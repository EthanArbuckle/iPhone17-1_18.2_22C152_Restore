uint64_t lzfse_stream_end(uint64_t a1)
{
  free(*(void **)(a1 + 32));
  *(void *)(a1 + 32) = 0;
  return 0;
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  state = stream->state;
  if (!state) {
    return -1;
  }
  char v3 = flags;
  src_ptr = stream->src_ptr;
  dst_ptr = stream->dst_ptr;
  int v7 = state[1];
  compression_status result = COMPRESSION_STATUS_ERROR;
  if (v7 > 2192)
  {
    if ((v7 - 2304) < 2)
    {
      compression_status result = lzvn_stream_process((uint64_t)stream, flags);
      if (result) {
        return result;
      }
      goto LABEL_23;
    }
    if (v7 == 2818)
    {
      compression_status result = brotli_stream_process((uint64_t)stream, flags);
      if (result) {
        return result;
      }
      goto LABEL_23;
    }
    if (v7 != 2193) {
      return result;
    }
LABEL_14:
    compression_status result = lzfse_stream_process((uint64_t)stream, flags);
    if (result) {
      return result;
    }
    goto LABEL_23;
  }
  if (v7 > 2048)
  {
    if ((v7 - 2049) >= 2) {
      return result;
    }
    goto LABEL_14;
  }
  switch(v7)
  {
    case 256:
      compression_status result = lz4_stream_process((uint64_t)stream, flags);
      if (result) {
        return result;
      }
      break;
    case 517:
      compression_status result = zlib_stream_process((void **)&stream->dst_ptr, flags);
      if (result) {
        return result;
      }
      break;
    case 774:
      compression_status result = lzma_stream_process(stream, flags);
      if (result) {
        return result;
      }
      break;
    default:
      return result;
  }
LABEL_23:
  if ((v3 & 1) != 0 && stream->src_ptr == src_ptr && stream->dst_ptr == dst_ptr) {
    return -1;
  }
  return result;
}

uint64_t lzfse_stream_process(uint64_t a1, char a2)
{
  int v2 = **(_DWORD **)(a1 + 32);
  if (v2 == 1) {
    return lzfseStreamDecode(a1, a2);
  }
  if (v2) {
    return 0xFFFFFFFFLL;
  }
  return lzfseStreamEncode(a1, a2);
}

uint64_t lzfseStreamDecode(uint64_t a1, char a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  int64x2_t v5 = *(int64x2_t *)(v4 + 48);
  *(void *)(v4 + 128) += v4;
  int64x2_t v6 = vdupq_n_s64(v4);
  *(int64x2_t *)(v4 + 48) = vaddq_s64(v6, v5);
  int64x2_t v7 = vaddq_s64(v6, *(int64x2_t *)(v4 + 80));
  *(int64x2_t *)(v4 + 64) = vaddq_s64(v6, *(int64x2_t *)(v4 + 64));
  *(int64x2_t *)(v4 + 80) = v7;
  int64x2_t v28 = v6;
  int64x2_t v8 = vaddq_s64(v6, *(int64x2_t *)(v4 + 16));
  *(int64x2_t *)(v4 + 16) = v8;
  *(void *)(v4 + 32) += v4;
  v9 = (char *)v8.i64[0];
  while (1)
  {
    uint64_t v10 = *(void *)(v4 + 64);
    if (*(void *)(a1 + 24) >= (unint64_t)&v9[-v10 + 786432]) {
      size_t v11 = (size_t)&v9[-v10 + 786432];
    }
    else {
      size_t v11 = *(void *)(a1 + 24);
    }
    if (v11)
    {
      memcpy(*(void **)(v4 + 64), *(const void **)(a1 + 16), v11);
      *(void *)(v4 + 64) += v11;
      size_t v12 = *(void *)(a1 + 24) - v11;
      *(void *)(a1 + 16) += v11;
      *(void *)(a1 + 24) = v12;
    }
    unint64_t v14 = *(void *)(v4 + 24);
    unint64_t v13 = *(void *)(v4 + 32);
    if (v13 >= v14 + 393216)
    {
      v15 = *(unsigned char **)(v4 + 72);
      v16 = v15 - 0x40000;
      if (v13 < (unint64_t)(v15 - 0x40000)) {
        v16 = *(char **)(v4 + 32);
      }
      if ((unint64_t)v16 >= v14) {
        v17 = v16;
      }
      else {
        v17 = *(unsigned char **)(v4 + 24);
      }
      if (v14 < (unint64_t)v16)
      {
        if (v15 != v17)
        {
          memmove(*(void **)(v4 + 80), v17, v15 - v17);
          unint64_t v13 = *(void *)(v4 + 32);
          v15 = *(unsigned char **)(v4 + 72);
        }
        *(void *)(v4 + 32) = v13 + v14 - (void)v17;
        *(void *)(v4 + 72) = &v15[v14 - (void)v17];
      }
    }
    if (!*(_DWORD *)(v4 + 40) && *(void *)(v4 + 72) < *(void *)(v4 + 88))
    {
      int v18 = lzfseDecode(v4 + 48);
      if (v18 == -1)
      {
        if (a2)
        {
LABEL_46:
          char v25 = 1;
          goto LABEL_41;
        }
      }
      else if (v18 == -3)
      {
        goto LABEL_46;
      }
      if (*(_DWORD *)(v4 + 96)) {
        *(_DWORD *)(v4 + 40) = 1;
      }
    }
    if (*(_DWORD *)(v4 + 44)) {
      goto LABEL_40;
    }
    v19 = *(char **)(v4 + 32);
    if (*(void *)(a1 + 8) >= *(void *)(v4 + 72) - (void)v19) {
      size_t v20 = *(void *)(v4 + 72) - (void)v19;
    }
    else {
      size_t v20 = *(void *)(a1 + 8);
    }
    if (v20)
    {
      memcpy(*(void **)a1, v19, v20);
      v19 = (char *)(*(void *)(v4 + 32) + v20);
      *(void *)(v4 + 32) = v19;
      size_t v21 = *(void *)(a1 + 8) - v20;
      *(void *)a1 += v20;
      *(void *)(a1 + 8) = v21;
    }
    if (*(_DWORD *)(v4 + 40) && v19 == *(char **)(v4 + 72)) {
      break;
    }
    if (*(_DWORD *)(v4 + 44))
    {
LABEL_40:
      char v25 = 0;
LABEL_41:
      v26 = *(char **)(v4 + 72);
      v19 = *(char **)(v4 + 32);
      goto LABEL_42;
    }
    v22 = *(char **)(v4 + 48);
    v9 = *(char **)(v4 + 16);
    if (v22 >= v9 + 393216)
    {
      uint64_t v23 = *(void *)(v4 + 64);
      uint64_t v24 = v23 - (void)v22;
      if (v23 - (uint64_t)v22 >= 1)
      {
        memmove(v9, v22, v23 - (void)v22);
        v9 = *(char **)(v4 + 16);
      }
      *(void *)(v4 + 48) = v9;
      *(void *)(v4 + 64) = &v9[v24];
    }
    char v25 = v20 | v11;
    if (!(v20 | v11)) {
      goto LABEL_41;
    }
  }
  char v25 = 0;
  *(_DWORD *)(v4 + 44) = 1;
  v26 = v19;
LABEL_42:
  *(void *)(v4 + 128) -= v4;
  *(int64x2_t *)(v4 + 48) = vsubq_s64(*(int64x2_t *)(v4 + 48), v28);
  *(void *)(v4 + 64) -= v4;
  *(void *)(v4 + 72) = &v26[-v4];
  *(int64x2_t *)(v4 + 80) = vsubq_s64(*(int64x2_t *)(v4 + 80), v28);
  *(int64x2_t *)(v4 + 16) = vsubq_s64(*(int64x2_t *)(v4 + 16), v28);
  *(void *)(v4 + 32) = &v19[-v4];
  if (v25) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(_DWORD *)(v4 + 44) != 0;
  }
}

uint64_t brotli_stream_process(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(v3 + 24) | a2 & 1;
  *(_DWORD *)(v3 + 24) = v4;
  uint64_t v5 = *(void *)(v3 + 16);
  if (*(_DWORD *)v3)
  {
    unsigned int v6 = BrotliDecoderDecompressStream(v5, (void *)(a1 + 24), (unsigned char **)(a1 + 16), (size_t *)(a1 + 8), (void **)a1, 0)- 1;
    if (v6 <= 2) {
      return dword_20DB0F060[v6];
    }
    return 0xFFFFFFFFLL;
  }
  if (!BrotliEncoderCompressStream(v5, 2 * (v4 != 0), (unint64_t *)(a1 + 24), (const void **)(a1 + 16), (size_t *)(a1 + 8), (void **)a1, 0))return 0xFFFFFFFFLL; {
  return *(_DWORD *)(v3 + 24) && BrotliEncoderIsFinished(*(void *)(v3 + 16));
  }
}

uint64_t BrotliDecoderDecompressStream(uint64_t a1, void *a2, unsigned char **a3, size_t *a4, void **a5, size_t *a6)
{
  int64x2_t v7 = a5;
  if (a6) {
    *a6 = *(void *)(a1 + 376);
  }
  if ((*(_DWORD *)(a1 + 116) & 0x80000000) != 0) {
    return 0;
  }
  if (*a4)
  {
    if (!a5 || !*a5)
    {
      return SaveErrorCode(a1, 0xFFFFFFEC);
    }
  }
  else
  {
    int64x2_t v7 = 0;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    unint64_t v13 = (unsigned char *)(a1 + 64);
    unsigned int HuffmanCode = 2;
  }
  else
  {
    *(void *)(a1 + 32) = *a2;
    unint64_t v13 = *a3;
    unsigned int HuffmanCode = 1;
  }
  v15 = (unint64_t *)(a1 + 8);
  uint64_t v16 = a1 + 64;
  *(void *)(a1 + 24) = v13;
  v163 = (unsigned int *)(a1 + 676);
  v164 = (unsigned __int8 **)(a1 + 680);
  v161 = (unsigned __int8 **)(a1 + 336);
  v162 = (unsigned int *)(a1 + 328);
  uint64_t v159 = a1 + 168;
  uint64_t v160 = a1 + 192;
  v17 = (void *)(a1 + 744);
  uint64_t v18 = a1 + 1288;
  uint64_t v157 = a1 + 952;
  uint64_t v158 = a1 + 216;
  v155 = (_OWORD *)(a1 + 712);
LABEL_16:
  while (2)
  {
    while (HuffmanCode == 1)
    {
      switch(*(_DWORD *)a1)
      {
        case 0:
          int v24 = BrotliWarmupBitReader(v15);
          unsigned int HuffmanCode = 2;
          if (!v24) {
            continue;
          }
          __int16 v25 = *(_WORD *)(a1 + 664);
          *(_WORD *)(a1 + 664) = v25 & 0xFFDF;
          unint64_t v26 = *(void *)(a1 + 8);
          int v27 = *(_DWORD *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v27 + 1;
          if (((v26 >> v27) & 1) == 0)
          {
            int v29 = 16;
            goto LABEL_175;
          }
          *(_DWORD *)(a1 + 16) = v27 + 4;
          int v28 = (v26 >> (v27 + 1)) & 7;
          if (v28)
          {
            int v29 = v28 + 17;
LABEL_175:
            *(_DWORD *)(a1 + 668) = v29;
            int v22 = 2;
            goto LABEL_179;
          }
          *(_DWORD *)(a1 + 16) = v27 + 7;
          int v138 = (v26 >> (v27 + 4)) & 7;
          if (!v138)
          {
            int v29 = 17;
            goto LABEL_175;
          }
          if (v138 != 1)
          {
            int v29 = v138 | 8;
            goto LABEL_175;
          }
          unsigned int HuffmanCode = -13;
          if ((v25 & 0x20) != 0)
          {
            *(_DWORD *)(a1 + 16) = v27 + 8;
            if (((v26 >> (v27 + 7)) & 1) == 0)
            {
              *(_WORD *)(a1 + 664) = v25 | 0x20;
              unsigned int HuffmanCode = 1;
              *(_DWORD *)a1 = 1;
            }
          }
          continue;
        case 1:
          int v30 = *(_DWORD *)(a1 + 16);
          if ((v30 - 59) >= 6)
          {
            unint64_t v34 = *v15;
          }
          else
          {
            uint64_t v31 = *(void *)(a1 + 32);
            unsigned int HuffmanCode = 2;
            if (!v31) {
              continue;
            }
            unint64_t v32 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v32 >> 8;
            v33 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v35 + 1) = *v33;
            *(void *)&long long v35 = v32;
            unint64_t v34 = v35 >> 8;
            *(void *)(a1 + 8) = v34;
            v30 -= 8;
            *(void *)(a1 + 24) = v33 + 1;
            *(void *)(a1 + 32) = v31 - 1;
          }
          uint64_t v36 = (v34 >> v30) & 0x3F;
          *(_DWORD *)(a1 + 668) = v36;
          *(_DWORD *)(a1 + 16) = v30 + 6;
          unsigned int HuffmanCode = -13;
          if ((v36 - 31) < 0xFFFFFFEB) {
            continue;
          }
          *(_DWORD *)a1 = 2;
LABEL_71:
          *(_DWORD *)(a1 + 80) = (1 << v36) - 16;
          uint64_t v57 = (*(uint64_t (**)(void, uint64_t))(a1 + 40))(*(void *)(a1 + 56), 12336);
          *(void *)(a1 + 240) = v57;
          unsigned int HuffmanCode = -30;
          if (!v57) {
            continue;
          }
          *(void *)(a1 + 248) = v57 + 7584;
          *(_DWORD *)a1 = 3;
LABEL_73:
          BrotliDecoderStateMetablockBegin(a1);
          *(_DWORD *)a1 = 4;
LABEL_74:
          unsigned int HuffmanCode = DecodeMetaBlockLength(a1, v15);
          if (HuffmanCode != 1) {
            continue;
          }
          __int16 v58 = *(_WORD *)(a1 + 664);
          if ((v58 & 6) == 0) {
            goto LABEL_79;
          }
          int v59 = *(_DWORD *)(a1 + 16);
          int v60 = -v59 & 7;
          if (v60)
          {
            uint64_t v61 = *(void *)(a1 + 8) >> v59;
            *(_DWORD *)(a1 + 16) = v60 + v59;
            unsigned int HuffmanCode = -14;
            if ((v61 & ~(-1 << v60)) != 0) {
              continue;
            }
          }
          if ((v58 & 4) != 0)
          {
            int v22 = 12;
            goto LABEL_179;
          }
LABEL_79:
          if (!*(_DWORD *)(a1 + 264)) {
            goto LABEL_178;
          }
          BrotliCalculateRingBufferSize(a1);
          if ((*(_WORD *)(a1 + 664) & 2) != 0)
          {
            int v22 = 11;
            goto LABEL_179;
          }
LABEL_81:
          int v51 = 0;
          *(void *)(a1 + 912) = v157;
          void *v17 = 0;
          *(void *)(a1 + 752) = 0;
          *(void *)a1 = 18;
LABEL_82:
          unsigned int HuffmanCode = DecodeVarLenUint8(a1, v15, (unsigned int *)(a1 + 4 * v51 + 284));
          if (HuffmanCode != 1) {
            continue;
          }
          ++*(_DWORD *)(a1 + 284 + 4 * *(int *)(a1 + 4));
          uint64_t v52 = *(int *)(a1 + 4);
          unsigned int v53 = *(_DWORD *)(a1 + 284 + 4 * v52);
          if (v53 <= 1)
          {
            *(_DWORD *)(a1 + 4) = v52 + 1;
            unsigned int HuffmanCode = 1;
            continue;
          }
          *(_DWORD *)a1 = 19;
LABEL_116:
          unsigned int HuffmanCode = ReadHuffmanCode(v53 + 2, v53 + 2, (int *)(*(void *)(a1 + 240) + 2528 * v52), 0, a1);
          if (HuffmanCode != 1) {
            continue;
          }
          *(_DWORD *)a1 = 20;
LABEL_118:
          unsigned int HuffmanCode = ReadHuffmanCode(26, 0x1Au, (int *)(*(void *)(a1 + 248) + 1584 * *(int *)(a1 + 4)), 0, a1);
          if (HuffmanCode != 1) {
            continue;
          }
          *(_DWORD *)a1 = 21;
LABEL_120:
          uint64_t v87 = *(int *)(a1 + 4);
          uint64_t v88 = *(void *)(a1 + 248);
          unsigned int v165 = 0;
          if (*(_DWORD *)(a1 + 660))
          {
            uint64_t v89 = *(unsigned int *)(a1 + 268);
            goto LABEL_131;
          }
          v90 = (unsigned char *)(v88 + 1584 * (int)v87);
          int v91 = *(_DWORD *)(a1 + 16);
          if ((v91 - 50) >= 0xF)
          {
            unint64_t v95 = *v15;
            goto LABEL_128;
          }
          uint64_t v92 = *(void *)(a1 + 32) - 1;
          while (v92 != -1)
          {
            unint64_t v93 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v93 >> 8;
            v94 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v96 + 1) = *v94;
            *(void *)&long long v96 = v93;
            unint64_t v95 = v96 >> 8;
            *(void *)(a1 + 8) = v95;
            int v97 = v91 - 8;
            *(_DWORD *)(a1 + 16) = v91 - 8;
            *(void *)(a1 + 24) = v94 + 1;
            *(void *)(a1 + 32) = v92--;
            LODWORD(v94) = v91 - 58;
            v91 -= 8;
            if (v94 >= 0xF)
            {
              int v91 = v97;
LABEL_128:
              unint64_t v98 = v95 >> v91;
              v99 = &v90[4 * (v95 >> v91)];
              unsigned int v100 = *v99;
              if (v100 >= 9)
              {
                v91 += 8;
                v99 += 4 * (BYTE1(v98) & ~(-1 << (v100 - 8)) & 0x7F)
                     + 4 * *(unsigned __int16 *)&v90[4 * v98 + 2];
                unsigned int v100 = *v99;
              }
              *(_DWORD *)(a1 + 16) = v91 + v100;
              uint64_t v89 = *((unsigned __int16 *)v99 + 1);
              goto LABEL_131;
            }
          }
          uint64_t v154 = v87;
          if (!SafeDecodeSymbol(v90, (uint64_t)v15, &v165)) {
            goto LABEL_182;
          }
          uint64_t v89 = v165;
          uint64_t v87 = v154;
LABEL_131:
          v101 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v89);
          unsigned int v102 = *((unsigned __int8 *)v101 + 2);
          int v103 = *v101;
          int v104 = *(_DWORD *)(a1 + 16);
          unsigned int v105 = 64 - v104;
          if (64 - v104 >= v102)
          {
            unint64_t v109 = *v15;
LABEL_137:
            *(_DWORD *)(a1 + 16) = v104 + v102;
            *(_DWORD *)(a1 + 4 * v87 + 272) = ((v109 >> v104) & ~(-1 << v102)) + v103;
            *(_DWORD *)(a1 + 660) = 0;
            ++*(_DWORD *)(a1 + 4);
            int v22 = 18;
            goto LABEL_179;
          }
          uint64_t v106 = *(void *)(a1 + 32) - 1;
          while (v106 != -1)
          {
            unint64_t v107 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v107 >> 8;
            v108 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v110 + 1) = *v108;
            *(void *)&long long v110 = v107;
            unint64_t v109 = v110 >> 8;
            *(void *)(a1 + 8) = v109;
            v104 -= 8;
            *(_DWORD *)(a1 + 16) = v104;
            *(void *)(a1 + 24) = v108 + 1;
            *(void *)(a1 + 32) = v106--;
            v105 += 8;
            if (v105 >= v102) {
              goto LABEL_137;
            }
          }
          *(_DWORD *)(a1 + 268) = v89;
          *(_DWORD *)(a1 + 660) = 1;
          goto LABEL_182;
        case 2:
          LODWORD(v36) = *(_DWORD *)(a1 + 668);
          goto LABEL_71;
        case 3:
          goto LABEL_73;
        case 4:
          goto LABEL_74;
        case 5:
          int v37 = *(_DWORD *)(a1 + 16);
          if ((v37 - 59) >= 6)
          {
            unint64_t v41 = *v15;
          }
          else
          {
            uint64_t v38 = *(void *)(a1 + 32);
            unsigned int HuffmanCode = 2;
            if (!v38) {
              continue;
            }
            unint64_t v39 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v39 >> 8;
            v40 = *(unsigned __int8 **)(a1 + 24);
            *((void *)&v42 + 1) = *v40;
            *(void *)&long long v42 = v39;
            unint64_t v41 = v42 >> 8;
            *(void *)(a1 + 8) = v41;
            v37 -= 8;
            *(void *)(a1 + 24) = v40 + 1;
            *(void *)(a1 + 32) = v38 - 1;
          }
          unint64_t v62 = v41 >> v37;
          *(_DWORD *)(a1 + 16) = v37 + 6;
          int v63 = (v41 >> v37) & 3;
          *(_DWORD *)(a1 + 320) = v63;
          *(_DWORD *)(a1 + 324) = ((v62 >> 2) & 0xF) << v63;
          uint64_t v64 = (*(uint64_t (**)(void, void))(a1 + 40))(*(void *)(a1 + 56), *(unsigned int *)(a1 + 284));
          *(void *)(a1 + 688) = v64;
          unsigned int HuffmanCode = -21;
          if (!v64) {
            continue;
          }
          LODWORD(i) = 0;
          *(void *)a1 = 6;
LABEL_88:
          LODWORD(v54) = *(_DWORD *)(a1 + 284);
          if ((int)i < (int)v54)
          {
            for (uint64_t i = (int)i; i < v54; ++i)
            {
              int v65 = *(_DWORD *)(a1 + 16);
              if ((v65 - 63) >= 2)
              {
                unint64_t v69 = *v15;
              }
              else
              {
                uint64_t v66 = *(void *)(a1 + 32);
                if (!v66)
                {
                  *(_DWORD *)(a1 + 4) = i;
LABEL_182:
                  unsigned int HuffmanCode = 2;
                  goto LABEL_16;
                }
                unint64_t v67 = *(void *)(a1 + 8);
                *(void *)(a1 + 8) = v67 >> 8;
                v68 = *(unsigned __int8 **)(a1 + 24);
                *((void *)&v70 + 1) = *v68;
                *(void *)&long long v70 = v67;
                unint64_t v69 = v70 >> 8;
                *(void *)(a1 + 8) = v69;
                v65 -= 8;
                *(void *)(a1 + 24) = v68 + 1;
                *(void *)(a1 + 32) = v66 - 1;
              }
              *(_DWORD *)(a1 + 16) = v65 + 2;
              *(unsigned char *)(*(void *)(a1 + 688) + i) = (v69 >> v65) & 3;
              uint64_t v54 = *(int *)(a1 + 284);
            }
          }
          *(_DWORD *)a1 = 22;
LABEL_96:
          unsigned int HuffmanCode = DecodeContextMap(v54 << 6, v163, v164, a1);
          if (HuffmanCode == 1)
          {
            _OWORD *v155 = 0u;
            v155[1] = 0u;
            uint64_t v71 = *(unsigned int *)(a1 + 284);
            if (v71)
            {
              unint64_t v72 = 0;
              v73 = *v164;
              do
              {
                int8x16x4_t v168 = vld4q_s8((const char *)v73);
                int8x16_t v74 = vld1q_dup_s8((const char *)v73);
                v168.val[0] = vorrq_s8(vorrq_s8(veorq_s8(v168.val[1], v74), veorq_s8(v168.val[0], v74)), vorrq_s8(veorq_s8(v168.val[2], v74), veorq_s8(v168.val[3], v74)));
                v168.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v168.val[0]);
                v168.val[2] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v168.val[1].i8);
                v168.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v168.val[0].i8);
                int8x16_t v75 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v168.val[0].i8);
                v168.val[1] = (int8x16_t)vmovl_high_u16((uint16x8_t)v168.val[1]);
                v168.val[0] = (int8x16_t)vmovl_high_u16((uint16x8_t)v168.val[0]);
                *(int8x8_t *)v168.val[0].i8 = vorr_s8(vorr_s8(vorr_s8(*(int8x8_t *)v75.i8, *(int8x8_t *)v168.val[2].i8), vorr_s8(*(int8x8_t *)v168.val[0].i8, *(int8x8_t *)v168.val[1].i8)), vorr_s8(vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v168.val[2], v168.val[2], 8uLL)), vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v168.val[0], v168.val[0], 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v168.val[1], v168.val[1], 8uLL))));
                v76.i64[0] = v168.val[0].u32[0];
                v76.i64[1] = v168.val[0].u32[1];
                if (!*(void *)&vorr_s8((int8x8_t)v168.val[0].u32[0], (int8x8_t)*(_OWORD *)&vextq_s8(v76, v76, 8uLL))) {
                  *(_DWORD *)(a1 + 4 * (v72 >> 5) + 712) |= 1 << v72;
                }
                ++v72;
                v73 += 64;
              }
              while (v71 != v72);
            }
            *(_DWORD *)a1 = 23;
LABEL_103:
            int v77 = *(_DWORD *)(a1 + 320);
            unsigned int v78 = *(_DWORD *)(a1 + 324);
            unsigned int v79 = v78 + 16;
            char v80 = v77 + 1;
            if ((*(_WORD *)(a1 + 664) & 0x20) != 0)
            {
              if (v78 > 0x7FFFFFFB)
              {
                int v81 = -2147483636;
              }
              else
              {
                int v81 = v78 + 16;
                char v82 = -1;
                int v83 = -5;
                unsigned int v84 = ((2147483644 - v78) >> v77) + 4;
                do
                {
                  ++v82;
                  v83 += 2;
                  BOOL v85 = v84 > 3;
                  v84 >>= 1;
                }
                while (v85);
                unsigned int v86 = (((((2147483644 - v78) >> v77) + 4) >> v82) & 1) + v83;
                if (v86 != -1) {
                  int v81 = v78 + ((v86 << v77) | ~(-1 << v77)) + 17;
                }
              }
              int v152 = v79 + (62 << v80);
              int v153 = v81;
            }
            else
            {
              int v152 = v79 + (24 << v80);
              int v153 = v152;
            }
            unsigned int HuffmanCode = DecodeContextMap(4 * *(_DWORD *)(a1 + 292), v162, v161, a1);
            if (HuffmanCode == 1)
            {
              v156 = v15;
              uint64_t v56 = v159;
              BOOL v150 = BrotliDecoderHuffmanTreeGroupInit(a1, v159, 256, 256, *(_DWORD *)(a1 + 676));
              int v151 = v150 & BrotliDecoderHuffmanTreeGroupInit(a1, v160, 704, 704, *(_DWORD *)(a1 + 288));
              if ((v151 & BrotliDecoderHuffmanTreeGroupInit(a1, v158, v152, v153, *(_DWORD *)(a1 + 328)) & 1) == 0)
              {
                uint64_t v149 = a1;
                unsigned int HuffmanCode = -22;
                return SaveErrorCode(v149, HuffmanCode);
              }
              int v55 = 0;
              *(void *)a1 = 24;
LABEL_141:
              if (*(_DWORD *)v17 == 1)
              {
                int v111 = *(_DWORD *)(a1 + 2540);
              }
              else
              {
                int v111 = 0;
                *(void *)(a1 + 2544) = *(void *)(v56 + 8);
                *(_DWORD *)(a1 + 2540) = 0;
                *(_DWORD *)(a1 + 744) = 1;
              }
              if (v111 >= *(unsigned __int16 *)(v56 + 20))
              {
LABEL_149:
                *(_DWORD *)(a1 + 744) = 0;
                *(_DWORD *)(a1 + 4) = v55 + 1;
                unsigned int HuffmanCode = 1;
                v15 = v156;
                if (v55 >= 2)
                {
                  *(_DWORD *)a1 = 25;
LABEL_151:
                  unint64_t v115 = *(unsigned int *)(a1 + 300);
                  uint64_t v116 = (v115 << 6);
                  uint64_t v117 = *(void *)(a1 + 680);
                  *(void *)(a1 + 152) = v117 + v116;
                  *(_DWORD *)(a1 + 256) = (*(_DWORD *)(a1 + ((v115 >> 3) & 0x1FFFFFFC) + 712) >> v115) & 1;
                  *(void *)(a1 + 344) = *(void *)(*(void *)(a1 + 168)
                                                    + 8 * *(unsigned __int8 *)(v117 + v116));
                  *(void *)(a1 + 144) = (char *)&_kBrotliContextLookupTable
                                        + 512 * (unint64_t)(*(unsigned char *)(*(void *)(a1 + 688) + v115) & 3);
                  *(void *)(a1 + 160) = *(void *)(a1 + 336);
                  *(void *)(a1 + 136) = **(void **)(a1 + 192);
                  int v118 = BrotliEnsureRingBuffer(a1);
                  unsigned int HuffmanCode = -27;
                  if (v118)
                  {
                    int v119 = *(_DWORD *)(a1 + 324);
                    if (v119)
                    {
                      for (int j = 0; j != v119; *(_DWORD *)(v18 + 4 * v121) = j)
                      {
                        unsigned int v121 = j + 16;
                        *((unsigned char *)v17 + v121) = 0;
                        ++j;
                      }
                      unsigned int v122 = j + 16;
                    }
                    else
                    {
                      unsigned int v122 = 16;
                    }
                    unsigned int v123 = *(unsigned __int16 *)(a1 + 234);
                    if (v122 < v123)
                    {
                      int v124 = 0;
                      int v125 = *(_DWORD *)(a1 + 320);
                      char v126 = 1;
                      do
                      {
                        unsigned int v127 = 1;
                        do
                        {
                          unsigned int v128 = v122 + v127 - 1;
                          *((unsigned char *)v17 + v128) = v126;
                          *(_DWORD *)(v18 + 4 * v128) = v119 + ((((v124 + 2) << v126) - 4) << v125) + v127;
                        }
                        while (!(v127++ >> v125));
                        v126 += v124;
                        v124 ^= 1u;
                        unsigned int v122 = v122 + v127 - 1;
                      }
                      while (v122 < v123);
                    }
                    *(_DWORD *)a1 = 7;
LABEL_164:
                    unsigned int HuffmanCode = ProcessCommands(a1);
                    if (HuffmanCode == 2) {
                      unsigned int HuffmanCode = SafeProcessCommands(a1);
                    }
                  }
                }
              }
              else
              {
                v112 = *(int **)(a1 + 2544);
                while (1)
                {
                  unsigned int v166 = 0;
                  unsigned int v113 = ReadHuffmanCode(*(unsigned __int16 *)(v56 + 16), *(unsigned __int16 *)(v56 + 18), v112, &v166, a1);
                  if (v113 != 1) {
                    break;
                  }
                  uint64_t v114 = *(int *)(a1 + 2540);
                  *(void *)(*(void *)v56 + 8 * v114) = *(void *)(a1 + 2544);
                  v112 = (int *)(*(void *)(a1 + 2544) + 4 * v166);
                  *(void *)(a1 + 2544) = v112;
                  *(_DWORD *)(a1 + 2540) = v114 + 1;
                  if ((int)v114 + 1 >= *(unsigned __int16 *)(v56 + 20))
                  {
                    int v55 = *(_DWORD *)(a1 + 4);
                    goto LABEL_149;
                  }
                }
                unsigned int HuffmanCode = v113;
                v15 = v156;
              }
            }
          }
          break;
        case 6:
          LODWORD(i) = *(_DWORD *)(a1 + 4);
          goto LABEL_88;
        case 7:
        case 8:
        case 9:
        case 0xA:
          goto LABEL_164;
        case 0xB:
          unsigned int HuffmanCode = CopyUncompressedBlockToOutput(a4, v7, a6, a1);
          if (HuffmanCode == 1) {
            *(_DWORD *)a1 = 14;
          }
          continue;
        case 0xC:
          int v44 = *(_DWORD *)(a1 + 264);
          if (v44 < 1) {
            goto LABEL_178;
          }
          int v45 = *(_DWORD *)(a1 + 16);
          int v46 = v44 + 1;
          do
          {
            if ((v45 - 57) <= 7)
            {
              uint64_t v47 = *(void *)(a1 + 32);
              if (!v47) {
                goto LABEL_182;
              }
              unint64_t v48 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v48 >> 8;
              v49 = *(unsigned __int8 **)(a1 + 24);
              *((void *)&v50 + 1) = *v49;
              *(void *)&long long v50 = v48;
              *(void *)(a1 + 8) = v50 >> 8;
              v45 -= 8;
              *(void *)(a1 + 24) = v49 + 1;
              *(void *)(a1 + 32) = v47 - 1;
            }
            v45 += 8;
            *(_DWORD *)(a1 + 16) = v45;
            *(_DWORD *)(a1 + 264) = v46 - 2;
            --v46;
          }
          while (v46 > 1);
LABEL_178:
          int v22 = 14;
          goto LABEL_179;
        case 0xD:
        case 0xF:
        case 0x10:
          unsigned int HuffmanCode = WriteRingBuffer(a1, a4, v7, a6, 0);
          if (HuffmanCode != 1) {
            continue;
          }
          WrapRingBuffer((void **)a1);
          if (*(_DWORD *)(a1 + 88) == 1 << *(_DWORD *)(a1 + 668)) {
            *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 80);
          }
          if (*(_DWORD *)a1 == 16)
          {
            int v22 = 10;
            goto LABEL_179;
          }
          if (*(_DWORD *)a1 == 15)
          {
            if (!*(_DWORD *)(a1 + 264)) {
              goto LABEL_178;
            }
            int v22 = 7;
            goto LABEL_179;
          }
          if (*(_DWORD *)(a1 + 4))
          {
            int v22 = 8;
            goto LABEL_179;
          }
          if (*(_DWORD *)(a1 + 264))
          {
            int v22 = 9;
            goto LABEL_179;
          }
          goto LABEL_178;
        case 0xE:
          unsigned int HuffmanCode = -10;
          if ((*(_DWORD *)(a1 + 264) & 0x80000000) != 0) {
            continue;
          }
          BrotliDecoderStateCleanupAfterMetablock(a1);
          if (*(_WORD *)(a1 + 664))
          {
            int v130 = *(_DWORD *)(a1 + 16);
            int v131 = -v130 & 7;
            if (!v131
              || (uint64_t v132 = *(void *)(a1 + 8) >> v130,
                  v130 += v131,
                  *(_DWORD *)(a1 + 16) = v130,
                  unsigned int HuffmanCode = -15,
                  (v132 & ~(-1 << v131)) == 0))
            {
              if (!*(_DWORD *)(a1 + 72))
              {
                uint64_t v133 = (64 - v130) >> 3;
                unsigned int v134 = (64 - v130) & 0xFFFFFFF8;
                uint64_t v135 = *(void *)(a1 + 32) + v133;
                v136 = (unsigned char *)(*(void *)(a1 + 24) - v133);
                *(void *)(a1 + 24) = v136;
                *(void *)(a1 + 32) = v135;
                if (v134 == 64) {
                  unint64_t v137 = 0;
                }
                else {
                  unint64_t v137 = *v15 << v134;
                }
                *(void *)(a1 + 8) = v137;
                *(_DWORD *)(a1 + 16) = v134 + v130;
                *a2 = v135;
                *a3 = v136;
              }
              *(_DWORD *)a1 = 26;
LABEL_193:
              if (!*(void *)(a1 + 120) || (unsigned int HuffmanCode = WriteRingBuffer(a1, a4, v7, a6, 1), HuffmanCode == 1))
              {
                uint64_t v149 = a1;
                unsigned int HuffmanCode = 1;
                return SaveErrorCode(v149, HuffmanCode);
              }
            }
          }
          else
          {
            int v22 = 3;
LABEL_179:
            *(_DWORD *)a1 = v22;
            unsigned int HuffmanCode = 1;
          }
          continue;
        case 0x11:
          goto LABEL_81;
        case 0x12:
          int v51 = *(_DWORD *)(a1 + 4);
          if (v51 < 3) {
            goto LABEL_82;
          }
          int v22 = 5;
          goto LABEL_179;
        case 0x13:
          uint64_t v52 = *(int *)(a1 + 4);
          unsigned int v53 = *(_DWORD *)(a1 + 4 * v52 + 284);
          goto LABEL_116;
        case 0x14:
          goto LABEL_118;
        case 0x15:
          goto LABEL_120;
        case 0x16:
          LODWORD(v54) = *(_DWORD *)(a1 + 284);
          goto LABEL_96;
        case 0x17:
          goto LABEL_103;
        case 0x18:
          int v55 = *(_DWORD *)(a1 + 4);
          v156 = v15;
          if (v55)
          {
            if (v55 == 2)
            {
              uint64_t v56 = v158;
            }
            else
            {
              uint64_t v56 = v160;
              if (v55 != 1)
              {
                uint64_t v149 = a1;
                unsigned int HuffmanCode = -31;
                return SaveErrorCode(v149, HuffmanCode);
              }
            }
          }
          else
          {
            uint64_t v56 = v159;
          }
          goto LABEL_141;
        case 0x19:
          goto LABEL_151;
        case 0x1A:
          goto LABEL_193;
        default:
          continue;
      }
    }
    if (HuffmanCode == 2)
    {
      if (*(void *)(a1 + 120) && (unsigned int v19 = WriteRingBuffer(a1, a4, v7, a6, 1), (v19 & 0x80000000) != 0))
      {
        unsigned int HuffmanCode = v19;
      }
      else
      {
        uint64_t v20 = *(unsigned int *)(a1 + 72);
        if (v20)
        {
          if (!*(void *)(a1 + 32))
          {
            *(_DWORD *)(a1 + 72) = 0;
            uint64_t v23 = *a2;
            *(void *)(a1 + 24) = *a3;
            *(void *)(a1 + 32) = v23;
            unsigned int HuffmanCode = 1;
            continue;
          }
          if (*a2)
          {
            *(unsigned char *)(v16 + v20) = **a3;
            uint64_t v21 = (*(_DWORD *)(a1 + 72) + 1);
            *(_DWORD *)(a1 + 72) = v21;
            *(void *)(a1 + 32) = v21;
            ++*a3;
            --*a2;
            unsigned int HuffmanCode = 1;
            continue;
          }
        }
        else
        {
          v139 = *(unsigned char **)(a1 + 24);
          uint64_t v140 = *(void *)(a1 + 32);
          *a3 = v139;
          *a2 = v140;
          if (v140)
          {
            unsigned int v141 = 0;
            do
            {
              *(unsigned char *)(v16 + v141) = *v139;
              unsigned int v141 = *(_DWORD *)(a1 + 72) + 1;
              *(_DWORD *)(a1 + 72) = v141;
              v139 = *a3 + 1;
              *a3 = v139;
            }
            while ((*a2)-- != 1);
          }
        }
        unsigned int HuffmanCode = 2;
      }
    }
    else if (*(_DWORD *)(a1 + 72))
    {
      *(_DWORD *)(a1 + 72) = 0;
    }
    else
    {
      int v143 = *(_DWORD *)(a1 + 16);
      uint64_t v144 = (64 - v143) >> 3;
      unsigned int v145 = (64 - v143) & 0xFFFFFFF8;
      uint64_t v146 = *(void *)(a1 + 32) + v144;
      v147 = (unsigned char *)(*(void *)(a1 + 24) - v144);
      *(void *)(a1 + 24) = v147;
      *(void *)(a1 + 32) = v146;
      if (v145 == 64) {
        unint64_t v148 = 0;
      }
      else {
        unint64_t v148 = *v15 << v145;
      }
      *(void *)(a1 + 8) = v148;
      *(_DWORD *)(a1 + 16) = v145 + v143;
      *a2 = v146;
      *a3 = v147;
    }
    break;
  }
  uint64_t v149 = a1;
  return SaveErrorCode(v149, HuffmanCode);
}

uint64_t ReadHuffmanCode(int a1, unsigned int a2, int *__src, _DWORD *a4, uint64_t a5)
{
  uint64_t v9 = a5 + 760;
  uint64_t v10 = (unint64_t *)(a5 + 8);
  int v11 = *(_DWORD *)(a5 + 752);
  size_t v12 = (unsigned __int16 *)(a5 + 2506);
  unint64_t v13 = (void *)(a5 + 2488);
  if (!v11)
  {
    int v14 = *(_DWORD *)(a5 + 16);
    if ((v14 - 63) >= 2)
    {
      unint64_t v18 = *v10;
    }
    else
    {
      uint64_t v15 = *(void *)(a5 + 32);
      if (!v15) {
        return 2;
      }
      unint64_t v16 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v16 >> 8;
      v17 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v19 + 1) = *v17;
      *(void *)&long long v19 = v16;
      unint64_t v18 = v19 >> 8;
      *(void *)(a5 + 8) = v18;
      v14 -= 8;
      *(void *)(a5 + 24) = v17 + 1;
      *(void *)(a5 + 32) = v15 - 1;
    }
    uint64_t v20 = (v18 >> v14) & 3;
    *(_DWORD *)(a5 + 756) = v20;
    int v21 = v14 + 2;
    *(_DWORD *)(a5 + 16) = v21;
    if (v20 != 1)
    {
      *(void *)(a5 + 772) = 0x2000000000;
      *(void *)(a5 + 2496) = 0;
      *(void *)(a5 + 2504) = 0;
      *unint64_t v13 = 0;
      *(void *)(a5 + 2510) = 0;
      int v11 = 4;
      *(_DWORD *)(a5 + 752) = 4;
      goto LABEL_8;
    }
LABEL_10:
    if ((v21 - 63) >= 2)
    {
      unint64_t v25 = *v10;
    }
    else
    {
      uint64_t v22 = *(void *)(a5 + 32);
      if (!v22)
      {
        int v48 = 1;
LABEL_156:
        *(_DWORD *)(a5 + 752) = v48;
        return 2;
      }
      unint64_t v23 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v23 >> 8;
      int v24 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v26 + 1) = *v24;
      *(void *)&long long v26 = v23;
      unint64_t v25 = v26 >> 8;
      *(void *)(a5 + 8) = v25;
      v21 -= 8;
      *(void *)(a5 + 24) = v24 + 1;
      *(void *)(a5 + 32) = v22 - 1;
    }
    *(_DWORD *)(a5 + 768) = (v25 >> v21) & 3;
    *(_DWORD *)(a5 + 16) = v21 + 2;
    *(_DWORD *)(a5 + 756) = 0;
LABEL_38:
    unsigned int v55 = 0;
    unsigned int v56 = a1 - 1;
    if (a1 != 1)
    {
      do
      {
        ++v55;
        BOOL v57 = v56 > 1;
        v56 >>= 1;
      }
      while (v57);
    }
    unsigned int v58 = *(_DWORD *)(a5 + 756);
    uint64_t v28 = *(unsigned int *)(a5 + 768);
    if (v58 <= v28)
    {
      int v63 = *(_DWORD *)(a5 + 16);
      do
      {
        unsigned int v64 = 64 - v63;
        if (64 - v63 >= v55)
        {
          unint64_t v68 = *v10;
        }
        else
        {
          uint64_t v65 = *(void *)(a5 + 32) - 1;
          do
          {
            if (v65 == -1)
            {
              *(_DWORD *)(a5 + 756) = v58;
              uint64_t result = 2;
              *(_DWORD *)(a5 + 752) = 2;
              return result;
            }
            unint64_t v66 = *(void *)(a5 + 8);
            *(void *)(a5 + 8) = v66 >> 8;
            unint64_t v67 = *(unsigned __int8 **)(a5 + 24);
            *((void *)&v69 + 1) = *v67;
            *(void *)&long long v69 = v66;
            unint64_t v68 = v69 >> 8;
            *(void *)(a5 + 8) = v68;
            v63 -= 8;
            *(_DWORD *)(a5 + 16) = v63;
            *(void *)(a5 + 24) = v67 + 1;
            *(void *)(a5 + 32) = v65--;
            v64 += 8;
          }
          while (v64 < v55);
        }
        unsigned int v70 = (v68 >> v63) & ~(-1 << v55);
        v63 += v55;
        *(_DWORD *)(a5 + 16) = v63;
        if (v70 >= a2) {
          return 4294967292;
        }
        *(_WORD *)(a5 + 2 * v58++ + 920) = v70;
      }
      while (v58 <= v28);
    }
    if (!v28) {
      goto LABEL_113;
    }
    uint64_t v59 = 0;
    do
    {
      uint64_t v60 = a5 + 2 * v59++;
      int v61 = *(unsigned __int16 *)(v60 + 920);
      unsigned int v62 = v59;
      do
      {
        if (v61 == *(unsigned __int16 *)(a5 + 2 * v62 + 920)) {
          return 4294967291;
        }
        ++v62;
      }
      while (v62 <= v28);
    }
    while (v59 != v28);
LABEL_15:
    if (v28 != 3)
    {
LABEL_113:
      int v106 = BrotliBuildSimpleHuffmanTable(__src, 8, (unsigned __int16 *)(a5 + 920), v28);
      if (a4) {
        *a4 = v106;
      }
      goto LABEL_153;
    }
    int v29 = *(_DWORD *)(a5 + 16);
    if (v29 != 64)
    {
      unint64_t v33 = *v10;
      goto LABEL_112;
    }
    uint64_t v30 = *(void *)(a5 + 32);
    if (v30)
    {
      unint64_t v31 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v31 >> 8;
      unint64_t v32 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v34 + 1) = *v32;
      *(void *)&long long v34 = v31;
      unint64_t v33 = v34 >> 8;
      *(void *)(a5 + 8) = v33;
      *(void *)(a5 + 24) = v32 + 1;
      *(void *)(a5 + 32) = v30 - 1;
      int v29 = 56;
LABEL_112:
      *(_DWORD *)(a5 + 16) = v29 + 1;
      LODWORD(v28) = ((v33 >> v29) & 1) + 3;
      *(_DWORD *)(a5 + 768) = v28;
      goto LABEL_113;
    }
    int v48 = 3;
    goto LABEL_156;
  }
LABEL_8:
  switch(v11)
  {
    case 1:
      int v21 = *(_DWORD *)(a5 + 16);
      goto LABEL_10;
    case 2:
      goto LABEL_38;
    case 3:
      LODWORD(v28) = *(_DWORD *)(a5 + 768);
      goto LABEL_15;
    case 4:
      int v35 = *(_DWORD *)(a5 + 772);
      int v36 = *(_DWORD *)(a5 + 776);
      uint64_t v37 = *(unsigned int *)(a5 + 756);
      if (v37 > 0x11) {
        goto LABEL_59;
      }
      int v38 = *(_DWORD *)(a5 + 16);
      break;
    case 5:
      unsigned int v134 = a2;
      uint64_t v135 = (unsigned __int16 *)(a5 + 2506);
      __srca = (char *)__src;
      uint64_t v133 = a4;
      unsigned int v49 = *(_DWORD *)(a5 + 768);
      int v50 = *(_DWORD *)(a5 + 772);
      int v51 = *(_DWORD *)(a5 + 776);
      int v52 = *(_DWORD *)(a5 + 764);
      LODWORD(v53) = *(_DWORD *)(a5 + 760);
      uint64_t v54 = *(void *)(a5 + 912);
      goto LABEL_67;
    default:
      return 4294967265;
  }
  do
  {
    uint64_t v39 = kCodeLengthCodeOrder[v37];
    if ((v38 - 61) >= 4)
    {
      unint64_t v43 = *v10;
      goto LABEL_25;
    }
    uint64_t v40 = *(void *)(a5 + 32);
    if (v40)
    {
      unint64_t v41 = *(void *)(a5 + 8);
      *(void *)(a5 + 8) = v41 >> 8;
      long long v42 = *(unsigned __int8 **)(a5 + 24);
      *((void *)&v44 + 1) = *v42;
      *(void *)&long long v44 = v41;
      unint64_t v43 = v44 >> 8;
      *(void *)(a5 + 8) = v43;
      v38 -= 8;
      *(void *)(a5 + 24) = v42 + 1;
      *(void *)(a5 + 32) = v40 - 1;
LABEL_25:
      uint64_t v45 = (v43 >> v38) & 0xF;
      unsigned int v46 = kCodeLengthPrefixLength[v45];
      goto LABEL_26;
    }
    if (v38 == 64) {
      uint64_t v45 = 0;
    }
    else {
      uint64_t v45 = *v10 >> v38;
    }
    unsigned int v46 = kCodeLengthPrefixLength[v45];
    if (64 - v38 < v46)
    {
      *(_DWORD *)(a5 + 756) = v37;
      *(_DWORD *)(a5 + 772) = v35;
      *(_DWORD *)(a5 + 776) = v36;
      int v48 = 4;
      goto LABEL_156;
    }
LABEL_26:
    unsigned int v47 = kCodeLengthPrefixValue[v45];
    v38 += v46;
    *(_DWORD *)(a5 + 16) = v38;
    *(unsigned char *)(a5 + v39 + 2488) = v47;
    if (((0x1111uLL >> v45) & 1) == 0)
    {
      v36 -= 0x20u >> v47;
      ++v35;
      ++*(_WORD *)(a5 + 2 * v47 + 2506);
      if ((v36 - 33) < 0xFFFFFFE0) {
        break;
      }
    }
    ++v37;
  }
  while (v37 != 18);
LABEL_59:
  if (v35 != 1 && v36 != 0) {
    return 4294967290;
  }
  unsigned int v134 = a2;
  __srca = (char *)__src;
  uint64_t v133 = a4;
  unint64_t v72 = v12;
  BrotliBuildCodeLengthsHuffmanTable(a5 + 780, (uint64_t)v13, v12);
  unint64_t v73 = 0;
  *(_OWORD *)unint64_t v72 = 0u;
  *((_OWORD *)v72 + 1) = 0u;
  uint64_t v135 = v72;
  int8x16_t v74 = (_OWORD *)(v9 + 1600);
  *(void *)&long long v75 = -1;
  *((void *)&v75 + 1) = -1;
  uint64_t v54 = *(void *)(a5 + 912);
  do
  {
    int32x2_t v76 = vdup_n_s32(v73);
    int64x2_t v77 = vaddq_s64(vdupq_n_s64(v73), (int64x2_t)xmmword_20DAD4320);
    *(int32x2_t *)&long long v78 = vmovn_s64(v77);
    *((int32x2_t *)&v78 + 1) = vadd_s32(v76, (int32x2_t)0xFFFFFFF3FFFFFFF2);
    int32x2_t v79 = vadd_s32(v76, (int32x2_t)0xFFFFFFF7FFFFFFF6);
    *(int32x2_t *)&long long v80 = vadd_s32(v76, (int32x2_t)0xFFFFFFF5FFFFFFF4);
    *((int32x2_t *)&v80 + 1) = v79;
    *int8x16_t v74 = v78;
    v74[1] = v80;
    v74 += 2;
    *(_OWORD *)(v54 + 2 * v77.i64[0]) = v75;
    v73 += 8;
  }
  while (v73 != 16);
  LODWORD(v53) = 0;
  int v50 = 0;
  unsigned int v49 = 0;
  *(_OWORD *)uint64_t v9 = xmmword_20DAD4330;
  int v51 = 0x8000;
  *(_DWORD *)(a5 + 776) = 0x8000;
  *(_DWORD *)(a5 + 752) = 5;
  int v52 = 8;
LABEL_67:
  uint64_t v81 = a5 + 2360;
  if (!BrotliWarmupBitReader(v10))
  {
    unsigned int v49 = *(_DWORD *)(a5 + 768);
    int v51 = *(_DWORD *)(a5 + 776);
    uint64_t v85 = (uint64_t)v135;
    unsigned int v82 = v134;
LABEL_116:
    if (v49 >= v82) {
      goto LABEL_149;
    }
    int v107 = 0;
    uint64_t v108 = a5 + 780;
    while (1)
    {
      if (!v51) {
        goto LABEL_151;
      }
      if (v107)
      {
        uint64_t v109 = *(void *)(a5 + 32);
        if (!v109) {
          return 2;
        }
        unint64_t v110 = *(void *)(a5 + 8);
        *(void *)(a5 + 8) = v110 >> 8;
        int v111 = *(unsigned __int8 **)(a5 + 24);
        *((void *)&v112 + 1) = *v111;
        *(void *)&long long v112 = v110;
        *(void *)(a5 + 8) = v112 >> 8;
        int v113 = *(_DWORD *)(a5 + 16) - 8;
        *(_DWORD *)(a5 + 16) = v113;
        *(void *)(a5 + 24) = v111 + 1;
        *(void *)(a5 + 32) = v109 - 1;
      }
      else
      {
        int v113 = *(_DWORD *)(a5 + 16);
      }
      if (v113 == 64) {
        LODWORD(v114) = 0;
      }
      else {
        unint64_t v114 = *v10 >> v113;
      }
      unsigned int v115 = *(unsigned __int8 *)(v108 + 4 * (v114 & 0x1F));
      if (64 - v113 < v115) {
        goto LABEL_127;
      }
      uint64_t v116 = *(unsigned __int16 *)(v108 + 4 * (v114 & 0x1F) + 2);
      if (v116 <= 0xF)
      {
        *(_DWORD *)(a5 + 16) = v113 + v115;
        uint64_t v117 = *(void *)(a5 + 912);
        *(_DWORD *)(a5 + 772) = 0;
        if (v116)
        {
          *(_WORD *)(v117 + 2 * *(int *)(v81 + 4 * v116)) = v49;
          *(_DWORD *)(v81 + 4 * v116) = v49;
          *(_DWORD *)(a5 + 764) = v116;
          v51 -= 0x8000u >> v116;
          *(_DWORD *)(a5 + 776) = v51;
          ++*(_WORD *)(v85 + 2 * v116);
        }
        int v107 = 0;
        *(_DWORD *)(a5 + 768) = ++v49;
        goto LABEL_148;
      }
      char v118 = v116 - 14;
      unsigned int v119 = v116 - 14 + v115;
      if (64 - v113 < v119)
      {
LABEL_127:
        int v107 = 1;
      }
      else
      {
        *(_DWORD *)(a5 + 16) = v119 + v113;
        if (v116 == 16)
        {
          unsigned int v120 = *(_DWORD *)(a5 + 764);
          char v121 = 2;
        }
        else
        {
          unsigned int v120 = 0;
          char v121 = 3;
        }
        if (*(_DWORD *)(a5 + 760) == v120)
        {
          int v122 = *(_DWORD *)(v9 + 12);
          if (v122) {
            int v123 = (v122 - 2) << v121;
          }
          else {
            int v123 = 0;
          }
        }
        else
        {
          int v123 = 0;
          int v122 = 0;
          *(_DWORD *)(a5 + 760) = v120;
        }
        unsigned int v124 = (v114 >> v115) & ~(-1 << v118);
        uint64_t v125 = *(void *)(a5 + 912);
        int v126 = v124 + v123 + 3;
        *(_DWORD *)(v9 + 12) = v126;
        int v127 = v126 - v122;
        unsigned int v128 = v126 - v122 + v49;
        if (v128 > v82)
        {
          *(_DWORD *)(a5 + 768) = v82;
          *(_DWORD *)(a5 + 776) = 0xFFFFF;
          return 4294967289;
        }
        if (v120)
        {
          int v129 = *(_DWORD *)(v81 + 4 * v120);
          int v130 = v123 + v124 - v122 + 3;
          do
          {
            *(_WORD *)(v125 + 2 * v129) = v49;
            int v129 = v49++;
            --v130;
          }
          while (v130);
          int v107 = 0;
          *(_DWORD *)(a5 + 768) = v128;
          *(_DWORD *)(v81 + 4 * v120) = v49 - 1;
          v51 -= v127 << (15 - v120);
          *(_DWORD *)(a5 + 776) = v51;
          *(_WORD *)(v85 + 2 * v120) += v127;
        }
        else
        {
          int v107 = 0;
          *(_DWORD *)(a5 + 768) = v128;
        }
        unsigned int v49 = v128;
      }
LABEL_148:
      if (v49 >= v82) {
        goto LABEL_149;
      }
    }
  }
  unsigned int v82 = v134;
  if (v49 >= v134 || v51 == 0)
  {
    uint64_t v85 = (uint64_t)v135;
    goto LABEL_74;
  }
  unint64_t v84 = *(void *)(a5 + 32);
  uint64_t v85 = (uint64_t)v135;
  while (2)
  {
    unint64_t v86 = v84 - 4;
    if (v84 < 4)
    {
      *(_DWORD *)(a5 + 768) = v49;
      *(_DWORD *)(a5 + 772) = v50;
      *(_DWORD *)(a5 + 764) = v52;
      *(_DWORD *)(a5 + 760) = v53;
      *(_DWORD *)(a5 + 776) = v51;
      goto LABEL_116;
    }
    unsigned int v87 = *(_DWORD *)(a5 + 16);
    unint64_t v88 = *(void *)(a5 + 8);
    if (v87 >= 0x20)
    {
      v87 ^= 0x20u;
      *(_DWORD *)(a5 + 16) = v87;
      uint64_t v89 = *(unsigned int **)(a5 + 24);
      *((void *)&v90 + 1) = *v89;
      *(void *)&long long v90 = v88;
      unint64_t v88 = v90 >> 32;
      *(void *)(a5 + 8) = v88;
      *(void *)(a5 + 24) = v89 + 1;
      *(void *)(a5 + 32) = v86;
      unint64_t v84 = v86;
    }
    int v91 = (unsigned __int8 *)(a5 + 780 + 4 * ((v88 >> v87) & 0x1F));
    unsigned int v92 = v87 + *v91;
    *(_DWORD *)(a5 + 16) = v92;
    uint64_t v93 = *((unsigned __int16 *)v91 + 1);
    if (v93 <= 0xF)
    {
      if (*((_WORD *)v91 + 1))
      {
        *(_WORD *)(v54 + 2 * *(int *)(v81 + 4 * v93)) = v49;
        *(_DWORD *)(v81 + 4 * v93) = v49;
        v51 -= 0x8000u >> v93;
        ++v135[v93];
        int v52 = v93;
      }
      int v50 = 0;
      ++v49;
      goto LABEL_107;
    }
    BOOL v94 = v93 == 16;
    if (v93 == 16) {
      int v95 = 2;
    }
    else {
      int v95 = 3;
    }
    int v96 = (v88 >> v92) & ~(-1 << v95);
    *(_DWORD *)(a5 + 16) = v95 + v92;
    if (v94) {
      unsigned int v97 = v52;
    }
    else {
      unsigned int v97 = 0;
    }
    int v98 = (v50 - 2) << v95;
    if (v50) {
      int v99 = v50;
    }
    else {
      int v99 = 0;
    }
    if (!v50) {
      int v98 = 0;
    }
    BOOL v100 = v53 == v97;
    if (v53 == v97) {
      uint64_t v53 = v53;
    }
    else {
      uint64_t v53 = v97;
    }
    if (v100)
    {
      int v101 = v98;
    }
    else
    {
      int v99 = 0;
      int v101 = 0;
    }
    int v50 = v96 + v101 + 3;
    int v102 = v50 - v99;
    unsigned int v103 = v50 - v99 + v49;
    if (v103 <= v134)
    {
      if (v53)
      {
        int v104 = *(_DWORD *)(v81 + 4 * v53);
        int v105 = v101 + v96 - v99 + 3;
        do
        {
          *(_WORD *)(v54 + 2 * v104) = v49;
          int v104 = v49++;
          --v105;
        }
        while (v105);
        *(_DWORD *)(v81 + 4 * v53) = v49 - 1;
        v51 -= v102 << (15 - v53);
        v135[v53] += v102;
      }
      unsigned int v49 = v103;
LABEL_107:
      if (v49 >= v134 || !v51) {
        goto LABEL_74;
      }
      continue;
    }
    break;
  }
  int v51 = 0xFFFFF;
LABEL_74:
  *(_DWORD *)(a5 + 776) = v51;
LABEL_149:
  if (v51) {
    return 4294967289;
  }
LABEL_151:
  int v131 = BrotliBuildHuffmanTable(__srca, 8, *(void *)(a5 + 912), v85);
  if (v133) {
    *uint64_t v133 = v131;
  }
LABEL_153:
  *(_DWORD *)(a5 + 752) = 0;
  return 1;
}

uint64_t BrotliWarmupBitReader(unint64_t *a1)
{
  if (*((_DWORD *)a1 + 2) != 64) {
    return 1;
  }
  unint64_t v1 = a1[3];
  if (v1)
  {
    unint64_t v2 = *a1;
    *a1 >>= 8;
    uint64_t v3 = (unsigned __int8 *)a1[2];
    *((void *)&v4 + 1) = *v3;
    *(void *)&long long v4 = v2;
    *a1 = v4 >> 8;
    *((_DWORD *)a1 + 2) = 56;
    a1[2] = (unint64_t)(v3 + 1);
    a1[3] = v1 - 1;
    return 1;
  }
  return 0;
}

uint64_t BrotliBuildHuffmanTable(char *__src, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = -1;
  do
    int v9 = *(__int16 *)(a3 + 2 * v8--);
  while (v9 == -1);
  unint64_t v10 = 0;
  int v11 = v8 + 17;
  uint64_t v12 = 1;
  uint64_t v13 = (1 << a2);
  if (v11 >= a2) {
    int v14 = a2;
  }
  else {
    int v14 = v11;
  }
  if (v11 >= a2) {
    int v15 = 1 << a2;
  }
  else {
    int v15 = 1 << v11;
  }
  uint64_t v16 = v14;
  int v17 = 2;
  unint64_t v18 = 0x8000000000000000;
  do
  {
    int v19 = *(unsigned __int16 *)(a4 + 2 * v12);
    if (*(_WORD *)(a4 + 2 * v12))
    {
      int v20 = v12 - 16;
      do
      {
        int v20 = *(unsigned __int16 *)(a3 + 2 * v20);
        int v21 = &__src[4 * __rbit64(v10)];
        int v22 = v15;
        do
        {
          *(_DWORD *)&v21[4 * (v22 - v17)] = v12 | (v20 << 16);
          v22 -= v17;
        }
        while (v22 > 0);
        v10 += v18;
        --v19;
      }
      while (v19);
    }
    v17 *= 2;
    v18 >>= 1;
  }
  while (v12++ < v16);
  if (v13 != v15)
  {
    do
    {
      memcpy(&__src[4 * v15], __src, 4 * v15);
      BOOL v24 = v13 == 2 * v15;
      v15 *= 2;
    }
    while (!v24);
  }
  if (v11 > a2)
  {
    unint64_t v25 = 0;
    uint64_t v26 = a2;
    uint64_t v27 = v11;
    char v28 = a2 + 1;
    uint64_t v29 = a4 + 2 * a2 + 2;
    unint64_t v30 = 0x8000000000000000;
    int v31 = 2;
    unint64_t v32 = __src;
    int v33 = 1 << a2;
    do
    {
      uint64_t v34 = v26 + 1;
      if (*(_WORD *)(a4 + 2 * (v26 + 1)))
      {
        int v35 = v26 - 15;
        do
        {
          if (!v25)
          {
            unsigned __int8 v36 = v26 + 1;
            if (v26 <= 13)
            {
              uint64_t v37 = 0;
              int v38 = 1 << (v34 - a2);
              while (1)
              {
                int v39 = v38 - *(unsigned __int16 *)(v29 + 2 * v37);
                if (v39 < 1) {
                  break;
                }
                int v38 = 2 * v39;
                ++v37;
                if (v26 + v37 >= 14)
                {
                  unsigned __int8 v36 = 15;
                  goto LABEL_30;
                }
              }
              unsigned __int8 v36 = v28 + v37;
            }
LABEL_30:
            v32 += 4 * v33;
            int v33 = 1 << (v36 - a2);
            uint64_t v13 = (v33 + v13);
            unint64_t v40 = __rbit64(v10);
            v10 += 0x8000000000000000 >> (a2 - 1);
            *(_DWORD *)&__src[4 * v40] = v36 | ((((v32 - __src) >> 2) - v40) << 16);
          }
          int v35 = *(unsigned __int16 *)(a3 + 2 * v35);
          unint64_t v41 = &v32[4 * __rbit64(v25)];
          int v42 = v33;
          do
          {
            *(_DWORD *)&v41[4 * (v42 - v31)] = (v34 - a2) | (v35 << 16);
            v42 -= v31;
          }
          while (v42 > 0);
          v25 += v30;
          __int16 v43 = *(_WORD *)(a4 + 2 * v34) - 1;
          *(_WORD *)(a4 + 2 * v34) = v43;
        }
        while (v43);
      }
      v31 *= 2;
      v30 >>= 1;
      ++v28;
      v29 += 2;
      ++v26;
    }
    while (v34 < v27);
  }
  return v13;
}

uint64_t BrotliBuildCodeLengthsHuffmanTable(uint64_t result, uint64_t a2, unsigned __int16 *a3)
{
  uint64_t v3 = 0;
  uint64_t v36 = *MEMORY[0x263EF8340];
  int v4 = a3[1] - 1;
  int v5 = v4 + a3[2] + a3[3];
  v34[2] = v4 + a3[2];
  v34[3] = v5;
  int v6 = v5 + a3[4];
  int v7 = v6 + a3[5];
  v34[4] = v6;
  v34[5] = v7;
  v34[0] = 17;
  v34[1] = v4;
  uint64_t v8 = a2 + 17;
  do
  {
    uint64_t v9 = *(unsigned __int8 *)(v8 + v3);
    uint64_t v10 = (int)v34[v9];
    v35[v10] = v3 + 17;
    v34[v9] = v10 - 1;
    uint64_t v11 = *(unsigned __int8 *)(v8 + v3 - 1);
    uint64_t v12 = (int)v34[v11];
    v34[v11] = v12 - 1;
    uint64_t v13 = *(unsigned __int8 *)(v8 + v3 - 2);
    uint64_t v14 = (int)v34[v13];
    v35[v12] = v3 + 16;
    v35[v14] = v3 + 15;
    v34[v13] = v14 - 1;
    uint64_t v15 = *(unsigned __int8 *)(v8 + v3 - 3);
    uint64_t v16 = (int)v34[v15];
    v34[v15] = v16 - 1;
    uint64_t v17 = *(unsigned __int8 *)(v8 + v3 - 4);
    uint64_t v18 = (int)v34[v17];
    v35[v16] = v3 + 14;
    v35[v18] = v3 + 13;
    v34[v17] = v18 - 1;
    uint64_t v19 = *(unsigned __int8 *)(v8 + v3 - 5);
    uint64_t v20 = (int)v34[v19];
    v34[v19] = v20 - 1;
    v35[v20] = v3 + 12;
    v3 -= 6;
  }
  while (v3 != -18);
  if (v34[0])
  {
    unint64_t v21 = 0;
    LODWORD(v22) = 0;
    int v23 = 2;
    unint64_t v24 = 0x8000000000000000;
    for (uint64_t i = 1; i != 6; ++i)
    {
      int v26 = a3[i];
      if (a3[i])
      {
        uint64_t v27 = -v23;
        uint64_t v22 = (int)v22;
        do
        {
          int v28 = i | (v35[v22] << 16);
          unint64_t v29 = result - 4 * v23 + 4 * __rbit64(v21);
          uint64_t v30 = 32;
          do
          {
            *(_DWORD *)(v29 + 4 * v30) = v28;
            BOOL v31 = __OFADD__(v30, v27);
            v30 += v27;
          }
          while (!((v30 < 0) ^ v31 | (v30 == 0)));
          ++v22;
          v21 += v24;
          --v26;
        }
        while (v26);
      }
      v23 *= 2;
      v24 >>= 1;
    }
  }
  else
  {
    uint64_t v32 = 0;
    int32x4_t v33 = vdupq_n_s32(v35[0] << 16);
    do
    {
      *(int32x4_t *)(result + v32) = v33;
      v32 += 16;
    }
    while (v32 != 128);
  }
  return result;
}

uint64_t WriteRingBuffer(uint64_t a1, size_t *a2, void **a3, size_t *a4, int a5)
{
  uint64_t v5 = *(int *)(a1 + 88);
  if (*(_DWORD *)(a1 + 76) >= (int)v5) {
    int v6 = *(_DWORD *)(a1 + 88);
  }
  else {
    int v6 = *(_DWORD *)(a1 + 76);
  }
  uint64_t v7 = *(void *)(a1 + 376);
  uint64_t v8 = *(void *)(a1 + 368) * v5 - v7;
  size_t v9 = v8 + v6;
  size_t v10 = *a2;
  if (*a2 >= v9) {
    size_t v11 = v8 + v6;
  }
  else {
    size_t v11 = *a2;
  }
  if ((*(_DWORD *)(a1 + 264) & 0x80000000) != 0) {
    return 4294967287;
  }
  if (!a3) {
    goto LABEL_13;
  }
  uint64_t v17 = (void *)(*(void *)(a1 + 120) + (v7 & *(int *)(a1 + 92)));
  if (!*a3)
  {
    *a3 = v17;
LABEL_13:
    size_t v18 = v10;
    goto LABEL_14;
  }
  memcpy(*a3, v17, v11);
  *a3 = (char *)*a3 + v11;
  size_t v18 = *a2;
LABEL_14:
  *a2 = v18 - v11;
  size_t v20 = *(void *)(a1 + 376) + v11;
  *(void *)(a1 + 376) = v20;
  if (a4) {
    *a4 = v20;
  }
  int v21 = *(_DWORD *)(a1 + 88);
  int v22 = 1 << *(_DWORD *)(a1 + 668);
  if (v9 <= v10)
  {
    if (v21 == v22)
    {
      int v24 = *(_DWORD *)(a1 + 76);
      BOOL v25 = __OFSUB__(v24, v21);
      int v26 = v24 - v21;
      if (v26 < 0 == v25)
      {
        *(_DWORD *)(a1 + 76) = v26;
        ++*(void *)(a1 + 368);
        *(_WORD *)(a1 + 664) = *(_WORD *)(a1 + 664) & 0xFFF7 | (8 * (v26 != 0));
      }
    }
    return 1;
  }
  else if (v21 != v22 && a5 == 0)
  {
    return 1;
  }
  else
  {
    return 3;
  }
}

uint64_t SaveErrorCode(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 116) = a2;
  if (a2 - 1 >= 3) {
    return 0;
  }
  else {
    return a2;
  }
}

uint64_t ProcessCommands(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 76);
  LODWORD(v3) = *(_DWORD *)(a1 + 4);
  if (*(void *)(a1 + 32) < 0x1CuLL) {
    goto LABEL_6;
  }
  int v123 = (unint64_t *)(a1 + 8);
  BrotliWarmupBitReader((unint64_t *)(a1 + 8));
  switch(*(_DWORD *)a1)
  {
    case 7:
      goto LABEL_10;
    case 8:
      goto LABEL_22;
    case 9:
      goto LABEL_57;
    case 0xA:
      uint64_t v4 = v2;
      break;
    default:
      return 4294967265;
  }
LABEL_101:
  uint64_t v115 = 0;
  int v116 = *(_DWORD *)(a1 + 88) - v2;
  while (1)
  {
    BOOL v117 = __OFSUB__(v3, 1);
    LODWORD(v3) = v3 - 1;
    if (((v3 & 0x80000000) != 0) != v117) {
      break;
    }
    *(unsigned char *)(v4 + v115 + *(void *)(a1 + 120)) = *(unsigned char *)(*(void *)(a1 + 120)
                                                             + (((int)v4 + (int)v115 - *(_DWORD *)(a1 + 360)) & *(_DWORD *)(a1 + 92)));
    if (v116 == ++v115)
    {
      int v2 = v4 + v115;
      int v118 = 16;
LABEL_123:
      *(_DWORD *)a1 = v118;
LABEL_125:
      uint64_t result = 1;
      goto LABEL_7;
    }
  }
  int v2 = v4 + v115;
  if (*(int *)(a1 + 264) < 1)
  {
    *(_DWORD *)a1 = 14;
    uint64_t result = 1;
    goto LABEL_7;
  }
  while (1)
  {
    while (1)
    {
LABEL_10:
      unint64_t v6 = *(void *)(a1 + 32);
      if (v6 < 0x1C)
      {
        *(_DWORD *)a1 = 7;
        goto LABEL_6;
      }
      int v7 = *(_DWORD *)(a1 + 276);
      if (v7) {
        break;
      }
      DecodeCommandBlockSwitch(a1);
    }
    uint64_t v8 = *(void *)(a1 + 136);
    unsigned int v9 = *(_DWORD *)(a1 + 16);
    unint64_t v10 = *(void *)(a1 + 8);
    if (v9 >= 0x30)
    {
      *(void *)(a1 + 8) = HIWORD(v10);
      v9 ^= 0x30u;
      size_t v11 = *(void **)(a1 + 24);
      *((void *)&v12 + 1) = *v11;
      *(void *)&long long v12 = v10;
      unint64_t v10 = v12 >> 48;
      *(void *)(a1 + 8) = v10;
      v6 -= 6;
      *(void *)(a1 + 24) = (char *)v11 + 6;
      *(void *)(a1 + 32) = v6;
    }
    unint64_t v13 = v10 >> v9;
    uint64_t v14 = (unsigned __int8 *)(v8 + 4 * (v10 >> v9));
    unsigned int v15 = *v14;
    if (v15 >= 9)
    {
      v9 += 8;
      v14 += 4 * ((v13 >> 8) & ~(-1 << (v15 - 8)))
           + 4 * *(unsigned __int16 *)(v8 + 4 * v13 + 2);
      unsigned int v15 = *v14;
    }
    unsigned int v16 = v9 + v15;
    *(_DWORD *)(a1 + 16) = v9 + v15;
    uint64_t v17 = (unsigned __int8 *)&kCmdLut + 8 * *((unsigned __int16 *)v14 + 1);
    int v18 = *v17;
    int v19 = v17[1];
    uint64_t v20 = v17[3];
    *(_DWORD *)(a1 + 360) = (char)v17[2];
    *(_DWORD *)(a1 + 260) = v20;
    int v21 = *((unsigned __int16 *)v17 + 2);
    int v22 = *((unsigned __int16 *)v17 + 3);
    *(unsigned char *)(a1 + 352) = *(unsigned char *)(*(void *)(a1 + 160) + v20);
    if (v18)
    {
      if (v16 >= 0x20)
      {
        v16 ^= 0x20u;
        *(_DWORD *)(a1 + 16) = v16;
        char v121 = *(unsigned int **)(a1 + 24);
        *((void *)&v122 + 1) = *v121;
        *(void *)&long long v122 = v10;
        unint64_t v10 = v122 >> 32;
        *(void *)(a1 + 8) = v10;
        v6 -= 4;
        *(void *)(a1 + 24) = v121 + 1;
        *(void *)(a1 + 32) = v6;
      }
      int v23 = (v10 >> v16) & ~(-1 << v18);
      v16 += v18;
    }
    else
    {
      int v23 = 0;
    }
    if (v16 >= 0x20)
    {
      v16 ^= 0x20u;
      *(_DWORD *)(a1 + 16) = v16;
      int v24 = *(unsigned int **)(a1 + 24);
      *((void *)&v25 + 1) = *v24;
      *(void *)&long long v25 = v10;
      unint64_t v10 = v25 >> 32;
      *(void *)(a1 + 8) = v10;
      *(void *)(a1 + 24) = v24 + 1;
      *(void *)(a1 + 32) = v6 - 4;
    }
    *(_DWORD *)(a1 + 16) = v16 + v19;
    *(_DWORD *)(a1 + 356) = ((v10 >> v16) & ~(-1 << v19)) + v22;
    *(_DWORD *)(a1 + 276) = v7 - 1;
    LODWORD(v3) = v23 + v21;
    if (v23 + v21) {
      break;
    }
LABEL_57:
    int v71 = *(_DWORD *)(a1 + 360);
    if (v71 < 0)
    {
      if (!*(_DWORD *)(a1 + 280)) {
        DecodeDistanceBlockSwitch(a1);
      }
      uint64_t v75 = *(void *)(*(void *)(a1 + 216) + 8 * *(unsigned __int8 *)(a1 + 352));
      unsigned int v76 = *(_DWORD *)(a1 + 16);
      unint64_t v77 = *(void *)(a1 + 8);
      if (v76 >= 0x30)
      {
        *(void *)(a1 + 8) = HIWORD(v77);
        v76 ^= 0x30u;
        long long v78 = *(void **)(a1 + 24);
        uint64_t v79 = *(void *)(a1 + 32);
        *((void *)&v80 + 1) = *v78;
        *(void *)&long long v80 = v77;
        unint64_t v77 = v80 >> 48;
        *(void *)(a1 + 8) = v77;
        *(void *)(a1 + 24) = (char *)v78 + 6;
        *(void *)(a1 + 32) = v79 - 6;
      }
      unint64_t v81 = v77 >> v76;
      unsigned int v82 = (unsigned __int8 *)(v75 + 4 * (v77 >> v76));
      unsigned int v83 = *v82;
      if (v83 >= 9)
      {
        v76 += 8;
        v82 += 4 * ((v81 >> 8) & ~(-1 << (v83 - 8)))
             + 4 * *(unsigned __int16 *)(v75 + 4 * v81 + 2);
        unsigned int v83 = *v82;
      }
      unsigned int v84 = v76 + v83;
      *(_DWORD *)(a1 + 16) = v76 + v83;
      uint64_t v85 = *((unsigned __int16 *)v82 + 1);
      --*(_DWORD *)(a1 + 280);
      *(_DWORD *)(a1 + 260) = 0;
      if (v85 > 0xF)
      {
        int v88 = *(unsigned __int8 *)(a1 + 744 + v85);
        if (v84 >= 0x20)
        {
          v84 ^= 0x20u;
          *(_DWORD *)(a1 + 16) = v84;
          uint64_t v89 = *(unsigned int **)(a1 + 24);
          uint64_t v90 = *(void *)(a1 + 32);
          *((void *)&v91 + 1) = *v89;
          *(void *)&long long v91 = v77;
          unint64_t v77 = v91 >> 32;
          *(void *)(a1 + 8) = v77;
          *(void *)(a1 + 24) = v89 + 1;
          *(void *)(a1 + 32) = v90 - 4;
        }
        unsigned int v72 = 0;
        *(_DWORD *)(a1 + 16) = v84 + v88;
        signed int v74 = (((v77 >> v84) & ~(-1 << v88)) << *(_DWORD *)(a1 + 320)) + *(_DWORD *)(a1 + 4 * v85 + 1288);
      }
      else
      {
        *(_DWORD *)(a1 + 360) = v85;
        if (v85 <= 3)
        {
          char v86 = ~(_BYTE)v85;
          unsigned int v72 = 1u >> v85;
          *(_DWORD *)(a1 + 260) = 1u >> v85;
          int v87 = *(_DWORD *)(a1 + 96);
          signed int v74 = *(_DWORD *)(a1 + 4 * (((_BYTE)v87 + v86) & 3) + 100);
          *(_DWORD *)(a1 + 360) = v74;
          *(_DWORD *)(a1 + 96) = v87 - v72;
          goto LABEL_80;
        }
        unsigned int v72 = 0;
        if (v85 >= 0xA) {
          char v92 = -10;
        }
        else {
          char v92 = -4;
        }
        if (v85 >= 0xA) {
          char v93 = 2;
        }
        else {
          char v93 = 3;
        }
        signed int v74 = ((0x605142u >> (4 * (v92 + v85))) & 7)
            + *(_DWORD *)(a1 + 4 * ((*(_DWORD *)(a1 + 96) + v93) & 3) + 100)
            - 3;
        if (v74 < 1) {
          signed int v74 = 0x7FFFFFFF;
        }
      }
    }
    else
    {
      unsigned int v72 = v71 == 0;
      *(_DWORD *)(a1 + 260) = v72;
      int v73 = *(_DWORD *)(a1 + 96) - 1;
      *(_DWORD *)(a1 + 96) = v73;
      signed int v74 = *(_DWORD *)(a1 + 4 * (v73 & 3) + 100);
    }
    *(_DWORD *)(a1 + 360) = v74;
LABEL_80:
    int v95 = *(_DWORD *)(a1 + 80);
    signed int v94 = *(_DWORD *)(a1 + 84);
    if (v94 != v95)
    {
      if (v2 >= v95) {
        signed int v94 = *(_DWORD *)(a1 + 80);
      }
      else {
        signed int v94 = v2;
      }
      *(_DWORD *)(a1 + 84) = v94;
    }
    size_t v3 = *(unsigned int *)(a1 + 356);
    if (v74 <= v94)
    {
      int v106 = *(_DWORD *)(a1 + 96);
      int v107 = *(_DWORD *)(a1 + 92) & (v2 - v74);
      uint64_t v108 = *(void *)(a1 + 120);
      uint64_t v4 = v2;
      uint64_t v109 = (_OWORD *)(v108 + v2);
      unint64_t v110 = (_OWORD *)(v108 + v107);
      int v111 = v3 + v2;
      *(_DWORD *)(a1 + 4 * (v106 & 3) + 100) = v74;
      *(_DWORD *)(a1 + 96) = v106 + 1;
      *(_DWORD *)(a1 + 264) -= v3;
      *uint64_t v109 = *v110;
      if (v107 + (int)v3 > v2 && v111 > v107) {
        goto LABEL_101;
      }
      int v113 = *(_DWORD *)(a1 + 88);
      if (v111 >= v113 || v107 + (int)v3 >= v113) {
        goto LABEL_101;
      }
      if ((int)v3 >= 17)
      {
        unsigned int v119 = v109 + 1;
        unsigned int v120 = v110 + 1;
        if (v3 < 0x21) {
          *unsigned int v119 = *v120;
        }
        else {
          memcpy(v119, v120, (v3 - 16));
        }
      }
    }
    else
    {
      if (v74 > 2147483644) {
        return 4294967280;
      }
      if ((v3 - 4) > 0x14) {
        return 4294967284;
      }
      uint64_t v96 = *(void *)(a1 + 696);
      uint64_t v97 = *(void *)(a1 + 704);
      uint64_t v98 = *(int *)(v96 + 4 * v3 + 32);
      char v99 = *(unsigned char *)(v96 + v3);
      *(_DWORD *)(a1 + 96) += v72;
      uint64_t v100 = *(void *)(v96 + 168);
      if (!v100) {
        return 4294967277;
      }
      int v101 = v74 + ~v94;
      int v102 = v101 >> v99;
      if (v101 >> v99 >= *(_DWORD *)(v97 + 24)) {
        return 4294967285;
      }
      unsigned int v103 = (void *)(v100 + v98 + (v101 & ~(-1 << v99)) * (int)v3);
      int v104 = (void *)(*(void *)(a1 + 120) + v2);
      if (v102 == *(__int16 *)(v97 + 48))
      {
        memcpy(v104, v103, v3);
        int v105 = v3;
      }
      else
      {
        int v105 = BrotliTransformDictionaryWord((uint64_t)v104, (char *)v103, v3, (void *)v97, v102);
      }
      v2 += v105;
      *(_DWORD *)(a1 + 264) -= v105;
      if (v2 >= *(_DWORD *)(a1 + 88))
      {
        int v118 = 15;
        goto LABEL_123;
      }
      int v111 = v2;
    }
    if (*(int *)(a1 + 264) <= 0)
    {
      *(_DWORD *)a1 = 14;
      uint64_t result = 1;
      int v2 = v111;
      goto LABEL_7;
    }
    int v2 = v111;
  }
  *(_DWORD *)(a1 + 264) -= v3;
LABEL_22:
  int v26 = v2;
  if (*(_DWORD *)(a1 + 256))
  {
LABEL_23:
    unsigned int v27 = *(_DWORD *)(a1 + 16);
    unint64_t v28 = *(void *)(a1 + 8);
    if (v27 >= 0x38)
    {
      *(void *)(a1 + 8) = HIBYTE(v28);
      v27 ^= 0x38u;
      *(_DWORD *)(a1 + 16) = v27;
      unint64_t v29 = *(void **)(a1 + 24);
      uint64_t v30 = *(void *)(a1 + 32);
      *((void *)&v31 + 1) = *v29;
      *(void *)&long long v31 = v28;
      unint64_t v28 = v31 >> 56;
      *(void *)(a1 + 8) = v28;
      *(void *)(a1 + 24) = (char *)v29 + 7;
      *(void *)(a1 + 32) = v30 - 7;
    }
    uint64_t v32 = 0;
    int32x4_t v33 = (unsigned __int8 *)(*(void *)(a1 + 344) + 4 * (v28 >> v27));
    unsigned int v34 = *v33;
    uint64_t v35 = *((unsigned __int16 *)v33 + 1);
    int v36 = v26;
    while (*(void *)(a1 + 32) > 0x1BuLL)
    {
      if (*(_DWORD *)(a1 + 272))
      {
        uint64_t v37 = *(void *)(a1 + 344);
      }
      else
      {
        DecodeLiteralBlockSwitch(a1);
        unsigned int v46 = *(_DWORD *)(a1 + 16);
        unint64_t v47 = *(void *)(a1 + 8);
        if (v46 >= 0x38)
        {
          *(void *)(a1 + 8) = HIBYTE(v47);
          v46 ^= 0x38u;
          *(_DWORD *)(a1 + 16) = v46;
          int v48 = *(void **)(a1 + 24);
          uint64_t v49 = *(void *)(a1 + 32);
          *((void *)&v50 + 1) = *v48;
          *(void *)&long long v50 = v47;
          unint64_t v47 = v50 >> 56;
          *(void *)(a1 + 8) = v47;
          *(void *)(a1 + 24) = (char *)v48 + 7;
          *(void *)(a1 + 32) = v49 - 7;
        }
        int v51 = *(_DWORD *)(a1 + 256);
        if (!v51)
        {
LABEL_54:
          int v26 = v36 + v32;
          LODWORD(v3) = v3 - v32;
          if (v51) {
            goto LABEL_23;
          }
          goto LABEL_43;
        }
        uint64_t v37 = *(void *)(a1 + 344);
        int v52 = (unsigned __int8 *)(v37 + 4 * (v47 >> v46));
        unsigned int v34 = *v52;
        uint64_t v35 = *((unsigned __int16 *)v52 + 1);
      }
      unsigned int v38 = *(_DWORD *)(a1 + 16);
      if (v34 >= 9)
      {
        unint64_t v41 = *v123;
        if (v38 >= 0x30)
        {
          *(void *)(a1 + 8) = HIWORD(v41);
          v38 ^= 0x30u;
          uint64_t v53 = *(void **)(a1 + 24);
          uint64_t v54 = *(void *)(a1 + 32);
          *((void *)&v55 + 1) = *v53;
          *(void *)&long long v55 = v41;
          unint64_t v41 = v55 >> 48;
          *(void *)(a1 + 8) = v41;
          *(void *)(a1 + 24) = (char *)v53 + 6;
          *(void *)(a1 + 32) = v54 - 6;
        }
        unsigned int v56 = (unsigned __int8 *)(v37
                                + 4 * (v41 >> v38)
                                + 4 * v35
                                + 4 * (((v41 >> v38) >> 8) & ~(-1 << (v34 - 8))));
        unsigned int v39 = v38 + *v56 + 8;
        *(_DWORD *)(a1 + 16) = v39;
        unsigned __int8 v40 = v56[2];
      }
      else
      {
        unsigned int v39 = v38 + v34;
        *(_DWORD *)(a1 + 16) = v39;
        unsigned __int8 v40 = v35;
        unint64_t v41 = *(void *)(a1 + 8);
      }
      if (v39 >= 0x38)
      {
        *(void *)(a1 + 8) = HIBYTE(v41);
        v39 ^= 0x38u;
        *(_DWORD *)(a1 + 16) = v39;
        int v42 = *(void **)(a1 + 24);
        uint64_t v43 = *(void *)(a1 + 32);
        *((void *)&v44 + 1) = *v42;
        *(void *)&long long v44 = v41;
        unint64_t v41 = v44 >> 56;
        *(void *)(a1 + 8) = v41;
        *(void *)(a1 + 24) = (char *)v42 + 7;
        *(void *)(a1 + 32) = v43 - 7;
      }
      uint64_t v45 = (unsigned __int8 *)(v37 + 4 * (v41 >> v39));
      unsigned int v34 = *v45;
      uint64_t v35 = *((unsigned __int16 *)v45 + 1);
      *(unsigned char *)(*(void *)(a1 + 120) + v26 + v32) = v40;
      --*(_DWORD *)(a1 + 272);
      int v2 = *(_DWORD *)(a1 + 88);
      if (v26 + v32 + 1 == v2)
      {
LABEL_124:
        *(_DWORD *)a1 = 13;
        LODWORD(v3) = ~v32 + v3;
        goto LABEL_125;
      }
      if (v3 == ++v32)
      {
LABEL_56:
        int v2 = v26 + v32;
        if (*(int *)(a1 + 264) > 0) {
          goto LABEL_57;
        }
        LODWORD(v3) = 0;
        int v118 = 14;
        goto LABEL_123;
      }
    }
  }
  else
  {
LABEL_43:
    uint64_t v32 = 0;
    uint64_t v57 = *(void *)(a1 + 120);
    int v36 = v26;
    uint64_t v58 = *(int *)(a1 + 92);
    uint64_t v59 = *(unsigned __int8 *)(v57 + (v58 & (v26 - 1)));
    uint64_t v60 = *(unsigned __int8 *)(v57 + (v58 & (v26 - 2)));
    while (1)
    {
      uint64_t v61 = v59;
      if (*(void *)(a1 + 32) <= 0x1BuLL) {
        break;
      }
      if (!*(_DWORD *)(a1 + 272))
      {
        DecodeLiteralBlockSwitch(a1);
        int v51 = *(_DWORD *)(a1 + 256);
        if (v51) {
          goto LABEL_54;
        }
      }
      uint64_t v62 = *(void *)(*(void *)(a1 + 168)
                      + 8
                      * *(unsigned __int8 *)(*(void *)(a1 + 152)
                                           + (*(unsigned char *)(*(void *)(a1 + 144) + v60 + 256) | *(unsigned char *)(*(void *)(a1 + 144) + v61))));
      unsigned int v63 = *(_DWORD *)(a1 + 16);
      unint64_t v64 = *(void *)(a1 + 8);
      if (v63 >= 0x30)
      {
        *(void *)(a1 + 8) = HIWORD(v64);
        v63 ^= 0x30u;
        uint64_t v65 = *(void **)(a1 + 24);
        uint64_t v66 = *(void *)(a1 + 32);
        *((void *)&v67 + 1) = *v65;
        *(void *)&long long v67 = v64;
        unint64_t v64 = v67 >> 48;
        *(void *)(a1 + 8) = v64;
        *(void *)(a1 + 24) = (char *)v65 + 6;
        *(void *)(a1 + 32) = v66 - 6;
      }
      unint64_t v68 = v64 >> v63;
      long long v69 = (unsigned __int8 *)(v62 + 4 * (v64 >> v63));
      unsigned int v70 = *v69;
      if (v70 >= 9)
      {
        v63 += 8;
        v69 += 4 * ((v68 >> 8) & ~(-1 << (v70 - 8)))
             + 4 * *(unsigned __int16 *)(v62 + 4 * v68 + 2);
        unsigned int v70 = *v69;
      }
      *(_DWORD *)(a1 + 16) = v63 + v70;
      uint64_t v59 = v69[2];
      *(unsigned char *)(*(void *)(a1 + 120) + v26 + v32) = v59;
      --*(_DWORD *)(a1 + 272);
      int v2 = *(_DWORD *)(a1 + 88);
      if (v26 + v32 + 1 == v2) {
        goto LABEL_124;
      }
      ++v32;
      uint64_t v60 = v61;
      if (v3 == v32) {
        goto LABEL_56;
      }
    }
  }
  int v2 = v26 + v32;
  *(_DWORD *)a1 = 8;
  LODWORD(v3) = v3 - v32;
LABEL_6:
  uint64_t result = 2;
LABEL_7:
  *(_DWORD *)(a1 + 76) = v2;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

uint64_t BrotliTransformDictionaryWord(uint64_t a1, char *a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v5 = a3;
  uint64_t v8 = a4[1];
  uint64_t v7 = a4[2];
  uint64_t v9 = a4[4];
  uint64_t v10 = 3 * a5;
  uint64_t v11 = *(unsigned __int16 *)(v7 + 2 * *(unsigned __int8 *)(v9 + v10));
  uint64_t v12 = v9 + (int)v10;
  int v13 = *(unsigned __int8 *)(v12 + 1);
  uint64_t v14 = *(unsigned __int16 *)(v7 + 2 * *(unsigned __int8 *)(v12 + 2));
  int v15 = *(unsigned __int8 *)(v8 + v11);
  if (*(unsigned char *)(v8 + v11))
  {
    uint64_t v16 = 0;
    uint64_t v17 = v11 + v8 + 1;
    do
    {
      *(unsigned char *)(a1 + v16) = *(unsigned char *)(v17 + v16);
      ++v16;
    }
    while (v15 != v16);
  }
  else
  {
    uint64_t v16 = 0;
  }
  if (v13 > 9)
  {
    if ((v13 - 12) <= 8)
    {
      uint64_t v18 = (v13 - 11);
      a2 += v18;
      uint64_t v5 = (a3 - v18);
    }
  }
  else
  {
    uint64_t v5 = (a3 - v13);
  }
  if ((int)v5 >= 1)
  {
    uint64_t v16 = v16;
    uint64_t v19 = v5;
    do
    {
      char v20 = *a2++;
      *(unsigned char *)(a1 + v16++) = v20;
      --v19;
    }
    while (v19);
  }
  if (v13 > 20)
  {
    if (v13 == 21)
    {
      Shift((char *)(a1 - (int)v5 + (int)v16), v5, *(unsigned __int8 *)(a4[5] + 2 * a5) | (*(unsigned __int8 *)(a4[5] + 2 * a5 + 1) << 8));
    }
    else if (v13 == 22 && (int)v5 >= 1)
    {
      long long v25 = (char *)(a1 - (int)v5 + (int)v16);
      __int16 v26 = *(unsigned __int8 *)(a4[5] + 2 * a5) | (*(unsigned __int8 *)(a4[5] + 2 * a5 + 1) << 8);
      do
      {
        int v27 = Shift(v25, v5, v26);
        v25 += v27;
        BOOL v24 = __OFSUB__(v5, v27);
        uint64_t v5 = (v5 - v27);
      }
      while (!(((int)v5 < 0) ^ v24 | (v5 == 0)));
    }
  }
  else if (v13 == 10)
  {
    unint64_t v28 = (unsigned __int8 *)(a1 - (int)v5 + (int)v16);
    unsigned int v29 = *v28;
    if (v29 > 0xBF)
    {
      if (v29 > 0xDF) {
        v28[2] ^= 5u;
      }
      else {
        v28[1] ^= 0x20u;
      }
    }
    else if (v29 - 97 <= 0x19)
    {
      *unint64_t v28 = v29 ^ 0x20;
    }
  }
  else if (v13 == 11 && (int)v5 >= 1)
  {
    int v21 = (unsigned __int8 *)(a1 - (int)v5 + (int)v16);
    do
    {
      unsigned int v22 = *v21;
      if (v22 > 0xBF)
      {
        if (v22 > 0xDF)
        {
          v21[2] ^= 5u;
          unsigned int v23 = 3;
        }
        else
        {
          v21[1] ^= 0x20u;
          unsigned int v23 = 2;
        }
      }
      else
      {
        if (v22 - 97 <= 0x19) {
          *int v21 = v22 ^ 0x20;
        }
        unsigned int v23 = 1;
      }
      v21 += v23;
      BOOL v24 = __OFSUB__(v5, v23);
      LODWORD(v5) = v5 - v23;
    }
    while (!(((int)v5 < 0) ^ v24 | (v5 == 0)));
  }
  int v30 = *(unsigned __int8 *)(v8 + v14);
  if (*(unsigned char *)(v8 + v14))
  {
    uint64_t v16 = v16;
    long long v31 = (char *)(v14 + v8 + 1);
    do
    {
      char v32 = *v31++;
      *(unsigned char *)(a1 + v16++) = v32;
      --v30;
    }
    while (v30);
  }
  return v16;
}

uint64_t DecodeCommandBlockSwitch(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 288);
  if (v1 >= 2)
  {
    uint64_t v2 = *(void *)(result + 240) + 2528;
    unsigned int v3 = *(_DWORD *)(result + 16);
    unint64_t v4 = *(void *)(result + 8);
    if (v3 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v3 ^= 0x30u;
      *(_DWORD *)(result + 16) = v3;
      uint64_t v5 = *(void **)(result + 24);
      uint64_t v6 = *(void *)(result + 32);
      *((void *)&v7 + 1) = *v5;
      *(void *)&long long v7 = v4;
      unint64_t v4 = v7 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v5 + 6;
      *(void *)(result + 32) = v6 - 6;
    }
    unint64_t v8 = v4 >> v3;
    uint64_t v9 = (unsigned __int8 *)(v2 + 4 * (v4 >> v3));
    unsigned int v10 = *v9;
    if (v10 >= 9)
    {
      v3 += 8;
      v9 += 4 * ((v8 >> 8) & ~(-1 << (v10 - 8)))
          + 4 * *(unsigned __int16 *)(v2 + 4 * v8 + 2);
      unsigned int v10 = *v9;
    }
    uint64_t v11 = *(void *)(result + 248) + 1584;
    unsigned int v12 = v3 + v10;
    int v13 = *((unsigned __int16 *)v9 + 1);
    if (v12 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v12 ^= 0x30u;
      uint64_t v14 = *(void **)(result + 24);
      uint64_t v15 = *(void *)(result + 32);
      *((void *)&v16 + 1) = *v14;
      *(void *)&long long v16 = v4;
      unint64_t v4 = v16 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v14 + 6;
      *(void *)(result + 32) = v15 - 6;
    }
    unint64_t v17 = v4 >> v12;
    uint64_t v18 = (unsigned __int8 *)(v11 + 4 * (v4 >> v12));
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v12 += 8;
      v18 += 4 * ((v17 >> 8) & ~(-1 << (v19 - 8)))
           + 4 * *(unsigned __int16 *)(v11 + 4 * v17 + 2);
      unsigned int v19 = *v18;
    }
    unsigned int v20 = v12 + v19;
    int v21 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * *((unsigned __int16 *)v18 + 1));
    int v22 = *((unsigned __int8 *)v21 + 2);
    int v23 = *v21;
    if (v20 >= 0x20)
    {
      v20 ^= 0x20u;
      *(_DWORD *)(result + 16) = v20;
      BOOL v24 = *(unsigned int **)(result + 24);
      uint64_t v25 = *(void *)(result + 32);
      *((void *)&v26 + 1) = *v24;
      *(void *)&long long v26 = v4;
      unint64_t v4 = v26 >> 32;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = v24 + 1;
      *(void *)(result + 32) = v25 - 4;
    }
    *(_DWORD *)(result + 16) = v20 + v22;
    *(_DWORD *)(result + 276) = ((v4 >> v20) & ~(-1 << v22)) + v23;
    if (v13)
    {
      if (v13 == 1) {
        unsigned int v27 = *(_DWORD *)(result + 308) + 1;
      }
      else {
        unsigned int v27 = v13 - 2;
      }
    }
    else
    {
      unsigned int v27 = *(_DWORD *)(result + 304);
    }
    if (v27 < v1) {
      unsigned int v1 = 0;
    }
    unsigned int v28 = v27 - v1;
    *(_DWORD *)(result + 304) = *(_DWORD *)(result + 308);
    *(_DWORD *)(result + 308) = v28;
    *(void *)(result + 136) = *(void *)(*(void *)(result + 192) + 8 * v28);
  }
  return result;
}

uint64_t DecodeLiteralBlockSwitch(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 284);
  if (v1 >= 2)
  {
    uint64_t v2 = *(void *)(result + 240);
    unsigned int v3 = *(_DWORD *)(result + 16);
    unint64_t v4 = *(void *)(result + 8);
    if (v3 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v3 ^= 0x30u;
      *(_DWORD *)(result + 16) = v3;
      uint64_t v5 = *(void **)(result + 24);
      uint64_t v6 = *(void *)(result + 32);
      *((void *)&v7 + 1) = *v5;
      *(void *)&long long v7 = v4;
      unint64_t v4 = v7 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v5 + 6;
      *(void *)(result + 32) = v6 - 6;
    }
    unint64_t v8 = v4 >> v3;
    uint64_t v9 = (unsigned __int8 *)(v2 + 4 * (v4 >> v3));
    unsigned int v10 = *v9;
    if (v10 >= 9)
    {
      v3 += 8;
      v9 += 4 * ((v8 >> 8) & ~(-1 << (v10 - 8)))
          + 4 * *(unsigned __int16 *)(v2 + 4 * v8 + 2);
      unsigned int v10 = *v9;
    }
    uint64_t v11 = *(void *)(result + 248);
    unsigned int v12 = v3 + v10;
    int v13 = *((unsigned __int16 *)v9 + 1);
    if (v12 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v12 ^= 0x30u;
      uint64_t v14 = *(void **)(result + 24);
      uint64_t v15 = *(void *)(result + 32);
      *((void *)&v16 + 1) = *v14;
      *(void *)&long long v16 = v4;
      unint64_t v4 = v16 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v14 + 6;
      *(void *)(result + 32) = v15 - 6;
    }
    unint64_t v17 = v4 >> v12;
    uint64_t v18 = (unsigned __int8 *)(v11 + 4 * (v4 >> v12));
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v12 += 8;
      v18 += 4 * ((v17 >> 8) & ~(-1 << (v19 - 8)))
           + 4 * *(unsigned __int16 *)(v11 + 4 * v17 + 2);
      unsigned int v19 = *v18;
    }
    unsigned int v20 = v12 + v19;
    int v21 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * *((unsigned __int16 *)v18 + 1));
    int v22 = *((unsigned __int8 *)v21 + 2);
    int v23 = *v21;
    if (v20 >= 0x20)
    {
      v20 ^= 0x20u;
      *(_DWORD *)(result + 16) = v20;
      BOOL v24 = *(unsigned int **)(result + 24);
      uint64_t v25 = *(void *)(result + 32);
      *((void *)&v26 + 1) = *v24;
      *(void *)&long long v26 = v4;
      unint64_t v4 = v26 >> 32;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = v24 + 1;
      *(void *)(result + 32) = v25 - 4;
    }
    *(_DWORD *)(result + 16) = v20 + v22;
    *(_DWORD *)(result + 272) = ((v4 >> v20) & ~(-1 << v22)) + v23;
    if (v13)
    {
      if (v13 == 1) {
        unsigned int v27 = *(_DWORD *)(result + 300) + 1;
      }
      else {
        unsigned int v27 = v13 - 2;
      }
    }
    else
    {
      unsigned int v27 = *(_DWORD *)(result + 296);
    }
    if (v27 < v1) {
      unsigned int v1 = 0;
    }
    unsigned int v28 = v27 - v1;
    *(_DWORD *)(result + 296) = *(_DWORD *)(result + 300);
    *(_DWORD *)(result + 300) = v28;
    uint64_t v29 = v28 << 6;
    uint64_t v30 = *(void *)(result + 680);
    *(void *)(result + 152) = v30 + v29;
    *(_DWORD *)(result + 256) = (*(_DWORD *)(result + 4 * (v28 >> 5) + 712) >> v28) & 1;
    *(void *)(result + 344) = *(void *)(*(void *)(result + 168)
                                          + 8 * *(unsigned __int8 *)(v30 + v29));
    *(void *)(result + 144) = (char *)&_kBrotliContextLookupTable
                              + 512 * (unint64_t)(*(unsigned char *)(*(void *)(result + 688) + v28) & 3);
  }
  return result;
}

uint64_t DecodeDistanceBlockSwitch(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 292);
  if (v1 >= 2)
  {
    uint64_t v2 = *(void *)(result + 240) + 5056;
    unsigned int v3 = *(_DWORD *)(result + 16);
    unint64_t v4 = *(void *)(result + 8);
    if (v3 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v3 ^= 0x30u;
      *(_DWORD *)(result + 16) = v3;
      uint64_t v5 = *(void **)(result + 24);
      uint64_t v6 = *(void *)(result + 32);
      *((void *)&v7 + 1) = *v5;
      *(void *)&long long v7 = v4;
      unint64_t v4 = v7 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v5 + 6;
      *(void *)(result + 32) = v6 - 6;
    }
    unint64_t v8 = v4 >> v3;
    uint64_t v9 = (unsigned __int8 *)(v2 + 4 * (v4 >> v3));
    unsigned int v10 = *v9;
    if (v10 >= 9)
    {
      v3 += 8;
      v9 += 4 * ((v8 >> 8) & ~(-1 << (v10 - 8)))
          + 4 * *(unsigned __int16 *)(v2 + 4 * v8 + 2);
      unsigned int v10 = *v9;
    }
    uint64_t v11 = *(void *)(result + 248) + 3168;
    unsigned int v12 = v3 + v10;
    int v13 = *((unsigned __int16 *)v9 + 1);
    if (v12 >= 0x30)
    {
      *(void *)(result + 8) = HIWORD(v4);
      v12 ^= 0x30u;
      uint64_t v14 = *(void **)(result + 24);
      uint64_t v15 = *(void *)(result + 32);
      *((void *)&v16 + 1) = *v14;
      *(void *)&long long v16 = v4;
      unint64_t v4 = v16 >> 48;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = (char *)v14 + 6;
      *(void *)(result + 32) = v15 - 6;
    }
    unint64_t v17 = v4 >> v12;
    uint64_t v18 = (unsigned __int8 *)(v11 + 4 * (v4 >> v12));
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v12 += 8;
      v18 += 4 * ((v17 >> 8) & ~(-1 << (v19 - 8)))
           + 4 * *(unsigned __int16 *)(v11 + 4 * v17 + 2);
      unsigned int v19 = *v18;
    }
    unsigned int v20 = v12 + v19;
    int v21 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * *((unsigned __int16 *)v18 + 1));
    int v22 = *((unsigned __int8 *)v21 + 2);
    int v23 = *v21;
    if (v20 >= 0x20)
    {
      v20 ^= 0x20u;
      *(_DWORD *)(result + 16) = v20;
      BOOL v24 = *(unsigned int **)(result + 24);
      uint64_t v25 = *(void *)(result + 32);
      *((void *)&v26 + 1) = *v24;
      *(void *)&long long v26 = v4;
      unint64_t v4 = v26 >> 32;
      *(void *)(result + 8) = v4;
      *(void *)(result + 24) = v24 + 1;
      *(void *)(result + 32) = v25 - 4;
    }
    *(_DWORD *)(result + 16) = v20 + v22;
    *(_DWORD *)(result + 280) = ((v4 >> v20) & ~(-1 << v22)) + v23;
    if (v13)
    {
      if (v13 == 1) {
        unsigned int v27 = *(_DWORD *)(result + 316) + 1;
      }
      else {
        unsigned int v27 = v13 - 2;
      }
    }
    else
    {
      unsigned int v27 = *(_DWORD *)(result + 312);
    }
    if (v27 < v1) {
      unsigned int v1 = 0;
    }
    unsigned int v28 = v27 - v1;
    *(_DWORD *)(result + 312) = *(_DWORD *)(result + 316);
    *(_DWORD *)(result + 316) = v28;
    uint64_t v29 = *(void *)(result + 336) + 4 * v28;
    *(void *)(result + 160) = v29;
    *(unsigned char *)(result + 352) = *(unsigned char *)(v29 + *(int *)(result + 260));
  }
  return result;
}

uint64_t BrotliBuildSimpleHuffmanTable(int *__src, char a2, unsigned __int16 *a3, int a4)
{
  unsigned int v5 = 1;
  uint64_t v6 = (1 << a2);
  switch(a4)
  {
    case 0:
      *__src = *a3 << 16;
      unsigned int v5 = 1;
      break;
    case 1:
      unsigned int v7 = a3[1];
      unsigned int v8 = *a3;
      if (v7 <= v8)
      {
        *__src = (v7 << 16) | 1;
        int v9 = (*a3 << 16) | 1;
      }
      else
      {
        *__src = (v8 << 16) | 1;
        int v9 = (a3[1] << 16) | 1;
      }
      __src[1] = v9;
      unsigned int v5 = 2;
      break;
    case 2:
      *__src = (*a3 << 16) | 1;
      __src[2] = (*a3 << 16) | 1;
      unsigned int v10 = a3[2];
      unsigned int v11 = a3[1];
      if (v10 > v11)
      {
        __src[1] = (v11 << 16) | 2;
        int v12 = (a3[2] << 16) | 2;
        goto LABEL_21;
      }
      __src[1] = (v10 << 16) | 2;
      int v19 = a3[1];
      goto LABEL_20;
    case 3:
      uint64_t v13 = 0;
      uint64_t v14 = 2;
      do
      {
        uint64_t v15 = v13++;
        unsigned __int16 v16 = a3[v15];
        uint64_t v17 = v14;
        do
        {
          unsigned int v18 = *(unsigned __int16 *)((char *)a3 + v17);
          if (v18 < v16)
          {
            *(unsigned __int16 *)((char *)a3 + v17) = v16;
            a3[v15] = v18;
            unsigned __int16 v16 = v18;
          }
          v17 += 2;
        }
        while (v17 != 8);
        v14 += 2;
      }
      while (v13 != 3);
      *__src = (*a3 << 16) | 2;
      __src[2] = (a3[1] << 16) | 2;
      __src[1] = (a3[2] << 16) | 2;
      int v19 = a3[3];
LABEL_20:
      int v12 = (v19 << 16) | 2;
LABEL_21:
      __src[3] = v12;
      unsigned int v5 = 4;
      break;
    case 4:
      unsigned int v20 = a3[3];
      unsigned int v21 = a3[2];
      if (v20 < v21)
      {
        a3[3] = v21;
        a3[2] = v20;
      }
      *__src = (*a3 << 16) | 1;
      __src[1] = (a3[1] << 16) | 2;
      __src[2] = (*a3 << 16) | 1;
      __src[3] = (a3[2] << 16) | 3;
      __src[4] = (*a3 << 16) | 1;
      __src[5] = (a3[1] << 16) | 2;
      __src[6] = (*a3 << 16) | 1;
      __src[7] = (a3[3] << 16) | 3;
      unsigned int v5 = 8;
      break;
    default:
      break;
  }
  while (v5 != v6)
  {
    memcpy(&__src[v5], __src, 4 * v5);
    v5 *= 2;
  }
  return v6;
}

uint64_t DecodeVarLenUint8(uint64_t a1, unint64_t *a2, unsigned int *a3)
{
  int v3 = *(_DWORD *)(a1 + 656);
  if (v3)
  {
    if (v3 != 1)
    {
      if (v3 != 2) {
        return 4294967265;
      }
      unsigned int v4 = *a3;
      goto LABEL_18;
    }
    int v11 = *((_DWORD *)a2 + 2);
  }
  else
  {
    int v5 = *((_DWORD *)a2 + 2);
    if (v5 == 64)
    {
      unint64_t v6 = a2[3];
      if (!v6) {
        return 2;
      }
      unint64_t v7 = *a2;
      *a2 >>= 8;
      unsigned int v8 = (unsigned __int8 *)a2[2];
      *((void *)&v10 + 1) = *v8;
      *(void *)&long long v10 = v7;
      unint64_t v9 = v10 >> 8;
      *a2 = v9;
      a2[2] = (unint64_t)(v8 + 1);
      a2[3] = v6 - 1;
      int v5 = 56;
    }
    else
    {
      unint64_t v9 = *a2;
    }
    int v11 = v5 + 1;
    *((_DWORD *)a2 + 2) = v5 + 1;
    if (((v9 >> v5) & 1) == 0)
    {
      *a3 = 0;
      return 1;
    }
  }
  if ((v11 - 62) >= 3)
  {
    unint64_t v16 = *a2;
    goto LABEL_16;
  }
  unint64_t v13 = a2[3];
  if (!v13)
  {
    *(_DWORD *)(a1 + 656) = 1;
    return 2;
  }
  unint64_t v14 = *a2;
  *a2 >>= 8;
  uint64_t v15 = (unsigned __int8 *)a2[2];
  *((void *)&v17 + 1) = *v15;
  *(void *)&long long v17 = v14;
  unint64_t v16 = v17 >> 8;
  *a2 = v16;
  v11 -= 8;
  a2[2] = (unint64_t)(v15 + 1);
  a2[3] = v13 - 1;
LABEL_16:
  *((_DWORD *)a2 + 2) = v11 + 3;
  unsigned int v4 = (v16 >> v11) & 7;
  if (!v4)
  {
    uint64_t v12 = 1;
    *a3 = 1;
LABEL_26:
    *(_DWORD *)(a1 + 656) = 0;
    return v12;
  }
  *a3 = v4;
LABEL_18:
  int v18 = *((_DWORD *)a2 + 2);
  unsigned int v19 = 64 - v18;
  if (64 - v18 >= v4)
  {
    unint64_t v23 = *a2;
LABEL_24:
    int v25 = (v23 >> v18) & ~(-1 << v4);
    *((_DWORD *)a2 + 2) = v18 + v4;
    uint64_t v12 = 1;
    *a3 = (1 << *a3) + v25;
    goto LABEL_26;
  }
  uint64_t v20 = a2[3] - 1;
  while (v20 != -1)
  {
    unint64_t v21 = *a2;
    *a2 >>= 8;
    int v22 = (unsigned __int8 *)a2[2];
    *((void *)&v24 + 1) = *v22;
    *(void *)&long long v24 = v21;
    unint64_t v23 = v24 >> 8;
    *a2 = v23;
    v18 -= 8;
    *((_DWORD *)a2 + 2) = v18;
    a2[2] = (unint64_t)(v22 + 1);
    a2[3] = v20--;
    v19 += 8;
    if (v19 >= v4) {
      goto LABEL_24;
    }
  }
  uint64_t v12 = 2;
  *(_DWORD *)(a1 + 656) = 2;
  return v12;
}

BOOL BrotliDecoderHuffmanTreeGroupInit(uint64_t a1, uint64_t a2, __int16 a3, int a4, unsigned int a5)
{
  __int16 v6 = a4;
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(a1 + 40))(*(void *)(a1 + 56), (4 * (a4 + 376) + 8) * a5);
  *(_WORD *)(a2 + 16) = a3;
  *(_WORD *)(a2 + 18) = v6;
  *(_WORD *)(a2 + 20) = a5;
  *(void *)a2 = v9;
  *(void *)(a2 + 8) = v9 + 8 * a5;
  return v9 != 0;
}

void *BrotliDefaultAllocFunc(int a1, size_t __size)
{
  return malloc(__size);
}

uint64_t DecodeContextMap(unsigned int a1, unsigned int *a2, unsigned __int8 **a3, uint64_t a4)
{
  unsigned int v8 = (unint64_t *)(a4 + 8);
  switch(*(_DWORD *)(a4 + 748))
  {
    case 0:
      uint64_t result = DecodeVarLenUint8(a4, (unint64_t *)(a4 + 8), a2);
      if (result == 1)
      {
        ++*a2;
        *(_DWORD *)(a4 + 2552) = 0;
        long long v10 = (unsigned __int8 *)(*(uint64_t (**)(void, void))(a4 + 40))(*(void *)(a4 + 56), a1);
        *a3 = v10;
        if (v10)
        {
          if (*a2 > 1)
          {
            *(_DWORD *)(a4 + 748) = 1;
            goto LABEL_11;
          }
          bzero(v10, a1);
          return 1;
        }
        else
        {
          return 4294967271;
        }
      }
      return result;
    case 1:
LABEL_11:
      int v13 = *(_DWORD *)(a4 + 16);
      if ((v13 - 60) >= 5)
      {
        unint64_t v17 = *v8;
      }
      else
      {
        uint64_t v14 = *(void *)(a4 + 32);
        if (!v14) {
          return 2;
        }
        unint64_t v15 = *(void *)(a4 + 8);
        *(void *)(a4 + 8) = v15 >> 8;
        unint64_t v16 = *(unsigned __int8 **)(a4 + 24);
        *((void *)&v18 + 1) = *v16;
        *(void *)&long long v18 = v15;
        unint64_t v17 = v18 >> 8;
        *(void *)(a4 + 8) = v17;
        v13 -= 8;
        *(void *)(a4 + 24) = v16 + 1;
        *(void *)(a4 + 32) = v14 - 1;
      }
      unint64_t v19 = v17 >> v13;
      BOOL v25 = (v19 & 1) == 0;
      unsigned int v11 = ((int)(v19 << 31) >> 31) & (((v19 >> 1) & 0xF) + 1);
      if (v25) {
        int v20 = v13 + 1;
      }
      else {
        int v20 = v13 + 5;
      }
      *(_DWORD *)(a4 + 2556) = v11;
      *(_DWORD *)(a4 + 16) = v20;
      *(_DWORD *)(a4 + 748) = 2;
      goto LABEL_19;
    case 2:
      unsigned int v11 = *(_DWORD *)(a4 + 2556);
LABEL_19:
      uint64_t result = ReadHuffmanCode(v11 + *a2, v11 + *a2, (int *)(a4 + 2564), 0, a4);
      if (result != 1) {
        return result;
      }
      unsigned int v12 = 0xFFFF;
      *(_DWORD *)(a4 + 2560) = 0xFFFF;
      *(_DWORD *)(a4 + 748) = 3;
LABEL_21:
      unsigned int v21 = *(_DWORD *)(a4 + 2552);
      unsigned int v22 = *(_DWORD *)(a4 + 2556);
      unint64_t v23 = *a3;
      unsigned int v52 = v12;
      BOOL v24 = v12 != 0xFFFF;
      BOOL v25 = v21 >= a1 && v12 == 0xFFFF;
      if (v25) {
        goto LABEL_52;
      }
      uint64_t v26 = a4 + 2564;
      break;
    case 3:
      unsigned int v12 = *(_DWORD *)(a4 + 2560);
      goto LABEL_21;
    case 4:
      goto LABEL_52;
    default:
      return 4294967265;
  }
  while (1)
  {
    int v27 = *(_DWORD *)(a4 + 16);
    if (v24) {
      break;
    }
    if ((v27 - 50) >= 0xF)
    {
      unint64_t v31 = *v8;
LABEL_33:
      unint64_t v34 = v31 >> v27;
      uint64_t v35 = (unsigned __int8 *)(v26 + 4 * (v31 >> v27));
      unsigned int v36 = *v35;
      if (v36 >= 9)
      {
        v27 += 8;
        v35 += 4 * (BYTE1(v34) & ~(-1 << (v36 - 8)) & 0x7F)
             + 4 * *(unsigned __int16 *)(v26 + 4 * v34 + 2);
        unsigned int v36 = *v35;
      }
      *(_DWORD *)(a4 + 16) = v27 + v36;
      unsigned int v12 = *((unsigned __int16 *)v35 + 1);
      unsigned int v52 = v12;
      if (!v12) {
        goto LABEL_49;
      }
    }
    else
    {
      uint64_t v28 = *(void *)(a4 + 32) - 1;
      while (v28 != -1)
      {
        unint64_t v29 = *(void *)(a4 + 8);
        *(void *)(a4 + 8) = v29 >> 8;
        uint64_t v30 = *(unsigned __int8 **)(a4 + 24);
        *((void *)&v32 + 1) = *v30;
        *(void *)&long long v32 = v29;
        unint64_t v31 = v32 >> 8;
        *(void *)(a4 + 8) = v31;
        int v33 = v27 - 8;
        *(_DWORD *)(a4 + 16) = v27 - 8;
        *(void *)(a4 + 24) = v30 + 1;
        *(void *)(a4 + 32) = v28--;
        LODWORD(v30) = v27 - 58;
        v27 -= 8;
        if (v30 >= 0xF)
        {
          int v27 = v33;
          goto LABEL_33;
        }
      }
      if (!SafeDecodeSymbol((unsigned char *)(a4 + 2564), (uint64_t)v8, &v52))
      {
        unsigned int v12 = 0xFFFF;
        goto LABEL_63;
      }
      unsigned int v12 = v52;
      if (!v52)
      {
LABEL_49:
        unsigned __int8 v37 = 0;
        goto LABEL_50;
      }
    }
    unsigned __int8 v37 = v12 - v22;
    if (v12 <= v22)
    {
      int v27 = *(_DWORD *)(a4 + 16);
      break;
    }
LABEL_50:
    v23[v21++] = v37;
LABEL_51:
    BOOL v24 = 0;
    if (v21 >= a1)
    {
LABEL_52:
      int v45 = *(_DWORD *)(a4 + 16);
      if (v45 == 64)
      {
        uint64_t v46 = *(void *)(a4 + 32);
        if (v46)
        {
          unint64_t v47 = *(void *)(a4 + 8);
          *(void *)(a4 + 8) = v47 >> 8;
          int v48 = *(unsigned __int8 **)(a4 + 24);
          *((void *)&v50 + 1) = *v48;
          *(void *)&long long v50 = v47;
          unint64_t v49 = v50 >> 8;
          *(void *)(a4 + 8) = v49;
          *(void *)(a4 + 24) = v48 + 1;
          *(void *)(a4 + 32) = v46 - 1;
          int v45 = 56;
          goto LABEL_56;
        }
        uint64_t result = 2;
        int v51 = 4;
      }
      else
      {
        unint64_t v49 = *v8;
LABEL_56:
        *(_DWORD *)(a4 + 16) = v45 + 1;
        if ((v49 >> v45)) {
          InverseMoveToFrontTransform(*a3, a1, (_DWORD *)a4);
        }
        int v51 = 0;
        uint64_t result = 1;
      }
      *(_DWORD *)(a4 + 748) = v51;
      return result;
    }
  }
  unsigned int v38 = 64 - v27;
  if (64 - v27 >= v12)
  {
    unint64_t v42 = *v8;
LABEL_44:
    *(_DWORD *)(a4 + 16) = v27 + v12;
    int v44 = ((v42 >> v27) & ~(-1 << v12)) + (1 << v12);
    if (v44 + v21 > a1) {
      return 4294967288;
    }
    do
    {
      v23[v21++] = 0;
      --v44;
    }
    while (v44);
    goto LABEL_51;
  }
  uint64_t v39 = *(void *)(a4 + 32) - 1;
  while (v39 != -1)
  {
    unint64_t v40 = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = v40 >> 8;
    unint64_t v41 = *(unsigned __int8 **)(a4 + 24);
    *((void *)&v43 + 1) = *v41;
    *(void *)&long long v43 = v40;
    unint64_t v42 = v43 >> 8;
    *(void *)(a4 + 8) = v42;
    v27 -= 8;
    *(_DWORD *)(a4 + 16) = v27;
    *(void *)(a4 + 24) = v41 + 1;
    *(void *)(a4 + 32) = v39--;
    v38 += 8;
    if (v38 >= v12) {
      goto LABEL_44;
    }
  }
LABEL_63:
  *(_DWORD *)(a4 + 2560) = v12;
  *(_DWORD *)(a4 + 2552) = v21;
  return 2;
}

unsigned __int8 *InverseMoveToFrontTransform(unsigned __int8 *result, unsigned int a2, _DWORD *a3)
{
  unsigned int v4 = result;
  int v5 = a3[96];
  __int16 v6 = a3 + 98;
  a3[98] = 50462976;
  if ((v5 + 1) > 2) {
    uint64_t v7 = (v5 + 1);
  }
  else {
    uint64_t v7 = 2;
  }
  unsigned int v8 = a3 + 99;
  uint64_t v9 = v7 - 1;
  int v10 = 117835012;
  do
  {
    *v8++ = v10;
    v10 += 67372036;
    --v9;
  }
  while (v9);
  if (a2)
  {
    unsigned int v11 = 0;
    unsigned int v12 = (unsigned __int8 *)a3 + 391;
    uint64_t v13 = a2;
    do
    {
      uint64_t v14 = *v4;
      unsigned __int8 v15 = v6[v14];
      *v4++ = v15;
      *unsigned int v12 = v15;
      uint64_t result = (unsigned __int8 *)memmove(v6, (char *)a3 + 391, v14 + 1);
      v11 |= v14;
      --v13;
    }
    while (v13);
    unsigned int v16 = v11 >> 2;
  }
  else
  {
    unsigned int v16 = 0;
  }
  a3[96] = v16;
  return result;
}

uint64_t zlib_stream_process(void **a1, char a2)
{
  int v3 = (char *)a1[4];
  if (*(_DWORD *)v3 == 1)
  {
    unint64_t v17 = (unint64_t *)(v3 + 262448);
    long long v18 = v3 + 328001;
    *((void *)v3 + 2) = v3 + 328001;
    unint64_t v19 = v3 + 262464;
    *((void *)v3 + 5) = v3 + 262464;
    while (1)
    {
      unint64_t v20 = *v17;
      if (*v17 > 0x10000) {
        break;
      }
      if (0x10000 - v20 >= (unint64_t)a1[3]) {
        size_t v21 = (size_t)a1[3];
      }
      else {
        size_t v21 = 0x10000 - v20;
      }
      memcpy(&v19[v20], a1[2], v21);
      unint64_t v22 = (unint64_t)a1[1];
      size_t v23 = (size_t)a1[3] - v21;
      a1[2] = (char *)a1[2] + v21;
      a1[3] = (void *)v23;
      uint64_t v24 = *((void *)v3 + 32807);
      unint64_t v25 = *v17 + v21;
      unint64_t *v17 = v25;
      unint64_t v26 = 0x20000 - v24;
      if (0x20000 - v24 >= v22) {
        unint64_t v26 = v22;
      }
      *((void *)v3 + 3) = v26;
      *((void *)v3 + 9) = &v18[v24 + v26];
      *((void *)v3 + 10) = &v18[v24];
      if (v25 >= 9)
      {
        *((void *)v3 + 6) = 8 * v25 - 64;
        zlibDecodeBuffer((uint64_t)(v3 + 16));
        if (*((_DWORD *)v3 + 16) == 12) {
          return 0xFFFFFFFFLL;
        }
        unint64_t v25 = *v17;
      }
      memcpy(v3 + 131232, v3 + 16, 0x20090uLL);
      *((void *)v3 + 6) = 8 * v25;
      zlibDecodeBufferSafe((uint64_t)(v3 + 16));
      unint64_t v27 = *((void *)v3 + 7);
      if (v27 > *((void *)v3 + 6) || *((_DWORD *)v3 + 16) == 12)
      {
        memcpy(v3 + 16, v3 + 131232, 0x20090uLL);
        unint64_t v27 = *((void *)v3 + 7);
      }
      if (!*((void *)v3 + 3))
      {
        unint64_t v28 = ~(-1 << (*((_DWORD *)v3 + 12) - v27));
        if (*((void *)v3 + 17) < v28) {
          unint64_t v28 = *((void *)v3 + 17);
        }
        *((void *)v3 + 17) = v28;
      }
      if (v27 >= 8)
      {
        uint64_t result = 0xFFFFFFFFLL;
        if (v27 > 0x80007) {
          return result;
        }
        unint64_t v29 = v27 >> 3;
        unint64_t v30 = *v17 - (v27 >> 3);
        if (*v17 < v27 >> 3) {
          return result;
        }
        *((void *)v3 + 7) = v27 & 7;
        unint64_t *v17 = v30;
        if (v30 >= 0x10000 - v29) {
          size_t v31 = 0x10000 - v29;
        }
        else {
          size_t v31 = v30;
        }
        memmove(v3 + 262464, &v19[v29], v31);
      }
      long long v32 = (unsigned char *)*((void *)v3 + 10);
      int v33 = &v18[*((void *)v3 + 32807)];
      size_t v34 = v32 - v33;
      if (v32 == v33)
      {
        if (*v17 == 0x10000) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        if (v34 > (unint64_t)a1[1]) {
          return 0xFFFFFFFFLL;
        }
        memcpy(*a1, v33, v34);
        size_t v35 = (size_t)a1[1] - v34;
        *a1 = (char *)*a1 + v34;
        a1[1] = (void *)v35;
        unint64_t v36 = *((void *)v3 + 32807) + v34;
        *((void *)v3 + 32807) = v36;
        if (v36 > 0x10000)
        {
          memmove(v3 + 328001, &v18[v36 - 0x10000], 0x10000uLL);
          *((void *)v3 + 32807) = 0x10000;
        }
      }
      int v37 = *((_DWORD *)v3 + 16);
      if (v37 == 11 || !a1[1] || !a1[3]) {
        return v37 == 11;
      }
    }
  }
  else
  {
    uint64_t result = 0xFFFFFFFFLL;
    if (*(_DWORD *)v3) {
      return result;
    }
    unint64_t v5 = (unint64_t)a1[3];
    *((void *)v3 + 3) = a1[2];
    __int16 v6 = (z_stream *)(v3 + 24);
    int v7 = LODWORD(v6[-1].reserved) | a2 & 1;
    BOOL v8 = v7 != 0;
    LODWORD(v6[-1].reserved) = v7;
    LODWORD(v9) = -1;
    if (v5 >= 0xFFFFFFFF) {
      LODWORD(v5) = -1;
    }
    v6->avail_in = v5;
    int v10 = (Bytef *)*a1;
    if ((unint64_t)a1[1] < 0xFFFFFFFF) {
      uint64_t v9 = (char *)a1[1];
    }
    v6->avail_out = v9;
    v6->next_out = v10;
    int v11 = deflate(v6, 4 * v8);
    next_out = v6->next_out;
    uint64_t v13 = (char *)*a1;
    uint64_t v14 = (char *)a1[1];
    unint64_t v15 = (unint64_t)a1[3] + (void)a1[2] - (unint64_t)v6->next_in;
    a1[2] = v6->next_in;
    a1[3] = (void *)v15;
    *a1 = next_out;
    a1[1] = &v14[v13 - (char *)next_out];
    if (v11 == -5 || v11 == 0) {
      return 0;
    }
    if (v11 == 1)
    {
      deflateEnd(v6);
      return 1;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t DecodeMetaBlockLength(uint64_t a1, unint64_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 648);
  while (2)
  {
    switch(v2)
    {
      case 0:
        int v3 = *((_DWORD *)a2 + 2);
        if (v3 == 64)
        {
          unint64_t v4 = a2[3];
          if (!v4) {
            return 2;
          }
          unint64_t v5 = *a2;
          *a2 >>= 8;
          __int16 v6 = (unsigned __int8 *)a2[2];
          *((void *)&v8 + 1) = *v6;
          *(void *)&long long v8 = v5;
          unint64_t v7 = v8 >> 8;
          *a2 = v7;
          a2[2] = (unint64_t)(v6 + 1);
          a2[3] = v4 - 1;
          int v3 = 56;
        }
        else
        {
          unint64_t v7 = *a2;
        }
        *((_DWORD *)a2 + 2) = v3 + 1;
        uint64_t v10 = v7 & (1 << v3);
        __int16 v11 = *(_WORD *)(a1 + 664) & 0xFFF8 | (v10 != 0);
        *(_DWORD *)(a1 + 264) = 0;
        *(_WORD *)(a1 + 664) = v11;
        if (v10)
        {
          *(_DWORD *)(a1 + 648) = 1;
          goto LABEL_10;
        }
        int v2 = 2;
        goto LABEL_22;
      case 1:
LABEL_10:
        int v12 = *((_DWORD *)a2 + 2);
        if (v12 == 64)
        {
          unint64_t v13 = a2[3];
          if (!v13) {
            return 2;
          }
          unint64_t v14 = *a2;
          *a2 >>= 8;
          unint64_t v15 = (unsigned __int8 *)a2[2];
          *((void *)&v17 + 1) = *v15;
          *(void *)&long long v17 = v14;
          unint64_t v16 = v17 >> 8;
          *a2 = v16;
          a2[2] = (unint64_t)(v15 + 1);
          a2[3] = v13 - 1;
          int v12 = 56;
        }
        else
        {
          unint64_t v16 = *a2;
        }
        int v9 = v12 + 1;
        *((_DWORD *)a2 + 2) = v12 + 1;
        if ((v16 >> v12)) {
          goto LABEL_84;
        }
        *(_DWORD *)(a1 + 648) = 2;
LABEL_16:
        if ((v9 - 63) >= 2)
        {
          unint64_t v21 = *a2;
        }
        else
        {
          unint64_t v18 = a2[3];
          if (!v18) {
            return 2;
          }
          unint64_t v19 = *a2;
          *a2 >>= 8;
          unint64_t v20 = (unsigned __int8 *)a2[2];
          *((void *)&v22 + 1) = *v20;
          *(void *)&long long v22 = v19;
          unint64_t v21 = v22 >> 8;
          *a2 = v21;
          v9 -= 8;
          a2[2] = (unint64_t)(v20 + 1);
          a2[3] = v18 - 1;
        }
        int v23 = (v21 >> v9) & 3;
        *((_DWORD *)a2 + 2) = v9 + 2;
        int v24 = *(_WORD *)(a1 + 664) & 0xC03F | (v23 << 6);
        unsigned int v25 = v24 | 0x100;
        *(_WORD *)(a1 + 664) = v24 | 0x100;
        *(_DWORD *)(a1 + 4) = 0;
        if (v23 == 3)
        {
          *(_WORD *)(a1 + 664) = v24 | 0x104;
          int v2 = 5;
LABEL_22:
          *(_DWORD *)(a1 + 648) = v2;
          continue;
        }
        int v26 = 0;
        *(_DWORD *)(a1 + 648) = 3;
LABEL_27:
        if (v26 < (v25 >> 6))
        {
          int v28 = *((_DWORD *)a2 + 2);
          int v29 = 4 * v26;
          do
          {
            if ((v28 - 61) >= 4)
            {
              unint64_t v33 = *a2;
            }
            else
            {
              unint64_t v30 = a2[3];
              if (!v30)
              {
LABEL_85:
                *(_DWORD *)(a1 + 4) = v26;
                return 2;
              }
              unint64_t v31 = *a2;
              *a2 >>= 8;
              long long v32 = (unsigned __int8 *)a2[2];
              *((void *)&v34 + 1) = *v32;
              *(void *)&long long v34 = v31;
              unint64_t v33 = v34 >> 8;
              *a2 = v33;
              v28 -= 8;
              a2[2] = (unint64_t)(v32 + 1);
              a2[3] = v30 - 1;
            }
            uint64_t v35 = (v33 >> v28) & 0xF;
            v28 += 4;
            *((_DWORD *)a2 + 2) = v28;
            ++v26;
            unsigned int v25 = *(unsigned __int16 *)(a1 + 664);
            unsigned int v36 = (v25 >> 6);
            if (v26 == v36 && v36 >= 5 && v35 == 0) {
              return 0xFFFFFFFFLL;
            }
            *(_DWORD *)(a1 + 264) |= v35 << v29;
            v29 += 4;
          }
          while (v26 < (int)v36);
        }
        *(_DWORD *)(a1 + 648) = 4;
        if ((v25 & 1) == 0)
        {
LABEL_44:
          int v39 = *((_DWORD *)a2 + 2);
          if (v39 == 64)
          {
            unint64_t v40 = a2[3];
            if (!v40) {
              return 2;
            }
            unint64_t v41 = *a2;
            *a2 >>= 8;
            unint64_t v42 = (unsigned __int8 *)a2[2];
            *((void *)&v44 + 1) = *v42;
            *(void *)&long long v44 = v41;
            unint64_t v43 = v44 >> 8;
            *a2 = v43;
            a2[2] = (unint64_t)(v42 + 1);
            a2[3] = v40 - 1;
            int v39 = 56;
          }
          else
          {
            unint64_t v43 = *a2;
          }
          *((_DWORD *)a2 + 2) = v39 + 1;
          *(_WORD *)(a1 + 664) = *(_WORD *)(a1 + 664) & 0xFFFD | (2 * ((v43 >> v39) & 1));
        }
LABEL_54:
        int v53 = *(_DWORD *)(a1 + 264) + 1;
LABEL_83:
        *(_DWORD *)(a1 + 264) = v53;
LABEL_84:
        *(_DWORD *)(a1 + 648) = 0;
        return 1;
      case 2:
        int v9 = *((_DWORD *)a2 + 2);
        goto LABEL_16;
      case 3:
        int v26 = *(_DWORD *)(a1 + 4);
        unsigned int v25 = *(unsigned __int16 *)(a1 + 664);
        goto LABEL_27;
      case 4:
        if ((*(_WORD *)(a1 + 664) & 1) == 0) {
          goto LABEL_44;
        }
        goto LABEL_54;
      case 5:
        int v45 = *((_DWORD *)a2 + 2);
        if (v45 == 64)
        {
          unint64_t v46 = a2[3];
          if (!v46) {
            return 2;
          }
          unint64_t v47 = *a2;
          *a2 >>= 8;
          int v48 = (unsigned __int8 *)a2[2];
          *((void *)&v50 + 1) = *v48;
          *(void *)&long long v50 = v47;
          unint64_t v49 = v50 >> 8;
          *a2 = v49;
          a2[2] = (unint64_t)(v48 + 1);
          a2[3] = v46 - 1;
          int v45 = 56;
        }
        else
        {
          unint64_t v49 = *a2;
        }
        int v51 = v45 + 1;
        *((_DWORD *)a2 + 2) = v45 + 1;
        if ((v49 >> v45)) {
          return 4294967294;
        }
        *(_DWORD *)(a1 + 648) = 6;
LABEL_60:
        if ((v51 - 63) >= 2)
        {
          unint64_t v57 = *a2;
        }
        else
        {
          unint64_t v54 = a2[3];
          if (!v54) {
            return 2;
          }
          unint64_t v55 = *a2;
          *a2 >>= 8;
          unsigned int v56 = (unsigned __int8 *)a2[2];
          *((void *)&v58 + 1) = *v56;
          *(void *)&long long v58 = v55;
          unint64_t v57 = v58 >> 8;
          *a2 = v57;
          v51 -= 8;
          a2[2] = (unint64_t)(v56 + 1);
          a2[3] = v54 - 1;
        }
        *((_DWORD *)a2 + 2) = v51 + 2;
        int v59 = (v57 >> v51) & 3;
        if (!v59) {
          goto LABEL_84;
        }
        unsigned int v52 = *(_WORD *)(a1 + 664) & 0xC03F | (v59 << 6);
        *(_WORD *)(a1 + 664) = *(_WORD *)(a1 + 664) & 0xC03F | ((_WORD)v59 << 6);
        *(_DWORD *)(a1 + 648) = 7;
LABEL_66:
        int v26 = *(_DWORD *)(a1 + 4);
        if (v26 >= (v52 >> 6))
        {
          int v71 = *(_DWORD *)(a1 + 264);
        }
        else
        {
          int v60 = *((_DWORD *)a2 + 2);
          int v61 = 8 * v26;
          do
          {
            if ((v60 - 57) >= 8)
            {
              unint64_t v65 = *a2;
            }
            else
            {
              unint64_t v62 = a2[3];
              if (!v62) {
                goto LABEL_85;
              }
              unint64_t v63 = *a2;
              *a2 >>= 8;
              unint64_t v64 = (unsigned __int8 *)a2[2];
              *((void *)&v66 + 1) = *v64;
              *(void *)&long long v66 = v63;
              unint64_t v65 = v66 >> 8;
              *a2 = v65;
              v60 -= 8;
              a2[2] = (unint64_t)(v64 + 1);
              a2[3] = v62 - 1;
            }
            int v67 = (v65 >> v60);
            v60 += 8;
            *((_DWORD *)a2 + 2) = v60;
            ++v26;
            unsigned int v68 = (*(unsigned __int16 *)(a1 + 664) >> 6);
            if (v26 == v68 && v68 >= 2 && v67 == 0) {
              return 4294967293;
            }
            int v71 = *(_DWORD *)(a1 + 264) | (v67 << v61);
            *(_DWORD *)(a1 + 264) = v71;
            v61 += 8;
          }
          while (v26 < (int)v68);
        }
        int v53 = v71 + 1;
        goto LABEL_83;
      case 6:
        int v51 = *((_DWORD *)a2 + 2);
        goto LABEL_60;
      case 7:
        unsigned int v52 = *(unsigned __int16 *)(a1 + 664);
        goto LABEL_66;
      default:
        return 4294967265;
    }
  }
}

uint64_t BrotliEnsureRingBuffer(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 672);
  if (*(_DWORD *)(a1 + 88) == v1) {
    return 1;
  }
  int v3 = *(const void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 40))(*(void *)(a1 + 56), v1 + 42);
  *(void *)(a1 + 120) = result;
  if (result)
  {
    *(unsigned char *)(*(int *)(a1 + 672) + result - 2) = 0;
    *(unsigned char *)(*(int *)(a1 + 672) + *(void *)(a1 + 120) - 1) = 0;
    if (v3)
    {
      memcpy(*(void **)(a1 + 120), v3, *(int *)(a1 + 76));
      (*(void (**)(void, const void *))(a1 + 48))(*(void *)(a1 + 56), v3);
    }
    uint64_t v5 = *(int *)(a1 + 672);
    *(_DWORD *)(a1 + 88) = v5;
    *(_DWORD *)(a1 + 92) = v5 - 1;
    *(void *)(a1 + 128) = *(void *)(a1 + 120) + v5;
    return 1;
  }
  *(void *)(a1 + 120) = v3;
  return result;
}

double BrotliDecoderStateMetablockBegin(uint64_t a1)
{
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 272) = xmmword_20DAD5C30;
  *(_OWORD *)(a1 + 288) = xmmword_20DAD5C40;
  *(_OWORD *)(a1 + 304) = xmmword_20DAD5C50;
  double result = 0.0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(unsigned char *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 680) = 0u;
  return result;
}

uint64_t BrotliCalculateRingBufferSize(uint64_t result)
{
  int v1 = 1 << *(_DWORD *)(result + 668);
  int v2 = *(_DWORD *)(result + 88);
  if (v2) {
    int v3 = *(_DWORD *)(result + 88);
  }
  else {
    int v3 = 1024;
  }
  if (v2 != v1)
  {
    __int16 v4 = *(_WORD *)(result + 664);
    if ((v4 & 4) == 0)
    {
      uint64_t v5 = *(void *)(result + 120);
      if (v5) {
        LODWORD(v5) = *(_DWORD *)(result + 76);
      }
      int v6 = *(_DWORD *)(result + 264) + v5;
      if (v3 <= v6) {
        int v3 = v6;
      }
      if ((v4 & 0x10) != 0)
      {
        do
        {
          int v7 = v1;
          v1 >>= 1;
        }
        while (v1 >= v3);
      }
      else
      {
        int v7 = 1 << *(_DWORD *)(result + 668);
      }
      *(_DWORD *)(result + 672) = v7;
    }
  }
  return result;
}

size_t zlibDecodeBufferSafe(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48);
  if (v1 == 11) {
    return 0;
  }
  __int16 v4 = (uint64_t *)(a1 + 24);
  uint64_t v5 = a1 + 144;
  uint64_t v6 = a1 + 65680;
  unint64_t v8 = *(void *)(a1 + 128);
  uint64_t v7 = *(void *)(a1 + 136);
  unint64_t v10 = *(void *)(a1 + 112);
  unint64_t v9 = *(void *)(a1 + 120);
  int v12 = *(_DWORD *)(a1 + 88);
  int v11 = *(_DWORD *)(a1 + 92);
  switch(v1)
  {
    case 0:
      goto LABEL_8;
    case 1:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_21;
    case 2:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v15 = *(void *)(a1 + 40);
      size_t v16 = *(void *)(a1 + 80);
      uint64_t v17 = *(void *)(a1 + 24);
      goto LABEL_28;
    case 3:
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_38;
    case 4:
      goto LABEL_41;
    case 5:
      goto LABEL_45;
    case 6:
      unint64_t v18 = *(void *)(a1 + 96);
      goto LABEL_54;
    case 7:
      goto LABEL_58;
    case 9:
      goto LABEL_70;
    case 10:
      goto LABEL_71;
    default:
      goto LABEL_88;
  }
  do
  {
LABEL_71:
    unint64_t v63 = *(void *)(a1 + 8);
    unint64_t v64 = v63 - v7;
    if (v63 < v7)
    {
      uint64_t v70 = *(void *)(a1 + 64);
      if (v63)
      {
        unint64_t v71 = 0;
        do
        {
          *(unsigned char *)(v70 + v71) = *(unsigned char *)(v70 - v8 + v71);
          ++v71;
          unint64_t v72 = *(void *)(a1 + 8);
        }
        while (v72 > v71);
        uint64_t v70 = *(void *)(a1 + 64);
      }
      else
      {
        unint64_t v72 = 0;
      }
      uint64_t v74 = v70 + v72;
      *(void *)(a1 + 64) = v74;
      *(void *)(a1 + 112) = v10;
      *(void *)(a1 + 120) = v9;
      *(_DWORD *)(a1 + 88) = v12;
      *(_DWORD *)(a1 + 92) = v11;
      *(void *)(a1 + 128) = v8;
      *(void *)(a1 + 136) = v7 - v72;
      *(void *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 48) = 10;
      return v74 - *(void *)a1;
    }
    unint64_t v65 = *(void *)(a1 + 64);
    uint64_t v66 = -(uint64_t)v8;
    if (v63 < v7 + 31)
    {
      if (v7)
      {
        uint64_t v67 = v7;
        do
        {
          *(unsigned char *)unint64_t v65 = *(unsigned char *)(v65 + v66);
          ++v65;
          --v67;
        }
        while (v67);
        unint64_t v65 = *(void *)(a1 + 64);
        unint64_t v63 = *(void *)(a1 + 8);
      }
      *(void *)(a1 + 64) = v65 + v7;
      uint64_t v47 = v63 - v7;
      goto LABEL_78;
    }
    unint64_t v68 = v65 + v7;
    *(void *)(a1 + 64) = v65 + v7;
    *(void *)(a1 + 8) = v64;
    if (v8 < 8)
    {
      if (v8 == 1)
      {
        if (v7 >= 1)
        {
          uint64_t v69 = 0x101010101010101 * *(unsigned __int8 *)(v65 - v8);
          do
          {
            *(void *)unint64_t v65 = v69;
            v65 += 8;
          }
          while (v65 < v68);
        }
      }
      else if (v7 >= 1)
      {
        do
        {
          *(_WORD *)unint64_t v65 = *(_WORD *)(v65 - v8);
          *(_WORD *)(v65 + 2) = *(_WORD *)(v65 - v8 + 2);
          v65 += 4;
        }
        while (v65 < v68);
      }
    }
    else if (v7 >= 1)
    {
      do
      {
        *(void *)unint64_t v65 = *(void *)(v65 - v8);
        *(void *)(v65 + 8) = *(void *)(v65 - v8 + 8);
        v65 += 16;
      }
      while (v65 < v68);
    }
    while (1)
    {
LABEL_45:
      if (v9 >= v12)
      {
        unint64_t v40 = *(void *)(a1 + 40);
      }
      else
      {
        unint64_t v39 = *(void *)(a1 + 32);
        unint64_t v40 = *(void *)(a1 + 40);
        BOOL v36 = v39 > v40;
        unint64_t v41 = v39 - v40;
        if (!v36)
        {
          size_t result = 0;
          int v73 = 5;
LABEL_97:
          *(_DWORD *)(a1 + 48) = v73;
          *(void *)(a1 + 112) = v10;
          *(void *)(a1 + 120) = v9;
          *(_DWORD *)(a1 + 88) = v12;
          *(_DWORD *)(a1 + 92) = v11;
          return result;
        }
        char v42 = v40 & 7;
        size_t v43 = (v41 + 7) >> 3 >= 8 ? 8 : (v41 + 7) >> 3;
        unint64_t __dst = 0;
        memcpy(&__dst, (const void *)(*v4 + (v40 >> 3)), v43);
        unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * v43) >> v42;
        unint64_t v10 = __dst >> v42;
      }
      unint64_t v44 = *(unsigned __int16 *)(v5 + 2 * (v10 & v12));
      uint64_t v45 = (v44 & 0xF) + 1;
      unint64_t v18 = v44 >> 4;
      *(void *)(a1 + 96) = v18;
      v10 >>= v45;
      v9 >>= v45;
      *(void *)(a1 + 40) = v45 + v40;
LABEL_54:
      if (v18 > 0xFF) {
        break;
      }
      if (!*(void *)(a1 + 8))
      {
        *(_DWORD *)(a1 + 48) = 6;
        *(void *)(a1 + 112) = v10;
        *(void *)(a1 + 120) = v9;
        *(_DWORD *)(a1 + 88) = v12;
        *(_DWORD *)(a1 + 92) = v11;
LABEL_99:
        size_t v34 = *(void *)(a1 + 64);
        return v34 - *(void *)a1;
      }
      unint64_t v46 = *(unsigned char **)(a1 + 64);
      *(void *)(a1 + 64) = v46 + 1;
      *unint64_t v46 = v18;
      uint64_t v47 = *(void *)(a1 + 8) - 1;
LABEL_78:
      *(void *)(a1 + 8) = v47;
    }
    unint64_t v48 = v18 - 256;
    *(void *)(a1 + 96) = v48;
    if (!v48)
    {
LABEL_8:
      while (!*(_DWORD *)(a1 + 52))
      {
        unint64_t v13 = *(void *)(a1 + 32);
        unint64_t v19 = *(void *)(a1 + 40);
        unint64_t v20 = v13 - v19;
        if (v13 < v19) {
          unint64_t v20 = 0;
        }
        if (v20 <= 2)
        {
          size_t result = 0;
          *(_DWORD *)(a1 + 48) = 0;
          return result;
        }
        if ((v13 + 7 - v19) >> 3 >= 8) {
          size_t v21 = 8;
        }
        else {
          size_t v21 = (v13 + 7 - v19) >> 3;
        }
        unint64_t __dst = 0;
        uint64_t v22 = *(void *)(a1 + 24);
        memcpy(&__dst, (const void *)(v22 + (v19 >> 3)), v21);
        unint64_t v23 = __dst >> (v19 & 7);
        *(void *)(a1 + 40) = v19 + 1;
        *(_DWORD *)(a1 + 52) = v23 & 1;
        if ((v13 + 7 + ~v19) >> 3 >= 8) {
          size_t v24 = 8;
        }
        else {
          size_t v24 = (v13 + 7 + ~v19) >> 3;
        }
        unint64_t __dst = 0;
        memcpy(&__dst, (const void *)(v22 + ((v19 + 1) >> 3)), v24);
        unint64_t v25 = __dst >> ((v19 + 1) & 7);
        unint64_t v14 = v19 + 3;
        *(void *)(a1 + 40) = v14;
        int v26 = v25 & 3;
        *(void *)(a1 + 72) = 0x800000008000;
        switch(v26)
        {
          case 1:
            if (staticHuffmanTable((int *)(a1 + 72), v5, (int *)(a1 + 76), v6)) {
              goto LABEL_88;
            }
            goto LABEL_41;
          case 2:
LABEL_38:
            if (readHuffmanTable(v4, (int *)(a1 + 72), v5, (int *)(a1 + 76), v6))
            {
              size_t result = 0;
              *(void *)(a1 + 40) = v14;
              int v38 = 3;
              goto LABEL_89;
            }
LABEL_41:
            unint64_t v9 = 0;
            unint64_t v10 = 0;
            int v12 = *(_DWORD *)(a1 + 72) - 1;
            int v11 = *(_DWORD *)(a1 + 76) - 1;
            goto LABEL_45;
          case 3:
            goto LABEL_88;
        }
LABEL_21:
        unint64_t v27 = v13 - v14;
        if (v13 < v14) {
          unint64_t v27 = 0;
        }
        if (v27 <= 0xF)
        {
          size_t result = 0;
          int v38 = 1;
          goto LABEL_89;
        }
        unint64_t v28 = v14 + 7;
        unint64_t v29 = (v14 + 7) & 0xFFFFFFFFFFFFFFF8;
        *(void *)(a1 + 40) = v29;
        if ((v13 - v29 + 7) >> 3 >= 8) {
          size_t v30 = 8;
        }
        else {
          size_t v30 = (v13 - v29 + 7) >> 3;
        }
        unint64_t __dst = 0;
        uint64_t v17 = *(void *)(a1 + 24);
        memcpy(&__dst, (const void *)(v17 + (v28 >> 3)), v30);
        size_t v16 = (unsigned __int16)__dst;
        *(void *)(a1 + 80) = (unsigned __int16)__dst;
        unint64_t v15 = v29 + 32;
        *(void *)(a1 + 40) = v29 + 32;
LABEL_28:
        unint64_t v31 = v13 - v15;
        if (v13 < v15) {
          unint64_t v31 = 0;
        }
        size_t v32 = v31 >> 3;
        if (v32 >= *(void *)(a1 + 8)) {
          size_t v32 = *(void *)(a1 + 8);
        }
        if (v32 >= v16) {
          size_t v33 = v16;
        }
        else {
          size_t v33 = v32;
        }
        memcpy(*(void **)(a1 + 64), (const void *)(v17 + (v15 >> 3)), v33);
        *(void *)(a1 + 40) += 8 * v33;
        *(void *)(a1 + 8) -= v33;
        size_t v34 = *(void *)(a1 + 64) + v33;
        *(void *)(a1 + 64) = v34;
        size_t v35 = *(void *)(a1 + 80);
        BOOL v36 = v35 > v33;
        size_t v37 = v35 - v33;
        if (v36)
        {
          *(void *)(a1 + 80) = v37;
          *(_DWORD *)(a1 + 48) = 2;
          return v34 - *(void *)a1;
        }
      }
      *(_DWORD *)(a1 + 48) = 11;
      goto LABEL_99;
    }
LABEL_58:
    unint64_t v49 = *(void *)(a1 + 32);
    unint64_t v50 = *(void *)(a1 + 40);
    BOOL v36 = v49 > v50;
    unint64_t v51 = v49 - v50;
    if (!v36)
    {
      size_t result = 0;
      int v73 = 7;
      goto LABEL_97;
    }
    if ((v51 + 7) >> 3 >= 8) {
      size_t v52 = 8;
    }
    else {
      size_t v52 = (v51 + 7) >> 3;
    }
    unint64_t __dst = 0;
    memcpy(&__dst, (const void *)(*(void *)(a1 + 24) + (v50 >> 3)), v52);
    unint64_t v53 = *(void *)(a1 + 96);
    if (v53 >= 0x1E) {
      break;
    }
    unint64_t v54 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * v52) >> (v50 & 7);
    unint64_t v55 = __dst >> (v50 & 7);
    uint64_t v7 = zlibDecodeBufferSafe_litlen_base[v53];
    if (v53 >= 9 && v53 != 29)
    {
      unint64_t v56 = (v53 - 5) >> 2;
      v7 += v55 & ~(-1 << v56);
      v55 >>= v56;
      v54 >>= v56;
      v50 += v56;
      *(void *)(a1 + 40) = v50;
    }
    unint64_t v57 = *(unsigned __int16 *)(v6 + 2 * (v55 & v11));
    if (v57 >= 0x1E0) {
      break;
    }
    unint64_t v58 = v57 >> 4;
    unint64_t v8 = zlibDecodeBufferSafe_distance_base[v57 >> 4];
    uint64_t v59 = (v57 & 0xF) + 1;
    unint64_t v10 = v55 >> v59;
    unint64_t v9 = v54 >> v59;
    unint64_t v60 = v50 + v59;
    *(void *)(a1 + 40) = v60;
    if (v57 >= 0x40)
    {
      unint64_t v61 = v58 - 2;
      unint64_t v62 = (v58 - 2) >> 1;
      v8 += v10 & ~(-1 << v62);
      v10 >>= v62;
      v9 >>= v62;
      *(void *)(a1 + 40) = v60 + (v61 >> 1);
    }
LABEL_70:
    ;
  }
  while (v8 - 1 < *(void *)(a1 + 64) - *(void *)a1);
LABEL_88:
  size_t result = 0;
  int v38 = 12;
LABEL_89:
  *(_DWORD *)(a1 + 48) = v38;
  return result;
}

size_t zlibDecodeBuffer(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48);
  if (v1 == 11) {
    return 0;
  }
  __int16 v4 = (uint64_t *)(a1 + 24);
  uint64_t v5 = a1 + 144;
  uint64_t v6 = a1 + 65680;
  unint64_t v8 = *(void *)(a1 + 128);
  uint64_t v7 = *(void *)(a1 + 136);
  unint64_t v10 = *(void *)(a1 + 112);
  unint64_t v9 = *(void *)(a1 + 120);
  int v12 = *(_DWORD *)(a1 + 88);
  int v11 = *(_DWORD *)(a1 + 92);
  switch(v1)
  {
    case 0:
      goto LABEL_8;
    case 1:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_15;
    case 2:
      unint64_t v13 = *(void *)(a1 + 32);
      unint64_t v15 = *(void *)(a1 + 40);
      size_t v16 = *(void *)(a1 + 80);
      uint64_t v17 = *(void *)(a1 + 24);
      goto LABEL_19;
    case 3:
      unint64_t v14 = *(void *)(a1 + 40);
      goto LABEL_29;
    case 4:
      goto LABEL_32;
    case 5:
      goto LABEL_36;
    case 6:
      unint64_t v18 = *(void *)(a1 + 96);
      goto LABEL_41;
    case 7:
      goto LABEL_45;
    case 9:
      goto LABEL_53;
    case 10:
      break;
    default:
      goto LABEL_71;
  }
  while (2)
  {
    unint64_t v51 = *(void *)(a1 + 8);
    unint64_t v52 = v51 - v7;
    if (v51 < v7)
    {
      uint64_t v59 = *(void *)(a1 + 64);
      if (v51)
      {
        unint64_t v60 = 0;
        do
        {
          *(unsigned char *)(v59 + v60) = *(unsigned char *)(v59 - v8 + v60);
          ++v60;
          unint64_t v61 = *(void *)(a1 + 8);
        }
        while (v61 > v60);
        uint64_t v59 = *(void *)(a1 + 64);
      }
      else
      {
        unint64_t v61 = 0;
      }
      uint64_t v62 = v59 + v61;
      *(void *)(a1 + 64) = v62;
      *(void *)(a1 + 112) = v10;
      *(void *)(a1 + 120) = v9;
      *(_DWORD *)(a1 + 88) = v12;
      *(_DWORD *)(a1 + 92) = v11;
      *(void *)(a1 + 128) = v8;
      *(void *)(a1 + 136) = v7 - v61;
      *(void *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 48) = 10;
      return v62 - *(void *)a1;
    }
    unint64_t v53 = *(void *)(a1 + 64);
    uint64_t v54 = -(uint64_t)v8;
    if (v51 < v7 + 31)
    {
      if (v7)
      {
        uint64_t v55 = v7;
        do
        {
          *(unsigned char *)unint64_t v53 = *(unsigned char *)(v53 + v54);
          ++v53;
          --v55;
        }
        while (v55);
        unint64_t v53 = *(void *)(a1 + 64);
        unint64_t v51 = *(void *)(a1 + 8);
      }
      *(void *)(a1 + 64) = v53 + v7;
      uint64_t v38 = v51 - v7;
      goto LABEL_61;
    }
    unint64_t v56 = v53 + v7;
    *(void *)(a1 + 64) = v53 + v7;
    *(void *)(a1 + 8) = v52;
    if (v8 < 8)
    {
      if (v8 == 1)
      {
        if (v7 >= 1)
        {
          uint64_t v57 = 0x101010101010101 * *(unsigned __int8 *)(v53 - v8);
          do
          {
            *(void *)unint64_t v53 = v57;
            v53 += 8;
          }
          while (v53 < v56);
        }
      }
      else if (v7 >= 1)
      {
        do
        {
          *(_WORD *)unint64_t v53 = *(_WORD *)(v53 - v8);
          *(_WORD *)(v53 + 2) = *(_WORD *)(v53 - v8 + 2);
          v53 += 4;
        }
        while (v53 < v56);
      }
    }
    else if (v7 >= 1)
    {
      do
      {
        *(void *)unint64_t v53 = *(void *)(v53 - v8);
        *(void *)(v53 + 8) = *(void *)(v53 - v8 + 8);
        v53 += 16;
      }
      while (v53 < v56);
    }
    while (1)
    {
LABEL_36:
      if (v9 >= v12)
      {
        unint64_t v34 = *(void *)(a1 + 40);
      }
      else
      {
        unint64_t v34 = *(void *)(a1 + 40);
        if (*(void *)(a1 + 32) <= v34)
        {
          size_t result = 0;
          int v58 = 5;
          goto LABEL_82;
        }
        unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> (v34 & 7);
        unint64_t v10 = *(void *)(*v4 + (v34 >> 3)) >> (v34 & 7);
      }
      unint64_t v35 = *(unsigned __int16 *)(v5 + 2 * (v10 & v12));
      uint64_t v36 = (v35 & 0xF) + 1;
      unint64_t v18 = v35 >> 4;
      *(void *)(a1 + 96) = v18;
      v10 >>= v36;
      v9 >>= v36;
      *(void *)(a1 + 40) = v36 + v34;
LABEL_41:
      if (v18 > 0xFF) {
        break;
      }
      if (!*(void *)(a1 + 8))
      {
        *(_DWORD *)(a1 + 48) = 6;
        *(void *)(a1 + 112) = v10;
        *(void *)(a1 + 120) = v9;
        *(_DWORD *)(a1 + 88) = v12;
        *(_DWORD *)(a1 + 92) = v11;
LABEL_84:
        size_t v29 = *(void *)(a1 + 64);
        return v29 - *(void *)a1;
      }
      size_t v37 = *(unsigned char **)(a1 + 64);
      *(void *)(a1 + 64) = v37 + 1;
      *size_t v37 = v18;
      uint64_t v38 = *(void *)(a1 + 8) - 1;
LABEL_61:
      *(void *)(a1 + 8) = v38;
    }
    unint64_t v39 = v18 - 256;
    *(void *)(a1 + 96) = v39;
    if (!v39)
    {
LABEL_8:
      while (!*(_DWORD *)(a1 + 52))
      {
        unint64_t v13 = *(void *)(a1 + 32);
        unint64_t v19 = *(void *)(a1 + 40);
        unint64_t v20 = v13 - v19;
        if (v13 < v19) {
          unint64_t v20 = 0;
        }
        if (v20 <= 2)
        {
          size_t result = 0;
          *(_DWORD *)(a1 + 48) = 0;
          return result;
        }
        *(void *)(a1 + 72) = 0x800000008000;
        uint64_t v21 = *(void *)(a1 + 24);
        *(_DWORD *)(a1 + 52) = (*(void *)(v21 + (v19 >> 3)) >> (v19 & 7)) & 1;
        uint64_t v22 = *(void *)(v21 + ((v19 + 1) >> 3)) >> ((v19 + 1) & 7);
        unint64_t v14 = v19 + 3;
        *(void *)(a1 + 40) = v19 + 3;
        int v23 = v22 & 3;
        switch(v23)
        {
          case 1:
            if (staticHuffmanTable((int *)(a1 + 72), v5, (int *)(a1 + 76), v6)) {
              goto LABEL_71;
            }
            goto LABEL_32;
          case 2:
LABEL_29:
            if (readHuffmanTable(v4, (int *)(a1 + 72), v5, (int *)(a1 + 76), v6))
            {
              size_t result = 0;
              *(void *)(a1 + 40) = v14;
              int v33 = 3;
              goto LABEL_72;
            }
LABEL_32:
            unint64_t v9 = 0;
            unint64_t v10 = 0;
            int v12 = *(_DWORD *)(a1 + 72) - 1;
            int v11 = *(_DWORD *)(a1 + 76) - 1;
            goto LABEL_36;
          case 3:
            goto LABEL_71;
        }
LABEL_15:
        unint64_t v24 = v13 - v14;
        if (v13 < v14) {
          unint64_t v24 = 0;
        }
        if (v24 <= 0xF)
        {
          size_t result = 0;
          int v33 = 1;
          goto LABEL_72;
        }
        uint64_t v17 = *(void *)(a1 + 24);
        size_t v16 = *(unsigned __int16 *)(v17 + ((v14 + 7) >> 3));
        *(void *)(a1 + 80) = v16;
        unint64_t v15 = ((v14 + 7) & 0xFFFFFFFFFFFFFFF8) + 32;
        *(void *)(a1 + 40) = v15;
LABEL_19:
        BOOL v25 = v13 >= v15;
        unint64_t v26 = v13 - v15;
        if (!v25) {
          unint64_t v26 = 0;
        }
        size_t v27 = v26 >> 3;
        if (v27 >= *(void *)(a1 + 8)) {
          size_t v27 = *(void *)(a1 + 8);
        }
        if (v27 >= v16) {
          size_t v28 = v16;
        }
        else {
          size_t v28 = v27;
        }
        memcpy(*(void **)(a1 + 64), (const void *)(v17 + (v15 >> 3)), v28);
        *(void *)(a1 + 40) += 8 * v28;
        *(void *)(a1 + 8) -= v28;
        size_t v29 = *(void *)(a1 + 64) + v28;
        *(void *)(a1 + 64) = v29;
        size_t v30 = *(void *)(a1 + 80);
        BOOL v31 = v30 > v28;
        size_t v32 = v30 - v28;
        if (v31)
        {
          *(void *)(a1 + 80) = v32;
          *(_DWORD *)(a1 + 48) = 2;
          return v29 - *(void *)a1;
        }
      }
      *(_DWORD *)(a1 + 48) = 11;
      goto LABEL_84;
    }
LABEL_45:
    unint64_t v40 = *(void *)(a1 + 40);
    if (*(void *)(a1 + 32) <= v40)
    {
      size_t result = 0;
      int v58 = 7;
LABEL_82:
      *(_DWORD *)(a1 + 48) = v58;
      *(void *)(a1 + 112) = v10;
      *(void *)(a1 + 120) = v9;
      *(_DWORD *)(a1 + 88) = v12;
      *(_DWORD *)(a1 + 92) = v11;
      return result;
    }
    unint64_t v41 = *(void *)(a1 + 96);
    if (v41 < 0x1E)
    {
      unint64_t v42 = 0xFFFFFFFFFFFFFFFFLL >> (v40 & 7);
      unint64_t v43 = *(void *)(*(void *)(a1 + 24) + (v40 >> 3)) >> (v40 & 7);
      uint64_t v7 = zlibDecodeBufferSafe_litlen_base[v41];
      if (v41 >= 9 && v41 != 29)
      {
        unint64_t v44 = (v41 - 5) >> 2;
        v7 += v43 & ~(-1 << v44);
        v43 >>= v44;
        v42 >>= v44;
        v40 += v44;
        *(void *)(a1 + 40) = v40;
      }
      unint64_t v45 = *(unsigned __int16 *)(v6 + 2 * (v43 & v11));
      if (v45 < 0x1E0)
      {
        unint64_t v46 = v45 >> 4;
        unint64_t v8 = zlibDecodeBufferSafe_distance_base[v45 >> 4];
        uint64_t v47 = (v45 & 0xF) + 1;
        unint64_t v10 = v43 >> v47;
        unint64_t v9 = v42 >> v47;
        unint64_t v48 = v40 + v47;
        *(void *)(a1 + 40) = v48;
        if (v45 >= 0x40)
        {
          unint64_t v49 = v46 - 2;
          unint64_t v50 = (v46 - 2) >> 1;
          v8 += v10 & ~(-1 << v50);
          v10 >>= v50;
          v9 >>= v50;
          *(void *)(a1 + 40) = v48 + (v49 >> 1);
        }
LABEL_53:
        if (v8 - 1 < *(void *)(a1 + 64) - *(void *)a1) {
          continue;
        }
      }
    }
    break;
  }
LABEL_71:
  size_t result = 0;
  int v33 = 12;
LABEL_72:
  *(_DWORD *)(a1 + 48) = v33;
  return result;
}

void **WrapRingBuffer(void **result)
{
  if (((_WORD)result[83] & 8) != 0)
  {
    int v1 = result;
    size_t result = (void **)memcpy(result[15], v1[16], *((int *)v1 + 19));
    *((_WORD *)v1 + 332) &= ~8u;
  }
  return result;
}

uint64_t lzma_stream_process(void *a1, char a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[3];
  *(void *)(v3 + 24) = a1[2];
  *(void *)(v3 + 32) = v4;
  uint64_t v5 = a1[1];
  *(void *)(v3 + 48) = *a1;
  *(void *)(v3 + 56) = v5;
  *(_DWORD *)(v3 + 16) |= a2 & 1;
  uint64_t result = lzma_code();
  uint64_t v7 = *(void *)(v3 + 32);
  a1[2] += a1[3] - v7;
  a1[3] = v7;
  uint64_t v8 = *(void *)(v3 + 56);
  *a1 += a1[1] - v8;
  a1[1] = v8;
  if (!result) {
    return 0;
  }
  if (result == 1) {
    return result;
  }
  if (result != 10) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t staticHuffmanTable(int *a1, uint64_t a2, int *a3, uint64_t a4)
{
  unint64_t v4 = 0;
  uint64_t v54 = *MEMORY[0x263EF8340];
  do
  {
    if (v4 <= 0x8F)
    {
LABEL_3:
      *((unsigned char *)&v48[2] + v4) = 8;
      goto LABEL_8;
    }
    if (v4 > 0xFF)
    {
      if (v4 > 0x117) {
        goto LABEL_3;
      }
      *((unsigned char *)&v48[2] + v4) = 7;
    }
    else
    {
      *((unsigned char *)&v48[2] + v4) = 9;
    }
LABEL_8:
    ++v4;
  }
  while (v4 != 288);
  uint64_t v5 = 0;
  *(void *)&long long v6 = 0x505050505050505;
  *((void *)&v6 + 1) = 0x505050505050505;
  v48[0] = v6;
  v48[1] = v6;
  v7.i64[0] = 0x100000001;
  v7.i64[1] = 0x100000001;
  v8.i64[0] = 0x100000001;
  v8.i64[1] = 0x100000001;
  v9.i64[0] = 0x100000001;
  v9.i64[1] = 0x100000001;
  v10.i64[0] = 0x100000001;
  v10.i64[1] = 0x100000001;
  do
  {
    uint8x16_t v11 = (uint8x16_t)v48[v5 + 2];
    uint16x8_t v12 = vmovl_u8(*(uint8x8_t *)v11.i8);
    uint16x8_t v13 = vmovl_high_u8(v11);
    int32x4_t v10 = vmaxq_s32(v10, (int32x4_t)vmovl_high_u16(v13));
    int32x4_t v9 = vmaxq_s32(v9, (int32x4_t)vmovl_u16(*(uint16x4_t *)v13.i8));
    int32x4_t v8 = vmaxq_s32(v8, (int32x4_t)vmovl_high_u16(v12));
    int32x4_t v7 = vmaxq_s32(v7, (int32x4_t)vmovl_u16(*(uint16x4_t *)v12.i8));
    ++v5;
  }
  while (v5 != 18);
  int v14 = 1 << vmaxvq_s32(vmaxq_s32(vmaxq_s32(v7, v9), vmaxq_s32(v8, v10)));
  if (v14 > *a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  do
    ++*((_DWORD *)&v50 + *((unsigned __int8 *)&v48[2] + v15++));
  while (v15 != 288);
  uint64_t v16 = 0;
  int v17 = 0;
  LODWORD(v50) = 0;
  v49[0] = 0;
  do
  {
    int v17 = 2 * (*(_DWORD *)((char *)&v50 + v16 * 4) + v17);
    v49[++v16] = v17;
  }
  while (v16 != 15);
  for (uint64_t i = 0;
        i != 288;
        *((_WORD *)&v48[20] + i++) = (breverse_brev8[BYTE1(v20)] | (breverse_brev8[v20] << 8)) >> (16 - v19))
  {
    uint64_t v19 = *((unsigned __int8 *)&v48[2] + i);
    int v20 = v49[v19];
    v49[v19] = v20 + 1;
  }
  for (uint64_t j = 0; j != 288; ++j)
  {
    __int16 v22 = *((unsigned __int8 *)&v48[2] + j);
    if (*((unsigned char *)&v48[2] + j))
    {
      uint64_t v23 = *((unsigned __int16 *)&v48[20] + j);
      if (v14 > (int)v23)
      {
        __int16 v24 = v22 + 16 * j - 1;
        uint64_t v25 = 1 << v22;
        do
        {
          *(_WORD *)(a2 + 2 * v23) = v24;
          v23 += v25;
        }
        while (v23 < v14);
      }
    }
  }
  uint64_t v26 = 0;
  v27.i64[0] = 0x100000001;
  v27.i64[1] = 0x100000001;
  v28.i64[0] = 0x100000001;
  v28.i64[1] = 0x100000001;
  v29.i64[0] = 0x100000001;
  v29.i64[1] = 0x100000001;
  v30.i64[0] = 0x100000001;
  v30.i64[1] = 0x100000001;
  do
  {
    uint8x16_t v31 = (uint8x16_t)v48[v26];
    uint16x8_t v32 = vmovl_u8(*(uint8x8_t *)v31.i8);
    uint16x8_t v33 = vmovl_high_u8(v31);
    int32x4_t v30 = vmaxq_s32(v30, (int32x4_t)vmovl_high_u16(v33));
    int32x4_t v29 = vmaxq_s32(v29, (int32x4_t)vmovl_u16(*(uint16x4_t *)v33.i8));
    int32x4_t v28 = vmaxq_s32(v28, (int32x4_t)vmovl_high_u16(v32));
    int32x4_t v27 = vmaxq_s32(v27, (int32x4_t)vmovl_u16(*(uint16x4_t *)v32.i8));
    ++v26;
  }
  while (v26 != 2);
  int v34 = 1 << vmaxvq_s32(vmaxq_s32(vmaxq_s32(v27, v29), vmaxq_s32(v28, v30)));
  if (v34 > *a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v36 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  do
    ++*((_DWORD *)&v50 + *((unsigned __int8 *)v48 + v36++));
  while (v36 != 32);
  uint64_t v37 = 0;
  int v38 = 0;
  LODWORD(v50) = 0;
  v49[0] = 0;
  do
  {
    int v38 = 2 * (*(_DWORD *)((char *)&v50 + v37 * 4) + v38);
    v49[++v37] = v38;
  }
  while (v37 != 15);
  for (uint64_t k = 0; k != 32; ++k)
  {
    uint64_t v40 = *((unsigned __int8 *)v48 + k);
    int v41 = v49[v40];
    v49[v40] = v41 + 1;
    *((_WORD *)&v48[20] + k) = (breverse_brev8[BYTE1(v41)] | (breverse_brev8[v41] << 8)) >> (16 - v40);
  }
  for (uint64_t m = 0; m != 32; ++m)
  {
    __int16 v43 = *((unsigned __int8 *)v48 + m);
    if (*((unsigned char *)v48 + m))
    {
      uint64_t v44 = *((unsigned __int16 *)&v48[20] + m);
      if (v34 > (int)v44)
      {
        __int16 v45 = v43 + 16 * m - 1;
        uint64_t v46 = 1 << v43;
        do
        {
          *(_WORD *)(a4 + 2 * v44) = v45;
          v44 += v46;
        }
        while (v44 < v34);
      }
    }
  }
  uint64_t v35 = 0;
  *a1 = v14;
  *a3 = v34;
  return v35;
}

uint64_t lzfse_stream_init(uint64_t a1, int a2, int a3, int a4)
{
  if (a2 == 1) {
    return lzfseStreamDecodeInit(a1, a3, a4);
  }
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  return lzfseStreamEncodeInit(a1, a3, a4);
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  state = stream->state;
  if (!state) {
    return -1;
  }
  int v2 = state[1];
  if (v2 <= 2192)
  {
    if (v2 <= 2048)
    {
      if (v2 != 256 && v2 != 517)
      {
        if (v2 == 774) {
          return lzma_stream_end((uint64_t)stream);
        }
        return -1;
      }
      return lzfse_stream_end((uint64_t)stream);
    }
    if ((v2 - 2049) < 2) {
      return lzfse_stream_end((uint64_t)stream);
    }
    return -1;
  }
  if ((v2 - 2304) < 2) {
    return lzfse_stream_end((uint64_t)stream);
  }
  if (v2 != 2818)
  {
    if (v2 == 2193) {
      return lzfse_stream_end((uint64_t)stream);
    }
    return -1;
  }
  return brotli_stream_end((uint64_t)stream);
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  if ((int)algorithm > 2192)
  {
    if (algorithm - 2304 < 2) {
      return lzvn_stream_init((uint64_t)stream, operation, algorithm, 0);
    }
    if (algorithm == COMPRESSION_BROTLI) {
      return brotli_stream_init((uint64_t)stream, operation);
    }
    if (algorithm == 2193) {
      return lzfse_stream_init((uint64_t)stream, operation, algorithm, 0);
    }
    return -1;
  }
  if ((int)algorithm > 2048)
  {
    if (algorithm - 2049 < 2) {
      return lzfse_stream_init((uint64_t)stream, operation, algorithm, 0);
    }
    return -1;
  }
  if (algorithm == COMPRESSION_LZ4) {
    return lz4_stream_init((uint64_t)stream, operation, 0);
  }
  if (algorithm != COMPRESSION_ZLIB)
  {
    if (algorithm == COMPRESSION_LZMA)
    {
      lzma_stream_init((uint64_t)stream, operation);
      return result;
    }
    return -1;
  }
  return zlib_stream_init((uint64_t)stream, operation, 0);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  unsigned __int8 v6 = algorithm;
  if ((algorithm ^ 0xA00) >= 0x100) {
    compression_algorithm v11 = algorithm;
  }
  else {
    compression_algorithm v11 = 2584;
  }
  int v12 = v11 & 0xF;
  if (v11 - 2816 >= 0xA)
  {
    int v13 = 2;
  }
  else
  {
    compression_algorithm v11 = COMPRESSION_BROTLI;
    int v13 = v12;
  }
  int v14 = v11 & 0xF;
  if (v11 - 512 >= 0xA)
  {
    int v15 = 5;
  }
  else
  {
    compression_algorithm v11 = COMPRESSION_ZLIB;
    int v15 = v14;
  }
  if (v11 - 1280 >= 0xA) {
    compression_algorithm v16 = v11;
  }
  else {
    compression_algorithm v16 = 1285;
  }
  if (v11 - 1280 >= 0xA) {
    int v17 = v15;
  }
  else {
    int v17 = v11 & 0xF;
  }
  size_t v18 = compression_encode_scratch_buffer_size(v16);
  rsize_t v19 = v18;
  if (scratch_buffer) {
    BOOL v20 = 1;
  }
  else {
    BOOL v20 = v18 == 0;
  }
  char v21 = v20;
  if (!v20)
  {
    scratch_buffer = malloc(v18);
    if (!scratch_buffer) {
      return 0;
    }
  }
  char v33 = v21;
  size_t v22 = 0;
  if ((int)v16 <= 2048)
  {
    if ((int)v16 <= 1284)
    {
      if ((int)v16 <= 516)
      {
        if (v16 == COMPRESSION_LZ4)
        {
          unint64_t v23 = lz4_encode_buffer((int32x4_t *)dst_buffer, dst_size, (char *)src_buffer, src_size, (char *)scratch_buffer);
        }
        else
        {
          if (v16 != COMPRESSION_LZ4_RAW) {
            goto LABEL_62;
          }
          unint64_t v23 = lz4raw_encode_buffer((int32x4_t *)dst_buffer, dst_size, (char *)src_buffer, src_size, scratch_buffer);
        }
        goto LABEL_61;
      }
      if (v16 != COMPRESSION_ZLIB)
      {
        if (v16 != COMPRESSION_LZMA) {
          goto LABEL_62;
        }
        unint64_t v23 = lzma_encode_buffer();
        goto LABEL_61;
      }
      uint64_t v25 = dst_buffer;
      size_t v26 = dst_size;
      int32x4_t v27 = src_buffer;
      size_t v28 = src_size;
      int32x4_t v29 = scratch_buffer;
      int v30 = v17;
      int v31 = 0;
    }
    else
    {
      if (v16 - 1536 < 3)
      {
        unint64_t v23 = lzbitmap_fast_encode_buffer((uint64_t)dst_buffer, dst_size, (char *)src_buffer, src_size, scratch_buffer, v16 & 0xF);
        goto LABEL_61;
      }
      if (v16 - 1792 < 3)
      {
        unint64_t v23 = lzbitmap_encode_buffer((int *)dst_buffer, dst_size, (uint64_t)src_buffer, src_size, (uint64_t)scratch_buffer, v16 & 0xF);
LABEL_61:
        size_t v22 = v23;
        goto LABEL_62;
      }
      if (v16 != 1285) {
        goto LABEL_62;
      }
      uint64_t v25 = dst_buffer;
      size_t v26 = dst_size;
      int32x4_t v27 = src_buffer;
      size_t v28 = src_size;
      int32x4_t v29 = scratch_buffer;
      int v30 = v17;
      int v31 = 1;
    }
    unint64_t v23 = (unint64_t)zlib_encode_buffer((uint64_t)v25, v26, (uint64_t)v27, v28, (uint64_t)v29, v30, v31);
    goto LABEL_61;
  }
  if ((int)v16 > 2583)
  {
    if (v16 - 3072 > 0x20 || ((1 << v16) & 0x100010001) == 0)
    {
      if (v16 == 2584)
      {
        unint64_t v23 = lz24_encode_buffer((char *)dst_buffer, dst_size, (char *)src_buffer, src_size, (char *)scratch_buffer, v6);
      }
      else
      {
        if (v16 != COMPRESSION_BROTLI) {
          goto LABEL_62;
        }
        unint64_t v23 = brotli_encode_buffer(dst_buffer, dst_size, (uint64_t *)src_buffer, src_size, (uint64_t)scratch_buffer, v13);
      }
    }
    else
    {
      unint64_t v23 = smb_encode_buffer(dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, v16);
    }
    goto LABEL_61;
  }
  if ((int)v16 > 2208)
  {
    if (v16 - 2304 < 2)
    {
      unint64_t v23 = (unint64_t)lzvn_encode_buffer((char *)dst_buffer, dst_size, (const float *)src_buffer, src_size, (int8x16_t *)scratch_buffer, v16);
      goto LABEL_61;
    }
    if (v16 != 2209) {
      goto LABEL_62;
    }
LABEL_56:
    unint64_t v23 = (unint64_t)lzfse_encode_buffer((uint64_t)dst_buffer, dst_size, (const float *)src_buffer, src_size, (int8x16_t *)scratch_buffer, v16);
    goto LABEL_61;
  }
  if (v16 - 2049 < 2 || v16 == 2193) {
    goto LABEL_56;
  }
LABEL_62:
  if ((v33 & 1) == 0)
  {
    memset_s(scratch_buffer, v19, 0, v19);
    free(scratch_buffer);
  }
  return v22;
}

size_t compression_encode_scratch_buffer_size(compression_algorithm algorithm)
{
  if ((algorithm ^ 0xA00) >= 0x100) {
    compression_algorithm v1 = algorithm;
  }
  else {
    compression_algorithm v1 = 2584;
  }
  if (v1 - 512 >= 0xA) {
    int v2 = v1;
  }
  else {
    int v2 = 517;
  }
  if ((v2 - 1280) >= 0xA) {
    int v3 = v2;
  }
  else {
    int v3 = 1285;
  }
  if (v3 > 2048)
  {
    if (v3 <= 2303)
    {
      if ((v3 - 2049) < 2 || v3 == 2193 || v3 == 2209) {
        return lzfse_encode_scratch_size(v3);
      }
      return 0;
    }
    if ((v3 - 3072) <= 0x20 && ((1 << v3) & 0x100010001) != 0) {
      return smb_encode_scratch_size(v3);
    }
    if ((v3 - 2304) < 2) {
      return lzvn_encode_scratch_size(v3);
    }
    if (v3 != 2584) {
      return 0;
    }
    return lz24_encode_scratch_buffer_size();
  }
  else
  {
    if (v3 > 1284)
    {
      if ((v3 - 1536) < 3) {
        return lzbitmap_fast_encode_scratch_size(v3 & 0xF);
      }
      if ((v3 - 1792) < 3) {
        return lzbitmap_encode_scratch_size(v3 & 0xF);
      }
      if (v3 != 1285) {
        return 0;
      }
      return zlib_encode_scratch_size();
    }
    if (v3 <= 773)
    {
      if ((v3 - 256) < 2) {
        return 0x8000;
      }
      if (v3 != 517) {
        return 0;
      }
      return zlib_encode_scratch_size();
    }
    if (v3 != 774) {
      return 0;
    }
    return lzvn_decode_scratch_size();
  }
}

uint64_t lz4_encode_buffer(int32x4_t *a1, unint64_t a2, char *a3, unint64_t a4, char *__b)
{
  int32x4_t v7 = a3;
  __int16 v24 = a3;
  memset_pattern8(__b, &unk_20DAB5A78, 0x8000uLL);
  size_t v22 = a1;
  if (a4)
  {
    int32x4_t v10 = a1;
    uint64_t v11 = (uint64_t)v7;
    while (1)
    {
      if (a2 < 0xC) {
        return 0;
      }
      unint64_t v12 = a4 >= 0x10000 ? 0x10000 : a4;
      int v13 = (int32x4_t *)((char *)&v10->u64[1] + 4);
      unint64_t v23 = (int32x4_t *)((char *)&v10->u64[1] + 4);
      lz4_encode_2gb(&v23, a2 - 12, &v24, v11, v12, (uint64_t)__b, 0);
      if (v24 - v7 < v12) {
        break;
      }
      if (v23 == v13) {
        goto LABEL_12;
      }
      int v14 = v23 - v13;
      int64_t v15 = (char *)v23 - (char *)v10;
      if ((char *)v23 - (char *)v10 >= v12 + 8) {
        goto LABEL_12;
      }
      v10->i32[0] = 825521762;
      v10->i32[1] = v12;
      v10->i32[2] = v14;
      int32x4_t v10 = v23;
      int32x4_t v7 = v24;
      a2 -= v15;
LABEL_15:
      if ((uint64_t)&v7[-v11] >= 1610612736)
      {
        for (uint64_t i = 0; i != 0x8000; i += 8)
        {
          unsigned int v19 = *(_DWORD *)&__b[i];
          if (v19 != 0x80000000)
          {
            if (v19 >> 30) {
              unsigned int v20 = v19 - 0x40000000;
            }
            else {
              unsigned int v20 = 0x80000000;
            }
            *(_DWORD *)&__b[i] = v20;
          }
        }
        v11 += 0x40000000;
      }
      a4 -= v12;
      if (!a4) {
        goto LABEL_27;
      }
    }
    unint64_t v23 = (int32x4_t *)((char *)&v10->u64[1] + 4);
    __int16 v24 = &v7[v12];
LABEL_12:
    v10->i32[0] = 758412898;
    v10->i32[1] = v12;
    BOOL v16 = a2 - 8 >= v12;
    a2 = a2 - 8 - v12;
    if (!v16) {
      return 0;
    }
    int v17 = &v10->u64[1];
    int32x4_t v7 = v24;
    memcpy(v17, &v24[-v12], v12);
    int32x4_t v10 = (int32x4_t *)((char *)v17 + v12);
    goto LABEL_15;
  }
  int32x4_t v10 = a1;
LABEL_27:
  if (a2 < 4) {
    return 0;
  }
  v10->i32[0] = 607417954;
  return (char *)v10 - (char *)v22 + 4;
}

int32x4_t **lz4_encode_2gb(int32x4_t **result, uint64_t a2, char **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int32x4_t v7 = vdupq_n_s32(0xFFFFFFFF);
  int32x4_t v8 = *result;
  int32x4_t v9 = *a3;
  uint64_t v10 = (uint64_t)(*result)[-8].i64 + a2;
  if (v10 < (uint64_t)*result) {
    goto LABEL_92;
  }
  uint64_t v11 = (uint64_t)&v9[a5 - 128];
  if (v11 >= (uint64_t)v9)
  {
    do
    {
      unint64_t v12 = v9;
      int v13 = &v9[-a4];
      while (1)
      {
        unint64_t v14 = *v12;
        int64_t v15 = (int *)(a6 + 8 * ((-1640531535 * *v12) >> 20));
        int v16 = *v15;
        int v17 = v15[1];
        int *v15 = (int)v13;
        v15[1] = v14;
        unint64_t v18 = v14 >> 8;
        unsigned int v19 = (int *)(a6 + 8 * ((-1640531535 * (v14 >> 8)) >> 20));
        int v20 = *v19;
        int v21 = v19[1];
        int *v19 = v13 + 1;
        v19[1] = v14 >> 8;
        if (v14 == v17)
        {
          uint64_t v22 = (v13 - v16);
          if (v22 < 0x10000 && v22 != 0) {
            break;
          }
        }
        unint64_t v12 = (void *)((char *)v12 + 1);
        __int16 v24 = v13 + 1;
        unint64_t v25 = v14 >> 16;
        size_t v26 = (int *)(a6 + 8 * ((-1640531535 * v25) >> 20));
        int v27 = *v26;
        int v28 = v26[1];
        int *v26 = v24 + 1;
        v26[1] = v25;
        if (v18 == v21)
        {
          uint64_t v22 = (v24 - v20);
          if (v22 < 0x10000 && v24 != v20) {
            break;
          }
        }
        unint64_t v12 = (void *)((char *)v12 + 1);
        int v30 = v24 + 1;
        unint64_t v31 = v25 >> 8;
        uint16x8_t v32 = (int *)(a6 + 8 * ((-1640531535 * (v25 >> 8)) >> 20));
        int v33 = *v32;
        int v34 = v32[1];
        *uint16x8_t v32 = v30 + 1;
        v32[1] = v25 >> 8;
        if (v25 == v28)
        {
          uint64_t v22 = (v30 - v27);
          if (v22 < 0x10000 && v30 != v27) {
            break;
          }
        }
        unint64_t v12 = (void *)((char *)v12 + 1);
        uint64_t v36 = v30 + 1;
        unint64_t v37 = v25 >> 16;
        int v38 = (int *)(a6 + 8 * ((-1640531535 * v37) >> 20));
        int v39 = *v38;
        int v40 = v38[1];
        *int v38 = v36 + 1;
        v38[1] = v37;
        if (v31 == v34)
        {
          uint64_t v22 = (v36 - v33);
          if (v22 < 0x10000 && v36 != v33) {
            break;
          }
        }
        unint64_t v12 = (void *)((char *)v12 + 1);
        unint64_t v42 = v36 + 1;
        if (v37 == v40)
        {
          uint64_t v22 = (v42 - v39);
          if (v22 < 0x10000 && v42 != v39) {
            break;
          }
        }
        unint64_t v12 = (void *)((char *)v12 + 1);
        int v13 = v42 + 1;
        if ((unint64_t)v12 >= v11) {
          goto LABEL_74;
        }
      }
      uint64_t v44 = (char *)v12 + 4;
      __int16 v45 = (void *)((char *)v12 - v22 + 4);
      while (1)
      {
        uint64_t v47 = *(void *)v44;
        v44 += 8;
        uint64_t v46 = v47;
        uint64_t v49 = *v45++;
        uint64_t v48 = v49;
        if (v46 != v49) {
          break;
        }
        if ((unint64_t)v44 >= v11) {
          goto LABEL_38;
        }
      }
      uint64_t v44 = &v44[(__clz(__rbit64(v46 ^ v48)) >> 3) - 8];
LABEL_38:
      long long v50 = (char *)v12 - v22;
      while (1)
      {
        BOOL v51 = (uint64_t)v12 <= (uint64_t)v9 || (uint64_t)v50 <= a4;
        if (v51) {
          break;
        }
        int v53 = *((unsigned __int8 *)v12 - 1);
        unint64_t v12 = (void *)((char *)v12 - 1);
        int v52 = v53;
        int v54 = *--v50;
        if (v52 != v54)
        {
          unint64_t v12 = (void *)((char *)v12 + 1);
          break;
        }
      }
      unint64_t v55 = v44 - (char *)v12 - 4;
      uint64_t v56 = (char *)v12 - v9;
      unint64_t v57 = (char *)v12 - v9 + 3;
      unint64_t v58 = v10 - (void)v8 - v57;
      if (v10 - (uint64_t)v8 < v57) {
        goto LABEL_92;
      }
      __int8 v59 = (v55 & 0xF) + 16 * v56;
      unint64_t v60 = (int32x4_t *)&v8->i8[1];
      if ((unint64_t)v56 >= 0xF)
      {
        v59 |= 0xF0u;
        unint64_t v61 = v56 - 15;
        BOOL v62 = v58-- != 0;
        if (!v62) {
          goto LABEL_92;
        }
        if (v61 >= 0xFF)
        {
          unint64_t v63 = v61 / 0xFFuLL;
          BOOL v62 = v58 >= v63;
          v58 -= v63;
          if (!v62) {
            goto LABEL_92;
          }
          LOBYTE(v61) = v61 + v63;
          do
          {
            *v60++ = v7;
            BOOL v51 = v63 > 0x10;
            v63 -= 16;
          }
          while (v51);
          unint64_t v60 = (int32x4_t *)((char *)v60 + v63);
        }
        v60->i8[0] = v61;
        unint64_t v60 = (int32x4_t *)((char *)v60 + 1);
      }
      do
      {
        int32x4_t v64 = *(int32x4_t *)v9;
        v9 += 16;
        *v60++ = v64;
        BOOL v51 = v56 <= 16;
        v56 -= 16;
      }
      while (!v51);
      unint64_t v65 = (__int16 *)((char *)v60->i16 + v56);
      *unint64_t v65 = v22;
      uint64_t v66 = (int32x4_t *)(v65 + 1);
      if (v55 >= 0xF)
      {
        v59 |= 0xFu;
        unint64_t v67 = v44 - (char *)v12 - 19;
        BOOL v62 = v58 != 0;
        unint64_t v68 = v58 - 1;
        if (!v62) {
          goto LABEL_92;
        }
        if (v67 >= 0xFF)
        {
          unint64_t v69 = v67 / 0xFFuLL;
          if (v68 < v69) {
            goto LABEL_92;
          }
          LOBYTE(v67) = v67 + v69;
          do
          {
            *v66++ = v7;
            BOOL v51 = v69 > 0x10;
            v69 -= 16;
          }
          while (v51);
          uint64_t v66 = (int32x4_t *)((char *)v66 + v69);
        }
        v66->i8[0] = v67;
        uint64_t v66 = (int32x4_t *)((char *)v66 + 1);
      }
      v8->i8[0] = v59;
      int32x4_t v8 = v66;
      int32x4_t v9 = v44;
    }
    while ((uint64_t)v44 < v11 && (uint64_t)v66 < v10);
  }
LABEL_74:
  if (a7) {
    goto LABEL_92;
  }
  unint64_t v71 = (char *)(v11 + 128);
  uint64_t v72 = v71 - v9;
  if (v71 == v9) {
    goto LABEL_92;
  }
  uint64_t v73 = v10 + 128 - (void)v8 - 1;
  BOOL v51 = v73 <= v72;
  uint64_t v74 = v73 - v72;
  if (v51) {
    goto LABEL_92;
  }
  if (v72 < 15)
  {
    v8->i8[0] = 16 * v72;
    int32x4_t v8 = (int32x4_t *)((char *)v8 + 1);
    do
    {
LABEL_91:
      __int8 v81 = *v9++;
      v8->i8[0] = v81;
      int32x4_t v8 = (int32x4_t *)((char *)v8 + 1);
    }
    while (v9 < v71);
    goto LABEL_92;
  }
  uint64_t v75 = v74 - 1;
  if (v75 >= 0)
  {
    v8->i8[0] = -16;
    unsigned int v76 = (int32x4_t *)&v8->i8[1];
    unsigned int v77 = v72 - 15;
    if ((unint64_t)(v72 - 15) >= 0xFF)
    {
      int64_t v78 = v77 / 0xFFuLL;
      if (v75 - v78 < 0)
      {
        int32x4_t v8 = (int32x4_t *)((char *)v76 - 1);
        goto LABEL_92;
      }
      LOBYTE(v77) = v77 + v78;
      do
      {
        *v76++ = v7;
        BOOL v51 = v78 <= 16;
        v78 -= 16;
      }
      while (!v51);
      unsigned int v76 = (int32x4_t *)((char *)v76 + v78);
    }
    v76->i8[0] = v77;
    int32x4_t v8 = (int32x4_t *)&v76->i8[1];
    uint64_t v79 = (unint64_t)v72 >> 4;
    if (!((unint64_t)v72 >> 4)) {
      goto LABEL_91;
    }
    do
    {
      int32x4_t v80 = *(int32x4_t *)v9;
      v9 += 16;
      *v8++ = v80;
      BOOL v51 = v79-- <= 1;
    }
    while (!v51);
    if (v9 < v71) {
      goto LABEL_91;
    }
  }
LABEL_92:
  *compression_status result = v8;
  *a3 = v9;
  return result;
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  if ((algorithm ^ 0xA00) >= 0x100) {
    compression_algorithm v11 = algorithm;
  }
  else {
    compression_algorithm v11 = 2584;
  }
  if (v11 - 2816 < 0xA) {
    compression_algorithm v11 = COMPRESSION_BROTLI;
  }
  if (v11 - 512 < 0xA) {
    compression_algorithm v11 = COMPRESSION_ZLIB;
  }
  if (v11 - 1280 >= 0xA) {
    compression_algorithm v12 = v11;
  }
  else {
    compression_algorithm v12 = 1285;
  }
  size_t v13 = compression_decode_scratch_buffer_size(v12);
  rsize_t v18 = v13;
  if (scratch_buffer) {
    BOOL v19 = 1;
  }
  else {
    BOOL v19 = v13 == 0;
  }
  char v20 = v19;
  if (!v19)
  {
    scratch_buffer = malloc(v13);
    if (!scratch_buffer) {
      return 0;
    }
  }
  size_t v21 = 0;
  if ((int)v12 <= 2048)
  {
    if ((int)v12 <= 1284)
    {
      if ((int)v12 <= 516)
      {
        if (v12 == COMPRESSION_LZ4)
        {
          unint64_t v22 = lz4_decode_buffer((char *)dst_buffer, (unsigned char *)dst_size, (unsigned __int8 *)src_buffer, src_size);
        }
        else
        {
          if (v12 != COMPRESSION_LZ4_RAW) {
            goto LABEL_60;
          }
          unint64_t v22 = (unint64_t)lz4raw_decode_buffer((char *)dst_buffer, dst_size, (unsigned __int8 *)src_buffer, src_size);
        }
        goto LABEL_59;
      }
      if (v12 != COMPRESSION_ZLIB)
      {
        if (v12 == COMPRESSION_LZMA)
        {
          size_t v21 = lzma_xz_buffer_decode((uint64_t)dst_buffer, dst_size, (uint64_t)src_buffer, src_size, scratch_buffer);
          if (v21) {
            goto LABEL_60;
          }
          unint64_t v22 = lzma_decode_buffer();
        }
        else
        {
          if (v12 != 1031) {
            goto LABEL_60;
          }
          unint64_t v22 = lzx_decode_buffer((uint64_t)dst_buffer, dst_size, (uint64_t)src_buffer, src_size, (unsigned int *)scratch_buffer);
        }
        goto LABEL_59;
      }
      __int16 v24 = dst_buffer;
      size_t v25 = dst_size;
      size_t v26 = (unsigned __int8 *)src_buffer;
      size_t v27 = src_size;
      int v28 = scratch_buffer;
      int v29 = 0;
      goto LABEL_57;
    }
    if (v12 - 1536 < 3)
    {
      unint64_t v22 = lzbitmap_fast_decode_buffer((uint64_t)dst_buffer, dst_size, (int8x16_t *)src_buffer, src_size, v14);
    }
    else
    {
      if (v12 - 1792 >= 3)
      {
        if (v12 != 1285) {
          goto LABEL_60;
        }
        __int16 v24 = dst_buffer;
        size_t v25 = dst_size;
        size_t v26 = (unsigned __int8 *)src_buffer;
        size_t v27 = src_size;
        int v28 = scratch_buffer;
        int v29 = 1;
LABEL_57:
        unint64_t v22 = zlib_decode_buffer(v24, v25, v26, v27, (uint64_t)v28, v29);
        goto LABEL_59;
      }
      unint64_t v22 = lzbitmap_decode_buffer((uint64_t)dst_buffer, dst_size, src_buffer, src_size, (uint64_t)scratch_buffer, *(double *)v14.i64, v15, v16, v17);
    }
LABEL_59:
    size_t v21 = v22;
    goto LABEL_60;
  }
  if ((int)v12 > 2583)
  {
    if (v12 - 3072 > 0x20 || ((1 << v12) & 0x100010001) == 0)
    {
      if (v12 == 2584)
      {
        unint64_t v22 = lz24_decode_buffer((char *)dst_buffer, dst_size, (unsigned int *)src_buffer, src_size);
      }
      else
      {
        if (v12 != COMPRESSION_BROTLI) {
          goto LABEL_60;
        }
        unint64_t v22 = brotli_decode_buffer((uint64_t)dst_buffer, dst_size);
      }
    }
    else
    {
      unint64_t v22 = smb_decode_buffer((char *)dst_buffer, dst_size, (char *)src_buffer, src_size, (char *)scratch_buffer, v12);
    }
    goto LABEL_59;
  }
  if ((int)v12 > 2208)
  {
    if (v12 - 2304 >= 2)
    {
      if (v12 != 2209) {
        goto LABEL_60;
      }
      unint64_t v22 = (unint64_t)lzfse_decode_buffer_iboot((char *)dst_buffer, dst_size, (char *)src_buffer, src_size, (char **)scratch_buffer);
    }
    else
    {
      unint64_t v22 = lzvn_decode_buffer((uint64_t)dst_buffer, dst_size, (unint64_t)src_buffer, src_size);
    }
    goto LABEL_59;
  }
  if (v12 - 2049 < 2 || v12 == 2193)
  {
    unint64_t v22 = lzfse_decode_buffer((uint64_t)dst_buffer, dst_size, (uint64_t)src_buffer, src_size, scratch_buffer, v12);
    goto LABEL_59;
  }
LABEL_60:
  if ((v20 & 1) == 0)
  {
    memset_s(scratch_buffer, v18, 0, v18);
    free(scratch_buffer);
  }
  return v21;
}

size_t compression_decode_scratch_buffer_size(compression_algorithm algorithm)
{
  if (algorithm - 512 >= 0xA) {
    compression_algorithm v1 = algorithm;
  }
  else {
    compression_algorithm v1 = COMPRESSION_ZLIB;
  }
  if (v1 - 1280 >= 0xA) {
    int v2 = v1;
  }
  else {
    int v2 = 1285;
  }
  if (v2 > 2192)
  {
    if (v2 > 3071)
    {
      if ((v2 - 3072) <= 0x20 && ((1 << v2) & 0x100010001) != 0) {
        return smb_decode_scratch_size(v2);
      }
      return 0;
    }
    if ((v2 - 2304) < 2) {
      return lzvn_decode_scratch_size();
    }
    if (v2 != 2193)
    {
      if (v2 == 2209) {
        return lzfse_decode_buffer_scratch_size_iboot();
      }
      return 0;
    }
    return lzfse_decode_scratch_size(v2);
  }
  if (v2 > 1284)
  {
    if ((v2 - 1792) < 3) {
      return lzbitmap_decode_scratch_size();
    }
    if ((v2 - 2049) >= 2)
    {
      if (v2 != 1285) {
        return 0;
      }
      return zlib_decode_scratch_size();
    }
    return lzfse_decode_scratch_size(v2);
  }
  switch(v2)
  {
    case 517:
      return zlib_decode_scratch_size();
    case 774:
      return lzma_xz_buffer_decode_scratch_size();
    case 1031:
      return lzx_decode_scratch_size();
  }
  return 0;
}

uint64_t lzfse_decode_scratch_size(int a1)
{
  if (a1 == 2193) {
    return 22376;
  }
  else {
    return 47376;
  }
}

uint64_t lzfse_decode_buffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, int a6)
{
  if (a6 == 2193) {
    size_t v11 = 22376;
  }
  else {
    size_t v11 = 47376;
  }
  if (a6 == 2193) {
    int v12 = 15000;
  }
  else {
    int v12 = 40000;
  }
  bzero(a5, v11);
  *a5 = a3;
  a5[1] = a3;
  a5[2] = a3 + a4;
  a5[3] = a1;
  a5[4] = a1;
  a5[5] = a1 + a2;
  *((_DWORD *)a5 + 1826) = v12;
  int v13 = lzfseDecode((uint64_t)a5);
  if (v13 != -2)
  {
    if (v13) {
      return 0;
    }
    else {
      return a5[3] - a1;
    }
  }
  return a2;
}

uint64_t lzfseDecode(uint64_t a1)
{
  int v2 = (char *)&__dst[16] + 2;
  uint64_t v3 = a1 + 3208;
  uint64_t v4 = a1 + 136;
  uint64_t v154 = a1 + 1160;
  uint64_t v155 = a1 + 648;
  v156 = (_DWORD *)(a1 + 7308);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v5 = *(_DWORD *)(a1 + 52);
        uint64_t result = 4294967293;
        if (v5 <= 829978209) {
          break;
        }
        if (v5 == 829978210 || v5 == 846755426)
        {
          unint64_t v8 = *(void *)(a1 + 16);
          BOOL v9 = v8 > *(void *)a1;
          unint64_t v10 = v8 - *(void *)a1;
          if (!v9 || v10 < *(unsigned int *)(a1 + 76)) {
            return 0xFFFFFFFFLL;
          }
          uint64_t result = lzfse_decode_lmd(a1);
          if (result) {
            return result;
          }
          *(_DWORD *)(a1 + 52) = 0;
          *(void *)a1 += *(unsigned int *)(a1 + 76);
        }
        else
        {
          if (v5 != 1853388386) {
            return result;
          }
          uint64_t v18 = *(unsigned int *)(a1 + 60);
          BOOL v19 = *(const void **)a1;
          unint64_t v20 = *(void *)(a1 + 16);
          if (v18 && v20 <= (unint64_t)v19) {
            return 0xFFFFFFFFLL;
          }
          *(_OWORD *)((char *)&__dst[3] + 8) = 0u;
          *(_OWORD *)((char *)&__dst[4] + 8) = 0u;
          *(_OWORD *)((char *)&__dst[2] + 8) = 0u;
          BOOL v9 = (uint64_t)(v20 - (void)v19) <= v18;
          unint64_t v21 = (unint64_t)v19 + v18;
          if (v9) {
            unint64_t v21 = v20;
          }
          *(void *)&__dst[0] = v19;
          *((void *)&__dst[0] + 1) = v21;
          long long v22 = *(_OWORD *)(a1 + 24);
          __dst[1] = v22;
          *(void *)&__dst[2] = *(void *)(a1 + 40);
          uint64_t v23 = *(unsigned int *)(a1 + 56);
          if (*(void *)&__dst[2] - (void)v22 > v23) {
            *(void *)&__dst[2] = v22 + v23;
          }
          *((void *)&__dst[4] + 1) = *(unsigned int *)(a1 + 64);
          LODWORD(__dst[5]) = 0;
          uint64_t result = lzvnDecode((uint64_t)__dst);
          if (result == -3) {
            return result;
          }
          unint64_t v24 = *(void *)&__dst[0] - *(void *)a1;
          unint64_t v25 = *(unsigned int *)(a1 + 60);
          if (v24 > v25) {
            return 4294967293;
          }
          uint64_t v26 = *(void *)&__dst[1];
          unint64_t v27 = *(void *)&__dst[1] - *(void *)(a1 + 24);
          unint64_t v28 = *(unsigned int *)(a1 + 56);
          if (v27 > v28) {
            return 4294967293;
          }
          *(void *)a1 = *(void *)&__dst[0];
          *(void *)(a1 + 24) = v26;
          int v29 = DWORD2(__dst[4]);
          int v30 = __dst[5];
          int v31 = v25 - v24;
          *(_DWORD *)(a1 + 60) = v31;
          *(_DWORD *)(a1 + 64) = v29;
          *(_DWORD *)(a1 + 56) = v28 - v27;
          if (v31)
          {
            if (v30) {
              BOOL v149 = 1;
            }
            else {
              BOOL v149 = v28 == v27;
            }
            if (v149) {
              return 4294967293;
            }
            else {
              return 4294967294;
            }
          }
          uint64_t result = 4294967293;
          if (v28 != v27 || !v30) {
            return result;
          }
LABEL_41:
          *(_DWORD *)(a1 + 52) = 0;
        }
      }
      if (!v5) {
        break;
      }
      if (v5 != 762869346) {
        return result;
      }
      unint64_t v11 = *(unsigned int *)(a1 + 68);
      if (!v11) {
        goto LABEL_41;
      }
      unint64_t v12 = *(void *)(a1 + 16);
      BOOL v9 = v12 > *(void *)a1;
      unint64_t v13 = v12 - *(void *)a1;
      if (!v9) {
        return 0xFFFFFFFFLL;
      }
      unint64_t v14 = *(void *)(a1 + 40);
      double v15 = *(void **)(a1 + 24);
      BOOL v9 = v14 > (unint64_t)v15;
      unint64_t v16 = v14 - (void)v15;
      if (!v9) {
        return 4294967294;
      }
      if (v13 >= v11) {
        unint64_t v11 = v11;
      }
      else {
        unint64_t v11 = v13;
      }
      if (v16 >= v11) {
        size_t v17 = v11;
      }
      else {
        size_t v17 = v16;
      }
      memmove(v15, *(const void **)a1, v17);
      *(void *)a1 += v17;
      *(void *)(a1 + 24) += v17;
      *(_DWORD *)(a1 + 68) -= v17;
    }
    uint16x8_t v32 = *(unsigned int **)a1;
    int v33 = (_DWORD *)(*(void *)a1 + 4);
    unint64_t v34 = *(void *)(a1 + 16);
    if ((unint64_t)v33 > v34) {
      return 0xFFFFFFFFLL;
    }
    int v35 = *v32;
    if ((int)*v32 <= 846755425) {
      break;
    }
    if (v35 != 846755426)
    {
      if (v35 != 1853388386) {
        return result;
      }
      if ((unint64_t)(v32 + 3) > v34) {
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 56) = v32[1];
      *(void *)(a1 + 60) = v32[2];
      *(void *)a1 = v32 + 3;
      int v36 = 1853388386;
      goto LABEL_130;
    }
LABEL_51:
    int v153 = *v32;
    if (v35 == 846755426)
    {
      uint64_t v151 = v3;
      unint64_t v37 = (unsigned __int8 *)(v32 + 8);
      if ((unint64_t)(v32 + 8) > v34) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v152 = v4;
      unint64_t v38 = *((void *)v32 + 3);
      if ((v38 & 0xFFFFFFE0) == 0) {
        return result;
      }
      BOOL v150 = v2;
      int v39 = (unsigned __int8 *)v32 + *((void *)v32 + 3);
      if ((unint64_t)v39 > v34) {
        return 0xFFFFFFFFLL;
      }
      bzero(&__dst[3], 0x2D4uLL);
      uint64_t v40 = v38;
      unint64_t v42 = *((void *)v32 + 1);
      unint64_t v41 = *((void *)v32 + 2);
      unsigned int v43 = v32[1];
      LODWORD(__dst[0]) = 829978210;
      DWORD1(__dst[0]) = v43;
      unint64_t v44 = v41 >> 30;
      uint64_t v45 = (v41 >> 40) & 0xFFFFF;
      uint64_t v46 = (v41 >> 60) & 7;
      LOWORD(v47) = v41;
      WORD1(v47) = v41 >> 10;
      WORD2(v47) = v41 >> 20;
      uint64_t v48 = (v42 >> 20) & 0xFFFFF;
      LODWORD(v47) = v47 & 0x3FF03FF;
      WORD2(v47) &= 0x3FFu;
      HIWORD(v47) = v44 & 0x3FF;
      *(void *)&__dst[2] = v47;
      LODWORD(__dst[1]) = (v42 >> 40) & 0xFFFFF;
      *(void *)((char *)&__dst[1] + 4) = __PAIR64__(v45, v48);
      HIDWORD(__dst[1]) = ((v42 >> 60) & 7) - 7;
      DWORD2(__dst[2]) = v46 - 7;
      WORD6(__dst[2]) = WORD2(v38) & 0x3FF;
      HIWORD(__dst[2]) = (v38 >> 42) & 0x3FF;
      LOWORD(__dst[3]) = (v38 >> 52) & 0x3FF;
      DWORD2(__dst[0]) = v45 + v48;
      HIDWORD(__dst[0]) = v42 & 0xFFFFF;
      BOOL v49 = v38 >= 0x20uLL;
      if (v38 != 32)
      {
        uint64_t v4 = v152;
        if (v49)
        {
          uint64_t v141 = 0;
          int v142 = 0;
          unsigned int v143 = 0;
          while (1)
          {
            if (v37 >= v39 || v142 > 24)
            {
              int v144 = v142;
            }
            else
            {
              do
              {
                int v144 = v142 + 8;
                int v145 = *v37++;
                v143 |= v145 << v142;
                if (v37 >= v39) {
                  break;
                }
                BOOL v9 = v142 < 17;
                v142 += 8;
              }
              while (v9);
            }
            int v146 = lzfse_freq_nbits_table[v143 & 0x1F];
            if (v146 == 14) {
              int v147 = ((v143 >> 4) & 0x3FF) + 24;
            }
            else {
              LOWORD(v147) = v146 == 8 ? (v143 >> 4) + 8 : lzfse_freq_value_table[v143 & 0x1F];
            }
            int v148 = (char)v146;
            *((_WORD *)&__dst[3] + v141 + 1) = v147;
            int v142 = v144 - (char)v146;
            if (v144 < v148) {
              break;
            }
            v143 >>= v148;
            if (++v141 == 360)
            {
              uint64_t result = 4294967293;
              if (v37 == v39)
              {
                int v2 = v150;
                uint64_t v3 = v151;
                if (v142 < 8) {
                  goto LABEL_61;
                }
              }
              return result;
            }
          }
        }
        return 4294967293;
      }
      int v2 = v150;
      uint64_t v3 = v151;
      uint64_t v4 = v152;
    }
    else
    {
      if ((unint64_t)(v32 + 193) > v34) {
        return 0xFFFFFFFFLL;
      }
      memcpy(__dst, v32, 0x304uLL);
      uint64_t v48 = DWORD1(__dst[1]);
      uint64_t v45 = DWORD2(__dst[1]);
      uint64_t v40 = 772;
    }
LABEL_61:
    long long v50 = (char *)v32 + v40;
    if ((unint64_t)v32 + v40 + v48 + v45 > v34) {
      return 0xFFFFFFFFLL;
    }
    unint64_t v51 = 0;
    int v52 = __dst[1];
    for (uint64_t i = 50; i != 90; i += 2)
      v51 += *(unsigned __int16 *)((char *)__dst + i);
    unint64_t v54 = 0;
    for (uint64_t j = 90; j != 130; j += 2)
      v54 += *(unsigned __int16 *)((char *)__dst + j);
    int64x2_t v56 = 0uLL;
    int64x2_t v57 = 0uLL;
    int64x2_t v58 = 0uLL;
    int64x2_t v59 = 0uLL;
    do
    {
      uint16x8_t v60 = *(uint16x8_t *)((char *)__dst + j);
      uint32x4_t v61 = vmovl_u16(*(uint16x4_t *)v60.i8);
      uint32x4_t v62 = vmovl_high_u16(v60);
      int64x2_t v59 = (int64x2_t)vaddw_high_u32((uint64x2_t)v59, v62);
      int64x2_t v58 = (int64x2_t)vaddw_u32((uint64x2_t)v58, *(uint32x2_t *)v62.i8);
      int64x2_t v57 = (int64x2_t)vaddw_high_u32((uint64x2_t)v57, v61);
      int64x2_t v56 = (int64x2_t)vaddw_u32((uint64x2_t)v56, *(uint32x2_t *)v61.i8);
      j += 16;
    }
    while (j != 258);
    unint64_t v63 = vaddvq_s64(vaddq_s64(vaddq_s64(v56, v58), vaddq_s64(v57, v59)));
    int64x2_t v64 = 0uLL;
    uint64_t v65 = 258;
    int64x2_t v66 = 0uLL;
    int64x2_t v67 = 0uLL;
    int64x2_t v68 = 0uLL;
    do
    {
      uint16x8_t v69 = *(uint16x8_t *)((char *)__dst + v65);
      uint32x4_t v70 = vmovl_u16(*(uint16x4_t *)v69.i8);
      uint32x4_t v71 = vmovl_high_u16(v69);
      int64x2_t v68 = (int64x2_t)vaddw_high_u32((uint64x2_t)v68, v71);
      int64x2_t v67 = (int64x2_t)vaddw_u32((uint64x2_t)v67, *(uint32x2_t *)v71.i8);
      int64x2_t v66 = (int64x2_t)vaddw_high_u32((uint64x2_t)v66, v70);
      int64x2_t v64 = (int64x2_t)vaddw_u32((uint64x2_t)v64, *(uint32x2_t *)v70.i8);
      v65 += 16;
    }
    while (v65 != 770);
    int8x16_t v72 = vbicq_s8((int8x16_t)xmmword_20DAD6010, (int8x16_t)vmovl_u16(vcgt_u16((uint16x4_t)0x400040004000400, *(uint16x4_t *)&__dst[2])));
    *(int8x8_t *)v72.i8 = vorr_s8(*(int8x8_t *)v72.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL));
    if (v72.i32[0] | v72.i32[1] | (2 * (HIDWORD(__dst[0]) > 0x9C40)) | ((WORD6(__dst[2]) > 0x3Fu) << 7) | (4 * (LODWORD(__dst[1]) > 0x2710)) | ((LOWORD(__dst[3]) > 0xFFu) << 9) | ((HIWORD(__dst[2]) > 0x3Fu) << 8) | ((v54 > 0x40) << 11) | ((v51 > 0x40) << 10) | (((unint64_t)vaddvq_s64(vaddq_s64(vaddq_s64(v64, v67), vaddq_s64(v66, v68))) > 0x400) << 13) | ((v63 > 0x100) << 12) | (LODWORD(__dst[0]) != 829978210)
      || *(_DWORD *)(a1 + 7304) < HIDWORD(__dst[0]))
    {
      return 4294967293;
    }
    uint64_t v73 = 0;
    int v74 = 0;
    *(void *)a1 = v50;
    uint64_t v75 = v3;
    *(_DWORD *)(a1 + 72) = v52;
    *(_DWORD *)(a1 + 76) = v45;
    do
    {
      unsigned int v76 = *(unsigned __int16 *)&v2[2 * v73];
      if (*(_WORD *)&v2[2 * v73])
      {
        v74 += v76;
        if (v74 > 1024) {
          break;
        }
        signed int v77 = 0;
        char v78 = __clz(v76);
        char v79 = v78 - 21;
        unsigned int v80 = 0x800u >> (v78 - 21);
        signed int v81 = v80 - v76;
        char v82 = v78 - 22;
        unsigned int v83 = v76 - v80;
        do
        {
          int v84 = (v83 + v77) << v82;
          if (v77 < v81) {
            char v85 = v79;
          }
          else {
            char v85 = v82;
          }
          if (v77 < v81) {
            LOWORD(v84) = (((_WORD)v76 + (_WORD)v77) << v79) - 1024;
          }
          *(unsigned char *)uint64_t v75 = v85;
          *(unsigned char *)(v75 + 1) = v73;
          *(_WORD *)(v75 + 2) = v84;
          v75 += 4;
          ++v77;
        }
        while (v76 != v77);
      }
      ++v73;
    }
    while (v73 != 256);
    uint64_t v86 = 0;
    uint64_t v87 = v4;
    do
    {
      unsigned int v88 = *((unsigned __int16 *)&__dst[3] + v86 + 1);
      if (*((_WORD *)&__dst[3] + v86 + 1))
      {
        signed int v89 = 0;
        char v90 = __clz(v88);
        char v91 = v90 - 25;
        unsigned int v92 = 0x80u >> (v90 - 25);
        signed int v93 = v92 - v88;
        char v94 = kLSymbolVBits[v86];
        int v95 = kLSymbolVBase[v86];
        char v96 = v90 - 26;
        unsigned int v97 = v88 - v92;
        do
        {
          int v98 = (v97 + v89) << v96;
          if (v89 < v93) {
            char v99 = v91;
          }
          else {
            char v99 = v96;
          }
          if (v89 < v93) {
            LOWORD(v98) = (((_WORD)v88 + (_WORD)v89) << v91) - 64;
          }
          *(unsigned char *)uint64_t v87 = v94 + v99;
          *(unsigned char *)(v87 + 1) = v94;
          *(_WORD *)(v87 + 2) = v98;
          *(_DWORD *)(v87 + 4) = v95;
          v87 += 8;
          ++v89;
        }
        while (v88 != v89);
      }
      ++v86;
    }
    while (v86 != 20);
    uint64_t v100 = 0;
    uint64_t v101 = v155;
    do
    {
      unsigned int v102 = *((unsigned __int16 *)&__dst[5] + v100 + 5);
      if (*((_WORD *)&__dst[5] + v100 + 5))
      {
        signed int v103 = 0;
        char v104 = __clz(v102);
        char v105 = v104 - 25;
        unsigned int v106 = 0x80u >> (v104 - 25);
        signed int v107 = v106 - v102;
        char v108 = kMSymbolVBits[v100];
        int v109 = kMSymbolVBase[v100];
        char v110 = v104 - 26;
        unsigned int v111 = v102 - v106;
        do
        {
          int v112 = (v111 + v103) << v110;
          if (v103 < v107) {
            char v113 = v105;
          }
          else {
            char v113 = v110;
          }
          if (v103 < v107) {
            LOWORD(v112) = (((_WORD)v102 + (_WORD)v103) << v105) - 64;
          }
          *(unsigned char *)uint64_t v101 = v108 + v113;
          *(unsigned char *)(v101 + 1) = v108;
          *(_WORD *)(v101 + 2) = v112;
          *(_DWORD *)(v101 + 4) = v109;
          v101 += 8;
          ++v103;
        }
        while (v102 != v103);
      }
      ++v100;
    }
    while (v100 != 20);
    uint64_t v114 = 0;
    uint64_t v115 = v154;
    do
    {
      unsigned int v116 = *((unsigned __int16 *)&__dst[8] + v114 + 1);
      if (*((_WORD *)&__dst[8] + v114 + 1))
      {
        signed int v117 = 0;
        char v118 = __clz(v116);
        char v119 = v118 - 23;
        unsigned int v120 = 0x200u >> (v118 - 23);
        signed int v121 = v120 - v116;
        char v122 = kDSymbolVBits[v114];
        int v123 = kDSymbolVBase[v114];
        char v124 = v118 - 24;
        unsigned int v125 = v116 - v120;
        do
        {
          int v126 = (v125 + v117) << v124;
          if (v117 < v121) {
            char v127 = v119;
          }
          else {
            char v127 = v124;
          }
          if (v117 < v121) {
            LOWORD(v126) = (((_WORD)v116 + (_WORD)v117) << v119) - 256;
          }
          *(unsigned char *)uint64_t v115 = v122 + v127;
          *(unsigned char *)(v115 + 1) = v122;
          *(_WORD *)(v115 + 2) = v126;
          *(_DWORD *)(v115 + 4) = v123;
          v115 += 8;
          ++v117;
        }
        while (v116 != v117);
      }
      ++v114;
    }
    while (v114 != 64);
    unint64_t v158 = 0;
    uint64_t v159 = 0;
    unint64_t v128 = *(void *)(a1 + 8);
    unsigned int v129 = HIDWORD(__dst[1]);
    unint64_t v130 = *(void *)a1 + DWORD1(__dst[1]);
    *(void *)a1 = v130;
    if (v129)
    {
      if (v130 < v128 + 8) {
        return 4294967293;
      }
      uint64_t v157 = (void *)(v130 - 8);
      unint64_t v131 = *(void *)(v130 - 8);
      unint64_t v158 = v131;
      char v132 = v129 + 64;
      LODWORD(v159) = v129 + 64;
      if (v129 < 0xFFFFFFF8) {
        return 4294967293;
      }
    }
    else
    {
      if (v130 < v128 + 7) {
        return 4294967293;
      }
      uint64_t v157 = (void *)(v130 - 7);
      int v133 = *(_DWORD *)(v130 - 7);
      *(_DWORD *)((char *)&v158 + 3) = *(_DWORD *)(v130 - 4);
      char v132 = 56;
      LODWORD(v158) = v133;
      unint64_t v131 = v158 & 0xFFFFFFFFFFFFFFLL;
      v158 &= 0xFFFFFFFFFFFFFFuLL;
      LODWORD(v159) = 56;
    }
    if (v131 >> v132
      || lzfse_decode_literals(v156, v3, HIDWORD(__dst[0]), (uint64_t)&v158, &v157, v128, *(double *)&__dst[2]) == -3)
    {
      return 4294967293;
    }
    *(void *)(a1 + 80) = v156;
    unsigned int v134 = *(const void **)a1;
    uint64_t v135 = *(void *)a1 + DWORD2(__dst[1]);
    if (DWORD2(__dst[2]))
    {
      if (DWORD2(__dst[1]) < 8) {
        return 4294967293;
      }
      unint64_t v138 = *(void *)(v135 - 8);
      unint64_t v136 = v135 - 8;
      unint64_t v137 = v138;
      int v139 = DWORD2(__dst[2]) + 64;
    }
    else
    {
      if (DWORD2(__dst[1]) < 7) {
        return 4294967293;
      }
      unsigned int v140 = *(_DWORD *)(v135 - 7);
      unint64_t v136 = v135 - 7;
      unint64_t v137 = v140 | ((unint64_t)(*(unsigned __int16 *)(v136 + 4) | (*(unsigned __int8 *)(v136 + 6) << 16)) << 32);
      int v139 = 56;
    }
    uint64_t result = 4294967293;
    if ((v139 & 0xFFFFFFF8) != 0x38) {
      return result;
    }
    if (v137 >> v139) {
      return result;
    }
    *(_WORD *)(a1 + 124) = WORD6(__dst[2]);
    *(_DWORD *)(a1 + 126) = *(_DWORD *)((char *)&__dst[2] + 14);
    if (v136 < (unint64_t)v134) {
      return result;
    }
    *(_DWORD *)(a1 + 116) = 0;
    *(_DWORD *)(a1 + 120) = v136 - v134;
    *(void *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 96) = -1;
    *(void *)(a1 + 104) = v137;
    *(_DWORD *)(a1 + 112) = v139;
    int v36 = v153;
LABEL_130:
    *(_DWORD *)(a1 + 52) = v36;
  }
  switch(v35)
  {
    case 762869346:
      if ((unint64_t)(v32 + 2) > v34) {
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 68) = *v33;
      *(void *)a1 = v32 + 2;
      int v36 = 762869346;
      goto LABEL_130;
    case 829978210:
      goto LABEL_51;
    case 611874402:
      uint64_t result = 0;
      *(void *)a1 = v33;
      *(_DWORD *)(a1 + 48) = 1;
      break;
  }
  return result;
}

uint64_t lzvnDecode(uint64_t a1)
{
  compression_algorithm v1 = *(char **)a1;
  unint64_t v2 = *(void *)(a1 + 8) - *(void *)a1;
  uint64_t v3 = *(_DWORD **)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 32) - (void)v3;
  if (*(void *)(a1 + 8) == *(void *)a1 || *(void *)(a1 + 32) == (void)v3) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v10 = *(void *)(a1 + 48);
  unint64_t v9 = *(void *)(a1 + 56);
  unint64_t v8 = a1 + 48;
  if (!v10)
  {
    if (!v9) {
      return lzvnDecode_opc_tbl[*v1](a1, v8);
    }
    unint64_t v11 = *(void *)(a1 + 64);
    *(void *)unint64_t v8 = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    goto LABEL_19;
  }
  unint64_t v11 = *(void *)(a1 + 64);
  *(void *)unint64_t v8 = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  if (v9)
  {
    if (v4 < 4 || v2 < 4)
    {
      unint64_t v13 = v10 - v4;
      if (v10 > v4)
      {
        if (v4)
        {
          unint64_t v21 = v1;
          long long v22 = v3;
          unint64_t v23 = v4;
          do
          {
            char v24 = *v21++;
            *v22++ = v24;
            --v23;
          }
          while (v23);
        }
        *(void *)a1 = &v1[v4];
        *(void *)(a1 + 16) = (char *)v3 + v4;
        *(void *)(a1 + 48) = v13;
        *(void *)(a1 + 56) = v9;
        goto LABEL_40;
      }
      unint64_t v14 = v1;
      double v15 = v3;
      unint64_t v16 = v10;
      do
      {
        char v17 = *v14++;
        *v15++ = v17;
        --v16;
      }
      while (v16);
    }
    else
    {
      *uint64_t v3 = *(_DWORD *)v1;
    }
    uint64_t v3 = (_DWORD *)((char *)v3 + v10);
    if (v11 - 1 >= (unint64_t)v3 - *(void *)(a1 + 24)) {
      return 4294967293;
    }
    v4 -= v10;
    v1 += v10;
LABEL_19:
    if (v4 < v9 + 7 || v11 < 8)
    {
      unint64_t v18 = v9 - v4;
      if (v9 > v4)
      {
        if (v4)
        {
          unint64_t v25 = v3;
          unint64_t v26 = v4;
          do
          {
            *unint64_t v25 = v25[-v11];
            ++v25;
            --v26;
          }
          while (v26);
        }
        *(void *)a1 = v1;
        *(void *)(a1 + 16) = (char *)v3 + v4;
        *(void *)(a1 + 48) = 0;
        *(void *)(a1 + 56) = v18;
        goto LABEL_40;
      }
      BOOL v19 = v3;
      unint64_t v20 = v9;
      do
      {
        unsigned char *v19 = v19[-v11];
        ++v19;
        --v20;
      }
      while (v20);
    }
    else
    {
      for (unint64_t i = 0; i < v9; i += 8)
        *(void *)&v3[i / 4] = *(void *)((char *)&v3[i / 4] - v11);
    }
    return ((uint64_t (*)(void))lzvnDecode_opc_tbl[*v1])();
  }
  if (v2 <= v10) {
    return 0xFFFFFFFFLL;
  }
  if (v4 >= v10 + 7 && v2 >= v10 + 7)
  {
    for (unint64_t j = 0; j < v10; j += 8)
      *(void *)&v3[j / 4] = *(void *)&v1[j];
    goto LABEL_52;
  }
  unint64_t v28 = v10 - v4;
  if (v10 > v4)
  {
    if (v4)
    {
      unint64_t v34 = v1;
      int v35 = v3;
      unint64_t v36 = v4;
      do
      {
        char v37 = *v34++;
        *v35++ = v37;
        --v36;
      }
      while (v36);
    }
    *(void *)a1 = &v1[v4];
    *(void *)(a1 + 16) = (char *)v3 + v4;
    *(void *)(a1 + 48) = v28;
    *(void *)(a1 + 56) = 0;
LABEL_40:
    uint64_t v6 = 4294967294;
    *(void *)(a1 + 64) = v11;
    return v6;
  }
  int v29 = v1;
  int v30 = v3;
  unint64_t v31 = v10;
  do
  {
    unsigned int v32 = *v29++;
    unint64_t v8 = v32;
    *v30++ = v32;
    --v31;
  }
  while (v31);
LABEL_52:
  v1 += v10;
  return lzvnDecode_opc_tbl[*v1](a1, v8);
}

uint64_t lz4_decode_buffer(char *__dst, unsigned char *__n, unsigned __int8 *a3, unint64_t a4)
{
  unint64_t v18 = a3;
  BOOL v19 = __dst;
  int v5 = __dst;
  if (!__n) {
    return v5 - __dst;
  }
  int32x4_t v7 = __n;
  int v5 = __dst;
  while (1)
  {
    if (a4 < 4) {
      return 0;
    }
    int v8 = *(_DWORD *)a3;
    if (*(_DWORD *)a3 == 758412898) {
      break;
    }
    if (v8 != 825521762)
    {
      if (v8 == 607417954) {
        return v5 - __dst;
      }
      else {
        return 0;
      }
    }
    unint64_t v9 = a4 - 12;
    if (a4 < 0xC) {
      return 0;
    }
    uint64_t v11 = *((unsigned int *)a3 + 1);
    unint64_t v10 = (unsigned __int8 *)*((unsigned int *)a3 + 2);
    unint64_t v12 = a3 + 12;
    unint64_t v18 = a3 + 12;
    a4 = v9 - (void)v10;
    if (v9 < (unint64_t)v10
      || (unint64_t)v7 >= 0x81
      && v10 >= 0x81
      && lz4_decode_asm((int8x16_t **)&v19, (unint64_t)__dst, (unint64_t)&v7[(void)v5 - 128], &v18, (unint64_t)&v10[(void)v12 - 128]))
    {
      return 0;
    }
    if (lz4_decode((void **)&v19, (unint64_t)__dst, (unint64_t)&v7[(void)v5], &v18, (unint64_t)&v10[(void)v12]))return 0; {
    unint64_t v13 = v19;
    }
    size_t v14 = v19 - v5;
    if ((unsigned char *)(v19 - v5) == v7) {
      return v13 - __dst;
    }
    uint64_t result = 0;
    if (v14 != v11) {
      return result;
    }
    a3 = v18;
    if ((unsigned __int8 *)(v18 - v12) != v10) {
      return result;
    }
    int v5 = v19;
LABEL_20:
    v7 -= v14;
    if (!v7) {
      return v5 - __dst;
    }
  }
  unint64_t v16 = a4 - 8;
  if (a4 < 8) {
    return 0;
  }
  size_t v14 = *((unsigned int *)a3 + 1);
  char v17 = a3 + 8;
  unint64_t v18 = a3 + 8;
  a4 = v16 - v14;
  if (v16 < v14) {
    return 0;
  }
  if ((unint64_t)v7 > v14)
  {
    memcpy(v5, v17, v14);
    int v5 = &v19[v14];
    a3 = &v18[v14];
    v18 += v14;
    v19 += v14;
    goto LABEL_20;
  }
  memcpy(v5, v17, (size_t)v7);
  unint64_t v13 = &v7[(void)v19];
  return v13 - __dst;
}

uint64_t lz4_decode_asm(int8x16_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  int v5 = *a4;
  uint64_t v6 = *a1;
  while (1)
  {
    int32x4_t v7 = v6;
    int v8 = v5;
    if ((unint64_t)v5 >= a5 || (unint64_t)v6 >= a3) {
      break;
    }
    unsigned int v10 = *v5;
    unint64_t v9 = v5 + 1;
    unint64_t v11 = (unint64_t)v10 >> 4;
    unint64_t v12 = (v10 & 0xF) + 4;
    if (v11 > 0xE)
    {
      while ((unint64_t)v9 < a5)
      {
        unsigned int v13 = *(unsigned __int8 *)v9;
        unint64_t v9 = (_OWORD *)((char *)v9 + 1);
        v11 += v13;
        if (v13 != 255)
        {
          size_t v14 = (int8x16_t *)v9;
          double v15 = v6;
          unint64_t v16 = (unsigned __int16 *)((char *)v9 + v11);
          char v17 = (int8x16_t *)((char *)v6 + v11);
          if ((unint64_t)v16 < a5 && (unint64_t)v17 < a3)
          {
            int8x16_t v19 = *v14;
            int8x16_t v20 = v14[1];
            unint64_t v18 = v14 + 2;
            int8x16_t *v15 = v19;
            v15[1] = v20;
            unint64_t v21 = v15 + 2;
            do
            {
              int8x16_t v22 = *v18;
              int8x16_t v23 = v18[1];
              v18 += 2;
              *unint64_t v21 = v22;
              v21[1] = v23;
              v21 += 2;
            }
            while (v17 > v21);
            goto LABEL_13;
          }
          goto LABEL_36;
        }
      }
      break;
    }
    *uint64_t v6 = *(int8x16_t *)v9;
    unint64_t v16 = (unsigned __int16 *)((char *)v9 + v11);
    char v17 = (int8x16_t *)((char *)v6 + v11);
LABEL_13:
    if ((unint64_t)v16 >= a5) {
      break;
    }
    unsigned int v25 = *v16;
    int v5 = (unsigned __int8 *)(v16 + 1);
    unint64_t v24 = v25;
    if (!v25 || (unint64_t v26 = (int8x16_t *)((char *)v17 - v24), (unint64_t)v17 - v24 < a2))
    {
      uint64_t v47 = -1;
      goto LABEL_37;
    }
    unint64_t v27 = v17;
    uint64_t v6 = (int8x16_t *)((char *)v17 + v12);
    if (v12 == 19)
    {
      while ((unint64_t)v5 < a5)
      {
        unsigned int v28 = *v5++;
        uint64_t v6 = (int8x16_t *)((char *)v6 + v28);
        if (v28 != 255)
        {
          if ((unint64_t)v6 >= a3) {
            goto LABEL_36;
          }
          goto LABEL_24;
        }
      }
      break;
    }
    if (v12 > 0x10)
    {
LABEL_24:
      if (v24 > 0x1F)
      {
        int8x16_t v36 = *v26;
        int v35 = v26 + 1;
        *unint64_t v27 = v36;
        char v37 = v27 + 1;
        do
        {
          int8x16_t v38 = *v35;
          int8x16_t v39 = v35[1];
          v35 += 2;
          *char v37 = v38;
          v37[1] = v39;
          v37 += 2;
        }
        while (v6 > v37);
      }
      else if (v24 > 0xF)
      {
        int8x16_t v41 = *v26;
        uint64_t v40 = v26 + 1;
        *unint64_t v27 = v41;
        unint64_t v42 = v27 + 1;
        do
        {
          int8x16_t v44 = *v40;
          unsigned int v43 = v40 + 1;
          *unint64_t v42 = v44;
          uint64_t v45 = v42 + 1;
          int8x16_t v46 = *v43;
          uint64_t v40 = v43 + 1;
          *uint64_t v45 = v46;
          unint64_t v42 = v45 + 1;
        }
        while (v6 > v42);
      }
      else
      {
        int v29 = (int8x16_t *)&qword_20DA656C0[4 * v24];
        int8x16_t v30 = vqtbl1q_s8(*v26, *v29);
        int8x16_t v31 = vqtbl1q_s8(*v26, v29[1]);
        uint64_t v32 = *((unsigned __int8 *)qword_20DA658C0 + v24);
        *unint64_t v27 = v30;
        v27[1] = v31;
        int v33 = (int8x16_t *)((char *)v27 + v32);
        do
        {
          int8x16_t *v33 = v30;
          v33[1] = v31;
          unint64_t v34 = (int8x16_t *)((char *)v33 + v32);
          *unint64_t v34 = v30;
          v34[1] = v31;
          int v33 = (int8x16_t *)((char *)v34 + v32);
        }
        while (v6 > v33);
      }
    }
    else if (v24 <= 0xF)
    {
      *unint64_t v27 = vqtbl1q_s8(*v26, *(int8x16_t *)&qword_20DA656C0[4 * v24]);
    }
    else
    {
      *unint64_t v27 = *v26;
    }
  }
LABEL_36:
  uint64_t v47 = 0;
LABEL_37:
  *a4 = v8;
  *a1 = v7;
  return v47;
}

uint64_t lz4_decode(void **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  int32x4_t v7 = (char *)*a1;
  int v8 = *a4;
  if ((unint64_t)*a1 < a3 && (unint64_t)v8 < a5)
  {
    while (1)
    {
      *a4 = v8;
      *a1 = v7;
      unsigned int v15 = *v8++;
      char v14 = v15;
      unsigned int v16 = v15 >> 4;
      if (v15 >> 4 == 15)
      {
        while ((unint64_t)v8 < a5)
        {
          int v25 = *v8++;
          v16 += v25;
          if (v25 != 255) {
            goto LABEL_8;
          }
        }
        return 1;
      }
LABEL_8:
      if (a5 - (unint64_t)v8 < v16) {
        return 1;
      }
      uint64_t v17 = v16;
      if (a3 - (unint64_t)v7 < v16)
      {
        memcpy(v7, v8, (a3 - v7));
        v7 += (a3 - v7);
        goto LABEL_6;
      }
      memcpy(v7, v8, v16);
      v8 += v17;
      unint64_t v18 = &v7[v17];
      if ((unint64_t)v8 >= a5)
      {
        v7 += v17;
        goto LABEL_6;
      }
      if (a5 - (unint64_t)v8 < 2) {
        return 1;
      }
      unsigned int v20 = *(unsigned __int16 *)v8;
      v8 += 2;
      uint64_t v19 = v20;
      if (!v20 || (unint64_t)&v18[-v19] < a2) {
        return 1;
      }
      unsigned int v21 = (v14 & 0xF) + 4;
      if ((v14 & 0xF) == 0xF)
      {
        while ((unint64_t)v8 < a5)
        {
          int v26 = *v8++;
          v21 += v26;
          if (v26 != 255) {
            goto LABEL_15;
          }
        }
        return 1;
      }
LABEL_15:
      if (a3 - (unint64_t)v18 < v21) {
        break;
      }
      if (v21)
      {
        uint64_t v22 = -v19;
        int8x16_t v23 = &v7[v17];
        uint64_t v24 = v21;
        do
        {
          *int8x16_t v23 = v23[v22];
          ++v23;
          --v24;
        }
        while (v24);
      }
      int32x4_t v7 = &v18[v21];
      if ((unint64_t)v8 >= a5) {
        goto LABEL_6;
      }
    }
    if (a3 != v18)
    {
      uint64_t v27 = -v19;
      unsigned int v28 = &v7[v17];
      uint64_t v29 = (a3 - v18);
      do
      {
        *unsigned int v28 = v28[v27];
        ++v28;
        --v29;
      }
      while (v29);
    }
    int32x4_t v7 = &v18[(a3 - v18)];
  }
LABEL_6:
  uint64_t result = 0;
  *a1 = v7;
  *a4 = v8;
  return result;
}

uint64_t lzfse_decode_lmd(uint64_t a1)
{
  compression_algorithm v1 = *(void **)(a1 + 24);
  unint64_t v2 = (uint64_t *)(*(void *)a1 + *(int *)(a1 + 120));
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t v4 = *(unsigned int *)(a1 + 112);
  uint64_t v5 = *(unsigned int *)(a1 + 72);
  unint64_t v6 = *(unsigned int *)(a1 + 88);
  unint64_t v7 = *(unsigned int *)(a1 + 92);
  unint64_t v8 = *(unsigned int *)(a1 + 96);
  unint64_t v9 = *(unsigned __int16 *)(a1 + 124);
  unint64_t v10 = *(unsigned __int16 *)(a1 + 126);
  unint64_t v11 = *(unsigned __int16 *)(a1 + 128);
  uint64_t v12 = *(void *)(a1 + 40) - (void)v1 - 32;
  unsigned int v13 = *(char **)(a1 + 80);
  if (v6 | v7) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    while (1)
    {
      unint64_t v2 = (uint64_t *)((char *)v2 - ((unint64_t)(63 - v4) >> 3));
      if ((unint64_t)v2 < *(void *)(a1 + 8)) {
        return -3;
      }
      uint64_t v3 = *v2;
      char v14 = (unsigned __int8 *)(a1 + 136 + 8 * v9);
      uint64_t v15 = *v14;
      uint64_t v16 = v4 + ((63 - v4) & 0xFFFFFFFFFFFFFFF8) - v15;
      unint64_t v17 = (unint64_t)*v2 >> v16;
      unint64_t v18 = v17 & ~(-1 << v15);
      LOBYTE(v15) = v14[1];
      unint64_t v9 = (v18 >> v15) + *((unsigned __int16 *)v14 + 1);
      unint64_t v6 = (v17 & ~(-1 << v15)) + *((unsigned int *)v14 + 1);
      uint64_t v19 = (unsigned __int8 *)(a1 + 648 + 8 * v10);
      uint64_t v20 = *v19;
      uint64_t v21 = v16 - v20;
      unint64_t v22 = (unint64_t)*v2 >> v21;
      unint64_t v23 = v22 & ~(-1 << v20);
      LOBYTE(v20) = v19[1];
      unint64_t v10 = (v23 >> v20) + *((unsigned __int16 *)v19 + 1);
      unint64_t v7 = (v22 & ~(-1 << v20)) + *((unsigned int *)v19 + 1);
      uint64_t v24 = (unsigned __int8 *)(a1 + 1160 + 8 * v11);
      uint64_t v25 = *v24;
      uint64_t v4 = v21 - v25;
      unint64_t v26 = (unint64_t)*v2 >> v4;
      unint64_t v27 = v26 & ~(-1 << v25);
      LOBYTE(v25) = v24[1];
      unint64_t v11 = (v27 >> v25) + *((unsigned __int16 *)v24 + 1);
      uint64_t v28 = (v26 & ~(-1 << v25)) + *((unsigned int *)v24 + 1);
      if (v28) {
        unint64_t v8 = v28;
      }
      --v5;
LABEL_7:
      if (v8 > (unint64_t)v1 + v6 - *(void *)(a1 + 32)
        || a1 + *(unsigned int *)(a1 + 7304) + 7308 < (uint64_t)&v13[v6])
      {
        return -3;
      }
      BOOL v29 = v12 < (uint64_t)(v6 + v7);
      v12 -= v6 + v7;
      if (v29)
      {
        uint64_t v40 = v12 + v6 + v7 + 32;
        if (v6)
        {
          do
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              goto LABEL_30;
            }
            char v42 = *v13++;
            *(unsigned char *)compression_algorithm v1 = v42;
            compression_algorithm v1 = (void *)((char *)v1 + 1);
          }
          while (--v6);
        }
        if (v7)
        {
          unsigned int v43 = (char *)v1 - v8;
          while (1)
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              break;
            }
            char v44 = *v43++;
            *(unsigned char *)compression_algorithm v1 = v44;
            compression_algorithm v1 = (void *)((char *)v1 + 1);
            if (!--v7) {
              goto LABEL_28;
            }
          }
LABEL_30:
          *(void *)(a1 + 24) = v1;
          *(void *)(a1 + 120) = (char *)v2 - *(void *)a1;
          *(void *)(a1 + 104) = v3;
          *(_DWORD *)(a1 + 112) = v4;
          *(_DWORD *)(a1 + 72) = v5;
          *(_DWORD *)(a1 + 88) = v6;
          *(_DWORD *)(a1 + 92) = v7;
          *(_DWORD *)(a1 + 96) = v8;
          *(_WORD *)(a1 + 124) = v9;
          *(_WORD *)(a1 + 126) = v10;
          *(_WORD *)(a1 + 128) = v11;
          *(void *)(a1 + 80) = v13;
          return -2;
        }
LABEL_28:
        uint64_t v12 = v40 - 32;
        if (!v5) {
          goto LABEL_29;
        }
      }
      else
      {
        do
        {
          uint64_t v30 = *(void *)v13;
          uint64_t v31 = *((void *)v13 + 1);
          v13 += 16;
          *compression_algorithm v1 = v30;
          v1[1] = v31;
          v1 += 2;
          BOOL v29 = v6 > 0x10;
          v6 -= 16;
        }
        while (v29);
        uint64_t v32 = (int8x16_t *)((char *)v1 + v6);
        v13 += v6;
        int v33 = (int8x16_t *)((char *)v32 - v8);
        if (v8 < 0x10)
        {
          int8x16_t v36 = (int8x16_t *)((char *)&unk_20DAD5980 + 32 * v8);
          unint64_t v37 = byte_20DAD5B80[v8];
          int8x16_t v38 = vqtbl1q_s8(*v33, *v36);
          int8x16_t v39 = vqtbl1q_s8(*v33, v36[1]);
          do
          {
            *uint64_t v32 = v38;
            v32[1] = v39;
            uint64_t v32 = (int8x16_t *)((char *)v32 + v37);
            BOOL v29 = v7 > v37;
            v7 -= v37;
          }
          while (v29);
          compression_algorithm v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }
        else
        {
          do
          {
            uint64_t v34 = v33->i64[0];
            uint64_t v35 = v33->i64[1];
            ++v33;
            v32->i64[0] = v34;
            v32->i64[1] = v35;
            ++v32;
            BOOL v29 = v7 > 0x10;
            v7 -= 16;
          }
          while (v29);
          compression_algorithm v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }
      }
    }
  }
  else
  {
LABEL_29:
    *(void *)(a1 + 24) = v1;
    return 0;
  }
}

uint64_t lzfse_decode_literals(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, void **a5, unint64_t a6, double a7)
{
  uint64_t v7 = LOWORD(a7);
  uint64_t v8 = WORD1(a7);
  uint64_t v9 = WORD2(a7);
  uint64_t v10 = HIWORD(a7);
  unint64_t v12 = *(void *)a4;
  int v13 = *(_DWORD *)(a4 + 8);
  char v14 = *a5;
  while (1)
  {
    unsigned int v15 = *(_DWORD *)(a2 + 4 * v7);
    unsigned int v16 = *(_DWORD *)(a2 + 4 * v8);
    unsigned int v17 = *(_DWORD *)(a2 + 4 * v9);
    unsigned int v18 = *(_DWORD *)(a2 + 4 * v10);
    *a1++ = (v16 & 0xFF00)
          + ((unsigned __int16)(v15 & 0xFF00) >> 8)
          + (((v18 & 0xFF00) + ((unsigned __int16)(v17 & 0xFF00) >> 8)) << 16);
    unint64_t v19 = (63 - v13) & 0xFFFFFFF8;
    if (((63 - v13) & 0xFFFFFFF8) != 0) {
      break;
    }
LABEL_5:
    uint64_t v20 = v13 - v15;
    uint64_t v21 = v20 - v16;
    unint64_t v22 = v12 >> (v13 - v15);
    unint64_t v23 = v12 & qword_20DA65E60[v20];
    uint64_t v24 = v21 - v17;
    uint64_t v7 = v22 + HIWORD(v15);
    unint64_t v25 = v23 >> (v20 - v16);
    unint64_t v26 = v23 & qword_20DA65E60[v21];
    int v13 = v24 - v18;
    uint64_t v8 = v25 + HIWORD(v16);
    unint64_t v27 = v26 >> (v21 - v17);
    unint64_t v28 = v26 & qword_20DA65E60[v24];
    uint64_t v9 = v27 + HIWORD(v17);
    unint64_t v29 = v28 >> (v24 - v18);
    unint64_t v12 = v28 & qword_20DA65E60[v13];
    uint64_t v10 = v29 + HIWORD(v18);
    BOOL v30 = a3 <= 4;
    a3 -= 4;
    if (v30)
    {
      *(void *)a4 = v12;
      *(_DWORD *)(a4 + 8) = v13;
      *a5 = v14;
      return 0;
    }
  }
  char v14 = (void *)((char *)v14 - (v19 >> 3));
  if ((unint64_t)v14 >= a6)
  {
    v13 += v19;
    unint64_t v12 = (v12 << v19) | *v14 & qword_20DA65E60[v19];
    goto LABEL_5;
  }
  return -3;
}

uint64_t lzvn_decode_scratch_size()
{
  return 0;
}

uint64_t lzvn_decode_buffer(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a3 <= a3 + a4 - 8) {
      __asm { BR              X17 }
    }
    __asm { BTI             j }
    return 0;
  }
  else
  {
    __asm { BTI             j }
    return 0;
  }
}

uint64_t brotli_stream_end(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = v2[2];
    if (*(_DWORD *)v2) {
      BrotliDecoderDestroyInstance(v3);
    }
    else {
      BrotliEncoderDestroyInstance(v3);
    }
    free(v2);
  }
  *(void *)(a1 + 32) = 0;
  return 0;
}

uint64_t BrotliDecoderDestroyInstance(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(result + 48);
    uint64_t v2 = *(void *)(result + 56);
    BrotliDecoderStateCleanup(result);
    return v3(v2, v1);
  }
  return result;
}

uint64_t BrotliDecoderStateCleanup(uint64_t a1)
{
  BrotliDecoderStateCleanupAfterMetablock(a1);
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  uint64_t result = (*(uint64_t (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 240));
  *(void *)(a1 + 240) = 0;
  return result;
}

uint64_t BrotliDecoderStateCleanupAfterMetablock(uint64_t a1)
{
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 688));
  *(void *)(a1 + 688) = 0;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 680));
  *(void *)(a1 + 680) = 0;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 336));
  *(void *)(a1 + 336) = 0;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 168));
  *(void *)(a1 + 168) = 0;
  (*(void (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 192));
  *(void *)(a1 + 192) = 0;
  uint64_t result = (*(uint64_t (**)(void, void))(a1 + 48))(*(void *)(a1 + 56), *(void *)(a1 + 216));
  *(void *)(a1 + 216) = 0;
  return result;
}

void BrotliDefaultFreeFunc(int a1, void *a2)
{
}

uint64_t zlib_stream_init(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  uint64_t v4 = *(_DWORD **)(a1 + 32);
  if (a2)
  {
    uint64_t v5 = realloc_stream_state(v4, a2, 517, 0x70148u, 0x30001u);
    *(void *)(a1 + 32) = v5;
    if (v5) {
      return 0;
    }
  }
  else
  {
    uint64_t v7 = realloc_stream_state(v4, 0, 517, 0x88u, 0);
    *(void *)(a1 + 32) = v7;
    if (v7)
    {
      if (!deflateInit2_((z_streamp)(v7 + 6), 5, 8, -15, 8, 0, "1.2.5", 112)) {
        return 0;
      }
      free(*(void **)(a1 + 32));
      *(void *)(a1 + 32) = 0;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t lzfseStreamDecodeInit(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    uint64_t v5 = *(_DWORD **)(a1 + 32);
  }
  else
  {
    uint64_t v5 = 0;
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  unint64_t v6 = realloc_stream_state(v5, 1, a2, 0x18B940u, 0x180000u);
  *(void *)(a1 + 32) = v6;
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  uint64_t result = 0;
  if (a2 == 2193) {
    int v9 = 15000;
  }
  else {
    int v9 = 40000;
  }
  v7[1838] = v9;
  *((void *)v7 + 16) -= v7;
  *((void *)v7 + 10) = 833856;
  *((void *)v7 + 11) = 1620288;
  *((void *)v7 + 6) = 47424;
  *((void *)v7 + 7) = 47424;
  *((void *)v7 + 8) = 47424;
  *((void *)v7 + 9) = 833856;
  *((void *)v7 + 2) = 47424;
  *((void *)v7 + 3) = 833856;
  *((void *)v7 + 4) = 833856;
  return result;
}

_DWORD *realloc_stream_state(_DWORD *a1, int a2, int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v6 = a4;
  int v9 = a1;
  if (a1 && a1[3] >= a4)
  {
    unsigned int v6 = a1[3];
  }
  else
  {
    free(a1);
    int v9 = malloc(v6);
    if (!v9) {
      return v9;
    }
  }
  if (v6 > a5) {
    bzero(v9, v6 - a5);
  }
  _DWORD *v9 = a2;
  v9[1] = a3;
  v9[2] = -1412628475;
  v9[3] = v6;
  return v9;
}

int deflateReset(z_streamp strm)
{
  if (!strm) {
    return -2;
  }
  state = strm->state;
  if (!state || !strm->zalloc || !strm->zfree) {
    return -2;
  }
  strm->total_in = 0;
  strm->total_out = 0;
  strm->msg = 0;
  strm->data_type = 2;
  *((_DWORD *)state + 10) = 0;
  *((void *)state + 4) = *((void *)state + 2);
  int v3 = *((_DWORD *)state + 11);
  if (v3 < 0)
  {
    int v3 = -v3;
    *((_DWORD *)state + 11) = v3;
  }
  if (v3) {
    int v4 = 42;
  }
  else {
    int v4 = 113;
  }
  *((_DWORD *)state + 2) = v4;
  if (v3 == 2) {
    uLong v5 = crc32(0, 0, 0);
  }
  else {
    uLong v5 = adler32(0, 0, 0);
  }
  strm->adler = v5;
  *((_DWORD *)state + 16) = 0;
  _tr_init((uint64_t)state);
  *((void *)state + 11) = 2 * *((unsigned int *)state + 17);
  uint64_t v7 = (char *)*((void *)state + 13);
  size_t v8 = 2 * (*((_DWORD *)state + 29) - 1);
  *(_WORD *)&v7[v8] = 0;
  bzero(v7, v8);
  int result = 0;
  int v9 = (unsigned __int16 *)&configuration_table[2 * *((int *)state + 45)];
  int v10 = v9[2];
  *((_DWORD *)state + 47) = *v9;
  *((_DWORD *)state + 48) = v10;
  int v11 = v9[1];
  *((_DWORD *)state + 43) = v9[3];
  *((_DWORD *)state + 44) = v11;
  *((void *)state + 17) = 0;
  *(void *)((char *)state + 164) = 0x200000000;
  *((_DWORD *)state + 36) = 2;
  *((void *)state + 19) = 0;
  *((_DWORD *)state + 28) = 0;
  return result;
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  if (!version) {
    return -6;
  }
  int result = -6;
  if (stream_size == 112 && *version == 49)
  {
    if (!strm) {
      return -2;
    }
    strm->msg = 0;
    zalloc = (uint64_t (*)(voidpf, uint64_t, uint64_t))strm->zalloc;
    if (!zalloc)
    {
      zalloc = (uint64_t (*)(voidpf, uint64_t, uint64_t))zcalloc;
      strm->zalloc = (alloc_func)zcalloc;
      strm->opaque = 0;
    }
    if (!strm->zfree) {
      strm->zfree = (free_func)zcfree;
    }
    unsigned int v13 = level == -1 ? 6 : level;
    int v14 = windowBits - 16;
    if (windowBits > 0xF)
    {
      int v15 = 2;
    }
    else
    {
      int v14 = windowBits;
      int v15 = 1;
    }
    unsigned int v16 = windowBits < 0 ? -windowBits : v14;
    int v17 = windowBits < 0 ? 0 : v15;
    int result = -2;
    if (strategy <= 4
      && v13 <= 9
      && method == 8
      && (memLevel - 10) >= 0xFFFFFFF7
      && v16 >= 8
      && v16 <= 0xF)
    {
      uint64_t v18 = zalloc(strm->opaque, 1, 5936);
      if (v18)
      {
        uint64_t v19 = v18;
        if (v16 == 8) {
          int v20 = 9;
        }
        else {
          int v20 = v16;
        }
        strm->state = (internal_state *)v18;
        *(void *)uint64_t v18 = strm;
        *(_DWORD *)(v18 + 44) = v17;
        *(void *)(v18 + 48) = 0;
        *(_DWORD *)(v18 + 68) = 1 << v20;
        *(_DWORD *)(v18 + 72) = v20;
        *(_DWORD *)(v18 + 76) = (1 << v20) - 1;
        *(_DWORD *)(v18 + 116) = 128 << memLevel;
        *(_DWORD *)(v18 + 120) = memLevel + 7;
        *(_DWORD *)(v18 + 124) = (128 << memLevel) - 1;
        *(_DWORD *)(v18 + 128) = (memLevel + 9) / 3u;
        *(void *)(v18 + 80) = ((uint64_t (*)(voidpf))strm->zalloc)(strm->opaque);
        *(void *)(v19 + 96) = ((uint64_t (*)(voidpf, void, uint64_t))strm->zalloc)(strm->opaque, *(unsigned int *)(v19 + 68), 2);
        *(void *)(v19 + 104) = ((uint64_t (*)(voidpf, void, uint64_t))strm->zalloc)(strm->opaque, *(unsigned int *)(v19 + 116), 2);
        *(void *)(v19 + 5928) = 0;
        *(_DWORD *)(v19 + 5880) = 64 << memLevel;
        uint64_t v21 = ((uint64_t (*)(voidpf))strm->zalloc)(strm->opaque);
        uint64_t v22 = *(unsigned int *)(v19 + 5880);
        *(void *)(v19 + 16) = v21;
        *(void *)(v19 + 24) = 4 * v22;
        if (*(void *)(v19 + 80) && *(void *)(v19 + 96) && *(void *)(v19 + 104) && v21)
        {
          *(void *)(v19 + 5888) = v21 + (v22 & 0xFFFFFFFE);
          *(void *)(v19 + 5872) = v21 + 3 * v22;
          *(_DWORD *)(v19 + 180) = v13;
          *(_DWORD *)(v19 + 184) = strategy;
          *(unsigned char *)(v19 + 60) = 8;
          return deflateReset(strm);
        }
        *(_DWORD *)(v19 + 8) = 666;
        strm->msg = "insufficient memory";
        deflateEnd(strm);
      }
      return -4;
    }
  }
  return result;
}

void zcalloc(uint64_t a1, int a2, int a3)
{
  size_t v3 = (a3 * a2);
  int v4 = malloc(v3);

  bzero(v4, v3);
}

uLong adler32(uLong adler, const Bytef *buf, uInt len)
{
  unint64_t v5 = WORD1(adler);
  adler = (unsigned __int16)adler;
  if (len == 1)
  {
    unint64_t v6 = (unsigned __int16)adler + (unint64_t)*buf;
    if (v6 > 0xFFF0) {
      v6 -= 65521;
    }
    if (v6 + v5 <= 0xFFF0) {
      uint64_t v7 = (v6 + v5) << 16;
    }
    else {
      uint64_t v7 = ((v6 + v5) << 16) - 4293984256u;
    }
    return v7 | v6;
  }
  else if (buf)
  {
    if ((int)len >= 16)
    {
      if ((buf & 0xF) != 0)
      {
        int v11 = buf + 1;
        unint64_t v12 = buf;
        do
        {
          --len;
          unsigned int v13 = *v12++;
          uLong v14 = adler + v13;
          if (v14 <= 0xFFF0) {
            adler = v14;
          }
          else {
            adler = v14 - 65521;
          }
          unint64_t v5 = (v14 + v5) % 0xFFF1;
        }
        while ((v11++ & 0xF) != 0);
        buf = &buf[-(buf & 0xF) + 16];
      }
      return adler32_vec(adler, v5, (uint8x16_t *)buf, len);
    }
    else
    {
      for (; len; --len)
      {
        unsigned int v9 = *buf++;
        adler += v9;
        v5 += adler;
      }
      uLong v10 = adler - 65521;
      if (adler <= 0xFFF0) {
        uLong v10 = adler;
      }
      return v10 | ((v5 % 0xFFF1) << 16);
    }
  }
  else
  {
    return 1;
  }
}

double _tr_init(uint64_t a1)
{
  *(void *)(a1 + 2888) = a1 + 196;
  *(void *)(a1 + 2904) = &static_l_desc;
  *(void *)(a1 + 2912) = a1 + 2488;
  *(void *)(a1 + 2928) = &static_d_desc;
  *(void *)(a1 + 2936) = a1 + 2732;
  *(void *)(a1 + 2952) = &static_bl_desc;
  *(_WORD *)(a1 + 5920) = 0;
  *(_DWORD *)(a1 + 5924) = 0;
  *(_DWORD *)(a1 + 5916) = 8;
  return init_block(a1);
}

int deflate(z_streamp strm, int flush)
{
  if (!strm) {
    return -2;
  }
  uint64_t v2 = *(void *)&flush;
  int result = -2;
  if (flush <= 5)
  {
    state = strm->state;
    if (state)
    {
      if (!strm->next_out || !strm->next_in && strm->avail_in || (int v6 = *((_DWORD *)state + 2), flush != 4) && v6 == 666)
      {
        strm->msg = "stream error";
        return result;
      }
      if (!strm->avail_out) {
        goto LABEL_136;
      }
      *(void *)state = strm;
      int v7 = *((_DWORD *)state + 16);
      *((_DWORD *)state + 16) = flush;
      if (v6 == 42)
      {
        if (*((_DWORD *)state + 11) == 2)
        {
          strm->uLong adler = crc32(0, 0, 0);
          uint64_t v8 = *((void *)state + 2);
          uint64_t v9 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v9 + 1;
          *(unsigned char *)(v8 + v9) = 31;
          uint64_t v10 = *((void *)state + 2);
          uint64_t v11 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v11 + 1;
          *(unsigned char *)(v10 + v11) = -117;
          uint64_t v12 = *((void *)state + 2);
          uint64_t v13 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v13 + 1;
          *(unsigned char *)(v12 + v13) = 8;
          uint64_t v14 = *((void *)state + 6);
          if (!v14)
          {
            uint64_t v52 = *((void *)state + 2);
            uint64_t v53 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v53 + 1;
            *(unsigned char *)(v52 + v53) = 0;
            uint64_t v54 = *((void *)state + 2);
            uint64_t v55 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v55 + 1;
            *(unsigned char *)(v54 + v55) = 0;
            uint64_t v56 = *((void *)state + 2);
            uint64_t v57 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v57 + 1;
            *(unsigned char *)(v56 + v57) = 0;
            uint64_t v58 = *((void *)state + 2);
            uint64_t v59 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v59 + 1;
            *(unsigned char *)(v58 + v59) = 0;
            uint64_t v60 = *((void *)state + 2);
            uint64_t v61 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v61 + 1;
            *(unsigned char *)(v60 + v61) = 0;
            int v62 = *((_DWORD *)state + 45);
            if (v62 == 9)
            {
              char v63 = 2;
            }
            else if (*((int *)state + 46) > 1 || v62 < 2)
            {
              char v63 = 4;
            }
            else
            {
              char v63 = 0;
            }
            uint64_t v112 = *((void *)state + 2);
            uint64_t v113 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v113 + 1;
            *(unsigned char *)(v112 + v113) = v63;
            uint64_t v114 = *((void *)state + 2);
            uint64_t v115 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v115 + 1;
            *(unsigned char *)(v114 + v115) = 3;
LABEL_127:
            *((_DWORD *)state + 2) = 113;
            goto LABEL_128;
          }
          char v15 = (*(_DWORD *)v14 != 0) | (2 * (*(_DWORD *)(v14 + 68) != 0)) | (4 * (*(void *)(v14 + 24) != 0)) | (8 * (*(void *)(v14 + 40) != 0)) | (16 * (*(void *)(v14 + 56) != 0));
          uint64_t v16 = *((void *)state + 2);
          uint64_t v17 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v17 + 1;
          *(unsigned char *)(v16 + v17) = v15;
          uint64_t v18 = *(void *)(*((void *)state + 6) + 8);
          uint64_t v19 = *((void *)state + 2);
          uint64_t v20 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v20 + 1;
          *(unsigned char *)(v19 + v20) = v18;
          uint64_t v21 = *(void *)(*((void *)state + 6) + 8) >> 8;
          uint64_t v22 = *((void *)state + 2);
          uint64_t v23 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v23 + 1;
          *(unsigned char *)(v22 + v23) = v21;
          uint64_t v24 = *(void *)(*((void *)state + 6) + 8) >> 16;
          uint64_t v25 = *((void *)state + 2);
          uint64_t v26 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v26 + 1;
          *(unsigned char *)(v25 + v26) = v24;
          uint64_t v27 = *(void *)(*((void *)state + 6) + 8) >> 24;
          uint64_t v28 = *((void *)state + 2);
          uint64_t v29 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v29 + 1;
          *(unsigned char *)(v28 + v29) = v27;
          int v30 = *((_DWORD *)state + 45);
          if (v30 == 9)
          {
            char v31 = 2;
          }
          else if (*((int *)state + 46) > 1 || v30 < 2)
          {
            char v31 = 4;
          }
          else
          {
            char v31 = 0;
          }
          uint64_t v65 = *((void *)state + 2);
          uint64_t v66 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v66 + 1;
          *(unsigned char *)(v65 + v66) = v31;
          char v67 = *(_DWORD *)(*((void *)state + 6) + 20);
          uint64_t v68 = *((void *)state + 2);
          uint64_t v69 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v69 + 1;
          *(unsigned char *)(v68 + v69) = v67;
          uint64_t v70 = *((void *)state + 6);
          if (*(void *)(v70 + 24))
          {
            char v71 = *(_DWORD *)(v70 + 32);
            uint64_t v72 = *((void *)state + 2);
            uint64_t v73 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v73 + 1;
            *(unsigned char *)(v72 + v73) = v71;
            int v74 = *(_DWORD *)(*((void *)state + 6) + 32) >> 8;
            uint64_t v75 = *((void *)state + 2);
            uint64_t v76 = *((unsigned int *)state + 10);
            *((_DWORD *)state + 10) = v76 + 1;
            *(unsigned char *)(v75 + v76) = v74;
            uint64_t v70 = *((void *)state + 6);
          }
          if (*(_DWORD *)(v70 + 68)) {
            strm->uLong adler = crc32(strm->adler, *((const Bytef **)state + 2), *((_DWORD *)state + 10));
          }
          *((_DWORD *)state + 14) = 0;
          *((_DWORD *)state + 2) = 69;
LABEL_49:
          uint64_t v77 = *((void *)state + 6);
          if (!*(void *)(v77 + 24)) {
            goto LABEL_68;
          }
          unsigned int v78 = *((_DWORD *)state + 10);
          unsigned int v79 = *((_DWORD *)state + 14);
          while (1)
          {
            if (v79 >= *(unsigned __int16 *)(v77 + 32)) {
              goto LABEL_63;
            }
            uint64_t v80 = *((unsigned int *)state + 10);
            if (*((void *)state + 3) == v80)
            {
              if (*(_DWORD *)(v77 + 68)) {
                BOOL v81 = v80 > v78;
              }
              else {
                BOOL v81 = 0;
              }
              if (v81) {
                strm->uLong adler = crc32(strm->adler, (const Bytef *)(*((void *)state + 2) + v78), v80 - v78);
              }
              flush_pending(strm);
              uint64_t v80 = *((unsigned int *)state + 10);
              uint64_t v77 = *((void *)state + 6);
              if (*((void *)state + 3) == v80)
              {
                unsigned int v78 = *((_DWORD *)state + 10);
LABEL_63:
                if (*(_DWORD *)(v77 + 68))
                {
                  unsigned int v84 = *((_DWORD *)state + 10);
                  if (v84 > v78)
                  {
                    strm->uLong adler = crc32(strm->adler, (const Bytef *)(*((void *)state + 2) + v78), v84 - v78);
                    uint64_t v77 = *((void *)state + 6);
                  }
                }
                if (*((_DWORD *)state + 14) == *(_DWORD *)(v77 + 32))
                {
                  *((_DWORD *)state + 14) = 0;
LABEL_68:
                  *((_DWORD *)state + 2) = 73;
LABEL_72:
                  if (*(void *)(v77 + 40))
                  {
                    unsigned int v85 = *((_DWORD *)state + 10);
                    do
                    {
                      uint64_t v86 = *((unsigned int *)state + 10);
                      uint64_t v87 = *((void *)state + 6);
                      if (*((void *)state + 3) == v86)
                      {
                        if (*(_DWORD *)(v87 + 68)) {
                          BOOL v88 = v86 > v85;
                        }
                        else {
                          BOOL v88 = 0;
                        }
                        if (v88) {
                          strm->uLong adler = crc32(strm->adler, (const Bytef *)(*((void *)state + 2) + v85), v86 - v85);
                        }
                        flush_pending(strm);
                        uint64_t v86 = *((unsigned int *)state + 10);
                        if (*((void *)state + 3) == v86)
                        {
                          char v92 = 0;
                          goto LABEL_86;
                        }
                        uint64_t v87 = *((void *)state + 6);
                        unsigned int v85 = *((_DWORD *)state + 10);
                      }
                      uint64_t v89 = *(void *)(v87 + 40);
                      uint64_t v90 = *((unsigned int *)state + 14);
                      *((_DWORD *)state + 14) = v90 + 1;
                      LODWORD(v89) = *(unsigned __int8 *)(v89 + v90);
                      uint64_t v91 = *((void *)state + 2);
                      *((_DWORD *)state + 10) = v86 + 1;
                      *(unsigned char *)(v91 + v86) = v89;
                    }
                    while (v89);
                    char v92 = 1;
                    LODWORD(v86) = v85;
LABEL_86:
                    if (*(_DWORD *)(*((void *)state + 6) + 68))
                    {
                      unsigned int v93 = *((_DWORD *)state + 10);
                      if (v93 > v86) {
                        strm->uLong adler = crc32(strm->adler, (const Bytef *)(*((void *)state + 2) + v86), v93 - v86);
                      }
                    }
                    if (v92)
                    {
                      *((_DWORD *)state + 14) = 0;
                      goto LABEL_91;
                    }
                    int v6 = *((_DWORD *)state + 2);
LABEL_93:
                    if (v6 != 91) {
                      goto LABEL_114;
                    }
                  }
                  else
                  {
LABEL_91:
                    *((_DWORD *)state + 2) = 91;
                  }
                  if (!*(void *)(*((void *)state + 6) + 56)) {
                    goto LABEL_112;
                  }
                  unsigned int v94 = *((_DWORD *)state + 10);
                  while (1)
                  {
                    uint64_t v95 = *((unsigned int *)state + 10);
                    uint64_t v96 = *((void *)state + 6);
                    if (*((void *)state + 3) == v95)
                    {
                      if (*(_DWORD *)(v96 + 68)) {
                        BOOL v97 = v95 > v94;
                      }
                      else {
                        BOOL v97 = 0;
                      }
                      if (v97) {
                        strm->uLong adler = crc32(strm->adler, (const Bytef *)(*((void *)state + 2) + v94), v95 - v94);
                      }
                      flush_pending(strm);
                      uint64_t v95 = *((unsigned int *)state + 10);
                      if (*((void *)state + 3) == v95)
                      {
                        char v101 = 0;
LABEL_108:
                        if (*(_DWORD *)(*((void *)state + 6) + 68))
                        {
                          unsigned int v102 = *((_DWORD *)state + 10);
                          if (v102 > v95) {
                            strm->uLong adler = crc32(strm->adler, (const Bytef *)(*((void *)state + 2) + v95), v102 - v95);
                          }
                        }
                        if (v101)
                        {
LABEL_112:
                          *((_DWORD *)state + 2) = 103;
                          goto LABEL_115;
                        }
                        int v6 = *((_DWORD *)state + 2);
LABEL_114:
                        if (v6 == 103)
                        {
LABEL_115:
                          if (!*(_DWORD *)(*((void *)state + 6) + 68)) {
                            goto LABEL_127;
                          }
                          unsigned int v103 = *((_DWORD *)state + 10);
                          unint64_t v104 = v103 + 2;
                          unint64_t v105 = *((void *)state + 3);
                          if (v105 < v104)
                          {
                            flush_pending(strm);
                            unsigned int v103 = *((_DWORD *)state + 10);
                            unint64_t v105 = *((void *)state + 3);
                            unint64_t v104 = v103 + 2;
                          }
                          if (v105 >= v104)
                          {
                            uLong adler = strm->adler;
                            uint64_t v107 = *((void *)state + 2);
                            *((_DWORD *)state + 10) = v103 + 1;
                            *(unsigned char *)(v107 + v103) = adler;
                            uLong v108 = strm->adler >> 8;
                            uint64_t v109 = *((void *)state + 2);
                            uint64_t v110 = *((unsigned int *)state + 10);
                            *((_DWORD *)state + 10) = v110 + 1;
                            *(unsigned char *)(v109 + v110) = v108;
                            strm->uLong adler = crc32(0, 0, 0);
                            goto LABEL_127;
                          }
                        }
LABEL_128:
                        if (*((_DWORD *)state + 10))
                        {
                          flush_pending(strm);
                          if (strm->avail_out) {
                            goto LABEL_130;
                          }
LABEL_162:
                          int result = 0;
                          *((_DWORD *)state + 16) = -1;
                          return result;
                        }
                        if (!strm->avail_in && v2 != 4 && v7 >= (int)v2)
                        {
LABEL_136:
                          strm->msg = "buffer error";
                          return -5;
                        }
LABEL_130:
                        int v116 = *((_DWORD *)state + 2);
                        uInt avail_in = strm->avail_in;
                        if (v116 != 666)
                        {
                          if (!avail_in) {
                            goto LABEL_138;
                          }
                          goto LABEL_139;
                        }
                        if (avail_in) {
                          goto LABEL_136;
                        }
LABEL_138:
                        if (*((_DWORD *)state + 41))
                        {
LABEL_139:
                          int v118 = *((_DWORD *)state + 46);
                          if (v118 == 3)
                          {
                            int v119 = deflate_rle((uint64_t)state, v2);
                          }
                          else if (v118 == 2)
                          {
                            int v119 = deflate_huff((uint64_t)state, v2);
                          }
                          else
                          {
                            int v119 = configuration_table[2 * *((int *)state + 45) + 1](state, v2);
                          }
                          if ((v119 & 0xFFFFFFFE) == 2) {
                            *((_DWORD *)state + 2) = 666;
                          }
                          if ((v119 & 0xFFFFFFFD) != 0)
                          {
                            if (v119 == 1)
                            {
                              if (v2 != 5)
                              {
                                if (v2 == 1)
                                {
                                  _tr_align((uint64_t)state);
                                }
                                else
                                {
                                  _tr_stored_block((uint64_t)state, 0, 0, 0);
                                  if (v2 == 3)
                                  {
                                    unsigned int v120 = (char *)*((void *)state + 13);
                                    size_t v121 = 2 * (*((_DWORD *)state + 29) - 1);
                                    *(_WORD *)&v120[v121] = 0;
                                    bzero(v120, v121);
                                    if (!*((_DWORD *)state + 41))
                                    {
                                      *((_DWORD *)state + 39) = 0;
                                      *((void *)state + 17) = 0;
                                    }
                                  }
                                }
                              }
                              flush_pending(strm);
                              if (!strm->avail_out) {
                                goto LABEL_162;
                              }
                            }
                            goto LABEL_160;
                          }
                          if (!strm->avail_out) {
                            goto LABEL_162;
                          }
                        }
                        else if (v2)
                        {
                          if (v116 != 666) {
                            goto LABEL_139;
                          }
LABEL_160:
                          if (v2 == 4)
                          {
                            int v122 = *((_DWORD *)state + 11);
                            if (v122 < 1) {
                              return 1;
                            }
                            uLong v123 = strm->adler;
                            if (v122 == 2)
                            {
                              uint64_t v124 = *((void *)state + 2);
                              uint64_t v125 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v125 + 1;
                              *(unsigned char *)(v124 + v125) = v123;
                              uLong v126 = strm->adler >> 8;
                              uint64_t v127 = *((void *)state + 2);
                              uint64_t v128 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v128 + 1;
                              *(unsigned char *)(v127 + v128) = v126;
                              uLong v129 = strm->adler >> 16;
                              uint64_t v130 = *((void *)state + 2);
                              uint64_t v131 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v131 + 1;
                              *(unsigned char *)(v130 + v131) = v129;
                              uLong v132 = strm->adler >> 24;
                              uint64_t v133 = *((void *)state + 2);
                              uint64_t v134 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v134 + 1;
                              *(unsigned char *)(v133 + v134) = v132;
                              uLong total_in = strm->total_in;
                              uint64_t v136 = *((void *)state + 2);
                              uint64_t v137 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v137 + 1;
                              *(unsigned char *)(v136 + v137) = total_in;
                              uLong v138 = strm->total_in >> 8;
                              uint64_t v139 = *((void *)state + 2);
                              uint64_t v140 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v140 + 1;
                              *(unsigned char *)(v139 + v140) = v138;
                              uLong v141 = strm->total_in >> 16;
                              uint64_t v142 = *((void *)state + 2);
                              uint64_t v143 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v143 + 1;
                              *(unsigned char *)(v142 + v143) = v141;
                              uLong v144 = strm->total_in >> 24;
                            }
                            else
                            {
                              uLong v145 = v123 >> 16;
                              uint64_t v146 = *((void *)state + 2);
                              uint64_t v147 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v147 + 1;
                              *(unsigned char *)(v146 + v147) = BYTE3(v123);
                              uint64_t v148 = *((void *)state + 2);
                              uint64_t v149 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v149 + 1;
                              *(unsigned char *)(v148 + v149) = v145;
                              uLong v144 = strm->adler;
                              uint64_t v150 = *((void *)state + 2);
                              uint64_t v151 = *((unsigned int *)state + 10);
                              *((_DWORD *)state + 10) = v151 + 1;
                              *(unsigned char *)(v150 + v151) = BYTE1(v144);
                            }
                            uint64_t v152 = *((void *)state + 2);
                            uint64_t v153 = *((unsigned int *)state + 10);
                            *((_DWORD *)state + 10) = v153 + 1;
                            *(unsigned char *)(v152 + v153) = v144;
                            flush_pending(strm);
                            int v154 = *((_DWORD *)state + 11);
                            if (v154 >= 1) {
                              *((_DWORD *)state + 11) = -v154;
                            }
                            return *((_DWORD *)state + 10) == 0;
                          }
                        }
                        return 0;
                      }
                      uint64_t v96 = *((void *)state + 6);
                      unsigned int v94 = *((_DWORD *)state + 10);
                    }
                    uint64_t v98 = *(void *)(v96 + 56);
                    uint64_t v99 = *((unsigned int *)state + 14);
                    *((_DWORD *)state + 14) = v99 + 1;
                    LODWORD(v98) = *(unsigned __int8 *)(v98 + v99);
                    uint64_t v100 = *((void *)state + 2);
                    *((_DWORD *)state + 10) = v95 + 1;
                    *(unsigned char *)(v100 + v95) = v98;
                    if (!v98)
                    {
                      char v101 = 1;
                      LODWORD(v95) = v94;
                      goto LABEL_108;
                    }
                  }
                }
                int v6 = *((_DWORD *)state + 2);
LABEL_70:
                if (v6 == 73)
                {
                  uint64_t v77 = *((void *)state + 6);
                  goto LABEL_72;
                }
                goto LABEL_93;
              }
              unsigned int v79 = *((_DWORD *)state + 14);
              unsigned int v78 = *((_DWORD *)state + 10);
            }
            char v82 = *(unsigned char *)(*(void *)(v77 + 24) + v79);
            uint64_t v83 = *((void *)state + 2);
            *((_DWORD *)state + 10) = v80 + 1;
            *(unsigned char *)(v83 + v80) = v82;
            unsigned int v79 = *((_DWORD *)state + 14) + 1;
            *((_DWORD *)state + 14) = v79;
            uint64_t v77 = *((void *)state + 6);
          }
        }
        if (*((int *)state + 46) <= 1)
        {
          int v33 = *((_DWORD *)state + 45);
          if (v33 == 6) {
            int v34 = 128;
          }
          else {
            int v34 = 192;
          }
          if (v33 >= 6) {
            int v35 = v34;
          }
          else {
            int v35 = 64;
          }
          if (v33 >= 2) {
            int v32 = v35;
          }
          else {
            int v32 = 0;
          }
        }
        else
        {
          int v32 = 0;
        }
        unsigned int v36 = v32 | ((*((_DWORD *)state + 18) << 12) - 30720);
        if (*((_DWORD *)state + 39)) {
          v36 |= 0x20u;
        }
        *((_DWORD *)state + 2) = 113;
        uint64_t v37 = *((void *)state + 2);
        uint64_t v38 = *((unsigned int *)state + 10);
        *((_DWORD *)state + 10) = v38 + 1;
        *(unsigned char *)(v37 + v38) = BYTE1(v36);
        uint64_t v39 = *((void *)state + 2);
        uint64_t v40 = *((unsigned int *)state + 10);
        *((_DWORD *)state + 10) = v40 + 1;
        *(unsigned char *)(v39 + v40) = ((v36 % 0x1F) | v36) ^ 0x1F;
        if (*((_DWORD *)state + 39))
        {
          uLong v41 = strm->adler;
          uLong v42 = v41 >> 16;
          uint64_t v43 = *((void *)state + 2);
          uint64_t v44 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v44 + 1;
          *(unsigned char *)(v43 + v44) = BYTE3(v41);
          uint64_t v45 = *((void *)state + 2);
          uint64_t v46 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v46 + 1;
          *(unsigned char *)(v45 + v46) = v42;
          uLong v47 = strm->adler;
          uint64_t v48 = *((void *)state + 2);
          uint64_t v49 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v49 + 1;
          *(unsigned char *)(v48 + v49) = BYTE1(v47);
          uint64_t v50 = *((void *)state + 2);
          uint64_t v51 = *((unsigned int *)state + 10);
          *((_DWORD *)state + 10) = v51 + 1;
          *(unsigned char *)(v50 + v51) = v47;
        }
        strm->uLong adler = adler32(0, 0, 0);
        int v6 = *((_DWORD *)state + 2);
      }
      if (v6 != 69) {
        goto LABEL_70;
      }
      goto LABEL_49;
    }
  }
  return result;
}

uint64_t deflate_slow(uint64_t a1, int a2)
{
  while (1)
  {
    if (*(_DWORD *)(a1 + 164) >= 0x106u)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 144);
      int v6 = *(_DWORD *)(a1 + 160);
      goto LABEL_8;
    }
    fill_window((uint64_t *)a1);
    unsigned int v4 = *(_DWORD *)(a1 + 164);
    if (!a2 && v4 < 0x106) {
      return 0;
    }
    if (!v4) {
      break;
    }
    unsigned int v5 = *(_DWORD *)(a1 + 144);
    int v6 = *(_DWORD *)(a1 + 160);
    if (v4 <= 2)
    {
      *(_DWORD *)(a1 + 168) = v5;
      unsigned int v7 = 2;
      *(_DWORD *)(a1 + 144) = 2;
      *(_DWORD *)(a1 + 148) = v6;
      goto LABEL_18;
    }
LABEL_8:
    unsigned int v8 = *(_DWORD *)(a1 + 156);
    unsigned int v9 = ((*(_DWORD *)(a1 + 112) << *(_DWORD *)(a1 + 128)) ^ *(unsigned __int8 *)(*(void *)(a1 + 80) + v8 + 2)) & *(_DWORD *)(a1 + 124);
    *(_DWORD *)(a1 + 112) = v9;
    uint64_t v10 = *(void *)(a1 + 104);
    unsigned int v11 = *(unsigned __int16 *)(v10 + 2 * v9);
    *(_WORD *)(*(void *)(a1 + 96) + 2 * (*(_DWORD *)(a1 + 76) & v8)) = v11;
    *(_WORD *)(v10 + 2 * v9) = v8;
    *(_DWORD *)(a1 + 168) = v5;
    unsigned int v7 = 2;
    *(_DWORD *)(a1 + 144) = 2;
    *(_DWORD *)(a1 + 148) = v6;
    if (!v11) {
      goto LABEL_18;
    }
    if (v5 < *(_DWORD *)(a1 + 176) && v8 - v11 <= *(_DWORD *)(a1 + 68) - 262)
    {
      unsigned int v7 = longest_match(a1, v11);
      *(_DWORD *)(a1 + 144) = v7;
      if (v7 <= 5)
      {
        if (*(_DWORD *)(a1 + 184) != 1)
        {
          if (v7 != 3) {
            goto LABEL_17;
          }
          if ((*(_DWORD *)(a1 + 156) - *(_DWORD *)(a1 + 160)) <= 0x1000)
          {
            unsigned int v7 = 3;
            goto LABEL_17;
          }
        }
        unsigned int v7 = 2;
        *(_DWORD *)(a1 + 144) = 2;
      }
    }
LABEL_17:
    unsigned int v5 = *(_DWORD *)(a1 + 168);
LABEL_18:
    unsigned __int8 v12 = v5 - 3;
    if (v5 < 3 || v7 > v5)
    {
      if (*(_DWORD *)(a1 + 152))
      {
        uint64_t v29 = *(unsigned __int8 *)(*(void *)(a1 + 80) + (*(_DWORD *)(a1 + 156) - 1));
        uint64_t v30 = *(unsigned int *)(a1 + 5884);
        *(_WORD *)(*(void *)(a1 + 5888) + 2 * v30) = 0;
        uint64_t v31 = *(void *)(a1 + 5872);
        *(_DWORD *)(a1 + 5884) = v30 + 1;
        *(unsigned char *)(v31 + v30) = v29;
        ++*(_WORD *)(a1 + 4 * v29 + 196);
        if (*(_DWORD *)(a1 + 5884) == *(_DWORD *)(a1 + 5880) - 1)
        {
          uint64_t v32 = *(void *)(a1 + 136);
          if (v32 < 0) {
            int v33 = 0;
          }
          else {
            int v33 = (char *)(*(void *)(a1 + 80) + v32);
          }
          _tr_flush_block((int *)a1, v33, *(unsigned int *)(a1 + 156) - v32, 0);
          *(void *)(a1 + 136) = *(unsigned int *)(a1 + 156);
          flush_pending(*(void **)a1);
        }
        ++*(_DWORD *)(a1 + 156);
        --*(_DWORD *)(a1 + 164);
        goto LABEL_39;
      }
      int v34 = *(_DWORD *)(a1 + 156) + 1;
      *(_DWORD *)(a1 + 152) = 1;
      *(_DWORD *)(a1 + 156) = v34;
      --*(_DWORD *)(a1 + 164);
    }
    else
    {
      int v13 = *(_DWORD *)(a1 + 156);
      int v14 = v13 + *(_DWORD *)(a1 + 164);
      int v15 = v13 + ~*(_DWORD *)(a1 + 148);
      uint64_t v16 = *(unsigned int *)(a1 + 5884);
      *(_WORD *)(*(void *)(a1 + 5888) + 2 * v16) = v15;
      uint64_t v17 = *(void *)(a1 + 5872);
      *(_DWORD *)(a1 + 5884) = v16 + 1;
      *(unsigned char *)(v17 + v16) = v12;
      unsigned __int16 v18 = v15 - 1;
      uint64_t v19 = a1 + 4 * _length_code[v12];
      ++*(_WORD *)(v19 + 1224);
      if ((v18 & 0xFF00) != 0) {
        unsigned __int16 v18 = (v18 >> 7) + 256;
      }
      unsigned int v20 = v14 - 3;
      uint64_t v24 = a1 + 4 * _dist_code[v18];
      ++*(_WORD *)(v24 + 2488);
      int v21 = *(_DWORD *)(a1 + 5884);
      int v22 = *(_DWORD *)(a1 + 5880) - 1;
      LODWORD(v24) = *(_DWORD *)(a1 + 168);
      *(_DWORD *)(a1 + 164) = *(_DWORD *)(a1 + 164) - v24 + 1;
      *(_DWORD *)(a1 + 168) = v24 - 2;
      int v23 = v24 - 3;
      LODWORD(v24) = *(_DWORD *)(a1 + 156) + 1;
      do
      {
        *(_DWORD *)(a1 + 156) = v24;
        if (v24 <= v20)
        {
          unsigned int v25 = ((*(_DWORD *)(a1 + 112) << *(_DWORD *)(a1 + 128)) ^ *(unsigned __int8 *)(*(void *)(a1 + 80)
                                                                                       + (v24 + 2))) & *(_DWORD *)(a1 + 124);
          *(_DWORD *)(a1 + 112) = v25;
          uint64_t v26 = *(void *)(a1 + 104);
          *(_WORD *)(*(void *)(a1 + 96) + 2 * (*(_DWORD *)(a1 + 76) & v24)) = *(_WORD *)(v26 + 2 * v25);
          *(_WORD *)(v26 + 2 * v25) = v24;
        }
        *(_DWORD *)(a1 + 168) = v23--;
        uint64_t v24 = (v24 + 1);
      }
      while (v23 != -1);
      *(_DWORD *)(a1 + 144) = 2;
      *(_DWORD *)(a1 + 152) = 0;
      *(_DWORD *)(a1 + 156) = v24;
      if (v21 == v22)
      {
        uint64_t v27 = *(void *)(a1 + 136);
        if (v27 < 0) {
          uint64_t v28 = 0;
        }
        else {
          uint64_t v28 = (char *)(*(void *)(a1 + 80) + v27);
        }
        _tr_flush_block((int *)a1, v28, v24 - v27, 0);
        *(void *)(a1 + 136) = *(unsigned int *)(a1 + 156);
        flush_pending(*(void **)a1);
LABEL_39:
        if (!*(_DWORD *)(*(void *)a1 + 32)) {
          return 0;
        }
      }
    }
  }
  if (*(_DWORD *)(a1 + 152))
  {
    uint64_t v36 = *(unsigned __int8 *)(*(void *)(a1 + 80) + (*(_DWORD *)(a1 + 156) - 1));
    uint64_t v37 = *(unsigned int *)(a1 + 5884);
    *(_WORD *)(*(void *)(a1 + 5888) + 2 * v37) = 0;
    uint64_t v38 = *(void *)(a1 + 5872);
    *(_DWORD *)(a1 + 5884) = v37 + 1;
    *(unsigned char *)(v38 + v37) = v36;
    ++*(_WORD *)(a1 + 4 * v36 + 196);
    *(_DWORD *)(a1 + 152) = 0;
  }
  uint64_t v39 = *(void *)(a1 + 136);
  if (v39 < 0) {
    uint64_t v40 = 0;
  }
  else {
    uint64_t v40 = (char *)(*(void *)(a1 + 80) + v39);
  }
  _tr_flush_block((int *)a1, v40, *(unsigned int *)(a1 + 156) - v39, a2 == 4);
  *(void *)(a1 + 136) = *(unsigned int *)(a1 + 156);
  flush_pending(*(void **)a1);
  if (!*(_DWORD *)(*(void *)a1 + 32)) {
    return 2 * (a2 == 4);
  }
  if (a2 == 4) {
    return 3;
  }
  return 1;
}

void fill_window(uint64_t *a1)
{
  size_t v2 = *((unsigned int *)a1 + 17);
  unsigned int v3 = *((_DWORD *)a1 + 41);
  int32x2_t v4 = vdup_n_s32(v2);
  while (1)
  {
    unsigned int v5 = *((_DWORD *)a1 + 39);
    LODWORD(v6) = *((_DWORD *)a1 + 22) - (v3 + v5);
    if (v5 >= (int)v2 - 262 + *((_DWORD *)a1 + 17))
    {
      memcpy((void *)a1[10], (const void *)(a1[10] + v2), v2);
      int32x2_t v7 = vsub_s32(*(int32x2_t *)((char *)a1 + 156), v4);
      *(uint64_t *)((char *)a1 + 156) = (uint64_t)v7;
      a1[17] -= v2;
      uint64_t v8 = *((unsigned int *)a1 + 29);
      unsigned int v9 = (_WORD *)(a1[13] + 2 * v8 - 2);
      do
      {
        unsigned int v10 = (unsigned __int16)*v9;
        BOOL v11 = v10 >= v2;
        __int16 v12 = v10 - v2;
        if (!v11) {
          __int16 v12 = 0;
        }
        *v9-- = v12;
        LODWORD(v8) = v8 - 1;
      }
      while (v8);
      int v13 = (_WORD *)(a1[12] + 2 * v2 - 2);
      int v14 = v2;
      do
      {
        unsigned int v15 = (unsigned __int16)*v13;
        BOOL v11 = v15 >= v2;
        __int16 v16 = v15 - v2;
        if (!v11) {
          __int16 v16 = 0;
        }
        *v13-- = v16;
        --v14;
      }
      while (v14);
      LODWORD(v6) = v2 + v6;
      unsigned int v5 = v7.i32[0];
    }
    uint64_t v17 = *a1;
    unsigned int v18 = *(_DWORD *)(*a1 + 8);
    if (!v18) {
      break;
    }
    uint64_t v19 = *((unsigned int *)a1 + 41);
    if (v18 >= v6) {
      size_t v6 = v6;
    }
    else {
      size_t v6 = v18;
    }
    if (!v6) {
      goto LABEL_23;
    }
    uint64_t v20 = a1[10];
    *(_DWORD *)(v17 + 8) = v18 - v6;
    int v21 = *(_DWORD *)(*(void *)(v17 + 56) + 44);
    if (v21 == 2)
    {
      uLong v22 = crc32(*(void *)(v17 + 96), *(const Bytef **)v17, v6);
      goto LABEL_21;
    }
    if (v21 == 1)
    {
      uLong v22 = adler32(*(void *)(v17 + 96), *(const Bytef **)v17, v6);
LABEL_21:
      *(void *)(v17 + 96) = v22;
    }
    memcpy((void *)(v20 + v5 + v19), *(const void **)v17, v6);
    *(void *)v17 += v6;
    *(void *)(v17 + 16) += v6;
    LODWORD(v19) = *((_DWORD *)a1 + 41);
LABEL_23:
    unsigned int v3 = v19 + v6;
    *((_DWORD *)a1 + 41) = v19 + v6;
    if ((v19 + v6) >= 3
      && (uint64_t v23 = a1[10],
          uint64_t v24 = *((unsigned int *)a1 + 39),
          int v25 = *(unsigned __int8 *)(v23 + v24),
          *((_DWORD *)a1 + 28) = v25,
          *((_DWORD *)a1 + 28) = ((v25 << *((_DWORD *)a1 + 32)) ^ *(unsigned __int8 *)(v23 + (v24 + 1))) & *((_DWORD *)a1 + 31),
          v3 > 0x105)
      || !*(_DWORD *)(*a1 + 8))
    {
      unint64_t v26 = a1[741];
      unint64_t v27 = a1[11];
      if (v27 <= v26) {
        return;
      }
      unint64_t v28 = *((unsigned int *)a1 + 39) + (unint64_t)v3;
      if (v26 >= v28)
      {
        if (v28 + 258 <= v26) {
          return;
        }
        if (v28 + 258 - v26 >= v27 - v26) {
          unint64_t v31 = v27 - v26;
        }
        else {
          unint64_t v31 = v28 + 258 - v26;
        }
        bzero((void *)(a1[10] + v26), v31);
        size_t v30 = a1[741] + v31;
      }
      else
      {
        if (v27 - v28 >= 0x102) {
          size_t v29 = 258;
        }
        else {
          size_t v29 = v27 - v28;
        }
        bzero((void *)(a1[10] + v28), v29);
        size_t v30 = v29 + v28;
      }
      a1[741] = v30;
      return;
    }
  }
}

uint64_t longest_match(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 172);
  uint64_t v3 = *(int *)(a1 + 168);
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t v5 = *(unsigned int *)(a1 + 156);
  size_t v6 = (unsigned __int8 *)(v4 + v5);
  unsigned int v7 = *(_DWORD *)(a1 + 68) - 262;
  BOOL v8 = v5 >= v7;
  unsigned int v9 = v5 - v7;
  if (!v8) {
    unsigned int v9 = 0;
  }
  uint64_t v10 = *(void *)(a1 + 96);
  unsigned int v11 = *(_DWORD *)(a1 + 76);
  unsigned int v12 = *(_DWORD *)(a1 + 164);
  int v13 = v6[v3 - 1];
  int v14 = v6[v3];
  unsigned int v15 = *(_DWORD *)(a1 + 192);
  if (v3 >= *(_DWORD *)(a1 + 188)) {
    v2 >>= 2;
  }
  if (v15 >= v12) {
    unsigned int v15 = *(_DWORD *)(a1 + 164);
  }
  while (1)
  {
    __int16 v16 = (unsigned __int8 *)(v4 + a2);
    if (v16[(int)v3] != v14 || v16[(int)v3 - 1] != v13 || *v16 != *v6 || v16[1] != v6[1]) {
      goto LABEL_32;
    }
    uint64_t v17 = 0;
    while (1)
    {
      unsigned int v18 = &v6[v17];
      if (v6[v17 + 3] != v16[v17 + 3])
      {
        int v24 = v18 + 3;
        goto LABEL_29;
      }
      if (v18[4] != v16[v17 + 4])
      {
        int v24 = v6 + v17 + 4;
        goto LABEL_29;
      }
      uint64_t v19 = &v6[v17];
      if (v6[v17 + 5] != v16[v17 + 5])
      {
        int v24 = v19 + 5;
        goto LABEL_29;
      }
      if (v19[6] != v16[v17 + 6])
      {
        int v24 = v6 + v17 + 6;
        goto LABEL_29;
      }
      uint64_t v20 = &v6[v17];
      if (v6[v17 + 7] != v16[v17 + 7])
      {
        int v24 = v20 + 7;
        goto LABEL_29;
      }
      if (v20[8] != v16[v17 + 8])
      {
        int v24 = v6 + v17 + 8;
        goto LABEL_29;
      }
      int v21 = &v6[v17];
      uLong v22 = &v16[v17];
      if (v6[v17 + 9] != v16[v17 + 9]) {
        break;
      }
      unint64_t v23 = v17 + 2;
      v17 += 8;
      if (v23 > 0xF9 || v21[10] != v22[10])
      {
        int v24 = v6 + v17 + 2;
        goto LABEL_29;
      }
    }
    int v24 = v21 + 9;
LABEL_29:
    int v25 = v24 - (v6 + 258);
    int v26 = v24 - v6;
    if (v26 <= (int)v3) {
      goto LABEL_32;
    }
    *(_DWORD *)(a1 + 160) = a2;
    if (v26 >= (int)v15) {
      break;
    }
    int v13 = v6[v25 + 257];
    int v14 = v6[v26];
    LODWORD(v3) = v26;
LABEL_32:
    a2 = *(unsigned __int16 *)(v10 + 2 * (a2 & v11));
    --v2;
    if (v9 >= a2 || v2 == 0) {
      goto LABEL_37;
    }
  }
  LODWORD(v3) = v26;
LABEL_37:
  if (v3 >= v12) {
    return v12;
  }
  else {
    return v3;
  }
}

void *flush_pending(void *result)
{
  uint64_t v1 = *((void *)result + 7);
  unsigned int v2 = *(_DWORD *)(v1 + 40);
  unsigned int v3 = *((_DWORD *)result + 8);
  if (v2 >= v3) {
    size_t v4 = v3;
  }
  else {
    size_t v4 = v2;
  }
  if (v4)
  {
    uint64_t v5 = result;
    int result = memcpy(*((void **)result + 3), *(const void **)(v1 + 32), v4);
    v5[3] += v4;
    uint64_t v6 = v5[7];
    *(void *)(v6 + 32) += v4;
    v5[5] += v4;
    *((_DWORD *)v5 + 8) -= v4;
    int v7 = *(_DWORD *)(v6 + 40) - v4;
    *(_DWORD *)(v6 + 40) = v7;
    if (!v7) {
      *(void *)(v6 + 32) = *(void *)(v6 + 16);
    }
  }
  return result;
}

uint64_t bi_windup(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 5924);
  if (v1 >= 9)
  {
    unsigned int v2 = (uint64_t *)(result + 16);
    uint64_t v3 = *(void *)(result + 16);
    size_t v4 = (_DWORD *)(result + 40);
    uint64_t v5 = *(unsigned int *)(result + 40);
    char v6 = *(unsigned char *)(result + 5920);
    *(_DWORD *)(result + 40) = v5 + 1;
    *(unsigned char *)(v3 + v5) = v6;
    char v7 = *(unsigned char *)(result + 5921);
LABEL_5:
    uint64_t v8 = *v2;
    uint64_t v9 = *v4;
    *size_t v4 = v9 + 1;
    *(unsigned char *)(v8 + v9) = v7;
    goto LABEL_6;
  }
  if (v1 >= 1)
  {
    char v7 = *(unsigned char *)(result + 5920);
    unsigned int v2 = (uint64_t *)(result + 16);
    size_t v4 = (_DWORD *)(result + 40);
    goto LABEL_5;
  }
LABEL_6:
  *(_WORD *)(result + 5920) = 0;
  *(_DWORD *)(result + 5924) = 0;
  return result;
}

void _tr_flush_block(int *a1, char *a2, uint64_t a3, int a4)
{
  if (a1[45] < 1)
  {
    unsigned int v11 = 0;
    unint64_t v12 = a3 + 5;
    unint64_t v13 = a3 + 5;
    if (!a2) {
      goto LABEL_24;
    }
  }
  else
  {
    if (*(_DWORD *)(*(void *)a1 + 88) == 2)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 4093624447;
      do
      {
        if ((v9 & 1) != 0 && LOWORD(a1[v8 + 49]))
        {
          int v10 = 0;
          goto LABEL_14;
        }
        v9 >>= 1;
        ++v8;
      }
      while (v8 != 32);
      if (!*((_WORD *)a1 + 116) && !*((_WORD *)a1 + 118) && !*((_WORD *)a1 + 124))
      {
        uint64_t v71 = 0;
        uint64_t v72 = a1 + 81;
        while (1)
        {
          int v10 = (unsigned __int16)v72[v71];
          if (v72[v71]) {
            break;
          }
          v71 += 2;
          if (v71 == 448) {
            goto LABEL_14;
          }
        }
      }
      int v10 = 1;
LABEL_14:
      *(_DWORD *)(*(void *)a1 + 88) = v10;
    }
    build_tree((uint64_t)a1, (uint64_t)(a1 + 722));
    build_tree((uint64_t)a1, (uint64_t)(a1 + 728));
    scan_tree(a1, (uint64_t)(a1 + 49), a1[724]);
    scan_tree(a1, (uint64_t)(a1 + 622), a1[730]);
    build_tree((uint64_t)a1, (uint64_t)(a1 + 734));
    unsigned int v11 = 0x12u;
    while (!HIWORD(a1[bl_order[v11] + 683]))
    {
      if (v11-- <= 3)
      {
        unsigned int v11 = 2;
        break;
      }
    }
    uint64_t v15 = *((void *)a1 + 737) + (int)(3 * v11 + 17);
    *((void *)a1 + 737) = v15;
    unint64_t v13 = (unint64_t)(v15 + 10) >> 3;
    unint64_t v12 = (unint64_t)(*((void *)a1 + 738) + 10) >> 3;
    if (v12 < v13) {
      unint64_t v13 = (unint64_t)(*((void *)a1 + 738) + 10) >> 3;
    }
    if (!a2) {
      goto LABEL_24;
    }
  }
  if (a3 + 4 <= v13)
  {
    _tr_stored_block((uint64_t)a1, a2, a3, a4);
    goto LABEL_50;
  }
LABEL_24:
  int v16 = a1[1481];
  if (v12 == v13 || a1[46] == 4)
  {
    int v25 = a4 + 2;
    if (v16 < 14)
    {
      *((_WORD *)a1 + 2960) |= v25 << v16;
      int v32 = v16 + 3;
    }
    else
    {
      __int16 v26 = *((_WORD *)a1 + 2960) | (v25 << v16);
      *((_WORD *)a1 + 2960) = v26;
      uint64_t v27 = *((void *)a1 + 2);
      uint64_t v28 = a1[10];
      a1[10] = v28 + 1;
      *(unsigned char *)(v27 + v28) = v26;
      LOBYTE(v26) = *((unsigned char *)a1 + 5921);
      uint64_t v29 = *((void *)a1 + 2);
      uint64_t v30 = a1[10];
      a1[10] = v30 + 1;
      *(unsigned char *)(v29 + v30) = v26;
      int v31 = a1[1481];
      *((_WORD *)a1 + 2960) = (unsigned __int16)(a4 + 2) >> (16 - v31);
      int v32 = v31 - 13;
    }
    a1[1481] = v32;
    uint64_t v44 = &static_ltree;
    uint64_t v45 = &static_dtree;
    uint64_t v46 = (uint64_t)a1;
  }
  else
  {
    int v17 = a4 + 4;
    if (v16 < 14)
    {
      int v23 = *((unsigned __int16 *)a1 + 2960) | (v17 << v16);
      int v24 = v16 + 3;
    }
    else
    {
      __int16 v18 = *((_WORD *)a1 + 2960) | (v17 << v16);
      *((_WORD *)a1 + 2960) = v18;
      uint64_t v19 = *((void *)a1 + 2);
      uint64_t v20 = a1[10];
      a1[10] = v20 + 1;
      *(unsigned char *)(v19 + v20) = v18;
      LOBYTE(v18) = *((unsigned char *)a1 + 5921);
      uint64_t v21 = *((void *)a1 + 2);
      uint64_t v22 = a1[10];
      a1[10] = v22 + 1;
      *(unsigned char *)(v21 + v22) = v18;
      LODWORD(v21) = a1[1481];
      int v23 = (unsigned __int16)(a4 + 4) >> (16 - v21);
      int v24 = v21 - 13;
    }
    a1[1481] = v24;
    int v33 = a1[724];
    int v34 = a1[730];
    int v35 = v33 + 65280;
    if (v24 < 12)
    {
      int v42 = v23 | (v35 << v24);
      int v43 = v24 + 5;
    }
    else
    {
      __int16 v36 = v23 | (v35 << v24);
      *((_WORD *)a1 + 2960) = v36;
      uint64_t v37 = *((void *)a1 + 2);
      uint64_t v38 = a1[10];
      a1[10] = v38 + 1;
      *(unsigned char *)(v37 + v38) = v36;
      LOBYTE(v36) = *((unsigned char *)a1 + 5921);
      uint64_t v39 = *((void *)a1 + 2);
      uint64_t v40 = a1[10];
      a1[10] = v40 + 1;
      *(unsigned char *)(v39 + v40) = v36;
      int v41 = a1[1481];
      int v42 = (unsigned __int16)(v33 - 256) >> (16 - v41);
      int v43 = v41 - 11;
    }
    a1[1481] = v43;
    if (v43 < 12)
    {
      int v52 = v42 | (v34 << v43);
      int v53 = v43 + 5;
    }
    else
    {
      __int16 v47 = v42 | (v34 << v43);
      *((_WORD *)a1 + 2960) = v47;
      uint64_t v48 = *((void *)a1 + 2);
      uint64_t v49 = a1[10];
      a1[10] = v49 + 1;
      *(unsigned char *)(v48 + v49) = v47;
      LOBYTE(v47) = *((unsigned char *)a1 + 5921);
      uint64_t v50 = *((void *)a1 + 2);
      uint64_t v51 = a1[10];
      a1[10] = v51 + 1;
      *(unsigned char *)(v50 + v51) = v47;
      LODWORD(v50) = a1[1481];
      int v52 = (unsigned __int16)v34 >> (16 - v50);
      int v53 = v50 - 11;
    }
    a1[1481] = v53;
    unsigned int v54 = v11 + 65533;
    if (v53 < 13)
    {
      int v60 = v52 | (v54 << v53);
      *((_WORD *)a1 + 2960) = v60;
      int v61 = v53 + 4;
    }
    else
    {
      __int16 v55 = v52 | (v54 << v53);
      *((_WORD *)a1 + 2960) = v55;
      uint64_t v56 = *((void *)a1 + 2);
      uint64_t v57 = a1[10];
      a1[10] = v57 + 1;
      *(unsigned char *)(v56 + v57) = v55;
      LOBYTE(v55) = *((unsigned char *)a1 + 5921);
      uint64_t v58 = *((void *)a1 + 2);
      uint64_t v59 = a1[10];
      a1[10] = v59 + 1;
      *(unsigned char *)(v58 + v59) = v55;
      LODWORD(v58) = a1[1481];
      int v60 = (unsigned __int16)(v11 - 3) >> (16 - v58);
      *((_WORD *)a1 + 2960) = v60;
      int v61 = v58 - 12;
    }
    a1[1481] = v61;
    if ((v11 & 0x80000000) == 0)
    {
      uint64_t v62 = v11 + 1;
      char v63 = bl_order;
      do
      {
        int v64 = *v63++;
        unsigned int v65 = HIWORD(a1[v64 + 683]);
        v60 |= v65 << v61;
        *((_WORD *)a1 + 2960) = v60;
        if (v61 < 14)
        {
          v61 += 3;
        }
        else
        {
          uint64_t v66 = *((void *)a1 + 2);
          uint64_t v67 = a1[10];
          a1[10] = v67 + 1;
          *(unsigned char *)(v66 + v67) = v60;
          char v68 = *((unsigned char *)a1 + 5921);
          uint64_t v69 = *((void *)a1 + 2);
          uint64_t v70 = a1[10];
          a1[10] = v70 + 1;
          *(unsigned char *)(v69 + v70) = v68;
          LODWORD(v69) = a1[1481];
          int v60 = v65 >> (16 - v69);
          *((_WORD *)a1 + 2960) = v60;
          int v61 = v69 - 13;
        }
        a1[1481] = v61;
        --v62;
      }
      while (v62);
    }
    send_tree((uint64_t)a1, (uint64_t)(a1 + 49), v33);
    send_tree((uint64_t)a1, (uint64_t)(a1 + 622), v34);
    uint64_t v46 = (uint64_t)a1;
    uint64_t v44 = a1 + 49;
    uint64_t v45 = a1 + 622;
  }
  compress_block(v46, (uint64_t)v44, (uint64_t)v45);
LABEL_50:
  init_block((uint64_t)a1);
  if (a4)
  {
    bi_windup((uint64_t)a1);
  }
}

uint64_t build_tree(uint64_t a1, uint64_t a2)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *(uint64_t **)(a2 + 16);
  uint64_t v6 = *v5;
  uint64_t v7 = *((unsigned int *)v5 + 5);
  uint64_t v8 = (int *)(a1 + 5284);
  *(void *)(a1 + 5284) = 0x23D00000000;
  if ((int)v7 < 1)
  {
    int v13 = 0;
    int v11 = -1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = (_WORD *)(v4 + 2);
    int v11 = -1;
    do
    {
      if (*(v10 - 1))
      {
        uint64_t v12 = *(int *)(a1 + 5284) + 1;
        *(_DWORD *)(a1 + 5284) = v12;
        *(_DWORD *)(a1 + 4 * v12 + 2992) = v9;
        *(unsigned char *)(a1 + 5292 + v9) = 0;
        int v11 = v9;
      }
      else
      {
        *int v10 = 0;
      }
      v10 += 2;
      ++v9;
    }
    while (v7 != v9);
    int v13 = *v8;
    if (*v8 > 1) {
      goto LABEL_20;
    }
  }
  int v14 = v11;
  do
  {
    if (v14 >= 2) {
      int v11 = v14;
    }
    else {
      int v11 = v14 + 1;
    }
    if (v14 < 2) {
      int v15 = v14 + 1;
    }
    else {
      int v15 = 0;
    }
    uint64_t v16 = v13 + 1;
    *(_DWORD *)(a1 + 5284) = v16;
    *(_DWORD *)(a1 + 4 * v16 + 2992) = v15;
    *(_WORD *)(v4 + 4 * v15) = 1;
    *(unsigned char *)(a1 + v15 + 5292) = 0;
    --*(void *)(a1 + 5896);
    if (v6) {
      *(void *)(a1 + 5904) -= *(unsigned __int16 *)(v6 + 4 * v15 + 2);
    }
    int v13 = *v8;
    int v14 = v11;
  }
  while (*v8 < 2);
LABEL_20:
  *(_DWORD *)(a2 + 8) = v11;
  int v17 = v13 >> 1;
  do
  {
    pqdownheap(a1, v4, v17);
    BOOL v18 = v17-- != 0;
  }
  while (v17 != 0 && v18);
  int v19 = *(_DWORD *)(a1 + 5284);
  uint64_t v20 = (int)v7;
  uint64_t v21 = 4 * (int)v7;
  do
  {
    uint64_t v22 = *(int *)(a1 + 2996);
    *(_DWORD *)(a1 + 5284) = v19 - 1;
    uint64_t v23 = a1 + 2992;
    *(_DWORD *)(a1 + 2996) = *(_DWORD *)(a1 + 2992 + 4 * v19);
    pqdownheap(a1, v4, 1);
    uint64_t v24 = *(int *)(a1 + 2996);
    uint64_t v25 = *(int *)(a1 + 5288) - 1;
    *(_DWORD *)(a1 + 5288) = v25;
    *(_DWORD *)(v23 + 4 * v25) = v22;
    uint64_t v26 = *(int *)(a1 + 5288) - 1;
    *(_DWORD *)(a1 + 5288) = v26;
    *(_DWORD *)(v23 + 4 * v26) = v24;
    uint64_t v27 = (_WORD *)(v4 + 4 * v22);
    uint64_t v28 = (_WORD *)(v4 + 4 * v24);
    *(_WORD *)(v4 + v21) = *v28 + *v27;
    unsigned int v29 = *(unsigned __int8 *)(a1 + 5292 + v24);
    if (*(unsigned __int8 *)(a1 + 5292 + v22) > v29) {
      LOBYTE(v29) = *(unsigned char *)(a1 + 5292 + v22);
    }
    *(unsigned char *)(a1 + 5292 + v20) = v29 + 1;
    v28[1] = v20;
    v27[1] = v20;
    *(_DWORD *)(a1 + 2996) = v20;
    uint64_t result = pqdownheap(a1, v4, 1);
    int v19 = *(_DWORD *)(a1 + 5284);
    v21 += 4;
    ++v20;
  }
  while (v19 > 1);
  int v31 = *(_DWORD *)(a1 + 2996);
  uint64_t v32 = *(int *)(a1 + 5288) - 1;
  *(_DWORD *)(a1 + 5288) = v32;
  *(_DWORD *)(v23 + 4 * v32) = v31;
  uint64_t v33 = *(void *)a2;
  int v34 = *(_DWORD *)(a2 + 8);
  int v35 = *(uint64_t **)(a2 + 16);
  uint64_t v36 = *v35;
  uint64_t v37 = v35[1];
  int v38 = *((_DWORD *)v35 + 4);
  uint64_t v39 = *((int *)v35 + 6);
  *(_OWORD *)(a1 + 2976) = 0u;
  *(_OWORD *)(a1 + 2960) = 0u;
  *(_WORD *)(v33 + 4 * *(int *)(v23 + 4 * *(int *)(a1 + 5288)) + 2) = 0;
  uint64_t v40 = *(int *)(a1 + 5288);
  if ((int)v40 <= 571)
  {
    int v41 = 0;
    do
    {
      uint64_t v42 = *(int *)(a1 + 2996 + 4 * v40);
      uint64_t result = v33 + 4 * v42;
      int v43 = *(unsigned __int16 *)(v33 + 4 * *(unsigned __int16 *)(result + 2) + 2);
      BOOL v44 = (int)v39 <= v43;
      if ((int)v39 > v43) {
        int v45 = v43 + 1;
      }
      else {
        int v45 = v39;
      }
      if (v44) {
        ++v41;
      }
      *(_WORD *)(result + 2) = v45;
      if ((int)v42 <= v34)
      {
        ++*(_WORD *)(a1 + 2 * v45 + 2960);
        int v46 = (int)v42 >= v38 ? *(_DWORD *)(v37 + 4 * ((int)v42 - v38)) : 0;
        uint64_t result = *(unsigned __int16 *)result;
        *(void *)(a1 + 5896) += (int)result * (uint64_t)(v46 + v45);
        if (v36) {
          *(void *)(a1 + 5904) += (*(unsigned __int16 *)(v36 + 4 * v42 + 2) + (uint64_t)v46) * result;
        }
      }
    }
    while (v40++ != 571);
    if (v41)
    {
      do
      {
        uint64_t v48 = (_WORD *)(a1 + 2 * v39 + 2960);
        uint64_t v49 = (v39 << 32) + 0x100000000;
        do
        {
          int v51 = (unsigned __int16)*--v48;
          __int16 v50 = v51;
          v49 -= 0x100000000;
        }
        while (!v51);
        *uint64_t v48 = v50 - 1;
        *(_WORD *)(a1 + (v49 >> 31) + 2960) += 2;
        --*(_WORD *)(a1 + 2 * v39 + 2960);
        BOOL v52 = __OFSUB__(v41, 2);
        v41 -= 2;
      }
      while (!((v41 < 0) ^ v52 | (v41 == 0)));
      if (v39)
      {
        int v53 = 573;
        do
        {
          int v54 = *(unsigned __int16 *)(a1 + 2 * v39 + 2960);
          if (*(_WORD *)(a1 + 2 * v39 + 2960))
          {
            do
            {
              __int16 v55 = (int *)(a1 + 2988 + 4 * v53);
              do
              {
                uint64_t v57 = *v55--;
                uint64_t v56 = v57;
                --v53;
              }
              while ((int)v57 > v34);
              uint64_t v58 = v33 + 4 * v56;
              unsigned int v61 = *(unsigned __int16 *)(v58 + 2);
              uint64_t v59 = (_WORD *)(v58 + 2);
              uint64_t v60 = v61;
              if (v39 != v61)
              {
                *(void *)(a1 + 5896) += (v39 - v60) * *(unsigned __int16 *)(v33 + 4 * v56);
                *uint64_t v59 = v39;
              }
              --v54;
            }
            while (v54);
          }
          --v39;
        }
        while (v39);
      }
    }
  }
  uint64_t v62 = 0;
  unsigned __int16 v63 = 0;
  do
  {
    unsigned __int16 v63 = 2 * ((v63 & 0xFFFE) + *(_WORD *)(a1 + 2960 + v62 * 2));
    v71[++v62] = v63;
  }
  while (v62 != 15);
  if ((v11 & 0x80000000) == 0)
  {
    uint64_t v64 = 0;
    do
    {
      uint64_t v65 = v4 + 4 * v64;
      int v66 = *(unsigned __int16 *)(v65 + 2);
      if (*(_WORD *)(v65 + 2))
      {
        int v67 = 0;
        unsigned int v68 = v71[*(unsigned __int16 *)(v65 + 2)];
        v71[v66] = v68 + 1;
        unsigned int v69 = v66 + 1;
        do
        {
          int v70 = v67 | v68 & 1;
          v68 >>= 1;
          int v67 = 2 * v70;
          --v69;
        }
        while (v69 > 1);
        *(_WORD *)(v4 + 4 * v64) = v70;
      }
      ++v64;
    }
    while (v64 != v11 + 1);
  }
  return result;
}

uint64_t pqdownheap(uint64_t result, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(result + 4 * a3 + 2992);
  int v4 = 2 * a3;
  int v5 = *(_DWORD *)(result + 5284);
  if (2 * a3 <= v5)
  {
    uint64_t v7 = result + 5292;
    while (1)
    {
      if (v4 >= v5)
      {
        int v6 = v4;
        uint64_t v8 = v4;
      }
      else
      {
        uint64_t v8 = v4;
        uint64_t v9 = *(int *)(result + 2992 + 4 * (v4 | 1));
        unsigned int v10 = *(unsigned __int16 *)(a2 + 4 * v9);
        uint64_t v11 = *(int *)(result + 2992 + 4 * v4);
        unsigned int v12 = *(unsigned __int16 *)(a2 + 4 * v11);
        if (v10 >= v12)
        {
          if (v10 != v12)
          {
            int v6 = v4;
            goto LABEL_11;
          }
          unsigned int v13 = *(unsigned __int8 *)(v7 + v9);
          int v6 = v4;
          if (v13 > *(unsigned __int8 *)(v7 + v11)) {
            goto LABEL_11;
          }
        }
        uint64_t v8 = v4 | 1;
        int v6 = v4 | 1;
      }
LABEL_11:
      unsigned int v14 = *(unsigned __int16 *)(a2 + 4 * v3);
      int v15 = *(_DWORD *)(result + 4 * v8 + 2992);
      unsigned int v16 = *(unsigned __int16 *)(a2 + 4 * v15);
      if (v14 < v16
        || v14 == v16
        && *(unsigned __int8 *)(result + v3 + 5292) <= *(unsigned __int8 *)(result + v15 + 5292))
      {
        break;
      }
      *(_DWORD *)(result + 4 * a3 + 2992) = v15;
      int v4 = 2 * v6;
      int v5 = *(_DWORD *)(result + 5284);
      a3 = v6;
      if (2 * v6 > v5) {
        goto LABEL_15;
      }
    }
  }
  int v6 = a3;
LABEL_15:
  *(_DWORD *)(result + 4 * v6 + 2992) = v3;
  return result;
}

uint64_t send_tree(uint64_t result, uint64_t a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v3 = 0;
    int v4 = 0;
    unsigned int v5 = *(unsigned __int16 *)(a2 + 2);
    if (*(_WORD *)(a2 + 2)) {
      int v6 = 7;
    }
    else {
      int v6 = 138;
    }
    if (*(_WORD *)(a2 + 2)) {
      int v7 = 4;
    }
    else {
      int v7 = 3;
    }
    int v8 = -1;
    do
    {
      ++v3;
      unsigned int v9 = *(unsigned __int16 *)(a2 + 4 * v3 + 2);
      int v10 = v4 + 1;
      if (v4 + 1 >= v6 || v5 != v9)
      {
        if (v10 >= v7)
        {
          int v23 = *(_DWORD *)(result + 5924);
          if (v5)
          {
            if (v5 != v8)
            {
              uint64_t v24 = result + 4 * v5;
              int v25 = *(unsigned __int16 *)(v24 + 2734);
              unsigned int v26 = *(unsigned __int16 *)(v24 + 2732);
              int v27 = *(unsigned __int16 *)(result + 5920);
              int v28 = v27 | (v26 << v23);
              *(_WORD *)(result + 5920) = v27 | ((_WORD)v26 << v23);
              if (v23 <= 16 - v25)
              {
                v23 += v25;
              }
              else
              {
                uint64_t v29 = *(void *)(result + 16);
                uint64_t v30 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v30 + 1;
                *(unsigned char *)(v29 + v30) = v28;
                LOBYTE(v29) = *(unsigned char *)(result + 5921);
                uint64_t v31 = *(void *)(result + 16);
                uint64_t v32 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v32 + 1;
                *(unsigned char *)(v31 + v32) = v29;
                LODWORD(v29) = *(_DWORD *)(result + 5924);
                *(_WORD *)(result + 5920) = v26 >> (16 - v29);
                int v23 = v25 + v29 - 16;
              }
              *(_DWORD *)(result + 5924) = v23;
              int v10 = v4;
            }
            int v52 = *(unsigned __int16 *)(result + 2798);
            unsigned int v53 = *(unsigned __int16 *)(result + 2796);
            int v54 = *(unsigned __int16 *)(result + 5920) | (v53 << v23);
            if (v23 <= 16 - v52)
            {
              int v60 = v23 + v52;
            }
            else
            {
              *(_WORD *)(result + 5920) = v54;
              uint64_t v55 = *(void *)(result + 16);
              uint64_t v56 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v56 + 1;
              *(unsigned char *)(v55 + v56) = v54;
              char v57 = *(unsigned char *)(result + 5921);
              uint64_t v58 = *(void *)(result + 16);
              uint64_t v59 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v59 + 1;
              *(unsigned char *)(v58 + v59) = v57;
              LODWORD(v58) = *(_DWORD *)(result + 5924);
              int v54 = v53 >> (16 - v58);
              int v60 = v52 + v58 - 16;
            }
            *(_DWORD *)(result + 5924) = v60;
            int v61 = v10 + 65533;
            if (v60 < 15)
            {
              *(_WORD *)(result + 5920) = v54 | (v61 << v60);
              int v69 = v60 + 2;
            }
            else
            {
              __int16 v62 = v54 | (v61 << v60);
              *(_WORD *)(result + 5920) = v62;
              uint64_t v63 = *(void *)(result + 16);
              uint64_t v64 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v64 + 1;
              *(unsigned char *)(v63 + v64) = v62;
              LOBYTE(v62) = *(unsigned char *)(result + 5921);
              uint64_t v65 = *(void *)(result + 16);
              uint64_t v66 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v66 + 1;
              *(unsigned char *)(v65 + v66) = v62;
              unsigned int v67 = (unsigned __int16)v61;
              int v68 = *(_DWORD *)(result + 5924);
              *(_WORD *)(result + 5920) = v67 >> (16 - v68);
              int v69 = v68 - 14;
            }
          }
          else
          {
            int v33 = *(unsigned __int16 *)(result + 5920);
            if (v4 > 9)
            {
              int v43 = *(unsigned __int16 *)(result + 2806);
              unsigned int v44 = *(unsigned __int16 *)(result + 2804);
              int v45 = v33 | (v44 << v23);
              if (v23 <= 16 - v43)
              {
                int v51 = v23 + v43;
              }
              else
              {
                *(_WORD *)(result + 5920) = v45;
                uint64_t v46 = *(void *)(result + 16);
                uint64_t v47 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v47 + 1;
                *(unsigned char *)(v46 + v47) = v45;
                char v48 = *(unsigned char *)(result + 5921);
                uint64_t v49 = *(void *)(result + 16);
                uint64_t v50 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v50 + 1;
                *(unsigned char *)(v49 + v50) = v48;
                LODWORD(v49) = *(_DWORD *)(result + 5924);
                int v45 = v44 >> (16 - v49);
                int v51 = v43 + v49 - 16;
              }
              *(_DWORD *)(result + 5924) = v51;
              int v78 = v4 + 65526;
              int v79 = v78 << v51;
              if (v51 < 10)
              {
                *(_WORD *)(result + 5920) = v45 | v79;
                int v69 = v51 + 7;
              }
              else
              {
                __int16 v80 = v45 | v79;
                *(_WORD *)(result + 5920) = v80;
                uint64_t v81 = *(void *)(result + 16);
                uint64_t v82 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v82 + 1;
                *(unsigned char *)(v81 + v82) = v80;
                LOBYTE(v80) = *(unsigned char *)(result + 5921);
                uint64_t v83 = *(void *)(result + 16);
                uint64_t v84 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v84 + 1;
                *(unsigned char *)(v83 + v84) = v80;
                int v85 = *(_DWORD *)(result + 5924);
                *(_WORD *)(result + 5920) = (unsigned __int16)v78 >> (16 - v85);
                int v69 = v85 - 9;
              }
            }
            else
            {
              int v34 = *(unsigned __int16 *)(result + 2802);
              unsigned int v35 = *(unsigned __int16 *)(result + 2800);
              int v36 = v33 | (v35 << v23);
              if (v23 <= 16 - v34)
              {
                int v42 = v23 + v34;
              }
              else
              {
                *(_WORD *)(result + 5920) = v36;
                uint64_t v37 = *(void *)(result + 16);
                uint64_t v38 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v38 + 1;
                *(unsigned char *)(v37 + v38) = v36;
                char v39 = *(unsigned char *)(result + 5921);
                uint64_t v40 = *(void *)(result + 16);
                uint64_t v41 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v41 + 1;
                *(unsigned char *)(v40 + v41) = v39;
                LODWORD(v40) = *(_DWORD *)(result + 5924);
                int v36 = v35 >> (16 - v40);
                int v42 = v34 + v40 - 16;
              }
              *(_DWORD *)(result + 5924) = v42;
              int v70 = v4 + 65534;
              int v71 = v70 << v42;
              if (v42 < 14)
              {
                *(_WORD *)(result + 5920) = v36 | v71;
                int v69 = v42 + 3;
              }
              else
              {
                __int16 v72 = v36 | v71;
                *(_WORD *)(result + 5920) = v72;
                uint64_t v73 = *(void *)(result + 16);
                uint64_t v74 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v74 + 1;
                *(unsigned char *)(v73 + v74) = v72;
                LOBYTE(v72) = *(unsigned char *)(result + 5921);
                uint64_t v75 = *(void *)(result + 16);
                uint64_t v76 = *(unsigned int *)(result + 40);
                *(_DWORD *)(result + 40) = v76 + 1;
                *(unsigned char *)(v75 + v76) = v72;
                int v77 = *(_DWORD *)(result + 5924);
                *(_WORD *)(result + 5920) = (unsigned __int16)v70 >> (16 - v77);
                int v69 = v77 - 13;
              }
            }
          }
          *(_DWORD *)(result + 5924) = v69;
        }
        else
        {
          uint64_t v11 = result + 4 * v5;
          unsigned int v12 = (unsigned __int16 *)(v11 + 2732);
          unsigned int v13 = (unsigned __int16 *)(v11 + 2734);
          int v14 = *(_DWORD *)(result + 5924);
          do
          {
            int v15 = *v13;
            unsigned int v16 = *v12;
            int v17 = *(unsigned __int16 *)(result + 5920);
            int v18 = v17 | (v16 << v14);
            *(_WORD *)(result + 5920) = v17 | ((_WORD)v16 << v14);
            if (v14 <= 16 - v15)
            {
              v14 += v15;
            }
            else
            {
              uint64_t v19 = *(void *)(result + 16);
              uint64_t v20 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v20 + 1;
              *(unsigned char *)(v19 + v20) = v18;
              LOBYTE(v19) = *(unsigned char *)(result + 5921);
              uint64_t v21 = *(void *)(result + 16);
              uint64_t v22 = *(unsigned int *)(result + 40);
              *(_DWORD *)(result + 40) = v22 + 1;
              *(unsigned char *)(v21 + v22) = v19;
              LODWORD(v19) = *(_DWORD *)(result + 5924);
              *(_WORD *)(result + 5920) = v16 >> (16 - v19);
              int v14 = v15 + v19 - 16;
            }
            *(_DWORD *)(result + 5924) = v14;
            --v10;
          }
          while (v10);
        }
        if (v5 == v9) {
          int v86 = 3;
        }
        else {
          int v86 = 4;
        }
        if (v5 == v9) {
          int v87 = 6;
        }
        else {
          int v87 = 7;
        }
        if (v9) {
          int v7 = v86;
        }
        else {
          int v7 = 3;
        }
        if (v9) {
          int v6 = v87;
        }
        else {
          int v6 = 138;
        }
        int v10 = 0;
        int v8 = v5;
      }
      unsigned int v5 = v9;
      int v4 = v10;
    }
    while (v3 != a3 + 1);
  }
  return result;
}

_WORD *scan_tree(_WORD *result, uint64_t a2, int a3)
{
  int v3 = *(unsigned __int16 *)(a2 + 2);
  uint64_t v4 = (a3 + 1);
  *(_WORD *)(a2 + 4 * (int)v4 + 2) = -1;
  if ((a3 & 0x80000000) == 0)
  {
    int v5 = 0;
    if (v3) {
      int v6 = 4;
    }
    else {
      int v6 = 3;
    }
    if (v3) {
      int v7 = 7;
    }
    else {
      int v7 = 138;
    }
    int v8 = (unsigned __int16 *)(a2 + 6);
    int v9 = -1;
    do
    {
      int v11 = *v8;
      v8 += 2;
      int v10 = v11;
      int v12 = v5 + 1;
      if (v5 + 1 >= v7 || v3 != v10)
      {
        if (v12 >= v6)
        {
          if (v3)
          {
            if (v3 != v9) {
              ++result[2 * v3 + 1366];
            }
            ++result[1398];
          }
          else if (v5 > 9)
          {
            ++result[1402];
          }
          else
          {
            ++result[1400];
          }
        }
        else
        {
          result[2 * v3 + 1366] += v12;
        }
        if (v3 == v10) {
          int v14 = 6;
        }
        else {
          int v14 = 7;
        }
        if (v3 == v10) {
          int v15 = 3;
        }
        else {
          int v15 = 4;
        }
        int v12 = 0;
        if (v10) {
          int v7 = v14;
        }
        else {
          int v7 = 138;
        }
        if (v10) {
          int v6 = v15;
        }
        else {
          int v6 = 3;
        }
        int v9 = v3;
      }
      int v5 = v12;
      int v3 = v10;
      --v4;
    }
    while (v4);
  }
  return result;
}

double init_block(uint64_t a1)
{
  for (uint64_t i = 196; i != 1340; i += 4)
    *(_WORD *)(a1 + i) = 0;
  for (uint64_t j = 0; j != 120; j += 4)
    *(_WORD *)(a1 + 2488 + j) = 0;
  for (uint64_t k = 0; k != 76; k += 4)
    *(_WORD *)(a1 + 2732 + k) = 0;
  *(_WORD *)(a1 + 1220) = 1;
  *(_DWORD *)(a1 + 5884) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 5896) = 0u;
  *(_DWORD *)(a1 + 5912) = 0;
  return result;
}

uint64_t compress_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(result + 5884))
  {
    uint64_t v3 = 0;
    while (1)
    {
      unsigned int v4 = *(unsigned __int16 *)(*(void *)(result + 5888) + 2 * v3);
      uint64_t v5 = *(unsigned __int8 *)(*(void *)(result + 5872) + v3);
      if (*(_WORD *)(*(void *)(result + 5888) + 2 * v3)) {
        break;
      }
      uint64_t v19 = (unsigned __int16 *)(a2 + 4 * v5);
      int v20 = v19[1];
      int v21 = *(_DWORD *)(result + 5924);
      unsigned int v22 = *v19;
      int v23 = *(unsigned __int16 *)(result + 5920);
      int v24 = v23 | (v22 << v21);
      *(_WORD *)(result + 5920) = v23 | ((_WORD)v22 << v21);
      if (v21 > 16 - v20)
      {
        uint64_t v25 = *(void *)(result + 16);
        uint64_t v26 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v26 + 1;
        *(unsigned char *)(v25 + v26) = v24;
        char v27 = *(unsigned char *)(result + 5921);
        uint64_t v28 = *(void *)(result + 16);
        uint64_t v29 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v29 + 1;
        *(unsigned char *)(v28 + v29) = v27;
        int v30 = *(_DWORD *)(result + 5924);
        *(_WORD *)(result + 5920) = v22 >> (16 - v30);
        int v31 = v20 + v30;
LABEL_24:
        int v40 = v31 - 16;
        goto LABEL_26;
      }
      int v40 = v21 + v20;
LABEL_26:
      *(_DWORD *)(result + 5924) = v40;
LABEL_27:
      if (++v3 >= (unint64_t)*(unsigned int *)(result + 5884)) {
        goto LABEL_30;
      }
    }
    uint64_t v6 = _length_code[v5];
    uint64_t v7 = a2 + 4 * v6;
    int v8 = *(unsigned __int16 *)(v7 + 1030);
    int v9 = *(_DWORD *)(result + 5924);
    unsigned int v10 = *(unsigned __int16 *)(v7 + 1028);
    int v11 = *(unsigned __int16 *)(result + 5920);
    int v12 = v11 | (v10 << v9);
    *(_WORD *)(result + 5920) = v11 | ((_WORD)v10 << v9);
    if (v9 <= 16 - v8)
    {
      int v18 = v9 + v8;
    }
    else
    {
      uint64_t v13 = *(void *)(result + 16);
      uint64_t v14 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v14 + 1;
      *(unsigned char *)(v13 + v14) = v12;
      char v15 = *(unsigned char *)(result + 5921);
      uint64_t v16 = *(void *)(result + 16);
      uint64_t v17 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v17 + 1;
      *(unsigned char *)(v16 + v17) = v15;
      LODWORD(v16) = *(_DWORD *)(result + 5924);
      int v12 = v10 >> (16 - v16);
      *(_WORD *)(result + 5920) = v12;
      int v18 = v8 + v16 - 16;
    }
    *(_DWORD *)(result + 5924) = v18;
    if ((unint64_t)(v6 - 28) >= 0xFFFFFFFFFFFFFFECLL)
    {
      int v32 = extra_lbits[v6];
      int v33 = v5 - base_length[v6];
      if (v18 <= 16 - v32)
      {
        v12 |= v33 << v18;
        *(_WORD *)(result + 5920) = v12;
        v18 += v32;
      }
      else
      {
        unsigned int v34 = (unsigned __int16)v33;
        __int16 v35 = v12 | (v33 << v18);
        *(_WORD *)(result + 5920) = v35;
        uint64_t v36 = *(void *)(result + 16);
        uint64_t v37 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v37 + 1;
        *(unsigned char *)(v36 + v37) = v35;
        LOBYTE(v35) = *(unsigned char *)(result + 5921);
        uint64_t v38 = *(void *)(result + 16);
        uint64_t v39 = *(unsigned int *)(result + 40);
        *(_DWORD *)(result + 40) = v39 + 1;
        *(unsigned char *)(v38 + v39) = v35;
        LODWORD(v38) = *(_DWORD *)(result + 5924);
        int v12 = v34 >> (16 - v38);
        *(_WORD *)(result + 5920) = v12;
        int v18 = v32 + v38 - 16;
      }
      *(_DWORD *)(result + 5924) = v18;
    }
    unsigned int v41 = v4 - 1;
    if (v4 >= 0x101) {
      unsigned int v42 = ((v4 - 1) >> 7) + 256;
    }
    else {
      unsigned int v42 = v4 - 1;
    }
    uint64_t v43 = _dist_code[v42];
    unsigned int v44 = (unsigned __int16 *)(a3 + 4 * v43);
    int v45 = v44[1];
    unsigned int v46 = *v44;
    int v47 = v12 | (v46 << v18);
    *(_WORD *)(result + 5920) = v47;
    if (v18 <= 16 - v45)
    {
      int v40 = v18 + v45;
    }
    else
    {
      uint64_t v48 = *(void *)(result + 16);
      uint64_t v49 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v49 + 1;
      *(unsigned char *)(v48 + v49) = v47;
      char v50 = *(unsigned char *)(result + 5921);
      uint64_t v51 = *(void *)(result + 16);
      uint64_t v52 = *(unsigned int *)(result + 40);
      *(_DWORD *)(result + 40) = v52 + 1;
      *(unsigned char *)(v51 + v52) = v50;
      LODWORD(v51) = *(_DWORD *)(result + 5924);
      int v47 = v46 >> (16 - v51);
      *(_WORD *)(result + 5920) = v47;
      int v40 = v45 + v51 - 16;
    }
    *(_DWORD *)(result + 5924) = v40;
    if (v43 < 4) {
      goto LABEL_27;
    }
    int v53 = extra_dbits[v43];
    unsigned int v54 = v41 - base_dist[v43];
    if (v40 <= 16 - v53)
    {
      *(_WORD *)(result + 5920) = v47 | ((_WORD)v54 << v40);
      v40 += v53;
      goto LABEL_26;
    }
    unsigned int v55 = (unsigned __int16)v54;
    __int16 v56 = v47 | (v54 << v40);
    *(_WORD *)(result + 5920) = v56;
    uint64_t v57 = *(void *)(result + 16);
    uint64_t v58 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v58 + 1;
    *(unsigned char *)(v57 + v58) = v56;
    LOBYTE(v56) = *(unsigned char *)(result + 5921);
    uint64_t v59 = *(void *)(result + 16);
    uint64_t v60 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v60 + 1;
    *(unsigned char *)(v59 + v60) = v56;
    int v61 = *(_DWORD *)(result + 5924);
    *(_WORD *)(result + 5920) = v55 >> (16 - v61);
    int v31 = v53 + v61;
    goto LABEL_24;
  }
  int v40 = *(_DWORD *)(result + 5924);
LABEL_30:
  int v62 = *(unsigned __int16 *)(a2 + 1026);
  unsigned int v63 = *(unsigned __int16 *)(a2 + 1024);
  int v64 = *(unsigned __int16 *)(result + 5920);
  int v65 = v64 | (v63 << v40);
  *(_WORD *)(result + 5920) = v64 | ((_WORD)v63 << v40);
  if (v40 <= 16 - v62)
  {
    int v72 = v40 + v62;
  }
  else
  {
    uint64_t v66 = *(void *)(result + 16);
    uint64_t v67 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v67 + 1;
    *(unsigned char *)(v66 + v67) = v65;
    char v68 = *(unsigned char *)(result + 5921);
    uint64_t v69 = *(void *)(result + 16);
    uint64_t v70 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v70 + 1;
    *(unsigned char *)(v69 + v70) = v68;
    int v71 = *(_DWORD *)(result + 5924);
    *(_WORD *)(result + 5920) = v63 >> (16 - v71);
    int v72 = v62 + v71 - 16;
  }
  *(_DWORD *)(result + 5924) = v72;
  *(_DWORD *)(result + 5916) = *(unsigned __int16 *)(a2 + 1026);
  return result;
}

uint64_t SafeProcessCommands(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 76);
  LODWORD(v3) = *(_DWORD *)(a1 + 4);
  unsigned int v4 = (unint64_t *)(a1 + 8);
  switch(*(_DWORD *)a1)
  {
    case 7:
      goto LABEL_4;
    case 8:
      goto LABEL_34;
    case 9:
      goto LABEL_77;
    case 0xA:
      uint64_t v5 = v2;
      break;
    default:
      return 4294967265;
  }
LABEL_136:
  uint64_t v129 = 0;
  int v130 = *(_DWORD *)(a1 + 88) - v2;
  while (1)
  {
    BOOL v131 = __OFSUB__(v3, 1);
    LODWORD(v3) = v3 - 1;
    if (((v3 & 0x80000000) != 0) != v131) {
      break;
    }
    *(unsigned char *)(v5 + v129 + *(void *)(a1 + 120)) = *(unsigned char *)(*(void *)(a1 + 120)
                                                             + (((int)v5 + (int)v129 - *(_DWORD *)(a1 + 360)) & *(_DWORD *)(a1 + 92)));
    if (v130 == ++v129)
    {
      int v2 = v5 + v129;
      int v132 = 16;
      goto LABEL_159;
    }
  }
  int v2 = v5 + v129;
  if (*(int *)(a1 + 264) < 1)
  {
    *(_DWORD *)a1 = 14;
    uint64_t result = 1;
    goto LABEL_152;
  }
LABEL_4:
  while (1)
  {
    *(_DWORD *)a1 = 7;
    if (*(_DWORD *)(a1 + 276)) {
      break;
    }
    if (!SafeDecodeCommandBlockSwitch(a1)) {
      goto LABEL_151;
    }
  }
  unsigned int v133 = 0;
  unint64_t v7 = *(void *)(a1 + 8);
  int v8 = *(_DWORD *)(a1 + 16);
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  int v11 = *(unsigned char **)(a1 + 136);
  unint64_t v12 = v7;
  int v13 = v8;
  if ((v8 - 50) > 0xE)
  {
LABEL_11:
    unint64_t v19 = v12 >> v13;
    int v20 = &v11[4 * (v12 >> v13)];
    unsigned int v21 = *v20;
    if (v21 >= 9)
    {
      v13 += 8;
      v20 += 4 * (BYTE1(v19) & ~(-1 << (v21 - 8)) & 0x7F)
           + 4 * *(unsigned __int16 *)&v11[4 * v19 + 2];
      unsigned int v21 = *v20;
    }
    *(_DWORD *)(a1 + 16) = v13 + v21;
    unsigned int v22 = *((unsigned __int16 *)v20 + 1);
    unsigned int v133 = v22;
  }
  else
  {
    uint64_t v14 = v9 + 1;
    uint64_t v15 = v10 - 1;
    unint64_t v12 = *(void *)(a1 + 8);
    int v16 = *(_DWORD *)(a1 + 16);
    while (v15 != -1)
    {
      *(void *)(a1 + 8) = v12 >> 8;
      *((void *)&v17 + 1) = *(unsigned __int8 *)(v14 - 1);
      *(void *)&long long v17 = v12;
      unint64_t v12 = v17 >> 8;
      *(void *)(a1 + 8) = v12;
      int v13 = v16 - 8;
      *(_DWORD *)(a1 + 16) = v16 - 8;
      *(void *)(a1 + 24) = v14;
      *(void *)(a1 + 32) = v15;
      ++v14;
      --v15;
      unsigned int v18 = v16 - 58;
      v16 -= 8;
      if (v18 >= 0xF) {
        goto LABEL_11;
      }
    }
    if (!SafeDecodeSymbol(v11, (uint64_t)v4, &v133)) {
      goto LABEL_151;
    }
    unsigned int v22 = v133;
  }
  int v23 = 0;
  int v24 = (unsigned __int8 *)&kCmdLut + 8 * v22;
  unsigned int v25 = *v24;
  unsigned int v26 = v24[1];
  int v27 = (char)v24[2];
  uint64_t v28 = v24[3];
  LODWORD(v3) = *((unsigned __int16 *)v24 + 2);
  int v29 = *((unsigned __int16 *)v24 + 3);
  *(_DWORD *)(a1 + 360) = v27;
  *(_DWORD *)(a1 + 260) = v28;
  *(unsigned char *)(a1 + 352) = *(unsigned char *)(*(void *)(a1 + 160) + v28);
  if (v25)
  {
    int v30 = *(_DWORD *)(a1 + 16);
    unsigned int v31 = 64 - v30;
    if (64 - v30 < v25)
    {
      uint64_t v32 = *(void *)(a1 + 32) - 1;
      while (v32 != -1)
      {
        unint64_t v33 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v33 >> 8;
        unsigned int v34 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v36 + 1) = *v34;
        *(void *)&long long v36 = v33;
        unint64_t v35 = v36 >> 8;
        *(void *)(a1 + 8) = v35;
        v30 -= 8;
        *(_DWORD *)(a1 + 16) = v30;
        *(void *)(a1 + 24) = v34 + 1;
        *(void *)(a1 + 32) = v32--;
        v31 += 8;
        if (v31 >= v25) {
          goto LABEL_23;
        }
      }
      goto LABEL_150;
    }
    unint64_t v35 = *v4;
LABEL_23:
    int v23 = (v35 >> v30) & ~(-1 << v25);
    *(_DWORD *)(a1 + 16) = v30 + v25;
  }
  int v37 = 0;
  if (v26)
  {
    int v38 = *(_DWORD *)(a1 + 16);
    unsigned int v39 = 64 - v38;
    if (64 - v38 < v26)
    {
      uint64_t v40 = *(void *)(a1 + 32) - 1;
      while (v40 != -1)
      {
        unint64_t v41 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v41 >> 8;
        unsigned int v42 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v44 + 1) = *v42;
        *(void *)&long long v44 = v41;
        unint64_t v43 = v44 >> 8;
        *(void *)(a1 + 8) = v43;
        v38 -= 8;
        *(_DWORD *)(a1 + 16) = v38;
        *(void *)(a1 + 24) = v42 + 1;
        *(void *)(a1 + 32) = v40--;
        v39 += 8;
        if (v39 >= v26) {
          goto LABEL_31;
        }
      }
      goto LABEL_150;
    }
    unint64_t v43 = *v4;
LABEL_31:
    int v37 = (v43 >> v38) & ~(-1 << v26);
    *(_DWORD *)(a1 + 16) = v38 + v26;
  }
  *(_DWORD *)(a1 + 356) = v37 + v29;
  --*(_DWORD *)(a1 + 276);
  if (!(v23 + v3))
  {
    LODWORD(v3) = 0;
    goto LABEL_77;
  }
  *(_DWORD *)(a1 + 264) -= v23 + v3;
  LODWORD(v3) = v23 + v3;
LABEL_34:
  int v45 = *(_DWORD *)(a1 + 256);
LABEL_35:
  *(_DWORD *)a1 = 8;
  if (!v45) {
    goto LABEL_55;
  }
  uint64_t v46 = v2;
  int v47 = *(_DWORD *)(a1 + 272);
  while (1)
  {
    if (!v47)
    {
      if (!SafeDecodeLiteralBlockSwitch(a1)) {
        goto LABEL_87;
      }
      if (!*(_DWORD *)(a1 + 256))
      {
        *(_DWORD *)a1 = 8;
        int v2 = v46;
LABEL_55:
        uint64_t v60 = *(void *)(a1 + 120);
        uint64_t v61 = v2;
        uint64_t v62 = *(int *)(a1 + 92);
        uint64_t v63 = *(unsigned __int8 *)(v60 + (v62 & (v2 - 1)));
        uint64_t v64 = *(unsigned __int8 *)(v60 + (v62 & (v2 - 2)));
        int v65 = *(_DWORD *)(a1 + 272);
        while (1)
        {
          uint64_t v46 = v63;
          if (!v65)
          {
            if (!SafeDecodeLiteralBlockSwitch(a1)) {
              goto LABEL_109;
            }
            if (*(_DWORD *)(a1 + 256))
            {
              int v45 = 1;
              int v2 = v61;
              goto LABEL_35;
            }
          }
          uint64_t v66 = *(unsigned char **)(*(void *)(a1 + 168)
                          + 8
                          * *(unsigned __int8 *)(*(void *)(a1 + 152)
                                               + (*(unsigned char *)(*(void *)(a1 + 144) + v64 + 256) | *(unsigned char *)(*(void *)(a1 + 144) + v46))));
          unsigned int v133 = 0;
          int v67 = *(_DWORD *)(a1 + 16);
          if ((v67 - 50) >= 0xF)
          {
            unint64_t v71 = *v4;
LABEL_63:
            unint64_t v74 = v71 >> v67;
            uint64_t v75 = &v66[4 * (v71 >> v67)];
            unsigned int v76 = *v75;
            if (v76 >= 9)
            {
              v67 += 8;
              v75 += 4 * (BYTE1(v74) & ~(-1 << (v76 - 8)) & 0x7F)
                   + 4 * *(unsigned __int16 *)&v66[4 * v74 + 2];
              unsigned int v76 = *v75;
            }
            *(_DWORD *)(a1 + 16) = v67 + v76;
            uint64_t v63 = v75[2];
          }
          else
          {
            uint64_t v68 = *(void *)(a1 + 32) - 1;
            while (v68 != -1)
            {
              unint64_t v69 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v69 >> 8;
              uint64_t v70 = *(unsigned __int8 **)(a1 + 24);
              *((void *)&v72 + 1) = *v70;
              *(void *)&long long v72 = v69;
              unint64_t v71 = v72 >> 8;
              *(void *)(a1 + 8) = v71;
              int v73 = v67 - 8;
              *(_DWORD *)(a1 + 16) = v67 - 8;
              *(void *)(a1 + 24) = v70 + 1;
              *(void *)(a1 + 32) = v68--;
              LODWORD(v70) = v67 - 58;
              v67 -= 8;
              if (v70 >= 0xF)
              {
                int v67 = v73;
                goto LABEL_63;
              }
            }
            if (!SafeDecodeSymbol(v66, (uint64_t)v4, &v133))
            {
LABEL_109:
              uint64_t result = 2;
              int v2 = v61;
              goto LABEL_152;
            }
            uint64_t v63 = v133;
          }
          *(unsigned char *)(*(void *)(a1 + 120) + v61) = v63;
          int v65 = *(_DWORD *)(a1 + 272) - 1;
          *(_DWORD *)(a1 + 272) = v65;
          ++v61;
          int v2 = *(_DWORD *)(a1 + 88);
          if (v2 == v61) {
            goto LABEL_160;
          }
          uint64_t v64 = v46;
          LODWORD(v46) = v61;
          LODWORD(v3) = v3 - 1;
          if (!v3) {
            goto LABEL_74;
          }
        }
      }
    }
    unsigned int v133 = 0;
    uint64_t v48 = *(unsigned char **)(a1 + 344);
    int v49 = *(_DWORD *)(a1 + 16);
    if ((v49 - 50) >= 0xF)
    {
      unint64_t v53 = *v4;
LABEL_44:
      unint64_t v56 = v53 >> v49;
      uint64_t v57 = &v48[4 * (v53 >> v49)];
      unsigned int v58 = *v57;
      if (v58 >= 9)
      {
        v49 += 8;
        v57 += 4 * (BYTE1(v56) & ~(-1 << (v58 - 8)) & 0x7F)
             + 4 * *(unsigned __int16 *)&v48[4 * v56 + 2];
        unsigned int v58 = *v57;
      }
      *(_DWORD *)(a1 + 16) = v49 + v58;
      __int16 v59 = *((_WORD *)v57 + 1);
    }
    else
    {
      uint64_t v50 = *(void *)(a1 + 32) - 1;
      while (v50 != -1)
      {
        unint64_t v51 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v51 >> 8;
        uint64_t v52 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v54 + 1) = *v52;
        *(void *)&long long v54 = v51;
        unint64_t v53 = v54 >> 8;
        *(void *)(a1 + 8) = v53;
        int v55 = v49 - 8;
        *(_DWORD *)(a1 + 16) = v49 - 8;
        *(void *)(a1 + 24) = v52 + 1;
        *(void *)(a1 + 32) = v50--;
        LODWORD(v52) = v49 - 58;
        v49 -= 8;
        if (v52 >= 0xF)
        {
          int v49 = v55;
          goto LABEL_44;
        }
      }
      if (!SafeDecodeSymbol(v48, (uint64_t)v4, &v133))
      {
LABEL_87:
        uint64_t result = 2;
LABEL_88:
        int v2 = v46;
        goto LABEL_152;
      }
      LOBYTE(v59) = v133;
    }
    *(unsigned char *)(*(void *)(a1 + 120) + v46) = v59;
    int v47 = *(_DWORD *)(a1 + 272) - 1;
    *(_DWORD *)(a1 + 272) = v47;
    ++v46;
    int v2 = *(_DWORD *)(a1 + 88);
    if (v2 == v46) {
      break;
    }
    LODWORD(v3) = v3 - 1;
    if (!v3)
    {
LABEL_74:
      if (*(int *)(a1 + 264) <= 0)
      {
        LODWORD(v3) = 0;
        *(_DWORD *)a1 = 14;
        uint64_t result = 1;
        goto LABEL_88;
      }
      LODWORD(v3) = 0;
      int v2 = v46;
LABEL_77:
      *(_DWORD *)a1 = 9;
      int v77 = *(_DWORD *)(a1 + 360);
      if ((v77 & 0x80000000) == 0)
      {
        unsigned int v78 = v77 == 0;
        *(_DWORD *)(a1 + 260) = v78;
        int v79 = *(_DWORD *)(a1 + 96) - 1;
        *(_DWORD *)(a1 + 96) = v79;
        int v80 = *(_DWORD *)(a1 + 4 * (v79 & 3) + 100);
        goto LABEL_113;
      }
      if (!*(_DWORD *)(a1 + 280) && !SafeDecodeDistanceBlockSwitch(a1)) {
        goto LABEL_151;
      }
      uint64_t v81 = a1 + 744;
      unsigned int v133 = 0;
      uint64_t v82 = *(unsigned char **)(*(void *)(a1 + 216) + 8 * *(unsigned __int8 *)(a1 + 352));
      unint64_t v7 = *(void *)(a1 + 8);
      int v8 = *(_DWORD *)(a1 + 16);
      uint64_t v9 = *(void *)(a1 + 24);
      uint64_t v10 = *(void *)(a1 + 32);
      unint64_t v83 = v7;
      int v84 = v8;
      if ((v8 - 50) > 0xE)
      {
LABEL_84:
        unint64_t v90 = v83 >> v84;
        uint64_t v91 = &v82[4 * (v83 >> v84)];
        unsigned int v92 = *v91;
        if (v92 >= 9)
        {
          v84 += 8;
          v91 += 4 * (BYTE1(v90) & ~(-1 << (v92 - 8)) & 0x7F)
               + 4 * *(unsigned __int16 *)&v82[4 * v90 + 2];
          unsigned int v92 = *v91;
        }
        *(_DWORD *)(a1 + 16) = v84 + v92;
        unsigned int v93 = *((unsigned __int16 *)v91 + 1);
      }
      else
      {
        uint64_t v85 = v9 + 1;
        uint64_t v86 = v10 - 1;
        unint64_t v83 = *(void *)(a1 + 8);
        int v87 = *(_DWORD *)(a1 + 16);
        while (v86 != -1)
        {
          *(void *)(a1 + 8) = v83 >> 8;
          *((void *)&v88 + 1) = *(unsigned __int8 *)(v85 - 1);
          *(void *)&long long v88 = v83;
          unint64_t v83 = v88 >> 8;
          *(void *)(a1 + 8) = v83;
          int v84 = v87 - 8;
          *(_DWORD *)(a1 + 16) = v87 - 8;
          *(void *)(a1 + 24) = v85;
          *(void *)(a1 + 32) = v86;
          ++v85;
          --v86;
          unsigned int v89 = v87 - 58;
          v87 -= 8;
          if (v89 >= 0xF) {
            goto LABEL_84;
          }
        }
        if (!SafeDecodeSymbol(v82, (uint64_t)v4, &v133)) {
          goto LABEL_151;
        }
        unsigned int v93 = v133;
      }
      int v94 = *(_DWORD *)(a1 + 280);
      *(_DWORD *)(a1 + 280) = v94 - 1;
      *(_DWORD *)(a1 + 260) = 0;
      if (v93 > 0xF)
      {
        int v96 = 0;
        unsigned int v97 = *(unsigned __int8 *)(v81 + v93);
        if (*(unsigned char *)(v81 + v93))
        {
          int v98 = *(_DWORD *)(a1 + 16);
          unsigned int v99 = 64 - v98;
          if (64 - v98 < v97)
          {
            uint64_t v100 = *(void *)(a1 + 32) - 1;
            while (v100 != -1)
            {
              unint64_t v101 = *(void *)(a1 + 8);
              *(void *)(a1 + 8) = v101 >> 8;
              unsigned int v102 = *(unsigned __int8 **)(a1 + 24);
              *((void *)&v104 + 1) = *v102;
              *(void *)&long long v104 = v101;
              unint64_t v103 = v104 >> 8;
              *(void *)(a1 + 8) = v103;
              v98 -= 8;
              *(_DWORD *)(a1 + 16) = v98;
              *(void *)(a1 + 24) = v102 + 1;
              *(void *)(a1 + 32) = v100--;
              v99 += 8;
              if (v99 >= v97) {
                goto LABEL_111;
              }
            }
            *(_DWORD *)(a1 + 280) = v94;
LABEL_150:
            *(void *)(a1 + 8) = v7;
            *(_DWORD *)(a1 + 16) = v8;
            *(void *)(a1 + 24) = v9;
            *(void *)(a1 + 32) = v10;
LABEL_151:
            uint64_t result = 2;
            goto LABEL_152;
          }
          unint64_t v103 = *v4;
LABEL_111:
          int v96 = (v103 >> v98) & ~(-1 << v97);
          *(_DWORD *)(a1 + 16) = v98 + v97;
        }
        unsigned int v78 = 0;
        int v80 = (v96 << *(_DWORD *)(a1 + 320)) + *(_DWORD *)(a1 + 4 * v93 + 1288);
        goto LABEL_113;
      }
      *(_DWORD *)(a1 + 360) = v93;
      if (v93 <= 3)
      {
        unsigned int v78 = 1u >> v93;
        *(_DWORD *)(a1 + 260) = 1u >> v93;
        int v95 = *(_DWORD *)(a1 + 96);
        int v80 = *(_DWORD *)(a1 + 4 * (((_BYTE)v95 + ~(_BYTE)v93) & 3) + 100);
        *(_DWORD *)(a1 + 360) = v80;
        *(_DWORD *)(a1 + 96) = v95 - v78;
        goto LABEL_114;
      }
      unsigned int v78 = 0;
      if (v93 >= 0xA) {
        char v105 = 10;
      }
      else {
        char v105 = 3;
      }
      if (v93 >= 0xA) {
        char v106 = -10;
      }
      else {
        char v106 = -4;
      }
      int v80 = ((0x605142u >> (4 * (v106 + v93))) & 7)
          + *(_DWORD *)(a1 + 4 * ((*(_DWORD *)(a1 + 96) + v105) & 3) + 100)
          - 3;
      if (v80 < 1) {
        int v80 = 0x7FFFFFFF;
      }
LABEL_113:
      *(_DWORD *)(a1 + 360) = v80;
LABEL_114:
      int v108 = *(_DWORD *)(a1 + 80);
      int v107 = *(_DWORD *)(a1 + 84);
      if (v107 != v108)
      {
        if (v2 >= v108) {
          int v107 = *(_DWORD *)(a1 + 80);
        }
        else {
          int v107 = v2;
        }
        *(_DWORD *)(a1 + 84) = v107;
      }
      size_t v3 = *(unsigned int *)(a1 + 356);
      if (v80 > v107)
      {
        if (v80 > 2147483644) {
          return 4294967280;
        }
        if ((v3 - 4) > 0x14) {
          return 4294967284;
        }
        uint64_t v109 = *(void *)(a1 + 696);
        uint64_t v110 = *(void *)(a1 + 704);
        uint64_t v111 = *(int *)(v109 + 4 * v3 + 32);
        char v112 = *(unsigned char *)(v109 + v3);
        *(_DWORD *)(a1 + 96) += v78;
        uint64_t v113 = *(void *)(v109 + 168);
        if (!v113) {
          return 4294967277;
        }
        int v114 = v80 + ~v107;
        int v115 = v114 >> v112;
        if (v114 >> v112 >= *(_DWORD *)(v110 + 24)) {
          return 4294967285;
        }
        int v116 = (void *)(v113 + v111 + (v114 & ~(-1 << v112)) * (int)v3);
        signed int v117 = (void *)(*(void *)(a1 + 120) + v2);
        if (v115 == *(__int16 *)(v110 + 48))
        {
          memcpy(v117, v116, v3);
          int v118 = v3;
        }
        else
        {
          int v118 = BrotliTransformDictionaryWord((uint64_t)v117, (char *)v116, v3, (void *)v110, v115);
        }
        v2 += v118;
        *(_DWORD *)(a1 + 264) -= v118;
        if (v2 < *(_DWORD *)(a1 + 88))
        {
          int v124 = v2;
          goto LABEL_145;
        }
        int v132 = 15;
LABEL_159:
        *(_DWORD *)a1 = v132;
        goto LABEL_161;
      }
      int v119 = *(_DWORD *)(a1 + 96);
      int v120 = *(_DWORD *)(a1 + 92) & (v2 - v80);
      uint64_t v121 = *(void *)(a1 + 120);
      uint64_t v5 = v2;
      int v122 = (_OWORD *)(v121 + v2);
      uLong v123 = (_OWORD *)(v121 + v120);
      int v124 = v3 + v2;
      *(_DWORD *)(a1 + 4 * (v119 & 3) + 100) = v80;
      *(_DWORD *)(a1 + 96) = v119 + 1;
      *(_DWORD *)(a1 + 264) -= v3;
      *int v122 = *v123;
      if (v120 + (int)v3 > v2 && v124 > v120) {
        goto LABEL_136;
      }
      int v126 = *(_DWORD *)(a1 + 88);
      if (v124 >= v126 || v120 + (int)v3 >= v126) {
        goto LABEL_136;
      }
      if ((int)v3 >= 17)
      {
        uint64_t v127 = v122 + 1;
        uint64_t v128 = v123 + 1;
        if (v3 < 0x21) {
          *uint64_t v127 = *v128;
        }
        else {
          memcpy(v127, v128, (v3 - 16));
        }
      }
LABEL_145:
      if (*(int *)(a1 + 264) <= 0)
      {
        *(_DWORD *)a1 = 14;
        uint64_t result = 1;
        int v2 = v124;
        goto LABEL_152;
      }
      int v2 = v124;
      goto LABEL_4;
    }
  }
LABEL_160:
  *(_DWORD *)a1 = 13;
  LODWORD(v3) = v3 - 1;
LABEL_161:
  uint64_t result = 1;
LABEL_152:
  *(_DWORD *)(a1 + 76) = v2;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

uint64_t SafeDecodeSymbol(unsigned char *a1, uint64_t a2, _DWORD *a3)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 != 64)
  {
    unsigned int v5 = 64 - v3;
    uint64_t v6 = *(void *)a2 >> v3;
    unint64_t v7 = &a1[4 * v6];
    unsigned int v8 = *v7;
    if (v8 > 8)
    {
      if (v5 < 9) {
        return 0;
      }
      uint64_t v10 = *(unsigned __int16 *)&a1[4 * v6 + 2] + ((v6 & ~(-1 << v8)) >> 8);
      unsigned int v11 = v7[4 * v10];
      if (56 - v3 < v11) {
        return 0;
      }
      *(_DWORD *)(a2 + 8) = v3 + v11 + 8;
      uint64_t v9 = &v7[4 * v10];
    }
    else
    {
      if (v5 < v8) {
        return 0;
      }
      *(_DWORD *)(a2 + 8) = v3 + v8;
      uint64_t v9 = &a1[4 * v6];
    }
    unsigned int v4 = (unsigned __int16 *)(v9 + 2);
    goto LABEL_12;
  }
  if (*a1) {
    return 0;
  }
  unsigned int v4 = (unsigned __int16 *)(a1 + 2);
LABEL_12:
  *a3 = *v4;
  return 1;
}

uint64_t SafeDecodeCommandBlockSwitch(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 288);
  if (v1 < 2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 248);
  unsigned int v4 = (unsigned char *)(*(void *)(a1 + 240) + 2528);
  unsigned int v5 = (unint64_t *)(a1 + 8);
  int v46 = 0;
  unint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v6;
  int v11 = v7;
  if ((v7 - 50) > 0xE)
  {
LABEL_6:
    unint64_t v17 = v10 >> v11;
    unsigned int v18 = &v4[4 * (v10 >> v11)];
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v11 += 8;
      v18 += 4 * (BYTE1(v17) & ~(-1 << (v19 - 8)) & 0x7F)
           + 4 * *(unsigned __int16 *)&v4[4 * v17 + 2];
      unsigned int v19 = *v18;
    }
    *(_DWORD *)(a1 + 16) = v11 + v19;
    int v46 = *((unsigned __int16 *)v18 + 1);
  }
  else
  {
    uint64_t v12 = v8 + 1;
    uint64_t v13 = v9 - 1;
    unint64_t v10 = *(void *)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 16);
    while (v13 != -1)
    {
      *(void *)(a1 + 8) = v10 >> 8;
      *((void *)&v15 + 1) = *(unsigned __int8 *)(v12 - 1);
      *(void *)&long long v15 = v10;
      unint64_t v10 = v15 >> 8;
      *(void *)(a1 + 8) = v10;
      int v11 = v14 - 8;
      *(_DWORD *)(a1 + 16) = v14 - 8;
      *(void *)(a1 + 24) = v12;
      *(void *)(a1 + 32) = v13;
      ++v12;
      --v13;
      unsigned int v16 = v14 - 58;
      v14 -= 8;
      if (v16 >= 0xF) {
        goto LABEL_6;
      }
    }
    if (!SafeDecodeSymbol(v4, a1 + 8, &v46)) {
      return 0;
    }
  }
  unsigned int v47 = 0;
  if (*(_DWORD *)(a1 + 660))
  {
    unsigned int v20 = *(_DWORD *)(a1 + 268);
  }
  else
  {
    unsigned int v21 = (unsigned char *)(v3 + 1584);
    int v22 = *(_DWORD *)(a1 + 16);
    if ((v22 - 50) >= 0xF)
    {
      unint64_t v26 = *v5;
LABEL_19:
      unint64_t v29 = v26 >> v22;
      int v30 = &v21[4 * (v26 >> v22)];
      unsigned int v31 = *v30;
      if (v31 >= 9)
      {
        v22 += 8;
        v30 += 4 * (BYTE1(v29) & ~(-1 << (v31 - 8)) & 0x7F)
             + 4 * *(unsigned __int16 *)&v21[4 * v29 + 2];
        unsigned int v31 = *v30;
      }
      *(_DWORD *)(a1 + 16) = v22 + v31;
      unsigned int v20 = *((unsigned __int16 *)v30 + 1);
    }
    else
    {
      uint64_t v23 = *(void *)(a1 + 32) - 1;
      while (v23 != -1)
      {
        unint64_t v24 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v24 >> 8;
        unsigned int v25 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v27 + 1) = *v25;
        *(void *)&long long v27 = v24;
        unint64_t v26 = v27 >> 8;
        *(void *)(a1 + 8) = v26;
        int v28 = v22 - 8;
        *(_DWORD *)(a1 + 16) = v22 - 8;
        *(void *)(a1 + 24) = v25 + 1;
        *(void *)(a1 + 32) = v23--;
        LODWORD(v25) = v22 - 58;
        v22 -= 8;
        if (v25 >= 0xF)
        {
          int v22 = v28;
          goto LABEL_19;
        }
      }
      if (!SafeDecodeSymbol(v21, a1 + 8, &v47)) {
        goto LABEL_32;
      }
      unsigned int v20 = v47;
    }
  }
  uint64_t v32 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v20);
  unsigned int v33 = *((unsigned __int8 *)v32 + 2);
  int v34 = *v32;
  int v35 = *(_DWORD *)(a1 + 16);
  unsigned int v36 = 64 - v35;
  if (64 - v35 < v33)
  {
    uint64_t v37 = *(void *)(a1 + 32) - 1;
    while (v37 != -1)
    {
      unint64_t v38 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v38 >> 8;
      unsigned int v39 = *(unsigned __int8 **)(a1 + 24);
      *((void *)&v41 + 1) = *v39;
      *(void *)&long long v41 = v38;
      unint64_t v40 = v41 >> 8;
      *(void *)(a1 + 8) = v40;
      v35 -= 8;
      *(_DWORD *)(a1 + 16) = v35;
      *(void *)(a1 + 24) = v39 + 1;
      *(void *)(a1 + 32) = v37--;
      v36 += 8;
      if (v36 >= v33) {
        goto LABEL_28;
      }
    }
    *(_DWORD *)(a1 + 268) = v20;
LABEL_32:
    *(_DWORD *)(a1 + 660) = 0;
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v8;
    *(void *)(a1 + 32) = v9;
    return 0;
  }
  unint64_t v40 = *v5;
LABEL_28:
  *(_DWORD *)(a1 + 16) = v35 + v33;
  *(_DWORD *)(a1 + 276) = ((v40 >> v35) & ~(-1 << v33)) + v34;
  *(_DWORD *)(a1 + 660) = 0;
  if (v46)
  {
    if (v46 == 1) {
      unsigned int v42 = *(_DWORD *)(a1 + 308) + 1;
    }
    else {
      unsigned int v42 = v46 - 2;
    }
  }
  else
  {
    unsigned int v42 = *(_DWORD *)(a1 + 304);
  }
  if (v42 >= v1) {
    unsigned int v44 = v1;
  }
  else {
    unsigned int v44 = 0;
  }
  unsigned int v45 = v42 - v44;
  *(_DWORD *)(a1 + 304) = *(_DWORD *)(a1 + 308);
  *(_DWORD *)(a1 + 308) = v45;
  *(void *)(a1 + 136) = *(void *)(*(void *)(a1 + 192) + 8 * v45);
  return 1;
}

uint64_t SafeDecodeLiteralBlockSwitch(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 284);
  if (v1 < 2) {
    return 0;
  }
  uint64_t v3 = *(unsigned char **)(a1 + 240);
  unsigned int v4 = *(unsigned char **)(a1 + 248);
  unsigned int v5 = (unint64_t *)(a1 + 8);
  int v47 = 0;
  unint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v6;
  int v11 = v7;
  if ((v7 - 50) > 0xE)
  {
LABEL_6:
    unint64_t v17 = v10 >> v11;
    unsigned int v18 = &v3[4 * (v10 >> v11)];
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v11 += 8;
      v18 += 4 * (BYTE1(v17) & ~(-1 << (v19 - 8)) & 0x7F)
           + 4 * *(unsigned __int16 *)&v3[4 * v17 + 2];
      unsigned int v19 = *v18;
    }
    *(_DWORD *)(a1 + 16) = v11 + v19;
    int v47 = *((unsigned __int16 *)v18 + 1);
  }
  else
  {
    uint64_t v12 = v8 + 1;
    uint64_t v13 = v9 - 1;
    unint64_t v10 = *(void *)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 16);
    while (v13 != -1)
    {
      *(void *)(a1 + 8) = v10 >> 8;
      *((void *)&v15 + 1) = *(unsigned __int8 *)(v12 - 1);
      *(void *)&long long v15 = v10;
      unint64_t v10 = v15 >> 8;
      *(void *)(a1 + 8) = v10;
      int v11 = v14 - 8;
      *(_DWORD *)(a1 + 16) = v14 - 8;
      *(void *)(a1 + 24) = v12;
      *(void *)(a1 + 32) = v13;
      ++v12;
      --v13;
      unsigned int v16 = v14 - 58;
      v14 -= 8;
      if (v16 >= 0xF) {
        goto LABEL_6;
      }
    }
    if (!SafeDecodeSymbol(v3, a1 + 8, &v47)) {
      return 0;
    }
  }
  unsigned int v48 = 0;
  if (*(_DWORD *)(a1 + 660))
  {
    unsigned int v20 = *(_DWORD *)(a1 + 268);
  }
  else
  {
    int v21 = *(_DWORD *)(a1 + 16);
    if ((v21 - 50) >= 0xF)
    {
      unint64_t v25 = *v5;
LABEL_19:
      unint64_t v28 = v25 >> v21;
      unint64_t v29 = &v4[4 * (v25 >> v21)];
      unsigned int v30 = *v29;
      if (v30 >= 9)
      {
        v21 += 8;
        v29 += 4 * (BYTE1(v28) & ~(-1 << (v30 - 8)) & 0x7F)
             + 4 * *(unsigned __int16 *)&v4[4 * v28 + 2];
        unsigned int v30 = *v29;
      }
      *(_DWORD *)(a1 + 16) = v21 + v30;
      unsigned int v20 = *((unsigned __int16 *)v29 + 1);
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 32) - 1;
      while (v22 != -1)
      {
        unint64_t v23 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v23 >> 8;
        unint64_t v24 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v26 + 1) = *v24;
        *(void *)&long long v26 = v23;
        unint64_t v25 = v26 >> 8;
        *(void *)(a1 + 8) = v25;
        int v27 = v21 - 8;
        *(_DWORD *)(a1 + 16) = v21 - 8;
        *(void *)(a1 + 24) = v24 + 1;
        *(void *)(a1 + 32) = v22--;
        LODWORD(v24) = v21 - 58;
        v21 -= 8;
        if (v24 >= 0xF)
        {
          int v21 = v27;
          goto LABEL_19;
        }
      }
      if (!SafeDecodeSymbol(v4, a1 + 8, &v48)) {
        goto LABEL_32;
      }
      unsigned int v20 = v48;
    }
  }
  unsigned int v31 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v20);
  unsigned int v32 = *((unsigned __int8 *)v31 + 2);
  int v33 = *v31;
  int v34 = *(_DWORD *)(a1 + 16);
  unsigned int v35 = 64 - v34;
  if (64 - v34 < v32)
  {
    uint64_t v36 = *(void *)(a1 + 32) - 1;
    while (v36 != -1)
    {
      unint64_t v37 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v37 >> 8;
      unint64_t v38 = *(unsigned __int8 **)(a1 + 24);
      *((void *)&v40 + 1) = *v38;
      *(void *)&long long v40 = v37;
      unint64_t v39 = v40 >> 8;
      *(void *)(a1 + 8) = v39;
      v34 -= 8;
      *(_DWORD *)(a1 + 16) = v34;
      *(void *)(a1 + 24) = v38 + 1;
      *(void *)(a1 + 32) = v36--;
      v35 += 8;
      if (v35 >= v32) {
        goto LABEL_28;
      }
    }
    *(_DWORD *)(a1 + 268) = v20;
LABEL_32:
    *(_DWORD *)(a1 + 660) = 0;
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v8;
    *(void *)(a1 + 32) = v9;
    return 0;
  }
  unint64_t v39 = *v5;
LABEL_28:
  *(_DWORD *)(a1 + 16) = v34 + v32;
  *(_DWORD *)(a1 + 272) = ((v39 >> v34) & ~(-1 << v32)) + v33;
  *(_DWORD *)(a1 + 660) = 0;
  if (v47)
  {
    if (v47 == 1) {
      unsigned int v41 = *(_DWORD *)(a1 + 300) + 1;
    }
    else {
      unsigned int v41 = v47 - 2;
    }
  }
  else
  {
    unsigned int v41 = *(_DWORD *)(a1 + 296);
  }
  if (v41 >= v1) {
    unsigned int v43 = v1;
  }
  else {
    unsigned int v43 = 0;
  }
  unsigned int v44 = v41 - v43;
  *(_DWORD *)(a1 + 296) = *(_DWORD *)(a1 + 300);
  *(_DWORD *)(a1 + 300) = v44;
  uint64_t v45 = v44 << 6;
  uint64_t v46 = *(void *)(a1 + 680);
  *(void *)(a1 + 152) = v46 + v45;
  *(_DWORD *)(a1 + 256) = (*(_DWORD *)(a1 + 4 * (v44 >> 5) + 712) >> v44) & 1;
  *(void *)(a1 + 344) = *(void *)(*(void *)(a1 + 168) + 8 * *(unsigned __int8 *)(v46 + v45));
  *(void *)(a1 + 144) = (char *)&_kBrotliContextLookupTable
                        + 512 * (unint64_t)(*(unsigned char *)(*(void *)(a1 + 688) + v44) & 3);
  return 1;
}

uint64_t brotli_stream_init(uint64_t a1, int a2)
{
  unsigned int v4 = malloc(0x20uLL);
  if (v4)
  {
    unsigned int v5 = v4;
    *unsigned int v4 = 0u;
    v4[1] = 0u;
    if (a2 == 1)
    {
      Instance = BrotliDecoderCreateInstance(0, 0, 0);
      v5[2] = Instance;
      if (Instance)
      {
        BrotliDecoderSetParameter((uint64_t)Instance, 1, 1);
        goto LABEL_8;
      }
    }
    else if (!a2)
    {
      unint64_t v6 = BrotliEncoderCreateInstance(0, 0, 0);
      v5[2] = v6;
      if (v6)
      {
        uint64_t v7 = (uint64_t)v6;
        BrotliEncoderSetParameter((uint64_t)v6, 1, 2u);
        BrotliEncoderSetParameter(v7, 2, 0x16u);
LABEL_8:
        uint64_t result = 0;
        *(_DWORD *)unsigned int v5 = a2;
        *((_DWORD *)v5 + 1) = 2818;
        *(void *)(a1 + 32) = v5;
        return result;
      }
    }
    free(v5);
  }
  return 0xFFFFFFFFLL;
}

uint64_t BrotliDecoderSetParameter(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)a1) {
    return 0;
  }
  if (a2 == 1)
  {
    __int16 v4 = *(_WORD *)(a1 + 664) & 0xFFDF | (32 * (a3 != 0));
  }
  else
  {
    if (a2) {
      return 0;
    }
    __int16 v4 = *(_WORD *)(a1 + 664) & 0xFFEF | (16 * (a3 == 0));
  }
  *(_WORD *)(a1 + 664) = v4;
  return 1;
}

void *BrotliDecoderCreateInstance(void *(*a1)(int a1, size_t __size), void (*a2)(int a1, void *a2), uint64_t a3)
{
  BOOL v6 = ((unint64_t)a1 | (unint64_t)a2) != 0;
  if ((unint64_t)a1 | (unint64_t)a2)
  {
    uint64_t result = 0;
    if (!a1 || !a2) {
      return result;
    }
    uint64_t v8 = a1(a3, 5152);
  }
  else
  {
    uint64_t v8 = malloc(0x1420uLL);
  }
  uint64_t v9 = v8;
  if (!v8) {
    return 0;
  }
  if (BrotliDecoderStateInit((uint64_t)v8, a1, a2, a3)) {
    return v9;
  }
  if (!v6)
  {
    free(v9);
    return 0;
  }
  uint64_t result = 0;
  if (a1 && a2)
  {
    a2(a3, v9);
    return 0;
  }
  return result;
}

uint64_t BrotliDecoderStateInit(uint64_t a1, void *(*a2)(int a1, size_t __size), void (*a3)(int a1, void *a2), uint64_t a4)
{
  if (a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = BrotliDefaultAllocFunc;
  }
  if (a2) {
    BOOL v6 = a3;
  }
  else {
    BOOL v6 = BrotliDefaultFreeFunc;
  }
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 48) = v6;
  if (a2) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = 0;
  }
  *(void *)(a1 + 56) = v7;
  *(_DWORD *)(a1 + 116) = 0;
  BrotliInitBitReader(a1 + 8);
  __int16 v8 = *(_WORD *)(a1 + 664);
  *(void *)a1 = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_WORD *)(a1 + 664) = v8 & 0xFFC0 | 0x10;
  *(void *)(a1 + 668) = 0;
  *(_OWORD *)(a1 + 100) = xmmword_20DAD5C20;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 384) = 63;
  *(void *)(a1 + 696) = BrotliGetDictionary();
  *(void *)(a1 + 704) = BrotliGetTransforms();
  return 1;
}

uint64_t BrotliInitBitReader(uint64_t result)
{
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 8) = 64;
  return result;
}

void *BrotliGetTransforms()
{
  return &kBrotliTransforms;
}

void *BrotliGetDictionary()
{
  return &kBrotliDictionary;
}

int deflateEnd(z_streamp strm)
{
  if (!strm) {
    return -2;
  }
  state = strm->state;
  if (!state) {
    return -2;
  }
  int v3 = *((_DWORD *)state + 2);
  BOOL v4 = (v3 - 69) > 0x2C || ((1 << (v3 - 69)) & 0x100400400011) == 0;
  if (v4 && v3 != 666 && v3 != 42) {
    return -2;
  }
  if (*((void *)state + 2))
  {
    ((void (*)(voidpf, void))strm->zfree)(strm->opaque, *((void *)state + 2));
    state = strm->state;
  }
  if (*((void *)state + 13))
  {
    ((void (*)(voidpf, void))strm->zfree)(strm->opaque, *((void *)state + 13));
    state = strm->state;
  }
  if (*((void *)state + 12))
  {
    ((void (*)(voidpf, void))strm->zfree)(strm->opaque, *((void *)state + 12));
    state = strm->state;
  }
  if (*((void *)state + 10))
  {
    ((void (*)(voidpf, void))strm->zfree)(strm->opaque, *((void *)state + 10));
    state = strm->state;
  }
  ((void (*)(voidpf, internal_state *))strm->zfree)(strm->opaque, state);
  strm->state = 0;
  if (v3 == 113) {
    return -3;
  }
  else {
    return 0;
  }
}

void zcfree(int a1, void *a2)
{
}

uint64_t lzma_stream_end(uint64_t a1)
{
  return 0;
}

double lzma_stream_init(uint64_t a1, int a2)
{
  *(void *)(a1 + 32) = 0;
  BOOL v4 = malloc(0xA0uLL);
  if (v4)
  {
    BOOL v6 = v4;
    v4[8] = 0u;
    v4[9] = 0u;
    v4[6] = 0u;
    v4[7] = 0u;
    v4[4] = 0u;
    v4[5] = 0u;
    v4[2] = 0u;
    v4[3] = 0u;
    *BOOL v4 = 0u;
    v4[1] = 0u;
    if (a2)
    {
      if (lzma_auto_decoder())
      {
LABEL_4:
        free(v6);
        return result;
      }
    }
    else if (lzma_easy_encoder())
    {
      goto LABEL_4;
    }
    *BOOL v6 = a2;
    double result = -1.06069509e-97;
    *(void *)(v6 + 1) = 0xABCD000500000306;
    *(void *)(a1 + 32) = v6;
  }
  return result;
}

uint64_t readHuffmanTable(uint64_t *a1, int *a2, uint64_t a3, int *a4, uint64_t a5)
{
  v76[8] = *MEMORY[0x263EF8340];
  unint64_t v6 = a1[1];
  unint64_t v5 = a1[2];
  unint64_t v7 = v6 - v5;
  if (v6 >= v5) {
    unint64_t v8 = v6 - v5;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v8 >= 0xE)
  {
    char v13 = v5 & 7;
    unint64_t v71 = v6 + 7;
    if ((v6 + 7 - v5) >> 3 >= 8) {
      size_t v14 = 8;
    }
    else {
      size_t v14 = (v6 + 7 - v5) >> 3;
    }
    *(void *)&__dst[0] = 0;
    uint64_t v15 = *a1;
    memcpy(__dst, (const void *)(*a1 + (v5 >> 3)), v14);
    uint64_t v16 = *(void *)&__dst[0] >> v13;
    uint64_t v17 = (((*(void *)&__dst[0] >> v13) >> 10) & 0xF) + 4;
    unint64_t v18 = v5 + 14;
    a1[2] = v18;
    uint64_t v73 = 0;
    v74[0] = 0;
    *(_DWORD *)((char *)v74 + 7) = 0;
    unint64_t v19 = v6 - v18;
    if (v6 < v18) {
      unint64_t v19 = 0;
    }
    unint64_t v20 = (3 * v17);
    if (v19 >= v20)
    {
      uint64_t v67 = a5;
      int v68 = ((v16 >> 5) & 0x1F) + 1;
      unsigned int v69 = (v16 & 0x1F) + 257;
      size_t v21 = (v7 - 7) >> 3 >= 8 ? 8 : (v7 - 7) >> 3;
      *(void *)&__dst[0] = 0;
      memcpy(__dst, (const void *)(v15 + (v18 >> 3)), v21);
      unint64_t v22 = *(void *)&__dst[0] >> (v18 & 7);
      unint64_t v23 = v18 + v20;
      a1[2] = v18 + v20;
      unint64_t v24 = &byte_20DB0A480;
      do
      {
        unsigned int v25 = *v24++;
        *((unsigned char *)&v74[-1] + v25) = v22 & 7;
        v22 >>= 3;
        --v17;
      }
      while (v17);
      uint64_t v26 = 0;
      int v27 = 1;
      do
      {
        if (v27 <= *((unsigned __int8 *)&v74[-1] + v26)) {
          int v27 = *((unsigned __int8 *)&v74[-1] + v26);
        }
        ++v26;
      }
      while (v26 != 19);
      int v28 = 1 << v27;
      if (v28 <= 128)
      {
        uint64_t v30 = 0;
        memset(v72, 0, 64);
        do
          ++*((_DWORD *)v72 + *((unsigned __int8 *)&v74[-1] + v30++));
        while (v30 != 19);
        uint64_t v31 = 0;
        int v32 = 0;
        LODWORD(v72[0]) = 0;
        LODWORD(v76[0]) = 0;
        do
        {
          int v32 = 2 * (*(_DWORD *)((char *)v72 + v31) + v32);
          *(_DWORD *)((char *)v76 + v31 + 4) = v32;
          v31 += 4;
        }
        while (v31 != 60);
        for (uint64_t i = 0; i != 19; ++i)
        {
          uint64_t v34 = *((unsigned __int8 *)&v74[-1] + i);
          int v35 = *((_DWORD *)v76 + v34);
          *((_DWORD *)v76 + v34) = v35 + 1;
          *((_WORD *)__dst + i) = (breverse_brev8[BYTE1(v35)] | (breverse_brev8[v35] << 8)) >> (16 - v34);
        }
        int v65 = a4;
        uint64_t v66 = a2;
        for (uint64_t j = 0; j != 19; ++j)
        {
          __int16 v37 = *((unsigned __int8 *)&v74[-1] + j);
          if (*((unsigned char *)&v74[-1] + j))
          {
            uint64_t v38 = *((unsigned __int16 *)__dst + j);
            if (v28 > (int)v38)
            {
              __int16 v39 = v37 + 16 * j - 1;
              uint64_t v40 = 1 << v37;
              do
              {
                *((_WORD *)v72 + v38) = v39;
                v38 += v40;
              }
              while (v38 < v28);
            }
          }
        }
        signed int v41 = 0;
        uint64_t v42 = 0;
        int v43 = v28 - 1;
        memset(__dst, 0, 320);
        while (1)
        {
          if (v6 >= v23) {
            unint64_t v44 = v6 - v23;
          }
          else {
            unint64_t v44 = 0;
          }
          v76[0] = 0;
          if ((v6 - v23 + 7) >> 3 >= 8) {
            size_t v45 = 8;
          }
          else {
            size_t v45 = (v6 - v23 + 7) >> 3;
          }
          memcpy(v76, (const void *)(v15 + (v23 >> 3)), v45);
          unsigned int v46 = *((unsigned __int16 *)v72 + (int)(v43 & (v76[0] >> (v23 & 7))));
          unint64_t v47 = (v46 & 0xF) + 1;
          if (v44 < v47) {
            return 0xFFFFFFFFLL;
          }
          uint64_t v48 = v46 >> 4;
          v23 += v47;
          a1[2] = v23;
          if (v46 > 0xFF)
          {
            if (v48 == 17)
            {
              unint64_t v53 = v6 - v23;
              if (v6 < v23) {
                unint64_t v53 = 0;
              }
              if (v53 < 3) {
                return 0xFFFFFFFFLL;
              }
              if ((v71 - v23) >> 3 >= 8) {
                size_t v54 = 8;
              }
              else {
                size_t v54 = (v71 - v23) >> 3;
              }
              v76[0] = 0;
              memcpy(v76, (const void *)(v15 + (v23 >> 3)), v54);
              uint64_t v55 = v76[0] >> (v23 & 7);
              v23 += 3;
              a1[2] = v23;
              size_t v56 = (v55 & 7) + 3;
            }
            else
            {
              if (v48 == 16)
              {
                unint64_t v49 = v6 - v23;
                if (v6 < v23) {
                  unint64_t v49 = 0;
                }
                if (v49 < 2) {
                  return 0xFFFFFFFFLL;
                }
                size_t v50 = (v71 - v23) >> 3 >= 8 ? 8 : (v71 - v23) >> 3;
                v76[0] = 0;
                memcpy(v76, (const void *)(v15 + (v23 >> 3)), v50);
                uint64_t v51 = v76[0] >> (v23 & 7);
                v23 += 2;
                a1[2] = v23;
                if ((int)((v51 & 3) + v41 + 3) > 319) {
                  return 0xFFFFFFFFLL;
                }
                int v52 = v51 & 3;
                memset((char *)__dst + v41, v42, (v51 & 3) + 3);
                v41 += v52 + 3;
                uint64_t v48 = v42;
                goto LABEL_70;
              }
              unint64_t v57 = v6 - v23;
              if (v6 < v23) {
                unint64_t v57 = 0;
              }
              if (v57 < 7) {
                return 0xFFFFFFFFLL;
              }
              if ((v71 - v23) >> 3 >= 8) {
                size_t v58 = 8;
              }
              else {
                size_t v58 = (v71 - v23) >> 3;
              }
              v76[0] = 0;
              memcpy(v76, (const void *)(v15 + (v23 >> 3)), v58);
              uint64_t v59 = v76[0] >> (v23 & 7);
              v23 += 7;
              a1[2] = v23;
              size_t v56 = (v59 & 0x7F) + 11;
            }
            signed int v60 = v56 + v41;
            if ((int)v56 + v41 > 319) {
              return 0xFFFFFFFFLL;
            }
            bzero((char *)__dst + v41, v56);
            uint64_t v48 = v42;
            signed int v41 = v60;
          }
          else
          {
            *((unsigned char *)__dst + v41++) = v46 >> 4;
          }
LABEL_70:
          uint64_t v42 = v48;
          if (v41 >= (int)(v68 + v69))
          {
            int DecoderTable = getDecoderTable(v69, (unsigned __int8 *)__dst, *v66, a3);
            if (DecoderTable)
            {
              int v62 = DecoderTable;
              int v63 = getDecoderTable(v68, (unsigned __int8 *)__dst + v69, *v65, v67);
              if (v63)
              {
                int v64 = v63;
                uint64_t result = 0;
                *uint64_t v66 = v62;
                *int v65 = v64;
                return result;
              }
            }
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t getDecoderTable(int a1, unsigned __int8 *a2, int a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (a1 < 1)
  {
    if (a3 > 1)
    {
      memset((char *)v28 + 4, 0, 60);
      uint64_t result = 2;
      goto LABEL_13;
    }
    return 0;
  }
  uint64_t v5 = a1;
  int v6 = 1;
  uint64_t v7 = a1;
  unint64_t v8 = a2;
  do
  {
    int v10 = *v8++;
    int v9 = v10;
    if (v6 <= v10) {
      int v6 = v9;
    }
    --v7;
  }
  while (v7);
  uint64_t result = (1 << v6);
  if ((int)result > a3) {
    return 0;
  }
  memset(v28, 0, sizeof(v28));
  uint64_t v12 = a2;
  do
  {
    unsigned int v13 = *v12++;
    ++*((_DWORD *)v28 + v13);
    --v5;
  }
  while (v5);
LABEL_13:
  uint64_t v14 = 0;
  int v15 = 0;
  LODWORD(v28[0]) = 0;
  v27[0] = 0;
  do
  {
    int v15 = 2 * (*(_DWORD *)((char *)v28 + v14 * 4) + v15);
    v27[++v14] = v15;
  }
  while (v14 != 15);
  if (a1 > 0)
  {
    uint64_t v16 = v26;
    uint64_t v17 = a2;
    uint64_t v18 = a1;
    do
    {
      int v19 = *v17++;
      int v20 = v27[v19];
      v27[v19] = v20 + 1;
      *v16++ = (breverse_brev8[BYTE1(v20)] | (breverse_brev8[v20] << 8)) >> (16 - v19);
      --v18;
    }
    while (v18);
    uint64_t v21 = 0;
    do
    {
      __int16 v22 = a2[v21];
      if (a2[v21])
      {
        uint64_t v23 = (unsigned __int16)v26[v21];
        if ((int)result > (int)v23)
        {
          __int16 v24 = v22 + 16 * v21 - 1;
          uint64_t v25 = 1 << v22;
          do
          {
            *(_WORD *)(a4 + 2 * v23) = v24;
            v23 += v25;
          }
          while (v23 < (int)result);
        }
      }
      ++v21;
    }
    while (v21 != a1);
  }
  return result;
}

uint64_t BrotliDestroyBlockSplit(uint64_t a1, uint64_t a2)
{
  BrotliFree(a1, *(void *)(a2 + 16));
  *(void *)(a2 + 16) = 0;
  uint64_t result = BrotliFree(a1, *(void *)(a2 + 24));
  *(void *)(a2 + 24) = 0;
  return result;
}

uint64_t BrotliFree(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    int v3 = (unint64_t *)result;
    uint64_t result = (*(uint64_t (**)(void))(result + 8))(*(void *)(result + 16));
    unint64_t v4 = v3[6];
    if (v4 == 64)
    {
      uint64_t result = CollectGarbagePointers(v3);
      unint64_t v4 = v3[6];
    }
    v3[6] = v4 + 1;
    v3[v4 + 199] = a2;
  }
  return result;
}

char *zero_coder_decode(int8x8_t *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  if (!zero_coder_luts_ok) {
    zero_coder_init_luts();
  }
  unint64_t v8 = (int8x8_t *)((char *)a1 + a2);
  unint64_t v9 = (unint64_t)&a3[a4];
  if (a2 < 8 || a4 < 9)
  {
    int v10 = a1;
  }
  else
  {
    int v10 = a1;
    do
    {
      uint64_t v11 = *a3;
      uint64_t v12 = v10 + 2;
      *v10++ = vqtbl1_s8((int8x16_t)*(unint64_t *)(a3 + 1), *(int8x8_t *)&zero_coder_lut_read[8 * v11]);
      a3 += zero_coder_lut_popcount[v11] + 1;
    }
    while (v12 <= v8 && (unint64_t)(a3 + 9) <= v9);
  }
LABEL_10:
  if ((unint64_t)a3 < v9)
  {
    int v13 = *a3++;
    unsigned int v14 = v13 | 0x100;
    while (v10 != v8)
    {
      if (v14)
      {
        if (a3 == (unsigned __int8 *)v9) {
          return (char *)((char *)v10 - (char *)a1);
        }
        __int8 v16 = *a3++;
        __int8 v15 = v16;
      }
      else
      {
        __int8 v15 = 0;
      }
      v10->i8[0] = v15;
      int v10 = (int8x8_t *)((char *)v10 + 1);
      BOOL v17 = v14 > 3;
      v14 >>= 1;
      if (!v17) {
        goto LABEL_10;
      }
    }
    int v10 = (int8x8_t *)((char *)a1 + a2);
  }
  return (char *)((char *)v10 - (char *)a1);
}

unsigned char *zero_coder_encode(unsigned char *a1, uint64_t a2, int8x8_t *a3, uint64_t a4, double a5, int8x16_t a6)
{
  if (!zero_coder_luts_ok) {
    zero_coder_init_luts();
  }
  if (a2 < 9) {
    return 0;
  }
  unint64_t v10 = (unint64_t)a3 + a4;
  uint64_t v11 = a1;
  while ((unint64_t)&a3[1] <= v10)
  {
    *(int8x8_t *)a6.i8 = *a3;
    int8x8_t v12 = vbic_s8((int8x8_t)0x8040201008040201, vceqz_s8(*a3));
    v12.i32[0] = vuzp1_s8(vorr_s8(vzip1_s8(v12, (int8x8_t)0x8040201008040201), vzip2_s8(v12, (int8x8_t)0x8040201008040201)), (int8x8_t)0x8040201008040201).u32[0];
    *uint64_t v11 = v12.i8[0] | v12.i8[2] | ((unsigned __int16)(v12.i16[0] | v12.i16[1]) >> 8);
    uint64_t v13 = (v12.i8[0] | v12.i8[2] | ((unsigned __int16)(v12.i16[0] | v12.i16[1]) >> 8));
    *(int8x8_t *)(v11 + 1) = vqtbl1_s8(a6, *(int8x8_t *)&zero_coder_lut_write[8 * v13]);
    v11 += zero_coder_lut_popcount[v13] + 1;
    ++a3;
    if (v11 + 9 > &a1[a2]) {
      return 0;
    }
  }
  if ((unint64_t)a3 >= v10)
  {
    BOOL v17 = v11;
  }
  else
  {
    char v15 = 0;
    int v16 = 0;
    BOOL v17 = v11 + 1;
    int v18 = -1 << (a4 & 7);
    unsigned __int8 v19 = 1;
    int v20 = a3;
    do
    {
      int v21 = v20->u8[0];
      if (v21)
      {
        *v17++ = v21;
        v18 |= 1 << v15;
      }
      char v15 = ++v16;
      int v20 = (int8x8_t *)((char *)a3 + v19++);
    }
    while ((unint64_t)v20 < v10);
    *uint64_t v11 = v18;
  }
  return (unsigned char *)(v17 - a1);
}

__int16 zero_coder_init_luts@<H0>()
{
  zero_coder_luts_ouint64_t k = 1;
  memset(zero_coder_lut_write, 128, sizeof(zero_coder_lut_write));
  memset(zero_coder_lut_read, 128, sizeof(zero_coder_lut_read));
  for (uint64_t i = 0; i != 256; ++i)
  {
    unsigned int v2 = 0;
    for (unsigned int j = 0; j != 8; ++j)
    {
      if ((i >> j))
      {
        zero_coder_lut_write[8 * i + v2] = j;
        zero_coder_lut_read[8 * i + j] = v2++;
      }
    }
    v0.i32[0] = i;
    int8x8_t v0 = vcnt_s8(v0);
    v0.i16[0] = vaddlv_u8((uint8x8_t)v0);
    zero_coder_lut_popcount[i] = v0.i8[0];
  }
  return v0.i16[0];
}

const char *zlibVersion(void)
{
  return "1.2.5";
}

uLong zlibCompileFlags(void)
{
  return 169;
}

const char *__cdecl zError(int a1)
{
  return z_errmsg[2 - a1];
}

uint64_t BrotliEncoderSetParameter(uint64_t a1, int a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 8636)) {
    return 0;
  }
  switch(a2)
  {
    case 0:
      *(_DWORD *)a1 = a3;
      break;
    case 1:
      *(_DWORD *)(a1 + 4) = a3;
      break;
    case 2:
      *(_DWORD *)(a1 + 8) = a3;
      break;
    case 3:
      *(_DWORD *)(a1 + 12) = a3;
      break;
    case 4:
      if (a3 > 1) {
        return 0;
      }
      *(_DWORD *)(a1 + 32) = a3 != 0;
      break;
    case 5:
      *(void *)(a1 + 24) = a3;
      break;
    case 6:
      *(_DWORD *)(a1 + 36) = a3 != 0;
      break;
    case 7:
      *(_DWORD *)(a1 + 64) = a3;
      break;
    case 8:
      *(_DWORD *)(a1 + 68) = a3;
      break;
    case 9:
      if (a3 > 0x40000000) {
        return 0;
      }
      *(void *)(a1 + 16) = a3;
      break;
    default:
      return 0;
  }
  return 1;
}

char *BrotliEncoderCreateInstance(void *(*a1)(int a1, size_t __size), void (*a2)(int a1, void *a2), uint64_t a3)
{
  if ((unint64_t)a1 | (unint64_t)a2)
  {
    int v6 = 0;
    if (!a1 || !a2) {
      return v6;
    }
    uint64_t v7 = (char *)a1(a3, 8640);
  }
  else
  {
    uint64_t v7 = (char *)malloc(0x21C0uLL);
  }
  int v6 = v7;
  if (v7)
  {
    BrotliInitMemoryManager((uint64_t)(v7 + 144), a1, a2, a3);
    *((_DWORD *)v6 + 9) = 0;
    *(void *)int v6 = 0xB00000000;
    *((_DWORD *)v6 + 2) = 22;
    *(void *)(v6 + 12) = 0;
    *(_OWORD *)(v6 + 20) = 0u;
    BrotliInitEncoderDictionary((uint64_t)(v6 + 88));
    *((_OWORD *)v6 + 4) = xmmword_20DAB5AD0;
    *((void *)v6 + 10) = 67108860;
    *((void *)v6 + 281) = 0;
    *((_WORD *)v6 + 1218) = 0;
    *((_DWORD *)v6 + 2157) = 0;
    *((void *)v6 + 1079) = 0;
    *((_OWORD *)v6 + 142) = 0u;
    *((_OWORD *)v6 + 143) = 0u;
    *((_OWORD *)v6 + 144) = 0u;
    *((_OWORD *)v6 + 145) = 0u;
    *((_OWORD *)v6 + 146) = 0u;
    *((void *)v6 + 305) = 0;
    *((_OWORD *)v6 + 153) = 0u;
    *((_OWORD *)v6 + 478) = 0u;
    *((_OWORD *)v6 + 537) = 0u;
    *((_OWORD *)v6 + 536) = 0u;
    *((_OWORD *)v6 + 535) = 0u;
    *((_OWORD *)v6 + 147) = xmmword_20DAB5AE0;
    *((_OWORD *)v6 + 151) = *((_OWORD *)v6 + 147);
  }
  return v6;
}

uint64_t BrotliEncoderDestroyInstance(uint64_t result)
{
  if (result)
  {
    unsigned int v1 = (unint64_t *)result;
    uint64_t v2 = result + 144;
    uint64_t v3 = *(void *)(result + 160);
    uint64_t v5 = *(uint64_t (**)(uint64_t, unint64_t *))(result + 152);
    if (*(_DWORD *)(result + 168))
    {
      BrotliWipeOutMemoryManager(result + 144);
    }
    else
    {
      BrotliFree(result + 144, *(void *)(result + 2448));
      v1[306] = 0;
      BrotliFree(v2, v1[288]);
      v1[288] = 0;
      BrotliFree(v2, v1[285]);
      v1[285] = 0;
      unint64_t v4 = v1[307];
      if (v4)
      {
        BrotliFree(v2, v4);
        v1[307] = 0;
      }
      BrotliFree(v2, v1[956]);
      v1[956] = 0;
      BrotliFree(v2, v1[1071]);
      v1[1071] = 0;
      BrotliFree(v2, v1[1072]);
      v1[1072] = 0;
    }
    return v5(v3, v1);
  }
  return result;
}

uint64_t BrotliEncoderMaxCompressedSize(unint64_t a1)
{
  unint64_t v1 = a1 + 4 * (a1 >> 14) + 6;
  if (v1 < a1) {
    unint64_t v1 = 0;
  }
  if (a1) {
    return v1;
  }
  else {
    return 2;
  }
}

uint64_t BrotliEncoderCompress(int a1, int a2, int a3, unint64_t a4, uint64_t *a5, unint64_t *a6, unsigned char *a7)
{
  uint64_t v7 = a7;
  unint64_t v8 = a6;
  uint64_t v274 = *MEMORY[0x263EF8340];
  unint64_t v9 = *a6;
  if (!a4)
  {
    if (v9)
    {
      uint64_t result = 1;
      *a6 = 1;
      *a7 = 6;
      return result;
    }
    return 0;
  }
  unint64_t v10 = a4;
  unint64_t v11 = a4 + 4 * (a4 >> 14) + 6;
  if (v11 < a4) {
    unint64_t v11 = 0;
  }
  if (v9)
  {
    unint64_t v181 = v11;
    unint64_t v182 = *a6;
    if (a1 != 10)
    {
      uint64_t result = (uint64_t)BrotliEncoderCreateInstance(0, 0, 0);
      if (!result) {
        return result;
      }
      uint64_t v22 = result;
      *(void *)&long long v240 = v10;
      *(void *)&v210[0] = a5;
      *(void *)&v199[0] = *v8;
      *(void *)v239 = v7;
      *(void *)&v193[0] = 0;
      if (!*(_DWORD *)(result + 8636))
      {
        *(_DWORD *)(result + 4) = a1;
        *(_DWORD *)(result + 8) = a2;
        *(_DWORD *)uint64_t result = a3;
        *(void *)(result + 24) = v10;
        if (a2 >= 25) {
          *(_DWORD *)(result + 36) = 1;
        }
      }
      int v23 = BrotliEncoderCompressStream(result, 2, (unint64_t *)&v240, (const void **)v210, (size_t *)v199, (void **)v239, (size_t *)v193);
      if (*(_DWORD *)(v22 + 8628) == 2 && !*(void *)(v22 + 8592)) {
        int v24 = v23;
      }
      else {
        int v24 = 0;
      }
      *unint64_t v8 = *(void *)&v193[0];
      BrotliEncoderDestroyInstance(v22);
      unint64_t v25 = v181;
      if (v24 && (!v181 || *v8 <= v181)) {
        return 1;
      }
      unint64_t v26 = v182;
      goto LABEL_324;
    }
    long long v271 = 0u;
    long long v270 = 0u;
    if (a2 <= 16) {
      int v15 = 16;
    }
    else {
      int v15 = a2;
    }
    long long v269 = 0uLL;
    long long v268 = 0uLL;
    if (v15 >= 30) {
      unsigned int v16 = 30;
    }
    else {
      unsigned int v16 = v15;
    }
    long long v267 = 0uLL;
    long long v266 = 0uLL;
    long long v265 = 0uLL;
    long long v264 = 0uLL;
    long long v263 = 0uLL;
    long long v262 = 0uLL;
    long long v261 = 0uLL;
    long long v260 = 0uLL;
    long long v259 = 0uLL;
    long long v258 = 0uLL;
    long long v257 = 0uLL;
    long long v256 = 0uLL;
    long long v255 = 0uLL;
    long long v254 = 0uLL;
    long long v253 = 0uLL;
    long long v252 = 0uLL;
    long long v251 = 0uLL;
    long long v250 = 0uLL;
    long long v249 = 0uLL;
    long long v248 = 0uLL;
    long long v247 = 0uLL;
    long long v246 = 0uLL;
    long long v245 = 0uLL;
    long long v244 = 0uLL;
    long long v243 = 0uLL;
    long long v242 = 0uLL;
    long long v241 = 0uLL;
    long long v240 = 0uLL;
    long long v272 = xmmword_20DAB5AE0;
    long long v273 = xmmword_20DAB5AE0;
    if (a4 >= 1 << v16) {
      unint64_t v17 = 1 << v16;
    }
    else {
      unint64_t v17 = a4;
    }
    memset(&v239[40], 0, 104);
    if (v15 >= 23) {
      char v18 = 23;
    }
    else {
      char v18 = v15;
    }
    long long v235 = 0uLL;
    long long v234 = 0uLL;
    long long v233 = 0uLL;
    long long v232 = 0uLL;
    long long v231 = 0uLL;
    long long v230 = 0uLL;
    long long v229 = 0uLL;
    long long v228 = 0uLL;
    long long v226 = 0uLL;
    long long v227 = 0uLL;
    long long v224 = 0uLL;
    long long v225 = 0uLL;
    long long v222 = 0uLL;
    long long v223 = 0uLL;
    long long v220 = 0uLL;
    long long v221 = 0uLL;
    long long v218 = 0uLL;
    long long v219 = 0uLL;
    long long v216 = 0uLL;
    long long v217 = 0uLL;
    long long v214 = 0uLL;
    long long v215 = 0uLL;
    *(_OWORD *)__b = 0uLL;
    memset(v213, 0, sizeof(v213));
    *(_OWORD *)v211 = 0uLL;
    memset(v210, 0, sizeof(v210));
    *(void *)v239 = 0xB00000000;
    memset(&v239[12], 0, 28);
    BrotliInitEncoderDictionary((uint64_t)&v239[88]);
    *(_OWORD *)&v239[64] = xmmword_20DAB5AD0;
    *(void *)&v239[80] = 67108860;
    *(_DWORD *)&v239[8] = v16;
    char v180 = v16;
    if (v16 < 0x19)
    {
      unsigned int v19 = 24;
    }
    else
    {
      *(_DWORD *)&v239[36] = 1;
      unsigned int v19 = 30;
    }
    *(_DWORD *)&v239[4] = 10;
    int v27 = v16;
    unint64_t v8 = a6;
    if (v19 < v16)
    {
      *(_DWORD *)&v239[8] = v19;
      int v27 = v19;
    }
    if (v27 >= 18) {
      int v28 = 18;
    }
    else {
      int v28 = v27;
    }
    *(_DWORD *)&v239[12] = v28;
    ChooseDistanceParams(v239);
    char v29 = v239[12];
    BrotliInitMemoryManager((uint64_t)&v240, 0, 0, 0);
    if (*(_DWORD *)&v239[36])
    {
      char v30 = 17;
      uint64_t v31 = 14;
    }
    else if (v16 == 16)
    {
      char v30 = 0;
      char v180 = 0;
      uint64_t v31 = 1;
    }
    else
    {
      if (v16 != 17)
      {
        char v30 = 2 * v16 - 33;
        uint64_t v176 = 4;
        char v180 = 0;
LABEL_42:
        if (*(void *)&v210[0])
        {
          if (HIDWORD(v210[2])) {
            goto LABEL_185;
          }
          int v32 = DWORD2(v210[1]);
          goto LABEL_122;
        }
        int v33 = *(_DWORD *)&v239[4];
        if (*(int *)&v239[4] < 10)
        {
          if (*(_DWORD *)&v239[4] == 4)
          {
            if (*(void *)&v239[24] >= 0x100000uLL) {
              int v33 = 54;
            }
          }
          else if (*(int *)&v239[4] > 4)
          {
            if (*(int *)&v239[8] > 16)
            {
              if (*(_DWORD *)&v239[8] < 0x13u || *(void *)&v239[24] < 0x100000uLL)
              {
                if (*(_DWORD *)&v239[4] >= 9u) {
                  int v40 = 16;
                }
                else {
                  int v40 = 10;
                }
                if (*(_DWORD *)&v239[4] < 7u) {
                  int v41 = 14;
                }
                else {
                  int v41 = 15;
                }
                *(_DWORD *)&v239[40] = 5;
                *(_DWORD *)&v239[44] = v41;
                if (*(_DWORD *)&v239[4] >= 7u) {
                  int v42 = v40;
                }
                else {
                  int v42 = 4;
                }
                *(_DWORD *)&v239[48] = *(_DWORD *)&v239[4] - 1;
                *(_DWORD *)&v239[56] = v42;
                int v33 = 5;
              }
              else
              {
                *(void *)&v239[40] = 0xF00000006;
                *(_DWORD *)&v239[48] = *(_DWORD *)&v239[4] - 1;
                *(_DWORD *)&v239[52] = 5;
                if (*(_DWORD *)&v239[4] >= 9u) {
                  int v37 = 16;
                }
                else {
                  int v37 = 10;
                }
                if (*(_DWORD *)&v239[4] >= 7u) {
                  int v38 = v37;
                }
                else {
                  int v38 = 4;
                }
                *(_DWORD *)&v239[56] = v38;
                int v33 = 6;
              }
              goto LABEL_51;
            }
            if (*(_DWORD *)&v239[4] < 9u) {
              int v36 = 41;
            }
            else {
              int v36 = 42;
            }
            if (*(_DWORD *)&v239[4] >= 7u) {
              int v33 = v36;
            }
            else {
              int v33 = 40;
            }
          }
        }
        else
        {
          int v33 = 10;
        }
        *(_DWORD *)&v239[40] = v33;
LABEL_51:
        if (*(int *)&v239[8] < 25)
        {
          uint64_t v34 = 0;
          switch(v33)
          {
            case 2:
            case 3:
            case 4:
            case 10:
              goto LABEL_87;
            case 5:
            case 6:
LABEL_58:
              uint64_t v35 = (4 << v239[44] << v239[48]) + (2 << v239[44]);
LABEL_86:
              if (v35) {
LABEL_87:
              }
                uint64_t v34 = BrotliAllocate((uint64_t)&v240);
              else {
                uint64_t v34 = 0;
              }
              break;
            case 7:
            case 8:
            case 9:
              break;
            default:
              switch(v33)
              {
                case '#':
                case '(':
                case ')':
                case '*':
                  goto LABEL_87;
                case '$':
                case '%':
                case '&':
                case '\'':
                  goto LABEL_88;
                default:
                  if (v33 == 54) {
                    goto LABEL_87;
                  }
                  break;
              }
              break;
          }
        }
        else
        {
          uint64_t v34 = 0;
          switch(v33)
          {
            case 2:
            case 4:
            case 10:
              goto LABEL_87;
            case 3:
              *(_DWORD *)&v239[40] = 35;
              goto LABEL_87;
            case 5:
              goto LABEL_58;
            case 6:
              *(_DWORD *)&v239[40] = 65;
              uint64_t v35 = (2 << v239[44]) + 0x4000000 + (4 << v239[44] << v239[48]);
              goto LABEL_86;
            case 7:
            case 8:
            case 9:
              break;
            default:
              switch(v33)
              {
                case '#':
                case '(':
                case ')':
                case '*':
                  goto LABEL_87;
                case '$':
                case '%':
                case '&':
                case '\'':
                  goto LABEL_88;
                default:
                  if (v33 != 54) {
                    goto LABEL_88;
                  }
                  *(_DWORD *)&v239[40] = 55;
                  break;
              }
              goto LABEL_87;
          }
        }
LABEL_88:
        *(void *)&v210[0] = v34;
        if (DWORD2(v241))
        {
LABEL_185:
          if (DWORD2(v241))
          {
LABEL_323:
            BrotliWipeOutMemoryManager((uint64_t)&v240);
            uint64_t v7 = a7;
            unint64_t v25 = v181;
            unint64_t v26 = v182;
            goto LABEL_324;
          }
          unint64_t v90 = 1 << (v18 + 1);
          if (DWORD2(v210[1]) == 65)
          {
            unint64_t v96 = 0x7FFFFFFFFFFFFFFFLL;
            if (v17 < 0x7FFFFFFFFFFFFFFFLL) {
              unint64_t v96 = v17;
            }
            uint64_t v91 = a7;
            if (v96 >= 0x20)
            {
              uint64_t v97 = 0;
              int v98 = 0;
              do
                int v98 = *((unsigned __int8 *)a5 + v97++) + v98 * DWORD1(v213[4]) + 1;
              while (v97 != 32);
              DWORD2(v213[2]) = v98;
            }
            unsigned int v99 = (void *)&v213[3] + 1;
            goto LABEL_211;
          }
          uint64_t v91 = a7;
          if (DWORD2(v210[1]) == 55)
          {
            unint64_t v100 = 0x7FFFFFFFFFFFFFFFLL;
            if (v17 < 0x7FFFFFFFFFFFFFFFLL) {
              unint64_t v100 = v17;
            }
            if (v100 < 0x20) {
              goto LABEL_210;
            }
            unint64_t v101 = 0;
            int v94 = 0;
            do
            {
              int v94 = *((unsigned __int8 *)a5 + v101) + v94 * HIDWORD(v213[0]) + 1;
              BOOL v95 = v101 >= 0x1C;
              v101 += 4;
            }
            while (!v95);
          }
          else
          {
            if (DWORD2(v210[1]) != 35)
            {
LABEL_212:
              char v174 = v30;
              uint64_t v171 = 0;
              uint64_t v102 = 0;
              unint64_t v175 = 0;
              unint64_t v183 = v90 >> 3;
              unint64_t v185 = 1 << v29;
              unint64_t __dst = v91;
              uint64_t v170 = 1 << (v18 + 1);
              do
              {
                unint64_t v103 = v102 + v90;
                if (v10 < v102 + v90) {
                  unint64_t v103 = v10;
                }
                unint64_t v187 = v103;
                unint64_t v104 = v103 - v102;
                unint64_t v209 = 0;
                unint64_t v208 = 0;
                unint64_t v207 = 0;
                size_t v177 = v102;
                if (*(int *)&v239[4] < 10 || BrotliIsMostlyUTF8((uint64_t)a5, v102, 0x7FFFFFFFFFFFFFFFLL, v104, 0.75)) {
                  int v105 = 2;
                }
                else {
                  int v105 = 3;
                }
                unint64_t v106 = 0;
                size_t v191 = 0;
                size_t v107 = 0;
                unint64_t v188 = 0;
                unint64_t v184 = v104 / 0xC + 16;
                unsigned int v172 = v105;
                v186 = &_kBrotliContextLookupTable[v105 << 9];
                unint64_t v108 = v177;
                while (v187 > v108)
                {
                  size_t v189 = v107;
                  __src = (void *)v106;
                  if (v187 - v108 >= v185) {
                    unint64_t v109 = v185;
                  }
                  else {
                    unint64_t v109 = v187 - v108;
                  }
                  if (v109 == -1) {
                    v192 = 0;
                  }
                  else {
                    v192 = (_DWORD *)BrotliAllocate((uint64_t)&v240);
                  }
                  if (DWORD2(v241)) {
                    goto LABEL_322;
                  }
                  BrotliInitZopfliNodes((uint64_t)v192, v109 + 1);
                  if (v108 >= 0x80 && v109 >= 3)
                  {
                    unint64_t v110 = v108 - 127;
                    unint64_t v111 = v109 + v108 - 127;
                    if (v108 < v111) {
                      unint64_t v111 = v108;
                    }
                    if (v110 < v111)
                    {
                      unint64_t v112 = (unint64_t)v211[0];
                      uint64_t v113 = v211[1];
                      int v114 = __b[1];
                      do
                      {
                        uint64_t v115 = v110 & 0x7FFFFFFFFFFFFFFFLL;
                        uint64_t v116 = 15;
                        if (v108 - v110 > 0xF) {
                          uint64_t v116 = v108 - v110;
                        }
                        unsigned int v117 = (506832829 * *(_DWORD *)((char *)a5 + (v110 & 0x7FFFFFFFFFFFFFFFLL))) >> 15;
                        uint64_t v118 = v113[v117];
                        uint64_t v119 = 2 * (v110 & v112);
                        uint64_t v120 = v119 | 1;
                        v113[v117] = v110;
                        if (v110 != v118)
                        {
                          unint64_t v122 = 0;
                          unint64_t v123 = 0;
                          int v124 = (char *)(v112 - v116);
                          uint64_t v125 = (char *)a5 + v115;
                          uint64_t v126 = 64;
                          do
                          {
                            if (v110 - v118 > (unint64_t)v124 || v126 == 0) {
                              break;
                            }
                            if (v123 >= v122) {
                              unint64_t v128 = v122;
                            }
                            else {
                              unint64_t v128 = v123;
                            }
                            uint64_t v129 = (unsigned __int8 *)a5 + v128 + v118;
                            unint64_t v130 = 128 - v128;
                            if (128 - v128 < 8)
                            {
                              unint64_t v133 = 0;
LABEL_260:
                              uint64_t v138 = v130 & 7;
                              if (v138)
                              {
                                unint64_t v139 = v133 | v138;
                                while (v125[v128 + v133] == *v129)
                                {
                                  ++v129;
                                  ++v133;
                                  if (!--v138)
                                  {
                                    unint64_t v133 = v139;
                                    break;
                                  }
                                }
                              }
                            }
                            else
                            {
                              uint64_t v131 = 0;
                              unint64_t v132 = v130 >> 3;
                              unint64_t v133 = v130 & 0xFFFFFFFFFFFFFFF8;
                              while (1)
                              {
                                uint64_t v134 = *(void *)&v129[v131];
                                uint64_t v135 = *(void *)&v125[v128 + v131];
                                if (v134 != v135) {
                                  break;
                                }
                                v131 += 8;
                                if (!--v132)
                                {
                                  v129 += v130 & 0xFFFFFFFFFFFFFFF8;
                                  goto LABEL_260;
                                }
                              }
                              unint64_t v133 = v131 + (__clz(__rbit64(v135 ^ v134)) >> 3);
                            }
                            unint64_t v136 = v133 + v128;
                            if (v136 >= 0x80)
                            {
                              uint64_t v140 = &v114[2 * (v118 & v112)];
                              v114[v119] = *v140;
                              int v121 = v140[1];
                              goto LABEL_237;
                            }
                            uint64_t v137 = 2 * (v118 & v112);
                            if (*((unsigned __int8 *)a5 + v136 + v115) <= *((unsigned __int8 *)a5
                                                                                         + v136
                                                                                         + v118))
                            {
                              v114[v120] = v118;
                              uint64_t v120 = 2 * (v118 & v112);
                              unint64_t v122 = v136;
                            }
                            else
                            {
                              v114[v119] = v118;
                              v137 |= 1uLL;
                              uint64_t v119 = v137;
                              unint64_t v123 = v136;
                            }
                            uint64_t v118 = v114[v137];
                            --v126;
                          }
                          while (v110 != v118);
                        }
                        v114[v119] = __b[0];
                        int v121 = (int)__b[0];
LABEL_237:
                        v114[v120] = v121;
                        ++v110;
                      }
                      while (v110 != v111);
                    }
                  }
                  uint64_t v141 = BrotliZopfliComputeShortestPath((uint64_t)&v240, v109, v108, (uint64_t)a5, 0x7FFFFFFFFFFFFFFFLL, (uint64_t)v186, (uint64_t)v239, (uint64_t)&v273, v210, v192);
                  if (DWORD2(v241)) {
                    goto LABEL_322;
                  }
                  size_t v142 = v141 + v191;
                  if (v184 <= v141 + v191 + 1) {
                    unint64_t v143 = v142 + 1;
                  }
                  else {
                    unint64_t v143 = v184;
                  }
                  if (v188 == v143)
                  {
                    unint64_t v144 = v183;
                  }
                  else
                  {
                    uLong v145 = (void *)BrotliAllocate((uint64_t)&v240);
                    if (DWORD2(v241)) {
                      goto LABEL_322;
                    }
                    unint64_t v106 = (unint64_t)v145;
                    if (__src)
                    {
                      memcpy(v145, __src, 16 * v191);
                      BrotliFree((uint64_t)&v240, (unint64_t)__src);
                    }
                    unint64_t v188 = v143;
                    unint64_t v144 = v183;
                  }
                  BrotliZopfliCreateCommands(v109, v108, (uint64_t)v192, (uint64_t)&v273, &v209, (uint64_t)v239, v106 + 16 * v191, &v208);
                  size_t v107 = v109 + v189;
                  BrotliFree((uint64_t)&v240, (unint64_t)v192);
                  if (v142 <= v144)
                  {
                    v108 += v109;
                    size_t v191 = v142;
                    if (v208 <= v144) {
                      continue;
                    }
                  }
                  goto LABEL_280;
                }
                size_t v142 = v191;
LABEL_280:
                unint64_t v146 = v209;
                if (v209)
                {
                  unint64_t v147 = v106 + 16 * v142;
                  *(_DWORD *)unint64_t v147 = v209;
                  *(void *)(v147 + 4) = 0x8000000;
                  *(_WORD *)(v147 + 14) = 16;
                  unint64_t v148 = v176;
                  if (v146 > 5)
                  {
                    if (v146 > 0x81)
                    {
                      if (v146 > 0x841)
                      {
                        if (v146 >> 1 >= 0xC21)
                        {
                          if (v146 < 0x5842) {
                            LOWORD(v149) = 22;
                          }
                          else {
                            LOWORD(v149) = 23;
                          }
                        }
                        else
                        {
                          LOWORD(v149) = 21;
                        }
                      }
                      else
                      {
                        unsigned int v149 = (__clz(v146 - 66) ^ 0x1F) + 10;
                      }
                    }
                    else
                    {
                      unsigned int v150 = (__clz(v146 - 2) ^ 0x1F) - 1;
                      unsigned int v149 = ((v146 - 2) >> v150) + 2 * v150 + 2;
                    }
                  }
                  else
                  {
                    LOWORD(v149) = v146;
                  }
                  ++v142;
                  *(_WORD *)(v147 + 12) = ((((0x520D40u >> (6 * ((unsigned __int16)v149 >> 3))) & 0xC0)
                                          + 192 * ((unsigned __int16)v149 >> 3)) & 0xFFC7 | (8 * (v149 & 7)))
                                        + 66;
                  v208 += v146;
                }
                else
                {
                  unint64_t v148 = v176;
                }
                unint64_t v151 = v107 + v177;
                BOOL v152 = v107 + v177 == v10;
                unint64_t v207 = v148;
                if (v107)
                {
                  if (ShouldCompress((uint64_t)a5, 0xFFFFFFFF, v177, v107, v208, v142))
                  {
                    long long v205 = 0u;
                    long long v206 = 0u;
                    long long v203 = 0u;
                    long long v204 = 0u;
                    long long v202 = 0u;
                    memset(v201, 0, sizeof(v201));
                    memset(v200, 0, sizeof(v200));
                    memset(v199, 0, sizeof(v199));
                    long long v196 = *(_OWORD *)&v239[96];
                    long long v197 = *(_OWORD *)&v239[112];
                    long long v198 = *(_OWORD *)&v239[128];
                    v193[2] = *(_OWORD *)&v239[32];
                    v193[3] = *(_OWORD *)&v239[48];
                    *(_OWORD *)v194 = *(_OWORD *)&v239[64];
                    long long v195 = *(_OWORD *)&v239[80];
                    v193[0] = *(_OWORD *)v239;
                    v193[1] = *(_OWORD *)&v239[16];
                    BrotliInitBlockSplit(v199);
                    BrotliInitBlockSplit(v200);
                    BrotliInitBlockSplit(v201);
                    long long v205 = 0u;
                    long long v206 = 0u;
                    long long v203 = 0u;
                    long long v204 = 0u;
                    long long v202 = 0u;
                    BrotliBuildMetaBlock(&v240, (uint64_t)a5, v177, 0x7FFFFFFFFFFFFFFFuLL, (uint64_t)v193, BYTE4(v171), v171, v106, v142, v172, (uint64_t *)v199);
                    if (DWORD2(v241)) {
                      goto LABEL_322;
                    }
                    BrotliOptimizeHistograms(v194[3], v199);
                    uint64_t v153 = (unsigned char *)BrotliAllocate((uint64_t)&v240);
                    if (DWORD2(v241)) {
                      goto LABEL_322;
                    }
                    int v154 = v153;
                    *uint64_t v153 = v174;
                    v153[1] = v180;
                    BrotliStoreMetaBlock((uint64_t)&v240, (uint64_t)a5, v177, v107, 0x7FFFFFFFFFFFFFFFLL, BYTE4(v171), v171, v152, (unsigned int *)v193, v172, v106, v142, (uint64_t)v199, &v207, (uint64_t)v153);
                    if (DWORD2(v241)) {
                      goto LABEL_322;
                    }
                    if (v107 + 4 < v207 >> 3)
                    {
                      long long v273 = v272;
                      *int v154 = v174;
                      v154[1] = v180;
                      unint64_t v207 = v148;
                      BrotliStoreUncompressedMetaBlock(v152, (uint64_t)a5, v177, 0x7FFFFFFFFFFFFFFFLL, v107, (uint64_t *)&v207, (uint64_t)v154);
                    }
                    BrotliDestroyBlockSplit((uint64_t)&v240, (uint64_t)v199);
                    BrotliDestroyBlockSplit((uint64_t)&v240, (uint64_t)v200);
                    BrotliDestroyBlockSplit((uint64_t)&v240, (uint64_t)v201);
                    BrotliFree((uint64_t)&v240, v202);
                    *(void *)&long long v202 = 0;
                    BrotliFree((uint64_t)&v240, v203);
                    *(void *)&long long v203 = 0;
                    BrotliFree((uint64_t)&v240, v204);
                    *(void *)&long long v204 = 0;
                    BrotliFree((uint64_t)&v240, v205);
                    *(void *)&long long v205 = 0;
                    BrotliFree((uint64_t)&v240, v206);
                  }
                  else
                  {
                    long long v273 = v272;
                    if (v107 == -16) {
                      int v154 = 0;
                    }
                    else {
                      int v154 = (unsigned char *)BrotliAllocate((uint64_t)&v240);
                    }
                    if (DWORD2(v241))
                    {
LABEL_322:
                      unint64_t v8 = a6;
                      goto LABEL_323;
                    }
                    *int v154 = v174;
                    v154[1] = v180;
                    BrotliStoreUncompressedMetaBlock(v152, (uint64_t)a5, v177, 0x7FFFFFFFFFFFFFFFLL, v107, (uint64_t *)&v207, (uint64_t)v154);
                  }
                }
                else
                {
                  uint64_t v155 = (unsigned char *)BrotliAllocate((uint64_t)&v240);
                  if (DWORD2(v241)) {
                    goto LABEL_322;
                  }
                  int v154 = v155;
                  unsigned char *v155 = v174;
                  v155[1] = v180;
                  int v156 = v207;
                  *(void *)&v155[v207 >> 3] = (3 << (v207 & 7)) | v155[v207 >> 3];
                  unint64_t v207 = (v156 + 9) & 0xFFFFFFF8;
                }
                uint64_t v7 = a7;
                char v157 = v207;
                unint64_t v158 = v207 >> 3;
                char v174 = v154[v207 >> 3];
                if (v151 < v10)
                {
                  LOBYTE(v171) = *((unsigned char *)a5 + v151 - 2);
                  BYTE4(v171) = *((unsigned char *)a5 + v151 - 1);
                }
                long long v272 = v273;
                v175 += v158;
                if (v175 <= v182)
                {
                  memcpy(__dst, v154, v207 >> 3);
                  __dst += v158;
                }
                BrotliFree((uint64_t)&v240, (unint64_t)v154);
                BrotliFree((uint64_t)&v240, v106);
                unint64_t v26 = v182;
                unint64_t v90 = v170;
                if (v151 >= v10) {
                  break;
                }
                char v180 = 0;
                uint64_t v176 = v157 & 7;
                uint64_t v102 = v107 + v177;
              }
              while (v175 <= v182);
              unint64_t v8 = a6;
              *a6 = v175;
              if (*(void *)&v210[0]) {
                BrotliFree((uint64_t)&v240, *(unint64_t *)&v210[0]);
              }
              unint64_t v25 = v181;
              if (v175 <= v182 && (!v181 || *a6 <= v181)) {
                return 1;
              }
LABEL_324:
              *unint64_t v8 = 0;
              if (v25 - 1 < v26)
              {
                uint64_t v159 = v8;
                uint64_t v160 = 0;
                *uint64_t v7 = 801;
                uint64_t v161 = 2;
                do
                {
                  if (v10 >= 0x1000000) {
                    size_t v162 = 0x1000000;
                  }
                  else {
                    size_t v162 = v10;
                  }
                  if (v162 <= 0x100000) {
                    int v163 = 1;
                  }
                  else {
                    int v163 = 2;
                  }
                  if (v162 <= 0x10000) {
                    int v163 = 0;
                  }
                  int v164 = 8 * v162 - 8;
                  int v165 = v164 | (2 * v163);
                  int v166 = (1 << ((4 * v163) | 0x13)) | v165;
                  v167 = (char *)v7 + v161;
                  unsigned char *v167 = v165;
                  v167[1] = BYTE1(v164);
                  uint64_t v168 = v161 + 3;
                  v167[2] = BYTE2(v166);
                  if (v162 > 0x100000)
                  {
                    *((unsigned char *)v7 + v168) = HIBYTE(v166);
                    uint64_t v168 = v161 + 4;
                  }
                  memcpy((char *)v7 + v168, (char *)a5 + v160, v162);
                  uint64_t v161 = v168 + v162;
                  v160 += v162;
                  v10 -= v162;
                }
                while (v10);
                *((unsigned char *)v7 + v161) = 3;
                *uint64_t v159 = v161 + 1;
                return 1;
              }
              return 0;
            }
            unint64_t v92 = 0x7FFFFFFFFFFFFFFFLL;
            if (v17 < 0x7FFFFFFFFFFFFFFFLL) {
              unint64_t v92 = v17;
            }
            if (v92 < 0x20) {
              goto LABEL_210;
            }
            unint64_t v93 = 0;
            int v94 = 0;
            do
            {
              int v94 = *((unsigned __int8 *)a5 + v93) + v94 * HIDWORD(v213[0]) + 1;
              BOOL v95 = v93 >= 0x1C;
              v93 += 4;
            }
            while (!v95);
          }
          LODWORD(__b[0]) = v94;
LABEL_210:
          unsigned int v99 = v213;
LABEL_211:
          void *v99 = 0;
          goto LABEL_212;
        }
        *(_OWORD *)((char *)&v210[1] + 8) = *(_OWORD *)&v239[40];
        DWORD2(v210[2]) = *(_DWORD *)&v239[56];
        int v32 = *(_DWORD *)&v239[40];
        if (*(int *)&v239[40] <= 34)
        {
          switch(*(_DWORD *)&v239[40])
          {
            case 2:
            case 3:
            case 4:
              goto LABEL_102;
            case 5:
              v211[0] = (void *)(1 << SBYTE12(v210[1]));
              v211[1] = (void *)(1 << SLOBYTE(v210[2]));
              LODWORD(__b[0]) = 32 - HIDWORD(v210[1]);
              HIDWORD(__b[0]) = (1 << SLOBYTE(v210[2])) - 1;
              *(void *)&v213[0] = v210;
              *((void *)&v213[0] + 1) = v34;
              *(void *)&v213[1] = v34 + 2 * (1 << SBYTE12(v210[1]));
              __b[1] = (void *)__PAIR64__(DWORD2(v210[2]), v210[2]);
              break;
            case 6:
              LODWORD(__b[0]) = 64 - HIDWORD(v210[1]);
              __b[1] = (void *)(0xFFFFFFFFFFFFFFFFLL >> (-8 * BYTE4(v210[2])));
              v211[0] = (void *)(1 << SBYTE12(v210[1]));
              v211[1] = (void *)(1 << SLOBYTE(v210[2]));
              *(void *)((char *)v213 + 4) = __PAIR64__(DWORD2(v210[2]), v210[2]);
              LODWORD(v213[0]) = (1 << SLOBYTE(v210[2])) - 1;
              *(void *)&v213[1] = v210;
              *((void *)&v213[1] + 1) = v34;
              *(void *)&v213[2] = v34 + 2 * (1 << SBYTE12(v210[1]));
              break;
            case 0xA:
              __b[1] = (void *)(v34 + 0x80000);
              v211[1] = (void *)v34;
              v211[0] = (void *)~(-1 << v239[8]);
              LODWORD(__b[0]) = (-1 << v239[8]) + 1;
              break;
            default:
              break;
          }
        }
        else if (*(int *)&v239[40] > 53)
        {
          switch(*(_DWORD *)&v239[40])
          {
            case '6':
LABEL_102:
              v211[0] = v210;
              v211[1] = (void *)v34;
              break;
            case '7':
LABEL_104:
              *(void *)&long long v214 = v210;
              *((void *)&v213[4] + 1) = v34;
              *(_OWORD *)((char *)&v213[1] + 8) = v210[0];
              *(_OWORD *)((char *)&v213[2] + 8) = v210[1];
              *(_OWORD *)((char *)&v213[3] + 8) = v210[2];
              DWORD2(v214) = 1;
              *(void *)&long long v215 = v239;
              break;
            case 'A':
              *((void *)&v217 + 1) = v210;
              *(void *)&long long v217 = v34;
              long long v214 = v210[0];
              long long v215 = v210[1];
              long long v216 = v210[2];
              LODWORD(v218) = 1;
              *((void *)&v218 + 1) = v239;
              break;
          }
        }
        else
        {
          switch(*(_DWORD *)&v239[40])
          {
            case '#':
              goto LABEL_104;
            case '(':
            case ')':
              __b[1] = v210;
              if (*(int *)&v239[4] >= 7) {
                int v39 = 7;
              }
              else {
                int v39 = 8;
              }
              __b[0] = (void *)v34;
              v211[1] = (void *)(v39 << (v239[4] - 4));
              break;
            case '*':
              v238 = v210;
              v237 = (void *)v34;
              if (*(int *)&v239[4] >= 7) {
                int v43 = 7;
              }
              else {
                int v43 = 8;
              }
              uint64_t v236 = (v43 << (v239[4] - 4));
              break;
            default:
              break;
          }
        }
        HIDWORD(v210[2]) = 0;
LABEL_122:
        if (v32 <= 34)
        {
          switch(v32)
          {
            case 2:
              unint64_t v44 = v211[1];
              if (v17 > 0x800) {
                goto LABEL_154;
              }
              size_t v45 = a5;
              unint64_t v46 = v17;
              do
              {
                uint64_t v47 = *v45;
                size_t v45 = (uint64_t *)((char *)v45 + 1);
                *(_DWORD *)((char *)v44 + (((0xBD1E35A7BD000000 * v47) >> 46) & 0x3FFFC)) = 0;
                --v46;
              }
              while (v46);
              break;
            case 3:
              unint64_t v44 = v211[1];
              if (v17 > 0x800)
              {
LABEL_154:
                size_t v60 = 0x40000;
                goto LABEL_183;
              }
              uint64_t v48 = a5;
              unint64_t v49 = v17;
              do
              {
                uint64_t v50 = *v48;
                uint64_t v48 = (uint64_t *)((char *)v48 + 1);
                unint64_t v51 = (0xBD1E35A7BD000000 * v50) >> 48;
                v44[v51] = 0;
                v44[(unsigned __int16)(v51 + 8)] = 0;
                --v49;
              }
              while (v49);
              break;
            case 4:
              unint64_t v44 = v211[1];
              if (v17 > 0x1000)
              {
                size_t v60 = 0x80000;
                goto LABEL_183;
              }
              uint64_t v52 = 0;
              do
              {
                int v53 = 0;
                unint64_t v54 = (0xBD1E35A7BD000000 * *(uint64_t *)((char *)a5 + v52)) >> 47;
                do
                {
                  v44[(v54 + v53) & 0x1FFFF] = 0;
                  v53 += 8;
                }
                while (v53 != 32);
                ++v52;
              }
              while (v52 != v17);
              break;
            case 5:
              unint64_t v44 = (_DWORD *)*((void *)&v213[0] + 1);
              uint64_t v55 = v211[0];
              if (v17 > (unint64_t)v211[0] >> 6) {
                goto LABEL_150;
              }
              char v56 = (char)__b[0];
              unint64_t v57 = a5;
              unint64_t v58 = v17;
              do
              {
                int v59 = *(_DWORD *)v57;
                unint64_t v57 = (uint64_t *)((char *)v57 + 1);
                *((_WORD *)v44 + ((506832829 * v59) >> v56)) = 0;
                --v58;
              }
              while (v58);
              break;
            case 6:
              unint64_t v44 = (_DWORD *)*((void *)&v213[1] + 1);
              uint64_t v55 = v211[0];
              if (v17 > (unint64_t)v211[0] >> 6)
              {
LABEL_150:
                size_t v60 = 2 * (void)v55;
                goto LABEL_183;
              }
              unint64_t v85 = (unint64_t)__b[1];
              char v86 = (char)__b[0];
              int v87 = a5;
              unint64_t v88 = v17;
              do
              {
                uint64_t v89 = *v87;
                int v87 = (uint64_t *)((char *)v87 + 1);
                *((_WORD *)v44 + ((0x1FE35A7BD3579BD3 * (v89 & v85)) >> v86)) = 0;
                --v88;
              }
              while (v88);
              break;
            case 10:
              uint64_t v61 = 0;
              int v62 = (char *)v211[1];
              int v63 = __b;
              float32x4_t v64 = vld1q_dup_f32((const float *)v63);
              do
              {
                *(float32x4_t *)&v62[v61] = v64;
                v61 += 16;
              }
              while (v61 != 0x80000);
              break;
            default:
              break;
          }
        }
        else if (v32 > 53)
        {
          switch(v32)
          {
            case '6':
              unint64_t v44 = v211[1];
              if (v17 > 0x8000)
              {
                size_t v60 = 0x400000;
LABEL_183:
                bzero(v44, v60);
              }
              else
              {
                uint64_t v82 = 0;
                do
                {
                  int v83 = 0;
                  unint64_t v84 = (unint64_t)(0x35A7BD1E35A7BD00 * *(uint64_t *)((char *)a5 + v82)) >> 44;
                  do
                  {
                    v44[(v84 + v83) & 0xFFFFF] = 0;
                    v83 += 8;
                  }
                  while (v83 != 32);
                  ++v82;
                }
                while (v82 != v17);
              }
              break;
            case '7':
              PrepareH55((uint64_t)v211, 1, v17, (uint64_t)a5);
              break;
            case 'A':
              PrepareH65((uint64_t)v211, 1, v17, a5);
              break;
          }
        }
        else
        {
          switch(v32)
          {
            case '#':
              PrepareH35((uint64_t)v211, 1, v17, a5);
              break;
            case '(':
              char v65 = v30;
              uint64_t v66 = __b[0];
              uint64_t v67 = (char *)__b[0] + 0x20000;
              if (v17 > 0x200) {
                goto LABEL_167;
              }
              int v68 = a5;
              unint64_t v69 = v17;
              do
              {
                int v70 = *(_DWORD *)v68;
                int v68 = (uint64_t *)((char *)v68 + 1);
                unsigned int v71 = (506832829 * v70) >> 17;
                v66[v71] = -858993460;
                *(_WORD *)&v67[2 * v71] = -13108;
                --v69;
              }
              while (v69);
              goto LABEL_168;
            case ')':
              char v65 = v30;
              uint64_t v66 = __b[0];
              uint64_t v67 = (char *)__b[0] + 0x20000;
              if (v17 > 0x200)
              {
LABEL_167:
                memset(v66, 204, 0x20000uLL);
                bzero(v67, 0x10000uLL);
              }
              else
              {
                long long v72 = a5;
                unint64_t v73 = v17;
                do
                {
                  int v74 = *(_DWORD *)v72;
                  long long v72 = (uint64_t *)((char *)v72 + 1);
                  unsigned int v75 = (506832829 * v74) >> 17;
                  v66[v75] = -858993460;
                  *(_WORD *)&v67[2 * v75] = -13108;
                  --v73;
                }
                while (v73);
              }
LABEL_168:
              bzero(v66 + 49152, 0x10000uLL);
              LOWORD(v211[0]) = 0;
              char v30 = v65;
              break;
            case '*':
              char v173 = v30;
              unsigned int v76 = v237;
              int v77 = (char *)v237 + 0x20000;
              if (v17 > 0x200)
              {
                memset(v237, 204, 0x20000uLL);
                bzero(v77, 0x10000uLL);
              }
              else
              {
                unsigned int v78 = a5;
                unint64_t v79 = v17;
                do
                {
                  int v80 = *(_DWORD *)v78;
                  unsigned int v78 = (uint64_t *)((char *)v78 + 1);
                  unsigned int v81 = (506832829 * v80) >> 17;
                  v76[v81] = -858993460;
                  *(_WORD *)&v77[2 * v81] = -13108;
                  --v79;
                }
                while (v79);
              }
              bzero(v76 + 49152, 0x10000uLL);
              bzero(v211, 0x400uLL);
              char v30 = v173;
              break;
            default:
              break;
          }
        }
        *(void *)&v210[1] = 0;
        *((void *)&v210[0] + 1) = 0;
        HIDWORD(v210[2]) = 1;
        goto LABEL_185;
      }
      char v180 = 0;
      char v30 = 1;
      uint64_t v31 = 7;
    }
    uint64_t v176 = v31;
    goto LABEL_42;
  }
  return 0;
}

uint64_t BrotliEncoderCompressStream(uint64_t a1, int a2, unint64_t *a3, const void **a4, size_t *a5, void **a6, size_t *a7)
{
  if (*(_DWORD *)(a1 + 168)) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 8636)) {
    goto LABEL_50;
  }
  *(_DWORD *)(a1 + 2432) = -33554432;
  *(_DWORD *)(a1 + 8624) = -1;
  unsigned int v15 = *(_DWORD *)(a1 + 4) & ~(*(int *)(a1 + 4) >> 31);
  if ((int)v15 >= 11) {
    unsigned int v15 = 11;
  }
  *(_DWORD *)(a1 + 4) = v15;
  if (v15 <= 2) {
    *(_DWORD *)(a1 + 36) = 0;
  }
  int v16 = *(_DWORD *)(a1 + 8);
  if (v16 < 10)
  {
    unsigned int v17 = 10;
LABEL_15:
    *(_DWORD *)(a1 + 8) = v17;
    int v16 = v17;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a1 + 36)) {
    unsigned int v17 = 30;
  }
  else {
    unsigned int v17 = 24;
  }
  if (v16 > v17) {
    goto LABEL_15;
  }
LABEL_16:
  if (v15 >= 2)
  {
    if (v15 >= 4)
    {
      int v19 = *(_DWORD *)(a1 + 12);
      if (v19)
      {
        if (v19 <= 16) {
          int v20 = 16;
        }
        else {
          int v20 = *(_DWORD *)(a1 + 12);
        }
        if (v20 >= 24) {
          int v18 = 24;
        }
        else {
          int v18 = v20;
        }
      }
      else
      {
        int v18 = 16;
        if (v15 >= 9)
        {
          if (v16 >= 18) {
            int v21 = 18;
          }
          else {
            int v21 = v16;
          }
          if (v21 <= 16) {
            int v18 = 16;
          }
          else {
            int v18 = v21;
          }
        }
      }
    }
    else
    {
      int v18 = 14;
    }
  }
  else
  {
    int v18 = v16;
  }
  *(_DWORD *)(a1 + 12) = v18;
  ChooseDistanceParams((_DWORD *)a1);
  unint64_t v22 = *(void *)(a1 + 16);
  if (v22)
  {
    *(unsigned char *)(a1 + 2435) = 2;
    *(void *)&long long v23 = 0xF0000000FLL;
    *((void *)&v23 + 1) = 0xF0000000FLL;
    *(_OWORD *)(a1 + 2352) = v23;
    *(_OWORD *)(a1 + 2416) = *(_OWORD *)(a1 + 2352);
  }
  int v25 = *(_DWORD *)(a1 + 8);
  int v24 = *(_DWORD *)(a1 + 12);
  unsigned int v26 = *(_DWORD *)(a1 + 4);
  if (v25 <= v24) {
    char v27 = *(_DWORD *)(a1 + 12);
  }
  else {
    char v27 = *(_DWORD *)(a1 + 8);
  }
  int v28 = 1 << (v27 + 1);
  *(_DWORD *)(a1 + 2260) = v28 - 1;
  *(_DWORD *)(a1 + 2256) = v28;
  int v29 = 1 << v24;
  *(_DWORD *)(a1 + 2264) = v29;
  *(_DWORD *)(a1 + 2268) = v28 + v29;
  if (v25 <= 18) {
    int v30 = 18;
  }
  else {
    int v30 = v25;
  }
  if (v26 >= 2) {
    int v30 = v25;
  }
  if (v22)
  {
    unint64_t v31 = (1 << v30) - 16;
    if (v22 >= v31) {
      unint64_t v22 = v31;
    }
    *(void *)(a1 + 16) = v22;
    if (v26) {
      goto LABEL_49;
    }
  }
  else
  {
    if (*(_DWORD *)(a1 + 36))
    {
      __int16 v44 = ((v30 & 0x3F) << 8) | 0x11;
      char v45 = 14;
    }
    else if (v30 == 16)
    {
      __int16 v44 = 0;
      char v45 = 1;
    }
    else if (v30 == 17)
    {
      char v45 = 7;
      __int16 v44 = 1;
    }
    else if (v30 < 18)
    {
      __int16 v44 = 16 * v30 - 127;
      char v45 = 7;
    }
    else
    {
      __int16 v44 = 2 * v30 - 33;
      char v45 = 4;
    }
    *(_WORD *)(a1 + 2432) = v44;
    *(unsigned char *)(a1 + 2434) = v45;
    if (v26) {
      goto LABEL_49;
    }
  }
  *(_OWORD *)(a1 + 7728) = xmmword_20DAB5B30;
  *(_OWORD *)(a1 + 7744) = unk_20DAB5B40;
  *(_OWORD *)(a1 + 7760) = xmmword_20DAB5B50;
  *(_OWORD *)(a1 + 7776) = unk_20DAB5B60;
  *(_OWORD *)(a1 + 7664) = InitCommandPrefixCodes_kDefaultCommandDepths;
  *(_OWORD *)(a1 + 7680) = unk_20DAB5B00;
  *(_OWORD *)(a1 + 7696) = xmmword_20DAB5B10;
  *(_OWORD *)(a1 + 7712) = unk_20DAB5B20;
  *(_OWORD *)(a1 + 7840) = unk_20DAB5BA0;
  *(_OWORD *)(a1 + 7824) = xmmword_20DAB5B90;
  *(_OWORD *)(a1 + 7808) = unk_20DAB5B80;
  *(_OWORD *)(a1 + 7792) = InitCommandPrefixCodes_kDefaultCommandBits;
  *(_OWORD *)(a1 + 7904) = unk_20DAB5BE0;
  *(_OWORD *)(a1 + 7888) = xmmword_20DAB5BD0;
  *(_OWORD *)(a1 + 7872) = unk_20DAB5BC0;
  *(_OWORD *)(a1 + 7856) = xmmword_20DAB5BB0;
  *(_OWORD *)(a1 + 7968) = unk_20DAB5C20;
  *(_OWORD *)(a1 + 7952) = xmmword_20DAB5C10;
  *(_OWORD *)(a1 + 7936) = unk_20DAB5C00;
  *(_OWORD *)(a1 + 7920) = xmmword_20DAB5BF0;
  *(_OWORD *)(a1 + 8032) = unk_20DAB5C60;
  *(_OWORD *)(a1 + 8016) = xmmword_20DAB5C50;
  *(_OWORD *)(a1 + 8000) = unk_20DAB5C40;
  *(_OWORD *)(a1 + 7984) = xmmword_20DAB5C30;
  strcpy((char *)(a1 + 8048), "\xFFwտ\xE7\xDE\xEA\x9EQ]\xDE\xC6pW\xBCX");
  strcpy((char *)(a1 + 8064), "XX\xD8\xD8X\xD5\xCB\x8C\xEA\xE0\xC3\x87\x1F\x83\xC1\x60\x1Cg\xB2\xAA\x06\x83\xC1\x600\x18̡ΈT\x94");
  *(unsigned char *)(a1 + 8095) = InitCommandPrefixCodes_kDefaultCommandCode[47];
  *(_OWORD *)(a1 + 8089) = *(_OWORD *)"\x18̡ΈT\x94F\xE1\xB0\xD0N\xB2\xF7\x04b";
  *(void *)(a1 + 8560) = 448;
LABEL_49:
  *(_DWORD *)(a1 + 8636) = 1;
LABEL_50:
  uint64_t v32 = *(unsigned int *)(a1 + 8624);
  if (v32 != -1)
  {
    uint64_t result = 0;
    if (a2 != 3 || *a3 != v32) {
      return result;
    }
    goto LABEL_55;
  }
  if (a2 == 3)
  {
LABEL_55:
    if (!*(void *)(a1 + 24))
    {
      uint64_t v33 = 0x40000000;
      if (!((*(void *)(a1 + 2248) - *(void *)(a1 + 2344)) >> 30)) {
        uint64_t v33 = (*(_DWORD *)(a1 + 2248) - *(_DWORD *)(a1 + 2344));
      }
      *(void *)(a1 + 24) = v33;
    }
    if (*a3 > 0x1000000) {
      return 0;
    }
    int v34 = *(_DWORD *)(a1 + 8628);
    if (!v34)
    {
      *(_DWORD *)(a1 + 8624) = *a3;
      *(_DWORD *)(a1 + 8628) = 3;
LABEL_83:
      unint64_t v46 = (_WORD *)(a1 + 8608);
      while (1)
      {
        while (1)
        {
          while (1)
          {
            while (InjectFlushOrPushOutput(a1, a5, a6, a7))
              ;
            if (*(void *)(a1 + 8592)) {
              return 1;
            }
            if (*(void *)(a1 + 2248) == *(void *)(a1 + 2336)) {
              break;
            }
            uint64_t result = EncodeData(a1, 0, 1, (unint64_t *)(a1 + 8592), (uint64_t *)(a1 + 8584), v47, v48, v49);
            if (!result) {
              return result;
            }
          }
          if (*(_DWORD *)(a1 + 8628) == 3) {
            break;
          }
          size_t v54 = *(unsigned int *)(a1 + 8624);
          if (!v54)
          {
            *(void *)(a1 + 8624) = 0xFFFFFFFFLL;
            return 1;
          }
          if (*a5)
          {
            if (v54 >= *a5) {
              size_t v55 = *a5;
            }
            else {
              size_t v55 = *(unsigned int *)(a1 + 8624);
            }
            memcpy(*a6, *a4, v55);
            *a4 = (char *)*a4 + v55;
            *a3 -= v55;
            *(_DWORD *)(a1 + 8624) -= v55;
            *a6 = (char *)*a6 + v55;
            *a5 -= v55;
          }
          else
          {
            if (v54 >= 0x10) {
              size_t v56 = 16;
            }
            else {
              size_t v56 = v54;
            }
            *(void *)(a1 + 8584) = v46;
            memcpy((void *)(a1 + 8608), *a4, v56);
            *a4 = (char *)*a4 + v56;
            *a3 -= v56;
            *(_DWORD *)(a1 + 8624) -= v56;
            *(void *)(a1 + 8592) = v56;
          }
        }
        *(void *)(a1 + 8584) = v46;
        uint64_t v50 = *(unsigned int *)(a1 + 8624);
        unint64_t v51 = *(unsigned __int8 *)(a1 + 2434);
        *unint64_t v46 = *(_WORD *)(a1 + 2432);
        *(_WORD *)(a1 + 2432) = 0;
        *(void *)((char *)v46 + (v51 >> 3)) = *((unsigned __int8 *)v46 + (v51 >> 3));
        *(unsigned char *)(a1 + 2434) = 0;
        *(void *)((char *)v46 + ((v51 + 1) >> 3)) = (3 << ((v51 + 1) & 7)) | *((unsigned __int8 *)v46
                                                                                 + ((v51 + 1) >> 3));
        *(void *)((char *)v46 + ((v51 + 3) >> 3)) = *((unsigned __int8 *)v46 + ((v51 + 3) >> 3));
        unint64_t v52 = v51 + 4;
        if (v50 == 1)
        {
          unsigned int v57 = 0;
        }
        else
        {
          if (!v50)
          {
            *(void *)((char *)v46 + (v52 >> 3)) = *((unsigned __int8 *)v46 + (v52 >> 3));
            unint64_t v53 = v51 + 6;
            goto LABEL_106;
          }
          unsigned int v57 = ((__clz(v50 - 1) ^ 0x18) + 8) >> 3;
        }
        *(void *)((char *)v46 + (v52 >> 3)) = ((unint64_t)v57 << (v52 & 7)) | *((unsigned __int8 *)v46
                                                                                       + (v52 >> 3));
        unint64_t v58 = v51 + 6;
        *(void *)((char *)v46 + (v58 >> 3)) = ((v50 - 1) << (v58 & 7)) | *((unsigned __int8 *)v46 + (v58 >> 3));
        unint64_t v53 = v58 + 8 * v57;
LABEL_106:
        *(void *)(a1 + 8592) = (v53 + 7) >> 3;
        *(_DWORD *)(a1 + 8628) = 4;
      }
    }
    if ((v34 - 3) <= 1) {
      goto LABEL_83;
    }
    return 0;
  }
  int v35 = *(_DWORD *)(a1 + 8628);
  if ((v35 - 3) < 2 || v35 && *a3) {
    return 0;
  }
  unsigned int v36 = *(_DWORD *)(a1 + 4);
  if (v36 < 2)
  {
    unint64_t v37 = 1 << *(_DWORD *)(a1 + 8);
    unint64_t v38 = *a3;
    if (*a3 >= v37) {
      unint64_t v38 = 1 << *(_DWORD *)(a1 + 8);
    }
    if (v38 >= 0x20000) {
      uint64_t v39 = 0x20000;
    }
    else {
      uint64_t v39 = v38;
    }
    __src = (void *)(a1 + 144);
    if (v36 != 1)
    {
      uint64_t v42 = 0;
      uint64_t v125 = 0;
      uint64_t v43 = 0;
      int v41 = 0;
      goto LABEL_206;
    }
    uint64_t v125 = *(unsigned int **)(a1 + 8568);
    if (v125 || v38 < 0x20000)
    {
      if (v125)
      {
        uint64_t v42 = 0;
        uint64_t v43 = 0;
        int v41 = *(char **)(a1 + 8576);
        goto LABEL_206;
      }
      if (!v39)
      {
        uint64_t v42 = 0;
        uint64_t v43 = 0;
LABEL_205:
        uint64_t v125 = (unsigned int *)v42;
        int v41 = (char *)v43;
        if (*(_DWORD *)(a1 + 168)) {
          return 0;
        }
        goto LABEL_206;
      }
    }
    else
    {
      *(void *)(a1 + 8568) = BrotliAllocate(a1 + 144);
      uint64_t v40 = BrotliAllocate(a1 + 144);
      *(void *)(a1 + 8576) = v40;
      if (*(_DWORD *)(a1 + 168)) {
        return 0;
      }
      uint64_t v125 = *(unsigned int **)(a1 + 8568);
      if (v125)
      {
        int v41 = (char *)v40;
        uint64_t v42 = 0;
        uint64_t v43 = 0;
LABEL_206:
        unint64_t v122 = v43;
        unint64_t v123 = v42;
        int v124 = v41;
        unint64_t v126 = v37;
        while (1)
        {
          while (InjectFlushOrPushOutput(a1, a5, a6, a7))
            ;
          if (*(void *)(a1 + 8592) || *(_DWORD *)(a1 + 8628) || (unint64_t v107 = *a3, !a2) && !v107)
          {
            BrotliFree((uint64_t)__src, v123);
            BrotliFree((uint64_t)__src, v122);
            if (*(_DWORD *)(a1 + 8628) == 1 && !*(void *)(a1 + 8592))
            {
LABEL_245:
              *(_DWORD *)(a1 + 8628) = 0;
              *(void *)(a1 + 8584) = 0;
            }
            return 1;
          }
          BOOL v108 = a2 == 2;
          unint64_t v109 = v37 >= v107 ? *a3 : v37;
          if (v107 <= v37)
          {
            BOOL v110 = a2 == 1;
          }
          else
          {
            BOOL v108 = 0;
            BOOL v110 = 0;
          }
          unint64_t v111 = *(unsigned __int8 *)(a1 + 2434);
          unint64_t v134 = 0;
          v135[0] = v111;
          if (v110 && v109 == 0) {
            break;
          }
          int v133 = v108;
          unint64_t v113 = 2 * v109 + 503;
          size_t v129 = *a5;
          size_t v131 = v113;
          if (v113 <= *a5)
          {
            uint64_t v115 = *a6;
          }
          else
          {
            uint64_t BrotliStorage = GetBrotliStorage(a1, v113);
            if (*(_DWORD *)(a1 + 168)) {
              return 0;
            }
            uint64_t v115 = (unsigned char *)BrotliStorage;
          }
          *uint64_t v115 = *(unsigned char *)(a1 + 2432);
          v115[1] = *(unsigned char *)(a1 + 2433);
          HashTable = GetHashTable(a1, *(_DWORD *)(a1 + 4), v109, &v134);
          if (*(_DWORD *)(a1 + 168)) {
            return 0;
          }
          uint64_t v118 = (char *)*a4;
          if (*(_DWORD *)(a1 + 4)) {
            BrotliCompressFragmentTwoPass((uint64_t)__src, v118, v109, v133, v125, v124, (uint64_t)HashTable, v134, v135, (uint64_t)v115);
          }
          else {
            BrotliCompressFragmentFast((unint64_t)__src, (unsigned __int8 *)v118, v109, v133, (uint64_t)HashTable, v134, (unsigned __int8 *)(a1 + 7664), a1 + 7792, (unint64_t *)(a1 + 8560), (unsigned char *)(a1 + 8048), v135, (uint64_t)v115);
          }
          if (*(_DWORD *)(a1 + 168)) {
            return 0;
          }
          if (v109)
          {
            *a4 = (char *)*a4 + v109;
            *a3 -= v109;
          }
          char v119 = v135[0];
          unint64_t v120 = v135[0] >> 3;
          if (v131 <= v129)
          {
            *a6 = (char *)*a6 + v120;
            *a5 -= v120;
            size_t v121 = *(void *)(a1 + 8600) + v120;
            *(void *)(a1 + 8600) = v121;
            if (a7) {
              *a7 = v121;
            }
          }
          else
          {
            *(void *)(a1 + 8584) = v115;
            *(void *)(a1 + 8592) = v120;
          }
          *(_WORD *)(a1 + 2432) = v115[v120];
          *(unsigned char *)(a1 + 2434) = v119 & 7;
          unint64_t v37 = v126;
          if ((v110 | v133) == 1)
          {
            if (v133) {
              int v116 = 2;
            }
            else {
              int v116 = 1;
            }
LABEL_242:
            *(_DWORD *)(a1 + 8628) = v116;
          }
        }
        int v116 = 1;
        goto LABEL_242;
      }
    }
    uint64_t v42 = BrotliAllocate((uint64_t)__src);
    uint64_t v43 = BrotliAllocate((uint64_t)__src);
    goto LABEL_205;
  }
  uint64_t v130 = a1 + 144;
  unint64_t v132 = (unint64_t *)(a1 + 8592);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v59 = *(void *)(a1 + 2248) - *(void *)(a1 + 2344);
        unint64_t v60 = 1 << *(_DWORD *)(a1 + 12);
        BOOL v61 = v60 >= v59;
        unint64_t v62 = v60 - v59;
        if (!v61) {
          unint64_t v62 = 0;
        }
        unint64_t v63 = *(char *)(a1 + 2435);
        unint64_t v64 = v62 >= v63 ? *(char *)(a1 + 2435) : v62;
        size_t v65 = (v63 & 0x80000000) == 0 ? v64 : v62;
        if (!v65 || !*a3) {
          break;
        }
        if (v65 >= *a3) {
          size_t v66 = *a3;
        }
        else {
          size_t v66 = v65;
        }
        uint64_t v67 = (char *)*a4;
        unsigned int v68 = *(_DWORD *)(a1 + 2276);
        if (v68 || v66 >= *(unsigned int *)(a1 + 2264))
        {
          unsigned int v78 = *(_DWORD *)(a1 + 2268);
          if (*(_DWORD *)(a1 + 2272) >= v78) {
            goto LABEL_148;
          }
          __srca = (char *)*a4;
          unint64_t v79 = (unsigned char *)BrotliAllocate(v130);
          if (!*(_DWORD *)(a1 + 168))
          {
            int v80 = v79;
            unsigned int v81 = *(const void **)(a1 + 2280);
            if (v81)
            {
              memcpy(v79, v81, (*(_DWORD *)(a1 + 2272) + 2) + 7);
              BrotliFree(v130, *(void *)(a1 + 2280));
            }
            uint64_t v82 = 0;
            *(void *)(a1 + 2280) = v80;
            *(_DWORD *)(a1 + 2272) = v78;
            *(void *)(a1 + 2288) = v80 + 2;
            v80[1] = 0;
            *(unsigned char *)(*(void *)(a1 + 2288) - 2) = 0;
            do
              *(unsigned char *)(*(void *)(a1 + 2288) + *(unsigned int *)(a1 + 2272) + v82++) = 0;
            while (v82 != 7);
            if (!*(_DWORD *)(a1 + 168))
            {
              *(unsigned char *)(*(void *)(a1 + 2288) + (*(_DWORD *)(a1 + 2256) - 2)) = 0;
              *(unsigned char *)(*(void *)(a1 + 2288) + (*(_DWORD *)(a1 + 2256) - 1)) = 0;
              *(unsigned char *)(*(void *)(a1 + 2288) + *(unsigned int *)(a1 + 2256)) = -15;
              unsigned int v68 = *(_DWORD *)(a1 + 2276);
              uint64_t v67 = __srca;
LABEL_148:
              uint64_t v83 = *(_DWORD *)(a1 + 2260) & v68;
              uint64_t v84 = *(unsigned int *)(a1 + 2264);
              size_t v85 = *(unsigned int *)(a1 + 2256);
              if (v83 < v84)
              {
                if (v66 >= v84 - v83) {
                  size_t v102 = v84 - v83;
                }
                else {
                  size_t v102 = v66;
                }
                unint64_t v103 = v67;
                memcpy((void *)(*(void *)(a1 + 2288) + v85 + v83), v67, v102);
                uint64_t v67 = v103;
                size_t v85 = *(unsigned int *)(a1 + 2256);
              }
              char v86 = (void *)(*(void *)(a1 + 2288) + v83);
              if (v66 + v83 > v85)
              {
                if (v66 >= (unint64_t)*(unsigned int *)(a1 + 2268) - v83) {
                  size_t v104 = *(unsigned int *)(a1 + 2268) - v83;
                }
                else {
                  size_t v104 = v66;
                }
                int v105 = v67;
                memcpy(v86, v67, v104);
                char v86 = *(void **)(a1 + 2288);
                uint64_t v106 = *(unsigned int *)(a1 + 2256) - v83;
                uint64_t v67 = &v105[v106];
                size_t v87 = v66 - v106;
              }
              else
              {
                size_t v87 = v66;
              }
              memcpy(v86, v67, v87);
              int v88 = *(_DWORD *)(a1 + 2276);
              *(unsigned char *)(*(void *)(a1 + 2288) - 2) = *(unsigned char *)(*(void *)(a1 + 2288)
                                                                  + (*(_DWORD *)(a1 + 2256) - 2));
              *(unsigned char *)(*(void *)(a1 + 2288) - 1) = *(unsigned char *)(*(void *)(a1 + 2288)
                                                                  + (*(_DWORD *)(a1 + 2256) - 1));
              if (v88 >= 0) {
                int v89 = (*(_DWORD *)(a1 + 2276) & 0x7FFFFFFF) + (v66 & 0x7FFFFFFF);
              }
              else {
                int v89 = ((*(_DWORD *)(a1 + 2276) & 0x7FFFFFFF) + (v66 & 0x7FFFFFFF)) | 0x80000000;
              }
              *(_DWORD *)(a1 + 2276) = v89;
LABEL_155:
              if (!*(_DWORD *)(a1 + 168))
              {
                *(void *)(a1 + 2248) += v66;
                uint64_t v90 = *(unsigned int *)(a1 + 2276);
                if (v90 <= *(_DWORD *)(a1 + 2260))
                {
                  uint64_t v91 = (_DWORD *)(*(void *)(a1 + 2288) + v90);
                  *(_DWORD *)((char *)v91 + 3) = 0;
                  *uint64_t v91 = 0;
                }
              }
            }
          }
        }
        else
        {
          unint64_t v69 = *a4;
          *(_DWORD *)(a1 + 2276) = v66;
          int v70 = (unsigned char *)BrotliAllocate(v130);
          if (!*(_DWORD *)(a1 + 168))
          {
            unsigned int v71 = v70;
            long long v72 = *(const void **)(a1 + 2280);
            if (v72)
            {
              memcpy(v70, v72, (*(_DWORD *)(a1 + 2272) + 2) + 7);
              BrotliFree(v130, *(void *)(a1 + 2280));
            }
            uint64_t v73 = 0;
            *(void *)(a1 + 2280) = v71;
            *(_DWORD *)(a1 + 2272) = v66;
            *(void *)(a1 + 2288) = v71 + 2;
            v71[1] = 0;
            *(unsigned char *)(*(void *)(a1 + 2288) - 2) = 0;
            do
              *(unsigned char *)(*(void *)(a1 + 2288) + *(unsigned int *)(a1 + 2272) + v73++) = 0;
            while (v73 != 7);
            if (!*(_DWORD *)(a1 + 168))
            {
              memcpy(*(void **)(a1 + 2288), v69, v66);
              goto LABEL_155;
            }
          }
        }
        *a4 = (char *)*a4 + v66;
        *a3 -= v66;
        int v92 = *(char *)(a1 + 2435);
        if (v92 >= 1) {
          *(unsigned char *)(a1 + 2435) = v92 - v66;
        }
      }
      if (!InjectFlushOrPushOutput(a1, a5, a6, a7)) {
        break;
      }
      if (*(unsigned __int8 *)(a1 + 2435) == 255)
      {
        int v77 = *(_DWORD *)(a1 + 8628);
        if (!v77) {
          goto LABEL_139;
        }
        if (v77 == 1 && !*v132)
        {
          *(_DWORD *)(a1 + 8628) = 0;
          *(void *)(a1 + 8584) = 0;
LABEL_139:
          *(unsigned char *)(a1 + 2435) = -2;
        }
      }
    }
    if (*v132) {
      return 1;
    }
    int v93 = *(_DWORD *)(a1 + 8628);
    if (v93)
    {
      if (v93 == 1) {
        goto LABEL_245;
      }
      return 1;
    }
    if (!a2 && v65) {
      return 1;
    }
    unint64_t v94 = *a3;
    if (*a3) {
      unsigned int v95 = 0;
    }
    else {
      unsigned int v95 = a2 == 2;
    }
    if (*a3) {
      BOOL v96 = 0;
    }
    else {
      BOOL v96 = a2 == 1;
    }
    if ((v95 & 1) == 0 && !*(unsigned char *)(a1 + 2435))
    {
      *(unsigned char *)(a1 + 2435) = -1;
      BOOL v96 = 1;
    }
    if (!*(void *)(a1 + 24))
    {
      uint64_t v97 = *(void *)(a1 + 2248) - *(void *)(a1 + 2344);
      unint64_t v98 = v97 | v94;
      uint64_t v100 = v97 + v94;
      unint64_t v99 = (v98 | v100) >> 30;
      uint64_t v100 = v100;
      if (v99) {
        uint64_t v100 = 0x40000000;
      }
      *(void *)(a1 + 24) = v100;
    }
    uint64_t result = EncodeData(a1, v95, v96, v132, (uint64_t *)(a1 + 8584), v74, v75, v76);
    if (!result) {
      return result;
    }
    if ((v95 & 1) != 0 || v96)
    {
      if (v95) {
        int v101 = 2;
      }
      else {
        int v101 = 1;
      }
      *(_DWORD *)(a1 + 8628) = v101;
    }
  }
}

BOOL BrotliEncoderIsFinished(uint64_t a1)
{
  return *(_DWORD *)(a1 + 8628) == 2 && *(void *)(a1 + 8592) == 0;
}

uint64_t InjectFlushOrPushOutput(uint64_t a1, size_t *a2, void **a3, size_t *a4)
{
  if (*(_DWORD *)(a1 + 8628) == 1 && (uint64_t v8 = *(unsigned __int8 *)(a1 + 2434), *(unsigned char *)(a1 + 2434)))
  {
    __int16 v9 = *(_WORD *)(a1 + 2432);
    *(_WORD *)(a1 + 2432) = 0;
    *(unsigned char *)(a1 + 2434) = 0;
    __int16 v10 = (6 << v8) | v9;
    uint64_t v11 = *(void *)(a1 + 8584);
    if (v11)
    {
      int8x8_t v12 = (unsigned char *)(v11 + *(void *)(a1 + 8592));
    }
    else
    {
      int8x8_t v12 = (unsigned char *)(a1 + 8608);
      *(void *)(a1 + 8584) = a1 + 8608;
    }
    *int8x8_t v12 = v10;
    if (v8 >= 3)
    {
      v12[1] = HIBYTE(v10);
      if (v8 >= 0xB) {
        v12[2] = (6 << v8) >> 16;
      }
    }
    *(void *)(a1 + 8592) += (unint64_t)(v8 + 13) >> 3;
  }
  else
  {
    size_t v13 = *(void *)(a1 + 8592);
    if (!v13 || !*a2) {
      return 0;
    }
    if (v13 >= *a2) {
      size_t v14 = *a2;
    }
    else {
      size_t v14 = *(void *)(a1 + 8592);
    }
    memcpy(*a3, *(const void **)(a1 + 8584), v14);
    *a3 = (char *)*a3 + v14;
    *a2 -= v14;
    *(void *)(a1 + 8584) += v14;
    *(void *)(a1 + 8592) -= v14;
    size_t v15 = *(void *)(a1 + 8600) + v14;
    *(void *)(a1 + 8600) = v15;
    if (a4) {
      *a4 = v15;
    }
  }
  return 1;
}

uint64_t EncodeData(uint64_t a1, unsigned int a2, int a3, unint64_t *a4, uint64_t *a5, __n128 a6, __n128 a7, int32x4_t a8)
{
  uint64_t v8 = *(void *)(a1 + 2248);
  unint64_t v9 = *(void *)(a1 + 2344);
  unint64_t v10 = v8 - v9;
  if (v9 >> 30 >= 3) {
    unint64_t v11 = (((2 * (int)v9) >> 1) & 0xC0000000 | v9 & 0x3FFFFFFF) ^ 0x80000000;
  }
  else {
    unint64_t v11 = v9;
  }
  unsigned int v247 = v11;
  unsigned int v248 = v8 - v9;
  if (*(_DWORD *)(a1 + 8632)) {
    return 0;
  }
  int8x8_t v12 = a5;
  size_t v13 = a4;
  int v14 = a3;
  if (a2) {
    *(_DWORD *)(a1 + 8632) = 1;
  }
  if (v10 > 1 << *(_DWORD *)(a1 + 12)) {
    return 0;
  }
  uint64_t v17 = a1 + 144;
  int v18 = *(int **)(a1 + 2288);
  size_t v244 = *(unsigned int *)(a1 + 2260);
  unsigned int v19 = *(_DWORD *)(a1 + 4);
  if (v19 != 1) {
    goto LABEL_13;
  }
  if (!*(void *)(a1 + 8568))
  {
    unsigned int v22 = a2;
    *(void *)(a1 + 8568) = BrotliAllocate(v17);
    *(void *)(a1 + 8576) = BrotliAllocate(a1 + 144);
    if (*(_DWORD *)(a1 + 168)) {
      return 0;
    }
    unsigned int v19 = *(_DWORD *)(a1 + 4);
    a2 = v22;
    uint64_t v17 = a1 + 144;
    int v14 = a3;
    size_t v13 = a4;
    int8x8_t v12 = a5;
LABEL_13:
    if (v19 <= 1) {
      goto LABEL_14;
    }
    long long v243 = (_DWORD *)v17;
    unint64_t v33 = (v10 >> 1) + *(void *)(a1 + 2312) + 1;
    if (v33 > *(void *)(a1 + 2296))
    {
      unsigned int v34 = a2;
      unint64_t v35 = v33 + (v10 >> 2) + 16;
      *(void *)(a1 + 2296) = v35;
      if (v35) {
        unsigned int v36 = (void *)BrotliAllocate(v17);
      }
      else {
        unsigned int v36 = 0;
      }
      if (*(_DWORD *)(a1 + 168)) {
        return 0;
      }
      unint64_t v37 = *(const void **)(a1 + 2304);
      if (v37)
      {
        memcpy(v36, v37, 16 * *(void *)(a1 + 2312));
        BrotliFree((uint64_t)v243, *(void *)(a1 + 2304));
      }
      *(void *)(a1 + 2304) = v36;
      a2 = v34;
    }
    long long v241 = (uint64_t *)(a1 + 2456);
    unint64_t v38 = v10;
    if (a2) {
      BOOL v39 = v11 == 0;
    }
    else {
      BOOL v39 = 0;
    }
    int v40 = v39;
    unsigned int v240 = a2;
    if (*(void *)(a1 + 2456))
    {
      unint64_t v41 = v244;
      if (*(_DWORD *)(a1 + 2500)) {
        goto LABEL_152;
      }
      goto LABEL_117;
    }
    uint64_t v42 = (__n128 *)(a1 + 40);
    unsigned int v43 = *(_DWORD *)(a1 + 4);
    unint64_t v41 = v244;
    if ((int)v43 < 10)
    {
      if (v43 == 4)
      {
        if (*(void *)(a1 + 24) >= 0x100000uLL) {
          unsigned int v43 = 54;
        }
      }
      else if ((int)v43 > 4)
      {
        int v44 = *(_DWORD *)(a1 + 8);
        if (v44 > 16)
        {
          unsigned int v51 = v43 - 1;
          if (v44 < 0x13 || *(void *)(a1 + 24) < 0x100000uLL)
          {
            *(_DWORD *)(a1 + 48) = v51;
            if (v43 >= 9) {
              int v57 = 16;
            }
            else {
              int v57 = 10;
            }
            BOOL v58 = v43 >= 7;
            if (v43 < 7) {
              int v59 = 14;
            }
            else {
              int v59 = 15;
            }
            *(_DWORD *)(a1 + 40) = 5;
            *(_DWORD *)(a1 + 44) = v59;
            if (v58) {
              int v60 = v57;
            }
            else {
              int v60 = 4;
            }
            *(_DWORD *)(a1 + 56) = v60;
            unsigned int v43 = 5;
          }
          else
          {
            a6.n128_u64[0] = 0xF00000006;
            *(void *)(a1 + 40) = 0xF00000006;
            *(_DWORD *)(a1 + 48) = v51;
            *(_DWORD *)(a1 + 52) = 5;
            if (v43 >= 9) {
              int v52 = 16;
            }
            else {
              int v52 = 10;
            }
            if (v43 >= 7) {
              int v53 = v52;
            }
            else {
              int v53 = 4;
            }
            *(_DWORD *)(a1 + 56) = v53;
            unsigned int v43 = 6;
          }
          goto LABEL_53;
        }
        if (v43 < 9) {
          int v45 = 41;
        }
        else {
          int v45 = 42;
        }
        if (v43 >= 7) {
          unsigned int v43 = v45;
        }
        else {
          unsigned int v43 = 40;
        }
      }
    }
    else
    {
      unsigned int v43 = 10;
    }
    v42->n128_u32[0] = v43;
LABEL_53:
    int v46 = *(_DWORD *)(a1 + 8);
    if (v46 < 25)
    {
      uint64_t v47 = 0;
      switch(v43)
      {
        case 2u:
        case 3u:
        case 4u:
          goto LABEL_81;
        case 5u:
        case 6u:
LABEL_57:
          uint64_t v48 = (4 << *(_DWORD *)(a1 + 44) << *(_DWORD *)(a1 + 48)) + (2 << *(_DWORD *)(a1 + 44));
          goto LABEL_80;
        case 7u:
        case 8u:
        case 9u:
          break;
        case 0xAu:
LABEL_63:
          uint64_t v50 = 1 << v46;
          if ((v40 & (1 << v46 > v38)) != 0) {
            uint64_t v50 = v38;
          }
          uint64_t v48 = 8 * v50 + 0x80000;
LABEL_80:
          if (v48) {
LABEL_81:
          }
            uint64_t v47 = BrotliAllocate((uint64_t)v243);
          else {
            uint64_t v47 = 0;
          }
          break;
        default:
          switch(v43)
          {
            case '#':
            case '(':
            case ')':
            case '*':
              goto LABEL_81;
            case '$':
            case '%':
            case '&':
            case '\'':
              goto LABEL_82;
            default:
              if (v43 == 54) {
                goto LABEL_81;
              }
              break;
          }
          break;
      }
    }
    else
    {
      uint64_t v47 = 0;
      switch(v43)
      {
        case 2u:
        case 4u:
          goto LABEL_81;
        case 3u:
          v42->n128_u32[0] = 35;
          goto LABEL_81;
        case 5u:
          goto LABEL_57;
        case 6u:
          *(_DWORD *)(a1 + 40) = 65;
          uint64_t v48 = (2 << *(_DWORD *)(a1 + 44)) + 0x4000000 + (4 << *(_DWORD *)(a1 + 44) << *(_DWORD *)(a1 + 48));
          goto LABEL_80;
        case 7u:
        case 8u:
        case 9u:
          break;
        case 0xAu:
          goto LABEL_63;
        default:
          switch(v43)
          {
            case '#':
            case '(':
            case ')':
            case '*':
              goto LABEL_81;
            case '$':
            case '%':
            case '&':
            case '\'':
              goto LABEL_82;
            default:
              if (v43 != 54) {
                goto LABEL_82;
              }
              v42->n128_u32[0] = 55;
              break;
          }
          goto LABEL_81;
      }
    }
LABEL_82:
    *(void *)(a1 + 2456) = v47;
    if (*(_DWORD *)(a1 + 168))
    {
LABEL_152:
      if (!*(_DWORD *)(a1 + 168))
      {
        int v80 = *(_DWORD *)(a1 + 2480);
        if (v80 <= 34)
        {
          switch(v80)
          {
            case 2:
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v103 = *(void *)(a1 + 2512);
                *(_DWORD *)(v103
                          + (((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 3) & v41))) >> 46) & 0x3FFFC)) = v11 - 3;
                *(_DWORD *)(v103
                          + (((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 2) & v41))) >> 46) & 0x3FFFC)) = v11 - 2;
                *(_DWORD *)(v103
                          + (((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 1) & v41))) >> 46) & 0x3FFFC)) = v11 - 1;
              }
              break;
            case 3:
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v133 = *(void *)(a1 + 2512);
                *(_DWORD *)(v133
                          + 4
                          * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 3) & v41))) >> 48)
                                             + ((v11 - 3) & 8))) = v11 - 3;
                *(_DWORD *)(v133
                          + 4
                          * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 2) & v41))) >> 48)
                                             + ((v11 - 2) & 8))) = v11 - 2;
                int v134 = v11 - 1;
                uint64_t v135 = (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 1) & v41))) >> 48)
                                        + ((v11 - 1) & 8));
                goto LABEL_307;
              }
              break;
            case 4:
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v133 = *(void *)(a1 + 2512);
                *(_DWORD *)(v133
                          + 4
                          * (((((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 3) & v41))) >> 32) >> 15)
                            + ((v11 - 3) & 0x18)) & 0x1FFFF)) = v11 - 3;
                *(_DWORD *)(v133
                          + 4
                          * (((((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 2) & v41))) >> 32) >> 15)
                            + ((v11 - 2) & 0x18)) & 0x1FFFF)) = v11 - 2;
                int v134 = v11 - 1;
                uint64_t v135 = ((((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 1) & v41))) >> 32) >> 15)
                      + ((v11 - 1) & 0x18)) & 0x1FFFF;
                goto LABEL_307;
              }
              break;
            case 5:
              if (v38 >= 3 && v11 >= 3)
              {
                unsigned int v136 = (506832829 * *(int *)((char *)v18 + ((v11 - 3) & v41))) >> *(_DWORD *)(a1 + 2520);
                uint64_t v137 = *(void *)(a1 + 2544);
                unsigned int v138 = *(unsigned __int16 *)(v137 + 2 * v136);
                uint64_t v139 = *(void *)(a1 + 2552);
                *(_DWORD *)(v139
                          + 4 * ((v136 << *(_DWORD *)(a1 + 2528)) + (unint64_t)(*(_DWORD *)(a1 + 2524) & v138))) = v11 - 3;
                *(_WORD *)(v137 + 2 * v136) = v138 + 1;
                unsigned int v140 = (506832829 * *(int *)((char *)v18 + ((v11 - 2) & v41))) >> *(_DWORD *)(a1 + 2520);
                unsigned int v141 = *(unsigned __int16 *)(v137 + 2 * v140);
                *(_DWORD *)(v139
                          + 4 * ((v140 << *(_DWORD *)(a1 + 2528)) + (unint64_t)(*(_DWORD *)(a1 + 2524) & v141))) = v11 - 2;
                *(_WORD *)(v137 + 2 * v140) = v141 + 1;
                unsigned int v142 = (506832829 * *(int *)((char *)v18 + ((v11 - 1) & v41))) >> *(_DWORD *)(a1 + 2520);
                unsigned int v143 = *(unsigned __int16 *)(v137 + 2 * v142);
                *(_DWORD *)(v139
                          + 4 * ((v142 << *(_DWORD *)(a1 + 2528)) + (unint64_t)(*(_DWORD *)(a1 + 2524) & v143))) = v11 - 1;
                *(_WORD *)(v137 + 2 * v142) = v143 + 1;
              }
              break;
            case 6:
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v144 = *(void *)(a1 + 2560);
                uint64_t v145 = *(void *)(a1 + 2568);
                unint64_t v146 = *(void *)(a1 + 2528);
                unint64_t v147 = (0x1FE35A7BD3579BD3 * (*(void *)((unsigned char *)v18 + ((v11 - 3) & v41)) & v146)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v148 = *(unsigned __int16 *)(v144 + 2 * v147);
                unint64_t v149 = (v147 << *(_DWORD *)(a1 + 2540))
                     + (unint64_t)(*(_DWORD *)(a1 + 2536) & v148);
                *(_WORD *)(v144 + 2 * v147) = v148 + 1;
                *(_DWORD *)(v145 + 4 * v149) = v11 - 3;
                unint64_t v150 = (0x1FE35A7BD3579BD3 * (*(void *)((unsigned char *)v18 + ((v11 - 2) & v41)) & v146)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v151 = *(unsigned __int16 *)(v144 + 2 * v150);
                unint64_t v152 = (v150 << *(_DWORD *)(a1 + 2540))
                     + (unint64_t)(*(_DWORD *)(a1 + 2536) & v151);
                *(_WORD *)(v144 + 2 * v150) = v151 + 1;
                *(_DWORD *)(v145 + 4 * v152) = v11 - 2;
                unint64_t v153 = (0x1FE35A7BD3579BD3 * (*(void *)((unsigned char *)v18 + ((v11 - 1) & v41)) & v146)) >> *(_DWORD *)(a1 + 2520);
                LODWORD(v146) = *(unsigned __int16 *)(v144 + 2 * v153);
                unint64_t v154 = (v153 << *(_DWORD *)(a1 + 2540))
                     + (unint64_t)(*(_DWORD *)(a1 + 2536) & v146);
                *(_WORD *)(v144 + 2 * v153) = v146 + 1;
                *(_DWORD *)(v145 + 4 * v154) = v11 - 1;
              }
              break;
            case 10:
              if (v38 >= 3 && v11 >= 0x80)
              {
                unint64_t v155 = v11 - 127;
                unint64_t v156 = v11 >= v11 - 127 + v38 ? v11 - 127 + v38 : v11;
                if (v155 < v156)
                {
                  uint64_t v157 = *(void *)(a1 + 2504);
                  uint64_t v239 = *(void *)(a1 + 2512);
                  uint64_t v158 = *(void *)(a1 + 2528);
                  do
                  {
                    uint64_t v159 = v11 - v155;
                    unint64_t v160 = v155 & v41;
                    if (v11 - v155 <= 0xF) {
                      uint64_t v159 = 15;
                    }
                    unsigned int v161 = (506832829 * *(int *)((char *)v18 + (v155 & v41))) >> 15;
                    uint64_t v162 = *(unsigned int *)(v239 + 4 * v161);
                    uint64_t v163 = 2 * (v157 & v155);
                    uint64_t v164 = v163 | 1;
                    *(_DWORD *)(v239 + 4 * v161) = v155;
                    if (v155 != v162)
                    {
                      unint64_t v166 = 0;
                      unint64_t v167 = 0;
                      unint64_t v168 = v157 - v159;
                      uint64_t v169 = 64;
                      do
                      {
                        if (v155 - v162 > v168 || v169 == 0) {
                          break;
                        }
                        unint64_t v171 = v162 & v41;
                        if (v167 >= v166) {
                          unint64_t v172 = v166;
                        }
                        else {
                          unint64_t v172 = v167;
                        }
                        char v173 = (char *)v18 + v172 + v160;
                        char v174 = (unsigned __int8 *)v18 + v172 + v171;
                        unint64_t v175 = 128 - v172;
                        if (128 - v172 < 8)
                        {
                          v179 = v18;
                          unint64_t v178 = 0;
LABEL_268:
                          uint64_t v185 = v175 & 7;
                          if (v185)
                          {
                            unint64_t v186 = v178 | v185;
                            while (v173[v178] == *v174)
                            {
                              ++v174;
                              ++v178;
                              if (!--v185)
                              {
                                unint64_t v178 = v186;
                                break;
                              }
                            }
                          }
                        }
                        else
                        {
                          uint64_t v176 = 0;
                          unint64_t v177 = v175 >> 3;
                          unint64_t v178 = v175 & 0xFFFFFFFFFFFFFFF8;
                          v179 = v18;
                          char v180 = (unsigned __int8 *)v18 + v172 + v171 + (v175 & 0xFFFFFFFFFFFFFFF8);
                          while (1)
                          {
                            uint64_t v181 = *(void *)&v174[v176];
                            uint64_t v182 = *(void *)&v173[v176];
                            if (v181 != v182) {
                              break;
                            }
                            v176 += 8;
                            if (!--v177)
                            {
                              char v174 = v180;
                              goto LABEL_268;
                            }
                          }
                          unint64_t v178 = v176 + (__clz(__rbit64(v182 ^ v181)) >> 3);
                        }
                        unint64_t v183 = v178 + v172;
                        int v18 = v179;
                        if (v178 + v172 >= 0x80)
                        {
                          unint64_t v187 = (int *)(v158 + 8 * (v162 & v157));
                          int v188 = *v187;
                          int v165 = v187 + 1;
                          *(_DWORD *)(v158 + 4 * v163) = v188;
                          unint64_t v41 = v244;
                          goto LABEL_245;
                        }
                        uint64_t v184 = 2 * (v162 & v157);
                        unint64_t v41 = v244;
                        if (*((unsigned __int8 *)v179 + v183 + v160) <= *((unsigned __int8 *)v179
                                                                                       + v183
                                                                                       + v171))
                        {
                          *(_DWORD *)(v158 + 4 * v164) = v162;
                          uint64_t v164 = 2 * (v162 & v157);
                          unint64_t v166 = v183;
                        }
                        else
                        {
                          *(_DWORD *)(v158 + 4 * v163) = v162;
                          v184 |= 1uLL;
                          uint64_t v163 = v184;
                          unint64_t v167 = v183;
                        }
                        uint64_t v162 = *(unsigned int *)(v158 + 4 * v184);
                        --v169;
                      }
                      while (v155 != v162);
                    }
                    *(_DWORD *)(v158 + 4 * v163) = *(_DWORD *)(a1 + 2520);
                    int v165 = (_DWORD *)(a1 + 2520);
LABEL_245:
                    *(_DWORD *)(v158 + 4 * v164) = *v165;
                    ++v155;
                  }
                  while (v155 != v156);
                }
              }
              break;
            default:
              break;
          }
        }
        else if (v80 > 53)
        {
          switch(v80)
          {
            case '6':
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v133 = *(void *)(a1 + 2512);
                *(_DWORD *)(v133
                          + 4
                          * (((((unint64_t)(0x35A7BD1E35A7BD00
                                                               * *(void *)((char *)v18 + ((v11 - 3) & v41))) >> 32) >> 12)
                            + ((v11 - 3) & 0x18)) & 0xFFFFF)) = v11 - 3;
                *(_DWORD *)(v133
                          + 4
                          * (((((unint64_t)(0x35A7BD1E35A7BD00
                                                               * *(void *)((char *)v18 + ((v11 - 2) & v41))) >> 32) >> 12)
                            + ((v11 - 2) & 0x18)) & 0xFFFFF)) = v11 - 2;
                int v134 = v11 - 1;
                uint64_t v135 = ((((unint64_t)(0x35A7BD1E35A7BD00
                                                         * *(void *)((char *)v18 + ((v11 - 1) & v41))) >> 32) >> 12)
                      + ((v11 - 1) & 0x18)) & 0xFFFFF;
LABEL_307:
                *(_DWORD *)(v133 + 4 * v135) = v134;
              }
              break;
            case '7':
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v225 = *(void *)(a1 + 2512);
                *(_DWORD *)(v225
                          + 4
                          * (((((unint64_t)(0x35A7BD1E35A7BD00
                                                               * *(void *)((char *)v18 + ((v11 - 3) & v41))) >> 32) >> 12)
                            + ((v11 - 3) & 0x18)) & 0xFFFFF)) = v11 - 3;
                *(_DWORD *)(v225
                          + 4
                          * (((((unint64_t)(0x35A7BD1E35A7BD00
                                                               * *(void *)((char *)v18 + ((v11 - 2) & v41))) >> 32) >> 12)
                            + ((v11 - 2) & 0x18)) & 0xFFFFF)) = v11 - 2;
                *(_DWORD *)(v225
                          + 4
                          * (((((unint64_t)(0x35A7BD1E35A7BD00
                                                               * *(void *)((char *)v18 + ((v11 - 1) & v41))) >> 32) >> 12)
                            + ((v11 - 1) & 0x18)) & 0xFFFFF)) = v11 - 1;
              }
              unint64_t v226 = 4 - (v11 & 3);
              if ((v11 & 3) != 0) {
                uint64_t v227 = 4 - (v11 & 3);
              }
              else {
                uint64_t v227 = 0;
              }
              BOOL v58 = v38 >= v226;
              unint64_t v228 = v38 - v226;
              if (!v58) {
                unint64_t v228 = 0;
              }
              if ((v11 & 3) != 0) {
                unint64_t v229 = v228;
              }
              else {
                unint64_t v229 = v38;
              }
              unint64_t v194 = v227 + v11;
              unint64_t v230 = (v227 + v11) & v41;
              unint64_t v231 = v41 - v230;
              if (v229 < v41 - v230) {
                unint64_t v231 = v229;
              }
              if (v231 >= 0x20)
              {
                unint64_t v232 = 0;
                int v198 = 0;
                long long v233 = (char *)v18 + v230;
                do
                {
                  int v198 = v233[v232] + v198 * *(_DWORD *)(a1 + 2548) + 1;
                  BOOL v58 = v232 >= 0x1C;
                  v232 += 4;
                }
                while (!v58);
LABEL_325:
                *(_DWORD *)(a1 + 2520) = v198;
              }
LABEL_326:
              *(void *)(a1 + 2536) = v194;
              break;
            case 'A':
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v118 = *(void *)(a1 + 2560);
                uint64_t v119 = *(void *)(a1 + 2568);
                unint64_t v120 = *(void *)(a1 + 2528);
                unint64_t v121 = (0x1FE35A7BD3579BD3 * (*(void *)((unsigned char *)v18 + ((v11 - 3) & v41)) & v120)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v122 = *(unsigned __int16 *)(v118 + 2 * v121);
                unint64_t v123 = (v121 << *(_DWORD *)(a1 + 2540))
                     + (unint64_t)(*(_DWORD *)(a1 + 2536) & v122);
                *(_WORD *)(v118 + 2 * v121) = v122 + 1;
                *(_DWORD *)(v119 + 4 * v123) = v11 - 3;
                unint64_t v124 = (0x1FE35A7BD3579BD3 * (*(void *)((unsigned char *)v18 + ((v11 - 2) & v41)) & v120)) >> *(_DWORD *)(a1 + 2520);
                unsigned int v125 = *(unsigned __int16 *)(v118 + 2 * v124);
                unint64_t v126 = (v124 << *(_DWORD *)(a1 + 2540))
                     + (unint64_t)(*(_DWORD *)(a1 + 2536) & v125);
                *(_WORD *)(v118 + 2 * v124) = v125 + 1;
                *(_DWORD *)(v119 + 4 * v126) = v11 - 2;
                unint64_t v127 = (0x1FE35A7BD3579BD3 * (*(void *)((unsigned char *)v18 + ((v11 - 1) & v41)) & v120)) >> *(_DWORD *)(a1 + 2520);
                LODWORD(v120) = *(unsigned __int16 *)(v118 + 2 * v127);
                unint64_t v128 = (v127 << *(_DWORD *)(a1 + 2540))
                     + (unint64_t)(*(_DWORD *)(a1 + 2536) & v120);
                *(_WORD *)(v118 + 2 * v127) = v120 + 1;
                *(_DWORD *)(v119 + 4 * v128) = v11 - 1;
              }
              unint64_t v129 = v41 - (v41 & v11);
              if (v129 >= v38) {
                unint64_t v129 = v38;
              }
              if (v129 >= 0x20)
              {
                uint64_t v130 = 0;
                int v131 = 0;
                do
                  int v131 = *((unsigned __int8 *)v18 + (v41 & v11) + v130++) + v131 * *(_DWORD *)(a1 + 2604) + 1;
                while (v130 != 32);
                *(_DWORD *)(a1 + 2576) = v131;
              }
              *(void *)(a1 + 2592) = v11;
              break;
          }
        }
        else
        {
          switch(v80)
          {
            case '#':
              if (v38 >= 7 && v11 >= 3)
              {
                uint64_t v189 = *(void *)(a1 + 2512);
                *(_DWORD *)(v189
                          + 4
                          * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 3) & v41))) >> 48)
                                             + ((v11 - 3) & 8))) = v11 - 3;
                *(_DWORD *)(v189
                          + 4
                          * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 2) & v41))) >> 48)
                                             + ((v11 - 2) & 8))) = v11 - 2;
                *(_DWORD *)(v189
                          + 4
                          * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)((char *)v18 + ((v11 - 1) & v41))) >> 48)
                                             + ((v11 - 1) & 8))) = v11 - 1;
              }
              unint64_t v190 = 4 - (v11 & 3);
              if ((v11 & 3) != 0) {
                uint64_t v191 = 4 - (v11 & 3);
              }
              else {
                uint64_t v191 = 0;
              }
              BOOL v58 = v38 >= v190;
              unint64_t v192 = v38 - v190;
              if (!v58) {
                unint64_t v192 = 0;
              }
              if ((v11 & 3) != 0) {
                unint64_t v193 = v192;
              }
              else {
                unint64_t v193 = v38;
              }
              unint64_t v194 = v191 + v11;
              unint64_t v195 = (v191 + v11) & v41;
              unint64_t v196 = v41 - v195;
              if (v193 < v41 - v195) {
                unint64_t v196 = v193;
              }
              if (v196 < 0x20) {
                goto LABEL_326;
              }
              unint64_t v197 = 0;
              int v198 = 0;
              v199 = (char *)v18 + v195;
              do
              {
                int v198 = v199[v197] + v198 * *(_DWORD *)(a1 + 2548) + 1;
                BOOL v58 = v197 >= 0x1C;
                v197 += 4;
              }
              while (!v58);
              goto LABEL_325;
            case '(':
            case ')':
              if (v38 >= 3 && v11 >= 3)
              {
                uint64_t v81 = *(void *)(a1 + 2520);
                unsigned int v82 = (506832829 * *(int *)((char *)v18 + ((v11 - 3) & v41))) >> 17;
                uint64_t v83 = v81 + 2 * v82;
                uint64_t v84 = *(unsigned __int16 *)(a1 + 2504);
                uint64_t v85 = v81 + 4 * v84;
                unsigned __int16 v86 = v84 + 1;
                *(_WORD *)(a1 + 2504) = v84 + 1;
                unint64_t v87 = v11 - 3 - *(unsigned int *)(v81 + 4 * v82);
                *(unsigned char *)(v81 + (unsigned __int16)(v11 - 3) + 196608) = v82;
                __int16 v88 = -1;
                if (v87 >= 0xFFFF) {
                  LOWORD(v87) = -1;
                }
                *(_WORD *)(v85 + 0x40000) = v87;
                __int16 v89 = *(_WORD *)(v83 + 0x20000);
                *(_DWORD *)(v81 + 4 * v82) = v11 - 3;
                *(_WORD *)(v85 + 262146) = v89;
                *(_WORD *)(v83 + 0x20000) = v84;
                uint64_t v90 = *(void *)(a1 + 2520);
                unsigned int v91 = (506832829 * *(int *)((char *)v18 + ((v11 - 2) & v41))) >> 17;
                uint64_t v92 = v90 + 2 * v91;
                uint64_t v93 = v90 + 4 * v86;
                *(_WORD *)(a1 + 2504) = v84 + 2;
                unint64_t v94 = v11 - 2 - *(unsigned int *)(v90 + 4 * v91);
                *(unsigned char *)(v90 + (unsigned __int16)(v11 - 2) + 196608) = v91;
                if (v94 >= 0xFFFF) {
                  LOWORD(v94) = -1;
                }
                *(_WORD *)(v93 + 0x40000) = v94;
                __int16 v95 = *(_WORD *)(v92 + 0x20000);
                *(_DWORD *)(v90 + 4 * v91) = v11 - 2;
                *(_WORD *)(v92 + 0x20000) = v86;
                *(_WORD *)(v93 + 262146) = v95;
                uint64_t v96 = *(void *)(a1 + 2520);
                unsigned int v97 = (506832829 * *(int *)((char *)v18 + ((v11 - 1) & v41))) >> 17;
                uint64_t v98 = v96 + 2 * v97;
                uint64_t v99 = *(unsigned __int16 *)(a1 + 2504);
                uint64_t v100 = v96 + 4 * v99;
                *(_WORD *)(a1 + 2504) = v99 + 1;
                uint64_t v101 = *(unsigned int *)(v96 + 4 * v97);
                *(unsigned char *)(v96 + (unsigned __int16)(v11 - 1) + 196608) = v97;
                __int16 v102 = *(_WORD *)(v98 + 0x20000);
                if (v11 - 1 - v101 < 0xFFFF) {
                  __int16 v88 = v11 - 1 - v101;
                }
                *(_WORD *)(v100 + 0x40000) = v88;
                *(_WORD *)(v100 + 262146) = v102;
                *(_DWORD *)(v96 + 4 * v97) = v11 - 1;
                *(_WORD *)(v98 + 0x20000) = v99;
              }
              break;
            case '*':
              if (v38 >= 3 && v11 >= 3)
              {
                uint64_t v200 = a1 + 2504;
                uint64_t v201 = *(void *)(a1 + 3536);
                unsigned int v202 = (506832829 * *(int *)((char *)v18 + ((v11 - 3) & v41))) >> 17;
                uint64_t v203 = v201 + 2 * v202;
                __int16 v204 = *(_WORD *)(a1 + 2504 + 2 * (v202 & 0x1FF));
                *(_WORD *)(a1 + 2504 + 2 * (v202 & 0x1FF)) = v204 + 1;
                uint64_t v205 = v204 & 0x1FF;
                unint64_t v206 = v11 - 3 - *(unsigned int *)(v201 + 4 * v202);
                *(unsigned char *)(v201 + (unsigned __int16)(v11 - 3) + 196608) = v202;
                if (v206 >= 0xFFFF) {
                  __int16 v207 = -1;
                }
                else {
                  __int16 v207 = v206;
                }
                unint64_t v208 = (__int16 *)(v201 + ((unint64_t)(v202 & 0x1FF) << 11) + 4 * v205 + 0x40000);
                *unint64_t v208 = v207;
                v208[1] = *(_WORD *)(v203 + 0x20000);
                *(_DWORD *)(v201 + 4 * v202) = v11 - 3;
                *(_WORD *)(v203 + 0x20000) = v205;
                uint64_t v209 = *(void *)(a1 + 3536);
                unsigned int v210 = (506832829 * *(int *)((char *)v18 + ((v11 - 2) & v41))) >> 17;
                uint64_t v211 = v209 + 2 * v210;
                __int16 v212 = *(_WORD *)(v200 + 2 * (v210 & 0x1FF));
                *(_WORD *)(v200 + 2 * (v210 & 0x1FF)) = v212 + 1;
                uint64_t v213 = v212 & 0x1FF;
                unint64_t v214 = v11 - 2 - *(unsigned int *)(v209 + 4 * v210);
                *(unsigned char *)(v209 + (unsigned __int16)(v11 - 2) + 196608) = v210;
                if (v214 >= 0xFFFF) {
                  __int16 v215 = -1;
                }
                else {
                  __int16 v215 = v214;
                }
                unint64_t v216 = v209 + ((unint64_t)(v210 & 0x1FF) << 11) + 4 * v213 + 0x40000;
                *(_WORD *)unint64_t v216 = v215;
                *(_WORD *)(v216 + 2) = *(_WORD *)(v211 + 0x20000);
                *(_DWORD *)(v209 + 4 * v210) = v11 - 2;
                *(_WORD *)(v211 + 0x20000) = v213;
                uint64_t v217 = *(void *)(a1 + 3536);
                unsigned int v218 = (506832829 * *(int *)((char *)v18 + ((v11 - 1) & v41))) >> 17;
                uint64_t v219 = v217 + 2 * v218;
                LOWORD(v216) = *(_WORD *)(v200 + 2 * (v218 & 0x1FF));
                *(_WORD *)(v200 + 2 * (v218 & 0x1FF)) = v216 + 1;
                unint64_t v220 = v216 & 0x1FF;
                unint64_t v221 = v11 - 1 - *(unsigned int *)(v217 + 4 * v218);
                *(unsigned char *)(v217 + (unsigned __int16)(v11 - 1) + 196608) = v218;
                if (v221 >= 0xFFFF) {
                  __int16 v222 = -1;
                }
                else {
                  __int16 v222 = v221;
                }
                __int16 v223 = *(_WORD *)(v219 + 0x20000);
                long long v224 = (__int16 *)(v217 + ((unint64_t)(v218 & 0x1FF) << 11) + 4 * v220 + 0x40000);
                *long long v224 = v222;
                v224[1] = v223;
                *(_DWORD *)(v217 + 4 * v218) = v11 - 1;
                *(_WORD *)(v219 + 0x20000) = v220;
              }
              break;
            default:
              break;
          }
        }
      }
      unint64_t v76 = *(void *)(a1 + 2336);
      if (v76 > 0xBFFFFFFF) {
        uint64_t v77 = (((2 * (int)v76) >> 1) & 0xC0000000 | v76 & 0x3FFFFFFF) ^ 0x80000000;
      }
      else {
        uint64_t v77 = v76;
      }
      if (*(int *)(a1 + 4) < 10 || BrotliIsMostlyUTF8((uint64_t)v18, v77, v41, *(void *)(a1 + 2248) - v76, 0.75)) {
        unsigned int v78 = 2;
      }
      else {
        unsigned int v78 = 3;
      }
      if (*(_DWORD *)(a1 + 168)) {
        return 0;
      }
      if (*(void *)(a1 + 2312) && !*(void *)(a1 + 2328)) {
        ExtendLastCommand(a1, &v248, &v247);
      }
      int v79 = *(_DWORD *)(a1 + 4);
      if (v79 == 11)
      {
        BrotliCreateHqZopfliBackwardReferences((uint64_t)v243, v248, v247, (uint64_t)v18, v41, (uint64_t)&_kBrotliContextLookupTable[512 * v78], a1, (uint64_t)v241, (long long *)(a1 + 2352), (void *)(a1 + 2328), *(void *)(a1 + 2304) + 16 * *(void *)(a1 + 2312), (uint64_t *)(a1 + 2312), (void *)(a1 + 2320));
      }
      else
      {
        if (v79 != 10)
        {
          BrotliCreateBackwardReferences(v248, v247, (uint64_t)v18, v41, a6.n128_f64[0], a7.n128_f64[0], a8, (uint64_t)&_kBrotliContextLookupTable[512 * v78], a1, (uint64_t)v241, (int *)(a1 + 2352), (unint64_t *)(a1 + 2328), (_DWORD *)(*(void *)(a1 + 2304) + 16 * *(void *)(a1 + 2312)), (void *)(a1 + 2312), (void *)(a1 + 2320));
          goto LABEL_187;
        }
        BrotliCreateZopfliBackwardReferences((uint64_t)v243, v248, v247, (uint64_t)v18, v41, (uint64_t)&_kBrotliContextLookupTable[512 * v78], a1, v241, a1 + 2352, (void *)(a1 + 2328), *(void *)(a1 + 2304) + 16 * *(void *)(a1 + 2312), (void *)(a1 + 2312), (void *)(a1 + 2320));
      }
      if (*(_DWORD *)(a1 + 168)) {
        return 0;
      }
LABEL_187:
      int v104 = *(_DWORD *)(a1 + 8);
      int v105 = *(_DWORD *)(a1 + 12);
      if (v104 <= v105) {
        int v104 = *(_DWORD *)(a1 + 12);
      }
      if (v104 >= 23) {
        char v106 = 23;
      }
      else {
        char v106 = v104;
      }
      uint64_t v107 = *(void *)(a1 + 2248);
      uint64_t v108 = *(void *)(a1 + 2336);
      BOOL v109 = *(int *)(a1 + 4) <= 3 && *(void *)(a1 + 2312) + *(void *)(a1 + 2320) > 0x2FFEuLL;
      uint64_t v110 = v107 - v108;
      if (v14 | v240
        || v109
        || (unint64_t v111 = 1 << (v106 + 1), v110 + (1 << v105) > v111)
        || *(void *)(a1 + 2320) >= v111 >> 3
        || *(void *)(a1 + 2312) >= v111 >> 3)
      {
        unint64_t v112 = *(void *)(a1 + 2328);
        if (v112)
        {
          uint64_t v113 = *(void *)(a1 + 2304);
          uint64_t v114 = *(void *)(a1 + 2312);
          *(void *)(a1 + 2312) = v114 + 1;
          uint64_t v115 = v113 + 16 * v114;
          *(_DWORD *)uint64_t v115 = v112;
          *(void *)(v115 + 4) = 0x8000000;
          *(_WORD *)(v115 + 14) = 16;
          int v116 = (_WORD *)(v115 + 12);
          if (v112 > 5)
          {
            if (v112 > 0x81)
            {
              if (v112 > 0x841)
              {
                if (v112 >> 1 >= 0xC21)
                {
                  if (v112 < 0x5842) {
                    LOWORD(v117) = 22;
                  }
                  else {
                    LOWORD(v117) = 23;
                  }
                }
                else
                {
                  LOWORD(v117) = 21;
                }
              }
              else
              {
                unsigned int v117 = (__clz(v112 - 66) ^ 0x1F) + 10;
              }
            }
            else
            {
              unsigned int v132 = (__clz(v112 - 2) ^ 0x1F) - 1;
              unsigned int v117 = ((v112 - 2) >> v132) + 2 * v132 + 2;
            }
          }
          else
          {
            LOWORD(v117) = v112;
          }
          *int v116 = ((((0x520D40u >> (6 * ((unsigned __int16)v117 >> 3))) & 0xC0) + 192 * ((unsigned __int16)v117 >> 3)) & 0xFFC7 | (8 * (v117 & 7)))
                + 66;
          *(void *)(a1 + 2320) += v112;
          *(void *)(a1 + 2328) = 0;
        }
        if (v240 || v107 != v108)
        {
          uint64_t BrotliStorage = (char *)GetBrotliStorage(a1, (2 * v110 + 503));
          unint64_t v246 = *(unsigned __int8 *)(a1 + 2434);
          if (!*(_DWORD *)(a1 + 168))
          {
            long long v235 = BrotliStorage;
            *uint64_t BrotliStorage = *(unsigned char *)(a1 + 2432);
            BrotliStorage[1] = *(unsigned char *)(a1 + 2433);
            WriteMetaBlockInternal(v243, (uint64_t)v18, v244, *(void *)(a1 + 2336), v110, v240, v78, a1, *(_WORD *)(a1 + 2436), HIBYTE(*(_WORD *)(a1 + 2436)), *(void *)(a1 + 2320), *(void *)(a1 + 2312), *(unsigned int **)(a1 + 2304), (_OWORD *)(a1 + 2416), (_OWORD *)(a1 + 2352), &v246, BrotliStorage);
            if (!*(_DWORD *)(a1 + 168))
            {
              char v236 = v246;
              unint64_t v237 = v246 >> 3;
              *(_WORD *)(a1 + 2432) = v235[v246 >> 3];
              *(unsigned char *)(a1 + 2434) = v236 & 7;
              *(void *)(a1 + 2336) = *(void *)(a1 + 2248);
              if (UpdateLastProcessedPos(a1)) {
                *(_DWORD *)(a1 + 2500) = 0;
              }
              uint64_t v238 = *(void *)(a1 + 2336);
              if (v238)
              {
                *(unsigned char *)(a1 + 2436) = *((unsigned char *)v18 + ((v238 - 1) & v244));
                if (v238 != 1) {
                  *(unsigned char *)(a1 + 2437) = *((unsigned char *)v18 + ((v238 - 2) & v244));
                }
              }
              *(void *)(a1 + 2312) = 0;
              *(void *)(a1 + 2320) = 0;
              *(_OWORD *)(a1 + 2416) = *(_OWORD *)(a1 + 2352);
              *int8x8_t v12 = (uint64_t)v235;
              *size_t v13 = v237;
              return 1;
            }
          }
          return 0;
        }
      }
      else if (UpdateLastProcessedPos(a1))
      {
        *(_DWORD *)(a1 + 2500) = 0;
      }
      *size_t v13 = 0;
      return 1;
    }
    a6 = *v42;
    *(__n128 *)(a1 + 2480) = *v42;
    *(_DWORD *)(a1 + 2496) = *(_DWORD *)(a1 + 56);
    int v54 = *(_DWORD *)(a1 + 2480);
    if (v54 <= 34)
    {
      switch(v54)
      {
        case 2:
        case 3:
        case 4:
          goto LABEL_97;
        case 5:
          InitializeH5(v241, a1 + 2504);
          break;
        case 6:
          InitializeH6(v241, a1 + 2504);
          break;
        case 10:
          *(void *)(a1 + 2512) = v47;
          *(void *)(a1 + 2528) = v47 + 0x80000;
          int v61 = -1 << *(_DWORD *)(a1 + 8);
          *(void *)(a1 + 2504) = ~v61;
          *(_DWORD *)(a1 + 2520) = v61 + 1;
          break;
        default:
          break;
      }
    }
    else if (v54 > 53)
    {
      switch(v54)
      {
        case '6':
LABEL_97:
          *(void *)(a1 + 2504) = v241;
          *(void *)(a1 + 2512) = v47;
          break;
        case '7':
LABEL_98:
          *(void *)(a1 + 2616) = v241;
          *(void *)(a1 + 2608) = v47;
          a7 = *(__n128 *)(a1 + 2472);
          *(_OWORD *)(a1 + 2560) = *(_OWORD *)v241;
          *(__n128 *)(a1 + 2576) = a7;
          a6 = *(__n128 *)(a1 + 2488);
          *(__n128 *)(a1 + 2592) = a6;
          *(_DWORD *)(a1 + 2624) = 1;
          *(void *)(a1 + 2632) = a1;
          break;
        case 'A':
          *(void *)(a1 + 2672) = v241;
          *(void *)(a1 + 2664) = v47;
          a7 = *(__n128 *)(a1 + 2472);
          *(_OWORD *)(a1 + 2616) = *(_OWORD *)v241;
          *(__n128 *)(a1 + 2632) = a7;
          a6 = *(__n128 *)(a1 + 2488);
          *(__n128 *)(a1 + 2648) = a6;
          *(_DWORD *)(a1 + 2680) = 1;
          *(void *)(a1 + 2688) = a1;
          break;
      }
    }
    else
    {
      switch(v54)
      {
        case '#':
          goto LABEL_98;
        case '(':
        case ')':
          *(void *)(a1 + 2528) = v241;
          *(void *)(a1 + 2520) = v47;
          int v55 = *(_DWORD *)(a1 + 4);
          if (v55 >= 7) {
            int v56 = 7;
          }
          else {
            int v56 = 8;
          }
          *(void *)(a1 + 2512) = (v56 << (v55 - 4));
          break;
        case '*':
          *(void *)(a1 + 3544) = v241;
          *(void *)(a1 + 3536) = v47;
          int v62 = *(_DWORD *)(a1 + 4);
          if (v62 >= 7) {
            int v63 = 7;
          }
          else {
            int v63 = 8;
          }
          *(void *)(a1 + 3528) = (v63 << (v62 - 4));
          break;
        default:
          break;
      }
    }
    *(_DWORD *)(a1 + 2500) = 0;
LABEL_117:
    int v64 = *(_DWORD *)(a1 + 2480);
    if (v64 <= 34)
    {
      switch(v64)
      {
        case 2:
          size_t v65 = *(_DWORD **)(a1 + 2512);
          if (v38 > 0x800 || !v40) {
            goto LABEL_144;
          }
          if (!v38) {
            goto LABEL_150;
          }
          size_t v66 = v18;
          unint64_t v67 = v38;
          do
          {
            uint64_t v68 = *(void *)v66;
            size_t v66 = (int *)((char *)v66 + 1);
            *(_DWORD *)((char *)v65 + (((0xBD1E35A7BD000000 * v68) >> 46) & 0x3FFFC)) = 0;
            --v67;
          }
          while (v67);
          break;
        case 3:
          size_t v65 = *(_DWORD **)(a1 + 2512);
          if (v38 <= 0x800 && v40)
          {
            if (!v38) {
              goto LABEL_150;
            }
            unint64_t v69 = v18;
            unint64_t v70 = v38;
            do
            {
              uint64_t v71 = *(void *)v69;
              unint64_t v69 = (int *)((char *)v69 + 1);
              unint64_t v72 = (0xBD1E35A7BD000000 * v71) >> 48;
              v65[v72] = 0;
              v65[(unsigned __int16)(v72 + 8)] = 0;
              --v70;
            }
            while (v70);
          }
          else
          {
LABEL_144:
            bzero(v65, 0x40000uLL);
          }
          break;
        case 4:
          PrepareH4(a1 + 2504, v40, v38, (uint64_t)v18);
          break;
        case 5:
          PrepareH5((unint64_t *)(a1 + 2504), v40, v38, v18);
          break;
        case 6:
          PrepareH6((unint64_t *)(a1 + 2504), v40, v38, (uint64_t *)v18);
          break;
        case 10:
          uint64_t v73 = 0;
          uint64_t v74 = *(void *)(a1 + 2512);
          __n128 v75 = (const float *)(a1 + 2520);
          a6 = (__n128)vld1q_dup_f32(v75);
          do
          {
            *(__n128 *)(v74 + v73) = a6;
            v73 += 16;
          }
          while (v73 != 0x80000);
          break;
        default:
          break;
      }
    }
    else if (v64 > 53)
    {
      switch(v64)
      {
        case '6':
          PrepareH54(a1 + 2504, v40, v38, (uint64_t)v18);
          break;
        case '7':
          PrepareH55(a1 + 2504, v40, v38, (uint64_t)v18);
          break;
        case 'A':
          PrepareH65(a1 + 2504, v40, v38, (uint64_t *)v18);
          break;
      }
    }
    else
    {
      switch(v64)
      {
        case '#':
          PrepareH35(a1 + 2504, v40, v38, (uint64_t *)v18);
          break;
        case '(':
        case ')':
          PrepareH40(a1 + 2504, v40, v38, v18);
          break;
        case '*':
          PrepareH42((void **)(a1 + 2504), v40, v38, v18);
          break;
        default:
          break;
      }
    }
    if (!v11)
    {
LABEL_150:
      *(void *)(a1 + 2472) = 0;
      *(void *)(a1 + 2464) = 0;
    }
    *(_DWORD *)(a1 + 2500) = 1;
    goto LABEL_152;
  }
LABEL_14:
  long long v23 = v12;
  int v24 = v18;
  unint64_t v25 = *(unsigned __int8 *)(a1 + 2434);
  unint64_t v245 = 0;
  unint64_t v246 = v25;
  if (!a2)
  {
    unint64_t v26 = 0;
    if (v8 == v9) {
      goto LABEL_16;
    }
  }
  unint64_t v27 = v17;
  int v28 = a2;
  int v29 = (unsigned char *)GetBrotliStorage(a1, (2 * v10 + 503));
  if (*(_DWORD *)(a1 + 168)) {
    return 0;
  }
  uint64_t v30 = (uint64_t)v29;
  *int v29 = *(unsigned char *)(a1 + 2432);
  v29[1] = *(unsigned char *)(a1 + 2433);
  HashTable = GetHashTable(a1, *(_DWORD *)(a1 + 4), v10, &v245);
  if (*(_DWORD *)(a1 + 168)) {
    return 0;
  }
  uint64_t v32 = (char *)v24 + (v244 & v11);
  if (*(_DWORD *)(a1 + 4)) {
    BrotliCompressFragmentTwoPass(v27, v32, v10, v28, *(unsigned int **)(a1 + 8568), *(char **)(a1 + 8576), (uint64_t)HashTable, v245, &v246, v30);
  }
  else {
    BrotliCompressFragmentFast(v27, (unsigned __int8 *)v32, v10, v28, (uint64_t)HashTable, v245, (unsigned __int8 *)(a1 + 7664), a1 + 7792, (unint64_t *)(a1 + 8560), (unsigned char *)(a1 + 8048), &v246, v30);
  }
  if (*(_DWORD *)(a1 + 168)) {
    return 0;
  }
  char v49 = v246;
  unint64_t v26 = v246 >> 3;
  *(_WORD *)(a1 + 2432) = *(unsigned __int8 *)(v30 + (v246 >> 3));
  *(unsigned char *)(a1 + 2434) = v49 & 7;
  UpdateLastProcessedPos(a1);
  *long long v23 = v30;
LABEL_16:
  *size_t v13 = v26;
  return 1;
}

BOOL BrotliEncoderHasMoreOutput(uint64_t a1)
{
  return *(void *)(a1 + 8592) != 0;
}

uint64_t BrotliEncoderTakeOutput(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *(void *)(a1 + 8592);
  if (*a2 >= v2) {
    unint64_t v3 = *(void *)(a1 + 8592);
  }
  else {
    unint64_t v3 = *a2;
  }
  if (!*a2) {
    unint64_t v3 = *(void *)(a1 + 8592);
  }
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 8584);
    *(void *)(a1 + 8584) = v4 + v3;
    *(void *)(a1 + 8592) = v2 - v3;
    *(void *)(a1 + 8600) += v3;
    if (*(_DWORD *)(a1 + 8628) == 1 && v2 == v3)
    {
      *(_DWORD *)(a1 + 8628) = 0;
      *(void *)(a1 + 8584) = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *a2 = v3;
  return v4;
}

uint64_t BrotliEncoderVersion()
{
  return 16777225;
}

uint64_t ChooseDistanceParams(_DWORD *a1)
{
  if ((int)a1[1] < 4
    || (*a1 != 2 ? (unsigned int v2 = a1[16], v1 = a1[17]) : (v1 = 12, unsigned int v2 = 1), v2 > 3 || v1 > 0x78 || ((v1 >> v2) & 0xF) << v2 != v1))
  {
    unsigned int v2 = 0;
    unsigned int v1 = 0;
  }
  return BrotliInitDistanceParams((uint64_t)a1, v2, v1);
}

BOOL ShouldCompress(uint64_t a1, unsigned int a2, int a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (a4 < 3) {
    return 0;
  }
  if ((a4 >> 8) + 2 <= a6 || (double)a4 * 0.99 >= (double)a5) {
    return 1;
  }
  bzero(v25, 0x400uLL);
  if (a4 + 12 >= 0xD)
  {
    unint64_t v11 = (a4 + 12) / 0xD;
    do
    {
      uint64_t v12 = *(unsigned __int8 *)(a1 + (a3 & a2));
      ++v25[v12];
      a3 += 13;
      --v11;
    }
    while (v11);
  }
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  double v15 = 0.0;
  double v16 = (double)a4 * 7.92 / 13.0;
  do
  {
    uint64_t v17 = &v25[v14];
    uint64_t v18 = *v17;
    if (v18 > 0xFF) {
      double v19 = log2((double)v18);
    }
    else {
      double v19 = kBrotliLog2Table[v18];
    }
    uint64_t v20 = v17[1];
    if (v20 > 0xFF) {
      double v21 = log2((double)v20);
    }
    else {
      double v21 = kBrotliLog2Table[v20];
    }
    v14 += 2;
    v13 += v18 + v20;
    double v15 = v15 - (double)v18 * v19 - (double)v20 * v21;
  }
  while ((unint64_t)(v14 - 2) < 0xFE);
  double v22 = (double)v13;
  if (v13)
  {
    if (v13 > 0xFF) {
      double v23 = log2((double)v13);
    }
    else {
      double v23 = kBrotliLog2Table[v13];
    }
    double v15 = v15 + v22 * v23;
  }
  double v24 = v15 >= v22 ? v15 : (double)v13;
  return v24 <= v16;
}

uint64_t *InitializeH5(uint64_t *result, uint64_t a2)
{
  int v2 = *((_DWORD *)result + 7);
  int v3 = *((_DWORD *)result + 8);
  int v4 = 32 - v2;
  uint64_t v5 = 1 << v2;
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = 1 << v3;
  *(_DWORD *)(a2 + 16) = v4;
  *(_DWORD *)(a2 + 20) = (1 << v3) - 1;
  uint64_t v6 = *result;
  *(void *)(a2 + 32) = result;
  *(void *)(a2 + 40) = v6;
  *(void *)(a2 + 48) = v6 + 2 * v5;
  LODWORD(v6) = *((_DWORD *)result + 10);
  *(_DWORD *)(a2 + 24) = v3;
  *(_DWORD *)(a2 + 28) = v6;
  return result;
}

uint64_t *InitializeH6(uint64_t *result, uint64_t a2)
{
  int v2 = *((_DWORD *)result + 7);
  int v3 = *((_DWORD *)result + 8);
  *(_DWORD *)(a2 + 16) = 64 - v2;
  int v4 = *((_DWORD *)result + 10);
  *(void *)(a2 + 24) = 0xFFFFFFFFFFFFFFFFLL >> (-8 * *((unsigned char *)result + 36));
  uint64_t v5 = 1 << v2;
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = 1 << v3;
  *(_DWORD *)(a2 + 32) = (1 << v3) - 1;
  *(_DWORD *)(a2 + 36) = v3;
  *(_DWORD *)(a2 + 40) = v4;
  uint64_t v6 = *result;
  *(void *)(a2 + 48) = result;
  *(void *)(a2 + 56) = v6;
  *(void *)(a2 + 64) = v6 + 2 * v5;
  return result;
}

void PrepareH4(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  int v4 = *(_DWORD **)(a1 + 8);
  if (a2 && a3 <= 0x1000)
  {
    if (a3)
    {
      for (uint64_t i = 0; i != a3; ++i)
      {
        int v6 = 0;
        unint64_t v7 = (0xBD1E35A7BD000000 * *(void *)(a4 + i)) >> 47;
        do
        {
          v4[(v7 + v6) & 0x1FFFF] = 0;
          v6 += 8;
        }
        while (v6 != 32);
      }
    }
  }
  else
  {
    bzero(v4, 0x80000uLL);
  }
}

void PrepareH5(unint64_t *a1, int a2, unint64_t a3, int *a4)
{
  uint64_t v5 = (_WORD *)a1[5];
  unint64_t v6 = *a1;
  if (a2 && v6 >> 6 >= a3)
  {
    if (a3)
    {
      int v7 = *((_DWORD *)a1 + 4);
      do
      {
        int v8 = *a4;
        a4 = (int *)((char *)a4 + 1);
        v5[(506832829 * v8) >> v7] = 0;
        --a3;
      }
      while (a3);
    }
  }
  else
  {
    bzero(v5, 2 * v6);
  }
}

void PrepareH6(unint64_t *a1, int a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v5 = (_WORD *)a1[7];
  unint64_t v6 = *a1;
  if (a2 && v6 >> 6 >= a3)
  {
    if (a3)
    {
      unint64_t v7 = a1[3];
      int v8 = *((_DWORD *)a1 + 4);
      do
      {
        uint64_t v9 = *a4;
        a4 = (uint64_t *)((char *)a4 + 1);
        v5[((0x1FE35A7BD3579BD3 * (v9 & v7)) >> v8)] = 0;
        --a3;
      }
      while (a3);
    }
  }
  else
  {
    bzero(v5, 2 * v6);
  }
}

void PrepareH40(uint64_t a1, int a2, unint64_t a3, int *a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (a2 && a3 <= 0x200)
  {
    for (; a3; --a3)
    {
      int v6 = *a4;
      a4 = (int *)((char *)a4 + 1);
      unsigned int v7 = (506832829 * v6) >> 17;
      *(_DWORD *)(v5 + 4 * v7) = -858993460;
      *(_WORD *)(v5 + 0x20000 + 2 * v7) = -13108;
    }
  }
  else
  {
    memset(*(void **)(a1 + 16), 204, 0x20000uLL);
    bzero((void *)(v5 + 0x20000), 0x10000uLL);
  }
  bzero((void *)(v5 + 196608), 0x10000uLL);
  *(_WORD *)a1 = 0;
}

void PrepareH42(void **a1, int a2, unint64_t a3, int *a4)
{
  uint64_t v5 = a1[129];
  if (a2 && a3 <= 0x200)
  {
    for (; a3; --a3)
    {
      int v6 = *a4;
      a4 = (int *)((char *)a4 + 1);
      unsigned int v7 = (506832829 * v6) >> 17;
      v5[v7] = -858993460;
      *((_WORD *)v5 + v7 + 0x10000) = -13108;
    }
  }
  else
  {
    memset(a1[129], 204, 0x20000uLL);
    bzero(v5 + 0x8000, 0x10000uLL);
  }
  bzero(v5 + 49152, 0x10000uLL);

  bzero(a1, 0x400uLL);
}

void PrepareH54(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  int v4 = *(_DWORD **)(a1 + 8);
  if (a2 && a3 <= 0x8000)
  {
    if (a3)
    {
      for (uint64_t i = 0; i != a3; ++i)
      {
        int v6 = 0;
        unint64_t v7 = (unint64_t)(0x35A7BD1E35A7BD00 * *(void *)(a4 + i)) >> 44;
        do
        {
          v4[(v7 + v6) & 0xFFFFF] = 0;
          v6 += 8;
        }
        while (v6 != 32);
      }
    }
  }
  else
  {
    bzero(v4, 0x400000uLL);
  }
}

void PrepareH35(uint64_t a1, int a2, unint64_t a3, uint64_t *a4)
{
  if (*(_DWORD *)(a1 + 120))
  {
    *(_DWORD *)(a1 + 120) = 0;
    int v8 = *(void ***)(a1 + 112);
    uint64_t v9 = (void *)(*(void *)(a1 + 104) + 0x40000);
    *(void *)(a1 + 56) = v9;
    unint64_t v10 = *v8;
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 16) = 0;
    *(void *)(a1 + 44) = 0x16C4362100010DCDLL;
    *(void *)(a1 + 24) = v9;
    *(void *)(a1 + 32) = 0;
    memset(v9, 255, 0x4000000uLL);
    if (!a2) {
      goto LABEL_10;
    }
  }
  else
  {
    unint64_t v10 = *(void **)(a1 + 8);
    if (!a2)
    {
LABEL_10:
      bzero(v10, 0x40000uLL);
      goto LABEL_11;
    }
  }
  if (a3 > 0x800) {
    goto LABEL_10;
  }
  if (!a3) {
    return;
  }
  unint64_t v11 = a4;
  unint64_t v12 = a3;
  do
  {
    uint64_t v13 = *v11;
    unint64_t v11 = (uint64_t *)((char *)v11 + 1);
    unint64_t v14 = (0xBD1E35A7BD000000 * v13) >> 48;
    *((_DWORD *)v10 + v14) = 0;
    *((_DWORD *)v10 + (unsigned __int16)(v14 + 8)) = 0;
    --v12;
  }
  while (v12);
LABEL_11:
  if (a3 >= 0x20)
  {
    unint64_t v15 = 0;
    int v16 = 0;
    do
    {
      int v16 = *((unsigned __int8 *)a4 + v15) + v16 * *(_DWORD *)(a1 + 44) + 1;
      BOOL v17 = v15 >= 0x1C;
      v15 += 4;
    }
    while (!v17);
    *(_DWORD *)(a1 + 16) = v16;
  }
}

void PrepareH55(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 120))
  {
    *(_DWORD *)(a1 + 120) = 0;
    int v8 = *(uint64_t **)(a1 + 112);
    uint64_t v9 = (void *)(*(void *)(a1 + 104) + 0x400000);
    *(void *)(a1 + 56) = v9;
    uint64_t v10 = *v8;
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 16) = 0;
    *(void *)(a1 + 44) = 0x16C4362100010DCDLL;
    *(void *)(a1 + 24) = v9;
    *(void *)(a1 + 32) = 0;
    memset(v9, 255, 0x4000000uLL);
  }
  PrepareH54(a1, a2, a3, a4);
  if (a3 >= 0x20)
  {
    unint64_t v11 = 0;
    int v12 = 0;
    do
    {
      int v12 = *(unsigned __int8 *)(a4 + v11) + v12 * *(_DWORD *)(a1 + 44) + 1;
      BOOL v13 = v11 >= 0x1C;
      v11 += 4;
    }
    while (!v13);
    *(_DWORD *)(a1 + 16) = v12;
  }
}

void PrepareH65(uint64_t a1, int a2, unint64_t a3, uint64_t *a4)
{
  if (*(_DWORD *)(a1 + 176))
  {
    int v8 = *(uint64_t **)(a1 + 168);
    uint64_t v9 = (void *)(*(void *)(a1 + 160)
                + (2 << *(_DWORD *)(*(void *)(a1 + 184) + 44))
                + (4 << *(_DWORD *)(*(void *)(a1 + 184) + 44) << *(_DWORD *)(*(void *)(a1 + 184) + 48)));
    int v10 = *((_DWORD *)v8 + 7);
    int v11 = *((_DWORD *)v8 + 8);
    *(_DWORD *)(a1 + 16) = 64 - v10;
    int v12 = *((_DWORD *)v8 + 10);
    unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * *((unsigned char *)v8 + 36));
    *(_DWORD *)(a1 + 176) = 0;
    *(void *)(a1 + 112) = v9;
    *(void *)(a1 + 24) = v13;
    uint64_t v14 = 1 << v10;
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = 1 << v11;
    *(_DWORD *)(a1 + 32) = (1 << v11) - 1;
    *(_DWORD *)(a1 + 36) = v11;
    *(_DWORD *)(a1 + 40) = v12;
    uint64_t v15 = *v8;
    *(void *)(a1 + 48) = v8;
    *(void *)(a1 + 56) = v15;
    *(void *)(a1 + 64) = v15 + 2 * v14;
    *(_DWORD *)(a1 + 72) = 0;
    *(void *)(a1 + 100) = 0xF1EBF08100010DCDLL;
    *(void *)(a1 + 80) = v9;
    *(void *)(a1 + 88) = 0;
    memset(v9, 255, 0x4000000uLL);
  }
  PrepareH6((unint64_t *)a1, a2, a3, a4);
  if (a3 >= 0x20)
  {
    uint64_t v16 = 0;
    int v17 = 0;
    do
      int v17 = *((unsigned __int8 *)a4 + v16++) + v17 * *(_DWORD *)(a1 + 100) + 1;
    while (v16 != 32);
    *(_DWORD *)(a1 + 72) = v17;
  }
}

uint64_t GetBrotliStorage(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 2440) >= a2) {
    return *(void *)(a1 + 2448);
  }
  BrotliFree(a1 + 144, *(void *)(a1 + 2448));
  *(void *)(a1 + 2448) = 0;
  uint64_t v4 = BrotliAllocate(a1 + 144);
  uint64_t result = 0;
  *(void *)(a1 + 2448) = v4;
  if (!*(_DWORD *)(a1 + 168))
  {
    *(void *)(a1 + 2440) = a2;
    return v4;
  }
  return result;
}

void *GetHashTable(uint64_t a1, int a2, unint64_t a3, unint64_t *a4)
{
  unint64_t v6 = 0x20000;
  if (!a2) {
    unint64_t v6 = 0x8000;
  }
  if (v6 >= a3) {
    unint64_t v7 = a3;
  }
  else {
    unint64_t v7 = v6;
  }
  uint64_t v8 = 256;
  do
  {
    unint64_t v9 = v8;
    v8 *= 2;
  }
  while (v9 < v7);
  if ((v9 & 0xAAA00) == 0 && a2 == 0) {
    unint64_t v11 = v8;
  }
  else {
    unint64_t v11 = v9;
  }
  if (v11 <= 0x400)
  {
    int v12 = (void *)(a1 + 3552);
LABEL_20:
    *a4 = v11;
    bzero(v12, 4 * v11);
    return v12;
  }
  if (v11 <= *(void *)(a1 + 7656))
  {
    int v12 = *(void **)(a1 + 7648);
    goto LABEL_20;
  }
  *(void *)(a1 + 7656) = v11;
  BrotliFree(a1 + 144, *(void *)(a1 + 7648));
  *(void *)(a1 + 7648) = 0;
  uint64_t v13 = BrotliAllocate(a1 + 144);
  int v12 = 0;
  *(void *)(a1 + 7648) = v13;
  if (!*(_DWORD *)(a1 + 168))
  {
    int v12 = (void *)v13;
    goto LABEL_20;
  }
  return v12;
}

BOOL UpdateLastProcessedPos(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 2344);
  if (v1 >> 30 >= 3) {
    LODWORD(v1) = (((2 * (int)v1) >> 1) & 0xC0000000 | v1 & 0x3FFFFFFF) ^ 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 2248);
  unsigned int v3 = (((2 * (int)v2) >> 1) & 0xC0000000 | v2 & 0x3FFFFFFF) ^ 0x80000000;
  if (v2 <= 0xBFFFFFFF) {
    unsigned int v3 = *(void *)(a1 + 2248);
  }
  *(void *)(a1 + 2344) = v2;
  return v3 < v1;
}

uint64_t ExtendLastCommand(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v3 = *(void *)(result + 2304);
  uint64_t v4 = *(void *)(result + 2312) - 1;
  uint64_t v5 = (unsigned int *)(v3 + 16 * v4);
  unint64_t v6 = v5 + 1;
  unsigned int v7 = v5[1];
  uint64_t v8 = v7 & 0x1FFFFFF;
  if (*(void *)(result + 2344) - v8 >= (unint64_t)((1 << *(_DWORD *)(result + 8)) - 16)) {
    unint64_t v9 = (1 << *(_DWORD *)(result + 8)) - 16;
  }
  else {
    unint64_t v9 = *(void *)(result + 2344) - v8;
  }
  unint64_t v10 = *(int *)(result + 2352);
  unsigned int v11 = *((unsigned __int16 *)v5 + 7);
  unsigned int v12 = v11 & 0x3FF;
  int v13 = *(_DWORD *)(result + 68);
  if (v12 >= v13 + 16) {
    unsigned int v12 = v13
  }
        + 16
        + ((v12 - v13 - 16) & ~(-1 << *(_DWORD *)(result + 64)))
        + ((v5[2] + ((((v12 - v13 - 16) >> *(_DWORD *)(result + 64)) & 1 | 2) << (v11 >> 10)) - 4) << *(_DWORD *)(result + 64));
  if (v12 < 0x10 || v12 - 15 == v10)
  {
    if (v9 >= v10 && *a2)
    {
      uint64_t v15 = *(void *)(result + 2288);
      uint64_t v16 = *(unsigned int *)(result + 2260);
      uint64_t v17 = *a3;
      while (1)
      {
        int v18 = *(unsigned __int8 *)(v15 + (v17 & v16));
        uint64_t result = *(unsigned __int8 *)(v15 + ((v17 - v10) & v16));
        unsigned int v7 = *v6;
        if (v18 != result) {
          break;
        }
        *unint64_t v6 = v7 + 1;
        --*a2;
        uint64_t v17 = (*a3 + 1);
        *a3 = v17;
        if (!*a2)
        {
          unsigned int v7 = *v6;
          break;
        }
      }
      LODWORD(v8) = v7 & 0x1FFFFFF;
    }
    unint64_t v19 = *v5;
    uint64_t v20 = v8 + (v7 >> 25);
    int v21 = v11 & 0x3FF;
    if (v19 > 5)
    {
      if (v19 > 0x81)
      {
        if (v19 > 0x841)
        {
          if (v19 >> 1 >= 0xC21)
          {
            if (v19 < 0x5842) {
              LOWORD(v19) = 22;
            }
            else {
              LOWORD(v19) = 23;
            }
          }
          else
          {
            LOWORD(v19) = 21;
          }
        }
        else
        {
          LODWORD(v19) = (__clz(v19 - 66) ^ 0x1F) + 10;
        }
      }
      else
      {
        v19 -= 2;
        unsigned int v22 = (__clz(v19) ^ 0x1F) - 1;
        LODWORD(v19) = (v19 >> v22) + 2 * v22 + 2;
      }
    }
    uint64_t v23 = v3 + 16 * v4;
    if (v20 > 9)
    {
      unsigned int v25 = (__clz(v20 - 70) ^ 0x1F) + 12;
      if (v20 <= 0x845) {
        __int16 v26 = v25;
      }
      else {
        __int16 v26 = 23;
      }
      unsigned int v27 = (__clz(v20 - 6) ^ 0x1F) - 1;
      if (v20 <= 0x85) {
        unsigned __int16 v24 = ((unint64_t)(v20 - 6) >> v27) + 2 * v27 + 4;
      }
      else {
        unsigned __int16 v24 = v26;
      }
    }
    else
    {
      unsigned __int16 v24 = v8 + (v7 >> 25) - 2;
    }
    int v28 = (_WORD *)(v23 + 12);
    unsigned int v29 = v24 & 7 | (8 * (v19 & 7));
    if (v21 || (unsigned __int16)v19 > 7u || v24 > 0xFu)
    {
      int v30 = 3 * ((unsigned __int16)v19 >> 3) + ((unsigned __int16)(v24 & 0xFFF8) >> 3);
      unsigned int v29 = ((((0x520D40u >> (2 * v30)) & 0xC0) + (v30 << 6)) | v29) + 64;
    }
    else if ((v24 & 0xFFF8) != 0)
    {
      LOWORD(v29) = v29 | 0x40;
    }
    *int v28 = v29;
  }
  return result;
}

void WriteMetaBlockInternal(_DWORD *a1, uint64_t a2, size_t a3, unint64_t a4, unint64_t a5, unsigned int a6, unsigned int a7, uint64_t a8, unsigned __int8 a9, unsigned __int8 a10, unint64_t a11, unint64_t a12, unsigned int *a13, _OWORD *a14, _OWORD *a15, unint64_t *a16, char *a17)
{
  if (a4 >> 30 < 3) {
    unsigned int v38 = a4;
  }
  else {
    unsigned int v38 = (((2 * (int)a4) >> 1) & 0xC0000000 | a4 & 0x3FFFFFFF) ^ 0x80000000;
  }
  long long v22 = *(_OWORD *)(a8 + 112);
  long long v52 = *(_OWORD *)(a8 + 96);
  long long v53 = v22;
  long long v54 = *(_OWORD *)(a8 + 128);
  long long v23 = *(_OWORD *)(a8 + 48);
  v49[2] = *(_OWORD *)(a8 + 32);
  v49[3] = v23;
  long long v24 = *(_OWORD *)(a8 + 80);
  long long v50 = *(_OWORD *)(a8 + 64);
  long long v51 = v24;
  long long v25 = *(_OWORD *)(a8 + 16);
  v49[0] = *(_OWORD *)a8;
  v49[1] = v25;
  if (!a5)
  {
    unint64_t v27 = *a16;
    *(void *)&a17[*a16 >> 3] = (3 << (*a16 & 7)) | a17[*a16 >> 3];
    *a16 = (v27 + 9) & 0xFFFFFFF8;
    return;
  }
  if (ShouldCompress(a2, a3, a4, a5, a11, a12))
  {
    int v26 = *(_DWORD *)(a8 + 4);
    char v35 = a17[1];
    unint64_t v34 = *(unsigned __int8 *)a16;
    char v33 = *a17;
    if (v26 <= 2)
    {
      BrotliStoreMetaBlockFast((uint64_t)a1, a2, v38, a5, a3, a6, a8, (uint64_t)a13, a12, a16, (uint64_t)a17);
      goto LABEL_14;
    }
    if (v26 == 3)
    {
      BrotliStoreMetaBlockTrivial((uint64_t)a1, a2, v38, a5, a3, a6, a8, (uint64_t)a13, a12, a16, (uint64_t)a17);
LABEL_14:
      if (a1[6]) {
        return;
      }
      goto LABEL_15;
    }
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    memset(v43, 0, sizeof(v43));
    memset(v42, 0, sizeof(v42));
    memset(v41, 0, sizeof(v41));
    BrotliInitBlockSplit(v41);
    BrotliInitBlockSplit(v42);
    BrotliInitBlockSplit(v43);
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v44 = 0u;
    int v28 = *(_DWORD *)(a8 + 4);
    if (v28 > 9)
    {
      BrotliBuildMetaBlock(a1, a2, v38, a3, (uint64_t)v49, a9, a10, (uint64_t)a13, a12, a7, (uint64_t *)v41);
    }
    else
    {
      uint64_t v29 = 0;
      int v30 = &_kBrotliContextLookupTable[512 * a7];
      unint64_t v31 = 1;
      uint64_t v39 = 0;
      unint64_t v40 = 1;
      uint64_t v32 = v38;
      if (!*(_DWORD *)(a8 + 32))
      {
        DecideOverLiteralContextModeling(a2, v38, a5, a3, v28, *(void *)(a8 + 24), (uint64_t *)&v40, &v39);
        uint64_t v32 = v38;
        int v30 = &_kBrotliContextLookupTable[512 * a7];
        uint64_t v29 = v39;
        unint64_t v31 = v40;
      }
      BrotliBuildMetaBlockGreedy((uint64_t)a1, a2, v32, a3, a9, a10, (uint64_t)v30, v31, v29, a13, a12, (uint64_t)v41);
    }
    if (!a1[6])
    {
      if (*(int *)(a8 + 4) >= 4) {
        BrotliOptimizeHistograms(HIDWORD(v50), v41);
      }
      BrotliStoreMetaBlock((uint64_t)a1, a2, v38, a5, a3, a9, a10, a6, (unsigned int *)v49, a7, (uint64_t)a13, a12, (uint64_t)v41, a16, (uint64_t)a17);
      if (!a1[6])
      {
        BrotliDestroyBlockSplit((uint64_t)a1, (uint64_t)v41);
        BrotliDestroyBlockSplit((uint64_t)a1, (uint64_t)v42);
        BrotliDestroyBlockSplit((uint64_t)a1, (uint64_t)v43);
        BrotliFree((uint64_t)a1, v44);
        *(void *)&long long v44 = 0;
        BrotliFree((uint64_t)a1, v45);
        *(void *)&long long v45 = 0;
        BrotliFree((uint64_t)a1, v46);
        *(void *)&long long v46 = 0;
        BrotliFree((uint64_t)a1, v47);
        *(void *)&long long v47 = 0;
        BrotliFree((uint64_t)a1, v48);
LABEL_15:
        if (a5 + 4 < *a16 >> 3)
        {
          *a15 = *a14;
          *a17 = v33;
          a17[1] = v35;
          *a16 = v34;
          BrotliStoreUncompressedMetaBlock(a6, a2, v38, a3, a5, (uint64_t *)a16, (uint64_t)a17);
        }
      }
    }
  }
  else
  {
    *a15 = *a14;
    BrotliStoreUncompressedMetaBlock(a6, a2, v38, a3, a5, (uint64_t *)a16, (uint64_t)a17);
  }
}

void DecideOverLiteralContextModeling(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, unint64_t a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v121 = *MEMORY[0x263EF8340];
  if (a3 >= 0x40 && a5 >= 5)
  {
    uint64_t v9 = a2;
    unint64_t v11 = a3 + a2;
    if (a6 >> 20)
    {
      long long v118 = 0u;
      long long v117 = 0u;
      long long v116 = 0u;
      long long v115 = 0u;
      long long v114 = 0u;
      long long v113 = 0u;
      long long v112 = 0u;
      long long v111 = 0u;
      bzero(v109, 0x680uLL);
      unint64_t v13 = v9 + 64;
      if (v9 + 64 <= v11)
      {
        unsigned int v108 = 0;
        uint64_t v14 = v9;
        do
        {
          if (v14 + 2 < v13)
          {
            unint64_t v15 = *(unsigned __int8 *)(a1 + ((v14 + 1) & a4));
            unint64_t v16 = *(unsigned __int8 *)(a1 + (v14 & a4));
            for (uint64_t i = 2; i != 64; ++i)
            {
              unint64_t v18 = v15;
              unint64_t v15 = *(unsigned __int8 *)(a1 + ((v14 + i) & a4));
              uint64_t v19 = ShouldUseComplexStaticContextMap_kStaticContextMapComplexUTF8[4
                                                                                * (*((unsigned char *)&_kBrotliContextLookupTable + v16 + 1280) | *((unsigned char *)&_kBrotliContextLookupTable + v18 + 1024))];
              uint64_t v20 = (v15 >> 1) & 0x7C;
              ++*(_DWORD *)((char *)&v111 + v20);
              int v21 = &v109[8 * v19];
              unint64_t v16 = v18;
              ++*(_DWORD *)((char *)v21 + v20);
            }
            v108 += 62;
          }
          v14 += 4096;
          v13 += 4096;
        }
        while (v13 <= v11);
      }
      else
      {
        unsigned int v108 = 0;
      }
      unint64_t v104 = v11;
      unint64_t v22 = 0;
      uint64_t v23 = 0;
      double v24 = 0.0;
      do
      {
        long long v25 = (unsigned int *)&v111 + v23;
        uint64_t v26 = *v25;
        if (v26 > 0xFF) {
          double v27 = log2((double)v26);
        }
        else {
          double v27 = kBrotliLog2Table[v26];
        }
        uint64_t v28 = v25[1];
        if (v28 > 0xFF) {
          double v29 = log2((double)v28);
        }
        else {
          double v29 = kBrotliLog2Table[v28];
        }
        v23 += 2;
        v22 += v26 + v28;
        double v24 = v24 - (double)v26 * v27 - (double)v28 * v29;
      }
      while ((unint64_t)(v23 - 2) < 0x1E);
      if (v22)
      {
        if (v22 > 0xFF) {
          double v30 = log2((double)v22);
        }
        else {
          double v30 = kBrotliLog2Table[v22];
        }
        double v24 = v24 + (double)v22 * v30;
      }
      uint64_t v31 = 0;
      double v32 = 0.0;
      char v33 = v109;
      do
      {
        unint64_t v34 = 0;
        uint64_t v35 = 0;
        double v36 = 0.0;
        do
        {
          unint64_t v37 = (unsigned int *)v33 + v35;
          uint64_t v38 = *v37;
          if (v38 > 0xFF) {
            double v39 = log2((double)v38);
          }
          else {
            double v39 = kBrotliLog2Table[v38];
          }
          uint64_t v40 = v37[1];
          if (v40 > 0xFF) {
            double v41 = log2((double)v40);
          }
          else {
            double v41 = kBrotliLog2Table[v40];
          }
          v35 += 2;
          v34 += v38 + v40;
          double v36 = v36 - (double)v38 * v39 - (double)v40 * v41;
        }
        while ((unint64_t)(v35 - 2) < 0x1E);
        if (v34)
        {
          if (v34 > 0xFF) {
            double v42 = log2((double)v34);
          }
          else {
            double v42 = kBrotliLog2Table[v34];
          }
          double v36 = v36 + (double)v34 * v42;
        }
        double v32 = v32 + v36;
        ++v31;
        v33 += 8;
      }
      while (v31 != 13);
      double v43 = 1.0 / (double)v108;
      if (v43 * v32 <= 3.0 && v43 * v24 - v43 * v32 >= 0.2)
      {
        *a7 = 13;
        uint64_t v102 = (uint64_t)ShouldUseComplexStaticContextMap_kStaticContextMapComplexUTF8;
        goto LABEL_121;
      }
      unint64_t v12 = v9 + 64;
      unint64_t v11 = v104;
    }
    else
    {
      unint64_t v12 = a2 + 64;
    }
    int v110 = 0;
    memset(v109, 0, sizeof(v109));
    if (v12 <= v11)
    {
      uint64_t v44 = v12 - v9;
      do
      {
        if (v9 + 1 < v12)
        {
          int v45 = *(_DWORD *)((char *)&DecideOverLiteralContextModeling_lut
                          + (((unint64_t)*(unsigned __int8 *)(a1 + (v9 & a4)) >> 4) & 0xC));
          uint64_t v46 = 1;
          do
          {
            int v47 = 3 * v45;
            int v45 = *(_DWORD *)((char *)&DecideOverLiteralContextModeling_lut
                            + (((unint64_t)*(unsigned __int8 *)(a1 + ((v9 + v46) & a4)) >> 4) & 0xC));
            ++*((_DWORD *)v109 + v45 + v47);
            ++v46;
          }
          while (v44 != v46);
        }
        v9 += 4096;
        v12 += 4096;
      }
      while (v12 <= v11);
    }
    unint64_t v48 = 0;
    int v120 = 0;
    uint64_t v119 = 0;
    long long v111 = 0uLL;
    *(void *)&long long v112 = 0;
    do
    {
      int v49 = *((_DWORD *)v109 + v48);
      *((_DWORD *)&v119 + v48 % 3u) += v49;
      unint64_t v50 = v48 - 6;
      if (v48 < 6) {
        unint64_t v50 = v48;
      }
      *((_DWORD *)&v111 + v50) += v49;
      ++v48;
    }
    while (v48 != 9);
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    double v53 = 0.0;
    char v54 = 1;
    while (1)
    {
      uint64_t v55 = *((unsigned int *)&v119 + v51);
      double v56 = v55 > 0xFF ? log2((double)v55) : kBrotliLog2Table[v55];
      unint64_t v57 = v52 + v55;
      double v58 = v53 - (double)v55 * v56;
      if ((v54 & 1) == 0) {
        break;
      }
      uint64_t v59 = *((unsigned int *)&v119 + (v51 | 1));
      if (v59 > 0xFF) {
        double v60 = log2((double)v59);
      }
      else {
        double v60 = kBrotliLog2Table[v59];
      }
      char v54 = 0;
      uint64_t v52 = v57 + v59;
      double v53 = v58 - (double)v59 * v60;
      uint64_t v51 = 2;
    }
    if (v57)
    {
      if (v57 > 0xFF) {
        double v61 = log2((double)v57);
      }
      else {
        double v61 = kBrotliLog2Table[v57];
      }
      double v58 = v58 + (double)v57 * v61;
    }
    uint64_t v62 = 0;
    uint64_t v63 = 0;
    double v64 = 0.0;
    char v65 = 1;
    while (1)
    {
      uint64_t v66 = *((unsigned int *)&v111 + v62);
      double v67 = v66 > 0xFF ? log2((double)v66) : kBrotliLog2Table[v66];
      unint64_t v68 = v63 + v66;
      double v69 = v64 - (double)v66 * v67;
      if ((v65 & 1) == 0) {
        break;
      }
      uint64_t v70 = *((unsigned int *)&v111 + (v62 | 1));
      if (v70 > 0xFF) {
        double v71 = log2((double)v70);
      }
      else {
        double v71 = kBrotliLog2Table[v70];
      }
      char v65 = 0;
      uint64_t v63 = v68 + v70;
      double v64 = v69 - (double)v70 * v71;
      uint64_t v62 = 2;
    }
    if (v68)
    {
      if (v68 > 0xFF) {
        double v72 = log2((double)v68);
      }
      else {
        double v72 = kBrotliLog2Table[v68];
      }
      double v69 = v69 + (double)v68 * v72;
    }
    uint64_t v73 = 0;
    uint64_t v74 = 0;
    double v75 = 0.0;
    while (1)
    {
      unint64_t v76 = (char *)&v111 + 4 * v73;
      uint64_t v77 = *((unsigned int *)v76 + 3);
      double v78 = v77 > 0xFF ? log2((double)v77) : kBrotliLog2Table[v77];
      unint64_t v79 = v74 + v77;
      double v80 = v75 - (double)v77 * v78;
      if ((unint64_t)(v73 + 3) >= 5) {
        break;
      }
      uint64_t v81 = *((unsigned int *)v76 + 4);
      if (v81 > 0xFF) {
        double v82 = log2((double)v81);
      }
      else {
        double v82 = kBrotliLog2Table[v81];
      }
      uint64_t v74 = v79 + v81;
      double v75 = v80 - (double)v81 * v82;
      v73 += 2;
    }
    if (v79)
    {
      if (v79 > 0xFF) {
        double v83 = log2((double)v79);
      }
      else {
        double v83 = kBrotliLog2Table[v79];
      }
      double v80 = v80 + (double)v79 * v83;
    }
    uint64_t v84 = 0;
    double v85 = 0.0;
    do
    {
      uint64_t v86 = 0;
      uint64_t v87 = 0;
      __int16 v88 = (char *)v109 + 12 * v84;
      char v89 = 1;
      double v90 = 0.0;
      while (1)
      {
        uint64_t v91 = *(unsigned int *)&v88[4 * v86];
        double v92 = v91 > 0xFF ? log2((double)v91) : kBrotliLog2Table[v91];
        unint64_t v93 = v87 + v91;
        double v94 = v90 - (double)v91 * v92;
        if ((v89 & 1) == 0) {
          break;
        }
        uint64_t v95 = *(unsigned int *)&v88[4 * (v86 | 1)];
        if (v95 > 0xFF) {
          double v96 = log2((double)v95);
        }
        else {
          double v96 = kBrotliLog2Table[v95];
        }
        char v89 = 0;
        uint64_t v87 = v93 + v95;
        double v90 = v94 - (double)v95 * v96;
        uint64_t v86 = 2;
      }
      if (v93)
      {
        if (v93 > 0xFF) {
          double v97 = log2((double)v93);
        }
        else {
          double v97 = kBrotliLog2Table[v93];
        }
        double v94 = v94 + (double)v93 * v97;
      }
      double v85 = v85 + v94;
      ++v84;
    }
    while (v84 != 3);
    double v98 = 1.0 / (double)(HIDWORD(v119) + v119 + v120);
    double v99 = v58 * v98;
    double v100 = (v69 + v80) * v98;
    double v101 = v85 * v98;
    if (a5 < 7) {
      double v101 = v99 * 10.0;
    }
    if (v99 - v100 < 0.2 && v99 - v101 < 0.2)
    {
      uint64_t v102 = 1;
      uint64_t v103 = a7;
LABEL_122:
      *uint64_t v103 = v102;
      return;
    }
    if (v100 - v101 >= 0.02)
    {
      *a7 = 3;
      uint64_t v102 = (uint64_t)&ChooseContextMap_kStaticContextMapContinuation;
    }
    else
    {
      *a7 = 2;
      uint64_t v102 = (uint64_t)&ChooseContextMap_kStaticContextMapSimpleUTF8;
    }
LABEL_121:
    uint64_t v103 = a8;
    goto LABEL_122;
  }
}

uint64_t lzx_huffman_tree_compute_lookup_from_code_len(unsigned __int8 *a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)a1 + 16446);
  bzero(v27, 0x3E0uLL);
  int v26 = 0;
  memset(v25, 0, sizeof(v25));
  if ((int)v2 < 1) {
    goto LABEL_21;
  }
  int v3 = 0;
  uint64_t v4 = v2;
  uint64_t v5 = a1;
  do
  {
    unsigned int v7 = *v5++;
    unsigned int v6 = v7;
    ++*((_DWORD *)v25 + v7);
    if (v3 <= (int)v7) {
      int v3 = v6;
    }
    --v4;
  }
  while (v4);
  if (!v3)
  {
LABEL_21:
    memset_pattern16(a1 + 496, &unk_20DAB5F80, 0x20000uLL);
    return 0;
  }
  int v8 = 0;
  int v24 = 0;
  memset(v23, 0, sizeof(v23));
  for (uint64_t i = 4; i != 68; i += 4)
  {
    *(_DWORD *)((char *)v23 + i) = 2 * v8;
    int v8 = *(_DWORD *)((char *)v25 + i) + 2 * v8;
  }
  if (v8 == 0x10000)
  {
    unint64_t v10 = v27;
    uint64_t v11 = v2;
    unint64_t v12 = a1;
    do
    {
      unsigned int v14 = *v12++;
      unsigned int v13 = v14;
      if (v14)
      {
        unsigned int v15 = *((_DWORD *)v23 + v13);
        *((_DWORD *)v23 + v13) = v15 + 1;
        if (v15 >> v13) {
          return 0xFFFFFFFFLL;
        }
        *unint64_t v10 = v15 << (16 - v13);
      }
      ++v10;
      --v11;
    }
    while (v11);
    bzero(a1 + 496, 0x20000uLL);
    uint64_t v16 = 0;
    do
    {
      __int16 v17 = a1[v16];
      if (a1[v16])
      {
        __int16 v18 = v17 | (32 * v16);
        char v19 = 16 - v17;
        unint64_t v20 = (unsigned __int16)v27[v16];
        unint64_t v21 = ((1 << v19) + v20);
        do
          *(_WORD *)&a1[2 * v20++ + 496] = v18;
        while (v20 < v21);
      }
      ++v16;
    }
    while (v16 != v2);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t lzx_huffman_tree_read_code(_WORD *a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a2 + 24);
  if (v3 <= 48)
  {
    unint64_t v4 = *(void *)(a2 + 8);
    unint64_t v5 = *(void *)a2 + 2;
    int v6 = 48 - v3;
    while (v5 <= v4)
    {
      uint64_t v7 = *(unsigned __int16 *)(v5 - 2);
      *(void *)a2 = v5;
      int v8 = v3 + 16;
      uint64_t v9 = (v7 << v6) | *(void *)(a2 + 16);
      *(_DWORD *)(a2 + 24) = v3 + 16;
      *(void *)(a2 + 16) = v9;
      v5 += 2;
      v6 -= 16;
      BOOL v10 = v3 < 33;
      v3 += 16;
      if (!v10) {
        goto LABEL_7;
      }
    }
  }
  int v8 = v3;
LABEL_7:
  unint64_t v11 = *(void *)(a2 + 16);
  unint64_t v12 = *(unsigned __int16 *)(a3 + 2 * HIWORD(v11) + 496);
  *a1 = *(_WORD *)(a3 + 2 * HIWORD(v11) + 496) >> 5;
  if (*(void *)(a3 + 131568) <= v12 >> 5) {
    return 0xFFFFFFFFLL;
  }
  int v13 = v12 & 0x1F;
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  if (v8 <= 48)
  {
    unint64_t v14 = *(void *)(a2 + 8);
    unint64_t v15 = *(void *)a2 + 2;
    int v16 = 48 - v8;
    while (v15 <= v14)
    {
      uint64_t v17 = *(unsigned __int16 *)(v15 - 2);
      *(void *)a2 = v15;
      int v18 = v8 + 16;
      v11 |= v17 << v16;
      *(_DWORD *)(a2 + 24) = v8 + 16;
      *(void *)(a2 + 16) = v11;
      v15 += 2;
      v16 -= 16;
      BOOL v10 = v8 < 33;
      v8 += 16;
      if (!v10) {
        goto LABEL_15;
      }
    }
  }
  int v18 = v8;
LABEL_15:
  if (v18 < v13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(void *)(a2 + 16) = v11 << v13;
  *(_DWORD *)(a2 + 24) = v18 - v13;
  return result;
}

uint64_t lzx_huffman_tree_update_tree_using_pre_tree_encoding(uint64_t a1, uint64_t a2, size_t a3, uint64_t a4, void *a5)
{
  if (lzx_huffman_create_pre_tree(a5, a2)) {
    return 0xFFFFFFFFLL;
  }
  size_t v11 = a4 + a3;
  while (a3 < v11)
  {
    unsigned __int16 v43 = 0;
    if (lzx_huffman_tree_read_code(&v43, a2, (uint64_t)a5)) {
      return 0xFFFFFFFFLL;
    }
    if (v43 > 0x10u)
    {
      switch(v43)
      {
        case 0x13u:
          int v21 = *(_DWORD *)(a2 + 24);
          if (v21 > 48)
          {
            int v26 = *(_DWORD *)(a2 + 24);
          }
          else
          {
            unint64_t v22 = *(void *)(a2 + 8);
            unint64_t v23 = *(void *)a2 + 2;
            int v24 = 48 - v21;
            while (v23 <= v22)
            {
              uint64_t v25 = *(unsigned __int16 *)(v23 - 2);
              *(void *)a2 = v23;
              int v26 = v21 + 16;
              uint64_t v27 = (v25 << v24) | *(void *)(a2 + 16);
              *(_DWORD *)(a2 + 24) = v21 + 16;
              *(void *)(a2 + 16) = v27;
              v23 += 2;
              v24 -= 16;
              BOOL v20 = v21 < 33;
              v21 += 16;
              if (!v20) {
                goto LABEL_33;
              }
            }
            int v26 = v21;
            if (v21 < 1) {
              return 0xFFFFFFFFLL;
            }
          }
LABEL_33:
          unint64_t v37 = *(void *)(a2 + 16);
          *(void *)(a2 + 16) = 2 * v37;
          *(_DWORD *)(a2 + 24) = v26 - 1;
          size_t v38 = (v37 >> 63) | 4;
          if (v38 + a3 > v11) {
            return 0xFFFFFFFFLL;
          }
          unsigned __int16 v42 = 0;
          if (lzx_huffman_tree_read_code(&v42, a2, (uint64_t)a5) || v42 >= 0x11u) {
            return 0xFFFFFFFFLL;
          }
          unsigned int v39 = *(unsigned __int8 *)(a1 + a3);
          if (v39 < v42) {
            v39 += 17;
          }
          memset((void *)(a1 + a3), v39 - v42, v38);
          a3 += v38;
          break;
        case 0x12u:
          int v28 = *(_DWORD *)(a2 + 24);
          if (v28 > 48)
          {
            int v33 = *(_DWORD *)(a2 + 24);
          }
          else
          {
            unint64_t v29 = *(void *)(a2 + 8);
            unint64_t v30 = *(void *)a2 + 2;
            int v31 = 48 - v28;
            while (v30 <= v29)
            {
              uint64_t v32 = *(unsigned __int16 *)(v30 - 2);
              *(void *)a2 = v30;
              int v33 = v28 + 16;
              uint64_t v34 = (v32 << v31) | *(void *)(a2 + 16);
              *(_DWORD *)(a2 + 24) = v28 + 16;
              *(void *)(a2 + 16) = v34;
              v30 += 2;
              v31 -= 16;
              BOOL v20 = v28 < 33;
              v28 += 16;
              if (!v20) {
                goto LABEL_40;
              }
            }
            int v33 = v28;
            if (v28 < 5) {
              return 0xFFFFFFFFLL;
            }
          }
LABEL_40:
          unint64_t v40 = *(void *)(a2 + 16);
          *(void *)(a2 + 16) = 32 * v40;
          *(_DWORD *)(a2 + 24) = v33 - 5;
          size_t v36 = (v40 >> 59) + 20;
          goto LABEL_41;
        case 0x11u:
          int v13 = *(_DWORD *)(a2 + 24);
          if (v13 > 48)
          {
            int v18 = *(_DWORD *)(a2 + 24);
          }
          else
          {
            unint64_t v14 = *(void *)(a2 + 8);
            unint64_t v15 = *(void *)a2 + 2;
            int v16 = 48 - v13;
            while (v15 <= v14)
            {
              uint64_t v17 = *(unsigned __int16 *)(v15 - 2);
              *(void *)a2 = v15;
              int v18 = v13 + 16;
              uint64_t v19 = (v17 << v16) | *(void *)(a2 + 16);
              *(_DWORD *)(a2 + 24) = v13 + 16;
              *(void *)(a2 + 16) = v19;
              v15 += 2;
              v16 -= 16;
              BOOL v20 = v13 < 33;
              v13 += 16;
              if (!v20) {
                goto LABEL_31;
              }
            }
            int v18 = v13;
            if (v13 < 4) {
              return 0xFFFFFFFFLL;
            }
          }
LABEL_31:
          unint64_t v35 = *(void *)(a2 + 16);
          *(void *)(a2 + 16) = 16 * v35;
          *(_DWORD *)(a2 + 24) = v18 - 4;
          size_t v36 = (v35 >> 60) + 4;
LABEL_41:
          size_t v41 = v36 + a3;
          if (v36 + a3 > v11) {
            return 0xFFFFFFFFLL;
          }
          bzero((void *)(a1 + a3), v36);
          a3 = v41;
          break;
      }
    }
    else
    {
      unsigned int v12 = *(unsigned __int8 *)(a1 + a3);
      if (v12 < v43) {
        LOBYTE(v12) = v12 + 17;
      }
      *(unsigned char *)(a1 + a3++) = v12 - v43;
    }
  }
  if (a3 == v11) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t lzx_huffman_create_pre_tree(void *a1, uint64_t a2)
{
  bzero(a1, 0x201F0uLL);
  unint64_t v4 = 0;
  a1[16446] = 20;
  while (1)
  {
    int v5 = *(_DWORD *)(a2 + 24);
    if (v5 <= 48) {
      break;
    }
    int v10 = *(_DWORD *)(a2 + 24);
LABEL_9:
    unint64_t v13 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = 16 * v13;
    *(_DWORD *)(a2 + 24) = v10 - 4;
    *((unsigned char *)a1 + v4++) = v13 >> 60;
    if (v4 >= a1[16446])
    {
      lzx_huffman_tree_compute_lookup_from_code_len((unsigned __int8 *)a1);
      return 0;
    }
  }
  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(void *)a2 + 2;
  int v8 = 48 - v5;
  while (v7 <= v6)
  {
    uint64_t v9 = *(unsigned __int16 *)(v7 - 2);
    *(void *)a2 = v7;
    int v10 = v5 + 16;
    uint64_t v11 = (v9 << v8) | *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v5 + 16;
    *(void *)(a2 + 16) = v11;
    v7 += 2;
    v8 -= 16;
    BOOL v12 = v5 < 33;
    v5 += 16;
    if (!v12) {
      goto LABEL_9;
    }
  }
  int v10 = v5;
  if (v5 >= 4) {
    goto LABEL_9;
  }
  return 0xFFFFFFFFLL;
}

unint64_t BrotliCompressFragmentFast(unint64_t result, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned int a6, unsigned __int8 *a7, uint64_t a8, unint64_t *a9, unsigned char *a10, unint64_t *a11, uint64_t a12)
{
  unint64_t v12 = *a11;
  if (!a3) {
    goto LABEL_11;
  }
  switch(__clz(a6) ^ 0x1F)
  {
    case 9u:
      uint64_t result = BrotliCompressFragmentFastImpl9(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    case 0xBu:
      uint64_t result = BrotliCompressFragmentFastImpl11(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    case 0xDu:
      uint64_t result = BrotliCompressFragmentFastImpl13(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    case 0xFu:
      uint64_t result = BrotliCompressFragmentFastImpl15(result, a2, a3, a4, a5, a7, a8, a9, a10, a11, a12);
      break;
    default:
      break;
  }
  if (*a11 - v12 > 8 * a3 + 31) {
    uint64_t result = (unint64_t)EmitUncompressedMetaBlock(a2, (uint64_t)&a2[a3], v12, a11, a12);
  }
  if (a4)
  {
    unint64_t v12 = *a11;
LABEL_11:
    *(void *)(a12 + (v12 >> 3)) = (1 << (v12 & 7)) | *(unsigned __int8 *)(a12 + (v12 >> 3));
    *a11 = v12 + 1;
    *(void *)(a12 + ((v12 + 1) >> 3)) = (1 << ((v12 + 1) & 7)) | *(unsigned __int8 *)(a12 + ((v12 + 1) >> 3));
    *a11 = (v12 + 9) & 0xFFFFFFF8;
  }
  return result;
}

unint64_t BrotliCompressFragmentFastImpl9(unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, unsigned char *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v206 = *MEMORY[0x263EF8340];
  unint64_t v199 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v195 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t v201 = v14;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v204, (uint64_t)v203, a10, a11);
  unint64_t v193 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v192 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8;
    }
    while (v21 < *a8);
    v18 += v20;
  }
  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
LABEL_11:
  unint64_t v200 = v201;
  unint64_t v23 = v22;
  unint64_t v194 = v22;
  while (1)
  {
    unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
    unint64_t v24 = v200;
    unint64_t v25 = (unint64_t)&v22[v200];
    unsigned int v202 = &v22[v200];
    if (v200 >= 0x10) {
      break;
    }
    unint64_t v27 = v199;
LABEL_100:
    unint64_t v155 = v27 - v24;
    if (v155 >= 0x10000) {
      unint64_t v156 = 0x10000;
    }
    else {
      unint64_t v156 = v155;
    }
    unint64_t v199 = v155;
    if (!v155
      || (v201 += v156, v201 > 0x100000)
      || (unint64_t result = ShouldMergeBlock(v25, v156, (uint64_t)v204), v25 = (unint64_t)v202, !result))
    {
      if ((unint64_t)v23 >= v25)
      {
        unint64_t v22 = (unsigned __int8 *)v25;
LABEL_113:
        unint64_t v162 = v199;
        if (!v199) {
          goto LABEL_141;
        }
      }
      else
      {
        unint64_t v157 = v25 - (void)v23;
        if ((v25 - (unint64_t)v23) >> 1 <= 0xC20)
        {
          if (v157 > 5)
          {
            unint64_t v162 = v199;
            if (v157 > 0x81)
            {
              if (v157 > 0x841)
              {
                uint64_t v173 = a6[61];
                unint64_t v174 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v175 = v174 + v173;
                *a10 = v175;
                *(void *)(a11 + (v175 >> 3)) = ((v157 - 2114) << (v175 & 7)) | *(unsigned __int8 *)(a11 + (v175 >> 3));
                unint64_t v160 = v175 + 12;
                *a10 = v160;
                unsigned int v161 = &__dst[61];
              }
              else
              {
                uint64_t v169 = __clz(v157 - 66) ^ 0x1F;
                uint64_t v170 = a6[v169 + 50];
                unint64_t v171 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v169 + 50)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v172 = v171 + v170;
                *a10 = v172;
                *(void *)(a11 + (v172 >> 3)) = (((-1 << v169) + v157 - 66) << (v172 & 7)) | *(unsigned __int8 *)(a11 + (v172 >> 3));
                unint64_t v160 = v172 + v169;
                *a10 = v172 + v169;
                unsigned int v161 = &__dst[v169 + 50];
              }
            }
            else
            {
              uint64_t v163 = (__clz(v157 - 2) ^ 0x1F) - 1;
              unint64_t v164 = (v157 - 2) >> v163;
              uint64_t v165 = (2 * v163) + v164 + 42;
              uint64_t v166 = a6[v165];
              unint64_t v167 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v165) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v168 = v167 + v166;
              *a10 = v168;
              *(void *)(a11 + (v168 >> 3)) = ((v157 - 2 - (v164 << v163)) << (v168 & 7)) | *(unsigned __int8 *)(a11 + (v168 >> 3));
              unint64_t v160 = v168 + v163;
              *a10 = v168 + v163;
              unsigned int v161 = &__dst[v165];
            }
          }
          else
          {
            uint64_t v158 = a6[v157 + 40];
            unint64_t v159 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v157 + 40)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v160 = v159 + v158;
            *a10 = v160;
            unsigned int v161 = &__dst[v157 + 40];
            unint64_t v162 = v199;
          }
          ++*v161;
          if ((unsigned __int8 *)v25 != v23)
          {
            if (v157 <= 1) {
              unint64_t v157 = 1;
            }
            do
            {
              int v176 = *v23++;
              uint64_t v177 = v204[v176];
              *(void *)(a11 + (v160 >> 3)) = ((unint64_t)(unsigned __int16)v203[v176] << (v160 & 7)) | *(unsigned __int8 *)(a11 + (v160 >> 3));
              v160 += v177;
              *a10 = v160;
              --v157;
            }
            while (v157);
          }
          goto LABEL_124;
        }
        unint64_t result = (unint64_t)v194;
        if (50 * (v23 - v194) <= v157 && v192 >= 0x3D5)
        {
          unint64_t v22 = (unsigned __int8 *)v25;
          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, v25, v195, a10, a11);
          goto LABEL_113;
        }
        if (v157 > 0x5841)
        {
          uint64_t v185 = a6[63];
          unint64_t v186 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v187 = v186 + v185;
          *a10 = v187;
          *(void *)(a11 + (v187 >> 3)) = ((v157 - 22594) << (v187 & 7)) | *(unsigned __int8 *)(a11 + (v187 >> 3));
          unint64_t v183 = v187 + 24;
          uint64_t v184 = &__dst[63];
        }
        else
        {
          uint64_t v180 = a6[62];
          unint64_t v181 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v182 = v181 + v180;
          *a10 = v182;
          *(void *)(a11 + (v182 >> 3)) = ((v157 - 6210) << (v182 & 7)) | *(unsigned __int8 *)(a11 + (v182 >> 3));
          unint64_t v183 = v182 + 14;
          uint64_t v184 = &__dst[62];
        }
        unint64_t v162 = v199;
        ++*v184;
        *a10 = v183;
        do
        {
          int v188 = *v23++;
          uint64_t v189 = v204[v188];
          *(void *)(a11 + (v183 >> 3)) = ((unint64_t)(unsigned __int16)v203[v188] << (v183 & 7)) | *(unsigned __int8 *)(a11 + (v183 >> 3));
          v183 += v189;
          *a10 = v183;
          --v157;
        }
        while (v157);
LABEL_124:
        unint64_t v22 = (unsigned __int8 *)v25;
        if (!v162) {
          goto LABEL_141;
        }
      }
LABEL_125:
      unint64_t v199 = v162;
      if (v162 >= 0x18000) {
        unint64_t v178 = 98304;
      }
      else {
        unint64_t v178 = v162;
      }
      unint64_t v201 = v178;
      unint64_t v195 = *a10;
      BrotliStoreMetaBlockHeader(v178, 0, a10, a11);
      unint64_t v179 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
      *a10 = v179 + 13;
      unint64_t result = BuildAndStoreLiteralPrefixCode(v193, v22, v201, v204, (uint64_t)v203, a10, a11);
      if (*(_DWORD *)(v193 + 24)) {
        return result;
      }
      unint64_t v192 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      goto LABEL_11;
    }
    unint64_t v200 = v156;
    unint64_t v22 = v202;
    UpdateBits((v201 - 1), v195 + 3, a11);
  }
  unint64_t v26 = v200 - 5;
  unint64_t v27 = v199;
  if (v200 - 5 >= v199 - 16) {
    unint64_t v26 = v199 - 16;
  }
  int v28 = &v22[v26];
  int v29 = -1;
  unint64_t v196 = v22;
LABEL_16:
  while (2)
  {
    uint64_t v31 = *(void *)++v22;
    uint64_t v30 = v31;
    for (unsigned int i = 32; ; ++i)
    {
      int v33 = &v22[i >> 5];
      if (v33 > v28) {
        goto LABEL_99;
      }
      unint64_t v34 = (unint64_t)(0x1E35A7BD000000 * v30) >> 55;
      uint64_t v30 = *(void *)v33;
      unint64_t v35 = &v22[-v29];
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
        break;
      }
      unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
      *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
        goto LABEL_24;
      }
LABEL_28:
      unint64_t v22 = v33;
    }
    *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
LABEL_24:
    int v37 = v22 - v35;
    if (v22 - v35 > 262128) {
      goto LABEL_28;
    }
    size_t v38 = v35 + 5;
    unsigned int v39 = v22 + 5;
    unint64_t v40 = v25 - (void)v22 - 5;
    if (v40 < 8)
    {
      unint64_t v43 = 0;
LABEL_88:
      unint64_t v147 = v40 & 7;
      if (v147)
      {
        unint64_t v148 = v43 | v147;
        while (v38[v43] == *v39)
        {
          ++v39;
          ++v43;
          if (!--v147)
          {
            unint64_t v43 = v148;
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v41 = 0;
      unint64_t v42 = v40 >> 3;
      unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8;
      while (1)
      {
        uint64_t v44 = *(void *)&v39[v41];
        uint64_t v45 = *(void *)&v38[v41];
        if (v44 != v45) {
          break;
        }
        v41 += 8;
        if (!--v42)
        {
          v39 += v40 & 0xFFFFFFFFFFFFFFF8;
          goto LABEL_88;
        }
      }
      unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
    }
    unint64_t v46 = v22 - v23;
    if ((unint64_t)(v22 - v23) >> 1 <= 0xC20)
    {
      if (v46 > 5)
      {
        if (v46 > 0x81)
        {
          if (v46 > 0x841)
          {
            uint64_t v62 = a6[61];
            unint64_t v63 = *a10;
            unint64_t result = *a10 & 7;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v64 = v63 + v62;
            *a10 = v64;
            *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
            unint64_t v50 = v64 + 12;
            *a10 = v50;
            uint64_t v51 = &__dst[61];
          }
          else
          {
            uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
            uint64_t v59 = a6[v58 + 50];
            unint64_t v60 = *a10;
            unint64_t v25 = (unint64_t)v202;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v61 = v60 + v59;
            *a10 = v61;
            unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
            *(void *)(a11 + (v61 >> 3)) = (((-1 << v58) + v46 - 66) << (v61 & 7)) | result;
            unint64_t v50 = v61 + v58;
            *a10 = v61 + v58;
            uint64_t v51 = &__dst[v58 + 50];
          }
        }
        else
        {
          uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
          unint64_t v53 = (v46 - 2) >> v52;
          uint64_t v54 = (2 * v52) + v53 + 42;
          uint64_t v55 = a6[v54];
          unint64_t v56 = *a10;
          unint64_t v25 = (unint64_t)v202;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v57 = v56 + v55;
          *a10 = v57;
          unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
          *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
          unint64_t v50 = v57 + v52;
          *a10 = v57 + v52;
          uint64_t v51 = &__dst[v54];
        }
      }
      else
      {
        uint64_t v47 = a6[v46 + 40];
        unint64_t v48 = *a10;
        unint64_t v49 = *a10 >> 3;
        unint64_t result = *(unsigned __int8 *)(a11 + v49);
        *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(unsigned char *)a10 & 7)) | result;
        unint64_t v50 = v48 + v47;
        *a10 = v50;
        uint64_t v51 = &__dst[v46 + 40];
      }
LABEL_43:
      ++*v51;
      if (v22 != v23)
      {
        if (v46 <= 1) {
          unint64_t v46 = 1;
        }
        do
        {
          int v65 = *v23++;
          uint64_t v66 = v204[v65];
          unint64_t result = v50 & 7;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v203[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          v50 += v66;
          *a10 = v50;
          --v46;
        }
        while (v46);
      }
      unint64_t v67 = v50 >> 3;
      if (v29 == v37)
      {
        uint64_t v68 = a6[64];
        *(void *)(a11 + v67) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        unint64_t v69 = v50 + v68;
        uint64_t v70 = &__dst[64];
      }
      else
      {
        unint64_t v71 = v37 + 3;
        unsigned int v72 = __clz(v71) ^ 0x1F;
        uint64_t v73 = v72 - 1;
        uint64_t v74 = (v71 >> (v72 - 1)) & 1 | 2;
        uint64_t v75 = ((2 * v72 - 4) & 0xFFFFFFFE | (v71 >> (v72 - 1)) & 1) + 80;
        uint64_t v76 = a6[v75];
        unint64_t result = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v75) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        *(void *)(a11 + v67) = result;
        *a10 = v50 + v76;
        *(void *)(a11 + ((v50 + v76) >> 3)) = ((v71 - (v74 << v73)) << ((v50 + v76) & 7)) | *(unsigned __int8 *)(a11 + ((v50 + v76) >> 3));
        unint64_t v69 = v50 + v76 + v73;
        uint64_t v70 = &__dst[v75];
        int v29 = v37;
      }
      unint64_t v77 = v43 + 5;
      ++*v70;
      *a10 = v69;
      if (v43 + 5 > 0xB)
      {
        if (v77 > 0x47)
        {
          if (v77 > 0x87)
          {
            if (v77 > 0x847)
            {
              uint64_t v98 = a6[39];
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
              unint64_t v99 = v69 + v98;
              *a10 = v99;
              char v100 = v99 & 7;
              *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
              unint64_t v101 = v99 + 24;
              *a10 = v99 + 24;
              uint64_t v102 = a6[64];
              *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
              *a10 = v101 + v102;
              ++__dst[39];
            }
            else
            {
              unint64_t v92 = v43 - 67;
              uint64_t v93 = __clz(v92) ^ 0x1F;
              uint64_t v94 = a6[v93 + 28];
              unint64_t result = *(unsigned __int8 *)(a11 + (v69 >> 3));
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v69 & 7)) | result;
              unint64_t v95 = v69 + v94;
              *a10 = v95;
              *(void *)(a11 + (v95 >> 3)) = (((-1 << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
              unint64_t v96 = v95 + v93;
              *a10 = v95 + v93;
              uint64_t v97 = a6[64];
              *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
              *a10 = v96 + v97;
              ++__dst[v93 + 28];
            }
          }
          else
          {
            unint64_t v86 = v43 - 3;
            uint64_t v87 = (v86 >> 5) + 30;
            uint64_t v88 = a6[v87];
            unint64_t result = v69 & 7;
            *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
            unint64_t v89 = v69 + v88;
            *a10 = v89;
            *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
            unint64_t v90 = v89 + 5;
            *a10 = v89 + 5;
            uint64_t v91 = a6[64];
            *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
            *a10 = v90 + v91;
            ++__dst[v87];
          }
          double v80 = &__dst[64];
        }
        else
        {
          unint64_t v81 = v43 - 3;
          uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
          uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
          uint64_t v84 = a6[v83];
          unint64_t result = v69 >> 3;
          *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
          unint64_t v85 = v69 + v84;
          *a10 = v85;
          *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
          *a10 = v85 + v82;
          double v80 = &__dst[v83];
        }
      }
      else
      {
        unint64_t v78 = v43 + 1;
        uint64_t v79 = a6[v78];
        *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
        *a10 = v69 + v79;
        double v80 = &__dst[v78];
      }
      v22 += v77;
      ++*v80;
      if (v22 >= v28)
      {
LABEL_98:
        unint64_t v23 = v22;
LABEL_99:
        unint64_t v24 = v200;
        goto LABEL_100;
      }
      unint64_t v103 = *(void *)(v22 - 3);
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v103) >> 53) & 0x7FC)) = v22 - a2 - 3;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 8)) >> 53) & 0x7FC)) = v22 - a2 - 2;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 16)) >> 53) & 0x7FC)) = v22 - a2 - 1;
      unint64_t v104 = ((0x1E35A7BD000000 * (v103 >> 24)) >> 53) & 0x7FC;
      uint64_t v105 = *(int *)(a5 + v104);
      *(_DWORD *)(a5 + v104) = v22 - a2;
      char v106 = &a2[v105];
      unint64_t v23 = v22;
      if (*(_DWORD *)v22 == *(_DWORD *)&a2[v105])
      {
        while (1)
        {
          unint64_t v23 = v22;
          if (v22[4] != v106[4]) {
            break;
          }
          uint64_t v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v25 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0;
LABEL_81:
            unint64_t v145 = v109 & 7;
            if (v145)
            {
              unint64_t v146 = v112 | v145;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v145)
                {
                  unint64_t v112 = v146;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v110 = 0;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_81;
              }
            }
            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }
          uint64_t v114 = v22 - v106;
          if (v114 <= 262128)
          {
            unint64_t v115 = v112 + 5;
            if (v112 + 5 > 9)
            {
              if (v115 > 0x85)
              {
                if (v115 > 0x845)
                {
                  uint64_t v132 = a6[39];
                  unint64_t v133 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v134 = v133 + v132;
                  *a10 = v134;
                  *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                  unint64_t v119 = v134 + 24;
                  *a10 = v134 + 24;
                  int v120 = &__dst[39];
                }
                else
                {
                  unint64_t v127 = v112 - 65;
                  uint64_t v128 = __clz(v127) ^ 0x1F;
                  uint64_t v129 = a6[v128 + 28];
                  unint64_t v130 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v131 = v130 + v129;
                  *a10 = v131;
                  *(void *)(a11 + (v131 >> 3)) = (((-1 << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                  unint64_t v119 = v131 + v128;
                  *a10 = v131 + v128;
                  int v120 = &__dst[v128 + 28];
                }
              }
              else
              {
                unint64_t v121 = v112 - 1;
                uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
                uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
                uint64_t v124 = a6[v123];
                unint64_t v125 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v126 = v125 + v124;
                *a10 = v126;
                *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
                unint64_t v119 = v126 + v122;
                *a10 = v126 + v122;
                int v120 = &__dst[v123];
              }
            }
            else
            {
              unint64_t v116 = v112 + 19;
              uint64_t v117 = a6[v112 + 19];
              unint64_t v118 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v119 = v118 + v117;
              *a10 = v119;
              int v120 = &__dst[v116];
            }
            v22 += v115;
            ++*v120;
            unint64_t v135 = (int)v114 + 3;
            unsigned int v136 = __clz(v135) ^ 0x1F;
            uint64_t v137 = v136 - 1;
            uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
            uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
            uint64_t v140 = a6[v139];
            unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
            *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
            unint64_t v141 = v119 + v140;
            *a10 = v141;
            *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
            *a10 = v141 + v137;
            ++__dst[v139];
            if (v22 >= v28) {
              goto LABEL_98;
            }
            int v29 = v114;
            unint64_t v142 = *(void *)(v22 - 3);
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v142) >> 53) & 0x7FC)) = v22 - a2 - 3;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 8)) >> 53) & 0x7FC)) = v22 - a2 - 2;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 16)) >> 53) & 0x7FC)) = v22 - a2 - 1;
            unint64_t v143 = ((0x1E35A7BD000000 * (v142 >> 24)) >> 53) & 0x7FC;
            uint64_t v144 = *(int *)(a5 + v143);
            *(_DWORD *)(a5 + v143) = v22 - a2;
            char v106 = &a2[v144];
            if (*(_DWORD *)v22 == *(_DWORD *)&a2[v144]) {
              continue;
            }
          }
          unint64_t v23 = v22;
          goto LABEL_16;
        }
      }
      continue;
    }
    break;
  }
  if (50 * (v23 - v194) > v46 || v192 < 0x3D5)
  {
    if (v46 > 0x5841)
    {
      uint64_t v152 = a6[63];
      unint64_t v153 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v154 = v153 + v152;
      *a10 = v154;
      *(void *)(a11 + (v154 >> 3)) = ((v46 - 22594) << (v154 & 7)) | *(unsigned __int8 *)(a11 + (v154 >> 3));
      unint64_t v50 = v154 + 24;
      *a10 = v50;
      uint64_t v51 = &__dst[63];
    }
    else
    {
      uint64_t v149 = a6[62];
      unint64_t v150 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v151 = v150 + v149;
      *a10 = v151;
      *(void *)(a11 + (v151 >> 3)) = ((v46 - 6210) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
      unint64_t v50 = v151 + 14;
      *a10 = v50;
      uint64_t v51 = &__dst[62];
    }
    goto LABEL_43;
  }
  unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, (uint64_t)v22, v195, a10, a11);
  unint64_t v162 = &v196[v199] - v22;
  if (v162) {
    goto LABEL_125;
  }
LABEL_141:
  if (!a4)
  {
    *a9 = 0;
    *a8 = 0;
    return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
  }
  return result;
}

unint64_t BrotliCompressFragmentFastImpl11(unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, unsigned char *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v206 = *MEMORY[0x263EF8340];
  unint64_t v199 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v195 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t v201 = v14;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v204, (uint64_t)v203, a10, a11);
  unint64_t v193 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v192 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8;
    }
    while (v21 < *a8);
    v18 += v20;
  }
  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
LABEL_11:
  unint64_t v200 = v201;
  unint64_t v23 = v22;
  unint64_t v194 = v22;
  while (1)
  {
    unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
    unint64_t v24 = v200;
    unint64_t v25 = (unint64_t)&v22[v200];
    unsigned int v202 = &v22[v200];
    if (v200 >= 0x10) {
      break;
    }
    unint64_t v27 = v199;
LABEL_100:
    unint64_t v155 = v27 - v24;
    if (v155 >= 0x10000) {
      unint64_t v156 = 0x10000;
    }
    else {
      unint64_t v156 = v155;
    }
    unint64_t v199 = v155;
    if (!v155
      || (v201 += v156, v201 > 0x100000)
      || (unint64_t result = ShouldMergeBlock(v25, v156, (uint64_t)v204), v25 = (unint64_t)v202, !result))
    {
      if ((unint64_t)v23 >= v25)
      {
        unint64_t v22 = (unsigned __int8 *)v25;
LABEL_113:
        unint64_t v162 = v199;
        if (!v199) {
          goto LABEL_141;
        }
      }
      else
      {
        unint64_t v157 = v25 - (void)v23;
        if ((v25 - (unint64_t)v23) >> 1 <= 0xC20)
        {
          if (v157 > 5)
          {
            unint64_t v162 = v199;
            if (v157 > 0x81)
            {
              if (v157 > 0x841)
              {
                uint64_t v173 = a6[61];
                unint64_t v174 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v175 = v174 + v173;
                *a10 = v175;
                *(void *)(a11 + (v175 >> 3)) = ((v157 - 2114) << (v175 & 7)) | *(unsigned __int8 *)(a11 + (v175 >> 3));
                unint64_t v160 = v175 + 12;
                *a10 = v160;
                unsigned int v161 = &__dst[61];
              }
              else
              {
                uint64_t v169 = __clz(v157 - 66) ^ 0x1F;
                uint64_t v170 = a6[v169 + 50];
                unint64_t v171 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v169 + 50)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v172 = v171 + v170;
                *a10 = v172;
                *(void *)(a11 + (v172 >> 3)) = (((-1 << v169) + v157 - 66) << (v172 & 7)) | *(unsigned __int8 *)(a11 + (v172 >> 3));
                unint64_t v160 = v172 + v169;
                *a10 = v172 + v169;
                unsigned int v161 = &__dst[v169 + 50];
              }
            }
            else
            {
              uint64_t v163 = (__clz(v157 - 2) ^ 0x1F) - 1;
              unint64_t v164 = (v157 - 2) >> v163;
              uint64_t v165 = (2 * v163) + v164 + 42;
              uint64_t v166 = a6[v165];
              unint64_t v167 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v165) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v168 = v167 + v166;
              *a10 = v168;
              *(void *)(a11 + (v168 >> 3)) = ((v157 - 2 - (v164 << v163)) << (v168 & 7)) | *(unsigned __int8 *)(a11 + (v168 >> 3));
              unint64_t v160 = v168 + v163;
              *a10 = v168 + v163;
              unsigned int v161 = &__dst[v165];
            }
          }
          else
          {
            uint64_t v158 = a6[v157 + 40];
            unint64_t v159 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v157 + 40)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v160 = v159 + v158;
            *a10 = v160;
            unsigned int v161 = &__dst[v157 + 40];
            unint64_t v162 = v199;
          }
          ++*v161;
          if ((unsigned __int8 *)v25 != v23)
          {
            if (v157 <= 1) {
              unint64_t v157 = 1;
            }
            do
            {
              int v176 = *v23++;
              uint64_t v177 = v204[v176];
              *(void *)(a11 + (v160 >> 3)) = ((unint64_t)(unsigned __int16)v203[v176] << (v160 & 7)) | *(unsigned __int8 *)(a11 + (v160 >> 3));
              v160 += v177;
              *a10 = v160;
              --v157;
            }
            while (v157);
          }
          goto LABEL_124;
        }
        unint64_t result = (unint64_t)v194;
        if (50 * (v23 - v194) <= v157 && v192 >= 0x3D5)
        {
          unint64_t v22 = (unsigned __int8 *)v25;
          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, v25, v195, a10, a11);
          goto LABEL_113;
        }
        if (v157 > 0x5841)
        {
          uint64_t v185 = a6[63];
          unint64_t v186 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v187 = v186 + v185;
          *a10 = v187;
          *(void *)(a11 + (v187 >> 3)) = ((v157 - 22594) << (v187 & 7)) | *(unsigned __int8 *)(a11 + (v187 >> 3));
          unint64_t v183 = v187 + 24;
          uint64_t v184 = &__dst[63];
        }
        else
        {
          uint64_t v180 = a6[62];
          unint64_t v181 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v182 = v181 + v180;
          *a10 = v182;
          *(void *)(a11 + (v182 >> 3)) = ((v157 - 6210) << (v182 & 7)) | *(unsigned __int8 *)(a11 + (v182 >> 3));
          unint64_t v183 = v182 + 14;
          uint64_t v184 = &__dst[62];
        }
        unint64_t v162 = v199;
        ++*v184;
        *a10 = v183;
        do
        {
          int v188 = *v23++;
          uint64_t v189 = v204[v188];
          *(void *)(a11 + (v183 >> 3)) = ((unint64_t)(unsigned __int16)v203[v188] << (v183 & 7)) | *(unsigned __int8 *)(a11 + (v183 >> 3));
          v183 += v189;
          *a10 = v183;
          --v157;
        }
        while (v157);
LABEL_124:
        unint64_t v22 = (unsigned __int8 *)v25;
        if (!v162) {
          goto LABEL_141;
        }
      }
LABEL_125:
      unint64_t v199 = v162;
      if (v162 >= 0x18000) {
        unint64_t v178 = 98304;
      }
      else {
        unint64_t v178 = v162;
      }
      unint64_t v201 = v178;
      unint64_t v195 = *a10;
      BrotliStoreMetaBlockHeader(v178, 0, a10, a11);
      unint64_t v179 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
      *a10 = v179 + 13;
      unint64_t result = BuildAndStoreLiteralPrefixCode(v193, v22, v201, v204, (uint64_t)v203, a10, a11);
      if (*(_DWORD *)(v193 + 24)) {
        return result;
      }
      unint64_t v192 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      goto LABEL_11;
    }
    unint64_t v200 = v156;
    unint64_t v22 = v202;
    UpdateBits((v201 - 1), v195 + 3, a11);
  }
  unint64_t v26 = v200 - 5;
  unint64_t v27 = v199;
  if (v200 - 5 >= v199 - 16) {
    unint64_t v26 = v199 - 16;
  }
  int v28 = &v22[v26];
  int v29 = -1;
  unint64_t v196 = v22;
LABEL_16:
  while (2)
  {
    uint64_t v31 = *(void *)++v22;
    uint64_t v30 = v31;
    for (unsigned int i = 32; ; ++i)
    {
      int v33 = &v22[i >> 5];
      if (v33 > v28) {
        goto LABEL_99;
      }
      unint64_t v34 = (unint64_t)(0x1E35A7BD000000 * v30) >> 53;
      uint64_t v30 = *(void *)v33;
      unint64_t v35 = &v22[-v29];
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
        break;
      }
      unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
      *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
        goto LABEL_24;
      }
LABEL_28:
      unint64_t v22 = v33;
    }
    *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
LABEL_24:
    int v37 = v22 - v35;
    if (v22 - v35 > 262128) {
      goto LABEL_28;
    }
    size_t v38 = v35 + 5;
    unsigned int v39 = v22 + 5;
    unint64_t v40 = v25 - (void)v22 - 5;
    if (v40 < 8)
    {
      unint64_t v43 = 0;
LABEL_88:
      unint64_t v147 = v40 & 7;
      if (v147)
      {
        unint64_t v148 = v43 | v147;
        while (v38[v43] == *v39)
        {
          ++v39;
          ++v43;
          if (!--v147)
          {
            unint64_t v43 = v148;
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v41 = 0;
      unint64_t v42 = v40 >> 3;
      unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8;
      while (1)
      {
        uint64_t v44 = *(void *)&v39[v41];
        uint64_t v45 = *(void *)&v38[v41];
        if (v44 != v45) {
          break;
        }
        v41 += 8;
        if (!--v42)
        {
          v39 += v40 & 0xFFFFFFFFFFFFFFF8;
          goto LABEL_88;
        }
      }
      unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
    }
    unint64_t v46 = v22 - v23;
    if ((unint64_t)(v22 - v23) >> 1 <= 0xC20)
    {
      if (v46 > 5)
      {
        if (v46 > 0x81)
        {
          if (v46 > 0x841)
          {
            uint64_t v62 = a6[61];
            unint64_t v63 = *a10;
            unint64_t result = *a10 & 7;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v64 = v63 + v62;
            *a10 = v64;
            *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
            unint64_t v50 = v64 + 12;
            *a10 = v50;
            uint64_t v51 = &__dst[61];
          }
          else
          {
            uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
            uint64_t v59 = a6[v58 + 50];
            unint64_t v60 = *a10;
            unint64_t v25 = (unint64_t)v202;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v61 = v60 + v59;
            *a10 = v61;
            unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
            *(void *)(a11 + (v61 >> 3)) = (((-1 << v58) + v46 - 66) << (v61 & 7)) | result;
            unint64_t v50 = v61 + v58;
            *a10 = v61 + v58;
            uint64_t v51 = &__dst[v58 + 50];
          }
        }
        else
        {
          uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
          unint64_t v53 = (v46 - 2) >> v52;
          uint64_t v54 = (2 * v52) + v53 + 42;
          uint64_t v55 = a6[v54];
          unint64_t v56 = *a10;
          unint64_t v25 = (unint64_t)v202;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v57 = v56 + v55;
          *a10 = v57;
          unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
          *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
          unint64_t v50 = v57 + v52;
          *a10 = v57 + v52;
          uint64_t v51 = &__dst[v54];
        }
      }
      else
      {
        uint64_t v47 = a6[v46 + 40];
        unint64_t v48 = *a10;
        unint64_t v49 = *a10 >> 3;
        unint64_t result = *(unsigned __int8 *)(a11 + v49);
        *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(unsigned char *)a10 & 7)) | result;
        unint64_t v50 = v48 + v47;
        *a10 = v50;
        uint64_t v51 = &__dst[v46 + 40];
      }
LABEL_43:
      ++*v51;
      if (v22 != v23)
      {
        if (v46 <= 1) {
          unint64_t v46 = 1;
        }
        do
        {
          int v65 = *v23++;
          uint64_t v66 = v204[v65];
          unint64_t result = v50 & 7;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v203[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          v50 += v66;
          *a10 = v50;
          --v46;
        }
        while (v46);
      }
      unint64_t v67 = v50 >> 3;
      if (v29 == v37)
      {
        uint64_t v68 = a6[64];
        *(void *)(a11 + v67) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        unint64_t v69 = v50 + v68;
        uint64_t v70 = &__dst[64];
      }
      else
      {
        unint64_t v71 = v37 + 3;
        unsigned int v72 = __clz(v71) ^ 0x1F;
        uint64_t v73 = v72 - 1;
        uint64_t v74 = (v71 >> (v72 - 1)) & 1 | 2;
        uint64_t v75 = ((2 * v72 - 4) & 0xFFFFFFFE | (v71 >> (v72 - 1)) & 1) + 80;
        uint64_t v76 = a6[v75];
        unint64_t result = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v75) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        *(void *)(a11 + v67) = result;
        *a10 = v50 + v76;
        *(void *)(a11 + ((v50 + v76) >> 3)) = ((v71 - (v74 << v73)) << ((v50 + v76) & 7)) | *(unsigned __int8 *)(a11 + ((v50 + v76) >> 3));
        unint64_t v69 = v50 + v76 + v73;
        uint64_t v70 = &__dst[v75];
        int v29 = v37;
      }
      unint64_t v77 = v43 + 5;
      ++*v70;
      *a10 = v69;
      if (v43 + 5 > 0xB)
      {
        if (v77 > 0x47)
        {
          if (v77 > 0x87)
          {
            if (v77 > 0x847)
            {
              uint64_t v98 = a6[39];
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
              unint64_t v99 = v69 + v98;
              *a10 = v99;
              char v100 = v99 & 7;
              *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
              unint64_t v101 = v99 + 24;
              *a10 = v99 + 24;
              uint64_t v102 = a6[64];
              *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
              *a10 = v101 + v102;
              ++__dst[39];
            }
            else
            {
              unint64_t v92 = v43 - 67;
              uint64_t v93 = __clz(v92) ^ 0x1F;
              uint64_t v94 = a6[v93 + 28];
              unint64_t result = *(unsigned __int8 *)(a11 + (v69 >> 3));
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v69 & 7)) | result;
              unint64_t v95 = v69 + v94;
              *a10 = v95;
              *(void *)(a11 + (v95 >> 3)) = (((-1 << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
              unint64_t v96 = v95 + v93;
              *a10 = v95 + v93;
              uint64_t v97 = a6[64];
              *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
              *a10 = v96 + v97;
              ++__dst[v93 + 28];
            }
          }
          else
          {
            unint64_t v86 = v43 - 3;
            uint64_t v87 = (v86 >> 5) + 30;
            uint64_t v88 = a6[v87];
            unint64_t result = v69 & 7;
            *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
            unint64_t v89 = v69 + v88;
            *a10 = v89;
            *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
            unint64_t v90 = v89 + 5;
            *a10 = v89 + 5;
            uint64_t v91 = a6[64];
            *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
            *a10 = v90 + v91;
            ++__dst[v87];
          }
          double v80 = &__dst[64];
        }
        else
        {
          unint64_t v81 = v43 - 3;
          uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
          uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
          uint64_t v84 = a6[v83];
          unint64_t result = v69 >> 3;
          *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
          unint64_t v85 = v69 + v84;
          *a10 = v85;
          *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
          *a10 = v85 + v82;
          double v80 = &__dst[v83];
        }
      }
      else
      {
        unint64_t v78 = v43 + 1;
        uint64_t v79 = a6[v78];
        *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
        *a10 = v69 + v79;
        double v80 = &__dst[v78];
      }
      v22 += v77;
      ++*v80;
      if (v22 >= v28)
      {
LABEL_98:
        unint64_t v23 = v22;
LABEL_99:
        unint64_t v24 = v200;
        goto LABEL_100;
      }
      unint64_t v103 = *(void *)(v22 - 3);
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v103) >> 51) & 0x1FFC)) = v22 - a2 - 3;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 8)) >> 51) & 0x1FFC)) = v22 - a2 - 2;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 16)) >> 51) & 0x1FFC)) = v22 - a2 - 1;
      unint64_t v104 = ((0x1E35A7BD000000 * (v103 >> 24)) >> 51) & 0x1FFC;
      uint64_t v105 = *(int *)(a5 + v104);
      *(_DWORD *)(a5 + v104) = v22 - a2;
      char v106 = &a2[v105];
      unint64_t v23 = v22;
      if (*(_DWORD *)v22 == *(_DWORD *)&a2[v105])
      {
        while (1)
        {
          unint64_t v23 = v22;
          if (v22[4] != v106[4]) {
            break;
          }
          uint64_t v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v25 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0;
LABEL_81:
            unint64_t v145 = v109 & 7;
            if (v145)
            {
              unint64_t v146 = v112 | v145;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v145)
                {
                  unint64_t v112 = v146;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v110 = 0;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_81;
              }
            }
            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }
          uint64_t v114 = v22 - v106;
          if (v114 <= 262128)
          {
            unint64_t v115 = v112 + 5;
            if (v112 + 5 > 9)
            {
              if (v115 > 0x85)
              {
                if (v115 > 0x845)
                {
                  uint64_t v132 = a6[39];
                  unint64_t v133 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v134 = v133 + v132;
                  *a10 = v134;
                  *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                  unint64_t v119 = v134 + 24;
                  *a10 = v134 + 24;
                  int v120 = &__dst[39];
                }
                else
                {
                  unint64_t v127 = v112 - 65;
                  uint64_t v128 = __clz(v127) ^ 0x1F;
                  uint64_t v129 = a6[v128 + 28];
                  unint64_t v130 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v131 = v130 + v129;
                  *a10 = v131;
                  *(void *)(a11 + (v131 >> 3)) = (((-1 << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                  unint64_t v119 = v131 + v128;
                  *a10 = v131 + v128;
                  int v120 = &__dst[v128 + 28];
                }
              }
              else
              {
                unint64_t v121 = v112 - 1;
                uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
                uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
                uint64_t v124 = a6[v123];
                unint64_t v125 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v126 = v125 + v124;
                *a10 = v126;
                *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
                unint64_t v119 = v126 + v122;
                *a10 = v126 + v122;
                int v120 = &__dst[v123];
              }
            }
            else
            {
              unint64_t v116 = v112 + 19;
              uint64_t v117 = a6[v112 + 19];
              unint64_t v118 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v119 = v118 + v117;
              *a10 = v119;
              int v120 = &__dst[v116];
            }
            v22 += v115;
            ++*v120;
            unint64_t v135 = (int)v114 + 3;
            unsigned int v136 = __clz(v135) ^ 0x1F;
            uint64_t v137 = v136 - 1;
            uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
            uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
            uint64_t v140 = a6[v139];
            unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
            *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
            unint64_t v141 = v119 + v140;
            *a10 = v141;
            *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
            *a10 = v141 + v137;
            ++__dst[v139];
            if (v22 >= v28) {
              goto LABEL_98;
            }
            int v29 = v114;
            unint64_t v142 = *(void *)(v22 - 3);
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v142) >> 51) & 0x1FFC)) = v22 - a2 - 3;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 8)) >> 51) & 0x1FFC)) = v22 - a2 - 2;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 16)) >> 51) & 0x1FFC)) = v22 - a2 - 1;
            unint64_t v143 = ((0x1E35A7BD000000 * (v142 >> 24)) >> 51) & 0x1FFC;
            uint64_t v144 = *(int *)(a5 + v143);
            *(_DWORD *)(a5 + v143) = v22 - a2;
            char v106 = &a2[v144];
            if (*(_DWORD *)v22 == *(_DWORD *)&a2[v144]) {
              continue;
            }
          }
          unint64_t v23 = v22;
          goto LABEL_16;
        }
      }
      continue;
    }
    break;
  }
  if (50 * (v23 - v194) > v46 || v192 < 0x3D5)
  {
    if (v46 > 0x5841)
    {
      uint64_t v152 = a6[63];
      unint64_t v153 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v154 = v153 + v152;
      *a10 = v154;
      *(void *)(a11 + (v154 >> 3)) = ((v46 - 22594) << (v154 & 7)) | *(unsigned __int8 *)(a11 + (v154 >> 3));
      unint64_t v50 = v154 + 24;
      *a10 = v50;
      uint64_t v51 = &__dst[63];
    }
    else
    {
      uint64_t v149 = a6[62];
      unint64_t v150 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v151 = v150 + v149;
      *a10 = v151;
      *(void *)(a11 + (v151 >> 3)) = ((v46 - 6210) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
      unint64_t v50 = v151 + 14;
      *a10 = v50;
      uint64_t v51 = &__dst[62];
    }
    goto LABEL_43;
  }
  unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, (uint64_t)v22, v195, a10, a11);
  unint64_t v162 = &v196[v199] - v22;
  if (v162) {
    goto LABEL_125;
  }
LABEL_141:
  if (!a4)
  {
    *a9 = 0;
    *a8 = 0;
    return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
  }
  return result;
}

unint64_t BrotliCompressFragmentFastImpl13(unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, unsigned char *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v206 = *MEMORY[0x263EF8340];
  unint64_t v199 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v195 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t v201 = v14;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v204, (uint64_t)v203, a10, a11);
  unint64_t v193 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v192 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8;
    }
    while (v21 < *a8);
    v18 += v20;
  }
  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
LABEL_11:
  unint64_t v200 = v201;
  unint64_t v23 = v22;
  unint64_t v194 = v22;
  while (1)
  {
    unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
    unint64_t v24 = v200;
    unint64_t v25 = (unint64_t)&v22[v200];
    unsigned int v202 = &v22[v200];
    if (v200 >= 0x10) {
      break;
    }
    unint64_t v27 = v199;
LABEL_100:
    unint64_t v155 = v27 - v24;
    if (v155 >= 0x10000) {
      unint64_t v156 = 0x10000;
    }
    else {
      unint64_t v156 = v155;
    }
    unint64_t v199 = v155;
    if (!v155
      || (v201 += v156, v201 > 0x100000)
      || (unint64_t result = ShouldMergeBlock(v25, v156, (uint64_t)v204), v25 = (unint64_t)v202, !result))
    {
      if ((unint64_t)v23 >= v25)
      {
        unint64_t v22 = (unsigned __int8 *)v25;
LABEL_113:
        unint64_t v162 = v199;
        if (!v199) {
          goto LABEL_141;
        }
      }
      else
      {
        unint64_t v157 = v25 - (void)v23;
        if ((v25 - (unint64_t)v23) >> 1 <= 0xC20)
        {
          if (v157 > 5)
          {
            unint64_t v162 = v199;
            if (v157 > 0x81)
            {
              if (v157 > 0x841)
              {
                uint64_t v173 = a6[61];
                unint64_t v174 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v175 = v174 + v173;
                *a10 = v175;
                *(void *)(a11 + (v175 >> 3)) = ((v157 - 2114) << (v175 & 7)) | *(unsigned __int8 *)(a11 + (v175 >> 3));
                unint64_t v160 = v175 + 12;
                *a10 = v160;
                unsigned int v161 = &__dst[61];
              }
              else
              {
                uint64_t v169 = __clz(v157 - 66) ^ 0x1F;
                uint64_t v170 = a6[v169 + 50];
                unint64_t v171 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v169 + 50)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v172 = v171 + v170;
                *a10 = v172;
                *(void *)(a11 + (v172 >> 3)) = (((-1 << v169) + v157 - 66) << (v172 & 7)) | *(unsigned __int8 *)(a11 + (v172 >> 3));
                unint64_t v160 = v172 + v169;
                *a10 = v172 + v169;
                unsigned int v161 = &__dst[v169 + 50];
              }
            }
            else
            {
              uint64_t v163 = (__clz(v157 - 2) ^ 0x1F) - 1;
              unint64_t v164 = (v157 - 2) >> v163;
              uint64_t v165 = (2 * v163) + v164 + 42;
              uint64_t v166 = a6[v165];
              unint64_t v167 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v165) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v168 = v167 + v166;
              *a10 = v168;
              *(void *)(a11 + (v168 >> 3)) = ((v157 - 2 - (v164 << v163)) << (v168 & 7)) | *(unsigned __int8 *)(a11 + (v168 >> 3));
              unint64_t v160 = v168 + v163;
              *a10 = v168 + v163;
              unsigned int v161 = &__dst[v165];
            }
          }
          else
          {
            uint64_t v158 = a6[v157 + 40];
            unint64_t v159 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v157 + 40)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v160 = v159 + v158;
            *a10 = v160;
            unsigned int v161 = &__dst[v157 + 40];
            unint64_t v162 = v199;
          }
          ++*v161;
          if ((unsigned __int8 *)v25 != v23)
          {
            if (v157 <= 1) {
              unint64_t v157 = 1;
            }
            do
            {
              int v176 = *v23++;
              uint64_t v177 = v204[v176];
              *(void *)(a11 + (v160 >> 3)) = ((unint64_t)(unsigned __int16)v203[v176] << (v160 & 7)) | *(unsigned __int8 *)(a11 + (v160 >> 3));
              v160 += v177;
              *a10 = v160;
              --v157;
            }
            while (v157);
          }
          goto LABEL_124;
        }
        unint64_t result = (unint64_t)v194;
        if (50 * (v23 - v194) <= v157 && v192 >= 0x3D5)
        {
          unint64_t v22 = (unsigned __int8 *)v25;
          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, v25, v195, a10, a11);
          goto LABEL_113;
        }
        if (v157 > 0x5841)
        {
          uint64_t v185 = a6[63];
          unint64_t v186 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v187 = v186 + v185;
          *a10 = v187;
          *(void *)(a11 + (v187 >> 3)) = ((v157 - 22594) << (v187 & 7)) | *(unsigned __int8 *)(a11 + (v187 >> 3));
          unint64_t v183 = v187 + 24;
          uint64_t v184 = &__dst[63];
        }
        else
        {
          uint64_t v180 = a6[62];
          unint64_t v181 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v182 = v181 + v180;
          *a10 = v182;
          *(void *)(a11 + (v182 >> 3)) = ((v157 - 6210) << (v182 & 7)) | *(unsigned __int8 *)(a11 + (v182 >> 3));
          unint64_t v183 = v182 + 14;
          uint64_t v184 = &__dst[62];
        }
        unint64_t v162 = v199;
        ++*v184;
        *a10 = v183;
        do
        {
          int v188 = *v23++;
          uint64_t v189 = v204[v188];
          *(void *)(a11 + (v183 >> 3)) = ((unint64_t)(unsigned __int16)v203[v188] << (v183 & 7)) | *(unsigned __int8 *)(a11 + (v183 >> 3));
          v183 += v189;
          *a10 = v183;
          --v157;
        }
        while (v157);
LABEL_124:
        unint64_t v22 = (unsigned __int8 *)v25;
        if (!v162) {
          goto LABEL_141;
        }
      }
LABEL_125:
      unint64_t v199 = v162;
      if (v162 >= 0x18000) {
        unint64_t v178 = 98304;
      }
      else {
        unint64_t v178 = v162;
      }
      unint64_t v201 = v178;
      unint64_t v195 = *a10;
      BrotliStoreMetaBlockHeader(v178, 0, a10, a11);
      unint64_t v179 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
      *a10 = v179 + 13;
      unint64_t result = BuildAndStoreLiteralPrefixCode(v193, v22, v201, v204, (uint64_t)v203, a10, a11);
      if (*(_DWORD *)(v193 + 24)) {
        return result;
      }
      unint64_t v192 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      goto LABEL_11;
    }
    unint64_t v200 = v156;
    unint64_t v22 = v202;
    UpdateBits((v201 - 1), v195 + 3, a11);
  }
  unint64_t v26 = v200 - 5;
  unint64_t v27 = v199;
  if (v200 - 5 >= v199 - 16) {
    unint64_t v26 = v199 - 16;
  }
  int v28 = &v22[v26];
  int v29 = -1;
  unint64_t v196 = v22;
LABEL_16:
  while (2)
  {
    uint64_t v31 = *(void *)++v22;
    uint64_t v30 = v31;
    for (unsigned int i = 32; ; ++i)
    {
      int v33 = &v22[i >> 5];
      if (v33 > v28) {
        goto LABEL_99;
      }
      unint64_t v34 = (unint64_t)(0x1E35A7BD000000 * v30) >> 51;
      uint64_t v30 = *(void *)v33;
      unint64_t v35 = &v22[-v29];
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
        break;
      }
      unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
      *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
        goto LABEL_24;
      }
LABEL_28:
      unint64_t v22 = v33;
    }
    *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
LABEL_24:
    int v37 = v22 - v35;
    if (v22 - v35 > 262128) {
      goto LABEL_28;
    }
    size_t v38 = v35 + 5;
    unsigned int v39 = v22 + 5;
    unint64_t v40 = v25 - (void)v22 - 5;
    if (v40 < 8)
    {
      unint64_t v43 = 0;
LABEL_88:
      unint64_t v147 = v40 & 7;
      if (v147)
      {
        unint64_t v148 = v43 | v147;
        while (v38[v43] == *v39)
        {
          ++v39;
          ++v43;
          if (!--v147)
          {
            unint64_t v43 = v148;
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v41 = 0;
      unint64_t v42 = v40 >> 3;
      unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8;
      while (1)
      {
        uint64_t v44 = *(void *)&v39[v41];
        uint64_t v45 = *(void *)&v38[v41];
        if (v44 != v45) {
          break;
        }
        v41 += 8;
        if (!--v42)
        {
          v39 += v40 & 0xFFFFFFFFFFFFFFF8;
          goto LABEL_88;
        }
      }
      unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
    }
    unint64_t v46 = v22 - v23;
    if ((unint64_t)(v22 - v23) >> 1 <= 0xC20)
    {
      if (v46 > 5)
      {
        if (v46 > 0x81)
        {
          if (v46 > 0x841)
          {
            uint64_t v62 = a6[61];
            unint64_t v63 = *a10;
            unint64_t result = *a10 & 7;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v64 = v63 + v62;
            *a10 = v64;
            *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
            unint64_t v50 = v64 + 12;
            *a10 = v50;
            uint64_t v51 = &__dst[61];
          }
          else
          {
            uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
            uint64_t v59 = a6[v58 + 50];
            unint64_t v60 = *a10;
            unint64_t v25 = (unint64_t)v202;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v61 = v60 + v59;
            *a10 = v61;
            unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
            *(void *)(a11 + (v61 >> 3)) = (((-1 << v58) + v46 - 66) << (v61 & 7)) | result;
            unint64_t v50 = v61 + v58;
            *a10 = v61 + v58;
            uint64_t v51 = &__dst[v58 + 50];
          }
        }
        else
        {
          uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
          unint64_t v53 = (v46 - 2) >> v52;
          uint64_t v54 = (2 * v52) + v53 + 42;
          uint64_t v55 = a6[v54];
          unint64_t v56 = *a10;
          unint64_t v25 = (unint64_t)v202;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v57 = v56 + v55;
          *a10 = v57;
          unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
          *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
          unint64_t v50 = v57 + v52;
          *a10 = v57 + v52;
          uint64_t v51 = &__dst[v54];
        }
      }
      else
      {
        uint64_t v47 = a6[v46 + 40];
        unint64_t v48 = *a10;
        unint64_t v49 = *a10 >> 3;
        unint64_t result = *(unsigned __int8 *)(a11 + v49);
        *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(unsigned char *)a10 & 7)) | result;
        unint64_t v50 = v48 + v47;
        *a10 = v50;
        uint64_t v51 = &__dst[v46 + 40];
      }
LABEL_43:
      ++*v51;
      if (v22 != v23)
      {
        if (v46 <= 1) {
          unint64_t v46 = 1;
        }
        do
        {
          int v65 = *v23++;
          uint64_t v66 = v204[v65];
          unint64_t result = v50 & 7;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v203[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          v50 += v66;
          *a10 = v50;
          --v46;
        }
        while (v46);
      }
      unint64_t v67 = v50 >> 3;
      if (v29 == v37)
      {
        uint64_t v68 = a6[64];
        *(void *)(a11 + v67) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        unint64_t v69 = v50 + v68;
        uint64_t v70 = &__dst[64];
      }
      else
      {
        unint64_t v71 = v37 + 3;
        unsigned int v72 = __clz(v71) ^ 0x1F;
        uint64_t v73 = v72 - 1;
        uint64_t v74 = (v71 >> (v72 - 1)) & 1 | 2;
        uint64_t v75 = ((2 * v72 - 4) & 0xFFFFFFFE | (v71 >> (v72 - 1)) & 1) + 80;
        uint64_t v76 = a6[v75];
        unint64_t result = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v75) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        *(void *)(a11 + v67) = result;
        *a10 = v50 + v76;
        *(void *)(a11 + ((v50 + v76) >> 3)) = ((v71 - (v74 << v73)) << ((v50 + v76) & 7)) | *(unsigned __int8 *)(a11 + ((v50 + v76) >> 3));
        unint64_t v69 = v50 + v76 + v73;
        uint64_t v70 = &__dst[v75];
        int v29 = v37;
      }
      unint64_t v77 = v43 + 5;
      ++*v70;
      *a10 = v69;
      if (v43 + 5 > 0xB)
      {
        if (v77 > 0x47)
        {
          if (v77 > 0x87)
          {
            if (v77 > 0x847)
            {
              uint64_t v98 = a6[39];
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
              unint64_t v99 = v69 + v98;
              *a10 = v99;
              char v100 = v99 & 7;
              *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
              unint64_t v101 = v99 + 24;
              *a10 = v99 + 24;
              uint64_t v102 = a6[64];
              *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
              *a10 = v101 + v102;
              ++__dst[39];
            }
            else
            {
              unint64_t v92 = v43 - 67;
              uint64_t v93 = __clz(v92) ^ 0x1F;
              uint64_t v94 = a6[v93 + 28];
              unint64_t result = *(unsigned __int8 *)(a11 + (v69 >> 3));
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v69 & 7)) | result;
              unint64_t v95 = v69 + v94;
              *a10 = v95;
              *(void *)(a11 + (v95 >> 3)) = (((-1 << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
              unint64_t v96 = v95 + v93;
              *a10 = v95 + v93;
              uint64_t v97 = a6[64];
              *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
              *a10 = v96 + v97;
              ++__dst[v93 + 28];
            }
          }
          else
          {
            unint64_t v86 = v43 - 3;
            uint64_t v87 = (v86 >> 5) + 30;
            uint64_t v88 = a6[v87];
            unint64_t result = v69 & 7;
            *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
            unint64_t v89 = v69 + v88;
            *a10 = v89;
            *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
            unint64_t v90 = v89 + 5;
            *a10 = v89 + 5;
            uint64_t v91 = a6[64];
            *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
            *a10 = v90 + v91;
            ++__dst[v87];
          }
          double v80 = &__dst[64];
        }
        else
        {
          unint64_t v81 = v43 - 3;
          uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
          uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
          uint64_t v84 = a6[v83];
          unint64_t result = v69 >> 3;
          *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
          unint64_t v85 = v69 + v84;
          *a10 = v85;
          *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
          *a10 = v85 + v82;
          double v80 = &__dst[v83];
        }
      }
      else
      {
        unint64_t v78 = v43 + 1;
        uint64_t v79 = a6[v78];
        *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
        *a10 = v69 + v79;
        double v80 = &__dst[v78];
      }
      v22 += v77;
      ++*v80;
      if (v22 >= v28)
      {
LABEL_98:
        unint64_t v23 = v22;
LABEL_99:
        unint64_t v24 = v200;
        goto LABEL_100;
      }
      unint64_t v103 = *(void *)(v22 - 3);
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v103) >> 49) & 0x7FFC)) = v22 - a2 - 3;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 8)) >> 49) & 0x7FFC)) = v22 - a2 - 2;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 16)) >> 49) & 0x7FFC)) = v22 - a2 - 1;
      unint64_t v104 = ((0x1E35A7BD000000 * (v103 >> 24)) >> 49) & 0x7FFC;
      uint64_t v105 = *(int *)(a5 + v104);
      *(_DWORD *)(a5 + v104) = v22 - a2;
      char v106 = &a2[v105];
      unint64_t v23 = v22;
      if (*(_DWORD *)v22 == *(_DWORD *)&a2[v105])
      {
        while (1)
        {
          unint64_t v23 = v22;
          if (v22[4] != v106[4]) {
            break;
          }
          uint64_t v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v25 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0;
LABEL_81:
            unint64_t v145 = v109 & 7;
            if (v145)
            {
              unint64_t v146 = v112 | v145;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v145)
                {
                  unint64_t v112 = v146;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v110 = 0;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_81;
              }
            }
            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }
          uint64_t v114 = v22 - v106;
          if (v114 <= 262128)
          {
            unint64_t v115 = v112 + 5;
            if (v112 + 5 > 9)
            {
              if (v115 > 0x85)
              {
                if (v115 > 0x845)
                {
                  uint64_t v132 = a6[39];
                  unint64_t v133 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v134 = v133 + v132;
                  *a10 = v134;
                  *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                  unint64_t v119 = v134 + 24;
                  *a10 = v134 + 24;
                  int v120 = &__dst[39];
                }
                else
                {
                  unint64_t v127 = v112 - 65;
                  uint64_t v128 = __clz(v127) ^ 0x1F;
                  uint64_t v129 = a6[v128 + 28];
                  unint64_t v130 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v131 = v130 + v129;
                  *a10 = v131;
                  *(void *)(a11 + (v131 >> 3)) = (((-1 << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                  unint64_t v119 = v131 + v128;
                  *a10 = v131 + v128;
                  int v120 = &__dst[v128 + 28];
                }
              }
              else
              {
                unint64_t v121 = v112 - 1;
                uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
                uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
                uint64_t v124 = a6[v123];
                unint64_t v125 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v126 = v125 + v124;
                *a10 = v126;
                *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
                unint64_t v119 = v126 + v122;
                *a10 = v126 + v122;
                int v120 = &__dst[v123];
              }
            }
            else
            {
              unint64_t v116 = v112 + 19;
              uint64_t v117 = a6[v112 + 19];
              unint64_t v118 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v119 = v118 + v117;
              *a10 = v119;
              int v120 = &__dst[v116];
            }
            v22 += v115;
            ++*v120;
            unint64_t v135 = (int)v114 + 3;
            unsigned int v136 = __clz(v135) ^ 0x1F;
            uint64_t v137 = v136 - 1;
            uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
            uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
            uint64_t v140 = a6[v139];
            unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
            *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
            unint64_t v141 = v119 + v140;
            *a10 = v141;
            *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
            *a10 = v141 + v137;
            ++__dst[v139];
            if (v22 >= v28) {
              goto LABEL_98;
            }
            int v29 = v114;
            unint64_t v142 = *(void *)(v22 - 3);
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v142) >> 49) & 0x7FFC)) = v22 - a2 - 3;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 8)) >> 49) & 0x7FFC)) = v22 - a2 - 2;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 16)) >> 49) & 0x7FFC)) = v22 - a2 - 1;
            unint64_t v143 = ((0x1E35A7BD000000 * (v142 >> 24)) >> 49) & 0x7FFC;
            uint64_t v144 = *(int *)(a5 + v143);
            *(_DWORD *)(a5 + v143) = v22 - a2;
            char v106 = &a2[v144];
            if (*(_DWORD *)v22 == *(_DWORD *)&a2[v144]) {
              continue;
            }
          }
          unint64_t v23 = v22;
          goto LABEL_16;
        }
      }
      continue;
    }
    break;
  }
  if (50 * (v23 - v194) > v46 || v192 < 0x3D5)
  {
    if (v46 > 0x5841)
    {
      uint64_t v152 = a6[63];
      unint64_t v153 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v154 = v153 + v152;
      *a10 = v154;
      *(void *)(a11 + (v154 >> 3)) = ((v46 - 22594) << (v154 & 7)) | *(unsigned __int8 *)(a11 + (v154 >> 3));
      unint64_t v50 = v154 + 24;
      *a10 = v50;
      uint64_t v51 = &__dst[63];
    }
    else
    {
      uint64_t v149 = a6[62];
      unint64_t v150 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v151 = v150 + v149;
      *a10 = v151;
      *(void *)(a11 + (v151 >> 3)) = ((v46 - 6210) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
      unint64_t v50 = v151 + 14;
      *a10 = v50;
      uint64_t v51 = &__dst[62];
    }
    goto LABEL_43;
  }
  unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, (uint64_t)v22, v195, a10, a11);
  unint64_t v162 = &v196[v199] - v22;
  if (v162) {
    goto LABEL_125;
  }
LABEL_141:
  if (!a4)
  {
    *a9 = 0;
    *a8 = 0;
    return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
  }
  return result;
}

unint64_t BrotliCompressFragmentFastImpl15(unint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, unint64_t *a8, unsigned char *a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v206 = *MEMORY[0x263EF8340];
  unint64_t v199 = a3;
  if (a3 >= 0x18000) {
    unint64_t v14 = 98304;
  }
  else {
    unint64_t v14 = a3;
  }
  unint64_t v195 = *a10;
  BrotliStoreMetaBlockHeader(v14, 0, a10, a11);
  unint64_t v15 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v15 + 13;
  unint64_t v201 = v14;
  unint64_t result = BuildAndStoreLiteralPrefixCode(a1, a2, v14, v204, (uint64_t)v203, a10, a11);
  unint64_t v193 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v192 = result;
  unint64_t v17 = *a8;
  unint64_t v18 = *a10;
  if (*a8 >= 8)
  {
    unint64_t v19 = 0;
    do
    {
      *(void *)(a11 + ((v18 + v19) >> 3)) = ((unint64_t)a9[v19 >> 3] << ((v18 + v19) & 7)) | *(unsigned __int8 *)(a11 + ((v18 + v19) >> 3));
      *a10 = v18 + v19 + 8;
      unint64_t v20 = v19 + 8;
      unint64_t v17 = *a8;
      unint64_t v21 = v19 + 15;
      v19 += 8;
    }
    while (v21 < *a8);
    v18 += v20;
  }
  *(void *)(a11 + (v18 >> 3)) = ((unint64_t)a9[v17 >> 3] << (v18 & 7)) | *(unsigned __int8 *)(a11 + (v18 >> 3));
  *a10 = v18 + (v17 & 7);
  unint64_t v22 = a2;
LABEL_11:
  unint64_t v200 = v201;
  unint64_t v23 = v22;
  unint64_t v194 = v22;
  while (1)
  {
    unint64_t result = (unint64_t)memcpy(__dst, &kCmdHistoSeed, sizeof(__dst));
    unint64_t v24 = v200;
    unint64_t v25 = (unint64_t)&v22[v200];
    unsigned int v202 = &v22[v200];
    if (v200 >= 0x10) {
      break;
    }
    unint64_t v27 = v199;
LABEL_100:
    unint64_t v155 = v27 - v24;
    if (v155 >= 0x10000) {
      unint64_t v156 = 0x10000;
    }
    else {
      unint64_t v156 = v155;
    }
    unint64_t v199 = v155;
    if (!v155
      || (v201 += v156, v201 > 0x100000)
      || (unint64_t result = ShouldMergeBlock(v25, v156, (uint64_t)v204), v25 = (unint64_t)v202, !result))
    {
      if ((unint64_t)v23 >= v25)
      {
        unint64_t v22 = (unsigned __int8 *)v25;
LABEL_113:
        unint64_t v162 = v199;
        if (!v199) {
          goto LABEL_141;
        }
      }
      else
      {
        unint64_t v157 = v25 - (void)v23;
        if ((v25 - (unint64_t)v23) >> 1 <= 0xC20)
        {
          if (v157 > 5)
          {
            unint64_t v162 = v199;
            if (v157 > 0x81)
            {
              if (v157 > 0x841)
              {
                uint64_t v173 = a6[61];
                unint64_t v174 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v175 = v174 + v173;
                *a10 = v175;
                *(void *)(a11 + (v175 >> 3)) = ((v157 - 2114) << (v175 & 7)) | *(unsigned __int8 *)(a11 + (v175 >> 3));
                unint64_t v160 = v175 + 12;
                *a10 = v160;
                unsigned int v161 = &__dst[61];
              }
              else
              {
                uint64_t v169 = __clz(v157 - 66) ^ 0x1F;
                uint64_t v170 = a6[v169 + 50];
                unint64_t v171 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v169 + 50)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v172 = v171 + v170;
                *a10 = v172;
                *(void *)(a11 + (v172 >> 3)) = (((-1 << v169) + v157 - 66) << (v172 & 7)) | *(unsigned __int8 *)(a11 + (v172 >> 3));
                unint64_t v160 = v172 + v169;
                *a10 = v172 + v169;
                unsigned int v161 = &__dst[v169 + 50];
              }
            }
            else
            {
              uint64_t v163 = (__clz(v157 - 2) ^ 0x1F) - 1;
              unint64_t v164 = (v157 - 2) >> v163;
              uint64_t v165 = (2 * v163) + v164 + 42;
              uint64_t v166 = a6[v165];
              unint64_t v167 = *a10;
              unint64_t result = *a10 & 7;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v165) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v168 = v167 + v166;
              *a10 = v168;
              *(void *)(a11 + (v168 >> 3)) = ((v157 - 2 - (v164 << v163)) << (v168 & 7)) | *(unsigned __int8 *)(a11 + (v168 >> 3));
              unint64_t v160 = v168 + v163;
              *a10 = v168 + v163;
              unsigned int v161 = &__dst[v165];
            }
          }
          else
          {
            uint64_t v158 = a6[v157 + 40];
            unint64_t v159 = *a10;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v157 + 40)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v160 = v159 + v158;
            *a10 = v160;
            unsigned int v161 = &__dst[v157 + 40];
            unint64_t v162 = v199;
          }
          ++*v161;
          if ((unsigned __int8 *)v25 != v23)
          {
            if (v157 <= 1) {
              unint64_t v157 = 1;
            }
            do
            {
              int v176 = *v23++;
              uint64_t v177 = v204[v176];
              *(void *)(a11 + (v160 >> 3)) = ((unint64_t)(unsigned __int16)v203[v176] << (v160 & 7)) | *(unsigned __int8 *)(a11 + (v160 >> 3));
              v160 += v177;
              *a10 = v160;
              --v157;
            }
            while (v157);
          }
          goto LABEL_124;
        }
        unint64_t result = (unint64_t)v194;
        if (50 * (v23 - v194) <= v157 && v192 >= 0x3D5)
        {
          unint64_t v22 = (unsigned __int8 *)v25;
          unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, v25, v195, a10, a11);
          goto LABEL_113;
        }
        if (v157 > 0x5841)
        {
          uint64_t v185 = a6[63];
          unint64_t v186 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v187 = v186 + v185;
          *a10 = v187;
          *(void *)(a11 + (v187 >> 3)) = ((v157 - 22594) << (v187 & 7)) | *(unsigned __int8 *)(a11 + (v187 >> 3));
          unint64_t v183 = v187 + 24;
          uint64_t v184 = &__dst[63];
        }
        else
        {
          uint64_t v180 = a6[62];
          unint64_t v181 = *a10;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v182 = v181 + v180;
          *a10 = v182;
          *(void *)(a11 + (v182 >> 3)) = ((v157 - 6210) << (v182 & 7)) | *(unsigned __int8 *)(a11 + (v182 >> 3));
          unint64_t v183 = v182 + 14;
          uint64_t v184 = &__dst[62];
        }
        unint64_t v162 = v199;
        ++*v184;
        *a10 = v183;
        do
        {
          int v188 = *v23++;
          uint64_t v189 = v204[v188];
          *(void *)(a11 + (v183 >> 3)) = ((unint64_t)(unsigned __int16)v203[v188] << (v183 & 7)) | *(unsigned __int8 *)(a11 + (v183 >> 3));
          v183 += v189;
          *a10 = v183;
          --v157;
        }
        while (v157);
LABEL_124:
        unint64_t v22 = (unsigned __int8 *)v25;
        if (!v162) {
          goto LABEL_141;
        }
      }
LABEL_125:
      unint64_t v199 = v162;
      if (v162 >= 0x18000) {
        unint64_t v178 = 98304;
      }
      else {
        unint64_t v178 = v162;
      }
      unint64_t v201 = v178;
      unint64_t v195 = *a10;
      BrotliStoreMetaBlockHeader(v178, 0, a10, a11);
      unint64_t v179 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
      *a10 = v179 + 13;
      unint64_t result = BuildAndStoreLiteralPrefixCode(v193, v22, v201, v204, (uint64_t)v203, a10, a11);
      if (*(_DWORD *)(v193 + 24)) {
        return result;
      }
      unint64_t v192 = result;
      BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a10, a11);
      goto LABEL_11;
    }
    unint64_t v200 = v156;
    unint64_t v22 = v202;
    UpdateBits((v201 - 1), v195 + 3, a11);
  }
  unint64_t v26 = v200 - 5;
  unint64_t v27 = v199;
  if (v200 - 5 >= v199 - 16) {
    unint64_t v26 = v199 - 16;
  }
  int v28 = &v22[v26];
  int v29 = -1;
  unint64_t v196 = v22;
LABEL_16:
  while (2)
  {
    uint64_t v31 = *(void *)++v22;
    uint64_t v30 = v31;
    for (unsigned int i = 32; ; ++i)
    {
      int v33 = &v22[i >> 5];
      if (v33 > v28) {
        goto LABEL_99;
      }
      unint64_t v34 = (unint64_t)(0x1E35A7BD000000 * v30) >> 49;
      uint64_t v30 = *(void *)v33;
      unint64_t v35 = &v22[-v29];
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4] && v29 >= 1) {
        break;
      }
      unint64_t v35 = &a2[*(int *)(a5 + 4 * v34)];
      *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
      if (*(_DWORD *)v22 == *(_DWORD *)v35 && v22[4] == v35[4]) {
        goto LABEL_24;
      }
LABEL_28:
      unint64_t v22 = v33;
    }
    *(_DWORD *)(a5 + 4 * v34) = v22 - a2;
LABEL_24:
    int v37 = v22 - v35;
    if (v22 - v35 > 262128) {
      goto LABEL_28;
    }
    size_t v38 = v35 + 5;
    unsigned int v39 = v22 + 5;
    unint64_t v40 = v25 - (void)v22 - 5;
    if (v40 < 8)
    {
      unint64_t v43 = 0;
LABEL_88:
      unint64_t v147 = v40 & 7;
      if (v147)
      {
        unint64_t v148 = v43 | v147;
        while (v38[v43] == *v39)
        {
          ++v39;
          ++v43;
          if (!--v147)
          {
            unint64_t v43 = v148;
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v41 = 0;
      unint64_t v42 = v40 >> 3;
      unint64_t v43 = v40 & 0xFFFFFFFFFFFFFFF8;
      while (1)
      {
        uint64_t v44 = *(void *)&v39[v41];
        uint64_t v45 = *(void *)&v38[v41];
        if (v44 != v45) {
          break;
        }
        v41 += 8;
        if (!--v42)
        {
          v39 += v40 & 0xFFFFFFFFFFFFFFF8;
          goto LABEL_88;
        }
      }
      unint64_t v43 = v41 + (__clz(__rbit64(v45 ^ v44)) >> 3);
    }
    unint64_t v46 = v22 - v23;
    if ((unint64_t)(v22 - v23) >> 1 <= 0xC20)
    {
      if (v46 > 5)
      {
        if (v46 > 0x81)
        {
          if (v46 > 0x841)
          {
            uint64_t v62 = a6[61];
            unint64_t v63 = *a10;
            unint64_t result = *a10 & 7;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 122) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v64 = v63 + v62;
            *a10 = v64;
            *(void *)(a11 + (v64 >> 3)) = ((v46 - 2114) << (v64 & 7)) | *(unsigned __int8 *)(a11 + (v64 >> 3));
            unint64_t v50 = v64 + 12;
            *a10 = v50;
            uint64_t v51 = &__dst[61];
          }
          else
          {
            uint64_t v58 = __clz(v46 - 66) ^ 0x1F;
            uint64_t v59 = a6[v58 + 50];
            unint64_t v60 = *a10;
            unint64_t v25 = (unint64_t)v202;
            *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v58 + 50)) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
            unint64_t v61 = v60 + v59;
            *a10 = v61;
            unint64_t result = *(unsigned __int8 *)(a11 + (v61 >> 3));
            *(void *)(a11 + (v61 >> 3)) = (((-1 << v58) + v46 - 66) << (v61 & 7)) | result;
            unint64_t v50 = v61 + v58;
            *a10 = v61 + v58;
            uint64_t v51 = &__dst[v58 + 50];
          }
        }
        else
        {
          uint64_t v52 = (__clz(v46 - 2) ^ 0x1F) - 1;
          unint64_t v53 = (v46 - 2) >> v52;
          uint64_t v54 = (2 * v52) + v53 + 42;
          uint64_t v55 = a6[v54];
          unint64_t v56 = *a10;
          unint64_t v25 = (unint64_t)v202;
          *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v54) << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
          unint64_t v57 = v56 + v55;
          *a10 = v57;
          unint64_t result = *(unsigned __int8 *)(a11 + (v57 >> 3));
          *(void *)(a11 + (v57 >> 3)) = ((v46 - 2 - (v53 << v52)) << (v57 & 7)) | result;
          unint64_t v50 = v57 + v52;
          *a10 = v57 + v52;
          uint64_t v51 = &__dst[v54];
        }
      }
      else
      {
        uint64_t v47 = a6[v46 + 40];
        unint64_t v48 = *a10;
        unint64_t v49 = *a10 >> 3;
        unint64_t result = *(unsigned __int8 *)(a11 + v49);
        *(void *)(a11 + v49) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v46 + 40)) << (*(unsigned char *)a10 & 7)) | result;
        unint64_t v50 = v48 + v47;
        *a10 = v50;
        uint64_t v51 = &__dst[v46 + 40];
      }
LABEL_43:
      ++*v51;
      if (v22 != v23)
      {
        if (v46 <= 1) {
          unint64_t v46 = 1;
        }
        do
        {
          int v65 = *v23++;
          uint64_t v66 = v204[v65];
          unint64_t result = v50 & 7;
          *(void *)(a11 + (v50 >> 3)) = ((unint64_t)(unsigned __int16)v203[v65] << (v50 & 7)) | *(unsigned __int8 *)(a11 + (v50 >> 3));
          v50 += v66;
          *a10 = v50;
          --v46;
        }
        while (v46);
      }
      unint64_t v67 = v50 >> 3;
      if (v29 == v37)
      {
        uint64_t v68 = a6[64];
        *(void *)(a11 + v67) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        unint64_t v69 = v50 + v68;
        uint64_t v70 = &__dst[64];
      }
      else
      {
        unint64_t v71 = v37 + 3;
        unsigned int v72 = __clz(v71) ^ 0x1F;
        uint64_t v73 = v72 - 1;
        uint64_t v74 = (v71 >> (v72 - 1)) & 1 | 2;
        uint64_t v75 = ((2 * v72 - 4) & 0xFFFFFFFE | (v71 >> (v72 - 1)) & 1) + 80;
        uint64_t v76 = a6[v75];
        unint64_t result = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v75) << (v50 & 7)) | *(unsigned __int8 *)(a11 + v67);
        *(void *)(a11 + v67) = result;
        *a10 = v50 + v76;
        *(void *)(a11 + ((v50 + v76) >> 3)) = ((v71 - (v74 << v73)) << ((v50 + v76) & 7)) | *(unsigned __int8 *)(a11 + ((v50 + v76) >> 3));
        unint64_t v69 = v50 + v76 + v73;
        uint64_t v70 = &__dst[v75];
        int v29 = v37;
      }
      unint64_t v77 = v43 + 5;
      ++*v70;
      *a10 = v69;
      if (v43 + 5 > 0xB)
      {
        if (v77 > 0x47)
        {
          if (v77 > 0x87)
          {
            if (v77 > 0x847)
            {
              uint64_t v98 = a6[39];
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
              unint64_t v99 = v69 + v98;
              *a10 = v99;
              char v100 = v99 & 7;
              *(void *)(a11 + (v99 >> 3)) = ((v43 - 2115) << (v99 & 7)) | *(unsigned __int8 *)(a11 + (v99 >> 3));
              unint64_t v101 = v99 + 24;
              *a10 = v99 + 24;
              uint64_t v102 = a6[64];
              *(void *)(a11 + (v101 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << v100) | *(unsigned __int8 *)(a11 + (v101 >> 3));
              *a10 = v101 + v102;
              ++__dst[39];
            }
            else
            {
              unint64_t v92 = v43 - 67;
              uint64_t v93 = __clz(v92) ^ 0x1F;
              uint64_t v94 = a6[v93 + 28];
              unint64_t result = *(unsigned __int8 *)(a11 + (v69 >> 3));
              *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v93 + 28)) << (v69 & 7)) | result;
              unint64_t v95 = v69 + v94;
              *a10 = v95;
              *(void *)(a11 + (v95 >> 3)) = (((-1 << v93) + v92) << (v95 & 7)) | *(unsigned __int8 *)(a11 + (v95 >> 3));
              unint64_t v96 = v95 + v93;
              *a10 = v95 + v93;
              uint64_t v97 = a6[64];
              *(void *)(a11 + (v96 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v96 & 7)) | *(unsigned __int8 *)(a11 + (v96 >> 3));
              *a10 = v96 + v97;
              ++__dst[v93 + 28];
            }
          }
          else
          {
            unint64_t v86 = v43 - 3;
            uint64_t v87 = (v86 >> 5) + 30;
            uint64_t v88 = a6[v87];
            unint64_t result = v69 & 7;
            *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v87) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
            unint64_t v89 = v69 + v88;
            *a10 = v89;
            *(void *)(a11 + (v89 >> 3)) = ((v86 & 0x1F) << (v89 & 7)) | *(unsigned __int8 *)(a11 + (v89 >> 3));
            unint64_t v90 = v89 + 5;
            *a10 = v89 + 5;
            uint64_t v91 = a6[64];
            *(void *)(a11 + (v90 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 128) << (v90 & 7)) | *(unsigned __int8 *)(a11 + (v90 >> 3));
            *a10 = v90 + v91;
            ++__dst[v87];
          }
          double v80 = &__dst[64];
        }
        else
        {
          unint64_t v81 = v43 - 3;
          uint64_t v82 = (__clz(v81) ^ 0x1F) - 1;
          uint64_t v83 = (2 * v82) + (v81 >> v82) + 4;
          uint64_t v84 = a6[v83];
          unint64_t result = v69 >> 3;
          *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v83) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
          unint64_t v85 = v69 + v84;
          *a10 = v85;
          *(void *)(a11 + (v85 >> 3)) = ((v81 - (v81 >> v82 << v82)) << (v85 & 7)) | *(unsigned __int8 *)(a11 + (v85 >> 3));
          *a10 = v85 + v82;
          double v80 = &__dst[v83];
        }
      }
      else
      {
        unint64_t v78 = v43 + 1;
        uint64_t v79 = a6[v78];
        *(void *)(a11 + (v69 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v78) << (v69 & 7)) | *(unsigned __int8 *)(a11 + (v69 >> 3));
        *a10 = v69 + v79;
        double v80 = &__dst[v78];
      }
      v22 += v77;
      ++*v80;
      if (v22 >= v28)
      {
LABEL_98:
        unint64_t v23 = v22;
LABEL_99:
        unint64_t v24 = v200;
        goto LABEL_100;
      }
      unint64_t v103 = *(void *)(v22 - 3);
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v103) >> 47) & 0x1FFFC)) = v22 - a2 - 3;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 8)) >> 47) & 0x1FFFC)) = v22 - a2 - 2;
      *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v103 >> 16)) >> 47) & 0x1FFFC)) = v22 - a2 - 1;
      unint64_t v104 = ((0x1E35A7BD000000 * (v103 >> 24)) >> 47) & 0x1FFFC;
      uint64_t v105 = *(int *)(a5 + v104);
      *(_DWORD *)(a5 + v104) = v22 - a2;
      char v106 = &a2[v105];
      unint64_t v23 = v22;
      if (*(_DWORD *)v22 == *(_DWORD *)&a2[v105])
      {
        while (1)
        {
          unint64_t v23 = v22;
          if (v22[4] != v106[4]) {
            break;
          }
          uint64_t v107 = v106 + 5;
          unsigned int v108 = v22 + 5;
          unint64_t v109 = v25 - (void)v22 - 5;
          if (v109 < 8)
          {
            unint64_t v112 = 0;
LABEL_81:
            unint64_t v145 = v109 & 7;
            if (v145)
            {
              unint64_t v146 = v112 | v145;
              while (v107[v112] == *v108)
              {
                ++v108;
                ++v112;
                if (!--v145)
                {
                  unint64_t v112 = v146;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v110 = 0;
            unint64_t v111 = v109 >> 3;
            unint64_t v112 = v109 & 0xFFFFFFFFFFFFFFF8;
            while (1)
            {
              unint64_t result = *(void *)&v108[v110];
              uint64_t v113 = *(void *)&v107[v110];
              if (result != v113) {
                break;
              }
              v110 += 8;
              if (!--v111)
              {
                v108 += v109 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_81;
              }
            }
            unint64_t v112 = v110 + (__clz(__rbit64(v113 ^ result)) >> 3);
          }
          uint64_t v114 = v22 - v106;
          if (v114 <= 262128)
          {
            unint64_t v115 = v112 + 5;
            if (v112 + 5 > 9)
            {
              if (v115 > 0x85)
              {
                if (v115 > 0x845)
                {
                  uint64_t v132 = a6[39];
                  unint64_t v133 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 78) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v134 = v133 + v132;
                  *a10 = v134;
                  *(void *)(a11 + (v134 >> 3)) = ((v112 - 2113) << (v134 & 7)) | *(unsigned __int8 *)(a11 + (v134 >> 3));
                  unint64_t v119 = v134 + 24;
                  *a10 = v134 + 24;
                  int v120 = &__dst[39];
                }
                else
                {
                  unint64_t v127 = v112 - 65;
                  uint64_t v128 = __clz(v127) ^ 0x1F;
                  uint64_t v129 = a6[v128 + 28];
                  unint64_t v130 = *a10;
                  *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * (v128 + 28)) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                  unint64_t v131 = v130 + v129;
                  *a10 = v131;
                  *(void *)(a11 + (v131 >> 3)) = (((-1 << v128) + v127) << (v131 & 7)) | *(unsigned __int8 *)(a11 + (v131 >> 3));
                  unint64_t v119 = v131 + v128;
                  *a10 = v131 + v128;
                  int v120 = &__dst[v128 + 28];
                }
              }
              else
              {
                unint64_t v121 = v112 - 1;
                uint64_t v122 = (__clz(v121) ^ 0x1F) - 1;
                uint64_t v123 = (2 * v122) + (v121 >> v122) + 20;
                uint64_t v124 = a6[v123];
                unint64_t v125 = *a10;
                *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v123) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
                unint64_t v126 = v125 + v124;
                *a10 = v126;
                *(void *)(a11 + (v126 >> 3)) = ((v121 - (v121 >> v122 << v122)) << (v126 & 7)) | *(unsigned __int8 *)(a11 + (v126 >> 3));
                unint64_t v119 = v126 + v122;
                *a10 = v126 + v122;
                int v120 = &__dst[v123];
              }
            }
            else
            {
              unint64_t v116 = v112 + 19;
              uint64_t v117 = a6[v112 + 19];
              unint64_t v118 = *a10;
              *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v116) << (*(unsigned char *)a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
              unint64_t v119 = v118 + v117;
              *a10 = v119;
              int v120 = &__dst[v116];
            }
            v22 += v115;
            ++*v120;
            unint64_t v135 = (int)v114 + 3;
            unsigned int v136 = __clz(v135) ^ 0x1F;
            uint64_t v137 = v136 - 1;
            uint64_t v138 = (v135 >> (v136 - 1)) & 1 | 2;
            uint64_t v139 = ((2 * v136 - 4) & 0xFFFFFFFE | (v135 >> (v136 - 1)) & 1) + 80;
            uint64_t v140 = a6[v139];
            unint64_t result = *(unsigned __int8 *)(a11 + (v119 >> 3));
            *(void *)(a11 + (v119 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v139) << (v119 & 7)) | result;
            unint64_t v141 = v119 + v140;
            *a10 = v141;
            *(void *)(a11 + (v141 >> 3)) = ((v135 - (v138 << v137)) << (v141 & 7)) | *(unsigned __int8 *)(a11 + (v141 >> 3));
            *a10 = v141 + v137;
            ++__dst[v139];
            if (v22 >= v28) {
              goto LABEL_98;
            }
            int v29 = v114;
            unint64_t v142 = *(void *)(v22 - 3);
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * v142) >> 47) & 0x1FFFC)) = v22 - a2 - 3;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 8)) >> 47) & 0x1FFFC)) = v22 - a2 - 2;
            *(_DWORD *)(a5 + (((0x1E35A7BD000000 * (v142 >> 16)) >> 47) & 0x1FFFC)) = v22 - a2 - 1;
            unint64_t v143 = ((0x1E35A7BD000000 * (v142 >> 24)) >> 47) & 0x1FFFC;
            uint64_t v144 = *(int *)(a5 + v143);
            *(_DWORD *)(a5 + v143) = v22 - a2;
            char v106 = &a2[v144];
            if (*(_DWORD *)v22 == *(_DWORD *)&a2[v144]) {
              continue;
            }
          }
          unint64_t v23 = v22;
          goto LABEL_16;
        }
      }
      continue;
    }
    break;
  }
  if (50 * (v23 - v194) > v46 || v192 < 0x3D5)
  {
    if (v46 > 0x5841)
    {
      uint64_t v152 = a6[63];
      unint64_t v153 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 126) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v154 = v153 + v152;
      *a10 = v154;
      *(void *)(a11 + (v154 >> 3)) = ((v46 - 22594) << (v154 & 7)) | *(unsigned __int8 *)(a11 + (v154 >> 3));
      unint64_t v50 = v154 + 24;
      *a10 = v50;
      uint64_t v51 = &__dst[63];
    }
    else
    {
      uint64_t v149 = a6[62];
      unint64_t v150 = *a10;
      unint64_t result = *a10 & 7;
      *(void *)(a11 + (*a10 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 124) << result) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      unint64_t v151 = v150 + v149;
      *a10 = v151;
      *(void *)(a11 + (v151 >> 3)) = ((v46 - 6210) << (v151 & 7)) | *(unsigned __int8 *)(a11 + (v151 >> 3));
      unint64_t v50 = v151 + 14;
      *a10 = v50;
      uint64_t v51 = &__dst[62];
    }
    goto LABEL_43;
  }
  unint64_t result = (unint64_t)EmitUncompressedMetaBlock(v194, (uint64_t)v22, v195, a10, a11);
  unint64_t v162 = &v196[v199] - v22;
  if (v162) {
    goto LABEL_125;
  }
LABEL_141:
  if (!a4)
  {
    *a9 = 0;
    *a8 = 0;
    return BuildAndStoreCommandPrefixCode((uint64_t)__dst, (uint64_t)a6, (_OWORD *)a7, a8, (uint64_t)a9);
  }
  return result;
}

void *EmitUncompressedMetaBlock(const void *a1, uint64_t a2, unint64_t a3, unint64_t *a4, uint64_t a5)
{
  size_t v8 = a2 - (void)a1;
  *(unsigned char *)(a5 + (a3 >> 3)) &= ~(-1 << (a3 & 7));
  *a4 = a3;
  BrotliStoreMetaBlockHeader(a2 - (void)a1, 1u, a4, a5);
  unint64_t v9 = (*(_DWORD *)a4 + 7) & 0xFFFFFFF8;
  *a4 = v9;
  unint64_t result = memcpy((void *)(a5 + (v9 >> 3)), a1, v8);
  unint64_t v11 = *a4 + 8 * v8;
  *a4 = v11;
  *(unsigned char *)(a5 + (v11 >> 3)) = 0;
  return result;
}

unint64_t BrotliStoreMetaBlockHeader(unint64_t result, unsigned int a2, unint64_t *a3, uint64_t a4)
{
  unint64_t v4 = *a3;
  *(void *)(a4 + (*a3 >> 3)) = *(unsigned __int8 *)(a4 + (*a3 >> 3));
  *a3 = v4 + 1;
  uint64_t v5 = 5;
  if (result >= 0x100001) {
    uint64_t v5 = 6;
  }
  if (result <= 0x10000) {
    uint64_t v5 = 4;
  }
  *(void *)(a4 + ((v4 + 1) >> 3)) = ((v5 - 4) << ((v4 + 1) & 7)) | *(unsigned __int8 *)(a4 + ((v4 + 1) >> 3));
  unint64_t v6 = v4 + 3;
  *a3 = v6;
  *(void *)(a4 + (v6 >> 3)) = ((result - 1) << (v6 & 7)) | *(unsigned __int8 *)(a4 + (v6 >> 3));
  unint64_t v7 = v6 + 4 * v5;
  *a3 = v7;
  *(void *)(a4 + (v7 >> 3)) = ((unint64_t)a2 << (v7 & 7)) | *(unsigned __int8 *)(a4 + (v7 >> 3));
  *a3 = v7 + 1;
  return result;
}

unint64_t BuildAndStoreLiteralPrefixCode(unint64_t a1, unsigned __int8 *a2, unint64_t a3, unsigned char *a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  bzero(v35, 0x400uLL);
  if (a3 >= 0x8000)
  {
    unint64_t v23 = 0;
    do
    {
      ++v35[a2[v23]];
      v23 += 29;
    }
    while (v23 < a3);
    uint64_t v24 = 0;
    uint64_t v25 = ((a3 + 28) * (unsigned __int128)0x1A7B9611A7B9611BuLL) >> 64;
    int64x2_t v17 = 0uLL;
    int64x2_t v18 = (int64x2_t)((v25 + ((a3 + 28 - v25) >> 1)) >> 4);
    v26.i64[0] = 0xB0000000BLL;
    v26.i64[1] = 0xB0000000BLL;
    do
    {
      int32x4_t v27 = *(int32x4_t *)&v35[v24];
      int32x4_t v28 = (int32x4_t)vminq_u32((uint32x4_t)v27, v26);
      unsigned long long v29 = *(_OWORD *)&vaddq_s32(v28, v28) | __PAIR128__(0x100000001, 0x100000001);
      *(int32x4_t *)&v35[v24] = vaddq_s32((int32x4_t)v29, v27);
      int64x2_t v17 = (int64x2_t)vaddw_high_u32((uint64x2_t)v17, (uint32x4_t)v29);
      int64x2_t v18 = (int64x2_t)vaddw_u32((uint64x2_t)v18, *(uint32x2_t *)&v29);
      v24 += 4;
    }
    while (v24 != 256);
  }
  else
  {
    if (a3)
    {
      unint64_t v14 = a3;
      do
      {
        int v15 = *a2++;
        ++v35[v15];
        --v14;
      }
      while (v14);
    }
    uint64_t v16 = 0;
    int64x2_t v17 = 0uLL;
    int64x2_t v18 = (int64x2_t)a3;
    v19.i64[0] = 0xB0000000BLL;
    v19.i64[1] = 0xB0000000BLL;
    do
    {
      int32x4_t v20 = *(int32x4_t *)&v35[v16];
      int32x4_t v21 = (int32x4_t)vminq_u32((uint32x4_t)v20, v19);
      int32x4_t v22 = vaddq_s32(v21, v21);
      *(int32x4_t *)&v35[v16] = vaddq_s32(v22, v20);
      int64x2_t v17 = (int64x2_t)vaddw_high_u32((uint64x2_t)v17, (uint32x4_t)v22);
      int64x2_t v18 = (int64x2_t)vaddw_u32((uint64x2_t)v18, *(uint32x2_t *)v22.i8);
      v16 += 4;
    }
    while (v16 != 256);
  }
  unint64_t v30 = vaddvq_s64(vaddq_s64(v18, v17));
  BrotliBuildAndStoreHuffmanTreeFast(a1, (uint64_t)v35, v30, 8, a4, a5, a6, a7);
  if (*(_DWORD *)(a1 + 24)) {
    return 0;
  }
  uint64_t v32 = 0;
  for (uint64_t i = 0; i != 256; ++i)
  {
    int v34 = v35[i];
    if (v34) {
      v32 += v34 * a4[i];
    }
  }
  return 125 * v32 / v30;
}

BOOL ShouldMergeBlock(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v16[256] = *MEMORY[0x263EF8340];
  bzero(v16, 0x800uLL);
  unint64_t v7 = 0;
  if (!a2) {
    goto LABEL_4;
  }
  do
  {
    ++v16[*(unsigned __int8 *)(a1 + v7)];
    v7 += 43;
  }
  while (v7 < a2);
  unint64_t v7 = (a2 + 42) / 0x2B;
  if ((a2 + 42) >> 8 > 0x2A)
  {
    double v9 = (double)v7;
    double v8 = log2((double)v7);
  }
  else
  {
LABEL_4:
    double v8 = kBrotliLog2Table[v7];
    double v9 = (double)v7;
  }
  uint64_t v10 = 0;
  double v11 = (v8 + 0.5) * v9 + 200.0;
  do
  {
    unint64_t v12 = v16[v10];
    double v13 = (double)v12;
    LOBYTE(v3) = *(unsigned char *)(a3 + v10);
    if (v12 > 0xFF) {
      double v14 = log2((double)v12);
    }
    else {
      double v14 = kBrotliLog2Table[v12];
    }
    double v11 = v11 - v13 * (v14 + (double)v3);
    ++v10;
  }
  while (v10 != 256);
  return v11 >= 0.0;
}

uint64_t UpdateBits(uint64_t result, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = 20;
  do
  {
    unint64_t v4 = 8 - (a2 & 7);
    if (v3 < v4) {
      unint64_t v4 = v3;
    }
    *(unsigned char *)(a3 + (a2 >> 3)) = ((-1 << (v4 + (a2 & 7))) | ~(-1 << (a2 & 7))) & *(unsigned char *)(a3 + (a2 >> 3)) | ((result & ~(-1 << v4)) << (a2 & 7));
    unint64_t result = result >> v4;
    a2 += v4;
    v3 -= v4;
  }
  while (v3);
  return result;
}

unint64_t BuildAndStoreCommandPrefixCode(uint64_t a1, uint64_t a2, _OWORD *a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  bzero(v34, 0x280uLL);
  BrotliCreateHuffmanTree(a1, 64, 15, (uint64_t)v35, a2);
  BrotliCreateHuffmanTree(a1 + 256, 64, 14, (uint64_t)v35, a2 + 64);
  *(_OWORD *)unint64_t v30 = *(_OWORD *)a2;
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v11 = *(void *)(a2 + 40);
  *(void *)&v30[16] = *(void *)(a2 + 16);
  *(void *)&long long v31 = v11;
  uint64_t v13 = *(void *)(a2 + 48);
  *((void *)&v31 + 1) = v10;
  *(void *)&long long v32 = v13;
  int v15 = (char *)(a2 + 56);
  uint64_t v14 = *(void *)(a2 + 56);
  *((void *)&v32 + 1) = v12;
  uint64_t v33 = v14;
  BrotliConvertBitDepthsToSymbols(v30, 64, (uint64_t)v29);
  long long v16 = v29[1];
  *a3 = v29[0];
  a3[1] = v16;
  long long v17 = v29[3];
  long long v18 = v29[4];
  long long v19 = v29[5];
  a3[2] = v29[2];
  a3[3] = v18;
  long long v20 = v29[7];
  a3[4] = v29[6];
  a3[5] = v17;
  a3[6] = v19;
  a3[7] = v20;
  BrotliConvertBitDepthsToSymbols((unsigned __int8 *)(a2 + 64), 64, (uint64_t)(a3 + 8));
  long long v32 = 0u;
  long long v31 = 0u;
  *(_OWORD *)&v30[8] = 0u;
  uint64_t v21 = *(void *)a2;
  uint64_t v22 = *(void *)(a2 + 8);
  uint64_t v33 = 0;
  v34[0] = v22;
  *(void *)unint64_t v30 = v21;
  uint64_t v23 = *(void *)(a2 + 24);
  v34[8] = *(void *)(a2 + 16);
  uint64_t v24 = *(void *)(a2 + 32);
  uint64_t v25 = 256;
  v34[16] = v23;
  v34[40] = v24;
  do
  {
    uint32x4_t v26 = &v30[v25];
    *(v26 - 128) = *(v15 - 16);
    unsigned char *v26 = *(v15 - 8);
    char v27 = *v15++;
    v26[192] = v27;
    v25 += 8;
  }
  while (v25 != 320);
  BrotliStoreHuffmanTree((uint64_t)v30, 0x2C0uLL, (uint64_t)v35, a4, a5);
  return BrotliStoreHuffmanTree(a2 + 64, 0x40uLL, (uint64_t)v35, a4, a5);
}

uint64_t BrotliInitMemoryManager(uint64_t result, void *(*a2)(int a1, size_t __size), void (*a3)(int a1, void *a2), uint64_t a4)
{
  if (a2) {
    unint64_t v4 = a2;
  }
  else {
    unint64_t v4 = BrotliDefaultAllocFunc;
  }
  if (a2) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = BrotliDefaultFreeFunc;
  }
  *(void *)unint64_t result = v4;
  *(void *)(result + 8) = v5;
  if (a2) {
    uint64_t v6 = a4;
  }
  else {
    uint64_t v6 = 0;
  }
  *(void *)(result + 16) = v6;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  *(void *)(result + 32) = 0;
  return result;
}

uint64_t BrotliAllocate(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))a1)(*(void *)(a1 + 16));
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3 == 64)
    {
      CollectGarbagePointers((unint64_t *)a1);
      uint64_t v3 = *(void *)(a1 + 40);
    }
    *(void *)(a1 + 40) = v3 + 1;
    *(void *)(a1 + 8 * v3 + 1080) = v2;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = 1;
  }
  return v2;
}

uint64_t CollectGarbagePointers(unint64_t *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 7);
  uint64_t v3 = a1 + 135;
  SortPointers((uint64_t)(a1 + 135), a1[5]);
  SortPointers((uint64_t)(a1 + 199), a1[6]);
  uint64_t result = Annihilate((uint64_t)v3, a1[5], (uint64_t)(a1 + 199), a1[6]);
  unint64_t v5 = a1[6];
  unint64_t v6 = a1[5] - result;
  a1[5] = v6;
  a1[6] = v5 - result;
  if (v5 != result)
  {
    uint64_t result = Annihilate(v2, a1[4], (uint64_t)(a1 + 199), v5 - result);
    unint64_t v6 = a1[5];
    a1[4] -= result;
    a1[6] -= result;
  }
  if (v6)
  {
    memcpy((void *)(v2 + 8 * a1[4]), v3, 8 * v6);
    unint64_t v7 = a1[4] + a1[5];
    a1[4] = v7;
    a1[5] = 0;
    return SortPointers(v2, v7);
  }
  return result;
}

uint64_t BrotliWipeOutMemoryManager(uint64_t a1)
{
  uint64_t result = CollectGarbagePointers((unint64_t *)a1);
  if (*(void *)(a1 + 32))
  {
    unint64_t v3 = 0;
    do
      uint64_t result = (*(uint64_t (**)(void, void))(a1 + 8))(*(void *)(a1 + 16), *(void *)(a1 + 56 + 8 * v3++));
    while (v3 < *(void *)(a1 + 32));
  }
  *(void *)(a1 + 32) = 0;
  return result;
}

uint64_t SortPointers(uint64_t result, unint64_t a2)
{
  for (uint64_t i = 0; i != 4; ++i)
  {
    unint64_t v3 = SortPointers_gaps[i];
    if (v3 < a2)
    {
      uint64_t v4 = result + 8 * v3;
      uint64_t v5 = result;
      unint64_t v6 = SortPointers_gaps[i];
      do
      {
        unint64_t v7 = *(void *)(result + 8 * v6);
        unint64_t v8 = v6;
        if (v6 >= v3)
        {
          uint64_t v9 = 0;
          while (1)
          {
            unint64_t v10 = *(void *)(v5 + 8 * v9);
            if (v7 >= v10) {
              break;
            }
            *(void *)(v4 + 8 * v9) = v10;
            v9 -= v3;
            unint64_t v8 = v6 + v9;
            if (v6 + v9 < v3) {
              goto LABEL_10;
            }
          }
          unint64_t v8 = v6 + v9;
        }
LABEL_10:
        *(void *)(result + 8 * v8) = v7;
        ++v6;
        v4 += 8;
        v5 += 8;
      }
      while (v6 != a2);
    }
  }
  return result;
}

uint64_t Annihilate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v5 = 0;
  unint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = 0;
  if (a2 && a4)
  {
    uint64_t result = 0;
    uint64_t v8 = 0;
    uint64_t v7 = 0;
    unint64_t v6 = 0;
    unint64_t v5 = 0;
    do
    {
      unint64_t v10 = *(void *)(a1 + 8 * v5);
      unint64_t v11 = *(void *)(a3 + 8 * v6);
      if (v10 == v11)
      {
        ++v5;
        ++v6;
        ++result;
      }
      else if (v10 >= v11)
      {
        ++v6;
        *(void *)(a3 + 8 * v8++) = v11;
      }
      else
      {
        ++v5;
        *(void *)(a1 + 8 * v7++) = v10;
      }
    }
    while (v5 < a2 && v6 < a4);
  }
  unint64_t v12 = a2 - v5;
  if (a2 > v5)
  {
    uint64_t v13 = (void *)(a1 + 8 * v7);
    uint64_t v14 = (uint64_t *)(a1 + 8 * v5);
    do
    {
      uint64_t v15 = *v14++;
      *v13++ = v15;
      --v12;
    }
    while (v12);
  }
  unint64_t v16 = a4 - v6;
  if (a4 > v6)
  {
    long long v17 = (void *)(a3 + 8 * v8);
    long long v18 = (uint64_t *)(a3 + 8 * v6);
    do
    {
      uint64_t v19 = *v18++;
      *v17++ = v19;
      --v16;
    }
    while (v16);
  }
  return result;
}

uint64_t cosl_model_update(uint64_t result, uint64_t a2, uint64_t a3)
{
  char v3 = 1;
  do
  {
    char v4 = v3;
    if (a3)
    {
      uint64_t v5 = 0;
      unsigned int v6 = 0;
      unsigned int v7 = 0;
      int v8 = 0;
      unsigned int v9 = 0;
      uint64_t v10 = *(void *)(result + 0x80000);
      unsigned int v11 = 32;
      int v12 = 32 - *(_DWORD *)(result + 524296);
      do
      {
        unsigned int v13 = v11 << 8;
        unsigned int v11 = *(unsigned __int8 *)(a2 + v5);
        uint64_t v14 = result + 8 * v13;
        uint64_t v15 = v10 + 8 * (v9 >> v12);
        uint64_t v16 = v10 + 8 * (v7 >> v12);
        unsigned int v17 = 1;
        int v18 = 7;
        uint64_t v19 = v10 + 8 * (v6 >> v12);
        do
        {
          int v20 = (v11 >> v18) & 1;
          uint64_t v21 = v17;
          uint64_t v22 = (unsigned int *)(v14 + 8 * v17);
          if (v4)
          {
            uint64_t v23 = v14 + 8 * v21;
            unsigned int v26 = *(_DWORD *)(v23 + 4);
            uint64_t v24 = (_DWORD *)(v23 + 4);
            unsigned int v25 = v26;
            unsigned int v27 = *v22;
            if (v26 >= 0xFFFF0000)
            {
              v25 -= v25 >> 1;
              unsigned int v27 = v27 - (v27 >> 1) - (v27 - (v27 >> 1) == v25);
            }
            unsigned int *v22 = v27 + v20;
            *uint64_t v24 = v25 + 1;
            int32x4_t v28 = (int *)(v15 + 8 * v21);
            unsigned int v29 = v28[1];
            unsigned int v30 = v29 - (v29 >> 1);
            int v31 = *v28 - (*v28 >> 1) - (*v28 - (*v28 >> 1) == v30);
            if (v29 < 0xFFFF0000)
            {
              unsigned int v30 = v28[1];
              int v31 = *v28;
            }
            *int32x4_t v28 = v31 + v20;
            v28[1] = v30 + 1;
            long long v32 = (unsigned int *)(v16 + 8 * v21);
            unsigned int v33 = v32[1];
            unsigned int v34 = *v32;
            unsigned int v35 = v33 - (v33 >> 1);
            BOOL v36 = __CFADD__(v33, 0x10000);
            if (v33 >= 0xFFFF0000) {
              v33 -= v33 >> 1;
            }
            if (v36) {
              unsigned int v34 = v34 - (v34 >> 1) - (v34 - (v34 >> 1) == v35);
            }
            *long long v32 = v34 + v20;
            v32[1] = v33 + 1;
            int v37 = (unsigned int *)(v19 + 8 * v21);
            unsigned int v39 = v37 + 1;
            unsigned int v38 = v37[1];
            if (v38 >= 0xFFFF0000) {
              unsigned int v40 = *v37 - (*v37 >> 1) - (*v37 - (*v37 >> 1) == v38 - (v38 >> 1));
            }
            else {
              unsigned int v40 = *v37;
            }
            if (v38 >= 0xFFFF0000) {
              unsigned int v41 = v38 - (v38 >> 1);
            }
            else {
              unsigned int v41 = v37[1];
            }
          }
          else
          {
            unint64_t v42 = *(unsigned int *)(v14 + 8 * v21 + 4);
            int v37 = (unsigned int *)(result
                                 + ((unint64_t)counter_get_quantizer[((((unint64_t)*v22 << 16)
                                                                                          + (v42 >> 1))
                                                                                         / v42) >> 10] << 15)
                                 + ((unint64_t)counter_get_quantizer[((((unint64_t)*(unsigned int *)(v15 + 8 * v21) << 16)
                                                                                          + ((unint64_t)*(unsigned int *)(v15 + 8 * v21 + 4) >> 1))
                                                                                         / *(unsigned int *)(v15 + 8 * v21 + 4)) >> 10] << 11)
                                 + ((unint64_t)counter_get_quantizer[((((unint64_t)*(unsigned int *)(v16 + 8 * v21) << 16)
                                                                                          + ((unint64_t)*(unsigned int *)(v16 + 8 * v21 + 4) >> 1))
                                                                                         / *(unsigned int *)(v16 + 8 * v21 + 4)) >> 10] << 7)
                                 + 8
                                 * counter_get_quantizer[((((unint64_t)*(unsigned int *)(v19 + 8 * v21) << 16)
                                                                       + ((unint64_t)*(unsigned int *)(v19 + 8 * v21 + 4) >> 1))
                                                                      / *(unsigned int *)(v19 + 8 * v21 + 4)) >> 10]
                                 + 524320);
            unsigned int v39 = v37 + 1;
            unsigned int v41 = v37[1];
            unsigned int v40 = *v37;
            if (v41 >= 0xFFFF0000)
            {
              v41 -= v41 >> 1;
              unsigned int v40 = v40 - (v40 >> 1) - (v40 - (v40 >> 1) == v41);
            }
          }
          *int v37 = v40 + v20;
          *unsigned int v39 = v41 + 1;
          unsigned int v17 = v20 | (2 * v21);
          --v18;
        }
        while (v18 != -1);
        if (v11 - 65 >= 0x1A) {
          unsigned __int8 v43 = v11;
        }
        else {
          unsigned __int8 v43 = v11 + 32;
        }
        BOOL v44 = ((v43 & 0xDF) - 91) >= 0xE6u || (char)v43 <= -1;
        int v45 = -1640531535 * (v6 + v43);
        if (v44) {
          unsigned int v6 = v45;
        }
        else {
          unsigned int v6 = 0;
        }
        unsigned int v7 = -1640531535 * (v8 + v11);
        int v8 = -1640531535 * (v9 + v11);
        unsigned int v9 = -1640531535 * (v13 | v11);
        ++v5;
      }
      while (v5 != a3);
    }
    char v3 = 0;
  }
  while ((v4 & 1) != 0);
  return result;
}

unint64_t cosl_codec_encode(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!a5) {
    return 0;
  }
  int v5 = 0;
  unint64_t v6 = 0;
  unint64_t v7 = 1;
  do
  {
    unint64_t v8 = v6;
    unint64_t v6 = v7;
    v7 += v8;
    ++v5;
  }
  while (a5 - v6 >= v7);
  unint64_t v9 = 1 << v5;
  if (v5)
  {
    unsigned int v10 = v5 - 1;
    unint64_t v11 = a5;
    do
    {
      uint64_t v12 = 1 << v10;
      if (v11 >= v7) {
        unint64_t v13 = v7;
      }
      else {
        unint64_t v13 = 0;
      }
      if (v11 < v7) {
        uint64_t v12 = 0;
      }
      v11 -= v13;
      v9 |= v12;
      unint64_t v14 = v7 - v6;
      unint64_t v7 = v6;
      unint64_t v6 = v14;
    }
    while ((unint64_t)v10--);
  }
  int v16 = 0;
  unint64_t v17 = 0;
  unint64_t v18 = a5 + ((73 - __clz(v9)) >> 3);
  unint64_t v19 = 1;
  do
  {
    unint64_t v20 = v17;
    unint64_t v17 = v19;
    v19 += v20;
    ++v16;
  }
  while (a5 - v17 >= v19);
  unint64_t v21 = 1 << v16;
  if (!v16) {
    goto LABEL_23;
  }
  unsigned int v22 = v16 - 1;
  unint64_t v23 = a5;
  do
  {
    uint64_t v24 = 1 << v22;
    if (v23 >= v19) {
      unint64_t v25 = v19;
    }
    else {
      unint64_t v25 = 0;
    }
    if (v23 < v19) {
      uint64_t v24 = 0;
    }
    v23 -= v25;
    v21 |= v24;
    unint64_t v26 = v19 - v17;
    unint64_t v19 = v17;
    unint64_t v17 = v26;
  }
  while ((unint64_t)v22--);
  if (!v21)
  {
    unint64_t v29 = 0;
    unsigned int v28 = 0;
    int v30 = -1;
  }
  else
  {
LABEL_23:
    unsigned int v28 = 0;
    unint64_t v29 = 0;
    int v30 = -1;
    do
    {
      int v31 = v28 + ((v30 - v28) >> 1);
      if (v21) {
        int v32 = v28;
      }
      else {
        int v32 = v31 + 1;
      }
      if ((v21 & 1) == 0) {
        int v31 = v30;
      }
      if ((v31 ^ v32) >> 24)
      {
        unsigned int v28 = v32;
        int v30 = v31;
      }
      else
      {
        do
        {
          unsigned int v28 = v32 << 8;
          if (v29 >= a3) {
            unint64_t v33 = 0;
          }
          else {
            unint64_t v33 = v29;
          }
          *(unsigned char *)(a2 + v33) = HIBYTE(v32);
          int v30 = (v31 << 8) | 0xFF;
          ++v29;
          unsigned int v34 = ((v31 << 8) ^ (v32 << 8)) >> 24;
          int v31 = v30;
          v32 <<= 8;
        }
        while (!v34);
      }
      BOOL v61 = v21 > 1;
      v21 >>= 1;
    }
    while (v61);
  }
  unsigned int v36 = v28 + ((v30 - v28) >> 1);
  if ((v36 ^ v28) >> 24)
  {
    unsigned int v37 = v28;
    unsigned int v39 = v36;
  }
  else
  {
    do
    {
      unsigned int v37 = v28 << 8;
      if (v29 >= a3) {
        unint64_t v38 = 0;
      }
      else {
        unint64_t v38 = v29;
      }
      *(unsigned char *)(a2 + v38) = HIBYTE(v28);
      unsigned int v39 = (v36 << 8) | 0xFF;
      ++v29;
      unsigned int v40 = ((v36 << 8) ^ (v28 << 8)) >> 24;
      unsigned int v36 = v39;
      v28 <<= 8;
    }
    while (!v40);
  }
  uint64_t v41 = 0;
  unsigned int v42 = 0;
  unsigned int v43 = 0;
  int v44 = 0;
  unsigned int v45 = 0;
  if (a5 <= 1) {
    uint64_t v46 = 1;
  }
  else {
    uint64_t v46 = a5;
  }
  unsigned int v47 = 32;
  do
  {
    unsigned int v48 = v47 << 8;
    unsigned int v47 = *(unsigned __int8 *)(a4 + v41);
    int v49 = -*(_DWORD *)(a1 + 16);
    unsigned int v50 = v45 >> v49;
    unsigned int v51 = v43 >> v49;
    unsigned int v52 = v42 >> v49;
    int v53 = 1;
    int v54 = 8;
    do
    {
      --v54;
      uint64_t v55 = *(void *)(a1 + 8);
      if ((v47 >> v54)) {
        unsigned int v56 = v37;
      }
      else {
        unsigned int v56 = v37
      }
            + ((*(unsigned __int8 *)(*(void *)(a1 + 40)
                                   + ((unint64_t)((*(unsigned __int8 *)(*(void *)a1
                                                                             + ((unint64_t)(v53 + v48) >> 1)) >> (4 * (v53 & 1))) & 0xF) << 12)
                                   + ((unint64_t)((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v50) >> 1)) >> (4 * ((v53 + v50) & 1))) & 0xF) << 8)
                                   + 16
                                   * ((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v51) >> 1)) >> (4 * ((v53 + v51) & 1))) & 0xF)
                                   + ((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v52) >> 1)) >> (4 * ((v53 + v52) & 1))) & 0xFLL))
              * (unint64_t)(v39 - v37)) >> 8)
            + 1;
      if ((v47 >> v54)) {
        unsigned int v57 = v37
      }
            + ((*(unsigned __int8 *)(*(void *)(a1 + 40)
                                   + ((unint64_t)((*(unsigned __int8 *)(*(void *)a1
                                                                             + ((unint64_t)(v53 + v48) >> 1)) >> (4 * (v53 & 1))) & 0xF) << 12)
                                   + ((unint64_t)((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v50) >> 1)) >> (4 * ((v53 + v50) & 1))) & 0xF) << 8)
                                   + 16
                                   * ((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v51) >> 1)) >> (4 * ((v53 + v51) & 1))) & 0xF)
                                   + ((*(unsigned __int8 *)(v55 + ((unint64_t)(v53 + v52) >> 1)) >> (4 * ((v53 + v52) & 1))) & 0xFLL))
              * (unint64_t)(v39 - v37)) >> 8);
      else {
        unsigned int v57 = v39;
      }
      if ((v57 ^ v56) >> 24)
      {
        unsigned int v37 = v56;
        unsigned int v39 = v57;
      }
      else
      {
        do
        {
          unsigned int v37 = v56 << 8;
          if (v29 >= a3) {
            unint64_t v58 = 0;
          }
          else {
            unint64_t v58 = v29;
          }
          *(unsigned char *)(a2 + v58) = HIBYTE(v56);
          unsigned int v39 = (v57 << 8) | 0xFF;
          ++v29;
          unsigned int v59 = ((v57 << 8) ^ (v56 << 8)) >> 24;
          unsigned int v57 = v39;
          v56 <<= 8;
        }
        while (!v59);
      }
      int v53 = (v47 >> v54) & 1 | (2 * v53);
    }
    while (v54);
    if (v47 - 65 >= 0x1A) {
      unsigned __int8 v60 = v47;
    }
    else {
      unsigned __int8 v60 = v47 + 32;
    }
    BOOL v61 = ((v60 & 0xDF) - 91) >= 0xE6u || (char)v60 <= -1;
    int v62 = -1640531535 * (v42 + v60);
    if (v61) {
      unsigned int v42 = v62;
    }
    else {
      unsigned int v42 = 0;
    }
    unsigned int v43 = -1640531535 * (v44 + v47);
    int v44 = -1640531535 * (v45 + v47);
    unsigned int v45 = -1640531535 * (v48 | v47);
    ++v41;
  }
  while (v41 != v46);
  while (1)
  {
    int v68 = HIBYTE(v37) + 1;
    if (v68 != HIBYTE(v39)) {
      break;
    }
    int v63 = v37 | 0xFFFFFF;
    unsigned int v64 = (v37 | 0xFFFFFF) - v37;
    if ((v39 & 0xFFFFFF) <= v64) {
      unsigned int v65 = v37;
    }
    else {
      unsigned int v65 = v39 & 0xFF000000;
    }
    if ((v39 & 0xFFFFFF) > v64) {
      int v63 = v39;
    }
    if ((v63 ^ v65) >> 24)
    {
      unsigned int v37 = v65;
      unsigned int v39 = v63;
    }
    else
    {
      do
      {
        unsigned int v37 = v65 << 8;
        if (v29 >= a3) {
          unint64_t v66 = 0;
        }
        else {
          unint64_t v66 = v29;
        }
        *(unsigned char *)(a2 + v66) = HIBYTE(v65);
        unsigned int v39 = (v63 << 8) | 0xFF;
        ++v29;
        unsigned int v67 = ((v63 << 8) ^ (v65 << 8)) >> 24;
        int v63 = v39;
        v65 <<= 8;
      }
      while (!v67);
    }
  }
  if (v29 >= a3) {
    unint64_t v69 = 0;
  }
  else {
    unint64_t v69 = v29;
  }
  *(unsigned char *)(a2 + v69) = v68;
  if (v29 + 1 <= a3) {
    unint64_t result = v29 + 1;
  }
  else {
    unint64_t result = 0;
  }
  if (result > v18)
  {
    int v70 = 0;
    unint64_t v71 = 0;
    unint64_t v72 = 1;
    do
    {
      unint64_t v73 = v71;
      unint64_t v71 = v72;
      v72 += v73;
      ++v70;
    }
    while (a5 - v71 >= v72);
    unint64_t v74 = 1 << v70;
    if (!v70) {
      goto LABEL_108;
    }
    unsigned int v75 = v70 - 1;
    do
    {
      uint64_t v76 = 1 << v75;
      if (a5 >= v72) {
        unint64_t v77 = v72;
      }
      else {
        unint64_t v77 = 0;
      }
      if (a5 < v72) {
        uint64_t v76 = 0;
      }
      a5 -= v77;
      v74 |= v76;
      unint64_t v78 = v72 - v71;
      unint64_t v72 = v71;
      unint64_t v71 = v78;
    }
    while ((unint64_t)v75--);
    if (!v74)
    {
      unint64_t v81 = 0;
      unsigned int v80 = 0;
      int v82 = -1;
    }
    else
    {
LABEL_108:
      unsigned int v80 = 0;
      unint64_t v81 = 0;
      int v82 = -1;
      do
      {
        if (v74) {
          unsigned int v83 = v80;
        }
        else {
          unsigned int v83 = v80 + ((v82 - v80) >> 1) + 1;
        }
        if (v74) {
          int v84 = v80 + ((v82 - v80) >> 1);
        }
        else {
          int v84 = v82;
        }
        if ((v84 ^ v83) >> 24)
        {
          unsigned int v80 = v83;
          int v82 = v84;
        }
        else
        {
          do
          {
            unsigned int v80 = v83 << 8;
            if (v81 >= a3) {
              unint64_t v85 = 0;
            }
            else {
              unint64_t v85 = v81;
            }
            *(unsigned char *)(a2 + v85) = HIBYTE(v83);
            int v82 = (v84 << 8) | 0xFF;
            ++v81;
            unsigned int v86 = ((v84 << 8) ^ (v83 << 8)) >> 24;
            int v84 = v82;
            v83 <<= 8;
          }
          while (!v86);
        }
        BOOL v61 = v74 > 1;
        v74 >>= 1;
      }
      while (v61);
    }
    unsigned int v87 = v80 + ((v82 - v80) >> 1) + 1;
    if ((v82 ^ v87) >> 24)
    {
      unsigned int v90 = v82;
      unsigned int v88 = v87;
    }
    else
    {
      do
      {
        unsigned int v88 = v87 << 8;
        if (v81 >= a3) {
          unint64_t v89 = 0;
        }
        else {
          unint64_t v89 = v81;
        }
        *(unsigned char *)(a2 + v89) = HIBYTE(v87);
        unsigned int v90 = (v82 << 8) | 0xFF;
        ++v81;
        unsigned int v91 = ((v82 << 8) ^ (v87 << 8)) >> 24;
        int v82 = v90;
        v87 <<= 8;
      }
      while (!v91);
    }
    for (uint64_t i = 0; i != v46; ++i)
    {
      unsigned int v93 = *(unsigned __int8 *)(a4 + i) | 0x100;
      do
      {
        if ((v93 & 0x80) != 0) {
          unsigned int v94 = v88;
        }
        else {
          unsigned int v94 = v88 + ((v90 - v88) >> 1) + 1;
        }
        if ((v93 & 0x80) != 0) {
          unsigned int v95 = v88 + ((v90 - v88) >> 1);
        }
        else {
          unsigned int v95 = v90;
        }
        if ((v95 ^ v94) >> 24)
        {
          unsigned int v88 = v94;
          unsigned int v90 = v95;
        }
        else
        {
          do
          {
            unsigned int v88 = v94 << 8;
            if (v81 >= a3) {
              unint64_t v96 = 0;
            }
            else {
              unint64_t v96 = v81;
            }
            *(unsigned char *)(a2 + v96) = HIBYTE(v94);
            unsigned int v90 = (v95 << 8) | 0xFF;
            ++v81;
            unsigned int v97 = ((v95 << 8) ^ (v94 << 8)) >> 24;
            unsigned int v95 = v90;
            v94 <<= 8;
          }
          while (!v97);
        }
        BOOL v98 = v93 >= 0x8000;
        v93 *= 2;
      }
      while (!v98);
    }
    while (1)
    {
      int v104 = HIBYTE(v88) + 1;
      if (v104 != HIBYTE(v90)) {
        break;
      }
      int v99 = v88 | 0xFFFFFF;
      unsigned int v100 = (v88 | 0xFFFFFF) - v88;
      if ((v90 & 0xFFFFFF) <= v100) {
        unsigned int v101 = v88;
      }
      else {
        unsigned int v101 = v90 & 0xFF000000;
      }
      if ((v90 & 0xFFFFFF) > v100) {
        int v99 = v90;
      }
      if ((v99 ^ v101) >> 24)
      {
        unsigned int v88 = v101;
        unsigned int v90 = v99;
      }
      else
      {
        do
        {
          unsigned int v88 = v101 << 8;
          if (v81 >= a3) {
            unint64_t v102 = 0;
          }
          else {
            unint64_t v102 = v81;
          }
          *(unsigned char *)(a2 + v102) = HIBYTE(v101);
          unsigned int v90 = (v99 << 8) | 0xFF;
          ++v81;
          unsigned int v103 = ((v99 << 8) ^ (v101 << 8)) >> 24;
          int v99 = v90;
          v101 <<= 8;
        }
        while (!v103);
      }
    }
    if (v81 >= a3) {
      unint64_t v105 = 0;
    }
    else {
      unint64_t v105 = v81;
    }
    *(unsigned char *)(a2 + v105) = v104;
    if (v81 + 1 <= a3) {
      return v81 + 1;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t cosl_codec_get_decoded_size(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  unsigned int v5 = 0;
  unsigned int v6 = 0;
  int v7 = 0;
  unint64_t v8 = 0;
  do
  {
    if ((v6 ^ v7) >> 24)
    {
      int v9 = v7;
      int v11 = v6;
    }
    else
    {
      do
      {
        int v9 = v7 << 8;
        unsigned int v10 = v6 << 8;
        int v11 = (v6 << 8) | 0xFF;
        if (v8 >= a3) {
          unint64_t v12 = 0;
        }
        else {
          unint64_t v12 = v8;
        }
        unsigned int v5 = *(unsigned __int8 *)(a2 + v12) | (v5 << 8);
        ++v8;
        unsigned int v13 = (v10 ^ (v7 << 8)) >> 24;
        unsigned int v6 = v11;
        v7 <<= 8;
      }
      while (!v13);
    }
    unsigned int v14 = v9 + ((v11 - v9) >> 1);
    v4 |= (unint64_t)(v5 <= v14) << v3;
    if ((2 * v4) >> v3 == 3) {
      break;
    }
    unsigned int v6 = v5 > v14 ? v11 : v9 + ((v11 - v9) >> 1);
    int v7 = v5 > v14 ? v14 + 1 : v9;
    ++v3;
  }
  while (v3 != 64);
  if (v4 < 2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = 1;
  uint64_t v17 = 2;
  do
  {
    uint64_t v18 = v17;
    result += ((uint64_t)(v4 << 63) >> 63) & v16;
    v17 += v16;
    uint64_t v16 = v18;
    BOOL v19 = v4 > 3;
    v4 >>= 1;
  }
  while (v19);
  return result;
}

unint64_t cosl_codec_decode(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  unsigned int v7 = 0;
  unsigned int v8 = 0;
  unsigned int v9 = 0;
  unint64_t v10 = 0;
  do
  {
    if ((v8 ^ v9) >> 24)
    {
      unsigned int v11 = v9;
      int v13 = v8;
    }
    else
    {
      do
      {
        unsigned int v11 = v9 << 8;
        unsigned int v12 = v8 << 8;
        int v13 = (v8 << 8) | 0xFF;
        if (v10 >= a5) {
          unint64_t v14 = 0;
        }
        else {
          unint64_t v14 = v10;
        }
        unsigned int v7 = *(unsigned __int8 *)(a4 + v14) | (v7 << 8);
        ++v10;
        unsigned int v15 = (v12 ^ (v9 << 8)) >> 24;
        unsigned int v8 = v13;
        v9 <<= 8;
      }
      while (!v15);
    }
    unsigned int v8 = v11 + ((v13 - v11) >> 1);
    uint64_t v16 = v7 <= v8;
    if (v7 > v8) {
      unsigned int v9 = v8 + 1;
    }
    else {
      unsigned int v9 = v11;
    }
    if (v7 > v8) {
      unsigned int v8 = v13;
    }
    v6 |= v16 << v5;
    if ((2 * v6) >> v5 == 3) {
      break;
    }
    ++v5;
  }
  while (v5 != 64);
  if (v6 < 2)
  {
    unint64_t v17 = 0;
  }
  else
  {
    unint64_t v17 = 0;
    uint64_t v18 = 1;
    uint64_t v19 = 2;
    do
    {
      uint64_t v20 = v19;
      v17 += ((uint64_t)(v6 << 63) >> 63) & v18;
      v19 += v18;
      uint64_t v18 = v20;
      BOOL v58 = v6 > 3;
      v6 >>= 1;
    }
    while (v58);
  }
  if (v17 >= a3) {
    unint64_t v21 = a3;
  }
  else {
    unint64_t v21 = v17;
  }
  if ((v8 ^ v9) >> 24)
  {
    unsigned int v22 = v9;
    unsigned int v24 = v8;
  }
  else
  {
    do
    {
      unsigned int v22 = v9 << 8;
      unsigned int v23 = v8 << 8;
      unsigned int v24 = (v8 << 8) | 0xFF;
      if (v10 >= a5) {
        unint64_t v25 = 0;
      }
      else {
        unint64_t v25 = v10;
      }
      unsigned int v7 = *(unsigned __int8 *)(a4 + v25) | (v7 << 8);
      ++v10;
      unsigned int v26 = (v23 ^ (v9 << 8)) >> 24;
      unsigned int v8 = v24;
      v9 <<= 8;
    }
    while (!v26);
  }
  unsigned int v27 = v22 + ((v24 - v22) >> 1);
  if (v7 <= v27)
  {
    if (v21)
    {
      uint64_t v37 = 0;
      unsigned int v38 = 0;
      unsigned int v39 = 0;
      int v40 = 0;
      unsigned int v41 = 0;
      int v42 = 32;
      do
      {
        int v43 = v42 << 8;
        int v44 = -*(_DWORD *)(a1 + 16);
        unsigned int v45 = v41 >> v44;
        unsigned int v46 = v39 >> v44;
        unsigned int v47 = v38 >> v44;
        int v49 = 8;
        int v50 = 1;
        do
        {
          if ((v27 ^ v22) >> 24)
          {
            unsigned int v51 = v22;
            int v53 = v27;
          }
          else
          {
            do
            {
              unsigned int v51 = v22 << 8;
              unsigned int v52 = v27 << 8;
              int v53 = (v27 << 8) | 0xFF;
              if (v10 >= a5) {
                unint64_t v54 = 0;
              }
              else {
                unint64_t v54 = v10;
              }
              unsigned int v7 = *(unsigned __int8 *)(a4 + v54) | (v7 << 8);
              ++v10;
              unsigned int v55 = (v52 ^ (v22 << 8)) >> 24;
              unsigned int v27 = v53;
              v22 <<= 8;
            }
            while (!v55);
          }
          uint64_t v48 = *(void *)(a1 + 8);
          unsigned int v27 = v51
              + ((*(unsigned __int8 *)(*(void *)(a1 + 40)
                                     + ((unint64_t)((*(unsigned __int8 *)(*(void *)a1
                                                                               + ((unint64_t)(v50 + v43) >> 1)) >> (4 * (v50 & 1))) & 0xF) << 12)
                                     + ((unint64_t)((*(unsigned __int8 *)(v48
                                                                               + ((unint64_t)(v50 + v45) >> 1)) >> (4 * ((v50 + v45) & 1))) & 0xF) << 8)
                                     + 16
                                     * ((*(unsigned __int8 *)(v48 + ((unint64_t)(v50 + v46) >> 1)) >> (4 * ((v50 + v46) & 1))) & 0xF)
                                     + ((*(unsigned __int8 *)(v48 + ((unint64_t)(v50 + v47) >> 1)) >> (4 * ((v50 + v47) & 1))) & 0xFLL))
                * (unint64_t)(v53 - v51)) >> 8);
          BOOL v56 = v7 <= v27;
          if (v7 > v27) {
            unsigned int v22 = v27 + 1;
          }
          else {
            unsigned int v22 = v51;
          }
          if (v7 > v27) {
            unsigned int v27 = v53;
          }
          int v50 = v56 | (2 * v50);
          --v49;
        }
        while (v49);
        if ((v50 - 65) >= 0x1Au) {
          unsigned __int8 v57 = v50;
        }
        else {
          unsigned __int8 v57 = v50 + 32;
        }
        BOOL v58 = ((v57 & 0xDF) - 91) >= 0xE6u || (char)v57 <= -1;
        unsigned int v38 = -1640531535 * (v38 + v57);
        if (!v58) {
          unsigned int v38 = 0;
        }
        int v42 = v50;
        unsigned int v39 = -1640531535 * (v40 + v50);
        int v40 = -1640531535 * (v41 + v50);
        unsigned int v41 = -1640531535 * (v50 | v43);
        *(unsigned char *)(a2 + v37++) = v50;
      }
      while (v37 != v21);
    }
  }
  else if (v21)
  {
    uint64_t v28 = 0;
    unsigned int v29 = v27 + 1;
    do
    {
      for (unsigned int i = 1; i < 0x100; unsigned int i = v36 | (2 * i))
      {
        if ((v24 ^ v29) >> 24)
        {
          unsigned int v31 = v29;
          int v33 = v24;
        }
        else
        {
          do
          {
            unsigned int v31 = v29 << 8;
            unsigned int v32 = v24 << 8;
            int v33 = (v24 << 8) | 0xFF;
            if (v10 >= a5) {
              unint64_t v34 = 0;
            }
            else {
              unint64_t v34 = v10;
            }
            unsigned int v7 = *(unsigned __int8 *)(a4 + v34) | (v7 << 8);
            ++v10;
            unsigned int v35 = (v32 ^ (v29 << 8)) >> 24;
            unsigned int v24 = v33;
            v29 <<= 8;
          }
          while (!v35);
        }
        unsigned int v24 = v31 + ((v33 - v31) >> 1);
        BOOL v36 = v7 <= v24;
        if (v7 > v24) {
          unsigned int v29 = v24 + 1;
        }
        else {
          unsigned int v29 = v31;
        }
        if (v7 > v24) {
          unsigned int v24 = v33;
        }
      }
      *(unsigned char *)(a2 + v28++) = i;
    }
    while (v28 != v21);
  }
  return v21;
}

void *cosl_model_create(unsigned int a1)
{
  if (a1 > 5) {
    return 0;
  }
  uint64_t v3 = calloc(1uLL, 0x100028uLL);
  unint64_t v1 = v3;
  if (!v3)
  {
    cosl_model_destroy(0);
    return v1;
  }
  unint64_t v4 = v3 + 0x10000;
  *((unsigned char *)v3 + 1048608) = a1;
  uint64_t v5 = (0x40000 << a1) | 0x100u;
  unint64_t v6 = malloc(8 * v5);
  if (v6)
  {
    *unint64_t v4 = v6;
    v1[65537] = a1 + 18;
    v1[65538] = v5;
    v1[65539] = 64;
    goto LABEL_9;
  }
  uint64_t v5 = v1[65538];
  if (v5)
  {
    unint64_t v6 = (void *)*v4;
    do
    {
LABEL_9:
      *v6++ = 0x200000001;
      --v5;
    }
    while (v5);
  }
  for (uint64_t i = 0; i != 0x10000; i += 4)
  {
    unsigned int v8 = &v1[i];
    *unsigned int v8 = xmmword_20DAB6220;
    v8[1] = xmmword_20DAB6220;
  }
  for (uint64_t j = 0; j != 0x10000; j += 4)
  {
    unint64_t v10 = &v1[j + 65540];
    *unint64_t v10 = xmmword_20DAB6220;
    v10[1] = xmmword_20DAB6220;
  }
  return v1;
}

void cosl_model_destroy(void **a1)
{
  if (a1)
  {
    free(a1[0x10000]);
    free(a1);
  }
}

uint64_t cosl_model_save_codec(uint64_t a1, const char *a2, int a3)
{
  uint64_t v3 = (void *)(a1 + 0x80000);
  uint64_t __ptr = 0x100000000000;
  unint64_t v4 = *(void *)(a1 + 524312) * *(void *)(a1 + 524304);
  if (v4 < 8) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = malloc(v4 >> 3);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = v8;
  unint64_t v10 = fopen(a2, "wb");
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v11 = v10;
  LODWORD(__ptr) = a3;
  HIWORD(__ptr) = *(unsigned __int8 *)(a1 + 1048608);
  if (fwrite(&__ptr, 1uLL, 8uLL, v10) != 8) {
    goto LABEL_19;
  }
  unint64_t v12 = v3[2];
  if (v12)
  {
    unint64_t v13 = 0;
    unint64_t v14 = (unsigned int *)(*v3 + 8);
    unsigned int v15 = v9;
    do
    {
      unsigned __int8 v16 = counter_get_quantizer[((((unint64_t)*(v14 - 2) << 16)
                                                + ((unint64_t)*(v14 - 1) >> 1))
                                               / *(v14 - 1)) >> 10];
      uint64_t v17 = *v14;
      unint64_t v18 = v14[1];
      v14 += 4;
      *v15++ = v16 + 16 * counter_get_quantizer[(((v17 << 16) + (v18 >> 1)) / v18) >> 10];
      v13 += 2;
    }
    while (v13 < v12);
  }
  if (fwrite(v9, 1uLL, v12 >> 1, v11) != v12 >> 1) {
    goto LABEL_19;
  }
  uint64_t v19 = (unsigned int *)(a1 + 8);
  unint64_t v20 = -2;
  unint64_t v21 = v9;
  do
  {
    unsigned __int8 v22 = counter_get_quantizer[((((unint64_t)*(v19 - 2) << 16)
                                              + ((unint64_t)*(v19 - 1) >> 1))
                                             / *(v19 - 1)) >> 10];
    uint64_t v23 = *v19;
    unint64_t v24 = v19[1];
    v19 += 4;
    *v21++ = v22 + 16 * counter_get_quantizer[(((v23 << 16) + (v24 >> 1)) / v24) >> 10];
    v20 += 2;
  }
  while (v20 < 0xFFFE);
  if (fwrite(v9, 1uLL, 0x8000uLL, v11) == 0x8000)
  {
    uint64_t v25 = 0;
    unsigned int v26 = (const float *)(a1 + 524320);
    v27.i64[0] = 0x100000001;
    v27.i64[1] = 0x100000001;
    v28.i64[0] = 0xFF000000FFLL;
    v28.i64[1] = 0xFF000000FFLL;
    do
    {
      unsigned int v29 = v26;
      float32x4x2_t v53 = vld2q_f32(v29);
      v29 += 8;
      int v30 = v26 + 16;
      float32x4x2_t v54 = vld2q_f32(v30);
      unsigned int v31 = v26 + 24;
      float32x4x2_t v55 = vld2q_f32(v31);
      float32x4x2_t v56 = vld2q_f32(v29);
      uint64x2_t v32 = vshll_high_n_u32((uint32x4_t)v56.val[0], 8uLL);
      uint32x4_t v33 = vshrq_n_u32((uint32x4_t)v53.val[1], 1uLL);
      uint32x4_t v34 = vshrq_n_u32((uint32x4_t)v55.val[1], 1uLL);
      uint32x4_t v35 = vshrq_n_u32((uint32x4_t)v54.val[1], 1uLL);
      uint64x2_t v36 = vshll_n_u32(*(uint32x2_t *)v56.val[0].f32, 8uLL);
      int32x4_t v37 = (int32x4_t)vaddw_high_u32(vshll_high_n_u32((uint32x4_t)v53.val[0], 8uLL), v33);
      uint64x2_t v38 = vaddw_u32(vshll_n_u32(*(uint32x2_t *)v55.val[0].f32, 8uLL), *(uint32x2_t *)v34.i8);
      uint64x2_t v39 = vaddw_high_u32(vshll_high_n_u32((uint32x4_t)v55.val[0], 8uLL), v34);
      int32x4_t v40 = (int32x4_t)vaddw_u32(vshll_n_u32(*(uint32x2_t *)v54.val[0].f32, 8uLL), *(uint32x2_t *)v35.i8);
      uint64x2_t v41 = vaddw_high_u32(vshll_high_n_u32((uint32x4_t)v54.val[0], 8uLL), v35);
      uint32x4_t v42 = vshrq_n_u32((uint32x4_t)v56.val[1], 1uLL);
      v43.i64[0] = v53.val[1].u32[2];
      v43.i64[1] = v53.val[1].u32[3];
      int32x4_t v44 = (int32x4_t)v43;
      v43.i64[0] = v56.val[1].u32[0];
      v43.i64[1] = v56.val[1].u32[1];
      float32x4_t v45 = v43;
      v43.i64[0] = v56.val[1].u32[2];
      v43.i64[1] = v56.val[1].u32[3];
      v56.val[0] = v43;
      v43.i64[0] = v55.val[1].u32[0];
      v43.i64[1] = v55.val[1].u32[1];
      v56.val[1] = v43;
      v43.i64[0] = v55.val[1].u32[2];
      v43.i64[1] = v55.val[1].u32[3];
      v55.val[1] = (float32x4_t)vaddw_u32(v36, *(uint32x2_t *)v42.i8);
      uint64x2_t v46 = vaddw_high_u32(v32, v42);
      unint64_t v47 = v40.i64[1] / (unint64_t)v54.val[1].u32[1];
      unint64_t v48 = v40.i64[0] / (unint64_t)v54.val[1].u32[0];
      v40.i64[0] = v41.i64[0] / (unint64_t)v54.val[1].u32[2];
      v54.val[0].i64[0] = v48;
      v54.val[1].i64[0] = v39.i64[0] / (unint64_t)v43.i64[0];
      v55.val[0].i64[0] = v38.i64[0] / (unint64_t)v56.val[1].i64[0];
      v40.i64[1] = v41.i64[1] / (unint64_t)v54.val[1].u32[3];
      v54.val[0].i64[1] = v47;
      v54.val[1].i64[1] = v39.i64[1] / (unint64_t)v43.i64[1];
      v37.i64[0] /= (unint64_t)v44.i64[0];
      v55.val[0].i64[1] = v38.i64[1] / (unint64_t)v56.val[1].i64[1];
      uint64x2_t v49 = vaddw_u32(vshll_n_u32(*(uint32x2_t *)v53.val[0].f32, 8uLL), *(uint32x2_t *)v33.i8);
      v43.i64[0] = v53.val[1].u32[0];
      v43.i64[1] = v53.val[1].u32[1];
      v37.i64[1] /= (unint64_t)v44.i64[1];
      v53.val[1].i64[0] = v46.i64[0] / (unint64_t)v56.val[0].i64[0];
      v53.val[1].i64[1] = v46.i64[1] / (unint64_t)v56.val[0].i64[1];
      v44.i64[0] = v55.val[1].i64[0] / (unint64_t)v45.i64[0];
      v44.i64[1] = v55.val[1].i64[1] / (unint64_t)v45.i64[1];
      v53.val[0].i64[0] = v49.i64[0] / (unint64_t)v43.i64[0];
      v53.val[0].i64[1] = v49.i64[1] / (unint64_t)v43.i64[1];
      *(int8x16_t *)&v9[v25] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vminq_u32(vmaxq_u32((uint32x4_t)vuzp1q_s32((int32x4_t)v53.val[0], v37), v27), v28), (int16x8_t)vminq_u32(vmaxq_u32((uint32x4_t)vuzp1q_s32(v44, (int32x4_t)v53.val[1]), v27), v28)), (int8x16_t)vuzp1q_s16((int16x8_t)vminq_u32(vmaxq_u32((uint32x4_t)vuzp1q_s32((int32x4_t)v54.val[0], v40), v27), v28), (int16x8_t)vminq_u32(vmaxq_u32(
                                                             (uint32x4_t)vuzp1q_s32((int32x4_t)v55.val[0], (int32x4_t)v54.val[1]), v27), v28)));
      v25 += 16;
      v26 += 32;
    }
    while (v25 != 0x10000);
    if (fwrite(v9, 1uLL, 0x10000uLL, v11) == 0x10000) {
      uint64_t v50 = 0;
    }
    else {
      uint64_t v50 = 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_19:
    uint64_t v50 = 0xFFFFFFFFLL;
  }
  free(v9);
  fclose(v11);
  return v50;
}

char **cosl_codec_map(const char *a1)
{
  memset(&v14, 0, sizeof(v14));
  uint64_t v2 = (char **)calloc(1uLL, 0x50uLL);
  uint64_t v3 = v2;
  if (!v2) {
    goto LABEL_3;
  }
  *((_DWORD *)v2 + 18) = -1;
  if (stat(a1, &v14)) {
    goto LABEL_3;
  }
  v3[8] = (char *)v14.st_size;
  int v5 = open(a1, 0, *(_OWORD *)&v14.st_dev, *(_OWORD *)&v14.st_uid, *(_OWORD *)&v14.st_atimespec, *(_OWORD *)&v14.st_mtimespec, *(_OWORD *)&v14.st_ctimespec, *(_OWORD *)&v14.st_birthtimespec);
  *((_DWORD *)v3 + 18) = v5;
  if (v5 < 0) {
    goto LABEL_3;
  }
  unint64_t v6 = (char *)mmap(0, (size_t)v3[8], 1, 2, v5, 0);
  v3[7] = v6;
  if (v6 == (char *)-1)
  {
    v3[7] = 0;
LABEL_3:
    cosl_codec_unmap(v3);
    return 0;
  }
  uint64_t v7 = (uint64_t)v3[8];
  v3[6] = v6;
  if (v7 < 8) {
    goto LABEL_3;
  }
  if (*((_WORD *)v6 + 2) != 4096) {
    goto LABEL_3;
  }
  unint64_t v8 = *((unsigned __int16 *)v6 + 3);
  if (v8 > 5) {
    goto LABEL_3;
  }
  unsigned int v9 = &v6[v7];
  unint64_t v10 = v6 + 8;
  unint64_t v11 = (0x40000 << v8) | 0x100;
  if (v7 >= v11 >> 1)
  {
    unint64_t v12 = v11 >> 1;
    v3[1] = v10;
    v3[2] = (char *)(v8 + 18);
    v3[3] = (char *)v11;
    v3[4] = (char *)4;
  }
  else
  {
    unint64_t v12 = 0;
  }
  unint64_t v13 = &v10[v12];
  *uint64_t v3 = v13;
  v3[5] = v13 + 0x8000;
  if (v13 + 98304 != v9) {
    goto LABEL_3;
  }
  return v3;
}

void cosl_codec_unmap(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 18);
    if ((v2 & 0x80000000) == 0)
    {
      if (*((void *)a1 + 7))
      {
        munmap(*((void **)a1 + 7), *((void *)a1 + 8));
        *((void *)a1 + 7) = 0;
        int v2 = *((_DWORD *)a1 + 18);
      }
      close(v2);
    }
  }

  free(a1);
}

uint64_t cosl_codec_get_id(uint64_t a1)
{
  return **(unsigned int **)(a1 + 48);
}

uint64_t BrotliBuildHistogramsWithContext(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, unsigned __int8 a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  stat v14 = *(unsigned int **)(a3 + 24);
  if (v14) {
    uint64_t v15 = *v14;
  }
  else {
    uint64_t v15 = 0;
  }
  unsigned __int8 v16 = *(unsigned int **)(a4 + 24);
  unint64_t v47 = v16;
  if (v16) {
    uint64_t v17 = *v16;
  }
  else {
    uint64_t v17 = 0;
  }
  unint64_t v18 = *(unsigned int **)(a5 + 24);
  int32x4_t v44 = v18;
  if (v18)
  {
    uint64_t v19 = *v18;
    if (!a2) {
      return result;
    }
  }
  else
  {
    uint64_t v19 = 0;
    if (!a2) {
      return result;
    }
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = a10;
  uint64_t v27 = a9;
  uint64_t v46 = 0;
  do
  {
    if (!v17)
    {
      ++v23;
      uint64_t v22 = *(unsigned __int8 *)(*(void *)(a4 + 16) + v23);
      uint64_t v17 = v47[v23];
    }
    uint32x4_t v28 = (unsigned int *)(result + 16 * v20);
    uint64_t v29 = a13 + 2832 * v22;
    unsigned int v30 = *((unsigned __int16 *)v28 + 6);
    ++*(_DWORD *)(v29 + 4 * *((unsigned __int16 *)v28 + 6));
    ++*(void *)(v29 + 2816);
    uint64_t v31 = *v28;
    if (v31)
    {
      do
      {
        uint64_t v32 = v27;
        if (!v15)
        {
          ++v25;
          uint64_t v24 = *(unsigned __int8 *)(*(void *)(a3 + 16) + v25);
          uint64_t v15 = v14[v25];
        }
        uint64_t v33 = v24;
        if (a11)
        {
          uint32x4_t v34 = (char *)&_kBrotliContextLookupTable + (*(_DWORD *)(a11 + 4 * v24) << 9);
          uint64_t v33 = (v24 << 6) + (v34[v26 + 256] | v34[v32]);
        }
        uint64_t v35 = a12 + 1040 * v33;
        --v15;
        ++*(_DWORD *)(v35 + 4 * *(unsigned __int8 *)(a6 + (a7 & a8)));
        ++*(void *)(v35 + 1024);
        uint64_t v27 = *(unsigned __int8 *)(a6 + (a7++ & a8));
        uint64_t v26 = v32;
        --v31;
      }
      while (v31);
    }
    else
    {
      uint64_t v32 = v26;
    }
    uint64_t v36 = *(_DWORD *)(result + 16 * v20 + 4) & 0x1FFFFFF;
    a7 += v36;
    if (v36)
    {
      uint64_t v32 = *(unsigned __int8 *)(a6 + ((a7 - 2) & a8));
      uint64_t v27 = *(unsigned __int8 *)(a6 + ((a7 - 1) & a8));
      if (v30 >= 0x80)
      {
        if (!v19)
        {
          uint64_t v21 = *(unsigned __int8 *)(*(void *)(a5 + 16) + ++v46);
          uint64_t v19 = v44[v46];
        }
        --v19;
        unsigned int v37 = v30 >> 6;
        BOOL v40 = v30 >> 6 != 2 && v37 != 4 && v37 != 7 || (v30 & 7) >= 3;
        uint64_t v41 = 3;
        if (!v40) {
          uint64_t v41 = v30 & 7;
        }
        uint64_t v42 = a14 + 2192 * (v41 | (4 * v21));
        uint64_t v43 = *(_WORD *)(result + 16 * v20 + 14) & 0x3FF;
        ++*(_DWORD *)(v42 + 4 * v43);
        ++*(void *)(v42 + 2176);
      }
    }
    --v17;
    ++v20;
    uint64_t v26 = v32;
  }
  while (v20 != a2);
  return result;
}

uint64_t thread_pool_send_task(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = v4 + 1;
  uint64_t v5 = *(void *)(a1 + 280);
  uint64_t v6 = (int)(v4 % (2 * *(void *)(a1 + 272)));
  uint64_t v7 = (pthread_mutex_t *)(a1 + 16);
  unint64_t v8 = (pthread_cond_t *)(a1 + 80);
  if (!v5) {
    goto LABEL_3;
  }
LABEL_2:
  uint64_t v9 = *(void *)(a1 + 264);
  if (*(void *)(v9 + 8 * v6))
  {
LABEL_3:
    while (!pthread_mutex_lock(v7))
    {
      while (1)
      {
        int v10 = *(_DWORD *)(a1 + 8);
        if (v10 > 0) {
          break;
        }
        if (pthread_cond_wait(v8, v7)) {
          return 0xFFFFFFFFLL;
        }
      }
      *(_DWORD *)(a1 + 8) = v10 - 1;
      if (pthread_mutex_unlock(v7)) {
        break;
      }
      uint64_t v5 = *(void *)(a1 + 280) + 1;
      *(void *)(a1 + 280) = v5;
      if (v5) {
        goto LABEL_2;
      }
    }
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 280) = v5 - 1;
  *(void *)(v9 + 8 * v6) = a2;
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 136))) {
    return 0xFFFFFFFFLL;
  }
  int v11 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 128) = v11 + 1;
  if (!v11)
  {
    if (pthread_cond_broadcast((pthread_cond_t *)(a1 + 200))) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 136));
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t thread_pool_sync(uint64_t a1)
{
  if (*(void *)(a1 + 280) >= *(void *)(a1 + 272))
  {
    int v4 = 1;
  }
  else
  {
    int v2 = (pthread_mutex_t *)(a1 + 16);
    uint64_t v3 = (pthread_cond_t *)(a1 + 80);
    int v4 = 1;
    do
    {
      if (pthread_mutex_lock(v2)) {
        goto LABEL_8;
      }
      while (1)
      {
        int v5 = *(_DWORD *)(a1 + 8);
        if (v5 > 0) {
          break;
        }
        if (pthread_cond_wait(v3, v2)) {
          goto LABEL_8;
        }
      }
      *(_DWORD *)(a1 + 8) = v5 - 1;
      if (pthread_mutex_unlock(v2)) {
LABEL_8:
      }
        int v4 = 0;
      unint64_t v6 = *(void *)(a1 + 272);
      unint64_t v7 = *(void *)(a1 + 280) + 1;
      *(void *)(a1 + 280) = v7;
    }
    while (v7 < v6);
  }
  if (v4) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

int64x2_t *thread_pool_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (int64x2_t *)calloc(1uLL, 0x138uLL);
  if (v6)
  {
    v6->i64[0] = (uint64_t)malloc(8 * a3);
    unint64_t v7 = calloc(1uLL, 16 * a3);
    v6[16].i64[1] = (uint64_t)v7;
    if (v6->i64[0] && v7 != 0)
    {
      v6->i32[2] = 0;
      if (!pthread_mutex_init((pthread_mutex_t *)&v6[1], 0) && !pthread_cond_init((pthread_cond_t *)&v6[5], 0))
      {
        v6[8].i32[0] = 0;
        if (!pthread_mutex_init((pthread_mutex_t *)&v6[8].u64[1], 0)
          && !pthread_cond_init((pthread_cond_t *)&v6[12].u64[1], 0))
        {
          v6[15].i64[1] = a2;
          v6[16].i64[0] = a1;
          if (!a3) {
            return v6;
          }
          uint64_t v10 = 0;
          int64x2_t v11 = vdupq_n_s64(1uLL);
          while ((create_thread((pthread_t *)(v6->i64[0] + v10), (void *(__cdecl *)(void *))thread_pool_entry, v6, 0) & 0x80000000) == 0)
          {
            v6[17] = vaddq_s64(v6[17], v11);
            v10 += 8;
            if (!--a3) {
              return v6;
            }
          }
        }
      }
    }
  }
  thread_pool_destroy((uint64_t)v6);
  return 0;
}

uint64_t thread_pool_entry(uint64_t a1)
{
  int v2 = (pthread_mutex_t *)(a1 + 136);
  uint64_t v3 = (pthread_cond_t *)(a1 + 200);
  int v4 = (pthread_mutex_t *)(a1 + 16);
  int v5 = (pthread_cond_t *)(a1 + 80);
  do
  {
    if (pthread_mutex_lock(v2)) {
      break;
    }
    while (1)
    {
      int v6 = *(_DWORD *)(a1 + 128);
      if (v6 > 0) {
        break;
      }
      if (pthread_cond_wait(v3, v2)) {
        return a1;
      }
    }
    *(_DWORD *)(a1 + 128) = v6 - 1;
    if (pthread_mutex_unlock(v2)) {
      break;
    }
    unint64_t add = atomic_fetch_add((atomic_ullong *volatile)(a1 + 296), 1uLL);
    uint64_t v8 = *(void *)(a1 + 264);
    unint64_t v9 = add % (2 * *(void *)(a1 + 272));
    if (!*(void *)(v8 + 8 * (int)v9)) {
      break;
    }
    *(void *)(v8 + 8 * (int)v9) = 0;
    if (((*(uint64_t (**)(void))(a1 + 248))(*(void *)(a1 + 256)) & 0x80000000) != 0) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 304), 1u, memory_order_relaxed);
    }
    if (pthread_mutex_lock(v4)) {
      break;
    }
    int v10 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v10 + 1;
    if (!v10)
    {
      if (pthread_cond_broadcast(v5)) {
        break;
      }
    }
  }
  while (!pthread_mutex_unlock(v4));
  return a1;
}

uint64_t thread_pool_destroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 272))
    {
      unint64_t v2 = 0;
      do
      {
        thread_pool_send_task(v1, 0);
        ++v2;
        unint64_t v3 = *(void *)(v1 + 272);
      }
      while (v2 < v3);
      if (v3)
      {
        unint64_t v4 = 0;
        do
          join_thread(*(_opaque_pthread_t **)(*(void *)v1 + 8 * v4++));
        while (v4 < *(void *)(v1 + 272));
      }
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 16))) {
      pthread_cond_destroy((pthread_cond_t *)(v1 + 80));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 136))) {
      pthread_cond_destroy((pthread_cond_t *)(v1 + 200));
    }
    unsigned int v5 = atomic_load((unsigned int *)(v1 + 304));
    free(*(void **)v1);
    free(*(void **)(v1 + 264));
    free((void *)v1);
    if (v5) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t lzvnStreamDecodeStateSize()
{
  return 524544;
}

uint64_t lzvnStreamDecodeInit(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    unint64_t v4 = *(_DWORD **)(a1 + 32);
  }
  else
  {
    unint64_t v4 = 0;
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  unsigned int v5 = realloc_stream_state(v4, 1, a2, 0x80100u, 0x80078u);
  *(void *)(a1 + 32) = v5;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  int v6 = v5;
  uint64_t result = 0;
  v6[2] = v6 + 32;
  v6[3] = v6 + 32800;
  v6[6] = v6 + 32;
  v6[7] = v6 + 32;
  v6[8] = v6 + 32800;
  v6[9] = v6 + 32800;
  v6[10] = v6 + 65568;
  v6[11] = v6 + 32800;
  return result;
}

uint64_t lzvnStreamDecode(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2) {
    *(_DWORD *)(v3 + 32) = 1;
  }
  int v4 = 1;
  do
  {
    if (*(_DWORD *)(v3 + 36))
    {
      int64_t v5 = 0;
    }
    else
    {
      int v6 = *(void **)(v3 + 56);
      unint64_t v7 = *(void *)(a1 + 24);
      if (v7 >= *(void *)(v3 + 16) - (void)v6 + 0x40000) {
        int64_t v5 = *(void *)(v3 + 16) - (void)v6 + 0x40000;
      }
      else {
        int64_t v5 = *(void *)(a1 + 24);
      }
      if (v5 >= 1)
      {
        memcpy(v6, *(const void **)(a1 + 16), v5);
        *(void *)(v3 + 56) += v5;
        unint64_t v7 = *(void *)(a1 + 24) - v5;
        *(void *)(a1 + 16) += v5;
        *(void *)(a1 + 24) = v7;
      }
      if (!v7 && *(_DWORD *)(v3 + 32)) {
        *(_DWORD *)(v3 + 36) = 1;
      }
    }
    unint64_t v8 = *(void *)(v3 + 88);
    if (v8 >= *(void *)(v3 + 24) + 0x20000)
    {
      unint64_t v9 = *(unsigned char **)(v3 + 64);
      unint64_t v10 = *(void *)(v3 + 72);
      int64x2_t v11 = v8 >= (unint64_t)(v9 - 0x10000) ? v9 - 0x10000 : *(char **)(v3 + 88);
      if ((unint64_t)v11 > v10)
      {
        if (v9 != v11)
        {
          memmove(*(void **)(v3 + 72), v11, v9 - v11);
          unint64_t v8 = *(void *)(v3 + 88);
          unint64_t v9 = *(unsigned char **)(v3 + 64);
        }
        *(void *)(v3 + 88) = v8 + v10 - (void)v11;
        *(void *)(v3 + 64) = &v9[v10 - (void)v11];
      }
    }
    if (*(_DWORD *)(v3 + 40) || *(void *)(v3 + 64) >= *(void *)(v3 + 80))
    {
      int v12 = 0;
    }
    else
    {
      int v12 = lzvnDecode(v3 + 48);
      if (v12 == -3) {
        int v4 = 0;
      }
      if (*(_DWORD *)(v3 + 128)) {
        *(_DWORD *)(v3 + 40) = 1;
      }
    }
    if (*(_DWORD *)(v3 + 44)) {
      goto LABEL_44;
    }
    unint64_t v13 = *(const void **)(v3 + 88);
    if (*(void *)(a1 + 8) >= *(void *)(v3 + 64) - (void)v13) {
      int64_t v14 = *(void *)(v3 + 64) - (void)v13;
    }
    else {
      int64_t v14 = *(void *)(a1 + 8);
    }
    if (v14 >= 1)
    {
      memcpy(*(void **)a1, v13, v14);
      unint64_t v13 = (const void *)(*(void *)(v3 + 88) + v14);
      *(void *)(v3 + 88) = v13;
      int64_t v15 = *(void *)(a1 + 8) - v14;
      *(void *)a1 += v14;
      *(void *)(a1 + 8) = v15;
    }
    if (*(_DWORD *)(v3 + 40) && v13 == *(const void **)(v3 + 64))
    {
      *(_DWORD *)(v3 + 44) = 1;
      if (v4) {
        return *(_DWORD *)(v3 + 44) != 0;
      }
      return 0xFFFFFFFFLL;
    }
    if (*(_DWORD *)(v3 + 44)) {
      goto LABEL_44;
    }
    unsigned __int8 v16 = *(char **)(v3 + 48);
    uint64_t v17 = *(char **)(v3 + 16);
    if (v16 >= v17 + 0x20000)
    {
      uint64_t v18 = *(void *)(v3 + 56);
      uint64_t v19 = v18 - (void)v16;
      if (v18 - (uint64_t)v16 >= 1)
      {
        memmove(v17, v16, v18 - (void)v16);
        uint64_t v17 = *(char **)(v3 + 16);
      }
      *(void *)(v3 + 48) = v17;
      *(void *)(v3 + 56) = &v17[v19];
    }
  }
  while (v14 | v5);
  if (v12 != -1)
  {
LABEL_44:
    if (v4) {
      return *(_DWORD *)(v3 + 44) != 0;
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (!*(_DWORD *)(v3 + 36) && v4) {
    return *(_DWORD *)(v3 + 44) != 0;
  }
  return result;
}

uint64_t touchpadCodecDecodeImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v85 = 0;
  char v86 = 0;
  unint64_t v6 = *(unsigned int *)(a1 + 664);
  uint64_t v78 = *(unsigned int *)(a1 + 668);
  uint64_t v90 = 0;
  unint64_t v91 = 0;
  uint64_t v87 = a4;
  unint64_t v88 = a5;
  unint64_t v89 = 0;
  if (!codecReadHeader(&v87, (uint64_t)&v85)) {
    return 0;
  }
  unsigned __int8 v76 = v85;
  if (v85)
  {
    if (*(void *)(a1 + 664) != __PAIR64__(HIWORD(v85), WORD2(v85)) || v86 != *(unsigned char *)(a1 + 672)) {
      return 0;
    }
    codecResetModel(a1);
  }
  if (v78)
  {
    unsigned int v7 = 0;
    uint64_t v8 = 0;
    unint64_t v9 = v89;
    uint64_t v10 = v90;
    uint64_t v75 = *(void *)(a1 + 632);
    unsigned int v11 = v91;
    int v12 = HIDWORD(v91);
    while (1)
    {
      uint64_t v13 = (v76 & (v8 != 0)) != 0 ? -(uint64_t)v6 : 0;
      unsigned int v80 = v7;
      uint64_t v79 = v8;
      if (v6) {
        break;
      }
LABEL_100:
      uint64_t v8 = v79 + 1;
      a2 += a3;
      unsigned int v7 = v80 + v6;
      if (v79 + 1 == v78) {
        goto LABEL_103;
      }
    }
    uint64_t v14 = 0;
    unint64_t v16 = v88;
    uint64_t v82 = v87;
    uint64_t v83 = v75 + 2 * v7;
    uint64_t v81 = v83 + 2 * v13;
    int v17 = *(__int16 *)(v75 + 2 * (v6 * v8) + 2 * v13);
    int v15 = v17;
    int v18 = v17;
    uint64_t v19 = v10;
    int v20 = v17;
    while (1)
    {
      uint64_t v21 = v14 + 1;
      if (v14 + 1 < v6) {
        int v20 = *(__int16 *)(v81 + 2 * v14 + 2);
      }
      int v22 = v15 - v17;
      if (v15 - v17 <= -2) {
        int v23 = -2;
      }
      else {
        int v23 = 0;
      }
      if (v22 > 1) {
        int v23 = 2;
      }
      if (v22 < -40) {
        int v23 = -1;
      }
      if (v22 <= 40) {
        int v24 = v23;
      }
      else {
        int v24 = 1;
      }
      int v25 = 25 * v24;
      int v26 = v17 - v18;
      if (v17 - v18 <= -2) {
        int v27 = -2;
      }
      else {
        int v27 = 0;
      }
      if (v26 > 1) {
        int v27 = 2;
      }
      if (v26 < -40) {
        int v27 = -1;
      }
      if (v26 <= 40) {
        int v28 = v27;
      }
      else {
        int v28 = 1;
      }
      int v29 = 5 * v28 + v25;
      int v30 = v18 - v20;
      if (v18 - v20 <= -2) {
        int v31 = -2;
      }
      else {
        int v31 = 0;
      }
      if (v30 > 1) {
        int v31 = 2;
      }
      if (v30 < -40) {
        int v31 = -1;
      }
      if (v30 <= 40) {
        int v32 = v31;
      }
      else {
        int v32 = 1;
      }
      int v33 = v29 + v32;
      int v34 = v18 - v17 + v15;
      if (v34 <= v15) {
        int v35 = v15;
      }
      else {
        int v35 = v34;
      }
      if (v34 < v15) {
        int v15 = v34;
      }
      if (v35 >= v18) {
        int v36 = v18;
      }
      else {
        int v36 = v35;
      }
      if (v15 <= v36) {
        __int16 v37 = v36;
      }
      else {
        __int16 v37 = v15;
      }
      if (v33 >= 0) {
        unsigned int v38 = v33;
      }
      else {
        unsigned int v38 = -v33;
      }
      if (v12 <= 15)
      {
        unint64_t v39 = v9 + 1;
        unint64_t v89 = v9 + 1;
        if (v9 < v16)
        {
          uint64_t v10 = v19 + 1;
          uint64_t v90 = v19 + 1;
          v11 |= *(unsigned __int8 *)(v82 + v19) << v12;
          v12 += 8;
          unint64_t v91 = __PAIR64__(v12, v11);
          ++v19;
        }
        v9 += 2;
        unint64_t v89 = v9;
        if (v39 < v16)
        {
          uint64_t v10 = v19 + 1;
          uint64_t v90 = v19 + 1;
          v11 |= *(unsigned __int8 *)(v82 + v19) << v12;
          v12 += 8;
          ++v19;
        }
      }
      uint64_t v40 = a1 + 10 * v38;
      int v41 = *(unsigned __int8 *)(v40 + 8);
      unsigned int v42 = __clz(__rbit32((unsigned __int16)v11 | 0x10000));
      if (v42 > 0xF)
      {
        unsigned int v47 = HIWORD(v11);
        int v48 = v12 - 16;
        LODWORD(v91) = HIWORD(v11);
        HIDWORD(v91) = v12 - 16;
        if (v12 <= 31)
        {
          unint64_t v49 = v9 + 1;
          unint64_t v89 = v9 + 1;
          if (v9 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v90 = v19 + 1;
            v47 |= *(unsigned __int8 *)(v82 + v19) << v48;
            int v48 = v12 - 8;
            LODWORD(v91) = v47;
            HIDWORD(v91) = v12 - 8;
            ++v19;
          }
          v9 += 2;
          unint64_t v89 = v9;
          if (v49 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v90 = v19 + 1;
            v47 |= *(unsigned __int8 *)(v82 + v19) << v48;
            v48 += 8;
            ++v19;
          }
        }
        unsigned int v11 = HIWORD(v47);
        int v12 = v48 - 16;
        LODWORD(v91) = HIWORD(v47);
        HIDWORD(v91) = v48 - 16;
      }
      else
      {
        unsigned int v43 = v11 >> (v42 + 1);
        int v44 = v12 - (v42 + 1);
        unint64_t v91 = __PAIR64__(v44, v43);
        if (v44 <= 15)
        {
          unint64_t v45 = v9 + 1;
          unint64_t v89 = v9 + 1;
          if (v9 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v90 = v19 + 1;
            v43 |= *(unsigned __int8 *)(v82 + v19) << v44;
            v44 += 8;
            unint64_t v91 = __PAIR64__(v44, v43);
            ++v19;
          }
          v9 += 2;
          unint64_t v89 = v9;
          if (v45 < v16)
          {
            uint64_t v10 = v19 + 1;
            uint64_t v90 = v19 + 1;
            v43 |= *(unsigned __int8 *)(v82 + v19) << v44;
            v44 += 8;
            ++v19;
          }
        }
        int v46 = v43 & ((-1 << v41) ^ 0xFFFF);
        unsigned int v11 = v43 >> v41;
        int v12 = v44 - v41;
        unint64_t v91 = __PAIR64__(v12, v11);
        unsigned int v47 = v46 + (v42 << v41);
      }
      int v50 = *(_DWORD *)(v40 + 4);
      int v51 = ((unsigned __int16)v47 >> 1) ^ -(v47 & 1);
      int v52 = *(_DWORD *)v40;
      uint64_t v53 = a1 + 10 * v38;
      char v55 = *(unsigned char *)(v53 + 9);
      float32x4x2_t v54 = (unsigned char *)(v53 + 9);
      unsigned __int8 v56 = v55 + 1;
      *float32x4x2_t v54 = v55 + 1;
      if (v51 >= 0) {
        int v57 = v51;
      }
      else {
        int v57 = -v51;
      }
      if (v51 <= 0)
      {
        if ((v51 & 0x80000000) == 0) {
          goto LABEL_84;
        }
        int v58 = -1;
      }
      else
      {
        int v58 = 1;
      }
      *(_DWORD *)(v40 + 4) = v50 + v58;
LABEL_84:
      int v59 = v57 + v52;
      int v60 = v56;
      int v61 = v56 << v41;
      int v63 = v61 >= 2 * v59 && v41 != 0;
      int v64 = v63 << 31 >> 31;
      if (v61 >= v59) {
        char v65 = v64;
      }
      else {
        char v65 = 1;
      }
      *(_DWORD *)uint64_t v40 = v59;
      *(unsigned char *)(v40 + 8) = v41 + v65;
      if (v60 == 64)
      {
        *float32x4x2_t v54 = 32;
        *(_DWORD *)uint64_t v40 = v59 - (v59 >> 1);
      }
      int v66 = (__int16)(v51 + ((v50 + 8) >> 4));
      if (v33 < 0) {
        int v66 = -v66;
      }
      __int16 v67 = v66 + v37;
      int v15 = (__int16)(v66 + v37);
      *(_WORD *)(a2 + 2 * v14) = v67;
      *(_WORD *)(v83 + 2 * v14++) = v67;
      int v17 = v18;
      int v18 = v20;
      if (v6 == v21) {
        goto LABEL_100;
      }
    }
  }
  int v12 = HIDWORD(v91);
LABEL_103:
  if (v12 <= 15)
  {
    unint64_t v68 = v89;
    unint64_t v69 = ++v89;
    if (v68 < v88)
    {
      uint64_t v70 = v90++;
      int v71 = *(unsigned __int8 *)(v87 + v70) << v12;
      v12 += 8;
      LODWORD(v91) = v71 | v91;
      HIDWORD(v91) = v12;
    }
    unint64_t v89 = v68 + 2;
    if (v69 < v88)
    {
      uint64_t v72 = v90++;
      LODWORD(v91) = v91 | (*(unsigned __int8 *)(v87 + v72) << v12);
      v12 += 8;
    }
  }
  int v73 = v91 & 0xFFF;
  LODWORD(v91) = v91 >> 12;
  HIDWORD(v91) = v12 - 12;
  if (v73 == codecGetFooterID(a1) && (v91 & 0x8000000000000000) == 0) {
    return v90 - ((unint64_t)HIDWORD(v91) >> 3);
  }
  return 0;
}

uint64_t zlib_encode_scratch_size()
{
  return 270336;
}

Bytef *zlib_encode_buffer(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  if ((a4 | a2) >> 32) {
    return 0;
  }
  int v9 = a4;
  int v11 = a2;
  v20[0] = a5;
  v20[1] = 270336;
  uint64_t v13 = zlib_malloc(v20, 1u, 0x70u);
  uint64_t v14 = (z_stream *)v13;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *(_OWORD *)(v13 + 8) = 0u;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_OWORD *)(v13 + 88) = 0u;
  *(void *)(v13 + 104) = 0;
  *(void *)(v13 + 64) = zlib_malloc;
  *(void *)(v13 + 72) = zlib_free;
  *(void *)(v13 + 80) = v20;
  *(_DWORD *)(v13 + 8) = v9;
  *(void *)uint64_t v13 = a3;
  *(_DWORD *)(v13 + 32) = v11;
  *(void *)(v13 + 24) = a1;
  if (a7) {
    int v15 = 15;
  }
  else {
    int v15 = -15;
  }
  int v16 = deflateInit2_((z_streamp)v13, a6, 8, v15, 8, 0, "1.2.5", 112);
  uint64_t result = 0;
  if (!v16)
  {
    int v18 = deflate(v14, 4);
    int v19 = deflateEnd(v14);
    uint64_t result = 0;
    if (!v19 && v18 == 1) {
      return &v14->next_out[-a1];
    }
  }
  return result;
}

double BrotliInitBlockSplit(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

_DWORD *BrotliSplitBlock(_DWORD *result, uint64_t a2, size_t a3, uint64_t a4, size_t a5, size_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  size_t v11 = a3;
  int v12 = result;
  uint64_t v617 = *MEMORY[0x263EF8340];
  uint64_t v540 = (uint64_t)result;
  if (!a3)
  {
    int v20 = result + 6;
    if (result[6]) {
      return result;
    }
    v548 = 0;
    goto LABEL_28;
  }
  size_t v16 = 0;
  int v17 = (unsigned int *)a2;
  size_t v18 = a3;
  do
  {
    unsigned int v19 = *v17;
    v17 += 4;
    v16 += v19;
    --v18;
  }
  while (v18);
  if (v16)
  {
    double result = (_DWORD *)BrotliAllocate((uint64_t)result);
    v548 = (char *)result;
  }
  else
  {
    v548 = 0;
  }
  int v22 = v12[6];
  uint64_t v21 = v12 + 6;
  if (v22) {
    return result;
  }
  uint64_t v510 = a7;
  v531 = v21;
  size_t v23 = v11;
  uint64_t v24 = 0;
  size_t v25 = a6 + 1;
  int v26 = (int *)(a2 + 4);
  size_t v520 = v23;
  do
  {
    size_t v27 = a5 & a6;
    size_t v28 = *(v26 - 1);
    if (v27 + v28 > a6)
    {
      uint64_t v29 = v25 - v27;
      double result = memcpy(&v548[v24], (const void *)(a4 + v27), v25 - v27);
      size_t v27 = 0;
      v24 += v29;
      v28 -= v29;
    }
    if (v28)
    {
      double result = memcpy(&v548[v24], (const void *)(a4 + v27), v28);
      v24 += v28;
    }
    int v30 = *v26;
    v26 += 4;
    a5 = v28 + v27 + (v30 & 0x1FFFFFF);
    --v23;
  }
  while (v23);
  if (v16 >> 7 <= 0x1A8) {
    unint64_t v31 = (unsigned __int16)v16 / 0x220u + 1;
  }
  else {
    unint64_t v31 = 100;
  }
  if (!v16)
  {
    int v20 = v531;
    a7 = v510;
    size_t v11 = v520;
LABEL_28:
    *(void *)a8 = 1;
    goto LABEL_29;
  }
  a7 = v510;
  size_t v11 = v520;
  if (v16 > 0x7F)
  {
    double result = (_DWORD *)BrotliAllocate(v540);
    if (*(_DWORD *)(v540 + 24)) {
      return result;
    }
    int v41 = result;
    uint64_t v42 = 0;
    do
    {
      bzero(&v41[v42], 0x408uLL);
      *(void *)&v41[v42 + 258] = 0x7FF0000000000000;
      v42 += 260;
    }
    while (260 * v31 != v42);
    uint64_t v43 = 0;
    LODWORD(v44) = 7;
    do
    {
      size_t v45 = v43 * v16 / v31;
      if (v43)
      {
        unint64_t v44 = (16807 * v44);
        v45 += v44 % (v16 / v31);
      }
      uint64_t v46 = 0;
      if (v45 + 70 >= v16) {
        size_t v47 = v16 - 71;
      }
      else {
        size_t v47 = v45;
      }
      int v48 = &v41[260 * v43];
      unint64_t v49 = &v548[v47];
      *((void *)v48 + 128) += 70;
      do
        ++v48[v49[v46++]];
      while (v46 != 70);
      ++v43;
    }
    while (v43 != v31);
    unint64_t v50 = v31 + 2 * v16 / 0x46 + 99 - (v31 + 2 * v16 / 0x46 + 99) % v31;
    if (v50)
    {
      unint64_t v51 = 0;
      if (v50 <= 1) {
        unint64_t v52 = 1;
      }
      else {
        unint64_t v52 = v31 + 2 * v16 / 0x46 + 99 - (v31 + 2 * v16 / 0x46 + 99) % v31;
      }
      LODWORD(v53) = 7;
      do
      {
        bzero(v552, 0x408uLL);
        unint64_t v53 = (16807 * v53);
        float32x4x2_t v54 = &v548[v53 % (v16 - 69)];
        uint64_t v55 = -70;
        do
        {
          unsigned int v56 = *v54++;
          ++*((_DWORD *)v552 + v56);
          BOOL v57 = __CFADD__(v55++, 1);
        }
        while (!v57);
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        int v60 = &v41[260 * (v51 % v31)];
        *((void *)v60 + 128) += 70;
        do
        {
          *(int32x4_t *)&v60[v59] = vaddq_s32(*(int32x4_t *)&v60[v59], *(int32x4_t *)&v552[v58]);
          v59 += 4;
          v58 += 2;
        }
        while (v58 != 128);
        ++v51;
      }
      while (v51 != v52);
    }
    int v61 = (char *)BrotliAllocate(v540);
    int v62 = (char *)BrotliAllocate(v540);
    int v63 = (void *)BrotliAllocate(v540);
    if (((v31 + 7) >> 3) * v16) {
      int v64 = (char *)BrotliAllocate(v540);
    }
    else {
      int v64 = 0;
    }
    double result = (_DWORD *)BrotliAllocate(v540);
    uint64_t v102 = 10;
    if (*(int *)(v510 + 4) <= 10) {
      uint64_t v102 = 3;
    }
    if (*(_DWORD *)(v540 + 24)) {
      return result;
    }
    __b = result;
    unsigned int v103 = 0;
    size_t v488 = v16 - 1;
    v477 = v41 + 255;
    v481 = v41 + 256;
    v469 = v61 - 2;
    int v104 = v548;
    unint64_t v486 = (unint64_t)v61;
    v515 = v41;
    v498 = (char *)v102;
    do
    {
      __src = v103;
      if (v31 > 1)
      {
        bzero(v62, v31 << 11);
        uint64_t v107 = 0;
        unsigned int v108 = v481;
        do
        {
          unint64_t v109 = *v108;
          if (v109 > 0xFF) {
            double v110 = log2((double)v109);
          }
          else {
            double v110 = kBrotliLog2Table[v109];
          }
          v108 += 260;
          *(double *)&v62[8 * v107++] = v110;
        }
        while (v31 != v107);
        unint64_t v493 = (v31 + 7) >> 3;
        unint64_t v111 = &v62[2040 * v31];
        unint64_t v112 = v477;
        uint64_t v113 = 256;
        do
        {
          uint64_t v114 = 0;
          --v113;
          unint64_t v115 = v112;
          do
          {
            double v116 = *(double *)&v62[8 * v114];
            uint64_t v117 = *v115;
            if (v117)
            {
              if (v117 > 0xFF) {
                double v118 = log2((double)v117);
              }
              else {
                double v118 = kBrotliLog2Table[v117];
              }
            }
            else
            {
              double v118 = -2.0;
            }
            v115 += 260;
            *(double *)&v111[8 * v114++] = v116 - v118;
          }
          while (v31 != v114);
          v111 -= 8 * v31;
          --v112;
        }
        while (v113);
        bzero(v63, 8 * v31);
        bzero(v64, v493 * v16);
        unint64_t v119 = 0;
        int v104 = v548;
        int v61 = (char *)v486;
        char v106 = __b;
        do
        {
          uint64_t v120 = 0;
          unint64_t v121 = &v62[8 * v31 * v548[v119]];
          double v122 = 1.0e99;
          do
          {
            double v123 = *(double *)&v121[8 * v120] + *((double *)v63 + v120);
            *((double *)v63 + v120) = v123;
            if (v123 < v122)
            {
              *(unsigned char *)(v486 + v119) = v120;
              double v122 = v123;
            }
            ++v120;
          }
          while (v31 != v120);
          double v124 = 28.1;
          if (v119 <= 0x7CF) {
            double v124 = ((double)v119 * 0.07 / 2000.0 + 0.77) * 28.1;
          }
          for (unint64_t i = 0; i != v31; ++i)
          {
            double v126 = *((double *)v63 + i) - v122;
            *((double *)v63 + i) = v126;
            if (v126 >= v124)
            {
              *((double *)v63 + i) = v124;
              v64[v119 * v493 + (i >> 3)] |= 1 << (i & 7);
            }
          }
          ++v119;
        }
        while (v119 != v16);
        unsigned int v127 = *(unsigned __int8 *)(v486 + v488);
        uint64_t v128 = &v64[(v16 - 2) * v493];
        size_t v129 = v16;
        unint64_t v105 = 1;
        do
        {
          if ((v128[(unint64_t)v127 >> 3] >> (v127 & 7)))
          {
            if (v127 != v469[v129]) {
              ++v105;
            }
            unsigned int v127 = v469[v129];
          }
          v128 -= v493;
          v469[v129--] = v127;
        }
        while (v129 != 1);
      }
      else
      {
        bzero(v61, v16);
        unint64_t v105 = 1;
        char v106 = __b;
      }
      if (v31) {
        memset_pattern16(v106, &unk_20DAD4250, 2 * v31);
      }
      uint64_t v130 = 0;
      unsigned __int16 v131 = 0;
      do
      {
        uint64_t v132 = v61[v130];
        if (*((_WORD *)v106 + v132) == 256) {
          *((_WORD *)v106 + v132) = v131++;
        }
        ++v130;
      }
      while (v16 != v130);
      for (uint64_t j = 0; j != v16; ++j)
        v61[j] = *((_WORD *)v106 + v61[j]);
      unint64_t v31 = v131;
      if (v131)
      {
        unint64_t v134 = v515;
        uint64_t v135 = v131;
        do
        {
          bzero(v134, 0x408uLL);
          v134[129] = 0x7FF0000000000000;
          v134 += 130;
          --v135;
        }
        while (v135);
      }
      for (uint64_t k = 0; k != v16; ++k)
      {
        uint64_t v137 = (char *)&v515[130 * v61[k]];
        ++*(_DWORD *)&v137[4 * v104[k]];
        ++*((void *)v137 + 128);
      }
      unsigned int v103 = __src + 1;
    }
    while (__src + 1 != v498);
    uint64_t v138 = v540;
    BrotliFree(v540, (unint64_t)v62);
    BrotliFree(v540, (unint64_t)v63);
    BrotliFree(v540, (unint64_t)v64);
    BrotliFree(v540, (unint64_t)__b);
    BrotliFree(v540, (unint64_t)v515);
    if (v105)
    {
      v462 = (_DWORD *)BrotliAllocate(v540);
      uint64_t v139 = (unsigned int *)BrotliAllocate(v540);
      unint64_t v140 = 16 * v105 + 1008;
      uint64_t v141 = v140 >> 6;
      if (v140 < 0x40)
      {
        unint64_t v142 = v140 >> 6;
        __srca = 0;
        v482 = 0;
        goto LABEL_180;
      }
    }
    else
    {
      v462 = 0;
      uint64_t v139 = 0;
      uint64_t v141 = 15;
    }
    __srca = (char *)BrotliAllocate(v540);
    unint64_t v142 = v141;
    v482 = (void *)BrotliAllocate(v540);
LABEL_180:
    uint64_t v143 = 64;
    if (v105 < 0x40) {
      uint64_t v143 = v105;
    }
    unint64_t v466 = v105;
    if (v143) {
      uint64_t v144 = BrotliAllocate(v540);
    }
    else {
      uint64_t v144 = 0;
    }
    double result = (_DWORD *)BrotliAllocate(v540);
    unint64_t __dst = result;
    long long v616 = 0u;
    long long v615 = 0u;
    long long v614 = 0u;
    long long v613 = 0u;
    long long v612 = 0u;
    long long v611 = 0u;
    long long v610 = 0u;
    long long v609 = 0u;
    long long v608 = 0u;
    long long v607 = 0u;
    long long v606 = 0u;
    long long v605 = 0u;
    long long v604 = 0u;
    long long v603 = 0u;
    long long v602 = 0u;
    long long v601 = 0u;
    long long v600 = 0u;
    long long v599 = 0u;
    long long v598 = 0u;
    long long v597 = 0u;
    long long v596 = 0u;
    long long v595 = 0u;
    long long v594 = 0u;
    long long v593 = 0u;
    long long v592 = 0u;
    long long v591 = 0u;
    long long v590 = 0u;
    long long v589 = 0u;
    long long v588 = 0u;
    long long v587 = 0u;
    long long v586 = 0u;
    long long v585 = 0u;
    long long v584 = 0u;
    long long v583 = 0u;
    long long v582 = 0u;
    long long v581 = 0u;
    long long v580 = 0u;
    long long v579 = 0u;
    long long v578 = 0u;
    long long v577 = 0u;
    long long v576 = 0u;
    long long v575 = 0u;
    long long v574 = 0u;
    long long v573 = 0u;
    long long v572 = 0u;
    long long v571 = 0u;
    long long v570 = 0u;
    long long v569 = 0u;
    long long v568 = 0u;
    long long v567 = 0u;
    long long v566 = 0u;
    long long v565 = 0u;
    long long v564 = 0u;
    long long v563 = 0u;
    long long v562 = 0u;
    long long v561 = 0u;
    long long v560 = 0u;
    long long v559 = 0u;
    long long v558 = 0u;
    long long v557 = 0u;
    long long v556 = 0u;
    long long v555 = 0u;
    long long v554 = 0u;
    long long v553 = 0u;
    int v20 = v531;
    if (*(_DWORD *)(v540 + 24)) {
      goto LABEL_186;
    }
    bzero(v139, 4 * v105);
    uint64_t v145 = 0;
    for (uint64_t m = 0; m != v16; ++m)
    {
      ++v139[v145];
      if (v488 == m || *(unsigned __int8 *)(v486 + m) != *(unsigned __int8 *)(v486 + m + 1)) {
        ++v145;
      }
    }
    if (v105)
    {
      unint64_t v147 = v105;
      unint64_t v148 = 0;
      uint64_t v149 = 0;
      unint64_t v150 = 0;
      uint64_t v494 = 0;
      v499 = 0;
      v489 = v462;
      unint64_t v151 = v466;
      uint64_t v152 = (char *)v142;
      v470 = (char *)v142;
      while (1)
      {
        v516 = v152;
        unint64_t v478 = v150;
        unint64_t v473 = v151 - 64;
        if (v151 >= 0x40) {
          uint64_t v153 = 64;
        }
        else {
          uint64_t v153 = v151;
        }
        v542 = v148;
        uint64_t v154 = v147 - (void)v148;
        if (v147 - (unint64_t)v148 >= 0x40) {
          uint64_t v154 = 64;
        }
        __ba = (void *)v154;
        if (v154)
        {
          uint64_t v155 = 0;
          do
          {
            unint64_t v156 = (void *)(v144 + 1040 * v155);
            bzero(v156, 0x408uLL);
            v156[129] = 0x7FF0000000000000;
            if (v139[(void)&v542[v155]])
            {
              unint64_t v157 = 0;
              do
              {
                ++*((_DWORD *)v156 + v548[v149 + v157++]);
                v156[128] = v157;
              }
              while (v157 < v139[(void)&v542[v155]]);
              v149 += v157;
            }
            BrotliPopulationCostLiteral(v144 + 1040 * v155);
            v156[129] = v158;
            *((_DWORD *)&v585 + v155) = v155;
            *((_DWORD *)&v569 + v155) = v155;
            *((_DWORD *)&v601 + v155++) = 1;
          }
          while (v155 != v153);
        }
        double result = (_DWORD *)BrotliHistogramCombineLiteral(v144, (uint64_t)&v601, &v569, &v585, __dst, (unint64_t)__ba, (uint64_t)__ba, 0x40uLL, 0x800uLL);
        unint64_t v159 = result;
        unint64_t v160 = v470;
        uint64_t v138 = v540;
        if (v470 < (char *)result + v494)
        {
          if (v470) {
            uint64_t v161 = (uint64_t)v470;
          }
          else {
            uint64_t v161 = (uint64_t)result + v494;
          }
          do
          {
            unint64_t v162 = (char *)v161;
            v161 *= 2;
          }
          while (v162 < (char *)result + v494);
          if (v162)
          {
            uint64_t v163 = BrotliAllocate(v540);
            unint64_t v160 = v470;
            unint64_t v164 = (char *)v163;
          }
          else
          {
            unint64_t v164 = 0;
          }
          if (*v531) {
            BOOL v165 = 1;
          }
          else {
            BOOL v165 = v160 == 0;
          }
          if (!v165) {
            memcpy(v164, __srca, 1040 * (void)v160);
          }
          double result = (_DWORD *)BrotliFree(v540, (unint64_t)__srca);
          v470 = v162;
          __srca = v164;
        }
        if (v516 < &v499[(void)v159])
        {
          if (v516) {
            uint64_t v166 = (uint64_t)v516;
          }
          else {
            uint64_t v166 = (uint64_t)&v499[(void)v159];
          }
          do
          {
            unint64_t v167 = (char *)v166;
            v166 *= 2;
          }
          while (v167 < &v499[(void)v159]);
          if (v167) {
            unint64_t v168 = (void *)BrotliAllocate(v540);
          }
          else {
            unint64_t v168 = 0;
          }
          if (*v531) {
            BOOL v169 = 1;
          }
          else {
            BOOL v169 = v516 == 0;
          }
          if (!v169) {
            memcpy(v168, v482, 4 * (void)v516);
          }
          double result = (_DWORD *)BrotliFree(v540, (unint64_t)v482);
          v516 = v167;
          v482 = v168;
        }
        int v20 = v531;
        if (*v531) {
          goto LABEL_186;
        }
        if (v159)
        {
          uint64_t v170 = 0;
          unint64_t v171 = &__srca[1040 * v494];
          do
          {
            uint64_t v172 = *((unsigned int *)&v585 + (void)v170);
            memcpy(v171, (const void *)(v144 + 1040 * v172), 0x410uLL);
            *((_DWORD *)v482 + (void)v499 + (void)v170) = *((_DWORD *)&v601 + v172);
            *((_DWORD *)&v553 + *((unsigned int *)&v585 + (void)v170)) = v170;
            uint64_t v170 = (_DWORD *)((char *)v170 + 1);
            v171 += 1040;
          }
          while (v159 != v170);
          v499 = (char *)v170 + (void)v499;
          v494 += (uint64_t)v170;
          uint64_t v138 = v540;
        }
        uint64_t v152 = v516;
        if (__ba)
        {
          uint64_t v173 = (unsigned int *)&v569;
          unint64_t v174 = v489;
          do
          {
            unsigned int v175 = *v173++;
            *v174++ = *((_DWORD *)&v553 + v175) + v478;
            --v153;
          }
          while (v153);
        }
        unint64_t v150 = (unint64_t)v159 + v478;
        unint64_t v148 = v542 + 64;
        v489 += 64;
        unint64_t v151 = v473;
        unint64_t v147 = v466;
        if ((unint64_t)(v542 + 64) >= v466) {
          goto LABEL_319;
        }
      }
    }
    unint64_t v150 = 0;
LABEL_319:
    unint64_t v224 = v150;
    double result = (_DWORD *)BrotliFree(v138, v144);
    if (v224 << 6 >= (v224 >> 1) * v224) {
      unint64_t v225 = (v224 >> 1) * v224;
    }
    else {
      unint64_t v225 = v224 << 6;
    }
    if (v225 < 0x801)
    {
      unint64_t v226 = v224;
      int v20 = v531;
    }
    else
    {
      BrotliFree(v138, (unint64_t)__dst);
      double result = (_DWORD *)BrotliAllocate(v138);
      unint64_t __dst = result;
      int v20 = v531;
      if (*(_DWORD *)(v138 + 24)) {
        goto LABEL_186;
      }
      unint64_t v226 = v224;
    }
    if (v226)
    {
      double result = (_DWORD *)BrotliAllocate(v138);
      int v20 = v531;
      if (*(_DWORD *)(v138 + 24)) {
        goto LABEL_186;
      }
      uint64_t v227 = result;
      uint64_t v228 = 0;
      do
      {
        result[v228] = v228;
        ++v228;
      }
      while (v224 != v228);
    }
    else
    {
      if (*v20) {
        goto LABEL_186;
      }
      uint64_t v227 = 0;
    }
    v543 = (char *)BrotliHistogramCombineLiteral((uint64_t)__srca, (uint64_t)v482, v462, v227, __dst, v224, v466, 0x100uLL, v225);
    BrotliFree(v138, (unint64_t)__dst);
    double result = (_DWORD *)BrotliFree(v138, (unint64_t)v482);
    if (v224)
    {
      double result = (_DWORD *)BrotliAllocate(v138);
      int v20 = v531;
      if (!*(_DWORD *)(v138 + 24))
      {
        unint64_t v229 = (unint64_t)result;
        memset(result, 255, 4 * v224);
LABEL_453:
        if (v466)
        {
          int v517 = 0;
          uint64_t v290 = 0;
          uint64_t v291 = 0;
          do
          {
            bzero(v552, 0x408uLL);
            v552[129] = 0x7FF0000000000000;
            if (v139[v290])
            {
              unint64_t v292 = 0;
              do
                ++*((_DWORD *)v552 + v548[v291 + v292++]);
              while (v292 < v139[v290]);
              v552[128] = v292;
              v291 += v292;
            }
            unint64_t v293 = v229;
            uint64_t v294 = v290 - 1;
            if (!v290) {
              uint64_t v294 = 0;
            }
            uint64_t v295 = v462[v294];
            double v296 = BrotliHistogramBitCostDistanceLiteral(v552, (uint64_t)&__srca[1040 * v295]);
            v297 = v543;
            if (v543)
            {
              double v298 = v296;
              v299 = v227;
              do
              {
                double v300 = BrotliHistogramBitCostDistanceLiteral(v552, (uint64_t)&__srca[1040 * *v299]);
                if (v300 < v298)
                {
                  uint64_t v295 = *v299;
                  double v298 = v300;
                }
                ++v299;
                --v297;
              }
              while (v297);
            }
            v462[v290] = v295;
            unint64_t v229 = v293;
            if (*(_DWORD *)(v293 + 4 * v295) == -1) {
              *(_DWORD *)(v293 + 4 * v295) = v517++;
            }
            ++v290;
          }
          while (v290 != v466);
        }
        BrotliFree(v540, (unint64_t)v227);
        double result = (_DWORD *)BrotliFree(v540, (unint64_t)__srca);
        unint64_t v301 = *(void *)(a8 + 32);
        if (v301 < v466)
        {
          if (!v301) {
            unint64_t v301 = v466;
          }
          do
          {
            unint64_t v302 = v301;
            v301 *= 2;
          }
          while (v302 < v466);
          if (v302) {
            v303 = (void *)BrotliAllocate(v540);
          }
          else {
            v303 = 0;
          }
          if (!*v531)
          {
            size_t v316 = *(void *)(a8 + 32);
            if (v316) {
              memcpy(v303, *(const void **)(a8 + 16), v316);
            }
          }
          double result = (_DWORD *)BrotliFree(v540, *(void *)(a8 + 16));
          *(void *)(a8 + 16) = v303;
          *(void *)(a8 + 32) = v302;
        }
        unint64_t v317 = *(void *)(a8 + 40);
        int v20 = v531;
        if (v317 < v466)
        {
          if (!v317) {
            unint64_t v317 = v466;
          }
          do
          {
            unint64_t v318 = v317;
            v317 *= 2;
          }
          while (v318 < v466);
          if (v318) {
            v319 = (void *)BrotliAllocate(v540);
          }
          else {
            v319 = 0;
          }
          if (!*v531)
          {
            uint64_t v320 = *(void *)(a8 + 40);
            if (v320) {
              memcpy(v319, *(const void **)(a8 + 24), 4 * v320);
            }
          }
          double result = (_DWORD *)BrotliFree(v540, *(void *)(a8 + 24));
          *(void *)(a8 + 24) = v319;
          *(void *)(a8 + 40) = v318;
          int v20 = v531;
        }
        if (!*v20)
        {
          unint64_t v321 = v466;
          if (v466)
          {
            unsigned __int8 v322 = 0;
            uint64_t v323 = 0;
            int v324 = 0;
            v325 = v462 + 1;
            v326 = (int *)v139;
            v327 = (void *)a8;
            do
            {
              int v328 = *v326++;
              v324 += v328;
              uint64_t v329 = *(v325 - 1);
              if (v321 == 1 || v329 != *v325)
              {
                int v330 = *(_DWORD *)(v229 + 4 * v329);
                *(unsigned char *)(*(void *)(a8 + 16) + v323) = v330;
                *(_DWORD *)(*(void *)(a8 + 24) + 4 * v323) = v324;
                if (v322 <= v330) {
                  unsigned __int8 v322 = v330;
                }
                ++v323;
                int v324 = 0;
              }
              ++v325;
              --v321;
            }
            while (v321);
          }
          else
          {
            uint64_t v323 = 0;
            unsigned __int8 v322 = 0;
            v327 = (void *)a8;
          }
          void *v327 = v322 + 1;
          v327[1] = v323;
          BrotliFree(v540, v229);
          BrotliFree(v540, (unint64_t)v139);
          double result = (_DWORD *)BrotliFree(v540, (unint64_t)v462);
          if (!*(_DWORD *)(v540 + 24)) {
            double result = (_DWORD *)BrotliFree(v540, v486);
          }
          int v20 = v531;
        }
      }
    }
    else
    {
      int v20 = v531;
      if (!*v531)
      {
        unint64_t v229 = 0;
        goto LABEL_453;
      }
    }
LABEL_186:
    a7 = v510;
    size_t v11 = v520;
    goto LABEL_29;
  }
  unint64_t v32 = *(void *)(a8 + 32);
  unint64_t v33 = *(void *)(a8 + 8) + 1;
  if (v32 < v33)
  {
    if (!v32) {
      unint64_t v32 = *(void *)(a8 + 8) + 1;
    }
    do
    {
      unint64_t v34 = v32;
      v32 *= 2;
    }
    while (v34 < v33);
    if (v34) {
      int v35 = (void *)BrotliAllocate(v540);
    }
    else {
      int v35 = 0;
    }
    if (!*v531)
    {
      size_t v73 = *(void *)(a8 + 32);
      if (v73) {
        memcpy(v35, *(const void **)(a8 + 16), v73);
      }
    }
    double result = (_DWORD *)BrotliFree(v540, *(void *)(a8 + 16));
    *(void *)(a8 + 16) = v35;
    *(void *)(a8 + 32) = v34;
    unint64_t v33 = *(void *)(a8 + 8) + 1;
  }
  unint64_t v74 = *(void *)(a8 + 40);
  if (v74 < v33)
  {
    if (!v74) {
      unint64_t v74 = v33;
    }
    do
    {
      unint64_t v75 = v74;
      v74 *= 2;
    }
    while (v75 < v33);
    if (v75) {
      unsigned __int8 v76 = (void *)BrotliAllocate(v540);
    }
    else {
      unsigned __int8 v76 = 0;
    }
    if (!*v531)
    {
      uint64_t v77 = *(void *)(a8 + 40);
      if (v77) {
        memcpy(v76, *(const void **)(a8 + 24), 4 * v77);
      }
    }
    double result = (_DWORD *)BrotliFree(v540, *(void *)(a8 + 24));
    *(void *)(a8 + 24) = v76;
    *(void *)(a8 + 40) = v75;
  }
  if (*v531) {
    return result;
  }
  *(void *)a8 = 1;
  *(unsigned char *)(*(void *)(a8 + 16) + *(void *)(a8 + 8)) = 0;
  uint64_t v78 = *(void *)(a8 + 8);
  *(_DWORD *)(*(void *)(a8 + 24) + 4 * v78) = v16;
  uint64_t v79 = v78 + 1;
  int v20 = v531;
  *(void *)(a8 + 8) = v79;
LABEL_29:
  if (*v20) {
    return result;
  }
  v532 = v20;
  double result = (_DWORD *)BrotliFree(v540, (unint64_t)v548);
  if (v11)
  {
    double result = (_DWORD *)BrotliAllocate(v540);
    if (*(_DWORD *)(v540 + 24)) {
      return result;
    }
    uint64_t v36 = v540;
    uint64_t v37 = 0;
    unsigned int v38 = (__int16 *)(a2 + 12);
    unint64_t v39 = (unint64_t)result;
    do
    {
      __int16 v40 = *v38;
      v38 += 8;
      *((_WORD *)result + v37++) = v40;
    }
    while (v11 != v37);
  }
  else
  {
    if (*v532) {
      return result;
    }
    unint64_t v39 = 0;
    uint64_t v36 = v540;
  }
  uint64_t v65 = a10;
  if (v11 <= 0x6783) {
    unint64_t v66 = (unsigned __int16)v11 / 0x212u + 1;
  }
  else {
    unint64_t v66 = 50;
  }
  if (!v11)
  {
    *(void *)a9 = 1;
    double result = (_DWORD *)BrotliFree(v36, v39);
    int v71 = v532;
    if (*(_DWORD *)(v36 + 24)) {
      return result;
    }
    unint64_t v72 = 0;
    goto LABEL_76;
  }
  unint64_t v538 = v39;
  if (v11 > 0x7F)
  {
    double result = (_DWORD *)BrotliAllocate(v36);
    if (*(_DWORD *)(v36 + 24)) {
      return result;
    }
    uint64_t v80 = 0;
    v541 = result;
    do
    {
      uint64_t v81 = &result[v80];
      bzero(&result[v80], 0xB08uLL);
      double result = v541;
      *((void *)v81 + 353) = 0x7FF0000000000000;
      v80 += 708;
    }
    while (708 * v66 != v80);
    uint64_t v82 = 0;
    LODWORD(v83) = 7;
    do
    {
      size_t v84 = v82 * v11 / v66;
      if (v82)
      {
        unint64_t v83 = (16807 * v83);
        v84 += v83 % (v11 / v66);
      }
      uint64_t v85 = 0;
      if (v84 + 40 >= v11) {
        size_t v86 = v11 - 41;
      }
      else {
        size_t v86 = v84;
      }
      uint64_t v87 = (char *)&v541[708 * v82];
      unint64_t v88 = v538 + 2 * v86;
      *((void *)v87 + 352) += 40;
      do
      {
        ++*(_DWORD *)&v87[4 * *(unsigned __int16 *)(v88 + v85)];
        v85 += 2;
      }
      while (v85 != 80);
      ++v82;
    }
    while (v82 != v66);
    size_t v521 = v11;
    unint64_t v89 = v66 + 2 * v11 / 0x28 + 99 - (v66 + 2 * v11 / 0x28 + 99) % v66;
    if (v89)
    {
      unint64_t v90 = 0;
      if (v89 <= 1) {
        unint64_t v91 = 1;
      }
      else {
        unint64_t v91 = v66 + 2 * v11 / 0x28 + 99 - (v66 + 2 * v11 / 0x28 + 99) % v66;
      }
      LODWORD(v92) = 7;
      do
      {
        bzero(v552, 0xB08uLL);
        unint64_t v92 = (16807 * v92);
        unsigned int v93 = (unsigned __int16 *)(v538 + 2 * (v92 % (v11 - 39)));
        uint64_t v94 = -40;
        do
        {
          unsigned int v95 = *v93++;
          ++*((_DWORD *)v552 + v95);
          BOOL v57 = __CFADD__(v94++, 1);
        }
        while (!v57);
        uint64_t v96 = 0;
        uint64_t v97 = 0;
        BOOL v98 = (char *)&v541[708 * (v90 % v66)];
        *((void *)v98 + 352) += 40;
        do
        {
          *(int32x4_t *)&v98[4 * v97] = vaddq_s32(*(int32x4_t *)&v98[4 * v97], *(int32x4_t *)&v552[v96]);
          v97 += 4;
          v96 += 2;
        }
        while (v96 != 352);
        ++v90;
      }
      while (v90 != v91);
    }
    v514 = (char *)BrotliAllocate(v540);
    int v99 = (char *)BrotliAllocate(v540);
    unsigned int v100 = (void *)BrotliAllocate(v540);
    unsigned int v101 = ((v66 + 7) >> 3) * v11 ? (char *)BrotliAllocate(v540) : 0;
    double result = (_DWORD *)BrotliAllocate(v540);
    uint64_t v184 = *(int *)(a7 + 4) <= 10 ? 3 : 10;
    if (*(_DWORD *)(v540 + 24)) {
      return result;
    }
    uint64_t v511 = a7;
    uint64_t v185 = 0;
    size_t v490 = v11 - 1;
    unint64_t v186 = (unsigned __int8 *)v514;
    v474 = v514 - 2;
    uint64_t v187 = v540;
    int v188 = result;
    v500 = (char *)v184;
    __bb = result;
    do
    {
      __srcb = v185;
      if (v66 > 1)
      {
        unint64_t v495 = (v66 + 7) >> 3;
        bzero(v99, 5632 * v66);
        uint64_t v190 = 0;
        uint64_t v191 = v541 + 704;
        do
        {
          unint64_t v192 = *v191;
          if (v192 > 0xFF) {
            double v193 = log2((double)v192);
          }
          else {
            double v193 = kBrotliLog2Table[v192];
          }
          v191 += 708;
          *(double *)&v99[8 * v190++] = v193;
        }
        while (v66 != v190);
        unint64_t v194 = &v99[5624 * v66];
        unint64_t v195 = v541 + 703;
        uint64_t v196 = 704;
        do
        {
          uint64_t v197 = 0;
          --v196;
          int v198 = v195;
          do
          {
            double v199 = *(double *)&v99[8 * v197];
            uint64_t v200 = *v198;
            if (v200)
            {
              if (v200 > 0xFF) {
                double v201 = log2((double)v200);
              }
              else {
                double v201 = kBrotliLog2Table[v200];
              }
            }
            else
            {
              double v201 = -2.0;
            }
            v198 += 708;
            *(double *)&v194[8 * v197++] = v199 - v201;
          }
          while (v66 != v197);
          v194 -= 8 * v66;
          --v195;
        }
        while (v196);
        bzero(v100, 8 * v66);
        size_t v11 = v521;
        bzero(v101, v495 * v521);
        unint64_t v202 = 0;
        uint64_t v187 = v540;
        unint64_t v186 = (unsigned __int8 *)v514;
        int v188 = __bb;
        do
        {
          uint64_t v203 = 0;
          __int16 v204 = &v99[8 * v66 * *(unsigned __int16 *)(v538 + 2 * v202)];
          double v205 = 1.0e99;
          do
          {
            double v206 = *(double *)&v204[8 * v203] + *((double *)v100 + v203);
            *((double *)v100 + v203) = v206;
            if (v206 < v205)
            {
              v514[v202] = v203;
              double v205 = v206;
            }
            ++v203;
          }
          while (v66 != v203);
          double v207 = 13.5;
          if (v202 <= 0x7CF) {
            double v207 = ((double)v202 * 0.07 / 2000.0 + 0.77) * 13.5;
          }
          for (unint64_t n = 0; n != v66; ++n)
          {
            double v209 = *((double *)v100 + n) - v205;
            *((double *)v100 + n) = v209;
            if (v209 >= v207)
            {
              *((double *)v100 + n) = v207;
              v101[v202 * v495 + (n >> 3)] |= 1 << (n & 7);
            }
          }
          ++v202;
        }
        while (v202 != v521);
        unsigned int v210 = v514[v490];
        uint64_t v211 = &v101[(v521 - 2) * v495];
        size_t v212 = v521;
        unint64_t v189 = 1;
        do
        {
          if ((v211[(unint64_t)v210 >> 3] >> (v210 & 7)))
          {
            if (v210 != v474[v212]) {
              ++v189;
            }
            unsigned int v210 = v474[v212];
          }
          v211 -= v495;
          v474[v212--] = v210;
        }
        while (v212 != 1);
      }
      else
      {
        bzero(v186, v11);
        unint64_t v189 = 1;
      }
      if (v66) {
        memset_pattern16(v188, &unk_20DAD4250, 2 * v66);
      }
      uint64_t v213 = 0;
      unsigned __int16 v214 = 0;
      do
      {
        uint64_t v215 = v186[v213];
        if (*((_WORD *)v188 + v215) == 256) {
          *((_WORD *)v188 + v215) = v214++;
        }
        ++v213;
      }
      while (v11 != v213);
      for (iunint64_t i = 0; ii != v11; ++ii)
        v186[ii] = *((_WORD *)v188 + v186[ii]);
      unint64_t v66 = v214;
      if (v214)
      {
        uint64_t v217 = v541;
        uint64_t v218 = v214;
        do
        {
          bzero(v217, 0xB08uLL);
          v217[353] = 0x7FF0000000000000;
          v217 += 354;
          --v218;
        }
        while (v218);
      }
      uint64_t v219 = 0;
      unint64_t v186 = (unsigned __int8 *)v514;
      do
      {
        unint64_t v220 = (char *)&v541[708 * v514[v219]];
        ++*(_DWORD *)&v220[4 * *(unsigned __int16 *)(v538 + 2 * v219)];
        ++*((void *)v220 + 352);
        ++v219;
      }
      while (v11 != v219);
      uint64_t v185 = __srcb + 1;
      int v188 = __bb;
    }
    while (__srcb + 1 != v500);
    BrotliFree(v187, (unint64_t)v99);
    BrotliFree(v187, (unint64_t)v100);
    BrotliFree(v187, (unint64_t)v101);
    BrotliFree(v187, (unint64_t)__bb);
    BrotliFree(v187, (unint64_t)v541);
    if (v189)
    {
      v461 = (_DWORD *)BrotliAllocate(v187);
      unint64_t v221 = (unsigned int *)BrotliAllocate(v187);
      unint64_t v222 = 16 * v189 + 1008;
      uint64_t v223 = v222 >> 6;
      if (v222 < 0x40)
      {
        unint64_t v471 = v222 >> 6;
        __srcc = 0;
        v483 = 0;
        goto LABEL_338;
      }
    }
    else
    {
      v461 = 0;
      unint64_t v221 = 0;
      uint64_t v223 = 15;
    }
    __srcc = (char *)BrotliAllocate(v187);
    unint64_t v471 = v223;
    v483 = (void *)BrotliAllocate(v187);
LABEL_338:
    uint64_t v230 = 64;
    if (v189 < 0x40) {
      uint64_t v230 = v189;
    }
    if (v230) {
      v549 = (void *)BrotliAllocate(v187);
    }
    else {
      v549 = 0;
    }
    double result = (_DWORD *)BrotliAllocate(v187);
    v467 = result;
    long long v616 = 0u;
    long long v615 = 0u;
    long long v614 = 0u;
    long long v613 = 0u;
    long long v612 = 0u;
    long long v611 = 0u;
    long long v610 = 0u;
    long long v609 = 0u;
    long long v608 = 0u;
    long long v607 = 0u;
    long long v606 = 0u;
    long long v605 = 0u;
    long long v604 = 0u;
    long long v603 = 0u;
    long long v602 = 0u;
    long long v601 = 0u;
    long long v600 = 0u;
    long long v599 = 0u;
    long long v598 = 0u;
    long long v597 = 0u;
    long long v596 = 0u;
    long long v595 = 0u;
    long long v594 = 0u;
    long long v593 = 0u;
    long long v592 = 0u;
    long long v591 = 0u;
    long long v590 = 0u;
    long long v589 = 0u;
    long long v588 = 0u;
    long long v587 = 0u;
    long long v586 = 0u;
    long long v585 = 0u;
    long long v584 = 0u;
    long long v583 = 0u;
    long long v582 = 0u;
    long long v581 = 0u;
    long long v580 = 0u;
    long long v579 = 0u;
    long long v578 = 0u;
    long long v577 = 0u;
    long long v576 = 0u;
    long long v575 = 0u;
    long long v574 = 0u;
    long long v573 = 0u;
    long long v572 = 0u;
    long long v571 = 0u;
    long long v570 = 0u;
    long long v569 = 0u;
    long long v568 = 0u;
    long long v567 = 0u;
    long long v566 = 0u;
    long long v565 = 0u;
    long long v564 = 0u;
    long long v563 = 0u;
    long long v562 = 0u;
    long long v561 = 0u;
    long long v560 = 0u;
    long long v559 = 0u;
    long long v558 = 0u;
    long long v557 = 0u;
    long long v556 = 0u;
    long long v555 = 0u;
    long long v554 = 0u;
    long long v553 = 0u;
    unint64_t v183 = v532;
    if (*(_DWORD *)(v187 + 24)) {
      goto LABEL_344;
    }
    bzero(v221, 4 * v189);
    uint64_t v238 = 0;
    uint64_t v239 = 0;
    unint64_t v240 = v538;
    do
    {
      ++v221[v238];
      if (v490 == v239 || v514[v239] != v514[v239 + 1]) {
        ++v238;
      }
      ++v239;
    }
    while (v11 != v239);
    if (v189)
    {
      long long v241 = 0;
      uint64_t v242 = 0;
      unint64_t v243 = 0;
      uint64_t v496 = 0;
      v501 = 0;
      v491 = v461;
      unint64_t v244 = v189;
      unint64_t v487 = v471;
      unint64_t v245 = (unint64_t)v549;
      while (1)
      {
        unint64_t v475 = v244 - 64;
        unint64_t v479 = v243;
        if (v244 >= 0x40) {
          uint64_t v246 = 64;
        }
        else {
          uint64_t v246 = v244;
        }
        v544 = v241;
        uint64_t v247 = v189 - (void)v241;
        if (v189 - (unint64_t)v241 >= 0x40) {
          uint64_t v247 = 64;
        }
        __bc = (void *)v247;
        if (v247)
        {
          uint64_t v248 = 0;
          do
          {
            long long v249 = (void *)(v245 + 2832 * v248);
            bzero(v249, 0xB08uLL);
            v249[353] = 0x7FF0000000000000;
            if (v221[(void)&v544[v248]])
            {
              unint64_t v250 = 0;
              do
                ++*((_DWORD *)v249 + *(unsigned __int16 *)(v240 + 2 * v242 + 2 * v250++));
              while (v250 < v221[(void)&v544[v248]]);
              v249[352] = v250;
              v242 += v250;
            }
            BrotliPopulationCostCommand((uint64_t)v249);
            v249[353] = v251;
            *((_DWORD *)&v585 + v248) = v248;
            *((_DWORD *)&v569 + v248) = v248;
            *((_DWORD *)&v601 + v248++) = 1;
            size_t v11 = v521;
            unint64_t v245 = (unint64_t)v549;
          }
          while (v248 != v246);
        }
        double result = (_DWORD *)BrotliHistogramCombineCommand(v245, (uint64_t)&v601, &v569, &v585, v467, (unint64_t)__bc, (uint64_t)__bc, 0x40uLL, 0x800uLL);
        long long v252 = result;
        long long v253 = (char *)v487;
        uint64_t v187 = v540;
        if (v487 >= (unint64_t)result + v496)
        {
          long long v255 = (char *)v471;
        }
        else
        {
          if (v487) {
            uint64_t v254 = v487;
          }
          else {
            uint64_t v254 = (uint64_t)result + v496;
          }
          long long v255 = (char *)v471;
          do
          {
            long long v253 = (char *)v254;
            v254 *= 2;
          }
          while (v253 < (char *)result + v496);
          if (v253) {
            __dsta = (char *)BrotliAllocate(v540);
          }
          else {
            __dsta = 0;
          }
          if (*v532) {
            BOOL v256 = 1;
          }
          else {
            BOOL v256 = v487 == 0;
          }
          if (!v256) {
            memcpy(__dsta, __srcc, 2832 * v487);
          }
          double result = (_DWORD *)BrotliFree(v540, (unint64_t)__srcc);
          __srcc = __dsta;
        }
        unint64_t v487 = (unint64_t)v253;
        if (v255 < &v501[(void)v252])
        {
          if (v255) {
            uint64_t v257 = (uint64_t)v255;
          }
          else {
            uint64_t v257 = (uint64_t)&v501[(void)v252];
          }
          do
          {
            long long v258 = (char *)v257;
            v257 *= 2;
          }
          while (v258 < &v501[(void)v252]);
          if (v258) {
            long long v259 = (void *)BrotliAllocate(v540);
          }
          else {
            long long v259 = 0;
          }
          if (*v532) {
            BOOL v260 = 1;
          }
          else {
            BOOL v260 = v255 == 0;
          }
          if (!v260) {
            memcpy(v259, v483, 4 * (void)v255);
          }
          double result = (_DWORD *)BrotliFree(v540, (unint64_t)v483);
          unint64_t v471 = (unint64_t)v258;
          uint64_t v187 = v540;
          v483 = v259;
        }
        unint64_t v183 = v532;
        if (*v532) {
          goto LABEL_344;
        }
        if (v252)
        {
          long long v261 = 0;
          long long v262 = &__srcc[2832 * v496];
          unint64_t v245 = (unint64_t)v549;
          do
          {
            uint64_t v263 = *((unsigned int *)&v585 + (void)v261);
            memcpy(v262, (const void *)(v245 + 2832 * v263), 0xB10uLL);
            unint64_t v245 = (unint64_t)v549;
            *((_DWORD *)v483 + (void)v501 + (void)v261) = *((_DWORD *)&v601 + v263);
            *((_DWORD *)&v553 + *((unsigned int *)&v585 + (void)v261)) = v261;
            long long v261 = (_DWORD *)((char *)v261 + 1);
            v262 += 2832;
          }
          while (v252 != v261);
          v501 = (char *)v261 + (void)v501;
          v496 += (uint64_t)v261;
          uint64_t v187 = v540;
          size_t v11 = v521;
        }
        else
        {
          unint64_t v245 = (unint64_t)v549;
        }
        unint64_t v240 = v538;
        if (__bc)
        {
          long long v264 = (unsigned int *)&v569;
          long long v265 = v491;
          do
          {
            unsigned int v266 = *v264++;
            *v265++ = *((_DWORD *)&v553 + v266) + v479;
            --v246;
          }
          while (v246);
        }
        unint64_t v243 = (unint64_t)v252 + v479;
        long long v241 = v544 + 64;
        v491 += 64;
        unint64_t v244 = v475;
        if ((unint64_t)(v544 + 64) >= v189) {
          goto LABEL_476;
        }
      }
    }
    unint64_t v243 = 0;
    unint64_t v245 = (unint64_t)v549;
LABEL_476:
    unint64_t v304 = v243;
    double result = (_DWORD *)BrotliFree(v187, v245);
    if (v304 << 6 >= (v304 >> 1) * v304) {
      unint64_t v305 = (v304 >> 1) * v304;
    }
    else {
      unint64_t v305 = v304 << 6;
    }
    if (v305 >= 0x801)
    {
      BrotliFree(v187, (unint64_t)v467);
      double result = (_DWORD *)BrotliAllocate(v187);
      v467 = result;
      unint64_t v183 = v532;
      if (*(_DWORD *)(v187 + 24)) {
        goto LABEL_344;
      }
    }
    if (v304)
    {
      double result = (_DWORD *)BrotliAllocate(v187);
      unint64_t v183 = v532;
      if (*(_DWORD *)(v187 + 24)) {
        goto LABEL_344;
      }
      v306 = result;
      for (juint64_t j = 0; jj != v304; ++jj)
        result[jj] = jj;
    }
    else
    {
      unint64_t v183 = v532;
      if (*v532) {
        goto LABEL_344;
      }
      v306 = 0;
    }
    v546 = (char *)BrotliHistogramCombineCommand((uint64_t)__srcc, (uint64_t)v483, v461, v306, v467, v304, v189, 0x100uLL, v305);
    BrotliFree(v187, (unint64_t)v467);
    double result = (_DWORD *)BrotliFree(v187, (unint64_t)v483);
    if (v304)
    {
      size_t v308 = 4 * v304;
      double result = (_DWORD *)BrotliAllocate(v187);
      v550 = result;
      unint64_t v183 = v532;
      size_t v11 = v521;
      if (*(_DWORD *)(v187 + 24)) {
        goto LABEL_344;
      }
      memset(result, 255, v308);
    }
    else
    {
      unint64_t v183 = v532;
      size_t v11 = v521;
      if (*v532) {
        goto LABEL_344;
      }
      v550 = 0;
    }
    if (v189)
    {
      int __be = 0;
      uint64_t v331 = 0;
      uint64_t v332 = 0;
      do
      {
        bzero(v552, 0xB08uLL);
        v552[353] = 0x7FF0000000000000;
        if (v221[v331])
        {
          unint64_t v333 = 0;
          do
            ++*((_DWORD *)v552 + *(unsigned __int16 *)(v538 + 2 * v332 + 2 * v333++));
          while (v333 < v221[v331]);
          v552[352] = v333;
          v332 += v333;
        }
        uint64_t v334 = v331 - 1;
        if (!v331) {
          uint64_t v334 = 0;
        }
        uint64_t v335 = v461[v334];
        double v336 = BrotliHistogramBitCostDistanceCommand(v552, (uint64_t)&__srcc[2832 * v335]);
        v337 = v546;
        if (v546)
        {
          double v338 = v336;
          v339 = v306;
          do
          {
            double v340 = BrotliHistogramBitCostDistanceCommand(v552, (uint64_t)&__srcc[2832 * *v339]);
            if (v340 < v338)
            {
              uint64_t v335 = *v339;
              double v338 = v340;
            }
            ++v339;
            --v337;
          }
          while (v337);
        }
        v461[v331] = v335;
        if (v550[v335] == -1) {
          v550[v335] = __be++;
        }
        ++v331;
      }
      while (v331 != v189);
    }
    BrotliFree(v540, (unint64_t)v306);
    double result = (_DWORD *)BrotliFree(v540, (unint64_t)__srcc);
    unint64_t v341 = *(void *)(a9 + 32);
    if (v341 < v189)
    {
      if (!v341) {
        unint64_t v341 = v189;
      }
      do
      {
        unint64_t v342 = v341;
        v341 *= 2;
      }
      while (v342 < v189);
      if (v342) {
        v343 = (void *)BrotliAllocate(v540);
      }
      else {
        v343 = 0;
      }
      if (!*v532)
      {
        size_t v416 = *(void *)(a9 + 32);
        if (v416) {
          memcpy(v343, *(const void **)(a9 + 16), v416);
        }
      }
      double result = (_DWORD *)BrotliFree(v540, *(void *)(a9 + 16));
      *(void *)(a9 + 16) = v343;
      *(void *)(a9 + 32) = v342;
    }
    unint64_t v417 = *(void *)(a9 + 40);
    if (v417 < v189)
    {
      if (!v417) {
        unint64_t v417 = v189;
      }
      do
      {
        unint64_t v418 = v417;
        v417 *= 2;
      }
      while (v418 < v189);
      if (v418) {
        v419 = (void *)BrotliAllocate(v540);
      }
      else {
        v419 = 0;
      }
      if (!*v532)
      {
        uint64_t v420 = *(void *)(a9 + 40);
        if (v420) {
          memcpy(v419, *(const void **)(a9 + 24), 4 * v420);
        }
      }
      double result = (_DWORD *)BrotliFree(v540, *(void *)(a9 + 24));
      *(void *)(a9 + 24) = v419;
      *(void *)(a9 + 40) = v418;
    }
    unint64_t v183 = v532;
    size_t v11 = v521;
    if (!*v532)
    {
      if (v189)
      {
        unsigned __int8 v421 = 0;
        uint64_t v422 = 0;
        int v423 = 0;
        v424 = v461 + 1;
        v425 = (int *)v221;
        do
        {
          int v426 = *v425++;
          v423 += v426;
          uint64_t v427 = *(v424 - 1);
          if (v189 == 1 || v427 != *v424)
          {
            int v428 = v550[v427];
            *(unsigned char *)(*(void *)(a9 + 16) + v422) = v428;
            *(_DWORD *)(*(void *)(a9 + 24) + 4 * v422) = v423;
            if (v421 <= v428) {
              unsigned __int8 v421 = v428;
            }
            ++v422;
            int v423 = 0;
          }
          ++v424;
          --v189;
        }
        while (v189);
      }
      else
      {
        uint64_t v422 = 0;
        unsigned __int8 v421 = 0;
      }
      *(void *)a9 = v421 + 1;
      *(void *)(a9 + 8) = v422;
      BrotliFree(v540, (unint64_t)v550);
      BrotliFree(v540, (unint64_t)v221);
      double result = (_DWORD *)BrotliFree(v540, (unint64_t)v461);
      unint64_t v183 = v532;
      a7 = v511;
      size_t v11 = v521;
      uint64_t v65 = a10;
      if (!*(_DWORD *)(v540 + 24))
      {
        double result = (_DWORD *)BrotliFree(v540, (unint64_t)v514);
        unint64_t v183 = v532;
      }
      goto LABEL_345;
    }
LABEL_344:
    a7 = v511;
    uint64_t v65 = a10;
    goto LABEL_345;
  }
  unint64_t v67 = *(void *)(a9 + 32);
  unint64_t v68 = *(void *)(a9 + 8) + 1;
  if (v67 < v68)
  {
    if (!v67) {
      unint64_t v67 = *(void *)(a9 + 8) + 1;
    }
    do
    {
      unint64_t v69 = v67;
      v67 *= 2;
    }
    while (v69 < v68);
    if (v69)
    {
      uint64_t v70 = (void *)BrotliAllocate(v36);
      if (*(_DWORD *)(v36 + 24))
      {
LABEL_247:
        double result = (_DWORD *)BrotliFree(v36, *(void *)(a9 + 16));
        *(void *)(a9 + 16) = v70;
        *(void *)(a9 + 32) = v69;
        unint64_t v68 = *(void *)(a9 + 8) + 1;
        goto LABEL_248;
      }
    }
    else
    {
      uint64_t v70 = 0;
    }
    size_t v176 = *(void *)(a9 + 32);
    if (v176) {
      memcpy(v70, *(const void **)(a9 + 16), v176);
    }
    goto LABEL_247;
  }
LABEL_248:
  unint64_t v177 = *(void *)(a9 + 40);
  if (v177 < v68)
  {
    if (!v177) {
      unint64_t v177 = v68;
    }
    do
    {
      unint64_t v178 = v177;
      v177 *= 2;
    }
    while (v178 < v68);
    if (v178) {
      unint64_t v179 = (void *)BrotliAllocate(v36);
    }
    else {
      unint64_t v179 = 0;
    }
    if (!*v532)
    {
      uint64_t v180 = *(void *)(a9 + 40);
      if (v180) {
        memcpy(v179, *(const void **)(a9 + 24), 4 * v180);
      }
    }
    double result = (_DWORD *)BrotliFree(v36, *(void *)(a9 + 24));
    *(void *)(a9 + 24) = v179;
    *(void *)(a9 + 40) = v178;
  }
  if (*v532) {
    return result;
  }
  *(void *)a9 = 1;
  *(unsigned char *)(*(void *)(a9 + 16) + *(void *)(a9 + 8)) = 0;
  uint64_t v181 = *(void *)(a9 + 8);
  *(_DWORD *)(*(void *)(a9 + 24) + 4 * v181) = v11;
  uint64_t v182 = v181 + 1;
  unint64_t v183 = v532;
  *(void *)(a9 + 8) = v182;
LABEL_345:
  if (*v183) {
    return result;
  }
  BrotliFree(v540, v538);
  double result = (_DWORD *)BrotliAllocate(v540);
  if (*(_DWORD *)(v540 + 24)) {
    return result;
  }
  unint64_t v72 = (unint64_t)result;
  unint64_t v231 = 0;
  unint64_t v232 = (unsigned __int16 *)(a2 + 12);
  do
  {
    if ((*((_DWORD *)v232 - 2) & 0x1FFFFFF) != 0 && *v232 >= 0x80u) {
      *((_WORD *)result + v231++) = v232[1] & 0x3FF;
    }
    v232 += 8;
    --v11;
  }
  while (v11);
  if (v231 >> 6 <= 0x1A8) {
    unint64_t v233 = (unsigned __int16)v231 / 0x220u + 1;
  }
  else {
    unint64_t v233 = 50;
  }
  if (!v231)
  {
    int v71 = v532;
LABEL_76:
    *(void *)uint64_t v65 = 1;
    goto LABEL_77;
  }
  size_t v534 = v231;
  if (v231 > 0x7F)
  {
    double result = (_DWORD *)BrotliAllocate(v540);
    if (*(_DWORD *)(v540 + 24)) {
      return result;
    }
    unint64_t v539 = v72;
    uint64_t v463 = v65;
    uint64_t v267 = a7;
    uint64_t v268 = 0;
    v545 = result;
    do
    {
      long long v269 = &result[v268];
      bzero(&result[v268], 0x888uLL);
      double result = v545;
      *((void *)v269 + 273) = 0x7FF0000000000000;
      v268 += 548;
    }
    while (548 * v233 != v268);
    uint64_t v270 = 0;
    LODWORD(v271) = 7;
    do
    {
      size_t v272 = v270 * v534 / v233;
      if (v270)
      {
        unint64_t v271 = (16807 * v271);
        v272 += v271 % (v534 / v233);
      }
      uint64_t v273 = 0;
      if (v272 + 40 >= v534) {
        size_t v274 = v534 - 41;
      }
      else {
        size_t v274 = v272;
      }
      v275 = (char *)&v545[548 * v270];
      unint64_t v276 = v72 + 2 * v274;
      *((void *)v275 + 272) += 40;
      do
      {
        ++*(_DWORD *)&v275[4 * *(unsigned __int16 *)(v276 + v273)];
        v273 += 2;
      }
      while (v273 != 80);
      ++v270;
    }
    while (v270 != v233);
    unint64_t v277 = v233 + 2 * v534 / 0x28 + 99 - (v233 + 2 * v534 / 0x28 + 99) % v233;
    if (v277)
    {
      unint64_t v278 = 0;
      if (v277 <= 1) {
        unint64_t v279 = 1;
      }
      else {
        unint64_t v279 = v233 + 2 * v534 / 0x28 + 99 - (v233 + 2 * v534 / 0x28 + 99) % v233;
      }
      LODWORD(v280) = 7;
      do
      {
        bzero(v552, 0x888uLL);
        unint64_t v280 = (16807 * v280);
        v281 = (unsigned __int16 *)(v539 + 2 * (v280 % (v534 - 39)));
        uint64_t v282 = -40;
        do
        {
          unsigned int v283 = *v281++;
          ++*((_DWORD *)v552 + v283);
          BOOL v57 = __CFADD__(v282++, 1);
        }
        while (!v57);
        uint64_t v284 = 0;
        uint64_t v285 = 0;
        v286 = (char *)&v545[548 * (v278 % v233)];
        *((void *)v286 + 272) += 40;
        do
        {
          *(int32x4_t *)&v286[4 * v285] = vaddq_s32(*(int32x4_t *)&v286[4 * v285], *(int32x4_t *)&v552[v284]);
          v285 += 4;
          v284 += 2;
        }
        while (v284 != 272);
        ++v278;
      }
      while (v278 != v279);
    }
    __bd = (char *)BrotliAllocate(v540);
    v287 = (char *)BrotliAllocate(v540);
    v288 = (void *)BrotliAllocate(v540);
    if (((v233 + 7) >> 3) * v534) {
      v289 = (char *)BrotliAllocate(v540);
    }
    else {
      v289 = 0;
    }
    double result = (_DWORD *)BrotliAllocate(v540);
    v502 = result;
    uint64_t v344 = 3;
    if (*(int *)(v267 + 4) > 10) {
      uint64_t v344 = 10;
    }
    v522 = (char *)v344;
    if (*(_DWORD *)(v540 + 24)) {
      return result;
    }
    v345 = 0;
    size_t v346 = v534;
    size_t v512 = v534 - 1;
    v348 = result;
    v347 = (unsigned __int8 *)__bd;
    v484 = __bd - 2;
    do
    {
      __srcd = v345;
      if (v233 > 1)
      {
        bzero(v287, 4352 * v233);
        uint64_t v350 = 0;
        v351 = v545 + 544;
        do
        {
          unint64_t v352 = *v351;
          if (v352 > 0xFF) {
            double v353 = log2((double)v352);
          }
          else {
            double v353 = kBrotliLog2Table[v352];
          }
          v351 += 548;
          *(double *)&v287[8 * v350++] = v353;
        }
        while (v233 != v350);
        unint64_t v518 = (v233 + 7) >> 3;
        v354 = &v287[4344 * v233];
        v355 = v545 + 543;
        uint64_t v356 = 544;
        do
        {
          uint64_t v357 = 0;
          --v356;
          v358 = v355;
          do
          {
            double v359 = *(double *)&v287[8 * v357];
            uint64_t v360 = *v358;
            if (v360)
            {
              if (v360 > 0xFF) {
                double v361 = log2((double)v360);
              }
              else {
                double v361 = kBrotliLog2Table[v360];
              }
            }
            else
            {
              double v361 = -2.0;
            }
            v358 += 548;
            *(double *)&v354[8 * v357++] = v359 - v361;
          }
          while (v233 != v357);
          v354 -= 8 * v233;
          --v355;
        }
        while (v356);
        bzero(v288, 8 * v233);
        bzero(v289, v518 * v534);
        unint64_t v362 = 0;
        v348 = v502;
        v347 = (unsigned __int8 *)__bd;
        do
        {
          uint64_t v363 = 0;
          v364 = &v287[8 * v233 * *(unsigned __int16 *)(v539 + 2 * v362)];
          double v365 = 1.0e99;
          do
          {
            double v366 = *(double *)&v364[8 * v363] + *((double *)v288 + v363);
            *((double *)v288 + v363) = v366;
            if (v366 < v365)
            {
              __bd[v362] = v363;
              double v365 = v366;
            }
            ++v363;
          }
          while (v233 != v363);
          double v367 = 14.6;
          if (v362 <= 0x7CF) {
            double v367 = ((double)v362 * 0.07 / 2000.0 + 0.77) * 14.6;
          }
          for (kuint64_t k = 0; kk != v233; ++kk)
          {
            double v369 = *((double *)v288 + kk) - v365;
            *((double *)v288 + kk) = v369;
            if (v369 >= v367)
            {
              *((double *)v288 + kk) = v367;
              v289[v362 * v518 + (kk >> 3)] |= 1 << (kk & 7);
            }
          }
          ++v362;
        }
        while (v362 != v534);
        unsigned int v370 = __bd[v512];
        v371 = &v289[(v534 - 2) * v518];
        size_t v372 = v534;
        unint64_t v349 = 1;
        do
        {
          if ((v371[(unint64_t)v370 >> 3] >> (v370 & 7)))
          {
            if (v370 != v484[v372]) {
              ++v349;
            }
            unsigned int v370 = v484[v372];
          }
          v371 -= v518;
          v484[v372--] = v370;
        }
        while (v372 != 1);
      }
      else
      {
        bzero(v347, v346);
        unint64_t v349 = 1;
      }
      if (v233) {
        memset_pattern16(v348, &unk_20DAD4250, 2 * v233);
      }
      uint64_t v373 = 0;
      unsigned __int16 v374 = 0;
      do
      {
        uint64_t v375 = v347[v373];
        if (*((_WORD *)v348 + v375) == 256) {
          *((_WORD *)v348 + v375) = v374++;
        }
        ++v373;
      }
      while (v534 != v373);
      v551 = (char *)v349;
      for (muint64_t m = 0; mm != v534; ++mm)
        v347[mm] = *((_WORD *)v348 + v347[mm]);
      unint64_t v233 = v374;
      if (v374)
      {
        v377 = v545;
        uint64_t v378 = v374;
        do
        {
          bzero(v377, 0x888uLL);
          v377[273] = 0x7FF0000000000000;
          v377 += 274;
          --v378;
        }
        while (v378);
      }
      uint64_t v379 = 0;
      size_t v346 = v534;
      do
      {
        v380 = (char *)&v545[548 * v347[v379]];
        ++*(_DWORD *)&v380[4 * *(unsigned __int16 *)(v539 + 2 * v379)];
        ++*((void *)v380 + 272);
        ++v379;
      }
      while (v534 != v379);
      v345 = __srcd + 1;
    }
    while (__srcd + 1 != v522);
    BrotliFree(v540, (unint64_t)v287);
    BrotliFree(v540, (unint64_t)v288);
    BrotliFree(v540, (unint64_t)v289);
    BrotliFree(v540, (unint64_t)v348);
    BrotliFree(v540, (unint64_t)v545);
    if (v349)
    {
      v468 = (_DWORD *)BrotliAllocate(v540);
      v381 = (unsigned int *)BrotliAllocate(v540);
      unint64_t v382 = 16 * v349 + 1008;
      unint64_t __srce = v382 >> 6;
      if (v382 < 0x40)
      {
        v547 = 0;
        v503 = 0;
        goto LABEL_620;
      }
    }
    else
    {
      v468 = 0;
      v381 = 0;
      unint64_t __srce = 15;
    }
    v547 = (char *)BrotliAllocate(v540);
    v503 = (void *)BrotliAllocate(v540);
LABEL_620:
    uint64_t v383 = 64;
    if (v349 < 0x40) {
      uint64_t v383 = v349;
    }
    if (v383) {
      uint64_t v476 = BrotliAllocate(v540);
    }
    else {
      uint64_t v476 = 0;
    }
    double result = (_DWORD *)BrotliAllocate(v540);
    v472 = result;
    long long v616 = 0u;
    long long v615 = 0u;
    long long v614 = 0u;
    long long v613 = 0u;
    long long v612 = 0u;
    long long v611 = 0u;
    long long v610 = 0u;
    long long v609 = 0u;
    long long v608 = 0u;
    long long v607 = 0u;
    long long v606 = 0u;
    long long v605 = 0u;
    long long v604 = 0u;
    long long v603 = 0u;
    long long v602 = 0u;
    long long v601 = 0u;
    long long v600 = 0u;
    long long v599 = 0u;
    long long v598 = 0u;
    long long v597 = 0u;
    long long v596 = 0u;
    long long v595 = 0u;
    long long v594 = 0u;
    long long v593 = 0u;
    long long v592 = 0u;
    long long v591 = 0u;
    long long v590 = 0u;
    long long v589 = 0u;
    long long v588 = 0u;
    long long v587 = 0u;
    long long v586 = 0u;
    long long v585 = 0u;
    long long v584 = 0u;
    long long v583 = 0u;
    long long v582 = 0u;
    long long v581 = 0u;
    long long v580 = 0u;
    long long v579 = 0u;
    long long v578 = 0u;
    long long v577 = 0u;
    long long v576 = 0u;
    long long v575 = 0u;
    long long v574 = 0u;
    long long v573 = 0u;
    long long v572 = 0u;
    long long v571 = 0u;
    long long v570 = 0u;
    long long v569 = 0u;
    long long v568 = 0u;
    long long v567 = 0u;
    long long v566 = 0u;
    long long v565 = 0u;
    long long v564 = 0u;
    long long v563 = 0u;
    long long v562 = 0u;
    long long v561 = 0u;
    long long v560 = 0u;
    long long v559 = 0u;
    long long v558 = 0u;
    long long v557 = 0u;
    long long v556 = 0u;
    long long v555 = 0u;
    long long v554 = 0u;
    long long v553 = 0u;
    int v71 = v532;
    if (*(_DWORD *)(v540 + 24)) {
      goto LABEL_626;
    }
    bzero(v381, 4 * v349);
    uint64_t v384 = 0;
    for (nunint64_t n = 0; nn != v534; ++nn)
    {
      ++v381[v384];
      if (v512 == nn || __bd[nn] != __bd[nn + 1]) {
        ++v384;
      }
    }
    if (v349)
    {
      uint64_t v386 = 0;
      uint64_t v387 = 0;
      unint64_t v388 = 0;
      v519 = 0;
      uint64_t v523 = 0;
      v389 = (char *)v468;
      v390 = v551;
      unint64_t v391 = (unint64_t)v551;
      unint64_t v513 = __srce;
      unint64_t v392 = v476;
      while (1)
      {
        unint64_t v480 = v391 - 64;
        v485 = v389;
        if (v391 >= 0x40) {
          uint64_t v393 = 64;
        }
        else {
          uint64_t v393 = v391;
        }
        uint64_t v394 = (uint64_t)&v390[-v386];
        if ((unint64_t)&v390[-v386] >= 0x40) {
          uint64_t v394 = 64;
        }
        size_t v535 = v394;
        if (v394)
        {
          uint64_t v395 = 0;
          do
          {
            v396 = (void *)(v392 + 2192 * v395);
            bzero(v396, 0x888uLL);
            v396[273] = 0x7FF0000000000000;
            if (v381[v395 + v386])
            {
              unint64_t v397 = 0;
              do
                ++*((_DWORD *)v396 + *(unsigned __int16 *)(v539 + 2 * v387 + 2 * v397++));
              while (v397 < v381[v395 + v386]);
              v396[272] = v397;
              v387 += v397;
            }
            BrotliPopulationCostDistance(v392 + 2192 * v395);
            v396[273] = v398;
            *((_DWORD *)&v585 + v395) = v395;
            *((_DWORD *)&v569 + v395) = v395;
            *((_DWORD *)&v601 + v395++) = 1;
          }
          while (v395 != v393);
        }
        double result = (_DWORD *)BrotliHistogramCombineDistance(v392, (uint64_t)&v601, &v569, &v585, v472, v535, v535, 0x40uLL, 0x800uLL);
        uint64_t v492 = v386;
        unint64_t v497 = v388;
        if ((char *)v513 < (char *)v519 + (unint64_t)result)
        {
          v399 = result;
          unint64_t v400 = v513;
          if (!v513) {
            unint64_t v400 = (unint64_t)v519 + (void)result;
          }
          do
          {
            v401 = (char *)v400;
            v400 *= 2;
          }
          while (v401 < (char *)v519 + (unint64_t)result);
          if (v401) {
            v402 = (char *)BrotliAllocate(v540);
          }
          else {
            v402 = 0;
          }
          if (*v532) {
            BOOL v403 = 1;
          }
          else {
            BOOL v403 = v513 == 0;
          }
          if (!v403) {
            memcpy(v402, v547, 2192 * v513);
          }
          BrotliFree(v540, (unint64_t)v547);
          unint64_t v513 = (unint64_t)v401;
          v547 = v402;
          double result = v399;
        }
        if (__srce < (unint64_t)result + v523)
        {
          v404 = result;
          unint64_t v405 = __srce;
          if (!__srce) {
            unint64_t v405 = (unint64_t)result + v523;
          }
          do
          {
            unint64_t v406 = v405;
            v405 *= 2;
          }
          while (v406 < (unint64_t)result + v523);
          if (v406) {
            v407 = (void *)BrotliAllocate(v540);
          }
          else {
            v407 = 0;
          }
          if (*v532) {
            BOOL v408 = 1;
          }
          else {
            BOOL v408 = __srce == 0;
          }
          if (!v408) {
            memcpy(v407, v503, 4 * __srce);
          }
          BrotliFree(v540, (unint64_t)v503);
          unint64_t __srce = v406;
          v503 = v407;
          double result = v404;
        }
        int v71 = v532;
        if (*v532) {
          goto LABEL_626;
        }
        if (result)
        {
          v409 = 0;
          v410 = &v547[2192 * (void)v519];
          do
          {
            uint64_t v411 = *((unsigned int *)&v585 + (void)v409);
            v412 = result;
            memcpy(v410, (const void *)(v476 + 2192 * v411), 0x890uLL);
            double result = v412;
            *((_DWORD *)v503 + v523 + (void)v409) = *((_DWORD *)&v601 + v411);
            *((_DWORD *)&v553 + *((unsigned int *)&v585 + (void)v409)) = v409;
            v409 = (_DWORD *)((char *)v409 + 1);
            v410 += 2192;
          }
          while (v412 != v409);
          v523 += (uint64_t)v409;
          v519 = (char *)v409 + (void)v519;
        }
        v390 = v551;
        unint64_t v392 = v476;
        if (v535)
        {
          v413 = (unsigned int *)&v569;
          v414 = v485;
          do
          {
            unsigned int v415 = *v413++;
            *v414++ = *((_DWORD *)&v553 + v415) + v497;
            --v393;
          }
          while (v393);
        }
        unint64_t v388 = (unint64_t)result + v497;
        v386 += 64;
        v389 = (char *)(v485 + 64);
        unint64_t v391 = v480;
        if (v492 + 64 >= (unint64_t)v551) {
          goto LABEL_712;
        }
      }
    }
    unint64_t v388 = 0;
    unint64_t v392 = v476;
LABEL_712:
    double result = (_DWORD *)BrotliFree(v540, v392);
    unint64_t v429 = v388;
    if (v388 << 6 >= (v388 >> 1) * v388) {
      unint64_t v430 = (v388 >> 1) * v388;
    }
    else {
      unint64_t v430 = v388 << 6;
    }
    if (v430 >= 0x801)
    {
      BrotliFree(v540, (unint64_t)v472);
      double result = (_DWORD *)BrotliAllocate(v540);
      v472 = result;
      int v71 = v532;
      if (*(_DWORD *)(v540 + 24)) {
        goto LABEL_626;
      }
    }
    if (v429)
    {
      double result = (_DWORD *)BrotliAllocate(v540);
      int v71 = v532;
      if (*(_DWORD *)(v540 + 24)) {
        goto LABEL_626;
      }
      v431 = result;
      for (uint64_t i1 = 0; i1 != v429; ++i1)
        result[i1] = i1;
    }
    else
    {
      int v71 = v532;
      if (*v532) {
        goto LABEL_626;
      }
      v431 = 0;
    }
    __srcf = (char *)BrotliHistogramCombineDistance((uint64_t)v547, (uint64_t)v503, v468, v431, v472, v429, (uint64_t)v551, 0x100uLL, v430);
    BrotliFree(v540, (unint64_t)v472);
    double result = (_DWORD *)BrotliFree(v540, (unint64_t)v503);
    if (v429)
    {
      size_t v433 = 4 * v429;
      double result = (_DWORD *)BrotliAllocate(v540);
      size_t v536 = (size_t)result;
      int v71 = v532;
      if (!*(_DWORD *)(v540 + 24))
      {
        memset(result, 255, v433);
LABEL_729:
        if (v551)
        {
          int v434 = 0;
          v435 = 0;
          uint64_t v436 = 0;
          do
          {
            bzero(v552, 0x888uLL);
            v552[273] = 0x7FF0000000000000;
            if (v381[(void)v435])
            {
              unint64_t v437 = 0;
              do
                ++*((_DWORD *)v552 + *(unsigned __int16 *)(v539 + 2 * v436 + 2 * v437++));
              while (v437 < v381[(void)v435]);
              v552[272] = v437;
              v436 += v437;
            }
            v438 = (char *)v435 - 1;
            if (!v435) {
              v438 = 0;
            }
            uint64_t v439 = v468[(void)v438];
            double v440 = BrotliHistogramBitCostDistanceDistance(v552, (uint64_t)&v547[2192 * v439]);
            if (__srcf)
            {
              double v441 = v440;
              v442 = v431;
              v443 = __srcf;
              do
              {
                double v444 = BrotliHistogramBitCostDistanceDistance(v552, (uint64_t)&v547[2192 * *v442]);
                if (v444 < v441)
                {
                  uint64_t v439 = *v442;
                  double v441 = v444;
                }
                ++v442;
                --v443;
              }
              while (v443);
            }
            v468[(void)v435] = v439;
            if (*(_DWORD *)(v536 + 4 * v439) == -1) {
              *(_DWORD *)(v536 + 4 * v439) = v434++;
            }
            v435 = (char *)v435 + 1;
          }
          while (v435 != v551);
        }
        BrotliFree(v540, (unint64_t)v431);
        double result = (_DWORD *)BrotliFree(v540, (unint64_t)v547);
        unint64_t v445 = *(void *)(v463 + 32);
        if (v445 < (unint64_t)v551)
        {
          if (!v445) {
            unint64_t v445 = (unint64_t)v551;
          }
          do
          {
            unint64_t v446 = v445;
            v445 *= 2;
          }
          while (v446 < (unint64_t)v551);
          if (v446) {
            v447 = (void *)BrotliAllocate(v540);
          }
          else {
            v447 = 0;
          }
          if (!*v532)
          {
            size_t v448 = *(void *)(v463 + 32);
            if (v448) {
              memcpy(v447, *(const void **)(v463 + 16), v448);
            }
          }
          double result = (_DWORD *)BrotliFree(v540, *(void *)(v463 + 16));
          *(void *)(v463 + 16) = v447;
          *(void *)(v463 + 32) = v446;
        }
        unint64_t v449 = *(void *)(v463 + 40);
        if (v449 < (unint64_t)v551)
        {
          if (!v449) {
            unint64_t v449 = (unint64_t)v551;
          }
          do
          {
            unint64_t v450 = v449;
            v449 *= 2;
          }
          while (v450 < (unint64_t)v551);
          if (v450) {
            v451 = (void *)BrotliAllocate(v540);
          }
          else {
            v451 = 0;
          }
          if (!*v532)
          {
            uint64_t v452 = *(void *)(v463 + 40);
            if (v452) {
              memcpy(v451, *(const void **)(v463 + 24), 4 * v452);
            }
          }
          double result = (_DWORD *)BrotliFree(v540, *(void *)(v463 + 24));
          *(void *)(v463 + 24) = v451;
          *(void *)(v463 + 40) = v450;
        }
        int v71 = v532;
        if (!*v532)
        {
          v453 = v551;
          if (v551)
          {
            unsigned __int8 v454 = 0;
            v453 = 0;
            int v455 = 0;
            v456 = v468 + 1;
            v457 = (int *)v381;
            do
            {
              int v458 = *v457++;
              v455 += v458;
              uint64_t v459 = *(v456 - 1);
              if (v551 == (char *)1 || v459 != *v456)
              {
                int v460 = *(_DWORD *)(v536 + 4 * v459);
                v453[*(void *)(v463 + 16)] = v460;
                *(_DWORD *)(*(void *)(v463 + 24) + 4 * (void)v453) = v455;
                if (v454 <= v460) {
                  unsigned __int8 v454 = v460;
                }
                ++v453;
                int v455 = 0;
              }
              ++v456;
              --v551;
            }
            while (v551);
          }
          else
          {
            unsigned __int8 v454 = 0;
          }
          *(void *)uint64_t v463 = v454 + 1;
          *(void *)(v463 + 8) = v453;
          BrotliFree(v540, v536);
          BrotliFree(v540, (unint64_t)v381);
          double result = (_DWORD *)BrotliFree(v540, (unint64_t)v468);
          if (!*(_DWORD *)(v540 + 24)) {
            double result = (_DWORD *)BrotliFree(v540, (unint64_t)__bd);
          }
          int v71 = v532;
        }
      }
    }
    else
    {
      int v71 = v532;
      if (!*v532)
      {
        size_t v536 = 0;
        goto LABEL_729;
      }
    }
LABEL_626:
    unint64_t v72 = v539;
LABEL_77:
    if (!*v71) {
      return (_DWORD *)BrotliFree(v540, v72);
    }
    return result;
  }
  unint64_t v234 = *(void *)(v65 + 32);
  unint64_t v235 = *(void *)(v65 + 8) + 1;
  if (v234 >= v235) {
    goto LABEL_495;
  }
  if (!v234) {
    unint64_t v234 = *(void *)(v65 + 8) + 1;
  }
  do
  {
    unint64_t v236 = v234;
    v234 *= 2;
  }
  while (v236 < v235);
  if (!v236)
  {
    unint64_t v237 = 0;
    goto LABEL_492;
  }
  unint64_t v237 = (void *)BrotliAllocate(v540);
  if (!*(_DWORD *)(v540 + 24))
  {
LABEL_492:
    size_t v309 = *(void *)(v65 + 32);
    if (v309) {
      memcpy(v237, *(const void **)(v65 + 16), v309);
    }
  }
  double result = (_DWORD *)BrotliFree(v540, *(void *)(v65 + 16));
  *(void *)(v65 + 16) = v237;
  *(void *)(v65 + 32) = v236;
  unint64_t v235 = *(void *)(v65 + 8) + 1;
LABEL_495:
  unint64_t v310 = *(void *)(v65 + 40);
  if (v310 < v235)
  {
    if (!v310) {
      unint64_t v310 = v235;
    }
    do
    {
      unint64_t v311 = v310;
      v310 *= 2;
    }
    while (v311 < v235);
    if (v311) {
      v312 = (void *)BrotliAllocate(v540);
    }
    else {
      v312 = 0;
    }
    if (!*v532)
    {
      uint64_t v313 = *(void *)(v65 + 40);
      if (v313) {
        memcpy(v312, *(const void **)(v65 + 24), 4 * v313);
      }
    }
    double result = (_DWORD *)BrotliFree(v540, *(void *)(v65 + 24));
    *(void *)(v65 + 24) = v312;
    *(void *)(v65 + 40) = v311;
  }
  if (!*v532)
  {
    *(void *)uint64_t v65 = 1;
    *(unsigned char *)(*(void *)(v65 + 16) + *(void *)(v65 + 8)) = 0;
    uint64_t v314 = *(void *)(v65 + 8);
    *(_DWORD *)(*(void *)(v65 + 24) + 4 * v314) = v534;
    uint64_t v315 = v314 + 1;
    int v71 = v532;
    *(void *)(v65 + 8) = v315;
    goto LABEL_77;
  }
  return result;
}

uint64_t lzvnStreamEncodeStateSize(int a1)
{
  return lzvn_encode_scratch_size(a1) + 524544;
}

uint64_t lzvnStreamEncodeInit(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  uint64_t v5 = lzvn_encode_scratch_size(a2);
  unint64_t v6 = realloc_stream_state(*(_DWORD **)(a1 + 32), 0, a2, (int)v5 + 524544, (int)v5 + 524344);
  *(void *)(a1 + 32) = v6;
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = v6;
  uint64_t result = 0;
  v7[4] = v7 + 32;
  int v9 = (char *)v7 + v5 + 256;
  v7[2] = v9;
  v7[3] = v9 + 0x40000;
  v7[8] = v9;
  v7[14] = v9 + 0x40000;
  v7[15] = v9 + 0x40000;
  v7[16] = v9 + 0x80000;
  v9[0x40000] = 14;
  *(unsigned char *)(v7[14] + 1) = 22;
  *(unsigned char *)(v7[14] + 2) = 22;
  *(unsigned char *)(v7[14] + 3) = 14;
  v7[14] += 4;
  return result;
}

uint64_t lzvnStreamEncode(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v64 = v3 + 64;
  if (a2) {
    *(_DWORD *)(v3 + 44) = 1;
  }
  while (1)
  {
    if (*(_DWORD *)(v3 + 48))
    {
      int64_t v4 = 0;
    }
    else
    {
      uint64_t v5 = *(void *)(v3 + 80);
      unint64_t v6 = *(void *)(a1 + 24);
      if (v6 >= 0x40000 - v5) {
        int64_t v4 = 0x40000 - v5;
      }
      else {
        int64_t v4 = *(void *)(a1 + 24);
      }
      if (v4 >= 1)
      {
        memcpy((void *)(*(void *)(v3 + 16) + v5), *(const void **)(a1 + 16), v4);
        *(void *)(v3 + 80) += v4;
        unint64_t v6 = *(void *)(a1 + 24) - v4;
        *(void *)(a1 + 16) += v4;
        *(void *)(a1 + 24) = v6;
      }
      if (!v6 && *(_DWORD *)(v3 + 44)) {
        *(_DWORD *)(v3 + 48) = 1;
      }
    }
    unsigned int v7 = *(char **)(v3 + 120);
    uint64_t v8 = *(char **)(v3 + 24);
    if (v7 >= v8 + 0x20000)
    {
      int v9 = *(unsigned char **)(v3 + 112);
      uint64_t v10 = v9 - v7;
      if (v9 != v7)
      {
        memmove(v8, v7, v9 - v7);
        uint64_t v8 = *(char **)(v3 + 24);
      }
      *(void *)(v3 + 112) = &v8[v10];
      *(void *)(v3 + 120) = v8;
    }
    if (*(_DWORD *)(v3 + 40))
    {
      if (*(_DWORD *)(v3 + 52)) {
        goto LABEL_34;
      }
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)(v3 + 72);
      if (v12 <= -65536) {
        LODWORD(v12) = -65536;
      }
      int32x4_t v13 = vdupq_n_s32(v12);
      int v14 = *(_DWORD *)(v3 + 136);
      unsigned int v15 = 1;
      do
      {
        *(int32x4_t *)(*(void *)(v3 + 192) + v11) = vmaxq_s32(*(int32x4_t *)(*(void *)(v3 + 192) + v11), v13);
        unsigned int v16 = v15++ >> v14;
        v11 += 32;
      }
      while (!v16);
      goto LABEL_27;
    }
    if (*(uint64_t *)(v3 + 80) <= 3) {
      break;
    }
    if (*(_DWORD *)(v3 + 52)) {
      goto LABEL_34;
    }
    lzvnEncodeInitState(v64, *(_DWORD *)(v3 + 4), *(void *)(v3 + 32));
    *(_DWORD *)(v3 + 40) = 1;
LABEL_27:
    uint64_t v17 = *(void *)(v3 + 80);
    *(void *)(v3 + 96) = v17 - 400;
    if (*(_DWORD *)(v3 + 48)) {
      *(void *)(v3 + 96) = v17 - 8;
    }
    lzvnEncode(v64, (int8x16_t)v13);
    if (*(_DWORD *)(v3 + 48) && *(void *)(v3 + 88) >= *(void *)(v3 + 80) - 8)
    {
      *(_DWORD *)(v3 + 52) = 1;
    }
    else if (!*(_DWORD *)(v3 + 52))
    {
      goto LABEL_35;
    }
LABEL_34:
    if (*(_DWORD *)(v3 + 56)) {
      goto LABEL_35;
    }
    unint64_t v30 = *(void *)(v3 + 160);
    uint64_t v31 = *(void *)(v3 + 104);
    if (!v30) {
      goto LABEL_98;
    }
    unint64_t v32 = *(void *)(v3 + 168);
    unint64_t v33 = *(void *)(v3 + 144) - v31;
    unint64_t v34 = (int *)(*(void *)(v3 + 64) + v31);
    int v35 = *(char **)(v3 + 112);
    unint64_t v36 = *(void *)(v3 + 128);
    uint64_t v62 = *(void *)(v3 + 184);
    uint64_t v63 = *(void *)(v3 + 152);
    if (v33 >= 0x10)
    {
      do
      {
        uint64_t v37 = v33 >= 0x10F ? 271 : v33;
        if ((unint64_t)&v35[v37 + 10] >= v36) {
          goto LABEL_93;
        }
        *(_WORD *)int v35 = ((_WORD)v37 << 8) - 3872;
        unsigned int v38 = v35 + 2;
        v33 -= v37;
        memcpy(v38, v34, ((v37 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
        int v35 = &v38[v37];
        unint64_t v34 = (int *)((char *)v34 + v37);
      }
      while (v33 > 0xF);
    }
    if (v33 >= 4)
    {
      if ((unint64_t)&v35[v33 + 10] >= v36) {
        goto LABEL_93;
      }
      *int v35 = v33 | 0xE0;
      unint64_t v39 = v35 + 1;
      memcpy(v39, v34, ((v33 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
      int v35 = &v39[v33];
      unint64_t v34 = (int *)((char *)v34 + v33);
      unint64_t v33 = 0;
    }
    if (10 - 2 * v33 >= v30) {
      uint64_t v40 = v30;
    }
    else {
      uint64_t v40 = 10 - 2 * v33;
    }
    if ((unint64_t)(v35 + 8) < v36)
    {
      unint64_t v41 = v30 - v40;
      char v42 = v40 - 3;
      int v43 = *v34;
      if (v32 == v62)
      {
        char v44 = ((_BYTE)v33 << 6) + 8 * v42;
        if (v33) {
          char v45 = 6;
        }
        else {
          char v45 = -16;
        }
        if (!v33) {
          char v44 = v40;
        }
        *int v35 = v45 | v44;
        uint64_t v46 = v35 + 1;
LABEL_83:
        *uint64_t v46 = v43;
        size_t v47 = (_WORD *)((char *)v46 + v33);
        if (v41 < 0x10)
        {
          int v48 = (char *)v46 + v33;
          if (v41)
          {
LABEL_89:
            if ((unint64_t)(v48 + 1) < v36)
            {
              *int v48 = v41 | 0xF0;
              unint64_t v36 = (unint64_t)(v48 + 1);
            }
          }
          else
          {
LABEL_92:
            unint64_t v36 = (unint64_t)v48;
          }
        }
        else
        {
          while (1)
          {
            int v48 = v47 + 1;
            if ((unint64_t)(v47 + 1) >= v36) {
              break;
            }
            uint64_t v49 = 271;
            if (v41 < 0x10F) {
              uint64_t v49 = v41;
            }
            *size_t v47 = ((_WORD)v49 << 8) - 3856;
            v41 -= v49;
            ++v47;
            if (v41 <= 0xF)
            {
              if (!v41) {
                goto LABEL_92;
              }
              goto LABEL_89;
            }
          }
        }
        goto LABEL_93;
      }
      if (v32 <= 0x5FF)
      {
        *int v35 = ((_BYTE)v33 << 6) + BYTE1(v32) + 8 * v42;
        v35[1] = v32;
        uint64_t v46 = v35 + 2;
        goto LABEL_83;
      }
      if (v30 > 0x22 || v32 >> 14 || !v41)
      {
        *int v35 = (((_BYTE)v33 << 6) + 8 * v42) | 7;
        *(_WORD *)(v35 + 1) = v32;
        uint64_t v46 = v35 + 3;
        goto LABEL_83;
      }
      *int v35 = ((v30 - 3) >> 2) + 8 * v33 - 96;
      *(_WORD *)(v35 + 1) = (v30 - 3) & 3 | (4 * v32);
      *(_DWORD *)(v35 + 3) = v43;
      unint64_t v36 = (unint64_t)&v35[v33 + 3];
    }
LABEL_93:
    if (v36 < *(void *)(v3 + 128))
    {
      uint64_t v50 = *(void *)(v3 + 112);
      *(void *)(v3 + 184) = v32;
      *(void *)(v3 + 104) = v63;
      *(void *)(v3 + 112) = v36;
      if (v36 != v50)
      {
        *(void *)(v3 + 176) = 0;
        *(_OWORD *)(v3 + 144) = 0u;
        *(_OWORD *)(v3 + 160) = 0u;
      }
    }
    if (*(void *)(v3 + 160)) {
      goto LABEL_35;
    }
    uint64_t v31 = *(void *)(v3 + 104);
LABEL_98:
    uint64_t v51 = *(void *)(v3 + 80);
    unint64_t v52 = v51 - v31;
    if (v51 > v31)
    {
      unint64_t v53 = (char *)(*(void *)(v3 + 64) + v31);
      float32x4x2_t v54 = *(char **)(v3 + 112);
      unint64_t v55 = *(void *)(v3 + 128);
      size_t v56 = v51 - v31;
      if (v52 < 0x10)
      {
LABEL_105:
        if (v56)
        {
          if ((unint64_t)&v54[v56 + 10] < v55)
          {
            *float32x4x2_t v54 = v56 | 0xE0;
            uint64_t v59 = v54 + 1;
            memcpy(v59, v53, v56);
            unint64_t v55 = (unint64_t)v59 + v56;
          }
        }
        else
        {
          unint64_t v55 = (unint64_t)v54;
        }
      }
      else
      {
        while (1)
        {
          size_t v57 = v56 >= 0x10F ? 271 : v56;
          if ((unint64_t)&v54[v57 + 10] >= v55) {
            break;
          }
          *(_WORD *)float32x4x2_t v54 = ((_WORD)v57 << 8) - 3872;
          uint64_t v58 = v54 + 2;
          v56 -= v57;
          memcpy(v58, v53, v57);
          float32x4x2_t v54 = &v58[v57];
          v53 += v57;
          if (v56 <= 0xF) {
            goto LABEL_105;
          }
        }
      }
      if (v55 < *(void *)(v3 + 128))
      {
        *(void *)(v3 + 104) += v52;
        *(void *)(v3 + 112) = v55;
      }
    }
    if (!*(void *)(v3 + 160) && *(void *)(v3 + 80) == *(void *)(v3 + 104))
    {
      int v60 = *(void **)(v3 + 112);
      if (*(void *)(v3 + 128) >= (unint64_t)(v60 + 1))
      {
        *int v60 = 6;
        *(void *)(v3 + 112) = v60 + 1;
        *(_DWORD *)(v3 + 56) = 1;
      }
    }
LABEL_35:
    if (*(_DWORD *)(v3 + 60))
    {
      if (*(_DWORD *)(v3 + 56)) {
        return 1;
      }
      int64_t v18 = 0;
    }
    else
    {
      unsigned int v19 = *(const void **)(v3 + 120);
      if (*(void *)(a1 + 8) >= *(void *)(v3 + 112) - (void)v19) {
        int64_t v18 = *(void *)(v3 + 112) - (void)v19;
      }
      else {
        int64_t v18 = *(void *)(a1 + 8);
      }
      if (v18 >= 1)
      {
        memcpy(*(void **)a1, v19, v18);
        unsigned int v19 = (const void *)(*(void *)(v3 + 120) + v18);
        *(void *)(v3 + 120) = v19;
        int64_t v20 = *(void *)(a1 + 8) - v18;
        *(void *)a1 += v18;
        *(void *)(a1 + 8) = v20;
      }
      if (*(_DWORD *)(v3 + 56))
      {
        if (v19 == *(const void **)(v3 + 112))
        {
          *(_DWORD *)(v3 + 60) = 1;
          return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
        }
        if (*(_DWORD *)(v3 + 60)) {
          return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
        }
      }
    }
    uint64_t v21 = *(void *)(v3 + 80);
    if (v21 >= 0x20000)
    {
      uint64_t v22 = *(void *)(v3 + 88);
      int64_t v23 = v22 - 0x10000;
      if (v22 < 0x20000) {
        int64_t v23 = 0;
      }
      if (v23 >= 1)
      {
        uint64_t v24 = 0;
        size_t v25 = v21 - v23;
        *(void *)(v3 + 80) = v21 - v23;
        *(void *)(v3 + 88) = v22 - v23;
        *(void *)(v3 + 104) -= v23;
        *(int64x2_t *)(v3 + 144) = vsubq_s64(*(int64x2_t *)(v3 + 144), vdupq_n_s64(v23));
        int32x4_t v26 = vdupq_n_s32(-(int)v23);
        int v27 = *(_DWORD *)(v3 + 136);
        unsigned int v28 = 1;
        do
        {
          *(int32x4_t *)(*(void *)(v3 + 192) + v24) = vaddq_s32(*(int32x4_t *)(*(void *)(v3 + 192) + v24), v26);
          unsigned int v29 = v28++ >> v27;
          v24 += 32;
        }
        while (!v29);
        memmove(*(void **)(v3 + 16), (const void *)(*(void *)(v3 + 16) + v23), v25);
        *(void *)(v3 + 64) = *(void *)(v3 + 16);
        *(void *)(v3 + 72) = 0;
      }
    }
    if (!(v18 | v4)) {
      return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
    }
  }
  if (*(_DWORD *)(v3 + 48)) {
    return 0xFFFFFFFFLL;
  }
  return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
}

uint64_t lz24_decode_buffer(char *__dst, unint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t result = 0;
  if (a4 >= 4 && ((a4 | a2) & 0x8000000000000000) == 0)
  {
    unint64_t v6 = (char *)(a3 + 1);
    unint64_t v7 = *a3;
    if (v7 > a2) {
      return 0;
    }
    if (v7)
    {
      uint64_t v8 = (char *)a3 + a4;
      int v9 = &__dst[a2];
      unint64_t v10 = (unint64_t)a3 + a4 - 34;
      uint64_t v11 = &__dst[a2 - 62];
      uint64_t v12 = __dst;
      while (1)
      {
        if (v7 >= 0x1000) {
          int64_t v13 = 4096;
        }
        else {
          int64_t v13 = v7;
        }
        if (v8 - v6 < 2 || v9 - v12 < v13) {
          return 0;
        }
        if (*(_WORD *)v6) {
          break;
        }
        int64_t v23 = v6 + 2;
        if (v8 - (v6 + 2) < v13) {
          return 0;
        }
        memcpy(v12, v6 + 2, v13);
        unint64_t v6 = &v23[v13];
LABEL_29:
        v12 += v13;
        LODWORD(v7) = v7 - v13;
        if (!v7) {
          return v12 - __dst;
        }
      }
      int v14 = &v12[v13];
      if ((unint64_t)(v8 - v6) >= 0x23 && v9 - v12 >= 63)
      {
        if (v11 <= v14) {
          unsigned int v15 = v11;
        }
        else {
          unsigned int v15 = &v12[v13];
        }
        unint64_t i = v12;
        while (1)
        {
          unint64_t v17 = *(unsigned int *)v6;
          uint64_t v18 = (v17 >> 10) & 0x3FFF;
          long long v19 = *(_OWORD *)(v6 + 19);
          *(_OWORD *)unint64_t i = *(_OWORD *)(v6 + 3);
          *((_OWORD *)i + 1) = v19;
          int64_t v20 = &i[v17 & 0x1F];
          if (v20 - __dst < v18) {
            return 0;
          }
          v6 += (v17 & 0x1F) + 3;
          long long v21 = *(_OWORD *)&v20[-v18 + 16];
          *(_OWORD *)int64_t v20 = *(_OWORD *)&v20[-v18];
          *((_OWORD *)v20 + 1) = v21;
          unint64_t i = &v20[(v17 >> 5) & 0x1F];
          if ((unint64_t)v6 >= v10 || i >= v15)
          {
            if (i <= v14) {
              goto LABEL_32;
            }
            return 0;
          }
        }
      }
      for (unint64_t i = v12; ; unint64_t i = &v31[v26])
      {
LABEL_32:
        if (i >= v14) {
          goto LABEL_29;
        }
        if (v8 - v6 < 3) {
          return 0;
        }
        unint64_t v24 = *(unsigned __int16 *)v6;
        uint64_t v25 = v24 & 0x1F;
        uint64_t v26 = (v24 >> 5) & 0x1F;
        if (v14 - i < (int64_t)(v26 + (v24 & 0x1F))) {
          return 0;
        }
        int v27 = v6 + 3;
        if (v8 - (v6 + 3) < v25) {
          return 0;
        }
        unint64_t v28 = *(unsigned __int16 *)(v6 + 1);
        unsigned int v29 = (uint64_t *)(v6 + 3);
        unint64_t v30 = i;
        if ((v24 & 0x10) != 0)
        {
          *(_OWORD *)unint64_t i = *(_OWORD *)(v6 + 3);
          unint64_t v30 = i + 16;
          unsigned int v29 = (uint64_t *)(v6 + 19);
          if ((v24 & 8) == 0)
          {
LABEL_38:
            if ((v24 & 4) == 0) {
              goto LABEL_39;
            }
            goto LABEL_48;
          }
        }
        else if ((v24 & 8) == 0)
        {
          goto LABEL_38;
        }
        uint64_t v34 = *v29++;
        *v30++ = v34;
        if ((v24 & 4) == 0)
        {
LABEL_39:
          if ((v24 & 2) == 0) {
            goto LABEL_40;
          }
          goto LABEL_49;
        }
LABEL_48:
        int v35 = *(_DWORD *)v29;
        unsigned int v29 = (uint64_t *)((char *)v29 + 4);
        *(_DWORD *)unint64_t v30 = v35;
        unint64_t v30 = (void *)((char *)v30 + 4);
        if ((v24 & 2) == 0)
        {
LABEL_40:
          if ((v24 & 1) == 0) {
            goto LABEL_42;
          }
LABEL_41:
          *(unsigned char *)unint64_t v30 = *(unsigned char *)v29;
          goto LABEL_42;
        }
LABEL_49:
        __int16 v36 = *(_WORD *)v29;
        unsigned int v29 = (uint64_t *)((char *)v29 + 2);
        *(_WORD *)unint64_t v30 = v36;
        unint64_t v30 = (void *)((char *)v30 + 2);
        if (v24) {
          goto LABEL_41;
        }
LABEL_42:
        uint64_t v31 = &i[v25];
        if (v31 - __dst < (uint64_t)(v28 >> 2)) {
          return 0;
        }
        unint64_t v32 = (long long *)&v31[-(v28 >> 2)];
        if ((v24 & 0x200) != 0)
        {
          long long v37 = *v32++;
          *(_OWORD *)uint64_t v31 = v37;
          unint64_t v33 = v31 + 16;
          if ((v24 & 0x100) == 0) {
            goto LABEL_53;
          }
LABEL_52:
          uint64_t v38 = *(void *)v32;
          unint64_t v32 = (long long *)((char *)v32 + 8);
          *v33++ = v38;
          goto LABEL_53;
        }
        unint64_t v33 = v31;
        if ((v24 & 0x100) != 0) {
          goto LABEL_52;
        }
LABEL_53:
        if ((v24 & 0x80) != 0)
        {
          int v39 = *(_DWORD *)v32;
          unint64_t v32 = (long long *)((char *)v32 + 4);
          *(_DWORD *)unint64_t v33 = v39;
          unint64_t v33 = (void *)((char *)v33 + 4);
          if ((v24 & 0x40) == 0)
          {
LABEL_55:
            if ((v24 & 0x20) == 0) {
              goto LABEL_57;
            }
LABEL_56:
            *(unsigned char *)unint64_t v33 = *(unsigned char *)v32;
            goto LABEL_57;
          }
        }
        else if ((v24 & 0x40) == 0)
        {
          goto LABEL_55;
        }
        __int16 v40 = *(_WORD *)v32;
        unint64_t v32 = (long long *)((char *)v32 + 2);
        *(_WORD *)unint64_t v33 = v40;
        unint64_t v33 = (void *)((char *)v33 + 2);
        if ((v24 & 0x20) != 0) {
          goto LABEL_56;
        }
LABEL_57:
        unint64_t v6 = &v27[v25];
      }
    }
    uint64_t v12 = __dst;
    return v12 - __dst;
  }
  return result;
}

uint64_t create_thread(pthread_t *a1, void *(__cdecl *a2)(void *), void *a3, size_t a4)
{
  uint64_t v8 = (pthread_attr_t *)calloc(1uLL, 0x40uLL);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  int v9 = v8;
  uint64_t v10 = pthread_attr_init(v8);
  if (!v10)
  {
    if (!a4 || (uint64_t v10 = pthread_attr_setstacksize(v9, a4), !v10)) {
      uint64_t v10 = pthread_create(a1, v9, a2, a3);
    }
  }
  pthread_attr_destroy(v9);
  free(v9);
  return v10;
}

uint64_t join_thread(_opaque_pthread_t *a1)
{
  unint64_t v2 = 0;
  return pthread_join(a1, &v2);
}

uint64_t BrotliSafeReadBits32Slow(unint64_t *a1, int a2, unsigned int *a3)
{
  int v3 = *((_DWORD *)a1 + 2);
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = v4;
  unint64_t v7 = *a1;
  uint64_t v8 = v5;
  unint64_t v9 = *a1;
  int v10 = v3;
  if ((v3 - 49) <= 0xF)
  {
    uint64_t v11 = 0;
    uint64_t v12 = -1;
    unint64_t v9 = *a1;
    int v13 = *((_DWORD *)a1 + 2);
    while (v5 != v11)
    {
      *a1 = v9 >> 8;
      *((void *)&v14 + 1) = *(unsigned __int8 *)(v4 + v11);
      *(void *)&long long v14 = v9;
      unint64_t v9 = v14 >> 8;
      *a1 = v9;
      int v10 = v13 - 8;
      *((_DWORD *)a1 + 2) = v13 - 8;
      a1[2] = v4 + v11 + 1;
      a1[3] = v5 + v12;
      ++v11;
      --v12;
      unsigned int v15 = v13 - 57;
      v13 -= 8;
      if (v15 >= 0x10)
      {
        uint64_t v6 = v4 + v11;
        uint64_t v8 = v5 - v11;
        goto LABEL_6;
      }
    }
    goto LABEL_11;
  }
LABEL_6:
  int v16 = v10 + 16;
  *((_DWORD *)a1 + 2) = v10 + 16;
  unsigned int v17 = a2 - 16;
  unsigned int v18 = 48 - v10;
  if (48 - v10 < (a2 - 16))
  {
    unint64_t v19 = v6 + 1;
    unint64_t v20 = v8 - 1;
    unint64_t v21 = v9;
    while (v20 != -1)
    {
      *a1 = v21 >> 8;
      *((void *)&v22 + 1) = *(unsigned __int8 *)(v19 - 1);
      *(void *)&long long v22 = v21;
      unint64_t v21 = v22 >> 8;
      *a1 = v21;
      v16 -= 8;
      *((_DWORD *)a1 + 2) = v16;
      a1[2] = v19;
      a1[3] = v20;
      ++v19;
      --v20;
      v18 += 8;
      if (v18 >= v17) {
        goto LABEL_13;
      }
    }
LABEL_11:
    uint64_t v23 = 0;
    *a1 = v7;
    *((_DWORD *)a1 + 2) = v3;
    a1[2] = v4;
    a1[3] = v5;
    return v23;
  }
  unint64_t v21 = v9;
LABEL_13:
  *((_DWORD *)a1 + 2) = v16 + v17;
  *a3 = (unsigned __int16)(v9 >> v10) | (((v21 >> v16) & ~(-1 << v17)) << 16);
  return 1;
}

uint64_t BrotliDecoderDecompress()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  unint64_t v2 = v1;
  uint64_t v13 = *MEMORY[0x263EF8340];
  memset(v12, 0, 512);
  uint64_t v10 = v0;
  size_t v11 = 0;
  size_t v8 = *v1;
  unint64_t v9 = v3;
  unint64_t v7 = v4;
  uint64_t result = BrotliDecoderStateInit((uint64_t)v12, 0, 0, 0);
  if (result)
  {
    int v6 = BrotliDecoderDecompressStream((uint64_t)v12, &v10, &v9, &v8, &v7, &v11);
    *unint64_t v2 = v11;
    BrotliDecoderStateCleanup((uint64_t)v12);
    return v6 == 1;
  }
  return result;
}

uint64_t CopyUncompressedBlockToOutput(size_t *a1, void **a2, size_t *a3, uint64_t a4)
{
  if (!BrotliEnsureRingBuffer(a4)) {
    return 4294967270;
  }
  for (int i = *(_DWORD *)(a4 + 652); ; int i = 0)
  {
    do
    {
      if (i == 1) {
        goto LABEL_24;
      }
    }
    while (i);
    unint64_t v9 = *(void *)(a4 + 32);
    int v10 = *(_DWORD *)(a4 + 16);
    if (v9 <= 0x40000000) {
      LODWORD(v9) = v9 + ((64 - v10) >> 3);
    }
    else {
      LODWORD(v9) = 0x40000000;
    }
    if (*(_DWORD *)(a4 + 264) < (int)v9) {
      LODWORD(v9) = *(_DWORD *)(a4 + 264);
    }
    uint64_t v11 = *(int *)(a4 + 76);
    int v12 = *(_DWORD *)(a4 + 88);
    if ((int)v11 + (int)v9 > v12) {
      LODWORD(v9) = v12 - v11;
    }
    uint64_t v13 = (unsigned char *)(*(void *)(a4 + 120) + v11);
    int v14 = v9;
    if ((v10 - 65) <= 0xFFFFFFF7 && v9)
    {
      unint64_t v9 = (int)v9;
      do
      {
        *v13++ = *(void *)(a4 + 8) >> v10;
        int v15 = *(_DWORD *)(a4 + 16);
        LOBYTE(v10) = v15 + 8;
        *(_DWORD *)(a4 + 16) = v15 + 8;
        size_t v16 = v9 - 1;
      }
      while ((v15 - 57) <= 0xFFFFFFF7 && v9-- != 1);
    }
    else
    {
      size_t v16 = (int)v9;
    }
    memcpy(v13, *(const void **)(a4 + 24), v16);
    size_t v18 = *(void *)(a4 + 32) - v16;
    *(void *)(a4 + 24) += v16;
    *(void *)(a4 + 32) = v18;
    int v19 = *(_DWORD *)(a4 + 76) + v14;
    *(_DWORD *)(a4 + 76) = v19;
    int v20 = *(_DWORD *)(a4 + 264);
    *(_DWORD *)(a4 + 264) = v20 - v14;
    if (v19 < 1 << *(_DWORD *)(a4 + 668)) {
      break;
    }
    *(_DWORD *)(a4 + 652) = 1;
LABEL_24:
    uint64_t result = WriteRingBuffer(a4, a1, a2, a3, 0);
    if (result != 1) {
      return result;
    }
    if (*(_DWORD *)(a4 + 88) == 1 << *(_DWORD *)(a4 + 668)) {
      *(_DWORD *)(a4 + 84) = *(_DWORD *)(a4 + 80);
    }
    *(_DWORD *)(a4 + 652) = 0;
  }
  if (v20 == v14) {
    return 1;
  }
  else {
    return 2;
  }
}

BOOL BrotliDecoderHasMoreOutput(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 116) & 0x80000000) == 0
      && *(void *)(a1 + 120)
      && *(int *)(a1 + 76) - *(void *)(a1 + 376) + *(void *)(a1 + 368) * *(int *)(a1 + 88) != 0;
}

void *BrotliDecoderTakeOutput(uint64_t a1, size_t *a2)
{
  if (*a2) {
    size_t v3 = *a2;
  }
  else {
    size_t v3 = 0x1000000;
  }
  size_t v7 = v3;
  size_t v8 = 0;
  if (*(void *)(a1 + 120) && (*(_DWORD *)(a1 + 116) & 0x80000000) == 0)
  {
    WrapRingBuffer((void **)a1);
    unsigned int v5 = WriteRingBuffer(a1, &v7, &v8, 0, 1);
    if ((v5 & 0xFFFFFFFD) == 1)
    {
      uint64_t result = v8;
      *a2 = v3 - v7;
      return result;
    }
    if ((v5 & 0x80000000) != 0) {
      SaveErrorCode(a1, v5);
    }
  }
  uint64_t result = 0;
  *a2 = 0;
  return result;
}

BOOL BrotliDecoderIsUsed(_DWORD *a1)
{
  return *a1 || a1[4] != 64;
}

BOOL BrotliDecoderIsFinished(uint64_t a1)
{
  if (*(_DWORD *)a1 != 26) {
    return 0;
  }
  if ((*(_DWORD *)(a1 + 116) & 0x80000000) != 0 || !*(void *)(a1 + 120)) {
    return 1;
  }
  return *(int *)(a1 + 76) - *(void *)(a1 + 376) + *(void *)(a1 + 368) * *(int *)(a1 + 88) == 0;
}

uint64_t BrotliDecoderGetErrorCode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

const char *BrotliDecoderErrorString(int a1)
{
  if ((a1 + 31) > 0x22) {
    return "INVALID";
  }
  else {
    return off_264125030[a1 + 31];
  }
}

uint64_t SafeDecodeDistanceBlockSwitch(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 292);
  if (v1 < 2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 248);
  uint64_t v4 = (unsigned char *)(*(void *)(a1 + 240) + 5056);
  unsigned int v5 = (unint64_t *)(a1 + 8);
  int v47 = 0;
  unint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v6;
  int v11 = v7;
  if ((v7 - 50) > 0xE)
  {
LABEL_6:
    unint64_t v17 = v10 >> v11;
    size_t v18 = &v4[4 * (v10 >> v11)];
    unsigned int v19 = *v18;
    if (v19 >= 9)
    {
      v11 += 8;
      v18 += 4 * (BYTE1(v17) & ~(-1 << (v19 - 8)) & 0x7F)
           + 4 * *(unsigned __int16 *)&v4[4 * v17 + 2];
      unsigned int v19 = *v18;
    }
    *(_DWORD *)(a1 + 16) = v11 + v19;
    int v47 = *((unsigned __int16 *)v18 + 1);
  }
  else
  {
    uint64_t v12 = v8 + 1;
    uint64_t v13 = v9 - 1;
    unint64_t v10 = *(void *)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 16);
    while (v13 != -1)
    {
      *(void *)(a1 + 8) = v10 >> 8;
      *((void *)&v15 + 1) = *(unsigned __int8 *)(v12 - 1);
      *(void *)&long long v15 = v10;
      unint64_t v10 = v15 >> 8;
      *(void *)(a1 + 8) = v10;
      int v11 = v14 - 8;
      *(_DWORD *)(a1 + 16) = v14 - 8;
      *(void *)(a1 + 24) = v12;
      *(void *)(a1 + 32) = v13;
      ++v12;
      --v13;
      unsigned int v16 = v14 - 58;
      v14 -= 8;
      if (v16 >= 0xF) {
        goto LABEL_6;
      }
    }
    if (!SafeDecodeSymbol(v4, a1 + 8, &v47)) {
      return 0;
    }
  }
  unsigned int v48 = 0;
  if (*(_DWORD *)(a1 + 660))
  {
    unsigned int v20 = *(_DWORD *)(a1 + 268);
  }
  else
  {
    unint64_t v21 = (unsigned char *)(v3 + 3168);
    int v22 = *(_DWORD *)(a1 + 16);
    if ((v22 - 50) >= 0xF)
    {
      unint64_t v26 = *v5;
LABEL_19:
      unint64_t v29 = v26 >> v22;
      unint64_t v30 = &v21[4 * (v26 >> v22)];
      unsigned int v31 = *v30;
      if (v31 >= 9)
      {
        v22 += 8;
        v30 += 4 * (BYTE1(v29) & ~(-1 << (v31 - 8)) & 0x7F)
             + 4 * *(unsigned __int16 *)&v21[4 * v29 + 2];
        unsigned int v31 = *v30;
      }
      *(_DWORD *)(a1 + 16) = v22 + v31;
      unsigned int v20 = *((unsigned __int16 *)v30 + 1);
    }
    else
    {
      uint64_t v23 = *(void *)(a1 + 32) - 1;
      while (v23 != -1)
      {
        unint64_t v24 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = v24 >> 8;
        uint64_t v25 = *(unsigned __int8 **)(a1 + 24);
        *((void *)&v27 + 1) = *v25;
        *(void *)&long long v27 = v24;
        unint64_t v26 = v27 >> 8;
        *(void *)(a1 + 8) = v26;
        int v28 = v22 - 8;
        *(_DWORD *)(a1 + 16) = v22 - 8;
        *(void *)(a1 + 24) = v25 + 1;
        *(void *)(a1 + 32) = v23--;
        LODWORD(v25) = v22 - 58;
        v22 -= 8;
        if (v25 >= 0xF)
        {
          int v22 = v28;
          goto LABEL_19;
        }
      }
      if (!SafeDecodeSymbol(v21, a1 + 8, &v48)) {
        goto LABEL_32;
      }
      unsigned int v20 = v48;
    }
  }
  unint64_t v32 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v20);
  unsigned int v33 = *((unsigned __int8 *)v32 + 2);
  int v34 = *v32;
  int v35 = *(_DWORD *)(a1 + 16);
  unsigned int v36 = 64 - v35;
  if (64 - v35 < v33)
  {
    uint64_t v37 = *(void *)(a1 + 32) - 1;
    while (v37 != -1)
    {
      unint64_t v38 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = v38 >> 8;
      int v39 = *(unsigned __int8 **)(a1 + 24);
      *((void *)&v41 + 1) = *v39;
      *(void *)&long long v41 = v38;
      unint64_t v40 = v41 >> 8;
      *(void *)(a1 + 8) = v40;
      v35 -= 8;
      *(_DWORD *)(a1 + 16) = v35;
      *(void *)(a1 + 24) = v39 + 1;
      *(void *)(a1 + 32) = v37--;
      v36 += 8;
      if (v36 >= v33) {
        goto LABEL_28;
      }
    }
    *(_DWORD *)(a1 + 268) = v20;
LABEL_32:
    *(_DWORD *)(a1 + 660) = 0;
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v8;
    *(void *)(a1 + 32) = v9;
    return 0;
  }
  unint64_t v40 = *v5;
LABEL_28:
  *(_DWORD *)(a1 + 16) = v35 + v33;
  *(_DWORD *)(a1 + 280) = ((v40 >> v35) & ~(-1 << v33)) + v34;
  *(_DWORD *)(a1 + 660) = 0;
  if (v47)
  {
    if (v47 == 1) {
      unsigned int v42 = *(_DWORD *)(a1 + 316) + 1;
    }
    else {
      unsigned int v42 = v47 - 2;
    }
  }
  else
  {
    unsigned int v42 = *(_DWORD *)(a1 + 312);
  }
  if (v42 >= v1) {
    unsigned int v44 = v1;
  }
  else {
    unsigned int v44 = 0;
  }
  unsigned int v45 = v42 - v44;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 316) = v45;
  uint64_t v46 = *(void *)(a1 + 336) + 4 * v45;
  *(void *)(a1 + 160) = v46;
  *(unsigned char *)(a1 + 352) = *(unsigned char *)(v46 + *(int *)(a1 + 260));
  return 1;
}

unint64_t lzbitmap_decode(uint64_t a1, unsigned int a2, unsigned char *a3, unsigned int a4, uint64_t a5, double a6, double a7, double a8, int32x4_t a9)
{
  if (a4 < 4) {
    return 0;
  }
  if (*a3 != 90) {
    return 0;
  }
  if (a3[1] != 66) {
    return 0;
  }
  if (a3[2] != 77) {
    return 0;
  }
  unsigned int v11 = a3[3];
  if (v11 > 0xF || (v11 & 3) - 2 < 2) {
    return 0;
  }
  int v16 = (v11 & 3) != 0 ? 0x8000 : 0x4000;
  unsigned int v218 = v16;
  int v17 = (v11 & 8) != 0 ? -3 : -4;
  unsigned int v18 = (v11 & 8) != 0 ? 3 : 4;
  if (!a2) {
    return 0;
  }
  uint64_t v19 = 0;
  unsigned int v203 = v11 & 4;
  unsigned int v204 = v18;
  double v201 = (int8x16_t *)(a5 + 4160);
  uint8x8_t v20 = (uint8x8_t)vdup_n_s8(v18);
  int v202 = 10 * (v17 + (v203 >> 2) + 15);
  int8x16_t v216 = 0u;
  unsigned int v21 = 4;
  long long v22 = xmmword_20DAD5BF0;
  LODWORD(v22) = -1;
  int32x4_t v205 = (int32x4_t)v22;
  int8x16_t v217 = 0u;
  int v215 = 1;
  while (1)
  {
    unsigned int v23 = v21 + 6;
    if (v21 + 6 > a4) {
      return 0;
    }
    unint64_t v24 = &a3[v21];
    uint64_t v25 = *v24 & 0xFFFFFF;
    unsigned int v26 = *(_DWORD *)((char *)v24 + 2);
    if (v25 == 6 && v26 < 0x100) {
      break;
    }
    unsigned int v27 = v26 >> 8;
    unsigned int v28 = (v26 >> 8) + 6;
    if (v25 < 6 || v27 > v218 || v25 > v28) {
      return 0;
    }
    unsigned int v31 = v27 + v19;
    if (v31 >= a2) {
      unint64_t v32 = a2;
    }
    else {
      unint64_t v32 = v31;
    }
    if (v28 == v25)
    {
      size_t v33 = (v32 - v19);
      if (v33 + v23 > a4) {
        return 0;
      }
      int v34 = (void *)(a1 + v19);
      unsigned int v35 = v21;
      memcpy(v34, &a3[v23], v33);
      unsigned int v21 = v25 + v35;
      goto LABEL_120;
    }
    v21 += v25;
    if (v25 < 0x20 || v21 > a4) {
      return 0;
    }
    unint64_t v37 = *(unsigned int *)((char *)v24 + 5);
    if (v37 < 0xF00) {
      return 0;
    }
    unint64_t v38 = v37 >> 8;
    unint64_t v39 = (unint64_t)v24[2] >> 8;
    if (*(_DWORD *)((char *)v24 + 5) >> 8 > v24[2] >> 8) {
      return 0;
    }
    unint64_t v40 = (unint64_t)*(unsigned int *)((char *)v24 + 11) >> 8;
    if (v39 > *(_DWORD *)((char *)v24 + 11) >> 8) {
      return 0;
    }
    unsigned int v41 = v25 - 17;
    unint64_t v42 = (v25 - 17 - v40);
    if ((int)v25 - 17 < v40) {
      return 0;
    }
    int v43 = 0;
    unint64_t v44 = (unint64_t)v24 + v25;
    unsigned int v45 = (v32 - v19 + 63) >> 3;
    unint64_t v46 = v45 & 0x1FFFFFF8;
    unsigned int v47 = v204;
    int8x16_t v48 = v216;
    int8x16_t v49 = v217;
    do
    {
      int8x16_t v226 = v48;
      *(unsigned char *)((unint64_t)&v226 | v43 & 0xF) = 0;
      int8x16_t v48 = v226;
      int8x16_t v225 = v49;
      *(unsigned char *)((unint64_t)&v225 | v43 & 0xF) = v43;
      int8x16_t v49 = v225;
      ++v43;
    }
    while (v204 != v43);
    unsigned int v50 = 0;
    do
    {
      int v51 = *(unsigned __int16 *)((char *)v24 + v41 + ((unint64_t)v50 >> 3)) >> (v50 & 6);
      int8x16_t v223 = v48;
      *(unsigned char *)((unint64_t)&v223 | v47 & 0xF) = v51;
      int8x16_t v48 = v223;
      int8x16_t v224 = v49;
      *(unsigned char *)((unint64_t)&v224 | v47 & 0xF) = BYTE1(v51) & 3;
      int8x16_t v49 = v224;
      v50 += 10;
      ++v47;
    }
    while (v202 != v50);
    int8x16_t v216 = v48;
    int8x16_t v217 = v224;
    unsigned int v212 = v21;
    unint64_t v213 = v45 & 0x1FFFFFF8;
    unsigned __int16 v214 = (char *)v24 + v25;
    if (v203)
    {
      if (v40 + (v46 >> 1) > v41) {
        return 0;
      }
      if (!v46) {
        goto LABEL_119;
      }
      unint64_t v60 = 0;
      int v61 = (_DWORD *)((char *)v24 + v40);
      do
      {
        unsigned int v62 = *v61++;
        uint64x2_t v63 = (uint64x2_t)vdupq_n_s64(v62);
        int8x16_t v64 = vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v63, (uint64x2_t)xmmword_20DAD5B90), (int8x16_t)xmmword_20DAD5BC0), vandq_s8((int8x16_t)vshlq_u64(v63, (uint64x2_t)xmmword_20DAD5BA0), (int8x16_t)xmmword_20DAD5BB0));
        *(void *)(a5 + v60) = *(unint64_t *)&vorr_s8(*(int8x8_t *)v64.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL)) | v62 & 0xF | ((unint64_t)v62 << 24) & 0xF000000000000 | ((((unint64_t)v62 >> 20) & 0xF) << 40) | ((unint64_t)v62 << 28) & 0xF00000000000000;
        v60 += 8;
      }
      while (v60 < v46);
    }
    else
    {
      if (v42 > v218 >> 4) {
        return 0;
      }
      unint64_t v210 = v39;
      unint64_t v52 = v38;
      v53.i64[0] = 0xF0F0F0F0F0F0F0FLL;
      v53.i64[1] = 0xF0F0F0F0F0F0F0FLL;
      if (v41 != v40)
      {
        unint64_t v54 = 0;
        unint64_t v55 = (char *)v24 + v40;
        size_t v56 = v201;
        do
        {
          int8x16_t v57 = *(int8x16_t *)&v55[v54];
          int8x16_t v58 = vandq_s8(v57, v53);
          int8x16_t v59 = (int8x16_t)vshrq_n_u8((uint8x16_t)v57, 4uLL);
          *size_t v56 = vzip1q_s8(v58, v59);
          v56[1] = vzip2q_s8(v58, v59);
          v56 += 2;
          v54 += 16;
        }
        while (v54 < v42);
      }
      lzbitmap_decode_rle(a5, v201, v46);
      unint64_t v46 = v213;
      unint64_t v44 = (unint64_t)v214;
      unsigned int v21 = v212;
      unint64_t v38 = v52;
      unint64_t v39 = v210;
    }
    if (v46)
    {
      unint64_t v65 = 0;
      unint64_t v66 = (int8x16_t *)((char *)v24 + 15);
      unint64_t v67 = (uint64_t *)((char *)v24 + v39);
      unint64_t v68 = (int8x16_t *)((char *)v24 + v38);
      int v69 = 8;
      v70.i64[0] = -1;
      v70.i64[1] = -1;
      while (1)
      {
        if ((unint64_t)(v67 + 1) > v44) {
          return 0;
        }
        if ((unint64_t)&v68[1] > v44) {
          return 0;
        }
        v71.i64[0] = *(void *)(a5 + v65);
        v71.i64[1] = -1;
        int8x16_t v72 = vqtbl1q_s8(v217, v71);
        *(uint8x8_t *)a9.i8 = vshl_u8(*(uint8x8_t *)v72.i8, (uint8x8_t)0x604020006040200);
        int32x4_t v73 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&a9 - 1), (int8x16_t)xmmword_20DAD5BD0);
        LODWORD(v74) = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v73.i8, 1), v73), vaddq_s32(vdupq_laneq_s32(v73, 2), vdupq_laneq_s32(v73, 3))).u32[0];
        unint64_t v75 = (int8x16_t *)((char *)v68 + v74);
        if ((unint64_t)&v75[1] > v44) {
          return 0;
        }
        int8x8_t v76 = (int8x8_t)vcgt_u8(v20, *(uint8x8_t *)(a5 + v65));
        v77.i64[1] = v216.i64[1];
        v77.i64[0] = *v67;
        int8x8_t v78 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vand_s8(v76, (int8x8_t)0x8040201008040201))));
        *(int8x8_t *)&long long v9 = vorr_s8(vqtbl1_s8(v77, lzbitmap_unpack_perm_table[*(void *)&v78]), vbic_s8((int8x8_t)*(_OWORD *)&vqtbl1q_s8(v216, v71), v76));
        int8x16_t v79 = *v68;
        v79.i32[3] = v69;
        int32x4_t v80 = (int32x4_t)vqtbl1q_s8(v79, lzbitmap_unpack_dist_perm_table[BYTE2(v74)]);
        int16x8_t v81 = vmovl_s8(vmvn_s8(vceq_s8(*(int8x8_t *)&v9, (int8x8_t)-1)));
        int32x4_t v82 = vdupq_n_s32(v19);
        int8x16_t v83 = (int8x16_t)vmovl_s16(*(int16x4_t *)v81.i8);
        a9 = vaddq_s32(v82, (int32x4_t)xmmword_20DAD5BF0);
        if ((vmaxvq_u32((uint32x4_t)vandq_s8(v83, (int8x16_t)vcgtq_u32((uint32x4_t)v80, (uint32x4_t)a9))) & 0x80000000) != 0) {
          return 0;
        }
        int8x16_t v84 = *v75;
        v84.i32[3] = v80.i32[3];
        int32x4_t v85 = (int32x4_t)vqtbl1q_s8(v84, lzbitmap_unpack_dist_perm_table[v74 >> 24]);
        int8x16_t v86 = (int8x16_t)vmovl_high_s16(v81);
        int32x4_t v87 = vaddq_s32(v82, (int32x4_t)xmmword_20DAD5BE0);
        int32x4_t v88 = (int32x4_t)vandq_s8(v86, (int8x16_t)vcgtq_u32((uint32x4_t)v85, (uint32x4_t)v87));
        v88.i32[0] = vmaxvq_u32((uint32x4_t)v88);
        int v89 = v88.i32[0];
        if (v88.i32[0] < 0) {
          return 0;
        }
        int8x16_t v90 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v88, v205), 0);
        int32x4_t v91 = (int32x4_t)vandq_s8(vandq_s8((int8x16_t)vsubq_s32(v87, v85), v86), v90);
        int32x4_t v92 = (int32x4_t)vandq_s8(vandq_s8((int8x16_t)vsubq_s32(a9, v80), v83), v90);
        v215 &= ~(v89 >> 31);
        if ((int)v19 + 64 > v32)
        {
          int v171 = 0;
          while ((unint64_t)&v66->u64[1] <= v44)
          {
            if (v19 < v32)
            {
              unint64_t v172 = 0;
              uint64_t v219 = v9;
              int v173 = *(unsigned __int8 *)((unint64_t)&v219 | v171 & 7);
              v220[0] = v92;
              v220[1] = v91;
              int v174 = *((_DWORD *)v220 + (v171 & 7));
              do
              {
                unint64_t v175 = v172;
                int v176 = 1 << v172;
                BOOL v177 = (v176 & v173) == 0;
                if ((v176 & v173) != 0) {
                  unint64_t v178 = v66;
                }
                else {
                  unint64_t v178 = (int8x16_t *)(a1 + (v174 + v175));
                }
                if (!v177) {
                  unint64_t v66 = (int8x16_t *)((char *)v66 + 1);
                }
                *(unsigned char *)(a1 + v19 + v175) = v178->i8[0];
                unint64_t v172 = v175 + 1;
              }
              while (v175 <= 6 && v172 + v19 < v32);
              uint64_t v19 = (v19 + v172);
            }
            if (++v171 == 8) {
              goto LABEL_119;
            }
          }
          return 0;
        }
        if ((unint64_t)&v66[1] > v44) {
          return 0;
        }
        uint8x8_t v93 = (uint8x8_t)vcnt_s8((int8x8_t)(unsigned __int16)v9);
        v93.i16[0] = vaddlv_u8(v93);
        uint64_t v94 = (int8x16_t *)((char *)v66 + v93.u32[0]);
        uint8x8_t v95 = (uint8x8_t)vcnt_s8((int8x8_t)WORD1(v9));
        v95.i16[0] = vaddlv_u8(v95);
        uint64_t v96 = (int8x16_t *)((char *)v94 + v95.u32[0]);
        BOOL v97 = (unint64_t)&v94[1] > v44 || (unint64_t)&v96[1] > v44;
        uint8x8_t v98 = (uint8x8_t)vcnt_s8((int8x8_t)WORD2(v9));
        v98.i16[0] = vaddlv_u8(v98);
        int v99 = (int8x16_t *)((char *)v96 + v98.u32[0]);
        if (v97 || (unint64_t)&v99[1] > v44) {
          return 0;
        }
        uint8x16_t v101 = (uint8x16_t)xmmword_20DAD5C00;
        int16x8_t v102 = vdupq_lane_s16(*(int16x4_t *)&v9, 0);
        *(int8x8_t *)v103.i8 = vmovn_s16(v102);
        v103.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v102.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v102, (int8x16_t)v102, 8uLL));
        int8x16_t v104 = (int8x16_t)vshlq_u8(v103, (uint8x16_t)xmmword_20DAD5C00);
        int8x16_t v105 = vcgtq_s8(v104, v70);
        int8x16_t v106 = vcntq_s8(v104);
        v106.u64[1] = (unint64_t)vadd_s8((int8x8_t)*(_OWORD *)&vextq_s8(v106, v106, 8uLL), vdup_lane_s8(*(int8x8_t *)v106.i8, 7));
        int8x16_t v107 = vorrq_s8(vaddq_s8(v106, v70), v105);
        int8x16_t v108 = vceqq_s8(v107, v70);
        int16x8_t v109 = vdupq_lane_s16(*(int16x4_t *)&v9, 1);
        *(int8x8_t *)v110.i8 = vmovn_s16(v109);
        v110.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v109.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v109, (int8x16_t)v109, 8uLL));
        int8x16_t v111 = (int8x16_t)vshlq_u8(v110, (uint8x16_t)xmmword_20DAD5C00);
        int8x16_t v112 = vcntq_s8(v111);
        v112.u64[1] = (unint64_t)vadd_s8((int8x8_t)*(_OWORD *)&vextq_s8(v112, v112, 8uLL), vdup_lane_s8(*(int8x8_t *)v112.i8, 7));
        int32x4_t v113 = (int32x4_t)vorrq_s8(vaddq_s8(v112, v70), vcgtq_s8(v111, v70));
        int8x16_t v114 = vceqq_s8((int8x16_t)v113, v70);
        int8x16_t v115 = vqtbl1q_s8(*v66, v107);
        int8x16_t v116 = vqtbl1q_s8(*v94, (int8x16_t)v113);
        int8x16_t v117 = *v96;
        int8x16_t v118 = *v99;
        v113.i64[0] = 0x800000008;
        v113.i64[1] = 0x800000008;
        unint64_t v119 = vextq_s8(v116, v116, 8uLL).u64[0];
        unint64_t v120 = vextq_s8(v114, v114, 8uLL).u64[0];
        unint64_t v121 = vextq_s8(v115, v115, 8uLL).u64[0];
        unint64_t v122 = vextq_s8(v108, v108, 8uLL).u64[0];
        long long v211 = v9;
        int8x8_t v208 = v78;
        double v209 = v75;
        int v207 = v85.i32[3];
        double v206 = v99;
        if ((vminvq_u32(vcgeq_u32((uint32x4_t)v82, (uint32x4_t)vaddq_s32(v92, v113))) & 0x80000000) != 0)
        {
          v129.i64[0] = *(void *)(a1 + v92.u32[0]);
          v129.i64[1] = *(void *)(a1 + v92.u32[1]);
          int8x16_t v130 = vorrq_s8(vandq_s8(v108, v129), v115);
          v131.i64[0] = *(void *)(a1 + v92.u32[2]);
          v131.i64[1] = *(void *)(a1 + v92.u32[3]);
          int8x16_t v132 = vorrq_s8(vandq_s8(v114, v131), v116);
          int8x16_t __src = v130;
          int8x16_t v228 = v132;
          unsigned int v127 = v19 + 32;
          unint64_t v133 = (int8x16_t *)(a1 + v19);
          if ((int)v19 + 32 >= v32)
          {
            size_t v136 = (v32 - v19);
            unint64_t v137 = v65;
            uint64_t v138 = v67;
            int32x4_t v198 = v92;
            int32x4_t v200 = v91;
            uint64_t v194 = v116.i64[0];
            uint64_t v196 = v114.i64[0];
            unint64_t v190 = v120;
            unint64_t v192 = v119;
            unint64_t v186 = v122;
            unint64_t v188 = v121;
            int8x16_t v184 = v117;
            int8x16_t v182 = v118;
            memcpy(v133, &__src, v136);
            int8x16_t v118 = v182;
            int8x16_t v117 = v184;
            uint8x16_t v101 = (uint8x16_t)xmmword_20DAD5C00;
            unint64_t v122 = v186;
            unint64_t v121 = v188;
            unint64_t v120 = v190;
            unint64_t v119 = v192;
            v116.i64[0] = v194;
            v114.i64[0] = v196;
            int32x4_t v92 = v198;
            int32x4_t v91 = v200;
            long long v9 = v211;
            unint64_t v67 = v138;
            unint64_t v65 = v137;
            unint64_t v46 = v213;
            unint64_t v44 = (unint64_t)v214;
            v70.i64[0] = -1;
            v70.i64[1] = -1;
            unsigned int v21 = v212;
            unsigned int v127 = v32;
          }
          else
          {
            *unint64_t v133 = v130;
            v133[1] = v132;
          }
        }
        else
        {
          int v123 = 0;
          while (1)
          {
            v222[0] = v92;
            v222[1] = v91;
            switch(v123)
            {
              case 0:
                int8x8_t v124 = *(int8x8_t *)v115.i8;
                int8x8_t v125 = *(int8x8_t *)v108.i8;
                break;
              case 1:
                int8x8_t v124 = (int8x8_t)v121;
                int8x8_t v125 = (int8x8_t)v122;
                break;
              case 2:
                int8x8_t v124 = *(int8x8_t *)v116.i8;
                int8x8_t v125 = *(int8x8_t *)v114.i8;
                break;
              case 3:
                int8x8_t v124 = (int8x8_t)v119;
                int8x8_t v125 = (int8x8_t)v120;
                break;
              default:
                int8x8_t v124 = 0;
                int8x8_t v125 = 0;
                break;
            }
            int8x8_t v126 = vorr_s8(vand_s8(v125, *(int8x8_t *)(a1 + *((unsigned int *)v222 + (v123 & 7)))), v124);
            *(int8x8_t *)__src.i8 = v126;
            unsigned int v127 = v19 + 8;
            uint64_t v128 = (int8x8_t *)(a1 + v19);
            if ((int)v19 + 8 >= v32) {
              break;
            }
            *uint64_t v128 = v126;
            ++v123;
            LODWORD(v19) = v19 + 8;
            if (v123 == 4) {
              goto LABEL_87;
            }
          }
          size_t v134 = (v32 - v19);
          unint64_t v135 = v65;
          char v180 = BYTE1(v74);
          unint64_t v74 = v67;
          int32x4_t v197 = v92;
          int32x4_t v199 = v91;
          uint64_t v193 = v116.i64[0];
          uint64_t v195 = v114.i64[0];
          unint64_t v189 = v120;
          unint64_t v191 = v119;
          unint64_t v185 = v122;
          unint64_t v187 = v121;
          int8x16_t v183 = v117;
          int8x16_t v181 = v118;
          memcpy(v128, &__src, v134);
          int8x16_t v118 = v181;
          int8x16_t v117 = v183;
          uint8x16_t v101 = (uint8x16_t)xmmword_20DAD5C00;
          unint64_t v122 = v185;
          unint64_t v121 = v187;
          unint64_t v120 = v189;
          unint64_t v119 = v191;
          v116.i64[0] = v193;
          v114.i64[0] = v195;
          int32x4_t v92 = v197;
          int32x4_t v91 = v199;
          long long v9 = v211;
          unint64_t v67 = v74;
          BYTE1(v74) = v180;
          unint64_t v65 = v135;
          unint64_t v46 = v213;
          unint64_t v44 = (unint64_t)v214;
          v70.i64[0] = -1;
          v70.i64[1] = -1;
          unsigned int v21 = v212;
          unsigned int v127 = v32;
        }
LABEL_87:
        int16x8_t v139 = vdupq_lane_s16(*(int16x4_t *)&v9, 3);
        *(int8x8_t *)v140.i8 = vmovn_s16(v139);
        v140.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v139.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v139, (int8x16_t)v139, 8uLL));
        int8x16_t v141 = (int8x16_t)vshlq_u8(v140, v101);
        int8x16_t v142 = vcgtq_s8(v141, v70);
        int8x16_t v143 = vcntq_s8(v141);
        v143.u64[1] = (unint64_t)vadd_s8((int8x8_t)*(_OWORD *)&vextq_s8(v143, v143, 8uLL), vdup_lane_s8(*(int8x8_t *)v143.i8, 7));
        int8x16_t v144 = vorrq_s8(vaddq_s8(v143, v70), v142);
        int16x8_t v145 = vdupq_lane_s16(*(int16x4_t *)&v9, 2);
        *(int8x8_t *)v142.i8 = vmovn_s16(v145);
        v142.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v145.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v145, (int8x16_t)v145, 8uLL));
        int8x16_t v146 = (int8x16_t)vshlq_u8((uint8x16_t)v142, v101);
        int8x16_t v147 = vcgtq_s8(v146, v70);
        int8x16_t v148 = vcntq_s8(v146);
        v148.u64[1] = (unint64_t)vadd_s8((int8x8_t)*(_OWORD *)&vextq_s8(v148, v148, 8uLL), vdup_lane_s8(*(int8x8_t *)v148.i8, 7));
        int8x16_t v149 = vorrq_s8(vaddq_s8(v148, v70), v147);
        int8x16_t v150 = vceqq_s8(v149, v70);
        int8x16_t v151 = vqtbl1q_s8(v117, v149);
        int8x16_t v152 = vqtbl1q_s8(v118, v144);
        a9 = (int32x4_t)vceqq_s8(v144, v70);
        v153.i64[0] = 0x800000008;
        v153.i64[1] = 0x800000008;
        if ((vminvq_u32(vcgeq_u32((uint32x4_t)vdupq_n_s32(v127), (uint32x4_t)vaddq_s32(v91, v153))) & 0x80000000) == 0) {
          break;
        }
        v163.i64[0] = *(void *)(a1 + v91.u32[0]);
        v163.i64[1] = *(void *)(a1 + v91.u32[1]);
        v164.i64[0] = *(void *)(a1 + v91.u32[2]);
        v164.i64[1] = *(void *)(a1 + v91.u32[3]);
        a9 = (int32x4_t)vandq_s8((int8x16_t)a9, v164);
        int8x16_t v165 = vorrq_s8(vandq_s8(v150, v163), v151);
        int8x16_t v166 = vorrq_s8((int8x16_t)a9, v152);
        int8x16_t __src = v165;
        int8x16_t v228 = v166;
        uint64_t v19 = v127 + 32;
        unint64_t v162 = (int8x16_t *)(a1 + v127);
        if (v19 >= v32) {
          goto LABEL_103;
        }
        int8x16_t *v162 = v165;
        v162[1] = v166;
LABEL_104:
        uint8x8_t v169 = (uint8x8_t)vcnt_s8(v208);
        v169.i16[0] = vaddlv_u8(v169);
        unint64_t v67 = (uint64_t *)((char *)v67 + v169.u32[0]);
        unint64_t v68 = (int8x16_t *)((char *)v209 + BYTE1(v74));
        int v69 = v207;
        uint8x8_t v170 = (uint8x8_t)vcnt_s8((int8x8_t)WORD3(v9));
        v170.i16[0] = vaddlv_u8(v170);
        unint64_t v66 = (int8x16_t *)((char *)v206 + v170.u32[0]);
        v65 += 8;
        if (v65 >= v46) {
          goto LABEL_119;
        }
      }
      unint64_t v154 = vextq_s8(v152, v152, 8uLL).u64[0];
      unint64_t v155 = vextq_s8((int8x16_t)a9, (int8x16_t)a9, 8uLL).u64[0];
      unint64_t v156 = vextq_s8(v151, v151, 8uLL).u64[0];
      int v157 = 4;
      unint64_t v158 = vextq_s8(v150, v150, 8uLL).u64[0];
      while (1)
      {
        v221[0] = v92;
        v221[1] = v91;
        switch(v157)
        {
          case 1:
            int8x8_t v159 = (int8x8_t)v121;
            int8x8_t v160 = (int8x8_t)v122;
            break;
          case 2:
            int8x8_t v159 = *(int8x8_t *)v116.i8;
            int8x8_t v160 = *(int8x8_t *)v114.i8;
            break;
          case 3:
            int8x8_t v159 = (int8x8_t)v119;
            int8x8_t v160 = (int8x8_t)v120;
            break;
          case 4:
            int8x8_t v159 = *(int8x8_t *)v151.i8;
            int8x8_t v160 = *(int8x8_t *)v150.i8;
            break;
          case 5:
            int8x8_t v159 = (int8x8_t)v156;
            int8x8_t v160 = (int8x8_t)v158;
            break;
          case 6:
            int8x8_t v159 = *(int8x8_t *)v152.i8;
            int8x8_t v160 = *(int8x8_t *)a9.i8;
            break;
          case 7:
            int8x8_t v159 = (int8x8_t)v154;
            int8x8_t v160 = (int8x8_t)v155;
            break;
          default:
            int8x8_t v159 = 0;
            int8x8_t v160 = 0;
            break;
        }
        int8x8_t v161 = vorr_s8(vand_s8(v160, *(int8x8_t *)(a1 + *((unsigned int *)v221 + (v157 & 7)))), v159);
        *(int8x8_t *)__src.i8 = v161;
        uint64_t v19 = v127 + 8;
        unint64_t v162 = (int8x16_t *)(a1 + v127);
        if (v19 >= v32) {
          break;
        }
        *(int8x8_t *)v162->i8 = v161;
        ++v157;
        v127 += 8;
        if (v157 == 8) {
          goto LABEL_104;
        }
      }
LABEL_103:
      unint64_t v167 = v65;
      unint64_t v168 = v67;
      memcpy(v162, &__src, v32 - v127);
      long long v9 = v211;
      unint64_t v67 = v168;
      unint64_t v65 = v167;
      unint64_t v46 = v213;
      unint64_t v44 = (unint64_t)v214;
      v70.i64[0] = -1;
      v70.i64[1] = -1;
      unsigned int v21 = v212;
      uint64_t v19 = v32;
      goto LABEL_104;
    }
LABEL_119:
    unint64_t v32 = v19;
LABEL_120:
    uint64_t v19 = v32;
    if (v32 >= a2) {
      goto LABEL_123;
    }
  }
  unint64_t v32 = v19;
LABEL_123:
  if (!v215) {
    return 0;
  }
  return v32;
}

uint64_t smb_lznt1_decode_buffer(char *__dst, unint64_t a2, char *__src, uint64_t a4)
{
  unint64_t v5 = a2;
  unint64_t v6 = __dst;
  uint64_t v7 = 0;
  uint64_t v8 = 15;
  if (a2 > 0xF) {
    uint64_t v8 = a2;
  }
  long long v9 = &__dst[v8 - 15];
  if (a4)
  {
    while (a4 != 1)
    {
      int v12 = *(unsigned __int16 *)__src;
      unsigned int v11 = __src + 2;
      __int16 v10 = v12;
      if (!v12) {
        return v7;
      }
      if ((v10 & 0x7000) != 0x3000 || (v7 & 0xFFF) != 0) {
        break;
      }
      uint64_t v14 = a4 - 2;
      unint64_t v15 = (v10 & 0xFFF) + 1;
      if (a4 - 2 < v15) {
        break;
      }
      if (v10 < 0)
      {
        unint64_t v16 = 0;
        unint64_t v17 = 0;
        do
        {
          unsigned int v18 = v11[v17];
          unint64_t v19 = v17 + 9;
          ++v17;
          if (v18) {
            BOOL v20 = 1;
          }
          else {
            BOOL v20 = v19 > v15;
          }
          if (v20 || v16 + 8 > v5)
          {
            if (v17 < v15)
            {
              unsigned int v22 = 1;
              while (1)
              {
                if (v18)
                {
                  unint64_t v24 = v17 + 2;
                  if (v17 + 2 > v15) {
                    return 0;
                  }
                  unsigned int v25 = *(unsigned __int16 *)&v11[v17];
                  unsigned int v26 = __clz(((_WORD)v16 - 1) & 0xFFF | 8) - 16;
                  unsigned int v27 = v25 >> v26;
                  unint64_t v28 = (v25 >> v26) + 1;
                  if (v16 < v28) {
                    return 0;
                  }
                  unint64_t v29 = (v25 & ~(-1 << v26)) + 3;
                  unint64_t v30 = &v6[v16];
                  unsigned int v31 = &v6[v16 + v29];
                  if (v27 < 0xF || v31 > v9)
                  {
                    if (v5 - v16 < v29) {
                      return 0;
                    }
                    uint64_t v33 = -(uint64_t)v28;
                    do
                    {
                      *unint64_t v30 = v30[v33];
                      ++v30;
                    }
                    while (v30 < v31);
                  }
                  else
                  {
                    uint64_t v32 = -(uint64_t)v28;
                    do
                    {
                      *(_OWORD *)unint64_t v30 = *(_OWORD *)&v30[v32];
                      v30 += 16;
                    }
                    while (v30 < v31);
                  }
                  v16 += v29;
                  unint64_t v17 = v24;
                }
                else
                {
                  if (v5 <= v16) {
                    return 0;
                  }
                  char v23 = v11[v17++];
                  v6[v16++] = v23;
                }
                if (v22 <= 7)
                {
                  v18 >>= 1;
                  ++v22;
                  if (v17 < v15) {
                    continue;
                  }
                }
                break;
              }
            }
          }
          else
          {
            *(void *)&v6[v16] = *(void *)&v11[v17];
            unint64_t v17 = v19;
            v16 += 8;
          }
        }
        while (v17 < v15);
      }
      else
      {
        if (v5 < v15) {
          return 0;
        }
        memcpy(v6, v11, (v10 & 0xFFF) + 1);
        unint64_t v16 = v15;
        unint64_t v17 = v15;
      }
      v6 += v16;
      v7 += v16;
      a4 = v14 - v17;
      int8x16_t __src = &v11[v17];
      v5 -= v16;
      if (v14 == v17) {
        return v7;
      }
    }
    return 0;
  }
  return v7;
}

uint64_t smb_lznt1_encode_buffer(_WORD *a1, unint64_t a2, unsigned char *a3, unint64_t a4, void *a5)
{
  bzero(a5, 0x8000uLL);
  uint64_t v10 = 0;
  if (!a4) {
    goto LABEL_64;
  }
  do
  {
    if (a4 >= 0x1000) {
      size_t v11 = 4096;
    }
    else {
      size_t v11 = a4;
    }
    unsigned int v12 = v11 + 7;
    if (a4 < v11 + 7) {
      unsigned int v12 = a4;
    }
    if (v12 <= 7) {
      unsigned int v12 = 7;
    }
    if (a2 < 3) {
      return 0;
    }
    unsigned int v13 = 0;
    unint64_t v14 = v12 - 7;
    unsigned int v15 = 3;
    unsigned int v16 = 2;
    unsigned int v17 = 0x10000;
    while (a2 >= v15 + 3)
    {
      if (v17 > 0x1FF)
      {
        unsigned int v18 = v15;
      }
      else
      {
        *((unsigned char *)a1 + v16) = v17;
        unsigned int v18 = v15 + 1;
        unsigned int v17 = 0x10000;
        unsigned int v16 = v15;
      }
      v17 >>= 1;
      if (a4 < v13 + 4)
      {
        char v19 = a3[v13++];
        unsigned int v15 = v18 + 1;
        *((unsigned char *)a1 + v18) = v19;
        goto LABEL_55;
      }
      BOOL v20 = &a3[v13];
      unsigned int v21 = *(_DWORD *)v20;
      int v22 = *(_DWORD *)v20 >> 8;
      unsigned int v23 = (-1640531535 * (*(_DWORD *)v20 & 0xFFFFFFu)) >> 19;
      uint64_t v24 = (-1640531535 * v22) >> 19;
      unsigned int v25 = *((_DWORD *)a5 + v23);
      unsigned int v26 = *((_DWORD *)a5 + v24);
      uint64_t v27 = v25 & 0xFFF;
      int v28 = *(_DWORD *)v20 & 0xFFFFF;
      *((_DWORD *)a5 + v23) = v13 + (*(_DWORD *)v20 << 12);
      if (v28 != v25 >> 12 || v27 >= v13 || v13 >= v14)
      {
        LODWORD(v31) = 0;
      }
      else
      {
        unint64_t v31 = 0;
        unsigned int v32 = 0;
        while (1)
        {
          unint64_t v31 = *(void *)&a3[v27 + v31] ^ *(void *)&v20[v31];
          if (v31) {
            break;
          }
          v32 += 8;
          unint64_t v31 = v32;
          if (v32 + (unint64_t)v13 >= v14) {
            goto LABEL_30;
          }
        }
        LODWORD(v31) = v32 + (__clz(__rbit64(v31)) >> 3);
      }
LABEL_30:
      if (((v21 >> 8) & 0xFFFFF) != v26 >> 12) {
        goto LABEL_48;
      }
      uint64_t v33 = v26 & 0xFFF;
      if (v33 > v13) {
        goto LABEL_48;
      }
      uint64_t v34 = v13 + 1;
      if (v34 >= v14)
      {
        LODWORD(v35) = 0;
LABEL_38:
        if (v33)
        {
LABEL_41:
          int v37 = v33 - 1;
          if (*v20 == a3[v37] && v31 <= v35)
          {
            LODWORD(v31) = v35 + 1;
            LODWORD(v27) = v37;
LABEL_48:
            if (v31 >= v11 - v13) {
              LODWORD(v31) = v11 - v13;
            }
            unsigned int v40 = v13 + 1;
            if (v31 > 2)
            {
              *((_DWORD *)a5 + v24) = v40 + (v22 << 12);
              unsigned int v42 = __clz(((_WORD)v13 - 1) & 0xFFF | 8) - 16;
              unsigned int v43 = (1 << v42) + 2;
              if (v31 < v43) {
                unsigned int v43 = v31;
              }
              *(_WORD *)((char *)a1 + v18) = ((v13 + ~v27) << v42) - 3 + v43;
              unsigned int v15 = v18 + 2;
              v13 += v43;
              v17 |= 0x80u;
            }
            else
            {
              char v41 = *v20;
              unsigned int v15 = v18 + 1;
              *((unsigned char *)a1 + v18) = v41;
              unsigned int v13 = v40;
            }
            goto LABEL_55;
          }
        }
      }
      else
      {
        unint64_t v35 = 0;
        unsigned int v36 = 0;
        while (1)
        {
          unint64_t v35 = *(void *)&a3[v33 + v35] ^ *(void *)&a3[v34 + v35];
          if (v35) {
            break;
          }
          v36 += 8;
          unint64_t v35 = v36;
          if ((unint64_t)v36 + v34 >= v14) {
            goto LABEL_38;
          }
        }
        LODWORD(v35) = v36 + (__clz(__rbit64(v35)) >> 3);
        if (v33) {
          goto LABEL_41;
        }
      }
      if (v31 >= v35) {
        goto LABEL_48;
      }
      char v39 = *v20;
      unsigned int v15 = v18 + 1;
      *((unsigned char *)a1 + v18) = v39;
      unsigned int v13 = v34;
LABEL_55:
      if (v13 >= v11) {
        goto LABEL_58;
      }
    }
    unsigned int v15 = -1;
    do
    {
LABEL_58:
      unsigned int v44 = v17;
      v17 >>= 1;
    }
    while (v44 > 0x1FF);
    *((unsigned char *)a1 + v16) = v44;
    uint64_t v45 = (v11 + 2);
    if (v15 < v45)
    {
      *a1 = (v15 + 32765) | 0xB000;
      uint64_t v45 = v15;
      goto LABEL_63;
    }
    if (a2 < v45) {
      return 0;
    }
    *a1 = (v11 - 1) | 0x3000;
    memcpy(a1 + 1, a3, v11);
LABEL_63:
    a3 += v11;
    a1 = (_WORD *)((char *)a1 + v45);
    a2 -= v45;
    v10 += v45;
    a4 -= v11;
  }
  while (a4);
LABEL_64:
  if (a2 >= 2)
  {
    *a1 = 0;
    v10 += 2;
  }
  return v10;
}

unint64_t get_max_payload_size(int a1, int a2, int a3, int a4, int a5)
{
  return (a2 * a1 * get_format_components(a3, a5) * (unint64_t)(a4 + 2) + 1024) >> 3;
}

uint64_t get_plane_max_rice_size(int a1)
{
  return (666 * a1 + 9580) >> 3;
}

uint64_t get_slice_width(unsigned __int16 *a1, int a2)
{
  unsigned int v2 = a1[2] + a2;
  if (v2 >= *a1) {
    unsigned int v2 = *a1;
  }
  return v2 - a2;
}

uint64_t get_slice_height(uint64_t a1, int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 6) + a2;
  if (v2 >= *(unsigned __int16 *)(a1 + 2)) {
    unsigned int v2 = *(unsigned __int16 *)(a1 + 2);
  }
  return v2 - a2;
}

uint64_t get_pool_size(uint64_t a1, int a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 17);
  if (*(unsigned char *)(a1 + 17))
  {
    unint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = a1 + 18;
    uint64_t v40 = a1 + 18;
    do
    {
      unint64_t v9 = v4;
      uint64_t v10 = (unsigned __int16 *)(v8 + 10 * v4);
      uint64_t v11 = v8;
      unsigned int v13 = v10 + 1;
      unsigned __int16 v12 = v10[1];
      if (v12)
      {
        unsigned int v14 = 0;
        unsigned int v44 = v10;
        unint64_t v45 = v9;
        uint64_t v15 = v11 + 10 * v9;
        unsigned int v16 = (unsigned __int16 *)(v15 + 4);
        unsigned int v17 = (unsigned __int16 *)(v15 + 6);
        unsigned int v18 = (unsigned __int8 *)(v15 + 8);
        unsigned int v19 = *v10;
        unsigned int v42 = v18;
        unsigned int v43 = v17;
        char v41 = v10 + 1;
        do
        {
          if (v19)
          {
            unsigned int v20 = 0;
            int v21 = *v16;
            do
            {
              uint64_t v46 = v7;
              uint64_t v47 = v5;
              unsigned int v22 = v20 + v21;
              if (v22 < v19) {
                unsigned int v19 = v22;
              }
              uint64_t v23 = v19 - v20;
              unsigned int v24 = v14 + *v17;
              if (v24 >= *v13) {
                unsigned int v24 = *v13;
              }
              uint64_t v25 = v24 - v14;
              int v26 = *v18;
              int format_components = get_format_components(*(unsigned __int8 *)(a1 + 16), v45);
              unsigned int v28 = v26 + 2;
              int v29 = *(unsigned __int8 *)(a1 + 16);
              uint64_t v49 = 0;
              unint64_t v30 = v28 * (unint64_t)(v25 * v23 * format_components) + 1024;
              memset(v48, 0, sizeof(v48));
              unsigned int v31 = get_format_components(v29, v45);
              unint64_t v32 = yzip_plane_encoder_allocate((unint64_t *)v48, v23, v25, v31, v29, 0);
              LODWORD(v25) = *(unsigned __int8 *)(a1 + 16);
              v6 += (v30 >> 3) + v32 + 16;
              v48[0] = 0uLL;
              unsigned int v33 = get_format_components(v25, v45);
              unint64_t v34 = yzip_plane_decoder_allocate(v48, v23, v33, v25, 0);
              unsigned int v13 = v41;
              unsigned int v18 = v42;
              uint64_t v35 = v46 + v34;
              unsigned int v17 = v43;
              uint64_t v7 = v35 + 16;
              int v21 = *v16;
              v20 += v21;
              uint64_t v5 = v47 + 1;
              unsigned int v19 = *v44;
            }
            while (v20 < v19);
            unsigned __int16 v12 = *v41;
          }
          v14 += *v17;
        }
        while (v14 < v12);
        unsigned int v2 = *(unsigned __int8 *)(a1 + 17);
        uint64_t v8 = v40;
        unint64_t v36 = v45;
      }
      else
      {
        uint64_t v8 = v11;
        unint64_t v36 = v9;
      }
      unint64_t v4 = v36 + 1;
    }
    while (v4 < v2);
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  uint64_t v37 = v6 + 32 * v5;
  if (!a2) {
    uint64_t v37 = v7 + 16 * v5;
  }
  return 160 * v5 + 2664 * v2 + v37 + 80;
}

uint64_t yzip_jobs_worker_entry(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 152);
  switch(v3)
  {
    case 2:
      uint64_t v4 = yzip_plane_decoder(a2);
LABEL_7:
      *(void *)(a2 + 144) = v4;
      return 0;
    case 1:
      uint64_t v4 = yzip_plane_encoder_phase2(a2);
      goto LABEL_7;
    case 0:
      *(void *)(a2 + 144) = (int)yzip_plane_encoder_phase1(a2);
      *(_DWORD *)(a2 + 152) = 1;
      break;
  }
  return 0;
}

unint64_t yzip_jobs_create_encoder_list(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t empty_list = yzip_jobs_create_empty_list(a1, a3);
  unsigned int v5 = *(unsigned __int8 *)(a3 + 17);
  if (*(unsigned char *)(a3 + 17))
  {
    unint64_t v6 = 0;
    uint64_t v7 = *(void *)(empty_list + 16);
    uint64_t v8 = a3 + 18;
    do
    {
      unint64_t v9 = (unsigned __int16 *)(v8 + 10 * v6);
      unsigned __int16 v10 = v9[1];
      char v39 = v9 + 1;
      if (v10)
      {
        unsigned int v11 = 0;
        uint64_t v12 = a2 + 32 * v6;
        unint64_t v36 = (void *)(v12 + 24);
        uint64_t v37 = (uint64_t *)(v12 + 16);
        unint64_t v13 = v8 + 10 * v6;
        unint64_t v38 = (unsigned __int16 *)(v13 + 4);
        uint64_t v40 = (unsigned __int16 *)(v13 + 6);
        uint64_t v35 = (unsigned __int8 *)(v13 + 8);
        unsigned int v14 = *v9;
        do
        {
          if (v14)
          {
            unsigned int v15 = 0;
            int v16 = *v38;
            do
            {
              *(_DWORD *)(v7 + 152) = 0;
              *(void *)(v7 + 24) = a3;
              *(void *)(v7 + 32) = v9;
              unsigned int v17 = v9;
              *(void *)(v7 + 8) = *v36;
              unsigned int v18 = v15 + v16;
              if (v18 < v14) {
                unsigned int v14 = v18;
              }
              *(_DWORD *)(v7 + 16) = v14 - v15;
              unsigned int v19 = v11 + *v40;
              if (v19 >= *v39) {
                unsigned int v19 = *v39;
              }
              *(_DWORD *)(v7 + 20) = v19 - v11;
              uint64_t v20 = *v37;
              *(void *)uint64_t v7 = v20
                            + get_format_bytes_per_pixel(*(unsigned __int8 *)(a3 + 16), *v35, v6) * v15
                            + *(void *)(v7 + 8) * v11;
              LODWORD(v20) = *v35;
              int v21 = *(_DWORD *)(v7 + 20) * *(_DWORD *)(v7 + 16);
              size_t v22 = ((v20 + 2)
                   * (unint64_t)(v21 * get_format_components(*(unsigned __int8 *)(a3 + 16), v6))
                   + 1024) >> 3;
              *(void *)(v7 + 144) = v22;
              unint64_t v23 = *(void *)(a1 + 16);
              unint64_t v24 = (*(void *)(a1 + 8) + 15) & 0xFFFFFFFFFFFFFFF0;
              *(void *)(a1 + 8) = v24 + v22;
              if (v24 + v22 > v23) {
                unint64_t v24 = (unint64_t)malloc(v22);
              }
              *(void *)(v7 + 104) = v24;
              uint64_t v25 = *(unsigned int *)(v7 + 16);
              uint64_t v26 = *(unsigned int *)(v7 + 20);
              int v27 = *(unsigned __int8 *)(a3 + 16);
              uint64_t v42 = 0;
              memset(v41, 0, sizeof(v41));
              unsigned int format_components = get_format_components(v27, v6);
              size_t v29 = yzip_plane_encoder_allocate((unint64_t *)v41, v25, v26, format_components, v27, 0) + 16;
              unint64_t v30 = *(void *)(a1 + 16);
              unint64_t v31 = (*(void *)(a1 + 8) + 15) & 0xFFFFFFFFFFFFFFF0;
              *(void *)(a1 + 8) = v31 + v29;
              if (v31 + v29 > v30) {
                unint64_t v31 = (unint64_t)malloc(v29);
              }
              *(void *)(v7 + 96) = v31;
              int v16 = *v38;
              v15 += v16;
              v7 += 160;
              unint64_t v9 = v17;
              unsigned int v14 = *v17;
            }
            while (v15 < v14);
            unsigned __int16 v10 = *v39;
          }
          v11 += *v40;
        }
        while (v11 < v10);
        unsigned int v5 = *(unsigned __int8 *)(a3 + 17);
        uint64_t v8 = a3 + 18;
      }
      ++v6;
    }
    while (v6 < v5);
  }
  return empty_list;
}

unint64_t yzip_jobs_create_empty_list(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = (*(void *)(a1 + 8) + 15) & 0xFFFFFFFFFFFFFFF0;
  *(void *)(a1 + 8) = v5 + 32;
  if (v5 + 32 > v4) {
    unint64_t v5 = (unint64_t)malloc(0x20uLL);
  }
  *(_OWORD *)unint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  uint64_t v6 = *(unsigned __int8 *)(a2 + 17);
  if (*(unsigned char *)(a2 + 17))
  {
    unsigned int v7 = 0;
    uint64_t v8 = (unsigned __int16 *)(a2 + 24);
    do
    {
      int v9 = (*(v8 - 3) + *(v8 - 1) - 1) / *(v8 - 1);
      int v10 = *(v8 - 2);
      int v11 = *v8;
      v8 += 5;
      v7 += (v10 + v11 - 1) / v11 * v9;
      --v6;
    }
    while (v6);
  }
  else
  {
    unsigned int v7 = 0;
  }
  *(_DWORD *)(v5 + 24) = v7;
  *(void *)unint64_t v5 = a2;
  unsigned int v12 = *(unsigned __int8 *)(a2 + 17);
  unint64_t v13 = *(void *)(a1 + 16);
  unint64_t v14 = (*(void *)(a1 + 8) + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v15 = v14 + 2664 * v12;
  if (v15 > v13) {
    unint64_t v14 = (unint64_t)malloc(2664 * v12);
  }
  *(void *)(v5 + 8) = v14;
  unint64_t v16 = (v15 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v17 = v16 + 160 * v7;
  *(void *)(a1 + 8) = v17;
  if (v17 > v13) {
    unint64_t v16 = (unint64_t)malloc(160 * v7);
  }
  *(void *)(v5 + 16) = v16;
  return v5;
}

unint64_t yzip_jobs_create_decoder_list(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v7 = a3;
  unint64_t result = yzip_jobs_create_empty_list(a1, a3);
  uint64_t v10 = *(unsigned __int16 *)(v7 + 6);
  if (v10 > a5) {
    return 0;
  }
  if (*(unsigned char *)(v7 + 17))
  {
    unint64_t v11 = 0;
    unsigned int v12 = 0;
    unint64_t v13 = 0;
    unint64_t v80 = (unint64_t)&a4[a5];
    int8x16_t v83 = &a4[v10];
    unint64_t v14 = &a4[v10 & 0xFFFC];
    unint64_t v84 = result;
    uint64_t v85 = v7;
    do
    {
      unint64_t v15 = (char *)(*(void *)(result + 8) + 2664 * v11);
      unsigned int v16 = *(unsigned __int8 *)(v7 + 10 * v11 + 26);
      bzero(v15, 0xA68uLL);
      unint64_t v17 = 0;
      unsigned int v18 = 0;
      if (v16 <= 8) {
        char v19 = 7;
      }
      else {
        char v19 = 15;
      }
      do
      {
        if (v12 <= 0x20)
        {
          if (a4 >= v14)
          {
            uint64_t v20 = 0;
          }
          else
          {
            unsigned int v21 = *(_DWORD *)a4;
            a4 += 4;
            uint64_t v20 = v21;
          }
          v13 += v20 << v12;
          v12 += 32;
        }
        char v22 = v13;
        unsigned int v23 = v12 - 1;
        v13 >>= 1;
        if (v22)
        {
          if (v17 <= 0xA) {
            int v24 = -1;
          }
          else {
            int v24 = -11;
          }
          int v25 = v24 + v17;
          if (v25 < 0)
          {
            int v27 = 0;
            char v28 = 0;
          }
          else
          {
            uint64_t v26 = &v15[4 * v25];
            int v27 = *(__int16 *)v26;
            char v28 = v26[2];
          }
          int v29 = 0;
          for (unsigned int i = v18 - 1; ; ++i)
          {
            if (v23 > 0x20)
            {
              unsigned int v33 = v23;
            }
            else
            {
              if (a4 >= v14)
              {
                uint64_t v31 = 0;
              }
              else
              {
                unsigned int v32 = *(_DWORD *)a4;
                a4 += 4;
                uint64_t v31 = v32;
              }
              v13 += v31 << v23;
              unsigned int v33 = v23 + 32;
            }
            char v34 = v13;
            unsigned int v23 = v33 - 1;
            v13 >>= 1;
            int v35 = lut_rle[v18 & 0x3F];
            if ((v34 & 1) == 0) {
              break;
            }
            LOBYTE(v18) = v18 + 1;
            v29 += 1 << v35;
          }
          if (v23 <= 0x20)
          {
            if (a4 >= v14)
            {
              uint64_t v36 = 0;
            }
            else
            {
              unsigned int v37 = *(_DWORD *)a4;
              a4 += 4;
              uint64_t v36 = v37;
            }
            v13 += v36 << v23;
            unsigned int v23 = v33 + 31;
          }
          int v38 = v13 & ~(-1 << v35);
          unsigned int v39 = v23 - v35;
          unint64_t v40 = v13 >> v35;
          *(_WORD *)&v15[4 * v17] = (int)(((-((v38 + v29) & 1) ^ ((v38 + v29) >> 1)) + v27) << (32 - v16)) >> (32 - v16);
          if (v39 <= 0x20)
          {
            if (a4 >= v14)
            {
              uint64_t v41 = 0;
            }
            else
            {
              unsigned int v42 = *(_DWORD *)a4;
              a4 += 4;
              uint64_t v41 = v42;
            }
            v40 += v41 << v39;
            v39 += 32;
          }
          unsigned int v43 = __clz(__rbit32(v40 | 0x80000000));
          unsigned int v44 = v39 - (v43 + 1);
          unint64_t v45 = v40 >> (v43 + 1);
          if (v44 <= 0x20)
          {
            if (a4 >= v14)
            {
              uint64_t v46 = 0;
            }
            else
            {
              unsigned int v47 = *(_DWORD *)a4;
              a4 += 4;
              uint64_t v46 = v47;
            }
            v45 += v46 << v44;
            v44 += 32;
          }
          unsigned int v18 = i + (i >> 31);
          char v48 = -1;
          unsigned int v49 = (v45 & ~(-1 << v43)) + ~(-1 << v43);
          char v50 = ((-(v49 & 1) ^ (v49 >> 1)) + v28) & v19;
          v15[4 * v17 + 2] = v50;
          int v51 = 16 << v50;
          do
            ++v48;
          while (!(((1 << v48) + v51) >> v16));
          unsigned int v12 = v44 - v43;
          unint64_t v13 = v45 >> v43;
          v15[4 * v17 + 3] = v48;
        }
        else
        {
          --v12;
        }
        ++v17;
      }
      while (v17 != 666);
      ++v11;
      unint64_t result = v84;
      uint64_t v7 = v85;
      unint64_t v52 = *(unsigned __int8 *)(v85 + 17);
    }
    while (v11 < v52);
    if (*(unsigned char *)(v85 + 17))
    {
      uint64_t v53 = 0;
      uint64_t v54 = v85 + 18;
      uint64_t v55 = *(void *)(v84 + 16);
      while (1)
      {
        size_t v56 = (unsigned __int16 *)(v54 + 10 * v53);
        int8x16_t v58 = v56 + 1;
        unsigned __int16 v57 = v56[1];
        if (v57) {
          break;
        }
LABEL_68:
        if (++v53 >= (unint64_t)v52) {
          return result;
        }
      }
      unsigned int v59 = 0;
      uint64_t v60 = a2 + 32 * v53;
      int8x16_t v77 = (void *)(v60 + 24);
      int8x8_t v78 = (uint64_t *)(v60 + 16);
      uint64_t v61 = v54 + 10 * v53;
      int8x16_t v79 = (unsigned __int16 *)(v61 + 4);
      int16x8_t v81 = (unsigned __int16 *)(v61 + 6);
      int8x8_t v76 = (unsigned __int8 *)(v61 + 8);
      unsigned int v62 = *v56;
      while (!v62)
      {
LABEL_66:
        v59 += *v81;
        if (v59 >= v57)
        {
          LOBYTE(v52) = *(unsigned char *)(v85 + 17);
          goto LABEL_68;
        }
      }
      unsigned int v63 = 0;
      int v64 = *v79;
      while (1)
      {
        *(_DWORD *)(v55 + 152) = 2;
        *(void *)(v55 + 24) = v85;
        *(void *)(v55 + 32) = v56;
        *(void *)(v55 + 8) = *v77;
        unsigned int v65 = v63 + v64;
        if (v65 < v62) {
          unsigned int v62 = v65;
        }
        *(_DWORD *)(v55 + 16) = v62 - v63;
        unsigned int v66 = v59 + *v81;
        if (v66 >= *v58) {
          unsigned int v66 = *v58;
        }
        *(_DWORD *)(v55 + 20) = v66 - v59;
        uint64_t v67 = *v78;
        *(void *)uint64_t v55 = v67
                       + get_format_bytes_per_pixel(*(unsigned __int8 *)(v85 + 16), *v76, v53) * v63
                       + *(void *)(v55 + 8) * v59;
        uint64_t v68 = *(unsigned int *)(v55 + 16);
        int v69 = *(unsigned __int8 *)(v85 + 16);
        v86[0] = 0;
        v86[1] = 0;
        unsigned int format_components = get_format_components(v69, v53);
        size_t v71 = yzip_plane_decoder_allocate(v86, v68, format_components, v69, 0) + 16;
        unint64_t v72 = *(void *)(a1 + 16);
        unint64_t v73 = (*(void *)(a1 + 8) + 15) & 0xFFFFFFFFFFFFFFF0;
        *(void *)(a1 + 8) = v73 + v71;
        if (v73 + v71 > v72) {
          unint64_t v73 = (unint64_t)malloc(v71);
        }
        *(void *)(v55 + 96) = v73;
        unint64_t result = v84;
        *(void *)(v55 + 120) = *(void *)(v84 + 8) + 2664 * v53;
        if ((unint64_t)(v83 + 4) > v80) {
          return 0;
        }
        *(void *)(v55 + 104) = v83 + 4;
        uint64_t v74 = *(unsigned int *)v83;
        *(void *)(v55 + 144) = v74;
        unint64_t v75 = (unint64_t)&v83[v74 + 4];
        if (v75 > v80) {
          return 0;
        }
        int8x16_t v83 = (char *)v75;
        int v64 = *v79;
        v63 += v64;
        v55 += 160;
        unsigned int v62 = *v56;
        if (v63 >= v62)
        {
          unsigned __int16 v57 = *v58;
          uint64_t v54 = v85 + 18;
          goto LABEL_66;
        }
      }
    }
  }
  return result;
}

uint64_t yzip_jobs_encode(uint64_t a1, uint64_t *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t)a2;
  uint64_t v7 = *a2;
  yzip_jobs_process(a1, (uint64_t)a2);
  uint64_t v69 = a4;
  uint64_t v8 = (char *)a3 + (a4 & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v74 = v6;
  unsigned int v66 = v8;
  uint64_t v67 = a3;
  if (*(unsigned char *)(v7 + 17))
  {
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    unsigned int v12 = *(void **)(v6 + 16);
    unint64_t v13 = v8 - 7;
    uint64_t v14 = v7 + 18;
    size_t v71 = v8 - 7;
    uint64_t v72 = v7;
    uint64_t v70 = v7 + 18;
    while (1)
    {
      unsigned int v15 = *(unsigned __int8 *)(v7 + 10 * v9 + 26);
      if (v13 - (char *)a3 - ((v10 + 31) >> 3) < (uint64_t)((666 * (unint64_t)v15 + 9580) >> 3)) {
        return -1;
      }
      uint64_t v16 = v12[14];
      unint64_t v17 = (unsigned __int16 *)(v14 + 10 * v9);
      int v18 = (v17[1] + v17[3] - 1) / v17[3] * ((*v17 + v17[2] - 1) / v17[2]);
      if (v18) {
        break;
      }
      uint64_t v21 = *(void *)(v6 + 8);
LABEL_13:
      uint64_t v73 = v9;
      int v25 = (char *)(v21 + 2664 * v9);
      bzero(v25, 0xA68uLL);
      unint64_t v26 = 0;
      unsigned int v27 = 0;
      if (v15 > 8) {
        char v28 = 28;
      }
      else {
        char v28 = 29;
      }
      uint64_t v14 = v70;
      unint64_t v13 = v71;
      do
      {
        int v29 = (uint64_t *)(v16 + 24 * v26);
        uint64_t v30 = *((_DWORD *)v29 + 4) != 0;
        *a3 = v11;
        unint64_t v11 = (v30 << (v10 & 0x1F)) + (v11 >> (v10 & 0x20));
        LODWORD(v30) = v10 >> 5;
        unsigned int v10 = (v10 & 0x1F) + 1;
        a3 += v30;
        unint64_t v31 = *((unsigned int *)v29 + 4);
        if (v31)
        {
          uint64_t v32 = *(void *)(v16 + 24 * v26 + 8);
          if (v32 <= 0) {
            unint64_t v33 = -(uint64_t)(-v32 / v31);
          }
          else {
            unint64_t v33 = (v31 + v32 - 1) / v31;
          }
          *(_WORD *)&v25[4 * v26] = v33;
          uint64_t v34 = *v29;
          unsigned __int8 v35 = -1;
          do
            ++v35;
          while ((uint64_t)(v31 << v35) < v34);
          v25[4 * v26 + 2] = v35;
          int v36 = v35;
          int v37 = 16 << v35;
          char v38 = -1;
          do
            ++v38;
          while (!(((1 << v38) + v37) >> v15));
          v25[4 * v26 + 3] = v38;
          if (v26 <= 0xA) {
            int v39 = -1;
          }
          else {
            int v39 = -11;
          }
          int v40 = v39 + v26;
          if (v40 < 0)
          {
            int v42 = 0;
            int v43 = 0;
          }
          else
          {
            uint64_t v41 = &v25[4 * v40];
            int v42 = *(__int16 *)v41;
            int v43 = v41[2];
          }
          unsigned int v44 = (2 * (((__int16)v33 - v42) << (32 - v15) >> (32 - v15))) ^ ~(~(2
                                                                             * (((__int16)v33 - v42) << (32 - v15) >> (32 - v15))) >> 31);
          int v45 = lut_rle[v27];
          if (v44 >> v45)
          {
            uint64_t v46 = &lut_rle[v27 + 1];
            do
            {
              *a3 = v11;
              unint64_t v11 = (v11 >> (v10 & 0x20)) + (1 << (v10 & 0x1F));
              unsigned int v47 = (v10 & 0x1F) + 1;
              a3 += v10 >> 5;
              v44 += -1 << v45;
              int v48 = *v46++;
              int v45 = v48;
              ++v27;
              unsigned int v10 = v47;
            }
            while (v44 >> v48);
          }
          else
          {
            unsigned int v47 = v10;
          }
          *a3 = v11;
          unint64_t v49 = ((unint64_t)(2 * v44) << (v47 & 0x1F)) + (v11 >> (v47 & 0x20));
          unsigned int v50 = (v47 & 0x1F) + v45 + 1;
          int v51 = &a3[v47 >> 5];
          unsigned int v27 = v27 - 1 + ((v27 - 1) >> 31);
          unsigned int v52 = ((2 * ((v36 - v43) << v28 >> v28)) ^ ~(~(2 * ((v36 - v43) << v28 >> v28)) >> 31)) + 1;
          unsigned int v53 = __clz(v52);
          uint64_t v54 = 0x80000000 >> v53;
          *int v51 = v49;
          unint64_t v55 = (v49 >> (v50 & 0x20)) + (v54 << (v50 & 0x1F));
          unsigned int v56 = (v50 & 0x1F) - v53;
          unsigned __int16 v57 = &v51[v50 >> 5];
          *unsigned __int16 v57 = v55;
          unint64_t v11 = (v55 >> ((v56 + 32) & 0x20)) + ((unint64_t)(v52 - v54) << (v56 & 0x1F));
          unsigned int v10 = (v56 & 0x1F) - v53 + 31;
          a3 = &v57[(v56 + 32) >> 5];
        }
        ++v26;
      }
      while (v26 != 666);
      uint64_t v7 = v72;
      uint64_t v9 = v73 + 1;
      uint64_t v6 = v74;
      if (v73 + 1 >= (unint64_t)*(unsigned __int8 *)(v72 + 17)) {
        goto LABEL_41;
      }
    }
    int v19 = 0;
    while (1)
    {
      uint64_t result = v12[18];
      if (result < 0) {
        break;
      }
      uint64_t v21 = *(void *)(v6 + 8);
      v12[15] = v21 + 2664 * v9;
      if (v19)
      {
        uint64_t v22 = v12[14];
        uint64_t v23 = -15984;
        do
        {
          int v24 = (int64x2_t *)(v16 + v23);
          v24[1000].i32[0] = *(_DWORD *)(v16 + v23 + 16000) + *(_DWORD *)(v22 + v23 + 16000);
          v24[999] = vaddq_s64(*(int64x2_t *)(v16 + v23 + 15984), *(int64x2_t *)(v22 + v23 + 15984));
          v23 += 24;
        }
        while (v23);
      }
      ++v19;
      v12 += 20;
      if (v19 == v18) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
    unsigned int v10 = 0;
LABEL_41:
    unint64_t v58 = (unint64_t)v67 + a4;
    *(void *)a3 = v11;
    *((void *)v66 - 1) = 0;
    unsigned __int16 v59 = ((_WORD)a3 - (_WORD)v67 + ((v10 + 7) >> 3) + 3) & 0xFFFC;
    *(_WORD *)(v7 + 6) = v59;
    uint64_t v60 = (char *)v67 + v59;
    yzip_jobs_process(a1, v6);
    if (*(_DWORD *)(v6 + 24))
    {
      uint64_t v61 = 0;
      unint64_t v62 = 0;
      while (1)
      {
        uint64_t v63 = *(void *)(v6 + 16);
        uint64_t v64 = v63 + v61;
        uint64_t result = *(void *)(v63 + v61 + 144);
        if (result < 0) {
          break;
        }
        if ((unint64_t)&v60[result + 4] > v58) {
          return -1;
        }
        *(_DWORD *)uint64_t v60 = result;
        unsigned int v65 = v60 + 4;
        memcpy(v65, *(const void **)(v63 + v61 + 104), *(void *)(v64 + 144));
        uint64_t v60 = &v65[*(void *)(v64 + 144)];
        ++v62;
        uint64_t v6 = v74;
        v61 += 160;
        if (v62 >= *(unsigned int *)(v74 + 24)) {
          return (uint64_t)&v60[v69 - v58];
        }
      }
    }
    else
    {
      return (uint64_t)&v60[v69 - v58];
    }
  }
  return result;
}

void yzip_jobs_process(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 32);
  size_t v4 = *(unsigned int *)(a2 + 24);
  if (v3 == 1)
  {
    if (!*(_DWORD *)(a2 + 24)) {
      return;
    }
  }
  else if (v4 != 1)
  {
    block[0] = MEMORY[0x263EF8330];
    block[1] = 0x40000000;
    block[2] = __yzip_jobs_process_block_invoke;
    block[3] = &__block_descriptor_tmp;
    block[4] = a2;
    dispatch_apply(v4, 0, block);
    return;
  }
  uint64_t v5 = 0;
  size_t v6 = 0;
  do
  {
    uint64_t v7 = (void *)(*(void *)(a2 + 16) + v5);
    if (*v7)
    {
      yzip_jobs_worker_entry(v4, (uint64_t)v7);
      size_t v4 = *(unsigned int *)(a2 + 24);
    }
    ++v6;
    v5 += 160;
  }
  while (v6 < v4);
}

uint64_t yzip_jobs_decode(uint64_t a1, uint64_t a2)
{
  yzip_jobs_process(a1, a2);
  uint64_t v3 = *(unsigned int *)(a2 + 24);
  if (!v3) {
    return 0;
  }
  uint64_t result = 0;
  for (unsigned int i = *(void **)(a2 + 16); !*i; i += 20)
  {
LABEL_6:
    if (!--v3) {
      return result;
    }
  }
  uint64_t v6 = i[18];
  if ((v6 & 0x8000000000000000) == 0)
  {
    result += v6;
    goto LABEL_6;
  }
  return i[18];
}

uint64_t __yzip_jobs_process_block_invoke(uint64_t result, uint64_t a2)
{
  unsigned int v2 = (void *)(*(void *)(*(void *)(result + 32) + 16) + 160 * a2);
  if (*v2) {
    return yzip_jobs_worker_entry(result, (uint64_t)v2);
  }
  return result;
}

uint64_t lzbitmap_fast_encode_state_size(unsigned int a1)
{
  if (a1 > 2) {
    return 0;
  }
  else {
    return dword_20DAD5CC0[a1];
  }
}

uint64_t lzbitmap_fast_encode(uint64_t a1, unsigned int a2, char *__src, unsigned int a4, void *a5, unsigned int a6)
{
  uint64_t result = 0;
  uint64_t v219 = *MEMORY[0x263EF8340];
  if (!a4 || !a5) {
    return result;
  }
  if (a4 >= 8) {
    size_t v10 = 8;
  }
  else {
    size_t v10 = a4;
  }
  unint64_t v193 = a1 + a2;
  if (a1 + v10 + 5 > v193) {
    return 0;
  }
  *(_WORD *)a1 = -1;
  *(_WORD *)(a1 + 2) = v10;
  *(unsigned char *)(a1 + 4) = 0;
  int v189 = a1;
  size_t v190 = v10;
  uint64_t v12 = a1 + 5;
  memcpy((void *)(a1 + 5), __src, v10);
  unsigned int v13 = v190;
  uint64_t v14 = (char *)(v12 + v190);
  if (a6 <= 2)
  {
    memset_pattern16(a5, asc_20DAD5CB0, qword_20DAD5CD0[a6]);
    unsigned int v13 = v190;
  }
  unsigned int v15 = a4;
  if (a6 == 2)
  {
    int8x16_t v217 = 0u;
    uint32x4_t v218 = 0u;
    uint32x4_t v215 = 0u;
    uint32x4_t v216 = 0u;
    uint32x4_t v213 = 0u;
    uint32x4_t v214 = 0u;
    uint32x4_t v211 = 0u;
    uint32x4_t v212 = 0u;
    long long v209 = 0u;
    long long v210 = 0u;
    if ((v13 | 0x90) <= a4)
    {
      uint64_t v191 = 8;
      int32x4_t v129 = vdupq_n_s32(0x9E3779B1);
      unsigned int v18 = v13;
      while ((unint64_t)(v14 + 164) <= v193)
      {
        unint64_t v130 = 0;
        int8x16_t v131 = &__src[v18];
        int8x16_t v133 = *(int8x16_t *)v131;
        int8x16_t v132 = (int8x16_t *)(v131 + 16);
        int8x16_t v134 = v133;
        do
        {
          int8x16_t v135 = v134;
          int8x16_t v136 = *v132++;
          int8x16_t v134 = v136;
          unint64_t v137 = (uint32x4_t *)(&v197 + 2 * v130);
          *unint64_t v137 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v135, (int8x16_t)xmmword_20DAD5C70), v129), 0x11uLL);
          v137[1] = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v135, (int8x16_t)xmmword_20DAD5C80), v129), 0x11uLL);
          v137[2] = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v135, (int8x16_t)xmmword_20DAD5C90), v129), 0x11uLL);
          v137[3] = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&v134 - 1), (int8x16_t)xmmword_20DAD5CA0), v129), 0x11uLL);
          v130 += 2;
        }
        while (v130 < 0xE);
        int v138 = 0;
        uint64_t v139 = 0;
        int v140 = 0;
        unsigned __int8 v141 = 0;
        __int16 v142 = 0;
        int8x16_t v143 = *v132;
        uint32x4_t v205 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v134, (int8x16_t)xmmword_20DAD5C70), v129), 0x11uLL);
        uint32x4_t v206 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v134, (int8x16_t)xmmword_20DAD5C80), v129), 0x11uLL);
        int8x16_t v144 = (int8x16_t)vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v134.i8, (int8x16_t)xmmword_20DAD5CA0), v129), 0x11uLL);
        uint32x4_t v207 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v134, (int8x16_t)xmmword_20DAD5C90), v129), 0x11uLL);
        int8x16_t v208 = v144;
        *(_DWORD *)uint64_t v14 = 0;
        uint64_t v145 = v191;
        do
        {
          unsigned int v146 = v18;
          int8x16_t v147 = (int8x8_t *)&__src[v18];
          *(int8x8_t *)v144.i8 = *v147;
          int8x8_t v148 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8((int8x8_t)0x8040201008040201, vceq_s8(*(int8x8_t *)((char *)v147 - v145), *v147)))));
          if (v148.i8[0])
          {
            unsigned __int8 v149 = v148.i8[0];
            v148.i32[0] = v148.u8[0];
            uint8x8_t v150 = (uint8x8_t)vcnt_s8(v148);
            v150.i16[0] = vaddlv_u8(v150);
            unsigned __int8 v151 = v150.i8[0];
            if (v150.i32[0] == 1)
            {
LABEL_102:
              int8x8_t v166 = vqtbl1_s8(v144, lzbitmap_pack_perm_table[v149]);
              *(int8x8_t *)&v211.i8[v142] = v166;
              v166.i32[0] = v149;
              v142 += vaddlv_u8((uint8x8_t)vcnt_s8(v166));
              int v138 = *(_DWORD *)v14 | (1 << v139);
              *(_DWORD *)uint64_t v14 = v138;
              v14[v141++ + 4] = v149;
            }
            else
            {
              uint64_t v152 = 0;
              int32x4_t v153 = (int8x16_t *)(&v197 + 2 * v139);
              int8x16_t v154 = v153[1];
              unsigned int v155 = v154.i32[0];
              __int16 v156 = *((_WORD *)a5 + v154.u32[0]);
              unsigned __int32 v157 = vextq_s8(*v153, *v153, 8uLL).u32[0];
              int8x16_t v158 = *v153;
              v154.i32[0] = HIDWORD(*(unsigned long long *)v153);
              LODWORD(v153) = *v153;
              __int16 v159 = *((_WORD *)a5 + v153);
              __int16 v160 = *((_WORD *)a5 + v157);
              *((_WORD *)a5 + v158.u32[1]) = v146 + 1;
              *((_WORD *)a5 + v157) = v146 + 2;
              *((_WORD *)a5 + v154.u32[0]) = v146 + 3;
              *((_WORD *)a5 + v154.u32[1]) = v146 + 5;
              *((_WORD *)a5 + v154.u32[2]) = v146 + 6;
              __int16 v194 = v146 + 4 - v156;
              __int16 v195 = v146 - v159;
              *((_WORD *)a5 + v154.u32[3]) = v146 + 7;
              __int16 v196 = v146 + 2 - v160;
              *((_WORD *)a5 + v155) = v146 + 4;
              *((_WORD *)a5 + v153) = v146;
              uint64_t v161 = v145;
              while (1)
              {
                uint64_t v162 = *(unsigned __int16 *)((char *)&v194 + v152);
                int8x8_t v163 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8((int8x8_t)0x8040201008040201, vceq_s8(*(int8x8_t *)((char *)v147 - v162), *(int8x8_t *)v144.i8)))));
                unsigned int v164 = v163.u8[0] | ((v162 - 8) >> 24);
                if (!(v163.i8[0] | ((v162 - 8) >> 24))) {
                  break;
                }
                v163.i32[0] = v163.i8[0] | ((v162 - 8) >> 24);
                uint8x8_t v165 = (uint8x8_t)vcnt_s8(v163);
                v165.i16[0] = vaddlv_u8(v165);
                if (v165.i32[0] + 2 < v151)
                {
                  unsigned __int8 v149 = v164;
                  unsigned __int8 v151 = v165.i8[0] + 2;
                  uint64_t v161 = *(unsigned __int16 *)((char *)&v194 + v152);
                  if (v152 == 4) {
                    goto LABEL_101;
                  }
                }
                v152 += 2;
                if (v152 == 6)
                {
                  uint64_t v162 = v161;
                  LOBYTE(v164) = v149;
                  if (v161 == v145) {
                    goto LABEL_102;
                  }
LABEL_101:
                  *(_DWORD *)uint64_t v14 = (0x10000 << v139) | v138;
                  *((_WORD *)&v209 + v140) = v162;
                  uint64_t v145 = v162;
                  ++v140;
                  unsigned __int8 v149 = v164;
                  goto LABEL_102;
                }
              }
              v138 |= 0x10000 << v139;
              *(_DWORD *)uint64_t v14 = v138;
              *((_WORD *)&v209 + v140) = v162;
              uint64_t v145 = v162;
              ++v140;
            }
          }
          ++v139;
          unsigned int v18 = v146 + 8;
        }
        while (v139 != 16);
        uint64_t v167 = v141 + 4;
        unint64_t v168 = 2 * v140 + (unint64_t)v142;
        if ((v168 + v167) <= 0x85)
        {
          int v176 = &v14[v167];
          long long v177 = v210;
          *(_OWORD *)int v176 = v209;
          *((_OWORD *)v176 + 1) = v177;
          if (v176 < v176 + 32)
          {
            unint64_t v178 = &v209;
            unint64_t v179 = v176;
            do
            {
              long long v180 = *v178;
              long long v181 = v178[1];
              v178 += 2;
              *(_OWORD *)unint64_t v179 = v180;
              *((_OWORD *)v179 + 1) = v181;
              v179 += 32;
            }
            while (v179 < v176 + 32);
          }
          uint64_t v14 = &v176[v168];
          uint32x4_t v182 = v212;
          int8x16_t v183 = (uint32x4_t *)&v176[v168 - v142];
          *int8x16_t v183 = v211;
          v183[1] = v182;
          if (v183 >= (uint32x4_t *)v14)
          {
            uint64_t v191 = v145;
            unsigned int v15 = a4;
          }
          else
          {
            int8x16_t v184 = &v211;
            unsigned int v15 = a4;
            do
            {
              uint32x4_t v185 = *v184;
              uint32x4_t v186 = v184[1];
              v184 += 2;
              *int8x16_t v183 = v185;
              v183[1] = v186;
              v183 += 2;
            }
            while (v183 < (uint32x4_t *)v14);
            uint64_t v191 = v145;
          }
        }
        else
        {
          uint8x8_t v169 = &__src[v18 - 128];
          *(_DWORD *)uint64_t v14 = 8454143;
          v14[4] = 0;
          long long v170 = *(_OWORD *)v169;
          long long v171 = *((_OWORD *)v169 + 1);
          long long v172 = *((_OWORD *)v169 + 2);
          *(_OWORD *)(v14 + 53) = *((_OWORD *)v169 + 3);
          *(_OWORD *)(v14 + 37) = v172;
          *(_OWORD *)(v14 + 21) = v171;
          *(_OWORD *)(v14 + 5) = v170;
          long long v173 = *((_OWORD *)v169 + 4);
          long long v174 = *((_OWORD *)v169 + 5);
          long long v175 = *((_OWORD *)v169 + 6);
          *(_OWORD *)(v14 + 117) = *((_OWORD *)v169 + 7);
          *(_OWORD *)(v14 + 101) = v175;
          *(_OWORD *)(v14 + 85) = v174;
          *(_OWORD *)(v14 + 69) = v173;
          v14 += 133;
          unsigned int v15 = a4;
        }
        if (v146 + 152 > v15) {
          goto LABEL_118;
        }
      }
      goto LABEL_117;
    }
    goto LABEL_87;
  }
  if (a6 == 1)
  {
    int8x16_t v217 = 0u;
    uint32x4_t v218 = 0u;
    uint32x4_t v215 = 0u;
    uint32x4_t v216 = 0u;
    uint32x4_t v213 = 0u;
    uint32x4_t v214 = 0u;
    uint32x4_t v211 = 0u;
    uint32x4_t v212 = 0u;
    long long v209 = 0u;
    long long v210 = 0u;
    if ((v13 | 0x90) <= a4)
    {
      uint64_t v71 = 8;
      int32x4_t v72 = vdupq_n_s32(0x9E3779B1);
      unsigned int v18 = v13;
      while ((unint64_t)(v14 + 164) <= v193)
      {
        unint64_t v73 = 0;
        uint64_t v74 = &__src[v18];
        int8x16_t v76 = *(int8x16_t *)v74;
        unint64_t v75 = (int8x16_t *)(v74 + 16);
        int8x16_t v77 = v76;
        do
        {
          int8x16_t v78 = v77;
          int8x16_t v79 = *v75++;
          int8x16_t v77 = v79;
          unint64_t v80 = (uint32x4_t *)(&v197 + 2 * v73);
          *unint64_t v80 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v78, (int8x16_t)xmmword_20DAD5C70), v72), 0x13uLL);
          v80[1] = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v78, (int8x16_t)xmmword_20DAD5C80), v72), 0x13uLL);
          v80[2] = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v78, (int8x16_t)xmmword_20DAD5C90), v72), 0x13uLL);
          v80[3] = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&v77 - 1), (int8x16_t)xmmword_20DAD5CA0), v72), 0x13uLL);
          v73 += 2;
        }
        while (v73 < 0xE);
        int v81 = 0;
        uint64_t v82 = 0;
        int v83 = 0;
        unsigned __int8 v84 = 0;
        __int16 v85 = 0;
        int8x16_t v86 = *v75;
        uint32x4_t v205 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v77, (int8x16_t)xmmword_20DAD5C70), v72), 0x13uLL);
        uint32x4_t v206 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v77, (int8x16_t)xmmword_20DAD5C80), v72), 0x13uLL);
        int8x16_t v87 = (int8x16_t)vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v77.i8, (int8x16_t)xmmword_20DAD5CA0), v72), 0x13uLL);
        uint32x4_t v207 = vshrq_n_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v77, (int8x16_t)xmmword_20DAD5C90), v72), 0x13uLL);
        int8x16_t v208 = v87;
        *(_DWORD *)uint64_t v14 = 0;
        uint64_t v88 = v71;
        do
        {
          unsigned int v89 = v18;
          int8x16_t v90 = (int8x8_t *)&__src[v18];
          *(int8x8_t *)v87.i8 = *v90;
          int8x8_t v91 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8((int8x8_t)0x8040201008040201, vceq_s8(*(int8x8_t *)((char *)v90- (unsigned __int16)v88), *v90)))));
          if (v91.i8[0])
          {
            unsigned __int8 v92 = v91.i8[0];
            v91.i32[0] = v91.u8[0];
            uint8x8_t v93 = (uint8x8_t)vcnt_s8(v91);
            v93.i16[0] = vaddlv_u8(v93);
            unsigned __int8 v94 = v93.i8[0];
            if (v93.i32[0] != 1)
            {
              uint64_t v95 = 0;
              uint64_t v96 = (int8x16_t *)(&v197 + 2 * v82);
              int8x16_t v97 = *v96;
              int8x16_t v98 = v96[1];
              unint64_t v99 = vextq_s8(v97, v97, 4uLL).u64[0];
              __int16 v194 = v89 + 4 - *((_WORD *)a5 + v98.u32[0]);
              __int16 v195 = v89 - *((_WORD *)a5 + v97.u32[0]);
              *((_WORD *)a5 + v99) = v89 + 1;
              *((_WORD *)a5 + HIDWORD(v99)) = v89 + 2;
              *((_WORD *)a5 + v97.u32[3]) = v89 + 3;
              *((_WORD *)a5 + v98.u32[1]) = v89 + 5;
              *((_WORD *)a5 + v98.u32[2]) = v89 + 6;
              *((_WORD *)a5 + v98.u32[3]) = v89 + 7;
              *((_WORD *)a5 + v98.u32[0]) = v89 + 4;
              *((_WORD *)a5 + v97.u32[0]) = v89;
              int v100 = 1;
              LODWORD(v101) = v88;
              do
              {
                uint64_t v102 = (unsigned __int16)*(&v194 + v95);
                int8x8_t v103 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8((int8x8_t)0x8040201008040201, vceq_s8(*(int8x8_t *)((char *)v90 - v102), *(int8x8_t *)v87.i8)))));
                unsigned int v104 = v103.u8[0] | ((v102 - 8) >> 24);
                if (!(v103.i8[0] | ((v102 - 8) >> 24)))
                {
                  v81 |= 0x10000 << v82;
                  *(_DWORD *)uint64_t v14 = v81;
                  *((_WORD *)&v209 + v83) = v102;
                  uint64_t v88 = v102;
                  ++v83;
                  goto LABEL_73;
                }
                char v105 = v100;
                v103.i32[0] = v103.i8[0] | ((v102 - 8) >> 24);
                uint8x8_t v106 = (uint8x8_t)vcnt_s8(v103);
                v106.i16[0] = vaddlv_u8(v106);
                unsigned __int8 v107 = v106.i8[0] + 2;
                if (((v106.i32[0] + 2 < v94) & ~v100) != 0)
                {
                  uint64_t v101 = v102;
                  unsigned __int8 v92 = v104;
                  goto LABEL_71;
                }
                int v100 = 0;
                if (v94 > v107) {
                  uint64_t v101 = v102;
                }
                else {
                  uint64_t v101 = v101;
                }
                if (v94 > v107) {
                  unsigned __int8 v92 = v104;
                }
                if (v94 >= v107) {
                  unsigned __int8 v94 = v106.i8[0] + 2;
                }
                uint64_t v95 = 1;
              }
              while ((v105 & 1) != 0);
              if ((unsigned __int16)v101 == (unsigned __int16)v88) {
                goto LABEL_72;
              }
LABEL_71:
              *(_DWORD *)uint64_t v14 = (0x10000 << v82) | v81;
              *((_WORD *)&v209 + v83) = v101;
              uint64_t v88 = v101;
              ++v83;
            }
LABEL_72:
            int8x8_t v108 = vqtbl1_s8(v87, lzbitmap_pack_perm_table[v92]);
            *(int8x8_t *)&v211.i8[v85] = v108;
            v108.i32[0] = v92;
            v85 += vaddlv_u8((uint8x8_t)vcnt_s8(v108));
            int v81 = *(_DWORD *)v14 | (1 << v82);
            *(_DWORD *)uint64_t v14 = v81;
            v14[v84++ + 4] = v92;
          }
LABEL_73:
          ++v82;
          unsigned int v18 = v89 + 8;
        }
        while (v82 != 16);
        uint64_t v109 = v84 + 4;
        unint64_t v110 = 2 * v83 + (unint64_t)v85;
        if ((v110 + v109) <= 0x85)
        {
          int8x16_t v118 = &v14[v109];
          long long v119 = v210;
          *(_OWORD *)int8x16_t v118 = v209;
          *((_OWORD *)v118 + 1) = v119;
          if (v118 < v118 + 32)
          {
            unint64_t v120 = &v209;
            unint64_t v121 = v118;
            do
            {
              long long v122 = *v120;
              long long v123 = v120[1];
              v120 += 2;
              *(_OWORD *)unint64_t v121 = v122;
              *((_OWORD *)v121 + 1) = v123;
              v121 += 32;
            }
            while (v121 < v118 + 32);
          }
          uint64_t v14 = &v118[v110];
          uint32x4_t v124 = v212;
          int8x8_t v125 = (uint32x4_t *)&v118[v110 - v85];
          *int8x8_t v125 = v211;
          v125[1] = v124;
          if (v125 >= (uint32x4_t *)v14)
          {
            uint64_t v71 = v88;
            unsigned int v15 = a4;
          }
          else
          {
            int8x8_t v126 = &v211;
            unsigned int v15 = a4;
            do
            {
              uint32x4_t v127 = *v126;
              uint32x4_t v128 = v126[1];
              v126 += 2;
              *int8x8_t v125 = v127;
              v125[1] = v128;
              v125 += 2;
            }
            while (v125 < (uint32x4_t *)v14);
            uint64_t v71 = v88;
          }
        }
        else
        {
          int8x16_t v111 = &__src[v18 - 128];
          *(_DWORD *)uint64_t v14 = 8454143;
          v14[4] = 0;
          long long v112 = *(_OWORD *)v111;
          long long v113 = *((_OWORD *)v111 + 1);
          long long v114 = *((_OWORD *)v111 + 2);
          *(_OWORD *)(v14 + 53) = *((_OWORD *)v111 + 3);
          *(_OWORD *)(v14 + 37) = v114;
          *(_OWORD *)(v14 + 21) = v113;
          *(_OWORD *)(v14 + 5) = v112;
          long long v115 = *((_OWORD *)v111 + 4);
          long long v116 = *((_OWORD *)v111 + 5);
          long long v117 = *((_OWORD *)v111 + 6);
          *(_OWORD *)(v14 + 117) = *((_OWORD *)v111 + 7);
          *(_OWORD *)(v14 + 101) = v117;
          *(_OWORD *)(v14 + 85) = v116;
          *(_OWORD *)(v14 + 69) = v115;
          v14 += 133;
          unsigned int v15 = a4;
        }
        if (v89 + 152 > v15) {
          goto LABEL_118;
        }
      }
      goto LABEL_117;
    }
LABEL_87:
    unsigned int v18 = v13;
    goto LABEL_118;
  }
  if (a6) {
    return 0;
  }
  long long v203 = 0u;
  long long v204 = 0u;
  long long v201 = 0u;
  long long v202 = 0u;
  long long v199 = 0u;
  long long v200 = 0u;
  long long v197 = 0u;
  long long v198 = 0u;
  long long v209 = 0u;
  long long v210 = 0u;
  if ((v13 | 0x90) > a4) {
    goto LABEL_87;
  }
  uint64_t v16 = 8;
  int32x4_t v17 = vdupq_n_s32(0x9E3779B1);
  unsigned int v18 = v13;
  while ((unint64_t)(v14 + 164) <= v193)
  {
    int v19 = 0;
    uint64_t v20 = 0;
    int v21 = 0;
    unsigned __int8 v22 = 0;
    __int16 v23 = 0;
    int v24 = (int32x4_t *)&__src[v18];
    uint32x4_t v25 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[1], v17), 0x13uLL);
    uint32x4_t v211 = vshrq_n_u32((uint32x4_t)vmulq_s32(*v24, v17), 0x13uLL);
    uint32x4_t v212 = v25;
    uint32x4_t v26 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[3], v17), 0x13uLL);
    uint32x4_t v213 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[2], v17), 0x13uLL);
    uint32x4_t v214 = v26;
    uint32x4_t v27 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[5], v17), 0x13uLL);
    uint32x4_t v215 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[4], v17), 0x13uLL);
    uint32x4_t v216 = v27;
    int8x16_t v28 = (int8x16_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v24[6], v17), 0x13uLL);
    uint32x4_t v29 = vshrq_n_u32((uint32x4_t)vmulq_s32(v24[7], v17), 0x13uLL);
    int8x16_t v217 = v28;
    uint32x4_t v218 = v29;
    *(_DWORD *)uint64_t v14 = 0;
    uint64_t v30 = v16;
    uint64_t v31 = v16;
    do
    {
      unsigned int v32 = v18;
      unint64_t v33 = (int8x8_t *)&__src[v18];
      *(int8x8_t *)v28.i8 = *v33;
      int8x8_t v34 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8((int8x8_t)0x8040201008040201, vceq_s8(*(int8x8_t *)((char *)v33 - (unsigned __int16)v31), *v33)))));
      if (v34.i8[0])
      {
        unsigned __int8 v35 = v34.i8[0];
        v34.i32[0] = v34.u8[0];
        uint8x8_t v36 = (uint8x8_t)vcnt_s8(v34);
        v36.i16[0] = vaddlv_u8(v36);
        unsigned __int8 v37 = v36.i8[0];
        if (v36.i32[0] != 1)
        {
          uint64_t v38 = 0;
          int v39 = (unsigned int *)&v211 + 2 * v20;
          uint64_t v41 = *v39;
          uint64_t v40 = v39[1];
          __int16 v194 = v32 - *((_WORD *)a5 + v41);
          __int16 v195 = v32 + 4 - *((_WORD *)a5 + v40);
          *((_WORD *)a5 + v40) = v32 + 4;
          *((_WORD *)a5 + v41) = v32;
          int v42 = 1;
          LODWORD(v43) = v31;
          do
          {
            char v44 = v42;
            uint64_t v45 = (unsigned __int16)*(&v194 + v38);
            int8x8_t v46 = (int8x8_t)vpaddl_u32(vpaddl_u16(vpaddl_u8((uint8x8_t)vbic_s8((int8x8_t)0x8040201008040201, vceq_s8(*(int8x8_t *)((char *)v33 - v45), *(int8x8_t *)v28.i8)))));
            unsigned int v47 = v46.u8[0] | ((v45 - 8) >> 24);
            if (!(v46.i8[0] | ((v45 - 8) >> 24)))
            {
              v19 |= 0x10000 << v20;
              *(_DWORD *)uint64_t v14 = v19;
              *((_WORD *)&v209 + v21) = v45;
              uint64_t v31 = v45;
              ++v21;
              goto LABEL_35;
            }
            v46.i32[0] = v46.i8[0] | ((v45 - 8) >> 24);
            uint8x8_t v48 = (uint8x8_t)vcnt_s8(v46);
            v48.i16[0] = vaddlv_u8(v48);
            unsigned __int8 v49 = v48.i8[0] + 2;
            if (((v48.i32[0] + 2 < v37) & ~v42) != 0)
            {
              uint64_t v43 = v45;
              unsigned __int8 v35 = v47;
              goto LABEL_33;
            }
            int v42 = 0;
            if (v37 > v49) {
              uint64_t v43 = v45;
            }
            else {
              uint64_t v43 = v43;
            }
            if (v37 > v49) {
              unsigned __int8 v35 = v47;
            }
            if (v37 >= v49) {
              unsigned __int8 v37 = v48.i8[0] + 2;
            }
            uint64_t v38 = 1;
          }
          while ((v44 & 1) != 0);
          if ((unsigned __int16)v43 == (unsigned __int16)v31) {
            goto LABEL_34;
          }
LABEL_33:
          *(_DWORD *)uint64_t v14 = (0x10000 << v20) | v19;
          *((_WORD *)&v209 + v21) = v43;
          uint64_t v31 = v43;
          ++v21;
        }
LABEL_34:
        int8x8_t v50 = vqtbl1_s8(v28, lzbitmap_pack_perm_table[v35]);
        *(int8x8_t *)((char *)&v197 + v23) = v50;
        v50.i32[0] = v35;
        v23 += vaddlv_u8((uint8x8_t)vcnt_s8(v50));
        int v19 = *(_DWORD *)v14 | (1 << v20);
        *(_DWORD *)uint64_t v14 = v19;
        v14[v22++ + 4] = v35;
      }
LABEL_35:
      ++v20;
      unsigned int v18 = v32 + 8;
    }
    while (v20 != 16);
    uint64_t v51 = v22 + 4;
    unint64_t v52 = 2 * v21 + (unint64_t)v23;
    if ((v52 + v51) <= 0x85)
    {
      uint64_t v60 = &v14[v51];
      long long v61 = v210;
      *(_OWORD *)uint64_t v60 = v209;
      *((_OWORD *)v60 + 1) = v61;
      if (v60 < v60 + 32)
      {
        unint64_t v62 = &v209;
        uint64_t v63 = v60;
        do
        {
          long long v64 = *v62;
          long long v65 = v62[1];
          v62 += 2;
          *(_OWORD *)uint64_t v63 = v64;
          *((_OWORD *)v63 + 1) = v65;
          v63 += 32;
        }
        while (v63 < v60 + 32);
      }
      uint64_t v14 = &v60[v52];
      long long v66 = v198;
      uint64_t v67 = &v60[v52 - v23];
      *(_OWORD *)uint64_t v67 = v197;
      *((_OWORD *)v67 + 1) = v66;
      if (v67 >= v14)
      {
        uint64_t v16 = v31;
        unsigned int v15 = a4;
      }
      else
      {
        uint64_t v68 = &v197;
        unsigned int v15 = a4;
        do
        {
          long long v69 = *v68;
          long long v70 = v68[1];
          v68 += 2;
          *(_OWORD *)uint64_t v67 = v69;
          *((_OWORD *)v67 + 1) = v70;
          v67 += 32;
        }
        while (v67 < v14);
        uint64_t v16 = v31;
      }
    }
    else
    {
      unsigned int v53 = &__src[v18 - 128];
      *(_DWORD *)uint64_t v14 = 8454143;
      v14[4] = 0;
      long long v54 = *(_OWORD *)v53;
      long long v55 = *((_OWORD *)v53 + 1);
      long long v56 = *((_OWORD *)v53 + 2);
      *(_OWORD *)(v14 + 53) = *((_OWORD *)v53 + 3);
      *(_OWORD *)(v14 + 37) = v56;
      *(_OWORD *)(v14 + 21) = v55;
      *(_OWORD *)(v14 + 5) = v54;
      long long v57 = *((_OWORD *)v53 + 4);
      long long v58 = *((_OWORD *)v53 + 5);
      long long v59 = *((_OWORD *)v53 + 6);
      *(_OWORD *)(v14 + 117) = *((_OWORD *)v53 + 7);
      *(_OWORD *)(v14 + 101) = v59;
      *(_OWORD *)(v14 + 85) = v58;
      *(_OWORD *)(v14 + 69) = v57;
      v14 += 133;
      unsigned int v15 = a4;
      uint64_t v16 = v30;
    }
    if (v32 + 152 > v15) {
      goto LABEL_118;
    }
  }
LABEL_117:
  uint64_t v14 = 0;
  unsigned int v18 = v190;
LABEL_118:
  if (!v14) {
    return 0;
  }
  do
  {
    uint64_t v187 = v15 - v18;
    if (v15 < v18) {
      break;
    }
    if ((unint64_t)&v14[v187 + 5] > v193) {
      return 0;
    }
    *(_WORD *)uint64_t v14 = -1;
    *((_WORD *)v14 + 1) = v15 - v18;
    v14[4] = 0;
    memcpy(v14 + 5, &__src[v18], v15 - v18);
    unsigned int v15 = a4;
    v14 += v187 + 5;
    BOOL v188 = a4 == v18;
    unsigned int v18 = a4;
  }
  while (!v188);
  return (v14 - v189);
}

uint64_t compression_stream_init_with_state_buffer(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if ((unint64_t)(a5 - 0x100000000) < 0xFFFFFFFF00000010) {
    return 0xFFFFFFFFLL;
  }
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 32) = a4;
  *(void *)a4 = 0;
  *(_DWORD *)(a4 + 8) = -1412628475;
  *(_DWORD *)(a4 + 12) = a5;
  return compression_stream_reinit(a1, a2, a3);
}

uint64_t compression_stream_reinit(uint64_t a1, int a2, int a3)
{
  if (a3 > 2192)
  {
    if ((a3 - 2304) < 2) {
      return lzvn_stream_init(a1, a2, a3, 1);
    }
    if (a3 != 2193) {
      return 0xFFFFFFFFLL;
    }
    return lzfse_stream_init(a1, a2, a3, 1);
  }
  if ((a3 - 2049) < 2) {
    return lzfse_stream_init(a1, a2, a3, 1);
  }
  if (a3 == 256) {
    return lz4_stream_init(a1, a2, 1);
  }
  if (a3 == 517) {
    return zlib_stream_init(a1, a2, 1);
  }
  return 0xFFFFFFFFLL;
}

uint64_t compression_stream_identify_algorithm(int *a1)
{
  if (lzfse_stream_identify_algorithm(a1)) {
    return 2049;
  }
  if (zlib_stream_identify_algorithm()) {
    return 517;
  }
  if (lzma_stream_identify_algorithm(a1)) {
    return 774;
  }
  if (lz4_stream_identify_algorithm(a1)) {
    return 256;
  }
  if (lzvn_stream_identify_algorithm(a1)) {
    return 2304;
  }
  if (lzbitmap_stream_identify_algorithm(a1)) {
    return 1794;
  }
  return 0xFFFFFFFFLL;
}

uint64_t compression_stream_get_state_size(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  int v3 = *(_DWORD *)(v1 + 4);
  if (v3 > 2048)
  {
    if ((v3 - 2049) >= 2 && v3 != 2193) {
      return result;
    }
    return *(unsigned int *)(v1 + 12);
  }
  if (v3 == 256 || v3 == 517) {
    return *(unsigned int *)(v1 + 12);
  }
  return result;
}

uint64_t compression_stream_get_encode_state_size(int a1)
{
  if (a1 > 2192)
  {
    if ((a1 - 2304) < 2) {
      return lzvn_stream_get_encode_state_size();
    }
    if (a1 != 2193) {
      return 0;
    }
    return lzfse_stream_get_encode_state_size();
  }
  if ((a1 - 2049) < 2) {
    return lzfse_stream_get_encode_state_size();
  }
  if (a1 == 256) {
    return lz4_stream_get_state_size();
  }
  if (a1 == 517) {
    return lzvn_decode_scratch_size();
  }
  return 0;
}

uint64_t compression_stream_get_decode_state_size(int a1)
{
  if (a1 > 2192)
  {
    if ((a1 - 2304) < 2) {
      return lzvn_stream_get_decode_state_size();
    }
    if (a1 != 2193) {
      return 0;
    }
    return lzfse_stream_get_decode_state_size();
  }
  if ((a1 - 2049) < 2) {
    return lzfse_stream_get_decode_state_size();
  }
  if (a1 == 256) {
    return lz4_stream_get_state_size();
  }
  if (a1 == 517) {
    return zlib_stream_get_decode_state_size();
  }
  return 0;
}

_DWORD *compression_stream_is_state_valid(_DWORD *result)
{
  if (result)
  {
    if (*result > 1u) {
      return 0;
    }
    else {
      return (_DWORD *)(result[2] == -1412628475);
    }
  }
  return result;
}

uint64_t lzfse_stream_identify_algorithm(int *a1)
{
  int v1 = *a1;
  uint64_t result = 1;
  if (v1 <= 829978209)
  {
    BOOL v3 = v1 == 611874402;
    int v4 = 762869346;
  }
  else
  {
    BOOL v3 = v1 == 829978210 || v1 == 846755426;
    int v4 = 1853388386;
  }
  if (!v3 && v1 != v4) {
    return 0;
  }
  return result;
}

uint64_t lzfse_stream_get_state_size(uint64_t a1)
{
  int v1 = *(_DWORD **)(a1 + 32);
  if (*v1 == 1) {
    return lzfseStreamDecodeStateSize();
  }
  if (*v1) {
    return 0;
  }
  return lzfseStreamEncodeStateSize(v1[1]);
}

void BrotliEstimateBitCostsForLiterals()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v54 = v1;
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  unint64_t v7 = v6;
  uint64_t v8 = v0;
  uint64_t v59 = *MEMORY[0x263EF8340];
  if (BrotliIsMostlyUTF8(v2, v0, v4, v6, 0.75))
  {
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    if (v7)
    {
      unint64_t v9 = 0;
      uint64_t v10 = v8;
      unint64_t v11 = v7;
      do
      {
        if (*(char *)(v3 + (v10 & v5)) < 0)
        {
          uint64_t v13 = 2 * (v9 > 0xDF);
          if (*(unsigned __int8 *)(v3 + (v10 & v5)) <= 0xBFu) {
            uint64_t v12 = v13;
          }
          else {
            uint64_t v12 = 1;
          }
        }
        else
        {
          uint64_t v12 = 0;
        }
        unint64_t v9 = *(unsigned __int8 *)(v3 + (v10 & v5));
        ++*(&v56 + v12);
        ++v10;
        --v11;
      }
      while (v11);
      BOOL v14 = (unint64_t)(v57 + v58) > 0x18;
    }
    else
    {
      BOOL v14 = 0;
    }
    bzero(&v56, 0x1800uLL);
    uint64_t v27 = 495;
    if (v7 < 0x1EF) {
      uint64_t v27 = v7;
    }
    memset(v55, 0, sizeof(v55));
    if (v27)
    {
      unint64_t v28 = 0;
      BOOL v29 = 0;
      uint64_t v30 = v8;
      do
      {
        int v31 = *(char *)(v3 + (v30 & v5));
        unint64_t v32 = *(unsigned __int8 *)(v3 + (v30 & v5));
        ++*(&v56 + 256 * v29 + v32);
        ++v55[v29];
        BOOL v29 = v28 >= 0xE0 && v14;
        if (v31 > 0xBFu) {
          BOOL v29 = v14;
        }
        if (v31 >= 0) {
          BOOL v29 = 0;
        }
        ++v30;
        unint64_t v28 = v32;
        --v27;
      }
      while (v27);
    }
    if (v7)
    {
      unint64_t v33 = 0;
      unint64_t v34 = 2000;
      do
      {
        if (v33 >= 0x1EF)
        {
          if (v33 != 495
            && ((unint64_t v35 = v8 + v33, v33 >= 0x1F1) ? (v36 = *(unsigned __int8 *)(v3 + ((v35 - 497) & v5))) : (v36 = 0),
                unsigned int v37 = *(unsigned __int8 *)(v3 + ((v35 - 496) & v5)),
                (v37 & 0x80) != 0))
          {
            BOOL v38 = v14;
            if (v37 <= 0xBF) {
              BOOL v38 = v36 >= 0xE0 && v14;
            }
          }
          else
          {
            BOOL v38 = 0;
          }
          uint64_t v39 = *(unsigned __int8 *)(v3 + ((v8 + v33 - 495) & v5));
          --*(&v56 + 256 * v38 + v39);
          --v55[v38];
        }
        if (v33 + 495 < v7)
        {
          BOOL v40 = *(unsigned __int8 *)(v3 + ((v8 + v33 + 493) & v5)) >= 0xE0u && v14;
          if (*(unsigned __int8 *)(v3 + ((v8 + v33 + 494) & v5)) > 0xBFu) {
            BOOL v40 = v14;
          }
          if (*(char *)(v3 + ((v8 + v33 + 494) & v5)) >= 0) {
            BOOL v40 = 0;
          }
          uint64_t v41 = *(unsigned __int8 *)(v3 + ((v8 + v33 + 495) & v5));
          ++*(&v56 + 256 * v40 + v41);
          ++v55[v40];
        }
        if (v33)
        {
          unint64_t v42 = v8 + v33;
          if (v33 == 1) {
            unint64_t v43 = 0;
          }
          else {
            unint64_t v43 = *(unsigned __int8 *)(v3 + ((v42 - 2) & v5));
          }
          unsigned int v45 = *(unsigned __int8 *)(v3 + ((v42 - 1) & v5));
          BOOL v46 = v43 >= 0xE0 && v14;
          if (v45 > 0xBF) {
            BOOL v46 = v14;
          }
          BOOL v44 = (v45 & 0x80) != 0 && v46;
        }
        else
        {
          BOOL v44 = 0;
        }
        unsigned int v47 = &v56 + 256 * v44;
        if ((unint64_t)v47[*(unsigned __int8 *)(v3 + ((v8 + v33) & v5))] <= 1) {
          unint64_t v48 = 1;
        }
        else {
          unint64_t v48 = v47[*(unsigned __int8 *)(v3 + ((v8 + v33) & v5))];
        }
        unint64_t v49 = v55[v44];
        if (v49 > 0xFF) {
          double v50 = log2((double)v49);
        }
        else {
          double v50 = kBrotliLog2Table[v49];
        }
        if (v48 > 0xFF) {
          double v51 = log2((double)v48);
        }
        else {
          double v51 = kBrotliLog2Table[v48];
        }
        double v52 = v50 - v51 + 0.02905;
        if (v52 < 1.0) {
          double v52 = v52 * 0.5 + 0.5;
        }
        if (v33 <= 0x7CF) {
          double v52 = (double)v34 / -2000.0 * 0.35 + 0.7 + v52;
        }
        float v53 = v52;
        *(float *)(v54 + 4 * v33++) = v53;
        --v34;
      }
      while (v7 != v33);
    }
  }
  else
  {
    bzero(&v56, 0x800uLL);
    if (v7 >= 0x7D0) {
      unint64_t v15 = 2000;
    }
    else {
      unint64_t v15 = v7;
    }
    if (v15)
    {
      uint64_t v16 = v8;
      unint64_t v17 = v15;
      do
      {
        ++*(&v56 + *(unsigned __int8 *)(v3 + (v16++ & v5)));
        --v17;
      }
      while (v17);
    }
    if (v7)
    {
      unint64_t v18 = 0;
      do
      {
        if (v18 >= 0x7D0)
        {
          uint64_t v19 = *(unsigned __int8 *)(v3 + ((v8 + v18 - 2000) & v5));
          --*(&v56 + v19);
          --v15;
        }
        unint64_t v20 = v18 + 2000;
        if (v18 + 2000 < v7)
        {
          uint64_t v21 = *(unsigned __int8 *)(v3 + ((v8 + v18 + 2000) & v5));
          ++*(&v56 + v21);
          ++v15;
        }
        if ((unint64_t)*(&v56 + *(unsigned __int8 *)(v3 + ((v8 + v18) & v5))) <= 1) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = *(&v56 + *(unsigned __int8 *)(v3 + ((v8 + v18) & v5)));
        }
        if (v15 > 0xFF) {
          double v23 = log2((double)v15);
        }
        else {
          double v23 = kBrotliLog2Table[v15];
        }
        if (v22 > 0xFF) {
          double v24 = log2((double)v22);
        }
        else {
          double v24 = kBrotliLog2Table[v22];
        }
        double v25 = v23 - v24 + 0.029;
        if (v25 < 1.0) {
          double v25 = v25 * 0.5 + 0.5;
        }
        float v26 = v25;
        *(float *)(v54 + 4 * v18++) = v26;
      }
      while (v20 - 1999 != v7);
    }
  }
}

uint64_t lz24_encode_scratch_buffer_size()
{
  return 279532;
}

unint64_t lz24_encode_buffer(char *a1, unint64_t a2, char *a3, unint64_t a4, char *__b, int a6)
{
  unint64_t result = 0;
  if (!HIDWORD(a4) && (a6 - 32) >= 0xFFFFFFE1)
  {
    if ((a2 & 0x8000000000000000) != 0 || a2 < 4)
    {
      return 0;
    }
    else
    {
      *(_DWORD *)a1 = a4;
      unint64_t v9 = a1 + 4;
      int8x16_t v87 = a1;
      if (a4)
      {
        uint64_t v10 = __b;
        uint64_t v12 = __b + 279520;
        uint64_t v13 = __b + 213488;
        unsigned int v89 = &a1[a2];
        BOOL v14 = __b + 0x20000;
        int v90 = a6 - 1;
        unint64_t __dst = __b + 147456;
        int v88 = a4 + a3;
        int v91 = a4;
        unsigned int v15 = a4;
        uint64_t v16 = a3;
        int8x16_t v98 = __b + 279520;
        int8x16_t v97 = __b + 0x10000;
        while (1)
        {
          unsigned int v94 = v15;
          if (v15 >= 0x1000) {
            size_t v17 = 4096;
          }
          else {
            size_t v17 = v15;
          }
          unsigned int v18 = *((_DWORD *)v12 + 1);
          if (v18 > 0x7F || (*((_DWORD *)v12 + 2) ^ v18) != 0xE11CCA)
          {
            unsigned int v18 = 0;
            *((_DWORD *)v12 + 1) = 0;
          }
          unsigned int v95 = v18;
          int8x16_t __src = v16;
          unint64_t v19 = v16 - a3;
          if (((v16 - a3) & 0x7FFFFFFF) == 0) {
            unint64_t result = (unint64_t)memset(v10, (v19 >> 24) - 2, 0x10000uLL);
          }
          uint64_t v20 = (v17 + v19);
          if (v20 > v19)
          {
            unint64_t v21 = (v16 - a3);
            unsigned int v22 = v88 - v16;
            do
            {
              double v23 = &v14[4 * (v21 & 0xFFF)];
              *(_WORD *)double v23 = 0;
              unint64_t v24 = (v91 - v21);
              if (v24 >= 4)
              {
                unsigned int v25 = *((_DWORD *)v10 + ((-1640531535 * *(_DWORD *)&a3[v21]) >> 18));
                __int16 v26 = v21 - v25;
                unsigned int v27 = (v21 - v25) >> 14;
                if (v27)
                {
                  unsigned int v27 = 0;
                }
                else
                {
                  int v28 = 64;
                  while (v28)
                  {
                    unint64_t result = 0;
                    --v28;
                    char v29 = 1;
                    while (1)
                    {
                      char v30 = v29;
                      if (result + 16 > v24) {
                        break;
                      }
                      int8x16_t v31 = veorq_s8(*(int8x16_t *)&a3[v25 + result], *(int8x16_t *)&a3[v21 + result]);
                      if (*(_OWORD *)&v31 != 0)
                      {
                        unsigned int v33 = (__clz(__rbit64(v31.u64[1])) >> 3) + 8;
                        unsigned int v34 = __clz(__rbit64(v31.u64[0])) >> 3;
                        if (v31.i64[0]) {
                          unsigned int v33 = v34;
                        }
                        unint64_t result = v33 + result;
                        if (result >= 0x1F) {
                          LODWORD(v32) = 31;
                        }
                        else {
                          LODWORD(v32) = result;
                        }
                        goto LABEL_40;
                      }
                      char v29 = 0;
                      unint64_t result = 16;
                      if ((v30 & 1) == 0)
                      {
LABEL_33:
                        LODWORD(v32) = 31;
                        goto LABEL_40;
                      }
                    }
                    if (result <= v22) {
                      unint64_t v32 = v22;
                    }
                    else {
                      unint64_t v32 = result;
                    }
                    while (v32 != result)
                    {
                      if (a3[(v21 + result)] != a3[v25 + result])
                      {
                        LODWORD(v32) = result;
                        break;
                      }
                      if (++result == 31) {
                        goto LABEL_33;
                      }
                    }
LABEL_40:
                    if (v32 > v27)
                    {
                      *(_WORD *)double v23 = v32;
                      *((_WORD *)v23 + 1) = v26;
                      if (v32 == 31)
                      {
                        unsigned int v27 = 31;
                        break;
                      }
                      unsigned int v27 = (unsigned __int16)v32;
                    }
                    unsigned int v25 = *(_DWORD *)&v97[4 * (v25 & 0x3FFF)];
                    __int16 v26 = v21 - v25;
                    if (v21 - v25 >= 0x4000) {
                      break;
                    }
                  }
                }
                if ((int)v20 - (int)v21 < v27) {
                  *(_WORD *)double v23 = v17 + v19 - v21;
                }
                if (v21 >= 0x1F)
                {
                  unsigned int v35 = (-1640531535 * *(_DWORD *)&a3[(v21 - 31)]) >> 18;
                  *(_DWORD *)&v97[4 * ((v21 - 31) & 0x3FFF)] = *((_DWORD *)v10 + v35);
                  *((_DWORD *)v10 + v35) = v21 - 31;
                }
              }
              ++v21;
              --v22;
            }
            while (v21 != v20);
          }
          unsigned int v36 = 0;
          uint64_t v37 = 128;
          uint64_t v38 = v95;
LABEL_54:
          uint64_t v39 = v38;
          while (v36 < v37)
          {
            unint64_t result = (unint64_t)memset(v13, 255, (16 * v17 + 496));
            unsigned int v40 = 0;
            uint64_t v41 = 0;
            *(void *)uint64_t v13 = 0x8000000000000000;
            v13[4] = 7936;
            while (1)
            {
              unint64_t v42 = &v13[8 * v41];
              unsigned int v43 = *((_DWORD *)v42 + 1);
              if (v40 > v43)
              {
                *(_DWORD *)unint64_t v42 = v43;
                *((unsigned char *)v42 + 8) = *((unsigned char *)v42 + 9);
                *((unsigned char *)v42 + 10) = 0;
                v42[6] = 0;
                unsigned int v40 = v43;
              }
              if (v41 == v17) {
                break;
              }
              BOOL v44 = &v13[8 * v41];
              int v47 = *((unsigned __int8 *)v44 + 9);
              unsigned int v45 = (char *)v44 + 9;
              char v46 = v47;
              if (v47 != 31)
              {
                unsigned int v48 = v43 + 4;
                if (*((_DWORD *)v42 + 5) > v48)
                {
                  *((_DWORD *)v42 + 5) = v48;
                  *((unsigned char *)v42 + 25) = v46 + 1;
                }
              }
              unsigned int v49 = v39 + 136 + v40;
              unsigned int v50 = 31;
              do
              {
                double v51 = &v42[8 * v50];
                unsigned int v53 = *((_DWORD *)v51 + 1);
                double v52 = (unsigned int *)(v51 + 2);
                unint64_t result = v53;
                if (v53 <= v49) {
                  break;
                }
                *double v52 = v49;
                HIBYTE(v42[8 * v50 + 4]) = v50;
                v49 -= 4;
                --v50;
              }
              while (v50);
              unsigned int v54 = *((_DWORD *)v42 + 1) + v39;
              uint64_t v55 = *(unsigned __int16 *)&v14[4 * v41];
              uint64_t v56 = &v42[8 * v55];
              unsigned int v57 = *(_DWORD *)v56;
              if (*(_DWORD *)v56 > v54)
              {
                *(_DWORD *)uint64_t v56 = v54;
                *((unsigned char *)v56 + 8) = *v45;
                *((unsigned char *)v56 + 10) = v55;
                v56[6] = *(_WORD *)&v14[4 * v41 + 2];
                unsigned int v40 = *(_DWORD *)v42;
                unsigned int v57 = v54;
              }
              unsigned int v58 = v39 + 12 + v40;
              if (v57 > v58)
              {
                *(_DWORD *)uint64_t v56 = v58;
                uint64_t v59 = &v42[8 * v55];
                *((unsigned char *)v59 + 8) = 0;
                *((unsigned char *)v59 + 10) = v55;
                v59[6] = *(_WORD *)&v14[4 * v41 + 2];
              }
              ++v41;
              unsigned int v40 = *(_DWORD *)&v13[8 * v41];
            }
            unsigned int v60 = 0;
            unsigned int v61 = 0;
            unsigned int v62 = v17;
            do
            {
              if (v62 > 0x1000) {
                goto LABEL_93;
              }
              uint64_t v63 = &v13[8 * v62];
              int v64 = *((unsigned __int8 *)v63 + 8);
              v61 += v64 + 3;
              v60 += a6;
              v62 -= v64 + *((unsigned __int8 *)v63 + 10);
            }
            while (v62);
            if (v60 <= v90 + (int)v17)
            {
              unint64_t result = (unint64_t)memcpy(__dst, v13, (16 * v17 + 16));
              *(_DWORD *)int8x16_t v98 = v61;
              goto LABEL_79;
            }
            unsigned int v36 = v39 + 1;
            if (v39 == *((_DWORD *)v98 + 1))
            {
              uint64_t v39 = (2 * v39) | 1u;
              if (v36 + v37 > 2 * (int)v39) {
                continue;
              }
            }
            uint64_t v39 = v37;
LABEL_79:
            uint64_t v38 = (v39 + v36) >> 1;
            uint64_t v37 = v39;
            goto LABEL_54;
          }
          *((_DWORD *)v98 + 1) = v36;
          *((_DWORD *)v98 + 2) = v36 ^ 0xE11CCA;
          if (v36 == 128) {
            break;
          }
          uint64_t v65 = *(unsigned int *)v98;
          uint64_t v66 = v89 - v9;
          uint64_t v10 = __b;
          if (v65 >= (int)v17 + 2)
          {
            if (v66 < (v17 + 2)) {
              return 0;
            }
            *(_WORD *)unint64_t v9 = 0;
            int8x16_t v86 = v9 + 2;
            __int16 v85 = __src;
            unint64_t result = (unint64_t)memcpy(v86, __src, v17);
            uint64_t v12 = v98;
            unint64_t v9 = &v86[v17];
          }
          else
          {
            if (v66 < v65 + 1) {
              return 0;
            }
            uint64_t v67 = &__dst[16 * v17];
            uint64_t v68 = *(void *)v67;
            int v69 = v67[8];
            char v70 = v67[9];
            int v71 = v67[10];
            int v99 = *(_DWORD *)(v67 + 11);
            char v100 = v67[15];
            int v72 = v17;
            do
            {
              v72 -= v71 + v69;
              unint64_t v73 = &__dst[16 * v72];
              uint64_t v74 = *(void *)v73;
              int v75 = v73[8];
              char v76 = v73[9];
              int v77 = v73[10];
              int v78 = *(_DWORD *)(v73 + 11);
              char v79 = v73[15];
              *(void *)unint64_t v73 = v68;
              v73[8] = v69;
              v73[9] = v70;
              v73[10] = v71;
              *(_DWORD *)(v73 + 11) = v99;
              v73[15] = v100;
              char v100 = v79;
              int v99 = v78;
              int v71 = v77;
              char v70 = v76;
              int v69 = v75;
              uint64_t v68 = v74;
            }
            while (v72);
            unsigned int v80 = 0;
            do
            {
              int v81 = &__dst[16 * v80];
              size_t v82 = v81[8];
              *(_DWORD *)unint64_t v9 = v82 + 32 * v81[10] + (*((unsigned __int16 *)v81 + 6) << 10);
              int v83 = v9 + 3;
              unint64_t result = (unint64_t)memcpy(v83, &__src[v80], v82);
              uint64_t v84 = v81[8];
              unint64_t v9 = &v83[v84];
              v80 += v84 + v81[10];
            }
            while (v80 < v17);
            uint64_t v12 = v98;
            __int16 v85 = __src;
            uint64_t v10 = __b;
          }
          uint64_t v16 = &v85[v17];
          unsigned int v15 = v94 - v17;
          if (v94 == v17) {
            return v9 - v87;
          }
        }
LABEL_93:
        __break(1u);
      }
      else
      {
        return v9 - v87;
      }
    }
  }
  return result;
}

uint64_t lz4raw_encode_buffer(int32x4_t *a1, uint64_t a2, char *a3, unint64_t a4, void *__b)
{
  unsigned int v15 = a1;
  uint64_t v16 = a3;
  unint64_t v6 = a1;
  if (!a4) {
    return (char *)v6 - (char *)a1;
  }
  unint64_t v8 = a4;
  uint64_t v9 = (uint64_t)a3;
  unint64_t v11 = a1;
  while (1)
  {
    memset_pattern8(__b, &unk_20DAB5A78, 0x8000uLL);
    unint64_t v12 = v8 >= 0x7FFFF000 ? 2147479552 : v8;
    lz4_encode_2gb(&v15, a2, &v16, v9, v12, (uint64_t)__b, v8 > 0x7FFFF000);
    unint64_t v6 = v15;
    unint64_t v13 = (unint64_t)&v16[-v9];
    if (v8 <= 0x7FFFF000 && v12 > v13) {
      break;
    }
    if (v8 >= 0x7FFFF001 && (v12 - v13) >> 16) {
      break;
    }
    a2 = &v11->i8[a2] - (__int8 *)v15;
    uint64_t v9 = (uint64_t)v16;
    unint64_t v11 = v15;
    v8 -= v13;
    if (!v8) {
      return (char *)v6 - (char *)a1;
    }
  }
  return 0;
}

char *lz4raw_decode_buffer(char *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  uint64_t v9 = a1;
  uint64_t v10 = a3;
  if (a2 >= 0x81
    && a4 >= 0x81
    && lz4_decode_asm((int8x16_t **)&v9, (unint64_t)a1, (unint64_t)&a1[a2 - 128], &v10, (unint64_t)&a3[a4 - 128])|| lz4_decode((void **)&v9, (unint64_t)a1, (unint64_t)&a1[a2], &v10, (unint64_t)&a3[a4]))
  {
    return 0;
  }
  else
  {
    return (char *)(v9 - a1);
  }
}

uint64_t BrotliSetDepth(int a1, uint64_t a2, uint64_t a3, int a4)
{
  LODWORD(v4) = 0;
  uint64_t v9 = *MEMORY[0x263EF8340];
  v8[0] = -1;
  while (1)
  {
    while (1)
    {
      uint64_t v5 = a1;
      if ((*(__int16 *)(a2 + 8 * a1 + 4) & 0x80000000) == 0) {
        break;
      }
      *(unsigned char *)(a3 + *(__int16 *)(a2 + 8 * a1 + 6)) = v4;
      if ((v4 & 0x80000000) != 0) {
        return 1;
      }
      while (1)
      {
        a1 = v8[v4];
        if (a1 != -1) {
          break;
        }
        BOOL v6 = (int)v4 <= 0;
        LODWORD(v4) = v4 - 1;
        if (v6) {
          return 1;
        }
      }
      v8[v4] = -1;
    }
    if ((int)v4 >= a4) {
      break;
    }
    a1 = *(unsigned __int16 *)(a2 + 8 * a1 + 4);
    uint64_t v4 = (int)v4 + 1;
    v8[v4] = *(__int16 *)(a2 + 8 * v5 + 6);
  }
  return 0;
}

uint64_t BrotliCreateHuffmanTree(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = result;
  uint64_t v45 = a2 - 1;
  uint64_t v10 = a4 + 8;
  for (unsigned int i = 1; ; i *= 2)
  {
    unint64_t v12 = 0;
    if (a2) {
      break;
    }
    uint64_t v22 = -1;
    *(void *)a4 = -1;
    *(void *)(a4 + 8) = -1;
    uint64_t v23 = 1;
LABEL_37:
    uint64_t v34 = 0;
    unsigned int v35 = (void *)(v10 - 8 * v22 + 16 * v12);
    do
    {
      unsigned int v36 = *(_DWORD *)(a4 + 8 * v34);
      unsigned int v37 = *(_DWORD *)(a4 + 8 * v23);
      BOOL v38 = v36 > v37;
      if (v36 > v37) {
        uint64_t v39 = v34;
      }
      else {
        uint64_t v39 = v34 + 1;
      }
      if (v38) {
        uint64_t v40 = v23 + 1;
      }
      else {
        uint64_t v40 = v23;
      }
      unsigned int v41 = *(_DWORD *)(a4 + 8 * v39);
      unsigned int v42 = *(_DWORD *)(a4 + 8 * v40);
      if (!v38) {
        uint64_t v23 = v34;
      }
      BOOL v43 = v41 > v42;
      if (v41 > v42) {
        uint64_t v44 = v40;
      }
      else {
        uint64_t v44 = v39;
      }
      *((_DWORD *)v35 - 2) = *(_DWORD *)(a4 + 8 * v44) + *(_DWORD *)(a4 + 8 * v23);
      *((_WORD *)v35 - 2) = v23;
      if (v43) {
        uint64_t v34 = v39;
      }
      else {
        uint64_t v34 = v39 + 1;
      }
      if (v43) {
        uint64_t v23 = v40 + 1;
      }
      else {
        uint64_t v23 = v40;
      }
      *((_WORD *)v35 - 1) = v44;
      *v35++ = -1;
      --v22;
    }
    while (v22);
    unint64_t result = BrotliSetDepth(2 * (int)v12 - 1, a4, a5, a3);
    if (result) {
      return result;
    }
  }
  uint64_t v13 = v45;
  do
  {
    unsigned int v14 = *(_DWORD *)(v9 + 4 * v13);
    if (v14)
    {
      if (v14 <= i) {
        unsigned int v14 = i;
      }
      unint64_t v15 = a4 + 8 * v12;
      *(_DWORD *)unint64_t v15 = v14;
      ++v12;
      *(_WORD *)(v15 + 4) = -1;
      *(_WORD *)(v15 + 6) = v13;
    }
    --v13;
  }
  while (v13 != -1);
  if (v12 != 1)
  {
    if (v12 <= 0xC)
    {
      if (v12 >= 2)
      {
        uint64_t v16 = 0;
        for (uint64_t j = 1; j != v12; ++j)
        {
          uint64_t v18 = *(void *)(a4 + 8 * j);
          uint64_t v19 = v16;
          uint64_t v20 = j;
          do
          {
            unsigned int v21 = *(_DWORD *)(a4 + v19);
            if (v21 == v18)
            {
              if (*(__int16 *)(a4 + v19 + 6) >= SHIWORD(v18)) {
                break;
              }
            }
            else if (v21 <= v18)
            {
              break;
            }
            *(void *)(a4 + 8 * v20) = *(void *)(a4 + v19);
            v19 -= 8;
            --v20;
          }
          while (v20);
          *(void *)(a4 + 8 * v20) = v18;
          v16 += 8;
        }
      }
LABEL_36:
      *(void *)&long long v33 = -1;
      *((void *)&v33 + 1) = -1;
      *(_OWORD *)(a4 + 8 * v12) = v33;
      uint64_t v22 = v12 - 1;
      uint64_t v23 = v12 + 1;
      goto LABEL_37;
    }
    uint64_t v24 = 2 * (v12 < 0x39);
LABEL_23:
    unint64_t v25 = kBrotliShellGaps[v24];
    if (v25 >= v12) {
      goto LABEL_35;
    }
    uint64_t v26 = 0;
    unint64_t v27 = kBrotliShellGaps[v24];
LABEL_25:
    uint64_t v28 = *(void *)(a4 + 8 * v27);
    unint64_t v29 = v27;
    if (v27 < v25) {
      goto LABEL_34;
    }
    uint64_t v30 = v26;
    unint64_t v31 = v27;
    while (1)
    {
      unsigned int v32 = *(_DWORD *)(a4 + v30);
      if (v32 == v28)
      {
        if (*(__int16 *)(a4 + v30 + 6) >= SHIWORD(v28)) {
          goto LABEL_33;
        }
      }
      else if (v32 <= v28)
      {
LABEL_33:
        unint64_t v29 = v31;
LABEL_34:
        *(void *)(a4 + 8 * v29) = v28;
        ++v27;
        v26 += 8;
        if (v27 == v12)
        {
LABEL_35:
          if (++v24 == 6) {
            goto LABEL_36;
          }
          goto LABEL_23;
        }
        goto LABEL_25;
      }
      unint64_t v29 = v31 - v25;
      *(void *)(a4 + 8 * v31) = *(void *)(a4 + v30);
      v30 -= 8 * v25;
      unint64_t v31 = v29;
      if (v29 < v25) {
        goto LABEL_34;
      }
    }
  }
  *(unsigned char *)(a5 + *(__int16 *)(a4 + 6)) = 1;
  return result;
}

void BrotliOptimizeHuffmanCountsForRle(uint64_t a1, int *a2, char *a3)
{
  if (a1)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      if (a2[v5]) {
        ++v6;
      }
      ++v5;
    }
    while (a1 != v5);
    if (v6 >= 0x10)
    {
      unint64_t v7 = a1 - 1;
      while (v7 != -1)
      {
        if (a2[v7--])
        {
          unint64_t v9 = 0;
          uint64_t v10 = 0;
          unint64_t v11 = v7 + 2;
          unsigned int v12 = 0x40000000;
          do
          {
            unint64_t v13 = v9;
            unsigned int v14 = a2[v10];
            if (v12 >= v14) {
              unsigned int v15 = a2[v10];
            }
            else {
              unsigned int v15 = v12;
            }
            if (v14)
            {
              ++v9;
              unsigned int v12 = v15;
            }
            ++v10;
          }
          while (v11 != v10);
          if (v9 >= 5)
          {
            if (v14) {
              unint64_t v16 = v13 + 1;
            }
            else {
              unint64_t v16 = v13;
            }
            unint64_t v17 = v7 - v16 + 2;
            BOOL v19 = v12 <= 3 && v17 <= 5 && v7 + 1 >= 2;
            if (v19)
            {
              uint64_t v20 = 0;
              do
              {
                if (a2[v20])
                {
                  unsigned int v21 = &a2[v20];
                  if (!v21[1])
                  {
                    if (v21[2]) {
                      v21[1] = 1;
                    }
                  }
                }
                ++v20;
              }
              while (v7 != v20);
            }
            if (v9 >= 0x1C)
            {
              bzero(a3, v7 + 2);
              size_t v22 = 0;
              unint64_t v23 = 0;
              int v24 = *a2;
              do
              {
                if (v11 == v23 || a2[v23] != v24)
                {
                  if (!v24 && v22 > 4 || v24 && v22 > 6) {
                    memset(&a3[v23 - v22], 1, v22);
                  }
                  if (v11 != v23) {
                    int v24 = a2[v23];
                  }
                  size_t v22 = 1;
                }
                else
                {
                  ++v22;
                }
                BOOL v19 = v23++ >= v11;
              }
              while (!v19);
              unint64_t v25 = 0;
              uint64_t v26 = 0;
              unint64_t v27 = 0;
              unint64_t v28 = ((a2[1] + *a2 + a2[2]) << 8) / 3u + 420;
              unint64_t v29 = a2 - 1;
              do
              {
                if (v11 == v25
                  || a3[v25]
                  || v25 && a3[v25 - 1]
                  || (uint64_t v35 = a2[v25], (v35 << 8) - v28 - 1240 <= 0xFFFFFFFFFFFFF64FLL))
                {
                  if (v27 > 3 || v27 == 3 && !v26)
                  {
                    unint64_t v30 = v26 + (v27 >> 1);
                    if (v27 > v30) {
                      int v31 = 1;
                    }
                    else {
                      int v31 = v30 / v27;
                    }
                    if (v26) {
                      int v32 = v31;
                    }
                    else {
                      int v32 = 0;
                    }
                    long long v33 = v29;
                    do
                    {
                      *v33-- = v32;
                      --v27;
                    }
                    while (v27);
                  }
                  if (v25 >= v7)
                  {
                    if (v25 >= v11) {
                      unsigned int v34 = 0;
                    }
                    else {
                      unsigned int v34 = a2[v25] << 8;
                    }
                  }
                  else
                  {
                    unsigned int v34 = ((a2[v25 + 1] + a2[v25] + a2[v25 + 2]) << 8) / 3u + 420;
                  }
                  unint64_t v28 = v34;
                  if (v11 == v25) {
                    uint64_t v26 = 0;
                  }
                  else {
                    uint64_t v26 = a2[v25];
                  }
                  unint64_t v27 = 1;
                }
                else
                {
                  ++v27;
                  v26 += v35;
                  if (v27 >= 4)
                  {
                    unint64_t v28 = ((v26 << 8) + (v27 >> 1)) / v27;
                    if (v27 == 4) {
                      v28 += 120;
                    }
                  }
                }
                ++v29;
                BOOL v19 = v25++ >= v11;
              }
              while (!v19);
            }
          }
          return;
        }
      }
    }
  }
}

uint64_t BrotliWriteHuffmanTree(uint64_t result, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (!a2) {
    return result;
  }
  unint64_t v5 = a2;
  while (!*(unsigned char *)(result - 1 + v5))
  {
    if (!--v5)
    {
      if (a2 > 0x32)
      {
        unint64_t v5 = 0;
        unint64_t v16 = 0;
        unint64_t v17 = 0;
        unint64_t v18 = 2;
        unint64_t v19 = 2;
        goto LABEL_26;
      }
      return result;
    }
  }
  if (a2 <= 0x32)
  {
    BOOL v20 = 0;
    BOOL v21 = 0;
LABEL_29:
    unint64_t v22 = 0;
    int v23 = 8;
    while (1)
    {
      int v24 = *(unsigned __int8 *)(result + v22);
      BOOL v25 = *(unsigned char *)(result + v22) || !v21;
      BOOL v26 = !v25;
      BOOL v27 = !v20 || v24 == 0;
      BOOL v28 = v27 && !v26;
      if (v28 || v22 + 1 >= v5) {
        break;
      }
      unint64_t v29 = 1;
      while (*(unsigned __int8 *)(result + v22 + v29) == v24)
      {
        if (v5 - v22 == ++v29)
        {
          unint64_t v29 = v5 - v22;
          break;
        }
      }
      if (*(unsigned char *)(result + v22)) {
        goto LABEL_52;
      }
      if (v29 == 11)
      {
        *(unsigned char *)(a4 + *a3) = 0;
        *(unsigned char *)(a5 + *a3) = 0;
        unint64_t v30 = *a3 + 1;
        *a3 = v30;
        unint64_t v29 = 11;
        unint64_t v31 = 7;
LABEL_78:
        *(unsigned char *)(a4 + v30) = 17;
        *(unsigned char *)(a5 + *a3) = v31 & 7;
        unint64_t v44 = *a3;
        uint64_t v45 = *a3 + 1;
        *a3 = v45;
        if (v31 >= 8)
        {
          do
          {
            unint64_t v31 = (v31 >> 3) - 1;
            *(unsigned char *)(a4 + v45) = 17;
            *(unsigned char *)(a5 + *a3) = v31 & 7;
            unint64_t v44 = *a3;
            uint64_t v45 = *a3 + 1;
            *a3 = v45;
          }
          while (v31 > 7);
        }
        if (v44 > v30)
        {
          unint64_t v46 = v30;
          do
          {
            char v47 = *(unsigned char *)(a4 + v46);
            *(unsigned char *)(a4 + v46) = *(unsigned char *)(a4 + v44);
            *(unsigned char *)(a4 + v44) = v47;
            ++v46;
            --v44;
          }
          while (v46 < v44);
          uint64_t v45 = *a3;
        }
        for (unint64_t i = v45 - 1; v30 < i; --i)
        {
          char v49 = *(unsigned char *)(a5 + v30);
          *(unsigned char *)(a5 + v30) = *(unsigned char *)(a5 + i);
          *(unsigned char *)(a5 + i) = v49;
          ++v30;
        }
        goto LABEL_75;
      }
      unint64_t v31 = v29 - 3;
      if (v29 >= 3)
      {
        unint64_t v30 = *a3;
        goto LABEL_78;
      }
      if (v29)
      {
LABEL_73:
        uint64_t v42 = *a3;
        unint64_t v43 = v29;
        do
        {
          *(unsigned char *)(a4 + v42) = 0;
          *(unsigned char *)(a5 + *a3) = 0;
          uint64_t v42 = *a3 + 1;
          *a3 = v42;
          --v43;
        }
        while (v43);
      }
LABEL_75:
      v22 += v29;
      if (v22 >= v5) {
        return result;
      }
    }
    unint64_t v29 = 1;
    if (!*(unsigned char *)(result + v22)) {
      goto LABEL_73;
    }
LABEL_52:
    unint64_t v32 = v29;
    if (v23 != v24)
    {
      *(unsigned char *)(a4 + *a3) = v24;
      *(unsigned char *)(a5 + (*a3)++) = 0;
      unint64_t v32 = v29 - 1;
    }
    if (v32 == 7)
    {
      *(unsigned char *)(a4 + *a3) = v24;
      *(unsigned char *)(a5 + *a3) = 0;
      unint64_t v33 = *a3 + 1;
      *a3 = v33;
      unint64_t v32 = 6;
    }
    else
    {
      if (v32 < 3)
      {
        if (v32)
        {
          uint64_t v34 = *a3;
          do
          {
            *(unsigned char *)(a4 + v34) = v24;
            *(unsigned char *)(a5 + *a3) = 0;
            uint64_t v34 = *a3 + 1;
            *a3 = v34;
            --v32;
          }
          while (v32);
        }
        goto LABEL_70;
      }
      unint64_t v33 = *a3;
    }
    unint64_t v35 = v32 - 3;
    *(unsigned char *)(a4 + v33) = 16;
    *(unsigned char *)(a5 + *a3) = (v32 - 3) & 3;
    unint64_t v36 = *a3;
    uint64_t v37 = *a3 + 1;
    *a3 = v37;
    if (v35 >= 4)
    {
      do
      {
        unint64_t v35 = (v35 >> 2) - 1;
        *(unsigned char *)(a4 + v37) = 16;
        *(unsigned char *)(a5 + *a3) = v35 & 3;
        unint64_t v36 = *a3;
        uint64_t v37 = *a3 + 1;
        *a3 = v37;
      }
      while (v35 > 3);
    }
    if (v36 > v33)
    {
      unint64_t v38 = v33;
      do
      {
        char v39 = *(unsigned char *)(a4 + v38);
        *(unsigned char *)(a4 + v38) = *(unsigned char *)(a4 + v36);
        *(unsigned char *)(a4 + v36) = v39;
        ++v38;
        --v36;
      }
      while (v38 < v36);
      uint64_t v37 = *a3;
    }
    for (unint64_t j = v37 - 1; v33 < j; --j)
    {
      char v41 = *(unsigned char *)(a5 + v33);
      *(unsigned char *)(a5 + v33) = *(unsigned char *)(a5 + j);
      *(unsigned char *)(a5 + j) = v41;
      ++v33;
    }
LABEL_70:
    int v23 = v24;
    goto LABEL_75;
  }
  unint64_t v6 = 0;
  unint64_t v17 = 0;
  unint64_t v16 = 0;
  uint64_t v7 = 1;
  uint64_t v8 = 1;
  do
  {
    int v9 = *(unsigned __int8 *)(result + v6);
    if (v6 + 1 >= v5)
    {
      ++v6;
      unint64_t v10 = 1;
    }
    else
    {
      unint64_t v10 = 1;
      while (*(unsigned __int8 *)(result + v6 + v10) == v9)
      {
        if (v5 - v6 == ++v10)
        {
          unint64_t v10 = v5 - v6;
          break;
        }
      }
      v6 += v10;
    }
    BOOL v11 = v9 == 0;
    char v12 = !v11;
    uint64_t v13 = (v10 > 2) & v11;
    if (v13) {
      unint64_t v14 = v10;
    }
    else {
      unint64_t v14 = 0;
    }
    v16 += v14;
    v8 += v13;
    uint64_t v15 = (v10 > 3) & v12;
    if (((v10 > 3) & v12) == 0) {
      unint64_t v10 = 0;
    }
    v17 += v10;
    v7 += v15;
  }
  while (v6 < v5);
  unint64_t v19 = 2 * v7;
  unint64_t v18 = 2 * v8;
LABEL_26:
  BOOL v20 = v17 > v19;
  BOOL v21 = v16 > v18;
  if (v5) {
    goto LABEL_29;
  }
  return result;
}

unsigned __int8 *BrotliConvertBitDepthsToSymbols(unsigned __int8 *result, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  memset(v14, 0, sizeof(v14));
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = a2;
    do
    {
      unsigned int v5 = *v3++;
      ++*((_WORD *)v14 + v5);
      --v4;
    }
    while (v4);
  }
  uint64_t v6 = 0;
  int v7 = 0;
  LOWORD(v14[0]) = 0;
  do
  {
    int v7 = 2 * (v7 + *(unsigned __int16 *)((char *)v14 + v6));
    *(_WORD *)&v13[v6 + 2] = v7;
    v6 += 2;
  }
  while (v6 != 30);
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      unint64_t v9 = result[i];
      if (result[i])
      {
        unsigned __int16 v10 = *(_WORD *)&v13[2 * v9];
        *(_WORD *)&v13[2 * v9] = v10 + 1;
        unint64_t v11 = BrotliReverseBits_kLut[v10 & 0xF];
        if (v9 >= 5)
        {
          for (unint64_t j = 4; j < v9; j += 4)
          {
            v10 >>= 4;
            unint64_t v11 = BrotliReverseBits_kLut[v10] | (16 * v11);
          }
        }
        *(_WORD *)(a3 + 2 * i) = v11 >> (-(char)v9 & 3);
      }
    }
  }
  return result;
}

uint64_t lzfse_decode_buffer_output_size(int *__src, uint64_t a2)
{
  uint64_t v2 = __src;
  uint64_t v3 = 0;
  uint64_t v4 = (char *)__src + a2;
  long long v5 = 0uLL;
  while (1)
  {
    uint64_t result = 0;
    if (v2 >= (int *)v4 || v2 + 1 > (int *)v4) {
      return result;
    }
    int v7 = *v2;
    if (*v2 > 846755425)
    {
      if (v7 != 846755426)
      {
        if (v7 != 1853388386) {
          return 0;
        }
        if (v2 + 3 > (int *)v4) {
          return 0;
        }
        uint64_t v8 = v2[2];
        if ((char *)v2 + v8 + 12 > v4) {
          return 0;
        }
        uint64_t v9 = v2[1];
        uint64_t v2 = (int *)((char *)v2 + v8 + 12);
        v3 += v9;
        goto LABEL_22;
      }
    }
    else
    {
      if (v7 == 762869346)
      {
        if (v2 + 2 > (int *)v4) {
          return 0;
        }
        uint64_t v13 = v2[1];
        if ((char *)v2 + v13 + 8 > v4) {
          return 0;
        }
        uint64_t v2 = (int *)((char *)v2 + v13 + 8);
        v3 += v13;
LABEL_22:
        int v11 = 2;
        goto LABEL_30;
      }
      if (v7 != 829978210)
      {
        uint64_t result = v3;
        if (v7 != 611874402) {
          return 0;
        }
        return result;
      }
    }
    v14[30] = v5;
    v14[31] = v5;
    v14[28] = v5;
    v14[29] = v5;
    v14[26] = v5;
    v14[27] = v5;
    v14[24] = v5;
    v14[25] = v5;
    v14[22] = v5;
    v14[23] = v5;
    v14[20] = v5;
    v14[21] = v5;
    v14[18] = v5;
    v14[19] = v5;
    v14[16] = v5;
    v14[17] = v5;
    v14[14] = v5;
    v14[15] = v5;
    v14[12] = v5;
    v14[13] = v5;
    v14[10] = v5;
    v14[11] = v5;
    v14[8] = v5;
    v14[9] = v5;
    v14[6] = v5;
    v14[7] = v5;
    v14[4] = v5;
    v14[5] = v5;
    _OWORD v14[2] = v5;
    v14[3] = v5;
    v14[0] = v5;
    v14[1] = v5;
    if (v7 == 846755426)
    {
      if (v2 + 8 <= (int *)v4)
      {
        uint64_t v10 = *((void *)v2 + 3);
        int v11 = 1;
        if ((v10 & 0xFFFFFFE0) == 0 || (char *)v2 + v10 > v4) {
          goto LABEL_30;
        }
        if (!lzfseDecodeV1(v14, (uint64_t)v2, (unint64_t)v4))
        {
          uint64_t v12 = v10;
          goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
    else if (v2 + 193 <= (int *)v4)
    {
      memcpy(v14, v2, 0x304uLL);
      uint64_t v12 = 772;
LABEL_26:
      if ((char *)v2 + v12 + DWORD2(v14[0]) <= v4)
      {
        uint64_t v2 = (int *)((char *)v2 + v12 + DWORD2(v14[0]));
        v3 += DWORD1(v14[0]);
        int v11 = 2;
      }
      else
      {
LABEL_27:
        int v11 = 1;
      }
      long long v5 = 0uLL;
      goto LABEL_30;
    }
    int v11 = 1;
LABEL_30:
    if (v11 != 2) {
      return 0;
    }
  }
}

uint64_t lzfseDecodeV1(_DWORD *a1, uint64_t a2, unint64_t a3)
{
  bzero(a1, 0x304uLL);
  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(void *)(a2 + 16);
  int v8 = *(_DWORD *)(a2 + 4);
  *a1 = 829978210;
  a1[1] = v8;
  unint64_t v9 = v7 >> 10;
  unsigned int v10 = v7 >> 20;
  unint64_t v11 = v7 >> 30;
  uint64_t v12 = (v7 >> 40) & 0xFFFFF;
  uint64_t v13 = (v7 >> 60) & 7;
  LOWORD(v14) = v7;
  unint64_t v15 = *(void *)(a2 + 24);
  WORD2(v14) = v10;
  uint64_t v16 = (v6 >> 20) & 0xFFFFF;
  LOWORD(v14) = v14 & 0x3FF;
  WORD1(v14) = v9 & 0x3FF;
  WORD2(v14) &= 0x3FFu;
  HIWORD(v14) = v11 & 0x3FF;
  *((void *)a1 + 4) = v14;
  a1[4] = (v6 >> 40) & 0xFFFFF;
  a1[5] = v16;
  a1[6] = v12;
  a1[7] = ((v6 >> 60) & 7) - 7;
  a1[10] = v13 - 7;
  *((_WORD *)a1 + 22) = WORD2(v15) & 0x3FF;
  *((_WORD *)a1 + 23) = (v15 >> 42) & 0x3FF;
  *((_WORD *)a1 + 24) = (v15 >> 52) & 0x3FF;
  a1[2] = v12 + v16;
  a1[3] = v6 & 0xFFFFF;
  if (v15 == 32) {
    return 0;
  }
  unint64_t v17 = (unsigned __int8 *)(a2 + 32);
  unint64_t v18 = a2 + v15;
  uint64_t result = 0xFFFFFFFFLL;
  if (v18 >= a2 + 32 && v18 <= a3)
  {
    uint64_t v20 = 0;
    int v21 = 0;
    unsigned int v22 = 0;
    do
    {
      if ((unint64_t)v17 >= v18 || v21 > 24)
      {
        int v23 = v21;
      }
      else
      {
        do
        {
          int v23 = v21 + 8;
          int v24 = *v17++;
          v22 |= v24 << v21;
          if ((unint64_t)v17 >= v18) {
            break;
          }
          BOOL v28 = v21 < 17;
          v21 += 8;
        }
        while (v28);
      }
      int v25 = lzfse_freq_nbits_table[v22 & 0x1F];
      if (v25 == 14)
      {
        int v26 = ((v22 >> 4) & 0x3FF) + 24;
      }
      else if (v25 == 8)
      {
        LOWORD(v26) = (v22 >> 4) + 8;
      }
      else
      {
        LOWORD(v26) = lzfse_freq_value_table[v22 & 0x1F];
      }
      int v27 = (char)v25;
      *((_WORD *)a1 + v20 + 25) = v26;
      int v21 = v23 - (char)v25;
      if (v23 < v27) {
        return 0xFFFFFFFFLL;
      }
      v22 >>= v27;
      ++v20;
    }
    while (v20 != 360);
    BOOL v28 = v17 == (unsigned __int8 *)v18 && v21 <= 7;
    int v29 = !v28;
    return (v29 << 31 >> 31);
  }
  return result;
}

uint64_t lzfse_decode_buffer_scratch_size_iboot()
{
  return 8088;
}

char *lzfse_decode_buffer_iboot(char *a1, uint64_t a2, char *a3, uint64_t a4, char **a5)
{
  bzero(a5 + 7, 0x1F60uLL);
  uint64_t result = 0;
  *a5 = a3;
  a5[1] = a3;
  unint64_t v11 = (unint64_t)&a3[a4];
  a5[3] = a1;
  uint32x4_t v185 = a5 + 3;
  a5[2] = &a3[a4];
  a5[5] = a1;
  a5[6] = 0;
  a5[4] = &a1[a2];
  if ((a1 & 3) != 0 || (((_BYTE)a1 + (_BYTE)a2) & 3) != 0 || a4 < 4) {
    return result;
  }
  uint64_t v12 = a3 + 4;
  uint64_t v13 = (_DWORD *)a5 + 15;
  uint64_t v14 = (uint64_t)a5 + 110;
  uint64_t v15 = (uint64_t)a5 + 150;
  uint64_t v16 = (uint64_t)a5 + 190;
  uint64_t v17 = (uint64_t)a5 + 318;
  int8x16_t v184 = a5 + 490;
  int8x16_t v183 = a5 + 1006;
  uint32x4_t v182 = a5 + 1002;
  while (1)
  {
    uint64_t result = 0;
    int v18 = *(_DWORD *)a3;
    *((_DWORD *)a5 + 14) = *(_DWORD *)a3;
    if (v18 <= 846755425) {
      break;
    }
    if (v18 == 846755426) {
      goto LABEL_13;
    }
    if (v18 != 1853388386) {
      return result;
    }
    if ((lzfse_decode_lzvn_block_iboot(a5) & 0x80000000) != 0) {
      return 0;
    }
    a3 = *a5;
LABEL_125:
    uint64_t result = 0;
    unint64_t v11 = (unint64_t)a5[2];
    if ((unint64_t)a3 < v11)
    {
      uint64_t v12 = a3 + 4;
      if ((unint64_t)(a3 + 4) <= v11) {
        continue;
      }
    }
    return result;
  }
  if (v18 == 762869346)
  {
    uint64_t v20 = (unsigned __int8 *)(a3 + 8);
    if ((unint64_t)(a3 + 8) > v11) {
      return 0;
    }
    uint64_t v21 = *((unsigned int *)a3 + 1);
    if ((unint64_t)&v20[v21] > v11 || (LZFSEIBootBufferPushN((uint64_t)v185, v21, v20) & 0x80000000) != 0) {
      return 0;
    }
    a3 = &(*a5)[v21 + 8];
    goto LABEL_124;
  }
  if (v18 != 829978210)
  {
    if (v18 == 611874402)
    {
      *a5 = v12;
      if (*((_DWORD *)a5 + 13))
      {
        int v176 = a5[5];
        *(_DWORD *)int v176 = *((_DWORD *)a5 + 12);
        uint64_t v177 = *((unsigned int *)a5 + 13);
      }
      else
      {
        uint64_t v177 = 0;
        int v176 = a5[5];
      }
      return &v176[v177 - *v185];
    }
    return result;
  }
LABEL_13:
  *((_DWORD *)a5 + 208) = 0;
  if (v18 == 846755426)
  {
    if ((unint64_t)(a3 + 32) > v11) {
      return 0;
    }
    uint64_t result = 0;
    uint64_t v19 = *((void *)a3 + 3);
    *((_DWORD *)a5 + 208) = v19;
    if (v19 < 0x20 || (unint64_t)&a3[v19] > v11) {
      return result;
    }
    if (lzfseDecodeV1(v13, (uint64_t)a3, v11)) {
      return 0;
    }
  }
  else
  {
    if ((unint64_t)(a3 + 772) > v11) {
      return 0;
    }
    memcpy(v13, a3, 0x304uLL);
    *((_DWORD *)a5 + 208) = 772;
  }
  unint64_t v22 = 0;
  for (uint64_t i = 110; i != 150; i += 2)
    v22 += *(unsigned __int16 *)((char *)a5 + i);
  unint64_t v24 = 0;
  for (uint64_t j = 150; j != 190; j += 2)
    v24 += *(unsigned __int16 *)((char *)a5 + j);
  int64x2_t v26 = 0uLL;
  int64x2_t v27 = 0uLL;
  int64x2_t v28 = 0uLL;
  int64x2_t v29 = 0uLL;
  do
  {
    uint16x8_t v30 = *(uint16x8_t *)((char *)a5 + j);
    uint32x4_t v31 = vmovl_u16(*(uint16x4_t *)v30.i8);
    uint32x4_t v32 = vmovl_high_u16(v30);
    int64x2_t v29 = (int64x2_t)vaddw_high_u32((uint64x2_t)v29, v32);
    int64x2_t v28 = (int64x2_t)vaddw_u32((uint64x2_t)v28, *(uint32x2_t *)v32.i8);
    int64x2_t v27 = (int64x2_t)vaddw_high_u32((uint64x2_t)v27, v31);
    int64x2_t v26 = (int64x2_t)vaddw_u32((uint64x2_t)v26, *(uint32x2_t *)v31.i8);
    j += 16;
  }
  while (j != 318);
  unint64_t v33 = vaddvq_s64(vaddq_s64(vaddq_s64(v26, v28), vaddq_s64(v27, v29)));
  int64x2_t v34 = 0uLL;
  uint64_t v35 = 318;
  int64x2_t v36 = 0uLL;
  int64x2_t v37 = 0uLL;
  int64x2_t v38 = 0uLL;
  do
  {
    uint16x8_t v39 = *(uint16x8_t *)((char *)a5 + v35);
    uint32x4_t v40 = vmovl_u16(*(uint16x4_t *)v39.i8);
    uint32x4_t v41 = vmovl_high_u16(v39);
    int64x2_t v38 = (int64x2_t)vaddw_high_u32((uint64x2_t)v38, v41);
    int64x2_t v37 = (int64x2_t)vaddw_u32((uint64x2_t)v37, *(uint32x2_t *)v41.i8);
    int64x2_t v36 = (int64x2_t)vaddw_high_u32((uint64x2_t)v36, v40);
    int64x2_t v34 = (int64x2_t)vaddw_u32((uint64x2_t)v34, *(uint32x2_t *)v40.i8);
    v35 += 16;
  }
  while (v35 != 830);
  int8x16_t v42 = vbicq_s8((int8x16_t)xmmword_20DAD6010, (int8x16_t)vmovl_u16(vcgt_u16((uint16x4_t)0x400040004000400, *(uint16x4_t *)((char *)a5 + 92))));
  *(int8x8_t *)v42.i8 = vorr_s8(*(int8x8_t *)v42.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL));
  if (v42.i32[0] | v42.i32[1] | (2 * (*((_DWORD *)a5 + 18) > 0x9C40u)) | ((*((unsigned __int16 *)a5 + 52) > 0x3Fu) << 7) | (4 * (*((_DWORD *)a5 + 19) > 0x2710u)) | ((*((unsigned __int16 *)a5 + 54) > 0xFFu) << 9) | ((*((unsigned __int16 *)a5 + 53) > 0x3Fu) << 8) | ((v24 > 0x40) << 11) | ((v22 > 0x40) << 10) | (((unint64_t)vaddvq_s64(vaddq_s64(vaddq_s64(v34, v37), vaddq_s64(v36, v38))) > 0x400) << 13) | ((v33 > 0x100) << 12) | (*((_DWORD *)a5 + 15) != 829978210)
    || &(*a5)[*((unsigned int *)a5 + 208) + *((unsigned int *)a5 + 17)] > a5[2])
  {
    return 0;
  }
  int v181 = *((_DWORD *)a5 + 17);
  uint64_t v43 = 0;
  int v44 = 0;
  uint64_t v45 = a5 + 490;
  do
  {
    unsigned int v46 = *(unsigned __int16 *)(v17 + 2 * v43);
    if (*(_WORD *)(v17 + 2 * v43))
    {
      v44 += v46;
      if (v44 > 1024) {
        return 0;
      }
      signed int v47 = 0;
      char v48 = __clz(v46);
      char v49 = v48 - 21;
      unsigned int v50 = 0x800u >> (v48 - 21);
      signed int v51 = v50 - v46;
      char v52 = v48 - 22;
      unsigned int v53 = v46 - v50;
      do
      {
        int v54 = (v53 + v47) << v52;
        if (v47 < v51) {
          char v55 = v49;
        }
        else {
          char v55 = v52;
        }
        if (v47 < v51) {
          LOWORD(v54) = (((_WORD)v46 + (_WORD)v47) << v49) - 1024;
        }
        *(unsigned char *)uint64_t v45 = v55;
        *((unsigned char *)v45 + 1) = v43;
        *((_WORD *)v45 + 1) = v54;
        uint64_t v45 = (char **)((char *)v45 + 4);
        ++v47;
      }
      while (v46 != v47);
    }
    ++v43;
  }
  while (v43 != 256);
  uint64_t v56 = 0;
  unsigned int v57 = a5 + 106;
  do
  {
    unsigned int v58 = *(unsigned __int16 *)(v14 + 2 * v56);
    if (*(_WORD *)(v14 + 2 * v56))
    {
      signed int v59 = 0;
      char v60 = __clz(v58);
      char v61 = v60 - 25;
      unsigned int v62 = 0x80u >> (v60 - 25);
      signed int v63 = v62 - v58;
      char v64 = kLSymbolVBits[v56];
      int v65 = kLSymbolVBase[v56];
      char v66 = v60 - 26;
      unsigned int v67 = v58 - v62;
      do
      {
        int v68 = (v67 + v59) << v66;
        if (v59 < v63) {
          char v69 = v61;
        }
        else {
          char v69 = v66;
        }
        if (v59 < v63) {
          LOWORD(v68) = (((_WORD)v58 + (_WORD)v59) << v61) - 64;
        }
        *(unsigned char *)unsigned int v57 = v64 + v69;
        *((unsigned char *)v57 + 1) = v64;
        *((_WORD *)v57 + 1) = v68;
        *((_DWORD *)v57++ + 1) = v65;
        ++v59;
      }
      while (v58 != v59);
    }
    ++v56;
  }
  while (v56 != 20);
  uint64_t v70 = 0;
  int v71 = a5 + 170;
  do
  {
    unsigned int v72 = *(unsigned __int16 *)(v15 + 2 * v70);
    if (*(_WORD *)(v15 + 2 * v70))
    {
      signed int v73 = 0;
      char v74 = __clz(v72);
      char v75 = v74 - 25;
      unsigned int v76 = 0x80u >> (v74 - 25);
      signed int v77 = v76 - v72;
      char v78 = kMSymbolVBits[v70];
      int v79 = kMSymbolVBase[v70];
      char v80 = v74 - 26;
      unsigned int v81 = v72 - v76;
      do
      {
        int v82 = (v81 + v73) << v80;
        if (v73 < v77) {
          char v83 = v75;
        }
        else {
          char v83 = v80;
        }
        if (v73 < v77) {
          LOWORD(v82) = (((_WORD)v72 + (_WORD)v73) << v75) - 64;
        }
        *(unsigned char *)int v71 = v78 + v83;
        *((unsigned char *)v71 + 1) = v78;
        *((_WORD *)v71 + 1) = v82;
        *((_DWORD *)v71++ + 1) = v79;
        ++v73;
      }
      while (v72 != v73);
    }
    ++v70;
  }
  while (v70 != 20);
  uint64_t v84 = 0;
  __int16 v85 = a5 + 234;
  do
  {
    unsigned int v86 = *(unsigned __int16 *)(v16 + 2 * v84);
    if (*(_WORD *)(v16 + 2 * v84))
    {
      signed int v87 = 0;
      char v88 = __clz(v86);
      char v89 = v88 - 23;
      unsigned int v90 = 0x200u >> (v88 - 23);
      signed int v91 = v90 - v86;
      char v92 = kDSymbolVBits[v84];
      int v93 = kDSymbolVBase[v84];
      char v94 = v88 - 24;
      unsigned int v95 = v86 - v90;
      do
      {
        int v96 = (v95 + v87) << v94;
        if (v87 < v91) {
          char v97 = v89;
        }
        else {
          char v97 = v94;
        }
        if (v87 < v91) {
          LOWORD(v96) = (((_WORD)v86 + (_WORD)v87) << v89) - 256;
        }
        *(unsigned char *)__int16 v85 = v92 + v97;
        *((unsigned char *)v85 + 1) = v92;
        *((_WORD *)v85 + 1) = v96;
        *((_DWORD *)v85++ + 1) = v93;
        ++v87;
      }
      while (v86 != v87);
    }
    ++v84;
  }
  while (v84 != 64);
  *((_DWORD *)a5 + 210) = *((_DWORD *)a5 + 18);
  uint64_t v98 = (uint64_t)*a5;
  uint64_t v99 = *((unsigned int *)a5 + 208);
  unint64_t v100 = (unint64_t)&(*a5)[v99 + *((unsigned int *)a5 + 20)];
  a5[1008] = (char *)v100;
  unint64_t v101 = (unint64_t)a5[2];
  if (v100 > v101) {
    return 0;
  }
  a5[1010] = 0;
  uint16x4_t v102 = *(uint16x4_t *)((char *)a5 + 92);
  a5[1009] = (char *)v102;
  unsigned int v103 = *((_DWORD *)a5 + 22);
  unsigned int v104 = a5[1];
  if (v103)
  {
    if (v100 < (unint64_t)(v104 + 8)) {
      return 0;
    }
    a5[1008] = (char *)(v100 - 8);
    unint64_t v105 = *(void *)(v100 - 8);
    a5[1006] = (char *)v105;
    char v106 = v103 + 64;
    *((_DWORD *)a5 + 2014) = v103 + 64;
    if (v103 < 0xFFFFFFF8) {
      return 0;
    }
  }
  else
  {
    if (v100 < (unint64_t)(v104 + 7)) {
      return 0;
    }
    a5[1008] = (char *)(v100 - 7);
    int v107 = *(_DWORD *)(v100 - 7);
    *(_DWORD *)((char *)a5 + 8051) = *(_DWORD *)(v100 - 4);
    *int8x16_t v183 = v107;
    unint64_t v105 = (unint64_t)a5[1006] & 0xFFFFFFFFFFFFFFLL;
    a5[1006] = (char *)v105;
    char v106 = 56;
    *((_DWORD *)a5 + 2014) = 56;
  }
  uint64_t result = 0;
  if ((vmaxv_u16(vcgt_u16(v102, (uint16x4_t)0xFC00FC00FC00FC00)) & 1) != 0 || v105 >> v106) {
    return result;
  }
  int v108 = *((_DWORD *)a5 + 19);
  *((_DWORD *)a5 + 209) = v108;
  unint64_t v109 = v100 + *((unsigned int *)a5 + 21);
  a5[1004] = (char *)v109;
  if (v109 > v101) {
    return 0;
  }
  unsigned int v110 = *((unsigned __int16 *)a5 + 52);
  *((_WORD *)a5 + 4020) = v110;
  unsigned int v111 = *((unsigned __int16 *)a5 + 53);
  *((_WORD *)a5 + 4021) = v111;
  unsigned int v112 = *((unsigned __int16 *)a5 + 54);
  *((_WORD *)a5 + 4022) = v112;
  unsigned int v113 = *((_DWORD *)a5 + 25);
  if (v113)
  {
    if (v109 < (unint64_t)(v104 + 8)) {
      return 0;
    }
    a5[1004] = (char *)(v109 - 8);
    unint64_t v114 = *(void *)(v109 - 8);
    a5[1002] = (char *)v114;
    char v115 = v113 + 64;
    *((_DWORD *)a5 + 2006) = v113 + 64;
    if (v113 < 0xFFFFFFF8) {
      return 0;
    }
  }
  else
  {
    if (v109 < (unint64_t)(v104 + 7)) {
      return 0;
    }
    a5[1004] = (char *)(v109 - 7);
    int v116 = *(_DWORD *)(v109 - 7);
    *(_DWORD *)((char *)a5 + 8019) = *(_DWORD *)(v109 - 4);
    *uint32x4_t v182 = v116;
    unint64_t v114 = (unint64_t)a5[1002] & 0xFFFFFFFFFFFFFFLL;
    a5[1002] = (char *)v114;
    char v115 = 56;
    *((_DWORD *)a5 + 2006) = 56;
  }
  uint64_t result = 0;
  if (v114 >> v115) {
    return result;
  }
  if (v110 > 0x3F) {
    return result;
  }
  if (v111 > 0x3F) {
    return result;
  }
  BOOL v117 = __OFSUB__(v112, 255);
  if (v112 > 0xFF) {
    return result;
  }
  if (!v108)
  {
LABEL_123:
    a3 = (char *)(v98 + (v99 + v181));
LABEL_124:
    *a5 = a3;
    goto LABEL_125;
  }
  int v118 = 0;
  unsigned int v119 = 0;
  unint64_t v178 = v13;
  while (1)
  {
    int v120 = *((_DWORD *)a5 + 2006);
    int v121 = 63 - v120;
    unsigned int v122 = (63 - v120) & 0xFFFFFFF8;
    int v180 = v118;
    if ((v121 < 0) ^ v117 | ((v121 & 0xFFFFFFF8) == 0))
    {
      uint32x4_t v124 = *(char **)v182;
    }
    else
    {
      long long v123 = &a5[1004][-(v121 >> 3)];
      if (v123 < a5[1]) {
        return 0;
      }
      a5[1004] = v123;
      uint32x4_t v124 = (char *)(FSE_mask_lsb64_mtable[v122] & *(void *)v123 | ((void)a5[1002] << v122));
      a5[1002] = v124;
      v120 += v122;
      *((_DWORD *)a5 + 2006) = v120;
    }
    uint64_t result = 0;
    int8x8_t v125 = &a5[*((unsigned __int16 *)a5 + 4020) + 106];
    int v126 = *(unsigned __int8 *)v125;
    uint64_t v127 = *((unsigned __int8 *)v125 + 1);
    __int16 v128 = *((_WORD *)v125 + 1);
    int v129 = *((_DWORD *)v125 + 1);
    int v130 = v120 - v126;
    *((_DWORD *)a5 + 2006) = v130;
    unint64_t v131 = (unint64_t)v124 >> v130;
    unint64_t v132 = FSE_mask_lsb64_mtable[v130] & (unint64_t)v124;
    a5[1002] = (char *)v132;
    unsigned __int16 v133 = v128 + (((unint64_t)v124 >> v130) >> v127);
    unsigned int v134 = v133;
    *((_WORD *)a5 + 4020) = v133;
    uint64_t v135 = FSE_mask_lsb64_mtable[v127];
    uint64_t v136 = (uint64_t)&a5[*((unsigned __int16 *)a5 + 4021) + 170];
    int v137 = *(unsigned __int8 *)v136;
    uint64_t v138 = *(unsigned __int8 *)(v136 + 1);
    int v139 = *(unsigned __int16 *)(v136 + 2);
    int v179 = *(_DWORD *)(v136 + 4);
    LODWORD(v136) = v130 - v137;
    *((_DWORD *)a5 + 2006) = v130 - v137;
    unint64_t v140 = v132 >> (v130 - v137);
    unint64_t v141 = FSE_mask_lsb64_mtable[v130 - v137] & v132;
    a5[1002] = (char *)v141;
    int v142 = v139 + (v140 >> v138);
    *((_WORD *)a5 + 4021) = v139 + (v140 >> v138);
    uint64_t v143 = FSE_mask_lsb64_mtable[v138];
    int8x16_t v144 = &a5[*((unsigned __int16 *)a5 + 4022) + 234];
    uint64_t v145 = *((unsigned __int8 *)v144 + 1);
    LODWORD(v136) = v136 - *(unsigned __int8 *)v144;
    *((_DWORD *)a5 + 2006) = v136;
    unint64_t v146 = v141 >> v136;
    int8x16_t v147 = (char *)(FSE_mask_lsb64_mtable[(int)v136] & v141);
    __int16 v148 = *((_WORD *)v144 + 1);
    int v149 = *((_DWORD *)v144 + 1);
    a5[1002] = v147;
    *((_WORD *)a5 + 4022) = v148 + (v146 >> v145);
    if (v149 + (FSE_mask_lsb64_mtable[v145] & v146)) {
      unsigned int v119 = v149 + (FSE_mask_lsb64_mtable[v145] & v146);
    }
    if (v134 > 0x3F
      || (unsigned __int16)v142 > 0x3Fu
      || (unsigned __int16)(v148 + (v146 >> v145)) > 0xFFu)
    {
      return result;
    }
    int v150 = v129 + (v135 & v131);
    if (v150)
    {
      int v151 = *((_DWORD *)a5 + 2021);
      do
      {
        if (v151)
        {
          int v152 = *((_DWORD *)a5 + 2020);
        }
        else
        {
          unsigned int v153 = *((_DWORD *)a5 + 210);
          BOOL v155 = __OFSUB__(v153, 4);
          BOOL v154 = v153 >= 4;
          unsigned int v156 = v153 - 4;
          if (!v154) {
            return 0;
          }
          *((_DWORD *)a5 + 2020) = 0;
          int v157 = *((_DWORD *)a5 + 2014);
          int v158 = 63 - v157;
          unsigned int v159 = (63 - v157) & 0xFFFFFFF8;
          if ((v158 < 0) ^ v155 | ((v158 & 0xFFFFFFF8) == 0))
          {
            unint64_t v161 = *(void *)v183;
          }
          else
          {
            __int16 v160 = &a5[1008][-(v158 >> 3)];
            if (v160 < a5[1]) {
              return 0;
            }
            a5[1008] = v160;
            unint64_t v161 = FSE_mask_lsb64_mtable[v159] & *(void *)v160 | ((void)a5[1006] << v159);
            v157 += v159;
            *((_DWORD *)a5 + 2014) = v157;
          }
          int v162 = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4036));
          int v163 = v157 - v162;
          *((_DWORD *)a5 + 2014) = v163;
          unint64_t v164 = v161 >> v163;
          unint64_t v165 = FSE_mask_lsb64_mtable[v163] & v161;
          *((_WORD *)a5 + 4036) = v164 + HIWORD(v162);
          *((_DWORD *)a5 + 2020) = BYTE1(v162);
          LODWORD(v164) = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4037));
          int v166 = v163 - v164;
          *((_DWORD *)a5 + 2014) = v166;
          unint64_t v167 = v165 >> v166;
          unint64_t v168 = FSE_mask_lsb64_mtable[v166] & v165;
          *((_WORD *)a5 + 4037) = v167 + WORD1(v164);
          LODWORD(v167) = v164 & 0xFF00 | BYTE1(v162);
          *((_DWORD *)a5 + 2020) = v167;
          int v169 = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4038));
          int v170 = v166 - v169;
          *((_DWORD *)a5 + 2014) = v170;
          unint64_t v171 = v168 >> v170;
          unint64_t v172 = FSE_mask_lsb64_mtable[v170] & v168;
          *((_WORD *)a5 + 4038) = v171 + HIWORD(v169);
          LODWORD(v167) = v167 & 0xFF00FFFF | (BYTE1(v169) << 16);
          *((_DWORD *)a5 + 2020) = v167;
          int v173 = *((_DWORD *)v184 + *((unsigned __int16 *)a5 + 4039));
          int v174 = v170 - v173;
          *((_DWORD *)a5 + 2014) = v174;
          a5[1006] = (char *)(FSE_mask_lsb64_mtable[v174] & v172);
          *((_WORD *)a5 + 4039) = (v172 >> v174) + HIWORD(v173);
          int v152 = v167 & 0xFFFFFF | (BYTE1(v173) << 24);
          *((_DWORD *)a5 + 2020) = v152;
          *((_DWORD *)a5 + 2021) = 4;
          *((_DWORD *)a5 + 210) = v156;
        }
        if ((LZFSEIBootBufferPush((uint64_t)v185, v152) & 0x80000000) != 0) {
          return 0;
        }
        *((_DWORD *)a5 + 2020) >>= 8;
        int v151 = *((_DWORD *)a5 + 2021) - 1;
        *((_DWORD *)a5 + 2021) = v151;
      }
      while (--v150);
    }
    if ((LZFSEIBootBufferCopy((uint64_t)v185, v179 + (v143 & v140), v119) & 0x80000000) != 0) {
      return 0;
    }
    int v118 = v180 + 1;
    unsigned int v175 = *((_DWORD *)a5 + 209);
    BOOL v117 = __OFSUB__(v180 + 1, v175);
    uint64_t v13 = v178;
    if (v180 + 1 >= v175)
    {
      LODWORD(v99) = *((_DWORD *)a5 + 208);
      uint64_t v98 = (uint64_t)*a5;
      goto LABEL_123;
    }
  }
}

uint64_t lzfse_decode_lzvn_block_iboot(void *a1)
{
  unint64_t v1 = *a1 + 12;
  unint64_t v2 = a1[2];
  if (v1 <= v2)
  {
    uint64_t v3 = *(unsigned int *)(*a1 + 8);
    if (v1 + v3 <= v2)
    {
      if (v3) {
        __asm { BRAA            X9, X17 }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t LZFSEIBootBufferPushN(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  unsigned int v4 = a2;
  if (*(void *)(a1 + 16) + (unint64_t)a2 <= *(void *)(a1 + 8))
  {
    if (a2)
    {
      while (*(_DWORD *)(a1 + 28))
      {
        if ((LZFSEIBootBufferPush(a1, *a3) & 0x80000000) != 0) {
          return 0xFFFFFFFFLL;
        }
        ++a3;
        if (!--v4) {
          return 0;
        }
      }
      if (v4 < 4) {
        goto LABEL_16;
      }
      uint64_t v6 = 0;
      uint64_t v7 = *(void *)(a1 + 16);
      do
      {
        *(_DWORD *)(v7 + v6) = *(_DWORD *)&a3[v6];
        *(void *)(a1 + 16) = v7 + v6 + 4;
        v4 -= 4;
        v6 += 4;
      }
      while (v4 > 3);
      if (v4)
      {
        a3 += v6;
LABEL_16:
        while ((LZFSEIBootBufferPush(a1, *a3) & 0x80000000) == 0)
        {
          ++a3;
          if (!--v4) {
            return 0;
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
    return 0;
  }
  if (!a2) {
    return 0;
  }
  while ((LZFSEIBootBufferPush(a1, *a3) & 0x80000000) == 0)
  {
    ++a3;
    if (!--v4) {
      return 0;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t LZFSEIBootBufferPush(uint64_t a1, int a2)
{
  unint64_t v2 = *(int **)(a1 + 16);
  if ((unint64_t)v2 >= *(void *)(a1 + 8)) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *(_DWORD *)(a1 + 28);
  int v4 = (a2 << (8 * v3++)) | *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = v3;
  if (v3 != 4) {
    return 0;
  }
  uint64_t v5 = 0;
  *unint64_t v2 = v4;
  *(void *)(a1 + 16) = v2 + 1;
  *(void *)(a1 + 24) = 0;
  return v5;
}

uint64_t LZFSEIBootBufferCopy(uint64_t a1, unsigned int a2, unsigned int a3)
{
  BOOL v3 = 0;
  int v4 = a2 != 0;
  if (a3 && a2)
  {
    unsigned int v7 = 0;
    uint64_t v8 = a3;
    unint64_t v9 = (_DWORD *)(a1 + 24);
    while (1)
    {
      unsigned int v10 = *(_DWORD **)(a1 + 16);
      uint64_t v11 = *(unsigned int *)(a1 + 28);
      uint64_t v12 = (uint64_t)v10 + v11 - *(void *)a1 - v8;
      unsigned int v13 = v12 & 3;
      v12 &= 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v14 = (_DWORD *)(*(void *)a1 + v12);
      if (v12 < 0 != v3 || v14 >= v10)
      {
        BOOL v16 = v14 != v10 || v13 >= v11;
        uint64_t v14 = v9;
        if (v16) {
          break;
        }
      }
      if ((LZFSEIBootBufferPush(a1, (*v14 >> (8 * v13))) & 0x80000000) != 0) {
        break;
      }
      BOOL v3 = __OFSUB__(++v7, a2);
      if (v7 >= a2)
      {
        int v4 = 0;
        return (v4 << 31 >> 31);
      }
    }
    int v4 = 1;
  }
  return (v4 << 31 >> 31);
}

uint64_t is_format_msb_layout(int a1)
{
  if ((a1 - 6) > 6) {
    return 0;
  }
  else {
    return dword_20DAD6228[a1 - 6];
  }
}

uint64_t get_format_bytes_per_pixel(int a1, unsigned int a2, int a3)
{
  return get_format_components(a1, a3) << (a2 > 8);
}

uint64_t get_format_components(int a1, int a2)
{
  unsigned __int8 v2 = 1;
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 15:
    case 16:
      return v2;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      if (a2) {
        unsigned __int8 v2 = 2;
      }
      else {
        unsigned __int8 v2 = 1;
      }
      break;
    case 13:
      unsigned __int8 v2 = 3;
      break;
    case 14:
      unsigned __int8 v2 = 4;
      break;
    default:
      unsigned __int8 v2 = 0;
      break;
  }
  return v2;
}

uint64_t get_format_convert_at_once(int a1)
{
  if (a1 == 16) {
    unsigned int v1 = 4;
  }
  else {
    unsigned int v1 = 1;
  }
  if (a1 == 15) {
    return 2;
  }
  else {
    return v1;
  }
}

uint64_t get_format_process_at_once(int a1)
{
  if ((a1 - 15) >= 2) {
    return 1;
  }
  else {
    return 2;
  }
}

const char *is_format_invalid(unsigned int a1, unsigned int a2, int a3, int a4)
{
  if (a1 > 0x10) {
    return "unknown format";
  }
  int v4 = "width/height is 0";
  if (a2 && a3)
  {
    if ((a3 | a2) >> 16)
    {
      return "width/height too large";
    }
    else
    {
      if (a1 - 1 > 0xA) {
        int v6 = 0;
      }
      else {
        int v6 = dword_20DAD6244[a1 - 1];
      }
      if ((v6 & a2) != 0) {
        return "width/format invalid";
      }
      if (a1 == 16) {
        int v7 = 3;
      }
      else {
        int v7 = 0;
      }
      if (a1 == 15) {
        int v7 = 1;
      }
      if ((v7 & a2) != 0)
      {
        return "width/format invalid";
      }
      else
      {
        if (a1 > 0xA || (int v8 = 1, ((1 << a1) & 0x482) == 0)) {
          int v8 = 0;
        }
        int v4 = "height/format invalid";
        if ((v8 & a3) == 0 && (v7 & a3) == 0)
        {
          int v4 = "bits/sample invalid";
          if ((a4 - 17) >= 0xFFFFFFF7 && get_format_bits(a1, a4) == a4) {
            return 0;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t get_format_bits(int a1, int a2)
{
  unsigned __int8 v2 = 8;
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 15:
      unsigned __int8 v2 = a2;
      break;
    case 6:
    case 10:
    case 11:
    case 12:
      if ((a2 - 9) >= 7) {
        unsigned __int8 v2 = 0;
      }
      else {
        unsigned __int8 v2 = a2;
      }
      break;
    case 13:
    case 14:
    case 16:
      return v2;
    default:
      unsigned __int8 v2 = 0;
      break;
  }
  return v2;
}

_DWORD *yzip_image_create(unsigned int a1, unsigned int a2, int a3, unsigned int a4)
{
  if (is_format_invalid(a4, a1, a2, a3)) {
    return 0;
  }
  int format_plane_count = get_format_plane_count(a4);
  uint64_t result = calloc(1uLL, (32 * format_plane_count) | 0x10u);
  if (result)
  {
    result[1] = format_plane_count;
    result[2] = a4;
    if (format_plane_count)
    {
      uint64_t v10 = 0;
      uint64_t v11 = (int)(a4 - 1);
      uint64_t v15 = result;
      for (uint64_t i = result + 10; ; i += 8)
      {
        if (v10)
        {
          if (v11 > 0xA) {
            LOBYTE(v13) = 0;
          }
          else {
            int v13 = dword_20DAD6244[v11];
          }
          if (a4 <= 0xA && ((1 << a4) & 0x482) != 0)
          {
            char v14 = 1;
            goto LABEL_15;
          }
        }
        else
        {
          LOBYTE(v13) = 0;
        }
        char v14 = 0;
LABEL_15:
        *(i - 2) = a1 >> v13;
        *(i - 1) = a2 >> v14;
        *uint64_t i = a3;
        *((void *)i - 2) = (get_format_components(a4, v10++) << (a3 > 8u))
                           * (unint64_t)(a1 >> v13);
        if (format_plane_count == v10) {
          return v15;
        }
      }
    }
  }
  return result;
}

uint64_t get_format_plane_count(unsigned int a1)
{
  if (a1 > 0x10) {
    return 0;
  }
  else {
    return byte_20DAD6270[a1];
  }
}

unsigned int *yzip_image_create_with_payload(unsigned int *a1, unint64_t a2)
{
  uint64_t result = header_fetch_from_payload(a1, a2);
  if (result)
  {
    unsigned int v3 = *((unsigned __int16 *)result + 10);
    int v4 = *((unsigned __int8 *)result + 26);
    unsigned int v5 = *((unsigned __int8 *)result + 16);
    unsigned int v6 = *((unsigned __int16 *)result + 9);
    return yzip_image_create(v6, v3, v4, v5);
  }
  return result;
}

unsigned int *header_fetch_from_payload(unsigned int *a1, unint64_t a2)
{
  if (a2 < 0x12) {
    return 0;
  }
  uint64_t v4 = *((unsigned __int8 *)a1 + 17);
  unint64_t v5 = 10 * v4 + 18;
  if (v5 > a2) {
    return 0;
  }
  unint64_t v6 = *a1;
  if (v6 > a2) {
    return 0;
  }
  unint64_t v7 = *((unsigned __int16 *)a1 + 2);
  if (v5 > v7 || v6 <= *((unsigned __int16 *)a1 + 3) + v7) {
    return 0;
  }
  unsigned int v9 = a1[2];
  if (v9 != 1297111641 && v9 != 810572377) {
    return 0;
  }
  uint64_t result = 0;
  if (v4)
  {
    unsigned int v10 = *((unsigned __int8 *)a1 + 16);
    if (v10 <= 0x10)
    {
      uint64_t v11 = 0;
      for (uint64_t i = (unsigned __int8 *)a1 + 27; ; i += 10)
      {
        unsigned int v13 = *(unsigned __int16 *)(i - 9);
        if (!*(_WORD *)(i - 9)) {
          break;
        }
        unsigned int v14 = *(unsigned __int16 *)(i - 5);
        if (v13 <= (unsigned __int16)(v14 - 1)) {
          break;
        }
        unsigned int v15 = *(unsigned __int16 *)(i - 7);
        if (!*(_WORD *)(i - 7)) {
          break;
        }
        unsigned int v16 = *(unsigned __int16 *)(i - 3);
        if (v15 <= (unsigned __int16)(v16 - 1) || v14 <= 0x3F && v13 != v14) {
          break;
        }
        if (v16 <= 0x3F && v15 != v16) {
          break;
        }
        if (*(i - 1) - 17 < 0xFFFFFFF7) {
          break;
        }
        int v17 = *i;
        if (v17 != get_format_components(v10, v11)) {
          break;
        }
        if (v4 == ++v11) {
          return a1;
        }
      }
      return 0;
    }
  }
  return result;
}

_DWORD *yzip_image_encode(uint64_t a1, void **a2, unsigned __int16 *a3, unint64_t a4)
{
  unint64_t v7 = (unsigned int *)a1;
  if (!is_image_valid(a1)) {
    return 0;
  }
  uint64_t v8 = 10 * v7[1];
  unsigned __int16 v9 = v8 + 18;
  if (v8 + 18 > a4) {
    return 0;
  }
  int v10 = 810572377;
  bzero(a3, v8 + 18);
  a3[2] = v9;
  *((_DWORD *)a3 + 2) = 810572377;
  *((_DWORD *)a3 + 3) = *v7;
  *((unsigned char *)a3 + 16) = v7[2];
  *((unsigned char *)a3 + 17) = v7[1];
  if (!v7[1])
  {
    *(_DWORD *)a3 = v9 & 0xFFFE;
    int64x2_t v37 = (_DWORD *)((char *)a3 + (v9 & 0xFFFE));
    uint64_t v38 = a4 - (v9 & 0xFFFE);
    goto LABEL_60;
  }
  unsigned __int16 v52 = v9;
  unint64_t v53 = a4;
  unint64_t v11 = 0;
  uint64_t v12 = a3 + 9;
  unsigned int v61 = 810572377;
  uint64_t v13 = 810572377;
  unsigned int v58 = v7;
  signed int v59 = a3;
  int v54 = a3 + 9;
  char v55 = a2;
  do
  {
    unsigned int v14 = &v12[5 * v11];
    unsigned int v15 = &v7[8 * v11];
    unsigned int v16 = v15[8];
    unsigned int v17 = v15[9];
    *unsigned int v14 = v16;
    v14[1] = v17;
    *((unsigned char *)v14 + 8) = v15[10];
    char format_components = get_format_components(v7[2], v11);
    _OWORD v14[2] = v16;
    uint64_t v19 = v14 + 2;
    *((unsigned char *)v19 + 5) = format_components;
    v19[1] = v17;
    uint64_t v20 = 1297111641;
    if (v13 == 1297111641)
    {
      int v21 = v61;
      goto LABEL_23;
    }
    unsigned int v62 = v19 + 1;
    signed int v63 = v19;
    unsigned __int16 v57 = v16;
    if (v11)
    {
      LOWORD(v22) = v17;
LABEL_9:
      unsigned int v23 = 1;
      unsigned int v24 = 3;
      do
      {
        unsigned int v25 = v24 - 1;
        if ((unsigned __int16)v16 <= (unsigned __int16)v22)
        {
          unsigned int v22 = (v25 + (unsigned __int16)v22) / v24;
          *unsigned int v62 = v22;
        }
        else
        {
          unsigned int v16 = (v25 + (unsigned __int16)v16) / v24;
          *signed int v63 = v16;
        }
        v23 *= v24;
        unsigned int v24 = 2;
      }
      while (v23 < 0x18);
      uint64_t v20 = v13;
      int v21 = v61;
      goto LABEL_15;
    }
    __int16 v56 = v17;
    unsigned int v28 = v7[2];
    int format_plane_count = get_format_plane_count(v28);
    if (!format_plane_count)
    {
      LOWORD(v22) = v17;
      goto LABEL_46;
    }
    int v30 = format_plane_count;
    LOWORD(v22) = v56;
    while (2)
    {
      int v60 = v10;
      int v31 = 0;
      unint64_t v32 = 0;
      uint64_t v33 = (int)(v28 - 1);
      do
      {
        if (!v31)
        {
          char v34 = 0;
LABEL_32:
          char v35 = 0;
          goto LABEL_37;
        }
        if (v33 > 0xA) {
          char v34 = 0;
        }
        else {
          char v34 = byte_20DAD6281[v33];
        }
        if (v28 > 0xA || ((1 << v28) & 0x482) == 0) {
          goto LABEL_32;
        }
        char v35 = 1;
LABEL_37:
        v32 += ((unint64_t)(unsigned __int16)v16 >> v34)
             * ((unint64_t)(unsigned __int16)v22 >> v35)
             * get_format_components(v28, v31++);
      }
      while (v30 != v31);
      if (v32 >= 0x600000)
      {
        unint64_t v7 = v58;
        a3 = v59;
        if ((unsigned __int16)v16 <= (unsigned __int16)v22)
        {
          unsigned int v22 = ((unsigned __int16)v22 + 1) >> 1;
          *unsigned int v62 = v22;
        }
        else
        {
          unsigned int v16 = ((unsigned __int16)v16 + 1) >> 1;
          *signed int v63 = v16;
        }
        *((_DWORD *)v59 + 2) = 1297111641;
        unsigned int v28 = v58[2];
        int v30 = get_format_plane_count(v28);
        int v10 = 1297111641;
        uint64_t v20 = 1297111641;
        unsigned int v61 = 1297111641;
        if (!v30)
        {
          int v21 = 1297111641;
          uint64_t v12 = v54;
          unint64_t v11 = 0;
          LOWORD(v17) = v56;
          goto LABEL_15;
        }
        continue;
      }
      break;
    }
    unint64_t v7 = v58;
    a3 = v59;
    uint64_t v12 = v54;
    unint64_t v11 = 0;
    int v10 = v60;
    LOWORD(v17) = v56;
LABEL_46:
    uint64_t v13 = v61;
    uint64_t v20 = 1297111641;
    int v21 = 1297111641;
    if (v61 != 1297111641) {
      goto LABEL_9;
    }
LABEL_15:
    unsigned __int16 v26 = (v16 + 7) & 0xFFF8;
    *signed int v63 = v26;
    unsigned __int16 v27 = (v22 + 7) & 0xFFF8;
    *unsigned int v62 = v27;
    if ((unsigned __int16)(v16 + 7) <= 0x3Fu)
    {
      unsigned __int16 v26 = 64;
      *signed int v63 = 64;
    }
    if ((((_WORD)v22 + 7) & 0xFFF8u) <= 0x3F)
    {
      unsigned __int16 v27 = 64;
      *unsigned int v62 = 64;
    }
    if (v26 > v57) {
      *signed int v63 = v57;
    }
    if (v27 > (unsigned __int16)v17) {
      *unsigned int v62 = v17;
    }
LABEL_23:
    ++v11;
    unsigned int v61 = v21;
    uint64_t v13 = v20;
  }
  while (v11 < v7[1]);
  *(_DWORD *)a3 = v52 & 0xFFFE;
  uint64_t v36 = v52 & 0xFFFE;
  int64x2_t v37 = (_DWORD *)((char *)a3 + v36);
  uint64_t v38 = v53 - v36;
  a2 = v55;
  if (v10 != 1297111641)
  {
LABEL_60:
    size_t pool_size = get_pool_size((uint64_t)a3, 1);
    if ((yzip_codec_pool_init(a2, pool_size) & 0x80000000) == 0)
    {
      encoder_list = (uint64_t *)yzip_jobs_create_encoder_list((uint64_t)a2, (uint64_t)v7, (uint64_t)a3);
      uint64_t v51 = yzip_jobs_encode((uint64_t)a2, encoder_list, v37, v38);
      if (v51 >= 1)
      {
        unsigned int v48 = *(_DWORD *)a3 + v51;
        *(_DWORD *)a3 = v48;
        return (_DWORD *)v48;
      }
    }
    return 0;
  }
  unsigned int v39 = a3[10];
  if (!a3[10]) {
    return (_DWORD *)*(unsigned int *)a3;
  }
  unsigned int v40 = 0;
  unsigned int v41 = a3[9];
  while (!v41)
  {
LABEL_57:
    v40 += a3[12];
    if (v40 >= v39) {
      return (_DWORD *)*(unsigned int *)a3;
    }
  }
  unsigned int v42 = 0;
  while (1)
  {
    unsigned int slice_width = get_slice_width(v12, v42);
    unsigned int slice_height = get_slice_height((uint64_t)v12, v40);
    uint64_t result = create_rectangle_within_image((uint64_t)v7, v42, v40, slice_width, slice_height);
    if (!result) {
      return result;
    }
    unsigned int v46 = result;
    uint64_t v47 = yzip_image_encode(result, v55, v37, v38);
    if (!v47)
    {
      free(v46);
      return 0;
    }
    int64x2_t v37 = (_DWORD *)((char *)v37 + v47);
    v38 -= v47;
    *(_DWORD *)a3 += v47;
    free(v46);
    v42 += a3[11];
    unsigned int v41 = a3[9];
    if (v42 >= v41)
    {
      unsigned int v39 = a3[10];
      goto LABEL_57;
    }
  }
}

uint64_t is_image_valid(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 4);
  if (v1)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 8);
    if (v1 == get_format_plane_count(v3)
      && !is_format_invalid(v3, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(unsigned __int8 *)(a1 + 40)))
    {
      for (uint64_t i = (void *)(a1 + 16); *i; i += 4)
      {
        if (!--v1) {
          return 1;
        }
      }
    }
  }
  return 0;
}

_DWORD *create_rectangle_within_image(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unint64_t v6 = yzip_image_create(a4, a5, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 8));
  if (v6)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 4);
    if (v7)
    {
      int v8 = 0;
      unint64_t v9 = 0;
      uint64_t v19 = 32 * v7;
      do
      {
        if (v9)
        {
          unsigned int v10 = *(_DWORD *)(a1 + 8);
          if (v10 - 1 > 0xA) {
            char v11 = 0;
          }
          else {
            char v11 = byte_20DAD6281[v10 - 1];
          }
          BOOL v13 = v10 > 0xA;
          int v14 = (1 << v10) & 0x482;
          char v12 = !v13 && v14 != 0;
        }
        else
        {
          char v11 = 0;
          char v12 = 0;
        }
        uint64_t v16 = *(void *)(a1 + v9 + 16);
        *(void *)&v6[v9 / 4 + 6] = *(void *)(a1 + v9 + 24);
        unsigned int v17 = *(unsigned __int8 *)(a1 + v9 + 40);
        *(void *)&v6[v9 / 4 + 4] = v16
                                   + (get_format_components(v6[2], v8) << (v17 > 8))
                                   * (unint64_t)(a2 >> v11)
                                   + *(void *)(a1 + v9 + 24) * (a3 >> v12);
        v9 += 32;
        ++v8;
      }
      while (v19 != v9);
    }
  }
  return v6;
}

uint64_t yzip_image_decode(_DWORD *a1, void **a2, unsigned int *a3, unint64_t a4)
{
  int v8 = header_fetch_from_payload(a3, a4);
  if (!v8) {
    return 0;
  }
  unint64_t v9 = (unsigned __int16 *)v8;
  uint64_t v10 = a1[1];
  if (__PAIR64__(v10, a1[2]) != __PAIR64__(*((unsigned __int8 *)v8 + 17), *((unsigned __int8 *)v8 + 16))) {
    return 0;
  }
  uint64_t v11 = *((unsigned __int16 *)v8 + 2);
  if (v10)
  {
    char v12 = a1 + 10;
    BOOL v13 = (unsigned __int16 *)v8 + 9;
    while (*((void *)v12 - 3) && *(v12 - 2) == *v13 && *(v12 - 1) == v13[1] && *v12 == *((unsigned __int8 *)v13 + 8))
    {
      v12 += 8;
      v13 += 5;
      if (!--v10) {
        goto LABEL_10;
      }
    }
    return 0;
  }
LABEL_10:
  int v14 = (char *)a3 + v11;
  uint64_t v15 = a4 - v11;
  *a1 = v8[3];
  if (v8[2] == 1297111641)
  {
    if (!*((_WORD *)v8 + 3))
    {
      unsigned int v16 = *((unsigned __int16 *)v8 + 10);
      if (*((_WORD *)v8 + 10))
      {
        unsigned int v17 = 0;
        uint64_t v18 = 0;
        unsigned int v19 = *((unsigned __int16 *)v8 + 9);
        while (!v19)
        {
LABEL_20:
          v17 += v9[12];
          if (v17 >= v16) {
            return v18;
          }
        }
        unsigned int v20 = 0;
        while (1)
        {
          unsigned int slice_width = get_slice_width(v9 + 9, v20);
          unsigned int slice_height = get_slice_height((uint64_t)(v9 + 9), v17);
          rectangle_within_image = create_rectangle_within_image((uint64_t)a1, v20, v17, slice_width, slice_height);
          if (!rectangle_within_image) {
            break;
          }
          unsigned int v24 = rectangle_within_image;
          uint64_t v25 = yzip_image_decode(rectangle_within_image, a2, v14, v15);
          if (!v25)
          {
            free(v24);
            return 0;
          }
          v18 += v25;
          uint64_t v26 = *(unsigned int *)v14;
          v14 += v26;
          v15 -= v26;
          free(v24);
          v20 += v9[11];
          unsigned int v19 = v9[9];
          if (v20 >= v19)
          {
            unsigned int v16 = v9[10];
            goto LABEL_20;
          }
        }
      }
    }
    return 0;
  }
  size_t pool_size = get_pool_size((uint64_t)v8, 0);
  if ((yzip_codec_pool_init(a2, pool_size) & 0x80000000) != 0) {
    return 0;
  }
  unint64_t decoder_list = yzip_jobs_create_decoder_list((uint64_t)a2, (uint64_t)a1, (uint64_t)v9, v14, v15);
  if (!decoder_list) {
    return 0;
  }
  uint64_t v18 = yzip_jobs_decode((uint64_t)a2, decoder_list);
  if (v18 < 0) {
    return 0;
  }
  return v18;
}

uint64_t yzip_image_get_descriptor(int *a1, uint64_t a2)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = a1[1];
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = 32 * v2;
  do
  {
    v4 += *(void *)&a1[v3 / 4 + 6] * a1[v3 / 4 + 9];
    v3 += 32;
  }
  while (v5 != v3);
  uint64_t v6 = 0;
  *(void *)a2 = v4;
  *(void *)(a2 + 8) = *((void *)a1 + 4);
  *(_DWORD *)(a2 + 16) = a1[10];
  *(_DWORD *)(a2 + 20) = a1[1];
  int v7 = *a1;
  *(_DWORD *)(a2 + 24) = a1[2];
  *(_DWORD *)(a2 + 28) = v7;
  return v6;
}

uint64_t yzip_image_get_plane_descriptor(uint64_t a1, unsigned int a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if (!a1 || *(_DWORD *)(a1 + 4) <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = a1 + 32 * a2;
  uint64_t v6 = *(void *)(v5 + 16);
  uint64_t v7 = *(void *)(v5 + 24);
  uint64_t v9 = v5 + 32;
  LODWORD(v5) = *(_DWORD *)(v5 + 32);
  uint64_t v8 = *(unsigned int *)(v9 + 4);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v7 * v8;
  *(void *)(a3 + 16) = v7;
  *(_DWORD *)(a3 + 24) = v5;
  *(_DWORD *)(a3 + 28) = v8;
  return result;
}

uint64_t yzip_image_get_max_payload_size(_DWORD *a1)
{
  if (!a1) {
    return 0;
  }
  unsigned int v2 = a1[1];
  uint64_t v3 = 10 * v2 + 18;
  if (v2)
  {
    unint64_t v4 = 0;
    uint64_t v5 = a1 + 10;
    do
    {
      uint64_t v6 = get_plane_max_rice_size(*v5) + v3;
      int v7 = *(v5 - 2);
      int v8 = *(v5 - 1);
      int v9 = *v5;
      v5 += 8;
      uint64_t v3 = v6 + get_max_payload_size(v7, v8, a1[2], v9, v4++);
    }
    while (v4 < a1[1]);
  }
  return v3;
}

uint64_t yzip_image_set_data(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 4);
    if (v4)
    {
      unint64_t v5 = 0;
      uint64_t v6 = a1 + 24;
      uint64_t v7 = *(unsigned int *)(a1 + 4);
      do
      {
        *(void *)(v6 - 8) = v5 + a2;
        v5 += *(void *)v6 * *(unsigned int *)(v6 + 12);
        v6 += 32;
        --v7;
      }
      while (v7);
      BOOL v8 = v5 > a3;
      int v9 = v5 > a3;
      if (v8)
      {
        uint64_t v10 = (void *)(a1 + 16);
        do
        {
          *uint64_t v10 = 0;
          v10 += 4;
          --v4;
        }
        while (v4);
        int v9 = 1;
      }
    }
    else
    {
      int v9 = 0;
    }
    return (v9 << 31 >> 31);
  }
  return v3;
}

uint64_t yzip_image_set_plane_data(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a3 && a4)
  {
    if (*(_DWORD *)(a1 + 4) <= a2) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v10 = a1 + 16;
    uint64_t v11 = a2;
    uint64_t v12 = a1 + 16 + 32 * a2;
    unsigned int v13 = *(_DWORD *)(v12 + 16);
    unsigned int v14 = *(unsigned __int8 *)(v12 + 24);
    int format_components = get_format_components(*(_DWORD *)(a1 + 8), a2);
    if (HIWORD(v13)) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v16 = *(unsigned int *)(v12 + 20);
    if (WORD1(v16)) {
      return 0xFFFFFFFFLL;
    }
    if (a5)
    {
      if (v13 * (unint64_t)(format_components << (v14 > 8)) > a5) {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      a5 = v13 * (unint64_t)(format_components << (v14 > 8));
    }
    if (a5 * v16 <= a4)
    {
      uint64_t result = 0;
      *(void *)uint64_t v12 = a3;
      *(void *)(v10 + 32 * v11 + 8) = a5;
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

_DWORD *yzip_image_set_identifier(_DWORD *result, int a2)
{
  if (result) {
    *uint64_t result = a2;
  }
  return result;
}

unint64_t smb_lz77h_decode_buffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, char *a5)
{
  unint64_t v6 = 0;
  unint64_t v7 = 0;
  uint64_t v79 = *MEMORY[0x263EF8340];
  uint64_t v8 = 15;
  if (a2 > 0xF) {
    uint64_t v8 = a2;
  }
  int v9 = a5 + 5120;
  uint64_t v10 = a5 + 4096;
  uint64_t v11 = a5 + 5121;
  long long v12 = 0uLL;
  v13.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v13.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  unint64_t v74 = a2;
  unint64_t v75 = a4;
  uint64_t v73 = a3;
  unint64_t v71 = a1 + v8 - 15;
LABEL_4:
  unint64_t v14 = v6 + 256;
  if (v6 + 256 > a4)
  {
    if (v7 != a2) {
      return 0;
    }
  }
  else
  {
    uint64_t v15 = (int8x16_t *)(a3 + v6);
    __int16 v78 = 0;
    unint64_t v16 = -32;
    long long v76 = v12;
    long long v77 = v12;
    do
    {
      int8x16_t v17 = *v15++;
      int8x16_t v18 = vandq_s8(v17, v13);
      int8x16_t v19 = (int8x16_t)vshrq_n_u8((uint8x16_t)v17, 4uLL);
      unsigned int v20 = (int8x16_t *)&a5[v16];
      v20[323] = vzip2q_s8(v18, v19);
      v20[322] = vzip1q_s8(v18, v19);
      v16 += 32;
    }
    while (v16 < 0x1E0);
    unint64_t v21 = 0;
    do
    {
      unsigned int v22 = (char *)&v76 + 2 * v11[v21 - 1];
      ++*((_WORD *)v22 + 1);
      unsigned int v23 = (char *)&v76 + 2 * v11[v21];
      ++*((_WORD *)v23 + 1);
      unsigned int v24 = (char *)&v76 + 2 * v11[v21 + 1];
      ++*((_WORD *)v24 + 1);
      uint64_t v25 = (char *)&v76 + 2 * v11[v21 + 2];
      ++*((_WORD *)v25 + 1);
      BOOL v26 = v21 >= 0x1FC;
      v21 += 4;
    }
    while (!v26);
    int v27 = 0;
    WORD1(v76) = 0;
    for (uint64_t i = 4; i != 34; i += 2)
    {
      v27 += *(unsigned __int16 *)((char *)&v76 + i);
      *(_WORD *)((char *)&v76 + i) = v27;
    }
    uint64_t v29 = 0;
    LOWORD(v76) = v78;
    do
    {
      uint64_t v30 = v9[v29];
      uint64_t v31 = *((unsigned __int16 *)&v76 + v30);
      *((_WORD *)&v76 + v30) = v31 + 1;
      *(_WORD *)&v10[2 * v31] = v30 + 16 * v29++;
    }
    while (v29 != 512);
    uint64_t v32 = HIWORD(v77);
    if (HIWORD(v77))
    {
      bzero(a5, 0x800uLL);
      int v33 = 0x8000;
      unint64_t v34 = 1024;
      while (1)
      {
        int v35 = v33;
        __int16 v36 = *(_WORD *)&a5[2 * v32 + 4094];
        unsigned int v37 = v36 & 0xF;
        v33 += -1 << (v36 & 0xF ^ 0xF);
        if (v33 < 0) {
          break;
        }
        int v38 = v33 >> 5;
        if (v37 > 0xA)
        {
          unsigned int v41 = *(unsigned __int16 *)&a5[2 * v38];
          if (!*(_WORD *)&a5[2 * v38])
          {
            LOWORD(v41) = v37 | (16 * v34);
            *(_WORD *)&a5[2 * v38] = v41;
            v34 += (1 << (v37 - 10));
            if (v34 > 0x800) {
              return 0;
            }
            unsigned int v41 = (unsigned __int16)v41;
          }
          uint64_t v42 = (v33 >> (v41 & 0xF ^ 0xF)) & ~(-1 << ((v41 & 0xF) - 10));
          unint64_t v43 = (1 << ((v41 & 0xF) - v37)) + (v41 >> 4) + v42;
          unint64_t v44 = v42 + (v41 >> 4);
          do
            *(_WORD *)&a5[2 * v44++] = v36;
          while (v44 < v43);
        }
        else if (v38 < v35 >> 5)
        {
          unsigned int v39 = &a5[2 * v38];
          uint64_t v40 = (v35 >> 5) - (uint64_t)v38;
          do
          {
            *(_WORD *)unsigned int v39 = v36;
            v39 += 2;
            --v40;
          }
          while (v40);
        }
        BOOL v63 = v32-- <= 1;
        if (v63)
        {
          if (v33) {
            return 0;
          }
          unint64_t v45 = v6 + 258;
          a4 = v75;
          if (v6 + 258 > v75) {
            return 0;
          }
          v6 += 260;
          if (v6 > v75) {
            return 0;
          }
          a3 = v73;
          a2 = v74;
          unsigned int v46 = *(unsigned __int16 *)(v73 + v45) | (*(unsigned __int16 *)(v73 + v14) << 16);
          if (v7 + 0x10000 >= v74) {
            unint64_t v47 = v74;
          }
          else {
            unint64_t v47 = v7 + 0x10000;
          }
          int v48 = 16;
          if (v7 < v47)
          {
            long long v12 = 0uLL;
            v13.i64[0] = 0xF0F0F0F0F0F0F0FLL;
            v13.i64[1] = 0xF0F0F0F0F0F0F0FLL;
            while (1)
            {
              unsigned int v49 = *(unsigned __int16 *)&a5[2 * (v46 >> 22)];
              if (v49 >= 0x4000) {
                unsigned int v49 = *(unsigned __int16 *)&a5[2 * (v46 << 10 >> (42 - (v49 & 0xF))) + 2 * (v49 >> 4)];
              }
              unsigned int v50 = v46 << (v49 & 0xF);
              v48 -= v49 & 0xF;
              if (v48 < 0)
              {
                if (v6 + 2 > v75) {
                  return 0;
                }
                v50 |= *(unsigned __int16 *)(v73 + v6) << -(char)v48;
                v48 += 16;
                v6 += 2;
              }
              unsigned int v51 = v49 >> 4;
              if (v49 > 0xFFF)
              {
                if (v51 == 256 && v6 == v75) {
                  return v7;
                }
                unint64_t v53 = v49 >> 4;
                if (v53 == 15)
                {
                  if (v6 >= v75) {
                    return 0;
                  }
                  unint64_t v54 = v6 + 1;
                  unint64_t v55 = *(unsigned __int8 *)(v73 + v6);
                  if (v55 == 255)
                  {
                    unint64_t v56 = v6 + 3;
                    if (v6 + 3 > v75) {
                      return 0;
                    }
                    unint64_t v57 = *(unsigned __int16 *)(v73 + v54);
                    if (!*(_WORD *)(v73 + v54))
                    {
                      if (v6 + 7 > v75) {
                        return 0;
                      }
                      unint64_t v57 = *(unsigned int *)(v73 + v56);
                      unint64_t v56 = v6 + 7;
                    }
                    BOOL v26 = v57 >= 0xF;
                    unint64_t v55 = v57 - 15;
                    if (!v26) {
                      return 0;
                    }
                  }
                  else
                  {
                    unint64_t v56 = v6 + 1;
                  }
                  unint64_t v53 = v55 + 15;
                  unint64_t v6 = v56;
                }
                int v58 = (v49 >> 8) & 0xF;
                unsigned int v46 = v50 << v58;
                v48 -= v58;
                if (v48 < 0)
                {
                  if (v6 + 2 > v75) {
                    return 0;
                  }
                  v46 |= *(unsigned __int16 *)(v73 + v6) << -(char)v48;
                  v48 += 16;
                  v6 += 2;
                }
                unint64_t v59 = (HIWORD(v50) >> (16 - v58)) | (1 << v58);
                if (v7 < v59) {
                  return 0;
                }
                unint64_t v60 = v53 + 3;
                unsigned int v61 = (unsigned char *)(a1 + v7);
                unint64_t v62 = a1 + v7 + v53 + 3;
                BOOL v63 = v59 < 0x10 || v62 > v71;
                if (v63)
                {
                  if (v60 > v74 - v7) {
                    return 0;
                  }
                  uint64_t v64 = -(uint64_t)v59;
                  do
                  {
                    *unsigned int v61 = v61[v64];
                    ++v61;
                  }
                  while ((unint64_t)v61 < v62);
                }
                else
                {
                  uint64_t v65 = -(uint64_t)v59;
                  do
                  {
                    *(_OWORD *)unsigned int v61 = *(_OWORD *)&v61[v65];
                    v61 += 16;
                  }
                  while ((unint64_t)v61 < v62);
                }
                v7 += v60;
              }
              else
              {
                *(unsigned char *)(a1 + v7++) = v51;
                unsigned int v46 = v50;
              }
              if (v7 >= v47) {
                goto LABEL_77;
              }
            }
          }
          long long v12 = 0uLL;
          v13.i64[0] = 0xF0F0F0F0F0F0F0FLL;
          v13.i64[1] = 0xF0F0F0F0F0F0F0FLL;
LABEL_77:
          unsigned int v66 = *(unsigned __int16 *)&a5[2 * (v46 >> 22)];
          if (v66 >= 0x4000) {
            LOWORD(v66) = *(_WORD *)&a5[2 * (v46 << 10 >> (42 - (v66 & 0xF))) + 2 * (v66 >> 4)];
          }
          int v67 = v66 & 0xFFF0;
          int v68 = v66 & 0xF;
          if (v67 == 4096 && v48 < v68)
          {
            v6 += 2;
            if (v6 > v75) {
              return 0;
            }
          }
          if (v6 != v75) {
            goto LABEL_4;
          }
          return v7;
        }
      }
    }
    return 0;
  }
  return v7;
}

uint64_t smb_lz77h_encode_buffer(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char *a5)
{
  uint64_t v163 = *MEMORY[0x263EF8340];
  unsigned int v153 = (unsigned __int16 *)(a5 + 171362);
  int8x16_t v147 = a5 + 170338;
  __int16 v148 = (unsigned __int16 *)(a5 + 171876);
  uint64_t v8 = a5 + 169312;
  BOOL v155 = (unsigned __int16 *)(a5 + 162144);
  bzero(a5, 0x10006uLL);
  uint64_t v9 = a3;
  uint64_t result = 0;
  unint64_t v11 = 0;
  long long v12 = a5 + 167264;
  int8x16_t v13 = a5 + 165216;
  unint64_t v14 = a5 + 168288;
  unint64_t v146 = a5 + 161120;
  uint64_t v145 = v9 + 1;
  uint64_t v151 = v9;
  do
  {
    if (v11 >= a4) {
      return result;
    }
    uint64_t v156 = result;
    unint64_t v157 = v11;
    if (v11 + 0x10000 >= a4) {
      unint64_t v15 = a4;
    }
    else {
      unint64_t v15 = v11 + 0x10000;
    }
    if (v15 <= 8) {
      uint64_t v16 = 8;
    }
    else {
      uint64_t v16 = v15;
    }
    unint64_t v17 = v11 + 1;
    bzero(a5 + 152928, 0x2000uLL);
    if (v17 < v15)
    {
      int v18 = 0;
      unint64_t v19 = v16 - 8;
      unsigned int v20 = 1;
      unint64_t v21 = v17;
      uint64_t v22 = v151;
      while (1)
      {
        if (v21 + 4 <= a4)
        {
          uint64_t v23 = 0;
          unsigned int v24 = 0;
          uint64_t v25 = &a5[2 * ((-1640531535 * (*(_DWORD *)(v151 + v21) & 0xFFFFFFu)) >> 17)];
          uint64_t v26 = v21 & 0xFFFF0000;
          unsigned int v27 = 2;
          LOWORD(v28) = v21;
          do
          {
            uint64_t v29 = *(unsigned __int16 *)&v25[2 * v23];
            *(_WORD *)&v25[2 * v23] = v28;
            unint64_t v28 = v26 | v29;
            if (v21 != (v26 | v29))
            {
              unsigned int v30 = v28 - 0x10000;
              if (v28 < v21) {
                unsigned int v30 = v28;
              }
              if (v21 >= v19)
              {
                LODWORD(v31) = 0;
              }
              else
              {
                unint64_t v31 = 0;
                unsigned int v32 = 0;
                while (1)
                {
                  unint64_t v31 = *(void *)(v151 + v30 + v31) ^ *(void *)(v151 + v21 + v31);
                  if (v31) {
                    break;
                  }
                  v32 += 8;
                  unint64_t v31 = v32;
                  if (v21 + v32 >= v19) {
                    goto LABEL_24;
                  }
                }
                LODWORD(v31) = v32 + (__clz(__rbit64(v31)) >> 3);
              }
LABEL_24:
              if (v27 < v31) {
                unsigned int v24 = v30;
              }
              if (v27 <= v31) {
                unsigned int v27 = v31;
              }
            }
            ++v23;
          }
          while (v23 != 3);
          if (v27 >= 4)
          {
            LOWORD(v33) = v21 - v24;
LABEL_34:
            *(_DWORD *)&a5[4 * (v20 >> 5) + 152928] |= 1 << v20;
            int v34 = v18 + 1;
            int v35 = &a5[4 * v18 + 65542];
            *(_WORD *)int v35 = v33;
            *((_WORD *)v35 + 1) = v27;
            unint64_t v36 = v21 + v27;
            unint64_t v17 = v21 + 1;
            if (v21 + 1 >= v36)
            {
              int v18 = v34;
            }
            else
            {
              uint64_t v37 = v27 - 1;
              do
              {
                unint64_t v38 = v21 + 1;
                if (v21 + 5 <= a4)
                {
                  unsigned int v39 = &a5[2 * ((-1640531535 * (*(_DWORD *)(v145 + v21) & 0xFFFFFFu)) >> 17)];
                  int v40 = *(_DWORD *)v39;
                  *(_WORD *)unsigned int v39 = v38;
                  *(_DWORD *)(v39 + 2) = v40;
                }
                unint64_t v21 = v38;
                --v37;
              }
              while (v37);
              int v18 = v34;
              unint64_t v17 = v36;
            }
            goto LABEL_41;
          }
          if (v27 == 3)
          {
            unint64_t v33 = v21 - v24;
            if (v33 < 0x100) {
              goto LABEL_34;
            }
          }
        }
        unint64_t v17 = v21 + 1;
LABEL_41:
        ++v20;
        unint64_t v21 = v17;
        if (v17 >= v15) {
          goto LABEL_44;
        }
      }
    }
    unsigned int v20 = 1;
    uint64_t v22 = v151;
LABEL_44:
    unint64_t v154 = v17;
    uint64_t v159 = a1 + v156;
    uint64_t v41 = v22 + v157;
    bzero(a5 + 167264, 0x400uLL);
    int v42 = 0;
    int v43 = 0;
    unsigned int v44 = 0;
    uint64_t v45 = 2176;
    do
    {
      if ((*(_DWORD *)&a5[4 * (v44 >> 5) + 152928] >> v44))
      {
        unsigned int v46 = &a5[4 * v43++];
        v46 += 65542;
        unsigned int v47 = *(unsigned __int16 *)v46;
        unsigned int v48 = *((unsigned __int16 *)v46 + 1);
        signed int v49 = 31 - __clz(v47);
        int v50 = v48 - 3;
        if (v48 - 3 >= 0xF) {
          int v50 = 15;
        }
        int v51 = (v50 | (16 * v49)) + 256;
        v42 += v48;
        uint64_t v52 = v45 + v49;
        ++*(_WORD *)&v12[2 * v51];
        if (v48 <= 0x110) {
          uint64_t v53 = 8;
        }
        else {
          uint64_t v53 = 24;
        }
        uint64_t v54 = v52 + v53;
        if (v48 >= 0x12) {
          uint64_t v45 = v54;
        }
        else {
          uint64_t v45 = v52;
        }
      }
      else
      {
        uint64_t v55 = *(unsigned __int8 *)(v41 + v42++);
        ++*(_WORD *)&v12[2 * v55];
      }
      ++v44;
    }
    while (v20 != v44);
    uint64_t v152 = v45;
    if (!v155[2816]) {
      v155[2816] = 1;
    }
    bzero(v153, 0x404uLL);
    uint64_t v56 = 0;
    int v57 = 0;
    do
    {
      unint64_t v58 = *(unsigned __int16 *)&v12[2 * v56];
      if (*(_WORD *)&v12[2 * v56])
      {
        ++v153[v58 + 1];
        ++*(unsigned __int16 *)((char *)v148 + ((v58 >> 7) & 0x1FE) + 2);
        *(_WORD *)&v8[2 * v57++] = v56;
      }
      ++v56;
    }
    while (v56 != 512);
    uint64_t v158 = v41;
    int v59 = *v153;
    int v60 = *v148;
    unsigned int v61 = (unsigned __int16 *)(a5 + 171364);
    uint64_t v62 = 255;
    do
    {
      v59 += *v61;
      *unsigned int v61 = v59;
      v60 += v61[257];
      v61[257] = v60;
      ++v61;
      --v62;
    }
    while (v62);
    uint64_t v63 = v57;
    if (v57 >= 1)
    {
      uint64_t v64 = (unsigned __int16 *)v8;
      uint64_t v65 = v57;
      do
      {
        int v66 = *v64++;
        uint64_t v67 = v12[2 * v66];
        uint64_t v68 = v153[v67];
        v153[v67] = v68 + 1;
        *(_WORD *)&v147[2 * v68] = v66;
        --v65;
      }
      while (v65);
      char v69 = (unsigned __int16 *)v147;
      uint64_t v70 = v57;
      do
      {
        int v71 = *v69++;
        unint64_t v72 = ((unint64_t)*(unsigned __int16 *)&v12[2 * v71] >> 7) & 0x1FE;
        uint64_t v73 = *(unsigned __int16 *)((char *)v148 + v72);
        *(unsigned __int16 *)((char *)v148 + v72) = v73 + 1;
        *(_WORD *)&v8[2 * v73] = v71;
        --v70;
      }
      while (v70);
    }
    memcpy(a5 + 165216, a5 + 167264, 0x400uLL);
    v155[2048] = -1;
    *(_WORD *)&v8[2 * v57] = 512;
    uint64_t v74 = (v57 + 511);
    uint64_t v75 = (int)v74;
    if ((int)v74 <= 513) {
      int v76 = 513;
    }
    else {
      int v76 = v57 + 511;
    }
    if (v57 > 1)
    {
      int v120 = 0;
      uint64_t v121 = (v76 + 1);
      unsigned int v122 = (char *)v14 + v74;
      uint64_t v123 = 513;
      int v124 = 513;
      int8x8_t v125 = &a5[4 * v74 + 161118];
      long long v77 = 0uLL;
      while (1)
      {
        do
        {
          *(_WORD *)&v13[2 * v123] = -1;
          int v126 = *(unsigned __int16 *)&v8[2 * v120];
          unsigned int v127 = *(unsigned __int16 *)&v13[2 * *(unsigned __int16 *)&v8[2 * v120]];
          unsigned int v128 = *(unsigned __int16 *)&v13[2 * v124];
          BOOL v129 = v127 > v128;
          if (v127 > v128)
          {
            int v130 = v124 + 1;
          }
          else
          {
            ++v120;
            int v130 = v124;
          }
          if (v129) {
            int v126 = v124;
          }
          int v131 = *(unsigned __int16 *)&v8[2 * v120];
          unsigned int v132 = *(unsigned __int16 *)&v13[2 * *(unsigned __int16 *)&v8[2 * v120]];
          unsigned int v133 = *(unsigned __int16 *)&v13[2 * v130];
          BOOL v134 = v132 > v133;
          if (v132 > v133)
          {
            int v135 = v130;
          }
          else
          {
            ++v120;
            int v135 = v131;
          }
          *(_WORD *)&v13[2 * v123] = *(_WORD *)&v13[2 * v135] + *(_WORD *)&v13[2 * v126];
          if (v134) {
            int v124 = v130 + 1;
          }
          else {
            int v124 = v130;
          }
          uint64_t v136 = &a5[4 * v123 + 161116];
          *(_WORD *)uint64_t v136 = v126;
          *((_WORD *)v136 + 1) = v135;
          ++v123;
        }
        while (v123 != v121);
        unsigned int v137 = 0;
        *((_OWORD *)a5 + 10548) = 0uLL;
        *((_OWORD *)a5 + 10549) = 0uLL;
        *((_OWORD *)a5 + 10546) = 0uLL;
        *((_OWORD *)a5 + 10547) = 0uLL;
        *((_OWORD *)a5 + 10544) = 0uLL;
        *((_OWORD *)a5 + 10545) = 0uLL;
        *((_OWORD *)a5 + 10542) = 0uLL;
        *((_OWORD *)a5 + 10543) = 0uLL;
        *((_OWORD *)a5 + 10540) = 0uLL;
        *((_OWORD *)a5 + 10541) = 0uLL;
        *((_OWORD *)a5 + 10538) = 0uLL;
        *((_OWORD *)a5 + 10539) = 0uLL;
        *((_OWORD *)a5 + 10536) = 0uLL;
        *((_OWORD *)a5 + 10537) = 0uLL;
        *((_OWORD *)a5 + 10534) = 0uLL;
        *((_OWORD *)a5 + 10535) = 0uLL;
        *((_OWORD *)a5 + 10532) = 0uLL;
        *((_OWORD *)a5 + 10533) = 0uLL;
        *((_OWORD *)a5 + 10530) = 0uLL;
        *((_OWORD *)a5 + 10531) = 0uLL;
        *((_OWORD *)a5 + 10528) = 0uLL;
        *((_OWORD *)a5 + 10529) = 0uLL;
        *((_OWORD *)a5 + 10526) = 0uLL;
        *((_OWORD *)a5 + 10527) = 0uLL;
        *((_OWORD *)a5 + 10524) = 0uLL;
        *((_OWORD *)a5 + 10525) = 0uLL;
        *((_OWORD *)a5 + 10522) = 0uLL;
        *((_OWORD *)a5 + 10523) = 0uLL;
        *((_OWORD *)a5 + 10520) = 0uLL;
        *((_OWORD *)a5 + 10521) = 0uLL;
        uint64_t v138 = v122;
        int v139 = v125;
        int v140 = v57 + 512;
        *unint64_t v14 = 0uLL;
        *((_OWORD *)a5 + 10519) = 0uLL;
        *((unsigned char *)v14 + v75) = 0;
        do
        {
          v137 |= 2 << *v138;
          *((unsigned char *)v14 + *((unsigned __int16 *)v139 - 1)) = *v138 + 1;
          char v141 = *v138--;
          char v142 = v141 + 1;
          unsigned int v143 = *(unsigned __int16 *)v139;
          v139 -= 4;
          *((unsigned char *)v14 + v143) = v142;
          --v140;
        }
        while (v140 > 513);
        if (v137 < 0x10000) {
          break;
        }
        for (uint64_t i = 0; i != 1024; i += 16)
          *(int16x8_t *)&v13[i] = vsubq_s16(*(int16x8_t *)&v13[i], (int16x8_t)vshrq_n_u16(*(uint16x8_t *)&v13[i], 1uLL));
        int v120 = 0;
        uint64_t v123 = 513;
        int v124 = 513;
      }
    }
    else
    {
      long long v77 = 0uLL;
      *((_OWORD *)a5 + 10548) = 0u;
      *((_OWORD *)a5 + 10549) = 0u;
      *((_OWORD *)a5 + 10546) = 0u;
      *((_OWORD *)a5 + 10547) = 0u;
      *((_OWORD *)a5 + 10544) = 0u;
      *((_OWORD *)a5 + 10545) = 0u;
      *((_OWORD *)a5 + 10542) = 0u;
      *((_OWORD *)a5 + 10543) = 0u;
      *((_OWORD *)a5 + 10540) = 0u;
      *((_OWORD *)a5 + 10541) = 0u;
      *((_OWORD *)a5 + 10538) = 0u;
      *((_OWORD *)a5 + 10539) = 0u;
      *((_OWORD *)a5 + 10536) = 0u;
      *((_OWORD *)a5 + 10537) = 0u;
      *((_OWORD *)a5 + 10534) = 0u;
      *((_OWORD *)a5 + 10535) = 0u;
      *((_OWORD *)a5 + 10532) = 0u;
      *((_OWORD *)a5 + 10533) = 0u;
      *((_OWORD *)a5 + 10530) = 0u;
      *((_OWORD *)a5 + 10531) = 0u;
      *((_OWORD *)a5 + 10528) = 0u;
      *((_OWORD *)a5 + 10529) = 0u;
      *((_OWORD *)a5 + 10526) = 0u;
      *((_OWORD *)a5 + 10527) = 0u;
      *((_OWORD *)a5 + 10524) = 0u;
      *((_OWORD *)a5 + 10525) = 0u;
      *((_OWORD *)a5 + 10522) = 0u;
      *((_OWORD *)a5 + 10523) = 0u;
      *((_OWORD *)a5 + 10520) = 0u;
      *((_OWORD *)a5 + 10521) = 0u;
      *unint64_t v14 = 0u;
      *((_OWORD *)a5 + 10519) = 0u;
      *((unsigned char *)v14 + (int)v74) = 0;
    }
    uint64_t v78 = 0;
    v162[0] = v77;
    v162[1] = v77;
    __int16 v161 = 0;
    v160[0] = v77;
    v160[1] = v77;
    do
    {
      uint64_t v79 = *((unsigned __int8 *)v14 + v78);
      *((_WORD *)v162 + v79) += *(_WORD *)&v12[2 * v78];
      ++*((_WORD *)v160 + v79 + 1);
      ++v78;
    }
    while (v78 != 512);
    uint64_t v80 = 0;
    int v81 = 0;
    uint64_t v82 = 0;
    WORD1(v160[0]) = 0;
    do
    {
      char v83 = (char *)v160 + 2 * v80;
      v82 += (v80 + 1) * *((unsigned __int16 *)v162 + v80 + 1);
      v81 += *((unsigned __int16 *)v83 + 2);
      *((_WORD *)v83 + 2) = v81;
      ++v80;
    }
    while (v80 != 15);
    uint64_t v84 = 0;
    LOWORD(v160[0]) = v161;
    do
    {
      uint64_t v85 = *((unsigned __int8 *)v14 + v84);
      uint64_t v86 = *((unsigned __int16 *)v160 + v85);
      *((_WORD *)v160 + v85) = v86 + 1;
      *(_WORD *)&a5[2 * v86 + 169312] = v84++;
    }
    while (v84 != 512);
    if (v57 >= 1)
    {
      LOWORD(v87) = 0;
      char v88 = (unsigned __int16 *)v8;
      do
      {
        int v89 = *v88++;
        __int16 v90 = a5[v89 + 168288];
        signed int v91 = &a5[4 * v89 + 161120];
        *(_WORD *)signed int v91 = (unsigned __int16)v87 >> (15 - v90);
        *((_WORD *)v91 + 1) = v90;
        int v87 = (1 << (15 - v90)) + (unsigned __int16)v87;
        --v63;
      }
      while (v63);
    }
    if (a2 - v156 < (unint64_t)(v82 + v152) >> 3) {
      break;
    }
    unint64_t v92 = 0;
    int v93 = (int8x16_t *)(a1 + v156);
    do
    {
      char v94 = (const char *)&v14[v92];
      int8x16x2_t v164 = vld2q_s8(v94);
      *v93++ = vorrq_s8(vshlq_n_s8(v164.val[1], 4uLL), v164.val[0]);
      BOOL v95 = v92 >= 30;
      v92 += 2;
    }
    while (!v95);
    int v96 = 0;
    unsigned int v97 = 0;
    uint64_t v98 = 0;
    unsigned int v99 = 0;
    int v100 = 16;
    uint64_t v101 = 260;
    uint64_t v102 = 258;
    uint64_t v103 = 256;
    do
    {
      if ((*(_DWORD *)&a5[4 * (v97 >> 5) + 152928] >> v97))
      {
        unsigned int v104 = *(unsigned __int16 *)&a5[4 * v96 + 65542];
        uint64_t v105 = *(unsigned __int16 *)&a5[4 * v96 + 65544];
        unsigned int v106 = __clz(v104);
        signed int v107 = 31 - v106;
        if ((v105 - 3) >= 0xF) {
          int v108 = 15;
        }
        else {
          int v108 = v105 - 3;
        }
        unint64_t v109 = &v146[4 * (v108 | (16 * v107)) + 1024];
        int v110 = *((unsigned __int16 *)v109 + 1);
        unsigned int v111 = *(unsigned __int16 *)v109;
        if (v110 <= v100)
        {
          v111 += v99 << v110;
        }
        else
        {
          int v112 = (v111 >> (v110 - v100)) + (v99 << v100);
          v100 += 16;
          *(_WORD *)(v159 + v103) = v112;
          uint64_t v103 = v102;
          uint64_t v102 = v101;
          v101 += 2;
        }
        if (v105 >= 0x12)
        {
          if (v105 > 0x110)
          {
            *(_DWORD *)(v159 + v101) = ((v105 - 3) << 8) | 0xFF;
            v101 += 3;
          }
          else
          {
            *(unsigned char *)(v159 + v101++) = v105 - 18;
          }
        }
        ++v96;
        uint64_t v113 = v98 + v105;
        signed int v117 = v100 - v110;
        unsigned int v99 = v104 - (0x80000000 >> v106);
        int v100 = v100 - v110 - v107;
        if (v117 >= v107)
        {
          v99 += (unsigned __int16)v111 << v107;
        }
        else
        {
          int v100 = v106 + v117 - 15;
          *(_WORD *)(v159 + v103) = ((_WORD)v111 << v117) + (v99 >> (v107 - v117));
          uint64_t v103 = v102;
          uint64_t v102 = v101;
          v101 += 2;
        }
      }
      else
      {
        uint64_t v113 = v98 + 1;
        unint64_t v114 = &v146[4 * *(unsigned __int8 *)(v158 + v98)];
        int v115 = *((unsigned __int16 *)v114 + 1);
        unsigned int v116 = *(unsigned __int16 *)v114;
        if (v100 >= v115)
        {
          unsigned int v99 = v116 + (v99 << v115);
          v100 -= v115;
        }
        else
        {
          *(_WORD *)(v159 + v103) = (v116 >> (v115 - v100)) + (v99 << v100);
          int v100 = v100 - v115 + 16;
          uint64_t v103 = v102;
          uint64_t v102 = v101;
          v101 += 2;
          unsigned int v99 = v116;
        }
      }
      ++v97;
      uint64_t v98 = v113;
    }
    while (v20 != v97);
    unint64_t v11 = v154;
    if (v154 == a4)
    {
      int v118 = v155[1];
      unsigned int v119 = *v155;
      if (v100 >= v118)
      {
        unsigned int v99 = v119 + (v99 << v118);
        LOBYTE(v100) = v100 - v118;
      }
      else
      {
        *(_WORD *)(v159 + v103) = (v119 >> (v118 - v100)) + (v99 << v100);
        LOBYTE(v100) = v100 - v118 + 16;
        uint64_t v103 = v102;
        uint64_t v102 = v101;
        v101 += 2;
        unsigned int v99 = v119;
      }
      unint64_t v11 = v154;
    }
    *(_WORD *)(v159 + v103) = v99 << v100;
    *(_WORD *)(v159 + v102) = 0;
    uint64_t result = v101 + v156;
  }
  while (v101);
  return 0;
}

uint16x8_t *convert_row_to_msb(uint16x8_t *result, unint64_t a2, char a3)
{
  if (a2 >= 8)
  {
    uint64_t v4 = 0;
    uint16x8_t v5 = (uint16x8_t)vdupq_n_s16(a3);
    unint64_t v6 = result;
    do
    {
      *unint64_t v6 = vshlq_u16(*v6, v5);
      ++v6;
      unint64_t v3 = v4 + 8;
      unint64_t v7 = v4 + 16;
      v4 += 8;
    }
    while (v7 <= a2);
  }
  else
  {
    unint64_t v3 = 0;
  }
  uint64_t v8 = a2 - v3;
  if (a2 > v3)
  {
    uint64_t v9 = &result->i16[v3];
    do
    {
      __int16 *v9 = (unsigned __int16)*v9 << a3;
      ++v9;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint16x8_t *convert_row_to_lsb(uint16x8_t *result, unint64_t a2, char a3)
{
  if (a2 >= 8)
  {
    uint64_t v4 = 0;
    uint16x8_t v5 = (uint16x8_t)vnegq_s16(vdupq_n_s16(a3));
    unint64_t v6 = result;
    do
    {
      *unint64_t v6 = vshlq_u16(*v6, v5);
      ++v6;
      unint64_t v3 = v4 + 8;
      unint64_t v7 = v4 + 16;
      v4 += 8;
    }
    while (v7 <= a2);
  }
  else
  {
    unint64_t v3 = 0;
  }
  uint64_t v8 = a2 - v3;
  if (a2 > v3)
  {
    uint64_t v9 = &result->i16[v3];
    do
    {
      __int16 *v9 = (unsigned __int16)*v9 >> a3;
      ++v9;
      --v8;
    }
    while (v8);
  }
  return result;
}

void *get_conversion_set(void *result, int a2, unsigned int a3, int a4)
{
  *uint64_t result = 0;
  result[1] = 0;
  switch(a2)
  {
    case 13:
      *uint64_t result = convert_row_RGB888toGUV;
      uint64_t v4 = convert_row_GUVtoRGB888;
      goto LABEL_17;
    case 14:
      *uint64_t result = convert_row_RGBA8888toGUVA;
      uint64_t v4 = convert_row_GUVAtoRGBA8888;
      goto LABEL_17;
    case 15:
      if (a3 > 8)
      {
        *uint64_t result = convert_rows_from_bayer16;
        uint64_t v4 = convert_rows_to_bayer16;
      }
      else
      {
        *uint64_t result = convert_rows_from_bayer8;
        uint64_t v4 = convert_rows_to_bayer8;
      }
      goto LABEL_17;
    case 16:
      if (a3 > 8) {
        return result;
      }
      *uint64_t result = convert_rows_from_quadra8;
      uint64_t v4 = convert_rows_to_quadra8;
      goto LABEL_17;
    default:
      if (a4 == 2)
      {
        if (a3 > 8)
        {
          *uint64_t result = convert_row_RGtoPlanarRG;
          uint64_t v4 = convert_row_PlanarRGtoRG;
        }
        else
        {
          *uint64_t result = convert_row_RG88toRG;
          uint64_t v4 = convert_row_RGtoRG88;
        }
      }
      else
      {
        if (a4 != 1) {
          return result;
        }
        if (a3 > 8)
        {
          uint64_t v4 = convert_row_copy16;
          *uint64_t result = convert_row_copy16;
        }
        else
        {
          *uint64_t result = convert_row_8to16;
          uint64_t v4 = convert_row_16to8;
        }
      }
LABEL_17:
      result[1] = v4;
      return result;
  }
}

uint64_t convert_rows_from_quadra8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2 * a4;
  uint64_t v6 = 3 * a4;
  unint64_t v7 = a3 >> 1;
  if (a3 >= 0x10)
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
    do
    {
      unint64_t v11 = (const __int16 *)(a2 + v10);
      int16x4x2_t v36 = vld2_s16(v11);
      long long v12 = (const __int16 *)(a2 + v5 + v10);
      int16x4x2_t v37 = vld2_s16(v12);
      int8x16_t v13 = (const __int16 *)(a2 + a4 + v10);
      int16x4x2_t v38 = vld2_s16(v13);
      unint64_t v14 = (const __int16 *)(a2 + v6 + v10);
      int16x4x2_t v39 = vld2_s16(v14);
      *(uint16x8_t *)(result + v10) = vmovl_u8((uint8x8_t)v36.val[0]);
      *(uint16x8_t *)(result + 2 * v7 + v10) = vmovl_u8((uint8x8_t)v36.val[1]);
      *(uint16x8_t *)(result + 2 * a3 + v10) = vmovl_u8((uint8x8_t)v37.val[0]);
      *(uint16x8_t *)(result + 6 * v7 + v10) = vmovl_u8((uint8x8_t)v37.val[1]);
      *(uint16x8_t *)(result + 2 * a5 + v10) = vmovl_u8((uint8x8_t)v38.val[0]);
      *(uint16x8_t *)(result + 2 * a5 + 2 * v7 + v10) = vmovl_u8((uint8x8_t)v38.val[1]);
      *(uint16x8_t *)(result + 2 * a5 + 2 * a3 + v10) = vmovl_u8((uint8x8_t)v39.val[0]);
      *(uint16x8_t *)(result + 6 * v7 + 2 * a5 + v10) = vmovl_u8((uint8x8_t)v39.val[1]);
      v9 += 8;
      uint64_t v8 = v10 + 16;
      unint64_t v15 = v10 + 32;
      v10 += 16;
    }
    while (v15 <= a3);
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  if ((v8 | 4uLL) <= a3)
  {
    uint64_t v16 = 0;
    uint64_t v17 = result + 2 * v9;
    uint64_t v18 = v8 + v5;
    uint64_t v19 = result + 2 * v9 + 2 * a5;
    uint64_t v20 = a2 + v18;
    uint64_t v21 = result + 6 * v7 + 2 * v9;
    uint64_t v22 = a2 + v8 + a4;
    uint64_t v23 = result + 2 * v9 + 2 * a3;
    uint64_t v24 = result + 2 * (v9 + a5 + v7);
    uint64_t v25 = 2 * v9 + 2 * v7 + result + 2;
    uint64_t v26 = a2 + v8 + v6;
    uint64_t v27 = v24 + 2;
    uint64_t v28 = result + 2 * (v9 + a5 + 3 * (a3 >> 1));
    uint64_t v29 = result + 2 * (v9 + a5 + a3);
    do
    {
      *(_WORD *)(v17 + v16) = *(unsigned __int8 *)(a2 + v8 + v16);
      *(_WORD *)(result + 2 * (v9 | 1)) = *(unsigned __int8 *)(a2 + ((v8 + v16) | 1));
      unsigned int v30 = (_WORD *)(v25 + v16);
      *(v30 - 1) = *(unsigned __int8 *)(a2 + ((v8 + v16) | 2));
      *unsigned int v30 = *(unsigned __int8 *)(a2 + ((v8 + v16) | 3));
      unint64_t v31 = (_WORD *)(v23 + v16);
      *unint64_t v31 = *(unsigned __int8 *)(v20 + v16);
      v31[1] = *(unsigned __int8 *)(a2 + ((v18 + v16) | 1));
      unsigned int v32 = (_WORD *)(v21 + v16);
      *unsigned int v32 = *(unsigned __int8 *)(v20 + v16 + 2);
      v32[1] = *(unsigned __int8 *)(v20 + v16 + 3);
      *(_WORD *)(v19 + v16) = *(unsigned __int8 *)(v22 + v16);
      *(_WORD *)(result + 2 * ((v9 | 1) + a5)) = *(unsigned __int8 *)(v22 + v16 + 1);
      unint64_t v33 = (_WORD *)(v27 + v16);
      *(v33 - 1) = *(unsigned __int8 *)(v22 + v16 + 2);
      _WORD *v33 = *(unsigned __int8 *)(v22 + v16 + 3);
      int v34 = (_WORD *)(v29 + v16);
      *int v34 = *(unsigned __int8 *)(v26 + v16);
      v34[1] = *(unsigned __int8 *)(v26 + v16 + 1);
      int v35 = (_WORD *)(v28 + v16);
      *int v35 = *(unsigned __int8 *)(v26 + v16 + 2);
      v35[1] = *(unsigned __int8 *)(v26 + v16 + 3);
      v9 += 2;
      v16 += 4;
    }
    while (v8 + v16 + 4 <= a3);
  }
  return result;
}

uint64_t convert_rows_to_quadra8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = a3 >> 1;
  uint64_t v6 = 2 * a4;
  uint64_t v7 = 3 * a4;
  if (a3 >= 0x10)
  {
    uint64_t v9 = 0;
    unint64_t v8 = (((a3 - 16) >> 1) & 0x7FFFFFFFFFFFFFF8) + 8;
    do
    {
      int16x8_t v10 = *(int16x8_t *)(a2 + v9);
      *(int8x8_t *)v10.i8 = vmovn_s16(v10);
      int16x8_t v11 = *(int16x8_t *)(a2 + 2 * v5 + v9);
      *(int8x8_t *)v11.i8 = vmovn_s16(v11);
      int16x8_t v12 = vzip1q_s16(v10, v11);
      int16x8_t v13 = *(int16x8_t *)(a2 + 2 * a3 + v9);
      *(int8x8_t *)v13.i8 = vmovn_s16(v13);
      int16x8_t v14 = *(int16x8_t *)(a2 + 6 * v5 + v9);
      *(int8x8_t *)v14.i8 = vmovn_s16(v14);
      int16x8_t v15 = vzip1q_s16(v13, v14);
      *(int8x8_t *)v14.i8 = vmovn_s16(*(int16x8_t *)(a2 + 2 * a5 + v9));
      int16x8_t v16 = *(int16x8_t *)(a2 + 2 * a5 + 2 * v5 + v9);
      *(int8x8_t *)v16.i8 = vmovn_s16(v16);
      int16x8_t v17 = vzip1q_s16(v14, v16);
      int16x8_t v18 = *(int16x8_t *)(a2 + 2 * a5 + 2 * a3 + v9);
      *(int8x8_t *)v18.i8 = vmovn_s16(v18);
      int16x8_t v19 = *(int16x8_t *)(a2 + 6 * v5 + 2 * a5 + v9);
      *(int8x8_t *)v19.i8 = vmovn_s16(v19);
      *(int16x8_t *)(result + v9) = v12;
      *(int16x8_t *)(result + v6 + v9) = v15;
      *(int16x8_t *)(result + a4 + v9) = v17;
      *(int16x8_t *)(result + v7 + v9) = vzip1q_s16(v18, v19);
      unint64_t v20 = v9 + 32;
      v9 += 16;
    }
    while (v20 <= a3);
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  if ((v9 | 4uLL) <= a3)
  {
    uint64_t v21 = 0;
    uint64_t v22 = a2 + 2 * v8;
    uint64_t v23 = v9 + v6;
    uint64_t v24 = a2 + 2 * v8 + 2 * a5;
    uint64_t v25 = a2 + 6 * v5 + 2 * v8;
    uint64_t v26 = result + v9 + a4;
    uint64_t v27 = a2 + 2 * v8 + 2 * a3;
    uint64_t v28 = a2 + 2 * (v8 + a5 + v5);
    uint64_t v29 = 2 * v8 + 2 * v5 + a2 + 2;
    uint64_t v30 = result + v9 + v7;
    uint64_t v31 = v28 + 2;
    uint64_t v32 = a2 + 2 * (v8 + a5 + 3 * (a3 >> 1));
    uint64_t v33 = a2 + 2 * (v8 + a5 + a3);
    do
    {
      *(unsigned char *)(result + v9 + v21) = *(unsigned char *)(v22 + v21);
      *(unsigned char *)(result + ((v9 + v21) | 1)) = *(_WORD *)(a2 + 2 * (v8 | 1));
      *(unsigned char *)(result + ((v9 + v21) | 2)) = *(unsigned char *)(v29 + v21 - 2);
      *(unsigned char *)(result + ((v9 + v21) | 3)) = *(unsigned char *)(v29 + v21);
      int v34 = (unsigned char *)(result + v23 + v21);
      *int v34 = *(unsigned char *)(v27 + v21);
      *(unsigned char *)(result + ((v23 + v21) | 1)) = *(unsigned char *)(v27 + v21 + 2);
      v34[2] = *(unsigned char *)(v25 + v21);
      v34[3] = *(unsigned char *)(v25 + v21 + 2);
      int v35 = (unsigned char *)(v26 + v21);
      *int v35 = *(unsigned char *)(v24 + v21);
      v35[1] = *(_WORD *)(a2 + 2 * ((v8 | 1) + a5));
      v35[2] = *(unsigned char *)(v31 + v21 - 2);
      v35[3] = *(unsigned char *)(v31 + v21);
      int16x4x2_t v36 = (unsigned char *)(v30 + v21);
      *int16x4x2_t v36 = *(unsigned char *)(v33 + v21);
      v36[1] = *(unsigned char *)(v33 + v21 + 2);
      v36[2] = *(unsigned char *)(v32 + v21);
      v36[3] = *(unsigned char *)(v32 + v21 + 2);
      v8 += 2;
      v21 += 4;
    }
    while (v9 + v21 + 4 <= a3);
  }
  return result;
}

uint64_t convert_rows_from_bayer8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v6 = a2 + a4;
  if (a3 >= 0x10)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    for (unint64_t i = 16; i <= a3; i += 16)
    {
      int16x8_t v11 = (const char *)(a2 + v9);
      int8x8x2_t v20 = vld2_s8(v11);
      int16x8_t v12 = (const char *)(v6 + v9);
      int8x8x2_t v21 = vld2_s8(v12);
      unint64_t v7 = i;
      uint64_t v13 = 2 * v8;
      *(uint16x8_t *)(result + v13) = vmovl_u8((uint8x8_t)v20.val[1]);
      *(uint16x8_t *)(result + 2 * v4 + v13) = vmovl_u8((uint8x8_t)v21.val[0]);
      *(uint16x8_t *)(result + 2 * v5 + v13) = vmovl_u8((uint8x8_t)v21.val[1]);
      *(uint16x8_t *)(result + 6 * v4 + v13) = vmovl_u8((uint8x8_t)v20.val[0]);
      v8 += 8;
      unint64_t v9 = v7;
    }
  }
  else
  {
    unint64_t v7 = 0;
    uint64_t v8 = 0;
  }
  if ((v7 | 2) <= a3)
  {
    uint64_t v14 = 0;
    uint64_t v15 = result + 6 * v4 + 2 * v8;
    uint64_t v16 = result + 2 * v8;
    uint64_t v17 = result + v5 + 2 * v8;
    uint64_t v18 = result + 4 * v4 + 2 * v8;
    do
    {
      *(_WORD *)(v15 + v14) = *(unsigned __int8 *)(a2 + v7 + v14);
      uint64_t v19 = (v7 + v14) | 1;
      *(_WORD *)(v16 + v14) = *(unsigned __int8 *)(a2 + v19);
      uint64_t result = *(unsigned __int8 *)(a2 + v7 + a4 + v14);
      *(_WORD *)(v17 + v14) = result;
      *(_WORD *)(v18 + v14) = *(unsigned __int8 *)(v6 + v19);
      v14 += 2;
    }
    while (v7 + v14 + 2 <= a3);
  }
  return result;
}

uint64_t convert_rows_to_bayer8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v6 = result + a4;
  if (a3 >= 0x10)
  {
    unint64_t v9 = 0;
    uint64_t v7 = 0;
    for (unint64_t i = 16; i <= a3; i += 16)
    {
      unint64_t v8 = i;
      int16x8_t v11 = *(int16x8_t *)(a2 + 2 * v7);
      int16x8_t v12 = *(int16x8_t *)(a2 + 2 * v4 + 2 * v7);
      *(int8x8_t *)v11.i8 = vmovn_s16(v11);
      *(int8x8_t *)v12.i8 = vmovn_s16(v12);
      int16x8_t v13 = *(int16x8_t *)(a2 + 2 * v5 + 2 * v7);
      int16x8_t v14 = *(int16x8_t *)(a2 + 6 * v4 + 2 * v7);
      *(int8x8_t *)v13.i8 = vmovn_s16(v13);
      *(int8x8_t *)v14.i8 = vmovn_s16(v14);
      *(int8x16_t *)(result + v9) = vzip1q_s8((int8x16_t)v14, (int8x16_t)v11);
      *(int8x16_t *)(v6 + v9) = vzip1q_s8((int8x16_t)v12, (int8x16_t)v13);
      v7 += 8;
      unint64_t v9 = v8;
    }
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
  }
  if ((v8 | 2) <= a3)
  {
    uint64_t v15 = 0;
    uint64_t v16 = a2 + 6 * v4 + 2 * v7;
    uint64_t v17 = a2 + 2 * v7;
    uint64_t v18 = a2 + v5 + 2 * v7;
    uint64_t v19 = a2 + 4 * v4 + 2 * v7;
    do
    {
      *(unsigned char *)(result + v8 + v15) = *(unsigned char *)(v16 + v15);
      uint64_t v20 = (v8 + v15) | 1;
      *(unsigned char *)(result + v20) = *(unsigned char *)(v17 + v15);
      *(unsigned char *)(result + v8 + a4 + v15) = *(unsigned char *)(v18 + v15);
      *(unsigned char *)(v6 + v20) = *(unsigned char *)(v19 + v15);
      v15 += 2;
    }
    while (v8 + v15 + 2 <= a3);
  }
  return result;
}

uint64_t convert_rows_from_bayer16(uint64_t result, const __int16 *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v6 = a4 >> 1;
  uint64_t v7 = 0;
  if (a3 >= 0x10)
  {
    unint64_t v8 = (((a3 - 16) >> 1) & 0x7FFFFFFFFFFFFFF8) + 8;
    unint64_t v9 = a2;
    do
    {
      int16x8_t v10 = &v9[v6];
      int16x8x2_t v21 = vld2q_s16(v9);
      v9 += 16;
      int16x8x2_t v22 = vld2q_s16(v10);
      *(int16x8_t *)(result + v7) = v21.val[1];
      *(int16x8_t *)(result + v5 + v7) = v22.val[0];
      *(int16x8_t *)(result + 4 * v4 + v7) = v22.val[1];
      *(int16x8_t *)(result + 6 * v4 + v7) = v21.val[0];
      unint64_t v11 = v7 + 32;
      v7 += 16;
    }
    while (v11 <= a3);
  }
  else
  {
    unint64_t v8 = 0;
  }
  if ((v7 | 2uLL) <= a3)
  {
    uint64_t v12 = 0;
    int16x8_t v13 = &a2[v6];
    int16x8_t v14 = &a2[v7 + v6];
    uint64_t v15 = result + 6 * v4 + 2 * v8;
    uint64_t v16 = 4 * v4 + 2 * v8;
    uint64_t v17 = result + 2 * v8;
    uint64_t v18 = result + v5 + 2 * v8;
    uint64_t v19 = result + v16;
    do
    {
      *(_WORD *)(v15 + v12) = a2[v7 + v12];
      uint64_t v20 = (2 * (v7 + v12)) | 2;
      *(_WORD *)(v17 + v12) = *(const __int16 *)((char *)a2 + v20);
      uint64_t result = (unsigned __int16)v14[v12];
      *(_WORD *)(v18 + v12) = result;
      *(_WORD *)(v19 + v12) = *(const __int16 *)((char *)v13 + v20);
      v12 += 2;
    }
    while (v7 + v12 + 2 <= a3);
  }
  return result;
}

int16x8_t *convert_rows_to_bayer16(int16x8_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3 >> 1;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v6 = a4 >> 1;
  if (a3 >= 0x10)
  {
    unint64_t v8 = 0;
    unint64_t v7 = (((a3 - 16) >> 1) & 0x7FFFFFFFFFFFFFF8) + 8;
    unint64_t v9 = result;
    do
    {
      int16x8_t v10 = *(int16x8_t *)(a2 + v8);
      int16x8_t v11 = *(int16x8_t *)(a2 + v5 + v8);
      int16x8_t v12 = *(int16x8_t *)(a2 + 4 * v4 + v8);
      int16x8_t v13 = *(int16x8_t *)(a2 + 6 * v4 + v8);
      int16x8_t *v9 = vzip1q_s16(v13, v10);
      v9[1] = vzip2q_s16(v13, v10);
      int16x8_t v14 = (int16x8_t *)((char *)v9 + 2 * v6);
      *int16x8_t v14 = vzip1q_s16(v11, v12);
      v14[1] = vzip2q_s16(v11, v12);
      unint64_t v15 = v8 + 32;
      v8 += 16;
      v9 += 2;
    }
    while (v15 <= a3);
  }
  else
  {
    unint64_t v7 = 0;
    unint64_t v8 = 0;
  }
  if ((v8 | 2) <= a3)
  {
    uint64_t v16 = 0;
    uint64_t v17 = &result->i8[2 * v6];
    uint64_t v18 = &result[v8 / 8].i8[2 * v6];
    uint64_t v19 = a2 + 6 * v4 + 2 * v7;
    uint64_t v20 = 4 * v4 + 2 * v7;
    uint64_t v21 = a2 + 2 * v7;
    uint64_t v22 = a2 + v5 + 2 * v7;
    uint64_t v23 = a2 + v20;
    do
    {
      result[v8 / 8].i16[v16] = *(_WORD *)(v19 + v16);
      uint64_t v24 = (2 * (v8 + v16)) | 2;
      *(__int16 *)((char *)result->i16 + v24) = *(_WORD *)(v21 + v16);
      *(_WORD *)&v18[2 * v16] = *(_WORD *)(v22 + v16);
      *(_WORD *)&v17[v24] = *(_WORD *)(v23 + v16);
      v16 += 2;
    }
    while (v8 + v16 + 2 <= a3);
  }
  return result;
}

__n128 *convert_row_RGB888toGUV(__n128 *result, uint64_t a2, unint64_t a3, double a4, __n128 a5, double a6, double a7, double a8, __n128 a9)
{
  unint64_t v9 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v12 = 0;
    uint64_t v10 = 0;
    a5.n128_u64[1] = -1;
    v13.i64[0] = 0x80008000800080;
    v13.i64[1] = 0x80008000800080;
    int16x8_t v14 = result;
    do
    {
      long long v15 = *(_OWORD *)(a2 + v10);
      a9.n128_u64[0] = *(void *)(a2 + v10 + 16);
      long long v16 = v15;
      int8x16_t v17 = vqtbl2q_s8(*(int8x16x2_t *)(&a9 - 1), (int8x16_t)xmmword_20DAD6290);
      int8x8_t v18 = (int8x8_t)vextq_s8(v17, v17, 8uLL).u64[0];
      *(void *)&long long v15 = vqtbl2q_s8(*(int8x16x2_t *)a9.n128_u64, (int8x16_t)xmmword_20DAD62A0).u64[0];
      *(uint16x8_t *)((char *)v14 + 2 * a3) = vmovl_u8((uint8x8_t)veor_s8(vsub_s8(*(int8x8_t *)v17.i8, v18), (int8x8_t)0x8080808080808080));
      a9 = (__n128)vmovl_high_u8((uint8x16_t)v17);
      *(__n128 *)((char *)v14 + 4 * a3) = (__n128)(*(_OWORD *)&vaddq_s16((int16x8_t)vsubl_u8(*(uint8x8_t *)&v15, vhadd_u8(*(uint8x8_t *)v17.i8, (uint8x8_t)v18)), v13) & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL));
      *v14++ = a9;
      v10 += 24;
      unint64_t v11 = v12 + 8;
      unint64_t v19 = v12 + 16;
      v12 += 8;
    }
    while (v19 <= a3);
  }
  else
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
  }
  uint64_t v20 = a3 - v11;
  if (a3 > v11)
  {
    if (a3 <= 7)
    {
      uint64_t v28 = (_WORD *)result + v11;
      uint64_t v29 = (unsigned __int8 *)(v10 + a2 + 1);
      do
      {
        int v30 = *(v29 - 1);
        int v31 = *v29;
        unsigned __int8 v32 = v29[1];
        *uint64_t v28 = v31;
        v28[a3] = (v30 - v31 + 0x80);
        v28[2 * a3] = (v32 - ((v31 + v30) >> 1) + 0x80);
        ++v28;
        v29 += 3;
        --v20;
      }
      while (v20);
    }
    else
    {
      uint64_t v21 = (long long *)(a2 + 3 * v9);
      uint64_t v22 = 2 * v9;
      long long v23 = *v21;
      a5.n128_u64[0] = *((void *)v21 + 2);
      long long v24 = *v21;
      int16x8_t v25 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&a5 - 1), (int8x16_t)xmmword_20DAD6290);
      int8x8_t v26 = (int8x8_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL).u64[0];
      *(void *)&long long v23 = vqtbl2q_s8(*(int8x16x2_t *)a5.n128_u64, (int8x16_t)xmmword_20DAD62A0).u64[0];
      *(uint16x8_t *)((char *)result + 2 * a3 + v22) = vmovl_u8((uint8x8_t)veor_s8(vsub_s8(*(int8x8_t *)v25.i8, v26), (int8x8_t)0x8080808080808080));
      uint16x8_t v27 = vmovl_high_u8((uint8x16_t)v25);
      *(uint8x8_t *)&long long v24 = vhadd_u8(*(uint8x8_t *)v25.i8, (uint8x8_t)v26);
      v25.i64[0] = 0x80008000800080;
      v25.i64[1] = 0x80008000800080;
      *(__n128 *)((char *)result + 4 * a3 + v22) = (__n128)(*(_OWORD *)&vaddq_s16((int16x8_t)vsubl_u8(*(uint8x8_t *)&v23, *(uint8x8_t *)&v24), v25) & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL));
      *(uint16x8_t *)((char *)result + v22) = v27;
    }
  }
  return result;
}

uint64_t convert_row_GUVtoRGB888(uint64_t result, int16x8_t *a2, unint64_t a3)
{
  unint64_t v4 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    unint64_t v8 = a2;
    do
    {
      *(int8x8_t *)v9.i8 = vmovn_s16(*v8);
      int8x8_t v10 = veor_s8(vadd_s8(vmovn_s16(*(int16x8_t *)((char *)v8 + 2 * a3)), *(int8x8_t *)v9.i8), (int8x8_t)0x8080808080808080);
      uint64_t v11 = result + v6;
      *(int8x8_t *)&long long v3 = veor_s8(vadd_s8((int8x8_t)vhadd_u8(*(uint8x8_t *)v9.i8, (uint8x8_t)v10), vmovn_s16(*(int16x8_t *)((char *)v8 + 4 * a3))), (int8x8_t)0x8080808080808080);
      int8x16_t v12 = vmovn_hight_s16(v10, *v8);
      v9.i64[1] = v3;
      *(int8x16_t *)uint64_t v11 = vqtbl2q_s8(*(int8x16x2_t *)&v3, (int8x16_t)xmmword_20DAD62B0);
      *(int8x8_t *)v13.i8 = vqtbl1_s8(v9, (int8x8_t)0xF07FF0E06FF0D05);
      v13.u64[1] = (unint64_t)v10;
      *(int8x8_t *)(v11 + 16) = vqtbl1_s8(v13, (int8x8_t)0x7060F04030E0100);
      v6 += 24;
      unint64_t v5 = v7 + 8;
      ++v8;
      unint64_t v14 = v7 + 16;
      v7 += 8;
    }
    while (v14 <= a3);
  }
  else
  {
    unint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  uint64_t v15 = a3 - v5;
  if (a3 > v5)
  {
    if (a3 <= 7)
    {
      uint64_t v21 = &a2->i16[v5];
      uint64_t v22 = (unsigned char *)(v6 + result + 1);
      do
      {
        __int16 v23 = *v21;
        __int16 v24 = v21[2 * a3];
        int v25 = *v21;
        __int16 v26 = (v21[a3] + *v21) ^ 0xFF80;
        *(v22 - 1) = (v21[a3] + *v21) ^ 0x80;
        unsigned char *v22 = v23;
        v22[1] = (v24 + ((v25 + v26) >> 1)) ^ 0x80;
        ++v21;
        v22 += 3;
        --v15;
      }
      while (v15);
    }
    else
    {
      uint64_t v16 = result + 3 * v4;
      uint64_t v17 = 2 * v4;
      int16x8_t v18 = *(int16x8_t *)((char *)a2 + v17);
      *(int8x8_t *)v19.i8 = vmovn_s16(v18);
      v27.val[0] = *(int8x16_t *)((char *)a2 + 4 * a3 + v17);
      int8x8_t v20 = veor_s8(vadd_s8(vmovn_s16(*(int16x8_t *)((char *)a2 + 2 * a3 + v17)), *(int8x8_t *)v19.i8), (int8x8_t)0x8080808080808080);
      *(int8x8_t *)v27.val[0].i8 = veor_s8(vadd_s8((int8x8_t)vhadd_u8(*(uint8x8_t *)v19.i8, (uint8x8_t)v20), vmovn_s16((int16x8_t)v27.val[0])), (int8x8_t)0x8080808080808080);
      v27.val[1] = vmovn_hight_s16(v20, v18);
      *(int8x16_t *)uint64_t v16 = vqtbl2q_s8(v27, (int8x16_t)xmmword_20DAD62B0);
      v19.i64[1] = v27.val[0].i64[0];
      *(int8x8_t *)v18.i8 = vqtbl1_s8(v19, (int8x8_t)0xF07FF0E06FF0D05);
      v18.u64[1] = (unint64_t)v20;
      *(int8x8_t *)(v16 + 16) = vqtbl1_s8((int8x16_t)v18, (int8x8_t)0x7060F04030E0100);
    }
  }
  return result;
}

uint16x8_t *convert_row_RGBA8888toGUVA(uint16x8_t *result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v6 = 0;
    uint64_t v4 = 0;
    v7.i64[0] = 0x80008000800080;
    v7.i64[1] = 0x80008000800080;
    unint64_t v8 = result;
    do
    {
      int8x16_t v9 = (const char *)(a2 + v4);
      int8x16x2_t v31 = vld2q_s8(v9);
      int8x8_t v10 = (int8x8_t)vextq_s8(v31.val[0], v31.val[0], 8uLL).u64[0];
      int8x8_t v11 = vuzp1_s8(*(int8x8_t *)v31.val[0].i8, v10);
      int8x8_t v12 = (int8x8_t)vextq_s8(v31.val[1], v31.val[1], 8uLL).u64[0];
      int8x8_t v13 = vuzp1_s8(*(int8x8_t *)v31.val[1].i8, v12);
      *(uint16x8_t *)((char *)v8 + 2 * a3) = vmovl_u8((uint8x8_t)veor_s8(vsub_s8(v11, v13), (int8x8_t)0x8080808080808080));
      *(uint16x8_t *)((char *)v8 + 4 * a3) = (uint16x8_t)(*(_OWORD *)&vaddq_s16((int16x8_t)vsubl_u8((uint8x8_t)vuzp2_s8(*(int8x8_t *)v31.val[0].i8, v10), vhadd_u8((uint8x8_t)v11, (uint8x8_t)v13)), v7) & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL));
      *unint64_t v8 = vmovl_u8((uint8x8_t)v13);
      *(uint16x8_t *)((char *)v8 + 6 * a3) = vmovl_u8((uint8x8_t)vuzp2_s8(*(int8x8_t *)v31.val[1].i8, v12));
      v4 += 32;
      unint64_t v5 = v6 + 8;
      ++v8;
      unint64_t v14 = v6 + 16;
      v6 += 8;
    }
    while (v14 <= a3);
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
  }
  uint64_t v15 = a3 - v5;
  if (a3 > v5)
  {
    if (a3 <= 7)
    {
      int v25 = &result->i16[v5];
      __int16 v26 = (unsigned __int8 *)(v4 + a2 + 1);
      do
      {
        int v27 = *(v26 - 1);
        int v28 = *v26;
        unsigned __int8 v29 = v26[1];
        *int v25 = v28;
        v25[a3] = (v27 - v28 + 0x80);
        v25[2 * a3] = (v29 - ((v28 + v27) >> 1) + 0x80);
        v25[3 * a3] = v26[2];
        ++v25;
        v26 += 4;
        --v15;
      }
      while (v15);
    }
    else
    {
      uint64_t v16 = (const char *)(a2 + 4 * v3);
      uint64_t v17 = 2 * v3;
      int8x16x2_t v30 = vld2q_s8(v16);
      int8x8_t v18 = (int8x8_t)vextq_s8(v30.val[0], v30.val[0], 8uLL).u64[0];
      int8x8_t v19 = vuzp1_s8(*(int8x8_t *)v30.val[0].i8, v18);
      int8x8_t v20 = (int8x8_t)vextq_s8(v30.val[1], v30.val[1], 8uLL).u64[0];
      int8x8_t v21 = vuzp1_s8(*(int8x8_t *)v30.val[1].i8, v20);
      *(uint16x8_t *)((char *)result + 2 * a3 + v17) = vmovl_u8((uint8x8_t)veor_s8(vsub_s8(v19, v21), (int8x8_t)0x8080808080808080));
      uint16x8_t v22 = vmovl_u8((uint8x8_t)v21);
      uint8x8_t v23 = vhadd_u8((uint8x8_t)v19, (uint8x8_t)v21);
      v24.i64[0] = 0x80008000800080;
      v24.i64[1] = 0x80008000800080;
      *(uint16x8_t *)((char *)result + 4 * a3 + v17) = (uint16x8_t)(*(_OWORD *)&vaddq_s16((int16x8_t)vsubl_u8((uint8x8_t)vuzp2_s8(*(int8x8_t *)v30.val[0].i8, v18), v23), v24) & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL));
      *(uint16x8_t *)((char *)result + v17) = v22;
      *(uint16x8_t *)((char *)result + 6 * a3 + v17) = vmovl_u8((uint8x8_t)vuzp2_s8(*(int8x8_t *)v30.val[1].i8, v20));
    }
  }
  return result;
}

uint64_t convert_row_GUVAtoRGBA8888(uint64_t result, int16x8_t *a2, unint64_t a3)
{
  unint64_t v3 = a3 - 8;
  if (a3 >= 8)
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    int16x8_t v7 = a2;
    do
    {
      unint64_t v8 = (int8x16_t *)(result + v5);
      int8x8_t v9 = vmovn_s16(*v7);
      int8x8_t v10 = vmovn_s16(*(int16x8_t *)((char *)v7 + 6 * a3));
      int8x8_t v11 = veor_s8(vadd_s8(vmovn_s16(*(int16x8_t *)((char *)v7 + 2 * a3)), v9), (int8x8_t)0x8080808080808080);
      int8x8_t v12 = veor_s8(vadd_s8((int8x8_t)vhadd_u8((uint8x8_t)v9, (uint8x8_t)v11), vmovn_s16(*(int16x8_t *)((char *)v7 + 4 * a3))), (int8x8_t)0x8080808080808080);
      *(int8x8_t *)v13.i8 = vzip2_s8(v11, v12);
      *(int8x8_t *)v14.i8 = vzip1_s8(v11, v12);
      v14.u64[1] = (unint64_t)vzip1_s8(v9, v10);
      v13.u64[1] = (unint64_t)vzip2_s8(v9, v10);
      *unint64_t v8 = vqtbl1q_s8(v14, (int8x16_t)xmmword_20DAD62C0);
      v8[1] = vqtbl1q_s8(v13, (int8x16_t)xmmword_20DAD62C0);
      v5 += 32;
      unint64_t v4 = v6 + 8;
      ++v7;
      unint64_t v15 = v6 + 16;
      v6 += 8;
    }
    while (v15 <= a3);
  }
  else
  {
    unint64_t v4 = 0;
    uint64_t v5 = 0;
  }
  uint64_t v16 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      int v25 = &a2->i16[v4];
      __int16 v26 = (unsigned char *)(v5 + result + 1);
      do
      {
        __int16 v27 = *v25;
        __int16 v28 = v25[2 * a3];
        int v29 = *v25;
        unsigned __int8 v30 = (v25[a3] + *v25) ^ 0x80;
        *(v26 - 1) = v30;
        unsigned char *v26 = v27;
        v26[1] = (v28 + ((v29 + v30) >> 1)) ^ 0x80;
        v26[2] = v25[3 * a3];
        ++v25;
        v26 += 4;
        --v16;
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = (int8x16_t *)(result + 4 * v3);
      uint64_t v18 = 2 * v3;
      int8x8_t v19 = vmovn_s16(*(int16x8_t *)((char *)a2 + v18));
      int8x8_t v20 = vmovn_s16(*(int16x8_t *)((char *)a2 + 6 * a3 + v18));
      int8x8_t v21 = veor_s8(vadd_s8(vmovn_s16(*(int16x8_t *)((char *)a2 + 2 * a3 + v18)), v19), (int8x8_t)0x8080808080808080);
      int8x8_t v22 = veor_s8(vadd_s8((int8x8_t)vhadd_u8((uint8x8_t)v19, (uint8x8_t)v21), vmovn_s16(*(int16x8_t *)((char *)a2 + 4 * a3 + v18))), (int8x8_t)0x8080808080808080);
      *(int8x8_t *)v23.i8 = vzip2_s8(v21, v22);
      *(int8x8_t *)v24.i8 = vzip1_s8(v21, v22);
      v24.u64[1] = (unint64_t)vzip1_s8(v19, v20);
      v23.u64[1] = (unint64_t)vzip2_s8(v19, v20);
      int8x16_t *v17 = vqtbl1q_s8(v24, (int8x16_t)xmmword_20DAD62C0);
      v17[1] = vqtbl1q_s8(v23, (int8x16_t)xmmword_20DAD62C0);
    }
  }
  return result;
}

uint16x8_t *convert_row_8to16(uint16x8_t *result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    uint64_t v4 = 0;
    uint64_t v5 = result;
    do
    {
      *v5++ = vmovl_u8(*(uint8x8_t *)(a2 + v4));
      unint64_t v3 = v4 + 8;
      unint64_t v6 = v4 + 16;
      v4 += 8;
    }
    while (v6 <= a3);
  }
  else
  {
    unint64_t v3 = 0;
  }
  uint64_t v7 = a3 - v3;
  if (a3 > v3)
  {
    if (a3 <= 7)
    {
      unint64_t v8 = &result->i16[v3];
      int8x8_t v9 = (unsigned __int8 *)(a2 + v3);
      do
      {
        __int16 v10 = *v9++;
        *v8++ = v10;
        --v7;
      }
      while (v7);
    }
    else
    {
      *(uint16x8_t *)((char *)result + 2 * a3 - 16) = vmovl_u8(*(uint8x8_t *)(a2 + a3 - 8));
    }
  }
  return result;
}

uint64_t convert_row_16to8(uint64_t result, int16x8_t *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    uint64_t v4 = 0;
    uint64_t v5 = a2;
    do
    {
      int16x8_t v6 = *v5++;
      *(int8x8_t *)(result + v4) = vmovn_s16(v6);
      unint64_t v3 = v4 + 8;
      unint64_t v7 = v4 + 16;
      v4 += 8;
    }
    while (v7 <= a3);
  }
  else
  {
    unint64_t v3 = 0;
  }
  uint64_t v8 = a3 - v3;
  if (a3 > v3)
  {
    if (a3 <= 7)
    {
      int8x8_t v9 = (unsigned char *)(result + v3);
      __int16 v10 = &a2->i8[2 * v3];
      do
      {
        char v11 = *v10;
        v10 += 2;
        *v9++ = v11;
        --v8;
      }
      while (v8);
    }
    else
    {
      *(int8x8_t *)(result + a3 - 8) = vmovn_s16(*(int16x8_t *)((char *)a2 + 2 * a3 - 16));
    }
  }
  return result;
}

void *convert_row_copy16(void *a1, const void *a2, uint64_t a3)
{
  return memcpy(a1, a2, 2 * a3);
}

uint64_t convert_row_RG88toRG(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = result + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0;
    uint64_t v4 = 0;
    do
    {
      unint64_t v7 = (const char *)(a2 + v4);
      int8x8x2_t v13 = vld2_s8(v7);
      *(uint16x8_t *)(result + v4) = vmovl_u8((uint8x8_t)v13.val[0]);
      *(uint16x8_t *)(v3 + v4) = vmovl_u8((uint8x8_t)v13.val[1]);
      v4 += 16;
      unint64_t v5 = v6 + 8;
      unint64_t v8 = v6 + 16;
      v6 += 8;
    }
    while (v8 <= a3);
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
  }
  uint64_t v9 = a3 - v5;
  if (a3 > v5)
  {
    if (a3 <= 7)
    {
      int8x8_t v12 = (_WORD *)(result + 2 * v5);
      do
      {
        *int8x8_t v12 = *(unsigned __int8 *)(a2 + v4);
        v12[a3] = *(unsigned __int8 *)(a2 + (v4 | 1));
        v4 += 2;
        ++v12;
        --v9;
      }
      while (v9);
    }
    else
    {
      uint64_t v10 = 2 * a3 - 16;
      char v11 = (const char *)(a2 + v10);
      int8x8x2_t v14 = vld2_s8(v11);
      *(uint16x8_t *)(result + v10) = vmovl_u8((uint8x8_t)v14.val[0]);
      *(uint16x8_t *)(v3 + v10) = vmovl_u8((uint8x8_t)v14.val[1]);
    }
  }
  return result;
}

uint64_t convert_row_RGtoRG88(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = a2 + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    do
    {
      int16x8_t v7 = *(int16x8_t *)(a2 + v5);
      *(int8x8_t *)v7.i8 = vmovn_s16(v7);
      int16x8_t v8 = *(int16x8_t *)(v3 + v5);
      *(int8x8_t *)v8.i8 = vmovn_s16(v8);
      *(int8x16_t *)(result + v5) = vzip1q_s8((int8x16_t)v7, (int8x16_t)v8);
      v5 += 16;
      unint64_t v4 = v6 + 8;
      unint64_t v9 = v6 + 16;
      v6 += 8;
    }
    while (v9 <= a3);
  }
  else
  {
    unint64_t v4 = 0;
    uint64_t v5 = 0;
  }
  uint64_t v10 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      int8x8x2_t v14 = (unsigned char *)(a2 + 2 * v4);
      do
      {
        *(unsigned char *)(result + v5) = *v14;
        *(unsigned char *)(result + (v5 | 1)) = v14[2 * a3];
        v5 += 2;
        v14 += 2;
        --v10;
      }
      while (v10);
    }
    else
    {
      uint64_t v11 = 2 * a3 - 16;
      int16x8_t v12 = *(int16x8_t *)(a2 + v11);
      *(int8x8_t *)v12.i8 = vmovn_s16(v12);
      int16x8_t v13 = *(int16x8_t *)(v3 + v11);
      *(int8x8_t *)v13.i8 = vmovn_s16(v13);
      *(int8x16_t *)(result + 2 * a3 - 16) = vzip1q_s8((int8x16_t)v12, (int8x16_t)v13);
    }
  }
  return result;
}

uint64_t convert_row_RGtoPlanarRG(uint64_t result, const __int16 *a2, unint64_t a3)
{
  uint64_t v3 = result + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0;
    uint64_t v4 = 0;
    int16x8_t v7 = a2;
    do
    {
      int16x8x2_t v13 = vld2q_s16(v7);
      v7 += 16;
      *(int16x8_t *)(result + v4) = v13.val[0];
      *(int16x8_t *)(v3 + v4) = v13.val[1];
      v4 += 16;
      unint64_t v5 = v6 + 8;
      unint64_t v8 = v6 + 16;
      v6 += 8;
    }
    while (v8 <= a3);
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
  }
  uint64_t v9 = a3 - v5;
  if (a3 > v5)
  {
    if (a3 <= 7)
    {
      int16x8_t v12 = (_WORD *)(result + 2 * v5);
      do
      {
        *int16x8_t v12 = a2[v4];
        v12[a3] = *(const __int16 *)((char *)a2 + ((2 * v4) | 2));
        v4 += 2;
        ++v12;
        --v9;
      }
      while (v9);
    }
    else
    {
      uint64_t v10 = 2 * a3 - 16;
      uint64_t v11 = &a2[v10];
      int16x8x2_t v14 = vld2q_s16(v11);
      *(int16x8_t *)(result + v10) = v14.val[0];
      *(int16x8_t *)(v3 + v10) = v14.val[1];
    }
  }
  return result;
}

int16x8_t *convert_row_PlanarRGtoRG(int16x8_t *result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = a2 + 2 * a3;
  if (a3 >= 8)
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    int16x8_t v7 = result;
    do
    {
      int16x8_t v8 = *(int16x8_t *)(a2 + v5);
      int16x8_t v9 = *(int16x8_t *)(v3 + v5);
      *int16x8_t v7 = vzip1q_s16(v8, v9);
      v7[1] = vzip2q_s16(v8, v9);
      v7 += 2;
      v5 += 16;
      unint64_t v4 = v6 + 8;
      unint64_t v10 = v6 + 16;
      v6 += 8;
    }
    while (v10 <= a3);
  }
  else
  {
    unint64_t v4 = 0;
    uint64_t v5 = 0;
  }
  uint64_t v11 = a3 - v4;
  if (a3 > v4)
  {
    if (a3 <= 7)
    {
      uint64_t v16 = (__int16 *)(a2 + 2 * v4);
      do
      {
        result->i16[v5] = *v16;
        *(__int16 *)((char *)result->i16 + ((2 * v5) | 2)) = v16[a3];
        v5 += 2;
        ++v16;
        --v11;
      }
      while (v11);
    }
    else
    {
      uint64_t v12 = 2 * a3 - 16;
      int16x8_t v13 = *(int16x8_t *)(a2 + v12);
      int16x8_t v14 = *(int16x8_t *)(v3 + v12);
      unint64_t v15 = (int16x8_t *)((char *)result + 4 * a3);
      v15[-2] = vzip1q_s16(v13, v14);
      v15[-1] = vzip2q_s16(v13, v14);
    }
  }
  return result;
}

void BrotliCompareAndPushToQueueLiteral(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unint64_t a5, uint64_t a6, unint64_t *a7)
{
  if (a3 != a4)
  {
    v40[130] = v12;
    v40[131] = v11;
    v40[132] = v10;
    v40[133] = v9;
    v40[144] = v7;
    v40[145] = v8;
    unsigned int v17 = a4 >= a3 ? a3 : a4;
    uint64_t v18 = *(unsigned int *)(a2 + 4 * v17);
    unsigned int v19 = a4 <= a3 ? a3 : a4;
    uint64_t v20 = *(unsigned int *)(a2 + 4 * v19);
    double v21 = (double)v18;
    double v22 = v18 > 0xFF ? log2((double)v18) : kBrotliLog2Table[v18];
    unint64_t v23 = v20 + v18;
    double v24 = v20 > 0xFF ? log2((double)v20) : kBrotliLog2Table[v20];
    double v25 = v24 * (double)v20 + v21 * v22;
    double v26 = v23 > 0xFF ? log2((double)v23) : kBrotliLog2Table[v23];
    uint64_t v27 = a1 + 1040 * v17;
    double v28 = (v25 - (double)v23 * v26) * 0.5 - *(double *)(v27 + 1032);
    uint64_t v29 = a1 + 1040 * v19;
    double v30 = *(double *)(v29 + 1032);
    double v31 = v28 - v30;
    if (!*(void *)(v27 + 1024)) {
      goto LABEL_27;
    }
    uint64_t v32 = *(void *)(a1 + 1040 * v19 + 1024);
    double v30 = *(double *)(v27 + 1032);
    if (!v32) {
      goto LABEL_27;
    }
    if (*a7) {
      double v33 = *(double *)(a6 + 16) >= 0.0 ? *(double *)(a6 + 16) : 0.0;
    }
    else {
      double v33 = 1.0e99;
    }
    memcpy(v40, (const void *)v27, 0x410uLL);
    uint64_t v34 = 0;
    v40[128] += v32;
    do
    {
      *(int32x4_t *)&v40[v34] = vaddq_s32(*(int32x4_t *)&v40[v34], *(int32x4_t *)(v29 + v34 * 8));
      v34 += 2;
    }
    while (v34 != 128);
    BrotliPopulationCostLiteral((uint64_t)v40);
    if (v30 < v33 - v31)
    {
LABEL_27:
      double v35 = v31 + v30;
      unint64_t v36 = *a7;
      if (*a7)
      {
        double v37 = *(double *)(a6 + 16);
        if (v37 == v35)
        {
          if (*(_DWORD *)(a6 + 4) - *(_DWORD *)a6 > v19 - v17) {
            goto LABEL_30;
          }
        }
        else if (v37 > v35)
        {
LABEL_30:
          if (v36 < a5)
          {
            uint64_t v38 = a6 + 24 * v36;
            *(_OWORD *)uint64_t v38 = *(_OWORD *)a6;
            *(void *)(v38 + 16) = *(void *)(a6 + 16);
            ++*a7;
          }
          *(_DWORD *)a6 = v17;
          *(_DWORD *)(a6 + 4) = v19;
          *(double *)(a6 + 8) = v30;
          *(double *)(a6 + 16) = v35;
          return;
        }
      }
      if (v36 < a5)
      {
        uint64_t v39 = a6 + 24 * v36;
        *(_DWORD *)uint64_t v39 = v17;
        *(_DWORD *)(v39 + 4) = v19;
        *(double *)(v39 + 8) = v30;
        *(double *)(v39 + 16) = v35;
        *a7 = v36 + 1;
      }
    }
  }
}

unint64_t BrotliHistogramCombineLiteral(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, unsigned int *a5, unint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v57 = 0;
  if (a6)
  {
    uint64_t v12 = 0;
    unint64_t v13 = a9;
    unint64_t v14 = a6 - 1;
    unint64_t v15 = a4 + 1;
    unint64_t v55 = a6;
    do
    {
      uint64_t v17 = v12 + 1;
      if (v12 + 1 < a6)
      {
        uint64_t v18 = v15;
        unint64_t v19 = v14;
        do
        {
          unsigned int v20 = *v18++;
          BrotliCompareAndPushToQueueLiteral(a1, a2, a4[v12], v20, v13, (uint64_t)a5, &v57);
          unint64_t v13 = a9;
          --v19;
        }
        while (v19);
      }
      --v14;
      ++v15;
      ++v12;
      a6 = v55;
    }
    while (v17 != v55);
    if (v55 >= 2)
    {
      double v21 = 0.0;
      unint64_t v22 = 1;
      unint64_t v23 = a4;
      do
      {
        if (*((double *)a5 + 2) >= v21)
        {
          double v21 = 1.0e99;
          unint64_t v22 = a8;
        }
        else
        {
          uint64_t v24 = 0;
          uint64_t v26 = *a5;
          uint64_t v25 = a5[1];
          uint64_t v27 = a1 + 1040 * v26;
          uint64_t v28 = a1 + 1040 * v25;
          *(void *)(v27 + 1024) += *(void *)(v28 + 1024);
          do
          {
            *(_DWORD *)(v27 + v24) += *(_DWORD *)(v28 + v24);
            v24 += 4;
          }
          while (v24 != 1024);
          *(void *)(a1 + 1040 * v26 + 1032) = *((void *)a5 + 1);
          *(_DWORD *)(a2 + 4 * v26) += *(_DWORD *)(a2 + 4 * v25);
          uint64_t v29 = a3;
          for (uint64_t i = a7; i; --i)
          {
            if (*v29 == v25) {
              *uint64_t v29 = v26;
            }
            ++v29;
          }
          unint64_t v31 = a6 - 1;
          if (a6 <= 1) {
            uint64_t v32 = 1;
          }
          else {
            uint64_t v32 = a6;
          }
          size_t v33 = 4 * a6 - 4;
          uint64_t v34 = v23;
          while (*v34 != v25)
          {
            v33 -= 4;
            ++v34;
            if (!--v32) {
              goto LABEL_25;
            }
          }
          memmove(v34, v34 + 1, v33);
LABEL_25:
          unint64_t v35 = v57;
          if (v57)
          {
            unint64_t v36 = 0;
            double v37 = (double *)a5;
            while (2)
            {
              int v38 = *(_DWORD *)v37;
              if (*(_DWORD *)v37 == v26) {
                goto LABEL_41;
              }
              unsigned int v39 = *((_DWORD *)v37 + 1);
              BOOL v40 = v39 == v25 || v38 == v25;
              if (v40 || v39 == v26) {
                goto LABEL_41;
              }
              double v42 = *((double *)a5 + 2);
              double v43 = v37[2];
              if (v42 == v43)
              {
                if (a5[1] - *a5 <= v39 - v38) {
                  goto LABEL_39;
                }
LABEL_37:
                long long v44 = *(_OWORD *)a5;
                uint64_t v45 = *((void *)a5 + 2);
                uint64_t v46 = *((void *)v37 + 2);
                *(_OWORD *)a5 = *(_OWORD *)v37;
                *((void *)a5 + 2) = v46;
              }
              else
              {
                if (v42 > v43) {
                  goto LABEL_37;
                }
LABEL_39:
                long long v44 = *(_OWORD *)v37;
                uint64_t v45 = *((void *)v37 + 2);
              }
              unsigned int v47 = &a5[6 * v36];
              *((void *)v47 + 2) = v45;
              *(_OWORD *)unsigned int v47 = v44;
              ++v36;
LABEL_41:
              v37 += 3;
              if (!--v35) {
                goto LABEL_44;
              }
              continue;
            }
          }
          unint64_t v36 = 0;
LABEL_44:
          unint64_t v57 = v36;
          if (!v31) {
            return 0;
          }
          unsigned int v48 = v23;
          unint64_t v49 = v31;
          do
          {
            unsigned int v50 = *v48++;
            BrotliCompareAndPushToQueueLiteral(a1, a2, v26, v50, a9, (uint64_t)a5, &v57);
            --v49;
          }
          while (v49);
          a6 = v31;
          unint64_t v23 = a4;
        }
      }
      while (a6 > v22);
    }
  }
  return a6;
}

double BrotliHistogramBitCostDistanceLiteral(void *__src, uint64_t a2)
{
  if (!__src[128]) {
    return 0.0;
  }
  memcpy(v6, __src, sizeof(v6));
  uint64_t v3 = 0;
  v6[128] += *(void *)(a2 + 1024);
  do
  {
    *(int32x4_t *)&v6[v3] = vaddq_s32(*(int32x4_t *)&v6[v3], *(int32x4_t *)(a2 + v3 * 8));
    v3 += 2;
  }
  while (v3 != 128);
  BrotliPopulationCostLiteral((uint64_t)v6);
  return v4 - *(double *)(a2 + 1032);
}

void BrotliHistogramRemapLiteral(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a6;
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      uint64_t v11 = i - 1;
      if (!i) {
        uint64_t v11 = 0;
      }
      unsigned int v12 = *(_DWORD *)(a6 + 4 * v11);
      double v13 = BrotliHistogramBitCostDistanceLiteral((void *)(a1 + 1040 * i), a5 + 1040 * v12);
      if (a4)
      {
        double v14 = v13;
        unint64_t v15 = a3;
        uint64_t v16 = a4;
        do
        {
          double v17 = BrotliHistogramBitCostDistanceLiteral((void *)(a1 + 1040 * i), a5 + 1040 * *v15);
          if (v17 < v14)
          {
            unsigned int v12 = *v15;
            double v14 = v17;
          }
          ++v15;
          --v16;
        }
        while (v16);
      }
      a6 = v23;
      *(_DWORD *)(v23 + 4 * i) = v12;
    }
  }
  for (; a4; --a4)
  {
    unsigned int v18 = *a3++;
    bzero((void *)(a5 + 1040 * v18), 0x408uLL);
    *(void *)(a5 + 1040 * v18 + 1032) = 0x7FF0000000000000;
  }
  if (a2)
  {
    uint64_t v19 = 0;
    uint64_t v20 = a1;
    do
    {
      uint64_t v21 = 0;
      uint64_t v22 = a5 + 1040 * *(unsigned int *)(v23 + 4 * v19);
      *(void *)(v22 + 1024) += *(void *)(a1 + 1040 * v19 + 1024);
      do
      {
        *(_DWORD *)(v22 + v21) += *(_DWORD *)(v20 + v21);
        v21 += 4;
      }
      while (v21 != 1024);
      ++v19;
      v20 += 1040;
    }
    while (v19 != a2);
  }
}

uint64_t BrotliHistogramReindexLiteral(uint64_t a1, char *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (a4)
  {
    uint64_t v8 = (void *)BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return 0;
    }
    unint64_t v9 = (unint64_t)v8;
    memset(v8, 255, 4 * v4);
    int v10 = 0;
    uint64_t v11 = a3;
    uint64_t v12 = v4;
    do
    {
      unsigned int v14 = *v11++;
      uint64_t v13 = v14;
      if (*(_DWORD *)(v9 + 4 * v14) == -1) {
        *(_DWORD *)(v9 + 4 * v13) = v10++;
      }
      --v12;
    }
    while (v12);
    unint64_t v15 = v10 ? BrotliAllocate(a1) : 0;
    if (*(_DWORD *)(a1 + 24)) {
      return 0;
    }
LABEL_14:
    if (v4)
    {
      unsigned int v17 = 0;
      do
      {
        uint64_t v18 = *a3;
        unsigned int v19 = *(_DWORD *)(v9 + 4 * v18);
        if (v19 == v17)
        {
          memcpy((void *)(v15 + 1040 * v17++), &a2[1040 * v18], 0x410uLL);
          unsigned int v19 = *(_DWORD *)(v9 + 4 * *a3);
        }
        *a3++ = v19;
        --v4;
      }
      while (v4);
      BrotliFree(a1, v9);
      if (v17)
      {
        uint64_t v16 = v17;
        uint64_t v20 = (char *)v15;
        uint64_t v21 = v17;
        do
        {
          memcpy(a2, v20, 0x410uLL);
          v20 += 1040;
          a2 += 1040;
          --v21;
        }
        while (v21);
        goto LABEL_25;
      }
    }
    else
    {
      BrotliFree(a1, v9);
    }
    uint64_t v16 = 0;
LABEL_25:
    BrotliFree(a1, v15);
    return v16;
  }
  uint64_t v16 = 0;
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v15 = 0;
    unint64_t v9 = 0;
    goto LABEL_14;
  }
  return v16;
}

void BrotliClusterHistogramsLiteral(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char *a5, uint64_t *a6, unsigned int *a7)
{
  if (a3)
  {
    uint64_t v11 = (void *)BrotliAllocate(a1);
    uint64_t v12 = (unsigned int *)BrotliAllocate(a1);
    uint64_t v13 = BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v13;
    memset_pattern16(v11, &unk_20DAD62E0, 4 * a3);
    uint64_t v15 = 0;
    uint64_t v16 = a5;
    unsigned int v17 = (char *)a2;
    do
    {
      memcpy(v16, v17, 0x410uLL);
      BrotliPopulationCostLiteral((uint64_t)v17);
      *((void *)v16 + 129) = v18;
      a7[v15] = v15;
      ++v15;
      v17 += 1040;
      v16 += 1040;
    }
    while (a3 != v15);
    unsigned int v19 = (_DWORD *)(a1 + 24);
  }
  else
  {
    uint64_t v20 = BrotliAllocate(a1);
    unsigned int v19 = (_DWORD *)(a1 + 24);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v20;
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  uint64_t v34 = a1;
  unint64_t v35 = v19;
  if (a3)
  {
    unint64_t v21 = 0;
    unint64_t v22 = 0;
    unint64_t v23 = a3;
    do
    {
      unint64_t v24 = v23 - 64;
      if (v23 >= 0x40) {
        unint64_t v23 = 64;
      }
      if (a3 - v21 >= 0x40) {
        unint64_t v25 = 64;
      }
      else {
        unint64_t v25 = a3 - v21;
      }
      if (v25)
      {
        uint64_t v26 = 0;
        do
        {
          v12[v22 + v26] = v21 + v26;
          ++v26;
        }
        while (v23 != v26);
      }
      v22 += BrotliHistogramCombineLiteral((uint64_t)a5, (uint64_t)v11, &a7[v21], &v12[v22], v14, v25, v25, a4, 0x800uLL);
      v21 += 64;
      unint64_t v23 = v24;
    }
    while (v21 < a3);
  }
  else
  {
    unint64_t v22 = 0;
  }
  if (v22 << 6 >= (v22 >> 1) * v22) {
    unint64_t v27 = (v22 >> 1) * v22;
  }
  else {
    unint64_t v27 = v22 << 6;
  }
  if (v27 < 0x800)
  {
    uint64_t v32 = v14;
    uint64_t v29 = v34;
  }
  else
  {
    uint64_t v28 = 2048;
    uint64_t v29 = v34;
    do
    {
      unint64_t v30 = v28;
      v28 *= 2;
    }
    while (v30 <= v27);
    unint64_t v31 = (unsigned int *)BrotliAllocate(v34);
    uint64_t v32 = v31;
    if (!*(_DWORD *)(v34 + 24)) {
      memcpy(v31, v14, 0xC000uLL);
    }
    BrotliFree(v34, (unint64_t)v14);
  }
  if (!*v35)
  {
    unint64_t v33 = BrotliHistogramCombineLiteral((uint64_t)a5, (uint64_t)v11, a7, v12, v32, v22, a3, a4, v27);
    BrotliFree(v29, (unint64_t)v32);
    BrotliFree(v29, (unint64_t)v11);
    BrotliHistogramRemapLiteral(a2, a3, v12, v33, (uint64_t)a5, (uint64_t)a7);
    BrotliFree(v29, (unint64_t)v12);
    *a6 = BrotliHistogramReindexLiteral(v29, a5, a7, a3);
  }
}

void BrotliCompareAndPushToQueueCommand(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unint64_t a5, uint64_t a6, unint64_t *a7)
{
  if (a3 != a4)
  {
    v40[354] = v12;
    v40[355] = v11;
    v40[356] = v10;
    v40[357] = v9;
    v40[368] = v7;
    v40[369] = v8;
    unsigned int v17 = a4 >= a3 ? a3 : a4;
    uint64_t v18 = *(unsigned int *)(a2 + 4 * v17);
    unsigned int v19 = a4 <= a3 ? a3 : a4;
    uint64_t v20 = *(unsigned int *)(a2 + 4 * v19);
    double v21 = (double)v18;
    double v22 = v18 > 0xFF ? log2((double)v18) : kBrotliLog2Table[v18];
    unint64_t v23 = v20 + v18;
    double v24 = v20 > 0xFF ? log2((double)v20) : kBrotliLog2Table[v20];
    double v25 = v24 * (double)v20 + v21 * v22;
    double v26 = v23 > 0xFF ? log2((double)v23) : kBrotliLog2Table[v23];
    uint64_t v27 = a1 + 2832 * v17;
    double v28 = (v25 - (double)v23 * v26) * 0.5 - *(double *)(v27 + 2824);
    uint64_t v29 = a1 + 2832 * v19;
    double v30 = *(double *)(v29 + 2824);
    double v31 = v28 - v30;
    if (!*(void *)(v27 + 2816)) {
      goto LABEL_27;
    }
    uint64_t v32 = *(void *)(a1 + 2832 * v19 + 2816);
    double v30 = *(double *)(v27 + 2824);
    if (!v32) {
      goto LABEL_27;
    }
    if (*a7) {
      double v33 = *(double *)(a6 + 16) >= 0.0 ? *(double *)(a6 + 16) : 0.0;
    }
    else {
      double v33 = 1.0e99;
    }
    memcpy(v40, (const void *)v27, 0xB10uLL);
    uint64_t v34 = 0;
    v40[352] += v32;
    do
    {
      *(int32x4_t *)&v40[v34] = vaddq_s32(*(int32x4_t *)&v40[v34], *(int32x4_t *)(v29 + v34 * 8));
      v34 += 2;
    }
    while (v34 != 352);
    BrotliPopulationCostCommand((uint64_t)v40);
    if (v30 < v33 - v31)
    {
LABEL_27:
      double v35 = v31 + v30;
      unint64_t v36 = *a7;
      if (*a7)
      {
        double v37 = *(double *)(a6 + 16);
        if (v37 == v35)
        {
          if (*(_DWORD *)(a6 + 4) - *(_DWORD *)a6 > v19 - v17) {
            goto LABEL_30;
          }
        }
        else if (v37 > v35)
        {
LABEL_30:
          if (v36 < a5)
          {
            uint64_t v38 = a6 + 24 * v36;
            *(_OWORD *)uint64_t v38 = *(_OWORD *)a6;
            *(void *)(v38 + 16) = *(void *)(a6 + 16);
            ++*a7;
          }
          *(_DWORD *)a6 = v17;
          *(_DWORD *)(a6 + 4) = v19;
          *(double *)(a6 + 8) = v30;
          *(double *)(a6 + 16) = v35;
          return;
        }
      }
      if (v36 < a5)
      {
        uint64_t v39 = a6 + 24 * v36;
        *(_DWORD *)uint64_t v39 = v17;
        *(_DWORD *)(v39 + 4) = v19;
        *(double *)(v39 + 8) = v30;
        *(double *)(v39 + 16) = v35;
        *a7 = v36 + 1;
      }
    }
  }
}

unint64_t BrotliHistogramCombineCommand(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, unsigned int *a5, unint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v57 = 0;
  if (a6)
  {
    uint64_t v12 = 0;
    unint64_t v13 = a9;
    unint64_t v14 = a6 - 1;
    uint64_t v15 = a4 + 1;
    unint64_t v55 = a6;
    do
    {
      uint64_t v17 = v12 + 1;
      if (v12 + 1 < a6)
      {
        uint64_t v18 = v15;
        unint64_t v19 = v14;
        do
        {
          unsigned int v20 = *v18++;
          BrotliCompareAndPushToQueueCommand(a1, a2, a4[v12], v20, v13, (uint64_t)a5, &v57);
          unint64_t v13 = a9;
          --v19;
        }
        while (v19);
      }
      --v14;
      ++v15;
      ++v12;
      a6 = v55;
    }
    while (v17 != v55);
    if (v55 >= 2)
    {
      double v21 = 0.0;
      unint64_t v22 = 1;
      unint64_t v23 = a4;
      do
      {
        if (*((double *)a5 + 2) >= v21)
        {
          double v21 = 1.0e99;
          unint64_t v22 = a8;
        }
        else
        {
          uint64_t v24 = 0;
          uint64_t v26 = *a5;
          uint64_t v25 = a5[1];
          uint64_t v27 = a1 + 2832 * v26;
          uint64_t v28 = a1 + 2832 * v25;
          *(void *)(v27 + 2816) += *(void *)(v28 + 2816);
          do
          {
            *(_DWORD *)(v27 + v24) += *(_DWORD *)(v28 + v24);
            v24 += 4;
          }
          while (v24 != 2816);
          *(void *)(a1 + 2832 * v26 + 2824) = *((void *)a5 + 1);
          *(_DWORD *)(a2 + 4 * v26) += *(_DWORD *)(a2 + 4 * v25);
          uint64_t v29 = a3;
          for (uint64_t i = a7; i; --i)
          {
            if (*v29 == v25) {
              *uint64_t v29 = v26;
            }
            ++v29;
          }
          unint64_t v31 = a6 - 1;
          if (a6 <= 1) {
            uint64_t v32 = 1;
          }
          else {
            uint64_t v32 = a6;
          }
          size_t v33 = 4 * a6 - 4;
          uint64_t v34 = v23;
          while (*v34 != v25)
          {
            v33 -= 4;
            ++v34;
            if (!--v32) {
              goto LABEL_25;
            }
          }
          memmove(v34, v34 + 1, v33);
LABEL_25:
          unint64_t v35 = v57;
          if (v57)
          {
            unint64_t v36 = 0;
            double v37 = (double *)a5;
            while (2)
            {
              int v38 = *(_DWORD *)v37;
              if (*(_DWORD *)v37 == v26) {
                goto LABEL_41;
              }
              unsigned int v39 = *((_DWORD *)v37 + 1);
              BOOL v40 = v39 == v25 || v38 == v25;
              if (v40 || v39 == v26) {
                goto LABEL_41;
              }
              double v42 = *((double *)a5 + 2);
              double v43 = v37[2];
              if (v42 == v43)
              {
                if (a5[1] - *a5 <= v39 - v38) {
                  goto LABEL_39;
                }
LABEL_37:
                long long v44 = *(_OWORD *)a5;
                uint64_t v45 = *((void *)a5 + 2);
                uint64_t v46 = *((void *)v37 + 2);
                *(_OWORD *)a5 = *(_OWORD *)v37;
                *((void *)a5 + 2) = v46;
              }
              else
              {
                if (v42 > v43) {
                  goto LABEL_37;
                }
LABEL_39:
                long long v44 = *(_OWORD *)v37;
                uint64_t v45 = *((void *)v37 + 2);
              }
              unsigned int v47 = &a5[6 * v36];
              *((void *)v47 + 2) = v45;
              *(_OWORD *)unsigned int v47 = v44;
              ++v36;
LABEL_41:
              v37 += 3;
              if (!--v35) {
                goto LABEL_44;
              }
              continue;
            }
          }
          unint64_t v36 = 0;
LABEL_44:
          unint64_t v57 = v36;
          if (!v31) {
            return 0;
          }
          unsigned int v48 = v23;
          unint64_t v49 = v31;
          do
          {
            unsigned int v50 = *v48++;
            BrotliCompareAndPushToQueueCommand(a1, a2, v26, v50, a9, (uint64_t)a5, &v57);
            --v49;
          }
          while (v49);
          a6 = v31;
          unint64_t v23 = a4;
        }
      }
      while (a6 > v22);
    }
  }
  return a6;
}

double BrotliHistogramBitCostDistanceCommand(void *__src, uint64_t a2)
{
  if (!__src[352]) {
    return 0.0;
  }
  memcpy(v6, __src, sizeof(v6));
  uint64_t v3 = 0;
  v6[352] += *(void *)(a2 + 2816);
  do
  {
    *(int32x4_t *)&v6[v3] = vaddq_s32(*(int32x4_t *)&v6[v3], *(int32x4_t *)(a2 + v3 * 8));
    v3 += 2;
  }
  while (v3 != 352);
  BrotliPopulationCostCommand((uint64_t)v6);
  return v4 - *(double *)(a2 + 2824);
}

void BrotliHistogramRemapCommand(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a6;
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      uint64_t v11 = i - 1;
      if (!i) {
        uint64_t v11 = 0;
      }
      unsigned int v12 = *(_DWORD *)(a6 + 4 * v11);
      double v13 = BrotliHistogramBitCostDistanceCommand((void *)(a1 + 2832 * i), a5 + 2832 * v12);
      if (a4)
      {
        double v14 = v13;
        uint64_t v15 = a3;
        uint64_t v16 = a4;
        do
        {
          double v17 = BrotliHistogramBitCostDistanceCommand((void *)(a1 + 2832 * i), a5 + 2832 * *v15);
          if (v17 < v14)
          {
            unsigned int v12 = *v15;
            double v14 = v17;
          }
          ++v15;
          --v16;
        }
        while (v16);
      }
      a6 = v23;
      *(_DWORD *)(v23 + 4 * i) = v12;
    }
  }
  for (; a4; --a4)
  {
    unsigned int v18 = *a3++;
    bzero((void *)(a5 + 2832 * v18), 0xB08uLL);
    *(void *)(a5 + 2832 * v18 + 2824) = 0x7FF0000000000000;
  }
  if (a2)
  {
    uint64_t v19 = 0;
    uint64_t v20 = a1;
    do
    {
      uint64_t v21 = 0;
      uint64_t v22 = a5 + 2832 * *(unsigned int *)(v23 + 4 * v19);
      *(void *)(v22 + 2816) += *(void *)(a1 + 2832 * v19 + 2816);
      do
      {
        *(_DWORD *)(v22 + v21) += *(_DWORD *)(v20 + v21);
        v21 += 4;
      }
      while (v21 != 2816);
      ++v19;
      v20 += 2832;
    }
    while (v19 != a2);
  }
}

uint64_t BrotliHistogramReindexCommand(uint64_t a1, char *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (a4)
  {
    uint64_t v8 = (void *)BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return 0;
    }
    unint64_t v9 = (unint64_t)v8;
    memset(v8, 255, 4 * v4);
    int v10 = 0;
    uint64_t v11 = a3;
    uint64_t v12 = v4;
    do
    {
      unsigned int v14 = *v11++;
      uint64_t v13 = v14;
      if (*(_DWORD *)(v9 + 4 * v14) == -1) {
        *(_DWORD *)(v9 + 4 * v13) = v10++;
      }
      --v12;
    }
    while (v12);
    unint64_t v15 = v10 ? BrotliAllocate(a1) : 0;
    if (*(_DWORD *)(a1 + 24)) {
      return 0;
    }
LABEL_14:
    if (v4)
    {
      unsigned int v17 = 0;
      do
      {
        uint64_t v18 = *a3;
        unsigned int v19 = *(_DWORD *)(v9 + 4 * v18);
        if (v19 == v17)
        {
          memcpy((void *)(v15 + 2832 * v17++), &a2[2832 * v18], 0xB10uLL);
          unsigned int v19 = *(_DWORD *)(v9 + 4 * *a3);
        }
        *a3++ = v19;
        --v4;
      }
      while (v4);
      BrotliFree(a1, v9);
      if (v17)
      {
        uint64_t v16 = v17;
        uint64_t v20 = (char *)v15;
        uint64_t v21 = v17;
        do
        {
          memcpy(a2, v20, 0xB10uLL);
          v20 += 2832;
          a2 += 2832;
          --v21;
        }
        while (v21);
        goto LABEL_25;
      }
    }
    else
    {
      BrotliFree(a1, v9);
    }
    uint64_t v16 = 0;
LABEL_25:
    BrotliFree(a1, v15);
    return v16;
  }
  uint64_t v16 = 0;
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v15 = 0;
    unint64_t v9 = 0;
    goto LABEL_14;
  }
  return v16;
}

void BrotliClusterHistogramsCommand(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char *a5, uint64_t *a6, unsigned int *a7)
{
  if (a3)
  {
    uint64_t v11 = (void *)BrotliAllocate(a1);
    uint64_t v12 = (unsigned int *)BrotliAllocate(a1);
    uint64_t v13 = BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v13;
    memset_pattern16(v11, &unk_20DAD62E0, 4 * a3);
    uint64_t v15 = 0;
    uint64_t v16 = a5;
    unsigned int v17 = (char *)a2;
    do
    {
      memcpy(v16, v17, 0xB10uLL);
      BrotliPopulationCostCommand((uint64_t)v17);
      *((void *)v16 + 353) = v18;
      a7[v15] = v15;
      ++v15;
      v17 += 2832;
      v16 += 2832;
    }
    while (a3 != v15);
    unsigned int v19 = (_DWORD *)(a1 + 24);
  }
  else
  {
    uint64_t v20 = BrotliAllocate(a1);
    unsigned int v19 = (_DWORD *)(a1 + 24);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v20;
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  uint64_t v34 = a1;
  unint64_t v35 = v19;
  if (a3)
  {
    unint64_t v21 = 0;
    unint64_t v22 = 0;
    unint64_t v23 = a3;
    do
    {
      unint64_t v24 = v23 - 64;
      if (v23 >= 0x40) {
        unint64_t v23 = 64;
      }
      if (a3 - v21 >= 0x40) {
        unint64_t v25 = 64;
      }
      else {
        unint64_t v25 = a3 - v21;
      }
      if (v25)
      {
        uint64_t v26 = 0;
        do
        {
          v12[v22 + v26] = v21 + v26;
          ++v26;
        }
        while (v23 != v26);
      }
      v22 += BrotliHistogramCombineCommand((uint64_t)a5, (uint64_t)v11, &a7[v21], &v12[v22], v14, v25, v25, a4, 0x800uLL);
      v21 += 64;
      unint64_t v23 = v24;
    }
    while (v21 < a3);
  }
  else
  {
    unint64_t v22 = 0;
  }
  if (v22 << 6 >= (v22 >> 1) * v22) {
    unint64_t v27 = (v22 >> 1) * v22;
  }
  else {
    unint64_t v27 = v22 << 6;
  }
  if (v27 < 0x800)
  {
    uint64_t v32 = v14;
    uint64_t v29 = v34;
  }
  else
  {
    uint64_t v28 = 2048;
    uint64_t v29 = v34;
    do
    {
      unint64_t v30 = v28;
      v28 *= 2;
    }
    while (v30 <= v27);
    unint64_t v31 = (unsigned int *)BrotliAllocate(v34);
    uint64_t v32 = v31;
    if (!*(_DWORD *)(v34 + 24)) {
      memcpy(v31, v14, 0xC000uLL);
    }
    BrotliFree(v34, (unint64_t)v14);
  }
  if (!*v35)
  {
    unint64_t v33 = BrotliHistogramCombineCommand((uint64_t)a5, (uint64_t)v11, a7, v12, v32, v22, a3, a4, v27);
    BrotliFree(v29, (unint64_t)v32);
    BrotliFree(v29, (unint64_t)v11);
    BrotliHistogramRemapCommand(a2, a3, v12, v33, (uint64_t)a5, (uint64_t)a7);
    BrotliFree(v29, (unint64_t)v12);
    *a6 = BrotliHistogramReindexCommand(v29, a5, a7, a3);
  }
}

void BrotliCompareAndPushToQueueDistance(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unint64_t a5, uint64_t a6, unint64_t *a7)
{
  if (a3 != a4)
  {
    v40[274] = v12;
    v40[275] = v11;
    v40[276] = v10;
    v40[277] = v9;
    v40[288] = v7;
    v40[289] = v8;
    unsigned int v17 = a4 >= a3 ? a3 : a4;
    uint64_t v18 = *(unsigned int *)(a2 + 4 * v17);
    unsigned int v19 = a4 <= a3 ? a3 : a4;
    uint64_t v20 = *(unsigned int *)(a2 + 4 * v19);
    double v21 = (double)v18;
    double v22 = v18 > 0xFF ? log2((double)v18) : kBrotliLog2Table[v18];
    unint64_t v23 = v20 + v18;
    double v24 = v20 > 0xFF ? log2((double)v20) : kBrotliLog2Table[v20];
    double v25 = v24 * (double)v20 + v21 * v22;
    double v26 = v23 > 0xFF ? log2((double)v23) : kBrotliLog2Table[v23];
    uint64_t v27 = a1 + 2192 * v17;
    double v28 = (v25 - (double)v23 * v26) * 0.5 - *(double *)(v27 + 2184);
    uint64_t v29 = a1 + 2192 * v19;
    double v30 = *(double *)(v29 + 2184);
    double v31 = v28 - v30;
    if (!*(void *)(v27 + 2176)) {
      goto LABEL_27;
    }
    uint64_t v32 = *(void *)(a1 + 2192 * v19 + 2176);
    double v30 = *(double *)(v27 + 2184);
    if (!v32) {
      goto LABEL_27;
    }
    if (*a7) {
      double v33 = *(double *)(a6 + 16) >= 0.0 ? *(double *)(a6 + 16) : 0.0;
    }
    else {
      double v33 = 1.0e99;
    }
    memcpy(v40, (const void *)v27, 0x890uLL);
    uint64_t v34 = 0;
    v40[272] += v32;
    do
    {
      *(int32x4_t *)&v40[v34] = vaddq_s32(*(int32x4_t *)&v40[v34], *(int32x4_t *)(v29 + v34 * 8));
      v34 += 2;
    }
    while (v34 != 272);
    BrotliPopulationCostDistance((uint64_t)v40);
    if (v30 < v33 - v31)
    {
LABEL_27:
      double v35 = v31 + v30;
      unint64_t v36 = *a7;
      if (*a7)
      {
        double v37 = *(double *)(a6 + 16);
        if (v37 == v35)
        {
          if (*(_DWORD *)(a6 + 4) - *(_DWORD *)a6 > v19 - v17) {
            goto LABEL_30;
          }
        }
        else if (v37 > v35)
        {
LABEL_30:
          if (v36 < a5)
          {
            uint64_t v38 = a6 + 24 * v36;
            *(_OWORD *)uint64_t v38 = *(_OWORD *)a6;
            *(void *)(v38 + 16) = *(void *)(a6 + 16);
            ++*a7;
          }
          *(_DWORD *)a6 = v17;
          *(_DWORD *)(a6 + 4) = v19;
          *(double *)(a6 + 8) = v30;
          *(double *)(a6 + 16) = v35;
          return;
        }
      }
      if (v36 < a5)
      {
        uint64_t v39 = a6 + 24 * v36;
        *(_DWORD *)uint64_t v39 = v17;
        *(_DWORD *)(v39 + 4) = v19;
        *(double *)(v39 + 8) = v30;
        *(double *)(v39 + 16) = v35;
        *a7 = v36 + 1;
      }
    }
  }
}

unint64_t BrotliHistogramCombineDistance(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, unsigned int *a5, unint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v57 = 0;
  if (a6)
  {
    uint64_t v12 = 0;
    unint64_t v13 = a9;
    unint64_t v14 = a6 - 1;
    uint64_t v15 = a4 + 1;
    unint64_t v55 = a6;
    do
    {
      uint64_t v17 = v12 + 1;
      if (v12 + 1 < a6)
      {
        uint64_t v18 = v15;
        unint64_t v19 = v14;
        do
        {
          unsigned int v20 = *v18++;
          BrotliCompareAndPushToQueueDistance(a1, a2, a4[v12], v20, v13, (uint64_t)a5, &v57);
          unint64_t v13 = a9;
          --v19;
        }
        while (v19);
      }
      --v14;
      ++v15;
      ++v12;
      a6 = v55;
    }
    while (v17 != v55);
    if (v55 >= 2)
    {
      double v21 = 0.0;
      unint64_t v22 = 1;
      unint64_t v23 = a4;
      do
      {
        if (*((double *)a5 + 2) >= v21)
        {
          double v21 = 1.0e99;
          unint64_t v22 = a8;
        }
        else
        {
          uint64_t v24 = 0;
          uint64_t v26 = *a5;
          uint64_t v25 = a5[1];
          uint64_t v27 = a1 + 2192 * v26;
          uint64_t v28 = a1 + 2192 * v25;
          *(void *)(v27 + 2176) += *(void *)(v28 + 2176);
          do
          {
            *(_DWORD *)(v27 + v24) += *(_DWORD *)(v28 + v24);
            v24 += 4;
          }
          while (v24 != 2176);
          *(void *)(a1 + 2192 * v26 + 2184) = *((void *)a5 + 1);
          *(_DWORD *)(a2 + 4 * v26) += *(_DWORD *)(a2 + 4 * v25);
          uint64_t v29 = a3;
          for (uint64_t i = a7; i; --i)
          {
            if (*v29 == v25) {
              *uint64_t v29 = v26;
            }
            ++v29;
          }
          unint64_t v31 = a6 - 1;
          if (a6 <= 1) {
            uint64_t v32 = 1;
          }
          else {
            uint64_t v32 = a6;
          }
          size_t v33 = 4 * a6 - 4;
          uint64_t v34 = v23;
          while (*v34 != v25)
          {
            v33 -= 4;
            ++v34;
            if (!--v32) {
              goto LABEL_25;
            }
          }
          memmove(v34, v34 + 1, v33);
LABEL_25:
          unint64_t v35 = v57;
          if (v57)
          {
            unint64_t v36 = 0;
            double v37 = (double *)a5;
            while (2)
            {
              int v38 = *(_DWORD *)v37;
              if (*(_DWORD *)v37 == v26) {
                goto LABEL_41;
              }
              unsigned int v39 = *((_DWORD *)v37 + 1);
              BOOL v40 = v39 == v25 || v38 == v25;
              if (v40 || v39 == v26) {
                goto LABEL_41;
              }
              double v42 = *((double *)a5 + 2);
              double v43 = v37[2];
              if (v42 == v43)
              {
                if (a5[1] - *a5 <= v39 - v38) {
                  goto LABEL_39;
                }
LABEL_37:
                long long v44 = *(_OWORD *)a5;
                uint64_t v45 = *((void *)a5 + 2);
                uint64_t v46 = *((void *)v37 + 2);
                *(_OWORD *)a5 = *(_OWORD *)v37;
                *((void *)a5 + 2) = v46;
              }
              else
              {
                if (v42 > v43) {
                  goto LABEL_37;
                }
LABEL_39:
                long long v44 = *(_OWORD *)v37;
                uint64_t v45 = *((void *)v37 + 2);
              }
              unsigned int v47 = &a5[6 * v36];
              *((void *)v47 + 2) = v45;
              *(_OWORD *)unsigned int v47 = v44;
              ++v36;
LABEL_41:
              v37 += 3;
              if (!--v35) {
                goto LABEL_44;
              }
              continue;
            }
          }
          unint64_t v36 = 0;
LABEL_44:
          unint64_t v57 = v36;
          if (!v31) {
            return 0;
          }
          unsigned int v48 = v23;
          unint64_t v49 = v31;
          do
          {
            unsigned int v50 = *v48++;
            BrotliCompareAndPushToQueueDistance(a1, a2, v26, v50, a9, (uint64_t)a5, &v57);
            --v49;
          }
          while (v49);
          a6 = v31;
          unint64_t v23 = a4;
        }
      }
      while (a6 > v22);
    }
  }
  return a6;
}

double BrotliHistogramBitCostDistanceDistance(void *__src, uint64_t a2)
{
  if (!__src[272]) {
    return 0.0;
  }
  memcpy(v6, __src, sizeof(v6));
  uint64_t v3 = 0;
  v6[272] += *(void *)(a2 + 2176);
  do
  {
    *(int32x4_t *)&v6[v3] = vaddq_s32(*(int32x4_t *)&v6[v3], *(int32x4_t *)(a2 + v3 * 8));
    v3 += 2;
  }
  while (v3 != 272);
  BrotliPopulationCostDistance((uint64_t)v6);
  return v4 - *(double *)(a2 + 2184);
}

void BrotliHistogramRemapDistance(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a6;
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      uint64_t v11 = i - 1;
      if (!i) {
        uint64_t v11 = 0;
      }
      unsigned int v12 = *(_DWORD *)(a6 + 4 * v11);
      double v13 = BrotliHistogramBitCostDistanceDistance((void *)(a1 + 2192 * i), a5 + 2192 * v12);
      if (a4)
      {
        double v14 = v13;
        uint64_t v15 = a3;
        uint64_t v16 = a4;
        do
        {
          double v17 = BrotliHistogramBitCostDistanceDistance((void *)(a1 + 2192 * i), a5 + 2192 * *v15);
          if (v17 < v14)
          {
            unsigned int v12 = *v15;
            double v14 = v17;
          }
          ++v15;
          --v16;
        }
        while (v16);
      }
      a6 = v23;
      *(_DWORD *)(v23 + 4 * i) = v12;
    }
  }
  for (; a4; --a4)
  {
    unsigned int v18 = *a3++;
    bzero((void *)(a5 + 2192 * v18), 0x888uLL);
    *(void *)(a5 + 2192 * v18 + 2184) = 0x7FF0000000000000;
  }
  if (a2)
  {
    uint64_t v19 = 0;
    uint64_t v20 = a1;
    do
    {
      uint64_t v21 = 0;
      uint64_t v22 = a5 + 2192 * *(unsigned int *)(v23 + 4 * v19);
      *(void *)(v22 + 2176) += *(void *)(a1 + 2192 * v19 + 2176);
      do
      {
        *(_DWORD *)(v22 + v21) += *(_DWORD *)(v20 + v21);
        v21 += 4;
      }
      while (v21 != 2176);
      ++v19;
      v20 += 2192;
    }
    while (v19 != a2);
  }
}

uint64_t BrotliHistogramReindexDistance(uint64_t a1, char *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (a4)
  {
    uint64_t v8 = (void *)BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return 0;
    }
    unint64_t v9 = (unint64_t)v8;
    memset(v8, 255, 4 * v4);
    int v10 = 0;
    uint64_t v11 = a3;
    uint64_t v12 = v4;
    do
    {
      unsigned int v14 = *v11++;
      uint64_t v13 = v14;
      if (*(_DWORD *)(v9 + 4 * v14) == -1) {
        *(_DWORD *)(v9 + 4 * v13) = v10++;
      }
      --v12;
    }
    while (v12);
    unint64_t v15 = v10 ? BrotliAllocate(a1) : 0;
    if (*(_DWORD *)(a1 + 24)) {
      return 0;
    }
LABEL_14:
    if (v4)
    {
      unsigned int v17 = 0;
      do
      {
        uint64_t v18 = *a3;
        unsigned int v19 = *(_DWORD *)(v9 + 4 * v18);
        if (v19 == v17)
        {
          memcpy((void *)(v15 + 2192 * v17++), &a2[2192 * v18], 0x890uLL);
          unsigned int v19 = *(_DWORD *)(v9 + 4 * *a3);
        }
        *a3++ = v19;
        --v4;
      }
      while (v4);
      BrotliFree(a1, v9);
      if (v17)
      {
        uint64_t v16 = v17;
        uint64_t v20 = (char *)v15;
        uint64_t v21 = v17;
        do
        {
          memcpy(a2, v20, 0x890uLL);
          v20 += 2192;
          a2 += 2192;
          --v21;
        }
        while (v21);
        goto LABEL_25;
      }
    }
    else
    {
      BrotliFree(a1, v9);
    }
    uint64_t v16 = 0;
LABEL_25:
    BrotliFree(a1, v15);
    return v16;
  }
  uint64_t v16 = 0;
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v15 = 0;
    unint64_t v9 = 0;
    goto LABEL_14;
  }
  return v16;
}

void BrotliClusterHistogramsDistance(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char *a5, uint64_t *a6, unsigned int *a7)
{
  if (a3)
  {
    uint64_t v11 = (void *)BrotliAllocate(a1);
    uint64_t v12 = (unsigned int *)BrotliAllocate(a1);
    uint64_t v13 = BrotliAllocate(a1);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v13;
    memset_pattern16(v11, &unk_20DAD62E0, 4 * a3);
    uint64_t v15 = 0;
    uint64_t v16 = a5;
    unsigned int v17 = (char *)a2;
    do
    {
      memcpy(v16, v17, 0x890uLL);
      BrotliPopulationCostDistance((uint64_t)v17);
      *((void *)v16 + 273) = v18;
      a7[v15] = v15;
      ++v15;
      v17 += 2192;
      v16 += 2192;
    }
    while (a3 != v15);
    unsigned int v19 = (_DWORD *)(a1 + 24);
  }
  else
  {
    uint64_t v20 = BrotliAllocate(a1);
    unsigned int v19 = (_DWORD *)(a1 + 24);
    if (*(_DWORD *)(a1 + 24)) {
      return;
    }
    unsigned int v14 = (unsigned int *)v20;
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  uint64_t v34 = a1;
  unint64_t v35 = v19;
  if (a3)
  {
    unint64_t v21 = 0;
    unint64_t v22 = 0;
    unint64_t v23 = a3;
    do
    {
      unint64_t v24 = v23 - 64;
      if (v23 >= 0x40) {
        unint64_t v23 = 64;
      }
      if (a3 - v21 >= 0x40) {
        unint64_t v25 = 64;
      }
      else {
        unint64_t v25 = a3 - v21;
      }
      if (v25)
      {
        uint64_t v26 = 0;
        do
        {
          v12[v22 + v26] = v21 + v26;
          ++v26;
        }
        while (v23 != v26);
      }
      v22 += BrotliHistogramCombineDistance((uint64_t)a5, (uint64_t)v11, &a7[v21], &v12[v22], v14, v25, v25, a4, 0x800uLL);
      v21 += 64;
      unint64_t v23 = v24;
    }
    while (v21 < a3);
  }
  else
  {
    unint64_t v22 = 0;
  }
  if (v22 << 6 >= (v22 >> 1) * v22) {
    unint64_t v27 = (v22 >> 1) * v22;
  }
  else {
    unint64_t v27 = v22 << 6;
  }
  if (v27 < 0x800)
  {
    uint64_t v32 = v14;
    uint64_t v29 = v34;
  }
  else
  {
    uint64_t v28 = 2048;
    uint64_t v29 = v34;
    do
    {
      unint64_t v30 = v28;
      v28 *= 2;
    }
    while (v30 <= v27);
    unint64_t v31 = (unsigned int *)BrotliAllocate(v34);
    uint64_t v32 = v31;
    if (!*(_DWORD *)(v34 + 24)) {
      memcpy(v31, v14, 0xC000uLL);
    }
    BrotliFree(v34, (unint64_t)v14);
  }
  if (!*v35)
  {
    unint64_t v33 = BrotliHistogramCombineDistance((uint64_t)a5, (uint64_t)v11, a7, v12, v32, v22, a3, a4, v27);
    BrotliFree(v29, (unint64_t)v32);
    BrotliFree(v29, (unint64_t)v11);
    BrotliHistogramRemapDistance(a2, a3, v12, v33, (uint64_t)a5, (uint64_t)a7);
    BrotliFree(v29, (unint64_t)v12);
    *a6 = BrotliHistogramReindexDistance(v29, a5, a7, a3);
  }
}

uint64_t lzfseStreamDecodeStateSize()
{
  return 1620288;
}

uint64_t lzbitmap_fast_decode(uint64_t a1, uint64_t a2, int8x16_t *a3, unsigned int a4, int8x16_t a5)
{
  uint64_t v7 = a2;
  if (a2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = -(int)a2;
    unsigned int v11 = 8;
    uint8x16_t v12 = (uint8x16_t)xmmword_20DAD5C00;
    v13.i64[0] = -1;
    v13.i64[1] = -1;
    int32x4_t v14 = (int32x4_t)xmmword_20DAD5BF0;
    v6.i32[0] = -1;
    v15.i64[0] = 0x800000008;
    v15.i64[1] = 0x800000008;
    int v16 = 1;
    unint64_t v17 = (unint64_t)a3->u64 + a4;
    while (1)
    {
      uint64_t v18 = &a3->u8[5];
      if ((unint64_t)a3->u64 + 5 > v17) {
        return 0;
      }
      unsigned int v19 = (int8x16_t *)((char *)a3->i64 + 4);
      unint64_t v20 = a3->u32[0];
      unint64_t v21 = v20 >> 16;
      int v22 = (unsigned __int16)a3->i32[0];
      if (v22 == 0xFFFF && !v19->i8[0])
      {
        if (v20 < 0x10000) {
          goto LABEL_55;
        }
        if ((unint64_t)&v18[v21] > v17) {
          return 0;
        }
        unsigned int v91 = v11;
        if ((int)v21 + (int)v9 <= v7) {
          unsigned __int16 v88 = HIWORD(a3->i32[0]);
        }
        else {
          unsigned __int16 v88 = v7 - v9;
        }
        uint64_t v89 = v10;
        int32x4_t v93 = v14;
        uint8x16_t v94 = v12;
        int32x4_t v92 = v6;
        memcpy((void *)(a1 + v9), v18, v88);
        v15.i64[0] = 0x800000008;
        v15.i64[1] = 0x800000008;
        int32x4_t v6 = v92;
        int32x4_t v14 = v93;
        v13.i64[0] = -1;
        v13.i64[1] = -1;
        uint8x16_t v12 = v94;
        uint64_t v10 = v89;
        uint64_t v9 = v9 + v88;
        a3 = (int8x16_t *)&v18[v88];
        unsigned int v11 = v91;
      }
      else
      {
        a5.i32[0] = (unsigned __int16)a3->i32[0];
        *(int8x8_t *)a5.i8 = vcnt_s8(*(int8x8_t *)a5.i8);
        a5.i16[0] = vaddlv_u8(*(uint8x8_t *)a5.i8);
        unint64_t v23 = (int8x16_t *)((char *)v19 + a5.u32[0]);
        if ((int)v9 + 128 > v7 || (unint64_t)a3[11].u64 + 4 > v17)
        {
          a5.i32[0] = HIWORD(a3->i32[0]);
          *(int8x8_t *)a5.i8 = vcnt_s8(*(int8x8_t *)a5.i8);
          a5.i16[0] = vaddlv_u8(*(uint8x8_t *)a5.i8);
          a3 = (int8x16_t *)((char *)v23 + (2 * a5.i32[0]));
          if ((unint64_t)a3 <= v17)
          {
            int v77 = 1;
            while (1)
            {
              int v78 = v9;
              if ((v77 & v21) != 0)
              {
                unsigned int v79 = v23->u16[0];
                unint64_t v23 = (int8x16_t *)((char *)v23 + 2);
                unsigned int v11 = v79;
              }
              if ((v77 & v22) != 0)
              {
                unsigned __int32 v81 = v19->u8[0];
                unsigned int v19 = (int8x16_t *)((char *)v19 + 1);
                unsigned __int32 v80 = v81;
              }
              else
              {
                unsigned __int32 v80 = 0;
              }
              a5.i32[0] = v80;
              *(int8x8_t *)a5.i8 = vcnt_s8(*(int8x8_t *)a5.i8);
              a5.i16[0] = vaddlv_u8(*(uint8x8_t *)a5.i8);
              if ((unint64_t)a3->u64 + a5.u32[0] > v17 || v9 < (unsigned __int16)v11 && v80 != 255) {
                break;
              }
              int v82 = 0;
              int v83 = v9 - (unsigned __int16)v11;
              int v84 = v10 + v9;
              while (1)
              {
                LODWORD(v9) = v78 + v82;
                if (v82 == 8) {
                  break;
                }
                int v85 = 1 << v82;
                int v86 = v82 + 1;
                int v87 = (int8x16_t *)(a1 + (v83 + v82));
                if ((v85 & v80) != 0)
                {
                  int v87 = a3;
                  a3 = (int8x16_t *)((char *)a3 + 1);
                }
                *(unsigned char *)(a1 + v9) = v87->i8[0];
                int v82 = v86;
                if (!(v84 + v86)) {
                  return v7;
                }
              }
              v77 *= 2;
              if (v77 >= 0x10000)
              {
                uint64_t v9 = (v78 + 8);
                goto LABEL_54;
              }
            }
          }
          return 0;
        }
        int8x16_t v24 = vcntq_s8((int8x16_t)vdupq_n_s16(v21));
        a5 = vorrq_s8(vandq_s8((int8x16_t)vdupq_n_s16(v11), vcltzq_s8(lzbitmap_fast_unpack_dist[BYTE2(v20)])), vqtbl1q_s8(*v23, lzbitmap_fast_unpack_dist[BYTE2(v20)]));
        v24.i16[0] = vaddq_s8(v24, v24).u16[0];
        a3 = (int8x16_t *)((char *)v23 + ((v24.i8[0] + v24.i8[1]) & 0x3E));
        int8x16_t v25 = vorrq_s8(vandq_s8((int8x16_t)vdupq_laneq_s16((int16x8_t)a5, 7), vcltzq_s8(*(int8x16_t *)((char *)lzbitmap_fast_unpack_dist + ((v20 >> 20) & 0xFF0)))), vqtbl1q_s8(*(int8x16_t *)((char *)v23 + (v24.i8[0] & 0x1E)), *(int8x16_t *)((char *)lzbitmap_fast_unpack_dist + ((v20 >> 20) & 0xFF0))));
        unsigned int v11 = v25.u16[7];
        if (v7 > v9)
        {
          unsigned int v26 = 0;
          *(int8x8_t *)v27.i8 = vdup_n_s8(v20);
          int8x8_t v28 = (int8x8_t)vdup_n_s16(v20);
          v27.u64[1] = (unint64_t)vuzp2_s8(v28, v28);
          int8x16_t v29 = (int8x16_t)vshlq_u8(v27, v12);
          int8x16_t v30 = vcgtq_s8(v29, v13);
          int8x16_t v31 = vcntq_s8(v29);
          v31.u64[1] = (unint64_t)vadd_s8((int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL), vdup_lane_s8(*(int8x8_t *)v31.i8, 7));
          int8x16_t v32 = vqtbl1q_s8(*v19, vorrq_s8(vaddq_s8(v31, v13), v30));
          unint64_t v33 = vextq_s8(v25, v25, 8uLL).u64[0];
          v30.i64[0] = vextq_s8(v32, v32, 8uLL).u64[0];
          int8x8_t v34 = vzip2_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)a5.i8);
          int8x8_t v35 = vzip1_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)a5.i8);
          unint64_t v36 = vextq_s8(a5, a5, 8uLL).u64[0];
          int8x8_t v37 = vzip2_s8(*(int8x8_t *)v32.i8, *(int8x8_t *)a5.i8);
          int8x8_t v38 = vzip1_s8(*(int8x8_t *)v32.i8, *(int8x8_t *)a5.i8);
          while (1)
          {
            switch(v26)
            {
              case 0u:
                uint16x4_t v39 = *(uint16x4_t *)a5.i8;
                *(int8x8_t *)v5.i8 = v38;
                break;
              case 1u:
                uint16x4_t v39 = (uint16x4_t)v36;
                *(int8x8_t *)v5.i8 = v37;
                break;
              case 2u:
                uint16x4_t v39 = *(uint16x4_t *)v25.i8;
                *(int8x8_t *)v5.i8 = v35;
                break;
              case 3u:
                uint16x4_t v39 = (uint16x4_t)v33;
                *(int8x8_t *)v5.i8 = v34;
                break;
              default:
                uint16x4_t v39 = 0;
                int16x8_t v5 = 0uLL;
                break;
            }
            int32x4_t v40 = vdupq_n_s32(v9);
            uint32x4_t v41 = (uint32x4_t)vaddq_s32(v40, v14);
            int8x16_t v42 = (int8x16_t)vmovl_s16((int16x4_t)vmvn_s8((int8x8_t)vceq_s16((int16x4_t)(v5.i64[0] & 0xFF00FF00FF00FFLL), (int16x4_t)0xFF00FF00FF00FFLL)));
            int32x4_t v43 = (int32x4_t)vandq_s8(v42, (int8x16_t)vcgtq_u32(vmovl_u16(v39), v41));
            v43.i32[0] = vmaxvq_u32((uint32x4_t)v43);
            int v44 = v43.i32[0];
            if (v43.i32[0] < 0) {
              return 0;
            }
            int32x4_t v45 = (int32x4_t)vandq_s8(vandq_s8((int8x16_t)vsubw_u16(v41, v39), v42), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v43, v6), 0));
            int16x4_t v46 = (int16x4_t)vmovn_s16(v5);
            v46.i16[2] = v46.i16[1];
            __int32 v96 = v46.i32[0];
            v5.i32[0] = v46.u16[0];
            uint8x8_t v47 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v5.i8);
            v47.i16[0] = vaddlv_u8(v47);
            unsigned __int32 v48 = v47.i32[0];
            int16x8_t v49 = vdupq_lane_s16(v46, 0);
            *(int8x8_t *)v50.i8 = vmovn_s16(v49);
            v50.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v49.i8, *(int8x8_t *)v49.i8);
            int8x16_t v51 = (int8x16_t)vshlq_u8(v50, v12);
            int8x16_t v52 = vcgtq_s8(v51, v13);
            int8x16_t v53 = vcntq_s8(v51);
            v53.u64[1] = (unint64_t)vadd_s8((int8x8_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL), vdup_lane_s8(*(int8x8_t *)v53.i8, 7));
            int8x16_t v54 = vorrq_s8(vaddq_s8(v53, v13), v52);
            int16x8_t v5 = (int16x8_t)vqtbl1q_s8(*a3, v54);
            int16x8_t v55 = vdupq_lane_s16(v46, 2);
            int8x16_t v56 = vceqq_s8(v54, v13);
            *(int8x8_t *)v57.i8 = vmovn_s16(v55);
            v57.u64[1] = (unint64_t)vuzp2_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v55.i8);
            int8x16_t v58 = (int8x16_t)vshlq_u8(v57, v12);
            int8x16_t v59 = vcgtq_s8(v58, v13);
            int8x16_t v60 = vcntq_s8(v58);
            v60.u64[1] = (unint64_t)vadd_s8((int8x8_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL), vdup_lane_s8(*(int8x8_t *)v60.i8, 7));
            int8x16_t v61 = vorrq_s8(vaddq_s8(v60, v13), v59);
            int8x16_t v62 = vqtbl1q_s8(*(int8x16_t *)((char *)a3 + v48), v61);
            int8x16_t v63 = vceqq_s8(v61, v13);
            if ((vminvq_u32(vcgeq_u32((uint32x4_t)v40, (uint32x4_t)vaddq_s32(v45, v15))) & 0x80000000) == 0)
            {
              int v64 = 0;
              int8x8_t v65 = (int8x8_t)vextq_s8(v62, v62, 8uLL).u64[0];
              int8x8_t v66 = (int8x8_t)vextq_s8(v63, v63, 8uLL).u64[0];
              int8x8_t v67 = (int8x8_t)vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL).u64[0];
              int8x8_t v68 = (int8x8_t)vextq_s8(v56, v56, 8uLL).u64[0];
              while (1)
              {
                int32x4_t v95 = v45;
                int8x8_t v69 = *(int8x8_t *)(a1
                                  + *(unsigned int *)((unint64_t)&v95 & 0xFFFFFFFFFFFFFFF3 | (4 * (v64 & 3))));
                switch(v64)
                {
                  case 0:
                    int8x8_t v70 = vorr_s8(vand_s8(v69, *(int8x8_t *)v56.i8), *(int8x8_t *)v5.i8);
                    goto LABEL_24;
                  case 1:
                    int8x8_t v70 = vorr_s8(vand_s8(v69, v68), v67);
                    goto LABEL_24;
                  case 2:
                    int8x8_t v70 = vorr_s8(vand_s8(v69, *(int8x8_t *)v63.i8), *(int8x8_t *)v62.i8);
                    goto LABEL_24;
                  case 3:
                    *(int8x8_t *)(a1 + v9) = vorr_s8(vand_s8(v69, v66), v65);
                    uint64_t v9 = (v9 + 8);
                    goto LABEL_27;
                  default:
                    int8x8_t v70 = 0;
LABEL_24:
                    *(int8x8_t *)(a1 + v9) = v70;
                    LODWORD(v9) = v9 + 8;
                    ++v64;
                    break;
                }
              }
            }
            v71.i64[0] = v45.u32[2];
            v71.i64[1] = v45.u32[3];
            int8x16_t v72 = v71;
            v71.i64[1] = v45.u32[1];
            v73.i64[0] = *(void *)(a1 + v45.u32[0]);
            v72.i64[0] = *(void *)(a1 + v72.i64[0]);
            v73.i64[1] = *(void *)(a1 + v71.i64[1]);
            v72.i64[1] = *(void *)(a1 + v72.i64[1]);
            int8x16_t v74 = vorrq_s8(vandq_s8(v73, v56), (int8x16_t)v5);
            int16x8_t v5 = (int16x8_t)vorrq_s8(vandq_s8(v72, v63), v62);
            uint64_t v75 = (int8x16_t *)(a1 + v9);
            *uint64_t v75 = v74;
            v75[1] = (int8x16_t)v5;
            uint64_t v9 = (v9 + 32);
LABEL_27:
            v16 &= ~(v44 >> 31);
            v46.i32[0] = v46.u16[1];
            uint8x8_t v76 = (uint8x8_t)vcnt_s8((int8x8_t)v46);
            v76.i16[0] = vaddlv_u8(v76);
            a3 = (int8x16_t *)((char *)a3 + v76.i32[0] + v48);
            if (v26 <= 2)
            {
              ++v26;
              if (v9 < v7) {
                continue;
              }
            }
            break;
          }
        }
      }
LABEL_54:
      if (v9 >= v7)
      {
LABEL_55:
        uint64_t v7 = v9;
        if (v16) {
          return v7;
        }
        return 0;
      }
    }
  }
  return v7;
}

uint64_t read_expected(int a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  if (a3)
  {
    unint64_t v6 = 0;
    while (1)
    {
      ssize_t v7 = read(a1, (void *)(a2 + v6), v3 - v6);
      if (v7 <= 0) {
        break;
      }
      v6 += v7;
      if (v6 >= v3) {
        return v3;
      }
    }
    if (v7) {
      return -1;
    }
    else {
      return v6;
    }
  }
  return v3;
}

uint64_t write_expected(int __fd, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  if (a3)
  {
    unint64_t v6 = 0;
    while (1)
    {
      ssize_t v7 = write(__fd, (const void *)(a2 + v6), v3 - v6);
      if (v7 <= 0) {
        break;
      }
      v6 += v7;
      if (v6 >= v3) {
        return v3;
      }
    }
    return -1;
  }
  return v3;
}

uint64_t parse_size(const char *a1)
{
  __endptr = 0;
  if ((*a1 - 48) > 9) {
    return -1;
  }
  uint64_t v1 = strtoll(a1, &__endptr, 10);
  int v2 = *__endptr;
  uint64_t v3 = -1;
  if (v2 <= 102)
  {
    if (!*__endptr || v2 == 98) {
      return v1;
    }
  }
  else
  {
    switch(v2)
    {
      case 'g':
        v1 <<= 30;
        return v1;
      case 'm':
        v1 <<= 20;
        return v1;
      case 'k':
        v1 <<= 10;
        return v1;
    }
  }
  return v3;
}

double get_real_time()
{
  v1.tv_sec = 0;
  *(void *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return (double)v1.tv_sec + (double)v1.tv_usec * 0.000001;
}

uint64_t get_default_nthreads()
{
  unsigned int v2 = 0;
  size_t v1 = 4;
  if (sysctlbyname("hw.physicalcpu", &v2, &v1, 0, 0)) {
    return 1;
  }
  else {
    return v2;
  }
}

__n128 lzma1_model_reset(__n128 *a1, void *__b)
{
  memset_pattern16(__b, &unk_20DAD6440, 0x7580uLL);
  result.n128_u64[0] = 0x100000001;
  result.n128_u64[1] = 0x100000001;
  *a1 = result;
  a1[1].n128_u64[0] = (unint64_t)__b;
  a1[1].n128_u8[13] = 0;
  return result;
}

uint64_t lzma1_chunk_decode(unsigned int *a1, unint64_t a2, unsigned char *a3, unsigned char *a4, unint64_t a5, unsigned __int8 *a6, uint64_t a7)
{
  ssize_t v7 = (unsigned __int16 *)*((void *)a1 + 2);
  if (!v7 || !a7) {
    return 0;
  }
  uint64_t v8 = *((unsigned __int8 *)a1 + 29);
  if (a7 < 1)
  {
    int v10 = 0;
    uint64_t v9 = a6;
  }
  else
  {
    uint64_t v9 = a6 + 1;
    int v10 = *a6;
  }
  unsigned int v11 = 0;
  unsigned int v613 = *((unsigned __int8 *)a1 + 28);
  int v610 = *((unsigned __int8 *)a1 + 27);
  uint8x16_t v12 = &a6[a7];
  int v13 = 4;
  char v611 = *((unsigned char *)a1 + 26);
  do
  {
    if (v9 >= v12)
    {
      int v14 = 0;
    }
    else
    {
      int v15 = *v9++;
      int v14 = v15;
    }
    unsigned int v11 = (v11 << 8) | v14;
    --v13;
  }
  while (v13);
  uint64_t v16 = 0;
  if (!v10 && v11 != -1)
  {
    if (a3 >= a4)
    {
      uint32x4_t v213 = a3;
      goto LABEL_830;
    }
    char v609 = 8 - v611;
    long long v607 = v7 + 1220;
    long long v608 = v7 + 690;
    unint64_t v17 = v7 + 1940;
    unsigned int v18 = -1;
    unsigned int v19 = a3;
    while (1)
    {
      if (!HIBYTE(v18))
      {
        if (v9 >= v12)
        {
          int v20 = 0;
        }
        else
        {
          int v21 = *v9++;
          int v20 = v21;
        }
        v18 <<= 8;
        unsigned int v11 = v20 | (v11 << 8);
      }
      int v22 = v19 - a2;
      unsigned int v23 = v613 & (v19 - a2);
      int8x16_t v24 = &v7[16 * v8 + v23];
      unsigned int v25 = *v24;
      unsigned int v26 = (v18 >> 11) * v25;
      unsigned int v27 = v11 - v26;
      if (v11 < v26)
      {
        *int8x16_t v24 = v25 + ((2048 - v25) >> 5);
        if ((unint64_t)v19 <= a2) {
          unsigned int v28 = 0;
        }
        else {
          unsigned int v28 = *(v19 - 1);
        }
        uint64_t v29 = (uint64_t)&v7[816 * ((v28 >> v609) | ((v22 & v610) << v611)) + 1956];
        if (!lzma_fsm_lut[v8])
        {
          int v30 = 0;
          int v31 = v19[-*a1];
          uint64_t v32 = (uint64_t)&v7[816 * ((v28 >> v609) | ((v22 & v610) << v611)) + 2724];
          unsigned int v33 = v31 & 0xF0;
          unsigned int v34 = 1;
          do
          {
            int v35 = v30 - 3;
            if (v30 > 3) {
              break;
            }
            if (!HIBYTE(v26))
            {
              if (v9 >= v12)
              {
                int v36 = 0;
              }
              else
              {
                int v37 = *v9++;
                int v36 = v37;
              }
              v26 <<= 8;
              unsigned int v11 = v36 | (v11 << 8);
            }
            int v38 = 2 * v34;
            uint64_t v39 = ((2 * v34) | (v33 >> 7) & 1) + 16;
            unsigned int v40 = *(unsigned __int16 *)(v32 + 2 * v39);
            int v41 = (v33 >> 7) & 1;
            unsigned int v42 = (v26 >> 11) * v40;
            unsigned int v43 = v40 + ((2048 - v40) >> 5);
            v26 -= v42;
            unsigned int v44 = v40 - (v40 >> 5);
            BOOL v45 = v11 >= v42;
            unsigned int v34 = v11 >= v42 ? v38 | 1 : v38;
            if (v11 >= v42) {
              v11 -= v42;
            }
            else {
              unsigned int v26 = v42;
            }
            __int16 v46 = v45 ? v44 : v43;
            int v47 = v45;
            *(_WORD *)(v32 + 2 * v39) = v46;
            if (v47 == v41)
            {
              ++v30;
            }
            else
            {
              if (v30 > 2) {
                break;
              }
              do
              {
                if (!HIBYTE(v26))
                {
                  if (v9 >= v12)
                  {
                    int v48 = 0;
                  }
                  else
                  {
                    int v49 = *v9++;
                    int v48 = v49;
                  }
                  v26 <<= 8;
                  unsigned int v11 = v48 | (v11 << 8);
                }
                unsigned int v50 = *(unsigned __int16 *)(v32 + 2 * v34);
                uint64_t v51 = v34;
                unsigned int v52 = (v26 >> 11) * v50;
                v34 *= 2;
                unsigned int v53 = v50 + ((2048 - v50) >> 5);
                unsigned int v54 = v50 - (v50 >> 5);
                BOOL v55 = v11 >= v52;
                if (v11 < v52)
                {
                  unsigned int v26 = v52;
                }
                else
                {
                  v34 |= 1u;
                  v26 -= v52;
                }
                if (v11 >= v52) {
                  v11 -= v52;
                }
                if (!v55) {
                  LOWORD(v54) = v53;
                }
                *(_WORD *)(v32 + 2 * v51) = v54;
                BOOL v45 = __CFADD__(v35++, 1);
              }
              while (!v45);
              int v30 = 4;
            }
            v33 *= 2;
          }
          while (v47 == v41);
          int v57 = 16 * (v34 ^ 0x10);
          if ((v31 ^ v57) <= 0xF)
          {
            int v58 = 0;
            uint64_t v59 = v29 + 96 * (v34 ^ 0x10);
            unsigned int v60 = 16 * v31;
            unsigned int v61 = 1;
            do
            {
              int v62 = v58 - 3;
              if (v58 > 3) {
                break;
              }
              if (!HIBYTE(v26))
              {
                if (v9 >= v12)
                {
                  int v63 = 0;
                }
                else
                {
                  int v64 = *v9++;
                  int v63 = v64;
                }
                v26 <<= 8;
                unsigned int v11 = v63 | (v11 << 8);
              }
              int v65 = 2 * v61;
              uint64_t v66 = ((2 * v61) | (v60 >> 7) & 1) + 16;
              unsigned int v67 = *(unsigned __int16 *)(v59 + 2 * v66);
              int v68 = (v60 >> 7) & 1;
              unsigned int v69 = (v26 >> 11) * v67;
              unsigned int v70 = v67 + ((2048 - v67) >> 5);
              unsigned int v61 = (2 * v61) | 1;
              unsigned int v71 = v67 - (v67 >> 5);
              BOOL v72 = v11 >= v69;
              if (v11 >= v69)
              {
                v26 -= v69;
              }
              else
              {
                unsigned int v61 = v65;
                unsigned int v26 = v69;
              }
              if (v11 >= v69) {
                v11 -= v69;
              }
              __int16 v73 = v72 ? v71 : v70;
              int v74 = v72;
              *(_WORD *)(v59 + 2 * v66) = v73;
              if (v74 == v68)
              {
                ++v58;
              }
              else
              {
                if (v58 > 2) {
                  break;
                }
                do
                {
                  if (!HIBYTE(v26))
                  {
                    if (v9 >= v12)
                    {
                      int v75 = 0;
                    }
                    else
                    {
                      int v76 = *v9++;
                      int v75 = v76;
                    }
                    v26 <<= 8;
                    unsigned int v11 = v75 | (v11 << 8);
                  }
                  unsigned int v77 = *(unsigned __int16 *)(v59 + 2 * v61);
                  uint64_t v78 = v61;
                  unsigned int v79 = (v26 >> 11) * v77;
                  v61 *= 2;
                  unsigned int v80 = v77 + ((2048 - v77) >> 5);
                  unsigned int v81 = v77 - (v77 >> 5);
                  BOOL v82 = v11 >= v79;
                  if (v11 < v79)
                  {
                    unsigned int v26 = v79;
                  }
                  else
                  {
                    v61 |= 1u;
                    v26 -= v79;
                  }
                  if (v11 >= v79) {
                    v11 -= v79;
                  }
                  if (!v82) {
                    LOWORD(v81) = v80;
                  }
                  *(_WORD *)(v59 + 2 * v78) = v81;
                  BOOL v45 = __CFADD__(v62++, 1);
                }
                while (!v45);
                int v58 = 4;
              }
              v60 *= 2;
            }
            while (v74 == v68);
            int v83 = v61 ^ 0x10;
            goto LABEL_199;
          }
          goto LABEL_153;
        }
        while (1)
        {
          uint64_t v84 = v29 + 1536;
          unsigned int v85 = *(unsigned __int16 *)(v29 + 1538);
          if (!HIBYTE(v26))
          {
            if (v9 >= v12)
            {
              int v86 = 0;
            }
            else
            {
              int v87 = *v9++;
              int v86 = v87;
            }
            v26 <<= 8;
            unsigned int v11 = v86 | (v11 << 8);
          }
          unsigned int v88 = (v26 >> 11) * v85;
          unsigned int v89 = v85 + ((2048 - v85) >> 5);
          unsigned int v90 = v26 - v88;
          unsigned int v91 = v11 - v88;
          unsigned int v92 = v85 - (v85 >> 5);
          if (v11 >= v88) {
            uint64_t v93 = 3;
          }
          else {
            uint64_t v93 = 2;
          }
          if (v11 >= v88)
          {
            __int16 v94 = v92;
          }
          else
          {
            unsigned int v90 = v88;
            unsigned int v91 = v11;
            __int16 v94 = v89;
          }
          *(_WORD *)(v29 + 1538) = v94;
          unsigned int v95 = *(unsigned __int16 *)(v84 + 2 * v93);
          if (!HIBYTE(v90))
          {
            if (v9 >= v12)
            {
              int v96 = 0;
            }
            else
            {
              int v97 = *v9++;
              int v96 = v97;
            }
            v90 <<= 8;
            unsigned int v91 = v96 | (v91 << 8);
          }
          unsigned int v98 = (v90 >> 11) * v95;
          unsigned int v99 = v95 + ((2048 - v95) >> 5);
          unsigned int v100 = v90 - v98;
          unsigned int v101 = v95 - (v95 >> 5);
          BOOL v102 = v91 >= v98;
          if (v91 >= v98) {
            uint64_t v103 = (2 * v93) | 1u;
          }
          else {
            uint64_t v103 = (2 * v93);
          }
          if (v91 >= v98) {
            unsigned int v104 = v100;
          }
          else {
            unsigned int v104 = v98;
          }
          if (v91 >= v98) {
            v91 -= v98;
          }
          if (v102) {
            __int16 v105 = v101;
          }
          else {
            __int16 v105 = v99;
          }
          *(_WORD *)(v84 + 2 * v93) = v105;
          unsigned int v106 = *(unsigned __int16 *)(v84 + 2 * v103);
          if (!HIBYTE(v104))
          {
            if (v9 >= v12)
            {
              int v107 = 0;
            }
            else
            {
              int v108 = *v9++;
              int v107 = v108;
            }
            v104 <<= 8;
            unsigned int v91 = v107 | (v91 << 8);
          }
          unsigned int v109 = (v104 >> 11) * v106;
          unsigned int v110 = v106 + ((2048 - v106) >> 5);
          unsigned int v111 = v104 - v109;
          unsigned int v112 = v106 - (v106 >> 5);
          if (v91 >= v109) {
            uint64_t v113 = (2 * v103) | 1u;
          }
          else {
            uint64_t v113 = (2 * v103);
          }
          if (v91 >= v109)
          {
            unsigned int v11 = v91 - v109;
          }
          else
          {
            unsigned int v111 = v109;
            unsigned int v11 = v91;
          }
          if (v91 >= v109) {
            __int16 v114 = v112;
          }
          else {
            __int16 v114 = v110;
          }
          *(_WORD *)(v84 + 2 * v103) = v114;
          unsigned int v115 = *(unsigned __int16 *)(v84 + 2 * v113);
          if (!HIBYTE(v111))
          {
            if (v9 >= v12)
            {
              int v116 = 0;
            }
            else
            {
              int v117 = *v9++;
              int v116 = v117;
            }
            v111 <<= 8;
            unsigned int v11 = v116 | (v11 << 8);
          }
          unsigned int v26 = (v111 >> 11) * v115;
          int v118 = 2 * v113;
          unsigned int v119 = v11 - v26;
          if (v11 >= v26)
          {
            v118 |= 1u;
            unsigned int v26 = v111 - v26;
            unsigned int v11 = v119;
            unsigned int v120 = v115 - (v115 >> 5);
          }
          else
          {
            unsigned int v120 = v115 + ((2048 - v115) >> 5);
          }
          *(_WORD *)(v84 + 2 * v113) = v120;
          int v57 = (16 * v118) ^ 0x100;
LABEL_153:
          uint64_t v121 = v29 + 2 * (3 * v57);
          unsigned int v122 = *(unsigned __int16 *)(v121 + 2);
          if (!HIBYTE(v26))
          {
            if (v9 >= v12)
            {
              int v123 = 0;
            }
            else
            {
              int v124 = *v9++;
              int v123 = v124;
            }
            v26 <<= 8;
            unsigned int v11 = v123 | (v11 << 8);
          }
          unsigned int v125 = (v26 >> 11) * v122;
          unsigned int v126 = v122 + ((2048 - v122) >> 5);
          unsigned int v127 = v26 - v125;
          unsigned int v128 = v11 - v125;
          unsigned int v129 = v122 - (v122 >> 5);
          if (v11 >= v125) {
            uint64_t v130 = 3;
          }
          else {
            uint64_t v130 = 2;
          }
          if (v11 >= v125)
          {
            __int16 v131 = v129;
          }
          else
          {
            unsigned int v127 = v125;
            unsigned int v128 = v11;
            __int16 v131 = v126;
          }
          *(_WORD *)(v121 + 2) = v131;
          unsigned int v132 = *(unsigned __int16 *)(v121 + 2 * v130);
          if (!HIBYTE(v127))
          {
            if (v9 >= v12)
            {
              int v133 = 0;
            }
            else
            {
              int v134 = *v9++;
              int v133 = v134;
            }
            v127 <<= 8;
            unsigned int v128 = v133 | (v128 << 8);
          }
          unsigned int v135 = (v127 >> 11) * v132;
          unsigned int v136 = v132 + ((2048 - v132) >> 5);
          unsigned int v137 = v127 - v135;
          unsigned int v138 = v132 - (v132 >> 5);
          BOOL v139 = v128 >= v135;
          if (v128 >= v135) {
            uint64_t v140 = (2 * v130) | 1u;
          }
          else {
            uint64_t v140 = (2 * v130);
          }
          if (v128 >= v135) {
            unsigned int v141 = v137;
          }
          else {
            unsigned int v141 = v135;
          }
          if (v128 >= v135) {
            v128 -= v135;
          }
          if (v139) {
            __int16 v142 = v138;
          }
          else {
            __int16 v142 = v136;
          }
          *(_WORD *)(v121 + 2 * v130) = v142;
          unsigned int v143 = *(unsigned __int16 *)(v121 + 2 * v140);
          if (!HIBYTE(v141))
          {
            if (v9 >= v12)
            {
              int v144 = 0;
            }
            else
            {
              int v145 = *v9++;
              int v144 = v145;
            }
            v141 <<= 8;
            unsigned int v128 = v144 | (v128 << 8);
          }
          unsigned int v146 = (v141 >> 11) * v143;
          unsigned int v147 = v143 + ((2048 - v143) >> 5);
          unsigned int v148 = v141 - v146;
          unsigned int v149 = v143 - (v143 >> 5);
          if (v128 >= v146) {
            uint64_t v150 = (2 * v140) | 1u;
          }
          else {
            uint64_t v150 = (2 * v140);
          }
          if (v128 >= v146)
          {
            unsigned int v11 = v128 - v146;
          }
          else
          {
            unsigned int v148 = v146;
            unsigned int v11 = v128;
          }
          if (v128 >= v146) {
            __int16 v151 = v149;
          }
          else {
            __int16 v151 = v147;
          }
          *(_WORD *)(v121 + 2 * v140) = v151;
          unsigned int v152 = *(unsigned __int16 *)(v121 + 2 * v150);
          if (!HIBYTE(v148))
          {
            if (v9 >= v12)
            {
              int v153 = 0;
            }
            else
            {
              int v154 = *v9++;
              int v153 = v154;
            }
            v148 <<= 8;
            unsigned int v11 = v153 | (v11 << 8);
          }
          unsigned int v26 = (v148 >> 11) * v152;
          int v155 = 2 * v150;
          unsigned int v156 = v11 - v26;
          if (v11 >= v26)
          {
            v155 |= 1u;
            unsigned int v26 = v148 - v26;
            unsigned int v11 = v156;
            unsigned int v157 = v152 - (v152 >> 5);
          }
          else
          {
            unsigned int v157 = v152 + ((2048 - v152) >> 5);
          }
          *(_WORD *)(v121 + 2 * v150) = v157;
          int v83 = v155 ^ 0x10;
LABEL_199:
          unsigned int v158 = v83 + v57;
          uint64_t v8 = lzma_fsm_lut[v8 + 12];
          *v19++ = v83 + v57;
          if (v19 == a4) {
            break;
          }
          unsigned int v23 = ++v22 & v613;
          int8x16_t v24 = &v7[16 * v8 + (v22 & v613)];
          unsigned int v25 = *v24;
          if (!HIBYTE(v26))
          {
            if (v9 >= v12)
            {
              int v159 = 0;
            }
            else
            {
              int v160 = *v9++;
              int v159 = v160;
            }
            v26 <<= 8;
            unsigned int v11 = v159 | (v11 << 8);
          }
          unsigned int v161 = (v26 >> 11) * v25;
          unsigned int v27 = v11 - v161;
          if (v11 >= v161)
          {
            unsigned int v56 = v26 - v161;
            goto LABEL_206;
          }
          *int8x16_t v24 = v25 + ((2048 - v25) >> 5);
          uint64_t v29 = (uint64_t)&v7[816 * (((v22 & v610) << v611) | (v158 >> v609)) + 1956];
          unsigned int v26 = (v26 >> 11) * v25;
        }
        uint32x4_t v213 = a4;
LABEL_830:
        uint64_t v16 = 0;
        if (!v11 && v213 == a4)
        {
          *((unsigned char *)a1 + 29) = v8;
          return a4 - a3;
        }
        return v16;
      }
      unsigned int v56 = v18 - v26;
LABEL_206:
      *int8x16_t v24 = v25 - (v25 >> 5);
      if (!HIBYTE(v56))
      {
        if (v9 >= v12)
        {
          int v162 = 0;
        }
        else
        {
          int v163 = *v9++;
          int v162 = v163;
        }
        v56 <<= 8;
        unsigned int v27 = v162 | (v27 << 8);
      }
      int8x16x2_t v164 = &v7[v8 + 192];
      int v165 = *v164;
      unsigned int v166 = (v56 >> 11) * v165;
      unsigned int v11 = v27 - v166;
      if (v27 >= v166)
      {
        *v164 -= *v164 >> 5;
        if (v19 == (unsigned char *)a2) {
          return 0;
        }
        unsigned int v201 = v56 - v166;
        if (!HIBYTE(v201))
        {
          if (v9 >= v12)
          {
            int v202 = 0;
          }
          else
          {
            int v203 = *v9++;
            int v202 = v203;
          }
          v201 <<= 8;
          unsigned int v11 = v202 | (v11 << 8);
        }
        long long v204 = &v7[v8 + 204];
        int v205 = *v204;
        unsigned int v206 = (v201 >> 11) * v205;
        unsigned int v207 = v11 - v206;
        if (v11 >= v206)
        {
          unsigned int v247 = v201 - v206;
          *v204 -= *v204 >> 5;
          if (!HIBYTE(v247))
          {
            if (v9 >= v12)
            {
              int v248 = 0;
            }
            else
            {
              int v249 = *v9++;
              int v248 = v249;
            }
            v247 <<= 8;
            unsigned int v207 = v248 | (v207 << 8);
          }
          unint64_t v250 = &v7[v8 + 408];
          int v251 = *v250;
          unsigned int v252 = (v247 >> 11) * v251;
          unsigned int v253 = v207 - v252;
          if (v207 >= v252)
          {
            unsigned int v293 = v247 - v252;
            *v250 -= *v250 >> 5;
            if (HIBYTE(v293))
            {
              v207 -= v252;
            }
            else
            {
              if (v9 >= v12)
              {
                int v294 = 0;
              }
              else
              {
                int v295 = *v9++;
                int v294 = v295;
              }
              v293 <<= 8;
              unsigned int v207 = v294 | (v253 << 8);
            }
            double v440 = &v7[v8];
            unsigned int v441 = v440[420];
            unsigned int v252 = (v293 >> 11) * v441;
            unsigned int v442 = v207 - v252;
            if (v207 >= v252)
            {
              unsigned int v252 = v293 - v252;
              unsigned int v443 = v441 - (v441 >> 5);
              LODWORD(v210) = a1[3];
              a1[3] = a1[2];
              unsigned int v207 = v442;
            }
            else
            {
              unsigned int v443 = v441 + ((2048 - v441) >> 5);
              LODWORD(v210) = a1[2];
            }
            v440[420] = v443;
            a1[2] = a1[1];
          }
          else
          {
            *unint64_t v250 = v251 + ((2048 - v251) >> 5);
            LODWORD(v210) = a1[1];
          }
          unsigned int v444 = *a1;
          *a1 = v210;
          a1[1] = v444;
        }
        else
        {
          *long long v204 = v205 + ((2048 - v205) >> 5);
          if (!HIBYTE(v206))
          {
            if (v9 >= v12)
            {
              int v208 = 0;
            }
            else
            {
              int v209 = *v9++;
              int v208 = v209;
            }
            v206 <<= 8;
            unsigned int v11 = v208 | (v11 << 8);
          }
          uint64_t v210 = *a1;
          uint32x4_t v211 = &v7[16 * v8 + 216 + v23];
          int v212 = *v211;
          unsigned int v18 = (v206 >> 11) * v212;
          unsigned int v207 = v11 - v18;
          if (v11 < v18)
          {
            *uint32x4_t v211 = v212 + ((2048 - v212) >> 5);
            unsigned char *v19 = v19[-v210];
            uint32x4_t v213 = v19 + 1;
            uint64_t v8 = lzma_fsm_lut[v8 + 48];
            goto LABEL_770;
          }
          unsigned int v252 = v206 - v18;
          *v211 -= *v211 >> 5;
        }
        int v445 = v7[962];
        if (!HIBYTE(v252))
        {
          if (v9 >= v12)
          {
            int v446 = 0;
          }
          else
          {
            int v447 = *v9++;
            int v446 = v447;
          }
          v252 <<= 8;
          unsigned int v207 = v446 | (v207 << 8);
        }
        unsigned int v448 = (v252 >> 11) * v445;
        unsigned int v449 = v207 - v448;
        if (v207 >= v448)
        {
          unsigned int v479 = v252 - v448;
          v7[962] -= v7[962] >> 5;
          if (!HIBYTE(v479))
          {
            if (v9 >= v12)
            {
              int v480 = 0;
            }
            else
            {
              int v481 = *v9++;
              int v480 = v481;
            }
            v479 <<= 8;
            unsigned int v449 = v480 | (v449 << 8);
          }
          int v482 = v7[963];
          unsigned int v483 = (v479 >> 11) * v482;
          unsigned int v484 = v449 - v483;
          if (v449 >= v483)
          {
            unsigned int v516 = v479 - v483;
            v7[963] -= v7[963] >> 5;
            if (!((v479 - v483) >> 24))
            {
              if (v9 >= v12)
              {
                int v517 = 0;
              }
              else
              {
                int v518 = *v9++;
                int v517 = v518;
              }
              v516 <<= 8;
              unsigned int v484 = v517 | (v484 << 8);
            }
            unsigned int v519 = v7[1221];
            unsigned int v520 = (v516 >> 11) * v519;
            unsigned int v521 = v519 + ((2048 - v519) >> 5);
            unsigned int v522 = v516 - v520;
            unsigned int v523 = v519 - (v519 >> 5);
            if (v484 >= v520) {
              uint64_t v524 = 3;
            }
            else {
              uint64_t v524 = 2;
            }
            if (v484 >= v520) {
              unsigned int v525 = v522;
            }
            else {
              unsigned int v525 = v520;
            }
            if (v484 >= v520) {
              unsigned int v526 = v484 - v520;
            }
            else {
              unsigned int v526 = v484;
            }
            if (v484 < v520) {
              LOWORD(v523) = v521;
            }
            v7[1221] = v523;
            if (!HIBYTE(v525))
            {
              if (v9 >= v12)
              {
                int v527 = 0;
              }
              else
              {
                int v528 = *v9++;
                int v527 = v528;
              }
              v525 <<= 8;
              unsigned int v526 = v527 | (v526 << 8);
            }
            unsigned int v529 = v607[v524];
            unsigned int v530 = (v525 >> 11) * v529;
            LODWORD(v531) = 2 * v524;
            unsigned int v532 = v529 + ((2048 - v529) >> 5);
            unsigned int v533 = v525 - v530;
            unsigned int v534 = v529 - (v529 >> 5);
            if (v526 >= v530) {
              uint64_t v531 = (2 * v524) | 1u;
            }
            else {
              uint64_t v531 = v531;
            }
            if (v526 >= v530) {
              unsigned int v535 = v533;
            }
            else {
              unsigned int v535 = v530;
            }
            if (v526 >= v530) {
              unsigned int v536 = v526 - v530;
            }
            else {
              unsigned int v536 = v526;
            }
            if (v526 < v530) {
              LOWORD(v534) = v532;
            }
            v607[v524] = v534;
            unsigned int v537 = v607[v531];
            if (!HIBYTE(v535))
            {
              if (v9 >= v12)
              {
                int v538 = 0;
              }
              else
              {
                int v539 = *v9++;
                int v538 = v539;
              }
              v535 <<= 8;
              unsigned int v536 = v538 | (v536 << 8);
            }
            unsigned int v540 = (v535 >> 11) * v537;
            unsigned int v541 = v537 + ((2048 - v537) >> 5);
            LODWORD(v542) = (2 * v531) | 1;
            unsigned int v543 = v535 - v540;
            unsigned int v544 = v537 - (v537 >> 5);
            if (v536 >= v540) {
              uint64_t v542 = v542;
            }
            else {
              uint64_t v542 = (2 * v531);
            }
            if (v536 >= v540)
            {
              unsigned int v545 = v536 - v540;
            }
            else
            {
              unsigned int v543 = v540;
              unsigned int v545 = v536;
            }
            if (v536 >= v540) {
              unsigned __int16 v546 = v544;
            }
            else {
              unsigned __int16 v546 = v541;
            }
            v607[v531] = v546;
            unsigned int v547 = v607[v542];
            if (!HIBYTE(v543))
            {
              if (v9 >= v12)
              {
                int v548 = 0;
              }
              else
              {
                int v549 = *v9++;
                int v548 = v549;
              }
              v543 <<= 8;
              unsigned int v545 = v548 | (v545 << 8);
            }
            unsigned int v550 = (v543 >> 11) * v547;
            int v551 = 2 * v542;
            unsigned int v552 = v545 - v550;
            if (v545 >= v550)
            {
              v551 |= 1u;
              unsigned int v550 = v543 - v550;
              unsigned int v545 = v552;
              unsigned int v553 = v547 - (v547 >> 5);
            }
            else
            {
              unsigned int v553 = v547 + ((2048 - v547) >> 5);
            }
            v607[v542] = v553;
            uint64_t v554 = v551 ^ 0x10u;
            long long v555 = &v7[16 * v554];
            unsigned int v556 = v555[1237];
            if (!HIBYTE(v550))
            {
              if (v9 >= v12)
              {
                int v557 = 0;
              }
              else
              {
                int v558 = *v9++;
                int v557 = v558;
              }
              v550 <<= 8;
              unsigned int v545 = v557 | (v545 << 8);
            }
            long long v559 = v555 + 1236;
            unsigned int v560 = (v550 >> 11) * v556;
            unsigned int v561 = v556 + ((2048 - v556) >> 5);
            unsigned int v562 = v550 - v560;
            unsigned int v563 = v556 - (v556 >> 5);
            BOOL v564 = v545 >= v560;
            if (v545 >= v560) {
              uint64_t v565 = 3;
            }
            else {
              uint64_t v565 = 2;
            }
            if (v545 >= v560) {
              unsigned int v566 = v562;
            }
            else {
              unsigned int v566 = v560;
            }
            if (v545 >= v560) {
              v545 -= v560;
            }
            if (v564) {
              unsigned __int16 v567 = v563;
            }
            else {
              unsigned __int16 v567 = v561;
            }
            v559[1] = v567;
            unsigned int v568 = v559[v565];
            if (!HIBYTE(v566))
            {
              if (v9 >= v12)
              {
                int v569 = 0;
              }
              else
              {
                int v570 = *v9++;
                int v569 = v570;
              }
              v566 <<= 8;
              unsigned int v545 = v569 | (v545 << 8);
            }
            unsigned int v571 = (v566 >> 11) * v568;
            unsigned int v572 = v568 + ((2048 - v568) >> 5);
            unsigned int v573 = v566 - v571;
            unsigned int v574 = v568 - (v568 >> 5);
            if (v545 >= v571) {
              uint64_t v575 = (2 * v565) | 1u;
            }
            else {
              uint64_t v575 = (2 * v565);
            }
            if (v545 >= v571) {
              unsigned int v576 = v573;
            }
            else {
              unsigned int v576 = v571;
            }
            if (v545 >= v571) {
              unsigned int v577 = v545 - v571;
            }
            else {
              unsigned int v577 = v545;
            }
            if (v545 >= v571) {
              unsigned __int16 v578 = v574;
            }
            else {
              unsigned __int16 v578 = v572;
            }
            v559[v565] = v578;
            unsigned int v579 = v559[v575];
            if (!HIBYTE(v576))
            {
              if (v9 >= v12)
              {
                int v580 = 0;
              }
              else
              {
                int v581 = *v9++;
                int v580 = v581;
              }
              v576 <<= 8;
              unsigned int v577 = v580 | (v577 << 8);
            }
            unsigned int v582 = (v576 >> 11) * v579;
            unsigned int v583 = v579 + ((2048 - v579) >> 5);
            unsigned int v584 = v576 - v582;
            unsigned int v585 = v579 - (v579 >> 5);
            if (v577 >= v582) {
              uint64_t v586 = (2 * v575) | 1u;
            }
            else {
              uint64_t v586 = (2 * v575);
            }
            if (v577 >= v582)
            {
              unsigned int v11 = v577 - v582;
            }
            else
            {
              unsigned int v584 = v582;
              unsigned int v11 = v577;
            }
            if (v577 >= v582) {
              unsigned __int16 v587 = v585;
            }
            else {
              unsigned __int16 v587 = v583;
            }
            v559[v575] = v587;
            unsigned int v588 = v559[v586];
            if (!HIBYTE(v584))
            {
              if (v9 >= v12)
              {
                int v589 = 0;
              }
              else
              {
                int v590 = *v9++;
                int v589 = v590;
              }
              v584 <<= 8;
              unsigned int v11 = v589 | (v11 << 8);
            }
            unsigned int v18 = (v584 >> 11) * v588;
            int v591 = 2 * v586;
            unsigned int v592 = v11 - v18;
            if (v11 >= v18)
            {
              v591 |= 1u;
              unsigned int v18 = v584 - v18;
              unsigned int v11 = v592;
              unsigned int v593 = v588 - (v588 >> 5);
            }
            else
            {
              unsigned int v593 = v588 + ((2048 - v588) >> 5);
            }
            v559[v586] = v593;
            unsigned int v254 = (v591 ^ 0x10) + 16 * v554 + 18;
          }
          else
          {
            v7[963] = v482 + ((2048 - v482) >> 5);
            if (!HIBYTE(v483))
            {
              if (v9 >= v12)
              {
                int v485 = 0;
              }
              else
              {
                int v486 = *v9++;
                int v485 = v486;
              }
              v483 <<= 8;
              unsigned int v449 = v485 | (v449 << 8);
            }
            unint64_t v487 = &v7[8 * v23];
            size_t v488 = v487 + 1092;
            LODWORD(v487) = v487[1093];
            unsigned int v489 = (v483 >> 11) * v487;
            unsigned int v490 = v487 + ((2048 - v487) >> 5);
            unsigned int v491 = v483 - v489;
            unsigned int v492 = v487 - (v487 >> 5);
            if (v449 >= v489) {
              uint64_t v493 = 3;
            }
            else {
              uint64_t v493 = 2;
            }
            if (v449 >= v489) {
              unsigned int v494 = v491;
            }
            else {
              unsigned int v494 = v489;
            }
            if (v449 >= v489) {
              unsigned int v495 = v449 - v489;
            }
            else {
              unsigned int v495 = v449;
            }
            if (v449 >= v489) {
              unsigned __int16 v496 = v492;
            }
            else {
              unsigned __int16 v496 = v490;
            }
            v488[1] = v496;
            if (!HIBYTE(v494))
            {
              if (v9 >= v12)
              {
                int v497 = 0;
              }
              else
              {
                int v498 = *v9++;
                int v497 = v498;
              }
              v494 <<= 8;
              unsigned int v495 = v497 | (v495 << 8);
            }
            unsigned int v499 = v488[v493];
            unsigned int v500 = (v494 >> 11) * v499;
            unsigned int v501 = v499 + ((2048 - v499) >> 5);
            unsigned int v502 = v494 - v500;
            unsigned int v503 = v499 - (v499 >> 5);
            BOOL v504 = v495 >= v500;
            if (v495 >= v500) {
              uint64_t v505 = (2 * v493) | 1u;
            }
            else {
              uint64_t v505 = (2 * v493);
            }
            if (v495 >= v500) {
              v495 -= v500;
            }
            else {
              unsigned int v502 = v500;
            }
            if (v504) {
              unsigned __int16 v506 = v503;
            }
            else {
              unsigned __int16 v506 = v501;
            }
            v488[v493] = v506;
            unsigned int v507 = v488[v505];
            if (!HIBYTE(v502))
            {
              if (v9 >= v12)
              {
                int v508 = 0;
              }
              else
              {
                int v509 = *v9++;
                int v508 = v509;
              }
              v502 <<= 8;
              unsigned int v495 = v508 | (v495 << 8);
            }
            unsigned int v510 = (v502 >> 11) * v507;
            int v511 = 2 * v505;
            unsigned int v512 = v507 + ((2048 - v507) >> 5);
            unsigned int v513 = v502 - v510;
            unsigned int v514 = v507 - (v507 >> 5);
            if (v495 < v510)
            {
              unsigned int v18 = v510;
            }
            else
            {
              int v511 = (2 * v505) | 1;
              unsigned int v18 = v513;
            }
            if (v495 >= v510) {
              unsigned int v11 = v495 - v510;
            }
            else {
              unsigned int v11 = v495;
            }
            if (v495 >= v510) {
              unsigned __int16 v515 = v514;
            }
            else {
              unsigned __int16 v515 = v512;
            }
            v488[v505] = v515;
            unsigned int v254 = (v511 ^ 8) + 10;
          }
        }
        else
        {
          v7[962] = v445 + ((2048 - v445) >> 5);
          if (!HIBYTE(v448))
          {
            if (v9 >= v12)
            {
              int v450 = 0;
            }
            else
            {
              int v451 = *v9++;
              int v450 = v451;
            }
            v448 <<= 8;
            unsigned int v207 = v450 | (v207 << 8);
          }
          uint64_t v452 = (uint64_t)&v7[8 * v23 + 962];
          uint64_t v453 = v452 + 4;
          LODWORD(v452) = *(unsigned __int16 *)(v452 + 6);
          unsigned int v454 = (v448 >> 11) * v452;
          int v455 = v452 + ((2048 - v452) >> 5);
          unsigned int v456 = v448 - v454;
          unsigned int v457 = v207 - v454;
          int v458 = v452 - (v452 >> 5);
          if (v207 >= v454) {
            uint64_t v459 = 3;
          }
          else {
            uint64_t v459 = 2;
          }
          if (v207 >= v454)
          {
            __int16 v460 = v458;
          }
          else
          {
            unsigned int v456 = v454;
            unsigned int v457 = v207;
            __int16 v460 = v455;
          }
          *(_WORD *)(v453 + 2) = v460;
          if (!HIBYTE(v456))
          {
            if (v9 >= v12)
            {
              int v461 = 0;
            }
            else
            {
              int v462 = *v9++;
              int v461 = v462;
            }
            v456 <<= 8;
            unsigned int v457 = v461 | (v457 << 8);
          }
          unsigned int v463 = *(unsigned __int16 *)(v453 + 2 * v459);
          unsigned int v464 = (v456 >> 11) * v463;
          unsigned int v465 = v463 + ((2048 - v463) >> 5);
          unsigned int v466 = v456 - v464;
          unsigned int v467 = v463 - (v463 >> 5);
          BOOL v468 = v457 >= v464;
          if (v457 >= v464) {
            uint64_t v469 = (2 * v459) | 1u;
          }
          else {
            uint64_t v469 = (2 * v459);
          }
          if (v457 >= v464) {
            unsigned int v470 = v466;
          }
          else {
            unsigned int v470 = v464;
          }
          if (v457 >= v464) {
            v457 -= v464;
          }
          if (!v468) {
            LOWORD(v467) = v465;
          }
          *(_WORD *)(v453 + 2 * v459) = v467;
          unsigned int v471 = *(unsigned __int16 *)(v453 + 2 * v469);
          if (!HIBYTE(v470))
          {
            if (v9 >= v12)
            {
              int v472 = 0;
            }
            else
            {
              int v473 = *v9++;
              int v472 = v473;
            }
            v470 <<= 8;
            unsigned int v457 = v472 | (v457 << 8);
          }
          unsigned int v474 = (v470 >> 11) * v471;
          int v475 = 2 * v469;
          unsigned int v476 = v471 + ((2048 - v471) >> 5);
          unsigned int v477 = v470 - v474;
          unsigned int v478 = v471 - (v471 >> 5);
          if (v457 < v474)
          {
            unsigned int v18 = v474;
          }
          else
          {
            int v475 = (2 * v469) | 1;
            unsigned int v18 = v477;
          }
          if (v457 >= v474) {
            unsigned int v11 = v457 - v474;
          }
          else {
            unsigned int v11 = v457;
          }
          if (v457 < v474) {
            LOWORD(v478) = v476;
          }
          *(_WORD *)(v453 + 2 * v469) = v478;
          unsigned int v254 = (v475 ^ 8) + 2;
        }
        uint64_t v8 = lzma_fsm_lut[v8 + 36];
      }
      else
      {
        *int8x16x2_t v164 = v165 + ((2048 - v165) >> 5);
        if (!HIBYTE(v166))
        {
          if (v9 >= v12)
          {
            int v167 = 0;
          }
          else
          {
            int v168 = *v9++;
            int v167 = v168;
          }
          v166 <<= 8;
          unsigned int v27 = v167 | (v27 << 8);
        }
        int v169 = v7[432];
        unsigned int v170 = (v166 >> 11) * v169;
        unsigned int v171 = v27 - v170;
        if (v27 >= v170)
        {
          unsigned int v214 = v166 - v170;
          v7[432] -= v7[432] >> 5;
          if (!HIBYTE(v214))
          {
            if (v9 >= v12)
            {
              int v215 = 0;
            }
            else
            {
              int v216 = *v9++;
              int v215 = v216;
            }
            v214 <<= 8;
            unsigned int v171 = v215 | (v171 << 8);
          }
          int v217 = v7[433];
          unsigned int v218 = (v214 >> 11) * v217;
          unsigned int v219 = v171 - v218;
          if (v171 >= v218)
          {
            unsigned int v255 = v214 - v218;
            v7[433] -= v7[433] >> 5;
            if (!((v214 - v218) >> 24))
            {
              if (v9 >= v12)
              {
                int v256 = 0;
              }
              else
              {
                int v257 = *v9++;
                int v256 = v257;
              }
              v255 <<= 8;
              unsigned int v219 = v256 | (v219 << 8);
            }
            unsigned int v258 = v7[691];
            unsigned int v259 = (v255 >> 11) * v258;
            unsigned int v260 = v258 + ((2048 - v258) >> 5);
            unsigned int v261 = v255 - v259;
            unsigned int v262 = v258 - (v258 >> 5);
            if (v219 >= v259) {
              uint64_t v263 = 3;
            }
            else {
              uint64_t v263 = 2;
            }
            if (v219 >= v259) {
              unsigned int v264 = v261;
            }
            else {
              unsigned int v264 = v259;
            }
            if (v219 >= v259) {
              unsigned int v265 = v219 - v259;
            }
            else {
              unsigned int v265 = v219;
            }
            if (v219 < v259) {
              LOWORD(v262) = v260;
            }
            v7[691] = v262;
            if (!HIBYTE(v264))
            {
              if (v9 >= v12)
              {
                int v266 = 0;
              }
              else
              {
                int v267 = *v9++;
                int v266 = v267;
              }
              v264 <<= 8;
              unsigned int v265 = v266 | (v265 << 8);
            }
            unsigned int v268 = v608[v263];
            unsigned int v269 = (v264 >> 11) * v268;
            LODWORD(v270) = 2 * v263;
            unsigned int v271 = v268 + ((2048 - v268) >> 5);
            unsigned int v272 = v264 - v269;
            unsigned int v273 = v268 - (v268 >> 5);
            if (v265 >= v269) {
              uint64_t v270 = (2 * v263) | 1u;
            }
            else {
              uint64_t v270 = v270;
            }
            if (v265 >= v269) {
              unsigned int v274 = v272;
            }
            else {
              unsigned int v274 = v269;
            }
            if (v265 >= v269) {
              unsigned int v275 = v265 - v269;
            }
            else {
              unsigned int v275 = v265;
            }
            if (v265 < v269) {
              LOWORD(v273) = v271;
            }
            v608[v263] = v273;
            unsigned int v276 = v608[v270];
            if (!HIBYTE(v274))
            {
              if (v9 >= v12)
              {
                int v277 = 0;
              }
              else
              {
                int v278 = *v9++;
                int v277 = v278;
              }
              v274 <<= 8;
              unsigned int v275 = v277 | (v275 << 8);
            }
            unsigned int v279 = (v274 >> 11) * v276;
            unsigned int v280 = v276 + ((2048 - v276) >> 5);
            LODWORD(v281) = (2 * v270) | 1;
            unsigned int v282 = v274 - v279;
            unsigned int v283 = v276 - (v276 >> 5);
            if (v275 >= v279) {
              uint64_t v281 = v281;
            }
            else {
              uint64_t v281 = (2 * v270);
            }
            if (v275 >= v279)
            {
              unsigned int v284 = v275 - v279;
            }
            else
            {
              unsigned int v282 = v279;
              unsigned int v284 = v275;
            }
            if (v275 >= v279) {
              unsigned __int16 v285 = v283;
            }
            else {
              unsigned __int16 v285 = v280;
            }
            v608[v270] = v285;
            unsigned int v286 = v608[v281];
            if (!HIBYTE(v282))
            {
              if (v9 >= v12)
              {
                int v287 = 0;
              }
              else
              {
                int v288 = *v9++;
                int v287 = v288;
              }
              v282 <<= 8;
              unsigned int v284 = v287 | (v284 << 8);
            }
            unsigned int v289 = (v282 >> 11) * v286;
            int v290 = 2 * v281;
            unsigned int v291 = v284 - v289;
            if (v284 >= v289)
            {
              v290 |= 1u;
              unsigned int v289 = v282 - v289;
              unsigned int v284 = v291;
              unsigned int v292 = v286 - (v286 >> 5);
            }
            else
            {
              unsigned int v292 = v286 + ((2048 - v286) >> 5);
            }
            v608[v281] = v292;
            uint64_t v296 = v290 ^ 0x10u;
            v297 = &v7[16 * v296];
            unsigned int v298 = v297[707];
            if (!HIBYTE(v289))
            {
              if (v9 >= v12)
              {
                int v299 = 0;
              }
              else
              {
                int v300 = *v9++;
                int v299 = v300;
              }
              v289 <<= 8;
              unsigned int v284 = v299 | (v284 << 8);
            }
            unint64_t v301 = v297 + 706;
            unsigned int v302 = (v289 >> 11) * v298;
            unsigned int v303 = v298 + ((2048 - v298) >> 5);
            unsigned int v304 = v289 - v302;
            unsigned int v305 = v298 - (v298 >> 5);
            BOOL v306 = v284 >= v302;
            if (v284 >= v302) {
              uint64_t v307 = 3;
            }
            else {
              uint64_t v307 = 2;
            }
            if (v284 >= v302) {
              unsigned int v308 = v304;
            }
            else {
              unsigned int v308 = v302;
            }
            if (v284 >= v302) {
              v284 -= v302;
            }
            if (v306) {
              unsigned __int16 v309 = v305;
            }
            else {
              unsigned __int16 v309 = v303;
            }
            v301[1] = v309;
            unsigned int v310 = v301[v307];
            if (!HIBYTE(v308))
            {
              if (v9 >= v12)
              {
                int v311 = 0;
              }
              else
              {
                int v312 = *v9++;
                int v311 = v312;
              }
              v308 <<= 8;
              unsigned int v284 = v311 | (v284 << 8);
            }
            unsigned int v313 = (v308 >> 11) * v310;
            unsigned int v314 = v310 + ((2048 - v310) >> 5);
            unsigned int v315 = v308 - v313;
            unsigned int v316 = v310 - (v310 >> 5);
            if (v284 >= v313) {
              uint64_t v317 = (2 * v307) | 1u;
            }
            else {
              uint64_t v317 = (2 * v307);
            }
            if (v284 >= v313) {
              unsigned int v318 = v315;
            }
            else {
              unsigned int v318 = v313;
            }
            if (v284 >= v313) {
              unsigned int v319 = v284 - v313;
            }
            else {
              unsigned int v319 = v284;
            }
            if (v284 >= v313) {
              unsigned __int16 v320 = v316;
            }
            else {
              unsigned __int16 v320 = v314;
            }
            v301[v307] = v320;
            unsigned int v321 = v301[v317];
            if (!HIBYTE(v318))
            {
              if (v9 >= v12)
              {
                int v322 = 0;
              }
              else
              {
                int v323 = *v9++;
                int v322 = v323;
              }
              v318 <<= 8;
              unsigned int v319 = v322 | (v319 << 8);
            }
            unsigned int v324 = (v318 >> 11) * v321;
            unsigned int v325 = v321 + ((2048 - v321) >> 5);
            unsigned int v326 = v318 - v324;
            unsigned int v327 = v321 - (v321 >> 5);
            if (v319 >= v324) {
              uint64_t v328 = (2 * v317) | 1u;
            }
            else {
              uint64_t v328 = (2 * v317);
            }
            if (v319 >= v324)
            {
              unsigned int v193 = v319 - v324;
            }
            else
            {
              unsigned int v326 = v324;
              unsigned int v193 = v319;
            }
            if (v319 >= v324) {
              unsigned __int16 v329 = v327;
            }
            else {
              unsigned __int16 v329 = v325;
            }
            v301[v317] = v329;
            unsigned int v330 = v301[v328];
            if (!HIBYTE(v326))
            {
              if (v9 >= v12)
              {
                int v331 = 0;
              }
              else
              {
                int v332 = *v9++;
                int v331 = v332;
              }
              v326 <<= 8;
              unsigned int v193 = v331 | (v193 << 8);
            }
            unsigned int v197 = (v326 >> 11) * v330;
            int v333 = 2 * v328;
            unsigned int v334 = v193 - v197;
            if (v193 >= v197)
            {
              v333 |= 1u;
              unsigned int v197 = v326 - v197;
              unsigned int v193 = v334;
              unsigned int v335 = v330 - (v330 >> 5);
            }
            else
            {
              unsigned int v335 = v330 + ((2048 - v330) >> 5);
            }
            v301[v328] = v335;
            unsigned int v254 = (v333 ^ 0x10) + 16 * v296 + 18;
          }
          else
          {
            v7[433] = v217 + ((2048 - v217) >> 5);
            if (!HIBYTE(v218))
            {
              if (v9 >= v12)
              {
                int v220 = 0;
              }
              else
              {
                int v221 = *v9++;
                int v220 = v221;
              }
              v218 <<= 8;
              unsigned int v171 = v220 | (v171 << 8);
            }
            unint64_t v222 = &v7[8 * v23];
            int8x16_t v223 = v222 + 562;
            LODWORD(v222) = v222[563];
            unsigned int v224 = (v218 >> 11) * v222;
            unsigned int v225 = v222 + ((2048 - v222) >> 5);
            unsigned int v226 = v218 - v224;
            unsigned int v227 = v222 - (v222 >> 5);
            if (v171 >= v224) {
              uint64_t v228 = 3;
            }
            else {
              uint64_t v228 = 2;
            }
            if (v171 >= v224) {
              unsigned int v229 = v226;
            }
            else {
              unsigned int v229 = v224;
            }
            if (v171 >= v224) {
              unsigned int v230 = v171 - v224;
            }
            else {
              unsigned int v230 = v171;
            }
            if (v171 >= v224) {
              unsigned __int16 v231 = v227;
            }
            else {
              unsigned __int16 v231 = v225;
            }
            v223[1] = v231;
            if (!HIBYTE(v229))
            {
              if (v9 >= v12)
              {
                int v232 = 0;
              }
              else
              {
                int v233 = *v9++;
                int v232 = v233;
              }
              v229 <<= 8;
              unsigned int v230 = v232 | (v230 << 8);
            }
            unsigned int v234 = v223[v228];
            unsigned int v235 = (v229 >> 11) * v234;
            unsigned int v236 = v234 + ((2048 - v234) >> 5);
            unsigned int v237 = v229 - v235;
            unsigned int v238 = v234 - (v234 >> 5);
            if (v230 >= v235) {
              uint64_t v239 = (2 * v228) | 1u;
            }
            else {
              uint64_t v239 = (2 * v228);
            }
            if (v230 >= v235)
            {
              unsigned int v193 = v230 - v235;
            }
            else
            {
              unsigned int v237 = v235;
              unsigned int v193 = v230;
            }
            if (v230 >= v235) {
              unsigned __int16 v240 = v238;
            }
            else {
              unsigned __int16 v240 = v236;
            }
            v223[v228] = v240;
            unsigned int v241 = v223[v239];
            if (!HIBYTE(v237))
            {
              if (v9 >= v12)
              {
                int v242 = 0;
              }
              else
              {
                int v243 = *v9++;
                int v242 = v243;
              }
              v237 <<= 8;
              unsigned int v193 = v242 | (v193 << 8);
            }
            unsigned int v197 = (v237 >> 11) * v241;
            int v244 = 2 * v239;
            unsigned int v245 = v193 - v197;
            if (v193 >= v197)
            {
              v244 |= 1u;
              unsigned int v197 = v237 - v197;
              unsigned int v193 = v245;
              unsigned int v246 = v241 - (v241 >> 5);
            }
            else
            {
              unsigned int v246 = v241 + ((2048 - v241) >> 5);
            }
            v223[v239] = v246;
            unsigned int v254 = (v244 ^ 8) + 10;
          }
        }
        else
        {
          v7[432] = v169 + ((2048 - v169) >> 5);
          if (!HIBYTE(v170))
          {
            if (v9 >= v12)
            {
              int v172 = 0;
            }
            else
            {
              int v173 = *v9++;
              int v172 = v173;
            }
            v170 <<= 8;
            unsigned int v27 = v172 | (v27 << 8);
          }
          uint64_t v174 = (uint64_t)&v7[8 * v23 + 432];
          uint64_t v175 = v174 + 4;
          LODWORD(v174) = *(unsigned __int16 *)(v174 + 6);
          unsigned int v176 = (v170 >> 11) * v174;
          int v177 = v174 + ((2048 - v174) >> 5);
          unsigned int v178 = v170 - v176;
          int v179 = v174 - (v174 >> 5);
          if (v27 >= v176) {
            uint64_t v180 = 3;
          }
          else {
            uint64_t v180 = 2;
          }
          if (v27 >= v176) {
            unsigned int v181 = v178;
          }
          else {
            unsigned int v181 = v176;
          }
          if (v27 >= v176) {
            unsigned int v182 = v27 - v176;
          }
          else {
            unsigned int v182 = v27;
          }
          if (v27 >= v176) {
            __int16 v183 = v179;
          }
          else {
            __int16 v183 = v177;
          }
          *(_WORD *)(v175 + 2) = v183;
          if (!HIBYTE(v181))
          {
            if (v9 >= v12)
            {
              int v184 = 0;
            }
            else
            {
              int v185 = *v9++;
              int v184 = v185;
            }
            v181 <<= 8;
            unsigned int v182 = v184 | (v182 << 8);
          }
          unsigned int v186 = *(unsigned __int16 *)(v175 + 2 * v180);
          unsigned int v187 = (v181 >> 11) * v186;
          unsigned int v188 = v186 + ((2048 - v186) >> 5);
          unsigned int v189 = v181 - v187;
          unsigned int v190 = v186 - (v186 >> 5);
          if (v182 >= v187) {
            uint64_t v191 = (2 * v180) | 1u;
          }
          else {
            uint64_t v191 = (2 * v180);
          }
          if (v182 >= v187) {
            unsigned int v192 = v189;
          }
          else {
            unsigned int v192 = v187;
          }
          if (v182 >= v187) {
            unsigned int v193 = v182 - v187;
          }
          else {
            unsigned int v193 = v182;
          }
          if (v182 < v187) {
            LOWORD(v190) = v188;
          }
          *(_WORD *)(v175 + 2 * v180) = v190;
          unsigned int v194 = *(unsigned __int16 *)(v175 + 2 * v191);
          if (!HIBYTE(v192))
          {
            if (v9 >= v12)
            {
              int v195 = 0;
            }
            else
            {
              int v196 = *v9++;
              int v195 = v196;
            }
            v192 <<= 8;
            unsigned int v193 = v195 | (v193 << 8);
          }
          unsigned int v197 = (v192 >> 11) * v194;
          int v198 = 2 * v191;
          unsigned int v199 = v193 - v197;
          if (v193 >= v197)
          {
            v198 |= 1u;
            unsigned int v197 = v192 - v197;
            unsigned int v193 = v199;
            unsigned int v200 = v194 - (v194 >> 5);
          }
          else
          {
            unsigned int v200 = v194 + ((2048 - v194) >> 5);
          }
          *(_WORD *)(v175 + 2 * v191) = v200;
          unsigned int v254 = (v198 ^ 8) + 2;
        }
        unsigned int v336 = v254 - 2;
        if (v254 >= 6) {
          unsigned int v336 = 3;
        }
        v337 = &v7[80 * v336];
        unsigned int v338 = v337[1557];
        if (!HIBYTE(v197))
        {
          if (v9 >= v12)
          {
            int v339 = 0;
          }
          else
          {
            int v340 = *v9++;
            int v339 = v340;
          }
          v197 <<= 8;
          unsigned int v193 = v339 | (v193 << 8);
        }
        unint64_t v341 = v337 + 1492;
        unint64_t v342 = v337 + 1556;
        unsigned int v343 = (v197 >> 11) * v338;
        unsigned int v344 = v338 + ((2048 - v338) >> 5);
        unsigned int v345 = v197 - v343;
        unsigned int v346 = v193 - v343;
        unsigned int v347 = v338 - (v338 >> 5);
        if (v193 >= v343) {
          uint64_t v348 = 3;
        }
        else {
          uint64_t v348 = 2;
        }
        if (v193 >= v343)
        {
          unsigned __int16 v349 = v347;
        }
        else
        {
          unsigned int v345 = v343;
          unsigned int v346 = v193;
          unsigned __int16 v349 = v344;
        }
        v341[65] = v349;
        unsigned int v350 = v342[v348];
        if (!HIBYTE(v345))
        {
          if (v9 >= v12)
          {
            int v351 = 0;
          }
          else
          {
            int v352 = *v9++;
            int v351 = v352;
          }
          v345 <<= 8;
          unsigned int v346 = v351 | (v346 << 8);
        }
        unsigned int v353 = (v345 >> 11) * v350;
        unsigned int v354 = v350 + ((2048 - v350) >> 5);
        unsigned int v355 = v345 - v353;
        unsigned int v356 = v350 - (v350 >> 5);
        BOOL v357 = v346 >= v353;
        if (v346 >= v353) {
          uint64_t v358 = (2 * v348) | 1u;
        }
        else {
          uint64_t v358 = (2 * v348);
        }
        if (v346 >= v353) {
          unsigned int v359 = v355;
        }
        else {
          unsigned int v359 = v353;
        }
        if (v346 >= v353) {
          v346 -= v353;
        }
        if (v357) {
          unsigned __int16 v360 = v356;
        }
        else {
          unsigned __int16 v360 = v354;
        }
        v342[v348] = v360;
        unsigned int v361 = v342[v358];
        if (!HIBYTE(v359))
        {
          if (v9 >= v12)
          {
            int v362 = 0;
          }
          else
          {
            int v363 = *v9++;
            int v362 = v363;
          }
          v359 <<= 8;
          unsigned int v346 = v362 | (v346 << 8);
        }
        unsigned int v364 = (v359 >> 11) * v361;
        unsigned int v365 = v361 + ((2048 - v361) >> 5);
        unsigned int v366 = v359 - v364;
        unsigned int v367 = v361 - (v361 >> 5);
        BOOL v368 = v346 >= v364;
        if (v346 >= v364) {
          uint64_t v369 = (2 * v358) | 1u;
        }
        else {
          uint64_t v369 = (2 * v358);
        }
        if (v346 >= v364) {
          v346 -= v364;
        }
        else {
          unsigned int v366 = v364;
        }
        if (v368) {
          unsigned __int16 v370 = v367;
        }
        else {
          unsigned __int16 v370 = v365;
        }
        v342[v358] = v370;
        unsigned int v371 = v342[v369];
        if (!HIBYTE(v366))
        {
          if (v9 >= v12)
          {
            int v372 = 0;
          }
          else
          {
            int v373 = *v9++;
            int v372 = v373;
          }
          v366 <<= 8;
          unsigned int v346 = v372 | (v346 << 8);
        }
        unsigned int v374 = (v366 >> 11) * v371;
        int v375 = 2 * v369;
        unsigned int v376 = v371 + ((2048 - v371) >> 5);
        unsigned int v377 = v366 - v374;
        unsigned int v378 = v346 - v374;
        unsigned int v379 = v371 - (v371 >> 5);
        BOOL v380 = v346 >= v374;
        if (v346 < v374)
        {
          unsigned int v381 = v374;
        }
        else
        {
          int v375 = (2 * v369) | 1;
          unsigned int v381 = v377;
        }
        if (v346 >= v374) {
          unsigned __int16 v382 = v379;
        }
        else {
          unsigned __int16 v382 = v376;
        }
        v342[v369] = v382;
        if (v380) {
          unsigned int v383 = v378;
        }
        else {
          unsigned int v383 = v346;
        }
        unsigned int v384 = (4 * v375) ^ 0x40;
        v385 = &v341[v384];
        unsigned int v386 = v385[1];
        if (!HIBYTE(v381))
        {
          if (v9 >= v12)
          {
            int v387 = 0;
          }
          else
          {
            int v388 = *v9++;
            int v387 = v388;
          }
          v381 <<= 8;
          unsigned int v383 = v387 | (v383 << 8);
        }
        unsigned int v389 = (v381 >> 11) * v386;
        unsigned int v390 = v386 + ((2048 - v386) >> 5);
        unsigned int v391 = v381 - v389;
        unsigned int v392 = v386 - (v386 >> 5);
        BOOL v393 = v383 >= v389;
        if (v383 >= v389) {
          uint64_t v394 = 3;
        }
        else {
          uint64_t v394 = 2;
        }
        if (v383 >= v389) {
          v383 -= v389;
        }
        else {
          unsigned int v391 = v389;
        }
        if (v393) {
          unsigned __int16 v395 = v392;
        }
        else {
          unsigned __int16 v395 = v390;
        }
        v385[1] = v395;
        unsigned int v396 = v385[v394];
        if (!HIBYTE(v391))
        {
          if (v9 >= v12)
          {
            int v397 = 0;
          }
          else
          {
            int v398 = *v9++;
            int v397 = v398;
          }
          v391 <<= 8;
          unsigned int v383 = v397 | (v383 << 8);
        }
        unsigned int v399 = (v391 >> 11) * v396;
        unsigned int v400 = v396 + ((2048 - v396) >> 5);
        unsigned int v401 = v391 - v399;
        unsigned int v402 = v396 - (v396 >> 5);
        if (v383 >= v399) {
          int v403 = (2 * v394) | 1;
        }
        else {
          int v403 = 2 * v394;
        }
        if (v383 >= v399) {
          unsigned int v18 = v401;
        }
        else {
          unsigned int v18 = v399;
        }
        if (v383 >= v399) {
          unsigned int v11 = v383 - v399;
        }
        else {
          unsigned int v11 = v383;
        }
        if (v383 >= v399) {
          unsigned __int16 v404 = v402;
        }
        else {
          unsigned __int16 v404 = v400;
        }
        v385[v394] = v404;
        unsigned int v405 = (v403 ^ 4) + v384;
        if (v384)
        {
          int v406 = (v405 >> 1) - 1;
          unsigned int v407 = (v403 & 1 | 2) << ((v405 >> 1) - 1);
          if (v405 > 0xD)
          {
            int v421 = 0;
            int v422 = (v405 >> 1) - 5;
            if (v405 >> 1 != 5)
            {
              unsigned int v423 = v18;
              do
              {
                if (!HIBYTE(v423))
                {
                  if (v9 >= v12)
                  {
                    int v424 = 0;
                  }
                  else
                  {
                    int v425 = *v9++;
                    int v424 = v425;
                  }
                  v423 <<= 8;
                  unsigned int v11 = v424 | (v11 << 8);
                }
                unsigned int v18 = v423 >> 1;
                BOOL v426 = v11 >= v423 >> 1;
                if (v11 < v423 >> 1) {
                  unsigned int v427 = 0;
                }
                else {
                  unsigned int v427 = v423 >> 1;
                }
                v11 -= v427;
                int v421 = v426 | (2 * v421);
                unsigned int v423 = v18;
                --v422;
              }
              while (v422);
            }
            int v428 = 0;
            int v429 = 0;
            unsigned int v430 = 1;
            do
            {
              if (!HIBYTE(v18))
              {
                if (v9 >= v12)
                {
                  int v431 = 0;
                }
                else
                {
                  int v432 = *v9++;
                  int v431 = v432;
                }
                v18 <<= 8;
                unsigned int v11 = v431 | (v11 << 8);
              }
              uint64_t v433 = v430;
              unsigned int v434 = v17[v430];
              unsigned int v435 = v434 + ((2048 - v434) >> 5);
              unsigned int v436 = (v18 >> 11) * v434;
              v430 *= 2;
              unsigned int v437 = v434 - (v434 >> 5);
              BOOL v438 = v11 >= v436;
              if (v11 < v436)
              {
                unsigned int v18 = v436;
              }
              else
              {
                v430 |= 1u;
                v18 -= v436;
              }
              if (v11 >= v436) {
                v11 -= v436;
              }
              if (v438)
              {
                int v439 = 1;
              }
              else
              {
                LOWORD(v437) = v435;
                int v439 = 0;
              }
              v17[v433] = v437;
              v429 += v439 << v428++;
            }
            while (v428 != 4);
            int v409 = v429 + 16 * v421;
          }
          else if (v405 < 4)
          {
            int v409 = 0;
          }
          else
          {
            int v408 = 0;
            int v409 = 0;
            uint64_t v410 = (uint64_t)&v7[v407 + 1812];
            if (v406 <= 1) {
              int v406 = 1;
            }
            unsigned int v411 = 1;
            do
            {
              if (!HIBYTE(v18))
              {
                if (v9 >= v12)
                {
                  int v412 = 0;
                }
                else
                {
                  int v413 = *v9++;
                  int v412 = v413;
                }
                v18 <<= 8;
                unsigned int v11 = v412 | (v11 << 8);
              }
              uint64_t v414 = v411;
              unsigned int v415 = *(unsigned __int16 *)(v410 + 2 * v411);
              unsigned int v416 = v415 + ((2048 - v415) >> 5);
              unsigned int v417 = (v18 >> 11) * v415;
              v411 *= 2;
              unsigned int v418 = v415 - (v415 >> 5);
              BOOL v419 = v11 >= v417;
              if (v11 < v417)
              {
                unsigned int v18 = v417;
              }
              else
              {
                v411 |= 1u;
                v18 -= v417;
              }
              if (v11 >= v417) {
                v11 -= v417;
              }
              if (v419)
              {
                int v420 = 1;
              }
              else
              {
                LOWORD(v418) = v416;
                int v420 = 0;
              }
              *(_WORD *)(v410 + 2 * v414) = v418;
              v409 += v420 << v408++;
            }
            while (v406 != v408);
          }
          unsigned int v405 = v409 + v407;
        }
        if ((uint64_t)&v19[-a2] <= v405) {
          return 0;
        }
        uint64_t v8 = lzma_fsm_lut[v8 + 24];
        a1[3] = a1[2];
        *(void *)(a1 + 1) = *(void *)a1;
        LODWORD(v210) = v405 + 1;
        *a1 = v405 + 1;
      }
      uint32x4_t v213 = &v19[v254];
      if ((unint64_t)(v213 + 47) > a5)
      {
        if (v213 > a4) {
          return 0;
        }
        do
        {
          unsigned char *v19 = v19[-v210];
          ++v19;
        }
        while (v19 < v213);
      }
      else if (v210 > 0xF)
      {
        long long v601 = &v19[-v210];
        if (v210 >= v254 + 47)
        {
          long long v603 = v601[1];
          *(_OWORD *)unsigned int v19 = *v601;
          *((_OWORD *)v19 + 1) = v603;
          *((_OWORD *)v19 + 2) = v601[2];
          if (v254 >= 0x31)
          {
            for (unint64_t i = 48; i < v254; i += 16)
              *(_OWORD *)&v19[i] = v601[i / 0x10];
          }
        }
        else
        {
          *(_OWORD *)unsigned int v19 = *v601;
          *((_OWORD *)v19 + 1) = v601[1];
          *((_OWORD *)v19 + 2) = v601[2];
          if (v254 >= 0x31)
          {
            for (unint64_t j = 48; j < v254; j += 16)
              *(_OWORD *)&v19[j] = v601[j / 0x10];
          }
        }
      }
      else
      {
        long long v594 = (int8x16_t *)&v19[-v210];
        int8x16_t v595 = vqtbl1q_s8(*v594, lzma_copy_with_pattern[(v210 - 1)]);
        uint64_t v596 = lzma_copy_with_pattern[(v210 - 1)];
        long long v597 = &v594->i8[v596];
        *(int8x16_t *)unsigned int v19 = v595;
        *((_OWORD *)v19 + 1) = *(_OWORD *)v597;
        *((_OWORD *)v19 + 2) = *((_OWORD *)v597 + 1);
        if (v254 >= 0x31)
        {
          uint64_t v598 = 0;
          uint64_t v599 = (uint64_t)&v19[v596 - v210 + 32];
          do
          {
            *(_OWORD *)&v19[v598 + 48] = *(_OWORD *)(v599 + v598);
            unint64_t v600 = v598 + 64;
            v598 += 16;
          }
          while (v600 < v254);
        }
      }
LABEL_770:
      unsigned int v19 = v213;
      if (v213 >= a4) {
        goto LABEL_830;
      }
    }
  }
  return v16;
}

uint64_t BrotliInitZopfliNodes(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = result + 12;
    do
    {
      *(void *)(v2 - 12) = 1;
      *(void *)(v2 - 4) = 0x7EFFC99E00000000;
      v2 += 16;
      --a2;
    }
    while (a2);
  }
  return result;
}

uint64_t BrotliZopfliCreateCommands(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v45 = result;
  uint64_t v8 = *(unsigned int *)(a3 + 12);
  if (v8 == -1)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
    unint64_t v11 = (1 << *(_DWORD *)(a6 + 8)) - 16;
    uint64_t v12 = *(void *)(a6 + 16) + a2;
    uint64_t v13 = a7 + 8;
    do
    {
      int v14 = (unsigned int *)(a3 + 16 * (v9 + v8));
      unsigned int v15 = *v14;
      unsigned int v16 = v14[2];
      uint64_t v8 = v14[3];
      uint64_t v17 = v16 & 0x7FFFFFF;
      if (v10)
      {
        unint64_t v18 = v16 & 0x7FFFFFF;
      }
      else
      {
        unint64_t v18 = *a5 + v17;
        *a5 = 0;
      }
      uint64_t v19 = v15 & 0x1FFFFFF;
      uint64_t v20 = v9 + v17;
      unint64_t v21 = v14[1];
      unsigned int v22 = (v15 & 0x1FFFFFF) - (v15 >> 25) + 9;
      unint64_t v23 = v12 + v20;
      if (v12 + v20 >= v11) {
        unint64_t v23 = v11;
      }
      unsigned int v24 = v16 >> 27;
      if (v24) {
        unint64_t v25 = v24 - 1;
      }
      else {
        unint64_t v25 = (v21 + 15);
      }
      *(_DWORD *)(v13 - 8) = v18;
      *(_DWORD *)(v13 - 4) = v19 | ((v22 - v15) << 25);
      uint64_t v26 = *(unsigned int *)(a6 + 68);
      __int16 v27 = v26 + 16;
      if (v26 + 16 <= v25)
      {
        int v30 = *(_DWORD *)(a6 + 64);
        unint64_t v31 = v25 - v26 + (4 << v30) - 16;
        unsigned int v32 = (__clz(v31) ^ 0x1F) - 1;
        __n128 result = v32 - v30;
        __int16 v29 = ((v31 & ~(-1 << v30)) + v27 + ((((v31 >> v32) & 1 | (2 * (v32 - v30))) + 65534) << v30)) | (((_WORD)v32 - (_WORD)v30) << 10);
        unint64_t v28 = (v31 - (((v31 >> v32) & 1 | 2) << v32)) >> v30;
      }
      else
      {
        LODWORD(v28) = 0;
        __int16 v29 = v25;
      }
      *(_WORD *)(v13 + 6) = v29;
      *(_DWORD *)uint64_t v13 = v28;
      if (v18 > 5)
      {
        if (v18 > 0x81)
        {
          if (v18 > 0x841)
          {
            if (v18 >> 1 >= 0xC21)
            {
              if (v18 < 0x5842) {
                LOWORD(v33) = 22;
              }
              else {
                LOWORD(v33) = 23;
              }
            }
            else
            {
              LOWORD(v33) = 21;
            }
          }
          else
          {
            unsigned int v33 = (__clz(v18 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v34 = (__clz(v18 - 2) ^ 0x1F) - 1;
          unsigned int v33 = ((v18 - 2) >> v34) + 2 * v34 + 2;
        }
      }
      else
      {
        LOWORD(v33) = v18;
      }
      if (v22 > 9)
      {
        unsigned int v36 = (__clz(v22 - 70) ^ 0x1F) + 12;
        if (v22 > 0x845) {
          LOWORD(v36) = 23;
        }
        unsigned int v37 = (__clz(v22 - 6) ^ 0x1F) - 1;
        int v38 = ((unint64_t)(int)(v22 - 6) >> v37) + 2 * v37 + 4;
        if (v22 <= 0x85) {
          unsigned __int16 v35 = v38;
        }
        else {
          unsigned __int16 v35 = v36;
        }
      }
      else
      {
        unsigned __int16 v35 = v22 - 2;
      }
      int v39 = v29 & 0x3FF;
      int v40 = v35 & 7 | (8 * (v33 & 7));
      if (v39) {
        BOOL v41 = 1;
      }
      else {
        BOOL v41 = (unsigned __int16)v33 > 7u;
      }
      if (v41 || v35 > 0xFu)
      {
        int v43 = 3 * ((unsigned __int16)v33 >> 3) + ((unsigned __int16)(v35 & 0xFFF8) >> 3);
        unsigned int v44 = ((((0x520D40u >> (2 * v43)) & 0xC0) + (v43 << 6)) | v40) + 64;
      }
      else if ((v35 & 0xFFF8) != 0)
      {
        LOWORD(v44) = v40 | 0x40;
      }
      else
      {
        LOWORD(v44) = v35 & 7 | (8 * (v33 & 7));
      }
      *(_WORD *)(v13 + 4) = v44;
      if (v23 >= v21 && v25)
      {
        *(_DWORD *)(a4 + 12) = *(_DWORD *)(a4 + 8);
        *(void *)(a4 + 4) = *(void *)a4;
        *(_DWORD *)a4 = v21;
      }
      *a8 += v18;
      uint64_t v9 = v20 + v19;
      --v10;
      v13 += 16;
    }
    while (v8 != 0xFFFFFFFFLL);
  }
  *a5 += v45 - v9;
  return result;
}

uint64_t BrotliZopfliComputeShortestPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, _DWORD *a10)
{
  uint64_t v10 = MEMORY[0x270FA5388]();
  unsigned int v170 = v13;
  uint64_t v14 = v12;
  unint64_t v16 = v15;
  uint64_t v18 = v17;
  uint64_t v20 = v19;
  unint64_t v21 = v11;
  uint64_t v22 = v10;
  uint64_t v182 = *MEMORY[0x263EF8340];
  uint64_t v162 = *(void *)(v12 + 16);
  int v23 = *(_DWORD *)(v12 + 8);
  if (*(int *)(v12 + 4) >= 11) {
    uint64_t v24 = 325;
  }
  else {
    uint64_t v24 = 150;
  }
  memset(v177, 0, 512);
  if (v11 >= 0x7F) {
    unint64_t v25 = v11 - 127;
  }
  else {
    unint64_t v25 = 0;
  }
  *a10 = 0;
  a10[3] = 0;
  InitZopfliCostModel(v10, (uint64_t)v177, v12 + 64, v11);
  uint64_t result = 0;
  if (!*(_DWORD *)(v22 + 24))
  {
    char v173 = v23;
    uint64_t v159 = v22;
    uint64_t v166 = v20;
    ZopfliCostModelSetFromLiteralCosts((uint64_t)v177);
    uint64_t v176 = 0;
    uint64_t v27 = v162;
    if (v21 >= 4)
    {
      uint64_t v28 = v14;
      unint64_t v29 = 0;
      unint64_t v171 = (1 << v173) - 16;
      unint64_t v160 = v25 + v166;
      unsigned int v161 = (uint64_t *)(v14 + 88);
      *(void *)int v172 = v21;
      uint64_t v174 = a9 + 8;
      memset(v175, 0, sizeof(v175));
      unint64_t v164 = v24;
      uint64_t v165 = v14;
      do
      {
        unint64_t v30 = v29 + v166;
        if (v29 + v166 >= v171) {
          unint64_t v31 = v171;
        }
        else {
          unint64_t v31 = v29 + v166;
        }
        unint64_t v32 = v30 + v27;
        if (v30 + v27 >= v171) {
          unint64_t v32 = v171;
        }
        unint64_t v163 = v32;
        unint64_t v33 = v21 - v29;
        unint64_t v34 = v30 & v16;
        unint64_t v35 = 16;
        if (*(_DWORD *)(v28 + 4) == 11) {
          unint64_t v35 = 64;
        }
        BOOL v36 = v30 >= v35;
        unint64_t v37 = v30 - v35;
        if (!v36) {
          unint64_t v37 = 0;
        }
        unint64_t v38 = v30 - 1;
        if (v30 - 1 <= v37)
        {
          int v40 = (char *)v180;
          unint64_t v41 = 1;
        }
        else
        {
          int v39 = (unsigned __int8 *)(v18 + v34);
          int v40 = (char *)v180;
          unint64_t v41 = 1;
          do
          {
            if (v30 - v38 > v31) {
              break;
            }
            unsigned int v42 = (unsigned __int8 *)(v18 + (v38 & v16));
            if (*v39 == *v42 && *(unsigned __int8 *)(v18 + v34 + 1) == *(unsigned __int8 *)((v38 & v16) + v18 + 1))
            {
              if (v33 < 8)
              {
                unint64_t v47 = 0;
                int v48 = (unsigned __int8 *)(v18 + v34);
LABEL_36:
                if ((v33 & 7) != 0)
                {
                  unint64_t v49 = v33 & 7 | v47;
                  unint64_t v50 = v33 & 7;
                  while (v42[v47] == *v48)
                  {
                    ++v48;
                    ++v47;
                    if (!--v50)
                    {
                      unint64_t v47 = v49;
                      break;
                    }
                  }
                }
              }
              else
              {
                uint64_t v43 = 0;
                unint64_t v44 = v33 >> 3;
                while (1)
                {
                  uint64_t v45 = *(void *)&v39[v43];
                  uint64_t v46 = *(void *)&v42[v43];
                  if (v45 != v46) {
                    break;
                  }
                  v43 += 8;
                  if (!--v44)
                  {
                    unint64_t v47 = v33 & 0xFFFFFFFFFFFFFFF8;
                    int v48 = (unsigned __int8 *)(v18 + v34 + (v33 & 0xFFFFFFFFFFFFFFF8));
                    goto LABEL_36;
                  }
                }
                unint64_t v47 = v43 + (__clz(__rbit64(v46 ^ v45)) >> 3);
              }
              if (v47 > v41)
              {
                *(_DWORD *)int v40 = v30 - v38;
                *((_DWORD *)v40 + 1) = 32 * v47;
                v40 += 8;
                unint64_t v41 = v47;
              }
            }
            if (--v38 <= v37) {
              break;
            }
          }
          while (v41 < 3);
        }
        if (v41 < v33)
        {
          uint64_t v51 = (506832829 * *(_DWORD *)(v18 + v34)) >> 15;
          uint64_t v52 = a9[9];
          uint64_t v54 = a9[6];
          uint64_t v53 = a9[7];
          uint64_t v55 = *(unsigned int *)(v53 + 4 * v51);
          if (v33 >= 0x80) {
            uint64_t v56 = 128;
          }
          else {
            uint64_t v56 = v21 - v29;
          }
          unint64_t v168 = v56;
          if (v33 >= 0x80) {
            *(_DWORD *)(v53 + 4 * v51) = v30;
          }
          uint64_t v167 = 2 * (v54 & v30);
          uint64_t v57 = v167 | 1;
          if (v30 != v55)
          {
            unint64_t v139 = 0;
            unint64_t v140 = 0;
            uint64_t v141 = 64;
            do
            {
              if (v30 - v55 > v31 || v141 == 0) {
                break;
              }
              unint64_t v143 = v55 & v16;
              if (v140 >= v139) {
                unint64_t v144 = v139;
              }
              else {
                unint64_t v144 = v140;
              }
              uint64_t v145 = v18 + v144 + v34;
              unsigned int v146 = (unsigned __int8 *)(v18 + v144 + v143);
              unint64_t v147 = v33 - v144;
              if (v33 - v144 < 8)
              {
                unint64_t v150 = 0;
LABEL_187:
                uint64_t v155 = v147 & 7;
                if (v155)
                {
                  unint64_t v156 = v150 | v155;
                  while (*(unsigned __int8 *)(v145 + v150) == *v146)
                  {
                    ++v146;
                    ++v150;
                    if (!--v155)
                    {
                      unint64_t v150 = v156;
                      break;
                    }
                  }
                }
              }
              else
              {
                uint64_t v148 = 0;
                unint64_t v149 = v147 >> 3;
                unint64_t v150 = v147 & 0xFFFFFFFFFFFFFFF8;
                while (1)
                {
                  uint64_t v151 = *(void *)&v146[v148];
                  uint64_t v152 = *(void *)(v145 + v148);
                  if (v151 != v152) {
                    break;
                  }
                  v148 += 8;
                  if (!--v149)
                  {
                    v146 += v147 & 0xFFFFFFFFFFFFFFF8;
                    goto LABEL_187;
                  }
                }
                unint64_t v150 = v148 + (__clz(__rbit64(v152 ^ v151)) >> 3);
              }
              unint64_t v153 = v150 + v144;
              if (v40 && v153 > v41)
              {
                *(_DWORD *)int v40 = v30 - v55;
                *((_DWORD *)v40 + 1) = 32 * v153;
                v40 += 8;
                unint64_t v41 = v153;
              }
              if (v153 >= v168)
              {
                if (v33 < 0x80) {
                  goto LABEL_52;
                }
                unsigned int v157 = (int *)(v52 + 8 * (v55 & v54));
                int v158 = *v157;
                int v58 = v157 + 1;
                *(_DWORD *)(v52 + 4 * v167) = v158;
                goto LABEL_51;
              }
              if (*(unsigned __int8 *)(v18 + v153 + v34) <= *(unsigned __int8 *)(v18 + v153 + v143))
              {
                if (v33 >= 0x80) {
                  *(_DWORD *)(v52 + 4 * v57) = v55;
                }
                uint64_t v154 = 2 * (v55 & v54);
                uint64_t v57 = v154;
                unint64_t v139 = v153;
              }
              else
              {
                if (v33 >= 0x80) {
                  *(_DWORD *)(v52 + 4 * v167) = v55;
                }
                uint64_t v154 = (2 * (v55 & v54)) | 1;
                uint64_t v167 = v154;
                unint64_t v140 = v153;
              }
              uint64_t v55 = *(unsigned int *)(v52 + 4 * v154);
              --v141;
            }
            while (v30 != v55);
          }
          if (v33 >= 0x80)
          {
            *(_DWORD *)(v52 + 4 * v167) = *v174;
            int v58 = a9 + 8;
LABEL_51:
            *(_DWORD *)(v52 + 4 * v57) = *v58;
          }
        }
LABEL_52:
        memset_pattern16(__b, &unk_20DAD64E0, 0x98uLL);
        if (v41 + 1 > 4) {
          unint64_t v59 = v41 + 1;
        }
        else {
          unint64_t v59 = 4;
        }
        if (BrotliFindAllStaticDictionaryMatches(v161, (unsigned __int8 *)(v18 + v34), v59, v33, (uint64_t)__b))
        {
          if (v33 >= 0x25) {
            unint64_t v60 = 37;
          }
          else {
            unint64_t v60 = v33;
          }
          unint64_t v62 = v164;
          uint64_t v61 = v165;
          if (v59 <= v60)
          {
            unint64_t v63 = v60 + 1;
            int v64 = 32 * v59;
            do
            {
              unint64_t v65 = __b[v59];
              if (v65 <= 0xFFFFFFE)
              {
                unint64_t v66 = v163 + 1 + (v65 >> 5);
                if (v66 <= *(void *)(v165 + 80))
                {
                  uint64_t v67 = v65 & 0x1F;
                  if (v59 == v67) {
                    LODWORD(v67) = 0;
                  }
                  *(_DWORD *)int v40 = v66;
                  *((_DWORD *)v40 + 1) = v64 + v67;
                  v40 += 8;
                }
              }
              ++v59;
              v64 += 32;
            }
            while (v63 != v59);
          }
        }
        else
        {
          unint64_t v62 = v164;
          uint64_t v61 = v165;
        }
        uint64_t v68 = v40 - (char *)v180;
        if (v40 == (char *)v180)
        {
          uint64_t v69 = 0;
          unint64_t v71 = *(void *)v172;
        }
        else
        {
          uint64_t v69 = v68 >> 3;
          uint64_t v70 = (v68 >> 3) - 1;
          unint64_t v71 = *(void *)v172;
          if (v62 < (unint64_t)HIDWORD(v180[v70]) >> 5)
          {
            v180[0] = v180[v70];
            uint64_t v69 = 1;
          }
        }
        unint64_t updated = UpdateNodes(v71, v166, v29, v18, v16, v61, v171, v170, v69, (uint64_t)v180, (uint64_t)v177, (uint64_t)v175, (uint64_t)a10);
        if (updated >= 0x4000) {
          unint64_t v73 = updated;
        }
        else {
          unint64_t v73 = 0;
        }
        if (v69 == 1)
        {
          unint64_t v74 = (unint64_t)HIDWORD(v180[0]) >> 5;
          if (v74 <= v73) {
            unint64_t v74 = v73;
          }
          if (v164 < (unint64_t)HIDWORD(v180[0]) >> 5) {
            unint64_t v73 = v74;
          }
        }
        if (v73 < 2)
        {
          unint64_t v21 = *(void *)v172;
        }
        else
        {
          unint64_t v169 = v73;
          unint64_t v75 = v160;
          if (v73 + v30 < v160) {
            unint64_t v75 = v73 + v30;
          }
          unint64_t v76 = v75 - 63;
          if (v30 + 64 > v75) {
            unint64_t v76 = v30 + 1;
          }
          if (v30 + 513 <= v76)
          {
            unint64_t v77 = v30 + 1;
            if (v30 + 1 < v76)
            {
              uint64_t v78 = a9[6];
              uint64_t v79 = a9[7];
              uint64_t v80 = a9[9];
              do
              {
                unint64_t v81 = v77 & v16;
                unsigned int v82 = (506832829 * *(_DWORD *)(v18 + (v77 & v16))) >> 15;
                uint64_t v83 = *(unsigned int *)(v79 + 4 * v82);
                uint64_t v84 = 2 * (v78 & v77);
                uint64_t v85 = v84 | 1;
                *(_DWORD *)(v79 + 4 * v82) = v77;
                if (v77 != v83)
                {
                  unint64_t v87 = 0;
                  unint64_t v88 = 0;
                  uint64_t v89 = 64;
                  do
                  {
                    if (v77 - v83 > v78 - 15 || v89 == 0) {
                      break;
                    }
                    unint64_t v91 = v83 & v16;
                    if (v88 >= v87) {
                      unint64_t v92 = v87;
                    }
                    else {
                      unint64_t v92 = v88;
                    }
                    unint64_t v93 = v18 + v81 + v92;
                    __int16 v94 = (unsigned __int8 *)(v18 + v92 + v91);
                    unint64_t v95 = 128 - v92;
                    if (128 - v92 < 8)
                    {
                      unint64_t v98 = 0;
LABEL_114:
                      uint64_t v104 = v95 & 7;
                      if (v104)
                      {
                        unint64_t v105 = v98 | v104;
                        while (*(unsigned __int8 *)(v93 + v98) == *v94)
                        {
                          ++v94;
                          ++v98;
                          if (!--v104)
                          {
                            unint64_t v98 = v105;
                            break;
                          }
                        }
                      }
                    }
                    else
                    {
                      uint64_t v96 = 0;
                      unint64_t v97 = v95 >> 3;
                      unint64_t v98 = v95 & 0xFFFFFFFFFFFFFFF8;
                      while (1)
                      {
                        uint64_t v99 = *(void *)&v94[v96];
                        uint64_t v100 = *(void *)(v93 + v96);
                        if (v99 != v100) {
                          break;
                        }
                        v96 += 8;
                        if (!--v97)
                        {
                          v94 += v95 & 0xFFFFFFFFFFFFFFF8;
                          goto LABEL_114;
                        }
                      }
                      unint64_t v98 = v96 + (__clz(__rbit64(v100 ^ v99)) >> 3);
                    }
                    unint64_t v101 = v98 + v92;
                    if (v101 >= 0x80)
                    {
                      unsigned int v106 = (_DWORD *)(v80 + 8 * (v83 & v78));
                      *(_DWORD *)(v80 + 4 * v84) = *v106;
                      int v86 = v106[1];
                      goto LABEL_91;
                    }
                    unsigned int v102 = *(unsigned __int8 *)(v18 + v101 + v91);
                    uint64_t v103 = 2 * (v83 & v78);
                    if (*(unsigned __int8 *)(v18 + v101 + v81) <= v102)
                    {
                      *(_DWORD *)(v80 + 4 * v85) = v83;
                      uint64_t v85 = 2 * (v83 & v78);
                      unint64_t v87 = v101;
                    }
                    else
                    {
                      *(_DWORD *)(v80 + 4 * v84) = v83;
                      v103 |= 1uLL;
                      uint64_t v84 = v103;
                      unint64_t v88 = v101;
                    }
                    uint64_t v83 = *(unsigned int *)(v80 + 4 * v103);
                    --v89;
                  }
                  while (v77 != v83);
                }
                int v86 = *v174;
                *(_DWORD *)(v80 + 4 * v84) = *v174;
LABEL_91:
                *(_DWORD *)(v80 + 4 * v85) = v86;
                v77 += 8;
              }
              while (v77 < v76);
            }
          }
          if (v76 < v75)
          {
            uint64_t v107 = a9[6];
            uint64_t v108 = a9[7];
            uint64_t v109 = a9[9];
            do
            {
              unint64_t v110 = v76 & v16;
              unsigned int v111 = (506832829 * *(_DWORD *)(v18 + (v76 & v16))) >> 15;
              uint64_t v112 = *(unsigned int *)(v108 + 4 * v111);
              uint64_t v113 = 2 * (v107 & v76);
              uint64_t v114 = v113 | 1;
              *(_DWORD *)(v108 + 4 * v111) = v76;
              if (v76 != v112)
              {
                unint64_t v116 = 0;
                unint64_t v117 = 0;
                uint64_t v118 = 64;
                do
                {
                  if (v76 - v112 > v107 - 15 || v118 == 0) {
                    break;
                  }
                  unint64_t v120 = v112 & v16;
                  if (v117 >= v116) {
                    unint64_t v121 = v116;
                  }
                  else {
                    unint64_t v121 = v117;
                  }
                  unint64_t v122 = v18 + v110 + v121;
                  int v123 = (unsigned __int8 *)(v18 + v121 + v120);
                  unint64_t v124 = 128 - v121;
                  if (128 - v121 < 8)
                  {
                    unint64_t v127 = 0;
LABEL_148:
                    uint64_t v133 = v124 & 7;
                    if (v133)
                    {
                      unint64_t v134 = v127 | v133;
                      while (*(unsigned __int8 *)(v122 + v127) == *v123)
                      {
                        ++v123;
                        ++v127;
                        if (!--v133)
                        {
                          unint64_t v127 = v134;
                          break;
                        }
                      }
                    }
                  }
                  else
                  {
                    uint64_t v125 = 0;
                    unint64_t v126 = v124 >> 3;
                    unint64_t v127 = v124 & 0xFFFFFFFFFFFFFFF8;
                    while (1)
                    {
                      uint64_t v128 = *(void *)&v123[v125];
                      uint64_t v129 = *(void *)(v122 + v125);
                      if (v128 != v129) {
                        break;
                      }
                      v125 += 8;
                      if (!--v126)
                      {
                        v123 += v124 & 0xFFFFFFFFFFFFFFF8;
                        goto LABEL_148;
                      }
                    }
                    unint64_t v127 = v125 + (__clz(__rbit64(v129 ^ v128)) >> 3);
                  }
                  unint64_t v130 = v127 + v121;
                  if (v130 >= 0x80)
                  {
                    unsigned int v135 = (_DWORD *)(v109 + 8 * (v112 & v107));
                    *(_DWORD *)(v109 + 4 * v113) = *v135;
                    int v115 = v135[1];
                    goto LABEL_125;
                  }
                  unsigned int v131 = *(unsigned __int8 *)(v18 + v130 + v120);
                  uint64_t v132 = 2 * (v112 & v107);
                  if (*(unsigned __int8 *)(v18 + v130 + v110) <= v131)
                  {
                    *(_DWORD *)(v109 + 4 * v114) = v112;
                    uint64_t v114 = 2 * (v112 & v107);
                    unint64_t v116 = v130;
                  }
                  else
                  {
                    *(_DWORD *)(v109 + 4 * v113) = v112;
                    v132 |= 1uLL;
                    uint64_t v113 = v132;
                    unint64_t v117 = v130;
                  }
                  uint64_t v112 = *(unsigned int *)(v109 + 4 * v132);
                  --v118;
                }
                while (v76 != v112);
              }
              int v115 = *v174;
              *(_DWORD *)(v109 + 4 * v113) = *v174;
LABEL_125:
              *(_DWORD *)(v109 + 4 * v114) = v115;
              ++v76;
            }
            while (v76 < v75);
          }
          unint64_t v136 = v169 - 1;
          unint64_t v137 = v29 + 4;
          unint64_t v21 = *(void *)v172;
          do
          {
            unint64_t v29 = v137 - 3;
            if (v137 >= v21) {
              break;
            }
            EvaluateNode((void *)(v162 + v166), v137 - 3, v171, v170, (uint64_t)v177, (uint64_t)v175, (uint64_t)a10);
            unint64_t v21 = *(void *)v172;
            ++v137;
            --v136;
          }
          while (v136);
        }
        uint64_t v28 = v165;
        uint64_t v27 = v162;
        unint64_t v138 = v29 + 4;
        ++v29;
      }
      while (v138 < v21);
    }
    BrotliFree(v159, v179);
    BrotliFree(v159, v178);
    return ComputeShortestPathFromNodes(v21, (uint64_t)a10);
  }
  return result;
}

uint64_t InitZopfliCostModel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a2 + 2848) = a4;
  if (a4 == -2) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = BrotliAllocate(a1);
  }
  *(void *)(a2 + 2832) = v7;
  int v8 = *(_DWORD *)(a3 + 12);
  if (v8)
  {
    uint64_t result = BrotliAllocate(a1);
    int v8 = *(_DWORD *)(a3 + 12);
  }
  else
  {
    uint64_t result = 0;
  }
  *(void *)(a2 + 2816) = result;
  *(_DWORD *)(a2 + 2824) = v8;
  return result;
}

float ZopfliCostModelSetFromLiteralCosts(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 2832);
  uint64_t v3 = *(void *)(a1 + 2816);
  uint64_t v4 = *(void *)(a1 + 2848);
  int16x8_t v5 = (float *)(v2 + 1);
  BrotliEstimateBitCostsForLiterals();
  *uint64_t v2 = 0;
  if (v4)
  {
    float v6 = 0.0;
    float v7 = 0.0;
    do
    {
      float v8 = v7 + *v5;
      float v9 = v6 + v8;
      *v5++ = v6 + v8;
      float v7 = v8 - (float)((float)(v6 + v8) - v6);
      float v6 = v9;
      --v4;
    }
    while (v4);
  }
  for (unint64_t i = 0; i != 704; ++i)
  {
    if (i > 0xF4) {
      double v11 = log2((double)(i + 11));
    }
    else {
      double v11 = kBrotliLog2Table[i + 11];
    }
    float v12 = v11;
    *(float *)(a1 + 4 * i) = v12;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 2824);
  if (v13)
  {
    for (uint64_t j = 0; j != v13; ++j)
    {
      unint64_t v15 = (j + 20);
      if (v15 > 0xFF) {
        double v16 = log2((double)v15);
      }
      else {
        double v16 = kBrotliLog2Table[v15];
      }
      float v17 = v16;
      *(float *)(v3 + 4 * j) = v17;
    }
  }
  float result = 3.45943165;
  *(float *)(a1 + 2840) = 3.45943165;
  return result;
}

unint64_t UpdateNodes(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, void *__src, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  unint64_t v15 = a3;
  uint64_t v16 = *(void *)(a6 + 16);
  unint64_t v17 = a3 + a2;
  unint64_t v106 = (a3 + a2) & a5;
  if (v16 + a3 + a2 >= a7) {
    unint64_t v18 = a7;
  }
  else {
    unint64_t v18 = v16 + a3 + a2;
  }
  unint64_t v108 = a1 - a3;
  int v100 = *(_DWORD *)(a6 + 4);
  if (v100 <= 10) {
    unint64_t v19 = 150;
  }
  else {
    unint64_t v19 = 325;
  }
  uint64_t v20 = a12;
  EvaluateNode((void *)(v16 + a2), a3, a7, __src, a11, a12, a13);
  if (v15 + 2 <= a1)
  {
    uint64_t v24 = a12 + 32 * (-*(_DWORD *)(a12 + 256) & 7);
    float v25 = (float)(*(float *)(v24 + 28) + *(float *)(a11 + 2840))
        + (float)(*(float *)(*(void *)(a11 + 2832) + 4 * v15)
                - *(float *)(*(void *)(a11 + 2832) + 4 * *(void *)v24));
    uint64_t v23 = a13;
    uint64_t v26 = (float *)(a13 + 16 * v15 + 44);
    uint64_t v21 = 2;
    uint64_t v27 = 4;
    uint64_t v28 = 10;
    uint64_t v22 = a4;
    do
    {
      if (*v26 > v25) {
        break;
      }
      if (++v21 == v28)
      {
        float v25 = v25 + 1.0;
        uint64_t v29 = v27;
      }
      else
      {
        uint64_t v29 = 0;
      }
      v27 <<= v21 == v28;
      v28 += v29;
      v26 += 4;
    }
    while (v15 + v21 <= a1);
  }
  else
  {
    uint64_t v21 = 2;
    uint64_t v22 = a4;
    uint64_t v23 = a13;
  }
  unint64_t result = 0;
  unint64_t v31 = 0;
  unint64_t v98 = v21;
  unint64_t v99 = v21 - 1;
  if (v18 >= v17) {
    unint64_t v32 = v17;
  }
  else {
    unint64_t v32 = v18;
  }
  unint64_t v104 = v32;
  unint64_t v97 = (unsigned __int8 *)(v22 + v106);
  uint64_t v96 = (unsigned __int8 *)(v22 + v106 + (v108 & 0xFFFFFFFFFFFFFFF8));
  unint64_t v107 = v15;
  while (1)
  {
    unint64_t v33 = *(void *)(v20 + 256);
    unint64_t v34 = 8;
    if (v33 < 8) {
      unint64_t v34 = *(void *)(v20 + 256);
    }
    if (v31 >= v34) {
      return result;
    }
    uint64_t v35 = ((_BYTE)v31 - (_BYTE)v33) & 7;
    unint64_t v36 = v15 - *(void *)(v20 + 32 * v35);
    if (v36 > 5)
    {
      if (v36 > 0x81)
      {
        if (v36 < 0x5842) {
          __int16 v39 = 22;
        }
        else {
          __int16 v39 = 23;
        }
        if (v36 >> 1 >= 0xC21) {
          __int16 v40 = v39;
        }
        else {
          __int16 v40 = 21;
        }
        unsigned int v41 = (__clz(v36 - 66) ^ 0x1F) + 10;
        if (v36 <= 0x841) {
          LOWORD(v37) = v41;
        }
        else {
          LOWORD(v37) = v40;
        }
      }
      else
      {
        unsigned int v38 = (__clz(v36 - 2) ^ 0x1F) - 1;
        LODWORD(v37) = ((v36 - 2) >> v38) + 2 * v38 + 2;
      }
    }
    else
    {
      unint64_t v37 = v15 - *(void *)(v20 + 32 * v35);
    }
    unint64_t v103 = v31;
    float v42 = (float)(*(float *)(v20 + 32 * v35 + 24) + (float)kBrotliInsExtra[(unsigned __int16)v37])
        + (float)(*(float *)(*(void *)(a11 + 2832) + 4 * v15) - **(float **)(a11 + 2832));
    unint64_t v43 = v99;
    unsigned __int16 v102 = v37;
    if (v99 < v108)
    {
      unint64_t v44 = 0;
      int v45 = 8 * (v37 & 7);
      int v46 = 3 * ((unsigned __int16)v37 >> 3);
      while (1)
      {
        if (v43 + v106 > a5) {
          goto LABEL_91;
        }
        unint64_t v47 = kDistanceCacheOffset[v44] + (uint64_t)*(int *)(a12 + 32 * v35 + 4 * kDistanceCacheIndex[v44] + 8);
        unint64_t v48 = v17 - v47;
        BOOL v49 = v104 < v47 || v48 >= v17;
        unint64_t v50 = v48 & a5;
        unint64_t v51 = v50 + v43;
        BOOL v52 = v49 || v51 > a5;
        if (!v52 && *(unsigned __int8 *)(a4 + v43 + v106) == *(unsigned __int8 *)(a4 + v51))
        {
          uint64_t v53 = a4 + v50;
          if (v108 < 8)
          {
            unint64_t v58 = 0;
            unint64_t v59 = v97;
LABEL_86:
            unint64_t v73 = v108 & 7;
            if ((v108 & 7) != 0)
            {
              unint64_t v74 = v108 & 7 | v58;
              while (*(unsigned __int8 *)(v53 + v58) == *v59)
              {
                ++v59;
                ++v58;
                if (!--v73)
                {
                  unint64_t v58 = v74;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v54 = 0;
            unint64_t v55 = v108 >> 3;
            while (1)
            {
              uint64_t v56 = *(void *)&v97[v54];
              uint64_t v57 = *(void *)(v53 + v54);
              if (v56 != v57) {
                break;
              }
              v54 += 8;
              if (!--v55)
              {
                unint64_t v59 = v96;
                unint64_t v58 = v108 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_86;
              }
            }
            unint64_t v58 = v54 + (__clz(__rbit64(v57 ^ v56)) >> 3);
          }
          if (v43 + 1 <= v58) {
            break;
          }
        }
LABEL_46:
        if (v44 <= 0xE)
        {
          ++v44;
          if (v43 < v108) {
            continue;
          }
        }
        goto LABEL_91;
      }
      float v60 = *(float *)(*(void *)(a11 + 2816) + 4 * v44);
      BOOL v62 = v102 < 8u && v44 == 0;
      unint64_t v63 = (float *)(v23 + 28 + 16 * (v107 + v43));
      unint64_t v64 = v43;
      while (2)
      {
        unint64_t v65 = v64 + 1;
        if (v64 + 1 <= 9)
        {
          LOWORD(v66) = v64 - 1;
          goto LABEL_70;
        }
        if (v65 <= 0x85)
        {
          unsigned int v67 = __clz(v64 - 5);
          unsigned int v66 = ((v64 - 5) >> ((v67 ^ 0x1F) - 1)) + 2 * ((v67 ^ 0x1F) - 1) + 4;
          goto LABEL_70;
        }
        if (v65 > 0x845)
        {
          LOWORD(v66) = 23;
          int v68 = v45 | 7;
        }
        else
        {
          unsigned int v66 = (__clz(v64 - 69) ^ 0x1F) + 12;
LABEL_70:
          int v68 = v66 & 7 | v45;
          char v69 = !v62;
          if ((unsigned __int16)v66 > 0xFu) {
            char v69 = 1;
          }
          if ((v69 & 1) == 0)
          {
            if ((v66 & 0xFFF8) != 0) {
              LOWORD(v68) = v68 | 0x40;
            }
LABEL_77:
            if ((v68 & 0xFF80) != 0) {
              float v70 = v60;
            }
            else {
              float v70 = -0.0;
            }
            float v71 = *(float *)(a11 + 4 * (unsigned __int16)v68)
                + (float)((float)(v42 + v70) + (float)kBrotliCopyExtra[(unsigned __int16)v66]);
            if (v71 < *v63)
            {
              *((_DWORD *)v63 - 3) = (v64 + 1) | 0x12000000;
              *((_DWORD *)v63 - 2) = v47;
              *((_DWORD *)v63 - 1) = ((v44 << 27) + 0x8000000) | v36;
              *unint64_t v63 = v71;
              if (result <= v65) {
                unint64_t result = v64 + 1;
              }
            }
            unint64_t v43 = v64 + 1;
            unint64_t v72 = v64 + 2;
            v63 += 4;
            ++v64;
            if (v72 > v58) {
              goto LABEL_46;
            }
            continue;
          }
        }
        break;
      }
      int v68 = ((((0x520D40u >> (2 * (v46 + ((unsigned __int16)(v66 & 0xFFF8) >> 3)))) & 0xC0)
            + ((v46 + ((unsigned __int16)(v66 & 0xFFF8) >> 3)) << 6)) | v68)
          + 64;
      goto LABEL_77;
    }
LABEL_91:
    if (v103 <= 1 && a9)
    {
      uint64_t v75 = 0;
      unint64_t v76 = v98;
      do
      {
        unint64_t v77 = *(void *)(a10 + 8 * v75);
        LOWORD(v78) = v77 + 15;
        uint64_t v79 = *(unsigned int *)(a6 + 68);
        uint64_t v80 = v79 + 16;
        if (v79 + 16 <= (unint64_t)v77 + 15)
        {
          uint64_t v81 = *(unsigned int *)(a6 + 64);
          unint64_t v82 = v77 + ~v79 + (4 << v81);
          uint64_t v83 = (__clz(v82) ^ 0x1F) - 1;
          uint64_t v78 = ((v82 & ~(-1 << v81)) + v80 + ((((v82 >> v83) & 1 | (2 * (v83 - v81))) - 2) << v81)) | ((v83 - v81) << 10);
        }
        unint64_t v84 = v77 >> 37;
        if ((v77 >> 37 > v19 || v18 < v77) && v76 < v84) {
          unint64_t v76 = v77 >> 37;
        }
        if (v76 <= v77 >> 37)
        {
          float v87 = *(float *)(*(void *)(a11 + 2816) + 4 * (v78 & 0x3FF))
              + (float)(v42 + (float)((unsigned __int16)v78 >> 10));
          uint64_t v88 = HIDWORD(v77) & 0x1F;
          if ((v77 & 0x1F00000000) == 0) {
            uint64_t v88 = v77 >> 37;
          }
          unint64_t v89 = v84 + 1;
          int v90 = (v76 << 25) + 301989888;
          unint64_t v91 = (float *)(v23 + 12 + 16 * (v107 + v76));
          do
          {
            if (v18 >= v77) {
              unint64_t v92 = v76;
            }
            else {
              unint64_t v92 = v88;
            }
            if (v92 > 9)
            {
              unsigned int v93 = (__clz(v92 - 70) ^ 0x1F) + 12;
              if (v92 > 0x845) {
                LOWORD(v93) = 23;
              }
              unsigned int v94 = (__clz(v92 - 6) ^ 0x1F) - 1;
              if (v92 <= 0x85) {
                LOWORD(v93) = ((v92 - 6) >> v94) + 2 * v94 + 4;
              }
            }
            else
            {
              LOWORD(v93) = v92 - 2;
            }
            float v95 = *(float *)(a11
                           + 4
                           * (unsigned __int16)(((((0x520D40u >> (2
                                                                * (3 * (v102 >> 3)
                                                                 + ((unsigned __int16)(v93 & 0xFFF8) >> 3)))) & 0xC0)
                                                + ((3 * (v102 >> 3) + ((unsigned __int16)(v93 & 0xFFF8) >> 3)) << 6)) | v93 & 7 | (8 * (v102 & 7)))
                                              + 64))
                + (float)(v87 + (float)kBrotliCopyExtra[(unsigned __int16)v93]);
            if (v95 < *v91)
            {
              *((_DWORD *)v91 - 3) = (v90 - (v92 << 25)) | v76;
              *((_DWORD *)v91 - 2) = v77;
              *((_DWORD *)v91 - 1) = v36;
              *unint64_t v91 = v95;
              if (result <= v76) {
                unint64_t result = v76;
              }
            }
            ++v76;
            v90 += 0x2000000;
            v91 += 4;
          }
          while (v89 != v76);
          unint64_t v76 = v89;
        }
        ++v75;
      }
      while (v75 != a9);
    }
    if (v100 >= 11)
    {
      unint64_t v31 = v103 + 1;
      uint64_t v20 = a12;
      unint64_t v15 = v107;
      if (v103 < 4) {
        continue;
      }
    }
    return result;
  }
}

void *EvaluateNode(void *result, unint64_t a2, unint64_t a3, void *__src, uint64_t a5, uint64_t a6, uint64_t a7)
{
  float v8 = (_DWORD *)(a7 + 16 * a2);
  float v9 = v8 + 3;
  float v10 = *((float *)v8 + 3);
  if (a2)
  {
    unint64_t v11 = v8[1];
    uint64_t v12 = *v8 & 0x1FFFFFF;
    unsigned int v13 = v8[2];
    if (v11 > a3 || v11 + v12 > (unint64_t)result + a2) {
      goto LABEL_10;
    }
    int v15 = v11 + 15;
    if (v13 >> 27) {
      int v15 = (v13 >> 27) - 1;
    }
    if (!v15) {
LABEL_10:
    }
      uint64_t v16 = *(unsigned int *)(a7 + 16 * (a2 - ((v13 & 0x7FFFFFF) + v12)) + 12);
    else {
      uint64_t v16 = a2;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  _DWORD *v9 = v16;
  float v17 = *(float *)(*(void *)(a5 + 2832) + 4 * a2) - **(float **)(a5 + 2832);
  if (v10 <= v17)
  {
    *(void *)&long long v35 = 0;
    long long v34 = a2;
    *((float *)&v35 + 2) = v10 - v17;
    *((float *)&v35 + 3) = v10;
    unint64_t v18 = 0;
    if (!v16) {
      goto LABEL_17;
    }
    do
    {
      unint64_t v19 = v18;
      uint64_t v20 = (int *)(a7 + 16 * v16);
      int v21 = *v20;
      int v22 = v20[2];
      *((_DWORD *)&v34 + v19 + 2) = v20[1];
      unint64_t v18 = v19 + 1;
      if (v19 > 2) {
        break;
      }
      uint64_t v16 = *(unsigned int *)(a7 + 16 * (v16 - ((v21 & 0x1FFFFFF) + (v22 & 0x7FFFFFFu))) + 12);
    }
    while (v16);
    if ((v18 & 0xFFFFFFFC) == 0) {
LABEL_17:
    }
      unint64_t result = memcpy((char *)&v34 + 4 * v18 + 8, __src, 16 - 4 * v18);
    uint64_t v23 = *(void *)(a6 + 256);
    *(void *)(a6 + 256) = v23 + 1;
    uint64_t v24 = ~(_BYTE)v23 & 7;
    if ((unint64_t)(v23 + 1) < 8) {
      unint64_t v25 = v23 + 1;
    }
    else {
      unint64_t v25 = 8;
    }
    long long v26 = v35;
    uint64_t v27 = (_OWORD *)(a6 + 32 * v24);
    *uint64_t v27 = v34;
    v27[1] = v26;
    if (v25 >= 2)
    {
      unint64_t v28 = v25 - 1;
      do
      {
        uint64_t v29 = (float *)(a6 + 32 * (v24 & 7));
        unint64_t v30 = (float *)(a6 + 32 * (((_BYTE)v24 + 1) & 7));
        if (v29[6] > v30[6])
        {
          long long v32 = *(_OWORD *)v29;
          long long v31 = *((_OWORD *)v29 + 1);
          long long v33 = *((_OWORD *)v30 + 1);
          *(_OWORD *)uint64_t v29 = *(_OWORD *)v30;
          *((_OWORD *)v29 + 1) = v33;
          *(_OWORD *)unint64_t v30 = v32;
          *((_OWORD *)v30 + 1) = v31;
        }
        LOBYTE(v24) = v24 + 1;
        --v28;
      }
      while (v28);
    }
  }
  return result;
}

uint64_t ComputeShortestPathFromNodes(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (_DWORD *)(a2 + 16 * a1);
  if ((v2[2] & 0x7FFFFFF) == 0)
  {
    uint64_t v3 = (_DWORD *)(a2 + 16 * a1);
    do
    {
      int v4 = *v3;
      v3 -= 4;
      if (v4 != 1) {
        break;
      }
      --a1;
      int v5 = *(v2 - 2);
      uint64_t v2 = v3;
    }
    while ((v5 & 0x7FFFFFF) == 0);
  }
  *(_DWORD *)(a2 + 16 * a1 + 12) = -1;
  for (uint64_t i = 0; a1; *(_DWORD *)(a2 + 16 * a1 + 12) = v7)
  {
    uint64_t v7 = (*(_DWORD *)(a2 + 16 * a1 + 8) & 0x7FFFFFF) + (*(_DWORD *)(a2 + 16 * a1) & 0x1FFFFFFu);
    ++i;
    a1 -= v7;
  }
  return i;
}

uint64_t BrotliCreateZopfliBackwardReferences(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13)
{
  uint64_t v18 = result;
  uint64_t v19 = a2 + 1;
  if (a2 == -1)
  {
    if (*(_DWORD *)(result + 24)) {
      return result;
    }
    uint64_t v20 = 0;
  }
  else
  {
    unint64_t result = BrotliAllocate(result);
    if (*(_DWORD *)(v18 + 24)) {
      return result;
    }
    uint64_t v20 = (_DWORD *)result;
    uint64_t v21 = result + 12;
    do
    {
      *(void *)(v21 - 12) = 1;
      *(void *)(v21 - 4) = 0x7EFFC99E00000000;
      v21 += 16;
      --v19;
    }
    while (v19);
  }
  unint64_t result = BrotliZopfliComputeShortestPath(v18, a2, a3, a4, a5, a6, a7, a9, a8, v20);
  *a12 += result;
  if (!*(_DWORD *)(v18 + 24))
  {
    BrotliZopfliCreateCommands(a2, a3, (uint64_t)v20, a9, a10, a7, a11, a13);
    return BrotliFree(v18, (unint64_t)v20);
  }
  return result;
}

void BrotliCreateHqZopfliBackwardReferences(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long *a9, void *a10, uint64_t a11, uint64_t *a12, void *a13)
{
  uint64_t v13 = MEMORY[0x270FA5388]();
  unsigned int v225 = v16;
  unint64_t v242 = v17;
  uint64_t v19 = v18;
  uint64_t v240 = v20;
  unint64_t v21 = v14;
  uint64_t v22 = v13;
  uint64_t v290 = *MEMORY[0x263EF8340];
  uint64_t v241 = v15;
  uint64_t v245 = v19;
  unint64_t v246 = v14;
  uint64_t v227 = v13;
  if (v14)
  {
    uint64_t v224 = *(void *)(v15 + 16);
    int v23 = *(_DWORD *)(v15 + 8);
    uint64_t v24 = 4 * v14;
    uint64_t v25 = BrotliAllocate(v13);
    unint64_t v26 = v24;
    unint64_t v21 = v246;
    unint64_t v239 = v25;
    long long v277 = 0u;
    long long v278 = 0u;
    if (v246 >= 0x7F) {
      unint64_t v27 = v246 - 127;
    }
    else {
      unint64_t v27 = 0;
    }
    long long v275 = 0uLL;
    long long v276 = 0uLL;
    long long v273 = 0uLL;
    long long v274 = 0uLL;
    long long v271 = 0uLL;
    long long v272 = 0uLL;
    long long v269 = 0uLL;
    long long v270 = 0uLL;
    long long v267 = 0uLL;
    long long v268 = 0uLL;
    long long v265 = 0uLL;
    long long v266 = 0uLL;
    long long v263 = 0uLL;
    long long v264 = 0uLL;
    long long v261 = 0uLL;
    long long v262 = 0uLL;
    long long v259 = 0uLL;
    long long v260 = 0uLL;
    long long v257 = 0uLL;
    long long v258 = 0uLL;
    long long v255 = 0uLL;
    long long v256 = 0uLL;
    long long v253 = 0uLL;
    long long v254 = 0uLL;
    long long v251 = 0uLL;
    long long v252 = 0uLL;
    long long v249 = 0uLL;
    long long v250 = 0uLL;
    long long v247 = 0uLL;
    long long v248 = 0uLL;
    if (v26)
    {
      unint64_t v28 = v26;
      uint64_t v29 = BrotliAllocate(v22);
      unint64_t v26 = v28;
      unint64_t v21 = v246;
      unint64_t v30 = (char *)v29;
    }
    else
    {
      unint64_t v30 = 0;
    }
    int v232 = (_DWORD *)(v22 + 24);
    uint64_t v15 = v241;
    unint64_t v31 = v242;
    if (*(_DWORD *)(v22 + 24)) {
      return;
    }
    if (v21 < 4)
    {
      int v228 = 0;
    }
    else
    {
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      unint64_t v220 = v27 + v240;
      unint64_t v222 = (1 << v23) - 16;
      unsigned int v237 = v225 + 8;
      do
      {
        unint64_t v34 = v32 + v240;
        if (v32 + v240 >= v222) {
          unint64_t v35 = v222;
        }
        else {
          unint64_t v35 = v32 + v240;
        }
        if (v34 + v224 >= v222) {
          unint64_t v36 = v222;
        }
        else {
          unint64_t v36 = v34 + v224;
        }
        if (v26 < v33 + 128)
        {
          if (v26) {
            unint64_t v37 = v26;
          }
          else {
            unint64_t v37 = v33 + 128;
          }
          do
          {
            unint64_t v38 = v37;
            v37 *= 2;
          }
          while (v38 < v33 + 128);
          uint64_t v39 = v32;
          uint64_t v40 = v33;
          if (v38)
          {
            unsigned int v41 = v30;
            unint64_t v42 = v26;
            uint64_t v43 = BrotliAllocate(v227);
            unint64_t v26 = v42;
            unint64_t v30 = v41;
            unint64_t v44 = (char *)v43;
          }
          else
          {
            unint64_t v44 = 0;
          }
          if (*v232) {
            BOOL v45 = 1;
          }
          else {
            BOOL v45 = v26 == 0;
          }
          if (!v45)
          {
            int v46 = v30;
            memcpy(v44, v30, 8 * v26);
            unint64_t v30 = v46;
          }
          BrotliFree(v227, (unint64_t)v30);
          unint64_t v26 = v38;
          unint64_t v30 = v44;
          uint64_t v15 = v241;
          unint64_t v31 = v242;
          unint64_t v21 = v246;
          uint64_t v33 = v40;
          uint64_t v32 = v39;
        }
        if (*v232) {
          return;
        }
        unint64_t v223 = v36;
        uint64_t v233 = v32;
        uint64_t v235 = v33;
        unint64_t v47 = v21 - v32;
        int v243 = v30;
        unint64_t v48 = &v30[8 * v33];
        unint64_t v49 = v34 & v31;
        unint64_t v50 = 16;
        if (*(_DWORD *)(v15 + 4) == 11) {
          unint64_t v50 = 64;
        }
        BOOL v88 = v34 >= v50;
        unint64_t v51 = v34 - v50;
        if (!v88) {
          unint64_t v51 = 0;
        }
        unint64_t v52 = v34 - 1;
        unsigned int v229 = &v30[8 * v33];
        unint64_t v230 = v26;
        if (v34 - 1 <= v51)
        {
          unint64_t v54 = 1;
        }
        else
        {
          uint64_t v53 = (unsigned __int8 *)(v19 + v49);
          unint64_t v54 = 1;
          do
          {
            if (v34 - v52 > v35) {
              break;
            }
            unint64_t v55 = (unsigned __int8 *)(v19 + (v52 & v31));
            if (*v53 == *v55 && *(unsigned __int8 *)(v19 + v49 + 1) == *(unsigned __int8 *)((v52 & v31) + v19 + 1))
            {
              if (v47 < 8)
              {
                unint64_t v60 = 0;
                uint64_t v61 = (unsigned __int8 *)(v19 + v49);
LABEL_55:
                if ((v47 & 7) != 0)
                {
                  unint64_t v62 = v47 & 7 | v60;
                  unint64_t v63 = v47 & 7;
                  while (v55[v60] == *v61)
                  {
                    ++v61;
                    ++v60;
                    if (!--v63)
                    {
                      unint64_t v60 = v62;
                      break;
                    }
                  }
                }
              }
              else
              {
                uint64_t v56 = 0;
                unint64_t v57 = v47 >> 3;
                while (1)
                {
                  uint64_t v58 = *(void *)&v53[v56];
                  uint64_t v59 = *(void *)&v55[v56];
                  if (v58 != v59) {
                    break;
                  }
                  v56 += 8;
                  if (!--v57)
                  {
                    unint64_t v60 = v47 & 0xFFFFFFFFFFFFFFF8;
                    uint64_t v61 = (unsigned __int8 *)(v19 + v49 + (v47 & 0xFFFFFFFFFFFFFFF8));
                    goto LABEL_55;
                  }
                }
                unint64_t v60 = v56 + (__clz(__rbit64(v59 ^ v58)) >> 3);
              }
              if (v60 > v54)
              {
                *(_DWORD *)unint64_t v48 = v34 - v52;
                *((_DWORD *)v48 + 1) = 32 * v60;
                v48 += 8;
                unint64_t v54 = v60;
              }
            }
            if (--v52 <= v51) {
              break;
            }
          }
          while (v54 < 3);
        }
        if (v54 < v47)
        {
          uint64_t v64 = (506832829 * *(_DWORD *)(v19 + v49)) >> 15;
          uint64_t v65 = v225[9];
          uint64_t v67 = v225[6];
          uint64_t v66 = v225[7];
          uint64_t v68 = *(unsigned int *)(v66 + 4 * v64);
          if (v47 >= 0x80) {
            unint64_t v69 = 128;
          }
          else {
            unint64_t v69 = v47;
          }
          if (v47 >= 0x80) {
            *(_DWORD *)(v66 + 4 * v64) = v34;
          }
          uint64_t v70 = 2 * (v67 & v34);
          uint64_t v71 = v70 | 1;
          if (v34 != v68)
          {
            unint64_t v119 = 0;
            unint64_t v120 = 0;
            uint64_t v121 = 64;
            do
            {
              if (v34 - v68 > v35 || v121 == 0) {
                break;
              }
              unint64_t v123 = v68 & v31;
              if (v120 >= v119) {
                unint64_t v124 = v119;
              }
              else {
                unint64_t v124 = v120;
              }
              uint64_t v125 = v19 + v124 + v49;
              unint64_t v126 = (unsigned __int8 *)(v19 + v124 + v123);
              unint64_t v127 = v47 - v124;
              if (v47 - v124 < 8)
              {
                unint64_t v130 = 0;
LABEL_166:
                uint64_t v135 = v127 & 7;
                if (v135)
                {
                  unint64_t v136 = v130 | v135;
                  while (*(unsigned __int8 *)(v125 + v130) == *v126)
                  {
                    ++v126;
                    ++v130;
                    if (!--v135)
                    {
                      unint64_t v130 = v136;
                      break;
                    }
                  }
                }
              }
              else
              {
                uint64_t v128 = 0;
                unint64_t v129 = v127 >> 3;
                unint64_t v130 = v127 & 0xFFFFFFFFFFFFFFF8;
                while (1)
                {
                  uint64_t v131 = *(void *)&v126[v128];
                  uint64_t v132 = *(void *)(v125 + v128);
                  if (v131 != v132) {
                    break;
                  }
                  v128 += 8;
                  if (!--v129)
                  {
                    v126 += v127 & 0xFFFFFFFFFFFFFFF8;
                    uint64_t v19 = v245;
                    goto LABEL_166;
                  }
                }
                unint64_t v130 = v128 + (__clz(__rbit64(v132 ^ v131)) >> 3);
                uint64_t v19 = v245;
              }
              unint64_t v133 = v130 + v124;
              if (v48 && v133 > v54)
              {
                *(_DWORD *)unint64_t v48 = v34 - v68;
                *((_DWORD *)v48 + 1) = 32 * v133;
                v48 += 8;
                unint64_t v54 = v133;
              }
              if (v133 >= v69)
              {
                if (v47 < 0x80) {
                  goto LABEL_71;
                }
                uint64_t v166 = (int *)(v65 + 8 * (v68 & v67));
                int v167 = *v166;
                unint64_t v72 = v166 + 1;
                *(_DWORD *)(v65 + 4 * v70) = v167;
                goto LABEL_70;
              }
              if (*(unsigned __int8 *)(v19 + v133 + v49) <= *(unsigned __int8 *)(v19 + v133 + v123))
              {
                if (v47 >= 0x80) {
                  *(_DWORD *)(v65 + 4 * v71) = v68;
                }
                uint64_t v134 = 2 * (v68 & v67);
                uint64_t v71 = v134;
                unint64_t v119 = v133;
              }
              else
              {
                if (v47 >= 0x80) {
                  *(_DWORD *)(v65 + 4 * v70) = v68;
                }
                uint64_t v134 = (2 * (v68 & v67)) | 1;
                uint64_t v70 = v134;
                unint64_t v120 = v133;
              }
              uint64_t v68 = *(unsigned int *)(v65 + 4 * v134);
              --v121;
            }
            while (v34 != v68);
          }
          if (v47 >= 0x80)
          {
            *(_DWORD *)(v65 + 4 * v70) = *v237;
            unint64_t v72 = v225 + 8;
LABEL_70:
            *(_DWORD *)(v65 + 4 * v71) = *v72;
          }
        }
LABEL_71:
        memset_pattern16(v287, &unk_20DAD64E0, 0x98uLL);
        if (v54 + 1 > 4) {
          unint64_t v73 = v54 + 1;
        }
        else {
          unint64_t v73 = 4;
        }
        if (BrotliFindAllStaticDictionaryMatches((uint64_t *)(v241 + 88), (unsigned __int8 *)(v19 + v49), v73, v47, (uint64_t)v287))
        {
          if (v47 >= 0x25) {
            unint64_t v74 = 37;
          }
          else {
            unint64_t v74 = v47;
          }
          uint64_t v15 = v241;
          unint64_t v30 = v243;
          uint64_t v75 = v233;
          uint64_t v33 = v235;
          if (v73 <= v74)
          {
            unint64_t v76 = v74 + 1;
            int v77 = 32 * v73;
            unint64_t v31 = v242;
            do
            {
              unint64_t v78 = *((unsigned int *)v287 + v73);
              if (v78 <= 0xFFFFFFE)
              {
                unint64_t v79 = v223 + 1 + (v78 >> 5);
                if (v79 <= *(void *)(v241 + 80))
                {
                  uint64_t v80 = v78 & 0x1F;
                  if (v73 == v80) {
                    LODWORD(v80) = 0;
                  }
                  *(_DWORD *)unint64_t v48 = v79;
                  *((_DWORD *)v48 + 1) = v77 + v80;
                  v48 += 8;
                }
              }
              ++v73;
              v77 += 32;
            }
            while (v76 != v73);
          }
          else
          {
            unint64_t v31 = v242;
          }
        }
        else
        {
          uint64_t v15 = v241;
          unint64_t v31 = v242;
          unint64_t v30 = v243;
          uint64_t v75 = v233;
          uint64_t v33 = v235;
        }
        uint64_t v81 = (v48 - v229) >> 3;
        *(_DWORD *)(v239 + 4 * v75) = v81;
        if (v48 != v229)
        {
          uint64_t v82 = v81 + v33;
          uint64_t v83 = v81 + v33 - 1;
          unint64_t v84 = *(unsigned int *)&v30[8 * v83 + 4];
          if (v84 >> 6 < 0xA3)
          {
            uint64_t v33 = v82;
          }
          else
          {
            *(void *)&v30[8 * v33] = *(void *)&v30[8 * v83];
            *(_DWORD *)(v239 + 4 * v75) = 1;
            unint64_t v85 = v34 + 1;
            unint64_t v86 = v34 + (v84 >> 5);
            if (v86 >= v220) {
              unint64_t v86 = v220;
            }
            if (v34 + 64 > v86) {
              unint64_t v87 = v34 + 1;
            }
            else {
              unint64_t v87 = v86 - 63;
            }
            BOOL v88 = v34 + 513 > v87 || v85 >= v87;
            if (!v88)
            {
              uint64_t v137 = v225[6];
              uint64_t v138 = v225[7];
              uint64_t v139 = v225[9];
              while (1)
              {
                unint64_t v140 = v85 & v31;
                unsigned int v141 = (506832829 * *(_DWORD *)(v19 + (v85 & v31))) >> 15;
                uint64_t v142 = *(unsigned int *)(v138 + 4 * v141);
                uint64_t v143 = 2 * (v137 & v85);
                uint64_t v144 = v143 | 1;
                *(_DWORD *)(v138 + 4 * v141) = v85;
                if (v85 != v142) {
                  break;
                }
LABEL_172:
                int v145 = *v237;
                *(_DWORD *)(v139 + 4 * v143) = *v237;
LABEL_173:
                *(_DWORD *)(v139 + 4 * v144) = v145;
                v85 += 8;
                if (v85 >= v87) {
                  goto LABEL_100;
                }
              }
              unint64_t v146 = 0;
              unint64_t v147 = 0;
              uint64_t v148 = 64;
              while (2)
              {
                if (v85 - v142 > v137 - 15 || v148 == 0) {
                  goto LABEL_172;
                }
                unint64_t v150 = v142 & v31;
                if (v147 >= v146) {
                  unint64_t v151 = v146;
                }
                else {
                  unint64_t v151 = v147;
                }
                unint64_t v152 = v19 + v140 + v151;
                unint64_t v153 = (unsigned __int8 *)(v19 + v151 + v150);
                unint64_t v154 = 128 - v151;
                if (128 - v151 < 8)
                {
                  unint64_t v157 = 0;
LABEL_197:
                  uint64_t v163 = v154 & 7;
                  if (v163)
                  {
                    unint64_t v164 = v157 | v163;
                    while (*(unsigned __int8 *)(v152 + v157) == *v153)
                    {
                      ++v153;
                      ++v157;
                      if (!--v163)
                      {
                        unint64_t v157 = v164;
                        goto LABEL_189;
                      }
                    }
                    goto LABEL_189;
                  }
                }
                else
                {
                  uint64_t v155 = 0;
                  unint64_t v156 = v154 >> 3;
                  unint64_t v157 = v154 & 0xFFFFFFFFFFFFFFF8;
                  while (1)
                  {
                    uint64_t v158 = *(void *)&v153[v155];
                    uint64_t v159 = *(void *)(v152 + v155);
                    if (v158 != v159) {
                      break;
                    }
                    v155 += 8;
                    if (!--v156)
                    {
                      v153 += v154 & 0xFFFFFFFFFFFFFFF8;
                      uint64_t v19 = v245;
                      goto LABEL_197;
                    }
                  }
                  unint64_t v157 = v155 + (__clz(__rbit64(v159 ^ v158)) >> 3);
LABEL_189:
                  uint64_t v19 = v245;
                }
                unint64_t v160 = v157 + v151;
                if (v160 >= 0x80)
                {
                  uint64_t v165 = (_DWORD *)(v139 + 8 * (v142 & v137));
                  *(_DWORD *)(v139 + 4 * v143) = *v165;
                  int v145 = v165[1];
                  goto LABEL_173;
                }
                unsigned int v161 = *(unsigned __int8 *)(v19 + v160 + v150);
                uint64_t v162 = 2 * (v142 & v137);
                if (*(unsigned __int8 *)(v19 + v160 + v140) <= v161)
                {
                  *(_DWORD *)(v139 + 4 * v144) = v142;
                  uint64_t v144 = 2 * (v142 & v137);
                  unint64_t v146 = v160;
                }
                else
                {
                  *(_DWORD *)(v139 + 4 * v143) = v142;
                  v162 |= 1uLL;
                  uint64_t v143 = v162;
                  unint64_t v147 = v160;
                }
                uint64_t v142 = *(unsigned int *)(v139 + 4 * v162);
                --v148;
                if (v85 == v142) {
                  goto LABEL_172;
                }
                continue;
              }
            }
LABEL_100:
            if (v87 < v86)
            {
              uint64_t v89 = v225[6];
              uint64_t v90 = v225[7];
              uint64_t v91 = v225[9];
              while (1)
              {
                unint64_t v92 = v87 & v31;
                unsigned int v93 = (506832829 * *(_DWORD *)(v19 + (v87 & v31))) >> 15;
                uint64_t v94 = *(unsigned int *)(v90 + 4 * v93);
                uint64_t v95 = 2 * (v89 & v87);
                uint64_t v96 = v95 | 1;
                *(_DWORD *)(v90 + 4 * v93) = v87;
                if (v87 != v94) {
                  break;
                }
LABEL_103:
                int v97 = *v237;
                *(_DWORD *)(v91 + 4 * v95) = *v237;
LABEL_104:
                *(_DWORD *)(v91 + 4 * v96) = v97;
                if (++v87 >= v86) {
                  goto LABEL_135;
                }
              }
              unint64_t v98 = 0;
              unint64_t v99 = 0;
              uint64_t v100 = 64;
              while (2)
              {
                if (v87 - v94 > v89 - 15 || v100 == 0) {
                  goto LABEL_103;
                }
                unint64_t v102 = v94 & v31;
                if (v99 >= v98) {
                  unint64_t v103 = v98;
                }
                else {
                  unint64_t v103 = v99;
                }
                unint64_t v104 = v19 + v92 + v103;
                unint64_t v105 = (unsigned __int8 *)(v19 + v103 + v102);
                unint64_t v106 = 128 - v103;
                if (128 - v103 < 8)
                {
                  unint64_t v109 = 0;
LABEL_128:
                  uint64_t v115 = v106 & 7;
                  if (v115)
                  {
                    unint64_t v116 = v109 | v115;
                    while (*(unsigned __int8 *)(v104 + v109) == *v105)
                    {
                      ++v105;
                      ++v109;
                      if (!--v115)
                      {
                        unint64_t v109 = v116;
                        goto LABEL_120;
                      }
                    }
                    goto LABEL_120;
                  }
                }
                else
                {
                  uint64_t v107 = 0;
                  unint64_t v108 = v106 >> 3;
                  unint64_t v109 = v106 & 0xFFFFFFFFFFFFFFF8;
                  while (1)
                  {
                    uint64_t v110 = *(void *)&v105[v107];
                    uint64_t v111 = *(void *)(v104 + v107);
                    if (v110 != v111) {
                      break;
                    }
                    v107 += 8;
                    if (!--v108)
                    {
                      v105 += v106 & 0xFFFFFFFFFFFFFFF8;
                      uint64_t v19 = v245;
                      goto LABEL_128;
                    }
                  }
                  unint64_t v109 = v107 + (__clz(__rbit64(v111 ^ v110)) >> 3);
LABEL_120:
                  uint64_t v19 = v245;
                }
                unint64_t v112 = v109 + v103;
                if (v112 >= 0x80)
                {
                  unint64_t v117 = (_DWORD *)(v91 + 8 * (v94 & v89));
                  *(_DWORD *)(v91 + 4 * v95) = *v117;
                  int v97 = v117[1];
                  goto LABEL_104;
                }
                unsigned int v113 = *(unsigned __int8 *)(v19 + v112 + v102);
                uint64_t v114 = 2 * (v94 & v89);
                if (*(unsigned __int8 *)(v19 + v112 + v92) <= v113)
                {
                  *(_DWORD *)(v91 + 4 * v96) = v94;
                  uint64_t v96 = 2 * (v94 & v89);
                  unint64_t v98 = v112;
                }
                else
                {
                  *(_DWORD *)(v91 + 4 * v95) = v94;
                  v114 |= 1uLL;
                  uint64_t v95 = v114;
                  unint64_t v99 = v112;
                }
                uint64_t v94 = *(unsigned int *)(v91 + 4 * v114);
                --v100;
                if (v87 == v94) {
                  goto LABEL_103;
                }
                continue;
              }
            }
LABEL_135:
            uint64_t v118 = (v84 >> 5) - 1;
            bzero((void *)(v239 + 4 * v233 + 4), 4 * v118);
            uint64_t v33 = v235 + 1;
            uint64_t v15 = v241;
            unint64_t v31 = v242;
            uint64_t v75 = v118 + v233;
            unint64_t v30 = v243;
          }
        }
        uint64_t v32 = v75 + 1;
        unint64_t v21 = v246;
        unint64_t v26 = v230;
      }
      while (v75 + 4 < v246);
      int v228 = 1;
    }
  }
  else
  {
    long long v277 = 0u;
    long long v278 = 0u;
    long long v275 = 0u;
    long long v276 = 0u;
    long long v273 = 0u;
    long long v274 = 0u;
    long long v271 = 0u;
    long long v272 = 0u;
    long long v269 = 0u;
    long long v270 = 0u;
    long long v267 = 0u;
    long long v268 = 0u;
    long long v265 = 0u;
    long long v266 = 0u;
    long long v263 = 0u;
    long long v264 = 0u;
    long long v261 = 0u;
    long long v262 = 0u;
    long long v259 = 0u;
    long long v260 = 0u;
    long long v257 = 0u;
    long long v258 = 0u;
    long long v255 = 0u;
    long long v256 = 0u;
    long long v253 = 0u;
    long long v254 = 0u;
    long long v251 = 0u;
    long long v252 = 0u;
    long long v249 = 0u;
    long long v250 = 0u;
    long long v247 = 0u;
    long long v248 = 0u;
    int v232 = (_DWORD *)(v13 + 24);
    if (*(_DWORD *)(v13 + 24)) {
      return;
    }
    int v228 = 0;
    unint64_t v239 = 0;
    unint64_t v30 = 0;
  }
  unint64_t v244 = (unint64_t)v30;
  unint64_t v169 = a12;
  unint64_t v168 = a13;
  unsigned int v170 = a10;
  uint64_t v226 = *a13;
  uint64_t v231 = *a10;
  long long v284 = *a9;
  uint64_t v234 = *a12;
  unint64_t v171 = v21 + 1;
  if (v21 == -1)
  {
    int v172 = 0;
  }
  else
  {
    uint64_t v173 = BrotliAllocate(v227);
    unint64_t v21 = v246;
    uint64_t v15 = v241;
    int v172 = (_DWORD *)v173;
  }
  if (!*v232)
  {
    InitZopfliCostModel(v227, (uint64_t)&v247, v15 + 64, v21);
    if (!*(_DWORD *)(v227 + 24))
    {
      char v174 = 1;
      unint64_t v221 = v171;
      do
      {
        char v175 = v174;
        if (v171)
        {
          uint64_t v176 = v172 + 3;
          unint64_t v177 = v171;
          do
          {
            *(void *)(v176 - 3) = 1;
            *(void *)(v176 - 1) = 0x7EFFC99E00000000;
            v176 += 4;
            --v177;
          }
          while (v177);
        }
        char v236 = v175;
        if (v175)
        {
          ZopfliCostModelSetFromLiteralCosts((uint64_t)&v247);
          unint64_t v178 = v242;
          uint64_t v179 = v241;
          unint64_t v180 = v244;
        }
        else
        {
          uint64_t v181 = *v169;
          bzero(v289, 0x400uLL);
          bzero(v287, 0xB00uLL);
          bzero(v286, 0x880uLL);
          if (v181 != v234)
          {
            uint64_t v182 = 0;
            uint64_t v183 = v240 - v231;
            do
            {
              int v184 = (unsigned int *)(a11 + 16 * v182);
              uint64_t v185 = *v184;
              unsigned int v186 = v184[1];
              __int16 v187 = *((_WORD *)v184 + 7);
              unint64_t v188 = *((unsigned __int16 *)v184 + 6);
              ++*((_DWORD *)v287 + v188);
              if (v188 >= 0x80) {
                ++v286[v187 & 0x3FF];
              }
              if (v185)
              {
                uint64_t v189 = v183;
                uint64_t v190 = v185;
                do
                {
                  ++v289[*(unsigned __int8 *)(v19 + (v189++ & v242))];
                  --v190;
                }
                while (v190);
              }
              v183 += v185 + (v186 & 0x1FFFFFF);
              ++v182;
            }
            while (v182 != v181 - v234);
          }
          SetCost(v289, 256, 1, v285);
          SetCost((unsigned int *)v287, 704, 0, (float *)&v247);
          SetCost(v286, v280, 0, v279);
          uint64_t v191 = 0;
          float v192 = 1.7e38;
          do
          {
            if (v192 >= *(float *)((char *)&v247 + v191)) {
              float v192 = *(float *)((char *)&v247 + v191);
            }
            v191 += 4;
          }
          while (v191 != 2816);
          float v282 = v192;
          unsigned int v193 = v281;
          uint64_t v194 = v283;
          _DWORD *v281 = 0;
          uint64_t v179 = v241;
          unint64_t v178 = v242;
          unint64_t v180 = v244;
          if (v194)
          {
            int v195 = (float *)(v193 + 1);
            float v196 = 0.0;
            uint64_t v197 = v240;
            float v198 = 0.0;
            do
            {
              float v199 = v198 + v285[*(unsigned __int8 *)(v19 + (v197 & v242))];
              float v200 = v196 + v199;
              *v195++ = v196 + v199;
              float v198 = v199 - (float)((float)(v196 + v199) - v196);
              ++v197;
              float v196 = v200;
              --v194;
            }
            while (v194);
          }
        }
        *unint64_t v169 = v234;
        *unint64_t v168 = v226;
        *unsigned int v170 = v231;
        *a9 = v284;
        uint64_t v201 = *(void *)(v179 + 16);
        int v202 = *(_DWORD *)(v179 + 8);
        uint64_t v203 = 325;
        if (*(int *)(v179 + 4) < 11) {
          uint64_t v203 = 150;
        }
        unint64_t v238 = v203;
        *int v172 = 0;
        v172[3] = 0;
        uint64_t v288 = 0;
        unint64_t v204 = v246;
        if (v228)
        {
          unint64_t v205 = 0;
          uint64_t v206 = 0;
          unint64_t v207 = (1 << v202) - 16;
          int v208 = (void *)(v201 + v240);
          memset(v287, 0, sizeof(v287));
          do
          {
            unint64_t updated = UpdateNodes(v204, v240, v205, v19, v178, v179, v207, a9, *(unsigned int *)(v239 + 4 * v205), v180 + 8 * v206, (uint64_t)&v247, (uint64_t)v287, (uint64_t)v172);
            unint64_t v180 = v244;
            if (updated >= 0x4000) {
              unint64_t v210 = updated;
            }
            else {
              unint64_t v210 = 0;
            }
            uint64_t v211 = *(unsigned int *)(v239 + 4 * v205);
            v206 += v211;
            if (v211 == 1)
            {
              unint64_t v212 = *(unsigned int *)(v244 + 8 * v206 - 4);
              unint64_t v213 = v212 >> 5;
              if (v212 >> 5 <= v210) {
                unint64_t v213 = v210;
              }
              if (v238 < v212 >> 5) {
                unint64_t v210 = v213;
              }
            }
            if (v210 >= 2)
            {
              unint64_t v214 = v210 - 1;
              unint64_t v204 = v246;
              do
              {
                unint64_t v215 = v205 + 1;
                if (v205 + 4 >= v204) {
                  break;
                }
                EvaluateNode(v208, v205 + 1, v207, a9, (uint64_t)&v247, (uint64_t)v287, (uint64_t)v172);
                unint64_t v204 = v246;
                v206 += *(unsigned int *)(v239 + 4 + 4 * v205++);
                --v214;
              }
              while (v214);
              unint64_t v205 = v215;
              unint64_t v180 = v244;
              uint64_t v19 = v245;
            }
            else
            {
              unint64_t v204 = v246;
            }
            unint64_t v216 = v205 + 4;
            ++v205;
            uint64_t v179 = v241;
            unint64_t v178 = v242;
          }
          while (v216 < v204);
        }
        uint64_t v217 = v179;
        unint64_t v218 = v204;
        unsigned int v170 = a10;
        unint64_t v169 = a12;
        *a12 += ComputeShortestPathFromNodes(v204, (uint64_t)v172);
        uint64_t v219 = v218;
        unint64_t v168 = a13;
        BrotliZopfliCreateCommands(v219, v240, (uint64_t)v172, (uint64_t)a9, a10, v217, a11, a13);
        char v174 = 0;
        unint64_t v171 = v221;
      }
      while ((v236 & 1) != 0);
      BrotliFree(v227, (unint64_t)v281);
      uint64_t v281 = 0;
      BrotliFree(v227, (unint64_t)v279);
      unsigned int v279 = 0;
      BrotliFree(v227, (unint64_t)v172);
      BrotliFree(v227, v244);
      BrotliFree(v227, v239);
    }
  }
}

void SetCost(unsigned int *a1, uint64_t a2, int a3, float *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = a1;
  unint64_t v8 = 0;
  if (!a2) {
    goto LABEL_5;
  }
  float v9 = a1;
  uint64_t v10 = a2;
  do
  {
    unsigned int v11 = *v9++;
    v8 += v11;
    --v10;
  }
  while (v10);
  if (v8 > 0xFF)
  {
    double v12 = log2((double)v8);
    if (a3) {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_5:
    double v12 = kBrotliLog2Table[v8];
    if (a3) {
      goto LABEL_13;
    }
  }
  if (v6)
  {
    uint64_t v13 = v7;
    uint64_t v14 = v6;
    do
    {
      if (!*v13++) {
        ++v8;
      }
      --v14;
    }
    while (v14);
  }
LABEL_13:
  if (v8 > 0xFF)
  {
    double v16 = log2((double)v8);
    if (!v6) {
      return;
    }
  }
  else
  {
    double v16 = kBrotliLog2Table[v8];
    if (!v6) {
      return;
    }
  }
  float v17 = v12;
  float v18 = v16;
  float v19 = v18 + 2.0;
  do
  {
    unsigned int v21 = *v7++;
    uint64_t v20 = v21;
    if (v21)
    {
      if (v20 > 0xFF) {
        double v22 = log2((double)v20);
      }
      else {
        double v22 = kBrotliLog2Table[v20];
      }
      float v23 = v22;
      float v24 = v17 - v23;
      *a4 = v24;
      if (v24 < 1.0) {
        *a4 = 1.0;
      }
    }
    else
    {
      *a4 = v19;
    }
    ++a4;
    --v6;
  }
  while (v6);
}

uint64_t lzbitmap_encode_state_size(unsigned int a1)
{
  v2[17] = *MEMORY[0x263EF8340];
  return lzbitmap_init_encode_state((uint64_t)v2, a1);
}

uint64_t lzbitmap_init_encode_state(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = 0;
  if (a2 <= 2 && a1)
  {
    unsigned int v3 = dword_20DAD6540[a2];
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_DWORD *)(a1 + 80) = v3;
    *(_DWORD *)(a1 + 84) = a2;
    if (a2 >= 2) {
      int v4 = 18;
    }
    else {
      int v4 = 15;
    }
    int v5 = 2 << v4;
    *(_DWORD *)(a1 + 88) = v4;
    *(_DWORD *)(a1 + 92) = (2 << v4) + 16;
    unint64_t v6 = ((unint64_t)(v3 & 1) << 14) + 0x4000;
    *(_DWORD *)(a1 + 96) = v6;
    *(void *)(a1 + 100) = 0x30000000002;
    unint64_t v7 = v6 >> 2;
    *(_DWORD *)(a1 + 108) = ((v3 >> 2) | 0xFFFFFFFE) + 14;
    *(_DWORD *)(a1 + 112) = v6 >> 2;
    int v8 = (v6 >> 2) | 3;
    *(_DWORD *)(a1 + 116) = v8;
    unint64_t v9 = (a1 + 199) & 0xFFFFFFFFFFFFFFC0;
    unint64_t v10 = (v9 + (v5 + 79)) & 0xFFFFFFFFFFFFFFC0;
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = v10;
    unint64_t v11 = (v10 + (v6 >> 2) + 66) & 0xFFFFFFFFFFFFFFC0;
    unint64_t v12 = (v11 + (v7 | 0x3F)) & 0xFFFFFFFFFFFFFFC0;
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v12;
    *(void *)(a1 + 32) = (v12 + 3135) & 0xFFFFFFFFFFFFFFC0;
    return (v5 + v7 + v8 + 5080);
  }
  return v2;
}

uint64_t lzbitmap_encode(int *a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6)
{
  uint64_t result = lzbitmap_init_encode_state(a5, a6);
  if (result)
  {
    uint64_t result = 0;
    *(_DWORD *)(a5 + 56) = a4;
    *(void *)(a5 + 40) = a3;
    *(void *)(a5 + 48) = (char *)a1 + a2 - 31;
    if (a1)
    {
      if (a2 >= 0x23)
      {
        uint64_t v12 = (uint64_t)(a1 + 1);
        *a1 = (*(_DWORD *)(a5 + 80) << 24) | 0x4D425A;
        uint64_t v13 = *(char **)a5;
        unint64_t v14 = *(unsigned int *)(a5 + 92);
        *(void *)&long long v15 = 0x8000800080008;
        *((void *)&v15 + 1) = 0x8000800080008;
        long long v21 = v15;
        if (v14 >= 0x10)
        {
          int v17 = 31;
          if (v14 > 0x1F) {
            int v17 = v14;
          }
          size_t v16 = v17 & 0xFFFFFFF0;
          memset_pattern16(v13, asc_20DAD5CB0, v16);
        }
        else
        {
          size_t v16 = 0;
        }
        memcpy(&v13[v16], &v21, v14 - v16);
        if (a4)
        {
          unsigned int v18 = 0;
          unsigned int v19 = *(_DWORD *)(a5 + 96);
          while (1)
          {
            size_t v20 = a4 - v18 >= v19 ? v19 : a4 - v18;
            uint64_t result = (uint64_t)lzbitmap_process_block((uint64_t *)a5, v12, v18, v20);
            if (!result) {
              break;
            }
            uint64_t v12 = result;
            unsigned int v19 = *(_DWORD *)(a5 + 96);
            v18 += v19;
            if (v18 >= a4) {
              goto LABEL_16;
            }
          }
        }
        else
        {
LABEL_16:
          if ((unint64_t)(v12 + 6) <= *(void *)(a5 + 48))
          {
            *(_DWORD *)uint64_t v12 = 6;
            *(_WORD *)(v12 + 4) = 0;
            return (v12 + 6 - a1);
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

char *lzbitmap_process_block(uint64_t *a1, uint64_t a2, unsigned int a3, size_t __n)
{
  int v4 = 0;
  uint64_t v312 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v5 = a2;
    unint64_t v6 = a1;
    unint64_t v7 = a1[6];
    int v8 = (char *)(a2 + 6);
    if (a2 + 6 <= v7)
    {
      unsigned int v9 = a3;
      if (__n >= 0x91)
      {
        int v294 = (void *)(a2 + 15);
        if (a2 + 15 <= v7)
        {
          unint64_t v10 = *((unsigned int *)a1 + 26);
          if (v10)
          {
            unint64_t v11 = 0;
            uint64_t v12 = (int32x4_t *)a1[3];
            int32x4_t v13 = (int32x4_t)xmmword_20DAD6500;
            int32x4_t v14 = (int32x4_t)xmmword_20DAD6510;
            v15.i64[0] = 0x800000008;
            v15.i64[1] = 0x800000008;
            do
            {
              *uint64_t v12 = v14;
              v12[1] = v13;
              v12 += 2;
              v11 += 8;
              int32x4_t v14 = vaddq_s32(v14, v15);
              int32x4_t v13 = vaddq_s32(v13, v15);
            }
            while (v11 < v10);
          }
          int v16 = *((_DWORD *)a1 + 21);
          long long v278 = (char *)(a2 + 6);
          switch(v16)
          {
            case 2:
              uint64_t v33 = (void *)a1[5];
              unsigned __int16 v285 = (_DWORD *)a1[3];
              int v287 = (_WORD *)a1[2];
              int v275 = __n;
              if (__n + a3 >= *((_DWORD *)a1 + 14) - 16) {
                unsigned int v34 = *((_DWORD *)a1 + 14) - 16;
              }
              else {
                unsigned int v34 = __n + a3;
              }
              unsigned int v277 = v34;
              uint64_t v274 = a2;
              if (a3 + 128 > v34)
              {
                unsigned int v21 = 0;
                unsigned __int16 v35 = 0;
                LOWORD(v36) = 8;
                unsigned int v37 = a3;
LABEL_107:
                LODWORD(__n) = v275;
                unsigned int v204 = ((v275 + 63) & 0xFFFFFFC0) + v9;
                if ((unint64_t)v294 + v21 + v204 - v37 <= v6[6])
                {
                  if (v204 <= v37)
                  {
                    uint64_t v94 = v21;
                    uint64_t v5 = v274;
                  }
                  else
                  {
                    int v206 = -(unsigned __int16)v36;
                    uint64_t v5 = v274;
                    do
                    {
                      unsigned __int16 v207 = 0;
                      unsigned __int8 v208 = 0;
                      uint64_t v209 = (v37 - v9) >> 3;
                      v287[v209] = 0;
                      do
                      {
                        if (v37 < *((_DWORD *)v6 + 14))
                        {
                          int v210 = *((unsigned __int8 *)v33 + v37);
                          if (v210 != *((unsigned __int8 *)v33 + v206 + v37))
                          {
                            *((unsigned char *)v294 + v21) = v210;
                            unsigned __int16 v207 = v287[v209] | (1 << v208);
                            v287[v209] = v207;
                            ++v21;
                          }
                        }
                        unsigned int v211 = v208;
                        ++v37;
                        ++v208;
                      }
                      while (v211 < 7);
                      v285[v207] += 0x10000;
                    }
                    while (v37 < v204);
                    uint64_t v94 = v21;
                  }
                  int v212 = v35;
                  goto LABEL_126;
                }
                goto LABEL_108;
              }
              unsigned __int16 v35 = 0;
              unsigned int v21 = 0;
              uint64_t v280 = a1[1];
              uint64_t v276 = a2 + 143;
              uint64_t v36 = 8;
              int32x4_t v148 = vdupq_n_s32(0x9E3779B1);
              unsigned int v37 = a3;
              uint64_t v283 = (void *)a1[5];
              while (v276 + (unint64_t)v21 <= v6[6])
              {
                unint64_t v149 = 0;
                uint64_t v150 = v37;
                int32x4_t v151 = vdupq_n_s32(32 - *((_DWORD *)v6 + 22));
                do
                {
                  int64x2_t v152 = *(int64x2_t *)((char *)v33 + v150);
                  v316.val[1] = *(int8x16_t *)((char *)v33 + v150 + 16);
                  uint32x4_t v153 = (uint32x4_t)vnegq_s32(v151);
                  unint64_t v154 = (uint32x4_t *)&v311[2 * v149];
                  *unint64_t v154 = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v152, (int8x16_t)xmmword_20DAD5C70), v148), v153);
                  v154[1] = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v152, (int8x16_t)xmmword_20DAD5C80), v148), v153);
                  v316.val[0] = (int8x16_t)vdupq_laneq_s64(v152, 1);
                  v154[2] = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v316.val[0], (int8x16_t)xmmword_20DAD5C70), v148), v153);
                  v154[3] = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl2q_s8(v316, (int8x16_t)xmmword_20DAD6520), v148), v153);
                  v150 += 16;
                  BOOL v47 = v149 >= 0xE;
                  v149 += 2;
                }
                while (!v47);
                if (!v37)
                {
                  _WORD *v287 = 255;
                  v285[255] += 0x10000;
                  *int v294 = *v33;
                  unsigned int v37 = 8;
                  unsigned int v21 = 8;
                }
                for (uint64_t i = v37 == 8; i != 16; ++i)
                {
                  unsigned int v156 = v37;
                  unint64_t v157 = (int8x16_t *)((char *)v33 + v37);
                  int8x16_t v158 = *v157;
                  uint64x2_t v159 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8((int8x16_t)xmmword_20DAD6530, vceqq_s8(*(int8x16_t *)((char *)v157 - v36), *v157)))));
                  if (v159.i8[0])
                  {
                    uint64_t v160 = 0;
                    LOWORD(v161) = 0;
                    __int16 v162 = v159.i16[0] | (v159.i16[4] << 8);
                    v159.i32[0] = v159.u8[0];
                    int8x8_t v163 = vcnt_s8(*(int8x8_t *)v159.i8);
                    v163.i16[0] = vaddlv_u8((uint8x8_t)v163);
                    __int32 v164 = v163.i32[0];
                    v163.i32[0] = HIBYTE(v162);
                    uint8x8_t v165 = (uint8x8_t)vcnt_s8(v163);
                    v165.i16[0] = vaddlv_u8(v165);
                    __int32 v166 = v165.i32[0] + 4 * v164;
                    uint64_t v167 = *v6;
                    unint64_t v168 = (unsigned int *)&v311[2 * i];
                    uint64_t v169 = v168[1];
                    uint64_t v170 = 2 * *v168;
                    int v171 = *(_DWORD *)(*v6 + v170);
                    __int16 v295 = v37 - v171;
                    __int16 v303 = v37 - HIWORD(v171);
                    uint64_t v172 = v168[5];
                    uint64_t v173 = 2 * v168[4];
                    int v174 = *(_DWORD *)(v167 + v173);
                    __int16 v296 = v37 + 4 - v174;
                    __int16 v304 = v37 + 4 - HIWORD(v174);
                    uint64_t v175 = v168[3];
                    uint64_t v176 = 2 * v168[2];
                    int v177 = *(_DWORD *)(v167 + v176);
                    __int16 v297 = v37 + 2 - v177;
                    __int16 v305 = v37 + 2 - HIWORD(v177);
                    uint64_t v178 = 2 * v175;
                    LODWORD(v175) = *(_DWORD *)(v167 + 2 * v175);
                    __int16 v298 = v37 + 3 - v175;
                    __int16 v179 = v37 + 3 - WORD1(v175);
                    v169 *= 2;
                    LODWORD(v175) = *(_DWORD *)(v167 + v169);
                    __int16 v306 = v179;
                    __int16 v299 = v37 + 1 - v175;
                    __int16 v307 = v37 + 1 - WORD1(v175);
                    uint64_t v180 = 2 * v172;
                    LODWORD(v172) = *(_DWORD *)(v167 + 2 * v172);
                    __int16 v300 = v37 + 5 - v172;
                    __int16 v181 = v37 + 5 - WORD1(v172);
                    uint64_t v183 = v168[6];
                    uint64_t v182 = v168[7];
                    v183 *= 2;
                    unsigned int v184 = v21;
                    int v185 = *(_DWORD *)(v167 + v183);
                    __int16 v308 = v181;
                    __int16 v301 = v37 + 6 - v185;
                    unsigned int v186 = v166 + 4;
                    __int16 v187 = v37 + 6 - HIWORD(v185);
                    uint64_t v188 = 2 * v182;
                    LODWORD(v182) = *(_DWORD *)(v167 + 2 * v182);
                    *(_DWORD *)(v167 + v169) = (unsigned __int16)(v37 + 1) | ((unsigned __int16)v175 << 16);
                    __int16 v309 = v187;
                    *(_DWORD *)(v167 + v176) = (unsigned __int16)(v37 + 2) | ((unsigned __int16)*(_DWORD *)(v167 + v176) << 16);
                    *(_DWORD *)(v167 + v178) = (unsigned __int16)(v37 + 3) | ((unsigned __int16)*(_DWORD *)(v167 + v178) << 16);
                    *(_DWORD *)(v167 + v180) = (unsigned __int16)(v37 + 5) | ((unsigned __int16)*(_DWORD *)(v167 + v180) << 16);
                    __int16 v302 = v37 + 7 - v182;
                    *(_DWORD *)(v167 + v183) = (unsigned __int16)(v37 + 6) | ((unsigned __int16)*(_DWORD *)(v167 + v183) << 16);
                    *(_DWORD *)(v167 + v188) = (unsigned __int16)(v37 + 7) | ((unsigned __int16)*(_DWORD *)(v167 + v188) << 16);
                    __int16 v310 = v37 + 7 - WORD1(v182);
                    *(_DWORD *)(v167 + v173) = (unsigned __int16)(v37 + 4) | ((unsigned __int16)*(_DWORD *)(v167 + v173) << 16);
                    *(_DWORD *)(v167 + v170) = (unsigned __int16)v37 | ((unsigned __int16)*(_DWORD *)(v167 + v170) << 16);
                    do
                    {
                      uint64_t v189 = *(unsigned __int16 *)((char *)&v295 + v160);
                      int32x2_t v190 = vmovn_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8((int8x16_t)xmmword_20DAD6530, vceqq_s8(*(int8x16_t *)((char *)v157 - v189), v158))))));
                      int8x8_t v191 = vorr_s8((int8x8_t)vdup_lane_s32(vshl_n_s32(v190, 8uLL), 1), (int8x8_t)v190);
                      __int32 v192 = v191.i32[0] | (((int)v189 - 8) >> 24);
                      v191.i32[0] = v191.i8[0] | ((v189 - 8) >> 24);
                      int8x8_t v193 = vcnt_s8(v191);
                      v193.i16[0] = vaddlv_u8((uint8x8_t)v193);
                      unsigned __int32 v194 = v193.i32[0] + ((v189 + 130816) >> 16);
                      v193.i32[0] = BYTE1(v192);
                      uint8x8_t v195 = (uint8x8_t)vcnt_s8(v193);
                      v195.i16[0] = vaddlv_u8(v195);
                      if (v195.i32[0] + 4 * (v162 != 0) + 4 * v194 < v186)
                      {
                        unsigned int v161 = (v189 + 130816) >> 16;
                        unsigned int v186 = (v195.i8[0] + 4 * (v162 != 0) + 4 * v194);
                        uint64_t v36 = *(unsigned __int16 *)((char *)&v295 + v160);
                        __int16 v162 = v192;
                      }
                      v160 += 2;
                    }
                    while (v160 != 32);
                    *(_WORD *)(v280 + v35) = v36;
                    v35 += v161;
                    int8x8_t v196 = vqtbl1_s8((int8x16_t)v158.u64[0], lzbitmap_pack_perm_table[v162]);
                    *(int8x8_t *)((char *)v294 + v184) = v196;
                    v287[(v37 - v9) >> 3] = v162 | (unsigned __int16)((_WORD)v161 << 8);
                    uint64_t v33 = v283;
                    v285[(unsigned __int16)(v162 | (unsigned __int16)((_WORD)v161 << 8))] += 0x10000;
                    v196.i32[0] = v162;
                    uint8x8_t v197 = (uint8x8_t)vcnt_s8(v196);
                    v197.i16[0] = vaddlv_u8(v197);
                    unsigned int v21 = v184 + v197.i32[0];
                    unsigned int v9 = a3;
                    unint64_t v6 = a1;
                  }
                  else
                  {
                    uint64_t v198 = *v6;
                    float v199 = (unsigned int *)&v311[2 * i];
                    uint64_t v200 = *v199;
                    *(_DWORD *)(v198 + 2 * v199[1]) = (unsigned __int16)(v37 + 1) | ((unsigned __int16)*(_DWORD *)(*v6 + 2 * v199[1]) << 16);
                    uint64_t v201 = v199[3];
                    *(_DWORD *)(v198 + 2 * v199[2]) = (unsigned __int16)(v37 + 2) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v199[2]) << 16);
                    *(_DWORD *)(v198 + 2 * v201) = (unsigned __int16)(v37 + 3) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v201) << 16);
                    uint64_t v202 = v199[4];
                    *(_DWORD *)(v198 + 2 * v199[5]) = (unsigned __int16)(v37 + 5) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v199[5]) << 16);
                    uint64_t v203 = v199[7];
                    *(_DWORD *)(v198 + 2 * v199[6]) = (unsigned __int16)(v37 + 6) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v199[6]) << 16);
                    *(_DWORD *)(v198 + 2 * v203) = (unsigned __int16)(v37 + 7) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v203) << 16);
                    *(_DWORD *)(v198 + 2 * v202) = (unsigned __int16)(v37 + 4) | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v202) << 16);
                    *(_DWORD *)(v198 + 2 * v200) = (unsigned __int16)v37 | ((unsigned __int16)*(_DWORD *)(v198 + 2 * v200) << 16);
                    v287[(v37 - v9) >> 3] = 0;
                    *v285 += 0x10000;
                  }
                  v37 += 8;
                }
                if (v156 + 136 > v277) {
                  goto LABEL_107;
                }
              }
              goto LABEL_109;
            case 1:
              uint64_t v25 = (void *)a1[5];
              unint64_t v26 = (_WORD *)a1[2];
              unint64_t v27 = (_DWORD *)a1[3];
              int v275 = __n;
              if (__n + a3 >= *((_DWORD *)a1 + 14) - 16) {
                unsigned int v28 = *((_DWORD *)a1 + 14) - 16;
              }
              else {
                unsigned int v28 = __n + a3;
              }
              unsigned int v281 = v28;
              uint64_t v274 = a2;
              if (a3 + 128 > v28)
              {
                LODWORD(v29) = 0;
                LOWORD(v30) = 0;
                LOWORD(v31) = 8;
                unsigned int v32 = v9;
LABEL_48:
                LODWORD(__n) = v275;
                unsigned int v87 = ((v275 + 63) & 0xFFFFFFC0) + v9;
                if ((unint64_t)v294 + v29 + v87 - v32 <= v6[6])
                {
                  if (v87 <= v32)
                  {
                    uint64_t v94 = v29;
                    uint64_t v5 = v274;
                  }
                  else
                  {
                    int v88 = -(unsigned __int16)v31;
                    uint64_t v5 = v274;
                    do
                    {
                      unsigned __int16 v89 = 0;
                      unsigned __int8 v90 = 0;
                      uint64_t v91 = (v32 - v9) >> 3;
                      v26[v91] = 0;
                      do
                      {
                        if (v32 < *((_DWORD *)v6 + 14))
                        {
                          int v92 = *((unsigned __int8 *)v25 + v32);
                          if (v92 != *((unsigned __int8 *)v25 + v88 + v32))
                          {
                            *((unsigned char *)v294 + v29) = v92;
                            unsigned __int16 v89 = v26[v91] | (1 << v90);
                            v26[v91] = v89;
                            LODWORD(v29) = v29 + 1;
                          }
                        }
                        unsigned int v93 = v90;
                        ++v32;
                        ++v90;
                      }
                      while (v93 < 7);
                      v27[v89] += 0x10000;
                    }
                    while (v32 < v87);
                    uint64_t v94 = v29;
                  }
                  int v212 = (unsigned __int16)v30;
                  *((_DWORD *)v6 + 30) = v29;
                  goto LABEL_127;
                }
LABEL_108:
                unint64_t v205 = 0;
LABEL_110:
                uint64_t v5 = v274;
                goto LABEL_128;
              }
              int v30 = 0;
              uint64_t v29 = 0;
              uint64_t v286 = a1[1];
              uint64_t v279 = a2 + 143;
              uint64_t v31 = 8;
              int32x4_t v38 = vdupq_n_s32(0x9E3779B1);
              unsigned int v32 = v9;
              uint64_t v288 = (void *)a1[5];
              while (v279 + (unint64_t)v29 <= v6[6])
              {
                unint64_t v39 = 0;
                uint64_t v40 = v32;
                int32x4_t v41 = vdupq_n_s32(32 - *((_DWORD *)v6 + 22));
                do
                {
                  int64x2_t v42 = *(int64x2_t *)((char *)v25 + v40);
                  v314.val[1] = *(int8x16_t *)((char *)v25 + v40 + 16);
                  uint32x4_t v43 = (uint32x4_t)vnegq_s32(v41);
                  unint64_t v44 = &v311[2 * v39];
                  *unint64_t v44 = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v42, (int8x16_t)xmmword_20DAD5C70), v38), v43);
                  v44[1] = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v42, (int8x16_t)xmmword_20DAD5C80), v38), v43);
                  v314.val[0] = (int8x16_t)vdupq_laneq_s64(v42, 1);
                  int32x4_t v45 = (int32x4_t)vqtbl2q_s8(v314, (int8x16_t)xmmword_20DAD6520);
                  uint32x4_t v46 = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v314.val[0], (int8x16_t)xmmword_20DAD5C70), v38), v43);
                  v44[2] = v46;
                  v44[3] = vshlq_u32((uint32x4_t)vmulq_s32(v45, v38), v43);
                  v40 += 16;
                  BOOL v47 = v39 >= 0xE;
                  v39 += 2;
                }
                while (!v47);
                if (!v32)
                {
                  _WORD *v26 = 255;
                  v27[255] += 0x10000;
                  *int v294 = *v25;
                  unsigned int v32 = 8;
                  uint64_t v29 = 8;
                }
                for (uint64_t j = v32 == 8; j != 16; ++j)
                {
                  unsigned int v49 = v32;
                  unint64_t v50 = (int8x16_t *)((char *)v25 + v32);
                  int8x16_t v51 = *v50;
                  uint64x2_t v52 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8((int8x16_t)xmmword_20DAD6530, vceqq_s8(*(int8x16_t *)((char *)v50 - v31), *v50)))));
                  unsigned int v53 = (v32 - v9) >> 3;
                  if (v52.i8[0])
                  {
                    v46.i32[0] = v52.u8[0];
                    *(int8x8_t *)v46.i8 = vcnt_s8(*(int8x8_t *)v46.i8);
                    v46.i16[0] = vaddlv_u8(*(uint8x8_t *)v46.i8);
                    uint64_t v54 = v52.u8[0];
                    if (v46.i32[0] == 1)
                    {
                      LOWORD(v55) = 0;
LABEL_44:
                      int8x8_t v85 = vqtbl1_s8((int8x16_t)v51.u64[0], lzbitmap_pack_perm_table[v54]);
                      *(int8x8_t *)((char *)v294 + v29) = v85;
                      v85.i32[0] = v54;
                      v26[v53] = v54 | (unsigned __int16)((_WORD)v55 << 8);
                      v27[v54 | ((unsigned __int16)v55 << 8)] += 0x10000;
                      uint8x8_t v86 = (uint8x8_t)vcnt_s8(v85);
                      v86.i16[0] = vaddlv_u8(v86);
                      uint64_t v29 = (v86.i32[0] + v29);
                    }
                    else
                    {
                      unsigned int v290 = (v32 - v9) >> 3;
                      uint64_t v56 = 0;
                      unsigned int v55 = 0;
                      v52.i32[0] = ((unsigned __int16)(v52.i16[0] | (v52.i16[4] << 8)) >> 8);
                      uint64_t v57 = *v6;
                      uint64_t v58 = (unsigned int *)&v311[2 * j];
                      uint64_t v59 = *v58;
                      uint64_t v60 = v58[1];
                      __int16 v295 = v32 - *(_WORD *)(*v6 + 2 * v59);
                      uint64_t v61 = v58[4];
                      uint64_t v62 = v58[5];
                      uint64_t v64 = v58[2];
                      uint64_t v63 = v58[3];
                      __int16 v65 = *(_WORD *)(v57 + 2 * v64);
                      __int16 v296 = v32 + 4 - *(_WORD *)(v57 + 2 * v61);
                      __int16 v297 = v32 + 2 - v65;
                      __int16 v298 = v32 + 3 - *(_WORD *)(v57 + 2 * v63);
                      __int16 v66 = *(_WORD *)(v57 + 2 * v60);
                      uint64_t v67 = v29;
                      __int16 v68 = *(_WORD *)(v57 + 2 * v62);
                      unint64_t v69 = v27;
                      uint64_t v70 = v58[6];
                      uint64_t v71 = v58[7];
                      __int16 v72 = *(_WORD *)(v57 + 2 * v70);
                      int v73 = v30;
                      __int16 v74 = *(_WORD *)(v57 + 2 * v71);
                      *(_WORD *)(v57 + 2 * v60) = v49 + 1;
                      __int16 v75 = v49 + 1 - v66;
                      unsigned int v76 = (vaddlv_u8((uint8x8_t)vcnt_s8(*(int8x8_t *)v52.i8)) + 4 * v46.i8[0]);
                      __int16 v299 = v75;
                      __int16 v300 = v49 + 5 - v68;
                      __int16 v301 = v49 + 6 - v72;
                      *(_WORD *)(v57 + 2 * v64) = v49 + 2;
                      *(_WORD *)(v57 + 2 * v63) = v49 + 3;
                      *(_WORD *)(v57 + 2 * v62) = v49 + 5;
                      *(_WORD *)(v57 + 2 * v70) = v49 + 6;
                      uint64_t v29 = v67;
                      unint64_t v27 = v69;
                      *(_WORD *)(v57 + 2 * v71) = v49 + 7;
                      __int16 v302 = v49 + 7 - v74;
                      *(_WORD *)(v57 + 2 * v61) = v49 + 4;
                      *(_WORD *)(v57 + 2 * v59) = v49;
                      while (1)
                      {
                        uint64_t v77 = *(unsigned __int16 *)((char *)&v295 + v56);
                        uint64x2_t v78 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8((int8x16_t)xmmword_20DAD6530, vceqq_s8(*(int8x16_t *)((char *)v50 - v77), v51)))));
                        int v79 = (unsigned __int16)(v78.i16[0] | (v78.i16[4] << 8));
                        int v80 = v79 | (((int)v77 - 8) >> 24);
                        unsigned int v81 = (v77 + 130816) >> 16;
                        unsigned int v82 = (unsigned __int16)(v79 | (((int)v77 - 8) >> 24));
                        if (!((unsigned __int16)v79 | (unsigned __int16)(((int)v77 - 8) >> 24))) {
                          break;
                        }
                        v78.i32[0] = v78.i8[0] | ((v77 - 8) >> 24);
                        int8x8_t v83 = vcnt_s8(*(int8x8_t *)v78.i8);
                        v83.i16[0] = vaddlv_u8((uint8x8_t)v83);
                        unsigned __int32 v84 = v83.i32[0] + v81;
                        v83.i32[0] = v82 >> 8;
                        *(int8x8_t *)v78.i8 = vcnt_s8(v83);
                        v78.i16[0] = vaddlv_u8(*(uint8x8_t *)v78.i8);
                        if (v78.i32[0] + 4 * v84 < v76)
                        {
                          unsigned int v76 = (v78.i8[0] + 4 * v84);
                          uint64_t v54 = v80;
                          uint64_t v31 = *(unsigned __int16 *)((char *)&v295 + v56);
                          unsigned int v55 = (v77 + 130816) >> 16;
                        }
                        v56 += 2;
                        if (v56 == 16)
                        {
                          *(_WORD *)(v286 + (unsigned __int16)v73) = v31;
                          int v30 = v73 + v55;
                          unsigned int v9 = a3;
                          unint64_t v6 = a1;
                          uint64_t v25 = v288;
                          unsigned int v53 = v290;
                          goto LABEL_44;
                        }
                      }
                      v26[v290] = (_WORD)v81 << 8;
                      v69[256 * v81] += 0x10000;
                      *(_WORD *)(v286 + (unsigned __int16)v73) = v77;
                      int v30 = v73 + ((v77 + 130816) >> 16);
                      uint64_t v31 = v77;
                      unsigned int v9 = a3;
                      unint64_t v6 = a1;
                      uint64_t v25 = v288;
                    }
                  }
                  else
                  {
                    v26[v53] = 0;
                    *v27 += 0x10000;
                  }
                  unsigned int v32 = v49 + 8;
                }
                if (v49 + 136 > v281) {
                  goto LABEL_48;
                }
              }
LABEL_109:
              unint64_t v205 = 0;
              LODWORD(__n) = v275;
              goto LABEL_110;
            case 0:
              int v17 = (void *)a1[5];
              unsigned int v19 = (_WORD *)a1[2];
              unsigned int v18 = (_DWORD *)a1[3];
              int v275 = __n;
              if (__n + a3 >= *((_DWORD *)a1 + 14) - 16) {
                unsigned int v20 = *((_DWORD *)a1 + 14) - 16;
              }
              else {
                unsigned int v20 = __n + a3;
              }
              unsigned int v284 = v20;
              uint64_t v274 = a2;
              if (a3 + 128 > v20)
              {
                unsigned int v21 = 0;
                LOWORD(v22) = 0;
                LOWORD(v23) = 8;
                unsigned int v24 = v9;
LABEL_80:
                LODWORD(__n) = v275;
                unsigned int v141 = ((v275 + 63) & 0xFFFFFFC0) + v9;
                if ((unint64_t)v294 + v21 + v141 - v24 <= v6[6])
                {
                  if (v141 <= v24)
                  {
                    uint64_t v94 = v21;
                    uint64_t v5 = v274;
                  }
                  else
                  {
                    int v142 = -(unsigned __int16)v23;
                    uint64_t v5 = v274;
                    do
                    {
                      unsigned __int16 v143 = 0;
                      unsigned __int8 v144 = 0;
                      uint64_t v145 = (v24 - v9) >> 3;
                      v19[v145] = 0;
                      do
                      {
                        if (v24 < *((_DWORD *)v6 + 14))
                        {
                          int v146 = *((unsigned __int8 *)v17 + v24);
                          if (v146 != *((unsigned __int8 *)v17 + v142 + v24))
                          {
                            *((unsigned char *)v294 + v21++) = v146;
                            unsigned __int16 v143 = v19[v145] | (1 << v144);
                            v19[v145] = v143;
                          }
                        }
                        unsigned int v147 = v144;
                        ++v24;
                        ++v144;
                      }
                      while (v147 < 7);
                      v18[v143] += 0x10000;
                    }
                    while (v24 < v141);
                    uint64_t v94 = v21;
                  }
                  int v212 = (unsigned __int16)v22;
LABEL_126:
                  *((_DWORD *)v6 + 30) = v21;
LABEL_127:
                  *((_DWORD *)v6 + 31) = v212;
                  unint64_t v205 = (char *)v294 + v94;
LABEL_128:
                  int v8 = v278;
                  if (v205)
                  {
                    size_t v213 = *((unsigned int *)v6 + 31);
                    unint64_t v214 = &v205[v213];
                    if ((unint64_t)&v205[v213] <= v6[6])
                    {
                      uint64_t v215 = v5;
                      int v216 = __n;
                      memcpy(v205, (const void *)v6[1], v213);
                      LODWORD(__n) = v216;
                      unsigned int v217 = 0;
                      unsigned int v218 = 0;
                      do
                      {
                        unint64_t v219 = 0;
                        uint64_t v220 = v6[4];
                        int32x4_t v221 = vdupq_n_s32(65537 * v218 + 16777472);
                        do
                        {
                          *(int32x4_t *)(v220 + 2 * v217 + v219) = v221;
                          v219 += 16;
                        }
                        while (v219 < 0x1F1);
                        ++v218;
                        v217 += 256;
                      }
                      while (v218 <= *((_DWORD *)v6 + 25));
                      unsigned int v222 = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                      uint64_t v223 = v6[3];
                      uint64_t v225 = *((unsigned int *)v6 + 26);
                      unsigned int v224 = *((_DWORD *)v6 + 27);
                      unsigned int v226 = 0;
                      if (!v225) {
                        goto LABEL_158;
                      }
                      uint64_t v227 = v6[3];
                      do
                      {
                        *(_DWORD *)(v223 + 4 * v226) = *(_DWORD *)v227;
                        if (*(_WORD *)(v227 + 2)) {
                          ++v226;
                        }
                        v227 += 4;
                        --v225;
                      }
                      while (v225);
                      if (v226 > v224)
                      {
                        unsigned int v228 = 0;
                        uint64_t v5 = v215;
                        do
                        {
                          uint64_t v229 = v228;
                          unsigned int v230 = *(_DWORD *)(v223 + 4 * v228);
                          uint64_t v231 = v226 - 1;
                          unsigned int v232 = *(_DWORD *)(v223 + 4 * v231);
                          if (v230 > v232)
                          {
                            *(_DWORD *)(v223 + 4 * v228) = v232;
                            *(_DWORD *)(v223 + 4 * v231) = v230;
                            unsigned int v232 = v230;
                          }
                          uint64_t v233 = (v228 + v226) >> 1;
                          unsigned int v234 = *(_DWORD *)(v223 + 4 * v233);
                          if (v234 > v232)
                          {
                            *(_DWORD *)(v223 + 4 * v233) = v232;
                            *(_DWORD *)(v223 + 4 * v231) = v234;
                            unsigned int v234 = *(_DWORD *)(v223 + 4 * v233);
                          }
                          unsigned int v235 = *(_DWORD *)(v223 + 4 * v228);
                          if (v234 > v235)
                          {
                            *(_DWORD *)(v223 + 4 * v229) = v234;
                            *(_DWORD *)(v223 + 4 * v233) = v235;
                            unsigned int v235 = *(_DWORD *)(v223 + 4 * v229);
                          }
                          LODWORD(v236) = v229 - 1;
                          unsigned int v237 = v226;
                          while (1)
                          {
                            do
                            {
                              uint64_t v236 = (v236 + 1);
                              unsigned int v238 = *(_DWORD *)(v223 + 4 * v236);
                            }
                            while (v238 > v235);
                            unsigned int v239 = v237 + 1;
                            do
                            {
                              uint64_t v240 = v239 - 2;
                              unsigned int v241 = *(_DWORD *)(v223 + 4 * v240);
                              --v239;
                            }
                            while (v241 < v235);
                            unsigned int v237 = v239 - 1;
                            if (v236 >= v239 - 1) {
                              break;
                            }
                            *(_DWORD *)(v223 + 4 * v240) = v238;
                            *(_DWORD *)(v223 + 4 * v236) = v241;
                          }
                          if (v239 < v224)
                          {
                            unsigned int v228 = v239;
                          }
                          else
                          {
                            unsigned int v226 = v239;
                            unsigned int v228 = v229;
                          }
                        }
                        while (v224 != v239);
                      }
                      else
                      {
LABEL_158:
                        bzero((void *)(v223 + 4 * v226), 4 * (v224 - v226));
                        LODWORD(__n) = v216;
                        uint64_t v5 = v215;
                      }
                      *(uint64_t *)((char *)v6 + 60) = 0;
                      unint64_t v242 = (long long *)((char *)v6 + 60);
                      *(uint64_t *)((char *)v6 + 68) = 0;
                      *((_DWORD *)v6 + 19) = 0;
                      LODWORD(v243) = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                      int v8 = v278;
                      if (*((_DWORD *)v6 + 27))
                      {
                        unsigned int v244 = 0;
                        unint64_t v245 = 0;
                        uint64_t v246 = v6[3];
                        LODWORD(v243) = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                        do
                        {
                          if (*(_DWORD *)(v246 + 4 * v245) < 0x10000u) {
                            break;
                          }
                          uint64_t v247 = (unsigned __int16)*(_DWORD *)(v246 + 4 * v245);
                          *(_DWORD *)((char *)v242 + ((v244 >> 3) & 0x1FFFFFFE)) |= v247 << (v244 & 0xE);
                          *(_WORD *)(v6[4] + 2 * v247) = v245 + *((_DWORD *)v6 + 25) + 1;
                          int v8 = v278;
                          LODWORD(v243) = v243 - *(unsigned __int16 *)(v246 + 4 * v245++ + 2);
                          v244 += 10;
                        }
                        while (v245 < *((unsigned int *)v6 + 27));
                      }
                      *((_DWORD *)v6 + 32) = v243;
                      unint64_t v248 = v6[6];
                      if ((unint64_t)&v214[v243] <= v248)
                      {
                        if (v222)
                        {
                          int v249 = 0;
                          uint64_t v250 = v6[4];
                          uint64_t v251 = ((v216 + 63) >> 3) & 0x1FFFFFF8;
                          long long v253 = (unsigned char *)v6[1];
                          long long v252 = (char *)v6[2];
                          do
                          {
                            unsigned int v254 = *(unsigned __int16 *)(v250 + 2 * *(unsigned __int16 *)v252);
                            *v253++ = v254;
                            char v255 = *v252;
                            v252 += 2;
                            v214[v249] = v255;
                            v249 += v254 >> 8;
                            --v251;
                          }
                          while (v251);
                          uint64_t v243 = *((unsigned int *)v6 + 32);
                          unint64_t v248 = v6[6];
                          int v8 = v278;
                        }
                        else
                        {
                          uint64_t v243 = v243;
                        }
                        long long v256 = (int8x16_t *)&v214[v243];
                        if ((unint64_t)&v214[v243 + (v222 >> 1)] <= v248)
                        {
                          if ((v6[10] & 4) != 0)
                          {
                            uint64_t v257 = v6[1];
                          }
                          else
                          {
                            uint64_t v257 = v6[2];
                            unsigned int v222 = lzbitmap_encode_rle(v257, v6[1], v222);
                          }
                          if (v222 >= 0x20)
                          {
                            uint64_t v258 = 0;
                            long long v259 = v256;
                            do
                            {
                              long long v260 = (const char *)(v257 + v258);
                              int8x16x2_t v313 = vld2q_s8(v260);
                              unint64_t v261 = v258 + 64;
                              v258 += 32;
                              *v259++ = vorrq_s8(vshlq_n_s8(v313.val[1], 4uLL), v313.val[0]);
                            }
                            while (v261 <= v222);
                          }
                          else
                          {
                            LODWORD(v258) = 0;
                          }
                          bzero(&v256->i8[v258 >> 1], (v222 + 1 - v258) >> 1);
                          if (v258 < v222)
                          {
                            unint64_t v262 = v222 - (unint64_t)v258;
                            unsigned int v263 = 4 * v258;
                            long long v264 = (unsigned __int8 *)(v257 + v258);
                            do
                            {
                              int v265 = *v264++;
                              *(__int32 *)((char *)v256->i32 + ((v263 >> 3) & 0x1FFFFFFE)) |= v265 << (v263 & 0xC);
                              v263 += 4;
                              --v262;
                            }
                            while (v262);
                          }
                          long long v266 = &v256->i8[(v222 + 1) >> 1];
                          int v4 = v266 + 17;
                          LODWORD(__n) = v216;
                          uint64_t v5 = v215;
                          int v8 = v278;
                          if ((unint64_t)(v266 + 17) <= v6[6])
                          {
                            long long v267 = *v242;
                            v266[16] = *((unsigned char *)v6 + 76);
                            *(_OWORD *)long long v266 = v267;
                            uint64_t v268 = (*((_DWORD *)v6 + 30) + 15);
                            uint64_t v269 = (*((_DWORD *)v6 + 31) + v268);
                            uint64_t v270 = (*((_DWORD *)v6 + 32) + v269);
                            *(void *)(v215 + 6) = v268 + (v269 << 24) + (v270 << 48);
                            *(unsigned char *)(v215 + 14) = BYTE2(v270);
                            if ((uint64_t)&v4[-v215] < (v216 + 6)) {
                              goto LABEL_185;
                            }
                          }
                        }
                      }
                    }
                  }
                  break;
                }
                goto LABEL_108;
              }
              int v22 = 0;
              unsigned int v21 = 0;
              uint64_t v289 = a1[1];
              uint64_t v282 = a2 + 143;
              uint64_t v23 = 8;
              int32x4_t v95 = vdupq_n_s32(0x9E3779B1);
              unsigned int v24 = v9;
              unsigned int v291 = (void *)a1[5];
              while (v282 + (unint64_t)v21 <= v6[6])
              {
                unint64_t v96 = 0;
                uint64_t v97 = v24;
                int32x4_t v98 = vdupq_n_s32(32 - *((_DWORD *)v6 + 22));
                do
                {
                  int64x2_t v99 = *(int64x2_t *)((char *)v17 + v97);
                  v315.val[1] = *(int8x16_t *)((char *)v17 + v97 + 16);
                  uint32x4_t v100 = (uint32x4_t)vnegq_s32(v98);
                  unint64_t v101 = &v311[2 * v96];
                  _OWORD *v101 = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v99, (int8x16_t)xmmword_20DAD5C70), v95), v100);
                  v101[1] = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v99, (int8x16_t)xmmword_20DAD5C80), v95), v100);
                  v315.val[0] = (int8x16_t)vdupq_laneq_s64(v99, 1);
                  int32x4_t v102 = (int32x4_t)vqtbl2q_s8(v315, (int8x16_t)xmmword_20DAD6520);
                  uint32x4_t v103 = vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)vqtbl1q_s8(v315.val[0], (int8x16_t)xmmword_20DAD5C70), v95), v100);
                  v101[2] = v103;
                  v101[3] = vshlq_u32((uint32x4_t)vmulq_s32(v102, v95), v100);
                  v97 += 16;
                  BOOL v47 = v96 >= 0xE;
                  v96 += 2;
                }
                while (!v47);
                if (!v24)
                {
                  _WORD *v19 = 255;
                  v18[255] += 0x10000;
                  *int v294 = *v17;
                  unsigned int v24 = 8;
                  unsigned int v21 = 8;
                }
                for (uint64_t k = v24 == 8; k != 16; ++k)
                {
                  unsigned int v105 = v24;
                  unint64_t v106 = (int8x16_t *)((char *)v17 + v24);
                  int8x16_t v107 = *v106;
                  uint64x2_t v108 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8((int8x16_t)xmmword_20DAD6530, vceqq_s8(*(int8x16_t *)((char *)v106 - v23), *v106)))));
                  unsigned int v109 = (v24 - v9) >> 3;
                  if (v108.i8[0])
                  {
                    v103.i32[0] = v108.u8[0];
                    *(int8x8_t *)v103.i8 = vcnt_s8(*(int8x8_t *)v103.i8);
                    v103.i16[0] = vaddlv_u8(*(uint8x8_t *)v103.i8);
                    uint64_t v110 = v108.u8[0];
                    if (v103.i32[0] == 1)
                    {
                      LOWORD(v111) = 0;
LABEL_76:
                      int8x8_t v139 = vqtbl1_s8((int8x16_t)v107.u64[0], lzbitmap_pack_perm_table[v110]);
                      *(int8x8_t *)((char *)v294 + v21) = v139;
                      v139.i32[0] = v110;
                      v19[v109] = v110 | (unsigned __int16)((_WORD)v111 << 8);
                      v18[v110 | ((unsigned __int16)v111 << 8)] += 0x10000;
                      uint8x8_t v140 = (uint8x8_t)vcnt_s8(v139);
                      v140.i16[0] = vaddlv_u8(v140);
                      v21 += v140.i32[0];
                    }
                    else
                    {
                      uint64_t v112 = 0;
                      unsigned int v111 = 0;
                      uint64_t v113 = *v6;
                      uint64_t v114 = (unsigned int *)&v311[2 * k];
                      uint64_t v115 = *v114;
                      unint64_t v116 = v18;
                      unint64_t v117 = v19;
                      int v118 = v22;
                      __int16 v119 = *(_WORD *)(*v6 + 2 * v115);
                      uint64_t v121 = v114[4];
                      uint64_t v120 = v114[5];
                      __int16 v122 = *(_WORD *)(*v6 + 2 * v121);
                      uint64_t v123 = v114[2];
                      uint64_t v124 = v114[3];
                      __int16 v125 = *(_WORD *)(*v6 + 2 * v123);
                      __int16 v126 = *(_WORD *)(*v6 + 2 * v124);
                      *(_WORD *)(v113 + 2 * v114[1]) = v105 + 1;
                      v108.i32[0] = ((unsigned __int16)(v108.i16[0] | (v108.i16[4] << 8)) >> 8);
                      __int16 v295 = v105 - v119;
                      *(_WORD *)(v113 + 2 * v123) = v105 + 2;
                      __int16 v296 = v105 + 4 - v122;
                      int v127 = v118;
                      unsigned int v19 = v117;
                      unsigned int v18 = v116;
                      *(_WORD *)(v113 + 2 * v124) = v105 + 3;
                      unsigned int v128 = (vaddlv_u8((uint8x8_t)vcnt_s8(*(int8x8_t *)v108.i8)) + 4 * v103.i8[0]);
                      __int16 v297 = v105 + 2 - v125;
                      *(_WORD *)(v113 + 2 * v120) = v105 + 5;
                      uint64_t v129 = v114[6];
                      uint64_t v130 = v114[7];
                      *(_WORD *)(v113 + 2 * v129) = v105 + 6;
                      *(_WORD *)(v113 + 2 * v130) = v105 + 7;
                      __int16 v298 = v105 + 3 - v126;
                      *(_WORD *)(v113 + 2 * v121) = v105 + 4;
                      *(_WORD *)(v113 + 2 * v115) = v105;
                      while (1)
                      {
                        uint64_t v131 = *(unsigned __int16 *)((char *)&v295 + v112);
                        uint64x2_t v132 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8((int8x16_t)xmmword_20DAD6530, vceqq_s8(*(int8x16_t *)((char *)v106 - v131), v107)))));
                        int v133 = (unsigned __int16)(v132.i16[0] | (v132.i16[4] << 8));
                        int v134 = v133 | (((int)v131 - 8) >> 24);
                        unsigned int v135 = (v131 + 130816) >> 16;
                        unsigned int v136 = (unsigned __int16)(v133 | (((int)v131 - 8) >> 24));
                        if (!((unsigned __int16)v133 | (unsigned __int16)(((int)v131 - 8) >> 24))) {
                          break;
                        }
                        v132.i32[0] = v132.i8[0] | ((v131 - 8) >> 24);
                        int8x8_t v137 = vcnt_s8(*(int8x8_t *)v132.i8);
                        v137.i16[0] = vaddlv_u8((uint8x8_t)v137);
                        unsigned __int32 v138 = v137.i32[0] + v135;
                        v137.i32[0] = v136 >> 8;
                        *(int8x8_t *)v132.i8 = vcnt_s8(v137);
                        v132.i16[0] = vaddlv_u8(*(uint8x8_t *)v132.i8);
                        if (v132.i32[0] + 4 * v138 < v128)
                        {
                          unsigned int v128 = (v132.i8[0] + 4 * v138);
                          uint64_t v110 = v134;
                          uint64_t v23 = *(unsigned __int16 *)((char *)&v295 + v112);
                          unsigned int v111 = (v131 + 130816) >> 16;
                        }
                        v112 += 2;
                        if (v112 == 8)
                        {
                          *(_WORD *)(v289 + (unsigned __int16)v127) = v23;
                          int v22 = v127 + v111;
                          unsigned int v9 = a3;
                          int v17 = v291;
                          unint64_t v6 = a1;
                          goto LABEL_76;
                        }
                      }
                      v19[v109] = (_WORD)v135 << 8;
                      v116[256 * v135] += 0x10000;
                      *(_WORD *)(v289 + (unsigned __int16)v127) = v131;
                      int v22 = v127 + ((v131 + 130816) >> 16);
                      uint64_t v23 = v131;
                      unsigned int v9 = a3;
                      int v17 = v291;
                      unint64_t v6 = a1;
                    }
                  }
                  else
                  {
                    v19[v109] = 0;
                    *v18 += 0x10000;
                  }
                  unsigned int v24 = v105 + 8;
                }
                if (v105 + 136 > v284) {
                  goto LABEL_80;
                }
              }
              goto LABEL_109;
          }
        }
      }
      int v4 = &v8[__n];
      if ((unint64_t)v4 <= v6[6])
      {
        int v271 = __n;
        uint64_t v272 = v5;
        memcpy(v8, (const void *)(v6[5] + v9), __n);
        uint64_t v5 = v272;
        LODWORD(__n) = v271;
      }
      else
      {
        int v4 = 0;
      }
LABEL_185:
      *(_DWORD *)uint64_t v5 = (v4 - v5) | (__n << 24);
      *(_WORD *)(v5 + 4) = __n >> 8;
    }
  }
  return v4;
}

uint64_t lzvn_stream_init(uint64_t a1, int a2, int a3, int a4)
{
  if (a2 == 1) {
    return lzvnStreamDecodeInit(a1, a3, a4);
  }
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  return lzvnStreamEncodeInit(a1, a3, a4);
}

uint64_t lzvn_stream_process(uint64_t a1, char a2)
{
  int v2 = **(_DWORD **)(a1 + 32);
  if (v2 == 1) {
    return lzvnStreamDecode(a1, a2);
  }
  if (v2) {
    return 0xFFFFFFFFLL;
  }
  return lzvnStreamEncode(a1, a2);
}

BOOL lzvn_stream_identify_algorithm(unsigned char *a1)
{
  return *a1 == 14 && a1[1] == 22 && a1[2] == 22 && a1[3] == 14;
}

uint64_t lzvn_stream_get_state_size(uint64_t a1)
{
  size_t v1 = *(_DWORD **)(a1 + 32);
  if (*v1 == 1) {
    return lzvnStreamDecodeStateSize();
  }
  if (*v1) {
    return 0;
  }
  return lzvnStreamEncodeStateSize(v1[1]);
}

uint64_t lzma_decode_buffer()
{
  if (lzma_stream_buffer_decode()) {
    return 0;
  }
  else {
    return 0;
  }
}

uint64_t lzma_encode_buffer()
{
  if (lzma_easy_buffer_encode()) {
    return 0;
  }
  else {
    return 0;
  }
}

uint64_t lzbitmap_encode_rle(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  unsigned int v4 = a3;
  do
  {
    if (v3) {
      char v5 = 0;
    }
    else {
      char v5 = 15;
    }
    *(unsigned char *)(a2 + a3 + v3++) = v5;
  }
  while (v3 != 16);
  if (a3)
  {
    unsigned int v4 = 0;
    unsigned int v6 = 0;
    do
    {
      unint64_t v7 = (_OWORD *)(a2 + v4);
      int8x16_t v8 = *(int8x16_t *)v7;
      int8x16_t v9 = *(int8x16_t *)((char *)v7 + 1);
      *(_OWORD *)(a1 + v6) = *v7;
      uint64x2_t v10 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v8, v9), (int8x16_t)xmmword_20DAD6530))));
      LODWORD(v7) = __clz(__rbit32(((v10.i32[0] | (v10.i32[2] << 8)) >> 1) & (((v10.i32[0] | (v10.i32[2] << 8)) & 0xFFFCu) >> 2) & (v10.i32[0] | (v10.i32[2] << 8)) | 0x2000))
                  + 1;
      v4 += v7;
      v6 += v7;
      if ((((v10.i32[0] | (v10.i32[2] << 8)) >> 1) & (((v10.i32[0] | (v10.i32[2] << 8)) & 0xFFFCu) >> 2) & (v10.i32[0] | (v10.i32[2] << 8))) != 0)
      {
        unsigned int v11 = v6 + 1;
        *(unsigned char *)(a1 + v6) = 15;
        v4 += 3;
        do
        {
          uint64x2_t v12 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vbicq_s8((int8x16_t)xmmword_20DAD6530, vceqq_s8(*(int8x16_t *)(a2 + v4 - 1), *(int8x16_t *)(a2 + v4))))));
          unsigned int v13 = __clz(__rbit32(v12.i16[0] | (unsigned __int16)(v12.i16[4] << 8) | 0xFFFF8000));
          unsigned int v6 = v11 + 1;
          *(unsigned char *)(a1 + v11) = v13;
          v4 += v13;
          ++v11;
        }
        while (v13 == 15);
      }
    }
    while (v4 < a3);
  }
  else
  {
    unsigned int v6 = 0;
  }
  return v6 + a3 - v4;
}

uint64_t lzbitmap_decode_rle(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (*a2 == 15 || a3 == 0) {
    return 0;
  }
  int v4 = 0;
  unsigned int v5 = 0;
  v6.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v6.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    int8x16_t v7 = *(int8x16_t *)&a2[v4];
    *(int8x16_t *)(a1 + v5) = v7;
    uint64x2_t v8 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v7, v6), (int8x16_t)xmmword_20DAD6530))));
    unsigned int v9 = __clz(__rbit32((unsigned __int16)(v8.i16[0] | (v8.i16[4] << 8)) | 0x10000));
    v5 += v9;
    v4 += v9;
    if (v8.i16[0] | (unsigned __int16)(v8.i16[4] << 8))
    {
      int v10 = v4 + 1;
      unsigned int v11 = &a2[v4 - 1];
      int8x16_t v12 = vld1q_dup_s8(v11);
      *(int8x16_t *)(a1 + v5) = v12;
      v5 += 3;
      do
      {
        int v4 = v10 + 1;
        unsigned int v13 = a2[v10];
        *(int8x16_t *)(a1 + v5) = v12;
        v5 += v13;
        BOOL v14 = v13 < 0xF || v5 >= a3;
        int v10 = v4;
      }
      while (!v14);
    }
  }
  while (v5 < a3);
  return a3;
}

_DWORD *BrotliInitEncoderDictionary(uint64_t a1)
{
  *(void *)a1 = BrotliGetDictionary();
  uint64_t result = BrotliGetTransforms();
  int v3 = result[6];
  *(void *)(a1 + 32) = &kStaticDictionaryHashLengths;
  *(void *)(a1 + 40) = &kStaticDictionaryBuckets;
  *(void *)(a1 + 48) = &kStaticDictionaryWords;
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 10;
  *(void *)(a1 + 16) = 0x71B520ADA2D3200;
  *(void *)(a1 + 24) = &kStaticDictionaryHashWords;
  return result;
}

uint64_t Shift(char *a1, uint64_t a2, __int16 a3)
{
  unsigned int v3 = *a1;
  if ((*a1 & 0x80000000) == 0)
  {
    *a1 = (v3 + a3) & 0x7F;
    return 1;
  }
  if (v3 < 0xC0) {
    return 1;
  }
  int v4 = (a3 & 0x7FFF) - (a3 & 0x8000) + 0x1000000;
  if (v3 > 0xDF)
  {
    if (v3 > 0xEF)
    {
      if (v3 > 0xF7) {
        return 1;
      }
      if ((int)a2 >= 4)
      {
        unsigned __int8 v10 = a1[3];
        unsigned __int8 v11 = a1[2];
        unsigned __int8 v12 = a1[1];
        int v13 = ((v3 & 7) << 18) + v4 + (v10 & 0x3F);
        unsigned int v14 = v13 + ((v11 & 0x3F) << 6);
        unsigned int v15 = v14 + ((v12 & 0x3F) << 12);
        *a1 = (v15 >> 18) & 7 | 0xF0;
        a1[1] = v12 & 0xC0 | (v15 >> 12) & 0x3F;
        a1[2] = v11 & 0xC0 | (v14 >> 6) & 0x3F;
        a1[3] = v10 & 0xC0 | v13 & 0x3F;
        return 4;
      }
    }
    else if ((int)a2 >= 3)
    {
      unsigned __int8 v7 = a1[2];
      unsigned __int8 v8 = a1[1];
      int v9 = ((v3 & 0xF) << 12) + v4 + (v7 & 0x3F);
      *a1 = ((unsigned __int16)(v9 + ((v8 & 0x3F) << 6)) >> 12) | 0xE0;
      a1[1] = v8 & 0xC0 | ((v9 + ((v8 & 0x3Fu) << 6)) >> 6) & 0x3F;
      a1[2] = v7 & 0xC0 | v9 & 0x3F;
      return 3;
    }
  }
  else
  {
    if ((int)a2 < 2) {
      return 1;
    }
    unsigned __int8 v5 = a1[1];
    unsigned int v6 = (v5 & 0x3F | ((v3 & 0x1F) << 6)) + v4;
    *a1 = (v6 >> 6) & 0x1F | 0xC0;
    a1[1] = v5 & 0xC0 | v6 & 0x3F;
    return 2;
  }
  return a2;
}

uint64_t lzvnEncodeInitState(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(result + 8);
  if (v4 <= -65535) {
    uint64_t v4 = -65535;
  }
  unsigned __int8 v5 = (const float *)(*(void *)result + v4);
  float32x4_t v6 = vld1q_dup_f32(v5);
  if (a2 == 2305) {
    int v7 = 11;
  }
  else {
    int v7 = 14;
  }
  *(_DWORD *)(result + 72) = v7;
  *(void *)(result + 128) = a3;
  int32x4_t v8 = vdupq_n_s32(v4);
  unsigned int v9 = 1;
  do
  {
    unsigned __int8 v10 = (int32x4_t *)(*(void *)(result + 128) + v3);
    *unsigned __int8 v10 = v8;
    v10[1] = (int32x4_t)v6;
    LODWORD(v10) = v9 >> v7;
    v3 += 32;
    ++v9;
  }
  while (!v10);
  return result;
}

int64_t lzvnEncode(int64_t result, int8x16_t a2)
{
  uint64_t v2 = *(void *)(result + 24);
  if (v2 < *(void *)(result + 32))
  {
    int64_t v3 = result;
    int64_t v93 = result + 80;
    do
    {
      uint64_t v4 = *(void *)v3;
      unsigned int v5 = *(_DWORD *)(*(void *)v3 + v2);
      uint64_t v6 = (-1640531535 * (v5 & 0xFFFFFF)) >> -*(unsigned char *)(v3 + 72);
      int v7 = (int8x16_t *)(*(void *)(v3 + 128) + 32 * v6);
      int8x16_t v9 = *v7;
      int8x16_t v8 = v7[1];
      int64_t v10 = *(void *)(v3 + 40);
      if (v2 >= v10)
      {
        a2 = veorq_s8(v8, (int8x16_t)vdupq_n_s32(v5));
        unsigned int v11 = __clz(__rbit64(a2.u32[0])) >> 3;
        if (a2.i32[0]) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = 4;
        }
        uint64_t v13 = *(void *)(v3 + 8);
        uint64_t v14 = *(void *)(v3 + 16);
        if (v12 >= 3 && (uint64_t v15 = v2 - v9.i32[0], (unint64_t)(v15 - 0x10000) >= 0xFFFFFFFFFFFF0001))
        {
          for (uint64_t i = v2 + v12; v12 == 4 && i + 4 < v14; i += v12)
          {
            unint64_t v23 = (*(_DWORD *)(v4 + i - v15) ^ *(_DWORD *)(v4 + i));
            unsigned int v24 = __clz(__rbit64(v23)) >> 3;
            if (v23) {
              uint64_t v12 = v24;
            }
            else {
              uint64_t v12 = 4;
            }
          }
          uint64_t v25 = 0;
          do
          {
            uint64_t v26 = v25;
            int64_t v27 = v2 + v25;
            uint64_t v28 = v9.i32[0] + v25;
            if (v27 <= v10 || v28 <= v13) {
              break;
            }
            uint64_t v25 = v26 - 1;
          }
          while (*(unsigned __int8 *)(v4 - 1 + v2 + v26) == *(unsigned __int8 *)(v4 - 1 + v9.i32[0] + v26));
          uint64_t result = i - v2;
          uint64_t v30 = -3;
          if (v15 < 1536) {
            uint64_t v30 = -2;
          }
          uint64_t v31 = v30 + result;
          uint64_t v32 = v30 + result - v26;
          if (v32 > 0 || (v16 = 0, v17 = 0, uint64_t v18 = 0, v19 = 0, v20 = 0, v31 == v26) && i >= 2)
          {
            uint64_t v18 = result - v26;
            int64_t v16 = v27;
            uint64_t v17 = i;
            uint64_t v19 = v2 - v9.i32[0];
            uint64_t v20 = v32;
          }
        }
        else
        {
          int64_t v16 = 0;
          uint64_t v17 = 0;
          uint64_t v18 = 0;
          uint64_t v19 = 0;
          uint64_t v20 = 0;
        }
        unsigned int v33 = __clz(__rbit64(a2.u32[1])) >> 3;
        if (a2.i32[1]) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = 4;
        }
        if (v34 >= 3)
        {
          uint64_t v35 = v2 - v9.i32[1];
          if ((unint64_t)(v35 - 0x10000) >= 0xFFFFFFFFFFFF0001)
          {
            for (uint64_t j = v2 + v34; v34 == 4 && j + 4 < v14; j += v34)
            {
              unint64_t v38 = (*(_DWORD *)(v4 + j - v35) ^ *(_DWORD *)(v4 + j));
              unsigned int v39 = __clz(__rbit64(v38)) >> 3;
              if (v38) {
                uint64_t v34 = v39;
              }
              else {
                uint64_t v34 = 4;
              }
            }
            uint64_t v40 = 0;
            do
            {
              uint64_t v41 = v40;
              int64_t v42 = v2 + v40;
              uint64_t v43 = v9.i32[1] + v40;
              if (v42 <= v10 || v43 <= v13) {
                break;
              }
              uint64_t v40 = v41 - 1;
            }
            while (*(unsigned __int8 *)(v4 - 1 + v2 + v41) == *(unsigned __int8 *)(v4 - 1 + v9.i32[1] + v41));
            uint64_t result = j - v2;
            uint64_t v45 = v35 >= 1536 ? -3 : -2;
            if (v45 + result - v41 > v20 || v45 + j - v20 - v2 == v41 && j > v17 + 1)
            {
              uint64_t v18 = result - v41;
              int64_t v16 = v42;
              uint64_t v17 = j;
              uint64_t v19 = v2 - v9.i32[1];
              uint64_t v20 = v45 + result - v41;
            }
          }
        }
        unsigned int v46 = __clz(__rbit64(a2.u32[2])) >> 3;
        if (a2.i32[2]) {
          uint64_t v47 = v46;
        }
        else {
          uint64_t v47 = 4;
        }
        if (v47 >= 3)
        {
          uint64_t v48 = v2 - v9.i32[2];
          if ((unint64_t)(v48 - 0x10000) >= 0xFFFFFFFFFFFF0001)
          {
            uint64_t v49 = v2 + v47;
            if (v47 == 4 && v49 + 4 < v14)
            {
              do
              {
                unint64_t v50 = (*(_DWORD *)(v4 + v49 - v48) ^ *(_DWORD *)(v4 + v49));
                unsigned int v51 = __clz(__rbit64(v50)) >> 3;
                if (v50) {
                  uint64_t v52 = v51;
                }
                else {
                  uint64_t v52 = 4;
                }
                v49 += v52;
              }
              while (v52 == 4 && v49 + 4 < v14);
            }
            uint64_t v54 = 0;
            do
            {
              uint64_t v55 = v54;
              int64_t v56 = v2 + v54;
              uint64_t v57 = v9.i32[2] + v54;
              if (v56 <= v10 || v57 <= v13) {
                break;
              }
              uint64_t v54 = v55 - 1;
            }
            while (*(unsigned __int8 *)(v4 - 1 + v2 + v55) == *(unsigned __int8 *)(v4 - 1 + v9.i32[2] + v55));
            uint64_t result = v49 - v2;
            if (v48 >= 1536) {
              uint64_t v59 = -3;
            }
            else {
              uint64_t v59 = -2;
            }
            if (v59 + result - v55 > v20 || v59 + v49 - v20 - v2 == v55 && v49 > v17 + 1)
            {
              uint64_t v18 = result - v55;
              int64_t v16 = v56;
              uint64_t v17 = v49;
              uint64_t v19 = v2 - v9.i32[2];
              uint64_t v20 = v59 + result - v55;
            }
          }
        }
        unsigned int v60 = __clz(__rbit64(a2.u32[3])) >> 3;
        if (a2.i32[3]) {
          uint64_t v61 = v60;
        }
        else {
          uint64_t v61 = 4;
        }
        if (v61 >= 3)
        {
          uint64_t v62 = v2 - v9.i32[3];
          if ((unint64_t)(v62 - 0x10000) >= 0xFFFFFFFFFFFF0001)
          {
            for (uint64_t k = v2 + v61; v61 == 4 && k + 4 < v14; k += v61)
            {
              unint64_t v65 = (*(_DWORD *)(v4 + k - v62) ^ *(_DWORD *)(v4 + k));
              unsigned int v66 = __clz(__rbit64(v65)) >> 3;
              if (v65) {
                uint64_t v61 = v66;
              }
              else {
                uint64_t v61 = 4;
              }
            }
            uint64_t v67 = 0;
            do
            {
              uint64_t v68 = v67;
              int64_t v69 = v2 + v67;
              uint64_t v70 = v9.i32[3] + v67;
              if (v69 <= v10 || v70 <= v13) {
                break;
              }
              uint64_t v67 = v68 - 1;
            }
            while (*(unsigned __int8 *)(v4 - 1 + v2 + v68) == *(unsigned __int8 *)(v4 - 1 + v9.i32[3] + v68));
            uint64_t result = k - v2;
            uint64_t v72 = v62 >= 1536 ? -3 : -2;
            if (v72 + result - v68 > v20 || v72 + k - v20 - v2 == v68 && k > v17 + 1)
            {
              uint64_t v18 = result - v68;
              int64_t v16 = v69;
              uint64_t v17 = k;
              uint64_t v19 = v2 - v9.i32[3];
              uint64_t v20 = v72 + result - v68;
            }
          }
        }
        uint64_t v73 = *(void *)(v3 + 120);
        if (v73)
        {
          unint64_t v74 = *(_DWORD *)(v4 + v2 - v73) ^ v5;
          unsigned int v75 = __clz(__rbit64(v74)) >> 3;
          if (!v74) {
            unsigned int v75 = 4;
          }
          if ((unint64_t)(v73 - 0x10000) >= 0xFFFFFFFFFFFF0001 && v75 >= 3)
          {
            uint64_t v76 = v2 + v75;
            uint64_t v77 = v76 + 4;
            for (BOOL m = v75 == 4; m && v77 < v14; BOOL m = v82 == 4)
            {
              unint64_t v80 = (*(_DWORD *)(v4 + v76 - v73) ^ *(_DWORD *)(v4 + v76));
              unsigned int v81 = __clz(__rbit64(v80)) >> 3;
              if (v80) {
                uint64_t v82 = v81;
              }
              else {
                uint64_t v82 = 4;
              }
              v76 += v82;
              uint64_t v77 = v76 + 4;
            }
            uint64_t result = v2;
            do
            {
              int64_t v83 = result;
              if (result <= v10) {
                break;
              }
              result -= v73;
              if (v83 - v73 <= v13) {
                break;
              }
              uint64_t result = v83 - 1;
            }
            while (*(unsigned __int8 *)(v4 - 1 + v83) == *(unsigned __int8 *)(v4 - 1 - v73 + v83));
            if (v76 - v83 - 1 > v20 || ~v20 + v76 == v83 && v76 > v17 + 1)
            {
              int64_t v16 = v83;
              uint64_t v17 = v76;
              uint64_t v18 = v76 - v83;
              uint64_t v19 = *(void *)(v3 + 120);
              uint64_t v20 = v76 - v83 - 1;
            }
          }
        }
        if (v18)
        {
          if (!*(void *)(v3 + 96)) {
            goto LABEL_146;
          }
          int8x16_t v94 = v9;
          int8x16_t v97 = v8;
          if (*(void *)(v3 + 88) <= v16)
          {
            long long v86 = *(_OWORD *)(v93 + 16);
            long long v100 = *(_OWORD *)v93;
            long long v101 = v86;
            uint64_t v102 = *(void *)(v93 + 32);
            uint64_t result = emitMatch((void *)v3, &v100);
            int8x16_t v9 = v94;
            int8x16_t v8 = v97;
            if (!result) {
              return result;
            }
LABEL_146:
            *(void *)(v3 + 80) = v16;
            *(void *)(v3 + 88) = v17;
            *(void *)(v3 + 96) = v18;
            *(void *)(v3 + 104) = v19;
            *(void *)(v3 + 112) = v20;
            goto LABEL_147;
          }
          if (v20 > *(void *)(v3 + 112))
          {
            *(void *)(v3 + 80) = v16;
            *(void *)(v3 + 88) = v17;
            *(void *)(v3 + 96) = v18;
            *(void *)(v3 + 104) = v19;
            *(void *)(v3 + 112) = v20;
          }
          long long v84 = *(_OWORD *)(v93 + 16);
          long long v100 = *(_OWORD *)v93;
          long long v101 = v84;
          uint64_t v102 = *(void *)(v93 + 32);
          uint64_t result = emitMatch((void *)v3, &v100);
          int8x16_t v9 = v94;
          int8x16_t v8 = v97;
          if (!result) {
            return result;
          }
          goto LABEL_144;
        }
        if (v2 - v10 >= 400)
        {
          if (*(void *)(v3 + 96))
          {
            int8x16_t v95 = v9;
            int8x16_t v98 = v8;
            long long v85 = *(_OWORD *)(v93 + 16);
            long long v100 = *(_OWORD *)v93;
            long long v101 = v85;
            uint64_t v102 = *(void *)(v93 + 32);
            uint64_t result = emitMatch((void *)v3, &v100);
            int8x16_t v9 = v95;
            int8x16_t v8 = v98;
            if (!result) {
              return result;
            }
LABEL_144:
            *(void *)(v93 + 32) = 0;
            a2 = 0uLL;
            *(_OWORD *)int64_t v93 = 0u;
            *(_OWORD *)(v93 + 16) = 0u;
            goto LABEL_147;
          }
          unsigned __int8 v90 = *(_WORD **)(v3 + 48);
          unint64_t v91 = *(void *)(v3 + 64);
          if ((unint64_t)v90 + 281 < v91)
          {
            _WORD *v90 = -32;
            int8x16_t v96 = v9;
            int8x16_t v99 = v8;
            uint64_t result = (int64_t)memcpy(v90 + 1, (const void *)(v4 + v10), 0x10FuLL);
            int8x16_t v9 = v96;
            int8x16_t v8 = v99;
            unint64_t v91 = (unint64_t)v90 + 273;
          }
          if (v91 >= *(void *)(v3 + 64)) {
            return result;
          }
          uint64_t v92 = *(void *)(v3 + 48);
          *(void *)(v3 + 40) += 271;
          *(void *)(v3 + 48) = v91;
          if (v91 == v92) {
            return result;
          }
        }
      }
LABEL_147:
      a2 = vextq_s8(a2, v9, 0xCuLL);
      a2.i32[0] = v2;
      int8x16_t v87 = vextq_s8(a2, v8, 0xCuLL);
      v87.i32[0] = v5;
      uint64_t v88 = *(void *)(v3 + 128) + 32 * v6;
      *(int8x16_t *)uint64_t v88 = a2;
      *(int8x16_t *)(v88 + 16) = v87;
      uint64_t v89 = *(void *)(v3 + 32);
      uint64_t v2 = *(void *)(v3 + 24) + 1;
      *(void *)(v3 + 24) = v2;
    }
    while (v2 < v89);
  }
  return result;
}

unint64_t emitMatch(void *a1, void *a2)
{
  uint64_t v4 = a1[5];
  unsigned int v5 = (char *)a1[6];
  unint64_t v6 = *a2 - v4;
  unint64_t v7 = a2[2];
  unint64_t v8 = a2[3];
  uint64_t v25 = a1[15];
  int8x16_t v9 = (int *)(*a1 + v4);
  unint64_t v10 = a1[8];
  if (v6 < 0x10)
  {
LABEL_7:
    if (v6 >= 4)
    {
      if ((unint64_t)&v5[v6 + 10] >= v10) {
        goto LABEL_39;
      }
      *unsigned int v5 = v6 | 0xE0;
      uint64_t v13 = v5 + 1;
      memcpy(v13, v9, ((v6 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
      unsigned int v5 = &v13[v6];
      int8x16_t v9 = (int *)((char *)v9 + v6);
      unint64_t v6 = 0;
    }
    if (10 - 2 * v6 >= v7) {
      uint64_t v14 = v7;
    }
    else {
      uint64_t v14 = 10 - 2 * v6;
    }
    if ((unint64_t)(v5 + 8) < v10)
    {
      unint64_t v15 = v7 - v14;
      char v16 = v14 - 3;
      int v17 = *v9;
      if (v8 == v25)
      {
        char v18 = ((_BYTE)v6 << 6) + 8 * v16;
        if (v6) {
          char v19 = 6;
        }
        else {
          char v19 = -16;
        }
        if (!v6) {
          char v18 = v14;
        }
        *unsigned int v5 = v19 | v18;
        uint64_t v20 = v5 + 1;
      }
      else if (v8 > 0x5FF)
      {
        if (v7 <= 0x22 && !(v8 >> 14) && v15)
        {
          *unsigned int v5 = ((v7 - 3) >> 2) + 8 * v6 - 96;
          *(_WORD *)(v5 + 1) = (v7 - 3) & 3 | (4 * v8);
          *(_DWORD *)(v5 + 3) = v17;
          unint64_t v10 = (unint64_t)&v5[v6 + 3];
          goto LABEL_39;
        }
        *unsigned int v5 = (((_BYTE)v6 << 6) + 8 * v16) | 7;
        *(_WORD *)(v5 + 1) = v8;
        uint64_t v20 = v5 + 3;
      }
      else
      {
        *unsigned int v5 = ((_BYTE)v6 << 6) + BYTE1(v8) + 8 * v16;
        v5[1] = v8;
        uint64_t v20 = v5 + 2;
      }
      *uint64_t v20 = v17;
      unsigned int v21 = (_WORD *)((char *)v20 + v6);
      if (v15 < 0x10)
      {
        int v22 = (char *)v20 + v6;
        if (v15)
        {
LABEL_35:
          if ((unint64_t)(v22 + 1) < v10)
          {
            unsigned char *v22 = v15 | 0xF0;
            unint64_t v10 = (unint64_t)(v22 + 1);
          }
        }
        else
        {
LABEL_38:
          unint64_t v10 = (unint64_t)v22;
        }
      }
      else
      {
        while (1)
        {
          int v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >= v10) {
            break;
          }
          if (v15 >= 0x10F) {
            uint64_t v23 = 271;
          }
          else {
            uint64_t v23 = v15;
          }
          *unsigned int v21 = ((_WORD)v23 << 8) - 3856;
          v15 -= v23;
          ++v21;
          if (v15 <= 0xF)
          {
            if (!v15) {
              goto LABEL_38;
            }
            goto LABEL_35;
          }
        }
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t v11 = v6 >= 0x10F ? 271 : v6;
      if ((unint64_t)&v5[v11 + 10] >= v10) {
        break;
      }
      *(_WORD *)unsigned int v5 = ((_WORD)v11 << 8) - 3872;
      uint64_t v12 = v5 + 2;
      v6 -= v11;
      memcpy(v12, v9, ((v11 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
      unsigned int v5 = &v12[v11];
      int8x16_t v9 = (int *)((char *)v9 + v11);
      if (v6 <= 0xF) {
        goto LABEL_7;
      }
    }
  }
LABEL_39:
  if (v10 >= a1[8]) {
    return 0;
  }
  unint64_t result = v10 - a1[6];
  a1[15] = a2[3];
  a1[5] = a2[1];
  a1[6] = v10;
  return result;
}

uint64_t lzvn_encode_scratch_size(int a1)
{
  if (a1 == 2305) {
    return 0x10000;
  }
  else {
    return 0x80000;
  }
}

char *lzvn_encode_buffer(char *a1, unint64_t a2, const float *a3, unint64_t a4, int8x16_t *a5, int a6)
{
  uint64_t v8 = 0;
  unint64_t result = lzvn_encode_partial(a1, a2, a3, a4, &v8, a5, a6);
  if (v8 != a4) {
    return 0;
  }
  return result;
}

char *lzvn_encode_partial(char *a1, unint64_t a2, const float *a3, unint64_t a4, uint64_t *a5, int8x16_t *a6, int a7)
{
  if (a2 < 8 || a4 <= 7)
  {
    unint64_t result = 0;
    *a5 = 0;
    return result;
  }
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v7 = 0xFFFFFFFFLL;
  long long v37 = 0u;
  if (a4 < 0xFFFFFFFF) {
    uint64_t v7 = a4;
  }
  v27[0] = a3;
  v27[1] = 0;
  uint64_t v28 = v7;
  uint64_t v29 = 0;
  uint64_t v30 = v7 - 8;
  uint64_t v31 = 0;
  uint64_t v32 = a1;
  unsigned int v33 = a1;
  unint64_t v8 = (unint64_t)&a1[a2];
  uint64_t v34 = (uint64_t)&a1[a2 - 8];
  if (a7 == 2305) {
    int v9 = 11;
  }
  else {
    int v9 = 14;
  }
  LODWORD(v35) = v9;
  uint64_t v38 = 0;
  unsigned int v39 = a6;
  unint64_t v10 = a6 + 1;
  unsigned int v11 = 1;
  int8x16_t v12 = (int8x16_t)vld1q_dup_f32(a3);
  do
  {
    v10[-1].i64[0] = 0;
    v10[-1].i64[1] = 0;
    unsigned int v13 = v11++ >> v9;
    *unint64_t v10 = v12;
    v10 += 2;
  }
  while (!v13);
  lzvnEncode((int64_t)v27, v12);
  uint64_t v14 = v28;
  uint64_t v15 = v31;
  char v16 = v32;
  size_t v17 = v28 - v31;
  char v18 = (char *)(v27[0] + v31);
  unint64_t v19 = v34;
  if ((unint64_t)(v28 - v31) < 0x10)
  {
    uint64_t v20 = v32;
    if (!v17)
    {
LABEL_22:
      uint64_t v23 = a5;
LABEL_23:
      if ((unint64_t)v20 < v19)
      {
        uint64_t v15 = v14;
        char v16 = v20;
      }
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v20 = v32;
    do
    {
      if (v17 >= 0x10F) {
        size_t v21 = 271;
      }
      else {
        size_t v21 = v17;
      }
      if ((unint64_t)&v20[v21 + 10] >= v19)
      {
        uint64_t v23 = a5;
        goto LABEL_27;
      }
      *(_WORD *)uint64_t v20 = ((_WORD)v21 << 8) - 3872;
      int v22 = v20 + 2;
      v17 -= v21;
      memcpy(v22, v18, v21);
      uint64_t v20 = &v22[v21];
      v18 += v21;
    }
    while (v17 > 0xF);
    if (!v17) {
      goto LABEL_22;
    }
  }
  uint64_t v23 = a5;
  if ((unint64_t)&v20[v17 + 10] < v19)
  {
    *uint64_t v20 = v17 | 0xE0;
    unsigned int v24 = v20 + 1;
    memcpy(v24, v18, v17);
    uint64_t v20 = &v24[v17];
    goto LABEL_23;
  }
LABEL_27:
  if (v8 >= (unint64_t)(v16 + 8))
  {
    *(void *)char v16 = 6;
    v16 += 8;
  }
  *uint64_t v23 = v15;
  return (char *)(v16 - v33);
}

uint64_t zlib_malloc(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3 = a3 * (unint64_t)a2;
  unint64_t v4 = a1[1];
  uint64_t v5 = v4 - v3;
  if (v4 < v3) {
    return 0;
  }
  uint64_t v6 = *a1;
  *a1 += v3;
  a1[1] = v5;
  return v6;
}

uint64_t smb_encode_scratch_size(int a1)
{
  uint64_t v1 = 0x10000;
  uint64_t v2 = 172392;
  if (a1 != 3104) {
    uint64_t v2 = 0;
  }
  if (a1 != 3088) {
    uint64_t v1 = v2;
  }
  if (a1 == 3072) {
    return 0x8000;
  }
  else {
    return v1;
  }
}

uint64_t smb_decode_scratch_size(int a1)
{
  if (a1 == 3104) {
    return 5632;
  }
  else {
    return 0;
  }
}

uint64_t smb_encode_buffer(_WORD *a1, unint64_t a2, unsigned char *a3, unint64_t a4, void *a5, int a6)
{
  unsigned int v6 = -16777216;
  if (a4 > 0xFFFFFFFFFF000000) {
    return 0;
  }
  if (a2 < 0xFFFFFFFFFF000000) {
    unsigned int v6 = a2;
  }
  unsigned int v7 = a6 & 0xFFFFFFF0;
  if ((a6 & 0xFFFFFFF0) == 0xC00) {
    return smb_lznt1_encode_buffer(a1, v6, a3, a4, a5);
  }
  if (v7 != 3104)
  {
    if (v7 == 3088) {
      return smb_lz77_encode_buffer((uint64_t)a1, v6, (uint64_t)a3, a4, a5);
    }
    return 0;
  }
  return smb_lz77h_encode_buffer((uint64_t)a1, v6, (uint64_t)a3, a4, (char *)a5);
}

uint64_t smb_decode_buffer(char *a1, unint64_t a2, char *a3, unint64_t a4, char *a5, int a6)
{
  unsigned int v6 = a6 & 0xFFFFFFF0;
  if ((a6 & 0xFFFFFFF0) == 0xC20) {
    return smb_lz77h_decode_buffer((uint64_t)a1, a2, (uint64_t)a3, a4, a5);
  }
  if (v6 == 3088) {
    return smb_lz77_decode_buffer((uint64_t)a1, a2, (uint64_t)a3, a4);
  }
  if (v6 == 3072) {
    return smb_lznt1_decode_buffer(a1, a2, a3, a4);
  }
  return 0;
}

uint64_t lzbitmap_fast_decode_buffer(uint64_t a1, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t a5)
{
  if ((a4 | (unint64_t)a2) >> 32) {
    return 0;
  }
  else {
    return lzbitmap_fast_decode(a1, a2, a3, a4, a5);
  }
}

uint64_t lzbitmap_fast_encode_buffer(uint64_t a1, unint64_t a2, char *a3, unint64_t a4, void *a5, unsigned int a6)
{
  if (HIDWORD(a4)) {
    return 0;
  }
  if (a2 >= 0xFFFFFFFF) {
    LODWORD(a2) = -1;
  }
  return lzbitmap_fast_encode(a1, a2, a3, a4, a5, a6);
}

uint64_t lzbitmap_fast_encode_scratch_size(unsigned int a1)
{
  return lzbitmap_fast_encode_state_size(a1);
}

uint64_t lzbitmap_decode_buffer(uint64_t a1, unint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, int32x4_t a9)
{
  if ((a4 | a2) >> 32) {
    return 0;
  }
  else {
    return lzbitmap_decode(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t lzbitmap_encode_buffer(int *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unsigned int a6)
{
  if (HIDWORD(a4)) {
    return 0;
  }
  if (a2 >= 0xFFFFFFFF) {
    LODWORD(a2) = -1;
  }
  return lzbitmap_encode(a1, a2, a3, a4, a5, a6);
}

uint64_t lzbitmap_decode_scratch_size()
{
  return 8320;
}

uint64_t lzbitmap_encode_scratch_size(unsigned int a1)
{
  return lzbitmap_encode_state_size(a1);
}

BOOL lzbitmap_stream_identify_algorithm(_DWORD *a1)
{
  return (*a1 & 0xF0FFFFFF) == 5063258;
}

unint64_t BrotliStoreHuffmanTree(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v33 = 0;
  v37[0] = 0;
  v37[1] = 0;
  __int16 v38 = 0;
  uint64_t v35 = 0;
  memset(v34, 0, sizeof(v34));
  BrotliWriteHuffmanTree(a1, a2, &v33, (uint64_t)v40, (uint64_t)v39);
  uint64_t v8 = v33;
  if (v33)
  {
    int v9 = v40;
    do
    {
      unsigned int v10 = *v9++;
      ++*((_DWORD *)v34 + v10);
      --v8;
    }
    while (v8);
  }
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v13 = 0;
  while (!*((_DWORD *)v34 + v13))
  {
LABEL_8:
    if (++v13 == 18) {
      goto LABEL_11;
    }
  }
  if (!v12)
  {
    int v12 = 1;
    uint64_t v11 = v13;
    goto LABEL_8;
  }
  int v12 = 2;
LABEL_11:
  unint64_t v14 = 18;
  BrotliCreateHuffmanTree((uint64_t)v34, 18, 5, a3, (uint64_t)v37);
  unint64_t result = (unint64_t)BrotliConvertBitDepthsToSymbols((unsigned __int8 *)v37, 18, (uint64_t)v36);
  if (v12 >= 2)
  {
    uint64_t v16 = 0x11u;
    while (!*((unsigned char *)v37 + BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kStorageOrder[v16]))
    {
      if (--v16 == -1)
      {
        unint64_t v14 = 0;
        goto LABEL_17;
      }
    }
    unint64_t v14 = v16 + 1;
  }
LABEL_17:
  uint64_t v17 = 2;
  if (!BYTE3(v37[0])) {
    uint64_t v17 = 3;
  }
  if (BYTE1(v37[0]) | BYTE2(v37[0])) {
    unint64_t v18 = 0;
  }
  else {
    unint64_t v18 = v17;
  }
  unint64_t v19 = *a4;
  *(void *)(a5 + (*a4 >> 3)) = (v18 << (*a4 & 7)) | *(unsigned __int8 *)(a5 + (*a4 >> 3));
  unint64_t v20 = v19 + 2;
  *a4 = v20;
  unint64_t v21 = v14 - v18;
  if (v14 > v18)
  {
    int v22 = &BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kStorageOrder[v18];
    do
    {
      unsigned int v23 = *v22++;
      uint64_t v24 = *((unsigned __int8 *)v37 + v23);
      uint64_t v25 = BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kHuffmanBitLengthHuffmanCodeBitLengths[v24];
      unint64_t result = v20 & 7;
      *(void *)(a5 + (v20 >> 3)) = ((unint64_t)BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask_kHuffmanBitLengthHuffmanCodeSymbols[v24] << (v20 & 7)) | *(unsigned __int8 *)(a5 + (v20 >> 3));
      v20 += v25;
      --v21;
    }
    while (v21);
    *a4 = v20;
  }
  if (v12 == 1) {
    *((unsigned char *)v37 + v11) = 0;
  }
  uint64_t v26 = v33;
  if (v33)
  {
    int64_t v27 = v39;
    uint64_t v28 = v40;
    while (1)
    {
      unsigned int v30 = *v28++;
      unsigned int v29 = v30;
      uint64_t v31 = *((unsigned __int8 *)v37 + v30);
      unint64_t result = *(unsigned __int8 *)(a5 + (v20 >> 3));
      *(void *)(a5 + (v20 >> 3)) = ((unint64_t)(unsigned __int16)v36[v30] << (v20 & 7)) | result;
      v20 += v31;
      if (v30 == 16) {
        break;
      }
      if (v29 == 17)
      {
        uint64_t v32 = 3;
LABEL_34:
        unint64_t result = v20 & 7;
        *(void *)(a5 + (v20 >> 3)) = ((unint64_t)*v27 << (v20 & 7)) | *(unsigned __int8 *)(a5 + (v20 >> 3));
        v20 += v32;
      }
      ++v27;
      if (!--v26)
      {
        *a4 = v20;
        return result;
      }
    }
    uint64_t v32 = 2;
    goto LABEL_34;
  }
  return result;
}

unint64_t BrotliBuildAndStoreHuffmanTreeFast(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  long long v90 = 0u;
  long long v91 = 0u;
  if (!a3) {
    goto LABEL_9;
  }
  unint64_t v14 = 0;
  unint64_t v15 = 0;
  uint64_t v16 = 8;
  do
  {
    uint64_t v17 = *(unsigned int *)(a2 + 4 * v15);
    if (v17)
    {
      if (v14 <= 3) {
        *((void *)&v90 + v14) = v15;
      }
      ++v14;
      a3 -= v17;
    }
    ++v15;
    v16 += 16;
  }
  while (a3);
  unint64_t v18 = v14 - 1;
  if (v14 <= 1)
  {
LABEL_9:
    unint64_t v19 = *a7;
    *(void *)(a8 + (*a7 >> 3)) = (1 << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
    v19 += 4;
    *a7 = v19;
    uint64_t v20 = v90;
    *(void *)(a8 + (v19 >> 3)) = ((void)v90 << (v19 & 7)) | *(unsigned __int8 *)(a8 + (v19 >> 3));
    *a7 = v19 + a4;
    a5[v20] = 0;
    *(_WORD *)(a6 + 2 * v20) = 0;
    return result;
  }
  uint64_t v89 = result;
  bzero(a5, v15);
  unint64_t result = BrotliAllocate(v89);
  if (!*(_DWORD *)(v89 + 24))
  {
    uint64_t v21 = result;
    uint64_t v88 = a6;
    unsigned int v22 = 1;
    do
    {
      if (v15)
      {
        unint64_t v23 = v15 - 1;
        uint64_t v24 = v21;
        do
        {
          unsigned int v25 = *(_DWORD *)(a2 + 4 * v23);
          if (v25)
          {
            if (v25 < v22) {
              unsigned int v25 = v22;
            }
            *(_DWORD *)uint64_t v24 = v25;
            *(_WORD *)(v24 + 4) = -1;
            *(_WORD *)(v24 + 6) = v23;
            v24 += 8;
          }
          --v23;
        }
        while (v23 != -1);
      }
      else
      {
        uint64_t v24 = v21;
      }
      unint64_t v26 = (v24 - v21) << 29;
      unint64_t v27 = (int)((v24 - v21) >> 3);
      if (((unint64_t)(v24 - v21) >> 3) > 0xCuLL)
      {
        uint64_t v33 = 2 * (HIDWORD(v26) < 0x39);
        do
        {
          unint64_t v34 = kBrotliShellGaps[v33];
          if (v34 < v27)
          {
            uint64_t v35 = 0;
            unint64_t v36 = kBrotliShellGaps[v33];
            do
            {
              uint64_t v37 = *(void *)(v21 + 8 * v36);
              unint64_t v38 = v36;
              if (v36 >= v34)
              {
                uint64_t v39 = v35;
                unint64_t v40 = v36;
                while (*(_DWORD *)(v21 + v39) > v37)
                {
                  unint64_t v38 = v40 - v34;
                  *(void *)(v21 + 8 * v40) = *(void *)(v21 + v39);
                  v39 -= 8 * v34;
                  unint64_t v40 = v38;
                  if (v38 < v34) {
                    goto LABEL_40;
                  }
                }
                unint64_t v38 = v40;
              }
LABEL_40:
              *(void *)(v21 + 8 * v38) = v37;
              ++v36;
              v35 += 8;
            }
            while (v36 != v27);
          }
          ++v33;
        }
        while (v33 != 6);
      }
      else if (v26 >> 33)
      {
        uint64_t v28 = 0;
        if (v27 <= 2) {
          unint64_t v27 = 2;
        }
        for (uint64_t i = 1; i != v27; ++i)
        {
          uint64_t v30 = *(void *)(v21 + 8 * i);
          uint64_t v31 = v28;
          uint64_t v32 = i;
          do
          {
            if (*(_DWORD *)(v21 + v31) <= v30) {
              break;
            }
            *(void *)(v21 + 8 * v32) = *(void *)(v21 + v31);
            v31 -= 8;
            --v32;
          }
          while (v32);
          *(void *)(v21 + 8 * v32) = v30;
          v28 += 8;
        }
      }
      unint64_t v41 = (unint64_t)(v24 - v21) >> 3;
      *(void *)uint64_t v24 = -1;
      *(void *)(v24 + 8) = -1;
      if ((int)v41 >= 2)
      {
        int v42 = 0;
        int v43 = v41 + 1;
        unint64_t v44 = (void *)(v24 + 16);
        unsigned int v45 = v41 + 1;
        do
        {
          unsigned int v46 = *(_DWORD *)(v21 + 8 * v42);
          unsigned int v47 = *(_DWORD *)(v21 + 8 * v43);
          BOOL v48 = v46 > v47;
          if (v46 > v47) {
            int v49 = v42;
          }
          else {
            int v49 = v42 + 1;
          }
          if (v48) {
            int v50 = v43 + 1;
          }
          else {
            int v50 = v43;
          }
          if (v48) {
            int v51 = v43;
          }
          else {
            int v51 = v42;
          }
          unsigned int v52 = *(_DWORD *)(v21 + 8 * v49);
          unsigned int v53 = *(_DWORD *)(v21 + 8 * v50);
          BOOL v54 = v52 > v53;
          if (v52 > v53) {
            int v42 = v49;
          }
          else {
            int v42 = v49 + 1;
          }
          if (v54) {
            int v43 = v50 + 1;
          }
          else {
            int v43 = v50;
          }
          if (v54) {
            int v49 = v50;
          }
          *((_DWORD *)v44 - 2) = *(_DWORD *)(v21 + 8 * v49) + *(_DWORD *)(v21 + 8 * v51);
          *((_WORD *)v44 - 2) = v51;
          *((_WORD *)v44 - 1) = v49;
          *v44++ = -1;
          --v45;
        }
        while (v45 > 2);
      }
      v22 *= 2;
    }
    while (!BrotliSetDepth(2 * (int)v41 - 1, v21, (uint64_t)a5, 14));
    BrotliFree(v89, v21);
    unint64_t result = (unint64_t)BrotliConvertBitDepthsToSymbols(a5, v15, v88);
    if (v14 <= 4)
    {
      uint64_t v55 = 0;
      unint64_t v56 = *a7;
      *(void *)(a8 + (*a7 >> 3)) = (1 << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
      *a7 = v56 + 2;
      *(void *)(a8 + ((v56 + 2) >> 3)) = (v18 << ((v56 + 2) & 7)) | *(unsigned __int8 *)(a8 + ((v56 + 2) >> 3));
      unint64_t v57 = v56 + 4;
      *a7 = v57;
      uint64_t v58 = (char *)&v90 + 8;
      do
      {
        uint64_t v59 = v55 + 1;
        if (v55 + 1 < v14)
        {
          uint64_t v60 = *((void *)&v90 + v55);
          uint64_t v61 = (uint64_t *)v58;
          unint64_t v62 = v18;
          do
          {
            uint64_t v63 = *v61;
            unint64_t result = a5[v60];
            if (a5[*v61] < result)
            {
              *uint64_t v61 = v60;
              *((void *)&v90 + v55) = v63;
              uint64_t v60 = v63;
            }
            ++v61;
            --v62;
          }
          while (v62);
        }
        --v18;
        v58 += 8;
        ++v55;
      }
      while (v59 != v14);
      unint64_t v64 = v57 >> 3;
      if (v14 == 3)
      {
        uint64_t v79 = *((void *)&v90 + 1);
        *(void *)(a8 + v64) = ((void)v90 << (v57 & 7)) | *(unsigned __int8 *)(a8 + v64);
        unint64_t v80 = v57 + a4;
        *a7 = v80;
        *(void *)(a8 + (v80 >> 3)) = (v79 << (v80 & 7)) | *(unsigned __int8 *)(a8 + (v80 >> 3));
        unint64_t v66 = v80 + a4;
        *a7 = v66;
        *(void *)(a8 + (v66 >> 3)) = ((void)v91 << (v66 & 7)) | *(unsigned __int8 *)(a8 + (v66 >> 3));
      }
      else
      {
        if (v14 != 2)
        {
          long long v82 = v90;
          *(void *)(a8 + v64) = ((void)v90 << (v57 & 7)) | *(unsigned __int8 *)(a8 + v64);
          unint64_t v83 = v57 + a4;
          *a7 = v83;
          *(void *)(a8 + (v83 >> 3)) = (*((void *)&v82 + 1) << (v83 & 7)) | *(unsigned __int8 *)(a8 + (v83 >> 3));
          unint64_t v84 = v83 + a4;
          *a7 = v84;
          uint64_t v85 = *((void *)&v91 + 1);
          *(void *)(a8 + (v84 >> 3)) = ((void)v91 << (v84 & 7)) | *(unsigned __int8 *)(a8 + (v84 >> 3));
          unint64_t v86 = v84 + a4;
          *a7 = v86;
          *(void *)(a8 + (v86 >> 3)) = (v85 << (v86 & 7)) | *(unsigned __int8 *)(a8 + (v86 >> 3));
          unint64_t v87 = v86 + a4;
          *a7 = v87;
          *(void *)(a8 + (v87 >> 3)) = ((unint64_t)(a5[v82] == 1) << (v87 & 7)) | *(unsigned __int8 *)(a8 + (v87 >> 3));
          unint64_t v81 = v87 + 1;
          goto LABEL_101;
        }
        uint64_t v65 = *((void *)&v90 + 1);
        *(void *)(a8 + v64) = ((void)v90 << (v57 & 7)) | *(unsigned __int8 *)(a8 + v64);
        unint64_t v66 = v57 + a4;
        *a7 = v66;
        *(void *)(a8 + (v66 >> 3)) = (v65 << (v66 & 7)) | *(unsigned __int8 *)(a8 + (v66 >> 3));
      }
      unint64_t v81 = v66 + a4;
LABEL_101:
      *a7 = v81;
      return result;
    }
    unint64_t v67 = *a7;
    *(void *)(a8 + (*a7 >> 3)) = (0xFF55555554 << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
    unint64_t v68 = v67 + 40;
    *a7 = v68;
    if (!v15) {
      return result;
    }
    unint64_t v69 = 0;
    uint64_t v70 = 8;
    while (1)
    {
      uint64_t v71 = a5[v69];
      if (v69 + 1 >= v15)
      {
        ++v69;
        unint64_t result = 1;
        if (!v71) {
          goto LABEL_94;
        }
      }
      else
      {
        uint64_t v72 = 0;
        unint64_t result = v15 - v69;
        while (a5[v69 + 1 + v72] == v71)
        {
          if (v15 - v69 - 1 == ++v72) {
            goto LABEL_93;
          }
        }
        unint64_t result = v72 + 1;
LABEL_93:
        v69 += result;
        if (!v71)
        {
LABEL_94:
          uint64_t v78 = kZeroRepsDepth[result];
          unint64_t result = (kZeroRepsBits[result] << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
          *(void *)(a8 + (v68 >> 3)) = result;
          v68 += v78;
          goto LABEL_95;
        }
      }
      if (v70 != v71)
      {
        uint64_t v73 = kCodeLengthDepth[v71];
        *(void *)(a8 + (v68 >> 3)) = ((unint64_t)kCodeLengthBits[v71] << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
        v68 += v73;
        *a7 = v68;
        --result;
      }
      if (result > 2) {
        break;
      }
      if (result)
      {
        uint64_t v74 = kCodeLengthDepth[v71];
        uint64_t v75 = kCodeLengthBits[v71];
        do
        {
          *(void *)(a8 + (v68 >> 3)) = (v75 << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
          v68 += v74;
          --result;
        }
        while (result);
        goto LABEL_91;
      }
LABEL_96:
      uint64_t v70 = v71;
      if (v69 >= v15) {
        return result;
      }
    }
    unint64_t v76 = result - 3;
    uint64_t v77 = kNonZeroRepsDepth[v76];
    unint64_t result = (kNonZeroRepsBits[v76] << (v68 & 7)) | *(unsigned __int8 *)(a8 + (v68 >> 3));
    *(void *)(a8 + (v68 >> 3)) = result;
    v68 += v77;
LABEL_91:
    uint64_t v70 = v71;
LABEL_95:
    *a7 = v68;
    uint64_t v71 = v70;
    goto LABEL_96;
  }
  return result;
}

uint64_t BrotliStoreMetaBlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, uint64_t a8, unsigned int *a9, unsigned int a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t *a14, uint64_t a15)
{
  int v15 = a8;
  uint64_t v20 = a14;
  uint64_t v19 = a15;
  uint64_t v158 = *MEMORY[0x263EF8340];
  size_t v21 = a9[19];
  uint64_t v103 = a9[18];
  StoreCompressedMetaBlockHeader(a8, a4, a14, a15);
  uint64_t result = BrotliAllocate(a1);
  if (!*(_DWORD *)(a1 + 24))
  {
    unint64_t v23 = result;
    uint64_t v24 = (uint64_t *)a13;
    long long v150 = 0u;
    long long v151 = 0u;
    long long v148 = 0u;
    long long v149 = 0u;
    long long v146 = 0u;
    long long v147 = 0u;
    long long v144 = 0u;
    long long v145 = 0u;
    long long v142 = 0u;
    long long v143 = 0u;
    long long v140 = 0u;
    long long v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    long long v137 = 0u;
    long long v136 = 0u;
    long long v135 = 0u;
    long long v134 = 0u;
    long long v133 = 0u;
    long long v132 = 0u;
    long long v131 = 0u;
    long long v130 = 0u;
    long long v129 = 0u;
    long long v128 = 0u;
    long long v127 = 0u;
    long long v126 = 0u;
    long long v125 = 0u;
    long long v124 = 0u;
    memset(v116, 0, sizeof(v116));
    long long v115 = 0u;
    *(_OWORD *)uint64_t v114 = 0u;
    memset(v108, 0, sizeof(v108));
    *(_OWORD *)unint64_t v106 = 0u;
    long long v107 = 0u;
    size_t v26 = *(void *)(a13 + 16);
    unsigned int v25 = *(unsigned int **)(a13 + 24);
    size_t v27 = *(void *)a13;
    size_t v28 = *(void *)(a13 + 8);
    v122[0] = 256;
    v122[1] = v27;
    v122[2] = v26;
    v122[3] = (size_t)v25;
    uint64_t v152 = 0;
    v122[4] = v28;
    long long v123 = xmmword_20DB05760;
    uint64_t v153 = 0;
    if (v28) {
      uint64_t v29 = *v25;
    }
    else {
      uint64_t v29 = 0;
    }
    uint64_t v154 = v29;
    uint64_t v155 = 0;
    unint64_t v157 = 0;
    unint64_t v156 = 0;
    uint64_t v31 = *(void *)(a13 + 64);
    uint64_t v30 = *(unsigned int **)(a13 + 72);
    size_t v32 = *(void *)(a13 + 48);
    uint64_t v33 = *(void *)(a13 + 56);
    v114[0] = 704;
    v114[1] = v32;
    *(void *)&long long v115 = v31;
    *((void *)&v115 + 1) = v30;
    *(void *)&v116[0] = v33;
    *(_OWORD *)((char *)v116 + 8) = xmmword_20DB05760;
    uint64_t v117 = 0;
    if (v33) {
      uint64_t v34 = *v30;
    }
    else {
      uint64_t v34 = 0;
    }
    uint64_t v118 = v34;
    uint64_t v119 = 0;
    unint64_t v121 = 0;
    unint64_t v120 = 0;
    uint64_t v36 = *(void *)(a13 + 112);
    uint64_t v35 = *(unsigned int **)(a13 + 120);
    size_t v37 = *(void *)(a13 + 96);
    uint64_t v38 = *(void *)(a13 + 104);
    v106[0] = v21;
    v106[1] = v37;
    *(void *)&long long v107 = v36;
    *((void *)&v107 + 1) = v35;
    *(void *)&v108[0] = v38;
    *(_OWORD *)((char *)v108 + 8) = xmmword_20DB05760;
    uint64_t v109 = 0;
    if (v38) {
      uint64_t v39 = *v35;
    }
    else {
      uint64_t v39 = 0;
    }
    uint64_t v110 = v39;
    uint64_t v111 = 0;
    unint64_t v113 = 0;
    unint64_t v112 = 0;
    BuildAndStoreBlockSwitchEntropyCodes((uint64_t)v122, result, a14, a15);
    BuildAndStoreBlockSwitchEntropyCodes((uint64_t)v114, v23, a14, a15);
    BuildAndStoreBlockSwitchEntropyCodes((uint64_t)v106, v23, a14, a15);
    uint64_t v40 = a9[16];
    unint64_t v41 = *a14;
    *(void *)(a15 + (*a14 >> 3)) = (v40 << (*a14 & 7)) | *(unsigned __int8 *)(a15 + (*a14 >> 3));
    *a14 = v41 + 2;
    *(void *)(a15 + ((v41 + 2) >> 3)) = ((unint64_t)(a9[17] >> v40) << ((v41 + 2) & 7)) | *(unsigned __int8 *)(a15 + ((v41 + 2) >> 3));
    unint64_t v42 = v41 + 6;
    *a14 = v41 + 6;
    if (*(void *)a13)
    {
      unint64_t v43 = 0;
      do
      {
        *(void *)(a15 + (v42 >> 3)) = ((unint64_t)a10 << (v42 & 7)) | *(unsigned __int8 *)(a15 + (v42 >> 3));
        v42 += 2;
        *a14 = v42;
        ++v43;
      }
      while (v43 < *(void *)a13);
    }
    unint64_t v44 = *(void *)(a13 + 152);
    if (v44)
    {
      uint64_t result = EncodeContextMap(a1, *(unsigned int **)(a13 + 144), v44, *(void *)(a13 + 184), v23, a14, a15);
      if (*(_DWORD *)(a1 + 24)) {
        return result;
      }
    }
    else
    {
      StoreTrivialContextMap(*(void *)(a13 + 184), 6uLL, v23, a14, a15);
    }
    unint64_t v45 = *(void *)(a13 + 168);
    if (v45)
    {
      uint64_t result = EncodeContextMap(a1, *(unsigned int **)(a13 + 160), v45, *(void *)(a13 + 216), v23, a14, a15);
      if (*(_DWORD *)(a1 + 24)) {
        return result;
      }
    }
    else
    {
      StoreTrivialContextMap(*(void *)(a13 + 216), 2uLL, v23, a14, a15);
    }
    uint64_t v97 = a5;
    uint64_t v98 = a1;
    int v94 = v15;
    unint64_t v47 = *(void *)(a13 + 176);
    uint64_t v46 = *(void *)(a13 + 184);
    if (v122[0] * v46)
    {
      uint64_t v48 = v98;
      unint64_t v156 = BrotliAllocate(v98);
      uint64_t result = BrotliAllocate(v98);
    }
    else
    {
      uint64_t result = 0;
      unint64_t v156 = 0;
      uint64_t v48 = v98;
    }
    unint64_t v157 = result;
    int v49 = *(_DWORD *)(v48 + 24);
    if (v46 && !v49)
    {
      for (uint64_t i = 0; i != v46; ++i)
      {
        uint64_t result = BuildAndStoreHuffmanTree(v47, v122[0], 256, v23, (unsigned char *)(v156 + v122[0] * i), v157 + 2 * v122[0] * i, a14, a15);
        v47 += 1040;
      }
      int v49 = *(_DWORD *)(v98 + 24);
    }
    if (!v49)
    {
      unint64_t v52 = *(void *)(a13 + 192);
      uint64_t v51 = *(void *)(a13 + 200);
      if (v114[0] * v51)
      {
        unint64_t v120 = BrotliAllocate(v98);
        uint64_t result = BrotliAllocate(v98);
        int v53 = *(_DWORD *)(v98 + 24);
      }
      else
      {
        int v53 = 0;
        uint64_t result = 0;
        unint64_t v120 = 0;
      }
      unint64_t v121 = result;
      if (v51 && !v53)
      {
        for (uint64_t j = 0; j != v51; ++j)
        {
          uint64_t result = BuildAndStoreHuffmanTree(v52, v114[0], 704, v23, (unsigned char *)(v120 + v114[0] * j), v121 + 2 * v114[0] * j, a14, a15);
          v52 += 2832;
        }
        int v53 = *(_DWORD *)(v98 + 24);
      }
      if (!v53)
      {
        unint64_t v56 = *(void *)(a13 + 208);
        uint64_t v55 = *(void *)(a13 + 216);
        if (v106[0] * v55)
        {
          unint64_t v112 = BrotliAllocate(v98);
          uint64_t v57 = BrotliAllocate(v98);
          int v58 = *(_DWORD *)(v98 + 24);
        }
        else
        {
          int v58 = 0;
          uint64_t v57 = 0;
          unint64_t v112 = 0;
        }
        unint64_t v113 = v57;
        if (v55 && !v58)
        {
          for (uint64_t k = 0; k != v55; ++k)
          {
            BuildAndStoreHuffmanTree(v56, v106[0], v103, v23, (unsigned char *)(v112 + v106[0] * k), v113 + 2 * v106[0] * k, a14, a15);
            v56 += 2192;
          }
          int v58 = *(_DWORD *)(v98 + 24);
        }
        uint64_t result = v98;
        if (!v58)
        {
          BrotliFree(v98, v23);
          if (a12)
          {
            uint64_t v60 = 0;
            *(void *)unint64_t v104 = a6;
            uint64_t v61 = a7;
            do
            {
              uint64_t v102 = v60;
              unint64_t v62 = (unsigned int *)(a11 + 16 * v60);
              uint64_t v64 = *v62;
              unsigned int v63 = v62[1];
              uint64_t v65 = v62[2];
              unint64_t v66 = *((unsigned __int16 *)v62 + 7);
              unsigned int v96 = *((unsigned __int16 *)v62 + 6);
              StoreSymbol(v114, *((unsigned __int16 *)v62 + 6), v20, v19);
              LOWORD(v67) = v64;
              if (v64 >= 6)
              {
                if (v64 > 0x81)
                {
                  if (v64 > 0x841)
                  {
                    __int16 v69 = 22;
                    if (v64 >= 0x5842) {
                      __int16 v69 = 23;
                    }
                    LOWORD(v67) = 21;
                    if (v64 >> 1 >= 0xC21) {
                      LOWORD(v67) = v69;
                    }
                  }
                  else
                  {
                    LODWORD(v67) = (__clz(v64 - 66) ^ 0x1F) + 10;
                  }
                }
                else
                {
                  unsigned int v68 = (__clz(v64 - 2) ^ 0x1F) - 1;
                  unint64_t v67 = 2 * v68 + ((unint64_t)(v64 - 2) >> v68) + 2;
                }
              }
              uint64_t v70 = (v63 & 0x1FFFFFF) + (char)(HIBYTE(v63) & 0x80 | (v63 >> 25));
              unint64_t v95 = v66;
              uint64_t v100 = v63 & 0x1FFFFFF;
              if (v70 > 9)
              {
                uint64_t v72 = v97;
                if (v70 > 0x85)
                {
                  LODWORD(v71) = (__clz(v70 - 70) ^ 0x1F) + 12;
                  if (v70 > 0x845) {
                    LOWORD(v71) = 23;
                  }
                }
                else
                {
                  unsigned int v73 = (__clz(v70 - 6) ^ 0x1F) - 1;
                  unint64_t v71 = 2 * v73 + ((unint64_t)(v70 - 6) >> v73) + 4;
                }
              }
              else
              {
                LOWORD(v71) = v63 + (char)(HIBYTE(v63) & 0x80 | (v63 >> 25)) - 2;
                uint64_t v72 = v97;
              }
              uint64_t v74 = 4 * (unsigned __int16)v67;
              int v75 = *(_DWORD *)((char *)&kBrotliInsExtra + v74);
              uint64_t v76 = 4 * (unsigned __int16)v71;
              unint64_t v77 = ((unint64_t)(v70 - *(_DWORD *)((char *)&kBrotliCopyBase + v76)) << v75) | (v64 - *(_DWORD *)((char *)&kBrotliInsBase + v74));
              uint64_t v78 = (*(_DWORD *)((char *)&kBrotliCopyExtra + v76) + v75);
              unint64_t v79 = *v20;
              *(void *)(v19 + (*v20 >> 3)) = (v77 << (*(unsigned char *)v20 & 7)) | *(unsigned __int8 *)(v19 + (*v20 >> 3));
              *uint64_t v20 = v79 + v78;
              if (v24[19])
              {
                uint64_t v80 = v72;
                uint64_t v81 = v61;
                long long v82 = v20;
                unint64_t v83 = v24;
                uint64_t v84 = *(void *)v104;
                if (v64)
                {
                  do
                  {
                    uint64_t v81 = v84;
                    uint64_t v85 = (_kBrotliContextLookupTable[512 * a10 + 256 + v61] | _kBrotliContextLookupTable[512 * a10 + v84]);
                    uint64_t v84 = *(unsigned __int8 *)(a2 + (a3 & v80));
                    StoreSymbolWithContext(v122, v84, v85, v24[18], v82, a15, 6);
                    ++a3;
                    uint64_t v61 = v81;
                    --v64;
                  }
                  while (v64);
                }
              }
              else
              {
                if (v64)
                {
                  do
                  {
                    StoreSymbol(v122, *(unsigned __int8 *)(a2 + (a3++ & v72)), v20, v19);
                    --v64;
                  }
                  while (v64);
                }
                uint64_t v81 = v61;
                long long v82 = v20;
                unint64_t v83 = v24;
                uint64_t v84 = *(void *)v104;
              }
              *(void *)unint64_t v104 = v84;
              a3 += v100;
              uint64_t v24 = v83;
              uint64_t v20 = v82;
              uint64_t v19 = a15;
              if (v100)
              {
                uint64_t v81 = *(unsigned __int8 *)(a2 + ((a3 - 2) & v97));
                *(void *)unint64_t v104 = *(unsigned __int8 *)(a2 + ((a3 - 1) & v97));
                if (v96 >= 0x80)
                {
                  uint64_t v86 = v95 & 0x3FF;
                  if (v24[21])
                  {
                    unsigned int v87 = v96 >> 6;
                    if (v96 >> 6 != 4 && v87 != 2 && v87 != 7 || (v96 & 7) >= 3) {
                      uint64_t v91 = 3;
                    }
                    else {
                      uint64_t v91 = v96 & 7;
                    }
                    StoreSymbolWithContext(v106, v86, v91, v24[20], v20, a15, 2);
                  }
                  else
                  {
                    StoreSymbol(v106, v86, v20, a15);
                  }
                  unint64_t v92 = *v20;
                  *(void *)(a15 + (*v20 >> 3)) = (v65 << (*v20 & 7)) | *(unsigned __int8 *)(a15 + (*v20 >> 3));
                  *uint64_t v20 = v92 + (v95 >> 10);
                }
              }
              uint64_t v60 = v102 + 1;
              uint64_t v61 = v81;
            }
            while (v102 + 1 != a12);
          }
          BrotliFree(v98, v112);
          unint64_t v112 = 0;
          BrotliFree(v98, v113);
          unint64_t v113 = 0;
          BrotliFree(v98, v120);
          unint64_t v120 = 0;
          BrotliFree(v98, v121);
          unint64_t v121 = 0;
          BrotliFree(v98, v156);
          unint64_t v156 = 0;
          uint64_t result = BrotliFree(v98, v157);
          if (v94)
          {
            unsigned int v93 = *(_DWORD *)v20 + 7;
            *uint64_t v20 = v93 & 0xFFFFFFF8;
            *(unsigned char *)(v19 + (v93 >> 3)) = 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t StoreCompressedMetaBlockHeader(uint64_t result, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  unint64_t v4 = *a3;
  *(void *)(a4 + (*a3 >> 3)) = ((uint64_t)(int)result << (*(unsigned char *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
  unint64_t v5 = v4 + 1;
  *a3 = v4 + 1;
  if (result)
  {
    *(void *)(a4 + (v5 >> 3)) = *(unsigned __int8 *)(a4 + (v5 >> 3));
    *a3 = v4 + 2;
    if (a2 == 1 || (unsigned int v6 = __clz(a2 - 1) ^ 0x1F, v6 <= 0xE)) {
      uint64_t v7 = 4;
    }
    else {
      uint64_t v7 = (v6 + 4) >> 2;
    }
    *(void *)(a4 + ((v4 + 2) >> 3)) = ((v7 - 4) << ((v4 + 2) & 7)) | *(unsigned __int8 *)(a4 + ((v4 + 2) >> 3));
    unint64_t v10 = v4 + 4;
    *a3 = v10;
    *(void *)(a4 + (v10 >> 3)) = ((a2 - 1) << (v10 & 7)) | *(unsigned __int8 *)(a4 + (v10 >> 3));
    unint64_t v11 = v10 + 4 * v7;
  }
  else
  {
    if (a2 == 1 || (unsigned int v8 = __clz(a2 - 1) ^ 0x1F, v8 <= 0xE)) {
      uint64_t v9 = 4;
    }
    else {
      uint64_t v9 = (v8 + 4) >> 2;
    }
    *(void *)(a4 + (v5 >> 3)) = ((v9 - 4) << (v5 & 7)) | *(unsigned __int8 *)(a4 + (v5 >> 3));
    unint64_t v12 = v4 + 3;
    *a3 = v12;
    *(void *)(a4 + (v12 >> 3)) = ((a2 - 1) << (v12 & 7)) | *(unsigned __int8 *)(a4 + (v12 >> 3));
    unint64_t v13 = v12 + 4 * v9;
    *a3 = v13;
    *(void *)(a4 + (v13 >> 3)) = *(unsigned __int8 *)(a4 + (v13 >> 3));
    unint64_t v11 = v13 + 1;
  }
  *a3 = v11;
  return result;
}

unint64_t BuildAndStoreBlockSwitchEntropyCodes(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(unsigned int **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(unsigned __int8 **)(a1 + 16);
  bzero(v40, 4 * (v10 + 2));
  uint64_t v39 = 0;
  memset(v38, 0, sizeof(v38));
  if (v8)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 1;
    do
    {
      uint64_t v14 = v9[v11];
      if (v11)
      {
        if (v12 == v14) {
          uint64_t v15 = 0;
        }
        else {
          uint64_t v15 = v14 + 2;
        }
        if (v13 + 1 == v14) {
          uint64_t v15 = 1;
        }
        ++v40[v15];
      }
      unsigned int v16 = v7[v11];
      if (v16 <= 0x2F0) {
        uint64_t v17 = 14;
      }
      else {
        uint64_t v17 = 20;
      }
      if (v16 <= 0x28) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = 7;
      }
      if (v16 <= 0xB0) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v17;
      }
      uint64_t v20 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v19 + 4);
      do
      {
        unsigned int v21 = v19;
        if (v19 == 25) {
          break;
        }
        ++v19;
        unsigned int v22 = *v20;
        v20 += 2;
      }
      while (v16 >= v22);
      ++*((_DWORD *)v38 + v21);
      ++v11;
      uint64_t v12 = v13;
      uint64_t v13 = v14;
    }
    while (v11 != v8);
  }
  unint64_t result = StoreVarLenUint8(v10 - 1, a3, a4);
  if (v10 >= 2)
  {
    BuildAndStoreHuffmanTree((unint64_t)v40, v10 + 2, v10 + 2, a2, (unsigned char *)(a1 + 56), a1 + 314, a3, a4);
    unint64_t result = BuildAndStoreHuffmanTree((unint64_t)v38, 0x1AuLL, 26, a2, (unsigned char *)(a1 + 830), a1 + 856, a3, a4);
    unsigned int v24 = *v7;
    uint64_t v25 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = *v9;
    *(void *)(a1 + 48) = v25;
    uint64_t v26 = 14;
    if (v24 > 0x2F0) {
      uint64_t v26 = 20;
    }
    uint64_t v27 = 7;
    if (v24 <= 0x28) {
      uint64_t v27 = 0;
    }
    if (v24 <= 0xB0) {
      uint64_t v28 = v27;
    }
    else {
      uint64_t v28 = v26;
    }
    uint64_t v29 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v28 + 4);
    do
    {
      unsigned int v30 = v28;
      if (v28 == 25) {
        break;
      }
      ++v28;
      unsigned int v31 = *v29;
      v29 += 2;
    }
    while (v24 >= v31);
    size_t v32 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v30);
    uint64_t v33 = *((unsigned __int8 *)v32 + 2);
    uint64_t v34 = v24 - *v32;
    uint64_t v35 = *(unsigned __int8 *)(a1 + 40 + v30 + 790);
    unint64_t v36 = *a3;
    *(void *)(a4 + (*a3 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a1 + 40 + 2 * v30 + 816) << (*(unsigned char *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
    *a3 = v36 + v35;
    *(void *)(a4 + ((v36 + v35) >> 3)) = (v34 << ((v36 + v35) & 7)) | *(unsigned __int8 *)(a4 + ((v36 + v35) >> 3));
    *a3 = v36 + v35 + v33;
  }
  return result;
}

unint64_t StoreTrivialContextMap(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  unint64_t result = StoreVarLenUint8(a1 - 1, a4, a5);
  if (a1 >= 2)
  {
    unint64_t v11 = a2 - 1;
    unint64_t v12 = a2 - 1 + a1;
    bzero(v24, 4 * v12);
    unint64_t v13 = *a4;
    *(void *)(a5 + (*a4 >> 3)) = (1 << (*a4 & 7)) | *(unsigned __int8 *)(a5 + (*a4 >> 3));
    *a4 = v13 + 1;
    *(void *)(a5 + ((v13 + 1) >> 3)) = ((a2 - 2) << ((v13 + 1) & 7)) | *(unsigned __int8 *)(a5 + ((v13 + 1) >> 3));
    *a4 = v13 + 5;
    v24[a2 - 1] = a1;
    v24[0] = 1;
    if (v12 > a2) {
      memset_pattern16(&v24[a2], &unk_20DAD62E0, 4 * a1 - 4);
    }
    unint64_t result = BuildAndStoreHuffmanTree((unint64_t)v24, a2 - 1 + a1, a2 - 1 + a1, a3, v23, (uint64_t)v22, a4, a5);
    uint64_t v14 = 0;
    uint64_t v15 = v23[v11];
    uint64_t v16 = (unsigned __int16)v22[v11];
    unint64_t v17 = *a4;
    do
    {
      uint64_t v18 = v11 + v14;
      if (!v14) {
        uint64_t v18 = 0;
      }
      uint64_t v19 = v23[v18];
      *(void *)(a5 + (v17 >> 3)) = ((unint64_t)(unsigned __int16)v22[v18] << (v17 & 7)) | *(unsigned __int8 *)(a5 + (v17 >> 3));
      unint64_t v20 = v17 + v19;
      *a4 = v20;
      *(void *)(a5 + (v20 >> 3)) = (v16 << (v20 & 7)) | *(unsigned __int8 *)(a5 + (v20 >> 3));
      uint64_t v21 = v20 + v15;
      *a4 = v20 + v15;
      *(void *)(a5 + ((v20 + v15) >> 3)) = ((unint64_t)~(-1 << (a2 - 1)) << ((v20 + v15) & 7)) | *(unsigned __int8 *)(a5 + ((v20 + v15) >> 3));
      unint64_t v17 = v21 + v11;
      *a4 = v21 + v11;
      ++v14;
    }
    while (a1 != v14);
    *(void *)(a5 + (v17 >> 3)) = (1 << (v17 & 7)) | *(unsigned __int8 *)(a5 + (v17 >> 3));
    *a4 = v21 + a2;
  }
  return result;
}

uint64_t EncodeContextMap(uint64_t a1, unsigned int *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v10 = a4;
  *(void *)&v59[1087] = *MEMORY[0x263EF8340];
  uint64_t result = StoreVarLenUint8(a4 - 1, a6, a7);
  if (v10 == 1) {
    return result;
  }
  uint64_t result = BrotliAllocate(a1);
  if (*(_DWORD *)(a1 + 24)) {
    return result;
  }
  unint64_t v15 = result;
  unsigned int v16 = *a2;
  if (a3 >= 2)
  {
    unint64_t v17 = a3 - 1;
    uint64_t v18 = a2 + 1;
    do
    {
      unsigned int v20 = *v18++;
      unsigned int v19 = v20;
      if (v20 > v16) {
        unsigned int v16 = v19;
      }
      --v17;
    }
    while (v17);
  }
  uint64_t v21 = 0;
  do
  {
    v59[v21 - 1] = v21;
    ++v21;
  }
  while (v16 + 1 != v21);
  if (!a3) {
    goto LABEL_44;
  }
  uint64_t v53 = v10;
  uint64_t v54 = a5;
  uint64_t v55 = a1;
  uint64_t v22 = 0;
  size_t v23 = v16 + 1;
  LOBYTE(a1) = __src;
  do
  {
    if (v23)
    {
      size_t v24 = 0;
      LODWORD(a1) = LOBYTE(a2[v22]);
      while (v59[v24 - 1] != a1)
      {
        if (v23 == ++v24)
        {
          LOBYTE(a1) = v59[v23 - 1];
          size_t v24 = v23;
          break;
        }
      }
      *(_DWORD *)(v15 + 4 * v22) = v24;
      if (v24) {
        memmove(v59, &__src, v24);
      }
    }
    else
    {
      *(_DWORD *)(v15 + 4 * v22) = 0;
    }
    char __src = a1;
    ++v22;
  }
  while (v22 != a3);
  unsigned int v25 = 0;
  unint64_t v26 = 0;
  a5 = v54;
  a1 = v55;
  uint64_t v10 = v53;
  do
  {
    if (a3 <= v26 + 1) {
      unint64_t v27 = v26 + 1;
    }
    else {
      unint64_t v27 = a3;
    }
    uint64_t v28 = (_DWORD *)(v15 + 4 * v26);
    while (*(_DWORD *)(v15 + 4 * v26))
    {
      ++v26;
      ++v28;
      if (v27 == v26)
      {
        unsigned int v32 = 0;
LABEL_40:
        if (v32 > v25) {
          unsigned int v25 = v32;
        }
        goto LABEL_42;
      }
    }
    if (a3 <= v26)
    {
      unsigned int v31 = 0;
    }
    else
    {
      uint64_t v29 = 0;
      while (!*v28++)
      {
        if (v26 - a3 == --v29)
        {
          unsigned int v32 = a3 - v26;
          goto LABEL_40;
        }
      }
      v26 -= v29;
      unsigned int v31 = -(int)v29;
    }
    if (v31 > v25) {
      unsigned int v25 = v31;
    }
  }
  while (v26 < a3);
LABEL_42:
  if (v25) {
    unsigned int v33 = __clz(v25) ^ 0x1F;
  }
  else {
LABEL_44:
  }
    unsigned int v33 = 0;
  if (v33 >= 6) {
    unsigned int v34 = 6;
  }
  else {
    unsigned int v34 = v33;
  }
  if (!a3)
  {
    bzero(&__src, 0x440uLL);
    uint64_t v35 = 0;
LABEL_72:
    BOOL v43 = 1;
    goto LABEL_73;
  }
  uint64_t v35 = 0;
  unint64_t v36 = 0;
  unsigned int v37 = 2 << v34;
  do
  {
    int v38 = *(_DWORD *)(v15 + 4 * v36);
    if (v38)
    {
      *(_DWORD *)(v15 + 4 * v35) = v38 + v34;
      ++v36;
LABEL_52:
      ++v35;
      continue;
    }
    if (v36 + 1 >= a3)
    {
      unsigned int v39 = 1;
      ++v36;
      goto LABEL_63;
    }
    unsigned int v39 = a3 - v36;
    uint64_t v40 = 1;
    while (!*(_DWORD *)(v15 + 4 * v36 + 4 * v40))
    {
      if (a3 - v36 == ++v40) {
        goto LABEL_62;
      }
    }
    unsigned int v39 = v40;
LABEL_62:
    v36 += v39;
    if (v39)
    {
LABEL_63:
      while (1)
      {
        unsigned int v41 = v39 - v37;
        if (v39 < v37) {
          break;
        }
        *(_DWORD *)(v15 + 4 * v35++) = v34 | (~(-1 << v34) << 9);
        unsigned int v39 = v41 + 1;
        if (v41 == -1) {
          goto LABEL_53;
        }
      }
      unsigned int v42 = __clz(v39);
      *(_DWORD *)(v15 + 4 * v35) = v42 ^ 0x1F | (((-1 << (v42 ^ 0x1F)) + v39) << 9);
      goto LABEL_52;
    }
LABEL_53:
    ;
  }
  while (v36 < a3);
  bzero(&__src, 0x440uLL);
  BOOL v43 = v35 == 0;
  if (!v35) {
    goto LABEL_72;
  }
  for (uint64_t i = 0; i != v35; ++i)
  {
    uint64_t v45 = *(_DWORD *)(v15 + 4 * i) & 0x1FF;
    ++*(_DWORD *)&v59[4 * v45 - 1];
  }
LABEL_73:
  unint64_t v46 = *a6;
  *(void *)(a7 + (*a6 >> 3)) = ((unint64_t)(v34 != 0) << (*(unsigned char *)a6 & 7)) | *(unsigned __int8 *)(a7 + (*a6 >> 3));
  *a6 = v46 + 1;
  if (v34)
  {
    *(void *)(a7 + ((v46 + 1) >> 3)) = ((unint64_t)(v34 - 1) << ((v46 + 1) & 7)) | *(unsigned __int8 *)(a7 + ((v46 + 1) >> 3));
    *a6 = v46 + 5;
  }
  BuildAndStoreHuffmanTree((unint64_t)&__src, v10 + v34, v10 + v34, a5, v57, (uint64_t)v56, a6, a7);
  unint64_t v47 = *a6;
  if (!v43)
  {
    uint64_t v48 = (unsigned int *)v15;
    do
    {
      unsigned int v50 = *v48++;
      unint64_t v49 = v50;
      uint64_t v51 = v50 & 0x1FF;
      uint64_t v52 = v57[v51];
      *(void *)(a7 + (v47 >> 3)) = ((unint64_t)(unsigned __int16)v56[v51] << (v47 & 7)) | *(unsigned __int8 *)(a7 + (v47 >> 3));
      v47 += v52;
      *a6 = v47;
      if ((int)v51 - 1 < v34)
      {
        *(void *)(a7 + (v47 >> 3)) = (v49 >> 9 << (v47 & 7)) | *(unsigned __int8 *)(a7 + (v47 >> 3));
        v47 += v51;
        *a6 = v47;
      }
      --v35;
    }
    while (v35);
  }
  *(void *)(a7 + (v47 >> 3)) = (1 << (v47 & 7)) | *(unsigned __int8 *)(a7 + (v47 >> 3));
  *a6 = v47 + 1;
  return BrotliFree(a1, v15);
}

void *StoreSymbol(void *result, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4 = result[115];
  if (!v4)
  {
    uint64_t v5 = result[114] + 1;
    result[114] = v5;
    uint64_t v6 = *(unsigned int *)(result[3] + 4 * v5);
    uint64_t v7 = *(unsigned __int8 *)(result[2] + v5);
    result[115] = v6;
    result[116] = *result * v7;
    uint64_t v8 = result[5];
    if (v8 + 1 == v7)
    {
      uint64_t v9 = 1;
    }
    else if (result[6] == v7)
    {
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v9 = v7 + 2;
    }
    result[5] = v7;
    result[6] = v8;
    uint64_t v10 = *((unsigned __int8 *)result + v9 + 56);
    uint64_t v11 = *((unsigned __int16 *)result + v9 + 157);
    unint64_t v12 = *a3;
    *(void *)(a4 + (*a3 >> 3)) = (v11 << (*(unsigned char *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
    unint64_t v13 = v12 + v10;
    *a3 = v13;
    uint64_t v14 = 14;
    if (v6 > 0x2F0) {
      uint64_t v14 = 20;
    }
    uint64_t v15 = 7;
    if (v6 <= 0x28) {
      uint64_t v15 = 0;
    }
    if (v6 <= 0xB0) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v14;
    }
    unint64_t v17 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v16 + 4);
    do
    {
      unsigned int v18 = v16;
      if (v16 == 25) {
        break;
      }
      ++v16;
      unsigned int v19 = *v17;
      v17 += 2;
    }
    while (v6 >= v19);
    unsigned int v20 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v18);
    uint64_t v21 = *((unsigned __int8 *)v20 + 2);
    uint64_t v22 = v6 - *v20;
    uint64_t v23 = *((unsigned __int8 *)result + v18 + 830);
    *(void *)(a4 + (v13 >> 3)) = ((unint64_t)*((unsigned __int16 *)result + v18 + 428) << (v13 & 7)) | *(unsigned __int8 *)(a4 + (v13 >> 3));
    unint64_t v24 = v13 + v23;
    *a3 = v24;
    *(void *)(a4 + (v24 >> 3)) = (v22 << (v24 & 7)) | *(unsigned __int8 *)(a4 + (v24 >> 3));
    *a3 = v24 + v21;
    uint64_t v4 = result[115];
  }
  result[115] = v4 - 1;
  uint64_t v25 = result[116] + a2;
  uint64_t v26 = *(unsigned __int8 *)(result[117] + v25);
  unint64_t v27 = *a3;
  *(void *)(a4 + (*a3 >> 3)) = ((unint64_t)*(unsigned __int16 *)(result[118] + 2 * v25) << (*(unsigned char *)a3 & 7)) | *(unsigned __int8 *)(a4 + (*a3 >> 3));
  *a3 = v27 + v26;
  return result;
}

void *StoreSymbolWithContext(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, char a7)
{
  uint64_t v7 = result[115];
  if (!v7)
  {
    uint64_t v8 = result[114] + 1;
    result[114] = v8;
    uint64_t v9 = *(unsigned int *)(result[3] + 4 * v8);
    uint64_t v10 = *(unsigned __int8 *)(result[2] + v8);
    result[115] = v9;
    result[116] = v10 << a7;
    uint64_t v11 = result[5];
    if (v11 + 1 == v10)
    {
      uint64_t v12 = 1;
    }
    else if (result[6] == v10)
    {
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v12 = v10 + 2;
    }
    result[5] = v10;
    result[6] = v11;
    uint64_t v13 = *((unsigned __int8 *)result + v12 + 56);
    uint64_t v14 = *((unsigned __int16 *)result + v12 + 157);
    unint64_t v15 = *a5;
    *(void *)(a6 + (*a5 >> 3)) = (v14 << (*(unsigned char *)a5 & 7)) | *(unsigned __int8 *)(a6 + (*a5 >> 3));
    unint64_t v16 = v15 + v13;
    *a5 = v16;
    uint64_t v17 = 14;
    if (v9 > 0x2F0) {
      uint64_t v17 = 20;
    }
    uint64_t v18 = 7;
    if (v9 <= 0x28) {
      uint64_t v18 = 0;
    }
    if (v9 <= 0xB0) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v17;
    }
    unsigned int v20 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v19 + 4);
    do
    {
      unsigned int v21 = v19;
      if (v19 == 25) {
        break;
      }
      ++v19;
      unsigned int v22 = *v20;
      v20 += 2;
    }
    while (v9 >= v22);
    uint64_t v23 = (unsigned __int16 *)((char *)&_kBrotliPrefixCodeRanges + 4 * v21);
    uint64_t v24 = *((unsigned __int8 *)v23 + 2);
    uint64_t v25 = v9 - *v23;
    uint64_t v26 = *((unsigned __int8 *)result + v21 + 830);
    *(void *)(a6 + (v16 >> 3)) = ((unint64_t)*((unsigned __int16 *)result + v21 + 428) << (v16 & 7)) | *(unsigned __int8 *)(a6 + (v16 >> 3));
    unint64_t v27 = v16 + v26;
    *a5 = v27;
    *(void *)(a6 + (v27 >> 3)) = (v25 << (v27 & 7)) | *(unsigned __int8 *)(a6 + (v27 >> 3));
    *a5 = v27 + v24;
    uint64_t v7 = result[115];
  }
  result[115] = v7 - 1;
  uint64_t v28 = a2 + *result * *(unsigned int *)(a4 + 4 * (result[116] + a3));
  uint64_t v29 = *(unsigned __int8 *)(result[117] + v28);
  unint64_t v30 = *a5;
  *(void *)(a6 + (*a5 >> 3)) = ((unint64_t)*(unsigned __int16 *)(result[118] + 2 * v28) << (*(unsigned char *)a5 & 7)) | *(unsigned __int8 *)(a6 + (*a5 >> 3));
  *a5 = v30 + v29;
  return result;
}

uint64_t BrotliStoreMetaBlockTrivial(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x270FA5388]();
  uint64_t v13 = v12;
  int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  uint64_t v21 = v20;
  uint64_t v22 = v11;
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v29 = *(unsigned int *)(v23 + 72);
  StoreCompressedMetaBlockHeader(v14, v24, a10, a11);
  bzero(v34, 0x408uLL);
  v34[129] = 0x7FF0000000000000;
  bzero(v32, 0xB08uLL);
  uint64_t v33 = 0x7FF0000000000000;
  bzero(v30, 0x888uLL);
  uint64_t v31 = 0x7FF0000000000000;
  BuildHistograms(v21, v19, v17, v13, a9, (uint64_t)v34, (uint64_t)v32, (uint64_t)v30);
  unint64_t v25 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v25 + 13;
  uint64_t result = BrotliAllocate(v22);
  if (!*(_DWORD *)(v22 + 24))
  {
    unint64_t v27 = result;
    BuildAndStoreHuffmanTree((unint64_t)v34, 0x100uLL, 256, result, v40, (uint64_t)v39, a10, a11);
    BuildAndStoreHuffmanTree((unint64_t)v32, 0x2C0uLL, 704, v27, v38, (uint64_t)v37, a10, a11);
    BuildAndStoreHuffmanTree((unint64_t)v30, 0x8CuLL, v29, v27, v36, (uint64_t)v35, a10, a11);
    BrotliFree(v22, v27);
    uint64_t result = StoreDataWithHuffmanCodes(v21, v19, v17, v13, a9, (uint64_t)v40, (uint64_t)v39, (uint64_t)v38, (uint64_t)v37, (uint64_t)v36, (uint64_t)v35, a10, a11);
    if (v15)
    {
      unsigned int v28 = *(_DWORD *)a10 + 7;
      *a10 = v28 & 0xFFFFFFF8;
      *(unsigned char *)(a11 + (v28 >> 3)) = 0;
    }
  }
  return result;
}

uint64_t BuildHistograms(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a7 + 2816);
    do
    {
      uint64_t v10 = (unsigned int *)(a4 + 16 * v8);
      uint64_t v12 = *v10;
      unsigned int v11 = v10[1];
      uint64_t v13 = *((unsigned __int16 *)v10 + 6);
      __int16 v14 = *((_WORD *)v10 + 7);
      ++*(_DWORD *)(a7 + 4 * v13);
      *(void *)(a7 + 2816) = ++v9;
      if (v12)
      {
        uint64_t v15 = *(void *)(a6 + 1024) + 1;
        do
        {
          ++*(_DWORD *)(a6 + 4 * *(unsigned __int8 *)(result + (a2 & a3)));
          *(void *)(a6 + 1024) = v15;
          ++a2;
          ++v15;
          --v12;
        }
        while (v12);
      }
      uint64_t v16 = v11 & 0x1FFFFFF;
      if (v16)
      {
        if (v13 >= 0x80)
        {
          ++*(_DWORD *)(a8 + 4 * (v14 & 0x3FF));
          ++*(void *)(a8 + 2176);
        }
      }
      a2 += v16;
      ++v8;
    }
    while (v8 != a5);
  }
  return result;
}

unint64_t BuildAndStoreHuffmanTree(unint64_t result, size_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v14 = result;
  uint64_t v46 = *MEMORY[0x263EF8340];
  long long v44 = 0u;
  long long v45 = 0u;
  if (a2)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    do
    {
      if (*(_DWORD *)(result + 4 * v15))
      {
        if (v16 > 3)
        {
          if (v16 != 4) {
            break;
          }
        }
        else
        {
          *((void *)&v44 + v16) = v15;
        }
        ++v16;
      }
      ++v15;
    }
    while (a2 != v15);
  }
  else
  {
    unint64_t v16 = 0;
  }
  uint64_t v17 = 0;
  unint64_t v18 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      ++v17;
      BOOL v19 = v18 > 1;
      v18 >>= 1;
    }
    while (v19);
  }
  unint64_t v20 = v16 - 1;
  if (v16 <= 1)
  {
    unint64_t v21 = *a7;
    *(void *)(a8 + (*a7 >> 3)) = (1 << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
    v21 += 4;
    *a7 = v21;
    uint64_t v22 = v44;
    *(void *)(a8 + (v21 >> 3)) = ((void)v44 << (v21 & 7)) | *(unsigned __int8 *)(a8 + (v21 >> 3));
    *a7 = v21 + v17;
    a5[v22] = 0;
    *(_WORD *)(a6 + 2 * v22) = 0;
    return result;
  }
  bzero(a5, a2);
  BrotliCreateHuffmanTree(v14, a2, 15, a4, (uint64_t)a5);
  uint64_t result = (unint64_t)BrotliConvertBitDepthsToSymbols(a5, a2, a6);
  if (v16 <= 4)
  {
    uint64_t v23 = 0;
    unint64_t v24 = *a7;
    *(void *)(a8 + (*a7 >> 3)) = (1 << (*a7 & 7)) | *(unsigned __int8 *)(a8 + (*a7 >> 3));
    *a7 = v24 + 2;
    *(void *)(a8 + ((v24 + 2) >> 3)) = (v20 << ((v24 + 2) & 7)) | *(unsigned __int8 *)(a8 + ((v24 + 2) >> 3));
    unint64_t v25 = v24 + 4;
    *a7 = v25;
    uint64_t v26 = (char *)&v44 + 8;
    do
    {
      uint64_t v27 = v23 + 1;
      if (v23 + 1 < v16)
      {
        uint64_t v28 = *((void *)&v44 + v23);
        uint64_t v29 = (uint64_t *)v26;
        unint64_t v30 = v20;
        do
        {
          uint64_t v31 = *v29;
          uint64_t result = a5[v28];
          if (a5[*v29] < result)
          {
            *uint64_t v29 = v28;
            *((void *)&v44 + v23) = v31;
            uint64_t v28 = v31;
          }
          ++v29;
          --v30;
        }
        while (v30);
      }
      --v20;
      v26 += 8;
      ++v23;
    }
    while (v27 != v16);
    unint64_t v32 = v25 >> 3;
    if (v16 == 3)
    {
      uint64_t v35 = *((void *)&v44 + 1);
      *(void *)(a8 + v32) = ((void)v44 << (v25 & 7)) | *(unsigned __int8 *)(a8 + v32);
      unint64_t v36 = v25 + v17;
      *a7 = v36;
      *(void *)(a8 + (v36 >> 3)) = (v35 << (v36 & 7)) | *(unsigned __int8 *)(a8 + (v36 >> 3));
      unint64_t v34 = v36 + v17;
      *a7 = v34;
      *(void *)(a8 + (v34 >> 3)) = ((void)v45 << (v34 & 7)) | *(unsigned __int8 *)(a8 + (v34 >> 3));
    }
    else
    {
      if (v16 != 2)
      {
        long long v38 = v44;
        *(void *)(a8 + v32) = ((void)v44 << (v25 & 7)) | *(unsigned __int8 *)(a8 + v32);
        unint64_t v39 = v25 + v17;
        *a7 = v39;
        *(void *)(a8 + (v39 >> 3)) = (*((void *)&v38 + 1) << (v39 & 7)) | *(unsigned __int8 *)(a8 + (v39 >> 3));
        unint64_t v40 = v39 + v17;
        *a7 = v40;
        uint64_t v41 = *((void *)&v45 + 1);
        *(void *)(a8 + (v40 >> 3)) = ((void)v45 << (v40 & 7)) | *(unsigned __int8 *)(a8 + (v40 >> 3));
        unint64_t v42 = v40 + v17;
        *a7 = v42;
        *(void *)(a8 + (v42 >> 3)) = (v41 << (v42 & 7)) | *(unsigned __int8 *)(a8 + (v42 >> 3));
        unint64_t v43 = v42 + v17;
        *a7 = v43;
        *(void *)(a8 + (v43 >> 3)) = ((unint64_t)(a5[v38] == 1) << (v43 & 7)) | *(unsigned __int8 *)(a8 + (v43 >> 3));
        unint64_t v37 = v43 + 1;
        goto LABEL_32;
      }
      uint64_t v33 = *((void *)&v44 + 1);
      *(void *)(a8 + v32) = ((void)v44 << (v25 & 7)) | *(unsigned __int8 *)(a8 + v32);
      unint64_t v34 = v25 + v17;
      *a7 = v34;
      *(void *)(a8 + (v34 >> 3)) = (v33 << (v34 & 7)) | *(unsigned __int8 *)(a8 + (v34 >> 3));
    }
    unint64_t v37 = v34 + v17;
LABEL_32:
    *a7 = v37;
    return result;
  }

  return BrotliStoreHuffmanTree((uint64_t)a5, a2, a4, a7, a8);
}

uint64_t StoreDataWithHuffmanCodes(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t *a12, uint64_t a13)
{
  if (a5)
  {
    uint64_t v13 = 0;
    unint64_t v14 = *a12;
    do
    {
      uint64_t v15 = (unsigned int *)(a4 + 16 * v13);
      uint64_t v16 = *v15;
      unsigned int v17 = v15[1];
      uint64_t v18 = v15[2];
      uint64_t v19 = *((unsigned __int16 *)v15 + 6);
      unint64_t v20 = *((unsigned __int16 *)v15 + 7);
      uint64_t v21 = *(unsigned __int8 *)(a8 + v19);
      *(void *)(a13 + (v14 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a9 + 2 * v19) << (v14 & 7)) | *(unsigned __int8 *)(a13 + (v14 >> 3));
      unint64_t v22 = v14 + v21;
      *a12 = v22;
      LOWORD(v23) = v16;
      if (v16 >= 6)
      {
        if (v16 > 0x81)
        {
          if (v16 > 0x841)
          {
            if (v16 >> 1 >= 0xC21)
            {
              if (v16 < 0x5842) {
                LOWORD(v23) = 22;
              }
              else {
                LOWORD(v23) = 23;
              }
            }
            else
            {
              LOWORD(v23) = 21;
            }
          }
          else
          {
            LODWORD(v23) = (__clz(v16 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v24 = (__clz(v16 - 2) ^ 0x1F) - 1;
          unint64_t v23 = 2 * v24 + ((unint64_t)(v16 - 2) >> v24) + 2;
        }
      }
      int v25 = HIBYTE(v17) & 0x80 | (v17 >> 25);
      uint64_t v26 = v17 & 0x1FFFFFF;
      uint64_t v27 = (v26 + (char)v25);
      if (v27 > 9)
      {
        if (v27 > 0x85)
        {
          unsigned int v30 = (__clz(v27 - 70) ^ 0x1F) + 12;
          if (v27 <= 0x845) {
            LOWORD(v28) = v30;
          }
          else {
            LOWORD(v28) = 23;
          }
        }
        else
        {
          unsigned int v29 = (__clz(v27 - 6) ^ 0x1F) - 1;
          unint64_t v28 = 2 * v29 + ((unint64_t)(v27 - 6) >> v29) + 4;
        }
      }
      else
      {
        LOWORD(v28) = v26 + (char)v25 - 2;
      }
      uint64_t v31 = 4 * (unsigned __int16)v23;
      int v32 = *(_DWORD *)((char *)&kBrotliInsExtra + v31);
      uint64_t v33 = 4 * (unsigned __int16)v28;
      unint64_t v34 = ((unint64_t)(v27 - *(_DWORD *)((char *)&kBrotliCopyBase + v33)) << v32) | (v16 - *(_DWORD *)((char *)&kBrotliInsBase + v31));
      uint64_t v35 = (*(_DWORD *)((char *)&kBrotliCopyExtra + v33) + v32);
      *(void *)(a13 + (v22 >> 3)) = (v34 << (v22 & 7)) | *(unsigned __int8 *)(a13 + (v22 >> 3));
      unint64_t v14 = v22 + v35;
      *a12 = v14;
      if (v16)
      {
        do
        {
          uint64_t v36 = *(unsigned __int8 *)(result + (a2 & a3));
          uint64_t v37 = *(unsigned __int8 *)(a6 + v36);
          *(void *)(a13 + (v14 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a7 + 2 * v36) << (v14 & 7)) | *(unsigned __int8 *)(a13 + (v14 >> 3));
          v14 += v37;
          *a12 = v14;
          ++a2;
          --v16;
        }
        while (v16);
      }
      if (v26)
      {
        if (v19 >= 0x80)
        {
          uint64_t v38 = *(unsigned __int8 *)(a10 + (v20 & 0x3FF));
          *(void *)(a13 + (v14 >> 3)) = ((unint64_t)*(unsigned __int16 *)(a11 + 2 * (v20 & 0x3FF)) << (v14 & 7)) | *(unsigned __int8 *)(a13 + (v14 >> 3));
          *a12 = v14 + v38;
          *(void *)(a13 + ((v14 + v38) >> 3)) = (v18 << ((v14 + v38) & 7)) | *(unsigned __int8 *)(a13
                                                                                                  + ((v14 + v38) >> 3));
          v14 += v38 + (v20 >> 10);
          *a12 = v14;
        }
      }
      a2 += v26;
      ++v13;
    }
    while (v13 != a5);
  }
  return result;
}

unint64_t BrotliStoreMetaBlockFast(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t *a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x270FA5388]();
  uint64_t v13 = v12;
  int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  uint64_t v21 = v20;
  unint64_t v22 = v11;
  uint64_t v51 = *MEMORY[0x263EF8340];
  int v24 = *(_DWORD *)(v23 + 72);
  StoreCompressedMetaBlockHeader(v14, v25, a10, a11);
  unint64_t v26 = *a10;
  *(void *)(a11 + (*a10 >> 3)) = *(unsigned __int8 *)(a11 + (*a10 >> 3));
  *a10 = v26 + 13;
  if (a9 > 0x80)
  {
    bzero(v36, 0x408uLL);
    uint64_t v38 = 0x7FF0000000000000;
    bzero(v48, 0xB08uLL);
    uint64_t v50 = 0x7FF0000000000000;
    bzero(v45, 0x888uLL);
    uint64_t v47 = 0x7FF0000000000000;
    BuildHistograms(v21, v19, v17, v13, a9, (uint64_t)v36, (uint64_t)v48, (uint64_t)v45);
    unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v22, (uint64_t)v36, *(uint64_t *)v37, 8, v44, (uint64_t)v43, a10, a11);
    if (!*(_DWORD *)(v22 + 24))
    {
      unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v22, (uint64_t)v48, *(uint64_t *)v49, 10, v42, (uint64_t)v41, a10, a11);
      if (!*(_DWORD *)(v22 + 24))
      {
        unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v22, (uint64_t)v45, *(uint64_t *)v46, (__clz(v24 - 1) ^ 0x1F) + 1, v40, (uint64_t)v39, a10, a11);
        if (!*(_DWORD *)(v22 + 24))
        {
          unint64_t result = StoreDataWithHuffmanCodes(v21, v19, v17, v13, a9, (uint64_t)v44, (uint64_t)v43, (uint64_t)v42, (uint64_t)v41, (uint64_t)v40, (uint64_t)v39, a10, a11);
          goto LABEL_16;
        }
      }
    }
  }
  else
  {
    bzero(v48, 0x400uLL);
    if (a9)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      uint64_t v29 = v19;
      do
      {
        unsigned int v30 = (unsigned int *)(v13 + 16 * v27);
        uint64_t v31 = *v30;
        if (v31)
        {
          uint64_t v32 = *v30;
          do
          {
            ++v48[*(unsigned __int8 *)(v21 + (v29++ & v17))];
            --v32;
          }
          while (v32);
        }
        v28 += v31;
        v29 += v30[1] & 0x1FFFFFF;
        ++v27;
      }
      while (v27 != a9);
    }
    else
    {
      uint64_t v28 = 0;
    }
    unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v22, (uint64_t)v48, v28, 8, v41, (uint64_t)v45, a10, a11);
    if (!*(_DWORD *)(v22 + 24))
    {
      unint64_t v34 = *a10;
      *(void *)(a11 + (*a10 >> 3)) = (0x92624416307003 << (*a10 & 7)) | *(unsigned __int8 *)(a11 + (*a10 >> 3));
      *a10 = v34 + 56;
      *(void *)(a11 + ((v34 + 56) >> 3)) = *(unsigned __int8 *)(a11 + ((v34 + 56) >> 3));
      *a10 = v34 + 59;
      *(void *)(a11 + ((v34 + 59) >> 3)) = (57269251 << ((v34 + 59) & 7)) | *(unsigned __int8 *)(a11 + ((v34 + 59) >> 3));
      *a10 = v34 + 87;
      unint64_t result = StoreDataWithHuffmanCodes(v21, v19, v17, v13, a9, (uint64_t)v41, (uint64_t)v45, (uint64_t)&kStaticCommandCodeDepth, (uint64_t)&kStaticCommandCodeBits, (uint64_t)&kStaticDistanceCodeDepth, (uint64_t)&kStaticDistanceCodeBits, a10, a11);
LABEL_16:
      if (v15)
      {
        unsigned int v35 = *(_DWORD *)a10 + 7;
        *a10 = v35 & 0xFFFFFFF8;
        *(unsigned char *)(a11 + (v35 >> 3)) = 0;
      }
    }
  }
  return result;
}

void *BrotliStoreUncompressedMetaBlock(int a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, uint64_t *a6, uint64_t a7)
{
  size_t v9 = a5;
  uint64_t v12 = a4 & a3;
  uint64_t v13 = *a6;
  *(void *)(a7 + ((unint64_t)*a6 >> 3)) = *(unsigned __int8 *)(a7 + ((unint64_t)*a6 >> 3));
  if (a5 == 1 || (unsigned int v14 = __clz(a5 - 1) ^ 0x1F, v14 <= 0xE)) {
    uint64_t v15 = 4;
  }
  else {
    uint64_t v15 = (v14 + 4) >> 2;
  }
  *(void *)(a7 + ((unint64_t)(v13 + 1) >> 3)) = ((v15 - 4) << ((v13 + 1) & 7)) | *(unsigned __int8 *)(a7 + ((unint64_t)(v13 + 1) >> 3));
  unint64_t v16 = v13 + 3;
  *(void *)(a7 + (v16 >> 3)) = ((a5 - 1) << (v16 & 7)) | *(unsigned __int8 *)(a7 + (v16 >> 3));
  unint64_t v17 = v16 + 4 * v15;
  *(void *)(a7 + (v17 >> 3)) = (1 << (v17 & 7)) | *(unsigned __int8 *)(a7 + (v17 >> 3));
  unsigned int v18 = v17 + 8;
  unint64_t v19 = v18 & 0xFFFFFFF8;
  uint64_t v20 = (unsigned char *)(a7 + (v19 >> 3));
  *uint64_t v20 = 0;
  uint64_t v21 = a4 + 1;
  if (v12 + a5 <= a4 + 1)
  {
    unint64_t v23 = v18 >> 3;
  }
  else
  {
    uint64_t v22 = v21 - v12;
    memcpy(v20, (const void *)(a2 + v12), v21 - v12);
    uint64_t v12 = 0;
    v19 += 8 * v22;
    v9 -= v22;
    unint64_t v23 = v19 >> 3;
  }
  unint64_t result = memcpy((void *)(a7 + v23), (const void *)(a2 + v12), v9);
  size_t v25 = v19 + 8 * v9;
  *a6 = v25;
  *(unsigned char *)(a7 + (v25 >> 3)) = 0;
  if (a1)
  {
    *(void *)(a7 + (v25 >> 3)) = 1 << (v19 & 7);
    *(void *)(a7 + ((v25 + 1) >> 3)) = (1 << ((v25 + 1) & 7)) | *(unsigned __int8 *)(a7 + ((v25 + 1) >> 3));
    unsigned int v26 = v25 + 9;
    *a6 = v26 & 0xFFFFFFF8;
    *(unsigned char *)(a7 + (v26 >> 3)) = 0;
  }
  return result;
}

uint64_t StoreVarLenUint8(uint64_t result, unint64_t *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = __clz(result) ^ 0x1F;
    unint64_t v4 = *a2;
    *(void *)(a3 + (*a2 >> 3)) = (1 << (*a2 & 7)) | *(unsigned __int8 *)(a3 + (*a2 >> 3));
    *a2 = v4 + 1;
    *(void *)(a3 + ((v4 + 1) >> 3)) = (v3 << ((v4 + 1) & 7)) | *(unsigned __int8 *)(a3 + ((v4 + 1) >> 3));
    v4 += 4;
    *a2 = v4;
    *(void *)(a3 + (v4 >> 3)) = (((-1 << v3) + result) << (v4 & 7)) | *(unsigned __int8 *)(a3 + (v4 >> 3));
    unint64_t v5 = v4 + v3;
  }
  else
  {
    unint64_t v6 = *a2;
    *(void *)(a3 + (*a2 >> 3)) = *(unsigned __int8 *)(a3 + (*a2 >> 3));
    unint64_t v5 = v6 + 1;
  }
  *a2 = v5;
  return result;
}

uint64_t lz4_stream_init(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  if (a2 == 1)
  {
    unint64_t v6 = realloc_stream_state(*(_DWORD **)(a1 + 32), 1, 256, 0x4813Cu, 0);
    *(void *)(a1 + 32) = v6;
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t result = 0;
      v7[4] = 5;
      return result;
    }
  }
  else if (!a2)
  {
    unint64_t v4 = realloc_stream_state(*(_DWORD **)(a1 + 32), 0, 256, 0x4813Cu, 0);
    *(void *)(a1 + 32) = v4;
    if (v4)
    {
      v4[4] = 0;
      memset_pattern8(v4 + 65615, &unk_20DAB5A78, 0x8000uLL);
      return 0;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t lz4_stream_process(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)v2 != 1)
  {
    if (!*(_DWORD *)v2)
    {
      uint64_t v5 = v2 + 65596;
      unint64_t v6 = (int *)(v2 + 24);
      int v7 = v2 + 131260;
      int v8 = *(_DWORD *)(v2 + 16);
      while (1)
      {
        uint64_t result = 0xFFFFFFFFLL;
        switch(v8)
        {
          case 0:
            uint64_t v10 = *(unsigned int *)(v2 + 44);
            if (*(void *)(a1 + 24) >= (unint64_t)(0x10000 - v10)) {
              size_t v11 = (0x10000 - v10);
            }
            else {
              size_t v11 = *(void *)(a1 + 24);
            }
            memcpy((void *)(v5 + v10), *(const void **)(a1 + 16), v11);
            size_t v12 = *(void *)(a1 + 24) - v11;
            *(void *)(a1 + 16) += v11;
            *(void *)(a1 + 24) = v12;
            uint64_t v13 = (*(_DWORD *)(v2 + 44) + v11);
            *(_DWORD *)(v2 + 44) = v13;
            if (!a2 && v13 < 0x10000) {
              return 0;
            }
            uint64_t v60 = (unsigned __int8 *)(v2 + 65596);
            uint64_t v61 = (void *)(v2 + 131260);
            if (*(_DWORD *)(v2 + 20)) {
              uint64_t v14 = v2 + 60;
            }
            else {
              uint64_t v14 = v2 + 65596;
            }
            lz4_encode_2gb((int32x4_t **)&v61, 131200, (char **)&v60, v14, v13, v2 + 262460, 0);
            unsigned int v15 = v61 - v7;
            *(_DWORD *)(v2 + 52) = v61 - v7;
            unsigned int v16 = *(_DWORD *)(v2 + 44);
            if (v16 <= v15)
            {
              int v17 = 8;
              int v18 = 758412898;
              unint64_t v19 = (_DWORD *)(v2 + 48);
            }
            else
            {
              *(_DWORD *)(v2 + 32) = v15;
              int v17 = 12;
              int v18 = 825521762;
              unint64_t v19 = (_DWORD *)(v2 + 56);
            }
            unsigned int v20 = 0;
            *(_DWORD *)(v2 + 24) = v18;
            *(_DWORD *)(v2 + 28) = v16;
            *(_DWORD *)(v2 + 36) = 0;
            *(_DWORD *)(v2 + 40) = v17;
            _DWORD *v19 = 0;
            *(_DWORD *)(v2 + 16) = 1;
            goto LABEL_34;
          case 1:
            unsigned int v20 = *(_DWORD *)(v2 + 36);
            int v17 = *(_DWORD *)(v2 + 40);
LABEL_34:
            unint64_t v30 = v17 - v20;
            unint64_t v31 = *(void *)(a1 + 8);
            if (v31 >= v30) {
              size_t v32 = v30;
            }
            else {
              size_t v32 = v31;
            }
            memcpy(*(void **)a1, (char *)v6 + v20, v32);
            size_t v33 = *(void *)(a1 + 8) - v32;
            *(void *)a1 += v32;
            *(void *)(a1 + 8) = v33;
            LODWORD(v33) = *(_DWORD *)(v2 + 40);
            int v34 = *(_DWORD *)(v2 + 36) + v32;
            *(_DWORD *)(v2 + 36) = v34;
            if (v34 != v33) {
              return 0;
            }
            int v35 = *v6;
            if (*v6 == 607417954)
            {
              int v8 = 8;
            }
            else if (v35 == 825521762)
            {
              int v8 = 2;
            }
            else
            {
              if (v35 != 758412898) {
                return 0xFFFFFFFFLL;
              }
              int v8 = 3;
            }
            goto LABEL_46;
          case 2:
            uint64_t v21 = *(unsigned int *)(v2 + 56);
            if (*(void *)(a1 + 8) >= (unint64_t)(*(_DWORD *)(v2 + 52) - v21)) {
              size_t v22 = (*(_DWORD *)(v2 + 52) - v21);
            }
            else {
              size_t v22 = *(void *)(a1 + 8);
            }
            memcpy(*(void **)a1, (const void *)(v2 + 131260 + v21), v22);
            size_t v23 = *(void *)(a1 + 8) - v22;
            *(void *)a1 += v22;
            *(void *)(a1 + 8) = v23;
            unsigned int v24 = *(_DWORD *)(v2 + 52);
            unsigned int v25 = *(_DWORD *)(v2 + 56) + v22;
            *(_DWORD *)(v2 + 56) = v25;
            goto LABEL_25;
          case 3:
            uint64_t v26 = *(unsigned int *)(v2 + 48);
            if (*(void *)(a1 + 8) >= (unint64_t)(*(_DWORD *)(v2 + 44) - v26)) {
              size_t v27 = (*(_DWORD *)(v2 + 44) - v26);
            }
            else {
              size_t v27 = *(void *)(a1 + 8);
            }
            memcpy(*(void **)a1, (const void *)(v5 + v26), v27);
            size_t v28 = *(void *)(a1 + 8) - v27;
            *(void *)a1 += v27;
            *(void *)(a1 + 8) = v28;
            unsigned int v24 = *(_DWORD *)(v2 + 44);
            unsigned int v25 = *(_DWORD *)(v2 + 48) + v27;
            *(_DWORD *)(v2 + 48) = v25;
LABEL_25:
            if (v25 < v24) {
              return 0;
            }
            int v8 = 4;
            goto LABEL_46;
          case 4:
            if (*(void *)(a1 + 24))
            {
              memcpy((void *)(v2 + 60), (const void *)(v2 + 65596), 0x10000uLL);
              *(_DWORD *)(v2 + 44) = 0;
              if (*(_DWORD *)(v2 + 20))
              {
                for (uint64_t i = 0; i != 0x8000; i += 8)
                  *(_DWORD *)(v2 + 262460 + i) -= 0x10000;
              }
              int v8 = 0;
              *(_DWORD *)(v2 + 20) = 1;
            }
            else
            {
              if (!a2) {
                return 0;
              }
              *(_DWORD *)(v2 + 24) = 607417954;
              *(void *)(v2 + 36) = 0x400000000;
              int v8 = 1;
            }
LABEL_46:
            *(_DWORD *)(v2 + 16) = v8;
            break;
          case 8:
            if (*(void *)(a1 + 24)) {
              goto LABEL_89;
            }
            return 1;
          default:
            return result;
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v36 = v2 + 65596;
  uint64_t v37 = (int *)(v2 + 24);
  while (2)
  {
    uint64_t result = 0xFFFFFFFFLL;
    uint64_t v38 = 1;
    switch(*(_DWORD *)(v2 + 16))
    {
      case 0:
        uint64_t v39 = *(unsigned int *)(v2 + 48);
        if (*(void *)(a1 + 24) >= (unint64_t)(*(_DWORD *)(v2 + 44) - v39)) {
          size_t v40 = (*(_DWORD *)(v2 + 44) - v39);
        }
        else {
          size_t v40 = *(void *)(a1 + 24);
        }
        memcpy((void *)(v36 + v39), *(const void **)(a1 + 16), v40);
        size_t v41 = *(void *)(a1 + 24) - v40;
        *(void *)(a1 + 16) += v40;
        *(void *)(a1 + 24) = v41;
        LODWORD(v41) = *(_DWORD *)(v2 + 44);
        unsigned int v42 = *(_DWORD *)(v2 + 48) + v40;
        *(_DWORD *)(v2 + 48) = v42;
        if (v42 < v41) {
          return 0;
        }
        goto LABEL_63;
      case 5:
        uint64_t v43 = *(unsigned int *)(v2 + 36);
        if (v43 <= 3)
        {
          unsigned int v44 = 4;
          *(_DWORD *)(v2 + 40) = 4;
          goto LABEL_74;
        }
        int v53 = *v37;
        if (*v37 == 758412898)
        {
          unsigned int v44 = 8;
          goto LABEL_73;
        }
        if (v53 == 825521762)
        {
          unsigned int v44 = 12;
LABEL_73:
          *(_DWORD *)(v2 + 40) = v44;
          if (v43 >= v44)
          {
            if (v53 == 758412898)
            {
              unsigned int v59 = *(_DWORD *)(v2 + 28);
              if (v59 > 0x10000) {
                goto LABEL_89;
              }
              *(_DWORD *)(v2 + 44) = v59;
              *(_DWORD *)(v2 + 48) = 0;
              *(_DWORD *)(v2 + 16) = 0;
            }
            else
            {
              unsigned int v58 = *(_DWORD *)(v2 + 32);
              if (v58 > 0x10000 || *(_DWORD *)(v2 + 28) >= 0x10001u)
              {
LABEL_89:
                *(_DWORD *)(v2 + 16) = 9;
                return result;
              }
              *(_DWORD *)(v2 + 52) = v58;
              *(_DWORD *)(v2 + 56) = 0;
              *(_DWORD *)(v2 + 16) = 6;
            }
          }
          else
          {
LABEL_74:
            unint64_t v54 = v44 - v43;
            unint64_t v55 = *(void *)(a1 + 24);
            if (v55 >= v54) {
              size_t v56 = v54;
            }
            else {
              size_t v56 = v55;
            }
            if (!v56) {
              return 0;
            }
            memcpy((char *)v37 + v43, *(const void **)(a1 + 16), v56);
            uint64_t v57 = *(void *)(a1 + 24) - v56;
            *(void *)(a1 + 16) += v56;
            *(void *)(a1 + 24) = v57;
            *(_DWORD *)(v2 + 36) += v56;
          }
          continue;
        }
        if (v53 == 607417954)
        {
          *(_DWORD *)(v2 + 40) = 4;
          *(_DWORD *)(v2 + 16) = 8;
          return 1;
        }
        else
        {
          return 0xFFFFFFFFLL;
        }
      case 6:
        uint64_t v45 = *(unsigned int *)(v2 + 56);
        if (*(void *)(a1 + 24) >= (unint64_t)(*(_DWORD *)(v2 + 52) - v45)) {
          size_t v46 = (*(_DWORD *)(v2 + 52) - v45);
        }
        else {
          size_t v46 = *(void *)(a1 + 24);
        }
        memcpy((void *)(v2 + 131260 + v45), *(const void **)(a1 + 16), v46);
        size_t v47 = *(void *)(a1 + 24) - v46;
        *(void *)(a1 + 16) += v46;
        *(void *)(a1 + 24) = v47;
        uint64_t v48 = *(unsigned int *)(v2 + 52);
        LODWORD(v47) = *(_DWORD *)(v2 + 56) + v46;
        *(_DWORD *)(v2 + 56) = v47;
        if (v47 < v48) {
          return 0;
        }
        uint64_t v60 = (unsigned __int8 *)(v2 + 131260);
        uint64_t v61 = (void *)(v2 + 65596);
        if (lz4_decode_asm((int8x16_t **)&v61, v2 + 60, v2 + 131260, &v60, v2 + v48 + 131260)
          || lz4_decode(&v61, v2 + 60, v2 + 131260, &v60, v2 + 131260 + *(unsigned int *)(v2 + 52)))
        {
          *(_DWORD *)(v2 + 16) = 9;
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(v2 + 44) = v61 - v36;
LABEL_63:
        *(_DWORD *)(v2 + 48) = 0;
        *(_DWORD *)(v2 + 16) = 7;
        continue;
      case 7:
        uint64_t v49 = *(unsigned int *)(v2 + 48);
        if (*(void *)(a1 + 8) >= (unint64_t)(*(_DWORD *)(v2 + 44) - v49)) {
          size_t v50 = (*(_DWORD *)(v2 + 44) - v49);
        }
        else {
          size_t v50 = *(void *)(a1 + 8);
        }
        memcpy(*(void **)a1, (const void *)(v36 + v49), v50);
        size_t v51 = *(void *)(a1 + 8) - v50;
        *(void *)a1 += v50;
        *(void *)(a1 + 8) = v51;
        LODWORD(v51) = *(_DWORD *)(v2 + 44);
        unsigned int v52 = *(_DWORD *)(v2 + 48) + v50;
        *(_DWORD *)(v2 + 48) = v52;
        if (v52 < v51) {
          return 0;
        }
        memcpy((void *)(v2 + 60), (const void *)(v2 + 65596), 0x10000uLL);
        *(_DWORD *)(v2 + 36) = 0;
        *(_DWORD *)(v2 + 40) = 0;
        *(_DWORD *)(v2 + 16) = 5;
        continue;
      case 8:
        return v38;
      default:
        return result;
    }
  }
}

BOOL lz4_stream_identify_algorithm(int *a1)
{
  int v1 = *a1;
  return *a1 == 607417954 || v1 == 758412898 || v1 == 825521762;
}

uint64_t lz4_stream_get_state_size()
{
  return 295228;
}

unint64_t smb_lz77_decode_buffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = 15;
  if (a2 > 0xF) {
    uint64_t v4 = a2;
  }
  if (a4 < 4) {
    return 0;
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = a1 + v4 - 15;
  unsigned int v10 = 1;
  unint64_t v11 = 4;
  do
  {
    int v12 = *(_DWORD *)(a3 + v8);
    v8 += 36;
    if (v12) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = v8 > a4;
    }
    unint64_t v14 = v7 + 32;
    if (v13 || v14 > a2)
    {
      int v16 = 1;
      while (1)
      {
        if (v12 < 0)
        {
          unint64_t v8 = v11 + 2;
          if (v11 + 2 > a4)
          {
            if (v11 == a4) {
              return v7;
            }
            else {
              return 0;
            }
          }
          unint64_t v17 = *(unsigned __int16 *)(a3 + v11);
          uint64_t v18 = v17 & 7;
          if ((v17 & 7) == 7)
          {
            if (v10 == 1)
            {
              if (v8 >= a4) {
                return 0;
              }
              int v19 = *(unsigned __int8 *)(a3 + v8);
              unint64_t v8 = v11 + 3;
              unsigned int v10 = v19 | 0x100;
            }
            unint64_t v20 = v10 & 0xF;
            if (v20 == 15)
            {
              if (v8 >= a4) {
                return 0;
              }
              unint64_t v21 = v8 + 1;
              unint64_t v22 = *(unsigned __int8 *)(a3 + v8);
              if (v22 == 255)
              {
                unint64_t v23 = v8 + 3;
                if (v8 + 3 > a4) {
                  return 0;
                }
                unint64_t v24 = *(unsigned __int16 *)(a3 + v21);
                if (!*(_WORD *)(a3 + v21))
                {
                  unint64_t v25 = v8 + 7;
                  if (v25 > a4) {
                    return 0;
                  }
                  unint64_t v24 = *(unsigned int *)(a3 + v23);
                  unint64_t v23 = v25;
                }
                BOOL v26 = v24 >= 0x16;
                unint64_t v22 = v24 - 22;
                if (!v26) {
                  return 0;
                }
              }
              else
              {
                unint64_t v23 = v8 + 1;
              }
              unint64_t v20 = v22 + 15;
              unint64_t v8 = v23;
            }
            v10 >>= 4;
            uint64_t v18 = v20 + 7;
          }
          unint64_t v27 = (v17 >> 3) + 1;
          if (v7 < v27) {
            return 0;
          }
          unint64_t v28 = v18 + 3;
          uint64_t v29 = (unsigned char *)(a1 + v7);
          unint64_t v30 = a1 + v7 + v28;
          if (v17 < 0x78 || v30 > v9)
          {
            if (v28 > a2 - v7) {
              return 0;
            }
            do
            {
              *uint64_t v29 = v29[-v27];
              ++v29;
            }
            while ((unint64_t)v29 < v30);
          }
          else
          {
            do
            {
              *(_OWORD *)uint64_t v29 = *(_OWORD *)&v29[-v27];
              v29 += 16;
            }
            while ((unint64_t)v29 < v30);
          }
          v7 += v28;
        }
        else
        {
          uint64_t v5 = 0;
          if (v11 >= a4 || a2 <= v7) {
            return v5;
          }
          unint64_t v8 = v11 + 1;
          *(unsigned char *)(a1 + v7++) = *(unsigned char *)(a3 + v11);
        }
        v12 *= 2;
        ++v16;
        unint64_t v11 = v8;
        if (v16 == 33) {
          goto LABEL_46;
        }
      }
    }
    long long v31 = *(_OWORD *)(a3 + v11 + 16);
    size_t v32 = (_OWORD *)(a1 + v7);
    *size_t v32 = *(_OWORD *)(a3 + v11);
    v32[1] = v31;
    unint64_t v7 = v14;
LABEL_46:
    uint64_t v5 = 0;
    unint64_t v11 = v8 + 4;
  }
  while (v8 + 4 <= a4);
  return v5;
}

uint64_t smb_lz77_encode_buffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  if (a4 <= 7) {
    uint64_t v10 = 7;
  }
  else {
    uint64_t v10 = a4;
  }
  bzero(a5, 0x10000uLL);
  if (a2 < 0x12) {
    return 0;
  }
  uint64_t v12 = 0;
  unint64_t v13 = 0;
  unint64_t v14 = v10 - 7;
  unint64_t v15 = a2 - 1;
  unsigned int v16 = 256;
  uint64_t v17 = 4;
  unint64_t v18 = 1;
  while (2)
  {
    for (__int16 i = 8 - 8 * v13; ; i -= 8)
    {
      if (HIDWORD(v18))
      {
        *(_DWORD *)(a1 + v12) = v18;
        uint64_t result = v17 + 4;
        uint64_t v12 = v17;
        unint64_t v18 = 1;
      }
      else
      {
        uint64_t result = v17;
      }
      v18 *= 2;
      if (v13 + 4 <= a4) {
        break;
      }
      if (a4 == v13)
      {
        do
        {
          int v45 = v18 | 1;
          unint64_t v46 = HIDWORD(v18);
          unint64_t v18 = 2 * (v18 | 1);
        }
        while (!v46);
        *(_DWORD *)(a1 + v12) = v45;
        do
        {
          unsigned int v47 = v16;
          v16 *= 16;
        }
        while (v47 < 0x100);
        *(unsigned char *)(a1 + v15) = (v47 >> 4) | v16;
        return result;
      }
      char v20 = *(unsigned char *)(a3 + v13++);
      uint64_t v17 = result + 1;
      *(unsigned char *)(a1 + result) = v20;
      if (result + 15 > a2) {
        return 0;
      }
    }
    unsigned int v21 = *(_DWORD *)(a3 + v13);
    unsigned int v22 = v21 >> 8;
    unsigned int v23 = (-1640531535 * (v21 & 0xFFFFFF)) >> 18;
    uint64_t v24 = (-1640531535 * (v21 >> 8)) >> 18;
    unsigned int v25 = *((_DWORD *)a5 + v23);
    unsigned int v26 = *((_DWORD *)a5 + v24);
    unint64_t v27 = v13 & 0xFFFFE000 | v25 & 0x1FFF;
    unint64_t v28 = v13 & 0xFFFFE000 | v26 & 0x1FFF;
    if (v13 <= v27) {
      unint64_t v27 = (v27 - 0x2000);
    }
    else {
      unint64_t v27 = v27;
    }
    if (v13 < v28) {
      LODWORD(v28) = v28 - 0x2000;
    }
    *((_DWORD *)a5 + v23) = v13 & 0x1FFF | (v21 << 13);
    if ((v21 & 0x7FFFF) != v25 >> 13 || (v13 > v27 ? (BOOL v29 = v13 >= v14) : (BOOL v29 = 1), v29))
    {
      LODWORD(v32) = 0;
    }
    else
    {
      unint64_t v32 = 0;
      unsigned int v33 = 0;
      while (1)
      {
        unint64_t v32 = *(void *)(a3 + v27 + v32) ^ *(void *)(a3 + v33 + v13);
        if (v32) {
          break;
        }
        v33 += 8;
        unint64_t v32 = v33;
        if (v13 + v33 >= v14) {
          goto LABEL_27;
        }
      }
      LODWORD(v32) = v33 + (__clz(__rbit64(v32)) >> 3);
    }
LABEL_27:
    if (v26 >> 13 != ((v21 >> 8) & 0x7FFFF)) {
      goto LABEL_47;
    }
    if (v13 + 1 >= v14)
    {
      LODWORD(v30) = 0;
LABEL_37:
      if (!v28) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = 0;
      unsigned int v31 = 0;
      while (1)
      {
        unint64_t v30 = *(void *)(a3 + v28 + v30) ^ *(void *)(a3 + v31 + v13 + 1);
        if (v30) {
          break;
        }
        v31 += 8;
        unint64_t v30 = v31;
        if (v13 + v31 + 1 >= v14) {
          goto LABEL_37;
        }
      }
      LODWORD(v30) = v31 + (__clz(__rbit64(v30)) >> 3);
      if (!v28) {
        goto LABEL_45;
      }
    }
    unsigned int v34 = v28 - 1;
    if (*(unsigned __int8 *)(a3 + v13) == *(unsigned __int8 *)(a3 + v34) && v32 <= v30)
    {
      LODWORD(v32) = v30 + 1;
      LOWORD(v27) = v34;
      goto LABEL_47;
    }
LABEL_45:
    if (v32 < v30)
    {
      uint64_t v17 = result + 1;
      *(unsigned char *)(a1 + result) = *(unsigned char *)(a3 + v13++);
      goto LABEL_73;
    }
LABEL_47:
    if (v32 > 2)
    {
      unsigned int v37 = v32 - 3;
      if ((v32 - 3) >= 7) {
        __int16 v38 = 7;
      }
      else {
        __int16 v38 = v32 - 3;
      }
      *((_DWORD *)a5 + v24) = ((_WORD)v13 + 1) & 0x1FFF | (v22 << 13);
      *(_WORD *)(a1 + result) = v38 - 8 * v27 - i;
      v13 += v32;
      unint64_t v39 = result + 2;
      v18 |= 1uLL;
      if (v37 < 7)
      {
        uint64_t v17 = result + 2;
      }
      else
      {
        if (v16 < 0x100)
        {
          uint64_t v17 = result + 2;
          unint64_t v39 = v15;
        }
        else
        {
          *(unsigned char *)(a1 + v15) = (16 * v16) | (v16 >> 4);
          uint64_t v17 = result + 3;
          unsigned int v16 = 1;
        }
        int v40 = v32 - 10;
        if ((v32 - 10) >= 0xF) {
          int v40 = 15;
        }
        unsigned int v16 = v40 | (16 * v16);
        if ((v32 - 10) >= 0xF)
        {
          unsigned int v41 = v32 - 25;
          if ((v32 - 25) >= 0xFF) {
            char v42 = -1;
          }
          else {
            char v42 = v32 - 25;
          }
          *(unsigned char *)(a1 + v17) = v42;
          if (v41 >= 0xFF)
          {
            BOOL v43 = v41 >= 0xFFEA;
            if (v41 >= 0xFFEA) {
              __int16 v44 = 0;
            }
            else {
              __int16 v44 = v32 - 3;
            }
            *(_WORD *)(a1 + v17 + 1) = v44;
            if (v43)
            {
              *(_DWORD *)(a1 + v17 + 3) = v37;
              v17 += 7;
            }
            else
            {
              v17 += 3;
            }
          }
          else
          {
            ++v17;
          }
        }
        unint64_t v15 = v39;
      }
    }
    else
    {
      char v36 = *(unsigned char *)(a3 + v13++);
      uint64_t v17 = result + 1;
      *(unsigned char *)(a1 + result) = v36;
    }
LABEL_73:
    uint64_t result = 0;
    if (v17 + 14 <= a2) {
      continue;
    }
    return result;
  }
}

void BrotliPopulationCostLiteral(uint64_t a1)
{
  v35[5] = *MEMORY[0x263EF8340];
  unint64_t v1 = *(void *)(a1 + 1024);
  if (!v1) {
    return;
  }
  int v3 = 0;
  for (uint64_t i = 0; i != 256; ++i)
  {
    if (*(_DWORD *)(a1 + 4 * i))
    {
      v35[v3] = i;
      BOOL v5 = v3++ <= 3;
      if (!v5) {
        break;
      }
    }
  }
  switch(v3)
  {
    case 1:
    case 2:
    case 3:
      return;
    case 4:
      for (uint64_t j = 0; j != 4; ++j)
        *((_DWORD *)v33 + j) = *(_DWORD *)(a1 + 4 * v35[j]);
      unint64_t v7 = 0;
      do
      {
        unint64_t v8 = v7++;
        if (v8 <= 2)
        {
          unsigned int v9 = *((_DWORD *)v33 + v8);
          unint64_t v10 = v7;
          do
          {
            unsigned int v11 = *((_DWORD *)v33 + v10);
            if (v11 > v9)
            {
              *((_DWORD *)v33 + v10) = v9;
              *((_DWORD *)v33 + v8) = v11;
              unsigned int v9 = v11;
            }
            ++v10;
          }
          while (v10 != 4);
        }
      }
      while (v7 != 4);
      return;
    default:
      uint64_t v34 = 0;
      memset(v33, 0, sizeof(v33));
      if (v1 > 0xFF) {
        double v12 = log2((double)v1);
      }
      else {
        double v12 = kBrotliLog2Table[v1];
      }
      int v13 = 0;
      unint64_t v14 = 0;
      double v15 = 0.0;
      unint64_t v16 = 1;
      break;
  }
  do
  {
    uint64_t v17 = *(unsigned int *)(a1 + 4 * v14);
    if (v17)
    {
      if (v17 > 0xFF)
      {
        double v19 = (double)v17;
        double v18 = log2((double)v17);
      }
      else
      {
        double v18 = kBrotliLog2Table[v17];
        double v19 = (double)v17;
      }
      double v23 = v12 - v18;
      unint64_t v24 = (unint64_t)(v23 + 0.5);
      double v15 = v15 + v19 * v23;
      if (v24 >= 0xF) {
        unint64_t v24 = 15;
      }
      if (v24 > v16) {
        unint64_t v16 = v24;
      }
      ++*((_DWORD *)v33 + v24);
      ++v14;
      continue;
    }
    if (v14 == 255) {
      break;
    }
    uint64_t v20 = 0;
    do
    {
      if (*(_DWORD *)(a1 + 4 + 4 * v14 + 4 * v20)) {
        break;
      }
      ++v20;
    }
    while (255 - v14 != v20);
    unsigned int v21 = v20 + 1;
    v14 += (v20 + 1);
    if (v14 == 256) {
      break;
    }
    unsigned int v22 = v20 - 1;
    if (v21 > 2)
    {
      do
      {
        ++v13;
        double v15 = v15 + 3.0;
        BOOL v5 = v22 > 7;
        v22 >>= 3;
      }
      while (v5);
    }
    else
    {
      LODWORD(v33[0]) += v21;
    }
  }
  while (v14 < 0x100);
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  HIDWORD(v34) = v13;
  double v27 = 0.0;
  do
  {
    uint64_t v28 = *((unsigned int *)v33 + v26);
    if (v28 > 0xFF)
    {
      double v30 = (double)v28;
      double v29 = log2((double)v28);
    }
    else
    {
      double v29 = kBrotliLog2Table[v28];
      double v30 = (double)v28;
    }
    uint64_t v31 = *((unsigned int *)v33 + v26 + 1);
    if (v31 > 0xFF) {
      double v32 = log2((double)v31);
    }
    else {
      double v32 = kBrotliLog2Table[v31];
    }
    v26 += 2;
    v25 += v28 + v31;
    double v27 = v27 - v30 * v29 - (double)v31 * v32;
  }
  while ((unint64_t)(v26 - 2) < 0x10);
  if (v25 >= 0x100) {
    log2((double)v25);
  }
}

void BrotliPopulationCostCommand(uint64_t a1)
{
  v35[5] = *MEMORY[0x263EF8340];
  unint64_t v1 = *(void *)(a1 + 2816);
  if (!v1) {
    return;
  }
  int v3 = 0;
  for (uint64_t i = 0; i != 704; ++i)
  {
    if (*(_DWORD *)(a1 + 4 * i))
    {
      v35[v3] = i;
      BOOL v5 = v3++ <= 3;
      if (!v5) {
        break;
      }
    }
  }
  switch(v3)
  {
    case 1:
    case 2:
    case 3:
      return;
    case 4:
      for (uint64_t j = 0; j != 4; ++j)
        *((_DWORD *)v33 + j) = *(_DWORD *)(a1 + 4 * v35[j]);
      unint64_t v7 = 0;
      do
      {
        unint64_t v8 = v7++;
        if (v8 <= 2)
        {
          unsigned int v9 = *((_DWORD *)v33 + v8);
          unint64_t v10 = v7;
          do
          {
            unsigned int v11 = *((_DWORD *)v33 + v10);
            if (v11 > v9)
            {
              *((_DWORD *)v33 + v10) = v9;
              *((_DWORD *)v33 + v8) = v11;
              unsigned int v9 = v11;
            }
            ++v10;
          }
          while (v10 != 4);
        }
      }
      while (v7 != 4);
      return;
    default:
      uint64_t v34 = 0;
      memset(v33, 0, sizeof(v33));
      if (v1 > 0xFF) {
        double v12 = log2((double)v1);
      }
      else {
        double v12 = kBrotliLog2Table[v1];
      }
      int v13 = 0;
      unint64_t v14 = 0;
      double v15 = 0.0;
      unint64_t v16 = 1;
      break;
  }
  do
  {
    uint64_t v17 = *(unsigned int *)(a1 + 4 * v14);
    if (v17)
    {
      if (v17 > 0xFF)
      {
        double v19 = (double)v17;
        double v18 = log2((double)v17);
      }
      else
      {
        double v18 = kBrotliLog2Table[v17];
        double v19 = (double)v17;
      }
      double v22 = v12 - v18;
      unint64_t v23 = (unint64_t)(v22 + 0.5);
      double v15 = v15 + v19 * v22;
      if (v23 >= 0xF) {
        unint64_t v23 = 15;
      }
      if (v23 > v16) {
        unint64_t v16 = v23;
      }
      ++*((_DWORD *)v33 + v23);
      ++v14;
      continue;
    }
    if (v14 > 0x2BE)
    {
      if (++v14 == 704) {
        break;
      }
      unsigned int v21 = 1;
      goto LABEL_41;
    }
    uint64_t v20 = 0;
    unsigned int v21 = 704 - v14;
    while (!*(_DWORD *)(a1 + 4 + 4 * v14 + 4 * v20))
    {
      if (703 - v14 == ++v20) {
        goto LABEL_39;
      }
    }
    unsigned int v21 = v20 + 1;
LABEL_39:
    v14 += v21;
    if (v14 == 704) {
      break;
    }
    unsigned int v24 = v21 - 2;
    if (v21 > 2)
    {
      do
      {
        ++v13;
        double v15 = v15 + 3.0;
        BOOL v5 = v24 > 7;
        v24 >>= 3;
      }
      while (v5);
      continue;
    }
LABEL_41:
    LODWORD(v33[0]) += v21;
  }
  while (v14 < 0x2C0);
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  HIDWORD(v34) = v13;
  double v27 = 0.0;
  do
  {
    uint64_t v28 = *((unsigned int *)v33 + v26);
    if (v28 > 0xFF)
    {
      double v30 = (double)v28;
      double v29 = log2((double)v28);
    }
    else
    {
      double v29 = kBrotliLog2Table[v28];
      double v30 = (double)v28;
    }
    uint64_t v31 = *((unsigned int *)v33 + v26 + 1);
    if (v31 > 0xFF) {
      double v32 = log2((double)v31);
    }
    else {
      double v32 = kBrotliLog2Table[v31];
    }
    v26 += 2;
    v25 += v28 + v31;
    double v27 = v27 - v30 * v29 - (double)v31 * v32;
  }
  while ((unint64_t)(v26 - 2) < 0x10);
  if (v25 >= 0x100) {
    log2((double)v25);
  }
}

void BrotliPopulationCostDistance(uint64_t a1)
{
  v35[5] = *MEMORY[0x263EF8340];
  unint64_t v1 = *(void *)(a1 + 2176);
  if (!v1) {
    return;
  }
  int v3 = 0;
  for (uint64_t i = 0; i != 544; ++i)
  {
    if (*(_DWORD *)(a1 + 4 * i))
    {
      v35[v3] = i;
      BOOL v5 = v3++ <= 3;
      if (!v5) {
        break;
      }
    }
  }
  switch(v3)
  {
    case 1:
    case 2:
    case 3:
      return;
    case 4:
      for (uint64_t j = 0; j != 4; ++j)
        *((_DWORD *)v33 + j) = *(_DWORD *)(a1 + 4 * v35[j]);
      unint64_t v7 = 0;
      do
      {
        unint64_t v8 = v7++;
        if (v8 <= 2)
        {
          unsigned int v9 = *((_DWORD *)v33 + v8);
          unint64_t v10 = v7;
          do
          {
            unsigned int v11 = *((_DWORD *)v33 + v10);
            if (v11 > v9)
            {
              *((_DWORD *)v33 + v10) = v9;
              *((_DWORD *)v33 + v8) = v11;
              unsigned int v9 = v11;
            }
            ++v10;
          }
          while (v10 != 4);
        }
      }
      while (v7 != 4);
      return;
    default:
      uint64_t v34 = 0;
      memset(v33, 0, sizeof(v33));
      if (v1 > 0xFF) {
        double v12 = log2((double)v1);
      }
      else {
        double v12 = kBrotliLog2Table[v1];
      }
      int v13 = 0;
      unint64_t v14 = 0;
      double v15 = 0.0;
      unint64_t v16 = 1;
      break;
  }
  do
  {
    uint64_t v17 = *(unsigned int *)(a1 + 4 * v14);
    if (v17)
    {
      if (v17 > 0xFF)
      {
        double v19 = (double)v17;
        double v18 = log2((double)v17);
      }
      else
      {
        double v18 = kBrotliLog2Table[v17];
        double v19 = (double)v17;
      }
      double v22 = v12 - v18;
      unint64_t v23 = (unint64_t)(v22 + 0.5);
      double v15 = v15 + v19 * v22;
      if (v23 >= 0xF) {
        unint64_t v23 = 15;
      }
      if (v23 > v16) {
        unint64_t v16 = v23;
      }
      ++*((_DWORD *)v33 + v23);
      ++v14;
      continue;
    }
    if (v14 > 0x21E)
    {
      if (++v14 == 544) {
        break;
      }
      unsigned int v21 = 1;
      goto LABEL_41;
    }
    uint64_t v20 = 0;
    unsigned int v21 = 544 - v14;
    while (!*(_DWORD *)(a1 + 4 + 4 * v14 + 4 * v20))
    {
      if (543 - v14 == ++v20) {
        goto LABEL_39;
      }
    }
    unsigned int v21 = v20 + 1;
LABEL_39:
    v14 += v21;
    if (v14 == 544) {
      break;
    }
    unsigned int v24 = v21 - 2;
    if (v21 > 2)
    {
      do
      {
        ++v13;
        double v15 = v15 + 3.0;
        BOOL v5 = v24 > 7;
        v24 >>= 3;
      }
      while (v5);
      continue;
    }
LABEL_41:
    LODWORD(v33[0]) += v21;
  }
  while (v14 < 0x220);
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  HIDWORD(v34) = v13;
  double v27 = 0.0;
  do
  {
    uint64_t v28 = *((unsigned int *)v33 + v26);
    if (v28 > 0xFF)
    {
      double v30 = (double)v28;
      double v29 = log2((double)v28);
    }
    else
    {
      double v29 = kBrotliLog2Table[v28];
      double v30 = (double)v28;
    }
    uint64_t v31 = *((unsigned int *)v33 + v26 + 1);
    if (v31 > 0xFF) {
      double v32 = log2((double)v31);
    }
    else {
      double v32 = kBrotliLog2Table[v31];
    }
    v26 += 2;
    v25 += v28 + v31;
    double v27 = v27 - v30 * v29 - (double)v31 * v32;
  }
  while ((unint64_t)(v26 - 2) < 0x10);
  if (v25 >= 0x100) {
    log2((double)v25);
  }
}

uint64_t cosmix_model_update(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = 0;
    uint64_t v93 = *(void *)(result + 589824);
    unsigned int v10 = 32;
    int v92 = 32 - *(_DWORD *)(result + 589832);
    do
    {
      unsigned int v96 = v10 << 8;
      uint64_t v11 = result + 9 * (v10 << 8);
      uint64_t v12 = v93 + 9 * (v9 >> v92);
      uint64_t v13 = v93 + 9 * (v8 >> v92);
      uint64_t v103 = v93 + 9 * (v7 >> v92);
      uint64_t v14 = v93 + 9 * (v6 >> v92);
      uint64_t v15 = v93 + 9 * (v5 >> v92);
      uint64_t v16 = v93 + 9 * (v4 >> v92);
      unsigned int v97 = v9;
      unsigned int v98 = v8;
      unsigned __int8 v17 = v9;
      unsigned __int8 v18 = v8;
      unsigned int v99 = v7;
      unsigned int v100 = v6;
      unsigned __int8 v19 = v7;
      unsigned __int8 v20 = v6;
      unsigned __int8 v21 = v5;
      unsigned int v101 = v4;
      unsigned __int8 v22 = v4;
      unsigned int v23 = 1;
      int v24 = 7;
      uint64_t v102 = v3;
      unsigned int v10 = *(unsigned __int8 *)(a2 + v3);
      unsigned int v105 = v10;
      uint64_t v104 = v12;
      uint64_t v106 = v13;
      do
      {
        uint64_t v25 = v23;
        uint64_t v26 = (unsigned int *)(v11 + 9 * v23);
        if (((*((unsigned char *)v26 + 8) ^ v23) & 0xF) != 0)
        {
          LODWORD(v27) = *(_DWORD *)(v11 + 9 * v23 + 4);
          LODWORD(v28) = *v26;
          unsigned int v29 = 8;
        }
        else
        {
          uint64_t v28 = *v26;
          unint64_t v27 = *(unsigned int *)(v11 + 9 * v23 + 4);
          unsigned int v29 = tc_quant16[((v28 << 16) / v27) >> 11];
        }
        int v30 = (v10 >> v24) & 1;
        uint64_t v31 = 9 * v23;
        unsigned int v32 = v27 >> 1;
        if (v27 <= 0xFFFF0000) {
          unsigned int v32 = 0;
        }
        unsigned int *v26 = (v28 >> (v27 > 0xFFFF0000)) + 4 * v30;
        *(_DWORD *)(v11 + 9 * v23 + 4) = v27 - v32 + 4;
        *((unsigned char *)v26 + 8) = v23;
        unsigned int v33 = (unsigned int *)(v12 + v31);
        uint64_t v34 = (unsigned __int8 *)(v12 + v31 + 8);
        if (((*v34 ^ v17) & 0xF) != 0)
        {
          LODWORD(v35) = *v33;
          LODWORD(v36) = v33[1];
          unsigned int v37 = 8;
        }
        else
        {
          uint64_t v35 = *v33;
          unint64_t v36 = v33[1];
          unsigned int v37 = tc_quant16[((v35 << 16) / v36) >> 11];
        }
        int v38 = 4 * v30;
        uint64_t v39 = 9 * v25;
        unsigned int v40 = v36 >> 1;
        if (v36 <= 0xFFFF0000) {
          unsigned int v40 = 0;
        }
        unsigned int *v33 = (v35 >> (v36 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v12 + 9 * v25 + 4) = v36 - v40 + 4;
        *uint64_t v34 = v17;
        unsigned int v41 = (unsigned int *)(v13 + v39);
        char v42 = (unsigned __int8 *)(v13 + v39 + 8);
        if (((*v42 ^ v18) & 0xF) != 0)
        {
          LODWORD(v43) = *v41;
          LODWORD(v44) = v41[1];
          unsigned int v45 = 8;
        }
        else
        {
          uint64_t v43 = *v41;
          unint64_t v44 = v41[1];
          unsigned int v45 = tc_quant16[((v43 << 16) / v44) >> 11];
        }
        uint64_t v46 = 9 * v25;
        unsigned int v47 = v44 >> 1;
        if (v44 <= 0xFFFF0000) {
          unsigned int v47 = 0;
        }
        *unsigned int v41 = (v43 >> (v44 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v13 + 9 * v25 + 4) = v44 - v47 + 4;
        *char v42 = v18;
        uint64_t v48 = (unsigned int *)(v103 + v46);
        uint64_t v49 = (unsigned __int8 *)(v103 + v46 + 8);
        if (((*v49 ^ v19) & 0xF) != 0)
        {
          LODWORD(v50) = *v48;
          LODWORD(v51) = v48[1];
          uint64_t v52 = 8;
        }
        else
        {
          uint64_t v50 = *v48;
          unint64_t v51 = v48[1];
          uint64_t v52 = tc_quant16[((v50 << 16) / v51) >> 11];
        }
        uint64_t v53 = 9 * v25;
        unsigned int v54 = v51 >> 1;
        if (v51 <= 0xFFFF0000) {
          unsigned int v54 = 0;
        }
        *uint64_t v48 = (v50 >> (v51 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v103 + 9 * v25 + 4) = v51 - v54 + 4;
        unsigned __int8 *v49 = v19;
        unint64_t v55 = (unsigned int *)(v14 + v53);
        size_t v56 = (unsigned __int8 *)(v14 + v53 + 8);
        if (((*v56 ^ v20) & 0xF) != 0)
        {
          LODWORD(v57) = *v55;
          LODWORD(v58) = v55[1];
          unsigned int v59 = 8;
        }
        else
        {
          uint64_t v57 = *v55;
          unint64_t v58 = v55[1];
          unsigned int v59 = tc_quant16[((v57 << 16) / v58) >> 11];
        }
        uint64_t v60 = 9 * v25;
        unsigned int v61 = v58 >> 1;
        if (v58 <= 0xFFFF0000) {
          unsigned int v61 = 0;
        }
        *unint64_t v55 = (v57 >> (v58 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v14 + 9 * v25 + 4) = v58 - v61 + 4;
        *size_t v56 = v20;
        unint64_t v62 = (unsigned int *)(v15 + v60);
        unsigned int v63 = (unsigned __int8 *)(v15 + v60 + 8);
        if (((*v63 ^ v21) & 0xF) != 0)
        {
          LODWORD(v64) = *v62;
          LODWORD(v65) = v62[1];
          unsigned int v66 = 8;
        }
        else
        {
          uint64_t v64 = *v62;
          unint64_t v65 = v62[1];
          unsigned int v66 = tc_quant16[((v64 << 16) / v65) >> 11];
        }
        uint64_t v67 = 9 * v25;
        unsigned int v68 = v65 >> 1;
        if (v65 <= 0xFFFF0000) {
          unsigned int v68 = 0;
        }
        *unint64_t v62 = (v64 >> (v65 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v15 + 9 * v25 + 4) = v65 - v68 + 4;
        *unsigned int v63 = v21;
        __int16 v69 = (unsigned int *)(v16 + v67);
        uint64_t v70 = (unsigned __int8 *)(v16 + v67 + 8);
        if (((*v70 ^ v22) & 0xF) != 0)
        {
          LODWORD(v71) = *v69;
          LODWORD(v72) = v69[1];
          uint64_t v73 = 8;
        }
        else
        {
          uint64_t v71 = *v69;
          unint64_t v72 = v69[1];
          uint64_t v73 = tc_quant16[((v71 << 16) / v72) >> 11];
        }
        unsigned int v74 = v72 >> 1;
        if (v72 <= 0xFFFF0000) {
          unsigned int v74 = 0;
        }
        *__int16 v69 = (v71 >> (v72 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v16 + 9 * v25 + 4) = v72 - v74 + 4;
        *uint64_t v70 = v22;
        uint64_t v75 = result + 2304 * v37 + 144 * v45 + 589848;
        uint64_t v76 = (unsigned int *)(v75 + 9 * v52);
        if ((v76[2] & 0xF) != 0)
        {
          LODWORD(v77) = *v76;
          LODWORD(v78) = v76[1];
          unsigned int v79 = 8;
        }
        else
        {
          uint64_t v77 = *v76;
          unint64_t v78 = v76[1];
          unsigned int v79 = tc_quant16[((v77 << 16) / v78) >> 11];
        }
        uint64_t v80 = v75 + 9 * v52;
        unsigned int v81 = v78 >> 1;
        if (v78 <= 0xFFFF0000) {
          unsigned int v81 = 0;
        }
        *uint64_t v76 = (v77 >> (v78 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v80 + 4) = v78 - v81 + 4;
        *((unsigned char *)v76 + 8) = 0;
        uint64_t v82 = result + 2304 * v59 + 144 * v66 + 626712;
        unint64_t v83 = (unsigned int *)(v82 + 9 * v73);
        if ((v83[2] & 0xF) != 0)
        {
          LODWORD(v85) = *v83;
          LODWORD(v84) = v83[1];
          uint64_t v86 = 8;
        }
        else
        {
          uint64_t v85 = *v83;
          unint64_t v84 = v83[1];
          uint64_t v86 = tc_quant16[((v85 << 16) / v84) >> 11];
        }
        unsigned int v10 = v105;
        uint64_t v12 = v104;
        uint64_t v87 = v82 + 9 * v73;
        unsigned int v88 = v84 >> 1;
        if (v84 <= 0xFFFF0000) {
          unsigned int v88 = 0;
        }
        *unint64_t v83 = (v85 >> (v84 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v87 + 4) = v84 - v88 + 4;
        *((unsigned char *)v83 + 8) = 0;
        uint64_t v89 = result + 2304 * v29 + 144 * v79 + 9 * v86 + 663576;
        unsigned int v90 = *(_DWORD *)(v89 + 4);
        unsigned int v91 = v90 >> 1;
        if (v90 <= 0xFFFF0000) {
          unsigned int v91 = 0;
        }
        *(_DWORD *)uint64_t v89 = (*(_DWORD *)v89 >> (v90 > 0xFFFF0000)) + v38;
        *(_DWORD *)(v89 + 4) = v90 - v91 + 4;
        *(unsigned char *)(v89 + 8) = 0;
        unsigned int v23 = v30 | (2 * v25);
        --v24;
        uint64_t v13 = v106;
      }
      while (v24 != -1);
      if (v105 >= 0x21) {
        unsigned int v4 = -1640531535 * (v101 + v105);
      }
      else {
        unsigned int v4 = 0;
      }
      unsigned int v5 = -1640531535 * (v100 + v105);
      unsigned int v6 = -1640531535 * (v99 + v105);
      unsigned int v7 = -1640531535 * (v98 + v105);
      unsigned int v8 = -1640531535 * (v97 + v105);
      unsigned int v9 = -1640531535 * (v96 | v105);
      uint64_t v3 = v102 + 1;
    }
    while (v102 + 1 != a3);
  }
  return result;
}

unint64_t cosmix_codec_encode(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!a5) {
    return 0;
  }
  int v5 = 0;
  unint64_t v6 = 0;
  unint64_t v7 = 1;
  do
  {
    unint64_t v8 = v6;
    unint64_t v6 = v7;
    v7 += v8;
    ++v5;
  }
  while (a5 - v6 >= v7);
  unint64_t v9 = 1 << v5;
  if (v5)
  {
    unsigned int v10 = v5 - 1;
    unint64_t v11 = a5;
    do
    {
      uint64_t v12 = 1 << v10;
      if (v11 >= v7) {
        unint64_t v13 = v7;
      }
      else {
        unint64_t v13 = 0;
      }
      if (v11 < v7) {
        uint64_t v12 = 0;
      }
      v11 -= v13;
      v9 |= v12;
      unint64_t v14 = v7 - v6;
      unint64_t v7 = v6;
      unint64_t v6 = v14;
    }
    while ((unint64_t)v10--);
  }
  int v16 = 0;
  unint64_t v17 = 0;
  unint64_t v18 = a5 + ((73 - __clz(v9)) >> 3);
  unint64_t v19 = 1;
  do
  {
    unint64_t v20 = v17;
    unint64_t v17 = v19;
    v19 += v20;
    ++v16;
  }
  while (a5 - v17 >= v19);
  unint64_t v21 = 1 << v16;
  unint64_t v137 = v18;
  if (!v16) {
    goto LABEL_23;
  }
  unsigned int v22 = v16 - 1;
  unint64_t v23 = a5;
  do
  {
    uint64_t v24 = 1 << v22;
    if (v23 >= v19) {
      unint64_t v25 = v19;
    }
    else {
      unint64_t v25 = 0;
    }
    if (v23 < v19) {
      uint64_t v24 = 0;
    }
    v23 -= v25;
    v21 |= v24;
    unint64_t v26 = v19 - v17;
    unint64_t v19 = v17;
    unint64_t v17 = v26;
  }
  while ((unint64_t)v22--);
  if (!v21)
  {
    unint64_t v29 = 0;
    unsigned int v28 = 0;
    int v30 = -1;
  }
  else
  {
LABEL_23:
    unsigned int v28 = 0;
    unint64_t v29 = 0;
    int v30 = -1;
    do
    {
      int v31 = v28 + ((v30 - v28) >> 1);
      if (v21) {
        int v32 = v28;
      }
      else {
        int v32 = v31 + 1;
      }
      if ((v21 & 1) == 0) {
        int v31 = v30;
      }
      if ((v31 ^ v32) >> 24)
      {
        unsigned int v28 = v32;
        int v30 = v31;
      }
      else
      {
        do
        {
          unsigned int v28 = v32 << 8;
          if (v29 >= a3) {
            unint64_t v33 = 0;
          }
          else {
            unint64_t v33 = v29;
          }
          *(unsigned char *)(a2 + v33) = HIBYTE(v32);
          int v30 = (v31 << 8) | 0xFF;
          ++v29;
          unsigned int v34 = ((v31 << 8) ^ (v32 << 8)) >> 24;
          int v31 = v30;
          v32 <<= 8;
        }
        while (!v34);
      }
      BOOL v35 = v21 > 1;
      v21 >>= 1;
    }
    while (v35);
  }
  unsigned int v37 = v28 + ((v30 - v28) >> 1);
  if ((v37 ^ v28) >> 24)
  {
    unsigned int v38 = v28;
    unsigned int v40 = v28 + ((v30 - v28) >> 1);
  }
  else
  {
    do
    {
      unsigned int v38 = v28 << 8;
      if (v29 >= a3) {
        unint64_t v39 = 0;
      }
      else {
        unint64_t v39 = v29;
      }
      *(unsigned char *)(a2 + v39) = HIBYTE(v28);
      unsigned int v40 = (v37 << 8) | 0xFF;
      ++v29;
      unsigned int v41 = ((v37 << 8) ^ (v28 << 8)) >> 24;
      unsigned int v37 = v40;
      v28 <<= 8;
    }
    while (!v41);
  }
  uint64_t v42 = 0;
  unsigned int v43 = 0;
  unsigned int v44 = 0;
  unsigned int v45 = 0;
  unsigned int v46 = 0;
  unsigned int v47 = 0;
  unsigned int v48 = 0;
  if (a5 <= 1) {
    uint64_t v49 = 1;
  }
  else {
    uint64_t v49 = a5;
  }
  uint64_t v139 = v49;
  LODWORD(v50) = 32;
  do
  {
    char v51 = 32 - *(_DWORD *)(a1 + 16);
    uint64_t v52 = *(void *)(a1 + 8);
    uint64_t v151 = v52 + ((unint64_t)v48 >> v51);
    uint64_t v150 = v52 + ((unint64_t)v47 >> v51);
    uint64_t v149 = v52 + ((unint64_t)v46 >> v51);
    uint64_t v148 = v52 + ((unint64_t)v45 >> v51);
    uint64_t v147 = v52 + ((unint64_t)v44 >> v51);
    uint64_t v53 = v52 + ((unint64_t)v43 >> v51);
    unsigned int v142 = v47;
    char v54 = v47;
    int v141 = v50 << 8;
    unsigned int v143 = v46;
    unsigned int v144 = v45;
    char v55 = v46;
    char v56 = v45;
    char v57 = v44;
    unsigned int v145 = v43;
    char v58 = v43;
    unint64_t v59 = *(void *)a1 + ((unint64_t)v50 << 8);
    unsigned int v60 = 1;
    int v61 = 8;
    uint64_t v146 = v42;
    uint64_t v50 = *(unsigned __int8 *)(a4 + v42);
    do
    {
      --v61;
      uint64_t v62 = v50;
      unsigned int v63 = v50 >> v61;
      unsigned int v64 = *(unsigned __int8 *)(v59 + v60);
      char v65 = v64 ^ v60;
      LODWORD(v66) = v64 >> 4;
      if ((v65 & 0xF) != 0) {
        uint64_t v66 = 8;
      }
      else {
        uint64_t v66 = v66;
      }
      unsigned int v67 = *(unsigned __int8 *)(v151 + v60);
      char v68 = v67 ^ v48;
      LODWORD(v69) = v67 >> 4;
      if ((v68 & 0xF) != 0) {
        uint64_t v69 = 8;
      }
      else {
        uint64_t v69 = v69;
      }
      unsigned int v70 = *(unsigned __int8 *)(v150 + v60);
      char v71 = v70 ^ v54;
      unsigned int v72 = v70 >> 4;
      if ((v71 & 0xF) != 0) {
        unsigned int v72 = 8;
      }
      unsigned int v73 = *(unsigned __int8 *)(v149 + v60);
      char v74 = v73 ^ v55;
      unsigned int v75 = v73 >> 4;
      if ((v74 & 0xF) != 0) {
        unsigned int v76 = 8;
      }
      else {
        unsigned int v76 = v75;
      }
      unsigned int v77 = *(unsigned __int8 *)(v148 + v60);
      char v78 = v77 ^ v56;
      LODWORD(v79) = v77 >> 4;
      if ((v78 & 0xF) != 0) {
        uint64_t v79 = 8;
      }
      else {
        uint64_t v79 = v79;
      }
      unsigned int v80 = *(unsigned __int8 *)(v147 + v60);
      char v81 = v80 ^ v57;
      unsigned int v82 = v80 >> 4;
      if ((v81 & 0xF) != 0) {
        unsigned int v82 = 8;
      }
      unsigned int v83 = *(unsigned __int8 *)(v53 + v60);
      char v84 = v83 ^ v58;
      unsigned int v85 = v83 >> 4;
      if ((v84 & 0xF) != 0) {
        unsigned int v86 = 8;
      }
      else {
        unsigned int v86 = v85;
      }
      uint64_t v87 = *(void *)(a1 + 32) + (v69 << 8);
      int v88 = v63 & 1;
      unsigned int v89 = v38
          + ((*(unsigned __int8 *)(*(void *)(a1 + 48)
                                 + (v66 << 8)
                                 + (*(unsigned char *)(v87 + 16 * v72 + v76) & 0xF0)
                                 + ((unint64_t)*(unsigned __int8 *)(*(void *)(a1 + 40)
                                                                         + (v79 << 8)
                                                                         + 16 * v82
                                                                         + v86) >> 4))
            * (unint64_t)(v40 - v38)) >> 8);
      if (v63) {
        unsigned int v90 = v38;
      }
      else {
        unsigned int v90 = v89 + 1;
      }
      if (!v88) {
        unsigned int v89 = v40;
      }
      if ((v89 ^ v90) >> 24)
      {
        unsigned int v38 = v90;
        unsigned int v40 = v89;
        uint64_t v50 = v62;
      }
      else
      {
        uint64_t v50 = v62;
        do
        {
          unsigned int v38 = v90 << 8;
          if (v29 >= a3) {
            unint64_t v91 = 0;
          }
          else {
            unint64_t v91 = v29;
          }
          *(unsigned char *)(a2 + v91) = HIBYTE(v90);
          unsigned int v40 = (v89 << 8) | 0xFF;
          ++v29;
          unsigned int v92 = ((v89 << 8) ^ (v90 << 8)) >> 24;
          unsigned int v89 = v40;
          v90 <<= 8;
        }
        while (!v92);
      }
      unsigned int v60 = v88 | (2 * v60);
    }
    while (v61);
    if (v50 >= 0x21) {
      unsigned int v43 = -1640531535 * (v145 + v50);
    }
    else {
      unsigned int v43 = 0;
    }
    unsigned int v44 = -1640531535 * (v144 + v50);
    unsigned int v45 = -1640531535 * (v143 + v50);
    unsigned int v46 = -1640531535 * (v142 + v50);
    unsigned int v47 = -1640531535 * (v48 + v50);
    unsigned int v48 = -1640531535 * (v141 | v50);
    uint64_t v42 = v146 + 1;
  }
  while (v146 + 1 != v139);
  while (1)
  {
    int v98 = HIBYTE(v38) + 1;
    if (v98 != HIBYTE(v40)) {
      break;
    }
    int v93 = v38 | 0xFFFFFF;
    unsigned int v94 = (v38 | 0xFFFFFF) - v38;
    if ((v40 & 0xFFFFFF) <= v94) {
      unsigned int v95 = v38;
    }
    else {
      unsigned int v95 = v40 & 0xFF000000;
    }
    if ((v40 & 0xFFFFFF) > v94) {
      int v93 = v40;
    }
    if ((v93 ^ v95) >> 24)
    {
      unsigned int v38 = v95;
      unsigned int v40 = v93;
    }
    else
    {
      do
      {
        unsigned int v38 = v95 << 8;
        if (v29 >= a3) {
          unint64_t v96 = 0;
        }
        else {
          unint64_t v96 = v29;
        }
        *(unsigned char *)(a2 + v96) = HIBYTE(v95);
        unsigned int v40 = (v93 << 8) | 0xFF;
        ++v29;
        unsigned int v97 = ((v93 << 8) ^ (v95 << 8)) >> 24;
        int v93 = v40;
        v95 <<= 8;
      }
      while (!v97);
    }
  }
  if (v29 >= a3) {
    unint64_t v99 = 0;
  }
  else {
    unint64_t v99 = v29;
  }
  *(unsigned char *)(a2 + v99) = v98;
  if (v29 + 1 <= a3) {
    unint64_t result = v29 + 1;
  }
  else {
    unint64_t result = 0;
  }
  unint64_t v100 = a5;
  if (result > v137)
  {
    int v101 = 0;
    unint64_t v102 = 0;
    unint64_t v103 = 1;
    do
    {
      unint64_t v104 = v102;
      unint64_t v102 = v103;
      v103 += v104;
      ++v101;
    }
    while (a5 - v102 >= v103);
    unint64_t v105 = 1 << v101;
    if (!v101) {
      goto LABEL_121;
    }
    unsigned int v106 = v101 - 1;
    do
    {
      uint64_t v107 = 1 << v106;
      if (v100 >= v103) {
        unint64_t v108 = v103;
      }
      else {
        unint64_t v108 = 0;
      }
      if (v100 < v103) {
        uint64_t v107 = 0;
      }
      v100 -= v108;
      v105 |= v107;
      unint64_t v109 = v103 - v102;
      unint64_t v103 = v102;
      unint64_t v102 = v109;
    }
    while ((unint64_t)v106--);
    if (!v105)
    {
      unint64_t v112 = 0;
      int v111 = 0;
      int v113 = -1;
    }
    else
    {
LABEL_121:
      int v111 = 0;
      unint64_t v112 = 0;
      int v113 = -1;
      do
      {
        int v114 = v111 + ((v113 - v111) >> 1);
        if (v105) {
          int v115 = v111;
        }
        else {
          int v115 = v114 + 1;
        }
        if ((v105 & 1) == 0) {
          int v114 = v113;
        }
        if ((v114 ^ v115) >> 24)
        {
          int v111 = v115;
          int v113 = v114;
        }
        else
        {
          do
          {
            int v111 = v115 << 8;
            if (v112 >= a3) {
              unint64_t v116 = 0;
            }
            else {
              unint64_t v116 = v112;
            }
            *(unsigned char *)(a2 + v116) = HIBYTE(v115);
            int v113 = (v114 << 8) | 0xFF;
            ++v112;
            unsigned int v117 = ((v114 << 8) ^ (v115 << 8)) >> 24;
            int v114 = v113;
            v115 <<= 8;
          }
          while (!v117);
        }
        BOOL v35 = v105 > 1;
        v105 >>= 1;
      }
      while (v35);
    }
    unsigned int v118 = v111 + ((v113 - v111) >> 1) + 1;
    if ((v113 ^ v118) >> 24)
    {
      unsigned int v121 = v113;
      unsigned int v119 = v111 + ((v113 - v111) >> 1) + 1;
    }
    else
    {
      do
      {
        unsigned int v119 = v118 << 8;
        if (v112 >= a3) {
          unint64_t v120 = 0;
        }
        else {
          unint64_t v120 = v112;
        }
        *(unsigned char *)(a2 + v120) = HIBYTE(v118);
        unsigned int v121 = (v113 << 8) | 0xFF;
        ++v112;
        unsigned int v122 = ((v113 << 8) ^ (v118 << 8)) >> 24;
        int v113 = v121;
        v118 <<= 8;
      }
      while (!v122);
    }
    for (uint64_t i = 0; i != v139; ++i)
    {
      unsigned int v124 = *(unsigned __int8 *)(a4 + i) | 0x100;
      do
      {
        unsigned int v125 = v119 + ((v121 - v119) >> 1);
        if ((v124 & 0x80) != 0) {
          unsigned int v126 = v119;
        }
        else {
          unsigned int v126 = v125 + 1;
        }
        if ((v124 & 0x80) == 0) {
          unsigned int v125 = v121;
        }
        if ((v125 ^ v126) >> 24)
        {
          unsigned int v119 = v126;
          unsigned int v121 = v125;
        }
        else
        {
          do
          {
            unsigned int v119 = v126 << 8;
            if (v112 >= a3) {
              unint64_t v127 = 0;
            }
            else {
              unint64_t v127 = v112;
            }
            *(unsigned char *)(a2 + v127) = HIBYTE(v126);
            unsigned int v121 = (v125 << 8) | 0xFF;
            ++v112;
            unsigned int v128 = ((v125 << 8) ^ (v126 << 8)) >> 24;
            unsigned int v125 = v121;
            v126 <<= 8;
          }
          while (!v128);
        }
        BOOL v129 = v124 >= 0x8000;
        v124 *= 2;
      }
      while (!v129);
    }
    while (1)
    {
      int v135 = HIBYTE(v119) + 1;
      if (v135 != HIBYTE(v121)) {
        break;
      }
      int v130 = v119 | 0xFFFFFF;
      unsigned int v131 = (v119 | 0xFFFFFF) - v119;
      if ((v121 & 0xFFFFFF) <= v131) {
        unsigned int v132 = v119;
      }
      else {
        unsigned int v132 = v121 & 0xFF000000;
      }
      if ((v121 & 0xFFFFFF) > v131) {
        int v130 = v121;
      }
      if ((v130 ^ v132) >> 24)
      {
        unsigned int v119 = v132;
        unsigned int v121 = v130;
      }
      else
      {
        do
        {
          unsigned int v119 = v132 << 8;
          if (v112 >= a3) {
            unint64_t v133 = 0;
          }
          else {
            unint64_t v133 = v112;
          }
          *(unsigned char *)(a2 + v133) = HIBYTE(v132);
          unsigned int v121 = (v130 << 8) | 0xFF;
          ++v112;
          unsigned int v134 = ((v130 << 8) ^ (v132 << 8)) >> 24;
          int v130 = v121;
          v132 <<= 8;
        }
        while (!v134);
      }
    }
    if (v112 >= a3) {
      unint64_t v136 = 0;
    }
    else {
      unint64_t v136 = v112;
    }
    *(unsigned char *)(a2 + v136) = v135;
    if (v112 + 1 <= a3) {
      return v112 + 1;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t cosmix_codec_get_decoded_size(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  unsigned int v5 = 0;
  unsigned int v6 = 0;
  int v7 = 0;
  unint64_t v8 = 0;
  do
  {
    if ((v6 ^ v7) >> 24)
    {
      int v9 = v7;
      int v11 = v6;
    }
    else
    {
      do
      {
        int v9 = v7 << 8;
        unsigned int v10 = v6 << 8;
        int v11 = (v6 << 8) | 0xFF;
        if (v8 >= a3) {
          unint64_t v12 = 0;
        }
        else {
          unint64_t v12 = v8;
        }
        unsigned int v5 = *(unsigned __int8 *)(a2 + v12) | (v5 << 8);
        ++v8;
        unsigned int v13 = (v10 ^ (v7 << 8)) >> 24;
        unsigned int v6 = v11;
        v7 <<= 8;
      }
      while (!v13);
    }
    unsigned int v14 = v9 + ((v11 - v9) >> 1);
    v4 |= (unint64_t)(v5 <= v14) << v3;
    if ((2 * v4) >> v3 == 3) {
      break;
    }
    unsigned int v6 = v5 > v14 ? v11 : v9 + ((v11 - v9) >> 1);
    int v7 = v5 > v14 ? v14 + 1 : v9;
    ++v3;
  }
  while (v3 != 64);
  if (v4 < 2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v16 = 1;
  uint64_t v17 = 2;
  do
  {
    uint64_t v18 = v17;
    result += ((uint64_t)(v4 << 63) >> 63) & v16;
    v17 += v16;
    uint64_t v16 = v18;
    BOOL v19 = v4 > 3;
    v4 >>= 1;
  }
  while (v19);
  return result;
}

unint64_t cosmix_codec_decode(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  unsigned int v7 = 0;
  unsigned int v8 = 0;
  unsigned int v9 = 0;
  unint64_t v10 = 0;
  do
  {
    if ((v8 ^ v9) >> 24)
    {
      unsigned int v11 = v9;
      int v13 = v8;
    }
    else
    {
      do
      {
        unsigned int v11 = v9 << 8;
        unsigned int v12 = v8 << 8;
        int v13 = (v8 << 8) | 0xFF;
        if (v10 >= a5) {
          unint64_t v14 = 0;
        }
        else {
          unint64_t v14 = v10;
        }
        unsigned int v7 = *(unsigned __int8 *)(a4 + v14) | (v7 << 8);
        ++v10;
        unsigned int v15 = (v12 ^ (v9 << 8)) >> 24;
        unsigned int v8 = v13;
        v9 <<= 8;
      }
      while (!v15);
    }
    unsigned int v8 = v11 + ((v13 - v11) >> 1);
    uint64_t v16 = v7 <= v8;
    if (v7 > v8) {
      unsigned int v9 = v8 + 1;
    }
    else {
      unsigned int v9 = v11;
    }
    if (v7 > v8) {
      unsigned int v8 = v13;
    }
    v6 |= v16 << v5;
    if ((2 * v6) >> v5 == 3) {
      break;
    }
    ++v5;
  }
  while (v5 != 64);
  if (v6 < 2)
  {
    unint64_t v17 = 0;
  }
  else
  {
    unint64_t v17 = 0;
    uint64_t v18 = 1;
    uint64_t v19 = 2;
    do
    {
      uint64_t v20 = v19;
      v17 += ((uint64_t)(v6 << 63) >> 63) & v18;
      v19 += v18;
      uint64_t v18 = v20;
      BOOL v21 = v6 > 3;
      v6 >>= 1;
    }
    while (v21);
  }
  if (v17 >= a3) {
    unint64_t result = a3;
  }
  else {
    unint64_t result = v17;
  }
  if ((v8 ^ v9) >> 24)
  {
    unsigned int v23 = v9;
    unsigned int v25 = v8;
  }
  else
  {
    do
    {
      unsigned int v23 = v9 << 8;
      unsigned int v24 = v8 << 8;
      unsigned int v25 = (v8 << 8) | 0xFF;
      if (v10 >= a5) {
        unint64_t v26 = 0;
      }
      else {
        unint64_t v26 = v10;
      }
      unsigned int v7 = *(unsigned __int8 *)(a4 + v26) | (v7 << 8);
      ++v10;
      unsigned int v27 = (v24 ^ (v9 << 8)) >> 24;
      unsigned int v8 = v25;
      v9 <<= 8;
    }
    while (!v27);
  }
  unsigned int v28 = v23 + ((v25 - v23) >> 1);
  if (v7 <= v28)
  {
    if (result)
    {
      uint64_t v38 = 0;
      unsigned int v39 = 0;
      unsigned int v40 = 0;
      unsigned int v41 = 0;
      unsigned int v42 = 0;
      unsigned int v43 = 0;
      unsigned int v44 = 0;
      unsigned int v45 = 32;
      unint64_t v88 = result;
      do
      {
        uint64_t v95 = v38;
        char v46 = 32 - *(_DWORD *)(a1 + 16);
        uint64_t v47 = *(void *)(a1 + 8);
        uint64_t v101 = v47 + ((unint64_t)v44 >> v46);
        uint64_t v100 = v47 + ((unint64_t)v43 >> v46);
        uint64_t v99 = v47 + ((unint64_t)v42 >> v46);
        uint64_t v98 = v47 + ((unint64_t)v41 >> v46);
        uint64_t v97 = v47 + ((unint64_t)v40 >> v46);
        uint64_t v96 = v47 + ((unint64_t)v39 >> v46);
        unsigned int v92 = v44;
        unsigned int v93 = v43;
        char v48 = v44;
        char v49 = v43;
        unsigned int v94 = v42;
        char v50 = v42;
        unint64_t v51 = *(void *)a1 + ((unint64_t)v45 << 8);
        int v52 = 8;
        unsigned int v53 = 1;
        unsigned int v91 = v45 << 8;
        do
        {
          unsigned int v54 = *(unsigned __int8 *)(v51 + v53);
          char v55 = v54 ^ v53;
          unsigned int v56 = v54 >> 4;
          if ((v55 & 0xF) != 0) {
            uint64_t v57 = 8;
          }
          else {
            uint64_t v57 = v56;
          }
          unsigned int v58 = *(unsigned __int8 *)(v101 + v53);
          char v59 = v58 ^ v48;
          unsigned int v60 = v58 >> 4;
          if ((v59 & 0xF) != 0) {
            uint64_t v61 = 8;
          }
          else {
            uint64_t v61 = v60;
          }
          unsigned int v62 = *(unsigned __int8 *)(v100 + v53);
          char v63 = v62 ^ v49;
          unsigned int v64 = v62 >> 4;
          if ((v63 & 0xF) != 0) {
            unsigned int v65 = 8;
          }
          else {
            unsigned int v65 = v64;
          }
          unsigned int v66 = *(unsigned __int8 *)(v99 + v53);
          char v67 = v66 ^ v50;
          unsigned int v68 = v66 >> 4;
          if ((v67 & 0xF) != 0) {
            unsigned int v69 = 8;
          }
          else {
            unsigned int v69 = v68;
          }
          unsigned int v70 = *(unsigned __int8 *)(v98 + v53);
          char v71 = v70 ^ v41;
          unsigned int v72 = v70 >> 4;
          if ((v71 & 0xF) != 0) {
            uint64_t v73 = 8;
          }
          else {
            uint64_t v73 = v72;
          }
          unsigned int v74 = *(unsigned __int8 *)(v97 + v53);
          char v75 = v74 ^ v40;
          unsigned int v76 = v74 >> 4;
          if ((v75 & 0xF) != 0) {
            unsigned int v77 = 8;
          }
          else {
            unsigned int v77 = v76;
          }
          unsigned int v78 = *(unsigned __int8 *)(v96 + v53);
          char v79 = v78 ^ v39;
          unsigned int v80 = v78 >> 4;
          if ((v79 & 0xF) != 0) {
            unsigned int v81 = 8;
          }
          else {
            unsigned int v81 = v80;
          }
          if ((v28 ^ v23) >> 24)
          {
            unsigned int v82 = v23;
            int v84 = v28;
          }
          else
          {
            do
            {
              unsigned int v82 = v23 << 8;
              unsigned int v83 = v28 << 8;
              int v84 = (v28 << 8) | 0xFF;
              if (v10 >= a5) {
                unint64_t v85 = 0;
              }
              else {
                unint64_t v85 = v10;
              }
              unsigned int v7 = *(unsigned __int8 *)(a4 + v85) | (v7 << 8);
              ++v10;
              unsigned int v86 = (v83 ^ (v23 << 8)) >> 24;
              unsigned int v28 = v84;
              v23 <<= 8;
            }
            while (!v86);
          }
          unsigned int v87 = v82
              + ((*(unsigned __int8 *)(*(void *)(a1 + 48)
                                     + (v57 << 8)
                                     + (*(unsigned char *)(*(void *)(a1 + 32) + (v61 << 8) + 16 * v65 + v69) & 0xF0)
                                     + ((unint64_t)*(unsigned __int8 *)(*(void *)(a1 + 40)
                                                                             + (v73 << 8)
                                                                             + 16 * v77
                                                                             + v81) >> 4))
                * (unint64_t)(v84 - v82)) >> 8);
          if (v7 > v87) {
            unsigned int v23 = v87 + 1;
          }
          else {
            unsigned int v23 = v82;
          }
          if (v7 > v87) {
            unsigned int v28 = v84;
          }
          else {
            unsigned int v28 = v87;
          }
          unsigned int v53 = (v7 <= v87) | (2 * v53);
          --v52;
        }
        while (v52);
        unsigned int v45 = v53;
        if (v53 >= 0x21u) {
          unsigned int v39 = -1640531535 * (v39 + v53);
        }
        else {
          unsigned int v39 = 0;
        }
        unsigned int v40 = -1640531535 * (v41 + v53);
        unsigned int v41 = -1640531535 * (v94 + v53);
        unsigned int v42 = -1640531535 * (v93 + v53);
        unsigned int v43 = -1640531535 * (v92 + v53);
        unsigned int v44 = -1640531535 * (v53 | v91);
        unint64_t result = v88;
        *(unsigned char *)(a2 + v95) = v53;
        uint64_t v38 = v95 + 1;
      }
      while (v95 + 1 != v88);
    }
  }
  else if (result)
  {
    uint64_t v29 = 0;
    unsigned int v30 = v28 + 1;
    do
    {
      for (unsigned int i = 1; i < 0x100; unsigned int i = v37 | (2 * i))
      {
        if ((v25 ^ v30) >> 24)
        {
          unsigned int v32 = v30;
          int v34 = v25;
        }
        else
        {
          do
          {
            unsigned int v32 = v30 << 8;
            unsigned int v33 = v25 << 8;
            int v34 = (v25 << 8) | 0xFF;
            if (v10 >= a5) {
              unint64_t v35 = 0;
            }
            else {
              unint64_t v35 = v10;
            }
            unsigned int v7 = *(unsigned __int8 *)(a4 + v35) | (v7 << 8);
            ++v10;
            unsigned int v36 = (v33 ^ (v30 << 8)) >> 24;
            unsigned int v25 = v34;
            v30 <<= 8;
          }
          while (!v36);
        }
        unsigned int v25 = v32 + ((v34 - v32) >> 1);
        BOOL v37 = v7 <= v25;
        if (v7 > v25) {
          unsigned int v30 = v25 + 1;
        }
        else {
          unsigned int v30 = v32;
        }
        if (v7 > v25) {
          unsigned int v25 = v34;
        }
      }
      *(unsigned char *)(a2 + v29++) = i;
    }
    while (v29 != result);
  }
  return result;
}

void **cosmix_model_create(unsigned int a1)
{
  if (a1 > 5) {
    return 0;
  }
  uint64_t v2 = (void **)calloc(1uLL, 0xAB020uLL);
  uint64_t v3 = v2;
  if (!v2 || (*((unsigned char *)v2 + 700440) = a1, (unint64_t v4 = (char *)malloc(9 * ((0x100000 << a1) | 0x100u))) == 0))
  {
    cosmix_model_destroy(v3);
    return 0;
  }
  uint64_t v5 = a1 + 20;
  v3[73728] = v4;
  v3[73729] = (void *)v5;
  unint64_t v6 = ((1 << v5) + 256);
  v3[73730] = (void *)v6;
  do
  {
    *(void *)unint64_t v4 = 0x200000001;
    v4[8] = 0;
    v4 += 9;
    --v6;
  }
  while (v6);
  do
  {
    unsigned int v7 = (char *)v3 + v6;
    *(void *)unsigned int v7 = 0x200000001;
    v7[8] = 0;
    v6 += 9;
  }
  while (v6 != 589824);
  for (uint64_t i = 0; i != 36864; i += 9)
  {
    unsigned int v9 = (char *)v3 + i + 589848;
    *(void *)unsigned int v9 = 0x800000004;
    v9[8] = 0;
  }
  for (uint64_t j = 0; j != 36864; j += 9)
  {
    unsigned int v11 = (char *)v3 + j + 626712;
    *(void *)unsigned int v11 = 0x800000004;
    v11[8] = 0;
  }
  for (uint64_t k = 0; k != 36864; k += 9)
  {
    int v13 = (char *)v3 + k + 663576;
    *(void *)int v13 = 0x800000004;
    v13[8] = 0;
  }
  return v3;
}

void cosmix_model_destroy(void **a1)
{
  if (a1)
  {
    free(a1[73728]);
    free(a1);
  }
}

uint64_t cosmix_model_save_codec(uint64_t a1, const char *a2, int a3)
{
  uint64_t v3 = (unsigned __int8 *)(a1 + 700440);
  unint64_t v4 = *(unsigned __int8 *)(a1 + 700440);
  uint64_t v5 = (0x100000 << v4) | 0x100u;
  if (v4 <= 5) {
    size_t v6 = (0x100000 << v4) | 0x100u;
  }
  else {
    size_t v6 = 0;
  }
  if (v4 > 5) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v10 = malloc((0x100000 << v4) | 0x100u);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v11 = v10;
  unsigned int v12 = fopen(a2, "wb");
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  int v13 = v12;
  int __ptr_4 = 1;
  int __ptr = a3;
  HIWORD(__ptr_4) = *v3;
  if (fwrite(&__ptr, 1uLL, 8uLL, v12) != 8) {
    goto LABEL_23;
  }
  uint64_t v14 = 0;
  unsigned int v15 = (unsigned int *)(a1 + 663580);
  uint64_t v16 = (unsigned char *)(a1 + 626720);
  unint64_t v17 = (unsigned char *)(*(void *)(a1 + 589824) + 8);
  do
  {
    v11[v14++] = *v17 & 0xF | (16
                             * tc_quant16[(((unint64_t)*((unsigned int *)v17 - 2) << 16)
                                                       / *((unsigned int *)v17 - 1)) >> 11]);
    v17 += 9;
  }
  while (v5 != v14);
  if (fwrite(v11, 1uLL, v6, v13) == v6)
  {
    uint64_t v18 = 0;
    uint64_t v19 = (unsigned char *)(a1 + 8);
    do
    {
      v11[v18++] = *v19 & 0xF | (16
                               * tc_quant16[(((unint64_t)*((unsigned int *)v19 - 2) << 16)
                                                         / *((unsigned int *)v19 - 1)) >> 11]);
      v19 += 9;
    }
    while (v18 != 0x10000);
    uint64_t v20 = (unsigned char *)(a1 + 589856);
    uint64_t v21 = 0x10000;
    uint64_t v22 = 69632;
    do
    {
      v11[v21] = *v20 & 0xF | (16
                             * tc_quant16[(((unint64_t)*((unsigned int *)v20 - 2) << 16)
                                                       / *((unsigned int *)v20 - 1)) >> 11]);
      v20 += 9;
      ++v21;
    }
    while (v21 != 69632);
    uint64_t v23 = 73728;
    do
    {
      v11[v22] = *v16 & 0xF | (16
                             * tc_quant16[(((unint64_t)*((unsigned int *)v16 - 2) << 16)
                                                       / *((unsigned int *)v16 - 1)) >> 11]);
      v16 += 9;
      ++v22;
    }
    while (v22 != 73728);
    do
    {
      unint64_t v24 = ((unint64_t)*(v15 - 1) << 16) / *v15;
      v11[v23] = ((int)((v24 >> 8) - 1) < 0) + BYTE1(v24);
      unsigned int v15 = (unsigned int *)((char *)v15 + 9);
      ++v23;
    }
    while (v23 != 77824);
    if (fwrite(v11, 1uLL, 0x13000uLL, v13) == 77824) {
      uint64_t v25 = 0;
    }
    else {
      uint64_t v25 = 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_23:
    uint64_t v25 = 0xFFFFFFFFLL;
  }
  free(v11);
  fclose(v13);
  return v25;
}

void *cosmix_codec_map(const char *a1)
{
  memset(&v12, 0, sizeof(v12));
  uint64_t v2 = calloc(1uLL, 0x58uLL);
  uint64_t v3 = v2;
  if (!v2) {
    goto LABEL_3;
  }
  *((_DWORD *)v2 + 20) = -1;
  if (stat(a1, &v12)) {
    goto LABEL_3;
  }
  v3[9] = v12.st_size;
  int v5 = open(a1, 0, *(_OWORD *)&v12.st_dev, *(_OWORD *)&v12.st_uid, *(_OWORD *)&v12.st_atimespec, *(_OWORD *)&v12.st_mtimespec, *(_OWORD *)&v12.st_ctimespec, *(_OWORD *)&v12.st_birthtimespec);
  *((_DWORD *)v3 + 20) = v5;
  if (v5 < 0) {
    goto LABEL_3;
  }
  size_t v6 = mmap(0, v3[9], 1, 2, v5, 0);
  v3[8] = v6;
  if (v6 == (_WORD *)-1)
  {
    v3[8] = 0;
LABEL_3:
    cosmix_codec_unmap(v3);
    return 0;
  }
  uint64_t v7 = v3[9];
  v3[7] = v6;
  if (v7 < 8) {
    goto LABEL_3;
  }
  if (v6[2] != 1) {
    goto LABEL_3;
  }
  unint64_t v8 = (unsigned __int16)v6[3];
  if (v8 > 5) {
    goto LABEL_3;
  }
  uint64_t v9 = (0x100000 << v8) | 0x100u;
  unint64_t v10 = v8 + 20;
  v3[2] = v10;
  v3[3] = ((1 << v10) + 256);
  unsigned int v11 = (char *)v6 + v9 + 8;
  *uint64_t v3 = v11;
  v3[1] = v6 + 4;
  v3[4] = v11 + 0x10000;
  v3[5] = v11 + 69632;
  v3[6] = v11 + 73728;
  if (v11 + 77824 != (char *)v6 + v7) {
    goto LABEL_3;
  }
  return v3;
}

void cosmix_codec_unmap(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 20);
    if ((v2 & 0x80000000) == 0)
    {
      if (*((void *)a1 + 8))
      {
        munmap(*((void **)a1 + 8), *((void *)a1 + 9));
        *((void *)a1 + 8) = 0;
        int v2 = *((_DWORD *)a1 + 20);
      }
      close(v2);
    }
  }

  free(a1);
}

uint64_t cosmix_codec_get_id(uint64_t a1)
{
  return **(unsigned int **)(a1 + 56);
}

uint64_t zlib_decode_scratch_size()
{
  return 131216;
}

size_t zlib_decode_buffer(const Bytef *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5, int a6)
{
  if (a6)
  {
    BOOL v9 = a4 >= 2;
    a4 -= 2;
    if (!v9) {
      return 0;
    }
    int v10 = *a3;
    int v11 = a3[1];
    unsigned int v12 = v11 | (v10 << 8);
    int v13 = v11 & 0x20;
    int v14 = v12 - 31 * ((138547333 * (unint64_t)v12) >> 32);
    BOOL v15 = (v10 & 0xF) == 8 && v13 == 0;
    if (!v15 || v14 != 0) {
      return 0;
    }
    a3 += 2;
  }
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(void *)(a5 + 32) = 8 * a4;
  *(void *)(a5 + 40) = 0;
  *(void *)a5 = a1;
  *(void *)(a5 + 8) = a2;
  *(void *)(a5 + 16) = a4;
  *(void *)(a5 + 24) = a3;
  *(void *)(a5 + 56) = &a1[a2];
  *(void *)(a5 + 64) = a1;
  if (a4 >= 9)
  {
    *(void *)(a5 + 16) = a4 - 8;
    *(void *)(a5 + 32) = 8 * a4 - 64;
    size_t v18 = zlibDecodeBuffer(a5);
    *(void *)(a5 + 16) += 8;
    *(void *)(a5 + 32) += 64;
    if (*(_DWORD *)(a5 + 48) == 11)
    {
      size_t v19 = v18;
      if (v18) {
        goto LABEL_25;
      }
    }
  }
  size_t result = zlibDecodeBufferSafe(a5);
  size_t v19 = result;
  if (result)
  {
LABEL_25:
    unint64_t v20 = (*(void *)(a5 + 40) + 7) & 0xFFFFFFFFFFFFFFF8;
    *(void *)(a5 + 40) = v20;
    if (!a6) {
      return v19;
    }
    unint64_t v21 = *(void *)(a5 + 32);
    BOOL v9 = v21 >= v20;
    unint64_t v22 = v21 - v20;
    if (!v9) {
      unint64_t v22 = 0;
    }
    if (v22 < 0x20) {
      return v19;
    }
    uLong v23 = adler32(0, 0, 0);
    int v24 = adler32(v23, a1, v19);
    size_t result = 0;
    if (bswap32(*(_DWORD *)(*(void *)(a5 + 24) + (*(void *)(a5 + 40) >> 3))) == v24) {
      return v19;
    }
  }
  return result;
}

uint64_t zlib_stream_identify_algorithm()
{
  return 0;
}

uint64_t zlib_stream_get_decode_state_size()
{
  return 459080;
}

uint64_t zlib_stream_get_state_size(uint64_t a1)
{
  if (**(_DWORD **)(a1 + 32)) {
    return 459080;
  }
  else {
    return 0;
  }
}

uint64_t lzx_decode_scratch_size()
{
  return 526320;
}

unint64_t lzx_decode_buffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int *a5)
{
  unint64_t v5 = a2 + 0x7FFF;
  unint64_t v6 = (a2 + 0x7FFF) >> 15;
  if (!v6) {
    return 0;
  }
  unint64_t v7 = a4;
  unint64_t v8 = (4 * v6 - 4);
  if (v8 >= a4) {
    return 0;
  }
  uint64_t v9 = (v5 >> 15);
  if (!(v5 >> 15)) {
    return 0;
  }
  uint64_t v11 = a3;
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  __n_4 = (unsigned __int8 *)(a5 + 4);
  unsigned int v122 = (unsigned __int8 *)(a5 + 65792);
  unsigned int v117 = a5 + 98686;
  unsigned int v119 = (unsigned __int8 *)(a5 + 32898);
  int v111 = 4 * v6 - 4;
  uint64_t v115 = v9;
  do
  {
    if (v14) {
      int v16 = *(_DWORD *)(v11 + 4 * v14 - 4);
    }
    else {
      int v16 = 0;
    }
    unsigned int v17 = v7;
    if (v14 + 1 != v9) {
      unsigned int v17 = *(_DWORD *)(v11 + 4 * v14) + v8;
    }
    if (v17 > v7) {
      return 0;
    }
    uint64_t v116 = v14 + 1;
    __unint64_t n = v17 - (v16 + v8);
    long long v123 = (unsigned __int16 *)(v11 + (v16 + v8));
    unint64_t v124 = (unint64_t)v123 + __n;
    unint64_t v125 = 0;
    uint64_t v126 = 0;
    lzx_decoder_init(a5);
    unint64_t v18 = v15;
    if (v15 + 0x8000 <= a2) {
      unsigned int v19 = 0x8000;
    }
    else {
      unsigned int v19 = a2 - v15;
    }
    unint64_t v20 = v18;
    if (!v19) {
      goto LABEL_139;
    }
    int v118 = 0;
    unint64_t v114 = v18;
    unint64_t v20 = v18;
    do
    {
      unint64_t v21 = v20;
      LODWORD(v22) = __n;
      if (__n == v19)
      {
        int v118 = 1;
        uint64_t v23 = 4;
      }
      else
      {
        int v24 = v126;
        unint64_t v25 = v125;
        if ((int)v126 > 48)
        {
          unsigned int v29 = v126;
        }
        else
        {
          unint64_t v26 = (unint64_t)(v123 + 1);
          int v27 = 48 - v126;
          while (v26 <= v124)
          {
            uint64_t v28 = *(unsigned __int16 *)(v26 - 2);
            unsigned int v29 = v24 + 16;
            LODWORD(v126) = v24 + 16;
            v25 |= v28 << v27;
            long long v123 = (unsigned __int16 *)v26;
            unint64_t v125 = v25;
            v26 += 2;
            v27 -= 16;
            BOOL v106 = v24 < 33;
            v24 += 16;
            if (!v106) {
              goto LABEL_25;
            }
          }
          unsigned int v29 = v24;
          if (v24 < 3) {
            return 0;
          }
        }
LABEL_25:
        uint64_t v23 = v25 >> 61;
        uint64_t v30 = 8 * v25;
        unint64_t v125 = v30;
        unsigned int v31 = v29 - 3;
        LODWORD(v126) = v29 - 3;
        if ((unint64_t)(v23 - 1) > 2) {
          return 0;
        }
        if (v29 > 0x33) {
          goto LABEL_32;
        }
        unsigned int v32 = v29 + 13;
        unint64_t v33 = (unint64_t)(v123 + 1);
        unsigned int v34 = 51 - v29;
        while (v33 <= v124)
        {
          uint64_t v35 = *(unsigned __int16 *)(v33 - 2);
          LODWORD(v126) = v32;
          v30 |= v35 << v34;
          long long v123 = (unsigned __int16 *)v33;
          unint64_t v125 = v30;
          unsigned int v36 = v32 + 16;
          v33 += 2;
          int v37 = v32 - 16;
          v34 -= 16;
          v32 += 16;
          if (v37 >= 33)
          {
            unsigned int v31 = v36 - 16;
            goto LABEL_32;
          }
        }
        unsigned int v31 = v32 - 16;
        if ((int)(v32 - 16) < 1) {
          return 0;
        }
LABEL_32:
        unint64_t v38 = 2 * v30;
        unint64_t v125 = 2 * v30;
        unsigned int v39 = v31 - 1;
        LODWORD(v126) = v31 - 1;
        if (v30 < 0)
        {
          LODWORD(v22) = v19;
        }
        else
        {
          if (v31 > 0x31) {
            goto LABEL_40;
          }
          unsigned int v40 = v31 + 15;
          unint64_t v41 = (unint64_t)(v123 + 1);
          unsigned int v42 = 49 - v31;
          while (v41 <= v124)
          {
            uint64_t v43 = *(unsigned __int16 *)(v41 - 2);
            LODWORD(v126) = v40;
            v38 |= v43 << v42;
            long long v123 = (unsigned __int16 *)v41;
            unint64_t v125 = v38;
            unsigned int v44 = v40 + 16;
            v41 += 2;
            int v45 = v40 - 16;
            v42 -= 16;
            v40 += 16;
            if (v45 >= 33)
            {
              unsigned int v39 = v44 - 16;
              goto LABEL_40;
            }
          }
          unsigned int v39 = v40 - 16;
          if ((int)(v40 - 16) < 16) {
            return 0;
          }
LABEL_40:
          unint64_t v125 = v38 << 16;
          LODWORD(v126) = v39 - 16;
          if (v38 > 0x8000FFFFFFFFFFFFLL) {
            return 0;
          }
          unint64_t v22 = HIWORD(v38);
        }
      }
      if (v19 < v22) {
        return 0;
      }
      v20 += v22;
      if (v20 > a2) {
        return 0;
      }
      size_t v46 = v22;
      if (v23 != 3)
      {
        if (v23 == 4)
        {
          if ((v126 & 7) != 0) {
            return 0;
          }
          uint64_t v47 = (char *)v123 - ((int)v126 >> 3);
          long long v123 = (unsigned __int16 *)v47;
          unint64_t v125 = 0;
          LODWORD(v126) = 0;
          char v48 = &v47[v22];
          if ((unint64_t)v48 > v124) {
            return 0;
          }
          memcpy((void *)(a1 + v21), v47, v22);
          long long v123 = (unsigned __int16 *)v48;
          goto LABEL_137;
        }
        if (!v22) {
          goto LABEL_137;
        }
        if (v23 == 2)
        {
          uint64_t v56 = 0;
          int v57 = v126;
          unint64_t v59 = v124;
          unint64_t v58 = v125;
          unsigned int v60 = v123;
          do
          {
            if (v57 > 48)
            {
              unsigned int v62 = v60;
              int v64 = v57;
            }
            else
            {
              int v61 = 48 - v57;
              while (1)
              {
                unsigned int v62 = v60 + 1;
                if ((unint64_t)(v60 + 1) > v59) {
                  break;
                }
                uint64_t v63 = *v60;
                int v64 = v57 + 16;
                LODWORD(v126) = v57 + 16;
                v58 |= v63 << v61;
                long long v123 = v62;
                unint64_t v125 = v58;
                v61 -= 16;
                unsigned int v60 = v62;
                BOOL v106 = v57 < 33;
                v57 += 16;
                if (!v106) {
                  goto LABEL_66;
                }
              }
              unsigned int v62 = v60;
              int v64 = v57;
              if (v57 < 3) {
                return 0;
              }
            }
LABEL_66:
            unint64_t v65 = v58 >> 61;
            v58 *= 8;
            unint64_t v125 = v58;
            int v57 = v64 - 3;
            LODWORD(v126) = v64 - 3;
            v122[v56++] = v65;
            unsigned int v60 = v62;
          }
          while (v56 != 8);
          lzx_huffman_tree_compute_lookup_from_code_len(v122);
        }
        if (!lzx_huffman_tree_update_tree_using_pre_tree_encoding((uint64_t)__n_4, (uint64_t)&v123, 0, 256, v117)&& !lzx_huffman_tree_update_tree_using_pre_tree_encoding((uint64_t)__n_4, (uint64_t)&v123, 0x100uLL, 240, v117)&& !lzx_huffman_tree_compute_lookup_from_code_len(__n_4)&& !lzx_huffman_tree_update_tree_using_pre_tree_encoding((uint64_t)v119, (uint64_t)&v123, 0, 249, v117)&& !lzx_huffman_tree_compute_lookup_from_code_len(v119))
        {
          size_t v66 = v46;
          while (1)
          {
            v128[0] = 0;
            if (lzx_huffman_tree_read_code(v128, (uint64_t)&v123, (uint64_t)__n_4)) {
              return 0;
            }
            if (v128[0] <= 0xFFu)
            {
              *(unsigned char *)(a1 + v21++) = v128[0];
              --v66;
              goto LABEL_126;
            }
            uint64_t v67 = v128[0] & 7;
            if (v67 == 7)
            {
              unsigned __int16 v127 = 0;
              if (lzx_huffman_tree_read_code(&v127, (uint64_t)&v123, (uint64_t)v119)) {
                return 0;
              }
              unint64_t v68 = v127 + 9;
            }
            else
            {
              unint64_t v68 = v67 + 2;
            }
            BOOL v90 = v66 >= v68;
            v66 -= v68;
            if (!v90) {
              return 0;
            }
            int v69 = v128[0] - 256;
            uint64_t v70 = (uint64_t)v69 >> 3;
            if (v70 == 2)
            {
              unsigned int v71 = a5[2];
              a5[2] = *a5;
            }
            else
            {
              if (v70 != 1)
              {
                if (v70)
                {
                  int v75 = position_slot_extra_bits[v70];
                  int v73 = position_slot_base_position[v70];
                  unsigned __int16 v127 = 0;
                  if (v23 == 2 && (unint64_t)(v70 - 8) <= 0x15)
                  {
                    int v76 = v75 - 3;
                    if ((v75 - 3) > 0x30) {
                      return 0;
                    }
                    int v110 = v73;
                    if (v75 == 3)
                    {
                      LODWORD(v109) = 0;
                    }
                    else
                    {
                      int v77 = v126;
                      if ((int)v126 <= 48)
                      {
                        unint64_t v78 = v125;
                        unint64_t v79 = (unint64_t)(v123 + 1);
                        int v80 = 48 - v126;
                        while (v79 <= v124)
                        {
                          uint64_t v81 = *(unsigned __int16 *)(v79 - 2);
                          int v82 = v77 + 16;
                          LODWORD(v126) = v77 + 16;
                          v78 |= v81 << v80;
                          long long v123 = (unsigned __int16 *)v79;
                          unint64_t v125 = v78;
                          v79 += 2;
                          v80 -= 16;
                          BOOL v106 = v77 < 33;
                          v77 += 16;
                          if (!v106) {
                            goto LABEL_110;
                          }
                        }
                      }
                      int v82 = v77;
LABEL_110:
                      if (v82 < v76) {
                        return 0;
                      }
                      unint64_t v109 = v125 >> (67 - v75);
                      v125 <<= v76;
                      LODWORD(v126) = v82 - v76;
                    }
                    int v89 = lzx_huffman_tree_read_code(&v127, (uint64_t)&v123, (uint64_t)v122);
                    int v73 = v110;
                    if (v89) {
                      return 0;
                    }
                    LODWORD(v74) = 8 * v109;
                    int v72 = v127;
                  }
                  else if (v69 >= 0x20)
                  {
                    int v83 = v126;
                    if ((int)v126 <= 48)
                    {
                      unint64_t v84 = v125;
                      unint64_t v85 = (unint64_t)(v123 + 1);
                      int v86 = 48 - v126;
                      while (v85 <= v124)
                      {
                        uint64_t v87 = *(unsigned __int16 *)(v85 - 2);
                        int v88 = v83 + 16;
                        LODWORD(v126) = v83 + 16;
                        v84 |= v87 << v86;
                        long long v123 = (unsigned __int16 *)v85;
                        unint64_t v125 = v84;
                        v85 += 2;
                        v86 -= 16;
                        BOOL v106 = v83 < 33;
                        v83 += 16;
                        if (!v106) {
                          goto LABEL_113;
                        }
                      }
                    }
                    int v88 = v83;
LABEL_113:
                    if (v88 < v75) {
                      return 0;
                    }
                    int v72 = 0;
                    unint64_t v74 = v125 >> -(char)v75;
                    v125 <<= v75;
                    LODWORD(v126) = v88 - v75;
                  }
                  else
                  {
                    int v72 = 0;
LABEL_92:
                    LODWORD(v74) = 0;
                  }
                  unsigned int v71 = v73 + v72 + v74 - 2;
                  *(void *)(a5 + 1) = *(void *)a5;
                  *a5 = v71;
                  goto LABEL_119;
                }
                unsigned int v71 = *a5;
                if (!*a5) {
                  goto LABEL_91;
                }
                goto LABEL_119;
              }
              unsigned int v71 = a5[1];
              a5[1] = *a5;
            }
            *a5 = v71;
            if (!v71)
            {
LABEL_91:
              int v72 = 0;
              int v73 = 0;
              goto LABEL_92;
            }
LABEL_119:
            if (v71) {
              BOOL v90 = v21 >= v71;
            }
            else {
              BOOL v90 = 0;
            }
            if (!v90) {
              return 0;
            }
            uint64_t v91 = a1 - v71;
            do
            {
              *(unsigned char *)(a1 + v21) = *(unsigned char *)(v91 + v21);
              ++v21;
              --v68;
            }
            while (v68);
LABEL_126:
            if (!v66) {
              goto LABEL_137;
            }
          }
        }
        return 0;
      }
      int v49 = v126;
      int v50 = v126 & 0xF;
      if ((v126 & 0xF) == 0) {
        int v50 = 16;
      }
      if ((int)v126 <= 48)
      {
        unint64_t v51 = v125;
        unint64_t v52 = (unint64_t)(v123 + 1);
        int v53 = 48 - v126;
        while (v52 <= v124)
        {
          uint64_t v54 = *(unsigned __int16 *)(v52 - 2);
          int v55 = v49 + 16;
          LODWORD(v126) = v49 + 16;
          v51 |= v54 << v53;
          long long v123 = (unsigned __int16 *)v52;
          unint64_t v125 = v51;
          v52 += 2;
          v53 -= 16;
          BOOL v106 = v49 < 33;
          v49 += 16;
          if (!v106) {
            goto LABEL_129;
          }
        }
      }
      int v55 = v49;
LABEL_129:
      BOOL v92 = __OFSUB__(v55, v50);
      int v93 = v55 - v50;
      if (v93 < 0 != v92) {
        return 0;
      }
      if ((v93 & 7) != 0) {
        return 0;
      }
      unint64_t v94 = v124;
      uint64_t v95 = (unsigned __int16 *)((char *)v123 - (v93 >> 3));
      long long v123 = v95;
      unint64_t v125 = 0;
      LODWORD(v126) = 0;
      uint64_t v96 = (char *)(v95 + 6);
      if ((unint64_t)(v95 + 6) > v124) {
        return 0;
      }
      unsigned int v97 = *((_DWORD *)v95 + 2);
      *(void *)a5 = *(void *)v95;
      a5[2] = v97;
      long long v123 = v95 + 6;
      unint64_t v125 = 0;
      LODWORD(v126) = 0;
      uint64_t v98 = &v96[v46];
      if ((unint64_t)&v96[v46] > v94) {
        return 0;
      }
      memcpy((void *)(a1 + v21), v96, v46);
      long long v123 = (unsigned __int16 *)v98;
      if ((v46 & 1) != 0 && (char *)v94 != v98)
      {
        unint64_t v125 = 0;
        LODWORD(v126) = 0;
        if ((unint64_t)(v98 + 1) > v94) {
          return 0;
        }
        long long v123 = (unsigned __int16 *)(v98 + 1);
      }
LABEL_137:
      v19 -= v46;
    }
    while (v19);
    uint64_t v11 = a3;
    unint64_t v7 = a4;
    LODWORD(v8) = v111;
    unint64_t v18 = v114;
    if (!v118)
    {
LABEL_139:
      int v99 = v20 - v18;
      if ((int)v20 - (int)v18 >= 11)
      {
        unint64_t v100 = v18;
        unsigned int v101 = 0;
        uint64_t v102 = a1 + v100;
        do
        {
          unint64_t v103 = (unsigned __int8 *)(v102 + v101);
          if (*v103 == 232)
          {
            int v104 = *(_DWORD *)(v103 + 1);
            int v105 = -v101;
            BOOL v106 = v104 >= (signed int)-v101 && v104 < 12000000;
            if (v106)
            {
              if (v104 < 0) {
                int v105 = 12000000;
              }
              *(_DWORD *)(v103 + 1) = v105 + v104;
            }
            int v107 = 5;
          }
          else
          {
            int v107 = 1;
          }
          v101 += v107;
        }
        while ((int)(v101 + 10) < v99);
      }
    }
    uint64_t v9 = v115;
    uint64_t v14 = v116;
    unint64_t v15 = v20;
  }
  while (v116 != v115);
  return v20;
}

unint64_t lzfse_encode_scratch_size(int a1)
{
  unint64_t ScratchSize = lzfseEncodeGetScratchSize(a1);
  if (a1 == 2050) {
    int v3 = 2305;
  }
  else {
    int v3 = 2304;
  }
  unint64_t result = lzvn_encode_scratch_size(v3);
  if (ScratchSize > result) {
    return ScratchSize;
  }
  return result;
}

char *lzfse_encode_buffer(uint64_t a1, unint64_t a2, const float *__src, size_t __n, int8x16_t *a5, int a6)
{
  int v10 = __n;
  if (__n >= 8)
  {
    if (__n > 0xFFF)
    {
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v19 = 0u;
      int v10 = __n;
      if (!lzfseEncodeInitState((uint64_t)&v19, a6, (uint64_t)a5))
      {
        *((void *)&v21 + 1) = a1;
        *(void *)&long long v22 = a1;
        *((void *)&v22 + 1) = a1 + a2;
        size_t v16 = __n;
        int v10 = __n;
        *(void *)&long long v19 = __src;
        *((void *)&v20 + 1) = 0;
        if (__n < 0x7FFFFFFF)
        {
LABEL_21:
          *((void *)&v19 + 1) = v16;
          *(void *)&long long v21 = v16 - 8;
          if (!lzfseEncodeBase((uint64_t)&v19) && !lzfseEncodeFinish((uint64_t *)&v19)) {
            return (char *)(*((void *)&v21 + 1) - a1);
          }
        }
        else
        {
          *((void *)&v19 + 1) = 0x40000;
          *(void *)&long long v21 = 262136;
          int v10 = __n;
          if (!lzfseEncodeBase((uint64_t)&v19))
          {
            size_t v17 = __n;
            while (1)
            {
              *((void *)&v19 + 1) = 0x80000;
              *(void *)&long long v21 = 524280;
              if (lzfseEncodeBase((uint64_t)&v19)) {
                break;
              }
              lzfseEncodeTranslateState((uint64_t)&v19, 0x40000uLL);
              size_t v16 = v17 - 0x40000;
              unint64_t v18 = (v17 - 0x80000) >> 18;
              v17 -= 0x40000;
              if (!v18)
              {
                int v10 = v16 - 0x40000;
                goto LABEL_21;
              }
            }
            int v10 = v17 - 0x40000;
          }
        }
      }
    }
    else
    {
      int v10 = __n;
      if (a2 >= 0x11)
      {
        uint64_t v11 = a1 + 12;
        unint64_t v12 = a2 - 16;
        int v13 = a6 == 2050 ? 2305 : 2304;
        uint64_t v14 = lzvn_encode_buffer((char *)(a1 + 12), v12, __src, __n, a5, v13);
        int v10 = __n;
        if (v14)
        {
          int v10 = __n;
          if ((unint64_t)v14 < __n)
          {
            *(_DWORD *)a1 = 1853388386;
            *(_DWORD *)(a1 + 4) = __n;
            *(_DWORD *)(a1 + 8) = v14;
            *(_DWORD *)&v14[v11] = 611874402;
            return v14 + 16;
          }
        }
      }
    }
  }
  unint64_t result = 0;
  if (__n <= 0x7FFFFFFE && __n + 12 <= a2)
  {
    *(_DWORD *)a1 = 762869346;
    *(_DWORD *)(a1 + 4) = v10;
    memcpy((void *)(a1 + 8), __src, __n);
    *(_DWORD *)(a1 + 8 + __n) = 611874402;
    return (char *)(__n + 12);
  }
  return result;
}

unint64_t BrotliCreateBackwardReferences(unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, double a5, double a6, int32x4_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int *a11, unint64_t *a12, _DWORD *a13, void *a14, void *a15)
{
  int v15 = *(_DWORD *)(a9 + 40);
  if (v15 <= 34)
  {
    switch(v15)
    {
      case 2:
        unint64_t result = CreateBackwardReferencesNH2(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 3:
        unint64_t result = CreateBackwardReferencesNH3(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 4:
        unint64_t result = CreateBackwardReferencesNH4(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 5:
        unint64_t result = CreateBackwardReferencesNH5(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case 6:
        unint64_t result = CreateBackwardReferencesNH6(result, a2, a3, a4, a9, a10, a11, a12, a13, a14, a15);
        break;
      default:
        return result;
    }
  }
  else if (v15 > 53)
  {
    switch(v15)
    {
      case '6':
        return CreateBackwardReferencesNH54(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
      case '7':
        return CreateBackwardReferencesNH55(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
      case 'A':
        return CreateBackwardReferencesNH65(result, a2, a3, a4, a9, a10, a11, a12, a13, a14, a15);
    }
  }
  else
  {
    switch(v15)
    {
      case '#':
        unint64_t result = CreateBackwardReferencesNH35(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case '(':
        unint64_t result = CreateBackwardReferencesNH40(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case ')':
        unint64_t result = CreateBackwardReferencesNH41(result, a2, a3, a4, a9, a10, a11, a12, (uint64_t)a13, a14, a15);
        break;
      case '*':
        unint64_t result = CreateBackwardReferencesNH42(result, a2, a3, a4, a9, a10, a11, a12, a5, a6, a7, (uint64_t)a13, a14, a15);
        break;
      default:
        return result;
    }
  }
  return result;
}

unint64_t CreateBackwardReferencesNH2(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  unint64_t v14 = a2 + result - 7;
  if (result <= 7) {
    uint64_t v15 = a2;
  }
  else {
    uint64_t v15 = a2 + result - 7;
  }
  unint64_t v147 = v15;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v16 = 512;
  }
  else {
    uint64_t v16 = 64;
  }
  if (a2 + 8 >= v13)
  {
    uint64_t v150 = a9;
    unint64_t v101 = a2;
    goto LABEL_230;
  }
  uint64_t v145 = v16;
  unint64_t v17 = (1 << *(_DWORD *)(a5 + 8)) - 16;
  uint64_t v154 = *(void *)(a5 + 16);
  unint64_t v18 = v16 + a2;
  unint64_t v152 = a2 + result;
  uint64_t v19 = 4 * v16;
  uint64_t v20 = *(void *)(a6 + 56);
  uint64_t v149 = a7;
  uint64_t v150 = a9;
  uint64_t v21 = a6;
  uint64_t v146 = a2 + result - 7;
  uint64_t v144 = 4 * v16;
  do
  {
    unint64_t v22 = v13 - v11;
    if (v11 >= v17) {
      unint64_t v23 = v17;
    }
    else {
      unint64_t v23 = v11;
    }
    if (v11 + v154 >= v17) {
      unint64_t v24 = v17;
    }
    else {
      unint64_t v24 = v11 + v154;
    }
    unint64_t v25 = *(void *)(a5 + 80);
    unint64_t v26 = v11 & a4;
    long long v27 = (void *)(a3 + (v11 & a4));
    int v28 = *(unsigned __int8 *)v27;
    unint64_t v29 = (0xBD1E35A7BD000000 * *v27) >> 48;
    unint64_t result = *a7;
    if (v11 < result || (uint64_t v30 = (unsigned __int8 *)(a3 + (a4 & (v11 - result))), v28 != *v30))
    {
LABEL_27:
      uint64_t v39 = *(unsigned int *)(v20 + 4 * v29);
      *(_DWORD *)(v20 + 4 * v29) = v11;
      unint64_t result = v11 - v39;
      unsigned int v40 = (unsigned __int8 *)(a3 + (v39 & a4));
      if (v28 != *v40 || v11 == v39 || result > v23) {
        goto LABEL_122;
      }
      if (v22 < 8)
      {
        unint64_t v33 = 0;
        int v45 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_212:
        unint64_t v136 = v22 & 7;
        if ((v22 & 7) != 0)
        {
          unint64_t v137 = v33 | v136;
          while (v40[v33] == *v45)
          {
            ++v45;
            ++v33;
            if (!--v136)
            {
              unint64_t v33 = v137;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v43 = 0;
        unint64_t v44 = v22 >> 3;
        unint64_t v33 = v22 & 0xFFFFFFFFFFFFFFF8;
        int v45 = (unsigned __int8 *)(a3 + v26 + (v22 & 0xFFFFFFFFFFFFFFF8));
        while (1)
        {
          uint64_t v46 = v27[v43];
          uint64_t v47 = *(void *)&v40[v43 * 8];
          if (v46 != v47) {
            break;
          }
          ++v43;
          if (!--v44) {
            goto LABEL_212;
          }
        }
        unint64_t v33 = v43 * 8 + (__clz(__rbit64(v47 ^ v46)) >> 3);
      }
      if (v33 < 4 || (unint64_t v37 = 135 * v33 - 30 * (__clz(result) ^ 0x1F) + 1920, v37 <= 0x7E4))
      {
        uint64_t v95 = *(void *)(v21 + 48);
        unint64_t v97 = *(void *)(v95 + 8);
        unint64_t v96 = *(void *)(v95 + 16);
        if (v96 < v97 >> 7) {
          goto LABEL_122;
        }
        uint64_t v98 = ((506832829 * *(_DWORD *)v27) >> 17) & 0x7FFELL;
        uint64_t v99 = *(void *)(a5 + 120);
        *(void *)(v95 + 8) = v97 + 1;
        unint64_t v100 = *(unsigned __int8 *)(v99 + v98);
        if (!*(unsigned char *)(v99 + v98) || v22 < v100) {
          goto LABEL_122;
        }
        unint64_t result = *(unsigned __int16 *)(*(void *)(a5 + 112) + 2 * v98);
        uint64_t v115 = *(void *)(a5 + 88);
        uint64_t v116 = *(unsigned int *)(v115 + 4 * v100 + 32);
        uint64_t v117 = *(void *)(v115 + 168);
        int v118 = (unsigned __int8 *)(v117 + v116 + result * *(unsigned __int8 *)(v99 + v98));
        if (v100 < 8)
        {
          unint64_t v33 = 0;
LABEL_224:
          unint64_t v140 = v100 & 7;
          if ((v100 & 7) != 0)
          {
            unint64_t v141 = v33 | v140;
            while (*((unsigned __int8 *)v27 + v33) == *v118)
            {
              ++v118;
              ++v33;
              if (!--v140)
              {
                unint64_t v33 = v141;
                break;
              }
            }
          }
        }
        else
        {
          unint64_t v119 = 0;
          unint64_t v33 = v100 & 0xF8;
          unint64_t v120 = (unsigned __int8 *)(v117 + result * (unint64_t)v100 + v33 + v116);
          while (1)
          {
            uint64_t v121 = *(void *)&v118[v119];
            uint64_t v122 = v27[v119 / 8];
            if (v121 != v122) {
              break;
            }
            v119 += 8;
            if (v33 == v119)
            {
              int v118 = v120;
              goto LABEL_224;
            }
          }
          unint64_t v33 = v119 + (__clz(__rbit64(v122 ^ v121)) >> 3);
        }
        uint64_t v21 = a6;
        if (!v33
          || v33 + *(unsigned int *)(a5 + 100) <= v100
          || (result += v24
                      + 1
                      + ((((*(void *)(a5 + 104) >> (6 * (v100 - v33))) & 0x3FLL)
                        + 4 * (v100 - v33)) << *(unsigned char *)(v115 + v100)),
              result > v25)
          || (unint64_t v37 = 135 * v33 - 30 * (__clz(result) ^ 0x1F) + 1920, v37 < 0x7E4)
          || (*(void *)(v95 + 16) = v96 + 1, v37 == 2020))
        {
LABEL_122:
          ++v12;
          unint64_t v101 = v11 + 1;
          if (v11 + 1 > v18)
          {
            if (v101 <= v18 + v19)
            {
              if (v11 + 9 >= v14) {
                unint64_t v103 = v14;
              }
              else {
                unint64_t v103 = v11 + 9;
              }
              while (v101 < v103)
              {
                *(_DWORD *)(v20 + (((0xBD1E35A7BD000000 * *(void *)(a3 + (v101 & a4))) >> 46) & 0x3FFFC)) = v101;
                v12 += 2;
                v101 += 2;
              }
            }
            else
            {
              if (v11 + 17 >= v14) {
                unint64_t v102 = v14;
              }
              else {
                unint64_t v102 = v11 + 17;
              }
              while (v101 < v102)
              {
                *(_DWORD *)(v20 + (((0xBD1E35A7BD000000 * *(void *)(a3 + (v101 & a4))) >> 46) & 0x3FFFC)) = v101;
                v12 += 4;
                v101 += 4;
              }
            }
          }
          goto LABEL_205;
        }
        unint64_t v148 = v25;
        int v38 = v100 - v33;
      }
      else
      {
        unint64_t v148 = v25;
        int v38 = 0;
      }
      goto LABEL_43;
    }
    if (v22 >= 8)
    {
      uint64_t v31 = 0;
      unint64_t v32 = v22 >> 3;
      unint64_t v33 = v22 & 0xFFFFFFFFFFFFFFF8;
      unsigned int v34 = (unsigned __int8 *)(a3 + v26 + (v22 & 0xFFFFFFFFFFFFFFF8));
      while (1)
      {
        uint64_t v35 = v27[v31];
        uint64_t v36 = *(void *)&v30[v31 * 8];
        if (v35 != v36) {
          break;
        }
        ++v31;
        if (!--v32)
        {
          uint64_t v21 = a6;
          goto LABEL_218;
        }
      }
      unint64_t v33 = v31 * 8 + (__clz(__rbit64(v36 ^ v35)) >> 3);
      goto LABEL_23;
    }
    unint64_t v33 = 0;
    unsigned int v34 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_218:
    unint64_t v138 = v22 & 7;
    if ((v22 & 7) != 0)
    {
      unint64_t v139 = v33 | v138;
      while (v30[v33] == *v34)
      {
        ++v34;
        ++v33;
        if (!--v138)
        {
          unint64_t v33 = v139;
          break;
        }
      }
LABEL_23:
      uint64_t v21 = a6;
    }
    if (v33 < 4) {
      goto LABEL_27;
    }
    unint64_t v37 = 135 * v33 + 1935;
    if (v37 < 0x7E5) {
      goto LABEL_27;
    }
    unint64_t v148 = *(void *)(a5 + 80);
    int v38 = 0;
    *(_DWORD *)(v20 + 4 * v29) = v11;
LABEL_43:
    unsigned int v48 = 0;
    unint64_t v49 = *v149;
    uint64_t v50 = a5;
    while (1)
    {
      --v22;
      unint64_t v51 = v33 - 1;
      if (v33 - 1 >= v22) {
        unint64_t v51 = v22;
      }
      if (*(int *)(v50 + 4) >= 5) {
        unint64_t v52 = 0;
      }
      else {
        unint64_t v52 = v51;
      }
      unint64_t v53 = v11 + 1;
      if (v11 + 1 < v17) {
        unint64_t v54 = v11 + 1;
      }
      else {
        unint64_t v54 = v17;
      }
      unint64_t v55 = v53 + v154;
      if (v53 + v154 >= v17) {
        unint64_t v55 = v17;
      }
      int v56 = *(unsigned __int8 *)(a3 + v52 + (v53 & a4));
      int v57 = (void *)(a3 + (v53 & a4));
      unint64_t v58 = (0xBD1E35A7BD000000 * *v57) >> 48;
      if (v53 >= v49)
      {
        unint64_t v59 = a4 & (v53 - v49);
        if (v56 == *(unsigned __int8 *)(a3 + v59 + v52))
        {
          uint64_t v60 = a3 + v59;
          if (v22 < 8)
          {
            unint64_t v61 = 0;
            unint64_t v65 = (unsigned __int8 *)(a3 + (v53 & a4));
LABEL_109:
            unint64_t v93 = v22 & 7;
            if ((v22 & 7) != 0)
            {
              do
              {
                if (*(unsigned __int8 *)(v60 + v61) != *v65) {
                  break;
                }
                ++v65;
                ++v61;
                --v93;
              }
              while (v93);
            }
          }
          else
          {
            unint64_t v61 = 0;
            unint64_t v62 = v22 >> 3;
            while (1)
            {
              uint64_t v63 = *(void *)((char *)v57 + v61);
              uint64_t v64 = *(void *)(v60 + v61);
              if (v63 != v64) {
                break;
              }
              v61 += 8;
              if (!--v62)
              {
                unint64_t v65 = (unsigned __int8 *)v57 + v61;
                uint64_t v50 = a5;
                goto LABEL_109;
              }
            }
            v61 += __clz(__rbit64(v64 ^ v63)) >> 3;
            uint64_t v50 = a5;
          }
          unint64_t v13 = v152;
          if (v61 >= 4)
          {
            unint64_t v66 = 135 * v61 + 1935;
            if (v66 >= 0x7E5)
            {
              int v67 = 0;
              *(_DWORD *)(v20 + 4 * v58) = v53;
              unint64_t v68 = v49;
              goto LABEL_87;
            }
          }
        }
      }
      uint64_t v69 = *(unsigned int *)(v20 + 4 * v58);
      *(_DWORD *)(v20 + 4 * v58) = v53;
      if (v56 != *(unsigned __int8 *)(a3 + (v69 & a4) + v52)
        || ((v68 = v53 - v69, v53 != v69) ? (BOOL v70 = v68 > v54) : (BOOL v70 = 1), v70))
      {
        unint64_t v68 = 0;
        int v67 = 0;
        unint64_t v61 = v52;
        unint64_t v66 = 2020;
        goto LABEL_87;
      }
      uint64_t v71 = a3 + (v69 & a4);
      if (v22 < 8)
      {
        unint64_t v61 = 0;
        int v75 = (unsigned __int8 *)(a3 + (v53 & a4));
LABEL_104:
        unint64_t v92 = v22 & 7;
        if ((v22 & 7) != 0)
        {
          do
          {
            if (*(unsigned __int8 *)(v71 + v61) != *v75) {
              break;
            }
            ++v75;
            ++v61;
            --v92;
          }
          while (v92);
        }
      }
      else
      {
        unint64_t v61 = 0;
        unint64_t v72 = v22 >> 3;
        while (1)
        {
          uint64_t v73 = *(void *)((char *)v57 + v61);
          uint64_t v74 = *(void *)(v71 + v61);
          if (v73 != v74) {
            break;
          }
          v61 += 8;
          if (!--v72)
          {
            int v75 = (unsigned __int8 *)v57 + v61;
            goto LABEL_104;
          }
        }
        v61 += __clz(__rbit64(v74 ^ v73)) >> 3;
      }
      if (v61 >= 4)
      {
        unint64_t v66 = 135 * v61 - 30 * (__clz(v68) ^ 0x1F) + 1920;
        if (v66 > 0x7E4)
        {
          int v67 = 0;
          goto LABEL_87;
        }
      }
      uint64_t v76 = *(void *)(v21 + 48);
      unint64_t v77 = *(void *)(v76 + 8);
      unint64_t v78 = *(void *)(v76 + 16);
      if (v78 < v77 >> 7) {
        goto LABEL_81;
      }
      uint64_t v79 = ((506832829 * *(_DWORD *)v57) >> 17) & 0x7FFELL;
      uint64_t v80 = *(void *)(v50 + 120);
      *(void *)(v76 + 8) = v77 + 1;
      unint64_t v81 = *(unsigned __int8 *)(v80 + v79);
      if (!*(unsigned char *)(v80 + v79) || v22 < v81)
      {
LABEL_85:
        unint64_t v68 = 0;
        int v67 = 0;
        unint64_t v61 = v52;
        unint64_t v66 = 2020;
        uint64_t v21 = a6;
        goto LABEL_86;
      }
      uint64_t v83 = *(unsigned __int16 *)(*(void *)(v50 + 112) + 2 * v79);
      uint64_t v84 = *(void *)(v50 + 88);
      uint64_t v85 = *(unsigned int *)(v84 + 4 * v81 + 32);
      uint64_t v86 = *(void *)(v84 + 168);
      uint64_t v87 = (unsigned __int8 *)(v86 + v85 + v83 * (unint64_t)v81);
      if (v81 < 8)
      {
        unint64_t v61 = 0;
LABEL_114:
        unint64_t v94 = v81 & 7;
        uint64_t v21 = a6;
        if ((v81 & 7) == 0) {
          goto LABEL_98;
        }
        unint64_t v142 = v61 | v94;
        while (*((unsigned __int8 *)v57 + v61) == *v87)
        {
          ++v87;
          ++v61;
          if (!--v94)
          {
            unint64_t v61 = v142;
            break;
          }
        }
      }
      else
      {
        unint64_t v88 = 0;
        unint64_t v61 = v81 & 0xF8;
        int v89 = (unsigned __int8 *)(v86 + v83 * (unint64_t)v81 + v61 + v85);
        while (1)
        {
          uint64_t v90 = *(void *)&v87[v88];
          uint64_t v91 = v57[v88 / 8];
          if (v90 != v91) {
            break;
          }
          v88 += 8;
          if (v61 == v88)
          {
            uint64_t v87 = v89;
            uint64_t v50 = a5;
            goto LABEL_114;
          }
        }
        unint64_t v61 = v88 + (__clz(__rbit64(v91 ^ v90)) >> 3);
        uint64_t v21 = a6;
      }
      uint64_t v50 = a5;
LABEL_98:
      int v67 = 0;
      unint64_t v68 = 0;
      if (!v61 || v61 + *(unsigned int *)(v50 + 100) <= v81) {
        goto LABEL_82;
      }
      unint64_t v68 = v55
          + 1
          + v83
          + ((((*(void *)(v50 + 104) >> (6 * (v81 - v61))) & 0x3FLL)
            + 4 * (v81 - v61)) << *(unsigned char *)(v84 + v81));
      if (v68 > v148) {
        goto LABEL_85;
      }
      unint64_t v66 = 135 * v61 - 30 * (__clz(v68) ^ 0x1F) + 1920;
      uint64_t v21 = a6;
      if (v66 >= 0x7E4)
      {
        int v67 = v81 - v61;
        *(void *)(v76 + 16) = v78 + 1;
        goto LABEL_86;
      }
LABEL_81:
      unint64_t v68 = 0;
      int v67 = 0;
LABEL_82:
      unint64_t v61 = v52;
      unint64_t v66 = 2020;
LABEL_86:
      unint64_t v13 = v152;
LABEL_87:
      if (v66 < v37 + 175) {
        break;
      }
      ++v12;
      if (v48 <= 2)
      {
        unint64_t v82 = v11 + 9;
        ++v48;
        unint64_t result = v68;
        unint64_t v37 = v66;
        int v38 = v67;
        unint64_t v33 = v61;
        ++v11;
        if (v82 < v13) {
          continue;
        }
      }
      goto LABEL_137;
    }
    unint64_t v55 = v11 + v154;
    if (v11 + v154 >= v17) {
      unint64_t v55 = v17;
    }
    unint64_t v68 = result;
    int v67 = v38;
    unint64_t v61 = v33;
    unint64_t v53 = v11;
LABEL_137:
    a7 = v149;
    if (v68 > v55)
    {
LABEL_138:
      unint64_t v104 = v68 + 15;
      goto LABEL_139;
    }
    uint64_t v105 = *v149;
    if (v68 == v105)
    {
      unint64_t v104 = 0;
      goto LABEL_144;
    }
    uint64_t v123 = v149[1];
    if (v68 == v123)
    {
      unint64_t v104 = 1;
    }
    else
    {
      unint64_t v124 = v68 + 3 - v105;
      if (v124 > 6)
      {
        unint64_t v127 = v68 + 3 - v123;
        if (v127 > 6)
        {
          if (v68 == v149[2])
          {
            unint64_t v104 = 2;
          }
          else
          {
            if (v68 != v149[3]) {
              goto LABEL_138;
            }
            unint64_t v104 = 3;
          }
          goto LABEL_139;
        }
        char v125 = 4 * v127;
        unsigned int v126 = 266017486;
      }
      else
      {
        char v125 = 4 * v124;
        unsigned int v126 = 158663784;
      }
      unint64_t v104 = (v126 >> v125) & 0xF;
    }
LABEL_139:
    if (v68 <= v55 && v104)
    {
      v149[3] = v149[2];
      *(void *)(v149 + 1) = *(void *)v149;
      *uint64_t v149 = v68;
    }
LABEL_144:
    *(_DWORD *)uint64_t v150 = v12;
    *(_DWORD *)(v150 + 4) = v61 | (v67 << 25);
    uint64_t v106 = *(unsigned int *)(a5 + 68);
    uint64_t v107 = v106 + 16;
    if (v106 + 16 <= v104)
    {
      uint64_t v109 = *(unsigned int *)(a5 + 64);
      unint64_t v110 = v104 - v106 + (4 << v109) - 16;
      uint64_t v111 = (__clz(v110) ^ 0x1F) - 1;
      uint64_t v112 = ((v110 >> v111) & 1 | 2) << v111;
      unint64_t v104 = ((v110 & ~(-1 << v109))
            + v107
            + ((((v110 >> v111) & 1 | (2 * (v111 - v109))) + 65534) << v109)) | ((v111 - v109) << 10);
      unint64_t v108 = (v110 - v112) >> v109;
    }
    else
    {
      LODWORD(v108) = 0;
    }
    *(_WORD *)(v150 + 14) = v104;
    *(_DWORD *)(v150 + 8) = v108;
    if (v12 > 5)
    {
      if (v12 > 0x81)
      {
        if (v12 > 0x841)
        {
          if (v12 >> 1 >= 0xC21)
          {
            if (v12 < 0x5842) {
              LOWORD(v113) = 22;
            }
            else {
              LOWORD(v113) = 23;
            }
          }
          else
          {
            LOWORD(v113) = 21;
          }
        }
        else
        {
          unsigned int v113 = (__clz(v12 - 66) ^ 0x1F) + 10;
        }
      }
      else
      {
        unsigned int v114 = (__clz(v12 - 2) ^ 0x1F) - 1;
        unsigned int v113 = ((v12 - 2) >> v114) + 2 * v114 + 2;
      }
    }
    else
    {
      LOWORD(v113) = v12;
    }
    unsigned int v128 = v67 + v61;
    if ((v67 + v61) > 9)
    {
      if (v128 > 0x85)
      {
        if (v128 > 0x845) {
          LOWORD(v128) = 23;
        }
        else {
          unsigned int v128 = (__clz(v128 - 70) ^ 0x1F) + 12;
        }
      }
      else
      {
        unsigned int v129 = __clz(v128 - 6);
        unsigned int v128 = ((unint64_t)(v67 + (int)v61 - 6) >> ((v129 ^ 0x1F) - 1)) + 2 * ((v129 ^ 0x1F) - 1) + 4;
      }
    }
    else
    {
      LOWORD(v128) = v128 - 2;
    }
    int v130 = v128 & 7 | (8 * (v113 & 7));
    if ((v104 & 0x3FF) != 0 || (unsigned __int16)v113 > 7u || (unsigned __int16)v128 > 0xFu)
    {
      int v132 = 3 * ((unsigned __int16)v113 >> 3) + ((unsigned __int16)(v128 & 0xFFF8) >> 3);
      unsigned int v131 = ((((0x520D40u >> (2 * v132)) & 0xC0) + (v132 << 6)) | v130) + 64;
    }
    else
    {
      LOWORD(v131) = v130 | 0x40;
      if ((v128 & 0xFFF8) == 0) {
        LOWORD(v131) = v128 & 7 | (8 * (v113 & 7));
      }
    }
    *(_WORD *)(v150 + 12) = v131;
    *a11 += v12;
    unint64_t v133 = v53 + 2;
    unint64_t v101 = v53 + v61;
    if (v53 + v61 >= v147) {
      unint64_t v134 = v147;
    }
    else {
      unint64_t v134 = v53 + v61;
    }
    if (v68 < v61 >> 2)
    {
      unint64_t v135 = v101 - 4 * v68;
      if (v133 > v135) {
        unint64_t v135 = v53 + 2;
      }
      if (v134 >= v135) {
        unint64_t v133 = v135;
      }
      else {
        unint64_t v133 = v134;
      }
    }
    unint64_t v18 = v145 + 2 * v61 + v53;
    unint64_t result = v150 + 16;
    v150 += 16;
    if (v133 >= v134)
    {
      unint64_t v12 = 0;
      unint64_t v14 = v146;
      uint64_t v19 = v144;
    }
    else
    {
      unint64_t v14 = v146;
      uint64_t v19 = v144;
      do
      {
        *(_DWORD *)(v20 + (((0xBD1E35A7BD000000 * *(void *)(a3 + (v133 & a4))) >> 46) & 0x3FFFC)) = v133;
        ++v133;
      }
      while (v134 != v133);
      unint64_t v12 = 0;
    }
LABEL_205:
    unint64_t v11 = v101;
  }
  while (v101 + 8 < v13);
LABEL_230:
  *a8 = v12 + v13 - v101;
  *a10 += (v150 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH3(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v132 = *MEMORY[0x263EF8340];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v119 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v122 = v14;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v15 = 512;
  }
  else {
    uint64_t v15 = 64;
  }
  if (a2 + 8 < v13)
  {
    uint64_t v16 = a5;
    unint64_t v128 = (1 << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v120 = *(void *)(a5 + 16);
    unint64_t result = v15 + a2;
    uint64_t v121 = v15;
    uint64_t v118 = 4 * v15;
    uint64_t v17 = *(void *)(a6 + 56);
    uint64_t v123 = a7;
    uint64_t v124 = a9;
    unint64_t v126 = v13;
    while (1)
    {
      unint64_t v18 = v13 - v11;
      if (v11 >= v128) {
        unint64_t v19 = v128;
      }
      else {
        unint64_t v19 = v11;
      }
      unint64_t v20 = v11 & a4;
      uint64_t v21 = (void *)(a3 + (v11 & a4));
      int v22 = *(unsigned __int8 *)v21;
      unint64_t v23 = *a7;
      if (v11 < v23) {
        goto LABEL_22;
      }
      unint64_t v24 = (unsigned __int8 *)(a3 + (a4 & (v11 - v23)));
      if (v22 != *v24) {
        goto LABEL_22;
      }
      if (v18 < 8)
      {
        unint64_t v26 = 0;
        long long v27 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_184:
        unint64_t v115 = v18 & 7;
        if ((v18 & 7) != 0)
        {
          unint64_t v116 = v26 | v115;
          while (v24[v26] == *v27)
          {
            ++v27;
            ++v26;
            if (!--v115)
            {
              unint64_t v26 = v116;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v25 = 0;
        unint64_t v26 = v18 & 0xFFFFFFFFFFFFFFF8;
        long long v27 = (unsigned __int8 *)(a3 + v20 + (v18 & 0xFFFFFFFFFFFFFFF8));
        unint64_t v28 = v18 >> 3;
        while (1)
        {
          uint64_t v29 = v21[v25];
          uint64_t v30 = *(void *)&v24[v25 * 8];
          if (v29 != v30) {
            break;
          }
          ++v25;
          if (!--v28) {
            goto LABEL_184;
          }
        }
        unint64_t v26 = v25 * 8 + (__clz(__rbit64(v30 ^ v29)) >> 3);
      }
      if (v26 >= 4 && (v129 = *a7, unint64_t v31 = 135 * v26 + 1935, v31 >= 0x7E5))
      {
        unint64_t v32 = result;
        int v22 = *(unsigned __int8 *)(a3 + v26 + v20);
      }
      else
      {
LABEL_22:
        unint64_t v32 = result;
        unint64_t v129 = 0;
        unint64_t v26 = 0;
        unint64_t v31 = 2020;
      }
      uint64_t v33 = 0;
      unint64_t v130 = (0xBD1E35A7BD000000 * *v21) >> 48;
      uint64_t v131 = (unsigned __int16)(v130 + 8);
      char v34 = 1;
      do
      {
        char v35 = v34;
        uint64_t v36 = *(unsigned int *)(v17 + 4 * *(&v130 + v33));
        unint64_t v37 = v11 - v36;
        if (v22 == *(unsigned __int8 *)(a3 + (v36 & a4) + v26) && v11 != v36 && v37 <= v19)
        {
          uint64_t v40 = a3 + (v36 & a4);
          if (v18 < 8)
          {
            unint64_t v45 = 0;
            uint64_t v46 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            unint64_t v48 = v18 & 7;
            if ((v18 & 7) != 0)
            {
              unint64_t v49 = v18 & 7 | v45;
              while (*(unsigned __int8 *)(v40 + v45) == *v46)
              {
                ++v46;
                ++v45;
                if (!--v48)
                {
                  unint64_t v45 = v49;
                  break;
                }
              }
              a7 = v123;
              uint64_t v16 = a5;
              unint64_t v13 = v126;
            }
          }
          else
          {
            uint64_t v41 = 0;
            unint64_t v42 = v18 >> 3;
            while (1)
            {
              uint64_t v43 = v21[v41];
              uint64_t v44 = *(void *)(v40 + v41 * 8);
              if (v43 != v44) {
                break;
              }
              ++v41;
              if (!--v42)
              {
                unint64_t v45 = v18 & 0xFFFFFFFFFFFFFFF8;
                uint64_t v46 = (unsigned __int8 *)v21 + (v18 & 0xFFFFFFFFFFFFFFF8);
                goto LABEL_43;
              }
            }
            unint64_t v45 = v41 * 8 + (__clz(__rbit64(v44 ^ v43)) >> 3);
          }
          if (v45 >= 4)
          {
            unsigned int v47 = __clz(v37) ^ 0x1F;
            if (v31 < 135 * v45 - 30 * v47 + 1920)
            {
              int v22 = *(unsigned __int8 *)(a3 + v45 + v20);
              unint64_t v129 = v37;
              unint64_t v31 = 135 * v45 - 30 * v47 + 1920;
              unint64_t v26 = v45;
            }
          }
        }
        char v34 = 0;
        uint64_t v33 = 1;
      }
      while ((v35 & 1) != 0);
      *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v130 + (v11 & 8))) = v11;
      if (v31 < 0x7E5)
      {
        ++v12;
        unint64_t v85 = v11 + 1;
        unint64_t result = v32;
        if (v11 + 1 > v32)
        {
          if (v85 <= v32 + v118)
          {
            unint64_t v99 = v11 + 9;
            if (v11 + 9 >= v119) {
              unint64_t v99 = v119;
            }
            for (; v85 < v99; v85 += 2)
            {
              *(_DWORD *)(v17
                        + 4
                        * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)(a3 + (v85 & a4))) >> 48) + (v85 & 8))) = v85;
              v12 += 2;
            }
          }
          else
          {
            unint64_t v86 = v11 + 17;
            if (v11 + 17 >= v119) {
              unint64_t v86 = v119;
            }
            for (; v85 < v86; v85 += 4)
            {
              *(_DWORD *)(v17
                        + 4
                        * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)(a3 + (v85 & a4))) >> 48) + (v85 & 8))) = v85;
              v12 += 4;
            }
          }
        }
        goto LABEL_177;
      }
      unsigned int v50 = 0;
      unint64_t v127 = *a7;
      while (1)
      {
        --v18;
        unint64_t v51 = v26 - 1;
        if (v26 - 1 >= v18) {
          unint64_t v51 = v18;
        }
        unint64_t v52 = *(int *)(v16 + 4) >= 5 ? 0 : v51;
        unint64_t v53 = v11 + 1;
        unint64_t v54 = v11 + 1 < v128 ? v11 + 1 : v128;
        unint64_t v55 = v53 & a4;
        int v56 = *(unsigned __int8 *)(a3 + v52 + (v53 & a4));
        int v57 = (void *)(a3 + (v53 & a4));
        if (v53 < v127) {
          goto LABEL_70;
        }
        unint64_t v58 = a4 & (v53 - v127);
        if (v56 != *(unsigned __int8 *)(a3 + v58 + v52)) {
          goto LABEL_70;
        }
        uint64_t v59 = a3 + v58;
        if (v18 < 8)
        {
          unint64_t v60 = 0;
          uint64_t v64 = (unsigned __int8 *)(a3 + (v53 & a4));
LABEL_102:
          unint64_t v84 = v18 & 7;
          if ((v18 & 7) != 0)
          {
            do
            {
              if (*(unsigned __int8 *)(v59 + v60) != *v64) {
                break;
              }
              ++v64;
              ++v60;
              --v84;
            }
            while (v84);
          }
        }
        else
        {
          unint64_t v60 = 0;
          unint64_t v61 = v18 >> 3;
          while (1)
          {
            uint64_t v62 = *(void *)((char *)v57 + v60);
            uint64_t v63 = *(void *)(v59 + v60);
            if (v62 != v63) {
              break;
            }
            v60 += 8;
            if (!--v61)
            {
              uint64_t v64 = (unsigned __int8 *)v57 + v60;
              goto LABEL_102;
            }
          }
          v60 += __clz(__rbit64(v63 ^ v62)) >> 3;
        }
        if (v60 >= 4 && (unint64_t v65 = 135 * v60 + 1935, v65 >= 0x7E5))
        {
          int v56 = *(unsigned __int8 *)(a3 + v60 + v55);
          unint64_t v52 = v60;
          unint64_t v66 = v127;
        }
        else
        {
LABEL_70:
          unint64_t v66 = 0;
          unint64_t v65 = 2020;
        }
        uint64_t v67 = 0;
        unint64_t v130 = (0xBD1E35A7BD000000 * *v57) >> 48;
        uint64_t v131 = (unsigned __int16)(v130 + 8);
        unint64_t v68 = v18 & 7;
        char v69 = 1;
        do
        {
          char v70 = v69;
          uint64_t v71 = *(unsigned int *)(v17 + 4 * *(&v130 + v67));
          unint64_t v72 = v53 - v71;
          if (v56 == *(unsigned __int8 *)(a3 + (v71 & a4) + v52) && v53 != v71 && v72 <= v54)
          {
            uint64_t v75 = a3 + (v71 & a4);
            if (v18 < 8)
            {
              unint64_t v76 = 0;
              uint64_t v80 = (unsigned __int8 *)(a3 + (v53 & a4));
LABEL_91:
              if (v68)
              {
                unint64_t v82 = v68;
                while (*(unsigned __int8 *)(v75 + v76) == *v80)
                {
                  ++v80;
                  ++v76;
                  --v82;
                  unint64_t v68 = v18 & 7;
                  if (!v82) {
                    goto LABEL_85;
                  }
                }
                unint64_t v68 = v18 & 7;
              }
            }
            else
            {
              unint64_t v76 = 0;
              unint64_t v77 = v18 >> 3;
              while (1)
              {
                uint64_t v78 = *(void *)((char *)v57 + v76);
                uint64_t v79 = *(void *)(v75 + v76);
                if (v78 != v79) {
                  break;
                }
                v76 += 8;
                if (!--v77)
                {
                  uint64_t v80 = (unsigned __int8 *)v57 + v76;
                  goto LABEL_91;
                }
              }
              v76 += __clz(__rbit64(v79 ^ v78)) >> 3;
            }
LABEL_85:
            if (v76 >= 4)
            {
              unint64_t v81 = 135 * v76 - 30 * (__clz(v72) ^ 0x1F) + 1920;
              unint64_t v68 = v18 & 7;
              if (v65 < v81)
              {
                int v56 = *(unsigned __int8 *)(a3 + v76 + v55);
                unint64_t v52 = v76;
                unint64_t v66 = v72;
                unint64_t v65 = v81;
              }
            }
          }
          char v69 = 0;
          uint64_t v67 = 1;
        }
        while ((v70 & 1) != 0);
        *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v130 + (v53 & 8))) = v53;
        if (v65 < v31 + 175) {
          break;
        }
        ++v12;
        uint64_t v16 = a5;
        if (v50 <= 2)
        {
          unint64_t v83 = v11 + 9;
          ++v50;
          unint64_t v129 = v66;
          unint64_t v31 = v65;
          unint64_t v26 = v52;
          ++v11;
          if (v83 < v126) {
            continue;
          }
        }
        goto LABEL_114;
      }
      unint64_t v66 = v129;
      unint64_t v52 = v26;
      unint64_t v53 = v11;
      uint64_t v16 = a5;
LABEL_114:
      unint64_t v87 = v128;
      if (v53 + v120 < v128) {
        unint64_t v87 = v53 + v120;
      }
      if (v66 > v87) {
        goto LABEL_117;
      }
      uint64_t v92 = *v123;
      if (v66 != v92) {
        break;
      }
      LOWORD(v88) = 0;
      LODWORD(v91) = 0;
      *(_DWORD *)uint64_t v124 = v12;
      *(_DWORD *)(v124 + 4) = v52;
LABEL_127:
      *(_WORD *)(v124 + 14) = v88;
      *(_DWORD *)(v124 + 8) = v91;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v97) = 22;
              }
              else {
                LOWORD(v97) = 23;
              }
            }
            else
            {
              LOWORD(v97) = 21;
            }
          }
          else
          {
            unsigned int v97 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v98 = (__clz(v12 - 2) ^ 0x1F) - 1;
          unsigned int v97 = ((v12 - 2) >> v98) + 2 * v98 + 2;
        }
      }
      else
      {
        LOWORD(v97) = v12;
      }
      unint64_t v105 = (unint64_t)v52 >> 1;
      if (v105 > 4)
      {
        if (v105 > 0x42)
        {
          if (v105 > 0x422) {
            LOWORD(v106) = 23;
          }
          else {
            unsigned int v106 = (__clz(v52 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v107 = (int)v52 - 6;
          unsigned int v108 = (__clz(v107) ^ 0x1F) - 1;
          unsigned int v106 = (v107 >> v108) + 2 * v108 + 4;
        }
      }
      else
      {
        LOWORD(v106) = v52 - 2;
      }
      int v109 = v106 & 7 | (8 * (v97 & 7));
      if ((v88 & 0x3FF) != 0 || (unsigned __int16)v97 > 7u || (unsigned __int16)v106 > 0xFu)
      {
        int v111 = 3 * ((unsigned __int16)v97 >> 3) + ((unsigned __int16)(v106 & 0xFFF8) >> 3);
        unsigned int v110 = ((((0x520D40u >> (2 * v111)) & 0xC0) + (v111 << 6)) | v109) + 64;
      }
      else
      {
        LOWORD(v110) = v109 | 0x40;
        if ((v106 & 0xFFF8) == 0) {
          LOWORD(v110) = v106 & 7 | (8 * (v97 & 7));
        }
      }
      *(_WORD *)(v124 + 12) = v110;
      *a11 += v12;
      unint64_t v112 = v53 + 2;
      unint64_t v85 = v53 + v52;
      unint64_t v113 = v122;
      if (v53 + v52 < v122) {
        unint64_t v113 = v53 + v52;
      }
      if (v66 < v52 >> 2)
      {
        unint64_t v114 = v85 - 4 * v66;
        if (v112 > v114) {
          unint64_t v114 = v53 + 2;
        }
        if (v113 >= v114) {
          unint64_t v112 = v114;
        }
        else {
          unint64_t v112 = v113;
        }
      }
      unint64_t result = v121 + 2 * v52 + v53;
      v124 += 16;
      if (v112 >= v113)
      {
        unint64_t v12 = 0;
        a7 = v123;
        unint64_t v13 = v126;
      }
      else
      {
        a7 = v123;
        unint64_t v13 = v126;
        do
        {
          *(_DWORD *)(v17
                    + 4
                    * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)(a3 + (v112 & a4))) >> 48) + (v112 & 8))) = v112;
          ++v112;
        }
        while (v113 != v112);
        unint64_t v12 = 0;
      }
LABEL_177:
      unint64_t v11 = v85;
      if (v85 + 8 >= v13) {
        goto LABEL_190;
      }
    }
    uint64_t v100 = v123[1];
    if (v66 == v100)
    {
      unint64_t v88 = 1;
      goto LABEL_118;
    }
    unint64_t v101 = v66 + 3;
    unint64_t v102 = v66 + 3 - v92;
    if (v102 > 6)
    {
      if (v101 - v100 > 6)
      {
        if (v66 == v123[2])
        {
          unint64_t v88 = 2;
        }
        else if (v66 == v123[3])
        {
          unint64_t v88 = 3;
        }
        else
        {
LABEL_117:
          unint64_t v88 = v66 + 15;
        }
LABEL_118:
        if (v66 <= v87 && v88)
        {
          v123[3] = v123[2];
          *(void *)(v123 + 1) = *(void *)v123;
          *uint64_t v123 = v66;
        }
        *(_DWORD *)uint64_t v124 = v12;
        *(_DWORD *)(v124 + 4) = v52;
        uint64_t v89 = *(unsigned int *)(v16 + 68);
        uint64_t v90 = v89 + 16;
        if (v89 + 16 <= v88)
        {
          uint64_t v93 = *(unsigned int *)(v16 + 64);
          unint64_t v94 = v88 - v89 + (4 << v93) - 16;
          uint64_t v95 = (__clz(v94) ^ 0x1F) - 1;
          uint64_t v96 = ((v94 >> v95) & 1 | 2) << v95;
          unint64_t v88 = ((v94 & ~(-1 << v93)) + v90 + ((((v94 >> v95) & 1 | (2 * (v95 - v93))) + 65534) << v93)) | ((v95 - v93) << 10);
          unint64_t v91 = (v94 - v96) >> v93;
        }
        else
        {
          LODWORD(v91) = 0;
        }
        goto LABEL_127;
      }
      char v103 = 4 * (v101 - v100);
      unsigned int v104 = 266017486;
    }
    else
    {
      char v103 = 4 * v102;
      unsigned int v104 = 158663784;
    }
    unint64_t v88 = (v104 >> v103) & 0xF;
    goto LABEL_118;
  }
  uint64_t v124 = a9;
  unint64_t v85 = a2;
LABEL_190:
  *a8 = v12 + v13 - v85;
  *a10 += (v124 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH4(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v172 = *MEMORY[0x263EF8340];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v157 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v155 = v14;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v15 = 512;
  }
  else {
    uint64_t v15 = 64;
  }
  if (a2 + 8 >= v13)
  {
    uint64_t v158 = a9;
    unint64_t v113 = a2;
    goto LABEL_241;
  }
  uint64_t v154 = v15;
  uint64_t v166 = *(void *)(a5 + 16);
  unint64_t v167 = (1 << *(_DWORD *)(a5 + 8)) - 16;
  unint64_t v16 = v15 + a2;
  uint64_t v17 = *(void *)(a6 + 56);
  uint64_t v156 = 4 * v15;
  int8x16_t v18 = (int8x16_t)vdupq_n_s64(0x1FFFFuLL);
  uint64_t v158 = a9;
  uint64_t i = a7;
  unint64_t v165 = a2 + result;
  uint64_t v168 = a5;
  do
  {
    unint64_t v20 = v13 - v11;
    if (v11 >= v167) {
      unint64_t v21 = v167;
    }
    else {
      unint64_t v21 = v11;
    }
    if (v11 + v166 >= v167) {
      unint64_t v22 = v167;
    }
    else {
      unint64_t v22 = v11 + v166;
    }
    unint64_t result = v11 & a4;
    unint64_t v23 = (void *)(a3 + (v11 & a4));
    int v24 = *(unsigned __int8 *)v23;
    unint64_t v25 = *i;
    if (v11 < v25) {
      goto LABEL_25;
    }
    unint64_t v26 = (unsigned __int8 *)(a3 + (a4 & (v11 - v25)));
    if (v24 != *v26) {
      goto LABEL_25;
    }
    uint64_t v169 = *i;
    if (v20 < 8)
    {
      unint64_t v28 = 0;
      uint64_t v29 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_229:
      unint64_t v149 = v20 & 7;
      if ((v20 & 7) != 0)
      {
        unint64_t v150 = v28 | v149;
        while (v26[v28] == *v29)
        {
          ++v29;
          ++v28;
          if (!--v149)
          {
            unint64_t v28 = v150;
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v27 = 0;
      unint64_t v28 = v20 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v29 = (unsigned __int8 *)(a3 + result + (v20 & 0xFFFFFFFFFFFFFFF8));
      unint64_t v30 = v20 >> 3;
      while (1)
      {
        uint64_t v31 = v23[v27];
        uint64_t v32 = *(void *)&v26[v27 * 8];
        if (v31 != v32) {
          break;
        }
        ++v27;
        if (!--v30) {
          goto LABEL_229;
        }
      }
      unint64_t v28 = v27 * 8 + (__clz(__rbit64(v32 ^ v31)) >> 3);
    }
    if (v28 >= 4 && (unint64_t v33 = 135 * v28 + 1935, v33 >= 0x7E5))
    {
      int v24 = *(unsigned __int8 *)(a3 + v28 + result);
    }
    else
    {
LABEL_25:
      uint64_t v169 = 0;
      unint64_t v28 = 0;
      unint64_t v33 = 2020;
    }
    uint64_t v34 = 0;
    unint64_t v159 = *(void *)(a5 + 80);
    int64x2_t v35 = vdupq_n_s64((0xBD1E35A7BD000000 * *v23) >> 47);
    int8x16_t v170 = vandq_s8((int8x16_t)vaddq_s64(v35, (int64x2_t)xmmword_20DB0A590), v18);
    int8x16_t v171 = vandq_s8((int8x16_t)vaddq_s64(v35, (int64x2_t)xmmword_20DB0A5A0), v18);
    uint64_t v36 = *(uint64_t *)((char *)v170.i64 + (v11 & 0x18));
    do
    {
      uint64_t v37 = *(unsigned int *)(v17 + 4 * v170.i64[v34]);
      unint64_t v38 = v11 - v37;
      if (v24 == *(unsigned __int8 *)(a3 + (v37 & a4) + v28) && v11 != v37 && v38 <= v21)
      {
        uint64_t v41 = a3 + (v37 & a4);
        if (v20 < 8)
        {
          unint64_t v46 = 0;
          unsigned int v47 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_46:
          if ((v20 & 7) != 0)
          {
            unint64_t v49 = v20 & 7 | v46;
            unint64_t v50 = v20 & 7;
            while (*(unsigned __int8 *)(v41 + v46) == *v47)
            {
              ++v47;
              ++v46;
              if (!--v50)
              {
                unint64_t v46 = v49;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v42 = 0;
          unint64_t v43 = v20 >> 3;
          while (1)
          {
            uint64_t v44 = v23[v42];
            uint64_t v45 = *(void *)(v41 + v42 * 8);
            if (v44 != v45) {
              break;
            }
            ++v42;
            if (!--v43)
            {
              unint64_t v46 = v20 & 0xFFFFFFFFFFFFFFF8;
              unsigned int v47 = (unsigned __int8 *)v23 + (v20 & 0xFFFFFFFFFFFFFFF8);
              goto LABEL_46;
            }
          }
          unint64_t v46 = v42 * 8 + (__clz(__rbit64(v45 ^ v44)) >> 3);
        }
        if (v46 >= 4)
        {
          unsigned int v48 = __clz(v38) ^ 0x1F;
          if (v33 < 135 * v46 - 30 * v48 + 1920)
          {
            int v24 = *(unsigned __int8 *)(a3 + v46 + result);
            uint64_t v169 = v38;
            unint64_t v33 = 135 * v46 - 30 * v48 + 1920;
            unint64_t v28 = v46;
          }
        }
      }
      ++v34;
    }
    while (v34 != 4);
    if (v33 == 2020)
    {
      uint64_t v51 = *(void *)(a6 + 48);
      unint64_t v53 = *(void *)(v51 + 8);
      unint64_t v52 = *(void *)(v51 + 16);
      a5 = v168;
      if (v52 < v53 >> 7) {
        goto LABEL_55;
      }
      uint64_t v54 = ((506832829 * *(_DWORD *)v23) >> 17) & 0x7FFELL;
      uint64_t v55 = *(void *)(v168 + 120);
      *(void *)(v51 + 8) = v53 + 1;
      unint64_t v56 = *(unsigned __int8 *)(v55 + v54);
      if (!*(unsigned char *)(v55 + v54) || v20 < v56) {
        goto LABEL_55;
      }
      uint64_t v128 = *(unsigned __int16 *)(*(void *)(v168 + 112) + 2 * v54);
      uint64_t v129 = *(void *)(v168 + 88);
      uint64_t v130 = *(unsigned int *)(v129 + 4 * v56 + 32);
      uint64_t v131 = *(void *)(v129 + 168);
      unint64_t result = v131 + v130 + v128 * (unint64_t)v56;
      if (v56 < 8)
      {
        unint64_t v28 = 0;
LABEL_235:
        unint64_t v151 = v56 & 7;
        if ((v56 & 7) != 0)
        {
          unint64_t v152 = v28 | v151;
          while (*((unsigned __int8 *)v23 + v28) == *(unsigned __int8 *)result)
          {
            ++result;
            ++v28;
            if (!--v151)
            {
              unint64_t v28 = v152;
              break;
            }
          }
        }
      }
      else
      {
        unint64_t v132 = 0;
        unint64_t v28 = v56 & 0xF8;
        unint64_t v133 = v131 + v128 * (unint64_t)v56 + v28 + v130;
        while (1)
        {
          uint64_t v134 = *(void *)(result + v132);
          uint64_t v135 = v23[v132 / 8];
          if (v134 != v135) {
            break;
          }
          v132 += 8;
          if (v28 == v132)
          {
            unint64_t result = v133;
            goto LABEL_235;
          }
        }
        unint64_t v28 = v132 + (__clz(__rbit64(v135 ^ v134)) >> 3);
      }
      if (!v28
        || v28 + *(unsigned int *)(v168 + 100) <= v56
        || (unint64_t result = v22
                   + 1
                   + v128
                   + ((((*(void *)(v168 + 104) >> (6 * (v56 - v28))) & 0x3FLL)
                     + 4 * (v56 - v28)) << *(unsigned char *)(v129 + v56)),
            result > v159)
        || (unint64_t v33 = 135 * v28 - 30 * (__clz(result) ^ 0x1F) + 1920, v33 < 0x7E4))
      {
LABEL_55:
        *(_DWORD *)(v17 + 4 * v36) = v11;
LABEL_140:
        ++v12;
        unint64_t v113 = v11 + 1;
        if (v11 + 1 <= v16)
        {
          uint64_t i = a7;
          unint64_t v13 = v165;
        }
        else
        {
          unint64_t v13 = v165;
          if (v113 <= v16 + v156)
          {
            unint64_t v115 = v11 + 9;
            if (v11 + 9 >= v157) {
              unint64_t v115 = v157;
            }
            for (uint64_t i = a7; v113 < v115; v113 += 2)
            {
              *(_DWORD *)(v17
                        + 4
                        * (((((0xBD1E35A7BD000000 * *(void *)(a3 + (v113 & a4))) >> 32) >> 15)
                          + (v113 & 0x18)) & 0x1FFFF)) = v113;
              v12 += 2;
            }
          }
          else
          {
            unint64_t v114 = v11 + 17;
            if (v11 + 17 >= v157) {
              unint64_t v114 = v157;
            }
            for (uint64_t i = a7; v113 < v114; v113 += 4)
            {
              *(_DWORD *)(v17
                        + 4
                        * (((((0xBD1E35A7BD000000 * *(void *)(a3 + (v113 & a4))) >> 32) >> 15)
                          + (v113 & 0x18)) & 0x1FFFF)) = v113;
              v12 += 4;
            }
          }
        }
        goto LABEL_222;
      }
      uint64_t v169 = v22
           + 1
           + v128
           + ((((*(void *)(v168 + 104) >> (6 * (v56 - v28))) & 0x3FLL)
             + 4 * (v56 - v28)) << *(unsigned char *)(v129 + v56));
      int v57 = v56 - v28;
      *(void *)(v51 + 16) = v52 + 1;
    }
    else
    {
      int v57 = 0;
      a5 = v168;
    }
    *(_DWORD *)(v17 + 4 * v36) = v11;
    if (v33 < 0x7E5) {
      goto LABEL_140;
    }
    unint64_t result = 0;
    unint64_t v163 = *a7;
    while (1)
    {
      --v20;
      unint64_t v58 = v28 - 1;
      if (v28 - 1 >= v20) {
        unint64_t v58 = v20;
      }
      if (*(int *)(a5 + 4) >= 5) {
        unint64_t v59 = 0;
      }
      else {
        unint64_t v59 = v58;
      }
      unint64_t v60 = v11 + 1;
      if (v11 + 1 < v167) {
        unint64_t v61 = v11 + 1;
      }
      else {
        unint64_t v61 = v167;
      }
      if (v60 + v166 >= v167) {
        unint64_t v62 = v167;
      }
      else {
        unint64_t v62 = v60 + v166;
      }
      unint64_t v63 = v60 & a4;
      int v64 = *(unsigned __int8 *)(a3 + v59 + (v60 & a4));
      unint64_t v65 = (void *)(a3 + (v60 & a4));
      unint64_t v164 = v62;
      int v162 = v57;
      if (v60 < v163) {
        goto LABEL_81;
      }
      unint64_t v66 = a4 & (v60 - v163);
      if (v64 != *(unsigned __int8 *)(a3 + v66 + v59)) {
        goto LABEL_81;
      }
      uint64_t v67 = a3 + v66;
      if (v20 < 8)
      {
        unint64_t v68 = 0;
        unint64_t v72 = (unsigned __int8 *)(a3 + (v60 & a4));
LABEL_130:
        unint64_t v110 = v20 & 7;
        if ((v20 & 7) != 0)
        {
          do
          {
            if (*(unsigned __int8 *)(v67 + v68) != *v72) {
              break;
            }
            ++v72;
            ++v68;
            --v110;
          }
          while (v110);
        }
      }
      else
      {
        unint64_t v68 = 0;
        unint64_t v69 = v20 >> 3;
        while (1)
        {
          uint64_t v70 = *(void *)((char *)v65 + v68);
          uint64_t v71 = *(void *)(v67 + v68);
          if (v70 != v71) {
            break;
          }
          v68 += 8;
          if (!--v69)
          {
            unint64_t v72 = (unsigned __int8 *)v65 + v68;
            goto LABEL_130;
          }
        }
        v68 += __clz(__rbit64(v71 ^ v70)) >> 3;
      }
      if (v68 >= 4 && (unint64_t v73 = 135 * v68 + 1935, v73 >= 0x7E5))
      {
        int v64 = *(unsigned __int8 *)(a3 + v68 + v63);
        unint64_t v59 = v68;
        unint64_t v74 = v163;
      }
      else
      {
LABEL_81:
        unint64_t v74 = 0;
        unint64_t v73 = 2020;
      }
      uint64_t v75 = 0;
      int64x2_t v76 = vdupq_n_s64((0xBD1E35A7BD000000 * *v65) >> 47);
      int8x16_t v77 = (int8x16_t)vdupq_n_s64(0x1FFFFuLL);
      int8x16_t v170 = vandq_s8((int8x16_t)vaddq_s64(v76, (int64x2_t)xmmword_20DB0A590), v77);
      int8x16_t v171 = vandq_s8((int8x16_t)vaddq_s64(v76, (int64x2_t)xmmword_20DB0A5A0), v77);
      uint64_t v78 = *(uint64_t *)((char *)v170.i64 + (v60 & 0x18));
      do
      {
        uint64_t v79 = *(unsigned int *)(v17 + 4 * v170.i64[v75]);
        unint64_t v80 = v60 - v79;
        if (v64 == *(unsigned __int8 *)(a3 + (v79 & a4) + v59) && v60 != v79 && v80 <= v61)
        {
          uint64_t v83 = a3 + (v79 & a4);
          if (v20 < 8)
          {
            unint64_t v84 = 0;
            unint64_t v88 = (unsigned __int8 *)(a3 + (v60 & a4));
LABEL_102:
            if ((v20 & 7) != 0)
            {
              unint64_t v90 = v20 & 7;
              do
              {
                if (*(unsigned __int8 *)(v83 + v84) != *v88) {
                  break;
                }
                ++v88;
                ++v84;
                --v90;
              }
              while (v90);
            }
          }
          else
          {
            unint64_t v84 = 0;
            unint64_t v85 = v20 >> 3;
            while (1)
            {
              uint64_t v86 = *(void *)((char *)v65 + v84);
              uint64_t v87 = *(void *)(v83 + v84);
              if (v86 != v87) {
                break;
              }
              v84 += 8;
              if (!--v85)
              {
                unint64_t v88 = (unsigned __int8 *)v65 + v84;
                goto LABEL_102;
              }
            }
            v84 += __clz(__rbit64(v87 ^ v86)) >> 3;
          }
          if (v84 >= 4)
          {
            unsigned int v89 = __clz(v80);
            if (v73 < 135 * v84 - 30 * (v89 ^ 0x1F) + 1920)
            {
              int v64 = *(unsigned __int8 *)(a3 + v84 + v63);
              unint64_t v59 = v84;
              unint64_t v74 = v80;
              unint64_t v73 = 135 * v84 - 30 * (v89 ^ 0x1F) + 1920;
            }
          }
        }
        ++v75;
      }
      while (v75 != 4);
      if (v73 != 2020)
      {
        int v107 = 0;
        a5 = v168;
        goto LABEL_124;
      }
      uint64_t v91 = *(void *)(a6 + 48);
      unint64_t v92 = *(void *)(v91 + 8);
      unint64_t v93 = *(void *)(v91 + 16);
      a5 = v168;
      if (v93 < v92 >> 7
        || (uint64_t v94 = ((506832829 * *(_DWORD *)v65) >> 17) & 0x7FFELL,
            uint64_t v95 = *(void *)(v168 + 120),
            *(void *)(v91 + 8) = v92 + 1,
            unint64_t v96 = *(unsigned __int8 *)(v95 + v94),
            !*(unsigned char *)(v95 + v94))
        || v20 < v96)
      {
LABEL_122:
        int v107 = 0;
LABEL_123:
        unint64_t v73 = 2020;
        goto LABEL_124;
      }
      uint64_t v97 = *(unsigned __int16 *)(*(void *)(v168 + 112) + 2 * v94);
      uint64_t v98 = *(void *)(v168 + 88);
      uint64_t v99 = *(unsigned int *)(v98 + 4 * v96 + 32);
      uint64_t v100 = *(void *)(v98 + 168);
      unint64_t v101 = (unsigned __int8 *)(v100 + v99 + v97 * (unint64_t)v96);
      if (v96 < 8)
      {
        unint64_t v103 = 0;
LABEL_135:
        unint64_t v111 = v96 & 7;
        if ((v96 & 7) != 0)
        {
          unint64_t v112 = v103 | v111;
          while (*((unsigned __int8 *)v65 + v103) == *v101)
          {
            ++v101;
            ++v103;
            if (!--v111)
            {
              unint64_t v103 = v112;
              break;
            }
          }
        }
      }
      else
      {
        unint64_t v102 = 0;
        unint64_t v103 = v96 & 0xF8;
        unsigned int v104 = (unsigned __int8 *)(v100 + v97 * (unint64_t)v96 + v103 + v99);
        while (1)
        {
          uint64_t v105 = *(void *)&v101[v102];
          uint64_t v106 = v65[v102 / 8];
          if (v105 != v106) {
            break;
          }
          v102 += 8;
          if (v103 == v102)
          {
            unint64_t v101 = v104;
            goto LABEL_135;
          }
        }
        unint64_t v103 = v102 + (__clz(__rbit64(v106 ^ v105)) >> 3);
      }
      int v107 = 0;
      a5 = v168;
      if (!v103 || v103 + *(unsigned int *)(v168 + 100) <= v96) {
        goto LABEL_123;
      }
      unint64_t v108 = v164
           + 1
           + v97
           + ((((*(void *)(v168 + 104) >> (6 * (v96 - v103))) & 0x3FLL)
             + 4 * (v96 - v103)) << *(unsigned char *)(v98 + v96));
      if (v108 > v159) {
        goto LABEL_122;
      }
      unint64_t v73 = 135 * v103 - 30 * (__clz(v108) ^ 0x1F) + 1920;
      if (v73 < 0x7E4) {
        goto LABEL_122;
      }
      int v107 = v96 - v103;
      *(void *)(v91 + 16) = v93 + 1;
      unint64_t v59 = v103;
      unint64_t v74 = v108;
LABEL_124:
      *(_DWORD *)(v17 + 4 * v78) = v60;
      if (v73 < v33 + 175) {
        break;
      }
      ++v12;
      if (result <= 2)
      {
        unint64_t v109 = v11 + 9;
        unint64_t result = (result + 1);
        uint64_t v169 = v74;
        unint64_t v33 = v73;
        int v57 = v107;
        unint64_t v28 = v59;
        ++v11;
        if (v109 < v165) {
          continue;
        }
      }
      goto LABEL_156;
    }
    unint64_t v116 = v11 + v166;
    if (v11 + v166 >= v167) {
      unint64_t v116 = v167;
    }
    unint64_t v164 = v116;
    unint64_t v74 = v169;
    int v107 = v162;
    unint64_t v59 = v28;
    unint64_t v60 = v11;
LABEL_156:
    uint64_t i = a7;
    if (v74 > v164)
    {
LABEL_157:
      unint64_t v117 = v74 + 15;
      goto LABEL_158;
    }
    uint64_t v118 = *a7;
    if (v74 == v118)
    {
      unint64_t v117 = 0;
      goto LABEL_163;
    }
    uint64_t v136 = a7[1];
    if (v74 == v136)
    {
      unint64_t v117 = 1;
    }
    else
    {
      unint64_t v137 = v74 + 3 - v118;
      if (v137 > 6)
      {
        unint64_t v140 = v74 + 3 - v136;
        if (v140 > 6)
        {
          if (v74 == a7[2])
          {
            unint64_t v117 = 2;
          }
          else
          {
            if (v74 != a7[3]) {
              goto LABEL_157;
            }
            unint64_t v117 = 3;
          }
          goto LABEL_158;
        }
        char v138 = 4 * v140;
        unsigned int v139 = 266017486;
      }
      else
      {
        char v138 = 4 * v137;
        unsigned int v139 = 158663784;
      }
      unint64_t v117 = (v139 >> v138) & 0xF;
    }
LABEL_158:
    if (v74 <= v164 && v117)
    {
      a7[3] = a7[2];
      *(void *)(a7 + 1) = *(void *)a7;
      *a7 = v74;
    }
LABEL_163:
    *(_DWORD *)uint64_t v158 = v12;
    *(_DWORD *)(v158 + 4) = v59 | (v107 << 25);
    uint64_t v119 = *(unsigned int *)(a5 + 68);
    uint64_t v120 = v119 + 16;
    if (v119 + 16 <= v117)
    {
      uint64_t v122 = *(unsigned int *)(a5 + 64);
      unint64_t v123 = v117 - v119 + (4 << v122) - 16;
      uint64_t v124 = (__clz(v123) ^ 0x1F) - 1;
      uint64_t v125 = ((v123 >> v124) & 1 | 2) << v124;
      unint64_t result = 65534;
      unint64_t v117 = ((v123 & ~(-1 << v122))
            + v120
            + ((((v123 >> v124) & 1 | (2 * (v124 - v122))) + 65534) << v122)) | ((v124 - v122) << 10);
      unint64_t v121 = (v123 - v125) >> v122;
    }
    else
    {
      LODWORD(v121) = 0;
    }
    unint64_t v13 = v165;
    *(_WORD *)(v158 + 14) = v117;
    *(_DWORD *)(v158 + 8) = v121;
    if (v12 > 5)
    {
      if (v12 > 0x81)
      {
        if (v12 > 0x841)
        {
          if (v12 >> 1 >= 0xC21)
          {
            if (v12 < 0x5842) {
              LOWORD(v126) = 22;
            }
            else {
              LOWORD(v126) = 23;
            }
          }
          else
          {
            LOWORD(v126) = 21;
          }
        }
        else
        {
          unsigned int v126 = (__clz(v12 - 66) ^ 0x1F) + 10;
        }
      }
      else
      {
        unsigned int v127 = (__clz(v12 - 2) ^ 0x1F) - 1;
        unsigned int v126 = ((v12 - 2) >> v127) + 2 * v127 + 2;
      }
    }
    else
    {
      LOWORD(v126) = v12;
    }
    unint64_t v141 = v107 + (int)v59;
    if (v141 > 9)
    {
      if (v141 > 0x85)
      {
        if (v141 > 0x845) {
          LOWORD(v141) = 23;
        }
        else {
          LODWORD(v141) = (__clz(v141 - 70) ^ 0x1F) + 12;
        }
      }
      else
      {
        v141 -= 6;
        unsigned int v142 = (__clz(v141) ^ 0x1F) - 1;
        LODWORD(v141) = (v141 >> v142) + 2 * v142 + 4;
      }
    }
    else
    {
      LOWORD(v141) = v141 - 2;
    }
    int v143 = v141 & 7 | (8 * (v126 & 7));
    if ((v117 & 0x3FF) != 0 || (unsigned __int16)v126 > 7u || (unsigned __int16)v141 > 0xFu)
    {
      int v145 = 3 * ((unsigned __int16)v126 >> 3) + ((unsigned __int16)(v141 & 0xFFF8) >> 3);
      unsigned int v144 = ((((0x520D40u >> (2 * v145)) & 0xC0) + (v145 << 6)) | v143) + 64;
    }
    else
    {
      LOWORD(v144) = v143 | 0x40;
      if ((v141 & 0xFFF8) == 0) {
        LOWORD(v144) = v143;
      }
    }
    *(_WORD *)(v158 + 12) = v144;
    *a11 += v12;
    unint64_t v146 = v60 + 2;
    unint64_t v113 = v60 + v59;
    if (v60 + v59 >= v155) {
      unint64_t v147 = v155;
    }
    else {
      unint64_t v147 = v60 + v59;
    }
    if (v74 < v59 >> 2)
    {
      unint64_t v148 = v113 - 4 * v74;
      if (v146 > v148) {
        unint64_t v148 = v60 + 2;
      }
      if (v147 >= v148) {
        unint64_t v146 = v148;
      }
      else {
        unint64_t v146 = v147;
      }
    }
    unint64_t v16 = v154 + 2 * v59 + v60;
    v158 += 16;
    if (v146 >= v147)
    {
      unint64_t v12 = 0;
    }
    else
    {
      do
      {
        *(_DWORD *)(v17
                  + 4
                  * (((((0xBD1E35A7BD000000 * *(void *)(a3 + (v146 & a4))) >> 32) >> 15)
                    + (v146 & 0x18)) & 0x1FFFF)) = v146;
        ++v146;
      }
      while (v147 != v146);
      unint64_t v12 = 0;
    }
LABEL_222:
    unint64_t v11 = v113;
  }
  while (v113 + 8 < v13);
LABEL_241:
  *a8 = v12 + v13 - v113;
  *a10 += (v158 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH5(unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v239 = *(void *)(a5 + 16);
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  unint64_t v226 = a2 + result - 3;
  if (result <= 3) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = a2 + result - 3;
  }
  int v15 = *(_DWORD *)(a5 + 8);
  uint64_t v16 = 512;
  if (*(int *)(a5 + 4) < 9) {
    uint64_t v16 = 64;
  }
  unint64_t v227 = v14;
  uint64_t v228 = v16;
  int v17 = *(_DWORD *)(a6 + 76);
  if (v17 >= 5)
  {
    int32x4_t v18 = (int32x4_t)vld1q_dup_f32((const float *)a7);
    *((int32x4_t *)a7 + 1) = vaddq_s32(v18, (int32x4_t)xmmword_20DB0A5B0);
    *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x3FFFFFFFDLL);
    if (v17 >= 0xB)
    {
      unint64_t v19 = (const float *)(a7 + 1);
      int32x4_t v20 = (int32x4_t)vld1q_dup_f32(v19);
      *(int32x4_t *)(a7 + 10) = vaddq_s32(v20, (int32x4_t)xmmword_20DB0A5B0);
      *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v20.i8, (int32x2_t)0x3FFFFFFFDLL);
    }
  }
  if (a2 + 4 < v13)
  {
    unint64_t v21 = v228 + a2;
    unint64_t v238 = (1 << v15) - 16;
    uint64_t v22 = *(void *)(a6 + 88);
    uint64_t v23 = *(void *)(a6 + 96);
    unint64_t v225 = v13 - 4;
    uint64_t v229 = a9;
    unint64_t v230 = v13;
    uint64_t v252 = v22;
    uint64_t v240 = v23;
    while (1)
    {
      unint64_t v253 = v12;
      unint64_t v24 = v13 - v11;
      if (v11 >= v238) {
        unint64_t v25 = v238;
      }
      else {
        unint64_t v25 = v11;
      }
      unint64_t v26 = v11 + v239;
      if (v11 + v239 >= v238) {
        unint64_t v26 = v238;
      }
      unint64_t v247 = v26;
      unint64_t v250 = v21;
      unint64_t v27 = v11 & a4;
      uint64_t v28 = *(int *)(a6 + 76);
      if (v28)
      {
        unint64_t v29 = 0;
        unint64_t v30 = 0;
        unint64_t v31 = 0;
        unint64_t v244 = 0;
        unint64_t v32 = 2020;
        uint64_t v33 = 2020;
        do
        {
          unint64_t v34 = a7[v29];
          unint64_t v35 = v11 - v34;
          BOOL v36 = v25 < v34 || v35 >= v11;
          unint64_t v37 = v35 & a4;
          unint64_t v38 = v30 + v27;
          BOOL v39 = v36 || v38 > a4;
          unint64_t result = v37 + v30;
          BOOL v40 = v39 || result > a4;
          if (!v40 && *(unsigned __int8 *)(a3 + v38) == *(unsigned __int8 *)(a3 + result))
          {
            uint64_t v41 = a3 + v37;
            if (v24 < 8)
            {
              unint64_t result = 0;
              unint64_t v46 = (unsigned __int8 *)(a3 + v27);
LABEL_49:
              if ((v24 & 7) != 0)
              {
                unint64_t v50 = v24 & 7 | result;
                unint64_t v51 = v24 & 7;
                while (*(unsigned __int8 *)(v41 + result) == *v46)
                {
                  ++v46;
                  ++result;
                  if (!--v51)
                  {
                    unint64_t result = v50;
                    break;
                  }
                }
                uint64_t v22 = v252;
                uint64_t v23 = v240;
              }
            }
            else
            {
              uint64_t v42 = 0;
              unint64_t v43 = v24 >> 3;
              while (1)
              {
                uint64_t v44 = *(void *)(a3 + v27 + v42);
                uint64_t v45 = *(void *)(v41 + v42);
                if (v44 != v45) {
                  break;
                }
                v42 += 8;
                if (!--v43)
                {
                  unint64_t result = v24 & 0xFFFFFFFFFFFFFFF8;
                  unint64_t v46 = (unsigned __int8 *)(a3 + v27 + (v24 & 0xFFFFFFFFFFFFFFF8));
                  goto LABEL_49;
                }
              }
              unint64_t result = v42 + (__clz(__rbit64(v45 ^ v44)) >> 3);
            }
            if (result > 2 || v29 <= 1 && result == 2)
            {
              unint64_t v47 = 135 * result + 1935;
              if (v32 < v47)
              {
                unint64_t v48 = v47 - (((0x1CA10u >> (v29 & 0xE)) & 0xE) + 39);
                if (!v29) {
                  unint64_t v48 = 135 * result + 1935;
                }
                unint64_t v49 = v244;
                if (v32 < v48) {
                  unint64_t v49 = a7[v29];
                }
                unint64_t v244 = v49;
                if (v32 < v48)
                {
                  uint64_t v33 = v48;
                  unint64_t v31 = result;
                  unint64_t v32 = v48;
                  unint64_t v30 = result;
                }
              }
            }
          }
          ++v29;
        }
        while (v29 != v28);
      }
      else
      {
        unint64_t v244 = 0;
        unint64_t v31 = 0;
        unint64_t v30 = 0;
        uint64_t v33 = 2020;
        unint64_t v32 = 2020;
      }
      unint64_t v52 = v31;
      unint64_t v246 = *(void *)(a5 + 80);
      unint64_t v53 = (_DWORD *)(a3 + v27);
      uint64_t v54 = *(unsigned int *)(a6 + 68);
      uint64_t v55 = (506832829 * *(_DWORD *)(a3 + v27)) >> *(_DWORD *)(a6 + 64);
      uint64_t v56 = v23 + 4 * (v55 << *(_DWORD *)(a6 + 72));
      unint64_t v57 = *(unsigned __int16 *)(v22 + 2 * v55);
      unint64_t v237 = *(void *)(a6 + 56);
      if (v57 >= v237) {
        unint64_t v58 = v57 - v237;
      }
      else {
        unint64_t v58 = 0;
      }
      if (v58 < v57)
      {
        unint64_t v59 = *(unsigned __int16 *)(v22 + 2 * v55);
        do
        {
          uint64_t v60 = *(unsigned int *)(v56 + 4 * (--v59 & v54));
          unint64_t v61 = v11 - v60;
          if (v11 - v60 > v25) {
            break;
          }
          if (v30 + v27 <= a4)
          {
            unint64_t v62 = v60 & a4;
            if (v62 + v30 <= a4 && *(unsigned __int8 *)(a3 + v30 + v27) == *(unsigned __int8 *)(a3 + v62 + v30))
            {
              uint64_t v63 = a3 + v62;
              if (v24 < 8)
              {
                unint64_t v68 = v13;
                unint64_t result = 0;
                unint64_t v69 = (unsigned __int8 *)(a3 + v27);
LABEL_77:
                if ((v24 & 7) != 0)
                {
                  unint64_t v71 = v24 & 7;
                  unint64_t v241 = v71 | result;
                  while (*(unsigned __int8 *)(v63 + result) == *v69)
                  {
                    ++v69;
                    ++result;
                    if (!--v71)
                    {
                      unint64_t result = v241;
                      break;
                    }
                  }
                }
                unint64_t v13 = v68;
              }
              else
              {
                uint64_t v64 = 0;
                unint64_t v65 = v24 >> 3;
                while (1)
                {
                  uint64_t v66 = *(void *)&v53[v64];
                  uint64_t v67 = *(void *)(v63 + v64 * 4);
                  if (v66 != v67) {
                    break;
                  }
                  v64 += 2;
                  if (!--v65)
                  {
                    unint64_t v68 = v13;
                    unint64_t result = v24 & 0xFFFFFFFFFFFFFFF8;
                    unint64_t v69 = (unsigned __int8 *)v53 + (v24 & 0xFFFFFFFFFFFFFFF8);
                    goto LABEL_77;
                  }
                }
                unint64_t result = v64 * 4 + (__clz(__rbit64(v67 ^ v66)) >> 3);
              }
              if (result >= 4)
              {
                unint64_t v70 = 135 * result - 30 * (__clz(v61) ^ 0x1F) + 1920;
                if (v32 < v70)
                {
                  unint64_t v244 = v61;
                  uint64_t v33 = v70;
                  unint64_t v52 = result;
                  unint64_t v32 = v70;
                  unint64_t v30 = result;
                }
              }
            }
          }
        }
        while (v59 > v58);
      }
      *(_DWORD *)(v56 + 4 * (v54 & v57)) = v11;
      uint64_t v22 = v252;
      *(_WORD *)(v252 + 2 * v55) = v57 + 1;
      if (v33 == 2020)
      {
        uint64_t v72 = *(void *)(a6 + 80);
        unint64_t v74 = *(void *)(v72 + 8);
        unint64_t v73 = *(void *)(v72 + 16);
        uint64_t v75 = a5;
        uint64_t v23 = v240;
        unint64_t v76 = v244;
        if (v73 < v74 >> 7) {
          goto LABEL_220;
        }
        int v236 = 0;
        uint64_t v77 = ((506832829 * *v53) >> 17) & 0x7FFE;
        uint64_t v78 = *(void *)(a5 + 120);
        unint64_t v248 = v247 + 1;
        char v79 = 1;
        unint64_t v80 = v52;
        unint64_t v81 = 2020;
        do
        {
          char v82 = v79;
          *(void *)(v72 + 8) = ++v74;
          unint64_t v83 = *(unsigned __int8 *)(v78 + v77);
          if (!*(unsigned char *)(v78 + v77) || v24 < v83) {
            goto LABEL_98;
          }
          uint64_t v84 = *(unsigned __int16 *)(*(void *)(v75 + 112) + 2 * v77);
          uint64_t v85 = *(void *)(v75 + 88);
          uint64_t v86 = *(unsigned int *)(v85 + 4 * v83 + 32);
          uint64_t v87 = *(void *)(v85 + 168);
          unint64_t result = v87 + v86 + v84 * *(unsigned __int8 *)(v78 + v77);
          if (v83 < 8)
          {
            unint64_t v52 = 0;
LABEL_103:
            unint64_t v94 = v83 & 7;
            if ((v83 & 7) != 0)
            {
              unint64_t v95 = v52;
              unint64_t v96 = v81;
              unint64_t v97 = v95 | v94;
              while (*((unsigned __int8 *)v53 + v95) == *(unsigned __int8 *)result)
              {
                ++result;
                ++v95;
                if (!--v94)
                {
                  unint64_t v98 = v97;
                  unint64_t v81 = v96;
                  unint64_t v52 = v98;
                  goto LABEL_94;
                }
              }
              unint64_t v81 = v96;
              unint64_t v52 = v95;
            }
          }
          else
          {
            unint64_t v88 = 0;
            unint64_t v89 = v87
                + v84 * (unint64_t)*(unsigned __int8 *)(v78 + v77)
                + (*(unsigned char *)(v78 + v77) & 0xF8)
                + v86;
            while (1)
            {
              uint64_t v90 = *(void *)(result + v88);
              uint64_t v91 = *(void *)&v53[v88 / 4];
              if (v90 != v91) {
                break;
              }
              v88 += 8;
              if ((v83 & 0xF8) == v88)
              {
                unint64_t result = v89;
                unint64_t v52 = v83 & 0xF8;
                goto LABEL_103;
              }
            }
            unint64_t v52 = v88 + (__clz(__rbit64(v91 ^ v90)) >> 3);
          }
LABEL_94:
          uint64_t v75 = a5;
          if (v52
            && v52 + *(unsigned int *)(a5 + 100) > v83
            && (unint64_t result = 6 * (v83 - v52),
                unint64_t v92 = v248
                    + v84
                    + ((((*(void *)(a5 + 104) >> result) & 0x3FLL) + 4 * (v83 - v52)) << *(unsigned char *)(v85 + v83)),
                v92 <= v246)
            && (unint64_t v93 = 135 * v52 - 30 * (__clz(v92) ^ 0x1F) + 1920, v93 >= v81))
          {
            int v236 = v83 - v52;
            *(void *)(v72 + 16) = ++v73;
            unint64_t v81 = v93;
          }
          else
          {
LABEL_98:
            unint64_t v92 = v76;
            unint64_t v52 = v80;
          }
          char v79 = 0;
          ++v77;
          unint64_t v80 = v52;
          unint64_t v76 = v92;
        }
        while ((v82 & 1) != 0);
      }
      else
      {
        unint64_t v81 = v33;
        int v236 = 0;
        uint64_t v75 = a5;
        uint64_t v23 = v240;
        unint64_t v92 = v244;
      }
      if (v81 < 0x7E5)
      {
LABEL_220:
        unint64_t v12 = v253 + 1;
        unint64_t v175 = v11 + 1;
        unint64_t v21 = v250;
        if (v11 + 1 > v250)
        {
          if (v175 <= v250 + 4 * v228)
          {
            unint64_t v198 = v11 + 9;
            if (v11 + 9 >= v226) {
              unint64_t v198 = v226;
            }
            if (v175 < v198)
            {
              int v199 = *(_DWORD *)(a6 + 64);
              int v200 = *(_DWORD *)(a6 + 68);
              int v201 = *(_DWORD *)(a6 + 72);
              do
              {
                unsigned int v202 = (506832829 * *(_DWORD *)(a3 + (v175 & a4))) >> v199;
                unsigned int v203 = *(unsigned __int16 *)(v252 + 2 * v202);
                *(_DWORD *)(v23 + 4 * ((v202 << v201) + (unint64_t)(v200 & v203))) = v175;
                *(_WORD *)(v252 + 2 * v202) = v203 + 1;
                v12 += 2;
                v175 += 2;
              }
              while (v175 < v198);
            }
          }
          else
          {
            unint64_t v176 = v11 + 17;
            if (v11 + 17 >= v225) {
              unint64_t v176 = v225;
            }
            if (v175 < v176)
            {
              int v177 = *(_DWORD *)(a6 + 64);
              int v178 = *(_DWORD *)(a6 + 68);
              int v179 = *(_DWORD *)(a6 + 72);
              do
              {
                unsigned int v180 = (506832829 * *(_DWORD *)(a3 + (v175 & a4))) >> v177;
                unsigned int v181 = *(unsigned __int16 *)(v252 + 2 * v180);
                *(_DWORD *)(v23 + 4 * ((v180 << v179) + (unint64_t)(v178 & v181))) = v175;
                *(_WORD *)(v252 + 2 * v180) = v181 + 1;
                v12 += 4;
                v175 += 4;
              }
              while (v175 < v176);
            }
          }
        }
        goto LABEL_294;
      }
      unint64_t v245 = v92;
      unint64_t v251 = v81;
      unsigned int v99 = 0;
      int v232 = *(_DWORD *)(a6 + 64);
      int v233 = *(_DWORD *)(a6 + 72);
      uint64_t v100 = *(unsigned int *)(a6 + 68);
      unsigned int v234 = *(_DWORD *)(a6 + 76);
      if (v234 <= 1) {
        int v101 = 1;
      }
      else {
        int v101 = *(_DWORD *)(a6 + 76);
      }
      uint64_t v102 = v101;
      unint64_t v103 = v52;
      while (1)
      {
        --v24;
        unint64_t v231 = v103;
        unint64_t v104 = v103 - 1;
        if (v103 - 1 >= v24) {
          unint64_t v104 = v24;
        }
        if (*(int *)(v75 + 4) >= 5) {
          unint64_t v105 = 0;
        }
        else {
          unint64_t v105 = v104;
        }
        unint64_t v106 = v11 + 1;
        if (v11 + 1 < v238) {
          unint64_t v107 = v11 + 1;
        }
        else {
          unint64_t v107 = v238;
        }
        unint64_t v108 = v106 + v239;
        if (v106 + v239 >= v238) {
          unint64_t v108 = v238;
        }
        unint64_t v242 = v108;
        unint64_t v109 = v106 & a4;
        unsigned int v249 = v99;
        if (v234)
        {
          unint64_t v110 = 0;
          unint64_t v111 = 0;
          unint64_t v112 = 0;
          uint64_t v113 = a3 + v109;
          unint64_t v114 = 2020;
          unint64_t v115 = 2020;
          do
          {
            unint64_t v116 = a7[v110];
            unint64_t v117 = v106 - v116;
            BOOL v118 = v107 < v116 || v117 >= v106;
            unint64_t v119 = v117 & a4;
            unint64_t v120 = v105 + v109;
            BOOL v121 = v118 || v120 > a4;
            unint64_t v122 = v119 + v105;
            BOOL v123 = v121 || v122 > a4;
            if (!v123 && *(unsigned __int8 *)(a3 + v120) == *(unsigned __int8 *)(a3 + v122))
            {
              uint64_t v124 = a3 + v119;
              if (v24 < 8)
              {
                unint64_t v125 = 0;
                uint64_t v129 = (unsigned __int8 *)(a3 + v109);
LABEL_157:
                if ((v24 & 7) != 0)
                {
                  unint64_t v132 = v24 & 7;
                  do
                  {
                    if (*(unsigned __int8 *)(v124 + v125) != *v129) {
                      break;
                    }
                    ++v129;
                    ++v125;
                    --v132;
                  }
                  while (v132);
                }
              }
              else
              {
                unint64_t v125 = 0;
                unint64_t v126 = v24 >> 3;
                while (1)
                {
                  uint64_t v127 = *(void *)(v113 + v125);
                  uint64_t v128 = *(void *)(v124 + v125);
                  if (v127 != v128) {
                    break;
                  }
                  v125 += 8;
                  if (!--v126)
                  {
                    uint64_t v129 = (unsigned __int8 *)(v113 + v125);
                    goto LABEL_157;
                  }
                }
                v125 += __clz(__rbit64(v128 ^ v127)) >> 3;
              }
              if (v125 > 2 || v110 <= 1 && v125 == 2)
              {
                unint64_t v130 = 135 * v125 + 1935;
                if (v114 < v130)
                {
                  unint64_t v131 = v130 - (((0x1CA10u >> (v110 & 0xE)) & 0xE) + 39);
                  if (!v110) {
                    unint64_t v131 = 135 * v125 + 1935;
                  }
                  if (v114 < v131)
                  {
                    unint64_t v112 = v125;
                    unint64_t v111 = a7[v110];
                    unint64_t v115 = v131;
                    unint64_t v114 = v131;
                    unint64_t v105 = v125;
                  }
                }
              }
            }
            ++v110;
          }
          while (v110 != v102);
        }
        else
        {
          unint64_t v112 = 0;
          unint64_t v111 = 0;
          unint64_t v115 = 2020;
          unint64_t v114 = 2020;
        }
        unint64_t v133 = (_DWORD *)(a3 + v109);
        uint64_t v134 = (506832829 * *(_DWORD *)(a3 + v109)) >> v232;
        uint64_t v135 = v240 + 4 * (v134 << v233);
        unint64_t v136 = *(unsigned __int16 *)(v252 + 2 * v134);
        if (v136 >= v237) {
          unint64_t v137 = v136 - v237;
        }
        else {
          unint64_t v137 = 0;
        }
        if (v137 < v136)
        {
          unint64_t v138 = v24 & 7;
          unint64_t v139 = *(unsigned __int16 *)(v252 + 2 * v134);
          do
          {
            uint64_t v140 = *(unsigned int *)(v135 + 4 * (--v139 & v100));
            unint64_t v141 = v106 - v140;
            if (v106 - v140 > v107) {
              break;
            }
            if (v105 + v109 <= a4)
            {
              unint64_t v142 = v140 & a4;
              if (v142 + v105 <= a4 && *(unsigned __int8 *)(a3 + v105 + v109) == *(unsigned __int8 *)(a3 + v142 + v105))
              {
                uint64_t v143 = a3 + v142;
                if (v24 < 8)
                {
                  unint64_t v145 = 0;
                  uint64_t v243 = (unsigned __int8 *)(a3 + v109);
LABEL_184:
                  if (v138)
                  {
                    unint64_t v150 = v138;
                    do
                    {
                      if (*(unsigned __int8 *)(v143 + v145) != *v243) {
                        break;
                      }
                      ++v243;
                      ++v145;
                      --v150;
                    }
                    while (v150);
                  }
                }
                else
                {
                  unint64_t v144 = v138;
                  unint64_t v145 = 0;
                  unint64_t v146 = v24 >> 3;
                  while (1)
                  {
                    uint64_t v147 = *(void *)((char *)v133 + v145);
                    uint64_t v148 = *(void *)(v143 + v145);
                    if (v147 != v148) {
                      break;
                    }
                    v145 += 8;
                    if (!--v146)
                    {
                      uint64_t v243 = (unsigned __int8 *)v133 + v145;
                      unint64_t v138 = v144;
                      goto LABEL_184;
                    }
                  }
                  v145 += __clz(__rbit64(v148 ^ v147)) >> 3;
                  unint64_t v138 = v144;
                }
                if (v145 >= 4)
                {
                  unint64_t v149 = 135 * v145 - 30 * (__clz(v141) ^ 0x1F) + 1920;
                  if (v114 < v149)
                  {
                    unint64_t v112 = v145;
                    unint64_t v111 = v141;
                    unint64_t v115 = v149;
                    unint64_t v114 = v149;
                    unint64_t v105 = v145;
                  }
                }
              }
            }
          }
          while (v139 > v137);
        }
        *(_DWORD *)(v135 + 4 * (v100 & v136)) = v106;
        *(_WORD *)(v252 + 2 * v134) = v136 + 1;
        if (v115 == 2020)
        {
          uint64_t v151 = *(void *)(a6 + 80);
          unint64_t v152 = *(void *)(v151 + 8);
          unint64_t v153 = *(void *)(v151 + 16);
          uint64_t v75 = a5;
          int v154 = 0;
          if (v153 >= v152 >> 7)
          {
            uint64_t v156 = ((506832829 * *v133) >> 17) & 0x7FFE;
            uint64_t v157 = *(void *)(a5 + 120);
            char v158 = 1;
            unint64_t v115 = 2020;
            unint64_t v159 = v111;
            unint64_t v160 = v112;
            do
            {
              char v161 = v158;
              *(void *)(v151 + 8) = ++v152;
              unint64_t v162 = *(unsigned __int8 *)(v157 + v156);
              if (!*(unsigned char *)(v157 + v156) || v24 < v162) {
                goto LABEL_210;
              }
              uint64_t v163 = *(unsigned __int16 *)(*(void *)(v75 + 112) + 2 * v156);
              uint64_t v164 = *(void *)(v75 + 88);
              uint64_t v165 = *(unsigned int *)(v164 + 4 * v162 + 32);
              uint64_t v166 = *(void *)(v164 + 168);
              unint64_t v167 = (unsigned __int8 *)(v166 + v165 + v163 * *(unsigned __int8 *)(v157 + v156));
              if (v162 < 8)
              {
                unint64_t v112 = 0;
LABEL_215:
                unint64_t v173 = v162 & 7;
                if ((v162 & 7) != 0)
                {
                  unint64_t v174 = v112 | v173;
                  while (*((unsigned __int8 *)v133 + v112) == *v167)
                  {
                    ++v167;
                    ++v112;
                    if (!--v173)
                    {
                      unint64_t v112 = v174;
                      break;
                    }
                  }
                }
              }
              else
              {
                unint64_t v168 = 0;
                unint64_t v112 = v162 & 0xF8;
                uint64_t v169 = (unsigned __int8 *)(v166
                                         + v163 * (unint64_t)*(unsigned __int8 *)(v157 + v156)
                                         + (*(unsigned char *)(v157 + v156) & 0xF8)
                                         + v165);
                while (1)
                {
                  uint64_t v170 = *(void *)&v167[v168];
                  uint64_t v171 = *(void *)&v133[v168 / 4];
                  if (v170 != v171) {
                    break;
                  }
                  v168 += 8;
                  if (v112 == v168)
                  {
                    unint64_t v167 = v169;
                    goto LABEL_215;
                  }
                }
                unint64_t v112 = v168 + (__clz(__rbit64(v171 ^ v170)) >> 3);
              }
              uint64_t v75 = a5;
              if (v112
                && v112 + *(unsigned int *)(a5 + 100) > v162
                && (unint64_t v111 = v242
                         + 1
                         + v163
                         + ((((*(void *)(a5 + 104) >> (6 * (v162 - v112))) & 0x3FLL)
                           + 4 * (v162 - v112)) << *(unsigned char *)(v164 + v162)),
                    v111 <= v246)
                && (unint64_t v172 = 135 * v112 - 30 * (__clz(v111) ^ 0x1F) + 1920, v172 >= v115))
              {
                int v154 = v162 - v112;
                *(void *)(v151 + 16) = ++v153;
                unint64_t v115 = v172;
              }
              else
              {
LABEL_210:
                unint64_t v112 = v160;
                unint64_t v111 = v159;
              }
              char v158 = 0;
              ++v156;
              unint64_t v159 = v111;
              unint64_t v160 = v112;
            }
            while ((v161 & 1) != 0);
          }
          else
          {
            unint64_t v115 = 2020;
          }
        }
        else
        {
          int v154 = 0;
          uint64_t v75 = a5;
        }
        if (v115 < v251 + 175) {
          break;
        }
        ++v253;
        unint64_t v13 = v230;
        if (v249 <= 2)
        {
          unint64_t v155 = v11 + 5;
          unsigned int v99 = v249 + 1;
          unint64_t v245 = v111;
          unint64_t v251 = v115;
          int v236 = v154;
          unint64_t v103 = v112;
          ++v11;
          if (v155 < v230) {
            continue;
          }
        }
        goto LABEL_231;
      }
      unint64_t v182 = v11 + v239;
      if (v11 + v239 >= v238) {
        unint64_t v182 = v238;
      }
      unint64_t v242 = v182;
      unint64_t v111 = v245;
      int v154 = v236;
      unint64_t v13 = v230;
      unint64_t v112 = v231;
      unint64_t v106 = v11;
LABEL_231:
      uint64_t v22 = v252;
      if (v111 > v242) {
        goto LABEL_232;
      }
      uint64_t v188 = *a7;
      if (v111 != v188) {
        break;
      }
      unint64_t v183 = 0;
LABEL_240:
      *(_DWORD *)uint64_t v229 = v253;
      *(_DWORD *)(v229 + 4) = v112 | (v154 << 25);
      uint64_t v189 = *(unsigned int *)(v75 + 68);
      uint64_t v190 = v189 + 16;
      if (v189 + 16 <= v183)
      {
        uint64_t v192 = *(unsigned int *)(v75 + 64);
        unint64_t v193 = v183 - v189 + (4 << v192) - 16;
        uint64_t v194 = (__clz(v193) ^ 0x1F) - 1;
        uint64_t v195 = ((v193 >> v194) & 1 | 2) << v194;
        unint64_t v183 = ((v193 & ~(-1 << v192))
              + v190
              + ((((v193 >> v194) & 1 | (2 * (v194 - v192))) + 65534) << v192)) | ((v194 - v192) << 10);
        unint64_t v191 = (v193 - v195) >> v192;
      }
      else
      {
        LODWORD(v191) = 0;
      }
      *(_WORD *)(v229 + 14) = v183;
      *(_DWORD *)(v229 + 8) = v191;
      if (v253 > 5)
      {
        if (v253 > 0x81)
        {
          if (v253 > 0x841)
          {
            if (v253 >> 1 >= 0xC21)
            {
              if (v253 < 0x5842) {
                LOWORD(v196) = 22;
              }
              else {
                LOWORD(v196) = 23;
              }
            }
            else
            {
              LOWORD(v196) = 21;
            }
          }
          else
          {
            unsigned int v196 = (__clz(v253 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v197 = (__clz(v253 - 2) ^ 0x1F) - 1;
          unsigned int v196 = ((v253 - 2) >> v197) + 2 * v197 + 2;
        }
      }
      else
      {
        LOWORD(v196) = v253;
      }
      uint64_t v209 = v154 + (int)v112;
      if (v209 > 9)
      {
        if (v209 > 0x85)
        {
          if (v209 > 0x845) {
            LOWORD(v210) = 23;
          }
          else {
            unsigned int v210 = (__clz(v209 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v211 = v209 - 6;
          unsigned int v212 = (__clz(v211) ^ 0x1F) - 1;
          unsigned int v210 = (v211 >> v212) + 2 * v212 + 4;
        }
      }
      else
      {
        LOWORD(v210) = v154 + v112 - 2;
      }
      int v213 = v210 & 7 | (8 * (v196 & 7));
      if ((v183 & 0x3FF) != 0 || (unsigned __int16)v196 > 7u || (unsigned __int16)v210 > 0xFu)
      {
        int v215 = 3 * ((unsigned __int16)v196 >> 3) + ((unsigned __int16)(v210 & 0xFFF8) >> 3);
        unsigned int v214 = ((((0x520D40u >> (2 * v215)) & 0xC0) + (v215 << 6)) | v213) + 64;
      }
      else
      {
        LOWORD(v214) = v213 | 0x40;
        if ((v210 & 0xFFF8) == 0) {
          LOWORD(v214) = v210 & 7 | (8 * (v196 & 7));
        }
      }
      *(_WORD *)(v229 + 12) = v214;
      unint64_t v216 = v227;
      *a11 += v253;
      unint64_t v217 = v106 + 2;
      unint64_t v175 = v106 + v112;
      if (v106 + v112 < v227) {
        unint64_t v216 = v106 + v112;
      }
      if (v111 < v112 >> 2)
      {
        unint64_t v218 = v175 - 4 * v111;
        if (v217 > v218) {
          unint64_t v218 = v106 + 2;
        }
        if (v216 >= v218) {
          unint64_t v217 = v218;
        }
        else {
          unint64_t v217 = v216;
        }
      }
      unint64_t v21 = v228 + 2 * v112 + v106;
      unint64_t result = v229 + 16;
      v229 += 16;
      if (v217 >= v216)
      {
        unint64_t v12 = 0;
        uint64_t v23 = v240;
      }
      else
      {
        int v219 = *(_DWORD *)(a6 + 64);
        int v220 = *(_DWORD *)(a6 + 68);
        int v221 = *(_DWORD *)(a6 + 72);
        uint64_t v23 = v240;
        do
        {
          unsigned int v222 = (506832829 * *(_DWORD *)(a3 + (v217 & a4))) >> v219;
          unsigned int v223 = *(unsigned __int16 *)(v252 + 2 * v222);
          *(_DWORD *)(v240 + 4 * ((v222 << v221) + (unint64_t)(v220 & v223))) = v217;
          *(_WORD *)(v252 + 2 * v222) = v223 + 1;
          ++v217;
        }
        while (v216 != v217);
        unint64_t v12 = 0;
      }
LABEL_294:
      unint64_t v11 = v175;
      if (v175 + 4 >= v13) {
        goto LABEL_301;
      }
    }
    uint64_t v204 = a7[1];
    if (v111 == v204)
    {
      unint64_t v183 = 1;
      goto LABEL_233;
    }
    unint64_t v205 = v111 + 3 - v188;
    if (v205 > 6)
    {
      unint64_t v208 = v111 + 3 - v204;
      if (v208 > 6)
      {
        if (v111 == a7[2])
        {
          unint64_t v183 = 2;
        }
        else if (v111 == a7[3])
        {
          unint64_t v183 = 3;
        }
        else
        {
LABEL_232:
          unint64_t v183 = v111 + 15;
        }
LABEL_233:
        if (v111 <= v242)
        {
          if (v183)
          {
            a7[3] = a7[2];
            int32x2_t v184 = *(int32x2_t *)a7;
            *(void *)(a7 + 1) = *(void *)a7;
            *a7 = v111;
            int v185 = *(_DWORD *)(a6 + 76);
            if (v185 >= 5)
            {
              int32x4_t v186 = vdupq_n_s32(v111);
              *((int32x4_t *)a7 + 1) = vaddq_s32(v186, (int32x4_t)xmmword_20DB0A5B0);
              *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v186.i8, (int32x2_t)0x3FFFFFFFDLL);
              if (v185 >= 0xB)
              {
                int32x4_t v187 = vdupq_lane_s32(v184, 0);
                *(int32x4_t *)(a7 + 10) = vaddq_s32(v187, (int32x4_t)xmmword_20DB0A5B0);
                *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v187.i8, (int32x2_t)0x3FFFFFFFDLL);
              }
            }
          }
        }
        goto LABEL_240;
      }
      char v206 = 4 * v208;
      unsigned int v207 = 266017486;
    }
    else
    {
      char v206 = 4 * v205;
      unsigned int v207 = 158663784;
    }
    unint64_t v183 = (v207 >> v206) & 0xF;
    goto LABEL_233;
  }
  uint64_t v229 = a9;
  unint64_t v175 = a2;
LABEL_301:
  *a8 = v12 + v13 - v175;
  *a10 += (v229 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH6(unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, _DWORD *a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v236 = *(void *)(a5 + 16);
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  unint64_t v220 = v13 - 7;
  if (result <= 7) {
    unint64_t v14 = v11;
  }
  else {
    unint64_t v14 = v13 - 7;
  }
  int v15 = *(_DWORD *)(a5 + 8);
  uint64_t v16 = 512;
  if (*(int *)(a5 + 4) < 9) {
    uint64_t v16 = 64;
  }
  unint64_t v221 = v14;
  uint64_t v222 = v16;
  int v17 = *(_DWORD *)(a6 + 88);
  if (v17 >= 5)
  {
    int32x4_t v18 = (int32x4_t)vld1q_dup_f32((const float *)a7);
    *((int32x4_t *)a7 + 1) = vaddq_s32(v18, (int32x4_t)xmmword_20DB0A5B0);
    *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x3FFFFFFFDLL);
    if (v17 >= 0xB)
    {
      unint64_t v19 = (const float *)(a7 + 1);
      int32x4_t v20 = (int32x4_t)vld1q_dup_f32(v19);
      *(int32x4_t *)(a7 + 10) = vaddq_s32(v20, (int32x4_t)xmmword_20DB0A5B0);
      *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v20.i8, (int32x2_t)0x3FFFFFFFDLL);
    }
  }
  if (v11 + 8 < v13)
  {
    unint64_t v21 = v222 + v11;
    unint64_t v235 = (1 << v15) - 16;
    uint64_t v22 = *(void *)(a6 + 104);
    unsigned int v223 = a9;
    uint64_t v247 = a5;
    uint64_t v244 = v22;
    unint64_t v231 = v13;
    unint64_t v237 = *(void *)(a6 + 72);
    unint64_t v238 = *(void *)(a6 + 112);
    while (1)
    {
      unint64_t v245 = v12;
      unint64_t v23 = v13 - v11;
      if (v11 >= v235) {
        unint64_t v24 = v235;
      }
      else {
        unint64_t v24 = v11;
      }
      unint64_t v25 = v11 + v236;
      if (v11 + v236 >= v235) {
        unint64_t v25 = v235;
      }
      unint64_t v242 = v25;
      unint64_t v26 = v11 & a4;
      uint64_t v27 = *(int *)(a6 + 88);
      unint64_t result = v23 >> 3;
      if (v27)
      {
        unint64_t v28 = 0;
        unint64_t v29 = 0;
        unint64_t v30 = 0;
        unint64_t v31 = 0;
        unint64_t v32 = 2020;
        unint64_t v246 = 2020;
        do
        {
          unint64_t v33 = a7[v28];
          unint64_t v34 = v11 - v33;
          BOOL v35 = v24 < v33 || v34 >= v11;
          unint64_t v36 = v34 & a4;
          unint64_t v37 = v29 + v26;
          BOOL v38 = v35 || v37 > a4;
          unint64_t v39 = v36 + v29;
          BOOL v40 = v38 || v39 > a4;
          if (!v40 && *(unsigned __int8 *)(a3 + v37) == *(unsigned __int8 *)(a3 + v39))
          {
            uint64_t v41 = a3 + v36;
            if (v23 < 8)
            {
              unint64_t v46 = 0;
              unint64_t v47 = (unsigned __int8 *)(a3 + v26);
LABEL_54:
              if ((v23 & 7) != 0)
              {
                unint64_t v51 = v23 & 7 | v46;
                unint64_t v52 = v23 & 7;
                while (*(unsigned __int8 *)(v41 + v46) == *v47)
                {
                  ++v47;
                  ++v46;
                  if (!--v52)
                  {
                    unint64_t v46 = v51;
                    break;
                  }
                }
                a5 = v247;
                uint64_t v22 = v244;
              }
            }
            else
            {
              uint64_t v42 = 0;
              unint64_t v43 = v23 >> 3;
              while (1)
              {
                uint64_t v44 = *(void *)(a3 + v26 + v42);
                uint64_t v45 = *(void *)(v41 + v42);
                if (v44 != v45) {
                  break;
                }
                v42 += 8;
                if (!--v43)
                {
                  unint64_t v46 = v23 & 0xFFFFFFFFFFFFFFF8;
                  unint64_t v47 = (unsigned __int8 *)(a3 + v26 + (v23 & 0xFFFFFFFFFFFFFFF8));
                  goto LABEL_54;
                }
              }
              unint64_t v46 = v42 + (__clz(__rbit64(v45 ^ v44)) >> 3);
            }
            if (v46 > 2 || v28 <= 1 && v46 == 2)
            {
              unint64_t v48 = 135 * v46 + 1935;
              if (v32 < v48)
              {
                if (v28) {
                  v48 -= ((0x1CA10u >> (v28 & 0xE)) & 0xE) + 39;
                }
                BOOL v49 = v32 >= v48;
                if (v32 < v48) {
                  unint64_t v31 = a7[v28];
                }
                unint64_t v50 = v246;
                if (v32 < v48) {
                  unint64_t v50 = v48;
                }
                unint64_t v246 = v50;
                if (v32 < v48)
                {
                  unint64_t v30 = v46;
                  unint64_t v32 = v48;
                }
                if (!v49) {
                  unint64_t v29 = v46;
                }
              }
            }
          }
          ++v28;
        }
        while (v28 != v27);
      }
      else
      {
        unint64_t v31 = 0;
        unint64_t v30 = 0;
        unint64_t v29 = 0;
        unint64_t v246 = 2020;
        unint64_t v32 = 2020;
      }
      unint64_t v241 = *(void *)(a5 + 80);
      unint64_t v53 = (_DWORD *)(a3 + v26);
      unint64_t v54 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + v26) & v237)) >> *(_DWORD *)(a6 + 64);
      uint64_t v55 = *(unsigned int *)(a6 + 80);
      unint64_t v56 = v238 + 4 * (v54 << *(_DWORD *)(a6 + 84));
      unint64_t v57 = *(unsigned __int16 *)(v22 + 2 * v54);
      unint64_t v234 = *(void *)(a6 + 56);
      if (v57 >= v234) {
        unint64_t v58 = v57 - v234;
      }
      else {
        unint64_t v58 = 0;
      }
      if (v58 < v57)
      {
        unint64_t v59 = v23 & 7;
        unint64_t v60 = *(unsigned __int16 *)(v22 + 2 * v54);
        do
        {
          uint64_t v61 = *(unsigned int *)(v56 + 4 * (--v60 & v55));
          unint64_t v62 = v11 - v61;
          if (v11 - v61 > v24) {
            break;
          }
          if (v29 + v26 <= a4)
          {
            uint64_t v63 = v61 & a4;
            if (v63 + v29 <= a4 && *(unsigned __int8 *)(a3 + v29 + v26) == *(unsigned __int8 *)(a3 + v63 + v29))
            {
              unint64_t v64 = v59;
              uint64_t v65 = a3 + v63;
              if (v23 < 8)
              {
                unint64_t v239 = v21;
                unint64_t v70 = 0;
                unint64_t v71 = (unsigned __int8 *)(a3 + v26);
LABEL_82:
                if (v64)
                {
                  unint64_t v73 = v64;
                  unint64_t v232 = v64 | v70;
                  while (*(unsigned __int8 *)(v65 + v70) == *v71)
                  {
                    ++v71;
                    ++v70;
                    if (!--v73)
                    {
                      unint64_t v70 = v232;
                      break;
                    }
                  }
                }
                unint64_t v21 = v239;
              }
              else
              {
                uint64_t v66 = 0;
                unint64_t v67 = v23 >> 3;
                while (1)
                {
                  uint64_t v68 = *(void *)&v53[v66];
                  uint64_t v69 = *(void *)(v65 + v66 * 4);
                  if (v68 != v69) {
                    break;
                  }
                  v66 += 2;
                  if (!--v67)
                  {
                    unint64_t v239 = v21;
                    unint64_t v70 = v23 & 0xFFFFFFFFFFFFFFF8;
                    unint64_t v71 = (unsigned __int8 *)v53 + (v23 & 0xFFFFFFFFFFFFFFF8);
                    goto LABEL_82;
                  }
                }
                unint64_t v70 = v66 * 4 + (__clz(__rbit64(v69 ^ v68)) >> 3);
              }
              unint64_t v59 = v64;
              if (v70 >= 4)
              {
                unsigned int v72 = __clz(v62) ^ 0x1F;
                if (v32 < 135 * v70 - 30 * v72 + 1920)
                {
                  unint64_t v31 = v62;
                  unint64_t v246 = 135 * v70 - 30 * v72 + 1920;
                  unint64_t v30 = v70;
                  unint64_t v32 = v246;
                  unint64_t v29 = v70;
                }
              }
            }
          }
        }
        while (v60 > v58);
      }
      *(_DWORD *)(v56 + 4 * (v55 & v57)) = v11;
      uint64_t v22 = v244;
      *(_WORD *)(v244 + 2 * v54) = v57 + 1;
      if (v246 == 2020)
      {
        uint64_t v74 = *(void *)(a6 + 96);
        unint64_t result = *(void *)(v74 + 8);
        unint64_t v75 = *(void *)(v74 + 16);
        a5 = v247;
        if (v75 < result >> 7) {
          goto LABEL_225;
        }
        unint64_t v76 = v31;
        int v233 = 0;
        uint64_t v77 = ((506832829 * *v53) >> 17) & 0x7FFE;
        uint64_t v78 = *(void *)(v247 + 120);
        char v79 = 1;
        unint64_t v80 = v30;
        unint64_t v246 = 2020;
        do
        {
          char v81 = v79;
          *(void *)(v74 + 8) = ++result;
          unint64_t v82 = *(unsigned __int8 *)(v78 + v77);
          if (!*(unsigned char *)(v78 + v77) || v23 < v82) {
            goto LABEL_103;
          }
          uint64_t v83 = *(unsigned __int16 *)(*(void *)(v247 + 112) + 2 * v77);
          uint64_t v84 = *(void *)(v247 + 88);
          uint64_t v85 = *(unsigned int *)(v84 + 4 * v82 + 32);
          uint64_t v86 = *(void *)(v84 + 168);
          uint64_t v87 = (unsigned __int8 *)(v86 + v85 + v83 * *(unsigned __int8 *)(v78 + v77));
          if (v82 < 8)
          {
            unint64_t v30 = 0;
LABEL_108:
            unint64_t v94 = v82 & 7;
            if ((v82 & 7) != 0)
            {
              unint64_t v95 = v30;
              v30 |= v94;
              while (*((unsigned __int8 *)v53 + v95) == *v87)
              {
                ++v87;
                ++v95;
                if (!--v94) {
                  goto LABEL_99;
                }
              }
              unint64_t v30 = v95;
            }
          }
          else
          {
            unint64_t v88 = 0;
            unint64_t v30 = v82 & 0xF8;
            unint64_t v89 = (unsigned __int8 *)(v86
                                    + v83 * (unint64_t)*(unsigned __int8 *)(v78 + v77)
                                    + (*(unsigned char *)(v78 + v77) & 0xF8)
                                    + v85);
            while (1)
            {
              uint64_t v90 = *(void *)&v87[v88];
              uint64_t v91 = *(void *)&v53[v88 / 4];
              if (v90 != v91) {
                break;
              }
              v88 += 8;
              if (v30 == v88)
              {
                uint64_t v87 = v89;
                goto LABEL_108;
              }
            }
            unint64_t v30 = v88 + (__clz(__rbit64(v91 ^ v90)) >> 3);
          }
LABEL_99:
          if (v30
            && v30 + *(unsigned int *)(v247 + 100) > v82
            && (unint64_t v92 = v242
                    + 1
                    + v83
                    + ((((*(void *)(v247 + 104) >> (6 * (v82 - v30))) & 0x3FLL)
                      + 4 * (v82 - v30)) << *(unsigned char *)(v84 + v82)),
                v92 <= v241)
            && (unint64_t v93 = 135 * v30 - 30 * (__clz(v92) ^ 0x1F) + 1920, v93 >= v246))
          {
            int v233 = v82 - v30;
            *(void *)(v74 + 16) = ++v75;
            unint64_t v246 = v93;
          }
          else
          {
LABEL_103:
            unint64_t v92 = v76;
            unint64_t v30 = v80;
          }
          char v79 = 0;
          ++v77;
          unint64_t v80 = v30;
          unint64_t v76 = v92;
        }
        while ((v81 & 1) != 0);
      }
      else
      {
        int v233 = 0;
        a5 = v247;
        unint64_t v92 = v31;
      }
      if (v246 < 0x7E5)
      {
LABEL_225:
        unint64_t v12 = v245 + 1;
        unint64_t v169 = v11 + 1;
        if (v11 + 1 > v21)
        {
          unint64_t v13 = v231;
          unint64_t result = v238;
          if (v169 <= v21 + 4 * v222)
          {
            unint64_t v177 = v220;
            if (v11 + 9 < v220) {
              unint64_t v177 = v11 + 9;
            }
            if (v169 < v177)
            {
              int v178 = *(_DWORD *)(a6 + 64);
              int v179 = *(_DWORD *)(a6 + 80);
              int v180 = *(_DWORD *)(a6 + 84);
              do
              {
                unint64_t v181 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + (v169 & a4)) & v237)) >> v178;
                unsigned int v182 = *(unsigned __int16 *)(v244 + 2 * v181);
                *(_WORD *)(v244 + 2 * v181) = v182 + 1;
                *(_DWORD *)(v238 + 4 * ((v181 << v180) + (unint64_t)(v179 & v182))) = v169;
                v12 += 2;
                v169 += 2;
              }
              while (v169 < v177);
            }
          }
          else
          {
            unint64_t v170 = v220;
            if (v11 + 17 < v220) {
              unint64_t v170 = v11 + 17;
            }
            if (v169 < v170)
            {
              int v171 = *(_DWORD *)(a6 + 64);
              int v172 = *(_DWORD *)(a6 + 80);
              int v173 = *(_DWORD *)(a6 + 84);
              do
              {
                unint64_t v174 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + (v169 & a4)) & v237)) >> v171;
                unsigned int v175 = *(unsigned __int16 *)(v244 + 2 * v174);
                *(_WORD *)(v244 + 2 * v174) = v175 + 1;
                *(_DWORD *)(v238 + 4 * ((v174 << v173) + (unint64_t)(v172 & v175))) = v169;
                v12 += 4;
                v169 += 4;
              }
              while (v169 < v170);
            }
          }
          goto LABEL_300;
        }
        goto LABEL_299;
      }
      unsigned int v96 = 0;
      int v228 = *(_DWORD *)(a6 + 64);
      int v227 = *(_DWORD *)(a6 + 84);
      uint64_t v97 = *(unsigned int *)(a6 + 80);
      unsigned int v229 = *(_DWORD *)(a6 + 88);
      if (v229 <= 1) {
        int v98 = 1;
      }
      else {
        int v98 = *(_DWORD *)(a6 + 88);
      }
      uint64_t v99 = v98;
      while (1)
      {
        unsigned int v243 = v96;
        unint64_t v225 = v92;
        unint64_t v226 = v30;
        --v23;
        unint64_t v100 = v30 - 1;
        if (v30 - 1 >= v23) {
          unint64_t v100 = v23;
        }
        if (*(int *)(a5 + 4) >= 5) {
          unint64_t v101 = 0;
        }
        else {
          unint64_t v101 = v100;
        }
        unint64_t v102 = v11 + 1;
        if (v11 + 1 < v235) {
          unint64_t v103 = v11 + 1;
        }
        else {
          unint64_t v103 = v235;
        }
        unint64_t v104 = v102 + v236;
        if (v102 + v236 >= v235) {
          unint64_t v104 = v235;
        }
        unint64_t v240 = v104;
        unint64_t v105 = v102 & a4;
        if (v229)
        {
          unint64_t v106 = 0;
          unint64_t v107 = 0;
          unint64_t v108 = 0;
          uint64_t v109 = a3 + v105;
          unint64_t v110 = 2020;
          unint64_t v111 = 2020;
          do
          {
            unint64_t v112 = a7[v106];
            unint64_t v113 = v102 - v112;
            BOOL v114 = v103 < v112 || v113 >= v102;
            uint64_t v115 = v113 & a4;
            unint64_t v116 = v101 + v105;
            BOOL v117 = v114 || v116 > a4;
            unint64_t v118 = v115 + v101;
            BOOL v119 = v117 || v118 > a4;
            if (!v119 && *(unsigned __int8 *)(a3 + v116) == *(unsigned __int8 *)(a3 + v118))
            {
              uint64_t v120 = a3 + v115;
              if (v23 < 8)
              {
                unint64_t v121 = 0;
                unint64_t v125 = (unsigned __int8 *)(a3 + v105);
LABEL_162:
                if ((v23 & 7) != 0)
                {
                  unint64_t v127 = v23 & 7;
                  do
                  {
                    if (*(unsigned __int8 *)(v120 + v121) != *v125) {
                      break;
                    }
                    ++v125;
                    ++v121;
                    --v127;
                  }
                  while (v127);
                }
              }
              else
              {
                unint64_t v121 = 0;
                unint64_t v122 = v23 >> 3;
                while (1)
                {
                  uint64_t v123 = *(void *)(v109 + v121);
                  uint64_t v124 = *(void *)(v120 + v121);
                  if (v123 != v124) {
                    break;
                  }
                  v121 += 8;
                  if (!--v122)
                  {
                    unint64_t v125 = (unsigned __int8 *)(v109 + v121);
                    goto LABEL_162;
                  }
                }
                v121 += __clz(__rbit64(v124 ^ v123)) >> 3;
              }
              if (v121 > 2 || v106 <= 1 && v121 == 2)
              {
                unint64_t v126 = 135 * v121 + 1935;
                if (v110 < v126)
                {
                  if (v106) {
                    v126 -= ((0x1CA10u >> (v106 & 0xE)) & 0xE) + 39;
                  }
                  if (v110 < v126)
                  {
                    unint64_t v108 = v121;
                    unint64_t v107 = a7[v106];
                    unint64_t v111 = v126;
                    unint64_t v110 = v126;
                    unint64_t v101 = v121;
                  }
                }
              }
            }
            ++v106;
          }
          while (v106 != v99);
        }
        else
        {
          unint64_t v108 = 0;
          unint64_t v107 = 0;
          unint64_t v111 = 2020;
          unint64_t v110 = 2020;
        }
        uint64_t v128 = (_DWORD *)(a3 + v105);
        unint64_t v129 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + v105) & v237)) >> v228;
        unint64_t v130 = v238 + 4 * (v129 << v227);
        unint64_t v131 = *(unsigned __int16 *)(v244 + 2 * v129);
        if (v131 >= v234) {
          unint64_t v132 = v131 - v234;
        }
        else {
          unint64_t v132 = 0;
        }
        if (v132 < v131)
        {
          unint64_t v133 = *(unsigned __int16 *)(v244 + 2 * v129);
          do
          {
            uint64_t v134 = *(unsigned int *)(v130 + 4 * (--v133 & v97));
            unint64_t v135 = v102 - v134;
            if (v102 - v134 > v103) {
              break;
            }
            if (v101 + v105 <= a4)
            {
              uint64_t v136 = v134 & a4;
              if (v136 + v101 <= a4 && *(unsigned __int8 *)(a3 + v101 + v105) == *(unsigned __int8 *)(a3 + v136 + v101))
              {
                uint64_t v137 = a3 + v136;
                if (v23 < 8)
                {
                  unint64_t v138 = 0;
                  unint64_t v142 = (unsigned __int8 *)(a3 + v105);
LABEL_189:
                  if ((v23 & 7) != 0)
                  {
                    unint64_t v144 = v23 & 7;
                    do
                    {
                      unint64_t v219 = v144;
                      if (*(unsigned __int8 *)(v137 + v138) != *v142) {
                        break;
                      }
                      ++v142;
                      ++v138;
                      --v144;
                    }
                    while (v219 != 1);
                  }
                }
                else
                {
                  unint64_t v138 = 0;
                  unint64_t v139 = v23 >> 3;
                  while (1)
                  {
                    uint64_t v140 = *(void *)((char *)v128 + v138);
                    uint64_t v141 = *(void *)(v137 + v138);
                    if (v140 != v141) {
                      break;
                    }
                    v138 += 8;
                    if (!--v139)
                    {
                      unint64_t v142 = (unsigned __int8 *)v128 + v138;
                      goto LABEL_189;
                    }
                  }
                  v138 += __clz(__rbit64(v141 ^ v140)) >> 3;
                }
                if (v138 >= 4)
                {
                  unsigned int v143 = __clz(v135) ^ 0x1F;
                  if (v110 < 135 * v138 - 30 * v143 + 1920)
                  {
                    unint64_t v108 = v138;
                    unint64_t v107 = v135;
                    unint64_t v111 = 135 * v138 - 30 * v143 + 1920;
                    unint64_t v110 = v111;
                    unint64_t v101 = v138;
                  }
                }
              }
            }
          }
          while (v133 > v132);
        }
        *(_DWORD *)(v130 + 4 * (v97 & v131)) = v102;
        *(_WORD *)(v244 + 2 * v129) = v131 + 1;
        if (v111 == 2020)
        {
          uint64_t v145 = *(void *)(a6 + 96);
          unint64_t v146 = *(void *)(v145 + 8);
          if (*(void *)(v145 + 16) >= v146 >> 7)
          {
            uint64_t v224 = *(void *)(v145 + 16);
            int v147 = 0;
            uint64_t v150 = ((506832829 * *v128) >> 17) & 0x7FFE;
            uint64_t v151 = *(void *)(v247 + 120);
            char v152 = 1;
            unint64_t v111 = 2020;
            unint64_t v153 = v107;
            unint64_t v154 = v108;
            do
            {
              char v155 = v152;
              *(void *)(v145 + 8) = ++v146;
              unint64_t v156 = *(unsigned __int8 *)(v151 + v150);
              if (!*(unsigned char *)(v151 + v150) || v23 < v156) {
                goto LABEL_215;
              }
              uint64_t v157 = *(unsigned __int16 *)(*(void *)(v247 + 112) + 2 * v150);
              uint64_t v158 = *(void *)(v247 + 88);
              uint64_t v159 = *(unsigned int *)(v158 + 4 * v156 + 32);
              uint64_t v160 = *(void *)(v158 + 168);
              char v161 = (unsigned __int8 *)(v160 + v159 + v157 * *(unsigned __int8 *)(v151 + v150));
              if (v156 < 8)
              {
                unint64_t v108 = 0;
LABEL_220:
                unint64_t v167 = v156 & 7;
                if ((v156 & 7) != 0)
                {
                  unint64_t v168 = v108 | v167;
                  while (*((unsigned __int8 *)v128 + v108) == *v161)
                  {
                    ++v161;
                    ++v108;
                    if (!--v167)
                    {
                      unint64_t v108 = v168;
                      break;
                    }
                  }
                }
              }
              else
              {
                unint64_t v162 = 0;
                unint64_t v108 = v156 & 0xF8;
                uint64_t v163 = (unsigned __int8 *)(v160
                                         + v157 * (unint64_t)*(unsigned __int8 *)(v151 + v150)
                                         + (*(unsigned char *)(v151 + v150) & 0xF8)
                                         + v159);
                while (1)
                {
                  uint64_t v164 = *(void *)&v161[v162];
                  uint64_t v165 = *(void *)&v128[v162 / 4];
                  if (v164 != v165) {
                    break;
                  }
                  v162 += 8;
                  if (v108 == v162)
                  {
                    char v161 = v163;
                    goto LABEL_220;
                  }
                }
                unint64_t v108 = v162 + (__clz(__rbit64(v165 ^ v164)) >> 3);
              }
              if (v108
                && v108 + *(unsigned int *)(v247 + 100) > v156
                && (unint64_t v107 = v240
                         + 1
                         + v157
                         + ((((*(void *)(v247 + 104) >> (6 * (v156 - v108))) & 0x3FLL)
                           + 4 * (v156 - v108)) << *(unsigned char *)(v158 + v156)),
                    v107 <= v241)
                && (unint64_t v166 = 135 * v108 - 30 * (__clz(v107) ^ 0x1F) + 1920, v166 >= v111))
              {
                int v147 = v156 - v108;
                *(void *)(v145 + 16) = ++v224;
                unint64_t v111 = v166;
              }
              else
              {
LABEL_215:
                unint64_t v108 = v154;
                unint64_t v107 = v153;
              }
              char v152 = 0;
              ++v150;
              unint64_t v153 = v107;
              unint64_t v154 = v108;
            }
            while ((v155 & 1) != 0);
          }
          else
          {
            int v147 = 0;
            unint64_t v111 = 2020;
          }
        }
        else
        {
          int v147 = 0;
        }
        if (v111 < v246 + 175) {
          break;
        }
        ++v245;
        if (v243 > 2)
        {
          a5 = v247;
          int v149 = v147;
          goto LABEL_243;
        }
        unint64_t v148 = v11 + 9;
        unsigned int v96 = v243 + 1;
        unint64_t v92 = v107;
        unint64_t v246 = v111;
        int v149 = v147;
        int v233 = v147;
        unint64_t v30 = v108;
        ++v11;
        a5 = v247;
        if (v148 >= v231) {
          goto LABEL_243;
        }
      }
      unint64_t v176 = v11 + v236;
      if (v11 + v236 >= v235) {
        unint64_t v176 = v235;
      }
      unint64_t v240 = v176;
      unint64_t v107 = v225;
      unint64_t v108 = v226;
      int v149 = v233;
      unint64_t v102 = v11;
      a5 = v247;
LABEL_243:
      unint64_t result = v238;
      uint64_t v22 = v244;
      unint64_t v183 = v223;
      if (v107 > v240) {
        goto LABEL_244;
      }
      uint64_t v189 = *a7;
      if (v107 != v189) {
        break;
      }
      unint64_t v184 = 0;
LABEL_252:
      *unsigned int v223 = v245;
      v223[1] = v108 | (v149 << 25);
      uint64_t v190 = *(unsigned int *)(a5 + 68);
      uint64_t v191 = v190 + 16;
      if (v190 + 16 <= v184)
      {
        uint64_t v193 = *(unsigned int *)(a5 + 64);
        unint64_t v194 = v184 - v190 + (4 << v193) - 16;
        uint64_t v195 = (__clz(v194) ^ 0x1F) - 1;
        uint64_t v196 = ((v194 >> v195) & 1 | 2) << v195;
        unint64_t v183 = v223;
        unint64_t v184 = ((v194 & ~(-1 << v193))
              + v191
              + ((((v194 >> v195) & 1 | (2 * (v195 - v193))) + 65534) << v193)) | ((v195 - v193) << 10);
        unint64_t v192 = (v194 - v196) >> v193;
      }
      else
      {
        LODWORD(v192) = 0;
      }
      *((_WORD *)v183 + 7) = v184;
      v183[2] = v192;
      if (v245 > 5)
      {
        if (v245 > 0x81)
        {
          if (v245 > 0x841)
          {
            if (v245 >> 1 >= 0xC21)
            {
              if (v245 < 0x5842) {
                LOWORD(v197) = 22;
              }
              else {
                LOWORD(v197) = 23;
              }
            }
            else
            {
              LOWORD(v197) = 21;
            }
          }
          else
          {
            unsigned int v197 = (__clz(v245 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v198 = (__clz(v245 - 2) ^ 0x1F) - 1;
          unsigned int v197 = ((v245 - 2) >> v198) + 2 * v198 + 2;
        }
      }
      else
      {
        LOWORD(v197) = v245;
      }
      uint64_t v204 = v149 + (int)v108;
      if (v204 > 9)
      {
        if (v204 > 0x85)
        {
          if (v204 > 0x845) {
            LOWORD(v205) = 23;
          }
          else {
            unsigned int v205 = (__clz(v204 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v206 = v204 - 6;
          unsigned int v207 = (__clz(v206) ^ 0x1F) - 1;
          unsigned int v205 = (v206 >> v207) + 2 * v207 + 4;
        }
      }
      else
      {
        LOWORD(v205) = v149 + v108 - 2;
      }
      int v208 = v205 & 7 | (8 * (v197 & 7));
      if ((v184 & 0x3FF) != 0 || (unsigned __int16)v197 > 7u || (unsigned __int16)v205 > 0xFu)
      {
        int v210 = 3 * ((unsigned __int16)v197 >> 3) + ((unsigned __int16)(v205 & 0xFFF8) >> 3);
        unsigned int v209 = ((((0x520D40u >> (2 * v210)) & 0xC0) + (v210 << 6)) | v208) + 64;
      }
      else
      {
        LOWORD(v209) = v208 | 0x40;
        if ((v205 & 0xFFF8) == 0) {
          LOWORD(v209) = v205 & 7 | (8 * (v197 & 7));
        }
      }
      *((_WORD *)v183 + 6) = v209;
      unint64_t v211 = v221;
      *a11 += v245;
      unint64_t v212 = v102 + 2;
      unint64_t v169 = v102 + v108;
      if (v102 + v108 < v221) {
        unint64_t v211 = v102 + v108;
      }
      if (v107 < v108 >> 2)
      {
        if (v212 <= v169 - 4 * v107) {
          unint64_t v212 = v169 - 4 * v107;
        }
        if (v211 < v212) {
          unint64_t v212 = v211;
        }
      }
      unint64_t v21 = v222 + 2 * v108 + v102;
      unsigned int v223 = v183 + 4;
      if (v212 < v211)
      {
        unint64_t v13 = v231;
        int v213 = *(_DWORD *)(a6 + 64);
        int v214 = *(_DWORD *)(a6 + 80);
        int v215 = *(_DWORD *)(a6 + 84);
        do
        {
          unint64_t v216 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + (v212 & a4)) & v237)) >> v213;
          unsigned int v217 = *(unsigned __int16 *)(v244 + 2 * v216);
          *(_WORD *)(v244 + 2 * v216) = v217 + 1;
          *(_DWORD *)(v238 + 4 * ((v216 << v215) + (unint64_t)(v214 & v217))) = v212++;
        }
        while (v211 != v212);
        unint64_t v12 = 0;
        goto LABEL_300;
      }
      unint64_t v12 = 0;
LABEL_299:
      unint64_t v13 = v231;
LABEL_300:
      unint64_t v11 = v169;
      if (v169 + 8 >= v13) {
        goto LABEL_307;
      }
    }
    uint64_t v199 = a7[1];
    if (v107 == v199)
    {
      unint64_t v184 = 1;
      goto LABEL_245;
    }
    unint64_t v200 = v107 + 3 - v189;
    if (v200 > 6)
    {
      unint64_t v203 = v107 + 3 - v199;
      if (v203 > 6)
      {
        if (v107 == a7[2])
        {
          unint64_t v184 = 2;
        }
        else if (v107 == a7[3])
        {
          unint64_t v184 = 3;
        }
        else
        {
LABEL_244:
          unint64_t v184 = v107 + 15;
        }
LABEL_245:
        if (v107 <= v240)
        {
          if (v184)
          {
            a7[3] = a7[2];
            int32x2_t v185 = *(int32x2_t *)a7;
            *(void *)(a7 + 1) = *(void *)a7;
            *a7 = v107;
            int v186 = *(_DWORD *)(a6 + 88);
            if (v186 >= 5)
            {
              int32x4_t v187 = vdupq_n_s32(v107);
              *((int32x4_t *)a7 + 1) = vaddq_s32(v187, (int32x4_t)xmmword_20DB0A5B0);
              *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v187.i8, (int32x2_t)0x3FFFFFFFDLL);
              if (v186 >= 0xB)
              {
                int32x4_t v188 = vdupq_lane_s32(v185, 0);
                *(int32x4_t *)(a7 + 10) = vaddq_s32(v188, (int32x4_t)xmmword_20DB0A5B0);
                *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v188.i8, (int32x2_t)0x3FFFFFFFDLL);
              }
            }
          }
        }
        goto LABEL_252;
      }
      char v201 = 4 * v203;
      unsigned int v202 = 266017486;
    }
    else
    {
      char v201 = 4 * v200;
      unsigned int v202 = 158663784;
    }
    unint64_t v184 = (v202 >> v201) & 0xF;
    goto LABEL_245;
  }
  unsigned int v223 = a9;
  unint64_t v169 = v11;
LABEL_307:
  *a8 = v12 + v13 - v169;
  *a10 += ((char *)v223 - (char *)a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH40(unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  uint64_t v11 = a9;
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 3;
  unint64_t v220 = v14;
  if (result <= 3) {
    uint64_t v14 = a2;
  }
  unint64_t v223 = v14;
  uint64_t v15 = 64;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v15 = 512;
  }
  if (a2 + 4 < v13)
  {
    unint64_t v16 = (1 << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v222 = v15;
    unint64_t v17 = v15 + a2;
    uint64_t v230 = a5;
    uint64_t v231 = *(void *)(a5 + 16);
    uint64_t v221 = 4 * v15;
    unint64_t v219 = v13 - 4;
    uint64_t v18 = a9;
    unint64_t v227 = a2 + result;
    uint64_t v245 = a3;
    unint64_t v229 = v16;
    while (1)
    {
      uint64_t v224 = v18;
      uint64_t v19 = 0;
      unint64_t v20 = 0;
      unint64_t v21 = 0;
      unint64_t v22 = 0;
      unint64_t v23 = v13 - a2;
      if (a2 >= v16) {
        unint64_t v24 = v16;
      }
      else {
        unint64_t v24 = a2;
      }
      unint64_t v239 = v17;
      unint64_t v241 = *(void *)(a5 + 80);
      uint64_t v242 = *(void *)(a6 + 64);
      unint64_t v244 = v12;
      uint64_t v25 = v242 + 196608;
      unint64_t v26 = a2 & a4;
      uint64_t v27 = (unsigned __int8 *)(a3 + (a2 & a4));
      uint64_t v28 = (506832829 * *(_DWORD *)v27) >> 17;
      unint64_t result = v23 >> 3;
      unint64_t v236 = v23 & 7;
      unint64_t v29 = 2020;
      uint64_t v30 = 2020;
      do
      {
        unint64_t v31 = a7[v19];
        unint64_t v32 = a2 - v31;
        if ((!v19 || *(unsigned __int8 *)(v25 + (unsigned __int16)(a2 - v31)) == v28)
          && v24 >= v31
          && v32 < a2)
        {
          uint64_t v34 = a3 + (v32 & a4);
          if (v23 < 8)
          {
            unint64_t v39 = 0;
            BOOL v40 = (unsigned __int8 *)(a3 + (a2 & a4));
LABEL_32:
            if ((v23 & 7) != 0)
            {
              unint64_t v43 = v236 | v39;
              unint64_t v44 = v23 & 7;
              while (*(unsigned __int8 *)(v34 + v39) == *v40)
              {
                ++v40;
                ++v39;
                if (!--v44)
                {
                  unint64_t v39 = v43;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v35 = 0;
            unint64_t v36 = v23 >> 3;
            while (1)
            {
              uint64_t v37 = *(void *)&v27[v35];
              uint64_t v38 = *(void *)(v34 + v35);
              if (v37 != v38) {
                break;
              }
              v35 += 8;
              if (!--v36)
              {
                BOOL v40 = &v27[v23 & 0xFFFFFFFFFFFFFFF8];
                unint64_t v39 = v23 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_32;
              }
            }
            unint64_t v39 = v35 + (__clz(__rbit64(v38 ^ v37)) >> 3);
          }
          if (v39 >= 2)
          {
            unint64_t v41 = 135 * v39 + 1935;
            if (v29 < v41)
            {
              unint64_t v42 = v41 - (((0x1CA10u >> (v19 & 0xE)) & 0xE) + 39);
              if (!v19) {
                unint64_t v42 = 135 * v39 + 1935;
              }
              if (v29 < v42)
              {
                unint64_t v22 = a7[v19];
                uint64_t v30 = v42;
                unint64_t v21 = v39;
                unint64_t v29 = v42;
                unint64_t v20 = v39;
              }
            }
          }
        }
        ++v19;
      }
      while (v19 != 4);
      unint64_t v45 = v21;
      if (a2 + v231 >= v16) {
        unint64_t v46 = v16;
      }
      else {
        unint64_t v46 = a2 + v231;
      }
      unint64_t v238 = v46;
      uint64_t v47 = v242 + 0x40000;
      uint64_t v48 = a6;
      uint64_t v49 = *(void *)(a6 + 56);
      unint64_t v50 = a2;
      unint64_t v51 = a2 - *(unsigned int *)(v242 + 4 * v28);
      __int16 v52 = *(_WORD *)(v242 + 0x20000 + 2 * v28);
      if (v49)
      {
        unint64_t v53 = 0;
        uint64_t v54 = *(unsigned __int16 *)(v242 + 0x20000 + 2 * v28);
        unint64_t v55 = v51;
        do
        {
          v53 += v55;
          if (v53 > v24) {
            break;
          }
          if (v20 + v26 <= a4)
          {
            unint64_t v56 = (v50 - v53) & a4;
            if (v56 + v20 <= a4)
            {
              if (*(unsigned __int8 *)(v245 + v20 + v26) == *(unsigned __int8 *)(v245 + v56 + v20))
              {
                uint64_t v57 = v245 + v56;
                if (v23 < 8)
                {
                  unint64_t v62 = 0;
                  uint64_t v63 = v27;
LABEL_71:
                  uint64_t v48 = a6;
                  unint64_t v70 = v23 & 7;
                  if ((v23 & 7) != 0)
                  {
                    unint64_t v232 = v236 | v62;
                    while (*(unsigned __int8 *)(v57 + v62) == *v63)
                    {
                      ++v63;
                      ++v62;
                      if (!--v70)
                      {
                        unint64_t v62 = v232;
                        break;
                      }
                    }
                  }
                }
                else
                {
                  uint64_t v58 = 0;
                  unint64_t v59 = v23 >> 3;
                  uint64_t v48 = a6;
                  while (1)
                  {
                    uint64_t v60 = *(void *)&v27[v58];
                    uint64_t v61 = *(void *)(v57 + v58);
                    if (v60 != v61) {
                      break;
                    }
                    v58 += 8;
                    if (!--v59)
                    {
                      uint64_t v63 = &v27[v23 & 0xFFFFFFFFFFFFFFF8];
                      unint64_t v62 = v23 & 0xFFFFFFFFFFFFFFF8;
                      goto LABEL_71;
                    }
                  }
                  unint64_t v62 = v58 + (__clz(__rbit64(v61 ^ v60)) >> 3);
                }
                unint64_t v64 = 135 * v62 - 30 * (__clz(v53) ^ 0x1F) + 1920;
                if (v29 < v64) {
                  unint64_t v65 = v53;
                }
                else {
                  unint64_t v65 = v22;
                }
                if (v29 < v64) {
                  uint64_t v66 = v64;
                }
                else {
                  uint64_t v66 = v30;
                }
                if (v29 < v64) {
                  unint64_t v67 = v62;
                }
                else {
                  unint64_t v67 = v45;
                }
                if (v29 < v64)
                {
                  unint64_t v68 = v62;
                }
                else
                {
                  unint64_t v64 = v29;
                  unint64_t v68 = v20;
                }
                if (v62 >= 4)
                {
                  unint64_t v22 = v65;
                  uint64_t v30 = v66;
                  unint64_t v45 = v67;
                  unint64_t v29 = v64;
                  unint64_t v20 = v68;
                }
              }
              else
              {
                uint64_t v48 = a6;
              }
            }
          }
          uint64_t v69 = (unsigned __int16 *)(v47 + 4 * v54);
          uint64_t v54 = v69[1];
          unint64_t v55 = *v69;
          --v49;
        }
        while (v49);
      }
      uint64_t v71 = *(unsigned __int16 *)(v48 + 48);
      *(_WORD *)(v48 + 48) = v71 + 1;
      *(unsigned char *)(v25 + (unsigned __int16)v50) = v28;
      __int16 v72 = -1;
      if (v51 < 0xFFFF) {
        __int16 v72 = v51;
      }
      unint64_t v73 = (__int16 *)(v47 + 4 * v71);
      __int16 *v73 = v72;
      v73[1] = v52;
      *(_DWORD *)(v242 + 4 * v28) = v50;
      *(_WORD *)(v242 + 0x20000 + 2 * v28) = v71;
      if (v30 == 2020)
      {
        uint64_t v74 = *(void *)(v48 + 72);
        unint64_t v75 = *(void *)(v74 + 8);
        unint64_t v76 = *(void *)(v74 + 16);
        unint64_t v16 = v229;
        a5 = v230;
        a3 = v245;
        if (v76 < v75 >> 7) {
          goto LABEL_211;
        }
        int v228 = 0;
        unint64_t v77 = v22;
        uint64_t v78 = ((506832829 * *(_DWORD *)v27) >> 17) & 0x7FFE;
        uint64_t v79 = *(void *)(v230 + 120);
        char v80 = 1;
        unint64_t result = v45;
        unint64_t v81 = 2020;
        do
        {
          char v82 = v80;
          *(void *)(v74 + 8) = ++v75;
          unint64_t v83 = *(unsigned __int8 *)(v79 + v78);
          if (!*(unsigned char *)(v79 + v78) || v23 < v83) {
            goto LABEL_93;
          }
          uint64_t v84 = *(unsigned __int16 *)(*(void *)(v230 + 112) + 2 * v78);
          uint64_t v85 = *(void *)(v230 + 88);
          uint64_t v86 = *(unsigned int *)(v85 + 4 * v83 + 32);
          uint64_t v87 = *(void *)(v85 + 168);
          unint64_t v88 = (unsigned __int8 *)(v87 + v86 + v84 * *(unsigned __int8 *)(v79 + v78));
          if (v83 < 8)
          {
            unint64_t v45 = 0;
LABEL_98:
            unint64_t v95 = v83 & 7;
            if ((v83 & 7) != 0)
            {
              unint64_t v96 = v45 | v95;
              while (v27[v45] == *v88)
              {
                ++v88;
                ++v45;
                if (!--v95)
                {
                  unint64_t v45 = v96;
                  break;
                }
              }
            }
          }
          else
          {
            unint64_t v89 = 0;
            unint64_t v45 = v83 & 0xF8;
            uint64_t v90 = (unsigned __int8 *)(v87
                                    + v84 * (unint64_t)*(unsigned __int8 *)(v79 + v78)
                                    + (*(unsigned char *)(v79 + v78) & 0xF8)
                                    + v86);
            while (1)
            {
              uint64_t v91 = *(void *)&v88[v89];
              uint64_t v92 = *(void *)&v27[v89];
              if (v91 != v92) {
                break;
              }
              v89 += 8;
              if (v45 == v89)
              {
                unint64_t v88 = v90;
                goto LABEL_98;
              }
            }
            unint64_t v45 = v89 + (__clz(__rbit64(v92 ^ v91)) >> 3);
          }
          if (v45
            && v45 + *(unsigned int *)(v230 + 100) > v83
            && (unint64_t v93 = v238
                    + 1
                    + v84
                    + ((((*(void *)(v230 + 104) >> (6 * (v83 - v45))) & 0x3FLL)
                      + 4 * (v83 - v45)) << *(unsigned char *)(v85 + v83)),
                v93 <= v241)
            && (unint64_t v94 = 135 * v45 - 30 * (__clz(v93) ^ 0x1F) + 1920, v94 >= v81))
          {
            int v228 = v83 - v45;
            *(void *)(v74 + 16) = ++v76;
            unint64_t v81 = v94;
          }
          else
          {
LABEL_93:
            unint64_t v93 = v77;
            unint64_t v45 = result;
          }
          char v80 = 0;
          ++v78;
          unint64_t result = v45;
          unint64_t v77 = v93;
        }
        while ((v82 & 1) != 0);
      }
      else
      {
        unint64_t v81 = v30;
        int v228 = 0;
        unint64_t v16 = v229;
        a5 = v230;
        a3 = v245;
        unint64_t v93 = v22;
      }
      if (v81 >= 0x7E5)
      {
        unint64_t v226 = v93;
        unint64_t v240 = v81;
        unsigned int v97 = 0;
        unint64_t result = *(unsigned __int16 *)(a6 + 48);
        while (1)
        {
          unsigned int v234 = v97;
          uint64_t v98 = 0;
          unint64_t v99 = 0;
          unint64_t v100 = 0;
          --v23;
          unint64_t v225 = v45;
          unint64_t v101 = v45 - 1;
          if (v45 - 1 >= v23) {
            unint64_t v101 = v23;
          }
          unint64_t v102 = *(int *)(a5 + 4) >= 5 ? 0 : v101;
          unint64_t v103 = v50 + 1;
          unint64_t v235 = v50;
          unint64_t v104 = v50 + 1 < v16 ? v50 + 1 : v16;
          uint64_t v105 = *(void *)(a6 + 64);
          uint64_t v106 = v105 + 196608;
          uint64_t v107 = v103 & a4;
          unint64_t v108 = (unsigned __int8 *)(a3 + (v103 & a4));
          uint64_t v109 = (506832829 * *(_DWORD *)v108) >> 17;
          unint64_t v243 = *(void *)(a5 + 80);
          unint64_t v110 = 2020;
          unint64_t v111 = 2020;
          do
          {
            unint64_t v112 = a7[v98];
            unint64_t v113 = v103 - v112;
            if ((!v98 || *(unsigned __int8 *)(v106 + (unsigned __int16)(v103 - v112)) == v109)
              && v104 >= v112
              && v113 < v103)
            {
              uint64_t v115 = a3 + (v113 & a4);
              if (v23 < 8)
              {
                unint64_t v116 = 0;
                uint64_t v120 = (unsigned __int8 *)(a3 + (v103 & a4));
LABEL_136:
                unint64_t v123 = v23 & 7;
                if ((v23 & 7) != 0)
                {
                  do
                  {
                    if (*(unsigned __int8 *)(v115 + v116) != *v120) {
                      break;
                    }
                    ++v120;
                    ++v116;
                    --v123;
                  }
                  while (v123);
                }
              }
              else
              {
                unint64_t v116 = 0;
                unint64_t v117 = v23 >> 3;
                while (1)
                {
                  uint64_t v118 = *(void *)&v108[v116];
                  uint64_t v119 = *(void *)(v115 + v116);
                  if (v118 != v119) {
                    break;
                  }
                  v116 += 8;
                  if (!--v117)
                  {
                    uint64_t v120 = &v108[v116];
                    goto LABEL_136;
                  }
                }
                v116 += __clz(__rbit64(v119 ^ v118)) >> 3;
              }
              if (v116 >= 2)
              {
                unint64_t v121 = 135 * v116 + 1935;
                if (v110 < v121)
                {
                  unint64_t v122 = v121 - (((0x1CA10u >> (v98 & 0xE)) & 0xE) + 39);
                  if (!v98) {
                    unint64_t v122 = 135 * v116 + 1935;
                  }
                  if (v110 < v122)
                  {
                    unint64_t v100 = v116;
                    unint64_t v99 = a7[v98];
                    unint64_t v111 = v122;
                    unint64_t v110 = v122;
                    unint64_t v102 = v116;
                  }
                }
              }
            }
            ++v98;
          }
          while (v98 != 4);
          if (v103 + v231 >= v16) {
            unint64_t v124 = v16;
          }
          else {
            unint64_t v124 = v103 + v231;
          }
          unint64_t v233 = v124;
          uint64_t v125 = v105 + 0x40000;
          uint64_t v126 = a6;
          uint64_t v127 = *(void *)(a6 + 56);
          uint64_t v128 = *(unsigned int *)(v105 + 4 * v109);
          unint64_t v129 = v103 - v128;
          uint64_t v130 = *(unsigned __int16 *)(v105 + 0x20000 + 2 * v109);
          __int16 v237 = *(_WORD *)(v105 + 0x20000 + 2 * v109);
          if (v127)
          {
            unint64_t v131 = 0;
            uint64_t v132 = v103 - v128;
            do
            {
              v131 += v132;
              if (v131 > v104) {
                break;
              }
              if (v102 + v107 <= a4)
              {
                unint64_t v133 = (v103 - v131) & a4;
                if (v133 + v102 <= a4
                  && *(unsigned __int8 *)(v245 + v102 + v107) == *(unsigned __int8 *)(v245 + v133 + v102))
                {
                  uint64_t v134 = v245 + v133;
                  if (v23 < 8)
                  {
                    unint64_t v135 = 0;
                    uint64_t v140 = v108;
                    unint64_t v137 = v23 & 7;
LABEL_174:
                    while (v137)
                    {
                      if (*(unsigned __int8 *)(v134 + v135) != *v140) {
                        break;
                      }
                      ++v140;
                      ++v135;
                      --v137;
                    }
                  }
                  else
                  {
                    unint64_t v135 = 0;
                    unint64_t v136 = v23 >> 3;
                    unint64_t v137 = v23 & 7;
                    while (1)
                    {
                      uint64_t v138 = *(void *)&v108[v135];
                      uint64_t v139 = *(void *)(v134 + v135);
                      if (v138 != v139) {
                        break;
                      }
                      v135 += 8;
                      if (!--v136)
                      {
                        uint64_t v140 = &v108[v135];
                        goto LABEL_174;
                      }
                    }
                    v135 += __clz(__rbit64(v139 ^ v138)) >> 3;
                  }
                  unint64_t v141 = 135 * v135 - 30 * (__clz(v131) ^ 0x1F) + 1920;
                  if (v110 < v141) {
                    unint64_t v142 = v135;
                  }
                  else {
                    unint64_t v142 = v100;
                  }
                  if (v110 < v141) {
                    unint64_t v143 = v131;
                  }
                  else {
                    unint64_t v143 = v99;
                  }
                  if (v110 < v141) {
                    unint64_t v144 = v141;
                  }
                  else {
                    unint64_t v144 = v111;
                  }
                  if (v110 < v141)
                  {
                    unint64_t v145 = v135;
                  }
                  else
                  {
                    unint64_t v141 = v110;
                    unint64_t v145 = v102;
                  }
                  if (v135 >= 4)
                  {
                    unint64_t v100 = v142;
                    unint64_t v99 = v143;
                    unint64_t v111 = v144;
                    unint64_t v110 = v141;
                    unint64_t v102 = v145;
                  }
                  uint64_t v126 = a6;
                }
              }
              unint64_t v146 = (unsigned __int16 *)(v125 + 4 * v130);
              uint64_t v130 = v146[1];
              uint64_t v132 = *v146;
              --v127;
            }
            while (v127);
          }
          unint64_t v147 = (result + 1);
          *(_WORD *)(v126 + 48) = result + 1;
          *(unsigned char *)(v106 + (unsigned __int16)v103) = v109;
          __int16 v148 = -1;
          if (v129 < 0xFFFF) {
            __int16 v148 = v129;
          }
          int v149 = (__int16 *)(v125 + 4 * (unsigned __int16)result);
          *int v149 = v148;
          v149[1] = v237;
          *(_DWORD *)(v105 + 4 * v109) = v103;
          *(_WORD *)(v105 + 0x20000 + 2 * v109) = result;
          if (v111 == 2020)
          {
            uint64_t v150 = *(void *)(v126 + 72);
            unint64_t v152 = *(void *)(v150 + 8);
            unint64_t v151 = *(void *)(v150 + 16);
            a5 = v230;
            int v153 = 0;
            if (v151 >= v152 >> 7)
            {
              uint64_t v154 = ((506832829 * *(_DWORD *)v108) >> 17) & 0x7FFE;
              unint64_t result = *(void *)(v230 + 120);
              char v155 = 1;
              unint64_t v111 = 2020;
              unint64_t v156 = v99;
              unint64_t v157 = v100;
              do
              {
                char v158 = v155;
                *(void *)(v150 + 8) = ++v152;
                unint64_t v159 = *(unsigned __int8 *)(result + v154);
                if (!*(unsigned char *)(result + v154) || v23 < v159) {
                  goto LABEL_201;
                }
                uint64_t v160 = *(unsigned __int16 *)(*(void *)(v230 + 112) + 2 * v154);
                uint64_t v161 = *(void *)(v230 + 88);
                uint64_t v162 = *(unsigned int *)(v161 + 4 * v159 + 32);
                uint64_t v163 = *(void *)(v161 + 168);
                uint64_t v164 = (unsigned __int8 *)(v163 + v162 + v160 * *(unsigned __int8 *)(result + v154));
                if (v159 < 8)
                {
                  unint64_t v100 = 0;
LABEL_206:
                  unint64_t v170 = v159 & 7;
                  if ((v159 & 7) != 0)
                  {
                    unint64_t v171 = v100 | v170;
                    while (v108[v100] == *v164)
                    {
                      ++v164;
                      ++v100;
                      if (!--v170)
                      {
                        unint64_t v100 = v171;
                        break;
                      }
                    }
                  }
                }
                else
                {
                  unint64_t v165 = 0;
                  unint64_t v100 = v159 & 0xF8;
                  unint64_t v166 = (unsigned __int8 *)(v163
                                           + v160 * (unint64_t)*(unsigned __int8 *)(result + v154)
                                           + (*(unsigned char *)(result + v154) & 0xF8)
                                           + v162);
                  while (1)
                  {
                    uint64_t v167 = *(void *)&v164[v165];
                    uint64_t v168 = *(void *)&v108[v165];
                    if (v167 != v168) {
                      break;
                    }
                    v165 += 8;
                    if (v100 == v165)
                    {
                      uint64_t v164 = v166;
                      goto LABEL_206;
                    }
                  }
                  unint64_t v100 = v165 + (__clz(__rbit64(v168 ^ v167)) >> 3);
                }
                if (v100
                  && v100 + *(unsigned int *)(v230 + 100) > v159
                  && (unint64_t v99 = v233
                          + 1
                          + v160
                          + ((((*(void *)(v230 + 104) >> (6 * (v159 - v100))) & 0x3FLL)
                            + 4 * (v159 - v100)) << *(unsigned char *)(v161 + v159)),
                      v99 <= v243)
                  && (unint64_t v169 = 135 * v100 - 30 * (__clz(v99) ^ 0x1F) + 1920, v169 >= v111))
                {
                  int v153 = v159 - v100;
                  *(void *)(v150 + 16) = ++v151;
                  unint64_t v111 = v169;
                }
                else
                {
LABEL_201:
                  unint64_t v100 = v157;
                  unint64_t v99 = v156;
                }
                char v155 = 0;
                ++v154;
                unint64_t v156 = v99;
                unint64_t v157 = v100;
              }
              while ((v158 & 1) != 0);
            }
            else
            {
              unint64_t v111 = 2020;
            }
          }
          else
          {
            int v153 = 0;
            a5 = v230;
          }
          if (v111 < v240 + 175) {
            break;
          }
          a3 = v245;
          ++v244;
          unint64_t v16 = v229;
          if (v234 <= 2)
          {
            unsigned int v97 = v234 + 1;
            unint64_t result = v147;
            unint64_t v226 = v99;
            unint64_t v240 = v111;
            int v228 = v153;
            unint64_t v45 = v100;
            unint64_t v50 = v103;
            if (v235 + 5 < v227) {
              continue;
            }
          }
          goto LABEL_225;
        }
        unint64_t v103 = v235;
        unint64_t v180 = v235 + v231;
        unint64_t v16 = v229;
        if (v235 + v231 >= v229) {
          unint64_t v180 = v229;
        }
        unint64_t v233 = v180;
        unint64_t v100 = v225;
        unint64_t v99 = v226;
        int v153 = v228;
        a3 = v245;
LABEL_225:
        if (v99 > v233)
        {
LABEL_226:
          unint64_t v181 = v99 + 15;
          goto LABEL_227;
        }
        uint64_t v182 = *a7;
        if (v99 == v182)
        {
          unint64_t v181 = 0;
LABEL_232:
          *(_DWORD *)uint64_t v224 = v244;
          *(_DWORD *)(v224 + 4) = v100 | (v153 << 25);
          uint64_t v183 = *(unsigned int *)(a5 + 68);
          uint64_t v184 = v183 + 16;
          if (v183 + 16 <= v181)
          {
            uint64_t v186 = *(unsigned int *)(a5 + 64);
            unint64_t v187 = v181 - v183 + (4 << v186) - 16;
            uint64_t v188 = (__clz(v187) ^ 0x1F) - 1;
            uint64_t v189 = ((v187 >> v188) & 1 | 2) << v188;
            unint64_t v181 = ((v187 & ~(-1 << v186))
                  + v184
                  + ((((v187 >> v188) & 1 | (2 * (v188 - v186))) + 65534) << v186)) | ((v188 - v186) << 10);
            unint64_t v185 = (v187 - v189) >> v186;
          }
          else
          {
            LODWORD(v185) = 0;
          }
          *(_WORD *)(v224 + 14) = v181;
          *(_DWORD *)(v224 + 8) = v185;
          if (v244 > 5)
          {
            if (v244 > 0x81)
            {
              if (v244 > 0x841)
              {
                if (v244 >> 1 >= 0xC21)
                {
                  if (v244 < 0x5842) {
                    LOWORD(v190) = 22;
                  }
                  else {
                    LOWORD(v190) = 23;
                  }
                }
                else
                {
                  LOWORD(v190) = 21;
                }
              }
              else
              {
                unsigned int v190 = (__clz(v244 - 66) ^ 0x1F) + 10;
              }
            }
            else
            {
              unsigned int v191 = (__clz(v244 - 2) ^ 0x1F) - 1;
              unsigned int v190 = ((v244 - 2) >> v191) + 2 * v191 + 2;
            }
          }
          else
          {
            LOWORD(v190) = v244;
          }
          uint64_t v203 = v153 + (int)v100;
          if (v203 > 9)
          {
            if (v203 > 0x85)
            {
              if (v203 > 0x845) {
                LOWORD(v204) = 23;
              }
              else {
                unsigned int v204 = (__clz(v203 - 70) ^ 0x1F) + 12;
              }
            }
            else
            {
              unint64_t v205 = v203 - 6;
              unsigned int v206 = (__clz(v205) ^ 0x1F) - 1;
              unsigned int v204 = (v205 >> v206) + 2 * v206 + 4;
            }
          }
          else
          {
            LOWORD(v204) = v153 + v100 - 2;
          }
          int v207 = v204 & 7 | (8 * (v190 & 7));
          if ((v181 & 0x3FF) != 0 || (unsigned __int16)v190 > 7u || (unsigned __int16)v204 > 0xFu)
          {
            int v209 = 3 * ((unsigned __int16)v190 >> 3) + ((unsigned __int16)(v204 & 0xFFF8) >> 3);
            unsigned int v208 = ((((0x520D40u >> (2 * v209)) & 0xC0) + (v209 << 6)) | v207) + 64;
          }
          else
          {
            LOWORD(v208) = v207 | 0x40;
            if ((v204 & 0xFFF8) == 0) {
              LOWORD(v208) = v204 & 7 | (8 * (v190 & 7));
            }
          }
          *(_WORD *)(v224 + 12) = v208;
          *a11 += v244;
          unint64_t v210 = v103 + 2;
          unint64_t v172 = v103 + v100;
          if (v103 + v100 >= v223) {
            unint64_t v211 = v223;
          }
          else {
            unint64_t v211 = v103 + v100;
          }
          if (v99 < v100 >> 2)
          {
            unint64_t v212 = v172 - 4 * v99;
            if (v210 > v212) {
              unint64_t v212 = v103 + 2;
            }
            if (v211 >= v212) {
              unint64_t v210 = v212;
            }
            else {
              unint64_t v210 = v211;
            }
          }
          unint64_t v17 = v222 + 2 * v100 + v103;
          uint64_t v18 = v224 + 16;
          if (v210 >= v211)
          {
            unint64_t v12 = 0;
            uint64_t v11 = a9;
            goto LABEL_293;
          }
          uint64_t v213 = *(void *)(a6 + 64);
          uint64_t v214 = v213 + 0x20000;
          unsigned __int16 v176 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v215 = (506832829 * *(_DWORD *)(a3 + (v210 & a4))) >> 17;
            *(unsigned char *)(v213 + 196608 + (unsigned __int16)v210) = v215;
            unint64_t v216 = (_WORD *)(v213 + 0x40000 + 4 * v176);
            unint64_t result = *(unsigned __int16 *)(v214 + 2 * v215);
            *(_WORD *)(v214 + 2 * v215) = v176++;
            unint64_t v217 = v210 - *(unsigned int *)(v213 + 4 * v215);
            if (v217 >= 0xFFFF) {
              LOWORD(v217) = -1;
            }
            *unint64_t v216 = v217;
            v216[1] = result;
            *(_DWORD *)(v213 + 4 * v215) = v210++;
          }
          while (v211 != v210);
          unint64_t v12 = 0;
          uint64_t v11 = a9;
          unint64_t v13 = v227;
          goto LABEL_291;
        }
        uint64_t v198 = a7[1];
        if (v99 == v198)
        {
          unint64_t v181 = 1;
        }
        else
        {
          unint64_t v199 = v99 + 3 - v182;
          if (v199 > 6)
          {
            unint64_t v202 = v99 + 3 - v198;
            if (v202 > 6)
            {
              if (v99 == a7[2])
              {
                unint64_t v181 = 2;
              }
              else
              {
                if (v99 != a7[3]) {
                  goto LABEL_226;
                }
                unint64_t v181 = 3;
              }
              goto LABEL_227;
            }
            char v200 = 4 * v202;
            unsigned int v201 = 266017486;
          }
          else
          {
            char v200 = 4 * v199;
            unsigned int v201 = 158663784;
          }
          unint64_t v181 = (v201 >> v200) & 0xF;
        }
LABEL_227:
        if (v99 <= v233 && v181)
        {
          a7[3] = a7[2];
          *(void *)(a7 + 1) = *(void *)a7;
          *a7 = v99;
        }
        goto LABEL_232;
      }
LABEL_211:
      unint64_t v12 = v244 + 1;
      unint64_t v172 = v50 + 1;
      unint64_t v17 = v239;
      if (v50 + 1 <= v239)
      {
        uint64_t v11 = a9;
        uint64_t v18 = v224;
LABEL_293:
        unint64_t v13 = v227;
        goto LABEL_294;
      }
      unint64_t v13 = v227;
      uint64_t v18 = v224;
      if (v172 <= v239 + v221)
      {
        unint64_t v192 = v220;
        if (v50 + 9 < v220) {
          unint64_t v192 = v50 + 9;
        }
        if (v172 < v192)
        {
          uint64_t v193 = *(void *)(a6 + 64);
          uint64_t v194 = v193 + 0x20000;
          unsigned __int16 v176 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v195 = (506832829 * *(_DWORD *)(a3 + (v172 & a4))) >> 17;
            uint64_t v196 = (_WORD *)(v193 + 0x40000 + 4 * v176);
            __int16 v197 = *(_WORD *)(v194 + 2 * v195);
            *(_WORD *)(v194 + 2 * v195) = v176++;
            *(unsigned char *)(v193 + 196608 + (unsigned __int16)v172) = v195;
            unint64_t result = v172 - *(unsigned int *)(v193 + 4 * v195);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            *uint64_t v196 = result;
            v196[1] = v197;
            *(_DWORD *)(v193 + 4 * v195) = v172;
            v12 += 2;
            v172 += 2;
          }
          while (v172 < v192);
LABEL_246:
          uint64_t v11 = a9;
LABEL_291:
          *(_WORD *)(a6 + 48) = v176;
          goto LABEL_294;
        }
      }
      else
      {
        unint64_t v173 = v219;
        if (v50 + 17 < v219) {
          unint64_t v173 = v50 + 17;
        }
        if (v172 < v173)
        {
          uint64_t v174 = *(void *)(a6 + 64);
          uint64_t v175 = v174 + 0x20000;
          unsigned __int16 v176 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v177 = (506832829 * *(_DWORD *)(a3 + (v172 & a4))) >> 17;
            int v178 = (_WORD *)(v174 + 0x40000 + 4 * v176);
            __int16 v179 = *(_WORD *)(v175 + 2 * v177);
            *(_WORD *)(v175 + 2 * v177) = v176++;
            *(unsigned char *)(v174 + 196608 + (unsigned __int16)v172) = v177;
            unint64_t result = v172 - *(unsigned int *)(v174 + 4 * v177);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            *int v178 = result;
            v178[1] = v179;
            *(_DWORD *)(v174 + 4 * v177) = v172;
            v12 += 4;
            v172 += 4;
          }
          while (v172 < v173);
          goto LABEL_246;
        }
      }
      uint64_t v11 = a9;
LABEL_294:
      a2 = v172;
      if (v172 + 4 >= v13) {
        goto LABEL_301;
      }
    }
  }
  uint64_t v18 = a9;
  unint64_t v172 = a2;
LABEL_301:
  *a8 = v12 + v13 - v172;
  *a10 += (v18 - v11) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH41(unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  uint64_t v11 = a9;
  uint64_t v234 = *(void *)(a5 + 16);
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 3;
  unint64_t v223 = v14;
  if (result <= 3) {
    uint64_t v14 = a2;
  }
  unint64_t v226 = v14;
  int v15 = *(_DWORD *)(a5 + 8);
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v16 = 512;
  }
  else {
    uint64_t v16 = 64;
  }
  int32x4_t v17 = (int32x4_t)vld1q_dup_f32((const float *)a7);
  *((int32x4_t *)a7 + 1) = vaddq_s32(v17, (int32x4_t)xmmword_20DB0A5B0);
  *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v17.i8, (int32x2_t)0x3FFFFFFFDLL);
  if (a2 + 4 < v13)
  {
    unint64_t v18 = (1 << v15) - 16;
    unint64_t v19 = v16 + a2;
    uint64_t v224 = 4 * v16;
    unint64_t v222 = v13 - 4;
    uint64_t v20 = a9;
    unint64_t v232 = v18;
    uint64_t v233 = a5;
    uint64_t v248 = a3;
    unint64_t v230 = a2 + result;
    uint64_t v225 = v16;
    while (1)
    {
      uint64_t v227 = v20;
      uint64_t v21 = 0;
      unint64_t v22 = 0;
      unint64_t v23 = 0;
      unint64_t v24 = 0;
      unint64_t v25 = v13 - a2;
      if (a2 >= v18) {
        unint64_t v26 = v18;
      }
      else {
        unint64_t v26 = a2;
      }
      unint64_t v242 = v19;
      unint64_t v244 = *(void *)(a5 + 80);
      uint64_t v245 = *(void *)(a6 + 64);
      unint64_t v247 = v12;
      uint64_t v27 = v245 + 196608;
      unint64_t v28 = a2 & a4;
      unint64_t v29 = (unsigned __int8 *)(a3 + (a2 & a4));
      uint64_t v30 = (506832829 * *(_DWORD *)v29) >> 17;
      unint64_t result = v25 >> 3;
      unint64_t v239 = v25 & 7;
      unint64_t v31 = 2020;
      uint64_t v32 = 2020;
      do
      {
        unint64_t v33 = a7[v21];
        unint64_t v34 = a2 - v33;
        if ((!v21 || *(unsigned __int8 *)(v27 + (unsigned __int16)(a2 - v33)) == v30)
          && v26 >= v33
          && v34 < a2)
        {
          uint64_t v36 = a3 + (v34 & a4);
          if (v25 < 8)
          {
            unint64_t v41 = 0;
            unint64_t v42 = (unsigned __int8 *)(a3 + (a2 & a4));
LABEL_33:
            if ((v25 & 7) != 0)
            {
              unint64_t v45 = v239 | v41;
              unint64_t v46 = v25 & 7;
              while (*(unsigned __int8 *)(v36 + v41) == *v42)
              {
                ++v42;
                ++v41;
                if (!--v46)
                {
                  unint64_t v41 = v45;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v37 = 0;
            unint64_t v38 = v25 >> 3;
            while (1)
            {
              uint64_t v39 = *(void *)&v29[v37];
              uint64_t v40 = *(void *)(v36 + v37);
              if (v39 != v40) {
                break;
              }
              v37 += 8;
              if (!--v38)
              {
                unint64_t v42 = &v29[v25 & 0xFFFFFFFFFFFFFFF8];
                unint64_t v41 = v25 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_33;
              }
            }
            unint64_t v41 = v37 + (__clz(__rbit64(v40 ^ v39)) >> 3);
          }
          if (v41 >= 2)
          {
            unint64_t v43 = 135 * v41 + 1935;
            if (v31 < v43)
            {
              unint64_t v44 = v43 - (((0x1CA10u >> (v21 & 0xE)) & 0xE) + 39);
              if (!v21) {
                unint64_t v44 = 135 * v41 + 1935;
              }
              if (v31 < v44)
              {
                unint64_t v24 = a7[v21];
                uint64_t v32 = v44;
                unint64_t v23 = v41;
                unint64_t v31 = v44;
                unint64_t v22 = v41;
              }
            }
          }
        }
        ++v21;
      }
      while (v21 != 10);
      unint64_t v47 = v23;
      if (a2 + v234 >= v18) {
        unint64_t v48 = v18;
      }
      else {
        unint64_t v48 = a2 + v234;
      }
      unint64_t v241 = v48;
      uint64_t v49 = v245 + 0x40000;
      uint64_t v50 = a6;
      uint64_t v51 = *(void *)(a6 + 56);
      unint64_t v52 = a2;
      unint64_t v53 = a2 - *(unsigned int *)(v245 + 4 * v30);
      __int16 v54 = *(_WORD *)(v245 + 0x20000 + 2 * v30);
      if (v51)
      {
        unint64_t v55 = 0;
        uint64_t v56 = *(unsigned __int16 *)(v245 + 0x20000 + 2 * v30);
        unint64_t v57 = v53;
        do
        {
          v55 += v57;
          if (v55 > v26) {
            break;
          }
          if (v22 + v28 <= a4)
          {
            unint64_t v58 = (v52 - v55) & a4;
            if (v58 + v22 <= a4)
            {
              if (*(unsigned __int8 *)(v248 + v22 + v28) == *(unsigned __int8 *)(v248 + v58 + v22))
              {
                uint64_t v59 = v248 + v58;
                if (v25 < 8)
                {
                  unint64_t v64 = 0;
                  unint64_t v65 = v29;
LABEL_72:
                  uint64_t v50 = a6;
                  unint64_t v72 = v25 & 7;
                  if ((v25 & 7) != 0)
                  {
                    unint64_t v235 = v239 | v64;
                    while (*(unsigned __int8 *)(v59 + v64) == *v65)
                    {
                      ++v65;
                      ++v64;
                      if (!--v72)
                      {
                        unint64_t v64 = v235;
                        break;
                      }
                    }
                  }
                }
                else
                {
                  uint64_t v60 = 0;
                  unint64_t v61 = v25 >> 3;
                  uint64_t v50 = a6;
                  while (1)
                  {
                    uint64_t v62 = *(void *)&v29[v60];
                    uint64_t v63 = *(void *)(v59 + v60);
                    if (v62 != v63) {
                      break;
                    }
                    v60 += 8;
                    if (!--v61)
                    {
                      unint64_t v65 = &v29[v25 & 0xFFFFFFFFFFFFFFF8];
                      unint64_t v64 = v25 & 0xFFFFFFFFFFFFFFF8;
                      goto LABEL_72;
                    }
                  }
                  unint64_t v64 = v60 + (__clz(__rbit64(v63 ^ v62)) >> 3);
                }
                unint64_t v66 = 135 * v64 - 30 * (__clz(v55) ^ 0x1F) + 1920;
                if (v31 < v66) {
                  unint64_t v67 = v55;
                }
                else {
                  unint64_t v67 = v24;
                }
                if (v31 < v66) {
                  uint64_t v68 = v66;
                }
                else {
                  uint64_t v68 = v32;
                }
                if (v31 < v66) {
                  unint64_t v69 = v64;
                }
                else {
                  unint64_t v69 = v47;
                }
                if (v31 < v66)
                {
                  unint64_t v70 = v64;
                }
                else
                {
                  unint64_t v66 = v31;
                  unint64_t v70 = v22;
                }
                if (v64 >= 4)
                {
                  unint64_t v24 = v67;
                  uint64_t v32 = v68;
                  unint64_t v47 = v69;
                  unint64_t v31 = v66;
                  unint64_t v22 = v70;
                }
              }
              else
              {
                uint64_t v50 = a6;
              }
            }
          }
          uint64_t v71 = (unsigned __int16 *)(v49 + 4 * v56);
          uint64_t v56 = v71[1];
          unint64_t v57 = *v71;
          --v51;
        }
        while (v51);
      }
      uint64_t v73 = *(unsigned __int16 *)(v50 + 48);
      *(_WORD *)(v50 + 48) = v73 + 1;
      *(unsigned char *)(v27 + (unsigned __int16)v52) = v30;
      __int16 v74 = -1;
      if (v53 < 0xFFFF) {
        __int16 v74 = v53;
      }
      unint64_t v75 = (__int16 *)(v49 + 4 * v73);
      *unint64_t v75 = v74;
      v75[1] = v54;
      *(_DWORD *)(v245 + 4 * v30) = v52;
      *(_WORD *)(v245 + 0x20000 + 2 * v30) = v73;
      if (v32 == 2020)
      {
        uint64_t v76 = *(void *)(v50 + 72);
        unint64_t v77 = *(void *)(v76 + 8);
        unint64_t v78 = *(void *)(v76 + 16);
        unint64_t v18 = v232;
        a5 = v233;
        a3 = v248;
        if (v78 < v77 >> 7) {
          goto LABEL_212;
        }
        int v231 = 0;
        unint64_t v79 = v24;
        uint64_t v80 = ((506832829 * *(_DWORD *)v29) >> 17) & 0x7FFE;
        uint64_t v81 = *(void *)(v233 + 120);
        char v82 = 1;
        unint64_t result = v47;
        unint64_t v83 = 2020;
        do
        {
          char v84 = v82;
          *(void *)(v76 + 8) = ++v77;
          unint64_t v85 = *(unsigned __int8 *)(v81 + v80);
          if (!*(unsigned char *)(v81 + v80) || v25 < v85) {
            goto LABEL_94;
          }
          uint64_t v86 = *(unsigned __int16 *)(*(void *)(v233 + 112) + 2 * v80);
          uint64_t v87 = *(void *)(v233 + 88);
          uint64_t v88 = *(unsigned int *)(v87 + 4 * v85 + 32);
          uint64_t v89 = *(void *)(v87 + 168);
          uint64_t v90 = (unsigned __int8 *)(v89 + v88 + v86 * *(unsigned __int8 *)(v81 + v80));
          if (v85 < 8)
          {
            unint64_t v47 = 0;
LABEL_99:
            unint64_t v97 = v85 & 7;
            if ((v85 & 7) != 0)
            {
              unint64_t v98 = v47 | v97;
              while (v29[v47] == *v90)
              {
                ++v90;
                ++v47;
                if (!--v97)
                {
                  unint64_t v47 = v98;
                  break;
                }
              }
            }
          }
          else
          {
            unint64_t v91 = 0;
            unint64_t v47 = v85 & 0xF8;
            uint64_t v92 = (unsigned __int8 *)(v89
                                    + v86 * (unint64_t)*(unsigned __int8 *)(v81 + v80)
                                    + (*(unsigned char *)(v81 + v80) & 0xF8)
                                    + v88);
            while (1)
            {
              uint64_t v93 = *(void *)&v90[v91];
              uint64_t v94 = *(void *)&v29[v91];
              if (v93 != v94) {
                break;
              }
              v91 += 8;
              if (v47 == v91)
              {
                uint64_t v90 = v92;
                goto LABEL_99;
              }
            }
            unint64_t v47 = v91 + (__clz(__rbit64(v94 ^ v93)) >> 3);
          }
          if (v47
            && v47 + *(unsigned int *)(v233 + 100) > v85
            && (unint64_t v95 = v241
                    + 1
                    + v86
                    + ((((*(void *)(v233 + 104) >> (6 * (v85 - v47))) & 0x3FLL)
                      + 4 * (v85 - v47)) << *(unsigned char *)(v87 + v85)),
                v95 <= v244)
            && (unint64_t v96 = 135 * v47 - 30 * (__clz(v95) ^ 0x1F) + 1920, v96 >= v83))
          {
            int v231 = v85 - v47;
            *(void *)(v76 + 16) = ++v78;
            unint64_t v83 = v96;
          }
          else
          {
LABEL_94:
            unint64_t v95 = v79;
            unint64_t v47 = result;
          }
          char v82 = 0;
          ++v80;
          unint64_t result = v47;
          unint64_t v79 = v95;
        }
        while ((v84 & 1) != 0);
      }
      else
      {
        unint64_t v83 = v32;
        int v231 = 0;
        unint64_t v18 = v232;
        a5 = v233;
        a3 = v248;
        unint64_t v95 = v24;
      }
      if (v83 >= 0x7E5)
      {
        unint64_t v229 = v95;
        unint64_t v243 = v83;
        unsigned int v99 = 0;
        int v100 = *(unsigned __int16 *)(a6 + 48);
        while (1)
        {
          unsigned int v237 = v99;
          uint64_t v101 = 0;
          unint64_t v102 = 0;
          unint64_t v103 = 0;
          --v25;
          unint64_t v228 = v47;
          unint64_t v104 = v47 - 1;
          if (v47 - 1 >= v25) {
            unint64_t v104 = v25;
          }
          unint64_t v105 = *(int *)(a5 + 4) >= 5 ? 0 : v104;
          unint64_t v106 = v52 + 1;
          unint64_t v238 = v52;
          unint64_t v107 = v52 + 1 < v18 ? v52 + 1 : v18;
          uint64_t v108 = *(void *)(a6 + 64);
          unint64_t result = v108 + 196608;
          uint64_t v109 = v106 & a4;
          unint64_t v110 = (unsigned __int8 *)(a3 + (v106 & a4));
          uint64_t v111 = (506832829 * *(_DWORD *)v110) >> 17;
          unint64_t v246 = *(void *)(a5 + 80);
          unint64_t v112 = 2020;
          unint64_t v113 = 2020;
          do
          {
            unint64_t v114 = a7[v101];
            unint64_t v115 = v106 - v114;
            if ((!v101 || *(unsigned __int8 *)(result + (unsigned __int16)(v106 - v114)) == v111)
              && v107 >= v114
              && v115 < v106)
            {
              uint64_t v117 = a3 + (v115 & a4);
              if (v25 < 8)
              {
                unint64_t v118 = 0;
                unint64_t v122 = (unsigned __int8 *)(a3 + (v106 & a4));
LABEL_137:
                unint64_t v125 = v25 & 7;
                if ((v25 & 7) != 0)
                {
                  do
                  {
                    if (*(unsigned __int8 *)(v117 + v118) != *v122) {
                      break;
                    }
                    ++v122;
                    ++v118;
                    --v125;
                  }
                  while (v125);
                }
              }
              else
              {
                unint64_t v118 = 0;
                unint64_t v119 = v25 >> 3;
                while (1)
                {
                  uint64_t v120 = *(void *)&v110[v118];
                  uint64_t v121 = *(void *)(v117 + v118);
                  if (v120 != v121) {
                    break;
                  }
                  v118 += 8;
                  if (!--v119)
                  {
                    unint64_t v122 = &v110[v118];
                    goto LABEL_137;
                  }
                }
                v118 += __clz(__rbit64(v121 ^ v120)) >> 3;
              }
              if (v118 >= 2)
              {
                unint64_t v123 = 135 * v118 + 1935;
                if (v112 < v123)
                {
                  unint64_t v124 = v123 - (((0x1CA10u >> (v101 & 0xE)) & 0xE) + 39);
                  if (!v101) {
                    unint64_t v124 = 135 * v118 + 1935;
                  }
                  if (v112 < v124)
                  {
                    unint64_t v103 = v118;
                    unint64_t v102 = a7[v101];
                    unint64_t v113 = v124;
                    unint64_t v112 = v124;
                    unint64_t v105 = v118;
                  }
                }
              }
            }
            ++v101;
          }
          while (v101 != 10);
          if (v106 + v234 >= v18) {
            unint64_t v126 = v18;
          }
          else {
            unint64_t v126 = v106 + v234;
          }
          unint64_t v236 = v126;
          uint64_t v127 = v108 + 0x40000;
          uint64_t v128 = a6;
          uint64_t v129 = *(void *)(a6 + 56);
          uint64_t v130 = *(unsigned int *)(v108 + 4 * v111);
          unint64_t v131 = v106 - v130;
          uint64_t v132 = *(unsigned __int16 *)(v108 + 0x20000 + 2 * v111);
          __int16 v240 = *(_WORD *)(v108 + 0x20000 + 2 * v111);
          if (v129)
          {
            unint64_t v133 = 0;
            uint64_t v134 = v106 - v130;
            do
            {
              v133 += v134;
              if (v133 > v107) {
                break;
              }
              if (v105 + v109 <= a4)
              {
                unint64_t v135 = (v106 - v133) & a4;
                if (v135 + v105 <= a4
                  && *(unsigned __int8 *)(v248 + v105 + v109) == *(unsigned __int8 *)(v248 + v135 + v105))
                {
                  uint64_t v136 = v248 + v135;
                  if (v25 < 8)
                  {
                    unint64_t v137 = 0;
                    unint64_t v142 = v110;
                    unint64_t v139 = v25 & 7;
LABEL_175:
                    while (v139)
                    {
                      if (*(unsigned __int8 *)(v136 + v137) != *v142) {
                        break;
                      }
                      ++v142;
                      ++v137;
                      --v139;
                    }
                  }
                  else
                  {
                    unint64_t v137 = 0;
                    unint64_t v138 = v25 >> 3;
                    unint64_t v139 = v25 & 7;
                    while (1)
                    {
                      uint64_t v140 = *(void *)&v110[v137];
                      uint64_t v141 = *(void *)(v136 + v137);
                      if (v140 != v141) {
                        break;
                      }
                      v137 += 8;
                      if (!--v138)
                      {
                        unint64_t v142 = &v110[v137];
                        goto LABEL_175;
                      }
                    }
                    v137 += __clz(__rbit64(v141 ^ v140)) >> 3;
                  }
                  unint64_t v143 = 135 * v137 - 30 * (__clz(v133) ^ 0x1F) + 1920;
                  if (v112 < v143) {
                    unint64_t v144 = v137;
                  }
                  else {
                    unint64_t v144 = v103;
                  }
                  if (v112 < v143) {
                    unint64_t v145 = v133;
                  }
                  else {
                    unint64_t v145 = v102;
                  }
                  if (v112 < v143) {
                    unint64_t v146 = v143;
                  }
                  else {
                    unint64_t v146 = v113;
                  }
                  if (v112 < v143)
                  {
                    unint64_t v147 = v137;
                  }
                  else
                  {
                    unint64_t v143 = v112;
                    unint64_t v147 = v105;
                  }
                  if (v137 >= 4)
                  {
                    unint64_t v103 = v144;
                    unint64_t v102 = v145;
                    unint64_t v113 = v146;
                    unint64_t v112 = v143;
                    unint64_t v105 = v147;
                  }
                  uint64_t v128 = a6;
                }
              }
              __int16 v148 = (unsigned __int16 *)(v127 + 4 * v132);
              uint64_t v132 = v148[1];
              uint64_t v134 = *v148;
              --v129;
            }
            while (v129);
          }
          int v149 = v100 + 1;
          *(_WORD *)(v128 + 48) = v100 + 1;
          *(unsigned char *)(result + (unsigned __int16)v106) = v111;
          __int16 v150 = -1;
          if (v131 < 0xFFFF) {
            __int16 v150 = v131;
          }
          unint64_t v151 = (__int16 *)(v127 + 4 * (unsigned __int16)v100);
          *unint64_t v151 = v150;
          v151[1] = v240;
          *(_DWORD *)(v108 + 4 * v111) = v106;
          *(_WORD *)(v108 + 0x20000 + 2 * v111) = v100;
          if (v113 == 2020)
          {
            uint64_t v152 = *(void *)(v128 + 72);
            unint64_t v154 = *(void *)(v152 + 8);
            unint64_t v153 = *(void *)(v152 + 16);
            a5 = v233;
            int v155 = 0;
            if (v153 >= v154 >> 7)
            {
              uint64_t v156 = ((506832829 * *(_DWORD *)v110) >> 17) & 0x7FFE;
              unint64_t result = *(void *)(v233 + 120);
              char v157 = 1;
              unint64_t v113 = 2020;
              unint64_t v158 = v102;
              unint64_t v159 = v103;
              do
              {
                char v160 = v157;
                *(void *)(v152 + 8) = ++v154;
                unint64_t v161 = *(unsigned __int8 *)(result + v156);
                if (!*(unsigned char *)(result + v156) || v25 < v161) {
                  goto LABEL_202;
                }
                uint64_t v162 = *(unsigned __int16 *)(*(void *)(v233 + 112) + 2 * v156);
                uint64_t v163 = *(void *)(v233 + 88);
                uint64_t v164 = *(unsigned int *)(v163 + 4 * v161 + 32);
                uint64_t v165 = *(void *)(v163 + 168);
                unint64_t v166 = (unsigned __int8 *)(v165 + v164 + v162 * *(unsigned __int8 *)(result + v156));
                if (v161 < 8)
                {
                  unint64_t v103 = 0;
LABEL_207:
                  unint64_t v172 = v161 & 7;
                  if ((v161 & 7) != 0)
                  {
                    unint64_t v173 = v103 | v172;
                    while (v110[v103] == *v166)
                    {
                      ++v166;
                      ++v103;
                      if (!--v172)
                      {
                        unint64_t v103 = v173;
                        break;
                      }
                    }
                  }
                }
                else
                {
                  unint64_t v167 = 0;
                  unint64_t v103 = v161 & 0xF8;
                  uint64_t v168 = (unsigned __int8 *)(v165
                                           + v162 * (unint64_t)*(unsigned __int8 *)(result + v156)
                                           + (*(unsigned char *)(result + v156) & 0xF8)
                                           + v164);
                  while (1)
                  {
                    uint64_t v169 = *(void *)&v166[v167];
                    uint64_t v170 = *(void *)&v110[v167];
                    if (v169 != v170) {
                      break;
                    }
                    v167 += 8;
                    if (v103 == v167)
                    {
                      unint64_t v166 = v168;
                      goto LABEL_207;
                    }
                  }
                  unint64_t v103 = v167 + (__clz(__rbit64(v170 ^ v169)) >> 3);
                }
                if (v103
                  && v103 + *(unsigned int *)(v233 + 100) > v161
                  && (unint64_t v102 = v236
                           + 1
                           + v162
                           + ((((*(void *)(v233 + 104) >> (6 * (v161 - v103))) & 0x3FLL)
                             + 4 * (v161 - v103)) << *(unsigned char *)(v163 + v161)),
                      v102 <= v246)
                  && (unint64_t v171 = 135 * v103 - 30 * (__clz(v102) ^ 0x1F) + 1920, v171 >= v113))
                {
                  int v155 = v161 - v103;
                  *(void *)(v152 + 16) = ++v153;
                  unint64_t v113 = v171;
                }
                else
                {
LABEL_202:
                  unint64_t v103 = v159;
                  unint64_t v102 = v158;
                }
                char v157 = 0;
                ++v156;
                unint64_t v158 = v102;
                unint64_t v159 = v103;
              }
              while ((v160 & 1) != 0);
            }
            else
            {
              unint64_t v113 = 2020;
            }
          }
          else
          {
            int v155 = 0;
            a5 = v233;
          }
          if (v113 < v243 + 175) {
            break;
          }
          a3 = v248;
          ++v247;
          unint64_t v18 = v232;
          if (v237 <= 2)
          {
            unsigned int v99 = v237 + 1;
            int v100 = v149;
            unint64_t v229 = v102;
            unint64_t v243 = v113;
            int v231 = v155;
            unint64_t v47 = v103;
            unint64_t v52 = v106;
            if (v238 + 5 < v230) {
              continue;
            }
          }
          goto LABEL_226;
        }
        unint64_t v106 = v238;
        unint64_t v182 = v238 + v234;
        unint64_t v18 = v232;
        if (v238 + v234 >= v232) {
          unint64_t v182 = v232;
        }
        unint64_t v236 = v182;
        unint64_t v103 = v228;
        unint64_t v102 = v229;
        int v155 = v231;
        a3 = v248;
LABEL_226:
        unint64_t v13 = v230;
        if (v102 > v236)
        {
LABEL_227:
          unint64_t v183 = v102 + 15;
          goto LABEL_228;
        }
        uint64_t v185 = *a7;
        if (v102 == v185)
        {
          unint64_t v183 = 0;
LABEL_233:
          *(_DWORD *)uint64_t v227 = v247;
          *(_DWORD *)(v227 + 4) = v103 | (v155 << 25);
          uint64_t v186 = *(unsigned int *)(a5 + 68);
          uint64_t v187 = v186 + 16;
          if (v186 + 16 <= v183)
          {
            uint64_t v189 = *(unsigned int *)(a5 + 64);
            unint64_t v190 = v183 - v186 + (4 << v189) - 16;
            uint64_t v191 = (__clz(v190) ^ 0x1F) - 1;
            uint64_t v192 = ((v190 >> v191) & 1 | 2) << v191;
            unint64_t v183 = ((v190 & ~(-1 << v189))
                  + v187
                  + ((((v190 >> v191) & 1 | (2 * (v191 - v189))) + 65534) << v189)) | ((v191 - v189) << 10);
            unint64_t v188 = (v190 - v192) >> v189;
          }
          else
          {
            LODWORD(v188) = 0;
          }
          *(_WORD *)(v227 + 14) = v183;
          *(_DWORD *)(v227 + 8) = v188;
          if (v247 > 5)
          {
            if (v247 > 0x81)
            {
              if (v247 > 0x841)
              {
                if (v247 >> 1 >= 0xC21)
                {
                  if (v247 < 0x5842) {
                    LOWORD(v193) = 22;
                  }
                  else {
                    LOWORD(v193) = 23;
                  }
                }
                else
                {
                  LOWORD(v193) = 21;
                }
              }
              else
              {
                unsigned int v193 = (__clz(v247 - 66) ^ 0x1F) + 10;
              }
            }
            else
            {
              unsigned int v194 = (__clz(v247 - 2) ^ 0x1F) - 1;
              unsigned int v193 = ((v247 - 2) >> v194) + 2 * v194 + 2;
            }
          }
          else
          {
            LOWORD(v193) = v247;
          }
          uint64_t v206 = v155 + (int)v103;
          if (v206 > 9)
          {
            if (v206 > 0x85)
            {
              if (v206 > 0x845) {
                LOWORD(v207) = 23;
              }
              else {
                unsigned int v207 = (__clz(v206 - 70) ^ 0x1F) + 12;
              }
            }
            else
            {
              unint64_t v208 = v206 - 6;
              unsigned int v209 = (__clz(v208) ^ 0x1F) - 1;
              unsigned int v207 = (v208 >> v209) + 2 * v209 + 4;
            }
          }
          else
          {
            LOWORD(v207) = v155 + v103 - 2;
          }
          int v210 = v207 & 7 | (8 * (v193 & 7));
          if ((v183 & 0x3FF) != 0 || (unsigned __int16)v193 > 7u || (unsigned __int16)v207 > 0xFu)
          {
            int v212 = 3 * ((unsigned __int16)v193 >> 3) + ((unsigned __int16)(v207 & 0xFFF8) >> 3);
            unsigned int v211 = ((((0x520D40u >> (2 * v212)) & 0xC0) + (v212 << 6)) | v210) + 64;
          }
          else
          {
            LOWORD(v211) = v210 | 0x40;
            if ((v207 & 0xFFF8) == 0) {
              LOWORD(v211) = v207 & 7 | (8 * (v193 & 7));
            }
          }
          *(_WORD *)(v227 + 12) = v211;
          *a11 += v247;
          unint64_t v213 = v106 + 2;
          unint64_t v174 = v106 + v103;
          if (v106 + v103 >= v226) {
            unint64_t v214 = v226;
          }
          else {
            unint64_t v214 = v106 + v103;
          }
          if (v102 < v103 >> 2)
          {
            unint64_t v215 = v174 - 4 * v102;
            if (v213 > v215) {
              unint64_t v215 = v106 + 2;
            }
            if (v214 >= v215) {
              unint64_t v213 = v215;
            }
            else {
              unint64_t v213 = v214;
            }
          }
          unint64_t v19 = v225 + 2 * v103 + v106;
          uint64_t v20 = v227 + 16;
          if (v213 >= v214)
          {
            unint64_t v12 = 0;
            uint64_t v11 = a9;
            goto LABEL_293;
          }
          uint64_t v216 = *(void *)(a6 + 64);
          uint64_t v217 = v216 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v218 = (506832829 * *(_DWORD *)(a3 + (v213 & a4))) >> 17;
            *(unsigned char *)(v216 + 196608 + (unsigned __int16)v213) = v218;
            unint64_t v219 = (_WORD *)(v216 + 0x40000 + 4 * v178);
            unint64_t result = *(unsigned __int16 *)(v217 + 2 * v218);
            *(_WORD *)(v217 + 2 * v218) = v178++;
            unint64_t v220 = v213 - *(unsigned int *)(v216 + 4 * v218);
            if (v220 >= 0xFFFF) {
              LOWORD(v220) = -1;
            }
            *unint64_t v219 = v220;
            v219[1] = result;
            *(_DWORD *)(v216 + 4 * v218) = v213++;
          }
          while (v214 != v213);
          unint64_t v12 = 0;
          uint64_t v11 = a9;
          goto LABEL_291;
        }
        uint64_t v201 = a7[1];
        if (v102 == v201)
        {
          unint64_t v183 = 1;
        }
        else
        {
          unint64_t v202 = v102 + 3 - v185;
          if (v202 > 6)
          {
            unint64_t v205 = v102 + 3 - v201;
            if (v205 > 6)
            {
              if (v102 == a7[2])
              {
                unint64_t v183 = 2;
              }
              else
              {
                if (v102 != a7[3]) {
                  goto LABEL_227;
                }
                unint64_t v183 = 3;
              }
              goto LABEL_228;
            }
            char v203 = 4 * v205;
            unsigned int v204 = 266017486;
          }
          else
          {
            char v203 = 4 * v202;
            unsigned int v204 = 158663784;
          }
          unint64_t v183 = (v204 >> v203) & 0xF;
        }
LABEL_228:
        if (v102 <= v236 && v183)
        {
          a7[3] = a7[2];
          *(void *)(a7 + 1) = *(void *)a7;
          *a7 = v102;
          int32x4_t v184 = vdupq_n_s32(v102);
          *((int32x4_t *)a7 + 1) = vaddq_s32(v184, (int32x4_t)xmmword_20DB0A5B0);
          *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v184.i8, (int32x2_t)0x3FFFFFFFDLL);
        }
        goto LABEL_233;
      }
LABEL_212:
      unint64_t v12 = v247 + 1;
      unint64_t v174 = v52 + 1;
      unint64_t v19 = v242;
      if (v52 + 1 > v242)
      {
        uint64_t v11 = a9;
        uint64_t v20 = v227;
        unint64_t v13 = v230;
        if (v174 <= v242 + v224)
        {
          unint64_t v195 = v223;
          if (v52 + 9 < v223) {
            unint64_t v195 = v52 + 9;
          }
          if (v174 >= v195) {
            goto LABEL_293;
          }
          uint64_t v196 = *(void *)(a6 + 64);
          uint64_t v197 = v196 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v198 = (506832829 * *(_DWORD *)(a3 + (v174 & a4))) >> 17;
            unint64_t v199 = (_WORD *)(v196 + 0x40000 + 4 * v178);
            __int16 v200 = *(_WORD *)(v197 + 2 * v198);
            *(_WORD *)(v197 + 2 * v198) = v178++;
            *(unsigned char *)(v196 + 196608 + (unsigned __int16)v174) = v198;
            unint64_t result = v174 - *(unsigned int *)(v196 + 4 * v198);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            _WORD *v199 = result;
            v199[1] = v200;
            *(_DWORD *)(v196 + 4 * v198) = v174;
            v12 += 2;
            v174 += 2;
          }
          while (v174 < v195);
        }
        else
        {
          unint64_t v175 = v222;
          if (v52 + 17 < v222) {
            unint64_t v175 = v52 + 17;
          }
          if (v174 >= v175) {
            goto LABEL_293;
          }
          uint64_t v176 = *(void *)(a6 + 64);
          uint64_t v177 = v176 + 0x20000;
          unsigned __int16 v178 = *(_WORD *)(a6 + 48);
          do
          {
            unsigned int v179 = (506832829 * *(_DWORD *)(a3 + (v174 & a4))) >> 17;
            unint64_t v180 = (_WORD *)(v176 + 0x40000 + 4 * v178);
            __int16 v181 = *(_WORD *)(v177 + 2 * v179);
            *(_WORD *)(v177 + 2 * v179) = v178++;
            *(unsigned char *)(v176 + 196608 + (unsigned __int16)v174) = v179;
            unint64_t result = v174 - *(unsigned int *)(v176 + 4 * v179);
            if (result >= 0xFFFF) {
              unint64_t result = 0xFFFFLL;
            }
            *unint64_t v180 = result;
            v180[1] = v181;
            *(_DWORD *)(v176 + 4 * v179) = v174;
            v12 += 4;
            v174 += 4;
          }
          while (v174 < v175);
        }
LABEL_291:
        *(_WORD *)(a6 + 48) = v178;
        goto LABEL_293;
      }
      uint64_t v11 = a9;
      uint64_t v20 = v227;
      unint64_t v13 = v230;
LABEL_293:
      a2 = v174;
      if (v174 + 4 >= v13) {
        goto LABEL_300;
      }
    }
  }
  uint64_t v20 = a9;
  unint64_t v174 = a2;
LABEL_300:
  *a8 = v12 + v13 - v174;
  *a10 += (v20 - v11) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH42(unint64_t result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, double a9, double a10, int32x4_t a11, uint64_t a12, void *a13, void *a14)
{
  uint64_t v14 = a12;
  uint64_t v246 = *(void *)(a5 + 16);
  unint64_t v15 = *a8;
  unint64_t v16 = a2 + result;
  uint64_t v17 = a2 + result - 3;
  unint64_t v234 = v17;
  if (result <= 3) {
    uint64_t v17 = a2;
  }
  unint64_t v237 = v17;
  int v18 = *(_DWORD *)(a5 + 8);
  uint64_t v19 = 64;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v19 = 512;
  }
  a11.i64[0] = *(void *)a7;
  int32x4_t v20 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)a7, 0), (int32x4_t)xmmword_20DB0A5B0);
  *((int32x4_t *)a7 + 1) = v20;
  *((int32x4_t *)a7 + 2) = vaddq_s32(vzip1q_s32(a11, a11), (int32x4_t)xmmword_20DB0A5C0);
  int32x4_t v21 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)a11.i8, 1), (int32x4_t)xmmword_20DB0A5D0);
  *((int32x4_t *)a7 + 3) = v21;
  if (a2 + 4 < v16)
  {
    uint64_t v236 = v19;
    unint64_t v259 = (1 << v18) - 16;
    uint64_t v260 = a3;
    unint64_t v22 = v19 + a2;
    uint64_t v235 = 4 * v19;
    unint64_t v233 = v16 - 4;
    uint64_t v23 = a12;
    uint64_t v244 = a5;
    uint64_t v245 = a6;
    unint64_t v241 = a2 + result;
    uint64_t v247 = a6 + 48;
    while (1)
    {
      unint64_t v252 = v22;
      uint64_t v238 = v23;
      uint64_t v24 = 0;
      unint64_t v25 = 0;
      unint64_t v26 = 0;
      unint64_t v27 = 0;
      unint64_t v28 = v16 - a2;
      if (a2 >= v259) {
        unint64_t result = v259;
      }
      else {
        unint64_t result = a2;
      }
      unint64_t v254 = *(void *)(a5 + 80);
      uint64_t v256 = *(void *)(a6 + 1080);
      unint64_t v258 = v15;
      uint64_t v29 = v256 + 196608;
      unint64_t v30 = a2 & a4;
      unint64_t v31 = (unsigned __int8 *)(a3 + (a2 & a4));
      uint64_t v32 = (506832829 * *(_DWORD *)v31) >> 17;
      unint64_t v33 = 2020;
      uint64_t v34 = 2020;
      do
      {
        unint64_t v35 = a7[v24];
        unint64_t v36 = a2 - v35;
        if ((!v24 || *(unsigned __int8 *)(v29 + (unsigned __int16)(a2 - v35)) == v32)
          && result >= v35
          && v36 < a2)
        {
          uint64_t v38 = v260 + (v36 & a4);
          if (v28 < 8)
          {
            unint64_t v44 = 0;
            unint64_t v43 = (unsigned __int8 *)(a3 + (a2 & a4));
LABEL_32:
            if ((v28 & 7) != 0)
            {
              unint64_t v47 = v28 & 7 | v44;
              unint64_t v48 = v28 & 7;
              while (*(unsigned __int8 *)(v38 + v44) == *v43)
              {
                ++v43;
                ++v44;
                if (!--v48)
                {
                  unint64_t v44 = v47;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v39 = 0;
            unint64_t v40 = v28 >> 3;
            while (1)
            {
              uint64_t v41 = *(void *)&v31[v39];
              uint64_t v42 = *(void *)(v38 + v39);
              if (v41 != v42) {
                break;
              }
              v39 += 8;
              if (!--v40)
              {
                unint64_t v43 = &v31[v28 & 0xFFFFFFFFFFFFFFF8];
                unint64_t v44 = v28 & 0xFFFFFFFFFFFFFFF8;
                goto LABEL_32;
              }
            }
            unint64_t v44 = v39 + (__clz(__rbit64(v42 ^ v41)) >> 3);
          }
          if (v44 >= 2)
          {
            unint64_t v45 = 135 * v44 + 1935;
            if (v33 < v45)
            {
              unint64_t v46 = v45 - (((0x1CA10u >> (v24 & 0xE)) & 0xE) + 39);
              if (!v24) {
                unint64_t v46 = 135 * v44 + 1935;
              }
              if (v33 < v46)
              {
                unint64_t v27 = a7[v24];
                uint64_t v34 = v46;
                unint64_t v26 = v44;
                unint64_t v33 = v46;
                unint64_t v25 = v44;
              }
            }
          }
        }
        ++v24;
      }
      while (v24 != 16);
      unint64_t v49 = v259;
      if (a2 + v246 < v259) {
        unint64_t v49 = a2 + v246;
      }
      unint64_t v250 = v49;
      uint64_t v50 = ((unsigned __int16)((506832829 * *(_DWORD *)v31) >> 16) >> 1) & 0x1FF;
      uint64_t v51 = *(void *)(a6 + 1072);
      unint64_t v52 = a2;
      unint64_t v53 = a2 - *(unsigned int *)(v256 + 4 * v32);
      __int16 v54 = *(_WORD *)(v256 + 0x20000 + 2 * v32);
      if (v51)
      {
        unint64_t v55 = 0;
        uint64_t v56 = *(unsigned __int16 *)(v256 + 0x20000 + 2 * v32);
        unint64_t v57 = v53;
        do
        {
          v55 += v57;
          if (v55 > result) {
            break;
          }
          if (v25 + v30 <= a4)
          {
            unint64_t v58 = (v52 - v55) & a4;
            if (v58 + v25 <= a4 && *(unsigned __int8 *)(v260 + v25 + v30) == *(unsigned __int8 *)(v260 + v58 + v25))
            {
              uint64_t v59 = v260 + v58;
              if (v28 < 8)
              {
                unint64_t v65 = 0;
                unint64_t v64 = v31;
LABEL_68:
                unint64_t v72 = v28 & 7;
                if ((v28 & 7) != 0)
                {
                  unint64_t v242 = v28 & 7 | v65;
                  while (*(unsigned __int8 *)(v59 + v65) == *v64)
                  {
                    ++v64;
                    ++v65;
                    if (!--v72)
                    {
                      unint64_t v65 = v242;
                      break;
                    }
                  }
                }
              }
              else
              {
                uint64_t v60 = 0;
                unint64_t v61 = v28 >> 3;
                while (1)
                {
                  uint64_t v62 = *(void *)&v31[v60];
                  uint64_t v63 = *(void *)(v59 + v60);
                  if (v62 != v63) {
                    break;
                  }
                  v60 += 8;
                  if (!--v61)
                  {
                    unint64_t v64 = &v31[v28 & 0xFFFFFFFFFFFFFFF8];
                    unint64_t v65 = v28 & 0xFFFFFFFFFFFFFFF8;
                    goto LABEL_68;
                  }
                }
                unint64_t v65 = v60 + (__clz(__rbit64(v63 ^ v62)) >> 3);
              }
              unint64_t v66 = 135 * v65 - 30 * (__clz(v55) ^ 0x1F) + 1920;
              if (v33 < v66) {
                unint64_t v67 = v55;
              }
              else {
                unint64_t v67 = v27;
              }
              if (v33 < v66) {
                uint64_t v68 = v66;
              }
              else {
                uint64_t v68 = v34;
              }
              if (v33 < v66) {
                unint64_t v69 = v65;
              }
              else {
                unint64_t v69 = v26;
              }
              if (v33 < v66)
              {
                unint64_t v70 = v65;
              }
              else
              {
                unint64_t v66 = v33;
                unint64_t v70 = v25;
              }
              if (v65 >= 4)
              {
                unint64_t v27 = v67;
                uint64_t v34 = v68;
                unint64_t v26 = v69;
                unint64_t v33 = v66;
                unint64_t v25 = v70;
              }
            }
          }
          uint64_t v71 = (unsigned __int16 *)(v256 + 0x40000 + (v50 << 11) + 4 * v56);
          uint64_t v56 = v71[1];
          unint64_t v57 = *v71;
          --v51;
        }
        while (v51);
      }
      __int16 v73 = *(_WORD *)(v247 + 2 * v50);
      *(_WORD *)(v247 + 2 * v50) = v73 + 1;
      *(unsigned char *)(v29 + (unsigned __int16)v52) = v32;
      uint64_t v74 = v73 & 0x1FF;
      __int16 v75 = -1;
      if (v53 < 0xFFFF) {
        __int16 v75 = v53;
      }
      uint64_t v76 = (__int16 *)(v256 + 0x40000 + (v50 << 11) + 4 * v74);
      *uint64_t v76 = v75;
      v76[1] = v54;
      *(_DWORD *)(v256 + 4 * v32) = v52;
      *(_WORD *)(v256 + 0x20000 + 2 * v32) = v74;
      if (v34 == 2020)
      {
        a5 = v244;
        a6 = v245;
        uint64_t v77 = *(void *)(v245 + 1088);
        unint64_t v79 = *(void *)(v77 + 8);
        unint64_t v78 = *(void *)(v77 + 16);
        unint64_t v80 = v52;
        if (v78 < v79 >> 7) {
          goto LABEL_208;
        }
        int v243 = 0;
        unint64_t result = ((506832829 * *(_DWORD *)v31) >> 17) & 0x7FFE;
        uint64_t v81 = *(void *)(v244 + 120);
        char v82 = 1;
        unint64_t v83 = v26;
        unint64_t v84 = 2020;
        unint64_t v85 = v27;
        do
        {
          char v86 = v82;
          *(void *)(v77 + 8) = ++v79;
          unint64_t v87 = *(unsigned __int8 *)(v81 + result);
          if (!*(unsigned char *)(v81 + result) || v28 < v87) {
            goto LABEL_90;
          }
          uint64_t v88 = *(unsigned __int16 *)(*(void *)(v244 + 112) + 2 * result);
          uint64_t v89 = *(void *)(v244 + 88);
          uint64_t v90 = *(unsigned int *)(v89 + 4 * v87 + 32);
          uint64_t v91 = *(void *)(v89 + 168);
          uint64_t v92 = (unsigned __int8 *)(v91 + v90 + v88 * *(unsigned __int8 *)(v81 + result));
          if (v87 < 8)
          {
            unint64_t v26 = 0;
LABEL_95:
            unint64_t v99 = v87 & 7;
            if ((v87 & 7) != 0)
            {
              unint64_t v100 = v26 | v99;
              while (v31[v26] == *v92)
              {
                ++v92;
                ++v26;
                if (!--v99)
                {
                  unint64_t v26 = v100;
                  break;
                }
              }
            }
          }
          else
          {
            unint64_t v93 = 0;
            unint64_t v26 = v87 & 0xF8;
            uint64_t v94 = (unsigned __int8 *)(v91
                                    + v88 * (unint64_t)*(unsigned __int8 *)(v81 + result)
                                    + (*(unsigned char *)(v81 + result) & 0xF8)
                                    + v90);
            while (1)
            {
              uint64_t v95 = *(void *)&v92[v93];
              uint64_t v96 = *(void *)&v31[v93];
              if (v95 != v96) {
                break;
              }
              v93 += 8;
              if (v26 == v93)
              {
                uint64_t v92 = v94;
                goto LABEL_95;
              }
            }
            unint64_t v26 = v93 + (__clz(__rbit64(v96 ^ v95)) >> 3);
          }
          if (v26
            && v26 + *(unsigned int *)(v244 + 100) > v87
            && (unint64_t v97 = v250
                    + 1
                    + v88
                    + ((((*(void *)(v244 + 104) >> (6 * (v87 - v26))) & 0x3FLL)
                      + 4 * (v87 - v26)) << *(unsigned char *)(v89 + v87)),
                v97 <= v254)
            && (unsigned int v98 = __clz(v97), 135 * v26 - 30 * (v98 ^ 0x1F) + 1920 >= v84))
          {
            int v243 = v87 - v26;
            *(void *)(v77 + 16) = ++v78;
            unint64_t v84 = 135 * v26 - 30 * (v98 ^ 0x1F) + 1920;
          }
          else
          {
LABEL_90:
            unint64_t v97 = v85;
            unint64_t v26 = v83;
          }
          char v82 = 0;
          ++result;
          unint64_t v83 = v26;
          unint64_t v85 = v97;
        }
        while ((v86 & 1) != 0);
      }
      else
      {
        unint64_t v84 = v34;
        int v243 = 0;
        a5 = v244;
        a6 = v245;
        unint64_t v80 = v52;
        unint64_t v97 = v27;
      }
      if (v84 < 0x7E5)
      {
LABEL_208:
        unint64_t v15 = v258 + 1;
        unint64_t v177 = v80 + 1;
        unint64_t v22 = v252;
        a3 = v260;
        if (v80 + 1 <= v252)
        {
          uint64_t v14 = a12;
          uint64_t v23 = v238;
          unint64_t v16 = v241;
        }
        else
        {
          uint64_t v14 = a12;
          uint64_t v23 = v238;
          unint64_t v16 = v241;
          if (v177 <= v252 + v235)
          {
            unint64_t v201 = v80 + 9;
            if (v80 + 9 >= v234) {
              unint64_t v201 = v234;
            }
            if (v177 < v201)
            {
              uint64_t v202 = *(void *)(a6 + 1080);
              uint64_t v203 = v202 + 0x20000;
              do
              {
                unsigned int v204 = (506832829 * *(_DWORD *)(v260 + (v177 & a4))) >> 17;
                __int16 v205 = *(_WORD *)(v247 + 2 * (v204 & 0x1FF));
                *(_WORD *)(v247 + 2 * (v204 & 0x1FF)) = v205 + 1;
                uint64_t v206 = v205 & 0x1FF;
                unint64_t v207 = v177 - *(unsigned int *)(v202 + 4 * v204);
                unint64_t result = (unsigned __int16)v177;
                *(unsigned char *)(v202 + 196608 + (unsigned __int16)v177) = v204;
                if (v207 >= 0xFFFF) {
                  LOWORD(v207) = -1;
                }
                unint64_t v208 = (_WORD *)(v202 + 0x40000 + ((unint64_t)(v204 & 0x1FF) << 11) + 4 * v206);
                *unint64_t v208 = v207;
                __int16 v209 = *(_WORD *)(v203 + 2 * v204);
                *(_DWORD *)(v202 + 4 * v204) = v177;
                v208[1] = v209;
                *(_WORD *)(v203 + 2 * v204) = v206;
                v15 += 2;
                v177 += 2;
              }
              while (v177 < v201);
            }
          }
          else
          {
            unint64_t v178 = v80 + 17;
            if (v80 + 17 >= v233) {
              unint64_t v178 = v233;
            }
            if (v177 < v178)
            {
              uint64_t v179 = *(void *)(a6 + 1080);
              uint64_t v180 = v179 + 0x20000;
              do
              {
                unsigned int v181 = (506832829 * *(_DWORD *)(v260 + (v177 & a4))) >> 17;
                __int16 v182 = *(_WORD *)(v247 + 2 * (v181 & 0x1FF));
                *(_WORD *)(v247 + 2 * (v181 & 0x1FF)) = v182 + 1;
                uint64_t v183 = v182 & 0x1FF;
                unint64_t v184 = v177 - *(unsigned int *)(v179 + 4 * v181);
                unint64_t result = (unsigned __int16)v177;
                *(unsigned char *)(v179 + 196608 + (unsigned __int16)v177) = v181;
                if (v184 >= 0xFFFF) {
                  LOWORD(v184) = -1;
                }
                uint64_t v185 = (_WORD *)(v179 + 0x40000 + ((unint64_t)(v181 & 0x1FF) << 11) + 4 * v183);
                *uint64_t v185 = v184;
                __int16 v186 = *(_WORD *)(v180 + 2 * v181);
                *(_DWORD *)(v179 + 4 * v181) = v177;
                v185[1] = v186;
                *(_WORD *)(v180 + 2 * v181) = v183;
                v15 += 4;
                v177 += 4;
              }
              while (v177 < v178);
            }
          }
        }
        goto LABEL_288;
      }
      unint64_t v255 = v84;
      unsigned int v101 = 0;
      a3 = v260;
      while (1)
      {
        unsigned int v249 = v101;
        unint64_t v239 = v97;
        unint64_t v240 = v26;
        uint64_t v102 = 0;
        unint64_t v103 = 0;
        unint64_t v104 = 0;
        --v28;
        unint64_t v105 = v26 - 1;
        if (v26 - 1 >= v28) {
          unint64_t v105 = v28;
        }
        unint64_t result = *(int *)(a5 + 4) >= 5 ? 0 : v105;
        unint64_t v106 = v80 + 1;
        unint64_t v253 = v80;
        unint64_t v107 = v80 + 1 < v259 ? v80 + 1 : v259;
        unint64_t v257 = *(void *)(a5 + 80);
        uint64_t v108 = *(void *)(a6 + 1080);
        uint64_t v109 = v108 + 196608;
        uint64_t v110 = v106 & a4;
        uint64_t v111 = (unsigned __int8 *)(a3 + (v106 & a4));
        uint64_t v112 = (506832829 * *(_DWORD *)v111) >> 17;
        unint64_t v113 = 2020;
        unint64_t v114 = 2020;
        do
        {
          unint64_t v115 = a7[v102];
          unint64_t v116 = v106 - v115;
          if ((!v102 || *(unsigned __int8 *)(v109 + (unsigned __int16)(v106 - v115)) == v112)
            && v107 >= v115
            && v116 < v106)
          {
            uint64_t v118 = a3 + (v116 & a4);
            if (v28 < 8)
            {
              unint64_t v119 = 0;
              unint64_t v123 = (unsigned __int8 *)(a3 + (v106 & a4));
LABEL_133:
              if ((v28 & 7) != 0)
              {
                unint64_t v126 = v28 & 7;
                do
                {
                  if (*(unsigned __int8 *)(v118 + v119) != *v123) {
                    break;
                  }
                  ++v123;
                  ++v119;
                  --v126;
                }
                while (v126);
              }
            }
            else
            {
              unint64_t v119 = 0;
              unint64_t v120 = v28 >> 3;
              while (1)
              {
                uint64_t v121 = *(void *)&v111[v119];
                uint64_t v122 = *(void *)(v118 + v119);
                if (v121 != v122) {
                  break;
                }
                v119 += 8;
                if (!--v120)
                {
                  unint64_t v123 = &v111[v119];
                  goto LABEL_133;
                }
              }
              v119 += __clz(__rbit64(v122 ^ v121)) >> 3;
            }
            if (v119 >= 2)
            {
              unint64_t v124 = 135 * v119 + 1935;
              if (v113 < v124)
              {
                unint64_t v125 = v124 - (((0x1CA10u >> (v102 & 0xE)) & 0xE) + 39);
                if (!v102) {
                  unint64_t v125 = 135 * v119 + 1935;
                }
                if (v113 < v125)
                {
                  unint64_t v104 = v119;
                  unint64_t v103 = a7[v102];
                  unint64_t v114 = v125;
                  unint64_t v113 = v125;
                  unint64_t result = v119;
                }
              }
            }
          }
          ++v102;
        }
        while (v102 != 16);
        unint64_t v127 = v259;
        if (v106 + v246 < v259) {
          unint64_t v127 = v106 + v246;
        }
        unint64_t v248 = v127;
        uint64_t v128 = ((unsigned __int16)((506832829 * *(_DWORD *)v111) >> 16) >> 1) & 0x1FF;
        uint64_t v129 = *(void *)(a6 + 1072);
        uint64_t v130 = *(unsigned int *)(v108 + 4 * v112);
        unint64_t v131 = v106 - v130;
        uint64_t v132 = *(unsigned __int16 *)(v108 + 0x20000 + 2 * v112);
        __int16 v251 = *(_WORD *)(v108 + 0x20000 + 2 * v112);
        if (v129)
        {
          unint64_t v133 = 0;
          uint64_t v134 = v106 - v130;
          unint64_t v135 = v28 & 7;
          do
          {
            v133 += v134;
            if (v133 > v107) {
              break;
            }
            if (result + v110 <= a4)
            {
              unint64_t v136 = (v106 - v133) & a4;
              if (v136 + result <= a4
                && *(unsigned __int8 *)(a3 + result + v110) == *(unsigned __int8 *)(a3 + v136 + result))
              {
                uint64_t v137 = a3 + v136;
                if (v28 < 8)
                {
                  unint64_t v138 = 0;
                  unint64_t v142 = v111;
LABEL_170:
                  while (v135)
                  {
                    if (*(unsigned __int8 *)(v137 + v138) != *v142) {
                      break;
                    }
                    ++v142;
                    ++v138;
                    --v135;
                  }
                }
                else
                {
                  unint64_t v138 = 0;
                  unint64_t v139 = v28 >> 3;
                  while (1)
                  {
                    uint64_t v140 = *(void *)&v111[v138];
                    uint64_t v141 = *(void *)(v137 + v138);
                    if (v140 != v141) {
                      break;
                    }
                    v138 += 8;
                    if (!--v139)
                    {
                      unint64_t v142 = &v111[v138];
                      unint64_t v135 = v28 & 7;
                      goto LABEL_170;
                    }
                  }
                  v138 += __clz(__rbit64(v141 ^ v140)) >> 3;
                }
                unint64_t v143 = 135 * v138 - 30 * (__clz(v133) ^ 0x1F) + 1920;
                if (v113 < v143) {
                  unint64_t v144 = v138;
                }
                else {
                  unint64_t v144 = v104;
                }
                if (v113 < v143) {
                  unint64_t v145 = v133;
                }
                else {
                  unint64_t v145 = v103;
                }
                if (v113 < v143) {
                  unint64_t v146 = v143;
                }
                else {
                  unint64_t v146 = v114;
                }
                if (v113 < v143)
                {
                  unint64_t v147 = v138;
                }
                else
                {
                  unint64_t v143 = v113;
                  unint64_t v147 = result;
                }
                if (v138 >= 4)
                {
                  unint64_t v104 = v144;
                  unint64_t v103 = v145;
                  unint64_t v114 = v146;
                  unint64_t v113 = v143;
                  unint64_t result = v147;
                }
                a3 = v260;
                unint64_t v135 = v28 & 7;
              }
            }
            __int16 v148 = (unsigned __int16 *)(v108 + 0x40000 + (v128 << 11) + 4 * v132);
            uint64_t v132 = v148[1];
            uint64_t v134 = *v148;
            --v129;
          }
          while (v129);
        }
        __int16 v149 = *(_WORD *)(v247 + 2 * v128);
        *(_WORD *)(v247 + 2 * v128) = v149 + 1;
        *(unsigned char *)(v109 + (unsigned __int16)v106) = v112;
        uint64_t v150 = v149 & 0x1FF;
        __int16 v151 = -1;
        if (v131 < 0xFFFF) {
          __int16 v151 = v131;
        }
        uint64_t v152 = (__int16 *)(v108 + 0x40000 + (v128 << 11) + 4 * v150);
        *uint64_t v152 = v151;
        v152[1] = v251;
        *(_DWORD *)(v108 + 4 * v112) = v106;
        *(_WORD *)(v108 + 0x20000 + 2 * v112) = v150;
        if (v114 == 2020)
        {
          a5 = v244;
          a6 = v245;
          uint64_t v153 = *(void *)(v245 + 1088);
          unint64_t result = *(void *)(v153 + 8);
          unint64_t v154 = *(void *)(v153 + 16);
          unint64_t v155 = v253;
          int v156 = 0;
          if (v154 >= result >> 7)
          {
            uint64_t v158 = ((506832829 * *(_DWORD *)v111) >> 17) & 0x7FFE;
            uint64_t v159 = *(void *)(v244 + 120);
            char v160 = 1;
            unint64_t v114 = 2020;
            unint64_t v161 = v103;
            unint64_t v162 = v104;
            do
            {
              char v163 = v160;
              *(void *)(v153 + 8) = ++result;
              unint64_t v164 = *(unsigned __int8 *)(v159 + v158);
              if (!*(unsigned char *)(v159 + v158) || v28 < v164) {
                goto LABEL_197;
              }
              uint64_t v165 = *(unsigned __int16 *)(*(void *)(v244 + 112) + 2 * v158);
              uint64_t v166 = *(void *)(v244 + 88);
              uint64_t v167 = *(unsigned int *)(v166 + 4 * v164 + 32);
              uint64_t v168 = *(void *)(v166 + 168);
              uint64_t v169 = (unsigned __int8 *)(v168 + v167 + v165 * *(unsigned __int8 *)(v159 + v158));
              if (v164 < 8)
              {
                unint64_t v104 = 0;
LABEL_202:
                unint64_t v175 = v164 & 7;
                if ((v164 & 7) != 0)
                {
                  unint64_t v176 = v104 | v175;
                  while (v111[v104] == *v169)
                  {
                    ++v169;
                    ++v104;
                    if (!--v175)
                    {
                      unint64_t v104 = v176;
                      break;
                    }
                  }
                  a3 = v260;
                }
              }
              else
              {
                unint64_t v170 = 0;
                unint64_t v104 = v164 & 0xF8;
                unint64_t v171 = (unsigned __int8 *)(v168
                                         + v165 * (unint64_t)*(unsigned __int8 *)(v159 + v158)
                                         + (*(unsigned char *)(v159 + v158) & 0xF8)
                                         + v167);
                while (1)
                {
                  uint64_t v172 = *(void *)&v169[v170];
                  uint64_t v173 = *(void *)&v111[v170];
                  if (v172 != v173) {
                    break;
                  }
                  v170 += 8;
                  if (v104 == v170)
                  {
                    uint64_t v169 = v171;
                    goto LABEL_202;
                  }
                }
                unint64_t v104 = v170 + (__clz(__rbit64(v173 ^ v172)) >> 3);
              }
              if (v104
                && v104 + *(unsigned int *)(v244 + 100) > v164
                && (unint64_t v103 = v248
                         + 1
                         + v165
                         + ((((*(void *)(v244 + 104) >> (6 * (v164 - v104))) & 0x3FLL)
                           + 4 * (v164 - v104)) << *(unsigned char *)(v166 + v164)),
                    v103 <= v257)
                && (unint64_t v174 = 135 * v104 - 30 * (__clz(v103) ^ 0x1F) + 1920, v174 >= v114))
              {
                int v156 = v164 - v104;
                *(void *)(v153 + 16) = ++v154;
                unint64_t v114 = v174;
              }
              else
              {
LABEL_197:
                unint64_t v104 = v162;
                unint64_t v103 = v161;
              }
              char v160 = 0;
              ++v158;
              unint64_t v161 = v103;
              unint64_t v162 = v104;
            }
            while ((v163 & 1) != 0);
          }
          else
          {
            unint64_t v114 = 2020;
          }
        }
        else
        {
          int v156 = 0;
          a5 = v244;
          a6 = v245;
          unint64_t v155 = v253;
        }
        if (v114 < v255 + 175) {
          break;
        }
        ++v258;
        if (v249 <= 2)
        {
          unint64_t v157 = v155 + 5;
          unsigned int v101 = v249 + 1;
          unint64_t v97 = v103;
          unint64_t v255 = v114;
          int v243 = v156;
          unint64_t v26 = v104;
          unint64_t v80 = v106;
          if (v157 < v241) {
            continue;
          }
        }
        goto LABEL_222;
      }
      unint64_t v187 = v155 + v246;
      if (v155 + v246 >= v259) {
        unint64_t v187 = v259;
      }
      unint64_t v248 = v187;
      unint64_t v103 = v239;
      unint64_t v104 = v240;
      int v156 = v243;
      unint64_t v106 = v155;
LABEL_222:
      unint64_t v16 = v241;
      if (v103 > v248)
      {
LABEL_223:
        unint64_t v188 = v103 + 15;
        goto LABEL_224;
      }
      uint64_t v191 = *a7;
      if (v103 == v191)
      {
        unint64_t v188 = 0;
        goto LABEL_229;
      }
      uint64_t v210 = a7[1];
      if (v103 == v210)
      {
        unint64_t v188 = 1;
        goto LABEL_224;
      }
      unint64_t v211 = v103 + 3 - v191;
      if (v211 <= 6) {
        break;
      }
      unint64_t v214 = v103 + 3 - v210;
      if (v214 <= 6)
      {
        char v212 = 4 * v214;
        unsigned int v213 = 266017486;
        goto LABEL_255;
      }
      if (v103 == a7[2])
      {
        unint64_t v188 = 2;
      }
      else
      {
        if (v103 != a7[3]) {
          goto LABEL_223;
        }
        unint64_t v188 = 3;
      }
LABEL_224:
      if (v103 <= v248)
      {
        uint64_t v189 = v247;
        if (v188)
        {
          a7[3] = a7[2];
          v21.i64[0] = *(void *)a7;
          *(void *)(a7 + 1) = *(void *)a7;
          *a7 = v103;
          v20.i32[0] = v103;
          int32x4_t v190 = vzip1q_s32(v20, v21);
          int32x4_t v20 = vaddq_s32(vzip1q_s32(v190, v190), (int32x4_t)xmmword_20DB0A5C0);
          *((int32x4_t *)a7 + 1) = vaddq_s32(vdupq_n_s32(v103), (int32x4_t)xmmword_20DB0A5B0);
          *((int32x4_t *)a7 + 2) = v20;
          int32x4_t v21 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v21.i8, 0), (int32x4_t)xmmword_20DB0A5D0);
          *((int32x4_t *)a7 + 3) = v21;
        }
        goto LABEL_230;
      }
LABEL_229:
      uint64_t v189 = v247;
LABEL_230:
      *(_DWORD *)uint64_t v238 = v258;
      *(_DWORD *)(v238 + 4) = v104 | (v156 << 25);
      uint64_t v192 = *(unsigned int *)(a5 + 68);
      uint64_t v193 = v192 + 16;
      if (v192 + 16 <= v188)
      {
        uint64_t v195 = *(unsigned int *)(a5 + 64);
        unint64_t v196 = v188 - v192 + (4 << v195) - 16;
        uint64_t v197 = (__clz(v196) ^ 0x1F) - 1;
        uint64_t v198 = ((v196 >> v197) & 1 | 2) << v197;
        unint64_t v188 = ((v196 & ~(-1 << v195))
              + v193
              + ((((v196 >> v197) & 1 | (2 * (v197 - v195))) + 65534) << v195)) | ((v197 - v195) << 10);
        unint64_t v194 = (v196 - v198) >> v195;
      }
      else
      {
        LODWORD(v194) = 0;
      }
      *(_WORD *)(v238 + 14) = v188;
      *(_DWORD *)(v238 + 8) = v194;
      if (v258 > 5)
      {
        if (v258 > 0x81)
        {
          if (v258 > 0x841)
          {
            if (v258 >> 1 >= 0xC21)
            {
              if (v258 < 0x5842) {
                LOWORD(v199) = 22;
              }
              else {
                LOWORD(v199) = 23;
              }
            }
            else
            {
              LOWORD(v199) = 21;
            }
          }
          else
          {
            unsigned int v199 = (__clz(v258 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v200 = (__clz(v258 - 2) ^ 0x1F) - 1;
          unsigned int v199 = ((v258 - 2) >> v200) + 2 * v200 + 2;
        }
      }
      else
      {
        LOWORD(v199) = v258;
      }
      uint64_t v215 = v156 + (int)v104;
      if (v215 > 9)
      {
        if (v215 > 0x85)
        {
          if (v215 > 0x845) {
            LOWORD(v216) = 23;
          }
          else {
            unsigned int v216 = (__clz(v215 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v217 = v215 - 6;
          unsigned int v218 = (__clz(v217) ^ 0x1F) - 1;
          unsigned int v216 = (v217 >> v218) + 2 * v218 + 4;
        }
      }
      else
      {
        LOWORD(v216) = v156 + v104 - 2;
      }
      int v219 = v216 & 7 | (8 * (v199 & 7));
      if ((v188 & 0x3FF) != 0 || (unsigned __int16)v199 > 7u || (unsigned __int16)v216 > 0xFu)
      {
        int v221 = 3 * ((unsigned __int16)v199 >> 3) + ((unsigned __int16)(v216 & 0xFFF8) >> 3);
        unsigned int v220 = ((((0x520D40u >> (2 * v221)) & 0xC0) + (v221 << 6)) | v219) + 64;
      }
      else
      {
        LOWORD(v220) = v219 | 0x40;
        if ((v216 & 0xFFF8) == 0) {
          LOWORD(v220) = v216 & 7 | (8 * (v199 & 7));
        }
      }
      *(_WORD *)(v238 + 12) = v220;
      *a14 += v258;
      unint64_t v222 = v106 + 2;
      unint64_t v177 = v106 + v104;
      unint64_t v223 = v237;
      if (v106 + v104 < v237) {
        unint64_t v223 = v106 + v104;
      }
      if (v103 < v104 >> 2)
      {
        unint64_t v224 = v177 - 4 * v103;
        if (v222 > v224) {
          unint64_t v224 = v106 + 2;
        }
        if (v223 >= v224) {
          unint64_t v222 = v224;
        }
        else {
          unint64_t v222 = v223;
        }
      }
      unint64_t v22 = v236 + 2 * v104 + v106;
      uint64_t v23 = v238 + 16;
      if (v222 >= v223)
      {
        unint64_t v15 = 0;
        uint64_t v14 = a12;
      }
      else
      {
        uint64_t v225 = *(void *)(a6 + 1080);
        uint64_t v226 = v225 + 0x20000;
        do
        {
          unsigned int v227 = (506832829 * *(_DWORD *)(a3 + (v222 & a4))) >> 17;
          __int16 v228 = *(_WORD *)(v189 + 2 * (v227 & 0x1FF));
          *(_WORD *)(v189 + 2 * (v227 & 0x1FF)) = v228 + 1;
          uint64_t v229 = v228 & 0x1FF;
          unint64_t v230 = v222 - *(unsigned int *)(v225 + 4 * v227);
          *(unsigned char *)(v225 + 196608 + (unsigned __int16)v222) = v227;
          if (v230 >= 0xFFFF) {
            LOWORD(v230) = -1;
          }
          int v231 = (_WORD *)(v225 + 0x40000 + ((unint64_t)(v227 & 0x1FF) << 11) + 4 * v229);
          *int v231 = v230;
          unint64_t result = *(unsigned __int16 *)(v226 + 2 * v227);
          v231[1] = result;
          *(_DWORD *)(v225 + 4 * v227) = v222;
          *(_WORD *)(v226 + 2 * v227) = v229;
          ++v222;
        }
        while (v223 != v222);
        unint64_t v15 = 0;
        uint64_t v14 = a12;
      }
LABEL_288:
      a2 = v177;
      if (v177 + 4 >= v16) {
        goto LABEL_295;
      }
    }
    char v212 = 4 * v211;
    unsigned int v213 = 158663784;
LABEL_255:
    unint64_t v188 = (v213 >> v212) & 0xF;
    goto LABEL_224;
  }
  uint64_t v23 = a12;
  unint64_t v177 = a2;
LABEL_295:
  *a8 = v15 + v16 - v177;
  *a13 += (v23 - v14) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH54(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *i, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v128 = *MEMORY[0x263EF8340];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v115 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v118 = v14;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v15 = 512;
  }
  else {
    uint64_t v15 = 64;
  }
  if (a2 + 8 < v13)
  {
    uint64_t v117 = v15;
    unint64_t v124 = (1 << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v116 = *(void *)(a5 + 16);
    unint64_t v16 = v15 + a2;
    unint64_t result = *(void *)(a6 + 56);
    uint64_t v114 = 4 * v15;
    int8x16_t v17 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
    uint64_t v119 = a9;
    unint64_t v120 = i;
    unint64_t v122 = v13;
    while (1)
    {
      unint64_t v18 = v13 - v11;
      if (v11 >= v124) {
        unint64_t v19 = v124;
      }
      else {
        unint64_t v19 = v11;
      }
      unint64_t v20 = v11 & a4;
      int32x4_t v21 = (void *)(a3 + (v11 & a4));
      int v22 = *(unsigned __int8 *)v21;
      unint64_t v23 = *i;
      if (v11 < v23) {
        goto LABEL_22;
      }
      uint64_t v24 = (unsigned __int8 *)(a3 + (a4 & (v11 - v23)));
      if (v22 != *v24) {
        goto LABEL_22;
      }
      if (v18 < 8)
      {
        unint64_t v26 = 0;
        unint64_t v27 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_179:
        unint64_t v111 = v18 & 7;
        if ((v18 & 7) != 0)
        {
          unint64_t v112 = v26 | v111;
          while (v24[v26] == *v27)
          {
            ++v27;
            ++v26;
            if (!--v111)
            {
              unint64_t v26 = v112;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v25 = 0;
        unint64_t v26 = v18 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v27 = (unsigned __int8 *)(a3 + v20 + (v18 & 0xFFFFFFFFFFFFFFF8));
        unint64_t v28 = v18 >> 3;
        while (1)
        {
          uint64_t v29 = v21[v25];
          uint64_t v30 = *(void *)&v24[v25 * 8];
          if (v29 != v30) {
            break;
          }
          ++v25;
          if (!--v28) {
            goto LABEL_179;
          }
        }
        unint64_t v26 = v25 * 8 + (__clz(__rbit64(v30 ^ v29)) >> 3);
      }
      if (v26 >= 4 && (unint64_t v31 = 135 * v26 + 1935, v31 >= 0x7E5))
      {
        unint64_t v125 = v23;
        int v22 = *(unsigned __int8 *)(a3 + v26 + v20);
      }
      else
      {
LABEL_22:
        unint64_t v125 = 0;
        unint64_t v26 = 0;
        unint64_t v31 = 2020;
      }
      uint64_t v32 = 0;
      int64x2_t v33 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00 * *v21) >> 44);
      int8x16_t v126 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_20DB0A590), v17);
      int8x16_t v127 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_20DB0A5A0), v17);
      do
      {
        uint64_t v34 = *(unsigned int *)(result + 4 * v126.i64[v32]);
        unint64_t v35 = v11 - v34;
        if (v22 == *(unsigned __int8 *)(a3 + (v34 & a4) + v26) && v11 != v34 && v35 <= v19)
        {
          uint64_t v38 = a3 + (v34 & a4);
          if (v18 < 8)
          {
            unint64_t v43 = 0;
            unint64_t v44 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            if ((v18 & 7) != 0)
            {
              unint64_t v46 = v18 & 7 | v43;
              unint64_t v47 = v18 & 7;
              while (*(unsigned __int8 *)(v38 + v43) == *v44)
              {
                ++v44;
                ++v43;
                if (!--v47)
                {
                  unint64_t v43 = v46;
                  break;
                }
              }
            }
          }
          else
          {
            uint64_t v39 = 0;
            unint64_t v40 = v18 >> 3;
            while (1)
            {
              uint64_t v41 = v21[v39];
              uint64_t v42 = *(void *)(v38 + v39 * 8);
              if (v41 != v42) {
                break;
              }
              ++v39;
              if (!--v40)
              {
                unint64_t v43 = v18 & 0xFFFFFFFFFFFFFFF8;
                unint64_t v44 = (unsigned __int8 *)v21 + (v18 & 0xFFFFFFFFFFFFFFF8);
                goto LABEL_43;
              }
            }
            unint64_t v43 = v39 * 8 + (__clz(__rbit64(v42 ^ v41)) >> 3);
          }
          if (v43 >= 4)
          {
            unsigned int v45 = __clz(v35) ^ 0x1F;
            if (v31 < 135 * v43 - 30 * v45 + 1920)
            {
              int v22 = *(unsigned __int8 *)(a3 + v43 + v20);
              unint64_t v125 = v35;
              unint64_t v31 = 135 * v43 - 30 * v45 + 1920;
              unint64_t v26 = v43;
            }
          }
        }
        ++v32;
      }
      while (v32 != 4);
      *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v126.i64 + (v11 & 0x18))) = v11;
      if (v31 < 0x7E5)
      {
        ++v12;
        unint64_t v82 = v11 + 1;
        if (v11 + 1 <= v16)
        {
          uint64_t i = v120;
          unint64_t v13 = v122;
        }
        else
        {
          unint64_t v13 = v122;
          if (v82 <= v16 + v114)
          {
            unint64_t v96 = v11 + 9;
            if (v11 + 9 >= v115) {
              unint64_t v96 = v115;
            }
            for (uint64_t i = v120; v82 < v96; v82 += 2)
            {
              *(_DWORD *)(result
                        + 4
                        * (((((unint64_t)(0x35A7BD1E35A7BD00 * *(void *)(a3 + (v82 & a4))) >> 32) >> 12)
                          + (v82 & 0x18)) & 0xFFFFF)) = v82;
              v12 += 2;
            }
          }
          else
          {
            unint64_t v83 = v11 + 17;
            if (v11 + 17 >= v115) {
              unint64_t v83 = v115;
            }
            for (uint64_t i = v120; v82 < v83; v82 += 4)
            {
              *(_DWORD *)(result
                        + 4
                        * (((((unint64_t)(0x35A7BD1E35A7BD00 * *(void *)(a3 + (v82 & a4))) >> 32) >> 12)
                          + (v82 & 0x18)) & 0xFFFFF)) = v82;
              v12 += 4;
            }
          }
        }
        goto LABEL_172;
      }
      unsigned int v48 = 0;
      unint64_t v123 = *v120;
      while (1)
      {
        --v18;
        unint64_t v49 = v26 - 1;
        if (v26 - 1 >= v18) {
          unint64_t v49 = v18;
        }
        unint64_t v50 = *(int *)(a5 + 4) >= 5 ? 0 : v49;
        unint64_t v51 = v11 + 1;
        unint64_t v52 = v11 + 1 < v124 ? v11 + 1 : v124;
        unint64_t v53 = v51 & a4;
        int v54 = *(unsigned __int8 *)(a3 + v50 + (v51 & a4));
        unint64_t v55 = (void *)(a3 + (v51 & a4));
        if (v51 < v123) {
          goto LABEL_69;
        }
        unint64_t v56 = a4 & (v51 - v123);
        if (v54 != *(unsigned __int8 *)(a3 + v56 + v50)) {
          goto LABEL_69;
        }
        uint64_t v57 = a3 + v56;
        if (v18 < 8)
        {
          unint64_t v58 = 0;
          uint64_t v62 = (unsigned __int8 *)(a3 + (v51 & a4));
LABEL_100:
          unint64_t v81 = v18 & 7;
          if ((v18 & 7) != 0)
          {
            do
            {
              if (*(unsigned __int8 *)(v57 + v58) != *v62) {
                break;
              }
              ++v62;
              ++v58;
              --v81;
            }
            while (v81);
          }
        }
        else
        {
          unint64_t v58 = 0;
          unint64_t v59 = v18 >> 3;
          while (1)
          {
            uint64_t v60 = *(void *)((char *)v55 + v58);
            uint64_t v61 = *(void *)(v57 + v58);
            if (v60 != v61) {
              break;
            }
            v58 += 8;
            if (!--v59)
            {
              uint64_t v62 = (unsigned __int8 *)v55 + v58;
              goto LABEL_100;
            }
          }
          v58 += __clz(__rbit64(v61 ^ v60)) >> 3;
        }
        if (v58 >= 4 && (unint64_t v63 = 135 * v58 + 1935, v63 >= 0x7E5))
        {
          int v54 = *(unsigned __int8 *)(a3 + v58 + v53);
          unint64_t v50 = v58;
          unint64_t v64 = v123;
        }
        else
        {
LABEL_69:
          unint64_t v64 = 0;
          unint64_t v63 = 2020;
        }
        uint64_t v65 = 0;
        int64x2_t v66 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00 * *v55) >> 44);
        int8x16_t v67 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
        int8x16_t v126 = vandq_s8((int8x16_t)vaddq_s64(v66, (int64x2_t)xmmword_20DB0A590), v67);
        int8x16_t v127 = vandq_s8((int8x16_t)vaddq_s64(v66, (int64x2_t)xmmword_20DB0A5A0), v67);
        do
        {
          uint64_t v68 = *(unsigned int *)(result + 4 * v126.i64[v65]);
          unint64_t v69 = v51 - v68;
          if (v54 == *(unsigned __int8 *)(a3 + (v68 & a4) + v50) && v51 != v68 && v69 <= v52)
          {
            uint64_t v72 = a3 + (v68 & a4);
            if (v18 < 8)
            {
              unint64_t v73 = 0;
              uint64_t v77 = (unsigned __int8 *)(a3 + (v51 & a4));
LABEL_90:
              if ((v18 & 7) != 0)
              {
                unint64_t v79 = v18 & 7;
                do
                {
                  if (*(unsigned __int8 *)(v72 + v73) != *v77) {
                    break;
                  }
                  ++v77;
                  ++v73;
                  --v79;
                }
                while (v79);
              }
            }
            else
            {
              unint64_t v73 = 0;
              unint64_t v74 = v18 >> 3;
              while (1)
              {
                uint64_t v75 = *(void *)((char *)v55 + v73);
                uint64_t v76 = *(void *)(v72 + v73);
                if (v75 != v76) {
                  break;
                }
                v73 += 8;
                if (!--v74)
                {
                  uint64_t v77 = (unsigned __int8 *)v55 + v73;
                  goto LABEL_90;
                }
              }
              v73 += __clz(__rbit64(v76 ^ v75)) >> 3;
            }
            if (v73 >= 4)
            {
              unint64_t v78 = 135 * v73 - 30 * (__clz(v69) ^ 0x1F) + 1920;
              if (v63 < v78)
              {
                int v54 = *(unsigned __int8 *)(a3 + v73 + v53);
                unint64_t v50 = v73;
                unint64_t v64 = v69;
                unint64_t v63 = v78;
              }
            }
          }
          ++v65;
        }
        while (v65 != 4);
        *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v126.i64 + (v51 & 0x18))) = v51;
        if (v63 < v31 + 175) {
          break;
        }
        ++v12;
        if (v48 <= 2)
        {
          unint64_t v80 = v11 + 9;
          ++v48;
          unint64_t v125 = v64;
          unint64_t v31 = v63;
          unint64_t v26 = v50;
          ++v11;
          if (v80 < v122) {
            continue;
          }
        }
        goto LABEL_112;
      }
      unint64_t v64 = v125;
      unint64_t v50 = v26;
      unint64_t v51 = v11;
LABEL_112:
      unint64_t v84 = v124;
      if (v51 + v116 < v124) {
        unint64_t v84 = v51 + v116;
      }
      uint64_t i = v120;
      if (v64 > v84) {
        goto LABEL_115;
      }
      uint64_t v89 = *v120;
      if (v64 != v89) {
        break;
      }
      LOWORD(v85) = 0;
      LODWORD(v88) = 0;
      *(_DWORD *)uint64_t v119 = v12;
      *(_DWORD *)(v119 + 4) = v50;
LABEL_125:
      *(_WORD *)(v119 + 14) = v85;
      *(_DWORD *)(v119 + 8) = v88;
      unint64_t v13 = v122;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v94) = 22;
              }
              else {
                LOWORD(v94) = 23;
              }
            }
            else
            {
              LOWORD(v94) = 21;
            }
          }
          else
          {
            unsigned int v94 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v95 = (__clz(v12 - 2) ^ 0x1F) - 1;
          unsigned int v94 = ((v12 - 2) >> v95) + 2 * v95 + 2;
        }
      }
      else
      {
        LOWORD(v94) = v12;
      }
      unint64_t v102 = (unint64_t)v50 >> 1;
      if (v102 > 4)
      {
        if (v102 > 0x42)
        {
          if (v102 > 0x422) {
            LOWORD(v103) = 23;
          }
          else {
            unsigned int v103 = (__clz(v50 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v104 = (int)v50 - 6;
          unsigned int v105 = (__clz(v104) ^ 0x1F) - 1;
          unsigned int v103 = (v104 >> v105) + 2 * v105 + 4;
        }
      }
      else
      {
        LOWORD(v103) = v50 - 2;
      }
      int v106 = v103 & 7 | (8 * (v94 & 7));
      if ((v85 & 0x3FF) != 0 || (unsigned __int16)v94 > 7u || (unsigned __int16)v103 > 0xFu)
      {
        int v108 = 3 * ((unsigned __int16)v94 >> 3) + ((unsigned __int16)(v103 & 0xFFF8) >> 3);
        unsigned int v107 = ((((0x520D40u >> (2 * v108)) & 0xC0) + (v108 << 6)) | v106) + 64;
      }
      else
      {
        LOWORD(v107) = v106 | 0x40;
        if ((v103 & 0xFFF8) == 0) {
          LOWORD(v107) = v103 & 7 | (8 * (v94 & 7));
        }
      }
      *(_WORD *)(v119 + 12) = v107;
      *a11 += v12;
      unint64_t v109 = v51 + 2;
      unint64_t v82 = v51 + v50;
      unint64_t v110 = v118;
      if (v51 + v50 < v118) {
        unint64_t v110 = v51 + v50;
      }
      if (v64 < v50 >> 2)
      {
        if (v109 <= v82 - 4 * v64) {
          unint64_t v109 = v82 - 4 * v64;
        }
        if (v110 < v109) {
          unint64_t v109 = v110;
        }
      }
      unint64_t v16 = v117 + 2 * v50 + v51;
      v119 += 16;
      if (v109 < v110)
      {
        do
        {
          *(_DWORD *)(result
                    + 4
                    * (((((unint64_t)(0x35A7BD1E35A7BD00 * *(void *)(a3 + (v109 & a4))) >> 32) >> 12)
                      + (v109 & 0x18)) & 0xFFFFF)) = v109;
          ++v109;
        }
        while (v110 != v109);
      }
      unint64_t v12 = 0;
LABEL_172:
      unint64_t v11 = v82;
      if (v82 + 8 >= v13) {
        goto LABEL_185;
      }
    }
    uint64_t v97 = v120[1];
    if (v64 == v97)
    {
      unint64_t v85 = 1;
      goto LABEL_116;
    }
    unint64_t v98 = v64 + 3;
    unint64_t v99 = v64 + 3 - v89;
    if (v99 > 6)
    {
      if (v98 - v97 > 6)
      {
        if (v64 == v120[2])
        {
          unint64_t v85 = 2;
        }
        else if (v64 == v120[3])
        {
          unint64_t v85 = 3;
        }
        else
        {
LABEL_115:
          unint64_t v85 = v64 + 15;
        }
LABEL_116:
        if (v64 <= v84 && v85)
        {
          v120[3] = v120[2];
          *(void *)(v120 + 1) = *(void *)v120;
          *unint64_t v120 = v64;
        }
        *(_DWORD *)uint64_t v119 = v12;
        *(_DWORD *)(v119 + 4) = v50;
        uint64_t v86 = *(unsigned int *)(a5 + 68);
        uint64_t v87 = v86 + 16;
        if (v86 + 16 <= v85)
        {
          uint64_t v90 = *(unsigned int *)(a5 + 64);
          unint64_t v91 = v85 - v86 + (4 << v90) - 16;
          uint64_t v92 = (__clz(v91) ^ 0x1F) - 1;
          uint64_t v93 = ((v91 >> v92) & 1 | 2) << v92;
          unint64_t v85 = ((v91 & ~(-1 << v90)) + v87 + ((((v91 >> v92) & 1 | (2 * (v92 - v90))) + 65534) << v90)) | ((v92 - v90) << 10);
          unint64_t v88 = (v91 - v93) >> v90;
        }
        else
        {
          LODWORD(v88) = 0;
        }
        goto LABEL_125;
      }
      char v100 = 4 * (v98 - v97);
      unsigned int v101 = 266017486;
    }
    else
    {
      char v100 = 4 * v99;
      unsigned int v101 = 158663784;
    }
    unint64_t v85 = (v101 >> v100) & 0xF;
    goto LABEL_116;
  }
  uint64_t v119 = a9;
  unint64_t v82 = a2;
LABEL_185:
  *a8 = v12 + v13 - v82;
  *a10 += (v119 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH35(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v171 = *MEMORY[0x263EF8340];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v156 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v160 = v14;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v15 = 512;
  }
  else {
    uint64_t v15 = 64;
  }
  if (a2 + 8 < v13)
  {
    unint64_t v165 = (1 << *(_DWORD *)(a5 + 8)) - 16;
    unint64_t v164 = a7;
    uint64_t v158 = *(void *)(a5 + 16);
    unint64_t v16 = v15 + a2;
    uint64_t v155 = 4 * v15;
    char v157 = v13 - 1;
    uint64_t v17 = *(void *)(a6 + 56);
    uint64_t v18 = a9;
    uint64_t v168 = a6;
    unint64_t v162 = v13;
    uint64_t v159 = v15;
    while (1)
    {
      unint64_t v19 = v13 - v11;
      if (v11 >= v165) {
        unint64_t v20 = v165;
      }
      else {
        unint64_t v20 = v11;
      }
      unint64_t v21 = v11 & a4;
      int v22 = (void *)(a3 + (v11 & a4));
      int v23 = *(unsigned __int8 *)v22;
      unint64_t v24 = *a7;
      uint64_t v161 = v18;
      if (v11 < v24) {
        goto LABEL_22;
      }
      uint64_t v25 = (unsigned __int8 *)(a3 + (a4 & (v11 - v24)));
      if (v23 != *v25) {
        goto LABEL_22;
      }
      unint64_t v166 = *a7;
      if (v19 < 8)
      {
        unint64_t v27 = 0;
        unint64_t v28 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_249:
        unint64_t v152 = v19 & 7;
        if ((v19 & 7) != 0)
        {
          unint64_t v153 = v27 | v152;
          while (v25[v27] == *v28)
          {
            ++v28;
            ++v27;
            if (!--v152)
            {
              unint64_t v27 = v153;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v26 = 0;
        unint64_t v27 = v19 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v28 = (unsigned __int8 *)(a3 + v21 + (v19 & 0xFFFFFFFFFFFFFFF8));
        unint64_t v29 = v19 >> 3;
        while (1)
        {
          uint64_t v30 = v22[v26];
          uint64_t v31 = *(void *)&v25[v26 * 8];
          if (v30 != v31) {
            break;
          }
          ++v26;
          if (!--v29) {
            goto LABEL_249;
          }
        }
        unint64_t v27 = v26 * 8 + (__clz(__rbit64(v31 ^ v30)) >> 3);
      }
      if (v27 >= 4 && (unint64_t v32 = 135 * v27 + 1935, v32 >= 0x7E5))
      {
        int v23 = *(unsigned __int8 *)(a3 + v27 + v21);
      }
      else
      {
LABEL_22:
        unint64_t v166 = 0;
        unint64_t v27 = 0;
        unint64_t v32 = 2020;
      }
      uint64_t v33 = 0;
      unint64_t v169 = (0xBD1E35A7BD000000 * *v22) >> 48;
      uint64_t v170 = (unsigned __int16)(v169 + 8);
      char v34 = 1;
      do
      {
        char v35 = v34;
        uint64_t v36 = *(unsigned int *)(v17 + 4 * *(&v169 + v33));
        unint64_t v37 = v11 - v36;
        if (v23 == *(unsigned __int8 *)(a3 + (v36 & a4) + v27) && v11 != v36 && v37 <= v20)
        {
          uint64_t v40 = a3 + (v36 & a4);
          if (v19 < 8)
          {
            unint64_t v45 = 0;
            unint64_t v46 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            if ((v19 & 7) != 0)
            {
              unint64_t v48 = v19 & 7 | v45;
              unint64_t v49 = v19 & 7;
              while (*(unsigned __int8 *)(v40 + v45) == *v46)
              {
                ++v46;
                ++v45;
                if (!--v49)
                {
                  unint64_t v45 = v48;
                  break;
                }
              }
              a6 = v168;
            }
            else
            {
              a6 = v168;
            }
          }
          else
          {
            uint64_t v41 = 0;
            unint64_t v42 = v19 >> 3;
            while (1)
            {
              uint64_t v43 = v22[v41];
              uint64_t v44 = *(void *)(v40 + v41 * 8);
              if (v43 != v44) {
                break;
              }
              ++v41;
              if (!--v42)
              {
                unint64_t v45 = v19 & 0xFFFFFFFFFFFFFFF8;
                unint64_t v46 = (unsigned __int8 *)v22 + (v19 & 0xFFFFFFFFFFFFFFF8);
                goto LABEL_43;
              }
            }
            unint64_t v45 = v41 * 8 + (__clz(__rbit64(v44 ^ v43)) >> 3);
          }
          if (v45 >= 4)
          {
            unint64_t v47 = 135 * v45 - 30 * (__clz(v37) ^ 0x1F) + 1920;
            if (v32 < v47)
            {
              int v23 = *(unsigned __int8 *)(a3 + v45 + v21);
              unint64_t v166 = v37;
              unint64_t v32 = v47;
              unint64_t v27 = v45;
            }
          }
        }
        char v34 = 0;
        uint64_t v33 = 1;
      }
      while ((v35 & 1) != 0);
      *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v169 + (v11 & 8))) = v11;
      if ((v11 & 3) != 0)
      {
        unint64_t result = 0xBD1E35A7BD000000;
      }
      else
      {
        unint64_t result = 0xBD1E35A7BD000000;
        if (v19 >= 0x20)
        {
          unint64_t v50 = *(void *)(a6 + 80);
          if (v50 <= v11)
          {
            int v52 = *(_DWORD *)(a6 + 92);
            int v51 = *(_DWORD *)(a6 + 96);
            int v53 = *(_DWORD *)(a6 + 64);
            do
            {
              int v54 = *(unsigned __int8 *)(a3 + (v50 & a4));
              int v55 = *(unsigned __int8 *)(a3 + ((v50 + 32) & a4));
              if ((v53 & 0x3F000000) == 0)
              {
                uint64_t v56 = *(void *)(a6 + 72);
                uint64_t v57 = *(unsigned int *)(v56 + 4 * (v53 & 0x3FFFFFFF));
                *(_DWORD *)(v56 + 4 * (v53 & 0x3FFFFFFF)) = v50;
                if (v50 == v11 && v57 != -1)
                {
                  unint64_t v58 = (v11 - v57);
                  if (v20 >= v58)
                  {
                    uint64_t v59 = 0;
                    uint64_t v60 = a3 + (v57 & a4);
                    unint64_t v61 = v19 >> 3;
                    do
                    {
                      uint64_t v62 = v22[v59];
                      uint64_t v63 = *(void *)(v60 + v59 * 8);
                      if (v62 != v63)
                      {
                        unint64_t v64 = v59 * 8 + (__clz(__rbit64(v63 ^ v62)) >> 3);
                        goto LABEL_67;
                      }
                      ++v59;
                      --v61;
                    }
                    while (v61);
                    unint64_t v64 = v19 & 0xFFFFFFFFFFFFFFF8;
                    if ((v19 & 7) != 0)
                    {
                      unint64_t v65 = v19 & 7;
                      unint64_t v64 = v19 & 0xFFFFFFFFFFFFFFF8;
                      while (*(unsigned __int8 *)(v60 + v64) == *((unsigned __int8 *)v22 + v64))
                      {
                        ++v64;
                        if (!--v65)
                        {
                          unint64_t v64 = v13 - v11;
                          break;
                        }
                      }
                    }
LABEL_67:
                    unint64_t v66 = 135 * v64 - 30 * (__clz(v58) ^ 0x1F) + 1920;
                    unint64_t v67 = v166;
                    if (v66 > v32)
                    {
                      unint64_t v68 = v64;
                    }
                    else
                    {
                      unint64_t v58 = v166;
                      unint64_t v66 = v32;
                      unint64_t v68 = v27;
                    }
                    if (v64 <= v27)
                    {
                      unint64_t v58 = v166;
                      unint64_t v66 = v32;
                      unint64_t v68 = v27;
                    }
                    if (v64 >= 4) {
                      unint64_t v67 = v58;
                    }
                    unint64_t v166 = v67;
                    if (v64 >= 4)
                    {
                      unint64_t v32 = v66;
                      unint64_t v27 = v68;
                    }
                    a6 = v168;
                  }
                }
              }
              int v53 = v55 + v52 * v53 + v51 * ~v54 + 1;
              v50 += 4;
            }
            while (v50 <= v11);
            *(_DWORD *)(a6 + 64) = v53;
            unint64_t result = 0xBD1E35A7BD000000;
          }
          *(void *)(a6 + 80) = v11 + 4;
        }
      }
      if (v32 < 0x7E5)
      {
        ++v12;
        unint64_t v123 = v11 + 1;
        uint64_t v18 = v161;
        if (v11 + 1 <= v16)
        {
          a7 = v164;
        }
        else
        {
          a7 = v164;
          if (v123 <= v16 + v155)
          {
            unint64_t v137 = v11 + 9;
            if (v137 >= v156) {
              unint64_t v137 = v156;
            }
            while (v123 < v137)
            {
              *(_DWORD *)(v17
                        + 4
                        * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)(a3 + (v123 & a4))) >> 48) + (v123 & 8))) = v123;
              v12 += 2;
              v123 += 2;
            }
          }
          else
          {
            unint64_t v124 = v11 + 17;
            if (v124 >= v156) {
              unint64_t v124 = v156;
            }
            while (v123 < v124)
            {
              *(_DWORD *)(v17
                        + 4
                        * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)(a3 + (v123 & a4))) >> 48) + (v123 & 8))) = v123;
              v12 += 4;
              v123 += 4;
            }
          }
        }
        goto LABEL_242;
      }
      unsigned int v69 = 0;
      char v70 = v157 - v11;
      while (1)
      {
        --v19;
        unint64_t v71 = v27 - 1;
        if (v27 - 1 >= v19) {
          unint64_t v71 = v19;
        }
        unint64_t v72 = *(int *)(a5 + 4) >= 5 ? 0 : v71;
        unint64_t v73 = v11 + 1;
        uint64_t v74 = (v11 + 1) & a4;
        int v75 = *(unsigned __int8 *)(a3 + v72 + v74);
        unint64_t v76 = v11 + 1 < v165 ? v11 + 1 : v165;
        uint64_t v77 = (void *)(a3 + v74);
        unint64_t v78 = *v164;
        if (v73 < v78) {
          goto LABEL_102;
        }
        unint64_t v79 = a4 & (v73 - v78);
        if (v75 != *(unsigned __int8 *)(a3 + v79 + v72)) {
          goto LABEL_102;
        }
        uint64_t v80 = a3 + v79;
        if (v19 < 8)
        {
          unint64_t v81 = 0;
          unint64_t v85 = (unsigned __int8 *)(a3 + v74);
LABEL_170:
          unint64_t v122 = v19 & 7;
          if ((v19 & 7) != 0)
          {
            do
            {
              if (*(unsigned __int8 *)(v80 + v81) != *v85) {
                break;
              }
              ++v85;
              ++v81;
              --v122;
            }
            while (v122);
          }
        }
        else
        {
          unint64_t v81 = 0;
          unint64_t v82 = v19 >> 3;
          while (1)
          {
            uint64_t v83 = *(void *)((char *)v77 + v81);
            uint64_t v84 = *(void *)(v80 + v81);
            if (v83 != v84) {
              break;
            }
            v81 += 8;
            if (!--v82)
            {
              unint64_t v85 = (unsigned __int8 *)v77 + v81;
              goto LABEL_170;
            }
          }
          v81 += __clz(__rbit64(v84 ^ v83)) >> 3;
        }
        if (v81 >= 4 && (unint64_t v86 = 135 * v81 + 1935, v86 >= 0x7E5))
        {
          int v75 = *(unsigned __int8 *)(a3 + v81 + v74);
          unint64_t v72 = v81;
        }
        else
        {
LABEL_102:
          unint64_t v78 = 0;
          unint64_t v86 = 2020;
        }
        uint64_t v87 = 0;
        uint64_t v167 = v70 & 7;
        unint64_t v169 = (0xBD1E35A7BD000000 * *v77) >> 48;
        uint64_t v170 = (unsigned __int16)(v169 + 8);
        char v88 = 1;
        do
        {
          char v89 = v88;
          uint64_t v90 = *(unsigned int *)(v17 + 4 * *(&v169 + v87));
          unint64_t v91 = v73 - v90;
          if (v75 == *(unsigned __int8 *)(a3 + (v90 & a4) + v72) && v73 != v90 && v91 <= v76)
          {
            uint64_t v94 = a3 + (v90 & a4);
            if (v19 < 8)
            {
              unint64_t v95 = 0;
              unint64_t v99 = (unsigned __int8 *)(a3 + v74);
LABEL_123:
              unint64_t v101 = v19 & 7;
              if ((v19 & 7) != 0)
              {
                do
                {
                  if (*(unsigned __int8 *)(v94 + v95) != *v99) {
                    break;
                  }
                  ++v99;
                  ++v95;
                  --v101;
                }
                while (v101);
              }
            }
            else
            {
              unint64_t v95 = 0;
              unint64_t v96 = v19 >> 3;
              while (1)
              {
                uint64_t v97 = *(void *)((char *)v77 + v95);
                uint64_t v98 = *(void *)(v94 + v95);
                if (v97 != v98) {
                  break;
                }
                v95 += 8;
                if (!--v96)
                {
                  unint64_t v99 = (unsigned __int8 *)v77 + v95;
                  goto LABEL_123;
                }
              }
              v95 += __clz(__rbit64(v98 ^ v97)) >> 3;
            }
            if (v95 >= 4)
            {
              unint64_t v100 = 135 * v95 - 30 * (__clz(v91) ^ 0x1F) + 1920;
              if (v86 < v100)
              {
                int v75 = *(unsigned __int8 *)(a3 + v95 + v74);
                unint64_t v72 = v95;
                unint64_t v78 = v91;
                unint64_t v86 = v100;
              }
            }
          }
          char v88 = 0;
          uint64_t v87 = 1;
        }
        while ((v89 & 1) != 0);
        *(_DWORD *)(v17 + 4 * *(unint64_t *)((char *)&v169 + (v73 & 8))) = v73;
        if (v19 < 0x20)
        {
          a6 = v168;
        }
        else
        {
          a6 = v168;
          if ((v73 & 3) == 0)
          {
            unint64_t v102 = *(void *)(v168 + 80);
            if (v102 <= v73)
            {
              int v103 = *(_DWORD *)(v168 + 92);
              int v104 = *(_DWORD *)(v168 + 96);
              int v105 = *(_DWORD *)(v168 + 64);
              do
              {
                int v106 = *(unsigned __int8 *)(a3 + (v102 & a4));
                int v107 = *(unsigned __int8 *)(a3 + ((v102 + 32) & a4));
                if ((v105 & 0x3F000000) == 0)
                {
                  uint64_t v108 = *(void *)(v168 + 72);
                  uint64_t v109 = *(unsigned int *)(v108 + 4 * (v105 & 0x3FFFFFFF));
                  *(_DWORD *)(v108 + 4 * (v105 & 0x3FFFFFFF)) = v102;
                  if (v102 == v73 && v109 != -1)
                  {
                    unint64_t v110 = (v73 - v109);
                    if (v76 >= v110)
                    {
                      unint64_t v111 = 0;
                      uint64_t v112 = a3 + (v109 & a4);
                      unint64_t v113 = v19 >> 3;
                      do
                      {
                        uint64_t v114 = *(void *)((char *)v77 + v111);
                        uint64_t v115 = *(void *)(v112 + v111);
                        if (v114 != v115)
                        {
                          v111 += __clz(__rbit64(v115 ^ v114)) >> 3;
                          goto LABEL_144;
                        }
                        v111 += 8;
                        --v113;
                      }
                      while (v113);
                      if ((v19 & 7) != 0)
                      {
                        uint64_t v116 = 0;
                        uint64_t v117 = v112 + v111;
                        do
                        {
                          if (*(unsigned __int8 *)(v117 + v116) != *((unsigned __int8 *)v77 + v111 + v116)) {
                            break;
                          }
                          ++v116;
                        }
                        while (v167 != v116);
                        v111 += v116;
                      }
LABEL_144:
                      unint64_t v118 = 135 * v111 - 30 * (__clz(v110) ^ 0x1F) + 1920;
                      if (v118 > v86) {
                        unint64_t v119 = v111;
                      }
                      else {
                        unint64_t v119 = v72;
                      }
                      if (v118 <= v86)
                      {
                        unint64_t v110 = v78;
                        unint64_t v118 = v86;
                      }
                      BOOL v120 = v111 >= 4 && v111 > v72;
                      if (v120) {
                        unint64_t v72 = v119;
                      }
                      if (v120) {
                        unint64_t v78 = v110;
                      }
                      if (v120) {
                        unint64_t v86 = v118;
                      }
                    }
                  }
                }
                int v105 = v107 + v103 * v105 + v104 * ~v106 + 1;
                v102 += 4;
              }
              while (v102 <= v73);
              a6 = v168;
              *(_DWORD *)(v168 + 64) = v105;
            }
            *(void *)(a6 + 80) = v11 + 5;
          }
        }
        if (v86 < v32 + 175) {
          break;
        }
        ++v12;
        if (v69 <= 2)
        {
          unint64_t v121 = v11 + 9;
          ++v69;
          char v70 = v167 + 7;
          unint64_t v166 = v78;
          unint64_t v32 = v86;
          unint64_t v27 = v72;
          ++v11;
          if (v121 < v162) {
            continue;
          }
        }
        goto LABEL_181;
      }
      unint64_t v78 = v166;
      unint64_t v72 = v27;
      unint64_t v73 = v11;
LABEL_181:
      a7 = v164;
      unint64_t v125 = v165;
      if (v73 + v158 < v165) {
        unint64_t v125 = v73 + v158;
      }
      if (v78 > v125) {
        goto LABEL_184;
      }
      uint64_t v130 = *v164;
      if (v78 != v130) {
        break;
      }
      LOWORD(v126) = 0;
      LODWORD(v129) = 0;
      *(_DWORD *)uint64_t v161 = v12;
      *(_DWORD *)(v161 + 4) = v72;
      unint64_t result = 0xBD1E35A7BD000000;
LABEL_194:
      *(_WORD *)(v161 + 14) = v126;
      *(_DWORD *)(v161 + 8) = v129;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v135) = 22;
              }
              else {
                LOWORD(v135) = 23;
              }
            }
            else
            {
              LOWORD(v135) = 21;
            }
          }
          else
          {
            unsigned int v135 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v136 = (__clz(v12 - 2) ^ 0x1F) - 1;
          unsigned int v135 = ((v12 - 2) >> v136) + 2 * v136 + 2;
        }
      }
      else
      {
        LOWORD(v135) = v12;
      }
      unint64_t v143 = (unint64_t)v72 >> 1;
      if (v143 > 4)
      {
        if (v143 > 0x42)
        {
          if (v143 > 0x422) {
            LOWORD(v144) = 23;
          }
          else {
            unsigned int v144 = (__clz(v72 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v145 = (int)v72 - 6;
          unsigned int v146 = (__clz(v145) ^ 0x1F) - 1;
          unsigned int v144 = (v145 >> v146) + 2 * v146 + 4;
        }
      }
      else
      {
        LOWORD(v144) = v72 - 2;
      }
      int v147 = v144 & 7 | (8 * (v135 & 7));
      if ((v126 & 0x3FF) != 0 || (unsigned __int16)v135 > 7u || (unsigned __int16)v144 > 0xFu)
      {
        int v149 = 3 * ((unsigned __int16)v135 >> 3) + ((unsigned __int16)(v144 & 0xFFF8) >> 3);
        unsigned int v148 = ((((0x520D40u >> (2 * v149)) & 0xC0) + (v149 << 6)) | v147) + 64;
      }
      else
      {
        LOWORD(v148) = v147 | 0x40;
        if ((v144 & 0xFFF8) == 0) {
          LOWORD(v148) = v144 & 7 | (8 * (v135 & 7));
        }
      }
      *(_WORD *)(v161 + 12) = v148;
      *a11 += v12;
      unint64_t v150 = v73 + 2;
      unint64_t v123 = v73 + v72;
      unint64_t v151 = v160;
      if (v73 + v72 < v160) {
        unint64_t v151 = v73 + v72;
      }
      if (v78 < v72 >> 2)
      {
        if (v150 <= v123 - 4 * v78) {
          unint64_t v150 = v123 - 4 * v78;
        }
        if (v151 < v150) {
          unint64_t v150 = v151;
        }
      }
      unint64_t v16 = v159 + 2 * v72 + v73;
      uint64_t v18 = v161 + 16;
      if (v150 >= v151)
      {
        unint64_t v12 = 0;
        unint64_t v13 = v162;
      }
      else
      {
        unint64_t v13 = v162;
        do
        {
          *(_DWORD *)(v17
                    + 4
                    * (unsigned __int16)(((0xBD1E35A7BD000000 * *(void *)(a3 + (v150 & a4))) >> 48) + (v150 & 8))) = v150;
          ++v150;
        }
        while (v151 != v150);
        unint64_t v12 = 0;
      }
LABEL_242:
      unint64_t v11 = v123;
      if (v123 + 8 >= v13) {
        goto LABEL_255;
      }
    }
    uint64_t v138 = v164[1];
    if (v78 == v138)
    {
      unint64_t v126 = 1;
      goto LABEL_185;
    }
    unint64_t v139 = v78 + 3;
    unint64_t v140 = v78 + 3 - v130;
    if (v140 > 6)
    {
      if (v139 - v138 > 6)
      {
        if (v78 == v164[2])
        {
          unint64_t v126 = 2;
        }
        else if (v78 == v164[3])
        {
          unint64_t v126 = 3;
        }
        else
        {
LABEL_184:
          unint64_t v126 = v78 + 15;
        }
LABEL_185:
        if (v78 <= v125 && v126)
        {
          v164[3] = v164[2];
          *(void *)(v164 + 1) = *(void *)v164;
          *unint64_t v164 = v78;
        }
        *(_DWORD *)uint64_t v161 = v12;
        *(_DWORD *)(v161 + 4) = v72;
        uint64_t v127 = *(unsigned int *)(a5 + 68);
        uint64_t v128 = v127 + 16;
        unint64_t result = 0xBD1E35A7BD000000;
        if (v127 + 16 <= v126)
        {
          uint64_t v131 = *(unsigned int *)(a5 + 64);
          unint64_t v132 = v126 - v127 + (4 << v131) - 16;
          uint64_t v133 = (__clz(v132) ^ 0x1F) - 1;
          uint64_t v134 = ((v132 >> v133) & 1 | 2) << v133;
          unint64_t v126 = ((v132 & ~(-1 << v131))
                + v128
                + ((((v132 >> v133) & 1 | (2 * (v133 - v131))) + 65534) << v131)) | ((v133 - v131) << 10);
          unint64_t v129 = (v132 - v134) >> v131;
        }
        else
        {
          LODWORD(v129) = 0;
        }
        goto LABEL_194;
      }
      char v141 = 4 * (v139 - v138);
      unsigned int v142 = 266017486;
    }
    else
    {
      char v141 = 4 * v140;
      unsigned int v142 = 158663784;
    }
    unint64_t v126 = (v142 >> v141) & 0xF;
    goto LABEL_185;
  }
  uint64_t v18 = a9;
  unint64_t v123 = a2;
LABEL_255:
  *a8 = v12 + v13 - v123;
  *a10 += (v18 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH55(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, uint64_t a9, void *a10, void *a11)
{
  unint64_t v11 = a2;
  uint64_t v171 = *MEMORY[0x263EF8340];
  unint64_t v12 = *a8;
  unint64_t v13 = a2 + result;
  uint64_t v14 = a2 + result - 7;
  unint64_t v155 = v14;
  if (result <= 7) {
    uint64_t v14 = a2;
  }
  unint64_t v159 = v14;
  if (*(int *)(a5 + 4) >= 9) {
    uint64_t v15 = 512;
  }
  else {
    uint64_t v15 = 64;
  }
  if (a2 + 8 < v13)
  {
    uint64_t v158 = v15;
    unint64_t v165 = (1 << *(_DWORD *)(a5 + 8)) - 16;
    uint64_t v157 = *(void *)(a5 + 16);
    unint64_t v16 = v15 + a2;
    unint64_t result = *(void *)(a6 + 56);
    uint64_t v154 = 4 * v15;
    char v156 = v13 - 1;
    int8x16_t v17 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
    unint64_t v160 = a7;
    uint64_t v161 = a9;
    uint64_t v168 = a6;
    unint64_t v162 = v13;
    while (1)
    {
      unint64_t v18 = v13 - v11;
      if (v11 >= v165) {
        unint64_t v19 = v165;
      }
      else {
        unint64_t v19 = v11;
      }
      unint64_t v20 = v11 & a4;
      unint64_t v21 = (void *)(a3 + (v11 & a4));
      int v22 = *(unsigned __int8 *)v21;
      unint64_t v23 = *a7;
      if (v11 < v23) {
        goto LABEL_22;
      }
      unint64_t v24 = (unsigned __int8 *)(a3 + (a4 & (v11 - v23)));
      if (v22 != *v24) {
        goto LABEL_22;
      }
      if (v18 < 8)
      {
        unint64_t v26 = 0;
        unint64_t v27 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_253:
        unint64_t v151 = v18 & 7;
        if ((v18 & 7) != 0)
        {
          unint64_t v152 = v26 | v151;
          while (v24[v26] == *v27)
          {
            ++v27;
            ++v26;
            if (!--v151)
            {
              unint64_t v26 = v152;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v25 = 0;
        unint64_t v26 = v18 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v27 = (unsigned __int8 *)(a3 + v20 + (v18 & 0xFFFFFFFFFFFFFFF8));
        unint64_t v28 = v18 >> 3;
        while (1)
        {
          uint64_t v29 = v21[v25];
          uint64_t v30 = *(void *)&v24[v25 * 8];
          if (v29 != v30) {
            break;
          }
          ++v25;
          if (!--v28) {
            goto LABEL_253;
          }
        }
        unint64_t v26 = v25 * 8 + (__clz(__rbit64(v30 ^ v29)) >> 3);
      }
      if (v26 >= 4 && (v166 = *a7, unint64_t v31 = 135 * v26 + 1935, v31 >= 0x7E5))
      {
        int v22 = *(unsigned __int8 *)(a3 + v26 + v20);
      }
      else
      {
LABEL_22:
        unint64_t v166 = 0;
        unint64_t v26 = 0;
        unint64_t v31 = 2020;
      }
      uint64_t v32 = 0;
      int64x2_t v33 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00 * *v21) >> 44);
      int8x16_t v169 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_20DB0A590), v17);
      int8x16_t v170 = vandq_s8((int8x16_t)vaddq_s64(v33, (int64x2_t)xmmword_20DB0A5A0), v17);
      do
      {
        uint64_t v34 = *(unsigned int *)(result + 4 * v169.i64[v32]);
        unint64_t v35 = v11 - v34;
        if (v22 == *(unsigned __int8 *)(a3 + (v34 & a4) + v26) && v11 != v34 && v35 <= v19)
        {
          uint64_t v38 = a3 + (v34 & a4);
          if (v18 < 8)
          {
            unint64_t v43 = 0;
            uint64_t v44 = (unsigned __int8 *)(a3 + (v11 & a4));
LABEL_43:
            if ((v18 & 7) != 0)
            {
              unint64_t v46 = v18 & 7 | v43;
              unint64_t v47 = v18 & 7;
              while (*(unsigned __int8 *)(v38 + v43) == *v44)
              {
                ++v44;
                ++v43;
                if (!--v47)
                {
                  unint64_t v43 = v46;
                  break;
                }
              }
              a7 = v160;
              a6 = v168;
              unint64_t v13 = v162;
            }
            else
            {
              a6 = v168;
            }
          }
          else
          {
            uint64_t v39 = 0;
            unint64_t v40 = v18 >> 3;
            while (1)
            {
              uint64_t v41 = v21[v39];
              uint64_t v42 = *(void *)(v38 + v39 * 8);
              if (v41 != v42) {
                break;
              }
              ++v39;
              if (!--v40)
              {
                unint64_t v43 = v18 & 0xFFFFFFFFFFFFFFF8;
                uint64_t v44 = (unsigned __int8 *)v21 + (v18 & 0xFFFFFFFFFFFFFFF8);
                goto LABEL_43;
              }
            }
            unint64_t v43 = v39 * 8 + (__clz(__rbit64(v42 ^ v41)) >> 3);
          }
          if (v43 >= 4)
          {
            unsigned int v45 = __clz(v35);
            if (v31 < 135 * v43 - 30 * (v45 ^ 0x1F) + 1920)
            {
              int v22 = *(unsigned __int8 *)(a3 + v43 + v20);
              unint64_t v166 = v35;
              unint64_t v31 = 135 * v43 - 30 * (v45 ^ 0x1F) + 1920;
              unint64_t v26 = v43;
            }
          }
        }
        ++v32;
      }
      while (v32 != 4);
      *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v169.i64 + (v11 & 0x18))) = v11;
      if ((v11 & 3) == 0 && v18 >= 0x20)
      {
        unint64_t v48 = *(void *)(a6 + 80);
        if (v48 <= v11)
        {
          int v49 = *(_DWORD *)(a6 + 92);
          int v50 = *(_DWORD *)(a6 + 96);
          int v51 = *(_DWORD *)(a6 + 64);
          do
          {
            int v52 = *(unsigned __int8 *)(a3 + (v48 & a4));
            int v53 = *(unsigned __int8 *)(a3 + ((v48 + 32) & a4));
            if ((v51 & 0x3F000000) == 0)
            {
              uint64_t v54 = *(void *)(a6 + 72);
              uint64_t v55 = *(unsigned int *)(v54 + 4 * (v51 & 0x3FFFFFFF));
              *(_DWORD *)(v54 + 4 * (v51 & 0x3FFFFFFF)) = v48;
              if (v48 == v11 && v55 != -1)
              {
                unint64_t v56 = (v11 - v55);
                if (v19 >= v56)
                {
                  uint64_t v57 = 0;
                  uint64_t v58 = a3 + (v55 & a4);
                  unint64_t v59 = v18 >> 3;
                  do
                  {
                    uint64_t v60 = v21[v57];
                    uint64_t v61 = *(void *)(v58 + v57 * 8);
                    if (v60 != v61)
                    {
                      unint64_t v62 = v57 * 8 + (__clz(__rbit64(v61 ^ v60)) >> 3);
                      goto LABEL_68;
                    }
                    ++v57;
                    --v59;
                  }
                  while (v59);
                  unint64_t v62 = v18 & 0xFFFFFFFFFFFFFFF8;
                  if ((v18 & 7) != 0)
                  {
                    unint64_t v63 = v18 & 7;
                    unint64_t v62 = v18 & 0xFFFFFFFFFFFFFFF8;
                    while (*(unsigned __int8 *)(v58 + v62) == *((unsigned __int8 *)v21 + v62))
                    {
                      ++v62;
                      if (!--v63)
                      {
                        unint64_t v62 = v18;
                        break;
                      }
                    }
                    a7 = v160;
                  }
LABEL_68:
                  unint64_t v64 = 135 * v62 - 30 * (__clz(v56) ^ 0x1F) + 1920;
                  unint64_t v65 = v166;
                  if (v64 > v31) {
                    unint64_t v66 = v56;
                  }
                  else {
                    unint64_t v66 = v166;
                  }
                  if (v64 > v31)
                  {
                    unint64_t v67 = v62;
                  }
                  else
                  {
                    unint64_t v64 = v31;
                    unint64_t v67 = v26;
                  }
                  if (v62 <= v26)
                  {
                    unint64_t v66 = v166;
                    unint64_t v64 = v31;
                    unint64_t v67 = v26;
                  }
                  if (v62 >= 4) {
                    unint64_t v65 = v66;
                  }
                  unint64_t v166 = v65;
                  if (v62 >= 4)
                  {
                    unint64_t v31 = v64;
                    unint64_t v26 = v67;
                  }
                  a6 = v168;
                }
              }
            }
            int v51 = v53 + v49 * v51 + v50 * ~v52 + 1;
            v48 += 4;
          }
          while (v48 <= v11);
          *(_DWORD *)(a6 + 64) = v51;
          unint64_t v13 = v162;
        }
        *(void *)(a6 + 80) = v11 + 4;
      }
      if (v31 < 0x7E5)
      {
        ++v12;
        unint64_t v122 = v11 + 1;
        if (v11 + 1 > v16)
        {
          if (v122 <= v16 + v154)
          {
            unint64_t v136 = v11 + 9;
            if (v11 + 9 >= v155) {
              unint64_t v136 = v155;
            }
            for (; v122 < v136; v122 += 2)
            {
              *(_DWORD *)(result
                        + 4
                        * (((((unint64_t)(0x35A7BD1E35A7BD00 * *(void *)(a3 + (v122 & a4))) >> 32) >> 12)
                          + (v122 & 0x18)) & 0xFFFFF)) = v122;
              v12 += 2;
            }
          }
          else
          {
            unint64_t v123 = v11 + 17;
            if (v11 + 17 >= v155) {
              unint64_t v123 = v155;
            }
            for (; v122 < v123; v122 += 4)
            {
              *(_DWORD *)(result
                        + 4
                        * (((((unint64_t)(0x35A7BD1E35A7BD00 * *(void *)(a3 + (v122 & a4))) >> 32) >> 12)
                          + (v122 & 0x18)) & 0xFFFFF)) = v122;
              v12 += 4;
            }
          }
        }
        goto LABEL_246;
      }
      unsigned int v68 = 0;
      unint64_t v164 = *a7;
      char v69 = v156 - v11;
      while (1)
      {
        --v18;
        unint64_t v70 = v26 - 1;
        if (v26 - 1 >= v18) {
          unint64_t v70 = v18;
        }
        unint64_t v71 = *(int *)(a5 + 4) >= 5 ? 0 : v70;
        unint64_t v72 = v11 + 1;
        unint64_t v73 = v11 + 1 < v165 ? v11 + 1 : v165;
        unint64_t v74 = v72 & a4;
        int v75 = *(unsigned __int8 *)(a3 + v71 + (v72 & a4));
        unint64_t v76 = (void *)(a3 + (v72 & a4));
        if (v72 < v164) {
          goto LABEL_105;
        }
        unint64_t v77 = a4 & (v72 - v164);
        if (v75 != *(unsigned __int8 *)(a3 + v77 + v71)) {
          goto LABEL_105;
        }
        uint64_t v78 = a3 + v77;
        if (v18 < 8)
        {
          unint64_t v79 = 0;
          uint64_t v83 = (unsigned __int8 *)(a3 + (v72 & a4));
LABEL_173:
          unint64_t v121 = v18 & 7;
          if ((v18 & 7) != 0)
          {
            do
            {
              if (*(unsigned __int8 *)(v78 + v79) != *v83) {
                break;
              }
              ++v83;
              ++v79;
              --v121;
            }
            while (v121);
          }
        }
        else
        {
          unint64_t v79 = 0;
          unint64_t v80 = v18 >> 3;
          while (1)
          {
            uint64_t v81 = *(void *)((char *)v76 + v79);
            uint64_t v82 = *(void *)(v78 + v79);
            if (v81 != v82) {
              break;
            }
            v79 += 8;
            if (!--v80)
            {
              uint64_t v83 = (unsigned __int8 *)v76 + v79;
              goto LABEL_173;
            }
          }
          v79 += __clz(__rbit64(v82 ^ v81)) >> 3;
        }
        if (v79 >= 4 && (unint64_t v84 = 135 * v79 + 1935, v84 >= 0x7E5))
        {
          int v75 = *(unsigned __int8 *)(a3 + v79 + v74);
          unint64_t v71 = v79;
          unint64_t v85 = v164;
        }
        else
        {
LABEL_105:
          unint64_t v85 = 0;
          unint64_t v84 = 2020;
        }
        uint64_t v86 = 0;
        uint64_t v167 = v69 & 7;
        int64x2_t v87 = vdupq_n_s64((unint64_t)(0x35A7BD1E35A7BD00 * *v76) >> 44);
        int8x16_t v88 = (int8x16_t)vdupq_n_s64(0xFFFFFuLL);
        int8x16_t v169 = vandq_s8((int8x16_t)vaddq_s64(v87, (int64x2_t)xmmword_20DB0A590), v88);
        int8x16_t v170 = vandq_s8((int8x16_t)vaddq_s64(v87, (int64x2_t)xmmword_20DB0A5A0), v88);
        do
        {
          uint64_t v89 = *(unsigned int *)(result + 4 * v169.i64[v86]);
          unint64_t v90 = v72 - v89;
          if (v75 == *(unsigned __int8 *)(a3 + (v89 & a4) + v71) && v72 != v89 && v90 <= v73)
          {
            uint64_t v93 = a3 + (v89 & a4);
            if (v18 < 8)
            {
              unint64_t v94 = 0;
              uint64_t v98 = (unsigned __int8 *)(a3 + (v72 & a4));
LABEL_126:
              unint64_t v100 = v18 & 7;
              if ((v18 & 7) != 0)
              {
                do
                {
                  if (*(unsigned __int8 *)(v93 + v94) != *v98) {
                    break;
                  }
                  ++v98;
                  ++v94;
                  --v100;
                }
                while (v100);
              }
            }
            else
            {
              unint64_t v94 = 0;
              unint64_t v95 = v18 >> 3;
              while (1)
              {
                uint64_t v96 = *(void *)((char *)v76 + v94);
                uint64_t v97 = *(void *)(v93 + v94);
                if (v96 != v97) {
                  break;
                }
                v94 += 8;
                if (!--v95)
                {
                  uint64_t v98 = (unsigned __int8 *)v76 + v94;
                  goto LABEL_126;
                }
              }
              v94 += __clz(__rbit64(v97 ^ v96)) >> 3;
            }
            if (v94 >= 4)
            {
              unsigned int v99 = __clz(v90) ^ 0x1F;
              if (v84 < 135 * v94 - 30 * v99 + 1920)
              {
                int v75 = *(unsigned __int8 *)(a3 + v94 + v74);
                unint64_t v71 = v94;
                unint64_t v85 = v90;
                unint64_t v84 = 135 * v94 - 30 * v99 + 1920;
              }
            }
          }
          ++v86;
        }
        while (v86 != 4);
        *(_DWORD *)(result + 4 * *(uint64_t *)((char *)v169.i64 + (v72 & 0x18))) = v72;
        if (v18 < 0x20)
        {
          a6 = v168;
        }
        else
        {
          a6 = v168;
          if ((v72 & 3) == 0)
          {
            unint64_t v101 = *(void *)(v168 + 80);
            if (v101 <= v72)
            {
              int v102 = *(_DWORD *)(v168 + 92);
              int v103 = *(_DWORD *)(v168 + 96);
              int v104 = *(_DWORD *)(v168 + 64);
              do
              {
                int v105 = *(unsigned __int8 *)(a3 + (v101 & a4));
                int v106 = *(unsigned __int8 *)(a3 + ((v101 + 32) & a4));
                if ((v104 & 0x3F000000) == 0)
                {
                  uint64_t v107 = *(void *)(v168 + 72);
                  uint64_t v108 = *(unsigned int *)(v107 + 4 * (v104 & 0x3FFFFFFF));
                  *(_DWORD *)(v107 + 4 * (v104 & 0x3FFFFFFF)) = v101;
                  if (v101 == v72 && v108 != -1)
                  {
                    unint64_t v109 = (v72 - v108);
                    if (v73 >= v109)
                    {
                      unint64_t v110 = 0;
                      uint64_t v111 = a3 + (v108 & a4);
                      unint64_t v112 = v18 >> 3;
                      do
                      {
                        uint64_t v113 = *(void *)((char *)v76 + v110);
                        uint64_t v114 = *(void *)(v111 + v110);
                        if (v113 != v114)
                        {
                          v110 += __clz(__rbit64(v114 ^ v113)) >> 3;
                          goto LABEL_147;
                        }
                        v110 += 8;
                        --v112;
                      }
                      while (v112);
                      if ((v18 & 7) != 0)
                      {
                        uint64_t v115 = 0;
                        uint64_t v116 = v111 + v110;
                        do
                        {
                          if (*(unsigned __int8 *)(v116 + v115) != *((unsigned __int8 *)v76 + v110 + v115)) {
                            break;
                          }
                          ++v115;
                        }
                        while (v167 != v115);
                        v110 += v115;
                      }
LABEL_147:
                      unint64_t v117 = 135 * v110 - 30 * (__clz(v109) ^ 0x1F) + 1920;
                      if (v117 > v84) {
                        unint64_t v118 = v110;
                      }
                      else {
                        unint64_t v118 = v71;
                      }
                      if (v117 <= v84)
                      {
                        unint64_t v109 = v85;
                        unint64_t v117 = v84;
                      }
                      BOOL v119 = v110 >= 4 && v110 > v71;
                      if (v119) {
                        unint64_t v71 = v118;
                      }
                      if (v119) {
                        unint64_t v85 = v109;
                      }
                      if (v119) {
                        unint64_t v84 = v117;
                      }
                    }
                  }
                }
                int v104 = v106 + v102 * v104 + v103 * ~v105 + 1;
                v101 += 4;
              }
              while (v101 <= v72);
              a6 = v168;
              *(_DWORD *)(v168 + 64) = v104;
            }
            *(void *)(a6 + 80) = v11 + 5;
          }
        }
        if (v84 < v31 + 175) {
          break;
        }
        ++v12;
        if (v68 <= 2)
        {
          unint64_t v120 = v11 + 9;
          ++v68;
          char v69 = v167 + 7;
          unint64_t v166 = v85;
          unint64_t v31 = v84;
          unint64_t v26 = v71;
          ++v11;
          if (v120 < v162) {
            continue;
          }
        }
        goto LABEL_185;
      }
      unint64_t v85 = v166;
      unint64_t v71 = v26;
      unint64_t v72 = v11;
LABEL_185:
      unint64_t v124 = v165;
      if (v72 + v157 < v165) {
        unint64_t v124 = v72 + v157;
      }
      if (v85 > v124) {
        goto LABEL_188;
      }
      uint64_t v129 = *v160;
      if (v85 != v129) {
        break;
      }
      LOWORD(v125) = 0;
      LODWORD(v128) = 0;
      *(_DWORD *)uint64_t v161 = v12;
      *(_DWORD *)(v161 + 4) = v71;
LABEL_197:
      *(_WORD *)(v161 + 14) = v125;
      *(_DWORD *)(v161 + 8) = v128;
      if (v12 > 5)
      {
        if (v12 > 0x81)
        {
          if (v12 > 0x841)
          {
            if (v12 >> 1 >= 0xC21)
            {
              if (v12 < 0x5842) {
                LOWORD(v134) = 22;
              }
              else {
                LOWORD(v134) = 23;
              }
            }
            else
            {
              LOWORD(v134) = 21;
            }
          }
          else
          {
            unsigned int v134 = (__clz(v12 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v135 = (__clz(v12 - 2) ^ 0x1F) - 1;
          unsigned int v134 = ((v12 - 2) >> v135) + 2 * v135 + 2;
        }
      }
      else
      {
        LOWORD(v134) = v12;
      }
      unint64_t v142 = (unint64_t)v71 >> 1;
      if (v142 > 4)
      {
        if (v142 > 0x42)
        {
          if (v142 > 0x422) {
            LOWORD(v143) = 23;
          }
          else {
            unsigned int v143 = (__clz(v71 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v144 = (int)v71 - 6;
          unsigned int v145 = (__clz(v144) ^ 0x1F) - 1;
          unsigned int v143 = (v144 >> v145) + 2 * v145 + 4;
        }
      }
      else
      {
        LOWORD(v143) = v71 - 2;
      }
      int v146 = v143 & 7 | (8 * (v134 & 7));
      if ((v125 & 0x3FF) != 0 || (unsigned __int16)v134 > 7u || (unsigned __int16)v143 > 0xFu)
      {
        int v148 = 3 * ((unsigned __int16)v134 >> 3) + ((unsigned __int16)(v143 & 0xFFF8) >> 3);
        unsigned int v147 = ((((0x520D40u >> (2 * v148)) & 0xC0) + (v148 << 6)) | v146) + 64;
      }
      else
      {
        LOWORD(v147) = v146 | 0x40;
        if ((v143 & 0xFFF8) == 0) {
          LOWORD(v147) = v143 & 7 | (8 * (v134 & 7));
        }
      }
      *(_WORD *)(v161 + 12) = v147;
      *a11 += v12;
      unint64_t v149 = v72 + 2;
      unint64_t v122 = v72 + v71;
      unint64_t v150 = v159;
      if (v72 + v71 < v159) {
        unint64_t v150 = v72 + v71;
      }
      if (v85 < v71 >> 2)
      {
        if (v149 <= v122 - 4 * v85) {
          unint64_t v149 = v122 - 4 * v85;
        }
        if (v150 < v149) {
          unint64_t v149 = v150;
        }
      }
      unint64_t v16 = v158 + 2 * v71 + v72;
      v161 += 16;
      if (v149 >= v150)
      {
        unint64_t v12 = 0;
        a7 = v160;
        unint64_t v13 = v162;
      }
      else
      {
        a7 = v160;
        unint64_t v13 = v162;
        do
        {
          *(_DWORD *)(result
                    + 4
                    * (((((unint64_t)(0x35A7BD1E35A7BD00 * *(void *)(a3 + (v149 & a4))) >> 32) >> 12)
                      + (v149 & 0x18)) & 0xFFFFF)) = v149;
          ++v149;
        }
        while (v150 != v149);
        unint64_t v12 = 0;
      }
LABEL_246:
      unint64_t v11 = v122;
      if (v122 + 8 >= v13) {
        goto LABEL_259;
      }
    }
    uint64_t v137 = v160[1];
    if (v85 == v137)
    {
      unint64_t v125 = 1;
      goto LABEL_189;
    }
    unint64_t v138 = v85 + 3;
    unint64_t v139 = v85 + 3 - v129;
    if (v139 > 6)
    {
      if (v138 - v137 > 6)
      {
        if (v85 == v160[2])
        {
          unint64_t v125 = 2;
        }
        else if (v85 == v160[3])
        {
          unint64_t v125 = 3;
        }
        else
        {
LABEL_188:
          unint64_t v125 = v85 + 15;
        }
LABEL_189:
        if (v85 <= v124 && v125)
        {
          v160[3] = v160[2];
          *(void *)(v160 + 1) = *(void *)v160;
          *unint64_t v160 = v85;
        }
        *(_DWORD *)uint64_t v161 = v12;
        *(_DWORD *)(v161 + 4) = v71;
        uint64_t v126 = *(unsigned int *)(a5 + 68);
        uint64_t v127 = v126 + 16;
        if (v126 + 16 <= v125)
        {
          uint64_t v130 = *(unsigned int *)(a5 + 64);
          unint64_t v131 = v125 - v126 + (4 << v130) - 16;
          uint64_t v132 = (__clz(v131) ^ 0x1F) - 1;
          uint64_t v133 = ((v131 >> v132) & 1 | 2) << v132;
          unint64_t v125 = ((v131 & ~(-1 << v130))
                + v127
                + ((((v131 >> v132) & 1 | (2 * (v132 - v130))) + 65534) << v130)) | ((v132 - v130) << 10);
          unint64_t v128 = (v131 - v133) >> v130;
        }
        else
        {
          LODWORD(v128) = 0;
        }
        goto LABEL_197;
      }
      char v140 = 4 * (v138 - v137);
      unsigned int v141 = 266017486;
    }
    else
    {
      char v140 = 4 * v139;
      unsigned int v141 = 158663784;
    }
    unint64_t v125 = (v141 >> v140) & 0xF;
    goto LABEL_189;
  }
  uint64_t v161 = a9;
  unint64_t v122 = a2;
LABEL_259:
  *a8 = v12 + v13 - v122;
  *a10 += (v161 - a9) >> 4;
  return result;
}

unint64_t CreateBackwardReferencesNH65(unint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7, unint64_t *a8, _DWORD *a9, void *a10, void *a11)
{
  uint64_t v11 = a6;
  uint64_t v12 = a5;
  unint64_t v13 = a2;
  uint64_t v274 = *(void *)(a5 + 16);
  unint64_t v14 = *a8;
  unint64_t v15 = a2 + result;
  unint64_t v265 = a2 + result - 7;
  if (result <= 7) {
    uint64_t v16 = a2;
  }
  else {
    uint64_t v16 = a2 + result - 7;
  }
  int v17 = *(_DWORD *)(v12 + 8);
  uint64_t v18 = 512;
  if (*(int *)(v12 + 4) < 9) {
    uint64_t v18 = 64;
  }
  unint64_t v267 = v16;
  uint64_t v268 = v18;
  int v19 = *(_DWORD *)(a6 + 88);
  if (v19 >= 5)
  {
    int32x4_t v20 = (int32x4_t)vld1q_dup_f32((const float *)a7);
    *((int32x4_t *)a7 + 1) = vaddq_s32(v20, (int32x4_t)xmmword_20DB0A5B0);
    *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v20.i8, (int32x2_t)0x3FFFFFFFDLL);
    if (v19 >= 0xB)
    {
      unint64_t v21 = (const float *)(a7 + 1);
      int32x4_t v22 = (int32x4_t)vld1q_dup_f32(v21);
      *(int32x4_t *)(a7 + 10) = vaddq_s32(v22, (int32x4_t)xmmword_20DB0A5B0);
      *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v22.i8, (int32x2_t)0x3FFFFFFFDLL);
    }
  }
  if (a2 + 8 < v15)
  {
    unint64_t v23 = v18 + a2;
    unint64_t v273 = (1 << v17) - 16;
    uint64_t v264 = 4 * v18;
    char v266 = v13 + result - 1;
    uint64_t v269 = a9;
    uint64_t v289 = v12;
    unint64_t v271 = v15;
    uint64_t v288 = *(void *)(a6 + 104);
    unint64_t v275 = *(void *)(a6 + 72);
    uint64_t v276 = *(void *)(a6 + 112);
    while (1)
    {
      unint64_t v283 = v23;
      unint64_t v287 = v14;
      unint64_t v24 = v15 - v13;
      if (v13 >= v273) {
        unint64_t v25 = v273;
      }
      else {
        unint64_t v25 = v13;
      }
      if (v13 + v274 >= v273) {
        unint64_t v26 = v273;
      }
      else {
        unint64_t v26 = v13 + v274;
      }
      unint64_t v27 = v13 & a4;
      uint64_t v28 = *(int *)(v11 + 88);
      if (v28)
      {
        unint64_t v29 = 0;
        unint64_t result = 0;
        unint64_t v30 = 0;
        unint64_t v31 = 0;
        unint64_t v32 = 2020;
        unint64_t v33 = 2020;
        do
        {
          unint64_t v34 = a7[v29];
          unint64_t v35 = v13 - v34;
          BOOL v36 = v25 < v34 || v35 >= v13;
          uint64_t v37 = v35 & a4;
          unint64_t v38 = result + v27;
          BOOL v39 = v36 || v38 > a4;
          unint64_t v40 = v37 + result;
          BOOL v41 = v39 || v40 > a4;
          if (!v41 && *(unsigned __int8 *)(a3 + v38) == *(unsigned __int8 *)(a3 + v40))
          {
            uint64_t v42 = a3 + v37;
            if (v24 < 8)
            {
              unint64_t v47 = 0;
              unint64_t v48 = (unsigned __int8 *)(a3 + v27);
LABEL_49:
              if ((v24 & 7) != 0)
              {
                unint64_t v50 = v30;
                unint64_t v51 = v24 & 7 | v47;
                unint64_t v52 = v24 & 7;
                while (*(unsigned __int8 *)(v42 + v47) == *v48)
                {
                  ++v48;
                  ++v47;
                  if (!--v52)
                  {
                    unint64_t v47 = v51;
                    break;
                  }
                }
                unint64_t v30 = v50;
              }
            }
            else
            {
              uint64_t v43 = 0;
              unint64_t v44 = v24 >> 3;
              while (1)
              {
                uint64_t v45 = *(void *)(a3 + v27 + v43);
                uint64_t v46 = *(void *)(v42 + v43);
                if (v45 != v46) {
                  break;
                }
                v43 += 8;
                if (!--v44)
                {
                  unint64_t v47 = v24 & 0xFFFFFFFFFFFFFFF8;
                  unint64_t v48 = (unsigned __int8 *)(a3 + v27 + (v24 & 0xFFFFFFFFFFFFFFF8));
                  goto LABEL_49;
                }
              }
              unint64_t v47 = v43 + (__clz(__rbit64(v46 ^ v45)) >> 3);
            }
            if (v47 > 2 || v29 <= 1 && v47 == 2)
            {
              unint64_t v49 = 135 * v47 + 1935;
              if (v32 < v49)
              {
                if (v29) {
                  v49 -= ((0x1CA10u >> (v29 & 0xE)) & 0xE) + 39;
                }
                if (v32 < v49)
                {
                  unint64_t v31 = a7[v29];
                  unint64_t v33 = v49;
                  unint64_t v30 = v47;
                  unint64_t v32 = v49;
                  unint64_t result = v47;
                }
              }
            }
          }
          ++v29;
        }
        while (v29 != v28);
      }
      else
      {
        unint64_t v31 = 0;
        unint64_t v30 = 0;
        unint64_t result = 0;
        unint64_t v33 = 2020;
        unint64_t v32 = 2020;
      }
      unint64_t v279 = *(void *)(v12 + 80);
      int v53 = (_DWORD *)(a3 + v27);
      unint64_t v54 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + v27) & v275)) >> *(_DWORD *)(v11 + 64);
      uint64_t v55 = *(unsigned int *)(v11 + 80);
      uint64_t v56 = v276 + 4 * (v54 << *(_DWORD *)(v11 + 84));
      unint64_t v57 = *(unsigned __int16 *)(v288 + 2 * v54);
      unint64_t v272 = *(void *)(v11 + 56);
      if (v57 >= v272) {
        unint64_t v58 = v57 - v272;
      }
      else {
        unint64_t v58 = 0;
      }
      if (v58 < v57)
      {
        unint64_t v59 = *(unsigned __int16 *)(v288 + 2 * v54);
        do
        {
          uint64_t v60 = *(unsigned int *)(v56 + 4 * (--v59 & v55));
          unint64_t v61 = v13 - v60;
          if (v13 - v60 > v25) {
            break;
          }
          if (result + v27 <= a4)
          {
            uint64_t v62 = v60 & a4;
            if (v62 + result <= a4
              && *(unsigned __int8 *)(a3 + result + v27) == *(unsigned __int8 *)(a3 + v62 + result))
            {
              uint64_t v63 = a3 + v62;
              if (v24 < 8)
              {
                unint64_t v68 = 0;
                char v69 = (unsigned __int8 *)(a3 + v27);
LABEL_77:
                if ((v24 & 7) != 0)
                {
                  unint64_t v285 = v33;
                  unint64_t v281 = v24 & 7 | v68;
                  unint64_t v71 = v24 & 7;
                  while (*(unsigned __int8 *)(v63 + v68) == *v69)
                  {
                    ++v69;
                    ++v68;
                    if (!--v71)
                    {
                      unint64_t v68 = v281;
                      break;
                    }
                  }
                  unint64_t v33 = v285;
                }
              }
              else
              {
                uint64_t v64 = 0;
                unint64_t v65 = v24 >> 3;
                while (1)
                {
                  uint64_t v66 = *(void *)&v53[v64];
                  uint64_t v67 = *(void *)(v63 + v64 * 4);
                  if (v66 != v67) {
                    break;
                  }
                  v64 += 2;
                  if (!--v65)
                  {
                    unint64_t v68 = v24 & 0xFFFFFFFFFFFFFFF8;
                    char v69 = (unsigned __int8 *)v53 + (v24 & 0xFFFFFFFFFFFFFFF8);
                    goto LABEL_77;
                  }
                }
                unint64_t v68 = v64 * 4 + (__clz(__rbit64(v67 ^ v66)) >> 3);
              }
              if (v68 >= 4)
              {
                unsigned int v70 = __clz(v61) ^ 0x1F;
                if (v32 < 135 * v68 - 30 * v70 + 1920)
                {
                  unint64_t v31 = v61;
                  unint64_t v33 = 135 * v68 - 30 * v70 + 1920;
                  unint64_t v30 = v68;
                  unint64_t v32 = v33;
                  unint64_t result = v68;
                }
              }
            }
          }
        }
        while (v59 > v58);
      }
      *(_DWORD *)(v56 + 4 * (v55 & v57)) = v13;
      *(_WORD *)(v288 + 2 * v54) = v57 + 1;
      unint64_t v72 = v30;
      if (v33 == 2020)
      {
        uint64_t v11 = a6;
        uint64_t v73 = *(void *)(a6 + 96);
        unint64_t v74 = *(void *)(v73 + 8);
        unint64_t result = *(void *)(v73 + 16);
        uint64_t v12 = v289;
        if (result >= v74 >> 7)
        {
          int v278 = 0;
          uint64_t v208 = ((506832829 * *v53) >> 17) & 0x7FFE;
          uint64_t v209 = *(void *)(v289 + 120);
          unint64_t v210 = v26 + 1;
          char v211 = 1;
          unint64_t v212 = v30;
          unint64_t v33 = 2020;
          unint64_t v213 = v31;
          do
          {
            char v214 = v211;
            *(void *)(v73 + 8) = ++v74;
            unint64_t v215 = *(unsigned __int8 *)(v209 + v208);
            if (!*(unsigned char *)(v209 + v208) || v24 < v215) {
              goto LABEL_292;
            }
            uint64_t v216 = *(unsigned __int16 *)(*(void *)(v289 + 112) + 2 * v208);
            uint64_t v217 = *(void *)(v289 + 88);
            uint64_t v218 = *(unsigned int *)(v217 + 4 * v215 + 32);
            uint64_t v219 = *(void *)(v217 + 168);
            unsigned int v220 = (unsigned __int8 *)(v219 + v218 + v216 * *(unsigned __int8 *)(v209 + v208));
            if (v215 < 8)
            {
              unint64_t v72 = 0;
LABEL_307:
              unint64_t v226 = v215 & 7;
              if ((v215 & 7) != 0)
              {
                unint64_t v227 = v72 | v226;
                while (*((unsigned __int8 *)v53 + v72) == *v220)
                {
                  ++v220;
                  ++v72;
                  if (!--v226)
                  {
                    unint64_t v72 = v227;
                    break;
                  }
                }
              }
            }
            else
            {
              unint64_t v221 = 0;
              unint64_t v222 = (unsigned __int8 *)(v219
                                       + v216 * (unint64_t)*(unsigned __int8 *)(v209 + v208)
                                       + (*(unsigned char *)(v209 + v208) & 0xF8)
                                       + v218);
              while (1)
              {
                uint64_t v223 = *(void *)&v220[v221];
                uint64_t v224 = *(void *)&v53[v221 / 4];
                if (v223 != v224) {
                  break;
                }
                v221 += 8;
                if ((v215 & 0xF8) == v221)
                {
                  unsigned int v220 = v222;
                  unint64_t v72 = v215 & 0xF8;
                  goto LABEL_307;
                }
              }
              unint64_t v72 = v221 + (__clz(__rbit64(v224 ^ v223)) >> 3);
            }
            if (v72
              && v72 + *(unsigned int *)(v289 + 100) > v215
              && (unint64_t v31 = v210
                      + v216
                      + ((((*(void *)(v289 + 104) >> (6 * (v215 - v72))) & 0x3FLL)
                        + 4 * (v215 - v72)) << *(unsigned char *)(v217 + v215)),
                  v31 <= v279)
              && (unint64_t v225 = 135 * v72 - 30 * (__clz(v31) ^ 0x1F) + 1920, v225 >= v33))
            {
              int v278 = v215 - v72;
              *(void *)(v73 + 16) = ++result;
              unint64_t v33 = v225;
            }
            else
            {
LABEL_292:
              unint64_t v31 = v213;
              unint64_t v72 = v212;
            }
            char v211 = 0;
            ++v208;
            unint64_t v212 = v72;
            unint64_t v213 = v31;
          }
          while ((v214 & 1) != 0);
        }
        else
        {
          int v278 = 0;
          unint64_t v33 = 2020;
        }
      }
      else
      {
        int v278 = 0;
        uint64_t v11 = a6;
        uint64_t v12 = v289;
      }
      if (v24 >= 0x20)
      {
        unint64_t v75 = *(void *)(v11 + 136);
        if (v75 <= v13)
        {
          int v76 = *(_DWORD *)(v11 + 148);
          int v77 = *(_DWORD *)(v11 + 152);
          unint64_t result = v24 & 7;
          int v78 = *(_DWORD *)(v11 + 120);
          do
          {
            int v79 = *(unsigned __int8 *)(a3 + (v75 & a4));
            int v80 = *(unsigned __int8 *)(a3 + ((v75 + 32) & a4));
            if ((v78 & 0x3F000000) == 0)
            {
              uint64_t v81 = *(void *)(v11 + 128);
              uint64_t v82 = *(unsigned int *)(v81 + 4 * (v78 & 0x3FFFFFFF));
              *(_DWORD *)(v81 + 4 * (v78 & 0x3FFFFFFF)) = v75;
              if (v75 == v13 && v82 != -1)
              {
                unint64_t v83 = (v13 - v82);
                if (v25 >= v83)
                {
                  uint64_t v84 = 0;
                  uint64_t v85 = a3 + (v82 & a4);
                  unint64_t v86 = v24 >> 3;
                  do
                  {
                    uint64_t v87 = *(void *)&v53[v84];
                    uint64_t v88 = *(void *)(v85 + v84 * 4);
                    if (v87 != v88)
                    {
                      unint64_t v89 = v84 * 4 + (__clz(__rbit64(v88 ^ v87)) >> 3);
                      goto LABEL_104;
                    }
                    v84 += 2;
                    --v86;
                  }
                  while (v86);
                  unint64_t v89 = v24 & 0xFFFFFFFFFFFFFFF8;
                  if ((v24 & 7) != 0)
                  {
                    unint64_t v90 = v24 & 7;
                    unint64_t v89 = v24 & 0xFFFFFFFFFFFFFFF8;
                    while (*(unsigned __int8 *)(v85 + v89) == *((unsigned __int8 *)v53 + v89))
                    {
                      ++v89;
                      if (!--v90)
                      {
                        unint64_t v89 = v24;
                        break;
                      }
                    }
                    uint64_t v11 = a6;
                    uint64_t v12 = v289;
                  }
LABEL_104:
                  unint64_t v91 = 135 * v89 - 30 * (__clz(v83) ^ 0x1F) + 1920;
                  BOOL v92 = v91 > v33;
                  if (v91 <= v33)
                  {
                    unint64_t v83 = v31;
                    unint64_t v91 = v33;
                  }
                  int v93 = v278;
                  if (v92) {
                    int v94 = 0;
                  }
                  else {
                    int v94 = v278;
                  }
                  if (v92) {
                    unint64_t v95 = v89;
                  }
                  else {
                    unint64_t v95 = v72;
                  }
                  if (v89 <= v72)
                  {
                    unint64_t v83 = v31;
                    unint64_t v91 = v33;
                    int v94 = v278;
                    unint64_t v95 = v72;
                  }
                  if (v89 >= 4)
                  {
                    unint64_t v31 = v83;
                    unint64_t v33 = v91;
                    int v93 = v94;
                  }
                  int v278 = v93;
                  if (v89 >= 4) {
                    unint64_t v72 = v95;
                  }
                }
              }
            }
            int v78 = v80 + v76 * v78 + v77 * ~v79 + 1;
            ++v75;
          }
          while (v75 <= v13);
          *(_DWORD *)(v11 + 120) = v78;
        }
        *(void *)(v11 + 136) = v13 + 1;
      }
      if (v33 < 0x7E5)
      {
        unint64_t v14 = v287 + 1;
        unint64_t v194 = v13 + 1;
        unint64_t v23 = v283;
        unint64_t v15 = v271;
        if (v13 + 1 > v283)
        {
          unint64_t result = 0x1FE35A7BD3579BD3;
          if (v194 <= v283 + v264)
          {
            unint64_t v238 = v13 + 9;
            if (v13 + 9 >= v265) {
              unint64_t v238 = v265;
            }
            if (v194 < v238)
            {
              int v239 = *(_DWORD *)(v11 + 64);
              int v240 = *(_DWORD *)(v11 + 80);
              int v241 = *(_DWORD *)(v11 + 84);
              do
              {
                unint64_t v242 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + (v194 & a4)) & v275)) >> v239;
                unsigned int v243 = *(unsigned __int16 *)(v288 + 2 * v242);
                *(_WORD *)(v288 + 2 * v242) = v243 + 1;
                *(_DWORD *)(v276 + 4 * ((v242 << v241) + (unint64_t)(v240 & v243))) = v194;
                v14 += 2;
                v194 += 2;
              }
              while (v194 < v238);
            }
          }
          else
          {
            unint64_t v195 = v13 + 17;
            if (v13 + 17 >= v265) {
              unint64_t v195 = v265;
            }
            if (v194 < v195)
            {
              int v196 = *(_DWORD *)(v11 + 64);
              int v197 = *(_DWORD *)(v11 + 80);
              int v198 = *(_DWORD *)(v11 + 84);
              do
              {
                unint64_t v199 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + (v194 & a4)) & v275)) >> v196;
                unsigned int v200 = *(unsigned __int16 *)(v288 + 2 * v199);
                *(_WORD *)(v288 + 2 * v199) = v200 + 1;
                *(_DWORD *)(v276 + 4 * ((v199 << v198) + (unint64_t)(v197 & v200))) = v194;
                v14 += 4;
                v194 += 4;
              }
              while (v194 < v195);
            }
          }
        }
        goto LABEL_368;
      }
      unint64_t v270 = v31;
      unsigned int v96 = 0;
      char v97 = v266 - v13;
      while (1)
      {
        --v24;
        char v282 = v97;
        unint64_t v284 = v72;
        unint64_t v98 = v72 - 1;
        if (v72 - 1 >= v24) {
          unint64_t v98 = v24;
        }
        if (*(int *)(v12 + 4) >= 5) {
          unint64_t v99 = 0;
        }
        else {
          unint64_t v99 = v98;
        }
        unint64_t v100 = v13 + 1;
        if (v13 + 1 < v273) {
          unint64_t v101 = v13 + 1;
        }
        else {
          unint64_t v101 = v273;
        }
        unint64_t v102 = v100 + v274;
        if (v100 + v274 >= v273) {
          unint64_t v102 = v273;
        }
        unint64_t v277 = v102;
        uint64_t v103 = v100 & a4;
        uint64_t v104 = *(int *)(v11 + 88);
        if (v104)
        {
          unint64_t v105 = 0;
          unint64_t v106 = 0;
          unint64_t v107 = 0;
          uint64_t v108 = a3 + v103;
          unint64_t v109 = 2020;
          unint64_t v110 = 2020;
          do
          {
            unint64_t v111 = a7[v105];
            unint64_t v112 = v100 - v111;
            BOOL v113 = v101 < v111 || v112 >= v100;
            uint64_t v114 = v112 & a4;
            unint64_t v115 = v99 + v103;
            BOOL v116 = v113 || v115 > a4;
            unint64_t v117 = v114 + v99;
            BOOL v118 = v116 || v117 > a4;
            if (!v118 && *(unsigned __int8 *)(a3 + v115) == *(unsigned __int8 *)(a3 + v117))
            {
              uint64_t v119 = a3 + v114;
              if (v24 < 8)
              {
                unint64_t v120 = 0;
                unint64_t v124 = (unsigned __int8 *)(a3 + v103);
LABEL_165:
                if ((v24 & 7) != 0)
                {
                  unint64_t v126 = v24 & 7;
                  do
                  {
                    if (*(unsigned __int8 *)(v119 + v120) != *v124) {
                      break;
                    }
                    ++v124;
                    ++v120;
                    --v126;
                  }
                  while (v126);
                }
              }
              else
              {
                unint64_t v120 = 0;
                unint64_t v121 = v24 >> 3;
                while (1)
                {
                  uint64_t v122 = *(void *)(v108 + v120);
                  uint64_t v123 = *(void *)(v119 + v120);
                  if (v122 != v123) {
                    break;
                  }
                  v120 += 8;
                  if (!--v121)
                  {
                    unint64_t v124 = (unsigned __int8 *)(v108 + v120);
                    goto LABEL_165;
                  }
                }
                v120 += __clz(__rbit64(v123 ^ v122)) >> 3;
              }
              if (v120 > 2 || v105 <= 1 && v120 == 2)
              {
                unint64_t v125 = 135 * v120 + 1935;
                if (v109 < v125)
                {
                  if (v105) {
                    v125 -= ((0x1CA10u >> (v105 & 0xE)) & 0xE) + 39;
                  }
                  if (v109 < v125)
                  {
                    unint64_t v107 = v120;
                    unint64_t v106 = a7[v105];
                    unint64_t v110 = v125;
                    unint64_t v109 = v125;
                    unint64_t v99 = v120;
                  }
                }
              }
            }
            ++v105;
          }
          while (v105 != v104);
        }
        else
        {
          unint64_t v107 = 0;
          unint64_t v106 = 0;
          unint64_t v110 = 2020;
          unint64_t v109 = 2020;
        }
        uint64_t v127 = (_DWORD *)(a3 + v103);
        unint64_t v128 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + v103) & v275)) >> *(_DWORD *)(v11 + 64);
        uint64_t v129 = *(unsigned int *)(v11 + 80);
        uint64_t v130 = v276 + 4 * (v128 << *(_DWORD *)(v11 + 84));
        unint64_t v131 = *(unsigned __int16 *)(v288 + 2 * v128);
        if (v131 >= v272) {
          unint64_t v132 = v131 - v272;
        }
        else {
          unint64_t v132 = 0;
        }
        unint64_t v286 = v33;
        if (v132 < v131)
        {
          unint64_t v133 = v24 & 7;
          unint64_t v134 = *(unsigned __int16 *)(v288 + 2 * v128);
          do
          {
            uint64_t v135 = *(unsigned int *)(v130 + 4 * (--v134 & v129));
            unint64_t v136 = v100 - v135;
            if (v100 - v135 > v101) {
              break;
            }
            if (v99 + v103 <= a4)
            {
              uint64_t v137 = v135 & a4;
              if (v137 + v99 <= a4 && *(unsigned __int8 *)(a3 + v99 + v103) == *(unsigned __int8 *)(a3 + v137 + v99))
              {
                uint64_t v138 = a3 + v137;
                if (v24 < 8)
                {
                  unint64_t v140 = 0;
                  unint64_t v144 = (unsigned __int8 *)(a3 + v103);
LABEL_192:
                  if (v133)
                  {
                    unint64_t v146 = v133;
                    do
                    {
                      if (*(unsigned __int8 *)(v138 + v140) != *v144) {
                        break;
                      }
                      ++v144;
                      ++v140;
                      --v146;
                    }
                    while (v146);
                  }
                }
                else
                {
                  unint64_t v139 = v133;
                  unint64_t v140 = 0;
                  unint64_t v141 = v24 >> 3;
                  while (1)
                  {
                    uint64_t v142 = *(void *)((char *)v127 + v140);
                    uint64_t v143 = *(void *)(v138 + v140);
                    if (v142 != v143) {
                      break;
                    }
                    v140 += 8;
                    if (!--v141)
                    {
                      unint64_t v144 = (unsigned __int8 *)v127 + v140;
                      unint64_t v133 = v139;
                      goto LABEL_192;
                    }
                  }
                  v140 += __clz(__rbit64(v143 ^ v142)) >> 3;
                  unint64_t v133 = v139;
                }
                if (v140 >= 4)
                {
                  unsigned int v145 = __clz(v136) ^ 0x1F;
                  if (v109 < 135 * v140 - 30 * v145 + 1920)
                  {
                    unint64_t v107 = v140;
                    unint64_t v106 = v136;
                    unint64_t v110 = 135 * v140 - 30 * v145 + 1920;
                    unint64_t v109 = v110;
                    unint64_t v99 = v140;
                  }
                }
              }
            }
          }
          while (v134 > v132);
        }
        *(_DWORD *)(v130 + 4 * (v129 & v131)) = v100;
        *(_WORD *)(v288 + 2 * v128) = v131 + 1;
        if (v110 == 2020)
        {
          uint64_t v147 = *(void *)(a6 + 96);
          unint64_t v148 = *(void *)(v147 + 8);
          unint64_t v149 = *(void *)(v147 + 16);
          if (v149 >= v148 >> 7)
          {
            int v150 = 0;
            uint64_t v175 = ((506832829 * *v127) >> 17) & 0x7FFE;
            uint64_t v176 = *(void *)(v289 + 120);
            char v177 = 1;
            unint64_t v110 = 2020;
            unint64_t v178 = v106;
            unint64_t v179 = v107;
            do
            {
              char v180 = v177;
              *(void *)(v147 + 8) = ++v148;
              unint64_t v181 = *(unsigned __int8 *)(v176 + v175);
              if (!*(unsigned char *)(v176 + v175) || v24 < v181) {
                goto LABEL_261;
              }
              uint64_t v182 = *(unsigned __int16 *)(*(void *)(v289 + 112) + 2 * v175);
              uint64_t v183 = *(void *)(v289 + 88);
              uint64_t v184 = *(unsigned int *)(v183 + 4 * v181 + 32);
              uint64_t v185 = *(void *)(v183 + 168);
              __int16 v186 = (unsigned __int8 *)(v185 + v184 + v182 * *(unsigned __int8 *)(v176 + v175));
              if (v181 < 8)
              {
                unint64_t v107 = 0;
LABEL_266:
                unint64_t v192 = v181 & 7;
                if ((v181 & 7) != 0)
                {
                  unint64_t v193 = v107 | v192;
                  while (*((unsigned __int8 *)v127 + v107) == *v186)
                  {
                    ++v186;
                    ++v107;
                    if (!--v192)
                    {
                      unint64_t v107 = v193;
                      break;
                    }
                  }
                }
              }
              else
              {
                unint64_t v187 = 0;
                unint64_t v107 = v181 & 0xF8;
                unint64_t v188 = (unsigned __int8 *)(v185
                                         + v182 * (unint64_t)*(unsigned __int8 *)(v176 + v175)
                                         + (*(unsigned char *)(v176 + v175) & 0xF8)
                                         + v184);
                while (1)
                {
                  uint64_t v189 = *(void *)&v186[v187];
                  uint64_t v190 = *(void *)&v127[v187 / 4];
                  if (v189 != v190) {
                    break;
                  }
                  v187 += 8;
                  if (v107 == v187)
                  {
                    __int16 v186 = v188;
                    goto LABEL_266;
                  }
                }
                unint64_t v107 = v187 + (__clz(__rbit64(v190 ^ v189)) >> 3);
              }
              if (v107
                && v107 + *(unsigned int *)(v289 + 100) > v181
                && (unint64_t v106 = v277
                         + 1
                         + v182
                         + ((((*(void *)(v289 + 104) >> (6 * (v181 - v107))) & 0x3FLL)
                           + 4 * (v181 - v107)) << *(unsigned char *)(v183 + v181)),
                    v106 <= v279)
                && (unsigned int v191 = __clz(v106) ^ 0x1F, 135 * v107 - 30 * v191 + 1920 >= v110))
              {
                int v150 = v181 - v107;
                *(void *)(v147 + 16) = ++v149;
                unint64_t v110 = 135 * v107 - 30 * v191 + 1920;
              }
              else
              {
LABEL_261:
                unint64_t v107 = v179;
                unint64_t v106 = v178;
              }
              char v177 = 0;
              ++v175;
              unint64_t v178 = v106;
              unint64_t v179 = v107;
            }
            while ((v180 & 1) != 0);
          }
          else
          {
            int v150 = 0;
            unint64_t v110 = 2020;
          }
        }
        else
        {
          int v150 = 0;
        }
        uint64_t v151 = v282 & 7;
        if (v24 >= 0x20)
        {
          uint64_t v11 = a6;
          unint64_t v153 = *(void *)(a6 + 136);
          if (v153 <= v100)
          {
            int v154 = *(_DWORD *)(a6 + 148);
            int v155 = *(_DWORD *)(a6 + 152);
            int v156 = *(_DWORD *)(a6 + 120);
            do
            {
              int v157 = *(unsigned __int8 *)(a3 + (v153 & a4));
              int v158 = *(unsigned __int8 *)(a3 + ((v153 + 32) & a4));
              if ((v156 & 0x3F000000) == 0)
              {
                uint64_t v159 = *(void *)(v11 + 128);
                uint64_t v160 = *(unsigned int *)(v159 + 4 * (v156 & 0x3FFFFFFF));
                *(_DWORD *)(v159 + 4 * (v156 & 0x3FFFFFFF)) = v153;
                if (v153 == v100 && v160 != -1)
                {
                  unint64_t v161 = (v100 - v160);
                  if (v101 >= v161)
                  {
                    unint64_t v162 = 0;
                    uint64_t v163 = a3 + (v160 & a4);
                    unint64_t v164 = v24 >> 3;
                    do
                    {
                      uint64_t v165 = *(void *)((char *)v127 + v162);
                      uint64_t v166 = *(void *)(v163 + v162);
                      if (v165 != v166)
                      {
                        v162 += __clz(__rbit64(v166 ^ v165)) >> 3;
                        goto LABEL_218;
                      }
                      v162 += 8;
                      --v164;
                    }
                    while (v164);
                    if ((v24 & 7) != 0)
                    {
                      uint64_t v167 = 0;
                      uint64_t v168 = v163 + v162;
                      do
                      {
                        if (*(unsigned __int8 *)(v168 + v167) != *((unsigned __int8 *)v127 + v162 + v167)) {
                          break;
                        }
                        ++v167;
                      }
                      while (v151 != v167);
                      v162 += v167;
                      uint64_t v11 = a6;
                    }
LABEL_218:
                    unint64_t v169 = 135 * v162 - 30 * (__clz(v161) ^ 0x1F) + 1920;
                    BOOL v170 = v169 > v110;
                    if (v169 > v110) {
                      unint64_t v171 = v162;
                    }
                    else {
                      unint64_t v171 = v107;
                    }
                    if (v169 <= v110)
                    {
                      unint64_t v161 = v106;
                      unint64_t v169 = v110;
                    }
                    if (v170) {
                      int v172 = 0;
                    }
                    else {
                      int v172 = v150;
                    }
                    BOOL v173 = v162 >= 4 && v162 > v107;
                    if (v173) {
                      unint64_t v107 = v171;
                    }
                    if (v173) {
                      unint64_t v106 = v161;
                    }
                    if (v173) {
                      unint64_t v110 = v169;
                    }
                    if (v173) {
                      int v150 = v172;
                    }
                  }
                }
              }
              int v156 = v158 + v154 * v156 + v155 * ~v157 + 1;
              ++v153;
            }
            while (v153 <= v100);
            *(_DWORD *)(v11 + 120) = v156;
          }
          uint64_t v12 = v289;
          unint64_t v152 = v284;
          *(void *)(v11 + 136) = v13 + 2;
        }
        else
        {
          uint64_t v11 = a6;
          uint64_t v12 = v289;
          unint64_t v152 = v284;
        }
        if (v110 < v286 + 175) {
          break;
        }
        ++v287;
        if (v96 <= 2)
        {
          unint64_t v174 = v13 + 9;
          ++v96;
          char v97 = v151 + 7;
          unint64_t v270 = v106;
          unint64_t v33 = v110;
          int v278 = v150;
          unint64_t v72 = v107;
          ++v13;
          if (v174 < v271) {
            continue;
          }
        }
        goto LABEL_282;
      }
      unint64_t v201 = v13 + v274;
      if (v13 + v274 >= v273) {
        unint64_t v201 = v273;
      }
      unint64_t v277 = v201;
      unint64_t v106 = v270;
      int v150 = v278;
      unint64_t v107 = v152;
      unint64_t v100 = v13;
LABEL_282:
      unint64_t result = 0x1FE35A7BD3579BD3;
      uint64_t v202 = v269;
      if (v106 > v277) {
        goto LABEL_283;
      }
      uint64_t v228 = *a7;
      if (v106 != v228) {
        break;
      }
      unint64_t v203 = 0;
LABEL_315:
      *uint64_t v269 = v287;
      v269[1] = v107 | (v150 << 25);
      uint64_t v229 = *(unsigned int *)(v12 + 68);
      uint64_t v230 = v229 + 16;
      if (v229 + 16 <= v203)
      {
        uint64_t v232 = *(unsigned int *)(v12 + 64);
        unint64_t v233 = v203 - v229 + (4 << v232) - 16;
        uint64_t v234 = (__clz(v233) ^ 0x1F) - 1;
        uint64_t v235 = ((v233 >> v234) & 1 | 2) << v234;
        uint64_t v202 = v269;
        unint64_t v203 = ((v233 & ~(-1 << v232))
              + v230
              + ((((v233 >> v234) & 1 | (2 * (v234 - v232))) + 65534) << v232)) | ((v234 - v232) << 10);
        unint64_t v231 = (v233 - v235) >> v232;
      }
      else
      {
        LODWORD(v231) = 0;
      }
      *((_WORD *)v202 + 7) = v203;
      v202[2] = v231;
      if (v287 > 5)
      {
        if (v287 > 0x81)
        {
          if (v287 > 0x841)
          {
            if (v287 >> 1 >= 0xC21)
            {
              if (v287 < 0x5842) {
                LOWORD(v236) = 22;
              }
              else {
                LOWORD(v236) = 23;
              }
            }
            else
            {
              LOWORD(v236) = 21;
            }
          }
          else
          {
            unsigned int v236 = (__clz(v287 - 66) ^ 0x1F) + 10;
          }
        }
        else
        {
          unsigned int v237 = (__clz(v287 - 2) ^ 0x1F) - 1;
          unsigned int v236 = ((v287 - 2) >> v237) + 2 * v237 + 2;
        }
      }
      else
      {
        LOWORD(v236) = v287;
      }
      uint64_t v249 = v150 + (int)v107;
      if (v249 > 9)
      {
        if (v249 > 0x85)
        {
          if (v249 > 0x845) {
            LOWORD(v250) = 23;
          }
          else {
            unsigned int v250 = (__clz(v249 - 70) ^ 0x1F) + 12;
          }
        }
        else
        {
          unint64_t v251 = v249 - 6;
          unsigned int v252 = (__clz(v251) ^ 0x1F) - 1;
          unsigned int v250 = (v251 >> v252) + 2 * v252 + 4;
        }
      }
      else
      {
        LOWORD(v250) = v150 + v107 - 2;
      }
      int v253 = v250 & 7 | (8 * (v236 & 7));
      if ((v203 & 0x3FF) != 0 || (unsigned __int16)v236 > 7u || (unsigned __int16)v250 > 0xFu)
      {
        int v255 = 3 * ((unsigned __int16)v236 >> 3) + ((unsigned __int16)(v250 & 0xFFF8) >> 3);
        unsigned int v254 = ((((0x520D40u >> (2 * v255)) & 0xC0) + (v255 << 6)) | v253) + 64;
      }
      else
      {
        LOWORD(v254) = v253 | 0x40;
        if ((v250 & 0xFFF8) == 0) {
          LOWORD(v254) = v250 & 7 | (8 * (v236 & 7));
        }
      }
      *((_WORD *)v202 + 6) = v254;
      unint64_t v256 = v267;
      *a11 += v287;
      unint64_t v257 = v100 + 2;
      unint64_t v194 = v100 + v107;
      if (v100 + v107 < v267) {
        unint64_t v256 = v100 + v107;
      }
      if (v106 < v107 >> 2)
      {
        if (v257 <= v194 - 4 * v106) {
          unint64_t v257 = v194 - 4 * v106;
        }
        if (v256 < v257) {
          unint64_t v257 = v256;
        }
      }
      unint64_t v23 = v268 + 2 * v107 + v100;
      uint64_t v269 = v202 + 4;
      if (v257 >= v256)
      {
        unint64_t v14 = 0;
        unint64_t v15 = v271;
      }
      else
      {
        int v258 = *(_DWORD *)(v11 + 64);
        int v259 = *(_DWORD *)(v11 + 80);
        int v260 = *(_DWORD *)(v11 + 84);
        unint64_t v15 = v271;
        do
        {
          unint64_t v261 = (0x1FE35A7BD3579BD3 * (*(void *)(a3 + (v257 & a4)) & v275)) >> v258;
          unsigned int v262 = *(unsigned __int16 *)(v288 + 2 * v261);
          *(_WORD *)(v288 + 2 * v261) = v262 + 1;
          *(_DWORD *)(v276 + 4 * ((v261 << v260) + (unint64_t)(v259 & v262))) = v257++;
        }
        while (v256 != v257);
        unint64_t v14 = 0;
      }
LABEL_368:
      unint64_t v13 = v194;
      if (v194 + 8 >= v15) {
        goto LABEL_375;
      }
    }
    uint64_t v244 = a7[1];
    if (v106 == v244)
    {
      unint64_t v203 = 1;
      goto LABEL_284;
    }
    unint64_t v245 = v106 + 3 - v228;
    if (v245 > 6)
    {
      unint64_t v248 = v106 + 3 - v244;
      if (v248 > 6)
      {
        if (v106 == a7[2])
        {
          unint64_t v203 = 2;
        }
        else if (v106 == a7[3])
        {
          unint64_t v203 = 3;
        }
        else
        {
LABEL_283:
          unint64_t v203 = v106 + 15;
        }
LABEL_284:
        if (v106 <= v277)
        {
          if (v203)
          {
            a7[3] = a7[2];
            int32x2_t v204 = *(int32x2_t *)a7;
            *(void *)(a7 + 1) = *(void *)a7;
            *a7 = v106;
            int v205 = *(_DWORD *)(v11 + 88);
            if (v205 >= 5)
            {
              int32x4_t v206 = vdupq_n_s32(v106);
              *((int32x4_t *)a7 + 1) = vaddq_s32(v206, (int32x4_t)xmmword_20DB0A5B0);
              *((int32x2_t *)a7 + 4) = vadd_s32(*(int32x2_t *)v206.i8, (int32x2_t)0x3FFFFFFFDLL);
              if (v205 >= 0xB)
              {
                int32x4_t v207 = vdupq_lane_s32(v204, 0);
                *(int32x4_t *)(a7 + 10) = vaddq_s32(v207, (int32x4_t)xmmword_20DB0A5B0);
                *((int32x2_t *)a7 + 7) = vadd_s32(*(int32x2_t *)v207.i8, (int32x2_t)0x3FFFFFFFDLL);
              }
            }
          }
        }
        goto LABEL_315;
      }
      char v246 = 4 * v248;
      unsigned int v247 = 266017486;
    }
    else
    {
      char v246 = 4 * v245;
      unsigned int v247 = 158663784;
    }
    unint64_t v203 = (v247 >> v246) & 0xF;
    goto LABEL_284;
  }
  uint64_t v269 = a9;
  unint64_t v194 = a2;
LABEL_375:
  *a8 = v14 + v15 - v194;
  *a10 += ((char *)v269 - (char *)a9) >> 4;
  return result;
}

uint64_t BrotliFindAllStaticDictionaryMatches(uint64_t *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5 = a1[5];
  unsigned int v6 = (506832829 * *(_DWORD *)a2) >> 17;
  uint64_t v7 = *(unsigned __int16 *)(v5 + 2 * v6);
  if (*(_WORD *)(v5 + 2 * v6))
  {
    uint64_t v8 = 0;
    uint64_t v9 = a2 + 1;
    uint64_t v10 = a1[6];
    uint64_t v11 = *a1;
    while (1)
    {
      uint64_t v12 = (char *)(v10 + 4 * v7);
      char v13 = *v12;
      int v14 = v12[1];
      int v15 = *((unsigned __int16 *)v12 + 1);
      unint64_t v16 = *v12 & 0x1F;
      char v17 = *(unsigned char *)(v11 + v16);
      if (!v12[1])
      {
        unint64_t v27 = *(void *)(v11 + 168)
            + *(unsigned int *)(v11 + 4 * (*v12 & 0x1F) + 32)
            + *((unsigned __int16 *)v12 + 1) * (unint64_t)(*v12 & 0x1F);
        if (v16 >= a4) {
          unint64_t v28 = a4;
        }
        else {
          unint64_t v28 = v13 & 0x1F;
        }
        if (v28 < 8)
        {
          unint64_t v30 = 0;
          unint64_t v31 = a2;
LABEL_241:
          unint64_t v96 = v28 & 7;
          if (v96)
          {
            unint64_t v97 = v30 | v96;
            while (*(unsigned __int8 *)(v27 + v30) == *v31)
            {
              ++v31;
              ++v30;
              if (!--v96)
              {
                unint64_t v30 = v97;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v29 = 0;
          unint64_t v30 = v28 & 0x18;
          unint64_t v31 = &a2[v30];
          while (1)
          {
            uint64_t v32 = *(void *)&a2[v29];
            uint64_t v33 = *(void *)(v27 + v29);
            if (v32 != v33) {
              break;
            }
            v29 += 8;
            if ((v28 & 0xFFFFFFFFFFFFFFF8) == v29) {
              goto LABEL_241;
            }
          }
          unint64_t v30 = v29 + (__clz(__rbit64(v33 ^ v32)) >> 3);
        }
        if (v30 == v16)
        {
          unsigned int v34 = *(_DWORD *)(a5 + 4 * v16);
          if (v34 >= (v16 | (32 * v15))) {
            unsigned int v34 = v16 | (32 * v15);
          }
          *(_DWORD *)(a5 + 4 * v16) = v34;
          uint64_t v8 = 1;
        }
        unint64_t v35 = v16 - 1;
        if (v30 >= v16 - 1)
        {
          unsigned int v36 = v16 | (32 * ((12 << v17) + v15));
          if (*(_DWORD *)(a5 + 4 * v35) < v36) {
            unsigned int v36 = *(_DWORD *)(a5 + 4 * v35);
          }
          *(_DWORD *)(a5 + 4 * v35) = v36;
          if (v16 + 2 < a4 && a2[v35] == 105 && a2[v16] == 110 && a2[v16 + 1] == 103 && a2[v16 + 2] == 32)
          {
            unsigned int v37 = v16 | (32 * ((49 << v17) + v15));
            uint64_t v38 = a5 + 4 * v16;
            if (*(_DWORD *)(v38 + 12) < v37) {
              unsigned int v37 = *(_DWORD *)(v38 + 12);
            }
            *(_DWORD *)(v38 + 12) = v37;
          }
          uint64_t v8 = 1;
        }
        unint64_t v39 = v16 - 9;
        if (a3 > v16 - 9) {
          unint64_t v39 = a3;
        }
        if (v16 <= 9) {
          unint64_t v40 = a3;
        }
        else {
          unint64_t v40 = v39;
        }
        unint64_t v41 = v16 - 2;
        if (v30 < v16 - 2) {
          unint64_t v41 = v30;
        }
        if (v40 <= v41)
        {
          unint64_t v42 = a1[2];
          uint64_t v43 = v41 - v40 + 1;
          int v44 = 4 * v16 - 4 * v40;
          char v45 = 6 * v16 - 6 * v40;
          uint64_t v46 = (unsigned int *)(a5 + 4 * v40);
          do
          {
            unsigned int v47 = v16 | (32 * (((unint64_t)(v44 + ((v42 >> v45) & 0x3F)) << v17) + v15));
            if (*v46 < v47) {
              unsigned int v47 = *v46;
            }
            *v46++ = v47;
            v44 -= 4;
            v45 -= 6;
            --v43;
          }
          while (v43);
          uint64_t v8 = 1;
        }
        if (v30 >= v16)
        {
          unint64_t v48 = v16 + 6;
          if (v16 + 6 < a4)
          {
            unint64_t v49 = &a2[v16];
            unsigned int v50 = a2[v16];
            if (v50 > 0x3C)
            {
              switch(a2[v16])
              {
                case 'a':
                  if (v49[1] == 108 && v49[2] == 32)
                  {
                    unint64_t v48 = v16 + 3;
                    uint64_t v55 = 84;
                    goto LABEL_176;
                  }
                  break;
                case 'b':
                case 'c':
                case 'd':
                case 'g':
                case 'h':
                case 'j':
                case 'k':
                case 'm':
                case 'n':
                  goto LABEL_179;
                case 'e':
                  int v84 = v49[1];
                  if (v84 == 115)
                  {
                    if (v49[2] == 116 && v49[3] == 32)
                    {
                      unint64_t v48 = v16 + 4;
                      uint64_t v55 = 95;
                      goto LABEL_176;
                    }
                  }
                  else if (v84 == 114)
                  {
                    if (v49[2] == 32)
                    {
                      unint64_t v48 = v16 + 3;
                      uint64_t v55 = 82;
                      goto LABEL_176;
                    }
                  }
                  else if (v84 == 100 && v49[2] == 32)
                  {
                    unint64_t v48 = v16 + 3;
                    uint64_t v55 = 53;
                    goto LABEL_176;
                  }
                  break;
                case 'f':
                  if (v49[1] == 117 && v49[2] == 108 && v49[3] == 32)
                  {
                    unint64_t v48 = v16 + 4;
                    uint64_t v55 = 90;
                    goto LABEL_176;
                  }
                  break;
                case 'i':
                  int v85 = v49[1];
                  if (v85 == 122)
                  {
                    if (v49[2] == 101 && v49[3] == 32)
                    {
                      unint64_t v48 = v16 + 4;
                      uint64_t v55 = 100;
                      goto LABEL_176;
                    }
                  }
                  else if (v85 == 118 && v49[2] == 101 && v49[3] == 32)
                  {
                    unint64_t v48 = v16 + 4;
                    uint64_t v55 = 92;
                    goto LABEL_176;
                  }
                  break;
                case 'l':
                  int v86 = v49[1];
                  if (v86 == 121)
                  {
                    if (v49[2] == 32)
                    {
                      unint64_t v48 = v16 + 3;
                      uint64_t v55 = 61;
                      goto LABEL_176;
                    }
                  }
                  else if (v86 == 101 && v49[2] == 115 && v49[3] == 115 && v49[4] == 32)
                  {
                    unint64_t v48 = v16 + 5;
                    uint64_t v55 = 93;
                    goto LABEL_176;
                  }
                  break;
                case 'o':
                  if (v49[1] == 117 && v49[2] == 115 && v49[3] == 32)
                  {
                    unint64_t v48 = v16 + 4;
                    uint64_t v55 = 106;
                    goto LABEL_176;
                  }
                  break;
                default:
                  if (v50 == 61)
                  {
                    int v89 = v49[1];
                    if (v89 == 39)
                    {
                      unint64_t v48 = v16 + 2;
                      uint64_t v55 = 86;
                      goto LABEL_176;
                    }
                    if (v89 == 34)
                    {
                      unint64_t v48 = v16 + 2;
                      uint64_t v55 = 70;
                      goto LABEL_176;
                    }
                  }
                  else if (v50 == 93)
                  {
                    unint64_t v48 = v16 + 1;
                    uint64_t v55 = 24;
                    goto LABEL_176;
                  }
                  break;
              }
            }
            else
            {
              switch(a2[v16])
              {
                case ' ':
                  unsigned int v51 = v16 | (32 * ((1 << v17) + v15));
                  uint64_t v52 = a5 + 4 * v16;
                  if (*(_DWORD *)(v52 + 4) < v51) {
                    unsigned int v51 = *(_DWORD *)(v52 + 4);
                  }
                  *(_DWORD *)(v52 + 4) = v51;
                  int v53 = v49[1];
                  switch(v49[1])
                  {
                    case 'a':
                      unsigned int v54 = v49[2];
                      if (v54 > 0x72)
                      {
                        if (v54 == 115)
                        {
                          if (v49[3] == 32)
                          {
                            unint64_t v48 = v16 + 4;
                            uint64_t v55 = 46;
                            goto LABEL_176;
                          }
                        }
                        else if (v54 == 116 && v49[3] == 32)
                        {
                          unint64_t v48 = v16 + 4;
                          uint64_t v55 = 60;
                          goto LABEL_176;
                        }
                      }
                      else
                      {
                        if (v54 == 32)
                        {
                          unint64_t v48 = v16 + 3;
                          uint64_t v55 = 28;
                          goto LABEL_176;
                        }
                        if (v54 == 110 && v49[3] == 100 && v49[4] == 32)
                        {
                          unint64_t v48 = v16 + 5;
                          uint64_t v55 = 10;
                          goto LABEL_176;
                        }
                      }
                      break;
                    case 'b':
                      if (v49[2] == 121 && v49[3] == 32)
                      {
                        unint64_t v48 = v16 + 4;
                        uint64_t v55 = 38;
                        goto LABEL_176;
                      }
                      break;
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'g':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'm':
                      goto LABEL_179;
                    case 'f':
                      int v91 = v49[2];
                      if (v91 == 114)
                      {
                        if (v49[3] == 111 && v49[4] == 109 && v49[5] == 32)
                        {
                          uint64_t v55 = 37;
                          goto LABEL_176;
                        }
                      }
                      else if (v91 == 111 && v49[3] == 114 && v49[4] == 32)
                      {
                        unint64_t v48 = v16 + 5;
                        uint64_t v55 = 25;
                        goto LABEL_176;
                      }
                      break;
                    case 'i':
                      int v92 = v49[2];
                      if (v92 == 115)
                      {
                        if (v49[3] == 32)
                        {
                          unint64_t v48 = v16 + 4;
                          uint64_t v55 = 47;
                          goto LABEL_176;
                        }
                      }
                      else if (v92 == 110 && v49[3] == 32)
                      {
                        unint64_t v48 = v16 + 4;
                        uint64_t v55 = 16;
                        goto LABEL_176;
                      }
                      break;
                    case 'n':
                      if (v49[2] == 111 && v49[3] == 116 && v49[4] == 32)
                      {
                        unint64_t v48 = v16 + 5;
                        uint64_t v55 = 80;
                        goto LABEL_176;
                      }
                      break;
                    case 'o':
                      int v93 = v49[2];
                      if (v93 == 110)
                      {
                        if (v49[3] == 32)
                        {
                          unint64_t v48 = v16 + 4;
                          uint64_t v55 = 45;
                          goto LABEL_176;
                        }
                      }
                      else if (v93 == 102 && v49[3] == 32)
                      {
                        unint64_t v48 = v16 + 4;
                        uint64_t v55 = 8;
                        goto LABEL_176;
                      }
                      break;
                    default:
                      if (v53 == 116)
                      {
                        int v94 = v49[2];
                        if (v94 == 111)
                        {
                          if (v49[3] == 32)
                          {
                            unint64_t v48 = v16 + 4;
                            uint64_t v55 = 17;
                            goto LABEL_176;
                          }
                        }
                        else if (v94 == 104)
                        {
                          int v95 = v49[3];
                          if (v95 == 97)
                          {
                            if (v49[4] == 116 && v49[5] == 32)
                            {
                              uint64_t v55 = 29;
                              goto LABEL_176;
                            }
                          }
                          else if (v95 == 101 && v49[4] == 32)
                          {
                            unint64_t v48 = v16 + 5;
                            uint64_t v55 = 5;
                            goto LABEL_176;
                          }
                        }
                      }
                      else if (v53 == 119 && v49[2] == 105 && v49[3] == 116 && v49[4] == 104 && v49[5] == 32)
                      {
                        uint64_t v55 = 35;
                        goto LABEL_176;
                      }
                      break;
                  }
                  goto LABEL_179;
                case '!':
                case '#':
                case '$':
                case '%':
                case '&':
                case ')':
                case '*':
                case '+':
                case '-':
                  goto LABEL_179;
                case '""':
                  unsigned int v76 = v16 | (32 * ((19 << v17) + v15));
                  uint64_t v77 = a5 + 4 * v16;
                  if (*(_DWORD *)(v77 + 4) < v76) {
                    unsigned int v76 = *(_DWORD *)(v77 + 4);
                  }
                  *(_DWORD *)(v77 + 4) = v76;
                  if (v49[1] != 62) {
                    goto LABEL_179;
                  }
                  unint64_t v48 = v16 + 2;
                  uint64_t v55 = 21;
                  goto LABEL_176;
                case '\'':
                  unint64_t v48 = v16 + 1;
                  uint64_t v55 = 36;
                  goto LABEL_176;
                case '(':
                  unint64_t v48 = v16 + 1;
                  uint64_t v55 = 57;
                  goto LABEL_176;
                case ',':
                  unsigned int v78 = v16 | (32 * ((76 << v17) + v15));
                  uint64_t v79 = a5 + 4 * v16;
                  if (*(_DWORD *)(v79 + 4) < v78) {
                    unsigned int v78 = *(_DWORD *)(v79 + 4);
                  }
                  *(_DWORD *)(v79 + 4) = v78;
                  if (v49[1] != 32) {
                    goto LABEL_179;
                  }
                  unint64_t v48 = v16 + 2;
                  uint64_t v55 = 14;
                  goto LABEL_176;
                case '.':
                  unsigned int v80 = v16 | (32 * ((20 << v17) + v15));
                  uint64_t v81 = a5 + 4 * v16;
                  if (*(_DWORD *)(v81 + 4) < v80) {
                    unsigned int v80 = *(_DWORD *)(v81 + 4);
                  }
                  *(_DWORD *)(v81 + 4) = v80;
                  if (v49[1] != 32) {
                    goto LABEL_179;
                  }
                  unsigned int v82 = v16 | (32 * ((31 << v17) + v15));
                  if (*(_DWORD *)(v81 + 8) < v82) {
                    unsigned int v82 = *(_DWORD *)(v81 + 8);
                  }
                  *(_DWORD *)(v81 + 8) = v82;
                  if (v49[2] != 84 || v49[3] != 104) {
                    goto LABEL_179;
                  }
                  int v83 = v49[4];
                  if (v83 == 105)
                  {
                    if (v49[5] == 115 && v49[6] == 32)
                    {
                      unint64_t v48 = v16 + 7;
                      uint64_t v55 = 75;
                      goto LABEL_176;
                    }
                  }
                  else if (v83 == 101 && v49[5] == 32)
                  {
                    uint64_t v55 = 43;
                    goto LABEL_176;
                  }
                  goto LABEL_179;
                default:
                  if (v50 != 10)
                  {
                    if (v50 != 58) {
                      goto LABEL_179;
                    }
                    unint64_t v48 = v16 + 1;
                    uint64_t v55 = 51;
                    goto LABEL_176;
                  }
                  unsigned int v87 = v16 | (32 * ((22 << v17) + v15));
                  uint64_t v88 = a5 + 4 * v16;
                  if (*(_DWORD *)(v88 + 4) < v87) {
                    unsigned int v87 = *(_DWORD *)(v88 + 4);
                  }
                  *(_DWORD *)(v88 + 4) = v87;
                  if (v49[1] == 9)
                  {
                    unint64_t v48 = v16 + 2;
                    uint64_t v55 = 50;
                    goto LABEL_176;
                  }
                  break;
              }
            }
          }
        }
        goto LABEL_179;
      }
      if (v16 <= a4)
      {
        uint64_t v18 = (unsigned __int8 *)(*(void *)(v11 + 168)
                                + *(unsigned int *)(v11 + 4 * (*v12 & 0x1F) + 32)
                                + *((unsigned __int16 *)v12 + 1) * (unint64_t)(*v12 & 0x1F));
        if (v14 == 10)
        {
          int v19 = *v18;
          if ((v19 - 97) > 0x19 || (v19 ^ 0x20) != *a2) {
            goto LABEL_179;
          }
          int v20 = v16 - 1;
          unint64_t v21 = (v16 - 1);
          if (v21 < 8)
          {
            uint64_t v23 = 0;
            unint64_t v24 = a2 + 1;
LABEL_255:
            uint64_t v98 = v20 & 7;
            if (v98)
            {
              uint64_t v99 = v23 | v98;
              uint64_t v100 = v23 + 1;
              while (v18[v100] == *v24)
              {
                ++v24;
                ++v100;
                if (!--v98)
                {
                  uint64_t v23 = v99;
                  goto LABEL_80;
                }
              }
              uint64_t v23 = v100 - 1;
            }
          }
          else
          {
            uint64_t v22 = 0;
            uint64_t v23 = v20 & 0xFFFFFFF8;
            unint64_t v24 = &v9[v23];
            while (1)
            {
              uint64_t v25 = *(void *)&v9[v22];
              uint64_t v26 = *(void *)&v18[v22 + 1];
              if (v25 != v26) {
                break;
              }
              v22 += 8;
              if ((v21 & 0xFFFFFFF8) == v22) {
                goto LABEL_255;
              }
            }
            uint64_t v23 = v22 + (__clz(__rbit64(v26 ^ v25)) >> 3);
          }
LABEL_80:
          if (v23 != v21) {
            goto LABEL_179;
          }
          uint64_t v60 = 9;
        }
        else
        {
          uint64_t v56 = v13 & 0x1F;
          unint64_t v57 = a2;
          if (v16)
          {
            do
            {
              int v59 = *v18++;
              int v58 = v59;
              if ((v59 - 97) <= 0x19) {
                v58 ^= 0x20u;
              }
              if (v58 != *v57) {
                goto LABEL_179;
              }
              ++v57;
            }
            while (--v56);
          }
          uint64_t v60 = 44;
        }
        unsigned int v61 = v16 | (32 * ((v60 << v17) + v15));
        if (*(_DWORD *)(a5 + 4 * v16) < v61) {
          unsigned int v61 = *(_DWORD *)(a5 + 4 * v16);
        }
        *(_DWORD *)(a5 + 4 * v16) = v61;
        unint64_t v48 = v16 + 1;
        if (v16 + 1 >= a4)
        {
LABEL_117:
          uint64_t v8 = 1;
        }
        else
        {
          uint64_t v62 = &a2[v16];
          uint64_t v8 = 1;
          switch(a2[v16])
          {
            case ' ':
              BOOL v63 = v14 == 10;
              uint64_t v64 = 68;
              uint64_t v65 = 4;
              goto LABEL_102;
            case '!':
            case '#':
            case '$':
            case '%':
            case '&':
            case ')':
            case '*':
            case '+':
            case '-':
              goto LABEL_179;
            case '""':
              uint64_t v67 = 87;
              if (v14 == 10) {
                uint64_t v67 = 66;
              }
              unsigned int v68 = v16 | (32 * ((v67 << v17) + v15));
              if (*(_DWORD *)(a5 + 4 * v48) < v68) {
                unsigned int v68 = *(_DWORD *)(a5 + 4 * v48);
              }
              *(_DWORD *)(a5 + 4 * v48) = v68;
              if (v62[1] != 62) {
                goto LABEL_117;
              }
              BOOL v69 = v14 == 10;
              uint64_t v70 = 97;
              uint64_t v71 = 69;
              goto LABEL_171;
            case '\'':
              BOOL v63 = v14 == 10;
              uint64_t v64 = 94;
              uint64_t v65 = 74;
              goto LABEL_102;
            case '(':
              BOOL v63 = v14 == 10;
              uint64_t v64 = 113;
              uint64_t v65 = 78;
LABEL_102:
              if (v63) {
                uint64_t v55 = v65;
              }
              else {
                uint64_t v55 = v64;
              }
              goto LABEL_175;
            case ',':
              uint64_t v72 = 112;
              if (v14 == 10) {
                uint64_t v72 = 99;
              }
              unsigned int v73 = v16 | (32 * ((v72 << v17) + v15));
              if (*(_DWORD *)(a5 + 4 * v48) < v73) {
                unsigned int v73 = *(_DWORD *)(a5 + 4 * v48);
              }
              *(_DWORD *)(a5 + 4 * v48) = v73;
              if (v62[1] != 32) {
                goto LABEL_117;
              }
              BOOL v69 = v14 == 10;
              uint64_t v70 = 107;
              uint64_t v71 = 58;
              goto LABEL_171;
            case '.':
              uint64_t v74 = 101;
              if (v14 == 10) {
                uint64_t v74 = 79;
              }
              unsigned int v75 = v16 | (32 * ((v74 << v17) + v15));
              if (*(_DWORD *)(a5 + 4 * v48) < v75) {
                unsigned int v75 = *(_DWORD *)(a5 + 4 * v48);
              }
              *(_DWORD *)(a5 + 4 * v48) = v75;
              if (v62[1] != 32) {
                goto LABEL_117;
              }
              BOOL v69 = v14 == 10;
              uint64_t v70 = 114;
              uint64_t v71 = 88;
              goto LABEL_171;
            default:
              if (a2[v16] != 61) {
                goto LABEL_179;
              }
              int v66 = v62[1];
              if (v66 == 39)
              {
                BOOL v69 = v14 == 10;
                uint64_t v70 = 116;
                uint64_t v71 = 108;
LABEL_171:
                if (v69) {
                  uint64_t v55 = v71;
                }
                else {
                  uint64_t v55 = v70;
                }
              }
              else
              {
                if (v66 != 34) {
                  goto LABEL_117;
                }
                if (v14 == 10) {
                  uint64_t v55 = 104;
                }
                else {
                  uint64_t v55 = 105;
                }
              }
              unint64_t v48 = v16 + 2;
LABEL_175:
              uint64_t v8 = 1;
              break;
          }
LABEL_176:
          unsigned int v90 = v16 | (32 * ((v55 << v17) + v15));
          if (*(_DWORD *)(a5 + 4 * v48) < v90) {
            unsigned int v90 = *(_DWORD *)(a5 + 4 * v48);
          }
          *(_DWORD *)(a5 + 4 * v48) = v90;
        }
      }
LABEL_179:
      ++v7;
      if (v13 < 0) {
        goto LABEL_262;
      }
    }
  }
  uint64_t v8 = 0;
LABEL_262:
  unint64_t v101 = a4 - 5;
  if (a4 < 5) {
    return v8;
  }
  int v102 = *a2;
  if (v102 == 46 || v102 == 32)
  {
    uint64_t v103 = a2 + 1;
    uint64_t v104 = *(unsigned __int16 *)(v5 + 2 * ((506832829 * *(_DWORD *)(a2 + 1)) >> 17));
    if (v104)
    {
      unint64_t v105 = a4 - 1;
      uint64_t v106 = a1[6];
      uint64_t v107 = *a1;
      if (v102 == 32) {
        uint64_t v108 = 6;
      }
      else {
        uint64_t v108 = 32;
      }
      if (v102 == 32) {
        uint64_t v109 = 89;
      }
      else {
        uint64_t v109 = 67;
      }
      if (v102 == 32) {
        uint64_t v110 = 2;
      }
      else {
        uint64_t v110 = 77;
      }
      while (1)
      {
        unint64_t v111 = (char *)(v106 + 4 * v104);
        char v112 = *v111;
        int v113 = v111[1];
        int v114 = *((unsigned __int16 *)v111 + 1);
        unint64_t v115 = *v111 & 0x1F;
        char v116 = *(unsigned char *)(v107 + v115);
        if (!v111[1]) {
          break;
        }
        if (v102 != 32 || v105 < v115) {
          goto LABEL_351;
        }
        unint64_t v117 = (unsigned __int8 *)(*(void *)(v107 + 168)
                                 + *(unsigned int *)(v107 + 4 * (*v111 & 0x1F) + 32)
                                 + *((unsigned __int16 *)v111 + 1) * (unint64_t)(*v111 & 0x1F));
        if (v113 == 10)
        {
          int v118 = *v117;
          if ((v118 - 97) > 0x19 || (v118 ^ 0x20) != *v103) {
            goto LABEL_351;
          }
          uint64_t v119 = v108;
          unint64_t v120 = v101;
          uint64_t v121 = v110;
          int v122 = v115 - 1;
          unint64_t v123 = (v115 - 1);
          if (v123 < 8)
          {
            uint64_t v125 = 0;
            unint64_t v221 = a2 + 2;
LABEL_371:
            uint64_t v163 = v122 & 7;
            if (v163)
            {
              uint64_t v164 = v125 | v163;
              uint64_t v165 = v125 + 1;
              uint64_t v166 = v221;
              while (v117[v165] == *v166)
              {
                ++v166;
                ++v165;
                if (!--v163)
                {
                  uint64_t v125 = v164;
                  goto LABEL_319;
                }
              }
              uint64_t v125 = v165 - 1;
            }
          }
          else
          {
            uint64_t v124 = 0;
            uint64_t v125 = v122 & 0xFFFFFFF8;
            unint64_t v126 = a2 + 2;
            unint64_t v221 = &a2[v125 + 2];
            while (1)
            {
              uint64_t v127 = *(void *)&v126[v124];
              uint64_t v128 = *(void *)&v117[v124 + 1];
              if (v127 != v128) {
                break;
              }
              v124 += 8;
              unint64_t v126 = a2 + 2;
              if ((v123 & 0xFFFFFFF8) == v124) {
                goto LABEL_371;
              }
            }
            uint64_t v125 = v124 + (__clz(__rbit64(v128 ^ v127)) >> 3);
          }
LABEL_319:
          uint64_t v110 = v121;
          unint64_t v101 = v120;
          uint64_t v108 = v119;
          if (v125 != v123) {
            goto LABEL_351;
          }
          uint64_t v145 = 30;
        }
        else
        {
          uint64_t v141 = v112 & 0x1F;
          uint64_t v142 = a2 + 1;
          if (v115)
          {
            do
            {
              int v144 = *v117++;
              int v143 = v144;
              if ((v144 - 97) <= 0x19) {
                v143 ^= 0x20u;
              }
              if (v143 != *v142) {
                goto LABEL_351;
              }
              ++v142;
            }
            while (--v141);
          }
          uint64_t v145 = 85;
        }
        int v146 = (v145 << v116) + v114;
        unint64_t v147 = v115 + 1;
        unsigned int v148 = v115 | (32 * v146);
        if (*(_DWORD *)(a5 + 4 * (v115 + 1)) < v148) {
          unsigned int v148 = *(_DWORD *)(a5 + 4 * (v115 + 1));
        }
        *(_DWORD *)(a5 + 4 * v147) = v148;
        unint64_t v137 = v115 + 2;
        if (v115 + 2 >= a4) {
          goto LABEL_350;
        }
        unint64_t v149 = &a2[v147];
        int v150 = a2[v147];
        uint64_t v8 = 1;
        if (v150 > 45)
        {
          if (v150 == 46)
          {
            uint64_t v156 = 115;
            if (v113 == 10) {
              uint64_t v156 = 96;
            }
            unsigned int v157 = v115 | (32 * ((v156 << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v157) {
              unsigned int v157 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v157;
            if (v149[1] == 32)
            {
              BOOL v152 = v113 == 10;
              uint64_t v140 = 117;
              uint64_t v153 = 91;
              goto LABEL_344;
            }
            goto LABEL_350;
          }
          if (v150 == 61)
          {
            int v154 = v149[1];
            if (v154 != 39)
            {
              if (v154 == 34)
              {
                BOOL v152 = v113 == 10;
                uint64_t v140 = 110;
                uint64_t v153 = 118;
                goto LABEL_344;
              }
LABEL_350:
              uint64_t v8 = 1;
              goto LABEL_351;
            }
            uint64_t v140 = 119;
            if (v113 == 10) {
              uint64_t v140 = 120;
            }
LABEL_346:
            unint64_t v137 = v115 + 3;
LABEL_347:
            unsigned int v158 = v115 | (32 * ((v140 << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v158) {
              unsigned int v158 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v158;
            goto LABEL_350;
          }
        }
        else
        {
          if (v150 == 32)
          {
            uint64_t v140 = 83;
            if (v113 == 10) {
              uint64_t v140 = 15;
            }
            goto LABEL_347;
          }
          if (v150 == 44)
          {
            if (v113 == 10)
            {
              unsigned int v151 = v115 | (32 * ((109 << v116) + v114));
              if (*(_DWORD *)(a5 + 4 * v137) < v151) {
                unsigned int v151 = *(_DWORD *)(a5 + 4 * v137);
              }
              *(_DWORD *)(a5 + 4 * v137) = v151;
            }
            if (v149[1] != 32) {
              goto LABEL_350;
            }
            BOOL v152 = v113 == 10;
            uint64_t v140 = 111;
            uint64_t v153 = 65;
LABEL_344:
            if (v152) {
              uint64_t v140 = v153;
            }
            goto LABEL_346;
          }
        }
LABEL_351:
        ++v104;
        if (v112 < 0) {
          goto LABEL_377;
        }
      }
      if (v105 < v115) {
        goto LABEL_351;
      }
      unint64_t v129 = *(void *)(v107 + 168)
           + *(unsigned int *)(v107 + 4 * (*v111 & 0x1F) + 32)
           + *((unsigned __int16 *)v111 + 1) * (unint64_t)(*v111 & 0x1F);
      if (v115 < 8)
      {
        unint64_t v131 = 0;
        unint64_t v132 = a2 + 1;
LABEL_365:
        unint64_t v161 = v115 & 7;
        if ((v115 & 7) != 0)
        {
          uint64_t v162 = v131 | v161;
          while (*(unsigned __int8 *)(v129 + v131) == *v132)
          {
            ++v132;
            ++v131;
            if (!--v161)
            {
              unint64_t v131 = v162;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v130 = 0;
        unint64_t v131 = v115 & 0x18;
        unint64_t v132 = &v103[v131];
        while (1)
        {
          uint64_t v133 = *(void *)&v103[v130];
          uint64_t v134 = *(void *)(v129 + v130);
          if (v133 != v134) {
            break;
          }
          v130 += 8;
          if (v131 == v130) {
            goto LABEL_365;
          }
        }
        unint64_t v131 = v130 + (__clz(__rbit64(v134 ^ v133)) >> 3);
      }
      if (v131 != v115) {
        goto LABEL_351;
      }
      unint64_t v135 = v115 + 1;
      unsigned int v136 = v115 | (32 * ((v108 << v116) + v114));
      if (*(_DWORD *)(a5 + 4 * (v115 + 1)) < v136) {
        unsigned int v136 = *(_DWORD *)(a5 + 4 * (v115 + 1));
      }
      *(_DWORD *)(a5 + 4 * v135) = v136;
      unint64_t v137 = v115 + 2;
      if (v115 + 2 >= a4) {
        goto LABEL_350;
      }
      uint64_t v138 = &a2[v135];
      int v139 = *v138;
      if (v139 == 32)
      {
        uint64_t v140 = v110;
      }
      else if (v139 == 40)
      {
        uint64_t v140 = v109;
      }
      else
      {
        if (v102 != 32) {
          goto LABEL_350;
        }
        switch(v139)
        {
          case '=':
            int v159 = v138[1];
            if (v159 == 39)
            {
              unint64_t v137 = v115 + 3;
              uint64_t v140 = 98;
            }
            else
            {
              if (v159 != 34) {
                goto LABEL_350;
              }
              unint64_t v137 = v115 + 3;
              uint64_t v140 = 81;
            }
            break;
          case '.':
            unsigned int v160 = v115 | (32 * ((71 << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v160) {
              unsigned int v160 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v160;
            if (v138[1] != 32) {
              goto LABEL_350;
            }
            unint64_t v137 = v115 + 3;
            uint64_t v140 = 52;
            break;
          case ',':
            unsigned int v155 = v115 | (32 * ((103 << v116) + v114));
            if (*(_DWORD *)(a5 + 4 * v137) < v155) {
              unsigned int v155 = *(_DWORD *)(a5 + 4 * v137);
            }
            *(_DWORD *)(a5 + 4 * v137) = v155;
            if (v138[1] != 32) {
              goto LABEL_350;
            }
            unint64_t v137 = v115 + 3;
            uint64_t v140 = 33;
            break;
          default:
            goto LABEL_350;
        }
      }
      goto LABEL_347;
    }
  }
LABEL_377:
  if (a4 < 6) {
    return v8;
  }
  int v167 = a2[1];
  int v168 = *a2;
  if (v167 == 32)
  {
    if (v168 != 44 && v168 != 101 && v168 != 115) {
      goto LABEL_420;
    }
  }
  else if (v167 != 160 || v168 != 194)
  {
    goto LABEL_420;
  }
  uint64_t v169 = a1[5];
  BOOL v170 = a2 + 2;
  uint64_t v171 = *(unsigned __int16 *)(v169 + 2 * ((506832829 * *(_DWORD *)(a2 + 2)) >> 17));
  if (*(_WORD *)(v169 + 2 * ((506832829 * *(_DWORD *)(a2 + 2)) >> 17)))
  {
    uint64_t v172 = a1[6];
    uint64_t v173 = *a1;
    while (1)
    {
      unint64_t v174 = (char *)(v172 + 4 * v171);
      char v175 = *v174;
      unint64_t v176 = *v174 & 0x1F;
      if (v174[1]) {
        BOOL v177 = 0;
      }
      else {
        BOOL v177 = a4 - 2 >= v176;
      }
      if (!v177) {
        goto LABEL_412;
      }
      int v178 = *((unsigned __int16 *)v174 + 1);
      unint64_t v179 = *(void *)(v173 + 168)
           + *(unsigned int *)(v173 + 4 * (*v174 & 0x1F) + 32)
           + *((unsigned __int16 *)v174 + 1) * (unint64_t)(*v174 & 0x1F);
      if (v176 < 8)
      {
        unint64_t v181 = 0;
        uint64_t v182 = a2 + 2;
LABEL_415:
        unint64_t v190 = v176 & 7;
        if ((v176 & 7) != 0)
        {
          unint64_t v191 = v181 | v190;
          while (*(unsigned __int8 *)(v179 + v181) == *v182)
          {
            ++v182;
            ++v181;
            if (!--v190)
            {
              unint64_t v181 = v191;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v180 = 0;
        unint64_t v181 = *v174 & 0x18;
        uint64_t v182 = &v170[v181];
        while (1)
        {
          uint64_t v183 = *(void *)&v170[v180];
          uint64_t v184 = *(void *)(v179 + v180);
          if (v183 != v184) {
            break;
          }
          v180 += 8;
          if (v181 == v180) {
            goto LABEL_415;
          }
        }
        unint64_t v181 = v180 + (__clz(__rbit64(v184 ^ v183)) >> 3);
      }
      if (v181 != v176) {
        goto LABEL_412;
      }
      int v185 = *a2;
      if (v185 == 194) {
        break;
      }
      if (v176 + 2 < a4 && a2[v176 + 2] == 32)
      {
        if (v185 == 115) {
          uint64_t v186 = 7;
        }
        else {
          uint64_t v186 = 13;
        }
        if (v185 == 101) {
          uint64_t v186 = 18;
        }
        uint64_t v187 = 3;
        goto LABEL_401;
      }
LABEL_412:
      ++v171;
      if (v175 < 0) {
        goto LABEL_420;
      }
    }
    uint64_t v186 = 102;
    uint64_t v187 = 2;
LABEL_401:
    unint64_t v188 = v187 + v176;
    unsigned int v189 = v176 | (32 * ((v186 << *(unsigned char *)(v173 + v176)) + v178));
    if (*(_DWORD *)(a5 + 4 * v188) < v189) {
      unsigned int v189 = *(_DWORD *)(a5 + 4 * v188);
    }
    *(_DWORD *)(a5 + 4 * v188) = v189;
    uint64_t v8 = 1;
    goto LABEL_412;
  }
LABEL_420:
  if (a4 < 9) {
    return v8;
  }
  int v192 = *a2;
  if (v192 != 46)
  {
    if (v192 != 32 || a2[1] != 116 || a2[2] != 104 || a2[3] != 101 || a2[4] != 32) {
      return v8;
    }
    goto LABEL_432;
  }
  if (a2[1] == 99 && a2[2] == 111 && a2[3] == 109 && a2[4] == 47)
  {
LABEL_432:
    unint64_t v193 = a2 + 5;
    unsigned int v194 = (506832829 * *(_DWORD *)(a2 + 5)) >> 17;
    uint64_t v195 = *(unsigned __int16 *)(a1[5] + 2 * v194);
    if (!*(_WORD *)(a1[5] + 2 * v194)) {
      return v8;
    }
    uint64_t v196 = a1[6];
    uint64_t v197 = *a1;
    do
    {
      int v198 = (char *)(v196 + 4 * v195);
      char v199 = *v198;
      unint64_t v200 = *v198 & 0x1F;
      if (v198[1]) {
        BOOL v201 = 0;
      }
      else {
        BOOL v201 = v101 >= v200;
      }
      if (!v201) {
        goto LABEL_469;
      }
      unsigned int v202 = *((unsigned __int16 *)v198 + 1);
      unint64_t v203 = *(void *)(v197 + 168)
           + *(unsigned int *)(v197 + 4 * v200 + 32)
           + v202 * (unint64_t)v200;
      if (v200 < 8)
      {
        unint64_t v205 = 0;
        int32x4_t v206 = a2 + 5;
LABEL_472:
        unint64_t v218 = v200 & 7;
        if ((v200 & 7) != 0)
        {
          uint64_t v219 = v205 | v218;
          while (*(unsigned __int8 *)(v203 + v205) == *v206)
          {
            ++v206;
            ++v205;
            if (!--v218)
            {
              unint64_t v205 = v219;
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v204 = 0;
        unint64_t v205 = v200 & 0x18;
        int32x4_t v206 = &v193[v205];
        while (1)
        {
          uint64_t v207 = *(void *)&v193[v204];
          uint64_t v208 = *(void *)(v203 + v204);
          if (v207 != v208) {
            break;
          }
          v204 += 8;
          if (v205 == v204) {
            goto LABEL_472;
          }
        }
        unint64_t v205 = v204 + (__clz(__rbit64(v208 ^ v207)) >> 3);
      }
      if (v205 != v200) {
        goto LABEL_469;
      }
      char v209 = *(unsigned char *)(v197 + v200);
      if (*a2 == 32) {
        uint64_t v210 = 41;
      }
      else {
        uint64_t v210 = 72;
      }
      unint64_t v211 = v200 + 5;
      unsigned int v212 = v200 | (32 * ((v210 << v209) + v202));
      if (*(_DWORD *)(a5 + 4 * (v200 + 5)) < v212) {
        unsigned int v212 = *(_DWORD *)(a5 + 4 * (v200 + 5));
      }
      *(_DWORD *)(a5 + 4 * v211) = v212;
      if (v211 < a4)
      {
        uint64_t v8 = 1;
        if (*a2 != 32 || v200 + 8 >= a4) {
          goto LABEL_469;
        }
        unint64_t v213 = &a2[v211];
        if (a2[v211] == 32 && v213[1] == 111 && v213[2] == 102 && v213[3] == 32)
        {
          unsigned int v214 = v200 | (32 * ((62 << v209) + v202));
          uint64_t v215 = a5 + 4 * v200;
          if (*(_DWORD *)(v215 + 36) < v214) {
            unsigned int v214 = *(_DWORD *)(v215 + 36);
          }
          *(_DWORD *)(v215 + 36) = v214;
          if (v200 + 12 < a4 && v213[4] == 116 && v213[5] == 104 && v213[6] == 101 && v213[7] == 32)
          {
            unsigned int v216 = v200 | (32 * ((73 << v209) + v202));
            uint64_t v217 = a5 + 4 * v200;
            if (*(_DWORD *)(v217 + 52) < v216) {
              unsigned int v216 = *(_DWORD *)(v217 + 52);
            }
            *(_DWORD *)(v217 + 52) = v216;
          }
        }
      }
      uint64_t v8 = 1;
LABEL_469:
      ++v195;
    }
    while ((v199 & 0x80) == 0);
  }
  return v8;
}

uint64_t lzfseStreamEncodeStateSize(int a1)
{
  return lzfseEncodeGetScratchSize(a1) + 1573080;
}

uint64_t lzfseStreamEncodeInit(uint64_t a1, int a2, int a3)
{
  if (!a3)
  {
    *(void *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  int ScratchSize = lzfseEncodeGetScratchSize(a2);
  unsigned int v6 = realloc_stream_state(*(_DWORD **)(a1 + 32), 0, a2, ScratchSize + 1573080, ScratchSize + 1572864);
  *(void *)(a1 + 32) = v6;
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  uint64_t result = 0;
  v7[8] = 216;
  v7[13] = 786648;
  v7[14] = 786648;
  v7[15] = 1573080;
  v7[2] = 216;
  v7[3] = 786648;
  v7[4] = 1573080;
  return result;
}

uint64_t lzfseStreamEncode(uint64_t a1, char a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = (uint64_t *)(v3 + 64);
  *(void *)(v3 + 64) += v3;
  int64x2_t v5 = vdupq_n_s64(v3);
  *(int64x2_t *)(v3 + 104) = vaddq_s64(v5, *(int64x2_t *)(v3 + 104));
  *(void *)(v3 + 120) += v3;
  int64x2_t v37 = v5;
  *(int64x2_t *)(v3 + 16) = vaddq_s64(v5, *(int64x2_t *)(v3 + 16));
  *(void *)(v3 + 32) += v3;
  if (a2) {
    *(_DWORD *)(v3 + 44) = 1;
  }
  while (1)
  {
    if (*(_DWORD *)(v3 + 48))
    {
      int64_t v6 = 0;
    }
    else
    {
      uint64_t v7 = *(void *)(v3 + 72);
      unint64_t v8 = *(void *)(a1 + 24);
      if (v8 >= 786432 - v7) {
        int64_t v6 = 786432 - v7;
      }
      else {
        int64_t v6 = *(void *)(a1 + 24);
      }
      if (v6 >= 1)
      {
        memcpy((void *)(*(void *)(v3 + 16) + v7), *(const void **)(a1 + 16), v6);
        *(void *)(v3 + 72) += v6;
        unint64_t v8 = *(void *)(a1 + 24) - v6;
        *(void *)(a1 + 16) += v6;
        *(void *)(a1 + 24) = v8;
      }
      if (!v8 && *(_DWORD *)(v3 + 44)) {
        *(_DWORD *)(v3 + 48) = 1;
      }
    }
    uint64_t v9 = *(char **)(v3 + 112);
    uint64_t v10 = *(char **)(v3 + 24);
    if (v9 >= v10 + 393216)
    {
      uint64_t v11 = *(unsigned char **)(v3 + 104);
      uint64_t v12 = v11 - v9;
      if (v11 != v9)
      {
        memmove(v10, v9, v11 - v9);
        uint64_t v10 = *(char **)(v3 + 24);
      }
      *(void *)(v3 + 104) = &v10[v12];
      *(void *)(v3 + 112) = v10;
    }
    if (*(_DWORD *)(v3 + 48)) {
      break;
    }
    if (!*(_DWORD *)(v3 + 40) && *(uint64_t *)(v3 + 72) < 4096) {
      goto LABEL_42;
    }
LABEL_28:
    if (!*(_DWORD *)(v3 + 52))
    {
LABEL_29:
      if (*(_DWORD *)(v3 + 40))
      {
LABEL_30:
        lzfseEncodeSetStateScratch((uint64_t)v4, *(void *)(v3 + 32));
      }
      else
      {
LABEL_31:
        lzfseEncodeInitState((uint64_t)v4, *(_DWORD *)(v3 + 4), *(void *)(v3 + 32));
        *(_DWORD *)(v3 + 40) = 1;
      }
      uint64_t v25 = *(void *)(v3 + 72);
      *(void *)(v3 + 96) = v25 - 400;
      if (*(_DWORD *)(v3 + 48)) {
        *(void *)(v3 + 96) = v25 - 8;
      }
      lzfseEncodeBase((uint64_t)v4);
      if (*(_DWORD *)(v3 + 48) && *(void *)(v3 + 88) >= *(void *)(v3 + 72) - 8)
      {
        *(_DWORD *)(v3 + 52) = 1;
      }
      else if (!*(_DWORD *)(v3 + 52))
      {
        goto LABEL_42;
      }
    }
LABEL_39:
    if (!*(_DWORD *)(v3 + 56) && !lzfseEncodeFinish(v4)) {
      goto LABEL_41;
    }
LABEL_42:
    if (*(_DWORD *)(v3 + 60))
    {
      if (*(_DWORD *)(v3 + 56)) {
        goto LABEL_66;
      }
      int64_t v26 = 0;
    }
    else
    {
      unint64_t v27 = *(const void **)(v3 + 112);
      if (*(void *)(a1 + 8) >= *(void *)(v3 + 104) - (void)v27) {
        int64_t v26 = *(void *)(v3 + 104) - (void)v27;
      }
      else {
        int64_t v26 = *(void *)(a1 + 8);
      }
      if (v26 >= 1)
      {
        memcpy(*(void **)a1, v27, v26);
        unint64_t v27 = (const void *)(*(void *)(v3 + 112) + v26);
        *(void *)(v3 + 112) = v27;
        int64_t v28 = *(void *)(a1 + 8) - v26;
        *(void *)a1 += v26;
        *(void *)(a1 + 8) = v28;
      }
      if (*(_DWORD *)(v3 + 56))
      {
        if (v27 == *(const void **)(v3 + 104))
        {
          char v32 = 0;
          *(_DWORD *)(v3 + 60) = 1;
          goto LABEL_68;
        }
        if (*(_DWORD *)(v3 + 60))
        {
LABEL_66:
          char v32 = 0;
          goto LABEL_68;
        }
      }
    }
    uint64_t v29 = *(void *)(v3 + 72);
    if (v29 >= 393216)
    {
      uint64_t v30 = *(void *)(v3 + 88);
      int64_t v31 = v30 > 0x80000 ? v30 - 0x40000 : 0;
      if (v31 >= 1)
      {
        lzfseEncodeTranslateState((uint64_t)v4, v31);
        if (v29 > (unint64_t)v31) {
          memmove(*(void **)(v3 + 16), (const void *)(*(void *)(v3 + 16) + v31), v29 - v31);
        }
        *(void *)(v3 + 64) = *(void *)(v3 + 16);
      }
    }
    char v32 = v26 | v6;
    if (!(v26 | v6)) {
      goto LABEL_68;
    }
  }
  if (*(_DWORD *)(v3 + 52)) {
    goto LABEL_39;
  }
  if (*(_DWORD *)(v3 + 40)) {
    goto LABEL_30;
  }
  int64_t v13 = *(void *)(v3 + 72);
  if (v13 > 4095) {
    goto LABEL_31;
  }
  unint64_t v14 = *(void *)(v3 + 120);
  uint64_t v15 = *(void *)(v3 + 104);
  if (v14 <= v15 + 16) {
    goto LABEL_29;
  }
  size_t v16 = lzvn_encode_scratch_size(2304);
  char v17 = (int8x16_t *)malloc(v16);
  if (v17)
  {
    uint64_t v18 = v17;
    unint64_t v19 = v14 - v15;
    int v20 = lzvn_encode_buffer((char *)(*(void *)(v3 + 104) + 12), v19 - 16, *(const float **)(v3 + 64), v13, v17, 2304);
    free(v18);
    if (v20 && (unint64_t)v20 < v13)
    {
      unint64_t v21 = *(_DWORD **)(v3 + 104);
      *unint64_t v21 = 1853388386;
      v21[1] = v13;
      v21[2] = v20;
      uint64_t v22 = &v20[*(void *)(v3 + 104)];
      *((_DWORD *)v22 + 3) = 611874402;
      uint64_t v23 = *(void *)(v3 + 72);
      *(void *)(v3 + 80) = v23;
      *(void *)(v3 + 88) = v23;
      unint64_t v24 = v22 + 16;
LABEL_65:
      *(void *)(v3 + 96) = v23;
      *(void *)(v3 + 104) = v24;
      *(_DWORD *)(v3 + 52) = 1;
LABEL_41:
      *(_DWORD *)(v3 + 56) = 1;
      goto LABEL_42;
    }
    if (v19 >= v13 + 12)
    {
      uint64_t v33 = *(_DWORD **)(v3 + 104);
      _DWORD *v33 = 762869346;
      v33[1] = v13;
      unsigned int v34 = (void *)(*(void *)(v3 + 104) + 8);
      *(void *)(v3 + 104) = v34;
      memcpy(v34, *(const void **)(v3 + 64), v13);
      unint64_t v35 = (_DWORD *)(*(void *)(v3 + 104) + v13);
      *unint64_t v35 = 611874402;
      unint64_t v24 = v35 + 1;
      uint64_t v23 = *(void *)(v3 + 72);
      *(void *)(v3 + 80) = v23;
      *(void *)(v3 + 88) = v23;
      goto LABEL_65;
    }
    goto LABEL_28;
  }
  char v32 = 1;
LABEL_68:
  *(void *)(v3 + 64) -= v3;
  *(int64x2_t *)(v3 + 104) = vsubq_s64(*(int64x2_t *)(v3 + 104), v37);
  *(void *)(v3 + 120) -= v3;
  *(int64x2_t *)(v3 + 16) = vsubq_s64(*(int64x2_t *)(v3 + 16), v37);
  *(void *)(v3 + 32) -= v3;
  if (v32) {
    return 0xFFFFFFFFLL;
  }
  return *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 60);
}

_DWORD *yzip_codec_create(int a1)
{
  uint64_t result = calloc(1uLL, 0x28uLL);
  if (result) {
    result[8] = a1 == 1;
  }
  return result;
}

void yzip_codec_destroy(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1);
  }
}

uint64_t yzip_codec_pool_init(void **a1, size_t a2)
{
  if ((unint64_t)a1[3] >= a2)
  {
    unint64_t v3 = (char *)*a1;
    if (*a1) {
      goto LABEL_3;
    }
  }
  else
  {
    a1[3] = (void *)a2;
    unint64_t v3 = (char *)reallocf(*a1, a2);
    *a1 = v3;
    if (v3)
    {
LABEL_3:
      uint64_t result = 0;
      int64x2_t v5 = &v3[(void)a1[3]];
      a1[1] = v3;
      a1[2] = v5;
      return result;
    }
  }
  return 0xFFFFFFFFLL;
}

BOOL BrotliIsMostlyUTF8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, double a5)
{
  if (!a4)
  {
    double v20 = 0.0;
    return (double)a4 * a5 < v20;
  }
  unint64_t v5 = 0;
  unint64_t v6 = 0;
  do
  {
    uint64_t v7 = (char *)(a1 + ((v5 + a2) & a3));
    unsigned int v8 = *v7;
    if (*v7 <= 0)
    {
      unint64_t v9 = a4 - v5;
      if (a4 - v5 >= 2)
      {
        if ((v8 & 0xE0) == 0xC0)
        {
          unsigned __int8 v10 = v7[1];
          if ((v10 & 0xC0) == 0x80)
          {
            unsigned int v11 = v10 & 0x3F | ((v8 & 0x1F) << 6);
            if (v11 > 0x7F)
            {
              unsigned int v8 = v11;
              uint64_t v12 = 2;
              goto LABEL_24;
            }
          }
        }
        if (v9 >= 3)
        {
          if ((v8 & 0xF0) == 0xE0)
          {
            unsigned __int8 v13 = v7[1];
            if ((v13 & 0xC0) == 0x80)
            {
              unsigned __int8 v14 = v7[2];
              if ((v14 & 0xC0) == 0x80 && (((v8 & 0xF) << 12) | ((v13 & 0x3F) << 6) | v14 & 0x3F) > 0x7FF)
              {
                unsigned int v8 = ((v8 & 0xF) << 12) | ((v13 & 0x3F) << 6) | v14 & 0x3F;
                uint64_t v12 = 3;
                goto LABEL_24;
              }
            }
          }
          if (v9 >= 4 && (v8 & 0xF8) == 0xF0)
          {
            unsigned __int8 v15 = v7[1];
            if ((v15 & 0xC0) == 0x80)
            {
              unsigned __int8 v16 = v7[2];
              if ((v16 & 0xC0) == 0x80)
              {
                unsigned __int8 v17 = v7[3];
                if ((v17 & 0xC0) == 0x80)
                {
                  int v18 = ((v8 & 7) << 18) | ((v15 & 0x3F) << 12);
                  if ((v18 - 0x10000) < 0x100000)
                  {
                    unsigned int v8 = v17 & 0x3F | ((v16 & 0x3F) << 6) | v18;
                    uint64_t v12 = 4;
                    goto LABEL_24;
                  }
                }
              }
            }
          }
        }
      }
      v8 |= 0x110000u;
    }
    uint64_t v12 = 1;
LABEL_24:
    v5 += v12;
    if (v8 >= 0x110000) {
      uint64_t v19 = 0;
    }
    else {
      uint64_t v19 = v12;
    }
    v6 += v19;
  }
  while (v5 < a4);
  double v20 = (double)v6;
  return (double)a4 * a5 < v20;
}

uint64_t BrotliCompressFragmentTwoPass(uint64_t result, char *__src, unint64_t a3, int a4, unsigned int *a5, char *__dst, uint64_t a7, unsigned int a8, unint64_t *a9, uint64_t a10)
{
  unint64_t v13 = *a9;
  switch(__clz(a8) ^ 0x1F)
  {
    case 8u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl8(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 9u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl9(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xAu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl10(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xBu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl11(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xCu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl12(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xDu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl13(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xEu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl14(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0xFu:
      uint64_t result = BrotliCompressFragmentTwoPassImpl15(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0x10u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl16(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    case 0x11u:
      uint64_t result = BrotliCompressFragmentTwoPassImpl17(result, __src, a3, a5, __dst, a7, a9, a10);
      break;
    default:
      break;
  }
  if (*a9 - v13 > 8 * a3 + 31)
  {
    *(unsigned char *)(a10 + (v13 >> 3)) &= ~(-1 << (v13 & 7));
    *a9 = v13;
    BrotliStoreMetaBlockHeader(a3, 1u, a9, a10);
    unint64_t v14 = (*(_DWORD *)a9 + 7) & 0xFFFFFFF8;
    *a9 = v14;
    uint64_t result = (uint64_t)memcpy((void *)(a10 + (v14 >> 3)), __src, a3);
    unint64_t v15 = *a9 + 8 * a3;
    *a9 = v15;
    *(unsigned char *)(a10 + (v15 >> 3)) = 0;
  }
  if (a4)
  {
    unint64_t v16 = *a9;
    *(void *)(a10 + (*a9 >> 3)) = (1 << (*a9 & 7)) | *(unsigned __int8 *)(a10 + (*a9 >> 3));
    *a9 = v16 + 1;
    *(void *)(a10 + ((v16 + 1) >> 3)) = (1 << ((v16 + 1) & 7)) | *(unsigned __int8 *)(a10 + ((v16 + 1) >> 3));
    *a9 = (v16 + 9) & 0xFFFFFFF8;
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl8(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 56;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 54) & 0x3FC)) = v16
                                                                                               - __src
                                                                                               - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 54) & 0x3FC)) = v16
                                                                                           - __src
                                                                                           - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 54) & 0x3FC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 54) & 0x3FC)) = v16
                                                                                               - __src
                                                                                               - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 54) & 0x3FC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 54) & 0x3FC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 54) & 0x3FC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl9(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 55;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 53) & 0x7FC)) = v16
                                                                                               - __src
                                                                                               - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 53) & 0x7FC)) = v16
                                                                                           - __src
                                                                                           - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 53) & 0x7FC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 53) & 0x7FC)) = v16
                                                                                               - __src
                                                                                               - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 53) & 0x7FC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 53) & 0x7FC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 53) & 0x7FC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl10(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 54;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 52) & 0xFFC)) = v16
                                                                                               - __src
                                                                                               - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 52) & 0xFFC)) = v16
                                                                                           - __src
                                                                                           - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 52) & 0xFFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 52) & 0xFFC)) = v16
                                                                                               - __src
                                                                                               - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 52) & 0xFFC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 52) & 0xFFC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 52) & 0xFFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl11(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 53;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 51) & 0x1FFC)) = v16
                                                                                                - __src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 51) & 0x1FFC)) = v16
                                                                                            - __src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 51) & 0x1FFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 51) & 0x1FFC)) = v16
                                                                                                - __src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 51) & 0x1FFC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 51) & 0x1FFC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 51) & 0x1FFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl12(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 52;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC)) = v16
                                                                                                - __src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 50) & 0x3FFC)) = v16
                                                                                            - __src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 50) & 0x3FFC)) = v16
                                                                                                - __src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 50) & 0x3FFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl13(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 51;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC)) = v16
                                                                                                - __src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 49) & 0x7FFC)) = v16
                                                                                            - __src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 49) & 0x7FFC)) = v16
                                                                                                - __src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 49) & 0x7FFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl14(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 50;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC)) = v16
                                                                                                - __src
                                                                                                - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 48) & 0xFFFC)) = v16
                                                                                            - __src
                                                                                            - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 48) & 0xFFFC)) = v16
                                                                                                - __src
                                                                                                - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 48) & 0xFFFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl15(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v85 = result;
  if (a3)
  {
    unint64_t v9 = __dst;
    int v94 = __src + 4;
    unsigned int v11 = __src;
    while (1)
    {
      unint64_t v12 = a3 >= 0x20000 ? 0x20000 : a3;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = v9;
      unint64_t v16 = v11;
      unint64_t v91 = a3;
      int v93 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_85:
      if (v16 < v13)
      {
        unsigned int v76 = v13 - v16;
        if ((v13 - v16) >= 6)
        {
          int v78 = (v76 << 8) - 1589738;
          if (v76 > 0x5841) {
            int v78 = (v76 << 8) - 5784041;
          }
          if (v76 >> 1 <= 0xC20) {
            unsigned int v77 = (v76 << 8) - 541163;
          }
          else {
            unsigned int v77 = v78;
          }
          unsigned int v79 = __clz(v76 - 66) ^ 0x1F;
          if (v76 <= 0x841) {
            unsigned int v77 = (v79 | (((-1 << v79) + v76 - 66) << 8)) + 10;
          }
          unsigned int v80 = (__clz(v76 - 2) ^ 0x1F) - 1;
          if (v76 <= 0x81) {
            unsigned int v77 = (((v76 - 2) >> v80) + 2 * v80 + 2) | ((v76 - 2 - ((v76 - 2) >> v80 << v80)) << 8);
          }
        }
        else
        {
          unsigned int v77 = v13 - v16;
        }
        *unint64_t v14 = v77;
        uint64_t v81 = v15;
        memcpy(v15, v16, v76);
        unint64_t v15 = &v81[v76];
        unint64_t v9 = __dst;
      }
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - v9))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v82 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v82 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v85 + 24)) {
          return result;
        }
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v83 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v83;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v83 >> 3)), v11, v12);
        unint64_t v84 = *a7 + 8 * v12;
        *a7 = v84;
        *(unsigned char *)(a8 + (v84 >> 3)) = 0;
        unsigned int v11 = v93;
        a3 = v91 - v12;
        if (v91 == v12) {
          return result;
        }
      }
    }
    int v89 = v11;
    unint64_t v90 = v12;
    unint64_t v17 = v12 - 4;
    if (v12 - 4 >= a3 - 16) {
      unint64_t v17 = a3 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 4;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = v9;
    unint64_t v16 = v11;
    int v95 = v13 - 4;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = (char *)v22 + (i >> 5);
      if (v24 > v18)
      {
LABEL_84:
        unint64_t v9 = __dst;
        unsigned int v11 = v89;
        unint64_t v12 = v90;
        unint64_t v13 = v93;
        goto LABEL_85;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD00000000 * v21) >> 49;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = (char *)v22 - v20;
      if (*v22 != *(_DWORD *)v26 || v20 < 1)
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*v22 != *(_DWORD *)v26) {
          goto LABEL_19;
        }
      }
      else
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      int v28 = v22 - v26;
      if ((char *)v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 4;
        uint64_t v30 = (unsigned __int8 *)(v22 + 1);
        unint64_t v31 = v19 - (char *)v22;
        if ((unint64_t)(v19 - (char *)v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_79:
          uint64_t v74 = v31 & 7;
          if (v74)
          {
            unint64_t v75 = v34 | v74;
            while (*((unsigned __int8 *)v29 + v34) == *v30)
            {
              ++v30;
              ++v34;
              if (!--v74)
              {
                unint64_t v34 = v75;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32 * 4];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 2;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_79;
            }
          }
          unint64_t v34 = v32 * 4 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v96 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v96 + 4;
        v14[1] = v43;
        if (v96 + 4 <= 0xB)
        {
          unsigned int v46 = v96 + 24;
          goto LABEL_45;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v96 - 68) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v96 - 68) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v96 - 4) >> 5) + 54) | ((((_BYTE)v96 - 4) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v96 - 4) ^ 0x1F) - 1;
          unsigned int v46 = (((v96 - 4) >> v47) + 2 * v47 + 28) | ((v96 - 4 - ((v96 - 4) >> v47 << v47)) << 8);
LABEL_45:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = (char *)v22 + v45;
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if ((char *)v22 + v45 >= v18) {
          goto LABEL_84;
        }
        uint64_t v51 = *(void *)(v16 - 3);
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 24) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC)) = v16
                                                                                                 - __src
                                                                                                 - 2;
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v51) >> 47) & 0x1FFFC)) = v16
                                                                                             - __src
                                                                                             - 1;
        unint64_t v52 = ((506832829 * ((v51 << 8) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC;
        uint64_t v53 = *(int *)(a6 + v52);
        *(_DWORD *)(a6 + v52) = v16 - __src;
        uint64_t v54 = v16 - &__src[v53];
        uint64_t v19 = v95;
        if (v54 < 262129 && *(_DWORD *)v16 == *(_DWORD *)&__src[v53])
        {
          while (1)
          {
            int v20 = v54;
            uint64_t v55 = &v94[v53];
            uint64_t v56 = (unsigned __int8 *)(v16 + 4);
            unint64_t v57 = v95 - v16;
            if ((unint64_t)(v95 - v16) < 8)
            {
              unint64_t v60 = 0;
LABEL_73:
              uint64_t v72 = v57 & 7;
              if (v72)
              {
                unint64_t v73 = v60 | v72;
                while (v55[v60] == *v56)
                {
                  ++v56;
                  ++v60;
                  if (!--v72)
                  {
                    unint64_t v60 = v73;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              unint64_t v59 = v57 >> 3;
              unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v61 = *(void *)&v56[v58];
                uint64_t v62 = *(void *)&v55[v58];
                if (v61 != v62) {
                  break;
                }
                v58 += 8;
                if (!--v59)
                {
                  v56 += v57 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_73;
                }
              }
              unint64_t v60 = v58 + (__clz(__rbit64(v62 ^ v61)) >> 3);
            }
            unint64_t v63 = v60 + 4;
            if (v60 + 4 > 9)
            {
              if (v63 > 0x85)
              {
                if (v63 > 0x845)
                {
                  unsigned int v64 = (v63 << 8) - 542145;
                }
                else
                {
                  unsigned int v67 = v60 - 66;
                  unsigned int v68 = __clz(v67) ^ 0x1F;
                  unsigned int v64 = (v68 | (((-1 << v68) + v67) << 8)) + 52;
                }
              }
              else
              {
                unint64_t v65 = v60 - 2;
                unsigned int v66 = (__clz(v65) ^ 0x1F) - 1;
                unsigned int v64 = ((v65 >> v66) + 2 * v66 + 44) | ((v65 - (v65 >> v66 << v66)) << 8);
              }
            }
            else
            {
              unsigned int v64 = v60 + 42;
            }
            v16 += v63;
            unsigned int v69 = __clz(v20 + 3);
            *unint64_t v14 = v64;
            v14[1] = (((v20 + 3 - ((((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1 | 2) << ((v69 ^ 0x1F) - 1))) << 8) | (2 * (v69 ^ 0x1F)) | ((v20 + 3) >> ((v69 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_84;
            }
            uint64_t v70 = *(void *)(v16 - 3);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD00000000 * v70) >> 47) & 0x1FFFC)) = v16
                                                                                                 - __src
                                                                                                 - 3;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 24) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC)) = v16 - __src - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v70 << 16) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC)) = v16 - __src - 1;
            unint64_t v71 = ((506832829 * ((v70 << 8) & 0xFFFFFFFF00000000)) >> 47) & 0x1FFFC;
            uint64_t v53 = *(int *)(a6 + v71);
            *(_DWORD *)(a6 + v71) = v16 - __src;
            uint64_t v54 = v16 - &__src[v53];
            if (v54 >= 262129 || *(_DWORD *)v16 != *(_DWORD *)&__src[v53]) {
              goto LABEL_10;
            }
          }
        }
        goto LABEL_10;
      }
LABEL_19:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl16(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v91 = result;
  if (a3)
  {
    unint64_t v9 = a3;
    unsigned int v11 = __src;
    unint64_t v96 = __dst;
    while (1)
    {
      unint64_t v12 = v9 >= 0x20000 ? 0x20000 : v9;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = __dst;
      unint64_t v16 = v11;
      unint64_t v97 = v9;
      uint64_t v98 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_93:
      if (v16 < v13)
      {
        unsigned int v80 = v13 - v16;
        uint64_t v81 = v11;
        if ((v13 - v16) >= 6)
        {
          int v83 = (v80 << 8) - 1589738;
          if (v80 > 0x5841) {
            int v83 = (v80 << 8) - 5784041;
          }
          if (v80 >> 1 <= 0xC20) {
            unsigned int v82 = (v80 << 8) - 541163;
          }
          else {
            unsigned int v82 = v83;
          }
          unsigned int v84 = __clz(v80 - 66) ^ 0x1F;
          if (v80 <= 0x841) {
            unsigned int v82 = (v84 | (((-1 << v84) + v80 - 66) << 8)) + 10;
          }
          unsigned int v85 = (__clz(v80 - 2) ^ 0x1F) - 1;
          if (v80 <= 0x81) {
            unsigned int v82 = (((v80 - 2) >> v85) + 2 * v85 + 2) | ((v80 - 2 - ((v80 - 2) >> v85 << v85)) << 8);
          }
        }
        else
        {
          unsigned int v82 = v13 - v16;
        }
        *unint64_t v14 = v82;
        int v86 = v15;
        memcpy(v15, v16, v80);
        unint64_t v15 = &v86[v80];
        unint64_t __dst = v96;
        unsigned int v11 = v81;
      }
      unsigned int v87 = v11;
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - __dst))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v88 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v88 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v91 + 24)) {
          return result;
        }
        unint64_t __dst = v96;
        unsigned int v11 = v98;
        unint64_t v9 = v97 - v12;
        if (v97 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v89 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v89;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v89 >> 3)), v87, v12);
        unint64_t v90 = *a7 + 8 * v12;
        *a7 = v90;
        *(unsigned char *)(a8 + (v90 >> 3)) = 0;
        unsigned int v11 = v98;
        v9 -= v12;
        unint64_t __dst = v96;
        if (!v9) {
          return result;
        }
      }
    }
    int v94 = v11;
    unint64_t v95 = v12;
    unint64_t v17 = v12 - 6;
    if (v12 - 6 >= v9 - 16) {
      unint64_t v17 = v9 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 6;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = __dst;
    unint64_t v16 = v11;
    uint64_t v100 = v13 - 6;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = &v22[i >> 5];
      if (v24 > v18)
      {
LABEL_92:
        unint64_t __dst = v96;
        unint64_t v9 = v97;
        unsigned int v11 = v94;
        unint64_t v12 = v95;
        unint64_t v13 = v98;
        goto LABEL_93;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD0000 * v21) >> 48;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = &v22[-v20];
      if (*(_DWORD *)v22 == *(_DWORD *)v26
        && v22[4] == v26[4]
        && (v22[5] == v26[5] ? (BOOL v27 = v20 < 1) : (BOOL v27 = 1), !v27))
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      else
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*(_DWORD *)v22 != *(_DWORD *)v26 || v22[4] != v26[4] || v22[5] != v26[5]) {
          goto LABEL_24;
        }
      }
      int v28 = v22 - v26;
      if (v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 6;
        uint64_t v30 = (unsigned __int8 *)(v22 + 6);
        unint64_t v31 = v19 - v22;
        if ((unint64_t)(v19 - v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_87:
          uint64_t v78 = v31 & 7;
          if (v78)
          {
            unint64_t v79 = v34 | v78;
            while (v29[v34] == *v30)
            {
              ++v30;
              ++v34;
              if (!--v78)
              {
                unint64_t v34 = v79;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 8;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_87;
            }
          }
          unint64_t v34 = v32 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v101 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v101 + 6;
        v14[1] = v43;
        if (v101 + 6 <= 0xB)
        {
          unsigned int v46 = v101 + 26;
          goto LABEL_50;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v101 - 66) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v101 - 66) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v101 - 2) >> 5) + 54) | ((((_BYTE)v101 - 2) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v101 - 2) ^ 0x1F) - 1;
          unsigned int v46 = (((v101 - 2) >> v47) + 2 * v47 + 28) | ((v101 - 2 - ((v101 - 2) >> v47 << v47)) << 8);
LABEL_50:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = &v22[v45];
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if (&v22[v45] >= v18) {
          goto LABEL_92;
        }
        uint64_t v51 = *(void *)(v16 - 5);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v51) >> 46) & 0x3FFFC)) = v16
                                                                                         - __src
                                                                                         - 5;
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16
                                                                                                - __src
                                                                                                - 4;
        *(_DWORD *)(a6 + (((506832829 * (v51 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16
                                                                                         - __src
                                                                                         - 3;
        uint64_t v52 = *(void *)(v16 - 2);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v52) >> 46) & 0x3FFFC)) = v16
                                                                                         - __src
                                                                                         - 2;
        *(_DWORD *)(a6 + (((506832829 * ((v52 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16
                                                                                                - __src
                                                                                                - 1;
        unint64_t v53 = ((506832829 * (v52 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC;
        uint64_t v54 = *(int *)(a6 + v53);
        *(_DWORD *)(a6 + v53) = v16 - __src;
        uint64_t v55 = &__src[v54];
        LODWORD(v56) = v16 - v55;
        uint64_t v19 = v100;
        if (v16 - v55 < 262129 && *(_DWORD *)v16 == *(_DWORD *)v55)
        {
          while (1)
          {
            int v57 = v56;
            if (v16[4] != v55[4] || v16[5] != v55[5]) {
              break;
            }
            uint64_t v58 = v55 + 6;
            unint64_t v59 = (unsigned __int8 *)(v16 + 6);
            unint64_t v60 = v100 - v16;
            if ((unint64_t)(v100 - v16) < 8)
            {
              unint64_t v63 = 0;
LABEL_80:
              uint64_t v76 = v60 & 7;
              if (v76)
              {
                unint64_t v77 = v63 | v76;
                while (v58[v63] == *v59)
                {
                  ++v59;
                  ++v63;
                  if (!--v76)
                  {
                    unint64_t v63 = v77;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v61 = 0;
              unint64_t v62 = v60 >> 3;
              unint64_t v63 = v60 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v64 = *(void *)&v59[v61];
                uint64_t v65 = *(void *)&v58[v61];
                if (v64 != v65) {
                  break;
                }
                v61 += 8;
                if (!--v62)
                {
                  v59 += v60 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_80;
                }
              }
              unint64_t v63 = v61 + (__clz(__rbit64(v65 ^ v64)) >> 3);
            }
            unint64_t v66 = v63 + 6;
            if (v63 + 6 > 9)
            {
              if (v66 > 0x85)
              {
                if (v66 > 0x845)
                {
                  unsigned int v67 = (v66 << 8) - 542145;
                }
                else
                {
                  unsigned int v69 = v63 - 64;
                  unsigned int v70 = __clz(v69) ^ 0x1F;
                  unsigned int v67 = (v70 | (((-1 << v70) + v69) << 8)) + 52;
                }
              }
              else
              {
                unsigned int v68 = (__clz(v63) ^ 0x1F) - 1;
                unsigned int v67 = ((v63 >> v68) + 2 * v68 + 44) | ((v63 - (v63 >> v68 << v68)) << 8);
              }
            }
            else
            {
              unsigned int v67 = v63 + 44;
            }
            v16 += v66;
            unsigned int v71 = __clz(v57 + 3);
            *unint64_t v14 = v67;
            v14[1] = (((v57 + 3 - ((((v57 + 3) >> ((v71 ^ 0x1F) - 1)) & 1 | 2) << ((v71 ^ 0x1F) - 1))) << 8) | (2 * (v71 ^ 0x1F)) | ((v57 + 3) >> ((v71 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_92;
            }
            uint64_t v72 = *(void *)(v16 - 5);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v72) >> 46) & 0x3FFFC)) = v16
                                                                                             - __src
                                                                                             - 5;
            *(_DWORD *)(a6 + (((506832829 * ((v72 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 4;
            *(_DWORD *)(a6 + (((506832829 * (v72 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16
                                                                                             - __src
                                                                                             - 3;
            uint64_t v73 = *(void *)(v16 - 2);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v73) >> 46) & 0x3FFFC)) = v16
                                                                                             - __src
                                                                                             - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v73 << 8) & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC)) = v16 - __src - 1;
            unint64_t v74 = ((506832829 * (v73 & 0xFFFFFFFFFFFF0000)) >> 46) & 0x3FFFC;
            uint64_t v75 = *(int *)(a6 + v74);
            *(_DWORD *)(a6 + v74) = v16 - __src;
            uint64_t v55 = &__src[v75];
            uint64_t v56 = v16 - &__src[v75];
            if (v56 < 262129)
            {
              int v20 = v57;
              if (*(_DWORD *)v16 == *(_DWORD *)v55) {
                continue;
              }
            }
            int v20 = v57;
            goto LABEL_10;
          }
        }
        goto LABEL_10;
      }
LABEL_24:
      uint64_t v22 = v24;
    }
  }
  return result;
}

uint64_t BrotliCompressFragmentTwoPassImpl17(uint64_t result, char *__src, unint64_t a3, unsigned int *a4, char *__dst, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  uint64_t v91 = result;
  if (a3)
  {
    unint64_t v9 = a3;
    unsigned int v11 = __src;
    unint64_t v96 = __dst;
    while (1)
    {
      unint64_t v12 = v9 >= 0x20000 ? 0x20000 : v9;
      unint64_t v13 = &v11[v12];
      unint64_t v14 = a4;
      unint64_t v15 = __dst;
      unint64_t v16 = v11;
      unint64_t v97 = v9;
      uint64_t v98 = &v11[v12];
      if (v12 >= 0x10) {
        break;
      }
LABEL_93:
      if (v16 < v13)
      {
        unsigned int v80 = v13 - v16;
        uint64_t v81 = v11;
        if ((v13 - v16) >= 6)
        {
          int v83 = (v80 << 8) - 1589738;
          if (v80 > 0x5841) {
            int v83 = (v80 << 8) - 5784041;
          }
          if (v80 >> 1 <= 0xC20) {
            unsigned int v82 = (v80 << 8) - 541163;
          }
          else {
            unsigned int v82 = v83;
          }
          unsigned int v84 = __clz(v80 - 66) ^ 0x1F;
          if (v80 <= 0x841) {
            unsigned int v82 = (v84 | (((-1 << v84) + v80 - 66) << 8)) + 10;
          }
          unsigned int v85 = (__clz(v80 - 2) ^ 0x1F) - 1;
          if (v80 <= 0x81) {
            unsigned int v82 = (((v80 - 2) >> v85) + 2 * v85 + 2) | ((v80 - 2 - ((v80 - 2) >> v85 << v85)) << 8);
          }
        }
        else
        {
          unsigned int v82 = v13 - v16;
        }
        *unint64_t v14 = v82;
        int v86 = v15;
        memcpy(v15, v16, v80);
        unint64_t v15 = &v86[v80];
        unint64_t __dst = v96;
        unsigned int v11 = v81;
      }
      unsigned int v87 = v11;
      if (ShouldCompress_0((uint64_t)v11, v12, v15 - __dst))
      {
        BrotliStoreMetaBlockHeader(v12, 0, a7, a8);
        unint64_t v88 = *a7;
        *(void *)(a8 + (*a7 >> 3)) = *(unsigned __int8 *)(a8 + (*a7 >> 3));
        *a7 = v88 + 13;
        uint64_t result = StoreCommands();
        if (*(_DWORD *)(v91 + 24)) {
          return result;
        }
        unint64_t __dst = v96;
        unsigned int v11 = v98;
        unint64_t v9 = v97 - v12;
        if (v97 == v12) {
          return result;
        }
      }
      else
      {
        BrotliStoreMetaBlockHeader(v12, 1u, a7, a8);
        unint64_t v89 = (*(_DWORD *)a7 + 7) & 0xFFFFFFF8;
        *a7 = v89;
        uint64_t result = (uint64_t)memcpy((void *)(a8 + (v89 >> 3)), v87, v12);
        unint64_t v90 = *a7 + 8 * v12;
        *a7 = v90;
        *(unsigned char *)(a8 + (v90 >> 3)) = 0;
        unsigned int v11 = v98;
        v9 -= v12;
        unint64_t __dst = v96;
        if (!v9) {
          return result;
        }
      }
    }
    int v94 = v11;
    unint64_t v95 = v12;
    unint64_t v17 = v12 - 6;
    if (v12 - 6 >= v9 - 16) {
      unint64_t v17 = v9 - 16;
    }
    int v18 = &v11[v17];
    uint64_t v19 = v13 - 6;
    int v20 = -1;
    unint64_t v14 = a4;
    unint64_t v15 = __dst;
    unint64_t v16 = v11;
    uint64_t v100 = v13 - 6;
LABEL_10:
    uint64_t v22 = v16 + 1;
    uint64_t v21 = *(void *)(v16 + 1);
    for (unsigned int i = 32; ; ++i)
    {
      unint64_t v24 = &v22[i >> 5];
      if (v24 > v18)
      {
LABEL_92:
        unint64_t __dst = v96;
        unint64_t v9 = v97;
        unsigned int v11 = v94;
        unint64_t v12 = v95;
        unint64_t v13 = v98;
        goto LABEL_93;
      }
      unint64_t v25 = (unint64_t)(0x1E35A7BD0000 * v21) >> 47;
      uint64_t v21 = *(void *)v24;
      int64_t v26 = &v22[-v20];
      if (*(_DWORD *)v22 == *(_DWORD *)v26
        && v22[4] == v26[4]
        && (v22[5] == v26[5] ? (BOOL v27 = v20 < 1) : (BOOL v27 = 1), !v27))
      {
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
      }
      else
      {
        int64_t v26 = &__src[*(int *)(a6 + 4 * v25)];
        *(_DWORD *)(a6 + 4 * v25) = v22 - __src;
        if (*(_DWORD *)v22 != *(_DWORD *)v26 || v22[4] != v26[4] || v22[5] != v26[5]) {
          goto LABEL_24;
        }
      }
      int v28 = v22 - v26;
      if (v22 - v26 <= 262128)
      {
        uint64_t v29 = v26 + 6;
        uint64_t v30 = (unsigned __int8 *)(v22 + 6);
        unint64_t v31 = v19 - v22;
        if ((unint64_t)(v19 - v22) < 8)
        {
          unint64_t v34 = 0;
LABEL_87:
          uint64_t v78 = v31 & 7;
          if (v78)
          {
            unint64_t v79 = v34 | v78;
            while (v29[v34] == *v30)
            {
              ++v30;
              ++v34;
              if (!--v78)
              {
                unint64_t v34 = v79;
                break;
              }
            }
          }
        }
        else
        {
          uint64_t v32 = 0;
          unint64_t v33 = v31 >> 3;
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF8;
          while (1)
          {
            uint64_t v35 = *(void *)&v30[v32];
            uint64_t v36 = *(void *)&v29[v32];
            if (v35 != v36) {
              break;
            }
            v32 += 8;
            if (!--v33)
            {
              v30 += v31 & 0xFFFFFFFFFFFFFFF8;
              goto LABEL_87;
            }
          }
          unint64_t v34 = v32 + (__clz(__rbit64(v36 ^ v35)) >> 3);
        }
        unsigned int v37 = v22 - v16;
        unint64_t v101 = v34;
        if ((v22 - v16) >= 6)
        {
          if (v37 > 0x81)
          {
            if (v37 > 0x841)
            {
              if (v37 >> 1 > 0xC20)
              {
                if (v37 > 0x5841) {
                  int v41 = -5784041;
                }
                else {
                  int v41 = -1589738;
                }
                unsigned int v38 = (v37 << 8) + v41;
              }
              else
              {
                unsigned int v38 = (v37 << 8) - 541163;
              }
            }
            else
            {
              unsigned int v40 = __clz(v37 - 66) ^ 0x1F;
              unsigned int v38 = (v40 | (((-1 << v40) + v37 - 66) << 8)) + 10;
            }
          }
          else
          {
            unsigned int v39 = (__clz(v37 - 2) ^ 0x1F) - 1;
            unsigned int v38 = (((v37 - 2) >> v39) + 2 * v39 + 2) | ((v37 - 2 - ((v37 - 2) >> v39 << v39)) << 8);
          }
        }
        else
        {
          unsigned int v38 = v22 - v16;
        }
        *unint64_t v14 = v38;
        unint64_t v42 = v15;
        memcpy(v15, v16, (int)v37);
        if (v20 == v28)
        {
          unsigned int v43 = 64;
        }
        else
        {
          unsigned int v44 = __clz(v28 + 3) ^ 0x1F;
          unsigned int v43 = (((v28 + 3 - ((((v28 + 3) >> (v44 - 1)) & 1 | 2) << (v44 - 1))) << 8) | (2 * v44) | ((v28 + 3) >> (v44 - 1)) & 1)
              + 76;
          int v20 = v28;
        }
        unint64_t v45 = v101 + 6;
        v14[1] = v43;
        if (v101 + 6 <= 0xB)
        {
          unsigned int v46 = v101 + 26;
          goto LABEL_50;
        }
        if (v45 > 0x47)
        {
          if (v45 > 0x87)
          {
            if (v45 > 0x847)
            {
              unsigned int v49 = (v45 << 8) - 542657;
            }
            else
            {
              unsigned int v50 = __clz(v101 - 66) ^ 0x1F;
              unsigned int v49 = (v50 | (((-1 << v50) + v101 - 66) << 8)) + 52;
            }
          }
          else
          {
            unsigned int v49 = (((v101 - 2) >> 5) + 54) | ((((_BYTE)v101 - 2) & 0x1F) << 8);
          }
          _OWORD v14[2] = v49;
          v14[3] = 64;
          uint64_t v48 = 4;
        }
        else
        {
          unsigned int v47 = (__clz(v101 - 2) ^ 0x1F) - 1;
          unsigned int v46 = (((v101 - 2) >> v47) + 2 * v47 + 28) | ((v101 - 2 - ((v101 - 2) >> v47 << v47)) << 8);
LABEL_50:
          _OWORD v14[2] = v46;
          uint64_t v48 = 3;
        }
        unint64_t v16 = &v22[v45];
        unint64_t v15 = &v42[v37];
        v14 += v48;
        if (&v22[v45] >= v18) {
          goto LABEL_92;
        }
        uint64_t v51 = *(void *)(v16 - 5);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v51) >> 45) & 0x7FFFC)) = v16
                                                                                         - __src
                                                                                         - 5;
        *(_DWORD *)(a6 + (((506832829 * ((v51 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16
                                                                                                - __src
                                                                                                - 4;
        *(_DWORD *)(a6 + (((506832829 * (v51 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16
                                                                                         - __src
                                                                                         - 3;
        uint64_t v52 = *(void *)(v16 - 2);
        *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v52) >> 45) & 0x7FFFC)) = v16
                                                                                         - __src
                                                                                         - 2;
        *(_DWORD *)(a6 + (((506832829 * ((v52 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16
                                                                                                - __src
                                                                                                - 1;
        unint64_t v53 = ((506832829 * (v52 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC;
        uint64_t v54 = *(int *)(a6 + v53);
        *(_DWORD *)(a6 + v53) = v16 - __src;
        uint64_t v55 = &__src[v54];
        LODWORD(v56) = v16 - v55;
        uint64_t v19 = v100;
        if (v16 - v55 < 262129 && *(_DWORD *)v16 == *(_DWORD *)v55)
        {
          while (1)
          {
            int v57 = v56;
            if (v16[4] != v55[4] || v16[5] != v55[5]) {
              break;
            }
            uint64_t v58 = v55 + 6;
            unint64_t v59 = (unsigned __int8 *)(v16 + 6);
            unint64_t v60 = v100 - v16;
            if ((unint64_t)(v100 - v16) < 8)
            {
              unint64_t v63 = 0;
LABEL_80:
              uint64_t v76 = v60 & 7;
              if (v76)
              {
                unint64_t v77 = v63 | v76;
                while (v58[v63] == *v59)
                {
                  ++v59;
                  ++v63;
                  if (!--v76)
                  {
                    unint64_t v63 = v77;
                    break;
                  }
                }
              }
            }
            else
            {
              uint64_t v61 = 0;
              unint64_t v62 = v60 >> 3;
              unint64_t v63 = v60 & 0xFFFFFFFFFFFFFFF8;
              while (1)
              {
                uint64_t v64 = *(void *)&v59[v61];
                uint64_t v65 = *(void *)&v58[v61];
                if (v64 != v65) {
                  break;
                }
                v61 += 8;
                if (!--v62)
                {
                  v59 += v60 & 0xFFFFFFFFFFFFFFF8;
                  goto LABEL_80;
                }
              }
              unint64_t v63 = v61 + (__clz(__rbit64(v65 ^ v64)) >> 3);
            }
            unint64_t v66 = v63 + 6;
            if (v63 + 6 > 9)
            {
              if (v66 > 0x85)
              {
                if (v66 > 0x845)
                {
                  unsigned int v67 = (v66 << 8) - 542145;
                }
                else
                {
                  unsigned int v69 = v63 - 64;
                  unsigned int v70 = __clz(v69) ^ 0x1F;
                  unsigned int v67 = (v70 | (((-1 << v70) + v69) << 8)) + 52;
                }
              }
              else
              {
                unsigned int v68 = (__clz(v63) ^ 0x1F) - 1;
                unsigned int v67 = ((v63 >> v68) + 2 * v68 + 44) | ((v63 - (v63 >> v68 << v68)) << 8);
              }
            }
            else
            {
              unsigned int v67 = v63 + 44;
            }
            v16 += v66;
            unsigned int v71 = __clz(v57 + 3);
            *unint64_t v14 = v67;
            v14[1] = (((v57 + 3 - ((((v57 + 3) >> ((v71 ^ 0x1F) - 1)) & 1 | 2) << ((v71 ^ 0x1F) - 1))) << 8) | (2 * (v71 ^ 0x1F)) | ((v57 + 3) >> ((v71 ^ 0x1F) - 1)) & 1)
                   + 76;
            v14 += 2;
            if (v16 >= v18) {
              goto LABEL_92;
            }
            uint64_t v72 = *(void *)(v16 - 5);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v72) >> 45) & 0x7FFFC)) = v16
                                                                                             - __src
                                                                                             - 5;
            *(_DWORD *)(a6 + (((506832829 * ((v72 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 4;
            *(_DWORD *)(a6 + (((506832829 * (v72 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16
                                                                                             - __src
                                                                                             - 3;
            uint64_t v73 = *(void *)(v16 - 2);
            *(_DWORD *)(a6 + (((unint64_t)(0x1E35A7BD0000 * v73) >> 45) & 0x7FFFC)) = v16
                                                                                             - __src
                                                                                             - 2;
            *(_DWORD *)(a6 + (((506832829 * ((v73 << 8) & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC)) = v16 - __src - 1;
            unint64_t v74 = ((506832829 * (v73 & 0xFFFFFFFFFFFF0000)) >> 45) & 0x7FFFC;
            uint64_t v75 = *(int *)(a6 + v74);
            *(_DWORD *)(a6 + v74) = v16 - __src;
            uint64_t v55 = &__src[v75];
            uint64_t v56 = v16 - &__src[v75];
            if (v56 < 262129)
            {
              int v20 = v57;
              if (*(_DWORD *)v16 == *(_DWORD *)v55) {
                continue;
              }
            }
            int v20 = v57;
            goto LABEL_10;
          }
        }
        goto LABEL_10;
      }
LABEL_24:
      uint64_t v22 = v24;
    }
  }
  return result;
}

BOOL ShouldCompress_0(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  double v3 = (double)a2;
  if ((double)a2 * 0.98 > (double)a3) {
    return 1;
  }
  bzero(v20, 0x400uLL);
  if (a2)
  {
    unint64_t v7 = 0;
    do
    {
      ++v20[*(unsigned __int8 *)(a1 + v7)];
      v7 += 43;
    }
    while (v7 < a2);
  }
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  double v10 = 0.0;
  double v11 = v3 * 8.0 * 0.98 / 43.0;
  do
  {
    uint64_t v12 = v20[v9];
    if (v12 > 0xFF)
    {
      double v14 = (double)v12;
      double v13 = log2((double)v12);
    }
    else
    {
      double v13 = kBrotliLog2Table[v12];
      double v14 = (double)v12;
    }
    uint64_t v15 = v20[v9 + 1];
    if (v15 > 0xFF) {
      double v16 = log2((double)v15);
    }
    else {
      double v16 = kBrotliLog2Table[v15];
    }
    v9 += 2;
    v8 += v12 + v15;
    double v10 = v10 - v14 * v13 - (double)v15 * v16;
  }
  while ((unint64_t)(v9 - 2) < 0xFE);
  double v17 = (double)v8;
  if (v8)
  {
    if (v8 > 0xFF) {
      double v18 = log2((double)v8);
    }
    else {
      double v18 = kBrotliLog2Table[v8];
    }
    double v10 = v10 + v17 * v18;
  }
  if (v10 >= v17) {
    double v19 = v10;
  }
  else {
    double v19 = (double)v8;
  }
  return v19 < v11;
}

unint64_t StoreCommands()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  unint64_t v4 = v3;
  uint64_t v6 = v5;
  unint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  unint64_t v13 = v0;
  uint64_t v66 = *MEMORY[0x263EF8340];
  bzero(v56, 0x400uLL);
  memset(v55, 0, sizeof(v55));
  long long v54 = 0u;
  long long v52 = 0u;
  memset(v53, 0, sizeof(v53));
  memset(v51, 0, sizeof(v51));
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  memset(v38, 0, sizeof(v38));
  memset(v37, 0, sizeof(v37));
  if (v10)
  {
    double v14 = v12;
    uint64_t v15 = v10;
    do
    {
      int v16 = *v14++;
      ++v56[v16];
      --v15;
    }
    while (v15);
  }
  unint64_t result = BrotliBuildAndStoreHuffmanTreeFast(v13, (uint64_t)v56, v10, 8, v58, (uint64_t)v57, v4, v2);
  if (!*(_DWORD *)(v13 + 24))
  {
    if (v6)
    {
      double v18 = v8;
      uint64_t v19 = v6;
      do
      {
        unsigned int v20 = *v18;
        v18 += 4;
        ++*((_DWORD *)v37 + v20);
        --v19;
      }
      while (v19);
      int32x2_t v21 = vadd_s32(*(int32x2_t *)((char *)v37 + 4), (int32x2_t)0x100000001);
      int v22 = LODWORD(v38[0]) + 1;
      int v23 = v39 + 1;
    }
    else
    {
      int32x2_t v21 = (int32x2_t)0x100000001;
      int v23 = 1;
      int v22 = 1;
    }
    *(int32x2_t *)((char *)v37 + 4) = v21;
    LODWORD(v38[0]) = v22;
    LODWORD(v39) = v23;
    bzero(v64, 0x280uLL);
    BrotliCreateHuffmanTree((uint64_t)v37, 64, 15, (uint64_t)v65, (uint64_t)&v52);
    BrotliCreateHuffmanTree((uint64_t)v38, 64, 14, (uint64_t)v65, (uint64_t)v55);
    *(void *)&v60[16] = *((void *)&v53[1] + 1);
    *(void *)&long long v61 = v52;
    *(_OWORD *)unint64_t v60 = *(_OWORD *)((char *)v53 + 8);
    *((void *)&v61 + 1) = v54;
    *(void *)&long long v62 = *((void *)&v52 + 1);
    unint64_t v24 = (char *)v53;
    *((void *)&v62 + 1) = *((void *)&v54 + 1);
    uint64_t v63 = *(void *)&v53[0];
    BrotliConvertBitDepthsToSymbols(v60, 64, (uint64_t)v59);
    v50[0] = v59[3];
    v50[1] = v59[5];
    v50[2] = v59[7];
    v50[3] = v59[0];
    v50[4] = v59[1];
    v50[5] = v59[2];
    v50[6] = v59[4];
    v50[7] = v59[6];
    BrotliConvertBitDepthsToSymbols((unsigned __int8 *)v55, 64, (uint64_t)v51);
    long long v62 = 0u;
    long long v61 = 0u;
    *(_OWORD *)&v60[8] = 0u;
    uint64_t v63 = 0;
    *(void *)unint64_t v60 = *((void *)&v53[0] + 1);
    v64[8] = *((void *)&v53[1] + 1);
    v64[0] = *(void *)&v53[1];
    v64[40] = *((void *)&v54 + 1);
    v64[16] = v54;
    for (uint64_t i = 256; i != 320; i += 8)
    {
      int64_t v26 = &v60[i];
      *(v26 - 128) = *(v24 - 16);
      unsigned char *v26 = *(v24 - 8);
      char v27 = *v24++;
      v26[192] = v27;
    }
    BrotliStoreHuffmanTree((uint64_t)v60, 0x2C0uLL, (uint64_t)v65, v4, v2);
    unint64_t result = BrotliStoreHuffmanTree((uint64_t)v55, 0x40uLL, (uint64_t)v65, v4, v2);
    if (v6)
    {
      uint64_t v28 = 0;
      unint64_t v29 = *v4;
      do
      {
        unint64_t v30 = *(unsigned int *)&v8[4 * v28];
        uint64_t v31 = *(_DWORD *)&v8[4 * v28];
        uint64_t v32 = *((unsigned __int8 *)&v53[-1] + v31);
        *(void *)(v2 + (v29 >> 3)) = ((unint64_t)*((unsigned __int16 *)v50 + v31) << (v29 & 7)) | *(unsigned __int8 *)(v2 + (v29 >> 3));
        unint64_t v33 = v29 + v32;
        *unint64_t v4 = v33;
        unint64_t result = StoreCommands_kNumExtraBits[v31];
        unint64_t v34 = v30 >> 8;
        *(void *)(v2 + (v33 >> 3)) = (v34 << (v33 & 7)) | *(unsigned __int8 *)(v2 + (v33 >> 3));
        unint64_t v29 = v33 + result;
        *unint64_t v4 = v29;
        if (v31 <= 0x17)
        {
          for (int j = StoreCommands_kInsertOffset[v31] + v34; j; --j)
          {
            int v36 = *v12++;
            unint64_t result = v58[v36];
            *(void *)(v2 + (v29 >> 3)) = ((unint64_t)(unsigned __int16)v57[v36] << (v29 & 7)) | *(unsigned __int8 *)(v2 + (v29 >> 3));
            v29 += result;
            *unint64_t v4 = v29;
          }
        }
        ++v28;
      }
      while (v28 != v6);
    }
  }
  return result;
}

const z_crc_t *get_crc_table(void)
{
  return (const z_crc_t *)&crc_table;
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  if (!buf) {
    return 0;
  }
  unsigned int v3 = ~crc;
  if (len && (buf & 3) != 0)
  {
    unint64_t v4 = buf + 1;
    do
    {
      char v5 = *buf++;
      unsigned int v3 = *((void *)&crc_table + (v5 ^ v3)) ^ (v3 >> 8);
      if (!--len) {
        break;
      }
    }
    while ((unint64_t)(v4++ & 3));
  }
  if (len >= 0x20)
  {
    unint64_t v7 = (char *)&crc_table + 6144;
    do
    {
      unsigned int v8 = *(_DWORD *)buf ^ v3;
      int v9 = qword_20DB0B858[BYTE1(v8) + 256] ^ *(void *)&v7[8 * (*buf ^ v3)];
      unsigned int v10 = *((_DWORD *)buf + 1) ^ v9 ^ qword_20DB0B858[BYTE2(v8)] ^ *((void *)&crc_table + HIBYTE(v8));
      unsigned int v11 = *((_DWORD *)buf + 2) ^ qword_20DB0B858[BYTE1(v10) + 256] ^ *(void *)&v7[8
                                                                                    * (buf[4] ^ v9 ^ qword_20DB0B858[BYTE2(v8)] ^ *((void *)&crc_table + HIBYTE(v8)))] ^ qword_20DB0B858[BYTE2(v10)] ^ *((void *)&crc_table + HIBYTE(v10));
      unsigned int v12 = *((_DWORD *)buf + 3) ^ qword_20DB0B858[BYTE1(v11) + 256] ^ *(void *)&v7[8 * v11] ^ qword_20DB0B858[BYTE2(v11)] ^ *((void *)&crc_table + HIBYTE(v11));
      unsigned int v13 = *((_DWORD *)buf + 4) ^ qword_20DB0B858[BYTE1(v12) + 256] ^ *(void *)&v7[8 * v12] ^ qword_20DB0B858[BYTE2(v12)] ^ *((void *)&crc_table + HIBYTE(v12));
      unsigned int v14 = *((_DWORD *)buf + 5) ^ qword_20DB0B858[BYTE1(v13) + 256] ^ *(void *)&v7[8 * v13] ^ qword_20DB0B858[BYTE2(v13)] ^ *((void *)&crc_table + HIBYTE(v13));
      unsigned int v15 = *((_DWORD *)buf + 6) ^ qword_20DB0B858[BYTE1(v14) + 256] ^ *(void *)&v7[8 * v14] ^ qword_20DB0B858[BYTE2(v14)] ^ *((void *)&crc_table + HIBYTE(v14));
      int v16 = qword_20DB0B858[BYTE1(v15) + 256] ^ *(void *)&v7[8 * v15] ^ qword_20DB0B858[BYTE2(v15)] ^ *((void *)&crc_table + HIBYTE(v15));
      double v17 = buf + 32;
      unsigned int v18 = *((_DWORD *)buf + 7) ^ v16;
      unsigned int v3 = qword_20DB0B858[BYTE1(v18) + 256] ^ *(void *)&v7[8 * v18] ^ qword_20DB0B858[BYTE2(v18)] ^ *((void *)&crc_table + HIBYTE(v18));
      len -= 32;
      buf += 32;
    }
    while (len > 0x1F);
    buf = v17;
  }
  if (len >= 4)
  {
    do
    {
      int v19 = *(_DWORD *)buf;
      buf += 4;
      unsigned int v3 = *((_DWORD *)&crc_table + 2 * ((unsigned __int16)(v19 ^ v3) >> 8) + 1024) ^ *((_DWORD *)&crc_table + 2 * (v19 ^ v3) + 1536) ^ *((_DWORD *)&crc_table + 2 * ((v19 ^ v3) >> 16) + 512) ^ *((void *)&crc_table + ((v19 ^ v3) >> 24));
      len -= 4;
    }
    while (len > 3);
  }
  for (; len; --len)
  {
    char v20 = *buf++;
    unsigned int v3 = *((void *)&crc_table + (v20 ^ v3)) ^ (v3 >> 8);
  }
  return ~v3;
}

uint64_t touchpadGetInfoWithCompressedBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0;
  v6[0] = a3;
  v6[1] = a4;
  memset(&v6[2], 0, 24);
  if (a2 == 9)
  {
    if (codecReadHeader(v6, a1)) {
      return 9;
    }
    else {
      return 0;
    }
  }
  return result;
}

BOOL codecReadHeader(uint64_t *a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 8) = 0;
  *(void *)a2 = 0;
  int v2 = *((_DWORD *)a1 + 9);
  if (v2 <= 15)
  {
    unint64_t v4 = a1[1];
    unint64_t v3 = a1[2];
    a1[2] = v3 + 1;
    if (v3 < v4)
    {
      uint64_t v5 = *a1;
      uint64_t v6 = a1[3];
      a1[3] = v6 + 1;
      LODWORD(v5) = (*(unsigned __int8 *)(v5 + v6) << v2) | *((_DWORD *)a1 + 8);
      v2 += 8;
      *((_DWORD *)a1 + 8) = v5;
      *((_DWORD *)a1 + 9) = v2;
    }
    a1[2] = v3 + 2;
    if (v3 + 1 < v4)
    {
      uint64_t v7 = *a1;
      uint64_t v8 = a1[3];
      a1[3] = v8 + 1;
      *((_DWORD *)a1 + 8) |= *(unsigned __int8 *)(v7 + v8) << v2;
      v2 += 8;
    }
  }
  unsigned int v9 = a1[4] & 0x1F;
  unsigned int v10 = *((_DWORD *)a1 + 8) >> 5;
  int v11 = v2 - 5;
  *((_DWORD *)a1 + 8) = v10;
  *((_DWORD *)a1 + 9) = v2 - 5;
  unsigned int v12 = v9 - 16;
  if (v9 > 0x10)
  {
    if (v2 <= 20)
    {
      unint64_t v24 = a1[1];
      unint64_t v23 = a1[2];
      a1[2] = v23 + 1;
      if (v23 < v24)
      {
        uint64_t v25 = *a1;
        uint64_t v26 = a1[3];
        a1[3] = v26 + 1;
        v10 |= *(unsigned __int8 *)(v25 + v26) << v11;
        int v11 = v2 + 3;
        *((_DWORD *)a1 + 8) = v10;
        *((_DWORD *)a1 + 9) = v2 + 3;
      }
      a1[2] = v23 + 2;
      if (v23 + 1 < v24)
      {
        uint64_t v27 = *a1;
        uint64_t v28 = a1[3];
        a1[3] = v28 + 1;
        v10 |= *(unsigned __int8 *)(v27 + v28) << v11;
        v11 += 8;
      }
    }
    unsigned int v29 = HIWORD(v10);
    int v30 = v11 - 16;
    *((_DWORD *)a1 + 8) = HIWORD(v10);
    *((_DWORD *)a1 + 9) = v11 - 16;
    if (v11 <= 31)
    {
      unint64_t v32 = a1[1];
      unint64_t v31 = a1[2];
      a1[2] = v31 + 1;
      if (v31 < v32)
      {
        uint64_t v33 = *a1;
        uint64_t v34 = a1[3];
        a1[3] = v34 + 1;
        v29 |= *(unsigned __int8 *)(v33 + v34) << v30;
        int v30 = v11 - 8;
        *((_DWORD *)a1 + 8) = v29;
        *((_DWORD *)a1 + 9) = v11 - 8;
      }
      a1[2] = v31 + 2;
      if (v31 + 1 < v32)
      {
        uint64_t v35 = *a1;
        uint64_t v36 = a1[3];
        a1[3] = v36 + 1;
        v29 |= *(unsigned __int8 *)(v35 + v36) << v30;
        v30 += 8;
      }
    }
    int v37 = v29 & ~(-1 << v12);
    unsigned int v20 = v29 >> v12;
    int v21 = v30 - v12;
    *((_DWORD *)a1 + 8) = v20;
    *((_DWORD *)a1 + 9) = v30 - v12;
    int v22 = (unsigned __int16)v10 | (v37 << 16);
    int v19 = -1 << v9;
  }
  else
  {
    if (v2 <= 20)
    {
      unint64_t v14 = a1[1];
      unint64_t v13 = a1[2];
      a1[2] = v13 + 1;
      if (v13 < v14)
      {
        uint64_t v15 = *a1;
        uint64_t v16 = a1[3];
        a1[3] = v16 + 1;
        v10 |= *(unsigned __int8 *)(v15 + v16) << v11;
        int v11 = v2 + 3;
        *((_DWORD *)a1 + 8) = v10;
        *((_DWORD *)a1 + 9) = v2 + 3;
      }
      a1[2] = v13 + 2;
      if (v13 + 1 < v14)
      {
        uint64_t v17 = *a1;
        uint64_t v18 = a1[3];
        a1[3] = v18 + 1;
        v10 |= *(unsigned __int8 *)(v17 + v18) << v11;
        v11 += 8;
      }
    }
    int v19 = -1 << v9;
    unsigned int v20 = v10 >> v9;
    int v21 = v11 - v9;
    *((_DWORD *)a1 + 8) = v10 >> v9;
    *((_DWORD *)a1 + 9) = v21;
    int v22 = v10 & (unsigned __int16)~(unsigned __int16)(-1 << v9);
  }
  int v38 = v22 + ~v19;
  *(_DWORD *)a2 = v38;
  if (v38)
  {
    if (v21 <= 15)
    {
      unint64_t v40 = a1[1];
      unint64_t v39 = a1[2];
      a1[2] = v39 + 1;
      if (v39 < v40)
      {
        uint64_t v41 = *a1;
        uint64_t v42 = a1[3];
        a1[3] = v42 + 1;
        v20 |= *(unsigned __int8 *)(v41 + v42) << v21;
        v21 += 8;
        *((_DWORD *)a1 + 8) = v20;
        *((_DWORD *)a1 + 9) = v21;
      }
      a1[2] = v39 + 2;
      if (v39 + 1 < v40)
      {
        uint64_t v43 = *a1;
        uint64_t v44 = a1[3];
        a1[3] = v44 + 1;
        v20 |= *(unsigned __int8 *)(v43 + v44) << v21;
        v21 += 8;
      }
    }
    int v45 = v20 & 0xF;
    unsigned int v46 = v20 >> 4;
    int v47 = v21 - 4;
    *((_DWORD *)a1 + 8) = v46;
    *((_DWORD *)a1 + 9) = v21 - 4;
    int v48 = v45 + 1;
    if (v21 <= 19)
    {
      unint64_t v50 = a1[1];
      unint64_t v49 = a1[2];
      a1[2] = v49 + 1;
      if (v49 < v50)
      {
        uint64_t v51 = *a1;
        uint64_t v52 = a1[3];
        a1[3] = v52 + 1;
        v46 |= *(unsigned __int8 *)(v51 + v52) << v47;
        int v47 = v21 + 4;
        *((_DWORD *)a1 + 8) = v46;
        *((_DWORD *)a1 + 9) = v21 + 4;
      }
      a1[2] = v49 + 2;
      if (v49 + 1 < v50)
      {
        uint64_t v53 = *a1;
        uint64_t v54 = a1[3];
        a1[3] = v54 + 1;
        v46 |= *(unsigned __int8 *)(v53 + v54) << v47;
        v47 += 8;
      }
    }
    __int16 v55 = ~(unsigned __int16)(-2 << v45);
    __int16 v56 = v46 & v55;
    unsigned int v57 = v46 >> v48;
    int v58 = v47 - v48;
    *((_DWORD *)a1 + 8) = v57;
    *((_DWORD *)a1 + 9) = v47 - v48;
    *(_WORD *)(a2 + 4) = v56;
    if (v47 - v48 <= 15)
    {
      unint64_t v60 = a1[1];
      unint64_t v59 = a1[2];
      a1[2] = v59 + 1;
      if (v59 < v60)
      {
        uint64_t v61 = *a1;
        uint64_t v62 = a1[3];
        a1[3] = v62 + 1;
        v57 |= *(unsigned __int8 *)(v61 + v62) << v58;
        v58 += 8;
        *((_DWORD *)a1 + 8) = v57;
        *((_DWORD *)a1 + 9) = v58;
      }
      a1[2] = v59 + 2;
      if (v59 + 1 < v60)
      {
        uint64_t v63 = *a1;
        uint64_t v64 = a1[3];
        a1[3] = v64 + 1;
        v57 |= *(unsigned __int8 *)(v63 + v64) << v58;
        v58 += 8;
      }
    }
    __int16 v65 = v57 & v55;
    unsigned int v66 = v57 >> v48;
    int v67 = v58 - v48;
    *((_DWORD *)a1 + 8) = v66;
    *((_DWORD *)a1 + 9) = v67;
    *(_WORD *)(a2 + 6) = v65;
    if (v67 <= 15)
    {
      unint64_t v69 = a1[1];
      unint64_t v68 = a1[2];
      a1[2] = v68 + 1;
      if (v68 < v69)
      {
        uint64_t v70 = *a1;
        uint64_t v71 = a1[3];
        a1[3] = v71 + 1;
        v66 |= *(unsigned __int8 *)(v70 + v71) << v67;
        v67 += 8;
        *((_DWORD *)a1 + 8) = v66;
        *((_DWORD *)a1 + 9) = v67;
      }
      a1[2] = v68 + 2;
      if (v68 + 1 < v69)
      {
        uint64_t v72 = *a1;
        uint64_t v73 = a1[3];
        a1[3] = v73 + 1;
        v66 |= *(unsigned __int8 *)(v72 + v73) << v67;
        v67 += 8;
      }
    }
    char v74 = v66 & 0x1F;
    unsigned int v75 = v66 >> 5;
    int v21 = v67 - 5;
    *((_DWORD *)a1 + 8) = v75;
    *((_DWORD *)a1 + 9) = v67 - 5;
    *(unsigned char *)(a2 + 8) = v74 + 1;
  }
  return (v21 & 0x80000000) == 0 && a1[3] != v21 >> 3;
}

uint64_t *codecWriteHeader(uint64_t *result, int a2, int a3, __int16 a4, int a5)
{
  unsigned int v5 = __clz(a5 + 1);
  unsigned int v6 = 31 - v5;
  int v7 = *((_DWORD *)result + 9);
  unsigned int v8 = *((_DWORD *)result + 8) | ((unsigned __int16)(31 - v5) << v7);
  int v9 = v7 + 5;
  *((_DWORD *)result + 8) = v8;
  *((_DWORD *)result + 9) = v7 + 5;
  if (v7 >= 12)
  {
    unint64_t v10 = result[1];
    unint64_t v11 = result[2];
    unint64_t v12 = v11 + 1;
    result[2] = v11 + 1;
    if (v11 < v10)
    {
      uint64_t v13 = *result;
      uint64_t v14 = result[3];
      result[3] = v14 + 1;
      *(unsigned char *)(v13 + v14) = v8;
      unsigned int v8 = *((_DWORD *)result + 8);
      int v9 = *((_DWORD *)result + 9);
      unint64_t v10 = result[1];
      unint64_t v12 = result[2];
    }
    unsigned int v15 = v8 >> 8;
    int v16 = v9 - 8;
    *((_DWORD *)result + 8) = v15;
    *((_DWORD *)result + 9) = v16;
    result[2] = v12 + 1;
    if (v12 < v10)
    {
      uint64_t v17 = *result;
      uint64_t v18 = result[3];
      result[3] = v18 + 1;
      *(unsigned char *)(v17 + v18) = v15;
      unsigned int v15 = *((_DWORD *)result + 8);
      int v16 = *((_DWORD *)result + 9);
    }
    unsigned int v8 = v15 >> 8;
    int v9 = v16 - 8;
  }
  unsigned int v19 = v8 | ((unsigned __int16)(a5 + 1 - (0x80000000 >> v5)) << v9);
  int v20 = v9 + v6;
  *((_DWORD *)result + 8) = v19;
  *((_DWORD *)result + 9) = v9 + v6;
  if ((int)(v9 + v6) >= 17)
  {
    unint64_t v21 = result[1];
    unint64_t v22 = result[2];
    unint64_t v23 = v22 + 1;
    result[2] = v22 + 1;
    if (v22 < v21)
    {
      uint64_t v24 = *result;
      uint64_t v25 = result[3];
      result[3] = v25 + 1;
      *(unsigned char *)(v24 + v25) = v19;
      unsigned int v19 = *((_DWORD *)result + 8);
      int v20 = *((_DWORD *)result + 9);
      unint64_t v21 = result[1];
      unint64_t v23 = result[2];
    }
    unsigned int v26 = v19 >> 8;
    int v27 = v20 - 8;
    *((_DWORD *)result + 8) = v26;
    *((_DWORD *)result + 9) = v27;
    result[2] = v23 + 1;
    if (v23 < v21)
    {
      uint64_t v28 = *result;
      uint64_t v29 = result[3];
      result[3] = v29 + 1;
      *(unsigned char *)(v28 + v29) = v26;
      unsigned int v26 = *((_DWORD *)result + 8);
      int v27 = *((_DWORD *)result + 9);
    }
    unsigned int v19 = v26 >> 8;
    int v20 = v27 - 8;
    *((_DWORD *)result + 8) = v19;
    *((_DWORD *)result + 9) = v20;
  }
  if (a5)
  {
    unsigned int v30 = __clz(a3 | a2);
    unsigned int v31 = v19 | ((unsigned __int16)(31 - v30) << v20);
    int v32 = v20 + 4;
    *((_DWORD *)result + 8) = v31;
    *((_DWORD *)result + 9) = v20 + 4;
    if (v20 >= 13)
    {
      unint64_t v33 = result[1];
      unint64_t v34 = result[2];
      unint64_t v35 = v34 + 1;
      result[2] = v34 + 1;
      if (v34 < v33)
      {
        uint64_t v36 = *result;
        uint64_t v37 = result[3];
        result[3] = v37 + 1;
        *(unsigned char *)(v36 + v37) = v31;
        unsigned int v31 = *((_DWORD *)result + 8);
        int v32 = *((_DWORD *)result + 9);
        unint64_t v33 = result[1];
        unint64_t v35 = result[2];
      }
      unsigned int v38 = v31 >> 8;
      int v39 = v32 - 8;
      *((_DWORD *)result + 8) = v38;
      *((_DWORD *)result + 9) = v39;
      result[2] = v35 + 1;
      if (v35 < v33)
      {
        uint64_t v40 = *result;
        uint64_t v41 = result[3];
        result[3] = v41 + 1;
        *(unsigned char *)(v40 + v41) = v38;
        unsigned int v38 = *((_DWORD *)result + 8);
        int v39 = *((_DWORD *)result + 9);
      }
      unsigned int v31 = v38 >> 8;
      int v32 = v39 - 8;
    }
    unsigned int v42 = 32 - v30;
    unsigned int v43 = v31 | ((unsigned __int16)a2 << v32);
    unsigned int v44 = v32 + v42;
    *((_DWORD *)result + 8) = v43;
    *((_DWORD *)result + 9) = v32 + v42;
    if ((int)(v32 + v42) >= 17)
    {
      unint64_t v45 = result[1];
      unint64_t v46 = result[2];
      unint64_t v47 = v46 + 1;
      result[2] = v46 + 1;
      if (v46 < v45)
      {
        uint64_t v48 = *result;
        uint64_t v49 = result[3];
        result[3] = v49 + 1;
        *(unsigned char *)(v48 + v49) = v43;
        unsigned int v43 = *((_DWORD *)result + 8);
        unsigned int v44 = *((_DWORD *)result + 9);
        unint64_t v45 = result[1];
        unint64_t v47 = result[2];
      }
      unsigned int v50 = v43 >> 8;
      unsigned int v51 = v44 - 8;
      *((_DWORD *)result + 8) = v50;
      *((_DWORD *)result + 9) = v51;
      result[2] = v47 + 1;
      if (v47 < v45)
      {
        uint64_t v52 = *result;
        uint64_t v53 = result[3];
        result[3] = v53 + 1;
        *(unsigned char *)(v52 + v53) = v50;
        unsigned int v50 = *((_DWORD *)result + 8);
        unsigned int v51 = *((_DWORD *)result + 9);
      }
      unsigned int v43 = v50 >> 8;
      unsigned int v44 = v51 - 8;
    }
    unsigned int v54 = v43 | ((unsigned __int16)a3 << v44);
    int v55 = v44 + v42;
    *((_DWORD *)result + 8) = v54;
    *((_DWORD *)result + 9) = v55;
    if (v55 >= 17)
    {
      unint64_t v56 = result[1];
      unint64_t v57 = result[2];
      unint64_t v58 = v57 + 1;
      result[2] = v57 + 1;
      if (v57 < v56)
      {
        uint64_t v59 = *result;
        uint64_t v60 = result[3];
        result[3] = v60 + 1;
        *(unsigned char *)(v59 + v60) = v54;
        unsigned int v54 = *((_DWORD *)result + 8);
        int v55 = *((_DWORD *)result + 9);
        unint64_t v56 = result[1];
        unint64_t v58 = result[2];
      }
      unsigned int v61 = v54 >> 8;
      int v62 = v55 - 8;
      *((_DWORD *)result + 8) = v61;
      *((_DWORD *)result + 9) = v62;
      result[2] = v58 + 1;
      if (v58 < v56)
      {
        uint64_t v63 = *result;
        uint64_t v64 = result[3];
        result[3] = v64 + 1;
        *(unsigned char *)(v63 + v64) = v61;
        unsigned int v61 = *((_DWORD *)result + 8);
        int v62 = *((_DWORD *)result + 9);
      }
      unsigned int v54 = v61 >> 8;
      int v55 = v62 - 8;
    }
    unsigned int v65 = v54 | ((unsigned __int16)(a4 - 1) << v55);
    int v66 = v55 + 5;
    *((_DWORD *)result + 8) = v65;
    *((_DWORD *)result + 9) = v55 + 5;
    if (v55 >= 12)
    {
      unint64_t v67 = result[1];
      unint64_t v68 = result[2];
      unint64_t v69 = v68 + 1;
      result[2] = v68 + 1;
      if (v68 < v67)
      {
        uint64_t v70 = *result;
        uint64_t v71 = result[3];
        result[3] = v71 + 1;
        *(unsigned char *)(v70 + v71) = v65;
        unsigned int v65 = *((_DWORD *)result + 8);
        int v66 = *((_DWORD *)result + 9);
        unint64_t v67 = result[1];
        unint64_t v69 = result[2];
      }
      unsigned int v72 = v65 >> 8;
      int v73 = v66 - 8;
      *((_DWORD *)result + 8) = v72;
      *((_DWORD *)result + 9) = v73;
      result[2] = v69 + 1;
      if (v69 < v67)
      {
        uint64_t v74 = *result;
        uint64_t v75 = result[3];
        result[3] = v75 + 1;
        *(unsigned char *)(v74 + v75) = v72;
        unsigned int v72 = *((_DWORD *)result + 8);
        int v73 = *((_DWORD *)result + 9);
      }
      *((_DWORD *)result + 8) = v72 >> 8;
      *((_DWORD *)result + 9) = v73 - 8;
    }
  }
  return result;
}

void *touchpadCodecCreate(int a1, int a2, int a3, int a4, uint64_t a5)
{
  unsigned int v5 = 0;
  if (a1)
  {
    if (a2)
    {
      if (a3 == 16 && !a4 && !a5)
      {
        unsigned int v8 = calloc(1uLL, 0x2A8uLL);
        unsigned int v5 = v8;
        if (v8)
        {
          v8[81] = (a2 * a1);
          v8[80] = 2 * (a2 * a1);
          v8[82] = 0;
          *((_DWORD *)v8 + 166) = a1;
          *((_DWORD *)v8 + 167) = a2;
          *((unsigned char *)v8 + 672) = 16;
          int v9 = malloc(2 * (a2 * a1));
          v5[79] = v9;
          if (v9)
          {
            bzero(v9, 2 * (a2 * a1));
            for (uint64_t i = 0; i != 630; i += 10)
            {
              unint64_t v11 = (char *)v5 + i;
              *(void *)unint64_t v11 = 32;
              *((_WORD *)v11 + 4) = 261;
            }
            v5[82] = 0;
          }
          else
          {
            free(v5);
            return 0;
          }
        }
      }
    }
  }
  return v5;
}

void codecResetModel(uint64_t a1)
{
  bzero(*(void **)(a1 + 632), *(void *)(a1 + 640));
  for (uint64_t i = 0; i != 630; i += 10)
  {
    uint64_t v3 = a1 + i;
    *(void *)uint64_t v3 = 32;
    *(_WORD *)(v3 + 8) = 261;
  }
  *(void *)(a1 + 656) = 0;
}

void touchpadCodecDestroy(void **a1)
{
  if (a1)
  {
    free(a1[79]);
    free(a1);
  }
}

uint64_t codecGetFooterID(uint64_t a1)
{
  uint64_t v1 = 0;
  int v2 = 0;
  do
  {
    int v2 = *(_DWORD *)(a1 + v1) ^ __ROR4__(v2, 31);
    v1 += 10;
  }
  while (v1 != 630);
  return (-1640531535 * v2) >> 20;
}

double lzx_decoder_init(void *a1)
{
  bzero(a1 + 1, 0x807E8uLL);
  *((_DWORD *)a1 + 2) = 1;
  *(void *)&double result = 0x100000001;
  *a1 = 0x100000001;
  a1[16448] = 496;
  a1[32895] = 249;
  a1[49342] = 8;
  return result;
}

uint64_t brotli_decode_buffer(uint64_t a1, uint64_t a2)
{
  if (BrotliDecoderDecompress()) {
    return a2;
  }
  else {
    return 0;
  }
}

unint64_t brotli_encode_buffer(unsigned char *a1, unint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, int a6)
{
  unint64_t v7 = a2;
  if (BrotliEncoderCompress(a6, 22, 0, a4, a3, &v7, a1)) {
    return v7;
  }
  else {
    return 0;
  }
}

unint64_t yzip_plane_encoder_allocate(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t format_convert_at_once = get_format_convert_at_once(a5);
  unsigned int format_process_at_once = get_format_process_at_once(a5);
  uint64_t v14 = a4 * a2 + 16;
  uint64_t v15 = v14 * format_process_at_once;
  a1[8] = 0;
  uint64_t v16 = v14 * format_convert_at_once;
  unint64_t v17 = (((a6 + 15) | 0xE) + 2 * v16) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v18 = (v17 + 2 * v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  *a1 = v18;
  a1[1] = ((a6 + 15) & 0xFFFFFFFFFFFFFFF0) + 16;
  unint64_t v19 = (v18 + 2 * v15 + 15) & 0xFFFFFFFFFFFFFFF0;
  a1[2] = v17 + 16;
  a1[3] = v19;
  v15 += 15;
  unint64_t v20 = (v15 + v19) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v21 = (v15 + v20) & 0xFFFFFFFFFFFFFFF0;
  a1[4] = v20;
  a1[5] = v21;
  unint64_t v22 = (v21 + 1039) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v23 = (v22 + 15999) & 0xFFFFFFFFFFFFFFF0;
  unint64_t result = v23 + 4 * a4 * a2 * a3;
  a1[6] = v22;
  a1[7] = v23;
  return result;
}

unint64_t yzip_plane_decoder_allocate(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  unint64_t v7 = (((a5 + 15) | 0xE) + (2 * a3 * a2 + 32) * get_format_convert_at_once(a4)) & 0xFFFFFFFFFFFFFFF0;
  unint64_t result = v7 + 1024;
  *a1 = ((a5 + 15) & 0xFFFFFFFFFFFFFFF0) + 16;
  a1[1] = v7;
  return result;
}

uint64_t yzip_plane_encoder_phase1(uint64_t a1)
{
  v115[0] = 0;
  v115[1] = 0;
  int v2 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 16);
  uint64_t v3 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 9);
  unsigned int format_convert_at_once = get_format_convert_at_once(v2);
  int format_process_at_once = get_format_process_at_once(v2);
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  uint64_t v5 = *(unsigned int *)(a1 + 20);
  unsigned int v6 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 8);
  int v107 = is_format_msb_layout(v2);
  uint64_t result = 0xFFFFFFFFLL;
  if (!v4 || !v5) {
    return result;
  }
  if (v6 < 8 || v6 > 0x10) {
    return result;
  }
  get_conversion_set(v115, v2, v6, v3);
  if (!v115[0]) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v9 = *(void *)(a1 + 104) + (*(void *)(a1 + 144) & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v105 = *(void *)(a1 + 104);
  if ((uint64_t)((*(void *)(a1 + 144) & 0xFFFFFFFFFFFFFFFCLL) - 10) < 5) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v101 = (v4 * v3 * format_process_at_once);
  uint64_t v10 = (v101 + 2) + 15;
  uint64_t v106 = v10 & 0x1FFFFFFF0;
  uint64_t v120 = 0;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  unint64_t v11 = v4 + (v5 << 16);
  *(_DWORD *)(v9 - 4) = v11;
  uint64_t v99 = v6 - 1;
  unint64_t v12 = v99 + HIDWORD(v11);
  uint64_t v94 = a1;
  unsigned int v93 = v5;
  yzip_plane_encoder_allocate((unint64_t *)&v116, v4, v5, v3, v2, *(void *)(a1 + 96));
  uint64_t v13 = 0;
  uint64_t v14 = (_OWORD *)*((void *)&v118 + 1);
  *(void *)&long long v15 = -1;
  *((void *)&v15 + 1) = -1;
  **((_OWORD **)&v118 + 1) = v15;
  v14[1] = v15;
  _OWORD v14[2] = v15;
  v14[3] = v15;
  v14[4] = v15;
  v14[5] = v15;
  v14[6] = v15;
  v14[7] = v15;
  v14[8] = v15;
  v14[9] = v15;
  v14[10] = v15;
  v14[11] = v15;
  v14[12] = v15;
  v14[13] = v15;
  v14[14] = v15;
  v14[15] = v15;
  v14[16] = v15;
  v14[17] = v15;
  v14[18] = v15;
  v14[19] = v15;
  v14[20] = v15;
  v14[21] = v15;
  v14[22] = v15;
  v14[23] = v15;
  v14[24] = v15;
  v14[25] = v15;
  v14[26] = v15;
  v14[27] = v15;
  v14[28] = v15;
  v14[29] = v15;
  v14[30] = v15;
  v14[31] = v15;
  *(void *)&long long v15 = 0x101010101010101;
  *((void *)&v15 + 1) = 0x101010101010101;
  v14[62] = v15;
  v14[63] = v15;
  v14[60] = v15;
  v14[61] = v15;
  v14[58] = v15;
  v14[59] = v15;
  v14[56] = v15;
  v14[57] = v15;
  v14[54] = v15;
  v14[55] = v15;
  v14[52] = v15;
  v14[53] = v15;
  v14[50] = v15;
  v14[51] = v15;
  v14[48] = v15;
  _OWORD v14[49] = v15;
  v14[46] = v15;
  v14[47] = v15;
  v14[44] = v15;
  v14[45] = v15;
  v14[42] = v15;
  v14[43] = v15;
  v14[40] = v15;
  v14[41] = v15;
  v14[38] = v15;
  v14[39] = v15;
  v14[36] = v15;
  v14[37] = v15;
  v14[34] = v15;
  v14[35] = v15;
  uint64_t v16 = (char *)v14 + 477;
  v14[32] = v15;
  v14[33] = v15;
  uint64_t v98 = v14;
  do
  {
    v16[v13] = quantize_slow((int)v13 - 35);
    ++v13;
  }
  while (v13 != 71);
  uint64_t v100 = v119;
  bzero((void *)v119, 0x3E70uLL);
  unsigned int v17 = 0;
  int v18 = 0;
  unsigned int v19 = 0;
  unsigned int v20 = 0;
  LODWORD(v120) = 0;
  unint64_t v21 = (__int16 *)(*((void *)&v116 + 1) - 4);
  *(_DWORD *)(*((void *)&v116 + 1) - 6) = 0;
  unint64_t v92 = v9;
  unint64_t v22 = (_DWORD *)(v9 - 8);
  unsigned int v104 = v6;
  uint64_t v103 = (2 * v10) & 0x3FFFFFFE0;
  unsigned int v23 = 4;
  char v96 = 16 - v6;
  char v97 = 32 - v6;
  uint64_t v24 = format_convert_at_once;
  do
  {
    int v95 = v18;
    uint64_t v111 = *(void *)(((unint64_t)&v116 | (8 * (v18 & 1))) + 8);
    ((void (*)(void))v115[0])();
    uint64_t v25 = v24;
    if (v24)
    {
      LODWORD(v26) = 0;
      uint64_t v28 = (char *)*((void *)&v117 + 1);
      uint64_t v27 = v118;
      uint64_t v29 = (int16x8_t *)v116;
      uint64_t v31 = v100;
      unint64_t v30 = v101;
      unint64_t v33 = v98;
      char v32 = v99;
      char v34 = v97;
      v35.i64[0] = 0x22002200220022;
      v35.i64[1] = 0x22002200220022;
      v36.i64[0] = 0x23002300230023;
      v36.i64[1] = 0x23002300230023;
      v37.i64[0] = 0xFFFF0000FFFFLL;
      v37.i64[1] = 0xFFFF0000FFFFLL;
      v38.i64[0] = 0x1000000010000;
      v38.i64[1] = 0x1000000010000;
      v39.i64[0] = 0x2200000022;
      v39.i64[1] = 0x2200000022;
      v40.i64[0] = 0x2300000023;
      v40.i64[1] = 0x2300000023;
      v41.i64[0] = 0x4700000047;
      v41.i64[1] = 0x4700000047;
      int v113 = (int16x8_t *)v116;
      uint64_t v114 = v118;
      while (1)
      {
        if ((uint64_t)v22 + -((v23 + 31) >> 3) - v105 - 3 < (uint64_t)v30) {
          return 0xFFFFFFFFLL;
        }
        int v110 = v26;
        uint64_t v26 = v26;
        unsigned int v42 = (uint16x8_t *)(v111 + 2 * v106 * v26);
        char v112 = v42;
        if (v107)
        {
          uint64_t v108 = v26;
          convert_row_to_lsb(v42, v30, v96);
          uint64_t v26 = v108;
          unsigned int v42 = v112;
          uint64_t v29 = v113;
          uint64_t v27 = v114;
          v41.i64[0] = 0x4700000047;
          v41.i64[1] = 0x4700000047;
          v40.i64[0] = 0x2300000023;
          v40.i64[1] = 0x2300000023;
          v39.i64[0] = 0x2200000022;
          v39.i64[1] = 0x2200000022;
          v38.i64[0] = 0x1000000010000;
          v38.i64[1] = 0x1000000010000;
          v37.i64[0] = 0xFFFF0000FFFFLL;
          v37.i64[1] = 0xFFFF0000FFFFLL;
          v36.i64[0] = 0x23002300230023;
          v36.i64[1] = 0x23002300230023;
          v35.i64[0] = 0x22002200220022;
          v35.i64[1] = 0x22002200220022;
          char v34 = v97;
          unint64_t v33 = v98;
          char v32 = v99;
          uint64_t v31 = v100;
          unint64_t v30 = v101;
          uint64_t v25 = format_convert_at_once;
        }
        unsigned int v43 = (int16x8_t *)(v111 + v103 * v26);
        v42[-1].i16[7] = *v21;
        v42->i16[v30] = v42->i16[(v101 - 1)];
        if (v104 >= 0xF)
        {
          unint64_t v53 = 0;
          unsigned int v54 = v29;
          do
          {
            uint16x8_t v55 = *(uint16x8_t *)(v21 - 1);
            int16x8_t v56 = *(int16x8_t *)v21;
            v21 += 8;
            int16x8_t v57 = v56;
            int16x8_t v58 = *(int16x8_t *)((char *)v43 - 2);
            int16x8_t v59 = *v43++;
            int32x4_t v60 = (int32x4_t)vsubl_u16(*(uint16x4_t *)v57.i8, *(uint16x4_t *)v55.i8);
            int32x4_t v61 = (int32x4_t)vsubl_high_u16((uint16x8_t)v57, v55);
            int32x4_t v62 = (int32x4_t)vaddw_high_u16((uint32x4_t)v61, (uint16x8_t)v58);
            int32x4_t v63 = (int32x4_t)vaddw_u16((uint32x4_t)v60, *(uint16x4_t *)v58.i8);
            int16x8_t v64 = vuzp1q_s16((int16x8_t)vorrq_s8((int8x16_t)vcgtq_s32(v63, v37), (int8x16_t)vminq_u32((uint32x4_t)v63, v38)), (int16x8_t)vorrq_s8((int8x16_t)vcgtq_s32(v62, v37), (int8x16_t)vminq_u32((uint32x4_t)v62, v38)));
            *(int8x8_t *)&v28[v53] = vmovn_s16(vuzp1q_s16((int16x8_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v60) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)), vandq_s8((int8x16_t)vcgtq_s32(v60, v40), (int8x16_t)v40)), vandq_s8((int8x16_t)v60, (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v60, v40)))), (int16x8_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v61) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)), vandq_s8((int8x16_t)vcgtq_s32(v61, v40), (int8x16_t)v40)), vandq_s8((int8x16_t)v61, (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v61, v40))))));
            int32x4_t v65 = (int32x4_t)vsubl_high_u16((uint16x8_t)v58, v55);
            int32x4_t v66 = (int32x4_t)vsubl_u16(*(uint16x4_t *)v58.i8, *(uint16x4_t *)v55.i8);
            *(int8x8_t *)(v27 + v53) = vmovn_s16(vuzp1q_s16((int16x8_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v66) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)), vandq_s8((int8x16_t)vcgtq_s32(v66, v40), (int8x16_t)v40)), vandq_s8((int8x16_t)v66, (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v66, v40)))), (int16x8_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vcgtq_s32(v39, v65) & __PAIR128__(0xFFFFFFDDFFFFFFDDLL, 0xFFFFFFDDFFFFFFDDLL)), vandq_s8((int8x16_t)vcgtq_s32(v65, v40), (int8x16_t)v40)), vandq_s8((int8x16_t)v65, (int8x16_t)vcgtq_u32(v41, (uint32x4_t)vaddq_s32(v65, v40))))));
            *v54++ = vsubq_s16(vaddq_s16(vaddq_s16(vsubq_s16(v59, vaddq_s16(v58, v57)), (int16x8_t)vminq_u16(vminq_u16((uint16x8_t)v58, (uint16x8_t)v57), (uint16x8_t)v64)), (int16x8_t)vmaxq_u16(vmaxq_u16((uint16x8_t)v58, (uint16x8_t)v57), (uint16x8_t)v64)), v64);
            v53 += 8;
          }
          while (v53 <= v30);
        }
        else
        {
          unint64_t v44 = 0;
          unint64_t v45 = v29;
          do
          {
            int16x8_t v46 = *(int16x8_t *)(v21 - 1);
            int16x8_t v47 = *(int16x8_t *)v21;
            v21 += 8;
            int16x8_t v48 = v47;
            int16x8_t v49 = *(int16x8_t *)((char *)v43 - 2);
            int16x8_t v50 = *v43++;
            int16x8_t v51 = vsubq_s16(v48, v46);
            int16x8_t v52 = vaddq_s16(v51, v49);
            *(int8x8_t *)&v28[v44] = vmovn_s16(vminq_s16(vmaxq_s16(v51, v35), v36));
            *(int8x8_t *)(v27 + v44) = vmovn_s16(vminq_s16(vmaxq_s16(vsubq_s16(v49, v46), v35), v36));
            *v45++ = vaddq_s16(vsubq_s16(v50, vaddq_s16(vaddq_s16(v49, v48), v52)), vaddq_s16(vminq_s16(vminq_s16(v49, v48), v52), vmaxq_s16(vmaxq_s16(v49, v48), v52)));
            v44 += 8;
          }
          while (v44 <= v30);
        }
        if (v30) {
          break;
        }
LABEL_47:
        LODWORD(v26) = v110 + 1;
        unsigned int v85 = v112;
        unint64_t v21 = (__int16 *)v112;
        if ((v110 + 1) * format_process_at_once >= v25) {
          goto LABEL_50;
        }
      }
      uint64_t v67 = 0;
      int v68 = *((char *)v33 + *v28 + 512);
      uint64_t v69 = *((void *)&v119 + 1);
      while (1)
      {
        uint64_t v70 = v67 + 1;
        int v71 = *((char *)v33 + v28[v67 + 1] + 512);
        int v72 = *((char *)v33 + *(char *)(v27 + v67) + 512) + 11 * (v71 + 11 * v68);
        unsigned int v73 = v29->i16[v67];
        if (v72 >= 0) {
          unsigned int v74 = v72;
        }
        else {
          unsigned int v74 = -v72;
        }
        if (v72 < 0) {
          unsigned int v73 = -v73;
        }
        if (!v19 && v72) {
          goto LABEL_42;
        }
        if (v73) {
          break;
        }
        ++v19;
LABEL_46:
        uint64_t v67 = v70;
        int v68 = v71;
        if (v70 == v30) {
          goto LABEL_47;
        }
      }
      int v75 = lut_rle[v20];
      if (v19 >> v75)
      {
        uint64_t v76 = &lut_rle[v20 + 1];
        do
        {
          _DWORD *v22 = v12;
          unint64_t v12 = (v12 >> (v23 & 0x20)) + (1 << (v23 & 0x1F));
          unsigned int v77 = (v23 & 0x1F) + 1;
          v22 -= v23 >> 5;
          v19 += -1 << v75;
          int v78 = *v76++;
          int v75 = v78;
          ++v20;
          unsigned int v23 = v77;
        }
        while (v19 >> v78);
      }
      else
      {
        unsigned int v77 = v23;
      }
      v73 += (v73 >> v32) & 1;
      _DWORD *v22 = v12;
      unint64_t v12 = ((unint64_t)(2 * v19) << (v77 & 0x1F)) + (v12 >> (v77 & 0x20));
      unsigned int v17 = v120;
      unsigned int v23 = (v77 & 0x1F) + v75 + 1;
      v22 -= v77 >> 5;
      unsigned int v20 = v20 - 1 + ((v20 - 1) >> 31);
      uint64_t v29 = v113;
      uint64_t v27 = v114;
LABEL_42:
      unsigned int v19 = 0;
      int v79 = v73 << v34;
      *(_DWORD *)(v69 + 4 * v17) = v79 + v74;
      uint64_t v80 = v31 + 24 * v74;
      int v81 = v79 >> v34;
      if (v81 >= 0) {
        uint64_t v82 = v81;
      }
      else {
        uint64_t v82 = -v81;
      }
      uint64_t v83 = *(void *)(v80 + 8);
      uint64_t v84 = *(void *)v80 + v82;
      LODWORD(v120) = ++v17;
      *(void *)uint64_t v80 = v84;
      *(void *)(v80 + 8) = v83 + v81;
      ++*(_DWORD *)(v80 + 16);
      goto LABEL_46;
    }
    unsigned int v85 = (uint16x8_t *)v21;
LABEL_50:
    int v18 = v95 + 1;
    unint64_t v21 = (__int16 *)v85;
    uint64_t v24 = v25;
  }
  while ((v95 + 1) * (int)v25 < v93);
  if (v19)
  {
    int v86 = lut_rle[v20];
    if (v19 >> v86)
    {
      unsigned int v87 = &lut_rle[v20 + 1];
      unint64_t v88 = v92;
      uint64_t v89 = v100;
      do
      {
        _DWORD *v22 = v12;
        unint64_t v12 = (v12 >> (v23 & 0x20)) + (1 << (v23 & 0x1F));
        unsigned int v90 = (v23 & 0x1F) + 1;
        v22 -= v23 >> 5;
        v19 += -1 << v86;
        int v91 = *v87++;
        int v86 = v91;
        unsigned int v23 = v90;
      }
      while (v19 >> v91);
    }
    else
    {
      unsigned int v90 = v23;
      unint64_t v88 = v92;
      uint64_t v89 = v100;
    }
    _DWORD *v22 = v12;
    unint64_t v12 = ((unint64_t)(2 * v19) << (v90 & 0x1F)) + (v12 >> (v90 & 0x20));
    unsigned int v23 = (v90 & 0x1F) + v86 + 1;
    v22 -= v90 >> 5;
    unsigned int v17 = v120;
  }
  else
  {
    unint64_t v88 = v92;
    uint64_t v89 = v100;
  }
  uint64_t result = 0;
  *(void *)(v94 + 40) = 0;
  *(void *)(v94 + 48) = v12;
  *(_DWORD *)(v94 + 56) = 0;
  *(_DWORD *)(v94 + 60) = v23;
  *(void *)(v94 + 64) = v105;
  *(void *)(v94 + 72) = v88;
  *(void *)(v94 + 80) = v22;
  *(void *)(v94 + 88) = v105;
  *(void *)(v94 + 112) = v89;
  *(void *)(v94 + 128) = *((void *)&v119 + 1);
  *(_DWORD *)(v94 + 136) = v17;
  return result;
}

uint64_t yzip_plane_encoder_phase2(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 48);
  unsigned int v3 = *(_DWORD *)(a1 + 56);
  int v4 = *(_DWORD *)(a1 + 60);
  uint64_t v5 = *(_DWORD **)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  unsigned int v8 = *(char **)(a1 + 80);
  uint64_t v7 = *(void *)(a1 + 88);
  unsigned int v9 = *(_DWORD *)(a1 + 136);
  if (v9)
  {
    unsigned int v10 = 0;
    char v11 = 32 - *(unsigned char *)(*(void *)(a1 + 32) + 8);
    uint64_t v12 = *(void *)(a1 + 120);
    uint64_t v13 = *(void *)(a1 + 128);
    uint64_t v14 = (v4 + 31) >> 3;
    while (1)
    {
      uint64_t v15 = v8 - ((char *)v5 + v14 + ((v3 + 31) >> 3));
      if (v15 < 32) {
        return -1;
      }
      unsigned int v16 = v10 + ((unint64_t)v15 >> 2);
      if (v16 >= v9) {
        unsigned int v16 = v9;
      }
      if (v10 + 8 <= v16)
      {
        do
        {
          int v17 = *(_DWORD *)(v13 + 4 * v10);
          int v18 = (__int16)v17;
          unsigned int v19 = (__int16 *)(v12 + 4 * (__int16)v17);
          int v20 = ((v17 >> v11) - *v19) << v11 >> v11;
          unsigned int v21 = (2 * v20) ^ ~(~(2 * v20) >> 31);
          int v22 = *((unsigned __int8 *)v19 + 2);
          unsigned int v23 = v21 >> v22;
          int v24 = v3 & 0x1F;
          if (v21 >> v22 > 0xF)
          {
            unsigned int v25 = (v21 + (-16 << v22)) << 16;
            unsigned int v26 = v24 + *(unsigned __int8 *)(v12 + 4 * v18 + 3) + 16;
          }
          else
          {
            unsigned int v25 = ((2 * (v21 & ~(-1 << v22))) | 1) << v23;
            unsigned int v26 = v24 + v22 + v23 + 1;
          }
          *uint64_t v5 = v1;
          int v27 = *(_DWORD *)(v13 + 4 * (v10 + 1));
          int v28 = (__int16)v27;
          uint64_t v29 = (__int16 *)(v12 + 4 * (__int16)v27);
          int v30 = ((v27 >> v11) - *v29) << v11 >> v11;
          unsigned int v31 = (2 * v30) ^ ~(~(2 * v30) >> 31);
          int v32 = *((unsigned __int8 *)v29 + 2);
          unsigned int v33 = v31 >> v32;
          int v34 = v26 & 0x1F;
          if (v31 >> v32 > 0xF)
          {
            int v37 = *(unsigned __int8 *)(v12 + 4 * v28 + 3);
            unsigned int v35 = (v31 + (-16 << v32)) << 16;
            unsigned int v36 = v34 + v37 + 16;
          }
          else
          {
            unsigned int v35 = ((2 * (v31 & ~(-1 << v32))) | 1) << v33;
            unsigned int v36 = v34 + v32 + v33 + 1;
          }
          unint64_t v38 = ((unint64_t)v25 << v24) + (v1 >> (v3 & 0x20));
          int32x4_t v39 = &v5[v3 >> 5];
          *int32x4_t v39 = v38;
          int v40 = *(_DWORD *)(v13 + 4 * (v10 + 2));
          int v41 = (__int16)v40;
          unsigned int v42 = (__int16 *)(v12 + 4 * (__int16)v40);
          int v43 = ((v40 >> v11) - *v42) << v11 >> v11;
          unsigned int v44 = (2 * v43) ^ ~(~(2 * v43) >> 31);
          int v45 = *((unsigned __int8 *)v42 + 2);
          unsigned int v46 = v44 >> v45;
          int v47 = v36 & 0x1F;
          if (v44 >> v45 > 0xF)
          {
            int v50 = *(unsigned __int8 *)(v12 + 4 * v41 + 3);
            unsigned int v48 = (v44 + (-16 << v45)) << 16;
            unsigned int v49 = v47 + v50 + 16;
          }
          else
          {
            unsigned int v48 = ((2 * (v44 & ~(-1 << v45))) | 1) << v46;
            unsigned int v49 = v47 + v45 + v46 + 1;
          }
          unint64_t v51 = ((unint64_t)v35 << v34) + (v38 >> (v26 & 0x20));
          int16x8_t v52 = &v39[v26 >> 5];
          *int16x8_t v52 = v51;
          int v53 = *(_DWORD *)(v13 + 4 * (v10 + 3));
          int v54 = (__int16)v53;
          uint16x8_t v55 = (__int16 *)(v12 + 4 * (__int16)v53);
          int v56 = ((v53 >> v11) - *v55) << v11 >> v11;
          unsigned int v57 = (2 * v56) ^ ~(~(2 * v56) >> 31);
          int v58 = *((unsigned __int8 *)v55 + 2);
          unsigned int v59 = v57 >> v58;
          int v60 = v49 & 0x1F;
          if (v57 >> v58 > 0xF)
          {
            int v63 = *(unsigned __int8 *)(v12 + 4 * v54 + 3);
            unsigned int v61 = (v57 + (-16 << v58)) << 16;
            unsigned int v62 = v60 + v63 + 16;
          }
          else
          {
            unsigned int v61 = ((2 * (v57 & ~(-1 << v58))) | 1) << v59;
            unsigned int v62 = v60 + v58 + v59 + 1;
          }
          unint64_t v64 = ((unint64_t)v48 << v47) + (v51 >> (v36 & 0x20));
          int32x4_t v65 = &v52[v36 >> 5];
          *int32x4_t v65 = v64;
          int v66 = *(_DWORD *)(v13 + 4 * (v10 + 4));
          int v67 = (__int16)v66;
          int v68 = (__int16 *)(v12 + 4 * (__int16)v66);
          int v69 = ((v66 >> v11) - *v68) << v11 >> v11;
          unsigned int v70 = (2 * v69) ^ ~(~(2 * v69) >> 31);
          int v71 = *((unsigned __int8 *)v68 + 2);
          unsigned int v72 = v70 >> v71;
          int v73 = v62 & 0x1F;
          if (v70 >> v71 > 0xF)
          {
            int v76 = *(unsigned __int8 *)(v12 + 4 * v67 + 3);
            unsigned int v74 = (v70 + (-16 << v71)) << 16;
            unsigned int v75 = v73 + v76 + 16;
          }
          else
          {
            unsigned int v74 = ((2 * (v70 & ~(-1 << v71))) | 1) << v72;
            unsigned int v75 = v73 + v71 + v72 + 1;
          }
          unint64_t v77 = ((unint64_t)v61 << v60) + (v64 >> (v49 & 0x20));
          int v78 = &v65[v49 >> 5];
          *int v78 = v77;
          int v79 = *(_DWORD *)(v13 + 4 * (v10 + 5));
          int v80 = (__int16)v79;
          int v81 = (__int16 *)(v12 + 4 * (__int16)v79);
          int v82 = ((v79 >> v11) - *v81) << v11 >> v11;
          unsigned int v83 = (2 * v82) ^ ~(~(2 * v82) >> 31);
          int v84 = *((unsigned __int8 *)v81 + 2);
          unsigned int v85 = v83 >> v84;
          int v86 = v75 & 0x1F;
          if (v83 >> v84 > 0xF)
          {
            int v89 = *(unsigned __int8 *)(v12 + 4 * v80 + 3);
            unsigned int v87 = (v83 + (-16 << v84)) << 16;
            unsigned int v88 = v86 + v89 + 16;
          }
          else
          {
            unsigned int v87 = ((2 * (v83 & ~(-1 << v84))) | 1) << v85;
            unsigned int v88 = v86 + v84 + v85 + 1;
          }
          unint64_t v90 = ((unint64_t)v74 << v73) + (v77 >> (v62 & 0x20));
          int v91 = &v78[v62 >> 5];
          *int v91 = v90;
          int v92 = *(_DWORD *)(v13 + 4 * (v10 + 6));
          int v93 = (__int16)v92;
          uint64_t v94 = (__int16 *)(v12 + 4 * (__int16)v92);
          int v95 = ((v92 >> v11) - *v94) << v11 >> v11;
          unsigned int v96 = (2 * v95) ^ ~(~(2 * v95) >> 31);
          int v97 = *((unsigned __int8 *)v94 + 2);
          unsigned int v98 = v96 >> v97;
          int v99 = v88 & 0x1F;
          if (v96 >> v97 > 0xF)
          {
            int v102 = *(unsigned __int8 *)(v12 + 4 * v93 + 3);
            unsigned int v100 = (v96 + (-16 << v97)) << 16;
            unsigned int v101 = v99 + v102 + 16;
          }
          else
          {
            unsigned int v100 = ((2 * (v96 & ~(-1 << v97))) | 1) << v98;
            unsigned int v101 = v99 + v97 + v98 + 1;
          }
          unint64_t v103 = ((unint64_t)v87 << v86) + (v90 >> (v75 & 0x20));
          unsigned int v104 = &v91[v75 >> 5];
          *unsigned int v104 = v103;
          int v105 = *(_DWORD *)(v13 + 4 * (v10 + 7));
          int v106 = (__int16)v105;
          int v107 = (__int16 *)(v12 + 4 * (__int16)v105);
          int v108 = ((v105 >> v11) - *v107) << v11 >> v11;
          unsigned int v109 = (2 * v108) ^ ~(~(2 * v108) >> 31);
          int v110 = *((unsigned __int8 *)v107 + 2);
          unsigned int v111 = v109 >> v110;
          int v112 = v101 & 0x1F;
          if (v109 >> v110 > 0xF)
          {
            int v114 = *(unsigned __int8 *)(v12 + 4 * v106 + 3);
            unsigned int v113 = (v109 + (-16 << v110)) << 16;
            unsigned int v3 = v112 + v114 + 16;
          }
          else
          {
            unsigned int v113 = ((2 * (v109 & ~(-1 << v110))) | 1) << v111;
            unsigned int v3 = v112 + v110 + v111 + 1;
          }
          unint64_t v115 = ((unint64_t)v100 << v99) + (v103 >> (v88 & 0x20));
          long long v116 = &v104[v88 >> 5];
          unint64_t v1 = ((unint64_t)v113 << v112) + (v115 >> (v101 & 0x20));
          *long long v116 = v115;
          LODWORD(v115) = v101 >> 5;
          unsigned int v117 = v10 + 16;
          v10 += 8;
          uint64_t v5 = &v116[v115];
        }
        while (v117 <= v16);
      }
      if (v10 < v16)
      {
        uint64_t v118 = v10;
        long long v119 = (int *)(v13 + 4 * v10);
        uint64_t v120 = v118 - v16;
        do
        {
          int v121 = *v119++;
          int v122 = (__int16)v121;
          unint64_t v123 = (__int16 *)(v12 + 4 * (__int16)v121);
          int v124 = ((v121 >> v11) - *v123) << v11 >> v11;
          unsigned int v125 = (2 * v124) ^ ~(~(2 * v124) >> 31);
          int v126 = *((unsigned __int8 *)v123 + 2);
          unsigned int v127 = v125 >> v126;
          int v128 = v3 & 0x1F;
          if (v125 >> v126 > 0xF)
          {
            int v131 = *(unsigned __int8 *)(v12 + 4 * v122 + 3);
            unsigned int v129 = (v125 + (-16 << v126)) << 16;
            int v130 = v128 + v131 + 16;
          }
          else
          {
            unsigned int v129 = ((2 * (v125 & ~(-1 << v126))) | 1) << v127;
            int v130 = v128 + v126 + v127 + 1;
          }
          unint64_t v132 = ((unint64_t)v129 << v128) + (v1 >> (v3 & 0x20));
          *uint64_t v5 = v1;
          v5 += v3 >> 5;
          unsigned int v3 = v130;
          unint64_t v1 = v132;
        }
        while (!__CFADD__(v120++, 1));
        unint64_t v1 = v132;
        unsigned int v3 = v130;
        unsigned int v10 = v16;
      }
      if (v10 >= v9) {
        goto LABEL_43;
      }
    }
  }
  else
  {
    LODWORD(v14) = (v4 + 31) >> 3;
LABEL_43:
    *(void *)uint64_t v5 = v1;
    *((_DWORD *)v8 - 1) = HIDWORD(v2);
    *(_DWORD *)unsigned int v8 = v2;
    uint64_t v134 = (v3 + 7) >> 3;
    unint64_t v135 = (unint64_t)v5 + v134 - v7;
    size_t v136 = v6 - (void)v8 + (v14 & 0x1FFFFFFC) - 4;
    if (v136 >= 4 || (v135 & 3) == 0) {
      unint64_t v138 = (unint64_t)v5 + v134 - v7;
    }
    else {
      unint64_t v138 = (v135 & 0xFFFFFFFFFFFFFFFCLL) + 4;
    }
    memmove((void *)(v7 + v138), (const void *)(v6 - v136), v136);
    return v138 + v136;
  }
}

uint64_t yzip_plane_decoder(uint64_t a1)
{
  uint64_t v106 = 0;
  int v107 = 0;
  uint64_t v90 = *(void *)(a1 + 120);
  int v2 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 16);
  unsigned int v3 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 9);
  unsigned int format_convert_at_once = get_format_convert_at_once(v2);
  int format_process_at_once = get_format_process_at_once(v2);
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  unsigned int v91 = *(_DWORD *)(a1 + 20);
  unsigned int v5 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 8);
  int v6 = is_format_msb_layout(v2);
  get_conversion_set(&v106, v2, v5, v3);
  if (!v107) {
    return -1;
  }
  uint64_t v7 = *(void *)(a1 + 104);
  unint64_t v8 = *(void *)(a1 + 144);
  uint64_t v9 = v8 + v7;
  if (v8 >= 4)
  {
    unint64_t v11 = v9 - 4;
    unint64_t v10 = *(unsigned int *)(v9 - 4);
  }
  else
  {
    unint64_t v10 = 0;
    unint64_t v11 = v8 + v7;
  }
  if (v4 != (unsigned __int16)v10) {
    return -1;
  }
  unint64_t v12 = v8 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v13 = v9 - v12;
  if (v11 <= v9 - v12)
  {
    uint64_t v14 = 0;
  }
  else
  {
    unsigned int v15 = *(_DWORD *)(v11 - 4);
    v11 -= 4;
    uint64_t v14 = v15;
  }
  if (v91 != (v10 >> 16)) {
    return -1;
  }
  if (v11 <= v13)
  {
    unint64_t v17 = 0;
  }
  else
  {
    unsigned int v16 = *(_DWORD *)(v11 - 4);
    v11 -= 4;
    unint64_t v17 = (unint64_t)v16 << 32;
  }
  if ((v14 & 0xF) != v5 - 1) {
    return -1;
  }
  unsigned int v88 = v5;
  uint64_t v102 = v4 * v3 * format_process_at_once;
  int v93 = *(unsigned int **)(a1 + 104);
  unint64_t v100 = v4 * v3;
  unint64_t v101 = v7 + v12;
  unint64_t v18 = (v17 | v14) >> 4;
  int v97 = (void *)a1;
  uint64_t v19 = *(void *)(a1 + 96);
  uint64_t v20 = 0;
  unsigned int v21 = (_OWORD *)((((v19 + 15) | 0xE)
                  + (2 * v3 * (unint64_t)v4 + 32) * get_format_convert_at_once(v2)) & 0xFFFFFFFFFFFFFFF0);
  *(void *)&long long v22 = -1;
  *((void *)&v22 + 1) = -1;
  *unsigned int v21 = v22;
  v21[1] = v22;
  v21[2] = v22;
  v21[3] = v22;
  v21[4] = v22;
  v21[5] = v22;
  unint64_t v23 = (v19 + 15) & 0xFFFFFFFFFFFFFFF0;
  v21[6] = v22;
  v21[7] = v22;
  v21[8] = v22;
  v21[9] = v22;
  v21[10] = v22;
  v21[11] = v22;
  v21[12] = v22;
  v21[13] = v22;
  v21[14] = v22;
  v21[15] = v22;
  v21[16] = v22;
  v21[17] = v22;
  v21[18] = v22;
  v21[19] = v22;
  v21[20] = v22;
  v21[21] = v22;
  v21[22] = v22;
  v21[23] = v22;
  v21[24] = v22;
  v21[25] = v22;
  v21[26] = v22;
  v21[27] = v22;
  v21[28] = v22;
  v21[29] = v22;
  v21[30] = v22;
  v21[31] = v22;
  *(void *)&long long v22 = 0x101010101010101;
  *((void *)&v22 + 1) = 0x101010101010101;
  v21[62] = v22;
  v21[63] = v22;
  v21[60] = v22;
  v21[61] = v22;
  v21[58] = v22;
  v21[59] = v22;
  v21[56] = v22;
  v21[57] = v22;
  v21[54] = v22;
  v21[55] = v22;
  v21[52] = v22;
  v21[53] = v22;
  v21[50] = v22;
  v21[51] = v22;
  v21[48] = v22;
  v21[49] = v22;
  v21[46] = v22;
  v21[47] = v22;
  v21[44] = v22;
  v21[45] = v22;
  v21[42] = v22;
  v21[43] = v22;
  v21[40] = v22;
  v21[41] = v22;
  v21[38] = v22;
  v21[39] = v22;
  v21[36] = v22;
  v21[37] = v22;
  v21[34] = v22;
  v21[35] = v22;
  int v24 = (char *)v21 + 477;
  v21[32] = v22;
  v21[33] = v22;
  int v105 = v21;
  do
  {
    v24[v20] = quantize_slow((int)v20 - 35);
    ++v20;
  }
  while (v20 != 71);
  *(_DWORD *)(v23 + 10) = 0;
  *(_WORD *)(v23 + 14) = 0;
  uint64_t v25 = v90;
  unsigned int v26 = format_convert_at_once;
  int v27 = v93;
  int v28 = v100;
  if (v91)
  {
    unsigned int v29 = 0;
    int v30 = 0;
    unsigned int v31 = 0;
    unsigned int v104 = 0;
    unint64_t v32 = 0;
    uint64_t v33 = v23 + 12;
    if (v6) {
      BOOL v34 = format_convert_at_once == 0;
    }
    else {
      BOOL v34 = 1;
    }
    char v35 = v34;
    unsigned int v36 = 60;
    char v89 = v35;
    int v37 = -1;
    do
    {
      unsigned int v95 = v29;
      int v92 = v30;
      unint64_t v103 = v32;
      if (v26)
      {
        unsigned int v38 = 0;
        int v39 = *(unsigned __int16 *)(v33 - 2);
        int v40 = (unsigned __int16 *)v33;
        uint64_t v41 = v102;
        do
        {
          int v42 = *v40;
          unsigned int v43 = v42 - v39 + 512;
          if (v43 > 0x3FF) {
            int v44 = ((v42 - v39) >> 31) | 1;
          }
          else {
            int v44 = *((char *)v105 + v43);
          }
          uint64_t v33 = v23 + 16 + 2 * (((v102 + 2) + 15) & 0x1FFFFFFF0) * v38;
          if (v41)
          {
            uint64_t v45 = 0;
            int v46 = *v40;
            int v47 = v46;
            do
            {
              int v48 = v47;
              uint64_t v49 = v45 + 1;
              int v47 = v40[v45 + 1];
              unsigned int v50 = v47 - v48 + 512;
              if (v50 > 0x3FF) {
                int v51 = ((v47 - v48) >> 31) | 1;
              }
              else {
                int v51 = *((char *)v105 + v50);
              }
              int v52 = v46 - v39;
              unsigned int v53 = v46 - v39 + 512;
              if (v53 > 0x3FF) {
                int v54 = (v52 >> 31) | 1;
              }
              else {
                int v54 = *((char *)v105 + v53);
              }
              int v55 = v54 + 11 * (v51 + 11 * v44);
              int v56 = v52 + v48;
              if (v52 + v48 <= v48) {
                int v57 = v48;
              }
              else {
                int v57 = v52 + v48;
              }
              if (v56 >= v48) {
                int v56 = v48;
              }
              if (v57 < v46) {
                int v46 = v57;
              }
              if (v56 > v46) {
                int v46 = v56;
              }
              if (!v55 && v37 < 0)
              {
                int v58 = 0;
                for (unsigned int i = v31 - 1; ; ++i)
                {
                  if (v36 > 0x20)
                  {
                    unsigned int v62 = v36;
                  }
                  else
                  {
                    if (v11 <= v13)
                    {
                      uint64_t v60 = 0;
                    }
                    else
                    {
                      unsigned int v61 = *(_DWORD *)(v11 - 4);
                      v11 -= 4;
                      uint64_t v60 = v61;
                    }
                    v18 += v60 << v36;
                    unsigned int v62 = v36 + 32;
                  }
                  char v63 = v18;
                  unsigned int v36 = v62 - 1;
                  v18 >>= 1;
                  int v64 = lut_rle[v31 & 0x3F];
                  if ((v63 & 1) == 0) {
                    break;
                  }
                  LOBYTE(v31) = v31 + 1;
                  v58 += 1 << v64;
                }
                if (v36 <= 0x20)
                {
                  if (v11 <= v13)
                  {
                    uint64_t v65 = 0;
                  }
                  else
                  {
                    unsigned int v66 = *(_DWORD *)(v11 - 4);
                    v11 -= 4;
                    uint64_t v65 = v66;
                  }
                  v18 += v65 << v36;
                  unsigned int v36 = v62 + 31;
                }
                int v67 = v18 & ~(-1 << v64);
                v36 -= v64;
                v18 >>= v64;
                int v37 = v67 + v58;
                unsigned int v31 = i + (i >> 31);
              }
              if (v37 <= 0)
              {
                if (v55 >= 0) {
                  uint64_t v68 = v55;
                }
                else {
                  uint64_t v68 = -v55;
                }
                if (v104 > 0x20)
                {
                  unint64_t v71 = v103;
                }
                else
                {
                  if ((unint64_t)v27 >= v101)
                  {
                    uint64_t v69 = 0;
                  }
                  else
                  {
                    unsigned int v70 = *v27++;
                    uint64_t v69 = v70;
                  }
                  unint64_t v71 = (v69 << v104) + v103;
                  v104 += 32;
                }
                unsigned int v72 = __clz(__rbit32(v71 | 0x10000));
                if (v72 > 0xF)
                {
                  uint64_t v77 = v25 + 4 * v68;
                  int v78 = *(unsigned __int8 *)(v77 + 3);
                  unsigned int v75 = (WORD1(v71) & ~(-1 << v78)) + (16 << *(unsigned char *)(v77 + 2));
                  int v76 = v78 + 16;
                }
                else
                {
                  unsigned int v73 = v72 + 1;
                  int v74 = *(unsigned __int8 *)(v25 + 4 * v68 + 2);
                  uint64_t v41 = v102;
                  unsigned int v75 = ((v71 >> (v72 + 1)) & ~(-1 << v74)) + (v72 << v74);
                  int v76 = v73 + v74;
                }
                v104 -= v76;
                unint64_t v103 = v71 >> v76;
                int v79 = (int)(((-(v75 & 1) ^ (v75 >> 1)) + *(__int16 *)(v25 + 4 * v68)) << (32 - v88)) >> (32 - v88);
                if (v37) {
                  BOOL v80 = 0;
                }
                else {
                  BOOL v80 = v79 < 1;
                }
                int v81 = v80;
                int v82 = v79 - v81;
                if (v55 >= 0) {
                  int v83 = v82;
                }
                else {
                  int v83 = -v82;
                }
                int v46 = (v83 + v46) & ~(-1 << v88);
              }
              --v37;
              *(_WORD *)(v33 + 2 * v45++) = v46;
              int v44 = v51;
              int v39 = v48;
            }
            while (v49 != v41);
          }
          *(_WORD *)(v33 + 2 * v41) = *(_WORD *)(v33 + 2 * (v102 - 1));
          *(_WORD *)(v33 - 2) = v42;
          ++v38;
          int v39 = v42;
          int v40 = (unsigned __int16 *)v33;
        }
        while (v38 * format_process_at_once < format_convert_at_once);
      }
      uint64_t v94 = v27;
      uint64_t v96 = *v97 + v97[1] * v95;
      v107();
      int v84 = v100;
      if ((v89 & 1) == 0)
      {
        unsigned int v85 = v97;
        uint64_t v86 = 0;
        do
        {
          convert_row_to_msb((uint16x8_t *)(v96 + v85[1] * v86), v100, 16 - v88);
          unsigned int v85 = v97;
          int v84 = v100;
          ++v86;
        }
        while (format_convert_at_once != v86);
      }
      int v30 = v92 + 1;
      unsigned int v26 = format_convert_at_once;
      unsigned int v29 = (v92 + 1) * format_convert_at_once;
      uint64_t v25 = v90;
      int v27 = v94;
      int v28 = v84;
      unint64_t v32 = v103;
    }
    while (v29 < v91);
  }
  return (v28 * v91) << (v88 > 8);
}

uint64_t quantize_slow(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0) {
    return -quantize_slow(-a1);
  }
  if (a1 == 1) {
    int v1 = 5;
  }
  else {
    int v1 = 0;
  }
  if (a1 <= 1) {
    int v2 = v1;
  }
  else {
    int v2 = 4;
  }
  if (a1 <= 4) {
    int v3 = v2;
  }
  else {
    int v3 = 3;
  }
  if (a1 <= 0xB) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 2;
  }
  if (a1 <= 0x22) {
    return v4;
  }
  else {
    return 1;
  }
}

uint64_t _tr_stored_block(uint64_t a1, char *a2, int a3, int a4)
{
  int v4 = a3;
  int v7 = *(_DWORD *)(a1 + 5924);
  if (v7 < 14)
  {
    *(_WORD *)(a1 + 5920) |= (_WORD)a4 << v7;
    int v14 = v7 + 3;
  }
  else
  {
    __int16 v8 = *(_WORD *)(a1 + 5920) | (a4 << v7);
    *(_WORD *)(a1 + 5920) = v8;
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v10 + 1;
    *(unsigned char *)(v9 + v10) = v8;
    LOBYTE(v8) = *(unsigned char *)(a1 + 5921);
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v12 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v12 + 1;
    *(unsigned char *)(v11 + v12) = v8;
    int v13 = *(_DWORD *)(a1 + 5924);
    *(_WORD *)(a1 + 5920) = (unsigned __int16)a4 >> (16 - v13);
    int v14 = v13 - 13;
  }
  *(_DWORD *)(a1 + 5924) = v14;
  __int16 v15 = ~(_WORD)a3;
  uint64_t result = bi_windup(a1);
  *(_DWORD *)(a1 + 5916) = 8;
  uint64_t v17 = *(void *)(a1 + 16);
  uint64_t v18 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v18 + 1;
  *(unsigned char *)(v17 + v18) = v4;
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v20 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v20 + 1;
  *(unsigned char *)(v19 + v20) = BYTE1(v4);
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v22 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v22 + 1;
  *(unsigned char *)(v21 + v22) = v15;
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v24 = *(unsigned int *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = v24 + 1;
  for (*(unsigned char *)(v23 + v24) = HIBYTE(v15); v4; --v4)
  {
    char v25 = *a2++;
    uint64_t v26 = *(void *)(a1 + 16);
    uint64_t v27 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v27 + 1;
    *(unsigned char *)(v26 + v27) = v25;
  }
  return result;
}

uint64_t _tr_align(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 5924);
  int v3 = *(unsigned __int16 *)(a1 + 5920);
  unsigned int v4 = v3 | (2 << v2);
  *(_WORD *)(a1 + 5920) = v3 | (2 << v2);
  if (v2 < 14)
  {
    int v10 = v2 + 3;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v6 + 1;
    *(unsigned char *)(v5 + v6) = v4;
    char v7 = *(unsigned char *)(a1 + 5921);
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v9 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v9 + 1;
    *(unsigned char *)(v8 + v9) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 5924);
    unsigned int v4 = 2u >> (16 - v8);
    *(_WORD *)(a1 + 5920) = v4;
    int v10 = v8 - 13;
  }
  *(_DWORD *)(a1 + 5924) = v10;
  if (v10 < 10)
  {
    int v16 = v10 + 7;
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v12 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v12 + 1;
    *(unsigned char *)(v11 + v12) = v4;
    char v13 = *(unsigned char *)(a1 + 5921);
    uint64_t v14 = *(void *)(a1 + 16);
    uint64_t v15 = *(unsigned int *)(a1 + 40);
    *(_DWORD *)(a1 + 40) = v15 + 1;
    *(unsigned char *)(v14 + v15) = v13;
    *(_WORD *)(a1 + 5920) = 0;
    int v16 = *(_DWORD *)(a1 + 5924) - 9;
  }
  *(_DWORD *)(a1 + 5924) = v16;
  uint64_t result = bi_flush(a1);
  int v18 = *(_DWORD *)(a1 + 5924);
  if (*(_DWORD *)(a1 + 5916) - v18 + 11 <= 8)
  {
    int v19 = *(unsigned __int16 *)(a1 + 5920);
    unsigned int v20 = v19 | (2 << v18);
    *(_WORD *)(a1 + 5920) = v19 | (2 << v18);
    if (v18 < 14)
    {
      int v26 = v18 + 3;
    }
    else
    {
      uint64_t v21 = *(void *)(a1 + 16);
      uint64_t v22 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v22 + 1;
      *(unsigned char *)(v21 + v22) = v20;
      char v23 = *(unsigned char *)(a1 + 5921);
      uint64_t v24 = *(void *)(a1 + 16);
      uint64_t v25 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v25 + 1;
      *(unsigned char *)(v24 + v25) = v23;
      LODWORD(v24) = *(_DWORD *)(a1 + 5924);
      unsigned int v20 = 2u >> (16 - v24);
      *(_WORD *)(a1 + 5920) = v20;
      int v26 = v24 - 13;
    }
    *(_DWORD *)(a1 + 5924) = v26;
    if (v26 < 10)
    {
      int v32 = v26 + 7;
    }
    else
    {
      uint64_t v27 = *(void *)(a1 + 16);
      uint64_t v28 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v28 + 1;
      *(unsigned char *)(v27 + v28) = v20;
      char v29 = *(unsigned char *)(a1 + 5921);
      uint64_t v30 = *(void *)(a1 + 16);
      uint64_t v31 = *(unsigned int *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v31 + 1;
      *(unsigned char *)(v30 + v31) = v29;
      *(_WORD *)(a1 + 5920) = 0;
      int v32 = *(_DWORD *)(a1 + 5924) - 9;
    }
    *(_DWORD *)(a1 + 5924) = v32;
    uint64_t result = bi_flush(a1);
  }
  *(_DWORD *)(a1 + 5916) = 7;
  return result;
}

uint64_t bi_flush(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 5924);
  if (v1 == 16)
  {
    int v2 = 0;
    char v3 = *(unsigned char *)(result + 5920);
    uint64_t v4 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v4 + 1;
    *(unsigned char *)(*(void *)(result + 16) + v4) = v3;
    char v5 = *(unsigned char *)(result + 5921);
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v7 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v7 + 1;
    *(unsigned char *)(v6 + v7) = v5;
    *(_WORD *)(result + 5920) = 0;
  }
  else
  {
    if (v1 < 8) {
      return result;
    }
    char v8 = *(unsigned char *)(result + 5920);
    uint64_t v9 = *(void *)(result + 16);
    uint64_t v10 = *(unsigned int *)(result + 40);
    *(_DWORD *)(result + 40) = v10 + 1;
    *(unsigned char *)(v9 + v10) = v8;
    *(_WORD *)(result + 5920) = *(unsigned __int8 *)(result + 5921);
    int v2 = *(_DWORD *)(result + 5924) - 8;
  }
  *(_DWORD *)(result + 5924) = v2;
  return result;
}

BOOL _tr_tally(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 5884);
  *(_WORD *)(*(void *)(a1 + 5888) + 2 * v3) = a2;
  uint64_t v4 = *(void *)(a1 + 5872);
  *(_DWORD *)(a1 + 5884) = v3 + 1;
  *(unsigned char *)(v4 + v3) = a3;
  if (a2)
  {
    ++*(_DWORD *)(a1 + 5912);
    unsigned int v5 = a2 - 1;
    uint64_t v6 = a1 + 4 * _length_code[a3];
    ++*(_WORD *)(v6 + 1224);
    if (a2 >= 0x101) {
      unsigned int v5 = ((a2 - 1) >> 7) + 256;
    }
    uint64_t v7 = (_WORD *)(a1 + 4 * _dist_code[v5] + 2488);
  }
  else
  {
    uint64_t v7 = (_WORD *)(a1 + 4 * a3 + 196);
  }
  ++*v7;
  return *(_DWORD *)(a1 + 5884) == *(_DWORD *)(a1 + 5880) - 1;
}

uint64_t BrotliInitDistanceParams(uint64_t result, int a2, unsigned int a3)
{
  *(_DWORD *)(result + 64) = a2;
  *(_DWORD *)(result + 68) = a3;
  unsigned int v3 = a3 + 16;
  char v4 = a2 + 1;
  if (*(_DWORD *)(result + 36))
  {
    if (a3 > 0x7FFFFFFB)
    {
      int v13 = -2147483636;
      a3 = 2147483644;
    }
    else
    {
      char v5 = -1;
      int v6 = -1 << a2;
      int v7 = -5;
      unsigned int v8 = ((2147483644 - a3) >> a2) + 4;
      do
      {
        ++v5;
        v7 += 2;
        BOOL v9 = v8 > 3;
        v8 >>= 1;
      }
      while (v9);
      unsigned int v10 = (((((2147483644 - a3) >> a2) + 4) >> v5) & 1) + v7;
      if (v10 == -1)
      {
        int v13 = a3 + 16;
      }
      else
      {
        unsigned int v11 = v10 >> 1;
        int v12 = (v10 & 1) << ((v10 >> 1) + 1);
        int v13 = a3 + ((v10 << a2) | ~v6) + 17;
        a3 = a3 - v6 + (((6 << v11) + v12 - 5) << a2);
      }
    }
    int v14 = v3 + (62 << v4);
  }
  else
  {
    int v14 = v3 + (24 << v4);
    a3 += (1 << (a2 + 26)) + (-1 << (a2 + 2));
    int v13 = v14;
  }
  *(_DWORD *)(result + 72) = v14;
  *(_DWORD *)(result + 76) = v13;
  *(void *)(result + 80) = a3;
  return result;
}

void BrotliBuildMetaBlock(_DWORD *a1, uint64_t a2, size_t a3, size_t a4, uint64_t a5, unsigned __int8 a6, unsigned __int8 a7, uint64_t a8, size_t a9, int a10, uint64_t *a11)
{
  unsigned int v11 = 0;
  int v12 = 0;
  long long v13 = *(_OWORD *)(a5 + 96);
  long long v14 = *(_OWORD *)(a5 + 64);
  long long v96 = *(_OWORD *)(a5 + 80);
  long long v97 = v13;
  long long v15 = *(_OWORD *)(a5 + 96);
  long long v16 = *(_OWORD *)(a5 + 128);
  long long v98 = *(_OWORD *)(a5 + 112);
  long long v99 = v16;
  long long v17 = *(_OWORD *)(a5 + 32);
  long long v18 = *(_OWORD *)a5;
  long long v92 = *(_OWORD *)(a5 + 16);
  long long v93 = v17;
  long long v19 = *(_OWORD *)(a5 + 32);
  long long v20 = *(_OWORD *)(a5 + 64);
  long long v94 = *(_OWORD *)(a5 + 48);
  long long v95 = v20;
  long long v21 = *(_OWORD *)a5;
  long long v88 = v15;
  long long v89 = v98;
  long long v90 = *(_OWORD *)(a5 + 128);
  long long v91 = v21;
  v85[2] = v19;
  v85[3] = v94;
  long long v86 = v14;
  long long v87 = v96;
  uint64_t v22 = a5 + 64;
  v85[0] = v18;
  v85[1] = v92;
  int v23 = 1;
  double v24 = 1.0e99;
  int v25 = v20;
  int v26 = DWORD1(v20);
  do
  {
    if (v11 <= 0xF)
    {
      while (1)
      {
        double v84 = 0.0;
        BrotliInitDistanceParams((uint64_t)v85, v12, v11 << v12);
        if (v11 << v12 == v26 && v12 == v25) {
          int v23 = 0;
        }
        if (!ComputeDistanceCost(a8, a9, (int *)&v95, (int *)&v86, &v84)) {
          break;
        }
        double v28 = v84;
        if (v84 > v24) {
          break;
        }
        *(_OWORD *)uint64_t v22 = v86;
        *(void *)(v22 + 16) = v87;
        ++v11;
        double v24 = v28;
        if (v11 == 16)
        {
          double v24 = v28;
          break;
        }
      }
    }
    unsigned int v29 = v11 - 1;
    if (!v11) {
      unsigned int v29 = 0;
    }
    unsigned int v11 = v29 >> 1;
    ++v12;
  }
  while (v12 != 4);
  if (v23)
  {
    double v84 = 0.0;
    ComputeDistanceCost(a8, a9, (int *)&v95, (int *)&v95, &v84);
    if (v84 < v24)
    {
      *(_OWORD *)uint64_t v22 = v95;
      *(void *)(v22 + 16) = v96;
    }
  }
  if (v25 == *(_DWORD *)v22)
  {
    uint64_t v30 = a1;
    if (!a9 || v26 == *(_DWORD *)(a5 + 68)) {
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v30 = a1;
    if (!a9) {
      goto LABEL_33;
    }
  }
  unsigned int v31 = v26 + 16;
  uint64_t v32 = a8 + 8;
  size_t v33 = a9;
  do
  {
    if ((*(_DWORD *)(v32 - 4) & 0x1FFFFFF) != 0 && *(unsigned __int16 *)(v32 + 4) >= 0x80u)
    {
      unsigned int v34 = *(unsigned __int16 *)(v32 + 6);
      unsigned int v35 = v34 & 0x3FF;
      if (v35 >= v31) {
        unsigned int v35 = ((v35 - v26 - 16) & ~(-1 << v25))
      }
            + v31
            + ((((((v35 - v26 - 16) >> v25) & 1 | 2) << (v34 >> 10)) + *(_DWORD *)v32 - 4) << v25);
      LOWORD(v36) = v35;
      uint64_t v37 = *(unsigned int *)(a5 + 68);
      int v38 = v37 + 16;
      if (v37 + 16 <= (unint64_t)v35)
      {
        unint64_t v40 = v35 - v37 + (4 << *(_DWORD *)v22) - 16;
        unsigned int v41 = (__clz(v40) ^ 0x1F) - 1;
        uint64_t v42 = ((v40 >> v41) & 1 | 2) << v41;
        int v36 = ((v40 & ~(-1 << *(_DWORD *)v22))
             + v38
             + ((((v40 >> v41) & 1 | (2 * (v41 - *(_DWORD *)v22))) + 65534) << *(_DWORD *)v22)) | ((v41 - *(_DWORD *)v22) << 10);
        unint64_t v39 = (v40 - v42) >> *(_DWORD *)v22;
      }
      else
      {
        LODWORD(v39) = 0;
      }
      *(_WORD *)(v32 + 6) = v36;
      *(_DWORD *)uint64_t v32 = v39;
    }
    v32 += 16;
    --v33;
  }
  while (v33);
LABEL_33:
  uint64_t v43 = (uint64_t)a11;
  int v44 = a11 + 12;
  BrotliSplitBlock(v30, a8, a9, a2, a3, a4, a5, (uint64_t)a11, (uint64_t)(a11 + 6), (uint64_t)(a11 + 12));
  if (v30[6]) {
    return;
  }
  uint64_t v45 = *a11;
  if (*(_DWORD *)(a5 + 32))
  {
    unint64_t v46 = 0;
    uint64_t v47 = 1;
  }
  else
  {
    if (v45)
    {
      uint64_t v48 = BrotliAllocate((uint64_t)v30);
      if (v30[6]) {
        return;
      }
      unint64_t v46 = v48;
      uint64_t v45 = *a11;
      if (*a11)
      {
        unint64_t v49 = 0;
        uint64_t v47 = 64;
        do
        {
          *(_DWORD *)(v48 + 4 * v49++) = a10;
          uint64_t v45 = *a11;
        }
        while (v49 < *a11);
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v46 = 0;
    }
    uint64_t v47 = 64;
  }
LABEL_45:
  unint64_t v50 = v45 * v47;
  if (v45 * v47)
  {
    int v79 = (void *)BrotliAllocate((uint64_t)v30);
    if (v30[6]) {
      return;
    }
    unint64_t v51 = v50;
    int v52 = v79;
    do
    {
      bzero(v52, 0x408uLL);
      v52[129] = 0x7FF0000000000000;
      v52 += 130;
      --v51;
    }
    while (v51);
    uint64_t v43 = (uint64_t)a11;
  }
  else
  {
    if (v30[6]) {
      return;
    }
    int v79 = 0;
  }
  uint64_t v53 = 4 * *v44;
  if (v53)
  {
    int v76 = (void *)BrotliAllocate((uint64_t)v30);
    if (v30[6]) {
      return;
    }
    int v54 = v76;
    do
    {
      bzero(v54, 0x888uLL);
      v54[273] = 0x7FF0000000000000;
      v54 += 274;
      --v53;
    }
    while (v53);
    uint64_t v43 = (uint64_t)a11;
  }
  else
  {
    if (v30[6]) {
      return;
    }
    int v76 = 0;
  }
  uint64_t v55 = *(void *)(v43 + 48);
  *(void *)(v43 + 200) = v55;
  if (v55) {
    int v56 = (void *)BrotliAllocate((uint64_t)v30);
  }
  else {
    int v56 = 0;
  }
  *(void *)(v43 + 192) = v56;
  if (!v30[6])
  {
    uint64_t v57 = *(void *)(v43 + 200);
    if (v57)
    {
      do
      {
        bzero(v56, 0xB08uLL);
        v56[353] = 0x7FF0000000000000;
        v56 += 354;
        --v57;
      }
      while (v57);
      uint64_t v43 = (uint64_t)a11;
      int v56 = (void *)a11[24];
    }
    BrotliBuildHistogramsWithContext(a8, a9, v43, (uint64_t)(a11 + 6), (uint64_t)v44, a2, a3, a4, a6, a7, v46, (uint64_t)v79, (uint64_t)v56, (uint64_t)v76);
    BrotliFree((uint64_t)v30, v46);
    uint64_t v58 = *(void *)v43 << 6;
    *(void *)(v43 + 152) = v58;
    uint64_t v59 = v58 ? BrotliAllocate((uint64_t)v30) : 0;
    *(void *)(v43 + 144) = v59;
    if (!v30[6])
    {
      uint64_t v60 = *(void *)(v43 + 152);
      *(void *)(v43 + 184) = v60;
      if (v60)
      {
        uint64_t v61 = BrotliAllocate((uint64_t)v30);
        int v62 = v30[6];
        *(void *)(v43 + 176) = v61;
        if (v62) {
          return;
        }
        char v63 = (char *)v61;
      }
      else
      {
        char v63 = 0;
        *(void *)(v43 + 176) = 0;
      }
      BrotliClusterHistogramsLiteral((uint64_t)v30, (uint64_t)v79, v50, 0x100uLL, v63, (uint64_t *)(v43 + 184), *(unsigned int **)(v43 + 144));
      if (!v30[6])
      {
        BrotliFree((uint64_t)v30, (unint64_t)v79);
        if (*(_DWORD *)(a5 + 32))
        {
          uint64_t v64 = *(void *)v43;
          if (*(void *)v43)
          {
            uint64_t v65 = *(void *)(v43 + 144);
            uint64_t v66 = v65 + (v64 << 8);
            do
            {
              --v64;
              uint64_t v67 = -256;
              do
              {
                *(_DWORD *)(v66 + v67) = *(_DWORD *)(v65 + 4 * v64);
                v67 += 4;
              }
              while (v67);
              v66 -= 256;
            }
            while (v64);
          }
        }
        uint64_t v68 = *(void *)(v43 + 96);
        *(void *)(v43 + 168) = 4 * v68;
        uint64_t v69 = 4 * v68 ? BrotliAllocate((uint64_t)v30) : 0;
        *(void *)(v43 + 160) = v69;
        if (!v30[6])
        {
          uint64_t v70 = *(void *)(v43 + 168);
          *(void *)(v43 + 216) = v70;
          if (v70)
          {
            uint64_t v71 = BrotliAllocate((uint64_t)v30);
            int v72 = v30[6];
            *(void *)(v43 + 208) = v71;
            if (v72) {
              return;
            }
            unsigned int v73 = (char *)v71;
          }
          else
          {
            unsigned int v73 = 0;
            *(void *)(v43 + 208) = 0;
          }
          BrotliClusterHistogramsDistance((uint64_t)v30, (uint64_t)v76, *(void *)(v43 + 168), 0x100uLL, v73, (uint64_t *)(v43 + 216), *(unsigned int **)(v43 + 160));
          if (!v30[6])
          {
            BrotliFree((uint64_t)v30, (unint64_t)v76);
          }
        }
      }
    }
  }
}

uint64_t ComputeDistanceCost(uint64_t a1, uint64_t a2, int *a3, int *a4, double *a5)
{
  bzero(v25, 0x888uLL);
  uint64_t v27 = 0x7FF0000000000000;
  int v10 = *a3;
  int v11 = *a4;
  BOOL v12 = *a3 != *a4 || a3[1] != a4[1];
  uint64_t v13 = 0;
  if (a2)
  {
    long long v14 = (unsigned __int16 *)(a1 + 14);
    double v15 = 0.0;
    while (1)
    {
      if ((*(_DWORD *)(v14 - 5) & 0x1FFFFFF) != 0 && *(v14 - 1) >= 0x80u)
      {
        unsigned int v16 = *v14;
        if (v12)
        {
          unsigned int v17 = v16 & 0x3FF;
          int v18 = a3[1];
          if (v17 >= v18 + 16) {
            unsigned int v17 = v18
          }
                + 16
                + ((v17 - v18 - 16) & ~(-1 << v10))
                + ((((((v17 - v18 - 16) >> v10) & 1 | 2) << (v16 >> 10)) + *(_DWORD *)(v14 - 3) - 4) << v10);
          if (*((void *)a4 + 2) < (unint64_t)v17) {
            return 0;
          }
          uint64_t v19 = a4[1];
          int v20 = v19 + 16;
          if (v19 + 16 <= (unint64_t)v17)
          {
            unint64_t v21 = (4 << v11) - 16 + v17 - v19;
            unsigned int v22 = __clz(v21);
            unsigned int v16 = ((v21 & ~(-1 << v11))
                 + v20
                 + ((((v21 >> ((v22 ^ 0x1F) - 1)) & 1 | (2 * ((v22 ^ 0x1F) - 1 - v11))) + 65534) << v11)) | (((v22 ^ 0x1F) - 1 - v11) << 10);
          }
          else
          {
            LOWORD(v16) = v17;
          }
        }
        ++v25[v16 & 0x3FF];
        ++v13;
        double v15 = v15 + (double)((unsigned __int16)v16 >> 10);
      }
      v14 += 8;
      if (!--a2) {
        goto LABEL_19;
      }
    }
  }
  double v15 = 0.0;
LABEL_19:
  uint64_t v26 = v13;
  BrotliPopulationCostDistance((uint64_t)v25);
  *a5 = v15 + v23;
  return 1;
}

void BrotliBuildMetaBlockGreedy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unint64_t a8, uint64_t a9, unsigned int *a10, unint64_t a11, uint64_t a12)
{
  unint64_t v16 = a11;
  if (a8 == 1)
  {
    uint64_t v88 = 0;
    long long v86 = 0u;
    memset(v87, 0, sizeof(v87));
    long long v84 = 0u;
    long long v85 = 0u;
    uint64_t v83 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v76 = 0u;
    uint64_t v75 = 0;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v68 = 0u;
    unint64_t v17 = 0;
    if (a11)
    {
      unint64_t v18 = a11;
      uint64_t v19 = a10;
      do
      {
        unsigned int v20 = *v19;
        v19 += 4;
        v17 += v20;
        --v18;
      }
      while (v18);
    }
    InitBlockSplitterLiteral(a1, (uint64_t)&v84, v17, a12, (void *)(a12 + 176), (uint64_t *)(a12 + 184));
    if (!*(_DWORD *)(a1 + 24))
    {
      InitBlockSplitterCommand(a1, (uint64_t)&v76, a11, a12 + 48, (void *)(a12 + 192), (uint64_t *)(a12 + 200));
      if (!*(_DWORD *)(a1 + 24))
      {
        InitBlockSplitterDistance(a1, (uint64_t)&v68, a11, a12 + 96, (void *)(a12 + 208), (uint64_t *)(a12 + 216));
        if (!*(_DWORD *)(a1 + 24))
        {
          if (a11)
          {
            for (uint64_t i = 0; i != a11; ++i)
            {
              unsigned int v22 = &a10[4 * i];
              uint64_t v24 = *v22;
              unsigned int v23 = v22[1];
              unsigned int v25 = *((unsigned __int16 *)v22 + 6);
              __int16 v26 = *((_WORD *)v22 + 7);
              BlockSplitterAddSymbolCommand(&v76, *((unsigned __int16 *)v22 + 6));
              if (v24)
              {
                do
                {
                  BlockSplitterAddSymbolLiteral(&v84, *(unsigned __int8 *)(a2 + (a3++ & a4)));
                  --v24;
                }
                while (v24);
              }
              uint64_t v27 = v23 & 0x1FFFFFF;
              if (v27)
              {
                if (v25 >= 0x80) {
                  BlockSplitterAddSymbolDistance(&v68, v26 & 0x3FF);
                }
              }
              a3 += v27;
            }
          }
          BlockSplitterFinishBlockLiteral(&v84, 1);
          BlockSplitterFinishBlockCommand();
          BlockSplitterFinishBlockDistance();
        }
      }
    }
    return;
  }
  memset((char *)v87 + 8, 0, 264);
  uint64_t v83 = 0;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v76 = 0u;
  uint64_t v75 = 0;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v68 = 0u;
  unint64_t v29 = 0;
  if (a11)
  {
    uint64_t v30 = a10;
    do
    {
      unsigned int v31 = *v30;
      v30 += 4;
      v29 += v31;
      --v16;
    }
    while (v16);
  }
  unint64_t v32 = v29 >> 9;
  unint64_t v33 = (v29 >> 9) + 1;
  *(void *)&long long v84 = 256;
  *((void *)&v84 + 1) = a8;
  *(void *)&long long v85 = 0x100 / a8;
  *((void *)&v85 + 1) = 512;
  long long v86 = 0x4079000000000000uLL;
  *(void *)&v87[0] = a12;
  *(void *)&v87[1] = a12 + 184;
  *((void *)&v87[1] + 1) = 512;
  if (v33 >= 0x100 / a8 + 1) {
    uint64_t v34 = 0x100 / a8 + 1;
  }
  else {
    uint64_t v34 = (v29 >> 9) + 1;
  }
  uint64_t v66 = v34;
  uint64_t v88 = 0;
  v87[2] = 0uLL;
  unint64_t v35 = *(void *)(a12 + 32);
  if (v35 <= v29 >> 9)
  {
    if (v35) {
      uint64_t v36 = *(void *)(a12 + 32);
    }
    else {
      uint64_t v36 = (v29 >> 9) + 1;
    }
    do
    {
      unint64_t v37 = v36;
      v36 *= 2;
    }
    while (v37 <= v32);
    int v38 = (void *)BrotliAllocate(a1);
    unint64_t v39 = v38;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v40 = *(void *)(a12 + 32);
      if (v40) {
        memcpy(v38, *(const void **)(a12 + 16), v40);
      }
    }
    BrotliFree(a1, *(void *)(a12 + 16));
    *(void *)(a12 + 16) = v39;
    *(void *)(a12 + 32) = v37;
  }
  unint64_t v41 = *(void *)(a12 + 40);
  if (v41 <= v32)
  {
    if (!v41) {
      unint64_t v41 = v33;
    }
    do
    {
      unint64_t v42 = v41;
      v41 *= 2;
    }
    while (v42 <= v32);
    uint64_t v43 = (void *)BrotliAllocate(a1);
    int v44 = v43;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v45 = *(void *)(a12 + 40);
      if (v45) {
        memcpy(v43, *(const void **)(a12 + 24), 4 * v45);
      }
    }
    BrotliFree(a1, *(void *)(a12 + 24));
    *(void *)(a12 + 24) = v44;
    *(void *)(a12 + 40) = v42;
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(a12 + 8) = v33;
    *(void *)(a12 + 184) = v66 * a8;
    if (v66 * a8)
    {
      uint64_t v46 = BrotliAllocate(a1);
      int v47 = *(_DWORD *)(a1 + 24);
      *(void *)(a12 + 176) = v46;
      *((void *)&v87[0] + 1) = v46;
      if (v47) {
        return;
      }
      uint64_t v48 = (void *)v46;
      if (!a8) {
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t v48 = 0;
      *(void *)(a12 + 176) = 0;
      *((void *)&v87[0] + 1) = 0;
      if (!a8)
      {
LABEL_45:
        v87[3] = 0uLL;
LABEL_50:
        InitBlockSplitterCommand(a1, (uint64_t)&v76, a11, a12 + 48, (void *)(a12 + 192), (uint64_t *)(a12 + 200));
        if (!*(_DWORD *)(a1 + 24))
        {
          InitBlockSplitterDistance(a1, (uint64_t)&v68, a11, a12 + 96, (void *)(a12 + 208), (uint64_t *)(a12 + 216));
          if (!*(_DWORD *)(a1 + 24))
          {
            unint64_t v51 = a10;
            if (a11)
            {
              uint64_t v52 = 0;
              uint64_t v53 = a5;
              uint64_t v54 = a6;
              while (1)
              {
                uint64_t v55 = &v51[4 * v52];
                uint64_t v57 = *v55;
                unsigned int v56 = v55[1];
                __int16 v61 = *((_WORD *)v55 + 7);
                uint64_t v63 = *((unsigned __int16 *)v55 + 6);
                uint64_t v65 = v52;
                BlockSplitterAddSymbolCommand(&v76, v63);
                if (v57) {
                  break;
                }
LABEL_59:
                a3 += v56 & 0x1FFFFFF;
                unint64_t v51 = a10;
                uint64_t v60 = v65;
                if ((v56 & 0x1FFFFFF) != 0)
                {
                  uint64_t v54 = *(unsigned __int8 *)(a2 + ((a3 - 2) & a4));
                  uint64_t v53 = *(unsigned __int8 *)(a2 + ((a3 - 1) & a4));
                  if (v63 >= 0x80)
                  {
                    BlockSplitterAddSymbolDistance(&v68, v61 & 0x3FF);
                    uint64_t v60 = v65;
                  }
                }
                uint64_t v52 = v60 + 1;
                if (v52 == a11) {
                  goto LABEL_63;
                }
              }
              while (1)
              {
                char v58 = *(unsigned char *)(a7 + 256 + v54);
                uint64_t v54 = v53;
                uint64_t v53 = *(unsigned __int8 *)(a2 + (a3 & a4));
                uint64_t v59 = *((void *)&v87[0] + 1)
                    + 1040
                    * (*((void *)&v87[2] + 1)
                     + *(unsigned int *)(a9 + 4 * (v58 | *(unsigned char *)(a7 + v54))));
                ++*(_DWORD *)(v59 + 4 * v53);
                ++*(void *)(v59 + 1024);
                if (++*(void *)&v87[2] == *((void *)&v87[1] + 1)) {
                  ContextBlockSplitterFinishBlock(&v84, a1, 0);
                }
                if (*(_DWORD *)(a1 + 24)) {
                  break;
                }
                ++a3;
                if (!--v57) {
                  goto LABEL_59;
                }
              }
            }
            else
            {
LABEL_63:
              ContextBlockSplitterFinishBlock(&v84, a1, 1);
              if (!*(_DWORD *)(a1 + 24))
              {
                BlockSplitterFinishBlockCommand();
                BlockSplitterFinishBlockDistance();
                if (a8 >= 2) {
                  MapStaticContexts(a1, a8, a9, (uint64_t *)a12);
                }
              }
            }
          }
        }
        return;
      }
    }
    unint64_t v49 = a8;
    do
    {
      bzero(v48, 0x408uLL);
      v48[129] = 0x7FF0000000000000;
      v48 += 130;
      --v49;
    }
    while (v49);
    int v50 = *(_DWORD *)(a1 + 24);
    v87[3] = 0uLL;
    if (v50) {
      return;
    }
    goto LABEL_50;
  }
}

void BrotliOptimizeHistograms(unsigned int a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a2[23])
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(256, (int *)(a2[22] + v4), v10);
      ++v5;
      v4 += 1040;
    }
    while (v5 < a2[23]);
  }
  if (a2[25])
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(704, (int *)(a2[24] + v6), v10);
      ++v7;
      v6 += 2832;
    }
    while (v7 < a2[25]);
  }
  if (a2[27])
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      BrotliOptimizeHuffmanCountsForRle(a1, (int *)(a2[26] + v8), v10);
      ++v9;
      v8 += 2192;
    }
    while (v9 < a2[27]);
  }
}

void InitBlockSplitterLiteral(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  unint64_t v11 = a3 >> 9;
  unint64_t v12 = (a3 >> 9) + 1;
  if (v12 < 0x101) {
    uint64_t v13 = v11 + 1;
  }
  else {
    uint64_t v13 = 257;
  }
  *(_OWORD *)a2 = xmmword_20DB12AF0;
  *(void *)(a2 + 16) = 0x4079000000000000;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = a4;
  *(void *)(a2 + 48) = a6;
  *(void *)(a2 + 56) = 512;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  unint64_t v14 = *(void *)(a4 + 32);
  if (v14 <= a3 >> 9)
  {
    if (!v14) {
      unint64_t v14 = (a3 >> 9) + 1;
    }
    do
    {
      unint64_t v15 = v14;
      v14 *= 2;
    }
    while (v15 <= v11);
    unint64_t v16 = (void *)BrotliAllocate(a1);
    unint64_t v17 = v16;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v18 = *(void *)(a4 + 32);
      if (v18) {
        memcpy(v16, *(const void **)(a4 + 16), v18);
      }
    }
    BrotliFree(a1, *(void *)(a4 + 16));
    *(void *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = v15;
  }
  unint64_t v19 = *(void *)(a4 + 40);
  if (v19 <= v11)
  {
    if (!v19) {
      unint64_t v19 = v12;
    }
    do
    {
      unint64_t v20 = v19;
      v19 *= 2;
    }
    while (v20 <= v11);
    unint64_t v21 = (void *)BrotliAllocate(a1);
    unsigned int v22 = v21;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v23 = *(void *)(a4 + 40);
      if (v23) {
        memcpy(v21, *(const void **)(a4 + 24), 4 * v23);
      }
    }
    BrotliFree(a1, *(void *)(a4 + 24));
    *(void *)(a4 + 24) = v22;
    *(void *)(a4 + 40) = v20;
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(*(void *)(a2 + 32) + 8) = v12;
    *a6 = v13;
    uint64_t v24 = (void *)BrotliAllocate(a1);
    *a5 = v24;
    *(void *)(a2 + 40) = v24;
    if (!*(_DWORD *)(a1 + 24))
    {
      unsigned int v25 = v24;
      bzero(v24, 0x408uLL);
      v25[129] = 0x7FF0000000000000;
      *(void *)(a2 + 80) = 0;
      *(void *)(a2 + 88) = 0;
    }
  }
}

void InitBlockSplitterCommand(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  unint64_t v11 = a3 >> 10;
  unint64_t v12 = (a3 >> 10) + 1;
  if (v12 < 0x101) {
    uint64_t v13 = v11 + 1;
  }
  else {
    uint64_t v13 = 257;
  }
  *(_OWORD *)a2 = xmmword_20DB12B00;
  *(void *)(a2 + 16) = 0x407F400000000000;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = a4;
  *(void *)(a2 + 48) = a6;
  *(void *)(a2 + 56) = 1024;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  unint64_t v14 = *(void *)(a4 + 32);
  if (v14 <= a3 >> 10)
  {
    if (!v14) {
      unint64_t v14 = (a3 >> 10) + 1;
    }
    do
    {
      unint64_t v15 = v14;
      v14 *= 2;
    }
    while (v15 <= v11);
    unint64_t v16 = (void *)BrotliAllocate(a1);
    unint64_t v17 = v16;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v18 = *(void *)(a4 + 32);
      if (v18) {
        memcpy(v16, *(const void **)(a4 + 16), v18);
      }
    }
    BrotliFree(a1, *(void *)(a4 + 16));
    *(void *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = v15;
  }
  unint64_t v19 = *(void *)(a4 + 40);
  if (v19 <= v11)
  {
    if (!v19) {
      unint64_t v19 = v12;
    }
    do
    {
      unint64_t v20 = v19;
      v19 *= 2;
    }
    while (v20 <= v11);
    unint64_t v21 = (void *)BrotliAllocate(a1);
    unsigned int v22 = v21;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v23 = *(void *)(a4 + 40);
      if (v23) {
        memcpy(v21, *(const void **)(a4 + 24), 4 * v23);
      }
    }
    BrotliFree(a1, *(void *)(a4 + 24));
    *(void *)(a4 + 24) = v22;
    *(void *)(a4 + 40) = v20;
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(*(void *)(a2 + 32) + 8) = v12;
    *a6 = v13;
    uint64_t v24 = (void *)BrotliAllocate(a1);
    *a5 = v24;
    *(void *)(a2 + 40) = v24;
    if (!*(_DWORD *)(a1 + 24))
    {
      unsigned int v25 = v24;
      bzero(v24, 0xB08uLL);
      v25[353] = 0x7FF0000000000000;
      *(void *)(a2 + 80) = 0;
      *(void *)(a2 + 88) = 0;
    }
  }
}

void InitBlockSplitterDistance(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  unint64_t v11 = a3 >> 9;
  unint64_t v12 = (a3 >> 9) + 1;
  if (v12 < 0x101) {
    uint64_t v13 = v11 + 1;
  }
  else {
    uint64_t v13 = 257;
  }
  *(_OWORD *)a2 = xmmword_20DB12B10;
  *(void *)(a2 + 16) = 0x4059000000000000;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = a4;
  *(void *)(a2 + 48) = a6;
  *(void *)(a2 + 56) = 512;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  unint64_t v14 = *(void *)(a4 + 32);
  if (v14 <= a3 >> 9)
  {
    if (!v14) {
      unint64_t v14 = (a3 >> 9) + 1;
    }
    do
    {
      unint64_t v15 = v14;
      v14 *= 2;
    }
    while (v15 <= v11);
    unint64_t v16 = (void *)BrotliAllocate(a1);
    unint64_t v17 = v16;
    if (!*(_DWORD *)(a1 + 24))
    {
      size_t v18 = *(void *)(a4 + 32);
      if (v18) {
        memcpy(v16, *(const void **)(a4 + 16), v18);
      }
    }
    BrotliFree(a1, *(void *)(a4 + 16));
    *(void *)(a4 + 16) = v17;
    *(void *)(a4 + 32) = v15;
  }
  unint64_t v19 = *(void *)(a4 + 40);
  if (v19 <= v11)
  {
    if (!v19) {
      unint64_t v19 = v12;
    }
    do
    {
      unint64_t v20 = v19;
      v19 *= 2;
    }
    while (v20 <= v11);
    unint64_t v21 = (void *)BrotliAllocate(a1);
    unsigned int v22 = v21;
    if (!*(_DWORD *)(a1 + 24))
    {
      uint64_t v23 = *(void *)(a4 + 40);
      if (v23) {
        memcpy(v21, *(const void **)(a4 + 24), 4 * v23);
      }
    }
    BrotliFree(a1, *(void *)(a4 + 24));
    *(void *)(a4 + 24) = v22;
    *(void *)(a4 + 40) = v20;
  }
  if (!*(_DWORD *)(a1 + 24))
  {
    *(void *)(*(void *)(a2 + 32) + 8) = v12;
    *a6 = v13;
    uint64_t v24 = (void *)BrotliAllocate(a1);
    *a5 = v24;
    *(void *)(a2 + 40) = v24;
    if (!*(_DWORD *)(a1 + 24))
    {
      unsigned int v25 = v24;
      bzero(v24, 0x888uLL);
      v25[273] = 0x7FF0000000000000;
      *(void *)(a2 + 80) = 0;
      *(void *)(a2 + 88) = 0;
    }
  }
}

void BlockSplitterAddSymbolCommand(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[5] + 2832 * a1[9];
  ++*(_DWORD *)(v2 + 4 * a2);
  ++*(void *)(v2 + 2816);
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[8] + 1;
  a1[8] = v4;
  if (v4 == v3) {
    BlockSplitterFinishBlockCommand();
  }
}

void BlockSplitterAddSymbolLiteral(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[5] + 1040 * a1[9];
  ++*(_DWORD *)(v2 + 4 * a2);
  ++*(void *)(v2 + 1024);
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[8] + 1;
  a1[8] = v4;
  if (v4 == v3) {
    BlockSplitterFinishBlockLiteral(a1, 0);
  }
}

void BlockSplitterAddSymbolDistance(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[5] + 2192 * a1[9];
  ++*(_DWORD *)(v2 + 4 * a2);
  ++*(void *)(v2 + 2176);
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[8] + 1;
  a1[8] = v4;
  if (v4 == v3) {
    BlockSplitterFinishBlockDistance();
  }
}

void BlockSplitterFinishBlockLiteral(void *a1, int a2)
{
  int v2 = a2;
  uint64_t v3 = (double *)a1;
  uint64_t v93 = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)a1[4];
  unint64_t v5 = (unsigned int *)a1[5];
  unint64_t v6 = a1[1];
  if (a1[8] > v6) {
    unint64_t v6 = a1[8];
  }
  a1[8] = v6;
  if (!a1[3])
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    *(_DWORD *)v4[3] = v6;
    *(unsigned char *)v4[2] = 0;
    unint64_t v15 = (unint64_t)&v5[*a1];
    double v16 = 0.0;
    unint64_t v17 = v5;
    if (*a1) {
      goto LABEL_13;
    }
    while (1)
    {
      if ((unint64_t)v17 >= v15)
      {
        double v26 = (double)v13;
        if (v13)
        {
          if (v13 > 0xFF) {
            double v27 = log2((double)v13);
          }
          else {
            double v27 = kBrotliLog2Table[v13];
          }
          double v16 = v16 + v26 * v27;
        }
        if (v16 >= v26) {
          double v28 = v16;
        }
        else {
          double v28 = (double)v13;
        }
        v3[12] = v28;
        v3[13] = v28;
        ++*((void *)v3 + 3);
        ++*v4;
        unint64_t v29 = *((void *)v3 + 9) + 1;
        *((void *)v3 + 9) = v29;
        if (v29 < **((void **)v3 + 6))
        {
          uint64_t v30 = &v5[260 * v29];
          bzero(v30, 0x408uLL);
          *((void *)v30 + 129) = 0x7FF0000000000000;
        }
        v3[8] = 0.0;
        goto LABEL_83;
      }
      unsigned int v19 = *v17++;
      uint64_t v18 = v19;
      unint64_t v14 = v13 + v19;
      double v20 = (double)v19;
      if (v19 > 0xFF) {
        double v21 = log2(v20);
      }
      else {
        double v21 = kBrotliLog2Table[v18];
      }
      double v16 = v16 - v20 * v21;
LABEL_13:
      unsigned int v23 = *v17++;
      uint64_t v22 = v23;
      unint64_t v13 = v14 + v23;
      double v24 = (double)v23;
      if (v23 > 0xFF) {
        double v25 = log2(v24);
      }
      else {
        double v25 = kBrotliLog2Table[v22];
      }
      double v16 = v16 - v24 * v25;
    }
  }
  if (!v6) {
    goto LABEL_83;
  }
  uint64_t v82 = a1[3];
  int v83 = v6;
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = &v5[260 * a1[9]];
  double v10 = *(double *)a1;
  unint64_t v11 = &v9[*a1];
  double v12 = 0.0;
  char __src = v9;
  long long v87 = a1 + 12;
  if ((*a1 & 1) == 0) {
    goto LABEL_28;
  }
  while (1)
  {
    unsigned int v36 = *v9++;
    uint64_t v35 = v36;
    unint64_t v7 = v8 + v36;
    double v37 = (double)v36;
    double v38 = v36 > 0xFF ? log2(v37) : kBrotliLog2Table[v35];
    double v12 = v12 - v37 * v38;
LABEL_28:
    if (v9 >= v11) {
      break;
    }
    unsigned int v32 = *v9++;
    uint64_t v31 = v32;
    unint64_t v8 = v7 + v32;
    double v33 = (double)v32;
    if (v32 > 0xFF) {
      double v34 = log2(v33);
    }
    else {
      double v34 = kBrotliLog2Table[v31];
    }
    double v12 = v12 - v33 * v34;
  }
  double v39 = (double)v7;
  long long v84 = v4;
  if (v7)
  {
    if (v7 > 0xFF) {
      double v40 = log2((double)v7);
    }
    else {
      double v40 = kBrotliLog2Table[v7];
    }
    double v12 = v12 + v39 * v40;
  }
  uint64_t v41 = 0;
  char v42 = 1;
  if (v12 < v39) {
    double v12 = (double)v7;
  }
  do
  {
    char v43 = v42;
    int v44 = v3;
    double v45 = v3[v41 + 10];
    uint64_t v46 = (char *)&v91[65 * v41];
    memcpy(v46, __src, 0x410uLL);
    uint64_t v47 = 0;
    uint64_t v48 = v5;
    unint64_t v49 = &v5[260 * *(void *)&v45];
    *((void *)v46 + 128) += *((void *)v49 + 128);
    do
    {
      *(_DWORD *)&v46[v47 * 4] += v49[v47];
      ++v47;
    }
    while (v47 != 256);
    unint64_t v50 = 0;
    unint64_t v51 = 0;
    uint64_t v52 = &v46[4 * *(void *)&v10];
    double v53 = 0.0;
    if (LOBYTE(v10)) {
      goto LABEL_56;
    }
    while (v46 < v52)
    {
      unsigned int v55 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v54 = v55;
      unint64_t v51 = v50 + v55;
      double v56 = (double)v55;
      if (v55 > 0xFF) {
        double v57 = log2(v56);
      }
      else {
        double v57 = kBrotliLog2Table[v54];
      }
      double v53 = v53 - v56 * v57;
LABEL_56:
      unsigned int v61 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v60 = v61;
      unint64_t v50 = v51 + v61;
      double v62 = (double)v61;
      if (v61 > 0xFF) {
        double v63 = log2(v62);
      }
      else {
        double v63 = kBrotliLog2Table[v60];
      }
      double v53 = v53 - v62 * v63;
    }
    double v58 = (double)v50;
    if (v50)
    {
      if (v50 > 0xFF) {
        double v59 = log2((double)v50);
      }
      else {
        double v59 = kBrotliLog2Table[v50];
      }
      unint64_t v5 = v48;
      double v53 = v53 + v58 * v59;
    }
    else
    {
      unint64_t v5 = v48;
    }
    uint64_t v3 = v44;
    char v42 = 0;
    if (v53 >= v58) {
      double v64 = v53;
    }
    else {
      double v64 = v58;
    }
    *(double *)&v90[v41] = v64;
    *(&v88 + v41) = v64 - v12 - *(double *)&v87[v41];
    uint64_t v41 = 1;
  }
  while ((v43 & 1) != 0);
  uint64_t v4 = v84;
  uint64_t v65 = *v84;
  if (*v84 >= 0x100uLL)
  {
    double v68 = v88;
    double v67 = v89;
    int v2 = a2;
  }
  else
  {
    double v66 = v44[2];
    double v68 = v88;
    double v67 = v89;
    BOOL v69 = v88 <= v66 || v89 <= v66;
    int v2 = a2;
    if (!v69)
    {
      *(_DWORD *)(v84[3] + 4 * v82) = v83;
      *(unsigned char *)(v84[2] + v82) = v65;
      v44[11] = v44[10];
      *((void *)v44 + 10) = *(unsigned __int8 *)v84;
      uint64_t v70 = *((void *)v44 + 12);
      v44[12] = v12;
      *((void *)v44 + 13) = v70;
      ++*((void *)v44 + 3);
      ++*v84;
      unint64_t v71 = *((void *)v44 + 9) + 1;
      *((void *)v44 + 9) = v71;
      if (v71 < **((void **)v44 + 6))
      {
        long long v72 = &v5[260 * v71];
        bzero(v72, 0x408uLL);
        *((void *)v72 + 129) = 0x7FF0000000000000;
      }
      v44[14] = 0.0;
      uint64_t v73 = *((void *)v44 + 1);
      v44[8] = 0.0;
LABEL_82:
      *((void *)v44 + 7) = v73;
      goto LABEL_83;
    }
  }
  uint64_t v74 = v84[3];
  if (v67 < v68 + -20.0)
  {
    *(_DWORD *)(v74 + 4 * v82) = v83;
    *(unsigned char *)(v84[2] + v82) = *(unsigned char *)(v84[2] + v82 - 2);
    uint64_t v75 = *((void *)v44 + 10);
    uint64_t v76 = *((void *)v44 + 11);
    *((void *)v44 + 10) = v76;
    *((void *)v44 + 11) = v75;
    memcpy(&v5[260 * v76], v92, 0x410uLL);
    uint64_t v77 = *((void *)v44 + 12);
    v44[12] = *(double *)&v90[1];
    *((void *)v44 + 13) = v77;
    ++*((void *)v44 + 3);
    v44[8] = 0.0;
    long long v78 = &v5[260 * *((void *)v44 + 9)];
    bzero(v78, 0x408uLL);
    *((void *)v78 + 129) = 0x7FF0000000000000;
    v44[14] = 0.0;
    uint64_t v73 = *((void *)v44 + 1);
    goto LABEL_82;
  }
  *(_DWORD *)(v74 + 4 * v82 - 4) += v83;
  memcpy(&v5[260 * *((void *)v44 + 10)], v91, 0x410uLL);
  uint64_t v79 = v90[0];
  v44[12] = *(double *)v90;
  if (*v84 == 1) {
    *((void *)v44 + 13) = v79;
  }
  v44[8] = 0.0;
  long long v80 = &v5[260 * *((void *)v44 + 9)];
  bzero(v80, 0x408uLL);
  *((void *)v80 + 129) = 0x7FF0000000000000;
  unint64_t v81 = *((void *)v44 + 14) + 1;
  *((void *)v44 + 14) = v81;
  if (v81 >= 2)
  {
    uint64_t v73 = *((void *)v44 + 7) + *((void *)v44 + 1);
    goto LABEL_82;
  }
LABEL_83:
  if (v2)
  {
    **((void **)v3 + 6) = *v4;
    v4[1] = *((void *)v3 + 3);
  }
}

void ContextBlockSplitterFinishBlock(void *a1, uint64_t a2, int a3)
{
  int v3 = a3;
  unint64_t v5 = a1;
  v116[13] = *MEMORY[0x263EF8340];
  uint64_t v6 = a1[1];
  unint64_t v7 = (double *)(a1 + 14);
  unint64_t v8 = (void *)a1[6];
  unint64_t v9 = (unsigned int *)a1[7];
  unint64_t v10 = a1[10];
  unint64_t v11 = a1[3];
  if (v10 < v11)
  {
    a1[10] = v11;
    unint64_t v10 = v11;
  }
  uint64_t v112 = v6;
  if (!a1[5])
  {
    *(_DWORD *)v8[3] = v10;
    unint64_t v103 = v8;
    *(unsigned char *)v8[2] = 0;
    if (!v6)
    {
LABEL_29:
      ++v5[5];
      unint64_t v8 = v103;
      ++*v103;
      unint64_t v32 = v5[11] + v6;
      v5[11] = v32;
      if (v32 < *(void *)v5[8])
      {
        uint64_t v33 = v5[1];
        if (v33)
        {
          double v34 = (void *)(v5[7] + 1040 * v32);
          do
          {
            bzero(v34, 0x408uLL);
            v34[129] = 0x7FF0000000000000;
            v34 += 130;
            --v33;
          }
          while (v33);
        }
      }
      v5[10] = 0;
      int v3 = a3;
LABEL_34:
      if (!v3) {
        return;
      }
LABEL_35:
      *(void *)v5[8] = *v8 * v6;
      v8[1] = v5[5];
      return;
    }
    uint64_t v12 = *a1;
    uint64_t v13 = *a1;
    uint64_t v14 = v6;
    while (1)
    {
      unint64_t v15 = 0;
      unint64_t v16 = 0;
      unint64_t v17 = &v9[v13];
      double v18 = 0.0;
      unsigned int v19 = v9;
      if (v12) {
        goto LABEL_18;
      }
      while (v9 < v17)
      {
        unsigned int v21 = *v9++;
        uint64_t v20 = v21;
        unint64_t v16 = v15 + v21;
        double v22 = (double)v21;
        if (v21 > 0xFF) {
          double v23 = log2(v22);
        }
        else {
          double v23 = kBrotliLog2Table[v20];
        }
        double v18 = v18 - v22 * v23;
LABEL_18:
        unsigned int v28 = *v9++;
        uint64_t v27 = v28;
        unint64_t v15 = v16 + v28;
        double v29 = (double)v28;
        if (v28 > 0xFF) {
          double v30 = log2(v29);
        }
        else {
          double v30 = kBrotliLog2Table[v27];
        }
        double v18 = v18 - v29 * v30;
      }
      double v24 = (double)v15;
      if (v15)
      {
        uint64_t v6 = v112;
        double v25 = v19;
        if (v15 > 0xFF) {
          double v26 = log2((double)v15);
        }
        else {
          double v26 = kBrotliLog2Table[v15];
        }
        double v18 = v18 + v24 * v26;
      }
      else
      {
        uint64_t v6 = v112;
        double v25 = v19;
      }
      if (v18 >= v24) {
        double v31 = v18;
      }
      else {
        double v31 = (double)v15;
      }
      *unint64_t v7 = v31;
      v7[v6] = v31;
      ++v7;
      unint64_t v9 = v25 + 260;
      if (!--v14) {
        goto LABEL_29;
      }
    }
  }
  if (!v10) {
    goto LABEL_34;
  }
  if ((v6 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    char __src = (char *)BrotliAllocate(a2);
  }
  else {
    char __src = 0;
  }
  double v113 = 0.0;
  double v114 = 0.0;
  if (!*(_DWORD *)(a2 + 24))
  {
    uint64_t v100 = a2;
    int v108 = v9;
    int v102 = v3;
    unsigned int v104 = v8;
    if (v6)
    {
      uint64_t v35 = 0;
      uint64_t v105 = 1040 * v6;
      uint64_t v36 = *v5;
      int v110 = v9;
      unsigned int v111 = __src;
      do
      {
        unint64_t v37 = 0;
        unint64_t v38 = 0;
        double v39 = &v108[260 * v5[11] + 260 * v35];
        double v40 = &v39[v36];
        double v41 = 0.0;
        int v107 = v39;
        if (v36) {
          goto LABEL_50;
        }
        while (v39 < v40)
        {
          unsigned int v43 = *v39++;
          uint64_t v42 = v43;
          unint64_t v38 = v37 + v43;
          double v44 = (double)v43;
          if (v43 > 0xFF) {
            double v45 = log2(v44);
          }
          else {
            double v45 = kBrotliLog2Table[v42];
          }
          double v41 = v41 - v44 * v45;
LABEL_50:
          unsigned int v49 = *v39++;
          uint64_t v48 = v49;
          unint64_t v37 = v38 + v49;
          double v50 = (double)v49;
          if (v49 > 0xFF) {
            double v51 = log2(v50);
          }
          else {
            double v51 = kBrotliLog2Table[v48];
          }
          double v41 = v41 - v50 * v51;
        }
        double v46 = (double)v37;
        if (v37)
        {
          if (v37 > 0xFF) {
            double v47 = log2((double)v37);
          }
          else {
            double v47 = kBrotliLog2Table[v37];
          }
          double v41 = v41 + v46 * v47;
        }
        uint64_t v52 = 0;
        if (v41 < v46) {
          double v41 = (double)v37;
        }
        uint64_t v109 = v35;
        *(double *)&v116[v35] = v41;
        char v53 = 1;
        do
        {
          uint64_t v54 = v7;
          char v55 = v53;
          uint64_t v56 = v109 + v52 * v6;
          double v57 = v5;
          uint64_t v58 = v5[v52 + 12];
          double v59 = &__src[1040 * v56];
          memcpy(v59, v107, 0x410uLL);
          uint64_t v60 = 0;
          *((void *)v59 + 128) += *(void *)&v108[260 * v58 + 256 + 260 * v109];
          do
          {
            *(_DWORD *)&v111[v105 * v52 + v60 * 4] += v110[260 * v58 + v60];
            ++v60;
          }
          while (v60 != 256);
          unint64_t v61 = 0;
          unint64_t v62 = 0;
          uint64_t v36 = *v57;
          double v63 = &v59[4 * *v57];
          double v64 = 0.0;
          if (*v57) {
            goto LABEL_70;
          }
          while (v59 < v63)
          {
            unsigned int v66 = *(_DWORD *)v59;
            v59 += 4;
            uint64_t v65 = v66;
            unint64_t v62 = v61 + v66;
            double v67 = (double)v66;
            if (v66 > 0xFF) {
              double v68 = log2(v67);
            }
            else {
              double v68 = kBrotliLog2Table[v65];
            }
            double v64 = v64 - v67 * v68;
LABEL_70:
            unsigned int v72 = *(_DWORD *)v59;
            v59 += 4;
            uint64_t v71 = v72;
            unint64_t v61 = v62 + v72;
            double v73 = (double)v72;
            if (v72 > 0xFF) {
              double v74 = log2(v73);
            }
            else {
              double v74 = kBrotliLog2Table[v71];
            }
            double v64 = v64 - v73 * v74;
          }
          double v69 = (double)v61;
          if (v61)
          {
            unint64_t v7 = v54;
            if (v61 > 0xFF) {
              double v70 = log2((double)v61);
            }
            else {
              double v70 = kBrotliLog2Table[v61];
            }
            unint64_t v5 = v57;
            double v64 = v64 + v69 * v70;
            uint64_t v6 = v112;
          }
          else
          {
            unint64_t v5 = v57;
            uint64_t v6 = v112;
            unint64_t v7 = v54;
          }
          char v53 = 0;
          if (v64 >= v69) {
            double v75 = v64;
          }
          else {
            double v75 = v69;
          }
          v115[v56] = v75;
          *(&v113 + v52) = *(&v113 + v52) + v75 - v41 - v7[v56];
          uint64_t v52 = 1;
        }
        while ((v55 & 1) != 0);
        uint64_t v35 = v109 + 1;
        v110 += 260;
        v111 += 1040;
      }
      while (v109 + 1 != v6);
    }
    unint64_t v8 = v104;
    uint64_t v76 = *v104;
    if (*v104 >= v5[2])
    {
      double v79 = v113;
      double v78 = v114;
    }
    else
    {
      double v77 = *((double *)v5 + 4);
      double v79 = v113;
      double v78 = v114;
      if (v113 > v77 && v114 > v77)
      {
        uint64_t v80 = v5[5];
        *(_DWORD *)(v104[3] + 4 * v80) = v5[10];
        *(unsigned char *)(v104[2] + v80) = v76;
        v5[13] = v5[12];
        v5[12] = *v104 * v6;
        uint64_t v81 = v100;
        if (v6)
        {
          uint64_t v82 = v116;
          uint64_t v83 = v6;
          do
          {
            v7[v6] = *v7;
            uint64_t v84 = *v82++;
            *(void *)v7++ = v84;
            --v83;
          }
          while (v83);
        }
        ++v5[5];
        ++*v104;
        unint64_t v85 = v5[11] + v6;
        v5[11] = v85;
        if (v85 < *(void *)v5[8])
        {
          uint64_t v86 = v5[1];
          if (v86)
          {
            long long v87 = (void *)(v5[7] + 1040 * v85);
            do
            {
              bzero(v87, 0x408uLL);
              v87[129] = 0x7FF0000000000000;
              v87 += 130;
              --v86;
            }
            while (v86);
          }
        }
        v5[40] = 0;
        uint64_t v88 = v5[3];
        v5[10] = 0;
        goto LABEL_106;
      }
    }
    int v89 = *((_DWORD *)v5 + 20);
    uint64_t v90 = v104[3];
    uint64_t v91 = v5[5];
    if (v78 >= v79 + -20.0)
    {
      *(_DWORD *)(v90 + 4 * v91 - 4) += v89;
      if (v6)
      {
        uint64_t v95 = 0;
        long long v96 = __src;
        do
        {
          memcpy(&v108[260 * v95 + 260 * v5[12]], v96, 0x410uLL);
          double v97 = v115[v95];
          v7[v95] = v97;
          if (*v104 == 1) {
            *(double *)&v5[v6 + 14 + v95] = v97;
          }
          long long v98 = &v108[260 * v95 + 260 * v5[11]];
          bzero(v98, 0x408uLL);
          *((void *)v98 + 129) = 0x7FF0000000000000;
          ++v95;
          v96 += 1040;
        }
        while (v6 != v95);
      }
      v5[10] = 0;
      unint64_t v99 = v5[40] + 1;
      v5[40] = v99;
      unint64_t v8 = v104;
      uint64_t v81 = v100;
      if (v99 >= 2)
      {
        uint64_t v88 = v5[9] + v5[3];
LABEL_106:
        v5[9] = v88;
      }
    }
    else
    {
      *(_DWORD *)(v90 + 4 * v91) = v89;
      *(unsigned char *)(v104[2] + v91) = *(unsigned char *)(v104[2] + v91 - 2);
      *((int8x16_t *)v5 + 6) = vextq_s8(*((int8x16_t *)v5 + 6), *((int8x16_t *)v5 + 6), 8uLL);
      if (v6)
      {
        uint64_t v92 = 0;
        uint64_t v93 = &__src[1040 * v6];
        do
        {
          memcpy(&v108[260 * v92 + 260 * v5[12]], v93, 0x410uLL);
          v7[v6 + v92] = v7[v92];
          v7[v92] = v115[v6 + v92];
          long long v94 = &v108[260 * v92 + 260 * v5[11]];
          bzero(v94, 0x408uLL);
          *((void *)v94 + 129) = 0x7FF0000000000000;
          ++v92;
          v93 += 1040;
        }
        while (v6 != v92);
      }
      ++v5[5];
      v5[40] = 0;
      v5[9] = v5[3];
      v5[10] = 0;
      unint64_t v8 = v104;
      uint64_t v81 = v100;
    }
    BrotliFree(v81, (unint64_t)__src);
    if (!v102) {
      return;
    }
    goto LABEL_35;
  }
}

void BlockSplitterFinishBlockCommand()
{
  uint64_t v0 = (void *)MEMORY[0x270FA5388]();
  int v2 = v1;
  int v3 = (double *)v0;
  uint64_t v93 = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)v0[4];
  unint64_t v5 = (unsigned int *)v0[5];
  unint64_t v6 = v0[1];
  if (v0[8] > v6) {
    unint64_t v6 = v0[8];
  }
  v0[8] = v6;
  if (!v0[3])
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    *(_DWORD *)v4[3] = v6;
    *(unsigned char *)v4[2] = 0;
    unint64_t v15 = (unint64_t)&v5[*v0];
    double v16 = 0.0;
    unint64_t v17 = v5;
    if (*v0) {
      goto LABEL_13;
    }
    while (1)
    {
      if ((unint64_t)v17 >= v15)
      {
        double v26 = (double)v13;
        if (v13)
        {
          if (v13 > 0xFF) {
            double v27 = log2((double)v13);
          }
          else {
            double v27 = kBrotliLog2Table[v13];
          }
          double v16 = v16 + v26 * v27;
        }
        if (v16 >= v26) {
          double v28 = v16;
        }
        else {
          double v28 = (double)v13;
        }
        v3[12] = v28;
        v3[13] = v28;
        ++*((void *)v3 + 3);
        ++*v4;
        unint64_t v29 = *((void *)v3 + 9) + 1;
        *((void *)v3 + 9) = v29;
        if (v29 < **((void **)v3 + 6))
        {
          double v30 = &v5[708 * v29];
          bzero(v30, 0xB08uLL);
          *((void *)v30 + 353) = 0x7FF0000000000000;
        }
        v3[8] = 0.0;
        goto LABEL_83;
      }
      unsigned int v19 = *v17++;
      uint64_t v18 = v19;
      unint64_t v14 = v13 + v19;
      double v20 = (double)v19;
      if (v19 > 0xFF) {
        double v21 = log2(v20);
      }
      else {
        double v21 = kBrotliLog2Table[v18];
      }
      double v16 = v16 - v20 * v21;
LABEL_13:
      unsigned int v23 = *v17++;
      uint64_t v22 = v23;
      unint64_t v13 = v14 + v23;
      double v24 = (double)v23;
      if (v23 > 0xFF) {
        double v25 = log2(v24);
      }
      else {
        double v25 = kBrotliLog2Table[v22];
      }
      double v16 = v16 - v24 * v25;
    }
  }
  if (!v6) {
    goto LABEL_83;
  }
  uint64_t v82 = v0[3];
  int v83 = v6;
  int v85 = v1;
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = &v5[708 * v0[9]];
  double v10 = *(double *)v0;
  unint64_t v11 = &v9[*v0];
  double v12 = 0.0;
  char __src = v9;
  long long v87 = v0 + 12;
  if ((*v0 & 1) == 0) {
    goto LABEL_28;
  }
  while (1)
  {
    unsigned int v36 = *v9++;
    uint64_t v35 = v36;
    unint64_t v7 = v8 + v36;
    double v37 = (double)v36;
    double v38 = v36 > 0xFF ? log2(v37) : kBrotliLog2Table[v35];
    double v12 = v12 - v37 * v38;
LABEL_28:
    if (v9 >= v11) {
      break;
    }
    unsigned int v32 = *v9++;
    uint64_t v31 = v32;
    unint64_t v8 = v7 + v32;
    double v33 = (double)v32;
    if (v32 > 0xFF) {
      double v34 = log2(v33);
    }
    else {
      double v34 = kBrotliLog2Table[v31];
    }
    double v12 = v12 - v33 * v34;
  }
  double v39 = (double)v7;
  uint64_t v84 = v4;
  if (v7)
  {
    if (v7 > 0xFF) {
      double v40 = log2((double)v7);
    }
    else {
      double v40 = kBrotliLog2Table[v7];
    }
    double v12 = v12 + v39 * v40;
  }
  uint64_t v41 = 0;
  char v42 = 1;
  if (v12 < v39) {
    double v12 = (double)v7;
  }
  do
  {
    char v43 = v42;
    double v44 = v3;
    double v45 = v3[v41 + 10];
    double v46 = (char *)&v91[177 * v41];
    memcpy(v46, __src, 0xB10uLL);
    uint64_t v47 = 0;
    uint64_t v48 = v5;
    unsigned int v49 = &v5[708 * *(void *)&v45];
    *((void *)v46 + 352) += *((void *)v49 + 352);
    do
    {
      *(_DWORD *)&v46[v47 * 4] += v49[v47];
      ++v47;
    }
    while (v47 != 704);
    unint64_t v50 = 0;
    unint64_t v51 = 0;
    uint64_t v52 = &v46[4 * *(void *)&v10];
    double v53 = 0.0;
    if (LOBYTE(v10)) {
      goto LABEL_56;
    }
    while (v46 < v52)
    {
      unsigned int v55 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v54 = v55;
      unint64_t v51 = v50 + v55;
      double v56 = (double)v55;
      if (v55 > 0xFF) {
        double v57 = log2(v56);
      }
      else {
        double v57 = kBrotliLog2Table[v54];
      }
      double v53 = v53 - v56 * v57;
LABEL_56:
      unsigned int v61 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v60 = v61;
      unint64_t v50 = v51 + v61;
      double v62 = (double)v61;
      if (v61 > 0xFF) {
        double v63 = log2(v62);
      }
      else {
        double v63 = kBrotliLog2Table[v60];
      }
      double v53 = v53 - v62 * v63;
    }
    double v58 = (double)v50;
    if (v50)
    {
      if (v50 > 0xFF) {
        double v59 = log2((double)v50);
      }
      else {
        double v59 = kBrotliLog2Table[v50];
      }
      unint64_t v5 = v48;
      double v53 = v53 + v58 * v59;
    }
    else
    {
      unint64_t v5 = v48;
    }
    int v3 = v44;
    char v42 = 0;
    if (v53 >= v58) {
      double v64 = v53;
    }
    else {
      double v64 = v58;
    }
    *(double *)&v90[v41] = v64;
    *(&v88 + v41) = v64 - v12 - *(double *)&v87[v41];
    uint64_t v41 = 1;
  }
  while ((v43 & 1) != 0);
  uint64_t v4 = v84;
  uint64_t v65 = *v84;
  if (*v84 >= 0x100uLL)
  {
    double v68 = v88;
    double v67 = v89;
    int v2 = v85;
  }
  else
  {
    double v66 = v44[2];
    double v68 = v88;
    double v67 = v89;
    BOOL v69 = v88 <= v66 || v89 <= v66;
    int v2 = v85;
    if (!v69)
    {
      *(_DWORD *)(v84[3] + 4 * v82) = v83;
      *(unsigned char *)(v84[2] + v82) = v65;
      v44[11] = v44[10];
      *((void *)v44 + 10) = *(unsigned __int8 *)v84;
      uint64_t v70 = *((void *)v44 + 12);
      v44[12] = v12;
      *((void *)v44 + 13) = v70;
      ++*((void *)v44 + 3);
      ++*v84;
      unint64_t v71 = *((void *)v44 + 9) + 1;
      *((void *)v44 + 9) = v71;
      if (v71 < **((void **)v44 + 6))
      {
        unsigned int v72 = &v5[708 * v71];
        bzero(v72, 0xB08uLL);
        *((void *)v72 + 353) = 0x7FF0000000000000;
      }
      v44[14] = 0.0;
      uint64_t v73 = *((void *)v44 + 1);
      v44[8] = 0.0;
LABEL_82:
      *((void *)v44 + 7) = v73;
      goto LABEL_83;
    }
  }
  uint64_t v74 = v84[3];
  if (v67 < v68 + -20.0)
  {
    *(_DWORD *)(v74 + 4 * v82) = v83;
    *(unsigned char *)(v84[2] + v82) = *(unsigned char *)(v84[2] + v82 - 2);
    uint64_t v75 = *((void *)v44 + 10);
    uint64_t v76 = *((void *)v44 + 11);
    *((void *)v44 + 10) = v76;
    *((void *)v44 + 11) = v75;
    memcpy(&v5[708 * v76], v92, 0xB10uLL);
    uint64_t v77 = *((void *)v44 + 12);
    v44[12] = *(double *)&v90[1];
    *((void *)v44 + 13) = v77;
    ++*((void *)v44 + 3);
    v44[8] = 0.0;
    double v78 = &v5[708 * *((void *)v44 + 9)];
    bzero(v78, 0xB08uLL);
    *((void *)v78 + 353) = 0x7FF0000000000000;
    v44[14] = 0.0;
    uint64_t v73 = *((void *)v44 + 1);
    goto LABEL_82;
  }
  *(_DWORD *)(v74 + 4 * v82 - 4) += v83;
  memcpy(&v5[708 * *((void *)v44 + 10)], v91, 0xB10uLL);
  uint64_t v79 = v90[0];
  v44[12] = *(double *)v90;
  if (*v84 == 1) {
    *((void *)v44 + 13) = v79;
  }
  v44[8] = 0.0;
  uint64_t v80 = &v5[708 * *((void *)v44 + 9)];
  bzero(v80, 0xB08uLL);
  *((void *)v80 + 353) = 0x7FF0000000000000;
  unint64_t v81 = *((void *)v44 + 14) + 1;
  *((void *)v44 + 14) = v81;
  if (v81 >= 2)
  {
    uint64_t v73 = *((void *)v44 + 7) + *((void *)v44 + 1);
    goto LABEL_82;
  }
LABEL_83:
  if (v2)
  {
    **((void **)v3 + 6) = *v4;
    v4[1] = *((void *)v3 + 3);
  }
}

void BlockSplitterFinishBlockDistance()
{
  uint64_t v0 = (void *)MEMORY[0x270FA5388]();
  int v2 = v1;
  int v3 = (double *)v0;
  uint64_t v93 = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)v0[4];
  unint64_t v5 = (unsigned int *)v0[5];
  unint64_t v6 = v0[1];
  if (v0[8] > v6) {
    unint64_t v6 = v0[8];
  }
  v0[8] = v6;
  if (!v0[3])
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    *(_DWORD *)v4[3] = v6;
    *(unsigned char *)v4[2] = 0;
    unint64_t v15 = (unint64_t)&v5[*v0];
    double v16 = 0.0;
    unint64_t v17 = v5;
    if (*v0) {
      goto LABEL_13;
    }
    while (1)
    {
      if ((unint64_t)v17 >= v15)
      {
        double v26 = (double)v13;
        if (v13)
        {
          if (v13 > 0xFF) {
            double v27 = log2((double)v13);
          }
          else {
            double v27 = kBrotliLog2Table[v13];
          }
          double v16 = v16 + v26 * v27;
        }
        if (v16 >= v26) {
          double v28 = v16;
        }
        else {
          double v28 = (double)v13;
        }
        v3[12] = v28;
        v3[13] = v28;
        ++*((void *)v3 + 3);
        ++*v4;
        unint64_t v29 = *((void *)v3 + 9) + 1;
        *((void *)v3 + 9) = v29;
        if (v29 < **((void **)v3 + 6))
        {
          double v30 = &v5[548 * v29];
          bzero(v30, 0x888uLL);
          *((void *)v30 + 273) = 0x7FF0000000000000;
        }
        v3[8] = 0.0;
        goto LABEL_83;
      }
      unsigned int v19 = *v17++;
      uint64_t v18 = v19;
      unint64_t v14 = v13 + v19;
      double v20 = (double)v19;
      if (v19 > 0xFF) {
        double v21 = log2(v20);
      }
      else {
        double v21 = kBrotliLog2Table[v18];
      }
      double v16 = v16 - v20 * v21;
LABEL_13:
      unsigned int v23 = *v17++;
      uint64_t v22 = v23;
      unint64_t v13 = v14 + v23;
      double v24 = (double)v23;
      if (v23 > 0xFF) {
        double v25 = log2(v24);
      }
      else {
        double v25 = kBrotliLog2Table[v22];
      }
      double v16 = v16 - v24 * v25;
    }
  }
  if (!v6) {
    goto LABEL_83;
  }
  uint64_t v82 = v0[3];
  int v83 = v6;
  int v85 = v1;
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = &v5[548 * v0[9]];
  double v10 = *(double *)v0;
  unint64_t v11 = &v9[*v0];
  double v12 = 0.0;
  char __src = v9;
  long long v87 = v0 + 12;
  if ((*v0 & 1) == 0) {
    goto LABEL_28;
  }
  while (1)
  {
    unsigned int v36 = *v9++;
    uint64_t v35 = v36;
    unint64_t v7 = v8 + v36;
    double v37 = (double)v36;
    double v38 = v36 > 0xFF ? log2(v37) : kBrotliLog2Table[v35];
    double v12 = v12 - v37 * v38;
LABEL_28:
    if (v9 >= v11) {
      break;
    }
    unsigned int v32 = *v9++;
    uint64_t v31 = v32;
    unint64_t v8 = v7 + v32;
    double v33 = (double)v32;
    if (v32 > 0xFF) {
      double v34 = log2(v33);
    }
    else {
      double v34 = kBrotliLog2Table[v31];
    }
    double v12 = v12 - v33 * v34;
  }
  double v39 = (double)v7;
  uint64_t v84 = v4;
  if (v7)
  {
    if (v7 > 0xFF) {
      double v40 = log2((double)v7);
    }
    else {
      double v40 = kBrotliLog2Table[v7];
    }
    double v12 = v12 + v39 * v40;
  }
  uint64_t v41 = 0;
  char v42 = 1;
  if (v12 < v39) {
    double v12 = (double)v7;
  }
  do
  {
    char v43 = v42;
    double v44 = v3;
    double v45 = v3[v41 + 10];
    double v46 = (char *)&v91[137 * v41];
    memcpy(v46, __src, 0x890uLL);
    uint64_t v47 = 0;
    uint64_t v48 = v5;
    unsigned int v49 = &v5[548 * *(void *)&v45];
    *((void *)v46 + 272) += *((void *)v49 + 272);
    do
    {
      *(_DWORD *)&v46[v47 * 4] += v49[v47];
      ++v47;
    }
    while (v47 != 544);
    unint64_t v50 = 0;
    unint64_t v51 = 0;
    uint64_t v52 = &v46[4 * *(void *)&v10];
    double v53 = 0.0;
    if (LOBYTE(v10)) {
      goto LABEL_56;
    }
    while (v46 < v52)
    {
      unsigned int v55 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v54 = v55;
      unint64_t v51 = v50 + v55;
      double v56 = (double)v55;
      if (v55 > 0xFF) {
        double v57 = log2(v56);
      }
      else {
        double v57 = kBrotliLog2Table[v54];
      }
      double v53 = v53 - v56 * v57;
LABEL_56:
      unsigned int v61 = *(_DWORD *)v46;
      v46 += 4;
      uint64_t v60 = v61;
      unint64_t v50 = v51 + v61;
      double v62 = (double)v61;
      if (v61 > 0xFF) {
        double v63 = log2(v62);
      }
      else {
        double v63 = kBrotliLog2Table[v60];
      }
      double v53 = v53 - v62 * v63;
    }
    double v58 = (double)v50;
    if (v50)
    {
      if (v50 > 0xFF) {
        double v59 = log2((double)v50);
      }
      else {
        double v59 = kBrotliLog2Table[v50];
      }
      unint64_t v5 = v48;
      double v53 = v53 + v58 * v59;
    }
    else
    {
      unint64_t v5 = v48;
    }
    int v3 = v44;
    char v42 = 0;
    if (v53 >= v58) {
      double v64 = v53;
    }
    else {
      double v64 = v58;
    }
    *(double *)&v90[v41] = v64;
    *(&v88 + v41) = v64 - v12 - *(double *)&v87[v41];
    uint64_t v41 = 1;
  }
  while ((v43 & 1) != 0);
  uint64_t v4 = v84;
  uint64_t v65 = *v84;
  if (*v84 >= 0x100uLL)
  {
    double v68 = v88;
    double v67 = v89;
    int v2 = v85;
  }
  else
  {
    double v66 = v44[2];
    double v68 = v88;
    double v67 = v89;
    BOOL v69 = v88 <= v66 || v89 <= v66;
    int v2 = v85;
    if (!v69)
    {
      *(_DWORD *)(v84[3] + 4 * v82) = v83;
      *(unsigned char *)(v84[2] + v82) = v65;
      v44[11] = v44[10];
      *((void *)v44 + 10) = *(unsigned __int8 *)v84;
      uint64_t v70 = *((void *)v44 + 12);
      v44[12] = v12;
      *((void *)v44 + 13) = v70;
      ++*((void *)v44 + 3);
      ++*v84;
      unint64_t v71 = *((void *)v44 + 9) + 1;
      *((void *)v44 + 9) = v71;
      if (v71 < **((void **)v44 + 6))
      {
        unsigned int v72 = &v5[548 * v71];
        bzero(v72, 0x888uLL);
        *((void *)v72 + 273) = 0x7FF0000000000000;
      }
      v44[14] = 0.0;
      uint64_t v73 = *((void *)v44 + 1);
      v44[8] = 0.0;
LABEL_82:
      *((void *)v44 + 7) = v73;
      goto LABEL_83;
    }
  }
  uint64_t v74 = v84[3];
  if (v67 < v68 + -20.0)
  {
    *(_DWORD *)(v74 + 4 * v82) = v83;
    *(unsigned char *)(v84[2] + v82) = *(unsigned char *)(v84[2] + v82 - 2);
    uint64_t v75 = *((void *)v44 + 10);
    uint64_t v76 = *((void *)v44 + 11);
    *((void *)v44 + 10) = v76;
    *((void *)v44 + 11) = v75;
    memcpy(&v5[548 * v76], v92, 0x890uLL);
    uint64_t v77 = *((void *)v44 + 12);
    v44[12] = *(double *)&v90[1];
    *((void *)v44 + 13) = v77;
    ++*((void *)v44 + 3);
    v44[8] = 0.0;
    double v78 = &v5[548 * *((void *)v44 + 9)];
    bzero(v78, 0x888uLL);
    *((void *)v78 + 273) = 0x7FF0000000000000;
    v44[14] = 0.0;
    uint64_t v73 = *((void *)v44 + 1);
    goto LABEL_82;
  }
  *(_DWORD *)(v74 + 4 * v82 - 4) += v83;
  memcpy(&v5[548 * *((void *)v44 + 10)], v91, 0x890uLL);
  uint64_t v79 = v90[0];
  v44[12] = *(double *)v90;
  if (*v84 == 1) {
    *((void *)v44 + 13) = v79;
  }
  v44[8] = 0.0;
  uint64_t v80 = &v5[548 * *((void *)v44 + 9)];
  bzero(v80, 0x888uLL);
  *((void *)v80 + 273) = 0x7FF0000000000000;
  unint64_t v81 = *((void *)v44 + 14) + 1;
  *((void *)v44 + 14) = v81;
  if (v81 >= 2)
  {
    uint64_t v73 = *((void *)v44 + 7) + *((void *)v44 + 1);
    goto LABEL_82;
  }
LABEL_83:
  if (v2)
  {
    **((void **)v3 + 6) = *v4;
    v4[1] = *((void *)v3 + 3);
  }
}

uint64_t MapStaticContexts(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = *a4 << 6;
  a4[19] = v8;
  if (v8) {
    uint64_t result = BrotliAllocate(a1);
  }
  else {
    uint64_t result = 0;
  }
  a4[18] = result;
  if (!*(_DWORD *)(a1 + 24))
  {
    uint64_t v10 = *a4;
    if (*a4)
    {
      uint64_t v11 = 0;
      do
      {
        for (uint64_t i = 0; i != 256; i += 4)
          *(_DWORD *)(result + i) = *(_DWORD *)(a3 + i) + v11 * a2;
        ++v11;
        result += 256;
      }
      while (v11 != v10);
    }
  }
  return result;
}

uint64_t lzfseEncodeGetScratchSize(int a1)
{
  uint64_t v1 = 684288;
  if (a1 == 2193) {
    uint64_t v1 = 584288;
  }
  if (a1 == 2050) {
    return 64768;
  }
  else {
    return v1;
  }
}

uint64_t lzfseEncodeSetStateScratch(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 68);
  uint64_t v3 = a2 + (32 << *(_DWORD *)(a1 + 64));
  *(void *)(a1 + 112) = a2;
  *(void *)(a1 + 120) = v3;
  uint64_t v4 = v3 + 4 * v2;
  uint64_t v5 = v4 + 4 * v2;
  *(void *)(a1 + 128) = v4;
  *(void *)(a1 + 136) = v5;
  *(void *)(a1 + 144) = v5 + 4 * v2;
  return 0;
}

uint64_t lzfseEncodeInitState(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 == 2050) {
    int v3 = 10;
  }
  else {
    int v3 = 14;
  }
  *(_DWORD *)(a1 + 64) = v3;
  int8x8_t v4 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(a2 == 2050), 0x1FuLL)), (int8x8_t)34359738370000, vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(a2 == 2193), 0x1FuLL)), (int8x8_t)0x3A9800000EA6, (int8x8_t)171798691850000));
  *(int8x8_t *)(a1 + 68) = v4;
  uint64_t v5 = a3 + (32 << v3);
  *(void *)(a1 + 112) = a3;
  *(void *)(a1 + 120) = v5;
  uint64_t v6 = (4 * v4.i32[0]);
  uint64_t v7 = v5 + v6;
  *(void *)(a1 + 128) = v7;
  *(void *)(a1 + 136) = v7 + v6;
  *(void *)(a1 + 144) = v7 + v6 + v6;
  unsigned int v8 = 1;
  int32x4_t v9 = vdupq_n_s32(0xFFF00014);
  do
  {
    uint64_t v10 = (int32x4_t *)(a3 + 32 * (v8 - 1));
    v10[1].i64[0] = 0;
    v10[1].i64[1] = 0;
    *uint64_t v10 = v9;
    LODWORD(v10) = v8++ >> v3;
  }
  while (!v10);
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  return 0;
}

uint64_t lzfseEncodeTranslateState(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    *(void *)a1 += a2;
    int64x2_t v2 = vdupq_n_s64(a2);
    *(int64x2_t *)(a1 + 24) = vsubq_s64(*(int64x2_t *)(a1 + 24), v2);
    *(int64x2_t *)(a1 + 8) = vsubq_s64(*(int64x2_t *)(a1 + 8), v2);
    *(int64x2_t *)(a1 + 80) = vsubq_s64(*(int64x2_t *)(a1 + 80), v2);
    int32x4_t v3 = vdupq_n_s32(a2);
    int v4 = *(_DWORD *)(a1 + 64);
    uint64_t v5 = *(void *)(a1 + 112);
    unsigned int v6 = 1;
    int32x4_t v7 = vdupq_n_s32(0xFFF00014);
    do
      *(int32x4_t *)(v5 + 32 * (v6 - 1)) = vmaxq_s32(vsubq_s32(*(int32x4_t *)(v5 + 32 * (v6 - 1)), v3), v7);
    while (!(v6++ >> v4));
  }
  return 0;
}

uint64_t lzfseEncodeBase(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1 < *(void *)(a1 + 32))
  {
    uint64_t v3 = a1 + 80;
    int32x4_t v32 = vdupq_n_s32(0x3FFFBu);
    int8x16_t v4 = (int8x16_t)xmmword_20DB12B40;
    do
    {
      uint64_t v5 = *(void *)a1;
      unsigned int v6 = (unsigned int *)(*(void *)a1 + v1);
      unsigned int v7 = *v6;
      unsigned int v8 = (int32x4_t *)(*(void *)(a1 + 112) + 32 * ((-1640531535 * *v6) >> -*(unsigned char *)(a1 + 64)));
      int32x4_t v9 = *v8;
      int32x4_t v10 = v8[1];
      int64_t v11 = *(void *)(a1 + 16);
      if (v1 >= v11)
      {
        uint64_t v38 = 0;
        int8x16_t v37 = (int8x16_t)(unint64_t)v1;
        int8x16_t v4 = vandq_s8((int8x16_t)vcgeq_s32(vaddq_s32(v9, v32), vdupq_n_s32(v1)), (int8x16_t)vceqq_s32(v10, vdupq_n_s32(v7)));
        if ((vmaxvq_u32((uint32x4_t)v4) & 0x80000000) != 0)
        {
          int v14 = 0;
          unsigned int v15 = 0;
          uint64_t v16 = 0;
          do
          {
            int8x16_t v36 = v4;
            if (*(_DWORD *)((unint64_t)&v36 & 0xFFFFFFFFFFFFFFF3 | (4 * (v14 & 3))))
            {
              int32x4_t v35 = v9;
              unsigned int v17 = 4;
              while (v17 < *(_DWORD *)(a1 + 8) - (int)v1 - 8)
              {
                uint64_t v18 = *(void *)(v5 + *(int *)((unint64_t)&v35 & 0xFFFFFFFFFFFFFFF3 | (4 * (v14 & 3))) + v17);
                uint64_t v19 = *(void *)((char *)v6 + v17);
                v17 += 8;
                unint64_t v20 = v19 ^ v18;
                if (v20)
                {
                  unsigned int v17 = v17 + (__clz(__rbit64(v20)) >> 3) - 8;
                  break;
                }
              }
              if (v17 > v15)
              {
                uint64_t v16 = *(int *)((unint64_t)&v35 & 0xFFFFFFFFFFFFFFF3 | (4 * (v14 & 3)));
                unsigned int v15 = v17;
              }
            }
            ++v14;
          }
          while (v14 != 4);
          LODWORD(v38) = v15;
          v37.i64[1] = v16;
          if (v15)
          {
            if (v15 >= 0x3997C) {
              int v21 = 235900;
            }
            else {
              int v21 = v15;
            }
            if (v1 <= v11 || v16 < 1)
            {
              uint64_t v24 = v16;
              int64_t v23 = v1;
            }
            else
            {
              uint64_t v22 = v5 - 1;
              int64_t v23 = v1;
              while (*(unsigned __int8 *)(v22 + v16) == *(unsigned __int8 *)(v22 + v23))
              {
                --v23;
                uint64_t v24 = v16 - 1;
                if (v23 > v11 && (unint64_t)v16-- >= 2) {
                  continue;
                }
                goto LABEL_32;
              }
              uint64_t v24 = v16;
            }
LABEL_32:
            v37.i64[0] = v23;
            v37.i64[1] = v24;
            unsigned int v27 = v21 + v1 - v23;
            LODWORD(v38) = v27;
            if (v27 >= 0x28)
            {
              int32x4_t v33 = v10;
              int32x4_t v34 = v9;
              goto LABEL_34;
            }
            uint64_t v30 = *(unsigned int *)(a1 + 96);
            if (!v30)
            {
              int8x16_t v4 = v37;
              *(int8x16_t *)uint64_t v3 = v37;
              *(void *)(v3 + 16) = v38;
              goto LABEL_38;
            }
            int32x4_t v33 = v10;
            int32x4_t v34 = v9;
            if (*(void *)v3 + v30 <= v23)
            {
              if (lzfseBackendMatch((uint64_t *)a1, (int *)v3)) {
                return 4294967294;
              }
              int8x16_t v4 = v37;
              *(int8x16_t *)uint64_t v3 = v37;
              *(void *)(v3 + 16) = v38;
            }
            else
            {
              if (v27 <= v30)
              {
LABEL_7:
                double v12 = (uint64_t *)a1;
                unint64_t v13 = (int *)v3;
              }
              else
              {
LABEL_34:
                unint64_t v13 = (int *)&v37;
                double v12 = (uint64_t *)a1;
              }
              if (lzfseBackendMatch(v12, v13)) {
                return 4294967294;
              }
              *(void *)uint64_t v3 = 0;
              *(void *)(v3 + 8) = 0;
              *(void *)(v3 + 16) = 0;
            }
            int32x4_t v10 = v33;
            int32x4_t v9 = v34;
            goto LABEL_38;
          }
        }
        if (v1 - v11 >= 946)
        {
          int32x4_t v33 = v10;
          int32x4_t v34 = v9;
          if (*(_DWORD *)(a1 + 96)) {
            goto LABEL_7;
          }
          uint64_t v40 = 0;
          int64x2_t v39 = vaddq_s64(vdupq_n_s64(v11), (int64x2_t)xmmword_20DB12B40);
          int v26 = lzfseBackendMatch((uint64_t *)a1, v39.i32);
          int32x4_t v10 = v33;
          int32x4_t v9 = v34;
          if (v26) {
            return 4294967294;
          }
        }
      }
LABEL_38:
      int8x16_t v4 = vextq_s8(v4, (int8x16_t)v10, 0xCuLL);
      int8x16_t v28 = vextq_s8(v4, (int8x16_t)v9, 0xCuLL);
      v28.i32[0] = v1;
      v4.i32[0] = v7;
      *unsigned int v8 = (int32x4_t)v28;
      v8[1] = (int32x4_t)v4;
      uint64_t v29 = *(void *)(a1 + 32);
      uint64_t v1 = *(void *)(a1 + 24) + 1;
      *(void *)(a1 + 24) = v1;
    }
    while (v1 < v29);
  }
  return 0;
}

uint64_t lzfseBackendMatch(uint64_t *a1, int *a2)
{
  uint64_t result = lzfsePushMatch(a1, a2);
  if (result)
  {
    if (lzfseEncodeMatches())
    {
      return 4294967294;
    }
    else
    {
      return lzfsePushMatch(a1, a2);
    }
  }
  return result;
}

uint64_t lzfseEncodeFinish(uint64_t *a1)
{
  if (*((_DWORD *)a1 + 24))
  {
    int64x2_t v2 = a1 + 10;
    if (lzfseBackendMatch(a1, (int *)a1 + 20)) {
      return 4294967294;
    }
    *int64x2_t v2 = 0;
    a1[11] = 0;
    a1[12] = 0;
  }
  uint64_t v3 = a1[1];
  if (v3 <= a1[2] || (v6[0] = a1[1], v6[1] = v3 - 1, v6[2] = 0, !lzfseBackendMatch(a1, (int *)v6)))
  {
    if (!lzfseEncodeMatches())
    {
      int8x16_t v4 = (_DWORD *)a1[5];
      if ((unint64_t)(v4 + 1) <= a1[7])
      {
        uint64_t result = 0;
        *int8x16_t v4 = 611874402;
        a1[5] = (uint64_t)(v4 + 1);
        return result;
      }
    }
  }
  return 4294967294;
}

uint64_t lzfsePushMatch(uint64_t *a1, int *a2)
{
  int v3 = *((_DWORD *)a1 + 26);
  int v4 = *((_DWORD *)a1 + 27);
  uint64_t v5 = a1[2];
  int v6 = *a2;
  unsigned int v7 = *a2 - v5;
  unsigned int v8 = a2[4];
  int v9 = a2[2];
  if (v7 >= 0x13C)
  {
    uint64_t v10 = a1[2];
    int v11 = *((_DWORD *)a1 + 27);
    while (1)
    {
      uint64_t v12 = *((unsigned int *)a1 + 26);
      if ((v12 + 9) > *((_DWORD *)a1 + 17) || (v11 + 331) > *((_DWORD *)a1 + 18)) {
        goto LABEL_27;
      }
      *((_DWORD *)a1 + 26) = v12 + 1;
      uint64_t v13 = a1[16];
      *(_DWORD *)(a1[15] + 4 * v12) = 315;
      *(_DWORD *)(v13 + 4 * v12) = 0;
      uint64_t v14 = a1[18];
      *(_DWORD *)(a1[17] + 4 * v12) = 1;
      unsigned int v15 = (char *)(v14 + *((unsigned int *)a1 + 27));
      uint64_t v16 = (long long *)(*a1 + v10);
      if (v10 + 331 <= a1[1])
      {
        unsigned int v17 = v15 + 315;
        long long v19 = *v16;
        uint64_t v18 = v16 + 1;
        *(_OWORD *)unsigned int v15 = v19;
        unint64_t v20 = v15 + 16;
        do
        {
          long long v21 = *v18++;
          *(_OWORD *)unint64_t v20 = v21;
          v20 += 16;
        }
        while (v20 < v17);
      }
      else
      {
        memcpy(v15, v16, 0x13BuLL);
      }
      int v11 = *((_DWORD *)a1 + 27) + 315;
      *((_DWORD *)a1 + 27) = v11;
      uint64_t v10 = a1[2] + 315;
      a1[2] = v10;
      v7 -= 315;
      if (v7 <= 0x13B) {
        goto LABEL_12;
      }
    }
  }
  uint64_t v10 = a1[2];
  int v11 = *((_DWORD *)a1 + 27);
LABEL_12:
  int v22 = v6 - v9;
  if (v8 >= 0x938)
  {
    while (1)
    {
      uint64_t v23 = *((unsigned int *)a1 + 26);
      if ((v23 + 9) > *((_DWORD *)a1 + 17) || v7 + v11 + 16 > *((_DWORD *)a1 + 18)) {
        goto LABEL_27;
      }
      *((_DWORD *)a1 + 26) = v23 + 1;
      uint64_t v24 = a1[16];
      *(_DWORD *)(a1[15] + 4 * v23) = v7;
      *(_DWORD *)(v24 + 4 * v23) = 2359;
      uint64_t v25 = a1[18];
      *(_DWORD *)(a1[17] + 4 * v23) = v22;
      int v26 = (_OWORD *)(v25 + *((unsigned int *)a1 + 27));
      uint64_t v27 = *a1;
      int8x16_t v28 = (_OWORD *)(*a1 + v10);
      if (v10 + v7 + 16 <= a1[1])
      {
        _OWORD *v26 = *v28;
        if (v7 >= 0x11)
        {
          uint64_t v29 = v26 + 1;
          uint64_t v30 = (long long *)(v27 + v10 + 16);
          do
          {
            long long v31 = *v30++;
            *v29++ = v31;
          }
          while (v29 < (_OWORD *)((char *)v26 + v7));
        }
      }
      else if (v7)
      {
        memcpy(v26, v28, v7);
      }
      unsigned int v32 = 0;
      int v11 = *((_DWORD *)a1 + 27) + v7;
      *((_DWORD *)a1 + 27) = v11;
      uint64_t v10 = a1[2] + v7 + 2359;
      a1[2] = v10;
      v8 -= 2359;
      unsigned int v7 = 0;
      if (v8 <= 0x937) {
        goto LABEL_24;
      }
    }
  }
  unsigned int v32 = v7;
LABEL_24:
  if (v8 | v32)
  {
    uint64_t v33 = *((unsigned int *)a1 + 26);
    if ((v33 + 9) <= *((_DWORD *)a1 + 17) && v32 + v11 + 16 <= *((_DWORD *)a1 + 18))
    {
      *((_DWORD *)a1 + 26) = v33 + 1;
      uint64_t v35 = a1[16];
      *(_DWORD *)(a1[15] + 4 * v33) = v32;
      *(_DWORD *)(v35 + 4 * v33) = v8;
      uint64_t v36 = a1[18];
      *(_DWORD *)(a1[17] + 4 * v33) = v22;
      int8x16_t v37 = (_OWORD *)(v36 + *((unsigned int *)a1 + 27));
      uint64_t v38 = *a1;
      int64x2_t v39 = (_OWORD *)(*a1 + v10);
      if (v10 + v32 + 16 <= a1[1])
      {
        *int8x16_t v37 = *v39;
        if (v32 >= 0x11)
        {
          uint64_t v40 = v37 + 1;
          uint64_t v41 = (long long *)(v10 + v38 + 16);
          do
          {
            long long v42 = *v41++;
            *v40++ = v42;
          }
          while (v40 < (_OWORD *)((char *)v37 + v32));
        }
      }
      else if (v32)
      {
        memcpy(v37, v39, v32);
      }
      uint64_t result = 0;
      *((_DWORD *)a1 + 27) += v32;
      uint64_t v5 = a1[2] + v8 + v32;
      goto LABEL_28;
    }
LABEL_27:
    *((_DWORD *)a1 + 26) = v3;
    *((_DWORD *)a1 + 27) = v4;
    uint64_t result = 4294967294;
LABEL_28:
    a1[2] = v5;
    return result;
  }
  return 0;
}

uint64_t lzfseEncodeMatches()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v1 = v0;
  uint64_t v252 = *MEMORY[0x263EF8340];
  unsigned int v2 = *(_DWORD *)(v0 + 108);
  if (v2)
  {
    bzero(&v233, 0x304uLL);
    int v3 = (unint64_t **)(v1 + 40);
    uint64_t v230 = *(void *)(v1 + 40);
    unsigned int v231 = v2;
    if ((v2 & 3) != 0)
    {
      unsigned int v4 = v2;
      do
      {
        *(_DWORD *)(v1 + 108) = v4 + 1;
        *(unsigned char *)(*(void *)(v1 + 144) + v4) = 0;
        unsigned int v4 = *(_DWORD *)(v1 + 108);
      }
      while ((v4 & 3) != 0);
    }
  }
  else
  {
    if (!*(_DWORD *)(v0 + 104)) {
      return 0;
    }
    unsigned int v231 = 0;
    bzero(&v233, 0x304uLL);
    int v3 = (unint64_t **)(v1 + 40);
    uint64_t v230 = *(void *)(v1 + 40);
  }
  unint64_t v5 = *(unsigned int *)(v1 + 104);
  if (v5)
  {
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = *(void *)(v1 + 136);
    do
    {
      uint64_t v9 = *(unsigned int *)(v8 + 4 * v6);
      if (v9 == v7)
      {
        *(_DWORD *)(v8 + 4 * v6) = 0;
        unint64_t v5 = *(unsigned int *)(v1 + 104);
        uint64_t v9 = v7;
      }
      ++v6;
      uint64_t v7 = v9;
    }
    while (v6 < v5);
  }
  else
  {
    unint64_t v5 = 0;
  }
  memset(v250, 0, sizeof(v250));
  memset(v251, 0, 80);
  memset(v249, 0, sizeof(v249));
  bzero(v248, 0x400uLL);
  if (v5)
  {
    int v10 = 0;
    int v11 = *(int **)(v1 + 120);
    unint64_t v12 = v5;
    do
    {
      uint64_t v13 = *v11++;
      v10 += v13;
      ++v251[getLSymbolFromValue_sym[v13]];
      --v12;
    }
    while (v12);
    int v14 = 0;
    unsigned int v15 = *(int **)(v1 + 128);
    unint64_t v16 = v5;
    do
    {
      uint64_t v17 = *v15++;
      v14 += v17;
      ++*(_DWORD *)&v250[4 * getMSymbolFromValue_sym[v17]];
      --v16;
    }
    while (v16);
    uint64_t v18 = *(unsigned int **)(v1 + 136);
    unint64_t v19 = v5;
    do
    {
      unsigned int v21 = *v18++;
      unsigned int v20 = v21;
      unsigned int v22 = v21 - 60;
      if (v21 >= 0x3C) {
        char v23 = 0;
      }
      else {
        char v23 = v20;
      }
      if (v22 >= 0x3C0) {
        char v24 = 0;
      }
      else {
        char v24 = (v22 >> 4) + 64;
      }
      char v25 = v24 | v23;
      if ((v20 - 1020) >> 10 >= 0xF) {
        char v26 = 0;
      }
      else {
        char v26 = ((unsigned __int16)(v20 - 1020) >> 8) + 0x80;
      }
      unsigned int v27 = v20 - 16380;
      unsigned int v28 = ((v20 + 1032196) >> 12) + 192;
      if (v27 >= 0x3C000) {
        LOBYTE(v28) = 0;
      }
      uint64_t v29 = getDSymbolFromValue_sym[(v25 | v26 | v28)];
      ++*(_DWORD *)&v249[4 * v29];
      --v19;
    }
    while (v19);
  }
  else
  {
    int v14 = 0;
    int v10 = 0;
  }
  unsigned int v30 = *(_DWORD *)(v1 + 108);
  if (v30)
  {
    long long v31 = *(unsigned __int8 **)(v1 + 144);
    uint64_t v32 = *(unsigned int *)(v1 + 108);
    do
    {
      int v33 = *v31++;
      ++v248[v33];
      --v32;
    }
    while (v32);
  }
  uint64_t v232 = *(void *)(v1 + 40);
  if ((unint64_t)(v232 + 752) > *(void *)(v1 + 56)) {
    goto LABEL_149;
  }
  uint64_t v34 = 0;
  int v233 = 829978210;
  int v234 = v14 + v10;
  unsigned int v235 = v30;
  unsigned int v236 = v5;
  int32x4_t v35 = 0uLL;
  do
  {
    int32x4_t v35 = vaddq_s32(*(int32x4_t *)&v251[v34], v35);
    v34 += 4;
  }
  while (v34 != 20);
  unsigned int v36 = vaddvq_s32(v35);
  if (v36) {
    unsigned int v37 = 0x80000000 / v36;
  }
  else {
    unsigned int v37 = 0;
  }
  uint64_t v38 = 0;
  int v39 = 0;
  unsigned int v40 = 0;
  int v41 = 64;
  do
  {
    int v42 = v251[v38];
    unsigned int v43 = (v42 * v37) >> 24;
    unsigned int v44 = v42 != 0;
    if (v43) {
      unsigned int v44 = (v43 + 1) >> 1;
    }
    v240[v38] = v44;
    v41 -= v44;
    BOOL v45 = v44 > v40;
    if ((int)v44 > (int)v40) {
      unsigned int v40 = v44;
    }
    if (v45) {
      int v39 = v38;
    }
    ++v38;
  }
  while (v38 != 20);
  if (-v41 >= (int)(v40 >> 2)) {
    fse_adjust_freqs(v240, -v41, 20);
  }
  else {
    v240[v39] += v41;
  }
  uint64_t v46 = 0;
  int32x4_t v47 = 0uLL;
  do
  {
    int32x4_t v47 = vaddq_s32(*(int32x4_t *)&v250[v46], v47);
    v46 += 16;
  }
  while (v46 != 80);
  unsigned int v48 = vaddvq_s32(v47);
  if (v48) {
    unsigned int v49 = 0x80000000 / v48;
  }
  else {
    unsigned int v49 = 0;
  }
  uint64_t v50 = 0;
  int v51 = 0;
  unsigned int v52 = 0;
  int v53 = 64;
  do
  {
    int v54 = *(_DWORD *)&v250[4 * v50];
    unsigned int v55 = (v54 * v49) >> 24;
    unsigned int v56 = v54 != 0;
    if (v55) {
      unsigned int v56 = (v55 + 1) >> 1;
    }
    v241[v50] = v56;
    v53 -= v56;
    BOOL v57 = v56 > v52;
    if ((int)v56 > (int)v52) {
      unsigned int v52 = v56;
    }
    if (v57) {
      int v51 = v50;
    }
    ++v50;
  }
  while (v50 != 20);
  if (-v53 >= (int)(v52 >> 2)) {
    fse_adjust_freqs(v241, -v53, 20);
  }
  else {
    v241[v51] += v53;
  }
  uint64_t v58 = 0;
  int32x4_t v59 = 0uLL;
  do
  {
    int32x4_t v59 = vaddq_s32(*(int32x4_t *)&v249[v58], v59);
    v58 += 16;
  }
  while (v58 != 256);
  unsigned int v60 = vaddvq_s32(v59);
  if (v60) {
    unsigned int v61 = 0x80000000 / v60;
  }
  else {
    unsigned int v61 = 0;
  }
  uint64_t v62 = 0;
  int v63 = 0;
  unsigned int v64 = 0;
  int v65 = 256;
  do
  {
    int v66 = *(_DWORD *)&v249[4 * v62];
    unsigned int v67 = v66 * v61;
    unsigned int v68 = (((v66 * v61) >> 22) + 1) >> 1;
    unsigned int v69 = v66 != 0;
    if (v67 >= 0x400000) {
      unsigned int v69 = v68;
    }
    v242[v62] = v69;
    v65 -= v69;
    BOOL v70 = v69 > v64;
    if ((int)v69 > (int)v64) {
      unsigned int v64 = v69;
    }
    if (v70) {
      int v63 = v62;
    }
    ++v62;
  }
  while (v62 != 64);
  if (-v65 >= (int)(v64 >> 2)) {
    fse_adjust_freqs(v242, -v65, 64);
  }
  else {
    v242[v63] += v65;
  }
  uint64_t v71 = 0;
  int32x4_t v72 = 0uLL;
  do
  {
    int32x4_t v72 = vaddq_s32(*(int32x4_t *)&v248[v71], v72);
    v71 += 4;
  }
  while (v71 != 256);
  unsigned int v73 = vaddvq_s32(v72);
  if (v73) {
    unsigned int v74 = 0x80000000 / v73;
  }
  else {
    unsigned int v74 = 0;
  }
  uint64_t v75 = 0;
  int v76 = 0;
  unsigned int v77 = 0;
  int v78 = 1024;
  do
  {
    int v79 = v248[v75];
    unsigned int v80 = v79 * v74;
    unsigned int v81 = (((v79 * v74) >> 20) + 1) >> 1;
    unsigned int v82 = v79 != 0;
    if (v80 >= 0x100000) {
      unsigned int v82 = v81;
    }
    v243[v75] = v82;
    v78 -= v82;
    BOOL v83 = v82 > v77;
    if ((int)v82 > (int)v77) {
      unsigned int v77 = v82;
    }
    if (v83) {
      int v76 = v75;
    }
    ++v75;
  }
  while (v75 != 256);
  if (-v78 >= (int)(v77 >> 2)) {
    fse_adjust_freqs(v243, -v78, 256);
  }
  else {
    v243[v76] += v78;
  }
  uint64_t v84 = 0;
  unsigned int v85 = 0;
  int v86 = 0;
  long long v87 = (unsigned char *)(v232 + 32);
  do
  {
    unsigned int v88 = (unsigned __int16)v240[v84];
    unsigned int v89 = (__int16)v88;
    if (v88 >= 8)
    {
      int v92 = 16 * v88;
      int v93 = v92 - 369;
      int v91 = v92 - 121;
      BOOL v94 = v89 > 0x17;
      if (v89 <= 0x17) {
        int v90 = 8;
      }
      else {
        int v90 = 14;
      }
      if (v94) {
        int v91 = v93;
      }
    }
    else
    {
      int v90 = dword_20DB138D0[(__int16)v88];
      int v91 = dword_20DB138F0[(__int16)v88];
    }
    v85 |= v91 << v86;
    int v95 = v90 + v86;
    if (v95 < 8)
    {
      int v86 = v95;
    }
    else
    {
      do
      {
        *v87++ = v85;
        v85 >>= 8;
        int v86 = v95 - 8;
        BOOL v45 = v95 > 0xF;
        v95 -= 8;
      }
      while (v45);
    }
    ++v84;
  }
  while (v84 != 360);
  if (v86 > 0)
  {
    *long long v87 = v85;
    LODWORD(v87) = v87 + 1;
  }
  uint64_t v96 = 0;
  int v97 = 0;
  uint64_t v98 = (v87 - v232);
  *(void *)(v232 + 8) = 0;
  *(void *)(v232 + 16) = 0;
  *(void *)(v232 + 24) = v98;
  unint64_t v99 = (unint64_t *)((char *)*v3 + v98);
  *int v3 = v99;
  uint64_t v100 = &v247;
  do
  {
    unsigned int v101 = (unsigned __int16)v240[v96];
    if (v240[v96])
    {
      __int16 v102 = __clz(v101);
      *((_WORD *)v100 - 2) = (v101 << (v102 - 25)) - 64;
      *((_WORD *)v100 - 1) = v102 - 25;
      *(_WORD *)uint64_t v100 = (0x40u >> (v102 - 25)) + v97 - v101;
      *((_WORD *)v100 + 1) = (0x40u >> (v102 - 26)) + v97 - v101;
      v97 += v101;
    }
    ++v96;
    v100 += 2;
  }
  while (v96 != 20);
  uint64_t v103 = 0;
  int v104 = 0;
  uint64_t v105 = v246;
  do
  {
    unsigned int v106 = (unsigned __int16)v241[v103];
    if (v241[v103])
    {
      __int16 v107 = __clz(v106);
      *(v105 - 2) = (v106 << (v107 - 25)) - 64;
      *(v105 - 1) = v107 - 25;
      *uint64_t v105 = (0x40u >> (v107 - 25)) + v104 - v106;
      v105[1] = (0x40u >> (v107 - 26)) + v104 - v106;
      v104 += v106;
    }
    ++v103;
    v105 += 4;
  }
  while (v103 != 20);
  uint64_t v108 = 0;
  int v109 = 0;
  int v110 = v245;
  do
  {
    unsigned int v111 = (unsigned __int16)v242[v108];
    if (v242[v108])
    {
      __int16 v112 = __clz(v111);
      *(v110 - 2) = (v111 << (v112 - 23)) - 256;
      *(v110 - 1) = v112 - 23;
      *int v110 = (0x100u >> (v112 - 23)) + v109 - v111;
      v110[1] = (0x100u >> (v112 - 24)) + v109 - v111;
      v109 += v111;
    }
    ++v108;
    v110 += 4;
  }
  while (v108 != 64);
  uint64_t v113 = 0;
  int v114 = 0;
  unint64_t v115 = v244;
  do
  {
    unsigned int v116 = (unsigned __int16)v243[v113];
    if (v243[v113])
    {
      __int16 v117 = __clz(v116);
      *(v115 - 2) = (v116 << (v117 - 21)) - 1024;
      *(v115 - 1) = v117 - 21;
      *unint64_t v115 = (0x400u >> (v117 - 21)) + v114 - v116;
      v115[1] = (0x400u >> (v117 - 22)) + v114 - v116;
      v114 += v116;
    }
    ++v113;
    v115 += 4;
  }
  while (v113 != 256);
  int v118 = *(_DWORD *)(v1 + 108);
  if (v118)
  {
    unint64_t v119 = 0;
    LOWORD(v120) = 0;
    LOWORD(v121) = 0;
    LOWORD(v122) = 0;
    LOWORD(v123) = 0;
    int v124 = 0;
    unsigned int v125 = v118 - 2;
    while ((unint64_t)(v99 + 2) <= *(void *)(v1 + 56))
    {
      uint64_t v126 = *(void *)(v1 + 144);
      unsigned int v127 = &v243[4 * *(unsigned __int8 *)(v126 + v125 + 1) + 257];
      int v128 = *v127;
      int v129 = v127[1];
      int v130 = v127 + 2;
      int v131 = v127 + 3;
      BOOL v132 = (unsigned __int16)v120 < v128;
      if (!v132) {
        int v131 = v130;
      }
      int v133 = v129 - v132;
      int v134 = (unsigned __int16)*v131;
      unint64_t v135 = (unint64_t)(unsigned __int16)(v120 & FSE_mask_lsb64_mtable_0[v133]) << v124;
      int v136 = v133 + v124;
      int v120 = v134 + ((unsigned __int16)v120 >> v133);
      unint64_t v137 = &v243[4 * *(unsigned __int8 *)(v126 + v125) + 257];
      int v138 = *v137;
      int v139 = v137[1];
      uint64_t v140 = v137 + 2;
      uint64_t v141 = v137 + 3;
      BOOL v142 = (unsigned __int16)v121 < v138;
      if (!v142) {
        uint64_t v141 = v140;
      }
      int v143 = v139 - v142;
      unint64_t v144 = (unint64_t)(unsigned __int16)(v121 & FSE_mask_lsb64_mtable_0[v143]) << v136;
      int v145 = v143 + v136;
      int v121 = (unsigned __int16)*v141 + ((unsigned __int16)v121 >> v143);
      int v146 = &v243[4 * *(unsigned __int8 *)(v126 + v125 - 1) + 257];
      int v147 = *v146;
      int v148 = v146[1];
      unint64_t v149 = v146 + 2;
      int v150 = v146 + 3;
      BOOL v151 = (unsigned __int16)v122 < v147;
      if (!v151) {
        int v150 = v149;
      }
      int v152 = v148 - v151;
      unint64_t v153 = (unint64_t)(unsigned __int16)(v122 & FSE_mask_lsb64_mtable_0[v152]) << v145;
      int v154 = v152 + v145;
      int v122 = (unsigned __int16)*v150 + ((unsigned __int16)v122 >> v152);
      unsigned int v155 = &v243[4 * *(unsigned __int8 *)(v126 + v125 - 2) + 257];
      int v156 = *v155;
      int v157 = v155[1];
      unsigned int v158 = v155 + 2;
      int v159 = v155 + 3;
      BOOL v160 = (unsigned __int16)v123 < v156;
      if (!v160) {
        int v159 = v158;
      }
      int v161 = v157 - v160;
      unint64_t v162 = v135 | v119 | v144 | v153 | ((unint64_t)(unsigned __int16)(v123 & FSE_mask_lsb64_mtable_0[v161]) << v154);
      int v163 = v161 + v154;
      int v123 = (unsigned __int16)*v159 + ((unsigned __int16)v123 >> v161);
      unint64_t *v99 = v162;
      unint64_t v99 = (unint64_t *)((char *)v99 + (v163 >> 3));
      unint64_t v119 = v162 >> (v163 & 0xF8);
      int v124 = v163 & 7;
      v125 -= 4;
      if (v125 == -2) {
        goto LABEL_148;
      }
    }
    goto LABEL_149;
  }
  int v124 = 0;
  LOWORD(v123) = 0;
  LOWORD(v122) = 0;
  LOWORD(v121) = 0;
  LOWORD(v120) = 0;
  unint64_t v119 = 0;
LABEL_148:
  unint64_t *v99 = v119;
  uint64_t v164 = (unint64_t *)((char *)v99 + ((v124 + 7) >> 3));
  int v165 = *(_DWORD *)(v1 + 40);
  LOWORD(v166) = v123;
  WORD1(v166) = v122;
  WORD2(v166) = v121;
  HIWORD(v166) = v120;
  int v238 = v124 - ((v124 + 7) & 8);
  unsigned int v237 = v164 - v165;
  uint64_t v239 = v166;
  *(void *)(v1 + 40) = v164;
  int v167 = v164 + 1;
  if ((unint64_t)(v164 + 1) > *(void *)(v1 + 56)) {
    goto LABEL_149;
  }
  int v174 = *(_DWORD *)(v1 + 104);
  *uint64_t v164 = 0;
  if (v174)
  {
    LOWORD(v175) = 0;
    LOWORD(v176) = 0;
    LOWORD(v177) = 0;
    int v178 = 0;
    unint64_t v179 = 0;
    uint64_t v180 = 4 * (v174 - 1);
    while ((unint64_t)(v167 + 2) <= *(void *)(v1 + 56))
    {
      unint64_t v181 = *(int *)(*(void *)(v1 + 136) + v180);
      if (v181 >= 0x3C) {
        char v182 = 0;
      }
      else {
        char v182 = *(_DWORD *)(*(void *)(v1 + 136) + v180);
      }
      if ((v181 - 60) >= 0x3C0) {
        char v183 = 0;
      }
      else {
        char v183 = ((v181 - 60) >> 4) + 64;
      }
      char v184 = v183 | v182;
      if ((v181 - 1020) >> 10 >= 0xF) {
        char v185 = 0;
      }
      else {
        char v185 = ((unsigned __int16)(v181 - 1020) >> 8) + 0x80;
      }
      unsigned int v186 = ((v181 + 1032196) >> 12) + 192;
      if ((v181 - 16380) >= 0x3C000) {
        LOBYTE(v186) = 0;
      }
      uint64_t v187 = getDSymbolFromValue_sym[(v184 | v185 | v186)];
      unint64_t v188 = (v181 - (int)kDSymbolVBase[v187]) << v178;
      int v189 = v178 + kDSymbolVBits[v187];
      unint64_t v190 = (__int16 *)&v244[8 * v187 + 2044];
      int v191 = *v190;
      int v192 = v190[1];
      unint64_t v193 = v190 + 2;
      unsigned int v194 = v190 + 3;
      BOOL v195 = (unsigned __int16)v175 < v191;
      if (!v195) {
        unsigned int v194 = v193;
      }
      int v196 = v192 - v195;
      unint64_t v197 = (unint64_t)(unsigned __int16)(v175 & FSE_mask_lsb64_mtable_0[v196]) << v189;
      int v198 = v196 + v189;
      uint64_t v175 = (unsigned __int16)*v194 + ((unsigned __int16)v175 >> v196);
      uint64_t v199 = *(int *)(*(void *)(v1 + 128) + v180);
      uint64_t v200 = getMSymbolFromValue_sym[v199];
      uint64_t v201 = (v199 - (int)kMSymbolVBase[v200]) << v198;
      int v202 = v198 + kMSymbolVBits[v200];
      unint64_t v203 = (__int16 *)&v245[8 * v200 + 508];
      int v204 = *v203;
      int v205 = v203[1];
      int32x4_t v206 = v203 + 2;
      uint64_t v207 = v203 + 3;
      BOOL v208 = (unsigned __int16)v176 < v204;
      if (v208) {
        int32x4_t v206 = v207;
      }
      int v209 = v205 - v208;
      unint64_t v210 = (unint64_t)(unsigned __int16)(v176 & FSE_mask_lsb64_mtable_0[v209]) << v202;
      int v211 = v209 + v202;
      int v176 = (unsigned __int16)*v206 + ((unsigned __int16)v176 >> v209);
      uint64_t v212 = *(int *)(*(void *)(v1 + 120) + v180);
      uint64_t v213 = getLSymbolFromValue_sym[v212];
      uint64_t v214 = (v212 - (int)kLSymbolVBase[v213]) << v211;
      int v215 = v211 + kLSymbolVBits[v213];
      unsigned int v216 = (__int16 *)&v246[8 * v213 + 156];
      int v217 = v216[1];
      BOOL v45 = (unsigned __int16)v177 < *v216;
      unint64_t v218 = v216 + 2;
      uint64_t v219 = v216 + 3;
      if (v45)
      {
        int v220 = 1;
      }
      else
      {
        uint64_t v219 = v218;
        int v220 = 0;
      }
      int v221 = v217 - v220;
      unint64_t v222 = v188 | v179 | v201 | v210 | v214 | ((unint64_t)(unsigned __int16)(v177 & FSE_mask_lsb64_mtable_0[v221]) << v215) | v197;
      int v177 = (unsigned __int16)*v219 + ((unsigned __int16)v177 >> v221);
      unint64_t *v167 = v222;
      int v167 = (unint64_t *)((char *)v167 + ((v221 + v215) >> 3));
      unint64_t v179 = v222 >> ((v221 + v215) & 0xF8);
      int v178 = (v221 + v215) & 7;
      v180 -= 4;
      if (!--v174)
      {
        unint64_t v223 = (unint64_t)(unsigned __int16)v177 << 32;
        unint64_t v224 = (unint64_t)(unsigned __int16)v176 << 42;
        uint64_t v225 = v175 << 52;
        goto LABEL_180;
      }
    }
LABEL_149:
    unint64_t v168 = *(unsigned int *)(v1 + 104);
    if (v168)
    {
      unint64_t v169 = 0;
      uint64_t v170 = 0;
      uint64_t v171 = *(void *)(v1 + 136);
      do
      {
        uint64_t v172 = *(unsigned int *)(v171 + 4 * v169);
        if (!v172)
        {
          *(_DWORD *)(v171 + 4 * v169) = v170;
          unint64_t v168 = *(unsigned int *)(v1 + 104);
          uint64_t v172 = v170;
        }
        ++v169;
        uint64_t v170 = v172;
      }
      while (v169 < v168);
    }
    *(_DWORD *)(v1 + 108) = v231;
    *(void *)(v1 + 40) = v230;
    return 4294967294;
  }
  unint64_t v179 = 0;
  int v178 = 0;
  unint64_t v223 = 0;
  unint64_t v224 = 0;
  uint64_t v225 = 0;
LABEL_180:
  uint64_t result = 0;
  unint64_t *v167 = v179;
  unint64_t v226 = (char *)v167 + ((v178 + 7) >> 3);
  uint64_t v227 = (v226 - *(_DWORD *)(v1 + 40));
  *(void *)(v1 + 40) = v226;
  *(void *)(v1 + 104) = 0;
  int v228 = v234;
  *(_DWORD *)uint64_t v232 = 846755426;
  *(_DWORD *)(v232 + 4) = v228;
  unint64_t v229 = (unsigned __int16)v239 | (unint64_t)(v227 << 40) | ((unint64_t)WORD1(v239) << 10) | ((unint64_t)WORD2(v239) << 20) | ((unint64_t)HIWORD(v239) << 30);
  *(void *)(v232 + 8) = v235 | ((unint64_t)v237 << 20) | ((unint64_t)v236 << 40) | ((unint64_t)(v238 + 7) << 60);
  *(void *)(v232 + 16) = v229 | ((unint64_t)(v178 - ((v178 + 7) & 8u) + 7) << 60);
  *(void *)(v232 + 24) |= v223 | v224 | v225;
  return result;
}

_WORD *fse_adjust_freqs(_WORD *result, signed int a2, int a3)
{
  if (a2)
  {
    for (char i = 3; ; --i)
    {
      uint64_t v4 = a3;
      unint64_t v5 = result;
      if (a3 >= 1) {
        break;
      }
LABEL_9:
      ;
    }
    while (1)
    {
      unsigned int v6 = (unsigned __int16)*v5;
      if (v6 >= 2)
      {
        signed int v7 = (v6 - 1) >> i;
        if (v7 >= a2) {
          signed int v7 = a2;
        }
        *unint64_t v5 = v6 - v7;
        a2 -= v7;
        if (!a2) {
          break;
        }
      }
      ++v5;
      if (!--v4) {
        goto LABEL_9;
      }
    }
  }
  return result;
}

int deflateInit_(z_streamp strm, int level, const char *version, int stream_size)
{
  return deflateInit2_(strm, level, 8, 15, 8, 0, version, stream_size);
}

int deflateSetDictionary(z_streamp strm, const Bytef *dictionary, uInt dictLength)
{
  if (!strm) {
    return -2;
  }
  int result = -2;
  if (dictionary)
  {
    state = strm->state;
    if (state)
    {
      LODWORD(v7) = dictLength;
      int v8 = *((_DWORD *)state + 11);
      if (v8)
      {
        if (v8 == 2 || v8 == 1 && *((_DWORD *)state + 2) != 42) {
          return result;
        }
        strm->uLong adler = adler32(strm->adler, dictionary, dictLength);
      }
      if (v7 >= 3)
      {
        unsigned int v9 = *((_DWORD *)state + 17);
        LODWORD(v10) = v7 - v9;
        if (v7 >= v9) {
          uint64_t v10 = v10;
        }
        else {
          uint64_t v10 = 0;
        }
        if (v9 >= v7) {
          size_t v7 = v7;
        }
        else {
          size_t v7 = v9;
        }
        memcpy(*((void **)state + 10), &dictionary[v10], v7);
        uint64_t v11 = 0;
        *((_DWORD *)state + 39) = v7;
        *((void *)state + 17) = v7;
        unint64_t v12 = (unsigned __int8 *)*((void *)state + 10);
        int v13 = *v12;
        *((_DWORD *)state + 28) = v13;
        int v15 = *((_DWORD *)state + 31);
        int v14 = *((_DWORD *)state + 32);
        unsigned int v16 = ((v13 << v14) ^ v12[1]) & v15;
        *((_DWORD *)state + 28) = v16;
        uint64_t v18 = *((void *)state + 12);
        uint64_t v17 = *((void *)state + 13);
        int v19 = *((_DWORD *)state + 19);
        LODWORD(v20) = v7 - 2;
        if ((v7 - 2) <= 1) {
          uint64_t v20 = 1;
        }
        else {
          uint64_t v20 = v20;
        }
        do
        {
          unsigned int v16 = ((v16 << v14) ^ v12[(v11 + 2)]) & v15;
          *((_DWORD *)state + 28) = v16;
          *(_WORD *)(v18 + 2 * (v19 & v11)) = *(_WORD *)(v17 + 2 * v16);
          *(_WORD *)(v17 + 2 * v16) = v11++;
        }
        while (v20 != v11);
      }
      return 0;
    }
  }
  return result;
}

int deflateSetHeader(z_streamp strm, gz_headerp head)
{
  if (!strm) {
    return -2;
  }
  state = strm->state;
  if (!state || *((_DWORD *)state + 11) != 2) {
    return -2;
  }
  int result = 0;
  *((void *)state + 6) = head;
  return result;
}

int deflatePrime(z_streamp strm, int bits, int value)
{
  if (!strm) {
    return -2;
  }
  state = strm->state;
  if (!state) {
    return -2;
  }
  int result = 0;
  *((_DWORD *)state + 1481) = bits;
  *((_WORD *)state + 2960) = value & ~(-1 << bits);
  return result;
}

int deflateParams(z_streamp strm, int level, int strategy)
{
  if (!strm) {
    return -2;
  }
  state = strm->state;
  if (!state) {
    return -2;
  }
  if (level == -1) {
    unsigned int v6 = 6;
  }
  else {
    unsigned int v6 = level;
  }
  int result = -2;
  if (strategy <= 4 && v6 <= 9)
  {
    if (*((_DWORD *)state + 46) == strategy
      && configuration_table[2 * *((int *)state + 45) + 1] == configuration_table[2 * v6 + 1]
      || !strm->total_in)
    {
      int result = 0;
    }
    else
    {
      int result = deflate(strm, 5);
    }
    if (*((_DWORD *)state + 45) != v6)
    {
      *((_DWORD *)state + 45) = v6;
      int v8 = (unsigned __int16 *)&configuration_table[2 * v6];
      int v9 = v8[1];
      int v10 = v8[2];
      *((_DWORD *)state + 47) = *v8;
      *((_DWORD *)state + 48) = v10;
      *((_DWORD *)state + 43) = v8[3];
      *((_DWORD *)state + 44) = v9;
    }
    *((_DWORD *)state + 46) = strategy;
  }
  return result;
}

int deflateTune(z_streamp strm, int good_length, int max_lazy, int nice_length, int max_chain)
{
  if (!strm) {
    return -2;
  }
  state = strm->state;
  if (!state) {
    return -2;
  }
  int result = 0;
  *((_DWORD *)state + 47) = good_length;
  *((_DWORD *)state + 48) = nice_length;
  *((_DWORD *)state + 43) = max_chain;
  *((_DWORD *)state + 44) = max_lazy;
  return result;
}

uLong deflateBound(z_streamp strm, uLong sourceLen)
{
  uLong v2 = sourceLen + ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6);
  if (!strm) {
    return v2 + 11;
  }
  state = strm->state;
  if (!state) {
    return v2 + 11;
  }
  uint64_t v4 = *((unsigned int *)state + 11);
  if (v4)
  {
    if (v4 == 2)
    {
      uint64_t v6 = *((void *)state + 6);
      if (v6)
      {
        if (*(void *)(v6 + 24)) {
          uint64_t v7 = (*(_DWORD *)(v6 + 32) + 2) + 18;
        }
        else {
          uint64_t v7 = 18;
        }
        int v8 = *(unsigned __int8 **)(v6 + 40);
        if (v8)
        {
          do
            ++v7;
          while (*v8++);
        }
        int v10 = *(unsigned __int8 **)(v6 + 56);
        if (v10)
        {
          do
            ++v7;
          while (*v10++);
        }
        if (*(_DWORD *)(v6 + 68)) {
          uint64_t v4 = v7 + 2;
        }
        else {
          uint64_t v4 = v7;
        }
      }
      else
      {
        uint64_t v4 = 18;
      }
    }
    else if (v4 == 1)
    {
      uint64_t v4 = 10;
      if (!*((_DWORD *)state + 39)) {
        uint64_t v4 = 6;
      }
    }
    else
    {
      uint64_t v4 = 6;
    }
  }
  if (*((_DWORD *)state + 18) == 15 && *((_DWORD *)state + 30) == 15) {
    uLong v12 = sourceLen + 7 + (sourceLen >> 12) + (sourceLen >> 14) + (sourceLen >> 25);
  }
  else {
    uLong v12 = v2 + 5;
  }
  return v12 + v4;
}