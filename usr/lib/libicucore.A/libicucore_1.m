uint64_t icu::UCharCharacterIterator::first32PostInc(icu::UCharCharacterIterator *this)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v7;

  v1 = *((_DWORD *)this + 5);
  v2 = *((int *)this + 4);
  *((_DWORD *)this + 3) = v2;
  if ((int)v2 >= v1) {
    return 0xFFFFLL;
  }
  v3 = *((void *)this + 3);
  v4 = v2 + 1;
  *((_DWORD *)this + 3) = v2 + 1;
  v5 = *(unsigned __int16 *)(v3 + 2 * v2);
  if ((v5 & 0xFC00) == 0xD800 && v4 != v1)
  {
    v7 = *(unsigned __int16 *)(v3 + 2 * v4);
    if ((v7 & 0xFC00) == 0xDC00)
    {
      *((_DWORD *)this + 3) = v2 + 2;
      return (v7 + (v5 << 10) - 56613888);
    }
  }
  return v5;
}

uint64_t icu::UCharCharacterIterator::last32(icu::UCharCharacterIterator *this)
{
  int v2 = *((_DWORD *)this + 4);
  int v1 = *((_DWORD *)this + 5);
  *((_DWORD *)this + 3) = v1;
  if (v1 <= v2) {
    return 0xFFFFLL;
  }
  uint64_t v4 = *((void *)this + 3);
  *((_DWORD *)this + 3) = v1 - 1;
  uint64_t result = *(unsigned __int16 *)(v4 + 2 * (v1 - 1));
  if (v1 - 1 > v2 && (result & 0xFC00) == 56320)
  {
    int v7 = v1 - 2;
    int v8 = *(unsigned __int16 *)(v4 + 2 * v7);
    if ((v8 & 0xFC00) == 0xD800)
    {
      *((_DWORD *)this + 3) = v7;
      return (result + (v8 << 10) - 56613888);
    }
  }
  return result;
}

uint64_t icu::UCharCharacterIterator::setIndex32(icu::UCharCharacterIterator *this, int a2)
{
  int v4 = *((_DWORD *)this + 4);
  int v3 = *((_DWORD *)this + 5);
  if (v3 >= a2) {
    int v5 = a2;
  }
  else {
    int v5 = *((_DWORD *)this + 5);
  }
  if (v4 <= a2) {
    int v6 = v5;
  }
  else {
    int v6 = *((_DWORD *)this + 4);
  }
  if (v6 >= v3)
  {
    *((_DWORD *)this + 3) = v6;
    return 0xFFFFLL;
  }
  else
  {
    uint64_t v7 = *((void *)this + 3);
    uint64_t result = *(unsigned __int16 *)(v7 + 2 * v6);
    if (v6 > v4 && (result & 0xFC00) == 56320)
    {
      if ((*(_WORD *)(v7 + 2 * (v6 - 1)) & 0xFC00) == 0xD800) {
        --v6;
      }
      uint64_t result = *(unsigned __int16 *)(v7 + 2 * v6);
    }
    *((_DWORD *)this + 3) = v6;
    int v10 = v6 + 1;
    if ((result & 0xFC00) == 0xD800 && v10 != v3)
    {
      int v12 = *(unsigned __int16 *)(v7 + 2 * v10);
      if ((v12 & 0xFC00) == 0xDC00) {
        return (v12 + (result << 10) - 56613888);
      }
    }
  }
  return result;
}

uint64_t icu::UCharCharacterIterator::current32(icu::UCharCharacterIterator *this)
{
  int v1 = *((_DWORD *)this + 4);
  uint64_t v2 = *((int *)this + 3);
  if ((int)v2 < v1) {
    return 0xFFFFLL;
  }
  int v3 = *((_DWORD *)this + 5);
  if ((int)v2 >= v3) {
    return 0xFFFFLL;
  }
  uint64_t v4 = *((void *)this + 3);
  uint64_t result = *(unsigned __int16 *)(v4 + 2 * v2);
  if ((result & 0xF800) != 0xD800) {
    return result;
  }
  if ((result & 0x400) != 0)
  {
    if ((int)v2 > v1)
    {
      int v9 = *(unsigned __int16 *)(v4 + 2 * ((int)v2 - 1));
      if ((v9 & 0xFC00) == 0xD800)
      {
        int v8 = result + (v9 << 10);
        return (v8 - 56613888);
      }
    }
  }
  else
  {
    int v6 = v2 + 1;
    if (v6 != v3)
    {
      int v7 = *(unsigned __int16 *)(v4 + 2 * v6);
      if ((v7 & 0xFC00) == 0xDC00)
      {
        int v8 = v7 + (result << 10);
        return (v8 - 56613888);
      }
    }
  }
  return result;
}

uint64_t icu::UCharCharacterIterator::next32(icu::UCharCharacterIterator *this)
{
  uint64_t v1 = *((int *)this + 3);
  int v2 = *((_DWORD *)this + 5);
  if ((int)v1 >= v2) {
    goto LABEL_15;
  }
  uint64_t v3 = *((void *)this + 3);
  int v4 = v1 + 1;
  *((_DWORD *)this + 3) = v1 + 1;
  BOOL v5 = (*(_WORD *)(v3 + 2 * v1) & 0xFC00) != 0xD800 || v4 == v2;
  if (!v5 && (*(_WORD *)(v3 + 2 * v4) & 0xFC00) == 0xDC00)
  {
    int v4 = v1 + 2;
    *((_DWORD *)this + 3) = v1 + 2;
  }
  if (v4 >= v2)
  {
LABEL_15:
    *((_DWORD *)this + 3) = v2;
    return 0xFFFFLL;
  }
  else
  {
    uint64_t v6 = v4 + 1;
    uint64_t result = *(unsigned __int16 *)(v3 + 2 * v4);
    if ((result & 0xFC00) == 0xD800 && v6 != v2)
    {
      int v9 = *(unsigned __int16 *)(v3 + 2 * v6);
      if ((v9 & 0xFC00) == 0xDC00) {
        return (v9 + (result << 10) - 56613888);
      }
    }
  }
  return result;
}

uint64_t icu::UCharCharacterIterator::next32PostInc(icu::UCharCharacterIterator *this)
{
  uint64_t v1 = *((int *)this + 3);
  int v2 = *((_DWORD *)this + 5);
  if ((int)v1 >= v2) {
    return 0xFFFFLL;
  }
  uint64_t v4 = *((void *)this + 3);
  int v5 = v1 + 1;
  *((_DWORD *)this + 3) = v1 + 1;
  uint64_t result = *(unsigned __int16 *)(v4 + 2 * v1);
  if ((result & 0xFC00) == 0xD800 && v5 != v2)
  {
    int v8 = *(unsigned __int16 *)(v4 + 2 * v5);
    if ((v8 & 0xFC00) == 0xDC00)
    {
      *((_DWORD *)this + 3) = v1 + 2;
      return (v8 + (result << 10) - 56613888);
    }
  }
  return result;
}

uint64_t icu::UCharCharacterIterator::previous32(icu::UCharCharacterIterator *this)
{
  int v1 = *((_DWORD *)this + 3);
  int v2 = *((_DWORD *)this + 4);
  if (v1 <= v2) {
    return 0xFFFFLL;
  }
  uint64_t v4 = *((void *)this + 3);
  *((_DWORD *)this + 3) = v1 - 1;
  uint64_t result = *(unsigned __int16 *)(v4 + 2 * (v1 - 1));
  if (v1 - 1 > v2 && (result & 0xFC00) == 56320)
  {
    int v7 = v1 - 2;
    int v8 = *(unsigned __int16 *)(v4 + 2 * v7);
    if ((v8 & 0xFC00) == 0xD800)
    {
      *((_DWORD *)this + 3) = v7;
      return (result + (v8 << 10) - 56613888);
    }
  }
  return result;
}

uint64_t icu::UCharCharacterIterator::move(_DWORD *a1, int a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      int v3 = a1[3];
    }
    else
    {
      if (a3 != 2)
      {
        uint64_t v4 = a1[3];
        goto LABEL_9;
      }
      int v3 = a1[5];
    }
  }
  else
  {
    int v3 = a1[4];
  }
  uint64_t v4 = (v3 + a2);
  a1[3] = v4;
LABEL_9:
  uint64_t v5 = a1[4];
  if ((int)v4 < (int)v5 || (uint64_t v5 = a1[5], (int)v4 > (int)v5))
  {
    a1[3] = v5;
    return v5;
  }
  return v4;
}

uint64_t icu::UCharCharacterIterator::move32(uint64_t a1, int a2, int a3)
{
  switch(a3)
  {
    case 2:
      LODWORD(v10) = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 12) = v10;
      if (a2 < 0)
      {
        int v11 = *(_DWORD *)(a1 + 16);
        int v12 = 1 - a2;
        do
        {
          if ((int)v10 <= v11) {
            break;
          }
          uint64_t v13 = *(void *)(a1 + 24);
          uint64_t v14 = (int)v10;
          uint64_t v10 = (int)v10 - 1;
          *(_DWORD *)(a1 + 12) = v10;
          if ((int)v10 > v11 && (*(_WORD *)(v13 + 2 * v10) & 0xFC00) == 0xDC00)
          {
            uint64_t v15 = v14 - 2;
            if ((*(_WORD *)(v13 + 2 * v15) & 0xFC00) == 0xD800)
            {
              *(_DWORD *)(a1 + 12) = v15;
              LODWORD(v10) = v15;
            }
          }
          --v12;
        }
        while (v12 > 1);
      }
      break;
    case 1:
      if (a2 < 1)
      {
        if (a2 < 0)
        {
          LODWORD(v24) = *(_DWORD *)(a1 + 12);
          int v23 = *(_DWORD *)(a1 + 16);
          int v25 = 1 - a2;
          do
          {
            if ((int)v24 <= v23) {
              break;
            }
            uint64_t v26 = *(void *)(a1 + 24);
            uint64_t v27 = (int)v24;
            uint64_t v24 = (int)v24 - 1;
            *(_DWORD *)(a1 + 12) = v24;
            if ((int)v24 > v23 && (*(_WORD *)(v26 + 2 * v24) & 0xFC00) == 0xDC00)
            {
              uint64_t v28 = v27 - 2;
              if ((*(_WORD *)(v26 + 2 * v28) & 0xFC00) == 0xD800)
              {
                *(_DWORD *)(a1 + 12) = v28;
                LODWORD(v24) = v28;
              }
            }
            --v25;
          }
          while (v25 > 1);
        }
      }
      else
      {
        int v16 = *(_DWORD *)(a1 + 20);
        int v17 = *(_DWORD *)(a1 + 12);
        int v18 = a2 + 1;
        do
        {
          if (v17 >= v16)
          {
            if ((v16 & 0x80000000) == 0) {
              return *(unsigned int *)(a1 + 12);
            }
            uint64_t v19 = *(void *)(a1 + 24);
            __int16 v20 = *(_WORD *)(v19 + 2 * v17);
            if (!v20) {
              return *(unsigned int *)(a1 + 12);
            }
          }
          else
          {
            uint64_t v19 = *(void *)(a1 + 24);
            __int16 v20 = *(_WORD *)(v19 + 2 * v17);
          }
          uint64_t v21 = v17 + 1;
          *(_DWORD *)(a1 + 12) = v21;
          BOOL v22 = (v20 & 0xFC00) != 0xD800 || v21 == v16;
          if (!v22 && (*(_WORD *)(v19 + 2 * v21) & 0xFC00) == 0xDC00)
          {
            LODWORD(v21) = v17 + 2;
            *(_DWORD *)(a1 + 12) = v17 + 2;
          }
          --v18;
          int v17 = v21;
        }
        while (v18 > 1);
      }
      break;
    case 0:
      int v3 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) = v3;
      if (a2 >= 1)
      {
        int v4 = *(_DWORD *)(a1 + 20);
        int v5 = a2 + 1;
        do
        {
          if (v3 >= v4)
          {
            if ((v4 & 0x80000000) == 0) {
              return *(unsigned int *)(a1 + 12);
            }
            uint64_t v6 = *(void *)(a1 + 24);
            __int16 v7 = *(_WORD *)(v6 + 2 * v3);
            if (!v7) {
              return *(unsigned int *)(a1 + 12);
            }
          }
          else
          {
            uint64_t v6 = *(void *)(a1 + 24);
            __int16 v7 = *(_WORD *)(v6 + 2 * v3);
          }
          uint64_t v8 = v3 + 1;
          *(_DWORD *)(a1 + 12) = v8;
          BOOL v9 = (v7 & 0xFC00) != 0xD800 || v8 == v4;
          if (!v9 && (*(_WORD *)(v6 + 2 * v8) & 0xFC00) == 0xDC00)
          {
            LODWORD(v8) = v3 + 2;
            *(_DWORD *)(a1 + 12) = v3 + 2;
          }
          --v5;
          int v3 = v8;
        }
        while (v5 > 1);
      }
      break;
  }
  return *(unsigned int *)(a1 + 12);
}

uint64_t icu::UCharCharacterIterator::setText(uint64_t result, uint64_t *a2, int a3)
{
  uint64_t v3 = *a2;
  *(void *)(result + 24) = *a2;
  if (v3) {
    BOOL v4 = a3 < 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    int v5 = 0;
  }
  else {
    int v5 = a3;
  }
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = v5;
  *(_DWORD *)(result + 8) = v5;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

void *icu::UCharCharacterIterator::getText(icu::UCharCharacterIterator *this, icu::UnicodeString *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  icu::UnicodeString::UnicodeString((uint64_t)v5, *((void *)this + 3), *((unsigned int *)this + 2));
  icu::UnicodeString::operator=(a2, (icu::UnicodeString *)v5);
  return icu::UnicodeString::~UnicodeString(v3, (icu::UnicodeString *)v5);
}

uint64_t u_cleanup()
{
  umtx_lock(0);
  umtx_unlock(0);
  sub_18C85464C();
  sub_18C7F184C();

  return sub_18C8BFE40();
}

uint64_t sub_18C85464C()
{
  for (uint64_t i = 0; i != 8; ++i)
  {
    int v1 = (void (*)(void))qword_1EB20B368[i];
    if (v1)
    {
      v1();
      qword_1EB20B368[i] = 0;
    }
  }
  for (uint64_t j = 0; j != 30; ++j)
  {
    uint64_t v3 = (void (*)(void))qword_1EB20B3A8[j];
    if (v3)
    {
      v3();
      qword_1EB20B3A8[j] = 0;
    }
  }
  return 1;
}

uint64_t ucln_cleanupOne(uint64_t result)
{
  int v1 = (uint64_t (*)(void))qword_1EB20B368[(int)result];
  if (v1)
  {
    uint64_t v2 = (int)result;
    uint64_t result = v1();
    qword_1EB20B368[v2] = 0;
  }
  return result;
}

void sub_18C8546F4(unsigned int a1, uint64_t a2)
{
  if (a1 == 29)
  {
    qword_1EB20B490 = a2;
  }
  else if (a1 <= 0x1D)
  {
    umtx_lock(0);
    qword_1EB20B3A8[a1] = a2;
    umtx_unlock(0);
  }
}

uint64_t ucln_registerCleanup(uint64_t result, uint64_t a2)
{
  if (result <= 7) {
    qword_1EB20B368[result] = a2;
  }
  return result;
}

uint64_t sub_18C85477C(unsigned char *a1)
{
  if (a1)
  {
    unsigned int v1 = bswap32(*(unsigned __int16 *)a1) >> 16;
    if (a1[8]) {
      return (unsigned __int16)v1;
    }
    else {
      return *(unsigned __int16 *)a1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t sub_18C8547A8(unsigned char *a1)
{
  if (a1)
  {
    unsigned int v1 = bswap32(*(unsigned __int16 *)a1) >> 16;
    if (a1[4]) {
      return (unsigned __int16)v1;
    }
    else {
      return *(unsigned __int16 *)a1;
    }
  }
  else
  {
    return 0;
  }
}

void sub_18C8547D4(_OWORD *a1, int *a2)
{
  if (*a2 <= 0)
  {
    if (!a1) {
      goto LABEL_8;
    }
    uint64_t v2 = (unsigned __int8 *)*((void *)a1 + 1);
    if (!v2 || v2[2] != 218 || v2[3] != 39 || v2[8] || v2[9]) {
      goto LABEL_8;
    }
    int v3 = v2[12];
    if (v3 == 84)
    {
      if (v2[13] == 111 && v2[14] == 67 && v2[15] == 80 && v2[16] == 1)
      {
        BOOL v4 = off_1EDA45A08;
        goto LABEL_21;
      }
    }
    else if (v3 == 67 && v2[13] == 109 && v2[14] == 110 && v2[15] == 68 && v2[16] == 1)
    {
      BOOL v4 = off_1EDA459F8;
LABEL_21:
      *(void *)a1 = v4;
      *((void *)a1 + 2) = &v2[*(unsigned __int16 *)v2];
      return;
    }
LABEL_8:
    *a2 = 3;
    udata_close(a1);
  }
}

char *sub_18C8548C0(uint64_t a1, unsigned __int8 *a2, int *a3)
{
  int v3 = *(int **)(a1 + 16);
  if (!v3) {
    return *(char **)(a1 + 8);
  }
  BOOL v4 = v3 + 1;
  int v5 = *v3;
  if (!*v3) {
    return 0;
  }
  uint64_t v6 = (unsigned __int8 *)v3 + v3[1];
  int v7 = -1;
  uint64_t v8 = a2;
  do
  {
    int v10 = *v8++;
    int v9 = v10;
    int v12 = *v6++;
    int v11 = v12;
    ++v7;
    if (v9) {
      BOOL v13 = v9 == v11;
    }
    else {
      BOOL v13 = 0;
    }
  }
  while (v13);
  if (v9 != v11)
  {
    signed int v16 = v5 - 1;
    int v17 = (unsigned __int8 *)v3 + v4[2 * v5 - 2];
    int v18 = -1;
    uint64_t v19 = a2;
    do
    {
      int v21 = *v19++;
      int v20 = v21;
      int v23 = *v17++;
      int v22 = v23;
      ++v18;
      if (v20) {
        BOOL v24 = v20 == v22;
      }
      else {
        BOOL v24 = 0;
      }
    }
    while (v24);
    if (v20 == v22)
    {
      unsigned int v14 = v5 - 1;
LABEL_18:
      if ((v14 & 0x80000000) == 0) {
        goto LABEL_19;
      }
    }
    else if (v5 >= 3)
    {
      int v26 = 1;
      do
      {
        int v27 = v26 + v16;
        if (v26 + v16 < 0 != __OFADD__(v26, v16)) {
          ++v27;
        }
        unsigned int v14 = v27 >> 1;
        if (v7 >= v18) {
          int v28 = v18;
        }
        else {
          int v28 = v7;
        }
        v29 = &a2[v28];
        v30 = (unsigned __int8 *)v3 + v4[2 * v14] + v28;
        int v31 = v28 - 1;
        do
        {
          unsigned int v33 = *v29++;
          unsigned int v32 = v33;
          unsigned int v35 = *v30++;
          unsigned int v34 = v35;
          ++v31;
          if (v32) {
            BOOL v36 = v32 == v34;
          }
          else {
            BOOL v36 = 0;
          }
        }
        while (v36);
        if (v32 >= v34)
        {
          if (v32 == v34) {
            goto LABEL_18;
          }
          int v26 = v14 + 1;
          int v7 = v31;
        }
        else
        {
          int v18 = v31;
          signed int v16 = v14;
        }
      }
      while (v26 < v16);
    }
    return 0;
  }
  unsigned int v14 = 0;
LABEL_19:
  if ((int)(v14 + 1) >= v5) {
    int v25 = -1;
  }
  else {
    int v25 = v4[2 * v14 + 3] - v4[2 * v14 + 1];
  }
  *a3 = v25;
  return (char *)v3 + v4[2 * v14 + 1];
}

uint64_t sub_18C854A10(uint64_t a1)
{
  unsigned int v1 = *(unsigned int **)(a1 + 16);
  if (v1) {
    return *v1;
  }
  else {
    return 0;
  }
}

uint64_t sub_18C854A28(uint64_t a1, unsigned __int8 *a2, _DWORD *a3)
{
  int v3 = *(_DWORD **)(a1 + 16);
  if (!v3) {
    return *(void *)(a1 + 8);
  }
  BOOL v4 = (unsigned __int8 **)(v3 + 2);
  int v5 = *v3;
  if (*v3)
  {
    uint64_t v6 = *v4;
    int v7 = -1;
    uint64_t v8 = a2;
    do
    {
      int v10 = *v8++;
      int v9 = v10;
      int v12 = *v6++;
      int v11 = v12;
      ++v7;
      if (v9) {
        BOOL v13 = v9 == v11;
      }
      else {
        BOOL v13 = 0;
      }
    }
    while (v13);
    if (v9 == v11)
    {
      int v14 = 0;
LABEL_19:
      *a3 = -1;
      return sub_18C87BAEC(*(void *)&v3[4 * v14 + 4]);
    }
    int v16 = v5 - 1;
    int v17 = v4[2 * v5 - 2];
    int v18 = -1;
    uint64_t v19 = a2;
    do
    {
      int v21 = *v19++;
      int v20 = v21;
      int v23 = *v17++;
      int v22 = v23;
      ++v18;
      if (v20) {
        BOOL v24 = v20 == v22;
      }
      else {
        BOOL v24 = 0;
      }
    }
    while (v24);
    if (v20 == v22)
    {
      int v14 = v5 - 1;
LABEL_18:
      if ((v14 & 0x80000000) == 0) {
        goto LABEL_19;
      }
    }
    else if (v5 >= 3)
    {
      int v25 = 1;
      do
      {
        int v26 = v25 + v16;
        if (v25 + v16 < 0 != __OFADD__(v25, v16)) {
          ++v26;
        }
        int v14 = v26 >> 1;
        if (v7 >= v18) {
          int v27 = v18;
        }
        else {
          int v27 = v7;
        }
        int v28 = &a2[v27];
        v29 = &v4[2 * v14][v27];
        int v30 = v27 - 1;
        do
        {
          unsigned int v32 = *v28++;
          unsigned int v31 = v32;
          unsigned int v34 = *v29++;
          unsigned int v33 = v34;
          ++v30;
          if (v31) {
            BOOL v35 = v31 == v33;
          }
          else {
            BOOL v35 = 0;
          }
        }
        while (v35);
        if (v31 >= v33)
        {
          if (v31 == v33) {
            goto LABEL_18;
          }
          int v25 = v14 + 1;
          int v7 = v30;
        }
        else
        {
          int v18 = v30;
          int v16 = v14;
        }
      }
      while (v25 < v16);
    }
  }
  return 0;
}

uint64_t sub_18C854B44(uint64_t a1)
{
  unsigned int v1 = *(unsigned int **)(a1 + 16);
  if (v1) {
    return *v1;
  }
  else {
    return 0;
  }
}

_OWORD *ucnv_open(unsigned __int8 *a1, UErrorCode *a2)
{
  if (a2 && *(int *)a2 <= 0) {
    return ucnv_createConverter(0, a1, a2);
  }
  else {
    return 0;
  }
}

_OWORD *ucnv_openU(UChar *s, UErrorCode *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (!a2 || *(int *)a2 > 0) {
    return 0;
  }
  if (s)
  {
    if (u_strlen(s) >= 60)
    {
      uint64_t result = 0;
      *a2 = U_ILLEGAL_ARGUMENT_ERROR;
      return result;
    }
    memset(v6, 0, 60);
    int v5 = (unsigned __int8 *)u_austrcpy((char *)v6, s);
    if (*(int *)a2 <= 0) {
      return ucnv_createConverter(0, v5, a2);
    }
    return 0;
  }

  return ucnv_createConverter(0, 0, a2);
}

_OWORD *ucnv_openCCSID(unsigned int a1, int a2, UErrorCode *a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (!a3 || *(int *)a3 > 0) {
    return 0;
  }
  memset(v6, 0, 60);
  if (a2)
  {
    uint64_t v5 = 0;
  }
  else
  {
    strcpy((char *)v6, "ibm-");
    uint64_t v5 = 4;
  }
  T_CString_integerToString((unsigned char *)((unint64_t)v6 | v5), a1, 0xAu);
  return ucnv_createConverter(0, (unsigned __int8 *)v6, a3);
}

uint64_t ucnv_safeClone(void (**a1)(void, void, void, void, void, void, void), uint64_t a2, int *a3, int *a4)
{
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  LOWORD(v31[0]) = 56;
  BYTE2(v31[0]) = 1;
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  LOWORD(v29[0]) = 56;
  BYTE2(v29[0]) = 1;
  if (!a4 || *a4 > 0) {
    return 0;
  }
  if (!a1)
  {
    uint64_t v5 = 0;
    int v12 = 1;
LABEL_12:
    *a4 = v12;
    return v5;
  }
  uint64_t v8 = a3;
  int v10 = *(void (**)(void, void, void, void))(*((void *)a1[6] + 4) + 112);
  if (v10)
  {
    int v34 = 0;
    v10(a1, 0, &v34, a4);
    uint64_t v5 = 0;
    if (*a4 >= 1) {
      return v5;
    }
    if (v8) {
      goto LABEL_9;
    }
LABEL_14:
    int v11 = 1;
    int v35 = 1;
    uint64_t v8 = &v35;
    goto LABEL_15;
  }
  int v34 = 288;
  if (!a3) {
    goto LABEL_14;
  }
LABEL_9:
  int v11 = *v8;
  int v35 = v11;
  if (v11 <= 0)
  {
    uint64_t v5 = 0;
    *uint64_t v8 = v34;
    return v5;
  }
LABEL_15:
  if (a2)
  {
    unint64_t v13 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
    size_t v14 = v34;
    uint64_t v15 = v13 - a2 + v34;
    BOOL v16 = v15 <= v11;
    if (v15 > v11) {
      int v17 = 1;
    }
    else {
      int v17 = v11 - (v13 - a2);
    }
    if (v16) {
      unint64_t v18 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    else {
      unint64_t v18 = a2;
    }
    int v35 = v17;
    if (v17 >= v34 && v18)
    {
      uint64_t v19 = 0;
      uint64_t v5 = v18;
      goto LABEL_30;
    }
  }
  else
  {
    unint64_t v18 = 0;
    size_t v14 = v34;
  }
  int v20 = uprv_malloc(v14);
  uint64_t v5 = (uint64_t)v20;
  if (!v20)
  {
    int v12 = 7;
    goto LABEL_12;
  }
  if (v8 != &v35) {
    *a4 = -126;
  }
  size_t v14 = v34;
  *uint64_t v8 = v34;
  uint64_t v19 = v20;
LABEL_30:
  bzero((void *)v5, v14);
  memcpy((void *)v5, a1, 0x120uLL);
  *(_WORD *)(v5 + 61) = 0;
  if ((char *)a1[5] == (char *)(a1 + 17))
  {
    *(void *)(v5 + 40) = v5 + 136;
  }
  else
  {
    int v21 = uprv_malloc(0x40uLL);
    *(void *)(v5 + 40) = v21;
    if (!v21)
    {
LABEL_40:
      uprv_free(v19);
      return 0;
    }
    int v22 = (long long *)a1[5];
    long long v23 = v22[3];
    long long v25 = *v22;
    long long v24 = v22[1];
    v21[2] = v22[2];
    v21[3] = v23;
    *int v21 = v25;
    v21[1] = v24;
  }
  int v26 = *(uint64_t (**)(void, void, void, void))(*((void *)a1[6] + 4) + 112);
  if (v26 && (uint64_t v5 = v26(a1, v5, v8, a4)) == 0 || *a4 >= 1)
  {
    if (v19)
    {
      int v27 = (void *)v19[5];
      if (v27 != v19 + 17) {
        uprv_free(v27);
      }
    }
    goto LABEL_40;
  }
  uint64_t v28 = (uint64_t)a1[6];
  if (*(unsigned char *)(v28 + 25)) {
    sub_18C85B83C(v28);
  }
  if (v5 == v18) {
    *(unsigned char *)(v18 + 61) = 1;
  }
  *((void *)&v29[0] + 1) = v5;
  *((void *)&v31[0] + 1) = v5;
  int v33 = 0;
  ((void (*)(void, _OWORD *, void, void, uint64_t, _DWORD *))a1[1])(a1[4], v31, 0, 0, 5, &v33);
  int v33 = 0;
  (*a1)(a1[3], v29, 0, 0, 0, 5, &v33);
  return v5;
}

uint64_t ucnv_clone(void (**a1)(void, void, void, void, void, void, void), int *a2)
{
  return ucnv_safeClone(a1, 0, 0, a2);
}

void ucnv_close(void *a1)
{
  int v12 = 0;
  if (a1)
  {
    uint64_t v2 = (unsigned char *(*)(unsigned char *, uint64_t, uint64_t, uint64_t, int, int *))a1[1];
    if (v2 != UCNV_TO_U_CALLBACK_SUBSTITUTE)
    {
      uint64_t v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      uint64_t v7 = 65592;
      uint64_t v8 = a1;
      int v12 = 0;
      v2((unsigned char *)a1[4], (uint64_t)&v7, 0, 0, 4, &v12);
    }
    int v3 = (unsigned char *(*)(unsigned char *, uint64_t, uint64_t, uint64_t, int, int, int *))*a1;
    if ((unsigned char *(*)(unsigned char *, uint64_t, uint64_t, uint64_t, int, int, int *))*a1 != UCNV_FROM_U_CALLBACK_SUBSTITUTE)
    {
      uint64_t v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      uint64_t v7 = 65592;
      uint64_t v8 = a1;
      int v12 = 0;
      v3((unsigned char *)a1[3], (uint64_t)&v7, 0, 0, 0, 4, &v12);
    }
    BOOL v4 = *(void (**)(void *))(*(void *)(a1[6] + 32) + 32);
    if (v4) {
      v4(a1);
    }
    uint64_t v5 = (void *)a1[5];
    if (v5 != a1 + 17) {
      uprv_free(v5);
    }
    uint64_t v6 = a1[6];
    if (*(unsigned char *)(v6 + 25)) {
      sub_18C85B7D8(v6);
    }
    if (!*((unsigned char *)a1 + 61)) {
      uprv_free(a1);
    }
  }
}

uint64_t ucnv_getAvailableName(unsigned int a1)
{
  if (HIWORD(a1)) {
    return 0;
  }
  int v2 = 0;
  uint64_t result = sub_18C85C410((unsigned __int16)a1, (UErrorCode *)&v2);
  if (v2 >= 1) {
    return 0;
  }
  return result;
}

uint64_t ucnv_countAvailable()
{
  int v1 = 0;
  return sub_18C85C354((UErrorCode *)&v1);
}

const void **ucnv_getSubstChars(const void **result, void *__dst, unsigned char *a3, int *a4)
{
  if (*a4 <= 0)
  {
    uint64_t v5 = result;
    int v6 = *((char *)result + 89);
    if (v6 <= 0)
    {
      *a3 = 0;
    }
    else if ((char)*a3 >= (char)v6)
    {
      uint64_t result = (const void **)memcpy(__dst, result[5], *((unsigned __int8 *)result + 89));
      *a3 = *((unsigned char *)v5 + 89);
    }
    else
    {
      *a4 = 8;
    }
  }
  return result;
}

void **ucnv_setSubstChars(void **result, const void *a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    char v4 = a3;
    uint64_t v5 = result;
    uint64_t v6 = *((void *)result[6] + 2);
    if (*(char *)(v6 + 71) >= a3 && *(char *)(v6 + 70) <= a3)
    {
      uint64_t result = (void **)memcpy(result[5], a2, a3);
      *((unsigned char *)v5 + 89) = v4;
      *((unsigned char *)v5 + 94) = 0;
    }
    else
    {
      *a4 = 1;
    }
  }
  return result;
}

void ucnv_setSubstString(uint64_t a1, const UChar *a2, int32_t a3, int *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  bzero(v17, 0x400uLL);
  memset(__src, 0, sizeof(__src));
  int v15 = 1024;
  uint64_t v8 = (void *)ucnv_safeClone((void (**)(void, void, void, void, void, void, void))a1, (uint64_t)v17, &v15, a4);
  long long v9 = v8;
  if (*a4 <= 0)
  {
    *uint64_t v8 = UCNV_FROM_U_CALLBACK_STOP;
    v8[3] = 0;
  }
  int v10 = ucnv_fromUChars((uint64_t)v8, (unint64_t)__src, 32, a2, a3, a4);
  ucnv_close(v9);
  if (*a4 <= 0)
  {
    uint64_t v11 = *(void *)(a1 + 48);
    if (*(void *)(*(void *)(v11 + 32) + 104)
      && (*(unsigned char *)(*(void *)(v11 + 16) + 69) != 2 || sub_18C86EDC4(a1) == 9))
    {
      if (a3 >= 33)
      {
        int v12 = 15;
LABEL_9:
        *a4 = v12;
        return;
      }
      if (a3 < 0) {
        a3 = u_strlen(a2);
      }
      int v10 = 2 * a3;
    }
    else
    {
      a2 = (const UChar *)__src;
    }
    if (v10 < 5)
    {
      if (!v10)
      {
LABEL_22:
        *(unsigned char *)(a1 + 89) = v10;
        *(unsigned char *)(a1 + 94) = 0;
        return;
      }
      unint64_t v13 = *(void **)(a1 + 40);
    }
    else
    {
      unint64_t v13 = *(void **)(a1 + 40);
      if (v13 == (void *)(a1 + 136))
      {
        size_t v14 = uprv_malloc(0x40uLL);
        *(void *)(a1 + 40) = v14;
        if (!v14)
        {
          *(void *)(a1 + 40) = v13;
          int v12 = 7;
          goto LABEL_9;
        }
        v14[2] = 0u;
        v14[3] = 0u;
        *size_t v14 = 0u;
        v14[1] = 0u;
        unint64_t v13 = v14;
      }
    }
    memcpy(v13, a2, v10);
    if (a2 != (const UChar *)__src) {
      int v10 = -a3;
    }
    goto LABEL_22;
  }
}

void *ucnv_setFromUCallBack(void *result, uint64_t a2, uint64_t a3, void *a4, void *a5, int *a6)
{
  if (*a6 <= 0)
  {
    if (a4) {
      *a4 = *result;
    }
    *uint64_t result = a2;
    if (a5) {
      *a5 = result[3];
    }
    result[3] = a3;
  }
  return result;
}

uint64_t ucnv_fromUChars(uint64_t a1, unint64_t a2, int a3, const UChar *a4, int a5, int *a6)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a4;
  uint64_t v19 = (unsigned char *)a2;
  if (!a6 || *a6 > 0) {
    return 0;
  }
  if (!a1 || (v9 = a3, a3 < 0) || (a3 ? (v11 = a2 == 0) : (v11 = 0), v11 || (int32_t v12 = a5, a5 < -1) || !a4 && a5))
  {
    uint64_t result = 0;
    *a6 = 1;
  }
  else
  {
    sub_18C8556C0(a1, 2, 1);
    if (v12 == -1) {
      int32_t v12 = u_strlen(a4);
    }
    if (v12 < 1)
    {
      uint64_t v17 = 0;
    }
    else
    {
      unint64_t v14 = (unint64_t)&a4[v12];
      int v15 = a2 + 0x7FFFFFFF;
      if (a2 > 0xFFFFFFFF80000000) {
        int v15 = -1;
      }
      int v16 = v15 - a2;
      if (v16 >= v9) {
        int v16 = v9;
      }
      if (v9) {
        int v9 = v16;
      }
      else {
        int v9 = 0;
      }
      ucnv_fromUnicode(a1, (uint64_t *)&v19, a2 + v9, (unint64_t *)&v18, v14, 0, 1, a6);
      uint64_t v17 = (v19 - a2);
      if (*a6 == 15)
      {
        bzero(v20, 0x400uLL);
        do
        {
          uint64_t v19 = v20;
          *a6 = 0;
          ucnv_fromUnicode(a1, (uint64_t *)&v19, (unint64_t)&v21, (unint64_t *)&v18, v14, 0, 1, a6);
          uint64_t v17 = v17 + v19 - v20;
        }
        while (*a6 == 15);
      }
    }
    return u_terminateChars(a2, v9, v17, a6);
  }
  return result;
}

uint64_t ucnv_reset(uint64_t a1)
{
  return sub_18C8556C0(a1, 0, 1);
}

uint64_t sub_18C8556C0(uint64_t result, uint64_t a2, int a3)
{
  if (result)
  {
    uint64_t v4 = result;
    if (a3)
    {
      if ((int)a2 > 1) {
        goto LABEL_7;
      }
      uint64_t v5 = *(unsigned char *(**)(unsigned char *, uint64_t, uint64_t, uint64_t, int, int *))(result + 8);
      if (v5 != UCNV_TO_U_CALLBACK_SUBSTITUTE)
      {
        uint64_t v13 = 0;
        long long v11 = 0u;
        long long v12 = 0u;
        uint64_t v9 = 65592;
        uint64_t v10 = result;
        int v14 = 0;
        uint64_t result = (uint64_t)v5(*(unsigned char **)(result + 32), (uint64_t)&v9, 0, 0, 3, &v14);
      }
      if (a2 != 1)
      {
LABEL_7:
        uint64_t v6 = *(unsigned char *(**)(unsigned char *, uint64_t, uint64_t, uint64_t, int, int, int *))v4;
        if (*(unsigned char *(**)(unsigned char *, uint64_t, uint64_t, uint64_t, int, int, int *))v4 != UCNV_FROM_U_CALLBACK_SUBSTITUTE)
        {
          uint64_t v13 = 0;
          long long v11 = 0u;
          long long v12 = 0u;
          uint64_t v9 = 65592;
          uint64_t v10 = v4;
          int v14 = 0;
          uint64_t result = (uint64_t)v6(*(unsigned char **)(v4 + 24), (uint64_t)&v9, 0, 0, 0, 3, &v14);
        }
      }
    }
    uint64_t v7 = *(void *)(v4 + 48);
    if ((int)a2 > 1
      || (*(void *)(v4 + 72) = *(unsigned int *)(v7 + 40),
          *(unsigned char *)(v4 + 64) = 0,
          *(unsigned char *)(v4 + 93) = 0,
          *(unsigned char *)(v4 + 90) = 0,
          *(unsigned char *)(v4 + 282) = 0,
          a2 != 1))
    {
      *(void *)(v4 + 80) = 0;
      *(_WORD *)(v4 + 91) = 0;
      *(_DWORD *)(v4 + 208) = -1;
      *(unsigned char *)(v4 + 281) = 0;
    }
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v7 + 32) + 40);
    if (v8) {
      return v8(v4, a2);
    }
  }
  return result;
}

uint64_t ucnv_resetToUnicode(uint64_t a1)
{
  return sub_18C8556C0(a1, 1, 1);
}

uint64_t ucnv_resetFromUnicode(uint64_t a1)
{
  return sub_18C8556C0(a1, 2, 1);
}

uint64_t ucnv_getMaxCharSize(uint64_t a1)
{
  return *(char *)(a1 + 88);
}

uint64_t ucnv_getMinCharSize(uint64_t a1)
{
  return *(char *)(*(void *)(*(void *)(a1 + 48) + 16) + 70);
}

uint64_t ucnv_getName(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(uint64_t (**)(uint64_t))(*(void *)(v4 + 32) + 96);
  if (v5)
  {
    uint64_t result = v5(a1);
    if (result) {
      return result;
    }
    uint64_t v4 = *(void *)(a1 + 48);
  }
  return *(void *)(v4 + 16) + 4;
}

uint64_t ucnv_getCCSID(uint64_t a1, UErrorCode *a2)
{
  if (*(int *)a2 > 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(v4 + 16);
  uint64_t result = *(unsigned int *)(v5 + 64);
  if (!result)
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)(v4 + 32) + 96);
    if (v7)
    {
      uint64_t v8 = (char *)v7(a1);
      if (v8)
      {
LABEL_9:
        StandardName = (char *)ucnv_getStandardName(v8, "IBM", a2);
        uint64_t result = 0;
        if (*(int *)a2 <= 0 && StandardName)
        {
          uint64_t result = (uint64_t)strchr(StandardName, 45);
          if (result) {
            return atol((const char *)(result + 1));
          }
        }
        return result;
      }
      uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 16);
    }
    uint64_t v8 = (char *)(v5 + 4);
    goto LABEL_9;
  }
  return result;
}

uint64_t ucnv_getPlatform(uint64_t a1, int *a2)
{
  if (*a2 <= 0) {
    return *(char *)(*(void *)(*(void *)(a1 + 48) + 16) + 68);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ucnv_getToUCallBack(uint64_t result, void *a2, void *a3)
{
  *a2 = *(void *)(result + 8);
  *a3 = *(void *)(result + 32);
  return result;
}

void *ucnv_getFromUCallBack(void *result, void *a2, void *a3)
{
  *a2 = *result;
  *a3 = result[3];
  return result;
}

uint64_t ucnv_setToUCallBack(uint64_t result, uint64_t a2, uint64_t a3, void *a4, void *a5, int *a6)
{
  if (*a6 <= 0)
  {
    if (a4) {
      *a4 = *(void *)(result + 8);
    }
    *(void *)(result + 8) = a2;
    if (a5) {
      *a5 = *(void *)(result + 32);
    }
    *(void *)(result + 32) = a3;
  }
  return result;
}

uint64_t ucnv_fromUnicode(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6, int a7, int *a8)
{
  unsigned int v31 = a6;
  if (a8 && *a8 <= 0)
  {
    uint64_t v9 = result;
    if (!result || !a2 || !a4) {
      goto LABEL_30;
    }
    unint64_t v13 = *a4;
    unint64_t v14 = *a2;
    uint64_t v15 = a5 + 0x7FFFFFFF;
    if (a5 >= 0xFFFFFFFF80000001) {
      uint64_t v15 = -1;
    }
    unint64_t v16 = a5 - (v15 == a5);
    BOOL v17 = v16 < v13 || v14 > a3;
    if (!v17
      && ((unint64_t v18 = v16 - v13, v16 > v13) ? (v19 = v18 > 0x7FFFFFFE) : (v19 = 0),
          !v19
       && ((a3 - v14) >> 31 ? (BOOL v20 = a3 > v14) : (BOOL v20 = 0), v20 ? (v21 = 0) : (v21 = 1), (v18 & 1) == 0
                                                                                      && (v21 & 1) != 0)))
    {
      v25[0] = 0;
      if (*(char *)(result + 91) < 1 || (uint64_t result = sub_18C855B34(result, a2, a3, &v31, a8), !result))
      {
        if (a7 || v13 != v16 || *(char *)(v9 + 281) < 0)
        {
          BYTE2(v25[0]) = a7;
          v25[1] = v9;
          unint64_t v26 = v13;
          uint64_t v23 = *a2;
          unint64_t v27 = v16;
          uint64_t v28 = v23;
          unint64_t v29 = a3;
          uint64_t v30 = v31;
          LOWORD(v25[0]) = 56;
          uint64_t result = sub_18C855BEC((uint64_t)v25, a8);
          uint64_t v24 = v28;
          *a4 = v26;
          *a2 = v24;
        }
      }
    }
    else
    {
LABEL_30:
      *a8 = 1;
    }
  }
  return result;
}

uint64_t sub_18C855B34(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD **a4, _DWORD *a5)
{
  if (a4) {
    uint64_t v5 = *a4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *a2;
  if (*(char *)(a1 + 91) < 1)
  {
LABEL_11:
    *(unsigned char *)(a1 + 91) = 0;
    *a2 = v6;
    uint64_t result = 0;
    if (v5) {
      *a4 = v5;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = a1 + 104;
    uint64_t v9 = *(unsigned __int8 *)(a1 + 91);
    while (v6 + v7 != a3)
    {
      *(unsigned char *)(v6 + v7) = *(unsigned char *)(v8 + v7);
      if (v5) {
        *v5++ = -1;
      }
      if (v9 == ++v7)
      {
        v6 += v7;
        goto LABEL_11;
      }
    }
    uint64_t v11 = 0;
    do
    {
      long long v12 = (unsigned char *)(v8 + v11);
      char v13 = *(unsigned char *)(v8 + v11++ + v7);
      *long long v12 = v13;
    }
    while (v11 + v7 < (char)v9);
    *(unsigned char *)(a1 + 91) = v11;
    *a2 = a3;
    if (v5) {
      *a4 = v5;
    }
    *a5 = 15;
    return 1;
  }
  return result;
}

uint64_t sub_18C855BEC(uint64_t result, int *a2)
{
  uint64_t v3 = result;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  memset(__dst, 0, sizeof(__dst));
  uint64_t v4 = *(void *)(result + 8);
  unint64_t v5 = *(void *)(result + 16);
  unint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(*(void *)(v4 + 48) + 32);
  if (v6)
  {
    BOOL v19 = *(uint64_t (**)(uint64_t, int *))(v7 + 72);
    if (v19)
    {
      uint64_t v8 = 0;
      goto LABEL_7;
    }
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = 0;
  }
  BOOL v19 = *(uint64_t (**)(uint64_t, int *))(v7 + 64);
LABEL_7:
  uint64_t v9 = *(void *)(result + 32);
  uint64_t v10 = *(char *)(v4 + 281);
  if (v10 < 0)
  {
    uint64_t v23 = *(void *)(result + 24);
    LODWORD(v22) = v8;
    BYTE4(v22) = *(unsigned char *)(result + 2);
    uint64_t result = (uint64_t)memcpy(__dst, (const void *)(v4 + 212), (-2 * v10));
    *(void *)(v3 + 16) = __dst;
    *(void *)(v3 + 24) = &__dst[-2 * v10];
    *(unsigned char *)(v3 + 2) = 0;
    *(unsigned char *)(v4 + 281) = 0;
    uint64_t v8 = 0xFFFFFFFFLL;
    unint64_t v24 = v5;
  }
  else
  {
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    uint64_t v22 = 0;
  }
  __src = (void *)(v4 + 212);
  int v11 = *a2;
  while (2)
  {
    while (2)
    {
      while (2)
      {
        BOOL v20 = v11 <= 0
           && (uint64_t result = v19(v3, a2), *a2 <= 0)
           && *(unsigned char *)(v3 + 2)
           && *(void *)(v3 + 16) == *(void *)(v3 + 24)
           && *(_DWORD *)(v4 + 84) == 0;
        LODWORD(v12) = 0;
        char v13 = 0;
        if (!v6) {
          goto LABEL_19;
        }
LABEL_15:
        uint64_t v14 = *(void *)(v3 + 32) - v9;
        if ((int)v14 >= 1)
        {
          uint64_t result = sub_18C857C68(v6, v14, v8, v12);
          v6 += 4 * v14;
          *(void *)(v3 + 48) = v6;
        }
        if ((v8 & 0x80000000) == 0)
        {
          uint64_t v15 = v8 + ((*(void *)(v3 + 16) - v5) >> 1);
          goto LABEL_20;
        }
        while (1)
        {
LABEL_19:
          uint64_t v15 = v8;
LABEL_20:
          uint64_t v16 = *(char *)(v4 + 281);
          if ((v16 & 0x8000000000000000) == 0) {
            goto LABEL_23;
          }
          if (v24)
          {
            *a2 = 5;
LABEL_23:
            uint64_t v8 = v15;
            goto LABEL_24;
          }
          uint64_t v23 = *(void *)(v3 + 24);
          unint64_t v24 = *(void *)(v3 + 16);
          BYTE4(v22) = *(unsigned char *)(v3 + 2);
          uint64_t result = (uint64_t)memcpy(__dst, __src, (-2 * v16));
          *(void *)(v3 + 16) = __dst;
          *(void *)(v3 + 24) = &__dst[-2 * v16];
          *(unsigned char *)(v3 + 2) = 0;
          uint64_t v8 = (int)v15 + (int)v16 < 0 != __OFADD__(v15, v16) ? 0xFFFFFFFFLL : (v15 + v16);
          *(unsigned char *)(v4 + 281) = 0;
          LODWORD(v22) = v15;
LABEL_24:
          unint64_t v5 = *(void *)(v3 + 16);
          uint64_t v9 = *(void *)(v3 + 32);
          int v11 = *a2;
          if (*a2 <= 0) {
            break;
          }
          if (v13 & 1 | ((v11 - 13) < 0xFFFFFFFD))
          {
            if (v24)
            {
              unint64_t v18 = *(void *)(v3 + 24) - v5;
              if ((int)(v18 >> 1) >= 1)
              {
                uint64_t result = (uint64_t)u_memcpy((UChar *)__src, *(const UChar **)(v3 + 16), v18 >> 1);
                *(unsigned char *)(v4 + 281) = -(v18 >> 1);
              }
              *(void *)(v3 + 16) = v24;
              *(void *)(v3 + 24) = v23;
              *(unsigned char *)(v3 + 2) = BYTE4(v22);
            }
            return result;
          }
          unsigned int v17 = *(_DWORD *)(v4 + 84);
LABEL_32:
          if (HIWORD(v17))
          {
            *(_WORD *)(v4 + 140) = (v17 >> 10) - 10304;
            *(_WORD *)(v4 + 142) = v17 & 0x3FF | 0xDC00;
            uint64_t v12 = 2;
          }
          else
          {
            *(_WORD *)(v4 + 140) = v17;
            uint64_t v12 = 1;
          }
          *(unsigned char *)(v4 + 92) = v12;
          *(_DWORD *)(v4 + 84) = 0;
          uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))v4)(*(void *)(v4 + 24), v3, v4 + 140, v12);
          char v13 = 1;
          if (v6) {
            goto LABEL_15;
          }
        }
        if (v5 < *(void *)(v3 + 24)) {
          continue;
        }
        break;
      }
      if (v24)
      {
        *(void *)(v3 + 16) = v24;
        *(void *)(v3 + 24) = v23;
        uint64_t v8 = v22;
        *(unsigned char *)(v3 + 2) = BYTE4(v22);
        unint64_t v24 = 0;
        continue;
      }
      break;
    }
    if (!*(unsigned char *)(v3 + 2)) {
      return result;
    }
    unsigned int v17 = *(_DWORD *)(v4 + 84);
    if (v17)
    {
      *a2 = 11;
      goto LABEL_32;
    }
    unint64_t v24 = 0;
    if (!v20) {
      continue;
    }
    return sub_18C8556C0(v4, 2, 0);
  }
}

uint64_t ucnv_toUnicode(uint64_t result, char **a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6, int a7, int *a8)
{
  unsigned int v31 = a6;
  if (a8 && *a8 <= 0)
  {
    uint64_t v9 = result;
    if (!result || !a2 || !a4) {
      goto LABEL_19;
    }
    unint64_t v13 = *a4;
    uint64_t v14 = a3 + 0x7FFFFFFF;
    if (a3 >= 0xFFFFFFFF80000001) {
      uint64_t v14 = -1;
    }
    BOOL v15 = v14 == a3;
    if (v13 > a5) {
      goto LABEL_19;
    }
    uint64_t v16 = *a2;
    unsigned int v17 = (char *)(a3 - v15);
    if (a3 - v15 < (unint64_t)*a2 || a5 > v13 && (a5 - v13) >> 31) {
      goto LABEL_19;
    }
    BOOL v20 = v17 >= v16;
    unint64_t v19 = v17 - v16;
    BOOL v20 = v19 != 0 && v20 && v19 >= 0x7FFFFFFF;
    unint64_t v21 = v19 & 1;
    if (!v20 && v21 == 0)
    {
      v25[0] = 0;
      if (*(char *)(result + 93) < 1 || (uint64_t result = sub_18C8560BC(result, (_WORD **)a2, v17, &v31, a8), !result))
      {
        if (a7 || v13 != a5 || *(char *)(v9 + 282) < 0)
        {
          BYTE2(v25[0]) = a7;
          v25[1] = v9;
          unint64_t v26 = v13;
          uint64_t v23 = *a2;
          unint64_t v27 = a5;
          uint64_t v28 = v23;
          unint64_t v29 = v17;
          uint64_t v30 = v31;
          LOWORD(v25[0]) = 56;
          uint64_t result = sub_18C85616C((uint64_t)v25, a8);
          unint64_t v24 = v28;
          *a4 = v26;
          *a2 = v24;
        }
      }
    }
    else
    {
LABEL_19:
      *a8 = 1;
    }
  }
  return result;
}

uint64_t sub_18C8560BC(uint64_t a1, _WORD **a2, _WORD *a3, _DWORD **a4, _DWORD *a5)
{
  unint64_t v5 = *a2;
  if (a4) {
    unint64_t v6 = *a4;
  }
  else {
    unint64_t v6 = 0;
  }
  if (*(char *)(a1 + 93) < 1)
  {
LABEL_10:
    *(unsigned char *)(a1 + 93) = 0;
    *a2 = v5;
    uint64_t result = 0;
    if (v6) {
      *a4 = v6;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = a1 + 144;
    uint64_t v9 = *(unsigned __int8 *)(a1 + 93);
    while (v5 != a3)
    {
      *v5++ = *(_WORD *)(v8 + 2 * v7);
      if (v6) {
        *v6++ = -1;
      }
      if (v9 == ++v7) {
        goto LABEL_10;
      }
    }
    uint64_t v11 = 0;
    do
      *(_WORD *)(v8 + 2 * v11++) = *(_WORD *)(v8 + 2 * v7++);
    while (v7 < (char)v9);
    *(unsigned char *)(a1 + 93) = v11;
    *a2 = a3;
    if (v6) {
      *a4 = v6;
    }
    *a5 = 15;
    return 1;
  }
  return result;
}

uint64_t sub_18C85616C(uint64_t result, int *a2)
{
  uint64_t v3 = result;
  __dst[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(result + 8);
  unint64_t v5 = *(void *)(result + 16);
  unint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(*(void *)(v4 + 48) + 32);
  if (v6)
  {
    unint64_t v24 = *(uint64_t (**)(uint64_t, int *))(v7 + 56);
    if (v24)
    {
      uint64_t v8 = 0;
      goto LABEL_7;
    }
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = 0;
  }
  unint64_t v24 = *(uint64_t (**)(uint64_t, int *))(v7 + 48);
LABEL_7:
  uint64_t v9 = *(void *)(result + 32);
  memset(__dst, 0, 31);
  uint64_t v10 = *(char *)(v4 + 282);
  if (v10 < 0)
  {
    uint64_t v28 = *(void *)(result + 24);
    LODWORD(v27) = v8;
    BYTE4(v27) = *(unsigned char *)(result + 2);
    uint64_t result = (uint64_t)memcpy(__dst, (const void *)(v4 + 250), -v10);
    *(void *)(v3 + 16) = __dst;
    *(void *)(v3 + 24) = (char *)__dst - v10;
    *(unsigned char *)(v3 + 2) = 0;
    *(unsigned char *)(v4 + 282) = 0;
    uint64_t v8 = 0xFFFFFFFFLL;
    unint64_t v29 = v5;
  }
  else
  {
    unint64_t v29 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
  }
  unint64_t v26 = (void *)(v4 + 250);
  int v11 = *a2;
  while (2)
  {
    while (2)
    {
      while (2)
      {
        BOOL v25 = v11 <= 0
           && (uint64_t result = v24(v3, a2), *a2 <= 0)
           && *(unsigned char *)(v3 + 2)
           && *(void *)(v3 + 16) == *(void *)(v3 + 24)
           && *(unsigned char *)(v4 + 64) == 0;
        LODWORD(v12) = 0;
        char v13 = 1;
        if (!v6) {
          goto LABEL_19;
        }
LABEL_15:
        unint64_t v14 = *(void *)(v3 + 32) - v9;
        unint64_t v15 = v14 >> 1;
        if ((int)(v14 >> 1) >= 1)
        {
          uint64_t result = sub_18C857C68(v6, v14 >> 1, v8, v12);
          v6 += 4 * v15;
          *(void *)(v3 + 48) = v6;
        }
        if ((v8 & 0x80000000) == 0)
        {
          uint64_t v16 = (v8 + *(_DWORD *)(v3 + 16) - v5);
          goto LABEL_20;
        }
        while (1)
        {
LABEL_19:
          uint64_t v16 = v8;
LABEL_20:
          uint64_t v17 = *(char *)(v4 + 282);
          if ((v17 & 0x8000000000000000) == 0) {
            goto LABEL_23;
          }
          if (v29)
          {
            *a2 = 5;
LABEL_23:
            uint64_t v8 = v16;
            goto LABEL_24;
          }
          unint64_t v29 = *(void *)(v3 + 16);
          uint64_t v28 = *(void *)(v3 + 24);
          BYTE4(v27) = *(unsigned char *)(v3 + 2);
          uint64_t result = (uint64_t)memcpy(__dst, v26, -(int)v17);
          *(void *)(v3 + 16) = __dst;
          *(void *)(v3 + 24) = (char *)__dst - v17;
          *(unsigned char *)(v3 + 2) = 0;
          uint64_t v8 = (int)v16 + (int)v17 < 0 != __OFADD__(v16, v17) ? 0xFFFFFFFFLL : (v16 + v17);
          *(unsigned char *)(v4 + 282) = 0;
          LODWORD(v27) = v16;
LABEL_24:
          unint64_t v5 = *(void *)(v3 + 16);
          uint64_t v9 = *(void *)(v3 + 32);
          int v11 = *a2;
          if (*a2 <= 0) {
            break;
          }
          if ((v13 & 1) == 0
            || ((BOOL v18 = v11 > 0x13, v19 = (1 << v11) & 0xC1C00, !v18) ? (v20 = v19 == 0) : (v20 = 1), v20))
          {
            if (v29)
            {
              int v23 = *(void *)(v3 + 24) - v5;
              if (v23 >= 1)
              {
                uint64_t result = (uint64_t)memcpy(v26, *(const void **)(v3 + 16), *(void *)(v3 + 24) - v5);
                *(unsigned char *)(v4 + 282) = -(char)v23;
              }
              *(void *)(v3 + 16) = v29;
              *(void *)(v3 + 24) = v28;
              *(unsigned char *)(v3 + 2) = BYTE4(v27);
            }
            return result;
          }
          uint64_t v12 = *(char *)(v4 + 64);
          *(unsigned char *)(v4 + 90) = *(unsigned char *)(v4 + 64);
          if ((int)v12 >= 1) {
            goto LABEL_37;
          }
LABEL_38:
          *(unsigned char *)(v4 + 64) = 0;
          uint64_t v22 = *(unsigned int *)(v4 + 284);
          if (v22 == 1)
          {
            if (*a2 == 10)
            {
              uint64_t v22 = 0;
              *(_DWORD *)(v4 + 284) = 0;
            }
            else
            {
              uint64_t v22 = 1;
            }
          }
          uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, int *))(v4 + 8))(*(void *)(v4 + 32), v3, v4 + 96, v12, v22, a2);
          char v13 = 0;
          *(_DWORD *)(v4 + 284) = 1;
          if (v6) {
            goto LABEL_15;
          }
        }
        if (v5 < *(void *)(v3 + 24)) {
          continue;
        }
        break;
      }
      if (v29)
      {
        *(void *)(v3 + 16) = v29;
        *(void *)(v3 + 24) = v28;
        uint64_t v8 = v27;
        *(unsigned char *)(v3 + 2) = BYTE4(v27);
        unint64_t v29 = 0;
        continue;
      }
      break;
    }
    if (!*(unsigned char *)(v3 + 2)) {
      return result;
    }
    int v21 = *(char *)(v4 + 64);
    if (v21 >= 1)
    {
      uint64_t v12 = *(unsigned __int8 *)(v4 + 64);
      *a2 = 11;
      *(unsigned char *)(v4 + 90) = v21;
LABEL_37:
      memcpy((void *)(v4 + 96), (const void *)(v4 + 65), v12);
      goto LABEL_38;
    }
    unint64_t v29 = 0;
    if (!v25) {
      continue;
    }
    return sub_18C8556C0(v4, 1, 0);
  }
}

uint64_t ucnv_toUChars(uint64_t a1, unint64_t a2, int a3, const char *a4, int a5, int *a6)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  BOOL v18 = a4;
  int v19 = (char *)a2;
  if (!a6 || *a6 > 0) {
    return 0;
  }
  if (!a1 || (v9 = a3, a3 < 0) || (a3 ? (v11 = a2 == 0) : (v11 = 0), v11 || (int v12 = a5, a5 < -1) || !a4 && a5))
  {
    uint64_t result = 0;
    *a6 = 1;
  }
  else
  {
    sub_18C8556C0(a1, 1, 1);
    if (v12 == -1) {
      int v12 = strlen(a4);
    }
    if (v12 < 1)
    {
      unint64_t v17 = 0;
    }
    else
    {
      unint64_t v14 = (unint64_t)&a4[v12];
      uint64_t v15 = a2 + 0x7FFFFFFF;
      if (a2 > 0xFFFFFFFF80000000) {
        uint64_t v15 = 0x1FFFFFFFFLL;
      }
      unint64_t v16 = (v15 - a2) >> 1;
      if ((int)v16 >= v9) {
        LODWORD(v16) = v9;
      }
      if (v9) {
        int v9 = v16;
      }
      else {
        int v9 = 0;
      }
      ucnv_toUnicode(a1, &v19, a2 + 2 * v9, (unint64_t *)&v18, v14, 0, 1, a6);
      unint64_t v17 = (unint64_t)&v19[-a2] >> 1;
      if (*a6 == 15)
      {
        bzero(v20, 0x800uLL);
        do
        {
          int v19 = v20;
          *a6 = 0;
          ucnv_toUnicode(a1, &v19, (unint64_t)&v21, (unint64_t *)&v18, v14, 0, 1, a6);
          unint64_t v17 = v17 + ((unint64_t)(v19 - v20) >> 1);
        }
        while (*a6 == 15);
      }
    }
    return u_terminateUChars(a2, v9, v17, a6);
  }
  return result;
}

uint64_t ucnv_getNextUChar(uint64_t a1, unint64_t *a2, unint64_t a3, int *a4)
{
  if (!a4 || *a4 > 0) {
    return 0xFFFFLL;
  }
  if (!a1 || !a2 || (unint64_t v8 = *a2, *a2 > a3) || a3 > v8 && (a3 - v8) >> 31)
  {
    *a4 = 1;
    return 0xFFFFLL;
  }
  int v11 = *(char *)(a1 + 93);
  if (v11 < 1)
  {
    LODWORD(v9) = -1;
  }
  else
  {
    int v12 = (char *)(a1 + 144);
    uint64_t v9 = *(unsigned __int16 *)(a1 + 144);
    int v13 = 1;
    if (v11 != 1 && (v9 & 0xFC00) == 0xD800)
    {
      int v14 = *(unsigned __int16 *)(a1 + 146);
      BOOL v15 = (v14 & 0xFC00) == 56320;
      unsigned int v16 = v14 + (v9 << 10) - 56613888;
      if (v15) {
        uint64_t v9 = v16;
      }
      else {
        uint64_t v9 = *(unsigned __int16 *)(a1 + 144);
      }
      if (v15) {
        int v13 = 2;
      }
      else {
        int v13 = 1;
      }
    }
    *(unsigned char *)(a1 + 93) = v11 - v13;
    if ((char)(v11 - v13) >= 1) {
      memmove(v12, &v12[2 * v13], 2 * (v11 - v13));
    }
    if (v9 >> 10 != 54 || v13 < v11) {
      return v9;
    }
  }
  int v29 = 0;
  v30[0] = 65592;
  v30[1] = a1;
  unint64_t v31 = v8;
  unint64_t v32 = a3;
  int v33 = (char *)&v29;
  int v34 = (char *)&v29 + 2;
  uint64_t v35 = 0;
  if ((v9 & 0x80000000) == 0)
  {
    LOWORD(v29) = v9;
    int v33 = (char *)&v29 + 2;
    LODWORD(v17) = 1;
    if (*a4 >= 1)
    {
      int v18 = 0;
      uint64_t v9 = 0xFFFFLL;
LABEL_55:
      int v27 = v17 - v18;
      uint64_t v28 = *(unsigned __int8 *)(a1 + 93);
      if (*(char *)(a1 + 93) >= 1) {
        memmove((void *)(a1 + 144 + 2 * v27), (const void *)(a1 + 144), 2 * v28);
      }
      *(unsigned char *)(a1 + 93) = v28 + v27;
      *(_WORD *)(a1 + 144) = *(_WORD *)((unint64_t)&v29 | (2 * v18));
      if (v27 > 1) {
        *(_WORD *)(a1 + 146) = *((_WORD *)&v29 + (v18 + 1));
      }
      goto LABEL_59;
    }
    unsigned __int16 v19 = v9;
    goto LABEL_37;
  }
  if (*(unsigned char *)(a1 + 64)) {
    goto LABEL_30;
  }
  unint64_t v24 = *(uint64_t (**)(void *, int *))(*(void *)(*(void *)(a1 + 48) + 32) + 80);
  if (!v24) {
    goto LABEL_30;
  }
  uint64_t v25 = v24(v30, a4);
  *a2 = v31;
  if (*a4 == 8)
  {
    sub_18C8556C0(a1, 1, 0);
    return 0xFFFFLL;
  }
  if (*a4 > 0 || (uint64_t v9 = v25, (v25 & 0x80000000) != 0))
  {
LABEL_30:
    sub_18C85616C((uint64_t)v30, a4);
    if (*a4 == 15)
    {
      *a4 = 0;
      unint64_t v17 = (unint64_t)(v33 - (char *)&v29) >> 1;
    }
    else
    {
      unint64_t v17 = (unint64_t)(v33 - (char *)&v29) >> 1;
      if (*a4 >= 1)
      {
        int v18 = 0;
        uint64_t v9 = 0xFFFFLL;
        goto LABEL_54;
      }
    }
    if (!v17)
    {
      *a4 = 8;
      uint64_t v9 = 0xFFFFLL;
      goto LABEL_59;
    }
    unsigned __int16 v19 = v29;
LABEL_37:
    uint64_t v9 = v19;
    if ((v19 & 0xFC00) == 0xD800)
    {
      int v20 = *(char *)(a1 + 93);
      BOOL v21 = __OFSUB__(v20, 1);
      int v22 = v20 - 1;
      if (v22 < 0 != v21)
      {
        if (v31 < a3)
        {
          int v34 = (char *)v30;
          sub_18C85616C((uint64_t)v30, a4);
          int v26 = *a4;
          if (*a4 == 15)
          {
            int v26 = 0;
            *a4 = 0;
          }
          unint64_t v17 = (unint64_t)(v33 - (char *)&v29) >> 1;
          int v18 = 1;
          if (v26 <= 0 && v17 == 2)
          {
            if ((HIWORD(v29) & 0xFC00) != 0xDC00)
            {
              LODWORD(v17) = 2;
              goto LABEL_55;
            }
            uint64_t v9 = HIWORD(v29) + (v9 << 10) - 56613888;
            goto LABEL_59;
          }
LABEL_54:
          if (v18 < (int)v17) {
            goto LABEL_55;
          }
LABEL_59:
          *a2 = v31;
          return v9;
        }
      }
      else
      {
        int v23 = *(unsigned __int16 *)(a1 + 144);
        if ((v23 & 0xFC00) == 0xDC00)
        {
          uint64_t v9 = (v23 + (v9 << 10) - 56613888);
          *(unsigned char *)(a1 + 93) = v22;
          if ((_BYTE)v22) {
            memmove((void *)(a1 + 144), (const void *)(a1 + 146), 2 * v22);
          }
        }
      }
    }
    int v18 = 1;
    goto LABEL_54;
  }
  return v9;
}

void ucnv_convertEx(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, const char **a5, const char *a6, uint64_t *a7, uint64_t **a8, uint64_t *a9, uint64_t *a10, char a11, char a12, int *a13)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  v60 = 0;
  if (!a13 || *a13 > 0) {
    return;
  }
  if (!a1) {
    goto LABEL_21;
  }
  if (!a2) {
    goto LABEL_21;
  }
  if (!a5) {
    goto LABEL_21;
  }
  if (!a3) {
    goto LABEL_21;
  }
  unint64_t v17 = *a5;
  if (!*a5) {
    goto LABEL_21;
  }
  if (!a4) {
    goto LABEL_21;
  }
  unint64_t v19 = *a3;
  if (!*a3) {
    goto LABEL_21;
  }
  int v20 = a6;
  if (v17 > a6 && a6 != 0) {
    goto LABEL_21;
  }
  if (v19 > a4) {
    goto LABEL_21;
  }
  int v22 = a8;
  int v23 = a7;
  if (a6 > v17)
  {
    if ((unint64_t)(a6 - v17) >> 31) {
      goto LABEL_21;
    }
  }
  BOOL v24 = a4 >= v19;
  unint64_t v25 = a4 - v19;
  if (v25 != 0 && v24)
  {
    if (v25 >> 31) {
      goto LABEL_21;
    }
  }
  v59 = 0;
  if (a7)
  {
    if (!a8 || (int v27 = a10, a7 >= a10) || (v28 = a9) == 0 || !*a8 || !*a9)
    {
LABEL_21:
      int v26 = 1;
LABEL_22:
      *a13 = v26;
      return;
    }
  }
  else
  {
    if (!a12) {
      goto LABEL_21;
    }
    int v23 = (uint64_t *)v61;
    v59 = v61;
    v60 = v61;
    int v27 = &v62;
    int v22 = (uint64_t **)&v60;
    uint64_t v28 = (uint64_t *)&v59;
  }
  v45 = v27;
  v48 = v28;
  bzero(v61, 0x800uLL);
  v56 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  if (!v20) {
    int v20 = &v17[strlen(v17)];
  }
  if (a11)
  {
    sub_18C8556C0(a2, 1, 1);
    sub_18C8556C0(a1, 2, 1);
    int v29 = v48;
    uint64_t *v48 = (uint64_t)v23;
    *int v22 = v23;
  }
  else
  {
    int v29 = v48;
    if (*(char *)(a1 + 91) >= 1)
    {
      int v44 = sub_18C855B34(a1, a3, a4, 0, a13);
      int v29 = v48;
      if (v44
        || !a12
        && (*(char *)(a1 + 281) & 0x80000000) == 0
        && *v22 == (uint64_t *)*v48
        && !*(unsigned char *)(a2 + 93)
        && (*(char *)(a2 + 282) & 0x80000000) == 0
        && v17 == v20)
      {
        return;
      }
    }
  }
  uint64_t v30 = *(void *)(a2 + 48);
  uint64_t v31 = *(void *)(a1 + 48);
  if ((*(unsigned char *)(*(void *)(v30 + 16) + 69) != 4
     || (unint64_t v32 = *(void (**)(long long *, long long *, int *))(*(void *)(v31 + 32) + 136)) == 0)
    && (*(unsigned char *)(*(void *)(v31 + 16) + 69) != 4
     || (unint64_t v32 = *(void (**)(long long *, long long *, int *))(*(void *)(v30 + 32) + 128)) == 0))
  {
    unint64_t v32 = 0;
  }
  BYTE2(v49) = 0;
  v47 = v32;
  if ((char *)v45 - (char *)v23 <= 64 || v32 == 0) {
    int v34 = v45;
  }
  else {
    int v34 = v23 + 8;
  }
  uint64_t v35 = *a3;
  *((void *)&v49 + 1) = a1;
  v51 = (unsigned char *)v35;
  unint64_t v52 = a4;
  uint64_t v53 = 0;
  LOWORD(v49) = 56;
  BYTE2(v54) = a12;
  v57 = v34;
  uint64_t v58 = 0;
  *((void *)&v54 + 1) = a2;
  *(void *)&long long v55 = v17;
  LOWORD(v54) = 56;
  v46 = (uint64_t *)((char *)v23 + 2);
  *((void *)&v55 + 1) = v20;
  BOOL v36 = v34;
  while (1)
  {
    uint64_t v37 = *v29;
    if ((unint64_t)*v22 >= *v29)
    {
      int v38 = *a13;
      if (*a13 <= 0 && (*(char *)(a1 + 281) & 0x80000000) == 0 && !BYTE2(v49)) {
        goto LABEL_53;
      }
    }
    *(void *)&long long v50 = *v22;
    *((void *)&v50 + 1) = v37;
    sub_18C855BEC((uint64_t)&v49, a13);
    int v38 = *a13;
    if (*a13 >= 1) {
      break;
    }
    int v29 = v48;
LABEL_53:
    uint64_t *v29 = (uint64_t)v23;
    *int v22 = v23;
    if (*(char *)(a2 + 93) < 1)
    {
      if ((const char *)v55 == v20
        && (*(char *)(a2 + 282) & 0x80000000) == 0
        && !*(unsigned char *)(a2 + 64)
        && (!a12 || BYTE2(v49)))
      {
        goto LABEL_92;
      }
      if (!v47 || (*(_DWORD *)(a1 + 208) & 0x80000000) == 0 || *(unsigned char *)(a2 + 282)) {
        goto LABEL_60;
      }
      if (v38 == -127) {
        *a13 = 0;
      }
      v47(&v49, &v54, a13);
      int v38 = *a13;
      if (*a13 == 15) {
        goto LABEL_92;
      }
      int v29 = v48;
      if (v38 < 1)
      {
        if (v38 == -127)
        {
          int v42 = 0;
        }
        else
        {
          if (!a12)
          {
LABEL_108:
            *a5 = (const char *)v55;
            *a3 = (uint64_t)v51;
            return;
          }
          if (*(char *)(a2 + 64) <= 0)
          {
            sub_18C8556C0(a2, 1, 0);
            sub_18C8556C0(a1, 2, 0);
            *a5 = (const char *)v55;
            v43 = v51;
            *a3 = (uint64_t)v51;
            int v38 = *a13;
            goto LABEL_94;
          }
          int v42 = 11;
        }
        *a13 = v42;
        goto LABEL_60;
      }
      if (*(char *)(a2 + 64) > 0)
      {
LABEL_60:
        v56 = v23;
        sub_18C85616C((uint64_t)&v54, a13);
        int v29 = v48;
        v40 = v56;
        uint64_t *v48 = (uint64_t)v56;
        int v38 = *a13;
        if (*a13 == 15)
        {
          *a13 = 0;
          if (a12) {
            goto LABEL_68;
          }
        }
        else
        {
          int v41 = a12;
          if (v38 > 0) {
            goto LABEL_93;
          }
          if (a12)
          {
LABEL_68:
            if ((const char *)v55 == v20 && (*(char *)(a2 + 282) & 0x80000000) == 0 && !*(unsigned char *)(a2 + 93)) {
              BYTE2(v49) = 1;
            }
          }
          else if (v40 == v23)
          {
            goto LABEL_108;
          }
        }
      }
      else
      {
        uint64_t *v48 = (uint64_t)v46;
        *int v22 = v46;
      }
    }
    else
    {
      int v39 = sub_18C8560BC(a2, (_WORD **)v48, v36, 0, a13);
      int v29 = v48;
      if (v39) {
        *a13 = 0;
      }
    }
  }
  *int v22 = (uint64_t *)v50;
LABEL_92:
  int v41 = a12;
LABEL_93:
  *a5 = (const char *)v55;
  v43 = v51;
  *a3 = (uint64_t)v51;
  if (!v41) {
    return;
  }
LABEL_94:
  if (v38 > 0) {
    return;
  }
  if (v43 == (unsigned char *)a4)
  {
    int v26 = -124;
    goto LABEL_22;
  }
  unsigned char *v43 = 0;
  if (*a13 == -124) {
    *a13 = 0;
  }
}

uint64_t ucnv_convert(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, int a4, char *a5, signed int a6, UErrorCode *a7)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a7 || *(int *)a7 > 0) {
    return 0;
  }
  if (a4 < 0 || !a5 || a6 < -1 || !a3 && a4)
  {
    uint64_t v8 = 0;
    *a7 = U_ILLEGAL_ARGUMENT_ERROR;
    return v8;
  }
  if (a6 && ((a6 & 0x80000000) == 0 || *a5))
  {
    memset(v20, 0, sizeof(v20));
    memset(v19, 0, sizeof(v19));
    Converter = ucnv_createConverter(v20, a2, a7);
    if (*(int *)a7 <= 0)
    {
      unsigned int v16 = Converter;
      unint64_t v17 = ucnv_createConverter(v19, a1, a7);
      if (*(int *)a7 < 1)
      {
        int v18 = v17;
        uint64_t v8 = sub_18C8571E8((uint64_t)v17, (uint64_t)v16, a3, a4, a5, a6, (int *)a7);
        ucnv_close(v16);
        ucnv_close(v18);
        return v8;
      }
      ucnv_close(v16);
    }
    return 0;
  }

  return u_terminateChars(a3, a4, 0, (int *)a7);
}

uint64_t sub_18C8571E8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char *__s, unsigned int a6, int *a7)
{
  v23[0] = *MEMORY[0x1E4F143B8];
  int v20 = __s;
  if ((a6 & 0x80000000) != 0)
  {
    size_t v13 = strlen(__s);
    if (v13)
    {
LABEL_3:
      int v14 = &__s[v13];
      bzero(v22, 0x800uLL);
      int v18 = v22;
      unint64_t v19 = v22;
      unint64_t v17 = (unsigned char *)a3;
      if (a4 < 1)
      {
        uint64_t v15 = 0;
        if (!a4) {
          goto LABEL_11;
        }
      }
      else
      {
        ucnv_convertEx(a1, a2, (uint64_t *)&v17, a3 + a4, &v20, v14, v22, &v19, (uint64_t *)&v18, v23, 0, 1, a7);
        uint64_t v15 = (v17 - a3);
      }
      if (*a7 != 15) {
        return v15;
      }
LABEL_11:
      bzero(v21, 0x400uLL);
      do
      {
        *a7 = 0;
        unint64_t v17 = v21;
        ucnv_convertEx(a1, a2, (uint64_t *)&v17, (unint64_t)v22, &v20, v14, v22, &v19, (uint64_t *)&v18, v23, 0, 1, a7);
        uint64_t v15 = v15 + v17 - v21;
      }
      while (*a7 == 15);
      return u_terminateChars(a3, a4, v15, a7);
    }
  }
  else
  {
    size_t v13 = a6;
    if (a6) {
      goto LABEL_3;
    }
  }

  return u_terminateChars(a3, a4, 0, a7);
}

uint64_t ucnv_toAlgorithmic(unsigned int a1, uint64_t a2, uint64_t a3, int a4, char *a5, signed int a6, int *a7)
{
  return sub_18C857424(1, a1, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_18C857424(int a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, char *a6, signed int a7, int *a8)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a8 || *a8 > 0) {
    return 0;
  }
  if (a5 < 0 || !a3 || !a6 || a7 < -1 || !a4 && a5)
  {
    uint64_t v9 = 0;
    *a8 = 1;
    return v9;
  }
  if (a7 && ((a7 & 0x80000000) == 0 || *a6))
  {
    memset(v23, 0, sizeof(v23));
    unint64_t v17 = sub_18C85C0D4(v23, a2, (uint64_t)"", 0, a8);
    uint64_t v9 = 0;
    if (*a8 <= 0)
    {
      int v18 = v17;
      BOOL v19 = a1 == 0;
      if (a1) {
        uint64_t v20 = 1;
      }
      else {
        uint64_t v20 = 2;
      }
      if (a1) {
        uint64_t v21 = (uint64_t)v17;
      }
      else {
        uint64_t v21 = a3;
      }
      if (v19) {
        uint64_t v22 = (uint64_t)v17;
      }
      else {
        uint64_t v22 = a3;
      }
      sub_18C8556C0(a3, v20, 1);
      uint64_t v9 = sub_18C8571E8(v21, v22, a4, a5, a6, a7, a8);
      ucnv_close(v18);
    }
    return v9;
  }

  return u_terminateChars(a4, a5, 0, a8);
}

uint64_t ucnv_fromAlgorithmic(uint64_t a1, unsigned int a2, uint64_t a3, int a4, char *a5, signed int a6, int *a7)
{
  if (a2 < 0x22) {
    return sub_18C857424(0, a2, a1, a3, a4, a5, a6, a7);
  }
  *a7 = 1;
  return 0;
}

uint64_t ucnv_getType(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 16) + 69) == 2) {
    return sub_18C86EDC4(a1);
  }
  else {
    return *(char *)(*(void *)(*(void *)(a1 + 48) + 16) + 69);
  }
}

uint64_t ucnv_getStarters(uint64_t result, uint64_t a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)(*(void *)(result + 48) + 32) + 88);
    if (v3) {
      return v3();
    }
    else {
      *a3 = 1;
    }
  }
  return result;
}

char **ucnv_fixFileSeparator(char **result, _WORD *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = a2;
    if (a2)
    {
      if (a3 >= 1)
      {
        uint64_t result = sub_18C8576F4(result);
        if (result)
        {
          int v5 = *((unsigned __int16 *)result + 4);
          uint64_t v6 = a3;
          do
          {
            if ((unsigned __int16)*v3 == v5) {
              *uint64_t v3 = 92;
            }
            ++v3;
            --v6;
          }
          while (v6);
        }
      }
    }
  }
  return result;
}

char **sub_18C8576F4(char **result)
{
  if (!result) {
    return result;
  }
  int v1 = result;
  int v2 = result[6];
  uint64_t v3 = *(uint64_t (**)(char **))(*((void *)v2 + 4) + 96);
  if (v3)
  {
    uint64_t v4 = (const char *)v3(result);
    if (v4) {
      goto LABEL_6;
    }
    int v2 = v1[6];
  }
  uint64_t v4 = (const char *)(*((void *)v2 + 2) + 4);
LABEL_6:
  uint64_t v5 = 0;
  while (strcmp(v4, (&off_1E55007E8)[v5]))
  {
    v5 += 2;
    if (v5 == 22) {
      return 0;
    }
  }
  return &(&off_1E55007E8)[v5];
}

BOOL ucnv_isAmbiguous(char **a1)
{
  return sub_18C8576F4(a1) != 0;
}

uint64_t ucnv_setFallback(uint64_t result, char a2)
{
  *(unsigned char *)(result + 63) = a2;
  return result;
}

uint64_t ucnv_usesFallback(uint64_t a1)
{
  return *(char *)(a1 + 63);
}

char *ucnv_getInvalidChars(char *result, void *__dst, unsigned char *a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if (result && __dst && a3)
    {
      int v4 = result[90];
      if ((char)*a3 >= v4)
      {
        *a3 = v4;
        if (v4 >= 1) {
          return (char *)memcpy(__dst, result + 96, v4);
        }
        return result;
      }
      int v5 = 8;
    }
    else
    {
      int v5 = 1;
    }
    *a4 = v5;
  }
  return result;
}

UChar *ucnv_getInvalidUChars(UChar *result, UChar *dest, unsigned char *a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if (result && dest && a3)
    {
      int32_t v4 = *((char *)result + 92);
      if ((char)*a3 >= v4)
      {
        *a3 = v4;
        if (v4 >= 1) {
          return u_memcpy(dest, result + 70, v4);
        }
        return result;
      }
      int v5 = 8;
    }
    else
    {
      int v5 = 1;
    }
    *a4 = v5;
  }
  return result;
}

const char *ucnv_detectUnicodeSignature(char *__s, int a2, int *a3, int *a4)
{
  char v14 = -91;
  int __dst = -1515870811;
  if (!a4 || *a4 > 0) {
    return 0;
  }
  if (!__s || a2 <= -2)
  {
    uint64_t result = 0;
    *a4 = 1;
    return result;
  }
  if (a2 == -1) {
    a2 = strlen(__s);
  }
  if (a2 <= 0)
  {
    BOOL v10 = 0;
    int v11 = BYTE2(__dst);
    int v8 = 165;
    int v9 = 165;
  }
  else
  {
    int v7 = a2 - 1;
    if ((a2 - 1) >= 4) {
      int v7 = 4;
    }
    memcpy(&__dst, __s, (v7 + 1));
    int v8 = __dst;
    int v9 = BYTE1(__dst);
    if (__dst == 254 && BYTE1(__dst) == 255)
    {
      if (a3) {
        *a3 = 2;
      }
      return "UTF-16BE";
    }
    BOOL v10 = BYTE1(__dst) == 254;
    if (__dst == 255 && BYTE1(__dst) == 254)
    {
      if (BYTE2(__dst) | HIBYTE(__dst))
      {
        if (a3) {
          *a3 = 2;
        }
        return "UTF-16LE";
      }
      else
      {
        if (a3) {
          *a3 = 4;
        }
        return "UTF-32LE";
      }
    }
    int v11 = BYTE2(__dst);
    if (__dst == 239 && BYTE1(__dst) == 187 && BYTE2(__dst) == 191)
    {
      if (a3) {
        *a3 = 3;
      }
      return "UTF-8";
    }
  }
  if (!v8 && !v9 && v11 == 254 && HIBYTE(__dst) == 255)
  {
    if (a3) {
      *a3 = 4;
    }
    return "UTF-32BE";
  }
  if (v8 != 14) {
    BOOL v10 = 0;
  }
  if (v10 && v11 == 255)
  {
    if (a3) {
      *a3 = 3;
    }
    return "SCSU";
  }
  if (v8 == 251 && v9 == 238 && v11 == 40)
  {
    if (a3) {
      *a3 = 3;
    }
    return "BOCU-1";
  }
  if (v8 == 43 && v9 == 47 && v11 == 118)
  {
    if (HIBYTE(__dst) == 56 && v14 == 45)
    {
      if (a3)
      {
        int v12 = 5;
LABEL_71:
        *a3 = v12;
        return "UTF-7";
      }
      return "UTF-7";
    }
    if (HIBYTE(__dst) <= 0x39u && ((1 << SHIBYTE(__dst)) & 0x300880000000000) != 0)
    {
      if (a3)
      {
        int v12 = 4;
        goto LABEL_71;
      }
      return "UTF-7";
    }
  }
  else if (v8 == 221 && v9 == 115 && v11 == 102 && HIBYTE(__dst) == 115)
  {
    if (a3) {
      *a3 = 4;
    }
    return "UTF-EBCDIC";
  }
  if (!a3) {
    return 0;
  }
  uint64_t result = 0;
  *a3 = 0;
  return result;
}

uint64_t ucnv_fromUCountPending(uint64_t a1, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0xFFFFFFFFLL;
  }
  if (!a1)
  {
    *a2 = 1;
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 208);
  if ((v3 & 0x80000000) != 0)
  {
    int v5 = *(char *)(a1 + 281);
    if (v5 < 0) {
      return -v5;
    }
    else {
      return *(_DWORD *)(a1 + 84) > 0;
    }
  }
  else
  {
    if (v3 < 0x10000) {
      int v4 = 1;
    }
    else {
      int v4 = 2;
    }
    return (v4 + *(char *)(a1 + 281));
  }
}

uint64_t ucnv_toUCountPending(uint64_t a1, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0xFFFFFFFFLL;
  }
  if (!a1)
  {
    *a2 = 1;
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *(char *)(a1 + 282);
  if ((int)result <= 0)
  {
    if ((result & 0x80000000) != 0) {
      return -(int)result;
    }
    else {
      return *(char *)(a1 + 64) & ~(*(char *)(a1 + 64) >> 31);
    }
  }
  return result;
}

uint64_t ucnv_isFixedWidth(uint64_t result, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  if (result)
  {
    unsigned int v2 = *(char *)(*(void *)(*(void *)(result + 48) + 16) + 69);
    if (v2 == 2) {
      unsigned int v2 = sub_18C86EDC4(result);
    }
    uint64_t result = 1;
    BOOL v3 = v2 > 0x1E;
    int v4 = (1 << v2) & 0x44000183;
    if (v3 || v4 == 0) {
      return 0;
    }
  }
  else
  {
    *a2 = 1;
  }
  return result;
}

unint64_t sub_18C857C68(unint64_t result, unsigned int a2, int a3, int a4)
{
  int v4 = a3 - a4;
  if (a3 < 0) {
    int v4 = -1;
  }
  if (v4)
  {
    if (v4 <= 0)
    {
      if (a2)
      {
        unint64_t v6 = result + 4 * a2;
        if (v6 <= result + 4) {
          unint64_t v6 = result + 4;
        }
        return (unint64_t)memset((void *)result, 255, ((v6 + ~result) & 0xFFFFFFFFFFFFFFFCLL) + 4);
      }
    }
    else if (a2)
    {
      int v5 = (_DWORD *)(result + 4 * a2);
      do
      {
        if ((*(_DWORD *)result & 0x80000000) == 0) {
          *(_DWORD *)result += v4;
        }
        result += 4;
      }
      while (result < (unint64_t)v5);
    }
  }
  return result;
}

void sub_18C857CDC(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  memset(__dst, 32, 6);
  unint64_t v6 = uprv_malloc(0x98uLL);
  *(void *)(a1 + 16) = v6;
  if (!v6)
  {
    int v14 = 7;
LABEL_16:
    *a3 = v14;
    return;
  }
  int v7 = v6;
  memset(v24, 0, sizeof(v24));
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  LODWORD(v21[0]) = 40;
  int v8 = *(unsigned __int8 *)(a2 + 8);
  BYTE8(v21[0]) = *(unsigned char *)(a2 + 8);
  *unint64_t v6 = 0u;
  v6[1] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  _OWORD v6[4] = 0u;
  v6[5] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[8] = 0u;
  *((void *)v6 + 18) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  int v9 = *(const char **)(a2 + 32);
  if (!v9)
  {
    *((_DWORD *)v6 + 27) = *(_DWORD *)(a2 + 12) & 0xF;
    goto LABEL_15;
  }
  strncpy(__dst, v9, 6uLL);
  int v10 = __dst[0];
  unsigned int v11 = *(_DWORD *)(a2 + 12) & 0xF;
  *((_DWORD *)v7 + 27) = v11;
  if (v10 != 107)
  {
    if (v10 == 106)
    {
      if ((__dst[1] == 112 || __dst[1] == 97) && (__dst[2] == 95 || !__dst[2]) && v11 < 5)
      {
        if (v11 > 1)
        {
          *((void *)v7 + 2) = sub_18C85B8A4("ISO8859_7", v24, v21, a3);
          *((void *)v7 + 4) = sub_18C85B8A4("Shift-JIS", v24, v21, a3);
          *((void *)v7 + 5) = sub_18C85B8A4("jisx-212", v24, v21, a3);
          *((void *)v7 + 6) = sub_18C85B8A4("ibm-5478", v24, v21, a3);
          int v12 = "ksc_5601";
          uint64_t v13 = 7;
        }
        else
        {
          *((void *)v7 + 4) = sub_18C85B8A4("Shift-JIS", v24, v21, a3);
          if (!v11)
          {
LABEL_39:
            unint64_t v17 = &unk_1E55009C0;
            *(void *)(a1 + 48) = &unk_1E55009C0;
            strcpy((char *)v7 + 143, "ja");
            strcpy((char *)v7 + 113, "ISO_2022,locale=ja,version=");
            int v18 = (char *)v7 + strlen((const char *)v7 + 113) + 113;
            *int v18 = *((unsigned char *)v7 + 108) + 48;
            v18[1] = 0;
            goto LABEL_50;
          }
          int v12 = "jisx-212";
          uint64_t v13 = 5;
        }
        *((void *)v7 + v13) = sub_18C85B8A4((unsigned __int8 *)v12, v24, v21, a3);
        goto LABEL_39;
      }
      goto LABEL_15;
    }
    if ((v10 == 122 && __dst[1] == 104 || v10 == 99 && __dst[1] == 110) && (__dst[2] == 95 || !__dst[2]) && v11 < 3)
    {
      *((void *)v7 + 1) = sub_18C85B8A4("ibm-5478", v24, v21, a3);
      if (v11 == 1) {
        *((void *)v7 + 2) = sub_18C85B8A4("iso-ir-165", v24, v21, a3);
      }
      *((void *)v7 + 3) = sub_18C85B8A4("cns-11643-1992", v24, v21, a3);
      *(void *)(a1 + 48) = &unk_1E5500C10;
      strcpy((char *)v7 + 143, "cn");
      if (v11)
      {
        if (v11 == 1)
        {
          *((_DWORD *)v7 + 27) = 1;
          unsigned int v16 = "ISO_2022,locale=zh,version=1";
        }
        else
        {
          *((_DWORD *)v7 + 27) = 2;
          unsigned int v16 = "ISO_2022,locale=zh,version=2";
        }
        *(_OWORD *)((char *)v7 + 113) = *(_OWORD *)v16;
        *(_OWORD *)((char *)v7 + 126) = *(_OWORD *)(v16 + 13);
      }
      else
      {
        *((_DWORD *)v7 + 27) = 0;
        strcpy((char *)v7 + 113, "ISO_2022,locale=zh,version=0");
      }
      unint64_t v17 = &unk_1E5500C10;
      goto LABEL_50;
    }
LABEL_15:
    int v14 = 2;
    goto LABEL_16;
  }
  if (__dst[1] != 114 && __dst[1] != 111 || __dst[2] != 95 && __dst[2] || v11 >= 2) {
    goto LABEL_15;
  }
  if (v11 == 1)
  {
    uint64_t v15 = "icu-internal-25546";
  }
  else
  {
    *((_DWORD *)v7 + 27) = 0;
    uint64_t v15 = "ibm-949";
  }
  if (v8)
  {
    sub_18C85BFD4((unsigned __int8 *)v15, a3);
    uprv_free(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    return;
  }
  BOOL v19 = ucnv_open((unsigned __int8 *)v15, a3);
  *((void *)v7 + 10) = v19;
  if (*(int *)a3 >= 1) {
    goto LABEL_52;
  }
  if (v11 == 1)
  {
    strcpy((char *)v7 + 113, "ISO_2022,locale=ko,version=1");
    **(_DWORD **)(a1 + 40) = **((_DWORD **)v19 + 5);
    BOOL v19 = (_OWORD *)*((void *)v7 + 10);
    *(unsigned char *)(a1 + 89) = *((unsigned char *)v19 + 89);
  }
  else
  {
    strcpy((char *)v7 + 113, "ISO_2022,locale=ko,version=0");
  }
  int v20 = *((_DWORD *)v7 + 27);
  if (v20 == 1)
  {
    *((void *)v19 + 9) = 0;
    *((unsigned char *)v19 + 64) = 0;
  }
  if (!*(unsigned char *)(a1 + 91))
  {
    *(unsigned char *)(a1 + 91) = 4;
    *(_DWORD *)(a1 + 104) = 1126769691;
  }
  if (v20 == 1) {
    *((void *)v19 + 10) = 1;
  }
  unint64_t v17 = &unk_1E5500AE8;
  *(void *)(a1 + 48) = &unk_1E5500AE8;
  strcpy((char *)v7 + 143, "ko");
LABEL_50:
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(v17[2] + 71);
  if (*(int *)a3 > 0 || *(unsigned char *)(a2 + 8)) {
LABEL_52:
  }
    sub_18C8581E8(a1);
}

void sub_18C8581E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    for (uint64_t i = 0; i != 80; i += 8)
    {
      uint64_t v4 = *(void *)(v1 + i);
      if (v4) {
        sub_18C85B7D8(v4);
      }
    }
    ucnv_close(*(void **)(v1 + 80));
    if (!*(unsigned char *)(a1 + 62))
    {
      uprv_free(*(void **)(a1 + 16));
      *(void *)(a1 + 16) = 0;
    }
  }
}

double sub_18C858250(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (a2 > 1)
  {
    *(_WORD *)(v2 + 102) = 0;
    *(_DWORD *)(v2 + 98) = 0;
    if (*(unsigned char *)(v2 + 143) != 107) {
      return result;
    }
  }
  else
  {
    *(_WORD *)(v2 + 96) = 0;
    *(_DWORD *)(v2 + 92) = 0;
    *(_DWORD *)(v2 + 104) = 0;
    *(unsigned char *)(v2 + 112) = 0;
    if (a2 == 1)
    {
      if (*(unsigned char *)(v2 + 143) == 107 && *(_DWORD *)(v2 + 108) == 1)
      {
        uint64_t v3 = *(void *)(v2 + 80);
        *(void *)(v3 + 72) = 0;
        *(unsigned char *)(v3 + 64) = 0;
      }
      return result;
    }
    *(_WORD *)(v2 + 102) = 0;
    *(_DWORD *)(v2 + 98) = 0;
    if (*(unsigned char *)(v2 + 143) != 107) {
      return result;
    }
    if (*(_DWORD *)(v2 + 108) == 1)
    {
      uint64_t v4 = *(void *)(v2 + 80);
      *(void *)(v4 + 72) = 0;
      *(unsigned char *)(v4 + 64) = 0;
    }
  }
  if (!*(unsigned char *)(a1 + 91))
  {
    *(unsigned char *)(a1 + 91) = 4;
    *(void *)&double result = 1126769691;
    *(_DWORD *)(a1 + 104) = 1126769691;
  }
  if (*(_DWORD *)(v2 + 108) == 1)
  {
    *(void *)&double result = 1;
    *(void *)(*(void *)(v2 + 80) + 80) = 1;
  }
  return result;
}

uint64_t sub_18C85831C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return v1 + 113;
  }
  else {
    return 0;
  }
}

void *sub_18C858330(void *a1, int a2, int *a3)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[1];
  uint64_t v6 = *(void *)(v5 + 16);
  v20[0] = 0;
  int v7 = *(char **)(v5 + 40);
  int v8 = *(char *)(v6 + 143);
  if (v8 == 99)
  {
    int v9 = (char *)v20;
    if (!*(unsigned char *)(v6 + 102)) {
      goto LABEL_14;
    }
    *(unsigned char *)(v6 + 102) = 0;
LABEL_13:
    int v9 = (char *)v20 + 1;
    LOBYTE(v20[0]) = 15;
    goto LABEL_14;
  }
  if (v8 != 107)
  {
    if (v8 != 106)
    {
      int v9 = (char *)v20;
      return ucnv_cbFromUWriteBytes(a1, (char *)v20, v9 - v20, a2, a3);
    }
    int v9 = (char *)v20;
    if (*(unsigned char *)(v6 + 102) == 1)
    {
      *(unsigned char *)(v6 + 102) = 0;
      int v9 = (char *)v20 + 1;
      LOBYTE(v20[0]) = 15;
    }
    if (*(unsigned char *)(v6 + 98)) {
      BOOL v10 = *(unsigned char *)(v6 + 98) == 3;
    }
    else {
      BOOL v10 = 1;
    }
    if (!v10)
    {
      *(unsigned char *)(v6 + 98) = 0;
      *int v9 = 27;
      *(_WORD *)(v9 + 1) = 16936;
      v9 += 3;
    }
LABEL_14:
    *int v9 = *v7;
    LODWORD(v9) = v9 + 1;
    return ucnv_cbFromUWriteBytes(a1, (char *)v20, v9 - v20, a2, a3);
  }
  int v11 = *(unsigned __int8 *)(v5 + 89);
  if (!*(_DWORD *)(v6 + 108))
  {
    int v18 = *(_DWORD *)(v5 + 80);
    if (v11 != 1)
    {
      BOOL v19 = (char *)v20;
      if (!v18)
      {
        *(_DWORD *)(v5 + 80) = 1;
        BOOL v19 = (char *)v20 + 1;
        LOBYTE(v20[0]) = 14;
      }
      *BOOL v19 = *v7;
      LODWORD(v9) = v19 + 2;
      v19[1] = v7[1];
      return ucnv_cbFromUWriteBytes(a1, (char *)v20, v9 - v20, a2, a3);
    }
    int v9 = (char *)v20;
    if (!v18) {
      goto LABEL_14;
    }
    *(_DWORD *)(v5 + 80) = 0;
    goto LABEL_13;
  }
  uint64_t v12 = *(void *)(v6 + 80);
  uint64_t v13 = *(void *)(v12 + 40);
  char v14 = *(unsigned char *)(v12 + 89);
  *(void *)(v12 + 40) = v7;
  *(unsigned char *)(v12 + 89) = v11;
  a1[1] = v12;
  *(_DWORD *)(v12 + 84) = *(_DWORD *)(v5 + 84);
  double result = (void *)ucnv_cbFromUWriteSub((uint64_t)a1, 0, a3);
  uint64_t v16 = *(void *)(v6 + 80);
  *(_DWORD *)(v5 + 84) = *(_DWORD *)(v16 + 84);
  a1[1] = v5;
  *(void *)(v16 + 40) = v13;
  *(unsigned char *)(v16 + 89) = v14;
  if (*a3 == 15)
  {
    int v17 = *(char *)(v16 + 91);
    if (v17 >= 1)
    {
      double result = memcpy((void *)(v5 + 104), (const void *)(v16 + 104), *(unsigned __int8 *)(v16 + 91));
      uint64_t v16 = *(void *)(v6 + 80);
      LOBYTE(v17) = *(unsigned char *)(v16 + 91);
    }
    *(unsigned char *)(v5 + 91) = v17;
    *(unsigned char *)(v16 + 91) = 0;
  }
  return result;
}

uint64_t sub_18C858538(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (!*a3)
  {
    uint64_t v4 = 0;
    *a3 = 728;
    return v4;
  }
  uint64_t v4 = a2;
  int v18 = 0;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(v6 + 144);
  long long v8 = *(_OWORD *)(v6 + 96);
  long long v9 = *(_OWORD *)(v6 + 128);
  *(_OWORD *)(a2 + 688) = *(_OWORD *)(v6 + 112);
  *(_OWORD *)(a2 + 704) = v9;
  *(_OWORD *)(a2 + 672) = v8;
  *(void *)(a2 + 720) = v7;
  long long v10 = *(_OWORD *)(v6 + 16);
  *(_OWORD *)(a2 + 576) = *(_OWORD *)v6;
  *(_OWORD *)(a2 + 592) = v10;
  long long v11 = *(_OWORD *)(v6 + 32);
  long long v12 = *(_OWORD *)(v6 + 48);
  long long v13 = *(_OWORD *)(v6 + 80);
  *(_OWORD *)(a2 + 640) = *(_OWORD *)(v6 + 64);
  *(_OWORD *)(a2 + 656) = v13;
  *(_OWORD *)(a2 + 608) = v11;
  *(_OWORD *)(a2 + 624) = v12;
  *(void *)(a2 + 16) = a2 + 576;
  *(unsigned char *)(a2 + 62) = 1;
  char v14 = *(void (***)(void, void, void, void, void, void, void))(v6 + 80);
  if (v14)
  {
    int v18 = 288;
    *(void *)(a2 + 656) = ucnv_safeClone(v14, a2 + 288, &v18, a4);
    if (*a4 > 0) {
      return 0;
    }
  }
  for (uint64_t i = 0; i != 80; i += 8)
  {
    uint64_t v17 = *(void *)(v6 + i);
    if (v17) {
      sub_18C85B83C(v17);
    }
  }
  return v4;
}

uint64_t sub_18C85862C(uint64_t result, uint64_t *a2, uint64_t a3, int *a4)
{
  if (*a4 > 0) {
    return result;
  }
  uint64_t v7 = *(void *)(result + 16);
  int v8 = *(char *)(v7 + 143);
  if (v8 <= 106)
  {
    if (v8 != 99)
    {
      if (v8 == 106)
      {
        ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 165);
        ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 8254);
        uint64_t v9 = *(_DWORD *)(v7 + 108) >= 2u ? 255 : 127;
        ((void (*)(uint64_t, void, uint64_t))a2[2])(*a2, 0, v9);
        int v10 = *(_DWORD *)(v7 + 108);
        BOOL v11 = v10 == 3 || a3 == 1;
        if (v11 || v10 == 4) {
          ((void (*)(uint64_t, uint64_t, uint64_t))a2[2])(*a2, 65377, 65439);
        }
      }
      goto LABEL_21;
    }
LABEL_19:
    ((void (*)(uint64_t, void, uint64_t))a2[2])(*a2, 0, 127);
    goto LABEL_21;
  }
  if (v8 != 107)
  {
    if (v8 != 122) {
      goto LABEL_21;
    }
    goto LABEL_19;
  }
  (*(void (**)(void))(*(void *)(*(void *)(*(void *)(v7 + 80) + 48) + 32) + 120))();
LABEL_21:
  for (uint64_t i = 0; i != 80; i += 8)
  {
    uint64_t v14 = *(void *)(v7 + i);
    if (v14)
    {
      int v15 = *(unsigned __int8 *)(v7 + 143);
      if (i == 32 && v15 == 106)
      {
        int v16 = 3;
      }
      else if ((v15 == 122 || v15 == 99) && i == 24 && !*(_DWORD *)(v7 + 108))
      {
        int v16 = 2;
      }
      else
      {
        int v16 = 4 * (i == 56);
      }
      sub_18C86BE98(v14, a2, a3, v16, a4);
    }
  }
  ((void (*)(uint64_t, uint64_t))a2[4])(*a2, 14);
  ((void (*)(uint64_t, uint64_t))a2[4])(*a2, 15);
  ((void (*)(uint64_t, uint64_t))a2[4])(*a2, 27);
  uint64_t v17 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[5];
  uint64_t v18 = *a2;

  return v17(v18, 128, 159);
}

uint64_t sub_18C858818(void *a1, int *a2)
{
  __int16 v46 = 0;
  uint64_t v6 = a1 + 1;
  uint64_t result = a1[1];
  uint64_t v5 = (unsigned __int8 *)v6[1];
  v45 = v5;
  unint64_t v7 = a1[3];
  int v8 = (_WORD *)a1[4];
  uint64_t v9 = *(void *)(result + 16);
  int v10 = (unsigned char *)(v9 + 92);
  if (!*(_DWORD *)(v9 + 104))
  {
    BOOL v13 = *(unsigned char *)(result + 64) != 1 || (unint64_t)v5 >= v7;
    if (v13 || (unint64_t)v8 >= a1[5]) {
      goto LABEL_20;
    }
    int v14 = *(unsigned __int8 *)(result + 65);
    *(unsigned char *)(result + 64) = 0;
    int v15 = (char)v10[*(char *)(v9 + 96)];
    goto LABEL_64;
  }
LABEL_2:
  char v11 = *(unsigned char *)(result + 64);
  uint64_t result = (uint64_t)sub_18C859978((void *)result, (unint64_t *)&v45, v7, 1, a2);
  if (*(_DWORD *)(v9 + 108))
  {
    int v12 = *a2;
    goto LABEL_5;
  }
  int v12 = *a2;
  if (*(_DWORD *)(v9 + 104))
  {
LABEL_5:
    if (v12 >= 1) {
      goto LABEL_18;
    }
    goto LABEL_6;
  }
  if (v12 > 0) {
    goto LABEL_18;
  }
  if (*(unsigned char *)(v9 + 112))
  {
    *a2 = 18;
    uint64_t v16 = a1[1];
    *(_DWORD *)(v16 + 284) = 2;
    *(unsigned char *)(v16 + 64) = v11 + (_BYTE)v45 - (_BYTE)v5;
LABEL_18:
    a1[4] = v8;
    a1[2] = v45;
    *(unsigned char *)(v9 + 112) = 0;
    return result;
  }
LABEL_6:
  if (!*(_DWORD *)(v9 + 104)) {
    *(unsigned char *)(v9 + 112) = 1;
  }
  uint64_t v5 = v45;
LABEL_20:
  if ((unint64_t)v5 >= v7) {
    goto LABEL_32;
  }
  unint64_t v19 = v7 - (void)v5;
  while (2)
  {
    if ((unint64_t)v8 >= a1[5])
    {
      int v23 = 15;
      goto LABEL_31;
    }
    uint64_t v20 = *v5;
    unsigned __int8 v21 = *v5;
    switch(*v5)
    {
      case 0xAu:
      case 0xDu:
        v45 = v5 + 1;
        int v15 = *v10;
        if (*v10 && v15 != 3)
        {
          LOBYTE(v15) = 0;
          *int v10 = 0;
        }
        *(unsigned char *)(v9 + 94) = 0;
        *(unsigned char *)(v9 + 96) = 0;
        *(unsigned char *)(v9 + 112) = 0;
        goto LABEL_46;
      case 0xBu:
      case 0xCu:
        goto LABEL_40;
      case 0xEu:
        if (*(_DWORD *)(v9 + 108) != 3)
        {
          v45 = ++v5;
          *(unsigned char *)(v9 + 112) = 0;
          LODWORD(v20) = 14;
          goto LABEL_52;
        }
        *(unsigned char *)(v9 + 93) = 8;
        char v22 = 1;
        goto LABEL_28;
      case 0xFu:
        if (*(_DWORD *)(v9 + 108) == 3)
        {
          char v22 = 0;
LABEL_28:
          *(unsigned char *)(v9 + 96) = v22;
          ++v5;
          if (!--v19)
          {
            uint64_t v5 = (unsigned __int8 *)v7;
            goto LABEL_32;
          }
          continue;
        }
        v45 = ++v5;
        *(unsigned char *)(v9 + 112) = 0;
        LODWORD(v20) = 15;
LABEL_52:
        uint64_t result = 0xFFFFLL;
LABEL_89:
        if (result <= 0xFFFD)
        {
          uint64_t v35 = a1[6];
          if (v35)
          {
            if (v20 >= 0x100) {
              int v36 = -2;
            }
            else {
              int v36 = -1;
            }
            *(_DWORD *)(v35 + 2 * ((void)v8 - a1[4])) = v36 + v5 - *((_DWORD *)a1 + 4);
          }
          *v8++ = result;
          goto LABEL_20;
        }
        if (result >= 0x10000)
        {
          *int v8 = ((result + 67043328) >> 10) - 10240;
          uint64_t v37 = a1[6];
          if (v37)
          {
            if (v20 >= 0x100) {
              int v38 = -2;
            }
            else {
              int v38 = -1;
            }
            int v39 = v38 + v5 - *((_DWORD *)a1 + 4);
            uint64_t v40 = a1[4];
            unint64_t v41 = a1[5];
            *(_DWORD *)(v37 + 2 * ((void)v8 - v40)) = v39;
            int v42 = v8 + 1;
            if ((unint64_t)(v8 + 1) < v41)
            {
              *int v42 = result & 0x3FF | 0xDC00;
              *(_DWORD *)(v37 + 2 * ((void)v42 - v40)) = v39;
LABEL_105:
              v8 += 2;
              goto LABEL_20;
            }
          }
          else
          {
            int v42 = v8 + 1;
            if ((unint64_t)(v8 + 1) < a1[5])
            {
              *int v42 = result & 0x3FF | 0xDC00;
              goto LABEL_105;
            }
          }
          uint64_t v17 = a1[1];
          uint64_t v18 = *(char *)(v17 + 93);
          *(unsigned char *)(v17 + 93) = v18 + 1;
          *(_WORD *)(v17 + 2 * v18 + 144) = result & 0x3FF | 0xDC00;
          int v8 = v42;
          goto LABEL_20;
        }
        v43 = (unsigned char *)a1[1];
        if (v20 < 0x100)
        {
          char v44 = 1;
        }
        else
        {
          v43[66] = v20;
          LODWORD(v20) = v20 >> 8;
          char v44 = 2;
        }
        v43[65] = v20;
        v43[64] = v44;
        if (result == 65534) {
          int v23 = 10;
        }
        else {
          int v23 = 12;
        }
LABEL_31:
        *a2 = v23;
LABEL_32:
        a1[4] = v8;
        a1[2] = v5;
        return result;
      default:
        if (v20 != 27)
        {
LABEL_40:
          v45 = v5 + 1;
          *(unsigned char *)(v9 + 112) = 0;
          uint64_t v24 = *(char *)(v9 + 96);
          LOBYTE(v15) = v10[v24];
          if (((char)v20 + 95) <= 0x3E && *(_DWORD *)(v9 + 108) == 4 && (v15 & 0xFC) != 4)
          {
            uint64_t result = (v20 + 65216);
            if ((int)v24 >= 2) {
              *(unsigned char *)(v9 + 96) = *(unsigned char *)(v9 + 97);
            }
            ++v5;
            goto LABEL_89;
          }
LABEL_46:
          int v15 = (char)v15;
          ++v5;
          switch((char)v15)
          {
            case 0:
              if ((v20 & 0x80u) != 0) {
                uint64_t result = 0xFFFFLL;
              }
              else {
                uint64_t result = v20;
              }
              goto LABEL_89;
            case 1:
              *(unsigned char *)(v9 + 96) = *(unsigned char *)(v9 + 97);
              if ((v20 & 0x80u) != 0) {
                uint64_t result = 0xFFFFLL;
              }
              else {
                uint64_t result = (v20 + 128);
              }
              goto LABEL_89;
            case 2:
              uint64_t result = 0xFFFFLL;
              if (((char)v20 & 0x80000000) == 0) {
                uint64_t result = *(unsigned __int16 *)(*(void *)(*(void *)(v9 + 16) + 56) + 4 * (v21 ^ 0x80u));
              }
              *(unsigned char *)(v9 + 96) = *(unsigned char *)(v9 + 97);
              goto LABEL_89;
            case 3:
              uint64_t result = 0xFFFFLL;
              if (((char)v20 & 0x80000000) == 0)
              {
                if ((char)v20 >= 0x5C)
                {
                  if (v20 == 126)
                  {
                    uint64_t result = 8254;
                  }
                  else if (v20 == 92)
                  {
                    uint64_t result = 165;
                  }
                  else
                  {
                    uint64_t result = v20;
                  }
                }
                else
                {
                  uint64_t result = v20;
                }
              }
              goto LABEL_89;
            case 8:
              if (((char)v20 - 33) >= 0x3F) {
                uint64_t result = 0xFFFFLL;
              }
              else {
                uint64_t result = (v20 + 65344);
              }
              goto LABEL_89;
            default:
              if ((unint64_t)v5 >= v7)
              {
                *(unsigned char *)(a1[1] + 65) = v21;
                *(unsigned char *)(a1[1] + 64) = 1;
                goto LABEL_32;
              }
              int v14 = v20;
              break;
          }
LABEL_64:
          unsigned int v25 = *v5;
          LODWORD(v20) = v25 | (v14 << 8);
          if ((((_BYTE)v14 - 33) & 0xFEu) > 0x5D || (v25 - 33) > 0x5Du)
          {
            uint64_t result = 0xFFFFLL;
            if ((v25 - 33) >= 0x5Eu
              && (v25 <= 0x1F ? (BOOL v34 = ((1 << v25) & 0x800C000) == 0) : (BOOL v34 = 1), v34))
            {
              v45 = ++v5;
              LODWORD(v20) = v20 + 0x10000;
            }
            else
            {
              LODWORD(v20) = v14;
            }
            goto LABEL_89;
          }
          v45 = ++v5;
          if (v15 == 7)
          {
            unsigned int v26 = v20 + 32896;
          }
          else
          {
            unsigned int v26 = v25 | (v14 << 8);
            if (v15 == 4)
            {
              if (v25 < 0x60) {
                char v27 = 31;
              }
              else {
                char v27 = 32;
              }
              if ((v14 & 1) == 0) {
                char v27 = 126;
              }
              unsigned __int8 v28 = (v14 & 1) + v14;
              unsigned int v29 = v28;
              int v30 = (char)v28;
              char v31 = v25 + v27;
              v28 >>= 1;
              char v32 = v28 + 112;
              char v33 = v28 - 80;
              if (v30 < 0) {
                char v33 = 0;
              }
              if (v29 < 0x60) {
                char v33 = v32;
              }
              LOBYTE(v46) = v33;
              HIBYTE(v46) = v31;
              goto LABEL_88;
            }
          }
          __int16 v46 = bswap32(v26) >> 16;
LABEL_88:
          uint64_t result = sub_18C86D39C(*(void *)(v9 + 8 * v15), (uint64_t)&v46, 2);
          goto LABEL_89;
        }
        v45 = v5;
        uint64_t result = a1[1];
        goto LABEL_2;
    }
  }
}

unint64_t sub_18C858E34(unint64_t result, uint64_t a2)
{
  v91 = (int *)a2;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  v115[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(result + 8);
  uint64_t v4 = *(unsigned __int16 **)(result + 16);
  uint64_t v6 = *(_WORD **)(result + 32);
  unint64_t v96 = result;
  unint64_t v97 = *(void *)(result + 24);
  unint64_t v7 = *(void *)(result + 40);
  v111 = *(_DWORD **)(result + 48);
  v115[0] = 0;
  __int16 v114 = 0;
  uint64_t v113 = 0;
  uint64_t v8 = *(void *)(v5 + 16);
  uint64_t v9 = (unsigned char *)(v8 + 98);
  LODWORD(a2) = *(_DWORD *)(v5 + 84);
  unint64_t v98 = v7;
  if (a2) {
    BOOL v10 = (unint64_t)v6 >= v7;
  }
  else {
    BOOL v10 = 1;
  }
  uint64_t v95 = v5;
  uint64_t v102 = *(void *)(v5 + 16);
  v103 = (unsigned char *)(v8 + 98);
  if (v10) {
    goto LABEL_6;
  }
LABEL_10:
  if ((unint64_t)v4 >= v97)
  {
    *(_DWORD *)(v5 + 84) = a2;
LABEL_144:
    if (*v91 <= 0
      && (*(unsigned char *)(v8 + 102) || *v9)
      && *(unsigned char *)(v96 + 2)
      && (unint64_t)v4 >= v97
      && !*(_DWORD *)(v5 + 84))
    {
      if (*(unsigned char *)(v8 + 102))
      {
        LOBYTE(v115[0]) = 15;
        *(unsigned char *)(v8 + 102) = 0;
        unsigned int v67 = 1;
      }
      else
      {
        unsigned int v67 = 0;
      }
      if (*v9)
      {
        unint64_t v87 = (unint64_t)v115 | v67;
        *(unsigned char *)(v87 + 2) = 66;
        *(_WORD *)unint64_t v87 = 10267;
        v67 += 3;
        *uint64_t v9 = 0;
      }
      uint64_t v88 = *(void *)(v96 + 16);
      unint64_t v89 = ((unint64_t)v4 - v88) >> 1;
      unsigned int v90 = v89 - 1;
      if ((int)v89 < 1)
      {
        unsigned int v90 = -1;
      }
      else if ((*(_WORD *)(v88 + 2 * v90) & 0xFC00) == 0xDC00 {
             && (v89 == 1 || (*(_WORD *)(v88 + 2 * (v89 - 2)) & 0xFC00) == 0xD800))
      }
      {
        unsigned int v90 = v89 - 2;
      }
      v112 = v6;
      uint64_t result = sub_18C85D210(v5, (char *)v115, v67, &v112, v98, &v111, v90, v91);
      uint64_t v6 = v112;
    }
    goto LABEL_188;
  }
  int v12 = *v4;
  if ((v12 & 0xFC00) != 0xDC00)
  {
LABEL_135:
    int v66 = 12;
    goto LABEL_136;
  }
  ++v4;
  a2 = (v12 + (a2 << 10) - 56613888);
  *(_DWORD *)(v5 + 84) = 0;
LABEL_13:
  if ((int)a2 <= 31 && ((1 << a2) & 0x800C000) != 0) {
    goto LABEL_135;
  }
  if (!v2)
  {
    unsigned int v14 = 0;
    uint64_t v15 = *(unsigned int *)(v8 + 108);
    int v16 = word_18CA7F504[v15];
    if ((v15 - 3) <= 1)
    {
      LOBYTE(v113) = 8;
      unsigned int v14 = 1;
    }
    char v17 = *(unsigned char *)(v8 + 98);
    uint64_t v2 = v14 + 1;
    *(unsigned char *)((unint64_t)&v113 | v14) = v17;
    unsigned int v18 = v16 & ~(1 << v17) & 0xFFFFFEFF;
    char v19 = *(unsigned char *)(v8 + 100);
    if (v19)
    {
      *(unsigned char *)((unint64_t)&v113 | v2) = v19;
      v18 &= (unsigned __int16)~(unsigned __int16)(1 << v19);
      uint64_t v2 = v14 | 2;
    }
    for (uint64_t i = 0; i != 9; ++i)
    {
      int v21 = dword_18CA7F87C[i];
      if (((1 << v21) & v18) != 0)
      {
        *((unsigned char *)&v113 + (int)v2) = v21;
        v18 &= (unsigned __int16)~(unsigned __int16)(1 << v21);
        uint64_t v2 = (v2 + 1);
      }
    }
  }
  if ((int)v2 < 1) {
    goto LABEL_134;
  }
  v100 = v6;
  v101 = v4;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  int v25 = 0;
  uint64_t v26 = *(unsigned __int8 *)(v5 + 63);
  uint64_t v27 = (uint64_t)(int)a2 >> 10;
  unsigned int v28 = (a2 >> 4) & 0x3F;
  int v29 = a2 & 0xF;
  int v30 = 1 << (a2 & 0xF | 0x10);
  unsigned int v104 = a2 - 57344;
  unsigned int v99 = a2 - 983040;
  uint64_t v31 = (a2 - 65377);
  unsigned int v93 = a2 - 65216;
  unsigned int v92 = a2 - 65344;
  uint64_t v32 = (a2 - 160);
  unsigned int v94 = a2 - 128;
  unint64_t v33 = v2;
  uint64_t v110 = a2;
  int v108 = v29;
  int v109 = v30;
  uint64_t v107 = v2;
  unsigned int v106 = v28;
  unint64_t v105 = v2;
  while (2)
  {
    LODWORD(v112) = 0;
    uint64_t v34 = *((unsigned __int8 *)&v113 + v22);
    uint64_t v35 = *((char *)&v113 + v22);
    switch(*((unsigned char *)&v113 + v22))
    {
      case 0:
        if ((int)a2 >= 128) {
          goto LABEL_128;
        }
        LODWORD(v23) = 0;
        uint64_t v3 = a2;
        goto LABEL_142;
      case 1:
        if (v32 >= 0x60) {
          goto LABEL_128;
        }
        LODWORD(v23) = 2;
        uint64_t v4 = v101;
        uint64_t v5 = v95;
        uint64_t v9 = v103;
        uint64_t v3 = v94;
        goto LABEL_154;
      case 2:
        uint64_t v36 = *(void *)(v8 + 8 * v35);
        if ((int)a2 >= 0x10000 && (*(unsigned char *)(v36 + 253) & 1) == 0) {
          goto LABEL_128;
        }
        unsigned int v37 = *(unsigned __int16 *)(*(void *)(v36 + 232)
                                  + 2
                                  * (v29
                                   + *(unsigned __int16 *)(*(void *)(v36 + 88)
                                                                       + 2
                                                                       * (v28
                                                                        + *(unsigned __int16 *)(*(void *)(v36 + 88)
                                                                                              + 2 * v27)))));
        if (v37 <= 0xEFF)
        {
          if ((_BYTE)v26)
          {
            if (v37 <= 0x7FF) {
              goto LABEL_128;
            }
          }
          else if (v37 < 0xC00)
          {
            uint64_t v26 = 0;
            goto LABEL_128;
          }
          int v38 = -1;
        }
        else
        {
          int v38 = 1;
        }
        if (v25) {
          BOOL v61 = v37 > 0xEFF;
        }
        else {
          BOOL v61 = 1;
        }
        if (v61 && v37 >= 0xA0u)
        {
          uint64_t v26 = 0;
          uint64_t v3 = v37 - 128;
          uint64_t v23 = 2;
          goto LABEL_126;
        }
        goto LABEL_128;
      case 3:
        if (a2 > 0x7F)
        {
          if (a2 == 165)
          {
            uint64_t v3 = 92;
            goto LABEL_152;
          }
          if (a2 == 8254)
          {
            LODWORD(v23) = 0;
            uint64_t v3 = 126;
            goto LABEL_142;
          }
        }
        else if (a2 != 92 && a2 != 126)
        {
          uint64_t v3 = a2;
LABEL_152:
          uint64_t v4 = v101;
          LODWORD(v23) = 0;
          goto LABEL_153;
        }
        goto LABEL_128;
      case 4:
        uint64_t v40 = *(void *)(v8 + 8 * v35);
        if ((int)a2 >= 0x10000 && (*(unsigned char *)(v40 + 253) & 1) == 0) {
          goto LABEL_73;
        }
        unsigned int v41 = *(unsigned __int16 *)(*(void *)(v40 + 232)
                                  + 2
                                  * (v29 & 0xFFF0000F | (16
                                                       * (unsigned __int16)*(_DWORD *)(*(void *)(v40 + 88)
                                                                                     + 4
                                                                                     * (v28
                                                                                      + *(unsigned __int16 *)(*(void *)(v40 + 88) + 2 * v27))))));
        if (v41 >= 0x100) {
          uint64_t result = 4294967294;
        }
        else {
          uint64_t result = 0xFFFFFFFFLL;
        }
        if ((*(_DWORD *)(*(void *)(v40 + 88) + 4 * (v28 + *(unsigned __int16 *)(*(void *)(v40 + 88) + 2 * v27))) & v30) == 0)
        {
          if (((_BYTE)v26 || v104 >> 8 < 0x19 || !(v99 >> 17))
            && *(_WORD *)(*(void *)(v40 + 232)
                        + 2
                        * (v29 & 0xFFF0000F | (16
                                             * (unsigned __int16)*(_DWORD *)(*(void *)(v40 + 88)
                                                                           + 4
                                                                           * (v28
                                                                            + *(unsigned __int16 *)(*(void *)(v40 + 88)
                                                                                                  + 2 * v27)))))))
          {
            LODWORD(v112) = *(unsigned __int16 *)(*(void *)(v40 + 232)
                                                + 2
                                                * (v29 & 0xFFF0000F | (16
                                                                     * (unsigned __int16)*(_DWORD *)(*(void *)(v40 + 88) + 4 * (v28 + *(unsigned __int16 *)(*(void *)(v40 + 88) + 2 * v27))))));
            goto LABEL_85;
          }
LABEL_73:
          uint64_t result = *(void *)(v40 + 288);
          if (!result)
          {
LABEL_76:
            BOOL v50 = v25 == 0;
LABEL_89:
            if (v50 && (_BYTE)v26)
            {
              if (v31 <= 0x3E)
              {
                uint64_t v26 = 0;
                uint64_t v23 = 0;
                uint64_t v3 = word_18CA7F8A0[v31];
                int v25 = -2;
                goto LABEL_127;
              }
              int v25 = 0;
            }
            goto LABEL_128;
          }
          uint64_t v44 = v3;
          uint64_t v45 = v23;
          uint64_t v46 = v24;
          uint64_t v47 = v26;
          uint64_t v48 = v31;
          uint64_t v49 = v32;
          uint64_t result = sub_18C85FA6C(result, a2, (int *)&v112, (char)v26);
          uint64_t v32 = v49;
          uint64_t v31 = v48;
          uint64_t v26 = v47;
          int v29 = v108;
          int v30 = v109;
          a2 = v110;
          unsigned int v28 = v106;
          uint64_t v2 = v107;
          uint64_t v24 = v46;
          uint64_t v23 = v45;
          uint64_t v8 = v102;
          uint64_t v3 = v44;
          unint64_t v33 = v105;
          if (result == 2)
          {
            int v38 = 2;
          }
          else
          {
LABEL_85:
            BOOL v50 = v25 == 0;
            if (result != -2 || v25 != 0) {
              goto LABEL_89;
            }
            int v38 = -2;
          }
          unsigned int v41 = v112;
          goto LABEL_115;
        }
        if (v41 < 0x100) {
          goto LABEL_76;
        }
        int v38 = 2;
LABEL_115:
        if (v41 > 0xEFFC) {
          goto LABEL_128;
        }
        uint64_t v26 = 0;
        uint64_t v23 = 0;
        if ((v41 & 0xFF00) >= 0x9F01) {
          int v62 = -45056;
        }
        else {
          int v62 = -28672;
        }
        int v63 = 2 * (v62 + (v41 & 0xFF00));
        if (v41 >= 0x7Fu) {
          int v64 = -32;
        }
        else {
          int v64 = -31;
        }
        if (v41 >= 0x9Fu)
        {
          int v65 = -126;
        }
        else
        {
          v63 -= 256;
          int v65 = v64;
        }
        uint64_t v3 = v63 | (v65 + v41);
LABEL_126:
        int v25 = v38;
LABEL_127:
        uint64_t v24 = v34;
LABEL_128:
        if (++v22 >= v33 || v25 >= 1)
        {
          uint64_t v6 = v100;
          uint64_t v4 = v101;
          uint64_t v5 = v95;
          uint64_t v9 = v103;
          if (v25) {
            goto LABEL_155;
          }
LABEL_134:
          int v66 = 10;
LABEL_136:
          int *v91 = v66;
          *(_DWORD *)(v5 + 84) = a2;
          goto LABEL_188;
        }
        continue;
      case 8:
        if (v31 > 0x3E) {
          goto LABEL_128;
        }
        int v39 = *(_DWORD *)(v8 + 108);
        if (v39 != 4)
        {
          if (v39 == 3)
          {
            *(unsigned char *)(v8 + 99) = v34;
            LODWORD(v23) = 1;
            uint64_t v3 = v92;
LABEL_142:
            uint64_t v4 = v101;
LABEL_153:
            uint64_t v5 = v95;
            uint64_t v9 = v103;
            goto LABEL_154;
          }
          goto LABEL_128;
        }
        LODWORD(v23) = 0;
        uint64_t v9 = v103;
        if ((*v103 & 0xFC) == 4) {
          LOBYTE(v34) = 3;
        }
        else {
          LOBYTE(v34) = *v103;
        }
        uint64_t v3 = v93;
        uint64_t v4 = v101;
        uint64_t v5 = v95;
LABEL_154:
        int v25 = 1;
        LOBYTE(v24) = v34;
        uint64_t v6 = v100;
LABEL_155:
        int v68 = 0;
        if (v25 < 0) {
          int v25 = -v25;
        }
        int v69 = *(unsigned __int8 *)(v8 + 102);
        if (v69 == 1 && !v23)
        {
          LOBYTE(v69) = 0;
          LOBYTE(v115[0]) = 15;
          *(unsigned char *)(v8 + 102) = 0;
          int v68 = 1;
        }
        if (v9[v23] != v24)
        {
          int v70 = byte_18CA7F91E[(char)v24];
          uint64_t v71 = v23;
          uint64_t v72 = v3;
          int v73 = v23;
          uint64_t v74 = v5;
          char v75 = v24;
          uint64_t result = (unint64_t)memcpy((void *)((unint64_t)v115 | v68), (char *)&unk_18CA7F927 + 6 * (char)v24, byte_18CA7F91E[(char)v24]);
          LODWORD(a2) = v110;
          LODWORD(v23) = v73;
          uint64_t v8 = v102;
          uint64_t v3 = v72;
          uint64_t v2 = 0;
          v68 += v70;
          v103[v71] = v75;
          uint64_t v5 = v74;
          uint64_t v9 = v103;
          LOBYTE(v69) = *(unsigned char *)(v102 + 102);
        }
        if (v23 != (char)v69)
        {
          uint64_t v76 = v68 + 1;
          if (v23 == 1)
          {
            *((unsigned char *)v115 + v68) = 14;
            *(unsigned char *)(v8 + 102) = 1;
            ++v68;
          }
          else
          {
            *((unsigned char *)v115 + v68) = 27;
            v68 += 2;
            *((unsigned char *)v115 + v76) = 78;
          }
        }
        int v77 = 1;
        int v78 = v68;
        if (v25 != 1)
        {
          int v78 = v68 + 1;
          *((unsigned char *)v115 + v68) = BYTE1(v3);
          int v77 = 2;
        }
        int v79 = v68 + v77;
        *((unsigned char *)v115 + v78) = v3;
        if (a2 == 13 || a2 == 10)
        {
          uint64_t v2 = 0;
          *(unsigned char *)(v8 + 100) = 0;
        }
        if (v79 == 2)
        {
          if ((unint64_t)(v6 + 1) > v98) {
            goto LABEL_176;
          }
          *uint64_t v6 = v115[0];
          v84 = v111;
          if (v111)
          {
            if (a2 >= 0x10000) {
              int v85 = -2;
            }
            else {
              int v85 = -1;
            }
            int v86 = (((unint64_t)v4 - *(void *)(v96 + 16)) >> 1) + v85;
            _DWORD *v111 = v86;
            v111 = v84 + 2;
            v84[1] = v86;
          }
          ++v6;
LABEL_6:
          if ((unint64_t)v4 >= v97) {
            goto LABEL_144;
          }
          if ((unint64_t)v6 >= v98)
          {
            int *v91 = 15;
            goto LABEL_188;
          }
          unsigned int v11 = *v4++;
          a2 = v11;
          if ((v11 & 0xF800) == 0xD800)
          {
            if ((a2 & 0x400) == 0) {
              goto LABEL_10;
            }
            goto LABEL_135;
          }
          goto LABEL_13;
        }
        if (v79 == 1)
        {
          *(unsigned char *)uint64_t v6 = v115[0];
          uint64_t v6 = (_WORD *)((char *)v6 + 1);
          v80 = v111;
          if (v111)
          {
            _DWORD *v111 = (((unint64_t)v4 - *(void *)(v96 + 16)) >> 1) - 1;
            v111 = v80 + 1;
          }
          goto LABEL_6;
        }
LABEL_176:
        unint64_t v81 = ((unint64_t)v4 - *(void *)(v96 + 16)) >> 1;
        if (a2 >= 0x10000) {
          int v82 = -2;
        }
        else {
          int v82 = -1;
        }
        v112 = v6;
        uint64_t v83 = v3;
        uint64_t result = sub_18C85D210(v5, (char *)v115, v79, &v112, v98, &v111, (int)v81 + v82, v91);
        uint64_t v3 = v83;
        uint64_t v6 = v112;
        if (*v91 < 1) {
          goto LABEL_6;
        }
LABEL_188:
        *(void *)(v96 + 16) = v4;
        *(void *)(v96 + 32) = v6;
        return result;
      default:
        uint64_t v42 = *(void *)(v8 + 8 * v35);
        if ((int)a2 >= 0x10000 && (*(unsigned char *)(v42 + 253) & 1) == 0) {
          goto LABEL_82;
        }
        unsigned int v43 = *(unsigned __int16 *)(*(void *)(v42 + 232)
                                  + 2
                                  * (v29 & 0xFFF0000F | (16
                                                       * (unsigned __int16)*(_DWORD *)(*(void *)(v42 + 88)
                                                                                     + 4
                                                                                     * (v28
                                                                                      + *(unsigned __int16 *)(*(void *)(v42 + 88) + 2 * v27))))));
        if (v43 >= 0x100) {
          uint64_t result = 4294967294;
        }
        else {
          uint64_t result = 0xFFFFFFFFLL;
        }
        if ((*(_DWORD *)(*(void *)(v42 + 88) + 4 * (v28 + *(unsigned __int16 *)(*(void *)(v42 + 88) + 2 * v27))) & v30) != 0)
        {
          LODWORD(v112) = *(unsigned __int16 *)(*(void *)(v42 + 232)
                                              + 2
                                              * (v29 & 0xFFF0000F | (16
                                                                   * (unsigned __int16)*(_DWORD *)(*(void *)(v42 + 88)
                                                                                                 + 4
                                                                                                 * (v28
                                                                                                  + *(unsigned __int16 *)(*(void *)(v42 + 88) + 2 * v27))))));
          if (v43 < 0x100) {
            goto LABEL_128;
          }
LABEL_84:
          int v57 = 2;
          goto LABEL_99;
        }
        if (((_BYTE)v26 || v104 >> 8 < 0x19 || !(v99 >> 17))
          && *(_WORD *)(*(void *)(v42 + 232)
                      + 2
                      * (v29 & 0xFFF0000F | (16
                                           * (unsigned __int16)*(_DWORD *)(*(void *)(v42 + 88)
                                                                         + 4
                                                                         * (v28
                                                                          + *(unsigned __int16 *)(*(void *)(v42 + 88)
                                                                                                + 2 * v27)))))))
        {
          LODWORD(v112) = *(unsigned __int16 *)(*(void *)(v42 + 232)
                                              + 2
                                              * (v29 & 0xFFF0000F | (16
                                                                   * (unsigned __int16)*(_DWORD *)(*(void *)(v42 + 88)
                                                                                                 + 4
                                                                                                 * (v28
                                                                                                  + *(unsigned __int16 *)(*(void *)(v42 + 88) + 2 * v27))))));
        }
        else
        {
LABEL_82:
          uint64_t result = *(void *)(v42 + 288);
          if (!result) {
            goto LABEL_128;
          }
          uint64_t v51 = v3;
          uint64_t v52 = v23;
          uint64_t v53 = v24;
          uint64_t v54 = v26;
          uint64_t v55 = v31;
          uint64_t v56 = v32;
          uint64_t result = sub_18C85FA6C(result, a2, (int *)&v112, (char)v26);
          uint64_t v32 = v56;
          uint64_t v31 = v55;
          uint64_t v26 = v54;
          int v29 = v108;
          int v30 = v109;
          a2 = v110;
          unsigned int v28 = v106;
          uint64_t v2 = v107;
          uint64_t v24 = v53;
          uint64_t v23 = v52;
          uint64_t v8 = v102;
          uint64_t v3 = v51;
          unint64_t v33 = v105;
          if (result == 2) {
            goto LABEL_84;
          }
        }
        if (result != -2 || v25 != 0) {
          goto LABEL_128;
        }
        int v57 = -2;
LABEL_99:
        uint64_t v60 = v112;
        if (v34 != 7
          || (((_WORD)v112 + 24159) & 0xFFFEu) <= 0x5D5D
          && (((_BYTE)v112 + 95) & 0xFEu) <= 0x5D
          && (uint64_t v60 = (v112 - 32896), v112 != 32896))
        {
          uint64_t v26 = 0;
          uint64_t v23 = 0;
          int v25 = v57;
          uint64_t v3 = v60;
          goto LABEL_127;
        }
        goto LABEL_128;
    }
  }
}

void *sub_18C859978(void *result, unint64_t *a2, unint64_t a3, int a4, int *a5)
{
  uint64_t v5 = (unsigned __int8 *)*a2;
  if (*a2 >= a3) {
    return result;
  }
  unint64_t v7 = result;
  uint64_t v8 = result[2];
  char v9 = *((unsigned char *)result + 64);
  int v10 = *(_DWORD *)(v8 + 104);
  do
  {
    *a2 = (unint64_t)(v5 + 1);
    uint64_t v11 = *v5;
    uint64_t v12 = *((char *)v7 + 64);
    *((unsigned char *)v7 + 64) = v12 + 1;
    *((unsigned char *)v7 + v12 + 65) = v11;
    int v13 = byte_18CA7F77A[v11];
    if (!byte_18CA7F77A[v11])
    {
LABEL_15:
      int v10 = 0;
LABEL_16:
      *(_DWORD *)(v8 + 104) = v10;
LABEL_17:
      *a5 = 18;
LABEL_18:
      int v20 = *((char *)v7 + 64);
      if (v20 >= 2)
      {
        char v21 = v20 - v9;
        if ((v20 - 1) <= (char)(v20 - v9))
        {
          uint64_t v22 = (v20 - 1);
        }
        else
        {
          *((unsigned char *)v7 + 282) = 1 - v9;
          uint64_t result = memcpy((char *)v7 + 250, (char *)v7 + 66, -(uint64_t)(char)(1 - v9));
          uint64_t v22 = v21;
        }
        *a2 -= v22;
        *((unsigned char *)v7 + 64) = 1;
      }
      return result;
    }
    int v14 = 0;
    int v15 = 0;
    uint64_t v16 = 74;
    int v10 = v13 + 32 * v10;
    while (1)
    {
      int v17 = v14;
      int v14 = (v15 + (int)v16) >> 1;
      if (v14 == v17) {
        goto LABEL_15;
      }
      uint64_t result = (void *)dword_18CA7F608[v14];
      uint64_t v18 = ((v15 + (int)v16) >> 1);
      if ((int)result <= v10)
      {
        int v15 = (v15 + (int)v16) >> 1;
        uint64_t v18 = v16;
        if ((int)result >= v10) {
          break;
        }
      }
      uint64_t v16 = v18;
      if (v18 == v15) {
        goto LABEL_15;
      }
    }
    int v19 = byte_18CA7F730[v14];
    if ((v19 - 1) < 2)
    {
      *(_DWORD *)(v8 + 104) = 0;
      goto LABEL_25;
    }
    if (v19 == -1) {
      goto LABEL_16;
    }
    uint64_t v5 = (unsigned __int8 *)*a2;
  }
  while (*a2 < a3);
  *(_DWORD *)(v8 + 104) = v10;
  if (!v19) {
    return result;
  }
LABEL_25:
  if (a4 == 3)
  {
    int v25 = byte_18CA7F5BE[v14];
    char v24 = byte_18CA7F5BE[v14];
    if (v25 <= 15)
    {
      if (v25 == -1) {
        goto LABEL_66;
      }
      if (v25 != 1)
      {
        if (v25 != 2)
        {
LABEL_64:
          if (!*(_DWORD *)(v8 + 108)) {
            goto LABEL_66;
          }
          *(unsigned char *)(v8 + 95) = v24;
          goto LABEL_59;
        }
        if (!*(_DWORD *)(v8 + 108)) {
          goto LABEL_66;
        }
      }
    }
    else
    {
      if (v25 <= 32)
      {
        if (v25 == 16)
        {
LABEL_50:
          if (!*(unsigned char *)(v8 + 94)) {
            goto LABEL_17;
          }
          int v28 = *(char *)(v8 + 96);
          if (v28 <= 1) {
            *(unsigned char *)(v8 + 97) = v28;
          }
          char v27 = 2;
          goto LABEL_54;
        }
        if (v25 == 17)
        {
          if (!*(unsigned char *)(v8 + 95)) {
            goto LABEL_17;
          }
          int v26 = *(char *)(v8 + 96);
          if (v26 <= 1) {
            *(unsigned char *)(v8 + 97) = v26;
          }
          char v27 = 3;
LABEL_54:
          *(unsigned char *)(v8 + 96) = v27;
          goto LABEL_59;
        }
        goto LABEL_64;
      }
      if (v25 != 33)
      {
        if (v25 == 34)
        {
LABEL_57:
          *(unsigned char *)(v8 + 94) = v24;
          goto LABEL_59;
        }
        goto LABEL_64;
      }
    }
    *(unsigned char *)(v8 + 93) = v24;
    goto LABEL_59;
  }
  if (a4 != 2)
  {
    if (a4 != 1) {
      goto LABEL_17;
    }
    int v23 = byte_18CA7F574[v14];
    char v24 = byte_18CA7F574[v14];
    if ((v23 - 1) >= 2)
    {
      if (v23 == -1) {
        goto LABEL_66;
      }
      if (v23 != 16)
      {
        if ((word_18CA7F504[*(unsigned int *)(v8 + 108)] >> v23))
        {
          *(unsigned char *)(v8 + 92) = v24;
          goto LABEL_59;
        }
LABEL_66:
        *a5 = 19;
LABEL_67:
        *((_DWORD *)v7 + 71) = 0;
        return result;
      }
      goto LABEL_50;
    }
    if (((word_18CA7F504[*(unsigned int *)(v8 + 108)] >> v23) & 1) == 0) {
      goto LABEL_66;
    }
    goto LABEL_57;
  }
  if (v14 != 48) {
    goto LABEL_66;
  }
LABEL_59:
  int v29 = *a5;
  if (*a5 <= 0)
  {
    *((unsigned char *)v7 + 64) = 0;
    return result;
  }
  if (v29 == 18) {
    goto LABEL_18;
  }
  if (v29 == 19) {
    goto LABEL_67;
  }
  return result;
}

uint64_t sub_18C859C80(uint64_t result, int *a2)
{
  uint64_t v3 = result;
  __int16 v44 = 0;
  uint64_t v6 = *(unsigned __int8 **)(result + 16);
  unint64_t v4 = *(void *)(result + 24);
  uint64_t v5 = (unint64_t *)(result + 16);
  unsigned int v43 = v6;
  uint64_t v7 = *(void *)(result + 8);
  uint64_t v8 = *(void *)(v7 + 16);
  if (*(_DWORD *)(v8 + 108) != 1)
  {
    uint64_t v11 = *(_WORD **)(result + 32);
    uint64_t v12 = *(void *)(*(void *)(v8 + 80) + 48);
    if (*(_DWORD *)(v8 + 104)) {
      goto LABEL_59;
    }
    BOOL v13 = *(unsigned char *)(v7 + 64) != 1 || (unint64_t)v6 >= v4;
    if (v13 || (unint64_t)v11 >= *(void *)(result + 40)) {
      goto LABEL_44;
    }
    LOWORD(v14) = *(unsigned __int8 *)(v7 + 65);
    *(unsigned char *)(v7 + 64) = 0;
LABEL_63:
    unsigned int v34 = *v6;
    unsigned int v35 = v34 - 33;
    __int16 v36 = v34 | ((_WORD)v14 << 8);
    if ((((_BYTE)v14 - 33) & 0xFEu) > 0x5D || v35 > 0x5D)
    {
      uint64_t result = 0xFFFFLL;
      if (v35 < 0x5E || v34 <= 0x1F && ((1 << v34) & 0x800C000) != 0) {
        goto LABEL_71;
      }
      unsigned int v43 = ++v6;
    }
    else
    {
      unsigned int v43 = ++v6;
      LOBYTE(v44) = v14 ^ 0x80;
      HIBYTE(v44) = v34 ^ 0x80;
      uint64_t result = sub_18C86D39C(v12, (uint64_t)&v44, 2);
    }
    LOWORD(v14) = v36;
LABEL_71:
    if ((int)result > 65533)
    {
      uint64_t v40 = *(unsigned char **)(v3 + 8);
      if ((unsigned __int16)v14 < 0x100u)
      {
        char v41 = 1;
      }
      else
      {
        v40[66] = v14;
        LOBYTE(v14) = BYTE1(v14);
        char v41 = 2;
      }
      v40[65] = v14;
      v40[64] = v41;
      if (result == 65534) {
        int v42 = 10;
      }
      else {
        int v42 = 12;
      }
      *a2 = v42;
      uint64_t v6 = v43;
      goto LABEL_55;
    }
    uint64_t v37 = *(void *)(v3 + 48);
    if (v37)
    {
      if ((unsigned __int16)v14 >= 0x100u) {
        int v38 = -2;
      }
      else {
        int v38 = -1;
      }
      *(_DWORD *)(v37 + 2 * ((void)v11 - *(void *)(v3 + 32))) = v38 + v6 - *(_DWORD *)(v3 + 16);
    }
    *v11++ = result;
    while (1)
    {
LABEL_44:
      if ((unint64_t)v6 >= v4) {
        goto LABEL_55;
      }
      uint64_t v31 = 0;
      unint64_t v32 = *(void *)(v3 + 40);
      while (1)
      {
        if ((unint64_t)v11 >= v32)
        {
          *a2 = 15;
          goto LABEL_55;
        }
        int v14 = v6[v31];
        if (v14 != 14) {
          break;
        }
        *(unsigned char *)(v8 + 96) = 1;
        *(unsigned char *)(v8 + 112) = 1;
LABEL_52:
        if (v4 - (void)v6 == ++v31)
        {
          uint64_t v6 = (unsigned __int8 *)v4;
          goto LABEL_55;
        }
      }
      if (v14 == 15) {
        break;
      }
      if (v14 != 27)
      {
        uint64_t v33 = (uint64_t)&v6[v31];
        v6 += v31 + 1;
        unsigned int v43 = v6;
        *(unsigned char *)(v8 + 112) = 0;
        if (*(unsigned char *)(v8 + 96) != 1)
        {
          uint64_t result = 0xFFFFLL;
          if (((char)v14 & 0x80000000) == 0) {
            uint64_t result = sub_18C86D39C(v12, v33, 1);
          }
          goto LABEL_71;
        }
        if ((unint64_t)v6 >= v4)
        {
          *(unsigned char *)(*(void *)(v3 + 8) + 65) = v14;
          *(unsigned char *)(*(void *)(v3 + 8) + 64) = 1;
          goto LABEL_55;
        }
        goto LABEL_63;
      }
      unsigned int v43 = &v6[v31];
      uint64_t v7 = *(void *)(v3 + 8);
LABEL_59:
      *(unsigned char *)(v8 + 112) = 0;
      uint64_t result = (uint64_t)sub_18C859978((void *)v7, (unint64_t *)&v43, v4, 2, a2);
      uint64_t v6 = v43;
      if (*a2 >= 1)
      {
LABEL_55:
        *(void *)(v3 + 32) = v11;
        *(void *)(v3 + 16) = v6;
        return result;
      }
    }
    *(unsigned char *)(v8 + 96) = 0;
    if (*(unsigned char *)(v8 + 112))
    {
      *(unsigned char *)(v8 + 112) = 0;
      *a2 = 18;
      uint64_t v39 = *(void *)(v3 + 8);
      *(_DWORD *)(v39 + 284) = 2;
      *(unsigned char *)(v39 + 65) = 15;
      *(unsigned char *)(*(void *)(v3 + 8) + 64) = 1;
      *(void *)(v3 + 32) = v11;
      *(void *)(v3 + 16) = &v6[v31 + 1];
      return result;
    }
    goto LABEL_52;
  }
  if (*(unsigned __int16 *)result >= 0x38u) {
    size_t v9 = 56;
  }
  else {
    size_t v9 = *(unsigned __int16 *)result;
  }
  if (v9 <= 0x37) {
    size_t v10 = 56 - v9;
  }
  else {
    size_t v10 = 0;
  }
  bzero((char *)__dst + v9, v10);
  uint64_t result = (uint64_t)memcpy(__dst, (const void *)v3, v9);
  __dst[0] = v9;
  uint64_t v46 = *(char **)(v8 + 80);
  if (*(_DWORD *)(v8 + 104)) {
    goto LABEL_43;
  }
  while (1)
  {
    int v15 = *a2;
    if (*a2 > 0) {
      return result;
    }
    unint64_t v16 = *(void *)(v3 + 16);
    unint64_t v17 = *(void *)(v3 + 24);
    if (v16 >= v17) {
      return result;
    }
    uint64_t v18 = 0;
    uint64_t v47 = *(void *)(v3 + 16);
    while (*(unsigned char *)(v16 + v18) != 27)
    {
      if (v17 - v16 == ++v18) {
        goto LABEL_24;
      }
    }
    unint64_t v17 = v16 + v18;
LABEL_24:
    unint64_t v48 = v17;
    if (v16 != v17)
    {
      uint64_t v19 = *(void *)(v3 + 8);
      int v20 = *(char *)(v19 + 64);
      char v21 = v46;
      if (v20 >= 1)
      {
        memcpy(v46 + 65, (const void *)(v19 + 65), *(unsigned __int8 *)(v19 + 64));
        LOBYTE(v20) = *(unsigned char *)(*(void *)(v3 + 8) + 64);
      }
      v21[64] = v20;
      uint64_t result = sub_18C86C2EC((uint64_t)__dst, a2);
      uint64_t v22 = *(_DWORD **)(v3 + 48);
      if (v22)
      {
        if (v6 != (unsigned __int8 *)*v5)
        {
          unint64_t v23 = *(void *)(v3 + 32);
          unint64_t v24 = v49;
          if (v23 < v49)
          {
            int v25 = *v5 - v6;
            do
            {
              if ((*v22 & 0x80000000) == 0) {
                *v22 += v25;
              }
              ++v22;
              v23 += 2;
            }
            while (v23 < v24);
          }
        }
      }
      int v26 = v46;
      *(void *)(v3 + 16) = v47;
      uint64_t v27 = v50;
      *(void *)(v3 + 32) = v49;
      *(void *)(v3 + 48) = v27;
      int v28 = v26[64];
      if (v28 >= 1)
      {
        uint64_t result = (uint64_t)memcpy((void *)(*(void *)(v3 + 8) + 65), v26 + 65, v26[64]);
        LOBYTE(v28) = v26[64];
      }
      int v29 = *(unsigned char **)(v3 + 8);
      v29[64] = v28;
      int v15 = *a2;
      if (*a2 == 15)
      {
        int v30 = v26[93];
        if (v30 >= 1)
        {
          uint64_t result = (uint64_t)memcpy(v29 + 144, v26 + 144, v26[93]);
          LOBYTE(v30) = v26[93];
          int v29 = *(unsigned char **)(v3 + 8);
          int v15 = *a2;
        }
        v29[93] = v30;
        v26[93] = 0;
      }
    }
    if (v15 > 0) {
      return result;
    }
    unint64_t v4 = *(void *)(v3 + 24);
    if (*(void *)(v3 + 16) == v4) {
      return result;
    }
    uint64_t v7 = *(void *)(v3 + 8);
LABEL_43:
    uint64_t result = (uint64_t)sub_18C859978((void *)v7, v5, v4, 2, a2);
  }
}

unint64_t sub_18C85A17C(unint64_t result, int *a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = result;
  unint64_t v5 = *(void *)(result + 24);
  unint64_t v4 = *(char **)(result + 32);
  unint64_t v6 = *(void *)(result + 40);
  uint64_t v56 = *(_DWORD **)(result + 48);
  unsigned int v55 = 0;
  uint64_t v7 = *(void *)(result + 8);
  uint64_t v8 = *(unsigned __int16 **)(result + 16);
  uint64_t v9 = *(void *)(v7 + 16);
  uint64_t v10 = *(void *)(v9 + 80);
  if (*(_DWORD *)(v9 + 108) == 1)
  {
    *(void *)(result + 8) = v10;
    *(_DWORD *)(v10 + 84) = *(_DWORD *)(v7 + 84);
    uint64_t result = sub_18C86D560(result, a2);
    uint64_t v11 = *(void *)(v9 + 80);
    *(_DWORD *)(v7 + 84) = *(_DWORD *)(v11 + 84);
    if (*v2 == 15)
    {
      int v12 = *(char *)(v11 + 91);
      if (v12 >= 1)
      {
        uint64_t result = (unint64_t)memcpy((void *)(v7 + 104), (const void *)(v11 + 104), *(unsigned __int8 *)(v11 + 91));
        uint64_t v11 = *(void *)(v9 + 80);
        LOBYTE(v12) = *(unsigned char *)(v11 + 91);
      }
      *(unsigned char *)(v7 + 91) = v12;
      *(unsigned char *)(v11 + 91) = 0;
    }
    *(void *)(v3 + 8) = v7;
    return result;
  }
  int v14 = *(_DWORD *)(v7 + 80);
  LODWORD(v13) = *(_DWORD *)(v7 + 84);
  if (v13) {
    BOOL v15 = (unint64_t)v4 >= v6;
  }
  else {
    BOOL v15 = 1;
  }
  if (!v15)
  {
LABEL_68:
    if ((unint64_t)v8 >= v5)
    {
      int v47 = 0;
    }
    else
    {
      int v44 = *v8;
      BOOL v45 = (v44 & 0xFC00) == 56320;
      int v46 = v44 + (v13 << 10) - 56613888;
      if ((v44 & 0xFC00) == 0xDC00) {
        int v47 = 10;
      }
      else {
        int v47 = 12;
      }
      v8 += v45;
      if (v45) {
        LODWORD(v13) = v46;
      }
    }
    goto LABEL_79;
  }
  if ((unint64_t)v8 < v5)
  {
    unint64_t v16 = *(void **)(v10 + 48);
    unint64_t v17 = v8 + 1;
    int v18 = *(unsigned __int8 *)(v7 + 63);
    int v19 = (char)v18;
    int v20 = *(_DWORD *)(v7 + 80);
    while (1)
    {
      char v21 = v8;
      LOBYTE(v14) = v20;
      unsigned int v55 = 0xFFFF;
      if ((unint64_t)v4 >= *(void *)(v3 + 40))
      {
        *uint64_t v2 = 15;
        goto LABEL_81;
      }
      ++v8;
      unint64_t v13 = *v21;
      if (v13 <= 0x1F && ((1 << v13) & 0x800C000) != 0)
      {
        *uint64_t v2 = 12;
        *(_DWORD *)(*(void *)(v3 + 8) + 84) = v13;
        ++v21;
        goto LABEL_81;
      }
      if (*(unsigned __int16 *)(v16[29]
                               + 2
                               * (v13 & 0xF | (16
                                             * (unsigned __int16)*(_DWORD *)(v16[11]
                                                                                         + 4
                                                                                         * (((v13 >> 4) & 0x3F)
                                                                                          + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E))))))) < 0x100u)
        uint64_t result = 1;
      else {
        uint64_t result = 2;
      }
      if (((*(_DWORD *)(v16[11]
                       + 4
                       * (((v13 >> 4) & 0x3F) + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E)))) >> (v13 & 0xF | 0x10)) & 1) != 0
        || ((v13 - 63744) < 0xFFFFE700 ? (BOOL v23 = v18 == 0) : (BOOL v23 = 0),
            !v23
         && *(_WORD *)(v16[29]
                     + 2
                     * (v13 & 0xF | (16
                                   * (unsigned __int16)*(_DWORD *)(v16[11]
                                                                               + 4
                                                                               * (((v13 >> 4) & 0x3F)
                                                                                + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E)))))))))
      {
        unsigned int v55 = *(unsigned __int16 *)(v16[29]
                                  + 2
                                  * (v13 & 0xF | (16
                                                * (unsigned __int16)*(_DWORD *)(v16[11]
                                                                                            + 4
                                                                                            * (((v13 >> 4) & 0x3F)
                                                                                             + *(unsigned __int16 *)(v16[11] + ((v13 >> 9) & 0x7E)))))));
      }
      else
      {
        uint64_t result = v16[36];
        if (!result) {
          goto LABEL_65;
        }
        int v52 = v19;
        int v53 = v18;
        unint64_t v38 = v6;
        uint64_t v39 = v16;
        uint64_t v54 = v2;
        unint64_t v40 = v5;
        char v41 = v4;
        uint64_t result = sub_18C85FA6C(result, v13, (int *)&v55, v19);
        int v19 = v52;
        int v18 = v53;
        unint64_t v4 = v41;
        unint64_t v5 = v40;
        uint64_t v2 = v54;
        unint64_t v16 = v39;
        unint64_t v6 = v38;
        if ((result & 0x80000000) != 0) {
          uint64_t result = -(int)result;
        }
      }
      BOOL v24 = (int)result > 2 || result == 0;
      if (v24
        || result == 1 && v55 > 0x7F
        || result == 2 && ((((_WORD)v55 + 24159) & 0xFFFEu) > 0x5D5D || (((_BYTE)v55 + 95) & 0xFEu) >= 0x5E))
      {
LABEL_65:
        unsigned int v55 = 0xFFFF;
LABEL_66:
        uint64_t v8 = v21 + 1;
        if ((v13 & 0xF800) == 0xD800)
        {
          if ((v13 & 0x400) == 0) {
            goto LABEL_68;
          }
          int v47 = 12;
        }
        else
        {
          int v47 = 10;
        }
LABEL_79:
        *uint64_t v2 = v47;
        *(_DWORD *)(*(void *)(v3 + 8) + 84) = v13;
        break;
      }
      if (v55 == 0xFFFF) {
        goto LABEL_66;
      }
      int v20 = v55 > 0xFF;
      if (v20 != (char)v14)
      {
        char v25 = v55 > 0xFF ? 14 : 15;
        *v4++ = v25;
        int v26 = v56;
        if (v56)
        {
          _DWORD *v56 = (((unint64_t)v17 - *(void *)(v3 + 16)) >> 1) - 1;
          uint64_t v56 = v26 + 1;
        }
      }
      char v27 = v55;
      if (v55 > 0xFF)
      {
        unsigned int v29 = (v55 >> 8) ^ 0xFFFFFF80;
        if ((unint64_t)v4 < v6)
        {
          *unint64_t v4 = v29;
          int v30 = v4 + 1;
          uint64_t v31 = v56;
          if (v56)
          {
            _DWORD *v56 = (((unint64_t)v17 - *(void *)(v3 + 16)) >> 1) - 1;
            uint64_t v56 = v31 + 1;
          }
          char v32 = v55 ^ 0x80;
          if ((unint64_t)v30 >= v6)
          {
            uint64_t v42 = *(void *)(v3 + 8);
            uint64_t v43 = *(char *)(v42 + 91);
            *(unsigned char *)(v42 + 91) = v43 + 1;
            *(unsigned char *)(v42 + v43 + 104) = v32;
            *uint64_t v2 = 15;
          }
          else
          {
            int v30 = v4 + 2;
            v4[1] = v32;
            uint64_t v33 = v56;
            if (v56)
            {
              _DWORD *v56 = (((unint64_t)v17 - *(void *)(v3 + 16)) >> 1) - 1;
              uint64_t v56 = v33 + 1;
            }
          }
          unint64_t v4 = v30;
          goto LABEL_63;
        }
        uint64_t v34 = *(void *)(v3 + 8);
        uint64_t v35 = *(char *)(v34 + 91);
        *(unsigned char *)(v34 + 91) = v35 + 1;
        *(unsigned char *)(v34 + v35 + 104) = v29;
        char v27 = v55 ^ 0x80;
      }
      else if ((unint64_t)v4 < v6)
      {
        *v4++ = v55;
        int v28 = v56;
        if (v56)
        {
          _DWORD *v56 = (((unint64_t)v17 - *(void *)(v3 + 16)) >> 1) - 1;
          uint64_t v56 = v28 + 1;
        }
        goto LABEL_63;
      }
      uint64_t v36 = *(void *)(v3 + 8);
      uint64_t v37 = *(char *)(v36 + 91);
      *(unsigned char *)(v36 + 91) = v37 + 1;
      *(unsigned char *)(v36 + v37 + 104) = v27;
      *uint64_t v2 = 15;
LABEL_63:
      ++v17;
      if ((unint64_t)v8 >= v5)
      {
        ++v21;
        LOBYTE(v14) = v20;
        goto LABEL_81;
      }
    }
  }
  char v21 = v8;
LABEL_81:
  if (*v2 <= 0 && v14 != 0)
  {
    if (*(unsigned char *)(v3 + 2))
    {
      if ((unint64_t)v21 >= v5)
      {
        uint64_t result = *(void *)(v3 + 8);
        if (!*(_DWORD *)(result + 84))
        {
          uint64_t v49 = *(void *)(v3 + 16);
          unint64_t v50 = ((unint64_t)v21 - v49) >> 1;
          unsigned int v51 = v50 - 1;
          if ((int)v50 < 1)
          {
            unsigned int v51 = -1;
          }
          else if ((*(_WORD *)(v49 + 2 * v51) & 0xFC00) == 0xDC00 {
                 && (v50 == 1 || (*(_WORD *)(v49 + 2 * (v50 - 2)) & 0xFC00) == 0xD800))
          }
          {
            unsigned int v51 = v50 - 2;
          }
          int v57 = v4;
          uint64_t result = sub_18C85D210(result, byte_18CA7F9C4, 1, &v57, v6, &v56, v51, v2);
          LOBYTE(v14) = 0;
          unint64_t v4 = v57;
        }
      }
    }
  }
  *(void *)(v3 + 16) = v21;
  *(void *)(v3 + 32) = v4;
  *(_DWORD *)(*(void *)(v3 + 8) + 80) = (char)v14;
  return result;
}

uint64_t sub_18C85A6CC(void *a1, int *a2)
{
  char v42 = 0;
  __int16 v41 = 0;
  unint64_t v6 = a1 + 1;
  uint64_t result = a1[1];
  unint64_t v5 = (unsigned __int8 *)v6[1];
  unint64_t v40 = v5;
  unint64_t v7 = a1[3];
  uint64_t v8 = (_WORD *)a1[4];
  uint64_t v9 = *(void *)(result + 16);
  uint64_t v10 = (_DWORD *)(v9 + 92);
  if (*(_DWORD *)(v9 + 104))
  {
LABEL_2:
    char v11 = *(unsigned char *)(result + 64);
    uint64_t result = (uint64_t)sub_18C859978((void *)result, (unint64_t *)&v40, v7, 3, a2);
    int v12 = *a2;
    if (*(_DWORD *)(v9 + 104)) {
      goto LABEL_5;
    }
    if (v12 <= 0)
    {
      if (!*(unsigned char *)(v9 + 112))
      {
LABEL_5:
        unint64_t v5 = v40;
        if (v12 < 1) {
          goto LABEL_17;
        }
        goto LABEL_15;
      }
      *a2 = 18;
      uint64_t v15 = a1[1];
      *(_DWORD *)(v15 + 284) = 2;
      *(unsigned char *)(v15 + 64) = v11 + (_BYTE)v40 - (_BYTE)v5;
    }
    unint64_t v5 = v40;
LABEL_15:
    a1[4] = v8;
    a1[2] = v5;
    *(unsigned char *)(v9 + 112) = 0;
    return result;
  }
  BOOL v13 = *(unsigned char *)(result + 64) != 1 || (unint64_t)v5 >= v7;
  if (!v13 && (unint64_t)v8 < a1[5])
  {
    LODWORD(v14) = *(unsigned __int8 *)(result + 65);
    *(unsigned char *)(result + 64) = 0;
    goto LABEL_37;
  }
LABEL_17:
  if ((unint64_t)v5 >= v7) {
    goto LABEL_28;
  }
  uint64_t v18 = 0;
  unint64_t v19 = a1[5];
  while (2)
  {
    if ((unint64_t)v8 >= v19)
    {
      int v21 = 15;
      goto LABEL_27;
    }
    uint64_t v14 = v5[v18];
    unsigned __int8 v20 = v5[v18];
    switch(v20)
    {
      case 0xAu:
      case 0xDu:
        unint64_t v40 = &v5[v18 + 1];
        *uint64_t v10 = 0;
        *(_WORD *)(v9 + 96) = 0;
        *(unsigned char *)(v9 + 112) = 0;
        goto LABEL_31;
      case 0xBu:
      case 0xCu:
        goto LABEL_34;
      case 0xEu:
        if (!*(unsigned char *)(v9 + 93))
        {
          v5 += v18 + 1;
          unint64_t v40 = v5;
          *(unsigned char *)(v9 + 112) = 0;
          LODWORD(v14) = 14;
          uint64_t result = 0xFFFFLL;
          goto LABEL_49;
        }
        *(unsigned char *)(v9 + 96) = 1;
        *(unsigned char *)(v9 + 112) = 1;
LABEL_24:
        if (v7 - (void)v5 == ++v18)
        {
          unint64_t v5 = (unsigned __int8 *)v7;
          goto LABEL_28;
        }
        continue;
      case 0xFu:
        *(unsigned char *)(v9 + 96) = 0;
        if (!*(unsigned char *)(v9 + 112)) {
          goto LABEL_24;
        }
        *(unsigned char *)(v9 + 112) = 0;
        *a2 = 18;
        uint64_t v37 = a1[1];
        *(_DWORD *)(v37 + 284) = 2;
        *(unsigned char *)(v37 + 65) = 15;
        *(unsigned char *)(a1[1] + 64) = 1;
        a1[4] = v8;
        a1[2] = &v5[v18 + 1];
        return result;
      default:
        if (v14 == 27)
        {
          v5 += v18;
          unint64_t v40 = v5;
          uint64_t result = a1[1];
          goto LABEL_2;
        }
LABEL_34:
        unint64_t v40 = &v5[v18 + 1];
        int v22 = *(unsigned __int8 *)(v9 + 96);
        *(unsigned char *)(v9 + 112) = 0;
        if (v22)
        {
          if ((unint64_t)&v5[v18 + 1] >= v7)
          {
            *(unsigned char *)(a1[1] + 65) = v20;
            *(unsigned char *)(a1[1] + 64) = 1;
            v5 += v18 + 1;
            goto LABEL_28;
          }
          v5 += v18 + 1;
LABEL_37:
          unsigned int v23 = *v5;
          int v24 = v23 | (v14 << 8);
          if ((((_BYTE)v14 - 33) & 0xFEu) > 0x5D || (v23 - 33) > 0x5Du)
          {
            uint64_t result = 0xFFFFLL;
            if ((v23 - 33) >= 0x5Eu && (v23 > 0x1F || ((1 << v23) & 0x800C000) == 0))
            {
              unint64_t v40 = ++v5;
              LODWORD(v14) = v24 | 0x10000;
            }
          }
          else
          {
            unint64_t v40 = ++v5;
            uint64_t v25 = *((char *)v10 + *(char *)(v9 + 96));
            if (v25 < 32)
            {
              uint64_t v26 = *(void *)(v9 + 8 * v25);
              int v28 = 2;
              char v27 = v14;
            }
            else
            {
              uint64_t v26 = *(void *)(v9 + 24);
              char v27 = v25 + 96;
              char v42 = v23;
              int v28 = 3;
              LOBYTE(v23) = v14;
            }
            LOBYTE(v41) = v27;
            HIBYTE(v41) = v23;
            uint64_t result = sub_18C86D39C(v26, (uint64_t)&v41, v28);
            LODWORD(v14) = v24;
          }
          if (*(char *)(v9 + 96) >= 2) {
            *(unsigned char *)(v9 + 96) = *(unsigned char *)(v9 + 97);
          }
        }
        else
        {
          uint64_t result = 0xFFFFLL;
          if ((char)v14 < 0)
          {
            v5 += v18 + 1;
          }
          else
          {
LABEL_31:
            v5 += v18 + 1;
            uint64_t result = v14;
          }
        }
LABEL_49:
        if (result <= 0xFFFD)
        {
          uint64_t v29 = a1[6];
          if (v29)
          {
            if (v14 >= 0x100) {
              int v30 = -2;
            }
            else {
              int v30 = -1;
            }
            *(_DWORD *)(v29 + 2 * ((void)v8 - a1[4])) = v30 + v5 - *((_DWORD *)a1 + 4);
          }
          *v8++ = result;
          goto LABEL_17;
        }
        if (result >= 0x10000)
        {
          *uint64_t v8 = ((result + 67043328) >> 10) - 10240;
          uint64_t v31 = a1[6];
          if (v31)
          {
            if (v14 >= 0x100) {
              int v32 = -2;
            }
            else {
              int v32 = -1;
            }
            int v33 = v32 + v5 - *((_DWORD *)a1 + 4);
            uint64_t v34 = a1[4];
            unint64_t v35 = a1[5];
            *(_DWORD *)(v31 + 2 * ((void)v8 - v34)) = v33;
            uint64_t v36 = v8 + 1;
            if ((unint64_t)(v8 + 1) < v35)
            {
              *uint64_t v36 = result & 0x3FF | 0xDC00;
              *(_DWORD *)(v31 + 2 * ((void)v36 - v34)) = v33;
              goto LABEL_65;
            }
LABEL_16:
            uint64_t v16 = a1[1];
            uint64_t v17 = *(char *)(v16 + 93);
            *(unsigned char *)(v16 + 93) = v17 + 1;
            *(_WORD *)(v16 + 2 * v17 + 144) = result & 0x3FF | 0xDC00;
            uint64_t v8 = v36;
          }
          else
          {
            uint64_t v36 = v8 + 1;
            if ((unint64_t)(v8 + 1) >= a1[5]) {
              goto LABEL_16;
            }
            *uint64_t v36 = result & 0x3FF | 0xDC00;
LABEL_65:
            v8 += 2;
          }
          goto LABEL_17;
        }
        unint64_t v38 = (unsigned char *)a1[1];
        if (v14 < 0x100)
        {
          char v39 = 1;
        }
        else
        {
          v38[66] = v14;
          LODWORD(v14) = v14 >> 8;
          char v39 = 2;
        }
        v38[65] = v14;
        v38[64] = v39;
        if (result == 65534) {
          int v21 = 10;
        }
        else {
          int v21 = 12;
        }
LABEL_27:
        *a2 = v21;
LABEL_28:
        a1[4] = v8;
        a1[2] = v5;
        return result;
    }
  }
}

unint64_t sub_18C85AB84(unint64_t result, int *a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = result;
  unsigned int v4 = 0;
  uint64_t v5 = 0;
  v87[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(result + 8);
  unint64_t v6 = *(unsigned __int16 **)(result + 16);
  unint64_t v9 = *(void *)(result + 24);
  uint64_t v8 = *(_WORD **)(result + 32);
  unint64_t v10 = *(void *)(result + 40);
  int v85 = *(_DWORD **)(result + 48);
  v87[0] = 0;
  memset(v84, 0, 3);
  uint64_t v11 = *(void *)(v7 + 16);
  uint64_t v12 = v11 + 98;
  unsigned int v13 = *(_DWORD *)(v7 + 84);
  if (v13) {
    BOOL v14 = (unint64_t)v8 >= v10;
  }
  else {
    BOOL v14 = 1;
  }
  unint64_t v74 = result;
  uint64_t v71 = v11 + 98;
  uint64_t v72 = v7;
  unint64_t v69 = v9;
  unint64_t v70 = v10;
  uint64_t v82 = *(void *)(v7 + 16);
  if (v14) {
    goto LABEL_6;
  }
  while (2)
  {
    if ((unint64_t)v6 >= v9)
    {
      *(_DWORD *)(v7 + 84) = v13;
LABEL_138:
      if (*v2 <= 0
        && *(unsigned char *)(v11 + 102)
        && *(unsigned char *)(v3 + 2)
        && (unint64_t)v6 >= v9
        && !*(_DWORD *)(v7 + 84))
      {
        *(unsigned char *)(v11 + 102) = 0;
        uint64_t v66 = *(void *)(v3 + 16);
        unint64_t v67 = ((unint64_t)v6 - v66) >> 1;
        unsigned int v68 = v67 - 1;
        if ((int)v67 < 1)
        {
          unsigned int v68 = -1;
        }
        else if ((*(_WORD *)(v66 + 2 * v68) & 0xFC00) == 0xDC00 {
               && (v67 == 1 || (*(_WORD *)(v66 + 2 * (v67 - 2)) & 0xFC00) == 0xD800))
        }
        {
          unsigned int v68 = v67 - 2;
        }
        int v86 = v8;
        uint64_t result = sub_18C85D210(v7, byte_18CA7F9C4, 1, &v86, v10, &v85, v68, v2);
        uint64_t v8 = v86;
      }
      goto LABEL_149;
    }
    int v16 = *v6;
    if ((v16 & 0xFC00) != 0xDC00)
    {
LABEL_38:
      *uint64_t v2 = 12;
      *(_DWORD *)(v7 + 84) = v13;
      goto LABEL_149;
    }
    ++v6;
    unsigned int v13 = v16 + (v13 << 10) - 56613888;
    *(_DWORD *)(v7 + 84) = 0;
LABEL_13:
    if ((int)v13 <= 127)
    {
      if ((int)v13 > 31 || ((1 << v13) & 0x800C000) == 0)
      {
        int v18 = 1;
        char v19 = v13;
        if (*(unsigned char *)(v11 + 102))
        {
          unsigned int v4 = 0;
          BYTE1(v87[0]) = v13;
          *(unsigned char *)(v11 + 102) = 0;
          int v18 = 2;
          char v19 = 15;
        }
        LOBYTE(v87[0]) = v19;
        if (v13 == 13 || v13 == 10)
        {
          unsigned int v4 = 0;
          *(_WORD *)(v12 + 4) = 0;
          *(_DWORD *)uint64_t v12 = 0;
        }
        goto LABEL_120;
      }
      goto LABEL_38;
    }
    uint64_t v76 = v6;
    if (v4)
    {
      unsigned int v77 = v4;
    }
    else
    {
      unsigned int v20 = *(unsigned __int8 *)(v11 + 99);
      if (v20 <= 1) {
        int v21 = 1;
      }
      else {
        int v21 = *(unsigned __int8 *)(v11 + 99);
      }
      LOBYTE(v84[0]) = v21;
      int v22 = *(_DWORD *)(v11 + 108);
      if (v22 == 1)
      {
        if (v21 == 2)
        {
          __int16 v24 = 8449;
        }
        else if ((char)v21 == 1)
        {
          __int16 v24 = 545;
        }
        else
        {
          __int16 v24 = 513;
        }
        *(_WORD *)((char *)v84 + 1) = v24;
        int v25 = 3;
      }
      else
      {
        if (v22) {
          goto LABEL_136;
        }
        if (v20 > 1) {
          char v23 = 1;
        }
        else {
          char v23 = 33;
        }
        HIBYTE(v84[0]) = v23;
        int v25 = 2;
      }
      unsigned int v77 = v25;
    }
    char v75 = v8;
    unint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    int v29 = 0;
    uint64_t v30 = *(unsigned __int8 *)(v7 + 63);
    uint64_t v83 = v13 >> 10;
    int v31 = (v13 >> 4) & 0x3F;
    int v32 = 1 << (v13 & 0xF | 0x10);
    unsigned int v81 = v13 - 57344;
    unsigned int v78 = v13 - 983040;
    unint64_t v33 = v77;
    do
    {
      int v34 = *((char *)v84 + v26);
      if (v34 < 1) {
        goto LABEL_101;
      }
      uint64_t v35 = *((unsigned __int8 *)v84 + v26);
      LODWORD(v86) = 0;
      if (v35 < 0x20)
      {
        uint64_t v41 = *(void *)(v11 + 8 * v34);
        if (v13 >= 0x10000 && (*(unsigned char *)(v41 + 253) & 1) == 0) {
          goto LABEL_87;
        }
        unsigned int v42 = *(unsigned __int16 *)(*(void *)(v41 + 232)
                                  + 2
                                  * (v13 & 0xF | (16
                                                * (unsigned __int16)*(_DWORD *)(*(void *)(v41 + 88)
                                                                              + 4
                                                                              * (v31
                                                                               + *(unsigned __int16 *)(*(void *)(v41 + 88) + 2 * v83))))));
        if (v42 >= 0x100) {
          uint64_t result = 4294967294;
        }
        else {
          uint64_t result = 0xFFFFFFFFLL;
        }
        if ((*(_DWORD *)(*(void *)(v41 + 88)
                        + 4 * (v31 + *(unsigned __int16 *)(*(void *)(v41 + 88) + 2 * v83))) & v32) != 0)
        {
          LODWORD(v86) = *(unsigned __int16 *)(*(void *)(v41 + 232)
                                             + 2
                                             * (v13 & 0xF | (16
                                                           * (unsigned __int16)*(_DWORD *)(*(void *)(v41 + 88)
                                                                                         + 4
                                                                                         * (v31
                                                                                          + *(unsigned __int16 *)(*(void *)(v41 + 88) + 2 * v83))))));
          if (v42 < 0x100) {
            goto LABEL_101;
          }
LABEL_89:
          int v29 = 2;
LABEL_96:
          uint64_t v30 = 0;
          uint64_t v27 = 1;
          uint64_t v5 = v86;
          uint64_t v28 = v35;
          goto LABEL_101;
        }
        if (((_BYTE)v30 || v81 >> 8 < 0x19 || !(v78 >> 17))
          && *(_WORD *)(*(void *)(v41 + 232)
                      + 2
                      * (v13 & 0xF | (16
                                    * (unsigned __int16)*(_DWORD *)(*(void *)(v41 + 88)
                                                                  + 4
                                                                  * (v31
                                                                   + *(unsigned __int16 *)(*(void *)(v41 + 88) + 2 * v83)))))))
        {
          LODWORD(v86) = *(unsigned __int16 *)(*(void *)(v41 + 232)
                                             + 2
                                             * (v13 & 0xF | (16
                                                           * (unsigned __int16)*(_DWORD *)(*(void *)(v41 + 88)
                                                                                         + 4
                                                                                         * (v31
                                                                                          + *(unsigned __int16 *)(*(void *)(v41 + 88) + 2 * v83))))));
        }
        else
        {
LABEL_87:
          uint64_t result = *(void *)(v41 + 288);
          if (!result) {
            goto LABEL_101;
          }
          uint64_t v79 = v28;
          uint64_t v48 = v5;
          int v80 = v29;
          uint64_t v49 = v27;
          uint64_t v50 = v30;
          uint64_t result = sub_18C85FA6C(result, v13, (int *)&v86, (char)v30);
          uint64_t v28 = v79;
          unint64_t v33 = v77;
          uint64_t v11 = v82;
          uint64_t v30 = v50;
          uint64_t v27 = v49;
          int v29 = v80;
          uint64_t v5 = v48;
          if (result == 2) {
            goto LABEL_89;
          }
        }
        if (result == -2 && v29 == 0)
        {
          int v29 = -2;
          goto LABEL_96;
        }
        goto LABEL_101;
      }
      uint64_t v36 = *(void *)(v11 + 24);
      if (v13 >= 0x10000 && (*(unsigned char *)(v36 + 253) & 1) == 0)
      {
LABEL_69:
        uint64_t result = *(void *)(v36 + 288);
        if (!result) {
          goto LABEL_101;
        }
        uint64_t v43 = v28;
        uint64_t v44 = v5;
        uint64_t v45 = v27;
        uint64_t v46 = v30;
        uint64_t result = sub_18C85FA6C(result, v13, (int *)&v86, (char)v30);
        uint64_t v28 = v43;
        unint64_t v33 = v77;
        uint64_t v11 = v82;
        uint64_t v30 = v46;
        uint64_t v27 = v45;
        uint64_t v5 = v44;
LABEL_71:
        if (result == 3)
        {
          int v29 = 2;
          goto LABEL_79;
        }
        goto LABEL_73;
      }
      uint64_t v37 = v13 & 0xF | (16
                       * (unsigned __int16)*(_DWORD *)(*(void *)(v36 + 88)
                                                     + 4
                                                     * (v31
                                                      + *(unsigned __int16 *)(*(void *)(v36 + 88)
                                                                                          + 2 * v83))));
      unint64_t v38 = (unsigned __int8 *)(*(void *)(v36 + 232) + v37 + 2 * v37);
      unsigned int v39 = (*v38 << 16) | (v38[1] << 8) | v38[2];
      if (v39 < 0x10000) {
        unsigned int v40 = 2;
      }
      else {
        unsigned int v40 = 3;
      }
      if (v39 < 0x100) {
        uint64_t result = 1;
      }
      else {
        uint64_t result = v40;
      }
      if ((*(_DWORD *)(*(void *)(v36 + 88)
                      + 4 * (v31 + *(unsigned __int16 *)(*(void *)(v36 + 88) + 2 * v83))) & v32) != 0)
      {
        LODWORD(v86) = v39;
        goto LABEL_71;
      }
      if (!(_BYTE)v30 && v81 >> 8 >= 0x19 && v78 >> 17 || !v39) {
        goto LABEL_69;
      }
      LODWORD(v86) = v39;
      uint64_t result = -(int)result;
LABEL_73:
      if (result == -3 && v29 == 0)
      {
        uint64_t v30 = 0;
        int v29 = -2;
LABEL_79:
        uint64_t v5 = v86;
        if (BYTE2(v86) == 129)
        {
          uint64_t v27 = 1;
          uint64_t v28 = 33;
        }
        else if (BYTE2(v86) == 130)
        {
          uint64_t v27 = 2;
          uint64_t v28 = 34;
        }
        else
        {
          uint64_t v28 = (v86 >> 16) - 96;
          if (*(_DWORD *)(v11 + 108) == 1)
          {
            uint64_t v27 = 3;
          }
          else
          {
            int v29 = 0;
            uint64_t v27 = v27;
          }
        }
      }
LABEL_101:
      ++v26;
    }
    while (v26 < v33 && v29 < 1);
    uint64_t v2 = a2;
    unint64_t v3 = v74;
    uint64_t v12 = v71;
    uint64_t v7 = v72;
    uint64_t v8 = v75;
    if (!v29)
    {
LABEL_136:
      *uint64_t v2 = 10;
      *(_DWORD *)(v7 + 84) = v13;
      unint64_t v6 = v76;
      goto LABEL_149;
    }
    if (*(unsigned __int8 *)(v71 + v27) == v28)
    {
      unsigned int v52 = 0;
      unint64_t v10 = v70;
      unsigned int v4 = v77;
    }
    else
    {
      uint64_t v53 = (char)v28;
      if ((char)v28 >= 3) {
        uint64_t v53 = (char)v28 - 30;
      }
      LODWORD(v87[0]) = *(_DWORD *)(&off_1E5500D38)[v53];
      *(unsigned char *)(v71 + v27) = v28;
      unsigned int v4 = v77;
      if (v27 == 1) {
        unsigned int v4 = 0;
      }
      unsigned int v52 = 4;
      unint64_t v10 = v70;
    }
    unint64_t v9 = v69;
    if (*(char *)(v11 + 102) == v27)
    {
      unint64_t v6 = v76;
      goto LABEL_119;
    }
    unint64_t v6 = v76;
    if (v27 == 2)
    {
      unint64_t v55 = v52 | (unint64_t)v87;
      *(unsigned char *)unint64_t v55 = 27;
      v52 |= 2u;
      uint64_t v56 = (unsigned char *)(v55 | 1);
      char v57 = 78;
    }
    else
    {
      if (v27 == 1)
      {
        uint64_t v54 = v52;
        v52 |= 1u;
        *(unsigned char *)((unint64_t)v87 | v54) = 14;
        *(unsigned char *)(v11 + 102) = 1;
        goto LABEL_119;
      }
      unint64_t v58 = v52 | (unint64_t)v87;
      *(unsigned char *)unint64_t v58 = 27;
      v52 |= 2u;
      uint64_t v56 = (unsigned char *)(v58 | 1);
      char v57 = 79;
    }
    unsigned char *v56 = v57;
LABEL_119:
    int v18 = v52 + 2;
    *(_WORD *)((unint64_t)v87 | v52) = bswap32(v5) >> 16;
LABEL_120:
    if (v18 == 2)
    {
      if ((unint64_t)(v8 + 1) > v10) {
        goto LABEL_125;
      }
      *uint64_t v8 = v87[0];
      int v63 = v85;
      if (v85)
      {
        if (v13 >= 0x10000) {
          int v64 = -2;
        }
        else {
          int v64 = -1;
        }
        int v65 = (((unint64_t)v6 - *(void *)(v3 + 16)) >> 1) + v64;
        *int v85 = v65;
        int v85 = v63 + 2;
        v63[1] = v65;
      }
      ++v8;
LABEL_6:
      if ((unint64_t)v6 >= v9) {
        goto LABEL_138;
      }
      if ((unint64_t)v8 >= v10)
      {
        *uint64_t v2 = 15;
        goto LABEL_149;
      }
      unsigned int v15 = *v6++;
      unsigned int v13 = v15;
      if ((v15 & 0xF800) == 0xD800)
      {
        if ((v13 & 0x400) == 0) {
          continue;
        }
        goto LABEL_38;
      }
      goto LABEL_13;
    }
    break;
  }
  if (v18 == 1)
  {
    *(unsigned char *)uint64_t v8 = v87[0];
    uint64_t v8 = (_WORD *)((char *)v8 + 1);
    v59 = v85;
    if (v85)
    {
      *int v85 = (((unint64_t)v6 - *(void *)(v3 + 16)) >> 1) - 1;
      int v85 = v59 + 1;
    }
    goto LABEL_6;
  }
LABEL_125:
  unint64_t v60 = ((unint64_t)v6 - *(void *)(v3 + 16)) >> 1;
  if (v13 >= 0x10000) {
    int v61 = -2;
  }
  else {
    int v61 = -1;
  }
  int v86 = v8;
  uint64_t v62 = v5;
  uint64_t result = sub_18C85D210(v7, (char *)v87, v18, &v86, v10, &v85, (int)v60 + v61, v2);
  uint64_t v5 = v62;
  uint64_t v11 = v82;
  uint64_t v8 = v86;
  if (*v2 < 1) {
    goto LABEL_6;
  }
LABEL_149:
  *(void *)(v3 + 16) = v6;
  *(void *)(v3 + 32) = v8;
  return result;
}

void ucnv_enableCleanup()
{
}

BOOL sub_18C85B3C4()
{
  if (qword_1E9191CD0 && !uhash_count(qword_1E9191CD0))
  {
    uhash_close((unsigned char *)qword_1E9191CD0);
    qword_1E9191CD0 = 0;
  }
  word_1E9191CD8 = 0;
  if (qword_1E9191CE0)
  {
    uprv_free((void *)qword_1E9191CE0);
    qword_1E9191CE0 = 0;
  }
  atomic_store(0, &dword_1E9191CE8);
  return qword_1E9191CD0 == 0;
}

unsigned char *ucnv_load(uint64_t a1, UErrorCode *a2)
{
  if (!a2 || *(int *)a2 > 0) {
    return 0;
  }
  uint64_t v5 = *(unsigned char **)(a1 + 16);
  if (v5 && *v5)
  {
    return sub_18C85B514(a1, a2);
  }
  else if (qword_1E9191CD0 && (uint64_t result = (unsigned char *)uhash_get(qword_1E9191CD0, *(void *)(a1 + 24))) != 0)
  {
    ++*((_DWORD *)result + 1);
  }
  else
  {
    unint64_t v6 = sub_18C85B514(a1, a2);
    uint64_t result = 0;
    if (*(int *)a2 <= 0 && v6)
    {
      if (!*(unsigned char *)(a1 + 8)) {
        sub_18C85B688((uint64_t)v6);
      }
      return v6;
    }
  }
  return result;
}

unsigned char *sub_18C85B514(uint64_t a1, UErrorCode *a2)
{
  if (*(int *)a2 > 0) {
    return 0;
  }
  uint64_t v5 = udata_openChoice(*(char **)(a1 + 16), "cnv", *(const char **)(a1 + 24), (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18C85CCEC, 0, a2);
  uint64_t v2 = 0;
  if (*(int *)a2 > 0) {
    return v2;
  }
  uint64_t v7 = v5;
  uint64_t Memory = udata_getMemory((uint64_t)v5);
  if (*(int *)a2 <= 0)
  {
    unint64_t v9 = (char *)Memory;
    __int16 v10 = *(char *)(Memory + 69);
    if ((v10 & 0xFFFEu) <= 0x21
      && ((0x203uLL >> v10) & 1) == 0
      && (uint64_t v11 = qword_1E5500D88[*(char *)(Memory + 69)], *(unsigned char *)(v11 + 25))
      && *(_DWORD *)(v11 + 4) == 1
      && *(_DWORD *)Memory == 100)
    {
      uint64_t v12 = uprv_malloc(0x128uLL);
      if (v12)
      {
        uint64_t v2 = v12;
        memcpy(v12, (const void *)v11, 0x128uLL);
        v2[24] = 0;
        *((void *)v2 + 1) = v7;
        *((void *)v2 + 2) = v9;
        unsigned int v13 = *(void (**)(unsigned char *, uint64_t, char *, UErrorCode *))(*((void *)v2 + 4) + 8);
        if (v13)
        {
          v13(v2, a1, &v9[*(unsigned int *)v9], a2);
          if (*(int *)a2 < 1) {
            return v2;
          }
          uprv_free(v2);
          uint64_t v2 = 0;
        }
        if (*(int *)a2 < 1) {
          return v2;
        }
        goto LABEL_19;
      }
      int v14 = 7;
    }
    else
    {
      int v14 = 13;
    }
    *a2 = v14;
  }
LABEL_19:
  udata_close(v7);
  return 0;
}

void sub_18C85B688(uint64_t a1)
{
  int v4 = 0;
  uint64_t v2 = qword_1E9191CD0;
  if (qword_1E9191CD0) {
    goto LABEL_2;
  }
  int v3 = ucnv_io_countKnownConverters((UErrorCode *)&v4);
  qword_1E9191CD0 = (uint64_t)uhash_openSize((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, 2 * v3, &v4);
  sub_18C8546F4(0x16u, (uint64_t)sub_18C85B3C4);
  if (v4 <= 0)
  {
    uint64_t v2 = qword_1E9191CD0;
LABEL_2:
    *(unsigned char *)(a1 + 24) = 1;
    uhash_put(v2, *(void *)(a1 + 16) + 4, a1, &v4);
  }
}

void ucnv_unload(uint64_t a1)
{
  if (a1)
  {
    int v1 = *(_DWORD *)(a1 + 4);
    if (!v1 || (int v2 = v1 - 1, (*(_DWORD *)(a1 + 4) = v2) == 0))
    {
      if (!*(unsigned char *)(a1 + 24)) {
        sub_18C85B770(a1);
      }
    }
  }
}

void sub_18C85B770(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 4))
  {
    int v2 = *(void (**)(uint64_t))(*(void *)(a1 + 32) + 16);
    if (v2) {
      v2(a1);
    }
    int v3 = *(_OWORD **)(a1 + 8);
    if (v3) {
      udata_close(v3);
    }
    uprv_free((void *)a1);
  }
}

void sub_18C85B7D8(uint64_t a1)
{
  if (a1 && *(unsigned char *)(a1 + 25))
  {
    umtx_lock((atomic_ullong *)&unk_1E9191CF0);
    ucnv_unload(a1);
    umtx_unlock((std::mutex **)&unk_1E9191CF0);
  }
}

void sub_18C85B83C(uint64_t a1)
{
  if (a1 && *(unsigned char *)(a1 + 25))
  {
    umtx_lock((atomic_ullong *)&unk_1E9191CF0);
    ++*(_DWORD *)(a1 + 4);
    umtx_unlock((std::mutex **)&unk_1E9191CF0);
  }
}

unsigned char *sub_18C85B8A4(unsigned __int8 *a1, _OWORD *a2, long long *a3, UErrorCode *a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v21 = 0;
  char v20 = 1;
  if (*(int *)a4 > 0) {
    return 0;
  }
  unint64_t v6 = a3;
  uint64_t v7 = a2;
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  if (a2)
  {
    if (a3) {
      goto LABEL_11;
    }
  }
  else
  {
    if (a3)
    {
      uint64_t result = 0;
      *a4 = U_INTERNAL_PROGRAM_ERROR;
      return result;
    }
    uint64_t v7 = v25;
  }
  uint64_t v24 = 0;
  long long v22 = 0uLL;
  long long v23 = 0uLL;
  LODWORD(v22) = 40;
  unint64_t v6 = &v22;
LABEL_11:
  memset(v25, 0, sizeof(v25));
  *(unsigned char *)uint64_t v7 = 0;
  *((unsigned char *)v7 + 60) = 0;
  *((_DWORD *)v7 + 55) = 0;
  *((void *)v6 + 3) = a1;
  *((void *)v6 + 4) = (char *)v7 + 60;
  *((_DWORD *)v6 + 3) = 0;
  if (!a1) {
    goto LABEL_23;
  }
  int v8 = *a1;
  if (v8 != 117)
  {
    if (v8 != 85 || a1[1] != 84 || a1[2] != 70) {
      goto LABEL_25;
    }
    goto LABEL_19;
  }
  if (a1[1] == 116 && a1[2] == 102)
  {
LABEL_19:
    int v9 = a1[3];
    if (v9 == 56)
    {
      if (a1[4]) {
        goto LABEL_25;
      }
    }
    else if (v9 != 45 || a1[4] != 56 || a1[5])
    {
      goto LABEL_25;
    }
LABEL_23:
    *((void *)v6 + 3) = "UTF-8";
    return &unk_1E5502C58;
  }
LABEL_25:
  sub_18C85BBBC((uint64_t)a1, (uint64_t)v7, (uint64_t)v6, a4);
  if (*(int *)a4 > 0) {
    return 0;
  }
  uint64_t ConverterName = ucnv_io_getConverterName(*((char **)v6 + 3), &v20, (UErrorCode *)&v21);
  *((void *)v6 + 3) = ConverterName;
  if (v21 <= 0 && (uint64_t v11 = (unsigned char *)ConverterName) != 0)
  {
    if (v21 == -122) {
      *a4 = U_AMBIGUOUS_ALIAS_WARNING;
    }
  }
  else
  {
    *((void *)v6 + 3) = v7;
    uint64_t v11 = v7;
  }
  if (v20)
  {
    if (v11 == (unsigned char *)v7)
    {
      uint64_t v11 = v7;
    }
    else
    {
      sub_18C85BBBC((uint64_t)v11, (uint64_t)v7, (uint64_t)v6, a4);
      uint64_t v11 = (unsigned char *)*((void *)v6 + 3);
    }
  }
  memset(__s1, 0, 60);
  ucnv_io_stripASCIIForCompare(__s1, v11);
  int v12 = 0;
  uint64_t v13 = 34;
  uint64_t v14 = 17;
  while (1)
  {
    int v15 = strcmp((const char *)__s1, (&off_1E5500E98)[2 * v14]);
    uint64_t v16 = v14;
    if ((v15 & 0x80000000) == 0)
    {
      int v12 = v14;
      uint64_t v16 = v13;
      if (!v15) {
        break;
      }
    }
    BOOL v17 = v14 == (v16 + v12) >> 1;
    uint64_t v14 = (v16 + v12) >> 1;
    uint64_t v13 = v16;
    if (v17) {
      goto LABEL_43;
    }
  }
  uint64_t v18 = SLODWORD((&off_1E5500E98)[2 * v14 + 1]);
  if (((0x203uLL >> v18) & 1) == 0) {
    return (unsigned char *)qword_1E5500D88[v18];
  }
LABEL_43:
  *((_DWORD *)v6 + 1) = 1;
  *((void *)v6 + 2) = 0;
  umtx_lock((atomic_ullong *)&unk_1E9191CF0);
  char v19 = ucnv_load((uint64_t)v6, a4);
  umtx_unlock((std::mutex **)&unk_1E9191CF0);
  uint64_t result = 0;
  if (*(int *)a4 <= 0 && v19) {
    return v19;
  }
  return result;
}

uint64_t sub_18C85BBBC(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7 = 0;
  int v8 = (unsigned char *)(a2 + 60);
  *(void *)(a3 + 24) = result;
  *(void *)(a3 + 32) = a2 + 60;
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 220);
  while (1)
  {
    int v9 = *(unsigned __int8 *)(result + v7);
    if (!*(unsigned char *)(result + v7) || v9 == 44) {
      break;
    }
    if (v7 == 59)
    {
      *a4 = 1;
      *(unsigned char *)a2 = 0;
      return result;
    }
    *(unsigned char *)(a2 + v7++) = v9;
  }
  *(unsigned char *)(a2 + v7) = 0;
  *(void *)(a3 + 24) = a2;
  __int16 v10 = (unsigned char *)(result + v7);
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_7:
        if (*v10 == 44)
        {
          uint64_t v11 = v10 + 1;
        }
        else
        {
          uint64_t v11 = v10;
          if (!*v10) {
            return result;
          }
        }
        uint64_t result = strncmp(v11, "locale=", 7uLL);
        if (result) {
          break;
        }
        for (uint64_t i = 0; ; ++i)
        {
          int v15 = v11[i + 7];
          if (!v11[i + 7] || v15 == 44)
          {
            v8[i] = 0;
            __int16 v10 = &v11[i + 7];
            if (!v15) {
              goto LABEL_7;
            }
            goto LABEL_30;
          }
          if (i == 156) {
            break;
          }
          v8[i] = v15;
        }
        *a4 = 1;
        *int v8 = 0;
        __int16 v10 = &v11[i + 8];
        if (!v15) {
          continue;
        }
LABEL_30:
        if (v15 != 44) {
          return result;
        }
      }
      uint64_t result = strncmp(v11, "version=", 8uLL);
      if (!result) {
        break;
      }
      uint64_t result = strncmp(v11, "swaplfnl", 8uLL);
      if (result)
      {
        __int16 v10 = v11;
        while (1)
        {
          int v13 = *v10++;
          int v12 = v13;
          if (v13 == 44) {
            break;
          }
          if (!v12) {
            return result;
          }
        }
      }
      else
      {
        __int16 v10 = v11 + 8;
        int v18 = *(_DWORD *)(a2 + 220) | 0x10;
        *(_DWORD *)(a2 + 220) = v18;
        *(_DWORD *)(a3 + 12) = v18;
      }
    }
    __int16 v10 = v11 + 8;
    if (!v11[8]) {
      break;
    }
    int v16 = (char)v11[8] - 48;
    if ((v16 & 0xFEu) <= 9)
    {
      unsigned int v17 = *(_DWORD *)(a2 + 220) & 0xFFFFFFF0 | v16;
      *(_DWORD *)(a2 + 220) = v17;
      *(_DWORD *)(a3 + 12) = v17;
      __int16 v10 = v11 + 9;
    }
  }
  unsigned int v19 = *(_DWORD *)(a2 + 220) & 0xFFFFFFF0;
  *(_DWORD *)(a2 + 220) = v19;
  *(_DWORD *)(a3 + 12) = v19;
  return result;
}

_OWORD *ucnv_createConverter(_OWORD *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  LODWORD(v7[0]) = 40;
  if (*(int *)a3 > 0) {
    return 0;
  }
  memset(v9, 0, sizeof(v9));
  uint64_t v5 = sub_18C85B8A4(a2, v9, v7, a3);
  uint64_t result = sub_18C85BE78(a1, (uint64_t)v5, (uint64_t)v7, (int *)a3);
  if (*(int *)a3 >= 1) {
    return 0;
  }
  return result;
}

_OWORD *sub_18C85BE78(_OWORD *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v5 = a1;
  if (*a4 >= 1) {
    goto LABEL_2;
  }
  if (a1)
  {
    char v9 = 1;
  }
  else
  {
    uint64_t v5 = uprv_malloc(0x120uLL);
    if (!v5)
    {
      *a4 = 7;
LABEL_2:
      sub_18C85B7D8(a2);
      return v5;
    }
    char v9 = 0;
  }
  v5[16] = 0u;
  v5[17] = 0u;
  v5[14] = 0u;
  v5[15] = 0u;
  v5[12] = 0u;
  v5[13] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  *uint64_t v5 = 0u;
  v5[1] = 0u;
  *((unsigned char *)v5 + 61) = v9;
  *((void *)v5 + 6) = a2;
  *((_DWORD *)v5 + 14) = *(_DWORD *)(a3 + 12);
  if (!*(unsigned char *)(a3 + 8))
  {
    *((_DWORD *)v5 + 52) = -1;
    *((void *)v5 + 1) = UCNV_TO_U_CALLBACK_SUBSTITUTE;
    *(void *)uint64_t v5 = UCNV_FROM_U_CALLBACK_SUBSTITUTE;
    *((_DWORD *)v5 + 18) = *(_DWORD *)(a2 + 40);
    uint64_t v10 = *(unsigned char **)(a2 + 16);
    *((unsigned char *)v5 + 88) = v10[71];
    *((unsigned char *)v5 + 94) = v10[80];
    size_t v11 = (char)v10[76];
    *((unsigned char *)v5 + 89) = v11;
    *((void *)v5 + 5) = (char *)v5 + 136;
    memcpy((char *)v5 + 136, v10 + 72, v11);
    *((_DWORD *)v5 + 71) = 1;
  }
  int v12 = *(void (**)(_OWORD *, uint64_t, int *))(*(void *)(a2 + 32) + 24);
  if (v12)
  {
    v12(v5, a3, a4);
    if (*a4 >= 1 && !*(unsigned char *)(a3 + 8))
    {
      ucnv_close(v5);
      return 0;
    }
  }
  return v5;
}

BOOL sub_18C85BFD4(unsigned __int8 *a1, UErrorCode *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  LODWORD(v6[0]) = 40;
  UErrorCode v2 = *a2;
  if (*(int *)a2 <= 0)
  {
    memset(v9, 0, sizeof(v9));
    memset(v8, 0, sizeof(v8));
    BYTE8(v6[0]) = 1;
    int v4 = sub_18C85B8A4(a1, v8, v6, a2);
    sub_18C85BE78(v9, (uint64_t)v4, (uint64_t)v6, (int *)a2);
    sub_18C85B7D8((uint64_t)v4);
    UErrorCode v2 = *a2;
  }
  return v2 < U_ILLEGAL_ARGUMENT_ERROR;
}

_OWORD *sub_18C85C0D4(_OWORD *a1, unsigned int a2, uint64_t a3, int a4, int *a5)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v7 = 40;
  if (a2 >= 0x22 || ((0x203uLL >> a2) & 1) != 0 || (uint64_t v5 = qword_1E5500D88[a2], *(unsigned char *)(v5 + 25)))
  {
    uint64_t result = 0;
    *a5 = 1;
  }
  else
  {
    HIDWORD(v8) = a4;
    uint64_t v10 = "";
    uint64_t v11 = a3;
    return sub_18C85BE78(a1, v5, (uint64_t)&v7, a5);
  }
  return result;
}

void *ucnv_openPackage_0(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  long long v8 = 0u;
  long long v9 = 0u;
  v7[0] = 40;
  if (*(int *)a3 <= 0)
  {
    long long v19 = 0uLL;
    memset(v20, 0, sizeof(v20));
    long long v17 = 0uLL;
    long long v18 = 0uLL;
    long long v15 = 0uLL;
    long long v16 = 0uLL;
    long long v14 = 0uLL;
    long long v12 = 0uLL;
    long long v13 = 0uLL;
    long long v11 = 0uLL;
    memset(v10, 0, sizeof(v10));
    LOBYTE(v10[0]) = 0;
    BYTE12(v11) = 0;
    int v21 = 0;
    sub_18C85BBBC(a2, (uint64_t)v10, (uint64_t)v7, a3);
    if (*(int *)a3 <= 0)
    {
      v7[1] = 1;
      *((void *)&v8 + 1) = a1;
      uint64_t v5 = sub_18C85B514((uint64_t)v7, a3);
      if (*(int *)a3 <= 0)
      {
        uint64_t result = sub_18C85BE78(0, (uint64_t)v5, (uint64_t)v7, (int *)a3);
        if (*(int *)a3 < 1) {
          return result;
        }
        ucnv_close(result);
      }
    }
  }
  return 0;
}

uint64_t ucnv_flushCache()
{
  u_flushDefaultConverter();
  if (!qword_1E9191CD0) {
    return 0;
  }
  umtx_lock((atomic_ullong *)&unk_1E9191CF0);
  uint64_t v0 = 0;
  char v1 = 1;
  do
  {
    int v8 = -1;
    uint64_t v2 = uhash_nextElement((uint64_t *)qword_1E9191CD0, &v8);
    if (!v2) {
      break;
    }
    uint64_t v3 = v2;
    int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v3 + 8);
      if (*(_DWORD *)(v5 + 4))
      {
        ++v4;
      }
      else
      {
        uint64_t v0 = (v0 + 1);
        uhash_removeElement(qword_1E9191CD0, (_DWORD *)v3);
        *(unsigned char *)(v5 + 24) = 0;
        sub_18C85B770(v5);
      }
      uint64_t v3 = uhash_nextElement((uint64_t *)qword_1E9191CD0, &v8);
    }
    while (v3);
    char v6 = v1 & (v4 > 0);
    char v1 = 0;
  }
  while ((v6 & 1) != 0);
  umtx_unlock((std::mutex **)&unk_1E9191CF0);
  return v0;
}

uint64_t sub_18C85C354(UErrorCode *a1)
{
  BOOL v1 = sub_18C85C380(a1);
  unsigned __int16 v2 = word_1E9191CD8;
  if (!v1) {
    return 0;
  }
  return v2;
}

BOOL sub_18C85C380(UErrorCode *a1)
{
  if (*(int *)a1 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191CE8, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191CE8))
    {
      if (dword_1E9191CEC >= 1) {
        *a1 = dword_1E9191CEC;
      }
    }
    else
    {
      sub_18C85CD5C(a1);
      dword_1E9191CEC = *a1;
      icu::umtx_initImplPostInit(&dword_1E9191CE8);
    }
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t sub_18C85C410(unsigned int a1, UErrorCode *a2)
{
  if (!sub_18C85C380(a2)) {
    return 0;
  }
  if ((unsigned __int16)word_1E9191CD8 > a1) {
    return *(void *)(qword_1E9191CE0 + 8 * a1);
  }
  uint64_t result = 0;
  *a2 = U_INDEX_OUTOFBOUNDS_ERROR;
  return result;
}

const char *ucnv_getDefaultName()
{
  return "UTF-8";
}

uint64_t ucnv_swap(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a3;
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), *(unsigned __int8 *)(a2 + 12)) != 0x6E00000063
    || *(unsigned char *)(a2 + 14) != 118
    || *(unsigned char *)(a2 + 15) != 116
    || *(unsigned char *)(a2 + 16) != 6
    || *(unsigned __int8 *)(a2 + 17) <= 1u)
  {
    uint64_t v62 = *(unsigned __int8 *)(a2 + 12);
    uint64_t v27 = "ucnv_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not recognized as an ICU .cnv conversion table\n";
LABEL_18:
    udata_printError(a1, (uint64_t)v27, v14, v15, v16, v17, v18, v19, v62);
LABEL_19:
    uint64_t result = 0;
    int v26 = 16;
    goto LABEL_20;
  }
  int v21 = v13;
  uint64_t v22 = (char *)(a2 + v13);
  if (a4) {
    long long v23 = (char *)a4 + v13;
  }
  else {
    long long v23 = 0;
  }
  if ((v10 & 0x80000000) != 0)
  {
    unsigned int v28 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)v22);
    uint64_t v29 = v28;
    uint64_t v30 = &v23[v28];
  }
  else
  {
    uint64_t v24 = (v10 - v13);
    if ((int)v24 < 100
      || (unsigned int v25 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)v22),
          uint64_t v10 = v24 - v25,
          v24 < v25))
    {
      udata_printError(a1, (uint64_t)"ucnv_swap(): too few bytes (%d after header) for an ICU .cnv conversion table\n", v14, v15, v16, v17, v18, v19, v24);
LABEL_16:
      uint64_t result = 0;
      int v26 = 8;
LABEL_20:
      *a5 = v26;
      return result;
    }
    unsigned int v28 = v25;
    if (v22 != v23) {
      memcpy(v23, v22, v25);
    }
    (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(a1 + 56))(a1, v22, 4, v23, a5);
    (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 56))(a1, (unsigned int *)v22 + 16, 4, v23 + 64, a5);
    size_t v32 = strlen(v22 + 4);
    (*(void (**)(uint64_t, unsigned int *, size_t, char *, int *))(a1 + 72))(a1, (unsigned int *)v22 + 1, v32, v23 + 4, a5);
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"ucnv_swap(): error swapping converter name\n", v14, v15, v16, v17, v18, v19, v62);
      return 0;
    }
    uint64_t v29 = v28;
    uint64_t v30 = &v23[v28];
  }
  if (v23) {
    int v31 = v30;
  }
  else {
    int v31 = 0;
  }
  if (v22[69] != 2)
  {
    udata_printError(a1, (uint64_t)"ucnv_swap(): unknown conversionType=%d!=UCNV_MBCS\n", v14, v15, v16, v17, v18, v19, v22[69]);
    goto LABEL_19;
  }
  if (v10 <= 0x27)
  {
LABEL_27:
    udata_printError(a1, (uint64_t)"ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table\n", v14, v15, v16, v17, v18, v19, v10);
    goto LABEL_16;
  }
  unint64_t v33 = &v22[v29];
  unsigned int v34 = v22[v29];
  if (v34 == 5)
  {
    if (v33[1] < 3u)
    {
      unsigned int v34 = 5;
    }
    else
    {
      unsigned int v35 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 8));
      if ((v35 & 0xFF80) == 0)
      {
        int v78 = (v35 >> 6) & 1;
        unsigned int v73 = 4 * (v35 & 0x3F);
        unsigned int v75 = v33[1];
        goto LABEL_45;
      }
      unsigned int v34 = *v33;
    }
LABEL_43:
    udata_printError(a1, (uint64_t)"ucnv_swap(): unsupported _MBCSHeader.version %d.%d\n", v14, v15, v16, v17, v18, v19, v34);
    goto LABEL_19;
  }
  if (v34 != 4) {
    goto LABEL_43;
  }
  if (!v33[1])
  {
    unsigned int v34 = 4;
    goto LABEL_43;
  }
  unsigned int v75 = v33[1];
  int v78 = 0;
  unsigned int v73 = 32;
LABEL_45:
  int v71 = v33[2];
  int v68 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 1));
  int v67 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 2));
  int v69 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 3));
  int v70 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 4));
  int v74 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 5));
  unsigned int v36 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 6));
  unsigned int v37 = (*(uint64_t (**)(void))(a1 + 16))(*((unsigned int *)v33 + 7));
  unsigned int v77 = v36;
  if (v78 && !(_BYTE)v36)
  {
    uint64_t v27 = "ucnv_swap(): unsupported combination of makeconv --small with SBCS\n";
    goto LABEL_18;
  }
  unsigned int v66 = v37;
  if (v36 > 0xEu || ((1 << v36) & 0x530F) == 0)
  {
    udata_printError(a1, (uint64_t)"ucnv_swap(): unsupported MBCS output type 0x%x\n", v14, v15, v16, v17, v18, v19, v36);
    goto LABEL_19;
  }
  int v64 = v36;
  if (v75 >= 3 && (_BYTE)v36)
  {
    unsigned int v38 = ((v71 << 8) + 256) >> 5;
    if (!v71) {
      unsigned int v38 = 0;
    }
    if (v36 == 14) {
      unsigned int v39 = 0;
    }
    else {
      unsigned int v39 = v38;
    }
    unsigned int v65 = v39;
  }
  else
  {
    unsigned int v65 = 0;
  }
  unsigned int v72 = v36 >> 8;
  if (v36 > 0xFF)
  {
    if ((v10 & 0x80000000) == 0 && (int)v10 < (int)(v72 + 128))
    {
      udata_printError(a1, (uint64_t)"ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table with extension data\n", v14, v15, v16, v17, v18, v19, v10);
      goto LABEL_16;
    }
    int v63 = (unsigned int *)&v33[v72];
    int v41 = udata_readInt32(a1, v63[31]) + v72;
  }
  else
  {
    int v63 = 0;
    unsigned int v40 = v37;
    if (v78) {
      unsigned int v40 = 0;
    }
    int v41 = v40 + v74 + v65;
  }
  int v76 = v41;
  if ((v10 & 0x80000000) == 0)
  {
    if ((int)v10 < v41) {
      goto LABEL_27;
    }
    if (v33 != v31) {
      memcpy(v31, v33, v41);
    }
    (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 56))(a1, (unsigned __int8 *)v33 + 4, v73 - 4, v31 + 4, a5);
    if (v36 == 14)
    {
      size_t v42 = strlen(&v33[v73]);
      (*(void (**)(uint64_t, char *, size_t, char *, int *))(a1 + 72))(a1, &v33[v73], v42, &v31[v73], a5);
      goto LABEL_91;
    }
    (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 56))(a1, &v33[v73], (v68 << 10), &v31[v73], a5);
    (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 56))(a1, &v33[v73 & 0x3FF | (v68 << 10)], (8 * v67), &v31[v73 & 0x3FF | (v68 << 10)], a5);
    uint64_t v43 = (void (**)(uint64_t, unsigned __int8 *, uint64_t, char *, int *))(a1 + 48);
    (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 48))(a1, &v33[v69], (v70 - v69), &v31[v69], a5);
    if (!v64)
    {
      (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 48))(a1, &v33[v70], v74 - v70 + v66, &v31[v70], a5);
LABEL_91:
      if (v77 >= 0x100)
      {
        uint64_t v46 = (unsigned __int8 *)&v33[v72];
        int v47 = &v31[v72];
        int Int32 = udata_readInt32(a1, v63[1]);
        int v49 = udata_readInt32(a1, v63[2]);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 56))(a1, &v46[Int32], (4 * v49), &v47[Int32], a5);
        int v50 = udata_readInt32(a1, v63[3]);
        int v51 = udata_readInt32(a1, v63[4]);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 48))(a1, &v46[v50], (2 * v51), &v47[v50], a5);
        int v52 = udata_readInt32(a1, v63[5]);
        int v53 = udata_readInt32(a1, v63[7]);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 48))(a1, &v46[v52], (2 * v53), &v47[v52], a5);
        int v54 = udata_readInt32(a1, v63[6]);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 56))(a1, &v46[v54], (4 * v53), &v47[v54], a5);
        int v55 = udata_readInt32(a1, v63[10]);
        int v56 = udata_readInt32(a1, v63[12]);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 48))(a1, &v46[v55], (2 * v56), &v47[v55], a5);
        int v57 = udata_readInt32(a1, v63[13]);
        int v58 = udata_readInt32(a1, v63[14]);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 48))(a1, &v46[v57], (2 * v58), &v47[v57], a5);
        int v59 = udata_readInt32(a1, v63[15]);
        int v60 = udata_readInt32(a1, v63[16]);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 56))(a1, &v46[v59], (4 * v60), &v47[v59], a5);
        int v61 = udata_readInt32(a1, *v63);
        (*(void (**)(uint64_t, unsigned __int8 *, void, char *, int *))(a1 + 56))(a1, v46, (4 * v61), v47, a5);
      }
      return v28 + v21 + v76;
    }
    if (v22[79]) {
      uint64_t v44 = 2176;
    }
    else {
      uint64_t v44 = 128;
    }
    (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(a1 + 48))(a1, &v33[v70], v44, &v31[v70], a5);
    (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 56))(a1, &v33[(v44 + v70)], (v74 - (v44 + v70)), &v31[(v44 + v70)], a5);
    if (v78) {
      uint64_t v45 = 0;
    }
    else {
      uint64_t v45 = v66;
    }
    if (v77 > 7u)
    {
      if (v77 != 8 && v77 != 12)
      {
LABEL_89:
        if (v65) {
          (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 48))(a1, &v33[(v45 + v74)], v65, &v31[(v45 + v74)], a5);
        }
        goto LABEL_91;
      }
    }
    else if (v77 != 1)
    {
      if (v77 != 3) {
        goto LABEL_89;
      }
      uint64_t v43 = (void (**)(uint64_t, unsigned __int8 *, uint64_t, char *, int *))(a1 + 56);
    }
    (*v43)(a1, (unsigned __int8 *)&v33[v74], v45, &v31[v74], a5);
    goto LABEL_89;
  }
  return v28 + v21 + v76;
}

BOOL sub_18C85CCEC(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[6] == 2
      && a4[8] == 99
      && a4[9] == 110
      && a4[10] == 118
      && a4[11] == 116
      && a4[12] == 6;
}

void sub_18C85CD5C(UErrorCode *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  sub_18C8546F4(0x16u, (uint64_t)sub_18C85B3C4);
  unsigned __int16 v2 = (void **)ucnv_openAllNames(a1);
  int v3 = uenum_count((uint64_t)v2, (int *)a1);
  if (*(int *)a1 <= 0)
  {
    int v4 = v3;
    qword_1E9191CE0 = (uint64_t)uprv_malloc(8 * v3);
    if (qword_1E9191CE0)
    {
      int v8 = 0;
      memset(v9, 0, sizeof(v9));
      Converter = ucnv_createConverter(v9, 0, (UErrorCode *)&v8);
      ucnv_close(Converter);
      word_1E9191CD8 = 0;
      if (v4 >= 1)
      {
        do
        {
          int v8 = 0;
          char v6 = (unsigned __int8 *)uenum_next((uint64_t)v2, 0, &v8);
          if (sub_18C85BFD4(v6, (UErrorCode *)&v8))
          {
            uint64_t v7 = (unsigned __int16)word_1E9191CD8++;
            *(void *)(qword_1E9191CE0 + 8 * v7) = v6;
          }
          --v4;
        }
        while (v4);
      }
      uenum_close(v2);
    }
    else
    {
      *a1 = U_MEMORY_ALLOCATION_ERROR;
    }
  }
}

void *ucnv_cbFromUWriteBytes(void *result, char *a2, int a3, int a4, int *a5)
{
  if (*a5 <= 0) {
    return (void *)sub_18C85D210(result[1], a2, a3, result + 4, result[5], result + 6, a4, a5);
  }
  return result;
}

uint64_t ucnv_cbFromUWriteUChars(uint64_t result, unint64_t *a2, unint64_t a3, int a4, int *a5)
{
  if (*a5 <= 0)
  {
    uint64_t v9 = result;
    uint64_t v10 = (uint64_t *)(result + 32);
    uint64_t v11 = *(void *)(result + 32);
    uint64_t result = ucnv_fromUnicode(*(void *)(result + 8), (uint64_t *)(result + 32), *(void *)(result + 40), a2, a3, 0, 0, a5);
    long long v12 = (_DWORD *)v10[2];
    if (v12)
    {
      uint64_t v13 = *v10;
      if (*v10 != v11)
      {
        do
        {
          *v12++ = a4;
          ++v11;
        }
        while (v11 != v13);
        *(void *)(v9 + 48) = v12;
      }
    }
    if (*a5 == 15)
    {
      int v16 = 0;
      uint64_t result = *(void *)(v9 + 8);
      unint64_t v17 = result + *(char *)(result + 91) + 104;
      unint64_t v14 = result + 136;
      if (v17 >= result + 136
        || (*(unsigned char *)(result + 91) = 0,
            uint64_t result = ucnv_fromUnicode(result, (uint64_t *)&v17, result + 136, a2, a3, 0, 0, &v16),
            unint64_t v15 = v17,
            *(unsigned char *)(*(void *)(v9 + 8) + 91) = v17 - *(void *)(v9 + 8) - 104,
            v15 >= v14)
        || v16 == 15)
      {
        *a5 = 5;
      }
    }
  }
  return result;
}

uint64_t ucnv_cbFromUWriteSub(uint64_t result, int a2, int *a3)
{
  if (*a3 <= 0)
  {
    uint64_t v4 = *(void *)(result + 8);
    int v5 = *(char *)(v4 + 89);
    if (*(unsigned char *)(v4 + 89))
    {
      if (v5 < 0)
      {
        return ucnv_cbFromUWriteUChars(result, &v13, *(void *)(v4 + 40) - 2 * *(char *)(v4 + 89), a2, a3);
      }
      else
      {
        uint64_t v7 = *(uint64_t (**)(void))(*(void *)(*(void *)(v4 + 48) + 32) + 104);
        if (v7)
        {
          return v7();
        }
        else
        {
          int v8 = (char *)(v4 + 94);
          if (*(unsigned char *)(v4 + 94) && *(unsigned __int16 *)(v4 + 140) <= 0xFFu)
          {
            uint64_t v9 = (void *)(result + 32);
            unint64_t v10 = *(void *)(result + 40);
            uint64_t v11 = (void *)(result + 48);
            uint64_t v12 = *(void *)(result + 8);
            int v5 = 1;
          }
          else
          {
            int v8 = *(char **)(v4 + 40);
            uint64_t v9 = (void *)(result + 32);
            unint64_t v10 = *(void *)(result + 40);
            uint64_t v11 = (void *)(result + 48);
            uint64_t v12 = *(void *)(result + 8);
          }
          return sub_18C85D210(v12, v8, v5, v9, v10, v11, a2, a3);
        }
      }
    }
  }
  return result;
}

uint64_t ucnv_cbToUWriteUChars(uint64_t result, __int16 *a2, int a3, int a4, int *a5)
{
  if (*a5 <= 0) {
    return sub_18C85D2B8(*(void *)(result + 8), a2, a3, (_WORD **)(result + 32), *(void *)(result + 40), (void *)(result + 48), a4, a5);
  }
  return result;
}

uint64_t ucnv_cbToUWriteSub(uint64_t a1, int a2, int *a3)
{
  uint64_t result = *(void *)(a1 + 8);
  if (*(unsigned char *)(result + 90) == 1 && *(unsigned char *)(result + 94))
  {
    if (*a3 < 1)
    {
      char v6 = (__int16 *)&unk_18CA7FA5E;
      return sub_18C85D2B8(result, v6, 1, (_WORD **)(a1 + 32), *(void *)(a1 + 40), (void *)(a1 + 48), a2, a3);
    }
  }
  else if (*a3 <= 0)
  {
    char v6 = (__int16 *)&unk_18CA7FA60;
    return sub_18C85D2B8(result, v6, 1, (_WORD **)(a1 + 32), *(void *)(a1 + 40), (void *)(a1 + 48), a2, a3);
  }
  return result;
}

uint64_t sub_18C85D1A8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(a2 + 16))(*(void *)a2, 0, 1114111);
}

uint64_t sub_18C85D1BC(uint64_t a1, uint64_t *a2)
{
  ((void (*)(void, void, uint64_t))a2[2])(*a2, 0, 55295);
  int v3 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[2];
  uint64_t v4 = *a2;

  return v3(v4, 57344, 1114111);
}

uint64_t sub_18C85D210(uint64_t result, char *a2, int a3, void *a4, unint64_t a5, void *a6, int a7, _DWORD *a8)
{
  int v8 = (unsigned char *)*a4;
  if (a6 && (uint64_t v9 = (_DWORD *)*a6) != 0)
  {
    if (a3 >= 1)
    {
      do
      {
        if ((unint64_t)v8 >= a5) {
          break;
        }
        unsigned int v10 = a3;
        char v11 = *a2++;
        *v8++ = v11;
        *v9++ = a7;
        --a3;
      }
      while (v10 >= 2);
    }
    *a6 = v9;
  }
  else if (a3 >= 1)
  {
    do
    {
      if ((unint64_t)v8 >= a5) {
        break;
      }
      unsigned int v12 = a3;
      char v13 = *a2++;
      *v8++ = v13;
      --a3;
    }
    while (v12 >= 2);
  }
  *a4 = v8;
  if (a3 >= 1)
  {
    if (result)
    {
      unint64_t v14 = (unsigned char *)(result + 104);
      *(unsigned char *)(result + 91) = a3;
      unsigned int v15 = a3 + 1;
      do
      {
        char v16 = *a2++;
        *v14++ = v16;
        --v15;
      }
      while (v15 > 1);
    }
    *a8 = 15;
  }
  return result;
}

uint64_t sub_18C85D2B8(uint64_t result, __int16 *a2, int a3, _WORD **a4, unint64_t a5, void *a6, int a7, _DWORD *a8)
{
  int v8 = *a4;
  if (a6 && (uint64_t v9 = (_DWORD *)*a6) != 0)
  {
    if (a3 >= 1)
    {
      do
      {
        if ((unint64_t)v8 >= a5) {
          break;
        }
        unsigned int v10 = a3;
        __int16 v11 = *a2++;
        *v8++ = v11;
        *v9++ = a7;
        --a3;
      }
      while (v10 >= 2);
    }
    *a6 = v9;
  }
  else if (a3 >= 1)
  {
    do
    {
      if ((unint64_t)v8 >= a5) {
        break;
      }
      unsigned int v12 = a3;
      __int16 v13 = *a2++;
      *v8++ = v13;
      --a3;
    }
    while (v12 >= 2);
  }
  *a4 = v8;
  if (a3 >= 1)
  {
    if (result)
    {
      unint64_t v14 = (_WORD *)(result + 144);
      *(unsigned char *)(result + 93) = a3;
      unsigned int v15 = a3 + 1;
      do
      {
        __int16 v16 = *a2++;
        *v14++ = v16;
        --v15;
      }
      while (v15 > 1);
    }
    *a8 = 15;
  }
  return result;
}

uint64_t sub_18C85D360(uint64_t result, unsigned int a2, unint64_t *a3, unint64_t a4, _DWORD **a5, int a6, _DWORD *a7)
{
  uint64_t v7 = (_WORD *)*a3;
  int v8 = (_WORD *)*a3;
  if (*a3 >= a4) {
    goto LABEL_13;
  }
  if ((int)a2 < 0x10000)
  {
    int v9 = 0;
    *int v8 = a2;
    a2 = -1;
LABEL_7:
    uint64_t v11 = 1;
    goto LABEL_8;
  }
  *int v8 = (a2 >> 10) - 10304;
  unsigned int v10 = v8 + 1;
  if ((unint64_t)v10 >= a4)
  {
    int v9 = 0;
    a2 = a2 & 0x3FF | 0xDC00;
    goto LABEL_7;
  }
  *unsigned int v10 = a2 & 0x3FF | 0xDC00;
  int v9 = 1;
  a2 = -1;
  uint64_t v11 = 2;
LABEL_8:
  int v8 = &v7[v11];
  if (a5)
  {
    unsigned int v12 = *a5;
    if (*a5)
    {
      *unsigned int v12 = a6;
      __int16 v13 = v12 + 1;
      if (v9)
      {
        __int16 v13 = v12 + 2;
        v12[1] = a6;
      }
      *a5 = v13;
    }
  }
LABEL_13:
  *a3 = (unint64_t)v8;
  if ((a2 & 0x80000000) == 0)
  {
    if (result)
    {
      if (HIWORD(a2))
      {
        __int16 v15 = a2 & 0x3FF | 0xDC00;
        a2 = (a2 >> 10) - 10304;
        *(_WORD *)(result + 146) = v15;
        char v14 = 2;
      }
      else
      {
        char v14 = 1;
      }
      *(_WORD *)(result + 144) = a2;
      *(unsigned char *)(result + 93) = v14;
    }
    *a7 = 15;
  }
  return result;
}

void sub_18C85D434(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  char v6 = uprv_malloc(0xA8uLL);
  *(void *)(a1 + 16) = v6;
  if (v6)
  {
    uint64_t v7 = v6;
    memset(v10, 0, sizeof(v10));
    uint64_t v9 = 0;
    memset(v8, 0, sizeof(v8));
    LODWORD(v8[0]) = 40;
    *char v6 = 0;
    v6[1] = sub_18C85B8A4("icu-internal-compound-s1", v10, v8, a3);
    _DWORD v7[2] = sub_18C85B8A4("icu-internal-compound-s2", v10, v8, a3);
    v7[3] = sub_18C85B8A4("icu-internal-compound-s3", v10, v8, a3);
    v7[4] = sub_18C85B8A4("icu-internal-compound-d1", v10, v8, a3);
    v7[5] = sub_18C85B8A4("icu-internal-compound-d2", v10, v8, a3);
    v7[6] = sub_18C85B8A4("icu-internal-compound-d3", v10, v8, a3);
    v7[7] = sub_18C85B8A4("icu-internal-compound-d4", v10, v8, a3);
    v7[8] = sub_18C85B8A4("icu-internal-compound-d5", v10, v8, a3);
    v7[9] = sub_18C85B8A4("icu-internal-compound-d6", v10, v8, a3);
    v7[10] = sub_18C85B8A4("icu-internal-compound-d7", v10, v8, a3);
    v7[11] = sub_18C85B8A4("icu-internal-compound-t", v10, v8, a3);
    v7[12] = sub_18C85B8A4("ibm-915_P100-1995", v10, v8, a3);
    v7[13] = sub_18C85B8A4("ibm-916_P100-1995", v10, v8, a3);
    v7[14] = sub_18C85B8A4("ibm-914_P100-1995", v10, v8, a3);
    v7[15] = sub_18C85B8A4("ibm-874_P100-1995", v10, v8, a3);
    v7[16] = sub_18C85B8A4("ibm-912_P100-1995", v10, v8, a3);
    v7[17] = sub_18C85B8A4("ibm-913_P100-2000", v10, v8, a3);
    v7[18] = sub_18C85B8A4("iso-8859_14-1998", v10, v8, a3);
    v7[19] = sub_18C85B8A4("ibm-923_P100-1998", v10, v8, a3);
    if (*(int *)a3 > 0 || *(unsigned char *)(a2 + 8)) {
      sub_18C85D72C(a1);
    }
    else {
      *((_DWORD *)v7 + 40) = 0;
    }
  }
  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
}

void sub_18C85D72C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    for (uint64_t i = 0; i != 160; i += 8)
    {
      uint64_t v4 = *(void *)(v1 + i);
      if (v4) {
        sub_18C85B7D8(v4);
      }
    }
    uprv_free(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
  }
}

size_t sub_18C85D788(void *a1, int *a2)
{
  int v5 = (unsigned __int8 *)a1[3];
  uint64_t v4 = (_WORD *)a1[4];
  char v6 = (unsigned __int8 *)a1[2];
  uint64_t v7 = *(void *)(a1[1] + 16);
  if (*(unsigned __int16 *)a1 >= 0x38u) {
    size_t v8 = 56;
  }
  else {
    size_t v8 = *(unsigned __int16 *)a1;
  }
  if (v8 <= 0x37) {
    size_t v9 = 56 - v8;
  }
  else {
    size_t v9 = 0;
  }
  bzero((char *)__dst + v8, v9);
  size_t result = (size_t)memcpy(__dst, a1, v8);
  __dst[0] = v8;
  uint64_t v34 = v7;
  int v11 = *(_DWORD *)(v7 + 160);
  while (1)
  {
LABEL_8:
    if (v6 >= v5) {
      goto LABEL_57;
    }
    unint64_t v12 = a1[5];
    if ((unint64_t)v4 >= v12)
    {
      int v28 = 15;
LABEL_56:
      *a2 = v28;
      goto LABEL_57;
    }
    uint64_t v13 = a1[1];
    uint64_t v14 = *(char *)(v13 + 64);
    __int16 v15 = (int)v14 <= 0 ? v6 : (unsigned __int8 *)(v13 + 65);
    if (*v15 == 27) {
      break;
    }
LABEL_29:
    if (v11)
    {
      if (v6 < v5)
      {
        int v22 = v5 - v6;
        if ((int)v5 - (int)v6 > 1)
        {
          uint64_t v23 = 1;
          while (v6[v23] != 27)
          {
            if (v5 - v6 == ++v23) {
              goto LABEL_43;
            }
          }
          int v22 = v23;
        }
LABEL_43:
        unsigned int v37 = v6;
        unsigned int v38 = &v6[v22];
        unsigned int v39 = v4;
        uint64_t v26 = *(void *)(v36 + 48);
        *(void *)(v36 + 48) = *(void *)(v34 + 8 * v11);
        size_t result = sub_18C86C2EC((uint64_t)__dst, a2);
        uint64_t v27 = v36;
        char v6 = v37;
        *(void *)(v36 + 48) = v26;
        uint64_t v4 = v39;
        if (*a2 >= 1)
        {
          if (*a2 == 15)
          {
            int v33 = *(char *)(v27 + 93);
            if (v33 >= 1)
            {
              size_t result = (size_t)memcpy((void *)(a1[1] + 144), (const void *)(v27 + 144), *(unsigned __int8 *)(v27 + 93));
              LOBYTE(v33) = *(unsigned char *)(v27 + 93);
            }
            *(unsigned char *)(a1[1] + 93) = v33;
            *(unsigned char *)(v27 + 93) = 0;
          }
          goto LABEL_57;
        }
      }
    }
    else if (v6 < v5)
    {
      uint64_t v24 = v5 - v6;
      while (1)
      {
        int v25 = *v6;
        if (v25 == 27) {
          break;
        }
        if ((unint64_t)v4 >= v12)
        {
          *a2 = 15;
          goto LABEL_8;
        }
        ++v6;
        *v4++ = v25;
        if (!--v24)
        {
          char v6 = v5;
          goto LABEL_8;
        }
      }
    }
  }
  uint64_t v16 = 0;
  unint64_t v17 = &v6[-v14];
  uint64_t v18 = (unsigned __int8 *)&unk_18CA7FAC9;
  while (2)
  {
    uint64_t v19 = 0;
    int v20 = 27;
    while (v19 < v14)
    {
      int v21 = *(unsigned __int8 *)(v13 + 65 + v19);
LABEL_20:
      if (v21 != v20) {
        goto LABEL_24;
      }
      int v20 = v18[v19++];
      if (!v20)
      {
        if (*a2 != 11)
        {
          if (v16 != -2)
          {
            size_t result = strlen((const char *)&unk_18CA7FAC8 + 5 * (int)v16);
            v6 += (int)result - (int)v14;
            *(unsigned char *)(v13 + 64) = 0;
            int v11 = v16;
            goto LABEL_29;
          }
          goto LABEL_53;
        }
        goto LABEL_48;
      }
    }
    if (&v17[v19] < v5)
    {
      int v21 = (char)v17[v19];
      goto LABEL_20;
    }
    *a2 = 11;
LABEL_24:
    ++v16;
    v18 += 5;
    if (v16 != 20) {
      continue;
    }
    break;
  }
  if (*a2 != 11)
  {
LABEL_53:
    if (!v14) {
      ++v6;
    }
    int v28 = 12;
    goto LABEL_56;
  }
LABEL_48:
  if (v6 < v5)
  {
    uint64_t v29 = v5 - v6;
    do
    {
      char v30 = *v6++;
      uint64_t v31 = a1[1];
      uint64_t v32 = *(char *)(v31 + 64);
      *(unsigned char *)(v31 + 64) = v32 + 1;
      *(unsigned char *)(v31 + v32 + 65) = v30;
      --v29;
    }
    while (v29);
    char v6 = v5;
  }
  *a2 = 0;
LABEL_57:
  *(_DWORD *)(v34 + 160) = v11;
  a1[4] = v4;
  a1[2] = v6;
  return result;
}

uint64_t sub_18C85DA78(uint64_t result, int *a2)
{
  unsigned __int16 v2 = (void *)result;
  int v3 = *(unsigned char **)(result + 32);
  unint64_t v4 = *(void *)(result + 40);
  uint64_t v5 = *(void *)(result + 8);
  char v6 = *(unsigned __int16 **)(result + 16);
  unint64_t v7 = *(void *)(result + 24);
  char v58 = *(unsigned char *)(v5 + 63);
  unsigned int v60 = 0;
  memset(v61, 0, 7);
  uint64_t v8 = *(void *)(v5 + 16);
  uint64_t v9 = *(unsigned int *)(v8 + 160);
  int v10 = *(_DWORD *)(v5 + 84);
  if (v10) {
    BOOL v11 = (unint64_t)v3 >= v4;
  }
  else {
    BOOL v11 = 1;
  }
  uint64_t v56 = v5;
  int v57 = a2;
  unint64_t v54 = v7;
  unint64_t v55 = v4;
  if (v11) {
    goto LABEL_6;
  }
  while ((unint64_t)v6 < v7)
  {
    int v13 = *v6;
    if ((v13 & 0xFC00) != 0xDC00)
    {
LABEL_72:
      *a2 = 12;
      break;
    }
    ++v6;
    int v10 = v13 + (v10 << 10) - 56613888;
    *(_DWORD *)(v5 + 84) = 0;
    do
    {
      uint64_t v14 = 0;
      if (v10 > 0xA || ((1 << v10) & 0x601) == 0)
      {
        uint64_t v14 = 0;
        if ((v10 & 0xFFFFFF60) - 32 >= 0x60)
        {
          if ((v10 - 258) >= 0x10 || (uint64_t v14 = 16, ((0xFC3Fu >> (v10 - 2)) & 1) == 0))
          {
            unsigned int v32 = v10 & 0xFFFFFFFC;
            uint64_t v14 = 16;
            if ((v10 & 0xFFFFFFFC) != 0x118 && (v10 & 0xFFFFFFFB) - 313 >= 2)
            {
              if ((v10 - 321) >= 0x15 || (uint64_t v14 = 16, ((0x19804Fu >> (v10 - 65)) & 1) == 0))
              {
                uint64_t v14 = 16;
                if (v32 != 344)
                {
                  unsigned int v33 = v10 & 0xFFFFFFFE;
                  if ((v10 & 0xFFFFFFFE) != 0x15E)
                  {
                    uint64_t v14 = 16;
                    if (((v10 - 352) > 0x1E || ((1 << (v10 - 96)) & 0x7E03C03F) == 0)
                      && ((v10 - 711) > 0x16 || ((1 << (v10 + 57)) & 0x560001) == 0))
                    {
                      uint64_t v14 = 17;
                      if (v32 != 264)
                      {
                        if ((v10 - 284) >= 6)
                        {
                          uint64_t v14 = 17;
                        }
                        else
                        {
                          uint64_t v14 = 17;
                          if ((0x33u >> (v10 - 28))) {
                            goto LABEL_17;
                          }
                        }
                        if (v32 != 292)
                        {
                          if ((v10 - 308) > 0x39
                            || (uint64_t v14 = 17, ((1 << (v10 - 52)) & 0x300030000000003) == 0))
                          {
                            uint64_t v14 = 18;
                            if (v32 != 372)
                            {
                              uint64_t v14 = 18;
                              if (v10 <= 7765)
                              {
                                if ((v10 - 7690) <= 0x37
                                  && ((1 << (v10 - 10)) & 0xC0000000300003) != 0)
                                {
                                  goto LABEL_17;
                                }
                                uint64_t v52 = v5;
                                int v53 = a2;
                                if ((v10 - 338) <= 0x26
                                  && ((1 << (v10 - 82)) & 0x4000000003) != 0)
                                {
LABEL_91:
                                  uint64_t v14 = 19;
LABEL_92:
                                  a2 = v53;
                                  uint64_t v5 = v52;
                                  goto LABEL_17;
                                }
                              }
                              else
                              {
                                if ((v10 - 7766) <= 0x2F
                                  && ((1 << (v10 - 86)) & 0xFC0000300C03) != 0
                                  || (v10 - 7922) < 2)
                                {
                                  goto LABEL_17;
                                }
                                uint64_t v52 = v5;
                                int v53 = a2;
                                if (v10 == 8364) {
                                  goto LABEL_91;
                                }
                              }
                              uint64_t v14 = 15;
                              if ((v10 - 3585) < 0x3A) {
                                goto LABEL_92;
                              }
                              a2 = v53;
                              uint64_t v5 = v52;
                              if ((v10 - 3647) >= 0x1D)
                              {
                                if ((v10 - 256) > 0x23
                                  || (uint64_t v14 = 14, ((1 << v10) & 0xC00CC0003) == 0))
                                {
                                  int v59 = v6;
                                  uint64_t v14 = 14;
                                  if (v32 == 296) {
                                    goto LABEL_124;
                                  }
                                  uint64_t v5 = v56;
                                  a2 = v57;
                                  unint64_t v7 = v54;
                                  unint64_t v4 = v55;
                                  if (v33 != 302)
                                  {
                                    if ((v10 - 310) > 0x3D
                                      || (uint64_t v14 = 14, ((1 << (v10 - 54)) & 0x303F000300F18067) == 0))
                                    {
                                      uint64_t v14 = 2;
                                      if (v33 != 700)
                                      {
                                        uint64_t v14 = 2;
                                        if (v10 == 8213) {
                                          goto LABEL_124;
                                        }
                                        uint64_t v5 = v56;
                                        a2 = v57;
                                        unint64_t v7 = v54;
                                        unint64_t v4 = v55;
                                        if ((v10 - 900) >= 0x4B)
                                        {
                                          if ((v10 - 1548) > 0x13
                                            || (uint64_t v14 = 3, ((1 << (v10 - 12)) & 0x88001) == 0))
                                          {
                                            uint64_t v14 = 3;
                                            if ((v10 - 1569) < 0x1A) {
                                              goto LABEL_124;
                                            }
                                            uint64_t v5 = v56;
                                            a2 = v57;
                                            unint64_t v7 = v54;
                                            unint64_t v4 = v55;
                                            if ((v10 - 1600) < 0x13) {
                                              goto LABEL_17;
                                            }
                                            uint64_t v14 = 3;
                                            if (v10 == 8203) {
                                              goto LABEL_124;
                                            }
                                            uint64_t v5 = v56;
                                            a2 = v57;
                                            unint64_t v7 = v54;
                                            unint64_t v4 = v55;
                                            if ((v10 - 1632) < 0xE) {
                                              goto LABEL_17;
                                            }
                                            if ((v10 - 65136) >= 5)
                                            {
                                              uint64_t v14 = 3;
                                              uint64_t v5 = v56;
                                              a2 = v57;
                                              unint64_t v7 = v54;
                                              unint64_t v4 = v55;
                                              if ((v10 - 65142) < 0x49) {
                                                goto LABEL_17;
                                              }
                                            }
                                            else
                                            {
                                              uint64_t v14 = 3;
                                              if ((0x17u >> (v10 - 112))) {
                                                goto LABEL_124;
                                              }
                                              uint64_t v5 = v56;
                                              a2 = v57;
                                              unint64_t v7 = v54;
                                              unint64_t v4 = v55;
                                              if ((v10 - 65142) <= 0x48) {
                                                goto LABEL_17;
                                              }
                                            }
                                            uint64_t v14 = 13;
                                            if ((v10 - 1488) < 0x1B) {
                                              goto LABEL_17;
                                            }
                                            uint64_t v14 = 13;
                                            if (v10 == 8215) {
                                              goto LABEL_124;
                                            }
                                            uint64_t v5 = v56;
                                            a2 = v57;
                                            unint64_t v7 = v54;
                                            unint64_t v4 = v55;
                                            if (v10 == 8254) {
                                              goto LABEL_17;
                                            }
                                            uint64_t v14 = 12;
                                            if (v10 == 8470)
                                            {
LABEL_124:
                                              uint64_t v5 = v56;
                                              a2 = v57;
                                              unint64_t v7 = v54;
                                              unint64_t v4 = v55;
                                              goto LABEL_17;
                                            }
                                            uint64_t v5 = v56;
                                            a2 = v57;
                                            unint64_t v7 = v54;
                                            unint64_t v4 = v55;
                                            if ((v10 - 1025) >= 0x5F)
                                            {
                                              if ((v10 - 286) > 0x13
                                                || (uint64_t v14 = 1, ((1 << (v10 - 30)) & 0xC0003) == 0))
                                              {
                                                uint64_t v14 = 1;
                                                if (v32 != 536)
                                                {
                                                  LODWORD(v16) = 0;
LABEL_23:
                                                  uint64_t v21 = 1;
                                                  uint64_t v22 = v9;
                                                  uint64_t v23 = v9;
                                                  uint64_t v24 = &byte_18CA7FACE;
                                                  while (1)
                                                  {
                                                    size_t result = sub_18C86EC94(*(void *)(v8 + 8 * v21), v10, (int *)&v60, v58);
                                                    if ((int)result >= 1) {
                                                      break;
                                                    }
                                                    ++v21;
                                                    v24 += 5;
                                                    if (v21 == 12)
                                                    {
                                                      uint64_t v9 = v23;
                                                      uint64_t v5 = v56;
                                                      a2 = v57;
                                                      unint64_t v7 = v54;
                                                      unint64_t v4 = v55;
                                                      goto LABEL_32;
                                                    }
                                                  }
                                                  if (v22 == v21)
                                                  {
                                                    uint64_t v9 = v22;
                                                    uint64_t v5 = v56;
                                                    a2 = v57;
                                                    char v6 = v59;
                                                  }
                                                  else
                                                  {
                                                    char v34 = *(v24 - 1);
                                                    unsigned int v35 = &v61[v16];
                                                    uint64_t v5 = v56;
                                                    a2 = v57;
                                                    char v6 = v59;
                                                    do
                                                    {
                                                      *v35++ = v34;
                                                      int v36 = *v24++;
                                                      char v34 = v36;
                                                      LODWORD(v16) = v16 + 1;
                                                    }
                                                    while (v36);
                                                    uint64_t v9 = v21;
                                                  }
                                                  unsigned int v37 = v60;
                                                  unsigned int v38 = &v61[(int)v16];
                                                  int v39 = result + 1;
                                                  int v40 = 8 * result - 8;
                                                  unint64_t v7 = v54;
                                                  unint64_t v4 = v55;
                                                  do
                                                  {
                                                    *v38++ = v37 >> v40;
                                                    LODWORD(v16) = v16 + 1;
                                                    --v39;
                                                    v40 -= 8;
                                                  }
                                                  while (v39 > 1);
                                                  goto LABEL_57;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
LABEL_17:
      LODWORD(v16) = 0;
      if (v9 != v14)
      {
        uint64_t v16 = 0;
        unint64_t v17 = (char *)&unk_18CA7FAC8 + 5 * v14;
        char v20 = *v17;
        uint64_t v18 = v17 + 1;
        LOBYTE(v19) = v20;
        do
        {
          v61[v16] = v19;
          int v19 = v18[v16++];
        }
        while (v19);
        uint64_t v9 = v14;
      }
      if (v9)
      {
        int v59 = v6;
        if (v9 != -1)
        {
          unint64_t v25 = v4;
          uint64_t v26 = a2;
          uint64_t v27 = v9;
          size_t result = sub_18C86EC94(*(void *)(v8 + 8 * (int)v9), v10, (int *)&v60, v58);
          if ((int)result >= 1)
          {
            unsigned int v28 = v60;
            uint64_t v29 = &v61[v16];
            unsigned int v30 = result + 1;
            int v31 = 8 * result - 8;
            LODWORD(v16) = result + v16;
            do
            {
              *v29++ = v28 >> v31;
              --v30;
              v31 -= 8;
            }
            while (v30 > 1);
          }
          uint64_t v9 = v27;
          a2 = v26;
          unint64_t v4 = v25;
LABEL_32:
          char v6 = v59;
          goto LABEL_57;
        }
        goto LABEL_23;
      }
      v61[v16] = v10;
      LODWORD(v16) = v16 + 1;
LABEL_57:
      if ((int)v16 < 1)
      {
        LODWORD(v41) = 0;
LABEL_65:
        int v46 = *a2;
      }
      else
      {
        unint64_t v41 = v4 - (void)v3;
        if (v4 < (unint64_t)v3) {
          unint64_t v41 = 0;
        }
        uint64_t v42 = v16;
        uint64_t v43 = v61;
        unint64_t v44 = v41;
        while (v44)
        {
          char v45 = *v43++;
          *v3++ = v45;
          --v44;
          if (!--v42)
          {
            LODWORD(v41) = v16;
            goto LABEL_65;
          }
        }
        int v46 = 15;
        *a2 = 15;
      }
      if (v46 == 15 && (int)v41 < (int)v16)
      {
        int v47 = &v61[v41];
        unint64_t v48 = v16 - (unint64_t)v41;
        do
        {
          char v49 = *v47++;
          uint64_t v50 = v2[1];
          uint64_t v51 = *(char *)(v50 + 91);
          *(unsigned char *)(v50 + 91) = v51 + 1;
          *(unsigned char *)(v50 + v51 + 104) = v49;
          --v48;
        }
        while (v48);
      }
LABEL_6:
      if ((unint64_t)v6 >= v7) {
        goto LABEL_75;
      }
      if ((unint64_t)v3 >= v4)
      {
        *a2 = 15;
        goto LABEL_75;
      }
      int v12 = *v6++;
      int v10 = v12;
    }
    while ((v12 & 0xF800) != 0xD800);
    if ((v10 & 0x400) != 0) {
      goto LABEL_72;
    }
  }
  *(_DWORD *)(v5 + 84) = v10;
LABEL_75:
  *(_DWORD *)(v8 + 160) = v9;
  v2[2] = v6;
  v2[4] = v3;
  return result;
}

const char *sub_18C85E298()
{
  return "x11-compound-text";
}

uint64_t sub_18C85E2A4(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  for (uint64_t i = 8; i != 160; i += 8)
    sub_18C86C2D8(*(void *)(v7 + i), a2, a3, a4);
  ((void (*)(uint64_t, void))a2[1])(*a2, 0);
  ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 9);
  ((void (*)(uint64_t, uint64_t))a2[1])(*a2, 10);
  ((void (*)(uint64_t, uint64_t, uint64_t))a2[2])(*a2, 32, 127);
  uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[2];
  uint64_t v10 = *a2;

  return v9(v10, 160, 255);
}

void UCNV_FROM_U_CALLBACK_STOP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, _DWORD *a7)
{
  if (!a6)
  {
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5) {
          goto LABEL_17;
        }
        int v7 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564) {
            goto LABEL_17;
          }
          goto LABEL_18;
        }
        int v7 = -4447;
      }
      if ((a5 + v7) < 2) {
        goto LABEL_17;
      }
      goto LABEL_18;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0) {
      goto LABEL_17;
    }
LABEL_18:
    if (a5 != 12644
      && (a5 & 0xFFFFFFF0) != 0x2060
      && (a5 & 0xFFFFF000) != 0xE0000
      && (a5 - 119155) >= 8
      && (a5 & 0xFFFFFFFC) != 0x1BCA0
      && (a5 - 65520) >= 9
      && a5 != 65440
      && a5 != 65279
      && (a5 & 0xFFFFFFF0) != 0xFE00)
    {
      return;
    }
LABEL_17:
    *a7 = 0;
  }
}

unsigned char *UCNV_FROM_U_CALLBACK_SKIP(unsigned char *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, _DWORD *a7)
{
  if (a6 <= 2)
  {
    if (a6)
    {
LABEL_3:
      if (result && (a6 || *result != 105)) {
        return result;
      }
LABEL_21:
      *a7 = 0;
      return result;
    }
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5) {
          goto LABEL_21;
        }
        int v7 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564) {
            goto LABEL_21;
          }
LABEL_22:
          if (a5 == 12644
            || (a5 & 0xFFFFFFF0) == 0x2060
            || (a5 & 0xFFFFF000) == 0xE0000
            || (a5 - 119155) < 8
            || (a5 & 0xFFFFFFFC) == 0x1BCA0
            || (a5 - 65520) < 9
            || a5 == 65440
            || a5 == 65279
            || (a5 & 0xFFFFFFF0) == 0xFE00)
          {
            goto LABEL_21;
          }
          goto LABEL_3;
        }
        int v7 = -4447;
      }
      if ((a5 + v7) < 2) {
        goto LABEL_21;
      }
      goto LABEL_22;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0) {
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  return result;
}

unsigned char *UCNV_FROM_U_CALLBACK_SUBSTITUTE(unsigned char *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7)
{
  if (a6 > 2) {
    return result;
  }
  if (!a6)
  {
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5) {
          goto LABEL_22;
        }
        int v7 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564) {
            goto LABEL_22;
          }
          goto LABEL_23;
        }
        int v7 = -4447;
      }
      if ((a5 + v7) < 2) {
        goto LABEL_22;
      }
      goto LABEL_23;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0) {
      goto LABEL_22;
    }
LABEL_23:
    if (a5 != 12644
      && (a5 & 0xFFFFFFF0) != 0x2060
      && (a5 & 0xFFFFF000) != 0xE0000
      && (a5 - 119155) >= 8
      && (a5 & 0xFFFFFFFC) != 0x1BCA0
      && (a5 - 65520) >= 9
      && a5 != 65440
      && a5 != 65279
      && (a5 & 0xFFFFFFF0) != 0xFE00)
    {
      goto LABEL_3;
    }
LABEL_22:
    *a7 = 0;
    return result;
  }
LABEL_3:
  if (!result || !a6 && *result == 105)
  {
    *a7 = 0;
    return (unsigned char *)ucnv_cbFromUWriteSub(a2, 0, a7);
  }
  return result;
}

char *UCNV_FROM_U_CALLBACK_ESCAPE(char *result, uint64_t a2, unsigned __int16 *a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  int v34 = 0;
  uint64_t v33 = 0;
  uint64_t v31 = 0;
  if (a6 <= 2)
  {
    unsigned int v8 = a5;
    LODWORD(v9) = a4;
    int v12 = result;
    if (a6)
    {
LABEL_3:
      memset(v36, 0, sizeof(v36));
      uint64_t v32 = 0;
      uint64_t v30 = 0;
      size_t result = (char *)ucnv_setFromUCallBack(*(void **)(a2 + 8), (uint64_t)UCNV_FROM_U_CALLBACK_SUBSTITUTE, 0, &v33, &v32, &v34);
      int v13 = v34;
      if (v34 <= 0)
      {
        if (!v12)
        {
          if ((int)v9 < 1) {
            goto LABEL_61;
          }
          int v17 = 0;
          uint64_t v9 = v9;
          do
          {
            *(_DWORD *)((char *)v36 + 2 * v17) = 5570597;
            unsigned int v18 = *a3++;
            v17 += uprv_itou((__int16 *)v36 + v17 + 2, 46 - v17, v18, 0x10u, 4) + 2;
            --v9;
          }
          while (v9);
LABEL_64:
          unsigned int v35 = v36;
          *a7 = 0;
          ucnv_cbFromUWriteUChars(a2, (unint64_t *)&v35, (unint64_t)v36 + 2 * v17, 0, a7);
          size_t result = (char *)ucnv_setFromUCallBack(*(void **)(a2 + 8), v33, v32, &v31, &v30, &v34);
          int v13 = v34;
          if (v34 < 1) {
            return result;
          }
          goto LABEL_65;
        }
        int v14 = *v12;
        if (v14 <= 82)
        {
          switch(v14)
          {
            case 'C':
              LOWORD(v36[0]) = 92;
              if (v9 == 2)
              {
                WORD1(v36[0]) = 85;
                unsigned int v23 = v8;
                uint64_t v24 = 8;
              }
              else
              {
                WORD1(v36[0]) = 117;
                unsigned int v23 = *a3;
                uint64_t v24 = 4;
              }
              int v17 = uprv_itou((__int16 *)v36 + 2, 46, v23, 0x10u, v24) + 2;
              goto LABEL_64;
            case 'D':
              LODWORD(v36[0]) = 2293798;
              if (v9 != 2) {
                unsigned int v8 = *a3;
              }
              int v25 = uprv_itou((__int16 *)v36 + 2, 46, v8, 0xAu, 0);
              int v17 = v25 + 3;
              *((_WORD *)v36 + v25 + 2) = 59;
              goto LABEL_64;
            case 'J':
              if ((int)v9 >= 1)
              {
                int v15 = 0;
                uint64_t v9 = v9;
                do
                {
                  *(_DWORD *)((char *)v36 + 2 * v15) = 7667804;
                  unsigned int v16 = *a3++;
                  v15 += uprv_itou((__int16 *)v36 + v15 + 2, 46 - v15, v16, 0x10u, 4) + 2;
                  int v17 = v15;
                  --v9;
                }
                while (v9);
                goto LABEL_64;
              }
LABEL_61:
              int v17 = 0;
              goto LABEL_64;
          }
          goto LABEL_57;
        }
        switch(v14)
        {
          case 'S':
            LOWORD(v36[0]) = 92;
            int v26 = uprv_itou((__int16 *)v36 + 1, 47, v8, 0x10u, 0);
            int v17 = v26 + 2;
            *((_WORD *)v36 + v26 + 1) = 32;
            goto LABEL_64;
          case 'U':
            LODWORD(v36[0]) = 5570683;
            WORD2(v36[0]) = 43;
            if (v9 != 2) {
              unsigned int v8 = *a3;
            }
            int v27 = uprv_itou((__int16 *)v36 + 3, 45, v8, 0x10u, 4);
            int v17 = v27 + 4;
            uint64_t v21 = (char *)v36 + 2 * v27;
            __int16 v22 = 125;
            break;
          case 'X':
            LODWORD(v36[0]) = 2293798;
            WORD2(v36[0]) = 120;
            if (v9 != 2) {
              unsigned int v8 = *a3;
            }
            int v20 = uprv_itou((__int16 *)v36 + 3, 45, v8, 0x10u, 0);
            int v17 = v20 + 4;
            uint64_t v21 = (char *)v36 + 2 * v20;
            __int16 v22 = 59;
            break;
          default:
LABEL_57:
            if ((int)v9 < 1) {
              goto LABEL_61;
            }
            int v28 = 0;
            uint64_t v9 = v9;
            do
            {
              *(_DWORD *)((char *)v36 + 2 * v28) = 5570597;
              unsigned int v29 = *a3++;
              v28 += uprv_itou((__int16 *)v36 + v28 + 2, 46 - v28, v29, 0x10u, 4) + 2;
              int v17 = v28;
              --v9;
            }
            while (v9);
            goto LABEL_64;
        }
        *((_WORD *)v21 + 3) = v22;
        goto LABEL_64;
      }
LABEL_65:
      *a7 = v13;
      return result;
    }
    int v13 = 0;
    if (a5 <= 8202)
    {
      if (a5 > 6067)
      {
        if ((a5 - 6155) < 5) {
          goto LABEL_65;
        }
        int v19 = -6068;
      }
      else
      {
        if (a5 <= 4446)
        {
          if (a5 == 173 || a5 == 847 || a5 == 1564) {
            goto LABEL_65;
          }
LABEL_37:
          int v13 = 0;
          if (a5 == 12644) {
            goto LABEL_65;
          }
          if ((a5 & 0xFFFFFFF0) == 0x2060) {
            goto LABEL_65;
          }
          int v13 = 0;
          if ((a5 & 0xFFFFF000) == 0xE0000
            || (a5 - 119155) < 8
            || (a5 & 0xFFFFFFFC) == 0x1BCA0
            || (a5 - 65520) < 9
            || a5 == 65440
            || a5 == 65279
            || (a5 & 0xFFFFFFF0) == 0xFE00)
          {
            goto LABEL_65;
          }
          goto LABEL_3;
        }
        int v19 = -4447;
      }
      if ((a5 + v19) < 2) {
        goto LABEL_65;
      }
      goto LABEL_37;
    }
    if ((a5 - 8203) <= 0x23 && ((1 << (a5 - 11)) & 0xF8000001FLL) != 0) {
      goto LABEL_65;
    }
    goto LABEL_37;
  }
  return result;
}

unsigned char *UCNV_TO_U_CALLBACK_SKIP(unsigned char *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, _DWORD *a6)
{
  if (a5 <= 2 && (!result || !a5 && *result == 105)) {
    *a6 = 0;
  }
  return result;
}

unsigned char *UCNV_TO_U_CALLBACK_SUBSTITUTE(unsigned char *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  if (a5 <= 2 && (!result || !a5 && *result == 105))
  {
    *a6 = 0;
    return (unsigned char *)ucnv_cbToUWriteSub(a2, 0, a6);
  }
  return result;
}

char *UCNV_TO_U_CALLBACK_ESCAPE(char *result, uint64_t a2, unsigned __int8 *a3, int a4, int a5, int *a6)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a5 <= 2)
  {
    memset(v31, 0, sizeof(v31));
    if (result)
    {
      int v9 = *result;
      switch(v9)
      {
        case 'X':
          if (a4 >= 1)
          {
            int v16 = 0;
            uint64_t v17 = a4;
            do
            {
              unsigned int v18 = (char *)v31 + 2 * v16;
              *(_DWORD *)unsigned int v18 = 2293798;
              uint64_t v19 = v16 + 3;
              *((_WORD *)v18 + 2) = 120;
              unsigned int v20 = *a3++;
              int v21 = uprv_itou((__int16 *)v31 + v19, 45 - v16, v20, 0x10u, 0);
              int v16 = v21 + v19 + 1;
              *((_WORD *)v31 + v21 + (int)v19) = 59;
              int v13 = v16;
              --v17;
            }
            while (v17);
            goto LABEL_27;
          }
          break;
        case 'D':
          if (a4 >= 1)
          {
            int v22 = 0;
            uint64_t v23 = a4;
            do
            {
              *(_DWORD *)((char *)v31 + 2 * v22) = 2293798;
              uint64_t v24 = v22 + 2;
              unsigned int v25 = *a3++;
              int v26 = uprv_itou((__int16 *)v31 + v24, 46 - v22, v25, 0xAu, 0);
              int v22 = v26 + v24 + 1;
              *((_WORD *)v31 + v26 + (int)v24) = 59;
              int v13 = v22;
              --v23;
            }
            while (v23);
            goto LABEL_27;
          }
          break;
        case 'C':
          if (a4 >= 1)
          {
            int v10 = 0;
            uint64_t v11 = a4;
            do
            {
              *(_DWORD *)((char *)v31 + 2 * v10) = 7864412;
              unsigned int v12 = *a3++;
              v10 += uprv_itou((__int16 *)v31 + v10 + 2, 46 - v10, v12, 0x10u, 2) + 2;
              int v13 = v10;
              --v11;
            }
            while (v11);
            goto LABEL_27;
          }
          break;
        default:
          if (a4 >= 1)
          {
            uint64_t v27 = 0;
            int v28 = (__int16 *)v31 + 2;
            uint64_t v29 = 4 * a4;
            do
            {
              *((_DWORD *)v28 - 1) = 5767205;
              unsigned int v30 = *a3++;
              uprv_itou(v28, v27 + 46, v30, 0x10u, 2);
              v27 -= 4;
              v28 += 4;
            }
            while (v29 + v27);
            int v13 = -(int)v27;
            goto LABEL_27;
          }
          break;
      }
    }
    else if (a4 >= 1)
    {
      int v13 = 0;
      uint64_t v14 = a4;
      do
      {
        *(_DWORD *)((char *)v31 + 2 * v13) = 5767205;
        unsigned int v15 = *a3++;
        v13 += uprv_itou((__int16 *)v31 + v13 + 2, 46 - v13, v15, 0x10u, 2) + 2;
        --v14;
      }
      while (v14);
      goto LABEL_27;
    }
    int v13 = 0;
LABEL_27:
    *a6 = 0;
    return (char *)ucnv_cbToUWriteUChars(a2, (__int16 *)v31, v13, 0, a6);
  }
  return result;
}

uint64_t sub_18C85EF38(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, int a5, unint64_t *a6, unint64_t a7, void *a8, int a9, unsigned __int8 a10, _DWORD *a11)
{
  int v15 = a3;
  unsigned int v29 = 0;
  int v18 = *(unsigned __int8 *)(*(void *)(a1 + 48) + 252);
  if (v18 == 12)
  {
    int v19 = *(_DWORD *)(a1 + 76);
  }
  else if (v18 == 219)
  {
    LOBYTE(v19) = 1;
  }
  else
  {
    LOBYTE(v19) = -1;
  }
  unsigned int v20 = (unsigned char *)(a1 + 65);
  int v21 = (char *)*a4;
  int v22 = sub_18C85F0DC(a2, (char)v19, a1 + 65, a3, *a4, a5 - *a4, &v29, a10);
  if (v22 < 1)
  {
    if ((v22 & 0x80000000) == 0) {
      return 0;
    }
    *(unsigned char *)(a1 + 283) = v15;
    if (v15 < 1)
    {
      int v15 = 0;
    }
    else
    {
      uint64_t v24 = v15;
      do
      {
        v20[185] = *v20;
        ++v20;
        --v24;
      }
      while (v24);
      int v21 = (char *)*a4;
    }
    uint64_t v25 = -v22;
    if (v15 < (int)v25)
    {
      int v26 = (unsigned char *)(a1 + v15 + 250);
      uint64_t v27 = v25 - v15;
      do
      {
        char v28 = *v21++;
        *v26++ = v28;
        --v27;
      }
      while (v27);
    }
    *a4 = (uint64_t)v21;
    *(unsigned char *)(a1 + 282) = -(char)v22;
  }
  else
  {
    *a4 = (uint64_t)&v21[v22 - v15];
    if (v29 >> 20 > 2) {
      sub_18C85D2B8(a1, (__int16 *)(a2 + *(int *)(a2 + 12) + 2 * (v29 & 0x3FFFF)), (v29 >> 18) - 12, (_WORD **)a6, a7, a8, a9, a11);
    }
    else {
      sub_18C85D360(a1, v29 - 2031616, a6, a7, (_DWORD **)a8, a9, a11);
    }
  }
  return 1;
}

uint64_t sub_18C85F0DC(uint64_t result, int a2, uint64_t a3, int a4, uint64_t a5, int a6, unsigned int *a7, unsigned __int8 a8)
{
  if (!result) {
    return result;
  }
  uint64_t v8 = result;
  if (*(int *)(result + 8) < 1) {
    return 0;
  }
  if (!a2)
  {
    if (a4 <= 1)
    {
      if (a6 >= 1) {
        int v10 = 1;
      }
      else {
        int v10 = a6;
      }
      if (a4 == 1) {
        a6 = 0;
      }
      else {
        a6 = v10;
      }
      int v9 = 1;
      goto LABEL_14;
    }
    return 0;
  }
  int v9 = a8;
LABEL_14:
  unsigned int v11 = 0;
  int v12 = 0;
  int v13 = 0;
  unsigned int v14 = 0;
  size_t result = 0;
  uint64_t v15 = v8 + *(int *)(v8 + 4);
  while (1)
  {
    int v16 = (unsigned int *)(v15 + 4 * v14);
    unsigned int v19 = *v16;
    uint64_t v17 = v16 + 1;
    unsigned int v18 = v19;
    int v20 = v19 & 0xFFFFFF;
    if ((v19 & 0xFFFFFF) != 0)
    {
      int v21 = (a2 == 0) ^ (v13 + v12 != 1);
      if (a2 < 0) {
        int v21 = 1;
      }
      if (v21)
      {
        unsigned int v11 = v20;
        size_t result = (v13 + v12);
      }
      else
      {
        size_t result = result;
      }
    }
    if (v12 >= a4) {
      break;
    }
    int v22 = v12++;
    uint64_t v23 = a3;
LABEL_25:
    int v24 = HIBYTE(v18);
    unsigned int v25 = *(unsigned __int8 *)(v23 + v22);
    unsigned int v26 = HIBYTE(v17[HIBYTE(v18) - 1]);
    if (v25 < HIBYTE(*v17) || v26 < v25) {
      goto LABEL_60;
    }
    int v28 = HIBYTE(*v17);
    if (v26 - v28 + 1 == v24)
    {
      unsigned int v29 = v17[v25 - v28];
    }
    else
    {
      int v30 = v18 >> 25;
      if (v30)
      {
        int v30 = 0;
        unsigned int v31 = v25 << 24;
        unsigned int v32 = v24;
        while (v32 > 4)
        {
          int v33 = v30 + v24;
          if (v30 + v24 < 0 != __OFADD__(v30, v24)) {
            ++v33;
          }
          int v34 = v33 >> 1;
          if (((v25 << 24) | 0xFFFFFFu) < v17[v34]) {
            int v24 = v34;
          }
          else {
            int v30 = v34;
          }
          unsigned int v32 = v24 - v30;
          if (v24 - v30 <= 1) {
            goto LABEL_49;
          }
        }
        if (v31 > v17[v30])
        {
          uint64_t v35 = v30 + 1;
          if ((int)v35 < v24 && v31 <= v17[v35] || (uint64_t v35 = v30 + 2, v30 + 2 < v24) && v31 <= v17[v35]) {
            int v30 = v35;
          }
          else {
            v30 += 3;
          }
        }
      }
LABEL_49:
      if (v30 >= v24) {
        goto LABEL_60;
      }
      unsigned int v29 = v17[v30];
      if (v25 != HIBYTE(v29)) {
        goto LABEL_60;
      }
    }
    unsigned int v14 = v29 & 0xFFFFFF;
    if (!v14) {
      goto LABEL_60;
    }
    if (v14 >= 0x1F0000)
    {
      int v36 = (a2 == 0) ^ (v13 + v12 != 1);
      if (a2 < 0) {
        int v36 = 1;
      }
      if (v36)
      {
        unsigned int v11 = v14;
        size_t result = (v13 + v12);
      }
      else
      {
        size_t result = result;
      }
      goto LABEL_60;
    }
  }
  if (v13 < a6)
  {
    int v22 = v13++;
    uint64_t v23 = a5;
    goto LABEL_25;
  }
  if (!v9 && v13 + v12 <= 31) {
    return -(v13 + v12);
  }
LABEL_60:
  if (result) {
    *a7 = v11 & 0xFF7FFFFF;
  }
  return result;
}

uint64_t sub_18C85F300(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v7 = 0;
  if (a3 < 1) {
    return 0xFFFFLL;
  }
  int v4 = sub_18C85F0DC(a1, -1, a2, a3, 0, 0, &v7, 1u);
  if (v7 < 0x300000 && v4 == a3) {
    return v7 - 2031616;
  }
  else {
    return 65534;
  }
}

uint64_t sub_18C85F374(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  unsigned int v29 = 0;
  uint64_t v8 = *(void *)(a1 + 48);
  int v9 = *(unsigned __int8 *)(v8 + 252);
  if (v9 == 12)
  {
    int v10 = *(_DWORD *)(a1 + 76);
  }
  else if (v9 == 219)
  {
    LOBYTE(v10) = 1;
  }
  else
  {
    LOBYTE(v10) = -1;
  }
  uint64_t v11 = a1 + 250;
  int v12 = *(char *)(a1 + 282);
  int v13 = *(char **)(a2 + 16);
  uint64_t result = sub_18C85F0DC(*(void *)(v8 + 288), (char)v10, a1 + 250, v12, (uint64_t)v13, *(_DWORD *)(a2 + 24) - (int)v13, &v29, *(unsigned char *)(a2 + 2));
  if ((int)result < 1)
  {
    if ((result & 0x80000000) != 0)
    {
      uint64_t v25 = -(int)result;
      if (v12 < (int)v25)
      {
        unsigned int v26 = (unsigned char *)(a1 + v12 + 250);
        uint64_t v27 = v25 - v12;
        do
        {
          char v28 = *v13++;
          *v26++ = v28;
          --v27;
        }
        while (v27);
      }
      *(void *)(a2 + 16) = v13;
      *(unsigned char *)(a1 + 282) = -(char)result;
    }
    else
    {
      uint64_t result = (uint64_t)memcpy((void *)(a1 + 65), (const void *)(a1 + 250), *(char *)(a1 + 283));
      int v17 = *(char *)(a1 + 283);
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a1 + 283);
      int v18 = *(char *)(a1 + 282);
      char v19 = v18 - v17;
      if (v18 - v17 >= 1) {
        uint64_t result = (uint64_t)memmove((void *)(a1 + 250), (const void *)(v11 + v17), (v18 - v17));
      }
      *(unsigned char *)(a1 + 282) = -v19;
      *a4 = 10;
    }
  }
  else
  {
    if ((int)result >= v12)
    {
      LOBYTE(v16) = 0;
      *(void *)(a2 + 16) = &v13[(int)result - v12];
    }
    else
    {
      int v15 = v12 - result;
      memmove((void *)(a1 + 250), (const void *)(v11 + result), v12 - (int)result);
      int v16 = -v15;
    }
    *(unsigned char *)(a1 + 282) = v16;
    unint64_t v20 = *(void *)(a2 + 40);
    if (v29 >> 20 > 2)
    {
      uint64_t v23 = (__int16 *)(*(void *)(v8 + 288) + *(int *)(*(void *)(v8 + 288) + 12) + 2 * (v29 & 0x3FFFF));
      int v24 = (v29 >> 18) - 12;
      return sub_18C85D2B8(a1, v23, v24, (_WORD **)(a2 + 32), v20, (void *)(a2 + 48), a3, a4);
    }
    else
    {
      unsigned int v21 = v29 - 2031616;
      unint64_t v22 = *(void *)(a2 + 40);
      return sub_18C85D360(a1, v21, (unint64_t *)(a2 + 32), v22, (_DWORD **)(a2 + 48), a3, a4);
    }
  }
  return result;
}

uint64_t sub_18C85F594(uint64_t a1, unint64_t a2, int a3, uint64_t *a4, uint64_t a5, void *a6, unint64_t a7, void *a8, int a9, char a10, _DWORD *a11)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unsigned int v32 = 0;
  int v18 = (__int16 *)*a4;
  int v19 = sub_18C85F7E4(a2, a3, 0, 0, *a4, (unint64_t)(a5 - *a4) >> 1, &v32, *(char *)(a1 + 63), a10);
  if (v19 < 2)
  {
    if (v19 < 0)
    {
      *(_DWORD *)(a1 + 208) = a3;
      if (v19 <= 0xFFFFFFFD)
      {
        unsigned int v29 = (_WORD *)(a1 + 212);
        uint64_t v30 = (-2 - v19);
        do
        {
          __int16 v31 = *v18++;
          *v29++ = v31;
          --v30;
        }
        while (v30);
      }
      *a4 = (uint64_t)v18;
      *(unsigned char *)(a1 + 281) = -2 - v19;
      return 1;
    }
    if (v19 == 1)
    {
      uint64_t result = 0;
      *(unsigned char *)(a1 + 95) = 1;
      return result;
    }
    return 0;
  }
  unsigned int v20 = v32;
  if ((v32 & 0x1F000000) == 0x1000000 && *(unsigned __int8 *)(*(void *)(a1 + 48) + 252) == 219) {
    return 0;
  }
  *a4 = (uint64_t)&v18[v19 - 2];
  memset(v33, 0, sizeof(v33));
  size_t v21 = HIBYTE(v20) & 0x1F;
  if (v21 > 3)
  {
    unint64_t v22 = (char *)(a2 + *(int *)(a2 + 32) + (*(void *)&v20 & 0xFFFFFFLL));
  }
  else
  {
    unint64_t v22 = (char *)v33 + 1;
    uint64_t v23 = (char *)v33 + 1;
    if (v21 != 1)
    {
      int v24 = (char *)v33 + 1;
      if (v21 != 2)
      {
        if (v21 != 3) {
          goto LABEL_16;
        }
        int v24 = (char *)v33 + 2;
        BYTE1(v33[0]) = BYTE2(v20);
      }
      *int v24 = BYTE1(v20);
      uint64_t v23 = v24 + 1;
    }
    *uint64_t v23 = v20;
  }
LABEL_16:
  int v26 = *(_DWORD *)(a1 + 80);
  if (v26)
  {
    if (v21 == 1 && v26 > 1)
    {
      char v27 = 15;
      int v28 = 1;
LABEL_27:
      *(_DWORD *)(a1 + 80) = v28;
      LOBYTE(v33[0]) = v27;
      if (v22 != (char *)v33 + 1) {
        memcpy((char *)v33 + 1, v22, v21);
      }
      LODWORD(v21) = v21 + 1;
      unint64_t v22 = (char *)v33;
      goto LABEL_30;
    }
    if (v21 >= 2 && v26 == 1)
    {
      char v27 = 14;
      int v28 = 2;
      goto LABEL_27;
    }
  }
LABEL_30:
  sub_18C85D210(a1, v22, v21, a6, a7, a8, a9, a11);
  return 1;
}

unint64_t sub_18C85F7E4(unint64_t result, int a2, uint64_t a3, int a4, uint64_t a5, int a6, _DWORD *a7, int a8, char a9)
{
  if (!result) {
    return result;
  }
  unint64_t v9 = result;
  if (a2 >> 10 >= *(_DWORD *)(result + 44)) {
    return 0;
  }
  unint64_t v10 = *(unsigned int *)(result
                        + *(int *)(result + 60)
                        + 4
                        * *(unsigned __int16 *)(result
                                              + *(int *)(result + 52)
                                              + 2
                                              * ((a2 & 0xF)
                                               + 4
                                               * *(unsigned __int16 *)(result
                                                                                   + *(int *)(result + 40)
                                                                                   + 2
                                                                                   * (((a2 >> 4) & 0x3F)
                                                                                    + *(unsigned __int16 *)(result + *(int *)(result + 40) + 2 * (a2 >> 10)))))));
  if (!v10) {
    return 0;
  }
  if (v10 >> 16 <= 0x1E)
  {
    unint64_t v11 = 0;
    int v12 = 0;
    int v13 = 0;
    uint64_t result = 0;
    unint64_t v14 = v9 + *(int *)(v9 + 20);
    unint64_t v15 = v9 + *(int *)(v9 + 24);
    unsigned int v16 = a2 - 57344;
    unsigned int v17 = a2 - 983040;
    while (1)
    {
      int v18 = (unsigned int *)(v15 + 4 * v10);
      unsigned int v21 = *v18;
      unsigned int v20 = v18 + 1;
      unint64_t v19 = v21;
      if (v21)
      {
        BOOL v22 = (v19 & 0xC0000000) == 0 && a8 == 0;
        BOOL v23 = v22 && v16 >> 8 >= 0x19;
        BOOL v24 = v23 && v17 >= 0x20000;
        BOOL v25 = !v24;
        if ((v19 & 0x20000000) == 0)
        {
          if (v25)
          {
            unint64_t v11 = v19;
            uint64_t result = (v13 + v12 + 2);
          }
          else
          {
            uint64_t result = result;
          }
        }
      }
      int v26 = (unsigned __int16 *)(v14 + 2 * v10);
      int v29 = *v26;
      char v27 = v26 + 1;
      int v28 = v29;
      if (v12 >= a4)
      {
        if (v13 >= a6)
        {
          if (!a9 && v13 + v12 <= 19) {
            return (-2 - (v13 + v12));
          }
LABEL_83:
          unint64_t v10 = v11;
          if (!result) {
            return result;
          }
LABEL_84:
          if (v10 == 2147483649) {
            return 1;
          }
          *a7 = v10;
          return result;
        }
        int v30 = v13++;
        uint64_t v31 = a5;
      }
      else
      {
        int v30 = v12++;
        uint64_t v31 = a3;
      }
      unsigned int v32 = *(unsigned __int16 *)(v31 + 2 * v30);
      if (v28 >= 2)
      {
        int v33 = 0;
        unsigned int v34 = v28;
        while (v34 > 4)
        {
          int v35 = v33 + v28;
          if (v33 + v28 < 0 != __OFADD__(v33, v28)) {
            ++v35;
          }
          int v36 = v35 >> 1;
          if (v27[v36] > v32) {
            int v28 = v36;
          }
          else {
            int v33 = v36;
          }
          unsigned int v34 = v28 - v33;
          if (v28 - v33 <= 1) {
            goto LABEL_45;
          }
        }
        if (v27[v33] < v32)
        {
          uint64_t v37 = v33 + 1;
          if ((int)v37 < v28 && v27[v37] >= v32 || (uint64_t v37 = v33 + 2, v33 + 2 < v28) && v27[v37] >= v32) {
            int v33 = v37;
          }
          else {
            v33 += 3;
          }
        }
      }
      else
      {
        int v33 = 0;
      }
LABEL_45:
      if (v33 >= v28 || v33 < 0 || v27[v33] != v32) {
        goto LABEL_83;
      }
      unint64_t v10 = v20[v33];
      if (HIBYTE(v20[v33]))
      {
        BOOL v41 = (v10 & 0xC0000000) != 0 || a8 != 0 || v16 >> 8 < 0x19 || v17 < 0x20000;
        if ((v10 & 0x20000000) == 0 && v41)
        {
          uint64_t result = (v12 + v13 + 2);
          unint64_t v11 = v20[v33];
        }
        goto LABEL_83;
      }
    }
  }
  uint64_t result = 0;
  BOOL v45 = (v10 & 0xC0000000) != 0
     || a8 != 0
     || (a2 - 57344) >> 8 < 0x19
     || (a2 - 983040) < 0x20000;
  if ((v10 & 0x20000000) == 0 && v45)
  {
    uint64_t result = 2;
    goto LABEL_84;
  }
  return result;
}

uint64_t sub_18C85FA6C(unint64_t a1, int a2, int *a3, int a4)
{
  unsigned int v9 = 0;
  int v5 = sub_18C85F7E4(a1, a2, 0, 0, 0, 0, &v9, a4, 1);
  uint64_t result = 0;
  if (v5 >= 2)
  {
    int v7 = v9;
    unsigned int v8 = HIBYTE(v9) & 0x1F;
    if (v8 <= 3)
    {
      *a3 = v9 & 0xFFFFFF;
      if (v7 < 0) {
        return v8;
      }
      else {
        return -v8;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t sub_18C85FAF4(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unsigned int v32 = 0;
  unint64_t v8 = *(void *)(*(void *)(a1 + 48) + 288);
  int v9 = *(_DWORD *)(a1 + 208);
  unint64_t v10 = (UChar *)(a1 + 212);
  int v11 = *(char *)(a1 + 281);
  int v12 = *(__int16 **)(a2 + 16);
  unint64_t result = sub_18C85F7E4(v8, v9, a1 + 212, v11, (uint64_t)v12, (*(void *)(a2 + 24) - (void)v12) >> 1, &v32, *(char *)(a1 + 63), *(unsigned char *)(a2 + 2));
  int v14 = result - 2;
  if ((int)result >= 2)
  {
    int v15 = v14 - v11;
    if (v14 >= v11)
    {
      LOBYTE(v17) = 0;
      *(void *)(a2 + 16) = &v12[v15];
    }
    else
    {
      int v16 = v11 - v14;
      u_memmove(v10, &v10[v14], v11 - v14);
      int v17 = -v16;
      unint64_t v8 = *(void *)(*(void *)(a1 + 48) + 288);
    }
    *(unsigned char *)(a1 + 281) = v17;
    *(_DWORD *)(a1 + 208) = -1;
    char v18 = v32;
    unint64_t v19 = (void *)(a2 + 32);
    unint64_t v20 = *(void *)(a2 + 40);
    unsigned int v21 = (void *)(a2 + 48);
    memset(v33, 0, sizeof(v33));
    unint64_t v22 = ((unint64_t)v32 >> 24) & 0x1F;
    if (v22 > 3)
    {
      BOOL v23 = (char *)(v8 + (v32 & 0xFFFFFF) + *(int *)(v8 + 32));
    }
    else
    {
      BOOL v23 = (char *)v33 + 1;
      BOOL v24 = (char *)v33 + 1;
      if (v22 != 1)
      {
        BOOL v25 = (char *)v33 + 1;
        if (v22 != 2)
        {
          if (v22 != 3) {
            goto LABEL_17;
          }
          BOOL v25 = (char *)v33 + 2;
          BYTE1(v33[0]) = BYTE2(v32);
        }
        *BOOL v25 = BYTE1(v32);
        BOOL v24 = v25 + 1;
      }
      *BOOL v24 = v18;
    }
LABEL_17:
    int v26 = *(_DWORD *)(a1 + 80);
    if (v26)
    {
      if (v22 == 1 && v26 > 1)
      {
        char v27 = 15;
        int v28 = 1;
LABEL_28:
        *(_DWORD *)(a1 + 80) = v28;
        LOBYTE(v33[0]) = v27;
        if (v23 != (char *)v33 + 1) {
          memcpy((char *)v33 + 1, v23, v22);
        }
        LODWORD(v22) = v22 + 1;
        BOOL v23 = (char *)v33;
        return sub_18C85D210(a1, v23, v22, v19, v20, v21, a3, a4);
      }
      if (v22 >= 2 && v26 == 1)
      {
        char v27 = 14;
        int v28 = 2;
        goto LABEL_28;
      }
    }
    return sub_18C85D210(a1, v23, v22, v19, v20, v21, a3, a4);
  }
  if ((result & 0x80000000) != 0)
  {
    if (-2 - (int)result > v11)
    {
      int v29 = (_WORD *)(a1 + 2 * v11 + 212);
      uint64_t v30 = -2 - (v11 + (uint64_t)(int)result);
      do
      {
        __int16 v31 = *v12++;
        *v29++ = v31;
        --v30;
      }
      while (v30);
    }
    *(void *)(a2 + 16) = v12;
    *(unsigned char *)(a1 + 281) = -2 - result;
  }
  else
  {
    if (result == 1) {
      *(unsigned char *)(a1 + 95) = 1;
    }
    *(_DWORD *)(a1 + 84) = v9;
    *(_DWORD *)(a1 + 208) = -1;
    *(unsigned char *)(a1 + 281) = -(char)v11;
    *a4 = 10;
  }
  return result;
}

uint64_t sub_18C85FD84(uint64_t result, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(result + 288);
  if (v4)
  {
    uint64_t v7 = *(unsigned int *)(v4 + 44);
    int v8 = a4 - 2;
    if (a4 == 2)
    {
      uint64_t v9 = 3;
    }
    else
    {
      BOOL v10 = *(unsigned __int8 *)(result + 252) != 219 && a4 == 0;
      uint64_t v9 = v10 ? 1 : 2;
    }
    if ((int)v7 >= 1)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = v4 + *(int *)(v4 + 40);
      uint64_t v14 = v4 + *(int *)(v4 + 60);
      uint64_t v27 = *(int *)(v4 + 52);
      memset(v29, 0, sizeof(v29));
      uint64_t v24 = v13;
      uint64_t v25 = v7;
      while (1)
      {
        uint64_t v26 = v11;
        uint64_t v15 = *(unsigned __int16 *)(v13 + 2 * v11);
        if ((int)v7 < (int)v15) {
          break;
        }
        uint64_t v12 = (v12 + 1024);
LABEL_54:
        LODWORD(v7) = v25;
        uint64_t v11 = v26 + 1;
        uint64_t v13 = v24;
        if (v26 + 1 == v25) {
          return result;
        }
      }
      uint64_t v16 = 0;
      uint64_t v28 = v13 + 2 * v15;
      while (!*(_WORD *)(v28 + 2 * v16))
      {
        uint64_t v12 = (v12 + 16);
LABEL_51:
        if (++v16 == 64) {
          goto LABEL_54;
        }
      }
      uint64_t v17 = v27 + 8 * *(unsigned __int16 *)(v28 + 2 * v16);
      while (1)
      {
        unsigned int v18 = *(_DWORD *)(v14 + 4 * *(unsigned __int16 *)(v4 + v17));
        if (v18)
        {
          if (HIBYTE(v18))
          {
            if (a3)
            {
              if ((v18 & 0x20000000) == 0) {
                goto LABEL_28;
              }
            }
            else if ((v18 & 0xA0000000) == 0x80000000)
            {
LABEL_28:
              if ((HIBYTE(v18) & 0x1F) >= v9)
              {
                switch(v8)
                {
                  case 0:
                    if ((v18 & 0x1F000000) == 0x3000000 && (v18 & 0xFF0000) < 0x830000) {
                      goto LABEL_49;
                    }
                    break;
                  case 1:
                    if ((v18 & 0x1F000000) == 0x2000000 && (v18 & 0xFFFFFF) - 33088 < 0x6EBD) {
                      goto LABEL_49;
                    }
                    break;
                  case 2:
                    BOOL v22 = (v18 & 0x1F000000) != 0x2000000 || (((_WORD)v18 + 24159) & 0xFFFEu) > 0x5D5D;
                    if (!v22 && (((_BYTE)v18 + 95) & 0xFEu) < 0x5E) {
                      goto LABEL_49;
                    }
                    break;
                  case 3:
                    BOOL v23 = (v18 & 0x1F000000) != 0x2000000 || (((_WORD)v18 + 24159) & 0xFFFEu) > 0x5C5D;
                    if (!v23 && (((_BYTE)v18 + 95) & 0xFEu) <= 0x5D) {
                      goto LABEL_49;
                    }
                    break;
                  default:
LABEL_49:
                    unint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
                    break;
                }
              }
            }
          }
          else
          {
            if (WORD1(v12))
            {
              unsigned int v20 = (v12 >> 10) - 10304;
              *(_WORD *)&v29[2] = v12 & 0x3FF | 0xDC00;
              uint64_t v19 = 2;
            }
            else
            {
              uint64_t v19 = 1;
              LOWORD(v20) = v12;
            }
            *(_WORD *)int v29 = v20;
            unint64_t result = sub_18C860060(v4, a2, a3, v9, v12, (uint64_t)v29, v19, v18);
          }
        }
        uint64_t v12 = (v12 + 1);
        v17 += 2;
        if ((v12 & 0xF) == 0) {
          goto LABEL_51;
        }
      }
    }
  }
  return result;
}

uint64_t sub_18C860060(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, int a8)
{
  int v9 = a7;
  uint64_t v14 = result;
  uint64_t v15 = *(int *)(result + 20);
  uint64_t v16 = *(int *)(result + 24);
  uint64_t v17 = *(unsigned __int16 *)(result + v15 + 2 * a8);
  unsigned int v18 = *(_DWORD *)(result + v16 + 4 * a8);
  if (a3)
  {
    if ((v18 & 0x20000000) != 0) {
      goto LABEL_11;
    }
  }
  else if ((v18 & 0xA0000000) != 0x80000000)
  {
    goto LABEL_11;
  }
  if ((int)(HIBYTE(v18) & 0x1F) >= (int)a4)
  {
    if (a5 < 0x10000) {
      int v19 = 1;
    }
    else {
      int v19 = 2;
    }
    uint64_t v20 = *a2;
    if (v19 != a7)
    {
      unint64_t result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[3])(v20, a6, a7);
      if (v17) {
        goto LABEL_12;
      }
      return result;
    }
    unint64_t result = ((uint64_t (*)(uint64_t))a2[1])(v20);
  }
LABEL_11:
  if (v17)
  {
LABEL_12:
    uint64_t v21 = a8;
    uint64_t v22 = v9;
    uint64_t v23 = (v9 + 1);
    uint64_t v24 = v16 + 4 * v21 + 4;
    uint64_t v25 = v15 + 2 * v21 + 2;
    do
    {
      *(_WORD *)(a6 + 2 * v22) = *(_WORD *)(v14 + v25);
      unsigned int v26 = *(_DWORD *)(v14 + v24);
      if (v26)
      {
        if (HIBYTE(v26))
        {
          if (a3)
          {
            if ((v26 & 0x20000000) == 0) {
              goto LABEL_20;
            }
          }
          else if ((v26 & 0xA0000000) == 0x80000000)
          {
LABEL_20:
            if ((int)(HIBYTE(v26) & 0x1F) >= (int)a4) {
              unint64_t result = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, a6, v23);
            }
          }
        }
        else
        {
          unint64_t result = sub_18C860060(v14, a2, a3, a4, a5, a6, v23);
        }
      }
      v25 += 2;
      v24 += 4;
      --v17;
    }
    while (v17);
  }
  return result;
}

unsigned char *ucnv_io_stripASCIIForCompare(unsigned char *result, unsigned char *a2)
{
  int v2 = *a2;
  int v3 = result;
  if (!*a2) {
    goto LABEL_20;
  }
  int v4 = 0;
  int v3 = result;
  do
  {
    ++a2;
    while (1)
    {
      if ((v2 & 0x80) != 0 || (int v5 = byte_18CA7FB2C[v2]) == 0)
      {
        int v2 = *a2;
        goto LABEL_12;
      }
      if (v5 != 1) {
        break;
      }
      if (v4)
      {
        int v4 = 1;
        goto LABEL_19;
      }
      if ((char)*a2 < 0 || byte_18CA7FB2C[*a2] - 1 > 1)
      {
        int v4 = 0;
        goto LABEL_19;
      }
      int v2 = *a2;
LABEL_12:
      int v4 = 0;
      ++a2;
      if (!v2) {
        goto LABEL_20;
      }
    }
    if (v5 == 2)
    {
      int v4 = 1;
    }
    else
    {
      LOBYTE(v2) = byte_18CA7FB2C[v2];
      int v4 = 0;
    }
LABEL_19:
    *v3++ = v2;
    int v2 = *a2;
  }
  while (*a2);
LABEL_20:
  *int v3 = 0;
  return result;
}

unsigned char *ucnv_io_stripEBCDICForCompare(unsigned char *result, unsigned char *a2)
{
  LOBYTE(v2) = *a2;
  int v3 = result;
  if (!*a2) {
    goto LABEL_20;
  }
  int v4 = 0;
  int v3 = result;
  do
  {
    ++a2;
    while (1)
    {
      if ((v2 & 0x80) == 0 || (int v5 = byte_18CA7FBAC[v2 & 0x7F]) == 0)
      {
        int v2 = *a2;
        goto LABEL_12;
      }
      if (v5 != 1) {
        break;
      }
      if (v4)
      {
        int v4 = 1;
        goto LABEL_19;
      }
      int v6 = (char)*a2;
      if ((v6 & 0x80000000) == 0 || byte_18CA7FBAC[v6 & 0x7F] - 1 > 1)
      {
        int v4 = 0;
        goto LABEL_19;
      }
      int v2 = *a2;
LABEL_12:
      int v4 = 0;
      ++a2;
      if (!v2) {
        goto LABEL_20;
      }
    }
    if (v5 == 2)
    {
      int v4 = 1;
    }
    else
    {
      LOBYTE(v2) = byte_18CA7FBAC[v2 & 0x7F];
      int v4 = 0;
    }
LABEL_19:
    *v3++ = v2;
    LOBYTE(v2) = *a2;
  }
  while (*a2);
LABEL_20:
  *int v3 = 0;
  return result;
}

uint64_t ucnv_compareNames(char *a1, char *a2)
{
  int v2 = 0;
  BOOL v3 = 0;
  while (2)
  {
    int v5 = *a1++;
    int v4 = v5;
    if (!v5)
    {
      int v7 = 0;
      goto LABEL_21;
    }
    int v6 = v2;
    while (1)
    {
      if ((v4 & 0x80) != 0 || (int v7 = byte_18CA7FB2C[v4]) == 0)
      {
        int v4 = *a1;
        goto LABEL_12;
      }
      if (v7 != 1) {
        break;
      }
      if (v6)
      {
        int v2 = 1;
        goto LABEL_20;
      }
      if (*a1 < 0 || byte_18CA7FB2C[*a1] - 1 > 1)
      {
        int v2 = 0;
LABEL_20:
        int v7 = v4;
        goto LABEL_21;
      }
      int v4 = *a1;
LABEL_12:
      int v6 = 0;
      int v7 = 0;
      int v2 = 0;
      ++a1;
      if (!v4) {
        goto LABEL_21;
      }
    }
    if (v7 == 2)
    {
      int v7 = v4;
      int v2 = 1;
    }
    else
    {
      int v2 = 0;
    }
LABEL_21:
    int v9 = *a2++;
    int v8 = v9;
    if (!v9)
    {
      int v12 = 0;
      goto LABEL_41;
    }
    BOOL v10 = v3;
    while (2)
    {
      if ((v8 & 0x80) != 0 || (int v11 = byte_18CA7FB2C[v8]) == 0)
      {
        int v8 = *a2;
LABEL_31:
        BOOL v10 = 0;
        int v12 = 0;
        BOOL v3 = 0;
        ++a2;
        if (!v8) {
          goto LABEL_41;
        }
        continue;
      }
      break;
    }
    if (v11 == 1)
    {
      if (v10)
      {
        BOOL v3 = 1;
        goto LABEL_40;
      }
      if (*a2 < 0 || byte_18CA7FB2C[*a2] - 1 > 1)
      {
        BOOL v3 = 0;
LABEL_40:
        int v12 = v8;
        goto LABEL_41;
      }
      int v8 = *a2;
      goto LABEL_31;
    }
    if (v11 == 2) {
      int v12 = v8;
    }
    else {
      int v12 = byte_18CA7FB2C[v8];
    }
    BOOL v3 = v11 == 2;
LABEL_41:
    if (v12 | v7)
    {
      uint64_t v13 = (v7 - v12);
      if (v13) {
        return v13;
      }
      continue;
    }
    return 0;
  }
}

uint64_t ucnv_io_getConverterName(char *a1, unsigned char *a2, UErrorCode *a3)
{
  char v4 = 0;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  for (char i = 1; ; char i = 0)
  {
    char v6 = i;
    if (v4)
    {
      if (*a1 != 120 || a1[1] != 45) {
        return 0;
      }
      a1 += 2;
    }
    if (!sub_18C86069C(a3)) {
      return 0;
    }
    if (!a1)
    {
      uint64_t result = 0;
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
      return result;
    }
    if (!*a1) {
      return 0;
    }
    uint64_t v7 = xmmword_1E9191D70;
    int v8 = *(unsigned __int16 *)xmmword_1E9191D70;
    memset(v26, 0, 60);
    int v9 = a1;
    char v25 = v6;
    if (!v8) {
      break;
    }
    if (strlen(a1) < 0x3C)
    {
      int v9 = (char *)v26;
      ucnv_io_stripASCIIForCompare(v26, a1);
      break;
    }
    *a3 = U_BUFFER_OVERFLOW_ERROR;
LABEL_29:
    char v4 = 1;
    if ((v25 & 1) == 0) {
      return 0;
    }
  }
  int v10 = 0;
  uint64_t v11 = DWORD1(xmmword_1E9191D90);
  uint64_t v12 = DWORD1(xmmword_1E9191D90) >> 1;
  uint64_t v13 = xmmword_1E9191D50;
  uint64_t v15 = *((void *)&xmmword_1E9191D70 + 1);
  uint64_t v14 = qword_1E9191D80;
  while (1)
  {
    uint64_t v16 = *(unsigned __int16 *)(v13 + 2 * v12);
    int v17 = v8 ? strcmp(v9, (const char *)(v14 + 2 * v16)) : ucnv_compareNames(v9, (char *)(v15 + 2 * v16));
    uint64_t v18 = v12;
    if ((v17 & 0x80000000) == 0)
    {
      int v10 = v12;
      uint64_t v18 = v11;
      if (!v17) {
        break;
      }
    }
    BOOL v19 = v12 == (v18 + v10) >> 1;
    uint64_t v12 = (v18 + v10) >> 1;
    uint64_t v11 = v18;
    if (v19) {
      goto LABEL_29;
    }
  }
  uint64_t v20 = *((void *)&xmmword_1E9191D50 + 1);
  int v21 = *(__int16 *)(*((void *)&xmmword_1E9191D50 + 1) + 2 * v12);
  if (v21 < 0) {
    *a3 = U_AMBIGUOUS_ALIAS_WARNING;
  }
  if (a2)
  {
    int v21 = ((unsigned __int16)v21 >> 14) & 1;
    if (!*(unsigned char *)(v7 + 2)) {
      LOBYTE(v21) = 1;
    }
    *a2 = v21;
    LOWORD(v21) = *(_WORD *)(v20 + 2 * v12);
  }
  if (dword_1E9191D88 <= (v21 & 0xFFFu)) {
    goto LABEL_29;
  }
  return v15 + 2 * *(unsigned __int16 *)(xmmword_1E9191D40 + 2 * (v21 & 0xFFF));
}

BOOL sub_18C86069C(UErrorCode *a1)
{
  if (*(int *)a1 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191DB0, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191DB0))
    {
      if (dword_1E9191DB4 >= 1) {
        *a1 = dword_1E9191DB4;
      }
    }
    else
    {
      sub_18C861C30(a1);
      dword_1E9191DB4 = *a1;
      icu::umtx_initImplPostInit(&dword_1E9191DB0);
    }
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

void *ucnv_openStandardNames(char *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  if (!sub_18C86069C(a3)) {
    return 0;
  }
  if (!a1)
  {
    int v9 = 0;
    int v12 = 1;
LABEL_9:
    *a3 = v12;
    return v9;
  }
  if (!*a1) {
    return 0;
  }
  unsigned int v6 = sub_18C860810(a1, a2, (int *)a3);
  if (v6 >= HIDWORD(xmmword_1E9191D90)) {
    return 0;
  }
  unsigned int v7 = v6;
  int v8 = uprv_malloc(0x38uLL);
  int v9 = v8;
  if (!v8)
  {
    int v12 = 7;
    goto LABEL_9;
  }
  long long v10 = *(_OWORD *)&off_1EDA45CF8;
  *(_OWORD *)int v8 = xmmword_1EDA45CE8;
  *((_OWORD *)v8 + 1) = v10;
  *((_OWORD *)v8 + 2) = xmmword_1EDA45D08;
  v8[6] = off_1EDA45D18;
  uint64_t v11 = uprv_malloc(8uLL);
  if (!v11)
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
    uprv_free(v9);
    return 0;
  }
  *uint64_t v11 = v7;
  v11[1] = 0;
  v9[1] = v11;
  return v9;
}

uint64_t sub_18C860810(char *a1, unsigned __int8 *a2, int *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = sub_18C861EB4(a2);
  int v6 = *(unsigned __int16 *)xmmword_1E9191D70;
  memset(v37, 0, 60);
  unsigned int v7 = a1;
  if (v6)
  {
    if (strlen(a1) >= 0x3C)
    {
      int v8 = 15;
      unsigned int v9 = -1;
LABEL_17:
      *a3 = v8;
      goto LABEL_18;
    }
    unsigned int v7 = (char *)v37;
    ucnv_io_stripASCIIForCompare(v37, a1);
  }
  int v35 = a3;
  int v10 = 0;
  uint64_t v11 = DWORD1(xmmword_1E9191D90);
  uint64_t v12 = DWORD1(xmmword_1E9191D90) >> 1;
  uint64_t v13 = xmmword_1E9191D50;
  uint64_t v15 = *((void *)&xmmword_1E9191D70 + 1);
  uint64_t v14 = qword_1E9191D80;
  while (1)
  {
    uint64_t v16 = *(unsigned __int16 *)(v13 + 2 * v12);
    int v17 = v6 ? strcmp(v7, (const char *)(v14 + 2 * v16)) : ucnv_compareNames(v7, (char *)(v15 + 2 * v16));
    uint64_t v18 = v12;
    if ((v17 & 0x80000000) == 0)
    {
      int v10 = v12;
      uint64_t v18 = v11;
      if (!v17) {
        break;
      }
    }
    BOOL v19 = v12 == (v18 + v10) >> 1;
    uint64_t v12 = (v18 + v10) >> 1;
    uint64_t v11 = v18;
    if (v19)
    {
      int v8 = 0;
      unsigned int v9 = -1;
      goto LABEL_18;
    }
  }
  unsigned int v9 = *(_WORD *)(*((void *)&xmmword_1E9191D50 + 1) + 2 * v12) & 0xFFF;
  if ((*(_WORD *)(*((void *)&xmmword_1E9191D50 + 1) + 2 * v12) & 0x8000) != 0)
  {
    int v8 = -122;
    a3 = v35;
    goto LABEL_17;
  }
  int v8 = 0;
LABEL_18:
  if (v5 >= dword_1E9191D8C - 1 || v9 >= dword_1E9191D88) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v20 = qword_1E9191D60;
  int v36 = dword_1E9191D88 * v5;
  unsigned int v21 = dword_1E9191D88 * v5 + v9;
  uint64_t result = *(unsigned __int16 *)(qword_1E9191D60 + 2 * v21);
  if (!*(_WORD *)(qword_1E9191D60 + 2 * v21) || !*(_WORD *)(qword_1E9191D68 + 2 * result + 2))
  {
    if (v8 == -122 && (uint64_t v23 = DWORD2(xmmword_1E9191D90), DWORD2(xmmword_1E9191D90)))
    {
      unsigned int v34 = dword_1E9191D88;
      uint64_t v24 = 0;
      uint64_t v25 = qword_1E9191D68;
      uint64_t v26 = *((void *)&xmmword_1E9191D70 + 1);
      while (1)
      {
        if (*(_WORD *)(v20 + 2 * v24))
        {
          uint64_t v27 = (unsigned __int16 *)(v25 + 2 * *(unsigned __int16 *)(v20 + 2 * v24));
          unsigned int v30 = *v27;
          uint64_t v28 = v27 + 1;
          unint64_t v29 = v30;
          if (v30)
          {
            uint64_t v31 = 0;
            BOOL v32 = 1;
            do
            {
              if (v28[v31] && !ucnv_compareNames(a1, (char *)(v26 + 2 * v28[v31]))) {
                break;
              }
              BOOL v32 = ++v31 < v29;
            }
            while (v29 != v31);
            if (v32)
            {
              unsigned int v33 = v24 % v34 + v36;
              uint64_t result = *(unsigned __int16 *)(v20 + 2 * v33);
              if (*(_WORD *)(v20 + 2 * v33))
              {
                if (*(_WORD *)(v25 + 2 * result + 2)) {
                  break;
                }
              }
            }
          }
        }
        if (++v24 == v23) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ucnv_getStandard(unsigned int a1, UErrorCode *a2)
{
  if (!sub_18C86069C(a2)) {
    return 0;
  }
  if (dword_1E9191D8C - 1 > a1) {
    return *((void *)&xmmword_1E9191D70 + 1)
  }
         + 2 * *(unsigned __int16 *)(*((void *)&xmmword_1E9191D40 + 1) + 2 * a1);
  uint64_t result = 0;
  *a2 = U_INDEX_OUTOFBOUNDS_ERROR;
  return result;
}

uint64_t ucnv_getStandardName(char *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  if (!sub_18C86069C(a3)) {
    return 0;
  }
  if (a1)
  {
    if (*a1)
    {
      unsigned int v6 = sub_18C860810(a1, a2, (int *)a3);
      if (v6)
      {
        if (v6 < HIDWORD(xmmword_1E9191D90) && *(_WORD *)(qword_1E9191D68 + 2 * v6 + 2)) {
          return *((void *)&xmmword_1E9191D70 + 1) + 2 * *(unsigned __int16 *)(qword_1E9191D68 + 2 * v6 + 2);
        }
      }
    }
    return 0;
  }
  uint64_t result = 0;
  *a3 = U_ILLEGAL_ARGUMENT_ERROR;
  return result;
}

uint64_t ucnv_countAliases(char *a1, UErrorCode *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_18C86069C(a2);
  if (result)
  {
    if (!a1)
    {
      uint64_t result = 0;
      *a2 = U_ILLEGAL_ARGUMENT_ERROR;
      return result;
    }
    if (!*a1) {
      return 0;
    }
    int v5 = *(unsigned __int16 *)xmmword_1E9191D70;
    memset(v19, 0, 60);
    if (v5)
    {
      if (strlen(a1) >= 0x3C)
      {
        *a2 = U_BUFFER_OVERFLOW_ERROR;
        return 0;
      }
      ucnv_io_stripASCIIForCompare(v19, a1);
      a1 = (char *)v19;
    }
    int v6 = 0;
    uint64_t v7 = DWORD1(xmmword_1E9191D90);
    uint64_t v8 = DWORD1(xmmword_1E9191D90) >> 1;
    uint64_t v9 = xmmword_1E9191D50;
    uint64_t v11 = *((void *)&xmmword_1E9191D70 + 1);
    uint64_t v10 = qword_1E9191D80;
    while (1)
    {
      uint64_t v12 = *(unsigned __int16 *)(v9 + 2 * v8);
      int v13 = v5 ? strcmp(a1, (const char *)(v10 + 2 * v12)) : ucnv_compareNames(a1, (char *)(v11 + 2 * v12));
      uint64_t v14 = v8;
      if ((v13 & 0x80000000) == 0)
      {
        int v6 = v8;
        uint64_t v14 = v7;
        if (!v13) {
          break;
        }
      }
      BOOL v15 = v8 == (v14 + v6) >> 1;
      uint64_t v8 = (v14 + v6) >> 1;
      uint64_t v7 = v14;
      if (v15) {
        return 0;
      }
    }
    __int16 v16 = *(_WORD *)(*((void *)&xmmword_1E9191D50 + 1) + 2 * v8);
    if (v16 < 0) {
      *a2 = U_AMBIGUOUS_ALIAS_WARNING;
    }
    unsigned int v17 = v16 & 0xFFF;
    if (dword_1E9191D88 > v17)
    {
      uint64_t v18 = *(unsigned __int16 *)(qword_1E9191D60 + 2 * (v17 + (dword_1E9191D8C - 1) * dword_1E9191D88));
      if (v18) {
        return *(unsigned __int16 *)(qword_1E9191D68 + 2 * v18);
      }
    }
    return 0;
  }
  return result;
}

uint64_t ucnv_getAlias(char *a1, unsigned int a2, UErrorCode *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!sub_18C86069C(a3)) {
    return 0;
  }
  if (!a1)
  {
    uint64_t result = 0;
    int v8 = 1;
    goto LABEL_8;
  }
  if (*a1)
  {
    int v6 = *(unsigned __int16 *)xmmword_1E9191D70;
    memset(v23, 0, 60);
    if (v6)
    {
      if (strlen(a1) >= 0x3C)
      {
        *a3 = U_BUFFER_OVERFLOW_ERROR;
        return 0;
      }
      ucnv_io_stripASCIIForCompare(v23, a1);
      a1 = (char *)v23;
    }
    int v9 = 0;
    uint64_t v10 = DWORD1(xmmword_1E9191D90);
    uint64_t v11 = DWORD1(xmmword_1E9191D90) >> 1;
    uint64_t v12 = xmmword_1E9191D50;
    uint64_t v13 = *((void *)&xmmword_1E9191D70 + 1);
    uint64_t v14 = qword_1E9191D80;
    while (1)
    {
      uint64_t v15 = *(unsigned __int16 *)(v12 + 2 * v11);
      int v16 = v6 ? strcmp(a1, (const char *)(v14 + 2 * v15)) : ucnv_compareNames(a1, (char *)(v13 + 2 * v15));
      uint64_t v17 = v11;
      if ((v16 & 0x80000000) == 0)
      {
        int v9 = v11;
        uint64_t v17 = v10;
        if (!v16) {
          break;
        }
      }
      BOOL v18 = v11 == (v17 + v9) >> 1;
      uint64_t v11 = (v17 + v9) >> 1;
      uint64_t v10 = v17;
      if (v18) {
        return 0;
      }
    }
    __int16 v19 = *(_WORD *)(*((void *)&xmmword_1E9191D50 + 1) + 2 * v11);
    if (v19 < 0) {
      *a3 = U_AMBIGUOUS_ALIAS_WARNING;
    }
    unsigned int v20 = v19 & 0xFFF;
    if (dword_1E9191D88 <= v20) {
      return 0;
    }
    uint64_t v21 = *(unsigned __int16 *)(qword_1E9191D60 + 2 * (v20 + (dword_1E9191D8C - 1) * dword_1E9191D88));
    if (!v21) {
      return 0;
    }
    uint64_t v22 = (unsigned __int16 *)(qword_1E9191D68 + 2 * v21);
    if (*v22 > a2) {
      return v13 + 2 * v22[a2 + 1];
    }
    uint64_t result = 0;
    int v8 = 8;
LABEL_8:
    *a3 = v8;
    return result;
  }
  return 0;
}

unint64_t ucnv_getAliases(char *a1, void *a2, UErrorCode *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  unint64_t result = sub_18C86069C(a3);
  if (result)
  {
    if (!a1)
    {
      int v8 = 1;
      goto LABEL_8;
    }
    if (!*a1) {
      return result;
    }
    int v7 = *(unsigned __int16 *)xmmword_1E9191D70;
    memset(v26, 0, 60);
    if (v7)
    {
      unint64_t result = strlen(a1);
      if (result >= 0x3C)
      {
        int v8 = 15;
LABEL_8:
        *a3 = v8;
        return result;
      }
      ucnv_io_stripASCIIForCompare(v26, a1);
      a1 = (char *)v26;
    }
    int v9 = 0;
    uint64_t v10 = DWORD1(xmmword_1E9191D90);
    uint64_t v11 = DWORD1(xmmword_1E9191D90) >> 1;
    uint64_t v12 = xmmword_1E9191D50;
    uint64_t v13 = *((void *)&xmmword_1E9191D70 + 1);
    uint64_t v14 = qword_1E9191D80;
    while (1)
    {
      uint64_t v15 = *(unsigned __int16 *)(v12 + 2 * v11);
      unint64_t result = v7 ? strcmp(a1, (const char *)(v14 + 2 * v15)) : ucnv_compareNames(a1, (char *)(v13 + 2 * v15));
      uint64_t v16 = v11;
      if ((result & 0x80000000) == 0)
      {
        int v9 = v11;
        uint64_t v16 = v10;
        if (!result) {
          break;
        }
      }
      BOOL v17 = v11 == (v16 + v9) >> 1;
      uint64_t v11 = (v16 + v9) >> 1;
      uint64_t v10 = v16;
      if (v17) {
        return result;
      }
    }
    __int16 v18 = *(_WORD *)(*((void *)&xmmword_1E9191D50 + 1) + 2 * v11);
    if (v18 < 0) {
      *a3 = U_AMBIGUOUS_ALIAS_WARNING;
    }
    unsigned int v19 = v18 & 0xFFF;
    if (dword_1E9191D88 > v19)
    {
      uint64_t v20 = *(unsigned __int16 *)(qword_1E9191D60 + 2 * (v19 + (dword_1E9191D8C - 1) * dword_1E9191D88));
      if (v20)
      {
        uint64_t v21 = (unsigned __int16 *)(qword_1E9191D68 + 2 * v20);
        unsigned int v24 = *v21;
        uint64_t v22 = v21 + 1;
        uint64_t v23 = v24;
        if (v24)
        {
          do
          {
            unsigned int v25 = *v22++;
            *a2++ = v13 + 2 * v25;
            --v23;
          }
          while (v23);
        }
      }
    }
  }
  return result;
}

uint64_t ucnv_countStandards()
{
  int v3 = 0;
  BOOL v0 = sub_18C86069C((UErrorCode *)&v3);
  unsigned __int16 v1 = dword_1E9191D8C - 1;
  if (!v0) {
    return 0;
  }
  return v1;
}

uint64_t ucnv_getCanonicalName(char *a1, unsigned __int8 *a2, UErrorCode *a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!sub_18C86069C(a3)) {
    return 0;
  }
  if (!a1)
  {
    uint64_t result = 0;
    *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    return result;
  }
  if (!*a1) {
    return 0;
  }
  unsigned int v6 = sub_18C861EB4(a2);
  int v7 = *(unsigned __int16 *)xmmword_1E9191D70;
  memset(v48, 0, 60);
  int v8 = a1;
  if (v7)
  {
    if (strlen(a1) >= 0x3C)
    {
      int v9 = 15;
      unsigned int v10 = -1;
      goto LABEL_22;
    }
    int v8 = (char *)v48;
    ucnv_io_stripASCIIForCompare(v48, a1);
  }
  unsigned int v45 = v6;
  int v12 = 0;
  uint64_t v13 = DWORD1(xmmword_1E9191D90);
  uint64_t v14 = DWORD1(xmmword_1E9191D90) >> 1;
  uint64_t v15 = xmmword_1E9191D50;
  uint64_t v17 = *((void *)&xmmword_1E9191D70 + 1);
  uint64_t v16 = qword_1E9191D80;
  while (1)
  {
    uint64_t v18 = *(unsigned __int16 *)(v15 + 2 * v14);
    int v19 = v7 ? strcmp(v8, (const char *)(v16 + 2 * v18)) : ucnv_compareNames(v8, (char *)(v17 + 2 * v18));
    uint64_t v20 = v14;
    if ((v19 & 0x80000000) == 0)
    {
      int v12 = v14;
      uint64_t v20 = v13;
      if (!v19) {
        break;
      }
    }
    BOOL v21 = v14 == (v20 + v12) >> 1;
    uint64_t v14 = (v20 + v12) >> 1;
    uint64_t v13 = v20;
    if (v21)
    {
      int v9 = 0;
      unsigned int v10 = -1;
LABEL_20:
      unsigned int v6 = v45;
      goto LABEL_23;
    }
  }
  __int16 v22 = *(_WORD *)(*((void *)&xmmword_1E9191D50 + 1) + 2 * v14);
  unsigned int v10 = v22 & 0xFFF;
  if ((v22 & 0x8000) == 0)
  {
    int v9 = 0;
    goto LABEL_20;
  }
  int v9 = -122;
  unsigned int v6 = v45;
LABEL_22:
  *a3 = v9;
LABEL_23:
  if (v6 >= dword_1E9191D8C - 1) {
    return 0;
  }
  unsigned int v23 = dword_1E9191D88;
  if (v10 >= dword_1E9191D88) {
    return 0;
  }
  uint64_t v24 = qword_1E9191D60;
  uint64_t v25 = dword_1E9191D88 * v6;
  if (!*(_WORD *)(qword_1E9191D60 + 2 * (v25 + v10))) {
    goto LABEL_50;
  }
  uint64_t v26 = (unsigned __int16 *)(qword_1E9191D68
                           + 2 * *(unsigned __int16 *)(qword_1E9191D60 + 2 * (v25 + v10)));
  unsigned int v29 = *v26;
  uint64_t v27 = v26 + 1;
  unint64_t v28 = v29;
  if (!v29) {
    goto LABEL_50;
  }
  uint64_t v43 = dword_1E9191D88 * v6;
  int v46 = dword_1E9191D88;
  unsigned int v30 = v6;
  uint64_t v31 = 0;
  uint64_t v32 = *((void *)&xmmword_1E9191D70 + 1);
  BOOL v33 = 1;
  do
  {
    if (v27[v31] && !ucnv_compareNames(a1, (char *)(v32 + 2 * v27[v31]))) {
      break;
    }
    BOOL v33 = ++v31 < v28;
  }
  while (v28 != v31);
  unsigned int v6 = v30;
  unsigned int v23 = v46;
  uint64_t v25 = v43;
  if (!v33)
  {
LABEL_50:
    if (v9 != -122) {
      return 0;
    }
    uint64_t v34 = v23 + v23 * v6;
    if (v25 >= v34) {
      return 0;
    }
    unsigned int v47 = v23;
    uint64_t v35 = qword_1E9191D68;
    uint64_t v32 = *((void *)&xmmword_1E9191D70 + 1);
    int v44 = v25;
    uint64_t v36 = v25;
    while (1)
    {
      if (*(_WORD *)(v24 + 2 * v36))
      {
        uint64_t v37 = (unsigned __int16 *)(v35 + 2 * *(unsigned __int16 *)(v24 + 2 * v36));
        unsigned int v40 = *v37;
        uint64_t v38 = v37 + 1;
        unint64_t v39 = v40;
        if (v40)
        {
          uint64_t v41 = 0;
          BOOL v42 = 1;
          do
          {
            if (v38[v41] && !ucnv_compareNames(a1, (char *)(v32 + 2 * v38[v41]))) {
              break;
            }
            BOOL v42 = ++v41 < v39;
          }
          while (v39 != v41);
          if (v42) {
            break;
          }
        }
      }
      uint64_t result = 0;
      if (++v36 == v34) {
        return result;
      }
    }
    unsigned int v10 = v36 - v44;
    unsigned int v23 = v47;
  }
  if (v10 < v23) {
    return v32 + 2 * *(unsigned __int16 *)(xmmword_1E9191D40 + 2 * v10);
  }
  return 0;
}

void *ucnv_openAllNames(UErrorCode *a1)
{
  if (!sub_18C86069C(a1)) {
    return 0;
  }
  int v2 = uprv_malloc(0x38uLL);
  int v3 = v2;
  if (!v2)
  {
    *a1 = U_MEMORY_ALLOCATION_ERROR;
    return v3;
  }
  long long v4 = *(_OWORD *)&off_1EDA45D30;
  *(_OWORD *)int v2 = xmmword_1EDA45D20;
  *((_OWORD *)v2 + 1) = v4;
  *((_OWORD *)v2 + 2) = xmmword_1EDA45D40;
  v2[6] = off_1EDA45D50;
  int v5 = uprv_malloc(2uLL);
  if (!v5)
  {
    *a1 = U_MEMORY_ALLOCATION_ERROR;
    uprv_free(v3);
    return 0;
  }
  *int v5 = 0;
  v3[1] = v5;
  return v3;
}

uint64_t ucnv_io_countKnownConverters(UErrorCode *a1)
{
  BOOL v1 = sub_18C86069C(a1);
  unsigned __int16 v2 = dword_1E9191D88;
  if (!v1) {
    return 0;
  }
  return v2;
}

uint64_t ucnv_swapAliases(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3;
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0;
  }
  uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x7600000043
    || *(unsigned char *)(a2 + 14) != 65
    || *(unsigned char *)(a2 + 15) != 108
    || *(unsigned char *)(a2 + 16) != 3)
  {
    udata_printError(a1, (uint64_t)"ucnv_swapAliases(): data format %02x.%02x.%02x.%02x (format version %02x) is not an alias table\n", v14, v15, v16, v17, v18, v19, v21);
    uint64_t result = 0;
    int v32 = 16;
    goto LABEL_13;
  }
  int v22 = v13;
  if ((v10 & 0x80000000) == 0)
  {
    uint64_t v23 = (v10 - v13);
    if ((int)v23 <= 35)
    {
LABEL_23:
      udata_printError(a1, (uint64_t)"ucnv_swapAliases(): too few bytes (%d after header) for an alias table\n", v14, v15, v16, v17, v18, v19, v23);
      uint64_t result = 0;
      int v32 = 8;
      goto LABEL_13;
    }
  }
  int v97 = 0;
  long long v96 = 0u;
  long long v95 = 0u;
  uint64_t v24 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)(a2 + v13));
  unsigned int v31 = v24;
  v94[0] = v24;
  if ((v24 - 10) < 0xFFFFFFFE)
  {
    udata_printError(a1, (uint64_t)"ucnv_swapAliases(): table of contents contains unsupported number of sections (%u sections)\n", v25, v26, v27, v28, v29, v30, v24);
    uint64_t result = 0;
    int v32 = 3;
LABEL_13:
    *a5 = v32;
    return result;
  }
  uint64_t v82 = a2 + v22;
  uint64_t v33 = v22 + 4;
  uint64_t v34 = &v95;
  unint64_t v83 = (v24 + 1);
  uint64_t v35 = (char *)(v83 - 1);
  do
  {
    *(_DWORD *)uint64_t v34 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)(a2 + v33));
    uint64_t v34 = (long long *)((char *)v34 + 4);
    v33 += 4;
    --v35;
  }
  while (v35);
  uint64_t v93 = 0;
  long long v91 = 0u;
  long long v92 = 0u;
  int v36 = 2 * v83;
  DWORD1(v91) = 2 * v83;
  if (v31 >= 2)
  {
    uint64_t v38 = 0;
    do
    {
      v36 += *((_DWORD *)&v95 + (void)v38);
      *((_DWORD *)&v91 + (void)v38++ + 2) = v36;
    }
    while ((unsigned char *)(v83 - 2) != v38);
    int v36 = *((_DWORD *)&v91 + (void)v38 + 1);
    int v37 = v38 + 1;
  }
  else
  {
    int v37 = 1;
  }
  int v39 = v94[v37] + v36;
  if (v10 < 0)
  {
    int v40 = 2 * v39;
  }
  else
  {
    uint64_t v23 = (v10 - v22);
    if ((int)v23 < 2 * v39) {
      goto LABEL_23;
    }
    (*(void (**)(uint64_t, uint64_t, void, char *, int *))(a1 + 56))(a1, v82, (4 * v83), (char *)a4 + v22, a5);
    int v41 = v93;
    uint64_t v42 = (uint64_t)&a4[v93] + v22;
    (*(void (**)(uint64_t, uint64_t, void, uint64_t, int *))(a1 + 72))(a1, v82 + 2 * v93, (2 * (v97 + HIDWORD(v96))), v42, a5);
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"ucnv_swapAliases().swapInvChars(charset names) failed\n", v43, v44, v45, v46, v47, v48, v75);
      return 0;
    }
    int v40 = 2 * v39;
    int v49 = *(unsigned __int8 *)(a1 + 3);
    if (*(unsigned __int8 *)(a1 + 1) == v49)
    {
      (*(void (**)(uint64_t, uint64_t, void, uint64_t, int *))(a1 + 48))(a1, v82 + 2 * DWORD1(v91), (2 * (v41 - DWORD1(v91))), (uint64_t)&a4[DWORD1(v91)] + v22, a5);
    }
    else
    {
      int v79 = v41;
      int v86 = 0;
      __src = 0;
      uint64_t v88 = 0;
      uint64_t v50 = DWORD2(v95);
      uint64_t v85 = v42;
      if (DWORD2(v95) > 0x1F4)
      {
        uint64_t v52 = (unsigned __int16 *)uprv_malloc((2 * DWORD2(v95)) + 4 * DWORD2(v95));
        int v86 = v52;
        if (!v52)
        {
          udata_printError(a1, (uint64_t)"ucnv_swapAliases(): unable to allocate memory for sorting tables (max length: %u)\n", v53, v54, v55, v56, v57, v58, v50);
          uint64_t result = 0;
          int v32 = 7;
          goto LABEL_13;
        }
        uint64_t v51 = v52;
        int v78 = v40;
        unsigned int v81 = (char *)a4 + v22;
        __src = &v52[2 * v50];
        int v49 = *(unsigned __int8 *)(a1 + 3);
      }
      else
      {
        int v78 = v40;
        unsigned int v81 = (char *)a4 + v22;
        uint64_t v51 = (unsigned __int16 *)v90;
        int v86 = (unsigned __int16 *)v90;
        __src = v89;
      }
      if (v49) {
        int v59 = ucnv_io_stripEBCDICForCompare;
      }
      else {
        int v59 = ucnv_io_stripASCIIForCompare;
      }
      bzero(v90, 0x7D0uLL);
      bzero(v89, 0x3E8uLL);
      uint64_t v88 = v59;
      uint64_t v77 = v92;
      uint64_t v80 = HIDWORD(v91);
      uint64_t v60 = v82 + 2 * HIDWORD(v91);
      if (v50)
      {
        uint64_t v61 = 0;
        uint64_t v62 = v51 + 1;
        do
        {
          *(v62 - 1) = (*(uint64_t (**)(void))(a1 + 8))(*(unsigned __int16 *)(v60 + 2 * v61));
          *uint64_t v62 = v61;
          v62 += 2;
          ++v61;
        }
        while (v50 != v61);
      }
      uprv_sortArray((uint64_t)v51, v50, 4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_18C861B78, (uint64_t)&v85, 0, a5);
      if (*a5 <= 0)
      {
        int __dst = &v81[2 * v80];
        v84 = &v81[2 * v77];
        if ((unsigned __int16 *)a2 == a4)
        {
          int v71 = (char *)__src;
          if (v50)
          {
            uint64_t v72 = 0;
            size_t v73 = 2 * v50;
            do
            {
              (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v60 + 2 * v86[v72 + 1], 2, &v71[v72], a5);
              v72 += 2;
            }
            while (v73 != v72);
            memcpy(__dst, v71, 2 * v50);
            uint64_t v74 = 0;
            do
            {
              (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v82 + 2 * v77 + 2 * v86[v74 + 1], 2, &v71[v74], a5);
              v74 += 2;
            }
            while (v73 != v74);
          }
          else
          {
            memcpy(__dst, __src, 2 * v50);
            size_t v73 = 0;
          }
          memcpy(v84, v71, v73);
        }
        else if (v50)
        {
          uint64_t v69 = 0;
          do
          {
            uint64_t v70 = v86[v69 + 1];
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v60 + 2 * v70, 2, &__dst[v69], a5);
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v82 + 2 * v77 + 2 * v70, 2, &v84[v69], a5);
            v69 += 2;
          }
          while (2 * v50 != v69);
        }
      }
      if (v86 != (unsigned __int16 *)v90) {
        uprv_free(v86);
      }
      if (*a5 >= 1)
      {
        udata_printError(a1, (uint64_t)"ucnv_swapAliases().uprv_sortArray(%u items) failed\n", v63, v64, v65, v66, v67, v68, v50);
        return 0;
      }
      (*(void (**)(uint64_t, uint64_t, void, char *, int *))(a1 + 48))(a1, v82 + 2 * DWORD1(v91), (2 * (v80 - DWORD1(v91))), &v81[2 * DWORD1(v91)], a5);
      (*(void (**)(uint64_t, uint64_t, void, char *, int *))(a1 + 48))(a1, v82 + 2 * DWORD1(v92), (2 * (v79 - DWORD1(v92))), &v81[2 * DWORD1(v92)], a5);
      int v40 = v78;
    }
  }
  return (v40 + v22);
}

uint64_t sub_18C861B78(uint64_t *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  memset(v10, 0, 60);
  memset(v9, 0, 60);
  uint64_t v5 = *a1;
  unsigned int v6 = (const char *)((uint64_t (*)(_OWORD *, uint64_t))a1[3])(v10, *a1 + 2 * *a2);
  int v7 = (const char *)((uint64_t (*)(_OWORD *, uint64_t))a1[3])(v9, v5 + 2 * *a3);
  return strcmp(v6, v7);
}

void sub_18C861C30(UErrorCode *a1)
{
  sub_18C8546F4(0x17u, (uint64_t)sub_18C861DF4);
  unsigned __int16 v2 = udata_openChoice(0, "icu", "cnvalias", (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18C861E50, 0, a1);
  if (*(int *)a1 <= 0)
  {
    int v3 = v2;
    uint64_t Memory = (int *)udata_getMemory((uint64_t)v2);
    int v5 = *Memory;
    if (*Memory > 7)
    {
      qword_1E9191DB8 = (uint64_t)v3;
      int v6 = Memory[1];
      dword_1E9191D88 = v6;
      int v7 = Memory[2];
      dword_1E9191D8C = v7;
      int v8 = Memory[3];
      LODWORD(xmmword_1E9191D90) = v8;
      int v9 = Memory[4];
      DWORD1(xmmword_1E9191D90) = v9;
      int v10 = Memory[5];
      DWORD2(xmmword_1E9191D90) = v10;
      int v11 = Memory[6];
      HIDWORD(xmmword_1E9191D90) = v11;
      int v12 = Memory[7];
      dword_1E9191DA0 = v12;
      int v13 = Memory[8];
      dword_1E9191DA4 = v13;
      if (v5 != 8) {
        dword_1E9191DA8 = Memory[9];
      }
      unsigned int v14 = 2 * v5 + 2;
      uint64_t v15 = (char *)Memory + 2 * v14;
      unsigned int v16 = v6 + v14;
      *(void *)&xmmword_1E9191D40 = v15;
      *((void *)&xmmword_1E9191D40 + 1) = (char *)Memory + 2 * v16;
      unsigned int v17 = v7 + v16;
      uint64_t v18 = (char *)Memory + 2 * v17;
      unsigned int v19 = v8 + v17;
      *(void *)&xmmword_1E9191D50 = v18;
      *((void *)&xmmword_1E9191D50 + 1) = (char *)Memory + 2 * v19;
      unsigned int v20 = v9 + v19;
      uint64_t v21 = (uint64_t)Memory + 2 * v20;
      unsigned int v22 = v10 + v20;
      qword_1E9191D60 = v21;
      qword_1E9191D68 = (uint64_t)Memory + 2 * v22;
      unsigned int v23 = v11 + v22;
      if (v12 && (uint64_t v24 = (unsigned __int16 *)Memory + v23, v25 = *v24, *v24 < 2u))
      {
        unsigned int v26 = v12 + v23;
        uint64_t v27 = (uint64_t)Memory + 2 * v26;
        *(void *)&xmmword_1E9191D70 = v24;
        *((void *)&xmmword_1E9191D70 + 1) = v27;
        if (v25) {
          uint64_t v27 = (uint64_t)Memory + 2 * v13 + 2 * v26;
        }
      }
      else
      {
        uint64_t v27 = (uint64_t)Memory + 2 * v12 + 2 * v23;
        *(void *)&xmmword_1E9191D70 = &unk_18CA7FC3A;
        *((void *)&xmmword_1E9191D70 + 1) = v27;
      }
      qword_1E9191D80 = v27;
    }
    else
    {
      *a1 = U_INVALID_FORMAT_ERROR;
      udata_close(v3);
    }
  }
}

uint64_t sub_18C861DF4()
{
  if (qword_1E9191DB8)
  {
    udata_close((_OWORD *)qword_1E9191DB8);
    qword_1E9191DB8 = 0;
  }
  atomic_store(0, &dword_1E9191DB0);
  xmmword_1E9191D90 = 0u;
  *(_OWORD *)&dword_1E9191DA0 = 0u;
  xmmword_1E9191D70 = 0u;
  *(_OWORD *)&qword_1E9191D80 = 0u;
  xmmword_1E9191D50 = 0u;
  *(_OWORD *)&qword_1E9191D60 = 0u;
  xmmword_1E9191D40 = 0u;
  return 1;
}

BOOL sub_18C861E50(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 67
      && a4[9] == 118
      && a4[10] == 65
      && a4[11] == 108
      && a4[12] == 3;
}

uint64_t sub_18C861EB4(unsigned __int8 *a1)
{
  if (*((void *)&xmmword_1E9191D40 + 1)) {
    BOOL v1 = dword_1E9191D8C == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = 0;
  while (uprv_stricmp((unsigned char *)(*((void *)&xmmword_1E9191D70 + 1)+ 2 * *(unsigned __int16 *)(*((void *)&xmmword_1E9191D40 + 1) + 2 * v3)), a1))
  {
    if (++v3 >= (unint64_t)dword_1E9191D8C) {
      return 0xFFFFFFFFLL;
    }
  }
  return v3;
}

void sub_18C861F34(void **a1)
{
  uprv_free(a1[1]);

  uprv_free(a1);
}

uint64_t sub_18C861F70(uint64_t a1)
{
  uint64_t v1 = **(unsigned int **)(a1 + 8);
  if (v1) {
    return *(unsigned __int16 *)(qword_1E9191D68 + 2 * v1);
  }
  else {
    return 0;
  }
}

uint64_t sub_18C861F94(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(unsigned int **)(a1 + 8);
  uint64_t v4 = *v3;
  if (v4 && (int v5 = (unsigned __int16 *)(qword_1E9191D68 + 2 * v4), v6 = v3[1], v6 < *v5))
  {
    uint64_t v7 = *((void *)&xmmword_1E9191D70 + 1);
    v3[1] = v6 + 1;
    uint64_t v8 = v5[v6 + 1];
    uint64_t v9 = v7 + 2 * v8;
    if (a2)
    {
      int v10 = strlen((const char *)(v7 + 2 * v8));
LABEL_7:
      *a2 = v10;
    }
  }
  else
  {
    uint64_t v9 = 0;
    if (a2)
    {
      int v10 = 0;
      goto LABEL_7;
    }
  }
  return v9;
}

uint64_t sub_18C86201C(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 8) + 4) = 0;
  return result;
}

uint64_t sub_18C862028()
{
  return dword_1E9191D88;
}

uint64_t sub_18C862034(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(_WORD **)(a1 + 8);
  uint64_t v4 = (unsigned __int16)*v3;
  if (dword_1E9191D88 <= v4)
  {
    uint64_t v8 = 0;
    if (a2)
    {
      int v9 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v5 = *((void *)&xmmword_1E9191D70 + 1);
    uint64_t v6 = xmmword_1E9191D40;
    *uint64_t v3 = v4 + 1;
    uint64_t v7 = *(unsigned __int16 *)(v6 + 2 * v4);
    uint64_t v8 = v5 + 2 * v7;
    if (a2)
    {
      int v9 = strlen((const char *)(v5 + 2 * v7));
LABEL_6:
      *a2 = v9;
    }
  }
  return v8;
}

uint64_t sub_18C8620B0(uint64_t result)
{
  **(_WORD **)(result + 8) = 0;
  return result;
}

void sub_18C8620BC(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C8620C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    for (uint64_t i = 0; i != 160; i += 8)
    {
      uint64_t v4 = *(void *)(v1 + i);
      if (v4) {
        sub_18C85B7D8(v4);
      }
    }
    if (!*(unsigned char *)(a1 + 62))
    {
      uprv_free(*(void **)(a1 + 16));
      *(void *)(a1 + 16) = 0;
    }
  }
}

void *sub_18C862124(void *result, int *a2)
{
  uint64_t v3 = result;
  int v4 = *a2;
  if (*a2 < 1)
  {
    char v21 = 0;
    __int16 __dst = 0;
    unint64_t v6 = result[2];
    unint64_t v7 = result[3];
    if (v7 <= v6) {
      return result;
    }
    uint64_t v8 = (char *)result[2];
    while (1)
    {
      if (v3[5] <= v3[4])
      {
        int v5 = 15;
        goto LABEL_5;
      }
      uint64_t v9 = v3[1];
      uint64_t v10 = *(char *)(v9 + 64);
      if (*(unsigned char *)(v9 + 64))
      {
        if (3 - v10 >= v7 - (unint64_t)v8) {
          size_t v11 = v7 - (void)v8;
        }
        else {
          size_t v11 = 3 - v10;
        }
        memcpy(&__dst, (const void *)(v9 + 65), *(char *)(v9 + 64));
        int v12 = (char *)&__dst + v10;
        memcpy((char *)&__dst + v10, v8, v11);
        v3[2] = &__dst;
        v3[3] = (char *)&__dst + v10 + v11;
        unsigned __int8 v13 = v10 + v11;
        uint64_t result = (void *)sub_18C862B94(v3, a2);
        uint64_t v14 = v3[1];
        uint64_t v15 = &v8[v3[2] - (void)v12];
        v3[2] = v15;
        v3[3] = v7;
        int v4 = *a2;
        if (*a2 == 11)
        {
          *(unsigned char *)(v14 + 64) = v13;
          uint64_t result = memcpy((void *)(v14 + 65), &__dst, (char)v13);
          int v5 = 0;
          v3[2] = v3[3];
          goto LABEL_5;
        }
        *(unsigned char *)(v14 + 64) = 0;
        p_dst = &__dst;
      }
      else
      {
        uint64_t result = (void *)sub_18C862B94(v3, a2);
        uint64_t v15 = (char *)v3[2];
        unsigned __int8 v13 = (_BYTE)v15 - (_BYTE)v8;
        int v4 = *a2;
        p_dst = (__int16 *)v8;
      }
      if (v4 > 0) {
        break;
      }
      if ((unsigned __int16)result > 0xFFFDu)
      {
        if ((unsigned __int16)result == 65534) {
          int v4 = 10;
        }
        else {
          int v4 = 12;
        }
        *a2 = v4;
        break;
      }
      unsigned int v17 = (_WORD *)v3[4];
      *unsigned int v17 = (_WORD)result;
      v3[4] = v17 + 1;
      uint64_t v18 = (_DWORD *)v3[6];
      if (v18)
      {
        *uint64_t v18 = v8 - v6;
        v3[6] = v18 + 1;
      }
      unint64_t v7 = v3[3];
      uint64_t v8 = v15;
      if (v7 <= (unint64_t)v15) {
        return result;
      }
    }
    uint64_t v19 = v3[1];
    *(unsigned char *)(v19 + 64) = v13;
    if ((char)v13 >= 1)
    {
      uint64_t result = memcpy((void *)(v19 + 65), p_dst, v13);
      int v4 = *a2;
    }
  }
  else
  {
    *(unsigned char *)(result[1] + 64) = 0;
  }
  if (v4 == 11)
  {
    int v5 = 0;
LABEL_5:
    *a2 = v5;
  }
  return result;
}

uint64_t sub_18C862314(uint64_t result, int *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v39 = 0;
  unsigned __int16 v2 = *(unsigned __int16 **)(result + 16);
  if ((unint64_t)v2 < *(void *)(result + 24))
  {
    int v4 = (void *)result;
    int v5 = 0;
    uint64_t v6 = *(void *)(*(void *)(result + 8) + 16);
    unint64_t v7 = (char *)&v36 + 1;
    char v37 = 0;
    __int16 v36 = 0;
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    int v42 = 0;
    while (1)
    {
      if (*a2 > 0) {
        return result;
      }
      if (v4[4] >= v4[5])
      {
        *a2 = 15;
        return result;
      }
      char v8 = *(unsigned char *)(v6 + 161);
      unsigned __int16 v9 = *v2;
      unsigned __int16 v38 = v9;
      if ((v9 & 0xFF80) != 0x80) {
        break;
      }
      uint64_t v10 = &v36;
      BOOL v11 = v9 - 167 > 0x30 || ((1 << (v9 + 89)) & 0x100000000A603) == 0;
      if (v11 && v9 != 247)
      {
        *(unsigned char *)(v6 + 161) = 1;
LABEL_15:
        uint64_t v10 = &v36;
        if (v9 <= 0x19u && ((1 << v9) & 0x2002601) != 0)
        {
          LOBYTE(v36) = v9;
          uint64_t v10 = (__int16 *)v7;
        }
      }
      if (v9 <= 0x19u && ((1 << v9) & 0x2002601) != 0) {
        goto LABEL_20;
      }
      uint64_t v19 = (unsigned __int8 *)&unk_18CA800EE;
      do
      {
        unsigned int v20 = *((unsigned __int16 *)v19 + 2);
        v19 += 6;
      }
      while (v20 < v9);
      if (*((unsigned __int16 *)v19 - 2) > v9) {
        goto LABEL_39;
      }
      unsigned int v21 = *v19;
      if (v21 == 15)
      {
        if (v9 <= 0x1Fu)
        {
          *(unsigned char *)uint64_t v10 = 15;
          LOBYTE(v9) = v9 + 32;
          goto LABEL_51;
        }
        if ((unsigned __int16)(v9 - 128) <= 0x20u)
        {
          *(unsigned char *)uint64_t v10 = 15;
LABEL_51:
          *((unsigned char *)v10++ + 1) = v9;
        }
        uint64_t result = (char *)v10 - (char *)&v36;
        unsigned int v21 = 15;
        goto LABEL_53;
      }
      if (v21 == 20)
      {
LABEL_39:
        unsigned int v21 = 20;
        *(unsigned char *)uint64_t v10 = 20;
        if ((_BYTE)v9) {
          char v22 = HIBYTE(v9);
        }
        else {
          char v22 = -10;
        }
        if (!(_BYTE)v9) {
          LOBYTE(v9) = HIBYTE(v9);
        }
        *((unsigned char *)v10 + 1) = v22;
        *((unsigned char *)v10 + 2) = v9;
        uint64_t v10 = (__int16 *)((char *)v10 + 3);
        uint64_t result = (char *)v10 - (char *)&v36;
      }
      else
      {
        if (v21 > 0x13) {
          goto LABEL_54;
        }
        uint64_t result = sub_18C862E54(v6, *v19, v10, &v38, &v39, (uint64_t)&v40);
      }
LABEL_53:
      if (result) {
        goto LABEL_21;
      }
LABEL_54:
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      int v42 = 0;
      unsigned int v23 = *(unsigned __int8 *)(v6 + 160);
      if (v23 == 1 || (v21 != 128 || v23 >= 0x10) && v21 != 130 && (v21 != 129 || v23 < 0x10)) {
        goto LABEL_55;
      }
      unsigned int v25 = *(unsigned __int8 *)(v6 + 161);
      if (v25 <= 0xF)
      {
        uint64_t result = sub_18C862E54(v6, 1u, v10, &v38, &v39, (uint64_t)&v40);
        if (result) {
          goto LABEL_21;
        }
        uint64_t result = sub_18C862E54(v6, 0, v10, &v38, &v39, (uint64_t)&v40);
        if (result) {
          goto LABEL_21;
        }
        unsigned int v25 = *(unsigned __int8 *)(v6 + 161);
      }
      uint64_t result = sub_18C862E54(v6, v25, v10, &v38, &v39, (uint64_t)&v40);
      if (!result)
      {
LABEL_55:
        unsigned int v24 = *(unsigned __int8 *)(v6 + 161);
        if (*(unsigned char *)(v6 + 161) && (v21 == 128 && v24 < 0x10 || v21 == 130 || v21 == 129 && v24 >= 0x10))
        {
          uint64_t result = sub_18C862E54(v6, v24, v10, &v38, &v39, (uint64_t)&v40);
          if (result)
          {
LABEL_79:
            if (!result) {
              goto LABEL_89;
            }
            goto LABEL_21;
          }
        }
        else
        {
          uint64_t result = 0;
        }
        if (v39)
        {
          if (v21 != 128 || v39 >= 0x10u)
          {
            BOOL v26 = v21 == 129 && v39 > 0xFu;
            BOOL v27 = v26;
            if (v21 != 130 && !v27)
            {
LABEL_89:
              uint64_t v35 = v7;
              if (v21 == 129) {
                unint64_t v28 = 16;
              }
              else {
                unint64_t v28 = 1;
              }
              if ((((_BYTE)v21 + 127) & 0xFE) != 0) {
                unint64_t v29 = 11;
              }
              else {
                unint64_t v29 = 19;
              }
              if (v29 >= v28)
              {
                do
                {
                  uint64_t v30 = *(void *)(v6 + 8 * v28);
                  if (v30)
                  {
                    if (*((unsigned char *)&v40 + v28)) {
                      uint64_t v30 = 0;
                    }
                    else {
                      uint64_t v30 = sub_18C862E54(v6, v28, v10, &v38, &v39, (uint64_t)&v40);
                    }
                  }
                  BOOL v31 = v30 == 0;
                  if (v28 >= v29) {
                    break;
                  }
                  ++v28;
                }
                while (!v30);
              }
              else
              {
                uint64_t v30 = 0;
                BOOL v31 = 1;
              }
              if (v21 == 129)
              {
                unint64_t v7 = v35;
              }
              else
              {
                unint64_t v7 = v35;
                if (v31) {
                  uint64_t v30 = sub_18C862E54(v6, 0, v10, &v38, &v39, (uint64_t)&v40);
                }
              }
              uint64_t result = v30;
              if (!v30)
              {
                char v32 = v38;
                int v33 = HIBYTE(v38);
                *(unsigned char *)uint64_t v10 = 20;
                if (v32) {
                  char v34 = v33;
                }
                else {
                  char v34 = -10;
                }
                if (!v32) {
                  char v32 = v33;
                }
                *((unsigned char *)v10 + 1) = v34;
                *((unsigned char *)v10 + 2) = v32;
                uint64_t result = v10 - &v36 + 3;
              }
              goto LABEL_21;
            }
          }
          uint64_t result = sub_18C862E54(v6, v39, v10, &v38, &v39, (uint64_t)&v40);
        }
        goto LABEL_79;
      }
LABEL_21:
      v4[2] += 2;
      int v12 = (unsigned char *)v4[4];
      if ((unint64_t)v12 >= v4[5])
      {
        unsigned __int8 v13 = (char *)&v36;
LABEL_29:
        if ((int)result >= 1)
        {
          uint64_t v16 = v4[1];
          unsigned int v17 = (unsigned char *)(v16 + 104);
          *a2 = 15;
          *(unsigned char *)(v16 + 91) = result;
          do
          {
            char v18 = *v13++;
            *v17++ = v18;
            uint64_t result = (result - 1);
          }
          while (result);
        }
      }
      else
      {
        unsigned __int8 v13 = (char *)&v36;
        while (result)
        {
          char v14 = *v13++;
          v4[4] = v12 + 1;
          *int v12 = v14;
          uint64_t v15 = (_DWORD *)v4[6];
          if (v15)
          {
            *uint64_t v15 = v5;
            v4[6] = v15 + 1;
          }
          int v12 = (unsigned char *)v4[4];
          uint64_t result = (result - 1);
          if ((unint64_t)v12 >= v4[5]) {
            goto LABEL_29;
          }
        }
      }
      ++v5;
      *(unsigned char *)(v6 + 161) = v8;
      unsigned __int16 v2 = (unsigned __int16 *)v4[2];
      if ((unint64_t)v2 >= v4[3]) {
        return result;
      }
    }
    if ((unsigned __int16)(v9 - 32) <= 0x5Fu)
    {
      LOBYTE(v36) = v9;
LABEL_20:
      uint64_t result = 1;
      goto LABEL_21;
    }
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_18C862910(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
  {
    uint64_t v3 = 0;
    *a3 = 456;
  }
  else
  {
    uint64_t v3 = a2;
    uint64_t v4 = 0;
    int v5 = *(long long **)(a1 + 16);
    long long v6 = *v5;
    long long v7 = v5[2];
    *(_OWORD *)(a2 + 304) = v5[1];
    *(_OWORD *)(a2 + 320) = v7;
    *(_OWORD *)(a2 + 288) = v6;
    long long v8 = v5[3];
    long long v9 = v5[4];
    long long v10 = v5[6];
    *(_OWORD *)(a2 + 368) = v5[5];
    *(_OWORD *)(a2 + 384) = v10;
    *(_OWORD *)(a2 + 336) = v8;
    *(_OWORD *)(a2 + 352) = v9;
    long long v11 = v5[7];
    long long v12 = v5[8];
    long long v13 = v5[9];
    *(void *)(a2 + 448) = *((void *)v5 + 20);
    uint64_t v14 = a2 + 288;
    *(_OWORD *)(a2 + 416) = v12;
    *(_OWORD *)(a2 + 432) = v13;
    *(_OWORD *)(a2 + 400) = v11;
    do
    {
      uint64_t v15 = *(void *)((char *)v5 + v4);
      if (v15) {
        sub_18C85B83C(v15);
      }
      v4 += 8;
    }
    while (v4 != 160);
    *(void *)(v3 + 16) = v14;
    *(unsigned char *)(v3 + 62) = 1;
  }
  return v3;
}

void sub_18C8629C0(uint64_t a1, uint64_t a2, UErrorCode *a3, char a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  long long v8 = uprv_malloc(0xA8uLL);
  *(void *)(a1 + 16) = v8;
  if (v8)
  {
    long long v9 = v8;
    uint64_t v10 = 0;
    memset(v21, 0, sizeof(v21));
    uint64_t v20 = 0;
    memset(v19, 0, sizeof(v19));
    LODWORD(v19[0]) = 40;
    *long long v8 = 0u;
    v8[1] = 0u;
    long long v8[2] = 0u;
    v8[3] = 0u;
    v8[4] = 0u;
    v8[5] = 0u;
    v8[6] = 0u;
    v8[7] = 0u;
    v8[8] = 0u;
    v8[9] = 0u;
    BYTE8(v19[0]) = *(unsigned char *)(a2 + 8);
    *((void *)v8 + 20) = 0;
    do
    {
      if (*(int *)a3 > 0) {
        goto LABEL_9;
      }
      if (((0xF680uLL >> v10) & 1) == 0) {
        *((void *)v9 + v10) = sub_18C85B8A4((unsigned __int8 *)off_1E5501FC0[v10], v21, v19, a3);
      }
      ++v10;
    }
    while (v10 != 20);
    if (*(int *)a3 > 0 || *(unsigned char *)(a2 + 8))
    {
LABEL_9:
      sub_18C8620C4(a1);
      return;
    }
    *((unsigned char *)v9 + 160) = a4;
    long long v11 = *(const char **)(a2 + 32);
    if (v11 && (int v12 = *(unsigned __int8 *)v11, *v11))
    {
      long long v13 = "ar";
      uint64_t v14 = &off_1E5502070;
      do
      {
        int v15 = *(unsigned __int8 *)v13;
        if (v15 == v12)
        {
          size_t v16 = strlen(v13);
          if (!strncmp(v13, v11, v16))
          {
            char v18 = *((unsigned char *)v14 - 8);
            goto LABEL_22;
          }
        }
        else if ((char)v15 > (char)v12)
        {
          break;
        }
        unsigned int v17 = *v14;
        v14 += 2;
        long long v13 = v17;
      }
      while (v17);
      char v18 = 1;
    }
    else
    {
      char v18 = 0;
    }
LABEL_22:
    *((unsigned char *)v9 + 161) = v18;
  }
  else
  {
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
}

uint64_t sub_18C862B94(void *a1, _DWORD *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[2];
  unint64_t v3 = a1[3];
  if ((unint64_t)v4 >= v3)
  {
    *a2 = 1;
    return 0xFFFFLL;
  }
  else
  {
    long long v6 = v4 + 1;
    a1[2] = v4 + 1;
    unsigned __int8 v7 = *v4;
    uint64_t result = *v4;
    if ((char)*v4 <= 31)
    {
      switch(*v4)
      {
        case 9u:
        case 0xAu:
        case 0xDu:
          return result;
        case 0xBu:
        case 0xCu:
        case 0xEu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
          goto LABEL_15;
        case 0xFu:
          if ((unint64_t)(v4 + 2) > v3) {
            goto LABEL_23;
          }
          a1[2] = v4 + 2;
          int v9 = *v6;
          if ((v9 & 0x80u) == 0) {
            return (v9 - 32);
          }
          else {
            return *v6;
          }
        case 0x14u:
          if ((unint64_t)(v4 + 3) > v3) {
            goto LABEL_23;
          }
          a1[2] = v4 + 2;
          int v22 = v4[1];
          a1[2] = v4 + 3;
          int v23 = v4[2];
          if (v22 == 246)
          {
            int v22 = v4[2];
            int v23 = 0;
          }
          return v23 | (v22 << 8);
        default:
          if (*v4) {
            BOOL v10 = result == 25;
          }
          else {
            BOOL v10 = 1;
          }
          if (v10) {
            return result;
          }
LABEL_15:
          if (*v4 <= 0x20u)
          {
            if (*v4 > 0x13u || (v11 = *(uint64_t **)(a1[1] + 16), (uint64_t v12 = v11[*v4]) == 0))
            {
              uint64_t result = 0;
              *a2 = 10;
              return result;
            }
            if (*v4 >= 0x10u)
            {
              if ((unint64_t)(v4 + 3) <= v3)
              {
                if ((char)*v6 != result)
                {
                  uint64_t result = sub_18C86D39C(v12, (uint64_t)v6, 2);
                  uint64_t v21 = a1[2] + 2;
                  goto LABEL_29;
                }
                uint64_t v13 = (uint64_t)(v4 + 2);
                a1[2] = v4 + 2;
                uint64_t v14 = v12;
                int v15 = 1;
LABEL_28:
                uint64_t result = sub_18C86D39C(v14, v13, v15);
                uint64_t v21 = a1[2] + 1;
LABEL_29:
                a1[2] = v21;
                return result;
              }
              goto LABEL_23;
            }
            BOOL v26 = v4 + 2;
            if ((unint64_t)v26 > v3) {
              goto LABEL_23;
            }
            a1[2] = v26;
            int v27 = (char)*v6;
            if ((v27 & 0x80000000) == 0)
            {
              uint64_t v28 = *v11;
              v29[0] = v7;
              v29[1] = v27;
              return sub_18C86D39C(v28, (uint64_t)v29, 2);
            }
            uint64_t v25 = *v6;
            uint64_t v24 = *(void *)(v12 + 56);
            return *(unsigned __int16 *)(v24 + 4 * v25);
          }
          uint64_t v16 = *(void *)(a1[1] + 16);
          unint64_t v17 = *(unsigned __int8 *)(v16 + 160);
          uint64_t v18 = *(void *)(v16 + 8 * v17);
          if (v17 < 0x10)
          {
            uint64_t v24 = *(void *)(v18 + 56);
            uint64_t v25 = v7;
            return *(unsigned __int16 *)(v24 + 4 * v25);
          }
          BOOL v19 = sub_18C86EDAC(*(void *)(v16 + 8 * v17), v7);
          unint64_t v20 = a1[2];
          if (v19)
          {
            unint64_t v3 = a1[3];
            if (v20 + 1 <= v3)
            {
              uint64_t v13 = v20 - 1;
              uint64_t v14 = v18;
              int v15 = 2;
              goto LABEL_28;
            }
LABEL_23:
            *a2 = 11;
            a1[2] = v3;
            return 0xFFFFLL;
          }
          unint64_t v3 = a1[3];
          if (v20 > v3) {
            goto LABEL_23;
          }
          uint64_t result = sub_18C86D39C(v18, v20 - 1, 1);
          break;
      }
    }
  }
  return result;
}

uint64_t sub_18C862E54(uint64_t a1, unsigned int a2, unsigned char *a3, unsigned __int16 *a4, unsigned char *a5, uint64_t a6)
{
  uint64_t v11 = *(void *)(a1 + 8 * a2);
  int v18 = 0;
  char v12 = a2;
  int v13 = sub_18C86EC94(v11, *a4, &v18, 0);
  if (v13 < 1)
  {
    uint64_t result = 0;
    *(unsigned char *)(a6 + a2) = 1;
  }
  else
  {
    int v14 = v18;
    *a5 = v12;
    int v15 = a3;
    if (a2)
    {
      int v15 = a3;
      if (*(unsigned __int8 *)(a1 + 160) != a2)
      {
        *a3 = a2;
        int v15 = a3 + 1;
        if (a2 >= 0x10 && v13 == 1)
        {
          int v15 = a3 + 2;
          a3[1] = a2;
        }
      }
    }
    if (v13 == 1 && (v14 & 0xE0) == 0)
    {
      return 0;
    }
    else
    {
      switch(v13)
      {
        case 1:
          goto LABEL_15;
        case 2:
          goto LABEL_14;
        case 3:
          goto LABEL_13;
        case 4:
          *v15++ = HIBYTE(v14);
LABEL_13:
          *v15++ = BYTE2(v14);
          BYTE1(v14) = BYTE1(v18);
LABEL_14:
          *v15++ = BYTE1(v14);
          LOBYTE(v14) = v18;
LABEL_15:
          *v15++ = v14;
          break;
        default:
          return v15 - a3;
      }
      return v15 - a3;
    }
  }
  return result;
}

void sub_18C862F98(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FA0(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FA8(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FB0(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FB8(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FC0(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FC8(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FD0(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FD8(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FE0(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

void sub_18C862FE8(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
}

uint64_t ucnv_getUnicodeSet(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    uint64_t v5 = result;
    if (result && a2 && a3 < 2)
    {
      if (*(void *)(*(void *)(*(void *)(result + 48) + 32) + 120))
      {
        v8[1] = *((void *)&xmmword_1EDA46418 + 1);
        long long v9 = *(_OWORD *)&off_1EDA46428;
        long long v10 = xmmword_1EDA46438;
        v8[0] = a2;
        uset_clear(a2);
        return (*(uint64_t (**)(uint64_t, void *, uint64_t, int *))(*(void *)(*(void *)(v5 + 48) + 32)
                                                                            + 120))(v5, v8, a3, a4);
      }
      int v7 = 16;
    }
    else
    {
      int v7 = 1;
    }
    *a4 = v7;
  }
  return result;
}

_DWORD *sub_18C8630B4(_DWORD *result, uint64_t a2, _DWORD *a3)
{
  if ((result[14] & 0xE) != 0)
  {
    *a3 = 1;
  }
  else
  {
    int v3 = result[14] & 0xF;
    result[19] = 8 * (v3 == 0);
    if (v3 == 1) {
      result[20] = 1;
    }
  }
  return result;
}

_DWORD *sub_18C8630EC(_DWORD *result, int a2)
{
  int v2 = result[14] & 0xF;
  if (a2 > 1 || (result[19] = 8 * (v2 == 0), a2 != 1))
  {
    if (v2 == 1) {
      result[20] = 1;
    }
  }
  return result;
}

void *sub_18C863128(void *result, int *a2)
{
  uint64_t v2 = result[1];
  if (*(int *)(v2 + 76) <= 7) {
    return sub_18C863A3C(result, a2);
  }
  unint64_t v3 = result[2];
  uint64_t v4 = result[3];
  unsigned int v5 = v4 - v3;
  if (v4 != v3 || *(_DWORD *)(v2 + 72))
  {
    long long v6 = (_WORD *)result[4];
    unint64_t v7 = result[5];
    if ((unint64_t)v6 >= v7)
    {
      *a2 = 15;
      return result;
    }
    unint64_t v8 = (v7 - (unint64_t)v6) >> 1;
    long long v9 = (int *)result[6];
    int v10 = *(_DWORD *)(v2 + 72);
    if (v10)
    {
      LOBYTE(v11) = 1;
      *(unsigned char *)(v2 + 64) = 1;
      char v12 = (char *)(v2 + 64);
      *(unsigned char *)(v2 + 65) = v10;
      *(_DWORD *)(v2 + 72) = 0;
    }
    else
    {
      char v12 = (char *)(v2 + 64);
      unsigned int v11 = *(unsigned __int8 *)(v2 + 64);
      if (!*(unsigned char *)(v2 + 64))
      {
        char v19 = 0;
        int v15 = 0;
        goto LABEL_33;
      }
    }
    uint64_t v13 = 0;
    int v14 = (char)v11;
    int v15 = 4 - (char)v11;
    unsigned int v16 = v4 + (char)v11 - v3 - 4;
    unsigned int v17 = ~v3 + v4;
    while (1)
    {
      uint64_t v18 = v13;
      *(unsigned char *)(v2 + 65 + (v14 + v13)) = *(unsigned char *)(v3 + v13);
      if (v14 + v13 == 1)
      {
        unsigned int v11 = __rev16(*(unsigned __int16 *)(v2 + 65));
        if ((v11 & 0xF800) != 0xD800)
        {
          *v6++ = v11;
          int v15 = v13 + 1;
          if (v9) {
            *v9++ = -1;
          }
          char v19 = 0;
          unsigned int v11 = 0;
          LODWORD(v8) = v8 - 1;
          goto LABEL_32;
        }
        if ((v11 & 0x400) != 0)
        {
          int v15 = v13 + 1;
          char v19 = 2;
          goto LABEL_32;
        }
      }
      else if (v14 + v13 == 3)
      {
        if ((*(unsigned char *)(v2 + 67) & 0xFC) != 0xDC)
        {
          *a2 = 12;
          if ((uint64_t)(~v3 + result[2] - v13) < 2)
          {
            uint64_t v23 = v3 + v13;
            *(_DWORD *)(v2 + 72) = *(unsigned __int8 *)(v2 + 67) | 0x100;
          }
          else
          {
            uint64_t v23 = v3 + v13 - 1;
          }
          *char v12 = 2;
          result[2] = v23;
          goto LABEL_78;
        }
        unsigned __int16 v20 = _byteswap_ushort(*(_WORD *)(v2 + 67));
        *long long v6 = bswap32(*(unsigned __int16 *)(v2 + 65)) >> 16;
        uint64_t v21 = v6 + 1;
        BOOL v22 = v8 >= 2;
        LODWORD(v8) = v8 - 2;
        if (v22)
        {
          uint64_t v21 = v6 + 2;
          v6[1] = v20;
          if (v9)
          {
            *(void *)long long v9 = -1;
            v9 += 2;
          }
          char v19 = 0;
          unsigned int v11 = 0;
        }
        else
        {
          LODWORD(v8) = 0;
          char v19 = 0;
          unsigned int v11 = 0;
          *(_WORD *)(v2 + 144) = v20;
          *(unsigned char *)(v2 + 93) = 1;
          *a2 = 15;
        }
        unsigned int v17 = v16;
        long long v6 = v21;
LABEL_32:
        *char v12 = v19;
        v3 += v18 + 1;
        unsigned int v5 = v17;
LABEL_33:
        unsigned int v24 = v5 & 0xFFFFFFFE;
        if (2 * (int)v8 <= v5) {
          unsigned int v24 = 2 * v8;
        }
        if (v11 || !v24) {
          goto LABEL_61;
        }
        v5 -= v24;
        unsigned int v25 = v24 >> 1;
        LODWORD(v8) = v8 - (v24 >> 1);
        if (v9)
        {
          while (1)
          {
            BOOL v26 = (unsigned __int8 *)(v3 + 2);
            unsigned int v11 = __rev16(*(unsigned __int16 *)v3);
            if ((v11 & 0xF800) == 0xD800)
            {
              if ((v11 & 0x400) != 0 || v25 < 2) {
                goto LABEL_57;
              }
              __int16 v27 = *v26;
              if ((v27 & 0xFC) != 0xDC) {
                goto LABEL_60;
              }
              __int16 v28 = *(unsigned __int8 *)(v3 + 3) | (unsigned __int16)(v27 << 8);
              v3 += 4;
              --v25;
              *long long v6 = v11;
              v6[1] = v28;
              v6 += 2;
              *long long v9 = v15;
              unint64_t v29 = v9 + 1;
              int v30 = 4;
              uint64_t v31 = 2;
            }
            else
            {
              *v6++ = v11;
              int v30 = 2;
              uint64_t v31 = 1;
              unint64_t v29 = v9;
              v3 += 2;
            }
            v9 += v31;
            int *v29 = v15;
            v15 += v30;
            if (!--v25) {
              goto LABEL_72;
            }
          }
        }
        while (1)
        {
          BOOL v26 = (unsigned __int8 *)(v3 + 2);
          unsigned int v11 = __rev16(*(unsigned __int16 *)v3);
          if ((v11 & 0xF800) == 0xD800)
          {
            if ((v11 & 0x400) != 0 || v25 < 2)
            {
              long long v9 = 0;
LABEL_57:
              if (!v25)
              {
                unint64_t v3 = (unint64_t)v26;
                goto LABEL_72;
              }
LABEL_60:
              unsigned int v5 = v5 + 2 * v25 - 2;
              LODWORD(v8) = v25 + v8;
              unint64_t v3 = (unint64_t)v26;
LABEL_61:
              if (!v11) {
                goto LABEL_72;
              }
              *(unsigned char *)(v2 + 65) = BYTE1(v11);
              *(unsigned char *)(v2 + 66) = v11;
              char v19 = 2;
              *(unsigned char *)(v2 + 64) = 2;
              if ((v11 & 0x400) == 0)
              {
                unsigned int v34 = v5 - 2;
                if (v5 < 2)
                {
                  char v19 = 2;
                  goto LABEL_72;
                }
                if ((*(unsigned char *)v3 & 0xFC) == 0xDC)
                {
                  unsigned __int16 v35 = _byteswap_ushort(*(_WORD *)v3);
                  v3 += 2;
                  *v6++ = v11;
                  if (v9) {
                    *v9++ = v15;
                  }
                  char v19 = 0;
                  *(_WORD *)(v2 + 144) = v35;
                  *(unsigned char *)(v2 + 93) = 1;
                  *(unsigned char *)(v2 + 64) = 0;
                  int v36 = 15;
                  unsigned int v5 = v34;
LABEL_71:
                  *a2 = v36;
LABEL_72:
                  if (v5 && *a2 <= 0)
                  {
                    if (v8)
                    {
                      char v37 = *(unsigned char *)v3++;
                      *(unsigned char *)(v2 + 64) = v19 + 1;
                      *(unsigned char *)(v2 + v19 + 65) = v37;
                    }
                    else
                    {
                      *a2 = 15;
                    }
                  }
                  result[2] = v3;
LABEL_78:
                  result[4] = v6;
                  result[6] = v9;
                  return result;
                }
                unsigned int v5 = 1;
                char v19 = 2;
              }
              int v36 = 12;
              goto LABEL_71;
            }
            __int16 v32 = *v26;
            if ((v32 & 0xFC) != 0xDC)
            {
              long long v9 = 0;
              goto LABEL_60;
            }
            __int16 v33 = *(unsigned __int8 *)(v3 + 3) | (unsigned __int16)(v32 << 8);
            v3 += 4;
            --v25;
            *long long v6 = v11;
            v6[1] = v33;
            v6 += 2;
          }
          else
          {
            *v6++ = v11;
            v3 += 2;
          }
          if (!--v25)
          {
            long long v9 = 0;
            goto LABEL_72;
          }
        }
      }
      ++v13;
      --v17;
      if (v5 == v18 + 1)
      {
        unsigned int v17 = 0;
        unsigned int v11 = 0;
        char v19 = v14 + v13;
        int v15 = v5;
        goto LABEL_32;
      }
    }
  }
  return result;
}

void *sub_18C863558(void *result, int *a2)
{
  uint64_t v2 = (unsigned __int16 *)result[2];
  uint64_t v3 = (result[3] - (void)v2) >> 1;
  if (!v3) {
    return result;
  }
  unsigned int v5 = result;
  uint64_t v6 = result[1];
  if (*(_DWORD *)(v6 + 80) == 1)
  {
    uint64_t result = (void *)sub_18C85D210(result[1], byte_18CA805B8, 2, result + 4, result[5], result + 6, -1, a2);
    *(_DWORD *)(v6 + 80) = 0;
  }
  unint64_t v7 = (unsigned char *)v5[4];
  unint64_t v8 = v5[5];
  __int16 v33 = v7;
  if ((unint64_t)v7 >= v8)
  {
    *a2 = 15;
    return result;
  }
  int v31 = 0;
  unsigned int v9 = v8 - v7;
  int v10 = (int32x4_t *)v5[6];
  __int16 v32 = v10;
  int v11 = *(_DWORD *)(v6 + 84);
  int v12 = (unsigned __int16)v11;
  if ((_WORD)v11 && ((unsigned __int16 v13 = *v2, v9 >= 4) ? (v14 = (*v2 & 0xFC00) == 56320) : (v14 = 0), v14))
  {
    ++v2;
    LODWORD(v3) = v3 - 1;
    *unint64_t v7 = BYTE1(v11);
    v7[1] = v11;
    _DWORD v7[2] = HIBYTE(v13);
    v7[3] = v13;
    v7 += 4;
    __int16 v33 = v7;
    if (v10)
    {
      v18.i64[0] = -1;
      v18.i64[1] = -1;
      *v10++ = v18;
      __int16 v32 = v10;
    }
    *(_DWORD *)(v6 + 84) = 0;
    unsigned int v15 = 1;
    v9 -= 4;
  }
  else
  {
    unsigned int v15 = 0;
    if ((unsigned __int16)*(_DWORD *)(v6 + 84))
    {
LABEL_11:
      if ((v12 & 0x400) != 0) {
        goto LABEL_16;
      }
      if ((unint64_t)v2 >= v5[3])
      {
        int v17 = 0;
        goto LABEL_49;
      }
      unsigned __int16 v16 = *v2;
      if ((*v2 & 0xFC00) != 0xDC00)
      {
LABEL_16:
        int v17 = 0;
        *a2 = 12;
      }
      else
      {
        ++v2;
        LOBYTE(v31) = BYTE1(v12);
        BYTE1(v31) = v12;
        BYTE2(v31) = HIBYTE(v16);
        HIBYTE(v31) = v16;
        int v17 = 4;
        int v12 = 0;
      }
LABEL_49:
      *(_DWORD *)(v6 + 84) = v12;
      uint64_t v21 = v2;
      goto LABEL_50;
    }
  }
  unsigned int v19 = 2 * v3;
  if (2 * (int)v3 > v9) {
    unsigned int v19 = v9 & 0xFFFFFFFE;
  }
  v9 -= v19;
  unsigned int v20 = v19 >> 1;
  int v17 = v3 - (v19 >> 1);
  if (v10)
  {
    if (v19)
    {
      uint64_t v21 = v2;
      while (1)
      {
        int v22 = *v21++;
        int v12 = v22;
        if ((v22 & 0xF800) == 0xD800)
        {
          if (v20 < 2) {
            goto LABEL_46;
          }
          if ((v12 & 0x400) != 0) {
            goto LABEL_46;
          }
          unsigned __int16 v23 = *v21;
          if ((*v21 & 0xFC00) != 0xDC00) {
            goto LABEL_46;
          }
          uint64_t v21 = v2 + 2;
          --v20;
          *unint64_t v7 = BYTE1(v12);
          unsigned int v24 = v33;
          v33[1] = v12;
          v24[2] = HIBYTE(v23);
          v24[3] = v23;
          unint64_t v7 = v24 + 4;
          unsigned int v25 = v32;
          *__int16 v32 = vdupq_n_s32(v15);
          __int16 v32 = v25 + 1;
          __int16 v33 = v7;
          v15 += 2;
        }
        else
        {
          *unint64_t v7 = BYTE1(v12);
          BOOL v26 = v33;
          v33[1] = v12;
          unint64_t v7 = v26 + 2;
          __int16 v33 = v7;
          __int16 v27 = v32;
          v32->i32[0] = v15;
          __int16 v32 = (int32x4_t *)&v27->u64[1];
          v27->i32[1] = v15++;
        }
        uint64_t v2 = v21;
        if (!--v20) {
          goto LABEL_42;
        }
      }
    }
    goto LABEL_41;
  }
  if (!v19)
  {
LABEL_41:
    uint64_t v21 = v2;
LABEL_42:
    if (!v17 || !v9) {
      goto LABEL_52;
    }
    int v12 = *v21;
    uint64_t v2 = v21 + 1;
    if ((v12 & 0xF800) != 0xD800)
    {
      LOBYTE(v31) = BYTE1(v12);
      BYTE1(v31) = v12;
      int v17 = 2;
      ++v21;
      goto LABEL_51;
    }
    goto LABEL_11;
  }
  while (1)
  {
    uint64_t v21 = v2 + 1;
    int v12 = *v2;
    if ((v12 & 0xF800) != 0xD800)
    {
      *unint64_t v7 = BYTE1(v12);
      int v30 = v33;
      v33[1] = v12;
      unint64_t v7 = v30 + 2;
      ++v2;
      goto LABEL_40;
    }
    if (v20 < 2) {
      break;
    }
    if ((v12 & 0x400) != 0) {
      break;
    }
    unsigned __int16 v28 = *v21;
    if ((*v21 & 0xFC00) != 0xDC00) {
      break;
    }
    v2 += 2;
    --v20;
    *unint64_t v7 = BYTE1(v12);
    unint64_t v29 = v33;
    v33[1] = v12;
    unsigned char v29[2] = HIBYTE(v28);
    _OWORD v29[3] = v28;
    unint64_t v7 = v29 + 4;
LABEL_40:
    __int16 v33 = v7;
    if (!--v20) {
      goto LABEL_41;
    }
  }
LABEL_46:
  v9 += 2 * v20;
  uint64_t v2 = v21;
  if (v12) {
    goto LABEL_11;
  }
LABEL_50:
  if (v17)
  {
LABEL_51:
    uint64_t result = (void *)sub_18C85D210(v6, (char *)&v31, v17, &v33, v5[5], &v32, v15, a2);
    unint64_t v7 = v33;
    unsigned int v9 = *((_DWORD *)v5 + 10) - v33;
  }
LABEL_52:
  if (*a2 <= 0 && (unint64_t)v21 < v5[3] && !v9) {
    *a2 = 15;
  }
  v5[2] = v21;
  v5[4] = v7;
  v5[6] = v32;
  return result;
}

uint64_t sub_18C8638F8(void *a1, int *a2)
{
  uint64_t v2 = a1[1];
  if (*(int *)(v2 + 76) >= 8)
  {
    uint64_t v4 = (char *)a1[2];
    unint64_t v5 = a1[3];
    if ((unint64_t)v4 >= v5)
    {
      int v7 = 8;
      goto LABEL_7;
    }
    uint64_t v6 = (unsigned __int8 *)(v4 + 2);
    if ((unint64_t)(v4 + 2) > v5)
    {
      *(unsigned char *)(v2 + 65) = *v4;
      *(unsigned char *)(a1[1] + 64) = 1;
      a1[2] = v4 + 1;
      int v7 = 11;
LABEL_7:
      *a2 = v7;
      return 0xFFFFLL;
    }
    int v8 = *v4;
    uint64_t v3 = v4[1] | (v8 << 8);
    if ((v8 & 0xF8) != 0xD8) {
      goto LABEL_19;
    }
    if ((v8 & 4) == 0)
    {
      unsigned int v9 = (unsigned __int8 *)(v4 + 4);
      if ((unint64_t)(v4 + 4) > v5)
      {
        int v10 = (unsigned char *)(v2 + 65);
        unint64_t v11 = v5 - (void)v4;
        *(unsigned char *)(v2 + 64) = v5 - (_BYTE)v4;
        uint64_t v6 = (unsigned __int8 *)v5;
        do
        {
          char v12 = *v4++;
          *v10++ = v12;
          --v11;
        }
        while (v11);
        int v13 = 11;
        goto LABEL_18;
      }
      int v14 = *v6;
      if ((v14 & 0xFC) == 0xDC)
      {
        unsigned int v15 = (v4[3] | (v14 << 8)) + (v3 << 10);
        if (v15 > 0x35FDBFF)
        {
          uint64_t v3 = v15 - 56613888;
          goto LABEL_20;
        }
        uint64_t v6 = (unsigned __int8 *)(v4 + 4);
      }
    }
    *(unsigned char *)(v2 + 64) = 2;
    *(unsigned char *)(v2 + 65) = *(v6 - 2);
    *(unsigned char *)(v2 + 66) = *(v6 - 1);
    int v13 = 12;
LABEL_18:
    *a2 = v13;
    uint64_t v3 = 0xFFFFLL;
LABEL_19:
    unsigned int v9 = v6;
LABEL_20:
    a1[2] = v9;
    return v3;
  }
  return 4294967287;
}

const char *sub_18C863A1C(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 56) & 0xF) != 0) {
    return "UTF-16BE,version=1";
  }
  else {
    return "UTF-16BE";
  }
}

void *sub_18C863A3C(void *result, int *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = result[1];
  uint64_t v4 = (unsigned __int8 *)result[2];
  uint64_t v6 = (unsigned __int8 *)result[3];
  int v7 = *(_DWORD *)(v5 + 76);
  if (v4 >= v6)
  {
LABEL_33:
    v3[2] = v4;
    if (v4 == v6 && *((unsigned char *)v3 + 2))
    {
      if (v7 == 9)
      {
        uint64_t result = sub_18C863CC4(v3, a2);
      }
      else if (v7 == 8)
      {
        uint64_t result = (void *)sub_18C863128(v3, a2);
      }
    }
    *(_DWORD *)(v5 + 76) = v7;
    return result;
  }
  int v8 = 0;
  unsigned int v9 = (_DWORD *)result[6];
  while (2)
  {
    if (*a2 > 0)
    {
LABEL_28:
      if (v9 && v8)
      {
        unint64_t v15 = v3[6];
        while ((unint64_t)v9 < v15)
          *v9++ += v8;
      }
      goto LABEL_33;
    }
    switch(v7)
    {
      case 0:
        char v10 = *v4++;
        *(unsigned char *)(v5 + 65) = v10;
        int v7 = 1;
        *(unsigned char *)(v5 + 64) = 1;
        goto LABEL_8;
      case 1:
        int v11 = *v4;
        int v12 = *(unsigned __int8 *)(v5 + 65);
        if (v12 == 254 && v11 == 255)
        {
          if (*(_UNKNOWN **)(v5 + 48) == &unk_1E5502318)
          {
            int v16 = 9;
            LOBYTE(v11) = -1;
            goto LABEL_43;
          }
          int v7 = 8;
LABEL_18:
          ++v4;
          *(unsigned char *)(v5 + 64) = 0;
          int v8 = v4 - *((_DWORD *)v3 + 4);
          goto LABEL_27;
        }
        int v13 = *(void **)(v5 + 48);
        if (v12 == 255 && v11 == 254)
        {
          if (v13 == &unk_1E55021F0)
          {
            int v16 = 8;
            LOBYTE(v11) = -2;
            goto LABEL_43;
          }
          int v7 = 9;
          goto LABEL_18;
        }
        if (v13 != &unk_1E5502440 && v13 != &unk_1E5502568 || (*(_DWORD *)(v5 + 56) & 0xF) != 1)
        {
          int v14 = (unsigned __int8 *)v3[2];
          if (v4 != v14)
          {
            *(unsigned char *)(v5 + 64) = 0;
            uint64_t v4 = v14;
          }
          if (v13 == &unk_1E5502318) {
            int v7 = 9;
          }
          else {
            int v7 = 8;
          }
LABEL_27:
          *(_DWORD *)(v5 + 76) = v7;
LABEL_8:
          if (v4 >= v6) {
            goto LABEL_28;
          }
          continue;
        }
        int v16 = 8;
LABEL_43:
        *(unsigned char *)(v5 + 66) = v11;
        *(unsigned char *)(v5 + 64) = 2;
        v3[2] = v4 + 1;
        *(_DWORD *)(v5 + 76) = v16;
        *a2 = 18;
        return result;
      case 8:
        v3[2] = v4;
        uint64_t result = (void *)sub_18C863128(v3, a2);
        uint64_t v4 = (unsigned __int8 *)v3[2];
        int v7 = 8;
        goto LABEL_8;
      case 9:
        v3[2] = v4;
        uint64_t result = sub_18C863CC4(v3, a2);
        uint64_t v4 = (unsigned __int8 *)v3[2];
        int v7 = 9;
        goto LABEL_8;
      default:
        goto LABEL_8;
    }
  }
}

void *sub_18C863CC4(void *result, int *a2)
{
  uint64_t v2 = result[1];
  if (*(int *)(v2 + 76) <= 7) {
    return (void *)sub_18C863A3C();
  }
  unint64_t v3 = result[2];
  uint64_t v4 = result[3];
  unsigned int v5 = v4 - v3;
  if (v4 != v3 || *(_DWORD *)(v2 + 72))
  {
    uint64_t v6 = (_WORD *)result[4];
    unint64_t v7 = result[5];
    if ((unint64_t)v6 >= v7)
    {
      *a2 = 15;
      return result;
    }
    unint64_t v8 = (v7 - (unint64_t)v6) >> 1;
    unsigned int v9 = (int *)result[6];
    int v10 = *(_DWORD *)(v2 + 72);
    if (v10)
    {
      LOBYTE(v11) = 1;
      *(unsigned char *)(v2 + 64) = 1;
      int v12 = (char *)(v2 + 64);
      *(unsigned char *)(v2 + 65) = v10;
      *(_DWORD *)(v2 + 72) = 0;
    }
    else
    {
      int v12 = (char *)(v2 + 64);
      int v11 = *(unsigned __int8 *)(v2 + 64);
      if (!*(unsigned char *)(v2 + 64))
      {
        char v19 = 0;
        int v15 = 0;
        goto LABEL_33;
      }
    }
    uint64_t v13 = 0;
    int v14 = (char)v11;
    int v15 = 4 - (char)v11;
    unsigned int v16 = v4 + (char)v11 - v3 - 4;
    unsigned int v17 = ~v3 + v4;
    while (1)
    {
      uint64_t v18 = v13;
      *(unsigned char *)(v2 + 65 + (v14 + v13)) = *(unsigned char *)(v3 + v13);
      if (v14 + v13 == 1)
      {
        int v11 = *(unsigned __int16 *)(v2 + 65);
        if ((v11 & 0xF800) != 0xD800)
        {
          *v6++ = v11;
          int v15 = v13 + 1;
          if (v9) {
            *v9++ = -1;
          }
          char v19 = 0;
          int v11 = 0;
          LODWORD(v8) = v8 - 1;
          goto LABEL_32;
        }
        if ((v11 & 0x400) != 0)
        {
          int v15 = v13 + 1;
          char v19 = 2;
          goto LABEL_32;
        }
      }
      else if (v14 + v13 == 3)
      {
        __int16 v20 = *(unsigned __int8 *)(v2 + 68);
        if ((v20 & 0xFC) != 0xDC)
        {
          *a2 = 12;
          if ((uint64_t)(~v3 + result[2] - v13) < 2)
          {
            uint64_t v24 = v3 + v13;
            *(_DWORD *)(v2 + 72) = *(unsigned __int8 *)(v2 + 67) | 0x100;
          }
          else
          {
            uint64_t v24 = v3 + v13 - 1;
          }
          *int v12 = 2;
          result[2] = v24;
          goto LABEL_78;
        }
        __int16 v21 = *(unsigned __int8 *)(v2 + 67) | (unsigned __int16)(v20 << 8);
        *uint64_t v6 = *(_WORD *)(v2 + 65);
        int v22 = v6 + 1;
        BOOL v23 = v8 >= 2;
        LODWORD(v8) = v8 - 2;
        if (v23)
        {
          int v22 = v6 + 2;
          v6[1] = v21;
          if (v9)
          {
            *(void *)unsigned int v9 = -1;
            v9 += 2;
          }
          char v19 = 0;
          int v11 = 0;
        }
        else
        {
          LODWORD(v8) = 0;
          char v19 = 0;
          int v11 = 0;
          *(_WORD *)(v2 + 144) = v21;
          *(unsigned char *)(v2 + 93) = 1;
          *a2 = 15;
        }
        unsigned int v17 = v16;
        uint64_t v6 = v22;
LABEL_32:
        *int v12 = v19;
        v3 += v18 + 1;
        unsigned int v5 = v17;
LABEL_33:
        unsigned int v25 = v5 & 0xFFFFFFFE;
        if (2 * (int)v8 <= v5) {
          unsigned int v25 = 2 * v8;
        }
        if (v11 || !v25) {
          goto LABEL_61;
        }
        v5 -= v25;
        unsigned int v26 = v25 >> 1;
        LODWORD(v8) = v8 - (v25 >> 1);
        if (v9)
        {
          while (1)
          {
            __int16 v27 = (unsigned __int8 *)(v3 + 2);
            int v11 = *(unsigned __int16 *)v3;
            if ((v11 & 0xF800) == 0xD800)
            {
              if ((v11 & 0x400) != 0 || v26 < 2) {
                goto LABEL_57;
              }
              __int16 v28 = *(unsigned __int8 *)(v3 + 3);
              if ((v28 & 0xFC) != 0xDC) {
                goto LABEL_60;
              }
              __int16 v29 = *(unsigned __int8 *)(v3 + 2) | (unsigned __int16)(v28 << 8);
              v3 += 4;
              --v26;
              *uint64_t v6 = v11;
              v6[1] = v29;
              v6 += 2;
              *unsigned int v9 = v15;
              int v30 = v9 + 1;
              int v31 = 4;
              uint64_t v32 = 2;
            }
            else
            {
              *v6++ = v11;
              int v31 = 2;
              uint64_t v32 = 1;
              int v30 = v9;
              v3 += 2;
            }
            v9 += v32;
            int *v30 = v15;
            v15 += v31;
            if (!--v26) {
              goto LABEL_72;
            }
          }
        }
        while (1)
        {
          __int16 v27 = (unsigned __int8 *)(v3 + 2);
          int v11 = *(unsigned __int16 *)v3;
          if ((v11 & 0xF800) == 0xD800)
          {
            if ((v11 & 0x400) != 0 || v26 < 2)
            {
              unsigned int v9 = 0;
LABEL_57:
              if (!v26)
              {
                unint64_t v3 = (unint64_t)v27;
                goto LABEL_72;
              }
LABEL_60:
              unsigned int v5 = v5 + 2 * v26 - 2;
              LODWORD(v8) = v26 + v8;
              unint64_t v3 = (unint64_t)v27;
LABEL_61:
              if (!v11) {
                goto LABEL_72;
              }
              *(_WORD *)(v2 + 65) = v11;
              char v19 = 2;
              *(unsigned char *)(v2 + 64) = 2;
              if ((v11 & 0x400) == 0)
              {
                unsigned int v35 = v5 - 2;
                if (v5 < 2)
                {
                  char v19 = 2;
                  goto LABEL_72;
                }
                __int16 v36 = *(unsigned __int8 *)(v3 + 1);
                if ((v36 & 0xFC) == 0xDC)
                {
                  __int16 v37 = *(unsigned __int8 *)v3;
                  v3 += 2;
                  __int16 v38 = v37 | (v36 << 8);
                  *v6++ = v11;
                  if (v9) {
                    *v9++ = v15;
                  }
                  char v19 = 0;
                  *(_WORD *)(v2 + 144) = v38;
                  *(unsigned char *)(v2 + 93) = 1;
                  *(unsigned char *)(v2 + 64) = 0;
                  int v39 = 15;
                  unsigned int v5 = v35;
LABEL_71:
                  *a2 = v39;
LABEL_72:
                  if (v5 && *a2 <= 0)
                  {
                    if (v8)
                    {
                      char v40 = *(unsigned char *)v3++;
                      *(unsigned char *)(v2 + 64) = v19 + 1;
                      *(unsigned char *)(v2 + v19 + 65) = v40;
                    }
                    else
                    {
                      *a2 = 15;
                    }
                  }
                  result[2] = v3;
LABEL_78:
                  result[4] = v6;
                  result[6] = v9;
                  return result;
                }
                unsigned int v5 = 1;
                char v19 = 2;
              }
              int v39 = 12;
              goto LABEL_71;
            }
            __int16 v33 = *(unsigned __int8 *)(v3 + 3);
            if ((v33 & 0xFC) != 0xDC)
            {
              unsigned int v9 = 0;
              goto LABEL_60;
            }
            __int16 v34 = *(unsigned __int8 *)(v3 + 2) | (unsigned __int16)(v33 << 8);
            v3 += 4;
            --v26;
            *uint64_t v6 = v11;
            v6[1] = v34;
            v6 += 2;
          }
          else
          {
            *v6++ = v11;
            v3 += 2;
          }
          if (!--v26)
          {
            unsigned int v9 = 0;
            goto LABEL_72;
          }
        }
      }
      ++v13;
      --v17;
      if (v5 == v18 + 1)
      {
        unsigned int v17 = 0;
        int v11 = 0;
        char v19 = v14 + v13;
        int v15 = v5;
        goto LABEL_32;
      }
    }
  }
  return result;
}

_DWORD *sub_18C8640DC(_DWORD *result, uint64_t a2, _DWORD *a3)
{
  if ((result[14] & 0xE) != 0)
  {
    *a3 = 1;
  }
  else
  {
    int v3 = result[14] & 0xF;
    result[19] = 8 * (v3 == 0);
    if (v3 == 1) {
      result[20] = 1;
    }
  }
  return result;
}

_DWORD *sub_18C864114(_DWORD *result, int a2)
{
  int v2 = result[14] & 0xF;
  if (a2 > 1 || (result[19] = 8 * (v2 == 0), a2 != 1))
  {
    if (v2 == 1) {
      result[20] = 1;
    }
  }
  return result;
}

void *sub_18C864150(void *result, int *a2)
{
  int v2 = (unsigned __int16 *)result[2];
  uint64_t v3 = (result[3] - (void)v2) >> 1;
  if (!v3) {
    return result;
  }
  unsigned int v5 = result;
  uint64_t v6 = result[1];
  if (*(_DWORD *)(v6 + 80) == 1)
  {
    uint64_t result = (void *)sub_18C85D210(result[1], byte_18CA805BA, 2, result + 4, result[5], result + 6, -1, a2);
    *(_DWORD *)(v6 + 80) = 0;
  }
  unint64_t v7 = (_WORD *)v5[4];
  unint64_t v8 = v5[5];
  __int16 v37 = v7;
  if ((unint64_t)v7 >= v8)
  {
    *a2 = 15;
    return result;
  }
  int v35 = 0;
  unsigned int v9 = v8 - v7;
  int v10 = (int32x4_t *)v5[6];
  __int16 v36 = v10;
  int v11 = *(_DWORD *)(v6 + 84);
  unsigned int v12 = (unsigned __int16)v11;
  if ((_WORD)v11 && ((unsigned __int16 v13 = *v2, v9 >= 4) ? (v14 = (*v2 & 0xFC00) == 56320) : (v14 = 0), v14))
  {
    ++v2;
    LODWORD(v3) = v3 - 1;
    *unint64_t v7 = v11;
    v7[1] = v13;
    v7 += 2;
    __int16 v37 = v7;
    if (v10)
    {
      v18.i64[0] = -1;
      v18.i64[1] = -1;
      *v10++ = v18;
      __int16 v36 = v10;
    }
    *(_DWORD *)(v6 + 84) = 0;
    unsigned int v15 = 1;
    v9 -= 4;
  }
  else
  {
    unsigned int v15 = 0;
    if ((unsigned __int16)*(_DWORD *)(v6 + 84))
    {
LABEL_11:
      if ((v12 & 0x400) != 0) {
        goto LABEL_16;
      }
      if ((unint64_t)v2 >= v5[3])
      {
        int v17 = 0;
        goto LABEL_49;
      }
      unsigned __int16 v16 = *v2;
      if ((*v2 & 0xFC00) != 0xDC00)
      {
LABEL_16:
        int v17 = 0;
        *a2 = 12;
      }
      else
      {
        ++v2;
        LOWORD(v35) = v12;
        HIWORD(v35) = v16;
        int v17 = 4;
        unsigned int v12 = 0;
      }
LABEL_49:
      *(_DWORD *)(v6 + 84) = v12;
      __int16 v21 = v2;
      goto LABEL_50;
    }
  }
  unsigned int v19 = v9 & 0xFFFFFFFE;
  if (2 * (int)v3 <= v9) {
    unsigned int v19 = 2 * v3;
  }
  v9 -= v19;
  unsigned int v20 = v19 >> 1;
  int v17 = v3 - (v19 >> 1);
  if (v10)
  {
    if (v19)
    {
      __int16 v21 = v2;
      while (1)
      {
        unsigned int v22 = *v21++;
        unsigned int v12 = v22;
        if ((v22 & 0xF800) == 0xD800)
        {
          if (v20 < 2) {
            goto LABEL_46;
          }
          if ((v12 & 0x400) != 0) {
            goto LABEL_46;
          }
          unsigned __int16 v23 = *v21;
          if ((*v21 & 0xFC00) != 0xDC00) {
            goto LABEL_46;
          }
          __int16 v21 = v2 + 2;
          --v20;
          *(unsigned char *)unint64_t v7 = v12;
          unsigned int v24 = v12 >> 8;
          unsigned int v25 = v37;
          *((unsigned char *)v37 + 1) = v24;
          v25[1] = v23;
          unint64_t v7 = v25 + 2;
          unsigned int v26 = v36;
          *__int16 v36 = vdupq_n_s32(v15);
          __int16 v36 = v26 + 1;
          __int16 v37 = v7;
          v15 += 2;
        }
        else
        {
          *(unsigned char *)unint64_t v7 = v12;
          unsigned int v27 = v12 >> 8;
          __int16 v28 = v37;
          *((unsigned char *)v37 + 1) = v27;
          unint64_t v7 = v28 + 1;
          __int16 v37 = v28 + 1;
          __int16 v29 = v36;
          v36->i32[0] = v15;
          __int16 v36 = (int32x4_t *)&v29->u64[1];
          v29->i32[1] = v15++;
        }
        int v2 = v21;
        if (!--v20) {
          goto LABEL_42;
        }
      }
    }
    goto LABEL_41;
  }
  if (!v19)
  {
LABEL_41:
    __int16 v21 = v2;
LABEL_42:
    if (!v17 || !v9) {
      goto LABEL_52;
    }
    unsigned int v12 = *v21;
    int v2 = v21 + 1;
    if ((v12 & 0xF800) != 0xD800)
    {
      LOWORD(v35) = v12;
      int v17 = 2;
      ++v21;
      goto LABEL_51;
    }
    goto LABEL_11;
  }
  while (1)
  {
    __int16 v21 = v2 + 1;
    unsigned int v12 = *v2;
    if ((v12 & 0xF800) != 0xD800)
    {
      *(unsigned char *)unint64_t v7 = v12;
      unsigned int v33 = v12 >> 8;
      __int16 v34 = v37;
      *((unsigned char *)v37 + 1) = v33;
      unint64_t v7 = v34 + 1;
      ++v2;
      goto LABEL_40;
    }
    if (v20 < 2) {
      break;
    }
    if ((v12 & 0x400) != 0) {
      break;
    }
    unsigned __int16 v30 = *v21;
    if ((*v21 & 0xFC00) != 0xDC00) {
      break;
    }
    v2 += 2;
    --v20;
    *(unsigned char *)unint64_t v7 = v12;
    unsigned int v31 = v12 >> 8;
    uint64_t v32 = v37;
    *((unsigned char *)v37 + 1) = v31;
    v32[1] = v30;
    unint64_t v7 = v32 + 2;
LABEL_40:
    __int16 v37 = v7;
    if (!--v20) {
      goto LABEL_41;
    }
  }
LABEL_46:
  v9 += 2 * v20;
  int v2 = v21;
  if (v12) {
    goto LABEL_11;
  }
LABEL_50:
  if (v17)
  {
LABEL_51:
    uint64_t result = (void *)sub_18C85D210(v6, (char *)&v35, v17, &v37, v5[5], &v36, v15, a2);
    unint64_t v7 = v37;
    unsigned int v9 = *((_DWORD *)v5 + 10) - v37;
  }
LABEL_52:
  if (*a2 <= 0 && (unint64_t)v21 < v5[3] && !v9) {
    *a2 = 15;
  }
  v5[2] = v21;
  v5[4] = v7;
  v5[6] = v36;
  return result;
}

uint64_t sub_18C8644F0(void *a1, int *a2)
{
  uint64_t v2 = a1[1];
  if (*(int *)(v2 + 76) >= 8)
  {
    uint64_t v4 = (char *)a1[2];
    unint64_t v5 = a1[3];
    if ((unint64_t)v4 >= v5)
    {
      int v7 = 8;
      goto LABEL_7;
    }
    uint64_t v6 = (unsigned __int8 *)(v4 + 2);
    if ((unint64_t)(v4 + 2) > v5)
    {
      *(unsigned char *)(v2 + 65) = *v4;
      *(unsigned char *)(a1[1] + 64) = 1;
      a1[2] = v4 + 1;
      int v7 = 11;
LABEL_7:
      *a2 = v7;
      return 0xFFFFLL;
    }
    int v8 = v4[1];
    uint64_t v3 = *v4 | (v8 << 8);
    if ((v8 & 0xF8) != 0xD8) {
      goto LABEL_19;
    }
    if ((v8 & 4) == 0)
    {
      unsigned int v9 = (unsigned __int8 *)(v4 + 4);
      if ((unint64_t)(v4 + 4) > v5)
      {
        int v10 = (unsigned char *)(v2 + 65);
        unint64_t v11 = v5 - (void)v4;
        *(unsigned char *)(v2 + 64) = v5 - (_BYTE)v4;
        uint64_t v6 = (unsigned __int8 *)v5;
        do
        {
          char v12 = *v4++;
          *v10++ = v12;
          --v11;
        }
        while (v11);
        int v13 = 11;
        goto LABEL_18;
      }
      int v14 = v4[3];
      if ((v14 & 0xFC) == 0xDC)
      {
        unsigned int v15 = (*v6 | (v14 << 8)) + (v3 << 10);
        if (v15 > 0x35FDBFF)
        {
          uint64_t v3 = v15 - 56613888;
          goto LABEL_20;
        }
        uint64_t v6 = v9;
      }
    }
    *(unsigned char *)(v2 + 64) = 2;
    *(unsigned char *)(v2 + 65) = *(v6 - 2);
    *(unsigned char *)(v2 + 66) = *(v6 - 1);
    int v13 = 12;
LABEL_18:
    *a2 = v13;
    uint64_t v3 = 0xFFFFLL;
LABEL_19:
    unsigned int v9 = v6;
LABEL_20:
    a1[2] = v9;
    return v3;
  }
  return 4294967287;
}

const char *sub_18C864618(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 56) & 0xF) != 0) {
    return "UTF-16LE,version=1";
  }
  else {
    return "UTF-16LE";
  }
}

uint64_t sub_18C864638(uint64_t result, uint64_t a2, _DWORD *a3)
{
  if ((*(_DWORD *)(result + 56) & 0xFu) > 2)
  {
    *a3 = 1;
  }
  else
  {
    if ((*(_DWORD *)(result + 56) & 0xF) == 2 && !*(unsigned char *)(a2 + 8))
    {
      *(void *)(result + 48) = &unk_1E5502568;
      **(_DWORD **)(result + 40) = 65023;
    }
    *(void *)(result + 76) = 0x100000000;
  }
  return result;
}

uint64_t sub_18C864688(uint64_t result, int a2)
{
  if (a2 > 1 || (*(_DWORD *)(result + 76) = 0, a2 != 1)) {
    *(_DWORD *)(result + 80) = 1;
  }
  return result;
}

uint64_t sub_18C8646A4(void *a1, int *a2)
{
  int v2 = *(_DWORD *)(a1[1] + 76);
  if (v2 == 9) {
    return sub_18C8644F0(a1, a2);
  }
  if (v2 == 8) {
    return sub_18C8638F8(a1, a2);
  }
  return 4294967287;
}

const char *sub_18C8646CC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 56);
  int v2 = "UTF-16,version=2";
  if ((v1 & 0xF) == 1) {
    int v2 = "UTF-16,version=1";
  }
  if ((v1 & 0xF) != 0) {
    return v2;
  }
  else {
    return "UTF-16";
  }
}

void *sub_18C864700(void *result, int *a2)
{
  unint64_t v3 = result[3];
  int v2 = (_WORD *)result[4];
  unint64_t v4 = result[5];
  uint64_t v6 = result[1];
  unint64_t v5 = (unsigned __int8 *)result[2];
  uint64_t v7 = v6 + 65;
  if (*(char *)(v6 + 64) < 1 || (unint64_t)v2 >= v4) {
    goto LABEL_6;
  }
  LODWORD(v9) = *(unsigned __int8 *)(v6 + 64);
  *(unsigned char *)(v6 + 64) = 0;
  unsigned int v10 = *(_DWORD *)(v6 + 72) - 1;
  *(_DWORD *)(v6 + 72) = 0;
  while (v9 > 3)
  {
LABEL_14:
    if (HIWORD(v10) > 0x10u || (v10 & 0xFFFFF800) == 55296)
    {
      *(unsigned char *)(result[1] + 64) = v9;
      *a2 = 12;
      goto LABEL_23;
    }
    if (HIWORD(v10))
    {
      *int v2 = (v10 >> 10) - 10304;
      int v14 = v2 + 1;
      __int16 v15 = v10 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v4)
      {
        uint64_t v18 = result[1];
        *(_WORD *)(v18 + 144) = v15;
        *(unsigned char *)(v18 + 93) = 1;
        *a2 = 15;
        int v2 = v14;
        goto LABEL_23;
      }
      v2[1] = v15;
      v2 += 2;
    }
    else
    {
      *v2++ = v10;
    }
LABEL_6:
    unsigned int v10 = 0;
    LODWORD(v9) = 0;
    if ((unint64_t)v5 >= v3 || (unint64_t)v2 >= v4) {
      goto LABEL_23;
    }
  }
  uint64_t v9 = v9;
  while ((unint64_t)v5 < v3)
  {
    int v12 = *v5++;
    unsigned int v10 = v12 | (v10 << 8);
    *(unsigned char *)(v7 + v9++) = v12;
    if (v9 == 4) {
      goto LABEL_14;
    }
  }
  unsigned int v16 = v10 + 1;
  uint64_t v17 = result[1];
  *(_DWORD *)(v17 + 72) = v16;
  *(unsigned char *)(v17 + 64) = v9;
LABEL_23:
  if ((unint64_t)v5 < v3 && (unint64_t)v2 >= v4 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v2;
  result[2] = v5;
  return result;
}

void *sub_18C864840(void *result, int *a2)
{
  unint64_t v3 = result[3];
  int v2 = (_WORD *)result[4];
  unint64_t v5 = result[5];
  unint64_t v4 = (_DWORD *)result[6];
  uint64_t v7 = result[1];
  uint64_t v6 = (unsigned __int8 *)result[2];
  uint64_t v8 = v7 + 65;
  int v9 = 0;
  if (*(char *)(v7 + 64) < 1 || (unint64_t)v2 >= v5) {
    goto LABEL_6;
  }
  LODWORD(v11) = *(unsigned __int8 *)(v7 + 64);
  *(unsigned char *)(v7 + 64) = 0;
  unsigned int v12 = *(_DWORD *)(v7 + 72) - 1;
  *(_DWORD *)(v7 + 72) = 0;
  while (v11 > 3)
  {
LABEL_14:
    if (HIWORD(v12) > 0x10u || (v12 & 0xFFFFF800) == 55296)
    {
      *(unsigned char *)(result[1] + 64) = v11;
      *a2 = 12;
      goto LABEL_24;
    }
    if (HIWORD(v12))
    {
      *int v2 = (v12 >> 10) - 10304;
      *unint64_t v4 = v9;
      uint64_t v17 = v4 + 1;
      __int16 v18 = v12 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v5)
      {
        uint64_t v20 = result[1];
        *(_WORD *)(v20 + 144) = v18;
        *(unsigned char *)(v20 + 93) = 1;
        *a2 = 15;
        ++v2;
        unint64_t v4 = v17;
        goto LABEL_24;
      }
      v2[1] = v18;
      v2 += 2;
      uint64_t v16 = 2;
    }
    else
    {
      *v2++ = v12;
      uint64_t v16 = 1;
      uint64_t v17 = v4;
    }
    v4 += v16;
    *uint64_t v17 = v9;
    v9 += v11;
LABEL_6:
    unsigned int v12 = 0;
    LODWORD(v11) = 0;
    if ((unint64_t)v6 >= v3 || (unint64_t)v2 >= v5) {
      goto LABEL_24;
    }
  }
  uint64_t v11 = v11;
  while ((unint64_t)v6 < v3)
  {
    int v14 = *v6++;
    unsigned int v12 = v14 | (v12 << 8);
    *(unsigned char *)(v8 + v11++) = v14;
    if (v11 == 4) {
      goto LABEL_14;
    }
  }
  uint64_t v19 = result[1];
  *(_DWORD *)(v19 + 72) = v12 + 1;
  *(unsigned char *)(v19 + 64) = v11;
LABEL_24:
  if ((unint64_t)v6 < v3 && (unint64_t)v2 >= v5 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v2;
  result[2] = v6;
  result[6] = v4;
  return result;
}

uint64_t sub_18C8649AC(uint64_t result, int *a2)
{
  int v2 = *(unsigned __int16 **)(result + 16);
  unint64_t v3 = *(void *)(result + 24);
  if ((unint64_t)v2 >= v3) {
    return result;
  }
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(result + 40);
  uint64_t result = *(void *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18C85D210(result, byte_18CA806E8, 4, (void *)(v5 + 32), v6, (void *)(v5 + 48), -1, a2);
    uint64_t result = *(void *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  int v16 = 0;
  uint64_t v7 = *(unsigned char **)(v5 + 32);
  int v8 = *(_DWORD *)(result + 84);
  if (!v8) {
    goto LABEL_6;
  }
  *(_DWORD *)(result + 84) = 0;
LABEL_12:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v8;
    if (!*(unsigned char *)(v5 + 2)) {
      goto LABEL_24;
    }
  }
  else
  {
    int v11 = *v2;
    if ((v11 & 0xFC00) == 0xDC00)
    {
      int v8 = v11 + (v8 << 10) - 56613888;
      ++v2;
      while (1)
      {
        uint64_t v12 = 0;
        BYTE1(v16) = BYTE2(v8) & 0x1F;
        BYTE2(v16) = BYTE1(v8);
        HIBYTE(v16) = v8;
        do
        {
          char v13 = *((unsigned char *)&v16 + v12);
          if ((unint64_t)v7 >= v6)
          {
            uint64_t v14 = *(void *)(v5 + 8);
            uint64_t v15 = *(char *)(v14 + 91);
            *(unsigned char *)(v14 + 91) = v15 + 1;
            *(unsigned char *)(v14 + v15 + 104) = v13;
            *a2 = 15;
          }
          else
          {
            *v7++ = v13;
          }
          ++v12;
        }
        while (v12 != 4);
LABEL_6:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6) {
          goto LABEL_24;
        }
        int v10 = *v2++;
        int v8 = v10;
        if ((v10 & 0xF800) == 0xD800)
        {
          if ((v8 & 0xFC00) != 0xD800) {
            break;
          }
          goto LABEL_12;
        }
      }
    }
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v8;
  }
  *a2 = 12;
LABEL_24:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0) {
    *a2 = 15;
  }
  *(void *)(v5 + 32) = v7;
  *(void *)(v5 + 16) = v2;
  return result;
}

uint64_t sub_18C864B58(uint64_t result, int *a2)
{
  int v2 = *(unsigned __int16 **)(result + 16);
  unint64_t v3 = *(void *)(result + 24);
  if ((unint64_t)v2 >= v3) {
    return result;
  }
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(result + 40);
  uint64_t result = *(void *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18C85D210(result, byte_18CA806EC, 4, (void *)(v5 + 32), v6, (void *)(v5 + 48), -1, a2);
    uint64_t result = *(void *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  int v18 = 0;
  uint64_t v7 = *(unsigned char **)(v5 + 32);
  int v8 = *(_DWORD **)(v5 + 48);
  int v9 = *(_DWORD *)(result + 84);
  if (!v9)
  {
    int v10 = 0;
    goto LABEL_7;
  }
  int v10 = 0;
  *(_DWORD *)(result + 84) = 0;
LABEL_13:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v9;
    if (!*(unsigned char *)(v5 + 2)) {
      goto LABEL_27;
    }
  }
  else
  {
    int v13 = *v2;
    if ((v13 & 0xFC00) == 0xDC00)
    {
      int v9 = v13 + (v9 << 10) - 56613888;
      ++v2;
      while (1)
      {
        uint64_t v14 = 0;
        BYTE1(v18) = BYTE2(v9) & 0x1F;
        BYTE2(v18) = BYTE1(v9);
        HIBYTE(v18) = v9;
        do
        {
          char v15 = *((unsigned char *)&v18 + v14);
          if ((unint64_t)v7 >= v6)
          {
            uint64_t v16 = *(void *)(v5 + 8);
            uint64_t v17 = *(char *)(v16 + 91);
            *(unsigned char *)(v16 + 91) = v17 + 1;
            *(unsigned char *)(v16 + v17 + 104) = v15;
            *a2 = 15;
          }
          else
          {
            *v7++ = v15;
            *v8++ = v10;
          }
          ++v14;
        }
        while (v14 != 4);
        if (BYTE1(v18)) {
          ++v10;
        }
        ++v10;
LABEL_7:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6) {
          goto LABEL_27;
        }
        int v12 = *v2++;
        int v9 = v12;
        if ((v12 & 0xF800) == 0xD800)
        {
          if ((v9 & 0xFC00) != 0xD800) {
            break;
          }
          goto LABEL_13;
        }
      }
    }
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v9;
  }
  *a2 = 12;
LABEL_27:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0) {
    *a2 = 15;
  }
  *(void *)(v5 + 32) = v7;
  *(void *)(v5 + 16) = v2;
  *(void *)(v5 + 48) = v8;
  return result;
}

uint64_t sub_18C864D28(void *a1, int *a2)
{
  unint64_t v4 = (unsigned __int8 *)a1[2];
  unint64_t v3 = a1[3];
  if ((unint64_t)v4 >= v3)
  {
    int v7 = 8;
  }
  else
  {
    int v6 = v3 - v4;
    if ((int)v3 - (int)v4 > 3)
    {
      unsigned int v8 = (*v4 << 24) | (v4[1] << 16);
      int v9 = v8 | (v4[2] << 8);
      unsigned int v10 = v4[3];
      a1[2] = v4 + 4;
      if (HIWORD(v8) <= 0x10u && (v9 & 0xFFFFF800) != 55296) {
        return v9 | v10;
      }
      *(_DWORD *)(a1[1] + 65) = *(_DWORD *)v4;
      *(unsigned char *)(a1[1] + 64) = 4;
      int v7 = 12;
    }
    else
    {
      memcpy((void *)(a1[1] + 65), v4, v6);
      *(unsigned char *)(a1[1] + 64) = v6;
      a1[2] = &v4[v6];
      int v7 = 11;
    }
  }
  *a2 = v7;
  return 0xFFFFLL;
}

void *sub_18C864E08(void *result, int *a2)
{
  unint64_t v3 = result[3];
  int v2 = (_WORD *)result[4];
  unint64_t v4 = result[5];
  uint64_t v6 = result[1];
  uint64_t v5 = (unsigned __int8 *)result[2];
  uint64_t v7 = v6 + 65;
  if (*(char *)(v6 + 64) < 1 || (unint64_t)v2 >= v4) {
    goto LABEL_6;
  }
  LODWORD(v9) = *(unsigned __int8 *)(v6 + 64);
  *(unsigned char *)(v6 + 64) = 0;
  unsigned int v10 = *(_DWORD *)(v6 + 72) - 1;
  *(_DWORD *)(v6 + 72) = 0;
  while (v9 > 3)
  {
LABEL_14:
    if (HIWORD(v10) > 0x10u || (v10 & 0xFFFFF800) == 55296)
    {
      *(unsigned char *)(result[1] + 64) = v9;
      *a2 = 12;
      goto LABEL_23;
    }
    if (HIWORD(v10))
    {
      *int v2 = (v10 >> 10) - 10304;
      char v15 = v2 + 1;
      __int16 v16 = v10 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v4)
      {
        uint64_t v19 = result[1];
        *(_WORD *)(v19 + 144) = v16;
        *(unsigned char *)(v19 + 93) = 1;
        *a2 = 15;
        int v2 = v15;
        goto LABEL_23;
      }
      v2[1] = v16;
      v2 += 2;
    }
    else
    {
      *v2++ = v10;
    }
LABEL_6:
    unsigned int v10 = 0;
    LODWORD(v9) = 0;
    if ((unint64_t)v5 >= v3 || (unint64_t)v2 >= v4) {
      goto LABEL_23;
    }
  }
  int v12 = 8 * v9;
  uint64_t v9 = v9;
  while ((unint64_t)v5 < v3)
  {
    int v13 = *v5++;
    v10 |= v13 << v12;
    *(unsigned char *)(v7 + v9) = v13;
    v12 += 8;
    if (++v9 == 4) {
      goto LABEL_14;
    }
  }
  unsigned int v17 = v10 + 1;
  uint64_t v18 = result[1];
  *(_DWORD *)(v18 + 72) = v17;
  *(unsigned char *)(v18 + 64) = v9;
LABEL_23:
  if ((unint64_t)v5 < v3 && (unint64_t)v2 >= v4 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v2;
  result[2] = v5;
  return result;
}

void *sub_18C864F54(void *result, int *a2)
{
  unint64_t v3 = result[3];
  int v2 = (_WORD *)result[4];
  unint64_t v5 = result[5];
  unint64_t v4 = (_DWORD *)result[6];
  uint64_t v7 = result[1];
  uint64_t v6 = (unsigned __int8 *)result[2];
  uint64_t v8 = v7 + 65;
  int v9 = 0;
  if (*(char *)(v7 + 64) < 1 || (unint64_t)v2 >= v5) {
    goto LABEL_6;
  }
  LODWORD(v11) = *(unsigned __int8 *)(v7 + 64);
  *(unsigned char *)(v7 + 64) = 0;
  unsigned int v12 = *(_DWORD *)(v7 + 72) - 1;
  *(_DWORD *)(v7 + 72) = 0;
  while (v11 > 3)
  {
LABEL_14:
    if (HIWORD(v12) > 0x10u || (v12 & 0xFFFFF800) == 55296)
    {
      *(unsigned char *)(result[1] + 64) = v11;
      *a2 = 12;
      goto LABEL_24;
    }
    if (HIWORD(v12))
    {
      *int v2 = (v12 >> 10) - 10304;
      *unint64_t v4 = v9;
      uint64_t v18 = v4 + 1;
      __int16 v19 = v12 & 0x3FF | 0xDC00;
      if ((unint64_t)(v2 + 1) >= v5)
      {
        uint64_t v21 = result[1];
        *(_WORD *)(v21 + 144) = v19;
        *(unsigned char *)(v21 + 93) = 1;
        *a2 = 15;
        ++v2;
        unint64_t v4 = v18;
        goto LABEL_24;
      }
      v2[1] = v19;
      v2 += 2;
      uint64_t v17 = 2;
    }
    else
    {
      *v2++ = v12;
      uint64_t v17 = 1;
      uint64_t v18 = v4;
    }
    v4 += v17;
    *uint64_t v18 = v9;
    v9 += v11;
LABEL_6:
    unsigned int v12 = 0;
    LODWORD(v11) = 0;
    if ((unint64_t)v6 >= v3 || (unint64_t)v2 >= v5) {
      goto LABEL_24;
    }
  }
  int v14 = 8 * v11;
  uint64_t v11 = v11;
  while ((unint64_t)v6 < v3)
  {
    int v15 = *v6++;
    v12 |= v15 << v14;
    *(unsigned char *)(v8 + v11) = v15;
    v14 += 8;
    if (++v11 == 4) {
      goto LABEL_14;
    }
  }
  uint64_t v20 = result[1];
  *(_DWORD *)(v20 + 72) = v12 + 1;
  *(unsigned char *)(v20 + 64) = v11;
LABEL_24:
  if ((unint64_t)v6 < v3 && (unint64_t)v2 >= v5 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v2;
  result[2] = v6;
  result[6] = v4;
  return result;
}

uint64_t sub_18C8650CC(uint64_t result, int *a2)
{
  int v2 = *(unsigned __int16 **)(result + 16);
  unint64_t v3 = *(void *)(result + 24);
  if ((unint64_t)v2 >= v3) {
    return result;
  }
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(result + 40);
  uint64_t result = *(void *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18C85D210(result, byte_18CA806F0, 4, (void *)(v5 + 32), v6, (void *)(v5 + 48), -1, a2);
    uint64_t result = *(void *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  int v16 = 0;
  uint64_t v7 = *(unsigned char **)(v5 + 32);
  int v8 = *(_DWORD *)(result + 84);
  if (!v8) {
    goto LABEL_6;
  }
  *(_DWORD *)(result + 84) = 0;
LABEL_12:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v8;
    if (!*(unsigned char *)(v5 + 2)) {
      goto LABEL_24;
    }
  }
  else
  {
    int v11 = *v2;
    if ((v11 & 0xFC00) == 0xDC00)
    {
      int v8 = v11 + (v8 << 10) - 56613888;
      ++v2;
      while (1)
      {
        uint64_t v12 = 0;
        BYTE2(v16) = BYTE2(v8) & 0x1F;
        LOWORD(v16) = v8;
        do
        {
          char v13 = *((unsigned char *)&v16 + v12);
          if ((unint64_t)v7 >= v6)
          {
            uint64_t v14 = *(void *)(v5 + 8);
            uint64_t v15 = *(char *)(v14 + 91);
            *(unsigned char *)(v14 + 91) = v15 + 1;
            *(unsigned char *)(v14 + v15 + 104) = v13;
            *a2 = 15;
          }
          else
          {
            *v7++ = v13;
          }
          ++v12;
        }
        while (v12 != 4);
LABEL_6:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6) {
          goto LABEL_24;
        }
        int v10 = *v2++;
        int v8 = v10;
        if ((v10 & 0xF800) == 0xD800)
        {
          if ((v8 & 0xFC00) != 0xD800) {
            break;
          }
          goto LABEL_12;
        }
      }
    }
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v8;
  }
  *a2 = 12;
LABEL_24:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0) {
    *a2 = 15;
  }
  *(void *)(v5 + 32) = v7;
  *(void *)(v5 + 16) = v2;
  return result;
}

uint64_t sub_18C865278(uint64_t result, int *a2)
{
  int v2 = *(unsigned __int16 **)(result + 16);
  unint64_t v3 = *(void *)(result + 24);
  if ((unint64_t)v2 >= v3) {
    return result;
  }
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(result + 40);
  uint64_t result = *(void *)(result + 8);
  if (*(_DWORD *)(result + 80) == 1)
  {
    sub_18C85D210(result, byte_18CA806F4, 4, (void *)(v5 + 32), v6, (void *)(v5 + 48), -1, a2);
    uint64_t result = *(void *)(v5 + 8);
    *(_DWORD *)(result + 80) = 0;
  }
  int v18 = 0;
  uint64_t v7 = *(unsigned char **)(v5 + 32);
  int v8 = *(_DWORD **)(v5 + 48);
  int v9 = *(_DWORD *)(result + 84);
  if (!v9)
  {
    int v10 = 0;
    goto LABEL_7;
  }
  int v10 = 0;
  *(_DWORD *)(result + 84) = 0;
LABEL_13:
  if ((unint64_t)v2 >= v3)
  {
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v9;
    if (!*(unsigned char *)(v5 + 2)) {
      goto LABEL_27;
    }
  }
  else
  {
    int v13 = *v2;
    if ((v13 & 0xFC00) == 0xDC00)
    {
      int v9 = v13 + (v9 << 10) - 56613888;
      ++v2;
      while (1)
      {
        uint64_t v14 = 0;
        BYTE2(v18) = BYTE2(v9) & 0x1F;
        LOWORD(v18) = v9;
        do
        {
          char v15 = *((unsigned char *)&v18 + v14);
          if ((unint64_t)v7 >= v6)
          {
            uint64_t v16 = *(void *)(v5 + 8);
            uint64_t v17 = *(char *)(v16 + 91);
            *(unsigned char *)(v16 + 91) = v17 + 1;
            *(unsigned char *)(v16 + v17 + 104) = v15;
            *a2 = 15;
          }
          else
          {
            *v7++ = v15;
            *v8++ = v10;
          }
          ++v14;
        }
        while (v14 != 4);
        if (BYTE2(v18)) {
          ++v10;
        }
        ++v10;
LABEL_7:
        if ((unint64_t)v2 >= v3 || (unint64_t)v7 >= v6) {
          goto LABEL_27;
        }
        int v12 = *v2++;
        int v9 = v12;
        if ((v12 & 0xF800) == 0xD800)
        {
          if ((v9 & 0xFC00) != 0xD800) {
            break;
          }
          goto LABEL_13;
        }
      }
    }
    *(_DWORD *)(*(void *)(v5 + 8) + 84) = v9;
  }
  *a2 = 12;
LABEL_27:
  if ((unint64_t)v2 < v3 && (unint64_t)v7 >= v6 && *a2 <= 0) {
    *a2 = 15;
  }
  *(void *)(v5 + 32) = v7;
  *(void *)(v5 + 16) = v2;
  *(void *)(v5 + 48) = v8;
  return result;
}

uint64_t sub_18C865448(void *a1, int *a2)
{
  unint64_t v4 = (unsigned __int8 *)a1[2];
  unint64_t v3 = a1[3];
  if ((unint64_t)v4 >= v3)
  {
    int v7 = 8;
  }
  else
  {
    int v6 = v3 - v4;
    if ((int)v3 - (int)v4 > 3)
    {
      unsigned int v8 = (v4[3] << 24) | (v4[2] << 16);
      int v9 = v8 | (v4[1] << 8);
      unsigned int v10 = *v4;
      a1[2] = v4 + 4;
      if (HIWORD(v8) <= 0x10u && (v9 & 0xFFFFF800) != 55296) {
        return v9 | v10;
      }
      *(_DWORD *)(a1[1] + 65) = *(_DWORD *)v4;
      *(unsigned char *)(a1[1] + 64) = 4;
      int v7 = 12;
    }
    else
    {
      memcpy((void *)(a1[1] + 65), v4, v6);
      *(unsigned char *)(a1[1] + 64) = v6;
      a1[2] = &v4[v6];
      int v7 = 11;
    }
  }
  *a2 = v7;
  return 0xFFFFLL;
}

double sub_18C865528(uint64_t a1)
{
  *(void *)&double result = 0x100000000;
  *(void *)(a1 + 76) = 0x100000000;
  return result;
}

uint64_t sub_18C865538(uint64_t result, int a2)
{
  if (a2 > 1 || (*(_DWORD *)(result + 76) = 0, a2 != 1)) {
    *(_DWORD *)(result + 80) = 1;
  }
  return result;
}

void *sub_18C865554(void *result, int *a2)
{
  unint64_t v3 = result;
  int v4 = 0;
  uint64_t v6 = result[1];
  uint64_t v5 = (unsigned char *)result[2];
  int v7 = (unsigned char *)result[3];
  unsigned int v8 = (_DWORD *)result[6];
  uint64_t v9 = *(unsigned int *)(v6 + 76);
LABEL_2:
  uint64_t v10 = v9;
  while (1)
  {
    if (v5 >= v7) {
      goto LABEL_32;
    }
    if (*a2 > 0) {
      break;
    }
    if (v10)
    {
      uint64_t v9 = v10;
      if (v10 > 9) {
        goto LABEL_2;
      }
      if (((1 << v10) & 0xEE) != 0)
      {
        if (*v5 == *((unsigned char *)&unk_18CA806F8 + v10))
        {
          ++v5;
          if (v10 == 3)
          {
            uint64_t v9 = 8;
          }
          else
          {
            uint64_t v9 = (v10 + 1);
            if (v10 != 7) {
              goto LABEL_2;
            }
            uint64_t v9 = 9;
          }
          int v4 = v5 - *((_DWORD *)v3 + 4);
        }
        else
        {
          int v11 = (unsigned char *)v3[2];
          int v12 = v5 - v11;
          uint64_t v9 = 8u;
          uint64_t v5 = v11;
          int v13 = (v10 & 3) - v12;
          if (v13)
          {
            uint64_t v14 = v6;
            char v15 = *((unsigned char *)v3 + 2);
            uint64_t v16 = (char *)&unk_18CA806F8 + (v10 & 4);
            v3[2] = v16;
            v3[3] = &v16[v13];
            *((unsigned char *)v3 + 2) = 0;
            double result = sub_18C864700(v3, a2);
            v3[3] = v7;
            *((unsigned char *)v3 + 2) = v15;
            uint64_t v6 = v14;
            uint64_t v9 = 8;
            uint64_t v5 = v11;
          }
        }
      }
      else if (v10 == 8)
      {
        v3[2] = v5;
        if (v8) {
          double result = sub_18C864840(v3, a2);
        }
        else {
          double result = sub_18C864700(v3, a2);
        }
        uint64_t v5 = (unsigned char *)v3[2];
        uint64_t v9 = 8;
      }
      else
      {
        uint64_t v9 = v10;
        if (v10 == 9)
        {
          v3[2] = v5;
          if (v8) {
            double result = sub_18C864F54(v3, a2);
          }
          else {
            double result = sub_18C864E08(v3, a2);
          }
          uint64_t v5 = (unsigned char *)v3[2];
          uint64_t v9 = 9u;
        }
      }
      goto LABEL_2;
    }
    if (*v5 == 255)
    {
      uint64_t v9 = 5u;
      goto LABEL_24;
    }
    uint64_t v10 = 8;
    if (!*v5)
    {
      uint64_t v9 = 1u;
LABEL_24:
      ++v5;
      goto LABEL_2;
    }
  }
  LODWORD(v9) = v10;
LABEL_32:
  if (v8 && v4)
  {
    unint64_t v17 = v3[6];
    while ((unint64_t)v8 < v17)
      *v8++ += v4;
  }
  v3[2] = v5;
  if (v5 == v7 && *((unsigned char *)v3 + 2) && v9 != 0)
  {
    if (v9 == 9)
    {
      double result = sub_18C864E08(v3, a2);
      LODWORD(v9) = 9;
    }
    else
    {
      if (v9 == 8)
      {
        double result = sub_18C864700(v3, a2);
      }
      else
      {
        __int16 v19 = (char *)&unk_18CA806F8 + (v9 & 4);
        v3[2] = v19;
        v3[3] = &v19[v9 & 3];
        double result = sub_18C864700(v3, a2);
        v3[2] = v7;
        v3[3] = v7;
      }
      LODWORD(v9) = 8;
    }
  }
  *(_DWORD *)(v6 + 76) = v9;
  return result;
}

uint64_t sub_18C8657C0(void *a1, int *a2)
{
  int v2 = *(_DWORD *)(a1[1] + 76);
  if (v2 == 9) {
    return sub_18C865448(a1, a2);
  }
  if (v2 == 8) {
    return sub_18C864D28(a1, a2);
  }
  return 4294967287;
}

uint64_t sub_18C8657E8(uint64_t result, uint64_t a2, _DWORD *a3)
{
  unsigned int v3 = *(_DWORD *)(result + 56) & 0xF;
  if (v3 > 1)
  {
    *a3 = 1;
  }
  else
  {
    *(_DWORD *)(result + 72) = 0x1000000;
    *(unsigned char *)(result + 64) = 0;
    *(_DWORD *)(result + 80) = (v3 << 28) | 0x1000000;
  }
  return result;
}

uint64_t sub_18C86581C(uint64_t result, int a2)
{
  if (a2 > 1 || (*(_DWORD *)(result + 72) = 0x1000000, *(unsigned char *)(result + 64) = 0, a2 != 1)) {
    *(_DWORD *)(result + 80) = *(_DWORD *)(result + 80) & 0xF0000000 | 0x1000000;
  }
  return result;
}

uint64_t sub_18C86584C(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  unsigned int v3 = *(unsigned __int8 **)(result + 16);
  uint64_t v5 = *(unsigned __int8 **)(result + 24);
  int v4 = *(_WORD **)(result + 32);
  unint64_t v7 = *(void *)(result + 40);
  uint64_t v6 = *(int **)(result + 48);
  unsigned int v8 = *(_DWORD *)(v2 + 72);
  unsigned int v9 = HIWORD(v8);
  uint64_t v10 = (unsigned char *)(v2 + 65);
  int v11 = *(unsigned __int8 *)(v2 + 64);
  if (*(unsigned char *)(v2 + 64)) {
    int v12 = -1;
  }
  else {
    int v12 = 0;
  }
  if ((v8 & 0x1000000) != 0)
  {
    int v13 = v12;
LABEL_7:
    int v14 = v5 - v3;
    if ((int)v5 - (int)v3 >= (int)((v7 - (unint64_t)v4) >> 1)) {
      int v14 = (v7 - (unint64_t)v4) >> 1;
    }
    if (v14 >= 1)
    {
      int v15 = v14 + 1;
      uint64_t v16 = v3 + 1;
      do
      {
        unsigned int v3 = v16;
        unsigned int v17 = *(v16 - 1);
        if (v17 - 32 >= 0x5E || v17 == 92)
        {
          if (v17 > 0xD || ((1 << v17) & 0x2600) == 0)
          {
            *uint64_t v10 = v17;
            *a2 = 12;
            LOBYTE(v11) = 1;
            goto LABEL_25;
          }
        }
        else if (v17 == 43)
        {
          int v11 = 0;
          LOWORD(v8) = 0;
          int v12 = v13 + 1;
          LOBYTE(v9) = -1;
          ++v13;
          goto LABEL_28;
        }
        *v4++ = v17;
        if (v6) {
          *v6++ = v13++;
        }
        --v15;
        uint64_t v16 = v3 + 1;
      }
      while (v15 > 1);
    }
    LOBYTE(v11) = 0;
LABEL_25:
    int v20 = 0x1000000;
    if (v3 < v5 && (unint64_t)v4 >= v7)
    {
LABEL_50:
      int v25 = 15;
LABEL_51:
      *a2 = v25;
    }
  }
  else
  {
    int v13 = 0;
LABEL_28:
    if (v3 < v5)
    {
      int64_t v21 = v5 - v3;
      while (1)
      {
        if ((unint64_t)v4 >= v7)
        {
          int v20 = 0;
          goto LABEL_50;
        }
        unint64_t v22 = *v3;
        v10[v11] = v22;
        if (v22 > 0x7D) {
          break;
        }
        int v23 = byte_18CA807C8[v22];
        unsigned __int8 v24 = byte_18CA807C8[v22];
        if ((~v23 & 0xFD) == 0) {
          goto LABEL_63;
        }
        if ((char)v23 < 0)
        {
          ++v13;
          ++v3;
          if ((_BYTE)v9 != 0xFF)
          {
            if (!(_WORD)v8)
            {
              LOWORD(v8) = 0;
              goto LABEL_7;
            }
            goto LABEL_74;
          }
          *v4++ = 43;
          LOBYTE(v9) = -1;
          if (v6)
          {
            *v6++ = v12 - 1;
            LOBYTE(v9) = -1;
          }
          goto LABEL_7;
        }
        switch((char)v9)
        {
          case -1:
          case 0:
            LOBYTE(v9) = 1;
            ++v11;
            LOWORD(v8) = byte_18CA807C8[v22];
            break;
          case 1:
          case 3:
          case 4:
          case 6:
            LOWORD(v8) = (char)v23 | (unsigned __int16)((_WORD)v8 << 6);
            LOBYTE(v9) = v9 + 1;
            goto LABEL_36;
          case 2:
            *v4++ = ((char)v23 >> 2) | (16 * v8);
            if (v6)
            {
              *v6++ = v12;
              int v12 = v13;
            }
            *uint64_t v10 = v22;
            LOWORD(v8) = v24 & 3;
            LOBYTE(v9) = 3;
            goto LABEL_44;
          case 5:
            *v4++ = ((char)v23 >> 4) | (4 * v8);
            if (v6)
            {
              *v6++ = v12;
              int v12 = v13;
            }
            *uint64_t v10 = v22;
            LOWORD(v8) = v24 & 0xF;
            LOBYTE(v9) = 6;
LABEL_44:
            int v11 = 1;
            break;
          case 7:
            *v4++ = (char)v23 | (unsigned __int16)((_WORD)v8 << 6);
            int v11 = 0;
            LOWORD(v8) = 0;
            LOBYTE(v9) = 0;
            if (v6)
            {
              *v6++ = v12;
              int v12 = v13 + 1;
            }
            break;
          default:
LABEL_36:
            ++v11;
            break;
        }
        ++v13;
        ++v3;
        if (!--v21)
        {
          int v20 = 0;
          unsigned int v3 = v5;
          goto LABEL_52;
        }
      }
      unsigned __int8 v24 = -3;
LABEL_63:
      if ((_BYTE)v9 == 0xFF)
      {
        *uint64_t v10 = 43;
        int v20 = 0x1000000;
        LOBYTE(v9) = -1;
        LOBYTE(v11) = 1;
      }
      else
      {
        if (!(_WORD)v8)
        {
          LOWORD(v8) = 0;
          if (v24 != 253) {
            goto LABEL_7;
          }
          ++v3;
LABEL_74:
          int v20 = 0x1000000;
          int v25 = 12;
          LOBYTE(v11) = v11 + 1;
          goto LABEL_51;
        }
        int v20 = 0x1000000;
      }
      int v25 = 12;
      goto LABEL_51;
    }
    int v20 = 0;
  }
LABEL_52:
  if (*a2 <= 0)
  {
    if ((_WORD)v8) {
      BOOL v26 = 0;
    }
    else {
      BOOL v26 = v3 == v5;
    }
    if (v26) {
      char v27 = 0;
    }
    else {
      char v27 = v11;
    }
    if (*(unsigned char *)(result + 2)) {
      LOBYTE(v11) = v27;
    }
  }
  *(_DWORD *)(v2 + 72) = v20 | (v9 << 16) | (unsigned __int16)v8;
  *(unsigned char *)(v2 + 64) = v11;
  *(void *)(result + 16) = v3;
  *(void *)(result + 32) = v4;
  *(void *)(result + 48) = v6;
  return result;
}

uint64_t sub_18C865BC4(uint64_t result, _DWORD *a2)
{
  int v2 = 0;
  uint64_t v3 = *(void *)(result + 8);
  int v4 = *(unsigned __int16 **)(result + 16);
  unint64_t v5 = *(void *)(result + 24);
  uint64_t v6 = *(char **)(result + 32);
  unint64_t v8 = *(void *)(result + 40);
  unint64_t v7 = *(_DWORD **)(result + 48);
  unsigned int v9 = *(_DWORD *)(v3 + 80);
  uint64_t v10 = &unk_18CA808C8;
  if (!(v9 >> 28)) {
    uint64_t v10 = &unk_18CA80848;
  }
  unsigned int v11 = HIWORD(v9);
  if ((v9 & 0x1000000) != 0) {
    goto LABEL_4;
  }
  while (2)
  {
    int v17 = 1;
    if ((unint64_t)v4 >= v5)
    {
      int v21 = 0;
      goto LABEL_83;
    }
    while (1)
    {
      int v18 = v4;
      if ((unint64_t)v6 >= v8)
      {
        int v21 = 0;
        int v17 = 1;
        goto LABEL_67;
      }
      ++v4;
      unint64_t v19 = *v18;
      if (v19 <= 0x7F)
      {
        if (v10[v19]) {
          break;
        }
      }
      if (v11 == 2)
      {
        *uint64_t v6 = aAbcdefghijklmn[v9 | (v19 >> 12)];
        int v20 = v6 + 1;
        if ((unint64_t)(v6 + 1) >= v8)
        {
          if (v7) {
            *v7++ = v2++;
          }
          LOBYTE(v9) = 0;
          LOBYTE(v11) = 0;
          *(unsigned char *)(v3 + 104) = aAbcdefghijklmn[(v19 >> 6) & 0x3F];
          *(unsigned char *)(v3 + 105) = aAbcdefghijklmn[v19 & 0x3F];
          *(unsigned char *)(v3 + 91) = 2;
        }
        else
        {
          int v20 = v6 + 2;
          v6[1] = aAbcdefghijklmn[(v19 >> 6) & 0x3F];
          if ((unint64_t)(v6 + 2) < v8)
          {
            long long v6[2] = aAbcdefghijklmn[v19 & 0x3F];
            LOBYTE(v9) = 0;
            LOBYTE(v11) = 0;
            if (v7)
            {
              *unint64_t v7 = v2;
              v7[1] = v2;
              _DWORD v7[2] = v2++;
              v7 += 3;
            }
            v6 += 3;
            goto LABEL_64;
          }
          if (v7)
          {
            *unint64_t v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
          LOBYTE(v9) = 0;
          LOBYTE(v11) = 0;
          *(unsigned char *)(v3 + 104) = aAbcdefghijklmn[v19 & 0x3F];
          *(unsigned char *)(v3 + 91) = 1;
        }
        *a2 = 15;
        goto LABEL_63;
      }
      if ((char)v11 == 1)
      {
        *uint64_t v6 = aAbcdefghijklmn[v9 | (v19 >> 14)];
        int v20 = v6 + 1;
        if ((unint64_t)(v6 + 1) >= v8)
        {
          if (v7) {
            *v7++ = v2++;
          }
          *(unsigned char *)(v3 + 104) = aAbcdefghijklmn[(v19 >> 8) & 0x3F];
          *(unsigned char *)(v3 + 105) = aAbcdefghijklmn[v19 >> 2];
          *(unsigned char *)(v3 + 91) = 2;
        }
        else
        {
          int v20 = v6 + 2;
          v6[1] = aAbcdefghijklmn[(v19 >> 8) & 0x3F];
          if ((unint64_t)(v6 + 2) < v8)
          {
            int v20 = v6 + 3;
            long long v6[2] = aAbcdefghijklmn[v19 >> 2];
            if (v7)
            {
              *unint64_t v7 = v2;
              v7[1] = v2;
              _DWORD v7[2] = v2++;
              v7 += 3;
            }
LABEL_62:
            LOBYTE(v9) = 16 * (v19 & 3);
            LOBYTE(v11) = 2;
LABEL_63:
            uint64_t v6 = v20;
            goto LABEL_64;
          }
          if (v7)
          {
            *unint64_t v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
          *(unsigned char *)(v3 + 104) = aAbcdefghijklmn[v19 >> 2];
          *(unsigned char *)(v3 + 91) = 1;
        }
        *a2 = 15;
        goto LABEL_62;
      }
      if (!(_BYTE)v11)
      {
        *uint64_t v6 = aAbcdefghijklmn[v19 >> 10];
        int v20 = v6 + 1;
        if ((unint64_t)(v6 + 1) >= v8)
        {
          if (v7) {
            *v7++ = v2++;
          }
          *(unsigned char *)(v3 + 104) = aAbcdefghijklmn[(v19 >> 4) & 0x3F];
          *(unsigned char *)(v3 + 91) = 1;
          *a2 = 15;
        }
        else
        {
          int v20 = v6 + 2;
          v6[1] = aAbcdefghijklmn[(v19 >> 4) & 0x3F];
          if (v7)
          {
            *unint64_t v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
        }
        LOBYTE(v9) = 4 * (v19 & 0xF);
        LOBYTE(v11) = 1;
        goto LABEL_63;
      }
LABEL_64:
      if ((unint64_t)v4 >= v5)
      {
        int v21 = 0;
        int v17 = 1;
        goto LABEL_83;
      }
    }
    if ((_BYTE)v11)
    {
      *v6++ = aAbcdefghijklmn[v9];
      if (v7) {
        *v7++ = v2 - 1;
      }
    }
    if (byte_18CA807C8[v19] != 255)
    {
      if ((unint64_t)v6 < v8)
      {
        *v6++ = 45;
        if (v7) {
          *v7++ = v2 - 1;
        }
        goto LABEL_76;
      }
      int v17 = 0;
      *(unsigned char *)(v3 + 104) = 45;
      *(unsigned char *)(v3 + 91) = 1;
      int v21 = 0x1000000;
LABEL_67:
      int v4 = v18;
      goto LABEL_82;
    }
LABEL_76:
    int v4 = v18;
LABEL_4:
    if ((int)((v5 - (unint64_t)v4) >> 1) >= (int)v8 - (int)v6) {
      LODWORD(v12) = v8 - v6;
    }
    else {
      LODWORD(v12) = (v5 - (unint64_t)v4) >> 1;
    }
    if ((int)v12 >= 1)
    {
      unint64_t v13 = v5 - (void)v4 - 2;
      for (i = v4; ; int v4 = i)
      {
        unsigned int v16 = *i++;
        uint64_t v15 = v16;
        if (v16 > 0x7F) {
          break;
        }
        if (v10[v15])
        {
          *v6++ = v15;
          if (v7) {
            *v7++ = v2++;
          }
          if ((int)v12 < 2) {
            goto LABEL_68;
          }
          LODWORD(v12) = v12 - 1;
        }
        else
        {
          if (v15 != 43) {
            break;
          }
          *uint64_t v6 = 43;
          if ((unint64_t)(v6 + 1) >= v8)
          {
            ++v4;
            if (v7) {
              *v7++ = v2++;
            }
            *(unsigned char *)(v3 + 104) = 45;
            *(unsigned char *)(v3 + 91) = 1;
            *a2 = 15;
            ++v6;
            goto LABEL_80;
          }
          v6[1] = 45;
          if (v7)
          {
            *unint64_t v7 = v2;
            v7[1] = v2;
            v7 += 2;
            ++v2;
          }
          v6 += 2;
          unint64_t v12 = v13 >> 1;
          if ((int)(v13 >> 1) >= (int)v8 - (int)v6) {
            LODWORD(v12) = v8 - v6;
          }
          if ((int)v12 <= 0)
          {
LABEL_68:
            ++v4;
            goto LABEL_80;
          }
        }
        v13 -= 2;
      }
      *v6++ = 43;
      LOBYTE(v11) = 0;
      if (v7) {
        *v7++ = v2;
      }
      continue;
    }
    break;
  }
LABEL_80:
  int v17 = 0;
  int v21 = 0x1000000;
  if ((unint64_t)v4 < v5 && (unint64_t)v6 >= v8) {
LABEL_82:
  }
    *a2 = 15;
LABEL_83:
  if (*(unsigned char *)(result + 2)) {
    BOOL v22 = (unint64_t)v4 >= v5;
  }
  else {
    BOOL v22 = 0;
  }
  if (v22)
  {
    if (!v17) {
      goto LABEL_103;
    }
    if ((_BYTE)v11)
    {
      char v24 = aAbcdefghijklmn[v9];
      if ((unint64_t)v6 < v8)
      {
        *uint64_t v6 = v24;
        int v25 = v6 + 1;
        if (v7)
        {
          *v7++ = v2 - 1;
          goto LABEL_95;
        }
        if ((unint64_t)v25 >= v8)
        {
          unint64_t v7 = 0;
LABEL_102:
          uint64_t v27 = *(char *)(v3 + 91);
          *(unsigned char *)(v3 + 91) = v27 + 1;
          *(unsigned char *)(v3 + v27 + 104) = 45;
          *a2 = 15;
          uint64_t v6 = v25;
          goto LABEL_103;
        }
        unint64_t v7 = 0;
        v6[1] = 45;
        v6 += 2;
LABEL_103:
        unsigned int v23 = *(_DWORD *)(v3 + 80) & 0xF0000000 | 0x1000000;
        goto LABEL_104;
      }
      uint64_t v26 = *(char *)(v3 + 91);
      *(unsigned char *)(v3 + 91) = v26 + 1;
      *(unsigned char *)(v3 + v26 + 104) = v24;
      *a2 = 15;
    }
    int v25 = v6;
LABEL_95:
    if ((unint64_t)v25 < v8)
    {
      *int v25 = 45;
      uint64_t v6 = v25 + 1;
      if (v7) {
        *v7++ = v2 - 1;
      }
      goto LABEL_103;
    }
    goto LABEL_102;
  }
  unsigned int v23 = v21 | v9 | ((char)v11 << 16) | *(_DWORD *)(v3 + 80) & 0xF0000000;
LABEL_104:
  *(_DWORD *)(v3 + 80) = v23;
  *(void *)(result + 16) = v4;
  *(void *)(result + 32) = v6;
  *(void *)(result + 48) = v7;
  return result;
}

const char *sub_18C866110(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80) >> 28 == 1) {
    return "UTF-7,version=1";
  }
  else {
    return "UTF-7";
  }
}

uint64_t sub_18C866134(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = *(unsigned __int8 **)(result + 16);
  unint64_t v5 = *(unsigned __int8 **)(result + 24);
  int v4 = *(_WORD **)(result + 32);
  unint64_t v6 = *(void *)(result + 40);
  unint64_t v7 = *(int **)(result + 48);
  unsigned int v8 = *(_DWORD *)(v2 + 72);
  unsigned int v9 = HIWORD(v8);
  uint64_t v10 = (unsigned char *)(v2 + 65);
  int v11 = *(unsigned __int8 *)(v2 + 64);
  if (*(unsigned char *)(v2 + 64)) {
    int v12 = -1;
  }
  else {
    int v12 = 0;
  }
  if ((v8 & 0x1000000) != 0)
  {
    int v14 = v12;
    goto LABEL_7;
  }
  int v13 = 0;
LABEL_22:
  if (v3 < v5)
  {
    uint64_t v22 = v5 - v3;
    while (1)
    {
      if ((unint64_t)v4 >= v6)
      {
        *a2 = 15;
        goto LABEL_51;
      }
      uint64_t v23 = *v3;
      char v19 = v11 + 1;
      v10[v11] = v23;
      if (v23 > 0x7E) {
        break;
      }
      if (v23 == 44)
      {
        unsigned int v24 = 63;
      }
      else
      {
        if (v23 == 47) {
          goto LABEL_67;
        }
        if ((char)byte_18CA807C8[v23] < 0)
        {
          if (v23 == 45)
          {
            int v14 = v13 + 1;
            ++v3;
            if ((_BYTE)v9 != 0xFF)
            {
              if (!(_WORD)v8 && v9 <= 6u && ((1 << v9) & 0x49) != 0)
              {
                LOWORD(v8) = 0;
                goto LABEL_7;
              }
              goto LABEL_69;
            }
            *v4++ = 38;
            LOBYTE(v9) = -1;
            if (v7)
            {
              *v7++ = v12 - 1;
              LOBYTE(v9) = -1;
            }
LABEL_7:
            int v15 = v5 - v3;
            if ((int)v5 - (int)v3 >= (int)((v6 - (unint64_t)v4) >> 1)) {
              int v15 = (v6 - (unint64_t)v4) >> 1;
            }
            if (v15 >= 1)
            {
              int v16 = v15 + 1;
              int v17 = v3 + 1;
              while (1)
              {
                uint64_t v3 = v17;
                int v18 = *(v17 - 1);
                if ((v18 - 32) >= 0x5F)
                {
                  *uint64_t v10 = v18;
                  *a2 = 12;
                  char v19 = 1;
                  goto LABEL_18;
                }
                if (v18 == 38) {
                  break;
                }
                *v4++ = v18;
                if (v7) {
                  *v7++ = v14++;
                }
                --v16;
                int v17 = v3 + 1;
                if (v16 <= 1) {
                  goto LABEL_16;
                }
              }
              int v11 = 0;
              LOWORD(v8) = 0;
              int v12 = v14 + 1;
              LOBYTE(v9) = -1;
              int v13 = v14 + 1;
              goto LABEL_22;
            }
LABEL_16:
            char v19 = 0;
LABEL_18:
            int v20 = 0x1000000;
            if (v3 < v5 && (unint64_t)v4 >= v6)
            {
              int v21 = 15;
              goto LABEL_72;
            }
            goto LABEL_73;
          }
LABEL_67:
          ++v3;
          if ((_BYTE)v9 == 0xFF)
          {
            *(unsigned char *)(v2 + 65) = 38;
            *(unsigned char *)(v2 + 66) = v23;
            char v19 = 2;
          }
LABEL_69:
          int v21 = 12;
          goto LABEL_72;
        }
        unsigned int v24 = byte_18CA807C8[v23];
      }
      switch((char)v9)
      {
        case -1:
        case 0:
          LOBYTE(v9) = 1;
          ++v11;
          LOWORD(v8) = v24;
          break;
        case 1:
        case 3:
        case 4:
        case 6:
          LOWORD(v8) = v24 | ((_WORD)v8 << 6);
          LOBYTE(v9) = v9 + 1;
          goto LABEL_33;
        case 2:
          if ((unsigned __int16)((v24 >> 2) | (16 * v8)) - 32 < 0x5F) {
            goto LABEL_49;
          }
          *v4++ = (v24 >> 2) | (16 * v8);
          if (v7)
          {
            *v7++ = v12;
            int v12 = v13;
          }
          *uint64_t v10 = v23;
          LOWORD(v8) = v24 & 3;
          LOBYTE(v9) = 3;
          goto LABEL_43;
        case 5:
          if ((unsigned __int16)((v24 >> 4) | (4 * v8)) - 32 < 0x5F) {
            goto LABEL_49;
          }
          *v4++ = (v24 >> 4) | (4 * v8);
          if (v7)
          {
            *v7++ = v12;
            int v12 = v13;
          }
          *uint64_t v10 = v23;
          LOWORD(v8) = v24 & 0xF;
          LOBYTE(v9) = 6;
LABEL_43:
          int v11 = 1;
          break;
        case 7:
          if ((unsigned __int16)(v24 | ((_WORD)v8 << 6)) - 32 < 0x5F) {
            goto LABEL_49;
          }
          *v4++ = v24 | ((_WORD)v8 << 6);
          int v11 = 0;
          LOWORD(v8) = 0;
          LOBYTE(v9) = 0;
          if (v7)
          {
            *v7++ = v12;
            int v12 = v13 + 1;
          }
          break;
        default:
LABEL_33:
          ++v11;
          break;
      }
      ++v13;
      ++v3;
      if (!--v22)
      {
        uint64_t v3 = v5;
        goto LABEL_51;
      }
    }
LABEL_49:
    ++v3;
    goto LABEL_69;
  }
LABEL_51:
  if (*a2 <= 0 && v11 == 0)
  {
    LOBYTE(v11) = 0;
    if (*(unsigned char *)(result + 2) && v3 >= v5)
    {
      if ((_BYTE)v9 == 0xFF)
      {
        *uint64_t v10 = 38;
        char v19 = 1;
      }
      else
      {
        char v19 = 0;
      }
      int v21 = 11;
LABEL_72:
      *a2 = v21;
      int v20 = 0x1000000;
LABEL_73:
      LOBYTE(v11) = v19;
    }
    else
    {
      int v20 = 0;
    }
  }
  else
  {
    int v20 = 0;
  }
  *(_DWORD *)(v2 + 72) = v20 | (v9 << 16) | (unsigned __int16)v8;
  *(unsigned char *)(v2 + 64) = v11;
  *(void *)(result + 16) = v3;
  *(void *)(result + 32) = v4;
  *(void *)(result + 48) = v7;
  return result;
}

uint64_t sub_18C8664F0(uint64_t result, _DWORD *a2)
{
  int v2 = 0;
  uint64_t v3 = *(void *)(result + 8);
  int v4 = *(unsigned __int16 **)(result + 16);
  unint64_t v6 = *(void *)(result + 24);
  unint64_t v5 = *(char **)(result + 32);
  unint64_t v7 = *(void *)(result + 40);
  unsigned int v8 = *(_DWORD **)(result + 48);
  unsigned int v9 = *(_DWORD *)(v3 + 80);
  unsigned int v10 = HIWORD(v9);
  int v11 = v5;
  int v12 = v8;
  if ((v9 & 0x1000000) != 0) {
    goto LABEL_100;
  }
  while (2)
  {
    int v13 = 1;
    if ((unint64_t)v4 >= v6)
    {
      int v42 = 0;
      goto LABEL_131;
    }
    int v14 = v4;
    while (1)
    {
      int v4 = v14;
      if ((unint64_t)v11 >= v7)
      {
        int v42 = 0;
        int v43 = 1;
        goto LABEL_130;
      }
      ++v14;
      unint64_t v15 = *v4;
      if ((unsigned __int16)(v15 - 32) <= 0x5Eu) {
        break;
      }
      if (v10 == 2)
      {
        if ((v9 | (v15 >> 12)) > 0x3Eu) {
          char v17 = 44;
        }
        else {
          char v17 = aAbcdefghijklmn[(v9 | (v15 >> 12))];
        }
        *int v11 = v17;
        uint64_t v22 = v11 + 1;
        if ((unint64_t)(v11 + 1) >= v7)
        {
          if (v12) {
            *v12++ = v2++;
          }
          uint64_t v29 = (v15 >> 6) & 0x3F;
          if (v29 == 63) {
            char v30 = 44;
          }
          else {
            char v30 = aAbcdefghijklmn[v29];
          }
          *(unsigned char *)(v3 + 104) = v30;
          if ((v15 & 0x3F) == 0x3F) {
            char v36 = 44;
          }
          else {
            char v36 = aAbcdefghijklmn[v15 & 0x3F];
          }
          LOBYTE(v9) = 0;
          LOBYTE(v10) = 0;
          *(unsigned char *)(v3 + 105) = v36;
          *(unsigned char *)(v3 + 91) = 2;
        }
        else
        {
          uint64_t v23 = (v15 >> 6) & 0x3F;
          if (v23 == 63) {
            char v24 = 44;
          }
          else {
            char v24 = aAbcdefghijklmn[v23];
          }
          uint64_t v22 = v11 + 2;
          v11[1] = v24;
          if ((unint64_t)(v11 + 2) < v7)
          {
            if ((v15 & 0x3F) == 0x3F) {
              char v33 = 44;
            }
            else {
              char v33 = aAbcdefghijklmn[v15 & 0x3F];
            }
            char v19 = v11 + 3;
            v11[2] = v33;
            LOBYTE(v9) = 0;
            LOBYTE(v10) = 0;
            if (v12)
            {
              *int v12 = v2;
              v12[1] = v2;
              v12[2] = v2++;
              v12 += 3;
            }
            goto LABEL_84;
          }
          if (v12)
          {
            *int v12 = v2;
            v12[1] = v2;
            v12 += 2;
            ++v2;
          }
          if ((v15 & 0x3F) == 0x3F) {
            char v39 = 44;
          }
          else {
            char v39 = aAbcdefghijklmn[v15 & 0x3F];
          }
          LOBYTE(v9) = 0;
          LOBYTE(v10) = 0;
          *(unsigned char *)(v3 + 104) = v39;
          *(unsigned char *)(v3 + 91) = 1;
        }
        int v11 = v22;
        *a2 = 15;
      }
      else
      {
        if ((char)v10 == 1)
        {
          if ((v9 | (v15 >> 14)) > 0x3Eu) {
            char v18 = 44;
          }
          else {
            char v18 = aAbcdefghijklmn[(v9 | (v15 >> 14))];
          }
          *int v11 = v18;
          char v19 = v11 + 1;
          if ((unint64_t)(v11 + 1) >= v7)
          {
            if (v12) {
              *v12++ = v2++;
            }
            uint64_t v31 = (v15 >> 8) & 0x3F;
            if (v31 == 63) {
              char v32 = 44;
            }
            else {
              char v32 = aAbcdefghijklmn[v31];
            }
            *(unsigned char *)(v3 + 104) = v32;
            uint64_t v37 = v15 >> 2;
            if (v37 == 63) {
              char v38 = 44;
            }
            else {
              char v38 = aAbcdefghijklmn[v37];
            }
            *(unsigned char *)(v3 + 105) = v38;
            *(unsigned char *)(v3 + 91) = 2;
          }
          else
          {
            uint64_t v25 = (v15 >> 8) & 0x3F;
            if (v25 == 63) {
              char v26 = 44;
            }
            else {
              char v26 = aAbcdefghijklmn[v25];
            }
            char v19 = v11 + 2;
            v11[1] = v26;
            if ((unint64_t)(v11 + 2) < v7)
            {
              uint64_t v34 = v15 >> 2;
              if (v34 == 63) {
                char v35 = 44;
              }
              else {
                char v35 = aAbcdefghijklmn[v34];
              }
              char v19 = v11 + 3;
              v11[2] = v35;
              if (v12)
              {
                *int v12 = v2;
                v12[1] = v2;
                v12[2] = v2++;
                v12 += 3;
              }
              goto LABEL_83;
            }
            if (v12)
            {
              *int v12 = v2;
              v12[1] = v2;
              v12 += 2;
              ++v2;
            }
            uint64_t v40 = v15 >> 2;
            if (v40 == 63) {
              char v41 = 44;
            }
            else {
              char v41 = aAbcdefghijklmn[v40];
            }
            *(unsigned char *)(v3 + 104) = v41;
            *(unsigned char *)(v3 + 91) = 1;
          }
          *a2 = 15;
LABEL_83:
          LOBYTE(v9) = 16 * (v15 & 3);
          LOBYTE(v10) = 2;
LABEL_84:
          int v11 = v19;
          goto LABEL_85;
        }
        if (!(_BYTE)v10)
        {
          if ((v15 >> 10) == 63) {
            char v16 = 44;
          }
          else {
            char v16 = aAbcdefghijklmn[v15 >> 10];
          }
          *int v11 = v16;
          char v19 = v11 + 1;
          if ((unint64_t)(v11 + 1) >= v7)
          {
            if (v12) {
              *v12++ = v2++;
            }
            uint64_t v27 = (v15 >> 4) & 0x3F;
            if (v27 == 63) {
              char v28 = 44;
            }
            else {
              char v28 = aAbcdefghijklmn[v27];
            }
            *(unsigned char *)(v3 + 104) = v28;
            *(unsigned char *)(v3 + 91) = 1;
            *a2 = 15;
          }
          else
          {
            uint64_t v20 = (v15 >> 4) & 0x3F;
            if (v20 == 63) {
              char v21 = 44;
            }
            else {
              char v21 = aAbcdefghijklmn[v20];
            }
            char v19 = v11 + 2;
            v11[1] = v21;
            if (v12)
            {
              *int v12 = v2;
              v12[1] = v2;
              v12 += 2;
              ++v2;
            }
          }
          LOBYTE(v9) = 4 * (v15 & 0xF);
          LOBYTE(v10) = 1;
          goto LABEL_84;
        }
      }
LABEL_85:
      if ((unint64_t)v14 >= v6)
      {
        int v42 = 0;
        int v13 = 1;
        int v4 = v14;
        goto LABEL_131;
      }
    }
    if (!(_BYTE)v10) {
      goto LABEL_93;
    }
    char v44 = 44;
    if (v9 <= 0x3Eu) {
      char v44 = aAbcdefghijklmn[v9];
    }
    *v11++ = v44;
    if (!v12)
    {
      if ((unint64_t)v11 < v7)
      {
        unsigned int v8 = 0;
        *int v11 = 45;
        goto LABEL_99;
      }
      int v12 = 0;
      goto LABEL_161;
    }
    *v12++ = v2 - 1;
LABEL_93:
    if ((unint64_t)v11 >= v7)
    {
LABEL_161:
      int v43 = 0;
      *(unsigned char *)(v3 + 104) = 45;
      *(unsigned char *)(v3 + 91) = 1;
      int v42 = 0x1000000;
      goto LABEL_130;
    }
    *int v11 = 45;
    if (v12)
    {
      *int v12 = v2 - 1;
      unsigned int v8 = v12 + 1;
    }
    else
    {
      unsigned int v8 = 0;
    }
LABEL_99:
    unint64_t v5 = v11 + 1;
LABEL_100:
    if ((int)((v6 - (unint64_t)v4) >> 1) >= (int)v7 - (int)v5) {
      int v45 = v7 - v5;
    }
    else {
      int v45 = (v6 - (unint64_t)v4) >> 1;
    }
    if (v45 < 1)
    {
      int v11 = v5;
      goto LABEL_125;
    }
    unint64_t v46 = v6 - (void)v4 - 2;
    uint64_t v47 = v4;
    while (2)
    {
      int v49 = *v47++;
      int v48 = v49;
      int v11 = v5 + 1;
      if (v49 != 38 && (v48 - 32) <= 0x5E)
      {
        *unint64_t v5 = v48;
        if (v8) {
          *v8++ = v2++;
        }
        if (v45 < 2) {
          goto LABEL_119;
        }
        --v45;
LABEL_118:
        v46 -= 2;
        unint64_t v5 = v11;
        int v4 = v47;
        continue;
      }
      break;
    }
    *unint64_t v5 = 38;
    if (v48 != 38)
    {
      LOBYTE(v10) = 0;
      if (v8)
      {
        *unsigned int v8 = v2;
        int v12 = v8 + 1;
      }
      else
      {
        int v12 = 0;
      }
      continue;
    }
    break;
  }
  if ((unint64_t)v11 < v7)
  {
    v5[1] = 45;
    if (v8)
    {
      *unsigned int v8 = v2;
      v8[1] = v2;
      v8 += 2;
      ++v2;
    }
    int v11 = v5 + 2;
    int v45 = v7 - (v5 + 2);
    if ((int)(v46 >> 1) < v45) {
      int v45 = v46 >> 1;
    }
    if (v45 <= 0)
    {
LABEL_119:
      ++v4;
      goto LABEL_125;
    }
    goto LABEL_118;
  }
  ++v4;
  if (v8) {
    *v8++ = v2++;
  }
  *(unsigned char *)(v3 + 104) = 45;
  *(unsigned char *)(v3 + 91) = 1;
  *a2 = 15;
LABEL_125:
  int v43 = 0;
  int v13 = 0;
  int v42 = 0x1000000;
  BOOL v50 = (unint64_t)v4 < v6 && (unint64_t)v11 >= v7;
  int v12 = v8;
  if (v50)
  {
LABEL_130:
    *a2 = 15;
    int v13 = v43;
  }
LABEL_131:
  if (*(unsigned char *)(result + 2)) {
    BOOL v51 = (unint64_t)v4 >= v6;
  }
  else {
    BOOL v51 = 0;
  }
  if (v51)
  {
    if (v13)
    {
      if (!(_BYTE)v10) {
        goto LABEL_149;
      }
      if ((unint64_t)v11 >= v7)
      {
        if (v9 > 0x3Eu) {
          char v54 = 44;
        }
        else {
          char v54 = aAbcdefghijklmn[v9];
        }
        uint64_t v55 = *(char *)(v3 + 91);
        *(unsigned char *)(v3 + 91) = v55 + 1;
        *(unsigned char *)(v3 + v55 + 104) = v54;
        *a2 = 15;
LABEL_149:
        if ((unint64_t)v11 < v7)
        {
          *v11++ = 45;
          if (v12) {
            *v12++ = v2 - 1;
          }
          goto LABEL_158;
        }
        goto LABEL_157;
      }
      if (v9 > 0x3Eu) {
        char v53 = 44;
      }
      else {
        char v53 = aAbcdefghijklmn[v9];
      }
      *int v11 = v53;
      if (v12)
      {
        *v12++ = v2 - 1;
        ++v11;
        goto LABEL_149;
      }
      if ((unint64_t)(v11 + 1) >= v7)
      {
        int v12 = 0;
        ++v11;
LABEL_157:
        uint64_t v56 = *(char *)(v3 + 91);
        *(unsigned char *)(v3 + 91) = v56 + 1;
        *(unsigned char *)(v3 + v56 + 104) = 45;
        *a2 = 15;
        goto LABEL_158;
      }
      int v12 = 0;
      v11[1] = 45;
      v11 += 2;
    }
LABEL_158:
    unsigned int v52 = *(_DWORD *)(v3 + 80) & 0xF0000000 | 0x1000000;
    goto LABEL_159;
  }
  unsigned int v52 = v42 | v9 | ((char)v10 << 16) | *(_DWORD *)(v3 + 80) & 0xF0000000;
LABEL_159:
  *(_DWORD *)(v3 + 80) = v52;
  *(void *)(result + 16) = v4;
  *(void *)(result + 32) = v11;
  *(void *)(result + 48) = v12;
  return result;
}

void *sub_18C866BA4(void *result, int *a2)
{
  uint64_t v3 = result[1];
  int v2 = (unsigned __int16 *)result[2];
  unint64_t v5 = result[3];
  int v4 = (char *)result[4];
  unint64_t v6 = result[5];
  int v21 = 0;
  unint64_t v7 = *(void **)(v3 + 48);
  unsigned int v8 = *(_DWORD *)(v3 + 84);
  if (v8) {
    BOOL v9 = (unint64_t)v4 >= v6;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    goto LABEL_13;
  }
  *(_DWORD *)(v3 + 84) = 0;
LABEL_23:
  if ((unint64_t)v2 >= v5)
  {
    *(_DWORD *)(v3 + 84) = v8;
  }
  else if ((v8 & 0x400) != 0 || (int v13 = *v2, (v13 & 0xFC00) != 0xDC00))
  {
    *(_DWORD *)(v3 + 84) = v8;
    *a2 = 12;
  }
  else
  {
    unsigned int v8 = v13 + (v8 << 10) - 56613888;
    ++v2;
LABEL_27:
    if ((uint64_t)(v6 - (void)v4) <= 3) {
      int v14 = (char *)&v21;
    }
    else {
      int v14 = v4;
    }
    if ((int)v8 >= 0x10000)
    {
      unsigned int v15 = (v8 >> 18) | 0xFFFFFFF0;
      if ((uint64_t)(v6 - (void)v4) <= 3) {
        char v17 = &v21;
      }
      else {
        char v17 = (int *)v4;
      }
      *((unsigned char *)v17 + 1) = (v8 >> 12) & 0x3F | 0x80;
      unsigned int v16 = 3;
    }
    else
    {
      unsigned int v15 = (v8 >> 12) | 0xFFFFFFE0;
      unsigned int v16 = 2;
    }
    *int v14 = v15;
    v14[v16 - 1] = (v8 >> 6) & 0x3F | 0x80;
    v14[v16] = v8 & 0x3F | 0x80;
    if (v14 == v4)
    {
      v4 += v16 + 1;
    }
    else
    {
      for (unint64_t i = (unint64_t)&v21 | v16; (unint64_t)v14 <= i; ++v14)
      {
        char v19 = *v14;
        if ((unint64_t)v4 >= v6)
        {
          uint64_t v20 = *(char *)(v3 + 91);
          *(unsigned char *)(v3 + 91) = v20 + 1;
          *(unsigned char *)(v3 + v20 + 104) = v19;
          *a2 = 15;
        }
        else
        {
          *v4++ = v19;
        }
      }
    }
LABEL_13:
    while ((unint64_t)v2 < v5 && (unint64_t)v4 < v6)
    {
      unsigned int v10 = *v2++;
      unsigned int v8 = v10;
      if (v10 > 0x7F)
      {
        if (v8 > 0x7FF)
        {
          if ((v8 & 0xF800) != 0xD800 || v7 == &unk_1E5502D80) {
            goto LABEL_27;
          }
          goto LABEL_23;
        }
        *int v4 = (v8 >> 6) | 0xC0;
        char v11 = v8 & 0x3F | 0x80;
        if ((unint64_t)(v4 + 1) >= v6)
        {
          *(unsigned char *)(v3 + 104) = v11;
          *(unsigned char *)(v3 + 91) = 1;
          *a2 = 15;
          ++v4;
        }
        else
        {
          v4[1] = v11;
          v4 += 2;
        }
      }
      else
      {
        *v4++ = v8;
      }
    }
  }
  if ((unint64_t)v2 < v5 && (unint64_t)v4 >= v6 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v4;
  result[2] = v2;
  return result;
}

void *sub_18C866DB0(void *result, int *a2)
{
  uint64_t v3 = result[1];
  int v2 = (unsigned __int16 *)result[2];
  unint64_t v4 = result[3];
  unint64_t v5 = (char *)result[4];
  unint64_t v6 = result[5];
  unint64_t v7 = (int *)result[6];
  int v23 = 0;
  unsigned int v8 = *(void **)(v3 + 48);
  unsigned int v9 = *(_DWORD *)(v3 + 84);
  if (v9) {
    BOOL v10 = (unint64_t)v5 >= v6;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    int v12 = 0;
    goto LABEL_7;
  }
  int v11 = 0;
  *(_DWORD *)(v3 + 84) = 0;
  int v12 = -1;
LABEL_19:
  if ((unint64_t)v2 >= v4)
  {
    *(_DWORD *)(v3 + 84) = v9;
  }
  else if ((v9 & 0x400) != 0 || (int v15 = *v2, (v15 & 0xFC00) != 0xDC00))
  {
    *(_DWORD *)(v3 + 84) = v9;
    *a2 = 12;
  }
  else
  {
    unsigned int v9 = v15 + (v9 << 10) - 56613888;
    ++v2;
    ++v11;
LABEL_23:
    if ((uint64_t)(v6 - (void)v5) <= 3) {
      unsigned int v16 = (char *)&v23;
    }
    else {
      unsigned int v16 = v5;
    }
    if ((int)v9 < 0x10000)
    {
      unsigned int v17 = (v9 >> 12) | 0xFFFFFFE0;
      unsigned int v19 = 2;
    }
    else
    {
      unsigned int v17 = (v9 >> 18) | 0xFFFFFFF0;
      if ((uint64_t)(v6 - (void)v5) <= 3) {
        char v18 = &v23;
      }
      else {
        char v18 = (int *)v5;
      }
      *((unsigned char *)v18 + 1) = (v9 >> 12) & 0x3F | 0x80;
      unsigned int v19 = 3;
    }
    *unsigned int v16 = v17;
    v16[v19 - 1] = (v9 >> 6) & 0x3F | 0x80;
    v16[v19] = v9 & 0x3F | 0x80;
    if (v16 == v5)
    {
      uint64_t v22 = v19 + 1;
      v5 += v22;
      *unint64_t v7 = v12;
      v7[1] = v12;
      _DWORD v7[2] = v12;
      if ((int)v9 >= 0x10000) {
        v7[3] = v12;
      }
      v7 += v22;
    }
    else
    {
      for (; (unint64_t)v16 <= ((unint64_t)&v23 | v19); ++v16)
      {
        if ((unint64_t)v5 >= v6)
        {
          char v20 = *v16;
          uint64_t v21 = *(char *)(v3 + 91);
          *(unsigned char *)(v3 + 91) = v21 + 1;
          *(unsigned char *)(v3 + v21 + 104) = v20;
          *a2 = 15;
        }
        else
        {
          *v7++ = v12;
          *v5++ = *v16;
        }
      }
    }
    int v12 = v11;
LABEL_7:
    while ((unint64_t)v2 < v4 && (unint64_t)v5 < v6)
    {
      unsigned int v13 = *v2++;
      unsigned int v9 = v13;
      if (v13 > 0x7F)
      {
        if (v9 > 0x7FF)
        {
          int v11 = v12 + 1;
          if ((v9 & 0xF800) != 0xD800 || v8 == &unk_1E5502D80) {
            goto LABEL_23;
          }
          goto LABEL_19;
        }
        *unint64_t v7 = v12;
        *unint64_t v5 = (v9 >> 6) | 0xC0;
        if ((unint64_t)(v5 + 1) >= v6)
        {
          *(unsigned char *)(v3 + 104) = v9 & 0x3F | 0x80;
          *(unsigned char *)(v3 + 91) = 1;
          *a2 = 15;
          ++v7;
          ++v5;
        }
        else
        {
          v7[1] = v12++;
          v7 += 2;
          v5[1] = v9 & 0x3F | 0x80;
          v5 += 2;
        }
      }
      else
      {
        *v7++ = v12++;
        *v5++ = v9;
      }
    }
  }
  if ((unint64_t)v2 < v4 && (unint64_t)v5 >= v6 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v5;
  result[2] = v2;
  result[6] = v7;
  return result;
}

void *sub_18C867024(void *result, int *a2)
{
  uint64_t v3 = result[1];
  int v2 = (char *)result[2];
  unint64_t v5 = result[3];
  unint64_t v4 = (_WORD *)result[4];
  unint64_t v6 = result[5];
  unint64_t v7 = *(void **)(v3 + 48);
  if (*(char *)(v3 + 64) < 1 || (unint64_t)v4 >= v6)
  {
    while (1)
    {
LABEL_7:
      if ((unint64_t)v2 >= v5 || (unint64_t)v4 >= v6) {
        goto LABEL_36;
      }
      unsigned int v10 = *v2;
      if (*v2 < 0) {
        break;
      }
      *v4++ = v10;
      ++v2;
    }
    *(unsigned char *)(v3 + 65) = v10;
    ++v2;
    if (v10 <= 0xEF) {
      int v12 = 2;
    }
    else {
      int v12 = 3;
    }
    if (v10 > 0xDF) {
      ++v12;
    }
    int v9 = 1;
    if ((v10 + 62) <= 0x32u) {
      int v11 = v12;
    }
    else {
      int v11 = 0;
    }
  }
  else
  {
    int v9 = *(unsigned __int8 *)(v3 + 64);
    *(unsigned char *)(v3 + 64) = 0;
    unsigned int v10 = *(_DWORD *)(v3 + 72);
    int v11 = *(_DWORD *)(v3 + 76);
    *(_DWORD *)(v3 + 72) = 0;
  }
  if (v9 < v11)
  {
    uint64_t v13 = 0;
    uint64_t v14 = v9;
    uint64_t v15 = v3 + v9 + 65;
    int v16 = v9 - v11;
    while (1)
    {
      if ((unint64_t)&v2[v13] >= v5)
      {
        *(_DWORD *)(v3 + 72) = v10;
        *(_DWORD *)(v3 + 76) = v11;
        *(unsigned char *)(v3 + 64) = v14 + v13;
        v2 += v13;
        goto LABEL_36;
      }
      unint64_t v17 = v14 + v13;
      unint64_t v18 = v2[v13];
      *(unsigned char *)(v15 + v13) = v18;
      if (v11 < 3 || v17 >= 2)
      {
        if ((char)v18 < -64) {
          goto LABEL_33;
        }
      }
      else
      {
        if (v11 == 3)
        {
          int v19 = a00000000000000[v10 & 0xF];
          int v20 = 1 << (v18 >> 5);
        }
        else
        {
          int v19 = byte_18CA80A64[v18 >> 4];
          int v20 = 1 << (v10 & 7);
        }
        if ((v19 & v20) != 0) {
          goto LABEL_33;
        }
      }
      if (v7 != &unk_1E5502D80 || v17 != 1 || v10 != 237 || (char)v18 > -65)
      {
        int v9 = v14 + v13;
        v2 += v13;
        break;
      }
LABEL_33:
      unsigned int v10 = v18 + (v10 << 6);
      if (!(v16 + ++v13))
      {
        v2 += v13;
        int v9 = v11;
        break;
      }
    }
  }
  BOOL v22 = v7 == &unk_1E5502D80 && v9 > 3;
  if (v9 != v11 || v22)
  {
    *(unsigned char *)(v3 + 64) = v9;
    *a2 = 12;
  }
  else
  {
    unsigned int v23 = v10 - dword_18CA80A50[v11];
    if (!HIWORD(v23))
    {
      *v4++ = v23;
      goto LABEL_7;
    }
    *unint64_t v4 = (v23 >> 10) - 10304;
    __int16 v24 = v23 & 0x3FF | 0xDC00;
    if ((unint64_t)(v4 + 1) < v6)
    {
      v4[1] = v24;
      v4 += 2;
      goto LABEL_7;
    }
    *(_WORD *)(v3 + 144) = v24;
    *(unsigned char *)(v3 + 93) = 1;
    *a2 = 15;
    ++v4;
  }
LABEL_36:
  if ((unint64_t)v2 < v5 && (unint64_t)v4 >= v6 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v4;
  result[2] = v2;
  return result;
}

void *sub_18C867294(void *result, int *a2)
{
  uint64_t v3 = result[1];
  int v2 = (char *)result[2];
  unint64_t v5 = result[3];
  unint64_t v4 = (_WORD *)result[4];
  unint64_t v7 = result[5];
  unint64_t v6 = (_DWORD *)result[6];
  unsigned int v8 = *(void **)(v3 + 48);
  int v9 = 0;
  if (*(char *)(v3 + 64) < 1 || (unint64_t)v4 >= v7) {
    goto LABEL_6;
  }
  int v11 = *(unsigned __int8 *)(v3 + 64);
  *(unsigned char *)(v3 + 64) = 0;
  unsigned int v13 = *(_DWORD *)(v3 + 72);
  int v12 = *(_DWORD *)(v3 + 76);
  *(_DWORD *)(v3 + 72) = 0;
LABEL_18:
  if (v11 < v12)
  {
    uint64_t v15 = 0;
    uint64_t v16 = v11;
    uint64_t v17 = v3 + v11 + 65;
    int v18 = v11 - v12;
    while (1)
    {
      if ((unint64_t)&v2[v15] >= v5)
      {
        *(_DWORD *)(v3 + 72) = v13;
        *(_DWORD *)(v3 + 76) = v12;
        *(unsigned char *)(v3 + 64) = v16 + v15;
        v2 += v15;
        goto LABEL_36;
      }
      unint64_t v19 = v16 + v15;
      unint64_t v20 = v2[v15];
      *(unsigned char *)(v17 + v15) = v20;
      if (v12 < 3 || v19 >= 2)
      {
        if ((char)v20 < -64) {
          goto LABEL_33;
        }
      }
      else
      {
        if (v12 == 3)
        {
          int v21 = a00000000000000[v13 & 0xF];
          int v22 = 1 << (v20 >> 5);
        }
        else
        {
          int v21 = byte_18CA80A64[v20 >> 4];
          int v22 = 1 << (v13 & 7);
        }
        if ((v21 & v22) != 0) {
          goto LABEL_33;
        }
      }
      if (v8 != &unk_1E5502D80 || v19 != 1 || v13 != 237 || (char)v20 > -65)
      {
        int v11 = v16 + v15;
        v2 += v15;
        break;
      }
LABEL_33:
      unsigned int v13 = v20 + (v13 << 6);
      if (!(v18 + ++v15))
      {
        v2 += v15;
        int v11 = v12;
        break;
      }
    }
  }
  BOOL v24 = v8 == &unk_1E5502D80 && v11 > 3;
  if (v11 != v12 || v24)
  {
    *(unsigned char *)(v3 + 64) = v11;
    *a2 = 12;
  }
  else
  {
    unsigned int v25 = v13 - dword_18CA80A50[v12];
    if (HIWORD(v25))
    {
      *unint64_t v4 = (v25 >> 10) - 10304;
      *unint64_t v6 = v9;
      __int16 v26 = v25 & 0x3FF | 0xDC00;
      if ((unint64_t)(v4 + 1) >= v7)
      {
        *(_WORD *)(v3 + 144) = v26;
        *(unsigned char *)(v3 + 93) = 1;
        *a2 = 15;
        ++v4;
        ++v6;
      }
      else
      {
        v4[1] = v26;
        v4 += 2;
        v6[1] = v9;
        v6 += 2;
      }
    }
    else
    {
      *v4++ = v25;
      *v6++ = v9;
    }
    v9 += v12;
LABEL_6:
    while ((unint64_t)v2 < v5 && (unint64_t)v4 < v7)
    {
      unsigned int v13 = *v2;
      if (*v2 < 0)
      {
        *(unsigned char *)(v3 + 65) = v13;
        ++v2;
        if (v13 <= 0xEF) {
          int v14 = 2;
        }
        else {
          int v14 = 3;
        }
        if (v13 > 0xDF) {
          ++v14;
        }
        int v11 = 1;
        if ((v13 + 62) <= 0x32u) {
          int v12 = v14;
        }
        else {
          int v12 = 0;
        }
        goto LABEL_18;
      }
      *v4++ = v13;
      *v6++ = v9++;
      ++v2;
    }
  }
LABEL_36:
  if ((unint64_t)v2 < v5 && (unint64_t)v4 >= v7 && *a2 <= 0) {
    *a2 = 15;
  }
  result[4] = v4;
  result[2] = v2;
  result[6] = v6;
  return result;
}

uint64_t sub_18C86753C(void *a1, int *a2)
{
  int v2 = (char *)a1[2];
  unint64_t v3 = a1[3];
  if ((unint64_t)v2 >= v3)
  {
    int v6 = 8;
LABEL_5:
    *a2 = v6;
    return 0xFFFFLL;
  }
  unint64_t v4 = v2 + 1;
  uint64_t v5 = *v2;
  if ((*v2 & 0x80000000) == 0)
  {
    a1[2] = v4;
    return v5;
  }
  uint64_t v7 = a1[1];
  if ((v5 + 62) > 0x32u)
  {
    *(unsigned char *)(v7 + 65) = v5;
    *(unsigned char *)(v7 + 64) = 1;
    *a2 = 12;
    goto LABEL_41;
  }
  char v8 = *v2;
  int v9 = v5 > 0xEF;
  if (v5 > 0xDF) {
    ++v9;
  }
  if ((unint64_t)&v4[v9 + 1] <= v3)
  {
    int v15 = v5 << 6;
    if (v9)
    {
      if (v9 == 1)
      {
        int v16 = *v4;
        if ((a00000000000000[v8 & 0xF] >> (*v4 >> 5)))
        {
          unint64_t v4 = v2 + 2;
          int v17 = v2[2];
          if (v17 <= -65)
          {
            a1[2] = v2 + 3;
            return v17 + ((v15 + v16) << 6) - 925824;
          }
        }
        goto LABEL_36;
      }
      unint64_t v21 = *v4;
      if ((byte_18CA80A64[v21 >> 4] >> (v5 & 7)))
      {
        unint64_t v4 = v2 + 2;
        int v22 = v2[2];
        if (v22 <= -65)
        {
          unint64_t v4 = v2 + 3;
          int v23 = v2[3];
          if (v23 <= -65)
          {
            a1[2] = v2 + 4;
            int v19 = ((v15 + v21) << 12) + (v22 << 6);
            int v20 = v23 - 63447168;
            return (v19 + v20);
          }
        }
      }
    }
    else
    {
      int v18 = *v4;
      if (v18 <= -65)
      {
        a1[2] = v2 + 2;
        int v19 = v15 + v18;
        int v20 = -12416;
        return (v19 + v20);
      }
    }
LABEL_36:
    char v24 = 0;
    a1[2] = v4;
    do
    {
      char v25 = *v2++;
      *(unsigned char *)(v7 + v24++ + 65) = v25;
    }
    while (v2 < v4);
    *(unsigned char *)(v7 + 64) = v24;
    int v6 = 12;
    goto LABEL_5;
  }
  *(unsigned char *)(v7 + 65) = v5;
  *a2 = 11;
  if ((unint64_t)v4 >= a1[3])
  {
    char v14 = 1;
    goto LABEL_40;
  }
  int v10 = 1 << (v5 & 7);
  char v11 = 1;
  while (1)
  {
    unint64_t v12 = *v4;
    unsigned __int8 v13 = *v4;
    if (v9)
    {
      if (v11 < 2) {
        break;
      }
    }
    if ((char)v12 >= -64) {
      goto LABEL_39;
    }
LABEL_20:
    char v14 = v11 + 1;
    *(unsigned char *)(v7 + v11 + 65) = v13;
    ++v4;
    ++v11;
    if ((unint64_t)v4 >= a1[3]) {
      goto LABEL_40;
    }
  }
  if (v9 == 1)
  {
    if ((a00000000000000[v8 & 0xF] & (1 << (v13 >> 5))) == 0) {
      goto LABEL_39;
    }
    goto LABEL_20;
  }
  if ((byte_18CA80A64[v12 >> 4] & v10) != 0) {
    goto LABEL_20;
  }
LABEL_39:
  *a2 = 12;
  char v14 = v11;
LABEL_40:
  *(unsigned char *)(v7 + 64) = v14;
LABEL_41:
  a1[2] = v4;
  return 0xFFFFLL;
}

uint64_t sub_18C8677BC(uint64_t result, void *a2, int *a3)
{
  uint64_t v3 = a2[1];
  unint64_t v4 = (unsigned __int8 *)a2[2];
  uint64_t v5 = (unsigned __int8 *)a2[3];
  int v6 = *(char *)(v3 + 64);
  if (v6 < 1)
  {
    int v6 = 0;
    LOBYTE(v8) = 0;
    unsigned int v7 = 0;
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(v3 + 72);
    int v8 = *(_DWORD *)(v3 + 76);
  }
  int v9 = *(unsigned char **)(result + 32);
  int v10 = v5 - v4 + v6;
  if (v10 >= (char)v8)
  {
    int v11 = *(_DWORD *)(result + 40) - v9;
    if (v11 < (char)v8)
    {
      int v12 = -127;
LABEL_33:
      *a3 = v12;
      return result;
    }
    if (v10 >= v11) {
      int v10 = *(_DWORD *)(result + 40) - v9;
    }
    int v13 = v10 - v6;
    unsigned int v14 = v13 - 1;
    if (v13 >= 1)
    {
      int v15 = (char)v4[v14];
      if (v15 < 0)
      {
        unint64_t v18 = v4[v14];
        if ((v15 + 62) < 0x33u) {
          goto LABEL_12;
        }
        unsigned int v19 = v4[v14];
        if (v19 <= 0xBF)
        {
          unsigned int v14 = v13 - 2;
          if (v13 < 2)
          {
            unsigned int v14 = 1;
            goto LABEL_12;
          }
          unint64_t v20 = v4[v14];
          if ((v20 + 32) <= 0x14u)
          {
            BOOL v21 = v20 > 0xEF;
            int v22 = &byte_18CA80A64[v18 >> 4];
            char v23 = v20 & 7;
            char v24 = &a00000000000000[v20 & 0xF];
            unsigned int v25 = v19 >> 5;
            if (v21)
            {
              LOBYTE(v25) = v23;
              char v24 = (char *)v22;
            }
            if (((*v24 >> v25) & 1) == 0) {
              unsigned int v14 = v13;
            }
            goto LABEL_12;
          }
          if ((char)v20 <= -65)
          {
            if (v13 < 3)
            {
              unsigned int v14 = 2;
            }
            else
            {
              unsigned __int8 v26 = v4[v13 - 3];
              unsigned int v14 = v13;
              if ((v26 + 16) <= 4u)
              {
                if ((byte_18CA80A64[v20 >> 4] >> (v26 & 7))) {
                  unsigned int v14 = v13 - 3;
                }
                else {
                  unsigned int v14 = v13;
                }
              }
            }
            goto LABEL_12;
          }
        }
      }
    }
    unsigned int v14 = v13;
LABEL_12:
    int v10 = v14 + v6;
  }
  if (v7)
  {
    *(_DWORD *)(v3 + 72) = 0;
    *(unsigned char *)(v3 + 64) = 0;
    int v16 = v6;
    goto LABEL_63;
  }
  int v17 = (unsigned __int8 *)a2[2];
  while (2)
  {
    if (v10 < 1)
    {
      unint64_t v4 = v17;
LABEL_48:
      if (*a3 <= 0 && v4 < v5)
      {
        if (v9 == *(unsigned char **)(result + 40))
        {
          int v38 = 15;
        }
        else
        {
          unsigned int v36 = *v4;
          if ((char)*v4 < 0)
          {
            if (v36 <= 0xEF) {
              char v55 = 2;
            }
            else {
              char v55 = 3;
            }
            if (v36 > 0xDF) {
              ++v55;
            }
            if ((v36 + 62) <= 0x32u) {
              unsigned __int8 v37 = v55;
            }
            else {
              unsigned __int8 v37 = 0;
            }
          }
          else
          {
            unsigned __int8 v37 = 1;
          }
          if (v5 - v4 >= v37)
          {
            int v38 = -127;
          }
          else
          {
            *(unsigned char *)(v3 + 65) = v36;
            if (++v4 == v5)
            {
              char v62 = 1;
LABEL_121:
              *(unsigned char *)(v3 + 64) = v62;
              *(_DWORD *)(v3 + 72) = v36;
              *(_DWORD *)(v3 + 76) = v37;
              goto LABEL_125;
            }
            char v56 = 1;
            while (1)
            {
              unint64_t v57 = *v4;
              unsigned __int8 v58 = *v4;
              if (v37 < 3u || v56 >= 2)
              {
                int v61 = (char)v57 < -64;
              }
              else
              {
                if (v37 == 3)
                {
                  int v59 = a00000000000000[v36 & 0xF];
                  char v60 = v58 >> 5;
                }
                else
                {
                  int v59 = byte_18CA80A64[v57 >> 4];
                  char v60 = v36 & 7;
                }
                int v61 = v59 & (1 << v60);
              }
              if (!v61) {
                break;
              }
              unsigned int v36 = v57 + (v36 << 6);
              char v62 = v56 + 1;
              *(unsigned char *)(v3 + v56 + 65) = v58;
              ++v4;
              ++v56;
              if (v4 == v5) {
                goto LABEL_121;
              }
            }
            *(unsigned char *)(v3 + 64) = v56;
            int v38 = 12;
          }
        }
        *a3 = v38;
      }
      uint64_t v5 = v4;
      goto LABEL_125;
    }
    unint64_t v4 = v17;
    while (1)
    {
      int v28 = (char)*v4++;
      char v27 = v28;
      unsigned int v7 = v28;
      if ((v28 & 0x80000000) == 0)
      {
        *v9++ = v7;
        int v29 = -1;
        goto LABEL_46;
      }
      if (v7 >= 0xE0) {
        break;
      }
      if (v7 < 0xC2) {
        goto LABEL_91;
      }
      int v33 = (char)*v4;
      if (v33 > -65) {
        goto LABEL_57;
      }
      unint64_t v4 = v17 + 2;
      *int v9 = v7;
      v9[1] = v33;
      v9 += 2;
      int v29 = -2;
LABEL_46:
      int v17 = v4;
      BOOL v34 = __OFADD__(v10, v29);
      v10 += v29;
      if ((v10 < 0) ^ v34 | (v10 == 0)) {
        goto LABEL_48;
      }
    }
    if (v7 <= 0xEF)
    {
      unsigned int v30 = a00000000000000[v27 & 0xF];
      unsigned __int8 v31 = *v4;
      if (((v30 >> (*v4 >> 5)) & 1) == 0) {
        goto LABEL_57;
      }
      int v32 = (char)v17[2];
      if (v32 > -65) {
        goto LABEL_57;
      }
      unint64_t v4 = v17 + 3;
      *int v9 = v7;
      v9[1] = v31;
      v9[2] = v32;
      v9 += 3;
      int v29 = -3;
      goto LABEL_46;
    }
    if ((v7 + 62) > 0x32u)
    {
LABEL_91:
      LOBYTE(v6) = 0;
      LOBYTE(v16) = 1;
      goto LABEL_92;
    }
LABEL_57:
    int v6 = 0;
    if (v7 <= 0xEF) {
      LOBYTE(v8) = 2;
    }
    else {
      LOBYTE(v8) = 3;
    }
    if (v7 > 0xDF) {
      LOBYTE(v8) = v8 + 1;
    }
    int v16 = 1;
LABEL_63:
    if (v16 >= (char)v8)
    {
LABEL_80:
      int v39 = (char)v16;
      if (v16 == v8)
      {
        char v41 = v4;
LABEL_82:
        if (v6 < 1)
        {
          int v50 = 0;
        }
        else
        {
          uint64_t v47 = v6;
          int v48 = (char *)(v3 + 65);
          do
          {
            char v49 = *v48++;
            *v9++ = v49;
            --v47;
          }
          while (v47);
          int v50 = v6;
        }
        int v17 = &v41[v6 - v39];
        while (v50 < (char)v8)
        {
          char v51 = *v17++;
          *v9++ = v51;
          int v50 = (char)(v50 + 1);
        }
        v10 -= v39;
        continue;
      }
      int v17 = &v4[v6 - (char)v16];
      if (v6 < (char)v16)
      {
LABEL_92:
        unsigned int v52 = (unsigned char *)(v3 + v6 + 65);
        unint64_t v53 = v16 - (unint64_t)v6;
        do
        {
          char v54 = *v17++;
          *v52++ = v54;
          --v53;
        }
        while (v53);
      }
      *(unsigned char *)(v3 + 64) = v16;
      a2[2] = v17;
      *(void *)(result + 32) = v9;
      int v12 = 12;
      goto LABEL_33;
    }
    break;
  }
  int v39 = (char)v8;
  LOBYTE(v40) = v16;
  char v41 = v4;
  while (v41 < v5)
  {
    unint64_t v42 = *v41;
    if ((char)v8 < 3 || v40 >= 2u)
    {
      if ((char)v42 >= -64) {
        goto LABEL_79;
      }
    }
    else
    {
      if (v8 == 3)
      {
        int v43 = a00000000000000[v7 & 0xF];
        unsigned int v44 = v42 >> 5;
      }
      else
      {
        int v43 = byte_18CA80A64[v42 >> 4];
        LOBYTE(v44) = v7 & 7;
      }
      if ((v43 & (1 << v44)) == 0)
      {
LABEL_79:
        LOBYTE(v16) = v40;
        unint64_t v4 = v41;
        goto LABEL_80;
      }
    }
    int v40 = (char)(v40 + 1);
    ++v41;
    unsigned int v7 = v42 + (v7 << 6);
    if (v40 >= (char)v8) {
      goto LABEL_82;
    }
  }
  unint64_t v45 = v6;
  if (v6 >= (char)v40)
  {
    uint64_t v5 = &v41[v6 - (uint64_t)(char)v40];
  }
  else
  {
    do
    {
      unint64_t v46 = v45 + 1;
      *(unsigned char *)(v3 + 65 + v45) = v4[v45 - v16];
      unint64_t v45 = v46;
    }
    while (v46 < (char)v40);
    uint64_t v5 = &v4[v46 - v16];
  }
  *(unsigned char *)(v3 + 64) = v40;
  *(_DWORD *)(v3 + 72) = v7;
  *(_DWORD *)(v3 + 76) = (char)v8;
LABEL_125:
  a2[2] = v5;
  *(void *)(result + 32) = v9;
  return result;
}

void *sub_18C867D4C(void *result, _DWORD *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = (unsigned char *)result[2];
  unint64_t v5 = result[3];
  unint64_t v4 = (_WORD *)result[4];
  unint64_t v6 = result[5];
  int v7 = *(_DWORD *)(v2 + 76);
  if (*(_DWORD *)(v2 + 72)) {
    unsigned int v8 = *(_DWORD *)(v2 + 72);
  }
  else {
    unsigned int v8 = 64;
  }
  LODWORD(v9) = *(_DWORD *)(v2 + 76) & 3;
  int v10 = *(char *)(v2 + 64);
  int v11 = (unsigned char *)(v2 + 65);
  if ((v7 & 3) == 0 || v10 < 1 || (unint64_t)v4 >= v6)
  {
    uint64_t v14 = result[5];
LABEL_13:
    int v15 = v5 - v3;
    unint64_t v9 = (unint64_t)(v14 - (void)v4) >> 1;
    if ((int)v9 >= (int)v5 - (int)v3) {
      LODWORD(v9) = v5 - v3;
    }
    if ((int)v9 >= 1)
    {
      do
      {
        unsigned int v16 = *v3;
        if (((v16 - 80) & 0x80) != 0)
        {
          if (v16 > 0x20) {
            goto LABEL_26;
          }
          if (v16 != 32) {
            unsigned int v8 = 64;
          }
          *unint64_t v4 = v16;
        }
        else
        {
          int v17 = v8 + v16 - 144;
          if (v17 >= 12288) {
            goto LABEL_26;
          }
          *unint64_t v4 = v17;
          unsigned int v8 = v17 & 0xFFFFFF80 | 0x40;
        }
        ++v4;
        ++v3;
        BOOL v18 = __OFSUB__(v9, 1);
        LODWORD(v9) = v9 - 1;
      }
      while (!(((v9 & 0x80000000) != 0) ^ v18 | (v9 == 0)));
      LODWORD(v9) = 0;
    }
    goto LABEL_26;
  }
LABEL_75:
  int v15 = v7 >> 2;
  while ((unint64_t)v3 < v5)
  {
    unsigned int v36 = *v3++;
    uint64_t v35 = v36;
    v11[(char)v10] = v36;
    if (v36 > 0x20uLL) {
      int v37 = v35 - 13;
    }
    else {
      int v37 = byte_18CA80ADC[v35];
    }
    LOBYTE(v10) = v10 + 1;
    int v38 = 59049 * v37;
    if (v9 == 2) {
      int v38 = 243 * v37;
    }
    if (v9 != 1) {
      int v37 = v38;
    }
    if (v37 < 0) {
      goto LABEL_106;
    }
    v15 += v37;
    LODWORD(v9) = v9 - 1;
    if (!v9)
    {
      unsigned int v25 = v15 + v8;
      if (v15 + v8 > 0x10FFFF)
      {
        LOBYTE(v10) = 0;
LABEL_106:
        char v27 = v3;
LABEL_107:
        *a2 = 12;
        uint64_t v3 = v27;
        goto LABEL_108;
      }
      LODWORD(v9) = 0;
      LOBYTE(v10) = 0;
LABEL_91:
      if (v25 - 55204 >= 0xFFFF589C)
      {
        if (v25 >> 10 <= 0x2A) {
          unsigned int v40 = v25 & 0xFFFFFF80 | 0x40;
        }
        else {
          unsigned int v40 = 49617;
        }
        if (v25 - 19968 >= 0x51A6) {
          int v41 = v40;
        }
        else {
          int v41 = 30481;
        }
        if (v25 >> 5 >= 0x185) {
          unsigned int v8 = v41;
        }
        else {
          unsigned int v8 = 12400;
        }
      }
      else
      {
        unsigned int v8 = v25 & 0xFFFFFF80 | 0x40;
        if (HIWORD(v25))
        {
          *unint64_t v4 = (v25 >> 10) - 10304;
          __int16 v39 = v25 & 0x3FF | 0xDC00;
          if ((unint64_t)(v4 + 1) < v6)
          {
            v4[1] = v39;
            v4 += 2;
            goto LABEL_26;
          }
          *(_WORD *)(v2 + 144) = v39;
          *(unsigned char *)(v2 + 93) = 1;
          ++v4;
LABEL_47:
          *a2 = 15;
LABEL_48:
          *(_DWORD *)(v2 + 72) = v8;
          int v24 = v9 | (4 * v15);
          goto LABEL_109;
        }
      }
      *v4++ = v25;
LABEL_26:
      unsigned int v19 = v3;
      int v20 = v8;
LABEL_27:
      uint64_t v3 = v19 + 1;
      int v21 = v20;
      do
      {
        unsigned int v8 = v21;
        if ((unint64_t)(v3 - 1) >= v5)
        {
          --v3;
          goto LABEL_44;
        }
        if ((unint64_t)v4 >= v6)
        {
          unsigned int v8 = v20;
          uint64_t v3 = v19;
          goto LABEL_47;
        }
        unsigned int v22 = *(v3 - 1);
        if (((v22 - 80) & 0x80) == 0)
        {
          unsigned int v25 = v21 + v22 - 144;
          if ((int)v25 >= 12288) {
            goto LABEL_91;
          }
          *v4++ = v25;
          unsigned int v8 = v25 & 0xFFFFFF80 | 0x40;
          uint64_t v14 = result[5];
          goto LABEL_13;
        }
        if (v22 <= 0x20)
        {
          if (v22 == 32) {
            int v20 = v21;
          }
          else {
            int v20 = 64;
          }
          *v4++ = v22;
          unsigned int v19 = v3;
          goto LABEL_27;
        }
        if ((v22 - 37) <= 0xD5u && (unint64_t)v3 < v5)
        {
          if (v22 <= 0x8F) {
            int v26 = -19504;
          }
          else {
            int v26 = -50480;
          }
          int v15 = v26 + 243 * v22;
          char v27 = v3 + 1;
          unsigned int v28 = *v3;
          if (v28 >= 0x21)
          {
            unsigned int v29 = v28 - 13;
          }
          else
          {
            unsigned int v29 = byte_18CA80ADC[*v3];
            if ((0x10C00FF81uLL >> v28))
            {
LABEL_110:
              *(unsigned char *)(v2 + 65) = v22;
              *(unsigned char *)(v2 + 66) = *v3;
              LOBYTE(v10) = 2;
              goto LABEL_107;
            }
          }
          unsigned int v25 = v15 + v21 + v29;
          if (v25 < 0x110000)
          {
            ++v3;
            goto LABEL_91;
          }
          goto LABEL_110;
        }
        ++v3;
        int v21 = 64;
      }
      while (v22 == 255);
      *int v11 = v22;
      --v3;
      if (v22 >= 0x22) {
        int v30 = 59049 * v22 - 2195326;
      }
      else {
        int v30 = -14536567;
      }
      if (v22 >= 0x22) {
        int v31 = 2;
      }
      else {
        int v31 = 3;
      }
      if (v22 >= 0x25)
      {
        int v30 = 243 * v22 - 19504;
        int v31 = 1;
      }
      int v32 = 59049 * v22 - 14810786;
      if (v22 <= 0xFD)
      {
        int v33 = 2;
      }
      else
      {
        int v32 = 187660;
        int v33 = 3;
      }
      if (v22 > 0xFA)
      {
        int v34 = v33;
      }
      else
      {
        int v32 = 243 * v22 - 50480;
        int v34 = 1;
      }
      if (v22 >= 0x50)
      {
        LODWORD(v9) = v34;
      }
      else
      {
        int v32 = v30;
        LODWORD(v9) = v31;
      }
      int v7 = v9 | (4 * v32);
      LOBYTE(v10) = 1;
      goto LABEL_75;
    }
  }
LABEL_44:
  if (*a2 != 12) {
    goto LABEL_48;
  }
LABEL_108:
  int v24 = 0;
  *(_DWORD *)(v2 + 72) = 64;
LABEL_109:
  *(_DWORD *)(v2 + 76) = v24;
  *(unsigned char *)(v2 + 64) = v10;
  result[2] = v3;
  result[4] = v4;
  return result;
}

void *sub_18C86814C(void *result, int *a2)
{
  int v2 = 0;
  uint64_t v3 = result[1];
  unint64_t v4 = (unsigned __int8 *)result[2];
  unint64_t v6 = result[3];
  unint64_t v5 = (_WORD *)result[4];
  unint64_t v8 = result[5];
  int v7 = (int *)result[6];
  int v9 = *(_DWORD *)(v3 + 76);
  if (*(_DWORD *)(v3 + 72)) {
    unsigned int v10 = *(_DWORD *)(v3 + 72);
  }
  else {
    unsigned int v10 = 64;
  }
  LODWORD(v11) = *(_DWORD *)(v3 + 76) & 3;
  int v12 = *(char *)(v3 + 64);
  int v13 = (unsigned char *)(v3 + 65);
  if ((v9 & 3) == 0 || v12 < 1 || (unint64_t)v5 >= v8)
  {
    uint64_t v16 = result[5];
    goto LABEL_13;
  }
  int v21 = -1;
LABEL_72:
  int v17 = v9 >> 2;
  v2 += v11;
  do
  {
    if ((unint64_t)v4 >= v6) {
      goto LABEL_99;
    }
    unsigned int v35 = *v4++;
    uint64_t v34 = v35;
    v13[(char)v12] = v35;
    if (v35 > 0x20uLL) {
      int v36 = v34 - 13;
    }
    else {
      int v36 = byte_18CA80ADC[v34];
    }
    LOBYTE(v12) = v12 + 1;
    int v37 = 59049 * v36;
    if (v11 == 2) {
      int v37 = 243 * v36;
    }
    if (v11 != 1) {
      int v36 = v37;
    }
    if (v36 < 0) {
      goto LABEL_97;
    }
    v17 += v36;
    LODWORD(v11) = v11 - 1;
  }
  while (v11);
  unsigned int v28 = v17 + v10;
  if (v17 + v10 > 0x10FFFF)
  {
    int v27 = 12;
    LOBYTE(v12) = 0;
    goto LABEL_98;
  }
  LOBYTE(v12) = 0;
LABEL_85:
  while (2)
  {
    if (v28 - 55204 >= 0xFFFF589C)
    {
      unsigned int v10 = 12400;
      if (v28 >> 5 >= 0x185)
      {
        unsigned int v10 = 30481;
        if (v28 - 19968 >= 0x51A6)
        {
          unsigned int v10 = 49617;
          if (v28 >> 10 <= 0x2A) {
            unsigned int v10 = v28 & 0xFFFFFF80 | 0x40;
          }
        }
      }
      goto LABEL_93;
    }
    unsigned int v10 = v28 & 0xFFFFFF80 | 0x40;
    if (!HIWORD(v28))
    {
LABEL_93:
      *v5++ = v28;
      uint64_t v39 = 1;
      int v38 = v7;
      goto LABEL_94;
    }
    *unint64_t v5 = (v28 >> 10) - 10304;
    if ((unint64_t)(v5 + 1) >= v8)
    {
      *v7++ = v21;
      *(_WORD *)(v3 + 144) = v28 & 0x3FF | 0xDC00;
      *(unsigned char *)(v3 + 93) = 1;
      int v27 = 15;
      ++v5;
      goto LABEL_98;
    }
    v5[1] = v28 & 0x3FF | 0xDC00;
    v5 += 2;
    *int v7 = v21;
    int v38 = v7 + 1;
    uint64_t v39 = 2;
LABEL_94:
    v7 += v39;
    *int v38 = v21;
LABEL_26:
    int v22 = v10;
LABEL_27:
    uint64_t v23 = 0;
    int v24 = v22;
    while (1)
    {
      unsigned int v10 = v24;
      if ((unint64_t)&v4[v23] >= v6)
      {
        v4 += v23;
        goto LABEL_99;
      }
      if ((unint64_t)v5 >= v8)
      {
        int v27 = 15;
        unsigned int v10 = v22;
        goto LABEL_98;
      }
      unsigned int v25 = v4[v23];
      if (((v25 - 80) & 0x80) == 0)
      {
        unsigned int v28 = v24 + v25 - 144;
        v4 += v23 + 1;
        int v21 = v23 + v2;
        v2 += v23 + 1;
        if ((int)v28 >= 12288) {
          goto LABEL_85;
        }
        *v5++ = v28;
        *v7++ = v21;
        unsigned int v10 = v28 & 0xFFFFFF80 | 0x40;
        uint64_t v16 = result[5];
LABEL_13:
        int v17 = v6 - v4;
        unint64_t v11 = (unint64_t)(v16 - (void)v5) >> 1;
        if ((int)v11 >= (int)v6 - (int)v4) {
          LODWORD(v11) = v6 - v4;
        }
        if ((int)v11 >= 1)
        {
          do
          {
            unsigned int v18 = *v4;
            if (((v18 - 80) & 0x80) != 0)
            {
              if (v18 > 0x20) {
                goto LABEL_26;
              }
              if (v18 != 32) {
                unsigned int v10 = 64;
              }
              *unint64_t v5 = v18;
              *int v7 = v2;
            }
            else
            {
              int v19 = v10 + v18 - 144;
              if (v19 >= 12288) {
                goto LABEL_26;
              }
              *unint64_t v5 = v19;
              *int v7 = v2;
              unsigned int v10 = v19 & 0xFFFFFF80 | 0x40;
            }
            ++v7;
            ++v5;
            ++v2;
            ++v4;
            BOOL v20 = __OFSUB__(v11, 1);
            LODWORD(v11) = v11 - 1;
          }
          while (!(((v11 & 0x80000000) != 0) ^ v20 | (v11 == 0)));
          LODWORD(v11) = 0;
        }
        goto LABEL_26;
      }
      if (v25 <= 0x20)
      {
        if (v25 == 32) {
          int v22 = v24;
        }
        else {
          int v22 = 64;
        }
        *v5++ = v25;
        *v7++ = v2 + v23;
        v4 += v23 + 1;
        v2 += v23 + 1;
        goto LABEL_27;
      }
      if ((v25 - 37) <= 0xD5u && (unint64_t)&v4[v23 + 1] < v6) {
        break;
      }
      ++v23;
      int v24 = 64;
      if (v25 != 255)
      {
        *int v13 = v25;
        v4 += v23;
        int v21 = v2 - 1 + v23;
        v2 += v23;
        if (v25 < 0x50)
        {
          if (v25 < 0x25)
          {
            LODWORD(v11) = 3;
            int v12 = -14536567;
            if (v25 >= 0x22)
            {
              int v12 = 59049 * v25 - 2195326;
              LODWORD(v11) = 2;
            }
            goto LABEL_71;
          }
          int v33 = -19504;
        }
        else
        {
          if (v25 > 0xFA)
          {
            if (v25 <= 0xFD) {
              int v12 = 59049 * v25 - 14810786;
            }
            else {
              int v12 = 187660;
            }
            if (v25 <= 0xFD) {
              LODWORD(v11) = 2;
            }
            else {
              LODWORD(v11) = 3;
            }
            goto LABEL_71;
          }
          int v33 = -50480;
        }
        int v12 = v33 + 243 * v25;
        LODWORD(v11) = 1;
LABEL_71:
        int v9 = v11 | (4 * v12);
        LOBYTE(v12) = 1;
        goto LABEL_72;
      }
    }
    if (v25 <= 0x8F) {
      int v29 = -19504;
    }
    else {
      int v29 = -50480;
    }
    int v17 = v29 + 243 * v25;
    int v30 = &v4[v23];
    v4 += v23 + 2;
    unsigned int v31 = v30[1];
    int v21 = v23 + v2;
    if (v31 >= 0x21)
    {
      unsigned int v32 = v31 - 13;
    }
    else
    {
      unsigned int v32 = byte_18CA80ADC[v30[1]];
      if ((0x10C00FF81uLL >> v31)) {
        break;
      }
    }
    unsigned int v28 = v17 + v10 + v32;
    if (HIWORD(v28) <= 0x10u)
    {
      int v2 = v21 + 2;
      continue;
    }
    break;
  }
  *(unsigned char *)(v3 + 65) = v25;
  *(unsigned char *)(v3 + 66) = v30[1];
  LOBYTE(v12) = 2;
LABEL_97:
  int v27 = 12;
LABEL_98:
  *a2 = v27;
LABEL_99:
  int v40 = v11 | (4 * v17);
  if (*a2 == 12) {
    int v41 = 64;
  }
  else {
    int v41 = v10;
  }
  if (*a2 == 12) {
    int v40 = 0;
  }
  *(_DWORD *)(v3 + 72) = v41;
  *(_DWORD *)(v3 + 76) = v40;
  *(unsigned char *)(v3 + 64) = v12;
  result[2] = v4;
  result[4] = v5;
  result[6] = v7;
  return result;
}

uint64_t sub_18C8685C8(uint64_t result, _DWORD *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 8);
  unint64_t v5 = *(unsigned __int16 **)(result + 16);
  unint64_t v7 = *(void *)(result + 24);
  unint64_t v6 = *(unsigned char **)(result + 32);
  int v8 = *(_DWORD *)(result + 40) - v6;
  unsigned int v9 = *(_DWORD *)(v4 + 84);
  if (*(_DWORD *)(v4 + 80)) {
    int v10 = *(_DWORD *)(v4 + 80);
  }
  else {
    int v10 = 64;
  }
  if (v9) {
    BOOL v11 = v8 <= 0;
  }
  else {
    BOOL v11 = 1;
  }
  int v12 = *(unsigned __int16 **)(result + 16);
  unsigned int v13 = *(_DWORD *)(result + 40) - v6;
  if (v11) {
    goto LABEL_9;
  }
LABEL_33:
  if ((unint64_t)v12 >= v7)
  {
    unsigned int v9 = -v9;
    unint64_t v5 = v12;
    goto LABEL_56;
  }
  int v20 = *v12;
  BOOL v21 = (v20 & 0xFC00) == 56320;
  int v22 = v20 + (v9 << 10) - 56613888;
  unint64_t v5 = &v12[v21];
  if (v21) {
    unsigned int v9 = v22;
  }
  while (1)
  {
    double result = v9 - v10;
    unsigned int v23 = v9 >> 10 <= 0x2A ? v9 & 0xFFFFFF80 | 0x40 : 49617;
    int v24 = v9 - 19968 >= 0x51A6 ? v23 : 30481;
    unsigned int v25 = v9 >> 5 >= 0x185 ? v24 : 12400;
    int v10 = v9 - 55204 <= 0xFFFF589B ? v9 & 0xFFFFFF80 | 0x40 : v25;
    if ((result + 64) > 0x7F) {
      break;
    }
    *v6++ = result - 112;
    int v8 = v13 - 1;
    if ((int)v9 < 12288)
    {
LABEL_9:
      if (v8 >= (int)((v7 - (unint64_t)v5) >> 1)) {
        int v8 = (v7 - (unint64_t)v5) >> 1;
      }
      if (v8 >= 1)
      {
        int v14 = v8 + 1;
        do
        {
          unsigned int v9 = *v5;
          if (v9 >> 12 > 2) {
            break;
          }
          if (v9 > 0x20)
          {
            char v16 = v9 - v10;
            if (v9 - v10 + 64 > 0x7F) {
              break;
            }
            int v10 = v9 & 0xFF80 | 0x40;
            LOBYTE(v15) = v16 - 112;
          }
          else
          {
            if (v9 != 32) {
              int v10 = 64;
            }
            unsigned __int16 v15 = *v5;
          }
          *v6++ = v15;
          ++v5;
          --v14;
        }
        while (v14 > 1);
      }
      int v8 = *(_DWORD *)(v3 + 40) - v6;
    }
LABEL_22:
    if ((unint64_t)v5 >= v7) {
      goto LABEL_56;
    }
    if (v8 < 1) {
      goto LABEL_31;
    }
    uint64_t v17 = 0;
    uint64_t v18 = 1;
    int v19 = v5;
    while (1)
    {
      int v12 = v19 + 1;
      unsigned int v9 = v5[v17];
      if (v9 > 0x20) {
        break;
      }
      if (v9 != 32) {
        int v10 = 64;
      }
      v6[v17] = v9;
      if ((unint64_t)v12 >= v7)
      {
        unint64_t v5 = v19 + 1;
        v6 += v17 + 1;
        goto LABEL_56;
      }
      ++v17;
      --v18;
      ++v19;
      if (v8 + (int)v18 < 2)
      {
        v6 += v17;
        unint64_t v5 = v12;
        goto LABEL_31;
      }
    }
    v6 += v17;
    unsigned int v13 = v8 - v17;
    if ((v9 & 0xFC00) == 0xD800) {
      goto LABEL_33;
    }
    unint64_t v5 = v19 + 1;
  }
  if ((result + 10513) <= 0x5221)
  {
    int v8 = v13 - 2;
    if (v13 >= 2)
    {
      if ((result & 0x80000000) != 0)
      {
        unsigned int v27 = (-64 - (int)result) / 0xF3u;
        unsigned int v30 = (-64 - (int)result) % 0xF3u;
        int v26 = 243 - v30;
        if (v30) {
          LOBYTE(v27) = ~(_BYTE)v27;
        }
        else {
          unsigned int v27 = -v27;
        }
        LOBYTE(v27) = v27 + 80;
        if (!v30)
        {
          int v26 = 0u;
          *unint64_t v6 = v27;
          goto LABEL_74;
        }
      }
      else
      {
        int v26 = (__int16)(result - 64) % 243;
        LOWORD(v27) = (__int16)(result - 64) / 243 + 208;
      }
      *unint64_t v6 = v27;
      if (v26 >= 20)
      {
        char v31 = v26 + 13;
LABEL_75:
        v6[1] = v31;
        v6 += 2;
        goto LABEL_22;
      }
LABEL_74:
      char v31 = byte_18CA80AFD[v26];
      goto LABEL_75;
    }
  }
  double result = sub_18C868E40(result);
  if (result >> 26) {
    int v28 = 4;
  }
  else {
    int v28 = (int)result >> 24;
  }
  unsigned int v29 = v28 - v13;
  if (v28 <= (int)v13)
  {
    if (v28 == 3) {
      goto LABEL_64;
    }
    if (v28 == 4)
    {
      *v6++ = BYTE3(result);
LABEL_64:
      *unint64_t v6 = BYTE2(result);
      v6[1] = BYTE1(result);
      long long v6[2] = result;
      v6 += 3;
    }
    int v8 = v13 - v28;
    goto LABEL_22;
  }
  unsigned int v32 = (unsigned char *)(v4 + 104);
  switch(v29)
  {
    case 1u:
      goto LABEL_82;
    case 2u:
      goto LABEL_81;
    case 3u:
      unsigned int v32 = (unsigned char *)(v4 + 105);
      *(unsigned char *)(v4 + 104) = BYTE2(result);
LABEL_81:
      *v32++ = BYTE1(result);
LABEL_82:
      *unsigned int v32 = result;
      break;
  }
  *(unsigned char *)(v4 + 91) = v29;
  int v33 = (int)result >> (8 * v29);
  switch(v13)
  {
    case 1u:
      goto LABEL_88;
    case 2u:
      goto LABEL_87;
    case 3u:
      *v6++ = BYTE2(v33);
LABEL_87:
      *v6++ = BYTE1(v33);
LABEL_88:
      *v6++ = v33;
      break;
  }
LABEL_31:
  *a2 = 15;
LABEL_56:
  *(_DWORD *)(v4 + 80) = v10;
  *(_DWORD *)(v4 + 84) = -v9 & ((int)v9 >> 31);
  *(void *)(v3 + 16) = v5;
  *(void *)(v3 + 32) = v6;
  return result;
}

uint64_t sub_18C8689AC(uint64_t result, _DWORD *a2)
{
  uint64_t v2 = result;
  int v3 = 0;
  uint64_t v5 = *(void *)(result + 8);
  uint64_t v4 = *(unsigned __int16 **)(result + 16);
  unint64_t v7 = *(void *)(result + 24);
  unint64_t v6 = *(unsigned char **)(result + 32);
  int v8 = *(_DWORD *)(result + 40) - v6;
  unsigned int v9 = *(int **)(result + 48);
  unsigned int v10 = *(_DWORD *)(v5 + 84);
  if (*(_DWORD *)(v5 + 80)) {
    int v11 = *(_DWORD *)(v5 + 80);
  }
  else {
    int v11 = 64;
  }
  if (v10) {
    int v12 = -1;
  }
  else {
    int v12 = 0;
  }
  if (v10) {
    BOOL v13 = v8 <= 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    int v14 = *(unsigned __int16 **)(result + 16);
    goto LABEL_13;
  }
LABEL_38:
  if ((unint64_t)v4 >= v7)
  {
    unsigned int v10 = -v10;
    int v14 = v4;
    goto LABEL_54;
  }
  int v23 = *v4;
  BOOL v24 = (v23 & 0xFC00) == 56320;
  int v25 = v23 + (v10 << 10) - 56613888;
  int v14 = &v4[v24];
  if (v24)
  {
    unsigned int v10 = v25;
    ++v3;
  }
  while (1)
  {
    double result = v10 - v11;
    if (v10 - 55204 <= 0xFFFF589B
      || (int v11 = 12400, v10 >> 5 >= 0x185) && (int v11 = 30481, v10 - 19968 >= 0x51A6) && (int v11 = 49617, v10 >> 10 <= 0x2A))
    {
      int v11 = v10 & 0xFFFFFF80 | 0x40;
    }
    if ((result + 64) > 0x7F)
    {
      if ((result + 10513) <= 0x5221 && v8 >= 2)
      {
        if ((result & 0x80000000) != 0)
        {
          unsigned int v30 = (-64 - (int)result) / 0xF3u;
          unsigned int v31 = (-64 - (int)result) % 0xF3u;
          int v26 = 243 - v31;
          if (v31) {
            char v32 = ~(_BYTE)v30;
          }
          else {
            char v32 = -(char)v30;
          }
          LOBYTE(v27) = v32 + 80;
          if (!v31)
          {
            int v26 = 0u;
            *unint64_t v6 = v27;
            goto LABEL_74;
          }
        }
        else
        {
          int v26 = (__int16)(result - 64) % 243;
          __int16 v27 = (__int16)(result - 64) / 243 + 208;
        }
        *unint64_t v6 = v27;
        if (v26 >= 20)
        {
          char v33 = v26 + 13;
LABEL_75:
          v6[1] = v33;
          v6 += 2;
          int v19 = v9 + 2;
          *unsigned int v9 = v12;
          v9[1] = v12;
          v8 -= 2;
          goto LABEL_27;
        }
LABEL_74:
        char v33 = byte_18CA80AFD[v26];
        goto LABEL_75;
      }
      uint64_t v37 = v2;
      int v38 = a2;
      double result = sub_18C868E40(result);
      int v28 = (int)result >> 24;
      if (result >> 26) {
        int v28 = 4;
      }
      int v29 = v28 - v8;
      if (v28 <= v8)
      {
        if (v28 == 2)
        {
          uint64_t v2 = v37;
          a2 = v38;
        }
        else
        {
          uint64_t v2 = v37;
          a2 = v38;
          if (v28 != 3)
          {
            if (v28 != 4)
            {
LABEL_72:
              v8 -= v28;
LABEL_26:
              int v19 = v9;
              goto LABEL_27;
            }
            *v6++ = BYTE3(result);
            *v9++ = v12;
          }
          *v6++ = BYTE2(result);
          *v9++ = v12;
        }
        *unint64_t v6 = BYTE1(result);
        *unsigned int v9 = v12;
        v6[1] = result;
        v6 += 2;
        v9[1] = v12;
        v9 += 2;
        goto LABEL_72;
      }
      uint64_t v34 = (unsigned char *)(v5 + 104);
      if (v29 == 1)
      {
        uint64_t v2 = v37;
        unsigned int v35 = v38;
      }
      else
      {
        uint64_t v2 = v37;
        unsigned int v35 = v38;
        if (v29 != 2)
        {
          if (v29 != 3) {
            goto LABEL_86;
          }
          uint64_t v34 = (unsigned char *)(v5 + 105);
          *(unsigned char *)(v5 + 104) = BYTE2(result);
        }
        *v34++ = BYTE1(result);
      }
      *uint64_t v34 = result;
LABEL_86:
      *(unsigned char *)(v5 + 91) = v29;
      int v36 = (int)result >> (8 * v29);
      if (v8 != 1)
      {
        if (v8 != 2)
        {
          if (v8 != 3)
          {
LABEL_92:
            *unsigned int v35 = 15;
            goto LABEL_54;
          }
          *v6++ = BYTE2(v36);
          *v9++ = v12;
        }
        *v6++ = BYTE1(v36);
        *v9++ = v12;
      }
      *v6++ = v36;
      *v9++ = v12;
      goto LABEL_92;
    }
    *v6++ = result - 112;
    *v9++ = v12;
    --v8;
    int v19 = v9;
    if ((int)v10 < 12288)
    {
LABEL_13:
      unint64_t v15 = (v7 - (unint64_t)v14) >> 1;
      if (v8 < (int)v15) {
        LODWORD(v15) = v8;
      }
      if ((int)v15 >= 1)
      {
        int v16 = v15 + 1;
        do
        {
          unsigned int v10 = *v14;
          if (v10 >> 12 > 2) {
            break;
          }
          if (v10 > 0x20)
          {
            char v18 = v10 - v11;
            if (v10 - v11 + 64 > 0x7F) {
              break;
            }
            int v11 = v10 & 0xFF80 | 0x40;
            LOBYTE(v17) = v18 - 112;
          }
          else
          {
            if (v10 != 32) {
              int v11 = 64;
            }
            unsigned __int16 v17 = *v14;
          }
          *v6++ = v17;
          *v9++ = v3;
          ++v14;
          ++v3;
          --v16;
        }
        while (v16 > 1);
      }
      int v8 = *(_DWORD *)(v2 + 40) - v6;
      goto LABEL_26;
    }
LABEL_27:
    if ((unint64_t)v14 >= v7)
    {
      unsigned int v9 = v19;
      goto LABEL_54;
    }
    if (v8 < 1) {
      break;
    }
    uint64_t v20 = 0;
    uint64_t v21 = 1;
    int v22 = v14;
    unsigned int v9 = v19;
    while (1)
    {
      uint64_t v4 = v22 + 1;
      unsigned int v10 = v14[v20];
      if (v10 > 0x20) {
        break;
      }
      if (v10 != 32) {
        int v11 = 64;
      }
      v6[v20] = v10;
      ++v9;
      v19[v20] = v3 + v20;
      if ((unint64_t)v4 >= v7)
      {
        int v14 = v22 + 1;
        v6 += v20 + 1;
        goto LABEL_54;
      }
      ++v20;
      --v21;
      ++v22;
      if (v8 + (int)v21 < 2)
      {
        v6 += v20;
        int v14 = v4;
        goto LABEL_36;
      }
    }
    v6 += v20;
    v8 -= v20;
    int v12 = v20 + v3;
    v3 += v20 + 1;
    if ((v10 & 0xFC00) == 0xD800) {
      goto LABEL_38;
    }
    int v14 = v22 + 1;
  }
  unsigned int v9 = v19;
LABEL_36:
  *a2 = 15;
LABEL_54:
  *(_DWORD *)(v5 + 80) = v11;
  *(_DWORD *)(v5 + 84) = -v10 & ((int)v10 >> 31);
  *(void *)(v2 + 16) = v14;
  *(void *)(v2 + 32) = v6;
  *(void *)(v2 + 48) = v9;
  return result;
}

uint64_t sub_18C868E40(int a1)
{
  if (a1 < -64)
  {
    if (a1 >= 0xFFFFD6EF)
    {
      unsigned int v3 = (((unsigned __int16)(-64 - a1 - ((3507 * (unsigned __int16)(-64 - a1)) >> 16)) >> 1)
          + ((3507 * (unsigned __int16)(-64 - a1)) >> 16)) >> 7;
      if (-64 - (_WORD)a1 == 243 * (_WORD)v3) {
        int v4 = -v3;
      }
      else {
        int v4 = ~v3;
      }
      if (-64 - (_WORD)a1 == 243 * (_WORD)v3) {
        unsigned __int16 v5 = 0;
      }
      else {
        unsigned __int16 v5 = 243 - (-64 - a1 - 243 * v3);
      }
      if (v5 < 0x14u) {
        int v2 = byte_18CA80AFD[v5];
      }
      else {
        int v2 = v5 + 13;
      }
      int v11 = (v4 << 8) + 20480;
      return v11 | v2 | 0x2000000u;
    }
    if (a1 > 0xFFFD22F3)
    {
      unsigned int v8 = (-10513 - a1) / 0xF3u;
      unsigned int v9 = (-10513 - a1) % 0xF3u;
      if (v9)
      {
        LOWORD(v8) = v8 + 1;
        unsigned int v10 = 243 - v9;
      }
      else
      {
        unsigned int v10 = 0;
      }
      if (v10 < 0x14) {
        unsigned int v7 = byte_18CA80AFD[v10];
      }
      else {
        unsigned int v7 = v10 + 13;
      }
      unsigned int v22 = (((unsigned __int16)(v8 - ((3507 * (unsigned __int16)v8) >> 16)) >> 1)
           + ((3507 * (unsigned __int16)v8) >> 16)) >> 7;
      __int16 v23 = v8 - 243 * v22;
      unsigned __int16 v24 = 243 - v23;
      BOOL v25 = v23 == 0;
      if (v23) {
        int v26 = ~v22;
      }
      else {
        int v26 = -v22;
      }
      if (v25) {
        unsigned __int16 v27 = 0;
      }
      else {
        unsigned __int16 v27 = v24;
      }
      if (v27 < 0x14u) {
        int v21 = byte_18CA80AFD[v27];
      }
      else {
        int v21 = v27 + 13;
      }
      int v37 = (v26 << 16) + 2424832;
      return v37 | v7 | (v21 << 8) | 0x3000000;
    }
    unsigned int v16 = (-187660 - a1) % 0xF3u;
    if (v16) {
      unsigned int v17 = (-187660 - a1) / 0xF3u + 1;
    }
    else {
      unsigned int v17 = (-187660 - a1) / 0xF3u;
    }
    if (v16) {
      unsigned int v18 = 243 - v16;
    }
    else {
      unsigned int v18 = 0;
    }
    if (v18 < 0x14) {
      unsigned int v19 = byte_18CA80AFD[v18];
    }
    else {
      unsigned int v19 = v18 + 13;
    }
    unsigned int v30 = v17 / 0xF3;
    unsigned int v31 = v17 % 0xF3;
    unsigned int v32 = 243 - v31;
    BOOL v33 = v31 == 0;
    if (v31) {
      int v34 = ~v30;
    }
    else {
      int v34 = -v30;
    }
    if (v33) {
      unsigned int v35 = 0;
    }
    else {
      unsigned int v35 = v32;
    }
    if (v35 < 0x14) {
      unsigned int v36 = byte_18CA80AFD[v35];
    }
    else {
      unsigned int v36 = v35 + 13;
    }
    unsigned int v40 = v36 << 8;
    if (v34 < -223) {
      int v41 = byte_18CA80AFD[v34 + 243];
    }
    else {
      int v41 = v34 + 256;
    }
    return v19 | v40 | (v41 << 16) | 0x21000000;
  }
  else
  {
    if (a1 <= 10512)
    {
      int v1 = (__int16)(a1 - 64) % 243;
      if (v1 < 20) {
        int v2 = byte_18CA80AFD[(__int16)(a1 - 64) % 243];
      }
      else {
        int v2 = (unsigned __int16)(v1 + 13);
      }
      int v11 = ((unsigned __int16)((__int16)(a1 - 64) / 243) << 8) + 53248;
      return v11 | v2 | 0x2000000u;
    }
    if (a1 <= 0x2DD0B)
    {
      unsigned int v6 = (a1 - 10513) % 0xF3u;
      if (v6 < 0x14) {
        unsigned int v7 = byte_18CA80AFD[v6];
      }
      else {
        unsigned int v7 = v6 + 13;
      }
      unsigned int v20 = (unsigned __int16)((a1 - 10513) / 0xF3u)
          - 243 * ((17674763 * (unint64_t)(unsigned __int16)((a1 - 10513) / 0xF3u)) >> 32);
      if (v20 < 0x14) {
        int v21 = byte_18CA80AFD[v20];
      }
      else {
        int v21 = v20 + 13;
      }
      int v37 = (((a1 - 10513) / 0xE6A9u) << 16) + 16449536;
      return v37 | v7 | (v21 << 8) | 0x3000000;
    }
    unsigned int v13 = a1 - 187660;
    unsigned int v14 = (a1 - 187660) % 0xF3u;
    if (v14 < 0x14) {
      unsigned int v15 = byte_18CA80AFD[v14];
    }
    else {
      unsigned int v15 = v14 + 13;
    }
    unsigned int v28 = (a1 - 187660) / 0xF3u - 243 * ((17674763 * (unint64_t)((a1 - 187660) / 0xF3u)) >> 32);
    if (v28 < 0x14) {
      unsigned int v29 = byte_18CA80AFD[v28];
    }
    else {
      unsigned int v29 = v28 + 13;
    }
    unsigned int v38 = v13 / 0xE6A9;
    if (v13 < 0x120534) {
      unsigned int v39 = byte_18CA80AFD[v38];
    }
    else {
      unsigned int v39 = v38 + 13;
    }
    return v15 | (v29 << 8) | (v39 << 16) | 0xFE000000;
  }
}

uint64_t ucnv_getDisplayName(uint64_t a1, char *a2, UChar *a3, int a4, int *a5)
{
  int v17 = 0;
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (!a1 || a4 < 0 || !a3 && a4)
  {
    uint64_t result = 0;
    *a5 = 1;
    return result;
  }
  uint64_t v10 = ures_open(0, a2, a5);
  if (*a5 > 0) {
    return 0;
  }
  uint64_t v11 = v10;
  unsigned int v18 = 0;
  StringByKey = ures_getStringByKey(v10, (const char *)(*(void *)(*(void *)(a1 + 48) + 16) + 4), (int *)&v18, &v17);
  ures_close(v11);
  if (v17 <= 0)
  {
    if (!*a5) {
      *a5 = v17;
    }
    int v16 = uprv_min(v18, a4);
    u_memcpy(a3, StringByKey, 2 * v16);
  }
  else
  {
    unsigned int v13 = (const char *)(*(void *)(*(void *)(a1 + 48) + 16) + 4);
    size_t v14 = strlen(v13);
    unsigned int v18 = v14;
    int32_t v15 = uprv_min(v14, a4);
    u_charsToUChars(v13, a3, v15);
  }
  return u_terminateUChars((uint64_t)a3, a4, v18, a5);
}

void sub_18C86936C(void *a1, uint64_t a2, UErrorCode *a3)
{
  if (*(unsigned char *)(a2 + 8))
  {
    sub_18C85BFD4("GBK", a3);
  }
  else
  {
    unsigned __int16 v5 = ucnv_open("GBK", a3);
    if (*(int *)a3 <= 0)
    {
      unsigned int v6 = v5;
      a1[9] = 0;
      a1[10] = 0;
      unsigned int v7 = uprv_calloc(1, 24);
      a1[2] = v7;
      if (v7)
      {
        *unsigned int v7 = v6;
      }
      else
      {
        ucnv_close(v6);
        *a3 = U_MEMORY_ALLOCATION_ERROR;
      }
    }
  }
}

void sub_18C86941C(uint64_t a1)
{
  int v1 = *(void ***)(a1 + 16);
  if (v1)
  {
    ucnv_close(*v1);
    if (!*(unsigned char *)(a1 + 62)) {
      uprv_free(*(void **)(a1 + 16));
    }
    *(void *)(a1 + 16) = 0;
  }
}

void *sub_18C869460(void *result, int a2)
{
  if (a2 >= 2)
  {
    uint64_t v2 = result[2];
LABEL_7:
    result[10] = 0;
    if (v2)
    {
      *(unsigned char *)(v2 + 18) = 0;
      *(void *)(v2 + 8) = 0;
      *(unsigned char *)(v2 + 16) = 0;
    }
    return result;
  }
  result[9] = 0;
  uint64_t v2 = result[2];
  if (v2)
  {
    *(unsigned char *)(v2 + 17) = 0;
    *(unsigned char *)(v2 + 19) = 0;
  }
  if (a2 != 1) {
    goto LABEL_7;
  }
  return result;
}

void *sub_18C8694A4(void *result, int *a2)
{
  uint64_t v2 = result;
  __int16 v22 = 0;
  unint64_t v4 = result[3];
  unsigned int v3 = (_WORD *)result[4];
  unsigned __int16 v5 = (unsigned __int8 *)result[2];
  if ((unint64_t)v5 >= v4) {
    goto LABEL_40;
  }
  uint64_t v6 = result[1];
  unsigned int v7 = *(unsigned char **)(v6 + 16);
  while (2)
  {
    unint64_t v8 = v2[5];
    int v9 = (int)v5;
    uint64_t v10 = v5;
    while (1)
    {
      if ((unint64_t)v3 >= v8)
      {
        *a2 = 15;
        goto LABEL_40;
      }
      uint64_t v11 = v10;
      unsigned int v13 = *v10++;
      unint64_t v12 = v13;
      if (*(_DWORD *)(v6 + 76) == 126) {
        break;
      }
      if (!v7[17])
      {
        if (v12 == 126)
        {
LABEL_15:
          *(_DWORD *)(v6 + 76) = 126;
          goto LABEL_19;
        }
        v7[19] = 0;
        if ((v12 & 0x80) == 0)
        {
          uint64_t result = (void *)v12;
          goto LABEL_31;
        }
        *a2 = 12;
        goto LABEL_56;
      }
      int v14 = *(_DWORD *)(v6 + 72);
      if (v14)
      {
        unsigned int v15 = v12 - 33;
        if ((v14 - 33) > 0x5Cu || v15 >= 0x5E)
        {
          *(_DWORD *)(v6 + 72) = 0;
          *a2 = 12;
          if (v15 >= 0x5E)
          {
            LOWORD(v12) = v12 | (v14 << 8);
            goto LABEL_59;
          }
          LOBYTE(v12) = v14;
        }
        else
        {
          int v21 = a2;
          LOBYTE(v22) = v14 ^ 0x80;
          HIBYTE(v22) = v12 ^ 0x80;
          uint64_t result = (void *)sub_18C86D39C(*(void *)(*(void *)v7 + 48), (uint64_t)&v22, 2);
          uint64_t v6 = v2[1];
          *(_DWORD *)(v6 + 72) = 0;
          if ((int)result <= 65533)
          {
            a2 = v21;
LABEL_31:
            uint64_t v17 = v2[6];
            if (v17) {
              *(_DWORD *)(v17 + 2 * ((void)v3 - v2[4])) = v9 - ((char)v7[17] + *((_DWORD *)v2 + 4));
            }
            *unsigned int v3 = (_WORD)result;
            goto LABEL_34;
          }
          LODWORD(v12) = v12 & 0xFFFF00FF | (v14 << 8);
          if (result == 65534) {
            int v20 = 10;
          }
          else {
            int v20 = 12;
          }
          *int v21 = v20;
          if (v12 >= 0x100)
          {
LABEL_59:
            *(unsigned char *)(v6 + 65) = BYTE1(v12);
            *(unsigned char *)(v2[1] + 66) = v12;
            uint64_t v18 = v2[1];
            goto LABEL_38;
          }
LABEL_56:
          ++v11;
        }
        *(unsigned char *)(v6 + 65) = v12;
        *(unsigned char *)(v2[1] + 64) = 1;
LABEL_47:
        unsigned __int16 v5 = v11;
        goto LABEL_40;
      }
      if (v12 == 126) {
        goto LABEL_15;
      }
      *(_DWORD *)(v6 + 72) = v12 | 0x100;
      v7[19] = 0;
LABEL_19:
      ++v9;
      if ((unint64_t)v10 >= v4) {
        goto LABEL_39;
      }
    }
    *(_DWORD *)(v6 + 76) = 0;
    if ((int)v12 <= 124)
    {
      if (v12 == 10) {
        goto LABEL_19;
      }
      if (v12 != 123) {
        goto LABEL_41;
      }
      goto LABEL_17;
    }
    if (v12 == 125)
    {
LABEL_17:
      v7[17] = v12 == 123;
      if (v7[19])
      {
        v7[19] = 0;
        *a2 = 18;
        *(_DWORD *)(v6 + 284) = 2;
        *(unsigned char *)(v6 + 65) = 126;
        *(unsigned char *)(v2[1] + 66) = v12;
        uint64_t v18 = v2[1];
LABEL_38:
        *(unsigned char *)(v18 + 64) = 2;
LABEL_39:
        unsigned __int16 v5 = v11 + 1;
        break;
      }
      v7[19] = 1;
      goto LABEL_19;
    }
    if (v12 != 126)
    {
LABEL_41:
      v7[19] = 0;
      *a2 = 18;
      *(unsigned char *)(v6 + 65) = 126;
      if (v7[17])
      {
        if ((v12 - 33) >= 0x5E)
        {
LABEL_43:
          ++v11;
          *(unsigned char *)(v2[1] + 66) = v12;
          char v19 = 2;
LABEL_46:
          *(unsigned char *)(v2[1] + 64) = v19;
          goto LABEL_47;
        }
      }
      else if ((v12 & 0x80) != 0)
      {
        goto LABEL_43;
      }
      char v19 = 1;
      goto LABEL_46;
    }
    uint64_t v16 = v2[6];
    if (v16) {
      *(_DWORD *)(v16 + 2 * ((void)v3 - v2[4])) = ~*((_DWORD *)v2 + 4) + v9;
    }
    *unsigned int v3 = 126;
    v7[19] = 0;
LABEL_34:
    ++v3;
    unsigned __int16 v5 = v11 + 1;
    if ((unint64_t)(v11 + 1) < v4) {
      continue;
    }
    break;
  }
LABEL_40:
  v2[4] = v3;
  v2[2] = v5;
  return result;
}

uint64_t sub_18C8697CC(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);
  int v6 = *(_DWORD *)(a1 + 40) - v5;
  uint64_t result = *(void *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = v4 - result;
  unint64_t v10 = (unint64_t)v9 >> 1;
  uint64_t v11 = *(unsigned char **)(v8 + 16);
  LOBYTE(v12) = v11[18];
  LODWORD(v13) = *(_DWORD *)(v8 + 84);
  if (v13) {
    BOOL v14 = v6 <= 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    LODWORD(v45) = 0;
    LODWORD(v46) = 0;
    uint64_t result = 0;
    goto LABEL_65;
  }
  if ((int)v10 < 1)
  {
    LODWORD(v45) = 0;
    LODWORD(v15) = 0;
    goto LABEL_76;
  }
  uint64_t v15 = 0;
  LODWORD(v45) = 0;
  uint64_t v16 = *(_DWORD **)(a1 + 48);
  uint64_t v17 = (int)(v9 >> 1);
  char v18 = v11[18];
  while (2)
  {
    uint64_t v19 = (int)v45;
    uint64_t v46 = v15;
    while (1)
    {
      unsigned int v55 = 0xFFFF;
      if ((int)v46 >= v6)
      {
        *a2 = 15;
        LODWORD(v45) = v19;
        goto LABEL_75;
      }
      uint64_t v45 = v19 + 1;
      uint64_t v13 = *(unsigned __int16 *)(result + 2 * v19);
      if (v13 != 126) {
        break;
      }
      uint64_t v20 = 0;
      do
      {
        char v21 = asc_18CA9B0C4[v20];
        if ((int)v46 >= v6)
        {
          uint64_t v22 = *(void *)(a1 + 8);
          uint64_t v23 = *(char *)(v22 + 91);
          *(unsigned char *)(v22 + 91) = v23 + 1;
          *(unsigned char *)(v22 + v23 + 104) = v21;
          *a2 = 15;
        }
        else
        {
          *(unsigned char *)(*(void *)(a1 + 32) + (int)v46) = v21;
          if (*(void *)(a1 + 48)) {
            *v16++ = v19;
          }
          uint64_t v46 = (v46 + 1);
        }
        ++v20;
      }
      while (v20 != 2);
      ++v19;
      if (v45 >= v17) {
        goto LABEL_75;
      }
    }
    unint64_t v54 = v10;
    unsigned int v24 = *(unsigned __int16 *)(result + 2 * v19);
    if (v13 >= 0x80)
    {
      uint64_t v50 = v17;
      uint64_t v51 = result;
      uint64_t v52 = v5;
      unint64_t v53 = v11;
      char v49 = v18;
      int v25 = sub_18C86EC94(*(void *)(*(void *)v11 + 48), v13, (int *)&v55, *(char *)(*(void *)(a1 + 8) + 63));
      char v18 = v49;
      uint64_t v5 = v52;
      uint64_t v11 = v53;
      BOOL v26 = v25 == 2;
      uint64_t v17 = v50;
      uint64_t result = v51;
      if (!v26 || (((_WORD)v55 + 24159) & 0xFFFEu) > 0x5C5D || (((_BYTE)v55 + 95) & 0xFEu) > 0x5D) {
        break;
      }
      unsigned int v24 = v55 - 32896;
    }
    unsigned int v55 = v24;
    if (v24 != 0xFFFF)
    {
      int v12 = v24 > 0xFF;
      v11[18] = v12;
      if (v12 == v18 && v11[16])
      {
        unint64_t v10 = v54;
      }
      else
      {
        if (v24 <= 0xFF)
        {
          uint64_t v31 = 0;
          unint64_t v10 = v54;
          do
          {
            char v32 = asc_18CA9B0C7[v31];
            if ((int)v46 >= v6)
            {
              uint64_t v33 = *(void *)(a1 + 8);
              uint64_t v34 = *(char *)(v33 + 91);
              *(unsigned char *)(v33 + 91) = v34 + 1;
              *(unsigned char *)(v33 + v34 + 104) = v32;
              *a2 = 15;
            }
            else
            {
              *(unsigned char *)(*(void *)(a1 + 32) + (int)v46) = v32;
              if (*(void *)(a1 + 48)) {
                *v16++ = v19;
              }
              uint64_t v46 = (v46 + 1);
            }
            ++v31;
          }
          while (v31 != 2);
        }
        else
        {
          uint64_t v27 = 0;
          unint64_t v10 = v54;
          do
          {
            char v28 = asc_18CA9B0CA[v27];
            if ((int)v46 >= v6)
            {
              uint64_t v29 = *(void *)(a1 + 8);
              uint64_t v30 = *(char *)(v29 + 91);
              *(unsigned char *)(v29 + 91) = v30 + 1;
              *(unsigned char *)(v29 + v30 + 104) = v28;
              *a2 = 15;
            }
            else
            {
              *(unsigned char *)(*(void *)(a1 + 32) + (int)v46) = v28;
              if (*(void *)(a1 + 48)) {
                *v16++ = v19;
              }
              uint64_t v46 = (v46 + 1);
            }
            ++v27;
          }
          while (v27 != 2);
        }
        v11[16] = 1;
      }
      char v35 = v55;
      if (v24 < 0x100)
      {
        if ((int)v46 < v6)
        {
          uint64_t v15 = (v46 + 1);
          *(unsigned char *)(v5 + (int)v46) = v55;
          if (v16) {
            *v16++ = v19;
          }
          goto LABEL_63;
        }
        uint64_t v41 = *(void *)(a1 + 8);
        uint64_t v42 = *(char *)(v41 + 91);
        *(unsigned char *)(v41 + 91) = v42 + 1;
        *(unsigned char *)(v41 + v42 + 104) = v35;
      }
      else
      {
        unsigned int v36 = v55 >> 8;
        if ((int)v46 < v6)
        {
          uint64_t v15 = (int)v46 + 1;
          *(unsigned char *)(v5 + (int)v46) = BYTE1(v55);
          if (v16)
          {
            *uint64_t v16 = v19;
            char v35 = v55;
            if ((int)v15 < v6)
            {
              *(unsigned char *)(v5 + v15) = v55;
              uint64_t v15 = (v46 + 2);
              v16[1] = v19;
              v16 += 2;
              goto LABEL_63;
            }
            ++v16;
          }
          else
          {
            if ((int)v15 < v6)
            {
              uint64_t v16 = 0;
              *(unsigned char *)(v5 + v15) = v35;
              uint64_t v15 = (v46 + 2);
              goto LABEL_63;
            }
            uint64_t v16 = 0;
          }
          uint64_t v43 = *(void *)(a1 + 8);
          uint64_t v44 = *(char *)(v43 + 91);
          *(unsigned char *)(v43 + 91) = v44 + 1;
          *(unsigned char *)(v43 + v44 + 104) = v35;
          *a2 = 15;
LABEL_63:
          unsigned int v55 = 0xFFFF;
          char v18 = v12;
          if ((int)v45 < (int)v10) {
            continue;
          }
          goto LABEL_76;
        }
        uint64_t v37 = *(void *)(a1 + 8);
        uint64_t v38 = *(char *)(v37 + 91);
        *(unsigned char *)(v37 + 91) = v38 + 1;
        *(unsigned char *)(v37 + v38 + 104) = v36;
        LOBYTE(v37) = v55;
        uint64_t v39 = *(void *)(a1 + 8);
        uint64_t v40 = *(char *)(v39 + 91);
        *(unsigned char *)(v39 + 91) = v40 + 1;
        *(unsigned char *)(v39 + v40 + 104) = v37;
      }
      *a2 = 15;
      uint64_t v15 = v46;
      goto LABEL_63;
    }
    break;
  }
  if ((v13 & 0xF800) == 0xD800)
  {
    if ((v13 & 0x400) == 0)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      *(_DWORD *)(v8 + 84) = v13;
      uint64_t result = v13;
      LOBYTE(v12) = v18;
      LODWORD(v10) = v54;
LABEL_65:
      if ((int)v45 >= (int)v10)
      {
        int v48 = 0;
      }
      else
      {
        int v47 = *(unsigned __int16 *)(*(void *)(a1 + 16) + 2 * (int)v45);
        if ((v47 & 0xFC00) == 0xDC00)
        {
          LODWORD(v45) = v45 + 1;
          LODWORD(v13) = v47 + (v13 << 10) - 56613888;
          *(_DWORD *)(v8 + 84) = 0;
          int v48 = 10;
LABEL_73:
          char v18 = v12;
          goto LABEL_74;
        }
        int v48 = 12;
      }
      LODWORD(v13) = result;
      goto LABEL_73;
    }
    int v48 = 12;
  }
  else
  {
    int v48 = 10;
  }
LABEL_74:
  *a2 = v48;
  *(_DWORD *)(*(void *)(a1 + 8) + 84) = v13;
LABEL_75:
  LODWORD(v15) = v46;
  LOBYTE(v12) = v18;
LABEL_76:
  *(void *)(a1 + 32) += (int)v15;
  *(void *)(a1 + 16) += 2 * (int)v45;
  v11[18] = v12;
  return result;
}

void *sub_18C869CA0(void *a1, int a2, int *a3)
{
  uint64_t v3 = a1[1];
  uint64_t v4 = *(void *)(v3 + 16);
  int v7 = 0;
  uint64_t v5 = &v7;
  if (*(unsigned char *)(v4 + 18))
  {
    LOWORD(v7) = 32126;
    uint64_t v5 = (int *)((char *)&v7 + 2);
    *(unsigned char *)(v4 + 18) = 0;
  }
  *(unsigned char *)uint64_t v5 = **(unsigned char **)(v3 + 40);
  return ucnv_cbFromUWriteBytes(a1, (char *)&v7, v5 - (&vars0 - 4) + 1, a2, a3);
}

uint64_t sub_18C869D0C(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (*a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = *(long long **)(a1 + 16);
    long long v6 = *v5;
    *(void *)(a2 + 592) = *((void *)v5 + 2);
    *(_OWORD *)(a2 + 576) = v6;
    *(void *)(a2 + 16) = a2 + 576;
    *(unsigned char *)(a2 + 62) = 1;
    int v8 = 288;
    **(void **)(a2 + 16) = ucnv_safeClone(**(void (****)(void, void, void, void, void, void, void))(a1 + 16), a2 + 288, &v8, a4);
  }
  else
  {
    uint64_t v4 = 0;
    *a3 = 600;
  }
  return v4;
}

uint64_t sub_18C869DAC(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  ((void (*)(uint64_t, void, uint64_t))a2[2])(*a2, 0, 127);
  uint64_t v8 = *(void *)(**(void **)(a1 + 16) + 48);

  return sub_18C86BE98(v8, a2, a3, 5, a4);
}

void sub_18C869E20(uint64_t a1, uint64_t a2, int *a3)
{
  if (!*(unsigned char *)(a2 + 8))
  {
    long long v6 = (char *)uprv_malloc(0x30uLL);
    *(void *)(a1 + 16) = v6;
    if (v6)
    {
      *(_DWORD *)long long v6 = 65534;
      *(_DWORD *)(a1 + 72) = 0xFFFF;
      v6[25] = 0;
      int v7 = *(_DWORD *)(a2 + 12);
      if ((v7 & 0xFu) <= 8)
      {
        uint64_t v8 = &dword_18CA80BDC[3 * (v7 & 0xF)];
        __int16 v9 = *(_WORD *)v8;
        *(void *)(v6 + 26) = *(void *)"ISCII,version=";
        unint64_t v10 = v6 + 26;
        v9 <<= 7;
        *((_WORD *)v6 + 2) = v9;
        *((_WORD *)v6 + 4) = v9;
        *((_WORD *)v6 + 3) = v9;
        LODWORD(v8) = v8[1];
        *((_DWORD *)v6 + 5) = v8;
        *((_DWORD *)v6 + 4) = v8;
        *((_DWORD *)v6 + 3) = v8;
        v6[24] = 1;
        strcpy(v6 + 33, "ersion=");
        int v11 = strlen(v6 + 26);
        v10[v11] = v7 & 0xF | 0x30;
        v10[v11 + 1] = 0;
        *(_DWORD *)(v10 + 18) = 0;
        return;
      }
      uprv_free(v6);
      *(void *)(a1 + 16) = 0;
      int v12 = 1;
    }
    else
    {
      int v12 = 7;
    }
    *a3 = v12;
  }
}

void sub_18C869F24(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    if (!*(unsigned char *)(a1 + 62)) {
      uprv_free(v2);
    }
    *(void *)(a1 + 16) = 0;
  }
}

uint64_t sub_18C869F5C(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (a2 >= 2)
  {
    int v4 = *(_DWORD *)(v2 + 20);
    __int16 v3 = *(_WORD *)(v2 + 4);
    goto LABEL_5;
  }
  *(void *)(result + 72) = 0xFFFFLL;
  __int16 v3 = *(_WORD *)(v2 + 4);
  *(_WORD *)(v2 + 8) = v3;
  int v4 = *(_DWORD *)(v2 + 20);
  *(_DWORD *)(v2 + 16) = v4;
  *(_WORD *)uint64_t v2 = -2;
  *(_DWORD *)(v2 + 44) = 0;
  if (a2 != 1)
  {
LABEL_5:
    *(_DWORD *)(result + 84) = 0;
    *(_WORD *)(v2 + 2) = 0;
    *(_DWORD *)(v2 + 12) = v4;
    *(_WORD *)(v2 + 6) = v3;
    *(_WORD *)(v2 + 24) = 1;
  }
  return result;
}

uint64_t sub_18C869FBC(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (!v2)
  {
    *a2 = 1;
    return result;
  }
  unint64_t v3 = *(void *)(result + 24);
  int v4 = *(__int16 **)(result + 32);
  unint64_t v5 = *(void *)(result + 16);
  long long v6 = *(__int16 **)(v2 + 16);
  int v7 = *a2;
  if (*a2 > 0 || v5 >= v3)
  {
    uint64_t v9 = *(void *)(result + 8);
    unint64_t v13 = *(void *)(result + 16);
    goto LABEL_210;
  }
  int v10 = ~*(_DWORD *)(result + 16);
  int v11 = -*(_DWORD *)(result + 16);
  unint64_t v12 = *(void *)(result + 40);
  unint64_t v13 = *(void *)(result + 16);
  while (2)
  {
    uint64_t v14 = 0;
    while (1)
    {
      if ((unint64_t)v4 >= v12)
      {
        *a2 = 15;
        goto LABEL_211;
      }
      uint64_t v15 = v14;
      uint64_t v16 = *(unsigned __int8 *)(v13 + v14);
      int v17 = (unsigned __int16)*v6;
      if (v17 != 239) {
        break;
      }
      if ((v16 - 66) <= 9)
      {
        char v18 = (_WORD *)((char *)&unk_18CA80C48 + 4 * (v16 & 0xF));
        _OWORD v6[4] = *v18 << 7;
        int v19 = (unsigned __int16)v18[1];
LABEL_16:
        *((_DWORD *)v6 + 4) = v19;
        goto LABEL_18;
      }
      if (v16 == 64)
      {
        _OWORD v6[4] = v6[2];
        int v19 = *((_DWORD *)v6 + 5);
        goto LABEL_16;
      }
      if ((v16 - 33) >= 0x1F)
      {
        *a2 = 12;
        *long long v6 = -2;
        goto LABEL_209;
      }
LABEL_18:
      *long long v6 = -2;
      uint64_t v14 = v15 + 1;
      if (v13 + v15 + 1 >= v3)
      {
        v13 += v15 + 1;
        goto LABEL_204;
      }
    }
    if (v17 == 217)
    {
      int v27 = *((_DWORD *)v6 + 11);
      if (v27)
      {
        *v4++ = v27;
        char v28 = *(_DWORD **)(result + 48);
        if (v28)
        {
          *char v28 = v13 - v5 + v15;
          *(void *)(result + 48) = v28 + 1;
        }
        *((_DWORD *)v6 + 11) = 0;
      }
      if (v16 == 232) {
        __int16 v29 = 32;
      }
      else {
        __int16 v29 = 8205;
      }
      if ((unint64_t)v4 >= v12)
      {
        uint64_t v31 = *(char *)(v2 + 93);
        *(unsigned char *)(v2 + 93) = v31 + 1;
        *(_WORD *)(v2 + 2 * v31 + 144) = v29;
        int v7 = 15;
        *a2 = 15;
      }
      else
      {
        *v4++ = v29;
        uint64_t v30 = *(_DWORD **)(result + 48);
        if (v30)
        {
          _DWORD *v30 = ~v5 + v13 + v15;
          *(void *)(result + 48) = v30 + 1;
        }
      }
      int v17 = 65534;
      *long long v6 = -2;
LABEL_52:
      if ((int)v16 <= 223)
      {
        if (v16 == 10 || v16 == 13)
        {
          *((unsigned char *)v6 + 25) = 1;
          int v24 = word_18CA80C78[v16];
          __int16 v35 = v16;
        }
        else
        {
          if (v16 == 217)
          {
LABEL_59:
            *long long v6 = v16;
            int v32 = *(_DWORD *)(v2 + 72);
            if (v32 == 0xFFFF) {
              goto LABEL_172;
            }
            int v33 = *((_DWORD *)v6 + 11);
            if (v33)
            {
              if ((unint64_t)v4 >= v12)
              {
                uint64_t v37 = *(char *)(v2 + 93);
                *(unsigned char *)(v2 + 93) = v37 + 1;
                *(_WORD *)(v2 + 2 * v37 + 144) = v33;
                int v7 = 15;
                *a2 = 15;
              }
              else
              {
                *v4++ = v33;
                uint64_t v34 = *(_DWORD **)(result + 48);
                if (v34)
                {
                  *uint64_t v34 = v11 + v13 + v15;
                  *(void *)(result + 48) = v34 + 1;
                }
              }
              *((_DWORD *)v6 + 11) = 0;
              int v32 = *(_DWORD *)(v2 + 72);
            }
            if (v32 >= 161 && (v32 - 2404) >= 2 && (v32 - 8204) >= 2) {
              LOWORD(v32) = v32 + v6[4];
            }
            if ((unint64_t)v4 >= v12)
            {
              uint64_t v39 = *(char *)(v2 + 93);
              *(unsigned char *)(v2 + 93) = v39 + 1;
              *(_WORD *)(v2 + 2 * v39 + 144) = v32;
              int v7 = 15;
              *a2 = 15;
            }
            else
            {
              *v4++ = v32;
              uint64_t v38 = *(_DWORD **)(result + 48);
              if (v38)
              {
                *uint64_t v38 = v10 + v13 + v15;
                *(void *)(result + 48) = v38 + 1;
              }
            }
            goto LABEL_164;
          }
LABEL_113:
          int v24 = word_18CA80C78[v16];
          if (v16 >= 0xA1
            && (*((_DWORD *)v6 + 4) & byte_18CA80EB8[v24 & 0x7F]) == 0
            && (v16 != 208 || v6[4] != 768))
          {
            int v24 = 0xFFFF;
          }
          __int16 v35 = v16;
        }
      }
      else
      {
        switch((int)v16)
        {
          case 232:
            if (v17 == 232)
            {
              int v24 = 8204;
              goto LABEL_71;
            }
            if (*((unsigned char *)v6 + 16)) {
              int v24 = 2381;
            }
            else {
              int v24 = 0xFFFF;
            }
            __int16 v35 = 232;
            break;
          case 233:
            if (v17 == 232)
            {
              int v24 = 8205;
LABEL_71:
              __int16 v35 = -2;
              break;
            }
            int v40 = (unsigned __int16)v6[4];
            if (v17 != 192 || v40 != 256)
            {
              uint64_t v43 = 0;
              while (1)
              {
                uint64_t v44 = (char *)&unk_18CA80E78 + v43;
                if (*(_WORD *)((char *)&unk_18CA80E78 + v43 + 4) == v17) {
                  break;
                }
                v43 += 4;
                if (v43 == 60) {
                  goto LABEL_113;
                }
              }
              int v24 = *((unsigned __int16 *)v44 + 3);
              if ((*((_DWORD *)v6 + 4) & byte_18CA80EB8[*((_WORD *)v44 + 3)]) == 0) {
                goto LABEL_113;
              }
              *long long v6 = -2;
              *(_DWORD *)(v2 + 72) = 0xFFFF;
              if (v40 != 256) {
                goto LABEL_169;
              }
              int v45 = *((_DWORD *)v6 + 11);
              if (v45)
              {
                if ((unint64_t)v4 >= v12)
                {
                  uint64_t v73 = *(char *)(v2 + 93);
                  *(unsigned char *)(v2 + 93) = v73 + 1;
                  *(_WORD *)(v2 + 2 * v73 + 144) = v45;
                  int v7 = 15;
                  *a2 = 15;
                }
                else
                {
                  *v4++ = v45;
                  uint64_t v46 = *(_DWORD **)(result + 48);
                  if (v46)
                  {
                    _DWORD *v46 = v11 + v13 + v15;
                    *(void *)(result + 48) = v46 + 1;
                  }
                }
                *((_DWORD *)v6 + 11) = 0;
              }
              if ((v24 - 2404) >= 2 && (v24 - 8204) >= 2) {
                LOWORD(v24) = v24 + 256;
              }
              if ((unint64_t)v4 >= v12) {
                goto LABEL_230;
              }
              *v4++ = v24;
              int v25 = *(_DWORD **)(result + 48);
              if (v25)
              {
                int v26 = v10 + v13 + v15;
LABEL_39:
                *int v25 = v26;
                *(void *)(result + 48) = v25 + 1;
              }
LABEL_172:
              v13 += v15 + 1;
              if (v7 > 0 || v13 >= v3)
              {
LABEL_204:
                uint64_t v9 = v2;
LABEL_210:
                if (v7 <= 0 && *(unsigned char *)(result + 2) && v13 == v3)
                {
                  int v77 = (unsigned __int16)*v6;
                  if ((v77 - 217) > 0x17 || ((1 << (v77 + 39)) & 0xC00001) == 0)
                  {
                    *(unsigned char *)(v9 + 64) = 0;
                  }
                  else
                  {
                    *(unsigned char *)(v9 + 65) = v77;
                    *(unsigned char *)(v9 + 64) = 1;
                    *long long v6 = -2;
                  }
                  int v79 = *(_DWORD *)(v2 + 72);
                  if (v79 != 0xFFFF)
                  {
                    if (v79 >= 161 && (v79 - 2404) >= 2 && (v79 - 8204) >= 2) {
                      LOWORD(v79) = v79 + v6[4];
                    }
                    if ((unint64_t)v4 >= *(void *)(result + 40))
                    {
                      uint64_t v81 = *(void *)(result + 8);
                      uint64_t v82 = *(char *)(v81 + 93);
                      *(unsigned char *)(v81 + 93) = v82 + 1;
                      *(_WORD *)(v81 + 2 * v82 + 144) = v79;
                      *a2 = 15;
                    }
                    else
                    {
                      *v4++ = v79;
                      uint64_t v80 = *(_DWORD **)(result + 48);
                      if (v80)
                      {
                        _DWORD *v80 = ~*(_DWORD *)(result + 16) + v3;
                        *(void *)(result + 48) = v80 + 1;
                      }
                    }
                    *(_DWORD *)(v2 + 72) = 0xFFFF;
                  }
                }
                goto LABEL_211;
              }
              continue;
            }
            int v41 = *((_DWORD *)v6 + 11);
            if (v41)
            {
              if ((unint64_t)v4 >= v12)
              {
                uint64_t v65 = *(char *)(v2 + 93);
                *(unsigned char *)(v2 + 93) = v65 + 1;
                *(_WORD *)(v2 + 2 * v65 + 144) = v41;
                int v7 = 15;
                *a2 = 15;
              }
              else
              {
                *v4++ = v41;
                uint64_t v42 = *(_DWORD **)(result + 48);
                if (v42)
                {
                  *uint64_t v42 = v11 + v13 + v15;
                  *(void *)(result + 48) = v42 + 1;
                }
              }
              *((_DWORD *)v6 + 11) = 0;
            }
            if ((unint64_t)v4 >= v12)
            {
              uint64_t v70 = *(char *)(v2 + 93);
              *(unsigned char *)(v2 + 93) = v70 + 1;
              *(_WORD *)(v2 + 2 * v70 + 144) = 2652;
              int v7 = 15;
              *a2 = 15;
              uint64_t v66 = v4;
            }
            else
            {
              *int v4 = 2652;
              uint64_t v66 = v4 + 1;
              uint64_t v67 = *(_DWORD **)(result + 48);
              if (v67)
              {
                *uint64_t v67 = v10 + v13 + v15;
                *(void *)(result + 48) = v67 + 1;
              }
              if (v7 <= 0)
              {
                if ((unint64_t)v66 >= v12)
                {
                  uint64_t v72 = *(char *)(v2 + 93);
                  *(_WORD *)(v2 + 144 + 2 * v72) = 2637;
                  int v7 = 15;
                  *a2 = 15;
                  *(unsigned char *)(v2 + 93) = v72 + 2;
                  *(_WORD *)(v2 + 144 + 2 * (char)(v72 + 1)) = 2617;
                }
                else
                {
                  v4[1] = 2637;
                  uint64_t v68 = *(_DWORD **)(result + 48);
                  if (v68)
                  {
                    *uint64_t v68 = v10 + v13 + v15;
                    *(void *)(result + 48) = v68 + 1;
                  }
                  uint64_t v66 = v4 + 2;
                  if ((unint64_t)(v4 + 2) >= v12)
                  {
                    uint64_t v75 = *(char *)(v2 + 93);
                    *(unsigned char *)(v2 + 93) = v75 + 1;
                    *(_WORD *)(v2 + 2 * v75 + 144) = 2617;
                    int v7 = 15;
                    *a2 = 15;
                  }
                  else
                  {
                    uint64_t v66 = v4 + 3;
                    v4[2] = 2617;
                    uint64_t v69 = *(_DWORD **)(result + 48);
                    if (v69)
                    {
                      *uint64_t v69 = v10 + v13 + v15;
                      *(void *)(result + 48) = v69 + 1;
                    }
                  }
                }
                goto LABEL_189;
              }
            }
            uint64_t v71 = *(char *)(v2 + 93);
            *(_WORD *)(v2 + 144 + 2 * v71) = 2637;
            *(unsigned char *)(v2 + 93) = v71 + 2;
            *(_WORD *)(v2 + 144 + 2 * (char)(v71 + 1)) = 2617;
LABEL_189:
            *(_DWORD *)(v2 + 72) = 0xFFFF;
            *long long v6 = -2;
            int v4 = v66;
            goto LABEL_172;
          case 234:
            if (v17 == 234)
            {
              int v24 = 2405;
              goto LABEL_74;
            }
            if ((v6[8] & 0x80) != 0) {
              int v24 = 2404;
            }
            else {
              int v24 = 0xFFFF;
            }
            __int16 v35 = 234;
            break;
          case 235:
          case 236:
          case 237:
          case 238:
            goto LABEL_113;
          case 239:
          case 240:
            goto LABEL_59;
          default:
            if (v16 != 224) {
              goto LABEL_113;
            }
            int v36 = *((_DWORD *)v6 + 4);
            if (v17 == 164 && (v36 & 0x80) != 0)
            {
              int v24 = 2308;
LABEL_74:
              *long long v6 = -2;
              goto LABEL_170;
            }
            if ((v36 & 0x87) != 0) {
              int v24 = 2374;
            }
            else {
              int v24 = 0xFFFF;
            }
            __int16 v35 = 224;
            break;
        }
      }
      *long long v6 = v35;
      int v48 = *(_DWORD *)(v2 + 72);
      if (v48 == 0xFFFF) {
        goto LABEL_169;
      }
      int v49 = (unsigned __int16)v6[4];
      int v50 = *((_DWORD *)v6 + 11);
      if (v49 != 256 || (v50 - 2560) > 0x4F)
      {
        if (!v50) {
          goto LABEL_139;
        }
        goto LABEL_134;
      }
      if (v48 != 2381 || ((byte_18CA80F38[v50 - 2560] & 1) != 0 ? (BOOL v51 = v24 + 256 == v50) : (BOOL v51 = 0), !v51))
      {
LABEL_134:
        if ((unint64_t)v4 >= v12)
        {
          uint64_t v55 = *(char *)(v2 + 93);
          *(unsigned char *)(v2 + 93) = v55 + 1;
          *(_WORD *)(v2 + 2 * v55 + 144) = v50;
          int v7 = 15;
          *a2 = 15;
        }
        else
        {
          *v4++ = v50;
          unint64_t v54 = *(_DWORD **)(result + 48);
          if (v54)
          {
            *unint64_t v54 = v11 + v13 + v15;
            *(void *)(result + 48) = v54 + 1;
          }
        }
        *((_DWORD *)v6 + 11) = 0;
LABEL_139:
        if (v49 == 256 && v24 == 2306)
        {
          int v56 = *(_DWORD *)(v2 + 72);
          if ((v56 - 2384) >= 0xFFFFFFB0 && byte_18CA80F38[v56 - 2304] >= 2u)
          {
            __int16 v57 = v56 + 256;
            if ((unint64_t)v4 >= v12)
            {
              uint64_t v64 = *(char *)(v2 + 93);
              *(unsigned char *)(v2 + 93) = v64 + 1;
              *(_WORD *)(v2 + 2 * v64 + 144) = v57;
              int v7 = 15;
              *a2 = 15;
            }
            else
            {
              *v4++ = v57;
              unsigned __int8 v58 = *(_DWORD **)(result + 48);
              if (v58)
              {
                *unsigned __int8 v58 = v10 + v13 + v15;
                *(void *)(result + 48) = v58 + 1;
              }
            }
            int v24 = 2416;
            goto LABEL_168;
          }
        }
        else
        {
          int v56 = *(_DWORD *)(v2 + 72);
          if (v49 == 256
            && v24 == 2381
            && (v56 - 2384) >= 0xFFFFFFB0
            && (byte_18CA80F38[v56 - 2304] & 1) != 0)
          {
            *((_DWORD *)v6 + 11) = v56 + 256;
            int v24 = 2381;
LABEL_168:
            *(_DWORD *)(v2 + 72) = 0xFFFF;
LABEL_169:
            if (v24 == 0xFFFF) {
              goto LABEL_206;
            }
LABEL_170:
            *(_DWORD *)(v2 + 72) = v24;
            if (*((unsigned char *)v6 + 25))
            {
              _OWORD v6[4] = v6[2];
              *((_DWORD *)v6 + 4) = *((_DWORD *)v6 + 5);
              *((unsigned char *)v6 + 25) = 0;
            }
            goto LABEL_172;
          }
        }
        if (v56 >= 161 && (v56 - 2404) >= 2 && (v56 - 8204) >= 2)
        {
          v56 += v49;
          *(_DWORD *)(v2 + 72) = v56;
        }
        if ((unint64_t)v4 >= v12)
        {
          uint64_t v60 = *(char *)(v2 + 93);
          *(unsigned char *)(v2 + 93) = v60 + 1;
          *(_WORD *)(v2 + 2 * v60 + 144) = v56;
          int v7 = 15;
          *a2 = 15;
        }
        else
        {
          *v4++ = v56;
          int v59 = *(_DWORD **)(result + 48);
          if (v59)
          {
            _DWORD *v59 = v10 + v13 + v15;
            *(void *)(result + 48) = v59 + 1;
          }
        }
        goto LABEL_168;
      }
      int v52 = -2 - v5 + v13 + v15;
      if ((unint64_t)v4 >= v12)
      {
        uint64_t v61 = *(char *)(v2 + 93);
        *(unsigned char *)(v2 + 93) = v61 + 1;
        *(_WORD *)(v2 + 2 * v61 + 144) = 2673;
        int v7 = 15;
        *a2 = 15;
      }
      else
      {
        *v4++ = 2673;
        unint64_t v53 = *(_DWORD **)(result + 48);
        if (v53)
        {
          *unint64_t v53 = v52;
          *(void *)(result + 48) = v53 + 1;
          int v50 = *((_DWORD *)v6 + 11);
        }
      }
      if ((unint64_t)v4 >= v12)
      {
        uint64_t v63 = *(char *)(v2 + 93);
        *(unsigned char *)(v2 + 93) = v63 + 1;
        *(_WORD *)(v2 + 2 * v63 + 144) = v50;
        int v7 = 15;
        *a2 = 15;
      }
      else
      {
        *v4++ = v50;
        char v62 = *(_DWORD **)(result + 48);
        if (v62)
        {
          *char v62 = v52;
          *(void *)(result + 48) = v62 + 1;
        }
      }
      *((_DWORD *)v6 + 11) = 0;
LABEL_164:
      *(_DWORD *)(v2 + 72) = 0xFFFF;
      goto LABEL_172;
    }
    break;
  }
  if (v17 != 240) {
    goto LABEL_52;
  }
  if ((v16 + 95) > 0x4Du)
  {
    *long long v6 = -2;
    int v76 = 12;
LABEL_208:
    *a2 = v76;
LABEL_209:
    *(unsigned char *)(v2 + 65) = v16;
    uint64_t v9 = *(void *)(result + 8);
    *(unsigned char *)(v9 + 64) = 1;
    int v7 = *a2;
    v13 += v15 + 1;
    goto LABEL_210;
  }
  if (v16 != 191 && v16 != 184
    || (v16 != 191 ? (__int16 v20 = 2386) : (__int16 v20 = 2416),
        v16 != 191 ? (char v21 = 82) : (char v21 = 112),
        (*((_DWORD *)v6 + 4) & byte_18CA80EB8[v21 & 0xFE]) == 0))
  {
LABEL_206:
    int v76 = 10;
    goto LABEL_208;
  }
  *long long v6 = -2;
  int v22 = *((_DWORD *)v6 + 11);
  if (v22)
  {
    *v4++ = v22;
    uint64_t v23 = *(_DWORD **)(result + 48);
    if (v23)
    {
      *uint64_t v23 = v13 - v5 + v15;
      *(void *)(result + 48) = v23 + 1;
    }
    *((_DWORD *)v6 + 11) = 0;
  }
  LOWORD(v24) = v6[4] + v20;
  if ((unint64_t)v4 < v12)
  {
    *v4++ = v24;
    int v25 = *(_DWORD **)(result + 48);
    if (v25)
    {
      int v26 = ~v5 + v13 + v15;
      goto LABEL_39;
    }
    goto LABEL_172;
  }
LABEL_230:
  uint64_t v83 = *(char *)(v2 + 93);
  *(unsigned char *)(v2 + 93) = v83 + 1;
  *(_WORD *)(v2 + 2 * v83 + 144) = v24;
  *a2 = 15;
  v13 += v15 + 1;
LABEL_211:
  *(void *)(result + 32) = v4;
  *(void *)(result + 16) = v13;
  return result;
}

void *sub_18C86AB68(void *result, int *a2)
{
  unint64_t v2 = result[3];
  unint64_t v3 = (unsigned char *)result[4];
  unint64_t v4 = result[5];
  uint64_t v5 = result[1];
  long long v6 = (unsigned __int16 *)result[2];
  if (v5) {
    BOOL v7 = v4 >= (unint64_t)v3;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7 || v2 < (unint64_t)v6)
  {
    *a2 = 1;
    return result;
  }
  unsigned int v9 = *(_DWORD *)(v5 + 84);
  if (v9)
  {
    int v10 = (unsigned char *)result[4];
LABEL_11:
    if ((unint64_t)v6 >= v2)
    {
      int v14 = 0;
    }
    else
    {
      int v11 = *v6;
      BOOL v12 = (v11 & 0xFC00) == 56320;
      int v13 = v11 + (v9 << 10) - 56613888;
      if ((v11 & 0xFC00) == 0xDC00) {
        int v14 = 10;
      }
      else {
        int v14 = 12;
      }
      v6 += v12;
      if (v12) {
        unsigned int v9 = v13;
      }
    }
LABEL_119:
    *a2 = v14;
    *(_DWORD *)(result[1] + 84) = v9;
    goto LABEL_139;
  }
  if ((unint64_t)v6 >= v2) {
    goto LABEL_138;
  }
  uint64_t v15 = *(void *)(v5 + 16);
  int v16 = *(unsigned __int16 *)(v15 + 6) >> 7;
  int v17 = (_DWORD *)result[6];
  while (2)
  {
    uint64_t v18 = 0;
    int v19 = v6;
    while (1)
    {
      uint64_t v20 = v18;
      uint64_t v21 = result[1];
      if (*(_DWORD *)(v21 + 80) == 10)
      {
        int v22 = dword_18CA80BDC[3 * (unsigned __int16)v16 + 2];
        *(_DWORD *)(v21 + 80) = 0;
        long long v6 = (unsigned __int16 *)((char *)v19 + v20);
        if ((unint64_t)v3 >= v4)
        {
          uint64_t v49 = *(char *)(v21 + 91);
          *(unsigned char *)(v21 + 91) = v49 + 1;
          *(unsigned char *)(v21 + v49 + 104) = -17;
          uint64_t v50 = result[1];
          uint64_t v51 = *(char *)(v50 + 91);
          *(unsigned char *)(v50 + 91) = v51 + 1;
          *(unsigned char *)(v50 + v51 + 104) = v22;
          *a2 = 15;
          goto LABEL_138;
        }
        uint64_t v23 = result[2];
        *unint64_t v3 = -17;
        int v10 = v3 + 1;
        if (v17)
        {
          int v24 = (((unint64_t)v6 - v23) >> 1) - 1;
          *int v17 = v24;
          if ((unint64_t)v10 >= v4) {
            goto LABEL_121;
          }
          *int v10 = v22;
          v17[1] = v24;
          v17 += 2;
        }
        else
        {
          if ((unint64_t)v10 >= v4)
          {
LABEL_121:
            uint64_t v52 = result[1];
            uint64_t v53 = *(char *)(v52 + 91);
            *(unsigned char *)(v52 + 91) = v53 + 1;
            *(unsigned char *)(v52 + v53 + 104) = v22;
            *a2 = 15;
            long long v6 = (unsigned __int16 *)((char *)v19 + v20);
            goto LABEL_139;
          }
          int v17 = 0;
          *int v10 = v22;
        }
        v3 += 2;
        if (*a2 > 0)
        {
          long long v6 = (unsigned __int16 *)((char *)v19 + v20);
          goto LABEL_138;
        }
      }
      unsigned int v9 = *(unsigned __int16 *)((char *)v19 + v20);
      if (v9 <= 0xA0)
      {
        uint64_t v25 = result[1];
        *(_DWORD *)(v25 + 80) = v9;
        int v26 = (char *)v19 + v20;
        if ((unint64_t)v3 >= v4)
        {
          uint64_t v54 = *(char *)(v25 + 91);
          *(unsigned char *)(v25 + 91) = v54 + 1;
          *(unsigned char *)(v25 + v54 + 104) = v9;
          *a2 = 15;
          long long v6 = (unsigned __int16 *)(v26 + 2);
          goto LABEL_138;
        }
        uint64_t v27 = result[2];
        *v3++ = v9;
        if (v17) {
          *v17++ = ((unint64_t)&v26[-v27 + 2] >> 1) - 1;
        }
        if (*a2 >= 1) {
          goto LABEL_137;
        }
        goto LABEL_37;
      }
      int v28 = *(unsigned __int16 *)(v15 + 2);
      if (v9 != 8204) {
        break;
      }
      *(_WORD *)(v15 + 2) = 0;
      if (v28)
      {
        unsigned int v9 = 8204;
        unsigned int v29 = 232;
        goto LABEL_78;
      }
LABEL_37:
      uint64_t v18 = v20 + 2;
      if ((unint64_t)v19 + v20 + 2 >= v2) {
        goto LABEL_137;
      }
    }
    if (v9 != 8205)
    {
      if (v9 - 2304 > 0x47F)
      {
        unsigned int v29 = 0xFFFF;
        goto LABEL_58;
      }
      if (v9 - 2406 > 0xFFFFFFFD)
      {
        int v32 = 0;
      }
      else
      {
        if ((int)(v9 - 2304) >= 0) {
          int v30 = v9 - 2304;
        }
        else {
          int v30 = v9 - 2177;
        }
        int v16 = v30 >> 7;
        unsigned __int16 v31 = v30 & 0xFF80;
        if ((v30 & 0xFF80) == *(unsigned __int16 *)(v15 + 6) && !*(unsigned char *)(v15 + 24))
        {
          int v32 = 0;
        }
        else
        {
          *(_WORD *)(v15 + 6) = v31;
          *(_DWORD *)(v15 + 12) = dword_18CA80BDC[3 * (unsigned __int16)(v30 >> 7) + 1];
          *(unsigned char *)(v15 + 24) = 0;
          int v32 = 1;
        }
        if ((v30 & 0xFF80) == 0x100)
        {
          if (v9 == 2672)
          {
            unsigned int v9 = 2562;
          }
          else if (v9 == 2673)
          {
            unsigned int v9 = 2673;
            *(_WORD *)(v15 + 2) = 2673;
          }
        }
        v9 -= v31;
      }
      unsigned __int16 v33 = word_18CA80F88[v9];
      if ((*(_DWORD *)(v15 + 12) & byte_18CA80EB8[v9]) == 0
        && (*(_WORD *)(v15 + 6) != 768 || v9 != 2353))
      {
        unsigned __int16 v33 = -1;
      }
      unsigned int v29 = v33;
      if (!v32)
      {
LABEL_101:
        if (v9 == 2417 && *(_WORD *)(v15 + 6) == 256)
        {
LABEL_113:
          long long v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
          if ((unint64_t)v6 < v2) {
            continue;
          }
          goto LABEL_137;
        }
LABEL_58:
        *(_WORD *)(v15 + 2) = 0;
        goto LABEL_78;
      }
      int v35 = dword_18CA80BDC[3 * (unsigned __int16)v16 + 2];
      if ((unint64_t)v3 >= v4)
      {
        uint64_t v38 = result[1];
        uint64_t v39 = *(char *)(v38 + 91);
        *(unsigned char *)(v38 + 91) = v39 + 1;
        *(unsigned char *)(v38 + v39 + 104) = -17;
        uint64_t v40 = result[1];
        uint64_t v41 = *(char *)(v40 + 91);
        *(unsigned char *)(v40 + 91) = v41 + 1;
        *(unsigned char *)(v40 + v41 + 104) = v35;
        *a2 = 15;
        goto LABEL_78;
      }
      uint64_t v36 = result[2];
      *unint64_t v3 = -17;
      int v10 = v3 + 1;
      if (v17)
      {
        int v37 = (((unint64_t)v19 + v20 - v36 + 2) >> 1) - 1;
        *int v17 = v37;
        if ((unint64_t)v10 < v4)
        {
          *int v10 = v35;
          v17[1] = v37;
          v17 += 2;
          goto LABEL_77;
        }
        ++v17;
      }
      else
      {
        if ((unint64_t)v10 < v4)
        {
          int v17 = 0;
          *int v10 = v35;
LABEL_77:
          v3 += 2;
          if (*a2 > 0) {
            goto LABEL_78;
          }
          goto LABEL_101;
        }
        int v17 = 0;
      }
      uint64_t v47 = result[1];
      uint64_t v48 = *(char *)(v47 + 91);
      *(unsigned char *)(v47 + 91) = v48 + 1;
      *(unsigned char *)(v47 + v48 + 104) = v35;
      *a2 = 15;
      goto LABEL_79;
    }
    break;
  }
  if (*(_WORD *)(v15 + 2)) {
    unsigned int v29 = 233;
  }
  else {
    unsigned int v29 = 217;
  }
  *(_WORD *)(v15 + 2) = 0;
  unsigned int v9 = 8205;
LABEL_78:
  int v10 = v3;
LABEL_79:
  if (*(_WORD *)(v15 + 6) == 256 && v28 == 2673 && v9 - 2384 >= 0xFFFFFFB0 && (byte_18CA80F38[v9 - 2304] & 1) != 0)
  {
    *(_WORD *)(v15 + 2) = 0;
    int v43 = v29 | (v29 << 16);
    unsigned int v44 = v43 | 0xE800;
    if ((unint64_t)v10 >= v4)
    {
      uint64_t v56 = result[1];
      long long v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
      if ((v43 & 0xFF0000) != 0)
      {
        uint64_t v57 = *(char *)(v56 + 91);
        *(unsigned char *)(v56 + 91) = v57 + 1;
        *(unsigned char *)(v56 + v57 + 104) = BYTE2(v43);
        uint64_t v56 = result[1];
      }
      uint64_t v58 = *(char *)(v56 + 91);
      *(unsigned char *)(v56 + 91) = v58 + 1;
      *(unsigned char *)(v56 + v58 + 104) = BYTE1(v44);
      uint64_t v59 = result[1];
      uint64_t v60 = *(char *)(v59 + 91);
      *(unsigned char *)(v59 + 91) = v60 + 1;
      *(unsigned char *)(v59 + v60 + 104) = v29;
      *a2 = 15;
      goto LABEL_139;
    }
    unint64_t v45 = ((unint64_t)v19 + v20 - result[2] + 2) >> 1;
    int v46 = v45 - 1;
    if (v44 >= 0x10000)
    {
      *v10++ = BYTE2(v43);
      if (!v17)
      {
        if ((unint64_t)v10 < v4)
        {
          int v17 = 0;
          *int v10 = BYTE1(v44);
LABEL_108:
          if ((unint64_t)(v10 + 1) >= v4)
          {
            uint64_t v65 = result[1];
            uint64_t v66 = *(char *)(v65 + 91);
            *(unsigned char *)(v65 + 91) = v66 + 1;
            *(unsigned char *)(v65 + v66 + 104) = v29;
            *a2 = 15;
            long long v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
            ++v10;
            goto LABEL_139;
          }
          v10[1] = v29;
          if (v17) {
            *v17++ = v46;
          }
          unint64_t v3 = v10 + 2;
          goto LABEL_112;
        }
LABEL_132:
        unsigned int v55 = v44 >> 8;
        goto LABEL_133;
      }
      int v46 = v45 - 2;
      *v17++ = v45 - 2;
    }
    if ((unint64_t)v10 < v4)
    {
      *int v10 = BYTE1(v44);
      if (v17) {
        *v17++ = v46;
      }
      goto LABEL_108;
    }
    goto LABEL_132;
  }
  if (v29 == 232)
  {
    *(_WORD *)(v15 + 2) = 232;
    if ((unint64_t)v10 < v4)
    {
      int v42 = (((unint64_t)v19 + v20 - result[2] + 2) >> 1) - 1;
LABEL_92:
      *int v10 = v29;
      unint64_t v3 = v10 + 1;
      if (v17) {
        *v17++ = v42;
      }
      goto LABEL_112;
    }
    goto LABEL_134;
  }
  if (v29 == 0xFFFF)
  {
    long long v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
    if (v9 >> 11 == 27)
    {
      if ((v9 & 0x400) == 0) {
        goto LABEL_11;
      }
      int v14 = 12;
    }
    else
    {
      int v14 = 10;
    }
    goto LABEL_119;
  }
  if ((unint64_t)v10 >= v4)
  {
    if ((v29 & 0xFF00) != 0)
    {
      unsigned int v55 = v29 >> 8;
LABEL_133:
      uint64_t v61 = result[1];
      uint64_t v62 = *(char *)(v61 + 91);
      *(unsigned char *)(v61 + 91) = v62 + 1;
      *(unsigned char *)(v61 + v62 + 104) = v55;
    }
LABEL_134:
    uint64_t v63 = result[1];
    uint64_t v64 = *(char *)(v63 + 91);
    *(unsigned char *)(v63 + 91) = v64 + 1;
    *(unsigned char *)(v63 + v64 + 104) = v29;
    *a2 = 15;
    long long v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
    goto LABEL_139;
  }
  int v42 = (((unint64_t)v19 + v20 - result[2] + 2) >> 1) - 1;
  if (v29 <= 0xFF) {
    goto LABEL_92;
  }
  *int v10 = BYTE1(v29);
  unint64_t v3 = v10 + 1;
  if (!v17)
  {
    if ((unint64_t)v3 >= v4) {
      goto LABEL_136;
    }
    int v17 = 0;
    unint64_t v3 = v10 + 2;
    v10[1] = v29;
LABEL_112:
    if (*a2 >= 1) {
      goto LABEL_137;
    }
    goto LABEL_113;
  }
  *int v17 = v42;
  if ((unint64_t)v3 < v4)
  {
    unint64_t v3 = v10 + 2;
    v10[1] = v29;
    v17[1] = v42;
    v17 += 2;
    goto LABEL_112;
  }
LABEL_136:
  uint64_t v67 = result[1];
  uint64_t v68 = *(char *)(v67 + 91);
  *(unsigned char *)(v67 + 91) = v68 + 1;
  *(unsigned char *)(v67 + v68 + 104) = v29;
  *a2 = 15;
LABEL_137:
  long long v6 = (unsigned __int16 *)((char *)v19 + v20 + 2);
LABEL_138:
  int v10 = v3;
LABEL_139:
  result[2] = v6;
  result[4] = v10;
  return result;
}

uint64_t sub_18C86B31C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return v1 + 26;
  }
  else {
    return 0;
  }
}

uint64_t sub_18C86B330(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (*a3)
  {
    unint64_t v4 = *(long long **)(a1 + 16);
    long long v5 = *v4;
    long long v6 = v4[2];
    *(_OWORD *)(a2 + 304) = v4[1];
    *(_OWORD *)(a2 + 320) = v6;
    *(_OWORD *)(a2 + 288) = v5;
    *(void *)(a2 + 16) = a2 + 288;
    *(unsigned char *)(a2 + 62) = 1;
  }
  else
  {
    a2 = 0;
    *a3 = 336;
  }
  return a2;
}

uint64_t sub_18C86B388(uint64_t a1, void *a2)
{
  ((void (*)(void, void, uint64_t))a2[2])(*a2, 0, 160);
  uint64_t v3 = 0;
  int v4 = 2304;
  do
  {
    uint64_t v5 = 0;
    int v6 = dword_18CA80BDC[3 * v3 + 1];
    do
    {
      BOOL v8 = v3 == 6 && v5 == 49;
      if ((v6 & byte_18CA80EB8[v5]) != 0 || v8) {
        ((void (*)(void, void))a2[1])(*a2, (v4 + v5));
      }
      ++v5;
    }
    while (v5 != 128);
    ++v3;
    v4 += 128;
  }
  while (v3 != 9);
  ((void (*)(void, uint64_t))a2[1])(*a2, 2404);
  ((void (*)(void, uint64_t))a2[1])(*a2, 2405);
  ((void (*)(void, uint64_t))a2[1])(*a2, 8204);
  uint64_t v10 = *a2;
  int v11 = (uint64_t (*)(uint64_t, uint64_t))a2[1];

  return v11(v10, 8205);
}

uint64_t sub_18C86B48C(uint64_t result, _DWORD *a2)
{
  unint64_t v2 = *(unsigned __int8 **)(result + 16);
  uint64_t v3 = *(_WORD **)(result + 32);
  uint64_t v4 = (*(void *)(result + 40) - (void)v3) >> 1;
  uint64_t v5 = *(void *)(result + 48);
  int v6 = *(_DWORD *)(result + 24) - v2;
  if (v6 > (int)v4)
  {
    *a2 = 15;
    int v6 = v4;
  }
  if (v6 < 8)
  {
    unsigned int v12 = 0;
  }
  else
  {
    unsigned int v7 = v6 >> 3;
    unsigned int v8 = (v6 >> 3) + 1;
    do
    {
      *uint64_t v3 = *v2;
      v3[1] = v2[1];
      v3[2] = v2[2];
      v3[3] = v2[3];
      v3[4] = v2[4];
      v3[5] = v2[5];
      v3[6] = v2[6];
      v3[7] = v2[7];
      v3 += 8;
      v2 += 8;
      --v8;
    }
    while (v8 > 1);
    v6 &= 7u;
    if (!v5)
    {
      if (!v6)
      {
        *(void *)(result + 16) = v2;
        *(void *)(result + 32) = v3;
        return result;
      }
      unsigned int v12 = 0;
      uint64_t v5 = 0;
      goto LABEL_12;
    }
    unsigned int v9 = 0;
    int v10 = v7 + 1;
    do
    {
      int8x16_t v11 = (int8x16_t)vdupq_n_s32(v9);
      *(_DWORD *)uint64_t v5 = v9;
      *(int8x16_t *)(v5 + 4) = vorrq_s8(v11, (int8x16_t)xmmword_18CA81090);
      *(int8x8_t *)(v5 + 20) = vorr_s8(*(int8x8_t *)v11.i8, (int8x8_t)0x600000005);
      unsigned int v12 = v9 + 8;
      *(_DWORD *)(v5 + 28) = v9 + 7;
      v5 += 32;
      --v10;
      v9 += 8;
    }
    while (v10 > 1);
  }
  if (v6 <= 0)
  {
    *(void *)(result + 16) = v2;
    *(void *)(result + 32) = v3;
    if (!v5) {
      return result;
    }
    goto LABEL_18;
  }
LABEL_12:
  unsigned int v13 = v6 + 1;
  do
  {
    __int16 v14 = *v2++;
    *v3++ = v14;
    --v13;
  }
  while (v13 > 1);
  *(void *)(result + 16) = v2;
  *(void *)(result + 32) = v3;
  if (v5)
  {
    do
    {
      *(_DWORD *)uint64_t v5 = v12;
      v5 += 4;
      ++v12;
      --v6;
    }
    while (v6);
LABEL_18:
    *(void *)(result + 48) = v5;
  }
  return result;
}

uint64_t sub_18C86B5F0(uint64_t result, int *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  unint64_t v2 = *(__int16 **)(result + 16);
  unint64_t v4 = *(void *)(result + 24);
  uint64_t v5 = *(unsigned char **)(result + 32);
  uint64_t v6 = *(void *)(result + 48);
  if (*(_UNKNOWN **)(v3 + 48) == &unk_1E5503220) {
    unsigned int v7 = 255;
  }
  else {
    unsigned int v7 = 127;
  }
  unsigned int v8 = *(_DWORD *)(v3 + 84);
  if (v8) {
    unsigned int v9 = -1;
  }
  else {
    unsigned int v9 = 0;
  }
  unint64_t v10 = (v4 - (unint64_t)v2) >> 1;
  if ((int)v10 >= *(_DWORD *)(result + 40) - (int)v5) {
    LODWORD(v10) = *(_DWORD *)(result + 40) - v5;
  }
  if (v8) {
    BOOL v11 = (int)v10 <= 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    int v32 = *(unsigned char **)(result + 32);
LABEL_19:
    if ((unint64_t)v2 >= v4)
    {
LABEL_40:
      *(_DWORD *)(v3 + 84) = v8;
      goto LABEL_41;
    }
    int v33 = (unsigned __int16)*v2;
    BOOL v34 = (v33 & 0xFC00) == 56320;
    int v35 = v33 + (v8 << 10) - 56613888;
    v2 += v34;
    if (v34) {
      unsigned int v8 = v35;
    }
LABEL_36:
    if (v8 >> 11 == 27) {
      int v43 = 12;
    }
    else {
      int v43 = 10;
    }
    *a2 = v43;
    goto LABEL_40;
  }
  if ((int)v10 < 16)
  {
    int v32 = *(unsigned char **)(result + 32);
  }
  else
  {
    unsigned int v12 = (v10 >> 4) + 1;
    int v32 = *(unsigned char **)(result + 32);
    while (1)
    {
      __int16 v13 = *v2;
      *int v32 = *v2;
      __int16 v14 = v2[1];
      v32[1] = v14;
      __int16 v15 = v2[2];
      v32[2] = v15;
      __int16 v16 = v2[3];
      v32[3] = v16;
      __int16 v17 = v2[4];
      v32[4] = v17;
      __int16 v18 = v2[5];
      v32[5] = v18;
      __int16 v19 = v2[6];
      v32[6] = v19;
      __int16 v20 = v2[7];
      v32[7] = v20;
      __int16 v21 = v2[8];
      v32[8] = v21;
      __int16 v22 = v2[9];
      v32[9] = v22;
      __int16 v23 = v2[10];
      v32[10] = v23;
      __int16 v24 = v2[11];
      v32[11] = v24;
      __int16 v25 = v2[12];
      v32[12] = v25;
      __int16 v26 = v2[13];
      v32[13] = v26;
      __int16 v27 = v2[14];
      v28.i16[0] = v13;
      v28.i16[1] = v14;
      v28.i16[2] = v15;
      v28.i16[3] = v16;
      v28.i16[4] = v17;
      v28.i16[5] = v18;
      v32[14] = v27;
      v28.i16[6] = v19;
      v28.i16[7] = v20;
      v29.i16[0] = v21;
      v29.i16[1] = v22;
      v29.i16[2] = v23;
      v29.i16[3] = v24;
      v29.i16[4] = v25;
      v29.i16[5] = v26;
      v29.i16[6] = v27;
      v29.i16[7] = v2[15];
      int8x16_t v30 = vorrq_s8(v28, v29);
      *(int8x8_t *)v30.i8 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      v32[15] = v29.i8[14];
      if (v7 < (v30.i16[0] | v30.i16[2] | ((v30.i32[0] | v30.i32[1]) >> 16))) {
        break;
      }
      v32 += 16;
      v2 += 16;
      if ((int)--v12 <= 1)
      {
        unsigned int v31 = 0;
        goto LABEL_25;
      }
    }
    unsigned int v31 = v12 - 1;
LABEL_25:
    int v36 = (v10 >> 4) - v31;
    LODWORD(v10) = v10 - 16 * v36;
    if (v6)
    {
      v5 += 16 * v36;
      if (v36 >= 1)
      {
        unsigned int v37 = v36 + 1;
        do
        {
          int32x4_t v38 = vdupq_n_s32(v9);
          *(_DWORD *)uint64_t v6 = v9;
          *(int32x4_t *)(v6 + 4) = vaddq_s32(v38, (int32x4_t)xmmword_18CA81090);
          *(int32x4_t *)(v6 + 20) = vaddq_s32(v38, (int32x4_t)xmmword_18CA810A0);
          *(int32x4_t *)(v6 + 36) = vaddq_s32(v38, (int32x4_t)xmmword_18CA810B0);
          unsigned int v39 = v9 + 15;
          *(int32x2_t *)(v6 + 52) = vadd_s32(*(int32x2_t *)v38.i8, (int32x2_t)0xE0000000DLL);
          v9 += 16;
          uint64_t v40 = v6 + 64;
          *(_DWORD *)(v6 + 60) = v39;
          --v37;
          v6 += 64;
        }
        while (v37 > 1);
        uint64_t v6 = v40;
      }
    }
  }
  if ((int)v10 >= 1)
  {
    int v41 = v10 + 1;
    int v42 = (unsigned __int16 *)(v2 + 1);
    do
    {
      unint64_t v2 = (__int16 *)v42;
      unsigned int v8 = *(v42 - 1);
      if (v8 > v7) {
        break;
      }
      *v32++ = v8;
      --v41;
      ++v42;
    }
    while (v41 > 1);
    if (v7 < v8)
    {
      if ((v8 & 0xFC00) != 0xD800) {
        goto LABEL_36;
      }
      goto LABEL_19;
    }
  }
LABEL_41:
  if (v6 && v32 != v5)
  {
    uint64_t v44 = v5 - v32;
    do
    {
      *(_DWORD *)uint64_t v6 = v9;
      v6 += 4;
      ++v9;
      BOOL v45 = __CFADD__(v44++, 1);
    }
    while (!v45);
  }
  BOOL v45 = *a2 > 0 || (unint64_t)v2 >= v4;
  if (!v45 && (unint64_t)v32 >= *(void *)(result + 40)) {
    *a2 = 15;
  }
  *(void *)(result + 16) = v2;
  *(void *)(result + 32) = v32;
  *(void *)(result + 48) = v6;
  return result;
}

uint64_t sub_18C86B914(uint64_t a1, _DWORD *a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a1 + 16);
  if ((unint64_t)v2 >= *(void *)(a1 + 24))
  {
    *a2 = 8;
    return 0xFFFFLL;
  }
  else
  {
    *(void *)(a1 + 16) = v2 + 1;
    return *v2;
  }
}

uint64_t sub_18C86B940(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(a2 + 16))(*(void *)a2, 0, 255);
}

uint64_t sub_18C86B954(uint64_t result, void *a2, int *a3)
{
  uint64_t v3 = a2[1];
  unint64_t v4 = (unsigned char *)a2[2];
  unint64_t v5 = a2[3];
  uint64_t v6 = *(unsigned char **)(result + 32);
  int v7 = *(_DWORD *)(result + 40) - v6;
  if (*(char *)(v3 + 64) < 1) {
    goto LABEL_7;
  }
  int v8 = *(_DWORD *)(v3 + 72);
  if (!v8 || (unint64_t)v4 >= v5) {
    goto LABEL_7;
  }
  if (!v7)
  {
    int v21 = 15;
LABEL_43:
    *a3 = v21;
    return result;
  }
  if ((v8 & 0xFFFFFFFE) != 0xC2 || (*v4 ^ 0x80u) > 0x3F)
  {
LABEL_42:
    int v21 = -127;
    goto LABEL_43;
  }
  *v6++ = *v4++ ^ 0x80 | ((_BYTE)v8 << 6);
  --v7;
  *(_DWORD *)(v3 + 72) = 0;
  *(unsigned char *)(v3 + 64) = 0;
LABEL_7:
  if ((unint64_t)v4 < v5 && (*(unsigned char *)(v5 - 1) + 62) < 0x33u) {
    --v5;
  }
  if ((unint64_t)v4 < v5)
  {
    while (1)
    {
      BOOL v10 = __OFSUB__(v7--, 1);
      if (v7 < 0 != v10)
      {
        *a3 = 15;
        goto LABEL_39;
      }
      BOOL v11 = v4 + 1;
      int v12 = (char)*v4;
      if (v12 < 0)
      {
        if ((v12 & 0xFFFFFFFE) != 0xFFFFFFC2 || (unsigned __int8 v13 = *v11 ^ 0x80, v13 > 0x3Fu))
        {
          a2[2] = v4;
          *(void *)(result + 32) = v6;
          goto LABEL_42;
        }
        BOOL v11 = v4 + 2;
        LOBYTE(v12) = v13 | ((_BYTE)v12 << 6);
      }
      *v6++ = v12;
      unint64_t v4 = v11;
      if ((unint64_t)v11 >= v5) {
        goto LABEL_19;
      }
    }
  }
  BOOL v11 = v4;
LABEL_19:
  if (*a3 <= 0 && (unint64_t)v11 < a2[3])
  {
    int v15 = (char)*v11++;
    int v14 = v15;
    unsigned int v16 = v15;
    *(unsigned char *)(v3 + 65) = v15;
    *(unsigned char *)(v3 + 64) = 1;
    unsigned int v17 = (v15 + 62);
    if (v15 <= 0xEFu) {
      int v18 = 2;
    }
    else {
      int v18 = 3;
    }
    if (v16 > 0xDF) {
      ++v18;
    }
    if (v17 <= 0x32) {
      int v19 = v18;
    }
    else {
      int v19 = 0;
    }
    if (v14 < 0) {
      int v20 = v19;
    }
    else {
      int v20 = 1;
    }
    *(_DWORD *)(v3 + 72) = v16;
    *(_DWORD *)(v3 + 76) = v20;
  }
  unint64_t v4 = v11;
LABEL_39:
  a2[2] = v4;
  *(void *)(result + 32) = v6;
  return result;
}

void *sub_18C86BAD4(void *result, int *a2)
{
  unint64_t v2 = (unsigned __int8 *)result[2];
  unint64_t v3 = result[3];
  uint64_t v4 = result[4];
  unint64_t v5 = result[5];
  uint64_t v6 = result[6];
  int v7 = v3 - v2;
  if ((int)v3 - (int)v2 >= (int)((v5 - v4) >> 1)) {
    int v7 = (v5 - v4) >> 1;
  }
  if (v7 < 8)
  {
    unsigned int v27 = 0;
    int v8 = (_WORD *)result[4];
  }
  else
  {
    int v8 = (_WORD *)result[4];
    int v9 = v7 >> 3;
    while (1)
    {
      int v10 = *v2;
      *int v8 = v10;
      int v11 = v2[1];
      v8[1] = v11;
      int v12 = v11 | v10;
      int v13 = v2[2];
      void v8[2] = v13;
      int v14 = v2[3];
      v8[3] = v14;
      int v15 = v12 | v13 | v14;
      int v16 = v2[4];
      v8[4] = v16;
      int v17 = v2[5];
      v8[5] = v17;
      int v18 = v16 | v17;
      int v19 = v2[6];
      v8[6] = v19;
      int v20 = v15 | v18 | v19;
      int v21 = v2[7];
      v8[7] = v21;
      if (((v20 | v21) & 0x80) != 0) {
        break;
      }
      v2 += 8;
      v8 += 8;
      BOOL v22 = __OFSUB__(v9--, 1);
      if ((v9 < 0) ^ v22 | (v9 == 0))
      {
        int v9 = 0;
        break;
      }
    }
    int v23 = (v7 >> 3) - v9;
    v7 -= 8 * v23;
    if (v6 && (v4 += 16 * v23, v23 >= 1))
    {
      unsigned int v24 = 0;
      unsigned int v25 = v23 + 1;
      do
      {
        int8x16_t v26 = (int8x16_t)vdupq_n_s32(v24);
        *(_DWORD *)uint64_t v6 = v24;
        *(int8x16_t *)(v6 + 4) = vorrq_s8(v26, (int8x16_t)xmmword_18CA81090);
        *(int8x8_t *)(v6 + 20) = vorr_s8(*(int8x8_t *)v26.i8, (int8x8_t)0x600000005);
        unsigned int v27 = v24 + 8;
        *(_DWORD *)(v6 + 28) = v24 + 7;
        v6 += 32;
        --v25;
        v24 += 8;
      }
      while (v25 > 1);
    }
    else
    {
      unsigned int v27 = 0;
    }
  }
  if (v7 >= 1)
  {
    int v28 = v7 + 1;
    while (1)
    {
      int v30 = (char)*v2++;
      unsigned __int8 v29 = v30;
      if (v30 < 0) {
        break;
      }
      *v8++ = v29;
      if (--v28 <= 1) {
        goto LABEL_20;
      }
    }
    uint64_t v32 = result[1];
    *(unsigned char *)(v32 + 65) = v29;
    *(unsigned char *)(v32 + 64) = 1;
    int v31 = 12;
    goto LABEL_24;
  }
LABEL_20:
  if ((unint64_t)v2 < v3 && (unint64_t)v8 >= v5)
  {
    int v31 = 15;
LABEL_24:
    *a2 = v31;
  }
  if (v6)
  {
    uint64_t v33 = (uint64_t)v8 - v4;
    if (v33)
    {
      uint64_t v34 = v33 >> 1;
      do
      {
        *(_DWORD *)uint64_t v6 = v27;
        v6 += 4;
        ++v27;
        --v34;
      }
      while (v34);
    }
  }
  result[2] = v2;
  result[4] = v8;
  result[6] = v6;
  return result;
}

uint64_t sub_18C86BC84(void *a1, int *a2)
{
  unint64_t v2 = (char *)a1[2];
  if ((unint64_t)v2 >= a1[3])
  {
    int v6 = 8;
  }
  else
  {
    int v4 = *v2;
    unsigned __int8 v3 = *v2;
    a1[2] = v2 + 1;
    if ((v4 & 0x80000000) == 0) {
      return v3;
    }
    uint64_t v7 = a1[1];
    *(unsigned char *)(v7 + 65) = v3;
    *(unsigned char *)(v7 + 64) = 1;
    int v6 = 12;
  }
  *a2 = v6;
  return 0xFFFFLL;
}

uint64_t sub_18C86BCCC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(a2 + 16))(*(void *)a2, 0, 127);
}

uint64_t sub_18C86BCE0(uint64_t result, void *a2, int *a3)
{
  if (*(char *)(a2[1] + 64) >= 1)
  {
    *a3 = -127;
    return result;
  }
  unsigned __int8 v3 = (__int8 *)a2[2];
  unint64_t v4 = a2[3];
  unint64_t v5 = *(__int8 **)(result + 32);
  int v6 = *(_DWORD *)(result + 40) - v5;
  if ((int)v4 - (int)v3 < v6) {
    int v6 = v4 - v3;
  }
  if (v6 >= 16)
  {
    int v7 = v6 >> 4;
    while (1)
    {
      __int8 v8 = *v3;
      *unint64_t v5 = *v3;
      __int8 v9 = v3[1];
      v5[1] = v9;
      __int8 v10 = v3[2];
      v5[2] = v10;
      __int8 v11 = v3[3];
      v5[3] = v11;
      __int8 v12 = v3[4];
      v5[4] = v12;
      __int8 v13 = v3[5];
      v5[5] = v13;
      __int8 v14 = v3[6];
      v5[6] = v14;
      __int8 v15 = v3[7];
      v5[7] = v15;
      __int8 v16 = v3[8];
      v5[8] = v16;
      __int8 v17 = v3[9];
      v5[9] = v17;
      __int8 v18 = v3[10];
      v5[10] = v18;
      __int8 v19 = v3[11];
      v5[11] = v19;
      __int8 v20 = v3[12];
      v5[12] = v20;
      __int8 v21 = v3[13];
      v5[13] = v21;
      __int8 v22 = v3[14];
      v5[14] = v22;
      __int8 v23 = v3[15];
      v24.i8[0] = v8;
      v24.i8[1] = v9;
      v24.i8[2] = v10;
      v24.i8[3] = v11;
      v24.i8[4] = v12;
      v24.i8[5] = v13;
      v24.i8[6] = v14;
      v5[15] = v23;
      v24.i8[7] = v15;
      v25.i8[0] = v16;
      v25.i8[1] = v17;
      v25.i8[2] = v18;
      v25.i8[3] = v19;
      v25.i8[4] = v20;
      v25.i8[5] = v21;
      v25.i8[6] = v22;
      v25.i8[7] = v23;
      int8x8_t v26 = vorr_s8(v24, v25);
      if (((v26.i32[0] | v26.i32[1] | ((*(void *)&v26 | HIDWORD(*(void *)&v26)) >> 16) | ((v26.i32[0] | v26.i32[1] | ((*(void *)&v26 | HIDWORD(*(void *)&v26)) >> 16)) >> 8)) & 0x80) != 0) {
        break;
      }
      v5 += 16;
      v3 += 16;
      BOOL v27 = __OFSUB__(v7--, 1);
      if ((v7 < 0) ^ v27 | (v7 == 0))
      {
        int v7 = 0;
        break;
      }
    }
    v6 += 16 * (v7 - (v6 >> 4));
  }
  if (v6 < 1)
  {
LABEL_16:
    if ((unint64_t)v3 >= v4 || (unint64_t)v5 < *(void *)(result + 40)) {
      goto LABEL_21;
    }
    int v30 = 15;
  }
  else
  {
    int v28 = v6 + 1;
    while (1)
    {
      int v29 = *v3;
      if (v29 < 0) {
        break;
      }
      ++v3;
      *v5++ = v29;
      if (--v28 <= 1) {
        goto LABEL_16;
      }
    }
    int v30 = -127;
  }
  *a3 = v30;
LABEL_21:
  a2[2] = v3;
  *(void *)(result + 32) = v5;
  return result;
}

uint64_t sub_18C86BE98(uint64_t result, uint64_t *a2, uint64_t a3, int a4, _DWORD *a5)
{
  uint64_t v37 = result;
  uint64_t v7 = *(void *)(result + 88);
  if (*(unsigned char *)(result + 253)) {
    uint64_t v8 = 1088;
  }
  else {
    uint64_t v8 = 64;
  }
  int v9 = *(unsigned __int8 *)(result + 252);
  uint64_t v10 = *(void *)(result + 232);
  uint64_t v42 = v8;
  if (*(unsigned char *)(result + 252))
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    if (v9 == 3) {
      unsigned int v13 = 4;
    }
    else {
      unsigned int v13 = 2;
    }
    if (v9 == 2 || v9 == 9) {
      uint64_t v15 = 3;
    }
    else {
      uint64_t v15 = v13;
    }
    unsigned int v40 = v8 >> 1;
    uint64_t v39 = *(void *)(result + 88);
    while (1)
    {
      uint64_t v41 = v11;
      uint64_t v16 = *(unsigned __int16 *)(v7 + 2 * v11);
      if (v40 < v16) {
        break;
      }
      uint64_t v12 = (v12 + 1024);
LABEL_66:
      uint64_t v11 = v41 + 1;
      uint64_t v7 = v39;
      if (v41 + 1 == v42) {
        goto LABEL_84;
      }
    }
    uint64_t v17 = v7;
    uint64_t v18 = 0;
    uint64_t v19 = v17 + 4 * v16;
    while (1)
    {
      unsigned int v20 = *(_DWORD *)(v19 + 4 * v18);
      if (v20) {
        break;
      }
      uint64_t v12 = (v12 + 16);
LABEL_63:
      if (++v18 == 64) {
        goto LABEL_66;
      }
    }
    __int8 v21 = (unsigned __int8 *)(v10 + 16 * v15 * (unsigned __int16)*(_DWORD *)(v19 + 4 * v18));
    unsigned int v22 = HIWORD(v20);
    switch(a4)
    {
      case 0:
        do
        {
          if (v22)
          {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
            v21 += v15;
          }
          else if (a3 == 1)
          {
            int v23 = 0;
            if (v15 != 2)
            {
              if (v15 != 3)
              {
                int v24 = *v21++;
                int v23 = v24;
              }
              int v25 = *v21++;
              v23 |= v25;
            }
            int v26 = *v21;
            int v27 = v21[1];
            v21 += 2;
            if (v26 | v23 | v27) {
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
            }
          }
          v22 >>= 1;
          uint64_t v12 = (v12 + 1);
        }
        while ((v12 & 0xF) != 0);
        goto LABEL_63;
      case 1:
        do
        {
          if (a3 == 1 || (v22) && *(unsigned __int16 *)v21 >= 0x100u) {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
          }
          v22 >>= 1;
          v21 += 2;
          uint64_t v12 = (v12 + 1);
        }
        while ((v12 & 0xF) != 0);
        goto LABEL_63;
      case 2:
        do
        {
          if (a3 == 1 || (v22) && (*v21 + 127) <= 1u) {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
          }
          v22 >>= 1;
          v21 += 3;
          uint64_t v12 = (v12 + 1);
        }
        while ((v12 & 0xF) != 0);
        goto LABEL_63;
      case 3:
        do
        {
          if (a3 == 1 || (v22) && (unsigned __int16)(*(_WORD *)v21 + 32448) <= 0x6EBCu) {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
          }
          v22 >>= 1;
          v21 += 2;
          uint64_t v12 = (v12 + 1);
        }
        while ((v12 & 0xF) != 0);
        goto LABEL_63;
      case 4:
        do
        {
          if (a3 == 1 || (v22)
            && (unsigned __int16)(*(_WORD *)v21 + 24159) <= 0x5D5Du
            && ((*(_WORD *)v21 + 95) & 0xFEu) <= 0x5D)
          {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
          }
          v22 >>= 1;
          v21 += 2;
          uint64_t v12 = (v12 + 1);
        }
        while ((v12 & 0xF) != 0);
        goto LABEL_63;
      case 5:
        do
        {
          if (a3 == 1 || (v22)
            && (unsigned __int16)(*(_WORD *)v21 + 24159) <= 0x5C5Du
            && ((*(_WORD *)v21 + 95) & 0xFEu) <= 0x5D)
          {
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2[1])(*a2, v12);
          }
          v22 >>= 1;
          v21 += 2;
          uint64_t v12 = (v12 + 1);
        }
        while ((v12 & 0xF) != 0);
        goto LABEL_63;
      default:
        *a5 = 5;
        break;
    }
  }
  else
  {
    unsigned int v28 = v8;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    if (a3) {
      unsigned int v31 = 2048;
    }
    else {
      unsigned int v31 = 3840;
    }
    do
    {
      uint64_t v32 = *(unsigned __int16 *)(v7 + 2 * v29);
      if (v28 >= v32)
      {
        uint64_t v30 = (v30 + 1024);
      }
      else
      {
        uint64_t v33 = 0;
        uint64_t v34 = v7 + 2 * v32;
        do
        {
          if (*(_WORD *)(v34 + 2 * v33))
          {
            int v35 = (unsigned __int16 *)(v10 + 2 * *(unsigned __int16 *)(v34 + 2 * v33));
            do
            {
              unsigned int v36 = *v35++;
              if (v31 <= v36) {
                ((void (*)(uint64_t, uint64_t))a2[1])(*a2, v30);
              }
              uint64_t v30 = (v30 + 1);
            }
            while ((v30 & 0xF) != 0);
          }
          else
          {
            uint64_t v30 = (v30 + 16);
          }
          ++v33;
        }
        while (v33 != 64);
      }
      ++v29;
      unsigned int v28 = v42;
    }
    while (v29 != v42);
LABEL_84:
    return sub_18C85FD84(v37, a2, a3, a4);
  }
  return result;
}

uint64_t sub_18C86C2D8(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  return sub_18C86BE98(a1, a2, a3, *(unsigned __int8 *)(a1 + 252) == 219, a4);
}

uint64_t sub_18C86C2EC(uint64_t result, int *a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  v161 = 0;
  v162 = 0;
  v160 = 0;
  uint64_t v4 = *(void *)(result + 8);
  if (*(char *)(v4 + 282) >= 1)
  {
    uint64_t v6 = *(void *)(result + 8);
    uint64_t result = sub_18C85F374(v6, result, -1, a2);
    if (*a2 > 0) {
      return result;
    }
    uint64_t v4 = v6;
    unint64_t v2 = a2;
    if (*(char *)(v6 + 282) < 0) {
      return result;
    }
  }
  uint64_t v7 = *(void *)(v4 + 48);
  if (*(unsigned char *)(v7 + 48) != 1)
  {
    uint64_t v71 = *(unsigned char **)(v3 + 16);
    unint64_t v70 = *(void *)(v3 + 24);
    unint64_t v72 = *(void *)(v3 + 40);
    v161 = *(_WORD **)(v3 + 32);
    v162 = v71;
    uint64_t v159 = v3;
    v160 = *(_DWORD **)(v3 + 48);
    uint64_t v73 = 56;
    if ((*(unsigned char *)(v4 + 56) & 0x10) != 0) {
      uint64_t v73 = 64;
    }
    int v74 = *(_DWORD *)(v4 + 72);
    LOBYTE(v75) = *(unsigned char *)(v4 + 64);
    uint64_t v76 = *(unsigned __int8 *)(v4 + 76);
    if (!*(unsigned char *)(v4 + 76)) {
      uint64_t v76 = *(unsigned __int8 *)(v7 + 49);
    }
    if ((unint64_t)v71 >= v70) {
      goto LABEL_210;
    }
    LODWORD(v77) = 0;
    uint64_t v78 = *(void *)(v7 + v73);
    int v79 = (unsigned char *)(v4 + 65);
    uint64_t v80 = *(void *)(v7 + 72);
    if (*(unsigned char *)(v4 + 64)) {
      uint64_t v81 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v81 = 0;
    }
    while (1)
    {
      uint64_t v82 = v161;
      if ((unint64_t)v161 >= v72) {
        goto LABEL_209;
      }
      if ((_BYTE)v75)
      {
        v162 = v71 + 1;
        uint64_t v83 = *v71;
        v79[(char)v75] = v83;
        LODWORD(v84) = *(_DWORD *)(v78 + ((unint64_t)v76 << 10) + 4 * v83);
        ++v71;
        uint64_t v85 = v76;
        goto LABEL_89;
      }
      int v86 = v160;
      if (!v160)
      {
        while (1)
        {
          unint64_t v84 = *(unsigned int *)(v78 + ((unint64_t)v76 << 10) + 4 * *v71);
          if ((v84 & 0x80000000) != 0)
          {
            if (v84 >= 0x80100000) {
              goto LABEL_83;
            }
            uint64_t v76 = 0;
            v162 = ++v71;
            *uint64_t v82 = v84;
            v161 = v82 + 1;
          }
          else
          {
            unint64_t v90 = v84 >> 24;
            int v74 = v84 & 0xFFFFFF;
            uint64_t v88 = v71 + 1;
            v162 = v71 + 1;
            if ((unint64_t)(v71 + 1) >= v70
              || (LODWORD(v84) = *(_DWORD *)(v78 + (v90 << 10) + 4 * *v88), (v84 & 0x80F00000) != 0x80400000)
              || (unsigned int v91 = *(unsigned __int16 *)(v80 + 2 * (v74 + (unsigned __int16)v84)), v91 > 0xFFFD))
            {
LABEL_85:
              *int v79 = *v71;
              unsigned int v75 = 1;
              uint64_t v71 = v88;
              uint64_t v85 = v90;
              goto LABEL_86;
            }
            int v74 = 0;
            v71 += 2;
            v162 = v71;
            *uint64_t v82 = v91;
            v161 = v82 + 1;
            uint64_t v76 = BYTE3(v84) & 0x7F;
          }
          uint64_t v82 = v161;
          if ((unint64_t)v71 >= v70 || (unint64_t)v161 >= v72)
          {
LABEL_83:
            unsigned int v75 = 0;
            uint64_t v85 = v76;
            goto LABEL_86;
          }
        }
      }
      uint64_t v85 = v76;
      while (1)
      {
        unint64_t v84 = *(unsigned int *)(v78 + ((unint64_t)v85 << 10) + 4 * *v71);
        if ((v84 & 0x80000000) != 0) {
          break;
        }
        unint64_t v87 = v84 >> 24;
        int v74 = v84 & 0xFFFFFF;
        uint64_t v88 = v71 + 1;
        v162 = v71 + 1;
        if ((unint64_t)(v71 + 1) >= v70
          || (LODWORD(v84) = *(_DWORD *)(v78 + (v87 << 10) + 4 * *v88), (v84 & 0x80F00000) != 0x80400000)
          || (unsigned int v89 = *(unsigned __int16 *)(v80 + 2 * (v74 + (unsigned __int16)v84)), v89 > 0xFFFD))
        {
          LODWORD(v77) = v77 + 1;
          unint64_t v90 = v87;
          goto LABEL_85;
        }
        v71 += 2;
        v162 = v71;
        *uint64_t v82 = v89;
        v161 = v82 + 1;
        if (v86)
        {
          *v86++ = v81;
          v160 = v86;
          uint64_t v81 = (v77 + 2);
          LODWORD(v77) = v77 + 2;
        }
        int v74 = 0;
        uint64_t v85 = BYTE3(v84) & 0x7F;
LABEL_71:
        unsigned int v75 = 0;
        uint64_t v82 = v161;
        if ((unint64_t)v71 >= v70 || (unint64_t)v161 >= v72) {
          goto LABEL_86;
        }
      }
      if (v84 < 0x80100000) {
        break;
      }
      unsigned int v75 = 0;
LABEL_86:
      if ((unint64_t)v71 >= v70) {
        goto LABEL_181;
      }
      if ((unint64_t)v82 >= v72)
      {
        *unint64_t v2 = 15;
LABEL_181:
        LOBYTE(v76) = v85;
        goto LABEL_210;
      }
      v162 = v71 + 1;
      v79[v75] = *v71++;
LABEL_89:
      uint64_t v77 = (v77 + 1);
      int v92 = (char)(v75 + 1);
      if ((v84 & 0x80000000) == 0)
      {
        uint64_t v76 = BYTE3(v84);
        v74 += v84 & 0xFFFFFF;
        LOBYTE(v75) = v75 + 1;
        uint64_t v93 = v81;
        goto LABEL_133;
      }
      *(_DWORD *)(v4 + 76) = v85;
      uint64_t v76 = BYTE3(v84) & 0x7F;
      unsigned int v94 = (v84 >> 20) & 0xF;
      if (!v94)
      {
LABEL_109:
        *uint64_t v82 = v84;
        unint64_t v98 = (unint64_t)(v82 + 1);
LABEL_110:
        v161 = (_WORD *)v98;
        uint64_t v107 = v160;
        if (v160)
        {
          int v74 = 0;
          LOBYTE(v75) = 0;
          _DWORD *v160 = v81;
          v160 = v107 + 1;
          goto LABEL_132;
        }
LABEL_130:
        int v74 = 0;
LABEL_131:
        LOBYTE(v75) = 0;
        goto LABEL_132;
      }
      if (v94 == 5)
      {
        unsigned int v97 = v74 + (unsigned __int16)v84;
        unsigned int v96 = *(unsigned __int16 *)(v80 + 2 * v97);
        if (v96 >> 11 <= 0x1A)
        {
LABEL_99:
          *uint64_t v82 = v96;
          unint64_t v98 = (unint64_t)(v82 + 1);
          goto LABEL_110;
        }
        unsigned int v102 = v97 + 1;
        if (v96 >> 13 <= 6)
        {
          *uint64_t v82 = v96 & 0xDBFF;
          v103 = v82 + 1;
          v161 = v82 + 1;
          unsigned int v104 = v160;
          if (v160)
          {
            _DWORD *v160 = v81;
            v160 = v104 + 1;
            if ((unint64_t)v103 < v72)
            {
              int v74 = 0;
              LOBYTE(v75) = 0;
              __int16 v105 = *(_WORD *)(v80 + 2 * v102);
              v161 = v82 + 2;
              v82[1] = v105;
              v160 = v104 + 2;
              v104[1] = v81;
              goto LABEL_132;
            }
          }
          else if ((unint64_t)v103 < v72)
          {
            int v74 = 0;
            LOBYTE(v75) = 0;
            __int16 v117 = *(_WORD *)(v80 + 2 * v102);
            v161 = v82 + 2;
            v82[1] = v117;
            goto LABEL_132;
          }
          int v74 = 0;
          LOBYTE(v75) = 0;
          *(_WORD *)(v4 + 144) = *(_WORD *)(v80 + 2 * v102);
LABEL_208:
          *(unsigned char *)(v4 + 93) = 1;
LABEL_209:
          *unint64_t v2 = 15;
          goto LABEL_210;
        }
        if ((v96 & 0xFFFE) == 0xE000)
        {
          LOWORD(v96) = *(_WORD *)(v80 + 2 * v102);
          goto LABEL_99;
        }
        uint64_t result = v76;
        if (v96 == 0xFFFF)
        {
LABEL_124:
          *unint64_t v2 = 12;
          uint64_t v76 = result;
        }
LABEL_125:
        if (!v92) {
          goto LABEL_130;
        }
        if (*v2 >= 1)
        {
          if (v92 >= 2)
          {
            uint64_t v146 = 0;
            BOOL v147 = *(unsigned char *)(*(void *)(v4 + 48) + 49) != 0;
            uint64_t v148 = v4;
            uint64_t v149 = v4 + 66;
            do
            {
              uint64_t result = sub_18C86D36C(v78, v76, v147, *(unsigned __int8 *)(v149 + v146));
              if (result)
              {
                LOBYTE(v75) = v146 + 1;
                char v150 = v92 - (v146 + 1);
                v151 = &v71[-*(void *)(v159 + 16)];
                uint64_t v4 = v148;
                if ((int)v151 >= v150)
                {
                  int v74 = 0;
                  v71 -= v150;
                }
                else
                {
                  char v152 = (_BYTE)v151 - v150;
                  *(unsigned char *)(v148 + 282) = v152;
                  uint64_t result = (uint64_t)memcpy((void *)(v148 + 250), (const void *)(v148 + v146 + 66), -(uint64_t)v152);
                  uint64_t v4 = v148;
                  int v74 = 0;
                  uint64_t v71 = *(unsigned char **)(v159 + 16);
                }
                goto LABEL_210;
              }
              ++v146;
            }
            while (v92 - 1 != v146);
            int v74 = 0;
            LOBYTE(v75) = v92;
            uint64_t v4 = v148;
            goto LABEL_210;
          }
          int v74 = 0;
        }
        else
        {
          uint64_t v109 = v159;
          *(void *)(v159 + 16) = v71;
          uint64_t v110 = *(void *)(*(void *)(v4 + 48) + 288);
          if (v110)
          {
            uint64_t v158 = v80;
            v156 = v2;
            v111 = v79;
            uint64_t v112 = v4;
            uint64_t result = sub_18C85EF38(v4, v110, v92, (uint64_t *)&v162, v70, (unint64_t *)&v161, v72, &v160, v81, *(unsigned char *)(v159 + 2), v2);
            uint64_t v109 = v159;
            uint64_t v80 = v158;
            int v79 = v111;
            uint64_t v4 = v112;
            unint64_t v2 = v156;
            if (result) {
              goto LABEL_129;
            }
          }
          if (v92 == 4 && (*(unsigned char *)(v4 + 57) & 0x80) != 0)
          {
            uint64_t v113 = 0;
            unsigned int v114 = *(unsigned __int8 *)(v4 + 68)
                 + 10
                 * (*(unsigned __int8 *)(v4 + 67)
                  + 126 * (*(unsigned __int8 *)(v4 + 66) + 10 * *(unsigned __int8 *)(v4 + 65)));
            while (1)
            {
              unsigned int v115 = dword_18CA811FC[v113 + 2];
              BOOL v143 = v114 >= v115;
              unsigned int v116 = v114 - v115;
              if (v143 && v114 <= dword_18CA811FC[v113 + 3]) {
                break;
              }
              v113 += 4;
              if ((v113 * 4) == 224) {
                goto LABEL_142;
              }
            }
            *unint64_t v2 = 0;
            v118 = v79;
            uint64_t v119 = v80;
            int v120 = v81;
            v121 = v2;
            uint64_t v122 = v4;
            uint64_t v123 = v109;
            uint64_t result = sub_18C85D360(v4, v116 + dword_18CA811FC[v113], (unint64_t *)&v161, v72, &v160, v120, v2);
            uint64_t v109 = v123;
            uint64_t v80 = v119;
            int v79 = v118;
            uint64_t v4 = v122;
            unint64_t v2 = v121;
LABEL_129:
            LOBYTE(v92) = 0;
          }
          else
          {
LABEL_142:
            *unint64_t v2 = 10;
          }
          int v74 = 0;
          uint64_t v71 = v162;
          if (*v2 < 1)
          {
            uint64_t v93 = (v77 + v162 - *(_DWORD *)(v109 + 16));
            LOBYTE(v75) = v92;
            LODWORD(v77) = v77 + v162 - *(_DWORD *)(v109 + 16);
            goto LABEL_133;
          }
        }
        LOBYTE(v75) = v92;
        goto LABEL_210;
      }
      if (v94 != 4)
      {
        if ((v84 & 0xD00000) != 0x100000)
        {
          int v74 = 0;
          unsigned int v106 = v94 - 2;
          LOBYTE(v75) = 0;
          uint64_t v93 = v77;
          uint64_t result = BYTE3(v84) & 0x7F;
          switch(v106)
          {
            case 0u:
              goto LABEL_109;
            case 4u:
              goto LABEL_125;
            case 5u:
              goto LABEL_124;
            case 6u:
              int v74 = *(unsigned __int8 *)(*(void *)(v4 + 48) + 49);
              uint64_t result = v85;
              if (*(unsigned char *)(*(void *)(v4 + 48) + 49)) {
                goto LABEL_124;
              }
              goto LABEL_131;
            default:
              goto LABEL_133;
          }
        }
        *uint64_t v82 = (v84 >> 10) & 0x3FF | 0xD800;
        unsigned int v99 = v82 + 1;
        v161 = v82 + 1;
        v100 = v160;
        if (v160)
        {
          _DWORD *v160 = v81;
          v160 = v100 + 1;
          __int16 v101 = v84 & 0x3FF | 0xDC00;
          if ((unint64_t)v99 < v72)
          {
            int v74 = 0;
            LOBYTE(v75) = 0;
            v161 = v82 + 2;
            v82[1] = v101;
            v160 = v100 + 2;
            v100[1] = v81;
LABEL_132:
            uint64_t v93 = v77;
            goto LABEL_133;
          }
        }
        else
        {
          __int16 v101 = v84 & 0x3FF | 0xDC00;
          if ((unint64_t)v99 < v72)
          {
            int v74 = 0;
            LOBYTE(v75) = 0;
            v161 = v82 + 2;
            v82[1] = v101;
            goto LABEL_132;
          }
        }
        int v74 = 0;
        LOBYTE(v75) = 0;
        *(_WORD *)(v4 + 144) = v101;
        goto LABEL_208;
      }
      unsigned int v95 = v74 + (unsigned __int16)v84;
      unsigned int v96 = *(unsigned __int16 *)(v80 + 2 * v95);
      if (v96 <= 0xFFFD) {
        goto LABEL_99;
      }
      if (v96 != 65534)
      {
        uint64_t result = BYTE3(v84) & 0x7F;
        goto LABEL_124;
      }
      uint64_t v157 = v80;
      v153 = v79;
      uint64_t v154 = v4;
      v155 = v2;
      uint64_t result = sub_18C86D300(*(void *)(v4 + 48) + 48, v95);
      if (result == 65534)
      {
        uint64_t v4 = v154;
        unint64_t v2 = v155;
        int v79 = v153;
        uint64_t v80 = v157;
        goto LABEL_125;
      }
      *uint64_t v82 = result;
      v161 = v82 + 1;
      int v108 = v160;
      unint64_t v2 = v155;
      int v79 = v153;
      uint64_t v80 = v157;
      int v74 = 0;
      LOBYTE(v75) = 0;
      if (v160)
      {
        _DWORD *v160 = v81;
        v160 = v108 + 1;
      }
      uint64_t v93 = v77;
      uint64_t v4 = v154;
LABEL_133:
      uint64_t v81 = v93;
      if ((unint64_t)v71 >= v70)
      {
LABEL_210:
        *(_DWORD *)(v4 + 72) = v74;
        *(_DWORD *)(v4 + 76) = v76;
        *(unsigned char *)(v4 + 64) = v75;
        *(void *)(v159 + 16) = v71;
        *(void *)(v159 + 32) = v161;
        *(void *)(v159 + 48) = v160;
        return result;
      }
    }
    v162 = ++v71;
    *uint64_t v82 = v84;
    v161 = v82 + 1;
    uint64_t v85 = 0;
    if (v86)
    {
      *v86++ = v81;
      v160 = v86;
      uint64_t v81 = (v77 + 1);
      LODWORD(v77) = v77 + 1;
    }
    goto LABEL_71;
  }
  if ((*(unsigned char *)(v7 + 253) & 1) == 0)
  {
    unsigned int v8 = 0;
    uint64_t v10 = *(void *)(v3 + 8);
    int v9 = *(unsigned __int8 **)(v3 + 16);
    unint64_t v12 = *(void *)(v3 + 24);
    uint64_t v11 = *(_WORD **)(v3 + 32);
    uint64_t v13 = v3;
    uint64_t v14 = (*(void *)(v3 + 40) - (void)v11) >> 1;
    v163 = *(int **)(v3 + 48);
    v164 = v11;
    uint64_t v15 = 64;
    if ((*(unsigned char *)(v10 + 56) & 0x10) == 0) {
      uint64_t v15 = 56;
    }
    uint64_t v16 = *(void *)(*(void *)(v10 + 48) + v15);
    if ((int)v12 - (int)v9 < (int)v14) {
      LODWORD(v14) = v12 - v9;
    }
    int32x4_t v17 = (int32x4_t)xmmword_18CA81090;
    int32x4_t v18 = (int32x4_t)xmmword_18CA810A0;
    int32x4_t v19 = (int32x4_t)xmmword_18CA810B0;
    uint64_t result = 2;
    unsigned int v20 = v9;
    while (1)
    {
      if ((int)v14 < 16) {
        goto LABEL_23;
      }
      signed int v21 = v14 >> 4;
      while (1)
      {
        v165 = v9 + 1;
        int v22 = *(_DWORD *)(v16 + 4 * *v9);
        v164 = v11 + 1;
        *uint64_t v11 = v22;
        v165 = v9 + 2;
        int v23 = *(_DWORD *)(v16 + 4 * v9[1]);
        int v24 = v23 | v22;
        v164 = v11 + 2;
        v11[1] = v23;
        v165 = v9 + 3;
        int v25 = *(_DWORD *)(v16 + 4 * v9[2]);
        v164 = v11 + 3;
        v11[2] = v25;
        v165 = v9 + 4;
        int v26 = *(_DWORD *)(v16 + 4 * v9[3]);
        int v27 = v24 | v25 | v26;
        v164 = v11 + 4;
        v11[3] = v26;
        v165 = v9 + 5;
        int v28 = *(_DWORD *)(v16 + 4 * v9[4]);
        v164 = v11 + 5;
        v11[4] = v28;
        v165 = v9 + 6;
        int v29 = *(_DWORD *)(v16 + 4 * v9[5]);
        int v30 = v28 | v29;
        v164 = v11 + 6;
        v11[5] = v29;
        v165 = v9 + 7;
        int v31 = *(_DWORD *)(v16 + 4 * v9[6]);
        int v32 = v30 | v31;
        v164 = v11 + 7;
        v11[6] = v31;
        v165 = v9 + 8;
        int v33 = *(_DWORD *)(v16 + 4 * v9[7]);
        int v34 = v27 | v32;
        v11[7] = v33;
        int v35 = *(_DWORD *)(v16 + 4 * v9[8]);
        int v36 = v33 | v35;
        v11[8] = v35;
        int v37 = *(_DWORD *)(v16 + 4 * v9[9]);
        int v38 = v36 | v37;
        v11[9] = v37;
        int v39 = *(_DWORD *)(v16 + 4 * v9[10]);
        int v40 = v38 | v39;
        v11[10] = v39;
        int v41 = *(_DWORD *)(v16 + 4 * v9[11]);
        v11[11] = v41;
        int v42 = *(_DWORD *)(v16 + 4 * v9[12]);
        int v43 = v34 | v40;
        int v44 = v41 | v42;
        v11[12] = v42;
        int v45 = *(_DWORD *)(v16 + 4 * v9[13]);
        int v46 = v44 | v45;
        v11[13] = v45;
        int v47 = *(_DWORD *)(v16 + 4 * v9[14]);
        int v48 = v46 | v47;
        v11[14] = v47;
        uint64_t v49 = v9 + 16;
        v165 = v9 + 16;
        int v50 = *(_DWORD *)(v16 + 4 * v9[15]);
        uint64_t v51 = v11 + 16;
        v164 = v11 + 16;
        v11[15] = v50;
        if ((v43 | v48 | v50) >= -2146435072) {
          break;
        }
        v11 += 16;
        v9 += 16;
        BOOL v52 = __OFSUB__(v21--, 1);
        if ((v21 < 0) ^ v52 | (v21 == 0))
        {
          signed int v21 = 0;
          int v9 = v49;
          uint64_t v11 = v51;
          goto LABEL_18;
        }
      }
      v165 = v9;
      v164 = v11;
LABEL_18:
      int v53 = (v14 >> 4) - v21;
      LODWORD(v14) = v14 - 16 * v53;
      uint64_t v54 = v163;
      if (v163 && (v20 += 16 * v53, v53 >= 1))
      {
        unsigned int v55 = v53 + 1;
        do
        {
          int32x4_t v56 = vdupq_n_s32(v8);
          *uint64_t v54 = v8;
          *(int32x4_t *)(v54 + 1) = vaddq_s32(v56, v17);
          *(int32x4_t *)(v54 + 5) = vaddq_s32(v56, v18);
          *(int32x4_t *)(v54 + 9) = vaddq_s32(v56, v19);
          *(int32x2_t *)(v54 + 13) = vadd_s32(*(int32x2_t *)v56.i8, (int32x2_t)0xE0000000DLL);
          unsigned int v57 = v8 + 16;
          uint64_t v58 = v54 + 16;
          v54[15] = v8 + 15;
          --v55;
          v8 += 16;
          v54 += 16;
        }
        while (v55 > 1);
        v163 = v58;
        uint64_t v59 = (uint64_t)v165;
        unsigned int v8 = v57;
      }
      else
      {
LABEL_23:
        uint64_t v59 = (uint64_t)v9;
      }
      if ((int)v14 < 1)
      {
LABEL_182:
        int v9 = (unsigned __int8 *)v59;
        goto LABEL_189;
      }
LABEL_25:
      uint64_t v60 = 0;
      unsigned int v61 = 2 - v20 + v59;
      do
      {
        unsigned int v62 = v61;
        int v9 = (unsigned __int8 *)(v59 + v60);
        if (v59 + v60 >= v12) {
          goto LABEL_189;
        }
        v165 = v9 + 1;
        int v63 = *(_DWORD *)(v16 + 4 * *v9);
        int v64 = (v63 >> 20) & 0xF;
        if (v63 < -2146435072 || v64 == 2)
        {
          *v11++ = v63;
          v164 = v11;
          uint64_t v59 = (uint64_t)v165;
          BOOL v52 = __OFSUB__(v14, 1);
          LODWORD(v14) = v14 - 1;
          if (((int)v14 < 0) ^ v52 | (v14 == 0)) {
            goto LABEL_182;
          }
          goto LABEL_25;
        }
        ++v60;
        if (v64 == 6) {
          goto LABEL_37;
        }
        unsigned int v61 = v62 + 1;
      }
      while (v64 != 7);
      *unint64_t v2 = 12;
LABEL_37:
      uint64_t v66 = v163;
      if (v163 && (int)v59 - (int)v20 + (int)v60 > 1)
      {
        do
        {
          *v66++ = v8++;
          --v62;
        }
        while (v62 > 2);
        v163 = v66;
      }
      if (*v2 >= 1)
      {
        int v9 = v165;
        goto LABEL_189;
      }
      unsigned int v20 = (unsigned __int8 *)(v59 + v60);
      *(unsigned char *)(v10 + 65) = *(unsigned char *)(v59 + v60 - 1);
      uint64_t v67 = *(void *)(*(void *)(v10 + 48) + 288);
      if (!v67)
      {
        int v9 = v165;
LABEL_187:
        *unint64_t v2 = 10;
        *(unsigned char *)(v10 + 64) = 1;
        unsigned int v8 = v9 + v8 - v59 - v60 + 1;
        unsigned int v20 = (unsigned __int8 *)(v59 + v60);
        goto LABEL_189;
      }
      uint64_t v68 = v2;
      uint64_t result = sub_18C85EF38(v10, v67, 1, (uint64_t *)&v165, v12, (unint64_t *)&v164, *(void *)(v13 + 40), &v163, v8, *(unsigned char *)(v13 + 2), v2);
      int v9 = v165;
      if (!result)
      {
        unint64_t v2 = v68;
        goto LABEL_187;
      }
      int v69 = *v68;
      *(unsigned char *)(v10 + 64) = 0;
      unint64_t v2 = v68;
      if (v69 >= 1) {
        break;
      }
      unsigned int v8 = 1 - v59 + v8 + v9 - v60;
      uint64_t v11 = v164;
      uint64_t v14 = (*(void *)(v13 + 40) - (void)v164) >> 1;
      if ((int)v12 - (int)v9 < (int)v14) {
        LODWORD(v14) = v12 - v9;
      }
      int32x4_t v18 = (int32x4_t)xmmword_18CA810A0;
      int32x4_t v17 = (int32x4_t)xmmword_18CA81090;
      int32x4_t v19 = (int32x4_t)xmmword_18CA810B0;
      uint64_t result = 2;
    }
    unsigned int v20 = (unsigned __int8 *)(v59 + v60);
    unsigned int v8 = v8 + v9 - v59 - v60 + 1;
LABEL_189:
    BOOL v143 = *v2 > 0 || (unint64_t)v9 >= v12;
    if (!v143 && (unint64_t)v164 >= *(void *)(v13 + 40)) {
      *unint64_t v2 = 15;
    }
    v144 = v163;
    if (v163 && v9 != v20)
    {
      int64_t v145 = v20 - v9;
      do
      {
        *v144++ = v8++;
        BOOL v143 = __CFADD__(v145++, 1);
      }
      while (!v143);
    }
    *(void *)(v13 + 16) = v9;
    *(void *)(v13 + 32) = v164;
    *(void *)(v13 + 48) = v144;
    return result;
  }
  uint64_t v125 = *(void *)(v3 + 8);
  v124 = *(unsigned char **)(v3 + 16);
  unint64_t v127 = *(void *)(v3 + 24);
  v126 = *(_WORD **)(v3 + 32);
  unint64_t v128 = *(void *)(v3 + 40);
  v163 = *(int **)(v3 + 48);
  v164 = v126;
  uint64_t v129 = 64;
  if ((*(unsigned char *)(v125 + 56) & 0x10) == 0) {
    uint64_t v129 = 56;
  }
  if ((unint64_t)v124 >= v127)
  {
LABEL_178:
    unint64_t v132 = (unint64_t)v124;
    goto LABEL_179;
  }
  int v130 = 0;
  uint64_t v131 = *(void *)(*(void *)(v125 + 48) + v129);
  while (1)
  {
    v126 = v164;
    if ((unint64_t)v164 >= v128)
    {
      *unint64_t v2 = 15;
      goto LABEL_178;
    }
    unint64_t v132 = (unint64_t)(v124 + 1);
    v165 = v124 + 1;
    int v133 = *(_DWORD *)(v131 + 4 * *v124);
    if (v133 < -2146435072)
    {
LABEL_154:
      _WORD *v164 = v133;
      v164 = v126 + 1;
      v134 = v163;
      if (v163)
      {
        int *v163 = v130;
        v163 = v134 + 1;
      }
      goto LABEL_166;
    }
    if ((v133 & 0xD00000) == 0x100000) {
      break;
    }
    int v138 = (v133 >> 20) & 0xF;
    if (v138 == 2) {
      goto LABEL_154;
    }
    if (v138 != 6)
    {
      if (v138 == 7)
      {
        *unint64_t v2 = 12;
        goto LABEL_179;
      }
      goto LABEL_166;
    }
    if (*v2 > 0) {
      goto LABEL_176;
    }
    *(void *)(v3 + 16) = v132;
    *(unsigned char *)(v125 + 65) = *v124;
    uint64_t v139 = *(void *)(*(void *)(v125 + 48) + 288);
    if (v139
      && (v140 = v2,
          result = sub_18C85EF38(v125, v139, 1, (uint64_t *)&v165, v127, (unint64_t *)&v164, v128, &v163, v130, *(unsigned char *)(v3 + 2), v2), unint64_t v2 = v140, result))
    {
      char v141 = 0;
      int v142 = *v140;
    }
    else
    {
      int v142 = 10;
      *unint64_t v2 = 10;
      char v141 = 1;
    }
    *(unsigned char *)(v125 + 64) = v141;
    unint64_t v132 = (unint64_t)v165;
    if (v142 >= 1)
    {
LABEL_176:
      v126 = v164;
      goto LABEL_179;
    }
    v130 += v165 - *(_DWORD *)(v3 + 16) + 1;
LABEL_167:
    v124 = (unsigned char *)v132;
    if (v132 >= v127) {
      goto LABEL_176;
    }
  }
  _WORD *v164 = (v133 >> 10) & 0x3FF | 0xD800;
  v135 = v126 + 1;
  v136 = v163;
  __int16 v137 = v133 & 0x3FF | 0xDC00;
  if (v163)
  {
    int *v163 = v130;
    v163 = v136 + 1;
    if ((unint64_t)v135 >= v128) {
      goto LABEL_183;
    }
    v164 = v126 + 2;
    v126[1] = v137;
    v163 = v136 + 2;
    v136[1] = v130;
    goto LABEL_166;
  }
  if ((unint64_t)v135 < v128)
  {
    v164 = v126 + 2;
    v126[1] = v137;
LABEL_166:
    ++v130;
    goto LABEL_167;
  }
LABEL_183:
  *(_WORD *)(v125 + 144) = v137;
  *(unsigned char *)(v125 + 93) = 1;
  *unint64_t v2 = 15;
  ++v126;
LABEL_179:
  *(void *)(v3 + 16) = v132;
  *(void *)(v3 + 32) = v126;
  *(void *)(v3 + 48) = v163;
  return result;
}

uint64_t sub_18C86D300(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  if (!v2) {
    return 65534;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (v2 == 1)
  {
    uint64_t v4 = 0;
  }
  else
  {
    LODWORD(v4) = 0;
    do
    {
      unsigned int v5 = (v2 + v4) >> 1;
      unsigned int v6 = *(_DWORD *)(v3 + 8 * v5);
      if (v6 <= a2) {
        uint64_t v4 = v5;
      }
      else {
        uint64_t v4 = v4;
      }
      if (v6 > a2) {
        unsigned int v2 = v5;
      }
    }
    while (v4 < v2 - 1);
  }
  if (*(_DWORD *)(v3 + 8 * v4) == a2) {
    return *(unsigned int *)(v3 + 8 * v4 + 4);
  }
  else {
    return 65534;
  }
}

uint64_t sub_18C86D36C(uint64_t a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + ((unint64_t)a2 << 10) + 4 * a4);
  if ((v4 & 0x80000000) == 0) {
    return sub_18C871218(a1, HIBYTE(v4));
  }
  int v6 = (v4 >> 20) & 0xF;
  if (a3) {
    BOOL v7 = v6 == 8;
  }
  else {
    BOOL v7 = 0;
  }
  return !v7 && v6 != 7;
}

uint64_t sub_18C86D39C(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = a3 - 1;
  if (a3 < 1) {
    return 0xFFFFLL;
  }
  uint64_t v6 = 0;
  int v7 = 0;
  uint64_t v8 = a1 + 48;
  uint64_t v9 = *(void *)(a1 + 72);
  uint64_t v11 = *(unsigned __int8 *)(a1 + 49);
  while (1)
  {
    unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 56) + (v11 << 10) + 4 * *(unsigned __int8 *)(a2 + v6));
    if ((v12 & 0x80000000) != 0) {
      break;
    }
    ++v6;
    uint64_t v11 = HIBYTE(v12);
    v7 += v12 & 0xFFFFFF;
    if (a3 == v6) {
      return 0xFFFFLL;
    }
  }
  uint64_t result = 65534;
  switch((v12 >> 20) & 0xF)
  {
    case 0u:
    case 2u:
      uint64_t result = (unsigned __int16)v12;
      goto LABEL_18;
    case 1u:
    case 3u:
      uint64_t result = (v12 & 0xFFFFF) + 0x10000;
      goto LABEL_18;
    case 4u:
      unsigned int v14 = v7 + (unsigned __int16)v12;
      uint64_t result = *(unsigned __int16 *)(v9 + 2 * v14);
      if (result == 65534) {
        uint64_t result = sub_18C86D300(v8, v14);
      }
      goto LABEL_18;
    case 5u:
      unsigned int v15 = v7 + (unsigned __int16)v12;
      uint64_t result = *(unsigned __int16 *)(v9 + 2 * v15);
      if (result >> 11 < 0x1B) {
        goto LABEL_18;
      }
      unsigned int v16 = v15 + 1;
      if (result >> 13 > 6)
      {
        if ((result & 0xFFFE) == 0xE000)
        {
          uint64_t result = *(unsigned __int16 *)(v9 + 2 * v16);
        }
        else
        {
          BOOL v17 = result == 0xFFFF;
          uint64_t result = 0xFFFFLL;
          if (v17) {
            return result;
          }
          uint64_t result = 65534;
        }
      }
      else
      {
        uint64_t result = ((result & 0x3FF) << 10) + *(unsigned __int16 *)(v9 + 2 * v16) + 9216;
      }
LABEL_18:
      if (v3 != v6) {
        return 0xFFFFLL;
      }
      if (result == 65534)
      {
        uint64_t v18 = *(void *)(a1 + 288);
        if (v18)
        {
          uint64_t result = sub_18C85F300(v18, a2, a3);
        }
        else
        {
          uint64_t result = 65534;
        }
      }
      break;
    case 6u:
      goto LABEL_18;
    default:
      return 0xFFFFLL;
  }
  return result;
}

uint64_t sub_18C86D560(uint64_t result, int *a2)
{
  unsigned int v2 = a2;
  uint64_t v3 = result;
  v205 = 0;
  unint64_t v206 = 0;
  v204 = 0;
  uint64_t v4 = *(void *)(result + 8);
  if ((*(_DWORD *)(v4 + 208) & 0x80000000) == 0)
  {
    uint64_t result = sub_18C85FAF4(*(void *)(result + 8), result, -1, a2);
    if (*v2 > 0 || *(char *)(v4 + 281) < 0) {
      return result;
    }
  }
  uint64_t v5 = *(void *)(v4 + 48);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 252);
  char v7 = *(unsigned char *)(v5 + 253);
  int v8 = v6 - 1;
  if (v6 == 1)
  {
    if (*(unsigned char *)(v5 + 254))
    {
      int v22 = 0;
      uint64_t v24 = *(void *)(v3 + 8);
      int v23 = *(unsigned __int16 **)(v3 + 16);
      uint64_t v25 = *(void *)(v24 + 48);
      char v26 = *(unsigned char *)(v25 + 253);
      unint64_t v27 = *(void *)(v3 + 24);
      v208 = *(unsigned char **)(v3 + 32);
      v209 = 0;
      int v28 = *(_DWORD *)(v3 + 40) - v208;
      v207 = *(int **)(v3 + 48);
      uint64_t v29 = *(void *)(v25 + 88);
      uint64_t v30 = *(void *)(v25 + 96);
      uint64_t v31 = 240;
      if ((*(unsigned char *)(v24 + 56) & 0x10) == 0) {
        uint64_t v31 = 232;
      }
      uint64_t v32 = *(void *)(v25 + v31);
      unsigned int v33 = *(_DWORD *)(v25 + 260);
      LODWORD(v34) = *(_DWORD *)(v24 + 84);
      if (v34) {
        int v35 = -1;
      }
      else {
        int v35 = 0;
      }
      if (!v34 || v28 <= 0) {
        goto LABEL_386;
      }
      do
      {
        if ((unint64_t)v23 >= v27) {
          goto LABEL_419;
        }
        int v36 = *v23;
        if ((v36 & 0xFC00) != 0xDC00) {
          break;
        }
        v209 = ++v23;
        ++v22;
        unint64_t v34 = ((v34 << 10) - 56613888 + v36);
        if (v26) {
          goto LABEL_29;
        }
LABEL_123:
        while (2)
        {
          *(void *)(v3 + 16) = v23;
          uint64_t result = sub_18C86EAF0(v24, *(void *)(v24 + 48), v34, (uint64_t *)&v209, v27, &v208, (unint64_t)&v208[v28], &v207, v35, *(unsigned char *)(v3 + 2), v2);
          LODWORD(v34) = result;
          int v23 = v209;
          if (*v2 > 0) {
            goto LABEL_419;
          }
          int v35 = v22 + (((unint64_t)v209 - *(void *)(v3 + 16)) >> 1);
          int v28 = *(_DWORD *)(v3 + 40) - v208;
          int v22 = v35;
LABEL_386:
          if ((unint64_t)v23 >= v27) {
            goto LABEL_419;
          }
          if (v28 < 1)
          {
LABEL_397:
            int v178 = 15;
LABEL_398:
            *unsigned int v2 = v178;
            goto LABEL_419;
          }
          ++v22;
          while (1)
          {
            unint64_t v34 = *v23;
            v209 = v23 + 1;
            if (v34 > 0x7F) {
              break;
            }
            if (((v33 >> (v34 >> 2)) & 1) == 0)
            {
              ++v23;
LABEL_408:
              unsigned int v37 = *(unsigned __int16 *)(v32 + 2 * ((v34 & 0x3F) + *(unsigned __int16 *)(v30 + ((v34 >> 5) & 0x7FE))));
LABEL_409:
              if (!v37) {
                goto LABEL_123;
              }
LABEL_410:
              if (v37 > 0xFF)
              {
                v184 = v208++;
                unsigned char *v184 = BYTE1(v37);
                if (v28 < 2)
                {
                  v187 = v207;
                  if (v207)
                  {
                    int *v207 = v35;
                    v207 = v187 + 1;
                  }
                  LODWORD(v34) = 0;
                  *(unsigned char *)(v24 + 104) = v37;
                  *(unsigned char *)(v24 + 91) = 1;
                  *unsigned int v2 = 15;
                  int v23 = v209;
LABEL_419:
                  *(_DWORD *)(v24 + 84) = v34;
                  *(void *)(v3 + 16) = v23;
LABEL_383:
                  *(void *)(v3 + 32) = v208;
                  int64_t v145 = v207;
                  goto LABEL_384;
                }
                v185 = v208++;
                unsigned char *v185 = v37;
                v186 = v207;
                int v182 = -2;
                if (v207)
                {
                  v181 = v207 + 1;
                  int *v207 = v35;
                  v183 = v186 + 2;
LABEL_416:
                  v207 = v183;
                  int *v181 = v35;
                }
              }
              else
              {
                v180 = v208++;
                unsigned char *v180 = v37;
                v181 = v207;
                int v182 = -1;
                if (v207)
                {
                  v183 = v207 + 1;
                  goto LABEL_416;
                }
              }
              LODWORD(v34) = 0;
              v28 += v182;
              int v23 = v209;
              int v35 = v22;
              goto LABEL_386;
            }
            v175 = v208++;
            unsigned char *v175 = v34;
            v176 = v207;
            if (v207)
            {
              int *v207 = v35;
              v207 = v176 + 1;
              int v35 = v22;
            }
            int v23 = v209;
            if ((unint64_t)v209 >= v27)
            {
              LODWORD(v34) = 0;
              goto LABEL_419;
            }
            ++v22;
            if (v28-- < 2)
            {
              LODWORD(v34) = 0;
              goto LABEL_397;
            }
          }
          ++v23;
          if (v34 >> 11 < 0x1B) {
            goto LABEL_408;
          }
          if ((v34 & 0xF800) != 0xD800 || (v26 & 2) != 0)
          {
LABEL_29:
            unsigned int v37 = *(unsigned __int16 *)(v32
                                      + 2
                                      * (v34 & 0xF | (16
                                                    * (unsigned __int16)*(_DWORD *)(v29
                                                                                                + 4
                                                                                                * (((v34 >> 4) & 0x3F)
                                                                                                 + *(unsigned __int16 *)(v29 + 2 * ((int)v34 >> 10)))))));
            if (((*(_DWORD *)(v29
                             + 4
                             * (((v34 >> 4) & 0x3F) + *(unsigned __int16 *)(v29 + 2 * ((int)v34 >> 10)))) >> (v34 & 0xF | 0x10)) & 1) != 0)
              goto LABEL_410;
            if (*(unsigned char *)(v24 + 63)
              || (v34 - 57344) >> 8 < 0x19
              || !((v34 - 983040) >> 17))
            {
              goto LABEL_409;
            }
            continue;
          }
          break;
        }
      }
      while ((v34 & 0x400) == 0);
      int v178 = 12;
      goto LABEL_398;
    }
  }
  else if (!*(unsigned char *)(v5 + 252) && (*(unsigned char *)(v5 + 253) & 2) == 0)
  {
    if ((*(unsigned char *)(v5 + 253) & 1) == 0)
    {
      uint64_t v10 = *(void *)(v3 + 8);
      uint64_t v9 = *(char **)(v3 + 16);
      unint64_t v11 = *(void *)(v3 + 24);
      v208 = *(unsigned char **)(v3 + 32);
      v209 = (unsigned __int16 *)v9;
      int v12 = *(_DWORD *)(v3 + 40) - v208;
      v207 = *(int **)(v3 + 48);
      uint64_t v13 = *(void *)(v10 + 48);
      uint64_t v14 = *(void *)(v13 + 88);
      uint64_t v15 = 240;
      if ((*(unsigned char *)(v10 + 56) & 0x10) == 0) {
        uint64_t v15 = 232;
      }
      uint64_t v16 = *(void *)(v13 + v15);
      unsigned int v17 = *(_DWORD *)(v13 + 260);
      int v202 = *(unsigned __int8 *)(v10 + 63);
      LODWORD(v18) = *(_DWORD *)(v10 + 84);
      if (v18) {
        int v19 = -1;
      }
      else {
        int v19 = 0;
      }
      unint64_t v20 = (v11 - (unint64_t)v9) >> 1;
      if ((int)v20 >= v12) {
        LODWORD(v20) = v12;
      }
      if (!v18 || (signed int v21 = v9, (int)v20 <= 0))
      {
LABEL_81:
        if ((int)v20 < 1) {
          goto LABEL_118;
        }
        if (v202) {
          unsigned int v75 = 2048;
        }
        else {
          unsigned int v75 = 3072;
        }
        int v76 = v20 + 1;
        while (1)
        {
          uint64_t v77 = v209;
          unsigned int v78 = *v209;
          unint64_t v18 = *v209++;
          if (v78 <= 0x7F && ((v17 >> (v18 >> 2)) & 1) != 0)
          {
            int v79 = v208++;
            *int v79 = v18;
          }
          else
          {
            unsigned int v80 = *(unsigned __int16 *)(v16
                                      + 2
                                      * ((v18 & 0xF)
                                       + *(unsigned __int16 *)(v14
                                                             + 2
                                                             * (((v18 >> 4) & 0x3F)
                                                              + *(unsigned __int16 *)(v14 + ((v18 >> 9) & 0x7E))))));
            if (v75 > v80)
            {
              signed int v21 = (char *)(v77 + 1);
              if ((v18 & 0xF800) == 0xD800)
              {
                if ((v18 & 0x400) == 0) {
                  break;
                }
LABEL_119:
                int v91 = 12;
LABEL_122:
                *unsigned int v2 = v91;
                goto LABEL_93;
              }
LABEL_107:
              if (v18 < 0x10000) {
                int v87 = 1;
              }
              else {
                int v87 = 2;
              }
              uint64_t v88 = v207;
              if (v207)
              {
                int v89 = ((unint64_t)(v21 - v9) >> 1) - v87;
                if (v89 >= 1)
                {
                  unsigned int v90 = v89 + 1;
                  do
                  {
                    *v88++ = v19++;
                    --v90;
                  }
                  while (v90 > 1);
                  v207 = v88;
                }
              }
              uint64_t result = sub_18C86EAF0(v10, *(void *)(v10 + 48), v18, (uint64_t *)&v209, v11, &v208, *(void *)(v3 + 40), &v207, v19, *(unsigned char *)(v3 + 2), v2);
              LODWORD(v18) = result;
              uint64_t v9 = (char *)v209;
              v19 += v87 + ((unint64_t)((char *)v209 - v21) >> 1);
              if (*v2 <= 0)
              {
                unint64_t v20 = (v11 - (unint64_t)v209) >> 1;
                if ((int)v20 >= *(_DWORD *)(v3 + 40) - (int)v208) {
                  LODWORD(v20) = *(_DWORD *)(v3 + 40) - v208;
                }
                goto LABEL_81;
              }
LABEL_118:
              signed int v21 = v9;
              goto LABEL_93;
            }
            uint64_t v81 = v208++;
            *uint64_t v81 = v80;
          }
          if (--v76 <= 1)
          {
            LODWORD(v18) = 0;
            signed int v21 = (char *)v209;
            goto LABEL_93;
          }
        }
      }
      if ((unint64_t)v21 < v11)
      {
        int v86 = *(unsigned __int16 *)v21;
        if ((v86 & 0xFC00) != 0xDC00) {
          goto LABEL_119;
        }
        v21 += 2;
        v209 = (unsigned __int16 *)v21;
        unint64_t v18 = ((v18 << 10) - 56613888 + v86);
        goto LABEL_107;
      }
      if (*(unsigned char *)(v3 + 2))
      {
        int v91 = 11;
        goto LABEL_122;
      }
LABEL_93:
      int v82 = *v2;
      if (*v2 <= 0 && (unint64_t)v21 < v11 && (unint64_t)v208 >= *(void *)(v3 + 40))
      {
        int v82 = 15;
        *unsigned int v2 = 15;
      }
      uint64_t v83 = v207;
      if (v207)
      {
        uint64_t v84 = v21 - v9;
        if (v84)
        {
          for (uint64_t i = (v84 >> 1) - (v82 == 11); i; --i)
            *v83++ = v19++;
        }
      }
      *(_DWORD *)(v10 + 84) = v18;
      *(void *)(v3 + 16) = v21;
      *(void *)(v3 + 32) = v208;
      *(void *)(v3 + 48) = v83;
      return result;
    }
    int v62 = 0;
    uint64_t v64 = *(void *)(v3 + 8);
    int v63 = *(unsigned __int16 **)(v3 + 16);
    unint64_t v65 = *(void *)(v3 + 24);
    v208 = *(unsigned char **)(v3 + 32);
    v209 = 0;
    int v66 = *(_DWORD *)(v3 + 40) - v208;
    v207 = *(int **)(v3 + 48);
    uint64_t v67 = *(void *)(v64 + 48);
    uint64_t v68 = *(void *)(v67 + 88);
    uint64_t v69 = 240;
    if ((*(unsigned char *)(v64 + 56) & 0x10) == 0) {
      uint64_t v69 = 232;
    }
    uint64_t v70 = *(void *)(v67 + v69);
    if (*(unsigned char *)(v64 + 63)) {
      unsigned int v71 = 2048;
    }
    else {
      unsigned int v71 = 3072;
    }
    char v72 = *(unsigned char *)(v67 + 253);
    LODWORD(v73) = *(_DWORD *)(v64 + 84);
    if (v73) {
      int v74 = -1;
    }
    else {
      int v74 = 0;
    }
    if (v73 && v66 > 0) {
      goto LABEL_368;
    }
    while (1)
    {
      if ((unint64_t)v63 >= v65)
      {
LABEL_382:
        *(_DWORD *)(v64 + 84) = v73;
        *(void *)(v3 + 16) = v63;
        goto LABEL_383;
      }
      if (v66 < 1)
      {
        int v174 = 15;
        goto LABEL_381;
      }
      unsigned int v169 = *v63++;
      uint64_t v73 = v169;
      v209 = v63;
      ++v62;
      if ((v169 & 0xF800) != 0xD800) {
        break;
      }
      if ((v73 & 0x400) != 0) {
        goto LABEL_379;
      }
LABEL_368:
      if ((unint64_t)v63 >= v65) {
        goto LABEL_382;
      }
      int v170 = *v63;
      if ((v170 & 0xFC00) != 0xDC00)
      {
LABEL_379:
        int v174 = 12;
LABEL_381:
        *unsigned int v2 = v174;
        goto LABEL_382;
      }
      v209 = ++v63;
      ++v62;
      uint64_t v73 = ((v73 << 10) - 56613888 + v170);
      v171 = v208;
      if (v72)
      {
LABEL_373:
        unsigned int v172 = *(unsigned __int16 *)(v70
                                   + 2
                                   * ((v73 & 0xF)
                                    + *(unsigned __int16 *)(v68
                                                          + 2
                                                          * (((v73 >> 4) & 0x3F)
                                                           + *(unsigned __int16 *)(v68 + 2 * ((int)v73 >> 10))))));
        if (v71 > v172) {
          goto LABEL_374;
        }
        v208 = v171 + 1;
        unsigned char *v171 = v172;
        v173 = v207;
        if (v207)
        {
          int *v207 = v74;
          v207 = v173 + 1;
        }
        LODWORD(v73) = 0;
        --v66;
        int v63 = v209;
        int v74 = v62;
      }
      else
      {
LABEL_374:
        *(void *)(v3 + 16) = v63;
        uint64_t result = sub_18C86EAF0(v64, *(void *)(v64 + 48), v73, (uint64_t *)&v209, v65, &v208, (unint64_t)&v171[v66], &v207, v74, *(unsigned char *)(v3 + 2), v2);
        LODWORD(v73) = result;
        int v63 = v209;
        if (*v2 > 0) {
          goto LABEL_382;
        }
        int v74 = v62 + (((unint64_t)v209 - *(void *)(v3 + 16)) >> 1);
        int v66 = *(_DWORD *)(v3 + 40) - v208;
        int v62 = v74;
      }
    }
    v171 = v208;
    goto LABEL_373;
  }
  int v39 = *(unsigned __int16 **)(v3 + 16);
  unint64_t v38 = *(void *)(v3 + 24);
  int v40 = *(unsigned char **)(v3 + 32);
  v205 = v40;
  unint64_t v206 = (unint64_t)v39;
  int v41 = *(_DWORD *)(v3 + 40);
  int v42 = *(int **)(v3 + 48);
  v204 = v42;
  if (*(unsigned char *)(v5 + 254)) {
    uint64_t v43 = *(void *)(v5 + 96);
  }
  else {
    uint64_t v43 = 0;
  }
  int v44 = *(_DWORD *)(v4 + 56);
  uint64_t v45 = 232;
  if ((v44 & 0x10) != 0) {
    uint64_t v45 = 240;
  }
  LODWORD(v46) = *(_DWORD *)(v4 + 84);
  if (v6 == 12)
  {
    int v47 = *(_DWORD *)(v4 + 80);
    if (v47 <= 1) {
      int v47 = 1;
    }
  }
  else
  {
    int v47 = 0;
  }
  int v48 = v41 - v40;
  uint64_t v195 = *(void *)(v5 + 88);
  uint64_t v197 = *(void *)(v5 + v45);
  if (v46) {
    int v49 = -1;
  }
  else {
    int v49 = 0;
  }
  if ((v44 & 0x1000) != 0)
  {
    uint64_t v192 = 0x4100420000;
    char v196 = 2;
    int v193 = 2;
    int v194 = 10;
    int v56 = 10;
    int v57 = 2;
LABEL_66:
    int v190 = v57;
    int v191 = v56;
    goto LABEL_67;
  }
  if ((v44 & 0x2000) != 0)
  {
    char v196 = 1;
    uint64_t v192 = 0;
    int v56 = 40;
    int v57 = 1;
    int v193 = 1;
    int v194 = 41;
    goto LABEL_66;
  }
  int v50 = v44 << 17;
  if ((v44 & 0x4000) != 0) {
    int v51 = 26;
  }
  else {
    int v51 = 15;
  }
  if ((v44 & 0x4000) != 0) {
    int v52 = 2;
  }
  else {
    int v52 = 1;
  }
  uint64_t result = 1;
  if ((v44 & 0x4000) != 0) {
    int v53 = 26;
  }
  else {
    int v53 = 14;
  }
  int v191 = v53;
  int v193 = v52;
  int v194 = v51;
  char v196 = v52;
  if ((*(_DWORD *)(v4 + 56) & 0x4000) != 0) {
    int v54 = 7340032;
  }
  else {
    int v54 = 0;
  }
  if ((*(_DWORD *)(v4 + 56) & 0x4000) != 0) {
    int v55 = 2;
  }
  else {
    int v55 = 1;
  }
  int v190 = v55;
  LODWORD(v192) = v54;
  HIDWORD(v192) = (v50 >> 31) & 0x71;
LABEL_67:
  int v58 = 0;
  unsigned int v59 = *(_DWORD *)(v5 + 260);
  int v60 = -1;
  v203 = v2;
  int v199 = v6 - 1;
  char v198 = v7;
  unsigned int v201 = v59;
  uint64_t v61 = 0;
  if (v46 && v48 > 0) {
    goto LABEL_150;
  }
  while (1)
  {
    while (1)
    {
      if ((unint64_t)v39 >= v38) {
        goto LABEL_162;
      }
      int v92 = v48 & (v48 >> 31);
      if (v48 < 1)
      {
LABEL_136:
        int v94 = 15;
        goto LABEL_137;
      }
      ++v58;
      while (1)
      {
        unint64_t v46 = *v39;
        unint64_t v206 = (unint64_t)(v39 + 1);
        if (v46 > 0x7F || ((v59 >> (v46 >> 2)) & 1) == 0) {
          break;
        }
        uint64_t v93 = v205++;
        *uint64_t v93 = v46;
        int v42 = v204;
        if (v204)
        {
          int *v204 = v49;
          v204 = ++v42;
          int v60 = v49;
          int v49 = v58;
        }
        --v48;
        int v39 = (unsigned __int16 *)v206;
        if (v206 >= v38)
        {
          LODWORD(v46) = 0;
          goto LABEL_162;
        }
        ++v58;
        if (v48 + 1 < 2)
        {
          LODWORD(v46) = 0;
          goto LABEL_136;
        }
      }
      ++v39;
      if (v46 >> 11 > 0x1A || v43 == 0) {
        break;
      }
      int v104 = *(unsigned __int16 *)(v43 + ((v46 >> 5) & 0x7FE));
      switch(v8)
      {
        case 0:
          unsigned int v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
          if (v102 > 0xFF) {
            goto LABEL_242;
          }
          goto LABEL_290;
        case 1:
          uint64_t v125 = (unsigned __int8 *)(v197 + 3 * ((v46 & 0x3F) + v104));
          unsigned int v102 = (*v125 << 16) | (v125[1] << 8) | v125[2];
          if (v102 <= 0xFF) {
            goto LABEL_290;
          }
          if (v102 < 0x10000) {
            uint64_t v61 = 2;
          }
          else {
            uint64_t v61 = 3;
          }
          break;
        case 2:
          unsigned int v102 = *(_DWORD *)(v197 + 4 * ((v46 & 0x3F) + v104));
          if (v102 <= 0xFF) {
            goto LABEL_290;
          }
          if (HIBYTE(v102)) {
            LODWORD(v61) = 4;
          }
          else {
            LODWORD(v61) = 3;
          }
          if (v102 >= 0x10000) {
            uint64_t v61 = v61;
          }
          else {
            uint64_t v61 = 2;
          }
          break;
        case 3:
        case 4:
        case 5:
        case 6:
        case 9:
        case 10:
          goto LABEL_266;
        case 7:
          unsigned int v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
          if (v102 <= 0xFF) {
            goto LABEL_290;
          }
          int v126 = v102 | 0x8F0080;
          if ((v102 & 0x80) != 0)
          {
            int v126 = v102;
            LODWORD(v61) = 2;
          }
          else
          {
            LODWORD(v61) = 3;
          }
          BOOL v127 = (v102 & 0x8000) == 0;
          if ((v102 & 0x8000) != 0) {
            unsigned int v102 = v126;
          }
          else {
            v102 |= 0x8E8000u;
          }
          if (v127) {
            uint64_t v61 = 3;
          }
          else {
            uint64_t v61 = v61;
          }
          break;
        case 8:
          unint64_t v128 = (unsigned __int8 *)(v197 + 3 * ((v46 & 0x3F) + v104));
          int v129 = *v128;
          int v130 = v128[1];
          unsigned int v102 = v128[2] | (v129 << 16) | (v130 << 8);
          if (v102 > 0xFF)
          {
            uint64_t v61 = 2;
            if (v102 >= 0x10000)
            {
              if ((char)v129 < 0)
              {
                if ((v130 & 0x80u) != 0)
                {
                  uint64_t v61 = 3;
                }
                else
                {
                  v102 |= 0x8F008000;
                  uint64_t v61 = 4;
                }
              }
              else
              {
                v102 |= 0x8E800000;
                uint64_t v61 = 4;
              }
            }
          }
          else
          {
LABEL_290:
            uint64_t v103 = v61;
            uint64_t v61 = 1;
            if (!v102) {
              goto LABEL_306;
            }
          }
          break;
        case 11:
          *(_DWORD *)(v4 + 80) = v47;
          unsigned int v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
          if (v102 > 0xFF)
          {
            int v146 = v102 | (v191 << 16);
            int v147 = v192 | (v191 << 24) | v102;
            uint64_t result = 4;
            if (v190 == 2) {
              LODWORD(v61) = 4;
            }
            else {
              int v147 = v102;
            }
            if (v190 == 1) {
              LODWORD(v61) = 3;
            }
            else {
              int v146 = v147;
            }
            if (v47 == 2)
            {
              uint64_t v61 = 2;
            }
            else
            {
              unsigned int v102 = v146;
              uint64_t v61 = v61;
            }
            int v47 = 2;
          }
          else
          {
            if (!v102) {
              goto LABEL_305;
            }
            int v131 = v102 | (v194 << 8);
            int v132 = (v194 << 16) | (HIDWORD(v192) << 8) | v102;
            uint64_t result = 3;
            if (v193 == 2) {
              LODWORD(v61) = 3;
            }
            else {
              int v132 = v102;
            }
            if (v193 == 1) {
              LODWORD(v61) = 2;
            }
            else {
              int v131 = v132;
            }
            if (v47 < 2)
            {
              uint64_t v61 = 1;
            }
            else
            {
              unsigned int v102 = v131;
              uint64_t v61 = v61;
            }
            if (v47 >= 2) {
              int v47 = 1;
            }
          }
          break;
        default:
          if (v6 == 219)
          {
            unsigned int v102 = *(unsigned __int16 *)(v197 + 2 * ((v46 & 0x3F) + v104));
            if (v102 < 0x100) {
              goto LABEL_305;
            }
LABEL_242:
            uint64_t v61 = 2;
          }
          else
          {
LABEL_266:
            unsigned int v102 = 0;
            uint64_t v61 = 0;
          }
          break;
      }
LABEL_327:
      int v148 = v61 - v48;
      if ((int)v61 > v48)
      {
        v161 = (unsigned char *)(v4 + 104);
        if (v148 == 1)
        {
          unsigned int v2 = v203;
          char v95 = v196;
        }
        else
        {
          unsigned int v2 = v203;
          char v95 = v196;
          if (v148 != 2)
          {
            if (v148 != 3) {
              goto LABEL_350;
            }
            v161 = (unsigned char *)(v4 + 105);
            *(unsigned char *)(v4 + 104) = BYTE2(v102);
          }
          *v161++ = BYTE1(v102);
        }
        unsigned char *v161 = v102;
LABEL_350:
        *(unsigned char *)(v4 + 91) = v148;
        unsigned int v162 = v102 >> (8 * v148);
        if (v48 != 1)
        {
          if (v48 != 2)
          {
            if (v48 != 3) {
              goto LABEL_359;
            }
            v163 = v205++;
            unsigned char *v163 = BYTE2(v162);
            v164 = v204;
            if (v204)
            {
              int *v204 = v49;
              v204 = v164 + 1;
            }
          }
          v165 = v205++;
          unsigned char *v165 = BYTE1(v162);
          v166 = v204;
          if (v204)
          {
            int *v204 = v49;
            v204 = v166 + 1;
          }
        }
        v167 = v205++;
        unsigned char *v167 = v162;
        v168 = v204;
        if (v204)
        {
          int v92 = 0;
          LODWORD(v46) = 0;
          int *v204 = v49;
          v204 = v168 + 1;
LABEL_360:
          int v94 = 15;
          goto LABEL_138;
        }
LABEL_359:
        int v92 = 0;
        LODWORD(v46) = 0;
        goto LABEL_360;
      }
      if (v42)
      {
        unsigned int v2 = v203;
        unsigned int v59 = v201;
        switch((int)v61)
        {
          case 1:
            goto LABEL_333;
          case 2:
            goto LABEL_332;
          case 3:
            goto LABEL_331;
          case 4:
            uint64_t v149 = v205++;
            *uint64_t v149 = HIBYTE(v102);
            char v150 = v204;
            int *v204 = v49;
            v204 = v150 + 1;
LABEL_331:
            v151 = v205++;
            unsigned char *v151 = BYTE2(v102);
            char v152 = v204;
            int *v204 = v49;
            v204 = v152 + 1;
LABEL_332:
            v153 = v205++;
            unsigned char *v153 = BYTE1(v102);
            uint64_t v154 = v204;
            int *v204 = v49;
            v204 = v154 + 1;
LABEL_333:
            v155 = v205++;
            unsigned char *v155 = v102;
            v156 = v204;
            int *v204 = v49;
            int v42 = v156 + 1;
            v204 = v42;
            break;
          default:
            break;
        }
      }
      else
      {
        unsigned int v2 = v203;
        unsigned int v59 = v201;
        switch((int)v61)
        {
          case 1:
            goto LABEL_338;
          case 2:
            goto LABEL_337;
          case 3:
            goto LABEL_336;
          case 4:
            uint64_t v157 = v205++;
            *uint64_t v157 = HIBYTE(v102);
LABEL_336:
            uint64_t v158 = v205++;
            *uint64_t v158 = BYTE2(v102);
LABEL_337:
            uint64_t v159 = v205++;
            *uint64_t v159 = BYTE1(v102);
LABEL_338:
            v160 = v205++;
            unsigned char *v160 = v102;
            int v42 = v204;
            break;
          default:
            break;
        }
      }
      LODWORD(v46) = 0;
      v48 -= v61;
      if (v42)
      {
        int v60 = v49;
        int v49 = v58;
      }
      int v39 = (unsigned __int16 *)v206;
    }
    if ((v46 & 0xF800) == 0xD800 && (v7 & 2) == 0) {
      break;
    }
LABEL_155:
    unsigned int v100 = *(_DWORD *)(v195
                     + 4 * (((v46 >> 4) & 0x3F) + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10))));
    switch(v8)
    {
      case 0:
        char v101 = v46 & 0xF;
        unsigned int v102 = *(unsigned __int16 *)(v197
                                   + 2
                                   * (v46 & 0xF | (16
                                                 * (unsigned __int16)*(_DWORD *)(v195
                                                                                             + 4
                                                                                             * (((v46 >> 4) & 0x3F)
                                                                                              + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
        if (v102 < 0x100) {
          uint64_t v103 = 1;
        }
        else {
          uint64_t v103 = 2;
        }
        goto LABEL_259;
      case 1:
        char v101 = v46 & 0xF;
        unint64_t v107 = v46 & 0xF | (16
                          * (unsigned __int16)*(_DWORD *)(v195
                                                                      + 4
                                                                      * (((v46 >> 4) & 0x3F)
                                                                       + *(unsigned __int16 *)(v195
                                                                                             + 2 * ((int)v46 >> 10)))));
        unsigned int v102 = (*(unsigned __int8 *)(v197 + v107 + 2 * v107) << 16) | (*(unsigned __int8 *)(v197 + v107 + 2 * v107 + 1) << 8) | *(unsigned __int8 *)(v197 + v107 + 2 * v107 + 2);
        if (v102 < 0x10000) {
          LODWORD(v103) = 2;
        }
        else {
          LODWORD(v103) = 3;
        }
        goto LABEL_192;
      case 2:
        char v101 = v46 & 0xF;
        unsigned int v102 = *(_DWORD *)(v197
                         + 4
                         * (v46 & 0xF | (16
                                       * (unsigned __int16)*(_DWORD *)(v195
                                                                                   + 4
                                                                                   * (((v46 >> 4) & 0x3F)
                                                                                    + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
        if (HIBYTE(v102)) {
          int v108 = 4;
        }
        else {
          int v108 = 3;
        }
        if (v102 >= 0x10000) {
          LODWORD(v103) = v108;
        }
        else {
          LODWORD(v103) = 2;
        }
LABEL_192:
        if (v102 >= 0x100) {
          uint64_t v103 = v103;
        }
        else {
          uint64_t v103 = 1;
        }
        goto LABEL_259;
      case 3:
      case 4:
      case 5:
      case 6:
      case 9:
      case 10:
        goto LABEL_182;
      case 7:
        char v101 = v46 & 0xF;
        unsigned int v109 = *(unsigned __int16 *)(v197
                                   + 2
                                   * (v46 & 0xF | (16
                                                 * (unsigned __int16)*(_DWORD *)(v195
                                                                                             + 4
                                                                                             * (((v46 >> 4) & 0x3F)
                                                                                              + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
        unsigned int v102 = v109 | 0x8F0080;
        if ((v109 & 0x80) != 0)
        {
          unsigned int v102 = *(unsigned __int16 *)(v197
                                     + 2
                                     * (v46 & 0xF | (16
                                                   * (unsigned __int16)*(_DWORD *)(v195
                                                                                               + 4
                                                                                               * (((v46 >> 4) & 0x3F)
                                                                                                + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          unsigned int v110 = 2;
        }
        else
        {
          unsigned int v110 = 3;
        }
        uint64_t result = 3;
        if ((v109 & 0x8000) == 0)
        {
          unsigned int v102 = v109 | 0x8E8000;
          unsigned int v110 = 3;
        }
        if (v109 >= 0x100)
        {
          uint64_t v103 = v110;
        }
        else
        {
          unsigned int v102 = *(unsigned __int16 *)(v197
                                     + 2
                                     * (v46 & 0xF | (16
                                                   * (unsigned __int16)*(_DWORD *)(v195
                                                                                               + 4
                                                                                               * (((v46 >> 4) & 0x3F)
                                                                                                + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          uint64_t v103 = 1;
        }
        goto LABEL_259;
      case 8:
        char v101 = v46 & 0xF;
        unint64_t v111 = v46 & 0xF | (16
                          * (unsigned __int16)*(_DWORD *)(v195
                                                                      + 4
                                                                      * (((v46 >> 4) & 0x3F)
                                                                       + *(unsigned __int16 *)(v195
                                                                                             + 2 * ((int)v46 >> 10)))));
        uint64_t v112 = (unsigned __int8 *)(v197 + v111 + 2 * v111);
        int v113 = *v112;
        int v114 = v112[1];
        unsigned int v115 = v112[2] | (v113 << 16) | (v114 << 8);
        if ((v114 & 0x80u) != 0) {
          unsigned int v116 = v115;
        }
        else {
          unsigned int v116 = v115 | 0x8F008000;
        }
        if ((v114 & 0x80u) != 0) {
          int v117 = 3;
        }
        else {
          int v117 = 4;
        }
        uint64_t result = v115 | 0x8E800000;
        if ((v113 & 0x80u) == 0) {
          unsigned int v118 = v115 | 0x8E800000;
        }
        else {
          unsigned int v118 = v116;
        }
        if ((v113 & 0x80u) == 0) {
          unsigned int v119 = 4;
        }
        else {
          unsigned int v119 = v117;
        }
        if (v115 < 0x10000)
        {
          unsigned int v118 = v115;
          unsigned int v119 = 2;
        }
        if (v115 >= 0x100) {
          unsigned int v102 = v118;
        }
        else {
          unsigned int v102 = v115;
        }
        if (v115 >= 0x100) {
          uint64_t v103 = v119;
        }
        else {
          uint64_t v103 = 1;
        }
        goto LABEL_259;
      case 11:
        *(_DWORD *)(v4 + 80) = v47;
        char v101 = v46 & 0xF;
        unsigned int v120 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
        if (v120 > 0xFF)
        {
          unsigned int v123 = v192 | (v191 << 24) | v120;
          int v124 = v120 | (v191 << 16);
          if (v190 == 1) {
            LODWORD(v61) = 3;
          }
          else {
            int v124 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          }
          if (v190 == 2) {
            LODWORD(v61) = 4;
          }
          else {
            unsigned int v123 = v124;
          }
          uint64_t result = 2;
          if (v47 == 2) {
            unsigned int v102 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          }
          else {
            unsigned int v102 = v123;
          }
          if (v47 == 2) {
            uint64_t v103 = 2;
          }
          else {
            uint64_t v103 = v61;
          }
          int v47 = 2;
        }
        else if (*(_WORD *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100))) {
               || ((v100 >> (v101 | 0x10)) & 1) != 0)
        }
        {
          int v121 = (v194 << 16) | (HIDWORD(v192) << 8) | v120;
          int v122 = v120 | (v194 << 8);
          if (v193 == 1) {
            LODWORD(v61) = 2;
          }
          else {
            int v122 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          }
          if (v193 == 2) {
            LODWORD(v61) = 3;
          }
          else {
            int v121 = v122;
          }
          uint64_t result = 1;
          if (v47 >= 2) {
            unsigned int v102 = v121;
          }
          else {
            unsigned int v102 = *(unsigned __int16 *)(v197 + 2 * (v46 & 0xF | (16 * (unsigned __int16)v100)));
          }
          if (v47 >= 2) {
            uint64_t v103 = v61;
          }
          else {
            uint64_t v103 = 1;
          }
          if (v47 >= 2) {
            int v47 = 1;
          }
        }
        else
        {
          unsigned int v102 = 0;
          uint64_t v103 = 0;
        }
        goto LABEL_259;
      default:
        if (v6 == 219)
        {
          char v101 = v46 & 0xF;
          unsigned int v106 = *(unsigned __int16 *)(v197
                                     + 2
                                     * (v46 & 0xF | (16
                                                   * (unsigned __int16)*(_DWORD *)(v195
                                                                                               + 4
                                                                                               * (((v46 >> 4) & 0x3F)
                                                                                                + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          if (v106 >= 0x100)
          {
            unsigned int v102 = *(unsigned __int16 *)(v197
                                       + 2
                                       * (v46 & 0xF | (16
                                                     * (unsigned __int16)*(_DWORD *)(v195
                                                                                                 + 4
                                                                                                 * (((v46 >> 4) & 0x3F)
                                                                                                  + *(unsigned __int16 *)(v195 + 2 * ((int)v46 >> 10)))))));
          }
          else
          {
            unsigned int v100 = 0;
            unsigned int v102 = 0;
          }
          if (v106 >= 0x100) {
            uint64_t v103 = 2;
          }
          else {
            uint64_t v103 = 0;
          }
        }
        else
        {
LABEL_182:
          unsigned int v100 = 0;
          unsigned int v102 = 0;
          uint64_t v103 = 0;
          char v101 = v46 & 0xF;
        }
LABEL_259:
        if ((v100 >> (v101 | 0x10)))
        {
          uint64_t v61 = v103;
          goto LABEL_327;
        }
        if (*(unsigned char *)(v4 + 63) || (v46 - 57344) >> 8 < 0x19 || !((v46 - 983040) >> 17))
        {
          uint64_t v61 = v103;
          if (v102) {
            goto LABEL_327;
          }
        }
LABEL_306:
        int v200 = v60;
        *(void *)(v3 + 16) = v39;
        uint64_t v133 = *(void *)(v4 + 48);
        uint64_t v134 = v6;
        unsigned int v2 = v203;
        char v189 = *(unsigned char *)(v3 + 2);
        int v188 = v49;
        uint64_t v135 = v4;
        uint64_t v136 = v43;
        int v137 = v49;
        uint64_t v138 = v4;
        uint64_t v139 = v3;
        unint64_t v140 = v38;
        uint64_t v141 = v103;
        uint64_t result = sub_18C86EAF0(v135, v133, v46, (uint64_t *)&v206, v38, &v205, (unint64_t)&v205[v48], &v204, v188, v189, v203);
        uint64_t v142 = v141;
        unint64_t v38 = v140;
        uint64_t v3 = v139;
        uint64_t v4 = v138;
        int v49 = v137;
        uint64_t v43 = v136;
        uint64_t v6 = v134;
        int v60 = v200;
        unsigned int v59 = v201;
        char v7 = v198;
        int v8 = v199;
        LODWORD(v46) = result;
        int v47 = *(_DWORD *)(v4 + 80);
        if (*v203 > 0) {
          goto LABEL_162;
        }
        int v39 = (unsigned __int16 *)v206;
        v58 += (v206 - *(void *)(v3 + 16)) >> 1;
        int v48 = *(_DWORD *)(v3 + 40) - v205;
        int v42 = v204;
        if (v204)
        {
          int v60 = v49;
          int v49 = v58;
        }
        uint64_t v61 = v142;
        break;
    }
  }
  if ((v46 & 0x400) != 0) {
    goto LABEL_267;
  }
LABEL_150:
  if ((unint64_t)v39 >= v38)
  {
LABEL_162:
    char v95 = v196;
    goto LABEL_163;
  }
  int v98 = *v39;
  if ((v98 & 0xFC00) == 0xDC00)
  {
    int v99 = 0;
    unint64_t v206 = (unint64_t)++v39;
    ++v58;
    unint64_t v46 = ((v46 << 10) - 56613888 + v98);
    if ((v7 & 1) == 0)
    {
      *(_DWORD *)(v4 + 80) = v47;
      int v99 = 6;
    }
    if (v99 == 6)
    {
LABEL_305:
      uint64_t v103 = v61;
      goto LABEL_306;
    }
    goto LABEL_155;
  }
LABEL_267:
  int v94 = 12;
  int v92 = v48;
LABEL_137:
  char v95 = v196;
LABEL_138:
  *unsigned int v2 = v94;
  int v48 = v92;
LABEL_163:
  if (v6 == 12 && *v2 <= 0 && v47 == 2)
  {
    if (*(unsigned char *)(v3 + 2))
    {
      int v47 = 2;
      if (v206 >= v38 && !v46)
      {
        if (v48 < 1)
        {
          *(unsigned char *)(v4 + 104) = v194;
          if (v193 == 2) {
            *(unsigned char *)(v4 + 105) = BYTE4(v192);
          }
          *(unsigned char *)(v4 + 91) = v95;
          *unsigned int v2 = 15;
        }
        else
        {
          __int16 v105 = v205++;
          *__int16 v105 = v194;
          if (v193 == 2)
          {
            if (v48 <= 1)
            {
              *(unsigned char *)(v4 + 104) = BYTE4(v192);
              *(unsigned char *)(v4 + 91) = 1;
              *unsigned int v2 = 15;
            }
            else
            {
              BOOL v143 = v205++;
              *BOOL v143 = BYTE4(v192);
            }
          }
          v144 = v204;
          if (v204)
          {
            int *v204 = v60;
            v204 = v144 + 1;
          }
        }
        int v47 = 1;
      }
    }
    else
    {
      int v47 = 2;
    }
  }
  *(_DWORD *)(v4 + 80) = v47;
  *(_DWORD *)(v4 + 84) = v46;
  *(void *)(v3 + 16) = v206;
  *(void *)(v3 + 32) = v205;
  int64_t v145 = v204;
LABEL_384:
  *(void *)(v3 + 48) = v145;
  return result;
}

uint64_t sub_18C86EAF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, void *a6, unint64_t a7, void *a8, int a9, char a10, _DWORD *a11)
{
  uint64_t v14 = a3;
  *(unsigned char *)(a1 + 95) = 0;
  unint64_t v16 = *(void *)(a2 + 288);
  if (!v16 || !sub_18C85F594(a1, v16, a3, a4, a5, a6, a7, a8, a9, a10, a11))
  {
    if ((*(unsigned char *)(a1 + 57) & 0x80) == 0)
    {
LABEL_10:
      *a11 = 10;
      return v14;
    }
    uint64_t v17 = 0;
    while (1)
    {
      unsigned int v18 = dword_18CA811FC[v17];
      BOOL v19 = v14 >= v18;
      int v20 = v14 - v18;
      if (v19 && dword_18CA811FC[v17 + 1] >= v14) {
        break;
      }
      v17 += 4;
      if ((v17 * 4) == 224) {
        goto LABEL_10;
      }
    }
    unsigned int v22 = v20 + dword_18CA811FC[v17 + 2] - 1687218;
    v23[3] = (v22 % 0xA) | 0x30;
    uint64_t v23[2] = v22 / 0xA - 126 * ((545392673 * (unint64_t)(v22 / 0xA)) >> 36) - 127;
    v23[1] = (v22 / 0x4EC - 10 * ((429496730 * (unint64_t)(v22 / 0x4EC)) >> 32)) | 0x30;
    v23[0] = v22 / 0x3138 - 127;
    sub_18C85D210(a1, v23, 4, a6, a7, a8, a9, a11);
  }
  return 0;
}

uint64_t sub_18C86EC94(uint64_t a1, int a2, int *a3, int a4)
{
  if (a2 < 0x10000 || (*(unsigned char *)(a1 + 253) & 1) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (*(unsigned char *)(a1 + 252) != 1)
    {
      if (*(unsigned char *)(a1 + 252)) {
        return 0xFFFFFFFFLL;
      }
      unsigned int v5 = *(unsigned __int16 *)(*(void *)(a1 + 232)
                               + 2
                               * ((a2 & 0xF)
                                + *(unsigned __int16 *)(v4
                                                                    + 2
                                                                    * (((a2 >> 4) & 0x3F)
                                                                     + *(unsigned __int16 *)(v4 + 2 * (a2 >> 10))))));
      if (a4)
      {
        if (v5 <= 0x7FF) {
          goto LABEL_20;
        }
      }
      else if (v5 < 0xC00)
      {
        goto LABEL_20;
      }
      *a3 = v5;
      return 1;
    }
    unsigned int v6 = *(_DWORD *)(v4 + 4 * (((a2 >> 4) & 0x3F) + *(unsigned __int16 *)(v4 + 2 * (a2 >> 10))));
    unsigned int v7 = *(unsigned __int16 *)(*(void *)(a1 + 232) + 2 * (a2 & 0xF | (16 * (unsigned __int16)v6)));
    if (v7 < 0x100) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = 2;
    }
    if (((v6 >> (a2 & 0xF | 0x10)) & 1) != 0
      || (a4 || (a2 - 57344) >> 8 < 0x19 || !((a2 - 983040) >> 17))
      && *(_WORD *)(*(void *)(a1 + 232) + 2 * (a2 & 0xF | (16 * (unsigned __int16)v6))))
    {
      *a3 = v7;
      return v8;
    }
  }
LABEL_20:
  unint64_t v9 = *(void *)(a1 + 288);
  if (!v9) {
    return 0;
  }
  LODWORD(result) = sub_18C85FA6C(v9, a2, a3, a4);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return -(int)result;
  }
}

BOOL sub_18C86EDAC(uint64_t a1, unsigned __int8 a2)
{
  return *(_DWORD *)(*(void *)(a1 + 56) + 4 * a2) >= 0;
}

uint64_t sub_18C86EDC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (*(unsigned char *)(v1 + 48) == 1) {
    return 0;
  }
  if (*(unsigned char *)(v1 + 252) == 12) {
    return 9;
  }
  uint64_t v3 = *(void *)(v1 + 16);
  if (*(unsigned char *)(v3 + 70) == 2 && *(unsigned char *)(v3 + 71) == 2) {
    return 1;
  }
  else {
    return 2;
  }
}

void sub_18C86EE1C(uint64_t a1, uint64_t a2, unsigned __int8 *a3, UErrorCode *a4)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  int v8 = *a3;
  if (v8 == 5)
  {
    if (a3[1] < 3u) {
      goto LABEL_32;
    }
    unsigned int v22 = *((_DWORD *)a3 + 8);
    if ((v22 & 0xFF80) != 0) {
      goto LABEL_32;
    }
    int v12 = *((_DWORD *)a3 + 8) & 0x3F;
    unsigned int v10 = *((_DWORD *)a3 + 6);
    *(unsigned char *)(a1 + 252) = v10;
    unint64_t v11 = (unsigned __int8 *)(a1 + 252);
    int v9 = (v22 >> 6) & 1;
    if ((v22 & 0x40) != 0 && !(_BYTE)v10) {
      goto LABEL_32;
    }
  }
  else
  {
    if (v8 != 4) {
      goto LABEL_32;
    }
    int v9 = 0;
    unsigned int v10 = *((_DWORD *)a3 + 6);
    *(unsigned char *)(a1 + 252) = v10;
    unint64_t v11 = (unsigned __int8 *)(a1 + 252);
    int v12 = 8;
  }
  if (v10 >= 0x100) {
    *(void *)(a1 + 288) = &a3[v10 >> 8];
  }
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  int v83 = 0;
  if (v10 > 0xEu) {
    goto LABEL_32;
  }
  uint64_t v13 = (unsigned char *)(a1 + 48);
  if (((1 << v10) & 0x130F) != 0)
  {
    if (*(unsigned char *)(a2 + 8)) {
      return;
    }
    uint64_t v14 = *((unsigned int *)a3 + 1);
    *(unsigned char *)(a1 + 48) = v14;
    *(_DWORD *)(a1 + 52) = *((_DWORD *)a3 + 2);
    uint64_t v15 = &a3[4 * v12];
    *(void *)(a1 + 56) = v15;
    *(void *)(a1 + 80) = &v15[1024 * v14];
    *(void *)(a1 + 72) = &a3[*((unsigned int *)a3 + 3)];
    *(void *)(a1 + 88) = &a3[*((unsigned int *)a3 + 4)];
    *(void *)(a1 + 232) = &a3[*((unsigned int *)a3 + 5)];
    *(_DWORD *)(a1 + 248) = *((_DWORD *)a3 + 7);
    LOWORD(v81) = 20;
    udata_getInfo(*(void **)(a1 + 8), &v81);
    if (BYTE4(v82) > 6u || BYTE4(v82) == 6 && BYTE5(v82))
    {
      unsigned int v16 = *(unsigned char *)(*(void *)(a1 + 16) + 79) & 3;
      *(unsigned char *)(a1 + 253) = v16;
      if (a3[1] >= 3u && v16 < 2)
      {
        unsigned int v17 = a3[2];
        if (*v13 == 1)
        {
          if (v17 > 0xE)
          {
            uint64_t v18 = 0;
            uint64_t v19 = 0;
            *(unsigned char *)(a1 + 254) = 1;
            uint64_t v20 = *(void *)(a1 + 88);
            do
            {
              *(_WORD *)(a1 + 104 + 2 * v19) = *(_WORD *)(v20
                                                        + 2
                                                        * ((v18 & 0x3C)
                                                         + *(unsigned __int16 *)(v20 + 2 * (v19 >> 4))));
              ++v19;
              v18 += 4;
            }
            while (v19 != 64);
            __int16 v21 = 4095;
LABEL_42:
            *(_WORD *)(a1 + 256) = v21;
          }
        }
        else if (v17 > 0xD6)
        {
          *(unsigned char *)(a1 + 254) = 1;
          if (v9) {
            uint64_t v28 = 0;
          }
          else {
            uint64_t v28 = *(unsigned int *)(a1 + 248);
          }
          *(void *)(a1 + 96) = *(void *)(a1 + 232) + v28;
          __int16 v21 = (a3[2] << 8) | 0xFF;
          goto LABEL_42;
        }
      }
    }
    else
    {
      LOBYTE(v16) = 3;
      *(unsigned char *)(a1 + 253) = 3;
    }
    uint64_t v29 = 0;
    int32x4_t v30 = (int32x4_t)xmmword_18CA811A0;
    v31.i64[0] = -1;
    v31.i64[1] = -1;
    v32.i64[0] = 0x100000001;
    v32.i64[1] = 0x100000001;
    v33.i64[0] = 0x400000004;
    v33.i64[1] = 0x400000004;
    do
    {
      int8x16_t v31 = vandq_s8(vornq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(*(void *)(a1 + 56) + v29), (int32x4_t)(*(_OWORD *)&v30 | __PAIR128__(0x8000000080000000, 0x8000000080000000))), (int8x16_t)vshlq_u32(v32, vshrq_n_u32((uint32x4_t)v30, 2uLL))), v31);
      int32x4_t v30 = vaddq_s32(v30, v33);
      v29 += 16;
    }
    while (v29 != 512);
    int8x8_t v34 = vand_s8(*(int8x8_t *)v31.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
    *(_DWORD *)(a1 + 260) = v34.i32[0] & v34.i32[1];
    if (v9)
    {
      unsigned int v80 = v11;
      if (v16) {
        unsigned int v35 = 1088;
      }
      else {
        unsigned int v35 = 64;
      }
      int v36 = *((_DWORD *)a3 + 4);
      int v37 = *((_DWORD *)a3 + 5);
      uint64_t v38 = *((unsigned int *)a3 + 9);
      size_t v39 = 4 * v38 + 2 * v35 + *(_DWORD *)(a1 + 248);
      int v40 = (char *)uprv_malloc(v39);
      *(void *)(a1 + 264) = v40;
      if (v40)
      {
        int v41 = v40;
        bzero(v40, v39);
        int v42 = *(char **)(a1 + 88);
        memcpy(v41, v42, 2 * v35);
        uint64_t v43 = &v41[2 * v35];
        memcpy(&v43[4 * (v38 - (((v37 - v36) >> 2) - (v35 >> 1)))], &v42[2 * v35], 4 * (((v37 - v36) >> 2) - (v35 >> 1)));
        *(void *)(a1 + 88) = v41;
        *(void *)(a1 + 232) = &v43[4 * v38];
        unsigned int v44 = *(unsigned __int16 *)(a1 + 256);
        unint64_t v11 = v80;
        if (v44 >= 0x3F)
        {
          uint64_t v45 = 0;
          signed int v46 = 0;
          signed int v47 = (v44 + 1) >> 6;
          do
          {
            uint64_t v48 = *(unsigned __int16 *)&v41[2 * v45];
            if (v35 >> 1 == v48)
            {
              v46 += 16;
            }
            else
            {
              uint64_t v49 = 0;
              uint64_t v50 = *(void *)(a1 + 96) + 2 * v46;
              int v51 = &v41[4 * v48];
              do
              {
                if (*(_WORD *)(v50 + 2 * v49))
                {
                  unsigned int v52 = *(unsigned __int16 *)(v50 + 2 * v49) >> 4;
                  *(_DWORD *)int v51 = v52;
                  *(int32x2_t *)(v51 + 4) = vadd_s32(vdup_n_s32(v52), (int32x2_t)0x200000001);
                  *((_DWORD *)v51 + 3) = v52 + 3;
                }
                ++v49;
                v51 += 16;
              }
              while (v49 != 16);
              v46 += 16;
            }
            ++v45;
          }
          while (v46 < v47);
        }
        *(void *)&long long v53 = -1;
        *((void *)&v53 + 1) = -1;
        long long v88 = v53;
        long long v89 = v53;
        long long v86 = v53;
        long long v87 = v53;
        *(_OWORD *)&v84[32] = v53;
        long long v85 = v53;
        *(_OWORD *)uint64_t v84 = v53;
        *(_OWORD *)&v84[16] = v53;
        sub_18C870120(*(void *)(a1 + 56), (uint64_t)v84, 0);
        unsigned int v54 = *(unsigned __int8 *)(a1 + 48);
        if (*(unsigned char *)(a1 + 48))
        {
          unint64_t v55 = 0;
          do
          {
            if ((char)v84[v55] >= 64)
            {
              sub_18C87030C(a1 + 48, (uint64_t)v84, v55, 0, 0, a1 + 48);
              unsigned int v54 = *v13;
            }
            ++v55;
          }
          while (v55 < v54);
        }
      }
      else
      {
        *a4 = U_MEMORY_ALLOCATION_ERROR;
        unint64_t v11 = v80;
      }
    }
    goto LABEL_67;
  }
  if (v10 != 14) {
    goto LABEL_32;
  }
  memset(&v84[8], 0, 32);
  uint64_t v23 = *(void *)(a1 + 288);
  if (!v23) {
    goto LABEL_32;
  }
  if (*(_DWORD *)(a2 + 4) != 1)
  {
    int v27 = 14;
    goto LABEL_33;
  }
  uint64_t v24 = (const char *)&a3[4 * v12];
  if (!strcmp(v24, (const char *)(*(void *)(a1 + 16) + 4)))
  {
LABEL_32:
    int v27 = 13;
LABEL_33:
    *a4 = v27;
    return;
  }
  *(void *)uint64_t v84 = 0x200000028;
  v84[8] = *(unsigned char *)(a2 + 8);
  *(_WORD *)&v84[10] = *(_WORD *)(a2 + 10);
  *(_DWORD *)&v84[12] = *(_DWORD *)(a2 + 12);
  *(void *)&v84[16] = *(void *)(a2 + 16);
  *(void *)&v84[24] = v24;
  uint64_t v25 = ucnv_load((uint64_t)v84, a4);
  if (*(int *)a4 > 0) {
    return;
  }
  uint64_t v26 = (uint64_t)v25;
  if (*(unsigned char *)(*((void *)v25 + 2) + 69) != 2 || *((void *)v25 + 35))
  {
    ucnv_unload((uint64_t)v25);
    goto LABEL_32;
  }
  if (*(unsigned char *)(a2 + 8))
  {
    ucnv_unload((uint64_t)v25);
    return;
  }
  long long v58 = *((_OWORD *)v25 + 3);
  *(_OWORD *)(a1 + 64) = *((_OWORD *)v25 + 4);
  long long v59 = *((_OWORD *)v25 + 5);
  long long v60 = *((_OWORD *)v25 + 6);
  long long v61 = *((_OWORD *)v25 + 8);
  *(_OWORD *)(a1 + 112) = *((_OWORD *)v25 + 7);
  *(_OWORD *)(a1 + 128) = v61;
  *(_OWORD *)(a1 + 80) = v59;
  *(_OWORD *)(a1 + 96) = v60;
  long long v62 = *((_OWORD *)v25 + 9);
  long long v63 = *((_OWORD *)v25 + 10);
  long long v64 = *((_OWORD *)v25 + 12);
  *(_OWORD *)(a1 + 176) = *((_OWORD *)v25 + 11);
  *(_OWORD *)(a1 + 192) = v64;
  *(_OWORD *)(a1 + 144) = v62;
  *(_OWORD *)(a1 + 160) = v63;
  long long v65 = *((_OWORD *)v25 + 13);
  long long v66 = *((_OWORD *)v25 + 14);
  long long v67 = *((_OWORD *)v25 + 15);
  *(void *)(a1 + 256) = *((void *)v25 + 32);
  *(_OWORD *)(a1 + 224) = v66;
  *(_OWORD *)(a1 + 240) = v67;
  *(_OWORD *)(a1 + 208) = v65;
  *(_OWORD *)uint64_t v13 = v58;
  *(void *)(a1 + 280) = v25;
  *(void *)(a1 + 288) = v23;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  uint64_t v68 = *(void *)(a1 + 16);
  int v69 = *(unsigned __int8 *)(v68 + 69);
  if (v69 == 1 || v69 == 2 && *(char *)(v68 + 70) >= 2)
  {
    if (v25[252] == 12)
    {
      unsigned int v70 = *(_DWORD *)(*(void *)(a1 + 56) + 56);
      if ((v70 & 0x80F00000) != 0x80800000) {
        goto LABEL_67;
      }
      int v71 = HIBYTE(v70) & 0x7F;
      if (!v71) {
        goto LABEL_67;
      }
      char v72 = v11;
      *(unsigned char *)(a1 + 49) = v71;
    }
    else
    {
      uint64_t v73 = (unsigned char *)*((void *)v25 + 2);
      if (v73[69] != 2) {
        goto LABEL_67;
      }
      if (v73[70] != 1) {
        goto LABEL_67;
      }
      if (v73[71] != 2) {
        goto LABEL_67;
      }
      int v74 = (char)*v13;
      if (v74 < 0) {
        goto LABEL_67;
      }
      char v72 = v11;
      unsigned int v75 = (char *)uprv_malloc((*v13 + 1) << 10);
      if (!v75)
      {
        ucnv_unload(v26);
        int v27 = 7;
        goto LABEL_33;
      }
      int v76 = v75;
      memcpy(v75, *(const void **)(a1 + 56), (unint64_t)v74 << 10);
      uint64_t v77 = 0;
      int v78 = v74 << 24;
      do
      {
        int32x2_t v79 = vcltz_s32(*(int32x2_t *)&v76[v77]);
        if (v79.i8[0]) {
          *(_DWORD *)&v76[v77] = v78;
        }
        if (v79.i8[4]) {
          *(_DWORD *)&v76[v77 + 4] = v78;
        }
        v77 += 8;
      }
      while (v77 != 1024);
      memset_pattern16(&v76[1024 * (unint64_t)v74], &unk_18CA811B0, 0x400uLL);
      *(void *)(a1 + 56) = v76;
      *(unsigned char *)(a1 + 48) = v74 + 1;
      *(unsigned char *)(a1 + 50) = 1;
    }
    unint64_t v11 = v72;
    *char v72 = -37;
  }
LABEL_67:
  if (*(unsigned char *)(a1 + 254))
  {
    if (*v13 != 1)
    {
      int v56 = *v11;
      if (v56 == 1)
      {
        *(void *)(a1 + 32) = &unk_1EDA46E68;
        return;
      }
      goto LABEL_71;
    }
    *(void *)(a1 + 32) = &unk_1EDA46DD8;
  }
  int v56 = *v11;
LABEL_71:
  if (v56 == 219 || v56 == 12) {
    *(_DWORD *)(a1 + 260) = 0;
  }
}

void sub_18C86F54C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 64);
  if (v2) {
    uprv_free(v2);
  }
  if (*(unsigned char *)(a1 + 50)) {
    uprv_free(*(void **)(a1 + 56));
  }
  uint64_t v3 = *(void *)(a1 + 280);
  if (v3) {
    ucnv_unload(v3);
  }
  uint64_t v4 = *(void **)(a1 + 264);
  if (v4)
  {
    uprv_free(v4);
  }
}

void sub_18C86F5B8(uint64_t a1, uint64_t a2, int *a3)
{
  if (*(unsigned char *)(a2 + 8)) {
    return;
  }
  uint64_t v6 = *(void *)(a1 + 48);
  int v7 = *(unsigned __int8 *)(v6 + 252);
  int v8 = *(_DWORD *)(a2 + 12);
  if (v7 == 219)
  {
    v8 &= ~0x10u;
    *(_DWORD *)(a2 + 12) = v8;
    *(_DWORD *)(a1 + 56) = v8;
  }
  if ((v8 & 0x10) != 0)
  {
    umtx_lock(0);
    uint64_t v9 = *(void *)(v6 + 64);
    umtx_unlock(0);
    if (!v9)
    {
      uint64_t v14 = *(void *)(a1 + 48);
      int v15 = *(unsigned __int8 *)(v14 + 252);
      if (v15 != 12 && v15 != 0) {
        goto LABEL_44;
      }
      uint64_t v17 = *(void *)(v14 + 56);
      if (*(_DWORD *)(v17 + 148) != -2147483638 || *(_DWORD *)(v17 + 84) != -2147483515) {
        goto LABEL_44;
      }
      uint64_t v18 = *(unsigned __int16 **)(v14 + 88);
      uint64_t v19 = *(_WORD **)(v14 + 232);
      uint64_t v20 = *v18;
      if (*(unsigned char *)(v14 + 252))
      {
        if ((*(_DWORD *)&v18[2 * v20] & 0x4000000) == 0
          || v19[16 * (unsigned __int16)*(_DWORD *)&v18[2 * v20] + 10] != 37
          || (int v21 = *(_DWORD *)&v18[2 * v20 + 16], (v21 & 0x200000) == 0)
          || v19[16 * (unsigned __int16)v21 + 5] != 21)
        {
LABEL_44:
          if (*a3 > 0) {
            return;
          }
          unsigned int v31 = *(_DWORD *)(a2 + 12) & 0xFFFFFFEF;
          *(_DWORD *)(a2 + 12) = v31;
          *(_DWORD *)(a1 + 56) = v31;
          goto LABEL_7;
        }
      }
      else if (v19[v18[v20] + 10] != 3877 || v19[v18[v20 + 8] + 5] != 3861)
      {
        goto LABEL_44;
      }
      size_t v22 = *(unsigned int *)(v14 + 248);
      if (v22)
      {
        uint64_t v23 = uprv_malloc(v22 + (*(unsigned __int8 *)(v14 + 48) << 10) + 80);
        if (v23)
        {
          uint64_t v24 = *(unsigned __int8 *)(v14 + 48);
          size_t __n = v22;
          uint64_t v25 = v23;
          memcpy(v23, *(const void **)(v14 + 56), v24 << 10);
          v25[37] = -2147483515;
          v25[21] = -2147483638;
          uint64_t v26 = (char *)&v25[256 * v24];
          memcpy(v26, v19, __n);
          uint64_t v27 = *v18;
          if (*(unsigned char *)(v14 + 252))
          {
            uint64_t v28 = &v18[2 * v27];
            *(_WORD *)&v26[32 * (unsigned __int16)*(_DWORD *)v28 + 20] = 21;
            uint64_t v29 = (16 * (unsigned __int16)*((_DWORD *)v28 + 8)) | 5;
            __int16 v30 = 37;
          }
          else
          {
            int32x4_t v33 = &v18[v27];
            *(_WORD *)&v26[2 * *v33 + 20] = 3861;
            uint64_t v29 = v33[8] + 5;
            __int16 v30 = 3877;
          }
          *(_WORD *)&v26[2 * v29] = v30;
          int8x8_t v34 = strcpy(&v26[__n], (const char *)(*(void *)(v14 + 16) + 4));
          strcpy(&v26[__n + strlen(v34)], ",swaplfnl");
          umtx_lock(0);
          if (*(void *)(v14 + 64))
          {
            umtx_unlock(0);
            uprv_free(v25);
          }
          else
          {
            *(void *)(v14 + 64) = v25;
            *(void *)(v14 + 240) = v26;
            *(void *)(v14 + 272) = &v26[__n];
            umtx_unlock(0);
          }
          goto LABEL_7;
        }
        int v32 = 7;
      }
      else
      {
        int v32 = 3;
      }
      *a3 = v32;
      return;
    }
  }
LABEL_7:
  unsigned int v10 = *(char **)(a2 + 24);
  if (strstr(v10, "18030"))
  {
    if (!strstr(v10, "gb18030") && !strstr(v10, "GB18030")) {
      goto LABEL_15;
    }
    int v11 = 0x8000;
  }
  else if (strstr(v10, "KEIS") || strstr(v10, "keis"))
  {
    int v11 = 4096;
  }
  else if (strstr(v10, "JEF") || strstr(v10, "jef"))
  {
    int v11 = 0x2000;
  }
  else
  {
    if (!strstr(v10, "JIPS") && !strstr(v10, "jips")) {
      goto LABEL_15;
    }
    int v11 = 0x4000;
  }
  *(_DWORD *)(a1 + 56) |= v11;
LABEL_15:
  if (v7 == 12) {
    *(unsigned char *)(a1 + 88) = 3;
  }
  uint64_t v12 = *(void *)(v6 + 288);
  if (v12)
  {
    char v13 = *(unsigned char *)(v12 + 68);
    if (v7 == 12) {
      ++v13;
    }
    if (v13 > *(char *)(a1 + 88)) {
      *(unsigned char *)(a1 + 88) = v13;
    }
  }
}

uint64_t sub_18C86F97C(void *a1, int *a2)
{
  uint64_t v2 = a1[1];
  if (*(char *)(v2 + 282) > 0) {
    return 4294967287;
  }
  uint64_t v3 = *(void *)(v2 + 48);
  if ((*(unsigned char *)(v3 + 253) & 2) != 0) {
    return 4294967287;
  }
  uint64_t v6 = (char *)a1[2];
  unint64_t v7 = a1[3];
  if (*(unsigned char *)(v3 + 48) == 1)
  {
    uint64_t v8 = 64;
    if ((*(unsigned char *)(v2 + 56) & 0x10) == 0) {
      uint64_t v8 = 56;
    }
    uint64_t v9 = *(void *)(v3 + v8);
    while (1)
    {
      if ((unint64_t)v6 >= v7) {
        goto LABEL_36;
      }
      unsigned int v10 = *v6++;
      int v11 = *(_DWORD *)(v9 + 4 * v10);
      a1[2] = v6;
      if (v11 < -2146435072) {
        return (unsigned __int16)v11;
      }
      if ((v11 & 0xD00000) == 0x100000) {
        return (v11 & 0xFFFFFu) + 0x10000;
      }
      int v12 = (v11 >> 20) & 0xF;
      if (v12 == 7) {
        goto LABEL_36;
      }
      if (v12 == 6) {
        break;
      }
      if (v12 == 2) {
        return (unsigned __int16)v11;
      }
    }
    if (*a2 > 0)
    {
LABEL_36:
      *a2 = 8;
      return 0xFFFFLL;
    }
    a1[2] = v6 - 1;
    return 4294967287;
  }
  uint64_t v14 = 64;
  if ((*(unsigned char *)(v2 + 56) & 0x10) == 0) {
    uint64_t v14 = 56;
  }
  uint64_t v15 = *(void *)(v3 + v14);
  uint64_t v16 = *(void *)(v3 + 72);
  int v17 = *(_DWORD *)(v2 + 72);
  unint64_t v18 = *(unsigned __int8 *)(v2 + 76);
  if (!*(unsigned char *)(v2 + 76)) {
    unint64_t v18 = *(unsigned __int8 *)(v3 + 49);
  }
  uint64_t result = 0xFFFFFFFFLL;
  while (2)
  {
    uint64_t v19 = v6;
    if ((unint64_t)v6 >= v7)
    {
      uint64_t v21 = 0;
      goto LABEL_51;
    }
    uint64_t v20 = 0;
    uint64_t v21 = v7 - (void)v6;
    unint64_t v22 = v18;
    while (1)
    {
      uint64_t v23 = &v19[v20 + 1];
      unint64_t v24 = *(unsigned int *)(v15 + ((unint64_t)v22 << 10) + 4 * v19[v20]);
      if ((v24 & 0x80000000) != 0) {
        break;
      }
      unint64_t v22 = v24 >> 24;
      v17 += v24 & 0xFFFFFF;
      if ((unint64_t)v23 < v7)
      {
        unsigned int v25 = *(_DWORD *)(v15 + (v22 << 10) + 4 * *v23);
        if ((v25 & 0x80F00000) == 0x80400000)
        {
          uint64_t result = *(unsigned __int16 *)(v16 + 2 * (v17 + (unsigned __int16)v25));
          if (result <= 0xFFFD)
          {
            uint64_t v27 = (uint64_t)&v19[v20 + 2];
            LODWORD(v18) = HIBYTE(v25) & 0x7F;
            goto LABEL_75;
          }
        }
      }
      if (v21 == ++v20) {
        goto LABEL_50;
      }
    }
    *(_DWORD *)(v2 + 76) = v22;
    unint64_t v18 = BYTE3(v24) & 0x7F;
    unsigned int v26 = (v24 >> 20) & 0xF;
    switch(v26)
    {
      case 5u:
        unsigned int v28 = v17 + (unsigned __int16)v24;
        uint64_t result = *(unsigned __int16 *)(v16 + 2 * v28);
        uint64_t v27 = (uint64_t)&v19[v20 + 1];
        if (result >> 11 < 0x1B) {
          goto LABEL_75;
        }
        unsigned int v29 = v28 + 1;
        if (result >> 13 <= 6)
        {
          uint64_t result = ((result & 0x3FF) << 10) + *(unsigned __int16 *)(v16 + 2 * v29) + 9216;
          goto LABEL_75;
        }
        if ((result & 0xFFFE) == 0xE000)
        {
          uint64_t result = *(unsigned __int16 *)(v16 + 2 * v29);
          goto LABEL_75;
        }
        if (result != 0xFFFF)
        {
LABEL_83:
          if (*a2 > 0)
          {
            uint64_t v21 = v20 + 1;
            goto LABEL_51;
          }
          *(_DWORD *)(v2 + 72) = 0;
          *(_DWORD *)(v2 + 76) = BYTE3(v24) & 0x7F;
          a1[2] = v19;
          return 4294967287;
        }
LABEL_82:
        *a2 = 12;
        uint64_t v27 = (uint64_t)&v19[v20 + 1];
LABEL_66:
        uint64_t result = 0xFFFFLL;
        goto LABEL_75;
      case 4u:
        unsigned int v30 = v17 + (unsigned __int16)v24;
        uint64_t result = *(unsigned __int16 *)(v16 + 2 * v30);
        uint64_t v21 = v20 + 1;
        if (result < 0xFFFE)
        {
          uint64_t v27 = (uint64_t)&v19[v21];
          goto LABEL_75;
        }
        if (result == 65534)
        {
          uint64_t v42 = sub_18C86D300(v3 + 48, v30);
          unint64_t v18 = BYTE3(v24) & 0x7F;
          uint64_t v43 = v42;
          uint64_t result = 65534;
          if (v43 != 65534)
          {
            uint64_t result = v43;
            goto LABEL_51;
          }
          goto LABEL_83;
        }
        goto LABEL_82;
      case 0u:
LABEL_32:
        uint64_t result = (unsigned __int16)v24;
LABEL_46:
        uint64_t v27 = (uint64_t)&v19[v20 + 1];
        goto LABEL_75;
    }
    if ((v24 & 0xD00000) == 0x100000)
    {
      uint64_t result = (v24 & 0xFFFFF) + 0x10000;
      goto LABEL_46;
    }
    int v17 = 0;
    uint64_t v6 = &v19[v20 + 1];
    switch(v26)
    {
      case 2u:
        goto LABEL_32;
      case 6u:
        goto LABEL_83;
      case 7u:
        unint64_t v22 = BYTE3(v24) & 0x7F;
        break;
      case 8u:
        if (!*(unsigned char *)(v3 + 49)) {
          goto LABEL_83;
        }
        break;
      default:
        continue;
    }
    break;
  }
  *a2 = 12;
  uint64_t v21 = v20 + 1;
LABEL_50:
  unint64_t v18 = v22;
LABEL_51:
  uint64_t v27 = (uint64_t)&v19[v21];
  if ((result & 0x80000000) != 0)
  {
    if (*a2 <= 0 && v27 == v7 && v21 >= 1)
    {
      int8x8_t v34 = (unsigned char *)(v2 + 65);
      *(unsigned char *)(v2 + 64) = v21;
      do
      {
        char v35 = *v19++;
        *v34++ = v35;
      }
      while ((unint64_t)v19 < v7);
      *a2 = 11;
      uint64_t result = 0xFFFFLL;
      uint64_t v27 = v7;
      goto LABEL_75;
    }
    if (*a2 < 1)
    {
      *a2 = 8;
    }
    else
    {
      BOOL v33 = *(unsigned char *)(v3 + 49) != 0;
      *(unsigned char *)(v2 + 65) = *v19;
      if (v21 != 1)
      {
        int v36 = v19 + 1;
        if (v21 < 2)
        {
          char v38 = 1;
        }
        else
        {
          int v37 = (unsigned char *)(v2 + 66);
          char v38 = 1;
          while (1)
          {
            unint64_t v39 = v27;
            char v40 = *v36;
            unint64_t v41 = v18;
            if (sub_18C86D36C(v15, v18, v33, *v36)) {
              break;
            }
            ++v36;
            *v37++ = v40;
            ++v38;
            uint64_t v27 = v39;
            unint64_t v18 = v41;
            if ((unint64_t)v36 >= v39) {
              goto LABEL_74;
            }
          }
          LOBYTE(v18) = v41;
        }
LABEL_74:
        *(unsigned char *)(v2 + 64) = v38;
        uint64_t result = 0xFFFFLL;
        uint64_t v27 = (uint64_t)v36;
        goto LABEL_75;
      }
      *(unsigned char *)(v2 + 64) = 1;
    }
    goto LABEL_66;
  }
LABEL_75:
  *(_DWORD *)(v2 + 72) = 0;
  *(_DWORD *)(v2 + 76) = v18;
  a1[2] = v27;
  return result;
}

uint64_t sub_18C86FE24(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = *(void *)(*(void *)(result + 48) + 56)
     + ((unint64_t)*(unsigned __int8 *)(*(void *)(result + 48) + 49) << 10);
  do
  {
    *(unsigned char *)(a2 + v2) = *(_DWORD *)(v3 + 4 * v2) >= 0;
    ++v2;
  }
  while (v2 != 256);
  return result;
}

uint64_t sub_18C86FE58(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if ((*(unsigned char *)(a1 + 56) & 0x10) == 0) {
    return *(void *)(v1 + 16) + 4;
  }
  uint64_t result = *(void *)(v1 + 272);
  if (!result) {
    return *(void *)(v1 + 16) + 4;
  }
  return result;
}

void *sub_18C86FE7C(void *result, int a2, int *a3)
{
  uint64_t v5 = result[1];
  uint64_t v6 = (char *)(v5 + 94);
  uint64_t v7 = *(void *)(v5 + 48);
  if (*(unsigned char *)(v5 + 94))
  {
    if (*(void *)(v7 + 288))
    {
      if (*(unsigned char *)(v5 + 95))
      {
LABEL_4:
        int v8 = 1;
        goto LABEL_7;
      }
    }
    else if (*(unsigned __int16 *)(v5 + 140) < 0x100u)
    {
      goto LABEL_4;
    }
  }
  uint64_t v6 = *(char **)(v5 + 40);
  int v8 = *(char *)(v5 + 89);
LABEL_7:
  int v12 = 0;
  *(unsigned char *)(v5 + 95) = 0;
  if (*(unsigned char *)(v7 + 252) == 12)
  {
    if (v8 == 2)
    {
      int v11 = (char *)&v12;
      if (*(_DWORD *)(v5 + 80) <= 1u)
      {
        *(_DWORD *)(v5 + 80) = 2;
        int v11 = (char *)&v12 + 1;
        LOBYTE(v12) = 14;
      }
      *int v11 = *v6;
      int v10 = v11 + 2;
      v11[1] = v6[1];
    }
    else
    {
      if (v8 != 1)
      {
        *a3 = 1;
        return result;
      }
      uint64_t v9 = (char *)&v12;
      if (*(_DWORD *)(v5 + 80) == 2)
      {
        *(_DWORD *)(v5 + 80) = 1;
        uint64_t v9 = (char *)&v12 + 1;
        LOBYTE(v12) = 15;
      }
      *uint64_t v9 = *v6;
      int v10 = v9 + 1;
    }
    uint64_t v6 = (char *)&v12;
    int v8 = v10 - (&vars0 - 4);
  }
  return ucnv_cbFromUWriteBytes(result, v6, v8, a2, a3);
}

uint64_t sub_18C86FF88(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4)
{
  if ((*(unsigned char *)(a1 + 57) & 0x80) != 0)
  {
    ((void (*)(uint64_t, void, uint64_t))a2[2])(*a2, 0, 55295);
    uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[2];
    uint64_t v10 = *a2;
    return v9(v10, 57344, 1114111);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 48);
    BOOL v7 = *(unsigned __int8 *)(v6 + 252) == 219;
    return sub_18C86BE98(v6, a2, a3, v7, a4);
  }
}

uint64_t sub_18C870018(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 184);
  int v6 = a2 & 0xFF7FFF;
  if (HIBYTE(a2) <= 0x8Eu) {
    int v6 = a2 & 0x7FFFFF;
  }
  if (HIBYTE(a2)) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = a2;
  }
  int v8 = a2 & 0xFF7F;
  if (HIWORD(a2) <= 0x8Eu) {
    int v8 = a2 & 0x7FFF;
  }
  int v9 = *(unsigned __int8 *)(a1 + 204);
  if (a2 < 0x10000) {
    int v8 = a2;
  }
  if (v9 != 8) {
    int v8 = a2;
  }
  if (v9 != 9) {
    unsigned int v7 = v8;
  }
  do
  {
    unint64_t v10 = *(unsigned int *)(a3 + 4 * v3);
    if ((v10 & 0x80000000) != 0) {
      goto LABEL_22;
    }
    uint64_t v11 = v4 + 4 * *(unsigned __int16 *)(v4 + ((v10 >> 9) & 0x7FFFFE));
    uint64_t v12 = (v10 >> 4) & 0x3F;
    int v13 = v7 + v3;
    int v14 = *(_DWORD *)(a3 + 4 * v3) & 0xF;
    unsigned int v15 = v14 | (16 * (unsigned __int16)*(_DWORD *)(v11 + 4 * v12));
    int v16 = *(unsigned __int8 *)(a1 + 204);
    if (v16 != 9)
    {
      if (v16 == 3)
      {
        *(_DWORD *)(v5 + 4 * v15) = v13;
        goto LABEL_21;
      }
      if (v16 != 2)
      {
        *(_WORD *)(v5 + 2 * v15) = v13;
        goto LABEL_21;
      }
    }
    int v17 = (unsigned char *)(v5 + 3 * v15);
    *int v17 = BYTE2(v13);
    v17[1] = BYTE1(v13);
    v17[2] = v13;
LABEL_21:
    *(_DWORD *)(v11 + 4 * v12) |= 1 << (v14 | 0x10);
LABEL_22:
    ++v3;
  }
  while (v3 != 32);
  return 1;
}

uint64_t sub_18C870120(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = result;
  uint64_t v5 = 0;
  int v6 = 0;
  uint64_t v21 = a3;
  unint64_t v7 = result + ((unint64_t)a3 << 10);
  unint64_t v8 = (unint64_t)a3 << 10;
  *(unsigned char *)(a2 + a3) = 0;
  while (1)
  {
    unint64_t v9 = *(unsigned int *)(v4 + v8);
    uint64_t v10 = (v9 >> 24) & 0x7F;
    if (*(unsigned __int8 *)(a2 + v10) == 255) {
      break;
    }
    if ((v9 & 0x80000000) != 0) {
      goto LABEL_7;
    }
LABEL_4:
    if ((*(char *)(a2 + v10) & 0x80000000) == 0) {
      goto LABEL_10;
    }
LABEL_8:
    if (v5 == -255)
    {
      *(unsigned char *)(a2 + v21) = -64;
      return result;
    }
    ++v6;
    v8 += 4;
    --v5;
  }
  uint64_t result = sub_18C870120(v4, a2, (v9 >> 24) & 0x7F);
  if ((v9 & 0x80000000) == 0) {
    goto LABEL_4;
  }
LABEL_7:
  if ((v9 & 0xE00000) >= 0x600000) {
    goto LABEL_8;
  }
LABEL_10:
  uint64_t v11 = -v5;
  uint64_t v12 = v21;
  char v13 = *(unsigned char *)(a2 + v21) | ((unint64_t)-v5 >> 2) & 0xF8;
  *(unsigned char *)(a2 + v21) = v13;
  if (-(int)v5 > 0xFE)
  {
    LODWORD(v14) = 255;
    goto LABEL_24;
  }
  uint64_t v14 = 255;
  while (2)
  {
    unint64_t v15 = *(unsigned int *)(v7 + 4 * v14);
    uint64_t v16 = (v15 >> 24) & 0x7F;
    if (*(unsigned __int8 *)(a2 + v16) == 255)
    {
      uint64_t result = sub_18C870120(v4, a2, (v15 >> 24) & 0x7F);
      if ((v15 & 0x80000000) == 0) {
        goto LABEL_14;
      }
    }
    else if ((v15 & 0x80000000) == 0)
    {
LABEL_14:
      if ((*(char *)(a2 + v16) & 0x80000000) == 0) {
        break;
      }
      goto LABEL_18;
    }
    if ((v15 & 0xE00000) >= 0x600000)
    {
LABEL_18:
      if (-v5 >= (unint64_t)--v14)
      {
        uint64_t v11 = -v5;
        uint64_t v12 = v21;
        uint64_t v14 = -v5;
        goto LABEL_23;
      }
      continue;
    }
    break;
  }
  uint64_t v11 = -v5;
  uint64_t v12 = v21;
LABEL_23:
  char v13 = *(unsigned char *)(a2 + v12);
LABEL_24:
  *(unsigned char *)(a2 + v12) = v13 | (v14 >> 5);
  if ((int)v14 >= (int)v11)
  {
    if ((int)v14 <= v6) {
      uint64_t v17 = v6;
    }
    else {
      uint64_t v17 = v14;
    }
    for (uint64_t i = v17 + v5 + 1; i; --i)
    {
      unint64_t v19 = *(unsigned int *)(v4 + v8);
      uint64_t v20 = (v19 >> 24) & 0x7F;
      if (*(unsigned __int8 *)(a2 + v20) == 255)
      {
        uint64_t result = sub_18C870120(v4, a2, (v19 >> 24) & 0x7F);
        if ((v19 & 0x80000000) != 0)
        {
LABEL_33:
          *(unsigned char *)(a2 + v20) |= 0x40u;
          if ((v19 & 0xC00000) == 0) {
            *(unsigned char *)(a2 + v12) |= 0x40u;
          }
        }
      }
      else if ((v19 & 0x80000000) != 0)
      {
        goto LABEL_33;
      }
      v8 += 4;
    }
  }
  return result;
}

uint64_t sub_18C87030C(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  memset(v26, 0, sizeof(v26));
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v24 = *(void *)(a1 + 24);
  int v10 = *(char *)(a2 + a3);
  unsigned int v11 = (4 * v10) & 0xE0;
  if (v11)
  {
LABEL_4:
    unsigned int v12 = 32 * (v10 & 7) + 32;
    if (v11 >= v12) {
      return 1;
    }
    goto LABEL_7;
  }
  if (v10 > 63)
  {
    LODWORD(v26[0]) = -1;
    unsigned int v11 = 1;
    goto LABEL_4;
  }
  unsigned int v11 = 0;
  unsigned int v12 = 32 * (v10 & 7) + 32;
LABEL_7:
  uint64_t v13 = v9 + ((uint64_t)a3 << 10);
  int v14 = a5 << 8;
  uint64_t v15 = v11;
  int v16 = -1;
  unint64_t v17 = v12;
  do
  {
    unint64_t v18 = *(unsigned int *)(v13 + 4 * v15);
    if ((v18 & 0x80000000) != 0)
    {
      unsigned int v20 = -1;
      switch((v18 >> 20) & 0xF)
      {
        case 0u:
          unsigned int v20 = (unsigned __int16)*(_DWORD *)(v13 + 4 * v15);
          break;
        case 1u:
          unsigned int v20 = (v18 & 0xFFFFF) + 0x10000;
          break;
        case 4u:
          unsigned int v20 = *(unsigned __int16 *)(v24 + 2 * (a4 + (unsigned __int16)v18));
          if (v20 >= 0xFFFE) {
            unsigned int v20 = -1;
          }
          break;
        case 5u:
          int v21 = a4 + (unsigned __int16)v18;
          unsigned int v20 = *(unsigned __int16 *)(v24 + 2 * v21);
          if (v20 >> 11 >= 0x1B)
          {
            uint64_t v22 = v21 + 1;
            if (v20 >> 10 > 0x36)
            {
              if (v20 == 57344) {
                unsigned int v20 = *(unsigned __int16 *)(v24 + 2 * (int)v22);
              }
              else {
                unsigned int v20 = -1;
              }
            }
            else
            {
              unsigned int v20 = ((v20 & 0x3FF) << 10) + 9216 + *(unsigned __int16 *)(v24 + 2 * v22);
            }
          }
          break;
        default:
          break;
      }
      *((_DWORD *)v26 + (v15 & 0x1F)) = v20;
      v16 &= v20;
    }
    else
    {
      if ((*(char *)(a2 + (v18 >> 24)) & 0x80000000) == 0)
      {
        uint64_t result = sub_18C87030C(a1, a2);
        if (!result) {
          return result;
        }
      }
      *((_DWORD *)v26 + (v15 & 0x1F)) = -1;
    }
    unint64_t v23 = v15 + 1;
    if (((v15 + 1) & 0x1F) == 0 && (v16 & 0x80000000) == 0)
    {
      uint64_t result = sub_18C870018(a6, (v15 - 31) | v14, (uint64_t)v26);
      if (!result) {
        return result;
      }
      int v16 = -1;
    }
    ++v15;
  }
  while (v23 < v17);
  return 1;
}

uint64_t sub_18C870584(uint64_t result, void *a2, int *a3)
{
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v6 = a2[1];
  unint64_t v5 = a2[2];
  unint64_t v7 = a2[3];
  unint64_t v8 = *(unsigned char **)(result + 32);
  long long v66 = v8;
  uint64_t v64 = result;
  uint64_t v9 = *(void *)(v4 + 48);
  if ((*(unsigned char *)(v4 + 56) & 0x10) != 0) {
    uint64_t v10 = 240;
  }
  else {
    uint64_t v10 = 232;
  }
  if (*(unsigned char *)(v4 + 63)) {
    uint64_t v11 = 2048;
  }
  else {
    uint64_t v11 = 3072;
  }
  int v12 = *(char *)(v6 + 64);
  if (v12 < 1)
  {
    LOBYTE(v12) = 0;
    LOBYTE(v14) = 0;
    LODWORD(v13) = 0;
  }
  else
  {
    LODWORD(v13) = *(_DWORD *)(v6 + 72);
    int v14 = *(_DWORD *)(v6 + 76);
  }
  int v15 = *(_DWORD *)(result + 40) - v8;
  uint64_t v16 = *(void *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + v10);
  int v18 = v7 - v5 - (char)v14 + v12;
  if (v18 >= 1 && *(char *)(v7 - 1) < 0)
  {
    unsigned int v19 = *(unsigned __int8 *)(v7 - 1);
    if (v18 < 2 || v19 > 0xBF)
    {
      if ((v19 + 62) < 0x2Eu) {
        --v7;
      }
    }
    else
    {
      char v20 = *(unsigned char *)(v7 - 2);
      if (v20 & 0xF0) == 0xE0 && ((a00000000000000[v20 & 0xF] >> (*(unsigned char *)(v7 - 1) >> 5))) {
        v7 -= 2;
      }
    }
  }
  int v21 = (unsigned __int16 *)(v9 + 104);
  uint64_t v22 = *(unsigned int *)(v9 + 260);
  int v23 = *(unsigned __int8 *)(v9 + 253);
  if (v13 && v15 > 0)
  {
    *(_DWORD *)(v6 + 72) = 0;
    *(unsigned char *)(v6 + 64) = 0;
    char v24 = v12;
    goto LABEL_66;
  }
  unsigned int v25 = (unsigned __int8 *)v5;
  while (1)
  {
    if ((unint64_t)v25 >= v7)
    {
      unint64_t v5 = (unint64_t)v25;
      goto LABEL_39;
    }
    while (1)
    {
      int v26 = v15 - 1;
      if (v15 < 1)
      {
        *a3 = 15;
        goto LABEL_59;
      }
      unint64_t v5 = (unint64_t)(v25 + 1);
      LOBYTE(v27) = *v25;
      uint64_t v13 = *v25;
      if ((*v25 & 0x80) == 0)
      {
        if (((v22 >> (*v25 >> 2)) & 1) == 0)
        {
          unsigned int v27 = *(unsigned __int16 *)(v17 + 2 * (*v21 + v13));
LABEL_63:
          unsigned int v25 = (unsigned __int8 *)v5;
          goto LABEL_89;
        }
        goto LABEL_38;
      }
      unsigned int v28 = *v25;
      if (v13 <= 0xDF)
      {
        if (v28 < 0xC2)
        {
          LOBYTE(v12) = 0;
          LOBYTE(v14) = 0;
LABEL_65:
          char v24 = 1;
          goto LABEL_66;
        }
        unsigned int v29 = *(unsigned __int8 *)v5 ^ 0x80;
        if (v29 > 0x3F) {
          goto LABEL_60;
        }
        LODWORD(v30) = v13 & 0x1F;
        unint64_t v5 = (unint64_t)(v25 + 2);
        int v31 = v21[v13 & 0x1F];
        goto LABEL_37;
      }
      if (v28 != 224) {
        break;
      }
      uint64_t v30 = *(unsigned __int8 *)v5 ^ 0x80;
      if ((v30 & 0xE0) != 0x20 || (unsigned int v29 = v25[2] ^ 0x80, v29 > 0x3F))
      {
LABEL_60:
        BOOL v43 = *v25 > 0xDFu;
        char v44 = 2;
        goto LABEL_61;
      }
      unint64_t v5 = (unint64_t)(v25 + 3);
      int v31 = v21[v30];
LABEL_37:
      unsigned int v27 = *(unsigned __int16 *)(v17 + 2 * (v31 + v29));
      if (v27 < v11)
      {
        uint64_t v13 = v29 | (v30 << 6);
        goto LABEL_63;
      }
LABEL_38:
      int v32 = v66++;
      *int v32 = v27;
      int v15 = v26;
      unsigned int v25 = (unsigned __int8 *)v5;
      if (v5 >= v7) {
        goto LABEL_39;
      }
    }
    char v24 = 1;
    if ((v27 + 62) < 0x33u)
    {
      if (*v25 <= 0xEFu) {
        char v44 = 2;
      }
      else {
        char v44 = 3;
      }
      BOOL v43 = 1;
LABEL_61:
      LOBYTE(v12) = 0;
      LOBYTE(v14) = v44 + v43;
      goto LABEL_65;
    }
    LOBYTE(v12) = 0;
    LOBYTE(v14) = 0;
LABEL_66:
    if (v24 < (char)v14) {
      break;
    }
LABEL_83:
    if (v24 != v14)
    {
      uint64_t v59 = (char)v12 - (uint64_t)v24;
      if ((char)v12 < v24)
      {
        long long v60 = (unsigned char *)((char)v12 + v6 + 65);
        do
          *v60++ = *(unsigned char *)(v5 + v59);
        while (!__CFADD__(v59++, 1));
      }
      *(unsigned char *)(v6 + 64) = v24;
      a2[2] = v5 + v59;
      *(void *)(v64 + 32) = v66;
      *a3 = 12;
      return result;
    }
    unsigned int v25 = (unsigned __int8 *)v5;
LABEL_85:
    uint64_t v13 = (v13 - dword_18CA811D0[(char)v14]);
    if (char)v14 < 4 || (v23) {
      unsigned int v27 = *(unsigned __int16 *)(v17
    }
                                + 2
                                * ((v13 & 0xF)
                                 + *(unsigned __int16 *)(v16
                                                       + 2
                                                       * (((v13 >> 4) & 0x3F)
                                                        + *(unsigned __int16 *)(v16 + 2 * ((int)v13 >> 10))))));
    else {
      unsigned int v27 = 0;
    }
LABEL_89:
    if (v11 <= v27)
    {
      long long v58 = v66++;
      *long long v58 = v27;
      --v15;
    }
    else
    {
      int v62 = v23;
      uint64_t v52 = v22;
      uint64_t v53 = v11;
      unsigned int v54 = v21;
      uint64_t v55 = v17;
      uint64_t v63 = v6;
      int v56 = a2;
      long long v65 = &unk_18CA811E4;
      int v57 = a3;
      uint64_t result = sub_18C86EAF0(v4, *(void *)(v4 + 48), v13, (uint64_t *)&v65, (uint64_t)&unk_18CA811E4, &v66, (unint64_t)&v66[v15], 0, -1, *(unsigned char *)(v64 + 2), a3);
      a3 = v57;
      if (*v57 >= 1)
      {
        *(_DWORD *)(v4 + 84) = result;
        unint64_t v5 = (unint64_t)v25;
        a2 = v56;
LABEL_111:
        uint64_t v6 = v63;
LABEL_39:
        if (*a3 <= 0 && (*(_DWORD *)(v4 + 208) & 0x80000000) != 0 && (unint64_t v33 = a2[3], v5 < v33))
        {
          int v34 = *(char *)v5;
          *(unsigned char *)(v6 + 65) = *(unsigned char *)v5;
          int v35 = v34;
          if (v34 <= 0xEFu) {
            int v36 = 2;
          }
          else {
            int v36 = 3;
          }
          if (v34 > 0xDFu) {
            ++v36;
          }
          if ((v34 + 62) <= 0x32u) {
            int v37 = v36;
          }
          else {
            int v37 = 0;
          }
          if (v34 < 0) {
            int v38 = v37;
          }
          else {
            int v38 = 1;
          }
          unsigned int v25 = (unsigned __int8 *)(v5 + 1);
          if (v5 + 1 >= v33)
          {
            char v40 = 1;
          }
          else
          {
            unint64_t v39 = ~v5 + v33;
            char v40 = 1;
            do
            {
              int v41 = *v25++;
              char v42 = v40++;
              *(unsigned char *)(v6 + v42 + 65) = v41;
              int v35 = v41 + (v35 << 6);
              --v39;
            }
            while (v39);
            unsigned int v25 = (unsigned __int8 *)v33;
          }
          *(unsigned char *)(v6 + 64) = v40;
          *(_DWORD *)(v6 + 72) = v35;
          *(_DWORD *)(v6 + 76) = v38;
        }
        else
        {
          unsigned int v25 = (unsigned __int8 *)v5;
        }
LABEL_59:
        a2[2] = v25;
        goto LABEL_96;
      }
      a2 = v56;
      if ((*(_DWORD *)(v4 + 208) & 0x80000000) == 0)
      {
        int *v57 = -127;
        unint64_t v5 = (unint64_t)v25;
        goto LABEL_111;
      }
      uint64_t v6 = v63;
      int v15 = *(_DWORD *)(v64 + 40) - v66;
      uint64_t v17 = v55;
      int v21 = v54;
      uint64_t v11 = v53;
      uint64_t v22 = v52;
      int v23 = v62;
    }
  }
  uint64_t result = 1;
  LOBYTE(v45) = v24;
  unsigned int v25 = (unsigned __int8 *)v5;
  while ((unint64_t)v25 < a2[3])
  {
    unint64_t v46 = *v25;
    if ((char)v14 < 3 || v45 >= 2u)
    {
      if ((char)v46 >= -64) {
        goto LABEL_82;
      }
    }
    else
    {
      if (v14 == 3)
      {
        int v47 = a00000000000000[v13 & 0xF];
        unsigned int v48 = v46 >> 5;
      }
      else
      {
        int v47 = byte_18CA811E6[v46 >> 4];
        LOBYTE(v48) = v13 & 7;
      }
      if ((v47 & (1 << v48)) == 0)
      {
LABEL_82:
        char v24 = v45;
        unint64_t v5 = (unint64_t)v25;
        goto LABEL_83;
      }
    }
    int v45 = (char)(v45 + 1);
    ++v25;
    LODWORD(v13) = v46 + (v13 << 6);
    if (v45 >= (char)v14) {
      goto LABEL_85;
    }
  }
  unint64_t v49 = (char)v12;
  if ((char)v12 >= (char)v45)
  {
    int v51 = &v25[(char)v12 - (uint64_t)(char)v45];
  }
  else
  {
    do
    {
      unint64_t v50 = v49 + 1;
      *(unsigned char *)(v6 + 65 + v49) = *(unsigned char *)(v5 - v24 + v49);
      unint64_t v49 = v50;
    }
    while (v50 < (char)v45);
    int v51 = (unsigned __int8 *)(v5 - v24 + v50);
  }
  *(unsigned char *)(v6 + 64) = v45;
  *(_DWORD *)(v6 + 72) = v13;
  *(_DWORD *)(v6 + 76) = (char)v14;
  a2[2] = v51;
LABEL_96:
  *(void *)(v64 + 32) = v66;
  return result;
}

uint64_t sub_18C870BAC(uint64_t result, void *a2, int *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 8);
  uint64_t v8 = a2[1];
  unint64_t v7 = (unsigned char *)a2[2];
  uint64_t v9 = (unsigned char *)a2[3];
  uint64_t v10 = *(unsigned char **)(result + 32);
  uint64_t v64 = v10;
  uint64_t v11 = *(void *)(v6 + 48);
  if ((*(unsigned char *)(v6 + 56) & 0x10) != 0) {
    uint64_t v12 = 240;
  }
  else {
    uint64_t v12 = 232;
  }
  int v13 = *(char *)(v8 + 64);
  if (v13 < 1)
  {
    LOBYTE(v13) = 0;
    LOBYTE(v15) = 0;
    LODWORD(v14) = 0;
  }
  else
  {
    LODWORD(v14) = *(_DWORD *)(v8 + 72);
    int v15 = *(_DWORD *)(v8 + 76);
  }
  int v16 = *(_DWORD *)(result + 40) - v10;
  long long v61 = *(unsigned __int16 **)(v11 + 96);
  uint64_t v62 = *(void *)(v11 + 88);
  uint64_t v17 = *(void *)(v11 + v12);
  int v18 = v9 - v7 - (char)v15 + v13;
  if (v18 >= 1 && (char)*(v9 - 1) < 0)
  {
    unsigned int v19 = *(v9 - 1);
    if (v18 < 2 || v19 > 0xBF)
    {
      if ((v19 + 62) < 0x2Eu) {
        --v9;
      }
    }
    else
    {
      char v20 = *(v9 - 2);
      if (v20 & 0xF0) == 0xE0 && ((a00000000000000[v20 & 0xF] >> (*(v9 - 1) >> 5))) {
        v9 -= 2;
      }
    }
  }
  unsigned int v21 = *(_DWORD *)(v11 + 260);
  char v22 = *(unsigned char *)(v11 + 253);
  if (v14 && v16 >= 1)
  {
    *(_DWORD *)(v8 + 72) = 0;
    *(unsigned char *)(v8 + 64) = 0;
    char v23 = v13;
    goto LABEL_46;
  }
  unint64_t v24 = (unint64_t)v7;
  while (1)
  {
    while (1)
    {
      if (v24 >= (unint64_t)v9) {
        goto LABEL_87;
      }
      unsigned int v28 = 0;
      while (1)
      {
        int v25 = v16 - 1;
        if (v16 < 1)
        {
          *a3 = 15;
          v24 += (unint64_t)v28;
          goto LABEL_113;
        }
        int v26 = (char)v28[v24];
        uint64_t v14 = v28[v24];
        if (v26 < 0) {
          break;
        }
        if (((v21 >> (v28[v24] >> 2)) & 1) == 0)
        {
          unsigned int v33 = *(unsigned __int16 *)(v17 + 2 * (*v61 + v14));
          v24 += (unint64_t)(v28 + 1);
          goto LABEL_72;
        }
        unsigned int v27 = v64++;
        *unsigned int v27 = v14;
        ++v28;
        int v16 = v25;
        if (&v9[-v24] == v28)
        {
          unint64_t v24 = (unint64_t)v9;
          goto LABEL_87;
        }
      }
      char v29 = v28[v24];
      unint64_t v7 = &v28[v24 + 1];
      if (v14 < 0xE0) {
        break;
      }
      if (v14 > 0xED)
      {
        char v23 = 1;
        if ((v14 + 62) > 0x32u)
        {
LABEL_45:
          LOBYTE(v13) = 0;
          LOBYTE(v15) = 0;
          goto LABEL_46;
        }
        goto LABEL_39;
      }
      if (((a00000000000000[v26 & 0xF] >> (*v7 >> 5)) & 1) == 0) {
        goto LABEL_39;
      }
      uint64_t v30 = &v28[v24];
      unsigned int v31 = v28[v24 + 2] ^ 0x80;
      if (v31 > 0x3F) {
        goto LABEL_39;
      }
      unsigned int v32 = *v7 & 0x3F | ((v26 & 0xF) << 6);
      unint64_t v24 = (unint64_t)(v30 + 3);
      unsigned int v33 = *(unsigned __int16 *)(v17 + 2 * (v61[v32] + v31));
      if (*(_WORD *)(v17 + 2 * (v61[v32] + v31))) {
        goto LABEL_73;
      }
      uint64_t v14 = v31 | (v32 << 6);
LABEL_78:
      uint64_t v63 = &unk_18CA811F8;
      uint64_t result = sub_18C86EAF0(v6, *(void *)(v6 + 48), v14, (uint64_t *)&v63, (uint64_t)&unk_18CA811F8, &v64, (unint64_t)&v64[v16], 0, -1, *(unsigned char *)(v5 + 2), a3);
      if (*a3 >= 1)
      {
        *(_DWORD *)(v6 + 84) = result;
        goto LABEL_87;
      }
      if ((*(_DWORD *)(v6 + 208) & 0x80000000) == 0)
      {
        *a3 = -127;
LABEL_87:
        if (*a3 <= 0 && (*(_DWORD *)(v6 + 208) & 0x80000000) != 0)
        {
          unint64_t v47 = a2[3];
          if (v24 < v47)
          {
            int v48 = *(char *)v24;
            *(unsigned char *)(v8 + 65) = *(unsigned char *)v24;
            int v49 = v48;
            if (v48 <= 0xEFu) {
              int v50 = 2;
            }
            else {
              int v50 = 3;
            }
            if (v48 > 0xDFu) {
              ++v50;
            }
            if ((v48 + 62) <= 0x32u) {
              int v51 = v50;
            }
            else {
              int v51 = 0;
            }
            if (v48 < 0) {
              int v52 = v51;
            }
            else {
              int v52 = 1;
            }
            uint64_t v53 = (unsigned __int8 *)(v24 + 1);
            if (v24 + 1 >= v47)
            {
              char v55 = 1;
            }
            else
            {
              unint64_t v54 = ~v24 + v47;
              char v55 = 1;
              do
              {
                int v56 = *v53++;
                char v57 = v55++;
                *(unsigned char *)(v8 + v57 + 65) = v56;
                int v49 = v56 + (v49 << 6);
                --v54;
              }
              while (v54);
              uint64_t v53 = (unsigned __int8 *)v47;
            }
            *(unsigned char *)(v8 + 64) = v55;
            unint64_t v24 = (unint64_t)v53;
            *(_DWORD *)(v8 + 72) = v49;
            *(_DWORD *)(v8 + 76) = v52;
          }
        }
LABEL_113:
        a2[2] = v24;
LABEL_114:
        *(void *)(v5 + 32) = v64;
        return result;
      }
      int v16 = *(_DWORD *)(v5 + 40) - v64;
    }
    char v23 = 1;
    if (v14 < 0xC2) {
      goto LABEL_45;
    }
    unsigned int v34 = *v7 ^ 0x80;
    if (v34 <= 0x3F)
    {
      v24 += (unint64_t)(v28 + 2);
      unsigned int v33 = *(unsigned __int16 *)(v17 + 2 * (v61[v29 & 0x1F] + v34));
      if (!*(_WORD *)(v17 + 2 * (v61[v29 & 0x1F] + v34)))
      {
        uint64_t v14 = v34 | ((v29 & 0x1F) << 6);
        goto LABEL_78;
      }
      goto LABEL_73;
    }
LABEL_39:
    LOBYTE(v13) = 0;
    if (v14 <= 0xEF) {
      LOBYTE(v15) = 2;
    }
    else {
      LOBYTE(v15) = 3;
    }
    if (v14 > 0xDF) {
      LOBYTE(v15) = v15 + 1;
    }
    char v23 = 1;
LABEL_46:
    if (v23 < (char)v15)
    {
      uint64_t result = 1;
      LOBYTE(v35) = v23;
      unint64_t v24 = (unint64_t)v7;
      while (v24 < a2[3])
      {
        unint64_t v36 = *(unsigned __int8 *)v24;
        if ((char)v15 < 3 || v35 >= 2u)
        {
          if ((char)v36 >= -64) {
            goto LABEL_62;
          }
        }
        else
        {
          if (v15 == 3)
          {
            int v37 = a00000000000000[v14 & 0xF];
            unsigned int v38 = v36 >> 5;
          }
          else
          {
            int v37 = byte_18CA811E6[v36 >> 4];
            LOBYTE(v38) = v14 & 7;
          }
          if ((v37 & (1 << v38)) == 0)
          {
LABEL_62:
            char v23 = v35;
            unint64_t v7 = (unsigned char *)v24;
            goto LABEL_63;
          }
        }
        int v35 = (char)(v35 + 1);
        ++v24;
        LODWORD(v14) = v36 + (v14 << 6);
        if (v35 >= (char)v15) {
          goto LABEL_65;
        }
      }
      unint64_t v39 = (char)v13;
      if ((char)v13 >= (char)v35)
      {
        int v41 = (unsigned char *)(v24 + (char)v13 - (uint64_t)(char)v35);
      }
      else
      {
        do
        {
          unint64_t v40 = v39 + 1;
          *(unsigned char *)(v8 + 65 + v39) = v7[v39 - v23];
          unint64_t v39 = v40;
        }
        while (v40 < (char)v35);
        int v41 = &v7[v40 - v23];
      }
      *(unsigned char *)(v8 + 64) = v35;
      *(_DWORD *)(v8 + 72) = v14;
      *(_DWORD *)(v8 + 76) = (char)v15;
      a2[2] = v41;
      goto LABEL_114;
    }
LABEL_63:
    if (v23 != v15) {
      break;
    }
    unint64_t v24 = (unint64_t)v7;
LABEL_65:
    uint64_t v14 = (v14 - dword_18CA811D0[(char)v15]);
    if (char)v15 < 4 || (unsigned int v42 = 0, (v22)) {
      unsigned int v42 = *(_DWORD *)(v62
    }
                      + 4 * (((v14 >> 4) & 0x3F) + *(unsigned __int16 *)(v62 + 2 * ((int)v14 >> 10))));
    unsigned int v33 = *(unsigned __int16 *)(v17 + 2 * (v14 & 0xF | (16 * (unsigned __int16)v42)));
    if (((v42 >> (v14 & 0xF | 0x10)) & 1) == 0)
    {
      if (!*(unsigned char *)(v6 + 63) && (v14 - 57344) >> 8 >= 0x19 && (v14 - 983040) >> 17) {
        goto LABEL_78;
      }
LABEL_72:
      if (!v33) {
        goto LABEL_78;
      }
    }
LABEL_73:
    if (v33 > 0xFF)
    {
      int v45 = v64++;
      unsigned char *v45 = BYTE1(v33);
      if (v16 < 2)
      {
        *(unsigned char *)(v6 + 104) = v33;
        *(unsigned char *)(v6 + 91) = 1;
        *a3 = 15;
        goto LABEL_113;
      }
      unint64_t v46 = v64++;
      unsigned char *v46 = v33;
      int v44 = -2;
    }
    else
    {
      BOOL v43 = v64++;
      unsigned char *v43 = v33;
      int v44 = -1;
    }
    v16 += v44;
  }
  uint64_t v58 = (char)v13 - (uint64_t)v23;
  if ((char)v13 < v23)
  {
    uint64_t v59 = (unsigned char *)((char)v13 + v8 + 65);
    do
      *v59++ = v7[v58];
    while (!__CFADD__(v58++, 1));
  }
  *(unsigned char *)(v8 + 64) = v23;
  a2[2] = &v7[v58];
  *(void *)(v5 + 32) = v64;
  *a3 = 12;
  return result;
}

uint64_t sub_18C871218(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a1 + ((unint64_t)a2 << 10);
  int v4 = *(_DWORD *)(v3 + 644);
  if ((v4 & 0x80000000) == 0 || (v4 & 0xF00000) == 0x700000)
  {
    int v5 = *(_DWORD *)(v3 + 260);
    if ((v5 & 0x80000000) == 0 || (v5 & 0xF00000) == 0x700000)
    {
      uint64_t v7 = 0;
      while (1)
      {
        int v8 = *(_DWORD *)(v3 + v7);
        if (v8 < 0 && (v8 & 0xF00000) != 0x700000) {
          break;
        }
        v7 += 4;
        if (v7 == 1024)
        {
          uint64_t v9 = 0;
          while (1)
          {
            unsigned int v10 = *(_DWORD *)(v3 + v9);
            if ((v10 & 0x80000000) == 0)
            {
              if (sub_18C871218(a1, HIBYTE(v10))) {
                break;
              }
            }
            v9 += 4;
            if (v9 == 1024) {
              return 0;
            }
          }
          return 1;
        }
      }
    }
  }
  return 1;
}

char *sub_18C8712C8(char *result, uint64_t a2, _DWORD *a3)
{
  if (!*(unsigned char *)(a2 + 8))
  {
    int v4 = result;
    int v5 = *(unsigned char **)(a2 + 32);
    uint64_t result = (char *)uprv_malloc(0x54uLL);
    *((void *)v4 + 2) = result;
    if (result)
    {
      if (!v5 || *v5 != 106 || v5[1] != 97 || (v6 = 0x605070001040203, char v7 = 1, v5[2]) && v5[2] != 95)
      {
        char v7 = 0;
        uint64_t v6 = 0x106050402030007;
      }
      result[74] = v7;
      *(_OWORD *)uint64_t result = xmmword_18CA81340;
      *((_OWORD *)result + 1) = unk_18CA81350;
      result[64] = 1;
      *(_DWORD *)(result + 65) = 0;
      v4[64] = 0;
      *((_OWORD *)result + 2) = xmmword_18CA81340;
      *((_OWORD *)result + 3) = unk_18CA81350;
      *((_WORD *)result + 36) = 1;
      result[75] = 0;
      *(void *)(result + 76) = v6;
      *((_DWORD *)v4 + 21) = 0;
    }
    else
    {
      *a3 = 7;
    }
    *((_WORD *)v4 + 68) = -3;
    v4[89] = -1;
  }
  return result;
}

void sub_18C8713B8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    if (!*(unsigned char *)(a1 + 62)) {
      uprv_free(v2);
    }
    *(void *)(a1 + 16) = 0;
  }
}

uint64_t sub_18C8713F0(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (a2 > 1
    || (*(_OWORD *)uint64_t v2 = xmmword_18CA81340,
        *(_OWORD *)(v2 + 16) = unk_18CA81350,
        *(unsigned char *)(v2 + 64) = 1,
        *(_DWORD *)(v2 + 65) = 0,
        *(unsigned char *)(result + 64) = 0,
        a2 != 1))
  {
    *(_OWORD *)(v2 + 32) = xmmword_18CA81340;
    *(_OWORD *)(v2 + 48) = unk_18CA81350;
    *(_WORD *)(v2 + 72) = 1;
    *(unsigned char *)(v2 + 75) = 0;
    uint64_t v3 = 0x106050402030007;
    if (*(unsigned char *)(v2 + 74) == 1) {
      uint64_t v3 = 0x605070001040203;
    }
    *(void *)(v2 + 76) = v3;
    *(_DWORD *)(result + 84) = 0;
  }
  return result;
}

void *sub_18C871470(void *result, int *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = (unsigned __int16 *)result[2];
  int v4 = *(unsigned char **)(v2 + 16);
  unint64_t v6 = result[3];
  int v5 = (_WORD *)result[4];
  unint64_t v7 = result[5];
  char v8 = v4[64];
  int v9 = v4[65];
  uint64_t v10 = v4[66];
  uint64_t v11 = v4[67];
  uint64_t v12 = v4[68];
  if (v8)
  {
    uint64_t v13 = v4[68];
    uint64_t v14 = v4[66];
    uint64_t v15 = v4[67];
    if (v4[65]) {
      goto LABEL_21;
    }
    goto LABEL_7;
  }
  uint64_t v14 = v4[66];
  if (!v4[65])
  {
LABEL_29:
    int v9 = 0;
    if ((unint64_t)v3 + 1 < v6 && (unint64_t)v5 < v7)
    {
      while ((*(unsigned char *)v3 + 13) <= 0xECu)
      {
        *v5++ = _byteswap_ushort(*v3);
        int v18 = v3 + 1;
        if ((unint64_t)v3 + 3 < v6)
        {
          ++v3;
          if ((unint64_t)v5 < v7) {
            continue;
          }
        }
        int v9 = 0;
        uint64_t v3 = v18;
        goto LABEL_36;
      }
      int v9 = 0;
    }
LABEL_36:
    uint64_t v14 = v10;
  }
  if ((unint64_t)v3 >= v6)
  {
    char v8 = 0;
    goto LABEL_56;
  }
  uint64_t v19 = 0;
  uint64_t v13 = v12;
  int v20 = v9;
  while ((unint64_t)v5 < v7)
  {
    uint64_t v21 = *((unsigned __int8 *)v3 + v19);
    if (v20)
    {
      if (v20 != 1)
      {
        if (v20 == 2)
        {
          *v5++ = v21 | ((_WORD)v13 << 8);
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
          uint64_t v12 = v13;
          uint64_t v10 = v14;
          goto LABEL_29;
        }
        goto LABEL_52;
      }
      *(unsigned char *)(v2 + 66) = v21;
      char v23 = 2;
      int v20 = 2;
    }
    else
    {
      uint64_t v22 = (v21 + 32);
      if ((v21 + 32) < 0x13u)
      {
        if (v21 < 0xE8)
        {
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
          char v8 = 1;
          uint64_t v12 = v13;
          uint64_t v10 = v14;
          uint64_t v11 = v22;
          while (1)
          {
LABEL_7:
            int v9 = 0;
            if ((unint64_t)v3 < v6 && (unint64_t)v5 < v7)
            {
              while (1)
              {
                unsigned int v16 = *(unsigned __int8 *)v3;
                if (v16 < 0x20)
                {
LABEL_18:
                  int v9 = 0;
                  break;
                }
                uint64_t v3 = (unsigned __int16 *)((char *)v3 + 1);
                if ((v16 & 0x80) != 0 && (unsigned int v16 = *(_DWORD *)&v4[4 * (char)v11] + (v16 & 0x7F), HIWORD(v16)))
                {
                  *int v5 = (v16 >> 10) - 10304;
                  __int16 v17 = v16 & 0x3FF | 0xDC00;
                  if ((unint64_t)(v5 + 1) >= v7)
                  {
                    int v9 = 0;
                    *(_WORD *)(v2 + 144) = v17;
                    *(unsigned char *)(v2 + 93) = 1;
                    *a2 = 15;
                    ++v5;
                    goto LABEL_57;
                  }
                  v5[1] = v17;
                  v5 += 2;
                }
                else
                {
                  *v5++ = v16;
                }
                if ((unint64_t)v3 >= v6 || (unint64_t)v5 >= v7) {
                  goto LABEL_18;
                }
              }
            }
            uint64_t v13 = v12;
            uint64_t v14 = v10;
LABEL_20:
            uint64_t v15 = v11;
LABEL_21:
            if ((unint64_t)v3 >= v6) {
              goto LABEL_25;
            }
            uint64_t v11 = v15;
            uint64_t v10 = v14;
            uint64_t v12 = v13;
            if ((unint64_t)v5 >= v7) {
              break;
            }
            *v5++ = *(unsigned __int8 *)v3 | (unsigned __int16)((_WORD)v13 << 8);
            uint64_t v3 = (unsigned __int16 *)((char *)v3 + 1);
          }
          *a2 = 15;
LABEL_25:
          LOBYTE(v12) = v13;
          LOBYTE(v10) = v14;
          LOBYTE(v11) = v15;
          goto LABEL_57;
        }
        if (v21 <= 0xEF)
        {
          uint64_t v11 = (v21 + 24);
          int v9 = 6;
          goto LABEL_28;
        }
        if (v21 != 240)
        {
          if (v21 == 241)
          {
            int v9 = 4;
LABEL_28:
            *(unsigned char *)(v2 + 65) = v21;
            char v8 = 1;
            *(unsigned char *)(v2 + 64) = 1;
            uint64_t v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
            goto LABEL_20;
          }
          char v8 = 0;
          int v9 = 0;
          *a2 = 12;
          *(unsigned char *)(v2 + 65) = v21;
          *(unsigned char *)(v2 + 64) = 1;
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v19 + 1);
          goto LABEL_54;
        }
        *(unsigned char *)(v2 + 65) = -16;
        char v23 = 1;
        int v20 = 1;
        uint64_t v21 = v13;
      }
      else
      {
        *(unsigned char *)(v2 + 65) = v21;
        int v20 = 2;
        char v23 = 1;
      }
    }
    *(unsigned char *)(v2 + 64) = v23;
    uint64_t v13 = v21;
LABEL_52:
    if (v6 - (void)v3 == ++v19)
    {
      char v8 = 0;
      uint64_t v3 = (unsigned __int16 *)v6;
      int v9 = v20;
LABEL_54:
      LOBYTE(v12) = v13;
      goto LABEL_56;
    }
  }
  char v8 = 0;
  *a2 = 15;
LABEL_56:
  LOBYTE(v10) = v14;
LABEL_57:
  if (*a2 < 1 || *a2 == 15)
  {
    if (!v9) {
      *(unsigned char *)(v2 + 64) = 0;
    }
  }
  else
  {
    LOBYTE(v9) = 0;
  }
  v4[64] = v8;
  v4[65] = v9;
  v4[66] = v10;
  v4[67] = v11;
  v4[68] = v12;
  result[2] = v3;
  result[4] = v5;
  return result;
}

void *sub_18C871A84(void *result, _DWORD *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = (unsigned __int8 *)result[2];
  int v4 = *(unsigned char **)(v2 + 16);
  unint64_t v6 = result[3];
  int v5 = (_WORD *)result[4];
  unint64_t v8 = result[5];
  unint64_t v7 = (int *)result[6];
  int v9 = v4[65];
  uint64_t v10 = v4[66];
  uint64_t v11 = v4[67];
  uint64_t v12 = v4[68];
  unsigned int v33 = a2;
  if (!v4[64])
  {
    int v15 = 0;
    if (v4[65])
    {
      int i = -1;
      uint64_t v16 = v4[68];
      goto LABEL_50;
    }
LABEL_80:
    uint64_t v16 = v12;
    if ((unint64_t)(v3 + 1) >= v6 || (unint64_t)v5 >= v8)
    {
      int v9 = 0;
      int i = v15;
      goto LABEL_50;
    }
    unint64_t v24 = 0;
    int i = v15;
    while ((v3[v24] + 13) <= 0xECu)
    {
      v5[v24 / 2] = _byteswap_ushort(*(_WORD *)&v3[v24]);
      unint64_t v25 = (unint64_t)&v5[v24 / 2 + 1];
      if (v7) {
        *v7++ = i;
      }
      unint64_t v26 = v24 + 2;
      if ((unint64_t)&v3[v24 + 3] < v6)
      {
        int i = v15 + v24;
        v24 += 2;
        if (v25 < v8) {
          continue;
        }
      }
      int v9 = 0;
      v15 += v26;
      int i = v15 - 2;
      int v5 = (_WORD *)((char *)v5 + v26);
      v3 += v26;
      goto LABEL_50;
    }
    int v9 = 0;
    v15 += v24;
    int v5 = (_WORD *)((char *)v5 + v24);
    v3 += v24;
LABEL_50:
    if ((unint64_t)v3 >= v6)
    {
      char v19 = 0;
      goto LABEL_69;
    }
    uint64_t v27 = 0;
    uint64_t v12 = v16;
    int v28 = v9;
    while (1)
    {
      if ((unint64_t)v5 >= v8)
      {
        char v19 = 0;
        *a2 = 15;
        goto LABEL_69;
      }
      uint64_t v29 = v3[v27];
      if (!v28) {
        break;
      }
      if (v28 == 1)
      {
        *(unsigned char *)(v2 + 66) = v29;
        char v30 = 2;
        int v28 = 2;
LABEL_64:
        *(unsigned char *)(v2 + 64) = v30;
        uint64_t v12 = v29;
        goto LABEL_65;
      }
      if (v28 == 2)
      {
        *v5++ = v29 | ((_WORD)v12 << 8);
        v15 += 1 + v27;
        v3 += v27 + 1;
        if (v7) {
          *v7++ = i;
        }
        goto LABEL_80;
      }
LABEL_65:
      if (v6 - (void)v3 == ++v27)
      {
        char v19 = 0;
        uint64_t v3 = (unsigned __int8 *)v6;
        int v9 = v28;
        goto LABEL_67;
      }
    }
    uint64_t v18 = (v29 + 32);
    if ((v29 + 32) < 0x13u)
    {
      if (v29 < 0xE8)
      {
        int i = v15 + v27 + 1;
        v3 += v27 + 1;
        char v32 = 1;
        uint64_t v16 = v12;
        uint64_t v17 = v10;
        goto LABEL_17;
      }
      if (v29 <= 0xEF)
      {
        uint64_t v11 = (v29 + 24);
        int v9 = 6;
        goto LABEL_84;
      }
      if (v29 != 240)
      {
        if (v29 == 241)
        {
          int v9 = 4;
LABEL_84:
          *(unsigned char *)(v2 + 65) = v29;
          char v32 = 1;
          *(unsigned char *)(v2 + 64) = 1;
          int v13 = v15 + v27 + 1;
          v3 += v27 + 1;
          goto LABEL_7;
        }
        char v19 = 0;
        int v9 = 0;
        *a2 = 12;
        *(unsigned char *)(v2 + 65) = v29;
        *(unsigned char *)(v2 + 64) = 1;
        v3 += v27 + 1;
LABEL_67:
        LOBYTE(v16) = v12;
LABEL_69:
        LOBYTE(v17) = v10;
        LOBYTE(v18) = v11;
        goto LABEL_70;
      }
      *(unsigned char *)(v2 + 65) = -16;
      char v30 = 1;
      int v28 = 1;
      uint64_t v29 = v12;
    }
    else
    {
      *(unsigned char *)(v2 + 65) = v29;
      int v28 = 2;
      char v30 = 1;
    }
    goto LABEL_64;
  }
  char v32 = v4[64];
  int v13 = 0;
  if (!v4[65])
  {
    uint64_t v16 = v4[68];
    uint64_t v17 = v4[66];
    uint64_t v18 = v4[67];
    int i = 0;
    goto LABEL_17;
  }
  for (i = -1; ; int v13 = i)
  {
LABEL_7:
    if ((unint64_t)v3 >= v6)
    {
      LOBYTE(v16) = v12;
      LOBYTE(v17) = v10;
      LOBYTE(v18) = v11;
      a2 = v33;
      goto LABEL_11;
    }
    uint64_t v18 = v11;
    LOBYTE(v17) = v10;
    uint64_t v16 = v12;
    if ((unint64_t)v5 >= v8)
    {
      a2 = v33;
      *unsigned int v33 = 15;
      LOBYTE(v16) = v12;
      LOBYTE(v18) = v11;
LABEL_11:
      char v19 = v32;
      goto LABEL_70;
    }
    *v5++ = *v3++ | (unsigned __int16)((_WORD)v12 << 8);
    if (v7) {
      *v7++ = i;
    }
    int i = v13 + 1;
    uint64_t v17 = v10;
    a2 = v33;
LABEL_17:
    int v9 = 0;
    if ((unint64_t)v3 < v6 && (unint64_t)v5 < v8) {
      break;
    }
LABEL_33:
    uint64_t v12 = v16;
    uint64_t v10 = v17;
    uint64_t v11 = v18;
  }
  while (1)
  {
    unsigned int v20 = *v3;
    if (v20 < 0x20)
    {
LABEL_32:
      int v9 = 0;
      goto LABEL_33;
    }
    ++v3;
    if ((v20 & 0x80) == 0 || (unsigned int v20 = *(_DWORD *)&v4[4 * (char)v18] + (v20 & 0x7F), !HIWORD(v20)))
    {
      *v5++ = v20;
      if (!v7) {
        goto LABEL_25;
      }
      uint64_t v21 = 1;
      uint64_t v22 = v7;
      goto LABEL_24;
    }
    *int v5 = (v20 >> 10) - 10304;
    if ((unint64_t)(v5 + 1) >= v8) {
      break;
    }
    v5[1] = v20 & 0x3FF | 0xDC00;
    if (v7)
    {
      *unint64_t v7 = i;
      uint64_t v22 = v7 + 1;
      uint64_t v21 = 2;
      v5 += 2;
LABEL_24:
      v7 += v21;
      *uint64_t v22 = i;
      goto LABEL_25;
    }
    v5 += 2;
LABEL_25:
    ++i;
    if ((unint64_t)v3 >= v6 || (unint64_t)v5 >= v8) {
      goto LABEL_32;
    }
  }
  if (v7) {
    *v7++ = i;
  }
  char v19 = v32;
  int v9 = 0;
  *(_WORD *)(v2 + 144) = v20 & 0x3FF | 0xDC00;
  *(unsigned char *)(v2 + 93) = 1;
  *a2 = 15;
  ++v5;
LABEL_70:
  if ((int)*a2 < 1 || *a2 == 15)
  {
    if (!v9) {
      *(unsigned char *)(v2 + 64) = 0;
    }
  }
  else
  {
    LOBYTE(v9) = 0;
  }
  v4[64] = v19;
  v4[65] = v9;
  v4[66] = v17;
  v4[67] = v18;
  v4[68] = v16;
  result[2] = v3;
  result[4] = v5;
  result[6] = v7;
  return result;
}

uint64_t sub_18C872268(uint64_t result, int *a2)
{
  uint64_t v84 = result;
  unsigned int v87 = 0;
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = *(unsigned __int16 **)(result + 16);
  uint64_t v4 = *(void *)(v2 + 16);
  unint64_t v5 = *(void *)(result + 24);
  unint64_t v6 = *(unsigned char **)(result + 32);
  int v7 = *(_DWORD *)(result + 40) - v6;
  uint64_t v8 = *(unsigned __int8 *)(v4 + 72);
  long long v85 = (unsigned char *)v2;
  uint64_t v86 = *(unsigned __int8 *)(v4 + 73);
  uint64_t v9 = *(unsigned int *)(v4 + 4 * v86 + 32);
  for (unsigned int i = *(_DWORD *)(v2 + 84); ; unsigned int i = 0)
  {
    BOOL v11 = !i || v7 <= 0;
    BOOL v12 = !v11;
    if (!v8) {
      break;
    }
    if (v12) {
      goto LABEL_10;
    }
    while (1)
    {
      if ((unint64_t)v3 >= v5) {
        goto LABEL_162;
      }
      if (v7 < 1) {
        goto LABEL_157;
      }
      unsigned int v56 = *v3++;
      unsigned int i = v56;
      if (v56 - 32 <= 0x5F) {
        goto LABEL_91;
      }
      if (i > 0x1F) {
        break;
      }
      if (((1 << i) & 0x2601) == 0)
      {
        i |= 0x100u;
        goto LABEL_98;
      }
LABEL_91:
      *unint64_t v6 = i;
LABEL_92:
      unsigned int i = 0;
      ++v6;
      --v7;
    }
    char v15 = i - v9;
    if (i - v9 < 0x80) {
      goto LABEL_13;
    }
    if ((i & 0xF800) != 0xD800)
    {
      if (i > 0x9F)
      {
        if (i == 65279 || i >> 4 > 0xFFE)
        {
          i |= 0xE0000u;
LABEL_114:
          int v32 = 3;
        }
        else
        {
          uint64_t v57 = 0;
          int v58 = 4224;
          while (i - *(_DWORD *)(v4 + 4 * v57 + 32) >= 0x80)
          {
            ++v57;
            v58 += 256;
            if (v57 == 8) {
              goto LABEL_119;
            }
          }
          if ((v57 & 0x80) != 0)
          {
LABEL_119:
            uint64_t v64 = 0;
            int v62 = 256;
            while (i - dword_18CA81360[v64] >= 0x80)
            {
              ++v64;
              v62 += 256;
              if (v64 == 8) {
                goto LABEL_126;
              }
            }
            if ((v64 & 0x80) == 0)
            {
              int v63 = i - dword_18CA81360[v64];
              goto LABEL_125;
            }
LABEL_126:
            uint64_t v65 = v9;
            uint64_t v66 = v8;
            uint64_t result = sub_18C873914(i, &v87);
            if ((result & 0x80000000) != 0)
            {
              uint64_t v9 = v65;
              if ((i - 13312) >> 10 <= 0x28
                && ((unint64_t)v3 >= v5 || (*v3 - 13312) >> 10 <= 0x28))
              {
                uint64_t v8 = 0;
                i |= 0xF0000u;
                goto LABEL_114;
              }
              i |= 0xE0000u;
              int v32 = 3;
            }
            else
            {
              int v67 = result;
              uint64_t v68 = *(char *)(v4 + 75);
              unsigned __int8 v69 = *(unsigned char *)(v4 + v68 + 76);
              int v70 = v69;
              if ((v68 + 1) == 8) {
                char v71 = 0;
              }
              else {
                char v71 = v68 + 1;
              }
              *(unsigned char *)(v4 + 75) = v71;
              uint64_t v72 = v87;
              *(_DWORD *)(v4 + 4 * v69 + 32) = v87;
              uint64_t result = sub_18C87389C(v4, v69);
              uint64_t v9 = v72;
              LOBYTE(v86) = v70;
              unsigned int i = ((v70 << 16) + 1572864) | (v67 << 8) | (i - v72) | 0x80;
              int v32 = 3;
            }
            uint64_t v8 = v66;
            goto LABEL_99;
          }
          char v59 = v57;
          if ((unint64_t)v3 >= v5
            || (unsigned int v60 = *(_DWORD *)(v4 + 4 * v57 + 32), v61 = *v3, v60 + 127 >= v61)
            && (v60 <= v61 || v61 <= 0x7F && (v61 > 0x1F || ((1 << v61) & 0x2601) != 0)))
          {
            uint64_t v73 = *(unsigned int *)(v4 + 4 * v57 + 32);
            uint64_t v74 = v8;
            uint64_t result = sub_18C87389C(v4, v57);
            uint64_t v9 = v73;
            uint64_t v8 = v74;
            unsigned int i = v58 | (i - v73);
            int v32 = 2;
            LOBYTE(v86) = v59;
            goto LABEL_99;
          }
          int v62 = i - v60;
          int v63 = ((char)v57 << 8) + 384;
LABEL_125:
          unsigned int i = v63 | v62;
LABEL_98:
          int v32 = 2;
        }
      }
      else
      {
        int v32 = 2;
        unsigned int i = i & 0x7F | 0x200;
      }
      goto LABEL_99;
    }
    if ((i & 0x400) != 0)
    {
LABEL_164:
      int v81 = 12;
LABEL_165:
      uint64_t v79 = v84;
      unsigned int v75 = v85;
LABEL_166:
      unsigned int v80 = a2;
      goto LABEL_167;
    }
LABEL_10:
    unint64_t v82 = v5;
    if ((unint64_t)v3 >= v5) {
      goto LABEL_162;
    }
    int v13 = *v3;
    if ((v13 & 0xFC00) != 0xDC00) {
      goto LABEL_164;
    }
    ++v3;
    int v14 = (i << 10) - 56613888 + v13;
    char v15 = v13 - v9;
    if ((v14 - v9) < 0x80)
    {
LABEL_13:
      *unint64_t v6 = v15 | 0x80;
      goto LABEL_92;
    }
    uint64_t v16 = 0;
    int v17 = 4224;
    while ((v14 - *(_DWORD *)(v4 + 4 * v16 + 32)) >= 0x80)
    {
      ++v16;
      v17 += 256;
      if (v16 == 8) {
        goto LABEL_27;
      }
    }
    if ((v16 & 0x80) == 0)
    {
      uint64_t v22 = *(unsigned int *)(v4 + 4 * v16 + 32);
      LOBYTE(v86) = v16;
      uint64_t v23 = v8;
      uint64_t result = sub_18C87389C(v4, v16);
      uint64_t v9 = v22;
      uint64_t v8 = v23;
      unsigned int i = v17 | (v14 - v22);
      goto LABEL_98;
    }
LABEL_27:
    uint64_t v24 = v9;
    uint64_t v25 = v8;
    uint64_t result = sub_18C873914((i << 10) - 56613888 + v13, &v87);
    if ((result & 0x80000000) != 0)
    {
      uint64_t v8 = 0;
      *v6++ = 15;
      --v7;
      int v32 = 4;
      unsigned int i = v13 | (i << 16);
      uint64_t v9 = v24;
    }
    else
    {
      int v26 = result;
      uint64_t v27 = *(char *)(v4 + 75);
      unsigned __int8 v28 = *(unsigned char *)(v4 + v27 + 76);
      int v29 = v28;
      if ((v27 + 1) == 8) {
        char v30 = 0;
      }
      else {
        char v30 = v27 + 1;
      }
      *(unsigned char *)(v4 + 75) = v30;
      uint64_t v31 = v87;
      *(_DWORD *)(v4 + 4 * v28 + 32) = v87;
      uint64_t result = sub_18C87389C(v4, v28);
      uint64_t v9 = v31;
      LOBYTE(v86) = v29;
      unsigned int i = ((v26 << 8) - 0x20000) | (v29 << 21) | (v14 - v31) | 0xB000080;
      int v32 = 4;
      uint64_t v8 = v25;
    }
    unint64_t v5 = v82;
LABEL_99:
    if (v7 < v32)
    {
LABEL_143:
      unsigned int v75 = v85;
      int v76 = v32 - v7;
      uint64_t v77 = v85 + 104;
      switch(v76)
      {
        case 1:
          goto LABEL_147;
        case 2:
          goto LABEL_146;
        case 3:
          goto LABEL_145;
        case 4:
          uint64_t v77 = v85 + 105;
          v85[104] = HIBYTE(i);
LABEL_145:
          *v77++ = BYTE2(i);
LABEL_146:
          *v77++ = BYTE1(i);
LABEL_147:
          *uint64_t v77 = i;
          break;
        default:
          break;
      }
      v85[91] = v76;
      if (v76 == 4) {
        unsigned int v78 = 0;
      }
      else {
        unsigned int v78 = i >> (8 * v76);
      }
      if (v7 == 1)
      {
        unsigned int v80 = a2;
        uint64_t v79 = v84;
      }
      else
      {
        if (v7 != 2)
        {
          if (v7 != 3)
          {
            unsigned int i = 0;
            int v81 = 15;
            uint64_t v79 = v84;
            goto LABEL_166;
          }
          *v6++ = BYTE2(v78);
        }
        unsigned int v80 = a2;
        uint64_t v79 = v84;
        *v6++ = BYTE1(v78);
      }
      unsigned int i = 0;
      *v6++ = v78;
      int v81 = 15;
LABEL_167:
      int *v80 = v81;
      goto LABEL_168;
    }
    if (v32 != 2)
    {
      if (v32 != 3) {
        *v6++ = HIBYTE(i);
      }
      *v6++ = BYTE2(i);
    }
    *(_WORD *)unint64_t v6 = bswap32(i) >> 16;
    v6 += 2;
    v7 -= v32;
  }
  if (v12)
  {
LABEL_19:
    if ((unint64_t)v3 < v5)
    {
      int v18 = *v3;
      if ((v18 & 0xFC00) != 0xDC00)
      {
        LOBYTE(v8) = 0;
        goto LABEL_164;
      }
      uint64_t v19 = 0;
      ++v3;
      unsigned int v20 = v18 + (i << 10) - 56613888;
      int v21 = 57472;
      while (v20 - *(_DWORD *)(v4 + 4 * v19 + 32) >= 0x80)
      {
        ++v19;
        v21 += 256;
        if (v19 == 8) {
          goto LABEL_46;
        }
      }
      if ((v19 & 0x80) != 0 || (unint64_t)v3 < v5 && (*v3 - 13312) >> 10 < 0x29)
      {
LABEL_46:
        if ((unint64_t)v3 >= v5
          || *v3 != (unsigned __int16)i
          || (v35 = v9, uint64_t result = sub_18C873914(v20, &v87), v9 = v35, (result & 0x80000000) != 0))
        {
          uint64_t v8 = 0;
          unsigned int i = v18 | (i << 16);
          int v32 = 4;
          goto LABEL_99;
        }
        int v36 = result;
        uint64_t v37 = *(char *)(v4 + 75);
        int v38 = *(char *)(v4 + v37 + 76);
        LOBYTE(v86) = *(unsigned char *)(v4 + v37 + 76);
        if ((v37 + 1) == 8) {
          char v39 = 0;
        }
        else {
          char v39 = v37 + 1;
        }
        *(unsigned char *)(v4 + 75) = v39;
        uint64_t v40 = v87;
        *(_DWORD *)(v4 + 4 * v38 + 32) = v87;
        uint64_t result = sub_18C87389C(v4, v38);
        uint64_t v9 = v40;
        unsigned int i = ((v36 << 8) + 268304384) | (v38 << 21) | (v20 - v40) | 0xF1000080;
        int v32 = 4;
      }
      else
      {
        uint64_t v43 = *(unsigned int *)(v4 + 4 * v19 + 32);
        LOBYTE(v86) = v19;
        uint64_t result = sub_18C87389C(v4, v19);
        uint64_t v9 = v43;
        unsigned int i = v21 | (v20 - v43);
        int v32 = 2;
      }
      uint64_t v8 = 1;
      goto LABEL_99;
    }
  }
  else if ((unint64_t)v3 < v5)
  {
    if (v7 < 1)
    {
      LOBYTE(v8) = 0;
      goto LABEL_157;
    }
    unint64_t v33 = 0;
    while (1)
    {
      unsigned int i = v3[v33 / 2];
      if ((i - 13312) >> 10 > 0x28) {
        break;
      }
      if (v7 < 2)
      {
        LOBYTE(v8) = 0;
        uint64_t v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
        v6 += v33;
        int v7 = 1;
        int v32 = 2;
        goto LABEL_143;
      }
      unsigned int v34 = &v6[v33];
      *unsigned int v34 = BYTE1(i);
      v34[1] = i;
      if ((unint64_t)&v3[v33 / 2 + 1] >= v5)
      {
        LOBYTE(v8) = 0;
        unsigned int i = 0;
        uint64_t v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
        unint64_t v6 = v34 + 2;
        goto LABEL_162;
      }
      v33 += 2;
      BOOL v11 = v7 < 3;
      v7 -= 2;
      if (v11)
      {
        LOBYTE(v8) = 0;
        unsigned int i = 0;
        uint64_t v3 = (unsigned __int16 *)((char *)v3 + v33);
        v6 += v33;
LABEL_157:
        int v81 = 15;
        goto LABEL_165;
      }
    }
    int v41 = &v3[v33 / 2 + 1];
    unsigned int v42 = &v6[v33];
    if ((i - 13312) >> 8 < 0xBF)
    {
      if (i >> 13 <= 6)
      {
        if ((i & 0x400) != 0)
        {
          LOBYTE(v8) = 0;
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
          v6 += v33;
          goto LABEL_164;
        }
        uint64_t v3 = (unsigned __int16 *)((char *)v3 + v33 + 2);
        v6 += v33;
        goto LABEL_19;
      }
      uint64_t v8 = 0;
      i |= 0xF00000u;
      int v32 = 3;
    }
    else if ((unint64_t)v41 >= v5 || (*v41 - 13312) >> 10 >= 0x29)
    {
      if (i - 48 >= 0xA && i - 97 >= 0x1A && i - 65 >= 0x1A)
      {
        uint64_t v46 = 0;
        int v47 = 57472;
        while (i - *(_DWORD *)(v4 + 4 * v46 + 32) >= 0x80)
        {
          ++v46;
          v47 += 256;
          if (v46 == 8) {
            goto LABEL_80;
          }
        }
        if ((v46 & 0x80) != 0)
        {
LABEL_80:
          uint64_t v49 = v9;
          uint64_t result = sub_18C873914(i, &v87);
          if ((result & 0x80000000) != 0)
          {
            uint64_t v8 = 0;
            int v32 = 2;
            uint64_t v3 = v41;
            unint64_t v6 = v42;
            uint64_t v9 = v49;
          }
          else
          {
            int v50 = result;
            uint64_t v51 = *(char *)(v4 + 75);
            unsigned __int8 v52 = *(unsigned char *)(v4 + v51 + 76);
            int v53 = v52;
            if ((v51 + 1) == 8) {
              char v54 = 0;
            }
            else {
              char v54 = v51 + 1;
            }
            *(unsigned char *)(v4 + 75) = v54;
            uint64_t v55 = v87;
            *(_DWORD *)(v4 + 4 * v52 + 32) = v87;
            uint64_t result = sub_18C87389C(v4, v52);
            uint64_t v9 = v55;
            LOBYTE(v86) = v53;
            unsigned int i = ((v53 << 16) + 15204352) | (v50 << 8) | (i - v55) | 0x80;
            int v32 = 3;
            uint64_t v8 = 1;
            uint64_t v3 = v41;
            unint64_t v6 = v42;
          }
          goto LABEL_99;
        }
        uint64_t v48 = *(unsigned int *)(v4 + 4 * v46 + 32);
        LOBYTE(v86) = v46;
        uint64_t result = sub_18C87389C(v4, v46);
        uint64_t v9 = v48;
        unsigned int i = v47 | (i - v48);
      }
      else
      {
        i |= (v86 << 8) + 57344;
      }
      int v32 = 2;
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v32 = 2;
    }
    uint64_t v3 = v41;
    unint64_t v6 = v42;
    goto LABEL_99;
  }
  LOBYTE(v8) = 0;
LABEL_162:
  uint64_t v79 = v84;
  unsigned int v75 = v85;
LABEL_168:
  *(unsigned char *)(v4 + 72) = v8;
  *(unsigned char *)(v4 + 73) = v86;
  *((_DWORD *)v75 + 21) = i;
  *(void *)(v79 + 16) = v3;
  *(void *)(v79 + 32) = v6;
  return result;
}

uint64_t sub_18C872C48(uint64_t result, int *a2)
{
  unsigned int v87 = (void *)result;
  int v2 = 0;
  unsigned int v94 = 0;
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v3 = *(unsigned __int16 **)(result + 16);
  uint64_t v5 = *(void *)(v4 + 16);
  unint64_t v6 = *(void *)(result + 24);
  int v7 = *(unsigned char **)(result + 32);
  int v8 = *(_DWORD *)(result + 40) - v7;
  uint64_t v9 = *(int **)(result + 48);
  uint64_t v10 = *(unsigned __int8 *)(v5 + 72);
  unint64_t v92 = v6;
  uint64_t v93 = *(unsigned __int8 *)(v5 + 73);
  uint64_t v91 = v4;
  unsigned int v11 = *(_DWORD *)(v4 + 84);
  if (v11) {
    int v12 = -1;
  }
  else {
    int v12 = 0;
  }
  unsigned int v13 = *(_DWORD *)(v5 + 4 * v93 + 32);
  while (1)
  {
    if (v11) {
      BOOL v14 = v8 <= 0;
    }
    else {
      BOOL v14 = 1;
    }
    char v15 = !v14;
    if (!v10)
    {
      if (v15)
      {
        int v16 = v12;
LABEL_24:
        if ((unint64_t)v3 < v6)
        {
          int v22 = *v3;
          if ((v22 & 0xFC00) == 0xDC00)
          {
            uint64_t v23 = 0;
            ++v3;
            int v12 = v2 + 1;
            unsigned int v24 = v22 + (v11 << 10) - 56613888;
            int v25 = 57472;
            while (v24 - *(_DWORD *)(v5 + 4 * v23 + 32) >= 0x80)
            {
              ++v23;
              v25 += 256;
              if (v23 == 8) {
                goto LABEL_53;
              }
            }
            if ((v23 & 0x80) != 0 || (unint64_t)v3 < v6 && (*v3 - 13312) >> 10 < 0x29)
            {
LABEL_53:
              if ((unint64_t)v3 >= v6
                || *v3 != (unsigned __int16)v11
                || (long long v89 = v3,
                    int v84 = v16,
                    uint64_t result = sub_18C873914(v24, &v94),
                    int v16 = v84,
                    uint64_t v3 = v89,
                    unint64_t v6 = v92,
                    (result & 0x80000000) != 0))
              {
                uint64_t v10 = 0;
                unsigned int v11 = v22 | (v11 << 16);
                int v31 = 4;
                goto LABEL_89;
              }
              int v40 = result;
              uint64_t v41 = *(char *)(v5 + 75);
              int v42 = *(char *)(v5 + v41 + 76);
              LOBYTE(v93) = *(unsigned char *)(v5 + v41 + 76);
              if ((v41 + 1) == 8) {
                char v43 = 0;
              }
              else {
                char v43 = v41 + 1;
              }
              *(unsigned char *)(v5 + 75) = v43;
              unsigned int v13 = v94;
              *(_DWORD *)(v5 + 4 * v42 + 32) = v94;
              uint64_t result = sub_18C87389C(v5, v42);
              int v16 = v84;
              uint64_t v3 = v89;
              unint64_t v6 = v92;
              unsigned int v11 = ((v40 << 8) + 268304384) | (v42 << 21) | (v24 - v13) | 0xF1000080;
              int v31 = 4;
            }
            else
            {
              uint64_t v46 = v3;
              unsigned int v13 = *(_DWORD *)(v5 + 4 * v23 + 32);
              LOBYTE(v93) = v23;
              int v47 = v16;
              uint64_t result = sub_18C87389C(v5, v23);
              int v16 = v47;
              uint64_t v3 = v46;
              unint64_t v6 = v92;
              unsigned int v11 = v25 | (v24 - v13);
              int v31 = 2;
            }
            uint64_t v10 = 1;
            goto LABEL_89;
          }
          LOBYTE(v10) = 0;
          goto LABEL_184;
        }
LABEL_178:
        LOBYTE(v10) = 0;
LABEL_179:
        uint64_t v77 = v87;
        goto LABEL_187;
      }
      if ((unint64_t)v3 >= v6) {
        goto LABEL_178;
      }
      if (v8 < 1)
      {
        LOBYTE(v10) = 0;
        goto LABEL_174;
      }
      unint64_t v37 = 0;
      int v38 = v2 + 1;
      while (1)
      {
        unsigned int v11 = v3[v37 / 2];
        if ((v11 - 13312) >> 10 > 0x28) {
          break;
        }
        if (v8 < 2)
        {
          LOBYTE(v10) = 0;
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v37 + 2);
          v7 += v37;
          int v8 = 1;
          int v31 = 2;
          goto LABEL_161;
        }
        char v39 = &v7[v37];
        *char v39 = BYTE1(v11);
        v39[1] = v11;
        if (v9)
        {
          *uint64_t v9 = v12;
          v9[1] = v12;
          v9 += 2;
        }
        if ((unint64_t)&v3[v37 / 2 + 1] >= v6)
        {
          LOBYTE(v10) = 0;
          unsigned int v11 = 0;
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v37 + 2);
          v7 += v37 + 2;
          goto LABEL_179;
        }
        v37 += 2;
        ++v38;
        int v12 = ++v2;
        BOOL v14 = v8 < 3;
        v8 -= 2;
        if (v14)
        {
          LOBYTE(v10) = 0;
          unsigned int v11 = 0;
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v37);
          v7 += v37;
          goto LABEL_174;
        }
      }
      int v44 = &v3[v37 / 2 + 1];
      int v45 = &v7[v37];
      if ((v11 - 13312) >> 8 < 0xBF)
      {
        if (v11 >> 13 <= 6)
        {
          if ((v11 & 0x400) != 0)
          {
            LOBYTE(v10) = 0;
            uint64_t v3 = (unsigned __int16 *)((char *)v3 + v37 + 2);
            v7 += v37;
LABEL_184:
            int v79 = 12;
            goto LABEL_185;
          }
          uint64_t v3 = (unsigned __int16 *)((char *)v3 + v37 + 2);
          v7 += v37;
          int v16 = v12;
          int v2 = v38;
          goto LABEL_24;
        }
        uint64_t v10 = 0;
        v11 |= 0xF00000u;
        int v31 = 3;
      }
      else if ((unint64_t)v44 >= v6 || (*v44 - 13312) >> 10 >= 0x29)
      {
        if (v11 - 48 >= 0xA && v11 - 97 >= 0x1A && v11 - 65 >= 0x1A)
        {
          uint64_t v50 = 0;
          int v51 = 57472;
          while (v11 - *(_DWORD *)(v5 + 4 * v50 + 32) >= 0x80)
          {
            ++v50;
            v51 += 256;
            if (v50 == 8) {
              goto LABEL_102;
            }
          }
          if ((v50 & 0x80) != 0)
          {
LABEL_102:
            uint64_t result = sub_18C873914(v11, &v94);
            if ((result & 0x80000000) != 0)
            {
              uint64_t v10 = 0;
              int v31 = 2;
              uint64_t v3 = v44;
              int v7 = v45;
              int v16 = v12;
              int v12 = v38;
              unint64_t v6 = v92;
            }
            else
            {
              int v52 = result;
              uint64_t v53 = *(char *)(v5 + 75);
              unsigned __int8 v54 = *(unsigned char *)(v5 + v53 + 76);
              LODWORD(v93) = v54;
              if ((v53 + 1) == 8) {
                char v55 = 0;
              }
              else {
                char v55 = v53 + 1;
              }
              *(unsigned char *)(v5 + 75) = v55;
              unsigned int v13 = v94;
              *(_DWORD *)(v5 + 4 * v54 + 32) = v94;
              uint64_t result = sub_18C87389C(v5, v54);
              unint64_t v6 = v92;
              unsigned int v11 = ((v93 << 16) + 15204352) | (v52 << 8) | (v11 - v13) | 0x80;
              int v31 = 3;
              uint64_t v10 = 1;
              uint64_t v3 = v44;
              int v7 = v45;
              int v16 = v12;
              int v12 = v38;
            }
            goto LABEL_89;
          }
          unsigned int v13 = *(_DWORD *)(v5 + 4 * v50 + 32);
          LOBYTE(v93) = v50;
          uint64_t result = sub_18C87389C(v5, v50);
          unint64_t v6 = v92;
          unsigned int v11 = v51 | (v11 - v13);
        }
        else
        {
          v11 |= (v93 << 8) + 57344;
        }
        int v31 = 2;
        uint64_t v10 = 1;
      }
      else
      {
        uint64_t v10 = 0;
        int v31 = 2;
      }
      uint64_t v3 = v44;
      int v7 = v45;
      int v16 = v12;
      int v12 = v38;
      goto LABEL_89;
    }
    int v16 = v12;
    if (v15) {
      goto LABEL_13;
    }
    while (1)
    {
      if ((unint64_t)v3 >= v6) {
        goto LABEL_179;
      }
      if (v8 < 1) {
        goto LABEL_174;
      }
      unsigned int v56 = *v3++;
      unsigned int v11 = v56;
      int v12 = v2 + 1;
      if (v56 - 32 <= 0x5F) {
        goto LABEL_113;
      }
      if (v11 > 0x1F) {
        break;
      }
      if (((1 << v11) & 0x2601) == 0)
      {
        v11 |= 0x100u;
        goto LABEL_121;
      }
LABEL_113:
      *int v7 = v11;
      if (v9) {
        goto LABEL_17;
      }
LABEL_114:
      uint64_t result = 0;
LABEL_115:
      unsigned int v11 = 0;
      ++v7;
      --v8;
      uint64_t v9 = (int *)result;
      int v16 = v12;
      int v2 = v12;
    }
    char v19 = v11 - v13;
    if (v11 - v13 <= 0x7F)
    {
LABEL_16:
      *int v7 = v19 | 0x80;
      if (!v9) {
        goto LABEL_114;
      }
LABEL_17:
      *uint64_t v9 = v16;
      uint64_t result = (uint64_t)(v9 + 1);
      goto LABEL_115;
    }
    if ((v11 & 0xF800) != 0xD800)
    {
      if (v11 > 0x9F)
      {
        if (v11 == 65279 || v11 >> 4 > 0xFFE)
        {
          v11 |= 0xE0000u;
          int v31 = 3;
        }
        else
        {
          uint64_t v57 = 0;
          int v58 = 4224;
          while (v11 - *(_DWORD *)(v5 + 4 * v57 + 32) >= 0x80)
          {
            ++v57;
            v58 += 256;
            if (v57 == 8) {
              goto LABEL_135;
            }
          }
          if ((v57 & 0x80) != 0)
          {
LABEL_135:
            uint64_t v63 = 0;
            int v61 = 256;
            while (v11 - dword_18CA81360[v63] >= 0x80)
            {
              ++v63;
              v61 += 256;
              if (v63 == 8) {
                goto LABEL_142;
              }
            }
            if ((v63 & 0x80) == 0)
            {
              int v62 = v11 - dword_18CA81360[v63];
              goto LABEL_141;
            }
LABEL_142:
            unsigned int v82 = v10;
            int v85 = v16;
            uint64_t v64 = v3;
            uint64_t result = sub_18C873914(v11, &v94);
            if ((result & 0x80000000) != 0)
            {
              unint64_t v6 = v92;
              uint64_t v3 = v64;
              if ((v11 - 13312) >> 10 > 0x28
                || (unint64_t)v64 < v92 && (*v64 - 13312) >> 10 > 0x28)
              {
                v11 |= 0xE0000u;
                int v31 = 3;
                uint64_t v10 = v82;
              }
              else
              {
                uint64_t v10 = 0;
                v11 |= 0xF0000u;
                int v31 = 3;
              }
              int v16 = v85;
            }
            else
            {
              int v65 = result;
              uint64_t v66 = *(char *)(v5 + 75);
              unsigned __int8 v67 = *(unsigned char *)(v5 + v66 + 76);
              int v68 = v67;
              if ((v66 + 1) == 8) {
                char v69 = 0;
              }
              else {
                char v69 = v66 + 1;
              }
              *(unsigned char *)(v5 + 75) = v69;
              unsigned int v13 = v94;
              *(_DWORD *)(v5 + 4 * v67 + 32) = v94;
              uint64_t result = sub_18C87389C(v5, v67);
              LOBYTE(v93) = v68;
              unsigned int v11 = ((v68 << 16) + 1572864) | (v65 << 8) | (v11 - v13) | 0x80;
              int v31 = 3;
              unint64_t v6 = v92;
              uint64_t v10 = v82;
              int v16 = v85;
              uint64_t v3 = v64;
            }
            goto LABEL_89;
          }
          if ((unint64_t)v3 >= v6
            || (v59 = *(_DWORD *)(v5 + 4 * v57 + 32), unsigned int v60 = *v3, v59 + 127 >= v60)
            && (v59 <= v60 || v60 <= 0x7F && (v60 > 0x1F || ((1 << v60) & 0x2601) != 0)))
          {
            unsigned int v90 = *(_DWORD *)(v5 + 4 * v57 + 32);
            int v70 = v3;
            uint64_t v71 = v10;
            int v72 = v16;
            LOBYTE(v93) = v57;
            uint64_t result = sub_18C87389C(v5, v57);
            int v16 = v72;
            uint64_t v3 = v70;
            unsigned int v13 = v90;
            uint64_t v10 = v71;
            unint64_t v6 = v92;
            unsigned int v11 = v58 | (v11 - v90);
            int v31 = 2;
            goto LABEL_89;
          }
          int v61 = v11 - v59;
          int v62 = ((char)v57 << 8) + 384;
LABEL_141:
          unsigned int v11 = v62 | v61;
LABEL_121:
          int v31 = 2;
        }
      }
      else
      {
        int v31 = 2;
        unsigned int v11 = v11 & 0x7F | 0x200;
      }
      goto LABEL_89;
    }
    if ((v11 & 0x400) != 0) {
      goto LABEL_184;
    }
    int v2 = v12;
LABEL_13:
    unsigned int v81 = v10;
    int v83 = v16;
    unsigned int v80 = v7;
    if ((unint64_t)v3 >= v6) {
      goto LABEL_179;
    }
    int v17 = *v3;
    if ((v17 & 0xFC00) != 0xDC00) {
      goto LABEL_184;
    }
    ++v3;
    int v12 = v2 + 1;
    int v18 = (v11 << 10) - 56613888 + v17;
    char v19 = v17 - v13;
    if (v18 - v13 < 0x80) {
      goto LABEL_16;
    }
    uint64_t v20 = 0;
    int v21 = 4224;
    while ((v18 - *(_DWORD *)(v5 + 4 * v20 + 32)) >= 0x80)
    {
      ++v20;
      v21 += 256;
      if (v20 == 8) {
        goto LABEL_32;
      }
    }
    if ((v20 & 0x80) == 0)
    {
      int v26 = v3;
      unsigned int v13 = *(_DWORD *)(v5 + 4 * v20 + 32);
      uint64_t v27 = v5;
      LOBYTE(v93) = v20;
      uint64_t v28 = v10;
      uint64_t v29 = v5;
      int v30 = v16;
      uint64_t result = sub_18C87389C(v27, v20);
      int v16 = v30;
      uint64_t v5 = v29;
      uint64_t v3 = v26;
      int v7 = v80;
      uint64_t v10 = v28;
      unint64_t v6 = v92;
      unsigned int v11 = v21 | (v18 - v13);
      int v31 = 2;
      goto LABEL_89;
    }
LABEL_32:
    long long v88 = v3;
    uint64_t result = sub_18C873914((v11 << 10) - 56613888 + v17, &v94);
    if ((result & 0x80000000) != 0)
    {
      *v7++ = 15;
      if (v9)
      {
        int v16 = v83;
        *v9++ = v83;
        unint64_t v6 = v92;
        uint64_t v3 = v88;
      }
      else
      {
        unint64_t v6 = v92;
        uint64_t v3 = v88;
        int v16 = v83;
      }
      uint64_t v10 = 0;
      --v8;
      int v31 = 4;
      unsigned int v11 = v17 | (v11 << 16);
    }
    else
    {
      int v32 = result;
      uint64_t v33 = *(char *)(v5 + 75);
      unsigned __int8 v34 = *(unsigned char *)(v5 + v33 + 76);
      int v35 = v34;
      char v36 = (v33 + 1) == 8 ? 0 : v33 + 1;
      *(unsigned char *)(v5 + 75) = v36;
      unsigned int v13 = v94;
      *(_DWORD *)(v5 + 4 * v34 + 32) = v94;
      uint64_t result = sub_18C87389C(v5, v34);
      LOBYTE(v93) = v35;
      unsigned int v11 = ((v32 << 8) - 0x20000) | (v35 << 21) | (v18 - v13) | 0xB000080;
      int v31 = 4;
      unint64_t v6 = v92;
      uint64_t v10 = v81;
      int v16 = v83;
      uint64_t v3 = v88;
    }
LABEL_89:
    if (v8 < v31) {
      break;
    }
    if (v9)
    {
      if (v31 != 2)
      {
        if (v31 != 3)
        {
          *v7++ = HIBYTE(v11);
          *v9++ = v16;
        }
        *v7++ = BYTE2(v11);
        *v9++ = v16;
      }
      *int v7 = BYTE1(v11);
      *uint64_t v9 = v16;
      v7[1] = v11;
      v7 += 2;
      v9[1] = v16;
      v9 += 2;
    }
    else
    {
      if (v31 != 2)
      {
        if (v31 != 3) {
          *v7++ = HIBYTE(v11);
        }
        *v7++ = BYTE2(v11);
      }
      uint64_t v9 = 0;
      *(_WORD *)int v7 = bswap32(v11) >> 16;
      v7 += 2;
    }
    unsigned int v11 = 0;
    v8 -= v31;
    int v2 = v12;
  }
  int v12 = v16;
LABEL_161:
  int v73 = v31 - v8;
  uint64_t v74 = (unsigned char *)(v91 + 104);
  switch(v73)
  {
    case 1:
      goto LABEL_165;
    case 2:
      goto LABEL_164;
    case 3:
      goto LABEL_163;
    case 4:
      uint64_t v74 = (unsigned char *)(v91 + 105);
      *(unsigned char *)(v91 + 104) = HIBYTE(v11);
LABEL_163:
      *v74++ = BYTE2(v11);
LABEL_164:
      *v74++ = BYTE1(v11);
LABEL_165:
      *uint64_t v74 = v11;
      break;
    default:
      break;
  }
  *(unsigned char *)(v91 + 91) = v73;
  unsigned int v75 = v11 >> (8 * v73);
  if (v8 == 1)
  {
    *v7++ = v75;
    if (!v9) {
      goto LABEL_173;
    }
    unsigned int v78 = a2;
    uint64_t v77 = v87;
LABEL_177:
    unsigned int v11 = 0;
    *v9++ = v12;
    goto LABEL_182;
  }
  if (v8 == 2)
  {
    *int v7 = BYTE1(v75);
    int v76 = v7 + 1;
    unsigned int v78 = a2;
    uint64_t v77 = v87;
    if (!v9) {
      goto LABEL_181;
    }
LABEL_176:
    *v9++ = v12;
    *int v76 = v75;
    int v7 = v76 + 1;
    goto LABEL_177;
  }
  if (v8 != 3)
  {
LABEL_173:
    unsigned int v11 = 0;
LABEL_174:
    int v79 = 15;
LABEL_185:
    unsigned int v78 = a2;
    uint64_t v77 = v87;
    goto LABEL_186;
  }
  *int v7 = BYTE2(v75);
  if (v9)
  {
    *v9++ = v12;
    v7[1] = BYTE1(v75);
    int v76 = v7 + 2;
    unsigned int v78 = a2;
    uint64_t v77 = v87;
    goto LABEL_176;
  }
  v7[1] = BYTE1(v75);
  int v76 = v7 + 2;
  unsigned int v78 = a2;
  uint64_t v77 = v87;
LABEL_181:
  uint64_t v9 = 0;
  unsigned int v11 = 0;
  *int v76 = v75;
  int v7 = v76 + 1;
LABEL_182:
  int v79 = 15;
LABEL_186:
  *unsigned int v78 = v79;
LABEL_187:
  *(unsigned char *)(v5 + 72) = v10;
  *(unsigned char *)(v5 + 73) = v93;
  *(_DWORD *)(v91 + 84) = v11;
  v77[2] = v3;
  v77[4] = v7;
  v77[6] = v9;
  return result;
}

const char *sub_18C873810(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(a1 + 16) + 74) == 1) {
    return "SCSU,locale=ja";
  }
  else {
    return "SCSU";
  }
}

uint64_t sub_18C873834(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (*a3)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    long long v5 = *(_OWORD *)(v4 + 16);
    *(_OWORD *)(a2 + 288) = *(_OWORD *)v4;
    *(_OWORD *)(a2 + 304) = v5;
    long long v6 = *(_OWORD *)(v4 + 32);
    long long v7 = *(_OWORD *)(v4 + 48);
    long long v8 = *(_OWORD *)(v4 + 64);
    *(_DWORD *)(a2 + 368) = *(_DWORD *)(v4 + 80);
    *(_OWORD *)(a2 + 336) = v7;
    *(_OWORD *)(a2 + 352) = v8;
    *(_OWORD *)(a2 + 320) = v6;
    *(void *)(a2 + 16) = a2 + 288;
    *(unsigned char *)(a2 + 62) = 1;
  }
  else
  {
    a2 = 0;
    *a3 = 376;
  }
  return a2;
}

uint64_t sub_18C87389C(uint64_t result, unsigned __int8 a2)
{
  int v2 = *(char *)(result + 75);
  do
  {
    BOOL v3 = __OFSUB__(v2--, 1);
    if (v2 < 0 != v3) {
      int v2 = 7;
    }
  }
  while (*(unsigned __int8 *)(result + v2 + 76) != a2);
  if (v2 == 7) {
    int v4 = 0;
  }
  else {
    int v4 = v2 + 1;
  }
  while (v4 != *(char *)(result + 75))
  {
    int v5 = v2;
    int v2 = v4;
    *(unsigned char *)(result + 76 + v5) = *(unsigned char *)(result + 76 + v4);
    if (v4 == 7) {
      int v4 = 0;
    }
    else {
      ++v4;
    }
  }
  *(unsigned char *)(result + v2 + 76) = a2;
  return result;
}

uint64_t sub_18C873914(unsigned int a1, unsigned int *a2)
{
  for (uint64_t i = 0; i != 7; ++i)
  {
    unsigned int v3 = dword_18CA81380[i];
    if (a1 - v3 <= 0x7F)
    {
      *a2 = v3;
      return (i + 249);
    }
  }
  if (a1 < 0x80) {
    return 0xFFFFFFFFLL;
  }
  if (a1 - 118784 < 0x3000 || a1 >> 10 < 0xD || (a1 & 0xFFFFC000) == 0x10000)
  {
    *a2 = a1 & 0x7FFFFF80;
    return a1 >> 7;
  }
  else
  {
    uint64_t v4 = 0xFFFFFFFFLL;
    if (a1 != 65279 && (a1 - 57344) >> 4 <= 0x1FE)
    {
      *a2 = a1 & 0x7FFFFF80;
      return (a1 - 44032) >> 7;
    }
  }
  return v4;
}

uint64_t ucnvsel_open(uint64_t a1, int a2, icu::UnicodeSet *a3, unsigned int a4, int *a5)
{
  if (*a5 > 0) {
    return 0;
  }
  int v7 = a2;
  if (a2 < 0 || (uint64_t v10 = a1) == 0 && a2)
  {
    uint64_t v5 = 0;
    int v11 = 1;
LABEL_7:
    *a5 = v11;
    return v5;
  }
  unsigned int v13 = uprv_malloc(0x38uLL);
  uint64_t v5 = (uint64_t)v13;
  if (!v13)
  {
    int v11 = 7;
    goto LABEL_7;
  }
  v13[6] = 0;
  *((_OWORD *)v13 + 1) = 0u;
  *((_OWORD *)v13 + 2) = 0u;
  *(_OWORD *)unsigned int v13 = 0u;
  if (!v7)
  {
    int v7 = ucnv_countAvailable();
    uint64_t v10 = 0;
  }
  BOOL v14 = uprv_malloc(8 * v7);
  *(void *)(v5 + 24) = v14;
  if (!v14) {
    goto LABEL_41;
  }
  *BOOL v14 = 0;
  if (v7 < 1)
  {
    int v16 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    int v16 = 0;
    do
    {
      if (v10) {
        AvailableName = *(const char **)(v10 + 8 * v15);
      }
      else {
        AvailableName = (const char *)ucnv_getAvailableName(v15);
      }
      v16 += strlen(AvailableName) + 1;
      ++v15;
    }
    while (v7 != v15);
  }
  int v30 = v16 & 3;
  int v18 = (v16 & 3) != 0 ? 4 - (v16 & 3) : 0;
  int v19 = v18 + v16;
  *(_DWORD *)(v5 + 36) = v19;
  uint64_t v20 = (char *)uprv_malloc(v19);
  if (!v20)
  {
LABEL_41:
    *a5 = 7;
LABEL_42:
    ucnvsel_close(v5);
    return 0;
  }
  int v21 = v20;
  int v29 = 4 - (v16 & 3);
  if (v7 >= 1)
  {
    uint64_t v22 = 0;
    uint64_t v23 = *(void *)(v5 + 24);
    do
    {
      *(void *)(v23 + 8 * v22) = v21;
      unsigned int v24 = *(char **)(*(void *)(v5 + 24) + 8 * v22);
      if (v10) {
        int v25 = *(const char **)(v10 + 8 * v22);
      }
      else {
        int v25 = (const char *)ucnv_getAvailableName(v22);
      }
      strcpy(v24, v25);
      uint64_t v23 = *(void *)(v5 + 24);
      v21 += strlen(*(const char **)(v23 + 8 * v22++)) + 1;
    }
    while (v7 != v22);
  }
  if (v30)
  {
    if (v29 >= 1) {
      int v26 = 1;
    }
    else {
      int v26 = v29;
    }
    bzero(v21, (v29 - v26) + 1);
  }
  *(unsigned char *)(v5 + 49) = 1;
  *(_DWORD *)(v5 + 32) = v7;
  int v27 = v7 + 31;
  if (v7 < -31) {
    int v27 = v7 + 62;
  }
  uint64_t v28 = (void **)upvec_open(v27 >> 5, a5);
  sub_18C873C04(v5, (uint64_t)v28, a3, a4, a5);
  upvec_close(v28);
  if (*a5 >= 1) {
    goto LABEL_42;
  }
  return v5;
}

void sub_18C873C04(uint64_t a1, uint64_t a2, icu::UnicodeSet *a3, unsigned int a4, int *a5)
{
  if (*a5 <= 0)
  {
    uint64_t v8 = a1;
    int v9 = *(_DWORD *)(a1 + 32);
    int v10 = v9 + 31;
    if (v9 < -31) {
      int v10 = v9 + 62;
    }
    int v26 = v10 >> 5;
    if (v9 < 1) {
      goto LABEL_20;
    }
    int v11 = 0;
    int v12 = v26 <= 1 ? 1 : v10 >> 5;
    do
      upvec_setValue(a2, 1114113, 1114113, v11++, -1, -1, a5);
    while (v12 != v11);
    if (*(int *)(v8 + 32) < 1)
    {
LABEL_20:
      if (a3)
      {
        int ItemCount = uset_getItemCount(a3);
        if (ItemCount >= 1)
        {
          int v22 = ItemCount;
          int v23 = 0;
          if (v26 <= 1) {
            int v24 = 1;
          }
          else {
            int v24 = v26;
          }
          do
          {
            uint64_t v31 = 0;
            uset_getItem(a3, v23, (_DWORD *)&v31 + 1, &v31, 0, 0, a5);
            if (v9 >= 1)
            {
              for (int i = 0; i != v24; ++i)
                upvec_setValue(a2, SHIDWORD(v31), v31, i, -1, -1, a5);
            }
            ++v23;
          }
          while (v23 != v22);
        }
      }
      *(void *)uint64_t v8 = upvec_compactToUTrie2WithRowIndexes(a2, a5);
      *(void *)(v8 + 8) = upvec_cloneArray(a2, (_DWORD *)(v8 + 16), 0, a5);
      *(_DWORD *)(v8 + 16) *= v26;
      *(unsigned char *)(v8 + 48) = 1;
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v28 = v8;
      int v27 = v9;
      while (1)
      {
        BOOL v14 = ucnv_open(*(unsigned __int8 **)(*(void *)(v8 + 24) + 8 * v13), (UErrorCode *)a5);
        if (*a5 > 0) {
          break;
        }
        uint64_t v15 = v14;
        int v16 = uset_open(1, 0);
        ucnv_getUnicodeSet((uint64_t)v15, (uint64_t)v16, a4, a5);
        if (*a5 >= 1)
        {
          ucnv_close(v15);
          return;
        }
        int v17 = a3;
        int v18 = uset_getItemCount(v16);
        if (v18 >= 1)
        {
          int v19 = v18;
          for (int j = 0; j != v19; ++j)
          {
            uint64_t v31 = 0;
            int v30 = 0;
            uset_getItem(v16, j, (_DWORD *)&v31 + 1, &v31, 0, 0, &v30);
            if (v30 <= 0) {
              upvec_setValue(a2, SHIDWORD(v31), v31, v13 >> 5, -1, 1 << v13, a5);
            }
          }
        }
        ucnv_close(v15);
        uset_close(v16);
        a3 = v17;
        uint64_t v8 = v28;
        int v9 = v27;
        if (*a5 >= 1) {
          return;
        }
        if (++v13 >= *(int *)(v28 + 32)) {
          goto LABEL_20;
        }
      }
    }
  }
}

void ucnvsel_close(uint64_t a1)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 49)) {
      uprv_free(**(void ***)(a1 + 24));
    }
    uprv_free(*(void **)(a1 + 24));
    if (*(unsigned char *)(a1 + 48)) {
      uprv_free(*(void **)(a1 + 8));
    }
    utrie2_close(*(void *)a1);
    uprv_free(*(void **)(a1 + 40));
    uprv_free((void *)a1);
  }
}

uint64_t ucnvsel_serialize(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (a3 < 0 || a3 && (!a2 || (a2 & 3) != 0))
  {
    uint64_t v4 = 0;
    int v13 = 1;
LABEL_12:
    *a4 = v13;
    return v4;
  }
  int v9 = utrie2_serialize(*(void *)a1, 0, 0, a4);
  int v10 = v9;
  if (*a4 == 15 || (uint64_t v4 = 0, *a4 <= 0))
  {
    *a4 = 0;
    int v11 = *(_DWORD *)(a1 + 16);
    int v12 = *(_DWORD *)(a1 + 36);
    uint64_t v4 = (v9 + 4 * v11 + v12 + 96);
    if ((int)v4 <= a3)
    {
      int v15 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)a2 = 668598304;
      *(_DWORD *)(a2 + 20) = 0;
      *(_OWORD *)(a2 + 4) = xmmword_18CA8139C;
      *(void *)(a2 + 24) = 0;
      *(_DWORD *)(a2 + 32) = v9;
      *(_DWORD *)(a2 + 36) = v11;
      *(_DWORD *)(a2 + 40) = v15;
      *(_DWORD *)(a2 + 44) = v12;
      *(_OWORD *)(a2 + 48) = 0u;
      *(_OWORD *)(a2 + 64) = 0u;
      *(_OWORD *)(a2 + 76) = 0u;
      *(_DWORD *)(a2 + 92) = v9 + 4 * v11 + v12 + 64;
      int v16 = (char *)(a2 + 96);
      utrie2_serialize(*(void *)a1, v16, v9, a4);
      int v17 = &v16[v10];
      uint64_t v18 = *(int *)(a1 + 16);
      memcpy(v17, *(const void **)(a1 + 8), 4 * v18);
      memcpy(&v17[4 * v18], **(const void ***)(a1 + 24), *(int *)(a1 + 36));
      return v4;
    }
    int v13 = 15;
    goto LABEL_12;
  }
  return v4;
}

_OWORD *ucnvsel_openFromSerialized(unsigned __int16 *a1, uint64_t a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  uint64_t v5 = a1;
  if (!a1 || (int)a2 < 1 || (a1 & 3) != 0)
  {
    unsigned int v3 = 0;
    int v7 = 1;
    goto LABEL_21;
  }
  if (a2 <= 0x1F)
  {
LABEL_7:
    unsigned int v3 = 0;
    int v7 = 8;
LABEL_21:
    *a3 = v7;
    return v3;
  }
  if (*((unsigned __int8 *)a1 + 2) != 218
    || *((unsigned char *)a1 + 3) != 39
    || *((unsigned char *)a1 + 12) != 67
    || *((unsigned char *)a1 + 13) != 83
    || *((unsigned char *)a1 + 14) != 101
    || *((unsigned char *)a1 + 15) != 108)
  {
    unsigned int v3 = 0;
    int v7 = 3;
    goto LABEL_21;
  }
  if (*((unsigned char *)a1 + 16) != 1)
  {
    unsigned int v3 = 0;
    int v7 = 16;
    goto LABEL_21;
  }
  if (*((unsigned char *)a1 + 8) || *((unsigned char *)a1 + 9))
  {
    uint64_t v8 = udata_openSwapperForInputData(a1, a2, 0, 0, a3);
    int v12 = sub_18C874388((uint64_t)v8, (uint64_t)v5, 0xFFFFFFFFLL, 0, a3, v9, v10, v11);
    if (*a3 >= 1)
    {
      udata_closeSwapper(v8);
      return 0;
    }
    if (v12 > (int)a2)
    {
      udata_closeSwapper(v8);
      goto LABEL_7;
    }
    BOOL v14 = (unsigned __int16 *)uprv_malloc(v12);
    if (!v14)
    {
      udata_closeSwapper(v8);
LABEL_40:
      unsigned int v3 = 0;
      int v7 = 7;
      goto LABEL_21;
    }
    uint64_t v18 = (uint64_t)v5;
    uint64_t v5 = v14;
    sub_18C874388((uint64_t)v8, v18, a2, v14, a3, v15, v16, v17);
    udata_closeSwapper(v8);
    if (*a3 >= 1)
    {
      uprv_free(v5);
      return 0;
    }
    int v19 = v5;
  }
  else
  {
    int v19 = 0;
  }
  int v20 = *v5;
  if (v20 + 64 > a2 || (v30 = v19, int v21 = (int *)((char *)v5 + *v5), (int)a2 - v20 < v21[15]))
  {
    uprv_free(v19);
    goto LABEL_7;
  }
  unsigned int v3 = uprv_malloc(0x38uLL);
  int v22 = uprv_malloc(8 * v21[2]);
  int v23 = v22;
  if (!v3 || !v22)
  {
    uprv_free(v30);
    uprv_free(v3);
    uprv_free(v23);
    goto LABEL_40;
  }
  v3[1] = 0u;
  v3[2] = 0u;
  *unsigned int v3 = 0u;
  int v24 = *v21;
  *((_DWORD *)v3 + 4) = v21[1];
  *((void *)v3 + 3) = v22;
  *((void *)v3 + 4) = *((void *)v21 + 1);
  *((void *)v3 + 5) = v30;
  *((void *)v3 + 6) = 0;
  *(void *)unsigned int v3 = utrie2_openFromSerialized(0, (uint64_t)(v21 + 16), v24, 0, a3);
  if (*a3 >= 1)
  {
    ucnvsel_close((uint64_t)v3);
    return 0;
  }
  uint64_t v25 = (uint64_t)v21 + *v21 + 64;
  *((void *)v3 + 1) = v25;
  uint64_t v26 = *((unsigned int *)v3 + 8);
  if ((int)v26 >= 1)
  {
    uint64_t v27 = 0;
    uint64_t v28 = (const char *)(v25 + 4 * *((int *)v3 + 4));
    uint64_t v29 = 8 * v26;
    do
    {
      *(void *)(*((void *)v3 + 3) + v27) = v28;
      v28 += strlen(v28) + 1;
      v27 += 8;
    }
    while (v29 != v27);
  }
  return v3;
}

uint64_t sub_18C874388(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (*a5 > 0) {
    return 0;
  }
  uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x5300000043
    || *(unsigned char *)(a2 + 14) != 101
    || *(unsigned char *)(a2 + 15) != 108)
  {
    udata_printError(a1, (uint64_t)"ucnvsel_swap(): data format %02x.%02x.%02x.%02x is not recognized as UConverterSelector data\n", v14, v15, v16, v17, v18, v19, v21);
    uint64_t result = 0;
    int v24 = 3;
LABEL_11:
    *a5 = v24;
    return result;
  }
  if (*(unsigned char *)(a2 + 16) != 1)
  {
    udata_printError(a1, (uint64_t)"ucnvsel_swap(): format version %02x is not supported\n", v14, v15, v16, v17, v18, v19, *(unsigned __int8 *)(a2 + 16));
    uint64_t result = 0;
    int v24 = 16;
    goto LABEL_11;
  }
  int v22 = v13;
  if (v10 < 0)
  {
    uint64_t v23 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v23 = (v10 - v13);
    if ((int)v23 <= 63)
    {
      udata_printError(a1, (uint64_t)"ucnvsel_swap(): too few bytes (%d after header) for UConverterSelector data\n", v14, v15, v16, v17, v18, v19, (v10 - v13));
LABEL_19:
      uint64_t result = 0;
      int v24 = 8;
      goto LABEL_11;
    }
  }
  uint64_t v25 = 0;
  uint64_t v26 = v13;
  *(_OWORD *)size_t __n = 0u;
  uint64_t v27 = a2 + v13;
  memset(v39, 0, sizeof(v39));
  do
  {
    *(_DWORD *)((char *)v39 + v25) = udata_readInt32(a1, *(unsigned int *)(v27 + v25));
    v25 += 4;
  }
  while (v25 != 64);
  int v34 = HIDWORD(__n[1]);
  if ((v23 & 0x80000000) == 0)
  {
    if ((int)v23 < SHIDWORD(__n[1]))
    {
      udata_printError(a1, (uint64_t)"ucnvsel_swap(): too few bytes (%d after header) for all of UConverterSelector data\n", v28, v29, v30, v31, v32, v33, v23);
      goto LABEL_19;
    }
    int v35 = (char *)a4 + v22;
    if ((unsigned __int16 *)a2 != a4) {
      memcpy((char *)a4 + v26, (const void *)(a2 + v22), SHIDWORD(__n[1]));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 56))(a1, a2 + v22, 64, (char *)a4 + v26, a5);
    uint64_t v36 = SLODWORD(v39[0]);
    utrie2_swap(a1, (unsigned __int16 *)(v27 + 64), v39[0], (uint64_t)(v35 + 64), a5);
    uint64_t v37 = v36 + 64;
    uint64_t v38 = 4 * SDWORD1(v39[0]);
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 56))(a1, v27 + v37, v38, &v35[v37], a5);
    (*(void (**)(uint64_t, uint64_t, void, char *, int *))(a1 + 72))(a1, v27 + v38 + (int)v37, HIDWORD(v39[0]), &v35[v38 + (int)v37], a5);
  }
  return (v34 + v22);
}

void *ucnvsel_selectForString(uint64_t a1, unsigned __int16 *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (!a1 || (int v7 = a2) == 0 && a3)
  {
    int v8 = 1;
LABEL_6:
    *a4 = v8;
    return 0;
  }
  int v10 = *(_DWORD *)(a1 + 32);
  int v11 = v10 + 31;
  if (v10 < -31) {
    int v11 = v10 + 62;
  }
  uint64_t v12 = (v11 >> 5);
  int v13 = (__int32 *)uprv_malloc(4 * (int)v12);
  if (!v13)
  {
    int v8 = 7;
    goto LABEL_6;
  }
  uint64_t v14 = v13;
  memset(v13, 255, 4 * (int)v12);
  if (v7)
  {
    uint64_t v15 = &v7[a3];
    while (1)
    {
      if (a3 < 0)
      {
        unsigned int v16 = *v7;
        if (!*v7) {
          break;
        }
      }
      else
      {
        if (v7 == v15) {
          break;
        }
        unsigned int v16 = *v7;
      }
      uint64_t v17 = v7 + 1;
      if ((v16 & 0xFC00) == 0xD800)
      {
        if (a3 < 0 || v15 != v17)
        {
          int v21 = *v17;
          uint64_t v18 = *(uint64_t **)a1;
          if ((v21 & 0xFC00) == 0xDC00)
          {
            unsigned int v22 = v21 + (v16 << 10) - 56613888;
            uint64_t v23 = *v18;
            if ((signed int)v22 >= *((_DWORD *)v18 + 11)) {
              int v24 = *((_DWORD *)v18 + 12);
            }
            else {
              int v24 = (v21 & 0x1F)
            }
                  + 4
                  * *(unsigned __int16 *)(v23
                                        + 2
                                        * (((v22 >> 5) & 0x3F) + *(unsigned __int16 *)(v23 + 2 * ((v22 >> 11) + 2080))));
            uint64_t v17 = v7 + 2;
            uint64_t v25 = (unsigned __int16 *)(v23 + 2 * v24);
            goto LABEL_27;
          }
        }
        else
        {
          uint64_t v18 = *(uint64_t **)a1;
        }
        uint64_t v19 = *v18;
        unsigned int v20 = (v16 >> 5) + 320;
      }
      else
      {
        uint64_t v19 = **(void **)a1;
        unsigned int v20 = v16 >> 5;
      }
      uint64_t v25 = (unsigned __int16 *)(v19 + 2 * ((v16 & 0x1F) + 4 * *(unsigned __int16 *)(v19 + 2 * v20)));
LABEL_27:
      if (v10 >= 1)
      {
        int v26 = 0;
        uint64_t v27 = (int *)(*(void *)(a1 + 8) + 4 * *v25);
        uint64_t v28 = v14;
        uint64_t v29 = v12;
        do
        {
          int v30 = *v27++;
          int v31 = *v28 & v30;
          *v28++ = v31;
          v26 |= v31;
          --v29;
        }
        while (v29);
        int v7 = v17;
        if (v26) {
          continue;
        }
      }
      break;
    }
  }

  return sub_18C8747F0(a1, v14, a4);
}

void *sub_18C8747F0(uint64_t a1, __int32 *a2, _DWORD *a3)
{
  long long v6 = (__int16 *)uprv_malloc(0x18uLL);
  int v7 = v6;
  if (v6)
  {
    *(void *)long long v6 = 0;
    *((_DWORD *)v6 + 2) = 0;
    *((void *)v6 + 2) = a1;
    int v8 = uprv_malloc(0x38uLL);
    uint64_t v9 = v8;
    if (v8)
    {
      long long v10 = *(_OWORD *)&off_1EDA46F98;
      *int v8 = xmmword_1EDA46F88;
      v8[1] = v10;
      v11.i32[1] = DWORD1(xmmword_1EDA46FA8);
      void v8[2] = xmmword_1EDA46FA8;
      *((void *)v8 + 6) = off_1EDA46FB8;
      int v12 = *(_DWORD *)(a1 + 32);
      int v13 = v12 + 31;
      if (v12 < -31) {
        int v13 = v12 + 62;
      }
      if (v12 >= 1)
      {
        unsigned __int16 v14 = 0;
        uint64_t v15 = (v13 >> 5);
        unsigned int v16 = a2;
        uint64_t v17 = v15;
        do
        {
          __int32 v19 = *v16++;
          __int32 v18 = v19;
          if (v19)
          {
            v11.i32[0] = v18;
            int8x8_t v11 = vcnt_s8(v11);
            v14 += vaddlv_u8((uint8x8_t)v11);
          }
          --v17;
        }
        while (v17);
        if ((__int16)v14 >= 1)
        {
          unsigned int v20 = uprv_malloc(2 * v14);
          *(void *)int v7 = v20;
          if (!v20)
          {
            *a3 = 7;
            int v8 = v9;
            uint64_t v9 = 0;
            goto LABEL_25;
          }
          uint64_t v21 = 0;
          __int16 v22 = 0;
          int v23 = *(_DWORD *)(a1 + 32);
          if ((int)v15 <= 1) {
            uint64_t v24 = 1;
          }
          else {
            uint64_t v24 = v15;
          }
          do
          {
            unsigned int v25 = a2[v21];
            int v26 = 32;
            do
            {
              if (v23 <= v22) {
                break;
              }
              if (v25)
              {
                uint64_t v27 = v7[4];
                v7[4] = v27 + 1;
                v20[v27] = v22;
              }
              v25 >>= 1;
              ++v22;
              --v26;
            }
            while (v26);
            ++v21;
          }
          while (v21 != v24);
        }
      }
      int v8 = 0;
      v9[1] = v7;
      int v7 = 0;
    }
    else
    {
      *a3 = 7;
    }
LABEL_25:
    uprv_free(v8);
    goto LABEL_26;
  }
  uint64_t v9 = 0;
  *a3 = 7;
LABEL_26:
  uprv_free(v7);
  uprv_free(a2);
  return v9;
}

void *ucnvsel_selectForUTF8(_DWORD *a1, char *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (!a1 || (v6 = a3, (int v7 = a2) == 0) && a3)
  {
    int v8 = 1;
LABEL_6:
    *a4 = v8;
    return 0;
  }
  int v10 = a1[8];
  int v11 = v10 + 31;
  if (v10 < -31) {
    int v11 = v10 + 62;
  }
  uint64_t v12 = (v11 >> 5);
  int v13 = (__int32 *)uprv_malloc(4 * (int)v12);
  if (!v13)
  {
    int v8 = 7;
    goto LABEL_6;
  }
  unsigned __int16 v14 = v13;
  memset(v13, 255, 4 * (int)v12);
  if (v6 < 0) {
    int v6 = strlen(v7);
  }
  if (v7)
  {
    unint64_t v15 = (unint64_t)&v7[v6];
    while (v7 != (char *)v15)
    {
      uint64_t v17 = v7 + 1;
      int v16 = *v7;
      uint64_t v18 = *v7;
      if ((v16 & 0x80000000) == 0)
      {
        __int32 v19 = (unsigned __int16 *)(*(void *)(*(void *)a1 + 8) + 2 * v18);
        ++v7;
        goto LABEL_30;
      }
      UChar32 v20 = *v7;
      if ((v18 & 0xF0) == 0xE0)
      {
        if (unint64_t)(v7 + 2) < v15 && ((a00000000000000[v18 & 0xF] >> (*v17 >> 5)))
        {
          unsigned int v21 = v7[2] ^ 0x80;
          if (v21 <= 0x3F)
          {
            v7 += 3;
            __int32 v19 = (unsigned __int16 *)(**(void **)a1
                                     + 2
                                     * ((v21 & 0x1F)
                                      + 4
                                      * *(unsigned __int16 *)(**(void **)a1
                                                            + 2
                                                            * (((2 * (*v17 & 0x3F)) | (v20 << 7)) + (v21 >> 5) - 28672))));
            goto LABEL_30;
          }
        }
      }
      else if ((v16 + 62) <= 0x1Du && (unint64_t)v17 < v15)
      {
        uint64_t v23 = *v17 ^ 0x80;
        if (v23 <= 0x3F)
        {
          v7 += 2;
          __int32 v19 = (unsigned __int16 *)(**(void **)a1
                                   + 2 * (*(unsigned __int16 *)(**(void **)a1 + 2 * v18 + 3776) + v23));
          goto LABEL_30;
        }
      }
      int Index = utrie2_internalU8NextIndex(*(uint64_t **)a1, v20, (uint8_t *)v7 + 1, v15);
      int v7 = &v17[Index & 7];
      __int32 v19 = (unsigned __int16 *)(**(void **)a1 + 2 * (Index >> 3));
LABEL_30:
      if (v10 >= 1)
      {
        int v25 = 0;
        int v26 = (int *)(*((void *)a1 + 1) + 4 * *v19);
        uint64_t v27 = v14;
        uint64_t v28 = v12;
        do
        {
          int v29 = *v26++;
          int v30 = *v27 & v29;
          *v27++ = v30;
          v25 |= v30;
          --v28;
        }
        while (v28);
        if (v25) {
          continue;
        }
      }
      break;
    }
  }

  return sub_18C8747F0((uint64_t)a1, v14, a4);
}

void sub_18C874BD8(void ***a1)
{
  uprv_free(*a1[1]);
  uprv_free(a1[1]);

  uprv_free(a1);
}

uint64_t sub_18C874C20(uint64_t a1, int *a2)
{
  if (*a2 <= 0) {
    return *(__int16 *)(*(void *)(a1 + 8) + 8);
  }
  else {
    return 0;
  }
}

const char *sub_18C874C40(uint64_t a1, _DWORD *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(__int16 *)(v3 + 10);
  if (v4 >= *(__int16 *)(v3 + 8)) {
    return 0;
  }
  uint64_t v5 = *(const char **)(*(void *)(*(void *)(v3 + 16) + 24)
                      + 8 * *(__int16 *)(*(void *)v3 + 2 * *(__int16 *)(v3 + 10)));
  *(_WORD *)(v3 + 10) = v4 + 1;
  if (a2) {
    *a2 = strlen(v5);
  }
  return v5;
}

uint64_t sub_18C874CBC(uint64_t result, int *a2)
{
  if (*a2 <= 0) {
    *(_WORD *)(*(void *)(result + 8) + 10) = 0;
  }
  return result;
}

BOOL ucol_looksLikeCollationBinary(unsigned __int8 *a1, unsigned __int16 *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL result = 0;
  if (a1 && a2 && a3 >= -1)
  {
    int v12 = 0;
    udata_swapDataHeader((uint64_t)a1, a2, 0xFFFFFFFFLL, 0, &v12, a6, a7, a8);
    if (v12 <= 0
      && *((unsigned char *)a2 + 12) == 85
      && *((unsigned char *)a2 + 13) == 67
      && *((unsigned char *)a2 + 14) == 111
      && *((unsigned char *)a2 + 15) == 108)
    {
      return 1;
    }
    if (a3 < 0)
    {
      udata_readInt32((uint64_t)a1, *(unsigned int *)a2);
    }
    else if (a3 < 0xA8 || (int)udata_readInt32((uint64_t)a1, *(unsigned int *)a2) > a3)
    {
      return 0;
    }
    if ((*((unsigned int (**)(void))a1 + 2))(*((unsigned int *)a2 + 4)) == 537069080
      && *((unsigned char *)a2 + 80) == 3
      && *((unsigned __int8 *)a2 + 65) == *a1)
    {
      return *((unsigned __int8 *)a2 + 66) == a1[1];
    }
    return 0;
  }
  return result;
}

uint64_t ucol_swap(unsigned __int8 *a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a5 > 0) {
    return 0;
  }
  int v14 = udata_swapDataHeader((uint64_t)a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (*a5 < 1)
  {
    uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
    if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) == 0x4300000055
      && *(unsigned char *)(a2 + 14) == 111
      && *(unsigned char *)(a2 + 15) == 108
      && (unsigned int v22 = *(unsigned __int8 *)(a2 + 16), v22 - 3 < 3))
    {
      int v23 = v14;
      uint64_t v24 = (unsigned int *)(a2 + v14);
      if ((int)a3 >= 0) {
        int v25 = v14;
      }
      else {
        int v25 = 0;
      }
      uint64_t v26 = (a3 - v25);
      if (a4) {
        uint64_t v27 = (unsigned int *)((char *)a4 + v14);
      }
      else {
        uint64_t v27 = 0;
      }
      if (v22 < 4) {
        int v28 = sub_18C874F80(a1, v24, v26, (uint64_t)v27, a5, v18, v19, v20);
      }
      else {
        int v28 = sub_18C875404((uint64_t)a1, v24, v26, v27, a5, v18, v19, v20);
      }
      if (*a5 <= 0) {
        return (v28 + v23);
      }
      else {
        return 0;
      }
    }
    else
    {
      udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not recognized as collation data\n", v15, v16, v17, v18, v19, v20, v21);
      uint64_t result = 0;
      *a5 = 16;
    }
  }
  else
  {
    *a5 = 0;
    return sub_18C874F80(a1, (unsigned int *)a2, a3, (uint64_t)a4, a5, v18, v19, v20);
  }
  return result;
}

uint64_t sub_18C874F80(unsigned __int8 *a1, unsigned int *a2, uint64_t a3, uint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a5 > 0) {
    return 0;
  }
  if (!a1 || !a2 || (int)a3 < -1 || (int)a3 >= 1 && !a4)
  {
    uint64_t Int32 = 0;
    int v14 = 1;
LABEL_9:
    *a5 = v14;
    return Int32;
  }
  if ((a3 & 0x80000000) != 0)
  {
    uint64_t Int32 = udata_readInt32((uint64_t)a1, *a2);
  }
  else if (a3 < 0xA8 || (uint64_t Int32 = udata_readInt32((uint64_t)a1, *a2), (int)Int32 > (int)a3))
  {
    udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(formatVersion=3): too few bytes (%d after header) for collation data\n", a3, a4, (uint64_t)a5, a6, a7, a8, a3);
    uint64_t Int32 = 0;
    int v14 = 8;
    goto LABEL_9;
  }
  uint64_t v16 = (*((uint64_t (**)(void))a1 + 2))(a2[4]);
  if (v16 != 537069080 || *((unsigned char *)a2 + 80) != 3)
  {
    udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(formatVersion=3): magic 0x%08x or format version %02x.%02x is not a collation binary\n", v17, v18, v19, v20, v21, v22, v16);
    uint64_t Int32 = 0;
    int v14 = 16;
    goto LABEL_9;
  }
  int v23 = *((unsigned __int8 *)a2 + 65);
  if (v23 != *a1 || *((unsigned __int8 *)a2 + 66) != a1[1])
  {
    udata_printError((uint64_t)a1, (uint64_t)"ucol_swap(formatVersion=3): endianness %d or charset %d does not match the swapper\n", v17, v18, v19, v20, v21, v22, (char)v23);
    uint64_t Int32 = 0;
    int v14 = 3;
    goto LABEL_9;
  }
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 != (unsigned int *)a4) {
      memcpy((void *)a4, a2, (int)Int32);
    }
    unsigned int v24 = (*((uint64_t (**)(void))a1 + 2))(a2[1]);
    unsigned int v41 = (*((uint64_t (**)(void))a1 + 2))(a2[2]);
    unsigned int v42 = (*((uint64_t (**)(void))a1 + 2))(a2[3]);
    unsigned int v25 = (*((uint64_t (**)(void))a1 + 2))(a2[5]);
    unsigned int v26 = (*((uint64_t (**)(void))a1 + 2))(a2[6]);
    unsigned int v43 = (*((uint64_t (**)(void))a1 + 2))(a2[7]);
    unsigned int v35 = (*((uint64_t (**)(void))a1 + 2))(a2[8]);
    int v27 = (*((uint64_t (**)(void))a1 + 2))(a2[9]);
    unsigned int v37 = (*((uint64_t (**)(void))a1 + 2))(a2[10]);
    (*((void (**)(void))a1 + 2))(a2[11]);
    int v36 = udata_readInt32((uint64_t)a1, a2[12]);
    int v38 = udata_readInt32((uint64_t)a1, a2[15]);
    unsigned int v39 = (*((uint64_t (**)(void))a1 + 2))(a2[21]);
    unsigned int v40 = (*((uint64_t (**)(void))a1 + 2))(a2[22]);
    (*((void (**)(unsigned __int8 *, unsigned int *, uint64_t, uint64_t, int *))a1 + 7))(a1, a2, 64, a4, a5);
    (*((void (**)(unsigned __int8 *, unsigned int *, uint64_t, uint64_t, int *))a1 + 7))(a1, a2 + 21, 8, a4 + 84, a5);
    *(_WORD *)(a4 + 65) = *((_WORD *)a1 + 1);
    if (v24) {
      (*((void (**)(unsigned __int8 *, char *, void, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v24, v26 - v24, a4 + v24, a5);
    }
    if (v25 && v26)
    {
      unsigned int v28 = v43;
      if (!v43) {
        unsigned int v28 = v25;
      }
      (*((void (**)(unsigned __int8 *, char *, void, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v26, v28 - v26, a4 + v26, a5);
    }
    if (v27)
    {
      (*((void (**)(unsigned __int8 *, char *, void, uint64_t, int *))a1 + 6))(a1, (char *)a2 + v43, (2 * v27), a4 + v43, a5);
      (*((void (**)(unsigned __int8 *, char *, void, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v35, (4 * v27), a4 + v35, a5);
    }
    if (v25) {
      utrie_swap((uint64_t)a1, (unsigned int *)((char *)a2 + v25), v37 - v25, a4 + v25, a5);
    }
    if (v36) {
      (*((void (**)(unsigned __int8 *, char *, void, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v37, (4 * v36), a4 + v37, a5);
    }
    if (v41) {
      (*((void (**)(unsigned __int8 *, char *, void, uint64_t, int *))a1 + 7))(a1, (char *)a2 + v41, v42 - v41, a4 + v41, a5);
    }
    if (v38) {
      (*((void (**)(unsigned __int8 *, char *, void, uint64_t, int *))a1 + 6))(a1, (char *)a2 + v42, 2 * v38 * *((unsigned __int8 *)a2 + 67), a4 + v42, a5);
    }
    if (v39)
    {
      int v29 = (unsigned __int16 *)((char *)a2 + v39);
      int v30 = (*((uint64_t (**)(void))a1 + 1))(*v29);
      int v31 = (*((uint64_t (**)(void))a1 + 1))(v29[1]);
      (*((void (**)(unsigned __int8 *, unsigned __int16 *, void, uint64_t, int *))a1 + 6))(a1, v29, (4 * v30 + 2 * v31 + 4), a4 + v39, a5);
    }
    if (v40)
    {
      uint64_t v32 = (unsigned __int16 *)((char *)a2 + v40);
      int v33 = (*((uint64_t (**)(void))a1 + 1))(*v32);
      int v34 = (*((uint64_t (**)(void))a1 + 1))(v32[1]);
      (*((void (**)(unsigned __int8 *, unsigned __int16 *, void, uint64_t, int *))a1 + 6))(a1, v32, (2 * (v34 + v33) + 4), a4 + v40, a5);
    }
  }
  return Int32;
}

uint64_t sub_18C875404(uint64_t a1, unsigned int *a2, uint64_t a3, unsigned int *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (*a5 > 0) {
    return 0;
  }
  memset(v44, 0, sizeof(v44));
  long long v43 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  if (a3 <= 7) {
    goto LABEL_18;
  }
  int Int32 = udata_readInt32(a1, *a2);
  int v15 = Int32;
  int v40 = Int32;
  uint64_t v16 = (4 * Int32);
  if ((a3 & 0x80000000) == 0 && (int)v16 > (int)a3) {
    goto LABEL_18;
  }
  unint64_t v17 = (Int32 - 2);
  if (Int32 < 2) {
    goto LABEL_12;
  }
  uint64_t v18 = &v41;
  uint64_t v19 = a2 + 1;
  if (v17 >= 0x12) {
    unint64_t v17 = 18;
  }
  unint64_t v20 = v17 + 1;
  do
  {
    unsigned int v21 = *v19++;
    *(_DWORD *)uint64_t v18 = udata_readInt32(a1, v21);
    uint64_t v18 = (long long *)((char *)v18 + 4);
    --v20;
  }
  while (v20);
  if (v15 >= 20)
  {
    uint64_t v22 = 19;
  }
  else
  {
LABEL_12:
    memset(&v40 + v15, 255, 4 * (19 - v15) + 4);
    uint64_t v8 = v16;
    if (v15 < 6) {
      goto LABEL_16;
    }
    uint64_t v22 = (v15 - 1);
  }
  uint64_t v8 = *(&v40 + v22);
LABEL_16:
  if ((a3 & 0x80000000) != 0) {
    return v8;
  }
  if ((int)v8 > (int)a3)
  {
LABEL_18:
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): too few bytes (%d after header) for collation data\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, a3);
    int v23 = 8;
LABEL_19:
    uint64_t v8 = 0;
    *a5 = v23;
    return v8;
  }
  if (a2 != a4) {
    memcpy(a4, a2, (int)v8);
  }
  (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, a2, v16, a4, a5);
  if (DWORD1(v42) - (int)v42 >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 56))(a1, (char *)a2 + (int)v42);
  }
  int v30 = HIDWORD(v42);
  uint64_t v31 = (HIDWORD(v42) - DWORD2(v42));
  if ((int)v31 >= 1) {
    utrie2_swap(a1, (unsigned __int16 *)((char *)a2 + SDWORD2(v42)), v31, (uint64_t)a4 + SDWORD2(v42), a5);
  }
  if ((int)v43 - v30 >= 1)
  {
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): unknown data at IX_RESERVED8_OFFSET\n", v31, v25, v26, v27, v28, v29, (v43 - v30));
LABEL_47:
    int v23 = 16;
    goto LABEL_19;
  }
  int v32 = DWORD1(v43);
  uint64_t v33 = (DWORD1(v43) - v43);
  if ((int)v33 >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 64))(a1, (char *)a2 + (int)v43);
  }
  if (DWORD2(v43) - v32 >= 1)
  {
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): unknown data at IX_RESERVED10_OFFSET\n", v33, v25, v26, v27, v28, v29, (DWORD2(v43) - v32));
    goto LABEL_47;
  }
  uint64_t v34 = SHIDWORD(v43);
  if (HIDWORD(v43) - DWORD2(v43) >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 56))(a1, (char *)a2 + SDWORD2(v43));
  }
  uint64_t v35 = v44[0];
  if (v44[0] - (int)v34 >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 56))(a1, (char *)a2 + v34);
  }
  uint64_t v36 = v44[1];
  if (v44[1] - (int)v35 >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v35);
  }
  uint64_t v37 = v44[2];
  if (v44[2] - (int)v36 >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v36);
  }
  uint64_t v38 = v44[3];
  if (v44[3] - (int)v37 >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v37);
  }
  uint64_t v39 = (v44[4] - v38);
  if ((int)v39 >= 1) {
    (*(void (**)(uint64_t, char *))(a1 + 48))(a1, (char *)a2 + v38);
  }
  if (v44[6] - v44[5] >= 1)
  {
    udata_printError(a1, (uint64_t)"ucol_swap(formatVersion=4): unknown data at IX_RESERVED18_OFFSET\n", v39, v25, v26, v27, v28, v29, (v44[6] - v44[5]));
    goto LABEL_47;
  }
  return v8;
}

uint64_t ucol_swapInverseUCA(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0;
  }
  uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x6E00000049
    || *(unsigned char *)(a2 + 14) != 118
    || *(unsigned char *)(a2 + 15) != 67
    || *(unsigned char *)(a2 + 16) != 2
    || !*(unsigned char *)(a2 + 17))
  {
    udata_printError(a1, (uint64_t)"ucol_swapInverseUCA(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not an inverse UCA collation file\n", v14, v15, v16, v17, v18, v19, v21);
    uint64_t result = 0;
    int v26 = 16;
    goto LABEL_14;
  }
  int v22 = v13;
  int v23 = (unsigned int *)(a2 + v13);
  if ((a3 & 0x80000000) != 0)
  {
    int Int32 = udata_readInt32(a1, *v23);
  }
  else
  {
    unsigned int v24 = a3 - v13;
    if ((int)a3 - v13 < 32 || (unsigned int v25 = udata_readInt32(a1, *v23), v24 < v25))
    {
      udata_printError(a1, (uint64_t)"ucol_swapInverseUCA(): too few bytes (%d after header) for inverse UCA collation data\n", v14, v15, v16, v17, v18, v19, a3);
      uint64_t result = 0;
      int v26 = 8;
LABEL_14:
      *a5 = v26;
      return result;
    }
    int Int32 = v25;
    uint64_t v28 = (char *)a4 + v22;
    if ((unsigned __int16 *)a2 != a4) {
      memcpy((char *)a4 + v22, v23, v25);
    }
    int v29 = (*(uint64_t (**)(void))(a1 + 16))(v23[1]);
    int v30 = (*(uint64_t (**)(void))(a1 + 16))(v23[2]);
    unsigned int v31 = (*(uint64_t (**)(void))(a1 + 16))(v23[3]);
    unsigned int v32 = (*(uint64_t (**)(void))(a1 + 16))(v23[4]);
    (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 56))(a1, v23, 20, v28, a5);
    (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 56))(a1, (char *)v23 + v31, (12 * v29), &v28[v31], a5);
    (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 48))(a1, (char *)v23 + v32, (2 * v30), &v28[v32], a5);
  }
  return (Int32 + v22);
}

_DWORD *ucptrie_openFromBinary(int a1, int a2, uint64_t a3, int a4, int *a5, int *a6)
{
  if (*a6 > 0) {
    return 0;
  }
  if (a4 < 1 || (a2 - 3) < 0xFFFFFFFC || (a1 - 2) < 0xFFFFFFFD || (a3 & 3) != 0)
  {
    uint64_t result = 0;
    int v19 = 1;
LABEL_31:
    *a6 = v19;
    return result;
  }
  if (a4 <= 0xF) {
    goto LABEL_30;
  }
  if (*(_DWORD *)a3 != 1416784179) {
    goto LABEL_30;
  }
  unsigned int v9 = *(unsigned __int16 *)(a3 + 4);
  if ((v9 & 0x38) != 0) {
    goto LABEL_30;
  }
  unsigned int v10 = v9 & 7;
  if (v10 > 2) {
    goto LABEL_30;
  }
  unsigned int v11 = v9 >> 6;
  if (v11 >= 2) {
    goto LABEL_30;
  }
  BOOL v12 = a1 < 0 || v11 == a1;
  BOOL v13 = v12;
  BOOL v14 = v10 == a2 || a2 <= -1;
  if (!v14 || !v13) {
    goto LABEL_30;
  }
  unsigned int v16 = *(unsigned __int16 *)(a3 + 6);
  unsigned int v17 = *(unsigned __int16 *)(a3 + 8) | ((unsigned __int16)v9 >> 12 << 16);
  if (v10 == 1)
  {
    int v18 = 4 * v17;
  }
  else
  {
    int v18 = *(unsigned __int16 *)(a3 + 8) | ((unsigned __int16)v9 >> 12 << 16);
    if ((v9 & 7) == 0) {
      int v18 = 2 * v17;
    }
  }
  if (2 * v16 + 16 + v18 > a4)
  {
LABEL_30:
    uint64_t result = 0;
    int v19 = 3;
    goto LABEL_31;
  }
  int v26 = 2 * v16 + 16 + v18;
  int v20 = *(unsigned __int16 *)(a3 + 12);
  int v21 = *(unsigned __int16 *)(a3 + 14);
  __int16 v27 = *(_WORD *)(a3 + 10);
  uint64_t result = uprv_malloc(0x30uLL);
  if (!result)
  {
    int v19 = 7;
    goto LABEL_31;
  }
  result[5] = v17;
  result[6] = v21 << 9;
  result[4] = v16;
  *((_WORD *)result + 14) = ((v21 << 9) + 4095) >> 12;
  unsigned int v22 = v20 & 0xFFF0FFFF | (((v9 >> 8) & 0xF) << 16);
  *((unsigned char *)result + 30) = v11;
  *((unsigned char *)result + 31) = v10;
  result[8] = 0;
  *((_WORD *)result + 18) = 0;
  *((_WORD *)result + 19) = v27;
  *((void *)result + 5) = v22;
  uint64_t v23 = a3 + 16 + 2 * v16;
  signed int v24 = v17 - 2;
  if (v22 < v17) {
    signed int v24 = v22;
  }
  *(void *)uint64_t result = a3 + 16;
  *((void *)result + 1) = 0;
  if (v10 == 2)
  {
    *((void *)result + 1) = v23;
    int v25 = *(unsigned __int8 *)(v23 + v24);
  }
  else if (v10 == 1)
  {
    *((void *)result + 1) = v23;
    int v25 = *(_DWORD *)(v23 + 4 * v24);
  }
  else
  {
    if ((v9 & 7) != 0) {
      goto LABEL_30;
    }
    *((void *)result + 1) = v23;
    int v25 = *(unsigned __int16 *)(v23 + 2 * v24);
  }
  result[11] = v25;
  if (a5) {
    *a5 = v26;
  }
  return result;
}

uint64_t ucptrie_getType(uint64_t a1)
{
  return *(char *)(a1 + 30);
}

uint64_t ucptrie_getValueWidth(uint64_t a1)
{
  return *(char *)(a1 + 31);
}

uint64_t ucptrie_internalSmallIndex(uint64_t *a1, unsigned int a2)
{
  if (*((unsigned char *)a1 + 30)) {
    int v2 = 64;
  }
  else {
    int v2 = 1020;
  }
  int v3 = v2 + ((int)a2 >> 14);
  uint64_t v4 = *a1;
  int v5 = *(__int16 *)(*a1 + 2 * (((a2 >> 9) & 0x1F) + *(unsigned __int16 *)(*a1 + 2 * v3)));
  int v6 = *(unsigned __int16 *)(*a1 + 2 * (((a2 >> 9) & 0x1F) + *(unsigned __int16 *)(*a1 + 2 * v3)));
  unsigned int v7 = (a2 >> 4) & 0x1F;
  if (v5 < 0)
  {
    unsigned int v9 = ((a2 >> 4) & 0x18 | (v7 >> 3)) + (v6 & 0x7FFF);
    int v8 = (*(unsigned __int16 *)(v4 + 2 * v9) << (2 * ((a2 >> 4) & 7) + 2)) & 0x30000 | *(unsigned __int16 *)(v4 + 2 * (((a2 >> 4) & 7) + v9 + 1));
  }
  else
  {
    int v8 = *(unsigned __int16 *)(v4 + 2 * (v7 + v6));
  }
  return v8 + (a2 & 0xF);
}

uint64_t ucptrie_internalSmallU8Index(uint64_t a1, int a2, int a3, int a4)
{
  signed int v4 = (a3 << 6) | (a2 << 12) | a4;
  if (v4 >= *(_DWORD *)(a1 + 24)) {
    return (*(_DWORD *)(a1 + 20) - 2);
  }
  else {
    return ucptrie_internalSmallIndex((uint64_t *)a1, v4);
  }
}

uint64_t ucptrie_internalU8PrevIndex(uint64_t a1, UChar32 c, const uint8_t *a3, uint64_t a4)
{
  if (a4 - (uint64_t)a3 >= 8) {
    int32_t v5 = 7;
  }
  else {
    int32_t v5 = a4 - a3;
  }
  if (a4 - (uint64_t)a3 >= 8) {
    int v6 = (const uint8_t *)(a4 - 7);
  }
  else {
    int v6 = a3;
  }
  pint i = v5;
  unsigned int v7 = utf8_prevCharSafeBody(v6, 0, &pi, c, -1);
  int32_t v8 = v5 - pi;
  pint i = v8;
  if (HIWORD(v7))
  {
    if (HIWORD(v7) > 0x10u)
    {
      int v9 = *(_DWORD *)(a1 + 20) - 1;
    }
    else if ((signed int)v7 >= *(_DWORD *)(a1 + 24))
    {
      int v9 = *(_DWORD *)(a1 + 20) - 2;
    }
    else
    {
      int v9 = ucptrie_internalSmallIndex((uint64_t *)a1, v7);
    }
  }
  else
  {
    int v9 = (v7 & 0x3F) + *(unsigned __int16 *)(*(void *)a1 + 2 * (v7 >> 6));
  }
  return v8 | (8 * v9);
}

uint64_t ucptrie_get(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0x80)
  {
    if (*(unsigned char *)(a1 + 30)) {
      unsigned int v3 = 4095;
    }
    else {
      unsigned int v3 = 0xFFFF;
    }
    if (v3 >= a2)
    {
      a2 = (a2 & 0x3F) + *(unsigned __int16 *)(*(void *)a1 + 2 * (a2 >> 6));
    }
    else if (HIWORD(a2) > 0x10u)
    {
      a2 = *(_DWORD *)(a1 + 20) - 1;
    }
    else if (*(_DWORD *)(a1 + 24) <= (signed int)a2)
    {
      a2 = *(_DWORD *)(a1 + 20) - 2;
    }
    else
    {
      a2 = ucptrie_internalSmallIndex((uint64_t *)a1, a2);
    }
  }
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(char *)(a1 + 31);
  if (v5 == 2) {
    return *(unsigned __int8 *)(v4 + (int)a2);
  }
  if (v5 == 1) {
    return *(unsigned int *)(v4 + 4 * (int)a2);
  }
  if (*(unsigned char *)(a1 + 31)) {
    return 0xFFFFFFFFLL;
  }
  return *(unsigned __int16 *)(v4 + 2 * (int)a2);
}

uint64_t sub_18C875E1C(uint64_t (*a1)(uint64_t, uint64_t, uint64_t, uint64_t, int *), uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, int *a8)
{
  int v10 = a3;
  if (a4)
  {
    int v20 = 0;
    if (a8) {
      BOOL v13 = a8;
    }
    else {
      BOOL v13 = &v20;
    }
    if (a4 == 2) {
      uint64_t v14 = 57343;
    }
    else {
      uint64_t v14 = 56319;
    }
    uint64_t result = a1(a2, a3, a6, a7, v13);
    if ((int)v14 >= v10 && (int)result >= 55295)
    {
      if (*v13 == a5)
      {
        unsigned int v16 = a1;
        if (result >= v14) {
          return result;
        }
        goto LABEL_19;
      }
      unsigned int v16 = a1;
      if (v10 < 55296) {
        return 55295;
      }
      *BOOL v13 = a5;
      BOOL v17 = result > v14;
      uint64_t result = v14;
      if (!v17)
      {
LABEL_19:
        int v19 = 0;
        LODWORD(result) = v16(a2, (v14 + 1), a6, a7, &v19);
        if (v19 == a5) {
          return result;
        }
        else {
          return v14;
        }
      }
    }
  }
  else
  {
    return a1(a2, a3, a6, a7, a8);
  }
  return result;
}

uint64_t ucptrie_getRange(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, int *a7)
{
  return sub_18C875E1C((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, int *))sub_18C875FA0, a1, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_18C875FA0(uint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, _DWORD *a5)
{
  if (WORD1(a2) > 0x10u) {
    return 0xFFFFFFFFLL;
  }
  int v6 = a5;
  uint64_t v7 = a4;
  uint64_t v8 = a2;
  uint64_t v5 = 1114111;
  int v10 = *((char *)a1 + 31);
  if (*((_DWORD *)a1 + 6) <= (int)a2)
  {
    if (a5)
    {
      uint64_t v48 = *((int *)a1 + 5) - 2;
      uint64_t v49 = a1[1];
      if (v10 == 2)
      {
        uint64_t v50 = *(unsigned __int8 *)(v49 + v48);
      }
      else if (v10 == 1)
      {
        uint64_t v50 = *(unsigned int *)(v49 + 4 * (int)v48);
      }
      else if (*((unsigned char *)a1 + 31))
      {
        uint64_t v50 = 0xFFFFFFFFLL;
      }
      else
      {
        uint64_t v50 = *(unsigned __int16 *)(v49 + 2 * v48);
      }
      if (a3) {
        LODWORD(v50) = a3(a4, v50);
      }
      *int v6 = v50;
    }
    return v5;
  }
  uint64_t v11 = *((unsigned int *)a1 + 11);
  uint64_t v66 = a3;
  if (a3)
  {
    uint64_t v12 = a3(a4, v11);
    a3 = v66;
    uint64_t v11 = v12;
  }
  uint64_t v13 = 0;
  char v14 = 0;
  uint64_t v15 = *a1;
  uint64_t v16 = 0xFFFFFFFFLL;
  int v17 = -1;
  uint64_t v5 = v8;
  uint64_t v18 = v11;
  unsigned int v65 = v11;
  int v59 = v8;
  uint64_t v57 = v6;
  uint64_t v58 = *a1;
  while ((int)v5 >= 0x10000 || (int)v5 >= 4096 && *((unsigned char *)a1 + 30))
  {
    if (*((unsigned char *)a1 + 30)) {
      int v19 = 64;
    }
    else {
      int v19 = 1020;
    }
    uint64_t v20 = *(unsigned __int16 *)(*a1
                              + 2
                              * (((v5 >> 9) & 0x1F)
                               + *(unsigned __int16 *)(*a1 + 2 * (v19 + (v5 >> 14)))));
    if (v16 == v20 && (int)v5 - (int)v8 >= 512)
    {
      uint64_t v5 = (v5 + 512);
      uint64_t v20 = v16;
    }
    else
    {
      if (v20 != *((unsigned __int16 *)a1 + 19))
      {
        signed int v21 = (v5 >> 4) & 0x1F;
        int v22 = 16;
        unsigned int v56 = v20;
        uint64_t v23 = 32;
        goto LABEL_24;
      }
      if (v14)
      {
        if (v11 != v18) {
          return (v5 - 1);
        }
      }
      else
      {
        uint64_t v13 = *((unsigned int *)a1 + 11);
        if (v6) {
          *int v6 = v11;
        }
      }
      int v17 = *((_DWORD *)a1 + 10);
      uint64_t v5 = (v5 & 0xFFFFFE00) + 512;
      char v14 = 1;
      uint64_t v18 = v11;
    }
LABEL_86:
    uint64_t v16 = v20;
    if ((int)v5 >= *((_DWORD *)a1 + 6))
    {
      uint64_t v45 = *((int *)a1 + 5) - 2;
      uint64_t v46 = a1[1];
      if (v10 == 2)
      {
        int v47 = *(unsigned __int8 *)(v46 + v45);
      }
      else if (v10 == 1)
      {
        int v47 = *(_DWORD *)(v46 + 4 * (int)v45);
      }
      else if (v10)
      {
        int v47 = -1;
      }
      else
      {
        int v47 = *(unsigned __int16 *)(v46 + 2 * v45);
      }
      int v52 = *((_DWORD *)a1 + 11);
      if (v47 == v52) {
        int v53 = v11;
      }
      else {
        int v53 = v47;
      }
      if (a3 && v47 != v52)
      {
        int v54 = v18;
        int v53 = ((uint64_t (*)(uint64_t))a3)(v7);
        LODWORD(v18) = v54;
      }
      if (v53 == v18) {
        return 1114111;
      }
      else {
        return (v5 - 1);
      }
    }
  }
  unsigned int v56 = v16;
  LODWORD(v20) = 0;
  signed int v21 = (int)v5 >> 6;
  int v22 = 64;
  if (*((unsigned char *)a1 + 30)) {
    uint64_t v23 = 64;
  }
  else {
    uint64_t v23 = 1024;
  }
LABEL_24:
  int v24 = v20 & 0x7FFF;
  int v25 = v22 - 1;
  int v64 = -v22;
  uint64_t v26 = v21;
  uint64_t v27 = v20;
  uint64_t v62 = v23;
  int v63 = v22;
  int v61 = v24;
  uint64_t v60 = v20;
  while (1)
  {
    unsigned int v28 = v27 >> 15
        ? (*(unsigned __int16 *)(v15 + 2 * (int)((v26 & 0xFFFFFFF8) + v24 + ((int)v26 >> 3))) << (2 * (v26 & 7) + 2)) & 0x30000 | *(unsigned __int16 *)(v15 + 2 * (int)((v26 & 7) + (v26 & 0xFFFFFFF8) + v24 + ((int)v26 >> 3) + 1))
        : *(unsigned __int16 *)(v15 + 2 * (v26 + v27));
    if (v28 != v17 || (int)v5 - (int)v8 < v22) {
      break;
    }
    uint64_t v5 = (v5 + v22);
LABEL_81:
    if (++v26 >= v23)
    {
      uint64_t v20 = v56;
      goto LABEL_86;
    }
  }
  if (v28 == *((_DWORD *)a1 + 10))
  {
    if (v14)
    {
      if (v11 != v18) {
        return (v5 - 1);
      }
    }
    else
    {
      uint64_t v13 = *((unsigned int *)a1 + 11);
      if (v6) {
        *int v6 = v11;
      }
    }
    uint64_t v5 = (v5 + v22) & v64;
    char v14 = 1;
    int v17 = v28;
    uint64_t v18 = v11;
    goto LABEL_81;
  }
  unint64_t v30 = (v5 & v25) + (unint64_t)v28;
  uint64_t v31 = a1[1];
  if (v10 != 2)
  {
    if (v10 == 1)
    {
      uint64_t v32 = *(unsigned int *)(v31 + 4 * v30);
      if (v14) {
        goto LABEL_57;
      }
    }
    else if (v10)
    {
      uint64_t v32 = 0xFFFFFFFFLL;
      if (v14) {
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v32 = *(unsigned __int16 *)(v31 + 2 * v30);
      if (v14) {
        goto LABEL_57;
      }
    }
LABEL_48:
    int v33 = *((_DWORD *)a1 + 11);
    if (v32 == v33) {
      uint64_t v18 = v11;
    }
    else {
      uint64_t v18 = v32;
    }
    if (a3 && v32 != v33)
    {
      uint64_t v34 = v66(v7, v32);
      uint64_t v11 = v65;
      a3 = v66;
      uint64_t v18 = v34;
    }
    if (v6) {
      *int v6 = v18;
    }
    goto LABEL_63;
  }
  uint64_t v32 = *(unsigned __int8 *)(v31 + v30);
  if ((v14 & 1) == 0) {
    goto LABEL_48;
  }
LABEL_57:
  if (v32 == v13)
  {
    uint64_t v32 = v13;
  }
  else
  {
    if (!a3) {
      return (v5 - 1);
    }
    int v35 = v11;
    if (v32 != *((_DWORD *)a1 + 11))
    {
      uint64_t v36 = v7;
      uint64_t v55 = v7;
      uint64_t v37 = v18;
      int v35 = v66(v36, v32);
      uint64_t v18 = v37;
      uint64_t v7 = v55;
      uint64_t v11 = v65;
      a3 = v66;
    }
    if (v35 != v18) {
      return (v5 - 1);
    }
  }
LABEL_63:
  if (((v5 + 1) & v25) == 0)
  {
    char v14 = 1;
    int v17 = v28;
    uint64_t v5 = (v5 + 1);
    uint64_t v13 = v32;
LABEL_80:
    LODWORD(v8) = v59;
    uint64_t v15 = v58;
    uint64_t v23 = v62;
    int v22 = v63;
    int v24 = v61;
    uint64_t v27 = v60;
    goto LABEL_81;
  }
  uint64_t v38 = v7;
  uint64_t v39 = v30 + 1;
  while (1)
  {
    uint64_t v40 = a1[1];
    if (v10 == 2)
    {
      uint64_t v41 = *(unsigned __int8 *)(v40 + v39);
    }
    else if (v10 == 1)
    {
      uint64_t v41 = *(unsigned int *)(v40 + 4 * v39);
    }
    else
    {
      uint64_t v41 = v10 ? 0xFFFFFFFFLL : *(unsigned __int16 *)(v40 + 2 * v39);
    }
    if (v41 != v32)
    {
      if (!a3) {
        return v5;
      }
      int v42 = v11;
      if (v41 != *((_DWORD *)a1 + 11))
      {
        uint64_t v43 = v18;
        int v42 = v66(v38, v41);
        uint64_t v18 = v43;
        uint64_t v11 = v65;
        a3 = v66;
      }
      uint64_t v32 = v41;
      if (v42 != v18) {
        return v5;
      }
    }
    int v44 = v5 + 2;
    ++v39;
    uint64_t v5 = (v5 + 1);
    if ((v44 & v25) == 0)
    {
      uint64_t v5 = (v5 + 1);
      char v14 = 1;
      int v17 = v28;
      uint64_t v13 = v32;
      uint64_t v7 = v38;
      int v6 = v57;
      goto LABEL_80;
    }
  }
}

uint64_t ucptrie_toBinary(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (a3 < 0
    || (unsigned int v6 = *(unsigned __int8 *)(a1 + 30), v6 > 1)
    || (int v7 = *(char *)(a1 + 31), v7 < 0)
    || v7 > 2
    || a3 && (!a2 || (a2 & 3) != 0))
  {
    uint64_t v4 = 0;
    int v9 = 1;
  }
  else
  {
    uint64_t v8 = *(int *)(a1 + 16);
    uint64_t v4 = (2 * v8 + 16);
    if (v7 == 2)
    {
      uint64_t v4 = (*(_DWORD *)(a1 + 20) + v4);
    }
    else if (v7 == 1)
    {
      uint64_t v4 = (v4 + 4 * *(_DWORD *)(a1 + 20));
    }
    else if (!*(unsigned char *)(a1 + 31))
    {
      uint64_t v4 = (2 * (*(_DWORD *)(a1 + 20) + v8) + 16);
    }
    if ((int)v4 <= a3)
    {
      *(_DWORD *)a2 = 1416784179;
      unsigned int v11 = *(_DWORD *)(a1 + 20);
      unsigned int v12 = *(_DWORD *)(a1 + 24);
      unsigned int v13 = *(_DWORD *)(a1 + 40);
      *(_WORD *)(a2 + 4) = (v11 >> 4) & 0xF000 | ((_WORD)v6 << 6) | (v13 >> 8) & 0xF00 | v7;
      *(_WORD *)(a2 + 6) = v8;
      *(_WORD *)(a2 + 8) = v11;
      *(_WORD *)(a2 + 10) = *(_WORD *)(a1 + 38);
      *(_WORD *)(a2 + 12) = v13;
      *(_WORD *)(a2 + 14) = v12 >> 9;
      uint64_t v14 = a2 + 16;
      memcpy((void *)(a2 + 16), *(const void **)a1, 2 * v8);
      if (v7 == 2)
      {
        uint64_t v15 = *(const void **)(a1 + 8);
        size_t v16 = *(int *)(a1 + 20);
      }
      else if (v7 == 1)
      {
        uint64_t v15 = *(const void **)(a1 + 8);
        size_t v16 = 4 * *(int *)(a1 + 20);
      }
      else
      {
        if (v7) {
          return v4;
        }
        uint64_t v15 = *(const void **)(a1 + 8);
        size_t v16 = 2 * *(int *)(a1 + 20);
      }
      memcpy((void *)(v14 + 2 * *(int *)(a1 + 16)), v15, v16);
      return v4;
    }
    int v9 = 15;
  }
  *a4 = v9;
  return v4;
}

UChar32 ucpmap_getRange(const UCPMap *map, UChar32 start, UCPMapRangeOption option, uint32_t surrogateValue, UCPMapValueFilter *filter, const void *context, uint32_t *pValue)
{
  return sub_18C875E1C((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, int *))sub_18C875FA0, (uint64_t)map, *(uint64_t *)&start, option, surrogateValue, (uint64_t)filter, (uint64_t)context, (int *)pValue);
}

uint64_t sub_18C876678(uint64_t a1)
{
  uint64_t v2 = uhash_get(**(void **)a1, *(void *)(a1 + 16));
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    unsigned int v5 = *(unsigned __int16 *)(v2 + 8);
    if (v5)
    {
      if (*(_WORD *)(v4 + 8)) {
        return 0;
      }
    }
    else
    {
      if ((v5 & 0x8000) != 0) {
        int v6 = *(_DWORD *)(v2 + 12);
      }
      else {
        int v6 = v5 >> 5;
      }
      unsigned int v7 = *(unsigned __int16 *)(v4 + 8);
      if ((v7 & 0x8000u) == 0) {
        unsigned int v8 = v7 >> 5;
      }
      else {
        unsigned int v8 = *(_DWORD *)(v4 + 12);
      }
      if ((v7 & 1) == 0
        && v6 == v8
        && icu::UnicodeString::doEquals((icu::UnicodeString *)v2, (const icu::UnicodeString *)v4, v6))
      {
        return 0;
      }
    }
    *(void *)(a1 + 16) = v3;
  }
  return v3;
}

uint64_t ucurr_forLocale(char *a1, UChar *a2, uint64_t a3, int *a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (*a4 > 0) {
    return 0;
  }
  if ((a3 & 0x80000000) != 0 || !a2 && a3)
  {
    uint64_t v4 = 0;
    *a4 = 1;
    return v4;
  }
  int v29 = 0;
  uint64_t v41 = 0;
  memset(&v40[1], 0, 48);
  v40[0] = (char *)&v40[1] + 5;
  LODWORD(v40[1]) = 40;
  memset(__s, 0, sizeof(__s));
  icu::CharStringByteSink::CharStringByteSink(__s, (uint64_t)v40);
  ulocimp_getKeywordValue(a1, "currency", (uint64_t)__s, &v29);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__s);
  unsigned int v28 = v41;
  if (v29 > 0 || v41 != 3 || !uprv_isInvariantString((unsigned __int8 *)v40[0], 3))
  {
    long long v38 = 0u;
    memset(v39, 0, sizeof(v39));
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    *(_OWORD *)__s = 0u;
    ulocimp_getRegionForSupplementalData(a1, 0, __s, 157, a4);
    uint64_t v4 = 0;
    if (*a4 > 0) {
      goto LABEL_50;
    }
    unsigned int v12 = strchr(__s, 95);
    if (v12) {
      *unsigned int v12 = 0;
    }
    if (!__s[0])
    {
      int v17 = 0;
      int v18 = 2;
      int v29 = 2;
      goto LABEL_39;
    }
    int v29 = 0;
    uint64_t v13 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v29);
    uint64_t v14 = ures_getByKey(v13, "CurrencyMap", v13, &v29);
    uint64_t v15 = ures_getByKey(v13, __s, v14, &v29);
    uint64_t v16 = v15;
    if (v29 > 0)
    {
      int v17 = 0;
      goto LABEL_38;
    }
    int Size = ures_getSize(v15);
    if (Size < 1)
    {
      int v17 = 0;
LABEL_35:
      if (v29 <= 0 && !v17) {
        int v29 = 2;
      }
LABEL_38:
      ures_close(v16);
      int v18 = v29;
      if (v29 < 1)
      {
        if (!v29)
        {
          int v25 = *a4;
          if (*a4) {
            goto LABEL_45;
          }
        }
        goto LABEL_44;
      }
LABEL_39:
      if (strchr(__s, 95))
      {
        memset(&v30[1], 0, 56);
        v30[0] = (char *)&v30[1] + 5;
        LODWORD(v30[1]) = 40;
        v27[0] = 0;
        v27[1] = 0;
        icu::CharStringByteSink::CharStringByteSink(v27, (uint64_t)v30);
        ulocimp_getParent(a1, (uint64_t)v27, a4);
        icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v27);
        *a4 = -128;
        uint64_t v4 = ucurr_forLocale(v30[0], a2, a3, a4);
        if (BYTE4(v30[1])) {
          uprv_free(v30[0]);
        }
        goto LABEL_50;
      }
LABEL_44:
      *a4 = v18;
      int v25 = v18;
LABEL_45:
      uint64_t v11 = v28;
      if (v25 <= 0 && (int)v28 < (int)a3)
      {
        u_strcpy(a2, v17);
        uint64_t v11 = v28;
      }
      uint64_t v9 = (uint64_t)a2;
      int v10 = a3;
      goto LABEL_49;
    }
    int v20 = Size;
    signed int v21 = 0;
    int v17 = 0;
    while (1)
    {
      int v22 = ures_getByIndex(v16, v21, 0, (UErrorCode *)&v29);
      LODWORD(v30[0]) = v29;
      StringByKey = ures_getStringByKey((uint64_t)v22, "tender", 0, (int *)v30);
      if (SLODWORD(v30[0]) < 1)
      {
        int32_t v24 = u_strcmp(StringByKey, word_18CAA1C42);
        if (!v24 && v17)
        {
          int32_t v24 = 4;
          goto LABEL_29;
        }
        int v17 = ures_getStringByKey((uint64_t)v22, "id", (int *)&v28, &v29);
        if (!v24) {
          goto LABEL_29;
        }
      }
      else
      {
        int v17 = ures_getStringByKey((uint64_t)v22, "id", (int *)&v28, &v29);
      }
      int32_t v24 = 2;
LABEL_29:
      if (v22) {
        ures_close((uint64_t)v22);
      }
      if ((v24 | 4) == 4 && v20 != ++v21) {
        continue;
      }
      goto LABEL_35;
    }
  }
  if (a3 >= 4)
  {
    T_CString_toUpperCase((unsigned __int8 *)v40[0]);
    u_charsToUChars((const char *)v40[0], a2, 3);
  }
  uint64_t v9 = (uint64_t)a2;
  int v10 = a3;
  uint64_t v11 = 3;
LABEL_49:
  uint64_t v4 = u_terminateUChars(v9, v10, v11, a4);
LABEL_50:
  if (BYTE4(v40[1])) {
    uprv_free(v40[0]);
  }
  return v4;
}

const UChar *ucurr_getName(const UChar *a1, char *a2, unsigned int a3, unsigned char *a4, int *a5, int *a6)
{
  v46[8] = *(void **)MEMORY[0x1E4F143B8];
  if (*a6 > 0) {
    return 0;
  }
  signed int v8 = a3;
  if (a3 >= 5)
  {
    int v6 = 0;
    *a6 = 1;
    return v6;
  }
  UErrorCode v42 = U_ZERO_ERROR;
  memset(&v46[1], 0, 56);
  v46[0] = (char *)&v46[1] + 5;
  LODWORD(v46[1]) = 40;
  v43[0] = 0;
  v43[1] = 0;
  icu::CharStringByteSink::CharStringByteSink(v43, (uint64_t)v46);
  ulocimp_getName(a2);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v43);
  *(_DWORD *)__s = 0;
  u_UCharsToChars(a1, __s, 3);
  __s[3] = 0;
  T_CString_toUpperCase((unsigned __int8 *)__s);
  UErrorCode v42 = U_ZERO_ERROR;
  BOOL v40 = 0;
  uint64_t v13 = ures_open("icudt74l-curr", (char *)v46[0], (int *)&v42);
  uint64_t v14 = ures_openWithCountryFallback("icudt74l-curr", (char *)v46[0], &v40, (int *)&v42);
  v44[0] = 0;
  v44[1] = 0;
  int v45 = 0;
  if (v40)
  {
    uscript_getCode((char *)v46[0], (int32_t *)v44, 5, (int *)&v42);
    if (v42 >= U_ILLEGAL_ARGUMENT_ERROR) {
      LODWORD(v44[0]) = 0;
    }
  }
  if ((v8 - 2) > 2) {
    goto LABEL_37;
  }
  memset(&v43[1], 0, 56);
  v43[0] = (char *)&v43[1] + 5;
  LODWORD(v43[1]) = 40;
  switch(v8)
  {
    case 4:
      uint64_t v15 = "Currencies%variant";
      uint64_t v16 = v37;
      int v17 = (icu::StringPiece *)v37;
      break;
    case 3:
      uint64_t v15 = "Currencies%formal";
      uint64_t v16 = v38;
      int v17 = (icu::StringPiece *)v38;
      break;
    case 2:
      uint64_t v15 = "Currencies%narrow";
      uint64_t v16 = v39;
      int v17 = (icu::StringPiece *)v39;
      break;
    default:
      int v20 = 0;
      int v6 = 0;
      *a6 = 16;
      goto LABEL_33;
  }
  icu::StringPiece::StringPiece(v17, v15);
  icu::CharString::append((icu::CharString *)v43, *(const char **)v16, *((_DWORD *)v16 + 2), &v42);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v35, "/");
  icu::CharString::append((icu::CharString *)v43, v35, v36, &v42);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v33, __s);
  icu::CharString::append((icu::CharString *)v43, v33, v34, &v42);
  if (!v40)
  {
    UErrorCode v19 = v42;
    goto LABEL_21;
  }
  StringByKeyWithFallback = ures_getStringByKeyWithFallback(v14, (char *)v43[0], a5, &v42);
  int v6 = StringByKeyWithFallback;
  UErrorCode v19 = v42;
  if (v42 <= U_ZERO_ERROR)
  {
    int v21 = *StringByKeyWithFallback;
    if ((v21 & 0xFC00) == 0xD800 && u_strlen(StringByKeyWithFallback) != 1)
    {
      int v22 = v6[1];
      if ((v22 & 0xFC00) == 0xDC00) {
        int v21 = v22 + (v21 << 10) - 56613888;
      }
    }
    int Script = uscript_getScript(v21, (int *)&v42);
    if (v42 > U_ZERO_ERROR) {
      goto LABEL_29;
    }
    int v31 = Script;
    int v32 = u_isalpha(v21);
    UErrorCode v19 = v42;
    if (v32)
    {
      if (v31 != 25 && v31 != LODWORD(v44[0])) {
        goto LABEL_21;
      }
    }
  }
  if (v19 == U_MISSING_RESOURCE_ERROR || !v6)
  {
LABEL_21:
    if (v19 < U_ILLEGAL_ARGUMENT_ERROR)
    {
LABEL_30:
      int v6 = ures_getStringByKeyWithFallback(v13, (char *)v43[0], a5, &v42);
      if (v42 == U_MISSING_RESOURCE_ERROR)
      {
        signed int v8 = 0;
        *a6 = -128;
        UErrorCode v42 = U_ZERO_ERROR;
      }
      goto LABEL_32;
    }
LABEL_29:
    UErrorCode v42 = U_ZERO_ERROR;
    goto LABEL_30;
  }
LABEL_32:
  int v20 = 1;
LABEL_33:
  if (BYTE4(v43[1])) {
    uprv_free(v43[0]);
  }
  if (v20)
  {
    if (v6) {
      goto LABEL_55;
    }
LABEL_37:
    if (v8 != 1 && v40)
    {
      ures_getByKey(v14, "Currencies", v14, (int *)&v42);
      ures_getByKeyWithFallback(v14, __s, v14, &v42);
      StringByint Index = ures_getStringByIndex(v14, v8, a5, &v42);
      int v6 = StringByIndex;
      if (v42 <= U_ZERO_ERROR)
      {
        int v25 = *StringByIndex;
        if ((v25 & 0xFC00) == 0xD800 && u_strlen(StringByIndex) != 1)
        {
          int v26 = v6[1];
          if ((v26 & 0xFC00) == 0xDC00) {
            int v25 = v26 + (v25 << 10) - 56613888;
          }
        }
        int v27 = uscript_getScript(v25, (int *)&v42);
        if (v42 > U_ZERO_ERROR) {
          goto LABEL_53;
        }
        int v28 = v27;
        if (u_isalpha(v25) && v28 != 25 && v28 != LODWORD(v44[0])) {
          goto LABEL_52;
        }
      }
      else if (!StringByIndex)
      {
        goto LABEL_53;
      }
      if (u_strcmp(v6, a1)) {
        goto LABEL_55;
      }
    }
LABEL_52:
    if (v42 < U_ILLEGAL_ARGUMENT_ERROR)
    {
LABEL_54:
      ures_getByKey(v13, "Currencies", v13, (int *)&v42);
      ures_getByKeyWithFallback(v13, __s, v13, &v42);
      int v6 = ures_getStringByIndex(v13, v8, a5, &v42);
LABEL_55:
      UErrorCode v29 = v42;
      if (v42 <= U_ZERO_ERROR && (v42 == U_USING_DEFAULT_WARNING || v42 == U_USING_FALLBACK_WARNING && *a6 != -127)) {
        *a6 = v42;
      }
      if (a4) {
        *a4 = 0;
      }
      if (v29 >= U_ILLEGAL_ARGUMENT_ERROR)
      {
        *a5 = u_strlen(a1);
        *a6 = -127;
        int v6 = a1;
      }
      goto LABEL_64;
    }
LABEL_53:
    UErrorCode v42 = U_ZERO_ERROR;
    goto LABEL_54;
  }
  int v6 = 0;
LABEL_64:
  if (v14) {
    ures_close(v14);
  }
  if (v13) {
    ures_close(v13);
  }
  if (BYTE4(v46[1])) {
    uprv_free(v46[0]);
  }
  return v6;
}

const UChar *ucurr_getPluralName(const UChar *a1, char *a2, unsigned char *a3, char *a4, int *a5, int *a6)
{
  v21[8] = *(void **)MEMORY[0x1E4F143B8];
  if (*a6 > 0) {
    return 0;
  }
  int v20 = 0;
  memset(&v21[1], 0, 56);
  v21[0] = (char *)&v21[1] + 5;
  LODWORD(v21[1]) = 40;
  v19[0] = 0;
  v19[1] = 0;
  icu::CharStringByteSink::CharStringByteSink(v19, (uint64_t)v21);
  ulocimp_getName(a2);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v19);
  if (v20 >= 1)
  {
    Name = 0;
    int v13 = 1;
LABEL_5:
    *a6 = v13;
    goto LABEL_6;
  }
  LODWORD(v19[0]) = 0;
  u_UCharsToChars(a1, (char *)v19, 3);
  BYTE3(v19[0]) = 0;
  int v20 = 0;
  uint64_t v15 = ures_open("icudt74l-curr", (char *)v21[0], &v20);
  uint64_t v16 = ures_getByKey(v15, "CurrencyPlurals", v15, &v20);
  uint64_t v17 = ures_getByKeyWithFallback(v16, (char *)v19, v16, (UErrorCode *)&v20);
  StringByKeyWithFallback = ures_getStringByKeyWithFallback(v17, a4, a5, (UErrorCode *)&v20);
  if (v20 < 1
    || (int v20 = 0, StringByKeyWithFallback = ures_getStringByKeyWithFallback(v17, "other", a5, (UErrorCode *)&v20),
                 v20 < 1))
  {
    Name = StringByKeyWithFallback;
    ures_close(v17);
    int v13 = v20;
    if (v20 <= 0)
    {
      if (v20 == -127 || v20 == -128 && *a6 != -127) {
        goto LABEL_5;
      }
    }
    else
    {
      *a5 = u_strlen(a1);
      *a6 = -127;
      Name = a1;
    }
  }
  else
  {
    ures_close(v17);
    Name = ucurr_getName(a1, a2, 1u, a3, a5, a6);
  }
LABEL_6:
  if (BYTE4(v21[1])) {
    uprv_free(v21[0]);
  }
  return Name;
}

void uprv_parseCurrency(char *a1, uint64_t a2, uint64_t a3, int a4, int *a5, UChar *a6, int *a7)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (*a7 <= 0)
  {
    uint64_t v14 = sub_18C877580(a1, a7);
    if (*a7 <= 0)
    {
      uint64_t v15 = (uint64_t)v14;
      int v25 = *((_DWORD *)v14 + 46);
      int v26 = *((_DWORD *)v14 + 42);
      uint64_t v27 = *((void *)v14 + 20);
      uint64_t v28 = *((void *)v14 + 22);
      int v16 = *(_DWORD *)(a3 + 8);
      uint64_t v59 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      *(_OWORD *)src = 0u;
      long long v48 = 0u;
      uint64_t v46 = 0;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      *(_OWORD *)dest = 0u;
      long long v35 = 0u;
      unsigned int v17 = *(unsigned __int16 *)(a2 + 8);
      if ((v17 & 0x8000) != 0) {
        unsigned int v18 = *(_DWORD *)(a2 + 12);
      }
      else {
        unsigned int v18 = v17 >> 5;
      }
      int v19 = v18 - v16;
      if ((int)(v18 - v16) > 100) {
        int v19 = 100;
      }
      icu::UnicodeString::doExtract((char *)a2, v16, v19, (uint64_t)src, 0);
      UErrorCode pErrorCode = U_ZERO_ERROR;
      int32_t v20 = u_strToUpper(dest, 100, src, v19, a1, &pErrorCode);
      *a5 = 0;
      int v31 = -1;
      int v32 = 0;
      sub_18C877E90(v27, v26, dest, v20, a5, &v32, &v31);
      int v21 = 0;
      int v29 = -1;
      int v30 = 0;
      BOOL v22 = a4 == 1;
      uint64_t v23 = v28;
      if (!v22)
      {
        sub_18C877E90(v28, v25, src, v20, a5, &v30, &v29);
        int v21 = v30;
      }
      if (v32 < v21 || (int v24 = v31, v31 == -1))
      {
        if (v21 < v32) {
          goto LABEL_16;
        }
        int v24 = v29;
        if (v29 == -1) {
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v23 = v27;
        int v21 = v32;
      }
      u_charsToUChars(*(const char **)(v23 + 24 * v24), a6, 4);
      *(_DWORD *)(a3 + 8) = v21 + v16;
LABEL_16:
      sub_18C878138(v15);
    }
  }
}

char *sub_18C877580(char *a1, int *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  umtx_lock((atomic_ullong *)&unk_1E9191E20);
  for (uint64_t i = 0; i != 10; ++i)
  {
    unsigned int v5 = (const char *)qword_1E9191DC8[i];
    if (v5 && !strcmp(a1, v5))
    {
      long long v51 = (char *)qword_1E9191DC8[i];
LABEL_62:
      ++*((_DWORD *)v51 + 47);
      goto LABEL_79;
    }
  }
  umtx_unlock((std::mutex **)&unk_1E9191E20);
  uint64_t v63 = sub_18C879618();
  int v71 = 0;
  memset(&__s[1], 0, 56);
  __s[0] = (char *)&__s[1] + 5;
  LODWORD(__s[1]) = 40;
  v82[0] = 0uLL;
  icu::CharStringByteSink::CharStringByteSink(v82, (uint64_t)__s);
  ulocimp_getName(a1);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v82);
  uint64_t v59 = a2;
  memset((char *)v82 + 8, 0, 56);
  *(void *)&v82[0] = (char *)v82 + 13;
  DWORD2(v82[0]) = 40;
  v79[0] = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v75, __s[0]);
  icu::CharString::append((icu::CharString *)v82, v75, v76, (UErrorCode *)v79);
  int v6 = 0;
  int v7 = 0;
  if (v79[0] <= 0)
  {
    uint64_t v8 = sub_18C879618();
    int v6 = 0;
    int v7 = 0;
    do
    {
      int32_t srcLength = 0;
      uint64_t v69 = ures_open("icudt74l-curr", *(char **)&v82[0], &srcLength);
      uint64_t v9 = ures_getByKey(v69, "Currencies", 0, &srcLength);
      int Size = ures_getSize(v9);
      if (Size >= 1)
      {
        int v11 = Size;
        for (signed int j = 0; j != v11; ++j)
        {
          int v13 = ures_getByIndex(v9, j, 0, (UErrorCode *)&srcLength);
          int v73 = 0;
          StringByint Index = ures_getStringByIndex((uint64_t)v13, 0, &v73, (UErrorCode *)&srcLength);
          if (v8)
          {
            int v72 = StringByIndex;
            icu::UnicodeString::UnicodeString(v79, 1, &v72);
            v77[1] = v79;
            v77[2] = v79;
            v77[0] = v8;
            do
              ++v7;
            while (sub_18C876678((uint64_t)v77));
            icu::UnicodeString::~UnicodeString(v15, (icu::UnicodeString *)v79);
          }
          else
          {
            ++v7;
          }
          ++v7;
          ures_close((uint64_t)v13);
        }
        v6 += v11;
      }
      v79[0] = 0;
      uint64_t v16 = ures_getByKey(v69, "CurrencyPlurals", 0, v79);
      int v17 = ures_getSize(v16);
      if (v17 >= 1)
      {
        int v18 = v17;
        for (signed int k = 0; k != v18; ++k)
        {
          int32_t v20 = ures_getByIndex(v16, k, 0, (UErrorCode *)v79);
          v6 += ures_getSize((uint64_t)v20);
          ures_close((uint64_t)v20);
        }
      }
      ures_close(v16);
      ures_close(v9);
      ures_close(v69);
    }
    while (sub_18C87971C((icu::CharString *)v82));
  }
  if (BYTE12(v82[0])) {
    uprv_free(*(void **)&v82[0]);
  }
  int v21 = v59;
  uint64_t v22 = v63;
  __base = (char *)uprv_malloc(24 * v6);
  if (__base)
  {
    int v68 = (char *)uprv_malloc(24 * v7);
    if (v68)
    {
      if (*v59 <= 0)
      {
        LODWORD(v75) = 0;
        LODWORD(v72) = 0;
        unsigned __int8 v67 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, (int *)&v75);
        int v6 = 0;
        int v7 = 0;
        int v70 = 0;
        int v61 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, (int *)&v72);
        do
        {
          int v71 = 0;
          uint64_t v60 = ures_open("icudt74l-curr", __s[0], &v71);
          uint64_t v66 = ures_getByKey(v60, "Currencies", 0, &v71);
          int v23 = ures_getSize(v66);
          if (v23 >= 1)
          {
            int v24 = v23;
            for (signed int m = 0; m != v24; ++m)
            {
              int v26 = ures_getByIndex(v66, m, 0, (UErrorCode *)&v71);
              int32_t srcLength = 0;
              uint64_t v27 = ures_getStringByIndex((uint64_t)v26, 0, &srcLength, (UErrorCode *)&v71);
              Key = (const char *)ures_getKey((uint64_t)v26);
              if (!v70 || !uhash_get((uint64_t)v67, (uint64_t)Key))
              {
                uhash_put((uint64_t)v67, (uint64_t)Key, (uint64_t)Key, (int *)&v75);
                int v29 = (const char **)&v68[24 * v7];
                unsigned __int16 *v29 = Key;
                v29[1] = (const char *)v27;
                int v30 = v7 + 1;
                unsigned char v29[2] = (const char *)srcLength;
                if (v22)
                {
                  memset(v82, 0, sizeof(v82));
                  v77[0] = v27;
                  icu::UnicodeString::UnicodeString(v82, 1, v77);
                  unsigned int v80 = v82;
                  unsigned int v81 = v82;
                  *(void *)int v79 = v22;
                  uint64_t v31 = sub_18C876678((uint64_t)v79);
                  if (v31)
                  {
                    long long v33 = (int *)&v68[24 * v30 + 16];
                    do
                    {
                      *((void *)v33 - 2) = Key;
                      __int16 v34 = *(_WORD *)(v31 + 8);
                      if ((v34 & 0x11) != 0)
                      {
                        uint64_t v35 = 0;
                      }
                      else if ((v34 & 2) != 0)
                      {
                        uint64_t v35 = v31 + 10;
                      }
                      else
                      {
                        uint64_t v35 = *(void *)(v31 + 24);
                      }
                      *((void *)v33 - 1) = v35;
                      v33[1] = 0;
                      if (*(__int16 *)(v31 + 8) < 0) {
                        int v36 = *(_DWORD *)(v31 + 12);
                      }
                      else {
                        int v36 = *(unsigned __int16 *)(v31 + 8) >> 5;
                      }
                      *long long v33 = v36;
                      v33 += 6;
                      uint64_t v31 = sub_18C876678((uint64_t)v79);
                      ++v30;
                    }
                    while (v31);
                  }
                  icu::UnicodeString::~UnicodeString(v32, (icu::UnicodeString *)v82);
                }
                long long v37 = (UChar *)ures_getStringByIndex((uint64_t)v26, 1, &srcLength, (UErrorCode *)&v71);
                long long v38 = &__base[24 * v6];
                *(void *)long long v38 = Key;
                *((void *)v38 + 1) = sub_18C879668(v37, srcLength, a1);
                ++v6;
                *((_DWORD *)v38 + 4) = srcLength;
                *((_DWORD *)v38 + 5) = 1;
                long long v39 = (const char **)&v68[24 * v30];
                *long long v39 = Key;
                long long v40 = (UChar *)uprv_malloc(6uLL);
                v39[1] = (const char *)v40;
                u_charsToUChars(Key, v40, 3);
                int v7 = v30 + 1;
                v39[2] = (const char *)0x100000003;
                uint64_t v22 = v63;
              }
              ures_close((uint64_t)v26);
            }
          }
          LODWORD(v82[0]) = 0;
          uint64_t v65 = ures_getByKey(v60, "CurrencyPlurals", 0, (int *)v82);
          int v64 = ures_getSize(v65);
          if (v64 < 1)
          {
            long long v42 = v61;
          }
          else
          {
            signed int v41 = 0;
            long long v42 = v61;
            do
            {
              long long v43 = ures_getByIndex(v65, v41, 0, (UErrorCode *)v82);
              uint64_t v44 = ures_getKey((uint64_t)v43);
              if (!v70 || !uhash_get((uint64_t)v42, v44))
              {
                uhash_put((uint64_t)v42, v44, v44, (int *)&v72);
                int v45 = ures_getSize((uint64_t)v43);
                v79[0] = 0;
                if (v45 >= 1)
                {
                  int v46 = v45;
                  signed int v47 = 0;
                  long long v48 = &__base[24 * v6 + 16];
                  do
                  {
                    long long v49 = (UChar *)ures_getStringByIndex((uint64_t)v43, v47, v79, (UErrorCode *)v82);
                    *((void *)v48 - 2) = v44;
                    *((void *)v48 - 1) = sub_18C879668(v49, v79[0], a1);
                    *(_DWORD *)long long v48 = v79[0];
                    *((_DWORD *)v48 + 1) = 1;
                    v48 += 24;
                    ++v47;
                  }
                  while (v46 != v47);
                  v6 += v47;
                  uint64_t v22 = v63;
                  long long v42 = v61;
                }
              }
              ures_close((uint64_t)v43);
              ++v41;
            }
            while (v41 != v64);
          }
          ures_close(v65);
          ures_close(v66);
          ures_close(v60);
          ++v70;
        }
        while (sub_18C87971C((icu::CharString *)__s));
        uhash_close(v67);
        uhash_close(v42);
        qsort(__base, v6, 0x18uLL, (int (__cdecl *)(const void *, const void *))sub_18C879848);
        qsort(v68, v7, 0x18uLL, (int (__cdecl *)(const void *, const void *))sub_18C879848);
        int v50 = (int)v75;
        int v21 = v59;
        if ((int)v75 > 0 || (int v50 = (int)v72, (int)v72 >= 1)) {
          int *v59 = v50;
        }
      }
      goto LABEL_65;
    }
    uprv_free(__base);
  }
  int v6 = 0;
  __base = 0;
  int v7 = 0;
  int v68 = 0;
  int *v59 = 7;
LABEL_65:
  if (BYTE4(__s[1])) {
    uprv_free(__s[0]);
  }
  if (*v21 > 0) {
    return 0;
  }
  umtx_lock((atomic_ullong *)&unk_1E9191E20);
  uint64_t v52 = 0;
  while (1)
  {
    long long v53 = (const char *)qword_1E9191DC8[v52];
    if (v53)
    {
      if (!strcmp(a1, v53)) {
        break;
      }
    }
    if (++v52 == 10) {
      goto LABEL_75;
    }
  }
  if (v52 != 255)
  {
    sub_18C8795AC(__base, v6);
    sub_18C8795AC(v68, v7);
    long long v51 = (char *)qword_1E9191DC8[v52];
    goto LABEL_62;
  }
LABEL_75:
  uint64_t v54 = qword_1E9191DC8[byte_1E9191E18];
  if (v54)
  {
    int v55 = *(_DWORD *)(v54 + 188) - 1;
    *(_DWORD *)(v54 + 188) = v55;
    if (!v55) {
      sub_18C8794C8(v54);
    }
  }
  long long v51 = (char *)uprv_malloc(0xC0uLL);
  int v56 = byte_1E9191E18;
  qword_1E9191DC8[byte_1E9191E18] = (uint64_t)v51;
  long long v57 = strcpy(v51, a1);
  *((void *)v57 + 20) = __base;
  *((_DWORD *)v57 + 42) = v6;
  *((void *)v57 + 22) = v68;
  *((_DWORD *)v57 + 46) = v7;
  *((_DWORD *)v57 + 47) = 2;
  byte_1E9191E18 = v56 + 1 - 10 * ((6554 * (v56 + 1)) >> 16);
  sub_18C8546F4(0xEu, (uint64_t)sub_18C879514);
LABEL_79:
  umtx_unlock((std::mutex **)&unk_1E9191E20);
  return v51;
}

uint64_t sub_18C877E90(uint64_t result, int a2, unsigned __int16 *__s2, int a4, int *a5, int *a6, int *a7)
{
  uint64_t v12 = result;
  uint64_t v13 = 0;
  int v14 = 0;
  *a7 = -1;
  *a6 = 0;
  int v15 = a2 - 1;
  while (2)
  {
    if (v13 == (a4 & ~(a4 >> 31)) || v14 > v15) {
      return result;
    }
    unsigned int v16 = __s2[v13];
    int v17 = v15;
    int v18 = v14;
    while (1)
    {
      int v19 = v18 + v17 < 0 != __OFADD__(v18, v17) ? v18 + v17 + 1 : v18 + v17;
      int v20 = v19 >> 1;
      uint64_t result = *(int *)(v12 + 24 * (v19 >> 1) + 16);
      if (v13 < result)
      {
        unsigned int v21 = *(unsigned __int16 *)(*(void *)(v12 + 24 * (v19 >> 1) + 8) + 2 * v13);
        if (v21 >= v16) {
          break;
        }
      }
      int v18 = v20 + 1;
LABEL_13:
      if (v18 > v17) {
        return result;
      }
    }
    if (v21 > v16)
    {
      int v17 = v20 - 1;
      goto LABEL_13;
    }
    if (v14 < v20)
    {
      int v22 = v20;
      do
      {
        int v23 = v14 + v22;
        if (v14 + v22 < 0 != __OFADD__(v14, v22)) {
          ++v23;
        }
        int v24 = v23 >> 1;
        uint64_t v25 = (uint64_t)v23 >> 1;
        if (v13 >= *(int *)(v12 + 24 * v24 + 16))
        {
          int v14 = v25 + 1;
        }
        else if (*(unsigned __int16 *)(*(void *)(v12 + 24 * (int)v25 + 8) + 2 * v13) >= v16)
        {
          int v22 = v25;
        }
        else
        {
          int v14 = v25 + 1;
        }
      }
      while (v14 < v22);
    }
    while (v20 < v15)
    {
      int v26 = v20 + v15;
      if (v20 + v15 < 0 != __OFADD__(v20, v15)) {
        ++v26;
      }
      int v27 = v26 >> 1;
      uint64_t v28 = (uint64_t)v26 >> 1;
      if (v13 <= *(int *)(v12 + 24 * v27 + 16))
      {
        if (*(unsigned __int16 *)(*(void *)(v12 + 24 * (int)v28 + 8) + 2 * v13) > v16) {
          int v15 = v28;
        }
        else {
          int v20 = v28 + 1;
        }
      }
      else
      {
        int v20 = v28 + 1;
      }
    }
    int v29 = *(unsigned __int16 *)(*(void *)(v12 + 24 * v15 + 8) + 2 * v13) > v16;
    uint64_t v30 = v13 + 1;
    if (v13 + 1 == *(_DWORD *)(v12 + 24 * v14 + 16)) {
      int v31 = v14;
    }
    else {
      int v31 = -1;
    }
    if (v14 != -1)
    {
      if (v13 >= *a5) {
        int v32 = v13 + 1;
      }
      else {
        int v32 = *a5;
      }
      *a5 = v32;
      if (v31 != -1)
      {
        *a6 = v30;
        *a7 = v31;
      }
      v15 -= v29;
      uint64_t v13 = v30;
      if (v15 - v14 <= 9)
      {
        if (v15 >= v14)
        {
          uint64_t v33 = v14;
          uint64_t v34 = *a5;
          int v35 = v15 + 1;
          do
          {
            int v36 = *(_DWORD *)(v12 + 24 * v33 + 16);
            BOOL v37 = v36 > a4 || v36 <= *a6;
            if (v37 || (uint64_t result = memcmp(*(const void **)(v12 + 24 * v33 + 8), __s2, 2 * v36), result))
            {
              if (v36 >= a4) {
                int v38 = a4;
              }
              else {
                int v38 = v36;
              }
              if ((int)v34 < v38)
              {
                uint64_t v39 = *(void *)(v12 + 24 * v33 + 8);
                uint64_t v40 = v34;
                do
                {
                  if (*(unsigned __int16 *)(v39 + 2 * v40) != __s2[v40]) {
                    break;
                  }
                  uint64_t v41 = *a5;
                  if (v40 >= v41) {
                    LODWORD(v41) = v40 + 1;
                  }
                  *a5 = v41;
                  ++v40;
                }
                while (v38 != v40);
              }
            }
            else
            {
              int v42 = *a5;
              if (*a5 <= v36) {
                int v42 = v36;
              }
              *a5 = v42;
              *a7 = v33;
              *a6 = v36;
            }
            ++v33;
          }
          while (v35 != v33);
        }
        return result;
      }
      continue;
    }
    return result;
  }
}

void sub_18C878138(uint64_t a1)
{
  umtx_lock((atomic_ullong *)&unk_1E9191E20);
  int v2 = *(_DWORD *)(a1 + 188) - 1;
  *(_DWORD *)(a1 + 188) = v2;
  if (!v2) {
    sub_18C8794C8(a1);
  }

  umtx_unlock((std::mutex **)&unk_1E9191E20);
}

const UChar *uprv_getStaticCurrencyName(const UChar *a1, char *a2, uint64_t a3, int *a4)
{
  unsigned int v13 = 0;
  uint64_t result = ucurr_getName(a1, a2, 0, 0, (int *)&v13, a4);
  if (*a4 <= 0)
  {
    uint64_t v7 = (uint64_t)result;
    uint64_t v8 = v13;
    icu::UnicodeString::unBogus(a3);
    unsigned int v9 = *(unsigned __int16 *)(a3 + 8);
    int v10 = (__int16)v9;
    unsigned int v11 = v9 >> 5;
    if (v10 >= 0) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = *(unsigned int *)(a3 + 12);
    }
    return (const UChar *)icu::UnicodeString::doReplace(a3, 0, v12, v7, 0, v8);
  }
  return result;
}

uint64_t ucurr_getDefaultFractionDigits(const UChar *a1, int *a2)
{
  if (*a2 <= 0) {
    return *sub_18C8782BC(a1, a2);
  }
  else {
    return 0;
  }
}

uint64_t ucurr_getDefaultFractionDigitsForUsage(const UChar *a1, int a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  if (a2 == 1) {
    return sub_18C8782BC(a1, a3)[2];
  }
  if (!a2) {
    return *sub_18C8782BC(a1, a3);
  }
  uint64_t result = 0;
  *a3 = 16;
  return result;
}

int *sub_18C8782BC(const UChar *a1, int *a2)
{
  if (!a1 || !*a1)
  {
    if (*a2 <= 0) {
      *a2 = 1;
    }
    return (int *)&unk_18CA8147C;
  }
  uint64_t v4 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)a2);
  uint64_t v5 = ures_getByKey(v4, "CurrencyMeta", v4, a2);
  uint64_t v6 = v5;
  if (*a2 >= 1)
  {
LABEL_4:
    ures_close(v5);
    return (int *)&unk_18CA8147C;
  }
  *(void *)unsigned int v13 = 0;
  u_UCharsToChars(a1, &v13[4], 3);
  v13[7] = 0;
  uint64_t v9 = ures_getByKey(v6, &v13[4], 0, (int *)v13);
  uint64_t v10 = v9;
  if (*(int *)v13 >= 1)
  {
    ures_close(v9);
    uint64_t v10 = ures_getByKey(v6, "DEFAULT", 0, a2);
    if (*a2 >= 1)
    {
      ures_close(v6);
      uint64_t v5 = v10;
      goto LABEL_4;
    }
  }
  int v12 = 0;
  IntVector = ures_getIntVector(v10, &v12, a2);
  if (*a2 < 1 && v12 == 4) {
    uint64_t v7 = IntVector;
  }
  else {
    uint64_t v7 = (int *)&unk_18CA8147C;
  }
  if ((*a2 >= 1 || v12 != 4) && *a2 <= 0)
  {
    *a2 = 3;
    uint64_t v7 = (int *)&unk_18CA8147C;
  }
  ures_close(v6);
  ures_close(v10);
  return v7;
}

int *ucurr_getRoundingIncrement(const UChar *a1, int *a2)
{
  return ucurr_getRoundingIncrementForUsage(a1, 0, a2);
}

int *ucurr_getRoundingIncrementForUsage(const UChar *a1, int a2, int *a3)
{
  uint64_t result = sub_18C8782BC(a1, a3);
  if (*a3 <= 0)
  {
    if (a2)
    {
      if (a2 != 1)
      {
        int v7 = 16;
        goto LABEL_10;
      }
      uint64_t v6 = result + 2;
    }
    else
    {
      uint64_t v6 = result;
    }
    if (*v6 >= 0xA)
    {
      int v7 = 3;
LABEL_10:
      *a3 = v7;
    }
  }
  return result;
}

uint64_t ucurr_isAvailable(uint64_t a1, int *a2, double a3, double a4)
{
  if (*a2 > 0) {
    return 0;
  }
  if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191E80, memory_order_acquire) == 2
    || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191E80))
  {
    int v9 = dword_1E9191E84;
    if (dword_1E9191E84 >= 1)
    {
      uint64_t result = 0;
      goto LABEL_9;
    }
  }
  else
  {
    sub_18C8785F8(a2);
    dword_1E9191E84 = *a2;
    icu::umtx_initImplPostInit(&dword_1E9191E80);
  }
  if (*a2 > 0) {
    return 0;
  }
  uint64_t result = uhash_get(qword_1E9191DC0, a1);
  if (result)
  {
    if (a3 <= a4) {
      return *(double *)(result + 16) >= a3 && *(double *)(result + 8) <= a4;
    }
    uint64_t result = 0;
    int v9 = 1;
LABEL_9:
    *a2 = v9;
  }
  return result;
}

void sub_18C8785F8(int *a1)
{
  sub_18C8546F4(0xEu, (uint64_t)sub_18C879514);
  int v2 = uhash_open((uint64_t)uhash_hashUChars, (uint64_t)uhash_compareUChars, 0, a1);
  if (*a1 > 0) {
    return;
  }
  uint64_t v3 = v2;
  uhash_setValueDeleter((uint64_t)v2, (uint64_t)j__uprv_free);
  int v28 = 0;
  uint64_t v4 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v28);
  uint64_t v5 = ures_getByKey(v4, "CurrencyMap", v4, &v28);
  uint64_t v6 = v5;
  if (v28 > 0)
  {
    *a1 = v28;
LABEL_4:
    ures_close(v6);
    if (*a1 >= 1) {
      goto LABEL_26;
    }
    qword_1E9191DC0 = (uint64_t)v3;
    return;
  }
  if ((int)ures_getSize(v5) < 1) {
    goto LABEL_4;
  }
  signed int v7 = 0;
  uint64_t v25 = v6;
  while (1)
  {
    uint64_t v8 = ures_getByIndex(v6, v7, 0, (UErrorCode *)&v28);
    uint64_t v9 = (uint64_t)v8;
    if (v28 <= 0) {
      break;
    }
    *a1 = v28;
LABEL_10:
    ures_close(v9);
    ++v7;
    uint64_t v6 = v25;
    if (v7 >= (int)ures_getSize(v25)) {
      goto LABEL_4;
    }
  }
  if ((int)ures_getSize((uint64_t)v8) < 1) {
    goto LABEL_10;
  }
  signed int v10 = 0;
  while (1)
  {
    unsigned int v11 = ures_getByIndex(v9, v10, 0, (UErrorCode *)&v28);
    int v12 = uprv_malloc(0x18uLL);
    if (!v12) {
      break;
    }
    uint64_t v13 = (uint64_t)v12;
    int v27 = 0;
    uint64_t v14 = ures_getByKey((uint64_t)v11, "id", 0, &v28);
    if (v14)
    {
      uint64_t v15 = v14;
      String = ures_getString(v14, &v27, &v28);
      uint64_t v17 = ures_getByKey((uint64_t)v11, "from", 0, &v28);
      uint64_t v18 = v17;
      if (v28 <= 0)
      {
        int v26 = 0;
        IntVector = ures_getIntVector(v17, &v26, &v28);
        double v19 = (double)(uint64_t)(IntVector[1] | ((unint64_t)*IntVector << 32));
      }
      else
      {
        double v19 = -1.79769313e308;
      }
      ures_close(v18);
      int v28 = 0;
      uint64_t v21 = ures_getByKey((uint64_t)v11, "to", 0, &v28);
      uint64_t v22 = v21;
      if (v28 <= 0)
      {
        int v26 = 0;
        int v24 = ures_getIntVector(v21, &v26, &v28);
        double v23 = (double)(uint64_t)(v24[1] | ((unint64_t)*v24 << 32));
      }
      else
      {
        double v23 = 1.79769313e308;
      }
      ures_close(v22);
      ures_close(v15);
      ures_close((uint64_t)v11);
      *(void *)uint64_t v13 = String;
      *(double *)(v13 + 8) = v19;
      *(double *)(v13 + 16) = v23;
      int v28 = 0;
      uhash_put((uint64_t)v3, (uint64_t)String, v13, &v28);
    }
    if (++v10 >= (int)ures_getSize(v9)) {
      goto LABEL_10;
    }
  }
  *a1 = 7;
LABEL_26:
  uhash_close(v3);
}

void *ucurr_openISOCurrencies(int a1, _DWORD *a2)
{
  uint64_t v4 = uprv_malloc(0x38uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    long long v6 = *(_OWORD *)&off_1EDA46FD0;
    *(_OWORD *)uint64_t v4 = xmmword_1EDA46FC0;
    *((_OWORD *)v4 + 1) = v6;
    *((_OWORD *)v4 + 2) = xmmword_1EDA46FE0;
    v4[6] = off_1EDA46FF0;
    signed int v7 = uprv_malloc(8uLL);
    if (v7)
    {
      *signed int v7 = a1;
      v7[1] = 0;
      v5[1] = v7;
    }
    else
    {
      *a2 = 7;
      uprv_free(v5);
      return 0;
    }
  }
  else
  {
    *a2 = 7;
  }
  return v5;
}

uint64_t ucurr_countCurrencies(char *a1, int *a2, double a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!a2 || *a2 > 0) {
    return 0;
  }
  int v23 = 0;
  memset(v32, 0, sizeof(v32));
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)__s = 0u;
  long long v25 = 0u;
  ulocimp_getRegionForSupplementalData(a1, 0, __s, 157, a2);
  uint64_t v4 = 0;
  if (*a2 <= 0)
  {
    signed int v7 = strchr(__s, 95);
    if (v7) {
      *signed int v7 = 0;
    }
    uint64_t v8 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v23);
    uint64_t v9 = ures_getByKey(v8, "CurrencyMap", v8, &v23);
    uint64_t v10 = ures_getByKey(v8, __s, v9, &v23);
    uint64_t v11 = v10;
    if (v23 > 0 || (int)ures_getSize(v10) < 1)
    {
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v4 = 0;
      signed int v12 = 0;
      do
      {
        uint64_t v13 = ures_getByIndex(v11, v12, 0, (UErrorCode *)&v23);
        int v22 = 0;
        uint64_t v14 = ures_getByKey((uint64_t)v13, "from", 0, &v23);
        IntVector = ures_getIntVector(v14, &v22, &v23);
        double v16 = (double)(uint64_t)(IntVector[1] | ((unint64_t)*IntVector << 32));
        if ((int)ures_getSize((uint64_t)v13) < 3)
        {
          if (v16 <= a3) {
            uint64_t v4 = (v4 + 1);
          }
        }
        else
        {
          int v21 = 0;
          uint64_t v17 = ures_getByKey((uint64_t)v13, "to", 0, &v23);
          uint64_t v18 = ures_getIntVector(v17, &v21, &v23);
          if (v16 <= a3 && (double)(uint64_t)(v18[1] | ((unint64_t)*v18 << 32)) > a3) {
            uint64_t v4 = (v4 + 1);
          }
          ures_close(v17);
        }
        ures_close((uint64_t)v13);
        ures_close(v14);
        ++v12;
      }
      while (v12 < (int)ures_getSize(v11));
    }
    ures_close(v11);
    int v19 = *a2;
    int v20 = v23;
    if (!*a2 || v23)
    {
      *a2 = v23;
      int v19 = v20;
    }
    if (v19 > 0) {
      return 0;
    }
  }
  return v4;
}

uint64_t ucurr_forLocaleAndDate(char *a1, int a2, UChar *a3, int a4, int *a5, double a6)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  unsigned int v35 = 0;
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (!a3 && a4)
  {
    uint64_t result = 0;
    *a5 = 1;
    return result;
  }
  int v34 = 0;
  long long v43 = 0u;
  memset(v44, 0, sizeof(v44));
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)__s = 0u;
  ulocimp_getRegionForSupplementalData(a1, 0, __s, 157, a5);
  uint64_t result = 0;
  if (*a5 <= 0)
  {
    signed int v12 = strchr(__s, 95);
    if (v12) {
      *signed int v12 = 0;
    }
    uint64_t v13 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)&v34);
    uint64_t v14 = ures_getByKey(v13, "CurrencyMap", v13, &v34);
    uint64_t v15 = ures_getByKey(v13, __s, v14, &v34);
    uint64_t v16 = v15;
    if (v34 <= 0)
    {
      if (a2 < 1 || (int)ures_getSize(v15) < a2)
      {
        ures_close(v16);
        return 0;
      }
      if ((int)ures_getSize(v16) < 1)
      {
        StringByKey = 0;
        char v23 = 0;
      }
      else
      {
        int v30 = 0;
        signed int v22 = 0;
        char v23 = 0;
        do
        {
          int v24 = ures_getByIndex(v16, v22, 0, (UErrorCode *)&v34);
          StringByKey = ures_getStringByKey((uint64_t)v24, "id", (int *)&v35, &v34);
          int v33 = 0;
          uint64_t v25 = ures_getByKey((uint64_t)v24, "from", 0, &v34);
          IntVector = ures_getIntVector(v25, &v33, &v34);
          double v27 = (double)(uint64_t)(IntVector[1] | ((unint64_t)*IntVector << 32));
          if ((int)ures_getSize((uint64_t)v24) < 3)
          {
            if (v27 <= a6 && ++v30 == a2) {
              char v23 = 1;
            }
          }
          else
          {
            long long v31 = StringByKey;
            int v32 = 0;
            uint64_t v28 = ures_getByKey((uint64_t)v24, "to", 0, &v34);
            long long v29 = ures_getIntVector(v28, &v32, &v34);
            if (v27 <= a6
              && (double)(uint64_t)(v29[1] | ((unint64_t)*v29 << 32)) > a6
              && ++v30 == a2)
            {
              char v23 = 1;
            }
            ures_close(v28);
            StringByKey = v31;
          }
          ures_close((uint64_t)v24);
          ures_close(v25);
          if (v23) {
            break;
          }
          ++v22;
        }
        while (v22 < (int)ures_getSize(v16));
      }
      BOOL v18 = (v23 & 1) == 0;
    }
    else
    {
      StringByKey = 0;
      BOOL v18 = 1;
    }
    ures_close(v16);
    int v19 = *a5;
    int v20 = v34;
    if (!*a5 || v34)
    {
      *a5 = v34;
      int v19 = v20;
    }
    if (v19 <= 0)
    {
      char v21 = (int)v35 >= a4 || v18;
      if (v21) {
        return 0;
      }
      u_strcpy(a3, StringByKey);
    }
    return u_terminateUChars((uint64_t)a3, a4, v35, a5);
  }
  return result;
}

uint64_t ucurr_getKeywordValuesForLocale(uint64_t a1, char *a2, int a3, int *a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)__s2 = 0;
  ulocimp_getRegionForSupplementalData(a2, 1, __s2, 4, a4);
  EmptyList = ulist_createEmptyList(a4);
  uint64_t v8 = ulist_createEmptyList(a4);
  uint64_t v9 = uprv_malloc(0x38uLL);
  uint64_t KeywordValuesForLocale = (uint64_t)v9;
  if (*a4 <= 0 && v9 != 0)
  {
    uint64_t v28 = a1;
    long long v12 = *(_OWORD *)&off_1EDA47008;
    *uint64_t v9 = xmmword_1EDA46FF8;
    v9[1] = v12;
    v9[2] = xmmword_1EDA47018;
    *((void *)v9 + 6) = off_1EDA47028;
    *((void *)v9 + 1) = EmptyList;
    uint64_t v13 = ures_openDirect((uint64_t)"icudt74l-curr", (uint64_t)"supplementalData", (uint64_t)a4);
    ures_getByKey(v13, "CurrencyMap", v13, a4);
    uint64_t v38 = 0;
    memset(v37, 0, sizeof(v37));
    uint64_t v36 = 0;
    memset(v35, 0, sizeof(v35));
    uint64_t v34 = 0;
    memset(v33, 0, sizeof(v33));
    uint64_t v32 = 0;
    memset(v31, 0, sizeof(v31));
    ures_initStackObject((uint64_t)v37);
    ures_initStackObject((uint64_t)v35);
    ures_initStackObject((uint64_t)v33);
    ures_initStackObject((uint64_t)v31);
    if (*a4 > 0) {
      goto LABEL_9;
    }
    while (1)
    {
      if (!ures_hasNext(v13))
      {
        if (*a4 <= 0)
        {
          if (a3)
          {
            if (!ulist_getListSize((uint64_t)EmptyList))
            {
              uenum_close((void **)KeywordValuesForLocale);
              uint64_t KeywordValuesForLocale = ucurr_getKeywordValuesForLocale(v28, "und", 1, a4);
            }
          }
          else
          {
            ulist_resetList(v8);
            Next = (const char *)ulist_getNext((uint64_t)v8);
            if (Next)
            {
              int v24 = Next;
              do
              {
                int v25 = strlen(v24);
                if (!ulist_containsString((uint64_t)EmptyList, v24, v25))
                {
                  long long v26 = uprv_malloc(0x60uLL);
                  size_t v27 = strlen(v24);
                  memcpy(v26, v24, v27 + 1);
                  ulist_addItemEndList((uint64_t)EmptyList, v26, 1, a4);
                  if (*a4 > 0) {
                    break;
                  }
                }
                int v24 = (const char *)ulist_getNext((uint64_t)v8);
              }
              while (v24);
            }
          }
          ulist_resetList(*(void **)(KeywordValuesForLocale + 8));
          goto LABEL_10;
        }
LABEL_9:
        ulist_deleteList(EmptyList);
        uprv_free((void *)KeywordValuesForLocale);
        uint64_t KeywordValuesForLocale = 0;
LABEL_10:
        ures_close((uint64_t)v31);
        ures_close((uint64_t)v33);
        ures_close((uint64_t)v35);
        ures_close((uint64_t)v37);
        ures_close(v13);
        ulist_deleteList(v8);
        return KeywordValuesForLocale;
      }
      ures_getNextResource(v13, (uint64_t)v37, (UErrorCode *)a4);
      if (*a4 > 0) {
        goto LABEL_9;
      }
      Key = (const char *)ures_getKey((uint64_t)v37);
      int v16 = strcmp(Key, __s2);
      int v17 = v16;
      if (!a3 || !v16) {
        break;
      }
LABEL_18:
      if (*a4 > 0) {
        goto LABEL_9;
      }
    }
    ures_getByKey(v13, Key, (uint64_t)v35, a4);
    while (1)
    {
      while (1)
      {
        do
        {
          if (*a4 > 0) {
            goto LABEL_9;
          }
          if (!ures_hasNext((BOOL)v35)) {
            goto LABEL_18;
          }
          ures_getNextResource((uint64_t)v35, (uint64_t)v33, (UErrorCode *)a4);
        }
        while (ures_getType((uint64_t)v33) != 2);
        BOOL v18 = (char *)uprv_malloc(0x60uLL);
        int32_t v29 = 96;
        if (!v18)
        {
          *a4 = 7;
          goto LABEL_18;
        }
        int v19 = v18;
        ures_getUTF8StringByKey((uint64_t)v33, "id", v18, &v29, 1, a4);
        if (*a4 > 0) {
          goto LABEL_18;
        }
        ures_getByKey((uint64_t)v33, "to", (uint64_t)v31, a4);
        if (*a4 < 1) {
          break;
        }
        *a4 = 0;
        if (v17) {
          break;
        }
        int v20 = strlen(v19);
        if (ulist_containsString((uint64_t)EmptyList, v19, v20)) {
          break;
        }
        uint64_t v22 = (uint64_t)EmptyList;
LABEL_33:
        ulist_addItemEndList(v22, v19, 1, a4);
      }
      int v21 = strlen(v19);
      if (!(ulist_containsString((uint64_t)v8, v19, v21) | a3))
      {
        uint64_t v22 = (uint64_t)v8;
        goto LABEL_33;
      }
      uprv_free(v19);
    }
  }
  if (v9) {
    uprv_free(v9);
  }
  else {
    *a4 = 7;
  }
  ulist_deleteList(EmptyList);
  ulist_deleteList(v8);
  return 0;
}

uint64_t ucurr_getNumericCode(const UChar *a1)
{
  if (!a1 || u_strlen(a1) != 3) {
    return 0;
  }
  int v7 = 0;
  uint64_t v2 = ures_openDirect(0, (uint64_t)"currencyNumericCodes", (uint64_t)&v7);
  ures_getByKey(v2, "codeMap", v2, &v7);
  uint64_t v3 = 0;
  if (v7 <= 0)
  {
    *(_DWORD *)long long v6 = 0;
    u_UCharsToChars(a1, v6, 3);
    v6[3] = 0;
    T_CString_toUpperCase((unsigned __int8 *)v6);
    ures_getByKey(v2, v6, v2, &v7);
    unsigned int Int = ures_getInt(v2, &v7);
    if (v7 <= 0) {
      uint64_t v3 = Int;
    }
    else {
      uint64_t v3 = 0;
    }
  }
  ures_close(v2);
  return v3;
}

void sub_18C8794C8(uint64_t a1)
{
  sub_18C8795AC(*(char **)(a1 + 160), *(_DWORD *)(a1 + 168));
  sub_18C8795AC(*(char **)(a1 + 176), *(_DWORD *)(a1 + 184));

  uprv_free((void *)a1);
}

uint64_t sub_18C879514()
{
  for (uint64_t i = 0; i != 10; ++i)
  {
    uint64_t v1 = qword_1E9191DC8[i];
    if (v1)
    {
      sub_18C8794C8(v1);
      qword_1E9191DC8[i] = 0;
    }
  }
  if (qword_1E9191DC0)
  {
    uhash_close((unsigned char *)qword_1E9191DC0);
    qword_1E9191DC0 = 0;
  }
  atomic_store(0, &dword_1E9191E80);
  uint64_t v2 = (void *)qword_1E9191E70;
  if (qword_1E9191E70)
  {
    if (*(void *)qword_1E9191E70) {
      uhash_close(*(unsigned char **)qword_1E9191E70);
    }
    icu::UMemory::operator delete(v2);
  }
  qword_1E9191E70 = 0;
  atomic_store(0, (unsigned int *)&unk_1E9191E78);
  return 1;
}

void sub_18C8795AC(char *a1, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v3 = a2;
    uint64_t v4 = a1 + 20;
    uint64_t v5 = a1 + 20;
    do
    {
      char v6 = *v5;
      v5 += 24;
      if (v6) {
        uprv_free(*(void **)(v4 - 12));
      }
      uint64_t v4 = v5;
      --v3;
    }
    while (v3);
  }

  uprv_free(a1);
}

uint64_t sub_18C879618()
{
  if (atomic_load_explicit(dword_1E9191E78, memory_order_acquire) != 2
    && icu::umtx_initImplPreInit(dword_1E9191E78))
  {
    sub_18C8798A8();
    icu::umtx_initImplPostInit((unsigned int *)dword_1E9191E78);
  }
  return qword_1E9191E70;
}

UChar *sub_18C879668(UChar *src, int32_t srcLength, char *locale)
{
  UErrorCode pErrorCode = U_ZERO_ERROR;
  int32_t v6 = u_strToUpper(0, 0, src, srcLength, locale, &pErrorCode);
  int32_t v7 = v6;
  UErrorCode pErrorCode = U_ZERO_ERROR;
  if (v6 <= srcLength) {
    int32_t v8 = srcLength;
  }
  else {
    int32_t v8 = v6;
  }
  uint64_t v9 = (UChar *)uprv_malloc(2 * v8);
  u_strToUpper(v9, v7, src, srcLength, locale, &pErrorCode);
  if (pErrorCode >= U_ILLEGAL_ARGUMENT_ERROR) {
    u_memcpy(v9, src, srcLength);
  }
  return v9;
}

uint64_t sub_18C87971C(icu::CharString *a1)
{
  v9[8] = *(void **)MEMORY[0x1E4F143B8];
  if (!*((_DWORD *)a1 + 14)) {
    return 0;
  }
  UErrorCode v8 = U_ZERO_ERROR;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v6, "en_GB");
  if (sub_18C879E08((uint64_t)a1, v6, v7))
  {
    icu::CharString::truncate((uint64_t)a1, 3);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v4, "001");
    icu::CharString::append(a1, v4, v5, &v8);
  }
  else
  {
    memset(&v9[1], 0, 56);
    v9[0] = (char *)&v9[1] + 5;
    LODWORD(v9[1]) = 40;
    v3[0] = 0;
    v3[1] = 0;
    icu::CharStringByteSink::CharStringByteSink(v3, (uint64_t)v9);
    ulocimp_getParent(*(char **)a1, (uint64_t)v3, (int *)&v8);
    icu::CharString::operator=((uint64_t)a1, (uint64_t)v9);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v3);
    if (BYTE4(v9[1])) {
      uprv_free(v9[0]);
    }
  }
  return 1;
}

uint64_t sub_18C879848(uint64_t a1, uint64_t a2)
{
  signed int v2 = *(_DWORD *)(a1 + 16);
  signed int v3 = *(_DWORD *)(a2 + 16);
  if (v2 >= v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if ((int)v4 < 1)
  {
LABEL_9:
    BOOL v10 = v2 < v3;
    BOOL v11 = v2 > v3;
    if (v10) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v11;
    }
  }
  else
  {
    int v5 = *(unsigned __int16 **)(a1 + 8);
    int32_t v6 = *(unsigned __int16 **)(a2 + 8);
    while (1)
    {
      unsigned int v8 = *v5++;
      unsigned int v7 = v8;
      unsigned int v9 = *v6++;
      BOOL v10 = v7 > v9;
      if (v7 < v9) {
        return 0xFFFFFFFFLL;
      }
      if (v10) {
        return 1;
      }
      if (!--v4) {
        goto LABEL_9;
      }
    }
  }
}

void sub_18C8798A8()
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  int v51 = 0;
  sub_18C8546F4(0xEu, (uint64_t)sub_18C879514);
  signed int v2 = (int32x2_t *)icu::UMemory::operator new(v1, (icu::UMemory *)0x58, v0);
  if (!v2) {
    return;
  }
  signed int v3 = (uint64_t *)v2;
  *signed int v2 = 0;
  uint64_t v4 = (uint64_t)&v2[1];
  uhash_init(v2 + 1, (uint64_t)uhash_hashUnicodeString, (uint64_t)uhash_compareUnicodeString, 0, &v51);
  if (v51 > 0) {
    goto LABEL_98;
  }
  *signed int v3 = v4;
  uhash_setKeyDeleter(v4, (uint64_t)uprv_deleteUObject);
  if (v51 >= 1) {
    goto LABEL_98;
  }
  uhash_setValueDeleter(*v3, (uint64_t)sub_18C879DDC);
  if (v51 > 0) {
    goto LABEL_98;
  }
  int v5 = &dword_18CA81454;
  long long v6 = 0uLL;
  while (2)
  {
    v56[2] = v6;
    v56[3] = v6;
    v56[0] = v6;
    v56[1] = v6;
    icu::UnicodeString::UnicodeString((uint64_t)v56, v5[1]);
    unsigned int v7 = (const icu::UnicodeSet *)icu::unisets::get(*v5);
    if (!v7)
    {
LABEL_96:
      icu::UnicodeString::~UnicodeString(v8, (icu::UnicodeString *)v56);
      break;
    }
    memset(v52, 0, sizeof(v52));
    icu::UnicodeSetIterator::UnicodeSetIterator((icu::UnicodeSetIterator *)v52, v7);
    while (icu::UnicodeSetIterator::next((icu::UnicodeSetIterator *)v52))
    {
      memset(v55, 0, sizeof(v55));
      String = icu::UnicodeSetIterator::getString((icu::UnicodeSetIterator *)v52, v9, v10);
      icu::UnicodeString::UnicodeString((icu::UnicodeString *)v55, (UChar **)String);
      if (BYTE8(v55[0]))
      {
        unint64_t v14 = WORD4(v56[0]);
        if (BYTE8(v56[0])) {
          goto LABEL_90;
        }
      }
      else
      {
        if ((SWORD4(v55[0]) & 0x8000u) == 0) {
          int v12 = WORD4(v55[0]) >> 5;
        }
        else {
          int v12 = HIDWORD(v55[0]);
        }
        if ((SWORD4(v56[0]) & 0x8000u) == 0) {
          int v13 = WORD4(v56[0]) >> 5;
        }
        else {
          int v13 = HIDWORD(v56[0]);
        }
        if ((BYTE8(v56[0]) & 1) == 0
          && v12 == v13
          && icu::UnicodeString::doEquals((icu::UnicodeString *)v55, (const icu::UnicodeString *)v56, v12))
        {
          goto LABEL_90;
        }
      }
      unint64_t v14 = v51;
      if (v51 > 0) {
        goto LABEL_95;
      }
      if (BYTE8(v56[0]))
      {
        if (BYTE8(v55[0])) {
          goto LABEL_89;
        }
      }
      else
      {
        if ((SWORD4(v56[0]) & 0x8000u) == 0) {
          int v15 = WORD4(v56[0]) >> 5;
        }
        else {
          int v15 = HIDWORD(v56[0]);
        }
        if ((SWORD4(v55[0]) & 0x8000u) == 0) {
          int v16 = WORD4(v55[0]) >> 5;
        }
        else {
          int v16 = HIDWORD(v55[0]);
        }
        if ((BYTE8(v55[0]) & 1) == 0
          && v15 == v16
          && icu::UnicodeString::doEquals((icu::UnicodeString *)v56, (const icu::UnicodeString *)v55, v15))
        {
          goto LABEL_89;
        }
      }
      v54[1] = v56;
      v54[2] = v56;
      v53[2] = v55;
      v54[0] = v3;
      v53[0] = v3;
      v53[1] = v55;
      uint64_t v17 = sub_18C876678((uint64_t)v54);
      uint64_t v18 = sub_18C876678((uint64_t)v53);
      uint64_t v21 = v18;
      if (v17 && v18)
      {
        uint64_t v22 = v18;
        uint64_t v23 = v17;
        while (1)
        {
          unsigned int v24 = *(unsigned __int16 *)(v23 + 8);
          if (v24)
          {
            if (BYTE8(v55[0])) {
              goto LABEL_89;
            }
          }
          else
          {
            if ((v24 & 0x8000) != 0) {
              int v25 = *(_DWORD *)(v23 + 12);
            }
            else {
              int v25 = v24 >> 5;
            }
            if ((SWORD4(v55[0]) & 0x8000u) == 0) {
              int v26 = WORD4(v55[0]) >> 5;
            }
            else {
              int v26 = HIDWORD(v55[0]);
            }
            if ((BYTE8(v55[0]) & 1) == 0
              && v25 == v26
              && icu::UnicodeString::doEquals((icu::UnicodeString *)v23, (const icu::UnicodeString *)v55, v25))
            {
              goto LABEL_89;
            }
          }
          unsigned int v27 = *(unsigned __int16 *)(v22 + 8);
          if (v27)
          {
            if (BYTE8(v56[0])) {
              goto LABEL_89;
            }
          }
          else
          {
            if ((v27 & 0x8000) != 0) {
              int v28 = *(_DWORD *)(v22 + 12);
            }
            else {
              int v28 = v27 >> 5;
            }
            if ((SWORD4(v56[0]) & 0x8000u) == 0) {
              int v29 = WORD4(v56[0]) >> 5;
            }
            else {
              int v29 = HIDWORD(v56[0]);
            }
            if ((BYTE8(v56[0]) & 1) == 0
              && v28 == v29
              && icu::UnicodeString::doEquals((icu::UnicodeString *)v22, (const icu::UnicodeString *)v56, v28))
            {
              goto LABEL_89;
            }
          }
          uint64_t v23 = sub_18C876678((uint64_t)v54);
          uint64_t v30 = sub_18C876678((uint64_t)v53);
          if (v23)
          {
            uint64_t v22 = v30;
            if (v30) {
              continue;
            }
          }
          break;
        }
      }
      long long v31 = (icu::UnicodeString *)icu::UMemory::operator new(v20, (icu::UMemory *)0x40, v19);
      uint64_t v34 = (uint64_t)v31;
      if (v21 | v17)
      {
        if (!v21)
        {
          if (v31)
          {
            uint64_t v39 = (UChar **)v55;
LABEL_75:
            icu::UnicodeString::UnicodeString(v31, v39);
          }
LABEL_76:
          uint64_t v36 = (icu::UnicodeString *)icu::UMemory::operator new(v33, (icu::UMemory *)0x40, v32);
          if (!v36)
          {
LABEL_84:
            if (v34) {
              goto LABEL_87;
            }
            goto LABEL_88;
          }
          uint64_t v37 = (uint64_t)v36;
          uint64_t v38 = (UChar **)v17;
          goto LABEL_78;
        }
        if (v17)
        {
          if (v31)
          {
            uint64_t v39 = (UChar **)v21;
            goto LABEL_75;
          }
          goto LABEL_76;
        }
        if (v31)
        {
          unsigned int v35 = (UChar **)v21;
          goto LABEL_66;
        }
      }
      else if (v31)
      {
        unsigned int v35 = (UChar **)v55;
LABEL_66:
        icu::UnicodeString::UnicodeString(v31, v35);
      }
      uint64_t v36 = (icu::UnicodeString *)icu::UMemory::operator new(v33, (icu::UMemory *)0x40, v32);
      if (!v36) {
        goto LABEL_84;
      }
      uint64_t v37 = (uint64_t)v36;
      uint64_t v38 = (UChar **)v56;
LABEL_78:
      icu::UnicodeString::UnicodeString(v36, v38);
      if (!v34)
      {
        uint64_t v34 = v37;
LABEL_87:
        (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
LABEL_88:
        int v51 = 7;
        goto LABEL_89;
      }
      uint64_t v42 = *v3;
      long long v43 = (icu::UnicodeString *)icu::UMemory::operator new(v41, (icu::UMemory *)0x40, v40);
      uint64_t v44 = (uint64_t)v43;
      if (v43) {
        icu::UnicodeString::UnicodeString(v43, (UChar **)v56);
      }
      uhash_put(v42, v44, v34, &v51);
      uint64_t v45 = *v3;
      long long v48 = (icu::UnicodeString *)icu::UMemory::operator new(v47, (icu::UMemory *)0x40, v46);
      uint64_t v49 = (uint64_t)v48;
      if (v48) {
        icu::UnicodeString::UnicodeString(v48, (UChar **)v55);
      }
      uhash_put(v45, v49, v37, &v51);
LABEL_89:
      unint64_t v14 = v51;
      if (v51 >= 1)
      {
LABEL_95:
        icu::UnicodeString::~UnicodeString((void *)v14, (icu::UnicodeString *)v55);
        icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v52);
        goto LABEL_96;
      }
LABEL_90:
      icu::UnicodeString::~UnicodeString((void *)v14, (icu::UnicodeString *)v55);
    }
    icu::UnicodeSetIterator::~UnicodeSetIterator((icu::UnicodeSetIterator *)v52);
    icu::UnicodeString::~UnicodeString(v50, (icu::UnicodeString *)v56);
    v5 += 2;
    long long v6 = 0uLL;
    if (v5 != (int *)&unk_18CA8147C) {
      continue;
    }
    break;
  }
  if (v51 < 1)
  {
    qword_1E9191E70 = (uint64_t)v3;
  }
  else
  {
LABEL_98:
    if (*v3) {
      uhash_close((unsigned char *)*v3);
    }
    icu::UMemory::operator delete(v3);
  }
}

uint64_t sub_18C879DDC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

BOOL sub_18C879E08(uint64_t a1, const void *a2, int a3)
{
  if (*(_DWORD *)(a1 + 56) != a3) {
    return 0;
  }
  if (a3) {
    return memcmp(*(const void **)a1, a2, a3) == 0;
  }
  return 1;
}

void sub_18C879E54(void **a1)
{
  uprv_free(a1[1]);

  uprv_free(a1);
}

uint64_t sub_18C879E90(uint64_t a1)
{
  uint64_t result = 0;
  int v3 = **(_DWORD **)(a1 + 8);
  uint64_t v4 = &off_1E55036D0;
  do
  {
    if (v3 == 0x7FFFFFFF || (v3 & ~*((_DWORD *)v4 - 2)) == 0) {
      uint64_t result = (result + 1);
    }
    int v5 = *v4;
    v4 += 2;
  }
  while (v5);
  return result;
}

uint64_t sub_18C879ED0(uint64_t a1, _DWORD *a2)
{
  signed int v2 = *(_DWORD **)(a1 + 8);
  uint64_t v3 = v2[1];
  if (v3 <= 0x132) {
    uint64_t v4 = 306;
  }
  else {
    uint64_t v4 = v3;
  }
  int v5 = &(&off_1E55036C0)[2 * v3 + 1];
  while (v4 != v3)
  {
    long long v6 = v5;
    v2[1] = v3 + 1;
    if (*v2 != 0x7FFFFFFF)
    {
      v5 += 2;
      ++v3;
      if ((*v2 & ~*v6) != 0) {
        continue;
      }
    }
    if (a2) {
      *a2 = 3;
    }
    return *((void *)v6 - 1);
  }
  uint64_t result = 0;
  if (a2) {
    *a2 = 0;
  }
  return result;
}

uint64_t sub_18C879F50(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 8) + 4) = 0;
  return result;
}

uint64_t sub_18C879F5C(uint64_t a1, const char *DataDirectory, const char *a3, char *__s, const char *a5, char a6, UErrorCode *a7)
{
  *(void *)(a1 + 24) = 0;
  uint64_t v13 = a1 + 24;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 48) = a1 + 61;
  unint64_t v14 = (icu::CharString *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = 40;
  *(_WORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = a1 + 125;
  *(_DWORD *)(a1 + 120) = 40;
  *(_WORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a1 + 189;
  int v15 = (icu::CharString *)(a1 + 176);
  *(_DWORD *)(a1 + 184) = 40;
  *(_WORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  if (!DataDirectory) {
    DataDirectory = u_getDataDirectory();
  }
  *(void *)a1 = DataDirectory;
  if (a3)
  {
    int v16 = icu::CharString::append(v15, 47, a7);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v24, a3);
    icu::CharString::append(v16, v24, v25, a7);
  }
  uint64_t v17 = strrchr(__s, 47);
  if (v17) {
    uint64_t v18 = v17 + 1;
  }
  else {
    uint64_t v18 = __s;
  }
  *(void *)(a1 + 16) = v18;
  *(_DWORD *)(a1 + 40) = strlen(v18);
  unint64_t v19 = (icu::CharString *)a1;
  if (v18 != __s)
  {
    icu::CharString::append(v14, __s, v18 - __s, a7);
    unint64_t v19 = v14;
  }
  *(void *)(a1 + 8) = *(void *)v19;
  if (a5) {
    int v20 = a5;
  }
  else {
    int v20 = "";
  }
  icu::StringPiece::StringPiece((icu::StringPiece *)&v22, v20);
  *(void *)uint64_t v13 = v22;
  *(_DWORD *)(v13 + 8) = v23;
  *(unsigned char *)(a1 + 240) = a6;
  return a1;
}

uint64_t sub_18C87A0DC(uint64_t a1, UErrorCode *a2)
{
  if (*(int *)a2 <= 0)
  {
    int v5 = (icu::CharString *)(a1 + 112);
    while (1)
    {
      long long v6 = *(const char **)(a1 + 8);
      if (!v6) {
        return 0;
      }
      if (v6 == *(const char **)(a1 + 48)) {
        break;
      }
      unsigned int v7 = strchr(*(char **)(a1 + 8), 58);
      *(void *)(a1 + 8) = v7;
      if (!v7) {
        goto LABEL_10;
      }
      size_t v8 = v7 - v6;
      *(void *)(a1 + 8) = v7 + 1;
      if (v7 == v6) {
        goto LABEL_22;
      }
LABEL_11:
      *(_DWORD *)(a1 + 168) = 0;
      **(unsigned char **)(a1 + 112) = 0;
      icu::CharString::append(v5, v6, v8, a2);
      unint64_t v9 = *(char **)(a1 + 112);
      BOOL v10 = strrchr(v9, 47);
      if (v10) {
        BOOL v11 = v10 + 1;
      }
      else {
        BOOL v11 = v9;
      }
      if ((int)v8 >= 4)
      {
        if (*(unsigned char *)(a1 + 240))
        {
          if (!strncmp(&v9[(v8 - 4)], *(const char **)(a1 + 24), 4uLL))
          {
            unsigned int v12 = *(_DWORD *)(a1 + 40);
            if (!strncmp(v11, *(const char **)(a1 + 16), v12) && strlen(v11) == v12 + 4) {
              return *(void *)v5;
            }
          }
        }
      }
      if (v9[(uint64_t)((v8 << 32) - 0x100000000) >> 32] == 47) {
        goto LABEL_29;
      }
      if ((int)v8 < 4 || strncmp(&v9[(v8 - 4)], ".dat", 4uLL))
      {
        int v13 = *(_DWORD *)(a1 + 232);
        if (v13)
        {
          if ((int)v8 > v13)
          {
            int v14 = *(_DWORD *)(a1 + 232);
            if (!strcmp(&v9[(int)v8 - v13], *(const char **)(a1 + 176))) {
              icu::CharString::truncate((uint64_t)v5, v8 - v14);
            }
          }
        }
        icu::CharString::append(v5, 47, a2);
LABEL_29:
        icu::CharString::append(v5, (const char *)(*(void *)(a1 + 176) + 1), *(_DWORD *)(a1 + 232) - 1, a2);
        int v15 = *(_DWORD *)(a1 + 32);
        if (v15)
        {
          if (v15 >= 5) {
            icu::CharString::ensureEndsWithFileSeparator(v5, a2);
          }
          icu::CharString::append(v5, *(const char **)(a1 + 24), *(_DWORD *)(a1 + 32), a2);
        }
        return *(void *)v5;
      }
LABEL_22:
      if (!*(void *)a1) {
        return 0;
      }
    }
    *(void *)(a1 + 8) = *(void *)a1;
LABEL_10:
    size_t v8 = strlen(v6);
    if (!v8) {
      goto LABEL_22;
    }
    goto LABEL_11;
  }
  return 0;
}

void udata_setCommonData(uint64_t a1, int *a2)
{
  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      uint64_t v5 = 0;
      memset(v4, 0, sizeof(v4));
      sub_18C87BA40((uint64_t)v4);
      sub_18C87BB10((uint64_t)v4, a1);
      sub_18C8547D4(v4, a2);
      if (*a2 <= 0) {
        sub_18C87A39C((uint64_t)v4, 1, a2);
      }
    }
    else
    {
      *a2 = 1;
    }
  }
}

void sub_18C87A39C(uint64_t a1, int a2, int *a3)
{
  NewInstance = UDataMemory_createNewInstance(a3);
  if (*a3 <= 0)
  {
    unsigned int v7 = NewInstance;
    sub_18C87BA5C((uint64_t)NewInstance, a1);
    umtx_lock(0);
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = qword_1EB20B498[v8];
      if (!v9) {
        break;
      }
      if (*(void *)(v9 + 8) != *(void *)(a1 + 8) && ++v8 != 10) {
        continue;
      }
      goto LABEL_8;
    }
    qword_1EB20B498[v8] = (uint64_t)v7;
LABEL_8:
    umtx_unlock(0);
    if (a2 && v8 == 10) {
      *a3 = -127;
    }
    if (v9)
    {
      uprv_free(v7);
    }
    else
    {
      sub_18C8546F4(0x18u, (uint64_t)sub_18C87B0A4);
    }
  }
}

void **udata_setAppData(void **result, uint64_t a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    if (a2)
    {
      uint64_t v5 = (char *)result;
      uint64_t v7 = 0;
      memset(v6, 0, sizeof(v6));
      sub_18C87BA40((uint64_t)v6);
      sub_18C87BB10((uint64_t)v6, a2);
      sub_18C8547D4(v6, a3);
      return sub_18C87A550(v5, (uint64_t)v6, a3);
    }
    else
    {
      *a3 = 1;
    }
  }
  return result;
}

void **sub_18C87A550(char *a1, uint64_t a2, int *a3)
{
  int v16 = 0;
  uint64_t v6 = sub_18C87B118(a3);
  if (*a3 > 0) {
    return 0;
  }
  uint64_t v7 = v6;
  uint64_t result = (void **)uprv_malloc(0x10uLL);
  if (!result)
  {
    *a3 = 7;
    return result;
  }
  uint64_t v9 = result;
  NewInstance = UDataMemory_createNewInstance(a3);
  v9[1] = NewInstance;
  if (*a3 >= 1) {
    goto LABEL_4;
  }
  sub_18C87BA5C((uint64_t)NewInstance, a2);
  BOOL v11 = strrchr(a1, 47);
  if (v11) {
    unsigned int v12 = v11 + 1;
  }
  else {
    unsigned int v12 = a1;
  }
  int v13 = strlen(v12);
  int v14 = (char *)uprv_malloc(v13 + 1);
  *uint64_t v9 = v14;
  if (!v14)
  {
    *a3 = 7;
    uprv_free(v9[1]);
LABEL_4:
    uprv_free(v9);
    return 0;
  }
  strcpy(v14, v12);
  umtx_lock(0);
  uint64_t v15 = uhash_get(v7, (uint64_t)a1);
  if (v15) {
    int v16 = -127;
  }
  else {
    uhash_put(v7, (uint64_t)*v9, (uint64_t)v9, &v16);
  }
  umtx_unlock(0);
  if (v16 != -127 && v16 < 1) {
    return (void **)v9[1];
  }
  *a3 = v16;
  uprv_free(*v9);
  uprv_free(v9[1]);
  uprv_free(v9);
  if (v15) {
    return *(void ***)(v15 + 8);
  }
  return 0;
}

void *udata_open(char *a1, const char *a2, const char *a3, UErrorCode *a4)
{
  if (a4 && *(int *)a4 <= 0)
  {
    if (a3 && *a3) {
      return sub_18C87A704(a1, a2, a3, 0, 0, a4);
    }
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return 0;
}

void *sub_18C87A704(char *__s1, const char *a2, const char *a3, unsigned int (*a4)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a5, UErrorCode *a6)
{
  uint64_t v9 = __s1;
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  int v81 = 0;
  if (!__s1 || !strcmp(__s1, "ICUDATA") || !strncmp(v9, "icudt74l-", 9uLL) || !strncmp(v9, "ICUDATA-", 8uLL))
  {
    char v11 = 0;
    int v10 = 1;
  }
  else
  {
    int v10 = 0;
    char v11 = 1;
  }
  memset(&v89[1], 0, 48);
  uint64_t v90 = 0;
  v89[0] = (char *)&v89[1] + 5;
  LODWORD(v89[1]) = 40;
  memset(&v88[1], 0, 56);
  v88[0] = (char *)&v88[1] + 5;
  LODWORD(v88[1]) = 40;
  memset(&v86[1], 0, 48);
  v87[1] = 0;
  v86[0] = (char *)&v86[1] + 5;
  LODWORD(v86[1]) = 40;
  v87[0] = 0;
  memset(&v84[1], 0, 48);
  v85[1] = 0;
  v84[0] = (char *)&v84[1] + 5;
  LODWORD(v84[1]) = 40;
  v85[0] = 0;
  if (!v9)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v79, "icudt74l");
    int v16 = v79;
    int v17 = v80;
LABEL_23:
    icu::CharString::append((icu::CharString *)v86, v16, v17, a6);
    goto LABEL_24;
  }
  unsigned int v12 = strrchr(v9, 47);
  int v13 = strchr(v9, 47);
  if (uprv_pathIsAbsolute((unsigned __int8 *)v9) || v12 != v13)
  {
    if (v12)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v77, v12 + 1);
      int v16 = v77;
      int v17 = v78;
    }
    else
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v75, v9);
      int v16 = v75;
      int v17 = v76;
    }
    goto LABEL_23;
  }
  int v14 = strchr(v9, 45);
  if (!v14)
  {
    if (v11)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v67, v9);
      int v16 = v67;
      int v17 = v68;
    }
    else
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v69, "icudt74l");
      int v16 = v69;
      int v17 = v70;
    }
    goto LABEL_23;
  }
  int v15 = (int)v14;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v73, v14 + 1);
  icu::CharString::append((icu::CharString *)v84, v73, v74, a6);
  if ((v11 & 1) == 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v71, "icudt74l");
    int v16 = v71;
    int v17 = v72;
    goto LABEL_23;
  }
  icu::CharString::append((icu::CharString *)v86, v9, v15 - v9, a6);
  if (!v12) {
    uint64_t v9 = v86[0];
  }
LABEL_24:
  icu::CharString::append((icu::CharString *)v89, v86[0], v87[0], a6);
  icu::CharString::append((icu::CharString *)v88, v86[0], v87[0], a6);
  uint64_t v18 = (int)v90;
  if (v85[0])
  {
    unint64_t v19 = icu::CharString::append((icu::CharString *)v89, 47, a6);
    icu::CharString::append(v19, v84[0], v85[0], a6);
    int v20 = icu::CharString::append((icu::CharString *)v88, 47, a6);
    icu::CharString::append(v20, v84[0], v85[0], a6);
  }
  uint64_t v21 = icu::CharString::append((icu::CharString *)v89, 47, a6);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v65, a3);
  icu::CharString::append(v21, v65, v66, a6);
  uint64_t v22 = icu::CharString::append((icu::CharString *)v88, 47, a6);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v63, a3);
  icu::CharString::append(v22, v63, v64, a6);
  if (a2 && *a2)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v61, ".");
    int v23 = icu::CharString::append((icu::CharString *)v89, v61, v62, a6);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v59, a2);
    icu::CharString::append(v23, v59, v60, a6);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v57, ".");
    unsigned int v24 = icu::CharString::append((icu::CharString *)v88, v57, v58, a6);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v55, a2);
    icu::CharString::append(v24, v55, v56, a6);
  }
  int v25 = (char *)v88[0] + v18 + 1;
  if (!v9) {
    uint64_t v9 = "icudt74l";
  }
  DataDirectory = u_getDataDirectory();
  if (v10
    && !strcmp(a2, "res")
    && (!strcmp(a3, "zoneinfo64")
     || !strcmp(a3, "timezoneTypes")
     || !strcmp(a3, "windowsZones")
     || !strcmp(a3, "metaZones"))
    && (TimeZoneFilesDirectory = u_getTimeZoneFilesDirectory(a6), *TimeZoneFilesDirectory))
  {
    UErrorCode v54 = U_ZERO_ERROR;
    memset(&v83[1], 0, 56);
    v83[0] = (char *)&v83[1] + 5;
    LODWORD(v83[1]) = 40;
    uint64_t v39 = TimeZoneFilesDirectory;
    icu::StringPiece::StringPiece((icu::StringPiece *)&v52, TimeZoneFilesDirectory);
    icu::CharString::append((icu::CharString *)v83, v52, v53, &v54);
    long long v31 = icu::CharString::append((icu::CharString *)v83, 47, &v54);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v50, "icutz44l");
    icu::CharString::append(v31, v50, v51, &v54);
    memset(&v82[1], 0, 56);
    v82[0] = (char *)&v82[1] + 5;
    LODWORD(v82[1]) = 40;
    icu::StringPiece::StringPiece((icu::StringPiece *)&v48, "icutz44l");
    icu::CharString::append((icu::CharString *)v82, v48, v49, &v54);
    if (v85[0])
    {
      unint64_t v32 = icu::CharString::append((icu::CharString *)v82, 47, &v54);
      icu::CharString::append(v32, v84[0], v85[0], &v54);
    }
    int v33 = icu::CharString::append((icu::CharString *)v82, 47, &v54);
    icu::StringPiece::StringPiece((icu::StringPiece *)&v46, a3);
    icu::CharString::append(v33, v46, v47, &v54);
    if (a2 && *a2)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v44, ".");
      uint64_t v34 = icu::CharString::append((icu::CharString *)v82, v44, v45, &v54);
      icu::StringPiece::StringPiece((icu::StringPiece *)&v42, a2);
      icu::CharString::append(v34, v42, v43, &v54);
    }
    unsigned int v35 = sub_18C87B28C(0, (uint64_t)v82[0], (char *)v83[0], (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)&v54);
    if (v54 > U_ZERO_ERROR || (unsigned int v27 = v35, v36 = 0, !v35))
    {
      unsigned int v27 = sub_18C87B494("", v39, v25, "", (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, a6);
      if (v27) {
        BOOL v36 = 0;
      }
      else {
        BOOL v36 = *a6 < U_ILLEGAL_ARGUMENT_ERROR;
      }
    }
    if (BYTE4(v82[1])) {
      uprv_free(v82[0]);
    }
    if (BYTE4(v83[1])) {
      uprv_free(v83[0]);
    }
    if (!v36) {
      goto LABEL_81;
    }
  }
  else
  {
    unsigned int v27 = 0;
  }
  unsigned int v28 = dword_1E9191768;
  if (dword_1E9191768 == 2)
  {
    unsigned int v27 = sub_18C87B28C(v10, (uint64_t)v89[0], v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)a6);
    if (v27) {
      goto LABEL_81;
    }
    if (*(int *)a6 > 0) {
      goto LABEL_74;
    }
    unsigned int v27 = 0;
    unsigned int v28 = dword_1E9191768;
  }
  if ((v28 & 0xFFFFFFFD) == 0)
  {
    if (DataDirectory)
    {
      if (*DataDirectory) {
        char v29 = 0;
      }
      else {
        char v29 = v10;
      }
      if (v29) {
        goto LABEL_39;
      }
    }
    else if (v10)
    {
      goto LABEL_39;
    }
    unsigned int v27 = sub_18C87B494(v86[0], DataDirectory, v25, v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, a6);
    if (v27) {
      goto LABEL_81;
    }
    if (*(int *)a6 > 0) {
      goto LABEL_74;
    }
    unsigned int v27 = 0;
    unsigned int v28 = dword_1E9191768;
  }
LABEL_39:
  if (v28 <= 1)
  {
    unsigned int v27 = sub_18C87B28C(v10, (uint64_t)v89[0], v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)a6);
    if (v27) {
      goto LABEL_81;
    }
    if (*(int *)a6 <= 0)
    {
      unsigned int v27 = 0;
      unsigned int v28 = dword_1E9191768;
      goto LABEL_43;
    }
LABEL_74:
    unsigned int v27 = 0;
    goto LABEL_81;
  }
LABEL_43:
  if (v28 == 3)
  {
    unsigned int v27 = sub_18C87B28C(v10, (uint64_t)v89[0], v9, (uint64_t)a2, (uint64_t)a3, a4, a5, &v81, (int *)a6);
    if (v27 || *(int *)a6 >= 1) {
      goto LABEL_81;
    }
  }
  else if (*(int *)a6 > 0)
  {
    goto LABEL_81;
  }
  int v37 = v81;
  if (v81 <= 0) {
    int v37 = 4;
  }
  *a6 = v37;
LABEL_81:
  if (BYTE4(v84[1])) {
    uprv_free(v84[0]);
  }
  if (BYTE4(v86[1])) {
    uprv_free(v86[0]);
  }
  if (BYTE4(v88[1])) {
    uprv_free(v88[0]);
  }
  if (BYTE4(v89[1])) {
    uprv_free(v89[0]);
  }
  return v27;
}

void *udata_openChoice(char *a1, const char *a2, const char *a3, unsigned int (*a4)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a5, UErrorCode *a6)
{
  if (a6 && *(int *)a6 <= 0)
  {
    if (a3 && a4 && *a3) {
      return sub_18C87A704(a1, a2, a3, a4, a5, a6);
    }
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return 0;
}

void *udata_getInfo(void *result, _WORD *a2)
{
  if (a2)
  {
    if (result && (uint64_t v3 = (unsigned char *)result[1]) != 0)
    {
      unsigned int v4 = sub_18C8547A8(v3 + 4);
      unsigned int v5 = (unsigned __int16)*a2;
      if (v5 > v4)
      {
        *a2 = v4;
        unsigned int v5 = v4;
      }
      uint64_t v6 = a2 + 1;
      uint64_t result = memcpy(v6, v3 + 6, v5 - 2);
      if (v3[8]) {
        *uint64_t v6 = bswap32(*((unsigned __int16 *)v3 + 3)) >> 16;
      }
    }
    else
    {
      *a2 = 0;
    }
  }
  return result;
}

uint64_t udata_setFileAccess(uint64_t result)
{
  dword_1E9191768 = result;
  return result;
}

uint64_t sub_18C87B0A4()
{
  if (qword_1EB20B4E8)
  {
    uhash_close((unsigned char *)qword_1EB20B4E8);
    qword_1EB20B4E8 = 0;
  }
  uint64_t v0 = 0;
  atomic_store(0, &dword_1EB20B4F0);
  do
  {
    uint64_t v1 = (_OWORD *)qword_1EB20B498[v0];
    if (!v1) {
      break;
    }
    udata_close(v1);
    qword_1EB20B498[v0++] = 0;
  }
  while (v0 != 10);
  atomic_store(0, (unsigned int *)&unk_1EB20B4F8);
  return 1;
}

uint64_t sub_18C87B118(int *a1)
{
  if (*a1 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1EB20B4F0, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1EB20B4F0))
    {
      if (dword_1EB20B4F4 >= 1) {
        *a1 = dword_1EB20B4F4;
      }
    }
    else
    {
      sub_18C87B1A4(a1);
      dword_1EB20B4F4 = *a1;
      icu::umtx_initImplPostInit(&dword_1EB20B4F0);
    }
  }
  return qword_1EB20B4E8;
}

void sub_18C87B1A4(int *a1)
{
  signed int v2 = uhash_open((uint64_t)uhash_hashChars, (uint64_t)uhash_compareChars, 0, a1);
  qword_1EB20B4E8 = (uint64_t)v2;
  if (*a1 <= 0)
  {
    uhash_setValueDeleter((uint64_t)v2, (uint64_t)sub_18C87B248);
    sub_18C8546F4(0x18u, (uint64_t)sub_18C87B0A4);
  }
}

void sub_18C87B248(uint64_t a1)
{
  udata_close(*(_OWORD **)(a1 + 8));
  uprv_free(*(void **)a1);

  uprv_free((void *)a1);
}

void *sub_18C87B28C(int a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, unsigned int (*a6)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7, int *a8, int *a9)
{
  int v13 = 0;
  if (a1) {
    unsigned int v14 = 0;
  }
  else {
    unsigned int v14 = -1;
  }
  while (1)
  {
    int v15 = (uint64_t (***)(void, void, void, void))sub_18C87B628(a3, v14, a8);
    int v16 = v15;
    int v17 = *a8;
    if (*a8 <= 0 && v15 != 0) {
      break;
    }
LABEL_12:
    if (v17 == 7)
    {
      uint64_t result = 0;
      *a9 = 7;
      return result;
    }
    if (!a1) {
      return 0;
    }
    if (v16)
    {
      ++v14;
    }
    else
    {
      if (v13) {
        return 0;
      }
      uint64_t v32 = 0;
      long long v31 = 0u;
      memset(v30, 0, sizeof(v30));
      if (!atomic_load_explicit(dword_1EB20B4F8, memory_order_acquire))
      {
        uint64_t v21 = sub_18C87B628("icudt74l", 0xFFFFFFFF, a8);
        sub_18C87BA40((uint64_t)v30);
        if (v21)
        {
          sub_18C87BA5C((uint64_t)v30, v21);
          long long v31 = 0uLL;
          sub_18C87A39C((uint64_t)v30, 0, a8);
        }
        atomic_store(1u, (unsigned int *)dword_1EB20B4F8);
      }
      uint64_t v22 = sub_18C87B964("icudt74l", a8);
      if (*a8 > 0) {
        return 0;
      }
      uint64_t v23 = v22;
      if (!v22) {
        return 0;
      }
      umtx_lock(0);
      uint64_t v24 = 0;
      while (1)
      {
        uint64_t v25 = qword_1EB20B498[v24];
        if (v25)
        {
          if (*(void *)(v25 + 8) == *(void *)(v23 + 8)) {
            break;
          }
        }
        if (++v24 == 10)
        {
          umtx_unlock(0);
          return 0;
        }
      }
      umtx_unlock(0);
      int v13 = 1;
    }
  }
  LODWORD(v30[0]) = 0;
  uint64_t v19 = (**v15)(v15, a2, v30, a8);
  if (!v19) {
    goto LABEL_11;
  }
  uint64_t result = sub_18C87B8BC(v19, a6, a7, a4, a5, a8, a9);
  if (*a9 > 0) {
    return 0;
  }
  if (!result)
  {
LABEL_11:
    int v17 = *a8;
    goto LABEL_12;
  }
  *((_DWORD *)result + 12) = v30[0];
  return result;
}

void *sub_18C87B494(const char *a1, const char *a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, unsigned int (*a7)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a8, _DWORD *a9, UErrorCode *a10)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = 0;
  long long v20 = 0u;
  memset(v19, 0, sizeof(v19));
  uint64_t v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  memset(v22, 0, sizeof(v22));
  sub_18C879F5C((uint64_t)v22, a2, a1, a4, a3, 0, a10);
  uint64_t v14 = sub_18C87A0DC((uint64_t)v22, a10);
  if (!v14)
  {
LABEL_8:
    int v17 = 0;
    goto LABEL_9;
  }
  int v15 = (const char *)v14;
  while (!uprv_mapFile(v19, v15, (int *)a10))
  {
LABEL_7:
    int v15 = (const char *)sub_18C87A0DC((uint64_t)v22, a10);
    if (!v15) {
      goto LABEL_8;
    }
  }
  int v16 = sub_18C87B8BC(*((uint64_t *)&v19[0] + 1), a7, a8, a5, a6, a9, (int *)a10);
  if (!v16)
  {
    udata_close(v19);
    if (*(int *)a10 > 0) {
      goto LABEL_8;
    }
    *a9 = 3;
    goto LABEL_7;
  }
  int v17 = v16;
  *((_OWORD *)v16 + 2) = v20;
LABEL_9:
  if (BYTE12(v31)) {
    uprv_free((void *)v31);
  }
  if (BYTE12(v27)) {
    uprv_free((void *)v27);
  }
  if (BYTE12(v23)) {
    uprv_free((void *)v23);
  }
  return v17;
}

uint64_t sub_18C87B628(char *a1, unsigned int a2, int *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*a3 > 0) {
    return 0;
  }
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  sub_18C87BA40((uint64_t)v14);
  if ((a2 & 0x80000000) != 0)
  {
    int v10 = strrchr(a1, 47);
    if (v10) {
      char v11 = v10 + 1;
    }
    else {
      char v11 = a1;
    }
    if (!*v11)
    {
      if (*a3 <= 0)
      {
        uint64_t v3 = 0;
        *a3 = 4;
        return v3;
      }
      return 0;
    }
    uint64_t v3 = sub_18C87B964(v11, a3);
    if (v3) {
      return v3;
    }
    if (*a3 > 0) {
      return 0;
    }
    uint64_t v31 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v16 = 0u;
    DataDirectory = u_getDataDirectory();
    sub_18C879F5C((uint64_t)&v16, DataDirectory, v11, a1, ".dat", 1, (UErrorCode *)a3);
    while (!sub_18C87BC48((uint64_t)v14))
    {
      int v13 = (const char *)sub_18C87A0DC((uint64_t)&v16, (UErrorCode *)a3);
      if (!v13) {
        break;
      }
      uprv_mapFile(v14, v13, a3);
    }
    if (*a3 <= 0)
    {
      if (sub_18C87BC48((uint64_t)v14))
      {
        sub_18C8547D4(v14, a3);
        uint64_t v3 = (uint64_t)sub_18C87A550(v11, (uint64_t)v14, a3);
      }
      else
      {
        uint64_t v3 = 0;
        *a3 = 4;
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
    sub_18C87B9EC((uint64_t)&v16);
  }
  else
  {
    if (a2 > 9) {
      return 0;
    }
    umtx_lock(0);
    uint64_t v3 = qword_1EB20B498[a2];
    if (!v3)
    {
      if (a2)
      {
        uint64_t v8 = qword_1EB20B498;
        uint64_t v9 = a2;
        while (*(char **)(*v8 + 8) != " ")
        {
          ++v8;
          if (!--v9) {
            goto LABEL_11;
          }
        }
        uint64_t v3 = 0;
      }
      else
      {
LABEL_11:
        umtx_unlock(0);
        *(void *)&long long v19 = 0;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v16 = 0u;
        sub_18C87BA40((uint64_t)&v16);
        sub_18C87BB10((uint64_t)&v16, (uint64_t)" ");
        sub_18C8547D4(&v16, a3);
        sub_18C87A39C((uint64_t)&v16, 0, a3);
        umtx_lock(0);
        uint64_t v3 = qword_1EB20B498[a2];
      }
    }
    umtx_unlock(0);
  }
  return v3;
}

void *sub_18C87B8BC(uint64_t a1, unsigned int (*a2)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, int *a7)
{
  if (*a7 > 0) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 2) == 218 && *(unsigned char *)(a1 + 3) == 39 && (!a2 || a2(a3, a4, a5, a1 + 4)))
  {
    uint64_t result = UDataMemory_createNewInstance(a7);
    if (*a7 > 0) {
      return 0;
    }
    result[1] = a1;
  }
  else
  {
    uint64_t result = 0;
    *a6 = 3;
  }
  return result;
}

uint64_t sub_18C87B964(char *a1, int *a2)
{
  uint64_t v4 = sub_18C87B118(a2);
  if (*a2 > 0) {
    return 0;
  }
  uint64_t v6 = v4;
  uint64_t v7 = strrchr(a1, 47);
  if (v7) {
    a1 = v7 + 1;
  }
  umtx_lock(0);
  uint64_t v8 = uhash_get(v6, (uint64_t)a1);
  umtx_unlock(0);
  if (v8) {
    return *(void *)(v8 + 8);
  }
  else {
    return 0;
  }
}

uint64_t sub_18C87B9EC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 188)) {
    uprv_free(*(void **)(a1 + 176));
  }
  if (*(unsigned char *)(a1 + 124)) {
    uprv_free(*(void **)(a1 + 112));
  }
  if (*(unsigned char *)(a1 + 60)) {
    uprv_free(*(void **)(a1 + 48));
  }
  return a1;
}

double sub_18C87BA40(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = -1;
  return result;
}

__n128 sub_18C87BA5C(uint64_t a1, uint64_t a2)
{
  char v2 = *(unsigned char *)(a1 + 24);
  long long v4 = *(_OWORD *)(a2 + 16);
  __n128 result = *(__n128 *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 48);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 48) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(unsigned char *)(a1 + 24) = v2;
  return result;
}

void *UDataMemory_createNewInstance(int *a1)
{
  if (*a1 > 0) {
    return 0;
  }
  __n128 result = uprv_malloc(0x38uLL);
  if (result)
  {
    result[6] = 0;
    *((_OWORD *)result + 1) = 0u;
    *((_OWORD *)result + 2) = 0u;
    *(_OWORD *)__n128 result = 0u;
    *((_DWORD *)result + 12) = -1;
    *((unsigned char *)result + 24) = 1;
  }
  else
  {
    *a1 = 7;
  }
  return result;
}

uint64_t sub_18C87BAEC(uint64_t result)
{
  if (result && (*(unsigned __int8 *)(result + 2) != 218 || *(unsigned char *)(result + 3) != 39)) {
    result += 8;
  }
  return result;
}

uint64_t sub_18C87BB10(uint64_t result, uint64_t a2)
{
  if (a2 && (*(unsigned __int8 *)(a2 + 2) != 218 || *(unsigned char *)(a2 + 3) != 39)) {
    a2 += 8;
  }
  *(void *)(result + 8) = a2;
  return result;
}

double udata_close(_OWORD *a1)
{
  if (a1)
  {
    sub_18C88AB4C((uint64_t)a1);
    if (*((unsigned char *)a1 + 24))
    {
      uprv_free(a1);
    }
    else
    {
      *((void *)a1 + 6) = 0;
      double result = 0.0;
      a1[1] = 0u;
      a1[2] = 0u;
      *a1 = 0u;
      *((_DWORD *)a1 + 12) = -1;
    }
  }
  return result;
}

uint64_t udata_getMemory(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 8);
    if (v1) {
      return v1 + sub_18C85477C(*(unsigned char **)(result + 8));
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t udata_getLength(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  char v2 = *(unsigned char **)(a1 + 8);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *(_DWORD *)(a1 + 48);
  if (v3 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3 - sub_18C85477C(v2);
  }
}

uint64_t udata_getRawMemory(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t result = *(void *)(a1 + 8);
  if (!result) {
    return 0;
  }
  return result;
}

BOOL sub_18C87BC48(uint64_t a1)
{
  return *(void *)(a1 + 8) != 0;
}

uint64_t udata_readInt16(uint64_t a1, unsigned __int16 a2)
{
  return (*(__int16 (**)(void))(a1 + 8))(a2);
}

uint64_t udata_readInt32(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 16))(a2);
}

uint64_t udata_swapInvStringBlock(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int *a5)
{
  if (!a5) {
    return 0;
  }
  if (*a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (!a3 || a4))
  {
    uint64_t v10 = a3;
    LODWORD(v11) = a3 + 1;
    while (v10 >= 1)
    {
      int v12 = *(unsigned __int8 *)(a2 + v10 - 1);
      uint64_t v11 = (v11 - 1);
      --v10;
      if (!v12) {
        goto LABEL_16;
      }
    }
    uint64_t v11 = 0;
LABEL_16:
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(a1 + 72))(a1, a2, v11, a4, a5);
    if (a2 != a4 && (int)a3 > (int)v11) {
      memcpy((void *)(a4 + v11), (const void *)(a2 + v11), (int)(a3 - v11));
    }
    if (*a5 <= 0) {
      return a3;
    }
    else {
      return 0;
    }
  }
  else
  {
    uint64_t result = 0;
    *a5 = 1;
  }
  return result;
}

uint64_t udata_printError(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(void *)(result + 80)) {
    return (*(uint64_t (**)(void, uint64_t, uint64_t *))(result + 80))(*(void *)(result + 88), a2, &a9);
  }
  return result;
}

uint64_t udata_swapDataHeader(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (!a1 || !a2 || (int v12 = a3, (int)a3 < -1) || (int)a3 >= 1 && !a4)
  {
    uint64_t v9 = 0;
    int v14 = 1;
LABEL_21:
    *a5 = v14;
    return v9;
  }
  if (a3 < 0x18
    || *((unsigned __int8 *)a2 + 2) != 218
    || *((unsigned char *)a2 + 3) != 39
    || *((unsigned char *)a2 + 10) != 2)
  {
    udata_printError(a1, (uint64_t)"udata_swapDataHeader(): initial bytes do not look like ICU data\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v27);
    uint64_t v9 = 0;
    int v14 = 16;
    goto LABEL_21;
  }
  unsigned int v15 = (*(uint64_t (**)(void))(a1 + 8))(*a2);
  unsigned int v16 = (*(uint64_t (**)(void))(a1 + 8))(a2[2]);
  uint64_t v9 = v15;
  if (v15 < 0x18 || v16 < 0x14 || (unint64_t v23 = v16 + 4, v23 > v15) || (v12 & 0x80000000) == 0 && (int)v15 > v12)
  {
    udata_printError(a1, (uint64_t)"udata_swapDataHeader(): header size mismatch - headerSize %d infoSize %d length %d\n", v17, v18, v19, v20, v21, v22, v15);
    uint64_t v9 = 0;
    int v14 = 8;
    goto LABEL_21;
  }
  if (v12 >= 1)
  {
    if (a2 != a4) {
      memcpy(a4, a2, v15);
    }
    a4[4] = *(_WORD *)(a1 + 2);
    (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, unsigned __int16 *, int *))(a1 + 48))(a1, a2, 2, a4, a5);
    (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, unsigned __int16 *, int *))(a1 + 48))(a1, a2 + 2, 4, a4 + 2, a5);
    uint64_t v25 = v15 - (unsigned __int16)v23;
    if ((int)v25 >= 1)
    {
      for (uint64_t i = 0; i != v25; ++i)
      {
        if (!*((unsigned char *)a2 + (unsigned __int16)v23 + i)) {
          break;
        }
      }
    }
    (*(void (**)(uint64_t))(a1 + 72))(a1);
  }
  return v9;
}

_OWORD *udata_openSwapper(int a1, unsigned int a2, int a3, int a4, int *a5)
{
  if (!a5) {
    return 0;
  }
  if (*a5 > 0) {
    return 0;
  }
  if ((a4 | a2) >= 2)
  {
    uint64_t result = 0;
    int v22 = 1;
LABEL_31:
    *a5 = v22;
    return result;
  }
  uint64_t result = uprv_malloc(0x60uLL);
  if (!result)
  {
    int v22 = 7;
    goto LABEL_31;
  }
  *uint64_t result = 0u;
  result[1] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  *(unsigned char *)uint64_t result = a1;
  *((unsigned char *)result + 1) = a2;
  *((unsigned char *)result + 2) = a3;
  *((unsigned char *)result + 3) = a4;
  if (a1) {
    uint64_t v11 = sub_18C87C1EC;
  }
  else {
    uint64_t v11 = (uint64_t (*))nullsub_19;
  }
  int v12 = sub_18C87C1F8;
  if (!a1) {
    int v12 = (uint64_t (*))nullsub_20;
  }
  *((void *)result + 1) = v11;
  *((void *)result + 2) = v12;
  if (a3) {
    int v13 = sub_18C87C208;
  }
  else {
    int v13 = sub_18C87C200;
  }
  int v14 = sub_18C87C21C;
  if (!a3) {
    int v14 = sub_18C87C214;
  }
  *((void *)result + 4) = v13;
  *((void *)result + 5) = v14;
  unsigned int v15 = sub_18C87F428;
  if (!a4) {
    unsigned int v15 = sub_18C87F328;
  }
  *((void *)result + 3) = v15;
  if (a1 == a3) {
    unsigned int v16 = sub_18C87C228;
  }
  else {
    unsigned int v16 = sub_18C87C398;
  }
  if (a1 == a3) {
    uint64_t v17 = sub_18C87C2A0;
  }
  else {
    uint64_t v17 = sub_18C87C408;
  }
  uint64_t v18 = sub_18C87C478;
  if (a1 == a3) {
    uint64_t v18 = sub_18C87C31C;
  }
  *((void *)result + 6) = v16;
  *((void *)result + 7) = v17;
  *((void *)result + 8) = v18;
  if (a2)
  {
    BOOL v19 = a4 == 1;
    uint64_t v20 = sub_18C87F158;
    uint64_t v21 = sub_18C87F238;
  }
  else
  {
    BOOL v19 = a4 == 0;
    uint64_t v20 = uprv_ebcdicFromAscii;
    uint64_t v21 = sub_18C87F070;
  }
  if (v19) {
    uint64_t v20 = v21;
  }
  *((void *)result + 9) = v20;
  return result;
}

uint64_t sub_18C87C1EC(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t sub_18C87C1F8(unsigned int a1)
{
  return bswap32(a1);
}

_WORD *sub_18C87C200(_WORD *result, __int16 a2)
{
  *uint64_t result = a2;
  return result;
}

_WORD *sub_18C87C208(_WORD *result, unsigned int a2)
{
  *uint64_t result = __rev16(a2);
  return result;
}

_DWORD *sub_18C87C214(_DWORD *result, int a2)
{
  *uint64_t result = a2;
  return result;
}

_DWORD *sub_18C87C21C(_DWORD *result, unsigned int a2)
{
  *uint64_t result = bswap32(a2);
  return result;
}

size_t sub_18C87C228(uint64_t a1, const void *a2, size_t __n, void *__dst, int *a5)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (size_t v5 = __n, (__n & 0x80000000) == 0) && (__n & 1) == 0 && __dst)
  {
    if (__n && a2 != __dst) {
      memcpy(__dst, a2, __n);
    }
  }
  else
  {
    size_t v5 = 0;
    *a5 = 1;
  }
  return v5;
}

size_t sub_18C87C2A0(uint64_t a1, const void *a2, size_t __n, void *__dst, int *a5)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (size_t v5 = __n, (__n & 0x80000000) == 0) && (__n & 3) == 0 && __dst)
  {
    if (__n && a2 != __dst) {
      memcpy(__dst, a2, __n);
    }
  }
  else
  {
    size_t v5 = 0;
    *a5 = 1;
  }
  return v5;
}

size_t sub_18C87C31C(uint64_t a1, const void *a2, size_t __n, void *__dst, int *a5)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (size_t v5 = __n, (__n & 0x80000000) == 0) && (__n & 7) == 0 && __dst)
  {
    if (__n && a2 != __dst) {
      memcpy(__dst, a2, __n);
    }
  }
  else
  {
    size_t v5 = 0;
    *a5 = 1;
  }
  return v5;
}

uint64_t sub_18C87C398(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _WORD *a4, int *a5)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (a3 & 1) == 0 && a4)
  {
    if (a3 >= 2)
    {
      unsigned int v6 = (a3 >> 1) + 1;
      do
      {
        unsigned int v7 = *a2++;
        *a4++ = bswap32(v7) >> 16;
        --v6;
      }
      while (v6 > 1);
    }
  }
  else
  {
    a3 = 0;
    *a5 = 1;
  }
  return a3;
}

uint64_t sub_18C87C408(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD *a4, int *a5)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (a3 & 3) == 0 && a4)
  {
    if (a3 >= 4)
    {
      unsigned int v6 = (a3 >> 2) + 1;
      do
      {
        unsigned int v7 = *a2++;
        *a4++ = bswap32(v7);
        --v6;
      }
      while (v6 > 1);
    }
  }
  else
  {
    a3 = 0;
    *a5 = 1;
  }
  return a3;
}

uint64_t sub_18C87C478(uint64_t a1, unint64_t *a2, uint64_t a3, void *a4, int *a5)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (a3 & 0x80000000) == 0 && (a3 & 7) == 0 && a4)
  {
    if (a3 >= 8)
    {
      unsigned int v6 = (a3 >> 3) + 1;
      do
      {
        unint64_t v7 = *a2++;
        *a4++ = bswap64(v7);
        --v6;
      }
      while (v6 > 1);
    }
  }
  else
  {
    a3 = 0;
    *a5 = 1;
  }
  return a3;
}

_OWORD *udata_openSwapperForInputData(unsigned __int16 *a1, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  if (a5 && *a5 <= 0)
  {
    if (a1 && a2 >= 0x18 && a4 < 2)
    {
      if (*((unsigned __int8 *)a1 + 2) == 218 && *((unsigned char *)a1 + 3) == 39 && *((unsigned char *)a1 + 10) == 2)
      {
        unsigned int v5 = *a1;
        if (*((unsigned char *)a1 + 8))
        {
          unsigned int v5 = __rev16(v5);
          unsigned int v6 = bswap32(a1[2]) >> 16;
        }
        else
        {
          unsigned int v6 = a1[2];
        }
        if (v5 <= a2 && v5 >= 0x18 && v6 >= 0x14 && (unint64_t)v6 + 4 <= v5) {
          return udata_openSwapper(*((char *)a1 + 8), *((unsigned __int8 *)a1 + 9), a3, a4, a5);
        }
      }
      int v7 = 16;
    }
    else
    {
      int v7 = 1;
    }
    *a5 = v7;
  }
  return 0;
}

void uenum_close(void **a1)
{
  if (a1)
  {
    char v2 = (void (*)(void **))a1[2];
    if (v2)
    {
      int v3 = *a1;
      if (*a1)
      {
        uprv_free(v3);
        char v2 = (void (*)(void **))a1[2];
      }
      v2(a1);
    }
    else
    {
      uprv_free(a1);
    }
  }
}

uint64_t uenum_count(uint64_t a1, int *a2)
{
  if (!a1 || *a2 > 0) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *(uint64_t (**)(void))(a1 + 24);
  if (!v3)
  {
    *a2 = 16;
    return 0xFFFFFFFFLL;
  }
  return v3();
}

UChar *uenum_unextDefault(uint64_t a1, _DWORD *a2, int *a3)
{
  int v12 = 0;
  unsigned int v5 = *(uint64_t (**)(void))(a1 + 40);
  if (v5)
  {
    uint64_t v7 = v5();
    if (!v7)
    {
      uint64_t v9 = 0;
      goto LABEL_9;
    }
    uint64_t v8 = (const char *)v7;
    uint64_t v9 = (UChar *)sub_18C87C70C((_DWORD **)a1, 2 * v12 + 2);
    if (v9)
    {
      u_charsToUChars(v8, v9, v12 + 1);
      goto LABEL_9;
    }
    int v10 = 7;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 16;
  }
  *a3 = v10;
LABEL_9:
  if (a2) {
    *a2 = v12;
  }
  return v9;
}

_DWORD *sub_18C87C70C(_DWORD **a1, int a2)
{
  uint64_t result = *a1;
  if (result)
  {
    if (*result >= a2) {
      return ++result;
    }
    uint64_t result = uprv_realloc(result, a2 + 12);
  }
  else
  {
    uint64_t result = uprv_malloc(a2 + 12);
  }
  *a1 = result;
  if (!result) {
    return result;
  }
  *uint64_t result = a2 + 8;
  return ++result;
}

char *uenum_nextDefault(uint64_t a1, _DWORD *a2, int *a3)
{
  long long v4 = *(uint64_t (**)(void))(a1 + 32);
  if (!v4)
  {
    uint64_t v9 = 0;
    int v10 = 16;
LABEL_8:
    *a3 = v10;
    return v9;
  }
  uint64_t v7 = v4();
  if (!v7) {
    return 0;
  }
  uint64_t v8 = (const UChar *)v7;
  uint64_t v9 = (char *)sub_18C87C70C((_DWORD **)a1, *a2 + 1);
  if (!v9)
  {
    int v10 = 7;
    goto LABEL_8;
  }
  u_UCharsToChars(v8, v9, *a2 + 1);
  return v9;
}

uint64_t uenum_unext(uint64_t a1, uint64_t a2, int *a3)
{
  if (!a1 || *a3 > 0) {
    return 0;
  }
  long long v4 = *(uint64_t (**)(void))(a1 + 32);
  if (!v4)
  {
    *a3 = 16;
    return 0;
  }
  return v4();
}

uint64_t uenum_next(uint64_t result, uint64_t a2, int *a3)
{
  if (result)
  {
    if (*a3 <= 0)
    {
      int v3 = *(uint64_t (**)(void))(result + 40);
      if (v3)
      {
        if (a2)
        {
          return v3();
        }
        else
        {
          int v4 = 0;
          return v3();
        }
      }
      else
      {
        uint64_t result = 0;
        *a3 = 16;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t uenum_reset(uint64_t result, int *a2)
{
  if (result && *a2 <= 0)
  {
    char v2 = *(uint64_t (**)(void))(result + 48);
    if (v2) {
      return v2();
    }
    else {
      *a2 = 16;
    }
  }
  return result;
}

int32x2_t *uhash_open(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  return sub_18C87C8F0(a1, a2, a3, 4, a4);
}

int32x2_t *sub_18C87C8F0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int *a5)
{
  if (*a5 > 0) {
    return 0;
  }
  int v12 = (int32x2_t *)uprv_malloc(0x50uLL);
  unsigned int v5 = v12;
  if (!v12)
  {
    *a5 = 7;
    return v5;
  }
  sub_18C87C9D4(v12, a1, a2, a3, a4, a5);
  v5[9].i8[1] = 1;
  if (*a5 >= 1)
  {
    uprv_free(v5);
    return 0;
  }
  return v5;
}

int32x2_t *uhash_openSize(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int *a5)
{
  for (uint64_t i = 0; i != 28; ++i)
  {
    if (dword_18CA814B0[i] >= a4) {
      break;
    }
  }
  return sub_18C87C8F0(a1, a2, a3, i, a5);
}

int32x2_t *uhash_init(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  return sub_18C87C9D4(a1, a2, a3, a4, 4, a5);
}

int32x2_t *sub_18C87C9D4(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  if (*a6 > 0) {
    return 0;
  }
  a1[1] = (int32x2_t)a2;
  a1[2] = (int32x2_t)a3;
  a1[9].i8[1] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[3] = (int32x2_t)a4;
  a1[8] = (int32x2_t)1056964608;
  sub_18C87D800(a1, a5, a6);
  if (*a6 >= 1) {
    return 0;
  }
  else {
    return a1;
  }
}

int32x2_t *uhash_initSize(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6)
{
  for (uint64_t i = 0; i != 28; ++i)
  {
    if (dword_18CA814B0[i] >= a5) {
      break;
    }
  }
  return sub_18C87C9D4(a1, a2, a3, a4, i, a6);
}

void uhash_close(unsigned char *a1)
{
  if (a1)
  {
    char v2 = *(void **)a1;
    if (v2)
    {
      if (*((void *)a1 + 4) || *((void *)a1 + 5))
      {
        LODWORD(v3) = -1;
LABEL_6:
        uint64_t v3 = (int)v3;
        char v2 = *(void **)a1;
        int v4 = (int *)(*(void *)a1 + 24 * (int)v3 + 24);
        while (++v3 < *((int *)a1 + 13))
        {
          unsigned int v5 = v4 + 6;
          int v6 = *v4;
          v4 += 6;
          if ((v6 & 0x80000000) == 0)
          {
            uint64_t v7 = (void (*)(void))*((void *)a1 + 4);
            if (v7 && *((void *)v5 - 1)) {
              v7();
            }
            uint64_t v8 = (void (*)(void))*((void *)a1 + 5);
            if (v8)
            {
              if (*((void *)v5 - 2)) {
                v8();
              }
            }
            goto LABEL_6;
          }
        }
      }
      uprv_free(v2);
      *(void *)a1 = 0;
    }
    if (a1[73])
    {
      uprv_free(a1);
    }
  }
}

uint64_t uhash_nextElement(uint64_t *a1, int *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = 24 * v2;
  while (v3 < *((int *)a1 + 13))
  {
    uint64_t v5 = *a1;
    int v6 = *(_DWORD *)(*a1 + v4 + 24);
    LODWORD(v2) = v2 + 1;
    ++v3;
    v4 += 24;
    if ((v6 & 0x80000000) == 0)
    {
      *a2 = v2;
      return v5 + v4;
    }
  }
  return 0;
}

uint64_t uhash_setKeyHasher(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2;
  return v2;
}

uint64_t uhash_setKeyComparator(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2;
  return v2;
}

uint64_t uhash_setValueComparator(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = a2;
  return v2;
}

uint64_t uhash_setKeyDeleter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = a2;
  return v2;
}

uint64_t uhash_setValueDeleter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = a2;
  return v2;
}

void uhash_setResizePolicy(int32x2_t *a1, int a2)
{
  int v3 = 0;
  float32x2_t v2 = qword_18CA81524[a2];
  a1[7] = vrev64_s32(vcvt_s32_f32(vmul_n_f32(v2, (float)a1[6].i32[1])));
  a1[8] = vrev64_s32((int32x2_t)v2);
  sub_18C87CC34(a1, &v3);
}

void sub_18C87CC34(int32x2_t *a1, int *a2)
{
  uint64_t v4 = (char *)*a1;
  int v5 = a1[9].i8[0];
  __int32 v6 = a1[6].i32[0];
  uint64_t v7 = a1[6].u32[1];
  if (v6 <= a1[7].i32[0])
  {
    if (v6 >= a1[7].i32[1] || v5 < 1) {
      return;
    }
    int v8 = v5 - 1;
  }
  else
  {
    if (v5 > 27) {
      return;
    }
    int v8 = v5 + 1;
  }
  sub_18C87D800(a1, v8, a2);
  if (*a2 <= 0)
  {
    if ((int)v7 >= 1)
    {
      unint64_t v10 = v7 + 1;
      do
      {
        uint64_t v11 = (int *)&v4[24 * (v10 - 2)];
        if ((*v11 & 0x80000000) == 0)
        {
          int v12 = &v4[24 * (v10 - 2)];
          int v13 = sub_18C87CD98((uint64_t *)a1, *((void *)v12 + 2), *v11);
          *((void *)v13 + 2) = *((void *)v12 + 2);
          *((void *)v13 + 1) = *((void *)v12 + 1);
          *int v13 = *v11;
          ++a1[6].i32[0];
        }
        --v10;
      }
      while (v10 > 1);
    }
    uprv_free(v4);
  }
  else
  {
    *a1 = (int32x2_t)v4;
    a1[6].i32[1] = v7;
  }
}

uint64_t uhash_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t uhash_get(uint64_t a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  return *((void *)sub_18C87CD98((uint64_t *)a1, a2, v4) + 1);
}

int *sub_18C87CD98(uint64_t *a1, uint64_t a2, int a3)
{
  int v4 = 0;
  int v5 = a3 & 0x7FFFFFFF;
  int v6 = *((_DWORD *)a1 + 13);
  int v7 = (a3 & 0x7FFFFFFF ^ 0x4000000) % v6;
  uint64_t v8 = *a1;
  int v9 = -1;
  int v10 = v7;
  do
  {
    int v11 = v10;
    int v12 = (int *)(v8 + 24 * v10);
    int v13 = *v12;
    if (*v12 == v5)
    {
      if (((unsigned int (*)(uint64_t, void))a1[2])(a2, *(void *)(v8 + 24 * v10 + 16))) {
        return v12;
      }
      int v6 = *((_DWORD *)a1 + 13);
    }
    else if (v13 < 0)
    {
      if (v9 < 0) {
        int v9 = v10;
      }
      if (v13 == -2147483647) {
        return (int *)(v8 + 24 * v9);
      }
    }
    if (!v4) {
      int v4 = v5 % (v6 - 1) + 1;
    }
    int v10 = (v4 + v11) % v6;
  }
  while (v10 != v7);
  if (v9 < 0)
  {
    int v9 = v7;
    if (v13 != -2147483647) {
      abort();
    }
  }
  return (int *)(v8 + 24 * v9);
}

uint64_t uhash_iget(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a2;
  int v4 = (*(uint64_t (**)(void))(a1 + 8))(a2);
  return *((void *)sub_18C87CD98((uint64_t *)a1, v3, v4) + 1);
}

uint64_t uhash_geti(uint64_t a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  return sub_18C87CD98((uint64_t *)a1, a2, v4)[2];
}

uint64_t uhash_igeti(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a2;
  int v4 = (*(uint64_t (**)(void))(a1 + 8))(a2);
  return sub_18C87CD98((uint64_t *)a1, v3, v4)[2];
}

uint64_t uhash_getiAndFound(uint64_t a1, uint64_t a2, BOOL *a3)
{
  int v6 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  int v7 = sub_18C87CD98((uint64_t *)a1, a2, v6);
  *a3 = *v7 >= 0;
  return v7[2];
}

uint64_t uhash_igetiAndFound(uint64_t a1, unsigned int a2, BOOL *a3)
{
  uint64_t v5 = a2;
  int v6 = (*(uint64_t (**)(void))(a1 + 8))(a2);
  int v7 = sub_18C87CD98((uint64_t *)a1, v5, v6);
  *a3 = *v7 >= 0;
  return v7[2];
}

uint64_t uhash_put(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  return sub_18C87D03C(a1, a2, a3, 3, a4);
}

uint64_t sub_18C87D03C(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int *a5)
{
  if (*a5 > 0)
  {
LABEL_2:
    uint64_t v8 = *(void (**)(uint64_t))(a1 + 32);
    if (v8) {
      BOOL v9 = a2 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9) {
      v8(a2);
    }
    int v10 = *(void (**)(uint64_t))(a1 + 40);
    if (v10) {
      BOOL v11 = a3 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11) {
      v10(a3);
    }
    return 0;
  }
  if ((a4 & 2) != 0)
  {
    if (!a3)
    {
LABEL_16:
      return sub_18C87D250(a1, a2);
    }
  }
  else if (!a3 && (a4 & 4) == 0)
  {
    goto LABEL_16;
  }
  if (*(_DWORD *)(a1 + 48) > *(_DWORD *)(a1 + 56))
  {
    sub_18C87CC34((int32x2_t *)a1, a5);
    if (*a5 > 0) {
      goto LABEL_2;
    }
  }
  int v14 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  unsigned int v15 = sub_18C87CD98((uint64_t *)a1, a2, v14);
  if (*v15 < 0)
  {
    int v16 = *(_DWORD *)(a1 + 48);
    int v17 = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a1 + 48) = v16 + 1;
    if (v16 + 1 == v17)
    {
      *(_DWORD *)(a1 + 48) = v16;
      *a5 = 7;
      goto LABEL_2;
    }
  }

  return sub_18C87D8A4(a1, (uint64_t)v15, v14 & 0x7FFFFFFF, a2, a3);
}

uint64_t uhash_iput(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  return sub_18C87D03C(a1, a2, a3, 2, a4);
}

uint64_t uhash_puti(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  return sub_18C87D03C(a1, a2, a3, 1, a4);
}

uint64_t uhash_iputi(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  return sub_18C87D03C(a1, a2, a3, 0, a4);
}

uint64_t uhash_putiAllowZero(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  return sub_18C87D03C(a1, a2, a3, 5, a4);
}

uint64_t uhash_iputiAllowZero(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  return sub_18C87D03C(a1, a2, a3, 4, a4);
}

uint64_t sub_18C87D250(uint64_t a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  uint64_t v5 = sub_18C87CD98((uint64_t *)a1, a2, v4);
  if (*v5 < 0) {
    return 0;
  }
  --*(_DWORD *)(a1 + 48);
  uint64_t v6 = sub_18C87D8A4(a1, (uint64_t)v5, 0x80000000, 0, 0);
  if (*(_DWORD *)(a1 + 48) < *(_DWORD *)(a1 + 60))
  {
    int v8 = 0;
    sub_18C87CC34((int32x2_t *)a1, &v8);
  }
  return v6;
}

uint64_t uhash_iremove(uint64_t a1, unsigned int a2)
{
  return sub_18C87D250(a1, a2);
}

uint64_t uhash_removei(uint64_t a1, uint64_t a2)
{
  return sub_18C87D250(a1, a2);
}

uint64_t uhash_iremovei(uint64_t a1, unsigned int a2)
{
  return sub_18C87D250(a1, a2);
}

uint64_t uhash_removeAll(uint64_t result)
{
  if (*(_DWORD *)(result + 48))
  {
    uint64_t v1 = result;
    LODWORD(v2) = -1;
LABEL_3:
    uint64_t v3 = 24 * (int)v2;
    uint64_t v2 = (int)v2;
    while (++v2 < *(int *)(v1 + 52))
    {
      uint64_t v4 = v3 + 24;
      int v5 = *(_DWORD *)(*(void *)v1 + v3 + 24);
      v3 += 24;
      if ((v5 & 0x80000000) == 0)
      {
        uint64_t result = uhash_removeElement(v1, (_DWORD *)(*(void *)v1 + v4));
        goto LABEL_3;
      }
    }
  }
  return result;
}

uint64_t uhash_removeElement(uint64_t a1, _DWORD *a2)
{
  if ((*a2 & 0x80000000) != 0) {
    return 0;
  }
  --*(_DWORD *)(a1 + 48);
  return sub_18C87D8A4(a1, (uint64_t)a2, 0x80000000, 0, 0);
}

BOOL uhash_containsKey(uint64_t a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  return *sub_18C87CD98((uint64_t *)a1, a2, v4) >= 0;
}

BOOL uhash_icontainsKey(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a2;
  int v4 = (*(uint64_t (**)(void))(a1 + 8))(a2);
  return *sub_18C87CD98((uint64_t *)a1, v3, v4) >= 0;
}

int *uhash_find(uint64_t a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
  uint64_t result = sub_18C87CD98((uint64_t *)a1, a2, v4);
  if (*result < 0) {
    return 0;
  }
  return result;
}

unsigned __int16 *uhash_hashUChars(unsigned __int16 *result)
{
  if (result)
  {
    uint64_t v1 = result;
    int32_t v2 = u_strlen(result);
    return ustr_hashUCharsN(v1, v2);
  }
  return result;
}

unsigned __int8 *uhash_hashChars(unsigned __int8 *result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = strlen((const char *)result);
    return ustr_hashCharsN(v1, v2);
  }
  return result;
}

char *uhash_hashIChars(char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = strlen(result);
    return ustr_hashICharsN(v1, v2);
  }
  return result;
}

uint64_t uhash_equals(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
      return 0;
    }
    uint64_t result = 0;
    uint64_t v5 = *(void *)(a1 + 24);
    if (v5 && v5 == *(void *)(a2 + 24))
    {
      int v6 = *(_DWORD *)(a1 + 48);
      if (v6 != *(_DWORD *)(a2 + 48)) {
        return 0;
      }
      if (v6 < 1)
      {
        return 1;
      }
      else
      {
        int v7 = 0;
        int v8 = -1;
        do
        {
          BOOL v9 = (_DWORD *)(*(void *)a1 + 24 * v8 + 24);
          do
          {
            ++v8;
            int v10 = *v9;
            v9 += 6;
          }
          while (v10 < 0);
          uint64_t v12 = *((void *)v9 - 2);
          uint64_t v11 = *((void *)v9 - 1);
          int v13 = (*(uint64_t (**)(uint64_t))(a2 + 8))(v11);
          int v14 = sub_18C87CD98((uint64_t *)a2, v11, v13);
          uint64_t result = (*(uint64_t (**)(uint64_t, void))(a1 + 24))(v12, *((void *)v14 + 1));
          if (!result) {
            break;
          }
          ++v7;
          uint64_t result = 1;
        }
        while (v7 != v6);
      }
    }
  }
  return result;
}

BOOL uhash_compareUChars(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    int v4 = *a1;
    if (*a1)
    {
      uint64_t v5 = a1 + 1;
      do
      {
        if (v4 != *a2) {
          break;
        }
        ++a2;
        int v6 = *v5++;
        int v4 = v6;
      }
      while (v6);
    }
    return v4 == *a2;
  }
  return result;
}

BOOL uhash_compareChars(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    int v4 = *a1;
    if (*a1)
    {
      uint64_t v5 = a1 + 1;
      do
      {
        if (v4 != *a2) {
          break;
        }
        ++a2;
        int v6 = *v5++;
        int v4 = v6;
      }
      while (v6);
    }
    return v4 == *a2;
  }
  return result;
}

BOOL uhash_compareIChars(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1)
  {
    int v4 = a2;
    if (a2)
    {
      unsigned __int8 v5 = *a1;
      if (*a1)
      {
        int v6 = a1 + 1;
        while (1)
        {
          int v7 = uprv_asciitolower((char)v5);
          if (v7 != uprv_asciitolower((char)*v4)) {
            break;
          }
          ++v4;
          int v8 = *v6++;
          unsigned __int8 v5 = v8;
          if (!v8) {
            goto LABEL_8;
          }
        }
        int v9 = *(v6 - 1);
      }
      else
      {
LABEL_8:
        int v9 = 0;
      }
      return v9 == *v4;
    }
  }
  return result;
}

BOOL uhash_compareLong(int a1, int a2)
{
  return a1 == a2;
}

int32x2_t *sub_18C87D800(int32x2_t *result, int a2, int *a3)
{
  if (*a3 <= 0)
  {
    int v4 = result;
    result[9].i8[0] = a2;
    uint64_t v5 = dword_18CA814B0[a2];
    result[6].i32[1] = v5;
    BOOL result = (int32x2_t *)uprv_malloc(24 * v5);
    *int v4 = (int32x2_t)result;
    if (result)
    {
      int v6 = v4[6].i32[1];
      if (v6 >= 1)
      {
        int v7 = (char *)&result[3 * v6];
        do
        {
          result[1] = 0;
          result[2] = 0;
          result->i32[0] = -2147483647;
          result += 3;
        }
        while (result < (int32x2_t *)v7);
      }
      v4[6].i32[0] = 0;
      v4[7] = vcvt_s32_f32(vmul_n_f32((float32x2_t)v4[8], (float)v6));
    }
    else
    {
      *a3 = 7;
    }
  }
  return result;
}

uint64_t sub_18C87D8A4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a2 + 8);
  uint64_t v11 = *(void (**)(void))(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(a2 + 16);
    if (v12 && v12 != a4) {
      v11();
    }
  }
  int v14 = *(void (**)(uint64_t))(a1 + 40);
  if (v14)
  {
    if (v10) {
      BOOL v15 = v10 == a5;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15) {
      v14(v10);
    }
    uint64_t v10 = 0;
  }
  *(void *)(a2 + 8) = a5;
  *(void *)(a2 + 16) = a4;
  *(_DWORD *)a2 = a3;
  return v10;
}

void uhash_deleteHashtable(void *a1)
{
  if (a1)
  {
    int v2 = (unsigned char *)*a1;
    if (v2) {
      uhash_close(v2);
    }
    icu::UMemory::operator delete(a1);
  }
}

int32_t uidna_toASCII(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  if (!status || *(int *)status > 0) {
    return 0;
  }
  if (src
    && (uint64_t v10 = *(void *)&srcLength, srcLength >= -1)
    && (destCapacity & 0x80000000) == 0
    && ((char v13 = options, dest) || !destCapacity))
  {
    uint64_t v15 = usprep_openByType(0, (int *)status);
    if (*(int *)status <= 0)
    {
      uint64_t v16 = v15;
      int32_t v17 = sub_18C87DA60((UChar *)src, v10, dest, destCapacity, v13, v15, (uint64_t)parseError, (int *)status);
      usprep_close(v16);
      return v17;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    int32_t result = 0;
    *status = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return result;
}

uint64_t sub_18C87DA60(UChar *s, uint64_t a2, UChar *a3, int a4, char a5, uint64_t a6, uint64_t a7, int *a8)
{
  uint64_t v12 = a2;
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (a2 == -1) {
    uint64_t v12 = u_strlen(s);
  }
  uint64_t v51 = 0;
  memset(v50, 0, sizeof(v50));
  memset(v48, 0, sizeof(v48));
  uint64_t v49 = 0;
  if ((int)v12 < 101)
  {
    int v14 = v50;
    if ((int)v12 < 1)
    {
      uint64_t v12 = 0;
      goto LABEL_19;
    }
    int v15 = 100;
LABEL_8:
    char v18 = a5 & 1;
    memcpy(v14, s, 2 * v12);
    uint64_t v19 = 0;
    char v20 = 1;
    do
    {
      if (s[v19] > 0x7Fu) {
        char v20 = 0;
      }
      ++v19;
    }
    while (v12 != v19);
    if (!v20)
    {
      uint64_t v16 = usprep_prepare(a6, s, v12, v14, v15, v18, a7, a8);
      int v21 = *a8;
      if (*a8 != 15) {
        goto LABEL_20;
      }
      if (v14 != (_WORD *)v50) {
        uprv_free(v14);
      }
      int v22 = (UChar *)uprv_malloc(2 * (int)v16);
      if (!v22) {
        goto LABEL_5;
      }
      int v14 = v22;
      *a8 = 0;
      uint64_t v12 = usprep_prepare(a6, s, v12, v22, v16, v18, a7, a8);
    }
LABEL_19:
    int v21 = *a8;
    uint64_t v16 = v12;
LABEL_20:
    if (v21 > 0)
    {
LABEL_21:
      uint64_t v16 = 0;
LABEL_22:
      int32_t v17 = (UChar *)v48;
      goto LABEL_23;
    }
    if (!v16)
    {
      *a8 = 66567;
      goto LABEL_22;
    }
    if ((int)v16 < 1)
    {
      if ((a5 & 2) == 0)
      {
LABEL_64:
        if ((int)v16 > a4) {
          goto LABEL_22;
        }
        u_memmove(a3, v14, v16);
        int32_t v17 = (UChar *)v48;
        goto LABEL_66;
      }
      int v27 = 1;
    }
    else
    {
      uint64_t v24 = 0;
      char v25 = 1;
      int v26 = -1;
      int v27 = 1;
      int v28 = v16;
      do
      {
        unsigned int v29 = (unsigned __int16)v14[v24];
        if (v29 <= 0x7F)
        {
          if (v29 > 0x7A || v29 != 45 && v29 - 48 >= 0xA && v29 - 65 >= 0x1A && v29 <= 0x60)
          {
            char v25 = 0;
            int v26 = v24;
          }
        }
        else
        {
          int v27 = 0;
        }
        ++v24;
      }
      while (v16 != v24);
      if ((a5 & 2) == 0) {
        goto LABEL_63;
      }
      if (!v25)
      {
        *a8 = 66563;
        long long v34 = v14;
LABEL_62:
        uprv_syntaxError(v34, v26, v28, a7);
        goto LABEL_21;
      }
    }
    if (*v14 == 45)
    {
      int v35 = 66563;
LABEL_58:
      *a8 = v35;
      long long v34 = v14;
      int v26 = 0;
LABEL_61:
      int v28 = v16;
      goto LABEL_62;
    }
    if (v14[(int)v16 - 1] == 45)
    {
      *a8 = 66563;
      int v26 = v16 - ((int)v16 > 0);
      long long v34 = v14;
      goto LABEL_61;
    }
LABEL_63:
    if (v27) {
      goto LABEL_64;
    }
    if ((int)v16 >= 4)
    {
      int v36 = (unsigned __int16)*v14;
      if ((v36 - 65) < 0x1A) {
        LOWORD(v36) = v36 + 32;
      }
      if ((unsigned __int16)v36 == 120)
      {
        uint64_t v37 = 1;
        while (v37 != 4)
        {
          int v38 = (unsigned __int16)v14[v37];
          if ((v38 - 65) < 0x1A) {
            LOWORD(v38) = v38 + 32;
          }
          int v39 = (unsigned __int16)aXn[v37++];
          if (v39 != (unsigned __int16)v38)
          {
            if ((unint64_t)(v37 - 2) <= 2) {
              goto LABEL_79;
            }
            break;
          }
        }
        int v35 = 66564;
        goto LABEL_58;
      }
    }
LABEL_79:
    unint64_t v40 = a3;
    int32_t v17 = (UChar *)v48;
    int v41 = u_strToPunycode(v14, v16, (uint64_t)v48, 100, 0, a8);
    int v42 = v41;
    int v43 = *a8;
    if (*a8 == 15)
    {
      int32_t v17 = (UChar *)uprv_malloc(2 * v41);
      if (!v17)
      {
        uint64_t v16 = 0;
        int v44 = 7;
        goto LABEL_87;
      }
      *a8 = 0;
      int v42 = u_strToPunycode(v14, v16, (uint64_t)v17, v42, 0, a8);
      int v43 = *a8;
    }
    if (v43 > 0)
    {
      uint64_t v16 = 0;
LABEL_88:
      a3 = v40;
      goto LABEL_23;
    }
    uint64_t v16 = (v42 + 4);
    if ((int)v16 <= a4)
    {
      u_memcpy(v40, (const UChar *)aXn, 4);
      int32_t v45 = v42;
      a3 = v40;
      u_memcpy(v40 + 4, v17, v45);
LABEL_66:
      if ((int)v16 >= 64) {
        *a8 = 66566;
      }
LABEL_23:
      if (v14 == (_WORD *)v50) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
    int v44 = 15;
LABEL_87:
    *a8 = v44;
    goto LABEL_88;
  }
  int v14 = uprv_malloc((2 * v12));
  int v15 = v12;
  if (v14) {
    goto LABEL_8;
  }
LABEL_5:
  uint64_t v16 = 0;
  int v14 = 0;
  *a8 = 7;
  int32_t v17 = (UChar *)v48;
LABEL_24:
  uprv_free(v14);
LABEL_25:
  if (v17 != (UChar *)v48) {
    uprv_free(v17);
  }
  uprv_free(0);
  return u_terminateUChars((uint64_t)a3, a4, v16, a8);
}

int32_t uidna_toUnicode(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  if (!status || *(int *)status > 0) {
    return 0;
  }
  if (src
    && (uint64_t v10 = *(void *)&srcLength, srcLength >= -1)
    && (destCapacity & 0x80000000) == 0
    && (dest || !destCapacity))
  {
    uint64_t v15 = usprep_openByType(0, (int *)status);
    if (*(int *)status <= 0)
    {
      uint64_t v16 = v15;
      int32_t v17 = sub_18C87E058((UChar *)src, v10, dest, destCapacity, options, v15, (uint64_t)parseError, (int *)status);
      usprep_close(v16);
      return v17;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    int32_t result = 0;
    *status = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return result;
}

uint64_t sub_18C87E058(UChar *src, uint64_t a2, UChar *dest, int a4, int32_t a5, uint64_t a6, uint64_t a7, int *a8)
{
  int v11 = a4;
  uint64_t v12 = dest;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v67 = 0;
  memset(v66, 0, sizeof(v66));
  uint64_t v65 = 0;
  memset(v64, 0, sizeof(v64));
  uint64_t v63 = 0;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  *(_OWORD *)desta = 0u;
  long long v52 = 0u;
  if (a2 == -1)
  {
    unsigned int v18 = *src;
    if (!*src)
    {
      uint64_t v14 = 0;
      uint64_t v16 = src;
LABEL_42:
      if ((int)v14 <= v11) {
        u_memmove(v12, src, v14);
      }
      uint64_t v32 = (UChar *)v64;
      uint64_t v27 = v14;
      goto LABEL_47;
    }
    uint64_t v17 = 0;
    char v19 = 1;
    do
    {
      if (v18 > 0x7F) {
        char v19 = 0;
      }
      char v20 = &src[v17++];
      unsigned int v18 = v20[1];
    }
    while (v18);
    if (v19)
    {
      uint64_t v14 = v17;
      uint64_t v16 = src;
      goto LABEL_24;
    }
    parseError = (UParseError *)dest;
    int v22 = a4;
    uint64_t v14 = v17;
  }
  else
  {
    uint64_t v14 = a2;
    if ((int)a2 < 1) {
      return 0;
    }
    uint64_t v15 = 0;
    while (src[v15] <= 0x7Fu)
    {
      if (a2 == ++v15)
      {
        uint64_t v16 = src;
        LODWORD(v17) = a2;
        goto LABEL_24;
      }
    }
    parseError = (UParseError *)dest;
    int v22 = a4;
  }
  int32_t v23 = a5;
  char v24 = a5 & 1;
  uint64_t v16 = (UChar *)v66;
  int v25 = usprep_prepare(a6, src, v14, (UChar *)v66, 100, a5 & 1, a7, a8);
  LODWORD(v17) = v25;
  int v26 = *a8;
  if (*a8 == 15)
  {
    uint64_t v16 = (UChar *)uprv_malloc(2 * v25);
    if (!v16)
    {
      uint64_t v27 = 0;
      *a8 = 7;
      goto LABEL_46;
    }
    *a8 = 0;
    LODWORD(v17) = usprep_prepare(a6, src, v14, v16, v17, v24, a7, a8);
    int v26 = *a8;
  }
  if (v26 > 0)
  {
    uint64_t v27 = 0;
LABEL_46:
    uint64_t v32 = (UChar *)v64;
    int v11 = v22;
    uint64_t v12 = (UChar *)parseError;
    goto LABEL_47;
  }
  a5 = v23;
  int v11 = v22;
  uint64_t v12 = (UChar *)parseError;
LABEL_24:
  if ((int)v17 < 4) {
    goto LABEL_42;
  }
  int v28 = *v16;
  if ((v28 - 65) < 0x1A) {
    LOWORD(v28) = v28 + 32;
  }
  if ((unsigned __int16)v28 != 120) {
    goto LABEL_42;
  }
  uint64_t v29 = 1;
  while (v29 != 4)
  {
    int v30 = v16[v29];
    if ((v30 - 65) < 0x1A) {
      LOWORD(v30) = v30 + 32;
    }
    int v31 = (unsigned __int16)aXn[v29++];
    if (v31 != (unsigned __int16)v30)
    {
      if ((unint64_t)(v29 - 2) < 3) {
        goto LABEL_42;
      }
      break;
    }
  }
  int32_t options = a5;
  parseErrora = (UParseError *)a7;
  uint64_t v32 = (UChar *)v64;
  uint64_t v33 = u_strFromPunycode(v16 + 4, (v17 - 4), (uint64_t)v64, 100, 0, a8);
  uint64_t v27 = v33;
  if (*a8 == 15)
  {
    uint64_t v32 = (UChar *)uprv_malloc(2 * (int)v33);
    if (!v32) {
      goto LABEL_58;
    }
    *a8 = 0;
    uint64_t v27 = u_strFromPunycode(v16 + 4, (v17 - 4), (uint64_t)v32, v27, 0, a8);
  }
  long long v34 = desta;
  int32_t v35 = uidna_toASCII(v32, v27, desta, 100, options, parseErrora, (UErrorCode *)a8);
  int v36 = *a8;
  if (*a8 != 15)
  {
LABEL_40:
    if (v36 > 0)
    {
      uint64_t v27 = 0;
      goto LABEL_47;
    }
    if ((int)v17 >= v35) {
      uint64_t v39 = v35;
    }
    else {
      uint64_t v39 = v17;
    }
    if ((int)v17 < v35) {
      int v40 = -1;
    }
    else {
      int v40 = 1;
    }
    if (v17 == v35) {
      int v40 = 0;
    }
    if (v39)
    {
      int v41 = v16;
      while (1)
      {
        int v43 = *v41++;
        int v42 = v43;
        int v45 = *v34++;
        int v44 = v45;
        if (v42 != v45)
        {
          if ((v42 - 65) < 0x1A) {
            LOWORD(v42) = v42 + 32;
          }
          if ((v44 - 65) < 0x1A) {
            LOWORD(v44) = v44 + 32;
          }
          int v46 = (unsigned __int16)v42 - (unsigned __int16)v44;
          if (v46) {
            break;
          }
        }
        if (!--v39) {
          goto LABEL_78;
        }
      }
      int v40 = v46;
    }
LABEL_78:
    if (!v40)
    {
      if ((int)v27 <= v11) {
        u_memmove(v12, v32, v27);
      }
      goto LABEL_47;
    }
    uint64_t v27 = 0;
    int v38 = 66565;
    goto LABEL_80;
  }
  int32_t destCapacity = v35;
  uint64_t v37 = (UChar *)uprv_malloc(2 * v35);
  if (v37)
  {
    long long v34 = v37;
    *a8 = 0;
    int32_t v35 = uidna_toASCII(v32, v27, v37, destCapacity, options, parseErrora, (UErrorCode *)a8);
    int v36 = *a8;
    goto LABEL_40;
  }
LABEL_58:
  uint64_t v27 = 0;
  int v38 = 7;
LABEL_80:
  *a8 = v38;
LABEL_47:
  if (v16 != (UChar *)v66 && v16 != src) {
    uprv_free(v16);
  }
  if (v32 != (UChar *)v64) {
    uprv_free(v32);
  }
  uprv_free(0);
  if (*a8 >= 1)
  {
    if (v12)
    {
      if ((int)v14 <= v11) {
        u_memmove(v12, src, v14);
      }
    }
    *a8 = 0;
    uint64_t v27 = v14;
  }
  return u_terminateUChars((uint64_t)v12, v11, v27, a8);
}

int32_t uidna_IDNToASCII(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  if (!status || *(int *)status > 0) {
    return 0;
  }
  if (!src
    || (uint64_t v9 = *(void *)&srcLength, srcLength < -1)
    || (int32_t v10 = destCapacity, destCapacity < 0)
    || (uint64_t v12 = *(void *)&options, (v13 = dest) == 0) && destCapacity)
  {
    *status = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  uint64_t v15 = usprep_openByType(0, (int *)status);
  UErrorCode v16 = *status;
  if (*(int *)status > 0) {
    return 0;
  }
  uint64_t v17 = v15;
  int v40 = parseError;
  uint64_t v18 = 0;
  char v19 = (UChar *)src;
  uint64_t v37 = v13;
  uint64_t v20 = v9;
  int32_t v38 = v10;
  int v39 = v9;
  while (1)
  {
    if (v20 == -1)
    {
      for (uint64_t i = 0; ; ++i)
      {
        unsigned int v27 = v19[i];
        if (v27 <= 0x3001)
        {
          if (!v19[i])
          {
            uint64_t v21 = i;
            goto LABEL_46;
          }
          if (v27 == 46) {
            goto LABEL_43;
          }
        }
        else if (v27 == 12290 || v27 == 65294 || v27 == 65377)
        {
LABEL_43:
          int v22 = &v19[(i + 1)];
          int v30 = 1;
          uint64_t v21 = i;
          goto LABEL_47;
        }
      }
    }
    if ((int)v20 >= 1)
    {
      uint64_t v21 = 0;
      int v22 = v19 + 1;
      while (1)
      {
        unsigned int v23 = *(v22 - 1);
        if (v23 > 0xFF0D)
        {
          if (v23 == 65377 || v23 == 65294)
          {
LABEL_42:
            int v30 = 1;
            goto LABEL_47;
          }
        }
        else if (v23 == 46 || v23 == 12290)
        {
          goto LABEL_42;
        }
        ++v21;
        ++v22;
        if (v20 == v21)
        {
          uint64_t v21 = v20;
          goto LABEL_45;
        }
      }
    }
    uint64_t v21 = 0;
LABEL_45:
    uint64_t i = (int)v20;
LABEL_46:
    int v22 = &v19[i];
    int v30 = 0;
    if (v21) {
      break;
    }
    int v33 = 0;
LABEL_52:
    if (v16 > U_ZERO_ERROR
      || ((uint64_t v18 = (v33 + v18), v10 <= v33) ? (v34 = 0) : (v34 = v33),
          v10 <= v33 ? (int32_t v10 = 0) : (v10 -= v33),
          !v30))
    {
      int v35 = v38;
      uint64_t v36 = (uint64_t)v37;
      goto LABEL_69;
    }
    char v19 = v22;
LABEL_61:
    v13 += v34;
    if (v10 >= 1)
    {
      *v13++ = 46;
      --v10;
    }
    uint64_t v18 = (v18 + 1);
    if ((int)v20 <= 0) {
      uint64_t v20 = v20;
    }
    else {
      uint64_t v20 = v9 - ((unint64_t)((char *)v19 - (char *)src) >> 1);
    }
  }
LABEL_47:
  uint64_t v9 = v12;
  char v31 = v12;
  uint64_t v32 = v17;
  int v33 = sub_18C87DA60(v19, v21, v13, v10, v31, v17, (uint64_t)v40, (int *)status);
  UErrorCode v16 = *status;
  if (*status != U_BUFFER_OVERFLOW_ERROR)
  {
    uint64_t v17 = v32;
    uint64_t v12 = v9;
    LODWORD(v9) = v39;
    goto LABEL_52;
  }
  *status = U_ZERO_ERROR;
  uint64_t v18 = (v33 + v18);
  if (v30)
  {
    UErrorCode v16 = U_ZERO_ERROR;
    int v34 = v33 & (v33 >> 31);
    int32_t v10 = -v33 & (v33 >> 31);
    char v19 = v22;
    uint64_t v17 = v32;
    uint64_t v12 = v9;
    LODWORD(v9) = v39;
    goto LABEL_61;
  }
  int v35 = v38;
  uint64_t v36 = (uint64_t)v37;
  uint64_t v17 = v32;
LABEL_69:
  if ((int)v18 >= 256) {
    *status = U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR;
  }
  usprep_close(v17);

  return u_terminateUChars(v36, v35, v18, (int *)status);
}

int32_t uidna_IDNToUnicode(const UChar *src, int32_t srcLength, UChar *dest, int32_t destCapacity, int32_t options, UParseError *parseError, UErrorCode *status)
{
  if (!status || *(int *)status > 0) {
    return 0;
  }
  if (!src
    || (uint64_t v9 = *(void *)&srcLength, srcLength < -1)
    || (int32_t v10 = destCapacity, destCapacity < 0)
    || (char v13 = dest) == 0 && destCapacity)
  {
    *status = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  uint64_t v15 = usprep_openByType(0, (int *)status);
  if (*(int *)status > 0) {
    return 0;
  }
  uint64_t v16 = v15;
  int v36 = v9;
  int32_t v37 = options;
  int32_t v38 = parseError;
  uint64_t v17 = 0;
  uint64_t v18 = (UChar *)src;
  uint64_t v33 = (uint64_t)v13;
  uint64_t v19 = v9;
  int v34 = v10;
  int v35 = src;
  while (1)
  {
    if (v19 == -1)
    {
      uint64_t v21 = v18;
      for (unsigned int i = 1; ; ++i)
      {
        unsigned int v26 = *v21;
        if (v26 <= 0x3001)
        {
          if (!*v21)
          {
            int v29 = 0;
            uint64_t v20 = i - 1;
            goto LABEL_46;
          }
          if (v26 == 46)
          {
LABEL_42:
            uint64_t v20 = i - 1;
            uint64_t v21 = &v18[i];
LABEL_43:
            int v29 = 1;
            goto LABEL_46;
          }
        }
        else if (v26 == 12290 || v26 == 65294 || v26 == 65377)
        {
          goto LABEL_42;
        }
        ++v21;
      }
    }
    if ((int)v19 < 1)
    {
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v20 = 0;
      uint64_t v21 = v18 + 1;
      do
      {
        unsigned int v22 = *(v21 - 1);
        if (v22 > 0xFF0D)
        {
          if (v22 == 65377 || v22 == 65294) {
            goto LABEL_43;
          }
        }
        else if (v22 == 46 || v22 == 12290)
        {
          goto LABEL_43;
        }
        ++v20;
        ++v21;
      }
      while (v19 != v20);
      uint64_t v20 = v19;
    }
    int v29 = 0;
    uint64_t v21 = &v18[(int)v19];
LABEL_46:
    uint64_t v30 = v16;
    int32_t v31 = sub_18C87E058(v18, v20, v13, v10, v37, v16, (uint64_t)v38, (int *)status);
    if (*status == U_BUFFER_OVERFLOW_ERROR)
    {
      int32_t v10 = 0;
      *status = U_ZERO_ERROR;
      goto LABEL_49;
    }
    if (*(int *)status > 0) {
      break;
    }
LABEL_49:
    uint64_t v17 = (v31 + v17);
    if (v10 <= v31) {
      int32_t v32 = 0;
    }
    else {
      int32_t v32 = v31;
    }
    if (v10 <= v31) {
      int32_t v10 = 0;
    }
    else {
      v10 -= v31;
    }
    uint64_t v16 = v30;
    if (!v29) {
      goto LABEL_64;
    }
    v13 += v32;
    if (v10 >= 1)
    {
      *v13++ = v18[(int)v20];
      --v10;
    }
    uint64_t v17 = (v17 + 1);
    if ((int)v19 <= 0) {
      uint64_t v19 = v19;
    }
    else {
      uint64_t v19 = v36 - ((unint64_t)((char *)v21 - (char *)v35) >> 1);
    }
    uint64_t v18 = v21;
  }
  uint64_t v16 = v30;
LABEL_64:
  if ((int)v17 >= 256) {
    *status = U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR;
  }
  usprep_close(v16);

  return u_terminateUChars(v33, v34, v17, (int *)status);
}

int32_t uidna_compare(const UChar *s1, int32_t length1, const UChar *s2, int32_t length2, int32_t options, UErrorCode *status)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  if (!status || *(int *)status > 0) {
    return -1;
  }
  long long v91 = 0u;
  long long v90 = 0u;
  long long v89 = 0u;
  long long v88 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  *(_OWORD *)dest = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  *(_OWORD *)int v28 = 0u;
  long long v29 = 0u;
  memset(&v27, 0, sizeof(v27));
  uint64_t v14 = dest;
  int32_t v15 = uidna_IDNToASCII(s1, length1, dest, 256, options, &v27, status);
  int32_t v16 = v15;
  if (*status != U_BUFFER_OVERFLOW_ERROR)
  {
LABEL_8:
    uint64_t v17 = v28;
    int32_t v18 = uidna_IDNToASCII(s2, length2, v28, 256, options, &v27, status);
    int32_t v19 = v18;
    if (*status == U_BUFFER_OVERFLOW_ERROR)
    {
      uint64_t v17 = (UChar *)uprv_malloc(2 * v18);
      if (!v17)
      {
        *status = U_MEMORY_ALLOCATION_ERROR;
        int32_t v7 = -1;
        goto LABEL_33;
      }
      *status = U_ZERO_ERROR;
      int32_t v19 = uidna_IDNToASCII(s2, length2, v17, v19, options, &v27, status);
    }
    if (v16 >= v19) {
      unsigned int v20 = v19;
    }
    else {
      unsigned int v20 = v16;
    }
    if (v16 < v19) {
      int v21 = -1;
    }
    else {
      int v21 = 1;
    }
    if (v16 == v19) {
      int32_t v7 = 0;
    }
    else {
      int32_t v7 = v21;
    }
    if (v20)
    {
      unint64_t v22 = 0;
      uint64_t v23 = 2 * v20;
      while (1)
      {
        int v24 = v14[v22 / 2];
        int v25 = v17[v22 / 2];
        if (v24 != v25)
        {
          if ((v24 - 65) < 0x1A) {
            LOWORD(v24) = v24 + 32;
          }
          if ((v25 - 65) < 0x1A) {
            LOWORD(v25) = v25 + 32;
          }
          int v26 = (unsigned __int16)v24 - (unsigned __int16)v25;
          if (v26) {
            break;
          }
        }
        v22 += 2;
        if (v23 == v22) {
          goto LABEL_33;
        }
      }
      int32_t v7 = v26;
    }
LABEL_33:
    if (v14 == dest) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  uint64_t v14 = (UChar *)uprv_malloc(2 * v15);
  if (v14)
  {
    *status = U_ZERO_ERROR;
    int32_t v16 = uidna_IDNToASCII(s1, length1, v14, v16, options, &v27, status);
    goto LABEL_8;
  }
  *status = U_MEMORY_ALLOCATION_ERROR;
  uint64_t v17 = v28;
  int32_t v7 = -1;
LABEL_34:
  uprv_free(v14);
LABEL_35:
  if (v17 != v28) {
    uprv_free(v17);
  }
  return v7;
}

void u_init(UErrorCode *a1)
{
  if (*(int *)a1 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191E88, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191E88))
    {
      if (dword_1E9191E8C >= 1) {
        *a1 = dword_1E9191E8C;
      }
    }
    else
    {
      ucnv_io_countKnownConverters(a1);
      sub_18C8546F4(0x1Au, (uint64_t)sub_18C87EE68);
      dword_1E9191E8C = *a1;
      icu::umtx_initImplPostInit(&dword_1E9191E88);
    }
  }
}

uint64_t sub_18C87EE68()
{
  return 1;
}

void u_charsToUChars(const char *cs, UChar *us, int32_t length)
{
  if (length >= 1)
  {
    unsigned int v3 = length + 1;
    do
    {
      UChar v4 = *(unsigned __int8 *)cs++;
      *us++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
}

void u_UCharsToChars(const UChar *us, char *cs, int32_t length)
{
  if (length >= 1)
  {
    int v3 = length + 1;
    do
    {
      unsigned int v5 = *us++;
      unsigned int v4 = v5;
      if (v5 > 0x7F || ((dword_18CA81544[v4 >> 5] >> v4) & 1) == 0) {
        LOBYTE(v4) = 0;
      }
      *cs++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
}

uint64_t uprv_isInvariantString(unsigned __int8 *a1, int a2)
{
  while ((a2 & 0x80000000) == 0)
  {
    if (!a2) {
      return 1;
    }
    --a2;
    unsigned int v3 = *a1++;
    unsigned int v2 = v3;
    if (v3)
    {
LABEL_6:
      if ((v2 & 0x80) != 0 || ((dword_18CA81544[v2 >> 5] >> v2) & 1) == 0) {
        return 0;
      }
    }
  }
  unsigned int v4 = *a1++;
  unsigned int v2 = v4;
  if (v4) {
    goto LABEL_6;
  }
  return 1;
}

uint64_t uprv_isInvariantUString(_WORD *a1, int a2)
{
  while ((a2 & 0x80000000) == 0)
  {
    if (!a2) {
      return 1;
    }
    --a2;
    unsigned int v2 = (unsigned __int16)*a1;
LABEL_5:
    if (v2 <= 0x7F)
    {
      ++a1;
      if ((dword_18CA81544[v2 >> 5] >> v2)) {
        continue;
      }
    }
    return 0;
  }
  unsigned int v2 = (unsigned __int16)*a1;
  if (*a1) {
    goto LABEL_5;
  }
  return 1;
}

uint64_t uprv_ebcdicFromAscii(uint64_t a1, char *a2, uint64_t a3, unsigned char *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a5) {
    return 0;
  }
  if (*a5 <= 0)
  {
    int v9 = 1;
    if (a1 && a2 && (a3 & 0x80000000) == 0 && (!a3 || a4))
    {
      if (!a3) {
        return a3;
      }
      int v10 = 0;
      while (1)
      {
        int v12 = *a2++;
        unsigned __int8 v11 = v12;
        if (v12 < 0 || ((*(_DWORD *)((char *)dword_18CA81544 + (((unint64_t)v11 >> 3) & 0x1C)) >> v11) & 1) == 0) {
          break;
        }
        *a4++ = byte_18CA81757[v11];
        --v10;
        if ((int)a3 + v10 + 1 <= 1) {
          return a3;
        }
      }
      udata_printError(a1, (uint64_t)"uprv_ebcdicFromAscii() string[%d] contains a variant character in position %d\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, a3);
      int v9 = 10;
    }
    a3 = 0;
    *a5 = v9;
    return a3;
  }
  return 0;
}

uint64_t sub_18C87F070(uint64_t a1, unsigned char *a2, uint64_t __n, unsigned char *__dst, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (uint64_t v9 = __n, (__n & 0x80000000) == 0) && (!__n || __dst))
  {
    if (__n)
    {
      uint64_t v12 = 0;
      int v13 = __n + 1;
      do
      {
        if ((char)a2[v12] < 0
          || ((*(_DWORD *)((char *)dword_18CA81544 + (((unint64_t)a2[v12] >> 3) & 0x1C)) >> a2[v12]) & 1) == 0)
        {
          udata_printError(a1, (uint64_t)"uprv_copyFromAscii() string[%d] contains a variant character in position %d\n", __n, (uint64_t)__dst, (uint64_t)a5, a6, a7, a8, __n);
          uint64_t v9 = 0;
          int v10 = 10;
          goto LABEL_10;
        }
        ++v12;
        --v13;
      }
      while (v13 > 1);
      if (a2 != __dst) {
        memcpy(__dst, a2, __n);
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
LABEL_10:
    *a5 = v10;
  }
  return v9;
}

uint64_t sub_18C87F158(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned char *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a5) {
    return 0;
  }
  if (*a5 <= 0)
  {
    int v9 = 1;
    if (a1 && a2 && (a3 & 0x80000000) == 0 && (!a3 || a4))
    {
      if (!a3) {
        return a3;
      }
      int v10 = 0;
      while (1)
      {
        unsigned int v12 = *a2++;
        unint64_t v11 = v12;
        if (v12)
        {
          unint64_t v11 = byte_18CA81554[v11];
          if (!v11 || ((*(_DWORD *)((char *)dword_18CA81544 + ((v11 >> 3) & 0x1C)) >> v11) & 1) == 0) {
            break;
          }
        }
        *a4++ = v11;
        --v10;
        if ((int)a3 + v10 + 1 <= 1) {
          return a3;
        }
      }
      udata_printError(a1, (uint64_t)"uprv_asciiFromEbcdic() string[%d] contains a variant character in position %d\n", a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, a3);
      int v9 = 10;
    }
    a3 = 0;
    *a5 = v9;
    return a3;
  }
  return 0;
}

uint64_t sub_18C87F238(uint64_t a1, unsigned char *a2, uint64_t __n, unsigned char *__dst, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a5 || *a5 > 0) {
    return 0;
  }
  if (a1 && a2 && (uint64_t v9 = __n, (__n & 0x80000000) == 0) && (!__n || __dst))
  {
    if (__n)
    {
      uint64_t v12 = 0;
      int v13 = __n + 1;
      do
      {
        if (a2[v12])
        {
          if (!byte_18CA81554[a2[v12]]
            || (unint64_t v14 = byte_18CA81554[a2[v12]],
                ((*(_DWORD *)((char *)dword_18CA81544 + ((v14 >> 3) & 0x1C)) >> v14) & 1) == 0))
          {
            udata_printError(a1, (uint64_t)"uprv_copyEbcdic() string[%] contains a variant character in position %d\n", __n, (uint64_t)__dst, (uint64_t)a5, a6, a7, a8, __n);
            uint64_t v9 = 0;
            int v10 = 10;
            goto LABEL_10;
          }
        }
        ++v12;
        --v13;
      }
      while (v13 > 1);
      if (a2 != __dst) {
        memcpy(__dst, a2, __n);
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
LABEL_10:
    *a5 = v10;
  }
  return v9;
}

uint64_t sub_18C87F328(int a1, char *__s, int a3, UChar *s, int a5)
{
  uint64_t result = 0;
  if (!__s) {
    return result;
  }
  int v6 = a3;
  if (a3 < -1) {
    return result;
  }
  int32_t v7 = s;
  if (!s) {
    return result;
  }
  int32_t v8 = a5;
  if (a5 < -1) {
    return result;
  }
  uint64_t v9 = __s;
  if ((a3 & 0x80000000) == 0)
  {
    if ((a5 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  int v6 = strlen(__s);
  if (v8 < 0) {
LABEL_7:
  }
    int32_t v8 = u_strlen(v7);
LABEL_8:
  uint64_t result = (v6 - v8);
  if (v6 >= v8) {
    int v10 = v8;
  }
  else {
    int v10 = v6;
  }
  if (v10 >= 1)
  {
    int v11 = v10 + 1;
    while (1)
    {
      int v13 = *v9++;
      LOBYTE(v12) = v13;
      if (v13 < 0
        || (int v12 = v12,
            ((*(_DWORD *)((char *)dword_18CA81544 + (((unint64_t)v12 >> 3) & 0x1C)) >> v12) & 1) == 0))
      {
        int v12 = -1;
      }
      unsigned int v15 = *v7++;
      unint64_t v14 = v15;
      if (v15 > 0x7F || ((*(_DWORD *)((char *)dword_18CA81544 + ((v14 >> 3) & 0x1FFC)) >> v14) & 1) == 0) {
        LODWORD(v14) = -2;
      }
      uint64_t v16 = (v12 - v14);
      if (v16) {
        break;
      }
      if (--v11 < 2) {
        return result;
      }
    }
    return v16;
  }
  return result;
}

uint64_t sub_18C87F428(int a1, char *__s, int a3, UChar *s, int a5)
{
  uint64_t result = 0;
  if (!__s) {
    return result;
  }
  int v6 = a3;
  if (a3 < -1) {
    return result;
  }
  int32_t v7 = s;
  if (!s) {
    return result;
  }
  int32_t v8 = a5;
  if (a5 < -1) {
    return result;
  }
  uint64_t v9 = __s;
  if ((a3 & 0x80000000) == 0)
  {
    if ((a5 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  int v6 = strlen(__s);
  if (v8 < 0) {
LABEL_7:
  }
    int32_t v8 = u_strlen(v7);
LABEL_8:
  uint64_t result = (v6 - v8);
  if (v6 >= v8) {
    int v10 = v8;
  }
  else {
    int v10 = v6;
  }
  if (v10 >= 1)
  {
    int v11 = v10 + 1;
    while (1)
    {
      unsigned int v13 = *v9++;
      unint64_t v12 = v13;
      if (v13)
      {
        unint64_t v12 = byte_18CA81554[v12];
        if (!v12 || ((*(_DWORD *)((char *)dword_18CA81544 + ((v12 >> 3) & 0x1C)) >> v12) & 1) == 0) {
          LODWORD(v12) = -1;
        }
      }
      unsigned int v15 = *v7++;
      unint64_t v14 = v15;
      if (v15 > 0x7F || ((*(_DWORD *)((char *)dword_18CA81544 + ((v14 >> 3) & 0x1FFC)) >> v14) & 1) == 0) {
        LODWORD(v14) = -2;
      }
      uint64_t v16 = (v12 - v14);
      if (v16) {
        break;
      }
      if (--v11 < 2) {
        return result;
      }
    }
    return v16;
  }
  return result;
}

uint64_t uprv_compareInvEbcdicAsAscii(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1;
  int v3 = *a2;
  if (v2 != v3)
  {
LABEL_5:
    if (v2)
    {
      unint64_t v8 = byte_18CA81554[v2];
      if (!byte_18CA81554[v2] || ((*(_DWORD *)((char *)dword_18CA81544 + ((v8 >> 3) & 0x1C)) >> v8) & 1) == 0) {
        LODWORD(v8) = -v2;
      }
      if (v3) {
        goto LABEL_10;
      }
    }
    else
    {
      LODWORD(v8) = 0;
      if (v3)
      {
LABEL_10:
        unint64_t v9 = byte_18CA81554[v3];
        if (!byte_18CA81554[v3] || ((*(_DWORD *)((char *)dword_18CA81544 + ((v9 >> 3) & 0x1C)) >> v9) & 1) == 0) {
          LODWORD(v9) = -v3;
        }
        return (v8 - v9);
      }
    }
    LODWORD(v9) = 0;
    return (v8 - v9);
  }
  unsigned int v4 = a2 + 1;
  unsigned int v5 = a1 + 1;
  while (v2)
  {
    int v6 = *v5++;
    int v2 = v6;
    int v7 = *v4++;
    int v3 = v7;
    if (v2 != v7) {
      goto LABEL_5;
    }
  }
  return 0;
}

uint64_t uprv_ebcdicToAscii(unsigned __int8 a1)
{
  return (char)byte_18CA81554[a1];
}

uint64_t uprv_ebcdicToLowercaseAscii(unsigned __int8 a1)
{
  return byte_18CA81657[a1];
}

unsigned char *uprv_aestrncpy(unsigned char *a1, char *__s, int a3)
{
  if (a3 == -1) {
    a3 = strlen(__s) + 1;
  }
  int v5 = *__s;
  if (*__s) {
    BOOL v6 = a3 < 1;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    unint64_t v9 = a1;
    int v7 = a3;
  }
  else
  {
    unint64_t v8 = __s + 1;
    unint64_t v9 = a1;
    do
    {
      *v9++ = byte_18CA81554[v5];
      int v7 = a3 - 1;
      int v10 = *v8++;
      int v5 = v10;
      if (v10) {
        BOOL v11 = a3 > 1;
      }
      else {
        BOOL v11 = 0;
      }
      --a3;
    }
    while (v11);
  }
  if (v7 >= 1) {
    bzero(v9, v7);
  }
  return a1;
}

unsigned char *uprv_eastrncpy(unsigned char *a1, char *__s, int a3)
{
  if (a3 == -1) {
    a3 = strlen(__s) + 1;
  }
  int v5 = *__s;
  if (*__s) {
    BOOL v6 = a3 < 1;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    unint64_t v9 = a1;
    int v7 = a3;
  }
  else
  {
    unint64_t v8 = __s + 1;
    unint64_t v9 = a1;
    do
    {
      int v10 = byte_18CA81757[v5];
      if (!v10) {
        LOBYTE(v10) = 111;
      }
      *v9++ = v10;
      int v7 = a3 - 1;
      int v11 = *v8++;
      int v5 = v11;
      if (v11) {
        BOOL v12 = a3 > 1;
      }
      else {
        BOOL v12 = 0;
      }
      --a3;
    }
    while (v12);
  }
  if (v7 >= 1) {
    bzero(v9, v7);
  }
  return a1;
}

void uiter_setString(UCharIterator *iter, const UChar *s, int32_t length)
{
  if (iter)
  {
    if (s && length >= -1)
    {
      long long v4 = *(_OWORD *)&off_1EDA47080;
      *(_OWORD *)&iter->current = xmmword_1EDA47070;
      *(_OWORD *)&iter->previous = v4;
      *(_OWORD *)&iter->getState = xmmword_1EDA47090;
      long long v5 = unk_1EDA47040;
      *(_OWORD *)&iter->context = xmmword_1EDA47030;
      *(_OWORD *)&iter->index = v5;
      long long v6 = *(_OWORD *)&off_1EDA47060;
      *(_OWORD *)&iter->getint Index = xmmword_1EDA47050;
      *(_OWORD *)&iter->hasNext = v6;
      iter->context = s;
      if (length < 0) {
        length = u_strlen(s);
      }
      iter->length = length;
      iter->limit = length;
    }
    else
    {
      long long v7 = *(_OWORD *)&off_1EDA470F0;
      *(_OWORD *)&iter->current = xmmword_1EDA470E0;
      *(_OWORD *)&iter->previous = v7;
      *(_OWORD *)&iter->getState = xmmword_1EDA47100;
      long long v8 = *(_OWORD *)algn_1EDA470B0;
      *(_OWORD *)&iter->context = xmmword_1EDA470A0;
      *(_OWORD *)&iter->index = v8;
      long long v9 = *(_OWORD *)&off_1EDA470D0;
      *(_OWORD *)&iter->getint Index = xmmword_1EDA470C0;
      *(_OWORD *)&iter->hasNext = v9;
    }
  }
}

void uiter_setUTF16BE(UCharIterator *iter, const char *s, int32_t length)
{
  if (iter)
  {
    int v3 = iter;
    if (!s)
    {
LABEL_5:
      long long v4 = *(_OWORD *)&off_1EDA470F0;
      *(_OWORD *)&iter->current = xmmword_1EDA470E0;
      *(_OWORD *)&iter->previous = v4;
      *(_OWORD *)&iter->getState = xmmword_1EDA47100;
      long long v5 = *(_OWORD *)algn_1EDA470B0;
      *(_OWORD *)&iter->context = xmmword_1EDA470A0;
      *(_OWORD *)&iter->index = v5;
      long long v6 = *(_OWORD *)&off_1EDA470D0;
      *(_OWORD *)&iter->getint Index = xmmword_1EDA470C0;
      *(_OWORD *)&iter->hasNext = v6;
      return;
    }
    if (length == -1)
    {
      long long v7 = *(_OWORD *)&off_1EDA47160;
      *(_OWORD *)&iter->current = xmmword_1EDA47150;
      *(_OWORD *)&iter->previous = v7;
      *(_OWORD *)&iter->getState = xmmword_1EDA47170;
      long long v8 = unk_1EDA47120;
      *(_OWORD *)&iter->context = xmmword_1EDA47110;
      *(_OWORD *)&iter->index = v8;
      long long v9 = *(_OWORD *)&off_1EDA47140;
      *(_OWORD *)&iter->getint Index = xmmword_1EDA47130;
      *(_OWORD *)&iter->hasNext = v9;
      iter->context = s;
      if (s)
      {
        for (uint64_t i = 0; s[i] || s[i + 1]; i += 2)
          ;
        iter = (UCharIterator *)((i + (unint64_t)(i < 0)) >> 1);
      }
      else
      {
        LODWORD(iter) = u_strlen((const UChar *)s);
      }
    }
    else
    {
      if ((length & 0x80000001) != 0) {
        goto LABEL_5;
      }
      long long v10 = *(_OWORD *)&off_1EDA47160;
      *(_OWORD *)&iter->current = xmmword_1EDA47150;
      *(_OWORD *)&iter->previous = v10;
      *(_OWORD *)&iter->getState = xmmword_1EDA47170;
      long long v11 = unk_1EDA47120;
      *(_OWORD *)&iter->context = xmmword_1EDA47110;
      *(_OWORD *)&iter->index = v11;
      long long v12 = *(_OWORD *)&off_1EDA47140;
      *(_OWORD *)&iter->getint Index = xmmword_1EDA47130;
      *(_OWORD *)&iter->hasNext = v12;
      LODWORD(iter) = length >> 1;
      v3->context = s;
    }
    v3->length = (int)iter;
    v3->limit = (int)iter;
  }
}

__n128 uiter_setCharacterIterator(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      long long v2 = *(_OWORD *)&off_1EDA471D0;
      *(_OWORD *)(a1 + 64) = xmmword_1EDA471C0;
      *(_OWORD *)(a1 + 80) = v2;
      *(_OWORD *)(a1 + 96) = xmmword_1EDA471E0;
      long long v3 = *(_OWORD *)algn_1EDA47190;
      *(_OWORD *)a1 = xmmword_1EDA47180;
      *(_OWORD *)(a1 + 16) = v3;
      __n128 result = *(__n128 *)&off_1EDA471B0;
      *(_OWORD *)(a1 + 32) = xmmword_1EDA471A0;
      *(__n128 *)(a1 + 48) = result;
      *(void *)a1 = a2;
    }
    else
    {
      long long v5 = *(_OWORD *)&off_1EDA470F0;
      *(_OWORD *)(a1 + 64) = xmmword_1EDA470E0;
      *(_OWORD *)(a1 + 80) = v5;
      *(_OWORD *)(a1 + 96) = xmmword_1EDA47100;
      long long v6 = *(_OWORD *)algn_1EDA470B0;
      *(_OWORD *)a1 = xmmword_1EDA470A0;
      *(_OWORD *)(a1 + 16) = v6;
      __n128 result = *(__n128 *)&off_1EDA470D0;
      *(_OWORD *)(a1 + 32) = xmmword_1EDA470C0;
      *(__n128 *)(a1 + 48) = result;
    }
  }
  return result;
}

__n128 uiter_setReplaceable(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      long long v3 = unk_1EDA47200;
      *(_OWORD *)a1 = xmmword_1EDA471F0;
      *(_OWORD *)(a1 + 16) = v3;
      *(_OWORD *)(a1 + 96) = xmmword_1EDA47250;
      long long v4 = *(_OWORD *)&off_1EDA47240;
      *(_OWORD *)(a1 + 64) = xmmword_1EDA47230;
      *(_OWORD *)(a1 + 80) = v4;
      long long v5 = *(_OWORD *)&off_1EDA47220;
      *(_OWORD *)(a1 + 32) = xmmword_1EDA47210;
      *(_OWORD *)(a1 + 48) = v5;
      *(void *)a1 = a2;
      int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
      *(_DWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 + 20) = v6;
    }
    else
    {
      long long v8 = *(_OWORD *)&off_1EDA470F0;
      *(_OWORD *)(a1 + 64) = xmmword_1EDA470E0;
      *(_OWORD *)(a1 + 80) = v8;
      *(_OWORD *)(a1 + 96) = xmmword_1EDA47100;
      long long v9 = *(_OWORD *)algn_1EDA470B0;
      *(_OWORD *)a1 = xmmword_1EDA470A0;
      *(_OWORD *)(a1 + 16) = v9;
      __n128 result = *(__n128 *)&off_1EDA470D0;
      *(_OWORD *)(a1 + 32) = xmmword_1EDA470C0;
      *(__n128 *)(a1 + 48) = result;
    }
  }
  return result;
}

void uiter_setUTF8(UCharIterator *iter, const char *s, int32_t length)
{
  if (iter)
  {
    if (s && length >= -1)
    {
      long long v4 = *(_OWORD *)&off_1EDA472B0;
      *(_OWORD *)&iter->current = xmmword_1EDA472A0;
      *(_OWORD *)&iter->previous = v4;
      *(_OWORD *)&iter->getState = xmmword_1EDA472C0;
      long long v5 = *(_OWORD *)algn_1EDA47270;
      *(_OWORD *)&iter->context = xmmword_1EDA47260;
      *(_OWORD *)&iter->index = v5;
      long long v6 = *(_OWORD *)&off_1EDA47290;
      *(_OWORD *)&iter->getint Index = xmmword_1EDA47280;
      *(_OWORD *)&iter->hasNext = v6;
      iter->context = s;
      if (length < 0) {
        length = strlen(s);
      }
      iter->limit = length;
      if (length >= 2) {
        int32_t v7 = -1;
      }
      else {
        int32_t v7 = length;
      }
      iter->length = v7;
    }
    else
    {
      long long v8 = *(_OWORD *)&off_1EDA470F0;
      *(_OWORD *)&iter->current = xmmword_1EDA470E0;
      *(_OWORD *)&iter->previous = v8;
      *(_OWORD *)&iter->getState = xmmword_1EDA47100;
      long long v9 = *(_OWORD *)algn_1EDA470B0;
      *(_OWORD *)&iter->context = xmmword_1EDA470A0;
      *(_OWORD *)&iter->index = v9;
      long long v10 = *(_OWORD *)&off_1EDA470D0;
      *(_OWORD *)&iter->getint Index = xmmword_1EDA470C0;
      *(_OWORD *)&iter->hasNext = v10;
    }
  }
}

UChar32 uiter_current32(UCharIterator *iter)
{
  unsigned int v2 = ((uint64_t (*)(void))iter->current)();
  UChar32 v3 = v2;
  if (v2 >> 11 == 27)
  {
    if ((v2 & 0x400) == 0)
    {
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, 1, 1);
      unsigned int v4 = ((uint64_t (*)(UCharIterator *))iter->current)(iter);
      if (v4 >> 10 == 55) {
        UChar32 v3 = v4 + (v3 << 10) - 56613888;
      }
      uint64_t v5 = 0xFFFFFFFFLL;
      goto LABEL_10;
    }
    unsigned int v6 = ((uint64_t (*)(UCharIterator *))iter->previous)(iter);
    if (v6 >> 10 == 54) {
      UChar32 v3 = v3 + (v6 << 10) - 56613888;
    }
    if ((v6 & 0x80000000) == 0)
    {
      uint64_t v5 = 1;
LABEL_10:
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, v5, 1);
    }
  }
  return v3;
}

UChar32 uiter_next32(UCharIterator *iter)
{
  unsigned int v2 = ((uint64_t (*)(void))iter->next)();
  if (v2 >> 10 == 54)
  {
    unsigned int v3 = ((uint64_t (*)(UCharIterator *))iter->next)(iter);
    if (v3 >> 10 == 55)
    {
      return v3 + (v2 << 10) - 56613888;
    }
    else if ((v3 & 0x80000000) == 0)
    {
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, 0xFFFFFFFFLL, 1);
    }
  }
  return v2;
}

UChar32 uiter_previous32(UCharIterator *iter)
{
  unsigned int v2 = ((uint64_t (*)(void))iter->previous)();
  if (v2 >> 10 == 55)
  {
    unsigned int v3 = ((uint64_t (*)(UCharIterator *))iter->previous)(iter);
    if (v3 >> 10 == 54)
    {
      return v2 + (v3 << 10) - 56613888;
    }
    else if ((v3 & 0x80000000) == 0)
    {
      ((void (*)(UCharIterator *, uint64_t, uint64_t))iter->move)(iter, 1, 1);
    }
  }
  return v2;
}

uint32_t uiter_getState(const UCharIterator *iter)
{
  if (iter && (getState = (uint64_t (*)(void))iter->getState) != 0) {
    return getState();
  }
  else {
    return -1;
  }
}

void uiter_setState(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode)
{
  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (iter)
    {
      setState = (void (*)(void))iter->setState;
      if (setState)
      {
        setState();
        return;
      }
      UErrorCode v4 = U_UNSUPPORTED_ERROR;
    }
    else
    {
      UErrorCode v4 = U_ILLEGAL_ARGUMENT_ERROR;
    }
    *UErrorCode pErrorCode = v4;
  }
}

uint64_t sub_18C87FCB8(unsigned int *a1, int a2)
{
  uint64_t result = 0;
  switch(a2)
  {
    case 0:
      uint64_t result = a1[3];
      break;
    case 1:
      uint64_t result = a1[4];
      break;
    case 2:
      uint64_t result = a1[5];
      break;
    case 3:
      return result;
    case 4:
      uint64_t result = a1[2];
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_18C87FD28(_DWORD *a1, int a2, int a3)
{
  switch(a3)
  {
    case 0:
      int v3 = a1[3];
      goto LABEL_7;
    case 1:
      int v3 = a1[4];
      goto LABEL_7;
    case 2:
      int v3 = a1[5];
      goto LABEL_7;
    case 3:
      goto LABEL_8;
    case 4:
      int v3 = a1[2];
LABEL_7:
      a2 += v3;
LABEL_8:
      uint64_t v4 = a1[3];
      if (a2 >= (int)v4)
      {
        LODWORD(v4) = a1[5];
        if (a2 >= (int)v4) {
          uint64_t v4 = v4;
        }
        else {
          uint64_t v4 = a2;
        }
      }
      a1[4] = v4;
      break;
    default:
      uint64_t v4 = 0xFFFFFFFFLL;
      break;
  }
  return v4;
}

BOOL sub_18C87FDB4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 20);
}

BOOL sub_18C87FDC4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) > *(_DWORD *)(a1 + 12);
}

uint64_t sub_18C87FDD4(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 16);
  if ((int)v1 >= *(_DWORD *)(a1 + 20)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(unsigned __int16 *)(*(void *)a1 + 2 * v1);
  }
}

uint64_t sub_18C87FDF8(uint64_t *a1)
{
  uint64_t v1 = *((int *)a1 + 4);
  if ((int)v1 >= *((_DWORD *)a1 + 5)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *a1;
  *((_DWORD *)a1 + 4) = v1 + 1;
  return *(unsigned __int16 *)(v2 + 2 * v1);
}

uint64_t sub_18C87FE24(uint64_t *a1)
{
  int v1 = *((_DWORD *)a1 + 4);
  if (v1 <= *((_DWORD *)a1 + 3)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *a1;
  int v3 = v1 - 1;
  *((_DWORD *)a1 + 4) = v3;
  return *(unsigned __int16 *)(v2 + 2 * v3);
}

uint64_t sub_18C87FE4C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

_DWORD *sub_18C87FE54(_DWORD *result, int a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    if (result)
    {
      if (result[3] <= a2 && result[5] >= a2)
      {
        result[4] = a2;
        return result;
      }
      int v3 = 8;
    }
    else
    {
      int v3 = 1;
    }
    *a3 = v3;
  }
  return result;
}

uint64_t sub_18C87FEA0()
{
  return 0;
}

uint64_t sub_18C87FEA8()
{
  return 0;
}

uint64_t sub_18C87FEB0()
{
  return 0;
}

uint64_t sub_18C87FEB8()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_18C87FEC0()
{
  return 0xFFFFFFFFLL;
}

void sub_18C87FEC8(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 16;
}

uint64_t sub_18C87FED4(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 16);
  if ((int)v1 >= *(_DWORD *)(a1 + 20)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(unsigned __int8 *)(*(void *)a1 + 2 * (int)v1 + 1) | (*(unsigned __int8 *)(*(void *)a1 + 2 * v1) << 8);
  }
}

uint64_t sub_18C87FF08(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 16);
  if ((int)v1 >= *(_DWORD *)(a1 + 20)) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 16) = v1 + 1;
  return *(unsigned __int8 *)(*(void *)a1 + 2 * (int)v1 + 1) | (*(unsigned __int8 *)(*(void *)a1 + 2 * v1) << 8);
}

uint64_t sub_18C87FF44(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1 <= *(_DWORD *)(a1 + 12)) {
    return 0xFFFFFFFFLL;
  }
  int v2 = v1 - 1;
  *(_DWORD *)(a1 + 16) = v2;
  return *(unsigned __int8 *)(*(void *)a1 + 2 * v2 + 1) | (*(unsigned __int8 *)(*(void *)a1 + 2 * v2) << 8);
}

uint64_t sub_18C87FF7C(uint64_t a1, int a2)
{
  uint64_t result = 0;
  switch(a2)
  {
    case 0:
      uint64_t result = *(unsigned int *)(*(void *)a1 + 16);
      break;
    case 1:
      uint64_t result = *(unsigned int *)(*(void *)a1 + 12);
      break;
    case 2:
      uint64_t result = *(unsigned int *)(*(void *)a1 + 20);
      break;
    case 3:
      return result;
    case 4:
      uint64_t result = *(unsigned int *)(*(void *)a1 + 8);
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_18C87FFFC(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  if (a3 >= 3)
  {
    if (a3 == 4)
    {
      uint64_t v6 = *a1;
    }
    else
    {
      if (a3 != 3) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v6 = *a1;
    }
    (*(void (**)(uint64_t))(*(void *)v6 + 120))(v6);
    return *(unsigned int *)(*a1 + 12);
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)*a1 + 192);

  return v4();
}

uint64_t sub_18C8800BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 56))();
}

uint64_t sub_18C8800E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 184))();
}

uint64_t sub_18C88010C(void *a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(*(void *)*a1 + 136))(*a1);
  if (v2 == 0xFFFF)
  {
    if ((*(unsigned int (**)(void))(*(void *)*a1 + 56))()) {
      return 0xFFFFLL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return v2;
}

uint64_t sub_18C880198(void *a1)
{
  if ((*(unsigned int (**)(void))(*(void *)*a1 + 56))(*a1)) {
    return (*(uint64_t (**)(void))(*(void *)*a1 + 40))();
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_18C880214(void *a1)
{
  if ((*(unsigned int (**)(void))(*(void *)*a1 + 184))(*a1)) {
    return (*(uint64_t (**)(void))(*(void *)*a1 + 168))();
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_18C880290(uint64_t a1)
{
  return *(unsigned int *)(*(void *)a1 + 12);
}

_DWORD *sub_18C88029C(_DWORD *result, int a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    if (result && (uint64_t result = *(_DWORD **)result) != 0)
    {
      if (result[4] <= a2 && result[5] >= a2) {
        return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 120))();
      }
      int v3 = 8;
    }
    else
    {
      int v3 = 1;
    }
    *a3 = v3;
  }
  return result;
}

uint64_t sub_18C88030C(_DWORD *a1)
{
  if (a1[4] >= a1[5]) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)a1 + 72))(*(void *)a1);
  }
}

uint64_t sub_18C88035C(uint64_t *a1)
{
  int v1 = *((_DWORD *)a1 + 4);
  if (v1 >= *((_DWORD *)a1 + 5)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *a1;
  *((_DWORD *)a1 + 4) = v1 + 1;
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 72))(v2);
}

uint64_t sub_18C8803B8(uint64_t *a1)
{
  int v1 = *((_DWORD *)a1 + 4);
  if (v1 <= *((_DWORD *)a1 + 3)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *a1;
  *((_DWORD *)a1 + 4) = v1 - 1;
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 72))(v2);
}

uint64_t sub_18C880414(uint64_t *a1, int a2)
{
  uint64_t v2 = 0;
  switch(a2)
  {
    case 0:
    case 3:
      return v2;
    case 1:
      uint64_t v2 = *((unsigned int *)a1 + 4);
      if ((v2 & 0x80000000) == 0) {
        return v2;
      }
      int v5 = *((_DWORD *)a1 + 3);
      if (v5 >= 1)
      {
        int v6 = 0;
        int v7 = 0;
        uint64_t v8 = *a1;
        while (1)
        {
          uint64_t v9 = v7;
          uint64_t v10 = v7 + 1;
          int v11 = *(char *)(v8 + v7);
          if ((v11 & 0x80000000) == 0 || v10 == v5) {
            goto LABEL_30;
          }
          unsigned int v12 = *(unsigned __int8 *)(v8 + v7);
          if (v11 < 0xE0u)
          {
            if (v12 < 0xC2) {
              goto LABEL_30;
            }
            unsigned int v16 = v11 & 0x1F;
          }
          else
          {
            if (v12 > 0xEF)
            {
              if (v12 > 0xF4) {
                goto LABEL_30;
              }
              unsigned int v18 = v12 - 240;
              unint64_t v13 = *(unsigned __int8 *)(v8 + v10);
              if (((byte_18CA81857[v13 >> 4] >> v18) & 1) == 0) {
                goto LABEL_30;
              }
              uint64_t v19 = v9 + 2;
              LODWORD(v10) = *((_DWORD *)a1 + 3);
              if (v9 + 2 == v5) {
                goto LABEL_30;
              }
              unsigned int v14 = *(unsigned __int8 *)(v8 + v19) ^ 0x80;
              if (v14 > 0x3F)
              {
                LODWORD(v10) = v19;
LABEL_30:
                int v17 = 1;
                goto LABEL_31;
              }
              LODWORD(v13) = v13 & 0x3F | (v18 << 6);
              LODWORD(v10) = v19;
            }
            else
            {
              unint64_t v13 = v11 & 0xF;
              if (((a00000000000000[v13] >> (*(unsigned char *)(v8 + v10) >> 5)) & 1) == 0) {
                goto LABEL_30;
              }
              unsigned int v14 = *(unsigned char *)(v8 + v10) & 0x3F;
            }
            int v15 = v10 + 1;
            LODWORD(v10) = *((_DWORD *)a1 + 3);
            if (v15 == v5) {
              goto LABEL_30;
            }
            unsigned int v16 = v14 | (v13 << 6);
            LODWORD(v10) = v15;
          }
          if (*(char *)(v8 + (int)v10) > -65) {
            goto LABEL_30;
          }
          LODWORD(v10) = v10 + 1;
          if (v16 <= 0x3FF) {
            goto LABEL_30;
          }
          int v17 = 2;
LABEL_31:
          v6 += v17;
          int v7 = v10;
          if ((int)v10 >= v5) {
            goto LABEL_58;
          }
        }
      }
      LODWORD(v10) = 0;
      int v6 = 0;
LABEL_58:
      *((_DWORD *)a1 + 3) = v10;
      if (v10 == *((_DWORD *)a1 + 5)) {
        *((_DWORD *)a1 + 2) = v6;
      }
      uint64_t v2 = v6 - (*((_DWORD *)a1 + 6) != 0);
      *((_DWORD *)a1 + 4) = v2;
      return v2;
    case 2:
    case 4:
      uint64_t v2 = *((unsigned int *)a1 + 2);
      if ((v2 & 0x80000000) == 0) {
        return v2;
      }
      uint64_t v3 = *a1;
      int v4 = *((_DWORD *)a1 + 3);
      LODWORD(v2) = *((_DWORD *)a1 + 4);
      if ((v2 & 0x80000000) != 0)
      {
        if (v4 < 1)
        {
          LODWORD(v22) = 0;
          uint64_t v2 = 0;
LABEL_62:
          BOOL v32 = *((_DWORD *)a1 + 6) != 0;
          *((_DWORD *)a1 + 3) = v22;
          *((_DWORD *)a1 + 4) = v2 - v32;
          int v4 = v22;
          goto LABEL_63;
        }
        LODWORD(v2) = 0;
        int v20 = 0;
        while (1)
        {
          uint64_t v21 = v20;
          uint64_t v22 = v20 + 1;
          int v23 = *(char *)(v3 + v20);
          if ((v23 & 0x80000000) == 0 || v22 == v4) {
            goto LABEL_54;
          }
          unsigned int v24 = *(unsigned __int8 *)(v3 + v20);
          if (v23 < 0xE0u)
          {
            if (v24 < 0xC2) {
              goto LABEL_54;
            }
            unsigned int v28 = v23 & 0x1F;
          }
          else
          {
            if (v24 > 0xEF)
            {
              if (v24 > 0xF4) {
                goto LABEL_54;
              }
              unsigned int v30 = v24 - 240;
              unint64_t v25 = *(unsigned __int8 *)(v3 + v22);
              if (((byte_18CA81857[v25 >> 4] >> v30) & 1) == 0) {
                goto LABEL_54;
              }
              uint64_t v31 = v21 + 2;
              LODWORD(v22) = *((_DWORD *)a1 + 3);
              if (v21 + 2 == v4) {
                goto LABEL_54;
              }
              unsigned int v26 = *(unsigned __int8 *)(v3 + v31) ^ 0x80;
              if (v26 > 0x3F)
              {
                LODWORD(v22) = v31;
LABEL_54:
                int v29 = 1;
                goto LABEL_55;
              }
              LODWORD(v25) = v25 & 0x3F | (v30 << 6);
              LODWORD(v22) = v31;
            }
            else
            {
              unint64_t v25 = v23 & 0xF;
              if (((a00000000000000[v25] >> (*(unsigned char *)(v3 + v22) >> 5)) & 1) == 0) {
                goto LABEL_54;
              }
              unsigned int v26 = *(unsigned char *)(v3 + v22) & 0x3F;
            }
            int v27 = v22 + 1;
            LODWORD(v22) = *((_DWORD *)a1 + 3);
            if (v27 == v4) {
              goto LABEL_54;
            }
            unsigned int v28 = v26 | (v25 << 6);
            LODWORD(v22) = v27;
          }
          if (*(char *)(v3 + (int)v22) > -65) {
            goto LABEL_54;
          }
          LODWORD(v22) = v22 + 1;
          if (v28 <= 0x3FF) {
            goto LABEL_54;
          }
          int v29 = 2;
LABEL_55:
          uint64_t v2 = (v29 + v2);
          int v20 = v22;
          if ((int)v22 >= v4) {
            goto LABEL_62;
          }
        }
      }
      if (*((_DWORD *)a1 + 6)) {
        uint64_t v2 = (v2 + 1);
      }
      else {
        uint64_t v2 = v2;
      }
LABEL_63:
      int v33 = *((_DWORD *)a1 + 5);
      if (v4 < v33)
      {
        do
        {
          uint64_t v34 = v4;
          uint64_t v35 = v4 + 1;
          int v36 = *(char *)(v3 + v4);
          if ((v36 & 0x80000000) == 0 || v35 == v33) {
            goto LABEL_83;
          }
          unsigned int v37 = *(unsigned __int8 *)(v3 + v4);
          if (v36 < 0xE0u)
          {
            if (v37 < 0xC2) {
              goto LABEL_83;
            }
            unsigned int v41 = v36 & 0x1F;
          }
          else
          {
            if (v37 > 0xEF)
            {
              if (v37 > 0xF4) {
                goto LABEL_83;
              }
              unsigned int v43 = v37 - 240;
              unint64_t v38 = *(unsigned __int8 *)(v3 + v35);
              if (((byte_18CA81857[v38 >> 4] >> v43) & 1) == 0) {
                goto LABEL_83;
              }
              uint64_t v44 = v34 + 2;
              LODWORD(v35) = *((_DWORD *)a1 + 5);
              if (v34 + 2 == v33) {
                goto LABEL_83;
              }
              unsigned int v39 = *(unsigned __int8 *)(v3 + v44) ^ 0x80;
              if (v39 > 0x3F)
              {
                LODWORD(v35) = v44;
LABEL_83:
                int v42 = 1;
                goto LABEL_84;
              }
              LODWORD(v38) = v38 & 0x3F | (v43 << 6);
              LODWORD(v35) = v44;
            }
            else
            {
              unint64_t v38 = v36 & 0xF;
              if (((a00000000000000[v38] >> (*(unsigned char *)(v3 + v35) >> 5)) & 1) == 0) {
                goto LABEL_83;
              }
              unsigned int v39 = *(unsigned char *)(v3 + v35) & 0x3F;
            }
            int v40 = v35 + 1;
            LODWORD(v35) = *((_DWORD *)a1 + 5);
            if (v40 == v33) {
              goto LABEL_83;
            }
            unsigned int v41 = v39 | (v38 << 6);
            LODWORD(v35) = v40;
          }
          if (*(char *)(v3 + (int)v35) > -65) {
            goto LABEL_83;
          }
          LODWORD(v35) = v35 + 1;
          if (v41 <= 0x3FF) {
            goto LABEL_83;
          }
          int v42 = 2;
LABEL_84:
          uint64_t v2 = (v42 + v2);
          int v4 = v35;
        }
        while ((int)v35 < v33);
      }
      *((_DWORD *)a1 + 2) = v2;
      return v2;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t sub_18C880840(uint64_t a1, signed int a2, int a3)
{
  signed int v3 = a2;
  switch(a3)
  {
    case 0:
    case 3:
      goto LABEL_7;
    case 1:
      uint64_t v7 = *(unsigned int *)(a1 + 16);
      if ((v7 & 0x80000000) == 0)
      {
        signed int v3 = v7 + a2;
        goto LABEL_7;
      }
      if (!a2) {
        return 4294967294;
      }
      uint64_t v9 = *(unsigned int *)(a1 + 12);
      goto LABEL_56;
    case 2:
    case 4:
      int v5 = *(_DWORD *)(a1 + 8);
      if ((v5 & 0x80000000) == 0)
      {
        signed int v3 = v5 + a2;
LABEL_7:
        if (v3 > 0)
        {
          uint64_t v6 = *(unsigned int *)(a1 + 8);
          if ((v6 & 0x80000000) == 0 && (int)v6 <= v3)
          {
            *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 20);
            *(_DWORD *)(a1 + 16) = v6;
            *(_DWORD *)(a1 + 24) = 0;
            return v6;
          }
          uint64_t v8 = (_DWORD *)(a1 + 16);
          uint64_t v7 = *(unsigned int *)(a1 + 16);
          if ((v7 & 0x80000000) != 0 || v3 < v7 >> 1)
          {
            uint64_t v6 = 0;
            *(_DWORD *)(a1 + 24) = 0;
            *(_DWORD *)(a1 + 12) = 0;
          }
          else
          {
            if ((v6 & 0x80000000) != 0 || (int)v6 - v3 >= v3 - (int)v7) {
              goto LABEL_20;
            }
            *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 20);
            *(_DWORD *)(a1 + 16) = v6;
            uint64_t v8 = (_DWORD *)(a1 + 24);
          }
          *uint64_t v8 = 0;
          uint64_t v7 = v6;
LABEL_20:
          v3 -= v7;
          if (!v3) {
            return v7;
          }
          uint64_t v9 = *(unsigned int *)(a1 + 12);
LABEL_22:
          uint64_t v10 = *(const uint8_t **)a1;
          if (v3 < 1)
          {
            if (*(_DWORD *)(a1 + 24))
            {
              *(_DWORD *)(a1 + 24) = 0;
              uint64_t v11 = (v9 - 4);
              uint64_t v6 = (v7 - 1);
              ++v3;
            }
            else
            {
              uint64_t v11 = v9;
              uint64_t v6 = v7;
            }
            if (v3 < 0 && (int)v11 >= 1)
            {
              do
              {
                puint64_t i = v11 - 1;
                int v25 = (char)v10[(v11 - 1)];
                if (v25 < 0 && (UChar32 v26 = utf8_prevCharSafeBody(v10, 0, &pi, v25, -3), v26 >= 0x10000))
                {
                  if (v3 >= -1)
                  {
                    uint64_t v11 = (pi + 4);
                    *(_DWORD *)(a1 + 24) = v26;
                    uint64_t v6 = (v6 - 1);
                    break;
                  }
                  int v27 = 2;
                  int v28 = -2;
                }
                else
                {
                  int v27 = 1;
                  int v28 = -1;
                }
                uint64_t v6 = (v6 + v28);
                uint64_t v11 = pi;
                v3 += v27;
              }
              while (v3 < 0 && pi > 0);
            }
          }
          else
          {
            uint64_t v11 = *(unsigned int *)(a1 + 20);
            uint64_t v6 = v7;
            if (*(_DWORD *)(a1 + 24))
            {
              *(_DWORD *)(a1 + 24) = 0;
              uint64_t v6 = (v7 + 1);
              --v3;
            }
            unsigned int v12 = 0;
            if (v3 && (int)v9 < (int)v11)
            {
              do
              {
                uint64_t v13 = (int)v9;
                int v14 = (char)v10[(int)v9];
                uint64_t v9 = (int)v9 + 1;
                int v15 = -1;
                int v16 = 1;
                if ((v14 & 0x80000000) == 0 || v9 == v11) {
                  goto LABEL_47;
                }
                char v17 = v14;
                if (v14 < 0xE0u)
                {
                  if (v14 < 0xC2u) {
                    goto LABEL_46;
                  }
                  int v20 = v14 & 0x1F;
                }
                else
                {
                  if (v14 > 0xEFu)
                  {
                    if (v14 > 0xF4u)
                    {
LABEL_46:
                      int v15 = -1;
                      goto LABEL_47;
                    }
                    int v22 = v14 - 240;
                    unint64_t v18 = v10[v9];
                    if (((byte_18CA81857[v18 >> 4] >> (v17 + 16)) & 1) == 0) {
                      goto LABEL_45;
                    }
                    uint64_t v9 = v13 + 2;
                    if (v13 + 2 == v11)
                    {
LABEL_44:
                      int v15 = -1;
                      int v16 = 1;
                      uint64_t v9 = v11;
                      goto LABEL_47;
                    }
                    unsigned int v19 = v10[v9] ^ 0x80;
                    if (v19 > 0x3F)
                    {
                      int v15 = -1;
                      int v16 = 1;
                      goto LABEL_47;
                    }
                    LODWORD(v18) = v18 & 0x3F | (v22 << 6);
                  }
                  else
                  {
                    unint64_t v18 = v14 & 0xF;
                    if (((a00000000000000[v18] >> (v10[v9] >> 5)) & 1) == 0) {
                      goto LABEL_45;
                    }
                    unsigned int v19 = v10[v9] & 0x3F;
                  }
                  uint64_t v9 = (v9 + 1);
                  if (v9 == v11) {
                    goto LABEL_44;
                  }
                  int v20 = v19 | (v18 << 6);
                }
                unsigned int v21 = v10[(int)v9] ^ 0x80;
                if (v21 > 0x3F || (unsigned int v12 = v21 | (v20 << 6), v9 = (v9 + 1), v12 < 0x10000))
                {
LABEL_45:
                  int v15 = -1;
                  int v16 = 1;
                  goto LABEL_47;
                }
                if (v3 <= 1)
                {
                  *(_DWORD *)(a1 + 24) = v12;
                  uint64_t v6 = (v6 + 1);
                  break;
                }
                int v15 = -2;
                int v16 = 2;
LABEL_47:
                unsigned int v12 = 0;
                uint64_t v6 = (v6 + v16);
                v3 += v15;
              }
              while (v3 >= 1 && (int)v9 < (int)v11);
            }
            if (v9 == v11)
            {
              int v29 = *(_DWORD *)(a1 + 8);
              if (v29 < 0)
              {
                if ((v7 & 0x80000000) == 0)
                {
                  if (v12) {
                    int v32 = v6 + 1;
                  }
                  else {
                    int v32 = v6;
                  }
                  *(_DWORD *)(a1 + 8) = v32;
                }
              }
              else if ((v7 & 0x80000000) != 0)
              {
                int v30 = v29 - (v12 != 0);
                *(_DWORD *)(a1 + 16) = v30;
LABEL_83:
                *(_DWORD *)(a1 + 12) = v11;
                if ((v30 & 0x80000000) == 0)
                {
                  *(_DWORD *)(a1 + 16) = v6;
                  return v6;
                }
                if ((int)v11 <= 1)
                {
                  *(_DWORD *)(a1 + 16) = v11;
                  return v11;
                }
                return 4294967294;
              }
            }
            else
            {
              uint64_t v11 = v9;
            }
          }
          int v30 = *(_DWORD *)(a1 + 16);
          goto LABEL_83;
        }
LABEL_61:
        uint64_t v6 = 0;
        *(_DWORD *)(a1 + 24) = 0;
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        return v6;
      }
      uint64_t v7 = 0xFFFFFFFFLL;
      uint64_t v9 = *(unsigned int *)(a1 + 20);
      *(_DWORD *)(a1 + 12) = v9;
      *(_DWORD *)(a1 + 16) = -1;
      *(_DWORD *)(a1 + 24) = 0;
      if ((a2 & 0x80000000) == 0) {
        return 4294967294;
      }
LABEL_56:
      if ((int)v9 <= -a2) {
        goto LABEL_61;
      }
      int v23 = *(_DWORD *)(a1 + 20);
      if (v23 - (int)v9 > a2) {
        goto LABEL_22;
      }
      int v24 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 12) = v23;
      *(_DWORD *)(a1 + 16) = v24;
      *(_DWORD *)(a1 + 24) = 0;
      if (v24 < 0) {
        return 4294967294;
      }
      else {
        return v24;
      }
    default:
      return 0xFFFFFFFFLL;
  }
}

BOOL sub_18C880C6C(_DWORD *a1)
{
  return a1[3] < a1[5] || a1[6] != 0;
}

BOOL sub_18C880C94(uint64_t a1)
{
  return *(_DWORD *)(a1 + 12) > 0;
}

uint64_t sub_18C880CA4(uint64_t *a1)
{
  if (*((_DWORD *)a1 + 6)) {
    return a1[3] & 0x3FF | 0xDC00;
  }
  uint64_t v2 = *((int *)a1 + 3);
  int v3 = *((_DWORD *)a1 + 5);
  if ((int)v2 >= v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *a1;
  int v5 = *(char *)(*a1 + v2);
  uint64_t result = *(unsigned __int8 *)(*a1 + v2);
  if (v5 < 0)
  {
    unint64_t v6 = v2 + 1;
    if (v2 + 1 != v3)
    {
      if (result < 0xE0)
      {
        if (result < 0xC2) {
          return 65533;
        }
        unsigned int v9 = result & 0x1F;
      }
      else
      {
        if (result > 0xEF)
        {
          if (result > 0xF4) {
            return 65533;
          }
          unint64_t v6 = *(unsigned __int8 *)(v4 + v6);
          if (((byte_18CA81857[v6 >> 4] >> (result + 16)) & 1) == 0) {
            return 65533;
          }
          uint64_t v11 = v2 + 2;
          if (v2 + 2 == v3) {
            return 65533;
          }
          unsigned int v8 = *(unsigned __int8 *)(v4 + v11) ^ 0x80;
          if (v8 > 0x3F) {
            return 65533;
          }
          LODWORD(v7) = v6 & 0x3F | ((result - 240) << 6);
          LODWORD(v6) = v11;
        }
        else
        {
          uint64_t v7 = v5 & 0xF;
          if (((a00000000000000[v7] >> (*(unsigned char *)(v4 + v6) >> 5)) & 1) == 0) {
            return 65533;
          }
          unsigned int v8 = *(unsigned char *)(v4 + v6) & 0x3F;
        }
        LODWORD(v6) = v6 + 1;
        if (v6 == v3) {
          return 65533;
        }
        unsigned int v9 = v8 | (v7 << 6);
      }
      unsigned int v10 = *(unsigned __int8 *)(v4 + (int)v6) ^ 0x80;
      if (v10 <= 0x3F)
      {
        uint64_t result = v10 | (v9 << 6);
        if (WORD1(result)) {
          return (unsigned __int16)((v9 >> 4) - 10304);
        }
        return result;
      }
    }
    return 65533;
  }
  return result;
}

uint64_t sub_18C880DD0(uint64_t *a1)
{
  if (*((_DWORD *)a1 + 6))
  {
    uint64_t v1 = a1[3] & 0x3FF | 0xDC00;
    *((_DWORD *)a1 + 6) = 0;
    int v2 = *((_DWORD *)a1 + 4);
    if ((v2 & 0x80000000) == 0) {
      *((_DWORD *)a1 + 4) = v2 + 1;
    }
    return v1;
  }
  uint64_t v3 = *((int *)a1 + 3);
  int v4 = *((_DWORD *)a1 + 5);
  if ((int)v3 >= v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *a1;
  uint64_t v6 = v3 + 1;
  *((_DWORD *)a1 + 3) = v3 + 1;
  int v7 = *(char *)(v5 + v3);
  uint64_t v1 = *(unsigned __int8 *)(v5 + v3);
  if (v7 < 0)
  {
    if (v6 == v4)
    {
LABEL_7:
      uint64_t v1 = 65533;
      LODWORD(v6) = v4;
      goto LABEL_25;
    }
    if (v1 < 0xE0)
    {
      if (v1 < 0xC2) {
        goto LABEL_24;
      }
      int v10 = v1 & 0x1F;
    }
    else
    {
      if (v1 > 0xEF)
      {
        if (v1 > 0xF4) {
          goto LABEL_24;
        }
        int v12 = v1 - 240;
        unint64_t v8 = *(unsigned __int8 *)(v5 + v6);
        if (((byte_18CA81857[v8 >> 4] >> v12) & 1) == 0) {
          goto LABEL_24;
        }
        uint64_t v6 = v3 + 2;
        *((_DWORD *)a1 + 3) = v3 + 2;
        if (v3 + 2 == v4) {
          goto LABEL_7;
        }
        unsigned int v9 = *(unsigned __int8 *)(v5 + v6) ^ 0x80;
        if (v9 > 0x3F)
        {
          uint64_t v1 = 65533;
          goto LABEL_25;
        }
        LODWORD(v8) = v8 & 0x3F | (v12 << 6);
      }
      else
      {
        unint64_t v8 = v7 & 0xF;
        if (((a00000000000000[v8] >> (*(unsigned char *)(v5 + v6) >> 5)) & 1) == 0) {
          goto LABEL_24;
        }
        unsigned int v9 = *(unsigned char *)(v5 + v6) & 0x3F;
      }
      LODWORD(v6) = v6 + 1;
      *((_DWORD *)a1 + 3) = v6;
      if (v6 == v4) {
        goto LABEL_7;
      }
      int v10 = v9 | (v8 << 6);
    }
    unsigned int v11 = *(unsigned __int8 *)(v5 + (int)v6) ^ 0x80;
    if (v11 <= 0x3F)
    {
      uint64_t v1 = v11 | (v10 << 6);
      LODWORD(v6) = v6 + 1;
      *((_DWORD *)a1 + 3) = v6;
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v1 = 65533;
  }
LABEL_25:
  int v13 = *((_DWORD *)a1 + 4);
  if (v13 < 0)
  {
    if (v6 == v4)
    {
      int v15 = *((_DWORD *)a1 + 2);
      if ((v15 & 0x80000000) == 0) {
        *((_DWORD *)a1 + 4) = v15 - ((int)v1 >= 0x10000);
      }
    }
  }
  else
  {
    *((_DWORD *)a1 + 4) = v13 + 1;
    if ((a1[1] & 0x80000000) != 0 && v6 == v4)
    {
      int v14 = v13 + 2;
      if ((int)v1 < 0x10000) {
        int v14 = v13 + 1;
      }
      *((_DWORD *)a1 + 2) = v14;
    }
  }
  if ((int)v1 >= 0x10000)
  {
    *((_DWORD *)a1 + 6) = v1;
    return (unsigned __int16)((v1 >> 10) - 10304);
  }
  return v1;
}

uint64_t sub_18C880F88(int32_t *pi)
{
  unsigned int v2 = pi[6];
  if (v2)
  {
    int v3 = (v2 >> 10) + 55232;
    pi[6] = 0;
    int v4 = pi[4];
    pi[3] -= 4;
    if (v4 >= 1) {
      pi[4] = v4 - 1;
    }
    return (unsigned __int16)v3;
  }
  unint64_t v8 = pi + 3;
  int32_t v7 = pi[3];
  BOOL v9 = __OFSUB__(v7, 1);
  int v10 = v7 - 1;
  if (v10 < 0 != v9) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v11 = *(const uint8_t **)pi;
  pi[3] = v10;
  int v12 = (char)v11[v10];
  uint64_t CharSafeBody = v12;
  if (v12 < 0) {
    uint64_t CharSafeBody = utf8_prevCharSafeBody(v11, 0, pi + 3, v12, -3);
  }
  int32_t v13 = pi[4];
  BOOL v9 = __OFSUB__(v13, 1);
  int v14 = v13 - 1;
  if (v14 < 0 != v9)
  {
    int v14 = *v8;
    if (*v8 > 1) {
      goto LABEL_15;
    }
    if ((int)CharSafeBody >= 0x10000) {
      ++v14;
    }
  }
  pi[4] = v14;
LABEL_15:
  if ((int)CharSafeBody >= 0x10000)
  {
    pi[3] += 4;
    pi[6] = CharSafeBody;
    return CharSafeBody & 0x3FF | 0xDC00;
  }
  return CharSafeBody;
}

uint64_t sub_18C881068(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 24) != 0) | (2 * *(_DWORD *)(a1 + 12));
}

uint64_t sub_18C881080(uint64_t result, unsigned int a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    uint64_t v4 = result;
    if (result)
    {
      if (((*(_DWORD *)(result + 24) != 0) | (2 * *(_DWORD *)(result + 12))) == a2) {
        return result;
      }
      if ((a2 & 0xFFFFFFF9) != 1)
      {
        uint64_t v5 = a2 >> 1;
        if (*(_DWORD *)(result + 20) >= (int)v5)
        {
          if (a2 >= 4) {
            int v6 = -1;
          }
          else {
            int v6 = a2 >> 1;
          }
          *(_DWORD *)(result + 12) = v5;
          *(_DWORD *)(result + 16) = v6;
          if ((a2 & 1) == 0)
          {
            *(_DWORD *)(result + 24) = 0;
            return result;
          }
          uint64_t result = *(void *)result;
          uint64_t v8 = v5 - 1;
          puint64_t i = v8;
          int v9 = *(char *)(result + v8);
          if (v9 < 0)
          {
            uint64_t result = utf8_prevCharSafeBody((const uint8_t *)result, 0, &pi, v9, -3);
            if ((int)result >= 0x10000)
            {
              *(_DWORD *)(v4 + 24) = result;
              return result;
            }
          }
        }
      }
      int v7 = 8;
    }
    else
    {
      int v7 = 1;
    }
    *a3 = v7;
  }
  return result;
}

void *ulist_createEmptyList(int *a1)
{
  if (*a1 > 0) {
    return 0;
  }
  uint64_t result = uprv_malloc(0x20uLL);
  if (result)
  {
    *uint64_t result = 0;
    result[1] = 0;
    *((_DWORD *)result + 6) = 0;
    result[2] = 0;
  }
  else
  {
    *a1 = 7;
  }
  return result;
}

void ulist_addItemEndList(uint64_t a1, void *a2, int a3, int *a4)
{
  if (a2 && a1 && *a4 < 1)
  {
    uint64_t v8 = uprv_malloc(0x20uLL);
    if (v8)
    {
      *(void *)uint64_t v8 = a2;
      v8[24] = a3;
      int v9 = *(_DWORD *)(a1 + 24);
      if (v9)
      {
        uint64_t v10 = *(void *)(a1 + 16);
        *((void *)v8 + 1) = 0;
        *((void *)v8 + 2) = v10;
        *(void *)(v10 + 8) = v8;
      }
      else
      {
        *((void *)v8 + 1) = 0;
        *((void *)v8 + 2) = 0;
        *(void *)(a1 + 8) = v8;
      }
      *(void *)(a1 + 16) = v8;
      *(_DWORD *)(a1 + 24) = v9 + 1;
    }
    else
    {
      if (a3) {
        uprv_free(a2);
      }
      *a4 = 7;
    }
  }
  else if (a3)
  {
    uprv_free(a2);
  }
}

void ulist_addItemBeginList(uint64_t a1, void *a2, int a3, int *a4)
{
  if (a2 && a1 && *a4 < 1)
  {
    uint64_t v8 = uprv_malloc(0x20uLL);
    if (v8)
    {
      *(void *)uint64_t v8 = a2;
      v8[24] = a3;
      int v9 = *(_DWORD *)(a1 + 24);
      if (v9)
      {
        uint64_t v10 = (void *)(a1 + 8);
        uint64_t v11 = *(void *)(a1 + 8);
        *((void *)v8 + 1) = v11;
        *((void *)v8 + 2) = 0;
        *(void *)(v11 + 16) = v8;
      }
      else
      {
        *((void *)v8 + 1) = 0;
        *((void *)v8 + 2) = 0;
        uint64_t v10 = (void *)(a1 + 16);
        *(void *)(a1 + 8) = v8;
      }
      *uint64_t v10 = v8;
      *(_DWORD *)(a1 + 24) = v9 + 1;
    }
    else
    {
      if (a3) {
        uprv_free(a2);
      }
      *a4 = 7;
    }
  }
  else if (a3)
  {
    uprv_free(a2);
  }
}

uint64_t ulist_containsString(uint64_t result, const void *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = *(void *)(result + 8);
    if (v3)
    {
      size_t v6 = a3;
      while (strlen(*(const char **)v3) != a3 || memcmp(a2, *(const void **)v3, v6))
      {
        uint64_t v3 = *(void *)(v3 + 8);
        if (!v3) {
          return 0;
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ulist_removeString(uint64_t result, char *__s1)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 8);
    if (v3)
    {
      while (strcmp(__s1, *(const char **)v3))
      {
        uint64_t v3 = *(void *)(v3 + 8);
        if (!v3) {
          return 0;
        }
      }
      uint64_t v5 = *(void *)(v3 + 8);
      uint64_t v6 = *(void *)(v3 + 16);
      if (v6)
      {
        *(void *)(v6 + 8) = v5;
        uint64_t v5 = *(void *)(v3 + 8);
      }
      else
      {
        *(void *)(v2 + 8) = v5;
      }
      if (v5) {
        uint64_t v7 = v5;
      }
      else {
        uint64_t v7 = v2;
      }
      *(void *)(v7 + 16) = v6;
      if (*(void *)v2 == v3) {
        *(void *)uint64_t v2 = v5;
      }
      --*(_DWORD *)(v2 + 24);
      if (*(unsigned char *)(v3 + 24)) {
        uprv_free(*(void **)v3);
      }
      uprv_free((void *)v3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *ulist_getNext(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void **)a1;
  if (*(void *)a1)
  {
    uint64_t v1 = (void *)*v1;
    *(void *)a1 = *(void *)(*(void *)a1 + 8);
  }
  return v1;
}

uint64_t ulist_getListSize(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 24);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void *ulist_resetList(void *result)
{
  if (result) {
    *uint64_t result = result[1];
  }
  return result;
}

void ulist_deleteList(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[1];
    if (v2)
    {
      do
      {
        uint64_t v3 = *(void *)(v2 + 8);
        if (*(unsigned char *)(v2 + 24)) {
          uprv_free(*(void **)v2);
        }
        uprv_free((void *)v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uprv_free(a1);
  }
}

void ulist_close_keyword_values_iterator(void **a1)
{
  if (a1)
  {
    ulist_deleteList(a1[1]);
    uprv_free(a1);
  }
}

uint64_t ulist_count_keyword_values(uint64_t a1, int *a2)
{
  if (*a2 <= 0 && (uint64_t v3 = *(void *)(a1 + 8)) != 0) {
    return *(unsigned int *)(v3 + 24);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

const char *ulist_next_keyword_value(uint64_t a1, _DWORD *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = *v5;
  if (!*v5) {
    return 0;
  }
  uint64_t v3 = *(const char **)v6;
  *uint64_t v5 = *(void *)(v6 + 8);
  if (a2 && v3) {
    *a2 = strlen(v3);
  }
  return v3;
}

uint64_t ulist_reset_keyword_values_iterator(uint64_t result, int *a2)
{
  if (*a2 <= 0)
  {
    uint64_t v2 = *(void **)(result + 8);
    if (v2) {
      *uint64_t v2 = v2[1];
    }
  }
  return result;
}

uint64_t ulist_getListFromEnum(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

char *locale_getKeywordsStart(char *a1)
{
  return strchr(a1, 64);
}

void sub_18C881644(char *a1, int a2, uint64_t a3, int a4, int *a5)
{
  v44[144] = *MEMORY[0x1E4F143B8];
  bzero(__s1, 0x4B0uLL);
  if (a2 != 64) {
    return;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (const char *)v44;
  do
  {
    for (uint64_t i = a1; *i == 32; ++i)
      ++a1;
    if (!*i) {
      break;
    }
    if (v10 == 25) {
      goto LABEL_52;
    }
    unsigned int v41 = v11;
    int32_t v13 = strchr(i, 61);
    int v14 = strchr(i, 59);
    if (!v13 || (int v15 = v14) != 0 && v14 < v13)
    {
LABEL_51:
      int v40 = 3;
      goto LABEL_49;
    }
    uint64_t v16 = v13 - a1;
    if (v13 - a1 > 24)
    {
LABEL_52:
      int v40 = 5;
      goto LABEL_49;
    }
    if (v16 < 1) {
      goto LABEL_51;
    }
    int v42 = a5;
    uint64_t v17 = 0;
    int v18 = 0;
    unsigned int v19 = &__s1[48 * v10];
    do
    {
      int v20 = i[v17];
      if (v20 != 32) {
        v19[v18++] = uprv_asciitolower((char)v20);
      }
      ++v17;
    }
    while (v16 > v17);
    if (!v18) {
      goto LABEL_48;
    }
    uint64_t v21 = 0;
    v19[v18] = 0;
    *(_DWORD *)&__s1[48 * v10 + 28] = v18;
    int v22 = v15 - v13;
    do
    {
      int v23 = v22;
      int v25 = *++v13;
      int v24 = v25;
      --v21;
      --v22;
    }
    while (v25 == 32);
    if (!v24 || v13 == v15)
    {
LABEL_48:
      int v40 = 3;
      a5 = v42;
LABEL_49:
      *a5 = v40;
      return;
    }
    *(void *)&__s1[48 * v10 + 32] = v13;
    if (v15)
    {
      UChar32 v26 = v15 - 1;
      do
      {
        int v27 = *v26--;
        --v23;
      }
      while (v27 == 32);
      *(_DWORD *)&__s1[48 * v10 + 40] = v23;
      a1 = v15 + 1;
      uint64_t v11 = v41;
      if (v10) {
        goto LABEL_26;
      }
    }
    else
    {
      int v33 = strlen(v13);
      uint64_t v34 = v33;
      int v35 = v33 + 1;
      uint64_t v11 = v41;
      while (v34)
      {
        int v36 = &v13[v34--];
        --v35;
        if (*(v36 - 1) != 32) {
          goto LABEL_37;
        }
      }
      int v35 = 0;
LABEL_37:
      a1 = 0;
      *(_DWORD *)&__s1[48 * v10 + 40] = v35;
      if (v10)
      {
LABEL_26:
        if (!strcmp(__s1, &__s1[48 * v10]))
        {
          BOOL v32 = 0;
        }
        else
        {
          int v28 = v11;
          uint64_t v29 = 1;
          do
          {
            unint64_t v30 = v29;
            if (v10 == v29) {
              break;
            }
            int v31 = strcmp(v28, &__s1[48 * v10]);
            uint64_t v29 = v30 + 1;
            v28 += 48;
          }
          while (v31);
          BOOL v32 = v30 >= v10;
        }
        goto LABEL_39;
      }
    }
    BOOL v32 = 1;
LABEL_39:
    uint64_t v10 = (v10 + v32);
    a5 = v42;
  }
  while (a1);
  uprv_sortArray((uint64_t)__s1, v10, 48, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_18C881A20, 0, 0, a5);
  if ((int)v10 >= 1)
  {
    unint64_t v37 = 0;
    unint64_t v38 = __s1;
    do
    {
      (*(void (**)(uint64_t, char *, void))(*(void *)a3 + 16))(a3, v38, *((unsigned int *)v38 + 7));
      unsigned int v39 = *(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16);
      if (a4)
      {
        v39(a3, "=", 1);
        (*(void (**)(uint64_t, void, void))(*(void *)a3 + 16))(a3, *((void *)v38 + 4), *((unsigned int *)v38 + 10));
        if (v37 < (v10 - 1)) {
          (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, ";", 1);
        }
      }
      else
      {
        v39(a3, byte_18CA81868, 1);
      }
      ++v37;
      v38 += 48;
    }
    while (v10 != v37);
  }
}

uint64_t sub_18C881A20(int a1, char *__s1, char *__s2)
{
  return strcmp(__s1, __s2);
}

uint64_t uloc_getKeywordValue(char *a1, char *a2, char *a3, int a4, int *a5)
{
  if (*a5 > 0) {
    return 0;
  }
  long long v12 = 0u;
  long long v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a3, a4);
  ulocimp_getKeywordValue(a1, a2, (uint64_t)&v12, a5);
  uint64_t v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13)) {
      *a5 = 15;
    }
    else {
      u_terminateChars((uint64_t)a3, a4, DWORD2(v13), a5);
    }
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

void ulocimp_getKeywordValue(char *a1, char *a2, uint64_t a3, int *a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v4 = a1;
    if (a1)
    {
      if (*a4 <= 0)
      {
        memset(&v28[1], 0, 48);
        uint64_t v29 = 0;
        v28[0] = (char *)&v28[1] + 5;
        LODWORD(v28[1]) = 40;
        if (a2 && *a2)
        {
          *(void *)__s1 = 0;
          uint64_t v35 = 0;
          char v37 = 0;
          uint64_t v36 = 0;
          sub_18C881E00((uint64_t)__s1, a2, a4);
          if (*a4 <= 0)
          {
            if (!strchr(v4, 64) && sub_18C881EB0(v4) == 1)
            {
              *(void *)__s2 = 0;
              uint64_t v31 = 0;
              icu::CharStringByteSink::CharStringByteSink(__s2, (uint64_t)v28);
              ulocimp_forLanguageTag(v4, -1, (uint64_t)__s2, 0, a4);
              if (v29) {
                BOOL v7 = *a4 <= 0;
              }
              else {
                BOOL v7 = 0;
              }
              if (v7) {
                uint64_t v4 = (char *)v28[0];
              }
              icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__s2);
            }
            uint64_t v8 = strchr(v4, 64);
            if (v8)
            {
              int v9 = v8;
              *(void *)__s2 = 0;
              uint64_t v31 = 0;
              char v33 = 0;
              uint64_t v32 = 0;
              while (v9)
              {
                uint64_t v10 = strchr(v9 + 1, 61);
                if (!v10) {
                  goto LABEL_50;
                }
                uint64_t v11 = v10;
                do
                  int v12 = *++v9;
                while (v12 == 32);
                long long v13 = v10;
                while (v13 > v9)
                {
                  int v14 = *--v13;
                  if (v14 != 32)
                  {
                    uint64_t v15 = 0;
                    uint64_t v16 = v13 + 1;
                    while (uprv_isASCIILetter(v9[v15]) || v9[v15] - 48 <= 9)
                    {
                      if (v15 == 24)
                      {
                        int v27 = 5;
                        goto LABEL_51;
                      }
                      char v17 = uprv_asciitolower(v9[v15]);
                      int v18 = v15 + 1;
                      __s2[v15] = v17;
                      unsigned int v19 = &v9[++v15];
                      if (v19 >= v16) {
                        goto LABEL_33;
                      }
                    }
                    goto LABEL_50;
                  }
                }
                if (v13 == v9) {
                  goto LABEL_50;
                }
                int v18 = 0;
LABEL_33:
                __s2[v18] = 0;
                int v9 = strchr(v11, 59);
                if (!strcmp(__s1, __s2))
                {
                  do
                    int v20 = *++v11;
                  while (v20 == 32);
                  if (!v9) {
                    int v9 = &v11[strlen(v11)];
                  }
                  while (v9 > v11)
                  {
                    int v21 = *--v9;
                    if (v21 != 32)
                    {
                      int v22 = v9 + 1;
                      while (1)
                      {
                        if (!uprv_isASCIILetter(*v11))
                        {
                          int v23 = *v11;
                          if ((v23 - 48) >= 0xA)
                          {
                            unsigned int v24 = v23 - 43;
                            BOOL v7 = v24 > 0x34;
                            uint64_t v25 = (1 << v24) & 0x10000000000015;
                            if (v7 || v25 == 0) {
                              goto LABEL_50;
                            }
                          }
                        }
                        (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16))(a3, v11++, 1);
                        if (v11 >= v22) {
                          goto LABEL_52;
                        }
                      }
                    }
                  }
                  if (v11 != v9) {
                    break;
                  }
                  goto LABEL_50;
                }
              }
            }
          }
        }
        else
        {
LABEL_50:
          int v27 = 1;
LABEL_51:
          *a4 = v27;
        }
LABEL_52:
        if (BYTE4(v28[1])) {
          uprv_free(v28[0]);
        }
      }
    }
  }
}

uint64_t sub_18C881E00(uint64_t a1, char *a2, int *a3)
{
  char v4 = *a2;
  if (*a2)
  {
    uint64_t v7 = 0;
    while (uprv_isASCIILetter(v4) || a2[v7] - 48 < 0xA)
    {
      if (v7 == 24)
      {
        uint64_t result = 0;
        int v10 = 5;
        goto LABEL_11;
      }
      char v8 = uprv_asciitolower(a2[v7]);
      uint64_t result = v7 + 1;
      *(unsigned char *)(a1 + v7) = v8;
      char v4 = a2[++v7];
      if (!v4)
      {
        if (!result) {
          break;
        }
        *(unsigned char *)(a1 + result) = 0;
        return result;
      }
    }
  }
  uint64_t result = 0;
  int v10 = 1;
LABEL_11:
  *a3 = v10;
  return result;
}

size_t sub_18C881EB0(const char *a1)
{
  uint64_t v1 = a1;
  size_t result = strlen(a1);
  if ((int)result >= 1)
  {
    int v3 = 0;
    uint64_t v4 = result;
    int v5 = 1;
    do
    {
      int v7 = *(unsigned __int8 *)v1++;
      int v6 = v7;
      if (v7 == 45 || v6 == 95)
      {
        BOOL v8 = v3 >= (int)result || v3 == 0;
        if (v8) {
          size_t result = result;
        }
        else {
          size_t result = v3;
        }
        int v5 = 1;
      }
      else
      {
        BOOL v8 = v5 == 0;
        int v5 = 0;
        if (v8) {
          ++v3;
        }
        else {
          int v3 = 1;
        }
      }
      --v4;
    }
    while (v4);
  }
  return result;
}

size_t uloc_setKeywordValue(char *a1, unsigned char *a2, char *__s, int a4, int *a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  *(void *)__s1 = 0;
  uint64_t v68 = 0;
  char v70 = 0;
  uint64_t v69 = 0;
  char v66 = 0;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  *(_OWORD *)__src = 0u;
  long long v61 = 0u;
  *(void *)__s2 = 0;
  uint64_t v57 = 0;
  char v59 = 0;
  uint64_t v58 = 0;
  memset(&v54[1], 0, 48);
  uint64_t v55 = 0;
  v54[0] = (char *)&v54[1] + 5;
  LODWORD(v54[1]) = 40;
  if (*a5 > 0)
  {
    size_t v5 = 0xFFFFFFFFLL;
    goto LABEL_11;
  }
  if (*a5 == -124) {
    *a5 = 0;
  }
  if (!a1) {
    goto LABEL_9;
  }
  if (a4 < 2) {
    goto LABEL_9;
  }
  if (!*a1) {
    goto LABEL_9;
  }
  size_t v5 = strlen(__s);
  if ((int)v5 > a4) {
    goto LABEL_9;
  }
  int v13 = sub_18C881E00((uint64_t)__s1, a1, a5);
  if (*a5 > 0)
  {
    size_t v5 = 0;
    goto LABEL_11;
  }
  int v14 = v13;
  if (!a2 || (LOBYTE(v15) = *a2) == 0)
  {
    int v22 = 0;
    goto LABEL_29;
  }
  int v50 = v13;
  uint64_t v16 = 0;
  do
  {
    if (!uprv_isASCIILetter(v15))
    {
      int v17 = a2[v16];
      if ((v17 - 48) >= 0xA)
      {
        unsigned int v18 = v17 - 43;
        BOOL v19 = v18 > 0x34;
        uint64_t v20 = (1 << v18) & 0x10000000000015;
        if (v19 || v20 == 0) {
          goto LABEL_9;
        }
      }
    }
    if (v16 == 96)
    {
LABEL_77:
      size_t v5 = 0;
      int v11 = 5;
      goto LABEL_10;
    }
    int v22 = v16 + 1;
    __src[v16] = a2[v16];
    int v15 = a2[++v16];
  }
  while (v15);
  int v14 = v50;
LABEL_29:
  __src[v22] = 0;
  int v23 = strchr(__s, 64);
  if (!v23 || !v23[1])
  {
    if (v22)
    {
      int v44 = v5 + v14 + v22;
      if (!v23) {
        ++v44;
      }
      size_t v45 = (v44 + 1);
      if ((int)v45 >= a4)
      {
        *a5 = 15;
      }
      else
      {
        if (!v23) {
          int v23 = &__s[(int)v5];
        }
        *int v23 = 64;
        long long v46 = &strcpy(v23 + 1, __s1)[v14];
        char *v46 = 61;
        strcpy(v46 + 1, __src);
      }
      size_t v5 = v45;
    }
    goto LABEL_11;
  }
  int v52 = 0;
  char v53 = 64;
  __int16 __dst = v23;
  unsigned int v24 = v23;
  int v51 = v14;
  while (2)
  {
    uint64_t v25 = strchr(v24 + 1, 61);
    UChar32 v26 = v25;
    if (!v25) {
      goto LABEL_9;
    }
    do
      int v27 = *++v24;
    while (v27 == 32);
    int v28 = v25;
    while (v28 > v24)
    {
      int v29 = *--v28;
      if (v29 != 32)
      {
        uint64_t v30 = 0;
        uint64_t v31 = v28 + 1;
        while (uprv_isASCIILetter(v24[v30]) || v24[v30] - 48 < 0xA)
        {
          if (v30 == 24) {
            goto LABEL_77;
          }
          int v32 = v30 + 1;
          __s2[v30] = uprv_asciitolower(v24[v30]);
          char v33 = &v24[++v30];
          if (v33 >= v31)
          {
            int v14 = v51;
            goto LABEL_45;
          }
        }
        goto LABEL_9;
      }
    }
    if (v28 == v24) {
      goto LABEL_9;
    }
    int v32 = 0;
LABEL_45:
    __s2[v32] = 0;
    uint64_t v34 = strchr(v26, 59);
    unsigned int v24 = v34;
    int v35 = ~v26;
    do
    {
      int v36 = v35;
      int v37 = *++v26;
      --v35;
    }
    while (v37 == 32);
    uint64_t v38 = v34;
    if (!v34) {
      uint64_t v38 = &v26[strlen(v26)];
    }
    int v39 = v38 + v36;
    do
    {
      int v40 = v38;
      int v41 = v39;
      if (v38 <= v26) {
        break;
      }
      --v38;
      --v39;
    }
    while (*(v40 - 1) == 32);
    if (v40 == v26)
    {
LABEL_9:
      size_t v5 = 0;
      int v11 = 1;
LABEL_10:
      *a5 = v11;
      goto LABEL_11;
    }
    int v42 = strcmp(__s1, __s2);
    if (v42)
    {
      if (v22 && v42 < 0 && !v52)
      {
        icu::CharString::append((icu::CharString *)v54, v53, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __s1, v14, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __src, v22, (UErrorCode *)a5);
        char v43 = 59;
        int v52 = 1;
      }
      else
      {
        char v43 = v53;
      }
      icu::CharString::append((icu::CharString *)v54, v43, (UErrorCode *)a5);
      icu::CharString::append((icu::CharString *)v54, __s2, v32, (UErrorCode *)a5);
      icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
      icu::CharString::append((icu::CharString *)v54, v26, v41, (UErrorCode *)a5);
      if (v22)
      {
        char v53 = 59;
        if (!v24 && !v52)
        {
          icu::CharString::append((icu::CharString *)v54, 59, (UErrorCode *)a5);
          icu::CharString::append((icu::CharString *)v54, __s1, v14, (UErrorCode *)a5);
          icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
          icu::CharString::append((icu::CharString *)v54, __src, v22, (UErrorCode *)a5);
LABEL_80:
          if (*a5 <= 0)
          {
            int v47 = v55;
            int v48 = a4 - (__dst - __s);
            if ((int)v55 >= v48) {
              *a5 = 15;
            }
            else {
              int v47 = icu::CharString::extract(v54, __dst, v48, (UErrorCode *)a5);
            }
            size_t v5 = (v47 + __dst - __s);
          }
          goto LABEL_11;
        }
      }
      else
      {
        char v53 = 59;
      }
    }
    else
    {
      if (v22)
      {
        icu::CharString::append((icu::CharString *)v54, v53, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __s1, v14, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, 61, (UErrorCode *)a5);
        icu::CharString::append((icu::CharString *)v54, __src, v22, (UErrorCode *)a5);
        char v53 = 59;
      }
      int v52 = 1;
    }
    if (v24) {
      continue;
    }
    break;
  }
  if (v52) {
    goto LABEL_80;
  }
LABEL_11:
  if (BYTE4(v54[1])) {
    uprv_free(v54[0]);
  }
  return v5;
}

char *sub_18C8824B0(char *__s1)
{
  uint64_t v1 = __s1;
  int v2 = sub_18C8824F8((const char **)off_1E55049F0, __s1);
  if ((v2 & 0x80000000) == 0) {
    return off_1E5504A80[(unsigned __int16)v2];
  }
  return v1;
}

uint64_t sub_18C8824F8(const char **a1, char *__s1)
{
  int v3 = a1;
  uint64_t v4 = -(uint64_t)a1;
  int v5 = 1;
  while (1)
  {
    int v6 = *v3;
    if (*v3) {
      break;
    }
LABEL_6:
    ++v3;
    if (++v5 == 3)
    {
      LOWORD(v9) = -1;
      return (__int16)v9;
    }
  }
  unint64_t v7 = (unint64_t)v3 + v4;
  while (strcmp(__s1, v6))
  {
    BOOL v8 = v3[1];
    ++v3;
    int v6 = v8;
    v7 += 8;
    if (!v8) {
      goto LABEL_6;
    }
  }
  unint64_t v9 = v7 >> 3;
  return (__int16)v9;
}

char *sub_18C882578(char *__s1)
{
  uint64_t v1 = __s1;
  int v2 = sub_18C8824F8((const char **)off_1E5504B10, __s1);
  if ((v2 & 0x80000000) == 0) {
    return off_1E5504B48[(unsigned __int16)v2];
  }
  return v1;
}

uint64_t sub_18C8825C0@<X0>(uint64_t result@<X0>, void *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  int v6 = (unsigned __int8 *)result;
  *(_OWORD *)(a4 + 8) = 0u;
  *(void *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(void *)a4 = a4 + 13;
  *(_DWORD *)(a4 + 8) = 40;
  *(_DWORD *)(a4 + 56) = 0;
  int v8 = *(unsigned __int8 *)result;
  if ((v8 - 73) <= 0x2F && ((1 << (v8 - 73)) & 0x800100008001) != 0)
  {
    int v10 = *(unsigned __int8 *)(result + 1);
    if (v10 == 95 || v10 == 45)
    {
      char v11 = uprv_asciitolower((char)v8);
      icu::CharString::append((icu::CharString *)a4, v11, a3);
      size_t result = (uint64_t)icu::CharString::append((icu::CharString *)a4, 45, a3);
      v6 += 2;
    }
  }
  while (1)
  {
    int v12 = *v6;
    BOOL v13 = (v12 - 45) > 0x32 || ((1 << (v12 - 45)) & 0x4000000080003) == 0;
    if (!v13 || v12 == 0) {
      break;
    }
    char v15 = uprv_asciitolower((char)v12);
    size_t result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v15, a3);
    ++v6;
  }
  if (*(_DWORD *)(a4 + 56) == 3)
  {
    uint64_t v16 = *(unsigned char **)a4;
    size_t result = sub_18C8824F8((const char **)off_1E5504B80, *(char **)a4);
    if ((result & 0x80000000) == 0)
    {
      *(_DWORD *)(a4 + 56) = 0;
      *uint64_t v16 = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v17, off_1E5505F08[(unsigned __int16)result]);
      size_t result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v17, v18, a3);
    }
  }
  if (a2) {
    *a2 = v6;
  }
  return result;
}

icu::CharString *sub_18C882744@<X0>(icu::CharString *result@<X0>, void *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  int v6 = (char *)result;
  *(_OWORD *)(a4 + 8) = 0u;
  *(void *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(void *)a4 = a4 + 13;
  *(_DWORD *)(a4 + 8) = 40;
  *(_DWORD *)(a4 + 56) = 0;
  if (a2) {
    *a2 = result;
  }
  for (uint64_t i = 0; ; ++i)
  {
    int v9 = v6[i];
    BOOL v10 = (v9 - 45) > 0x32 || ((1 << (v9 - 45)) & 0x4000000080003) == 0;
    if (!v10 || v9 == 0) {
      break;
    }
    size_t result = (icu::CharString *)uprv_isASCIILetter(v9);
    if (!result) {
      break;
    }
  }
  if (i == 4)
  {
    if (a2) {
      *a2 = &v6[i];
    }
    char v12 = uprv_toupper(*v6);
    icu::CharString::append((icu::CharString *)a4, v12, a3);
    uint64_t v13 = 1;
    do
    {
      char v14 = uprv_asciitolower(v6[v13]);
      size_t result = icu::CharString::append((icu::CharString *)a4, v14, a3);
      ++v13;
    }
    while (v13 != 4);
  }
  return result;
}

uint64_t sub_18C882854@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, UErrorCode *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = result;
  uint64_t v8 = 0;
  *(_OWORD *)(a4 + 8) = 0u;
  *(void *)(a4 + 56) = 0;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(void *)a4 = a4 + 13;
  *(_DWORD *)(a4 + 8) = 40;
  *(_DWORD *)(a4 + 56) = 0;
  while (1)
  {
    int v9 = *(unsigned __int8 *)(v6 + v8);
    BOOL v10 = (v9 - 45) > 0x32 || ((1 << (v9 - 45)) & 0x4000000080003) == 0;
    if (!v10 || v9 == 0) {
      break;
    }
    char v12 = uprv_toupper((char)v9);
    size_t result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v12, a3);
    ++v8;
  }
  if ((v8 & 0x7FFFFFFE) == 2)
  {
    v6 += v8;
    if (v8 == 3)
    {
      uint64_t v13 = *(unsigned char **)a4;
      size_t result = sub_18C8824F8((const char **)off_1E5507290, *(char **)a4);
      if ((result & 0x80000000) == 0)
      {
        *(_DWORD *)(a4 + 56) = 0;
        *uint64_t v13 = 0;
        icu::StringPiece::StringPiece((icu::StringPiece *)&v14, off_1E5507AF8[(unsigned __int16)result]);
        size_t result = (uint64_t)icu::CharString::append((icu::CharString *)a4, v14, v15, a3);
      }
    }
  }
  else
  {
    *(_DWORD *)(a4 + 56) = 0;
    **(unsigned char **)a4 = 0;
  }
  if (a2) {
    *a2 = v6;
  }
  return result;
}

_OWORD *uloc_openKeywordList(const void *a1, int a2, int *a3)
{
  if (*a3 > 0)
  {
    int v3 = 0;
    uint64_t v4 = 0;
LABEL_8:
    uint64_t v8 = 0;
    goto LABEL_9;
  }
  int v3 = uprv_malloc(0x10uLL);
  uprv_free(0);
  uint64_t v8 = uprv_malloc(0x38uLL);
  uprv_free(0);
  if (!v3
    || !v8
    || (long long v9 = *(_OWORD *)&off_1EDA472E0,
        *uint64_t v8 = xmmword_1EDA472D0,
        v8[1] = v9,
        void v8[2] = xmmword_1EDA472F0,
        *((void *)v8 + 6) = off_1EDA47300,
        BOOL v10 = uprv_malloc(a2 + 1),
        (*int v3 = v10) == 0))
  {
    *a3 = 7;
    uint64_t v4 = v8;
    goto LABEL_8;
  }
  char v11 = v10;
  memcpy(v10, a1, a2);
  uint64_t v4 = 0;
  v11[a2] = 0;
  v3[1] = v11;
  *((void *)v8 + 1) = v3;
  int v3 = 0;
LABEL_9:
  uprv_free(v4);
  uprv_free(v3);
  return v8;
}

_OWORD *uloc_openKeywords(char *__s, int *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  memset(&v20[1], 0, 48);
  uint64_t v21 = 0;
  v20[0] = (char *)&v20[1] + 5;
  LODWORD(v20[1]) = 40;
  if (!a2 || *a2 > 0) {
    goto LABEL_18;
  }
  Default_0 = __s;
  if (__s)
  {
    if (!strchr(__s, 64) && sub_18C881EB0(Default_0) == 1)
    {
      v12[0] = 0;
      v12[1] = 0;
      icu::CharStringByteSink::CharStringByteSink(v12, (uint64_t)v20);
      ulocimp_forLanguageTag(Default_0, -1, (uint64_t)v12, 0, a2);
      if (v21) {
        BOOL v4 = *a2 <= 0;
      }
      else {
        BOOL v4 = 0;
      }
      if (v4) {
        Default_0 = (char *)v20[0];
      }
      __sa = Default_0;
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v12);
      goto LABEL_15;
    }
  }
  else
  {
    Default_0 = (char *)uloc_getDefault_0();
  }
  __sa = Default_0;
LABEL_15:
  sub_18C8825C0((uint64_t)Default_0, &__sa, (UErrorCode *)a2, (uint64_t)&v18);
  if (v19) {
    uprv_free(v18);
  }
  if (*a2 > 0) {
    goto LABEL_18;
  }
  unint64_t v7 = __sa;
  int v8 = *__sa;
  if (v8 == 95 || v8 == 45)
  {
    v12[0] = 0;
    sub_18C882744((icu::CharString *)(__sa + 1), v12, (UErrorCode *)a2, (uint64_t)&v16);
    if (v17) {
      uprv_free(v16);
    }
    if (*a2 > 0) {
      goto LABEL_18;
    }
    unint64_t v7 = __sa;
    if (v12[0] != __sa + 1)
    {
      __sa = (char *)v12[0];
      unint64_t v7 = (char *)v12[0];
    }
    int v9 = *v7;
    if (v9 == 95 || v9 == 45)
    {
      sub_18C882854((uint64_t)(v7 + 1), (uint64_t *)&__sa, (UErrorCode *)a2, (uint64_t)&v14);
      if (v15) {
        uprv_free(v14);
      }
      if (*a2 > 0) {
        goto LABEL_18;
      }
      unint64_t v7 = __sa;
    }
  }
  __sa = strchr(v7, 64);
  if (!__sa)
  {
LABEL_18:
    int v5 = 0;
    goto LABEL_19;
  }
  memset(&v12[1], 0, 48);
  uint64_t v13 = 0;
  v12[0] = (char *)&v12[1] + 5;
  LODWORD(v12[1]) = 40;
  v10[0] = 0;
  v10[1] = 0;
  icu::CharStringByteSink::CharStringByteSink(v10, (uint64_t)v12);
  sub_18C881644(__sa + 1, 64, (uint64_t)v10, 0, a2);
  int v5 = 0;
  if (*a2 <= 0) {
    int v5 = uloc_openKeywordList(v12[0], v13, a2);
  }
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v10);
  if (BYTE4(v12[1])) {
    uprv_free(v12[0]);
  }
LABEL_19:
  if (BYTE4(v20[1])) {
    uprv_free(v20[0]);
  }
  return v5;
}

uint64_t uloc_getParent(char *a1, char *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  ulocimp_getParent(a1, (uint64_t)&v10, a4);
  uint64_t v4 = DWORD2(v11);
  if (*a4 <= 0)
  {
    if (BYTE12(v11)) {
      *a4 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), a4);
    }
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

char *ulocimp_getParent(char *__s, uint64_t a2, int *a3)
{
  if (*a3 <= 0)
  {
    Default_0 = __s;
    if (!__s) {
      Default_0 = (char *)uloc_getDefault_0(0);
    }
    __s = strrchr(Default_0, 95);
    if (__s) {
      int v5 = __s - Default_0;
    }
    else {
      int v5 = 0;
    }
    if (v5 >= 1)
    {
      uint64_t v6 = *(uint64_t (**)(uint64_t, char *))(*(void *)a2 + 16);
      return (char *)v6(a2, Default_0);
    }
  }
  return __s;
}

UErrorCode *uloc_getLanguage(uint64_t Default_0, char *a2, int a3, int *a4)
{
  uint64_t v4 = (UErrorCode *)a4;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    if (*a4 <= 0)
    {
      if (!Default_0) {
        Default_0 = uloc_getDefault_0();
      }
      sub_18C8825C0(Default_0, 0, v4, (uint64_t)&v8);
      uint64_t v4 = (UErrorCode *)icu::CharString::extract(&v8, a2, a3, v4);
      if (v9) {
        uprv_free(v8);
      }
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t uloc_getScript(uint64_t Default_0, char *a2, int a3, int *a4)
{
  uint64_t v4 = (UErrorCode *)a4;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  char v9 = (unsigned __int8 *)Default_0;
  if (a4)
  {
    if (*a4 > 0) {
      return 0;
    }
    if (!Default_0)
    {
      Default_0 = uloc_getDefault_0();
      char v9 = (unsigned __int8 *)Default_0;
    }
    sub_18C8825C0(Default_0, &v9, v4, (uint64_t)&v12);
    if (v13) {
      uprv_free(v12);
    }
    if (*(int *)v4 <= 0)
    {
      int v8 = *v9;
      if (v8 == 95 || v8 == 45)
      {
        sub_18C882744((icu::CharString *)(v9 + 1), 0, v4, (uint64_t)&v10);
        uint64_t v4 = (UErrorCode *)icu::CharString::extract(&v10, a2, a3, v4);
        if (v11) {
          uprv_free(v10);
        }
      }
      else
      {
        return u_terminateChars((uint64_t)a2, a3, 0, (int *)v4);
      }
    }
    else
    {
      return 0;
    }
  }
  return (uint64_t)v4;
}

uint64_t uloc_getCountry(uint64_t Default_0, char *a2, int a3, int *a4)
{
  uint64_t v4 = (UErrorCode *)a4;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  char v12 = (unsigned __int8 *)Default_0;
  if (a4)
  {
    if (*a4 > 0) {
      return 0;
    }
    if (!Default_0)
    {
      Default_0 = uloc_getDefault_0();
      char v12 = (unsigned __int8 *)Default_0;
    }
    sub_18C8825C0(Default_0, &v12, v4, (uint64_t)&v17);
    if (v18) {
      uprv_free(v17);
    }
    if (*(int *)v4 > 0) {
      return 0;
    }
    int v8 = *v12;
    if (v8 != 95 && v8 != 45) {
      return u_terminateChars((uint64_t)a2, a3, 0, (int *)v4);
    }
    char v11 = 0;
    sub_18C882744((icu::CharString *)(v12 + 1), &v11, v4, (uint64_t)&v15);
    if (v16) {
      uprv_free(v15);
    }
    if (*(int *)v4 > 0) {
      return 0;
    }
    char v9 = v12;
    if (v11 != v12 + 1)
    {
      char v12 = v11;
      char v9 = v11;
    }
    int v10 = *v9;
    if (v10 != 95 && v10 != 45) {
      return u_terminateChars((uint64_t)a2, a3, 0, (int *)v4);
    }
    sub_18C882854((uint64_t)(v9 + 1), 0, v4, (uint64_t)&v13);
    uint64_t v4 = (UErrorCode *)icu::CharString::extract(&v13, a2, a3, v4);
    if (v14) {
      uprv_free(v13);
    }
  }
  return (uint64_t)v4;
}

uint64_t uloc_getVariant(char *__s, char *a2, int a3, int *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  memset(&v31[1], 0, 48);
  uint64_t v32 = 0;
  v31[0] = (char *)&v31[1] + 5;
  LODWORD(v31[1]) = 40;
  unsigned int v24 = 0;
  if (!a4 || *a4 > 0) {
    goto LABEL_17;
  }
  Default_0 = __s;
  if (__s)
  {
    if (!strchr(__s, 64) && sub_18C881EB0(Default_0) == 1)
    {
      long long v20 = 0uLL;
      icu::CharStringByteSink::CharStringByteSink(&v20, (uint64_t)v31);
      ulocimp_forLanguageTag(Default_0, -1, (uint64_t)&v20, 0, a4);
      if (v32) {
        BOOL v8 = *a4 <= 0;
      }
      else {
        BOOL v8 = 0;
      }
      char v9 = (char *)v31[0];
      if (!v8) {
        char v9 = Default_0;
      }
      unsigned int v24 = v9;
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&v20);
      Default_0 = v24;
      goto LABEL_14;
    }
  }
  else
  {
    Default_0 = (char *)uloc_getDefault_0();
  }
  unsigned int v24 = Default_0;
LABEL_14:
  sub_18C8825C0((uint64_t)Default_0, &v24, (UErrorCode *)a4, (uint64_t)&v29);
  if (v30) {
    uprv_free(v29);
  }
  if (*a4 > 0) {
    goto LABEL_17;
  }
  int v12 = *v24;
  if (v12 != 95 && v12 != 45) {
    goto LABEL_45;
  }
  int v23 = 0;
  sub_18C882744((icu::CharString *)(v24 + 1), &v23, (UErrorCode *)a4, (uint64_t)&v27);
  if (v28) {
    uprv_free(v27);
  }
  if (*a4 > 0) {
    goto LABEL_17;
  }
  char v13 = (unsigned __int8 *)v24;
  if (v23 != (unsigned __int8 *)(v24 + 1))
  {
    unsigned int v24 = (char *)v23;
    char v13 = v23;
  }
  int v14 = *v13;
  if (v14 != 95 && v14 != 45) {
    goto LABEL_45;
  }
  uint64_t v22 = 0;
  sub_18C882854((uint64_t)(v13 + 1), (uint64_t *)&v22, (UErrorCode *)a4, (uint64_t)&v25);
  if (v26) {
    uprv_free(v25);
  }
  if (*a4 > 0)
  {
LABEL_17:
    uint64_t v10 = 0;
    goto LABEL_18;
  }
  char v15 = (unsigned __int8 *)v24;
  if (v22 != (unsigned __int8 *)(v24 + 1))
  {
    unsigned int v24 = (char *)v22;
    char v15 = v22;
  }
  int v16 = *v15;
  if (v16 != 95 && v16 != 45)
  {
LABEL_45:
    uint64_t v10 = 0;
    goto LABEL_46;
  }
  if (v15 != v22)
  {
    int v19 = v15[1];
    char v17 = v15 + 1;
    int v18 = v19;
    if (v19 == 95 || v18 == 45) {
      unsigned int v24 = (char *)v17;
    }
  }
  long long v20 = 0u;
  long long v21 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v20, a2, a3);
  sub_18C883514(v24 + 1, *v24, (uint64_t)&v20, 0);
  uint64_t v10 = DWORD2(v21);
  if (*a4 > 0) {
    goto LABEL_44;
  }
  if (BYTE12(v21))
  {
    *a4 = 15;
LABEL_44:
    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v20);
    goto LABEL_18;
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v20);
LABEL_46:
  uint64_t v10 = u_terminateChars((uint64_t)a2, a3, v10, a4);
LABEL_18:
  if (BYTE4(v31[1])) {
    uprv_free(v31[0]);
  }
  return v10;
}

char *sub_18C883514(char *__s, int a2, uint64_t a3, unsigned __int8 a4)
{
  uint64_t v6 = __s;
  int v7 = a4;
  if (a2 != 95 && a2 != 45) {
    goto LABEL_14;
  }
  for (char i = 1; ; char i = 0)
  {
    int v9 = *v6;
    if (!*v6 || v9 == 46 || v9 == 64) {
      break;
    }
    if (v7)
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "_", 1);
      LOBYTE(v9) = *v6;
    }
    char v17 = 0;
    int v10 = uprv_toupper((char)v9);
    if (v10 == 45) {
      char v11 = 95;
    }
    else {
      char v11 = v10;
    }
    char v17 = v11;
    __s = (char *)(*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16))(a3, &v17, 1);
    int v7 = 0;
    ++v6;
  }
  if (i)
  {
LABEL_14:
    if (a2 != 64)
    {
      __s = strchr(v6, 64);
      if (!__s) {
        return __s;
      }
      uint64_t v6 = __s + 1;
    }
    while (1)
    {
      int v12 = *v6;
      if (!*v6 || v12 == 46 || v12 == 64) {
        break;
      }
      if (v7) {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "_", 1);
      }
      char v16 = 0;
      int v13 = *v6++;
      int v14 = uprv_toupper(v13);
      if ((v14 & 0xFFFFFFFE) == 0x2C) {
        char v15 = 95;
      }
      else {
        char v15 = v14;
      }
      char v16 = v15;
      __s = (char *)(*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16))(a3, &v16, 1);
      int v7 = 0;
    }
  }
  return __s;
}

uint64_t uloc_getName(char *a1, char *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18C8837B0(a1);
  uint64_t v4 = DWORD2(v11);
  if (*a4 <= 0)
  {
    if (BYTE12(v11)) {
      *a4 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), a4);
    }
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

uint64_t ulocimp_getName(char *a1)
{
  return sub_18C8837B0(a1);
}

void sub_18C8837B0(char *__s, uint64_t a2, char a3, UErrorCode *a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (*(int *)a4 > 0) {
    return;
  }
  Default_0 = __s;
  uint64_t v57 = 0;
  memset(&v56[1], 0, 48);
  v56[0] = (char *)&v56[1] + 5;
  LODWORD(v56[1]) = 40;
  memset(&v55[1], 0, 56);
  v55[0] = (char *)&v55[1] + 5;
  LODWORD(v55[1]) = 40;
  __sa = 0;
  if (!__s)
  {
    Default_0 = (char *)uloc_getDefault_0(0);
LABEL_16:
    __sa = Default_0;
    goto LABEL_17;
  }
  if (strchr(__s, 64) || sub_18C881EB0(Default_0) != 1) {
    goto LABEL_16;
  }
  if (!strchr(Default_0, 95)) {
    goto LABEL_94;
  }
  int v8 = Default_0[1];
  if (v8 == 45) {
    goto LABEL_94;
  }
  if (v8 == 95) {
    goto LABEL_94;
  }
  icu::CharString::append((icu::CharString *)v55, Default_0, -1, a4);
  if (*(int *)a4 > 0) {
    goto LABEL_94;
  }
  for (char i = v55[0]; *i == 95; ++i)
  {
    *char i = 45;
LABEL_14:
    ;
  }
  if (*i) {
    goto LABEL_14;
  }
  Default_0 = (char *)v55[0];
LABEL_94:
  long long __s1 = 0uLL;
  icu::CharStringByteSink::CharStringByteSink(&__s1, (uint64_t)v56);
  ulocimp_forLanguageTag(Default_0, -1, (uint64_t)&__s1, 0, (int *)a4);
  if (v57) {
    BOOL v33 = *a4 <= U_ZERO_ERROR;
  }
  else {
    BOOL v33 = 0;
  }
  uint64_t v34 = (char *)v56[0];
  if (!v33) {
    uint64_t v34 = Default_0;
  }
  __sa = v34;
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&__s1);
  Default_0 = __sa;
LABEL_17:
  long long v53 = 0u;
  long long v54 = 0u;
  long long __s1 = 0u;
  long long v52 = 0u;
  sub_18C8825C0((uint64_t)Default_0, &__sa, a4, (uint64_t)&__s1);
  if (DWORD2(v54) == 9)
  {
    long long v10 = (icu::Locale *)strncmp(Default_0, "i-defaultund", 9uLL);
    if (!v10)
    {
      DWORD2(v54) = 0;
      *(unsigned char *)long long __s1 = 0;
      char v17 = (const char *)uloc_getDefault_0(v10);
      icu::StringPiece::StringPiece((icu::StringPiece *)&v40, v17);
      icu::CharString::append((icu::CharString *)&__s1, v40, v41, a4);
LABEL_32:
      int v14 = 0;
      int v12 = 0;
      int v18 = 0;
      goto LABEL_47;
    }
  }
  int v11 = *__sa;
  if (v11 != 95 && v11 != 45) {
    goto LABEL_32;
  }
  int v39 = 0;
  icu::CharString::append((icu::CharString *)&__s1, 95, a4);
  long long v49 = 0u;
  long long v50 = 0u;
  long long __s2 = 0u;
  long long v48 = 0u;
  sub_18C882744((icu::CharString *)(__sa + 1), &v39, a4, (uint64_t)&__s2);
  icu::CharString::append((icu::CharString *)&__s1, (const char *)__s2, SDWORD2(v50), a4);
  int v12 = DWORD2(v50);
  if (SDWORD2(v50) < 1)
  {
    int v14 = 1;
  }
  else
  {
    __sa = v39;
    int v13 = *v39;
    if (v13 == 95 || v13 == 45) {
      icu::CharString::append((icu::CharString *)&__s1, 95, a4);
    }
    int v14 = 2;
  }
  int v15 = *__sa;
  if (v15 == 95 || v15 == 45)
  {
    uint64_t v38 = 0;
    long long v45 = 0u;
    *(_OWORD *)long long v46 = 0u;
    *(_OWORD *)char v43 = 0u;
    long long v44 = 0u;
    sub_18C882854((uint64_t)(__sa + 1), (uint64_t *)&v38, a4, (uint64_t)v43);
    icu::CharString::append((icu::CharString *)&__s1, v43[0], v46[2], a4);
    if (v46[2])
    {
      char v16 = v38;
      __sa = v38;
    }
    else
    {
      char v16 = __sa;
    }
    int v19 = *v16;
    if (v19 == 95 || v19 == 45)
    {
      int v20 = v16[1];
      if (v20 != 45 && v20 != 95)
      {
        ++v14;
        icu::CharString::append((icu::CharString *)&__s1, 95, a4);
      }
      int v21 = DWORD2(v54);
      v37[0] = 0;
      v37[1] = 0;
      icu::CharStringByteSink::CharStringByteSink(v37, (uint64_t)&__s1);
      sub_18C883514(__sa + 1, *__sa, (uint64_t)v37, 0);
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v37);
      int v18 = DWORD2(v54) - v21;
      if (DWORD2(v54) - v21 >= 1) {
        __sa += (v18 + 1);
      }
    }
    else
    {
      int v18 = 0;
    }
    if (BYTE4(v43[1])) {
      uprv_free(v43[0]);
    }
  }
  else
  {
    int v18 = 0;
  }
  if (BYTE12(__s2)) {
    uprv_free((void *)__s2);
  }
LABEL_47:
  uint64_t v22 = __sa;
  if ((a3 & 1) == 0)
  {
    int v23 = *__sa;
    if (v23 == 46)
    {
      while (((char)v23 | 0x40) != 0x40)
      {
        icu::CharString::append((icu::CharString *)&__s1, v23, a4);
        uint64_t v22 = __sa + 1;
        __sa = v22;
        LOBYTE(v23) = *v22;
      }
    }
  }
  unsigned int v24 = strchr(v22, 64);
  uint64_t v25 = v24;
  __sa = v24;
  if (!v24)
  {
    int v27 = 0;
    goto LABEL_58;
  }
  char v26 = strchr(v24, 61);
  int v27 = strchr(v25, 59);
  BOOL v28 = v26 == 0;
  if ((a3 & 1) == 0 && !v26)
  {
    char v29 = *v25;
    if (!*v25)
    {
      char v26 = 0;
      goto LABEL_81;
    }
    do
    {
      icu::CharString::append((icu::CharString *)&__s1, v29, a4);
      uint64_t v25 = __sa + 1;
      __sa = v25;
      char v29 = *v25;
    }
    while (*v25);
LABEL_58:
    char v26 = 0;
    BOOL v28 = 1;
  }
  if ((a3 & 1) == 0) {
    goto LABEL_81;
  }
  if (!v25) {
    BOOL v28 = 0;
  }
  if (v28)
  {
    if (v14 < 2 || v14 == 2 && v12 >= 1)
    {
      if (v14 <= 1) {
        int v30 = 1;
      }
      else {
        int v30 = v14;
      }
      int v31 = v30 - v14 + 1;
      do
      {
        icu::CharString::append((icu::CharString *)&__s1, 95, a4);
        --v31;
      }
      while (v31);
    }
    long long __s2 = 0uLL;
    icu::CharStringByteSink::CharStringByteSink(&__s2, (uint64_t)&__s1);
    sub_18C883514(__sa + 1, 64, (uint64_t)&__s2, v18 > 0);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&__s2);
  }
  uint64_t v32 = 0;
  while (2)
  {
    long long __s2 = 0uLL;
    icu::StringPiece::StringPiece((icu::StringPiece *)&__s2, off_1E5508360[v32]);
    if (DWORD2(v54) != DWORD2(__s2))
    {
LABEL_76:
      v32 += 2;
      if (v32 == 20) {
        goto LABEL_81;
      }
      continue;
    }
    break;
  }
  if (DWORD2(__s2))
  {
    if (!memcmp((const void *)__s1, (const void *)__s2, SDWORD2(__s2))) {
      goto LABEL_80;
    }
    goto LABEL_76;
  }
  if (__sa) {
    goto LABEL_81;
  }
LABEL_80:
  DWORD2(v54) = 0;
  *(unsigned char *)long long __s1 = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v35, off_1E5508360[v32 + 1]);
  icu::CharString::append((icu::CharString *)&__s1, v35, v36, a4);
LABEL_81:
  (*(void (**)(uint64_t, void, void))(*(void *)a2 + 16))(a2, __s1, DWORD2(v54));
  if ((a3 & 2) == 0 && __sa && v26 && (!v27 || v27 > v26))
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "@", 1);
    sub_18C881644(__sa + 1, 64, a2, 1, (int *)a4);
  }
  if (BYTE12(__s1)) {
    uprv_free((void *)__s1);
  }
  if (BYTE4(v55[1])) {
    uprv_free(v55[0]);
  }
  if (BYTE4(v56[1])) {
    uprv_free(v56[0]);
  }
}

uint64_t uloc_getBaseName(char *a1, char *a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 > 0) {
    return 0;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18C8837B0(a1, (uint64_t)&v10, 2, a4);
  uint64_t v4 = DWORD2(v11);
  if (*(int *)a4 <= 0)
  {
    if (BYTE12(v11)) {
      *a4 = U_BUFFER_OVERFLOW_ERROR;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), (int *)a4);
    }
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

void ulocimp_getBaseName(char *a1, uint64_t a2, UErrorCode *a3)
{
}

uint64_t uloc_canonicalize(char *a1, char *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v10, a2, a3);
  sub_18C8837B0(a1);
  uint64_t v4 = DWORD2(v11);
  if (*a4 <= 0)
  {
    if (BYTE12(v11)) {
      *a4 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v11), a4);
    }
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v10);
  return v4;
}

uint64_t ulocimp_canonicalize(char *a1)
{
  return sub_18C8837B0(a1);
}

uint64_t ualoc_canonicalForm(icu::Locale *a1, void *a2, int a3, int *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*a4 > 0) {
    return 0;
  }
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)__s = 0u;
  long long v14 = 0u;
  memset(v12, 0, sizeof(v12));
  icu::Locale::createCanonical(a1, (icu::Locale *)v12);
  int v8 = __s[1];
  size_t v9 = strlen(__s[1]);
  int v10 = uprv_min(v9, a3);
  memcpy(a2, v8, v10);
  uint64_t v4 = u_terminateChars((uint64_t)a2, a3, v9, a4);
  icu::Locale::~Locale((icu::Locale *)v12);
  return v4;
}

char *uloc_getISO3Language(uint64_t Default_0)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  int v3 = 0;
  if (!Default_0) {
    Default_0 = uloc_getDefault_0(0);
  }
  int v5 = 0;
  *(void *)long long __s1 = 0;
  uloc_getLanguage(Default_0, __s1, 12, &v3);
  if (v3 > 0) {
    return "";
  }
  int v2 = sub_18C8824F8((const char **)off_1E5505F08, __s1);
  if (v2 < 0) {
    return "";
  }
  else {
    return off_1E5504B80[(unsigned __int16)v2];
  }
}

char *uloc_getISO3Country(uint64_t Default_0)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  int v3 = 0;
  if (!Default_0) {
    Default_0 = uloc_getDefault_0(0);
  }
  int v5 = 0;
  *(void *)long long __s1 = 0;
  uloc_getCountry(Default_0, __s1, 12, &v3);
  if (v3 > 0) {
    return "";
  }
  int v2 = sub_18C8824F8((const char **)off_1E5507AF8, __s1);
  if (v2 < 0) {
    return "";
  }
  else {
    return off_1E5507290[(unsigned __int16)v2];
  }
}

uint64_t uloc_getLCID(char *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v9 = 0;
  if (!a1 || strlen(a1) < 2) {
    return 0;
  }
  memset(v22, 0, 157);
  uint64_t v2 = uprv_convertToLCIDPlatform();
  uint64_t v3 = v2;
  if (!v2)
  {
    uloc_getLanguage((uint64_t)a1, v22, 157, &v9);
    if (v9 <= 0 && v9 != -124)
    {
      if (!strchr(a1, 64)) {
        return uprv_convertToLCID(v22, a1, &v9);
      }
      long long v20 = 0u;
      memset(v21, 0, sizeof(v21));
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      *(_OWORD *)__s = 0u;
      memset(v11, 0, sizeof(v11));
      uint64_t v12 = 0;
      *(void *)int v10 = (char *)v11 + 5;
      LODWORD(v11[0]) = 40;
      v8[0] = 0;
      v8[1] = 0;
      icu::CharStringByteSink::CharStringByteSink(v8, (uint64_t)v10);
      ulocimp_getKeywordValue(a1, "collation", (uint64_t)v8, &v9);
      icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v8);
      if (v9 > 0) {
        goto LABEL_17;
      }
      if (v12
        && (int BaseName = uloc_getBaseName(a1, __s, 156, (UErrorCode *)&v9), v9 <= 0)
        && BaseName >= 1
        && (__s[BaseName] = 0, int v6 = uloc_setKeywordValue("collation", *(unsigned char **)v10, __s, 156 - BaseName, &v9), v9 <= 0)
        && v6 >= 1)
      {
        __s[v6] = 0;
        uint64_t v3 = uprv_convertToLCID(v22, __s, &v9);
        int v7 = 0;
      }
      else
      {
LABEL_17:
        int v9 = 0;
        int v7 = 1;
      }
      if (BYTE4(v11[0])) {
        uprv_free(*(void **)v10);
      }
      if (v7) {
        return uprv_convertToLCID(v22, a1, &v9);
      }
    }
  }
  return v3;
}

char *uloc_setDefault(char *a1, int *a2)
{
  if (*a2 <= 0) {
    return (char *)sub_18C80754C(a1);
  }
  return a1;
}

char **uloc_getISOLanguages()
{
  return off_1E5505F08;
}

char **uloc_getISOCountries()
{
  return off_1E5507AF8;
}

char *uloc_toUnicodeLocaleKey(uint64_t a1)
{
  uint64_t v1 = (char *)a1;
  uint64_t v2 = sub_18C88476C(a1);
  if (v2 || !sub_18C885F80(v1, -1)) {
    return (char *)v2;
  }
  return v1;
}

char *uloc_toUnicodeLocaleType(uint64_t a1, char *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = sub_18C884888(a1, a2, 0, 0);
  if (v3 || !sub_18C885FF4(v2, -1)) {
    return (char *)v3;
  }
  return v2;
}

uint64_t uloc_toLegacyKey(char *a1)
{
  uint64_t result = sub_18C884840((uint64_t)a1);
  if (!result)
  {
    char v3 = *a1;
    if (*a1)
    {
      uint64_t v4 = (unsigned __int8 *)(a1 + 1);
      while (uprv_isASCIILetter(v3) || *(v4 - 1) - 48 <= 9)
      {
        int v5 = *v4++;
        char v3 = v5;
        if (!v5) {
          return (uint64_t)a1;
        }
      }
      return 0;
    }
    else
    {
      return (uint64_t)a1;
    }
  }
  return result;
}

uint64_t uloc_toLegacyType(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = sub_18C884AD0(a1, a2, 0, 0);
  if (v3) {
    return v3;
  }
  int v5 = 0;
  for (char i = v2; ; ++i)
  {
    int v7 = *i;
    if ((v7 - 45) <= 0x32 && ((1 << (v7 - 45)) & 0x4000000000005) != 0)
    {
      if (!v5) {
        return v3;
      }
      int v5 = 0;
      continue;
    }
    if (!*i) {
      break;
    }
    if (!uprv_isASCIILetter(v7) && *i - 48 > 9) {
      return v3;
    }
    ++v5;
  }
  if (!v5) {
    return v3;
  }
  return (uint64_t)v2;
}

void sub_18C884658(void ***a1)
{
  uprv_free(*a1[1]);
  uprv_free(a1[1]);

  uprv_free(a1);
}

uint64_t sub_18C8846A0(uint64_t a1)
{
  uint64_t v1 = **(const char ***)(a1 + 8);
  if (!*v1) {
    return 0;
  }
  LODWORD(v2) = 0;
  do
  {
    uint64_t v2 = (v2 + 1);
    uint64_t v3 = &v1[strlen(v1)];
    int v4 = *((unsigned __int8 *)v3 + 1);
    uint64_t v1 = v3 + 1;
  }
  while (v4);
  return v2;
}

unsigned char *sub_18C8846F4(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(unsigned char **)(v3 + 8);
  if (!*v4)
  {
    int v4 = 0;
    int v5 = 0;
    if (!a2) {
      return v4;
    }
    goto LABEL_3;
  }
  int v5 = strlen(*(const char **)(v3 + 8));
  *(void *)(v3 + 8) = &v4[v5 + 1];
  if (a2) {
LABEL_3:
  }
    *a2 = v5;
  return v4;
}

uint64_t sub_18C88475C(uint64_t result)
{
  *(void *)(*(void *)(result + 8) + 8) = **(void **)(result + 8);
  return result;
}

uint64_t sub_18C88476C(uint64_t a1)
{
  if (!sub_18C8847B4()) {
    return 0;
  }
  uint64_t result = uhash_get(qword_1EB20B500, a1);
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

BOOL sub_18C8847B4()
{
  int v1 = 0;
  if (atomic_load_explicit((atomic_uint *volatile)&dword_1EB20B508, memory_order_acquire) == 2
    || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1EB20B508))
  {
    if (dword_1EB20B50C >= 1) {
      int v1 = dword_1EB20B50C;
    }
  }
  else
  {
    sub_18C884BC0(&v1);
    dword_1EB20B50C = v1;
    icu::umtx_initImplPostInit(&dword_1EB20B508);
  }
  return v1 < 1;
}

uint64_t sub_18C884840(uint64_t a1)
{
  if (!sub_18C8847B4()) {
    return 0;
  }
  uint64_t result = uhash_get(qword_1EB20B500, a1);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_18C884888(uint64_t a1, unsigned char *a2, unsigned char *a3, unsigned char *a4)
{
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (!sub_18C8847B4()) {
    return 0;
  }
  uint64_t result = uhash_get(qword_1EB20B500, a1);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  if (a3) {
    *a3 = 1;
  }
  uint64_t v10 = uhash_get(*(void *)(result + 16), (uint64_t)a2);
  if (v10) {
    return *(void *)(v10 + 8);
  }
  int v11 = *(_DWORD *)(v9 + 24);
  if (!v11) {
    return 0;
  }
  if ((v11 & 1) != 0 && sub_18C884978(a2))
  {
LABEL_16:
    if (!a4) {
      return (uint64_t)a2;
    }
    goto LABEL_27;
  }
  if ((v11 & 2) != 0)
  {
    if (sub_18C8849EC(a2)) {
      goto LABEL_16;
    }
    int v11 = *(_DWORD *)(v9 + 24);
  }
  if ((v11 & 4) == 0) {
    return 0;
  }
  BOOL v12 = sub_18C884A60(a2);
  if (v12) {
    uint64_t result = (uint64_t)a2;
  }
  else {
    uint64_t result = 0;
  }
  if (a4 && v12)
  {
LABEL_27:
    *a4 = 1;
    return (uint64_t)a2;
  }
  return result;
}

BOOL sub_18C884978(unsigned char *a1)
{
  int v1 = 0;
  while (1)
  {
    int v2 = *a1;
    if (v2 != 45) {
      break;
    }
    unsigned int v7 = v1 - 7;
    int v1 = 0;
    if (v7 < 0xFFFFFFFD) {
      return 0;
    }
LABEL_11:
    ++a1;
  }
  if (!*a1) {
    return (v1 - 4) < 3;
  }
  if ((v2 - 48) < 0xA
    || ((v3 = v2 - 65, BOOL v4 = v3 > 0x25, v5 = (1 << v3) & 0x3F0000003FLL, !v4) ? (v6 = v5 == 0) : (v6 = 1), !v6))
  {
    ++v1;
    goto LABEL_11;
  }
  return 0;
}

BOOL sub_18C8849EC(unsigned char *a1)
{
  int v2 = 0;
  while (1)
  {
    int v3 = *a1;
    if (v3 == 45) {
      break;
    }
    if (!*a1) {
      return (v2 - 3) < 6;
    }
    BOOL result = uprv_isASCIILetter(v3);
    if (!result) {
      return result;
    }
    ++v2;
LABEL_7:
    ++a1;
  }
  unsigned int v5 = v2 - 9;
  int v2 = 0;
  if (v5 >= 0xFFFFFFFA) {
    goto LABEL_7;
  }
  return 0;
}

BOOL sub_18C884A60(unsigned char *a1)
{
  LOBYTE(v1) = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t v2 = 0;
  int v3 = a1 + 1;
  do
  {
    if (v2 > 1)
    {
      if ((v1 | 0x20) != 0x7A) {
        return 0;
      }
    }
    else
    {
      BOOL result = uprv_isASCIILetter(v1);
      if (!result) {
        return result;
      }
    }
    int v1 = v3[v2++];
  }
  while (v1);
  return v2 == 6;
}

uint64_t sub_18C884AD0(uint64_t a1, unsigned char *a2, unsigned char *a3, unsigned char *a4)
{
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (!sub_18C8847B4()) {
    return 0;
  }
  uint64_t result = uhash_get(qword_1EB20B500, a1);
  if (!result) {
    return result;
  }
  uint64_t v9 = result;
  if (a3) {
    *a3 = 1;
  }
  uint64_t v10 = uhash_get(*(void *)(result + 16), (uint64_t)a2);
  if (v10) {
    return *(void *)v10;
  }
  int v11 = *(_DWORD *)(v9 + 24);
  if (!v11) {
    return 0;
  }
  if ((v11 & 1) != 0 && sub_18C884978(a2))
  {
LABEL_16:
    if (!a4) {
      return (uint64_t)a2;
    }
    goto LABEL_27;
  }
  if ((v11 & 2) != 0)
  {
    if (sub_18C8849EC(a2)) {
      goto LABEL_16;
    }
    int v11 = *(_DWORD *)(v9 + 24);
  }
  if ((v11 & 4) == 0) {
    return 0;
  }
  BOOL v12 = sub_18C884A60(a2);
  if (v12) {
    uint64_t result = (uint64_t)a2;
  }
  else {
    uint64_t result = 0;
  }
  if (a4 && v12)
  {
LABEL_27:
    *a4 = 1;
    return (uint64_t)a2;
  }
  return result;
}

void sub_18C884BC0(int *a1)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  sub_18C8546F4(6u, (uint64_t)sub_18C88562C);
  qword_1EB20B500 = (uint64_t)uhash_open((uint64_t)uhash_hashIChars, (uint64_t)uhash_compareIChars, 0, a1);
  uint64_t v2 = ures_openDirect(0, (uint64_t)"keyTypeData", (uint64_t)a1);
  uint64_t v3 = ures_getByKey(v2, "keyMap", 0, a1);
  uint64_t v4 = ures_getByKey(v2, "typeMap", 0, a1);
  if (*a1 > 0) {
    goto LABEL_149;
  }
  int v80 = 0;
  uint64_t v5 = ures_getByKey(v2, "typeAlias", 0, &v80);
  int v80 = 0;
  uint64_t v6 = ures_getByKey(v2, "bcpTypeAlias", 0, &v80);
  uint64_t v8 = icu::UMemory::operator new((icu::UMemory *)0x58, v7);
  uint64_t v10 = (const void ***)&unk_1EB20B000;
  if (!v8)
  {
    qword_1EB20B510 = 0;
LABEL_144:
    *a1 = 7;
    goto LABEL_145;
  }
  *(_DWORD *)uint64_t v8 = 0;
  *(void *)(v8 + 8) = v8 + 24;
  *(_DWORD *)(v8 + 16) = 8;
  *(unsigned char *)(v8 + 20) = 0;
  qword_1EB20B510 = v8;
  uint64_t v11 = icu::UMemory::operator new((icu::UMemory *)0x58, v9);
  if (!v11)
  {
    qword_1EB20B518 = 0;
    goto LABEL_144;
  }
  *(_DWORD *)uint64_t v11 = 0;
  *(void *)(v11 + 8) = v11 + 24;
  *(_DWORD *)(v11 + 16) = 8;
  *(unsigned char *)(v11 + 20) = 0;
  qword_1EB20B518 = v11;
  uint64_t v13 = icu::UMemory::operator new((icu::UMemory *)0x58, v12);
  if (!v13)
  {
    qword_1EB20B520 = 0;
    goto LABEL_144;
  }
  uint64_t v14 = 0;
  *(_DWORD *)uint64_t v13 = 0;
  *(void *)(v13 + 8) = v13 + 24;
  *(_DWORD *)(v13 + 16) = 8;
  uint64_t v73 = v6;
  *(unsigned char *)(v13 + 20) = 0;
  qword_1EB20B520 = v13;
  uint64_t v70 = v5;
  uint64_t v71 = v3;
  do
  {
    if (!ures_hasNext(v3)) {
      break;
    }
    NextResource = ures_getNextResource(v3, v14, (UErrorCode *)a1);
    uint64_t v14 = (uint64_t)NextResource;
    if (*a1 > 0) {
      break;
    }
    Key = (const char *)ures_getKey((uint64_t)NextResource);
    uint64_t v92 = 0;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v89 = 0u;
    long long v88 = &unk_1EDA47700;
    LOWORD(v89) = 2;
    LODWORD(v81) = 0;
    String = ures_getString(v14, (int *)&v81, a1);
    if (*a1 <= 0)
    {
      long long v83 = String;
      icu::UnicodeString::setTo((icu::UnicodeString *)&v88, 1, &v83, (int)v81);
    }
    else
    {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)&v88);
    }
    if (*a1 > 0) {
      goto LABEL_157;
    }
    long long v19 = Key;
    if ((unsigned __int16)v89 >= 0x20u)
    {
      long long v20 = (icu::CharString *)sub_18C8856B4(v10[162], v18);
      if (!v20)
      {
        *a1 = 7;
LABEL_157:
        icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v88);
        break;
      }
      long long v21 = v20;
      icu::CharString::appendInvariantChars(v20, (const icu::UnicodeString *)&v88, (UErrorCode *)a1);
      if (*a1 > 0) {
        goto LABEL_157;
      }
      long long v19 = *(const char **)v21;
    }
    long long v75 = v19;
    int v76 = strcmp(Key, "timezone");
    long long v22 = uhash_open((uint64_t)uhash_hashIChars, (uint64_t)uhash_compareIChars, 0, a1);
    if (*a1 > 0) {
      goto LABEL_157;
    }
    uint64_t v74 = (uint64_t)v22;
    if (v5)
    {
      int v80 = 0;
      uint64_t v23 = ures_getByKey(v5, Key, 0, &v80);
      if (v80 >= 1) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = v23;
      }
      uint64_t v78 = v24;
      if (v6)
      {
LABEL_22:
        int v80 = 0;
        uint64_t v25 = ures_getByKey(v6, v75, 0, &v80);
        if (v80 >= 1) {
          uint64_t v26 = 0;
        }
        else {
          uint64_t v26 = v25;
        }
        uint64_t v77 = v26;
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v78 = 0;
      if (v6) {
        goto LABEL_22;
      }
    }
    uint64_t v77 = 0;
LABEL_28:
    uint64_t v27 = ures_getByKey(v4, Key, 0, a1);
    BOOL v28 = Key;
    uint64_t v29 = v27;
    if (*a1 > 0)
    {
      int v30 = 3;
      if (!v27) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }
    uint64_t v72 = (uint64_t)v28;
    uint64_t v31 = 0;
    int v32 = 0;
    do
    {
      if (!ures_hasNext(v29)) {
        break;
      }
      uint64_t v34 = ures_getNextResource(v29, v31, (UErrorCode *)a1);
      uint64_t v31 = (uint64_t)v34;
      if (*a1 > 0) {
        break;
      }
      __s = 0;
      int v35 = (char *)ures_getKey((uint64_t)v34);
      __s = v35;
      if (!strcmp(v35, "CODEPOINTS"))
      {
        v32 |= 1u;
      }
      else if (!strcmp(v35, "REORDER_CODE"))
      {
        v32 |= 2u;
      }
      else
      {
        if (strcmp(v35, "RG_KEY_VALUE"))
        {
          if (!v76 && strchr(v35, 58))
          {
            uint64_t v36 = sub_18C8857A0((int *)qword_1EB20B510, (const char **)&__s, (UErrorCode *)a1);
            if (!v36)
            {
              *a1 = 7;
              break;
            }
            if (*a1 > 0) {
              break;
            }
            int v37 = *(char **)v36;
            uint64_t v38 = *(int *)(v36 + 56);
            if (v38)
            {
              do
              {
                if (*v37 == 58) {
                  *int v37 = 47;
                }
                ++v37;
                --v38;
              }
              while (v38);
              int v37 = *(char **)v36;
            }
            __s = v37;
          }
          uint64_t v87 = 0;
          long long v85 = 0u;
          long long v86 = 0u;
          long long v84 = 0u;
          long long v83 = (const UChar *)&unk_1EDA47700;
          LOWORD(v84) = 2;
          int v82 = 0;
          int v39 = (const char *)ures_getString(v31, &v82, a1);
          if (*a1 <= 0)
          {
            long long v81 = (const UChar *)v39;
            icu::UnicodeString::setTo((icu::UnicodeString *)&v83, 1, &v81, v82);
          }
          else
          {
            icu::UnicodeString::setToBogus((icu::UnicodeString *)&v83);
          }
          if (*a1 > 0)
          {
LABEL_61:
            int v41 = 5;
            goto LABEL_98;
          }
          if ((unsigned __int16)v84 >= 0x20u)
          {
            int v42 = (icu::CharString *)sub_18C8856B4((const void **)qword_1EB20B510, v40);
            if (v42)
            {
              p_s = (char **)v42;
              icu::CharString::appendInvariantChars(v42, (const icu::UnicodeString *)&v83, (UErrorCode *)a1);
              if (*a1 <= 0)
              {
LABEL_67:
                long long v44 = *p_s;
                long long v45 = sub_18C8858CC((const void **)qword_1EB20B520, v40);
                if (v45)
                {
                  uint64_t v46 = (uint64_t)v45;
                  void *v45 = __s;
                  v45[1] = v44;
                  uhash_put(v74, (uint64_t)__s, (uint64_t)v45, a1);
                  if (v44 != __s) {
                    uhash_put(v74, (uint64_t)v44, v46, a1);
                  }
                  uint64_t v68 = v46;
                  uint64_t v69 = v44;
                  if (*a1 <= 0)
                  {
                    uint64_t v5 = v70;
                    uint64_t v3 = v71;
                    if (v78)
                    {
                      ures_resetIterator(v78);
                      BOOL hasNext = ures_hasNext(v78);
                      int v48 = *a1;
                      if (hasNext && v48 <= 0)
                      {
                        long long v49 = 0;
                        do
                        {
                          int v82 = 0;
                          long long v49 = ures_getNextResource(v78, (uint64_t)v49, (UErrorCode *)a1);
                          long long v50 = (UChar *)ures_getString((uint64_t)v49, &v82, a1);
                          int v51 = *a1;
                          if (*a1 > 0) {
                            break;
                          }
                          if (!sub_18C87F328(0, __s, -1, v50, v82))
                          {
                            long long v81 = 0;
                            long long v52 = (char *)ures_getKey((uint64_t)v49);
                            long long v53 = v52;
                            long long v81 = (const UChar *)v52;
                            if (!v76 && strchr(v52, 58))
                            {
                              uint64_t v54 = sub_18C8857A0((int *)qword_1EB20B510, (const char **)&v81, (UErrorCode *)a1);
                              if (!v54)
                              {
                                int v51 = 7;
                                *a1 = 7;
                                if (!v49) {
                                  goto LABEL_104;
                                }
LABEL_91:
                                ures_close((uint64_t)v49);
                                BOOL v57 = v51 < 1;
                                uint64_t v5 = v70;
                                if (v57) {
                                  goto LABEL_106;
                                }
                                goto LABEL_61;
                              }
                              int v51 = *a1;
                              if (*a1 > 0) {
                                break;
                              }
                              long long v53 = *(char **)v54;
                              uint64_t v55 = *(int *)(v54 + 56);
                              if (v55)
                              {
                                do
                                {
                                  if (*v53 == 58) {
                                    *long long v53 = 47;
                                  }
                                  ++v53;
                                  --v55;
                                }
                                while (v55);
                                long long v53 = *(char **)v54;
                              }
                              long long v81 = (const UChar *)v53;
                            }
                            uhash_put(v74, (uint64_t)v53, v68, a1);
                          }
                          BOOL v56 = ures_hasNext(v78);
                          int v51 = *a1;
                        }
                        while (v56 && v51 < 1);
                        if (v49) {
                          goto LABEL_91;
                        }
LABEL_104:
                        BOOL v57 = v51 <= 0;
                        uint64_t v5 = v70;
                        if (v57) {
                          goto LABEL_106;
                        }
                        goto LABEL_61;
                      }
                      if (v48 >= 1) {
                        goto LABEL_61;
                      }
                    }
LABEL_106:
                    if (v77)
                    {
                      ures_resetIterator(v77);
                      BOOL v58 = ures_hasNext(v77);
                      int v59 = *a1;
                      if (v58 && v59 <= 0)
                      {
                        long long v60 = 0;
                        do
                        {
                          LODWORD(v81) = 0;
                          long long v60 = ures_getNextResource(v77, (uint64_t)v60, (UErrorCode *)a1);
                          long long v61 = (UChar *)ures_getString((uint64_t)v60, (int *)&v81, a1);
                          int v62 = *a1;
                          if (*a1 >= 1) {
                            break;
                          }
                          if (!sub_18C87F328(0, v69, -1, v61, (int)v81))
                          {
                            uint64_t v63 = ures_getKey((uint64_t)v60);
                            uhash_put(v74, v63, v68, a1);
                          }
                          BOOL v64 = ures_hasNext(v77);
                          int v62 = *a1;
                          if (!v64) {
                            break;
                          }
                        }
                        while (v62 < 1);
                        if (v60)
                        {
                          ures_close((uint64_t)v60);
                          BOOL v57 = v62 < 1;
                          uint64_t v5 = v70;
                          if (!v57) {
                            goto LABEL_61;
                          }
                        }
                        else
                        {
                          BOOL v57 = v62 <= 0;
                          uint64_t v5 = v70;
                          if (!v57) {
                            goto LABEL_61;
                          }
                        }
                      }
                      else if (v59 >= 1)
                      {
                        goto LABEL_61;
                      }
                    }
                    int v41 = 0;
LABEL_98:
                    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v83);
                    continue;
                  }
                }
                else
                {
                  *a1 = 7;
                }
                int v41 = 5;
                uint64_t v5 = v70;
                uint64_t v3 = v71;
                goto LABEL_98;
              }
            }
            else
            {
              *a1 = 7;
            }
            int v41 = 5;
            uint64_t v3 = v71;
            goto LABEL_98;
          }
          p_s = &__s;
          goto LABEL_67;
        }
        v32 |= 4u;
      }
      int v41 = 4;
    }
    while (v41 != 5);
    if (v31) {
      ures_close(v31);
    }
    if (*a1 > 0)
    {
      int v30 = 3;
      uint64_t v6 = v73;
      uint64_t v10 = (const void ***)&unk_1EB20B000;
      if (!v29) {
        goto LABEL_31;
      }
LABEL_30:
      ures_close(v29);
      goto LABEL_31;
    }
    long long v65 = sub_18C8859A4((const void **)qword_1EB20B518, v33);
    uint64_t v10 = (const void ***)&unk_1EB20B000;
    if (v65)
    {
      uint64_t v66 = (uint64_t)v65;
      *(void *)long long v65 = v72;
      *((void *)v65 + 1) = v75;
      *((_DWORD *)v65 + 6) = v32;
      long long v67 = (unsigned char *)*((void *)v65 + 2);
      if (v67) {
        uhash_close(v67);
      }
      *(void *)(v66 + 16) = v74;
      uhash_put(qword_1EB20B500, v72, v66, a1);
      if ((const char *)v72 != v75) {
        uhash_put(qword_1EB20B500, (uint64_t)v75, v66, a1);
      }
      if (*a1 <= 0) {
        int v30 = 0;
      }
      else {
        int v30 = 3;
      }
    }
    else
    {
      *a1 = 7;
      int v30 = 3;
    }
    uint64_t v6 = v73;
    if (v29) {
      goto LABEL_30;
    }
LABEL_31:
    if (v77) {
      ures_close(v77);
    }
    if (v78) {
      ures_close(v78);
    }
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v88);
  }
  while (!v30);
  if (v14) {
    ures_close(v14);
  }
LABEL_145:
  if (v6) {
    ures_close(v6);
  }
  if (v5) {
    ures_close(v5);
  }
LABEL_149:
  if (v4) {
    ures_close(v4);
  }
  if (v3) {
    ures_close(v3);
  }
  if (v2) {
    ures_close(v2);
  }
}

uint64_t sub_18C88562C()
{
  if (qword_1EB20B500)
  {
    uhash_close((unsigned char *)qword_1EB20B500);
    qword_1EB20B500 = 0;
  }
  if (qword_1EB20B518)
  {
    uint64_t v0 = (void *)sub_18C885A80(qword_1EB20B518);
    icu::UMemory::operator delete(v0);
  }
  qword_1EB20B518 = 0;
  if (qword_1EB20B520)
  {
    int v1 = (void *)sub_18C885AFC(qword_1EB20B520);
    icu::UMemory::operator delete(v1);
  }
  qword_1EB20B520 = 0;
  if (qword_1EB20B510)
  {
    uint64_t v2 = (void *)sub_18C885B60(qword_1EB20B510);
    icu::UMemory::operator delete(v2);
  }
  qword_1EB20B510 = 0;
  atomic_store(0, &dword_1EB20B508);
  return 1;
}

void *sub_18C8856B4(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0;
    }
    uint64_t result = uprv_malloc(8 * v4);
    if (!result) {
      return result;
    }
    uint64_t v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((unsigned char *)a1 + 20) = 1;
  }
  uint64_t result = (void *)icu::UMemory::operator new((icu::UMemory *)0x40, a2);
  if (result)
  {
    *uint64_t result = (char *)result + 13;
    *((_DWORD *)result + 2) = 40;
    *((_WORD *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
  }
  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_18C8857A0(int *a1, const char **a2, UErrorCode *a3)
{
  int v6 = a1[4];
  if (*a1 != v6)
  {
LABEL_16:
    uint64_t v9 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    if (v9)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v15, *a2);
      uint64_t v11 = v15;
      int v12 = v16;
      *(void *)uint64_t v9 = v9 + 13;
      *(_DWORD *)(v9 + 8) = 40;
      *(_WORD *)(v9 + 12) = 0;
      *(_DWORD *)(v9 + 56) = 0;
      icu::CharString::append((icu::CharString *)v9, v11, v12, a3);
    }
    uint64_t v13 = *a1;
    *a1 = v13 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v13) = v9;
    return v9;
  }
  if (v6 == 8) {
    int v7 = 32;
  }
  else {
    int v7 = 2 * v6;
  }
  if (v7 < 1) {
    return 0;
  }
  uint64_t v8 = uprv_malloc(8 * v7);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    if (v6 >= 1)
    {
      int v10 = a1[4];
      if (v10 >= v6) {
        int v10 = v6;
      }
      if (v10 >= v7) {
        int v10 = v7;
      }
      memcpy(v8, *((const void **)a1 + 1), 8 * v10);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v9;
    a1[4] = v7;
    *((unsigned char *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v9;
}

void *sub_18C8858CC(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0;
    }
    uint64_t result = uprv_malloc(8 * v4);
    if (!result) {
      return result;
    }
    int v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((unsigned char *)a1 + 20) = 1;
  }
  uint64_t result = (void *)icu::UMemory::operator new((icu::UMemory *)0x10, a2);
  if (result)
  {
    *uint64_t result = 0;
    result[1] = 0;
  }
  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

_OWORD *sub_18C8859A4(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0;
    }
    uint64_t result = uprv_malloc(8 * v4);
    if (!result) {
      return result;
    }
    int v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((unsigned char *)a1 + 20) = 1;
  }
  uint64_t result = (_OWORD *)icu::UMemory::operator new((icu::UMemory *)0x20, a2);
  if (result)
  {
    *uint64_t result = 0u;
    result[1] = 0u;
  }
  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_18C885A80(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      int v4 = *(void **)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        uint64_t v5 = (unsigned char *)v4[2];
        if (v5) {
          uhash_close(v5);
        }
        icu::UMemory::operator delete(v4);
        int v2 = *(_DWORD *)a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(unsigned char *)(a1 + 20)) {
    uprv_free(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_18C885AFC(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      int v4 = *(void **)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        icu::UMemory::operator delete(v4);
        int v2 = *(_DWORD *)a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(unsigned char *)(a1 + 20)) {
    uprv_free(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_18C885B60(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 8 * v3);
      if (v4)
      {
        if (*(unsigned char *)(v4 + 12)) {
          uprv_free(*(void **)v4);
        }
        icu::UMemory::operator delete((void *)v4);
        int v2 = *(_DWORD *)a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(unsigned char *)(a1 + 20)) {
    uprv_free(*(void **)(a1 + 8));
  }
  return a1;
}

BOOL sub_18C885BE0(char *__s, unsigned int a2)
{
  int v2 = __s;
  if ((a2 & 0x80000000) != 0) {
    a2 = strlen(__s);
  }
  if (a2 - 2 > 6) {
    return 0;
  }
  uint64_t v3 = a2;
  while (1)
  {
    char v4 = *v2++;
    BOOL result = uprv_isASCIILetter(v4);
    if (!result) {
      break;
    }
    if (!--v3) {
      return 1;
    }
  }
  return result;
}

BOOL sub_18C885C40(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  if (a2 != 4) {
    return 0;
  }
  uint64_t v3 = 0;
  while (1)
  {
    BOOL result = uprv_isASCIILetter(__s[v3]);
    if (!result) {
      break;
    }
    if (++v3 == 4) {
      return 1;
    }
  }
  return result;
}

BOOL sub_18C885CA0(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  if (a2 == 2)
  {
    uint64_t v5 = 0;
    while (1)
    {
      BOOL result = uprv_isASCIILetter(__s[v5]);
      if (!result) {
        break;
      }
      if (++v5 == 2) {
        return 1;
      }
    }
  }
  else
  {
    if (a2 == 3)
    {
      uint64_t v3 = 0;
      while (__s[v3] - 48 < 0xA)
      {
        if (++v3 == 3) {
          return 1;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_18C885D2C(char *__s, int a2)
{
  return sub_18C885D48((uint64_t (*)(void))sub_18C885E1C, __s, a2);
}

uint64_t sub_18C885D48(uint64_t (*a1)(void), char *__s, int a3)
{
  if (a3 < 0) {
    a3 = strlen(__s);
  }
  if (a3 < 1) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = a3;
  do
  {
    if (__s[v4] == 45)
    {
      if (!v5 || !((unsigned int (*)(char *, void))a1)(v5, (__s + v4 - v5))) {
        return 0;
      }
      uint64_t v5 = 0;
    }
    else if (!v5)
    {
      uint64_t v5 = &__s[v4];
    }
    ++v4;
  }
  while (v4 < v6);
  if (!v5) {
    return 0;
  }

  return a1();
}

uint64_t sub_18C885E1C(char *__s, int a2)
{
  int v2 = a2;
  if (a2 < 0) {
    int v2 = strlen(__s);
  }
  if (sub_18C885F08(__s, v2, 5)) {
    return 1;
  }
  if (v2 == 4 && *__s - 48 <= 9)
  {
    uint64_t v5 = 1;
    while (uprv_isASCIILetter(__s[v5]) || __s[v5] - 48 <= 9)
    {
      if (++v5 == 4) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t sub_18C885EB8(char *__s, int a2)
{
  return sub_18C885D48((uint64_t (*)(void))sub_18C885ED4, __s, a2);
}

BOOL sub_18C885ED4(char *a1, int a2)
{
  return sub_18C885F08(a1, a2, 2);
}

uint64_t sub_18C885EDC(char *__s, int a2)
{
  return sub_18C885D48((uint64_t (*)(void))sub_18C885EF8, __s, a2);
}

BOOL sub_18C885EF8(char *a1, int a2)
{
  return sub_18C885F08(a1, a2, 1);
}

BOOL sub_18C885F00(char *a1, int a2)
{
  return sub_18C885F08(a1, a2, 3);
}

BOOL sub_18C885F08(char *__s, int a2, int a3)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  return a2 >= a3 && a2 <= 8 && sub_18C888B78(__s, a2);
}

uint64_t sub_18C885F64(char *__s, int a2)
{
  return sub_18C885D48((uint64_t (*)(void))sub_18C885F00, __s, a2);
}

BOOL sub_18C885F80(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  return a2 == 2
      && (uprv_isASCIILetter(*__s) || *__s - 48 <= 9)
      && uprv_isASCIILetter(__s[1]);
}

BOOL sub_18C885FEC(char *a1, int a2)
{
  return sub_18C885F08(a1, a2, 3);
}

uint64_t sub_18C885FF4(char *__s, int a2)
{
  return sub_18C885D48((uint64_t (*)(void))sub_18C885FEC, __s, a2);
}

char *ultag_getTKeyStart(char *a1)
{
  int v1 = a1;
  int v2 = strchr(a1, 45);
  if (v2)
  {
    uint64_t v3 = v2;
    while (!sub_18C886080(v1, v3 - v1))
    {
      int v1 = v3 + 1;
      uint64_t v3 = strchr(v3 + 1, 45);
      if (!v3) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    if (!sub_18C886080(v1, -1)) {
      return 0;
    }
  }
  return v1;
}

BOOL sub_18C886080(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  return a2 == 2 && uprv_isASCIILetter(*__s) && __s[1] - 48 < 0xA;
}

uint64_t sub_18C8860E0(char *__s, int a2)
{
  return sub_18C8860FC((uint64_t (*)(int *, char *, uint64_t))sub_18C8861BC, __s, a2);
}

uint64_t sub_18C8860FC(uint64_t (*a1)(int *, char *, uint64_t), char *__s, int a3)
{
  int v3 = a3;
  uint64_t v4 = __s;
  int v11 = 0;
  if (a3 < 0) {
    int v3 = strlen(__s);
  }
  if (v3 < 1)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    int v7 = v4 + 1;
    int v8 = v3 + 1;
    do
    {
      if (*(v7 - 1) == 45)
      {
        uint64_t result = a1(&v11, v4, v6);
        uint64_t v6 = 0;
        uint64_t v4 = v7;
        if (!result) {
          return result;
        }
      }
      else
      {
        uint64_t v6 = (v6 + 1);
      }
      ++v7;
      --v8;
    }
    while (v8 > 1);
  }
  if (a1(&v11, v4, v6)) {
    BOOL v10 = v11 < 0;
  }
  else {
    BOOL v10 = 1;
  }
  return !v10;
}

BOOL sub_18C8861BC(int *a1, char *__s, unsigned int a3)
{
  unsigned int v3 = a3;
  if ((a3 & 0x80000000) != 0) {
    unsigned int v3 = strlen(__s);
  }
  BOOL result = 0;
  switch(*a1)
  {
    case -1:
      BOOL result = sub_18C885F08(__s, v3, 3);
      if (result)
      {
        int v7 = 6;
        goto LABEL_19;
      }
      return result;
    case 0:
      if (!sub_18C885BE0(__s, v3) || v3 == 4) {
        goto LABEL_11;
      }
      BOOL result = 1;
      *a1 = 1;
      return result;
    case 1:
      if (!sub_18C885C40(__s, v3)) {
        goto LABEL_15;
      }
      int v7 = 2;
      goto LABEL_19;
    case 2:
LABEL_15:
      if (!sub_18C885CA0(__s, v3)) {
        goto LABEL_4;
      }
      int v7 = 3;
      goto LABEL_19;
    case 3:
    case 4:
LABEL_4:
      if (sub_18C885E1C(__s, v3))
      {
        int v7 = 4;
      }
      else
      {
LABEL_11:
        BOOL result = sub_18C886080(__s, v3);
        if (!result) {
          return result;
        }
LABEL_18:
        int v7 = -1;
      }
LABEL_19:
      *a1 = v7;
      return 1;
    case 6:
      if (sub_18C886080(__s, v3)) {
        goto LABEL_18;
      }
      return sub_18C885F08(__s, v3, 3);
    default:
      return result;
  }
}

uint64_t sub_18C886334(char *__s, int a2)
{
  return sub_18C8860FC((uint64_t (*)(int *, char *, uint64_t))sub_18C886350, __s, a2);
}

BOOL sub_18C886350(int *a1, char *__s, int a3)
{
  int v6 = *a1;
  if (*a1 == 2) {
    goto LABEL_17;
  }
  if (v6 == 1)
  {
    if (!sub_18C885F80(__s, a3))
    {
      BOOL result = sub_18C885F08(__s, a3, 3);
      if (!result) {
        return result;
      }
      *a1 = 2;
    }
    return 1;
  }
  if (v6) {
    return 0;
  }
LABEL_17:
  if (sub_18C885F80(__s, a3))
  {
    BOOL result = 1;
    *a1 = 1;
  }
  else
  {
    return sub_18C885F08(__s, a3, 3);
  }
  return result;
}

uint64_t uloc_toLanguageTag(char *a1, char *a2, int a3, int a4, int *a5)
{
  if (*a5 > 0) {
    return 0;
  }
  long long v12 = 0u;
  long long v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a2, a3);
  ulocimp_toLanguageTag(a1, (uint64_t)&v12, a4, a5);
  uint64_t v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13)) {
      *a5 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v13), a5);
    }
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

void ulocimp_toLanguageTag(char *a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  memset(&v112[1], 0, 48);
  int v114 = 0;
  v112[0] = (char *)&v112[1] + 5;
  LODWORD(v112[1]) = 40;
  int v113 = 0;
  int v98 = 0;
  *(void *)__s = 0;
  *(void *)&__s[8] = 0;
  icu::CharStringByteSink::CharStringByteSink(__s, (uint64_t)v112);
  ulocimp_canonicalize(a1);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__s);
  KeywordsStart = locale_getKeywordsStart((char *)v112[0]);
  if (KeywordsStart == v112[0])
  {
    uint64_t v9 = (void **)uloc_openKeywords(KeywordsStart, &v98);
    BOOL v10 = v9;
    if (v98 > 0
      || uenum_count((uint64_t)v9, &v98) != 1
      || (LODWORD(v106[0]) = 0, int v11 = (char *)uenum_next((uint64_t)v10, (uint64_t)v106, &v98), LODWORD(v106[0]) != 1)
      || (long long v12 = v11, *v11 != 120))
    {
LABEL_16:
      if (v10) {
        uenum_close(v10);
      }
      goto LABEL_18;
    }
    memset(&__s[8], 0, 56);
    *(void *)__s = &__s[13];
    *(_DWORD *)&__s[8] = 40;
    unint64_t v107 = 0;
    int v108 = 0;
    icu::CharStringByteSink::CharStringByteSink(&v107, (uint64_t)__s);
    ulocimp_getKeywordValue(a1, v12, (uint64_t)&v107, &v98);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)&v107);
    if (v98 > 0)
    {
      int v13 = 0;
      *a4 = 1;
      goto LABEL_13;
    }
    if (sub_18C885D48((uint64_t (*)(void))sub_18C885EF8, *(char **)__s, *(int *)&__s[56]))
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "und-x-", 6);
      (*(void (**)(uint64_t, void, void))(*(void *)a2 + 16))(a2, *(void *)__s, *(unsigned int *)&__s[56]);
    }
    else
    {
      int v13 = 1;
      if (!a3) {
        goto LABEL_13;
      }
      *a4 = 1;
    }
    int v13 = 0;
LABEL_13:
    if (__s[12]) {
      uprv_free(*(void **)__s);
    }
    if (!v13)
    {
      if (v10) {
        uenum_close(v10);
      }
      goto LABEL_204;
    }
    goto LABEL_16;
  }
LABEL_18:
  LODWORD(v107) = 0;
  int v97 = a3;
  if (*a4 > 0) {
    goto LABEL_19;
  }
  *(_DWORD *)&__s[8] = 0;
  *(void *)__s = 0;
  Language = uloc_getLanguage((uint64_t)v112[0], __s, 12, (int *)&v107);
  if ((int)v107 > 0 || v107 == -124) {
    goto LABEL_73;
  }
  size_t v31 = (size_t)Language;
  if (!Language)
  {
LABEL_79:
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a2 + 16))(a2, "und", 3);
    goto LABEL_86;
  }
  if (!sub_18C885BE0(__s, Language))
  {
LABEL_73:
    if (a3)
    {
      *a4 = 1;
      goto LABEL_19;
    }
    goto LABEL_79;
  }
  size_t v32 = strlen(__s);
  unint64_t v33 = "in";
  unint64_t v34 = -2;
  while (v32 >= strlen(v33))
  {
    if (!strcmp(__s, v33))
    {
      strcpy(__s, v33 + 4);
      size_t v31 = strlen(__s);
      break;
    }
    v33 += 8;
    v34 += 2;
    if (v34 >= 0x9A) {
      break;
    }
  }
  (*(void (**)(uint64_t, char *, size_t))(*(void *)a2 + 16))(a2, __s, v31);
LABEL_86:
  int v40 = *a4;
  LODWORD(v107) = 0;
  if (v40 <= 0)
  {
    *(_WORD *)&char __s[4] = 0;
    *(_DWORD *)__s = 0;
    uint64_t Script = uloc_getScript((uint64_t)v112[0], __s, 6, (int *)&v107);
    if ((int)v107 <= 0 && v107 != -124)
    {
      uint64_t v42 = Script;
      if ((int)Script < 1) {
        goto LABEL_19;
      }
      if (sub_18C885C40(__s, Script))
      {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
        (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a2 + 16))(a2, __s, v42);
        goto LABEL_19;
      }
    }
    if (a3)
    {
      *a4 = 1;
      goto LABEL_20;
    }
  }
LABEL_19:
  int v14 = *a4;
  LODWORD(v107) = 0;
  if (v14 > 0) {
    goto LABEL_20;
  }
  *(_DWORD *)__s = 0;
  uint64_t Country = uloc_getCountry((uint64_t)v112[0], __s, 4, (int *)&v107);
  if ((int)v107 > 0 || v107 == -124) {
    goto LABEL_75;
  }
  size_t v36 = Country;
  if ((int)Country < 1) {
    goto LABEL_20;
  }
  if (!sub_18C885CA0(__s, Country))
  {
LABEL_75:
    if (a3) {
      goto LABEL_78;
    }
  }
  else
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
    int v37 = (const char *)&unk_18CA81AE7;
    unint64_t v38 = -2;
    while (strcmp(__s, v37))
    {
      v37 += 6;
      v38 += 2;
      if (v38 >= 0xA) {
        goto LABEL_82;
      }
    }
    strcpy(__s, v37 + 3);
    size_t v36 = strlen(__s);
LABEL_82:
    (*(void (**)(uint64_t, char *, size_t))(*(void *)a2 + 16))(a2, __s, v36);
  }
LABEL_20:
  char v15 = 0;
  int v16 = *a4;
  LODWORD(v106[0]) = 0;
  if (v16 > 0) {
    goto LABEL_101;
  }
  long long v121 = 0u;
  memset(v122, 0, sizeof(v122));
  long long v119 = 0u;
  long long v120 = 0u;
  long long v118 = 0u;
  memset(__s, 0, sizeof(__s));
  int Variant = uloc_getVariant((char *)v112[0], __s, 157, (int *)v106);
  if (SLODWORD(v106[0]) > 0 || LODWORD(v106[0]) == -124)
  {
    if (!a3) {
      goto LABEL_80;
    }
LABEL_78:
    char v15 = 0;
    *a4 = 1;
    goto LABEL_101;
  }
  int v18 = Variant;
  if (Variant < 1)
  {
LABEL_80:
    char v15 = 0;
    goto LABEL_101;
  }
  char v95 = 0;
  long long v19 = 0;
  unint64_t v107 = 0;
  long long v20 = __s;
  while (1)
  {
    int v21 = *v20;
    if (*v20)
    {
      if (v21 != 95 && v21 != 45)
      {
        if (!v19) {
          long long v19 = v20;
        }
        int v21 = 1;
        goto LABEL_50;
      }
      *long long v20 = 0;
      int v21 = 1;
    }
    if (!v19) {
      goto LABEL_48;
    }
    char v22 = *v19;
    if (*v19)
    {
      uint64_t v23 = (unsigned __int8 *)(v19 + 1);
      do
      {
        *(v23 - 1) = uprv_asciitolower(v22);
        int v24 = *v23++;
        char v22 = v24;
      }
      while (v24);
    }
    if (!sub_18C885E1C(v19, -1)) {
      break;
    }
    if (!strcmp(v19, "posix") && v18 == 5)
    {
      long long v19 = 0;
      char v95 = 1;
    }
    else
    {
      uint64_t v25 = uprv_malloc(0x10uLL);
      if (!v25)
      {
        int v39 = 7;
        goto LABEL_97;
      }
      uint64_t v26 = v25;
      *uint64_t v25 = v19;
      if (!sub_18C888BE4(&v107, (uint64_t)v25))
      {
        uprv_free(v26);
        a3 = v97;
LABEL_48:
        if (!a3)
        {
LABEL_49:
          long long v19 = 0;
          goto LABEL_50;
        }
LABEL_83:
        int v39 = 1;
LABEL_97:
        *a4 = v39;
        uint64_t v27 = v107;
        goto LABEL_98;
      }
      long long v19 = 0;
    }
    a3 = v97;
LABEL_50:
    ++v20;
    if (!v21) {
      goto LABEL_51;
    }
  }
  a3 = v97;
  if (v97) {
    goto LABEL_83;
  }
  if (!sub_18C885F08(v19, -1, 1)) {
    goto LABEL_49;
  }
LABEL_51:
  uint64_t v27 = v107;
  if (*a4 <= 0 && v107)
  {
    sub_18C888B00((uint64_t)v107);
    BOOL v28 = v27;
    do
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
      size_t v29 = strlen(*v28);
      (*(void (**)(uint64_t, const char *, size_t))(*(void *)a2 + 16))(a2, *v28, v29);
      BOOL v28 = (const char **)v28[1];
    }
    while (v28);
  }
LABEL_98:
  if (v27)
  {
    do
    {
      char v43 = (const char **)v27[1];
      uprv_free(v27);
      uint64_t v27 = v43;
    }
    while (v43);
  }
  char v15 = v95;
LABEL_101:
  long long v44 = (char *)v112[0];
  LODWORD(v120) = 0;
  long long v118 = 0u;
  long long v119 = 0u;
  memset(__s, 0, sizeof(__s));
  int v111 = 0;
  unint64_t v107 = 0;
  memset(v109, 0, sizeof(v109));
  uint64_t v110 = 0;
  int v108 = &v109[2];
  v109[0] = 8;
  v106[0] = 0;
  memset(&v106[2], 0, 72);
  v106[1] = &v106[3];
  LODWORD(v106[2]) = 8;
  v105[0] = 0;
  memset(&v105[2], 0, 72);
  v105[1] = &v105[3];
  LODWORD(v105[2]) = 8;
  long long v45 = (void **)uloc_openKeywords((char *)v112[0], a4);
  uint64_t v46 = v45;
  if (!v15 && *a4 > 0 || !(v15 | (v45 != 0))) {
    goto LABEL_201;
  }
  int v104 = 0;
  unsigned int v102 = 0;
  uint64_t v103 = 0;
  v101[0] = 0;
  memset(&v101[2], 0, 72);
  v101[1] = &v101[3];
  LODWORD(v101[2]) = 8;
  int v100 = 0;
  uint64_t v47 = uenum_next((uint64_t)v45, 0, a4);
  if (!v47) {
    goto LABEL_179;
  }
  long long v49 = (char *)v47;
  unsigned int v94 = 0;
  unsigned int v96 = 0;
  while (2)
  {
    uint64_t v116 = 0;
    memset(&v115[1], 0, 48);
    v115[0] = (char *)&v115[1] + 5;
    LODWORD(v115[1]) = 40;
    v99[0] = 0;
    v99[1] = 0;
    icu::CharStringByteSink::CharStringByteSink(v99, (uint64_t)v115);
    ulocimp_getKeywordValue(v44, v49, (uint64_t)v99, &v100);
    icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v99);
    int v50 = v116;
    int v104 = v116;
    int v51 = v100;
    if (v100 >= 1)
    {
      if (v100 != 7)
      {
        if (v97) {
          goto LABEL_109;
        }
        int v100 = 0;
LABEL_149:
        int v52 = 2;
        goto LABEL_111;
      }
LABEL_110:
      *a4 = v51;
      int v52 = 3;
      goto LABEL_111;
    }
    int v53 = strlen(v49);
    if (strcmp(v49, "attribute"))
    {
      if (v53 >= 2)
      {
        unsigned int v96 = uloc_toUnicodeLocaleKey((uint64_t)v49);
        if (v96)
        {
          uint64_t v54 = uloc_toUnicodeLocaleType((uint64_t)v49, (char *)v115[0]);
          if (v54)
          {
            unsigned int v94 = v54;
            if (v54 != v115[0]) {
              goto LABEL_172;
            }
            uint64_t v55 = (unsigned __int8 **)sub_18C888E20((int *)v101, (unint64_t)v115, (UErrorCode *)&v100);
            if (!v55) {
              goto LABEL_176;
            }
            int v51 = v100;
            if (v100 >= 1) {
              goto LABEL_110;
            }
            BOOL v56 = v55;
            T_CString_toLowerCase(*v55);
            unsigned int v94 = (char *)*v56;
LABEL_172:
            uint64_t v73 = sub_18C8890D4(v106, v48);
            if (!v73)
            {
LABEL_176:
              int v51 = 7;
              goto LABEL_110;
            }
            *uint64_t v73 = v96;
            v73[1] = v94;
            int v74 = sub_18C8891B0(&v103, (uint64_t)v73, 1);
            int v52 = 0;
            if (!v97 || v74) {
              goto LABEL_111;
            }
          }
          else
          {
            if (!v97)
            {
              unsigned int v94 = 0;
              goto LABEL_149;
            }
            unsigned int v94 = 0;
          }
        }
        else
        {
          if (!v97)
          {
            unsigned int v96 = 0;
            goto LABEL_149;
          }
          unsigned int v96 = 0;
        }
LABEL_109:
        int v51 = 1;
        goto LABEL_110;
      }
      if (*v49 == 120)
      {
        long long v67 = (char *)v115[0];
        uint64_t v68 = (uint64_t (*)(void))sub_18C885EF8;
        int v69 = v50;
LABEL_154:
        if (sub_18C885D48(v68, v67, v69))
        {
          v99[0] = (const char *)v115[0];
          uint64_t v70 = (char **)sub_18C888FAC((int *)v101, v99, &v104, (UErrorCode *)&v100);
          if (v70)
          {
            int v71 = v100;
            if (v100 < 1)
            {
              unsigned int v94 = *v70;
              unsigned int v96 = v49;
              goto LABEL_172;
            }
          }
          else
          {
            int v71 = 7;
          }
          *a4 = v71;
          int v52 = 3;
          unsigned int v96 = v49;
          goto LABEL_111;
        }
      }
      else if (sub_18C888F38(v49, v53))
      {
        long long v67 = (char *)v115[0];
        int v69 = v104;
        uint64_t v68 = (uint64_t (*)(void))sub_18C885ED4;
        goto LABEL_154;
      }
      if (!v97) {
        goto LABEL_149;
      }
      goto LABEL_109;
    }
    if (v50 < 1) {
      goto LABEL_172;
    }
    int v57 = 0;
    while (2)
    {
      int v111 = 0;
      int v58 = v104;
      if (v57 >= v104) {
        goto LABEL_140;
      }
      int v59 = v57;
      int v60 = *((unsigned __int8 *)v115[0] + v57);
      if (v60 == 45)
      {
        unint64_t v61 = 0;
LABEL_135:
        int v57 = v59 + 1;
LABEL_137:
        if ((int)v61 >= 1)
        {
          if (v61 > 0x63) {
            *a4 = -124;
          }
          else {
            __s[v61] = 0;
          }
LABEL_141:
          uint64_t v63 = sub_18C8858CC((const void **)&v107, v48);
          if (!v63 || (BOOL v64 = v63, (v65 = (void *)sub_18C888C4C((int *)v105, __s, &v111, (UErrorCode *)a4)) == 0))
          {
            unsigned int v94 = 0;
            int v72 = 7;
LABEL_170:
            *a4 = v72;
LABEL_171:
            unsigned int v96 = "attribute";
            goto LABEL_172;
          }
          if (*a4 > 0)
          {
LABEL_168:
            unsigned int v94 = 0;
            goto LABEL_171;
          }
          *BOOL v64 = *v65;
          int v66 = sub_18C888D70(&v102, (uint64_t)v64);
          if (v97 && !v66)
          {
            unsigned int v94 = 0;
            int v72 = 1;
            goto LABEL_170;
          }
          continue;
        }
LABEL_140:
        if (v57 >= v58) {
          goto LABEL_168;
        }
        goto LABEL_141;
      }
      break;
    }
    unint64_t v61 = 0;
    int v62 = (char *)v115[0] + v57 + 1;
    while (v61 != 100)
    {
      int v111 = v61 + 1;
      __s[v61] = v60;
      if (!(v57 - (uint64_t)v58 + 1 + v61))
      {
        unint64_t v61 = (v61 + 1);
        int v57 = v58;
        goto LABEL_137;
      }
      int v60 = v62[v61++];
      if (v60 == 45)
      {
        int v59 = v57 + v61;
        unint64_t v61 = v61;
        goto LABEL_135;
      }
    }
    int v52 = 1;
    *a4 = 1;
LABEL_111:
    if (BYTE4(v115[1])) {
      uprv_free(v115[0]);
    }
    if (v52 && v52 != 2)
    {
      if (v52 == 3) {
        break;
      }
      goto LABEL_200;
    }
    long long v49 = (char *)uenum_next((uint64_t)v46, 0, a4);
    if (v49) {
      continue;
    }
    break;
  }
LABEL_179:
  if (!v15)
  {
LABEL_182:
    if (*a4 > 0) {
      goto LABEL_200;
    }
    int v76 = v103;
    if (!v103) {
      goto LABEL_200;
    }
    int v77 = 0;
    uint64_t v78 = v102;
    while (1)
    {
      long long v79 = *v76;
      if (!v77)
      {
        if (strlen(*v76) < 2)
        {
          int v77 = 0;
          goto LABEL_189;
        }
        (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-u", 2);
        long long v79 = *v76;
      }
      int v77 = 1;
LABEL_189:
      if (!strcmp(v79, "attribute"))
      {
        if (v78)
        {
          long long v83 = v78;
          do
          {
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
            size_t v84 = strlen(*v83);
            (*(void (**)(uint64_t, const char *, size_t))(*(void *)a2 + 16))(a2, *v83, v84);
            long long v83 = (const char **)v83[1];
          }
          while (v83);
        }
      }
      else
      {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
        size_t v80 = strlen(*v76);
        (*(void (**)(uint64_t, const char *, size_t))(*(void *)a2 + 16))(a2, *v76, v80);
        long long v81 = v76[1];
        if (strcmp(v81, "true") && strcmp(v81, "yes"))
        {
          (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
          size_t v82 = strlen(v76[1]);
          (*(void (**)(uint64_t, const char *, size_t))(*(void *)a2 + 16))(a2, v76[1], v82);
        }
      }
      int v76 = (const char **)v76[2];
      if (!v76) {
        goto LABEL_200;
      }
    }
  }
  long long v75 = sub_18C8890D4(v106, v48);
  if (v75)
  {
    *long long v75 = "va";
    v75[1] = "posix";
    sub_18C8891B0(&v103, (uint64_t)v75, 1);
    goto LABEL_182;
  }
  *a4 = 7;
LABEL_200:
  sub_18C885B60((uint64_t)v101);
LABEL_201:
  if (v46) {
    uenum_close(v46);
  }
  sub_18C885B60((uint64_t)v105);
  sub_18C885AFC((uint64_t)v106);
  sub_18C885AFC((uint64_t)&v107);
  LODWORD(v107) = 0;
  if (*a4 <= 0)
  {
    long long v121 = 0u;
    memset(v122, 0, sizeof(v122));
    long long v119 = 0u;
    long long v120 = 0u;
    long long v118 = 0u;
    memset(__s, 0, sizeof(__s));
    int v85 = uloc_getVariant((char *)v112[0], __s, 157, (int *)&v107);
    if ((int)v107 > 0 || v107 == -124)
    {
LABEL_231:
      if (v97) {
        *a4 = 1;
      }
      goto LABEL_204;
    }
    if (v85 < 1) {
      goto LABEL_204;
    }
    long long v86 = 0;
    uint64_t v87 = __s;
    int v88 = 1;
    do
    {
      int v89 = *v87;
      if (*v87)
      {
        if (v89 != 95 && v89 != 45)
        {
          if (!v86) {
            long long v86 = v87;
          }
          int v89 = 1;
          goto LABEL_229;
        }
        *uint64_t v87 = 0;
        int v89 = 1;
      }
      if (v86)
      {
        char v90 = *v86;
        if (*v86)
        {
          long long v91 = (unsigned __int8 *)(v86 + 1);
          do
          {
            *(v91 - 1) = uprv_asciitolower(v90);
            int v92 = *v91++;
            char v90 = v92;
          }
          while (v92);
        }
        if (!sub_18C885F08(v86, -1, 1)) {
          goto LABEL_231;
        }
        if (v88 && sub_18C885E1C(v86, -1))
        {
          long long v86 = 0;
        }
        else
        {
          (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
          if (v88)
          {
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "x", 1);
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "lvariant", 8);
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a2 + 16))(a2, "-", 1);
          }
          size_t v93 = strlen(v86);
          (*(void (**)(uint64_t, char *, size_t))(*(void *)a2 + 16))(a2, v86, v93);
          long long v86 = 0;
          int v88 = 0;
        }
      }
LABEL_229:
      ++v87;
    }
    while (v89);
  }
LABEL_204:
  if (BYTE4(v112[1])) {
    uprv_free(v112[0]);
  }
}

uint64_t uloc_forLanguageTag(char *a1, char *a2, int a3, _DWORD *a4, int *a5)
{
  if (*a5 > 0) {
    return 0;
  }
  long long v12 = 0u;
  long long v13 = 0u;
  icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v12, a2, a3);
  ulocimp_forLanguageTag(a1, -1, (uint64_t)&v12, a4, a5);
  uint64_t v5 = DWORD2(v13);
  if (*a5 <= 0)
  {
    if (BYTE12(v13)) {
      *a5 = 15;
    }
    else {
      u_terminateChars((uint64_t)a2, a3, DWORD2(v13), a5);
    }
  }
  icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v12);
  return v5;
}

uint64_t *ulocimp_forLanguageTag(char *__s, int a2, uint64_t a3, _DWORD *a4, int *a5)
{
  uint64_t v5 = (UErrorCode *)a5;
  int v8 = a2;
  uint64_t v178 = *MEMORY[0x1E4F143B8];
  if (a4) {
    *a4 = 0;
  }
  uint64_t v159 = 0;
  if (*a5 > 0) {
    goto LABEL_4;
  }
  if (a2 < 0) {
    int v8 = strlen(__s);
  }
  int v11 = (char *)uprv_malloc(v8 + 1);
  if (!v11)
  {
    *uint64_t v5 = U_MEMORY_ALLOCATION_ERROR;
LABEL_4:
    uint64_t v159 = 0;
    return sub_18C889338(&v159);
  }
  long long v12 = v11;
  if (v8 >= 1) {
    memcpy(v11, __s, v8);
  }
  v12[v8] = 0;
  long long v13 = uprv_malloc(0x58uLL);
  uint64_t v14 = (uint64_t)v13;
  *(void *)int v170 = v13;
  uint64_t v158 = v5;
  if (!v13)
  {
    uprv_free(v12);
LABEL_32:
    *uint64_t v5 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_153;
  }
  v13[2] = 0;
  v13[3] = 0;
  v13[4] = 0;
  v13[5] = &unk_18CA81B2D;
  v13[6] = &unk_18CA81B2D;
  v13[7] = 0;
  v13[9] = &unk_18CA81B2D;
  v13[10] = &unk_18CA81B2D;
  char v13[8] = 0;
  *long long v13 = v12;
  v13[1] = &unk_18CA81B2D;
  if (v8 < 2) {
    goto LABEL_152;
  }
  char v152 = a4;
  unint64_t v15 = 0;
  while (1)
  {
    int v16 = strlen(off_1E5508400[v15]);
    int v17 = v16;
    int v18 = v8 - v16;
    if (v8 >= v16 && (v8 <= v16 || v12[v16] == 45) && !uprv_strnicmp(off_1E5508400[v15], v12, v16)) {
      break;
    }
    BOOL v19 = v15 >= 0x30;
    v15 += 2;
    if (v19)
    {
      int v146 = 0;
      long long v20 = a4;
LABEL_21:
      unint64_t v21 = 0;
      while (1)
      {
        size_t v22 = strlen(off_1E5508590[v21]);
        if (!uprv_strnicmp(off_1E5508590[v21], v12, v22))
        {
          int v23 = v12[v22];
          BOOL v24 = v23 == 45 || v23 == 0;
          if (v24) {
            break;
          }
        }
        BOOL v19 = v21 >= 0x32;
        v21 += 2;
        if (v19) {
          goto LABEL_44;
        }
      }
      size_t v25 = strlen(off_1E5508590[v21 + 1]);
      memcpy(*(void **)v14, off_1E5508590[v21 + 1], v25);
      uint64_t v26 = &v12[v25];
      if (v12[v22] == 45) {
        memmove(v26, &v12[v22], v8 - v22 + 1);
      }
      else {
        *uint64_t v26 = 0;
      }
      int v146 = v22 - v25;
      goto LABEL_45;
    }
  }
  uint64_t v27 = off_1E5508400[v15 + 1];
  int v28 = strlen(v27);
  int v29 = v18 + v28;
  if (v8 >= v18 + v28)
  {
    int v30 = *(char **)v14;
  }
  else
  {
    uprv_free(v12);
    int v30 = (char *)uprv_malloc(v29 + 1);
    *(void *)uint64_t v14 = v30;
    long long v12 = v30;
    int v8 = v18 + v28;
    if (!v30)
    {
LABEL_37:
      uint64_t v14 = 0;
      uint64_t v5 = v158;
      goto LABEL_32;
    }
  }
  int v146 = v17 - v28;
  strcpy(v30, v27);
  int v31 = v17;
  if (v8 != v17)
  {
    memcpy((void *)(*(void *)v14 + v28), &__s[v17], v18);
    *(unsigned char *)(*(void *)v14 + v29) = 0;
    int v31 = v8;
  }
  int v8 = v31;
  long long v20 = v152;
  if (!v17) {
    goto LABEL_21;
  }
LABEL_44:
  if (!v12)
  {
LABEL_146:
    uint64_t v5 = v158;
    goto LABEL_150;
  }
LABEL_45:
  int v144 = 0;
  v151 = 0;
  uint64_t v154 = 0;
  uint64_t v156 = 0;
  int v148 = 0;
  __int16 v32 = 129;
  unint64_t v33 = (unsigned __int8 *)v12;
  while (1)
  {
    for (size_t i = 0; ; ++i)
    {
      int v35 = v33[i];
      if (!v33[i] || v35 == 45) {
        break;
      }
    }
    size_t v36 = &v33[i];
    if (v33[i]) {
      int v37 = v36 + 1;
    }
    else {
      int v37 = 0;
    }
    if ((v32 & 1) != 0 && sub_18C885BE0((char *)v33, i))
    {
      v33[i] = 0;
      *(void *)(*(void *)v170 + 8) = T_CString_toLowerCase(v33);
      if ((int)i >= 4) {
        __int16 v32 = 188;
      }
      else {
        __int16 v32 = 190;
      }
      goto LABEL_91;
    }
    if ((v32 & 2) != 0)
    {
      int v38 = (i & 0x80000000) != 0 ? strlen((const char *)v33) : i;
      if (v38 == 3)
      {
        uint64_t v39 = 0;
        while (uprv_isASCIILetter(v33[v39]))
        {
          if (++v39 == 3)
          {
            *size_t v36 = 0;
            *(void *)(*(void *)v170 + 8 * v148 + 16) = T_CString_toLowerCase(v33);
            if (v148 >= 2) {
              __int16 v32 = 188;
            }
            else {
              __int16 v32 = 190;
            }
            long long v12 = (char *)&v33[i];
            ++v148;
            goto LABEL_92;
          }
        }
      }
    }
    if ((v32 & 4) != 0 && sub_18C885C40((char *)v33, i))
    {
      *size_t v36 = 0;
      *unint64_t v33 = uprv_toupper((char)*v33);
      signed __int8 v40 = v33[1];
      if (v40)
      {
        int v41 = v33 + 2;
        do
        {
          *(v41 - 1) = uprv_asciitolower(v40);
          int v42 = *v41++;
          signed __int8 v40 = v42;
        }
        while (v42);
      }
      *(void *)(*(void *)v170 + 40) = v33;
      __int16 v32 = 184;
      goto LABEL_91;
    }
    if ((v32 & 8) == 0 || !sub_18C885CA0((char *)v33, i)) {
      break;
    }
    *size_t v36 = 0;
    *(void *)(*(void *)v170 + 48) = T_CString_toUpperCase(v33);
LABEL_90:
    __int16 v32 = 176;
LABEL_91:
    long long v12 = (char *)v36;
LABEL_92:
    unint64_t v33 = v37;
    if (!v37) {
      goto LABEL_133;
    }
  }
  if ((v32 & 0x10) != 0 && (sub_18C885E1C((char *)v33, i) || v144 && sub_18C885F08((char *)v33, i, 1)))
  {
    long long v44 = uprv_malloc(0x10uLL);
    if (!v44) {
      goto LABEL_37;
    }
    long long v45 = v44;
    *size_t v36 = 0;
    *long long v44 = T_CString_toUpperCase(v33);
    if (!sub_18C888BE4((const char ***)(*(void *)v170 + 56), (uint64_t)v45))
    {
      uprv_free(v45);
      goto LABEL_133;
    }
    goto LABEL_90;
  }
  if ((v32 & 0x20) != 0 && sub_18C888F38((char *)v33, i))
  {
    if (!v156)
    {
      char v43 = (unsigned __int8 *)v12;
      goto LABEL_130;
    }
    char v43 = v151;
    if (v154 && v151)
    {
      unsigned __int8 *v151 = 0;
      *(void *)(v156 + 8) = T_CString_toLowerCase(v154);
      if (!sub_18C8891B0((const char ***)(*(void *)v170 + 64), v156, 0))
      {
        BOOL v56 = (void *)v156;
        goto LABEL_148;
      }
LABEL_130:
      int v53 = uprv_malloc(0x18uLL);
      if (!v53) {
        goto LABEL_37;
      }
      *size_t v36 = 0;
      uint64_t v154 = 0;
      uint64_t v156 = (uint64_t)v53;
      *int v53 = T_CString_toLowerCase(v33);
      *(void *)(v156 + 8) = 0;
      long long v12 = (char *)v43;
      __int16 v32 = 64;
      v151 = 0;
      goto LABEL_92;
    }
    BOOL v56 = (void *)v156;
LABEL_148:
    uprv_free(v56);
LABEL_149:
    uint64_t v5 = v158;
    long long v20 = v152;
    goto LABEL_150;
  }
  if ((v32 & 0x40) != 0 && sub_18C885F08((char *)v33, i, 2))
  {
    uint64_t v46 = v154;
    if (!v154) {
      uint64_t v46 = v33;
    }
    uint64_t v154 = v46;
    __int16 v32 = 224;
    v151 = &v33[i];
    goto LABEL_92;
  }
  if ((v32 & 0x80) != 0)
  {
    int v47 = uprv_asciitolower((char)*v33);
    if (i == 1 && v47 == 120)
    {
      if (v156)
      {
        unint64_t v48 = (char *)v151;
        long long v20 = v152;
        if (!v154 || !v151)
        {
          uint64_t v55 = (void *)v156;
          goto LABEL_145;
        }
        unsigned __int8 *v151 = 0;
        *(void *)(v156 + 8) = T_CString_toLowerCase(v154);
        if (!sub_18C8891B0((const char ***)(*(void *)v170 + 64), v156, 0))
        {
          uint64_t v55 = (void *)v156;
LABEL_145:
          uprv_free(v55);
          goto LABEL_146;
        }
      }
      else
      {
        unint64_t v48 = v12;
        long long v20 = v152;
      }
      if (!v35)
      {
        LODWORD(v12) = v48;
        goto LABEL_146;
      }
      long long v49 = (char *)(v36 + 1);
      while (1)
      {
        long long v12 = v48;
        if (!v49) {
          break;
        }
        for (uint64_t j = 0; v49[j] && v49[j] != 45; ++j)
          ;
        unint64_t v48 = &v49[j];
        if (v49[j]) {
          int v51 = v48 + 1;
        }
        else {
          int v51 = 0;
        }
        if (!strncmp(v49, "lvariant", 8uLL))
        {
          uint64_t v156 = 0;
          v49[j] = 0;
          int v144 = 1;
          goto LABEL_128;
        }
        BOOL v52 = sub_18C885F08(v49, j, 1);
        long long v49 = v51;
        if (!v52) {
          goto LABEL_125;
        }
      }
      int v51 = 0;
LABEL_125:
      if (v32 == 16)
      {
        uint64_t v156 = 0;
LABEL_128:
        __int16 v32 = 16;
        int v37 = (unsigned __int8 *)v51;
        goto LABEL_92;
      }
      if (v12 - (char *)v37 >= 1)
      {
        *long long v12 = 0;
        *(void *)(*(void *)v170 + 72) = T_CString_toLowerCase(v37);
      }
      goto LABEL_149;
    }
  }
LABEL_133:
  if (!v156) {
    goto LABEL_149;
  }
  uint64_t v5 = v158;
  long long v20 = v152;
  if (v154 && v151)
  {
    unsigned __int8 *v151 = 0;
    *(void *)(v156 + 8) = T_CString_toLowerCase(v154);
    if (sub_18C8891B0((const char ***)(*(void *)v170 + 64), v156, 0))
    {
      LODWORD(v12) = v151;
      goto LABEL_150;
    }
    uint64_t v54 = (void *)v156;
  }
  else
  {
    uint64_t v54 = (void *)v156;
  }
  uprv_free(v54);
LABEL_150:
  uint64_t v14 = *(void *)v170;
  if (v20) {
    *long long v20 = v146 + v12 - **(_DWORD **)v170;
  }
LABEL_152:
  *(void *)int v170 = 0;
LABEL_153:
  sub_18C889338((uint64_t *)v170);
  int v57 = *v5;
  uint64_t v159 = v14;
  if (v57 > 0) {
    return sub_18C889338(&v159);
  }
  uint64_t v58 = 0;
  int v59 = 0;
  do
  {
    if (*(void *)(v14 + 16 + v58)) {
      ++v59;
    }
    v58 += 8;
  }
  while (v58 != 24);
  BOOL v24 = v59 == 0;
  uint64_t v60 = 16;
  if (v24) {
    uint64_t v60 = 8;
  }
  unint64_t v61 = *(const char **)(v14 + v60);
  if (!strcmp(v61, "und") || (int)strlen(v61) < 1)
  {
    int v62 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, const char *))(*(void *)a3 + 16))(a3, v61);
    int v62 = 0;
  }
  uint64_t v63 = *(const char **)(v14 + 40);
  int v64 = strlen(v63);
  uint64_t v65 = (v64 - 1);
  if (v64 >= 1)
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "_", 1);
    v170[0] = 0;
    v170[0] = uprv_toupper(*v63);
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16))(a3, v170, 1);
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, v63 + 1, v65);
    int v62 = 0;
  }
  int v66 = *(const char **)(v14 + 48);
  int v67 = strlen(v66);
  if (v67 >= 1)
  {
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "_", 1);
    if (*v66)
    {
      uint64_t v68 = (unsigned __int8 *)(v66 + 1);
      do
      {
        v170[0] = 0;
        v170[0] = uprv_toupper((char)*(v68 - 1));
        (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16))(a3, v170, 1);
      }
      while (*v68++);
    }
    int v62 = 0;
  }
  sub_18C888B00(*(void *)(v14 + 56));
  uint64_t v71 = *(void *)(v14 + 56);
  if (v71)
  {
    int v72 = 0;
    do
    {
      uint64_t v71 = *(void *)(v71 + 8);
      ++v72;
    }
    while (v71);
    if (v67 < 1)
    {
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "_", 1);
      int v62 = 0;
    }
    int v73 = 0;
    int v74 = 1;
    do
    {
      uint64_t v75 = *(void *)(v14 + 56);
      if (v75)
      {
        int v76 = v74;
        while (--v76)
        {
          uint64_t v75 = *(void *)(v75 + 8);
          if (!v75) {
            goto LABEL_181;
          }
        }
        int v77 = *(unsigned char **)v75;
      }
      else
      {
LABEL_181:
        int v77 = 0;
      }
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "_", 1);
      if (*v77)
      {
        uint64_t v78 = v77 + 1;
        do
        {
          v170[0] = 0;
          v170[0] = uprv_toupper((char)*(v78 - 1));
          (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16))(a3, v170, 1);
        }
        while (*v78++);
      }
      ++v73;
      ++v74;
    }
    while (v72 != v73);
    uint64_t v5 = v158;
  }
  if (*(void *)(v14 + 64))
  {
    if (v62) {
      (*(void (**)(uint64_t, char *, uint64_t))(*(void *)a3 + 16))(a3, "und", 3);
    }
  }
  else if (!**(unsigned char **)(v14 + 72))
  {
    return sub_18C889338(&v159);
  }
  unsigned int v162 = 0;
  v161[0] = 0;
  memset(&v161[2], 0, 72);
  v161[1] = &v161[3];
  LODWORD(v161[2]) = 8;
  v160[0] = 0;
  memset(&v160[2], 0, 72);
  v160[1] = &v160[3];
  LODWORD(v160[2]) = 8;
  int v80 = *v5;
  if (*(int *)v5 > 0) {
    goto LABEL_325;
  }
  uint64_t v81 = *(void *)(v14 + 64);
  if (!v81)
  {
    int v135 = 0;
    goto LABEL_308;
  }
  int v82 = -1;
  do
  {
    uint64_t v81 = *(void *)(v81 + 16);
    ++v82;
  }
  while (v81);
  int v83 = 0;
  int v153 = 0;
  int v84 = 1;
  while (2)
  {
    uint64_t v85 = *(void *)(v14 + 64);
    int v86 = v84;
    uint64_t v87 = v85;
    while (--v86)
    {
      uint64_t v87 = *(void *)(v87 + 16);
      if (!v87)
      {
        int v88 = 0;
        goto LABEL_202;
      }
    }
    int v88 = *(unsigned char **)v87;
LABEL_202:
    int v89 = v84;
    int v157 = v84;
    while (--v89)
    {
      uint64_t v85 = *(void *)(v85 + 16);
      if (!v85)
      {
        char v90 = 0;
        goto LABEL_207;
      }
    }
    char v90 = *(char **)(v85 + 8);
LABEL_207:
    if (*v88 != 117)
    {
      int v129 = sub_18C8890D4(v161, (unint64_t)v70);
      if (v129)
      {
        *int v129 = v88;
        v129[1] = v90;
        int v130 = sub_18C8891B0(&v162, (uint64_t)v129, 0);
        int v131 = v157;
        if (v130) {
          goto LABEL_295;
        }
        goto LABEL_323;
      }
      goto LABEL_322;
    }
    uint64_t v91 = *(void *)(v14 + 56);
    v168 = 0;
    unsigned int v169 = 0;
    LODWORD(v176) = 0;
    long long v174 = 0u;
    long long v175 = 0u;
    long long v172 = 0u;
    long long v173 = 0u;
    *(_OWORD *)int v170 = 0u;
    long long v171 = 0u;
    __n[0] = 0;
    memset(&__n[2], 0, 72);
    __n[1] = (size_t)&__n[3];
    LODWORD(__n[2]) = 8;
    int v92 = *v90;
    if (!*v90)
    {
      sub_18C885AFC((uint64_t)__n);
      goto LABEL_284;
    }
    uint64_t v149 = v91;
    int v155 = v83;
    int v93 = 0;
    do
    {
      for (k = 0; v92; int v92 = v95[1])
      {
        if (v92 == 45) {
          break;
        }
        char v95 = &v90[k++];
      }
      if (sub_18C885F80(v90, k)) {
        goto LABEL_221;
      }
      int v97 = sub_18C8858CC((const void **)__n, v96);
      if (!v97)
      {
        int v133 = 7;
LABEL_290:
        uint64_t v5 = v158;
        int v83 = v155;
        goto LABEL_291;
      }
      if (100 - v93 <= (int)k)
      {
        int v133 = 1;
        goto LABEL_290;
      }
      int v98 = v97;
      memcpy(&v170[v93], v90, k);
      v170[(v93 + k)] = 0;
      *int v98 = &v170[v93];
      v93 += k + 1;
      sub_18C888D70(&v168, (uint64_t)v98);
      if (v90[k]) {
        v90 += k + 1;
      }
      else {
        v90 += k;
      }
      int v92 = *v90;
    }
    while (*v90);
    char v90 = 0;
LABEL_221:
    int v99 = v168;
    uint64_t v5 = v158;
    int v83 = v155;
    uint64_t v100 = v149;
    if (v168)
    {
      char v101 = sub_18C8890D4(v161, v96);
      if (!v101)
      {
        int v133 = 7;
        goto LABEL_291;
      }
      uint64_t v103 = v101;
      int v104 = (icu::CharString *)sub_18C8856B4(v160, v102);
      if (v104)
      {
        __int16 v105 = v104;
        unsigned int v106 = v99;
        do
        {
          unint64_t v107 = (const char **)v106[1];
          if (v106 != v99) {
            icu::CharString::append(v105, 45, v158);
          }
          icu::StringPiece::StringPiece((icu::StringPiece *)&v165, *v106);
          icu::CharString::append(v105, v165, v166, v158);
          unsigned int v106 = v107;
        }
        while (v107);
        int v83 = v155;
        if (*(int *)v158 <= 0)
        {
          void *v103 = "attribute";
          v103[1] = *(void *)v105;
          int v108 = sub_18C8891B0(&v169, (uint64_t)v103, 0);
          uint64_t v5 = v158;
          uint64_t v100 = v149;
          if (v108) {
            goto LABEL_230;
          }
          int v133 = 1;
LABEL_291:
          *uint64_t v5 = v133;
        }
        sub_18C885AFC((uint64_t)__n);
        int v153 = 0;
        goto LABEL_293;
      }
      int v133 = 7;
      uint64_t v5 = v158;
      goto LABEL_291;
    }
LABEL_230:
    sub_18C885AFC((uint64_t)__n);
    if (!v90)
    {
LABEL_284:
      int v153 = 0;
LABEL_285:
      uint64_t v70 = v169;
      if (v169)
      {
        do
        {
          int v132 = (const char **)v70[2];
          sub_18C8891B0(&v162, (uint64_t)v70, 0);
          uint64_t v70 = v132;
        }
        while (v132);
      }
      goto LABEL_294;
    }
    unsigned int v109 = 0;
    uint64_t v110 = 0;
    LODWORD(__n[0]) = 0;
    LODWORD(v168) = 0;
    if (v100) {
      BOOL v111 = 0;
    }
    else {
      BOOL v111 = v153 == 0;
    }
    int v112 = v111;
    int v145 = v112;
    int v153 = 0;
    while (1)
    {
      int v113 = *v90;
      if (*v90)
      {
        uint64_t v114 = 0;
        do
        {
          if (v113 == 45) {
            break;
          }
          unsigned int v115 = &v90[v114++];
          int v113 = v115[1];
        }
        while (v113);
        if (!sub_18C885F80(v90, v114))
        {
          if (v109)
          {
            LODWORD(v168) = v168 + v114 + 1;
          }
          else
          {
            LODWORD(v168) = v114;
            unsigned int v109 = v90;
          }
          goto LABEL_276;
        }
        if (!v110)
        {
          LODWORD(__n[0]) = v114;
          uint64_t v110 = v90;
LABEL_276:
          if (v90[v114]) {
            v90 += v114 + 1;
          }
          else {
            v90 += v114;
          }
          continue;
        }
        int v116 = 0;
        int v117 = v90;
        if (v90[v114]) {
          v90 += v114 + 1;
        }
        else {
          v90 += v114;
        }
      }
      else
      {
        LODWORD(v114) = 0;
        int v117 = 0;
        int v116 = 1;
      }
      char v164 = 0;
      *(_WORD *)__int16 __dst = 0;
      uint64_t v118 = SLODWORD(__n[0]);
      if (SLODWORD(__n[0]) >= 3
        || (int v147 = v117,
            int v150 = v116,
            strncpy(__dst, v110, SLODWORD(__n[0])),
            __dst[v118] = 0,
            (long long v119 = (char *)uloc_toLegacyKey(__dst)) == 0))
      {
        *uint64_t v158 = U_ILLEGAL_ARGUMENT_ERROR;
        int v83 = v155;
        goto LABEL_293;
      }
      long long v120 = v119;
      int v83 = v155;
      if (v119 == __dst)
      {
        T_CString_toLowerCase((unsigned __int8 *)__dst);
        long long v121 = v158;
        int v122 = (const char **)sub_18C888C4C((int *)v160, __dst, (int *)__n, v158);
        if (!v122) {
          goto LABEL_304;
        }
        if (*(int *)v158 > 0) {
          goto LABEL_293;
        }
        long long v120 = *v122;
      }
      if (!v109)
      {
        uint64_t v125 = "yes";
        goto LABEL_264;
      }
      long long v176 = 0u;
      long long v177 = 0u;
      long long v174 = 0u;
      long long v175 = 0u;
      long long v172 = 0u;
      long long v173 = 0u;
      *(_OWORD *)int v170 = 0u;
      long long v171 = 0u;
      uint64_t v123 = (int)v168;
      if ((int)v168 > 127
        || (strncpy(v170, v109, (int)v168),
            v170[v123] = 0,
            (int v124 = (char *)uloc_toLegacyType((uint64_t)v120, v170)) == 0))
      {
        int v134 = 1;
        long long v121 = v158;
        int v83 = v155;
        goto LABEL_305;
      }
      uint64_t v125 = v124;
      int v83 = v155;
      if (v124 == v170) {
        break;
      }
LABEL_264:
      if (v145 && !strcmp(v120, "va") && !strcmp(v125, "posix"))
      {
        int v153 = 1;
      }
      else
      {
        BOOL v127 = sub_18C8890D4(v161, (unint64_t)v70);
        if (!v127)
        {
          *uint64_t v158 = U_MEMORY_ALLOCATION_ERROR;
          goto LABEL_293;
        }
        *BOOL v127 = v120;
        v127[1] = v125;
        sub_18C8891B0(&v169, (uint64_t)v127, 0);
      }
      unsigned int v109 = 0;
      uint64_t v110 = v147;
      if (v147) {
        int v128 = v114;
      }
      else {
        int v128 = 0;
      }
      LODWORD(__n[0]) = v128;
      LODWORD(v168) = 0;
      if (v150)
      {
        uint64_t v5 = v158;
        goto LABEL_285;
      }
    }
    T_CString_toLowerCase((unsigned __int8 *)v170);
    long long v121 = v158;
    int v126 = (const char **)sub_18C888C4C((int *)v160, v170, (int *)&v168, v158);
    if (v126)
    {
      if (*(int *)v158 > 0) {
        goto LABEL_293;
      }
      uint64_t v125 = *v126;
      goto LABEL_264;
    }
LABEL_304:
    int v134 = 7;
LABEL_305:
    _DWORD *v121 = v134;
LABEL_293:
    uint64_t v5 = v158;
LABEL_294:
    int v131 = v157;
    if (*(int *)v5 >= 1) {
      goto LABEL_325;
    }
LABEL_295:
    int v84 = v131 + 1;
    BOOL v24 = v82 == v83++;
    if (!v24) {
      continue;
    }
    break;
  }
  int v80 = *v5;
  if (*(int *)v5 <= 0)
  {
    int v135 = v153;
LABEL_308:
    uint64_t v136 = *(const char **)(v14 + 72);
    if ((int)strlen(v136) < 1)
    {
LABEL_312:
      if (v80 <= 0 && v135)
      {
        (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "_POSIX", 6);
        int v80 = *v5;
      }
      if (v80 <= 0)
      {
        uint64_t v139 = v162;
        if (v162)
        {
          unint64_t v140 = "@";
          do
          {
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, v140, 1);
            size_t v141 = strlen(*v139);
            (*(void (**)(uint64_t, const char *, size_t))(*(void *)a3 + 16))(a3, *v139, v141);
            (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)a3 + 16))(a3, "=", 1);
            size_t v142 = strlen(v139[1]);
            (*(void (**)(uint64_t, const char *, size_t))(*(void *)a3 + 16))(a3, v139[1], v142);
            uint64_t v139 = (const char **)v139[2];
            unint64_t v140 = ";";
          }
          while (v139);
        }
      }
      goto LABEL_325;
    }
    uint64_t v138 = sub_18C8890D4(v161, v137);
    if (v138)
    {
      *uint64_t v138 = "x";
      v138[1] = v136;
      if (sub_18C8891B0(&v162, (uint64_t)v138, 0))
      {
        int v80 = *v5;
        goto LABEL_312;
      }
LABEL_323:
      int v143 = 1;
LABEL_324:
      *uint64_t v5 = v143;
      goto LABEL_325;
    }
LABEL_322:
    int v143 = 7;
    goto LABEL_324;
  }
LABEL_325:
  sub_18C885B60((uint64_t)v160);
  sub_18C885AFC((uint64_t)v161);
  return sub_18C889338(&v159);
}

uint64_t sub_18C888B00(uint64_t result)
{
  if (result)
  {
    for (uint64_t i = result; ; uint64_t i = v2)
    {
      uint64_t v2 = *(void *)(i + 8);
      uint64_t v3 = v2;
      if (!v2) {
        break;
      }
      do
      {
        uint64_t v4 = *(const char **)i;
        uint64_t v5 = *(const char **)v3;
        BOOL result = strcmp(*(const char **)i, *(const char **)v3);
        if ((int)result >= 1)
        {
          *(void *)uint64_t i = v5;
          *(void *)uint64_t v3 = v4;
        }
        uint64_t v3 = *(void *)(v3 + 8);
      }
      while (v3);
    }
  }
  return result;
}

uint64_t sub_18C888B78(char *a1, int a2)
{
  if (a2 < 1) {
    return 1;
  }
  uint64_t v3 = a2;
  while (uprv_isASCIILetter(*a1) || *a1 - 48 <= 9)
  {
    ++a1;
    if (!--v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t sub_18C888BE4(const char ***a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  if (*a1)
  {
    uint64_t v4 = *(const char **)a2;
    while (1)
    {
      uint64_t v5 = v3;
      uint64_t result = strcmp(v4, *v3);
      if (!result) {
        break;
      }
      uint64_t v3 = (const char **)v5[1];
      if (!v3)
      {
        v5[1] = (const char *)a2;
        *(void *)(a2 + 8) = 0;
        return 1;
      }
    }
  }
  else
  {
    *(void *)(a2 + 8) = 0;
    *a1 = (const char **)a2;
    return 1;
  }
  return result;
}

uint64_t sub_18C888C4C(int *a1, const char *a2, int *a3, UErrorCode *a4)
{
  int v8 = a1[4];
  if (*a1 != v8)
  {
LABEL_16:
    uint64_t v13 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    uint64_t v11 = v13;
    if (v13)
    {
      int v14 = *a3;
      *(void *)uint64_t v13 = v13 + 13;
      *(_DWORD *)(v13 + 8) = 40;
      *(_WORD *)(v13 + 12) = 0;
      *(_DWORD *)(v13 + 56) = 0;
      icu::CharString::append((icu::CharString *)v13, a2, v14, a4);
    }
    uint64_t v15 = *a1;
    *a1 = v15 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v15) = v11;
    return v11;
  }
  if (v8 == 8) {
    int v9 = 32;
  }
  else {
    int v9 = 2 * v8;
  }
  if (v9 < 1) {
    return 0;
  }
  BOOL v10 = uprv_malloc(8 * v9);
  uint64_t v11 = (uint64_t)v10;
  if (v10)
  {
    if (v8 >= 1)
    {
      int v12 = a1[4];
      if (v12 >= v8) {
        int v12 = v8;
      }
      if (v12 >= v9) {
        int v12 = v9;
      }
      memcpy(v10, *((const void **)a1 + 1), 8 * v12);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v11;
    a1[4] = v9;
    *((unsigned char *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v11;
}

uint64_t sub_18C888D70(const char ***a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (!*a1)
  {
    *(void *)(a2 + 8) = 0;
    *a1 = (const char **)a2;
    return 1;
  }
  uint64_t v5 = *(const char **)a2;
  uint64_t result = strcmp(*(const char **)a2, *v4);
  if ((result & 0x80000000) != 0)
  {
    int v7 = 0;
LABEL_9:
    if (v7) {
      int v9 = (const char ***)(v7 + 1);
    }
    else {
      int v9 = a1;
    }
    *int v9 = (const char **)a2;
    *(void *)(a2 + 8) = v4;
    return 1;
  }
  int v8 = v4;
  while (result)
  {
    uint64_t v4 = (const char **)v8[1];
    if (!v4)
    {
      v8[1] = (const char *)a2;
      *(void *)(a2 + 8) = 0;
      return 1;
    }
    uint64_t result = strcmp(v5, *v4);
    int v7 = v8;
    int v8 = v4;
    if ((result & 0x80000000) != 0) {
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t sub_18C888E20(int *a1, unint64_t a2, UErrorCode *a3)
{
  int v6 = a1[4];
  if (*a1 != v6)
  {
LABEL_16:
    uint64_t v11 = icu::UMemory::operator new((icu::UMemory *)0x40, a2);
    uint64_t v9 = v11;
    if (v11)
    {
      *(void *)uint64_t v11 = v11 + 13;
      *(_DWORD *)(v11 + 8) = 40;
      *(_WORD *)(v11 + 12) = 0;
      *(_DWORD *)(v11 + 56) = 0;
      icu::CharString::append((icu::CharString *)v11, *(const char **)a2, *(_DWORD *)(a2 + 56), a3);
    }
    uint64_t v12 = *a1;
    *a1 = v12 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v12) = v9;
    return v9;
  }
  if (v6 == 8) {
    int v7 = 32;
  }
  else {
    int v7 = 2 * v6;
  }
  if (v7 < 1) {
    return 0;
  }
  int v8 = uprv_malloc(8 * v7);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    if (v6 >= 1)
    {
      int v10 = a1[4];
      if (v10 >= v6) {
        int v10 = v6;
      }
      if (v10 >= v7) {
        int v10 = v7;
      }
      memcpy(v8, *((const void **)a1 + 1), 8 * v10);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v9;
    a1[4] = v7;
    *((unsigned char *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v9;
}

BOOL sub_18C888F38(char *__s, int a2)
{
  if (a2 < 0) {
    a2 = strlen(__s);
  }
  BOOL result = 0;
  if (a2 == 1)
  {
    BOOL v3 = !uprv_isASCIILetter(*__s) && (*__s - 48) > 9u;
    if (!v3 && uprv_asciitolower(*__s) != 120) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_18C888FAC(int *a1, const char **a2, int *a3, UErrorCode *a4)
{
  int v8 = a1[4];
  if (*a1 != v8)
  {
LABEL_16:
    uint64_t v13 = icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
    uint64_t v11 = v13;
    if (v13)
    {
      int v14 = *a2;
      int v15 = *a3;
      *(unsigned char *)(v13 + 13) = 0;
      *(void *)uint64_t v13 = v13 + 13;
      *(_DWORD *)(v13 + 8) = 40;
      *(unsigned char *)(v13 + 12) = 0;
      *(_DWORD *)(v13 + 56) = 0;
      icu::CharString::append((icu::CharString *)v13, v14, v15, a4);
    }
    uint64_t v16 = *a1;
    *a1 = v16 + 1;
    *(void *)(*((void *)a1 + 1) + 8 * v16) = v11;
    return v11;
  }
  if (v8 == 8) {
    int v9 = 32;
  }
  else {
    int v9 = 2 * v8;
  }
  if (v9 < 1) {
    return 0;
  }
  int v10 = uprv_malloc(8 * v9);
  uint64_t v11 = (uint64_t)v10;
  if (v10)
  {
    if (v8 >= 1)
    {
      int v12 = a1[4];
      if (v12 >= v8) {
        int v12 = v8;
      }
      if (v12 >= v9) {
        int v12 = v9;
      }
      memcpy(v10, *((const void **)a1 + 1), 8 * v12);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free(*((void **)a1 + 1));
    }
    *((void *)a1 + 1) = v11;
    a1[4] = v9;
    *((unsigned char *)a1 + 20) = 1;
    goto LABEL_16;
  }
  return v11;
}

void *sub_18C8890D4(const void **a1, unint64_t a2)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (*(_DWORD *)a1 == v3)
  {
    if (v3 == 8) {
      int v4 = 32;
    }
    else {
      int v4 = 2 * v3;
    }
    if (v4 < 1) {
      return 0;
    }
    BOOL result = uprv_malloc(8 * v4);
    if (!result) {
      return result;
    }
    int v6 = result;
    if (v3 >= 1)
    {
      int v7 = *((_DWORD *)a1 + 4);
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7 >= v4) {
        int v7 = v4;
      }
      memcpy(result, a1[1], 8 * v7);
    }
    if (*((unsigned char *)a1 + 20)) {
      uprv_free((void *)a1[1]);
    }
    a1[1] = v6;
    *((_DWORD *)a1 + 4) = v4;
    *((unsigned char *)a1 + 20) = 1;
  }
  BOOL result = (void *)icu::UMemory::operator new((icu::UMemory *)0x18, a2);
  if (result)
  {
    *BOOL result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  uint64_t v8 = *(int *)a1;
  *(_DWORD *)a1 = v8 + 1;
  *((void *)a1[1] + v8) = result;
  return result;
}

uint64_t sub_18C8891B0(const char ***a1, uint64_t a2, int a3)
{
  uint64_t v5 = *a1;
  if (*a1)
  {
    int v7 = 0;
    uint64_t v8 = *(const char **)a2;
    while (1)
    {
      int v9 = v7;
      int v7 = v5;
      if (a3)
      {
        int v10 = strlen(v8);
        uint64_t v11 = *v7;
        uint64_t v12 = strlen(*v7);
        if (v10 == 1 && v12 == 1)
        {
          int v13 = *(unsigned __int8 *)v8;
          int v14 = *(unsigned __int8 *)v11;
          if (v13 == v14) {
            return 0;
          }
          if ((char)v13 == 120) {
            goto LABEL_20;
          }
          if ((char)v14 == 120) {
            goto LABEL_24;
          }
          int v15 = (char)v13 - (char)v14;
        }
        else if (v10 == 1)
        {
          int v15 = *v8 - 117;
        }
        else if (v12 == 1)
        {
          int v15 = 117 - *v11;
        }
        else
        {
          uint64_t result = strcmp(v8, v11);
          if (!result) {
            return result;
          }
          int v15 = result;
          if (!strcmp(v11, "attribute")) {
            goto LABEL_20;
          }
          if (!strcmp(v8, "attribute")) {
            goto LABEL_24;
          }
        }
      }
      else
      {
        int v15 = strcmp(v8, *v5);
      }
      if (v15 < 0)
      {
LABEL_24:
        int v17 = (const char ***)(v9 + 2);
        if (!v9) {
          int v17 = a1;
        }
        *int v17 = (const char **)a2;
        *(void *)(a2 + 16) = v7;
        return 1;
      }
      if (!v15) {
        return 0;
      }
LABEL_20:
      uint64_t v5 = (const char **)v7[2];
      if (!v5)
      {
        _DWORD v7[2] = (const char *)a2;
        *(void *)(a2 + 16) = 0;
        return 1;
      }
    }
  }
  *(void *)(a2 + 16) = 0;
  *a1 = (const char **)a2;
  return 1;
}

uint64_t *sub_18C889338(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uprv_free(*(void **)v2);
    int v3 = *(void **)(v2 + 56);
    if (v3)
    {
      do
      {
        int v4 = (void *)v3[1];
        uprv_free(v3);
        int v3 = v4;
      }
      while (v4);
    }
    uint64_t v5 = *(void **)(v2 + 64);
    if (v5)
    {
      do
      {
        int v6 = (void *)v5[2];
        uprv_free(v5);
        uint64_t v5 = v6;
      }
      while (v6);
    }
    uprv_free((void *)v2);
  }
  return a1;
}

icu::Locale *ulocale_openForLocaleID(char *__s, int a2, UErrorCode *a3)
{
  uint64_t v5 = __s;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  memset(&v12[1], 0, 48);
  if (a2 < 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v9, __s);
    uint64_t v5 = v9;
  }
  else
  {
    int v9 = __s;
    int v10 = a2;
  }
  v12[0] = (char *)&v12[1] + 5;
  LODWORD(v12[1]) = 40;
  WORD2(v12[1]) = 0;
  LODWORD(v13) = 0;
  icu::CharString::append((icu::CharString *)v12, v5, v10, a3);
  if (*(int *)a3 <= 0)
  {
    icu::Locale::createFromName((icu::Locale *)v12[0], (uint64_t)v11);
    int v6 = icu::Locale::clone((icu::Locale *)v11, v7);
    icu::Locale::~Locale((icu::Locale *)v11);
  }
  else
  {
    int v6 = 0;
  }
  if (BYTE4(v12[1])) {
    uprv_free(v12[0]);
  }
  return v6;
}

icu::Locale *ulocale_openForLanguageTag(char *__s, int a2, int *a3)
{
  int v4 = __s;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  memset(v10, 0, sizeof(v10));
  if (a2 < 0)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v8, __s);
    int v4 = v8;
  }
  else
  {
    uint64_t v8 = __s;
    LODWORD(v9) = a2;
  }
  icu::Locale::forLanguageTag(v4, v9, a3, (uint64_t)v10);
  if (*a3 <= 0) {
    int v6 = icu::Locale::clone((icu::Locale *)v10, v5);
  }
  else {
    int v6 = 0;
  }
  icu::Locale::~Locale((icu::Locale *)v10);
  return v6;
}

uint64_t ulocale_close(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t ulocale_getLanguage(uint64_t a1)
{
  if (a1) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t ulocale_getScript(uint64_t a1)
{
  if (a1) {
    return a1 + 20;
  }
  else {
    return 0;
  }
}

uint64_t ulocale_getRegion(uint64_t a1)
{
  if (a1) {
    return a1 + 26;
  }
  else {
    return 0;
  }
}

uint64_t ulocale_getVariant(uint64_t result)
{
  if (result) {
    return *(void *)(result + 208) + *(int *)(result + 32);
  }
  return result;
}

uint64_t ulocale_getLocaleID(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

icu::Locale *ulocale_getBaseName(icu::Locale *result)
{
  if (result) {
    return (icu::Locale *)icu::Locale::getBaseName(result);
  }
  return result;
}

uint64_t ulocale_getKeywordValue(uint64_t a1, const char *a2, int a3, char *a4, int a5, UErrorCode *a6)
{
  if (*(int *)a6 > 0) {
    return 0;
  }
  uint64_t v6 = a1;
  if (a1)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v15, a4, a5);
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v13, a2);
      a2 = v13;
    }
    else
    {
      uint64_t v13 = a2;
      LODWORD(v14) = a3;
    }
    icu::Locale::getKeywordValue(v6, a2, v14, (uint64_t)&v15, a6);
    uint64_t v6 = DWORD2(v16);
    if (*(int *)a6 <= 0)
    {
      if (BYTE12(v16)) {
        *a6 = U_BUFFER_OVERFLOW_ERROR;
      }
      else {
        u_terminateChars((uint64_t)a4, a5, DWORD2(v16), (int *)a6);
      }
    }
    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v15);
  }
  else
  {
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v6;
}

uint64_t ulocale_getUnicodeKeywordValue(uint64_t a1, const char *a2, int a3, char *a4, int a5, UErrorCode *a6)
{
  if (*(int *)a6 > 0) {
    return 0;
  }
  uint64_t v6 = a1;
  if (a1)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v15, a4, a5);
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v13, a2);
      a2 = v13;
    }
    else
    {
      uint64_t v13 = a2;
      LODWORD(v14) = a3;
    }
    icu::Locale::getUnicodeKeywordValue(v6, a2, v14, (uint64_t)&v15, a6);
    uint64_t v6 = DWORD2(v16);
    if (*(int *)a6 <= 0)
    {
      if (BYTE12(v16)) {
        *a6 = U_BUFFER_OVERFLOW_ERROR;
      }
      else {
        u_terminateChars((uint64_t)a4, a5, DWORD2(v16), (int *)a6);
      }
    }
    icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v15);
  }
  else
  {
    *a6 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v6;
}

_OWORD *ulocale_getKeywords(icu::Locale *a1, UErrorCode *a2)
{
  if (*(int *)a2 > 0) {
    return 0;
  }
  if (!a1)
  {
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  Keywords = icu::Locale::createKeywords(a1, a2);

  return uenum_openFromStringEnumeration((uint64_t)Keywords, (int *)a2);
}

_OWORD *ulocale_getUnicodeKeywords(icu::Locale *a1, UErrorCode *a2)
{
  if (*(int *)a2 > 0) {
    return 0;
  }
  if (!a1)
  {
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  UnicodeKeywords = icu::Locale::createUnicodeKeywords(a1, a2);

  return uenum_openFromStringEnumeration((uint64_t)UnicodeKeywords, (int *)a2);
}

BOOL ulocale_isBogus(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 216) != 0;
  }
  return result;
}

uint64_t *ulocbld_open@<X0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t result = icu::UMemory::operator new(a2, (icu::UMemory *)0x30, a1);
  if (result) {
    return icu::LocaleBuilder::LocaleBuilder(result);
  }
  return result;
}

uint64_t ulocbld_close(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void ulocbld_setLocale(icu::LocaleBuilder *a1, const char *a2, unsigned int a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    memset(v9, 0, 224);
    icu::Locale::Locale((icu::Locale *)v9);
    if ((a3 & 0x80000000) != 0 || !a2[a3])
    {
      uint64_t v6 = a2;
    }
    else
    {
      if (a3 >= 0x9D)
      {
        icu::Locale::setToBogus((icu::Locale *)v9);
LABEL_9:
        icu::LocaleBuilder::setLocale(a1, (const icu::Locale *)v9);
        icu::Locale::~Locale((icu::Locale *)v9);
        return;
      }
      bzero(&__dst[a3], 157 - a3);
      memcpy(__dst, a2, a3);
      __dst[a3] = 0;
      uint64_t v6 = __dst;
    }
    icu::Locale::Locale((icu::Locale *)v8, v6, 0, 0, 0);
    icu::Locale::operator=((uint64_t)v9, (uint64_t)v8);
    icu::Locale::~Locale((icu::Locale *)v8);
    goto LABEL_9;
  }
}

icu::LocaleBuilder *ulocbld_adoptULocale(icu::LocaleBuilder *result, const icu::Locale *a2)
{
  if (result)
  {
    icu::LocaleBuilder::setLocale(result, a2);
    return (icu::LocaleBuilder *)ulocale_close((uint64_t)a2);
  }
  return result;
}

int *ulocbld_setLanguageTag(int *result, char *a2, int a3)
{
  if (result)
  {
    int v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setLanguageTag(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setLanguage(uint64_t result, char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setLanguage(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setScript(uint64_t result, char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setScript(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setRegion(uint64_t result, char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setRegion(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setVariant(uint64_t result, const char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::setVariant(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_addUnicodeLocaleAttribute(uint64_t result, const char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::addUnicodeLocaleAttribute(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_removeUnicodeLocaleAttribute(uint64_t result, const char *a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
      a2 = v4;
    }
    else
    {
      int v4 = a2;
      LODWORD(v5) = a3;
    }
    return icu::LocaleBuilder::removeUnicodeLocaleAttribute(v3, a2, v5);
  }
  return result;
}

uint64_t ulocbld_setExtension(uint64_t result, int a2, char *__s, int a4)
{
  if (result)
  {
    uint64_t v5 = result;
    if (a4 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v6, __s);
      __s = v6;
    }
    else
    {
      uint64_t v6 = __s;
      LODWORD(v7) = a4;
    }
    return icu::LocaleBuilder::setExtension(v5, a2, __s, v7);
  }
  return result;
}

uint64_t ulocbld_setUnicodeLocaleKeyword(uint64_t result, const char *a2, int a3, char *__s, int a5)
{
  if (result)
  {
    uint64_t v7 = result;
    if (a3 < 0)
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v10, a2);
      if ((a5 & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v10 = (char *)a2;
      LODWORD(v11) = a3;
      if ((a5 & 0x80000000) == 0)
      {
LABEL_4:
        uint64_t v8 = __s;
        LODWORD(v9) = a5;
        return icu::LocaleBuilder::setUnicodeLocaleKeyword(v7, v10, v11, __s, v9);
      }
    }
    icu::StringPiece::StringPiece((icu::StringPiece *)&v8, __s);
    __s = v8;
    return icu::LocaleBuilder::setUnicodeLocaleKeyword(v7, v10, v11, __s, v9);
  }
  return result;
}

icu::LocaleBuilder *ulocbld_clear(icu::LocaleBuilder *this)
{
  if (this) {
    return icu::LocaleBuilder::clear(this);
  }
  return this;
}

icu::LocaleBuilder *ulocbld_clearExtensions(icu::LocaleBuilder *this)
{
  if (this) {
    return icu::LocaleBuilder::clearExtensions(this);
  }
  return this;
}

icu::Locale *ulocbld_buildULocale(icu::LocaleBuilder *a1, UErrorCode *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    memset(v6, 0, sizeof(v6));
    icu::LocaleBuilder::build(a1, a2, (icu::Locale *)v6);
    if (*(int *)a2 <= 0)
    {
      int v4 = icu::Locale::clone((icu::Locale *)v6, v3);
      if (!v4) {
        *a2 = U_MEMORY_ALLOCATION_ERROR;
      }
    }
    else
    {
      int v4 = 0;
    }
    icu::Locale::~Locale((icu::Locale *)v6);
  }
  else
  {
    int v4 = 0;
    *a2 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v4;
}

uint64_t ulocbld_buildLocaleID(icu::LocaleBuilder *a1, void *a2, int a3, UErrorCode *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    *(_OWORD *)__s = 0u;
    long long v13 = 0u;
    memset(v11, 0, sizeof(v11));
    icu::LocaleBuilder::build(a1, a4, (icu::Locale *)v11);
    if (*(int *)a4 <= 0)
    {
      size_t v8 = strlen(__s[1]);
      uint64_t v9 = v8;
      if ((int)v8 >= 1 && (int)v8 <= a3) {
        memcpy(a2, __s[1], v8);
      }
      uint64_t v7 = u_terminateChars((uint64_t)a2, a3, v9, (int *)a4);
    }
    else
    {
      uint64_t v7 = 0;
    }
    icu::Locale::~Locale((icu::Locale *)v11);
  }
  else
  {
    uint64_t v7 = 0;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v7;
}

uint64_t ulocbld_buildLanguageTag(icu::LocaleBuilder *a1, char *a2, int a3, UErrorCode *a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    memset(v11, 0, sizeof(v11));
    icu::LocaleBuilder::build(a1, a4, (icu::Locale *)v11);
    if (*(int *)a4 <= 0)
    {
      long long v9 = 0u;
      long long v10 = 0u;
      icu::CheckedArrayByteSink::CheckedArrayByteSink((uint64_t)&v9, a2, a3);
      icu::Locale::toLanguageTag((char **)v11, (icu::ByteSink *)&v9, a4);
      uint64_t v7 = DWORD2(v10);
      if (*(int *)a4 <= 0)
      {
        if (BYTE12(v10)) {
          *a4 = U_BUFFER_OVERFLOW_ERROR;
        }
        else {
          u_terminateChars((uint64_t)a2, a3, DWORD2(v10), (int *)a4);
        }
      }
      icu::CheckedArrayByteSink::~CheckedArrayByteSink((icu::CheckedArrayByteSink *)&v9);
    }
    else
    {
      uint64_t v7 = 0;
    }
    icu::Locale::~Locale((icu::Locale *)v11);
  }
  else
  {
    uint64_t v7 = 0;
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v7;
}

BOOL ulocbld_copyErrorTo(icu::LocaleBuilder *a1, UErrorCode *a2)
{
  if (a1) {
    return icu::LocaleBuilder::copyErrorTo(a1, a2);
  }
  *a2 = U_ILLEGAL_ARGUMENT_ERROR;
  return 1;
}

void *ulocdata_open(char *a1, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  uint64_t v6 = uprv_malloc(0x18uLL);
  uint64_t v2 = v6;
  if (!v6)
  {
    *a2 = 7;
    return v2;
  }
  long long v6[2] = 0;
  *(unsigned char *)uint64_t v6 = 0;
  v6[1] = ures_open(0, a1, a2);
  int v7 = *a2;
  if (*a2 >= 1)
  {
    uprv_free(v2);
    return 0;
  }
  v2[2] = ures_open("icudt74l-lang", a1, a2);
  if (*a2 == 2) {
    *a2 = v7;
  }
  return v2;
}

void ulocdata_close(uint64_t *a1)
{
  if (a1)
  {
    ures_close(a1[2]);
    ures_close(a1[1]);
    uprv_free(a1);
  }
}

unsigned char *ulocdata_setNoSubstitute(unsigned char *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t ulocdata_getNoSubstitute(char *a1)
{
  return *a1;
}

icu::UnicodeSet *ulocdata_getExemplarSet(uint64_t a1, icu::UnicodeSet *a2, int a3, int a4, UErrorCode *a5)
{
  uint64_t v12 = 0;
  if (*(int *)a5 > 0) {
    return 0;
  }
  StringByKey = ures_getStringByKey(*(void *)(a1 + 8), off_1E5508730[a4], (int *)&v12 + 1, (int *)&v12);
  int v10 = v12;
  if (v12 == -127)
  {
    if (*(unsigned char *)a1)
    {
      int v10 = 2;
      LODWORD(v12) = 2;
    }
    else
    {
      int v10 = -127;
    }
  }
  else if (!v12)
  {
    int v10 = *a5;
    goto LABEL_9;
  }
  *a5 = v10;
LABEL_9:
  if (v10 > 0) {
    return 0;
  }
  if (!a2) {
    return uset_openPatternOptions((uint64_t)StringByKey, SHIDWORD(v12), a3 | 1u, a5);
  }
  uset_applyPattern(a2, (uint64_t)StringByKey, HIDWORD(v12), a3 | 1, a5);
  return a2;
}

uint64_t ulocdata_getDelimiter(uint64_t a1, int a2, UChar *a3, int32_t a4, int *a5)
{
  uint64_t result = 0;
  uint64_t v16 = 0;
  if (*a5 <= 0)
  {
    uint64_t v11 = ures_getByKey(*(void *)(a1 + 8), "delimiters", 0, (int *)&v16);
    uint64_t v12 = v11;
    int v13 = v16;
    if (v16 == -127)
    {
      if (*(unsigned char *)a1)
      {
        int v13 = 2;
        LODWORD(v16) = 2;
      }
      else
      {
        int v13 = -127;
      }
    }
    else if (!v16)
    {
      int v13 = *a5;
      goto LABEL_9;
    }
    *a5 = v13;
LABEL_9:
    if (v13 >= 1)
    {
      ures_close(v11);
      return 0;
    }
    StringByKeyWithFallbacsize_t k = ures_getStringByKeyWithFallback(v11, off_1E5508750[a2], (int *)&v16 + 1, (UErrorCode *)&v16);
    ures_close(v12);
    int v15 = v16;
    if (v16 == -127)
    {
      if (*(unsigned char *)a1)
      {
        int v15 = 2;
        LODWORD(v16) = 2;
      }
      else
      {
        int v15 = -127;
      }
    }
    else if (!v16)
    {
      int v15 = *a5;
      goto LABEL_18;
    }
    *a5 = v15;
LABEL_18:
    if (v15 <= 0)
    {
      u_strncpy(a3, StringByKeyWithFallback, a4);
      return HIDWORD(v16);
    }
    return 0;
  }
  return result;
}

uint64_t ulocdata_getMeasurementSystem(char *a1, int *a2)
{
  if (!a2) {
    return 3;
  }
  uint64_t v3 = 3;
  if (*a2 <= 0)
  {
    uint64_t v4 = sub_18C88A520(a1, "MeasurementSystem", a2);
    unsigned int Int = ures_getInt(v4, a2);
    if (*a2 <= 0) {
      uint64_t v3 = Int;
    }
    else {
      uint64_t v3 = 3;
    }
    ures_close(v4);
  }
  return v3;
}

uint64_t sub_18C88A520(char *a1, const char *a2, int *a3)
{
  int v11 = 0;
  ulocimp_getRegionForSupplementalData(a1, 1, (char *)&v11, 4, a3);
  uint64_t v5 = ures_openDirect(0, (uint64_t)"supplementalData", (uint64_t)a3);
  ures_getByKey(v5, "measurementData", v5, a3);
  if (v5)
  {
    uint64_t v6 = ures_getByKey(v5, (const char *)&v11, 0, a3);
    uint64_t v7 = v6;
    int v8 = *a3;
    if (*a3 <= 0)
    {
      uint64_t v9 = ures_getByKey(v6, a2, 0, a3);
      int v8 = *a3;
    }
    else
    {
      uint64_t v9 = 0;
    }
    if (v8 == 2)
    {
      *a3 = 0;
      if (v7) {
        ures_close(v7);
      }
      uint64_t v7 = ures_getByKey(v5, "001", 0, a3);
      uint64_t v9 = ures_getByKey(v7, a2, 0, a3);
    }
    ures_close(v7);
  }
  else
  {
    uint64_t v9 = 0;
  }
  ures_close(v5);
  return v9;
}

void ulocdata_getPaperSize(char *a1, int *a2, _DWORD *a3, int *a4)
{
  int v9 = 0;
  if (a4 && *a4 <= 0)
  {
    uint64_t v7 = sub_18C88A520(a1, "PaperSize", a4);
    IntVector = ures_getIntVector(v7, &v9, a4);
    if (*a4 <= 0)
    {
      if (v9 > 1)
      {
        *a2 = *IntVector;
        *a3 = IntVector[1];
      }
      else
      {
        *a4 = 5;
      }
    }
    ures_close(v7);
  }
}

void ulocdata_getCLDRVersion(uint8_t *a1, int *a2)
{
  uint64_t v4 = ures_openDirect(0, (uint64_t)"supplementalData", (uint64_t)a2);
  ures_getVersionByKey(v4, "cldrVersion", a1, a2);

  ures_close(v4);
}

uint64_t ulocdata_getLocaleDisplayPattern(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t result = 0;
  uint64_t v14 = 0;
  if (*a4 <= 0)
  {
    uint64_t result = *(void *)(a1 + 16);
    if (!result)
    {
      *a4 = 2;
      return result;
    }
    uint64_t v9 = ures_getByKey(result, "localeDisplayPattern", 0, (int *)&v14);
    uint64_t v10 = v9;
    int v11 = v14;
    if (v14 == -127)
    {
      if (*(unsigned char *)a1)
      {
        int v11 = 2;
        LODWORD(v14) = 2;
      }
      else
      {
        int v11 = -127;
      }
    }
    else if (!v14)
    {
      int v11 = *a4;
      goto LABEL_11;
    }
    *a4 = v11;
LABEL_11:
    if (v11 >= 1)
    {
      ures_close(v9);
      return 0;
    }
    StringByKey = ures_getStringByKey(v9, "pattern", (int *)&v14 + 1, (int *)&v14);
    ures_close(v10);
    int v13 = v14;
    if (v14 == -127)
    {
      if (*(unsigned char *)a1)
      {
        int v13 = 2;
        LODWORD(v14) = 2;
      }
      else
      {
        int v13 = -127;
      }
    }
    else if (!v14)
    {
      int v13 = *a4;
      goto LABEL_20;
    }
    *a4 = v13;
LABEL_20:
    if (v13 <= 0)
    {
      u_strncpy(a2, StringByKey, a3);
      return HIDWORD(v14);
    }
    return 0;
  }
  return result;
}

uint64_t ulocdata_getLocaleSeparator(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t result = 0;
  uint64_t v17 = 0;
  if (*a4 > 0) {
    return result;
  }
  uint64_t result = *(void *)(a1 + 16);
  if (!result)
  {
    *a4 = 2;
    return result;
  }
  uint64_t v9 = ures_getByKey(result, "localeDisplayPattern", 0, (int *)&v17);
  uint64_t v10 = v9;
  int v11 = v17;
  if (v17 == -127)
  {
    if (*(unsigned char *)a1)
    {
      int v11 = 2;
      LODWORD(v17) = 2;
    }
    else
    {
      int v11 = -127;
    }
  }
  else if (!v17)
  {
    int v11 = *a4;
    goto LABEL_11;
  }
  *a4 = v11;
LABEL_11:
  if (v11 >= 1)
  {
    ures_close(v9);
    return 0;
  }
  StringByKey = ures_getStringByKey(v9, "separator", (int *)&v17 + 1, (int *)&v17);
  ures_close(v10);
  int v13 = v17;
  if (v17 == -127)
  {
    if (*(unsigned char *)a1)
    {
      int v13 = 2;
      LODWORD(v17) = 2;
    }
    else
    {
      int v13 = -127;
    }
    goto LABEL_19;
  }
  if (v17)
  {
LABEL_19:
    *a4 = v13;
    goto LABEL_20;
  }
  int v13 = *a4;
LABEL_20:
  if (v13 > 0) {
    return 0;
  }
  uint64_t v14 = u_strstr(StringByKey, (const UChar *)"{");
  int v15 = u_strstr(StringByKey, (const UChar *)"{");
  if (v14
    && v15
    && v14 <= v15
    && (StringByKey = v14 + 3,
        unint64_t v16 = (unint64_t)((char *)v15 - (char *)(v14 + 3)) >> 1,
        HIDWORD(v17) = v16,
        (int)v16 < a3))
  {
    u_strncpy(a2, v14 + 3, v16);
    uint64_t result = SHIDWORD(v17);
    a2[SHIDWORD(v17)] = 0;
  }
  else
  {
    u_strncpy(a2, StringByKey, a3);
    return HIDWORD(v17);
  }
  return result;
}

uint64_t uprv_mapFile(void *a1, const char *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  memset(&v12, 0, sizeof(v12));
  sub_18C87BA40((uint64_t)a1);
  uint64_t v3 = 0;
  if (!stat(a2, &v12))
  {
    int st_size = v12.st_size;
    if (v12.st_size >= 1)
    {
      int v8 = open(a2, 0, *(_OWORD *)&v12.st_dev, *(_OWORD *)&v12.st_uid, *(_OWORD *)&v12.st_atimespec, *(_OWORD *)&v12.st_mtimespec, *(_OWORD *)&v12.st_ctimespec, *(_OWORD *)&v12.st_birthtimespec);
      if (v8 != -1)
      {
        int v9 = v8;
        size_t v10 = st_size;
        int v11 = (char *)mmap(0, st_size, 1, 1, v8, 0);
        close(v9);
        if (v11 != (char *)-1)
        {
          a1[1] = v11;
          a1[4] = v11;
          a1[5] = &v11[v10];
          uint64_t v3 = 1;
          posix_madvise(v11, v10, 1);
          return v3;
        }
      }
      return 0;
    }
  }
  return v3;
}

uint64_t sub_18C88AB4C(uint64_t result)
{
  if (result)
  {
    int v1 = (void *)result;
    uint64_t v2 = *(void *)(result + 40);
    if (v2)
    {
      uint64_t result = munmap(*(void **)(result + 32), v2 - *(void *)(result + 32));
      v1[1] = 0;
      v1[4] = 0;
      v1[5] = 0;
    }
  }
  return result;
}

uint64_t uprv_max(uint64_t result, int a2)
{
  if ((int)result <= a2) {
    return a2;
  }
  else {
    return result;
  }
}

uint64_t uprv_min(uint64_t result, int a2)
{
  if ((int)result >= a2) {
    return a2;
  }
  else {
    return result;
  }
}

void **umutablecptrie_open(int a1, unint64_t a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  int v5 = a2;
  uint64_t v7 = icu::UMemory::operator new((icu::UMemory *)0x11040, a2);
  if (!v7)
  {
    if (*a3 <= 0)
    {
      uint64_t result = 0;
      *a3 = 7;
      return result;
    }
    return 0;
  }
  uint64_t result = (void **)sub_18C88AC38(v7, a1, v5, a3);
  if (*a3 >= 1)
  {
    int v8 = sub_18C88AE68(result);
    icu::UMemory::operator delete(v8);
    return 0;
  }
  return result;
}

uint64_t sub_18C88AC38(uint64_t a1, int a2, int a3, int *a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0xFFFFFFFF00000000;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = -1;
  *(_DWORD *)(a1 + 36) = a2;
  *(_DWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 44) = a3;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = a2;
  *(void *)(a1 + 56) = 0;
  if (*a4 <= 0)
  {
    *(void *)a1 = uprv_malloc(0x4000uLL);
    uint64_t v6 = uprv_malloc(0x10000uLL);
    *(void *)(a1 + 16) = v6;
    if (*(void *)a1 && v6)
    {
      *(_DWORD *)(a1 + 8) = 4096;
      *(_DWORD *)(a1 + 24) = 0x4000;
    }
    else
    {
      *a4 = 7;
    }
  }
  return a1;
}

uint64_t *umutablecptrie_clone(uint64_t a1, int *a2)
{
  uint64_t v2 = 0;
  if (a1)
  {
    uint64_t v4 = (uint64_t *)*a2;
    if ((int)v4 <= 0)
    {
      uint64_t v6 = icu::UMemory::operator new(v4, (icu::UMemory *)0x11040, (unint64_t)a2);
      if (v6)
      {
        uint64_t v2 = v6;
        *uint64_t v6 = 0;
        int v7 = *(_DWORD *)(a1 + 12);
        *((_DWORD *)v6 + 2) = 0;
        *((_DWORD *)v6 + 3) = v7;
        long long v6[2] = 0;
        _OWORD v6[3] = 0;
        *((_OWORD *)v6 + 2) = *(_OWORD *)(a1 + 32);
        uint64_t v8 = *(void *)(a1 + 48);
        v6[6] = v8;
        v6[7] = 0;
        if (*a2 <= 0)
        {
          if ((int)v8 > 0x10000) {
            int v9 = 69632;
          }
          else {
            int v9 = 4096;
          }
          *uint64_t v6 = (uint64_t)uprv_malloc((4 * v9));
          size_t v10 = uprv_malloc(4 * *(int *)(a1 + 24));
          v2[2] = (uint64_t)v10;
          int v11 = (void *)*v2;
          if (*v2 && v10)
          {
            *((_DWORD *)v2 + 2) = v9;
            *((_DWORD *)v2 + 6) = *(_DWORD *)(a1 + 24);
            int v12 = *((_DWORD *)v2 + 12);
            int v13 = v12 >> 4;
            memcpy(v2 + 8, (const void *)(a1 + 64), (uint64_t)v12 >> 4);
            memcpy(v11, *(const void **)a1, 4 * v13);
            memcpy((void *)v2[2], *(const void **)(a1 + 16), 4 * *(int *)(a1 + 28));
            *((_DWORD *)v2 + 7) = *(_DWORD *)(a1 + 28);
            if (*a2 < 1) {
              return v2;
            }
          }
          else
          {
            *a2 = 7;
          }
        }
        uint64_t v14 = sub_18C88AE68((void **)v2);
        icu::UMemory::operator delete(v14);
        return 0;
      }
      if (*a2 > 0) {
        return 0;
      }
      uint64_t v2 = 0;
      *a2 = 7;
    }
  }
  return v2;
}

void umutablecptrie_close(void **a1)
{
  if (a1)
  {
    int v1 = sub_18C88AE68(a1);
    icu::UMemory::operator delete(v1);
  }
}

void **sub_18C88AE68(void **a1)
{
  return a1;
}

void **umutablecptrie_fromUCPMap(UCPMap *map, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  if (!map)
  {
    uint64_t v2 = 0;
    int v15 = 1;
    goto LABEL_19;
  }
  uint32_t v6 = ucpmap_get(map, -1);
  uint32_t v7 = ucpmap_get(map, 1114111);
  size_t v10 = icu::UMemory::operator new(v9, (icu::UMemory *)0x11040, v8);
  if (!v10)
  {
    if (*a2 > 0) {
      return 0;
    }
    uint64_t v2 = 0;
    int v15 = 7;
LABEL_19:
    *a2 = v15;
    return v2;
  }
  uint64_t v2 = (void **)v10;
  sub_18C88AC38((uint64_t)v10, v7, v6, a2);
  if (*a2 > 0) {
    goto LABEL_15;
  }
  uint32_t pValue = 0;
  UChar32 Range = ucpmap_getRange(map, 0, UCPMAP_RANGE_NORMAL, 0, 0, 0, &pValue);
  if ((Range & 0x80000000) == 0)
  {
    UChar32 v12 = Range;
    unsigned int v13 = 0;
    do
    {
      if (pValue != v7)
      {
        if (v13 == v12) {
          sub_18C88B520((uint64_t)v2, v12, pValue, a2);
        }
        else {
          sub_18C88B5BC((uint64_t)v2, v13, v12, pValue, a2);
        }
      }
      unsigned int v13 = v12 + 1;
      UChar32 v12 = ucpmap_getRange(map, v12 + 1, UCPMAP_RANGE_NORMAL, 0, 0, 0, &pValue);
    }
    while ((v12 & 0x80000000) == 0);
  }
  if (*a2 >= 1)
  {
LABEL_15:
    uint64_t v14 = sub_18C88AE68(v2);
    icu::UMemory::operator delete(v14);
    return 0;
  }
  return v2;
}

void **umutablecptrie_fromUCPTrie(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  if (!a1) {
    goto LABEL_8;
  }
  int v5 = *(char *)(a1 + 31);
  if (v5 == 2)
  {
    uint32_t v6 = (uint64_t *)(*(int *)(a1 + 20) + *(void *)(a1 + 8));
    int v8 = *((unsigned __int8 *)v6 - 1);
    int v9 = *((unsigned __int8 *)v6 - 2);
  }
  else
  {
    if (v5 != 1)
    {
      if (!*(unsigned char *)(a1 + 31))
      {
        uint32_t v6 = *(uint64_t **)(a1 + 8);
        int v7 = *(_DWORD *)(a1 + 20);
        int v8 = *((unsigned __int16 *)v6 + v7 - 1);
        int v9 = *((unsigned __int16 *)v6 + v7 - 2);
        goto LABEL_13;
      }
LABEL_8:
      uint64_t v2 = 0;
      int v10 = 1;
      goto LABEL_9;
    }
    uint32_t v6 = *(uint64_t **)(a1 + 8);
    int v12 = *(_DWORD *)(a1 + 20);
    int v8 = *((_DWORD *)v6 + v12 - 1);
    int v9 = *((_DWORD *)v6 + v12 - 2);
  }
LABEL_13:
  unsigned int v13 = icu::UMemory::operator new(v6, (icu::UMemory *)0x11040, (unint64_t)a2);
  if (!v13)
  {
    if (*a2 > 0) {
      return 0;
    }
    uint64_t v2 = 0;
    int v10 = 7;
LABEL_9:
    *a2 = v10;
    return v2;
  }
  uint64_t v2 = (void **)v13;
  sub_18C88AC38((uint64_t)v13, v9, v8, a2);
  if (*a2 > 0) {
    goto LABEL_23;
  }
  unsigned int v18 = 0;
  unsigned int Range = ucptrie_getRange(a1, 0, 0, 0, 0, 0, (int *)&v18);
  if ((Range & 0x80000000) == 0)
  {
    unsigned int v15 = Range;
    unsigned int v16 = 0;
    do
    {
      if (v18 != v9)
      {
        if (v16 == v15) {
          sub_18C88B520((uint64_t)v2, v15, v18, a2);
        }
        else {
          sub_18C88B5BC((uint64_t)v2, v16, v15, v18, a2);
        }
      }
      unsigned int v16 = v15 + 1;
      unsigned int v15 = ucptrie_getRange(a1, v15 + 1, 0, 0, 0, 0, (int *)&v18);
    }
    while ((v15 & 0x80000000) == 0);
  }
  if (*a2 >= 1)
  {
LABEL_23:
    uint64_t v17 = sub_18C88AE68(v2);
    icu::UMemory::operator delete(v17);
    return 0;
  }
  return v2;
}

uint64_t umutablecptrie_get(uint64_t a1, unsigned int a2)
{
  if (a2 < 0x110000)
  {
    if (*(_DWORD *)(a1 + 48) <= (signed int)a2)
    {
      uint64_t v2 = (unsigned int *)(a1 + 52);
    }
    else
    {
      uint64_t v3 = a2 >> 4;
      if (*(unsigned char *)(a1 + v3 + 64)) {
        uint64_t v2 = (unsigned int *)(*(void *)(a1 + 16) + 4 * (*(_DWORD *)(*(void *)a1 + 4 * v3) + (a2 & 0xF)));
      }
      else {
        uint64_t v2 = (unsigned int *)(*(void *)a1 + 4 * v3);
      }
    }
  }
  else
  {
    uint64_t v2 = (unsigned int *)(a1 + 44);
  }
  return *v2;
}

uint64_t umutablecptrie_getRange(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, int *a7)
{
  return sub_18C875E1C((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, int *))sub_18C88B278, a1, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_18C88B278(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, _DWORD *a5)
{
  if (WORD1(a2) > 0x10u) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = a2;
  uint64_t v5 = 1114111;
  if (*(_DWORD *)(a1 + 48) <= (int)a2)
  {
    if (a5)
    {
      uint64_t v30 = *(unsigned int *)(a1 + 52);
      if (a3) {
        LODWORD(v30) = a3(a4, v30);
      }
      *a5 = v30;
    }
    return v5;
  }
  int v11 = *(_DWORD *)(a1 + 40);
  if (a3) {
    int v11 = a3(a4, *(unsigned int *)(a1 + 40));
  }
  uint64_t v12 = 0;
  int v13 = 0;
  char v14 = 0;
  uint64_t v15 = v9 >> 4;
  while (1)
  {
    uint64_t v16 = *(unsigned int *)(*(void *)a1 + 4 * v15);
    if (!*(unsigned char *)(a1 + v15 + 64))
    {
      if (v14)
      {
        if (v16 == v12)
        {
          uint64_t v16 = v12;
        }
        else
        {
          if (!a3) {
            return (v9 - 1);
          }
          int v26 = v11;
          if (v16 != *(_DWORD *)(a1 + 40)) {
            int v26 = a3(a4, *(unsigned int *)(*(void *)a1 + 4 * v15));
          }
          if (v26 != v13) {
            return (v9 - 1);
          }
        }
      }
      else
      {
        int v20 = *(_DWORD *)(a1 + 40);
        if (v16 == v20) {
          int v13 = v11;
        }
        else {
          int v13 = *(_DWORD *)(*(void *)a1 + 4 * v15);
        }
        if (a3 && v16 != v20) {
          int v13 = a3(a4, *(unsigned int *)(*(void *)a1 + 4 * v15));
        }
        if (a5) {
          *a5 = v13;
        }
      }
      uint64_t v9 = (v9 & 0xFFFFFFF0) + 16;
      goto LABEL_49;
    }
    int v17 = v16 + (v9 & 0xF);
    uint64_t v18 = *(void *)(a1 + 16);
    uint64_t v16 = *(unsigned int *)(v18 + 4 * v17);
    if (v14)
    {
      if (v16 == v12)
      {
        uint64_t v16 = v12;
      }
      else
      {
        if (!a3) {
          return (v9 - 1);
        }
        int v21 = v11;
        if (v16 != *(_DWORD *)(a1 + 40)) {
          int v21 = a3(a4, *(unsigned int *)(v18 + 4 * v17));
        }
        if (v21 != v13) {
          return (v9 - 1);
        }
      }
    }
    else
    {
      int v19 = *(_DWORD *)(a1 + 40);
      if (v16 == v19) {
        int v13 = v11;
      }
      else {
        int v13 = *(_DWORD *)(v18 + 4 * v17);
      }
      if (a3 && v16 != v19) {
        int v13 = a3(a4, *(unsigned int *)(v18 + 4 * v17));
      }
      if (a5) {
        *a5 = v13;
      }
    }
    if ((((_BYTE)v9 + 1) & 0xF) != 0) {
      break;
    }
    uint64_t v9 = (v9 + 1);
LABEL_49:
    ++v15;
    char v14 = 1;
    uint64_t v12 = v16;
    if ((int)v9 >= *(_DWORD *)(a1 + 48))
    {
      int v27 = *(_DWORD *)(a1 + 52);
      int v28 = *(_DWORD *)(a1 + 40);
      if (v27 == v28) {
        int v29 = v11;
      }
      else {
        int v29 = *(_DWORD *)(a1 + 52);
      }
      if (a3 && v27 != v28) {
        int v29 = ((uint64_t (*)(uint64_t))a3)(a4);
      }
      if (v29 == v13) {
        return 1114111;
      }
      else {
        return (v9 - 1);
      }
    }
  }
  uint64_t v22 = 4 * v17 + 4;
  while (1)
  {
    int v23 = v16;
    uint64_t v16 = *(unsigned int *)(*(void *)(a1 + 16) + v22);
    if (v16 != v23)
    {
      if (!a3) {
        return v9;
      }
      int v24 = v11;
      if (v16 != *(_DWORD *)(a1 + 40)) {
        int v24 = a3(a4, *(unsigned int *)(*(void *)(a1 + 16) + v22));
      }
      if (v24 != v13) {
        return v9;
      }
    }
    char v25 = v9 + 2;
    uint64_t v9 = (v9 + 1);
    v22 += 4;
    if ((v25 & 0xF) == 0)
    {
      uint64_t v9 = (v9 + 1);
      goto LABEL_49;
    }
  }
}

uint64_t umutablecptrie_set(uint64_t result, unsigned int a2, int a3, int *a4)
{
  if (*a4 <= 0) {
    return sub_18C88B520(result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_18C88B520(uint64_t result, unsigned int a2, int a3, int *a4)
{
  if (*a4 <= 0)
  {
    if (a2 < 0x110000)
    {
      int v8 = (void *)result;
      uint64_t result = sub_18C88D068(result, a2);
      if (result)
      {
        uint64_t result = sub_18C88D12C(v8, a2 >> 4);
        if ((result & 0x80000000) == 0)
        {
          *(_DWORD *)(v8[2] + 4 * (result + (a2 & 0xF))) = a3;
          return result;
        }
      }
      int v6 = 7;
    }
    else
    {
      int v6 = 1;
    }
    *a4 = v6;
  }
  return result;
}

uint64_t umutablecptrie_setRange(uint64_t result, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  if (*a5 <= 0) {
    return sub_18C88B5BC(result, a2, a3, a4, a5);
  }
  return result;
}

uint64_t sub_18C88B5BC(uint64_t result, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  if (*a5 > 0) {
    return result;
  }
  LODWORD(v7) = a2;
  int v8 = 1;
  if ((int)a2 > a3 || a2 > 0x10FFFF || a3 > 0x10FFFF)
  {
LABEL_29:
    *a5 = v8;
    return result;
  }
  int v10 = (void *)result;
  uint64_t result = sub_18C88D068(result, a3);
  if (!result) {
    goto LABEL_28;
  }
  unsigned int v11 = a3 + 1;
  unsigned int v12 = v7 & 0xF;
  if ((v7 & 0xF) == 0) {
    goto LABEL_15;
  }
  uint64_t result = sub_18C88D12C(v10, v7 >> 4);
  if ((result & 0x80000000) != 0)
  {
LABEL_28:
    int v8 = 7;
    goto LABEL_29;
  }
  LODWORD(v7) = (v7 + 15) & 0xFFFFFFF0;
  uint64_t v13 = v10[2] + 4 * result;
  if (v7 > v11)
  {
    if (v12 < (v11 & 0xF))
    {
      unint64_t v14 = v13 + 4 * (v11 & 0xF);
      uint64_t v15 = (unsigned int *)(v13 + 4 * v12);
      do
        *v15++ = a4;
      while ((unint64_t)v15 < v14);
    }
    return result;
  }
  uint64_t v16 = 4 * v12;
  do
  {
    *(_DWORD *)(v13 + v16) = a4;
    v16 += 4;
  }
  while (v16 != 64);
LABEL_15:
  if ((int)v7 < (int)(v11 & 0xFFFFFFF0))
  {
    unint64_t v7 = v7;
    int32x4_t v17 = vdupq_n_s32(a4);
    do
    {
      unint64_t v18 = v7 >> 4;
      if (*((unsigned char *)v10 + (v7 >> 4) + 64))
      {
        uint64_t v19 = 0;
        uint64_t v20 = v10[2] + 4 * *(unsigned int *)(*v10 + 4 * v18);
        do
        {
          *(int32x4_t *)(v20 + v19) = v17;
          v19 += 16;
        }
        while (v19 != 64);
      }
      else
      {
        *(_DWORD *)(*v10 + 4 * v18) = a4;
      }
      v7 += 16;
    }
    while ((int)(v11 & 0xFFFFFFF0) > (int)v7);
  }
  if ((v11 & 0xF) != 0)
  {
    uint64_t result = sub_18C88D12C(v10, v7 >> 4);
    if ((result & 0x80000000) == 0)
    {
      int v21 = (unsigned int *)(v10[2] + 4 * result);
      uint64_t v22 = &v21[v11 & 0xF];
      do
        *v21++ = a4;
      while (v21 < v22);
      return result;
    }
    goto LABEL_28;
  }
  return result;
}

char *umutablecptrie_buildImmutable()
{
  uint64_t v0 = (int8x8_t *)MEMORY[0x1F4188790]();
  uint64_t v297 = *MEMORY[0x1E4F143B8];
  if (*v3 <= 0)
  {
    if (v1 > 1 || v2 >= 3)
    {
      uint64_t v4 = 0;
      *uint64_t v3 = 1;
      return v4;
    }
    uint64_t v5 = v0;
    if (v2)
    {
      if (v2 != 2) {
        goto LABEL_18;
      }
      unsigned int v6 = 255;
    }
    else
    {
      unsigned int v6 = 0xFFFF;
    }
    v0[5] = vand_s8(v0[5], (int8x8_t)vdup_n_s32(v6));
    unint64_t v7 = v0[6].u32[0];
    v0[6].i32[1] &= v6;
    if ((int)v7 >= 16)
    {
      uint64_t v8 = 0;
      unint64_t v9 = v7 >> 4;
      do
      {
        if (!v0[8].i8[v8]) {
          *(_DWORD *)(*(void *)v0 + 4 * v8) &= v6;
        }
        ++v8;
      }
      while (v9 != v8);
    }
    if (v0[3].i32[1] >= 1)
    {
      uint64_t v10 = 0;
      int8x8_t v11 = v0[2];
      do
        *(_DWORD *)(*(void *)&v11 + 4 * v10++) &= v6;
      while (v10 < v0[3].i32[1]);
    }
LABEL_18:
    unsigned int v277 = v2;
    if (v1) {
      unsigned int v12 = 4096;
    }
    else {
      unsigned int v12 = 0x10000;
    }
    unint64_t v13 = v12 >> 4;
    unint64_t v14 = v0[6].u32[0];
    if ((int)v14 < 1114112)
    {
      uint64_t v16 = (_DWORD *)&v0[6] + 1;
      __int32 v17 = v0[6].i32[1];
      if ((int)v14 < 16)
      {
LABEL_25:
        unsigned int v18 = 0;
        goto LABEL_41;
      }
    }
    else
    {
      if (v0[8711].i8[7]) {
        uint64_t v15 = (__int32 *)(*(void *)&v0[2] + 4 * (*(_DWORD *)(*(void *)v0 + 278524) + 15));
      }
      else {
        uint64_t v15 = (__int32 *)(*(void *)v0 + 278524);
      }
      __int32 v17 = *v15;
      v0[6].i32[1] = *v15;
      uint64_t v16 = (_DWORD *)&v0[6] + 1;
    }
    uint64_t v19 = v14 >> 4;
    while (1)
    {
      uint64_t v20 = (v19 - 1);
      if (v0[8].i8[v20]) {
        break;
      }
      if (*(_DWORD *)(*(void *)v0 + 4 * v20) != v17) {
        goto LABEL_38;
      }
LABEL_35:
      BOOL v111 = v19-- <= 1;
      if (v111) {
        goto LABEL_25;
      }
    }
    uint64_t v21 = 0;
    uint64_t v22 = *(void *)&v0[2] + 4 * *(unsigned int *)(*(void *)v0 + 4 * v20);
    while (*(_DWORD *)(v22 + v21) == v17)
    {
      v21 += 4;
      if (v21 == 64) {
        goto LABEL_35;
      }
    }
LABEL_38:
    unsigned int v18 = (16 * v19 + 511) & 0x7FFFFE00;
    if (v18 == 1114112)
    {
      v0[6].i32[1] = v0[5].i32[0];
      unsigned int v23 = 1114112;
      goto LABEL_45;
    }
    unsigned int v23 = (16 * v19 + 511) & 0x7FFFFE00;
    if (v18 >= v12)
    {
LABEL_45:
      v281 = v3;
      unint64_t v28 = 0;
      v0[6].i32[0] = v23;
      memset(__src, 0, sizeof(__src));
      do
      {
        int v29 = v16;
        if (v28 < v23)
        {
          uint64_t v30 = v28 >> 4;
          if (v0[8].i8[v30]) {
            int v29 = (_DWORD *)(*(void *)&v0[2] + 4
          }
                                               * (*(_DWORD *)(*(void *)v0 + 4 * v30) + (v28 & 0xF)));
          else {
            int v29 = (_DWORD *)(*(void *)v0 + 4 * v30);
          }
        }
        *((_DWORD *)__src + v28++) = *v29;
      }
      while (v28 != 128);
      unsigned int v269 = v18;
      unsigned int v272 = v1;
      unsigned int v273 = v12;
      uint64_t v292 = 0;
      memset(v291, 0, sizeof(v291));
      DWORD1(v291[0]) = -1;
      if (!v23)
      {
        int v33 = 148;
        goto LABEL_109;
      }
      int v31 = 0;
      signed int v32 = v23 >> 4;
      int v33 = 148;
      int v34 = 64;
      int v35 = 4;
      while (1)
      {
        if (v31 == v13)
        {
          int v34 = 16;
          int v35 = 1;
        }
        int8x8_t v36 = *v5;
        uint64_t v37 = *(unsigned int *)(*(void *)v5 + 4 * v31);
        int v38 = (char *)v5 + v31;
        int v40 = v38[64];
        uint64_t v39 = v38 + 64;
        if (v40 == 1)
        {
          int v41 = (int *)(*(void *)&v5[2] + 4 * v37);
          int v43 = *v41;
          int v42 = v41 + 1;
          LODWORD(v37) = v43;
          long long v44 = &v42[v34 - 1];
          do
          {
            if (*v42 != v37) {
              break;
            }
            ++v42;
          }
          while (v42 < v44);
          if (v42 != v44) {
            goto LABEL_93;
          }
          *uint64_t v39 = 0;
          int8x8_t v36 = *v5;
          *(_DWORD *)(*(void *)v5 + 4 * v31) = v37;
        }
        else if (v35 >= 2)
        {
          uint64_t v45 = v31 + 1;
          do
          {
            if (v45 >= v35 + v31) {
              goto LABEL_67;
            }
            int v46 = *(_DWORD *)(*(void *)&v36 + 4 * v45++);
          }
          while (v46 == v37);
          int v47 = sub_18C88D12C(v5, v31);
          if (v47 < 0) {
            goto LABEL_117;
          }
          v33 += v34 & ~(v47 >> 31);
          goto LABEL_94;
        }
LABEL_67:
        uint64_t v48 = DWORD1(v291[0]);
        if ((DWORD1(v291[0]) & 0x80000000) != 0 || *((_DWORD *)&v291[8] + DWORD1(v291[0]) + 2) != v37) {
          break;
        }
LABEL_76:
        int v50 = (char *)v291 + 4 * v48;
        *((_DWORD *)v50 + 66) += v35;
        int v51 = *((_DWORD *)v50 + 2);
        if (v51 == -2)
        {
LABEL_77:
          if (!v31)
          {
LABEL_84:
            if (SLODWORD(v291[0]) < 1)
            {
              int v54 = -1;
            }
            else
            {
              uint64_t v53 = 0;
              int v54 = -1;
              int v55 = 69632;
              do
              {
                if (*((_DWORD *)&v291[16] + v53 + 2) < v55)
                {
                  int v54 = v53;
                  int v55 = *((_DWORD *)&v291[16] + v53 + 2);
                }
                ++v53;
              }
              while (LODWORD(v291[0]) != v53);
            }
            DWORD1(v291[0]) = v54;
            uint64_t v49 = v54;
            BOOL v56 = (char *)v291 + 4 * v54;
            *((_DWORD *)v56 + 2) = v31;
            *((_DWORD *)v56 + 34) = v37;
LABEL_92:
            *((_DWORD *)&v291[16] + v49 + 2) = v35;
            goto LABEL_93;
          }
          int v51 = 0;
          int v52 = 4;
          while (1)
          {
            if (v51 == v13) {
              int v52 = 1;
            }
            if (!v5[8].i8[v51] && *(_DWORD *)(*(void *)&v36 + 4 * v51) == v37) {
              break;
            }
            v51 += v52;
            if (v51 == v31) {
              goto LABEL_84;
            }
          }
          if (SLODWORD(v291[0]) < 1)
          {
            int v58 = -1;
          }
          else
          {
            uint64_t v57 = 0;
            int v58 = -1;
            int v59 = 69632;
            do
            {
              if (*((_DWORD *)&v291[16] + v57 + 2) < v59)
              {
                int v58 = v57;
                int v59 = *((_DWORD *)&v291[16] + v57 + 2);
              }
              ++v57;
            }
            while (LODWORD(v291[0]) != v57);
          }
          DWORD1(v291[0]) = v58;
          uint64_t v60 = (_DWORD *)v291 + v58;
          v60[2] = v51;
          v60[34] = v37;
          v60[66] = v52 + v35;
        }
        if ((v51 & 0x80000000) == 0)
        {
          *uint64_t v39 = 2;
          *(_DWORD *)(*(void *)v5 + 4 * v31) = v51;
          goto LABEL_94;
        }
LABEL_93:
        v33 += v34;
LABEL_94:
        v31 += v35;
        if (v31 >= v32)
        {
          if (v33 < 0)
          {
LABEL_117:
            int *v281 = 7;
            goto LABEL_207;
          }
LABEL_109:
          unint64_t v61 = uprv_malloc(4 * v33);
          if (!v61) {
            goto LABEL_117;
          }
          uint64_t v62 = (uint64_t)v61;
          memcpy(v61, __src, 0x200uLL);
          if (LODWORD(v291[0]))
          {
            if (SLODWORD(v291[0]) < 1)
            {
              uint64_t v66 = -1;
            }
            else
            {
              uint64_t v63 = 0;
              int v64 = 0;
              int v65 = -1;
              do
              {
                if (*((_DWORD *)&v291[16] + v63 + 2) > v64)
                {
                  int v65 = v63;
                  int v64 = *((_DWORD *)&v291[16] + v63 + 2);
                }
                ++v63;
              }
              while (LODWORD(v291[0]) != v63);
              uint64_t v66 = v65;
            }
            unsigned int v67 = *((_DWORD *)v291 + v66 + 2);
          }
          else
          {
            unsigned int v67 = -1;
          }
          long long v289 = 0u;
          long long v290 = 0u;
          uint64_t v68 = (_DWORD *)*v5;
          *uint64_t v68 = 0;
          v68[4] = 64;
          if (!sub_18C88D2EC((uint64_t)&v289, v33, 64))
          {
LABEL_203:
            LODWORD(v124) = 0;
            int v125 = 7;
            uint64_t v123 = v281;
LABEL_204:
            *uint64_t v123 = v125;
LABEL_205:
            unsigned int v126 = v277;
            goto LABEL_206;
          }
          LODWORD(v69) = 128;
          sub_18C88D3D8((uint64_t)&v289, v62, 0, 128);
          int v70 = v5[6].i32[0];
          if (v70 >= 144)
          {
            uint64_t v71 = 0;
            int v72 = v70 >> 4;
            uint64_t v69 = 128;
            uint64_t v73 = 64;
            int v74 = 4;
            int v75 = 8;
            int v274 = v70 >> 4;
            unsigned int v276 = v67;
            do
            {
              if (v75 == v13)
              {
                if (!sub_18C88D2EC((uint64_t)&v289, v33, 16)) {
                  goto LABEL_203;
                }
                sub_18C88D3D8((uint64_t)&v289, v62, 0, v69);
                int v74 = 1;
                uint64_t v73 = 16;
                uint64_t v71 = v69;
              }
              if (v5[8].i8[v75] == 1)
              {
                unsigned int v282 = v73;
                int v284 = v74;
                unsigned int v278 = v71;
                int8x8_t v86 = *v5;
                uint64_t v270 = 4 * *(unsigned int *)(*(void *)v5 + 4 * v75);
                int8x8_t v271 = v5[2];
                int v88 = (int *)(*(void *)&v271 + v270 + 4);
                unsigned int v87 = *(_DWORD *)(*(void *)&v271 + v270);
                if (SDWORD2(v290) <= 2) {
                  uint64_t v89 = 2;
                }
                else {
                  uint64_t v89 = DWORD2(v290);
                }
                uint64_t v90 = v89 - 1;
                do
                {
                  int v91 = *v88++;
                  unsigned int v87 = v91 + 37 * v87;
                  --v90;
                }
                while (v90);
                unsigned int v92 = sub_18C88D49C((uint64_t)&v289, v62, *(void *)&v271 + v270, 0, v87);
                if ((v92 & 0x80000000) != 0 || (int v93 = (DWORD1(v290) & *(_DWORD *)(v289 + 4 * v92)) - 1, v93 < 0))
                {
                  uint64_t v94 = 4 * (int)v69;
                  uint64_t v95 = v94 - 4 * v282 + 4;
                  uint64_t v96 = v282;
                  do
                  {
                    uint64_t v97 = v96--;
                    uint64_t v98 = v95;
                    int v99 = v97;
                    uint64_t v100 = (_DWORD *)(*(void *)&v271 + v270);
                    while (*(_DWORD *)(v62 + v98) == *v100)
                    {
                      ++v100;
                      --v99;
                      v98 += 4;
                      if (v99 <= 1) {
                        goto LABEL_157;
                      }
                    }
                    v95 += 4;
                  }
                  while (v97 >= 3);
                  LODWORD(v96) = 0;
LABEL_157:
                  *(_DWORD *)(*(void *)&v86 + 4 * v75) = v69 - v96;
                  uint64_t v101 = v69;
                  unsigned int v67 = v276;
                  if ((int)v96 < (int)v282)
                  {
                    unint64_t v102 = (_DWORD *)(v62 + v94);
                    uint64_t v103 = (int *)(*(void *)&v271 + v270 + 4 * (int)v96);
                    uint64_t v104 = v282 - (uint64_t)(int)v96;
                    uint64_t v101 = v69 + v282 - v96;
                    do
                    {
                      int v105 = *v103++;
                      *v102++ = v105;
                      --v104;
                    }
                    while (v104);
                  }
                  sub_18C88D3D8((uint64_t)&v289, v62, v69, v101);
                  uint64_t v73 = v282;
                  uint64_t v69 = v101;
                  int v72 = v274;
                  uint64_t v71 = v278;
                  int v74 = v284;
                }
                else
                {
                  *(_DWORD *)(*(void *)&v86 + 4 * v75) = v93;
                  unsigned int v67 = v276;
                  int v72 = v274;
                  uint64_t v71 = v278;
                  int v74 = v284;
                  uint64_t v73 = v282;
                }
                goto LABEL_200;
              }
              if (v5[8].i8[v75])
              {
                *(_DWORD *)(*(void *)v5 + 4 * v75) = *(_DWORD *)(*(void *)v5
                                                                   + 4 * *(unsigned int *)(*(void *)v5 + 4 * v75));
              }
              else
              {
                int8x8_t v76 = *v5;
                unsigned int v77 = *(_DWORD *)(*(void *)v5 + 4 * v75);
                unsigned int v78 = v77;
                if (SDWORD2(v290) >= 2)
                {
                  int v79 = DWORD2(v290) - 1;
                  unsigned int v78 = *(_DWORD *)(*(void *)v5 + 4 * v75);
                  do
                  {
                    unsigned int v78 = v77 + 37 * v78;
                    --v79;
                  }
                  while (v79);
                }
                signed int v80 = v78 % (HIDWORD(v289) - 1) + 1;
                int v81 = *(_DWORD *)(v289 + 4 * v80);
                if (v81)
                {
                  int v82 = v78 << v290;
                  int v83 = v78 % (HIDWORD(v289) - 1) + 1;
                  while (1)
                  {
                    if ((v81 & ~DWORD1(v290)) == v82)
                    {
                      int v84 = (_DWORD *)(v62 + 4 * ((v81 & DWORD1(v290)) - 1));
                      uint64_t v85 = &v84[SDWORD2(v290)];
                      if (SDWORD2(v290) >= 1)
                      {
                        do
                        {
                          if (*v84 != v77) {
                            break;
                          }
                          ++v84;
                        }
                        while (v84 < v85);
                      }
                      if (v84 == v85) {
                        break;
                      }
                    }
                    int v83 = (v83 + v80) % SHIDWORD(v289);
                    int v81 = *(_DWORD *)(v289 + 4 * v83);
                    if (!v81) {
                      goto LABEL_162;
                    }
                  }
                }
                else
                {
                  int v83 = v78 % (HIDWORD(v289) - 1) + 1;
LABEL_162:
                  int v83 = ~v83;
                }
                if (v83 < 0) {
                  int v106 = -1;
                }
                else {
                  int v106 = (DWORD1(v290) & *(_DWORD *)(v289 + 4 * v83)) - 1;
                }
                int v107 = v106 >> 31;
                if (v75 == v67 && v75 >= (int)v13 && (v106 & 0x80000000) == 0 && v106 < (int)v71)
                {
                  int v108 = v69 - v73;
                  while (1)
                  {
                    unint64_t v109 = 0;
                    while (*(_DWORD *)(*(void *)&v76 + 4 * v109) != v106)
                    {
                      v109 += 4;
                      if (v109 >= v13) {
                        goto LABEL_194;
                      }
                    }
                    if (v108 <= v106) {
                      break;
                    }
                    int v107 = v106;
                    while (1)
                    {
                      int v106 = v107 + 1;
                      if (*(_DWORD *)(v62 + 4 * (v107 + 1)) == v77) {
                        break;
                      }
LABEL_183:
                      int v107 = v106;
                      if (v106 >= v108) {
                        goto LABEL_188;
                      }
                    }
                    uint64_t v110 = 0;
                    do
                    {
                      if (*(_DWORD *)(v62 + 8 + 4 * v107 + 4 * v110) != v77)
                      {
                        int v106 = v107 + v110 + 2;
                        goto LABEL_183;
                      }
                      ++v110;
                    }
                    while (v73 - 1 != v110);
                    BOOL v111 = v107 < -1;
                    LOBYTE(v107) = v107 < -1;
                    if (v111 || v106 >= (int)v71) {
                      goto LABEL_187;
                    }
                  }
LABEL_188:
                  int v112 = v69 + 1;
                  int v113 = v69 + 1 - v73;
                  uint64_t v114 = v113;
                  if ((int)v69 < v113) {
                    int v113 = v69;
                  }
                  uint64_t v115 = (int)v69;
                  while (v115 > v114)
                  {
                    uint64_t v116 = v62 + 4 * v115--;
                    --v112;
                    if (*(_DWORD *)(v116 - 4) != v77) {
                      goto LABEL_196;
                    }
                  }
                  int v112 = v113;
LABEL_196:
                  int v285 = v74;
                  uint64_t v117 = v71;
                  *(_DWORD *)(*(void *)&v76 + 4 * v75) = v112;
                  uint64_t v118 = v69;
                  if ((int)v69 - v112 < (int)v73)
                  {
                    long long v119 = (unsigned int *)(v62 + 4 * (int)v69);
                    int v120 = v112 + v73;
                    LODWORD(v118) = v69;
                    do
                    {
                      *v119++ = v77;
                      uint64_t v118 = (v118 + 1);
                    }
                    while (v120 != v118);
                  }
                  int v121 = v69;
                  uint64_t v122 = v73;
                  sub_18C88D3D8((uint64_t)&v289, v62, v121, v118);
                  uint64_t v73 = v122;
                  uint64_t v69 = v118;
                  int v72 = v274;
                  uint64_t v71 = v117;
                  int v74 = v285;
                  unsigned int v67 = v276;
                  goto LABEL_200;
                }
LABEL_187:
                if (v107) {
                  goto LABEL_188;
                }
LABEL_194:
                *(_DWORD *)(*(void *)&v76 + 4 * v75) = v106;
              }
LABEL_200:
              v75 += v74;
            }
            while (v75 < v72);
          }
          uint64_t v123 = v281;
          if (*v281 > 0)
          {
            LODWORD(v124) = 0;
            goto LABEL_205;
          }
          uprv_free(*(void **)&v5[2]);
          v5[2] = (int8x8_t)v62;
          v5[3].i32[0] = v33;
          v5[3].i32[1] = v69;
          if ((int)v69 >= 262160)
          {
            LODWORD(v124) = 0;
            int v125 = 8;
            goto LABEL_204;
          }
          if ((v67 & 0x80000000) != 0)
          {
            LODWORD(v138) = 0xFFFFF;
          }
          else
          {
            uint64_t v138 = *(int *)(*(void *)v5 + 4 * v67);
            v5[5].i32[0] = *(_DWORD *)(v62 + 4 * v138);
          }
          v5[4].i32[0] = v138;
          uint64_t v124 = v273 >> 6;
          if ((int)v124 >= v5[6].i32[0] >> 6)
          {
            v5[1].i32[1] = 0x7FFF;
            goto LABEL_368;
          }
          bzero(v296, 0x800uLL);
          uint64_t v146 = 0;
          uint64_t v147 = 0;
          int8x8_t v148 = *v5;
          if ((int)v13 <= 4) {
            int v149 = 4;
          }
          else {
            int v149 = v13;
          }
          uint64_t v150 = ((v149 - 1) >> 2) + 1;
          int v151 = -1;
          int8x8_t v152 = *v5;
          do
          {
            int v153 = *(_DWORD *)(*(void *)&v148 + 4 * v146);
            v296[v147] = v153;
            if (v153 == v5[4].i32[0])
            {
              if (v151 < 0)
              {
                int v151 = v147;
              }
              else if (v5[1].i32[1] < 0 && v147 - v151 == 31)
              {
                v5[1].i32[1] = v151;
              }
            }
            else
            {
              int v151 = -1;
            }
            v146 += 4;
            int v154 = v153 + 16;
            for (uint64_t i = 4; i != 16; i += 4)
            {
              *(_DWORD *)(*(void *)&v152 + i) = v154;
              v154 += 16;
            }
            ++v147;
            *(void *)&v152 += 16;
          }
          while (v147 != v150);
          if ((sub_18C88D2EC((uint64_t)&v289, v124, 32) & 1) == 0) {
            goto LABEL_365;
          }
          int v156 = v272 == 0;
          sub_18C88D550((uint64_t)&v289, (uint64_t)v296, 0, 0, v124);
          unint64_t v157 = (v156 << 12);
          int v158 = v5[6].i32[0] >> 4;
          int v286 = v158;
          if (v158 <= v156 << 12)
          {
            int v160 = 0;
            char v159 = 0;
          }
          else
          {
            char v159 = 0;
            int v160 = 0;
            __int32 v161 = v5[1].i32[1];
            int64_t v162 = v158;
            uint64_t v163 = (uint64_t)*v5;
            uint64_t v164 = *(void *)v5 + 4 * v157;
            int64_t v165 = v157;
            do
            {
              uint64_t v166 = 0;
              v167 = (const float *)&v5[4];
              int32x4_t v168 = (int32x4_t)vld1q_dup_f32(v167);
              int8x16_t v169 = 0uLL;
              v170.i64[0] = 0x101010101010101;
              v170.i64[1] = 0x101010101010101;
              int8x16_t v171 = 0uLL;
              int8x16_t v172 = 0uLL;
              int8x16_t v173 = 0uLL;
              do
              {
                int32x4_t v174 = *(int32x4_t *)(v164 + v166);
                int32x4_t v175 = *(int32x4_t *)(v164 + v166 + 16);
                int32x4_t v177 = *(int32x4_t *)(v164 + v166 + 32);
                int32x4_t v176 = *(int32x4_t *)(v164 + v166 + 48);
                int8x16_t v172 = vorrq_s8((int8x16_t)v177, v172);
                int8x16_t v171 = vorrq_s8((int8x16_t)v175, v171);
                int8x16_t v169 = vorrq_s8((int8x16_t)v174, v169);
                int8x16_t v173 = vorrq_s8((int8x16_t)v176, v173);
                int8x16_t v170 = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqq_s32(v174, v168), (int16x8_t)vceqq_s32(v175, v168)), (int8x16_t)vuzp1q_s16((int16x8_t)vceqq_s32(v177, v168), (int16x8_t)vceqq_s32(v176, v168))), v170);
                v166 += 64;
              }
              while (v166 != 128);
              int8x16_t v178 = vorrq_s8(vorrq_s8(v169, v172), vorrq_s8(v171, v173));
              *(int8x8_t *)v178.i8 = vorr_s8(*(int8x8_t *)v178.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v178, v178, 8uLL));
              unsigned __int32 v179 = v178.i32[0] | v178.i32[1];
              if (vmaxvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vmvnq_s8(v170), 7uLL))))
              {
                if (HIWORD(v179))
                {
                  v5[8].i8[v165] = 3;
                  v160 += 36;
                  char v159 = 1;
                }
                else
                {
                  int v180 = sub_18C88D618((uint64_t *)&v289, (uint64_t)v296, v163, v165);
                  v181 = (char *)&v5[8] + v165;
                  if (v180 < 0)
                  {
                    unsigned char *v181 = 2;
                    v160 += 32;
                  }
                  else
                  {
                    unsigned char *v181 = 1;
                    *(_DWORD *)(v163 + 4 * v165) = v180;
                  }
                }
              }
              else
              {
                v5[8].i8[v165] = 0;
                if (v161 < 0)
                {
                  __int32 v161 = 0;
                  unsigned __int32 v182 = HIWORD(v179);
                  BOOL v183 = v182 == 0;
                  BOOL v184 = v182 != 0;
                  if (v183) {
                    int v185 = 32;
                  }
                  else {
                    int v185 = 36;
                  }
                  v160 += v185;
                  v159 |= v184;
                }
              }
              v165 += 32;
              v164 += 128;
            }
            while (v165 < v162);
          }
          uint64_t v207 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
          int v208 = v207 + ((v286 - (int)v157) >> 5) + v160 + 1;
          v209 = uprv_malloc(2 * v208);
          v5[7] = (int8x8_t)v209;
          if (v209)
          {
            memcpy(v209, v296, v273 >> 5);
            uint64_t v123 = v281;
            if (sub_18C88D2EC((uint64_t)&v289, v208, 32))
            {
              memset(v293, 0, sizeof(v293));
              if ((v159 & 1) != 0 && (sub_18C88D2EC((uint64_t)v293, v208, 36) & 1) == 0)
              {
                LODWORD(v124) = 0;
                int *v281 = 7;
              }
              else
              {
                char v279 = v159;
                bzero(v295, 0x1100uLL);
                uint64_t v210 = v5[1].u32[1];
                uint64_t v283 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
                if (v286 > (int)v157)
                {
                  uint64_t v211 = 0;
                  uint64_t v287 = ((v286 + ~v157) >> 5) + 1;
                  uint64_t v275 = (int)v207;
                  uint64_t v212 = v207;
                  uint64_t v213 = 4 * v157;
                  uint64_t v214 = v212;
                  uint64_t v215 = v5[1].u32[1];
                  while (1)
                  {
                    int v216 = v5[8].u8[v157];
                    if (!v5[8].i8[v157] && (v215 & 0x80000000) != 0) {
                      break;
                    }
                    if (v5[8].i8[v157])
                    {
                      if (v216 == 2) {
                        goto LABEL_320;
                      }
                      if (v216 != 1)
                      {
LABEL_322:
                        uint64_t v222 = (uint64_t)v5[7];
                        v223 = (int16x8_t *)(v222 + 2 * (int)v214 + 2);
                        v224 = (int16x8_t *)(*(void *)v5 + v213);
                        unint64_t v225 = v157;
                        do
                        {
                          int16x8_t v226 = *v224;
                          int16x8_t v227 = v224[1];
                          v224 += 2;
                          v225 += 8;
                          int16x8_t *v223 = vuzp1q_s16(v226, v227);
                          v223[-1].i16[7] = ((unsigned __int32)v226.i32[1] >> 4) & 0x3000 | ((unsigned __int32)v226.i32[0] >> 2) & 0xC000 | ((unsigned __int32)v226.i32[2] >> 6) & 0xC00 | ((unsigned __int32)v226.i32[3] >> 8) & 0x300 | ((unsigned __int32)v227.i32[0] >> 10) & 0xC0 | ((unsigned __int32)v227.i32[1] >> 12) & 0x30 | ((unsigned __int32)v227.i32[2] >> 14) & 0xC | v227.i8[14] & 3;
                          v223 = (int16x8_t *)((char *)v223 + 18);
                        }
                        while (v225 < v157 + 32);
                        int v228 = sub_18C88D718((uint64_t)v293, v222, v222, v214);
                        if (v228 < 0)
                        {
                          int v229 = v283;
                          if (v214 == v283)
                          {
LABEL_349:
                            uint64_t v230 = (v214 + 36);
                          }
                          else
                          {
                            uint64_t v234 = 0;
                            uint64_t v235 = 0x7FFFFFFFFFFFFFDDLL;
                            uint64_t v236 = 35;
                            uint64_t v237 = 36;
LABEL_330:
                            unint64_t v238 = v237--;
                            int v239 = v238;
                            v240 = (unsigned __int16 *)(v222 + 2 * (int)v214);
                            do
                            {
                              if (v240[v235] != *v240)
                              {
                                --v236;
                                ++v235;
                                v234 -= 2;
                                if (v238 >= 3) {
                                  goto LABEL_330;
                                }
                                int v229 = v214;
                                goto LABEL_349;
                              }
                              ++v240;
                              --v239;
                            }
                            while (v239 > 1);
                            int v229 = v214 - v237;
                            if ((int)v237 < 1) {
                              goto LABEL_349;
                            }
                            if (v237 > 0x23)
                            {
                              uint64_t v230 = v214;
                            }
                            else
                            {
                              uint64_t v245 = 0;
                              do
                              {
                                *(_WORD *)(v222 + 2 * (int)v214 + 2 * v245++) = *(_WORD *)(v222
                                                                                           + 2 * (int)v214
                                                                                           + v234
                                                                                           + 70);
                                v234 += 2;
                              }
                              while (v234 != 2);
                              uint64_t v230 = (v214 + v245);
                            }
                          }
                          sub_18C88D550((uint64_t)&v289, v222, v283, v214, v230);
                          if (v279) {
                            sub_18C88D550((uint64_t)v293, *(void *)&v5[7], v283, v214, v230);
                          }
                        }
                        else
                        {
                          int v229 = v228;
                          uint64_t v230 = v214;
                        }
                        uint64_t v217 = v229 | 0x8000u;
                        uint64_t v214 = v230;
                        goto LABEL_359;
                      }
                      uint64_t v217 = *(unsigned int *)(*(void *)v5 + 4 * v157);
                    }
                    else
                    {
                      uint64_t v217 = v210;
                    }
LABEL_359:
                    uint64_t v210 = v5[1].u32[1];
                    if ((v210 & 0x80000000) != 0 && (v215 & 0x80000000) == 0)
                    {
                      v5[1].i32[1] = v217;
                      uint64_t v210 = v217;
                    }
                    v295[v211] = v217;
                    v157 += 32;
                    v213 += 128;
                    ++v211;
                    int v249 = v287;
                    if (v211 == v287)
                    {
                      uint64_t v250 = v214;
                      uint64_t v123 = v281;
                      LODWORD(v207) = v283;
                      goto LABEL_370;
                    }
                  }
                  uint64_t v215 = 0;
                  if (v5[4].i32[0] >= 0x10000) {
                    goto LABEL_322;
                  }
LABEL_320:
                  uint64_t v218 = v215;
                  uint64_t v219 = (uint64_t)v5[7];
                  int8x8_t v220 = *v5;
                  uint64_t v221 = sub_18C88D618((uint64_t *)&v289, v219, (uint64_t)*v5, v157);
                  if ((v221 & 0x80000000) != 0)
                  {
                    if (v214 == v283)
                    {
                      unint64_t v231 = 0;
                      uint64_t v232 = v275;
                      uint64_t v217 = v283;
                      uint64_t v233 = v219;
                    }
                    else
                    {
                      uint64_t v232 = (int)v214;
                      int v241 = 32;
                      unint64_t v231 = 31;
                      uint64_t v233 = v219;
LABEL_338:
                      v242 = (unsigned __int16 *)(v219 + 2 * ((int)v214 - v231));
                      int8x8_t v243 = v220;
                      int v244 = v241;
                      do
                      {
                        if (*(_DWORD *)(*(void *)&v243 + v213) != *v242)
                        {
                          --v241;
                          BOOL v111 = v231-- > 1;
                          if (v111) {
                            goto LABEL_338;
                          }
                          unint64_t v231 = 0;
                          uint64_t v217 = v214;
                          goto LABEL_354;
                        }
                        ++v242;
                        --v244;
                        *(void *)&v243 += 4;
                      }
                      while (v244 > 1);
                      uint64_t v217 = (v214 - v231);
                      uint64_t v246 = v214;
                      if ((int)v231 > 31) {
                        goto LABEL_356;
                      }
                    }
LABEL_354:
                    v247 = (_WORD *)(v233 + 2 * v232);
                    uint64_t v248 = 4 * v231;
                    uint64_t v246 = (v232 - v231 + 32);
                    do
                    {
                      *v247++ = *(_DWORD *)(*(void *)&v220 + v213 + v248);
                      v248 += 4;
                    }
                    while (v248 != 128);
LABEL_356:
                    sub_18C88D550((uint64_t)&v289, v233, v283, v214, v246);
                    if (v279) {
                      sub_18C88D550((uint64_t)v293, *(void *)&v5[7], v283, v214, v246);
                    }
                    uint64_t v214 = v246;
                    uint64_t v215 = v218;
                  }
                  else
                  {
                    uint64_t v217 = v221;
                    uint64_t v215 = v218;
                  }
                  goto LABEL_359;
                }
                int v249 = 0;
                uint64_t v250 = (v124 + ((((v286 - (int)v157) >> 5) + 31) >> 5));
LABEL_370:
                if ((v210 & 0x80000000) != 0) {
                  v5[1].i32[1] = 0x7FFF;
                }
                if ((int)v250 > 32798)
                {
                  LODWORD(v250) = 0;
                  *uint64_t v123 = 8;
                  goto LABEL_409;
                }
                if (v249 >= 1)
                {
                  int v251 = 0;
                  uint64_t v288 = (int)v207;
                  uint64_t v252 = (uint64_t)v5[7];
                  int v280 = v249 + 1;
                  int v253 = 32;
                  int v254 = v249;
                  do
                  {
                    int v255 = v249 - v251;
                    if (v249 - v251 >= v253)
                    {
                      uint64_t v257 = v250;
                      int v256 = sub_18C88D718((uint64_t)&v289, v252, (uint64_t)v295, v251);
                      uint64_t v250 = v257;
                      LOWORD(v257) = v256;
                      if (v256 < 0) {
                        goto LABEL_391;
                      }
                      goto LABEL_405;
                    }
                    if ((int)v250 - v255 < (int)v207)
                    {
LABEL_378:
                      int v253 = v249 - v251;
                      goto LABEL_391;
                    }
                    uint64_t v257 = v288;
                    while (1)
                    {
                      if (v255 >= 1)
                      {
                        v258 = (unsigned __int16 *)(v252 + 2 * v257);
                        int v259 = v280 - v251;
                        v260 = &v295[v251];
                        while (*v258 == *v260)
                        {
                          ++v258;
                          ++v260;
                          if (--v259 <= 1)
                          {
                            int v253 = v249 - v251;
                            if ((v257 & 0x80000000) == 0) {
                              goto LABEL_405;
                            }
                            goto LABEL_391;
                          }
                        }
                        goto LABEL_388;
                      }
                      if (!v255) {
                        break;
                      }
LABEL_388:
                      if (v250 - v255 + 1 == ++v257) {
                        goto LABEL_378;
                      }
                    }
                    int v253 = 0;
                    if ((v257 & 0x80000000) != 0)
                    {
LABEL_391:
                      if (v250 == v207)
                      {
                        int v261 = 0;
                        goto LABEL_402;
                      }
                      int v261 = v253 - 1;
                      if (v253 <= 1)
                      {
                        LOWORD(v257) = v250 - v261;
                        goto LABEL_403;
                      }
                      uint64_t v262 = v253;
                      do
                      {
                        uint64_t v263 = v262--;
                        v264 = (unsigned __int16 *)(v252 + 2 * ((int)v250 - v262));
                        int v265 = v263;
                        v266 = &v295[v251];
                        while (*v264 == *v266)
                        {
                          ++v264;
                          ++v266;
                          if (--v265 <= 1)
                          {
                            int v261 = v262;
                            goto LABEL_402;
                          }
                        }
                        int v261 = 0;
                      }
                      while (v263 >= 3);
LABEL_402:
                      LOWORD(v257) = v250 - v261;
                      uint64_t v267 = v250;
                      if (v261 < v253)
                      {
LABEL_403:
                        int v268 = v250;
                        memcpy((void *)(v252 + 2 * (int)v250), &v295[v261 + v251], 2 * (v253 + ~v261) + 2);
                        LODWORD(v250) = v268;
                        uint64_t v267 = (v253 + v268 - v261);
                      }
                      LODWORD(v207) = v283;
                      sub_18C88D550((uint64_t)&v289, v252, v283, v250, v267);
                      uint64_t v252 = (uint64_t)v5[7];
                      uint64_t v250 = v267;
                      int v249 = v254;
                    }
LABEL_405:
                    *(_WORD *)(v252 + 2 * v124++) = v257;
                    v251 += v253;
                  }
                  while (v251 < v249);
                }
LABEL_409:
                LODWORD(v124) = v250;
                uint64_t v123 = v281;
              }
              uprv_free(*(void **)&v293[0]);
LABEL_368:
              unsigned int v126 = v277;
              v5[6].i32[0] = v269;
LABEL_206:
              uprv_free((void *)v289);
              if (*v123 >= 1)
              {
LABEL_207:
                v5[1].i32[1] = -1;
                *(int8x8_t *)((char *)&v5[3] + 4) = (int8x8_t)0xFFFFFFFF00000000;
                __int32 v127 = v5[4].i32[1];
                v5[5].i32[0] = v127;
                v5[6].i32[0] = 0;
                v5[6].i32[1] = v127;
                uprv_free(*(void **)&v5[7]);
                uint64_t v4 = 0;
LABEL_208:
                v5[7] = 0;
                return v4;
              }
              if (v126 == 1 && (v124 & 1) != 0)
              {
                *(_WORD *)(*(void *)&v5[7] + 2 * (int)v124) = -18;
                int v129 = 2 * (v124 + 1);
                LODWORD(v124) = v124 + 1;
                goto LABEL_219;
              }
              int v129 = 2 * v124;
              if (v126)
              {
                if (v126 != 1)
                {
                  int v130 = v5[3].i32[1];
                  int v131 = ((_BYTE)v130 + (_BYTE)v129) & 3;
                  if ((((_BYTE)v130 + (_BYTE)v129) & 3) != 0)
                  {
                    if (v131 == 3)
                    {
                      int8x8_t v132 = v5[2];
                      if (*(_DWORD *)(*(void *)&v132 + 4 * (v130 - 1)) != v5[6].i32[1]) {
                        goto LABEL_280;
                      }
                    }
                    else
                    {
                      if (v131 == 2)
                      {
                        int8x8_t v132 = v5[2];
                        goto LABEL_282;
                      }
                      int8x8_t v132 = v5[2];
                      do
                      {
LABEL_280:
                        __int32 v186 = v5[6].i32[1];
                        uint64_t v187 = v5[3].i32[1];
                        v5[3].i32[1] = v187 + 1;
                        *(_DWORD *)(*(void *)&v132 + 4 * v187) = v186;
                        int v131 = (v131 + 1) & 3;
                      }
                      while (v131 != 2);
                      int v130 = v5[3].i32[1];
LABEL_282:
                      __int32 v188 = v5[6].i32[1];
                      v5[3].i32[1] = v130 + 1;
                      *(_DWORD *)(*(void *)&v132 + 4 * v130) = v188;
                      int v130 = v5[3].i32[1];
                    }
                    __int32 v189 = v5[5].i32[1];
                    v5[3].i32[1] = v130 + 1;
                    *(_DWORD *)(*(void *)&v132 + 4 * v130) = v189;
                    int v130 = v5[3].i32[1];
                  }
                  else
                  {
                    int8x8_t v132 = v5[2];
                    if (*(_DWORD *)(*(void *)&v132 + 4 * (v130 - 1)) != v5[5].i32[1]
                      || *(_DWORD *)(*(void *)&v132 + 4 * (v130 - 2)) != v5[6].i32[1])
                    {
                      goto LABEL_280;
                    }
                  }
LABEL_284:
                  int v190 = (char *)uprv_malloc(v129 + v130 + 48);
                  uint64_t v4 = v190;
                  if (v190)
                  {
                    *(_OWORD *)(v190 + 8) = 0u;
                    int v191 = (char **)(v190 + 8);
                    *(_OWORD *)(v190 + 24) = 0u;
                    signed int v192 = v5[6].i32[0];
                    *((_WORD *)v190 + 14) = (v192 + 4095) >> 12;
                    __int32 v193 = v5[4].i32[0];
                    uint64_t v194 = v5[3].i32[1];
                    *((_DWORD *)v190 + 4) = v124;
                    *((_DWORD *)v190 + 5) = v194;
                    *((_DWORD *)v190 + 6) = v192;
                    v190[30] = v272;
                    v190[31] = v126;
                    *((_WORD *)v190 + 19) = v5[1].i32[1];
                    __int32 v195 = v5[5].i32[0];
                    *((_DWORD *)v190 + 10) = v193;
                    *((_DWORD *)v190 + 11) = v195;
                    char v196 = v190 + 48;
                    *(void *)int v190 = v190 + 48;
                    if (v192 <= (int)v273)
                    {
                      if ((int)v124 < 1)
                      {
                        uint64_t v197 = v190 + 48;
                      }
                      else
                      {
                        char v198 = (int *)*v5;
                        uint64_t v197 = v190 + 48;
                        do
                        {
                          int v199 = *v198;
                          v198 += 4;
                          *(_WORD *)uint64_t v197 = v199;
                          v197 += 2;
                          LODWORD(v124) = v124 - 1;
                        }
                        while (v124);
                      }
                    }
                    else
                    {
                      memcpy(v190 + 48, *(const void **)&v5[7], v129);
                      uint64_t v197 = &v196[2 * (int)v124];
                    }
                    int v200 = &v196[v129];
                    unsigned int v201 = (int *)v5[2];
                    if (v126 == 2)
                    {
                      *int v191 = v200;
                      if ((int)v194 >= 1)
                      {
                        unsigned int v204 = v194 + 1;
                        do
                        {
                          int v205 = *v201++;
                          *v200++ = v205;
                          --v204;
                        }
                        while (v204 > 1);
                      }
                    }
                    else if (v126 == 1)
                    {
                      *int v191 = v200;
                      memcpy(v200, v201, 4 * v194);
                    }
                    else
                    {
                      *int v191 = v197;
                      if ((int)v194 >= 1)
                      {
                        unsigned int v202 = v194 + 1;
                        do
                        {
                          int v203 = *v201++;
                          *(_WORD *)uint64_t v197 = v203;
                          v197 += 2;
                          --v202;
                        }
                        while (v202 > 1);
                      }
                    }
                  }
                  else
                  {
                    *uint64_t v123 = 7;
                  }
                  v5[1].i32[1] = -1;
                  *(int8x8_t *)((char *)&v5[3] + 4) = (int8x8_t)0xFFFFFFFF00000000;
                  __int32 v206 = v5[4].i32[1];
                  v5[5].i32[0] = v206;
                  v5[6].i32[0] = 0;
                  v5[6].i32[1] = v206;
                  uprv_free(*(void **)&v5[7]);
                  goto LABEL_208;
                }
LABEL_219:
                int8x8_t v133 = v5[2];
                __int32 v134 = v5[3].i32[1];
                int v135 = *(_DWORD *)(*(void *)&v133 + 4 * (v134 - 1));
                __int32 v136 = v5[5].i32[1];
                if (v135 == v136)
                {
                  __int32 v137 = v5[6].i32[1];
                  if (*(_DWORD *)(*(void *)&v133 + 4 * (v134 - 2)) == v137)
                  {
LABEL_228:
                    int v130 = 4 * v134;
                    goto LABEL_284;
                  }
                }
                else
                {
                  __int32 v137 = v5[6].i32[1];
                }
                if (v135 != v137)
                {
                  v5[3].i32[1] = v134 + 1;
                  *(_DWORD *)(*(void *)&v133 + 4 * v134) = v137;
                  __int32 v136 = v5[5].i32[1];
                  __int32 v134 = v5[3].i32[1];
                }
                v5[3].i32[1] = v134 + 1;
                *(_DWORD *)(*(void *)&v133 + 4 * v134) = v136;
                __int32 v134 = v5[3].i32[1];
                goto LABEL_228;
              }
              __int32 v139 = v5[3].i32[1];
              int8x8_t v140 = v5[2];
              __int32 v141 = v139;
              if ((v139 ^ v124))
              {
                __int32 v142 = v5[5].i32[1];
                v5[3].i32[1] = v139 + 1;
                *(_DWORD *)(*(void *)&v140 + 4 * v139) = v142;
                __int32 v141 = v5[3].i32[1];
              }
              if (*(_DWORD *)(*(void *)&v140 + 4 * v141 - 4) == v5[5].i32[1])
              {
                __int32 v143 = v5[6].i32[1];
                if (*(_DWORD *)(*(void *)&v140 + 4 * v141 - 8) == v143) {
                  goto LABEL_238;
                }
              }
              else
              {
                __int32 v143 = v5[6].i32[1];
              }
              v5[3].i32[1] = v141 + 1;
              *(_DWORD *)(*(void *)&v140 + 4 * v141) = v143;
              __int32 v144 = v5[5].i32[1];
              uint64_t v145 = v5[3].i32[1];
              v5[3].i32[1] = v145 + 1;
              *(_DWORD *)(*(void *)&v140 + 4 * v145) = v144;
              __int32 v141 = v5[3].i32[1];
LABEL_238:
              int v130 = 2 * v141;
              goto LABEL_284;
            }
LABEL_365:
            LODWORD(v124) = 0;
          }
          else
          {
            LODWORD(v124) = 0;
            uint64_t v123 = v281;
          }
          *uint64_t v123 = 7;
          goto LABEL_368;
        }
      }
      if (SLODWORD(v291[0]) >= 1)
      {
        uint64_t v48 = 0;
        do
        {
          if (*((_DWORD *)&v291[8] + v48 + 2) == v37)
          {
            DWORD1(v291[0]) = v48;
            goto LABEL_76;
          }
          ++v48;
        }
        while (LODWORD(v291[0]) != v48);
        if (LODWORD(v291[0]) == 32) {
          goto LABEL_77;
        }
      }
      DWORD1(v291[0]) = v291[0];
      *((_DWORD *)v291 + SLODWORD(v291[0]) + 2) = v31;
      *((_DWORD *)&v291[8] + SLODWORD(v291[0]) + 2) = v37;
      uint64_t v49 = SLODWORD(v291[0]);
      ++LODWORD(v291[0]);
      goto LABEL_92;
    }
LABEL_41:
    unsigned int v24 = v18 >> 4;
    if (v18 >> 4 < v13)
    {
      unint64_t v25 = v13 - v24;
      int v26 = (_DWORD *)(*(void *)v0 + 4 * v24);
      int v27 = (char *)&v0[8] + v24;
      do
      {
        *v27++ = 0;
        *v26++ = *v16;
        --v25;
      }
      while (v25);
    }
    unsigned int v23 = v12;
    goto LABEL_45;
  }
  return 0;
}

uint64_t sub_18C88D068(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 48);
  if (v2 <= a2)
  {
    unsigned int v4 = (a2 & 0xFFFFFE00) + 512;
    int v5 = v2 >> 4;
    uint64_t v6 = v4 >> 4;
    if ((int)v6 > *(_DWORD *)(a1 + 8))
    {
      uint64_t result = (uint64_t)uprv_malloc(0x44000uLL);
      if (!result) {
        return result;
      }
      uint64_t v8 = result;
      unint64_t v9 = *(void **)a1;
      memcpy((void *)result, *(const void **)a1, 4 * v5);
      uprv_free(v9);
      *(void *)a1 = v8;
      *(_DWORD *)(a1 + 8) = 69632;
    }
    uint64_t v10 = v5;
    do
    {
      *(unsigned char *)(a1 + v10 + 64) = 0;
      *(_DWORD *)(*(void *)a1 + 4 * v10++) = *(_DWORD *)(a1 + 40);
    }
    while (v10 < v6);
    *(_DWORD *)(a1 + 48) = v4;
  }
  return 1;
}

uint64_t sub_18C88D12C(void *a1, int a2)
{
  uint64_t v4 = a2;
  int v5 = (char *)a1 + a2;
  int v7 = v5[64];
  uint64_t v6 = v5 + 64;
  if (v7 == 1) {
    return *(unsigned int *)(*a1 + 4 * a2);
  }
  if (a2 > 4095)
  {
    uint64_t result = sub_18C88D248((uint64_t)a1, 16);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v18 = 0;
      uint64_t v19 = a1[2] + 4 * result;
      uint64_t v20 = (const float *)(*a1 + 4 * v4);
      float32x4_t v21 = vld1q_dup_f32(v20);
      do
      {
        *(float32x4_t *)(v19 + v18) = v21;
        v18 += 16;
      }
      while (v18 != 64);
      *uint64_t v6 = 1;
      *(_DWORD *)(*a1 + 4 * v4) = result;
    }
  }
  else
  {
    uint64_t result = sub_18C88D248((uint64_t)a1, 64);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v9 = (int)(a2 & 0xFFFFFFFC);
      uint64_t v10 = *a1;
      uint64_t v11 = 4 * result;
      uint64_t v12 = result;
      do
      {
        uint64_t v13 = 0;
        uint64_t v14 = a1[2];
        uint64_t v15 = (const float *)(v10 + 4 * v9);
        float32x4_t v16 = vld1q_dup_f32(v15);
        do
        {
          *(float32x4_t *)(v14 + v11 + v13) = v16;
          v13 += 16;
        }
        while (v13 != 64);
        *((unsigned char *)a1 + v9 + 64) = 1;
        uint64_t v10 = *a1;
        *(_DWORD *)(*a1 + 4 * v9) = v12;
        v12 += 16;
        v11 += 64;
      }
      while (v9++ < (a2 | 3));
      return *(unsigned int *)(v10 + 4 * v4);
    }
  }
  return result;
}

uint64_t sub_18C88D248(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(a1 + 28);
  int v5 = v4 + a2;
  if ((int)v4 + a2 <= v3) {
    goto LABEL_8;
  }
  if (v3 >= 0x20000)
  {
    if (HIWORD(v3) > 0x10u) {
      return 0xFFFFFFFFLL;
    }
    int v6 = 1114112;
  }
  else
  {
    int v6 = 0x20000;
  }
  int v7 = uprv_malloc((4 * v6));
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void **)(a1 + 16);
  memcpy(v7, v9, 4 * *(int *)(a1 + 28));
  uprv_free(v9);
  *(void *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 24) = v6;
LABEL_8:
  *(_DWORD *)(a1 + 28) = v5;
  return v4;
}

uint64_t sub_18C88D2EC(uint64_t a1, int a2, int a3)
{
  unsigned int v5 = a2 - a3;
  if (a2 - a3 > 4094)
  {
    if (v5 > 0x7FFE)
    {
      if (v5 > 0x1FFFE)
      {
        *(void *)(a1 + 16) = 0x1FFFFF00000015;
        int v6 = 1500007;
      }
      else
      {
        *(void *)(a1 + 16) = 0x1FFFF00000011;
        int v6 = 200003;
      }
    }
    else
    {
      *(void *)(a1 + 16) = 0x7FFF0000000FLL;
      int v6 = 50021;
    }
  }
  else
  {
    *(void *)(a1 + 16) = 0xFFF0000000CLL;
    int v6 = 6007;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t result = *(void *)a1;
  if (v6 <= v7)
  {
    size_t v9 = (4 * v6);
  }
  else
  {
    uprv_free((void *)result);
    size_t v9 = (4 * v6);
    uint64_t result = (uint64_t)uprv_malloc(v9);
    *(void *)a1 = result;
    if (!result) {
      return result;
    }
    *(_DWORD *)(a1 + 8) = v6;
  }
  *(_DWORD *)(a1 + 12) = v6;
  bzero((void *)result, v9);
  *(_DWORD *)(a1 + 24) = a3;
  return 1;
}

uint64_t sub_18C88D3D8(uint64_t result, uint64_t a2, int a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  if (a3 >= v4) {
    int v5 = a3 - v4 + 1;
  }
  else {
    int v5 = 0;
  }
  int v6 = a4 - v4;
  if (v5 <= a4 - v4)
  {
    uint64_t v8 = result;
    do
    {
      int v9 = v5;
      uint64_t v10 = *(int *)(v8 + 24) + (uint64_t)v5++;
      unsigned int v11 = *(_DWORD *)(a2 + 4 * v9);
      uint64_t v12 = v5;
      do
        unsigned int v11 = *(_DWORD *)(a2 + 4 * v12++) + 37 * v11;
      while (v12 < v10);
      uint64_t result = sub_18C88D49C(v8, a2, a2, v9, v11);
      if ((result & 0x80000000) != 0) {
        *(_DWORD *)(*(void *)v8 + 4 * ~result) = (v11 << *(_DWORD *)(v8 + 16)) | v5;
      }
    }
    while (v5 <= v6);
  }
  return result;
}

uint64_t sub_18C88D49C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  int v5 = *(_DWORD *)(a1 + 12);
  signed int v6 = a5 % (v5 - 1) + 1;
  int v7 = *(_DWORD *)(*(void *)a1 + 4 * v6);
  if (v7)
  {
    int v8 = *(_DWORD *)(a1 + 20);
    int v9 = (_DWORD *)(a3 + 4 * a4);
    uint64_t v10 = a5 % (v5 - 1) + 1;
    do
    {
      if ((v7 & ~v8) == a5 << *(_DWORD *)(a1 + 16))
      {
        int v11 = *(_DWORD *)(a1 + 24);
        if (v11 < 1)
        {
          if (!v11) {
            return v10;
          }
        }
        else
        {
          uint64_t v12 = (_DWORD *)(a2 + 4 * ((v8 & v7) - 1));
          int v13 = v11 + 1;
          for (uint64_t i = v9; *v12 == *i; ++i)
          {
            ++v12;
            if (--v13 <= 1) {
              return v10;
            }
          }
        }
      }
      uint64_t v10 = (((int)v10 + v6) % v5);
      int v7 = *(_DWORD *)(*(void *)a1 + 4 * (int)v10);
    }
    while (v7);
  }
  else
  {
    LODWORD(v10) = a5 % (v5 - 1) + 1;
  }
  return ~v10;
}

uint64_t sub_18C88D550(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  int v5 = *(_DWORD *)(result + 24);
  if (a4 - v5 >= a3) {
    int v6 = a4 - v5 + 1;
  }
  else {
    int v6 = a3;
  }
  int v7 = a5 - v5;
  if (v6 <= a5 - v5)
  {
    uint64_t v9 = result;
    do
    {
      int v10 = v6;
      uint64_t v11 = *(int *)(v9 + 24) + (uint64_t)v6++;
      unsigned int v12 = *(unsigned __int16 *)(a2 + 2 * v10);
      uint64_t v13 = v6;
      do
        unsigned int v12 = *(unsigned __int16 *)(a2 + 2 * v13++) + 37 * v12;
      while (v13 < v11);
      uint64_t result = sub_18C88D790(v9, a2, a2, v10, v12);
      if ((result & 0x80000000) != 0) {
        *(_DWORD *)(*(void *)v9 + 4 * ~result) = (v12 << *(_DWORD *)(v9 + 16)) | v6;
      }
    }
    while (v6 <= v7);
  }
  return result;
}

uint64_t sub_18C88D618(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *((_DWORD *)a1 + 6);
  int v5 = (unsigned int *)(a3 + 4 * a4);
  unsigned int v6 = *v5;
  uint64_t v7 = a4 + 1;
  do
    unsigned int v6 = *(_DWORD *)(a3 + 4 * v7++) + 37 * v6;
  while (v7 < v4 + a4);
  int v8 = *((_DWORD *)a1 + 3);
  signed int v9 = v6 % (v8 - 1) + 1;
  uint64_t v10 = *a1;
  int v11 = *(_DWORD *)(*a1 + 4 * v9);
  if (v11)
  {
    int v12 = *((_DWORD *)a1 + 5);
    unsigned int v13 = v6 << *((_DWORD *)a1 + 4);
    int v14 = v6 % (v8 - 1) + 1;
    do
    {
      if ((v11 & ~v12) == v13)
      {
        if (v4 < 1)
        {
          if (!v4) {
            goto LABEL_16;
          }
        }
        else
        {
          uint64_t v15 = (unsigned __int16 *)(a2 + 2 * ((v11 & v12) - 1));
          int v16 = v4 + 1;
          __int32 v17 = v5;
          while (*v17 == *v15)
          {
            ++v15;
            ++v17;
            if (--v16 <= 1) {
              goto LABEL_16;
            }
          }
        }
      }
      int v14 = (v14 + v9) % v8;
      int v11 = *(_DWORD *)(v10 + 4 * v14);
    }
    while (v11);
  }
  else
  {
    int v14 = v6 % (v8 - 1) + 1;
  }
  int v14 = ~v14;
LABEL_16:
  if (v14 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return ((*((_DWORD *)a1 + 5) & *(_DWORD *)(v10 + 4 * v14)) - 1);
  }
}

uint64_t sub_18C88D718(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v5 = *(unsigned __int16 *)(a3 + 2 * a4);
  uint64_t v6 = a4 + 1;
  do
    unsigned int v5 = *(unsigned __int16 *)(a3 + 2 * v6++) + 37 * v5;
  while (v6 < *(int *)(a1 + 24) + (uint64_t)a4);
  unsigned int v7 = sub_18C88D790(a1, a2, a3, a4, v5);
  if ((v7 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return ((*(_DWORD *)(a1 + 20) & *(_DWORD *)(*(void *)a1 + 4 * v7)) - 1);
  }
}

uint64_t sub_18C88D790(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  int v5 = *(_DWORD *)(a1 + 12);
  signed int v6 = a5 % (v5 - 1) + 1;
  int v7 = *(_DWORD *)(*(void *)a1 + 4 * v6);
  if (v7)
  {
    int v8 = *(_DWORD *)(a1 + 20);
    signed int v9 = (unsigned __int16 *)(a3 + 2 * a4);
    uint64_t v10 = a5 % (v5 - 1) + 1;
    do
    {
      if ((v7 & ~v8) == a5 << *(_DWORD *)(a1 + 16))
      {
        int v11 = *(_DWORD *)(a1 + 24);
        if (v11 < 1)
        {
          if (!v11) {
            return v10;
          }
        }
        else
        {
          int v12 = (unsigned __int16 *)(a2 + 2 * ((v8 & v7) - 1));
          int v13 = v11 + 1;
          for (uint64_t i = v9; *v12 == *i; ++i)
          {
            ++v12;
            if (--v13 <= 1) {
              return v10;
            }
          }
        }
      }
      uint64_t v10 = (((int)v10 + v6) % v5);
      int v7 = *(_DWORD *)(*(void *)a1 + 4 * (int)v10);
    }
    while (v7);
  }
  else
  {
    LODWORD(v10) = a5 % (v5 - 1) + 1;
  }
  return ~v10;
}

unint64_t icu::UMutex::getMutex(icu::UMutex *this)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 8, memory_order_acquire);
  if (!explicit)
  {
    if (atomic_load_explicit(&qword_1EB20B538, memory_order_acquire) != -1)
    {
      signed int v6 = &v7;
      int v7 = sub_18C88D928;
      std::__call_once((std::once_flag::_State_type *)&qword_1EB20B538, &v6, (void (__cdecl *)(void *))sub_18C88DBFC);
    }
    int v3 = (std::mutex *)qword_1EB20B528;
    std::mutex::lock((std::mutex *)qword_1EB20B528);
    int v4 = (unint64_t *)((char *)this + 64);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 8, memory_order_acquire);
    if (!explicit)
    {
      *(void *)this = 850045863;
      *(_OWORD *)((char *)this + 8) = 0u;
      *(_OWORD *)((char *)this + 24) = 0u;
      *(_OWORD *)((char *)this + 40) = 0u;
      *((void *)this + 7) = 0;
      atomic_store((unint64_t)this, v4);
      unint64_t explicit = atomic_load(v4);
      *((void *)this + 9) = icu::UMutex::gListHead;
      icu::UMutex::gListHead = (uint64_t)this;
    }
    std::mutex::unlock(v3);
  }
  return explicit;
}

void sub_18C88D928()
{
  qword_1EB20B540 = 850045863;
  unk_1EB20B548 = 0u;
  unk_1EB20B558 = 0u;
  unk_1EB20B568 = 0u;
  qword_1EB20B528 = (uint64_t)&qword_1EB20B540;
  qword_1EB20B578 = 0;
  qword_1EB20B580 = 1018212795;
  unk_1EB20B588 = 0u;
  unk_1EB20B598 = 0u;
  qword_1EB20B5A8 = 0;
  qword_1EB20B530 = (uint64_t)&qword_1EB20B580;
  sub_18C8546F4(0x1Du, (uint64_t)sub_18C88DBC0);
}

void icu::UMutex::cleanup(icu::UMutex *this)
{
  uint64_t v1 = icu::UMutex::gListHead;
  if (icu::UMutex::gListHead)
  {
    do
    {
      int v2 = (std::mutex *)atomic_load((unint64_t *)(v1 + 64));
      std::mutex::~mutex(v2);
      atomic_store(0, (unint64_t *)(v1 + 64));
      uint64_t v3 = *(void *)(v1 + 72);
      *(void *)(v1 + 72) = 0;
      uint64_t v1 = v3;
    }
    while (v3);
  }
  icu::UMutex::gListHead = 0;
}

void umtx_lock(atomic_ullong *a1)
{
  if (!a1) {
    a1 = (atomic_ullong *)&unk_1EB20B5B0;
  }
  sub_18C88DA00(a1);
}

void sub_18C88DA00(atomic_ullong *this)
{
  unint64_t explicit = (std::mutex *)atomic_load_explicit(this + 8, memory_order_acquire);
  if (!explicit) {
    unint64_t explicit = (std::mutex *)icu::UMutex::getMutex((icu::UMutex *)this);
  }

  std::mutex::lock(explicit);
}

void umtx_unlock(std::mutex **a1)
{
  uint64_t v1 = (std::mutex **)&unk_1EB20B5B0;
  if (a1) {
    uint64_t v1 = a1;
  }
  std::mutex::unlock(v1[8]);
}

uint64_t icu::umtx_initImplPreInit(atomic_uint *a1)
{
  if (atomic_load_explicit(&qword_1EB20B538, memory_order_acquire) != -1)
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_18C88D928;
    p_lsize_t k = &__lk;
    std::__call_once((std::once_flag::_State_type *)&qword_1EB20B538, &p_lk, (void (__cdecl *)(void *))sub_18C88DBFC);
  }
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)qword_1EB20B528;
  uint64_t v2 = 1;
  *(void *)&__lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)qword_1EB20B528);
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    while (atomic_load_explicit(a1, memory_order_acquire) == 1)
      std::condition_variable::wait((std::condition_variable *)qword_1EB20B530, &__lk);
    uint64_t v2 = 0;
  }
  else
  {
    atomic_store(1u, (unsigned int *)a1);
  }
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  return v2;
}

void icu::umtx_initImplPostInit(unsigned int *a1)
{
  uint64_t v2 = (std::mutex *)qword_1EB20B528;
  std::mutex::lock((std::mutex *)qword_1EB20B528);
  atomic_store(2u, a1);
  std::mutex::unlock(v2);
  uint64_t v3 = (std::condition_variable *)qword_1EB20B530;

  std::condition_variable::notify_all(v3);
}

void u_setMutexFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*a6 <= 0) {
    *a6 = 16;
  }
}

void u_setAtomicIncDecFunctions(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0) {
    *a4 = 16;
  }
}

uint64_t sub_18C88DBC0()
{
  std::mutex::~mutex((std::mutex *)qword_1EB20B528);
  std::condition_variable::~condition_variable((std::condition_variable *)qword_1EB20B530);
  icu::UMutex::cleanup(v0);
  qword_1EB20B538 = 0;
  return 1;
}

uint64_t sub_18C88DBFC(uint64_t (***a1)(void))
{
  return (**a1)();
}

int32_t u_charName(UChar32 code, UCharNameChoice nameChoice, char *buffer, int32_t bufferLength, UErrorCode *pErrorCode)
{
  if (!pErrorCode || *(int *)pErrorCode > 0) {
    return 0;
  }
  if ((int)nameChoice > (int)U_CHAR_NAME_ALIAS || bufferLength < 0 || !buffer && bufferLength)
  {
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  if (HIWORD(code) <= 0x10u && sub_18C88DD84(pErrorCode))
  {
    int v11 = (int *)(qword_1E9191E90 + *(unsigned int *)(qword_1E9191E90 + 12));
    int v12 = *v11;
    if (*v11)
    {
      uint64_t v13 = (uint64_t)(v11 + 1);
      while (*(_DWORD *)v13 > code || *(_DWORD *)(v13 + 4) < code)
      {
        v13 += *(unsigned __int16 *)(v13 + 10);
        if (!--v12) {
          goto LABEL_16;
        }
      }
      uint64_t v15 = sub_18C88DE14(v13, code, nameChoice, buffer, (unsigned __int16)bufferLength);
    }
    else
    {
LABEL_16:
      if (nameChoice == U_EXTENDED_CHAR_NAME)
      {
        uint64_t v14 = sub_18C88DFAC((unsigned int *)qword_1E9191E90, code, 2, buffer, (unsigned __int16)bufferLength);
        if (v14)
        {
LABEL_23:
          int v16 = buffer;
          int32_t v17 = bufferLength;
          goto LABEL_24;
        }
        uint64_t v15 = sub_18C88E0FC(code, buffer, (unsigned __int16)bufferLength);
      }
      else
      {
        uint64_t v15 = sub_18C88DFAC((unsigned int *)qword_1E9191E90, code, nameChoice, buffer, (unsigned __int16)bufferLength);
      }
    }
    uint64_t v14 = v15;
    goto LABEL_23;
  }
  int v16 = buffer;
  int32_t v17 = bufferLength;
  uint64_t v14 = 0;
LABEL_24:

  return u_terminateChars((uint64_t)v16, v17, v14, (int *)pErrorCode);
}

BOOL sub_18C88DD84(UErrorCode *a1)
{
  if (*(int *)a1 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191EBC, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191EBC))
    {
      if (dword_1E9191EC0 >= 1) {
        *a1 = dword_1E9191EC0;
      }
    }
    else
    {
      sub_18C89003C(a1);
      dword_1E9191EC0 = *a1;
      icu::umtx_initImplPostInit(&dword_1E9191EBC);
    }
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

uint64_t sub_18C88DE14(uint64_t a1, unsigned int a2, int a3, unsigned char *a4, int a5)
{
  int v5 = a4;
  v24[2] = *MEMORY[0x1E4F143B8];
  if ((a3 & 0xFFFFFFFD) != 0)
  {
LABEL_2:
    unsigned __int16 v6 = 0;
    if (a5) {
      *a4 = 0;
    }
    return v6;
  }
  if (*(unsigned char *)(a1 + 8) == 1)
  {
    v24[0] = 0;
    v24[1] = 0;
    uint64_t v11 = *(unsigned __int8 *)(a1 + 9);
    int v12 = (unsigned __int8 *)(a1 + 12 + 2 * v11);
    int v15 = *v12;
    uint64_t v13 = v12 + 1;
    char v14 = v15;
    if (v15)
    {
      __int16 v16 = 0;
      do
      {
        if ((_WORD)a5)
        {
          *v5++ = v14;
          LOWORD(a5) = a5 - 1;
        }
        else
        {
          LOWORD(a5) = 0;
        }
        ++v16;
        int v17 = *v13++;
        char v14 = v17;
      }
      while (v17);
    }
    else
    {
      __int16 v16 = 0;
    }
    return (unsigned __int16)(sub_18C890194(a1 + 12, v11, v13, a2 - *(_DWORD *)a1, v24, 0, 0, v5, a5) + v16);
  }
  else
  {
    if (*(unsigned char *)(a1 + 8)) {
      goto LABEL_2;
    }
    char v7 = *(unsigned char *)(a1 + 12);
    if (v7)
    {
      __int16 v8 = 0;
      signed int v9 = (unsigned __int8 *)(a1 + 13);
      do
      {
        if ((_WORD)a5)
        {
          *v5++ = v7;
          LOWORD(a5) = a5 - 1;
        }
        else
        {
          LOWORD(a5) = 0;
        }
        ++v8;
        int v10 = *v9++;
        char v7 = v10;
      }
      while (v10);
    }
    else
    {
      __int16 v8 = 0;
    }
    uint64_t v18 = *(unsigned __int8 *)(a1 + 9);
    if (v18 < (unsigned __int16)a5) {
      v5[v18] = 0;
    }
    if (v18)
    {
      uint64_t v19 = &v5[(unsigned __int16)(v18 - 1)];
      unsigned __int16 v20 = v18 - 1;
      do
      {
        if ((unsigned __int16)a5 > v20)
        {
          if ((a2 & 0xF) >= 0xA) {
            char v21 = (a2 & 0xF) + 55;
          }
          else {
            char v21 = a2 & 0xF | 0x30;
          }
          *uint64_t v19 = v21;
        }
        a2 >>= 4;
        --v19;
      }
      while (v20--);
    }
    return (unsigned __int16)(v8 + v18);
  }
}

uint64_t sub_18C88DFAC(unsigned int *a1, unsigned int a2, int a3, char *a4, int a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v10 = sub_18C890288((uint64_t)a1, a2);
  if (*v10 == (unsigned __int16)(a2 >> 5))
  {
    unsigned int v11 = a2 & 0x1F;
    int v19 = 0;
    memset(v18, 0, sizeof(v18));
    int v17 = 0;
    memset(v16, 0, sizeof(v16));
    int v12 = sub_18C88FF90((unsigned __int8 *)a1 + a1[2] + ((v10[1] << 16) | (unint64_t)v10[2]), v18, v16);
    int v13 = *((unsigned __int16 *)v16 + v11);
    char v14 = &v12[*((unsigned __int16 *)v18 + v11)];
    return sub_18C8902F4(a1, v14, v13, a3, a4, a5);
  }
  else
  {
    if (a5) {
      *a4 = 0;
    }
    return 0;
  }
}

uint64_t sub_18C88E0FC(unsigned int a1, char *a2, int a3)
{
  int v5 = a1;
  unsigned int v6 = sub_18C88E828(a1);
  if (v6 <= 0x20)
  {
    char v7 = off_1E5508770[v6];
    if (a3) {
      goto LABEL_3;
    }
  }
  else
  {
    char v7 = "unknown";
    if (a3)
    {
LABEL_3:
      *a2++ = 60;
      __int16 v8 = a3 - 1;
      goto LABEL_6;
    }
  }
  __int16 v8 = 0;
LABEL_6:
  char v9 = *v7;
  if (*v7)
  {
    __int16 v10 = 1;
    do
    {
      __int16 v11 = v10;
      if (v8)
      {
        *a2++ = v9;
        --v8;
      }
      else
      {
        __int16 v8 = 0;
      }
      ++v10;
      char v9 = v7[(unsigned __int16)(v11 + 1) - 1];
    }
    while (v9);
    __int16 v12 = v11 + 3;
  }
  else
  {
    __int16 v12 = 3;
  }
  if (v8)
  {
    *a2++ = 45;
    __int16 v13 = v8 - 1;
  }
  else
  {
    __int16 v13 = 0;
  }
  int v14 = 0;
  if (v5)
  {
    int v15 = v5;
    do
    {
      ++v14;
      BOOL v16 = v15 > 0xF;
      v15 >>= 4;
    }
    while (v16);
  }
  if (v14 <= 4) {
    int v14 = 4;
  }
  if ((v14 > 0 || v5 != 0) && v13 != 0)
  {
    uint64_t v19 = v14;
    do
    {
      if ((v5 & 0xFu) >= 0xA) {
        char v20 = (v5 & 0xF) + 55;
      }
      else {
        char v20 = v5 & 0xF | 0x30;
      }
      a2[v19 - 1] = v20;
      --v13;
      if (v19 < 2 && v5 < 0x10) {
        break;
      }
      --v19;
      v5 >>= 4;
    }
    while (v13);
  }
  if (v13) {
    a2[v14] = 62;
  }
  return (unsigned __int16)(v12 + v14);
}

int32_t u_getISOComment(UChar32 c, char *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  if (!pErrorCode || *(int *)pErrorCode > 0) {
    return 0;
  }
  if (destCapacity < 0 || !dest && destCapacity)
  {
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  return u_terminateChars((uint64_t)dest, destCapacity, 0, (int *)pErrorCode);
}

UChar32 u_charFromName(UCharNameChoice nameChoice, const char *name, UErrorCode *pErrorCode)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v65 = 0;
  memset(v64, 0, sizeof(v64));
  uint64_t v63 = 0;
  memset(v62, 0, sizeof(v62));
  if (!pErrorCode || *(int *)pErrorCode > 0) {
    return 0xFFFF;
  }
  uint64_t v4 = *(void *)&nameChoice;
  UErrorCode v5 = U_ILLEGAL_ARGUMENT_ERROR;
  if ((int)nameChoice > (int)U_CHAR_NAME_ALIAS) {
    goto LABEL_75;
  }
  unsigned int v6 = name;
  if (!name || !*name) {
    goto LABEL_75;
  }
  if (!sub_18C88DD84(pErrorCode)) {
    return 0xFFFF;
  }
  uint64_t v7 = 0;
  unsigned int v8 = -1;
  while (1)
  {
    char v9 = *v6;
    if (!*v6) {
      break;
    }
    ++v6;
    int v10 = v9;
    *((unsigned char *)v64 + v7) = uprv_toupper(v9);
    *((unsigned char *)v62 + v7++) = uprv_asciitolower(v10);
    ++v8;
    if (v7 == 120) {
      goto LABEL_74;
    }
  }
  *((unsigned char *)v62 + v7) = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  *((unsigned char *)v64 + v7) = 0;
  if (LOBYTE(v62[0]) == 60)
  {
    if (v4 == 2)
    {
      unsigned int v11 = v7 - 1;
      if (*((unsigned char *)v62 + (v7 - 1)) == 62)
      {
        if (v11 < 3)
        {
          if (v7 != 3) {
            goto LABEL_74;
          }
          unsigned int v16 = 2;
        }
        else
        {
          uint64_t v12 = -1;
          do
          {
            unint64_t v13 = v8 + v12;
            int v14 = *((unsigned __int8 *)v62 + v8 + v12--);
          }
          while (v14 != 45 && v13 > 2);
          unsigned int v16 = v7 + v12;
        }
        if (*((unsigned char *)v62 + v16) == 45 && v7 - v16 - 3 <= 7)
        {
          int v32 = 0;
          *((unsigned char *)v62 + v16) = 0;
          unsigned int v52 = v16 + 1;
          unsigned int v53 = v11 <= v16 + 1 ? v16 + 1 : v7 - 1;
          while (v52 < v11)
          {
            int v54 = *((char *)v62 + v52);
            if ((v54 - 48) >= 0xA)
            {
              if ((v54 - 97) > 5) {
                goto LABEL_74;
              }
              int v55 = -87;
            }
            else
            {
              int v55 = -48;
            }
            int v32 = v55 + 16 * v32 + v54;
            ++v52;
            UErrorCode v5 = U_ILLEGAL_CHAR_FOUND;
            if (v32 >= 1114112) {
              goto LABEL_75;
            }
          }
          int v56 = sub_18C88E828(v32);
          uint64_t v57 = 0;
          *((unsigned char *)v62 + v53) = 0;
          while (strcmp((const char *)v62 + 1, off_1E5508770[v57]))
          {
            ++v57;
            UErrorCode v5 = U_ILLEGAL_CHAR_FOUND;
            if (v57 == 33) {
              goto LABEL_75;
            }
          }
          if ((v57 * 8) == 8 * v56) {
            return v32;
          }
        }
      }
    }
LABEL_74:
    UErrorCode v5 = U_ILLEGAL_CHAR_FOUND;
LABEL_75:
    *UErrorCode pErrorCode = v5;
    return 0xFFFF;
  }
  uint64_t v17 = qword_1E9191E90;
  uint64_t v18 = (int *)(qword_1E9191E90 + *(unsigned int *)(qword_1E9191E90 + 12));
  int v19 = *v18;
  if (!*v18) {
    goto LABEL_73;
  }
  char v20 = v18 + 1;
  int v21 = v4 & 0xFFFFFFFD;
  long long v22 = 0uLL;
  do
  {
    if (v21) {
      goto LABEL_24;
    }
    if (*((unsigned char *)v20 + 8) == 1)
    {
      long long v71 = v22;
      long long v72 = v22;
      *(_OWORD *)long long __s2 = v22;
      long long v70 = v22;
      v68[0] = 0;
      v68[1] = 0;
      v67[2] = v22;
      v67[3] = v22;
      v67[0] = v22;
      v67[1] = v22;
      v66[2] = v22;
      v66[3] = v22;
      v66[0] = v22;
      v66[1] = v22;
      int v26 = v20 + 3;
      uint64_t v27 = *((unsigned __int8 *)v20 + 9);
      unint64_t v28 = (unsigned __int8 *)v20 + 2 * v27 + 13;
      int v29 = (const char *)v64;
      while (1)
      {
        int v30 = *(v28 - 1);
        if (!*(v28 - 1)) {
          break;
        }
        ++v28;
        int v31 = *(unsigned __int8 *)v29++;
        if (v30 != v31)
        {
          int v32 = 0xFFFF;
          goto LABEL_71;
        }
      }
      int v32 = *v20;
      int v58 = v20[1];
      int v59 = v19;
      sub_18C890194((uint64_t)(v20 + 3), v27, v28, 0, v68, v67, v66, __s2, 64);
      if (!strcmp(v29, __s2))
      {
        int v19 = v59;
        int v21 = v4 & 0xFFFFFFFD;
        long long v22 = 0uLL;
      }
      else
      {
        ++v32;
        long long v22 = 0uLL;
        if (v32 >= v58 + 1)
        {
LABEL_68:
          int v19 = v59;
          int v21 = v4 & 0xFFFFFFFD;
          goto LABEL_24;
        }
        uint64_t v38 = (unsigned __int16)(v27 - 1);
        while (1)
        {
          unsigned __int16 v39 = *((_WORD *)v68 + v38) + 1;
          uint64_t v40 = (unsigned __int16)(v27 - 1);
          int v41 = v27 - 1;
          if (*((unsigned __int16 *)v26 + v38) <= v39)
          {
            do
            {
              *((_WORD *)v68 + v40) = 0;
              *((void *)v66 + v40) = *((void *)v67 + v40);
              uint64_t v40 = (unsigned __int16)--v41;
              unsigned __int16 v39 = *((_WORD *)v68 + (unsigned __int16)v41) + 1;
            }
            while (*((unsigned __int16 *)v26 + (unsigned __int16)v41) <= v39);
          }
          *((_WORD *)v68 + v40) = v39;
          int v42 = (unsigned __int8 *)*((void *)v66 + v40);
          while (*v42++)
            ;
          *((void *)v66 + v40) = v42;
          long long v44 = v29;
          if (!v27) {
            goto LABEL_102;
          }
          unsigned __int16 v45 = 0;
          long long v44 = v29;
          do
          {
            int v46 = (const char *)*((void *)v66 + v45);
            while (1)
            {
              int v47 = *(unsigned __int8 *)v46;
              if (!*v46) {
                break;
              }
              int v48 = *(unsigned __int8 *)v44++;
              BOOL v49 = v47 == v48;
              if (v47 == v48) {
                ++v46;
              }
              else {
                int v46 = "";
              }
              if (!v49) {
                unsigned __int16 v45 = 99;
              }
            }
            ++v45;
          }
          while (v27 > v45);
          if (v45 <= 0x62u)
          {
LABEL_102:
            if (!*v44) {
              break;
            }
          }
          BOOL v49 = v32++ == v58;
          if (v49) {
            goto LABEL_68;
          }
        }
        int v19 = v59;
        int v21 = v4 & 0xFFFFFFFD;
      }
    }
    else
    {
      if (*((unsigned char *)v20 + 8)) {
        goto LABEL_24;
      }
      uint64_t v23 = 0;
      while (1)
      {
        int v24 = *((unsigned __int8 *)v20 + v23 + 12);
        if (!*((unsigned char *)v20 + v23 + 12)) {
          break;
        }
        int v25 = *((unsigned __int8 *)v64 + v23++);
        if (v24 != v25) {
          goto LABEL_24;
        }
      }
      int v33 = (char *)v64 + v23;
      int v32 = 0;
      if (*((unsigned char *)v20 + 9))
      {
        uint64_t v34 = (unsigned __int16)(*((unsigned __int8 *)v20 + 9) - 1) + 1;
        do
        {
          int v36 = (char)*v33++;
          int v35 = v36;
          if ((v36 - 48) >= 0xA)
          {
            if ((v35 - 65) > 5) {
              goto LABEL_24;
            }
            int v37 = -55;
          }
          else
          {
            int v37 = -48;
          }
          int v32 = (v37 + v35) | (16 * v32);
          --v34;
        }
        while (v34);
      }
      if (*v33 || *v20 > v32 || v32 > v20[1]) {
        goto LABEL_24;
      }
    }
LABEL_71:
    if (v32 != 0xFFFF) {
      return v32;
    }
LABEL_24:
    char v20 = (int *)((char *)v20 + *((unsigned __int16 *)v20 + 5));
    --v19;
  }
  while (v19);
  uint64_t v17 = qword_1E9191E90;
  uint64_t v4 = v4;
LABEL_73:
  uint64_t v60 = v64;
  LODWORD(v61) = 0xFFFF;
  sub_18C88E8A8(v17, 0, 1114112, 0, (uint64_t)&v60, v4);
  int v32 = v61;
  if (v61 == 0xFFFF) {
    goto LABEL_74;
  }
  return v32;
}

uint64_t sub_18C88E828(unsigned int c)
{
  if ((int)c >= 64976 && (c >> 4 < 0xFDF || HIWORD(c) <= 0x10u && (c & 0xFFFE) == 0xFFFE))
  {
    return 30;
  }
  else
  {
    int v3 = u_charType(c);
    if (c >> 10 == 54) {
      unsigned __int8 v2 = 31;
    }
    else {
      unsigned __int8 v2 = 32;
    }
    if (v3 != 18) {
      return v3;
    }
  }
  return v2;
}

uint64_t sub_18C88E8A8(uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a5, uint64_t a6)
{
  uint64_t v12 = sub_18C890288(a1, a2);
  unint64_t v13 = v12;
  unsigned int v14 = (unsigned __int16)(a2 >> 5);
  uint64_t v15 = a2;
  if (a6 == 2)
  {
    unsigned int v16 = *v12;
    uint64_t v15 = a2;
    if (v14 < v16)
    {
      int v17 = 32 * v16;
      uint64_t v15 = v17 >= a3 ? a3 : v17;
      uint64_t result = sub_18C890468(a2, (int)v15 - 1, a4, a5);
      if (!result) {
        return result;
      }
    }
  }
  unsigned int v19 = a3 - 1;
  unsigned int v20 = (a3 - 1) >> 5;
  if (v14 == (unsigned __int16)v20)
  {
    if (*v13 == (unsigned __int16)(a2 >> 5))
    {
      int v21 = (unsigned __int8 *)a1;
      uint64_t v22 = (uint64_t)v13;
      uint64_t v23 = v15;
LABEL_37:
      return sub_18C89054C(v21, v22, v23, a3 - 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4, a5, a6);
    }
    if (a6 != 2) {
      return 1;
    }
    goto LABEL_45;
  }
  unint64_t v24 = a1 + *(unsigned int *)(a1 + 4) + 6 * *(unsigned __int16 *)(a1 + *(unsigned int *)(a1 + 4)) + 2;
  unsigned int v25 = *v13;
  if (v14 == v25)
  {
    if ((v15 & 0x1F) != 0)
    {
      uint64_t result = sub_18C89054C((unsigned __int8 *)a1, (uint64_t)v13, v15, (32 * v14) | 0x1F, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4, a5, a6);
      if (!result) {
        return result;
      }
      v13 += 3;
      unsigned int v20 = (a3 - 1) >> 5;
    }
  }
  else if (v14 > v25)
  {
    v13 += 3;
    if ((unint64_t)v13 < v24 && a6 == 2)
    {
      unsigned int v26 = *v13;
      if (v14 < v26)
      {
        int v27 = 32 * v26;
        if (v27 >= a3) {
          int v27 = a3;
        }
        uint64_t result = sub_18C890468(v15, v27 - 1, a4, a5);
        unsigned int v20 = v19 >> 5;
        if (!result) {
          return result;
        }
      }
    }
  }
  if ((unint64_t)v13 >= v24)
  {
LABEL_40:
    uint64_t result = 1;
    if (a6 != 2 || v13 != (unsigned __int16 *)v24) {
      return result;
    }
    int v34 = 32 * *(unsigned __int16 *)(v24 - 6) + 32;
    if (v34 <= (int)v15) {
      uint64_t v15 = v15;
    }
    else {
      uint64_t v15 = v34;
    }
LABEL_45:
    if (a3 >= 1114112) {
      int v35 = 1114112;
    }
    else {
      int v35 = a3;
    }
    return sub_18C890468(v15, v35 - 1, a4, a5);
  }
  unsigned int v28 = (unsigned __int16)(v19 >> 5);
  unsigned int v29 = *v13;
  if (v28 <= v29)
  {
LABEL_35:
    if (v29 == (unsigned __int16)v20)
    {
      uint64_t v23 = v19 & 0xFFFFFFE0;
      int v21 = (unsigned __int8 *)a1;
      uint64_t v22 = (uint64_t)v13;
      goto LABEL_37;
    }
    goto LABEL_40;
  }
  __int16 v36 = v20;
  v13 += 3;
  while (1)
  {
    LODWORD(v15) = 32 * v29;
    uint64_t result = sub_18C89054C((unsigned __int8 *)a1, (uint64_t)(v13 - 3), 32 * v29, (32 * v29) | 0x1F, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *))a4, a5, a6);
    if (!result) {
      return result;
    }
    if ((unint64_t)v13 >= v24) {
      goto LABEL_40;
    }
    if (a6 == 2)
    {
      unsigned int v30 = *v13;
      int v31 = *(v13 - 3);
      if (v31 + 1 < v30)
      {
        int v32 = 32 * v30;
        if (v32 >= a3) {
          int v32 = a3;
        }
        uint64_t result = sub_18C890468((32 * v31 + 32), v32 - 1, a4, a5);
        if (!result) {
          return result;
        }
      }
    }
    unsigned int v33 = *v13;
    v13 += 3;
    unsigned int v29 = v33;
    if (v28 <= v33)
    {
      v13 -= 3;
      LOWORD(v20) = v36;
      goto LABEL_35;
    }
  }
}

void u_enumCharNames(UChar32 start, UChar32 limit, UEnumCharNamesFn *fn, void *context, UCharNameChoice nameChoice, UErrorCode *pErrorCode)
{
  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (!fn || (uint64_t v7 = *(void *)&nameChoice, (int)nameChoice >= (int)U_CHAR_NAME_CHOICE_COUNT))
    {
      *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
      return;
    }
    uint64_t v8 = *(void *)&start;
    unsigned int v9 = limit >= 0x110000 ? 1114112 : limit;
    if (v9 > start && sub_18C88DD84(pErrorCode))
    {
      uint64_t v11 = qword_1E9191E90;
      uint64_t v12 = (_DWORD *)(qword_1E9191E90 + *(unsigned int *)(qword_1E9191E90 + 12));
      int v13 = *v12;
      if (!*v12)
      {
LABEL_22:
        sub_18C88E8A8(v11, v8, v9, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7);
        return;
      }
      unsigned int v14 = v12 + 1;
      while (1)
      {
        unsigned int v15 = *v14;
        if (v8 < *v14)
        {
          uint64_t v11 = qword_1E9191E90;
          if (v9 <= v15) {
            goto LABEL_22;
          }
          if (!sub_18C88E8A8(qword_1E9191E90, v8, v15, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7))return; {
          uint64_t v8 = *v14;
          }
        }
        unsigned int v16 = v14[1];
        if (v8 <= v16)
        {
          if (v9 <= v16 + 1)
          {
            sub_18C88ED5C((uint64_t)v14, v8, v9, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7);
            return;
          }
          if (!sub_18C88ED5C((uint64_t)v14, v8, v16 + 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t))fn, (uint64_t)context, v7))return; {
          uint64_t v8 = v14[1] + 1;
          }
        }
        unsigned int v14 = (unsigned int *)((char *)v14 + *((unsigned __int16 *)v14 + 5));
        if (!--v13)
        {
          uint64_t v11 = qword_1E9191E90;
          goto LABEL_22;
        }
      }
    }
  }
}

uint64_t sub_18C88ED5C(uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a5, uint64_t a6)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if ((a6 & 0xFFFFFFFD) != 0) {
    return 1;
  }
  uint64_t v11 = a2;
  uint64_t v56 = 0;
  memset(v55, 0, sizeof(v55));
  if (*(unsigned char *)(a1 + 8) == 1)
  {
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    memset(v52, 0, sizeof(v52));
    memset(v51, 0, sizeof(v51));
    uint64_t v25 = a1 + 12;
    uint64_t v26 = *(unsigned __int8 *)(a1 + 9);
    int v27 = (unsigned __int8 *)(a1 + 12 + 2 * v26);
    int v30 = *v27;
    unsigned int v28 = v27 + 1;
    char v29 = v30;
    if (v30)
    {
      unsigned __int16 v31 = 0;
      int v32 = v55;
      do
      {
        *v32++ = v29;
        ++v31;
        int v33 = *v28++;
        char v29 = v33;
      }
      while (v33);
    }
    else
    {
      unsigned __int16 v31 = 0;
      int v32 = v55;
    }
    __int16 v34 = sub_18C890194(a1 + 12, v26, v28, (int)a2 - *(_DWORD *)a1, &v53, v52, v51, v32, 200 - v31);
    if (!a4(a5, v11, a6, v55, (unsigned __int16)(v34 + v31))) {
      return 0;
    }
    uint64_t v35 = (unsigned __int16)(v26 - 1);
    while (1)
    {
      uint64_t v11 = (v11 + 1);
      if ((int)v11 >= a3) {
        break;
      }
      unsigned __int16 v36 = *((_WORD *)&v53 + v35) + 1;
      uint64_t v37 = (unsigned __int16)(v26 - 1);
      int v38 = v26 - 1;
      if (*(unsigned __int16 *)(v25 + 2 * v35) <= v36)
      {
        do
        {
          *((_WORD *)&v53 + v37) = 0;
          *((void *)v51 + v37) = *((void *)v52 + v37);
          uint64_t v37 = (unsigned __int16)--v38;
          unsigned __int16 v36 = *((_WORD *)&v53 + (unsigned __int16)v38) + 1;
        }
        while (*(unsigned __int16 *)(v25 + 2 * (unsigned __int16)v38) <= v36);
      }
      *((_WORD *)&v53 + v37) = v36;
      unsigned __int16 v39 = (unsigned __int8 *)*((void *)v51 + v37);
      while (*v39++)
        ;
      *((void *)v51 + v37) = v39;
      unsigned __int16 v41 = v31;
      int v42 = v32;
      if (v26)
      {
        uint64_t v43 = 0;
        int v42 = v32;
        unsigned __int16 v41 = v31;
        do
        {
          long long v44 = (unsigned char *)*((void *)v51 + v43);
          char v45 = *v44;
          if (*v44)
          {
            int v46 = v44 + 1;
            do
            {
              *v42++ = v45;
              ++v41;
              int v47 = *v46++;
              char v45 = v47;
            }
            while (v47);
          }
          ++v43;
        }
        while (v43 != v26);
      }
      *int v42 = 0;
      if (!a4(a5, v11, a6, v55, v41)) {
        return 0;
      }
    }
    return 1;
  }
  if (*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  uint64_t v12 = sub_18C88DE14(a1, a2, a6, v55, 200);
  if (!v12) {
    return 1;
  }
  uint64_t v13 = v12;
  uint64_t result = a4(a5, v11, a6, v55, v12);
  if (result)
  {
    unsigned int v14 = (char *)&v54 + 5;
    do
    {
      int v15 = v14[3];
      ++v14;
    }
    while (v15);
    while (1)
    {
      uint64_t v11 = (v11 + 1);
      if ((int)v11 >= a3) {
        return 1;
      }
      int v16 = v14[1];
      BOOL v17 = (v16 - 48) >= 9 && (v16 - 65) >= 5;
      uint64_t v18 = v14 + 1;
      unsigned int v19 = (unsigned __int8 *)v14;
      if (v17)
      {
        do
        {
          if (v16 == 70)
          {
            v19[1] = 48;
          }
          else if (v16 == 57)
          {
            uint64_t v18 = (char *)(v19 + 1);
            char v24 = 65;
            goto LABEL_26;
          }
          int v20 = *v19--;
          int v16 = v20;
          unsigned int v21 = v20 - 65;
        }
        while ((v20 - 48) >= 9 && v21 >= 5);
        uint64_t v18 = (char *)(v19 + 1);
      }
      char v24 = v16 + 1;
LABEL_26:
      *uint64_t v18 = v24;
      unsigned int v23 = a4(a5, v11, a6, v55, v13);
      uint64_t result = 0;
      if (!v23) {
        return result;
      }
    }
  }
  return result;
}

uint64_t uprv_getMaxCharNameLength()
{
  int v1 = 0;
  if (sub_18C88F0D4((UErrorCode *)&v1)) {
    return dword_1E9191E98;
  }
  else {
    return 0;
  }
}

BOOL sub_18C88F0D4(UErrorCode *a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!dword_1E9191E98)
  {
    BOOL result = sub_18C88DD84(a1);
    if (!result) {
      return result;
    }
    for (uint64_t i = 0; i != 19; ++i)
      *(_DWORD *)((char *)dword_1E9191E9C + (((unint64_t)a0123456789abcd[i] >> 3) & 0x1C)) |= 1 << a0123456789abcd[i];
    int v3 = (unsigned int *)qword_1E9191E90;
    uint64_t v4 = (int *)(qword_1E9191E90 + *(unsigned int *)(qword_1E9191E90 + 12));
    int v5 = *v4;
    if (*v4)
    {
      int v6 = 0;
      uint64_t v7 = v4 + 1;
      while (*((unsigned char *)v7 + 8) != 1)
      {
        if (!*((unsigned char *)v7 + 8))
        {
          unsigned int v8 = *((unsigned __int8 *)v7 + 12);
          if (*((unsigned char *)v7 + 12))
          {
            uint64_t v9 = 0;
            do
            {
              dword_1E9191E9C[v8 >> 5] |= 1 << v8;
              unsigned int v8 = *((unsigned __int8 *)v7 + v9++ + 13);
            }
            while (v8);
          }
          else
          {
            LODWORD(v9) = 0;
          }
          int v15 = v9 + *((unsigned __int8 *)v7 + 9);
          if (v15 > v6) {
            int v6 = v15;
          }
        }
LABEL_40:
        uint64_t v7 = (_DWORD *)((char *)v7 + *((unsigned __int16 *)v7 + 5));
        if (!--v5) {
          goto LABEL_43;
        }
      }
      int v10 = v7 + 3;
      uint64_t v11 = *((unsigned __int8 *)v7 + 9);
      uint64_t v12 = (char *)v7 + 2 * v11 + 12;
      unsigned int v13 = *v12;
      if (*v12)
      {
        uint64_t v14 = 0;
        do
        {
          dword_1E9191E9C[v13 >> 5] |= 1 << v13;
          unsigned int v13 = *((unsigned __int8 *)v7 + 2 * v11 + v14++ + 13);
        }
        while (v13);
        if (!v11)
        {
LABEL_38:
          if ((int)v14 > v6) {
            int v6 = v14;
          }
          goto LABEL_40;
        }
      }
      else
      {
        LODWORD(v14) = 0;
        if (!*((unsigned char *)v7 + 9)) {
          goto LABEL_38;
        }
      }
      uint64_t v16 = 0;
      BOOL v17 = &v12[(int)v14 + 1];
      do
      {
        int v18 = *((unsigned __int16 *)v10 + v16);
        if (*((_WORD *)v10 + v16))
        {
          int v19 = 0;
          do
          {
            unsigned int v20 = *v17;
            if (*v17)
            {
              uint64_t v21 = 0;
              do
              {
                dword_1E9191E9C[v20 >> 5] |= 1 << v20;
                unsigned int v20 = v17[++v21];
              }
              while (v20);
            }
            else
            {
              LODWORD(v21) = 0;
            }
            v17 += (int)v21 + 1;
            if ((int)v21 > v19) {
              int v19 = v21;
            }
            BOOL v22 = __OFSUB__(v18--, 1);
          }
          while (!((v18 < 0) ^ v22 | (v18 == 0)));
        }
        else
        {
          int v19 = 0;
        }
        LODWORD(v14) = v19 + v14;
        ++v16;
      }
      while (v16 != v11);
      goto LABEL_38;
    }
    int v6 = 0;
LABEL_43:
    for (uint64_t j = 0; j != 33; ++j)
    {
      char v24 = off_1E5508770[j];
      unsigned int v25 = *v24;
      if (*v24)
      {
        uint64_t v26 = 0;
        int v27 = v24 + 1;
        do
        {
          dword_1E9191E9C[v25 >> 5] |= 1 << v25;
          unsigned int v25 = v27[v26++];
        }
        while (v25);
      }
      else
      {
        LODWORD(v26) = 0;
      }
      int v28 = v26 + 9;
      if (v28 > v6) {
        int v6 = v28;
      }
    }
    size_t v29 = *((unsigned __int16 *)v3 + 8);
    uint64_t v30 = *v3;
    unsigned __int16 v31 = uprv_malloc(v29);
    int v32 = v31;
    if (v31) {
      bzero(v31, v29);
    }
    uint64_t v45 = qword_1E9191E90;
    int v33 = (_WORD *)(qword_1E9191E90 + *(unsigned int *)(qword_1E9191E90 + 4));
    int v34 = (unsigned __int16)*v33;
    if (*v33)
    {
      uint64_t v35 = (uint64_t)v3 + 18;
      int v52 = 0;
      uint64_t v36 = (uint64_t)v3 + v30;
      memset(v51, 0, sizeof(v51));
      memset(v49, 0, sizeof(v49));
      uint64_t v37 = v33 + 1;
      int v50 = 0;
      do
      {
        int v47 = v34;
        int v46 = v37;
        int v38 = sub_18C88FF90((unsigned __int8 *)(v45+ *(unsigned int *)(v45 + 8)+ (((unsigned __int16)v37[1] << 16) | (unint64_t)(unsigned __int16)v37[2])), v51, v49);
        for (uint64_t k = 0; k != 64; k += 2)
        {
          uint64_t v40 = &v38[*(unsigned __int16 *)((char *)v51 + k)];
          int v48 = v40;
          uint64_t v41 = *(unsigned __int16 *)((char *)v49 + k);
          if (*(_WORD *)((char *)v49 + k))
          {
            int v42 = &v40[v41];
            int v43 = sub_18C890850(v35, v29, v36, (uint64_t)v32, &v48, &v40[v41]);
            if (v43 > v6) {
              int v6 = v43;
            }
            if (v48 != v42)
            {
              int v44 = sub_18C890850(v35, v29, v36, (uint64_t)v32, &v48, v42);
              if (v44 > v6) {
                int v6 = v44;
              }
            }
          }
        }
        uint64_t v37 = v46 + 3;
        int v34 = v47 - 1;
      }
      while (v47 > 1);
    }
    if (v32) {
      uprv_free(v32);
    }
    dword_1E9191E98 = v6;
  }
  return 1;
}

void uprv_getCharNameCharacters(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  memset(us, 0, sizeof(us));
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)unsigned int v8 = 0u;
  long long v9 = 0u;
  int v7 = 0;
  if (sub_18C88F0D4((UErrorCode *)&v7))
  {
    LODWORD(v2) = 0;
    for (unsigned int i = 0; i != 256; ++i)
    {
      if ((dword_1E9191E9C[i >> 5] >> i))
      {
        v8[(int)v2] = i;
        LODWORD(v2) = v2 + 1;
      }
    }
    u_charsToUChars(v8, (UChar *)us, v2);
    if ((int)v2 >= 1)
    {
      uint64_t v2 = v2;
      uint64_t v4 = v8;
      int v5 = (unsigned __int16 *)us;
      do
      {
        int v6 = *v5++;
        if (v6 || !*v4) {
          (*(void (**)(void))(a1 + 8))(*(void *)a1);
        }
        ++v4;
        --v2;
      }
      while (v2);
    }
  }
}

uint64_t uchar_swapNames(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3;
  v121[64] = *MEMORY[0x1E4F143B8];
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0;
  }
  uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x6E00000075
    || *(unsigned char *)(a2 + 14) != 97
    || *(unsigned char *)(a2 + 15) != 109
    || *(unsigned char *)(a2 + 16) != 1)
  {
    udata_printError(a1, (uint64_t)"uchar_swapNames(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as unames.icu\n", v14, v15, v16, v17, v18, v19, v21);
    uint64_t result = 0;
    int v27 = 16;
    goto LABEL_16;
  }
  int v22 = v13;
  long long v23 = (unsigned int *)(a2 + v13);
  if (a4) {
    char v24 = (unsigned int *)((char *)a4 + v13);
  }
  else {
    char v24 = 0;
  }
  if (v10 < 0)
  {
    unsigned int v28 = (*(uint64_t (**)(void))(a1 + 16))(v23[3]);
    int v29 = (*(uint64_t (**)(void))(a1 + 16))(*(unsigned int *)((char *)v23 + v28));
    unsigned int v30 = v28 + 4;
    if (v29)
    {
      int v31 = v29;
      do
      {
        v30 += (*(uint64_t (**)(void))(a1 + 8))(*(unsigned __int16 *)((char *)v23 + v30 + 10));
        --v31;
      }
      while (v31);
    }
    return v30 + v22;
  }
  size_t v25 = (v10 - v13);
  if ((int)v25 < 20 || (unsigned int v26 = (*(uint64_t (**)(void))(a1 + 16))(v23[3]), v25 < v26))
  {
    udata_printError(a1, (uint64_t)"uchar_swapNames(): too few bytes (%d after header) for unames.icu\n", v14, v15, v16, v17, v18, v19, v25);
    uint64_t result = 0;
    int v27 = 8;
LABEL_16:
    *a5 = v27;
    return result;
  }
  unsigned int v103 = v26;
  bzero(v120, 0x400uLL);
  memset(v119, 0, sizeof(v119));
  memset(v118, 0, sizeof(v118));
  if (v23 != v24) {
    memcpy(v24, v23, v25);
  }
  uint64_t v110 = v25;
  unsigned int v105 = (*(uint64_t (**)(void))(a1 + 16))(*v23);
  unsigned int v107 = (*(uint64_t (**)(void))(a1 + 16))(v23[1]);
  unsigned int v102 = (*(uint64_t (**)(void))(a1 + 16))(v23[2]);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, v23, 16, v24, a5);
  BOOL v111 = (char *)v24;
  unint64_t v109 = v23;
  unsigned int v33 = *((unsigned __int16 *)v23 + 8);
  int v32 = v23 + 4;
  uint64_t v34 = (*(uint64_t (**)(void))(a1 + 8))(v33);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 48))(a1, v32, 2, (char *)v24 + 16, a5);
  uint64_t v35 = (unsigned __int16 *)v32 + 1;
  if (v34 >= 0x201) {
    uint64_t v36 = 512;
  }
  else {
    uint64_t v36 = v34;
  }
  if (!v36) {
    goto LABEL_30;
  }
  uint64_t v37 = v120;
  uint64_t v38 = v36;
  unsigned __int16 v39 = v35;
  do
  {
    unsigned __int16 v40 = *v39++;
    *v37++ = udata_readInt16(a1, v40);
    --v38;
  }
  while (v38);
  if (v36 <= 0x1FF) {
LABEL_30:
  }
    bzero((char *)v120 + (2 * v36), ((2 * v36) ^ 0x3FEu) + 2);
  sub_18C88FDB8(a1, (uint64_t)v120, v34, v119, a5);
  if (v34 >= 0x100) {
    unsigned int v41 = v34 - 256;
  }
  else {
    unsigned int v41 = 0;
  }
  sub_18C88FDB8(a1, (uint64_t)v121, v41, v118, a5);
  if (*a5 > 0) {
    return 0;
  }
  int v42 = uprv_malloc((2 * v34));
  if (!v42)
  {
    udata_printError(a1, (uint64_t)"out of memory swapping %u unames.icu tokens\n", v43, v44, v45, v46, v47, v48, v34);
    int v63 = 7;
    goto LABEL_48;
  }
  BOOL v49 = v42;
  if (v34 >= 0x100) {
    uint64_t v50 = 256;
  }
  else {
    uint64_t v50 = v34;
  }
  if (v50)
  {
    int v51 = (unsigned __int8 *)v119;
    uint64_t v52 = v50;
    do
    {
      unsigned int v53 = *v51++;
      (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, uint64_t, int *))(a1 + 48))(a1, v35++, 2, (uint64_t)v49 + 2 * v53, a5);
      --v52;
    }
    while (v52);
  }
  if (v34 >= 0x101)
  {
    uint64_t v54 = v22 + 2 * v50 + a2 + 18;
    do
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(a1 + 48))(a1, v54, 2, (uint64_t)v49 + 2 * (v50 & 0x7FFFFF00) + 2 * *((unsigned __int8 *)v118 + v50), a5);
      ++v50;
      v54 += 2;
    }
    while (v34 != v50);
  }
  memcpy(v111 + 18, v49, (2 * v34));
  uprv_free(v49);
  int v55 = v109;
  uint64_t v56 = v111;
  udata_swapInvStringBlock(a1, (uint64_t)v109 + v105, v107 - v105, (uint64_t)&v111[v105], a5);
  if (*a5 >= 1)
  {
    udata_printError(a1, (uint64_t)"uchar_swapNames(token strings) failed\n", v57, v58, v59, v60, v61, v62, v101);
    return 0;
  }
  int v64 = (*(uint64_t (**)(void))(a1 + 8))(*(unsigned __int16 *)((char *)v109 + v107));
  (*(void (**)(uint64_t, char *, void, char *, int *))(a1 + 48))(a1, (char *)v109 + v107, (6 * v64 + 2), &v111[v107], a5);
  if (*(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 3))
  {
    __int16 v117 = 0;
    long long v116 = 0u;
    memset(v115, 0, sizeof(v115));
    __int16 v114 = 0;
    long long v113 = 0u;
    unsigned int v65 = v103 - v102;
    memset(v112, 0, sizeof(v112));
    if (v103 - v102 >= 0x21)
    {
      uint64_t v66 = (unsigned __int8 *)&v111[v102];
      unsigned int v67 = (unsigned __int8 *)v109 + v102;
      do
      {
        uint64_t v68 = v67;
        unsigned int v67 = sub_18C88FF90(v67, v115, v112);
        int v69 = v67 - v68;
        v66 += v67 - v68;
        int v70 = HIWORD(v113) + HIWORD(v116);
        if (v70)
        {
          int v71 = HIWORD(v113) + HIWORD(v116);
          do
          {
            uint64_t v72 = *v67;
            *uint64_t v66 = *((unsigned char *)v119 + v72);
            int v73 = v120[v72];
            if (v73 == -2)
            {
              unsigned __int8 v74 = *((unsigned char *)v118 + v67[1]);
              v67 += 2;
              v66[1] = v74;
              v66 += 2;
            }
            else
            {
              int v73 = -1;
              ++v67;
              ++v66;
            }
            v71 += v73;
          }
          while (v71);
        }
        unsigned int v65 = v65 - v69 - v70;
      }
      while (v65 >= 0x21);
    }
    int v55 = v109;
    uint64_t v56 = v111;
  }
  int v75 = (unsigned int *)((char *)v55 + v103);
  int v76 = (*(uint64_t (**)(void))(a1 + 16))(*v75);
  (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(a1 + 56))(a1, v75, 4, &v56[v103], a5);
  unsigned int v83 = v103 + 4;
  int v106 = v76;
  if (!v76)
  {
    unsigned int v30 = v103 + 4;
    return v30 + v22;
  }
  uint64_t v84 = 0;
  uint64_t v104 = v22 + a2 + 11;
  while (1)
  {
    if (v83 > v110)
    {
      udata_printError(a1, (uint64_t)"uchar_swapNames(): too few bytes (%d after header) for unames.icu algorithmic range %u\n", v77, v78, v79, v80, v81, v82, v110);
      int v63 = 8;
      goto LABEL_48;
    }
    uint64_t v85 = (uint64_t)v55 + v83;
    int8x8_t v86 = &v56[v83];
    int v108 = (*(uint64_t (**)(void))(a1 + 8))(*(unsigned __int16 *)(v85 + 10));
    unsigned int v30 = v83 + v108;
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 56))(a1, v85, 8, v86, a5);
    (*(void (**)(uint64_t, uint64_t, uint64_t, char *, int *))(a1 + 48))(a1, v85 + 10, 2, v86 + 10, a5);
    if (*(unsigned char *)(v85 + 8) == 1)
    {
      uint64_t v94 = v83;
      uint64_t v95 = *(unsigned __int8 *)(v85 + 9);
      uint64_t v96 = v85 + 12;
      (*(void (**)(uint64_t, uint64_t, void, char *, int *))(a1 + 48))(a1, v96, (2 * v95), v86 + 12, a5);
      uint64_t v97 = v55 + v30 - (v96 + 2 * v95);
      int v98 = v108 - 2 * v95 - 11;
      int v99 = (unsigned __int8 *)(v104 + v94 + 2 * v95 + v97);
      uint64_t v56 = v111;
      do
      {
        if (!v97) {
          break;
        }
        --v97;
        int v100 = *v99--;
        --v98;
      }
      while (v100);
      (*(void (**)(uint64_t))(a1 + 72))(a1);
      goto LABEL_71;
    }
    if (*(unsigned char *)(v85 + 8)) {
      break;
    }
    size_t v93 = strlen((const char *)(v85 + 12));
    (*(void (**)(uint64_t, uint64_t, size_t, char *, int *))(a1 + 72))(a1, v85 + 12, v93, v86 + 12, a5);
    int v55 = v109;
    uint64_t v56 = v111;
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"uchar_swapNames(prefix string of algorithmic range %u) failed\n", v77, v78, v79, v80, v81, v82, v84);
      return 0;
    }
LABEL_71:
    uint64_t v84 = (v84 + 1);
    unsigned int v83 = v30;
    if (v84 == v106) {
      return v30 + v22;
    }
  }
  udata_printError(a1, (uint64_t)"uchar_swapNames(): unknown type %u of algorithmic range %u\n", v87, v88, v89, v90, v91, v92, *(unsigned __int8 *)(v85 + 8));
  int v63 = 16;
LABEL_48:
  *a5 = v63;
  return 0;
}

uint64_t sub_18C88FDB8(uint64_t result, uint64_t a2, unsigned int a3, _OWORD *a4, int *a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*a5 <= 0)
  {
    uint64_t v6 = result;
    if (*(unsigned __int8 *)(result + 1) == *(unsigned __int8 *)(result + 3))
    {
      uint64_t v7 = 0;
      int8x16_t v8 = (int8x16_t)xmmword_18CA81B70;
      v9.i64[0] = 0x1010101010101010;
      v9.i64[1] = 0x1010101010101010;
      do
      {
        a4[v7++] = v8;
        int8x16_t v8 = vaddq_s8(v8, v9);
      }
      while (v7 != 16);
    }
    else
    {
      a4[14] = 0u;
      a4[15] = 0u;
      if (a3 >= 0x100) {
        uint64_t v10 = 256;
      }
      else {
        uint64_t v10 = a3;
      }
      a4[12] = 0uLL;
      a4[13] = 0uLL;
      a4[10] = 0uLL;
      a4[11] = 0uLL;
      a4[8] = 0uLL;
      a4[9] = 0uLL;
      a4[6] = 0uLL;
      a4[7] = 0uLL;
      a4[4] = 0uLL;
      a4[5] = 0uLL;
      a4[2] = 0uLL;
      a4[3] = 0uLL;
      *a4 = 0uLL;
      a4[1] = 0uLL;
      memset(v27, 0, sizeof(v27));
      if (v10 >= 2)
      {
        unsigned __int8 v25 = 0;
        for (uint64_t i = 1; i != v10; ++i)
        {
          if (*(__int16 *)(a2 + 2 * i) == -1)
          {
            unsigned __int8 v26 = i;
            uint64_t result = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t, unsigned __int8 *, int *))(v6 + 72))(v6, &v26, 1, &v25, a5);
            if (*a5 >= 1) {
              return udata_printError(v6, (uint64_t)"unames/makeTokenMap() finds variant character 0x%02x used (input charset family %d)\n", v14, v15, v16, v17, v18, v19, i);
            }
            uint64_t v20 = v25;
            *((unsigned char *)a4 + v26) = v25;
            *((unsigned char *)v27 + v20) = 1;
          }
        }
        uint64_t v21 = 1;
        int v22 = 1;
        do
        {
          if (!*((unsigned char *)a4 + v21))
          {
            do
              char v23 = v22;
            while (*((unsigned __int8 *)v27 + (unsigned __int16)v22++));
            *((unsigned char *)a4 + v21) = v23;
          }
          ++v21;
        }
        while (v21 != v10);
      }
    }
  }
  return result;
}

unsigned __int8 *sub_18C88FF90(unsigned __int8 *result, _WORD *a2, _WORD *a3)
{
  LOWORD(v3) = 0;
  int v4 = 0;
  unsigned int v5 = 0;
  do
  {
    unsigned int v7 = *result++;
    unsigned int v6 = v7;
    if ((unsigned __int16)v3 < 0xCu)
    {
      if (v6 > 0xBF)
      {
        LOWORD(v3) = 0;
        int v9 = (v6 & 0x3F) + 12;
        *a2++ = v4;
        *a3++ = v9;
        v4 += v9;
        ++v5;
        continue;
      }
      unsigned int v8 = v6 >> 4;
    }
    else
    {
      unsigned int v8 = ((v6 >> 4) & 0xFFFFFFCF | (16 * (v3 & 3))) + 12;
    }
    *a2 = v4;
    unsigned int v3 = v6 & 0xF;
    *a3 = v8;
    v4 += v8;
    if (v3 > 0xB)
    {
      ++v5;
      ++a2;
      ++a3;
    }
    else
    {
      a2[1] = v4;
      a2 += 2;
      a3[1] = v3;
      a3 += 2;
      v4 += v3;
      v5 += 2;
    }
  }
  while (v5 < 0x20);
  return result;
}

void sub_18C89003C(UErrorCode *a1)
{
  uint64_t v2 = udata_openChoice(0, "icu", "unames", (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18C8900D8, 0, a1);
  qword_1E9191EC8 = (uint64_t)v2;
  if (*(int *)a1 < 1) {
    qword_1E9191E90 = udata_getMemory((uint64_t)v2);
  }
  else {
    qword_1E9191EC8 = 0;
  }

  sub_18C8546F4(0x13u, (uint64_t)sub_18C89013C);
}

BOOL sub_18C8900D8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 117
      && a4[9] == 110
      && a4[10] == 97
      && a4[11] == 109
      && a4[12] == 1;
}

uint64_t sub_18C89013C()
{
  if (qword_1E9191EC8)
  {
    udata_close((_OWORD *)qword_1E9191EC8);
    qword_1E9191EC8 = 0;
  }
  if (qword_1E9191E90) {
    qword_1E9191E90 = 0;
  }
  atomic_store(0, &dword_1E9191EBC);
  dword_1E9191E98 = 0;
  return 1;
}

uint64_t sub_18C890194(uint64_t a1, __int16 a2, unsigned __int8 *a3, unsigned int a4, _WORD *a5, void *a6, void *a7, unsigned char *a8, __int16 a9)
{
  if (a2 == 1)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = (unsigned __int16)(a2 - 1);
    uint64_t v11 = v10;
    do
    {
      __int16 v12 = a4;
      a4 /= *(unsigned __int16 *)(a1 + 2 * v11);
      a5[v11] = v12 - a4 * *(_WORD *)(a1 + 2 * v11);
      --v11;
    }
    while ((_WORD)v11);
  }
  uint64_t v13 = 0;
  unsigned __int16 v14 = 0;
  *a5 = a4;
  if (a6)
  {
LABEL_7:
    *a6++ = a3;
    goto LABEL_8;
  }
  while (1)
  {
LABEL_8:
    int v15 = (unsigned __int16)a5[v13];
    if (a5[v13])
    {
      do
      {
        while (*a3++)
          ;
        --v15;
      }
      while ((_WORD)v15);
    }
    if (a7) {
      *a7++ = a3;
    }
    while (1)
    {
      int v18 = *a3++;
      char v17 = v18;
      if (!v18) {
        break;
      }
      if (a9)
      {
        *a8++ = v17;
        --a9;
      }
      else
      {
        a9 = 0;
      }
      ++v14;
    }
    if (v13 == v10) {
      break;
    }
    for (__int16 i = *(_WORD *)(a1 + 2 * v13) + ~a5[v13]; i; --i)
    {
      while (*a3++)
        ;
    }
    ++v13;
    if (a6) {
      goto LABEL_7;
    }
  }
  if (a9) {
    *a8 = 0;
  }
  return v14;
}

unsigned __int16 *sub_18C890288(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = (unsigned __int16 *)(a1 + *(unsigned int *)(a1 + 4));
  unsigned int v5 = *v2;
  unsigned int v3 = v2 + 1;
  unsigned int v4 = v5;
  if (v5 < 2)
  {
    uint64_t v10 = 0;
  }
  else
  {
    int v6 = 0;
    unsigned __int16 v7 = 0;
    unsigned __int16 v8 = v4;
    do
    {
      unsigned int v9 = (v4 + v6) >> 1;
      if ((unsigned __int16)(a2 >> 5) < v3[3 * v9]) {
        unsigned __int16 v8 = v9;
      }
      else {
        unsigned __int16 v7 = v9;
      }
      int v6 = v7;
      unsigned int v4 = v8;
    }
    while (v8 - 1 > v7);
    uint64_t v10 = 3 * v7;
  }
  return &v3[v10];
}

uint64_t sub_18C8902F4(unsigned int *a1, unsigned __int8 *a2, int a3, int a4, char *a5, int a6)
{
  unsigned int v6 = *((unsigned __int16 *)a1 + 8);
  uint64_t v7 = *a1;
  unsigned __int16 v8 = (char *)a1 + v7;
  if ((a4 & 0xFFFFFFFD) != 0)
  {
    if (v6 < 0x3C || *((__int16 *)a1 + 68) == -1)
    {
      int v9 = a4;
      do
      {
        if ((_WORD)a3)
        {
          do
          {
            --a3;
            int v10 = *a2++;
          }
          while (v10 != 59 && (unsigned __int16)a3 != 0);
        }
        else
        {
          a3 = 0;
        }
        BOOL v12 = __OFSUB__(v9--, 1);
      }
      while (!((v9 < 0) ^ v12 | (v9 == 0)));
    }
    else
    {
      a3 = 0;
    }
  }
  int v13 = 0;
  unsigned __int16 v14 = (char *)a1 + 18;
  uint64_t v15 = (uint64_t)a1 + v7 + 1;
LABEL_17:
  int v16 = a3;
  char v17 = a2;
  while ((_WORD)v16)
  {
    a3 = v16 - 1;
    a2 = v17 + 1;
    uint64_t v18 = *v17;
    if (v6 <= v18)
    {
      if (v18 == 59) {
        break;
      }
LABEL_29:
      if ((_WORD)a6)
      {
        *a5++ = v18;
        --a6;
      }
      else
      {
        a6 = 0;
      }
      ++v13;
      goto LABEL_17;
    }
    unsigned int v19 = *(unsigned __int16 *)&v14[2 * v18];
    if (v19 == 65534)
    {
      a2 = v17 + 2;
      unsigned int v19 = *(unsigned __int16 *)&v14[(2 * v17[1]) | (v18 << 9)];
      a3 = v16 - 2;
    }
    if (v19 != 0xFFFF)
    {
      char v20 = v8[v19];
      if (v20)
      {
        uint64_t v21 = (unsigned __int8 *)(v15 + v19);
        do
        {
          if ((_WORD)a6)
          {
            *a5++ = v20;
            --a6;
          }
          else
          {
            a6 = 0;
          }
          ++v13;
          int v22 = *v21++;
          char v20 = v22;
        }
        while (v22);
      }
      goto LABEL_17;
    }
    if (v18 != 59) {
      goto LABEL_29;
    }
    if (a4 == 2 && !(_WORD)v13)
    {
      int v13 = 0;
      int v16 = a3;
      char v17 = a2;
      if (*((__int16 *)a1 + 68) == -1) {
        continue;
      }
    }
    break;
  }
  if ((_WORD)a6) {
    *a5 = 0;
  }
  return (unsigned __int16)v13;
}

uint64_t sub_18C890468(uint64_t a1, int a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t), uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 1;
  }
  uint64_t v4 = a1;
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  if ((int)a1 > a2) {
    return 1;
  }
  int v7 = a2 + 1;
  while (1)
  {
    uint64_t v8 = sub_18C88E0FC(v4, (char *)v10, 200);
    *((unsigned char *)v10 + v8) = 0;
    if (v8)
    {
      uint64_t result = a3(a4, v4, 2, v10, v8);
      if (!result) {
        break;
      }
    }
    uint64_t v4 = (v4 + 1);
    if (v7 == v4) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_18C89054C(unsigned __int8 *a1, uint64_t a2, uint64_t a3, int a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, _OWORD *), uint64_t a6, uint64_t a7)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  int v42 = 0;
  memset(v41, 0, sizeof(v41));
  int v40 = 0;
  memset(v39, 0, sizeof(v39));
  int v13 = sub_18C88FF90(&a1[*((unsigned int *)a1 + 2)+ ((*(unsigned __int16 *)(a2 + 2) << 16) | (unint64_t)*(unsigned __int16 *)(a2 + 4))], v41, v39);
  if (a5)
  {
    uint64_t v38 = 0;
    memset(v37, 0, sizeof(v37));
    if ((int)a3 <= a4)
    {
      int v14 = a4 + 1;
      while (1)
      {
        unsigned int v15 = sub_18C8902F4((unsigned int *)a1, &v13[*((unsigned __int16 *)v41 + (a3 & 0x1F))], *((unsigned __int16 *)v39 + (a3 & 0x1F)), a7, (char *)v37, 200);
        unsigned int v16 = v15;
        if (a7 == 2 && !v15)
        {
          unsigned int v16 = sub_18C88E0FC(a3, (char *)v37, 200);
          *((unsigned char *)v37 + v16) = 0;
        }
        if (v16)
        {
          uint64_t result = a5(a6, a3, a7, v37);
          if (!result) {
            break;
          }
        }
        a3 = (a3 + 1);
        if (v14 == a3) {
          return 1;
        }
      }
      return result;
    }
    return 1;
  }
  if ((int)a3 > a4) {
    return 1;
  }
  uint64_t v18 = (char *)(a1 + 18);
  unsigned int v19 = *((unsigned __int16 *)a1 + 8);
LABEL_13:
  char v20 = &v13[*((unsigned __int16 *)v41 + (a3 & 0x1F))];
  int v21 = *((unsigned __int16 *)v39 + (a3 & 0x1F));
  if ((a7 & 0xFFFFFFFD) != 0)
  {
    if (v19 < 0x3C || *((__int16 *)a1 + 68) == -1)
    {
      int v22 = a7;
      do
      {
        if ((_WORD)v21)
        {
          do
          {
            --v21;
            int v23 = *v20++;
            BOOL v24 = v23 == 59 || (unsigned __int16)v21 == 0;
          }
          while (!v24);
        }
        else
        {
          int v21 = 0;
        }
        BOOL v25 = __OFSUB__(v22--, 1);
      }
      while (!((v22 < 0) ^ v25 | (v22 == 0)));
    }
    else
    {
      int v21 = 0;
    }
  }
  unsigned __int8 v26 = *(unsigned char **)a6;
LABEL_29:
  BOOL v28 = a7 == 2 && v26 == *(unsigned char **)a6;
  int v29 = v20;
  int v30 = v21;
  while ((_WORD)v30)
  {
    int v21 = v30 - 1;
    char v20 = v29 + 1;
    uint64_t v31 = *v29;
    if (v19 <= v31)
    {
      if (v31 == 59) {
        break;
      }
LABEL_46:
      int v33 = *v26++;
      if (v31 == v33) {
        goto LABEL_29;
      }
LABEL_53:
      BOOL v24 = a3 == a4;
      LODWORD(a3) = a3 + 1;
      if (v24) {
        return 1;
      }
      goto LABEL_13;
    }
    int v32 = *(unsigned __int16 *)&v18[2 * v31];
    if (v32 == 65534)
    {
      char v20 = v29 + 2;
      int v32 = *(unsigned __int16 *)&v18[(2 * v29[1]) | (v31 << 9)];
      int v21 = v30 - 2;
    }
    if (v32 != 0xFFFF)
    {
      uint64_t v34 = &a1[*(unsigned int *)a1 + v32];
      while (1)
      {
        int v35 = *v34;
        if (!*v34) {
          goto LABEL_29;
        }
        ++v34;
        int v36 = *v26++;
        if (v35 != v36) {
          goto LABEL_53;
        }
      }
    }
    if (v31 != 59) {
      goto LABEL_46;
    }
    if (!v28) {
      break;
    }
    int v29 = v20;
    int v30 = v21;
    if (*((__int16 *)a1 + 68) != -1)
    {
      unsigned __int8 v26 = *(unsigned char **)a6;
      break;
    }
  }
  if (*v26) {
    goto LABEL_53;
  }
  uint64_t result = 0;
  *(_DWORD *)(a6 + 8) = a3;
  return result;
}

uint64_t sub_18C890850(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned __int8 **a5, unsigned __int8 *a6)
{
  unsigned int v6 = *a5;
  if (*a5 != a6)
  {
    uint64_t result = 0;
    uint64_t v9 = a3 + 1;
    int v10 = *a5;
    while (1)
    {
      unsigned int v12 = *v10++;
      unint64_t v11 = v12;
      if (v12 == 59)
      {
        a6 = v10;
        goto LABEL_29;
      }
      if (v11 >= a2)
      {
        *(_DWORD *)((char *)dword_1E9191E9C + ((v11 >> 3) & 0x1C)) |= 1 << v11;
      }
      else
      {
        unsigned int v13 = *(unsigned __int16 *)(a1 + 2 * v11);
        if (v13 == 65534)
        {
          int v10 = v6 + 2;
          LODWORD(v11) = v6[1] | (v11 << 8);
          unsigned int v13 = *(unsigned __int16 *)(a1 + 2 * v11);
        }
        if (v13 != 0xFFFF)
        {
          if (a4)
          {
            LODWORD(v14) = *(char *)(a4 + v11);
            if (!*(unsigned char *)(a4 + v11))
            {
              unsigned int v15 = *(unsigned __int8 *)(a3 + v13);
              if (*(unsigned char *)(a3 + v13))
              {
                uint64_t v14 = 0;
                uint64_t v16 = v9 + v13;
                do
                {
                  dword_1E9191E9C[v15 >> 5] |= 1 << v15;
                  unsigned int v15 = *(unsigned __int8 *)(v16 + v14++);
                }
                while (v15);
              }
              else
              {
                LODWORD(v14) = 0;
              }
              *(unsigned char *)(a4 + v11) = v14;
            }
          }
          else
          {
            unsigned int v17 = *(unsigned __int8 *)(a3 + v13);
            if (*(unsigned char *)(a3 + v13))
            {
              uint64_t v14 = 0;
              uint64_t v18 = v9 + v13;
              do
              {
                dword_1E9191E9C[v17 >> 5] |= 1 << v17;
                unsigned int v17 = *(unsigned __int8 *)(v18 + v14++);
              }
              while (v17);
            }
            else
            {
              LODWORD(v14) = 0;
            }
          }
          uint64_t result = (v14 + result);
          goto LABEL_25;
        }
        dword_1E9191E9C[v11 >> 5] |= 1 << v11;
      }
      uint64_t result = (result + 1);
LABEL_25:
      unsigned int v6 = v10;
      if (v10 == a6) {
        goto LABEL_29;
      }
    }
  }
  uint64_t result = 0;
LABEL_29:
  *a5 = a6;
  return result;
}

uint64_t sub_18C8909B0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

uint64_t sub_18C8909D4(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
}

uint64_t sub_18C890A0C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t icu::UnifiedCache::getInstance(UErrorCode *this, UErrorCode *a2)
{
  if (*(int *)this <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1EB20B618, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1EB20B618))
    {
      if (dword_1EB20B61C >= 1) {
        *this = dword_1EB20B61C;
      }
    }
    else
    {
      sub_18C890ADC(this);
      dword_1EB20B61C = *this;
      icu::umtx_initImplPostInit(&dword_1EB20B618);
    }
  }
  if (*(int *)this >= 1) {
    return 0;
  }
  else {
    return qword_1EB20B600;
  }
}

icu::UnifiedCache *sub_18C890ADC(UErrorCode *a1)
{
  sub_18C8546F4(0x1Bu, (uint64_t)sub_18C8918A8);
  qword_1EB20B620 = 850045863;
  unk_1EB20B628 = 0u;
  unk_1EB20B638 = 0u;
  unk_1EB20B648 = 0u;
  qword_1EB20B658 = 0;
  qword_1EB20B608 = (uint64_t)&qword_1EB20B620;
  qword_1EB20B660 = 1018212795;
  unk_1EB20B668 = 0u;
  unk_1EB20B678 = 0u;
  qword_1EB20B688 = 0;
  qword_1EB20B610 = (uint64_t)&qword_1EB20B660;
  uint64_t result = (icu::UnifiedCache *)icu::UMemory::operator new(&qword_1EB20B660, (icu::UMemory *)0x38, v2);
  if (result)
  {
    uint64_t result = icu::UnifiedCache::UnifiedCache(result, a1);
    qword_1EB20B600 = (uint64_t)result;
    if (*(int *)a1 < 1) {
      return result;
    }
    uint64_t result = (icu::UnifiedCache *)(*(uint64_t (**)(icu::UnifiedCache *))(*(void *)result + 8))(result);
  }
  else
  {
    *a1 = U_MEMORY_ALLOCATION_ERROR;
  }
  qword_1EB20B600 = 0;
  return result;
}

icu::UnifiedCache *icu::UnifiedCache::UnifiedCache(icu::UnifiedCache *this, UErrorCode *a2)
{
  *(void *)this = &unk_1EDA47318;
  *((void *)this + 1) = 0;
  *((_OWORD *)this + 1) = xmmword_18CA81B90;
  *((_DWORD *)this + 8) = 100;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  unsigned int v3 = (uint64_t *)*(unsigned int *)a2;
  if ((int)v3 <= 0)
  {
    unsigned int v6 = icu::UMemory::operator new(v3, (icu::UMemory *)0x18, (unint64_t)a2);
    if (v6)
    {
      v6[1] = 0;
      long long v6[2] = 0;
      *unsigned int v6 = (uint64_t)&unk_1EDA44E40;
      *((void *)this + 6) = v6;
      *((_DWORD *)v6 + 2) = 1;
      atomic_store(1u, (unsigned int *)v6 + 3);
      *(void *)(*((void *)this + 6) + 16) = this;
      int v7 = uhash_open((uint64_t)sub_18C8909B0, (uint64_t)sub_18C8909D4, 0, (int *)a2);
      *((void *)this + 1) = v7;
      if (*(int *)a2 <= 0) {
        uhash_setKeyDeleter((uint64_t)v7, (uint64_t)sub_18C890A0C);
      }
    }
    else
    {
      *((void *)this + 6) = 0;
      *a2 = U_MEMORY_ALLOCATION_ERROR;
    }
  }
  return this;
}

void icu::UnifiedCache::setEvictionPolicy(icu::UnifiedCache *this, int a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 <= 0)
  {
    if ((a3 | a2) < 0)
    {
      *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    }
    else
    {
      int v7 = (std::mutex *)qword_1EB20B608;
      std::mutex::lock((std::mutex *)qword_1EB20B608);
      *((_DWORD *)this + 7) = a2;
      *((_DWORD *)this + 8) = a3;
      std::mutex::unlock(v7);
    }
  }
}

uint64_t icu::UnifiedCache::unusedCount(icu::UnifiedCache *this)
{
  unint64_t v2 = (std::mutex *)qword_1EB20B608;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  uint64_t v3 = uhash_count(*((void *)this + 1)) - *((_DWORD *)this + 6);
  std::mutex::unlock(v2);
  return v3;
}

uint64_t icu::UnifiedCache::autoEvictedCount(icu::UnifiedCache *this)
{
  unint64_t v2 = (std::mutex *)qword_1EB20B608;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  uint64_t v3 = *((void *)this + 5);
  std::mutex::unlock(v2);
  return v3;
}

uint64_t icu::UnifiedCache::keyCount(icu::UnifiedCache *this)
{
  unint64_t v2 = (std::mutex *)qword_1EB20B608;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  uint64_t v3 = uhash_count(*((void *)this + 1));
  std::mutex::unlock(v2);
  return v3;
}

void icu::UnifiedCache::flush(icu::UnifiedCache *this)
{
  unint64_t v2 = (std::mutex *)qword_1EB20B608;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  while (icu::UnifiedCache::_flush(this, 0))
    ;

  std::mutex::unlock(v2);
}

uint64_t icu::UnifiedCache::_flush(icu::UnifiedCache *this, int a2)
{
  int v4 = uhash_count(*((void *)this + 1));
  if (v4 < 1)
  {
    return 0;
  }
  else
  {
    int v5 = v4;
    char v6 = 0;
    do
    {
      uint64_t Element = icu::UnifiedCache::_nextElement(this);
      if (!Element) {
        break;
      }
      uint64_t v8 = Element;
      if (a2 || icu::UnifiedCache::_isEvictable((uint64_t)this, Element))
      {
        uint64_t v9 = *(const icu::SharedObject **)(v8 + 8);
        uhash_removeElement(*((void *)this + 1), (_DWORD *)v8);
        icu::UnifiedCache::removeSoftRef((uint64_t)this, v9);
        char v6 = 1;
      }
      --v5;
    }
    while (v5);
  }
  return v6;
}

void icu::UnifiedCache::handleUnreferencedObject(icu::UnifiedCache *this)
{
  unint64_t v2 = (std::mutex *)qword_1EB20B608;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  --*((_DWORD *)this + 6);
  icu::UnifiedCache::_runEvictionSlice(this);

  std::mutex::unlock(v2);
}

uint64_t icu::UnifiedCache::_runEvictionSlice(icu::UnifiedCache *this)
{
  uint64_t result = uhash_count(*((void *)this + 1));
  int v3 = *((_DWORD *)this + 6);
  unint64_t v4 = 1374389535 * *((_DWORD *)this + 8) * v3;
  int v5 = (v4 >> 63) + (SHIDWORD(v4) >> 5);
  if (v5 <= *((_DWORD *)this + 7)) {
    int v5 = *((_DWORD *)this + 7);
  }
  int v6 = result - v3 - v5;
  if (v6 >= 1)
  {
    int v7 = 10;
    do
    {
      uint64_t result = icu::UnifiedCache::_nextElement(this);
      if (!result) {
        break;
      }
      uint64_t v8 = result;
      uint64_t result = icu::UnifiedCache::_isEvictable((uint64_t)this, result);
      if (result)
      {
        uint64_t v9 = *(const icu::SharedObject **)(v8 + 8);
        uhash_removeElement(*((void *)this + 1), (_DWORD *)v8);
        uint64_t result = icu::UnifiedCache::removeSoftRef((uint64_t)this, v9);
        ++*((void *)this + 5);
        if (!--v6) {
          break;
        }
      }
      --v7;
    }
    while (v7);
  }
  return result;
}

void icu::UnifiedCache::~UnifiedCache(icu::UnifiedCache *this)
{
  *(void *)this = &unk_1EDA47318;
  icu::UnifiedCache::flush(this);
  unint64_t v2 = (std::mutex *)qword_1EB20B608;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  icu::UnifiedCache::_flush(this, 1);
  std::mutex::unlock(v2);
  uhash_close(*((unsigned char **)this + 1));
  *((void *)this + 1) = 0;
  uint64_t v3 = *((void *)this + 6);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 6) = 0;

  icu::UnifiedCacheBase::~UnifiedCacheBase(this);
}

{
  void *v1;
  uint64_t vars8;

  icu::UnifiedCache::~UnifiedCache(this);

  icu::UMemory::operator delete(v1);
}

uint64_t icu::UnifiedCache::_nextElement(icu::UnifiedCache *this)
{
  uint64_t result = uhash_nextElement(*((uint64_t **)this + 1), (int *)this + 4);
  if (!result)
  {
    *((_DWORD *)this + 4) = -1;
    uint64_t v3 = (uint64_t *)*((void *)this + 1);
    return uhash_nextElement(v3, (int *)this + 4);
  }
  return result;
}

BOOL icu::UnifiedCache::_isEvictable(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(atomic_uint **)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  int v5 = *(atomic_uint **)(a1 + 48);
  if (*(_DWORD *)(v4 + 8)) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = v5 == v3;
  }
  if (v6) {
    return 0;
  }
  if (*(unsigned char *)(v4 + 12))
  {
    if (v3[2] == 1) {
      return icu::SharedObject::getRefCount(v3) == 0;
    }
    return 0;
  }
  return 1;
}

uint64_t icu::UnifiedCache::removeSoftRef(uint64_t this, const icu::SharedObject *a2)
{
  int v2 = *((_DWORD *)a2 + 2) - 1;
  *((_DWORD *)a2 + 2) = v2;
  if (!v2)
  {
    --*(_DWORD *)(this + 20);
    this = icu::SharedObject::getRefCount((atomic_uint *)a2);
    if (this)
    {
      *((void *)a2 + 2) = 0;
    }
    else
    {
      uint64_t v4 = *(uint64_t (**)(const icu::SharedObject *))(*(void *)a2 + 8);
      return v4(a2);
    }
  }
  return this;
}

uint64_t icu::UnifiedCache::_computeCountOfItemsToEvict(icu::UnifiedCache *this)
{
  int v2 = uhash_count(*((void *)this + 1));
  int v3 = *((_DWORD *)this + 6);
  unint64_t v4 = 1374389535 * *((_DWORD *)this + 8) * v3;
  int v5 = (v4 >> 63) + (SHIDWORD(v4) >> 5);
  if (v5 <= *((_DWORD *)this + 7)) {
    int v5 = *((_DWORD *)this + 7);
  }
  return (v2 - v3 - v5) & ~((v2 - v3 - v5) >> 31);
}

uint64_t icu::UnifiedCache::_putNew(uint64_t this, const icu::CacheKeyBase *a2, const icu::SharedObject *a3, UErrorCode a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    uint64_t v8 = this;
    this = (*(uint64_t (**)(const icu::CacheKeyBase *))(*(void *)a2 + 32))(a2);
    if (this)
    {
      *(_DWORD *)(this + 8) = a4;
      if (!*((_DWORD *)a3 + 2))
      {
        *(unsigned char *)(this + 12) = 1;
        *((void *)a3 + 2) = v8;
        *(int32x2_t *)(v8 + 20) = vadd_s32(*(int32x2_t *)(v8 + 20), (int32x2_t)0x100000001);
      }
      this = uhash_put(*(void *)(v8 + 8), this, (uint64_t)a3, (int *)a5);
      if (*(int *)a5 <= 0) {
        ++*((_DWORD *)a3 + 2);
      }
    }
    else
    {
      *a5 = U_MEMORY_ALLOCATION_ERROR;
    }
  }
  return this;
}

int32x2_t icu::UnifiedCache::_registerPrimary(icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject *a3)
{
  *((unsigned char *)a2 + 12) = 1;
  *((void *)a3 + 2) = this;
  int32x2_t result = vadd_s32(*(int32x2_t *)((char *)this + 20), (int32x2_t)0x100000001);
  *(int32x2_t *)((char *)this + 20) = result;
  return result;
}

void icu::UnifiedCache::_putIfAbsentAndGet(icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, UErrorCode *a4)
{
  uint64_t v8 = (std::mutex *)qword_1EB20B608;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  uint64_t v9 = uhash_find(*((void *)this + 1), (uint64_t)a2);
  if (v9)
  {
    uint64_t v10 = (uint64_t)v9;
    if (!icu::UnifiedCache::_inProgress((uint64_t)this, (uint64_t)v9))
    {
      icu::UnifiedCache::_fetch((uint64_t)this, v10, (uint64_t)a3, a4);
      goto LABEL_7;
    }
    icu::UnifiedCache::_put((uint64_t)this, v10, (uint64_t)*a3, *a4);
  }
  else
  {
    UErrorCode v11 = U_ZERO_ERROR;
    icu::UnifiedCache::_putNew((uint64_t)this, a2, *a3, *a4, &v11);
  }
  icu::UnifiedCache::_runEvictionSlice(this);
LABEL_7:
  std::mutex::unlock(v8);
}

BOOL icu::UnifiedCache::_inProgress(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  int v3 = *(_DWORD *)(*(void *)(a2 + 16) + 8);
  if (v2)
  {
    if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 12), 1u)) {
      ++*(_DWORD *)(a1 + 24);
    }
    if (v3) {
      BOOL v4 = 0;
    }
    else {
      BOOL v4 = *(void *)(a1 + 48) == v2;
    }
    uint64_t v5 = v4;
    if (atomic_fetch_add((atomic_uint *volatile)(v2 + 12), 0xFFFFFFFF) == 1) {
      --*(_DWORD *)(a1 + 24);
    }
  }
  else
  {
    return !v3 && *(void *)(a1 + 48) == 0;
  }
  return v5;
}

uint64_t icu::UnifiedCache::_fetch(uint64_t result, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *a4 = *(_DWORD *)(*(void *)(a2 + 16) + 8);
  if (*(void *)a3 && atomic_fetch_add((atomic_uint *volatile)(*(void *)a3 + 12), 0xFFFFFFFF) == 1) {
    --*(_DWORD *)(result + 24);
  }
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a3 = v4;
  if (v4)
  {
    if (!atomic_fetch_add((atomic_uint *volatile)(v4 + 12), 1u)) {
      ++*(_DWORD *)(result + 24);
    }
  }
  return result;
}

void icu::UnifiedCache::_put(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = a2 + 8;
  uint64_t v5 = *(const icu::SharedObject **)(a2 + 8);
  uint64_t v6 = *(void *)(v7 + 8);
  *(_DWORD *)(v6 + 8) = a4;
  int v8 = *(_DWORD *)(a3 + 8);
  if (!v8)
  {
    *(unsigned char *)(v6 + 12) = 1;
    *(void *)(a3 + 16) = a1;
    *(int32x2_t *)(a1 + 20) = vadd_s32(*(int32x2_t *)(a1 + 20), (int32x2_t)0x100000001);
  }
  *(_DWORD *)(a3 + 8) = v8 + 1;
  *(void *)(a2 + 8) = a3;
  icu::UnifiedCache::removeSoftRef(a1, v5);
  uint64_t v9 = (std::condition_variable *)qword_1EB20B610;

  std::condition_variable::notify_all(v9);
}

uint64_t icu::UnifiedCache::_poll(icu::UnifiedCache *this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, UErrorCode *a4)
{
  v12.__m_ = (std::unique_lock<std::mutex>::mutex_type *)qword_1EB20B608;
  *(void *)&v12.__owns_ = 1;
  std::mutex::lock((std::mutex *)qword_1EB20B608);
  int v8 = uhash_find(*((void *)this + 1), (uint64_t)a2);
  if (v8)
  {
    uint64_t v9 = v8;
    while (icu::UnifiedCache::_inProgress((uint64_t)this, (uint64_t)v9))
    {
      std::condition_variable::wait((std::condition_variable *)qword_1EB20B610, &v12);
      uint64_t v9 = uhash_find(*((void *)this + 1), (uint64_t)a2);
      if (!v9) {
        goto LABEL_5;
      }
    }
    icu::UnifiedCache::_fetch((uint64_t)this, (uint64_t)v9, (uint64_t)a3, a4);
    uint64_t v10 = 1;
  }
  else
  {
LABEL_5:
    icu::UnifiedCache::_putNew((uint64_t)this, a2, *((const icu::SharedObject **)this + 6), U_ZERO_ERROR, a4);
    uint64_t v10 = 0;
  }
  if (v12.__owns_) {
    std::mutex::unlock(v12.__m_);
  }
  return v10;
}

const icu::SharedObject *icu::UnifiedCache::_get(icu::SharedObject **this, const icu::CacheKeyBase *a2, const icu::SharedObject **a3, const void *a4, UErrorCode *a5)
{
  int32x2_t result = (const icu::SharedObject *)icu::UnifiedCache::_poll((icu::UnifiedCache *)this, a2, a3, a5);
  if (result)
  {
    int32x2_t result = *a3;
    if (*a3) {
      BOOL v11 = result == this[6];
    }
    else {
      BOOL v11 = 0;
    }
    if (!v11) {
      return result;
    }
LABEL_7:
    int32x2_t result = (const icu::SharedObject *)icu::SharedObject::removeRef((uint64_t)result);
    *a3 = 0;
    return result;
  }
  if (*(int *)a5 <= 0)
  {
    std::unique_lock<std::mutex> v12 = (const icu::SharedObject *)(*(uint64_t (**)(const icu::CacheKeyBase *, const void *, UErrorCode *))(*(void *)a2 + 40))(a2, a4, a5);
    *a3 = v12;
    if (!v12) {
      sub_18C8917C4(this[6], a3);
    }
    icu::UnifiedCache::_putIfAbsentAndGet((icu::UnifiedCache *)this, a2, a3, a5);
    int32x2_t result = *a3;
    if (*a3)
    {
      if (result == this[6]) {
        goto LABEL_7;
      }
    }
  }
  return result;
}

icu::SharedObject *sub_18C8917C4(icu::SharedObject *this, icu::SharedObject **a2)
{
  int32x2_t result = *a2;
  if (*a2 != this)
  {
    if (result) {
      int32x2_t result = (icu::SharedObject *)icu::SharedObject::removeRef((uint64_t)result);
    }
    *a2 = this;
    if (this)
    {
      return (icu::SharedObject *)icu::SharedObject::addRef((uint64_t)this);
    }
  }
  return result;
}

uint64_t icu::UnifiedCache::removeHardRef(icu::UnifiedCache *this, atomic_uint *a2)
{
  if (!a2) {
    return 0;
  }
  unsigned int add = atomic_fetch_add(a2 + 3, 0xFFFFFFFF);
  uint64_t result = add - 1;
  if (add == 1) {
    --*((_DWORD *)this + 6);
  }
  return result;
}

uint64_t icu::UnifiedCache::addHardRef(icu::UnifiedCache *this, atomic_uint *a2)
{
  if (!a2) {
    return 0;
  }
  unsigned int add = atomic_fetch_add(a2 + 3, 1u);
  if (add) {
    return add + 1;
  }
  ++*((_DWORD *)this + 6);
  return 1;
}

BOOL icu::UnifiedCache::_inProgress(icu::UnifiedCache *this, const icu::SharedObject *a2, UErrorCode a3)
{
  return a3 == U_ZERO_ERROR && *((void *)this + 6) == (void)a2;
}

uint64_t sub_18C8918A8()
{
  if (qword_1EB20B600) {
    (*(void (**)(uint64_t))(*(void *)qword_1EB20B600 + 8))(qword_1EB20B600);
  }
  qword_1EB20B600 = 0;
  std::mutex::~mutex((std::mutex *)qword_1EB20B608);
  qword_1EB20B608 = 0;
  std::condition_variable::~condition_variable((std::condition_variable *)qword_1EB20B610);
  qword_1EB20B610 = 0;
  return 1;
}

void *icu::UnicodeFilter::getStaticClassID(icu::UnicodeFilter *this)
{
  return &unk_1E9191ED0;
}

uint64_t icu::UnicodeFilter::toMatcher(icu::UnicodeFilter *this)
{
  if (this) {
    return (uint64_t)this + 8;
  }
  else {
    return 0;
  }
}

uint64_t icu::UnicodeFilter::matches(uint64_t a1, uint64_t a2, int *a3, int a4, int a5)
{
  int v10 = *a3;
  if (*a3 < a4)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2);
    int v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, v11);
    int v10 = *a3;
    if (v12)
    {
      if (v11 < 0x10000) {
        int v13 = 1;
      }
      else {
        int v13 = 2;
      }
      int v14 = v10 + v13;
      goto LABEL_11;
    }
  }
  if (v10 > a4)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2);
    int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, v15);
    int v10 = *a3;
    if (v16)
    {
      BOOL v17 = __OFSUB__(v10, 1);
      int v18 = v10 - 1;
      *a3 = v18;
      if (v18 < 0 != v17) {
        return 2;
      }
      int v14 = *a3 - (((*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2) & 0xFFFF0000) != 0);
LABEL_11:
      *a3 = v14;
      return 2;
    }
  }
  return a5 && v10 == a4;
}

uint64_t non-virtual thunk to'icu::UnicodeFilter::matches(uint64_t a1, uint64_t a2, int *a3, int a4, int a5)
{
  return icu::UnicodeFilter::matches(a1 - 8, a2, a3, a4, a5);
}

void *icu::UnicodeFunctor::getStaticClassID(icu::UnicodeFunctor *this)
{
  return &unk_1E9191ED1;
}

uint64_t icu::UnicodeFunctor::toMatcher(icu::UnicodeFunctor *this)
{
  return 0;
}

uint64_t icu::UnicodeFunctor::toReplacer(icu::UnicodeFunctor *this)
{
  return 0;
}

void *icu::UnicodeSet::getStaticClassID(icu::UnicodeSet *this)
{
  return &unk_1E9191ED2;
}

void *icu::UnicodeSet::getDynamicClassID(icu::UnicodeSet *this)
{
  return &unk_1E9191ED2;
}

BOOL icu::UnicodeSet::hasStrings(icu::UnicodeSet *this)
{
  uint64_t v1 = *((void *)this + 10);
  return v1 && *(_DWORD *)(v1 + 8) != 0;
}

uint64_t icu::UnicodeSet::stringsSize(icu::UnicodeSet *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (v1) {
    return *(unsigned int *)(v1 + 8);
  }
  else {
    return 0;
  }
}

icu::UVector *icu::UnicodeSet::stringsContains(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  uint64_t result = (icu::UVector *)*((void *)this + 10);
  if (result) {
    return (icu::UVector *)((int)icu::UVector::indexOf(result, (uint64_t)a2, 0) >= 0);
  }
  return result;
}

double icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this)
{
  *(void *)this = &unk_1EDA47548;
  *((_DWORD *)this + 24) = 1114112;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *(void *)&double result = 0x100000019;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_1EDA47548;
  *((_DWORD *)this + 24) = 1114112;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *(void *)&double result = 0x100000019;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  *(void *)this = &unk_1EDA47548;
  *((_DWORD *)this + 24) = 1114112;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::add(this, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      int v4 = 0;
      goto LABEL_9;
    }
  }
  a2 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if (a3 > 0x10FFFF) {
LABEL_9:
  }
    a3 = v4;
  if (a2 < a3)
  {
    unsigned int v6 = a3 + 1;
    int v7 = *((_DWORD *)this + 7);
    if (v7)
    {
      if (v7 == 1)
      {
        int v8 = -2;
      }
      else
      {
        int v8 = *(_DWORD *)(*((void *)this + 2) + 4 * (v7 - 2));
        if (v8 > (int)a2) {
          goto LABEL_23;
        }
      }
      if (!*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
      {
        uint64_t v9 = *((void *)this + 2);
        if (v8 == a2)
        {
          *(_DWORD *)(v9 + 4 * (v7 - 2)) = v6;
          if (a3 == 1114111) {
            --*((_DWORD *)this + 7);
          }
          goto LABEL_31;
        }
        *(_DWORD *)(v9 + 4 * (v7 - 1)) = a2;
        int v11 = *((_DWORD *)this + 7);
        if (a3 >= 0x10FFFF)
        {
          if (!icu::UnicodeSet::ensureCapacity(this, v11 + 1)) {
            goto LABEL_31;
          }
          uint64_t v12 = *((void *)this + 2);
        }
        else
        {
          if (!icu::UnicodeSet::ensureCapacity(this, v11 + 2)) {
            goto LABEL_31;
          }
          uint64_t v12 = *((void *)this + 2);
          uint64_t v13 = *((int *)this + 7);
          *((_DWORD *)this + 7) = v13 + 1;
          *(_DWORD *)(v12 + 4 * v13) = v6;
        }
        uint64_t v14 = *((int *)this + 7);
        *((_DWORD *)this + 7) = v14 + 1;
        *(_DWORD *)(v12 + 4 * v14) = 1114112;
LABEL_31:
        uint64_t v15 = (void *)*((void *)this + 8);
        if (v15)
        {
          uprv_free(v15);
          *((void *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
        return this;
      }
    }
LABEL_23:
    v16[0] = a2;
    v16[1] = a3 + 1;
    v16[2] = 1114112;
    icu::UnicodeSet::add(this, v16, 2, 0);
    return this;
  }
  if (a2 == a3) {
    icu::UnicodeSet::add(this, a2);
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::copyFrom(this, a2, 0);
}

{
  icu::UVector **v4;
  uint64_t v5;
  uint64_t v6;
  const UChar *v7;
  UErrorCode v9;

  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 10) = 0;
  int v4 = (icu::UVector **)((char *)this + 80);
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  if (icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)a2 + 7)))
  {
    int v5 = *((int *)a2 + 7);
    *((_DWORD *)this + 7) = v5;
    memcpy(*((void **)this + 2), *((const void **)a2 + 2), 4 * v5);
    unsigned int v6 = *((void *)a2 + 10);
    if (v6
      && *(_DWORD *)(v6 + 8)
      && ((uint64_t v9 = U_ZERO_ERROR, !icu::UnicodeSet::allocateStrings(this, &v9))
       || (icu::UVector::assign(*v4, *((void *)a2 + 10), (uint64_t (*)(uint64_t, uint64_t))sub_18C8921F8, &v9),
           v9 > U_ZERO_ERROR)))
    {
      icu::UnicodeSet::clear(this);
      *((unsigned char *)this + 32) = 1;
    }
    else
    {
      int v7 = (const UChar *)*((void *)a2 + 8);
      if (v7) {
        icu::UnicodeSet::setPattern((uint64_t)this, v7, *((_DWORD *)a2 + 18));
      }
    }
  }
  return this;
}

{
  return icu::UnicodeSet::UnicodeSet(this, a2);
}

icu::UnicodeSet *icu::UnicodeSet::operator=(icu::UnicodeSet *a1, const icu::UnicodeSet *a2)
{
  return icu::UnicodeSet::copyFrom(a1, a2, 0);
}

uint64_t icu::UnicodeSet::ensureCapacity(icu::UnicodeSet *this, int a2)
{
  if (a2 > 1114112) {
    int v2 = 1114113;
  }
  else {
    int v2 = a2;
  }
  if (v2 <= *((_DWORD *)this + 6)) {
    return 1;
  }
  if ((2 * v2) > 0x110000) {
    int v4 = 1114113;
  }
  else {
    int v4 = 2 * v2;
  }
  if (v2 <= 0x9C4) {
    int v4 = 5 * v2;
  }
  if (v2 <= 24) {
    int v5 = v2 + 25;
  }
  else {
    int v5 = v4;
  }
  unsigned int v6 = uprv_malloc(4 * v5);
  if (v6)
  {
    int v7 = v6;
    int v8 = (char *)*((void *)this + 2);
    memcpy(v6, v8, 4 * *((int *)this + 7));
    if (v8 != (char *)this + 96) {
      uprv_free(v8);
    }
    *((void *)this + 2) = v7;
    *((_DWORD *)this + 6) = v5;
    return 1;
  }
  icu::UnicodeSet::clear(this);
  uint64_t result = 0;
  *((unsigned char *)this + 32) = 1;
  return result;
}

uint64_t icu::UnicodeSet::allocateStrings(icu::UnicodeSet *this, UErrorCode *a2)
{
  if (*(int *)a2 > 0) {
    return 0;
  }
  uint64_t v6 = icu::UMemory::operator new((icu::UMemory *)0x28, (unint64_t)a2);
  if (v6)
  {
    uint64_t v2 = 1;
    uint64_t v7 = icu::UVector::UVector(v6, uprv_deleteUObject, uhash_compareUnicodeString, 1, a2);
    *((void *)this + 10) = v7;
    if (*(int *)a2 >= 1)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      uint64_t v2 = 0;
      *((void *)this + 10) = 0;
    }
  }
  else
  {
    uint64_t v2 = 0;
    *((void *)this + 10) = 0;
    *a2 = U_MEMORY_ALLOCATION_ERROR;
  }
  return v2;
}

icu::UnicodeString *sub_18C8921F8(icu::UnicodeString **a1, UChar ***a2)
{
  uint64_t result = (icu::UnicodeString *)icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2);
  if (result) {
    uint64_t result = icu::UnicodeString::UnicodeString(result, *a2);
  }
  *a1 = result;
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::setToBogus(icu::UnicodeSet *this)
{
  uint64_t result = icu::UnicodeSet::clear(this);
  *((unsigned char *)result + 32) = 1;
  return result;
}

UChar *icu::UnicodeSet::setPattern(uint64_t a1, const UChar *a2, int32_t a3)
{
  uint64_t v6 = *(void **)(a1 + 64);
  if (v6)
  {
    uprv_free(v6);
    *(void *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 72) = 0;
  }
  uint64_t result = (UChar *)uprv_malloc(2 * (a3 + 1));
  *(void *)(a1 + 64) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 72) = a3;
    uint64_t result = u_memcpy(result, a2, a3);
    *(_WORD *)(*(void *)(a1 + 64) + 2 * *(int *)(a1 + 72)) = 0;
  }
  return result;
}

void icu::UnicodeSet::~UnicodeSet(icu::UnicodeSet *this)
{
  uint64_t v2 = (char *)*((void *)this + 2);
  if (v2 != (char *)this + 96) {
    uprv_free(v2);
  }
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = (char *)*((void *)this + 6);
  if (v4 != (char *)this + 96) {
    uprv_free(v4);
  }
  uint64_t v5 = *((void *)this + 10);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 11);
  if (v6)
  {
    uint64_t v7 = (void *)sub_18C8996FC(v6);
    icu::UMemory::operator delete(v7);
  }
  int v8 = (void *)*((void *)this + 8);
  if (v8)
  {
    uprv_free(v8);
    *((void *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }

  icu::UnicodeFilter::~UnicodeFilter(this);
}

{
  void *v1;
  uint64_t vars8;

  icu::UnicodeSet::~UnicodeSet(this);

  icu::UMemory::operator delete(v1);
}

void icu::UnicodeSet::releasePattern(icu::UnicodeSet *this)
{
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    uprv_free(v2);
    *((void *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
}

void non-virtual thunk to'icu::UnicodeSet::~UnicodeSet(icu::UnicodeSet *this)
{
}

{
  void *v1;
  uint64_t vars8;

  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)((char *)this - 8));

  icu::UMemory::operator delete(v1);
}

icu::UnicodeSet *icu::UnicodeSet::copyFrom(icu::UnicodeSet *this, const icu::UnicodeSet *a2, int a3)
{
  if (this == a2 || *((void *)this + 5) || *((void *)this + 11)) {
    return this;
  }
  if (*((unsigned char *)a2 + 32)) {
    goto LABEL_30;
  }
  if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)a2 + 7))) {
    return this;
  }
  uint64_t v6 = *((int *)a2 + 7);
  *((_DWORD *)this + 7) = v6;
  memcpy(*((void **)this + 2), *((const void **)a2 + 2), 4 * v6);
  if (!a3 && *((void *)a2 + 5))
  {
    uint64_t v8 = icu::UMemory::operator new((icu::UMemory *)0x368, v7);
    if (!v8)
    {
      *((void *)this + 5) = 0;
      goto LABEL_30;
    }
    sub_18C7E90A8(v8, *((void *)a2 + 5), *((void *)this + 2), *((_DWORD *)this + 7));
    *((void *)this + 5) = v9;
  }
  unint64_t v10 = *((void *)a2 + 10);
  if (v10 && *(_DWORD *)(v10 + 8))
  {
    UErrorCode v17 = U_ZERO_ERROR;
    int v11 = (icu::UVector *)*((void *)this + 10);
    if (!v11)
    {
      if (!icu::UnicodeSet::allocateStrings(this, &v17)) {
        goto LABEL_30;
      }
      int v11 = (icu::UVector *)*((void *)this + 10);
      unint64_t v10 = *((void *)a2 + 10);
    }
    icu::UVector::assign(v11, v10, (uint64_t (*)(uint64_t, uint64_t))sub_18C8921F8, &v17);
    if (v17 <= U_ZERO_ERROR) {
      goto LABEL_20;
    }
LABEL_30:
    icu::UnicodeSet::clear(this);
    *((unsigned char *)this + 32) = 1;
    return this;
  }
  uint64_t v12 = *((void *)this + 10);
  if (v12 && *(_DWORD *)(v12 + 8)) {
    icu::UVector::removeAllElements(v12);
  }
LABEL_20:
  if (a3 || !*((void *)a2 + 11)) {
    goto LABEL_24;
  }
  uint64_t v13 = icu::UMemory::operator new((icu::UMemory *)0x188, v10);
  if (!v13)
  {
    *((void *)this + 11) = 0;
    goto LABEL_30;
  }
  *((void *)this + 11) = sub_18C899698(v13, *((void *)a2 + 11), *((void *)this + 10));
LABEL_24:
  uint64_t v14 = (void *)*((void *)this + 8);
  if (v14)
  {
    uprv_free(v14);
    *((void *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
  uint64_t v15 = (const UChar *)*((void *)a2 + 8);
  if (v15) {
    icu::UnicodeSet::setPattern((uint64_t)this, v15, *((_DWORD *)a2 + 18));
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::clone@<X0>(icu::UnicodeSet *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result) {
    return icu::UnicodeSet::UnicodeSet(result, this);
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::cloneAsThawed@<X0>(icu::UnicodeSet *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, a2);
  if (result) {
    return icu::UnicodeSet::UnicodeSet(result, this);
  }
  return result;
}

BOOL icu::UnicodeSet::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  if (v2 != *(_DWORD *)(a2 + 28)) {
    return 0;
  }
  if ((int)v2 >= 1)
  {
    uint64_t v3 = *(int **)(a1 + 16);
    int v4 = *(int **)(a2 + 16);
    do
    {
      int v6 = *v3++;
      int v5 = v6;
      int v7 = *v4++;
      if (v5 != v7) {
        return 0;
      }
    }
    while (--v2);
  }
  uint64_t v8 = *(void *)(a1 + 80);
  if (!v8)
  {
    uint64_t v11 = *(void *)(a2 + 80);
    return !v11 || !*(_DWORD *)(v11 + 8);
  }
  int v9 = *(_DWORD *)(v8 + 8);
  uint64_t v10 = *(void *)(a2 + 80);
  if (v10)
  {
    if ((v9 != 0) == (*(_DWORD *)(v10 + 8) != 0)) {
      goto LABEL_17;
    }
    return 0;
  }
  if (v9) {
    return 0;
  }
  uint64_t v10 = 0;
LABEL_17:
  if (!*(_DWORD *)(v8 + 8)) {
    return 1;
  }
  BOOL result = icu::UVector::operator==(v8, v10);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t icu::UnicodeSet::hashCode(icu::UnicodeSet *this)
{
  uint64_t result = *((unsigned int *)this + 7);
  if ((int)result >= 1)
  {
    uint64_t v3 = (int *)*((void *)this + 2);
    uint64_t v4 = result;
    do
    {
      int v5 = *v3++;
      uint64_t result = (v5 + 1000003 * result);
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t icu::UnicodeSet::size(icu::UnicodeSet *this)
{
  unint64_t v1 = *((unsigned int *)this + 7);
  if ((int)v1 < 2)
  {
    int v2 = 0;
  }
  else
  {
    int v2 = 0;
    unint64_t v3 = v1 >> 1;
    uint64_t v4 = (_DWORD *)(*((void *)this + 2) + 4);
    do
    {
      int v2 = *v4 + v2 - *(v4 - 1);
      v4 += 2;
      --v3;
    }
    while (v3);
  }
  uint64_t v5 = *((void *)this + 10);
  if (v5) {
    LODWORD(v5) = *(_DWORD *)(v5 + 8);
  }
  return (v5 + v2);
}

uint64_t icu::UnicodeSet::getRangeCount(icu::UnicodeSet *this)
{
  return (*((_DWORD *)this + 7) / 2);
}

uint64_t icu::UnicodeSet::getRangeEnd(icu::UnicodeSet *this, int a2)
{
  return (*(_DWORD *)(*((void *)this + 2) + 4 * ((2 * a2) | 1)) - 1);
}

uint64_t icu::UnicodeSet::getRangeStart(icu::UnicodeSet *this, int a2)
{
  return *(unsigned int *)(*((void *)this + 2) + 8 * a2);
}

BOOL icu::UnicodeSet::isEmpty(icu::UnicodeSet *this)
{
  if (*((_DWORD *)this + 7) != 1) {
    return 0;
  }
  uint64_t v1 = *((void *)this + 10);
  return !v1 || *(_DWORD *)(v1 + 8) == 0;
}

uint64_t icu::UnicodeSet::contains(icu::UnicodeSet *this, int a2)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
LABEL_2:
    unint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 16);
    return v3(v2);
  }
  else
  {
    while (1)
    {
      uint64_t v5 = *((void *)this + 11);
      if (!v5) {
        break;
      }
      this = (icu::UnicodeSet *)(v5 + 8);
      uint64_t v2 = *(void *)(v5 + 48);
      if (v2) {
        goto LABEL_2;
      }
    }
    if (a2 < 1114112) {
      return icu::UnicodeSet::findCodePoint(this, a2) & 1;
    }
    else {
      return 0;
    }
  }
}

uint64_t icu::UnicodeSet::findCodePoint(icu::UnicodeSet *this, int a2)
{
  uint64_t v2 = (_DWORD *)*((void *)this + 2);
  if (*v2 > a2) {
    return 0;
  }
  int v4 = *((_DWORD *)this + 7);
  uint64_t result = (v4 - 1);
  if (v4 >= 2 && v2[v4 - 2] > a2 && v4 != 2)
  {
    unsigned int v6 = 0;
    unsigned int v7 = result >> 1;
    do
    {
      if (v2[v7] > a2)
      {
        uint64_t result = v7;
      }
      else
      {
        unsigned int v6 = v7;
        uint64_t result = result;
      }
      unsigned int v7 = (int)(result + v6) >> 1;
    }
    while (v7 != v6);
  }
  return result;
}

BOOL icu::UnicodeSet::contains(icu::UnicodeSet *this, int a2, int a3)
{
  int CodePoint = icu::UnicodeSet::findCodePoint(this, a2);
  return (CodePoint & 1) != 0 && *(_DWORD *)(*((void *)this + 2) + 4 * CodePoint) > a3;
}

icu::UVector *icu::UnicodeSet::contains(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
  if (SingleCP < 0)
  {
    uint64_t result = (icu::UVector *)*((void *)this + 10);
    if (result) {
      return (icu::UVector *)((int)icu::UVector::indexOf(result, (uint64_t)a2, 0) >= 0);
    }
  }
  else
  {
    return (icu::UVector *)icu::UnicodeSet::contains(this, SingleCP);
  }
  return result;
}

uint64_t icu::UnicodeSet::getSingleCP(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 0x8000u) == 0) {
    unsigned int v3 = v2 >> 5;
  }
  else {
    unsigned int v3 = *((_DWORD *)this + 3);
  }
  if (v3 == 2)
  {
    uint64_t result = icu::UnicodeString::char32At(this, 0);
    if ((int)result >= 0x10000) {
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  if (v3 != 1) {
    return 0xFFFFFFFFLL;
  }
  if ((v2 & 2) != 0) {
    int v4 = (unsigned __int16 *)((char *)this + 10);
  }
  else {
    int v4 = (unsigned __int16 *)*((void *)this + 3);
  }
  return *v4;
}

uint64_t icu::UnicodeSet::containsAll(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  unint64_t v4 = *((unsigned int *)a2 + 7);
  if ((int)v4 < 2)
  {
LABEL_6:
    uint64_t v8 = (const icu::UVector *)*((void *)a2 + 10);
    if (v8 && *((_DWORD *)v8 + 2))
    {
      uint64_t result = *((void *)this + 10);
      if (result) {
        return icu::UVector::containsAll((icu::UVector *)result, v8);
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    unint64_t v5 = v4 >> 1;
    unsigned int v6 = (_DWORD *)(*((void *)a2 + 2) + 4);
    while (1)
    {
      int CodePoint = icu::UnicodeSet::findCodePoint(this, *(v6 - 1));
      if ((CodePoint & 1) == 0 || *(_DWORD *)(*((void *)this + 2) + 4 * CodePoint) < *v6) {
        return 0;
      }
      v6 += 2;
      if (!--v5) {
        goto LABEL_6;
      }
    }
  }
  return result;
}

BOOL icu::UnicodeSet::containsAll(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  if ((v3 & 0x11) != 0)
  {
    unint64_t v4 = 0;
  }
  else if ((v3 & 2) != 0)
  {
    unint64_t v4 = (UChar *)((char *)a2 + 10);
  }
  else
  {
    unint64_t v4 = (UChar *)*((void *)a2 + 3);
  }
  int v5 = (__int16)v3;
  unsigned int v6 = v3 >> 5;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *((unsigned int *)a2 + 3);
  }
  int v8 = icu::UnicodeSet::span(this, v4, v7, 1);
  unsigned int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = (__int16)v9;
  unsigned int v11 = v9 >> 5;
  if (v10 < 0) {
    unsigned int v11 = *((_DWORD *)a2 + 3);
  }
  return v8 == v11;
}

unint64_t icu::UnicodeSet::span(icu::UnicodeSet *this, UChar *s, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v5 = u_strlen(s);
    if (!v5) {
      return 0;
    }
  }
  else
  {
    int v8 = (unsigned int *)*((void *)this + 5);
    if (v8) {
      return (unint64_t)((char *)sub_18C7E93D0(v8, s, (unint64_t)&s[a3], a4) - (char *)s) >> 1;
    }
  }
  uint64_t v11 = *((void *)this + 11);
  if (!v11)
  {
    uint64_t v12 = *((void *)this + 10);
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      uint64_t v31 = 0;
      if (a4) {
        uint64_t v13 = 42;
      }
      else {
        uint64_t v13 = 41;
      }
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v22 = 0u;
      memset(v21, 0, sizeof(v21));
      sub_18C8995A4(v21, this, v12, v13);
      if (HIDWORD(v22))
      {
        uint64_t v9 = sub_18C899700((uint64_t)v21, s, v5, a4);
        sub_18C8996FC(v21);
        return v9;
      }
      sub_18C8996FC(v21);
    }
    uint64_t v9 = 0;
    int v14 = a4 != 0;
    do
    {
      uint64_t v15 = (int)v9 + 1;
      int v16 = s[(int)v9];
      if ((v16 & 0xFC00) == 0xD800 && v15 != v5)
      {
        int v18 = s[v15];
        BOOL v19 = (v18 & 0xFC00) == 56320;
        int v20 = v18 + (v16 << 10) - 56613888;
        if (v19) {
          int v16 = v20;
        }
        if (v19) {
          uint64_t v15 = (v9 + 2);
        }
        else {
          uint64_t v15 = v15;
        }
      }
      if (v14 != icu::UnicodeSet::contains(this, v16)) {
        break;
      }
      uint64_t v9 = v15;
    }
    while ((int)v15 < (int)v5);
    return v9;
  }

  return sub_18C899700(v11, s, v5, a4);
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, int a2, int a3)
{
  int CodePoint = icu::UnicodeSet::findCodePoint(this, a2);
  return (CodePoint & 1) == 0 && *(_DWORD *)(*((void *)this + 2) + 4 * CodePoint) > a3;
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, const icu::UnicodeSet *a2)
{
  unint64_t v4 = *((unsigned int *)a2 + 7);
  if ((int)v4 < 2)
  {
LABEL_6:
    int v8 = (icu::UVector *)*((void *)this + 10);
    return !v8
        || (uint64_t v9 = (const icu::UVector *)*((void *)a2 + 10)) == 0
        || !*((_DWORD *)v9 + 2)
        || icu::UVector::containsNone(v8, v9) != 0;
  }
  else
  {
    unint64_t v5 = v4 >> 1;
    unsigned int v6 = (_DWORD *)(*((void *)a2 + 2) + 4);
    while (1)
    {
      int CodePoint = icu::UnicodeSet::findCodePoint(this, *(v6 - 1));
      if ((CodePoint & 1) != 0 || *(_DWORD *)(*((void *)this + 2) + 4 * CodePoint) < *v6) {
        return 0;
      }
      v6 += 2;
      if (!--v5) {
        goto LABEL_6;
      }
    }
  }
}

BOOL icu::UnicodeSet::containsNone(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  if ((v3 & 0x11) != 0)
  {
    unint64_t v4 = 0;
  }
  else if ((v3 & 2) != 0)
  {
    unint64_t v4 = (UChar *)((char *)a2 + 10);
  }
  else
  {
    unint64_t v4 = (UChar *)*((void *)a2 + 3);
  }
  int v5 = (__int16)v3;
  unsigned int v6 = v3 >> 5;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *((unsigned int *)a2 + 3);
  }
  int v8 = icu::UnicodeSet::span(this, v4, v7, 0);
  unsigned int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = (__int16)v9;
  unsigned int v11 = v9 >> 5;
  if (v10 < 0) {
    unsigned int v11 = *((_DWORD *)a2 + 3);
  }
  return v8 == v11;
}

uint64_t icu::UnicodeSet::matchesIndexValue(icu::UnicodeSet *this, unsigned int a2)
{
  unint64_t v4 = *((unsigned int *)this + 7);
  if ((int)v4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    unsigned int v6 = (unsigned char *)(*((void *)this + 2) + 4);
    do
    {
      unsigned int v7 = *((_DWORD *)v6 - 1);
      unsigned int v8 = (*v6 - 1);
      if (((*(_DWORD *)v6 - 1) ^ *((_DWORD *)v6 - 1)) > 0xFF)
      {
        if (v7 <= a2 || v8 >= a2) {
          return 1;
        }
      }
      else if (v7 <= a2 && v8 >= a2)
      {
        return 1;
      }
      v6 += 8;
      --v5;
    }
    while (v5);
  }
  uint64_t result = *((void *)this + 10);
  if (result)
  {
    if (*(int *)(result + 8) < 1)
    {
      return 0;
    }
    else
    {
      signed int v12 = 0;
      while (1)
      {
        uint64_t v13 = (unsigned __int16 *)icu::UVector::elementAt((icu::UVector *)result, v12);
        int v14 = (uint64_t *)v13[4];
        if (v14 >= 0x20
          && a2 == icu::UnicodeString::char32At(v14, (icu::UnicodeString *)v13, 0))
        {
          break;
        }
        ++v12;
        uint64_t result = *((void *)this + 10);
        if (v12 >= *(_DWORD *)(result + 8)) {
          return 0;
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t non-virtual thunk to'icu::UnicodeSet::matchesIndexValue(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::matchesIndexValue((icu::UnicodeSet *)((char *)this - 8), a2);
}

uint64_t icu::UnicodeSet::matches(int **this, const icu::Replaceable *a2, int *a3, int a4, int a5)
{
  int v7 = *a3;
  if (*a3 == a4)
  {
    int v8 = icu::UnicodeSet::contains((icu::UnicodeSet *)this, 0xFFFF);
    if (a5) {
      unsigned int v9 = 1;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v8) {
      return v9;
    }
    else {
      return 0;
    }
  }
  int v14 = this[10];
  if (!v14
    || !v14[2]
    || (unsigned int v15 = (*(uint64_t (**)(const icu::Replaceable *, void))(*(void *)a2 + 72))(a2, *a3), v16 = this[10], v16[2] < 1))
  {
LABEL_51:
    return icu::UnicodeFilter::matches((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  }
  uint64_t v17 = 0;
  signed int v18 = 0;
  while (1)
  {
    uint64_t v19 = icu::UVector::elementAt((icu::UVector *)v16, v18);
    unsigned int v20 = *(unsigned __int16 *)(v19 + 8);
    if (v20 < 0x20)
    {
LABEL_44:
      uint64_t v30 = v17;
      goto LABEL_45;
    }
    uint64_t v21 = v19;
    if (v7 >= a4)
    {
      if ((v20 & 0x8000) != 0) {
        unsigned int v24 = *(_DWORD *)(v19 + 12);
      }
      else {
        unsigned int v24 = v20 >> 5;
      }
      unsigned int v22 = v24 - 1;
      if ((v20 & 0x8000) == 0)
      {
LABEL_15:
        unsigned int v23 = v20 >> 5;
        goto LABEL_21;
      }
    }
    else
    {
      unsigned int v22 = 0;
      if ((v20 & 0x8000) == 0) {
        goto LABEL_15;
      }
    }
    unsigned int v23 = *(_DWORD *)(v19 + 12);
LABEL_21:
    if (v23 <= v22)
    {
      unsigned int v26 = 0xFFFF;
    }
    else
    {
      uint64_t v25 = (v20 & 2) != 0 ? v19 + 10 : *(void *)(v19 + 24);
      unsigned int v26 = *(unsigned __int16 *)(v25 + 2 * (int)v22);
    }
    if (v7 < a4 && v26 > v15) {
      break;
    }
    if (v26 != v15) {
      goto LABEL_44;
    }
    int matched = icu::UnicodeSet::matchRest((uint64_t)a2, *a3, a4, v19);
    if (a5)
    {
      int v28 = *a3 - a4;
      if (v7 < a4) {
        int v28 = a4 - *a3;
      }
      if (matched == v28) {
        return 1;
      }
    }
    int v29 = *(__int16 *)(v21 + 8) < 0 ? *(_DWORD *)(v21 + 12) : *(unsigned __int16 *)(v21 + 8) >> 5;
    if (matched != v29) {
      goto LABEL_44;
    }
    if (matched <= (int)v17) {
      uint64_t v30 = v17;
    }
    else {
      uint64_t v30 = matched;
    }
    if (v7 < a4 && matched < (int)v17)
    {
LABEL_46:
      if (!v30) {
        goto LABEL_51;
      }
      goto LABEL_47;
    }
LABEL_45:
    ++v18;
    int v16 = this[10];
    uint64_t v17 = v30;
    if (v18 >= v16[2]) {
      goto LABEL_46;
    }
  }
  LODWORD(v30) = v17;
  if (!v17) {
    goto LABEL_51;
  }
LABEL_47:
  if (v7 >= a4) {
    LODWORD(v30) = -(int)v30;
  }
  *a3 += v30;
  return 2;
}

uint64_t icu::UnicodeSet::matchRest(uint64_t a1, int a2, int a3, uint64_t a4)
{
  unsigned int v6 = *(unsigned __int16 *)(a4 + 8);
  int v7 = (__int16)v6;
  unsigned int v8 = v6 >> 5;
  if (v7 < 0) {
    unsigned int v8 = *(_DWORD *)(a4 + 12);
  }
  unsigned int v9 = a2 - a3;
  if (a2 >= a3)
  {
    if ((int)v9 >= (int)v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = v9;
    }
    if ((int)v10 >= 2)
    {
      unsigned int v18 = v8 - 2;
      uint64_t v19 = (a2 - 1);
      uint64_t v20 = v10 - 1;
      while (1)
      {
        int v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v19);
        unsigned int v22 = *(unsigned __int16 *)(a4 + 8);
        unsigned int v23 = (v22 & 0x8000u) == 0 ? v22 >> 5 : *(_DWORD *)(a4 + 12);
        if (v23 <= v18)
        {
          int v25 = 0xFFFF;
        }
        else
        {
          uint64_t v24 = (v22 & 2) != 0 ? a4 + 10 : *(void *)(a4 + 24);
          int v25 = *(unsigned __int16 *)(v24 + 2 * (int)v18);
        }
        if (v21 != v25) {
          break;
        }
        --v18;
        uint64_t v19 = (v19 - 1);
        if (!--v20) {
          return v10;
        }
      }
      return 0;
    }
  }
  else
  {
    if (a3 - a2 >= (int)v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = (a3 - a2);
    }
    if ((int)v10 >= 2)
    {
      unint64_t v12 = 1;
      while (1)
      {
        int v13 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 72))(a1, (a2 + v12));
        unsigned int v14 = *(unsigned __int16 *)(a4 + 8);
        unint64_t v15 = (v14 & 0x8000u) == 0 ? v14 >> 5 : *(unsigned int *)(a4 + 12);
        if (v12 >= v15)
        {
          int v17 = 0xFFFF;
        }
        else
        {
          uint64_t v16 = (v14 & 2) != 0 ? a4 + 10 : *(void *)(a4 + 24);
          int v17 = *(unsigned __int16 *)(v16 + 2 * v12);
        }
        if (v13 != v17) {
          break;
        }
        if (v10 == ++v12) {
          return v10;
        }
      }
      return 0;
    }
  }
  return v10;
}

uint64_t non-virtual thunk to'icu::UnicodeSet::matches(int **this, const icu::Replaceable *a2, int *a3, int a4, int a5)
{
  return icu::UnicodeSet::matches(this - 1, a2, a3, a4, a5);
}

icu::UnicodeSet *icu::UnicodeSet::addMatchSetTo(icu::UnicodeSet *this, icu::UVector **a2)
{
  return icu::UnicodeSet::addAll(a2, this);
}

icu::UnicodeSet *icu::UnicodeSet::addAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  int v4 = *((_DWORD *)a2 + 7);
  if (v4 >= 1)
  {
    unint64_t v5 = (int *)*((void *)a2 + 2);
    if (v5) {
      icu::UnicodeSet::add((icu::UnicodeSet *)this, v5, v4, 0);
    }
  }
  unsigned int v6 = (icu::UVector *)*((void *)a2 + 10);
  if (v6 && *((int *)v6 + 2) >= 1)
  {
    signed int v7 = 0;
    do
    {
      unsigned int v8 = (UChar **)icu::UVector::elementAt(v6, v7);
      unsigned int v9 = this[10];
      if (!v9 || (icu::UVector::indexOf(v9, (uint64_t)v8, 0) & 0x80000000) != 0) {
        icu::UnicodeSet::_add((icu::UnicodeSet *)this, v8);
      }
      ++v7;
      unsigned int v6 = (icu::UVector *)*((void *)a2 + 10);
    }
    while (v7 < *((_DWORD *)v6 + 2));
  }
  return (icu::UnicodeSet *)this;
}

icu::UnicodeSet *non-virtual thunk to'icu::UnicodeSet::addMatchSetTo(icu::UnicodeSet *this, icu::UVector **a2)
{
  return icu::UnicodeSet::addAll(a2, (icu::UnicodeSet *)((char *)this - 8));
}

uint64_t icu::UnicodeSet::indexOf(icu::UnicodeSet *this, unsigned int a2)
{
  if (HIWORD(a2) <= 0x10u)
  {
    int v3 = 0;
    for (__int16 i = (int *)(*((void *)this + 2) + 4); ; i += 2)
    {
      int v5 = *(i - 1);
      if (v5 > (int)a2) {
        break;
      }
      int v6 = v3;
      int v7 = *i;
      int v3 = v3 - v5 + v7;
      if (v7 > (int)a2) {
        return v6 + a2 - v5;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t icu::UnicodeSet::charAt(icu::UnicodeSet *this, int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    int64_t v2 = 0;
    while (v2 < (uint64_t)(*((int *)this + 7) & 0xFFFFFFFFFFFFFFFELL))
    {
      int v3 = a2;
      uint64_t v4 = *((void *)this + 2) + 4 * v2;
      v2 += 2;
      int v5 = *(_DWORD *)v4;
      LODWORD(v4) = *(_DWORD *)(v4 + 4) - *(_DWORD *)v4;
      BOOL v6 = __OFSUB__(a2, v4);
      a2 -= v4;
      if (a2 < 0 != v6) {
        return (v5 + v3);
      }
    }
  }
  return 0xFFFFFFFFLL;
}

icu::UnicodeSet *icu::UnicodeSet::set(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  int v5 = icu::UnicodeSet::clear(this);

  return icu::UnicodeSet::complement(v5, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::clear(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11))
  {
    **((_DWORD **)this + 2) = 1114112;
    *((_DWORD *)this + 7) = 1;
    int64_t v2 = (void *)*((void *)this + 8);
    if (v2)
    {
      uprv_free(v2);
      *((void *)this + 8) = 0;
      *((_DWORD *)this + 18) = 0;
    }
    uint64_t v3 = *((void *)this + 10);
    if (v3) {
      icu::UVector::removeAllElements(v3);
    }
    *((unsigned char *)this + 32) = 0;
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 5) || *((void *)this + 11) || (*((unsigned char *)this + 32) & 1) != 0) {
    return this;
  }
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
    goto LABEL_8;
  }
  int v5 = 1114111;
  if (a2 > 0x10FFFF) {
LABEL_8:
  }
    a2 = v5;
  if ((a3 & 0x80000000) != 0)
  {
    int v4 = 0;
  }
  else if (a3 <= 0x10FFFF)
  {
    goto LABEL_14;
  }
  a3 = v4;
LABEL_14:
  if (a2 <= a3)
  {
    v8[0] = a2;
    v8[1] = a3 + 1;
    void v8[2] = 1114112;
    icu::UnicodeSet::exclusiveOr(this, v8, 2, 0);
  }
  BOOL v6 = (void *)*((void *)this + 8);
  if (v6)
  {
    uprv_free(v6);
    *((void *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
  return this;
}

void icu::UnicodeSet::add(icu::UnicodeSet *this, int *a2, int a3, char a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 5)
    || *((void *)this + 11)
    || !a2
    || (*((unsigned char *)this + 32) & 1) != 0
    || !icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    return;
  }
  int v8 = 0;
  uint64_t v9 = (int *)*((void *)this + 2);
  int v10 = *v9;
  int v11 = *a2;
  int v12 = 1;
  int v13 = 1;
  while (2)
  {
    switch(a4)
    {
      case 0:
        if (v10 >= v11)
        {
          if (v11 >= v10)
          {
            if (v10 == 1114112) {
              goto LABEL_55;
            }
            uint64_t v22 = *((void *)this + 6);
            unsigned int v23 = v8 - 1;
            if (v8 >= 1 && (int v24 = *(_DWORD *)(v22 + 4 * v23), v10 <= v24))
            {
              if (v9[v12] <= v24) {
                int v10 = *(_DWORD *)(v22 + 4 * v23);
              }
              else {
                int v10 = v9[v12];
              }
            }
            else
            {
              unsigned int v23 = v8 + 1;
              *(_DWORD *)(v22 + 4 * v8) = v10;
              int v10 = v9[v12];
            }
            ++v12;
            int v11 = a2[v13++];
            a4 = 3;
            int v8 = v23;
          }
          else
          {
            uint64_t v19 = *((void *)this + 6);
            unsigned int v20 = v8 - 1;
            if (v8 >= 1 && (int v21 = *(_DWORD *)(v19 + 4 * v20), v11 <= v21))
            {
              if (a2[v13] <= v21) {
                int v11 = *(_DWORD *)(v19 + 4 * v20);
              }
              else {
                int v11 = a2[v13];
              }
            }
            else
            {
              unsigned int v20 = v8 + 1;
              *(_DWORD *)(v19 + 4 * v8) = v11;
              int v11 = a2[v13];
            }
            ++v13;
            a4 = 2;
            int v8 = v20;
          }
        }
        else
        {
          uint64_t v14 = *((void *)this + 6);
          unsigned int v15 = v8 - 1;
          if (v8 >= 1 && (int v16 = *(_DWORD *)(v14 + 4 * v15), v10 <= v16))
          {
            if (v9[v12] <= v16) {
              int v10 = *(_DWORD *)(v14 + 4 * v15);
            }
            else {
              int v10 = v9[v12];
            }
          }
          else
          {
            unsigned int v15 = v8 + 1;
            *(_DWORD *)(v14 + 4 * v8) = v10;
            int v10 = v9[v12];
          }
          ++v12;
          a4 = 1;
          int v8 = v15;
        }
        continue;
      case 1:
        if (v10 >= v11)
        {
          if (v11 >= v10)
          {
            if (v10 == 1114112) {
              goto LABEL_55;
            }
            int v10 = v9[v12++];
            int v11 = a2[v13++];
            a4 = 2;
          }
          else
          {
            int v11 = a2[v13++];
            a4 = 3;
          }
        }
        else
        {
          int v17 = *((_DWORD *)this + 14);
          if ((v8 >= v17 || v12 >= *((_DWORD *)this + 6))
            && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            int v18 = *((_DWORD *)this + 6);
            *(_DWORD *)buf = 67110912;
            int v28 = v8;
            __int16 v29 = 1024;
            int v30 = v17;
            __int16 v31 = 1024;
            int v32 = v12;
            __int16 v33 = 1024;
            int v34 = v18;
            __int16 v35 = 1024;
            int v36 = v13;
            __int16 v37 = 1024;
            int v38 = a3;
            __int16 v39 = 1024;
            int v40 = v10;
            __int16 v41 = 1024;
            int v42 = v11;
            _os_log_impl(&dword_18C7E8000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "# UnicodeSet::add case 1, k %d bufCap %d i %d cap %d j %d otherLen %d a %04X b %04X", buf, 0x32u);
            uint64_t v9 = (int *)*((void *)this + 2);
          }
          a4 = 0;
          *(_DWORD *)(*((void *)this + 6) + 4 * v8++) = v10;
          int v10 = v9[v12++];
        }
        continue;
      case 2:
        if (v11 < v10)
        {
          a4 = 0;
          *(_DWORD *)(*((void *)this + 6) + 4 * v8++) = v11;
LABEL_34:
          int v11 = a2[v13++];
          continue;
        }
        if (v10 < v11)
        {
          int v10 = v9[v12++];
          a4 = 3;
          continue;
        }
        if (v10 != 1114112)
        {
          int v10 = v9[v12++];
          int v11 = a2[v13++];
          a4 = 1;
          continue;
        }
LABEL_55:
        uint64_t v25 = *((void *)this + 6);
        *(_DWORD *)(v25 + 4 * v8) = 1114112;
        *((void *)this + 2) = v25;
        *((void *)this + 6) = v9;
        LODWORD(v25) = *((_DWORD *)this + 6);
        *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
        *((_DWORD *)this + 7) = v8 + 1;
        *((_DWORD *)this + 14) = v25;
        unsigned int v26 = (void *)*((void *)this + 8);
        if (v26)
        {
          uprv_free(v26);
          *((void *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
        return;
      case 3:
        if (v11 <= v10)
        {
          if (v10 == 1114112) {
            goto LABEL_55;
          }
        }
        else
        {
          int v10 = v11;
          if (v11 == 1114112) {
            goto LABEL_55;
          }
        }
        a4 = 0;
        *(_DWORD *)(*((void *)this + 6) + 4 * v8++) = v10;
        int v10 = v9[v12++];
        goto LABEL_34;
      default:
        continue;
    }
  }
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0)
  {
    int v3 = 0;
  }
  else
  {
    int v3 = a2;
    if (a2 >= 0x110000) {
      int v3 = 1114111;
    }
  }
  int CodePoint = icu::UnicodeSet::findCodePoint(this, v3);
  if ((CodePoint & 1) == 0 && !*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
  {
    int v5 = CodePoint;
    uint64_t v6 = *((void *)this + 2);
    uint64_t v7 = CodePoint;
    if (v3 == *(_DWORD *)(v6 + 4 * CodePoint) - 1)
    {
      *(_DWORD *)(v6 + 4 * CodePouint64_t (*v15)(int, char *, int, UChar *, int) = v3;
      if (v3 == 1114111)
      {
        if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)this + 7) + 1)) {
          return this;
        }
        uint64_t v6 = *((void *)this + 2);
        uint64_t v8 = *((int *)this + 7);
        *((_DWORD *)this + 7) = v8 + 1;
        *(_DWORD *)(v6 + 4 * v8) = 1114112;
      }
      if (v5 < 1 || v3 != *(_DWORD *)(v6 + 4 * (v5 - 1))) {
        goto LABEL_26;
      }
      uint64_t v9 = v6 + 4 * v7;
      int v10 = *((_DWORD *)this + 7);
      if (v9 + 4 < (unint64_t)(v6 + 4 * v10))
      {
        unint64_t v11 = v6 + 4 * v10;
        if (v9 + 8 > v11) {
          unint64_t v11 = v9 + 8;
        }
        memmove((void *)(v9 - 4), (const void *)(v9 + 4), ((v11 - v9 - 5) & 0xFFFFFFFFFFFFFFFCLL) + 4);
        int v10 = *((_DWORD *)this + 7);
      }
      int v12 = v10 - 2;
    }
    else
    {
      uint64_t v13 = (CodePoint - 1);
      if (CodePoint >= 1 && v3 == *(_DWORD *)(v6 + 4 * v13))
      {
        *(_DWORD *)(v6 + 4 * v13) = v3 + 1;
        goto LABEL_26;
      }
      if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)this + 7) + 2)) {
        return this;
      }
      memmove((void *)(*((void *)this + 2) + 4 * v7 + 8), (const void *)(*((void *)this + 2) + 4 * v7), 4 * (*((_DWORD *)this + 7) - v5));
      uint64_t v14 = (int *)(*((void *)this + 2) + 4 * v7);
      *uint64_t v14 = v3;
      v14[1] = v3 + 1;
      int v12 = *((_DWORD *)this + 7) + 2;
    }
    *((_DWORD *)this + 7) = v12;
LABEL_26:
    unsigned int v15 = (void *)*((void *)this + 8);
    if (v15)
    {
      uprv_free(v15);
      *((void *)this + 8) = 0;
      *((_DWORD *)this + 18) = 0;
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::add(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      uint64_t v6 = (icu::UVector *)*((void *)this + 10);
      if (!v6 || (icu::UVector::indexOf(v6, (uint64_t)a2, 0) & 0x80000000) != 0)
      {
        icu::UnicodeSet::_add(this, (UChar **)a2);
        uint64_t v7 = (void *)*((void *)this + 8);
        if (v7)
        {
          uprv_free(v7);
          *((void *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
      }
    }
    else
    {
      icu::UnicodeSet::add(this, SingleCP);
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::_add(icu::UnicodeSet *this, UChar **a2)
{
  if (!*((void *)this + 5))
  {
    int64_t v2 = this;
    if (!*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
    {
      if ((UErrorCode v6 = U_ZERO_ERROR, !*((void *)this + 10)) && !icu::UnicodeSet::allocateStrings(this, &v6)
        || (int v4 = (icu::UnicodeString *)icu::UMemory::operator new((icu::UMemory *)0x40, (unint64_t)a2)) == 0
        || (int v5 = v4,
            icu::UnicodeString::UnicodeString(v4, a2),
            this = (icu::UnicodeSet *)icu::UVector::sortedInsert(*((void *)v2 + 10), v5, sub_18C893D64, &v6),
            v6 >= U_ILLEGAL_ARGUMENT_ERROR))
      {
        this = icu::UnicodeSet::clear(v2);
        *((unsigned char *)v2 + 32) = 1;
      }
    }
  }
  return this;
}

uint64_t sub_18C893D64(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if (*(__int16 *)(a1 + 8) < 0) {
    int32_t v3 = *(_DWORD *)(a1 + 12);
  }
  else {
    int32_t v3 = v2 >> 5;
  }
  unsigned int v4 = *(unsigned __int16 *)(a2 + 8);
  if (v4) {
    return (v2 & 1) == 0;
  }
  if ((v4 & 0x8000u) == 0) {
    int v5 = v4 >> 5;
  }
  else {
    int v5 = *(_DWORD *)(a2 + 12);
  }
  if ((v4 & 2) != 0) {
    uint64_t v6 = a2 + 10;
  }
  else {
    uint64_t v6 = *(void *)(a2 + 24);
  }
  return icu::UnicodeString::doCompare(a1, 0, v3, v6, v5 & (v5 >> 31), v5 & ~(v5 >> 31));
}

icu::UnicodeSet *icu::UnicodeSet::addAll(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  int v4 = (__int16)v3;
  LODWORD(v5) = v3 >> 5;
  if (v4 >= 0) {
    unint64_t v5 = v5;
  }
  else {
    unint64_t v5 = *((unsigned int *)a2 + 3);
  }
  if ((int)v5 >= 1)
  {
    int v7 = 0;
    do
    {
      unsigned int v8 = icu::UnicodeString::char32At((uint64_t *)v5, a2, v7);
      icu::UnicodeSet::add(this, v8);
      if (v8 < 0x10000) {
        int v9 = 1;
      }
      else {
        int v9 = 2;
      }
      v7 += v9;
      unsigned int v10 = *((unsigned __int16 *)a2 + 4);
      int v11 = (__int16)v10;
      LODWORD(v5) = v10 >> 5;
      if (v11 >= 0) {
        unint64_t v5 = v5;
      }
      else {
        unint64_t v5 = *((unsigned int *)a2 + 3);
      }
    }
    while (v7 < (int)v5);
  }
  return this;
}

icu::UVector **icu::UnicodeSet::retainAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  long long v5 = 0uLL;
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  v4[0] = &unk_1EDA47548;
  v4[1] = &unk_1EDA47660;
  v4[2] = v9;
  _OWORD v4[3] = 0x100000019;
  long long v6 = 0uLL;
  long long v8 = 0uLL;
  long long v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::retainAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::retainAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::retain((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 0);
    int v4 = this[10];
    if (v4)
    {
      if (*((_DWORD *)v4 + 2))
      {
        long long v5 = (const icu::UVector *)*((void *)a2 + 10);
        if (v5 && *((_DWORD *)v5 + 2)) {
          icu::UVector::retainAll(v4, v5);
        }
        else {
          icu::UVector::removeAllElements((uint64_t)v4);
        }
      }
    }
  }
  return (icu::UnicodeSet *)this;
}

icu::UVector **icu::UnicodeSet::complementAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  long long v5 = 0uLL;
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  v4[0] = &unk_1EDA47548;
  v4[1] = &unk_1EDA47660;
  v4[2] = v9;
  _OWORD v4[3] = 0x100000019;
  long long v6 = 0uLL;
  long long v8 = 0uLL;
  long long v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::complementAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complementAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::exclusiveOr((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 0);
    int v4 = (icu::UVector *)*((void *)a2 + 10);
    if (v4)
    {
      if (*((int *)v4 + 2) >= 1)
      {
        signed int v5 = 0;
        do
        {
          long long v6 = (UChar **)icu::UVector::elementAt(v4, v5);
          long long v7 = this[10];
          if (!v7 || !icu::UVector::removeElement(v7, (uint64_t)v6)) {
            icu::UnicodeSet::_add((icu::UnicodeSet *)this, v6);
          }
          ++v5;
          int v4 = (icu::UVector *)*((void *)a2 + 10);
        }
        while (v5 < *((_DWORD *)v4 + 2));
      }
    }
  }
  return (icu::UnicodeSet *)this;
}

icu::UVector **icu::UnicodeSet::removeAll(icu::UVector **this, const icu::UnicodeString *a2)
{
  long long v5 = 0uLL;
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  v4[0] = &unk_1EDA47548;
  v4[1] = &unk_1EDA47660;
  v4[2] = v9;
  _OWORD v4[3] = 0x100000019;
  long long v6 = 0uLL;
  long long v8 = 0uLL;
  long long v7 = 0uLL;
  LODWORD(v9[0]) = 1114112;
  icu::UnicodeSet::addAll((icu::UnicodeSet *)v4, a2);
  icu::UnicodeSet::removeAll(this, (const icu::UnicodeSet *)v4);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v4);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::removeAll(icu::UVector **this, const icu::UnicodeSet *a2)
{
  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    icu::UnicodeSet::retain((icu::UnicodeSet *)this, *((int **)a2 + 2), *((_DWORD *)a2 + 7), 2);
    int v4 = this[10];
    if (v4)
    {
      if (*((_DWORD *)v4 + 2))
      {
        long long v5 = (const icu::UVector *)*((void *)a2 + 10);
        if (v5)
        {
          if (*((_DWORD *)v5 + 2)) {
            icu::UVector::removeAll(v4, v5);
          }
        }
      }
    }
  }
  return (icu::UnicodeSet *)this;
}

icu::UnicodeSet *icu::UnicodeSet::removeAllStrings(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11))
  {
    uint64_t v3 = *((void *)this + 10);
    if (v3)
    {
      if (*(_DWORD *)(v3 + 8))
      {
        icu::UVector::removeAllElements(v3);
        int v4 = (void *)*((void *)this + 8);
        if (v4)
        {
          uprv_free(v4);
          *((void *)this + 8) = 0;
          *((_DWORD *)this + 18) = 0;
        }
      }
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::createFrom@<X0>(icu::UnicodeSet *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = &unk_1EDA47548;
    *((_DWORD *)result + 24) = 1114112;
    *((void *)result + 1) = &unk_1EDA47660;
    *((void *)result + 2) = (char *)result + 96;
    *((void *)result + 3) = 0x100000019;
    *((unsigned char *)result + 32) = 0;
    *((void *)result + 8) = 0;
    *((_DWORD *)result + 18) = 0;
    *((void *)result + 5) = 0;
    *((void *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
    *((void *)result + 10) = 0;
    *((void *)result + 11) = 0;
    return icu::UnicodeSet::add(result, this);
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::createFromAll@<X0>(icu::UnicodeSet *this@<X0>, const icu::UnicodeString *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeSet *)icu::UMemory::operator new(a3, (icu::UMemory *)0xC8, (unint64_t)a2);
  if (result)
  {
    *(void *)uint64_t result = &unk_1EDA47548;
    *((_DWORD *)result + 24) = 1114112;
    *((void *)result + 1) = &unk_1EDA47660;
    *((void *)result + 2) = (char *)result + 96;
    *((void *)result + 3) = 0x100000019;
    *((unsigned char *)result + 32) = 0;
    *((void *)result + 8) = 0;
    *((_DWORD *)result + 18) = 0;
    *((void *)result + 5) = 0;
    *((void *)result + 6) = 0;
    *((_DWORD *)result + 14) = 0;
    *((void *)result + 10) = 0;
    *((void *)result + 11) = 0;
    return icu::UnicodeSet::addAll(result, this);
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      int v4 = 0;
      goto LABEL_9;
    }
  }
  a2 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if (a3 > 0x10FFFF) {
LABEL_9:
  }
    a3 = v4;
  if (a2 <= a3)
  {
    v7[0] = a2;
    v7[1] = a3 + 1;
    _DWORD v7[2] = 1114112;
    icu::UnicodeSet::retain(this, v7, 2, 0);
  }
  else
  {
    icu::UnicodeSet::clear(this);
  }
  return this;
}

void icu::UnicodeSet::retain(icu::UnicodeSet *this, int *a2, int a3, char a4)
{
  if (!*((void *)this + 5)
    && !*((void *)this + 11)
    && (*((unsigned char *)this + 32) & 1) == 0
    && icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    int v7 = 0;
    uint64_t v8 = (int *)*((void *)this + 2);
    int v9 = *v8;
    int v10 = *a2;
    int v11 = 1;
    int v12 = 1;
    while (1)
    {
      switch(a4)
      {
        case 0:
          if (v9 < v10)
          {
            int v9 = v8[v11++];
            a4 = 1;
            continue;
          }
          if (v10 < v9) {
            goto LABEL_27;
          }
          if (v9 == 1114112) {
            goto LABEL_34;
          }
          *(_DWORD *)(*((void *)this + 6) + 4 * v7++) = v9;
          int v9 = v8[v11];
          int v10 = a2[v12];
          ++v11;
          goto LABEL_20;
        case 1:
          if (v9 >= v10)
          {
            if (v10 >= v9)
            {
              if (v9 == 1114112) {
                goto LABEL_34;
              }
              int v9 = v8[v11++];
LABEL_27:
              int v10 = a2[v12++];
              a4 = 2;
            }
            else
            {
              *(_DWORD *)(*((void *)this + 6) + 4 * v7++) = v10;
              int v10 = a2[v12];
LABEL_20:
              ++v12;
              a4 = 3;
            }
          }
          else
          {
            a4 = 0;
            int v9 = v8[v11++];
          }
          continue;
        case 2:
          if (v10 < v9)
          {
            a4 = 0;
            goto LABEL_33;
          }
          if (v9 < v10)
          {
            *(_DWORD *)(*((void *)this + 6) + 4 * v7++) = v9;
            int v9 = v8[v11++];
            a4 = 3;
            continue;
          }
          if (v9 == 1114112) {
            goto LABEL_34;
          }
          int v9 = v8[v11++];
          goto LABEL_30;
        case 3:
          if (v9 >= v10)
          {
            if (v10 >= v9)
            {
              if (v9 == 1114112)
              {
LABEL_34:
                uint64_t v13 = *((void *)this + 6);
                *(_DWORD *)(v13 + 4 * v7) = 1114112;
                *((void *)this + 2) = v13;
                *((void *)this + 6) = v8;
                int v14 = *((_DWORD *)this + 6);
                *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
                *((_DWORD *)this + 7) = v7 + 1;
                *((_DWORD *)this + 14) = v14;
                unsigned int v15 = (void *)*((void *)this + 8);
                if (v15)
                {
                  uprv_free(v15);
                  *((void *)this + 8) = 0;
                  *((_DWORD *)this + 18) = 0;
                }
                return;
              }
              a4 = 0;
              *(_DWORD *)(*((void *)this + 6) + 4 * v7++) = v9;
              int v9 = v8[v11++];
LABEL_33:
              int v10 = a2[v12++];
            }
            else
            {
              *(_DWORD *)(*((void *)this + 6) + 4 * v7++) = v10;
LABEL_30:
              int v10 = a2[v12++];
              a4 = 1;
            }
          }
          else
          {
            *(_DWORD *)(*((void *)this + 6) + 4 * v7++) = v9;
            int v9 = v8[v11++];
            a4 = 2;
          }
          break;
        default:
          continue;
      }
    }
  }
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::retain(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::retain(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      int v5 = (icu::UVector *)*((void *)this + 10);
      if (!v5 || (icu::UVector::indexOf(v5, (uint64_t)a2, 0) & 0x80000000) != 0)
      {
        icu::UnicodeSet::clear(this);
      }
      else if ((*((_DWORD *)this + 7) + 1) > 2 || icu::UnicodeSet::size(this) != 1)
      {
        long long v6 = icu::UnicodeSet::clear(this);
        icu::UnicodeSet::_add(v6, (UChar **)a2);
      }
    }
    else
    {
      icu::UnicodeSet::retain(this, SingleCP, SingleCP);
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, unsigned int a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v4 = 1114111;
  if ((a2 & 0x80000000) != 0)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 1114111;
    if (a2 <= 0x10FFFF)
    {
      if ((a3 & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      int v4 = 0;
      goto LABEL_9;
    }
  }
  a2 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if (a3 > 0x10FFFF) {
LABEL_9:
  }
    a3 = v4;
  if (a2 <= a3)
  {
    v7[0] = a2;
    v7[1] = a3 + 1;
    _DWORD v7[2] = 1114112;
    icu::UnicodeSet::retain(this, v7, 2, 2);
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::remove(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::remove(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      long long v6 = (icu::UVector *)*((void *)this + 10);
      if (v6)
      {
        if (icu::UVector::removeElement(v6, (uint64_t)a2))
        {
          int v7 = (void *)*((void *)this + 8);
          if (v7)
          {
            uprv_free(v7);
            *((void *)this + 8) = 0;
            *((_DWORD *)this + 18) = 0;
          }
        }
      }
    }
    else
    {
      icu::UnicodeSet::remove(this, SingleCP, SingleCP);
    }
  }
  return this;
}

void icu::UnicodeSet::exclusiveOr(icu::UnicodeSet *this, int *a2, int a3, unsigned __int8 a4)
{
  if (*((void *)this + 5)
    || *((void *)this + 11)
    || (*((unsigned char *)this + 32) & 1) != 0
    || !icu::UnicodeSet::ensureBufferCapacity(this, *((_DWORD *)this + 7) + a3))
  {
    return;
  }
  int v7 = (int *)*((void *)this + 2);
  int v8 = *v7;
  int v9 = *a2;
  if (a4 - 1 > 1) {
    goto LABEL_9;
  }
  if (!v9)
  {
    int v9 = a2[1];
LABEL_9:
    int v10 = 1;
    goto LABEL_10;
  }
  int v10 = 0;
  int v9 = 0;
LABEL_10:
  int v11 = 0;
  uint64_t v12 = 1;
LABEL_11:
  uint64_t v13 = 0;
  for (i = &a2[v10]; ; int v9 = i[v13++])
  {
    if (v8 < v9)
    {
      *(_DWORD *)(*((void *)this + 6) + 4 * v11 + 4 * v13) = v8;
      v10 += v13;
      v11 += v13 + 1;
LABEL_18:
      int v8 = v7[v12++];
      goto LABEL_11;
    }
    if (v9 >= v8) {
      break;
    }
    *(_DWORD *)(*((void *)this + 6) + 4 * v11 + 4 * v13) = v9;
  }
  if (v8 != 1114112)
  {
    v11 += v13;
    v10 += v13 + 1;
    int v9 = i[v13];
    goto LABEL_18;
  }
  uint64_t v15 = *((void *)this + 6);
  *(_DWORD *)(v15 + 4 * v11 + 4 * v13) = 1114112;
  *((void *)this + 2) = v15;
  *((void *)this + 6) = v7;
  int v16 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 6) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 7) = v11 + v13 + 1;
  *((_DWORD *)this + 14) = v16;
  int v17 = (void *)*((void *)this + 8);
  if (v17)
  {
    uprv_free(v17);
    *((void *)this + 8) = 0;
    *((_DWORD *)this + 18) = 0;
  }
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, unsigned int a2)
{
  return icu::UnicodeSet::complement(this, a2, a2);
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
  {
    unsigned int v2 = (_DWORD *)*((void *)this + 2);
    if (*v2)
    {
      if (!icu::UnicodeSet::ensureCapacity(this, *((_DWORD *)this + 7) + 1)) {
        return this;
      }
      memmove((void *)(*((void *)this + 2) + 4), *((const void **)this + 2), 4 * *((int *)this + 7));
      **((_DWORD **)this + 2) = 0;
      int v3 = 1;
    }
    else
    {
      memmove(v2, v2 + 1, 4 * *((int *)this + 7) - 4);
      int v3 = -1;
    }
    *((_DWORD *)this + 7) += v3;
    int v4 = (void *)*((void *)this + 8);
    if (v4)
    {
      uprv_free(v4);
      *((void *)this + 8) = 0;
      *((_DWORD *)this + 18) = 0;
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::complement(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
  {
    unsigned int SingleCP = icu::UnicodeSet::getSingleCP(a2, a2);
    if ((SingleCP & 0x80000000) != 0)
    {
      int v5 = (icu::UVector *)*((void *)this + 10);
      if (!v5 || (icu::UVector::indexOf(v5, (uint64_t)a2, 0) & 0x80000000) != 0) {
        icu::UnicodeSet::_add(this, (UChar **)a2);
      }
      else {
        icu::UVector::removeElement(*((icu::UVector **)this + 10), (uint64_t)a2);
      }
      long long v6 = (void *)*((void *)this + 8);
      if (v6)
      {
        uprv_free(v6);
        *((void *)this + 8) = 0;
        *((_DWORD *)this + 18) = 0;
      }
    }
    else
    {
      icu::UnicodeSet::complement(this, SingleCP, SingleCP);
    }
  }
  return this;
}

uint64_t icu::UnicodeSet::getString(icu::UVector **this, unsigned int a2)
{
  return icu::UVector::elementAt(this[10], a2);
}

icu::UnicodeSet *icu::UnicodeSet::compact(icu::UnicodeSet *this)
{
  if (*((void *)this + 5) || *((void *)this + 11) || (*((unsigned char *)this + 32) & 1) != 0) {
    return this;
  }
  unsigned int v2 = (char *)*((void *)this + 6);
  int v3 = (char *)this + 96;
  if (v2 != (char *)this + 96)
  {
    uprv_free(v2);
    *((void *)this + 6) = 0;
    *((_DWORD *)this + 14) = 0;
  }
  int v4 = (char *)*((void *)this + 2);
  if (v4 != v3)
  {
    uint64_t v5 = *((int *)this + 7);
    if ((int)v5 <= 25)
    {
      memcpy((char *)this + 96, *((const void **)this + 2), 4 * v5);
      uprv_free(v4);
      *((void *)this + 2) = v3;
      int v6 = 25;
LABEL_12:
      *((_DWORD *)this + 6) = v6;
      goto LABEL_13;
    }
    if ((int)v5 + 7 < *((_DWORD *)this + 6))
    {
      int v7 = uprv_realloc(*((void **)this + 2), 4 * *((unsigned int *)this + 7));
      if (v7)
      {
        *((void *)this + 2) = v7;
        int v6 = *((_DWORD *)this + 7);
        goto LABEL_12;
      }
    }
  }
LABEL_13:
  int v8 = (_DWORD *)*((void *)this + 10);
  if (v8 && !v8[2])
  {
    (*(void (**)(_DWORD *))(*(void *)v8 + 8))(v8);
    *((void *)this + 10) = 0;
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, unsigned __int16 *a2, int a3, int a4, int *a5)
{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  if (*a5 < 1)
  {
    if (a3 < 1 || !a2 || a4)
    {
      *a5 = 1;
      icu::UnicodeSet::clear(this);
      *((unsigned char *)this + 32) = 1;
    }
    else
    {
      int v7 = (__int16)*a2;
      if (v7 >= 0) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = 2;
      }
      LODWORD(v9) = *a2;
      if (v7 < 0) {
        LODWORD(v9) = a2[1];
      }
      int v10 = *a2 & 0x7FFF;
      int v11 = v10 - v9;
      if (v10 >= (int)v9) {
        int v12 = v10 - v9;
      }
      else {
        int v12 = v11 + 1;
      }
      int v13 = v9 + (v12 >> 1);
      if (icu::UnicodeSet::ensureCapacity(this, v13 + 1))
      {
        uint64_t v14 = *((void *)this + 2);
        if (v9)
        {
          uint64_t v15 = v9;
          int v16 = (_DWORD *)*((void *)this + 2);
          int v17 = (__int16 *)&a2[v8];
          do
          {
            int v18 = (unsigned __int16)*v17++;
            *v16++ = v18;
            --v15;
          }
          while (v15);
        }
        if (v11 >= 2)
        {
          uint64_t v9 = v9;
          uint64_t v19 = (__int16 *)&a2[v8 + 1 + v9];
          do
          {
            int v20 = (unsigned __int16)*(v19 - 1);
            int v21 = (unsigned __int16)*v19;
            v19 += 2;
            *(_DWORD *)(v14 + 4 * v9++) = v21 | (v20 << 16);
          }
          while (v9 < v13);
        }
        if (!v9 || *(_DWORD *)(v14 + 4 * ((int)v9 - 1)) != 1114112)
        {
          *(_DWORD *)(v14 + 4 * v9) = 1114112;
          LODWORD(v9) = v9 + 1;
        }
        *((_DWORD *)this + 7) = v9;
      }
    }
  }
  else
  {
    icu::UnicodeSet::clear(this);
    *((unsigned char *)this + 32) = 1;
  }
  return this;
}

uint64_t icu::UnicodeSet::serialize(icu::UnicodeSet *this, unsigned __int16 *a2, int a3, UErrorCode *a4)
{
  if (*(int *)a4 > 0) {
    return 0;
  }
  if (a3 < 0 || !a2 && a3)
  {
    uint64_t result = 0;
    UErrorCode v5 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_7:
    *a4 = v5;
    return result;
  }
  int v6 = *((_DWORD *)this + 7);
  uint64_t v7 = (v6 - 1);
  if (v6 == 1)
  {
    if (a3) {
      *a2 = 0;
    }
    else {
      *a4 = U_BUFFER_OVERFLOW_ERROR;
    }
    return 1;
  }
  else
  {
    unsigned int v8 = (int *)*((void *)this + 2);
    if (v8[v6 - 2] >= 0x10000)
    {
      if (*v8 < 0x10000)
      {
        if (v6 < 2)
        {
          LODWORD(v10) = 0;
        }
        else
        {
          uint64_t v10 = 0;
          while (v8[v10] < 0x10000)
          {
            if (v7 == ++v10)
            {
              LODWORD(v10) = v6 - 1;
              break;
            }
          }
        }
        int v9 = v10 + 2 * (v7 - v10);
        LODWORD(v7) = v10;
      }
      else
      {
        int v9 = 2 * v7;
        LODWORD(v7) = 0;
      }
    }
    else
    {
      int v9 = v6 - 1;
    }
    if (v9 >= 0x8000)
    {
      uint64_t result = 0;
      UErrorCode v5 = U_INDEX_OUTOFBOUNDS_ERROR;
      goto LABEL_7;
    }
    if (v9 <= (int)v7) {
      int v11 = 1;
    }
    else {
      int v11 = 2;
    }
    uint64_t result = (v11 + v9);
    if ((int)result > a3)
    {
      UErrorCode v5 = U_BUFFER_OVERFLOW_ERROR;
      goto LABEL_7;
    }
    *a2 = v9;
    if (v9 > (int)v7)
    {
      *a2 = v9 | 0x8000;
      a2[1] = v7;
      ++a2;
    }
    int v12 = a2 + 1;
    if ((int)v7 < 1)
    {
      LODWORD(v7) = 0;
    }
    else
    {
      int v13 = v7;
      do
      {
        int v14 = *v8++;
        *v12++ = v14;
        --v13;
      }
      while (v13);
    }
    while ((int)v7 < v9)
    {
      int v15 = *v8++;
      HIDWORD(v16) = v15;
      LODWORD(v16) = v15;
      *(_DWORD *)int v12 = v16 >> 16;
      v12 += 2;
      LODWORD(v7) = v7 + 2;
    }
  }
  return result;
}

uint64_t icu::UnicodeSet::nextCapacity(icu::UnicodeSet *this)
{
  if ((int)this <= 24) {
    return (this + 25);
  }
  if (this <= 0x9C4) {
    return (5 * this);
  }
  if ((2 * this) > 0x110000) {
    return 1114113;
  }
  return (2 * this);
}

uint64_t icu::UnicodeSet::ensureBufferCapacity(icu::UnicodeSet *this, int a2)
{
  if (a2 > 1114112) {
    int v2 = 1114113;
  }
  else {
    int v2 = a2;
  }
  if (v2 <= *((_DWORD *)this + 14)) {
    return 1;
  }
  if ((2 * v2) > 0x110000) {
    int v4 = 1114113;
  }
  else {
    int v4 = 2 * v2;
  }
  if (v2 <= 0x9C4) {
    int v4 = 5 * v2;
  }
  if (v2 <= 24) {
    int v5 = v2 + 25;
  }
  else {
    int v5 = v4;
  }
  int v6 = uprv_malloc(4 * v5);
  if (v6)
  {
    uint64_t v7 = v6;
    unsigned int v8 = (char *)*((void *)this + 6);
    if (v8 != (char *)this + 96) {
      uprv_free(v8);
    }
    *((void *)this + 6) = v7;
    *((_DWORD *)this + 14) = v5;
    return 1;
  }
  icu::UnicodeSet::clear(this);
  uint64_t result = 0;
  *((unsigned char *)this + 32) = 1;
  return result;
}

uint64_t icu::UnicodeSet::swapBuffers(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 16);
  *(void *)(this + 16) = *(void *)(this + 48);
  *(void *)(this + 48) = v1;
  LODWORD(v1) = *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 24) = *(_DWORD *)(this + 56);
  *(_DWORD *)(this + 56) = v1;
  return this;
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat(icu::ICU_Utility *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 4);
  int v4 = (__int16)v3;
  int v5 = v3 >> 5;
  if (v4 < 0) {
    int v5 = *((_DWORD *)a2 + 3);
  }
  if (v5 >= 1)
  {
    int v6 = (int)a3;
    unsigned int v8 = this;
    int v9 = 0;
    do
    {
      uint64_t v10 = (icu::UnicodeString *)icu::UnicodeString::char32At(a2, v9);
      unsigned int v11 = v10;
      this = icu::UnicodeSet::_appendToPat(v8, v10, v6);
      if (v11 < 0x10000) {
        int v12 = 1;
      }
      else {
        int v12 = 2;
      }
      v9 += v12;
      unsigned int v13 = *((unsigned __int16 *)a2 + 4);
      int v14 = (__int16)v13;
      int v15 = v13 >> 5;
      if (v14 < 0) {
        int v15 = *((_DWORD *)a2 + 3);
      }
    }
    while (v9 < v15);
  }
  return this;
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat(icu::UnicodeSet *this, icu::UnicodeString *a2, int a3)
{
  if (!a3)
  {
    if (icu::ICU_Utility::shouldAlwaysBeEscaped(a2)) {
      goto LABEL_3;
    }
LABEL_7:
    if ((a2 - 36) <= 0x3A && ((1 << (a2 - 36)) & 0x780000000400205) != 0
      || a2 == 125
      || a2 == 123)
    {
      __int16 v7 = 92;
      int v6 = &v7;
    }
    else
    {
      if (!icu::PatternProps::isWhiteSpace(a2)) {
        return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)this, a2);
      }
      __int16 v8 = 92;
      int v6 = &v8;
    }
    icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)v6, 0, 1);
    return (icu::ICU_Utility *)icu::UnicodeString::append((uint64_t)this, a2);
  }
  if (!icu::ICU_Utility::isUnprintable(a2)) {
    goto LABEL_7;
  }
LABEL_3:

  return icu::ICU_Utility::escape(this, a2);
}

icu::ICU_Utility *icu::UnicodeSet::_appendToPat(icu::UnicodeSet *this, icu::UnicodeString *a2, icu::UnicodeString *a3, int a4)
{
  int v6 = (int)a2;
  uint64_t result = icu::UnicodeSet::_appendToPat(this, a2, a4);
  if (v6 != a3)
  {
    if (v6 == 56319 || v6 + 1 != a3)
    {
      __int16 v9 = 45;
      icu::UnicodeString::doAppend((uint64_t)this, (uint64_t)&v9, 0, 1);
    }
    return icu::UnicodeSet::_appendToPat(this, a3, a4);
  }
  return result;
}

icu::UnicodeString *icu::UnicodeSet::_toPattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  int v3 = (int)a3;
  if (*((void *)this + 8))
  {
    int v6 = *((_DWORD *)this + 18);
    if (v6 >= 1)
    {
      int v7 = 0;
      int v8 = 0;
      do
      {
        uint64_t v9 = *((void *)this + 8);
        uint64_t v10 = v8 + 1;
        unint64_t v11 = *(unsigned __int16 *)(v9 + 2 * v8);
        if ((v11 & 0xFC00) != 0xD800 || v10 == v6)
        {
          ++v8;
        }
        else
        {
          int v13 = *(unsigned __int16 *)(v9 + 2 * v10);
          BOOL v14 = (v13 & 0xFC00) == 56320;
          unsigned int v15 = v13 + (v11 << 10) - 56613888;
          if (v14) {
            v8 += 2;
          }
          else {
            ++v8;
          }
          if (v14) {
            unint64_t v11 = v15;
          }
          else {
            unint64_t v11 = v11;
          }
        }
        if (v3)
        {
          if (icu::ICU_Utility::isUnprintable((icu::ICU_Utility *)v11)) {
            goto LABEL_18;
          }
        }
        else if (icu::ICU_Utility::shouldAlwaysBeEscaped((icu::ICU_Utility *)v11))
        {
LABEL_18:
          if ((v7 & 0x80000001) == 1)
          {
            unsigned int v16 = *((unsigned __int16 *)a2 + 4);
            if (*((__int16 *)a2 + 4) < 0) {
              unsigned int v17 = *((_DWORD *)a2 + 3);
            }
            else {
              unsigned int v17 = v16 >> 5;
            }
            int v18 = v17 - 1;
            if ((v16 & 1) != 0 && v17 == 1)
            {
              icu::UnicodeString::unBogus((uint64_t)a2);
            }
            else if (v17 > v18)
            {
              if (v18 > 1023)
              {
                *((_WORD *)a2 + 4) = v16 | 0xFFE0;
                *((_DWORD *)a2 + 3) = v18;
              }
              else
              {
                *((_WORD *)a2 + 4) = *((_WORD *)a2 + 4) & 0x1F | (32 * v18);
              }
            }
          }
          icu::ICU_Utility::escape(a2, (icu::UnicodeString *)v11);
          int v7 = 0;
          goto LABEL_34;
        }
        icu::UnicodeString::append((uint64_t)a2, v11);
        if (v11 == 92) {
          ++v7;
        }
        else {
          int v7 = 0;
        }
LABEL_34:
        int v6 = *((_DWORD *)this + 18);
      }
      while (v8 < v6);
    }
    return a2;
  }
  else
  {
    return (icu::UnicodeString *)icu::UnicodeSet::_generatePattern(this, a2, a3);
  }
}

uint64_t icu::UnicodeSet::_generatePattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  __int16 v30 = 91;
  icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v30, 0, 1);
  int v6 = *((_DWORD *)this + 7);
  signed int v7 = v6 & 0xFFFFFFFE;
  if (v6 >= 4 && (v7 == v6 ? (BOOL v8 = **((_DWORD **)this + 2) == 0) : (BOOL v8 = 0), v8))
  {
    uint64_t v28 = *((void *)this + 10);
    if (v28 && *(_DWORD *)(v28 + 8))
    {
      LODWORD(v9) = 0;
      signed int v7 = *((_DWORD *)this + 7);
    }
    else
    {
      __int16 v31 = 94;
      LODWORD(v9) = 1;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v31, 0, 1);
      signed int v7 = v6 - 1;
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((int)v9 < v7)
  {
    uint64_t v10 = v7;
    signed int v29 = v7;
    do
    {
      uint64_t v11 = *((void *)this + 2);
      uint64_t v12 = (int)v9;
      int v13 = *(_DWORD *)(v11 + 4 * (int)v9 + 4);
      if ((v13 - 55297) > 0x3FF)
      {
        icu::UnicodeSet::_appendToPat(a2, (icu::UnicodeString *)*(unsigned int *)(v11 + 4 * (int)v9), (icu::UnicodeString *)(v13 - 1), (int)a3);
        signed int v7 = v29;
        LODWORD(v9) = v9 + 2;
      }
      else
      {
        uint64_t v14 = (int)v9 + 2;
        uint64_t v15 = (uint64_t)(int)v9 << 32;
        uint64_t v16 = (int)v9 + 2;
        do
        {
          uint64_t v17 = v14;
          uint64_t v18 = v15;
          if (v16 >= v10) {
            break;
          }
          int v19 = *(_DWORD *)(v11 + 4 * v16);
          v14 += 2;
          v15 += 0x200000000;
          v16 += 2;
        }
        while (v19 < 56320);
        LODWORD(v9) = v17;
        if (v7 > (int)v17)
        {
          uint64_t v9 = v17;
          do
          {
            uint64_t v20 = *((void *)this + 2);
            int v21 = (icu::UnicodeString *)*(unsigned int *)(v20 + 4 * v9);
            if ((int)v21 >= 57344) {
              break;
            }
            icu::UnicodeSet::_appendToPat(a2, v21, (icu::UnicodeString *)(*(_DWORD *)(v20 + 4 * v9 + 4) - 1), (int)a3);
            v9 += 2;
          }
          while (v9 < v10);
          signed int v7 = v29;
        }
        if ((int)v12 < (int)v17)
        {
          uint64_t v22 = v18 >> 32;
          do
          {
            icu::UnicodeSet::_appendToPat(a2, (icu::UnicodeString *)*(unsigned int *)(*((void *)this + 2) + 4 * v12), (icu::UnicodeString *)(*(_DWORD *)(*((void *)this + 2) + 4 * v12 + 4) - 1), (int)a3);
            BOOL v23 = v12 < v22;
            v12 += 2;
          }
          while (v23);
          signed int v7 = v29;
        }
      }
    }
    while ((int)v9 < v7);
  }
  uint64_t v24 = *((void *)this + 10);
  if (v24 && *(int *)(v24 + 8) >= 1)
  {
    signed int v25 = 0;
    do
    {
      __int16 v32 = 123;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v32, 0, 1);
      unsigned int v26 = (icu::UnicodeString *)icu::UVector::elementAt(*((icu::UVector **)this + 10), v25);
      icu::UnicodeSet::_appendToPat(a2, v26, a3);
      __int16 v33 = 125;
      icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v33, 0, 1);
      ++v25;
    }
    while (v25 < *(_DWORD *)(*((void *)this + 10) + 8));
  }
  __int16 v34 = 93;
  return icu::UnicodeString::doAppend((uint64_t)a2, (uint64_t)&v34, 0, 1);
}

icu::UnicodeString *icu::UnicodeSet::toPattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  unsigned int v6 = *((unsigned __int16 *)a2 + 4);
  if (v6)
  {
    icu::UnicodeString::unBogus((uint64_t)a2);
  }
  else
  {
    if ((v6 & 0x8000u) == 0) {
      unsigned int v7 = v6 >> 5;
    }
    else {
      unsigned int v7 = *((_DWORD *)a2 + 3);
    }
    if (v7) {
      *((_WORD *)a2 + 4) &= 0x1Fu;
    }
  }

  return icu::UnicodeSet::_toPattern(this, a2, a3);
}

icu::UnicodeString *non-virtual thunk to'icu::UnicodeSet::toPattern(icu::UnicodeSet *this, icu::UnicodeString *a2, const icu::UnicodeString *a3)
{
  return icu::UnicodeSet::toPattern((icu::UnicodeSet *)((char *)this - 8), a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::freeze(icu::UnicodeSet *this)
{
  if (!*((void *)this + 5) && !*((void *)this + 11) && (*((unsigned char *)this + 32) & 1) == 0)
  {
    icu::UnicodeSet::compact(this);
    uint64_t v3 = *((void *)this + 10);
    if (v3 && *(_DWORD *)(v3 + 8))
    {
      uint64_t v4 = icu::UMemory::operator new((icu::UMemory *)0x188, v2);
      if (!v4)
      {
        *((void *)this + 11) = 0;
        goto LABEL_14;
      }
      uint64_t v5 = sub_18C8995A4(v4, this, *((void *)this + 10), 63);
      *((void *)this + 11) = v5;
      if (!*(_DWORD *)(v5 + 252))
      {
        unsigned int v6 = (void *)sub_18C8996FC();
        icu::UMemory::operator delete(v6);
        *((void *)this + 11) = 0;
LABEL_10:
        uint64_t v7 = icu::UMemory::operator new((icu::UMemory *)0x368, v2);
        if (v7)
        {
          *((void *)this + 5) = sub_18C7E90A4(v7, *((void *)this + 2), *((_DWORD *)this + 7));
          return this;
        }
        *((void *)this + 5) = 0;
LABEL_14:
        icu::UnicodeSet::clear(this);
        *((unsigned char *)this + 32) = 1;
      }
    }
    else if (!*((void *)this + 11))
    {
      goto LABEL_10;
    }
  }
  return this;
}

unint64_t icu::UnicodeSet::spanBack(icu::UnicodeSet *this, UChar *s, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v5 = u_strlen(s);
    if (!v5) {
      return v5;
    }
  }
  else
  {
    BOOL v8 = (unsigned int *)*((void *)this + 5);
    if (v8) {
      return (unint64_t)(sub_18C7E9628(v8, (uint64_t)s, (uint64_t)&s[a3], a4) - (void)s) >> 1;
    }
  }
  uint64_t v10 = *((void *)this + 11);
  if (!v10)
  {
    uint64_t v11 = *((void *)this + 10);
    if (v11 && *(_DWORD *)(v11 + 8))
    {
      uint64_t v29 = 0;
      if (a4) {
        uint64_t v12 = 26;
      }
      else {
        uint64_t v12 = 25;
      }
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v20 = 0u;
      memset(v19, 0, sizeof(v19));
      sub_18C8995A4(v19, this, v11, v12);
      if (HIDWORD(v20))
      {
        uint64_t v5 = sub_18C899FE4((uint64_t)v19, s, v5, a4);
        sub_18C8996FC(v19);
        return v5;
      }
      sub_18C8996FC(v19);
    }
    int v13 = a4 != 0;
    do
    {
      uint64_t v14 = (v5 - 1);
      int v15 = s[(int)v14];
      if ((int)v5 > 1 && (v15 & 0xFC00) == 0xDC00)
      {
        int v16 = s[(v5 - 2)];
        int v17 = v16 & 0xFC00;
        int v18 = v15 + (v16 << 10) - 56613888;
        uint64_t v14 = v17 == 55296 ? (v5 - 2) : v14;
        if (v17 == 55296) {
          int v15 = v18;
        }
      }
      if (v13 != icu::UnicodeSet::contains(this, v15)) {
        break;
      }
      uint64_t v5 = v14;
    }
    while ((int)v14 >= 1);
    return v5;
  }

  return sub_18C899FE4(v10, s, v5, a4);
}

uint64_t icu::UnicodeSet::spanUTF8(icu::UnicodeSet *this, char *__s, size_t a3, int a4)
{
  size_t v5 = a3;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0;
    }
    size_t v5 = strlen(__s);
    if (!v5) {
      return 0;
    }
  }
  else
  {
    uint64_t v8 = *((void *)this + 5);
    if (v8) {
      return sub_18C7E987C(v8, __s, a3, a4) - __s;
    }
  }
  uint64_t v11 = *((void *)this + 11);
  if (!v11)
  {
    uint64_t v12 = *((void *)this + 10);
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      uint64_t v33 = 0;
      if (a4) {
        uint64_t v13 = 38;
      }
      else {
        uint64_t v13 = 37;
      }
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      memset(v24, 0, sizeof(v24));
      sub_18C8995A4(v24, this, v12, v13);
      if (v25)
      {
        uint64_t v9 = sub_18C89A840((uint64_t)v24, __s, v5, a4);
        sub_18C8996FC(v24);
        return v9;
      }
      sub_18C8996FC(v24);
    }
    uint64_t v9 = 0;
    int v14 = a4 != 0;
    while (1)
    {
      uint64_t v15 = (int)v9 + 1;
      int v16 = __s[(int)v9];
      unsigned int v17 = __s[(int)v9];
      if ((v16 & 0x80000000) == 0) {
        goto LABEL_44;
      }
      if (v15 == v5) {
        goto LABEL_23;
      }
      if (v17 < 0xE0) {
        break;
      }
      if (v17 <= 0xEF)
      {
        uint64_t v18 = v16 & 0xF;
        if ((a00000000000000[v18] >> (__s[v15] >> 5)))
        {
          unsigned int v19 = __s[v15] & 0x3F;
          goto LABEL_28;
        }
        goto LABEL_43;
      }
      if (v17 > 0xF4) {
        goto LABEL_43;
      }
      unint64_t v23 = __s[v15];
      if (((byte_18CA81C20[v23 >> 4] >> (v17 + 16)) & 1) == 0) {
        goto LABEL_43;
      }
      uint64_t v15 = (int)v9 + 2;
      if (v9 + 2 == v5) {
        goto LABEL_23;
      }
      unsigned int v19 = __s[v15] ^ 0x80;
      if (v19 <= 0x3F)
      {
        LODWORD(v18) = v23 & 0x3F | ((v17 - 240) << 6);
LABEL_28:
        LODWORD(v15) = v15 + 1;
        if (v15 != v5)
        {
          int v20 = v19 | (v18 << 6);
LABEL_32:
          unsigned int v21 = __s[(int)v15] ^ 0x80;
          int v22 = v21 | (v20 << 6);
          if (v21 <= 0x3F) {
            unsigned int v17 = v22;
          }
          else {
            unsigned int v17 = 65533;
          }
          if (v21 > 0x3F) {
            uint64_t v15 = v15;
          }
          else {
            uint64_t v15 = (v15 + 1);
          }
          goto LABEL_44;
        }
LABEL_23:
        unsigned int v17 = 65533;
        uint64_t v15 = v5;
        goto LABEL_44;
      }
      unsigned int v17 = 65533;
LABEL_44:
      if (v14 == icu::UnicodeSet::contains(this, v17))
      {
        uint64_t v9 = v15;
        if ((int)v15 < (int)v5) {
          continue;
        }
      }
      return v9;
    }
    if (v17 >= 0xC2)
    {
      int v20 = v17 & 0x1F;
      goto LABEL_32;
    }
LABEL_43:
    unsigned int v17 = 65533;
    goto LABEL_44;
  }

  return sub_18C89A840(v11, __s, v5, a4);
}

uint64_t icu::UnicodeSet::spanBackUTF8(icu::UnicodeSet *this, uint8_t *s, uint64_t a3, int a4)
{
  size_t v5 = a3;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)a3 < 1)
  {
    if ((a3 & 0x80000000) == 0) {
      return 0;
    }
    size_t v5 = strlen((const char *)s);
    if (v5) {
      goto LABEL_10;
    }
    return v5;
  }
  uint64_t v8 = *((void *)this + 5);
  if (v8)
  {
    return sub_18C7E9B90(v8, s, a3, a4);
  }
LABEL_10:
  uint64_t v10 = *((void *)this + 11);
  if (!v10)
  {
    uint64_t v11 = *((void *)this + 10);
    if (v11 && *(_DWORD *)(v11 + 8))
    {
      uint64_t v25 = 0;
      if (a4) {
        uint64_t v12 = 22;
      }
      else {
        uint64_t v12 = 21;
      }
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      memset(v16, 0, sizeof(v16));
      sub_18C8995A4(v16, this, v11, v12);
      if (v17)
      {
        size_t v5 = sub_18C89AF88((uint64_t)v16, s, v5, a4);
        sub_18C8996FC(v16);
        return v5;
      }
      sub_18C8996FC(v16);
    }
    int v13 = a4 != 0;
    do
    {
      p__int16 i = v5 - 1;
      UChar32 v14 = s[(int)v5 - 1];
      if ((v14 & 0x80) != 0) {
        UChar32 v14 = utf8_prevCharSafeBody(s, 0, &pi, v14, -3);
      }
      if (v13 != icu::UnicodeSet::contains(this, v14)) {
        break;
      }
      size_t v5 = pi;
    }
    while (pi > 0);
    return v5;
  }

  return sub_18C89AF88(v10, s, v5, a4);
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeString *a2, unsigned int a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5);
}

{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, unsigned int a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  char v6 = a3;
  uint64_t v15 = &unk_1EDA44670;
  unint64_t v16 = 0xFFFFFFFF00000000;
  icu::UnicodeSet::applyPattern(this, a2, (icu::ParsePosition *)&v15, a3, a4, a5);
  if (*(int *)a5 <= 0)
  {
    int v9 = v16;
    int v14 = v16;
    if (v6)
    {
      icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v14, (int *)1);
      int v9 = v14;
    }
    unsigned int v10 = *((unsigned __int16 *)a2 + 4);
    int v11 = (__int16)v10;
    unsigned int v12 = v10 >> 5;
    if (v11 < 0) {
      unsigned int v12 = *((_DWORD *)a2 + 3);
    }
    if (v9 != v12) {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v15);
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, unsigned int a4, const icu::SymbolTable *a5, UErrorCode *a6)
{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5, a6);
}

{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3, a4, a5, a6);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, unsigned int a4, const icu::SymbolTable *a5, UErrorCode *a6)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(int *)a6 <= 0)
  {
    if (*((void *)this + 5) || *((void *)this + 11))
    {
      *a6 = U_NO_WRITE_PERMISSION;
    }
    else
    {
      long long v16 = 0u;
      long long v17 = 0u;
      uint64_t v19 = 0;
      long long v18 = 0u;
      uint64_t v14 = 0;
      uint64_t v15 = &unk_1EDA47700;
      LOWORD(v16) = 2;
      long long v12 = 0u;
      long long v13 = 0u;
      sub_18C83A890((uint64_t)&v12, (uint64_t)a2, (uint64_t)a5, (uint64_t)a3);
      icu::UnicodeSet::applyPattern(this, (uint64_t *)&v12, (uint64_t)a5, (icu::UnicodeString *)&v15, a4, (void (*)(void *))icu::UnicodeSet::closeOver, 0, 0, a6);
      uint64_t v11 = *(unsigned int *)a6;
      if ((int)v11 <= 0)
      {
        if (*((void *)&v13 + 1))
        {
          uint64_t v11 = 65538;
          *a6 = U_MALFORMED_SET;
        }
        else
        {
          sub_18C8964B8((uint64_t)this, (uint64_t)&v15);
        }
      }
      icu::UnicodeString::~UnicodeString((void *)v11, (icu::UnicodeString *)&v15);
    }
  }
  return this;
}

icu::UVector **icu::UnicodeSet::closeOver(icu::UVector **this, char a2)
{
  if (!this[5] && !this[11] && ((_BYTE)this[4] & 1) == 0)
  {
    switch(a2 & 6)
    {
      case 1:
      case 3:
      case 5:
        __break(1u);
        JUMPOUT(0x18C89649CLL);
      case 2:
        int v3 = 0;
        goto LABEL_7;
      case 4:
        icu::UnicodeSet::closeOverAddCaseMappings(this);
        return this;
      case 6:
        int v3 = 1;
LABEL_7:
        icu::UnicodeSet::closeOverCaseInsensitive((icu::UnicodeSet *)this, v3);
        break;
      default:
        return this;
    }
  }
  return this;
}

UChar *sub_18C8964B8(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  if ((v2 & 0x11) != 0)
  {
    int v3 = 0;
  }
  else if ((v2 & 2) != 0)
  {
    int v3 = (const UChar *)(a2 + 10);
  }
  else
  {
    int v3 = *(const UChar **)(a2 + 24);
  }
  int v4 = (__int16)v2;
  int32_t v5 = v2 >> 5;
  if (v4 >= 0) {
    int32_t v6 = v5;
  }
  else {
    int32_t v6 = *(_DWORD *)(a2 + 12);
  }
  return icu::UnicodeSet::setPattern(a1, v3, v6);
}

void icu::UnicodeSet::closeOverCaseInsensitive(icu::UnicodeSet *this, int a2)
{
  int v3 = this;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = 0;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  *(_OWORD *)unsigned int v53 = 0u;
  memset(v52, 0, sizeof(v52));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v52, this);
  if ((a2 & 1) == 0 && icu::UnicodeSet::hasStrings((icu::UnicodeSet *)v52)) {
    icu::UVector::removeAllElements((uint64_t)v53[0]);
  }
  v51[0] = v52;
  v51[1] = icu::UnicodeSet::add;
  v51[2] = icu::UnicodeSet::add;
  _OWORD v51[4] = 0;
  v51[5] = 0;
  v51[3] = sub_18C896DEC;
  uint64_t v50 = 0;
  memset(v49, 0, sizeof(v49));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v49, 0, 1114111);
  int v4 = sub_18C896E7C(v3, (icu::UVector **)v49);
  int RangeCount = icu::UnicodeSet::getRangeCount((icu::UnicodeSet *)v4);
  if (RangeCount >= 1)
  {
    int v6 = RangeCount;
    for (int i = 0; i != v6; ++i)
    {
      uint64_t RangeStart = icu::UnicodeSet::getRangeStart((icu::UnicodeSet *)v4, i);
      int RangeEnd = icu::UnicodeSet::getRangeEnd((icu::UnicodeSet *)v4, i);
      if (a2)
      {
        if ((int)RangeStart <= RangeEnd)
        {
          int v10 = RangeEnd + 1;
          do
          {
            sub_18C84B6A8(RangeStart, v51);
            uint64_t RangeStart = (RangeStart + 1);
          }
          while (v10 != RangeStart);
        }
      }
      else if ((int)RangeStart <= RangeEnd)
      {
        int v11 = RangeEnd + 1;
        do
        {
          sub_18C84B38C(RangeStart, v51);
          uint64_t RangeStart = (RangeStart + 1);
        }
        while (v11 != RangeStart);
      }
    }
  }
  if (icu::UnicodeSet::hasStrings(v3))
  {
    int v48 = a2;
    long long v12 = &v61;
    long long v62 = 0u;
    uint64_t v65 = 0;
    long long v64 = 0u;
    long long v63 = 0u;
    uint64_t v61 = (UChar *)&unk_1EDA47700;
    LOWORD(v62) = 2;
    long long v13 = (unsigned int *)*((void *)v3 + 10);
    if ((int)v13[2] >= 1)
    {
      signed int v14 = 0;
      uint64_t v47 = (unsigned int **)v3;
      do
      {
        uint64_t v15 = icu::UVector::elementAt((icu::UVector *)v13, v14);
        long long v16 = (const icu::UnicodeString *)v15;
        if (v48)
        {
          unsigned int v17 = *(unsigned __int16 *)(v15 + 8);
          if ((v17 & 0x11) != 0)
          {
            uint64_t v18 = 0;
          }
          else if ((v17 & 2) != 0)
          {
            uint64_t v18 = v15 + 10;
          }
          else
          {
            uint64_t v18 = *(void *)(v15 + 24);
          }
          int v23 = (__int16)v17;
          int v24 = v17 >> 5;
          if (v23 >= 0) {
            int v25 = v24;
          }
          else {
            int v25 = *(_DWORD *)(v15 + 12);
          }
          if (v25 < 1) {
            goto LABEL_75;
          }
          int v26 = 0;
          while (1)
          {
            uint64_t v27 = v26 + 1;
            unsigned int v28 = *(unsigned __int16 *)(v18 + 2 * v26);
            if ((v28 & 0xFC00) != 0xD800 || v27 == v25)
            {
              ++v26;
            }
            else
            {
              int v30 = *(unsigned __int16 *)(v18 + 2 * v27);
              BOOL v31 = (v30 & 0xFC00) == 56320;
              unsigned int v32 = (v28 << 10) - 56613888 + v30;
              if (v31) {
                v26 += 2;
              }
              else {
                ++v26;
              }
              if (v31) {
                unsigned int v28 = v32;
              }
            }
            UChar32 v33 = u_foldCase(v28, 0);
            if (v33 != v28) {
              break;
            }
            if (v26 >= v25) {
              goto LABEL_75;
            }
          }
          unsigned int v34 = v33;
          if (v28 >= 0x10000) {
            int v35 = -2;
          }
          else {
            int v35 = -1;
          }
          uint64_t v36 = (v35 + v26);
          icu::UnicodeString::unBogus((uint64_t)&v61);
          if ((v62 & 0x8000u) == 0) {
            uint64_t v37 = (unsigned __int16)v62 >> 5;
          }
          else {
            uint64_t v37 = DWORD1(v62);
          }
          icu::UnicodeString::doReplace((uint64_t)&v61, 0, v37, v18, 0, v36);
          icu::UnicodeString::append((uint64_t)&v61, v34);
          if (v26 != v25)
          {
            int v38 = v26;
            do
            {
              uint64_t v39 = v38 + 1;
              UChar32 v40 = *(unsigned __int16 *)(v18 + 2 * v38);
              if ((v40 & 0xFC00) == 0xD800 && v39 != v25)
              {
                int v42 = *(unsigned __int16 *)(v18 + 2 * v39);
                BOOL v43 = (v42 & 0xFC00) == 56320;
                int v44 = v38 + 2;
                UChar32 v45 = (v40 << 10) - 56613888 + v42;
                if (v43) {
                  LODWORD(v39) = v44;
                }
                if (v43) {
                  UChar32 v40 = v45;
                }
              }
              UChar32 v46 = u_foldCase(v40, 0);
              icu::UnicodeString::append((uint64_t)&v61, v46);
              int v38 = v39;
            }
            while (v39 != v25);
          }
          long long v22 = icu::UnicodeSet::remove((icu::UnicodeSet *)v52, v16);
        }
        else
        {
          icu::UnicodeString::operator=(&v61, (UChar **)v15);
          icu::UnicodeString::foldCase(&v61, 0);
          uint64_t v19 = (unsigned __int16 *)v63;
          if ((v62 & 2) != 0) {
            uint64_t v19 = (unsigned __int16 *)&v62 + 1;
          }
          if ((v62 & 0x11) != 0) {
            uint64_t v20 = 0;
          }
          else {
            uint64_t v20 = v19;
          }
          if ((v62 & 0x8000u) == 0) {
            int v21 = (unsigned __int16)v62 >> 5;
          }
          else {
            int v21 = DWORD1(v62);
          }
          if (sub_18C84B978(v20, v21, v51)) {
            goto LABEL_75;
          }
          long long v22 = (icu::UnicodeSet *)v52;
        }
        icu::UnicodeSet::add(v22, (const icu::UnicodeString *)&v61);
LABEL_75:
        ++v14;
        int v3 = (icu::UnicodeSet *)v47;
        long long v13 = v47[10];
        long long v12 = (UChar **)v13[2];
      }
      while (v14 < (int)v12);
    }
    icu::UnicodeString::~UnicodeString(v12, (icu::UnicodeString *)&v61);
  }
  icu::UnicodeSet::operator=(v3, (const icu::UnicodeSet *)v52);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v49);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v52);
}

void icu::UnicodeSet::closeOverAddCaseMappings(icu::UVector **this)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v28, (const icu::UnicodeSet *)this);
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)v26, 0, 1114111);
  unsigned int v2 = sub_18C896E7C((icu::UnicodeSet *)this, (icu::UVector **)v26);
  int RangeCount = icu::UnicodeSet::getRangeCount((icu::UnicodeSet *)v2);
  uint64_t v25 = 0;
  long long v32 = 0u;
  uint64_t v35 = 0;
  long long v34 = 0u;
  long long v33 = 0u;
  BOOL v31 = (UChar *)&unk_1EDA47700;
  LOWORD(v32) = 2;
  if (RangeCount >= 1)
  {
    int v4 = RangeCount;
    for (int i = 0; i != v4; ++i)
    {
      signed int RangeStart = icu::UnicodeSet::getRangeStart((icu::UnicodeSet *)v2, i);
      signed int RangeEnd = icu::UnicodeSet::getRangeEnd((icu::UnicodeSet *)v2, i);
      if (RangeStart <= RangeEnd)
      {
        int v8 = RangeEnd + 1;
        do
        {
          unsigned int v9 = ucase_toFullLower(RangeStart, 0, 0, &v25, 1);
          if ((v9 & 0x80000000) == 0)
          {
            if (v9 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v9);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v9);
            }
          }
          unsigned int v10 = ucase_toFullTitle(RangeStart, 0, 0, &v25, 1);
          if ((v10 & 0x80000000) == 0)
          {
            if (v10 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v10);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v10);
            }
          }
          unsigned int v11 = ucase_toFullUpper(RangeStart, 0, 0, &v25, 1);
          if ((v11 & 0x80000000) == 0)
          {
            if (v11 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v11);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v11);
            }
          }
          unsigned int v12 = ucase_toFullFolding(RangeStart, &v25, 0);
          if ((v12 & 0x80000000) == 0)
          {
            if (v12 < 0x20)
            {
              *(void *)&v30[0] = v25;
              icu::UnicodeString::setTo((icu::UnicodeString *)&v31, 0, (const UChar **)v30, v12);
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
            }
            else
            {
              icu::UnicodeSet::add((icu::UnicodeSet *)v28, v12);
            }
          }
          ++RangeStart;
        }
        while (v8 != RangeStart);
      }
    }
  }
  if (icu::UnicodeSet::hasStrings((icu::UnicodeSet *)this))
  {
    memset(v30, 0, sizeof(v30));
    icu::Locale::Locale((icu::Locale *)v30, "", 0, 0, 0);
    int v24 = 0;
    WordInstance = icu::BreakIterator::createWordInstance((char **)v30, (const icu::Locale *)&v24, v13, v14);
    if (v24 <= 0)
    {
      long long v16 = this[10];
      if (*((int *)v16 + 2) >= 1)
      {
        signed int v17 = 0;
        do
        {
          uint64_t v18 = (UChar **)icu::UVector::elementAt(v16, v17);
          uint64_t v19 = (UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toLower(v19, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          uint64_t v20 = (UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toTitle(v20, (icu::BreakIterator *)WordInstance, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          int v21 = (UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::toUpper(v21, (const icu::Locale *)v30);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          long long v22 = (UChar **)icu::UnicodeString::operator=(&v31, v18);
          icu::UnicodeString::foldCase(v22, 0);
          icu::UnicodeSet::add((icu::UnicodeSet *)v28, (const icu::UnicodeString *)&v31);
          ++v17;
          long long v16 = this[10];
        }
        while (v17 < *((_DWORD *)v16 + 2));
      }
    }
    if (WordInstance) {
      (*(void (**)(char *))(*(void *)WordInstance + 8))(WordInstance);
    }
    icu::Locale::~Locale((icu::Locale *)v30);
  }
  icu::UnicodeSet::operator=((icu::UnicodeSet *)this, (const icu::UnicodeSet *)v28);
  icu::UnicodeString::~UnicodeString(v23, (icu::UnicodeString *)&v31);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v26);
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)v28);
}

void *sub_18C896DEC(icu::UnicodeSet *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 >> 31, &v6);
  icu::UnicodeSet::add(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

icu::UVector **sub_18C896E7C(icu::UnicodeSet *a1, icu::UVector **a2)
{
  int v3 = a1;
  if ((int)icu::UnicodeSet::size(a1) >= 30)
  {
    int v10 = 0;
    int v4 = sub_18C7F017C(34, (UErrorCode *)&v10);
    if (v10 <= 0)
    {
      int32_t v5 = v4;
      int RangeCount = icu::UnicodeSet::getRangeCount(v3);
      int v7 = icu::UnicodeSet::getRangeCount(v5);
      if (RangeCount <= v7) {
        uint64_t v8 = v3;
      }
      else {
        uint64_t v8 = v5;
      }
      if (RangeCount <= v7) {
        int v3 = v5;
      }
      icu::UnicodeSet::retainAll(a2, v8);
      icu::UnicodeSet::retainAll(a2, v3);
      return a2;
    }
  }
  return (icu::UVector **)v3;
}

uint64_t sub_18C896F18(UErrorCode *a1)
{
  if (*(int *)a1 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191EE0, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191EE0))
    {
      if (dword_1E9191EE4 >= 1) {
        *a1 = dword_1E9191EE4;
      }
    }
    else
    {
      sub_18C896FA4(a1, v2);
      dword_1E9191EE4 = *a1;
      icu::umtx_initImplPostInit(&dword_1E9191EE0);
    }
  }
  return qword_1E9191ED8;
}

void sub_18C896FA4(UErrorCode *a1, unint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = icu::UMemory::operator new((icu::UMemory *)0xC8, a2);
  if (!v3)
  {
    qword_1E9191ED8 = 0;
    goto LABEL_5;
  }
  uint64_t v4 = v3;
  uint64_t v6 = "[";
  icu::UnicodeString::UnicodeString(v7, 1, &v6);
  *(void *)uint64_t v4 = &unk_1EDA47548;
  *(void *)(v4 + 8) = &unk_1EDA47660;
  *(void *)(v4 + 16) = v4 + 96;
  *(void *)(v4 + 24) = 0x100000019;
  *(unsigned char *)(v4 + 32) = 0;
  *(void *)(v4 + 64) = 0;
  *(_DWORD *)(v4 + 72) = 0;
  *(void *)(v4 + 40) = 0;
  *(void *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 56) = 0;
  *(void *)(v4 + 80) = 0;
  *(void *)(v4 + 88) = 0;
  icu::UnicodeSet::applyPattern((icu::UnicodeSet *)v4, (const icu::UnicodeString *)v7, a1);
  qword_1E9191ED8 = v4;
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v7);
  if (!qword_1E9191ED8)
  {
LABEL_5:
    *a1 = U_MEMORY_ALLOCATION_ERROR;
    goto LABEL_6;
  }
  icu::UnicodeSet::freeze((icu::UnicodeSet *)qword_1E9191ED8);
LABEL_6:
  sub_18C8546F4(0x12u, (uint64_t)sub_18C898F58);
}

icu::UnicodeSet *icu::UnicodeSet::UnicodeSet(icu::UnicodeSet *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3);
}

{
  *(void *)this = &unk_1EDA47548;
  *((void *)this + 1) = &unk_1EDA47660;
  *((void *)this + 2) = (char *)this + 96;
  *((void *)this + 3) = 0x100000019;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  return icu::UnicodeSet::applyPattern(this, a2, a3);
}

icu::UnicodeSet *icu::UnicodeSet::applyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, UErrorCode *a3)
{
  unsigned int v11 = &unk_1EDA44670;
  unint64_t v12 = 0xFFFFFFFF00000000;
  icu::UnicodeSet::applyPatternIgnoreSpace(this, a2, (icu::ParsePosition *)&v11, 0, a3);
  if (*(int *)a3 <= 0)
  {
    int v10 = v12;
    icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v10, (int *)1);
    unsigned int v6 = *((unsigned __int16 *)a2 + 4);
    int v7 = (__int16)v6;
    unsigned int v8 = v6 >> 5;
    if (v7 < 0) {
      unsigned int v8 = *((_DWORD *)a2 + 3);
    }
    if (v10 != v8) {
      *a3 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }
  icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v11);
  return this;
}

void icu::UnicodeSet::applyPatternIgnoreSpace(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, const icu::SymbolTable *a4, UErrorCode *a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(int *)a5 <= 0)
  {
    if (*((void *)this + 5) || *((void *)this + 11))
    {
      *a5 = U_NO_WRITE_PERMISSION;
    }
    else
    {
      long long v12 = 0u;
      long long v13 = 0u;
      uint64_t v15 = 0;
      long long v14 = 0u;
      uint64_t v10 = 0;
      unsigned int v11 = &unk_1EDA47700;
      LOWORD(v12) = 2;
      long long v8 = 0u;
      long long v9 = 0u;
      sub_18C83A890((uint64_t)&v8, (uint64_t)a2, (uint64_t)a4, (uint64_t)a3);
      icu::UnicodeSet::applyPattern(this, (uint64_t *)&v8, (uint64_t)a4, (icu::UnicodeString *)&v11, 1u, 0, 0, 0, a5);
      if (*(int *)a5 <= 0)
      {
        if (*((void *)&v9 + 1)) {
          *a5 = U_MALFORMED_SET;
        }
        else {
          sub_18C8964B8((uint64_t)this, (uint64_t)&v11);
        }
      }
      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v11);
    }
  }
}

void icu::UnicodeSet::applyPattern(icu::UnicodeSet *a1, uint64_t *a2, uint64_t a3, icu::UnicodeString *a4, unsigned int a5, void (*a6)(void *), uint64_t a7, int a8, UErrorCode *a9)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (*(int *)a9 > 0) {
    return;
  }
  if (a8 >= 101)
  {
    *a9 = U_ILLEGAL_ARGUMENT_ERROR;
    return;
  }
  long long v55 = 0u;
  uint64_t v58 = 0;
  if (a5) {
    char v12 = 7;
  }
  else {
    char v12 = 3;
  }
  long long v57 = 0uLL;
  long long v56 = 0uLL;
  long long v54 = &unk_1EDA47700;
  LOWORD(v55) = 2;
  long long v50 = 0uLL;
  uint64_t v53 = 0;
  long long v52 = 0uLL;
  long long v51 = 0uLL;
  BOOL v49 = &unk_1EDA47700;
  LOWORD(v50) = 2;
  v47[0] = 0;
  v47[1] = 0;
  icu::UnicodeSet::clear(a1);
  int v13 = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  char v17 = 0;
  UChar32 v45 = 0;
  int v39 = 0;
  unsigned int v40 = a8 + 1;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        if (sub_18C83A8A0(a2)) {
          goto LABEL_134;
        }
        char v46 = 0;
        if (!icu::UnicodeSet::resemblesPropertyPattern((uint64_t)a2, v12)) {
          break;
        }
        uint64_t v19 = 0;
        int v20 = 2;
LABEL_11:
        if (v17 == 1)
        {
          if (v14) {
            goto LABEL_123;
          }
          icu::UnicodeSet::add(a1, v15, v15);
          icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v54, v15, 0);
        }
        else if (v14 == 45 || v14 == 38)
        {
          __int16 v48 = v14;
          icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
        }
        if (!v19)
        {
          uint64_t v19 = v45;
          if (!v45)
          {
            int v21 = (icu::UnicodeSet *)icu::UMemory::operator new((icu::UMemory *)0xC8, v18);
            if (!v21) {
              goto LABEL_117;
            }
            icu::UnicodeSet::UnicodeSet(v21);
            UChar32 v45 = v22;
            uint64_t v19 = v22;
          }
        }
        if (v20 == 3)
        {
          icu::UnicodeSet::_toPattern(v19, (icu::UnicodeString *)&v54, 0);
        }
        else if (v20 == 2)
        {
          sub_18C83ACC4((BOOL)a2, v12);
          icu::UnicodeSet::applyPropertyPattern(v19, a2, (uint64_t)&v54, a9);
          if (*(int *)a9 >= 1) {
            goto LABEL_135;
          }
        }
        else
        {
          icu::UnicodeSet::applyPattern(v19, a2, a3, &v54, a5, a6, a7, v40, a9);
        }
        if (!v16)
        {
          icu::UnicodeSet::operator=(a1, v19);
          int v13 = 1;
          goto LABEL_103;
        }
        if (v14)
        {
          if (v14 == 38) {
            icu::UnicodeSet::retainAll((icu::UVector **)a1, v19);
          }
          else {
            icu::UnicodeSet::removeAll((icu::UVector **)a1, v19);
          }
          int v14 = 0;
        }
        else
        {
          icu::UnicodeSet::addAll((icu::UVector **)a1, v19);
        }
        int v13 = 1;
LABEL_39:
        char v17 = 2;
      }
      sub_18C83AC8C((uint64_t)a2, (uint64_t)v47);
      uint64_t v23 = sub_18C83A8DC((uint64_t)a2, v12, &v46, (int *)a9);
      if (*(int *)a9 > 0) {
        goto LABEL_135;
      }
      uint64_t v24 = v23;
      if (v23 != 91 || v46) {
        break;
      }
      if (v16 == 1)
      {
        sub_18C83ACA8((uint64_t)a2, (uint64_t)v47);
        uint64_t v19 = 0;
        int v20 = 1;
        goto LABEL_11;
      }
      __int16 v48 = 91;
      icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
      sub_18C83AC8C((uint64_t)a2, (uint64_t)v47);
      int v27 = sub_18C83A8DC((uint64_t)a2, v12, &v46, (int *)a9);
      if (*(int *)a9 > 0) {
        goto LABEL_135;
      }
      if (v27 == 94 && !v46)
      {
        __int16 v48 = 94;
        int v39 = 1;
        icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
        sub_18C83AC8C((uint64_t)a2, (uint64_t)v47);
        int v27 = sub_18C83A8DC((uint64_t)a2, v12, &v46, (int *)a9);
        if (*(int *)a9 > 0) {
          goto LABEL_135;
        }
      }
      if (v27 == 45)
      {
        int v16 = 1;
        char v46 = 1;
        uint64_t v24 = 45;
        goto LABEL_59;
      }
      sub_18C83ACA8((uint64_t)a2, (uint64_t)v47);
      int v16 = 1;
    }
    if (a3)
    {
      uint64_t v25 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24))(a3, v23);
      if (v25)
      {
        if (!v26) {
          goto LABEL_123;
        }
        uint64_t v19 = v26;
        int v20 = 3;
        goto LABEL_11;
      }
    }
    if (!v16) {
      goto LABEL_123;
    }
    if (v46) {
      goto LABEL_59;
    }
    if ((int)v24 <= 44) {
      break;
    }
    if ((int)v24 > 93)
    {
      if (v24 == 123)
      {
        if (!v14)
        {
          if (v17 == 1)
          {
            icu::UnicodeSet::add(a1, v15, v15);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v54, v15, 0);
          }
          sub_18C8980C0((uint64_t)&v49, 0);
          while (!sub_18C83A8A0(a2))
          {
            unsigned int v29 = sub_18C83A8DC((uint64_t)a2, v12, &v46, (int *)a9);
            if (*(int *)a9 > 0) {
              goto LABEL_135;
            }
            if (v29 == 125 && !v46)
            {
              icu::UnicodeSet::add(a1, (const icu::UnicodeString *)&v49);
              __int16 v48 = 123;
              icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
              icu::UnicodeSet::_appendToPat((icu::ICU_Utility *)&v54, (icu::UnicodeString *)&v49, 0);
              __int16 v48 = 125;
              icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
              goto LABEL_69;
            }
            icu::UnicodeString::append((uint64_t)&v49, v29);
          }
        }
LABEL_123:
        int v28 = 65538;
        goto LABEL_124;
      }
      if (v24 == 94) {
        goto LABEL_123;
      }
LABEL_59:
      switch(v17)
      {
        case 2:
          if (v14) {
            goto LABEL_123;
          }
LABEL_65:
          char v17 = 1;
          goto LABEL_76;
        case 1:
          if (v14 == 45)
          {
            if ((int)v15 >= (int)v24) {
              goto LABEL_123;
            }
            icu::UnicodeSet::add(a1, v15, v24);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v54, v15, 0);
            __int16 v48 = 45;
            icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v54, (icu::UnicodeString *)v24, 0);
LABEL_69:
            char v17 = 0;
            int v14 = 0;
          }
          else
          {
            icu::UnicodeSet::add(a1, v15, v15);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v54, v15, 0);
LABEL_76:
            uint64_t v15 = (icu::UnicodeString *)v24;
          }
          break;
        case 0:
          goto LABEL_65;
      }
    }
    else
    {
      if (v24 != 45)
      {
        if (v24 == 93)
        {
          if (v17 == 1)
          {
            icu::UnicodeSet::add(a1, v15, v15);
            icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v54, v15, 0);
          }
          if (v14 != 38)
          {
            if (v14 == 45)
            {
              icu::UnicodeSet::add(a1, 0x2Du, 0x2Du);
              __int16 v48 = 45;
              goto LABEL_132;
            }
            goto LABEL_133;
          }
          goto LABEL_123;
        }
        goto LABEL_59;
      }
      if (v14) {
        goto LABEL_123;
      }
      if (!v17)
      {
        icu::UnicodeSet::add(a1, 0x2Du, 0x2Du);
        int v37 = sub_18C83A8DC((uint64_t)a2, v12, &v46, (int *)a9);
        if (*(int *)a9 > 0) {
          goto LABEL_135;
        }
        int v28 = 65538;
        if (v37 == 93 && !v46)
        {
          icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&unk_18CAA1C4E, 0, 2);
          goto LABEL_103;
        }
LABEL_124:
        int v21 = v45;
        goto LABEL_125;
      }
      int v14 = 45;
    }
  }
  if (v24 != 36)
  {
    if (v24 == 38)
    {
      int v28 = 65538;
      if (v17 != 2 || v14) {
        goto LABEL_124;
      }
      int v14 = 38;
      goto LABEL_39;
    }
    goto LABEL_59;
  }
  sub_18C83AC8C((uint64_t)a2, (uint64_t)v47);
  int v30 = sub_18C83A8DC((uint64_t)a2, v12, &v46, (int *)a9);
  if (*(int *)a9 > 0) {
    goto LABEL_135;
  }
  BOOL v32 = v30 == 93 && v46 == 0;
  if (!a3 && !v32)
  {
    sub_18C83ACA8((uint64_t)a2, (uint64_t)v47);
    uint64_t v24 = 36;
    goto LABEL_59;
  }
  if (v14) {
    BOOL v32 = 0;
  }
  if (v32)
  {
    if (v17 == 1)
    {
      icu::UnicodeSet::add(a1, v15, v15);
      icu::UnicodeSet::_appendToPat((icu::UnicodeSet *)&v54, v15, 0);
    }
    icu::UnicodeSet::add(a1, 0xFFFFu);
    __int16 v48 = 36;
    int v13 = 1;
LABEL_132:
    icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
LABEL_133:
    __int16 v48 = 93;
    icu::UnicodeString::doAppend((uint64_t)&v54, (uint64_t)&v48, 0, 1);
LABEL_103:
    sub_18C83ACC4((BOOL)a2, v12);
    if ((a5 & 6) != 0)
    {
      long long v33 = (void *)((char *)a1 + (a7 >> 1));
      if (a7) {
        (*(void (**)(void *))(*v33 + a6))(v33);
      }
      else {
        a6(v33);
      }
    }
    if (v39)
    {
      long long v34 = icu::UnicodeSet::complement(a1);
      icu::UnicodeSet::removeAllStrings(v34);
    }
    if (v13)
    {
      if ((v55 & 0x8000u) == 0) {
        uint64_t v35 = (unsigned __int16)v55 >> 5;
      }
      else {
        uint64_t v35 = DWORD1(v55);
      }
      icu::UnicodeString::doAppend((uint64_t)a4, (const icu::UnicodeString *)&v54, 0, v35);
    }
    else
    {
      icu::UnicodeSet::_generatePattern(a1, a4, 0);
    }
    if (*((unsigned char *)a1 + 32))
    {
      int v21 = v45;
      if (*(int *)a9 > 0) {
        goto LABEL_136;
      }
LABEL_117:
      int v28 = 7;
LABEL_125:
      *a9 = v28;
      goto LABEL_136;
    }
  }
  else
  {
LABEL_134:
    *a9 = U_MALFORMED_SET;
  }
LABEL_135:
  int v21 = v45;
LABEL_136:
  if (v21)
  {
    icu::UnicodeSet::~UnicodeSet(v21);
    icu::UMemory::operator delete(v36);
  }
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v49);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v54);
}

BOOL icu::UnicodeSet::resemblesPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2)
{
  int v2 = a2 + 1;
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0)
  {
    unsigned int v4 = *((_DWORD *)this + 3);
    if (v2 >= (int)v4) {
      return icu::UnicodeSet::resemblesPropertyPattern((uint64_t)this, (signed int)a2) != 0;
    }
  }
  else
  {
    if (v2 >= (int)(v3 >> 5)) {
      return icu::UnicodeSet::resemblesPropertyPattern((uint64_t)this, (signed int)a2) != 0;
    }
    unsigned int v4 = v3 >> 5;
  }
  if (v4 > a2)
  {
    int32_t v5 = (v3 & 2) != 0 ? (icu::UnicodeSet *)((char *)this + 10) : (icu::UnicodeSet *)*((void *)this + 3);
    if (*((_WORD *)v5 + (int)a2) == 91) {
      return 1;
    }
  }
  return icu::UnicodeSet::resemblesPropertyPattern((uint64_t)this, (signed int)a2) != 0;
}

uint64_t icu::UnicodeSet::resemblesPropertyPattern(uint64_t a1, signed int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if ((v2 & 0x8000u) == 0) {
    unsigned int v3 = v2 >> 5;
  }
  else {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
  }
  if (a2 + 5 > (int)v3 || v3 <= a2) {
    return 0;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = a1 + 10;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 24);
  }
  int v5 = *(unsigned __int16 *)(v4 + 2 * a2);
  if (v5 != 92)
  {
    if (v5 == 91)
    {
      uint64_t v6 = a2 + 1;
      if (v3 > v6 && *(_WORD *)(v4 + 2 * v6) == 58) {
        return 1;
      }
    }
    return 0;
  }
  uint64_t v8 = a2 + 1;
  if (v3 <= v8) {
    return 0;
  }
  int v9 = *(_WORD *)(v4 + 2 * v8) & 0xFFDF;
  uint64_t result = v9 == 80;
  if (v9 != 80 && v3 > v8) {
    return *(unsigned __int16 *)(v4 + 2 * (int)v8) == 78;
  }
  return result;
}

BOOL icu::UnicodeSet::resemblesPropertyPattern(uint64_t a1, char a2)
{
  char v12 = 0;
  int v11 = 0;
  char v4 = a2 & 0xFD;
  v10[0] = 0;
  v10[1] = 0;
  sub_18C83AC8C(a1, (uint64_t)v10);
  int v5 = sub_18C83A8DC(a1, v4, &v12, &v11);
  if ((v5 - 91) <= 1)
  {
    int v6 = v5;
    int v7 = sub_18C83A8DC(a1, a2 & 0xF9, &v12, &v11);
    int v8 = v7;
    if (v6 == 91)
    {
      sub_18C83ACA8(a1, (uint64_t)v10);
      if (v8 != 58) {
        return 0;
      }
      return v11 < 1;
    }
    if ((v7 - 78) <= 0x22 && ((1 << (v7 - 78)) & 0x400000005) != 0)
    {
      sub_18C83ACA8(a1, (uint64_t)v10);
      return v11 < 1;
    }
  }
  sub_18C83ACA8(a1, (uint64_t)v10);
  return 0;
}

void icu::UnicodeSet::applyPropertyPattern(icu::UnicodeSet *a1, uint64_t *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(int *)a4 <= 0)
  {
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t v14 = 0;
    long long v13 = 0u;
    uint64_t v10 = &unk_1EDA47700;
    LOWORD(v11) = 2;
    sub_18C83AC1C((uint64_t)a2, (icu::UnicodeString *)&v10, 0xFFFFFFFF);
    int v8 = &unk_1EDA44670;
    *(void *)int v9 = 0xFFFFFFFF00000000;
    icu::UnicodeSet::applyPropertyPattern(a1, (const icu::UnicodeString *)&v10, (icu::ParsePosition *)&v8, a4);
    if (*(int *)a4 <= 0)
    {
      if (v9[0])
      {
        sub_18C83AC88(a2, v9[0]);
        icu::UnicodeString::doAppend(a3, (const icu::UnicodeString *)&v10, 0, v9[0]);
      }
      else
      {
        *a4 = U_MALFORMED_SET;
      }
    }
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v8);
    icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v10);
  }
}

uint64_t sub_18C8980C0(uint64_t a1, int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if (!a2 && (v2 & 1) != 0)
  {
    icu::UnicodeString::unBogus(a1);
    return 0;
  }
  if ((v2 & 0x8000) != 0) {
    unsigned int v3 = *(_DWORD *)(a1 + 12);
  }
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a2) {
    return 0;
  }
  if (a2 > 1023)
  {
    *(_WORD *)(a1 + 8) = v2 | 0xFFE0;
    *(_DWORD *)(a1 + 12) = a2;
  }
  else
  {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 8) & 0x1F | (32 * a2);
  }
  return 1;
}

icu::UnicodeSet *icu::UnicodeSet::applyFilter(icu::UnicodeSet *this, signed __int8 (*a2)(int, void *), void *a3, const icu::UnicodeSet *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    int v5 = a5;
    int v9 = this;
    icu::UnicodeSet::clear(this);
    this = (icu::UnicodeSet *)icu::UnicodeSet::getRangeCount(a4);
    if ((int)this >= 1)
    {
      int v10 = (int)this;
      int v16 = v5;
      int v11 = 0;
      signed int v12 = -1;
      do
      {
        int RangeStart = icu::UnicodeSet::getRangeStart(a4, v11);
        this = (icu::UnicodeSet *)icu::UnicodeSet::getRangeEnd(a4, v11);
        if (RangeStart <= (int)this)
        {
          int v14 = (int)this;
          unsigned int v15 = RangeStart - 1;
          do
          {
            this = (icu::UnicodeSet *)((uint64_t (*)(void, void *))a2)(v15 + 1, a3);
            if (this)
            {
              if (v12 < 0) {
                signed int v12 = v15 + 1;
              }
            }
            else if ((v12 & 0x80000000) == 0)
            {
              this = icu::UnicodeSet::add(v9, v12, v15);
              signed int v12 = -1;
            }
            ++v15;
          }
          while (v14 != v15);
        }
        ++v11;
      }
      while (v11 != v10);
      int v5 = v16;
      if ((v12 & 0x80000000) == 0) {
        this = icu::UnicodeSet::add(v9, v12, 0x10FFFFu);
      }
    }
    if ((*((unsigned char *)v9 + 32) & 1) != 0 && *(int *)v5 <= 0) {
      *int v5 = U_MEMORY_ALLOCATION_ERROR;
    }
  }
  return this;
}

icu::UnicodeSet *icu::UnicodeSet::applyIntPropertyValue(icu::UnicodeSet *this, uint64_t property, unsigned int a3, UErrorCode *pErrorCode)
{
  unsigned int v16 = a3;
  if (*(int *)pErrorCode > 0 || *((void *)this + 5) || *((void *)this + 11)) {
    return this;
  }
  int v7 = property;
  if (property == 28672)
  {
    int v8 = (const icu::UnicodeSet *)sub_18C7EFE14(28672, (int *)pErrorCode);
    v15[0] = a3;
    int v11 = (uint64_t (*)(UChar32, unsigned int *))sub_18C8983F0;
LABEL_8:
    int v9 = v11;
    int v10 = v15;
    goto LABEL_9;
  }
  if (property == 0x2000)
  {
    int v8 = (const icu::UnicodeSet *)sub_18C7EFE14(0x2000, (int *)pErrorCode);
    int v9 = sub_18C8983C4;
    int v10 = &v16;
LABEL_9:
    icu::UnicodeSet::applyFilter(this, (signed __int8 (*)(int, void *))v9, v10, v8, pErrorCode);
    return this;
  }
  if (property > 0x4A)
  {
    if ((property - 4096) > 0x18)
    {
      *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
      return this;
    }
    int v8 = (const icu::UnicodeSet *)sub_18C7EFE14(property, (int *)pErrorCode);
    v15[0] = v7;
    v15[1] = a3;
    int v11 = (uint64_t (*)(UChar32, unsigned int *))sub_18C8983F8;
    goto LABEL_8;
  }
  if (a3 > 1)
  {
    icu::UnicodeSet::clear(this);
  }
  else
  {
    BinaryPropertySet = u_getBinaryPropertySet((UProperty)property, pErrorCode);
    if (*(int *)pErrorCode <= 0)
    {
      icu::UnicodeSet::copyFrom(this, BinaryPropertySet, 1);
      if (!a3)
      {
        int v14 = icu::UnicodeSet::complement(this);
        icu::UnicodeSet::removeAllStrings(v14);
      }
    }
  }
  return this;
}

uint64_t sub_18C8983C4(UChar32 a1, unsigned int *a2)
{
  unsigned int v2 = *a2;
  return (v2 >> u_charType(a1)) & 1;
}

BOOL sub_18C8983F0(unsigned int a1, unsigned int *a2)
{
  return uscript_hasScript(a1, *a2);
}

BOOL sub_18C8983F8(UChar32 a1, uint64_t a2)
{
  return u_getIntPropertyValue(a1, *(UProperty *)a2) == *(_DWORD *)(a2 + 4);
}

icu::UnicodeSet *icu::UnicodeSet::applyPropertyAlias(icu::UnicodeSet *this, const icu::UnicodeString *a2, const icu::UnicodeString *a3, UErrorCode *a4)
{
  v49[8] = *(void **)MEMORY[0x1E4F143B8];
  if (*(int *)a4 > 0 || *((void *)this + 5) || *((void *)this + 11)) {
    return this;
  }
  unsigned int v8 = *((unsigned __int16 *)a2 + 4);
  if ((v8 & 0x11) != 0)
  {
    int v9 = 0;
  }
  else if ((v8 & 2) != 0)
  {
    int v9 = (_WORD *)((char *)a2 + 10);
  }
  else
  {
    int v9 = (_WORD *)*((void *)a2 + 3);
  }
  int v10 = (__int16)v8;
  int v11 = v8 >> 5;
  if (v10 >= 0) {
    int v12 = v11;
  }
  else {
    int v12 = *((_DWORD *)a2 + 3);
  }
  if (!uprv_isInvariantUString(v9, v12)
    || ((unsigned int v13 = *((unsigned __int16 *)a3 + 4), (v13 & 0x11) == 0)
      ? ((v13 & 2) != 0
       ? (int v14 = (_WORD *)((char *)a3 + 10))
       : (int v14 = (_WORD *)*((void *)a3 + 3)))
      : (int v14 = 0),
        (int v15 = (__int16)v13, v16 = v13 >> 5, v15 >= 0) ? (v17 = v16) : (v17 = *((_DWORD *)a3 + 3)),
        !uprv_isInvariantUString(v14, v17)))
  {
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return this;
  }
  memset(&v49[1], 0, 56);
  v49[0] = (char *)&v49[1] + 5;
  LODWORD(v49[1]) = 40;
  memset(&alias[1], 0, 56);
  alias[0] = (char *)&alias[1] + 5;
  LODWORD(alias[1]) = 40;
  icu::CharString::appendInvariantChars((icu::CharString *)v49, a2, a4);
  icu::CharString::appendInvariantChars((icu::CharString *)alias, a3, a4);
  if (*(int *)a4 <= 0)
  {
    unsigned int v18 = *((unsigned __int16 *)a3 + 4);
    int v19 = (__int16)v18;
    int v20 = v18 >> 5;
    if (v19 < 0) {
      int v20 = *((_DWORD *)a3 + 3);
    }
    if (v20 < 1)
    {
      uint64_t v23 = 0x2000;
      PropertyValueEnusigned int m = u_getPropertyValueEnum(UCHAR_GENERAL_CATEGORY_MASK, (const char *)v49[0]);
      if (PropertyValueEnum != -1
        || (uint64_t v23 = 4106,
            PropertyValueEnusigned int m = u_getPropertyValueEnum(UCHAR_SCRIPT, (const char *)v49[0]),
            PropertyValueEnum != -1))
      {
        int32_t v25 = PropertyValueEnum;
        goto LABEL_43;
      }
      PropertyEnusigned int m = u_getPropertyEnum((const char *)v49[0]);
      if (PropertyEnum < 0x4B)
      {
        uint64_t v23 = PropertyEnum;
        int32_t v25 = 1;
        goto LABEL_43;
      }
      if (uprv_compareASCIIPropertyNames(byte_18CA81C60, (unsigned __int8 *)v49[0]))
      {
        if (uprv_compareASCIIPropertyNames("ASCII", (unsigned __int8 *)v49[0]))
        {
          if (!uprv_compareASCIIPropertyNames("Assigned", (unsigned __int8 *)v49[0]))
          {
            int v37 = icu::UnicodeSet::applyIntPropertyValue(this, 0x2000, 1u, a4);
            int v38 = icu::UnicodeSet::complement(v37);
            icu::UnicodeSet::removeAllStrings(v38);
LABEL_44:
            if ((*((unsigned char *)this + 32) & 1) == 0 || *(int *)a4 > 0) {
              goto LABEL_71;
            }
            UErrorCode v27 = U_MEMORY_ALLOCATION_ERROR;
            goto LABEL_70;
          }
          goto LABEL_69;
        }
        uint64_t v35 = this;
        unsigned int v36 = 127;
      }
      else
      {
        uint64_t v35 = this;
        unsigned int v36 = 1114111;
      }
      icu::UnicodeSet::set(v35, 0, v36);
      goto LABEL_71;
    }
    uint64_t v21 = u_getPropertyEnum((const char *)v49[0]);
    if (v21 == -1) {
      goto LABEL_69;
    }
    uint64_t v22 = v21;
    if (v21 == 4101) {
      uint64_t v23 = 0x2000;
    }
    else {
      uint64_t v23 = v21;
    }
    if (v23 == 0x2000 || v23 < 0x4B || (v23 - 4096) <= 0x18)
    {
      int32_t v25 = u_getPropertyValueEnum((UProperty)v23, alias[0]);
      if (v25 != -1) {
        goto LABEL_43;
      }
      if ((v23 - 4098) <= 0xF && ((1 << (v23 - 2)) & 0xC001) != 0)
      {
        *(void *)versionString = 0;
        double v30 = strtod(alias[0], (char **)versionString);
        if (!**(unsigned char **)versionString && v30 >= 0.0 && v30 <= 255.0)
        {
          int32_t v25 = (int)v30;
          if (v30 == (double)(int)v30)
          {
            uint64_t v23 = v22;
            goto LABEL_43;
          }
        }
      }
      goto LABEL_69;
    }
    if ((int)v23 <= 16388)
    {
      if (v23 == 12288)
      {
        *(void *)versionString = 0;
        double versionArray = strtod(alias[0], (char **)versionString);
        if (**(unsigned char **)versionString) {
          goto LABEL_69;
        }
        int v28 = (const icu::UnicodeSet *)sub_18C7EFE14(12288, (int *)a4);
        unsigned int v29 = (signed __int8 (*)(int, void *))sub_18C898940;
      }
      else
      {
        if (v23 != 0x4000) {
          goto LABEL_69;
        }
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        *(_OWORD *)versionString = 0u;
        long long v41 = 0u;
        if (!sub_18C898970((uint64_t)versionString, (uint64_t)alias[0])) {
          goto LABEL_69;
        }
        LODWORD(versionArray) = 0;
        u_versionFromString((uint8_t *)&versionArray, versionString);
        int v28 = (const icu::UnicodeSet *)sub_18C7EFE14(0x4000, (int *)a4);
        unsigned int v29 = (signed __int8 (*)(int, void *))sub_18C8989F0;
      }
      icu::UnicodeSet::applyFilter(this, v29, &versionArray, v28, a4);
    }
    else
    {
      if (v23 != 16389)
      {
        if (v23 == 28672)
        {
          int32_t v24 = u_getPropertyValueEnum(UCHAR_SCRIPT, alias[0]);
          if (v24 != -1)
          {
            int32_t v25 = v24;
            uint64_t v23 = 28672;
LABEL_43:
            icu::UnicodeSet::applyIntPropertyValue(this, v23, v25, a4);
            goto LABEL_44;
          }
        }
LABEL_69:
        UErrorCode v27 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_70:
        *a4 = v27;
        goto LABEL_71;
      }
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      *(_OWORD *)versionString = 0u;
      long long v41 = 0u;
      if (!sub_18C898970((uint64_t)versionString, (uint64_t)alias[0])) {
        goto LABEL_69;
      }
      UChar32 v32 = u_charFromName(U_EXTENDED_CHAR_NAME, versionString, a4);
      if (*(int *)a4 > 0) {
        goto LABEL_69;
      }
      unsigned int v33 = v32;
      icu::UnicodeSet::clear(this);
      icu::UnicodeSet::add(this, v33);
    }
  }
LABEL_71:
  if (BYTE4(alias[1])) {
    uprv_free(alias[0]);
  }
  if (BYTE4(v49[1])) {
    uprv_free(v49[0]);
  }
  return this;
}

BOOL sub_18C898940(UChar32 a1, double *a2)
{
  return u_getNumericValue(a1) == *a2;
}

uint64_t sub_18C898970(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  while (2)
  {
    uint64_t v3 = a2 + 1;
    while (1)
    {
      a2 = v3;
      int v4 = *(unsigned __int8 *)(v3 - 1);
      if (v4 != 32) {
        break;
      }
      ++v3;
      if (v2 && *(unsigned char *)(a1 + (v2 - 1)) != 32) {
        goto LABEL_8;
      }
    }
    if (!*(unsigned char *)(v3 - 1))
    {
      if (v2)
      {
        if (*(unsigned char *)(a1 + (v2 - 1)) == 32) {
          LODWORD(v2) = v2 - 1;
        }
        uint64_t v2 = (int)v2;
      }
      else
      {
        uint64_t v2 = 0;
      }
      *(unsigned char *)(a1 + v2) = 0;
      return 1;
    }
LABEL_8:
    if (v2 != 127)
    {
      *(unsigned char *)(a1 + v2++) = v4;
      continue;
    }
    return 0;
  }
}

BOOL sub_18C8989F0(UChar32 a1, unsigned int *a2)
{
  *(_DWORD *)UVersionInfo versionArray = 0;
  u_charAge(a1, versionArray);
  BOOL result = 0;
  if (bswap32(*(unsigned int *)versionArray))
  {
    unsigned int v4 = bswap32(*(unsigned int *)versionArray);
    unsigned int v5 = bswap32(*a2);
    BOOL v6 = v4 >= v5;
    BOOL v7 = v4 > v5;
    int v8 = !v6;
    return v7 - v8 < 1;
  }
  return result;
}

icu::UnicodeSet *icu::UnicodeSet::applyPropertyPattern(icu::UnicodeSet *this, const icu::UnicodeString *a2, icu::ParsePosition *a3, UErrorCode *a4)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (*(int *)a4 > 0) {
    return this;
  }
  uint64_t v8 = *((int *)a3 + 2);
  unsigned int v9 = *((unsigned __int16 *)a2 + 4);
  if ((v9 & 0x8000u) == 0) {
    unsigned int v10 = v9 >> 5;
  }
  else {
    unsigned int v10 = *((_DWORD *)a2 + 3);
  }
  if ((int)v8 + 5 > (int)v10 || v10 <= v8) {
    goto LABEL_88;
  }
  unsigned int v42 = 0;
  if ((v9 & 2) != 0) {
    int v11 = (char *)a2 + 10;
  }
  else {
    int v11 = (char *)*((void *)a2 + 3);
  }
  int v12 = *(unsigned __int16 *)&v11[2 * v8];
  if (v12 == 92)
  {
    unsigned int v21 = v8 + 1;
    if (v10 > (int)v8 + 1)
    {
      int v22 = *(unsigned __int16 *)&v11[2 * v21];
      if ((v22 & 0xFFFFFFDF) != 0x50)
      {
        if (v10 <= v21 || *(_WORD *)&v11[2 * v21] != 78) {
          goto LABEL_88;
        }
        int v22 = 78;
      }
      BOOL v20 = v22 == 80;
      BOOL v23 = v22 == 78;
      unsigned int v42 = v8 + 2;
      int v24 = icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v42, 0);
      unsigned int v25 = *((unsigned __int16 *)a2 + 4);
      if ((v25 & 0x8000) != 0)
      {
        unsigned int v26 = *((_DWORD *)a2 + 3);
        if (v24 == v26) {
          goto LABEL_88;
        }
      }
      else
      {
        if (v24 == v25 >> 5) {
          goto LABEL_88;
        }
        unsigned int v26 = v25 >> 5;
      }
      int v27 = v24 + 1;
      unsigned int v42 = v24 + 1;
      if (v26 > v24)
      {
        int v28 = (char *)*((void *)a2 + 3);
        if ((v25 & 2) != 0) {
          int v28 = (char *)a2 + 10;
        }
        if (*(_WORD *)&v28[2 * v24] == 123)
        {
          if (v24 >= -1)
          {
            if ((v25 & 0x8000) != 0)
            {
              int v30 = *((_DWORD *)a2 + 3);
              int v29 = v30 >= v27 ? v24 + 1 : *((_DWORD *)a2 + 3);
            }
            else
            {
              int v30 = v25 >> 5;
              int v29 = v30 >= v27 ? v24 + 1 : v30;
            }
          }
          else
          {
            int v29 = 0;
            int v30 = (v25 & 0x8000) != 0 ? *((_DWORD *)a2 + 3) : v25 >> 5;
          }
          uint64_t v34 = icu::UnicodeString::doIndexOf((uint64_t)a2, 0x7Du, v29, v30 - v29);
          int v33 = 1;
          if ((v34 & 0x80000000) == 0) {
            goto LABEL_57;
          }
        }
      }
    }
LABEL_88:
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return this;
  }
  BOOL v13 = v12 == 91;
  unsigned int v14 = v8 + 1;
  BOOL v15 = v13 && v10 > v14;
  if (!v15 || *(_WORD *)&v11[2 * v14] != 58) {
    goto LABEL_88;
  }
  unsigned int v42 = v8 + 2;
  int v16 = icu::ICU_Utility::skipWhitespace(a2, (const icu::UnicodeString *)&v42, 0);
  unsigned int v42 = v16;
  unsigned int v17 = *((unsigned __int16 *)a2 + 4);
  int v18 = v17 >> 5;
  if ((v17 & 0x8000) != 0)
  {
    int v19 = *((_DWORD *)a2 + 3);
    if (v16 >= v19)
    {
      BOOL v20 = 0;
      if ((v16 & 0x80000000) == 0) {
        goto LABEL_50;
      }
LABEL_55:
      int v32 = 0;
      int v18 = *((_DWORD *)a2 + 3);
      goto LABEL_56;
    }
  }
  else
  {
    int v19 = v17 >> 5;
    if (v16 >= (int)(v17 >> 5))
    {
      BOOL v20 = 0;
      if (v16 < 0) {
        goto LABEL_54;
      }
      goto LABEL_46;
    }
  }
  if (v19 <= v16) {
    goto LABEL_43;
  }
  BOOL v31 = (char *)*((void *)a2 + 3);
  if ((v17 & 2) != 0) {
    BOOL v31 = (char *)a2 + 10;
  }
  if (*(_WORD *)&v31[2 * v16] == 94)
  {
    unsigned int v42 = ++v16;
    BOOL v20 = 1;
  }
  else
  {
LABEL_43:
    BOOL v20 = 0;
  }
  if (v16 < 0)
  {
    if ((v17 & 0x8000) == 0)
    {
LABEL_54:
      int v32 = 0;
      goto LABEL_56;
    }
    goto LABEL_55;
  }
  if ((v17 & 0x8000) == 0)
  {
LABEL_46:
    if (v18 >= v16) {
      int v32 = v16;
    }
    else {
      int v32 = v17 >> 5;
    }
    goto LABEL_56;
  }
LABEL_50:
  int v18 = *((_DWORD *)a2 + 3);
  if (v18 >= v16) {
    int v32 = v16;
  }
  else {
    int v32 = *((_DWORD *)a2 + 3);
  }
LABEL_56:
  int v33 = 2;
  uint64_t v34 = icu::UnicodeString::indexOf((uint64_t)a2, (uint64_t)L":]", 0, 2, v32, v18 - v32);
  BOOL v23 = 0;
  if ((v34 & 0x80000000) != 0) {
    goto LABEL_88;
  }
LABEL_57:
  unsigned int v35 = *((unsigned __int16 *)a2 + 4);
  if ((v42 & 0x80000000) != 0)
  {
    int v37 = 0;
    if ((v35 & 0x8000) != 0) {
      int v36 = *((_DWORD *)a2 + 3);
    }
    else {
      int v36 = v35 >> 5;
    }
  }
  else if ((v35 & 0x8000) != 0)
  {
    int v36 = *((_DWORD *)a2 + 3);
    if (v36 >= (int)v42) {
      int v37 = v42;
    }
    else {
      int v37 = *((_DWORD *)a2 + 3);
    }
  }
  else
  {
    int v36 = v35 >> 5;
    if (v36 >= v42) {
      int v37 = v42;
    }
    else {
      int v37 = v36;
    }
  }
  uint64_t v38 = icu::UnicodeString::doIndexOf((uint64_t)a2, 0x3Du, v37, v36 - v37);
  long long v50 = 0u;
  uint64_t v53 = 0;
  long long v52 = 0u;
  long long v51 = 0u;
  BOOL v49 = (UChar *)&unk_1EDA47700;
  LOWORD(v50) = 2;
  long long v45 = 0u;
  uint64_t v48 = 0;
  long long v47 = 0u;
  long long v46 = 0u;
  long long v44 = (UChar *)&unk_1EDA47700;
  LOWORD(v45) = 2;
  if ((v38 & 0x80000000) != 0 || (int v39 = v38, v38 >= v34) || v23)
  {
    (*(void (**)(const icu::UnicodeString *, void, uint64_t, UChar **))(*(void *)a2 + 24))(a2, v42, v34, &v49);
    if (v23)
    {
      icu::UnicodeString::operator=(&v44, &v49);
      icu::UnicodeString::UnicodeString(v43, "na", 2, 0);
      icu::UnicodeString::operator=((icu::UnicodeString *)&v49, (icu::UnicodeString *)v43);
      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)v43);
    }
  }
  else
  {
    (*(void (**)(const icu::UnicodeString *, void, uint64_t, UChar **))(*(void *)a2 + 24))(a2, v42, v38, &v49);
    (*(void (**)(const icu::UnicodeString *, void, uint64_t, UChar **))(*(void *)a2 + 24))(a2, (v39 + 1), v34, &v44);
  }
  icu::UnicodeSet::applyPropertyAlias(this, (const icu::UnicodeString *)&v49, (const icu::UnicodeString *)&v44, a4);
  if (*(int *)a4 <= 0)
  {
    if (v20)
    {
      unsigned int v40 = icu::UnicodeSet::complement(this);
      icu::UnicodeSet::removeAllStrings(v40);
    }
    *((_DWORD *)a3 + 2) = v34 + v33;
  }
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v44);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v49);
  return this;
}

uint64_t sub_18C898F58()
{
  if (qword_1E9191ED8)
  {
    icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)qword_1E9191ED8);
    icu::UMemory::operator delete(v0);
  }
  qword_1E9191ED8 = 0;
  atomic_store(0, &dword_1E9191EE0);
  return 1;
}

uint64_t sub_18C898F9C(uint64_t a1, const icu::UnicodeSet *a2, uint64_t a3, int a4)
{
  uint64_t v8 = (icu::UnicodeSet *)(a1 + 8);
  unsigned int v9 = (icu::UVector **)icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)(a1 + 8), 0, 1114111);
  *(_OWORD *)(a1 + 224) = 0u;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = a3;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_DWORD *)(a1 + 256) = 0;
  long long v56 = (char **)(a1 + 224);
  *(unsigned char *)(a1 + 260) = a4 == 63;
  icu::UnicodeSet::retainAll(v9, a2);
  if (a4) {
    *(void *)(a1 + 208) = v8;
  }
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  if ((int)v10 < 1) {
    goto LABEL_127;
  }
  unsigned int v11 = 0;
  char v12 = 0;
  do
  {
    uint64_t v13 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v11);
    unsigned int v14 = *(unsigned __int16 *)(v13 + 8);
    if ((v14 & 0x11) != 0)
    {
      BOOL v15 = 0;
      if ((v14 & 0x8000) == 0) {
        goto LABEL_10;
      }
    }
    else if ((v14 & 2) != 0)
    {
      BOOL v15 = (UChar *)(v13 + 10);
      if ((v14 & 0x8000) == 0)
      {
LABEL_10:
        uint64_t v16 = v14 >> 5;
        if (!v16) {
          goto LABEL_34;
        }
        goto LABEL_14;
      }
    }
    else
    {
      BOOL v15 = *(UChar **)(v13 + 24);
      if ((v14 & 0x8000) == 0) {
        goto LABEL_10;
      }
    }
    uint64_t v16 = *(unsigned int *)(v13 + 12);
    if (!v16) {
      goto LABEL_34;
    }
LABEL_14:
    int v17 = icu::UnicodeSet::span(v8, v15, v16, 1);
    if (v17 < (int)v16) {
      char v12 = 1;
    }
    if ((a4 & 8) != 0 && (int)v16 > *(_DWORD *)(a1 + 252)) {
      *(_DWORD *)(a1 + 252) = v16;
    }
    BOOL v19 = (a4 & 2) == 0 && v17 >= (int)v16;
    if ((a4 & 4) != 0 && !v19)
    {
      *(void *)UErrorCode pErrorCode = 0;
      u_strToUTF8(0, 0, (int32_t *)pErrorCode, v15, v16, &pErrorCode[1]);
      BOOL v20 = pErrorCode[1] == U_BUFFER_OVERFLOW_ERROR || pErrorCode[1] < U_ILLEGAL_ARGUMENT_ERROR;
      UErrorCode v21 = pErrorCode[0];
      if (!v20) {
        UErrorCode v21 = U_ZERO_ERROR;
      }
      *(_DWORD *)(a1 + 248) += v21;
      if (v21 > *(_DWORD *)(a1 + 256)) {
        *(_DWORD *)(a1 + 256) = v21;
      }
    }
LABEL_34:
    ++v11;
  }
  while (v10 != v11);
  if (!v12) {
    goto LABEL_127;
  }
  if (*(unsigned char *)(a1 + 260) && (icu::UnicodeSet::freeze(v8), int v22 = *(unsigned __int8 *)(a1 + 260), *(unsigned char *)(a1 + 260)))
  {
    int v23 = *(_DWORD *)(a1 + 248) + 8 * v10;
  }
  else
  {
    int v22 = 0;
    if ((a4 & 4) != 0) {
      int v23 = 5 * v10 + *(_DWORD *)(a1 + 248);
    }
    else {
      int v23 = v10;
    }
  }
  if (v23 <= 128)
  {
    int v24 = (char *)(a1 + 264);
    *(void *)(a1 + 224) = a1 + 264;
    if (v22) {
      goto LABEL_44;
    }
LABEL_47:
    if ((a4 & 4) != 0)
    {
      v24 += 4 * (int)v10;
      *(void *)(a1 + 240) = &v24[(int)v10];
    }
    *(void *)(a1 + 232) = v24;
    uint64_t v60 = v24;
    unsigned int v26 = v24;
    goto LABEL_50;
  }
  int v27 = (char *)uprv_malloc(v23);
  char *v56 = v27;
  if (!v27)
  {
LABEL_127:
    *(_DWORD *)(a1 + 252) = 0;
    *(_DWORD *)(a1 + 256) = 0;
    return a1;
  }
  int v24 = v27;
  if (!*(unsigned char *)(a1 + 260)) {
    goto LABEL_47;
  }
LABEL_44:
  unsigned int v25 = &v24[4 * (int)v10];
  int v24 = &v25[(int)v10];
  uint64_t v60 = &v24[(int)v10];
  unsigned int v26 = &v60[(int)v10];
  *(void *)(a1 + 232) = v25;
  *(void *)(a1 + 240) = &v26[(int)v10];
LABEL_50:
  uint64_t v28 = 0;
  int v61 = 0;
  uint64_t v58 = v10;
  uint64_t v59 = v24;
  long long v57 = v26;
  while (2)
  {
    uint64_t v29 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v28);
    unsigned int v30 = *(unsigned __int16 *)(v29 + 8);
    if ((v30 & 0x11) == 0)
    {
      if ((v30 & 2) != 0)
      {
        BOOL v31 = (UChar *)(v29 + 10);
        if ((v30 & 0x8000) != 0) {
          goto LABEL_58;
        }
      }
      else
      {
        BOOL v31 = *(UChar **)(v29 + 24);
        if ((v30 & 0x8000) != 0) {
          goto LABEL_58;
        }
      }
      goto LABEL_56;
    }
    BOOL v31 = 0;
    if ((v30 & 0x8000) == 0)
    {
LABEL_56:
      uint64_t v32 = v30 >> 5;
      goto LABEL_59;
    }
LABEL_58:
    uint64_t v32 = *(unsigned int *)(v29 + 12);
LABEL_59:
    int v33 = icu::UnicodeSet::span(v8, v31, v32, 1);
    if ((int)v32 < 1 || v33 >= (int)v32)
    {
      if ((a4 & 4) != 0)
      {
        if ((a4 & 2) != 0)
        {
          int v37 = (char *)(*(void *)(a1 + 240) + v61);
          int32_t v38 = *(_DWORD *)(a1 + 248) - v61;
          *(void *)UErrorCode pErrorCode = 0;
          u_strToUTF8(v37, v38, (int32_t *)pErrorCode, v31, v32, &pErrorCode[1]);
          if (pErrorCode[1] <= U_ZERO_ERROR) {
            UErrorCode v39 = pErrorCode[0];
          }
          else {
            UErrorCode v39 = U_ZERO_ERROR;
          }
          *(_DWORD *)(*(void *)(a1 + 224) + 4 * v28) = v39;
          v61 += v39;
        }
        else
        {
          *(_DWORD *)&(*v56)[4 * v28] = 0;
        }
      }
      if (*(unsigned char *)(a1 + 260))
      {
        v26[v28] = -1;
        v60[v28] = -1;
        v24[v28] = -1;
      }
      *(unsigned char *)(*(void *)(a1 + 232) + v28) = -1;
      goto LABEL_114;
    }
    if ((a4 & 8) != 0)
    {
      if ((a4 & 2) == 0)
      {
        LOBYTE(v35) = 0;
        v24[v28] = 0;
        int v36 = *(char **)(a1 + 232);
        goto LABEL_85;
      }
      if ((a4 & 0x20) != 0)
      {
        if (v33 >= 254) {
          char v40 = -2;
        }
        else {
          char v40 = v33;
        }
        *(unsigned char *)(*(void *)(a1 + 232) + v28) = v40;
      }
      if ((a4 & 0x10) != 0)
      {
        int v35 = v32 - icu::UnicodeSet::spanBack(v8, v31, v32, 1);
        if (v35 >= 254) {
          LOBYTE(v35) = -2;
        }
        int v36 = v24;
LABEL_85:
        v36[v28] = v35;
      }
    }
    if ((a4 & 4) != 0)
    {
      long long v41 = (char *)(*(void *)(a1 + 240) + v61);
      int32_t v42 = *(_DWORD *)(a1 + 248) - v61;
      *(void *)UErrorCode pErrorCode = 0;
      u_strToUTF8(v41, v42, (int32_t *)pErrorCode, v31, v32, &pErrorCode[1]);
      if (pErrorCode[1] <= U_ZERO_ERROR) {
        size_t v43 = pErrorCode[0];
      }
      else {
        size_t v43 = 0;
      }
      *(_DWORD *)(*(void *)(a1 + 224) + 4 * v28) = v43;
      v61 += v43;
      if (v43)
      {
        if ((a4 & 2) == 0)
        {
          LOBYTE(v44) = 0;
          unsigned int v26 = v57;
          v57[v28] = 0;
          goto LABEL_94;
        }
        if ((a4 & 0x20) != 0)
        {
          int v53 = icu::UnicodeSet::spanUTF8(v8, v41, v43, 1);
          if (v53 >= 254) {
            char v54 = -2;
          }
          else {
            char v54 = v53;
          }
          v60[v28] = v54;
        }
        if ((a4 & 0x10) == 0)
        {
          uint64_t v10 = v58;
          int v24 = v59;
          unsigned int v26 = v57;
          if ((a4 & 1) == 0) {
            goto LABEL_114;
          }
          goto LABEL_97;
        }
        int v44 = v43 - icu::UnicodeSet::spanBackUTF8(v8, (uint8_t *)v41, v43, 1);
        if (v44 >= 254) {
          LOBYTE(v44) = -2;
        }
        unsigned int v26 = v57;
        long long v45 = v57;
      }
      else
      {
        LOBYTE(v44) = -1;
        unsigned int v26 = v57;
        v57[v28] = -1;
LABEL_94:
        long long v45 = v60;
      }
      uint64_t v10 = v58;
      int v24 = v59;
      v45[v28] = v44;
    }
    if ((a4 & 1) == 0) {
      goto LABEL_114;
    }
LABEL_97:
    if ((a4 & 0x20) != 0)
    {
      unsigned int v46 = *v31;
      BOOL v47 = v32 != 1 && (v46 & 0xFC00) == 55296;
      if (v47)
      {
        int v48 = v31[1];
        BOOL v47 = (v48 & 0xFC00) == 56320;
        unsigned int v49 = (v46 << 10) - 56613888 + v48;
        if (v47) {
          unsigned int v46 = v49;
        }
      }
      sub_18C899520(a1, v46);
    }
    if ((a4 & 0x10) != 0)
    {
      unsigned int v50 = v31[(v32 - 1)];
      if (v32 >= 2 && (v50 & 0xFC00) == 0xDC00)
      {
        int v51 = v31[(v32 - 2)];
        BOOL v47 = (v51 & 0xFC00) == 55296;
        int v52 = v50 - 56613888 + (v51 << 10);
        if (v47) {
          unsigned int v50 = v52;
        }
      }
      sub_18C899520(a1, v50);
    }
LABEL_114:
    if (v10 != ++v28) {
      continue;
    }
    break;
  }
  if (*(unsigned char *)(a1 + 260)) {
    icu::UnicodeSet::freeze(*(icu::UnicodeSet **)(a1 + 208));
  }
  return a1;
}

icu::UnicodeSet *sub_18C899520(uint64_t a1, unsigned int a2)
{
  BOOL result = *(icu::UnicodeSet **)(a1 + 208);
  if (result) {
    BOOL v5 = result == (icu::UnicodeSet *)(a1 + 8);
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    BOOL result = (icu::UnicodeSet *)icu::UnicodeSet::contains((icu::UnicodeSet *)(a1 + 8), a2);
    if (result) {
      return result;
    }
    BOOL result = icu::UnicodeSet::cloneAsThawed((icu::UnicodeSet *)(a1 + 8), v6, v7);
    if (!result) {
      return result;
    }
    *(void *)(a1 + 208) = result;
  }

  return icu::UnicodeSet::add(result, a2);
}

uint64_t sub_18C8995A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (uint64_t *)(a2 + 8);
  BOOL v7 = (icu::UnicodeSet *)icu::UnicodeSet::UnicodeSet((icu::UnicodeSet *)(a1 + 8), (const icu::UnicodeSet *)(a2 + 8));
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = a3;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  uint64_t v9 = *(void *)(a2 + 248);
  *(void *)(a1 + 248) = v9;
  *(_DWORD *)(a1 + 256) = *(_DWORD *)(a2 + 256);
  *(unsigned char *)(a1 + 260) = 1;
  uint64_t v10 = *(uint64_t **)(a2 + 208);
  if (v10 == v6)
  {
    int v11 = v9;
  }
  else
  {
    BOOL v7 = icu::UnicodeSet::clone(*(icu::UnicodeSet **)(a2 + 208), v8, v10);
    a3 = *(void *)(a1 + 216);
    int v11 = *(_DWORD *)(a1 + 248);
  }
  *(void *)(a1 + 208) = v7;
  uint64_t v12 = *(int *)(a3 + 8);
  size_t v13 = 8 * v12 + v11;
  if ((int)v13 > 128)
  {
    unsigned int v14 = (char *)uprv_malloc(v13);
    *(void *)(a1 + 224) = v14;
    if (!v14)
    {
      *(_DWORD *)(a1 + 252) = 0;
      *(_DWORD *)(a1 + 256) = 0;
      return a1;
    }
  }
  else
  {
    unsigned int v14 = (char *)(a1 + 264);
    *(void *)(a1 + 224) = a1 + 264;
  }
  BOOL v15 = &v14[4 * v12];
  *(void *)(a1 + 232) = v15;
  *(void *)(a1 + 240) = &v15[4 * (int)v12];
  memcpy(v14, *(const void **)(a2 + 224), v13);
  return a1;
}

void *sub_18C89969C(void *a1)
{
  uint64_t v2 = (icu::UnicodeSet *)a1[26];
  if (v2) {
    BOOL v3 = v2 == (icu::UnicodeSet *)(a1 + 1);
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    icu::UnicodeSet::~UnicodeSet(v2);
    icu::UMemory::operator delete(v4);
  }
  BOOL v5 = (void *)a1[28];
  if (v5) {
    BOOL v6 = v5 == a1 + 33;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    uprv_free(v5);
  }
  icu::UnicodeSet::~UnicodeSet((icu::UnicodeSet *)(a1 + 1));
  return a1;
}

uint64_t sub_18C899700(uint64_t a1, UChar *s, uint64_t a3, int a4)
{
  uint64_t v4 = a3;
  v70[3] = *MEMORY[0x1E4F143B8];
  if (!a4)
  {
    return sub_18C899D58(a1, (uint64_t)s, a3);
  }
  int v7 = a4;
  long long v64 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v8 = icu::UnicodeSet::span((icu::UnicodeSet *)(a1 + 8), s);
  int v9 = v4 - v8;
  if (v4 == v8) {
    return v4;
  }
  uint64_t v10 = v8;
  memset(v70, 0, 24);
  uint64_t v68 = (char *)v70 + 4;
  uint64_t v69 = 0;
  if (v7 == 1)
  {
    int v11 = *(_DWORD *)(a1 + 252);
    if (v11 > 16)
    {
      uint64_t v12 = (char *)uprv_malloc(*(unsigned int *)(a1 + 252));
      if (v12)
      {
        uint64_t v68 = v12;
        LODWORD(v69) = v11;
      }
      else
      {
        int v11 = v69;
        uint64_t v12 = (char *)v68;
      }
    }
    else
    {
      int v11 = 16;
      LODWORD(v69) = 16;
      uint64_t v12 = (char *)v70 + 4;
    }
    bzero(v12, v11);
  }
  uint64_t v63 = v4;
  uint64_t v67 = (int)v4;
  uint64_t v14 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  int v15 = v10;
  int v65 = v7;
  while (1)
  {
    if (v7 == 1)
    {
      if ((int)v14 >= 1)
      {
        uint64_t v16 = 0;
        while (1)
        {
          LODWORD(v17) = *(unsigned __int8 *)(*(void *)(a1 + 232) + v16);
          if (v17 != 255) {
            break;
          }
LABEL_37:
          if (++v16 == v14) {
            goto LABEL_101;
          }
        }
        uint64_t v18 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v16);
        unsigned int v19 = *(unsigned __int16 *)(v18 + 8);
        if ((v19 & 0x11) != 0)
        {
          BOOL v20 = 0;
          if ((v19 & 0x8000) != 0) {
            goto LABEL_25;
          }
LABEL_23:
          int v21 = v19 >> 5;
LABEL_26:
          if (v17 == 254)
          {
            uint64_t v17 = v21 - 1;
            BOOL v22 = (v20[v17] & 0xFC00) != 0xDC00 || v21 < 2;
            if (!v22 && (v20[v21 - 2] & 0xFC00) == 0xD800) {
              LODWORD(v17) = v21 - 2;
            }
          }
          if ((int)v17 >= v15) {
            LODWORD(v23) = v15;
          }
          else {
            LODWORD(v23) = v17;
          }
          int v24 = v21 - v23;
          if (v21 - (int)v23 <= v9)
          {
            uint64_t v25 = v21;
            uint64_t v26 = v21 - 1;
            uint64_t v23 = (int)v23;
            uint64_t v27 = v67 - v21;
            int v28 = v21 + 1;
            do
            {
              int v29 = v69;
              if (LODWORD(v70[0]) + v24 < (int)v69) {
                int v29 = 0;
              }
              int v30 = LODWORD(v70[0]) + v24 - v29;
              if (!*((unsigned char *)v68 + v30))
              {
                uint64_t v32 = (int)v10 - v23;
                int v33 = &s[v32];
                int v34 = v28;
                int v35 = v33;
                int v36 = v20;
                while (*v35 == *v36)
                {
                  ++v36;
                  ++v35;
                  if (--v34 <= 1)
                  {
                    if ((v32 < 1 || (*(v33 - 1) & 0xFC00) != 0xD800 || (*v33 & 0xFC00) != 0xDC00)
                      && (v32 >= v27 || (v33[v26] & 0xFC00) != 0xD800 || (v33[v25] & 0xFC00) != 0xDC00))
                    {
                      if (v24 == v9) {
                        goto LABEL_123;
                      }
                      *((unsigned char *)v68 + v30) = 1;
                      ++HIDWORD(v69);
                    }
                    break;
                  }
                }
              }
              if (!v23) {
                break;
              }
              --v23;
            }
            while (v24++ != v9);
          }
          goto LABEL_37;
        }
        if ((v19 & 2) != 0)
        {
          BOOL v20 = (unsigned __int16 *)(v18 + 10);
          if ((v19 & 0x8000) == 0) {
            goto LABEL_23;
          }
        }
        else
        {
          BOOL v20 = *(unsigned __int16 **)(v18 + 24);
          if ((v19 & 0x8000) == 0) {
            goto LABEL_23;
          }
        }
LABEL_25:
        int v21 = *(_DWORD *)(v18 + 12);
        goto LABEL_26;
      }
      goto LABEL_101;
    }
    uint64_t v66 = v10;
    if ((int)v14 >= 1)
    {
      uint64_t v37 = 0;
      int v38 = 0;
      uint64_t v39 = 0;
      while (1)
      {
        unsigned int v40 = *(unsigned __int8 *)(*(void *)(a1 + 232) + v37);
        uint64_t v41 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v37);
        unsigned int v42 = *(unsigned __int16 *)(v41 + 8);
        if ((v42 & 0x11) != 0)
        {
          size_t v43 = 0;
          if ((v42 & 0x8000) == 0) {
            goto LABEL_65;
          }
        }
        else if ((v42 & 2) != 0)
        {
          size_t v43 = (unsigned __int16 *)(v41 + 10);
          if ((v42 & 0x8000) == 0)
          {
LABEL_65:
            unsigned int v44 = v42 >> 5;
            if (v42 >> 5) {
              goto LABEL_69;
            }
            goto LABEL_93;
          }
        }
        else
        {
          size_t v43 = *(unsigned __int16 **)(v41 + 24);
          if ((v42 & 0x8000) == 0) {
            goto LABEL_65;
          }
        }
        unsigned int v44 = *(_DWORD *)(v41 + 12);
        if (v44)
        {
LABEL_69:
          if (v40 <= 0xFD) {
            LODWORD(v45) = v40;
          }
          else {
            LODWORD(v45) = v44;
          }
          if ((int)v45 >= v15) {
            LODWORD(v45) = v15;
          }
          uint64_t v46 = v44 - v45;
          if ((int)v46 <= v9 && (int)v45 >= v38)
          {
            uint64_t v48 = (int)v44;
            uint64_t v49 = (int)v44 - 1;
            uint64_t v45 = (int)v45;
            uint64_t v50 = v67 - (int)v44;
            unsigned int v51 = v44 + 1;
            do
            {
              if (v45 > v38 || (int)v46 > (int)v39)
              {
                uint64_t v52 = (int)v66 - v45;
                int v53 = &s[v52];
                unsigned int v54 = v51;
                long long v55 = v53;
                long long v56 = v43;
                while (*v55 == *v56)
                {
                  ++v56;
                  ++v55;
                  if ((int)--v54 <= 1)
                  {
                    if ((v52 < 1 || (*(v53 - 1) & 0xFC00) != 0xD800 || (*v53 & 0xFC00) != 0xDC00)
                      && (v52 >= v50 || (v53[v49] & 0xFC00) != 0xD800 || (v53[v48] & 0xFC00) != 0xDC00))
                    {
                      int v38 = v45;
                      goto LABEL_94;
                    }
                    break;
                  }
                }
              }
              if ((int)v46 >= v9) {
                break;
              }
              uint64_t v46 = (v46 + 1);
              BOOL v22 = v45-- <= v38;
            }
            while (!v22);
          }
        }
LABEL_93:
        uint64_t v46 = v39;
LABEL_94:
        ++v37;
        uint64_t v39 = v46;
        if (v37 == v14) {
          goto LABEL_98;
        }
      }
    }
    LODWORD(v46) = 0;
    int v38 = 0;
LABEL_98:
    int v57 = v46 | v38;
    int v7 = v65;
    uint64_t v10 = v66;
    if (v57)
    {
      v9 -= v46;
      if (!v9) {
        goto LABEL_123;
      }
      int v15 = 0;
      goto LABEL_122;
    }
LABEL_101:
    if (v15 || !v10)
    {
      if (!HIDWORD(v69))
      {
        uint64_t v4 = v10;
        goto LABEL_124;
      }
LABEL_110:
      LODWORD(v46) = sub_18C899F70((unsigned __int8 **)&v68);
      int v15 = 0;
      v9 -= v46;
      goto LABEL_122;
    }
    uint64_t v58 = &s[(int)v10];
    if (HIDWORD(v69)) {
      break;
    }
    LODWORD(v46) = icu::UnicodeSet::span(v64, &s[(int)v10]);
    v9 -= v46;
    if (!v9 || !v46)
    {
      uint64_t v4 = (v46 + v10);
      goto LABEL_124;
    }
    int v15 = v46;
LABEL_122:
    uint64_t v10 = (v46 + v10);
  }
  int v59 = *v58;
  if (v9 >= 2 && (v59 & 0xFC00) == 0xD800 && (int v60 = v58[1], (v60 & 0xFC00) == 0xDC00))
  {
    if (!icu::UnicodeSet::contains(v64, v60 + (v59 << 10) - 56613888)) {
      goto LABEL_110;
    }
    LODWORD(v46) = 2;
  }
  else
  {
    if (!icu::UnicodeSet::contains(v64, v59)) {
      goto LABEL_110;
    }
    LODWORD(v46) = 1;
  }
  v9 -= v46;
  if (v9)
  {
    int v61 = v69;
    if (LODWORD(v70[0]) + (int)v46 < (int)v69) {
      int v61 = 0;
    }
    int v62 = LODWORD(v70[0]) + v46 - v61;
    if (*((unsigned char *)v68 + v62))
    {
      *((unsigned char *)v68 + v62) = 0;
      --HIDWORD(v69);
    }
    int v15 = 0;
    LODWORD(v70[0]) = v62;
    goto LABEL_122;
  }
LABEL_123:
  uint64_t v4 = v63;
LABEL_124:
  if (v68 != (char *)v70 + 4) {
    uprv_free(v68);
  }
  return v4;
}

uint64_t sub_18C899D58(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v3 = a3;
  int v6 = 0;
  uint64_t v7 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  uint64_t v25 = (icu::UnicodeSet *)(a1 + 8);
  while (1)
  {
    int v8 = icu::UnicodeSet::span(*(icu::UnicodeSet **)(a1 + 208), (UChar *)(a2 + 2 * v6));
    int v9 = v3 - v8;
    if (v3 == v8) {
      return a3;
    }
    uint64_t v10 = (v8 + v6);
    int v11 = (unsigned __int16 *)(a2 + 2 * (int)v10);
    int v12 = *v11;
    if (v9 < 2 || (v12 & 0xFC00) != 55296) {
      break;
    }
    int v14 = v11[1];
    if ((v14 & 0xFC00) != 0xDC00) {
      break;
    }
    if (icu::UnicodeSet::contains(v25, v14 + (v12 << 10) - 56613888)) {
      return v10;
    }
    int v15 = -2;
LABEL_13:
    if ((int)v7 >= 1)
    {
      uint64_t v16 = 0;
      while (*(unsigned __int8 *)(*(void *)(a1 + 232) + v16) == 255)
      {
LABEL_34:
        if (++v16 == v7) {
          goto LABEL_35;
        }
      }
      uint64_t v17 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v16);
      unsigned int v18 = *(unsigned __int16 *)(v17 + 8);
      if ((v18 & 0x11) != 0)
      {
        unsigned int v19 = 0;
        if ((v18 & 0x8000) != 0)
        {
LABEL_23:
          int v20 = *(_DWORD *)(v17 + 12);
LABEL_24:
          if (v20 <= v9)
          {
            int v21 = v20 + 1;
            BOOL v22 = (unsigned __int16 *)(a2 + 2 * (int)v10);
            while (*v22 == *v19)
            {
              ++v19;
              ++v22;
              if (--v21 <= 1)
              {
                if (((int)v10 < 1 || (*(v11 - 1) & 0xFC00) != 0xD800 || (*v11 & 0xFC00) != 0xDC00)
                  && ((int)(a3 - v10) <= v20 || (v11[v20 - 1] & 0xFC00) != 0xD800 || (v11[v20] & 0xFC00) != 0xDC00))
                {
                  return v10;
                }
                goto LABEL_34;
              }
            }
          }
          goto LABEL_34;
        }
      }
      else if ((v18 & 2) != 0)
      {
        unsigned int v19 = (unsigned __int16 *)(v17 + 10);
        if ((v18 & 0x8000) != 0) {
          goto LABEL_23;
        }
      }
      else
      {
        unsigned int v19 = *(unsigned __int16 **)(v17 + 24);
        if ((v18 & 0x8000) != 0) {
          goto LABEL_23;
        }
      }
      int v20 = v18 >> 5;
      goto LABEL_24;
    }
LABEL_35:
    int v6 = v10 - v15;
    int v3 = v15 + v9;
    if (!(v15 + v9)) {
      return a3;
    }
  }
  if (!icu::UnicodeSet::contains(v25, v12))
  {
    int v15 = -1;
    goto LABEL_13;
  }
  return v10;
}

uint64_t sub_18C899F70(unsigned __int8 **a1)
{
  int v1 = *((_DWORD *)a1 + 4);
  uint64_t v2 = *((int *)a1 + 2);
  int v3 = *a1;
  uint64_t v4 = v1;
  while (1)
  {
    uint64_t v5 = v4 + 1;
    if (v4 + 1 >= v2) {
      break;
    }
    if (v3[++v4])
    {
      v3[v5] = 0;
      uint64_t v7 = (v5 - *((_DWORD *)a1 + 4));
      --*((_DWORD *)a1 + 3);
      *((_DWORD *)a1 + 4) = v5;
      return v7;
    }
  }
  int v8 = -1;
  do
  {
    int v9 = *v3++;
    ++v8;
  }
  while (!v9);
  *(v3 - 1) = 0;
  --*((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 4) = v8;
  return (v2 - v1 + v8);
}

uint64_t sub_18C899FE4(uint64_t a1, UChar *s, int a3, int a4)
{
  v70[3] = *MEMORY[0x1E4F143B8];
  if (!a4)
  {
    return sub_18C89A650(a1, s, a3);
  }
  long long v64 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v7 = icu::UnicodeSet::spanBack((icu::UnicodeSet *)(a1 + 8), s);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  int v9 = a3 - v7;
  memset(v70, 0, 24);
  uint64_t v68 = (char *)v70 + 4;
  uint64_t v69 = 0;
  if (a4 == 1)
  {
    int v10 = *(_DWORD *)(a1 + 252);
    if (v10 > 16)
    {
      int v11 = (char *)uprv_malloc(*(unsigned int *)(a1 + 252));
      if (v11)
      {
        uint64_t v68 = v11;
        LODWORD(v69) = v10;
      }
      else
      {
        int v10 = v69;
        int v11 = (char *)v68;
      }
    }
    else
    {
      int v10 = 16;
      LODWORD(v69) = 16;
      int v11 = (char *)v70 + 4;
    }
    bzero(v11, v10);
  }
  uint64_t v14 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  if (*(unsigned char *)(a1 + 260)) {
    uint64_t v15 = (int)v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v67 = a1;
  uint64_t v16 = *(void *)(a1 + 232) + v15;
  while (1)
  {
    while (a4 != 1)
    {
      if ((int)v14 >= 1)
      {
        uint64_t v38 = 0;
        uint64_t v39 = 0;
        int v66 = 0;
        while (1)
        {
          unsigned int v40 = *(unsigned __int8 *)(v16 + v38);
          uint64_t v41 = icu::UVector::elementAt(*(icu::UVector **)(v67 + 216), v38);
          unsigned int v42 = *(unsigned __int16 *)(v41 + 8);
          if ((v42 & 0x11) != 0)
          {
            size_t v43 = 0;
            if ((v42 & 0x8000) == 0) {
              goto LABEL_68;
            }
          }
          else if ((v42 & 2) != 0)
          {
            size_t v43 = (unsigned __int16 *)(v41 + 10);
            if ((v42 & 0x8000) == 0)
            {
LABEL_68:
              unsigned int v44 = v42 >> 5;
              if (v42 >> 5) {
                goto LABEL_72;
              }
              goto LABEL_97;
            }
          }
          else
          {
            size_t v43 = *(unsigned __int16 **)(v41 + 24);
            if ((v42 & 0x8000) == 0) {
              goto LABEL_68;
            }
          }
          unsigned int v44 = *(_DWORD *)(v41 + 12);
          if (v44)
          {
LABEL_72:
            if (v40 <= 0xFD) {
              LODWORD(v45) = v40;
            }
            else {
              LODWORD(v45) = v44;
            }
            if ((int)v45 >= v9) {
              uint64_t v45 = v9;
            }
            else {
              uint64_t v45 = v45;
            }
            LODWORD(v46) = v44 - v45;
            BOOL v47 = (int)(v44 - v45) > (int)v8 || (int)v45 < (int)v39;
            if (!v47)
            {
              uint64_t v48 = (int)v44;
              uint64_t v49 = (int)v44 - 1;
              uint64_t v46 = (int)v46;
              uint64_t v50 = a3 - (uint64_t)(int)v44;
              unsigned int v51 = v44 + 1;
              do
              {
                if ((int)v45 > (int)v39 || v46 > v66)
                {
                  uint64_t v52 = (int)v8 - v46;
                  int v53 = &s[v52];
                  unsigned int v54 = v51;
                  long long v55 = v53;
                  long long v56 = v43;
                  while (*v55 == *v56)
                  {
                    ++v56;
                    ++v55;
                    if ((int)--v54 <= 1)
                    {
                      if ((v52 < 1 || (*(v53 - 1) & 0xFC00) != 0xD800 || (*v53 & 0xFC00) != 0xDC00)
                        && (v52 >= v50 || (v53[v49] & 0xFC00) != 0xD800 || (v53[v48] & 0xFC00) != 0xDC00))
                      {
                        int v66 = v46;
                        goto LABEL_98;
                      }
                      break;
                    }
                  }
                }
                if ((int)v8 <= v46) {
                  break;
                }
                ++v46;
                BOOL v47 = (int)v45 <= (int)v39;
                uint64_t v45 = (v45 - 1);
              }
              while (!v47);
            }
          }
LABEL_97:
          uint64_t v45 = v39;
LABEL_98:
          ++v38;
          uint64_t v39 = v45;
          if (v38 == v14) {
            goto LABEL_102;
          }
        }
      }
      int v66 = 0;
      LODWORD(v45) = 0;
LABEL_102:
      if (!(v66 | v45)) {
        goto LABEL_105;
      }
      int v9 = 0;
      uint64_t v13 = 0;
      uint64_t v8 = (v8 - v66);
      if (!v8) {
        goto LABEL_133;
      }
    }
    if ((int)v14 >= 1)
    {
      uint64_t v17 = 0;
      while (1)
      {
        int v18 = *(unsigned __int8 *)(v16 + v17);
        if (v18 != 255) {
          break;
        }
LABEL_41:
        if (++v17 == v14) {
          goto LABEL_105;
        }
      }
      uint64_t v19 = icu::UVector::elementAt(*(icu::UVector **)(v67 + 216), v17);
      unsigned int v20 = *(unsigned __int16 *)(v19 + 8);
      if ((v20 & 0x11) != 0)
      {
        int v21 = 0;
        if ((v20 & 0x8000) != 0) {
          goto LABEL_29;
        }
LABEL_27:
        unsigned int v22 = v20 >> 5;
        goto LABEL_30;
      }
      if ((v20 & 2) != 0)
      {
        int v21 = (unsigned __int16 *)(v19 + 10);
        if ((v20 & 0x8000) == 0) {
          goto LABEL_27;
        }
      }
      else
      {
        int v21 = *(unsigned __int16 **)(v19 + 24);
        if ((v20 & 0x8000) == 0) {
          goto LABEL_27;
        }
      }
LABEL_29:
      unsigned int v22 = *(_DWORD *)(v19 + 12);
LABEL_30:
      if (v18 == 254)
      {
        int v23 = -1;
        if ((*v21 & 0xFC00) == 0xD800 && v22 != 1)
        {
          if ((v21[1] & 0xFC00) == 0xDC00) {
            int v23 = -2;
          }
          else {
            int v23 = -1;
          }
        }
        int v18 = v23 + v22;
      }
      if (v18 >= v9) {
        int v24 = v9;
      }
      else {
        int v24 = v18;
      }
      LODWORD(v25) = v22 - v24;
      if ((int)(v22 - v24) <= (int)v8)
      {
        uint64_t v26 = (int)v22;
        uint64_t v27 = (int)v22 - 1;
        uint64_t v25 = (int)v25;
        uint64_t v28 = a3 - (uint64_t)(int)v22;
        unsigned int v29 = v22 + 1;
        do
        {
          int v30 = v69;
          if (LODWORD(v70[0]) + (int)v25 < (int)v69) {
            int v30 = 0;
          }
          int v31 = LODWORD(v70[0]) + v25 - v30;
          uint64_t v32 = (char *)v68;
          if (!*((unsigned char *)v68 + v31))
          {
            uint64_t v33 = (int)v8 - v25;
            int v34 = &s[v33];
            unsigned int v35 = v29;
            int v36 = v34;
            uint64_t v37 = v21;
            while (*v36 == *v37)
            {
              ++v37;
              ++v36;
              if ((int)--v35 <= 1)
              {
                if (v33 >= 1 && (*(v34 - 1) & 0xFC00) == 0xD800 && (*v34 & 0xFC00) == 0xDC00
                  || v33 < v28 && (v34[v27] & 0xFC00) == 0xD800 && (v34[v26] & 0xFC00) == 0xDC00)
                {
                  break;
                }
                if (v8 != v25)
                {
                  *((unsigned char *)v68 + v31) = 1;
                  ++HIDWORD(v69);
                  break;
                }
                uint64_t v13 = 0;
                goto LABEL_128;
              }
            }
          }
          if (!v24) {
            break;
          }
          --v24;
          ++v25;
        }
        while (v8 + 1 != v25);
      }
      goto LABEL_41;
    }
LABEL_105:
    if (v9 || v8 == a3) {
      break;
    }
    if (HIDWORD(v69))
    {
      int v57 = s[(int)v8 - 1];
      if ((int)v8 >= 2 && (v57 & 0xFC00) == 0xDC00 && (int v58 = s[(v8 - 2)], (v58 & 0xFC00) == 0xD800))
      {
        if (icu::UnicodeSet::contains(v64, v57 + (v58 << 10) - 56613888))
        {
          int v59 = 2;
          goto LABEL_117;
        }
LABEL_114:
        int v9 = 0;
        uint64_t v8 = v8 - sub_18C899F70((unsigned __int8 **)&v68);
      }
      else
      {
        if (!icu::UnicodeSet::contains(v64, v57)) {
          goto LABEL_114;
        }
        int v59 = 1;
LABEL_117:
        uint64_t v8 = (v8 - v59);
        if (!v8)
        {
          uint64_t v13 = 0;
          goto LABEL_133;
        }
        int v60 = LODWORD(v70[0]) + v59;
        if (v60 >= (int)v69) {
          int v61 = v69;
        }
        else {
          int v61 = 0;
        }
        int v62 = v60 - v61;
        if (*((unsigned char *)v68 + v62))
        {
          *((unsigned char *)v68 + v62) = 0;
          --HIDWORD(v69);
        }
        int v9 = 0;
        LODWORD(v70[0]) = v62;
      }
    }
    else
    {
      uint64_t v63 = icu::UnicodeSet::spanBack(v64, s);
      uint64_t v13 = v63;
      if (!v63) {
        goto LABEL_133;
      }
      int v9 = v8 - v63;
      uint64_t v8 = v63;
      if (!v9) {
        goto LABEL_133;
      }
    }
  }
  if (HIDWORD(v69)) {
    goto LABEL_114;
  }
  uint64_t v13 = v8;
LABEL_133:
  uint64_t v32 = (char *)v68;
LABEL_128:
  if (v32 != (char *)v70 + 4) {
    uprv_free(v32);
  }
  return v13;
}

uint64_t sub_18C89A650(uint64_t a1, UChar *s, int a3)
{
  int v23 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  do
  {
    uint64_t v7 = icu::UnicodeSet::spanBack(*(icu::UnicodeSet **)(a1 + 208), s);
    uint64_t v8 = v7;
    if (!v7) {
      return v8;
    }
    int v9 = s[(int)v7 - 1];
    BOOL v10 = (int)v7 >= 2 && (v9 & 0xFC00) == 56320;
    if (v10 && (int v11 = s[(v7 - 2)], (v11 & 0xFC00) == 0xD800))
    {
      if (icu::UnicodeSet::contains(v23, v9 + (v11 << 10) - 56613888)) {
        return v8;
      }
      int v12 = -2;
    }
    else
    {
      if (icu::UnicodeSet::contains(v23, v9)) {
        return v8;
      }
      int v12 = -1;
    }
    if ((int)v6 >= 1)
    {
      uint64_t v13 = 0;
      while (*(unsigned __int8 *)(*(void *)(a1 + 232) + v13) == 255)
      {
LABEL_34:
        if (++v13 == v6) {
          goto LABEL_35;
        }
      }
      uint64_t v14 = icu::UVector::elementAt(*(icu::UVector **)(a1 + 216), v13);
      unsigned int v15 = *(unsigned __int16 *)(v14 + 8);
      if ((v15 & 0x11) != 0)
      {
        uint64_t v16 = 0;
        if ((v15 & 0x8000) != 0) {
          goto LABEL_23;
        }
LABEL_21:
        int v17 = v15 >> 5;
        goto LABEL_24;
      }
      if ((v15 & 2) != 0)
      {
        uint64_t v16 = (unsigned __int16 *)(v14 + 10);
        if ((v15 & 0x8000) == 0) {
          goto LABEL_21;
        }
      }
      else
      {
        uint64_t v16 = *(unsigned __int16 **)(v14 + 24);
        if ((v15 & 0x8000) == 0) {
          goto LABEL_21;
        }
      }
LABEL_23:
      int v17 = *(_DWORD *)(v14 + 12);
LABEL_24:
      int v18 = v8 - v17;
      if ((int)v8 >= v17)
      {
        uint64_t v19 = &s[v18];
        int v20 = v17 + 1;
        int v21 = v19;
        while (*v21 == *v16)
        {
          ++v16;
          ++v21;
          if (--v20 <= 1)
          {
            if ((v18 < 1 || (*(v19 - 1) & 0xFC00) != 0xD800 || (*v19 & 0xFC00) != 0xDC00)
              && (a3 - v18 <= v17 || (v19[v17 - 1] & 0xFC00) != 0xD800 || (v19[v17] & 0xFC00) != 0xDC00))
            {
              return v8;
            }
            goto LABEL_34;
          }
        }
      }
      goto LABEL_34;
    }
LABEL_35:
    ;
  }
  while (v12 + v8);
  return 0;
}

uint64_t sub_18C89A840(uint64_t a1, char *__s, uint64_t a3, int a4)
{
  uint64_t i = a3;
  v51[3] = *MEMORY[0x1E4F143B8];
  if (!a4)
  {
    return sub_18C89AD0C(a1, (uint64_t)__s, a3);
  }
  uint64_t v45 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v6 = icu::UnicodeSet::spanUTF8((icu::UnicodeSet *)(a1 + 8), __s);
  signed int v7 = i - v6;
  if (i == v6) {
    return i;
  }
  uint64_t v8 = v6;
  memset(v51, 0, 24);
  uint64_t v49 = (char *)v51 + 4;
  uint64_t v50 = 0;
  if (a4 == 1)
  {
    int v9 = *(_DWORD *)(a1 + 256);
    if (v9 > 16)
    {
      BOOL v10 = (char *)uprv_malloc(*(unsigned int *)(a1 + 256));
      if (v10)
      {
        uint64_t v49 = v10;
        LODWORD(v50) = v9;
      }
      else
      {
        int v9 = v50;
        BOOL v10 = (char *)v49;
      }
    }
    else
    {
      int v9 = 16;
      LODWORD(v50) = 16;
      BOOL v10 = (char *)v51 + 4;
    }
    bzero(v10, v9);
  }
  unsigned int v44 = i;
  uint64_t v12 = a1;
  uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  uint64_t v14 = 2 * (int)v13;
  if (!*(unsigned char *)(a1 + 260)) {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(void *)(a1 + 232) + v14;
  for (uint64_t i = v8; ; uint64_t i = (v32 + i))
  {
    uint64_t v16 = *(const uint8_t **)(v12 + 240);
    uint64_t v48 = i;
    if (a4 == 1) {
      break;
    }
    if ((int)v13 < 1)
    {
      LODWORD(v32) = 0;
      int v31 = 0;
    }
    else
    {
      uint64_t v30 = 0;
      int v31 = 0;
      uint64_t v32 = 0;
      do
      {
        uint64_t v33 = *(int *)(*(void *)(v12 + 224) + 4 * v30);
        if (v33)
        {
          int v34 = *(unsigned __int8 *)(v15 + v30);
          if (v34 > 0xFD) {
            int v34 = *(_DWORD *)(*(void *)(v12 + 224) + 4 * v30);
          }
          if (v34 >= (int)v8) {
            LODWORD(v35) = v8;
          }
          else {
            LODWORD(v35) = v34;
          }
          uint64_t v36 = (v33 - v35);
          BOOL v37 = (int)v36 > v7 || (int)v35 < v31;
          if (!v37)
          {
            uint64_t v35 = (int)v35;
            do
            {
              if (__s[(int)i - v35] >= -64 && (v35 > v31 || (int)v36 > (int)v32))
              {
                uint64_t v38 = &__s[(int)i - v35];
                int v39 = v33 + 1;
                unsigned int v40 = v16;
                while (*v38 == *v40)
                {
                  ++v40;
                  ++v38;
                  if (--v39 <= 1)
                  {
                    int v31 = v35;
                    goto LABEL_69;
                  }
                }
              }
              if ((int)v36 >= v7) {
                break;
              }
              uint64_t v36 = (v36 + 1);
              BOOL v37 = v35-- <= v31;
            }
            while (!v37);
          }
          uint64_t v36 = v32;
LABEL_69:
          v16 += v33;
          uint64_t v32 = v36;
        }
        ++v30;
      }
      while (v30 != v13);
    }
    if (!(v32 | v31)) {
      goto LABEL_74;
    }
    v7 -= v32;
    if (!v7)
    {
LABEL_92:
      uint64_t i = v44;
      goto LABEL_93;
    }
    LODWORD(v8) = 0;
LABEL_91:
    ;
  }
  if ((int)v13 >= 1)
  {
    uint64_t v17 = 0;
    int v18 = &__s[(int)i];
    do
    {
      uint64_t v19 = *(int *)(*(void *)(v12 + 224) + 4 * v17);
      if (v19)
      {
        int32_t v20 = *(unsigned __int8 *)(v15 + v17);
        if (v20 != 255)
        {
          if (v20 == 254)
          {
            int32_t v20 = v19 - 1;
            if ((char)v16[v19 - 1] <= -65)
            {
              int32_t v21 = utf8_back1SafeBody(v16, 0, v20);
              uint64_t v12 = a1;
              int32_t v20 = v21;
            }
          }
          LODWORD(v22) = v20 >= (int)v8 ? v8 : v20;
          int v23 = v19 - v22;
          if ((int)v19 - (int)v22 <= v7)
          {
            uint64_t v22 = (int)v22;
            do
            {
              if (__s[(int)v48 - v22] >= -64)
              {
                int v24 = v50;
                if (LODWORD(v51[0]) + v23 < (int)v50) {
                  int v24 = 0;
                }
                int v25 = LODWORD(v51[0]) + v23 - v24;
                if (!*((unsigned char *)v49 + v25))
                {
                  uint64_t v26 = &v18[-v22];
                  int v27 = v19 + 1;
                  uint64_t v28 = v16;
                  while (*v26 == *v28)
                  {
                    ++v28;
                    ++v26;
                    if (--v27 <= 1)
                    {
                      if (v23 == v7) {
                        goto LABEL_92;
                      }
                      *((unsigned char *)v49 + v25) = 1;
                      ++HIDWORD(v50);
                      break;
                    }
                  }
                }
              }
              if (!v22) {
                break;
              }
              --v22;
            }
            while (v23++ != v7);
          }
        }
        v16 += v19;
      }
      ++v17;
    }
    while (v17 != v13);
  }
LABEL_74:
  uint64_t i = v48;
  if (v8 || !v48)
  {
    if (!HIDWORD(v50)) {
      goto LABEL_93;
    }
LABEL_85:
    LODWORD(v32) = sub_18C899F70((unsigned __int8 **)&v49);
    LODWORD(v8) = 0;
    v7 -= v32;
LABEL_90:
    uint64_t v12 = a1;
    goto LABEL_91;
  }
  uint64_t v41 = (unsigned __int8 *)&__s[(int)v48];
  if (HIDWORD(v50))
  {
    LODWORD(v32) = sub_18C89AE50(v45, v41, v7);
    if ((int)v32 >= 1)
    {
      v7 -= v32;
      if (!v7) {
        goto LABEL_92;
      }
      int v42 = v50;
      if (LODWORD(v51[0]) + (int)v32 < (int)v50) {
        int v42 = 0;
      }
      int v43 = LODWORD(v51[0]) + v32 - v42;
      if (*((unsigned char *)v49 + v43))
      {
        *((unsigned char *)v49 + v43) = 0;
        --HIDWORD(v50);
      }
      LODWORD(v8) = 0;
      LODWORD(v51[0]) = v43;
      goto LABEL_90;
    }
    goto LABEL_85;
  }
  LODWORD(v32) = icu::UnicodeSet::spanUTF8(v45, (char *)v41);
  LODWORD(v8) = v32;
  v7 -= v32;
  if (v7 && v32) {
    goto LABEL_90;
  }
  uint64_t i = (v32 + v48);
LABEL_93:
  if (v49 != (char *)v51 + 4) {
    uprv_free(v49);
  }
  return i;
}

uint64_t sub_18C89AD0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  int v6 = 0;
  uint64_t v7 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  uint64_t v8 = 2 * (int)v7;
  if (!*(unsigned char *)(a1 + 260)) {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 232) + v8;
  BOOL v10 = (icu::UnicodeSet *)(a1 + 8);
  int v11 = a3;
  do
  {
    int v12 = icu::UnicodeSet::spanUTF8(*(icu::UnicodeSet **)(a1 + 208), (char *)(a2 + v6));
    signed int v13 = v11 - v12;
    if (!v13) {
      break;
    }
    uint64_t v14 = v6 + (uint64_t)v12;
    int v15 = sub_18C89AE50(v10, (unsigned __int8 *)(a2 + v14), v13);
    if (v15 > 0) {
      return v14;
    }
    if ((int)v7 >= 1)
    {
      uint64_t v16 = 0;
      uint64_t v17 = *(unsigned __int8 **)(a1 + 240);
      do
      {
        uint64_t v18 = *(int *)(*(void *)(a1 + 224) + 4 * v16);
        if (v18 && (int)v18 <= v13 && *(unsigned __int8 *)(v9 + v16) != 255)
        {
          int v19 = v18 + 1;
          int32_t v20 = (unsigned __int8 *)(a2 + v14);
          for (uint64_t i = v17; *v20 == *i; ++i)
          {
            ++v20;
            if (--v19 <= 1) {
              return v14;
            }
          }
        }
        v17 += v18;
        ++v16;
      }
      while (v16 != v7);
    }
    int v6 = v14 - v15;
    int v11 = v15 + v13;
  }
  while (v11);
  return v3;
}

uint64_t sub_18C89AE50(icu::UnicodeSet *a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3 = (char)*a2;
  unsigned int v4 = *a2;
  if ((v3 & 0x80000000) == 0)
  {
    if (icu::UnicodeSet::contains(a1, *a2)) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  unsigned int v6 = a3;
  if (a3 == 1) {
    goto LABEL_22;
  }
  if (v4 < 0xE0)
  {
    if (v4 >= 0xC2)
    {
      int v10 = v4 & 0x1F;
      unsigned int v9 = 1;
LABEL_14:
      unsigned int v11 = a2[v9] ^ 0x80;
      if (v11 > 0x3F)
      {
        int v12 = 65533;
        unsigned int v6 = v9;
      }
      else
      {
        int v12 = v11 | (v10 << 6);
        unsigned int v6 = v9 + 1;
      }
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  if (v4 <= 0xEF)
  {
    int v7 = v3 & 0xF;
    if ((a00000000000000[v3 & 0xF] >> (a2[1] >> 5)))
    {
      unsigned int v8 = a2[1] & 0x3F;
      unsigned int v9 = 2;
      goto LABEL_10;
    }
LABEL_21:
    unsigned int v6 = 1;
    goto LABEL_22;
  }
  if (v4 > 0xF4) {
    goto LABEL_21;
  }
  unsigned int v13 = v4 - 240;
  unint64_t v14 = a2[1];
  if (((byte_18CA81C73[v14 >> 4] >> v13) & 1) == 0) {
    goto LABEL_21;
  }
  if (a3 == 2) {
    goto LABEL_22;
  }
  unsigned int v8 = a2[2] ^ 0x80;
  if (v8 > 0x3F)
  {
    unsigned int v6 = 2;
    goto LABEL_22;
  }
  int v7 = v14 & 0x3F | (v13 << 6);
  unsigned int v9 = 3;
LABEL_10:
  if (v9 != a3)
  {
    int v10 = v8 | (v7 << 6);
    goto LABEL_14;
  }
LABEL_22:
  int v12 = 65533;
LABEL_23:
  if (icu::UnicodeSet::contains(a1, v12)) {
    return v6;
  }
  else {
    return -v6;
  }
}

uint64_t sub_18C89AF88(uint64_t a1, uint8_t *s, int a3, int a4)
{
  v56[3] = *MEMORY[0x1E4F143B8];
  if (!a4)
  {
    return sub_18C89B558(a1, s);
  }
  uint64_t v52 = (icu::UnicodeSet *)(a1 + 8);
  uint64_t v8 = icu::UnicodeSet::spanBackUTF8((icu::UnicodeSet *)(a1 + 8), s);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  int v10 = a3 - v8;
  memset(v56, 0, 24);
  unsigned int v54 = (char *)v56 + 4;
  uint64_t v55 = 0;
  if (a4 == 1)
  {
    int v11 = *(_DWORD *)(a1 + 256);
    if (v11 > 16)
    {
      int v12 = (char *)uprv_malloc(*(unsigned int *)(a1 + 256));
      if (v12)
      {
        unsigned int v54 = v12;
        LODWORD(v55) = v11;
      }
      else
      {
        int v11 = v55;
        int v12 = (char *)v54;
      }
    }
    else
    {
      int v11 = 16;
      LODWORD(v55) = 16;
      int v12 = (char *)v56 + 4;
    }
    bzero(v12, v11);
  }
  uint64_t v15 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  uint64_t v16 = 3 * (int)v15;
  if (!*(unsigned char *)(a1 + 260)) {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(void *)(a1 + 232) + v16;
  while (1)
  {
    while (1)
    {
      uint64_t v18 = *(unsigned __int8 **)(a1 + 240);
      if (a4 == 1) {
        break;
      }
      if ((int)v15 < 1)
      {
        int v35 = 0;
        LODWORD(v34) = 0;
      }
      else
      {
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        int v35 = 0;
        do
        {
          uint64_t v36 = *(int *)(*(void *)(a1 + 224) + 4 * v33);
          if (v36)
          {
            LODWORD(v37) = *(unsigned __int8 *)(v17 + v33);
            if (v37 > 0xFD) {
              LODWORD(v37) = *(_DWORD *)(*(void *)(a1 + 224) + 4 * v33);
            }
            if ((int)v37 >= v10) {
              uint64_t v37 = v10;
            }
            else {
              uint64_t v37 = v37;
            }
            LODWORD(v38) = v36 - v37;
            if ((int)v36 - (int)v37 <= (int)v9 && (int)v37 >= (int)v34)
            {
              uint64_t v38 = (int)v38;
              do
              {
                if ((char)s[(int)v9 - v38] >= -64 && ((int)v37 > (int)v34 || v38 > v35))
                {
                  unsigned int v40 = &s[(int)v9 - v38];
                  int v41 = v36 + 1;
                  int v42 = v18;
                  while (*v40 == *v42)
                  {
                    ++v42;
                    ++v40;
                    if (--v41 <= 1)
                    {
                      int v35 = v38;
                      goto LABEL_88;
                    }
                  }
                }
                if ((int)v9 <= v38) {
                  break;
                }
                ++v38;
                BOOL v25 = (int)v37 <= (int)v34;
                uint64_t v37 = (v37 - 1);
              }
              while (!v25);
            }
            uint64_t v37 = v34;
LABEL_88:
            v18 += v36;
            uint64_t v34 = v37;
          }
          ++v33;
        }
        while (v33 != v15);
      }
      if (!(v35 | v34)) {
        goto LABEL_93;
      }
      int v10 = 0;
      uint64_t v14 = 0;
      uint64_t v9 = (v9 - v35);
      if (!v9) {
        goto LABEL_120;
      }
    }
    if ((int)v15 >= 1)
    {
      uint64_t v19 = 0;
      while (1)
      {
        uint64_t v20 = *(int *)(*(void *)(a1 + 224) + 4 * v19);
        if (v20) {
          break;
        }
LABEL_60:
        if (++v19 == v15) {
          goto LABEL_93;
        }
      }
      int v21 = *(unsigned __int8 *)(v17 + v19);
      if (v21 == 255)
      {
LABEL_59:
        v18 += v20;
        goto LABEL_60;
      }
      if (v21 != 254)
      {
LABEL_44:
        if (v21 >= v10) {
          int v21 = v10;
        }
        LODWORD(v26) = v20 - v21;
        if ((int)v20 - v21 <= (int)v9)
        {
          uint64_t v26 = (int)v26;
          do
          {
            if ((char)s[(int)v9 - v26] >= -64)
            {
              int v27 = v55;
              if (LODWORD(v56[0]) + (int)v26 < (int)v55) {
                int v27 = 0;
              }
              int v28 = LODWORD(v56[0]) + v26 - v27;
              unsigned int v29 = (char *)v54;
              if (!*((unsigned char *)v54 + v28))
              {
                uint64_t v30 = &s[(int)v9 - v26];
                int v31 = v20 + 1;
                uint64_t v32 = v18;
                while (*v30 == *v32)
                {
                  ++v32;
                  ++v30;
                  if (--v31 <= 1)
                  {
                    if (v9 != v26)
                    {
                      *((unsigned char *)v54 + v28) = 1;
                      ++HIDWORD(v55);
                      break;
                    }
                    uint64_t v14 = 0;
                    goto LABEL_121;
                  }
                }
              }
            }
            if (!v21) {
              break;
            }
            --v21;
            ++v26;
          }
          while (v9 + 1 != v26);
        }
        goto LABEL_59;
      }
      int v22 = -1;
      if (v20 != 1)
      {
        unsigned int v23 = *v18;
        if ((v23 + 11) >= 0xCDu)
        {
          unint64_t v24 = v18[1];
          if ((v23 & 0xF0) == 0xE0)
          {
            if ((a00000000000000[v23 & 0xF] >> (v18[1] >> 5)))
            {
              if (v20 != 2)
              {
                BOOL v25 = (char)v18[2] < -64;
                int v22 = -3;
                goto LABEL_29;
              }
              goto LABEL_42;
            }
            goto LABEL_41;
          }
          if (v23 <= 0xDF)
          {
            if ((char)v24 < -64) {
              int v22 = -2;
            }
            else {
              int v22 = -1;
            }
            goto LABEL_43;
          }
          if (((byte_18CA81C73[v24 >> 4] >> (v23 & 7)) & 1) == 0)
          {
LABEL_41:
            int v22 = -1;
            goto LABEL_43;
          }
          if (v20 == 2 || (char)v18[2] > -65)
          {
LABEL_42:
            int v22 = -2;
            goto LABEL_43;
          }
          if (v20 != 3)
          {
            BOOL v25 = (char)v18[3] < -64;
            int v22 = -4;
LABEL_29:
            if (!v25) {
              ++v22;
            }
            goto LABEL_43;
          }
          int v22 = -3;
        }
      }
LABEL_43:
      int v21 = v22 + v20;
      goto LABEL_44;
    }
LABEL_93:
    if (v10 || v9 == a3) {
      break;
    }
    if (HIDWORD(v55))
    {
      uint64_t v43 = (int)v9 - 1;
      UChar32 v44 = s[v43];
      if ((char)s[v43] < 0)
      {
        puint64_t i = v9 - 1;
        UChar32 v47 = utf8_prevCharSafeBody(s, 0, &pi, v44, -3);
        int v48 = v9 - pi;
        if (icu::UnicodeSet::contains(v52, v47)) {
          int v45 = v48;
        }
        else {
          int v45 = -v48;
        }
        if (v45 < 1) {
          goto LABEL_100;
        }
LABEL_110:
        uint64_t v9 = (v9 - v45);
        if (!v9)
        {
          uint64_t v14 = 0;
          goto LABEL_120;
        }
        int v49 = LODWORD(v56[0]) + v45;
        if (v49 >= (int)v55) {
          int v50 = v55;
        }
        else {
          int v50 = 0;
        }
        int v51 = v49 - v50;
        if (*((unsigned char *)v54 + v51))
        {
          *((unsigned char *)v54 + v51) = 0;
          --HIDWORD(v55);
        }
        int v10 = 0;
        LODWORD(v56[0]) = v51;
      }
      else
      {
        if (icu::UnicodeSet::contains(v52, s[v43]))
        {
          int v45 = 1;
          goto LABEL_110;
        }
LABEL_100:
        int v10 = 0;
        uint64_t v9 = v9 - sub_18C899F70((unsigned __int8 **)&v54);
      }
    }
    else
    {
      uint64_t v46 = icu::UnicodeSet::spanBackUTF8(v52, s);
      uint64_t v14 = v46;
      if (!v46) {
        goto LABEL_120;
      }
      int v10 = v9 - v46;
      uint64_t v9 = v46;
      if (!v10) {
        goto LABEL_120;
      }
    }
  }
  if (HIDWORD(v55)) {
    goto LABEL_100;
  }
  uint64_t v14 = v9;
LABEL_120:
  unsigned int v29 = (char *)v54;
LABEL_121:
  if (v29 != (char *)v56 + 4) {
    uprv_free(v29);
  }
  return v14;
}

uint64_t sub_18C89B558(uint64_t a1, uint8_t *s)
{
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 216) + 8);
  uint64_t v5 = 3 * (int)v4;
  if (!*(unsigned char *)(a1 + 260)) {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void *)(a1 + 232) + v5;
  int v7 = (icu::UnicodeSet *)(a1 + 8);
  while (1)
  {
    uint64_t v8 = icu::UnicodeSet::spanBackUTF8(*(icu::UnicodeSet **)(a1 + 208), s);
    uint64_t v9 = v8;
    if (!v8) {
      break;
    }
    uint64_t v10 = (int)v8 - 1;
    UChar32 v11 = s[v10];
    if ((char)s[v10] < 0)
    {
      puint64_t i = v8 - 1;
      UChar32 v13 = utf8_prevCharSafeBody(s, 0, &pi, v11, -3);
      int v14 = v9 - pi;
      if (icu::UnicodeSet::contains(v7, v13)) {
        int v12 = v14;
      }
      else {
        int v12 = -v14;
      }
      if (v12 > 0) {
        return v9;
      }
    }
    else
    {
      if (icu::UnicodeSet::contains(v7, s[v10])) {
        return v9;
      }
      int v12 = -1;
    }
    if ((int)v4 >= 1)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *(unsigned __int8 **)(a1 + 240);
      do
      {
        uint64_t v17 = *(int *)(*(void *)(a1 + 224) + 4 * v15);
        if (v17 && (int)v17 <= (int)v9 && *(unsigned __int8 *)(v6 + v15) != 255)
        {
          uint64_t v18 = &s[(int)v9 - v17];
          int v19 = v17 + 1;
          for (uint64_t i = v16; *v18 == *i; ++i)
          {
            ++v18;
            if (--v19 <= 1) {
              return v9;
            }
          }
        }
        v16 += v17;
        ++v15;
      }
      while (v15 != v4);
    }
    if (!(v12 + v9)) {
      return 0;
    }
  }
  return v9;
}

void *icu::UnicodeString::getStaticClassID(icu::UnicodeString *this)
{
  return &unk_1E9191EE8;
}

void *icu::UnicodeString::getDynamicClassID(icu::UnicodeString *this)
{
  return &unk_1E9191EE8;
}

void icu::operator+(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  int v7 = (__int16)v6;
  unsigned int v8 = v6 >> 5;
  if (v7 < 0) {
    unsigned int v8 = *(_DWORD *)(a1 + 12);
  }
  unsigned int v9 = *(unsigned __int16 *)(a2 + 8);
  int v10 = (__int16)v9;
  unsigned int v11 = v9 >> 5;
  if (v10 < 0) {
    unsigned int v11 = *(_DWORD *)(a2 + 12);
  }
  int v22 = &unk_1EDA47700;
  __int16 v23 = 0;
  icu::UnicodeString::allocate((icu::UnicodeString *)&v22, v8 + v11 + 1);
  unsigned int v12 = *(unsigned __int16 *)(a1 + 8);
  int v13 = (__int16)v12;
  unsigned int v14 = v12 >> 5;
  if (v13 >= 0) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = *(unsigned int *)(a1 + 12);
  }
  uint64_t v16 = icu::UnicodeString::doAppend((uint64_t)&v22, (const icu::UnicodeString *)a1, 0, v15);
  unsigned int v17 = *(unsigned __int16 *)(a2 + 8);
  int v18 = (__int16)v17;
  unsigned int v19 = v17 >> 5;
  if (v18 >= 0) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = *(unsigned int *)(a2 + 12);
  }
  int v21 = (UChar **)icu::UnicodeString::doAppend(v16, (const icu::UnicodeString *)a2, 0, v20);
  *(void *)a3 = &unk_1EDA47700;
  *(_WORD *)(a3 + 8) = 2;
  icu::UnicodeString::copyFrom((UChar **)a3, v21, 0);
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v22);
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, UChar **a2)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  return icu::UnicodeString::copyFrom((UChar **)this, a2, 0);
}

{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  return icu::UnicodeString::copyFrom((UChar **)this, a2, 0);
}

uint64_t icu::UnicodeString::addRef(uint64_t this)
{
  return this;
}

uint64_t icu::UnicodeString::removeRef(icu::UnicodeString *this)
{
  return atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) - 1;
}

uint64_t icu::UnicodeString::refCount(icu::UnicodeString *this)
{
  return atomic_load_explicit((atomic_uint *volatile)(*((void *)this + 3) - 4), memory_order_acquire);
}

void icu::UnicodeString::releaseArray(icu::UnicodeString *this)
{
  if ((*((_WORD *)this + 4) & 4) != 0
    && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1)
  {
    uprv_free((void *)(*((void *)this + 3) - 4));
  }
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, int a2, unsigned int a3, int a4)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 0;
  if (HIWORD(a3) > 0x10u || a4 <= 0) {
    goto LABEL_6;
  }
  if (!HIWORD(a3))
  {
    if (a2 <= a4) {
      a2 = a4;
    }
    if (icu::UnicodeString::allocate(this, a2))
    {
      if ((*((_WORD *)this + 4) & 2) != 0) {
        unsigned int v9 = (_WORD *)((char *)this + 10);
      }
      else {
        unsigned int v9 = (_WORD *)*((void *)this + 3);
      }
      uint64_t v12 = a4;
      do
      {
        *v9++ = a3;
        --v12;
      }
      while (v12);
      if (a4 <= 1023)
      {
        __int16 v13 = *((_WORD *)this + 4) & 0x1F | (32 * a4);
LABEL_31:
        *((_WORD *)this + 4) = v13;
        return this;
      }
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a4;
    }
    return this;
  }
  if (a4 >> 30)
  {
LABEL_6:
    icu::UnicodeString::allocate(this, a2);
    return this;
  }
  unint64_t v10 = (2 * a4);
  if ((int)v10 > a2) {
    a2 = 2 * a4;
  }
  if (icu::UnicodeString::allocate(this, a2))
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      unsigned int v11 = (char *)this + 10;
    }
    else {
      unsigned int v11 = (char *)*((void *)this + 3);
    }
    unint64_t v14 = 0;
    do
    {
      uint64_t v15 = &v11[2 * v14];
      *(_WORD *)uint64_t v15 = (a3 >> 10) - 10304;
      *((_WORD *)v15 + 1) = a3 & 0x3FF | 0xDC00;
      v14 += 2;
    }
    while (v14 < v10);
    if (a4 > 0x1FF)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = v10;
      return this;
    }
    __int16 v13 = *((_WORD *)this + 4) & 0x1F | (32 * v10);
    goto LABEL_31;
  }
  return this;
}

uint64_t icu::UnicodeString::allocate(icu::UnicodeString *this, int a2)
{
  if (a2 > 27)
  {
    if (a2 <= 0x7FFFFFF5
      && (size_t v4 = (2 * (a2 + 1) + 19) & 0x3FFFFFFF0, (v5 = uprv_malloc(v4)) != 0))
    {
      unsigned int v6 = v5;
      uint64_t result = 1;
      *unsigned int v6 = 1;
      *((void *)this + 3) = v6 + 1;
      *((_DWORD *)this + 4) = (v4 + 0x1FFFFFFFCLL) >> 1;
      *((_WORD *)this + 4) = 4;
    }
    else
    {
      uint64_t result = 0;
      *((_WORD *)this + 4) = 1;
      *((void *)this + 3) = 0;
      *((_DWORD *)this + 4) = 0;
    }
  }
  else
  {
    *((_WORD *)this + 4) = 2;
    return 1;
  }
  return result;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t result, __int16 a2)
{
  *(void *)uint64_t result = &unk_1EDA47700;
  *(_WORD *)(result + 8) = 34;
  *(_WORD *)(result + 10) = a2;
  return result;
}

{
  *(void *)uint64_t result = &unk_1EDA47700;
  *(_WORD *)(result + 8) = 34;
  *(_WORD *)(result + 10) = a2;
  return result;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t this, unsigned int a2)
{
  *(void *)this = &unk_1EDA47700;
  *(_WORD *)(this + 8) = 2;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u) {
      return this;
    }
    *(_WORD *)(this + 10) = (a2 >> 10) - 10304;
    __int16 v2 = 66;
    uint64_t v3 = 12;
    LOWORD(a2) = a2 & 0x3FF | 0xDC00;
  }
  else
  {
    __int16 v2 = 34;
    uint64_t v3 = 10;
  }
  *(_WORD *)(this + v3) = a2;
  *(_WORD *)(this + 8) = v2;
  return this;
}

{
  __int16 v2;
  uint64_t v3;

  *(void *)this = &unk_1EDA47700;
  *(_WORD *)(this + 8) = 2;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u) {
      return this;
    }
    *(_WORD *)(this + 10) = (a2 >> 10) - 10304;
    __int16 v2 = 66;
    uint64_t v3 = 12;
    LOWORD(a2) = a2 & 0x3FF | 0xDC00;
  }
  else
  {
    __int16 v2 = 34;
    uint64_t v3 = 10;
  }
  *(_WORD *)(this + v3) = a2;
  *(_WORD *)(this + 8) = v2;
  return this;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EDA47700;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, 0xFFFFFFFFLL);
  return a1;
}

{
  *(void *)a1 = &unk_1EDA47700;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, 0xFFFFFFFFLL);
  return a1;
}

uint64_t icu::UnicodeString::doAppend(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = a1;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return v4;
  }
  uint64_t v5 = a4;
  if (!a4) {
    return v4;
  }
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if ((v6 & 0x11) != 0) {
    return v4;
  }
  int v7 = (const void *)(a2 + 2 * a3);
  if ((a4 & 0x80000000) != 0)
  {
    uint64_t v9 = u_strlen((const UChar *)(a2 + 2 * a3));
    if (!v9) {
      return v4;
    }
    uint64_t v5 = v9;
    unsigned int v6 = *(unsigned __int16 *)(v4 + 8);
    if ((v6 & 0x8000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((v6 & 0x8000) == 0)
  {
LABEL_6:
    LODWORD(v8) = v6 >> 5;
    goto LABEL_10;
  }
  LODWORD(v8) = *(_DWORD *)(v4 + 12);
LABEL_10:
  int v23 = 0;
  if (uprv_add32_overflow(v8, v5, &v23))
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)v4);
    return v4;
  }
  __int16 v11 = *(_WORD *)(v4 + 8);
  if ((v11 & 2) != 0) {
    unint64_t v12 = v4 + 10;
  }
  else {
    unint64_t v12 = *(void *)(v4 + 24);
  }
  if ((v11 & 0x19) != 0)
  {
    uint64_t v8 = (int)v8;
  }
  else
  {
    BOOL v13 = (v11 & 4) == 0
       || atomic_load_explicit((atomic_uint *volatile)(*(void *)(v4 + 24) - 4), memory_order_acquire) == 1;
    if (v13 && v12 < (unint64_t)v7 + 2 * (int)v5 && (unint64_t)v7 < v12 + 2 * (int)v8)
    {
      long long v25 = 0u;
      long long v26 = 0u;
      uint64_t v28 = 0;
      long long v27 = 0u;
      uint64_t v24 = &unk_1EDA47700;
      LOWORD(v25) = 2;
      icu::UnicodeString::doAppend(&v24, v7, 0, v5);
      if (v25)
      {
        icu::UnicodeString::setToBogus((icu::UnicodeString *)v4);
      }
      else
      {
        if ((v25 & 2) != 0) {
          unint64_t v14 = (char *)&v25 + 2;
        }
        else {
          unint64_t v14 = (char *)v26;
        }
        uint64_t v4 = icu::UnicodeString::doAppend(v4, v14, 0, v5);
      }
      icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v24);
      return v4;
    }
    uint64_t v8 = (int)v8;
    __int16 v11 = *(_WORD *)(v4 + 8);
  }
  int v15 = v23;
  if ((v11 & 2) != 0) {
    int v16 = 27;
  }
  else {
    int v16 = *(_DWORD *)(v4 + 16);
  }
  if (v23 <= v16 && (v11 & 0x19) == 0)
  {
    if ((v11 & 4) == 0
      || atomic_load_explicit((atomic_uint *volatile)(*(void *)(v4 + 24) - 4), memory_order_acquire) == 1)
    {
LABEL_39:
      __int16 v19 = *(_WORD *)(v4 + 8);
      if ((v19 & 2) != 0) {
        uint64_t v20 = v4 + 10;
      }
      else {
        uint64_t v20 = *(void *)(v4 + 24);
      }
      if ((int)v5 >= 1)
      {
        int v21 = (void *)(v20 + 2 * v8);
        if (v7 != v21)
        {
          memmove(v21, v7, 2 * v5);
          __int16 v19 = *(_WORD *)(v4 + 8);
        }
      }
      int v22 = v23;
      if (v23 > 1023)
      {
        *(_WORD *)(v4 + 8) = v19 | 0xFFE0;
        *(_DWORD *)(v4 + 12) = v22;
      }
      else
      {
        *(_WORD *)(v4 + 8) = v19 & 0x1F | (32 * v23);
      }
      return v4;
    }
    int v15 = v23;
  }
  int v17 = (v15 >> 2) + 128;
  if (v17 <= 2147483637 - v15) {
    int v18 = v17 + v15;
  }
  else {
    int v18 = 2147483637;
  }
  if (icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v4, v15, v18, 1, 0, 0)) {
    goto LABEL_39;
  }
  return v4;
}

uint64_t icu::UnicodeString::UnicodeString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1EDA47700;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, a3);
  return a1;
}

{
  *(void *)a1 = &unk_1EDA47700;
  *(_WORD *)(a1 + 8) = 2;
  icu::UnicodeString::doAppend(a1, a2, 0, a3);
  return a1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, int a2, const UChar **a3, int32_t a4)
{
  *(void *)this = &unk_1EDA47700;
  LOBYTE(v5) = 8;
  *((_WORD *)this + 4) = 8;
  unsigned int v6 = *a3;
  if (!*a3)
  {
    *((_WORD *)this + 4) = 2;
    return this;
  }
  if (a4 < -1 || !a2 && a4 == -1) {
    goto LABEL_8;
  }
  if (!a2 || a4 < 0)
  {
    if (a4 == -1)
    {
      a4 = u_strlen(*a3);
      __int16 v5 = *((_WORD *)this + 4);
    }
  }
  else
  {
    if (v6[a4])
    {
LABEL_8:
      icu::UnicodeString::setToBogus(this);
      return this;
    }
    LOBYTE(v5) = 8;
  }
  if (a2) {
    int32_t v8 = a4 + 1;
  }
  else {
    int32_t v8 = a4;
  }
  if (a4 > 1023)
  {
    __int16 v9 = v5 | 0xFFE0;
    *((_DWORD *)this + 3) = a4;
  }
  else
  {
    __int16 v9 = v5 & 0x1F | (32 * a4);
  }
  *((_WORD *)this + 4) = v9;
  *((void *)this + 3) = v6;
  *((_DWORD *)this + 4) = v8;
  return this;
}

void icu::UnicodeString::setToBogus(icu::UnicodeString *this)
{
  if ((*((_WORD *)this + 4) & 4) != 0
    && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1)
  {
    uprv_free((void *)(*((void *)this + 3) - 4));
  }
  *((_WORD *)this + 4) = 1;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, char *a2, unint64_t a3, unsigned int a4)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 0;
  if (a2)
  {
    if ((int)a3 > (int)a4 || (int)a3 < -1 || (a4 & 0x80000000) != 0)
    {
      icu::UnicodeString::setToBogus(this);
    }
    else
    {
      if (a3 == -1)
      {
        __int16 v5 = a2;
        if (a4)
        {
          uint64_t v6 = 2 * a4;
          __int16 v5 = a2;
          while (*(_WORD *)v5)
          {
            v5 += 2;
            v6 -= 2;
            if (!v6)
            {
              __int16 v5 = &a2[2 * a4];
              break;
            }
          }
        }
        a3 = (unint64_t)(v5 - a2) >> 1;
      }
      if ((int)a3 > 1023)
      {
        *((_DWORD *)this + 3) = a3;
        __int16 v7 = -32;
      }
      else
      {
        __int16 v7 = 32 * a3;
      }
      *((_WORD *)this + 4) = v7;
      *((void *)this + 3) = a2;
      *((_DWORD *)this + 4) = a4;
    }
  }
  else
  {
    *((_WORD *)this + 4) = 2;
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, char *__s, int32_t a3)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  if (__s)
  {
    int32_t v4 = a3;
    if (a3 < 0) {
      int32_t v4 = strlen(__s);
    }
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v4, v4, 0, 0, 0))
    {
      if ((*((_WORD *)this + 4) & 2) != 0) {
        uint64_t v6 = (UChar *)((char *)this + 10);
      }
      else {
        uint64_t v6 = (UChar *)*((void *)this + 3);
      }
      u_charsToUChars(__s, v6, v4);
      if (v4 > 1023)
      {
        *((_WORD *)this + 4) |= 0xFFE0u;
        *((_DWORD *)this + 3) = v4;
      }
      else
      {
        *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * v4);
      }
    }
    else
    {
      icu::UnicodeString::setToBogus(this);
    }
  }
  return this;
}

uint64_t icu::UnicodeString::cloneArrayIfNeeded(icu::UnicodeString *this, int a2, int a3, int a4, int **a5, int a6)
{
  int v8 = a2;
  v24[7] = *MEMORY[0x1E4F143B8];
  unsigned int v10 = *((unsigned __int16 *)this + 4);
  if (a2 == -1)
  {
    if ((v10 & 2) != 0) {
      int v8 = 27;
    }
    else {
      int v8 = *((_DWORD *)this + 4);
    }
  }
  if ((v10 & 0x11) != 0) {
    return 0;
  }
  if (!a6 && (v10 & 8) == 0)
  {
    if ((v10 & 4) == 0
      || (int explicit = atomic_load_explicit((atomic_uint *volatile)(*((void *)this + 3) - 4), memory_order_acquire),
          unsigned int v10 = *((unsigned __int16 *)this + 4),
          explicit <= 1))
    {
      int v13 = (v10 & 2) != 0 ? 27 : *((_DWORD *)this + 4);
      if (v8 <= v13) {
        return 1;
      }
    }
  }
  if (v8 >= 28 || a3 <= 27) {
    int v15 = a3;
  }
  else {
    int v15 = 27;
  }
  memset(&v24[2], 0, 38);
  if (a3 >= 0) {
    int v16 = v15;
  }
  else {
    int v16 = v8;
  }
  *(_OWORD *)uint64_t v24 = 0uLL;
  if ((v10 & 0x8000) != 0)
  {
    int v17 = *((_DWORD *)this + 3);
    if ((v10 & 2) == 0) {
      goto LABEL_26;
    }
  }
  else
  {
    int v17 = v10 >> 5;
    if ((v10 & 2) == 0)
    {
LABEL_26:
      int v18 = (void *)*((void *)this + 3);
      goto LABEL_32;
    }
  }
  int v18 = 0;
  if (a4)
  {
    if (v16 >= 28)
    {
      int v18 = v24;
      if (v17 >= 1) {
        memcpy(v24, (char *)this + 10, 2 * v17);
      }
    }
  }
LABEL_32:
  if (!icu::UnicodeString::allocate(this, v16)
    && (v8 >= v16 || !icu::UnicodeString::allocate(this, v8)))
  {
    if ((v10 & 2) == 0) {
      *((void *)this + 3) = v18;
    }
    *((_WORD *)this + 4) = v10;
    icu::UnicodeString::setToBogus(this);
    return 0;
  }
  __int16 v19 = *((_WORD *)this + 4);
  if (!a4)
  {
    __int16 v22 = *((_WORD *)this + 4) & 0x1F;
    goto LABEL_55;
  }
  if ((v19 & 2) != 0)
  {
    if (v17 >= 27) {
      int v20 = 27;
    }
    else {
      int v20 = v17;
    }
    if (!v18) {
      goto LABEL_54;
    }
    int v21 = (char *)this + 10;
  }
  else
  {
    if (*((_DWORD *)this + 4) >= v17) {
      int v20 = v17;
    }
    else {
      int v20 = *((_DWORD *)this + 4);
    }
    if (!v18) {
      goto LABEL_53;
    }
    int v21 = (char *)*((void *)this + 3);
  }
  if (v20 < 1)
  {
LABEL_54:
    __int16 v22 = v19 & 0x1F | (32 * v20);
LABEL_55:
    *((_WORD *)this + 4) = v22;
    if ((v10 & 4) != 0) {
      goto LABEL_56;
    }
    return 1;
  }
  memmove(v21, v18, 2 * v20);
  __int16 v19 = *((_WORD *)this + 4);
LABEL_53:
  if (v20 <= 1023) {
    goto LABEL_54;
  }
  *((_WORD *)this + 4) = v19 | 0xFFE0;
  *((_DWORD *)this + 3) = v20;
  if ((v10 & 4) != 0)
  {
LABEL_56:
    int v23 = (int *)v18 - 1;
    if (atomic_fetch_add((atomic_uint *volatile)v18 - 1, 0xFFFFFFFF) == 1)
    {
      if (a5) {
        *a5 = v23;
      }
      else {
        uprv_free(v23);
      }
    }
  }
  return 1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *a2)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  if (a2)
  {
    icu::StringPiece::StringPiece((icu::StringPiece *)&v4, a2);
    icu::UnicodeString::setToUTF8((uint64_t)this, v4, v5);
  }
  return this;
}

uint64_t icu::UnicodeString::setToUTF8(uint64_t a1, const char *a2, int32_t a3)
{
  if (*(_WORD *)(a1 + 8)) {
    *(_WORD *)(a1 + 8) = 2;
  }
  int32_t v6 = 27;
  if (a3 > 27) {
    int v7 = a3 + 1;
  }
  else {
    int v7 = 27;
  }
  Buffer = (UChar *)icu::UnicodeString::getBuffer((icu::UnicodeString *)a1, v7);
  *(void *)UErrorCode pErrorCode = 0;
  if ((*(_WORD *)(a1 + 8) & 2) == 0) {
    int32_t v6 = *(_DWORD *)(a1 + 16);
  }
  u_strFromUTF8WithSub(Buffer, v6, (int32_t *)&pErrorCode[1], a2, a3, 65533, 0, pErrorCode);
  icu::UnicodeString::releaseBuffer(a1, pErrorCode[1]);
  if (pErrorCode[0] >= U_ILLEGAL_ARGUMENT_ERROR) {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a1);
  }
  return a1;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, int32_t a3)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  if (a3 >= -1 && __s && a3)
  {
    if (a3 == -1) {
      a3 = strlen(__s);
    }
    icu::UnicodeString::setToUTF8((uint64_t)this, __s, a3);
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::copyFrom(UChar **this, UChar **a2, int a3)
{
  if (this != a2)
  {
    if ((_WORD)a2[1])
    {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
    }
    else
    {
      if (((_WORD)this[1] & 4) != 0 && atomic_fetch_add((atomic_uint *volatile)this[3] - 1, 0xFFFFFFFF) == 1) {
        uprv_free(this[3] - 2);
      }
      unsigned int v6 = *((unsigned __int16 *)a2 + 4);
      if (v6 <= 0x1F)
      {
        __int16 v8 = 2;
LABEL_11:
        *((_WORD *)this + 4) = v8;
      }
      else
      {
        *((_WORD *)this + 4) = v6;
        unsigned int v7 = *((unsigned __int16 *)a2 + 4);
        switch(v7 & 0x1F)
        {
          case 0u:
            goto LABEL_17;
          case 2u:
            memcpy((char *)this + 10, (char *)a2 + 10, 2 * ((__int16)v6 >> 5));
            return (icu::UnicodeString *)this;
          case 4u:
            atomic_fetch_add((atomic_uint *volatile)a2[3] - 1, 1u);
            this[3] = a2[3];
            *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
            if ((__int16)this[1] < 0) {
              goto LABEL_16;
            }
            return (icu::UnicodeString *)this;
          case 8u:
            if (a3)
            {
              this[3] = a2[3];
              *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
              if ((v6 & 0x8000) != 0) {
LABEL_16:
              }
                *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
            }
            else
            {
LABEL_17:
              int v9 = (__int16)v7;
              int v10 = v7 >> 5;
              if (v9 >= 0) {
                int v11 = v10;
              }
              else {
                int v11 = *((_DWORD *)a2 + 3);
              }
              if (!icu::UnicodeString::allocate((icu::UnicodeString *)this, v11))
              {
LABEL_23:
                *((_WORD *)this + 4) = 1;
                this[3] = 0;
                *((_DWORD *)this + 4) = 0;
                return (icu::UnicodeString *)this;
              }
              if (((_WORD)this[1] & 2) != 0) {
                unint64_t v12 = (UChar *)this + 5;
              }
              else {
                unint64_t v12 = this[3];
              }
              if (((_WORD)a2[1] & 2) != 0) {
                int v13 = (const UChar *)a2 + 5;
              }
              else {
                int v13 = a2[3];
              }
              u_memcpy(v12, v13, v11);
              if (v11 <= 1023)
              {
                __int16 v8 = (_WORD)this[1] & 0x1F | (32 * v11);
                goto LABEL_11;
              }
              *((_WORD *)this + 4) |= 0xFFE0u;
              *((_DWORD *)this + 3) = v11;
            }
            break;
          default:
            goto LABEL_23;
        }
      }
    }
  }
  return (icu::UnicodeString *)this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *a1, icu::UnicodeString *a2)
{
  *(void *)a1 = &unk_1EDA47700;
  icu::UnicodeString::copyFieldsFrom(a1, a2, 1);
  return a1;
}

{
  *(void *)a1 = &unk_1EDA47700;
  icu::UnicodeString::copyFieldsFrom(a1, a2, 1);
  return a1;
}

icu::UnicodeString *icu::UnicodeString::copyFieldsFrom(icu::UnicodeString *this, icu::UnicodeString *a2, int a3)
{
  int v3 = *((__int16 *)a2 + 4);
  *((_WORD *)this + 4) = *((_WORD *)a2 + 4);
  if ((v3 & 2) != 0)
  {
    if (this != a2) {
      return (icu::UnicodeString *)memcpy((char *)this + 10, (char *)a2 + 10, 2 * (v3 >> 5));
    }
  }
  else
  {
    *((void *)this + 3) = *((void *)a2 + 3);
    *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
    if ((v3 & 0x80000000) == 0)
    {
      if (!a3) {
        return this;
      }
LABEL_8:
      *((_WORD *)a2 + 4) = 1;
      *((void *)a2 + 3) = 0;
      *((_DWORD *)a2 + 4) = 0;
      return this;
    }
    *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
    if (a3) {
      goto LABEL_8;
    }
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const icu::UnicodeString *a2, int a3)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  unsigned int v4 = *((unsigned __int16 *)a2 + 4);
  unsigned int v5 = v4 >> 5;
  if (a3 < 0)
  {
    int v7 = 0;
    goto LABEL_7;
  }
  int v6 = a3;
  if ((v4 & 0x8000) != 0)
  {
    int v7 = *((_DWORD *)a2 + 3);
    if (v7 >= a3) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  int v7 = v4 >> 5;
  if (v5 < a3) {
LABEL_7:
  }
    int v6 = v7;
LABEL_8:
  if ((v4 & 0x8000u) != 0) {
    unsigned int v5 = *((_DWORD *)a2 + 3);
  }
  icu::UnicodeString::doReplace(this, 0, 0, a2, v6, v5 - v6);
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const icu::UnicodeString *a2, int a3, uint64_t a4)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  icu::UnicodeString::doReplace(this, 0, 0, a2, a3, a4);
  return this;
}

{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  icu::UnicodeString::doReplace(this, 0, 0, a2, a3, a4);
  return this;
}

uint64_t icu::Replaceable::clone(icu::Replaceable *this)
{
  return 0;
}

icu::UnicodeString *icu::UnicodeString::clone@<X0>(UChar **this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (icu::UnicodeString *)icu::UMemory::operator new(a3, (icu::UMemory *)0x40, a2);
  if (result)
  {
    *(void *)uint64_t result = &unk_1EDA47700;
    *((_WORD *)result + 4) = 2;
    uint64_t result = icu::UnicodeString::copyFrom((UChar **)result, this, 0);
    if (*((_WORD *)result + 4))
    {
      (*(void (**)(icu::UnicodeString *))(*(void *)result + 8))(result);
      return 0;
    }
  }
  return result;
}

void icu::UnicodeString::~UnicodeString(icu::UnicodeString *this)
{
  *(void *)this = &unk_1EDA47700;
  if ((*((_WORD *)this + 4) & 4) != 0
    && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1)
  {
    uprv_free((void *)(*((void *)this + 3) - 4));
  }

  icu::UObject::~UObject(this);
}

{
  void *v1;
  uint64_t vars8;

  icu::UnicodeString::~UnicodeString(this);

  icu::UMemory::operator delete(v1);
}

uint64_t icu::UnicodeString::fromUTF8@<X0>(const char *a1@<X0>, int32_t a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = &unk_1EDA47700;
  *(_WORD *)(a3 + 8) = 2;
  return icu::UnicodeString::setToUTF8(a3, a1, a2);
}

void icu::UnicodeString::fromUTF32(const UChar32 *this@<X0>, const int *a2@<X1>, uint64_t a3@<X8>)
{
  int32_t v3 = (int)a2;
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = &unk_1EDA47700;
  *(_WORD *)(a3 + 8) = 2;
  if ((int)a2 <= 27) {
    int v6 = 27;
  }
  else {
    int v6 = a2 + (a2 >> 4) + 4;
  }
  while (1)
  {
    Buffer = (UChar *)icu::UnicodeString::getBuffer((icu::UnicodeString *)a3, v6);
    *(void *)UErrorCode pErrorCode = 0;
    int32_t v8 = (*(_WORD *)(a3 + 8) & 2) != 0 ? 27 : *(_DWORD *)(a3 + 16);
    u_strFromUTF32WithSub(Buffer, v8, (int32_t *)&pErrorCode[1], this, v3, 65533, 0, pErrorCode);
    UErrorCode v9 = pErrorCode[1];
    icu::UnicodeString::releaseBuffer(a3, pErrorCode[1]);
    if (pErrorCode[0] != U_BUFFER_OVERFLOW_ERROR) {
      break;
    }
    int v6 = v9 + 1;
  }
  if (pErrorCode[0] >= U_ILLEGAL_ARGUMENT_ERROR) {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)a3);
  }
}

uint64_t icu::UnicodeString::getBuffer(icu::UnicodeString *this, int a2)
{
  if (a2 < -1) {
    return 0;
  }
  if (!icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0, 0)) {
    return 0;
  }
  __int16 v3 = *((_WORD *)this + 4);
  *((_WORD *)this + 4) = v3 & 0xF | 0x10;
  if ((v3 & 2) != 0) {
    return (uint64_t)this + 10;
  }
  else {
    return *((void *)this + 3);
  }
}

uint64_t icu::UnicodeString::releaseBuffer(uint64_t this, int a2)
{
  if (a2 < -1) {
    return this;
  }
  __int16 v2 = *(_WORD *)(this + 8);
  if ((v2 & 0x10) == 0) {
    return this;
  }
  if ((v2 & 2) != 0)
  {
    if (a2 == -1)
    {
      unsigned int v4 = (char *)(this + 10);
      unint64_t v5 = this + 64;
      goto LABEL_13;
    }
    int v3 = 27;
  }
  else
  {
    int v3 = *(_DWORD *)(this + 16);
    if (a2 == -1)
    {
      unsigned int v4 = *(char **)(this + 24);
      if (v3 < 1)
      {
        int v7 = *(char **)(this + 24);
LABEL_18:
        unint64_t v6 = (unint64_t)(v7 - v4) >> 1;
        goto LABEL_19;
      }
      unint64_t v5 = (unint64_t)&v4[2 * v3];
LABEL_13:
      int v7 = v4;
      do
      {
        if (!*(_WORD *)v7) {
          break;
        }
        v7 += 2;
      }
      while ((unint64_t)v7 < v5);
      goto LABEL_18;
    }
  }
  if (v3 >= a2) {
    LODWORD(v6) = a2;
  }
  else {
    LODWORD(v6) = v3;
  }
LABEL_19:
  if ((int)v6 > 1023)
  {
    __int16 v8 = v2 | 0xFFE0;
    *(_DWORD *)(this + 12) = v6;
  }
  else
  {
    __int16 v8 = *(_WORD *)(this + 8) & 0x1F | (32 * v6);
  }
  *(_WORD *)(this + 8) = v8 & 0xFFEF;
  return this;
}

icu::UnicodeString *icu::UnicodeString::operator=(UChar **a1, UChar **a2)
{
  return icu::UnicodeString::copyFrom(a1, a2, 0);
}

icu::UnicodeString *icu::UnicodeString::fastCopyFrom(UChar **this, UChar **a2)
{
  return icu::UnicodeString::copyFrom(this, a2, 1);
}

icu::UnicodeString *icu::UnicodeString::operator=(icu::UnicodeString *this, icu::UnicodeString *a2)
{
  if ((*((_WORD *)this + 4) & 4) != 0
    && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1)
  {
    uprv_free((void *)(*((void *)this + 3) - 4));
  }
  icu::UnicodeString::copyFieldsFrom(this, a2, 1);
  return this;
}

void icu::UnicodeString::swap(icu::UnicodeString *this, void **a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t v9 = 0;
  long long v8 = 0u;
  unint64_t v5 = &unk_1EDA47700;
  LOWORD(v6) = 2;
  icu::UnicodeString::copyFieldsFrom((icu::UnicodeString *)&v5, this, 0);
  icu::UnicodeString::copyFieldsFrom(this, (icu::UnicodeString *)a2, 0);
  int v4 = (__int16)v6;
  *((_WORD *)a2 + 4) = v6;
  if ((v4 & 2) != 0)
  {
    if (&v5 != a2) {
      memcpy((char *)a2 + 10, (char *)&v6 + 2, 2 * (v4 >> 5));
    }
  }
  else
  {
    a2[3] = (void *)v7;
    *((_DWORD *)a2 + 4) = DWORD2(v6);
    if (v4 < 0) {
      *((_DWORD *)a2 + 3) = DWORD1(v6);
    }
  }
  LOWORD(v6) = 2;
  icu::UnicodeString::~UnicodeString((icu::UnicodeString *)&v5);
}

uint64_t icu::UnicodeString::unescape@<X0>(icu::UnicodeString *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((v4 & 0x8000) != 0) {
    int v5 = *((_DWORD *)this + 3);
  }
  else {
    int v5 = v4 >> 5;
  }
  *(void *)a2 = &unk_1EDA47700;
  uint64_t result = icu::UnicodeString::allocate((icu::UnicodeString *)a2, v5);
  if (*(_WORD *)(a2 + 8)) {
    return result;
  }
  unsigned int v7 = *((unsigned __int16 *)this + 4);
  if ((v7 & 0x11) != 0)
  {
    long long v8 = 0;
    if ((v7 & 0x8000) != 0) {
      goto LABEL_12;
    }
LABEL_10:
    unsigned int v9 = v7 >> 5;
    goto LABEL_13;
  }
  if ((v7 & 2) != 0)
  {
    long long v8 = (char *)this + 10;
    if ((v7 & 0x8000) == 0) {
      goto LABEL_10;
    }
  }
  else
  {
    long long v8 = (char *)*((void *)this + 3);
    if ((v7 & 0x8000) == 0) {
      goto LABEL_10;
    }
  }
LABEL_12:
  unsigned int v9 = *((_DWORD *)this + 3);
LABEL_13:
  int32_t offset = 0;
  if (v9)
  {
    int v10 = 0;
    int32_t v11 = 0;
    while (1)
    {
      int32_t v12 = v10 + 1;
      int32_t offset = v10 + 1;
      if (*(_WORD *)&v8[2 * v10] == 92)
      {
        icu::UnicodeString::doAppend(a2, (uint64_t)v8, v11, (v10 - v11));
        unsigned int v13 = *((unsigned __int16 *)this + 4);
        if ((v13 & 0x8000) != 0) {
          int32_t v14 = *((_DWORD *)this + 3);
        }
        else {
          int32_t v14 = v13 >> 5;
        }
        uint64_t result = u_unescapeAt((UNESCAPE_CHAR_AT)sub_18C89D28C, &offset, v14, this);
        if ((result & 0x80000000) != 0)
        {
          if (*(_WORD *)(a2 + 8)) {
            __int16 v15 = 2;
          }
          else {
            __int16 v15 = *(_WORD *)(a2 + 8) & 0x1F;
          }
          *(_WORD *)(a2 + 8) = v15;
          return result;
        }
        icu::UnicodeString::append(a2, result);
        int32_t v12 = offset;
        int32_t v11 = offset;
      }
      int v10 = v12;
      if (v12 == v9) {
        return icu::UnicodeString::doAppend(a2, (uint64_t)v8, v11, v9 - v11);
      }
    }
  }
  int32_t v11 = 0;
  return icu::UnicodeString::doAppend(a2, (uint64_t)v8, v11, v9 - v11);
}

uint64_t icu::UnicodeString::unescapeAt(icu::UnicodeString *this, int *a2)
{
  if (*((__int16 *)this + 4) < 0) {
    int32_t v2 = *((_DWORD *)this + 3);
  }
  else {
    int32_t v2 = *((unsigned __int16 *)this + 4) >> 5;
  }
  return u_unescapeAt((UNESCAPE_CHAR_AT)sub_18C89D28C, a2, v2, this);
}

uint64_t icu::UnicodeString::append(uint64_t this, unsigned int a2)
{
  int v3 = 0;
  if (HIWORD(a2))
  {
    if (HIWORD(a2) > 0x10u) {
      return this;
    }
    LOWORD(v3) = (a2 >> 10) - 10304;
    HIWORD(v3) = a2 & 0x3FF | 0xDC00;
    uint64_t v2 = 2;
  }
  else
  {
    LOWORD(v3) = a2;
    uint64_t v2 = 1;
  }
  return icu::UnicodeString::doAppend(this, (uint64_t)&v3, 0, v2);
}

uint64_t sub_18C89D28C(unsigned int a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  if (*(__int16 *)(a2 + 8) < 0) {
    unsigned int v3 = *(_DWORD *)(a2 + 12);
  }
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a1) {
    return 0xFFFFLL;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = a2 + 10;
  }
  else {
    uint64_t v4 = *(void *)(a2 + 24);
  }
  return *(unsigned __int16 *)(v4 + 2 * (int)a1);
}

BOOL icu::UnicodeString::doEquals(icu::UnicodeString *this, const icu::UnicodeString *a2, int a3)
{
  if ((*((_WORD *)this + 4) & 2) != 0) {
    unsigned int v3 = (char *)this + 10;
  }
  else {
    unsigned int v3 = (char *)*((void *)this + 3);
  }
  if ((*((_WORD *)a2 + 4) & 2) != 0) {
    uint64_t v4 = (char *)a2 + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)a2 + 3);
  }
  return memcmp(v3, v4, 2 * a3) == 0;
}

BOOL icu::UnicodeString::doEqualsSubstring(uint64_t a1, int a2, int32_t count, uint64_t a4, int a5, int32_t a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if (v6) {
    return 0;
  }
  int32_t v7 = count;
  int v8 = a2;
  if ((v6 & 0x8000) == 0)
  {
    signed int v9 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_11:
    int v10 = 0;
    goto LABEL_12;
  }
  signed int v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_11;
  }
LABEL_4:
  int v10 = v9;
  if (v9 >= v8)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_13:
    int32_t v11 = 0;
    goto LABEL_14;
  }
LABEL_12:
  int v8 = v10;
  if (count < 0) {
    goto LABEL_13;
  }
LABEL_6:
  int32_t v11 = v9 - v8;
  if (v11 >= count)
  {
    if (a4) {
      goto LABEL_8;
    }
    return v7 == 0;
  }
LABEL_14:
  int32_t v7 = v11;
  if (!a4) {
    return v7 == 0;
  }
LABEL_8:
  if ((v6 & 2) != 0) {
    uint64_t v12 = a1 + 10;
  }
  else {
    uint64_t v12 = *(void *)(a1 + 24);
  }
  int32_t v14 = (const UChar *)(a4 + 2 * a5);
  if (a6 < 0) {
    a6 = u_strlen(&v14[a5]);
  }
  if (v7 != a6) {
    return 0;
  }
  BOOL result = 1;
  if (v7 && (const UChar *)(v12 + 2 * v8) != v14) {
    return u_memcmp((const UChar *)(v12 + 2 * v8), v14, v7) == 0;
  }
  return result;
}

uint64_t icu::UnicodeString::doCompare(uint64_t a1, int a2, int32_t a3, uint64_t a4, int a5, int32_t a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if (v6)
  {
    LOBYTE(v13) = -1;
    return (char)v13;
  }
  int32_t v7 = a3;
  int v8 = a2;
  if ((v6 & 0x8000) == 0)
  {
    signed int v9 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_12:
    int v10 = 0;
    goto LABEL_13;
  }
  signed int v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_12;
  }
LABEL_4:
  int v10 = v9;
  if (v9 >= v8)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_14:
    int32_t v11 = 0;
    goto LABEL_15;
  }
LABEL_13:
  int v8 = v10;
  if (a3 < 0) {
    goto LABEL_14;
  }
LABEL_6:
  int32_t v11 = v9 - v8;
  if (v11 >= a3)
  {
    if (a4) {
      goto LABEL_8;
    }
LABEL_16:
    LOBYTE(v13) = v7 != 0;
    return (char)v13;
  }
LABEL_15:
  int32_t v7 = v11;
  if (!a4) {
    goto LABEL_16;
  }
LABEL_8:
  if ((v6 & 2) != 0) {
    uint64_t v12 = a1 + 10;
  }
  else {
    uint64_t v12 = *(void *)(a1 + 24);
  }
  int32_t v14 = (unsigned __int16 *)(a4 + 2 * a5);
  if (a6 < 0) {
    a6 = u_strlen(&v14[a5]);
  }
  if (v7 >= a6) {
    int v15 = a6;
  }
  else {
    int v15 = v7;
  }
  if (v7 < a6) {
    LOBYTE(v13) = -1;
  }
  else {
    LOBYTE(v13) = 1;
  }
  if (v7 == a6) {
    LOBYTE(v13) = 0;
  }
  if (v15 >= 1)
  {
    int v16 = (unsigned __int16 *)(v12 + 2 * v8);
    if (v16 != v14)
    {
      int v17 = v15 + 1;
      while (1)
      {
        unsigned int v18 = *v16 - *v14;
        if (v18) {
          break;
        }
        ++v14;
        ++v16;
        if (--v17 <= 1) {
          return (char)v13;
        }
      }
      int v13 = (v18 >> 15) | 1;
    }
  }
  return (char)v13;
}

uint64_t icu::UnicodeString::doCompareCodePointOrder(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a1 + 8);
  if (v6)
  {
    LOBYTE(v10) = -1;
    return (char)v10;
  }
  if ((v6 & 0x8000) == 0)
  {
    signed int v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_10:
    int v8 = 0;
    goto LABEL_11;
  }
  signed int v7 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_10;
  }
LABEL_4:
  int v8 = v7;
  if (v7 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  a2 = v8;
  if ((a3 & 0x80000000) == 0)
  {
LABEL_6:
    int v9 = v7 - a2;
    if (v9 >= a3) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_12:
  int v9 = 0;
LABEL_13:
  a3 = v9;
LABEL_14:
  if (a4) {
    int v11 = a6;
  }
  else {
    int v11 = 0;
  }
  if ((v6 & 2) != 0) {
    uint64_t v12 = a1 + 10;
  }
  else {
    uint64_t v12 = *(void *)(a1 + 24);
  }
  int v13 = (unsigned __int16 *)(v12 + 2 * a2);
  if (a4) {
    uint64_t v14 = a5;
  }
  else {
    uint64_t v14 = 0;
  }
  int v15 = (unsigned __int16 *)(a4 + 2 * v14);
  if (!a4) {
    int v15 = 0;
  }
  unsigned int v16 = sub_18C8B6AC8(v13, a3, v15, v11, 0, 1);
  int v10 = (v16 >> 15) | 1;
  if (!v16) {
    LOBYTE(v10) = 0;
  }
  return (char)v10;
}

uint64_t icu::UnicodeString::getLength(icu::UnicodeString *this)
{
  if (*((__int16 *)this + 4) < 0) {
    return *((unsigned int *)this + 3);
  }
  else {
    return *((unsigned __int16 *)this + 4) >> 5;
  }
}

uint64_t icu::UnicodeString::getCharAt(icu::UnicodeString *this, unsigned int a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0) {
    unsigned int v3 = *((_DWORD *)this + 3);
  }
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a2) {
    return 0xFFFFLL;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = (char *)this + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)this + 3);
  }
  return *(unsigned __int16 *)&v4[2 * a2];
}

uint64_t icu::UnicodeString::char32At(icu::UnicodeString *this, int a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0) {
    unsigned int v3 = *((_DWORD *)this + 3);
  }
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a2) {
    return 0xFFFFLL;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = (char *)this + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)this + 3);
  }
  uint64_t result = *(unsigned __int16 *)&v4[2 * a2];
  if ((result & 0xF800) == 0xD800)
  {
    if ((result & 0x400) != 0)
    {
      if (a2 >= 1)
      {
        int v9 = *(unsigned __int16 *)&v4[2 * (a2 - 1)];
        if ((v9 & 0xFC00) == 0xD800)
        {
          int v8 = result + (v9 << 10);
          return (v8 - 56613888);
        }
      }
    }
    else
    {
      uint64_t v6 = a2 + 1;
      if (v6 != v3)
      {
        int v7 = *(unsigned __int16 *)&v4[2 * v6];
        if ((v7 & 0xFC00) == 0xDC00)
        {
          int v8 = v7 + (result << 10);
          return (v8 - 56613888);
        }
      }
    }
  }
  return result;
}

uint64_t icu::UnicodeString::getChar32Start(icu::UnicodeString *this, uint64_t a2)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0) {
    unsigned int v3 = *((_DWORD *)this + 3);
  }
  else {
    unsigned int v3 = v2 >> 5;
  }
  if (v3 <= a2) {
    return 0;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = (char *)this + 10;
  }
  else {
    uint64_t v4 = (char *)*((void *)this + 3);
  }
  unsigned int v5 = a2 - 1;
  if ((int)a2 >= 1 && (*(_WORD *)&v4[2 * (int)a2] & 0xFC00) == 0xDC00)
  {
    if ((*(_WORD *)&v4[2 * v5] & 0xFC00) == 0xD800) {
      return v5;
    }
    else {
      return a2;
    }
  }
  return a2;
}

uint64_t icu::UnicodeString::getChar32Limit(icu::UnicodeString *this, uint64_t a2)
{
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0) {
    uint64_t result = *((unsigned int *)this + 3);
  }
  else {
    uint64_t result = v3 >> 5;
  }
  if (result > a2)
  {
    if ((v3 & 2) != 0) {
      unsigned int v5 = (char *)this + 10;
    }
    else {
      unsigned int v5 = (char *)*((void *)this + 3);
    }
    if ((int)a2 >= 1
      && ((int)result > (int)a2 || (result & 0x80000000) != 0)
      && (*(_WORD *)&v5[2 * (a2 - 1)] & 0xFC00) == 0xD800)
    {
      if ((*(_WORD *)&v5[2 * a2] & 0xFC00) == 0xDC00) {
        return (a2 + 1);
      }
      else {
        return a2;
      }
    }
    else
    {
      return a2;
    }
  }
  return result;
}

uint64_t icu::UnicodeString::countChar32(icu::UnicodeString *this, int a2, int32_t length)
{
  unsigned int v3 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v4 = v3 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v5 = 0;
    goto LABEL_10;
  }
  signed int v4 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v5 = v4;
  if (v4 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v6 = 0;
LABEL_12:
    length = v6;
    if ((v3 & 2) == 0) {
      goto LABEL_7;
    }
LABEL_13:
    int v7 = (char *)this + 10;
    return u_countChar32((const UChar *)&v7[2 * a2], length);
  }
LABEL_10:
  a2 = v5;
  if (length < 0) {
    goto LABEL_11;
  }
LABEL_5:
  int32_t v6 = v4 - a2;
  if (v6 < length) {
    goto LABEL_12;
  }
  if ((v3 & 2) != 0) {
    goto LABEL_13;
  }
LABEL_7:
  int v7 = (char *)*((void *)this + 3);
  return u_countChar32((const UChar *)&v7[2 * a2], length);
}

uint64_t icu::UnicodeString::hasMoreChar32Than(icu::UnicodeString *this, int a2, int32_t length, int32_t number)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }
  signed int v5 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    length = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
LABEL_13:
    int v8 = (char *)this + 10;
    return u_strHasMoreChar32Than((const UChar *)&v8[2 * a2], length, number);
  }
LABEL_10:
  a2 = v6;
  if (length < 0) {
    goto LABEL_11;
  }
LABEL_5:
  int32_t v7 = v5 - a2;
  if (v7 < length) {
    goto LABEL_12;
  }
  if ((v4 & 2) != 0) {
    goto LABEL_13;
  }
LABEL_7:
  int v8 = (char *)*((void *)this + 3);
  return u_strHasMoreChar32Than((const UChar *)&v8[2 * a2], length, number);
}

uint64_t icu::UnicodeString::moveIndex32(icu::UnicodeString *this, int a2, int a3)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if (*((__int16 *)this + 4) < 0) {
    int v5 = *((_DWORD *)this + 3);
  }
  else {
    int v5 = v4 >> 5;
  }
  if (v5 >= a2) {
    unsigned int v6 = a2;
  }
  else {
    unsigned int v6 = v5;
  }
  if (a2 >= 0) {
    uint64_t result = v6;
  }
  else {
    uint64_t result = 0;
  }
  if ((v4 & 2) != 0) {
    int v8 = (char *)this + 10;
  }
  else {
    int v8 = (char *)*((void *)this + 3);
  }
  if (a3 >= 1)
  {
    int v9 = a3 + 1;
    uint64_t v10 = result;
    while (1)
    {
      if ((int)v10 >= v5)
      {
        if ((v5 & 0x80000000) == 0) {
          return v10;
        }
        __int16 v11 = *(_WORD *)&v8[2 * (int)v10];
        if (!v11) {
          return v10;
        }
      }
      else
      {
        __int16 v11 = *(_WORD *)&v8[2 * (int)v10];
      }
      uint64_t result = (int)v10 + 1;
      if ((v11 & 0xFC00) == 0xD800 && result != v5)
      {
        unsigned int v13 = v10 + 2;
        if ((*(_WORD *)&v8[2 * result] & 0xFC00) == 0xDC00) {
          uint64_t result = v13;
        }
        else {
          uint64_t result = result;
        }
      }
      --v9;
      uint64_t v10 = result;
      if (v9 <= 1) {
        return result;
      }
    }
  }
  if (a3 && (int)result >= 1)
  {
    int v14 = -a3;
    do
    {
      uint64_t result = v6 - 1;
      if ((*(_WORD *)&v8[2 * result] & 0xFC00) == 0xDC00 && v6 >= 2)
      {
        unsigned int v16 = v6 - 2;
        if ((*(_WORD *)&v8[2 * v16] & 0xFC00) == 0xD800) {
          uint64_t result = v16;
        }
        else {
          uint64_t result = result;
        }
      }
      if (v14 < 2) {
        break;
      }
      --v14;
      unsigned int v6 = result;
    }
    while ((int)result > 0);
  }
  return result;
}

char *icu::UnicodeString::doExtract(char *result, int a2, int a3, uint64_t a4, int a5)
{
  unsigned int v5 = *((unsigned __int16 *)result + 4);
  if ((*((__int16 *)result + 4) & 0x80000000) == 0)
  {
    signed int v6 = v5 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v7 = 0;
    goto LABEL_10;
  }
  signed int v6 = *((_DWORD *)result + 3);
  if (a2 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v7 = v6;
  if (v6 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int v8 = 0;
LABEL_12:
    a3 = v8;
    if ((v5 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
LABEL_10:
  a2 = v7;
  if (a3 < 0) {
    goto LABEL_11;
  }
LABEL_5:
  int v8 = v6 - a2;
  if (v8 < a3) {
    goto LABEL_12;
  }
  if ((v5 & 2) == 0)
  {
LABEL_7:
    int v9 = (char *)*((void *)result + 3);
    goto LABEL_14;
  }
LABEL_13:
  int v9 = result + 10;
LABEL_14:
  if (a3 >= 1)
  {
    uint64_t v10 = &v9[2 * a2];
    uint64_t result = (char *)(a4 + 2 * a5);
    if (v10 != result) {
      return (char *)memmove(result, v10, 2 * a3);
    }
  }
  return result;
}

uint64_t icu::UnicodeString::extract(uint64_t a1, UChar **a2, int a3, int *a4)
{
  unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
  if (*(__int16 *)(a1 + 8) < 0) {
    uint64_t v8 = *(unsigned int *)(a1 + 12);
  }
  else {
    uint64_t v8 = v7 >> 5;
  }
  if (*a4 > 0) {
    return v8;
  }
  if (a3 < 0 || (v7 & 1) != 0 || a3 && !*a2)
  {
    *a4 = 1;
    return v8;
  }
  if ((v7 & 2) != 0) {
    int v9 = (const UChar *)(a1 + 10);
  }
  else {
    int v9 = *(const UChar **)(a1 + 24);
  }
  __int16 v11 = *a2;
  if ((int)v8 >= 1 && (int)v8 <= a3)
  {
    if (v9 == v11)
    {
      __int16 v11 = (UChar *)v9;
    }
    else
    {
      u_memcpy(v11, v9, v8);
      __int16 v11 = *a2;
    }
  }

  return u_terminateUChars((uint64_t)v11, a3, v8, a4);
}

uint64_t icu::UnicodeString::extract(uint64_t a1, int a2, uint64_t length, char *cs, int a5)
{
  if (a5 < 0) {
    return 0;
  }
  if (!cs && a5) {
    return 0;
  }
  unsigned int v9 = *(unsigned __int16 *)(a1 + 8);
  if ((*(__int16 *)(a1 + 8) & 0x80000000) == 0)
  {
    signed int v10 = v9 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
LABEL_13:
    int v11 = 0;
    goto LABEL_14;
  }
  signed int v10 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_13;
  }
LABEL_8:
  int v11 = v10;
  if (v10 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_15;
  }
LABEL_14:
  a2 = v11;
  if ((length & 0x80000000) == 0)
  {
LABEL_10:
    uint64_t v12 = (v10 - a2);
    if ((int)v12 >= (int)length) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_15:
  uint64_t v12 = 0;
LABEL_16:
  length = v12;
LABEL_17:
  if ((int)length <= a5)
  {
    if ((v9 & 2) != 0) {
      uint64_t v13 = a1 + 10;
    }
    else {
      uint64_t v13 = *(void *)(a1 + 24);
    }
    u_UCharsToChars((const UChar *)(v13 + 2 * a2), cs, length);
  }
  int v14 = 0;
  return u_terminateChars((uint64_t)cs, a5, length, &v14);
}

icu::UnicodeString *icu::UnicodeString::tempSubString@<X0>(icu::UnicodeString *this@<X0>, int a2@<W1>, int32_t a3@<W2>, icu::UnicodeString *a4@<X8>)
{
  unsigned int v7 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v8 = v7 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_8:
    int v9 = 0;
    goto LABEL_9;
  }
  signed int v8 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_8;
  }
LABEL_3:
  int v9 = v8;
  if (v8 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  a2 = v9;
  if ((a3 & 0x80000000) == 0)
  {
LABEL_5:
    int32_t v10 = v8 - a2;
    if (v10 >= a3) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_10:
  int32_t v10 = 0;
LABEL_11:
  a3 = v10;
LABEL_12:
  if ((v7 & 0x11) != 0) {
    goto LABEL_13;
  }
  if ((v7 & 2) != 0)
  {
    int v11 = (char *)this + 10;
    goto LABEL_18;
  }
  int v11 = (char *)*((void *)this + 3);
  if (!v11)
  {
LABEL_13:
    int v11 = (char *)this + 10;
    a3 = -2;
  }
LABEL_18:
  uint64_t v13 = (const UChar *)&v11[2 * a2];
  return icu::UnicodeString::UnicodeString(a4, 0, &v13, a3);
}

uint64_t icu::UnicodeString::toUTF8(icu::UnicodeString *this, int a2, int32_t srcLength, char *dest, int32_t destCapacity)
{
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_8:
    int v8 = 0;
    goto LABEL_9;
  }
  signed int v7 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_8;
  }
LABEL_3:
  int v8 = v7;
  if (v7 >= a2)
  {
    if ((srcLength & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    int32_t v9 = 0;
    goto LABEL_11;
  }
LABEL_9:
  a2 = v8;
  if (srcLength < 0) {
    goto LABEL_10;
  }
LABEL_5:
  int32_t v9 = v7 - a2;
  if (v9 < srcLength) {
LABEL_11:
  }
    int32_t srcLength = v9;
  int32_t pDestLength = 0;
  UErrorCode pErrorCode = U_ZERO_ERROR;
  if ((v6 & 0x11) != 0)
  {
    int32_t v10 = 0;
  }
  else if ((v6 & 2) != 0)
  {
    int32_t v10 = (char *)this + 10;
  }
  else
  {
    int32_t v10 = (char *)*((void *)this + 3);
  }
  u_strToUTF8WithSub(dest, destCapacity, &pDestLength, (const UChar *)&v10[2 * a2], srcLength, 65533, 0, &pErrorCode);
  return pDestLength;
}

uint64_t icu::UnicodeString::extract(icu::UnicodeString *this, int a2, int32_t a3, char *a4, int32_t a5)
{
  if (!a4 && a5) {
    return 0;
  }
  if (a5 < 0) {
    a5 = 0x7FFFFFFF;
  }
  return icu::UnicodeString::toUTF8(this, a2, a3, a4, a5);
}

uint64_t icu::UnicodeString::extractBetween(icu::UnicodeString *this, int a2, unsigned int a3, icu::UnicodeString *a4)
{
  if (a2 < 0)
  {
    int v5 = 0;
  }
  else
  {
    int v4 = a2;
    if (*((__int16 *)this + 4) < 0)
    {
      int v5 = *((_DWORD *)this + 3);
      if (v5 >= a2)
      {
LABEL_4:
        if ((a3 & 0x80000000) == 0) {
          goto LABEL_5;
        }
LABEL_11:
        int v6 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      int v5 = *((unsigned __int16 *)this + 4) >> 5;
      if (v5 >= a2) {
        goto LABEL_4;
      }
    }
  }
  int v4 = v5;
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_11;
  }
LABEL_5:
  if (*((__int16 *)this + 4) < 0)
  {
    int v6 = *((_DWORD *)this + 3);
    if (v6 >= (int)a3) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  int v6 = *((unsigned __int16 *)this + 4) >> 5;
  if (v6 < a3) {
LABEL_13:
  }
    a3 = v6;
LABEL_14:
  uint64_t v7 = a3 - v4;
  unsigned int v8 = *((unsigned __int16 *)a4 + 4);
  int v9 = (__int16)v8;
  unsigned int v10 = v8 >> 5;
  if (v9 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = *((unsigned int *)a4 + 3);
  }
  return icu::UnicodeString::doReplace(a4, 0, v11, this, v4, v7);
}

void icu::UnicodeString::toUTF8(icu::UnicodeString *this, icu::ByteSink *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*((__int16 *)this + 4) < 0)
  {
    int32_t v4 = *((_DWORD *)this + 3);
    if (!v4) {
      return;
    }
  }
  else
  {
    int32_t v4 = *((unsigned __int16 *)this + 4) >> 5;
    if (!v4) {
      return;
    }
  }
  bzero(v18, 0x400uLL);
  int32_t destCapacity = 1024;
  if (v4 >= 1024) {
    uint64_t v5 = 1024;
  }
  else {
    uint64_t v5 = v4;
  }
  int v6 = (char *)(*(uint64_t (**)(icu::ByteSink *, uint64_t, void, unsigned char *, uint64_t, int32_t *))(*(void *)a2 + 24))(a2, v5, (3 * v4), v18, 1024, &destCapacity);
  uint64_t v7 = v6;
  UErrorCode pErrorCode = U_ZERO_ERROR;
  int32_t pDestLength = 0;
  __int16 v8 = *((_WORD *)this + 4);
  if ((v8 & 0x11) != 0)
  {
    int v9 = 0;
  }
  else if ((v8 & 2) != 0)
  {
    int v9 = (const UChar *)((char *)this + 10);
  }
  else
  {
    int v9 = (const UChar *)*((void *)this + 3);
  }
  u_strToUTF8WithSub(v6, destCapacity, &pDestLength, v9, v4, 65533, 0, &pErrorCode);
  UErrorCode v10 = pErrorCode;
  UErrorCode v11 = pErrorCode;
  if (pErrorCode == U_BUFFER_OVERFLOW_ERROR)
  {
    uint64_t v12 = (char *)uprv_malloc(pDestLength);
    if (!v12) {
      return;
    }
    uint64_t v7 = v12;
    UErrorCode pErrorCode = U_ZERO_ERROR;
    __int16 v13 = *((_WORD *)this + 4);
    if ((v13 & 0x11) != 0)
    {
      int v14 = 0;
    }
    else if ((v13 & 2) != 0)
    {
      int v14 = (const UChar *)((char *)this + 10);
    }
    else
    {
      int v14 = (const UChar *)*((void *)this + 3);
    }
    u_strToUTF8WithSub(v12, pDestLength, &pDestLength, v14, v4, 65533, 0, &pErrorCode);
    UErrorCode v11 = pErrorCode;
  }
  if (v11 <= U_ZERO_ERROR)
  {
    (*(void (**)(icu::ByteSink *, char *, void))(*(void *)a2 + 16))(a2, v7, pDestLength);
    (*(void (**)(icu::ByteSink *))(*(void *)a2 + 32))(a2);
  }
  if (v10 == U_BUFFER_OVERFLOW_ERROR) {
    uprv_free(v7);
  }
}

uint64_t icu::UnicodeString::toUTF32(icu::UnicodeString *this, UChar32 *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  uint64_t v4 = 0;
  int32_t pDestLength = 0;
  if (*(int *)pErrorCode <= 0)
  {
    unsigned int v6 = *((unsigned __int16 *)this + 4);
    if ((v6 & 0x11) != 0)
    {
      uint64_t v7 = 0;
      if ((v6 & 0x8000) != 0) {
        goto LABEL_9;
      }
LABEL_7:
      int32_t v8 = v6 >> 5;
LABEL_10:
      u_strToUTF32WithSub(dest, destCapacity, &pDestLength, v7, v8, 65533, 0, pErrorCode);
      return pDestLength;
    }
    if ((v6 & 2) != 0)
    {
      uint64_t v7 = (const UChar *)((char *)this + 10);
      if ((v6 & 0x8000) == 0) {
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v7 = (const UChar *)*((void *)this + 3);
      if ((v6 & 0x8000) == 0) {
        goto LABEL_7;
      }
    }
LABEL_9:
    int32_t v8 = *((_DWORD *)this + 3);
    goto LABEL_10;
  }
  return v4;
}

uint64_t icu::UnicodeString::indexOf(uint64_t a1, uint64_t a2, unsigned int a3, int32_t a4, int a5, int32_t length)
{
  uint64_t v6 = 0xFFFFFFFFLL;
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (a2)
      {
        unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
        if ((v7 & 1) == 0)
        {
          if (a4 < 0 && !*(_WORD *)(a2 + 2 * a3)) {
            return 0xFFFFFFFFLL;
          }
          if ((v7 & 0x8000) != 0)
          {
            signed int v8 = *(_DWORD *)(a1 + 12);
            if ((a5 & 0x80000000) == 0)
            {
LABEL_9:
              int v9 = v8;
              if (v8 >= a5)
              {
                if ((length & 0x80000000) == 0) {
                  goto LABEL_11;
                }
                goto LABEL_17;
              }
LABEL_16:
              a5 = v9;
              if ((length & 0x80000000) == 0)
              {
LABEL_11:
                int32_t v10 = v8 - a5;
                if (v10 >= length)
                {
                  if ((v7 & 2) == 0)
                  {
LABEL_13:
                    uint64_t v11 = *(void *)(a1 + 24);
                    goto LABEL_20;
                  }
LABEL_19:
                  uint64_t v11 = a1 + 10;
LABEL_20:
                  First = u_strFindFirst((const UChar *)(v11 + 2 * a5), length, (const UChar *)(a2 + 2 * a3), a4);
                  uint64_t v6 = ((unint64_t)First - v11) >> 1;
                  if (First) {
                    return v6;
                  }
                  else {
                    return 0xFFFFFFFFLL;
                  }
                }
LABEL_18:
                length = v10;
                if ((v7 & 2) == 0) {
                  goto LABEL_13;
                }
                goto LABEL_19;
              }
LABEL_17:
              int32_t v10 = 0;
              goto LABEL_18;
            }
          }
          else
          {
            signed int v8 = v7 >> 5;
            if ((a5 & 0x80000000) == 0) {
              goto LABEL_9;
            }
          }
          int v9 = 0;
          goto LABEL_16;
        }
      }
    }
  }
  return v6;
}

uint64_t icu::UnicodeString::doIndexOf(uint64_t a1, UChar a2, int a3, int32_t count)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 8);
  if ((*(__int16 *)(a1 + 8) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }
  signed int v5 = *(_DWORD *)(a1 + 12);
  if (a3 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
LABEL_10:
  a3 = v6;
  if (count < 0) {
    goto LABEL_11;
  }
LABEL_5:
  int32_t v7 = v5 - a3;
  if (v7 < count) {
    goto LABEL_12;
  }
  if ((v4 & 2) == 0)
  {
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 24);
    goto LABEL_14;
  }
LABEL_13:
  uint64_t v8 = a1 + 10;
LABEL_14:
  int v9 = u_memchr((const UChar *)(v8 + 2 * a3), a2, count);
  if (v9) {
    return (((unint64_t)v9 - v8) >> 1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t icu::UnicodeString::doIndexOf(icu::UnicodeString *this, UChar32 a2, int a3, int32_t count)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }
  signed int v5 = *((_DWORD *)this + 3);
  if (a3 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
LABEL_10:
  a3 = v6;
  if (count < 0) {
    goto LABEL_11;
  }
LABEL_5:
  int32_t v7 = v5 - a3;
  if (v7 < count) {
    goto LABEL_12;
  }
  if ((v4 & 2) == 0)
  {
LABEL_7:
    uint64_t v8 = (char *)*((void *)this + 3);
    goto LABEL_14;
  }
LABEL_13:
  uint64_t v8 = (char *)this + 10;
LABEL_14:
  int v9 = u_memchr32((const UChar *)&v8[2 * a3], a2, count);
  if (v9) {
    return ((unint64_t)((char *)v9 - v8) >> 1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t icu::UnicodeString::lastIndexOf(uint64_t a1, uint64_t a2, unsigned int a3, int32_t a4, int a5, int32_t length)
{
  uint64_t v6 = 0xFFFFFFFFLL;
  if (a4)
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (a2)
      {
        unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
        if ((v7 & 1) == 0)
        {
          if (a4 < 0 && !*(_WORD *)(a2 + 2 * a3)) {
            return 0xFFFFFFFFLL;
          }
          if ((v7 & 0x8000) != 0)
          {
            signed int v8 = *(_DWORD *)(a1 + 12);
            if ((a5 & 0x80000000) == 0)
            {
LABEL_9:
              int v9 = v8;
              if (v8 >= a5)
              {
                if ((length & 0x80000000) == 0) {
                  goto LABEL_11;
                }
                goto LABEL_17;
              }
LABEL_16:
              a5 = v9;
              if ((length & 0x80000000) == 0)
              {
LABEL_11:
                int32_t v10 = v8 - a5;
                if (v10 >= length)
                {
                  if ((v7 & 2) == 0)
                  {
LABEL_13:
                    uint64_t v11 = *(void *)(a1 + 24);
                    goto LABEL_20;
                  }
LABEL_19:
                  uint64_t v11 = a1 + 10;
LABEL_20:
                  Last = u_strFindLast((const UChar *)(v11 + 2 * a5), length, (const UChar *)(a2 + 2 * a3), a4);
                  uint64_t v6 = ((unint64_t)Last - v11) >> 1;
                  if (Last) {
                    return v6;
                  }
                  else {
                    return 0xFFFFFFFFLL;
                  }
                }
LABEL_18:
                length = v10;
                if ((v7 & 2) == 0) {
                  goto LABEL_13;
                }
                goto LABEL_19;
              }
LABEL_17:
              int32_t v10 = 0;
              goto LABEL_18;
            }
          }
          else
          {
            signed int v8 = v7 >> 5;
            if ((a5 & 0x80000000) == 0) {
              goto LABEL_9;
            }
          }
          int v9 = 0;
          goto LABEL_16;
        }
      }
    }
  }
  return v6;
}

uint64_t icu::UnicodeString::doLastIndexOf(uint64_t a1, UChar a2, int a3, int32_t count)
{
  unsigned int v4 = *(unsigned __int16 *)(a1 + 8);
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  if ((v4 & 0x8000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_11:
    int v6 = 0;
    goto LABEL_12;
  }
  signed int v5 = *(_DWORD *)(a1 + 12);
  if (a3 < 0) {
    goto LABEL_11;
  }
LABEL_4:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_13:
    int32_t v7 = 0;
LABEL_14:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_8;
    }
    goto LABEL_15;
  }
LABEL_12:
  a3 = v6;
  if (count < 0) {
    goto LABEL_13;
  }
LABEL_6:
  int32_t v7 = v5 - a3;
  if (v7 < count) {
    goto LABEL_14;
  }
  if ((v4 & 2) == 0)
  {
LABEL_8:
    uint64_t v8 = *(void *)(a1 + 24);
    goto LABEL_16;
  }
LABEL_15:
  uint64_t v8 = a1 + 10;
LABEL_16:
  int32_t v10 = u_memrchr((const UChar *)(v8 + 2 * a3), a2, count);
  if (v10) {
    return (((unint64_t)v10 - v8) >> 1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t icu::UnicodeString::doLastIndexOf(icu::UnicodeString *this, UChar32 a2, int a3, int32_t count)
{
  unsigned int v4 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v5 = v4 >> 5;
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    int v6 = 0;
    goto LABEL_10;
  }
  signed int v5 = *((_DWORD *)this + 3);
  if (a3 < 0) {
    goto LABEL_9;
  }
LABEL_3:
  int v6 = v5;
  if (v5 >= a3)
  {
    if ((count & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_11:
    int32_t v7 = 0;
LABEL_12:
    count = v7;
    if ((v4 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
LABEL_10:
  a3 = v6;
  if (count < 0) {
    goto LABEL_11;
  }
LABEL_5:
  int32_t v7 = v5 - a3;
  if (v7 < count) {
    goto LABEL_12;
  }
  if ((v4 & 2) == 0)
  {
LABEL_7:
    uint64_t v8 = (char *)*((void *)this + 3);
    goto LABEL_14;
  }
LABEL_13:
  uint64_t v8 = (char *)this + 10;
LABEL_14:
  int v9 = u_memrchr32((const UChar *)&v8[2 * a3], a2, count);
  if (v9) {
    return ((unint64_t)((char *)v9 - v8) >> 1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

icu::UnicodeString *icu::UnicodeString::findAndReplace(icu::UnicodeString *this, int a2, int32_t length, const icu::UnicodeString *a4, signed int a5, uint64_t a6, const icu::UnicodeString *a7, int a8, int a9)
{
  unsigned int v10 = *((unsigned __int16 *)this + 4);
  if (v10) {
    return this;
  }
  unsigned int v12 = *((unsigned __int16 *)a4 + 4);
  if (v12) {
    return this;
  }
  unsigned int v14 = *((unsigned __int16 *)a7 + 4);
  if (v14) {
    return this;
  }
  int v15 = a8;
  uint64_t v16 = a6;
  signed int v17 = a5;
  int32_t v18 = length;
  int v19 = a2;
  if ((v10 & 0x8000) == 0)
  {
    int v20 = v10 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_11:
    int v21 = 0;
    goto LABEL_12;
  }
  int v20 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_11;
  }
LABEL_6:
  int v21 = v20;
  if (v20 >= a2)
  {
    if ((length & 0x80000000) == 0) {
      goto LABEL_8;
    }
LABEL_13:
    int32_t v22 = 0;
    goto LABEL_14;
  }
LABEL_12:
  int v19 = v21;
  if (length < 0) {
    goto LABEL_13;
  }
LABEL_8:
  int32_t v22 = v20 - v19;
  if (v22 < length) {
LABEL_14:
  }
    int32_t v18 = v22;
  int v23 = (__int16)v12;
  signed int v24 = v12 >> 5;
  if (v23 < 0) {
    signed int v24 = *((_DWORD *)a4 + 3);
  }
  if (a5 < 0)
  {
    signed int v25 = 0;
    goto LABEL_21;
  }
  signed int v25 = v24;
  if (v24 < a5) {
LABEL_21:
  }
    signed int v17 = v25;
  uint64_t v26 = a9;
  if ((a6 & 0x80000000) != 0)
  {
    uint64_t v27 = 0;
    goto LABEL_26;
  }
  uint64_t v27 = (v24 - v17);
  if ((int)v27 < (int)a6) {
LABEL_26:
  }
    uint64_t v16 = v27;
  int v28 = (__int16)v14;
  int v29 = v14 >> 5;
  if (v28 < 0) {
    int v29 = *((_DWORD *)a7 + 3);
  }
  if (a8 < 0)
  {
    int v30 = 0;
  }
  else
  {
    int v30 = v29;
    if (v29 >= a8)
    {
      if ((a9 & 0x80000000) == 0) {
        goto LABEL_32;
      }
      goto LABEL_36;
    }
  }
  int v15 = v30;
  if ((a9 & 0x80000000) == 0)
  {
LABEL_32:
    uint64_t v31 = (v29 - v15);
    if ((int)v31 >= a9) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
LABEL_36:
  uint64_t v31 = 0;
LABEL_37:
  uint64_t v26 = v31;
LABEL_38:
  if (v16 && v18 >= 1 && v18 >= (int)v16)
  {
    uint64_t v43 = (char *)a4 + 10;
    while (1)
    {
      unsigned int v32 = *((unsigned __int16 *)a4 + 4);
      if (v32) {
        return this;
      }
      if ((v32 & 0x8000u) == 0) {
        signed int v33 = v32 >> 5;
      }
      else {
        signed int v33 = *((_DWORD *)a4 + 3);
      }
      if (v17 < 0)
      {
        unsigned int v34 = 0;
      }
      else
      {
        unsigned int v34 = v33;
        unsigned int v35 = v17;
        if (v33 >= v17)
        {
          if ((v16 & 0x80000000) != 0) {
            goto LABEL_53;
          }
          goto LABEL_49;
        }
      }
      unsigned int v35 = v34;
      if ((v16 & 0x80000000) != 0)
      {
LABEL_53:
        int v36 = 0;
LABEL_54:
        int32_t v37 = v36;
        goto LABEL_55;
      }
LABEL_49:
      int v36 = v33 - v35;
      int32_t v37 = v16;
      if (v36 < (int)v16) {
        goto LABEL_54;
      }
LABEL_55:
      if (v37 >= 1)
      {
        uint64_t v38 = (v32 & 2) != 0 ? (uint64_t)v43 : *((void *)a4 + 3);
        uint64_t v39 = icu::UnicodeString::indexOf((uint64_t)this, v38, v35, v37, v19, v18);
        if ((v39 & 0x80000000) == 0)
        {
          int v40 = v39;
          icu::UnicodeString::doReplace(this, v39, v16, a7, v15, v26);
          int32_t v18 = v19 + v18 - v16 - v40;
          int v19 = v40 + v26;
          if (v18 >= 1 && v18 >= (int)v16) {
            continue;
          }
        }
      }
      return this;
    }
  }
  return this;
}

uint64_t icu::UnicodeString::unBogus(uint64_t this)
{
  if (*(_WORD *)(this + 8)) {
    *(_WORD *)(this + 8) = 2;
  }
  return this;
}

uint64_t icu::UnicodeString::getTerminatedBuffer(icu::UnicodeString *this)
{
  unsigned int v1 = *((unsigned __int16 *)this + 4);
  if ((v1 & 0x11) != 0) {
    return 0;
  }
  if ((v1 & 2) == 0)
  {
    uint64_t result = *((void *)this + 3);
    if ((v1 & 0x8000) == 0) {
      goto LABEL_6;
    }
LABEL_9:
    int v4 = *((_DWORD *)this + 3);
    if ((v1 & 2) == 0) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }
  uint64_t result = (uint64_t)this + 10;
  if ((v1 & 0x8000) != 0) {
    goto LABEL_9;
  }
LABEL_6:
  int v4 = v1 >> 5;
  if ((v1 & 2) == 0)
  {
LABEL_7:
    int v5 = *((_DWORD *)this + 4);
    goto LABEL_11;
  }
LABEL_10:
  int v5 = 27;
LABEL_11:
  if (v4 >= v5)
  {
    if (v4 == 0x7FFFFFFF) {
      return 0;
    }
    goto LABEL_19;
  }
  if ((v1 & 8) == 0)
  {
    if ((v1 & 4) == 0
      || atomic_load_explicit((atomic_uint *volatile)(*((void *)this + 3) - 4), memory_order_acquire) == 1)
    {
      goto LABEL_23;
    }
LABEL_19:
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v4 + 1, -1, 1, 0, 0))
    {
      if ((*((_WORD *)this + 4) & 2) != 0) {
        uint64_t result = (uint64_t)this + 10;
      }
      else {
        uint64_t result = *((void *)this + 3);
      }
LABEL_23:
      *(_WORD *)(result + 2 * v4) = 0;
      return result;
    }
    return 0;
  }
  if (*(_WORD *)(result + 2 * v4)) {
    goto LABEL_19;
  }
  return result;
}

icu::UnicodeString *icu::UnicodeString::setTo(icu::UnicodeString *this, int a2, const UChar **a3, int a4)
{
  __int16 v5 = *((_WORD *)this + 4);
  if ((v5 & 0x10) == 0)
  {
    int v6 = *a3;
    if (*a3)
    {
      int32_t v7 = a4;
      if (a4 < -1 || !a2 && a4 == -1 || a2 && (a4 & 0x80000000) == 0 && v6[a4])
      {
        icu::UnicodeString::setToBogus(this);
      }
      else
      {
        if ((v5 & 4) != 0 && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1) {
          uprv_free((void *)(*((void *)this + 3) - 4));
        }
        if (v7 == -1) {
          int32_t v7 = u_strlen(v6);
        }
        if (a2) {
          int32_t v9 = v7 + 1;
        }
        else {
          int32_t v9 = v7;
        }
        if (v7 > 1023)
        {
          *((_DWORD *)this + 3) = v7;
          __int16 v10 = -24;
        }
        else
        {
          __int16 v10 = (32 * v7) | 8;
        }
        *((_WORD *)this + 4) = v10;
        *((void *)this + 3) = v6;
        *((_DWORD *)this + 4) = v9;
      }
    }
    else
    {
      if ((v5 & 4) != 0 && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1) {
        uprv_free((void *)(*((void *)this + 3) - 4));
      }
      *((_WORD *)this + 4) = 2;
    }
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::setTo(icu::UnicodeString *this, char *a2, int a3, unsigned int a4)
{
  __int16 v5 = *((_WORD *)this + 4);
  if ((v5 & 0x10) == 0)
  {
    if (a2)
    {
      LODWORD(v8) = a3;
      if (a3 > (int)a4 || a3 < -1 || (a4 & 0x80000000) != 0)
      {
        icu::UnicodeString::setToBogus(this);
      }
      else
      {
        if (a3 == -1)
        {
          int32_t v9 = a2;
          if (a4)
          {
            uint64_t v10 = 2 * a4;
            int32_t v9 = a2;
            while (*(_WORD *)v9)
            {
              v9 += 2;
              v10 -= 2;
              if (!v10)
              {
                int32_t v9 = &a2[2 * a4];
                break;
              }
            }
          }
          unint64_t v8 = (unint64_t)(v9 - a2) >> 1;
        }
        if ((v5 & 4) != 0 && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1) {
          uprv_free((void *)(*((void *)this + 3) - 4));
        }
        if ((int)v8 > 1023)
        {
          *((_DWORD *)this + 3) = v8;
          __int16 v11 = -32;
        }
        else
        {
          __int16 v11 = 32 * v8;
        }
        *((_WORD *)this + 4) = v11;
        *((void *)this + 3) = a2;
        *((_DWORD *)this + 4) = a4;
      }
    }
    else
    {
      if ((v5 & 4) != 0 && atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 3) - 4), 0xFFFFFFFF) == 1) {
        uprv_free((void *)(*((void *)this + 3) - 4));
      }
      *((_WORD *)this + 4) = 2;
    }
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::setCharAt(icu::UnicodeString *this, int a2, __int16 a3)
{
  if (*((__int16 *)this + 4) < 0) {
    int v6 = *((_DWORD *)this + 3);
  }
  else {
    int v6 = *((unsigned __int16 *)this + 4) >> 5;
  }
  if (icu::UnicodeString::cloneArrayIfNeeded(this, -1, -1, 1, 0, 0))
  {
    int v7 = v6 - 1;
    if (v6 >= 1)
    {
      if (v6 > a2) {
        int v7 = a2;
      }
      if (a2 < 0) {
        int v7 = 0;
      }
      if ((*((_WORD *)this + 4) & 2) != 0) {
        unint64_t v8 = (char *)this + 10;
      }
      else {
        unint64_t v8 = (char *)*((void *)this + 3);
      }
      *(_WORD *)&v8[2 * v7] = a3;
    }
  }
  return this;
}

uint64_t icu::UnicodeString::replace(icu::UnicodeString *this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int v6 = 0;
  if (HIWORD(a4))
  {
    if (HIWORD(a4) > 0x10u)
    {
      uint64_t v4 = 0;
    }
    else
    {
      LOWORD(v6) = (a4 >> 10) - 10304;
      HIWORD(v6) = a4 & 0x3FF | 0xDC00;
      uint64_t v4 = 2;
    }
  }
  else
  {
    LOWORD(v6) = a4;
    uint64_t v4 = 1;
  }
  return icu::UnicodeString::doReplace((uint64_t)this, a2, a3, (uint64_t)&v6, 0, v4);
}

uint64_t icu::UnicodeString::doReplace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6 = a1;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
  if ((v7 & 0x11) != 0) {
    return v6;
  }
  uint64_t v9 = a6;
  uint64_t v10 = a3;
  uint64_t v11 = a2;
  unsigned __int16 v12 = *(_WORD *)(a1 + 8);
  if ((__int16)v7 < 0)
  {
    int32_t v13 = *(_DWORD *)(a1 + 12);
    if (a6) {
      goto LABEL_21;
    }
  }
  else
  {
    int32_t v13 = v7 >> 5;
    if (a6) {
      goto LABEL_21;
    }
  }
  if ((v7 & 8) == 0) {
    goto LABEL_21;
  }
  if (!a2)
  {
    if ((a3 & 0x80000000) != 0)
    {
      int v15 = 0;
    }
    else if ((__int16)v7 < 0)
    {
      int v15 = *(_DWORD *)(a1 + 12);
      if (v15 >= (int)a3) {
        goto LABEL_55;
      }
    }
    else
    {
      int v15 = v7 >> 5;
      if (v15 >= a3)
      {
LABEL_55:
        *(void *)(a1 + 24) += 2 * (int)v10;
        *(_DWORD *)(a1 + 16) -= v10;
        int v24 = v13 - v10;
        if (v13 - (int)v10 > 1023)
        {
          *(_WORD *)(a1 + 8) = v12 | 0xFFE0;
          *(_DWORD *)(a1 + 12) = v24;
        }
        else
        {
          *(_WORD *)(a1 + 8) = v12 & 0x1F | (32 * v24);
        }
        return v6;
      }
    }
    LODWORD(v10) = v15;
    goto LABEL_55;
  }
  if ((a2 & 0x80000000) != 0)
  {
    uint64_t v14 = 0;
    goto LABEL_19;
  }
  if ((__int16)v7 < 0)
  {
    uint64_t v14 = *(unsigned int *)(a1 + 12);
    if ((int)v14 >= (int)a2) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v14 = v7 >> 5;
  if (v14 < a2) {
LABEL_19:
  }
    uint64_t v11 = v14;
LABEL_20:
  if (v13 - (int)v11 <= (int)a3)
  {
    if ((int)v11 > 1023)
    {
      __int16 v17 = v12 | 0xFFE0;
      *(_DWORD *)(a1 + 12) = v11;
    }
    else
    {
      __int16 v17 = *(_WORD *)(a1 + 8) & 0x1F | (32 * v11);
    }
    *(_WORD *)(a1 + 8) = v17;
    *(_DWORD *)(a1 + 16) = v11;
    return v6;
  }
LABEL_21:
  if (v11 != v13)
  {
    if (a4)
    {
      uint64_t v16 = (const UChar *)(a4 + 2 * a5);
      if ((a6 & 0x80000000) != 0)
      {
        uint64_t v9 = u_strlen((const UChar *)(a4 + 2 * a5));
        unsigned __int16 v12 = *(_WORD *)(v6 + 8);
      }
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v9 = 0;
    }
    if ((v12 & 0x8000) != 0)
    {
      uint64_t v18 = *(unsigned int *)(v6 + 12);
      if ((v11 & 0x80000000) == 0)
      {
LABEL_33:
        uint64_t v19 = v18;
        if ((int)v11 <= (int)v18)
        {
          if ((v10 & 0x80000000) == 0) {
            goto LABEL_35;
          }
          goto LABEL_40;
        }
LABEL_39:
        uint64_t v11 = v19;
        if ((v10 & 0x80000000) == 0)
        {
LABEL_35:
          uint64_t v20 = (v18 - v11);
          if ((int)v20 >= (int)v10)
          {
LABEL_42:
            if ((int)v9 > (int)((v13 - v10) ^ 0x7FFFFFFF))
            {
              icu::UnicodeString::setToBogus((icu::UnicodeString *)v6);
              return v6;
            }
            int v21 = v12 & 2;
            if ((v12 & 2) != 0) {
              int32_t v22 = (const UChar *)(v6 + 10);
            }
            else {
              int32_t v22 = *(const UChar **)(v6 + 24);
            }
            if ((v12 & 0x19) == 0)
            {
              BOOL v23 = (v12 & 4) == 0
                 || atomic_load_explicit((atomic_uint *volatile)(*(void *)(v6 + 24) - 4), memory_order_acquire) == 1;
              if (v23 && v22 < &v16[(int)v9] && v16 < &v22[v13])
              {
                memset(&dest[8], 0, 48);
                uint64_t v36 = 0;
                *(void *)dest = &unk_1EDA47700;
                *(_WORD *)&UChar dest[8] = 2;
                icu::UnicodeString::doAppend((uint64_t)dest, (uint64_t)v16, 0, v9);
                if (dest[8])
                {
                  icu::UnicodeString::setToBogus((icu::UnicodeString *)v6);
                }
                else
                {
                  if ((dest[8] & 2) != 0) {
                    signed int v25 = &dest[10];
                  }
                  else {
                    signed int v25 = *(unsigned char **)&dest[24];
                  }
                  uint64_t v6 = icu::UnicodeString::doReplace(v6, v11, v10, v25, 0, v9);
                }
                icu::UnicodeString::~UnicodeString((icu::UnicodeString *)dest);
                return v6;
              }
              int v21 = *(_WORD *)(v6 + 8) & 2;
            }
            int v26 = v13 - v10 + v9;
            memset(dest, 0, 54);
            if (v21 && v26 >= 28)
            {
              u_memcpy((UChar *)dest, v22, v13);
              int32_t v22 = (const UChar *)dest;
            }
            unsigned int v34 = 0;
            int v27 = (v26 >> 2) + 128;
            if (v27 <= 2147483637 - v26) {
              int v28 = v27 + v26;
            }
            else {
              int v28 = 2147483637;
            }
            if (!icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v6, v26, v28, 0, &v34, 0)) {
              return v6;
            }
            if ((*(_WORD *)(v6 + 8) & 2) != 0) {
              int v29 = (UChar *)(v6 + 10);
            }
            else {
              int v29 = *(UChar **)(v6 + 24);
            }
            if (v29 == v22)
            {
              if (v10 == v9) {
                goto LABEL_87;
              }
              int v30 = v10 + v11;
              int v31 = v13 - (v10 + v11);
              if (v31 < 1) {
                goto LABEL_87;
              }
              unsigned int v32 = v22;
            }
            else
            {
              if ((int)v11 >= 1) {
                memmove(v29, v22, 2 * v11);
              }
              int v30 = v10 + v11;
              int v31 = v13 - (v10 + v11);
              if (v13 <= (int)v10 + (int)v11) {
                goto LABEL_87;
              }
              unsigned int v32 = v29;
            }
            memmove((void *)&v32[(int)v11 + (int)v9], &v22[v30], 2 * v31);
LABEL_87:
            if ((int)v9 >= 1) {
              memmove(&v29[(int)v11], v16, 2 * v9);
            }
            if (v26 > 1023)
            {
              __int16 v33 = *(_WORD *)(v6 + 8) | 0xFFE0;
              *(_DWORD *)(v6 + 12) = v26;
            }
            else
            {
              __int16 v33 = *(_WORD *)(v6 + 8) & 0x1F | (32 * v26);
            }
            *(_WORD *)(v6 + 8) = v33;
            if (v34) {
              uprv_free(v34);
            }
            return v6;
          }
LABEL_41:
          uint64_t v10 = v20;
          goto LABEL_42;
        }
LABEL_40:
        uint64_t v20 = 0;
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v18 = v12 >> 5;
      if ((v11 & 0x80000000) == 0) {
        goto LABEL_33;
      }
    }
    uint64_t v19 = 0;
    goto LABEL_39;
  }

  return icu::UnicodeString::doAppend(a1, a4, a5, a6);
}

uint64_t icu::UnicodeString::doReplace(icu::UnicodeString *this, uint64_t a2, uint64_t a3, const icu::UnicodeString *a4, int a5, uint64_t a6)
{
  unsigned int v6 = *((unsigned __int16 *)a4 + 4);
  if ((v6 & 0x8000u) == 0) {
    int v7 = v6 >> 5;
  }
  else {
    int v7 = *((_DWORD *)a4 + 3);
  }
  if (a5 < 0)
  {
    int v8 = 0;
  }
  else
  {
    int v8 = v7;
    if (v7 >= a5)
    {
      if ((a6 & 0x80000000) == 0) {
        goto LABEL_7;
      }
LABEL_11:
      uint64_t v9 = 0;
      goto LABEL_12;
    }
  }
  a5 = v8;
  if ((a6 & 0x80000000) != 0) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v9 = (v7 - a5);
  if ((int)v9 < (int)a6) {
LABEL_12:
  }
    a6 = v9;
  if ((v6 & 2) != 0) {
    uint64_t v10 = (char *)a4 + 10;
  }
  else {
    uint64_t v10 = (char *)*((void *)a4 + 3);
  }
  return icu::UnicodeString::doReplace((uint64_t)this, a2, a3, (uint64_t)v10, a5, a6);
}

uint64_t icu::UnicodeString::doAppend(uint64_t this, const icu::UnicodeString *a2, int a3, uint64_t a4)
{
  if (!a4) {
    return this;
  }
  unsigned int v4 = *((unsigned __int16 *)a2 + 4);
  if ((v4 & 0x8000u) == 0) {
    int v5 = v4 >> 5;
  }
  else {
    int v5 = *((_DWORD *)a2 + 3);
  }
  if (a3 < 0)
  {
    int v6 = 0;
  }
  else
  {
    int v6 = v5;
    if (v5 >= a3)
    {
      if ((a4 & 0x80000000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
  }
  a3 = v6;
  if ((a4 & 0x80000000) == 0)
  {
LABEL_8:
    uint64_t v7 = (v5 - a3);
    if ((int)v7 >= (int)a4) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
LABEL_13:
  uint64_t v7 = 0;
LABEL_14:
  a4 = v7;
LABEL_15:
  if ((v4 & 2) != 0) {
    int v8 = (char *)a2 + 10;
  }
  else {
    int v8 = (char *)*((void *)a2 + 3);
  }
  return icu::UnicodeString::doAppend(this, (uint64_t)v8, a3, a4);
}

uint64_t icu::UnicodeString::handleReplaceBetween(icu::UnicodeString *this, uint64_t a2, int a3, const icu::UnicodeString *a4)
{
  uint64_t v4 = (a3 - a2);
  unsigned int v5 = *((unsigned __int16 *)a4 + 4);
  int v6 = (__int16)v5;
  unsigned int v7 = v5 >> 5;
  if (v6 >= 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = *((unsigned int *)a4 + 3);
  }
  return icu::UnicodeString::doReplace(this, a2, v4, a4, 0, v8);
}

void icu::UnicodeString::copy(icu::UnicodeString *this, int a2, signed int a3, uint64_t a4)
{
  uint64_t v4 = (a3 - a2);
  if (a3 <= a2) {
    return;
  }
  unsigned int v6 = a3;
  int v7 = a2;
  uint64_t v9 = uprv_malloc(2 * (int)v4);
  if (!v9) {
    return;
  }
  uint64_t v10 = v9;
  if (v7 < 0)
  {
    int v11 = 0;
  }
  else if (*((__int16 *)this + 4) < 0)
  {
    int v11 = *((_DWORD *)this + 3);
    if (v11 >= v7)
    {
LABEL_6:
      if ((v6 & 0x80000000) == 0) {
        goto LABEL_7;
      }
LABEL_14:
      int v12 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    int v11 = *((unsigned __int16 *)this + 4) >> 5;
    if (v11 >= v7) {
      goto LABEL_6;
    }
  }
  int v7 = v11;
  if ((v6 & 0x80000000) != 0) {
    goto LABEL_14;
  }
LABEL_7:
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    int v12 = *((unsigned __int16 *)this + 4) >> 5;
    if (v12 >= v6) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  int v12 = *((_DWORD *)this + 3);
  if (v12 < (int)v6) {
LABEL_16:
  }
    unsigned int v6 = v12;
LABEL_17:
  icu::UnicodeString::doExtract((char *)this, v7, v6 - v7, (uint64_t)v9, 0);
  icu::UnicodeString::doReplace((uint64_t)this, a4, 0, (uint64_t)v10, 0, v4);

  uprv_free(v10);
}

uint64_t icu::Replaceable::hasMetaData(icu::Replaceable *this)
{
  return 1;
}

uint64_t icu::UnicodeString::hasMetaData(icu::UnicodeString *this)
{
  return 0;
}

icu::UnicodeString *icu::UnicodeString::doReverse(icu::UnicodeString *this, int a2, int a3)
{
  if (a3 < 2) {
    return this;
  }
  int v4 = a3;
  if (!icu::UnicodeString::cloneArrayIfNeeded(this, -1, -1, 1, 0, 0)) {
    return this;
  }
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if ((*((__int16 *)this + 4) & 0x80000000) == 0)
  {
    signed int v7 = v6 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_8:
    int v8 = 0;
    goto LABEL_9;
  }
  signed int v7 = *((_DWORD *)this + 3);
  if (a2 < 0) {
    goto LABEL_8;
  }
LABEL_5:
  int v8 = v7;
  if (v7 < a2) {
LABEL_9:
  }
    a2 = v8;
  int v9 = v7 - a2;
  if (v9 >= v4 || (int v4 = v9, v9 >= 2))
  {
    uint64_t v10 = (v6 & 2) != 0 ? (icu::UnicodeString *)((char *)this + 10) : (icu::UnicodeString *)*((void *)this + 3);
    int v11 = 0;
    int v12 = (__int16 *)((char *)v10 + 2 * a2);
    unint64_t v13 = (unint64_t)v10 + 2 * a2 + 2 * v4 - 4;
    do
    {
      __int16 v14 = *v12;
      BOOL v15 = (*v12 & 0xFC00) == 55296;
      __int16 v16 = *(_WORD *)(v13 + 2);
      *v12++ = v16;
      v11 |= v15 || (v16 & 0xFC00) == 55296;
      *(_WORD *)(v13 + 2) = v14;
      BOOL v17 = (unint64_t)v12 >= v13;
      v13 -= 2;
    }
    while (!v17);
    if (v11 | ((*v12 & 0xFC00) == 55296))
    {
      uint64_t v18 = (*((_WORD *)this + 4) & 2) != 0
          ? (icu::UnicodeString *)((char *)this + 10)
          : (icu::UnicodeString *)*((void *)this + 3);
      uint64_t v19 = (__int16 *)((char *)v18 + 2 * a2);
      unint64_t v20 = (unint64_t)&v19[v4 - 1];
      while ((unint64_t)v19 < v20)
      {
        __int16 v21 = *v19;
        if ((*v19 & 0xFC00) == 0xDC00 && (__int16 v22 = v19[1], (v22 & 0xFC00) == 0xD800))
        {
          *uint64_t v19 = v22;
          v19[1] = v21;
          v19 += 2;
        }
        else
        {
          ++v19;
        }
      }
    }
  }
  return this;
}

uint64_t icu::UnicodeString::padLeading(icu::UnicodeString *this, int a2, __int16 a3)
{
  if (*((__int16 *)this + 4) < 0) {
    int v6 = *((_DWORD *)this + 3);
  }
  else {
    int v6 = *((unsigned __int16 *)this + 4) >> 5;
  }
  int v7 = a2 - v6;
  if (a2 <= v6) {
    return 0;
  }
  uint64_t result = icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0, 0);
  if (result)
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      int v9 = (char *)this + 10;
    }
    else {
      int v9 = (char *)*((void *)this + 3);
    }
    if (v6 >= 1) {
      memmove(&v9[2 * v7], v9, 2 * v6);
    }
    if (v7 >= 1)
    {
      uint64_t v10 = -1;
      do
        *(_WORD *)&v9[2 * (v7 + v10--)] = a3;
      while (v7 + (int)v10 + 2 > 1);
    }
    if (a2 > 1023)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a2;
    }
    else
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * a2);
    }
    return 1;
  }
  return result;
}

uint64_t icu::UnicodeString::padTrailing(icu::UnicodeString *this, int a2, __int16 a3)
{
  if (*((__int16 *)this + 4) < 0) {
    int v6 = *((_DWORD *)this + 3);
  }
  else {
    int v6 = *((unsigned __int16 *)this + 4) >> 5;
  }
  if (v6 >= a2) {
    return 0;
  }
  uint64_t result = icu::UnicodeString::cloneArrayIfNeeded(this, a2, -1, 1, 0, 0);
  if (result)
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      int v8 = (char *)this + 10;
    }
    else {
      int v8 = (char *)*((void *)this + 3);
    }
    uint64_t v9 = a2;
    uint64_t v10 = v8 - 2;
    do
      *(_WORD *)&v10[2 * v9--] = a3;
    while (v9 > v6);
    if (a2 > 1023)
    {
      *((_WORD *)this + 4) |= 0xFFE0u;
      *((_DWORD *)this + 3) = a2;
    }
    else
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * a2);
    }
    return 1;
  }
  return result;
}

uint64_t icu::UnicodeString::doHashCode(icu::UnicodeString *this)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if ((v2 & 2) != 0)
  {
    unsigned int v3 = (unsigned __int16 *)((char *)this + 10);
    if ((v2 & 0x8000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v3 = (unsigned __int16 *)*((void *)this + 3);
    if ((v2 & 0x8000) == 0)
    {
LABEL_3:
      int v4 = v2 >> 5;
      goto LABEL_6;
    }
  }
  int v4 = *((_DWORD *)this + 3);
LABEL_6:
  LODWORD(result) = ustr_hashUCharsN(v3, v4);
  if (result <= 1) {
    return 1;
  }
  else {
    return result;
  }
}

void icu::UnicodeStringAppendable::~UnicodeStringAppendable(icu::UnicodeStringAppendable *this)
{
  icu::Appendable::~Appendable(this);

  icu::UMemory::operator delete(v1);
}

BOOL icu::UnicodeStringAppendable::appendCodeUnit(uint64_t a1, __int16 a2)
{
  __int16 v3 = a2;
  return (*(_WORD *)(icu::UnicodeString::doAppend(*(void *)(a1 + 8), (uint64_t)&v3, 0, 1) + 8) & 0x11) == 0;
}

BOOL icu::UnicodeStringAppendable::appendCodePoint(icu::UnicodeStringAppendable *this, unsigned int a2)
{
  int v4 = 0;
  if (!HIWORD(a2))
  {
    LOWORD(v4) = a2;
    uint64_t v2 = 1;
    return (*(_WORD *)(icu::UnicodeString::doAppend(*((void *)this + 1), (uint64_t)&v4, 0, v2) + 8) & 0x11) == 0;
  }
  if (HIWORD(a2) <= 0x10u)
  {
    LOWORD(v4) = (a2 >> 10) - 10304;
    HIWORD(v4) = a2 & 0x3FF | 0xDC00;
    uint64_t v2 = 2;
    return (*(_WORD *)(icu::UnicodeString::doAppend(*((void *)this + 1), (uint64_t)&v4, 0, v2) + 8) & 0x11) == 0;
  }
  return 0;
}

BOOL icu::UnicodeStringAppendable::appendString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_WORD *)(icu::UnicodeString::doAppend(*(void *)(a1 + 8), a2, 0, a3) + 8) & 0x11) == 0;
}

uint64_t icu::UnicodeStringAppendable::reserveAppendCapacity(icu::UnicodeStringAppendable *this, int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (*(__int16 *)(v2 + 8) < 0) {
    int v3 = *(_DWORD *)(v2 + 12);
  }
  else {
    int v3 = *(unsigned __int16 *)(v2 + 8) >> 5;
  }
  return icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v2, v3 + a2, -1, 1, 0, 0);
}

uint64_t icu::UnicodeStringAppendable::getAppendBuffer(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int *a6)
{
  if (a2 < 1 || a5 < a2)
  {
    a4 = 0;
    *a6 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 8);
    if (*(__int16 *)(v10 + 8) < 0) {
      int v11 = *(_DWORD *)(v10 + 12);
    }
    else {
      int v11 = *(unsigned __int16 *)(v10 + 8) >> 5;
    }
    BOOL v12 = 2147483637 - v11 < a2 || 2147483637 - v11 < a3;
    if (v12
      || !icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)v10, v11 + a2, v11 + a3, 1, 0, 0))
    {
      *a6 = a5;
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 8);
      if ((*(_WORD *)(v13 + 8) & 2) != 0) {
        int v14 = 27;
      }
      else {
        int v14 = *(_DWORD *)(v13 + 16);
      }
      *a6 = v14 - v11;
      if ((*(_WORD *)(v13 + 8) & 2) != 0) {
        uint64_t v15 = v13 + 10;
      }
      else {
        uint64_t v15 = *(void *)(v13 + 24);
      }
      return v15 + 2 * v11;
    }
  }
  return a4;
}

icu::UnicodeString *uhash_hashUnicodeString(icu::UnicodeString *result)
{
  if (result) {
    return (icu::UnicodeString *)icu::UnicodeString::doHashCode(result);
  }
  return result;
}

BOOL uhash_compareUnicodeString(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    unsigned int v3 = *(unsigned __int16 *)(a1 + 8);
    if (v3)
    {
      return *(_WORD *)(a2 + 8) & 1;
    }
    else
    {
      if ((v3 & 0x8000) != 0) {
        int v4 = *(_DWORD *)(a1 + 12);
      }
      else {
        int v4 = v3 >> 5;
      }
      uint64_t v2 = 0;
      unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
      if ((v5 & 0x8000u) == 0) {
        unsigned int v6 = v5 >> 5;
      }
      else {
        unsigned int v6 = *(_DWORD *)(a2 + 12);
      }
      if ((v5 & 1) == 0 && v4 == v6) {
        return icu::UnicodeString::doEquals((icu::UnicodeString *)a1, (const icu::UnicodeString *)a2, v4);
      }
    }
  }
  return v2;
}

uint64_t icu::UnicodeString::doCaseCompare(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int32_t a6, __int16 a7)
{
  unsigned int v7 = *(unsigned __int16 *)(a1 + 8);
  if (v7) {
    return -1;
  }
  if ((v7 & 0x8000) == 0)
  {
    signed int v9 = v7 >> 5;
    if ((a2 & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_10:
    int v10 = 0;
    goto LABEL_11;
  }
  signed int v9 = *(_DWORD *)(a1 + 12);
  if (a2 < 0) {
    goto LABEL_10;
  }
LABEL_4:
  int v10 = v9;
  if (v9 >= a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  a2 = v10;
  if ((a3 & 0x80000000) == 0)
  {
LABEL_6:
    int v11 = v9 - a2;
    if (v11 >= a3) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_12:
  int v11 = 0;
LABEL_13:
  a3 = v11;
LABEL_14:
  if (a4) {
    int32_t v13 = a6;
  }
  else {
    int32_t v13 = 0;
  }
  if ((v7 & 2) != 0) {
    uint64_t v14 = a1 + 10;
  }
  else {
    uint64_t v14 = *(void *)(a1 + 24);
  }
  uint64_t v15 = (UChar *)(v14 + 2 * a2);
  if (a4) {
    uint64_t v16 = a5;
  }
  else {
    uint64_t v16 = 0;
  }
  BOOL v17 = (UChar *)(a4 + 2 * v16);
  if (v15 == v17)
  {
    if (v13 < 0) {
      int32_t v13 = u_strlen(&v15[v16]);
    }
    unsigned int v20 = a3 - v13;
    if (v20)
    {
      unsigned int v19 = HIBYTE(v20);
      return (char)(v19 | 1);
    }
  }
  else
  {
    int v22 = 0;
    unsigned int v18 = sub_18C8B4884(v15, a3, v17, v13, a7, &v22);
    if (v18)
    {
      unsigned int v19 = HIBYTE(v18);
      return (char)(v19 | 1);
    }
  }
  return 0;
}

icu::UnicodeString *icu::UnicodeString::caseMap(UChar **this, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *((unsigned __int16 *)this + 4);
  if (v6 >= 0x20 && (v6 & 0x11) == 0)
  {
    long long v82 = 0u;
    memset(v83, 0, sizeof(v83));
    long long v80 = 0u;
    long long v81 = 0u;
    *(_OWORD *)dest = 0u;
    long long v79 = 0u;
    if ((v6 & 0x8000) != 0) {
      uint64_t v12 = *((unsigned int *)this + 3);
    }
    else {
      uint64_t v12 = v6 >> 5;
    }
    if ((v6 & 0x19) != 0) {
      BOOL v13 = 0;
    }
    else {
      BOOL v13 = (v6 & 4) == 0 || icu::UnicodeString::refCount((icu::UnicodeString *)this) == 1;
    }
    UErrorCode v47 = U_ZERO_ERROR;
    long long v74 = 0u;
    uint64_t v77 = 0;
    long long v76 = 0u;
    long long v75 = 0u;
    int v73 = &unk_1EDA47700;
    LOWORD(v74) = 2;
    if (v13)
    {
      if ((int)v12 >= 55) {
        goto LABEL_16;
      }
    }
    else if ((int)v12 > 26)
    {
LABEL_16:
      if (((_WORD)this[1] & 2) != 0) {
        uint64_t v14 = (UChar *)this + 5;
      }
      else {
        uint64_t v14 = this[3];
      }
      long long v34 = 0uLL;
      long long v45 = 0uLL;
      long long v44 = 0uLL;
      long long v43 = 0uLL;
      long long v42 = 0uLL;
      long long v41 = 0uLL;
      long long v40 = 0uLL;
      long long v39 = 0uLL;
      long long v38 = 0uLL;
      long long v37 = 0uLL;
      long long v36 = 0uLL;
      long long v35 = 0uLL;
      int v30 = (unsigned __int16 *)&v33[2];
      int v31 = 100;
      *(void *)unsigned int v32 = 0;
      memset(v33, 0, sizeof(v33));
      long long v71 = 0uLL;
      long long v72 = 0uLL;
      long long v69 = 0uLL;
      long long v70 = 0uLL;
      long long v67 = 0uLL;
      long long v68 = 0uLL;
      long long v65 = 0uLL;
      long long v66 = 0uLL;
      long long v63 = 0uLL;
      long long v64 = 0uLL;
      long long v61 = 0uLL;
      long long v62 = 0uLL;
      long long v59 = 0uLL;
      long long v60 = 0uLL;
      long long v57 = 0uLL;
      long long v58 = 0uLL;
      long long v55 = 0uLL;
      long long v56 = 0uLL;
      long long v53 = 0uLL;
      long long v54 = 0uLL;
      long long v51 = 0uLL;
      long long v52 = 0uLL;
      long long v49 = 0uLL;
      long long v50 = 0uLL;
      *(_OWORD *)int v48 = 0uLL;
      if (a4)
      {
        int v29 = v14;
        icu::UnicodeString::setTo((icu::UnicodeString *)&v73, 0, (const UChar **)&v29, v12);
        (*(void (**)(uint64_t, void **))(*(void *)a4 + 56))(a4, &v73);
      }
      a5(a2, a3 | 0x4000, a4, v48, 200, v14, v12, &v30, &v47);
      if (v47 <= U_ZERO_ERROR)
      {
        if (v32[1] >= 1
          && !icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, v32[1] + (int)v12, v32[1] + (int)v12, 1, 0, 0))
        {
          goto LABEL_51;
        }
        *(_OWORD *)int v27 = 0u;
        long long v28 = 0u;
        long long v26 = 0u;
        icu::Edits::Iterator::Iterator((uint64_t)&v26, v30, v32[0], 1, 1);
        while (icu::Edits::Iterator::next((icu::Edits::Iterator *)&v26, v27[4], &v47))
          icu::UnicodeString::doReplace((uint64_t)this, DWORD2(v28), *(unsigned int *)&v27[8], (uint64_t)v48, SDWORD1(v28), *(unsigned int *)&v27[12]);
        if (v47 < U_ILLEGAL_ARGUMENT_ERROR) {
          goto LABEL_51;
        }
      }
      else if (v47 == U_BUFFER_OVERFLOW_ERROR)
      {
        int v16 = v32[1] + v12;
        icu::Edits::~Edits((void **)&v30);
LABEL_39:
        v48[0] = 0;
        if (icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, v16, v16, 0, v48, 1))
        {
          UErrorCode v47 = U_ZERO_ERROR;
          if (((_WORD)this[1] & 2) != 0)
          {
            unsigned int v20 = (UChar *)this + 5;
            uint64_t v21 = 27;
          }
          else
          {
            unsigned int v20 = this[3];
            uint64_t v21 = *((unsigned int *)this + 4);
          }
          int v23 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, void, UErrorCode *))a5)(a2, a3, a4, v20, v21, v14, v12, 0, &v47);
          if (v48[0]) {
            uprv_free(v48[0]);
          }
          if (v47 > U_ZERO_ERROR) {
            goto LABEL_56;
          }
          int v24 = *((unsigned __int16 *)this + 4);
          if (v23 > 1023)
          {
            unsigned int v18 = (void *)(v24 | 0xFFE0u);
            *((_WORD *)this + 4) = (_WORD)v18;
            *((_DWORD *)this + 3) = v23;
            goto LABEL_62;
          }
          unsigned int v18 = (void *)(v24 & 0x1F | (32 * v23));
LABEL_60:
          *((_WORD *)this + 4) = (_WORD)v18;
        }
LABEL_62:
        icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v73);
        return (icu::UnicodeString *)this;
      }
      icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
LABEL_51:
      icu::Edits::~Edits((void **)&v30);
      goto LABEL_62;
    }
    if (((_WORD)this[1] & 2) != 0) {
      uint64_t v15 = (const UChar *)this + 5;
    }
    else {
      uint64_t v15 = this[3];
    }
    u_memcpy(dest, v15, v12);
    if (v13)
    {
      if (((_WORD)this[1] & 2) == 0)
      {
        uint64_t v17 = *((unsigned int *)this + 4);
        if (!a4) {
          goto LABEL_36;
        }
        goto LABEL_35;
      }
    }
    else
    {
      if (!icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, 27, 27, 0, 0, 0)) {
        goto LABEL_62;
      }
      uint64_t v15 = (const UChar *)this + 5;
    }
    uint64_t v17 = 27;
    if (!a4)
    {
LABEL_36:
      int v19 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, const UChar *, uint64_t, UChar *, uint64_t, void, UErrorCode *))a5)(a2, a3, a4, v15, v17, dest, v12, 0, &v47);
      int v16 = v19;
      if (v47 <= U_ZERO_ERROR)
      {
        int v22 = *((unsigned __int16 *)this + 4);
        if (v19 > 1023)
        {
          unsigned int v18 = (void *)(v22 | 0xFFE0u);
          *((_WORD *)this + 4) = (_WORD)v18;
          *((_DWORD *)this + 3) = v19;
          goto LABEL_62;
        }
        unsigned int v18 = (void *)(v22 & 0x1F | (32 * v19));
        goto LABEL_60;
      }
      if (v47 != U_BUFFER_OVERFLOW_ERROR)
      {
LABEL_56:
        icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
        goto LABEL_62;
      }
      uint64_t v14 = dest;
      goto LABEL_39;
    }
LABEL_35:
    uint64_t v46 = dest;
    icu::UnicodeString::setTo((icu::UnicodeString *)&v73, 0, (const UChar **)&v46, v12);
    (*(void (**)(uint64_t, void **))(*(void *)a4 + 56))(a4, &v73);
    goto LABEL_36;
  }
  return (icu::UnicodeString *)this;
}

icu::UnicodeString *icu::UnicodeString::foldCase(UChar **this, uint64_t a2)
{
  return icu::UnicodeString::caseMap(this, 1, a2, 0, (void (*)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18C8B43E8);
}

uint64_t uhash_hashCaselessUnicodeString(UChar **a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  memset(v4, 0, sizeof(v4));
  icu::UnicodeString::UnicodeString((icu::UnicodeString *)v4, a1);
  icu::UnicodeString::caseMap((UChar **)v4, 1, 0, 0, (void (*)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18C8B43E8);
  uint64_t v1 = icu::UnicodeString::doHashCode((icu::UnicodeString *)v4);
  icu::UnicodeString::~UnicodeString(v2, (icu::UnicodeString *)v4);
  return v1;
}

BOOL uhash_compareCaselessUnicodeString(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    unsigned int v3 = *(unsigned __int16 *)(a1 + 8);
    if (*(__int16 *)(a1 + 8) < 0) {
      int v4 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v4 = v3 >> 5;
    }
    unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
    if (v5)
    {
      int v8 = (v3 & 1) == 0;
    }
    else
    {
      if ((v5 & 0x8000u) == 0) {
        int v6 = v5 >> 5;
      }
      else {
        int v6 = *(_DWORD *)(a2 + 12);
      }
      if ((v5 & 2) != 0) {
        uint64_t v7 = a2 + 10;
      }
      else {
        uint64_t v7 = *(void *)(a2 + 24);
      }
      int v8 = icu::UnicodeString::doCaseCompare(a1, 0, v4, v7, v6 & (v6 >> 31), v6 & ~(v6 >> 31), 0);
    }
    return v8 == 0;
  }
  return v2;
}

icu::UnicodeString *icu::UnicodeString::toLower(UChar **this)
{
  uint64_t v2 = sub_18C8B4FD8(0);

  return icu::UnicodeString::caseMap(this, v2, 0, 0, (void (*)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18C8B3F34);
}

icu::UnicodeString *icu::UnicodeString::toLower(UChar **this, const icu::Locale *a2)
{
  int BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a2);
  uint64_t v4 = sub_18C8B4FD8(BaseName);

  return icu::UnicodeString::caseMap(this, v4, 0, 0, (void (*)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18C8B3F34);
}

icu::UnicodeString *icu::UnicodeString::toUpper(UChar **this)
{
  uint64_t v2 = sub_18C8B4FD8(0);

  return icu::UnicodeString::caseMap(this, v2, 0, 0, (void (*)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18C8B3FD4);
}

icu::UnicodeString *icu::UnicodeString::toUpper(UChar **this, const icu::Locale *a2)
{
  int BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a2);
  uint64_t v4 = sub_18C8B4FD8(BaseName);

  return icu::UnicodeString::caseMap(this, v4, 0, 0, (void (*)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18C8B3FD4);
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, char *a3)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  if (__s)
  {
    int v6 = strlen(__s);
    icu::UnicodeString::doCodepageCreate((UChar **)this, __s, v6, a3);
  }
  return this;
}

void icu::UnicodeString::doCodepageCreate(UChar **this, const char *__s, int a3, char *a4)
{
  if (a3 < -1) {
    return;
  }
  uint64_t v17 = v4;
  uint64_t v18 = v5;
  if (!__s) {
    return;
  }
  int32_t v7 = a3;
  if (!a3) {
    return;
  }
  if (a3 == -1) {
    int32_t v7 = strlen(__s);
  }
  UErrorCode v16 = U_ZERO_ERROR;
  if (!a4)
  {
    DefaultName = ucnv_getDefaultName();
    int v12 = *(unsigned __int8 *)DefaultName;
    if (v12 == 117)
    {
      if (DefaultName[1] != 116 || DefaultName[2] != 102) {
        goto LABEL_29;
      }
    }
    else if (v12 != 85 || DefaultName[1] != 84 || DefaultName[2] != 70)
    {
      goto LABEL_29;
    }
    int v14 = *((unsigned __int8 *)DefaultName + 3);
    if (v14 == 56)
    {
      if (!DefaultName[4])
      {
LABEL_23:
        icu::UnicodeString::setToUTF8((uint64_t)this, __s, v7);
        return;
      }
    }
    else if (v14 == 45 && DefaultName[4] == 56 && !DefaultName[5])
    {
      goto LABEL_23;
    }
LABEL_29:
    DefaultConverter = (UConverter *)u_getDefaultConverter(&v16);
    goto LABEL_30;
  }
  if (*a4)
  {
    DefaultConverter = (UConverter *)ucnv_open((unsigned __int8 *)a4, &v16);
LABEL_30:
    uint64_t v15 = DefaultConverter;
    if (v16 >= U_ILLEGAL_ARGUMENT_ERROR) {
      goto LABEL_31;
    }
    icu::UnicodeString::doCodepageCreate((icu::UnicodeString *)this, __s, v7, DefaultConverter, &v16);
    if (v16 >= U_ILLEGAL_ARGUMENT_ERROR) {
      icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
    }
    if (a4) {
      ucnv_close(v15);
    }
    else {
      u_releaseDefaultConverter(v15);
    }
    return;
  }
  if (!icu::UnicodeString::cloneArrayIfNeeded((icu::UnicodeString *)this, v7, v7, 0, 0, 0))
  {
LABEL_31:
    icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
    return;
  }
  if (((_WORD)this[1] & 2) != 0) {
    BOOL v13 = (UChar *)this + 5;
  }
  else {
    BOOL v13 = this[3];
  }
  u_charsToUChars(__s, v13, v7);
  if (v7 > 1023)
  {
    *((_WORD *)this + 4) |= 0xFFE0u;
    *((_DWORD *)this + 3) = v7;
  }
  else
  {
    *((_WORD *)this + 4) = (_WORD)this[1] & 0x1F | (32 * v7);
  }
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *a2, int a3, char *a4)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  if (a2) {
    icu::UnicodeString::doCodepageCreate((UChar **)this, a2, a3, a4);
  }
  return this;
}

{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  if (a2) {
    icu::UnicodeString::doCodepageCreate((UChar **)this, a2, a3, a4);
  }
  return this;
}

icu::UnicodeString *icu::UnicodeString::UnicodeString(icu::UnicodeString *this, const char *__s, int a3, UConverter *a4, UErrorCode *a5)
{
  *(void *)this = &unk_1EDA47700;
  *((_WORD *)this + 4) = 2;
  if (*(int *)a5 <= 0 && __s != 0)
  {
    int v8 = a3;
    if (a3 <= -2)
    {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
LABEL_14:
      icu::UnicodeString::setToBogus(this);
      return this;
    }
    if (a3 == -1) {
      int v8 = strlen(__s);
    }
    if (v8 >= 1)
    {
      if (a4)
      {
        ucnv_resetToUnicode((uint64_t)a4);
        icu::UnicodeString::doCodepageCreate(this, __s, v8, a4, a5);
      }
      else
      {
        DefaultConverter = (UConverter *)u_getDefaultConverter(a5);
        icu::UnicodeString::doCodepageCreate(this, __s, v8, DefaultConverter, a5);
        u_releaseDefaultConverter(DefaultConverter);
      }
    }
    if (*(int *)a5 >= 1) {
      goto LABEL_14;
    }
  }
  return this;
}

void icu::UnicodeString::doCodepageCreate(icu::UnicodeString *this, const char *a2, int a3, UConverter *a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    unsigned int v20 = 0;
    uint64_t v21 = a2;
    if (a3 <= 27) {
      int v10 = 27;
    }
    else {
      int v10 = a3 + (a3 >> 2);
    }
    if (icu::UnicodeString::cloneArrayIfNeeded(this, v10, v10, 0, 0, 0))
    {
      int v11 = &a2[a3];
      while (1)
      {
        unsigned int v12 = *((unsigned __int16 *)this + 4);
        BOOL v13 = (char *)this + 10;
        if ((v12 & 2) == 0) {
          BOOL v13 = (char *)*((void *)this + 3);
        }
        int v14 = (v12 & 0x8000) != 0 ? *((_DWORD *)this + 3) : v12 >> 5;
        unsigned int v20 = &v13[2 * v14];
        int v15 = (v12 & 2) != 0 ? 27 : *((_DWORD *)this + 4);
        ucnv_toUnicode((uint64_t)a4, &v20, (unint64_t)&v13[2 * v15], (unint64_t *)&v21, (unint64_t)v11, 0, 1, (int *)a5);
        unint64_t v16 = (unint64_t)(v20 - v13) >> 1;
        __int16 v17 = *((_WORD *)this + 4);
        if ((int)v16 > 1023)
        {
          LOWORD(v18) = v17 | 0xFFE0;
          *((_DWORD *)this + 3) = v16;
        }
        else
        {
          unsigned int v18 = v17 & 0x1F | (32 * ((v20 - v13) >> 1));
        }
        *((_WORD *)this + 4) = v18;
        if (*a5 != U_BUFFER_OVERFLOW_ERROR) {
          break;
        }
        *a5 = U_ZERO_ERROR;
        if (*((__int16 *)this + 4) < 0) {
          int v19 = *((_DWORD *)this + 3);
        }
        else {
          int v19 = *((unsigned __int16 *)this + 4) >> 5;
        }
        if (!icu::UnicodeString::cloneArrayIfNeeded(this, v19 + 2 * ((int)v11 - (int)v21), v19 + 2 * ((int)v11 - (int)v21), 1, 0, 0))goto LABEL_23; {
      }
        }
    }
    else
    {
LABEL_23:
      icu::UnicodeString::setToBogus(this);
    }
  }
}

uint64_t icu::UnicodeString::extract(icu::UnicodeString *this, int a2, uint64_t a3, char *cs, unsigned int a5, char *a6)
{
  uint64_t v7 = a3;
  int v8 = a2;
  if (cs || !a5)
  {
    unsigned int v11 = *((unsigned __int16 *)this + 4);
    if (*((__int16 *)this + 4) < 0)
    {
      int v12 = *((_DWORD *)this + 3);
      if ((a2 & 0x80000000) == 0)
      {
LABEL_6:
        int v13 = v12;
        if (v12 >= a2)
        {
          if ((a3 & 0x80000000) == 0) {
            goto LABEL_8;
          }
          goto LABEL_13;
        }
LABEL_12:
        int v8 = v13;
        if ((a3 & 0x80000000) == 0)
        {
LABEL_8:
          uint64_t v14 = (v12 - v8);
          if ((int)v14 >= (int)a3)
          {
LABEL_15:
            int v15 = cs + 0x7FFFFFFF;
            if ((unint64_t)cs >= 0xFFFFFFFF80000001) {
              int v15 = -1;
            }
            int v16 = v15 - cs;
            if (a5 >= 0x7FFFFFFF) {
              int v17 = v16;
            }
            else {
              int v17 = a5;
            }
            UErrorCode v30 = U_ZERO_ERROR;
            if (!v7)
            {
              int v19 = cs;
              int v20 = v17;
              uint64_t v21 = 0;
              return u_terminateChars((uint64_t)v19, v20, v21, (int *)&v30);
            }
            if (a6)
            {
              if (*a6)
              {
                unsigned int v18 = (UConverter *)ucnv_open((unsigned __int8 *)a6, &v30);
                uint64_t v10 = icu::UnicodeString::doExtract(this, v8, v7, cs, v17, v18, &v30);
                ucnv_close(v18);
                return v10;
              }
              if ((int)v7 >= v17) {
                int32_t v24 = v17;
              }
              else {
                int32_t v24 = v7;
              }
              if ((v11 & 2) != 0) {
                signed int v25 = (char *)this + 10;
              }
              else {
                signed int v25 = (char *)*((void *)this + 3);
              }
              u_UCharsToChars((const UChar *)&v25[2 * v8], cs, v24);
              int v19 = cs;
              int v20 = v17;
              uint64_t v21 = v7;
              return u_terminateChars((uint64_t)v19, v20, v21, (int *)&v30);
            }
            DefaultName = ucnv_getDefaultName();
            int v23 = *(unsigned __int8 *)DefaultName;
            if (v23 == 117)
            {
              if (DefaultName[1] != 116 || DefaultName[2] != 102) {
                goto LABEL_47;
              }
            }
            else if (v23 != 85 || DefaultName[1] != 84 || DefaultName[2] != 70)
            {
              goto LABEL_47;
            }
            int v26 = *((unsigned __int8 *)DefaultName + 3);
            if (v26 == 56)
            {
              if (!DefaultName[4]) {
                return icu::UnicodeString::toUTF8(this, v8, v7, cs, v17);
              }
            }
            else if (v26 == 45 && DefaultName[4] == 56 && !DefaultName[5])
            {
              return icu::UnicodeString::toUTF8(this, v8, v7, cs, v17);
            }
LABEL_47:
            DefaultConverter = (UConverter *)u_getDefaultConverter(&v30);
            uint64_t v10 = icu::UnicodeString::doExtract(this, v8, v7, cs, v17, DefaultConverter, &v30);
            u_releaseDefaultConverter(DefaultConverter);
            return v10;
          }
LABEL_14:
          uint64_t v7 = v14;
          goto LABEL_15;
        }
LABEL_13:
        uint64_t v14 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      int v12 = v11 >> 5;
      if ((a2 & 0x80000000) == 0) {
        goto LABEL_6;
      }
    }
    int v13 = 0;
    goto LABEL_12;
  }
  return 0;
}

uint64_t icu::UnicodeString::doExtract(icu::UnicodeString *this, int a2, int a3, char *a4, int a5, UConverter *a6, UErrorCode *a7)
{
  int v7 = a5;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v17 = a4;
  if (*(int *)a7 < 1)
  {
    if ((*((_WORD *)this + 4) & 2) != 0) {
      int v12 = (char *)this + 10;
    }
    else {
      int v12 = (char *)*((void *)this + 3);
    }
    int v16 = &v12[2 * a2];
    unint64_t v13 = (unint64_t)&v16[2 * a3];
    if (a5 == -1)
    {
      int v7 = 0x7FFFFFFF;
      if ((unint64_t)a4 >= 0xFFFFFFFF80000001) {
        unint64_t v14 = -1;
      }
      else {
        unint64_t v14 = (unint64_t)(a4 + 0x7FFFFFFF);
      }
    }
    else if (a5)
    {
      unint64_t v14 = (unint64_t)&a4[a5];
    }
    else
    {
      unint64_t v14 = 0;
      int v17 = 0;
    }
    ucnv_fromUnicode((uint64_t)a6, (uint64_t *)&v17, v14, (unint64_t *)&v16, v13, 0, 1, (int *)a7);
    uint64_t v15 = (v17 - a4);
    if (*a7 == U_BUFFER_OVERFLOW_ERROR)
    {
      bzero(v18, 0x400uLL);
      do
      {
        int v17 = v18;
        *a7 = U_ZERO_ERROR;
        ucnv_fromUnicode((uint64_t)a6, (uint64_t *)&v17, (unint64_t)&v19, (unint64_t *)&v16, v13, 0, 1, (int *)a7);
        uint64_t v15 = v15 + v17 - v18;
      }
      while (*a7 == U_BUFFER_OVERFLOW_ERROR);
    }
    return u_terminateChars((uint64_t)a4, v7, v15, (int *)a7);
  }
  else
  {
    uint64_t result = 0;
    if (a5) {
      *a4 = 0;
    }
  }
  return result;
}

uint64_t icu::UnicodeString::extract(icu::UnicodeString *this, char *a2, int a3, UConverter *a4, UErrorCode *a5)
{
  if (*(int *)a5 > 0) {
    return 0;
  }
  if (a3 < 0 || (unsigned int v9 = *((unsigned __int16 *)this + 4), (v9 & 1) != 0) || !a2 && a3)
  {
    uint64_t v5 = 0;
    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    return v5;
  }
  if (v9 > 0x1F)
  {
    if (a4)
    {
      ucnv_resetFromUnicode((uint64_t)a4);
      unint64_t v13 = a4;
    }
    else
    {
      uint64_t DefaultConverter = u_getDefaultConverter(a5);
      if (*(int *)a5 >= 1) {
        return 0;
      }
      unint64_t v13 = (UConverter *)DefaultConverter;
    }
    if (*((__int16 *)this + 4) < 0) {
      int v14 = *((_DWORD *)this + 3);
    }
    else {
      int v14 = *((unsigned __int16 *)this + 4) >> 5;
    }
    uint64_t v5 = icu::UnicodeString::doExtract(this, 0, v14, a2, a3, v13, a5);
    if (!a4) {
      u_releaseDefaultConverter(v13);
    }
    return v5;
  }

  return u_terminateChars((uint64_t)a2, a3, 0, (int *)a5);
}

icu::UnicodeString *icu::UnicodeString::trim(icu::UnicodeString *this)
{
  unsigned int v2 = *((unsigned __int16 *)this + 4);
  if (v2) {
    return this;
  }
  if ((v2 & 2) != 0)
  {
    unsigned int v3 = (char *)this + 10;
    if ((v2 & 0x8000) == 0) {
      goto LABEL_4;
    }
LABEL_6:
    int v4 = *((_DWORD *)this + 3);
    goto LABEL_7;
  }
  unsigned int v3 = (char *)*((void *)this + 3);
  if ((v2 & 0x8000) != 0) {
    goto LABEL_6;
  }
LABEL_4:
  int v4 = v2 >> 5;
LABEL_7:
  if (v4 < 1) {
    return this;
  }
  int v5 = v4;
  do
  {
    int v6 = v5 - 1;
    UChar32 v7 = *(unsigned __int16 *)&v3[2 * (v5 - 1)];
    if ((v7 & 0xFC00) == 0xDC00)
    {
      if (v5 < 2)
      {
        int v6 = 0;
      }
      else
      {
        int v8 = *(unsigned __int16 *)&v3[2 * (v5 - 2)];
        BOOL v9 = (v8 & 0xFC00) == 55296;
        int v10 = v7 - 56613888 + (v8 << 10);
        if (v9) {
          int v6 = v5 - 2;
        }
        if (v9) {
          UChar32 v7 = v10;
        }
      }
    }
    else if (v7 == 32)
    {
      goto LABEL_21;
    }
    if (!u_isWhitespace(v7)) {
      break;
    }
LABEL_21:
    int v5 = v6;
  }
  while (v6 > 0);
  if (v5 >= v4)
  {
LABEL_25:
    if (v5 < 1) {
      return this;
    }
  }
  else
  {
    if (v5 <= 1023)
    {
      *((_WORD *)this + 4) = *((_WORD *)this + 4) & 0x1F | (32 * v5);
      goto LABEL_25;
    }
    *((_WORD *)this + 4) |= 0xFFE0u;
    *((_DWORD *)this + 3) = v5;
  }
  uint64_t v11 = 0;
  while (2)
  {
    uint64_t v12 = (int)v11 + 1;
    UChar32 v13 = *(unsigned __int16 *)&v3[2 * (int)v11];
    if ((v13 & 0xFC00) == 0xD800 && v12 != v5)
    {
      int v15 = *(unsigned __int16 *)&v3[2 * v12];
      BOOL v16 = (v15 & 0xFC00) == 56320;
      UChar32 v17 = (v13 << 10) - 56613888 + v15;
      if (v16) {
        uint64_t v12 = (v11 + 2);
      }
      else {
        uint64_t v12 = v12;
      }
      if (v16) {
        UChar32 v13 = v17;
      }
      goto LABEL_42;
    }
    if (v13 != 32)
    {
LABEL_42:
      if (!u_isWhitespace(v13)) {
        break;
      }
    }
    uint64_t v11 = v12;
    if ((int)v12 < v5) {
      continue;
    }
    break;
  }
  if ((int)v11 >= 1) {
    icu::UnicodeString::doReplace((uint64_t)this, 0, v11, 0, 0, 0);
  }
  return this;
}

UChar **icu::UnicodeString::toTitle(icu::UnicodeString *this, icu::BreakIterator *a2)
{
  Default = icu::Locale::getDefault(this);

  return icu::UnicodeString::toTitle((UChar **)this, a2, (const icu::Locale *)Default, 0);
}

UChar **icu::UnicodeString::toTitle(UChar **this, icu::BreakIterator *a2, const icu::Locale *a3, uint64_t a4)
{
  uint64_t v13 = 0;
  int v12 = 0;
  uint64_t v7 = sub_18C8B24AC(a3, "", a4, (uint64_t)a2, &v13, (const icu::Locale *)&v12);
  if (v7)
  {
    uint64_t v8 = v7;
    int BaseName = (unsigned __int8 *)icu::Locale::getBaseName(a3);
    uint64_t v10 = sub_18C8B4FD8(BaseName);
    icu::UnicodeString::caseMap(this, v10, a4, v8, (void (*)(uint64_t, void, uint64_t, int **, uint64_t, UChar *, uint64_t, unsigned __int16 **, UErrorCode *))sub_18C8B2B84);
  }
  else
  {
    icu::UnicodeString::setToBogus((icu::UnicodeString *)this);
  }
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  return this;
}

UChar **icu::UnicodeString::toTitle(UChar **this, icu::BreakIterator *a2, const icu::Locale *a3)
{
  return icu::UnicodeString::toTitle(this, a2, a3, 0);
}

uint64_t unorm_quickCheck(uint64_t a1, int a2, int a3, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);

  return unorm2_quickCheck(Instance, a1, a2, (int *)this);
}

uint64_t unorm_quickCheckWithOptions(uint64_t a1, int a2, int a3, char a4, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) != 0)
  {
    v12[0] = &unk_1EDA43948;
    v12[1] = Instance;
    _OWORD v12[2] = sub_18C896F18((UErrorCode *)this);
    uint64_t v11 = unorm2_quickCheck((uint64_t)v12, a1, a2, (int *)this);
    icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v12);
    return v11;
  }
  else
  {
    return unorm2_quickCheck(Instance, a1, a2, (int *)this);
  }
}

uint64_t unorm_isNormalized(uint64_t a1, int a2, int a3, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);

  return unorm2_isNormalized(Instance, a1, a2, (int *)this);
}

uint64_t unorm_isNormalizedWithOptions(uint64_t a1, int a2, int a3, char a4, icu::Normalizer2Factory *this)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) != 0)
  {
    v12[0] = &unk_1EDA43948;
    v12[1] = Instance;
    _OWORD v12[2] = sub_18C896F18((UErrorCode *)this);
    uint64_t isNormalized = unorm2_isNormalized((uint64_t)v12, a1, a2, (int *)this);
    icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v12);
    return isNormalized;
  }
  else
  {
    return unorm2_isNormalized(Instance, a1, a2, (int *)this);
  }
}

uint64_t unorm_normalize(UChar *a1, int a2, int a3, char a4, UChar *a5, uint64_t a6, icu::Normalizer2Factory *this)
{
  uint64_t Instance = (const void *)icu::Normalizer2Factory::getInstance(a3, this);
  if ((a4 & 0x20) != 0)
  {
    v16[0] = &unk_1EDA43948;
    v16[1] = Instance;
    v16[2] = sub_18C896F18((UErrorCode *)this);
    uint64_t v15 = unorm2_normalize(v16, a1, a2, a5, a6, (UErrorCode *)this);
    icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v16);
    return v15;
  }
  else
  {
    return unorm2_normalize(Instance, a1, a2, a5, a6, (UErrorCode *)this);
  }
}

uint64_t unorm_previous(uint64_t a1, UChar *a2, uint64_t a3, int a4, char a5, int a6, unsigned char *a7, icu::Normalizer2Factory *a8)
{
  return sub_18C8A12E8(a1, 0, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_18C8A12E8(uint64_t a1, int a2, UChar *a3, uint64_t a4, int a5, char a6, int a7, unsigned char *a8, icu::Normalizer2Factory *a9)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a5, a9);
  if ((a6 & 0x20) != 0)
  {
    uint64_t v18 = sub_18C896F18((UErrorCode *)a9);
    if (*(int *)a9 > 0) {
      return 0;
    }
    v20[0] = &unk_1EDA43948;
    v20[1] = Instance;
    void v20[2] = v18;
    uint64_t v19 = sub_18C8A17D0(a1, a2, a3, a4, (uint64_t)v20, a7, a8, (int *)a9);
    icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v20);
    return v19;
  }
  else
  {
    return sub_18C8A17D0(a1, a2, a3, a4, Instance, a7, a8, (int *)a9);
  }
}

uint64_t unorm_next(uint64_t a1, UChar *a2, uint64_t a3, int a4, char a5, int a6, unsigned char *a7, icu::Normalizer2Factory *a8)
{
  return sub_18C8A12E8(a1, 1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t unorm_concatenate(uint64_t a1, uint64_t a2, unint64_t a3, int a4, char *a5, unsigned int a6, int a7, char a8, icu::Normalizer2Factory *a9)
{
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a7, a9);
  if ((a8 & 0x20) != 0)
  {
    uint64_t v18 = sub_18C896F18((UErrorCode *)a9);
    if (*(int *)a9 > 0) {
      return 0;
    }
    v20[0] = &unk_1EDA43948;
    v20[1] = Instance;
    void v20[2] = v18;
    uint64_t v19 = sub_18C8A15A4(a1, a2, a3, a4, a5, a6, (uint64_t)v20, (int *)a9);
    icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v20);
    return v19;
  }
  else
  {
    return sub_18C8A15A4(a1, a2, a3, a4, a5, a6, Instance, (int *)a9);
  }
}

uint64_t sub_18C8A15A4(uint64_t a1, uint64_t a2, unint64_t a3, int a4, char *a5, unsigned int a6, uint64_t a7, int *a8)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*a8 > 0) {
    return 0;
  }
  if ((a6 & 0x80000000) != 0
    || (!a5 ? (BOOL v13 = a6 == 0) : (BOOL v13 = 1),
        v13 ? (int v14 = 0) : (int v14 = 1),
        a4 < -1
     || !a3
     || (int)a2 < -1
     || !a1
     || v14
     || a5
     && (a3 >= (unint64_t)a5 && (unint64_t)&a5[2 * a6] > a3
      || a4 >= 1 && (unint64_t)a5 >= a3 && a3 + 2 * a4 > (unint64_t)a5)))
  {
    uint64_t v8 = 0;
    *a8 = 1;
  }
  else
  {
    long long v27 = 0u;
    uint64_t v30 = 0;
    long long v29 = 0u;
    long long v28 = 0u;
    int v26 = &unk_1EDA47700;
    LOWORD(v27) = 2;
    if ((char *)a1 == a5)
    {
      icu::UnicodeString::setTo((icu::UnicodeString *)&v26, a5, a2, a6);
    }
    else
    {
      icu::UnicodeString::setTo((icu::UnicodeString *)&v26, a5, 0, a6);
      icu::UnicodeString::doAppend((uint64_t)&v26, a1, 0, a2);
      v22[1] = a1;
    }
    unint64_t v24 = a3;
    icu::UnicodeString::UnicodeString(v25, a4 >> 31, &v24);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void **, unsigned char *, int *))(*(void *)a7 + 48))(a7, &v26, v25, a8);
    int v23 = (UChar *)a5;
    uint64_t v8 = icu::UnicodeString::extract(v20, &v23, a6, a8);
    v22[0] = v23;
    icu::UnicodeString::~UnicodeString(v22, (icu::UnicodeString *)v25);
    unint64_t v21 = v24;
    icu::UnicodeString::~UnicodeString(&v21, (icu::UnicodeString *)&v26);
  }
  return v8;
}

uint64_t sub_18C8A17D0(uint64_t a1, int a2, UChar *a3, uint64_t a4, uint64_t a5, int a6, unsigned char *a7, int *a8)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (*a8 > 0) {
    return 0;
  }
  if ((a4 & 0x80000000) != 0 || (!a3 ? (BOOL v13 = a4 == 0) : (BOOL v13 = 1), v13 ? (v14 = 0) : (v14 = 1), !a1 || v14))
  {
    uint64_t v8 = 0;
    *a8 = 1;
    return v8;
  }
  if (a7) {
    *a7 = 0;
  }
  uint64_t v19 = 48;
  if (!a2) {
    uint64_t v19 = 56;
  }
  if ((*(unsigned int (**)(uint64_t))(a1 + v19))(a1))
  {
    long long v36 = 0u;
    uint64_t v39 = 0;
    long long v38 = 0u;
    long long v37 = 0u;
    long long v35 = &unk_1EDA47700;
    LOWORD(v36) = 2;
    if (a2)
    {
      UChar32 v20 = uiter_next32((UCharIterator *)a1);
      icu::UnicodeString::append((uint64_t)&v35, v20);
      uint64_t v21 = uiter_next32((UCharIterator *)a1);
      if ((v21 & 0x80000000) == 0)
      {
        uint64_t v22 = v21;
        while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a5 + 120))(a5, v22))
        {
          icu::UnicodeString::append((uint64_t)&v35, v22);
          uint64_t v22 = uiter_next32((UCharIterator *)a1);
          if ((v22 & 0x80000000) != 0) {
            goto LABEL_34;
          }
        }
        if (v22 >= 0x10000) {
          uint64_t v26 = 4294967294;
        }
        else {
          uint64_t v26 = 0xFFFFFFFFLL;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v26, 1);
      }
    }
    else
    {
      do
      {
        uint64_t v24 = uiter_previous32((UCharIterator *)a1);
        if ((v24 & 0x80000000) != 0) {
          break;
        }
        uint64_t v23 = v24;
        icu::UnicodeString::replace((icu::UnicodeString *)&v35, 0, 0, v24);
      }
      while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a5 + 120))(a5, v23));
    }
LABEL_34:
    memset(v34, 0, sizeof(v34));
    icu::UnicodeString::UnicodeString(v34, a3, 0, a4);
    int v27 = (unsigned __int16)v36 >> 5;
    if ((v36 & 0x8000u) != 0) {
      int v27 = DWORD1(v36);
    }
    if (a6 && v27 >= 1)
    {
      uint64_t v28 = (*(uint64_t (**)(uint64_t, void **, _OWORD *, int *))(*(void *)a5 + 24))(a5, &v35, v34, a8);
      __int16 v33 = a3;
      icu::UnicodeString::extract(v28, &v33, a4, a8);
      if (a7 && *a8 <= 0) {
        *a7 = sub_18C8A1B58((uint64_t)v34, (uint64_t)&v35);
      }
      unint64_t v29 = SWORD4(v34[0]);
      if ((v29 & 0x80000000) != 0)
      {
        uint64_t v8 = HIDWORD(v34[0]);
      }
      else
      {
        unint64_t v29 = WORD4(v34[0]);
        uint64_t v8 = WORD4(v34[0]) >> 5;
      }
    }
    else
    {
      unsigned int v32 = a3;
      uint64_t v8 = icu::UnicodeString::extract((uint64_t)&v35, &v32, a4, a8);
      uint64_t v31 = v32;
      unint64_t v29 = (unint64_t)&v31;
    }
    icu::UnicodeString::~UnicodeString((void *)v29, (icu::UnicodeString *)v34);
    icu::UnicodeString::~UnicodeString(v30, (icu::UnicodeString *)&v35);
    return v8;
  }

  return u_terminateUChars((uint64_t)a3, a4, 0, a8);
}

uint64_t sub_18C8A1B58(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 8);
  if (v2)
  {
    int v4 = *(_WORD *)(a2 + 8) & 1;
  }
  else
  {
    if ((v2 & 0x8000) != 0) {
      int v3 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v3 = v2 >> 5;
    }
    int v4 = 0;
    unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
    if ((v5 & 0x8000u) == 0) {
      unsigned int v6 = v5 >> 5;
    }
    else {
      unsigned int v6 = *(_DWORD *)(a2 + 12);
    }
    if ((v5 & 1) == 0 && v3 == v6) {
      int v4 = icu::UnicodeString::doEquals((icu::UnicodeString *)a1, (const icu::UnicodeString *)a2, v3);
    }
  }
  return v4 ^ 1u;
}

uint64_t unorm_compare(UChar *a1, UErrorCode *a2, UChar *a3, int a4, unsigned int a5, icu::Normalizer2Factory *this)
{
  v76[5] = *MEMORY[0x1E4F143B8];
  if (*(int *)this > 0) {
    return 0;
  }
  uint64_t v8 = a1;
  if (!a1 || (v9 = (int)a2, (int)a2 < -1) || (uint64_t v10 = a3) == 0 || (v11 = a4, a4 <= -2))
  {
    uint64_t v6 = 0;
    *(_DWORD *)this = 1;
    return v6;
  }
  long long v59 = 0u;
  uint64_t v62 = 0;
  long long v61 = 0u;
  long long v60 = 0u;
  uint64_t v57 = 0;
  long long v58 = &unk_1EDA47700;
  LOWORD(v59) = 2;
  long long v54 = 0u;
  long long v56 = 0u;
  long long v55 = 0u;
  long long v53 = &unk_1EDA47700;
  LOWORD(v54) = 2;
  if ((a5 & 0x20001) != 0x20000)
  {
    if (a5) {
      NFDuint64_t Instance = icu::Normalizer2::getNFDInstance(this, a2);
    }
    else {
      NFDuint64_t Instance = icu::Normalizer2Factory::getFCDInstance(this, a2);
    }
    uint64_t v42 = NFDInstance;
    uint64_t v12 = a5;
    if (*(int *)this > 0) {
      goto LABEL_123;
    }
    if ((a5 & 0x2000000) != 0)
    {
      *(void *)dest = &unk_1EDA43948;
      *(void *)&dest[4] = NFDInstance;
      *(void *)&long long v68 = sub_18C896F18((UErrorCode *)this);
      if (sub_18C8A252C((uint64_t)dest, (uint64_t)v8, v9, (icu::UnicodeString *)&v58, (unsigned int *)this))
      {
        if ((v59 & 0x11) != 0)
        {
          uint64_t v8 = 0;
        }
        else if ((v59 & 2) != 0)
        {
          uint64_t v8 = (UChar *)&v59 + 1;
        }
        else
        {
          uint64_t v8 = (UChar *)v60;
        }
        if ((v59 & 0x8000) != 0) {
          signed int v9 = DWORD1(v59);
        }
        else {
          signed int v9 = (unsigned __int16)v59 >> 5;
        }
      }
      if (sub_18C8A252C((uint64_t)dest, (uint64_t)v10, v11, (icu::UnicodeString *)&v53, (unsigned int *)this))
      {
        if ((v54 & 0x11) != 0)
        {
          uint64_t v10 = 0;
        }
        else if ((v54 & 2) != 0)
        {
          uint64_t v10 = (UChar *)&v54 + 1;
        }
        else
        {
          uint64_t v10 = (UChar *)v55;
        }
        if ((v54 & 0x8000) != 0) {
          signed int v11 = DWORD1(v54);
        }
        else {
          signed int v11 = (unsigned __int16)v54 >> 5;
        }
      }
      icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)dest);
    }
    else
    {
      if (sub_18C8A252C(NFDInstance, (uint64_t)v8, v9, (icu::UnicodeString *)&v58, (unsigned int *)this))
      {
        if ((v59 & 0x11) != 0)
        {
          uint64_t v8 = 0;
        }
        else if ((v59 & 2) != 0)
        {
          uint64_t v8 = (UChar *)&v59 + 1;
        }
        else
        {
          uint64_t v8 = (UChar *)v60;
        }
        if ((v59 & 0x8000) != 0) {
          signed int v9 = DWORD1(v59);
        }
        else {
          signed int v9 = (unsigned __int16)v59 >> 5;
        }
      }
      if (sub_18C8A252C(v42, (uint64_t)v10, v11, (icu::UnicodeString *)&v53, (unsigned int *)this))
      {
        if ((v54 & 0x11) != 0)
        {
          uint64_t v10 = 0;
        }
        else if ((v54 & 2) != 0)
        {
          uint64_t v10 = (UChar *)&v54 + 1;
        }
        else
        {
          uint64_t v10 = (UChar *)v55;
        }
        if ((v54 & 0x8000) != 0) {
          signed int v11 = DWORD1(v54);
        }
        else {
          signed int v11 = (unsigned __int16)v54 >> 5;
        }
      }
    }
  }
  uint64_t v12 = *(unsigned int *)this;
  if ((int)v12 > 0
    || (NFCImpl = icu::Normalizer2Factory::getNFCImpl(this, a2), uint64_t v12 = *(unsigned int *)this, (int)v12 > 0))
  {
LABEL_123:
    uint64_t v6 = 0;
    goto LABEL_124;
  }
  uint64_t v45 = NFCImpl;
  int v14 = 0;
  int v15 = 0;
  src = 0;
  unsigned int v16 = a5;
  unsigned int v51 = 0;
  memset(v76, 0, 32);
  long long v73 = 0u;
  memset(v74, 0, sizeof(v74));
  long long v75 = 0u;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  *(_OWORD *)dest = 0u;
  long long v68 = 0u;
  if (v9 == -1) {
    UChar32 v17 = 0;
  }
  else {
    UChar32 v17 = &v8[v9];
  }
  uint64_t v12 = (uint64_t)&v10[v11];
  long long v69 = 0uLL;
  long long v70 = 0uLL;
  if (v11 == -1) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = &v10[v11];
  }
  uint64_t v19 = 0xFFFFFFFFLL;
  *(_OWORD *)long long v63 = 0uLL;
  long long v64 = 0uLL;
  UChar32 v20 = v8;
  uint64_t v21 = v10;
  unsigned int v22 = -1;
  long long v65 = 0uLL;
  long long v66 = 0uLL;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if ((v19 & 0x80000000) != 0)
            {
              while (1)
              {
                if (v8 != v17)
                {
                  uint64_t v12 = v16 & 0x1000;
                  BOOL v24 = v17 && v12 == 0;
                  uint64_t v23 = *v8;
                  if (v24 || *v8)
                  {
                    ++v8;
                    if ((v22 & 0x80000000) != 0) {
                      goto LABEL_37;
                    }
                    goto LABEL_46;
                  }
                }
                if (!v14) {
                  break;
                }
                uint64_t v12 = (uint64_t)&v76[3 * v14];
                do
                {
                  UChar32 v20 = *(UChar **)(v12 - 40);
                  v12 -= 24;
                  --v14;
                }
                while (!v20);
                uint64_t v8 = *(UChar **)(v12 - 8);
                UChar32 v17 = *(UChar **)v12;
              }
              uint64_t v23 = 0xFFFFFFFFLL;
              if ((v22 & 0x80000000) != 0) {
                goto LABEL_37;
              }
            }
            else
            {
              uint64_t v23 = v19;
              if ((v22 & 0x80000000) != 0)
              {
LABEL_37:
                while (1)
                {
                  if (v10 != v18)
                  {
                    uint64_t v12 = v16 & 0x1000;
                    BOOL v25 = v18 && v12 == 0;
                    unsigned int v22 = *v10;
                    if (v25 || *v10) {
                      break;
                    }
                  }
                  if (!v15)
                  {
                    unsigned int v22 = -1;
                    goto LABEL_46;
                  }
                  uint64_t v12 = (uint64_t)&v74[3 * v15];
                  do
                  {
                    uint64_t v21 = *(UChar **)(v12 - 40);
                    v12 -= 24;
                    --v15;
                  }
                  while (!v21);
                  uint64_t v10 = *(UChar **)(v12 - 8);
                  uint64_t v18 = *(UChar **)v12;
                }
                ++v10;
              }
            }
LABEL_46:
            if (v23 != v22) {
              break;
            }
            uint64_t v19 = 0xFFFFFFFFLL;
            unsigned int v22 = -1;
            if ((v23 & 0x80000000) != 0) {
              goto LABEL_123;
            }
          }
          if ((v23 & 0x80000000) != 0)
          {
            uint64_t v6 = 0xFFFFFFFFLL;
            goto LABEL_124;
          }
          if ((v22 & 0x80000000) != 0)
          {
            uint64_t v6 = 1;
            goto LABEL_124;
          }
          unsigned int v26 = v23;
          int v47 = v23 & 0xFFFFF800;
          if ((v23 & 0xFFFFF800) == 0xD800)
          {
            if ((v23 & 0x400) != 0)
            {
              unsigned int v26 = v23;
              if (v20 <= v8 - 2)
              {
                int v28 = *(v8 - 2);
                unsigned int v26 = v23;
                if ((v28 & 0xFC00) == 0xD800) {
                  unsigned int v26 = v23 - 56613888 + (v28 << 10);
                }
              }
            }
            else
            {
              unsigned int v26 = v23;
              if (v8 != v17)
              {
                int v27 = *v8;
                unsigned int v26 = v23;
                if ((v27 & 0xFC00) == 0xDC00) {
                  unsigned int v26 = (v23 << 10) - 56613888 + v27;
                }
              }
            }
          }
          uint64_t v12 = v22 & 0xFFFFF800;
          int v29 = v22;
          int v48 = v12;
          if (v12 == 55296)
          {
            if ((v22 & 0x400) != 0)
            {
              uint64_t v12 = (uint64_t)(v10 - 2);
              int v29 = v22;
              if (v21 <= v10 - 2)
              {
                uint64_t v12 = *(unsigned __int16 *)v12;
                int v29 = v22;
                if ((v12 & 0xFC00) == 0xD800) {
                  int v29 = v22 - 56613888 + (v12 << 10);
                }
              }
            }
            else
            {
              int v29 = v22;
              if (v10 != v18)
              {
                uint64_t v12 = *v10;
                int v29 = v22;
                if ((v12 & 0xFC00) == 0xDC00) {
                  int v29 = (v22 << 10) - 56613888 + v12;
                }
              }
            }
          }
          unsigned int v49 = v29;
          signed int v46 = v26;
          if ((v16 & 0x10000) == 0) {
            break;
          }
          if (v14) {
            break;
          }
          unsigned int v30 = ucase_toFullFolding(v26, &src, a5);
          unsigned int v16 = a5;
          unsigned int v51 = v30;
          if ((v30 & 0x80000000) != 0) {
            break;
          }
          LOWORD(v31) = v30;
          if (v47 == 55296)
          {
            if ((v23 & 0x400) != 0)
            {
              unsigned int v22 = *(v10 - 2);
              --v10;
            }
            else
            {
              ++v8;
            }
          }
          *(void *)&long long v75 = v20;
          *((void *)&v75 + 1) = v8;
          v76[0] = v17;
          if (v30 > 0x1F)
          {
            if (HIWORD(v30))
            {
              int v31 = (v30 >> 10) - 10304;
              dest[1] = v30 & 0x3FF | 0xDC00;
              uint64_t v12 = 2;
            }
            else
            {
              uint64_t v12 = 1;
            }
            dest[0] = v31;
            unsigned int v51 = v12;
          }
          else
          {
            u_memcpy(dest, src, v30);
            unsigned int v16 = a5;
            uint64_t v12 = v51;
          }
          uint64_t v8 = dest;
          UChar32 v17 = &dest[(int)v12];
          uint64_t v19 = 0xFFFFFFFFLL;
          int v14 = 1;
          UChar32 v20 = dest;
        }
        if ((v16 & 0x10000) == 0) {
          break;
        }
        if (v15) {
          break;
        }
        unsigned int v32 = ucase_toFullFolding(v49, &src, a5);
        unsigned int v16 = a5;
        unsigned int v51 = v32;
        if ((v32 & 0x80000000) != 0) {
          break;
        }
        LOWORD(v33) = v32;
        if (v48 != 55296) {
          goto LABEL_79;
        }
        if ((v22 & 0x400) == 0)
        {
          ++v10;
LABEL_79:
          uint64_t v19 = v23;
          goto LABEL_106;
        }
        uint64_t v19 = *(v8 - 2);
        --v8;
LABEL_106:
        *(void *)&long long v73 = v21;
        *((void *)&v73 + 1) = v10;
        v74[0] = v18;
        if (v32 > 0x1F)
        {
          if (HIWORD(v32))
          {
            int v33 = (v32 >> 10) - 10304;
            v63[1] = v32 & 0x3FF | 0xDC00;
            uint64_t v12 = 2;
          }
          else
          {
            uint64_t v12 = 1;
          }
          v63[0] = v33;
          unsigned int v51 = v12;
        }
        else
        {
          uint64_t v38 = v19;
          u_memcpy(v63, src, v32);
          uint64_t v19 = v38;
          unsigned int v16 = a5;
          uint64_t v12 = v51;
        }
        uint64_t v10 = v63;
        uint64_t v18 = &v63[(int)v12];
        unsigned int v22 = -1;
        int v15 = 1;
        uint64_t v21 = v63;
      }
      if (v14 > 1) {
        break;
      }
      Decomposition = icu::Normalizer2Impl::getDecomposition(v45, v46, &v72, (int *)&v51);
      unsigned int v16 = a5;
      src = Decomposition;
      if (!Decomposition) {
        break;
      }
      if (v47 == 55296)
      {
        if ((v23 & 0x400) != 0)
        {
          unsigned int v22 = *(v10 - 2);
          --v10;
        }
        else
        {
          ++v8;
        }
      }
      uint64_t v39 = (UChar **)&v76[3 * v14 - 2];
      *uint64_t v39 = v20;
      v39[1] = v8;
      v39[2] = v17;
      if (v14 <= 0)
      {
        int v40 = v14;
        v14 += 2;
        v76[3 * v40 + 1] = 0;
      }
      else
      {
        int v14 = 2;
      }
      uint64_t v12 = (int)v51;
      UChar32 v17 = &Decomposition[v51];
      uint64_t v19 = 0xFFFFFFFFLL;
      uint64_t v8 = Decomposition;
      UChar32 v20 = Decomposition;
    }
    if (v15 > 1) {
      break;
    }
    long long v35 = icu::Normalizer2Impl::getDecomposition(v45, v49, &v71, (int *)&v51);
    unsigned int v16 = a5;
    src = v35;
    if (!v35) {
      break;
    }
    if (v48 != 55296) {
      goto LABEL_90;
    }
    if ((v22 & 0x400) == 0)
    {
      ++v10;
LABEL_90:
      uint64_t v19 = v23;
      goto LABEL_100;
    }
    uint64_t v19 = *(v8 - 2);
    --v8;
LABEL_100:
    long long v36 = (UChar **)&v74[3 * v15 - 2];
    *long long v36 = v21;
    v36[1] = v10;
    v36[2] = v18;
    if (v15 <= 0)
    {
      int v37 = v15;
      v15 += 2;
      v74[3 * v37 + 1] = 0;
    }
    else
    {
      int v15 = 2;
    }
    uint64_t v12 = (int)v51;
    uint64_t v18 = &v35[v51];
    unsigned int v22 = -1;
    uint64_t v10 = v35;
    uint64_t v21 = v35;
  }
  if ((v16 & 0x8000) != 0)
  {
    uint64_t v12 = v23 >> 11;
    if (v12 >= 0x1B)
    {
      uint64_t v12 = v22 >> 11;
      if (v12 >= 0x1B)
      {
        if ((v23 >> 10 > 0x36 || v8 == v17 || (*v8 & 0xFC00) != 0xDC00)
          && (v23 >> 10 != 55 || v20 == v8 - 1 || (*(v8 - 2) & 0xFC00) != 0xD800))
        {
          LODWORD(v23) = v23 - 10240;
        }
        uint64_t v12 = v22 >> 10;
        if (v12 > 0x36 || v10 == v18 || (*v10 & 0xFC00) != 0xDC00)
        {
          if (v12 != 55 || v21 == v10 - 1 || (uint64_t v12 = *(v10 - 2) & 0xFC00, v12 != 55296))
          {
            uint64_t v12 = 4294957056;
            v22 -= 10240;
          }
        }
      }
    }
  }
  uint64_t v6 = v23 - v22;
LABEL_124:
  icu::UnicodeString::~UnicodeString((void *)v12, (icu::UnicodeString *)&v53);
  icu::UnicodeString::~UnicodeString(v43, (icu::UnicodeString *)&v58);
  return v6;
}

uint64_t sub_18C8A252C(uint64_t a1, uint64_t a2, unsigned int a3, icu::UnicodeString *a4, unsigned int *a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v17 = a2;
  icu::UnicodeString::UnicodeString(&v19, a3 >> 31, &v17);
  int v8 = (*(uint64_t (**)(uint64_t, long long *, unsigned int *))(*(void *)a1 + 112))(a1, &v19, a5);
  signed int v9 = (void *)*a5;
  if ((int)v9 > 0) {
    goto LABEL_12;
  }
  int v10 = v8;
  LODWORD(v9) = WORD4(v19) >> 5;
  signed int v9 = (SWORD4(v19) & 0x8000u) == 0 ? (void *)v9 : (void *)HIDWORD(v19);
  if (v8 >= (int)v9) {
    goto LABEL_12;
  }
  memset(v18, 0, sizeof(v18));
  icu::UnicodeString::tempSubString((icu::UnicodeString *)&v19, v8, 0x7FFFFFFF, (icu::UnicodeString *)v18);
  if ((BYTE8(v19) & 0x11) != 0) {
    signed int v11 = 0;
  }
  else {
    signed int v11 = (const UChar *)((BYTE8(v19) & 2) != 0 ? (unint64_t)&v19 | 0xA : *((void *)&v20 + 1));
  }
  unsigned int v16 = v11;
  icu::UnicodeString::setTo(a4, 0, &v16, v10);
  (*(void (**)(uint64_t, icu::UnicodeString *, _OWORD *, unsigned int *))(*(void *)a1 + 40))(a1, a4, v18, a5);
  int v12 = *a5;
  icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v18);
  if (v12 < 1) {
    uint64_t v14 = 1;
  }
  else {
LABEL_12:
  }
    uint64_t v14 = 0;
  icu::UnicodeString::~UnicodeString(v9, (icu::UnicodeString *)&v19);
  return v14;
}

void icu::UMemory::operator delete(void *a1)
{
  if (a1) {
    uprv_free(a1);
  }
}

void icu::UMemory::operator delete[](void *a1)
{
  if (a1) {
    uprv_free(a1);
  }
}

void icu::UObject::~UObject(void *this)
{
  if (this) {
    uprv_free(this);
  }
}

uint64_t icu::UObject::getDynamicClassID(icu::UObject *this)
{
  return 0;
}

uint64_t uprv_deleteUObject(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

UBool u_hasBinaryProperty(UChar32 c, UProperty which)
{
  if (which <= (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL)) {
    return (*((uint64_t (**)(char *, void))&unk_1EDA47898 + 2 * which + 1))((char *)&unk_1EDA47898 + 16 * which, *(void *)&c);
  }
  else {
    return 0;
  }
}

BOOL u_isEmoji(unsigned int a1)
{
  return sub_18C7F80F0(a1, 57);
}

UBool u_isIDStart(UChar32 c)
{
  return (sub_18C84FE2C(c, 1) >> 24) & 1;
}

UBool u_isIDPart(UChar32 c)
{
  return (sub_18C84FE2C(c, 1) >> 25) & 1;
}

UBool u_stringHasBinaryProperty(const UChar *s, int32_t length, UProperty which)
{
  if (!s && length) {
    return 0;
  }
  if (length != 1)
  {
    if (length == 2)
    {
      UChar v4 = *s;
    }
    else
    {
      if ((length & 0x80000000) == 0) {
        goto LABEL_20;
      }
      UChar v4 = *s;
      if (!*s) {
        goto LABEL_20;
      }
    }
    int v5 = 1;
    if ((v4 & 0xFC00) == 0xD800)
    {
      if ((s[1] & 0xFC00) == 0xDC00) {
        int v5 = 2;
      }
      else {
        int v5 = 1;
      }
    }
    if (length < 1)
    {
      if (!s[v5]) {
        goto LABEL_22;
      }
    }
    else if (v5 == length)
    {
LABEL_22:
      if (which <= (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL))
      {
        uint64_t v6 = *(uint64_t (**)(void))&dword_1EDA47898[4 * which + 2];
        goto LABEL_24;
      }
      return 0;
    }
LABEL_20:
    if ((which - 65) <= 6) {
      return sub_18C7F8208(s, length, which);
    }
    return 0;
  }
  if (which > (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL)) {
    return 0;
  }
  uint64_t v6 = *(uint64_t (**)(void))&dword_1EDA47898[4 * which + 2];
LABEL_24:

  return v6();
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  if (which <= (UCHAR_BINARY_LIMIT|UCHAR_CHANGES_WHEN_CASEMAPPED|0xF80))
  {
    if (which <= (UCHAR_BINARY_LIMIT|UCHAR_BIDI_CONTROL)) {
      return (*(uint64_t (**)(unsigned int *, void))&dword_1EDA47898[4 * which + 2])(&dword_1EDA47898[4 * which], *(void *)&c);
    }
    return 0;
  }
  if (which > UCHAR_VERTICAL_ORIENTATION)
  {
    if (which == UCHAR_GENERAL_CATEGORY_MASK) {
      return 1 << u_charType(c);
    }
    return 0;
  }
  int v3 = qword_1EDA47D48[4 * (which - 4096) + 2];

  return v3();
}

int32_t u_getIntPropertyMinValue(UProperty which)
{
  return 0;
}

int32_t u_getIntPropertyMaxValue(UProperty which)
{
  if (which > (UCHAR_BINARY_LIMIT|UCHAR_CHANGES_WHEN_CASEMAPPED|0xF80))
  {
    if (which <= UCHAR_VERTICAL_ORIENTATION) {
      return qword_1EDA47D48[4 * (which - 4096) + 3]();
    }
  }
  else if (which < (UCHAR_BINARY_LIMIT|UCHAR_BIDI_MIRRORED))
  {
    return 1;
  }
  return -1;
}

uint64_t sub_18C8A29CC(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0) {
    return 0;
  }
  if (a1 > 0x4A)
  {
    if (a1 >= 0x1000)
    {
      if (a1 <= 0x1018)
      {
        if (((0x1E3FEE5uLL >> a1) & 1) == 0) {
          return 2;
        }
        return LODWORD(qword_1EDA47D48[4 * a1 - 0x4000]);
      }
      if (!(a1 >> 14)) {
        return (a1 & 0xFFFFEFFF) == 0x2000;
      }
      if (a1 > 0x400D) {
        return 2 * (a1 == 28672);
      }
      if (a1 - 0x4000 < 0xD) {
        return dword_18CA81D64[a1 - 0x4000];
      }
    }
    return 0;
  }
  if (dword_1EDA47898[4 * a1 + 1]) {
    return 2;
  }
  return dword_1EDA47898[4 * a1];
}

uint64_t sub_18C8A2A94(uint64_t result, void *a2, UErrorCode *a3)
{
  if (*(int *)a3 > 0) {
    return result;
  }
  int v4 = result;
  if (result == 17)
  {
    for (uint64_t i = 0; i != 10; ++i)
      ((void (*)(void, void))a2[1])(*a2, dword_18CA81CE0[i]);
    for (uint64_t j = 0; j != 13; ++j)
    {
      unsigned int v7 = dword_18CA81D08[j];
      ((void (*)(void, void))a2[1])(*a2, v7);
      uint64_t result = ((uint64_t (*)(void, void))a2[1])(*a2, v7 + 1);
    }
    return result;
  }
  uint64_t result = sub_18C8A2BD8(a3);
  if (!result) {
    return result;
  }
  if ((v4 - 12) > 2)
  {
    int v13 = 1;
LABEL_17:
    *a3 = v13;
    return result;
  }
  signed int v9 = (uint64_t *)off_1E5508878[v4 - 12];
  uint64_t v10 = *v9;
  if (!*v9)
  {
    int v13 = 2;
    goto LABEL_17;
  }
  uint64_t result = ucptrie_getRange(*v9, 0, 0, 0, 0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    int v11 = result;
    uint64_t v12 = 0;
    do
    {
      ((void (*)(void, uint64_t))a2[1])(*a2, v12);
      uint64_t v12 = (v11 + 1);
      uint64_t result = ucptrie_getRange(v10, v12, 0, 0, 0, 0, 0);
      int v11 = result;
    }
    while ((result & 0x80000000) == 0);
  }
  return result;
}

BOOL sub_18C8A2BD8(UErrorCode *a1)
{
  if (*(int *)a1 > 0) {
    return 0;
  }
  if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191F14, memory_order_acquire) == 2
    || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191F14))
  {
    if (dword_1E9191F18 >= 1) {
      *a1 = dword_1E9191F18;
    }
  }
  else
  {
    sub_18C8A3AF8(a1);
    dword_1E9191F18 = *a1;
    icu::umtx_initImplPostInit(&dword_1E9191F14);
  }
  return *a1 < U_ILLEGAL_ARGUMENT_ERROR;
}

int32_t u_getFC_NFKC_Closure(UChar32 c, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (pErrorCode && *(int *)pErrorCode <= 0)
  {
    if (destCapacity < 0 || !dest && destCapacity)
    {
      int32_t v5 = 0;
      *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
      return v5;
    }
    NFKCuint64_t Instance = icu::Normalizer2::getNFKCInstance((icu::Normalizer2 *)pErrorCode, (UErrorCode *)dest);
    if (*(int *)pErrorCode <= 0)
    {
      int v11 = (icu::Normalizer2Factory *)NFKCInstance;
      uint64_t v41 = 0;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v38 = 0u;
      int v37 = &unk_1EDA47700;
      LOWORD(v38) = 2;
      BOOL v25 = 0;
      unsigned int v12 = ucase_toFullFolding(c, &v25, 0);
      if ((v12 & 0x80000000) != 0)
      {
        uint64_t Impl = icu::Normalizer2Factory::getImpl(v11, v13);
        unsigned int v16 = sub_18C81942C(Impl, c);
        if (v16 > 0xFE01 || *(unsigned __int16 *)(Impl + 18) > v16 || *(unsigned __int16 *)(Impl + 30) <= v16)
        {
          int32_t v5 = u_terminateUChars((uint64_t)dest, destCapacity, 0, (int *)pErrorCode);
LABEL_24:
          icu::UnicodeString::~UnicodeString(v21, (icu::UnicodeString *)&v37);
          return v5;
        }
        UChar32 v14 = c;
      }
      else
      {
        if (v12 < 0x20)
        {
          BOOL v24 = v25;
          icu::UnicodeString::setTo((icu::UnicodeString *)&v37, 0, &v24, v12);
          v22[1] = v24;
LABEL_19:
          uint64_t v36 = 0;
          long long v34 = 0u;
          long long v35 = 0u;
          long long v33 = 0u;
          unsigned int v32 = (UChar *)&unk_1EDA47700;
          LOWORD(v33) = 2;
          (*(void (**)(icu::Normalizer2Factory *, void **, UChar **, UErrorCode *))(*(void *)v11 + 24))(v11, &v37, &v32, pErrorCode);
          memset(v31, 0, sizeof(v31));
          icu::UnicodeString::UnicodeString((icu::UnicodeString *)v31, &v32);
          uint64_t v17 = icu::UnicodeString::foldCase((UChar **)v31, 0);
          long long v27 = 0u;
          long long v28 = 0u;
          long long v29 = 0u;
          uint64_t v30 = 0;
          unsigned int v26 = &unk_1EDA47700;
          LOWORD(v27) = 2;
          (*(void (**)(icu::Normalizer2Factory *, icu::UnicodeString *, void **, UErrorCode *))(*(void *)v11 + 24))(v11, v17, &v26, pErrorCode);
          if (*(int *)pErrorCode > 0 || sub_18C830FC4((uint64_t)&v32, (uint64_t)&v26))
          {
            int32_t v5 = u_terminateUChars((uint64_t)dest, destCapacity, 0, (int *)pErrorCode);
          }
          else
          {
            uint64_t v23 = dest;
            int32_t v5 = icu::UnicodeString::extract((uint64_t)&v26, &v23, destCapacity, (int *)pErrorCode);
            v22[0] = v23;
            uint64_t v18 = v22;
          }
          icu::UnicodeString::~UnicodeString(v18, (icu::UnicodeString *)&v26);
          icu::UnicodeString::~UnicodeString(v19, (icu::UnicodeString *)v31);
          icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)&v32);
          goto LABEL_24;
        }
        UChar32 v14 = v12;
      }
      sub_18C8A2FA8((uint64_t)&v37, v14);
      goto LABEL_19;
    }
  }
  return 0;
}

uint64_t sub_18C8A2FA8(uint64_t a1, unsigned int a2)
{
  icu::UnicodeString::unBogus(a1);
  if (*(__int16 *)(a1 + 8) < 0) {
    uint64_t v4 = *(unsigned int *)(a1 + 12);
  }
  else {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 8) >> 5;
  }

  return icu::UnicodeString::replace((icu::UnicodeString *)a1, 0, v4, a2);
}

BOOL sub_18C8A3004(int *a1, unsigned int a2)
{
  return (a1[1] & sub_18C84FE2C(a2, *a1)) != 0;
}

uint64_t sub_18C8A3040(uint64_t a1, unsigned int a2)
{
  return sub_18C84723C(a2);
}

uint64_t sub_18C8A3048(int a1, UChar32 c)
{
  return u_isMirrored_0(c);
}

BOOL sub_18C8A3050(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  int v6 = 0;
  uint64_t NFCImpl = icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)&v6, a2);
  BOOL result = 0;
  if (v6 <= 0)
  {
    unsigned int v5 = sub_18C81942C(NFCImpl, v2);
    return *(unsigned __int16 *)(NFCImpl + 18) <= v5 && *(unsigned __int16 *)(NFCImpl + 30) > v5;
  }
  return result;
}

uint64_t sub_18C8A30C4(uint64_t a1, unsigned int a2)
{
  return sub_18C8472B0(a2);
}

uint64_t sub_18C8A30CC(uint64_t a1, unsigned int a2, int a3)
{
  return (char)sub_18C84CDE0(a2, a3);
}

BOOL sub_18C8A30F0(uint64_t a1, uint64_t a2, int a3)
{
  int v7 = 0;
  uint64_t Instance = icu::Normalizer2Factory::getInstance(a3 - 35, (icu::Normalizer2Factory *)&v7);
  uint64_t v5 = 0;
  if (v7 <= 0) {
    return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)Instance + 136))(Instance, a2) != 0;
  }
  return v5;
}

BOOL sub_18C8A316C(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  UErrorCode v5 = U_ZERO_ERROR;
  uint64_t NFCImpl = (icu::Normalizer2Impl *)icu::Normalizer2Factory::getNFCImpl((icu::Normalizer2Factory *)&v5, a2);
  BOOL result = 0;
  if (v5 <= U_ZERO_ERROR)
  {
    BOOL result = icu::Normalizer2Impl::ensureCanonIterData(NFCImpl, &v5);
    if (result) {
      return icu::Normalizer2Impl::isCanonSegmentStarter(NFCImpl, v2);
    }
  }
  return result;
}

BOOL sub_18C8A31D8(uint64_t a1, unsigned int a2)
{
  return sub_18C84FF40(a2);
}

uint64_t sub_18C8A31E0(int a1, UChar32 c)
{
  return u_isblank(c);
}

BOOL sub_18C8A31E8(uint64_t a1, unsigned int a2)
{
  return sub_18C8504EC(a2);
}

BOOL sub_18C8A31F0(uint64_t a1, unsigned int a2)
{
  return sub_18C85044C(a2);
}

uint64_t sub_18C8A31F8(int a1, UChar32 c)
{
  return u_isxdigit(c);
}

BOOL sub_18C8A3200(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  long long v30 = 0u;
  uint64_t v33 = 0;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v29 = &unk_1EDA47700;
  LOWORD(v30) = 2;
  UErrorCode pErrorCode = U_ZERO_ERROR;
  NFCuint64_t Instance = icu::Normalizer2::getNFCInstance((icu::Normalizer2 *)&pErrorCode, a2);
  BOOL v4 = 0;
  unint64_t v5 = pErrorCode;
  if (pErrorCode > U_ZERO_ERROR) {
    goto LABEL_15;
  }
  if (!(*(unsigned int (**)(uint64_t, UErrorCode *, void **))(*(void *)NFCInstance + 56))(NFCInstance, v2, &v29))
  {
    if ((v2 & 0x80000000) != 0)
    {
      BOOL v4 = 0;
      goto LABEL_15;
    }
LABEL_14:
    *(void *)dest = 0;
    int v9 = ucase_toFullFolding(v2, dest, 0);
    unint64_t v5 = ~v9;
    BOOL v4 = v9 >= 0;
    goto LABEL_15;
  }
  unsigned int v6 = (unsigned __int16)v30;
  if (((__int16)v30 & 0x80000000) == 0)
  {
    if ((v30 & 0xFFE0) != 0x20)
    {
      if ((unsigned __int16)v30 > 0x5Fu) {
        goto LABEL_23;
      }
      int v7 = (unsigned __int16)v30 >> 5;
      goto LABEL_17;
    }
LABEL_10:
    if ((v30 & 2) != 0) {
      int v8 = (unsigned __int16 *)&v30 + 1;
    }
    else {
      int v8 = (unsigned __int16 *)v31;
    }
    LODWORD(v2) = *v8;
    goto LABEL_14;
  }
  int v7 = DWORD1(v30);
  if (DWORD1(v30) == 1) {
    goto LABEL_10;
  }
  if (SDWORD1(v30) >= 3) {
    goto LABEL_23;
  }
LABEL_17:
  unsigned int v11 = icu::UnicodeString::char32At((uint64_t *)(unsigned __int16)v30, (icu::UnicodeString *)&v29, 0);
  if (v11 < 0x10000) {
    int v12 = 1;
  }
  else {
    int v12 = 2;
  }
  if ((v11 & 0x80000000) == 0)
  {
    LODWORD(v2) = v11;
    if (v7 == v12) {
      goto LABEL_14;
    }
  }
  unsigned int v6 = (unsigned __int16)v30;
LABEL_23:
  long long v27 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)dest = 0u;
  if ((v6 & 0x11) != 0)
  {
    int v13 = 0;
  }
  else if ((v6 & 2) != 0)
  {
    int v13 = (const UChar *)&v30 + 1;
  }
  else
  {
    int v13 = (const UChar *)v31;
  }
  int v14 = (__int16)v6;
  int32_t v15 = v6 >> 5;
  if (v14 >= 0) {
    int32_t v16 = v15;
  }
  else {
    int32_t v16 = DWORD1(v30);
  }
  int32_t v17 = u_strFoldCase(dest, 62, v13, v16, 0, &pErrorCode);
  BOOL v4 = 0;
  unint64_t v5 = pErrorCode;
  if (pErrorCode <= U_ZERO_ERROR)
  {
    int32_t v18 = v17;
    if ((v30 & 0x11) != 0)
    {
      long long v19 = 0;
    }
    else if ((v30 & 2) != 0)
    {
      long long v19 = (const UChar *)&v30 + 1;
    }
    else
    {
      long long v19 = (const UChar *)v31;
    }
    if ((v30 & 0x8000u) == 0) {
      int32_t v20 = (unsigned __int16)v30 >> 5;
    }
    else {
      int32_t v20 = DWORD1(v30);
    }
    BOOL v4 = u_strCompare(v19, v20, dest, v18, 0) != 0;
  }
LABEL_15:
  icu::UnicodeString::~UnicodeString((void *)v5, (icu::UnicodeString *)&v29);
  return v4;
}

uint64_t sub_18C8A346C(uint64_t a1, UErrorCode *a2)
{
  unsigned int v2 = a2;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  UErrorCode v18 = U_ZERO_ERROR;
  NFKC_CFuint64_t Impl = icu::Normalizer2Factory::getNFKC_CFImpl((icu::Normalizer2Factory *)&v18, a2);
  uint64_t v4 = 0;
  if (v18 <= U_ZERO_ERROR)
  {
    unint64_t v5 = (UChar *)NFKC_CFImpl;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    icu::UnicodeString::UnicodeString((uint64_t)&v24, v2);
    long long v20 = 0u;
    uint64_t v23 = 0;
    long long v22 = 0u;
    long long v21 = 0u;
    long long v19 = &unk_1EDA47700;
    LOWORD(v20) = 2;
    long long v17 = 0u;
    int v13 = v5;
    int v14 = (icu::UnicodeString *)&v19;
    long long v16 = 0u;
    long long v15 = 0u;
    *(void *)((char *)&v16 + 5) = 0;
    if (icu::ReorderingBuffer::init((icu::ReorderingBuffer *)&v13, 5, &v18))
    {
      if ((BYTE8(v24) & 0x11) != 0)
      {
        unsigned int v6 = 0;
      }
      else if ((BYTE8(v24) & 2) != 0)
      {
        unsigned int v6 = (UChar *)((unint64_t)&v24 | 0xA);
      }
      else
      {
        unsigned int v6 = (UChar *)*((void *)&v25 + 1);
      }
      int v7 = WORD4(v24) >> 5;
      if (SWORD4(v24) < 0) {
        int v7 = HIDWORD(v24);
      }
      icu::Normalizer2Impl::compose((uint64_t)v5, v6, &v6[v7], 0, 1, &v13, &v18);
    }
    if ((void)v15) {
      icu::UnicodeString::releaseBuffer((uint64_t)v14, ((void)v16 - (void)v15) >> 1);
    }
    unint64_t v8 = v18;
    if (v18 <= U_ZERO_ERROR)
    {
      if (v20)
      {
        unint64_t v8 = BYTE8(v24) & 1;
      }
      else
      {
        unint64_t v8 = 0;
        if ((v20 & 0x8000u) == 0) {
          int v9 = (unsigned __int16)v20 >> 5;
        }
        else {
          int v9 = DWORD1(v20);
        }
        if ((SWORD4(v24) & 0x8000u) == 0) {
          int v10 = WORD4(v24) >> 5;
        }
        else {
          int v10 = HIDWORD(v24);
        }
        if ((BYTE8(v24) & 1) == 0 && v9 == v10) {
          unint64_t v8 = icu::UnicodeString::doEquals((icu::UnicodeString *)&v19, (const icu::UnicodeString *)&v24, v9);
        }
      }
      uint64_t v4 = v8 ^ 1;
    }
    else
    {
      uint64_t v4 = 0;
    }
    icu::UnicodeString::~UnicodeString((void *)v8, (icu::UnicodeString *)&v19);
    icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)&v24);
  }
  return v4;
}

BOOL sub_18C8A3674(uint64_t a1, unsigned int a2, int a3)
{
  return sub_18C7F80F0(a2, a3);
}

BOOL sub_18C8A3680(uint64_t a1, int a2)
{
  return (a2 - 127462) < 0x1A;
}

BOOL sub_18C8A3694(uint64_t a1, unsigned int a2)
{
  return a2 >> 1 == 6143;
}

BOOL sub_18C8A36A4(uint64_t a1, int a2)
{
  if (a2 < 8706) {
    return 0;
  }
  uint64_t v3 = 0;
  do
  {
    int v4 = dword_18CA81D08[v3];
    if (v4 == a2) {
      break;
    }
  }
  while (v3++ != 12);
  return v4 == a2;
}

BOOL sub_18C8A36EC(uint64_t a1, int a2)
{
  unint64_t v2 = 0;
  do
  {
    if (dword_18CA81CE0[v2] > a2) {
      return 0;
    }
    if (dword_18CA81CE0[v2 + 1] > a2) {
      return 1;
    }
    BOOL v3 = v2 > 7;
    v2 += 2;
  }
  while (!v3);
  if (a2 < 8706) {
    return 0;
  }
  uint64_t v5 = 0;
  do
  {
    int v6 = dword_18CA81D08[v5];
    if (v6 == a2) {
      break;
    }
  }
  while (v5++ != 12);
  return v6 == a2;
}

uint64_t sub_18C8A3774(int a1, UChar32 c)
{
  return u_charDirection(c);
}

uint64_t sub_18C8A377C(uint64_t a1, int a2)
{
  return sub_18C84702C(a2);
}

uint64_t sub_18C8A3784(int *a1, unsigned int a2)
{
  return ((int)(a1[1] & sub_18C84FE2C(a2, *a1)) >> a1[2]);
}

uint64_t sub_18C8A37C0(int *a1)
{
  return (a1[1] & sub_18C850BFC(*a1)) >> a1[2];
}

uint64_t sub_18C8A37F4(int a1, UChar32 c)
{
  return u_getCombiningClass(c);
}

uint64_t sub_18C8A3810(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_18C8A3818(int a1, UChar32 c)
{
  return u_charType(c);
}

uint64_t sub_18C8A3834(uint64_t a1, int a2)
{
  return sub_18C847398(a2);
}

uint64_t sub_18C8A383C(uint64_t a1, unsigned int a2)
{
  return sub_18C847324(a2);
}

uint64_t sub_18C8A3844(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = sub_18C850B8C(a2);
  if (v2 < 0x540) {
    int v3 = 2;
  }
  else {
    int v3 = 3;
  }
  if (v2 >= 0x2C0) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 1;
  }
  if (v2 >= 0x40) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t sub_18C8A3880(uint64_t a1, unsigned int a2)
{
  int v3 = 0;
  return uscript_getScript(a2, &v3);
}

uint64_t sub_18C8A38AC()
{
  unsigned int v0 = sub_18C850BFC(0);
  return v0 | (((v0 >> 20) & 3) << 8);
}

uint64_t sub_18C8A38D4(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = (sub_18C84FE2C(a2, 2) >> 5) & 0x1F;
  if (v2 > 9) {
    return 0;
  }
  else {
    return dword_18CA81D3C[v2];
  }
}

uint64_t sub_18C8A3914(int a1, uint64_t a2, int a3)
{
  return sub_18C7FBFE4(a2, a3 - 4106);
}

uint64_t sub_18C8A3924(uint64_t a1, signed int a2)
{
  return sub_18C818318(a2) >> 8;
}

uint64_t sub_18C8A3944(uint64_t a1, signed int a2)
{
  return sub_18C818318(a2);
}

uint64_t sub_18C8A3964(uint64_t a1, unsigned int a2)
{
  return sub_18C8473D8(a2);
}

uint64_t sub_18C8A396C(uint64_t a1, unsigned int a2)
{
  int v5 = 0;
  BOOL v3 = sub_18C8A2BD8((UErrorCode *)&v5);
  uint64_t result = 0;
  if (v3)
  {
    if (qword_1E9191EF0) {
      return ucptrie_get(qword_1E9191EF0, a2);
    }
  }
  return result;
}

uint64_t sub_18C8A39C4(uint64_t a1, int a2)
{
  int v4 = 0;
  uint64_t result = sub_18C8A2BD8((UErrorCode *)&v4);
  if (result)
  {
    switch(a2)
    {
      case 4120:
        return dword_1E9191F10;
      case 4119:
        return dword_1E9191F0C;
      case 4118:
        return dword_1E9191F08;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t sub_18C8A3A48(uint64_t a1, unsigned int a2)
{
  int v5 = 0;
  BOOL v3 = sub_18C8A2BD8((UErrorCode *)&v5);
  uint64_t result = 0;
  if (v3)
  {
    if (qword_1E9191EF8) {
      return ucptrie_get(qword_1E9191EF8, a2);
    }
  }
  return result;
}

uint64_t sub_18C8A3AA0(uint64_t a1, unsigned int a2)
{
  int v5 = 0;
  BOOL v3 = sub_18C8A2BD8((UErrorCode *)&v5);
  uint64_t result = 0;
  if (v3)
  {
    if (qword_1E9191F00) {
      return ucptrie_get(qword_1E9191F00, a2);
    }
  }
  return result;
}

void sub_18C8A3AF8(UErrorCode *a1)
{
  unsigned int v2 = udata_openChoice(0, "icu", "ulayout", (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18C8A3C70, 0, a1);
  qword_1E9191F20 = (uint64_t)v2;
  if (*(int *)a1 <= 0)
  {
    uint64_t Memory = (int *)udata_getMemory((uint64_t)v2);
    uint64_t v4 = *Memory;
    if ((int)v4 > 11)
    {
      int v5 = Memory;
      uint64_t v6 = 4 * v4;
      uint64_t v7 = Memory[1];
      if ((int)v7 - (int)v6 >= 16) {
        qword_1E9191EF0 = (uint64_t)ucptrie_openFromBinary(-1, -1, (uint64_t)&Memory[(unint64_t)v6 / 4], (int)v7 - (int)v6, 0, (int *)a1);
      }
      uint64_t v8 = v5[2];
      if ((int)v8 - (int)v7 >= 16) {
        qword_1E9191EF8 = (uint64_t)ucptrie_openFromBinary(-1, -1, (uint64_t)v5 + v7, (int)v8 - (int)v7, 0, (int *)a1);
      }
      int v9 = v5[3] - v8;
      if (v9 >= 16) {
        qword_1E9191F00 = (uint64_t)ucptrie_openFromBinary(-1, -1, (uint64_t)v5 + v8, v9, 0, (int *)a1);
      }
      unsigned int v10 = v5[9];
      dword_1E9191F08 = HIBYTE(v10);
      dword_1E9191F0C = BYTE2(v10);
      dword_1E9191F10 = BYTE1(v10);
      sub_18C8546F4(0x14u, (uint64_t)sub_18C8A3CD4);
    }
    else
    {
      *a1 = U_INVALID_FORMAT_ERROR;
    }
  }
}

BOOL sub_18C8A3C70(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  return *(unsigned __int16 *)a4 >= 0x14u
      && !a4[4]
      && !a4[5]
      && a4[8] == 76
      && a4[9] == 97
      && a4[10] == 121
      && a4[11] == 111
      && a4[12] == 1;
}

uint64_t sub_18C8A3CD4()
{
  qword_1E9191F20 = 0;
  ucptrie_close(qword_1E9191EF0);
  qword_1E9191EF0 = 0;
  ucptrie_close(qword_1E9191EF8);
  qword_1E9191EF8 = 0;
  ucptrie_close(qword_1E9191F00);
  qword_1E9191F00 = 0;
  dword_1E9191F08 = 0;
  dword_1E9191F0C = 0;
  dword_1E9191F10 = 0;
  atomic_store(0, &dword_1E9191F14);
  return 1;
}

char *urbtok_open(int a1, const char *a2, const icu::Locale *a3)
{
  uint64_t result = ubrk_open(a1, a2, 0, 0, a3);
  if (*(int *)a3 <= 0) {
    icu::RuleBasedBreakIterator::initLatin1Cat((icu::RuleBasedBreakIterator *)result);
  }
  return result;
}

uint64_t urbtok_openRules(uint64_t a1, uint64_t a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a4 && *(int *)a4 <= 0)
  {
    memset(v9, 0, sizeof(v9));
    icu::UnicodeString::UnicodeString((uint64_t)v9, a1, a2);
    uint64_t v6 = sub_18C82F078((UChar **)v9, a3, a4);
    uint64_t v7 = (void *)*(unsigned int *)a4;
    if ((int)v7 <= 0) {
      icu::RuleBasedBreakIterator::initLatin1Cat(v6);
    }
    icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)v9);
  }
  return 0;
}

uint64_t urbtok_openBinaryRules(unsigned int *a1, UErrorCode *a2)
{
  if (a2 && *(int *)a2 <= 0)
  {
    size_t v5 = a1[2];
    uint64_t v6 = uprv_malloc(v5);
    if (!v6)
    {
      *a2 = U_MEMORY_ALLOCATION_ERROR;
      return 0;
    }
    uint64_t v7 = (uint64_t)v6;
    memcpy(v6, a1, v5);
    uint64_t v10 = (icu::RuleBasedBreakIterator *)icu::UMemory::operator new(v9, (icu::UMemory *)0x310, v8);
    unsigned int v11 = v10;
    if (v10)
    {
      icu::RuleBasedBreakIterator::RuleBasedBreakIterator(v10, v7, a2);
      if (*(int *)a2 >= 1)
      {
        (*(void (**)(icu::RuleBasedBreakIterator *))(*(void *)v11 + 8))(v11);
        return 0;
      }
    }
    else if (*(int *)a2 >= 1)
    {
      return 0;
    }
    icu::RuleBasedBreakIterator::initLatin1Cat(v11);
  }
  return 0;
}

uint64_t urbtok_openBinaryRulesNoCopy(uint64_t a1, UErrorCode *a2)
{
  if (a2)
  {
    BOOL v3 = (uint64_t *)*(unsigned int *)a2;
    if ((int)v3 <= 0)
    {
      unsigned int v6 = *(_DWORD *)(a1 + 8);
      uint64_t v7 = (icu::RuleBasedBreakIterator *)icu::UMemory::operator new(v3, (icu::UMemory *)0x310, (unint64_t)a2);
      unint64_t v8 = v7;
      if (v7)
      {
        icu::RuleBasedBreakIterator::RuleBasedBreakIterator(v7, (const unsigned __int8 *)a1, v6, a2);
        if (*(int *)a2 >= 1)
        {
          (*(void (**)(icu::RuleBasedBreakIterator *))(*(void *)v8 + 8))(v8);
          return 0;
        }
      }
      else if (*(int *)a2 >= 1)
      {
        return 0;
      }
      icu::RuleBasedBreakIterator::initLatin1Cat(v8);
    }
  }
  return 0;
}

uint64_t urbtok_getBinaryRules(const void *a1, void *a2, unsigned int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if ((a2 || !a3) {
      && a1
    }
    {
      LODWORD(__n) = 0;
      int v9 = (const void *)(*(uint64_t (**)(void *, size_t *))(*(void *)v8 + 200))(v8, &__n);
      uint64_t v5 = __n;
      if (!a2) {
        return v5;
      }
      if (__n <= a3)
      {
        memcpy(a2, v9, __n);
        return v5;
      }
      int v10 = 15;
    }
    else
    {
      uint64_t v5 = 0;
      int v10 = 1;
    }
    *a4 = v10;
    return v5;
  }
  return 0;
}

unint64_t urbtok_tokenize(uint64_t a1, int a2, char *a3, void *a4)
{
  if (a1 && a3) {
    return icu::RuleBasedBreakIterator::tokenize(a1, a2, a3, a4);
  }
  else {
    return 0;
  }
}

_OWORD *urbtok_swapBinaryRules(_DWORD *a1, void *a2, int a3, int a4, int *a5)
{
  char v6 = a3;
  uint64_t result = udata_openSwapper(a3, 0, a4, 0, a5);
  if (a5 && *a5 <= 0)
  {
    uint64_t v10 = (uint64_t)result;
    unsigned int v11 = (*((uint64_t (**)(void))result + 2))(a1[2]);
    size_t v12 = v11 + 24;
    int v13 = uprv_malloc(v12);
    if (v13)
    {
      int v14 = v13;
      long long v15 = (unsigned __int16 *)uprv_malloc(v12);
      if (v15)
      {
        long long v16 = v15;
        *int v14 = (*(uint64_t (**)(uint64_t))(v10 + 8))(24);
        v14[1] = 10202;
        v14[2] = (*(uint64_t (**)(uint64_t))(v10 + 8))(20);
        _OWORD v14[3] = 0;
        *((unsigned char *)v14 + 8) = v6;
        *(_WORD *)((char *)v14 + 9) = 512;
        *((unsigned char *)v14 + 11) = 0;
        int v17 = a1[1];
        *((_DWORD *)v14 + 3) = 543912514;
        *((_DWORD *)v14 + 4) = v17;
        *((_DWORD *)v14 + 5) = 260;
        memcpy(v14 + 12, a1, v11);
        int v21 = ubrk_swap(v10, (uint64_t)v14, v12, v16, a5, v18, v19, v20);
        if (*a5 > 0 || v21 == v12)
        {
          if (*a5 <= 0) {
            memcpy(a2, v16 + 12, v11);
          }
        }
        else
        {
          *a5 = 3;
        }
        uprv_free(v16);
      }
      else
      {
        *a5 = 7;
      }
      uprv_free(v14);
    }
    else
    {
      *a5 = 7;
    }
    return (_OWORD *)udata_closeSwapper(v10);
  }
  return result;
}

icu::RuleBasedTokenizer *urbtok57_openRules(uint64_t a1, uint64_t a2, UParseError *a3, UErrorCode *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!a4 || *(int *)a4 > 0) {
    return 0;
  }
  memset(v12, 0, sizeof(v12));
  icu::UnicodeString::UnicodeString((uint64_t)v12, a1, a2);
  int v9 = (icu::RuleBasedTokenizer *)icu::UMemory::operator new(v8, (icu::UMemory *)0x260, v7);
  uint64_t v5 = v9;
  if (v9)
  {
    icu::RuleBasedTokenizer::RuleBasedTokenizer(v9, (const icu::UnicodeString *)v12, a3, a4);
    uint64_t v10 = (void *)*(unsigned int *)a4;
    if ((int)v10 >= 1)
    {
      (*(void (**)(icu::RuleBasedTokenizer *))(*(void *)v5 + 8))(v5);
      uint64_t v5 = 0;
    }
  }
  icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v12);
  return v5;
}

uint64_t *urbtok57_openBinaryRules(unsigned int *a1, UErrorCode *a2)
{
  if (!a2) {
    return 0;
  }
  if (*(int *)a2 > 0) {
    return 0;
  }
  size_t v5 = a1[2];
  uint64_t result = (uint64_t *)uprv_malloc(v5);
  if (!result)
  {
    *a2 = U_MEMORY_ALLOCATION_ERROR;
    return result;
  }
  char v6 = (unsigned __int8 *)result;
  memcpy(result, a1, v5);
  uint64_t result = icu::UMemory::operator new(v8, (icu::UMemory *)0x260, v7);
  if (result)
  {
    uint64_t result = (uint64_t *)icu::RuleBasedTokenizer::RuleBasedTokenizer((icu::RuleBasedTokenizer *)result, v6, a2);
    if (*(int *)a2 >= 1)
    {
      (*(void (**)(uint64_t *))(*result + 8))(result);
      return 0;
    }
  }
  return result;
}

uint64_t urbtok57_openBinaryRulesNoCopy(uint64_t a1, int *a2)
{
  if (!a2) {
    return 0;
  }
  if (*a2 > 0) {
    return 0;
  }
  uint64_t result = icu::UMemory::operator new((icu::UMemory *)0x260, (unint64_t)a2);
  if (result)
  {
    uint64_t result = icu::RuleBasedTokenizer::RuleBasedTokenizer(result, a1, 0, a2);
    if (*a2 >= 1)
    {
      (*(void (**)(uint64_t))(*(void *)result + 8))(result);
      return 0;
    }
  }
  return result;
}

uint64_t urbtok57_getBinaryRules(const void *a1, void *a2, unsigned int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if ((a2 || !a3) {
      && a1
    }
    {
      LODWORD(__n) = 0;
      int v9 = (const void *)(*(uint64_t (**)(void *, size_t *))(*(void *)v8 + 192))(v8, &__n);
      uint64_t v5 = __n;
      if (!a2) {
        return v5;
      }
      if (__n <= a3)
      {
        memcpy(a2, v9, __n);
        return v5;
      }
      int v10 = 15;
    }
    else
    {
      uint64_t v5 = 0;
      int v10 = 1;
    }
    *a4 = v10;
    return v5;
  }
  return 0;
}

uint64_t ures_openU(UChar *a1, char *a2, int *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a3 || *a3 > 0) {
    return 0;
  }
  bzero(v13, 0x400uLL);
  if (!a1)
  {
    unint64_t v8 = 0;
    return ures_open(v8, a2, a3);
  }
  int32_t v7 = u_strlen(a1);
  if (v7 >= 1024)
  {
LABEL_7:
    uint64_t result = 0;
    *a3 = 1;
    return result;
  }
  int v9 = v7;
  if (uprv_isInvariantUString(a1, v7))
  {
    int32_t v10 = v9 + 1;
    unint64_t v8 = v13;
    u_UCharsToChars(a1, v13, v10);
    return ures_open(v8, a2, a3);
  }
  uint64_t DefaultConverter = (void *)u_getDefaultConverter((UErrorCode *)a3);
  int v12 = ucnv_fromUChars((uint64_t)DefaultConverter, (unint64_t)v13, 1024, a1, v9, a3);
  u_releaseDefaultConverter(DefaultConverter);
  if (*a3 <= 0)
  {
    if (v12 >= 1024) {
      goto LABEL_7;
    }
    unint64_t v8 = v13;
    return ures_open(v8, a2, a3);
  }
  return 0;
}

uint64_t ures_getLocParent(char *Default, void *a2, int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if (!Default) {
    Default = (char *)uloc_getDefault(0);
  }
  unint64_t v8 = (const char *)sub_18C8A4844(Default, (uint64_t)"ar_Latn", (uint64_t)"ar_Latn", dword_18CA826C8, 714);
  if (!v8) {
    return 0;
  }
  int v9 = v8;
  size_t v10 = strlen(v8);
  int v11 = uprv_min(v10, a3);
  memcpy(a2, v9, v11);

  return u_terminateChars((uint64_t)a2, a3, v10, a4);
}

uint64_t sub_18C8A4844(char *__s1, uint64_t a2, uint64_t a3, int *a4, int a5)
{
  if (!a5) {
    return 0;
  }
  uint64_t v5 = a4;
  int v9 = &a4[a5];
  while (1)
  {
    size_t v10 = &v5[2 * ((v9 - v5 + (v9 - v5 < 0 ? 3uLL : 0)) >> 2)];
    int v11 = strcmp(__s1, (const char *)(a2 + *v10));
    if (!v11) {
      break;
    }
    if (v11 < 0) {
      int v9 = &v5[2 * ((v9 - v5 + (v9 - v5 < 0 ? 3uLL : 0)) >> 2)];
    }
    else {
      uint64_t v5 = v10 + 2;
    }
    if (v5 >= v9) {
      return 0;
    }
  }
  return a3 + v10[1];
}

double ures_initStackObject(uint64_t a1)
{
  *(void *)(a1 + 128) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

double icu::StackUResourceBundle::StackUResourceBundle(icu::StackUResourceBundle *this)
{
  *((void *)this + 16) = 0;
  double result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 16) = 0;
  double result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void icu::StackUResourceBundle::~StackUResourceBundle(icu::StackUResourceBundle *this)
{
}

{
  sub_18C8A49A0((uint64_t)this, 1);
}

void ures_close(uint64_t a1)
{
}

void sub_18C8A49A0(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4) {
      sub_18C8A87F0(v4);
    }
    uint64_t v5 = *(void **)(a1 + 16);
    if (v5) {
      uprv_free(v5);
    }
    char v6 = *(void **)(a1 + 32);
    if (v6 && v6 != (void *)(a1 + 40)) {
      uprv_free(v6);
    }
    *(void *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 104) = 0;
    if (*(_DWORD *)(a1 + 116) == 19700503 && a2 && *(_DWORD *)(a1 + 120) == 19641227)
    {
      uprv_free((void *)a1);
    }
  }
}

char *sub_18C8A4A4C(uint64_t a1, long long *a2, int *a3)
{
  BOOL v3 = (char *)a1;
  if (a2 && (long long *)a1 != a2 && *a3 <= 0)
  {
    if (a1)
    {
      BOOL v6 = *(_DWORD *)(a1 + 116) != 19700503 || *(_DWORD *)(a1 + 120) != 19641227;
      sub_18C8A49A0(a1, 0);
    }
    else
    {
      BOOL v3 = (char *)uprv_malloc(0x88uLL);
      if (!v3)
      {
        *a3 = 7;
        return v3;
      }
      BOOL v6 = 0;
    }
    long long v7 = a2[3];
    long long v8 = a2[4];
    long long v9 = a2[1];
    *((_OWORD *)v3 + 2) = a2[2];
    long long v10 = a2[7];
    uint64_t v11 = *((void *)a2 + 16);
    long long v12 = a2[5];
    *((_OWORD *)v3 + 6) = a2[6];
    long long v13 = *a2;
    *((_OWORD *)v3 + 3) = v7;
    *((_OWORD *)v3 + 4) = v8;
    *(_OWORD *)BOOL v3 = v13;
    *((_OWORD *)v3 + sub_18C8A49A0((uint64_t)this, 1) = v9;
    *((void *)v3 + 16) = v11;
    *((_OWORD *)v3 + 7) = v10;
    *((_OWORD *)v3 + 5) = v12;
    *((void *)v3 + 4) = 0;
    *((_DWORD *)v3 + 26) = 0;
    uint64_t v14 = (char *)*((void *)a2 + 4);
    if (v14) {
      sub_18C8A4B80((uint64_t)v3, v14, *((_DWORD *)a2 + 26), a3);
    }
    *(int8x8_t *)(v3 + 116) = vand_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(!v6), 0x1FuLL)), (int8x8_t)0x12BB38B012C9B17);
    uint64_t v15 = *((void *)v3 + 1);
    if (v15) {
      sub_18C8A4C5C(v15);
    }
  }
  return v3;
}

char *sub_18C8A4B80(uint64_t a1, char *__src, int a3, _DWORD *a4)
{
  int v7 = *(_DWORD *)(a1 + 104);
  double result = *(char **)(a1 + 32);
  if (result)
  {
    int v9 = v7;
  }
  else
  {
    int v9 = 0;
    *(unsigned char *)(a1 + 40) = 0;
    double result = (char *)(a1 + 40);
    *(void *)(a1 + 32) = a1 + 40;
  }
  int v10 = v9 + a3;
  *(_DWORD *)(a1 + 104) = v10;
  if (v10 >= 63)
  {
    if (result == (char *)(a1 + 40))
    {
      double result = (char *)uprv_malloc((v10 + 1));
      *(void *)(a1 + 32) = result;
      if (result)
      {
        double result = strcpy(result, (const char *)(a1 + 40));
        goto LABEL_10;
      }
    }
    else
    {
      double result = (char *)uprv_realloc(result, (v10 + 1));
      if (result)
      {
        *(void *)(a1 + 32) = result;
        goto LABEL_10;
      }
    }
    *a4 = 7;
    return result;
  }
LABEL_10:
  uint64_t v11 = &result[v7];

  return strcpy(v11, __src);
}

void sub_18C8A4C5C(uint64_t a1)
{
  umtx_lock((atomic_ullong *)&unk_1EB20B690);
  ++*(_DWORD *)(a1 + 108);
  for (uint64_t i = *(void *)(a1 + 16); i; uint64_t i = *(void *)(i + 16))
    ++*(_DWORD *)(i + 108);

  umtx_unlock((std::mutex **)&unk_1EB20B690);
}

const UChar *ures_getString(uint64_t a1, int *a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0;
  }
  if (!a1)
  {
    int v5 = 1;
    goto LABEL_9;
  }
  double result = res_getStringNoTrace(*(void *)(a1 + 8) + 40, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    int v5 = 17;
LABEL_9:
    double result = 0;
    *a3 = v5;
  }
  return result;
}

char *ures_getUTF8String(uint64_t a1, char *a2, int32_t *a3, int a4, int *a5)
{
  int32_t srcLength = 0;
  String = (UChar *)ures_getString(a1, &srcLength, a5);
  return sub_18C8A4D98(String, srcLength, a2, a3, a4, a5);
}

char *sub_18C8A4D98(UChar *src, int32_t srcLength, char *dest, int32_t *pDestLength, int a5, int *a6)
{
  if (*a6 > 0) {
    return 0;
  }
  BOOL v6 = dest;
  if (!pDestLength)
  {
    int v9 = 0;
    if (srcLength) {
      goto LABEL_12;
    }
    if (!a5) {
      return "";
    }
LABEL_10:
    u_terminateChars((uint64_t)dest, v9, 0, a6);
    return v6;
  }
  int v9 = *pDestLength;
  if (*pDestLength < 0 || !dest && v9)
  {
    BOOL v6 = 0;
    *a6 = 1;
    return v6;
  }
  if (!srcLength)
  {
    *int32_t pDestLength = 0;
    if (!a5) {
      return "";
    }
    goto LABEL_10;
  }
LABEL_12:
  if (v9 >= srcLength)
  {
    if (srcLength <= 715827882)
    {
      int v11 = 3 * srcLength;
      int v12 = v9 - (3 * srcLength + 1);
      if (v9 <= 3 * srcLength + 1) {
        int v12 = 0;
      }
      long long v13 = &dest[v12];
      if (v9 >= v11 + 1) {
        int v14 = v11 + 1;
      }
      else {
        int v14 = v9;
      }
      if (!a5)
      {
        BOOL v6 = v13;
        int v9 = v14;
      }
    }
    int v10 = v6;
  }
  else
  {
    int v10 = 0;
    int v9 = 0;
  }

  return u_strToUTF8(v10, v9, pDestLength, src, srcLength, (UErrorCode *)a6);
}

int *ures_getBinary(uint64_t a1, int *a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0;
  }
  if (!a1)
  {
    int v5 = 1;
    goto LABEL_9;
  }
  double result = res_getBinaryNoTrace(*(void *)(a1 + 8) + 40, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    int v5 = 17;
LABEL_9:
    double result = 0;
    *a3 = v5;
  }
  return result;
}

int *ures_getIntVector(uint64_t a1, int *a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0;
  }
  if (!a1)
  {
    int v5 = 1;
    goto LABEL_9;
  }
  double result = res_getIntVectorNoTrace(*(void *)(a1 + 8) + 40, *(_DWORD *)(a1 + 108), a2);
  if (!result)
  {
    int v5 = 17;
LABEL_9:
    double result = 0;
    *a3 = v5;
  }
  return result;
}

uint64_t ures_getInt(uint64_t a1, int *a2)
{
  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      unsigned int v2 = *(_DWORD *)(a1 + 108);
      if (v2 >> 28 == 7) {
        return ((int)(16 * v2) >> 4);
      }
      int v4 = 17;
    }
    else
    {
      int v4 = 1;
    }
    *a2 = v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ures_getUInt(uint64_t a1, int *a2)
{
  if (a2 && *a2 <= 0)
  {
    if (a1)
    {
      unsigned int v2 = *(_DWORD *)(a1 + 108);
      if (v2 >> 28 == 7) {
        return v2 & 0xFFFFFFF;
      }
      int v4 = 17;
    }
    else
    {
      int v4 = 1;
    }
    *a2 = v4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ures_getType(uint64_t a1)
{
  if (a1) {
    return res_getPublicType(*(_DWORD *)(a1 + 108));
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ures_getKey(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t ures_getSize(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 128);
  }
  return result;
}

uint64_t ures_resetIterator(uint64_t result)
{
  if (result) {
    *(_DWORD *)(result + 124) = -1;
  }
  return result;
}

BOOL ures_hasNext(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 124) < *(_DWORD *)(result + 128) - 1;
  }
  return result;
}

const UChar *ures_getNextString(uint64_t a1, int *a2, void *a3, UErrorCode *a4)
{
  if (!a4 || *(int *)a4 > 0) {
    return 0;
  }
  if (!a1)
  {
    int v7 = 1;
    goto LABEL_7;
  }
  int v6 = *(_DWORD *)(a1 + 124);
  if (v6 == *(_DWORD *)(a1 + 128) - 1)
  {
    int v7 = 8;
LABEL_7:
    *a4 = v7;
    return 0;
  }
  unsigned int v11 = v6 + 1;
  *(_DWORD *)(a1 + 124) = v6 + 1;
  unsigned int v12 = *(_DWORD *)(a1 + 108);
  switch(v12 >> 28)
  {
    case 0u:
    case 6u:
      uint64_t v14 = *(void *)(a1 + 8) + 40;
      return res_getStringNoTrace(v14, v12, a2);
    case 1u:
    case 7u:
    case 0xEu:
      int v7 = 17;
      goto LABEL_7;
    case 2u:
    case 4u:
    case 5u:
      TableItemByint Index = res_getTableItemByIndex(*(void *)(a1 + 8) + 40, v12, v11, a3);
      goto LABEL_16;
    case 3u:
      goto LABEL_17;
    case 8u:
    case 9u:
      TableItemByint Index = res_getArrayItem(*(void *)(a1 + 8) + 40, v12, v11);
LABEL_16:
      unsigned int v12 = TableItemByIndex;
      unsigned int v11 = *(_DWORD *)(a1 + 124);
LABEL_17:
      double result = sub_18C8A51BC(a1, v12, v11, a2, a4);
      break;
    default:
      return 0;
  }
  return result;
}

const UChar *sub_18C8A51BC(uint64_t a1, unsigned int a2, signed int a3, int *a4, UErrorCode *a5)
{
  if (a2 >> 28 == 3)
  {
    int v7 = ures_getByIndex(a1, a3, 0, a5);
    String = ures_getString((uint64_t)v7, a4, (int *)a5);
    sub_18C8A49A0((uint64_t)v7, 1);
    return String;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 8) + 40;
    return res_getStringNoTrace(v10, a2, a4);
  }
}

char *ures_getNextResource(uint64_t a1, uint64_t a2, UErrorCode *a3)
{
  uint64_t v14 = 0;
  if (!a3 || *(int *)a3 > 0) {
    return (char *)a2;
  }
  if (!a1)
  {
    int v7 = 1;
    goto LABEL_7;
  }
  int v6 = *(_DWORD *)(a1 + 124);
  if (v6 == *(_DWORD *)(a1 + 128) - 1)
  {
    int v7 = 8;
LABEL_7:
    *a3 = v7;
    return (char *)a2;
  }
  unsigned int v9 = v6 + 1;
  *(_DWORD *)(a1 + 124) = v6 + 1;
  unsigned int v10 = *(_DWORD *)(a1 + 108);
  unsigned int v11 = v10 >> 28;
  if (v10 >> 28 == 15) {
    return (char *)a2;
  }
  if (((1 << v11) & 0x40C3) == 0)
  {
    if (((1 << v11) & 0x34) != 0)
    {
      TableItemByint Index = res_getTableItemByIndex(*(void *)(a1 + 8) + 40, v10, v9, &v14);
      return (char *)sub_18C8A8850(*(void *)(a1 + 8), TableItemByIndex, v14, *(_DWORD *)(a1 + 124), *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a2, a3);
    }
    else if (((1 << v11) & 0x300) != 0)
    {
      ArrayItesigned int m = res_getArrayItem(*(void *)(a1 + 8) + 40, v10, v9);
      return (char *)sub_18C8A8850(*(void *)(a1 + 8), ArrayItem, 0, *(_DWORD *)(a1 + 124), *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a2, a3);
    }
    return (char *)a2;
  }

  return sub_18C8A4A4C(a2, (long long *)a1, (int *)a3);
}

char *ures_getByIndex(uint64_t a1, signed int a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v4 = a3;
  uint64_t v14 = 0;
  if (!a4 || *(int *)a4 > 0) {
    return (char *)v4;
  }
  if (!a1)
  {
    int v11 = 1;
    goto LABEL_12;
  }
  if (a2 < 0 || *(_DWORD *)(a1 + 128) <= a2)
  {
    int v11 = 2;
LABEL_12:
    *a4 = v11;
    return (char *)v4;
  }
  unsigned int v8 = *(_DWORD *)(a1 + 108);
  unsigned int v9 = v8 >> 28;
  if (v8 >> 28 == 15) {
    return (char *)v4;
  }
  if (((1 << v9) & 0x40C3) == 0)
  {
    if (((1 << v9) & 0x34) != 0)
    {
      TableItemByint Index = res_getTableItemByIndex(*(void *)(a1 + 8) + 40, v8, a2, &v14);
      return (char *)sub_18C8A8850(*(void *)(a1 + 8), TableItemByIndex, v14, a2, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, v4, a4);
    }
    else if (((1 << v9) & 0x300) != 0)
    {
      ArrayItesigned int m = res_getArrayItem(*(void *)(a1 + 8) + 40, v8, a2);
      return (char *)sub_18C8A8850(*(void *)(a1 + 8), ArrayItem, 0, a2, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, v4, a4);
    }
    return (char *)v4;
  }

  return sub_18C8A4A4C(a3, (long long *)a1, (int *)a4);
}

const UChar *ures_getStringByIndex(uint64_t a1, signed int a2, int *a3, UErrorCode *a4)
{
  uint64_t v13 = 0;
  if (!a4 || *(int *)a4 > 0) {
    return 0;
  }
  if (!a1)
  {
    double result = 0;
    int v10 = 1;
    goto LABEL_11;
  }
  if (a2 < 0 || *(_DWORD *)(a1 + 128) <= a2)
  {
    double result = 0;
    int v10 = 2;
LABEL_11:
    *a4 = v10;
    return result;
  }
  ArrayItesigned int m = *(_DWORD *)(a1 + 108);
  switch(ArrayItem >> 28)
  {
    case 0u:
    case 6u:
      uint64_t v12 = *(void *)(a1 + 8) + 40;
      return res_getStringNoTrace(v12, ArrayItem, a3);
    case 1u:
    case 7u:
    case 0xEu:
      double result = 0;
      int v10 = 17;
      goto LABEL_11;
    case 2u:
    case 4u:
    case 5u:
      TableItemByint Index = res_getTableItemByIndex(*(void *)(a1 + 8) + 40, ArrayItem, a2, &v13);
      return sub_18C8A51BC(a1, TableItemByIndex, a2, a3, a4);
    case 3u:
      goto LABEL_18;
    case 8u:
    case 9u:
      ArrayItesigned int m = res_getArrayItem(*(void *)(a1 + 8) + 40, ArrayItem, a2);
LABEL_18:
      double result = sub_18C8A51BC(a1, ArrayItem, a2, a3, a4);
      break;
    default:
      double result = 0;
      int v10 = 5;
      goto LABEL_11;
  }
  return result;
}

char *ures_getUTF8StringByIndex(uint64_t a1, signed int a2, char *a3, int32_t *a4, int a5, UErrorCode *a6)
{
  int32_t srcLength = 0;
  StringByint Index = (UChar *)ures_getStringByIndex(a1, a2, &srcLength, a6);
  return sub_18C8A4D98(StringByIndex, srcLength, a3, a4, a5, (int *)a6);
}

uint64_t ures_findResource(const char *a1, uint64_t a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    size_t v6 = (int)(strlen(a1) + 1);
    int v7 = uprv_malloc(v6);
    if (v7)
    {
      unsigned int v8 = v7;
      memcpy(v7, a1, v6);
      if (*v8 == 47)
      {
        unsigned int v9 = v8 + 1;
        int v10 = strchr(v8 + 1, 47);
        if (v10)
        {
          *int v10 = 0;
          int v11 = v10 + 1;
          goto LABEL_11;
        }
        *a3 = 1;
      }
      else
      {
        unsigned int v9 = 0;
      }
      int v11 = v8;
LABEL_11:
      uint64_t v12 = strchr(v11, 47);
      if (v12)
      {
        uint64_t v13 = v12;
        *uint64_t v12 = 0;
        uint64_t v14 = sub_18C8A6A04(0, v9, v11, 0, a3);
        if (*a3 <= 0)
        {
          uint64_t v15 = v14;
          uint64_t SubResource = ures_findSubResource(v14, v13 + 1, a2, (UErrorCode *)a3);
LABEL_16:
          a2 = SubResource;
          sub_18C8A49A0(v15, 1);
        }
      }
      else
      {
        int v17 = (long long *)sub_18C8A6A04(0, v9, v11, 0, a3);
        if (*a3 <= 0)
        {
          uint64_t v15 = (uint64_t)v17;
          uint64_t SubResource = (uint64_t)sub_18C8A4A4C(a2, v17, a3);
          goto LABEL_16;
        }
      }
      uprv_free(v8);
      return a2;
    }
    *a3 = 7;
  }
  return a2;
}

uint64_t ures_open(const char *a1, char *a2, int *a3)
{
  return sub_18C8A6A04(0, a1, a2, 0, a3);
}

uint64_t ures_findSubResource(uint64_t a1, char *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v12 = a2;
  if (a4 && *(int *)a4 <= 0)
  {
    uint64_t v6 = a1;
    int v11 = 0;
    unsigned int v7 = sub_18C8ABC8C(*(void *)(a1 + 8) + 40, *(unsigned int *)(a1 + 108), &v12, &v11);
    if (v7 == -1)
    {
      uint64_t v6 = a3;
LABEL_9:
      *a4 = U_MISSING_RESOURCE_ERROR;
    }
    else
    {
      unsigned int v8 = v7;
      while (1)
      {
        uint64_t v9 = sub_18C8A8850(*(void *)(v6 + 8), v8, v11, 0xFFFFFFFF, *(void *)(v6 + 24), *(char **)(v6 + 32), 0, a3, a4);
        uint64_t v6 = v9;
        if (!*v12) {
          break;
        }
        unsigned int v8 = sub_18C8ABC8C(*(void *)(v9 + 8) + 40, *(unsigned int *)(v9 + 108), &v12, &v11);
        if (v8 == -1) {
          goto LABEL_9;
        }
      }
    }
    return v6;
  }
  return a3;
}

const UChar *ures_getStringByKeyWithFallback(uint64_t a1, char *a2, int *a3, UErrorCode *a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  memset(v10, 0, sizeof(v10));
  ures_getByKeyWithFallback(a1, a2, (uint64_t)v10, a4);
  int v9 = 0;
  if (a4 && *(int *)a4 <= 0)
  {
    StringNoTrace = res_getStringNoTrace(*((void *)&v10[0] + 1) + 40, HIDWORD(v11), &v9);
    if (!StringNoTrace) {
      *a4 = U_RESOURCE_TYPE_MISMATCH;
    }
  }
  else
  {
    StringNoTrace = 0;
  }
  sub_18C8A49A0((uint64_t)v10, 1);
  if (*(int *)a4 > 0) {
    return 0;
  }
  int v7 = v9;
  if (v9 == 3)
  {
    if (*StringNoTrace == 8709 && StringNoTrace[1] == 8709 && StringNoTrace[2] == 8709)
    {
      int v7 = 0;
      StringNoTrace = 0;
      *a4 = U_MISSING_RESOURCE_ERROR;
    }
    else
    {
      int v7 = 3;
    }
  }
  if (a3) {
    *a3 = v7;
  }
  return StringNoTrace;
}

uint64_t ures_getByKeyWithFallback(uint64_t a1, char *a2, uint64_t a3, UErrorCode *a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!a4 || *(int *)a4 > 0) {
    return a3;
  }
  if (!a1)
  {
    *a4 = U_ILLEGAL_ARGUMENT_ERROR;
    return a3;
  }
  unsigned int v7 = *(_DWORD *)(a1 + 108);
  if (v7 >> 28 != 2 && (v7 & 0xE0000000) != 0x40000000)
  {
    uint64_t v13 = 0;
    *a4 = U_RESOURCE_TYPE_MISMATCH;
LABEL_68:
    sub_18C8A49A0(v13, 1);
    return a3;
  }
  long long v39 = *(unsigned __int8 **)(a1 + 32);
  int v40 = *(_DWORD *)(a1 + 104);
  uint64_t v10 = *(void *)(a1 + 8);
  long long v49 = 0u;
  long long v50 = 0u;
  uint64_t v52 = 0;
  long long v51 = 0u;
  __s = (char *)&v49 + 5;
  LODWORD(v49) = 40;
  UErrorCode v47 = U_ZERO_ERROR;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v45, a2);
  icu::CharString::append((icu::CharString *)&__s, v45, v46, &v47);
  if (v47 <= U_ZERO_ERROR)
  {
    uint64_t v14 = __s;
    if (!*__s) {
      goto LABEL_11;
    }
    uint64_t v15 = v10 + 40;
    while (v7 >> 28 == 2 || (v7 & 0xE0000000) == 0x40000000 || (v7 & 0xE0000000) == 0x80000000)
    {
      long long v16 = strchr(v14, 47);
      if (v16)
      {
        *long long v16 = 0;
        int v17 = v16 + 1;
      }
      else
      {
        int v17 = &v14[strlen(v14)];
      }
      unsigned int v44 = 0;
      long long v43 = v14;
      unsigned int TableItemByKey = res_getTableItemByKey(v15, v7, &v44, (const char **)&v43);
      unsigned int v7 = TableItemByKey;
      if (*v17) {
        BOOL v19 = TableItemByKey == -1;
      }
      else {
        BOOL v19 = 1;
      }
      uint64_t v14 = v17;
      if (v19)
      {
        if (*v17) {
          break;
        }
        goto LABEL_11;
      }
    }
  }
  unsigned int v7 = -1;
LABEL_11:
  if (BYTE4(v49)) {
    uprv_free(__s);
  }
  uint64_t v45 = a2;
  uint64_t v11 = *(void *)(a1 + 8);
  if (v7 != -1)
  {
    uint64_t v12 = sub_18C8A8850(v11, v7, a2, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a3, a4);
    uint64_t v13 = 0;
LABEL_67:
    a3 = v12;
    goto LABEL_68;
  }
  uint64_t v13 = 0;
  int v20 = 0;
  long long v49 = 0u;
  long long v50 = 0u;
  uint64_t v52 = 0;
  long long v51 = 0u;
  __s = (char *)&v49 + 5;
  LODWORD(v49) = 40;
  uint64_t v42 = *(char **)(a1 + 32);
  long long v43 = 0;
  int v41 = *(_DWORD *)(a1 + 104);
  uint64_t v21 = *(void *)(v11 + 16);
  BOOL v22 = v21 == 0;
  while (1)
  {
    if (!v22) {
      uint64_t v11 = v21;
    }
    if (!*(_DWORD *)(v11 + 112)) {
      break;
    }
LABEL_35:
    v20 |= v22;
    uint64_t v21 = *(void *)(v11 + 16);
    BOOL v22 = v21 == 0;
    if ((v22 & v20) != 0)
    {
      *a4 = U_MISSING_RESOURCE_ERROR;
      char v37 = 1;
LABEL_63:
      uint64_t v12 = a3;
      goto LABEL_64;
    }
  }
  uint64_t v23 = *(unsigned int *)(v11 + 72);
  sub_18C8A5FC4(v39, v40, v42, v41, a2, (icu::CharString *)&__s, a4);
  if (*(int *)a4 >= 1)
  {
    sub_18C8A49A0(v13, 1);
    char v37 = 0;
    goto LABEL_63;
  }
  long long v43 = __s;
  uint64_t v45 = a2;
  do
  {
    uint64_t v24 = sub_18C8ABC8C(v11 + 40, v23, &v43, (const char **)&v45);
    unsigned int v25 = v24;
    if (v24 >> 28 == 3)
    {
      if (*v43)
      {
        uint64_t v24 = sub_18C8A8850(v11, v24, 0, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, v13, a4);
        uint64_t v13 = v24;
        if (!v24) {
          break;
        }
        uint64_t v11 = *(void *)(v24 + 8);
        uint64_t v42 = *(char **)(v24 + 32);
        uint64_t v23 = *(unsigned int *)(v24 + 108);
        int v41 = *(_DWORD *)(v24 + 104);
      }
    }
    else if (v24 == -1)
    {
      goto LABEL_35;
    }
  }
  while (*v43);
  long long v26 = *(const char **)v11;
  Default = (const char *)uloc_getDefault(v24);
  if (!strcmp(v26, Default))
  {
    int v28 = -127;
  }
  else if (!strcmp(*(const char **)v11, "root"))
  {
    int v28 = -127;
  }
  else
  {
    int v28 = -128;
  }
  *a4 = v28;
  uint64_t v29 = sub_18C8A8850(v11, v25, v45, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a3, a4);
  uint64_t v12 = v29;
  if (v42)
  {
    long long v30 = v39;
    int v31 = v40;
    int v32 = v41;
    uint64_t v33 = v42;
  }
  else
  {
    uint64_t v34 = *(const char **)(v29 + 32);
    if (v34 && (long long v35 = strchr(*(char **)(v29 + 32), 47)) != 0 && v35[1])
    {
      int v32 = strlen(v34);
      long long v30 = v39;
      int v31 = v40;
      uint64_t v33 = (char *)v34;
    }
    else
    {
      uint64_t v33 = "";
      long long v30 = v39;
      int v31 = v40;
      int v32 = 0;
    }
  }
  sub_18C8A5FC4(v30, v31, v33, v32, a2, (icu::CharString *)&__s, a4);
  uint64_t v36 = *(void **)(v12 + 32);
  if (v36 && v36 != (void *)(v12 + 40)) {
    uprv_free(v36);
  }
  *(void *)(v12 + 32) = 0;
  *(_DWORD *)(v12 + 104) = 0;
  sub_18C8A4B80(v12, __s, v52, a4);
  char v37 = 1;
  if (*(unsigned char *)(*(int *)(v12 + 104) + *(void *)(v12 + 32) - 1) != 47) {
    sub_18C8A4B80(v12, "/", 1, a4);
  }
LABEL_64:
  if (BYTE4(v49)) {
    uprv_free(__s);
  }
  if (v37) {
    goto LABEL_67;
  }
  return a3;
}

icu::CharString *sub_18C8A5FC4(unsigned __int8 *a1, int a2, char *a3, int a4, const char *a5, icu::CharString *this, UErrorCode *a7)
{
  *((_DWORD *)this + 14) = 0;
  **(unsigned char **)this = 0;
  if (a4 < 1)
  {
    uint64_t v24 = v27;
    unsigned int v25 = (icu::StringPiece *)v27;
  }
  else
  {
    icu::CharString::append(this, a3, a4, a7);
    if (*(int *)a7 <= 0)
    {
      uint64_t v14 = a3;
      uint64_t v15 = &a3[a4];
      if (a2 >= 1)
      {
        long long v16 = &a1[a2];
        uint64_t v14 = a3;
        do
        {
          do
            int v17 = *a1++;
          while (v17 != 47 && a1 < v16);
          if (v14 < v15)
          {
            BOOL v19 = (char *)(&a3[a4] - v14++);
            while (*(v14 - 1) != 47)
            {
              ++v14;
              if (!--v19)
              {
                uint64_t v14 = &a3[a4];
                break;
              }
            }
          }
        }
        while (a1 < v16 && v14 < v15);
      }
      if (v14 < v15)
      {
        while (1)
        {
          int v20 = *(unsigned __int8 *)a5;
          if (!*a5) {
            break;
          }
          if (v14 < v15)
          {
            uint64_t v21 = (char *)(&a3[a4] - v14++);
            while (*(v14 - 1) != 47)
            {
              ++v14;
              if (!--v21)
              {
                uint64_t v14 = &a3[a4];
                break;
              }
            }
          }
          BOOL v22 = a5;
          if (*a5)
          {
            do
            {
              if (v20 == 47) {
                break;
              }
              int v23 = *(unsigned __int8 *)++v22;
              int v20 = v23;
            }
            while (v23);
          }
          if (v20 == 47) {
            a5 = v22 + 1;
          }
          else {
            a5 = v22;
          }
          if (v14 >= v15)
          {
            if (v20 == 47) {
              a5 = v22 + 1;
            }
            else {
              a5 = v22;
            }
            break;
          }
        }
      }
    }
    uint64_t v24 = v28;
    unsigned int v25 = (icu::StringPiece *)v28;
  }
  icu::StringPiece::StringPiece(v25, a5);
  return icu::CharString::append(this, *(const char **)v24, *((_DWORD *)v24 + 2), a7);
}

void ures_getAllChildrenWithFallback(uint64_t a1, char *a2, uint64_t a3, int *a4)
{
  v4[0] = &unk_1EDA480B0;
  v4[1] = a3;
  ures_getAllItemsWithFallback(a1, a2, (uint64_t)v4, a4);
  icu::ResourceSink::~ResourceSink((icu::ResourceSink *)v4);
}

void ures_getAllItemsWithFallback(uint64_t a1, char *a2, uint64_t a3, int *a4)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*a4 <= 0)
  {
    if (a2)
    {
      uint64_t v8 = 0;
      memset(v7, 0, sizeof(v7));
      if (!*a2 || (a1 = ures_getByKeyWithFallback(a1, a2, (uint64_t)v7, (UErrorCode *)a4), *a4 <= 0))
      {
        long long v6[2] = 0;
        v6[0] = &unk_1EDA480F8;
        v6[1] = 0;
        _OWORD v6[3] = 0xFFFFFFFFLL;
        sub_18C8A6320(a1, (uint64_t)v6, a3, a4);
        icu::ResourceValue::~ResourceValue((icu::ResourceValue *)v6);
      }
      sub_18C8A49A0((uint64_t)v7, 1);
    }
    else
    {
      *a4 = 1;
    }
  }
}

uint64_t ures_getValueWithFallback(uint64_t result, char *a2, uint64_t a3, uint64_t a4, UErrorCode *a5)
{
  if (*(int *)a5 <= 0)
  {
    if (a2)
    {
      if (!*a2 || (double result = ures_getByKeyWithFallback(result, a2, a3, a5), *(int *)a5 <= 0))
      {
        uint64_t v7 = *(void *)(result + 24);
        *(void *)(a4 + 8) = *(void *)(result + 8) + 40;
        *(void *)(a4 + 16) = v7;
        *(_DWORD *)(a4 + 24) = *(_DWORD *)(result + 108);
      }
    }
    else
    {
      *a5 = U_ILLEGAL_ARGUMENT_ERROR;
    }
  }
  return result;
}

void sub_18C8A6320(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (*a4 <= 0)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    *(void *)(a2 + 8) = v8 + 40;
    *(void *)(a2 + 16) = *(void *)(a1 + 24);
    uint64_t v9 = *(void *)(v8 + 16);
    BOOL v10 = v9 && *(_DWORD *)(v9 + 112) < 1;
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 108);
    BOOL v11 = !v10;
    (*(void (**)(uint64_t, void, uint64_t, BOOL, int *))(*(void *)a3 + 24))(a3, *(void *)a1, a2, v11, a4);
    if (!v11)
    {
      v17[0] = 0;
      long long v18 = 0u;
      uint64_t v25 = 0;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      v17[1] = v9;
      *((void *)&v18 + sub_18C8A49A0((uint64_t)this, 1) = *(void *)(a1 + 24);
      LOBYTE(v24) = *(unsigned char *)(v9 + 96) == 0;
      BYTE1(v24) = 1;
      HIDWORD(v23) = *(_DWORD *)(v9 + 72);
      uint64_t v25 = res_countArrayItems(v9 + 40, HIDWORD(v23));
      HIDWORD(v24) = -1;
      sub_18C8A4C5C(v9);
      uint64_t v16 = 0;
      memset(v15, 0, sizeof(v15));
      int v14 = 0;
      uint64_t v12 = *(char **)(a1 + 32);
      if (v12 && *v12)
      {
        uint64_t v13 = (void *)ures_getByKeyWithFallback((uint64_t)v17, v12, (uint64_t)v15, (UErrorCode *)&v14);
        if (v14 > 0)
        {
LABEL_12:
          sub_18C8A49A0((uint64_t)v15, 1);
          sub_18C8A49A0((uint64_t)v17, 1);
          return;
        }
      }
      else
      {
        uint64_t v13 = v17;
      }
      sub_18C8A6320(v13, a2, a3, a4);
      goto LABEL_12;
    }
  }
}

uint64_t ures_getByKey(uint64_t a1, const char *a2, uint64_t a3, int *a4)
{
  uint64_t v16 = a2;
  if (a4 && *a4 <= 0)
  {
    if (!a1)
    {
      int v13 = 1;
      goto LABEL_16;
    }
    unsigned int v8 = *(_DWORD *)(a1 + 108);
    if (v8 >> 28 != 2 && (v8 & 0xE0000000) != 0x40000000)
    {
      int v13 = 17;
LABEL_16:
      *a4 = v13;
      return a3;
    }
    unsigned int v15 = 0;
    unsigned int TableItemByKey = res_getTableItemByKey(*(void *)(a1 + 8) + 40, v8, &v15, &v16);
    unsigned int v17 = TableItemByKey;
    if (TableItemByKey == -1)
    {
      uint64_t v16 = a2;
      if (!*(unsigned char *)(a1 + 112) || (uint64_t v12 = sub_18C8A6608(a1, &v16, &v17, a4), *a4 > 0))
      {
        int v13 = 2;
        goto LABEL_16;
      }
      unsigned int v11 = v17;
    }
    else
    {
      unsigned int v11 = TableItemByKey;
      uint64_t v12 = *(void *)(a1 + 8);
    }
    return sub_18C8A8850(v12, v11, v16, 0xFFFFFFFF, *(void *)(a1 + 24), *(char **)(a1 + 32), 0, a3, (UErrorCode *)a4);
  }
  return a3;
}

uint64_t sub_18C8A6608(uint64_t a1, const char **a2, _DWORD *a3, int *a4)
{
  uint64_t v5 = *(void *)(a1 + 8);
  unsigned int v17 = -1;
  *a3 = -1;
  if (!v5) {
    goto LABEL_23;
  }
  if (*(_DWORD *)(v5 + 112))
  {
    if (!*(unsigned char *)(a1 + 112))
    {
LABEL_22:
      uint64_t v5 = 0;
LABEL_23:
      int v15 = 2;
LABEL_24:
      *a4 = v15;
      return v5;
    }
    int v9 = 0;
  }
  else
  {
    uint64_t TableItemByKey = res_getTableItemByKey(v5 + 40, *(_DWORD *)(v5 + 72), &v17, a2);
    *a3 = TableItemByKey;
    if (!*(unsigned char *)(a1 + 112))
    {
      int v9 = 1;
      goto LABEL_16;
    }
    if (TableItemByKey != -1) {
      return v5;
    }
    int v9 = 1;
  }
  uint64_t TableItemByKey = 0xFFFFFFFFLL;
  while (1)
  {
    uint64_t v11 = *(void *)(v5 + 16);
    if (!v11) {
      break;
    }
    uint64_t v5 = *(void *)(v5 + 16);
    if (*(_DWORD *)(v11 + 112))
    {
      int v12 = -1;
    }
    else
    {
      ++v9;
      uint64_t TableItemByKey = res_getTableItemByKey(v11 + 40, *(_DWORD *)(v11 + 72), &v17, a2);
      *a3 = TableItemByKey;
      int v12 = TableItemByKey;
    }
    if (v12 != -1) {
      goto LABEL_17;
    }
  }
LABEL_16:
  if (TableItemByKey == -1) {
    goto LABEL_22;
  }
LABEL_17:
  if (v9 >= 2)
  {
    int v13 = *(const char **)v5;
    Default = (const char *)uloc_getDefault(TableItemByKey);
    if (!strcmp(v13, Default))
    {
      int v15 = -127;
    }
    else if (!strcmp(*(const char **)v5, "root"))
    {
      int v15 = -127;
    }
    else
    {
      int v15 = -128;
    }
    goto LABEL_24;
  }
  return v5;
}

const UChar *ures_getStringByKey(uint64_t a1, const char *a2, int *a3, int *a4)
{
  long long v21 = a2;
  if (a4 && *a4 <= 0)
  {
    if (!a1)
    {
      String = 0;
      int v15 = 1;
      goto LABEL_27;
    }
    unsigned int v8 = *(_DWORD *)(a1 + 108);
    if (v8 >> 28 != 2 && (v8 & 0xE0000000) != 0x40000000)
    {
      String = 0;
      int v15 = 17;
LABEL_27:
      *a4 = v15;
      return String;
    }
    unsigned int v20 = 0;
    unsigned int TableItemByKey = res_getTableItemByKey(*(void *)(a1 + 8) + 40, v8, &v20, &v21);
    unsigned int v22 = TableItemByKey;
    if (TableItemByKey != -1)
    {
      unsigned int v12 = TableItemByKey;
      unsigned int v13 = TableItemByKey >> 28;
      if (TableItemByKey >> 28 == 6)
      {
LABEL_14:
        uint64_t v14 = *(void *)(a1 + 8) + 40;
        return res_getStringNoTrace(v14, v12, a3);
      }
      if (v13 != 3)
      {
        if (!v13) {
          goto LABEL_14;
        }
        goto LABEL_25;
      }
LABEL_24:
      uint64_t v18 = ures_getByKey(a1, a2, 0, a4);
      String = ures_getString(v18, a3, a4);
      sub_18C8A49A0(v18, 1);
      return String;
    }
    long long v21 = a2;
    if (!*(unsigned char *)(a1 + 112) || (uint64_t v16 = sub_18C8A6608(a1, &v21, &v22, a4), *a4 > 0))
    {
      int v15 = 2;
LABEL_26:
      String = 0;
      goto LABEL_27;
    }
    unsigned int v12 = v22;
    unsigned int v17 = v22 >> 28;
    if (v22 >> 28 != 6)
    {
      if (v17 == 3) {
        goto LABEL_24;
      }
      if (v17)
      {
LABEL_25:
        int v15 = 17;
        goto LABEL_26;
      }
    }
    uint64_t v14 = v16 + 40;
    return res_getStringNoTrace(v14, v12, a3);
  }
  return 0;
}

char *ures_getUTF8StringByKey(uint64_t a1, const char *a2, char *a3, int32_t *a4, int a5, int *a6)
{
  int32_t srcLength = 0;
  StringByKey = (UChar *)ures_getStringByKey(a1, a2, &srcLength, a6);
  return sub_18C8A4D98(StringByKey, srcLength, a3, a4, a5, a6);
}

uint64_t ures_getLocaleInternal(uint64_t result, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0;
  }
  if (result) {
    return **(void **)(result + 8);
  }
  *a2 = 1;
  return result;
}

uint64_t ures_getLocale(uint64_t result, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0;
  }
  if (result) {
    return **(void **)(result + 8);
  }
  *a2 = 1;
  return result;
}

uint64_t ures_getLocaleByType(uint64_t result, int a2, int *a3)
{
  if (!a3 || *a3 > 0) {
    return 0;
  }
  if (result)
  {
    if (a2 == 1)
    {
      uint64_t v3 = *(void *)(result + 24);
      return *(void *)v3;
    }
    if (!a2)
    {
      uint64_t v3 = *(void *)(result + 8);
      return *(void *)v3;
    }
    double result = 0;
  }
  *a3 = 1;
  return result;
}

uint64_t sub_18C8A69F4(uint64_t result)
{
  if (result) {
    return **(void **)(result + 8);
  }
  return result;
}

uint64_t sub_18C8A6A04(uint64_t a1, const char *a2, char *a3, int a4, int *a5)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (*a5 > 0) {
    return 0;
  }
  uint64_t v5 = a1;
  if (a4 == 2)
  {
    sub_18C8A95A0(a5);
    if (*a5 > 0) {
      return 0;
    }
    if (a3)
    {
      if (*a3) {
        Default = a3;
      }
      else {
        Default = "root";
      }
    }
    else
    {
      Default = (const char *)uloc_getDefault(v11);
    }
    umtx_lock((atomic_ullong *)&unk_1EB20B690);
    unsigned int v20 = sub_18C8A9CE0(Default, a2, (UErrorCode *)a5);
    if (*a5 > 0) {
      goto LABEL_25;
    }
    uint64_t v14 = (uint64_t)v20;
    if (v20[28])
    {
      --v20[27];
LABEL_25:
      uint64_t v14 = 0;
LABEL_26:
      umtx_unlock((std::mutex **)&unk_1EB20B690);
      goto LABEL_27;
    }
    v44[0] = v20;
    int v30 = strcmp(Default, "root");
    int v31 = (void *)v14;
    if (!v30
      || (int v31 = (void *)v14, *(void *)(v14 + 16))
      || (int v31 = (void *)v14, *(unsigned char *)(v14 + 96))
      || (v32 = strlen(Default), int v31 = (void *)v14, v32 > 0x9C))
    {
LABEL_65:
      while (1)
      {
        int v31 = (void *)v31[2];
        if (!v31) {
          break;
        }
        ++*((_DWORD *)v31 + 27);
      }
      goto LABEL_26;
    }
    long long v52 = 0u;
    memset(v53, 0, sizeof(v53));
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    *(_OWORD *)__int16 __dst = 0u;
    strcpy(__dst, Default);
    uint64_t v33 = strrchr(__dst, 95);
    uint64_t v34 = (const char **)v14;
    if (v33)
    {
      *uint64_t v33 = 0;
      uint64_t v34 = (const char **)v14;
      if (*(_DWORD *)__dst ^ 0x746F6F72 | __dst[4])
      {
        if (!sub_18C8A9FE4((uint64_t *)v44, __dst, a5))
        {
LABEL_62:
          if (*a5 > 0) {
            goto LABEL_25;
          }
          int v31 = v44[0];
          goto LABEL_65;
        }
        uint64_t v34 = (const char **)v44[0];
      }
    }
    if (strcmp(*v34, "root") && !v34[2]) {
      sub_18C8AA170((uint64_t)v44, a5);
    }
    goto LABEL_62;
  }
  memset(&v44[1], 0, 56);
  memset(__dst, 0, sizeof(__dst));
  v44[0] = (char *)&v44[1] + 5;
  LODWORD(v44[1]) = 40;
  icu::CharStringByteSink::CharStringByteSink(__dst, (uint64_t)v44);
  ulocimp_getBaseName(a3, (uint64_t)__dst, (UErrorCode *)a5);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)__dst);
  int v13 = *a5;
  if (*a5 >= 1)
  {
    uint64_t v14 = 0;
    *a5 = 1;
    goto LABEL_17;
  }
  int v15 = (const char *)v44[0];
  int v43 = 0;
  uint64_t v42 = 0;
  __int16 v41 = 0;
  char v40 = 1;
  sub_18C8A95A0(a5);
  uint64_t v14 = 0;
  if (*a5 <= 0)
  {
    uint64_t v16 = strncpy(__dst, v15, 0x9CuLL);
    v53[28] = 0;
    unsigned int v17 = (const char *)uloc_getDefault(v16);
    umtx_lock((atomic_ullong *)&unk_1EB20B690);
    uint64_t v18 = sub_18C8A967C(a2, __dst, v17, a4, (BOOL *)&v41, &v40, (BOOL *)&v41 + 1, (UErrorCode *)&v43);
    int v19 = v43;
    if (v43 == 7)
    {
LABEL_14:
      uint64_t v14 = 0;
      goto LABEL_15;
    }
    uint64_t v14 = (uint64_t)v18;
    if (v18)
    {
      uint64_t v42 = v18;
      if (v40)
      {
        int v25 = v41;
        if (!(_BYTE)v41)
        {
LABEL_72:
          if (!sub_18C8A9FE4((uint64_t *)&v42, __dst, a5)) {
            goto LABEL_86;
          }
          int v25 = 0;
        }
LABEL_74:
        int v35 = 1;
        goto LABEL_75;
      }
      int v25 = v41;
      if (!__dst[0]) {
        goto LABEL_74;
      }
      int v35 = 1;
      if (strstr("nb nn", __dst) && !v25) {
        goto LABEL_72;
      }
    }
    else
    {
      int v35 = 0;
      int v25 = v41;
    }
LABEL_75:
    if (a4 || v14 || HIBYTE(v41) || v25)
    {
      if (v14) {
        goto LABEL_85;
      }
    }
    else
    {
      strcpy(__dst, v17);
      uint64_t v36 = sub_18C8A967C(a2, __dst, v17, 0, (BOOL *)&v41, &v40, (BOOL *)&v41 + 1, (UErrorCode *)&v43);
      int v19 = v43;
      if (v43 == 7) {
        goto LABEL_14;
      }
      uint64_t v14 = (uint64_t)v36;
      int v43 = -127;
      if (v36)
      {
        uint64_t v42 = v36;
        if (v40)
        {
          if ((_BYTE)v41) {
            goto LABEL_86;
          }
          goto LABEL_97;
        }
        int v25 = v41;
        if (__dst[0])
        {
          int v35 = 1;
          if (strstr("nb nn", __dst) && !v25)
          {
LABEL_97:
            if (!sub_18C8A9FE4((uint64_t *)&v42, __dst, a5)) {
              goto LABEL_86;
            }
            int v35 = 1;
LABEL_99:
            long long v38 = v42;
            if (!strcmp(*v42, "root") || v38[2] || *(unsigned char *)(v14 + 96))
            {
LABEL_102:
              for (uint64_t i = v42; ; ++*((_DWORD *)i + 27))
              {
                uint64_t i = (const char **)i[2];
                if (!i) {
                  break;
                }
              }
              goto LABEL_86;
            }
            if (sub_18C8AA170((uint64_t)&v42, a5))
            {
              if (!v35) {
                *(_DWORD *)(v14 + 112) = -127;
              }
              goto LABEL_102;
            }
LABEL_86:
            if (*a5 > 0)
            {
              uint64_t v14 = 0;
              goto LABEL_16;
            }
            int v19 = v43;
            if (!v43) {
              goto LABEL_16;
            }
LABEL_15:
            *a5 = v19;
LABEL_16:
            umtx_unlock((std::mutex **)&unk_1EB20B690);
            goto LABEL_17;
          }
        }
        else
        {
          int v35 = 1;
        }
LABEL_85:
        if (v25) {
          goto LABEL_86;
        }
        goto LABEL_99;
      }
    }
    strcpy(__dst, "root");
    char v37 = sub_18C8A967C(a2, __dst, v17, a4, (BOOL *)&v41, &v40, (BOOL *)&v41 + 1, (UErrorCode *)&v43);
    int v19 = v43;
    if (v43 == 7) {
      goto LABEL_14;
    }
    uint64_t v14 = (uint64_t)v37;
    if (!v37)
    {
      int v19 = 2;
      goto LABEL_15;
    }
    uint64_t v42 = v37;
    int v43 = -127;
    if (!(_BYTE)v41) {
      goto LABEL_102;
    }
    goto LABEL_86;
  }
LABEL_17:
  if (BYTE4(v44[1])) {
    uprv_free(v44[0]);
  }
  if (v13 >= 1) {
    return 0;
  }
LABEL_27:
  if (*a5 > 0) {
    return 0;
  }
  if (!v14)
  {
    uint64_t v5 = 0;
    int v24 = 2;
    goto LABEL_37;
  }
  if (!v5)
  {
    uint64_t v26 = uprv_malloc(0x88uLL);
    uint64_t v5 = (uint64_t)v26;
    if (v26)
    {
      int v23 = 19700503;
      v26[16] = 0;
      *((_OWORD *)v26 + 6) = 0u;
      *((_OWORD *)v26 + 7) = 0u;
      *((_OWORD *)v26 + 4) = 0u;
      *((_OWORD *)v26 + 5) = 0u;
      *((_OWORD *)v26 + 2) = 0u;
      *((_OWORD *)v26 + 3) = 0u;
      *(_OWORD *)uint64_t v26 = 0u;
      *((_OWORD *)v26 + sub_18C8A49A0((uint64_t)this, 1) = 0u;
LABEL_44:
      int32x2_t v22 = vdup_n_s32(0x12BB38Bu);
      goto LABEL_45;
    }
    sub_18C8A87F0(v14);
    int v24 = 7;
LABEL_37:
    *a5 = v24;
    return v5;
  }
  if (*(_DWORD *)(v5 + 116) != 19700503)
  {
    sub_18C8A49A0(v5, 0);
    *(void *)(v5 + 128) = 0;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    int32x2_t v22 = 0;
    *(_OWORD *)uint64_t v5 = 0u;
    *(_OWORD *)(v5 + 16) = 0u;
    goto LABEL_47;
  }
  int v21 = *(_DWORD *)(v5 + 120);
  sub_18C8A49A0(v5, 0);
  *(void *)(v5 + 128) = 0;
  v22.i32[1] = 0;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  if (v21 == 19641227) {
    int v23 = 19700503;
  }
  else {
    int v23 = 0;
  }
  if (v21 == 19641227) {
    goto LABEL_44;
  }
LABEL_45:
  v22.i32[0] = v23;
LABEL_47:
  *(int32x2_t *)(v5 + 116) = v22;
  *(void *)(v5 + 8) = v14;
  *(void *)(v5 + 24) = v14;
  BOOL v27 = a4 != 2 && *(unsigned char *)(v14 + 96) == 0;
  *(unsigned char *)(v5 + 112) = v27;
  *(unsigned char *)(v5 + 113) = 1;
  unsigned int v28 = *(_DWORD *)(v14 + 72);
  *(_DWORD *)(v5 + 108) = v28;
  int v29 = res_countArrayItems(v14 + 40, v28);
  *(_DWORD *)(v5 + 124) = -1;
  *(_DWORD *)(v5 + 128) = v29;
  return v5;
}

uint64_t ures_openNoDefault(const char *a1, char *a2, int *a3)
{
  return sub_18C8A6A04(0, a1, a2, 1, a3);
}

uint64_t ures_openDirect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_18C8A6A04(0, a1, a2, 2, a3);
}

uint64_t ures_openFillIn(uint64_t result, const char *a2, char *a3, int *a4)
{
  if (result || *a4 > 0) {
    return sub_18C8A6A04(result, a2, a3, 0, a4);
  }
  *a4 = 1;
  return result;
}

uint64_t ures_openDirectFillIn(uint64_t result, const char *a2, char *a3, int *a4)
{
  if (result || *a4 > 0) {
    return sub_18C8A6A04(result, a2, a3, 2, a4);
  }
  *a4 = 1;
  return result;
}

uint64_t ures_openWithCountryFallback(const char *a1, char *a2, BOOL *a3, int *a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  int v31 = 0;
  if ((int)ulocimp_setRegionToSupplementalRegion(a2, 0, 0) >= 1)
  {
    long long v43 = 0u;
    memset(v44, 0, sizeof(v44));
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    *(_OWORD *)uint64_t v36 = 0u;
    ulocimp_setRegionToSupplementalRegion(a2, v36, 157);
    if (*a4 <= 0)
    {
      uint64_t v8 = ures_openWithCountryFallback(a1, v36, a3, a4);
      if (a3) {
        *a3 = 1;
      }
      return v8;
    }
  }
  uint64_t v8 = sub_18C8A6A04(0, a1, a2, 0, a4);
  if (a3) {
    *a3 = 0;
  }
  *(_DWORD *)long long __s1 = 0;
  uloc_getCountry((uint64_t)a2, __s1, 4, a4);
  BOOL v9 = *a4 == -128;
  if (!a1 || *a4 != -128) {
    goto LABEL_9;
  }
  if (strcmp(a1, "icudt74l"))
  {
    *(_DWORD *)uint64_t v36 = 0;
    uint64_t v10 = sub_18C8A6A04(0, 0, a2, 0, (int *)v36);
    sub_18C8A49A0(v10, 1);
    BOOL v9 = *(_DWORD *)v36 == -128;
LABEL_9:
    if (!v9) {
      return v8;
    }
  }
  if (__s1[0])
  {
    *(_DWORD *)long long __s2 = 0;
    if (*a4 <= 0)
    {
      if (v8)
      {
        uint64_t v11 = **(void **)(v8 + 8);
      }
      else
      {
        uint64_t v11 = 0;
        *a4 = 1;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    uloc_getCountry(v11, __s2, 4, a4);
    if (strcmp(__s1, __s2))
    {
      int v35 = 0;
      *(void *)__int16 __dst = 0;
      __int16 v28 = 0;
      *(_DWORD *)__s = 0;
      long long v43 = 0u;
      memset(v44, 0, sizeof(v44));
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      *(_OWORD *)uint64_t v36 = 0u;
      uloc_getLanguage((uint64_t)a2, __dst, 12, a4);
      uloc_getScript((uint64_t)a2, __s, 6, a4);
      size_t v12 = strlen(__s);
      size_t v13 = strlen(__dst);
      if (v12) {
        size_t v14 = v12 + 1;
      }
      else {
        size_t v14 = 0;
      }
      sprintf(v36, "und_%s", __s1);
      uloc_addLikelySubtags(v36, v36, 157, (UErrorCode *)a4);
      uloc_getLanguage((uint64_t)v36, __dst, 12, a4);
      uloc_getScript((uint64_t)v36, __s, 6, a4);
      if (*a4 > 0) {
        return v8;
      }
      int v15 = &a2[v13 + 1 + v14];
      *a4 = 0;
      sprintf(v36, "%s_%s_%s", __dst, __s, v15);
      uint64_t v16 = sub_18C8A6A04(0, a1, v36, 0, a4);
      uint64_t v17 = v16;
      int v18 = *a4;
      if ((*a4 & 0xFFFFFFFE) == 0xFFFFFF80)
      {
        int v33 = 0;
        *(void *)size_t v32 = 0;
        if (v16)
        {
          uint64_t v19 = **(void **)(v16 + 8);
        }
        else
        {
          uint64_t v19 = 0;
          *a4 = 1;
        }
        uloc_getLanguage(v19, v32, 12, a4);
        int v18 = *a4;
        if (*a4 == -127 || strcmp(__dst, v32))
        {
          unint64_t v20 = 0;
          strcpy(__dst, "en");
          while (1)
          {
            size_t v21 = strlen(off_1E5508890[v20]);
            if (!strncmp(v36, off_1E5508890[v20], v21)) {
              break;
            }
            BOOL v22 = v20 >= 8;
            v20 += 2;
            if (v22) {
              goto LABEL_36;
            }
          }
          strcpy(__dst, off_1E5508890[v20 + 1]);
LABEL_36:
          sprintf(v36, "%s_%s_%s", __dst, __s, v15);
          sub_18C8A49A0(v17, 1);
          uint64_t v17 = sub_18C8A6A04(0, a1, v36, 0, a4);
          int v18 = *a4;
        }
      }
      if (v18 > 0) {
        return v8;
      }
      if (a3)
      {
        if (v8 && v17)
        {
          BOOL v24 = 0;
          int v25 = **(const char ***)(v8 + 8);
          if (v25)
          {
            uint64_t v26 = **(const char ***)(v17 + 8);
            if (v26) {
              BOOL v24 = strcmp(v25, v26) != 0;
            }
          }
        }
        else
        {
          BOOL v24 = 0;
        }
        *a3 = v24;
      }
      sub_18C8A49A0(v8, 1);
      return v17;
    }
  }
  return v8;
}

uint64_t ures_countArrayItems(uint64_t a1, const char *a2, int *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  memset(v6, 0, sizeof(v6));
  if (a3 && *a3 <= 0)
  {
    if (!a1)
    {
      uint64_t v4 = 0;
      *a3 = 1;
      return v4;
    }
    ures_getByKey(a1, a2, (uint64_t)v6, a3);
    if (*(void *)(*((void *)&v6[0] + 1) + 40))
    {
      uint64_t v4 = res_countArrayItems(*((void *)&v6[0] + 1) + 40, HIDWORD(v7));
      sub_18C8A49A0((uint64_t)v6, 1);
      return v4;
    }
    *a3 = 2;
    sub_18C8A49A0((uint64_t)v6, 1);
  }
  return 0;
}

char *ures_getVersionNumberInternal(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  unsigned int v2 = *(char **)(a1 + 16);
  if (!v2)
  {
    *(void *)length = 0;
    StringByKey = ures_getStringByKey(a1, "Version", length, &length[1]);
    if (length[0] <= 1) {
      unsigned int v5 = 1;
    }
    else {
      unsigned int v5 = length[0];
    }
    uint64_t v6 = (char *)uprv_malloc(v5 + 1);
    unsigned int v2 = v6;
    *(void *)(a1 + 16) = v6;
    if (v6)
    {
      if (length[0] < 1)
      {
        *(_WORD *)uint64_t v6 = 48;
      }
      else
      {
        u_UCharsToChars(StringByKey, v6, length[0]);
        *(unsigned char *)(*(void *)(a1 + 16) + v5) = 0;
        return *(char **)(a1 + 16);
      }
    }
  }
  return v2;
}

void ures_getVersion(uint64_t a1, uint8_t *a2)
{
  if (a1)
  {
    VersionNumberInternal = ures_getVersionNumberInternal(a1);
    u_versionFromString(a2, VersionNumberInternal);
  }
}

void *ures_openAvailableLocales(const char *a1, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  uint64_t v4 = uprv_malloc(0x110uLL);
  unsigned int v5 = uprv_malloc(0x38uLL);
  uint64_t v6 = v5;
  if (!v5 || !v4)
  {
    *a2 = 7;
    uprv_free(v5);
    uprv_free(v4);
    return 0;
  }
  long long v7 = *(_OWORD *)&off_1EDA48078;
  *unsigned int v5 = xmmword_1EDA48068;
  v5[1] = v7;
  v5[2] = xmmword_1EDA48088;
  *((void *)v5 + 6) = off_1EDA48098;
  *uint64_t v4 = 0u;
  v4[1] = 0u;
  void v4[2] = 0u;
  _OWORD v4[3] = 0u;
  _OWORD v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[13] = 0u;
  v4[14] = 0u;
  v4[15] = 0u;
  v4[16] = 0u;
  uint64_t v8 = sub_18C8A6A04(0, a1, "res_index", 2, a2);
  ures_getByKey(v8, "InstalledLocales", (uint64_t)v4, a2);
  if (*a2 <= 0)
  {
    v6[1] = v4;
  }
  else
  {
    sub_18C8A49A0((uint64_t)v4, 1);
    uprv_free(v4);
    uprv_free(v6);
    uint64_t v6 = 0;
  }
  sub_18C8A49A0(v8, 1);
  return v6;
}

uint64_t ures_getFunctionalEquivalent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1);
  int v11 = v10;
  size_t v13 = v12;
  int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  size_t v21 = v20;
  int v23 = v22;
  BOOL v24 = (char *)v9;
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  bzero(v99, 0x400uLL);
  bzero(__s, 0x400uLL);
  memset(&v97[1], 0, 56);
  v97[0] = (char *)&v97[1] + 5;
  LODWORD(v97[1]) = 40;
  bzero(__dst, 0x400uLL);
  bzero(__src, 0x400uLL);
  bzero(v93, 0x400uLL);
  UErrorCode v68 = U_ZERO_ERROR;
  if (*a9 >= 1) {
    return 0;
  }
  long long v59 = v24;
  uint64_t v92 = 0;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  uint64_t v83 = 0;
  memset(&__s1[1], 0, 48);
  uint64_t v72 = 0;
  __s1[0] = (char *)&__s1[1] + 5;
  LODWORD(__s1[1]) = 40;
  uint64_t v74 = 0;
  *(void *)uint64_t v71 = 0;
  icu::CharStringByteSink::CharStringByteSink(v71, (uint64_t)__s1);
  ulocimp_getKeywordValue(v15, v17, (uint64_t)v71, (int *)&v68);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v71);
  icu::StringPiece::StringPiece((icu::StringPiece *)&__s2, "default");
  uint64_t v26 = v17;
  if (v74 == v67)
  {
    BOOL v27 = __s1[0];
    if (!v67 || !memcmp(__s1[0], __s2, (int)v67))
    {
      LODWORD(v74) = 0;
      *BOOL v27 = 0;
    }
  }
  *(void *)uint64_t v71 = 0;
  uint64_t v72 = 0;
  icu::CharStringByteSink::CharStringByteSink(v71, (uint64_t)v97);
  ulocimp_getBaseName(v15, (uint64_t)v71, &v68);
  icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v71);
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  uint64_t v92 = 0;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  uint64_t v83 = 0;
  icu::CharString::extract(v97, __src, 1024, &v68);
  icu::CharString::extract(v97, __dst, 1024, &v68);
  if (v13)
  {
    __int16 v28 = (void **)ures_openAvailableLocales(v21, (int *)&v68);
    *size_t v13 = 1;
    if (v68 <= U_ZERO_ERROR)
    {
      do
      {
        int v29 = (const char *)uenum_next((uint64_t)v28, 0, (int *)&v68);
        if (!v29)
        {
          char v30 = 0;
          goto LABEL_14;
        }
      }
      while (strcmp(v29, __src));
      char v30 = 1;
LABEL_14:
      *size_t v13 = v30;
    }
    uenum_close(v28);
  }
  if (v68 > U_ZERO_ERROR)
  {
    uint64_t v25 = 0;
    *a9 = v68;
    goto LABEL_107;
  }
  do
  {
    UErrorCode v68 = U_ZERO_ERROR;
    uint64_t v31 = sub_18C8A6A04(0, v21, __src, 0, (int *)&v68);
    uint64_t v32 = v31;
    if (v13 && (v68 & 0xFFFFFFFE) == 0xFFFFFF80)
    {
      *size_t v13 = 0;
    }
    else if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey(v31, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          *(_DWORD *)uint64_t v71 = 0;
          StringByKey = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
          if (v68 <= U_ZERO_ERROR)
          {
            if (*(_DWORD *)v71)
            {
              uint64_t v34 = StringByKey;
              int32_t v35 = u_strlen(StringByKey);
              u_UCharsToChars(v34, v99, v35);
              strcpy(__s, __src);
              if (!v74) {
                icu::CharString::append((icu::CharString *)__s1, v99, *(int *)v71, &v68);
              }
            }
          }
        }
      }
    }
    else
    {
      *a9 = v68;
    }
    UErrorCode v68 = U_ZERO_ERROR;
    if (v32) {
      strcpy(__dst, **(const char ***)(v32 + 24));
    }
    if (!strcmp(__dst, __src)) {
      sub_18C8A838C(__dst, v32, (uint64_t)&v84, __src, 1024);
    }
    else {
      strcpy(__src, __dst);
    }
    sub_18C8A49A0(v32, 1);
    if (v99[0]) {
      break;
    }
    if (!__dst[0]) {
      break;
    }
    if (!(*(_DWORD *)__dst ^ 0x746F6F72 | v96)) {
      break;
    }
    size_t v13 = 0;
  }
  while (*a9 < 1);
  icu::CharString::extract(v97, __src, 1024, &v68);
  icu::CharString::extract(v97, __dst, 1024, &v68);
  while (1)
  {
    uint64_t v36 = sub_18C8A6A04(0, v21, __src, 0, (int *)&v68);
    uint64_t v37 = v36;
    if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey(v36, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          ures_getByKey((uint64_t)&v84, (const char *)__s1[0], (uint64_t)&v75, (int *)&v68);
          if (v68 == U_ZERO_ERROR)
          {
            strcpy(v93, __src);
            if (!v93[0]) {
              strcpy(v93, "root");
            }
            size_t v38 = strlen(__s);
            if (v38 > strlen(v93))
            {
              *(_DWORD *)uint64_t v71 = 0;
              long long v39 = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
              if (v68 <= U_ZERO_ERROR)
              {
                if (*(_DWORD *)v71)
                {
                  long long v40 = v39;
                  int32_t v41 = u_strlen(v39);
                  u_UCharsToChars(v40, v99, v41);
                  strcpy(__s, v93);
                }
              }
            }
          }
        }
      }
    }
    else
    {
      *a9 = v68;
    }
    if (v37)
    {
      if (!strcmp(v19, "collations"))
      {
        UErrorCode v68 = U_ZERO_ERROR;
        long long v42 = **(const char ***)(v37 + 24);
        if (v42)
        {
          if (*v42 && strcmp(v42, "root"))
          {
            LODWORD(v72) = 0;
            *(void *)uint64_t v71 = 0;
            int v70 = 0;
            *(void *)long long v69 = 0;
            uloc_getLanguage((uint64_t)v42, v71, 12, (int *)&v68);
            uloc_getLanguage((uint64_t)__src, v69, 12, (int *)&v68);
            if (v68 <= U_ZERO_ERROR && strcmp(v71, v69))
            {
              strcpy(__dst, v42);
              UErrorCode v68 = U_ZERO_ERROR;
              goto LABEL_54;
            }
            UErrorCode v68 = U_ZERO_ERROR;
          }
        }
      }
    }
    strcpy(__dst, __src);
LABEL_54:
    sub_18C8A838C(__dst, v37, (uint64_t)&v84, __src, 1023);
    sub_18C8A49A0(v37, 1);
    UErrorCode v68 = U_ZERO_ERROR;
    if (v93[0] || !__dst[0]) {
      break;
    }
    if (*a9 > 0) {
      goto LABEL_66;
    }
  }
  if (v93[0]) {
    goto LABEL_69;
  }
LABEL_66:
  icu::StringPiece::StringPiece((icu::StringPiece *)&v64, v99);
  if (v74 == v65)
  {
    if (!v65) {
      goto LABEL_69;
    }
    long long v43 = __s1[0];
    if (!memcmp(__s1[0], v64, (int)v65)) {
      goto LABEL_69;
    }
  }
  else
  {
    long long v43 = __s1[0];
  }
  LODWORD(v74) = 0;
  unsigned char *v43 = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v62, v99);
  icu::CharString::append((icu::CharString *)__s1, v62, v63, &v68);
  icu::CharString::extract(v97, __src, 1024, &v68);
  icu::CharString::extract(v97, __dst, 1024, &v68);
  while (1)
  {
    uint64_t v47 = sub_18C8A6A04(0, v21, __src, 0, (int *)&v68);
    uint64_t v48 = v47;
    if (v68 < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (v68 == U_ZERO_ERROR)
      {
        ures_getByKey(v47, v19, (uint64_t)&v84, (int *)&v68);
        if (v68 == U_ZERO_ERROR)
        {
          ures_getByKey((uint64_t)&v84, (const char *)__s1[0], (uint64_t)&v75, (int *)&v68);
          if (v68 == U_ZERO_ERROR)
          {
            strcpy(v93, __src);
            if (!v93[0]) {
              strcpy(v93, "root");
            }
            size_t v49 = strlen(__s);
            if (v49 > strlen(v93))
            {
              *(_DWORD *)uint64_t v71 = 0;
              long long v50 = ures_getStringByKey((uint64_t)&v84, "default", (int *)v71, (int *)&v68);
              if (v68 <= U_ZERO_ERROR)
              {
                if (*(_DWORD *)v71)
                {
                  long long v51 = v50;
                  int32_t v52 = u_strlen(v50);
                  u_UCharsToChars(v51, v99, v52);
                  strcpy(__s, v93);
                }
              }
            }
          }
        }
      }
    }
    else
    {
      *a9 = v68;
    }
    strcpy(__dst, __src);
    sub_18C8A838C(__dst, v48, (uint64_t)&v84, __src, 1023);
    sub_18C8A49A0(v48, 1);
    UErrorCode v68 = U_ZERO_ERROR;
    if (v93[0] || !__dst[0]) {
      break;
    }
    if (*a9 > 0) {
      goto LABEL_100;
    }
  }
LABEL_69:
  if (*a9 <= 0)
  {
    if (!v93[0])
    {
      *a9 = 2;
      goto LABEL_95;
    }
    if (v11 && (size_t v44 = strlen(__s), v44 <= strlen(v93)))
    {
      icu::StringPiece::StringPiece((icu::StringPiece *)&v60, v99);
      int v45 = v74;
      if (v74 == v61)
      {
        long long v46 = __s1[0];
        if (!v61 || !memcmp(__s1[0], v60, (int)v61))
        {
          LODWORD(v74) = 0;
          unsigned char *v46 = 0;
        }
        goto LABEL_95;
      }
    }
    else
    {
LABEL_95:
      int v45 = v74;
    }
    strcpy(__dst, v93);
    if (v45)
    {
      *(_WORD *)&__dst[strlen(__dst)] = 64;
      strcat(__dst, v26);
      *(_WORD *)&__dst[strlen(__dst)] = 61;
      uint64_t v53 = (const char *)__s1[0];
      goto LABEL_98;
    }
    if (!v11)
    {
      *(_WORD *)&__dst[strlen(__dst)] = 64;
      strcat(__dst, v26);
      *(_WORD *)&__dst[strlen(__dst)] = 61;
      uint64_t v53 = v99;
LABEL_98:
      strcat(__dst, v53);
    }
  }
LABEL_100:
  sub_18C8A49A0((uint64_t)&v84, 1);
  sub_18C8A49A0((uint64_t)&v75, 1);
  size_t v54 = strlen(__dst);
  if (*a9 <= 0)
  {
    uint64_t v55 = v54;
    int v57 = uprv_min(v54, v23);
    uint64_t v56 = (uint64_t)v59;
    if (v57 >= 1) {
      strncpy(v59, __dst, v57);
    }
    if (!v55) {
      *a9 = 2;
    }
  }
  else
  {
    uint64_t v55 = 0;
    uint64_t v56 = (uint64_t)v59;
    char *v59 = 0;
  }
  uint64_t v25 = u_terminateChars(v56, v23, v55, a9);
LABEL_107:
  if (BYTE4(__s1[1])) {
    uprv_free(__s1[0]);
  }
  if (BYTE4(v97[1])) {
    uprv_free(v97[0]);
  }
  return v25;
}

char *sub_18C8A838C(char *a1, uint64_t a2, uint64_t a3, char *a4, int32_t a5)
{
  int v13 = 0;
  *a4 = 0;
  if (!a2) {
    goto LABEL_9;
  }
  ures_getByKey(a2, "%%Parent", a3, &v13);
  if (v13 > 0) {
    goto LABEL_9;
  }
  int32_t pDestLength = a5;
  int32_t srcLength = 0;
  if (!a3)
  {
    int v10 = 1;
    goto LABEL_7;
  }
  StringNoTrace = (UChar *)res_getStringNoTrace(*(void *)(a3 + 8) + 40, *(_DWORD *)(a3 + 108), &srcLength);
  if (!StringNoTrace)
  {
    int v10 = 17;
LABEL_7:
    StringNoTrace = 0;
    int v13 = v10;
  }
  double result = sub_18C8A4D98(StringNoTrace, srcLength, a4, &pDestLength, 1, &v13);
  if (v13 > 0 || !*a4)
  {
LABEL_9:
    int v13 = 0;
    return (char *)uloc_getParent(a1, a4, a5, &v13);
  }
  return result;
}

_OWORD *ures_getKeywordValues(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  unsigned int v5 = v4;
  uint64_t v6 = (const char *)v1;
  *(void *)&v33[2046] = *MEMORY[0x1E4F143B8];
  bzero(v33, 0x7FEuLL);
  bzero(v31, 0x1000uLL);
  int v26 = 0;
  memset(v29, 0, sizeof(v29));
  uint64_t v30 = 0;
  memset(v27, 0, sizeof(v27));
  uint64_t v28 = 0;
  long long v7 = (void **)ures_openAvailableLocales(v6, v3);
  if (*v3 < 1)
  {
    uint64_t v9 = v7;
    __int16 v32 = 0;
    uint64_t v10 = uenum_next((uint64_t)v7, (uint64_t)&v26, v3);
    if (v10)
    {
      int v11 = (char *)v10;
      int v12 = 0;
      int v24 = 0;
      do
      {
        int v25 = 0;
        uint64_t v13 = sub_18C8A6A04(0, v6, v11, 0, &v25);
        ures_getByKey(v13, v5, (uint64_t)v29, &v25);
        if (v13)
        {
          if (v25 <= 0)
          {
            NextResource = (const char **)ures_getNextResource((uint64_t)v29, (uint64_t)v27, (UErrorCode *)&v25);
            if (NextResource)
            {
              if (v25 <= 0)
              {
                do
                {
                  int v15 = *NextResource;
                  if (*NextResource && *v15 && strcmp(*NextResource, "default") && strncmp(v15, "private-", 8uLL))
                  {
                    if (v12 >= 1)
                    {
                      uint64_t v16 = v9;
                      uint64_t v17 = v6;
                      int v18 = v5;
                      uint64_t v19 = v12;
                      unint64_t v20 = (const char **)v31;
                      do
                      {
                        if (!strcmp(*v20, v15))
                        {
                          unsigned int v5 = v18;
                          uint64_t v6 = v17;
                          uint64_t v9 = v16;
                          goto LABEL_22;
                        }
                        ++v20;
                        --v19;
                      }
                      while (v19);
                      unsigned int v5 = v18;
                      uint64_t v6 = v17;
                      uint64_t v9 = v16;
                      if (v12 > 510) {
                        goto LABEL_19;
                      }
                    }
                    int v21 = strlen(v15);
                    uint64_t v22 = v24;
                    uint64_t v23 = v24 + (uint64_t)v21;
                    if ((int)v23 < 2046)
                    {
                      int v24 = v23 + 1;
                      v31[v12++] = strcpy(&v33[v22 - 2], v15);
                      v33[v23 - 2] = 0;
                    }
                    else
                    {
LABEL_19:
                      *uint64_t v3 = 1;
                    }
                  }
LABEL_22:
                  NextResource = (const char **)ures_getNextResource((uint64_t)v29, (uint64_t)v27, (UErrorCode *)&v25);
                }
                while (NextResource && v25 < 1);
              }
            }
          }
        }
        sub_18C8A49A0(v13, 1);
        int v11 = (char *)uenum_next((uint64_t)v9, (uint64_t)&v26, v3);
      }
      while (v11);
    }
    else
    {
      int v24 = 0;
    }
    v33[v24 - 2] = 0;
    sub_18C8A49A0((uint64_t)v29, 1);
    sub_18C8A49A0((uint64_t)v27, 1);
    uenum_close(v9);
    return uloc_openKeywordList(&v32, v24 + 1, v3);
  }
  else
  {
    sub_18C8A49A0((uint64_t)v29, 1);
    sub_18C8A49A0((uint64_t)v27, 1);
    return 0;
  }
}

void ures_getVersionByKey(uint64_t a1, const char *a2, uint8_t *a3, int *a4)
{
  int v7 = 0;
  StringByKey = ures_getStringByKey(a1, a2, &v7, a4);
  if (*a4 <= 0) {
    u_versionFromUString(a3, StringByKey);
  }
}

void sub_18C8A87F0(uint64_t a1)
{
  umtx_lock((atomic_ullong *)&unk_1EB20B690);
  if (a1)
  {
    do
    {
      uint64_t v2 = *(void *)(a1 + 16);
      --*(_DWORD *)(a1 + 108);
      a1 = v2;
    }
    while (v2);
  }

  umtx_unlock((std::mutex **)&unk_1EB20B690);
}

uint64_t sub_18C8A8850(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, uint64_t a5, char *a6, int a7, uint64_t a8, UErrorCode *a9)
{
  uint64_t v9 = a8;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a9 || *(int *)a9 > 0) {
    return v9;
  }
  if (!a5)
  {
    uint64_t v9 = 0;
    int v16 = 1;
    goto LABEL_8;
  }
  if (a2 >> 28 != 3)
  {
    if (a8)
    {
      uint64_t v17 = *(void *)(a8 + 8);
      if (v17) {
        sub_18C8A87F0(v17);
      }
      int v18 = *(void **)(v9 + 16);
      if (v18) {
        uprv_free(v18);
      }
      uint64_t v19 = *(char **)(v9 + 32);
      if (v19 == a6)
      {
LABEL_24:
        *(void *)(v9 + 8) = a1;
        sub_18C8A4C5C(a1);
        *(_WORD *)(v9 + 112) = 0;
        *(_DWORD *)(v9 + 124) = -1;
        *(void *)uint64_t v9 = a3;
        *(void *)(v9 + 24) = a5;
        if (*(char **)(v9 + 32) != a6)
        {
          int v23 = strlen(a6);
          sub_18C8A4B80(v9, a6, v23, a9);
        }
        if (a3)
        {
          int v24 = strlen(a3);
          uint64_t v25 = v9;
          int v26 = (char *)a3;
        }
        else
        {
          if ((a4 & 0x80000000) != 0)
          {
LABEL_32:
            if (v9 + 40 == *(void *)(v9 + 32)) {
              uint64_t v27 = *(int *)(v9 + 104);
            }
            else {
              uint64_t v27 = 0;
            }
            bzero((void *)(v9 + 40 + v27), 64 - v27);
            *(void *)(v9 + 16) = 0;
            *(_DWORD *)(v9 + 108) = a2;
            *(_DWORD *)(v9 + 128) = res_countArrayItems(*(void *)(v9 + 8) + 40, a2);
            return v9;
          }
          memset(v28, 0, sizeof(v28));
          int v24 = T_CString_integerToString(v28, a4, 0xAu);
          int v26 = (char *)v28;
          uint64_t v25 = v9;
        }
        sub_18C8A4B80(v25, v26, v24, a9);
        if (*(unsigned char *)(*(int *)(v9 + 104) + *(void *)(v9 + 32) - 1) != 47) {
          sub_18C8A4B80(v9, "/", 1, a9);
        }
        goto LABEL_32;
      }
      if (v19 && v19 != (char *)(v9 + 40)) {
        uprv_free(v19);
      }
    }
    else
    {
      uint64_t v22 = (char *)uprv_malloc(0x88uLL);
      uint64_t v9 = (uint64_t)v22;
      if (!v22)
      {
        int v16 = 7;
        goto LABEL_8;
      }
      *(void *)(v22 + 116) = 0x12BB38B012C9B17;
    }
    *(void *)(v9 + 32) = 0;
    *(_DWORD *)(v9 + 104) = 0;
    goto LABEL_24;
  }
  if (a7 >= 256)
  {
    int v16 = 24;
LABEL_8:
    *a9 = v16;
    return v9;
  }
  uint64_t v20 = a1 + 40;

  return sub_18C8A8B20(v20, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_18C8A8B20(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, uint64_t a5, const char *a6, int a7, uint64_t a8, UErrorCode *a9)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (*(int *)a9 > 0) {
    return a8;
  }
  int32_t v50 = 0;
  Alias = res_getAlias(a1, a2, &v50);
  if (v50 <= 0)
  {
    *a9 = U_ILLEGAL_ARGUMENT_ERROR;
    return a8;
  }
  memset(&__s[1], 0, 48);
  __s[0] = (char *)&__s[1] + 5;
  LODWORD(__s[1]) = 40;
  uint64_t v56 = 0;
  icu::CharString::appendInvariantChars((int *)__s, (UChar *)Alias, v50, a9);
  uint64_t v16 = 0;
  if (*(int *)a9 <= 0)
  {
    uint64_t v17 = __s[0];
    if (*__s[0] == 47)
    {
      int v18 = __s[0] + 1;
      uint64_t v19 = strchr(__s[0] + 1, 47);
      uint64_t v17 = v19;
      if (v19)
      {
        *uint64_t v19 = 0;
        uint64_t v17 = v19 + 1;
      }
      if (!strcmp(v18, "LOCALE"))
      {
        uint64_t v41 = 0;
        uint64_t v26 = a5;
        goto LABEL_22;
      }
      if (!strcmp(v18, "ICUDATA")) {
        uint64_t v20 = 0;
      }
      else {
        uint64_t v20 = v18;
      }
      if (v17)
      {
        int v21 = strchr(v17, 47);
        uint64_t v22 = v21;
        if (v21)
        {
          *int v21 = 0;
          uint64_t v22 = v21 + 1;
        }
      }
      else
      {
        uint64_t v22 = 0;
        uint64_t v17 = "";
      }
    }
    else
    {
      int v23 = strchr(__s[0], 47);
      uint64_t v22 = v23;
      if (v23)
      {
        *int v23 = 0;
        uint64_t v22 = v23 + 1;
      }
      uint64_t v20 = *(const char **)(a5 + 8);
    }
    LODWORD(__dst[0]) = 0;
    uint64_t v24 = sub_18C8A6A04(0, v20, v17, 2, __dst);
    uint64_t v25 = v24;
    if (SLODWORD(__dst[0]) > 0)
    {
      *a9 = (UErrorCode)__dst[0];
LABEL_72:
      if (v25) {
        sub_18C8A49A0(v25, 1);
      }
      uint64_t v16 = a8;
      goto LABEL_75;
    }
    uint64_t v41 = v24;
    uint64_t v26 = *(void *)(v24 + 8);
    uint64_t v17 = v22;
LABEL_22:
    long long __s2 = 0;
    if (v17)
    {
      long long v53 = 0u;
      long long v54 = 0u;
      *(_OWORD *)__int16 __dst = 0u;
      long long v52 = 0u;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v43, v17);
      __dst[0] = (char *)((unint64_t)__dst | 0xD);
      LODWORD(__dst[1]) = 40;
      WORD2(__dst[1]) = 0;
      DWORD2(v54) = 0;
      icu::CharString::append((icu::CharString *)__dst, v43, v44, a9);
      UErrorCode v27 = *a9;
      if (*(int *)a9 <= 0)
      {
        uint64_t v30 = 0;
        uint64_t v31 = __dst[0];
        long long v42 = __dst[0];
        uint64_t v32 = (a7 + 1);
        UErrorCode v33 = v27;
        uint64_t v28 = a8;
        while (1)
        {
          uint64_t v34 = *(unsigned int *)(v26 + 72);
          while (*v31)
          {
            if (v33 > U_ZERO_ERROR) {
              goto LABEL_25;
            }
            uint64_t v34 = sub_18C8ABC8C(v26 + 40, v34, &v42, (const char **)&__s2);
            if (v34 == -1)
            {
              UErrorCode v33 = *a9;
              break;
            }
            uint64_t v28 = sub_18C8A8850(v26, v34, __s2, 0xFFFFFFFFLL, a5, v30, v32, v28, a9);
            UErrorCode v33 = *a9;
            if (*(int *)a9 > 0) {
              goto LABEL_25;
            }
            if (!__s2 || strcmp(v17, __s2))
            {
              int32_t v35 = *(void **)(v28 + 32);
              if (v35) {
                BOOL v36 = v35 == (void *)(v28 + 40);
              }
              else {
                BOOL v36 = 1;
              }
              if (!v36) {
                uprv_free(v35);
              }
              *(void *)(v28 + 32) = 0;
              *(_DWORD *)(v28 + 104) = 0;
              int v37 = strlen(v17);
              sub_18C8A4B80(v28, v17, v37, a9);
              if (*(unsigned char *)(*(int *)(v28 + 104) + *(void *)(v28 + 32) - 1) != 47) {
                sub_18C8A4B80(v28, "/", 1, a9);
              }
              UErrorCode v33 = *a9;
              if (*(int *)a9 > 0) {
                goto LABEL_25;
              }
            }
            uint64_t v26 = *(void *)(v28 + 8);
            uint64_t v30 = *(void *)(v28 + 32);
            uint64_t v34 = *(unsigned int *)(v28 + 108);
            uint64_t v31 = v42;
          }
          if (v33 > U_ZERO_ERROR || v34 != -1) {
            break;
          }
          uint64_t v26 = *(void *)(v26 + 16);
          if (!v26)
          {
            *a9 = U_MISSING_RESOURCE_ERROR;
            break;
          }
          long long v42 = __dst[0];
          strcpy(__dst[0], v17);
          uint64_t v31 = v42;
          UErrorCode v33 = *a9;
        }
      }
      else
      {
        uint64_t v28 = a8;
        a8 = 0;
      }
LABEL_25:
      uint64_t v25 = v41;
      if (BYTE4(__dst[1])) {
        uprv_free(__dst[0]);
      }
      if (v27 > U_ZERO_ERROR) {
        goto LABEL_72;
      }
      goto LABEL_69;
    }
    uint64_t v40 = v26 + 40;
    uint64_t v29 = *(unsigned int *)(v26 + 72);
    if (a6)
    {
      LODWORD(v56) = 0;
      *__s[0] = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v47, a6);
      icu::CharString::append((icu::CharString *)__s, v47, v48, a9);
      uint64_t v25 = v41;
      if (*(int *)a9 > 0)
      {
LABEL_58:
        a8 = 0;
        goto LABEL_72;
      }
      __dst[0] = __s[0];
      uint64_t v29 = sub_18C8ABC8C(v40, v29, __dst, (const char **)&__s2);
    }
    else
    {
      uint64_t v25 = v41;
    }
    if (a3)
    {
      LODWORD(v56) = 0;
      *__s[0] = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v45, a3);
      icu::CharString::append((icu::CharString *)__s, v45, v46, a9);
      if (*(int *)a9 > 0) {
        goto LABEL_58;
      }
      __dst[0] = __s[0];
      TableItemByint Index = sub_18C8ABC8C(v40, v29, __dst, (const char **)&__s2);
    }
    else
    {
      if (a4 == -1) {
        goto LABEL_66;
      }
      if (v29 >> 28 == 2 || (v29 & 0xE0000000) == 0x40000000)
      {
        __dst[0] = 0;
        TableItemByint Index = res_getTableItemByIndex(v40, v29, a4, __dst);
      }
      else
      {
        TableItemByint Index = res_getArrayItem(v40, v29, a4);
      }
    }
    uint64_t v29 = TableItemByIndex;
LABEL_66:
    if (v29 == -1)
    {
      *a9 = U_MISSING_RESOURCE_ERROR;
      uint64_t v28 = a8;
    }
    else
    {
      uint64_t v28 = sub_18C8A8850(v26, v29, __s2, 0xFFFFFFFFLL, a5, 0, (a7 + 1), a8, a9);
    }
LABEL_69:
    if (v25 == v28) {
      uint64_t v25 = 0;
    }
    a8 = v28;
    goto LABEL_72;
  }
LABEL_75:
  if (BYTE4(__s[1])) {
    uprv_free(__s[0]);
  }
  return v16;
}

void sub_18C8A90AC(icu::ResourceSink *a1)
{
  icu::ResourceSink::~ResourceSink(a1);

  icu::UMemory::operator delete(v1);
}

void sub_18C8A90D4(uint64_t a1, char *a2, icu::ResourceValue *a3, uint64_t a4, UErrorCode *a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = 0;
  uint64_t v32 = a2;
  memset(v30, 0, sizeof(v30));
  (*(void (**)(_OWORD *__return_ptr, icu::ResourceValue *, UErrorCode *))(*(void *)a3 + 88))(v30, a3, a5);
  if (*(int *)a5 <= 0
    && icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, 0, (const char **)&v32, a3))
  {
    unsigned int v9 = 0;
    do
    {
      if ((*(unsigned int (**)(icu::ResourceValue *))(*(void *)a3 + 24))(a3) == 3)
      {
        uint64_t v40 = 0;
        memset(v39, 0, sizeof(v39));
        uint64_t v10 = sub_18C8A8B20(*((void *)a3 + 1), *((_DWORD *)a3 + 6), 0, 0xFFFFFFFF, *((void *)a3 + 2), 0, 0, (uint64_t)v39, a5);
        if (*(int *)a5 <= 0)
        {
          uint64_t v11 = v10;
          uint64_t v29 = 0;
          uint64_t v27 = 0;
          uint64_t v28 = 0;
          uint64_t v12 = *(void *)(v10 + 8) + 40;
          uint64_t v26 = &unk_1EDA480F8;
          uint64_t v27 = v12;
          uint64_t v28 = *(void *)(v10 + 24);
          LODWORD(v29) = *(_DWORD *)(v10 + 108);
          if (sub_18C8AAD64((uint64_t)&v26) == 2)
          {
            int v38 = 0;
            memset(&v36[1], 0, 48);
            v36[0] = (char *)&v36[1] + 5;
            LODWORD(v36[1]) = 40;
            int v37 = 0;
            icu::StringPiece::StringPiece((icu::StringPiece *)&v24, *(const char **)(v11 + 32));
            icu::CharString::append((icu::CharString *)v36, v24, v25, a5);
            uint64_t v19 = v32;
            (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
            uint64_t v13 = *(void *)(v11 + 8);
            int v14 = 2;
            while (v14 == 2 && *(void *)(v13 + 16))
            {
              int v35 = 0;
              memset(&v33[1], 0, 48);
              v33[0] = (char *)&v33[1] + 5;
              LODWORD(v33[1]) = 40;
              int v34 = 0;
              icu::CharString::copyFrom(v33, v36, a5);
              uint64_t v22 = 0;
              int v23 = (char *)v33[0];
              uint64_t v13 = *(void *)(v13 + 16);
              int v15 = sub_18C8ABC8C(v13 + 40, *(unsigned int *)(v13 + 72), &v23, &v22);
              if (v15 == -1)
              {
                char v18 = 1;
                int v14 = 2;
              }
              else
              {
                uint64_t v27 = v13 + 40;
                LODWORD(v29) = v15;
                int v14 = sub_18C8AAD64((uint64_t)&v26);
                if (v14 == 3)
                {
                  uint64_t v16 = sub_18C8A8B20(v27, v29, 0, 0xFFFFFFFF, v28, 0, 0, (uint64_t)v39, a5);
                  int v37 = 0;
                  *(unsigned char *)v36[0] = 0;
                  icu::StringPiece::StringPiece((icu::StringPiece *)&v20, *(const char **)(v16 + 32));
                  icu::CharString::append((icu::CharString *)v36, v20, v21, a5);
                  uint64_t v13 = *(void *)(v16 + 8);
                  int v17 = *(_DWORD *)(v16 + 108);
                  uint64_t v27 = v13 + 40;
                  LODWORD(v29) = v17;
                  int v14 = sub_18C8AAD64((uint64_t)&v26);
                }
                if (v14 == 2)
                {
                  (*(void (**)(void, char *, void **, uint64_t, UErrorCode *))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v19, &v26, a4, a5);
                  char v18 = 1;
                }
                else
                {
                  char v18 = 0;
                  *a5 = U_INTERNAL_PROGRAM_ERROR;
                }
              }
              if (BYTE4(v33[1])) {
                uprv_free((void *)v33[0]);
              }
              if ((v18 & 1) == 0)
              {
                if (BYTE4(v36[1])) {
                  uprv_free((void *)v36[0]);
                }
                icu::ResourceValue::~ResourceValue((icu::ResourceValue *)&v26);
                sub_18C8A49A0((uint64_t)v39, 1);
                return;
              }
            }
            if (BYTE4(v36[1])) {
              uprv_free((void *)v36[0]);
            }
          }
          else
          {
            (*(void (**)(void, char *, void **, uint64_t, UErrorCode *))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v32, &v26, a4, a5);
          }
          icu::ResourceValue::~ResourceValue((icu::ResourceValue *)&v26);
        }
        sub_18C8A49A0((uint64_t)v39, 1);
      }
      else
      {
        (*(void (**)(void, char *, icu::ResourceValue *, uint64_t, UErrorCode *))(**(void **)(a1 + 8)
                                                                                            + 24))(*(void *)(a1 + 8), v32, a3, a4, a5);
      }
      if (*(int *)a5 >= 1) {
        break;
      }
      ++v9;
    }
    while (icu::ResourceTable::getKeyAndValue((icu::ResourceTable *)v30, v9, (const char **)&v32, a3));
  }
}

void sub_18C8A95A0(int *a1)
{
  if (*a1 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1EB20B6E0, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1EB20B6E0))
    {
      if (dword_1EB20B6E4 >= 1) {
        *a1 = dword_1EB20B6E4;
      }
    }
    else
    {
      qword_1EB20B6E8 = (uint64_t)uhash_open((uint64_t)sub_18C8AA1F4, (uint64_t)sub_18C8AA230, 0, a1);
      sub_18C8546F4(0x1Cu, (uint64_t)sub_18C8AA278);
      dword_1EB20B6E4 = *a1;
      icu::umtx_initImplPostInit(&dword_1EB20B6E0);
    }
  }
}

const char **sub_18C8A967C(const char *a1, char *a2, const char *a3, int a4, BOOL *a5, unsigned char *a6, BOOL *a7, UErrorCode *a8)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  *a6 = 1;
  long long v58 = 0u;
  memset(v59, 0, sizeof(v59));
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  *(_OWORD *)__int16 __dst = 0u;
  strcpy(__dst, a2);
  while (1)
  {
    int v15 = (const char **)sub_18C8A9CE0(a2, a1, a8);
    if (*(int *)a8 > 0) {
      return 0;
    }
    uint64_t v16 = v15;
    size_t v17 = strlen(a2);
    *a7 = strncmp(a2, a3, v17) == 0;
    int v18 = *((_DWORD *)v16 + 28);
    if (v18)
    {
      --*((_DWORD *)v16 + 27);
      uint64_t v16 = 0;
      *a8 = U_USING_FALLBACK_WARNING;
    }
    else
    {
      strcpy(a2, *v16);
    }
    *a5 = strcmp(a2, "root") == 0;
    uint64_t v19 = a2;
    if (!v18) {
      break;
    }
    size_t v20 = strlen(a2);
    if (!v20 || a2[v20 - 1] == 95 || (LODWORD(v77[0]) = 0, uloc_getVariant(a2, 0, 0, (int *)v77)))
    {
      uint64_t v19 = a2;
      break;
    }
    UErrorCode v50 = U_ZERO_ERROR;
    size_t v49 = a2;
    long long v78 = 0u;
    memset(v77, 0, sizeof(v77));
    sub_18C8825C0((uint64_t)a2, &v49, &v50, (uint64_t)v77);
    int v23 = (icu::CharString *)v49;
    if (*v49 == 95) {
      int v23 = (icu::CharString *)++v49;
    }
    long long v76 = 0u;
    memset(v75, 0, sizeof(v75));
    sub_18C882744(v23, &v49, &v50, (uint64_t)v75);
    uint64_t v24 = (uint64_t)v49;
    if (*v49 == 95) {
      uint64_t v24 = (uint64_t)++v49;
    }
    long long v74 = 0u;
    memset(v73, 0, sizeof(v73));
    sub_18C882854(v24, (uint64_t *)&v49, &v50, (uint64_t)v73);
    uint64_t v72 = 0;
    memset(&__src[1], 0, 48);
    __src[0] = (char *)&__src[1] + 5;
    LODWORD(__src[1]) = 40;
    if (v50 >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      int v25 = strrchr(a2, 95);
      if (!v25) {
        goto LABEL_39;
      }
      *int v25 = 0;
      goto LABEL_69;
    }
    if (!a4)
    {
      uint64_t v27 = sub_18C8A4844(a2, (uint64_t)"ar_Latn", (uint64_t)"ar_Latn", dword_18CA826C8, 714);
      if (v27)
      {
        uint64_t v28 = (const char *)v27;
LABEL_68:
        strcpy(a2, v28);
LABEL_69:
        LOBYTE(v3sub_18C8A49A0((uint64_t)this, 1) = 1;
        goto LABEL_70;
      }
    }
    if (DWORD2(v76))
    {
      if (DWORD2(v74))
      {
        sub_18C8AA3DC((uint64_t)v77, (uint64_t)v73, (uint64_t)&__s1);
        if (DWORD2(v70) == DWORD2(v76))
        {
          if (DWORD2(v76)) {
            BOOL v26 = memcmp((const void *)__s1, v75[0], SDWORD2(v76)) == 0;
          }
          else {
            BOOL v26 = 1;
          }
        }
        else
        {
          BOOL v26 = 0;
        }
        if (BYTE12(__s1)) {
          uprv_free((void *)__s1);
        }
        int v38 = icu::CharString::append((icu::CharString *)__src, v77[0], SDWORD2(v78), &v50);
        if (v26)
        {
          icu::StringPiece::StringPiece((icu::StringPiece *)&v47, "_");
          UErrorCode v33 = icu::CharString::append(v38, v47, v48, &v50);
          int v34 = (const char *)v73[0];
          int v35 = DWORD2(v74);
        }
        else
        {
          icu::StringPiece::StringPiece((icu::StringPiece *)&v45, "_");
          UErrorCode v33 = icu::CharString::append(v38, v45, v46, &v50);
          int v34 = (const char *)v75[0];
          int v35 = DWORD2(v76);
        }
      }
      else
      {
        if (!a4)
        {
          *(void *)&long long v63 = (char *)&v63 + 13;
          DWORD2(v63) = 40;
          WORD6(v63) = 0;
          DWORD2(v66) = 0;
          sub_18C8AA3DC((uint64_t)v77, (uint64_t)&v63, (uint64_t)&__s1);
          BOOL v31 = 0;
          if (DWORD2(v70) == DWORD2(v76))
          {
            if (DWORD2(v76)) {
              BOOL v31 = memcmp((const void *)__s1, v75[0], SDWORD2(v76)) == 0;
            }
            else {
              BOOL v31 = 1;
            }
          }
          if (BYTE12(__s1)) {
            uprv_free((void *)__s1);
          }
          if (BYTE12(v63)) {
            uprv_free((void *)v63);
          }
          if (!v31) {
            goto LABEL_70;
          }
        }
        int v34 = v77[0];
        int v35 = DWORD2(v78);
        UErrorCode v33 = (icu::CharString *)__src;
      }
      icu::CharString::append(v33, v34, v35, &v50);
    }
    else
    {
      if (!DWORD2(v74))
      {
LABEL_39:
        LOBYTE(v3sub_18C8A49A0((uint64_t)this, 1) = 0;
        goto LABEL_70;
      }
      UErrorCode v44 = U_ZERO_ERROR;
      size_t v49 = __dst;
      long long v69 = 0u;
      long long v70 = 0u;
      long long __s1 = 0u;
      long long v68 = 0u;
      sub_18C8825C0((uint64_t)__dst, &v49, &v44, (uint64_t)&__s1);
      if (*v49 == 95) {
        ++v49;
      }
      long long v65 = 0u;
      long long v66 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      sub_18C882744((icu::CharString *)__dst, 0, &v44, (uint64_t)&v63);
      int v29 = DWORD2(v66);
      int v37 = icu::CharString::append((icu::CharString *)__src, v77[0], SDWORD2(v78), &v44);
      if (v29)
      {
        icu::StringPiece::StringPiece((icu::StringPiece *)&v42, "_");
        uint64_t v30 = icu::CharString::append(v37, v42, v43, &v44);
        icu::CharString::append(v30, (const char *)v63, SDWORD2(v66), &v44);
      }
      else
      {
        icu::StringPiece::StringPiece((icu::StringPiece *)&v40, "_");
        uint64_t v32 = icu::CharString::append(v37, v40, v41, &v44);
        sub_18C8AA3DC((uint64_t)v77, (uint64_t)v73, (uint64_t)&v60);
        icu::CharString::append(v32, v60, v62, &v44);
        if (v61) {
          uprv_free(v60);
        }
      }
      if (BYTE12(v63)) {
        uprv_free((void *)v63);
      }
      if (BYTE12(__s1)) {
        uprv_free((void *)__s1);
      }
    }
    LOBYTE(v3sub_18C8A49A0((uint64_t)this, 1) = 0;
    if (v50 <= U_ZERO_ERROR && v72)
    {
      uint64_t v28 = __src[0];
      goto LABEL_68;
    }
LABEL_70:
    if (BYTE4(__src[1])) {
      uprv_free(__src[0]);
    }
    if (BYTE4(v73[1])) {
      uprv_free(v73[0]);
    }
    if (BYTE4(v75[1])) {
      uprv_free((void *)v75[0]);
    }
    if (BYTE4(v77[1])) {
      uprv_free((void *)v77[0]);
    }
    *a6 = v31;
    if (v31) {
      goto LABEL_13;
    }
    int v22 = 0;
LABEL_17:
    if (!v22) {
      return v16;
    }
  }
  int v21 = strrchr(v19, 95);
  if (v21)
  {
    *int v21 = 0;
    *a6 = 1;
LABEL_13:
    if (*a2)
    {
      int v22 = 1;
      if (!v18) {
        return v16;
      }
    }
    else
    {
      *(_DWORD *)a2 = 6581877;
      int v22 = *a6;
      if (!v18) {
        return v16;
      }
    }
    goto LABEL_17;
  }
  *a6 = 0;
  return v16;
}

void *sub_18C8A9CE0(const char *a1, const char *a2, UErrorCode *a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  *(_OWORD *)int v29 = 0u;
  long long v30 = 0u;
  int v20 = 0;
  if (*(int *)a3 > 0) {
    return 0;
  }
  if (a1)
  {
    if (*a1) {
      Default = a1;
    }
    else {
      Default = "root";
    }
  }
  else
  {
    Default = (const char *)uloc_getDefault(0);
  }
  uint64_t v28 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  v21[0] = Default;
  v21[1] = a2;
  int v7 = (char *)uhash_get(qword_1EB20B6E8, (uint64_t)v21);
  if (v7) {
    goto LABEL_10;
  }
  double result = uprv_malloc(0x78uLL);
  if (!result)
  {
    int v8 = 7;
LABEL_18:
    *a3 = v8;
    return result;
  }
  int v7 = (char *)result;
  *((void *)result + 14) = 0;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + sub_18C8A49A0((uint64_t)this, 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  *(_OWORD *)double result = 0u;
  int v9 = strlen(Default);
  if (v9 > 2)
  {
    uint64_t v10 = (char *)uprv_malloc(v9 + 1);
    *(void *)int v7 = v10;
    if (!v10)
    {
LABEL_23:
      *a3 = U_MEMORY_ALLOCATION_ERROR;
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v10 = v7 + 104;
    *(void *)int v7 = v7 + 104;
  }
  strcpy(v10, Default);
  if (*(int *)a3 >= 1)
  {
LABEL_27:
    uprv_free(v7);
    return 0;
  }
  if (a2)
  {
    uint64_t v11 = (char *)uprv_strdup(a2);
    *((void *)v7 + sub_18C8A49A0((uint64_t)this, 1) = v11;
    if (!v11) {
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v11 = (char *)*((void *)v7 + 1);
  }
  sub_18C8AA9C4(v7 + 40, v11, *(const char **)v7, a3);
  if (*(int *)a3 >= 1)
  {
    if (*a3 == U_MEMORY_ALLOCATION_ERROR) {
      goto LABEL_27;
    }
    UErrorCode v13 = U_USING_FALLBACK_WARNING;
    goto LABEL_37;
  }
  if (v7[98])
  {
    uint64_t v12 = sub_18C8AA5B8(*((void *)v7 + 1), (int *)a3);
    *((void *)v7 + 4) = v12;
    UErrorCode v13 = *a3;
    if (*(int *)a3 > 0)
    {
LABEL_38:
      *((_DWORD *)v7 + 28) = v13;
      goto LABEL_39;
    }
    uint64_t v14 = *(void *)(v12 + 48);
    if (*(_DWORD *)(*((void *)v7 + 6) + 32) != *(_DWORD *)(v14 + 32))
    {
      UErrorCode v13 = U_INVALID_FORMAT_ERROR;
LABEL_37:
      *a3 = v13;
      goto LABEL_38;
    }
    *((void *)v7 + 8) = v14 + 4 + 4 * *(unsigned __int8 *)(v14 + 4);
    *((void *)v7 + 10) = *(void *)(v12 + 56);
  }
  unsigned int Resource = res_getResource((uint64_t)(v7 + 40), "%%ALIAS");
  if (Resource != -1)
  {
    StringNoTrace = res_getStringNoTrace((uint64_t)(v7 + 40), Resource, &v20);
    if (StringNoTrace)
    {
      if (v20 >= 1)
      {
        u_UCharsToChars(StringNoTrace, v29, v20 + 1);
        *((void *)v7 + 3) = sub_18C8A9CE0(v29, a2, a3);
      }
    }
  }
LABEL_39:
  uint64_t v17 = uhash_get(qword_1EB20B6E8, (uint64_t)v7);
  if (v17)
  {
    int v18 = (char *)v17;
    sub_18C8AA348(v7);
    int v7 = v18;
    goto LABEL_10;
  }
  UErrorCode v19 = U_ZERO_ERROR;
  uhash_put(qword_1EB20B6E8, (uint64_t)v7, (uint64_t)v7, (int *)&v19);
  if (v19 >= U_ILLEGAL_ARGUMENT_ERROR)
  {
    *a3 = v19;
    sub_18C8AA348(v7);
    return 0;
  }
  do
  {
LABEL_10:
    double result = v7;
    int v7 = (char *)*((void *)v7 + 3);
  }
  while (v7);
  int v8 = *((_DWORD *)result + 28);
  ++*((_DWORD *)result + 27);
  if (v8 && *(int *)a3 <= 0) {
    goto LABEL_18;
  }
  return result;
}

uint64_t sub_18C8A9FE4(uint64_t *a1, char *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  uint64_t v5 = *a1;
  if (!*(void *)(*a1 + 16))
  {
    while (!*(unsigned char *)(v5 + 96) && res_getResource(v5 + 40, "%%ParentIsRoot") == -1)
    {
      unsigned int Resource = res_getResource(*a1 + 40, "%%Parent");
      if (Resource != -1)
      {
        int v14 = 0;
        StringNoTrace = res_getStringNoTrace(*a1 + 40, Resource, &v14);
        if (StringNoTrace && v14 >= 1 && v14 <= 156)
        {
          u_UCharsToChars(StringNoTrace, a2, v14 + 1);
          if (!strcmp(a2, "root")) {
            break;
          }
        }
      }
      int v13 = 0;
      uint64_t v11 = sub_18C8A9CE0(a2, *(const char **)(*a1 + 8), (UErrorCode *)&v13);
      if (v13 >= 1)
      {
        uint64_t result = 0;
        *a3 = v13;
        return result;
      }
      *(void *)(*a1 + 16) = v11;
      *a1 = (uint64_t)v11;
      uint64_t v12 = strrchr(a2, 95);
      if (v12)
      {
        *uint64_t v12 = 0;
      }
      else if (!*a2 || !strstr("nb nn", a2))
      {
        return 1;
      }
      uint64_t v5 = *a1;
      uint64_t result = 1;
      if (*(void *)(*a1 + 16)) {
        return result;
      }
    }
  }
  return 1;
}

uint64_t sub_18C8AA170(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  int v6 = 0;
  uint64_t v5 = sub_18C8A9CE0("root", *(const char **)(*(void *)a1 + 8), (UErrorCode *)&v6);
  if (v6 < 1)
  {
    *(void *)(*(void *)a1 + 16) = v5;
    *(void *)a1 = v5;
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *a2 = v6;
  }
  return result;
}

uint64_t sub_18C8AA1F4(unsigned __int8 **a1)
{
  uint64_t v1 = a1[1];
  unsigned int v2 = uhash_hashChars(*a1);
  return v2 + 37 * uhash_hashChars(v1);
}

BOOL sub_18C8AA230(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned int v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL result = uhash_compareChars(*a1, *a2);
  if (result) {
    return uhash_compareChars(v2, v3);
  }
  return result;
}

uint64_t sub_18C8AA278()
{
  if (qword_1EB20B6E8)
  {
    int v5 = 0;
    umtx_lock((atomic_ullong *)&unk_1EB20B690);
    if (qword_1EB20B6E8)
    {
      do
      {
        int v5 = -1;
        uint64_t v0 = uhash_nextElement((uint64_t *)qword_1EB20B6E8, &v5);
        if (!v0) {
          break;
        }
        uint64_t v1 = v0;
        int v2 = 0;
        do
        {
          uint64_t v3 = *(void *)(v1 + 8);
          if (!*(_DWORD *)(v3 + 108))
          {
            uhash_removeElement(qword_1EB20B6E8, (_DWORD *)v1);
            sub_18C8AA348((char *)v3);
            int v2 = 1;
          }
          uint64_t v1 = uhash_nextElement((uint64_t *)qword_1EB20B6E8, &v5);
        }
        while (v1);
      }
      while (v2);
    }
    umtx_unlock((std::mutex **)&unk_1EB20B690);
    uhash_close((unsigned char *)qword_1EB20B6E8);
    qword_1EB20B6E8 = 0;
  }
  atomic_store(0, &dword_1EB20B6E0);
  return 1;
}

void sub_18C8AA348(char *a1)
{
  sub_18C8AAA58((_OWORD **)a1 + 5);
  int v2 = *(char **)a1;
  if (*(void *)a1) {
    BOOL v3 = v2 == a1 + 104;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    uprv_free(v2);
  }
  uint64_t v4 = (void *)*((void *)a1 + 1);
  if (v4) {
    uprv_free(v4);
  }
  uint64_t v5 = *((void *)a1 + 4);
  if (v5) {
    --*(_DWORD *)(v5 + 108);
  }
  uint64_t v6 = *((void *)a1 + 3);
  if (v6)
  {
    do
    {
      uint64_t v7 = v6;
      uint64_t v6 = *(void *)(v6 + 24);
    }
    while (v6);
    --*(_DWORD *)(v7 + 108);
  }

  uprv_free(a1);
}

void sub_18C8AA3DC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char __s1[8] = *(char **)MEMORY[0x1E4F143B8];
  UErrorCode v18 = U_ZERO_ERROR;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(void *)(a3 + 56) = 0;
  icu::StringPiece::StringPiece((icu::StringPiece *)&v16, "Latn");
  uint64_t v6 = v16;
  int v7 = v17;
  *(void *)a3 = a3 + 13;
  *(_DWORD *)(a3 + 8) = 40;
  *(_WORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  icu::CharString::append((icu::CharString *)a3, v6, v7, &v18);
  if (!*(_DWORD *)(a2 + 56)) {
    goto LABEL_8;
  }
  memset(&__s1[1], 0, 56);
  __s1[0] = (char *)&__s1[1] + 5;
  LODWORD(__s1[1]) = 40;
  int v8 = icu::CharString::append((icu::CharString *)__s1, *(const char **)a1, *(_DWORD *)(a1 + 56), &v18);
  icu::StringPiece::StringPiece((icu::StringPiece *)&v14, "_");
  int v9 = icu::CharString::append(v8, v14, v15, &v18);
  icu::CharString::append(v9, *(const char **)a2, *(_DWORD *)(a2 + 56), &v18);
  uint64_t v10 = 0;
  UErrorCode v11 = v18;
  if (v18 <= U_ZERO_ERROR) {
    uint64_t v10 = (const char *)sub_18C8A4844(__s1[0], (uint64_t)&unk_18CA83215, (uint64_t)"Aghb", dword_18CA844A8, 2052);
  }
  if (BYTE4(__s1[1])) {
    uprv_free(__s1[0]);
  }
  if (v11 <= U_ZERO_ERROR)
  {
    if (v10)
    {
LABEL_9:
      *(_DWORD *)(a3 + 56) = 0;
      **(unsigned char **)a3 = 0;
      icu::StringPiece::StringPiece((icu::StringPiece *)&v12, v10);
      icu::CharString::append((icu::CharString *)a3, v12, v13, &v18);
      return;
    }
LABEL_8:
    uint64_t v10 = (const char *)sub_18C8A4844(*(char **)a1, (uint64_t)&unk_18CA83215, (uint64_t)"Aghb", dword_18CA844A8, 2052);
    if (!v10) {
      return;
    }
    goto LABEL_9;
  }
}

uint64_t sub_18C8AA5B8(uint64_t a1, int *a2)
{
  uint64_t result = sub_18C8A9CE0("pool", a1, a2);
  if (*a2 <= 0 && (!result || *(_DWORD *)(result + 112) || !*(unsigned char *)(result + 97))) {
    *a2 = 3;
  }
  return result;
}

void sub_18C8AA618(void *a1)
{
  int v2 = (void *)a1[1];
  sub_18C8A49A0((uint64_t)v2 + 136, 1);
  sub_18C8A49A0((uint64_t)v2, 1);
  uprv_free(v2);

  uprv_free(a1);
}

uint64_t sub_18C8AA670(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return *(unsigned int *)(v1 + 128);
  }
  else {
    return 0;
  }
}

const char *sub_18C8AA688(uint64_t a1, _DWORD *a2, UErrorCode *a3)
{
  Nextunsigned int Resource = *(char **)(a1 + 8);
  if (NextResource)
  {
    if (*((_DWORD *)NextResource + 31) >= *((_DWORD *)NextResource + 32) - 1)
    {
      uint64_t v5 = 0;
      LODWORD(NextResource) = 0;
      if (!a2) {
        return v5;
      }
      goto LABEL_7;
    }
    Nextunsigned int Resource = ures_getNextResource((uint64_t)NextResource, (uint64_t)(NextResource + 136), a3);
    if (NextResource)
    {
      uint64_t v5 = *(const char **)NextResource;
      LODWORD(NextResource) = strlen(*(const char **)NextResource);
      if (!a2) {
        return v5;
      }
      goto LABEL_7;
    }
  }
  uint64_t v5 = 0;
  if (a2) {
LABEL_7:
  }
    *a2 = NextResource;
  return v5;
}

uint64_t sub_18C8AA700(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if (v1) {
    *(_DWORD *)(v1 + 124) = -1;
  }
  return result;
}

void res_read(_OWORD *a1, unsigned __int16 *a2, unsigned int *a3, unsigned int a4, int *a5)
{
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  if (*a5 <= 0)
  {
    int v9 = 0;
    if (sub_18C8AA7A0(&v9, (uint64_t)a2, (uint64_t)a3, a2)) {
      sub_18C8AA81C((uint64_t)a1, (unsigned __int8 *)&v9, a3, a4, a5);
    }
    else {
      *a5 = 3;
    }
  }
}

BOOL sub_18C8AA7A0(_DWORD *a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  *a1 = *((_DWORD *)a4 + 3);
  return *a4 >= 0x14u
      && !*((unsigned char *)a4 + 4)
      && !*((unsigned char *)a4 + 5)
      && *((unsigned char *)a4 + 6) == 2
      && *((unsigned char *)a4 + 8) == 82
      && *((unsigned char *)a4 + 9) == 101
      && *((unsigned char *)a4 + 10) == 115
      && *((unsigned char *)a4 + 11) == 66
      && *((unsigned __int8 *)a4 + 12) - 1 < 3;
}

void sub_18C8AA81C(uint64_t a1, unsigned __int8 *a2, unsigned int *a3, unsigned int a4, _DWORD *a5)
{
  unsigned int v6 = *a3;
  *(_DWORD *)(a1 + 32) = *a3;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = &unk_18CA864F2;
  if ((a4 & 0x80000000) == 0)
  {
    unsigned int v7 = 6;
    if (*a2 == 1)
    {
      if (a2[1]) {
        unsigned int v7 = 6;
      }
      else {
        unsigned int v7 = 1;
      }
    }
    if (a4 >> 2 < v7) {
      goto LABEL_34;
    }
  }
  if (v6 >> 28 != 2 && (v6 & 0xE0000000) != 0x40000000) {
    goto LABEL_34;
  }
  unsigned int v9 = *a2;
  if (v9 == 1 && !a2[1])
  {
    *(_DWORD *)(a1 + 36) = 0x10000;
    goto LABEL_29;
  }
  unsigned int v10 = *((unsigned __int8 *)a3 + 4);
  if (v10 > 4 && ((a4 & 0x80000000) != 0 || 4 * v10 + 4 <= a4 && (int)a4 >= (int)(4 * a3[4])))
  {
    signed int v11 = a3[2];
    if (v11 > (int)(v10 + 1))
    {
      *(_DWORD *)(a1 + 36) = 4 * v11;
      unsigned int v9 = *a2;
    }
    if (v9 >= 3) {
      *(_DWORD *)(a1 + 48) = a3[1] >> 8;
    }
    if (v10 < 6)
    {
      if (!*(unsigned char *)(a1 + 57) && !*(unsigned char *)(a1 + 58)) {
        goto LABEL_29;
      }
    }
    else
    {
      unsigned int v12 = a3[6];
      *(unsigned char *)(a1 + 56) = v12 & 1;
      *(unsigned char *)(a1 + 57) = (v12 & 2) != 0;
      *(unsigned char *)(a1 + 58) = (v12 & 4) != 0;
      *(_DWORD *)(a1 + 48) |= (v12 << 12) & 0xF000000;
      *(_DWORD *)(a1 + 52) = HIWORD(v12);
      if ((v12 >> 1))
      {
        if (v10 > 7) {
          goto LABEL_37;
        }
      }
      else if (v10 > 7 || ((v12 >> 2) & 1) == 0)
      {
        if (v10 >= 7)
        {
LABEL_37:
          uint64_t v14 = (int)a3[2];
          if ((int)a3[7] > (int)v14) {
            *(void *)(a1 + 16) = &a3[v14];
          }
        }
LABEL_29:
        *(unsigned char *)(a1 + 59) = 1;
        return;
      }
    }
  }
LABEL_34:
  *a5 = 3;
  int v13 = *(_OWORD **)a1;
  if (*(void *)a1)
  {
    udata_close(v13);
    *(void *)a1 = 0;
  }
}

void sub_18C8AA9C4(_OWORD *a1, char *a2, const char *a3, UErrorCode *a4)
{
  int v8 = 0;
  *a1 = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  unsigned int v6 = udata_openChoice(a2, "res", a3, (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18C8AA7A0, (uint64_t)&v8, a4);
  *(void *)a1 = v6;
  if (*(int *)a4 <= 0)
  {
    uint64_t Memory = (unsigned int *)udata_getMemory((uint64_t)v6);
    sub_18C8AA81C((uint64_t)a1, (unsigned __int8 *)&v8, Memory, 0xFFFFFFFF, a4);
  }
}

void sub_18C8AAA58(_OWORD **a1)
{
  int v2 = *a1;
  if (v2)
  {
    udata_close(v2);
    *a1 = 0;
  }
}

uint64_t res_getPublicType(unsigned int a1)
{
  return byte_18CA864B8[(unint64_t)a1 >> 28];
}

const UChar *res_getStringNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 6)
  {
    int v4 = *(_DWORD *)(a1 + 48);
    BOOL v5 = (int)(a2 & 0xFFFFFFF) < v4;
    if ((int)(a2 & 0xFFFFFFF) < v4) {
      int v4 = 0;
    }
    uint64_t v6 = 16;
    if (v5) {
      uint64_t v6 = 40;
    }
    unsigned int v7 = (const UChar *)(*(void *)(a1 + v6) + 2 * ((a2 & 0xFFFFFFF) - v4));
    unsigned int v8 = *v7;
    if ((v8 & 0xFC00) == 0xDC00)
    {
      if (v8 > 0xDFEE)
      {
        if (v8 > 0xDFFE)
        {
          int v9 = v7[2] | (v7[1] << 16);
          v7 += 3;
          if (!a3) {
            return v7;
          }
        }
        else
        {
          int v9 = (v7[1] | (v8 << 16)) + 537985024;
          v7 += 2;
          if (!a3) {
            return v7;
          }
        }
      }
      else
      {
        int v9 = v8 & 0x3FF;
        ++v7;
        if (!a3) {
          return v7;
        }
      }
    }
    else
    {
      int v9 = u_strlen(v7);
      if (!a3) {
        return v7;
      }
    }
    goto LABEL_22;
  }
  if (a2 >> 28)
  {
    unsigned int v7 = 0;
    int v9 = 0;
    if (!a3) {
      return v7;
    }
    goto LABEL_22;
  }
  if (a2) {
    unsigned int v10 = (int *)(*(void *)(a1 + 8) + 4 * a2);
  }
  else {
    unsigned int v10 = &dword_18CA864C8;
  }
  int v11 = *v10;
  unsigned int v7 = (const UChar *)(v10 + 1);
  int v9 = v11;
  if (a3) {
LABEL_22:
  }
    *a3 = v9;
  return v7;
}

int *res_getAlias(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 3)
  {
    if ((a2 & 0xFFFFFFF) != 0) {
      BOOL v3 = (int *)(*(void *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
    }
    else {
      BOOL v3 = &dword_18CA864C8;
    }
    int v6 = *v3;
    uint64_t result = v3 + 1;
    int v5 = v6;
    if (a3) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t result = 0;
    int v5 = 0;
    if (a3) {
LABEL_8:
    }
      *a3 = v5;
  }
  return result;
}

int *res_getBinaryNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 1)
  {
    if ((a2 & 0xFFFFFFF) != 0) {
      BOOL v3 = (int *)(*(void *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
    }
    else {
      BOOL v3 = &dword_18CA864D0;
    }
    int v6 = *v3;
    uint64_t result = v3 + 1;
    int v5 = v6;
    if (a3) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t result = 0;
    int v5 = 0;
    if (a3) {
LABEL_8:
    }
      *a3 = v5;
  }
  return result;
}

int *res_getIntVectorNoTrace(uint64_t a1, unsigned int a2, int *a3)
{
  if (a2 >> 28 == 14)
  {
    if ((a2 & 0xFFFFFFF) != 0) {
      BOOL v3 = (int *)(*(void *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
    }
    else {
      BOOL v3 = &dword_18CA864D0;
    }
    int v6 = *v3;
    uint64_t result = v3 + 1;
    int v5 = v6;
    if (a3) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t result = 0;
    int v5 = 0;
    if (a3) {
LABEL_8:
    }
      *a3 = v5;
  }
  return result;
}

uint64_t res_countArrayItems(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = a2 & 0xFFFFFFF;
  uint64_t result = 1;
  switch(a2 >> 28)
  {
    case 0u:
    case 1u:
    case 3u:
    case 6u:
    case 7u:
    case 0xEu:
      return result;
    case 2u:
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t result = *(unsigned __int16 *)(*(void *)(a1 + 8) + 4 * (a2 & 0xFFFFFFF));
      break;
    case 4u:
    case 8u:
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t result = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v3);
      break;
    case 5u:
    case 9u:
      uint64_t result = *(unsigned __int16 *)(*(void *)(a1 + 16) + 2 * v3);
      break;
    default:
LABEL_7:
      uint64_t result = 0;
      break;
  }
  return result;
}

void sub_18C8AAD3C(icu::ResourceValue *a1)
{
  icu::ResourceValue::~ResourceValue(a1);

  icu::UMemory::operator delete(v1);
}

uint64_t sub_18C8AAD64(uint64_t a1)
{
  return byte_18CA864B8[(unint64_t)*(unsigned int *)(a1 + 24) >> 28];
}

const UChar *sub_18C8AAD7C(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  uint64_t result = res_getStringNoTrace(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), a2);
  if (!result) {
    *a3 = 17;
  }
  return result;
}

int *sub_18C8AADD0(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 3)
  {
    uint64_t v5 = v4 & 0xFFFFFFF;
    if (v5) {
      int v6 = (int *)(*(void *)(*(void *)(a1 + 8) + 8) + 4 * v5);
    }
    else {
      int v6 = &dword_18CA864C8;
    }
    int v7 = *v6;
    uint64_t result = v6 + 1;
    *a2 = v7;
  }
  else
  {
    uint64_t result = 0;
    *a2 = 0;
    *a3 = 17;
  }
  return result;
}

uint64_t sub_18C8AAE34(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (v3 >> 28 != 7) {
    *a2 = 17;
  }
  return ((int)(16 * v3) >> 4);
}

uint64_t sub_18C8AAE68(uint64_t a1, int *a2)
{
  if (*a2 > 0) {
    return 0;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (v3 >> 28 != 7) {
    *a2 = 17;
  }
  return v3 & 0xFFFFFFF;
}

int *sub_18C8AAE9C(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 14)
  {
    uint64_t v5 = v4 & 0xFFFFFFF;
    if (v5) {
      int v6 = (int *)(*(void *)(*(void *)(a1 + 8) + 8) + 4 * v5);
    }
    else {
      int v6 = &dword_18CA864D0;
    }
    int v7 = *v6;
    uint64_t result = v6 + 1;
    *a2 = v7;
  }
  else
  {
    uint64_t result = 0;
    *a2 = 0;
    *a3 = 17;
  }
  return result;
}

int *sub_18C8AAF00(uint64_t a1, int *a2, int *a3)
{
  if (*a3 > 0) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4 >> 28 == 1)
  {
    uint64_t v5 = v4 & 0xFFFFFFF;
    if (v5) {
      int v6 = (int *)(*(void *)(*(void *)(a1 + 8) + 8) + 4 * v5);
    }
    else {
      int v6 = &dword_18CA864D0;
    }
    int v7 = *v6;
    uint64_t result = v6 + 1;
    *a2 = v7;
  }
  else
  {
    uint64_t result = 0;
    *a2 = 0;
    *a3 = 17;
  }
  return result;
}

uint64_t sub_18C8AAF64@<X0>(uint64_t result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2 >= 1) {
    goto LABEL_2;
  }
  unsigned int v3 = *(_DWORD *)(result + 24);
  uint64_t v4 = v3 & 0xFFFFFFF;
  unsigned int v5 = v3 >> 28;
  if (v5 == 9)
  {
    unsigned int v8 = 0;
    unsigned int v10 = (unsigned __int16 *)(*(void *)(*(void *)(result + 8) + 16) + 2 * v4);
    int v11 = *v10;
    int v6 = v10 + 1;
    LODWORD(v4) = v11;
  }
  else
  {
    if (v5 != 8)
    {
      *a2 = 17;
LABEL_2:
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(_DWORD *)(a3 + 16) = 0;
      return result;
    }
    int v6 = 0;
    if (v4)
    {
      int v7 = (int *)(*(void *)(*(void *)(result + 8) + 8) + 4 * v4);
      int v9 = *v7;
      unsigned int v8 = v7 + 1;
      LODWORD(v4) = v9;
    }
    else
    {
      unsigned int v8 = 0;
    }
  }
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v8;
  *(_DWORD *)(a3 + 16) = v4;
  return result;
}

uint64_t sub_18C8AAFE8@<X0>(uint64_t result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2 >= 1)
  {
    *(_DWORD *)(a3 + 32) = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    return result;
  }
  unsigned int v3 = *(_DWORD *)(result + 24);
  uint64_t v4 = v3 & 0xFFFFFFF;
  unsigned int v5 = v3 >> 28;
  if (v5 == 5)
  {
    int v6 = 0;
    uint64_t v11 = 0;
    unsigned int v12 = (unsigned __int16 *)(*(void *)(*(void *)(result + 8) + 16) + 2 * v4);
    int v13 = *v12;
    int v9 = v12 + 1;
    LODWORD(v4) = v13;
    int v7 = &v9[v13];
    goto LABEL_13;
  }
  if (v5 == 4)
  {
    if (v4)
    {
      int v9 = 0;
      int v7 = 0;
      uint64_t v14 = (int *)(*(void *)(*(void *)(result + 8) + 8) + 4 * v4);
      uint64_t v15 = *v14;
      int v6 = v14 + 1;
      LODWORD(v4) = v15;
      uint64_t v11 = (uint64_t)&v6[v15];
      goto LABEL_13;
    }
LABEL_12:
    int v9 = 0;
    int v6 = 0;
    int v7 = 0;
    uint64_t v11 = 0;
    goto LABEL_13;
  }
  if (v5 != 2)
  {
    *a2 = 17;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)(a3 + 32) = 0;
    return result;
  }
  if (!v4) {
    goto LABEL_12;
  }
  int v6 = 0;
  int v7 = 0;
  unsigned int v8 = (unsigned __int16 *)(*(void *)(*(void *)(result + 8) + 8) + 4 * v4);
  int v10 = *v8;
  int v9 = v8 + 1;
  LODWORD(v4) = v10;
  uint64_t v11 = (uint64_t)&v9[v10 + ((v10 & 1) == 0)];
LABEL_13:
  *(void *)a3 = v9;
  *(void *)(a3 + 8) = v6;
  *(void *)(a3 + 16) = v7;
  *(void *)(a3 + 24) = v11;
  *(_DWORD *)(a3 + 32) = v4;
  return result;
}

BOOL sub_18C8AB0D4(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 24);
  int v2 = v1 & 0xFFFFFFF;
  if ((v1 & 0xFFFFFFF) == 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (!(v1 >> 28))
  {
    uint64_t v4 = *(void *)(v3 + 8) + 4 * v1;
    if (*(_DWORD *)v4 == 3)
    {
      int v5 = 8709;
      if (*(_WORD *)(v4 + 4) == 8709 && *(_WORD *)(v4 + 6) == 8709)
      {
        int v6 = (unsigned __int16 *)(v4 + 8);
        return *v6 == v5;
      }
    }
    return 0;
  }
  if (v1 >> 28 != 6) {
    return 0;
  }
  int v7 = *(_DWORD *)(v3 + 48);
  BOOL v8 = v2 < v7;
  if (v2 < v7) {
    int v7 = 0;
  }
  uint64_t v9 = 16;
  if (v8) {
    uint64_t v9 = 40;
  }
  int v10 = (unsigned __int16 *)(*(void *)(v3 + v9) + 2 * (v2 - v7));
  int v11 = *v10;
  if (v11 == 56323)
  {
    int v5 = 8709;
    if (v10[1] == 8709 && v10[2] == 8709) {
      goto LABEL_19;
    }
    return 0;
  }
  BOOL result = 0;
  if (v11 == 8709)
  {
    if (v10[1] == 8709 && v10[2] == 8709)
    {
      int v5 = 0;
LABEL_19:
      int v6 = v10 + 3;
      return *v6 == v5;
    }
    return 0;
  }
  return result;
}

uint64_t sub_18C8AB1C8(void *a1, icu::UnicodeString *a2, int a3, int *a4)
{
  uint64_t v7 = a1[1];
  (*(void (**)(void *__return_ptr))(*a1 + 80))(v9);
  return sub_18C8AB244(v7, (uint64_t)v9, a2, a3, a4);
}

uint64_t sub_18C8AB244(uint64_t a1, uint64_t a2, icu::UnicodeString *a3, int a4, int *a5)
{
  if (*a5 <= 0)
  {
    uint64_t v7 = a3;
    if (a3)
    {
      if ((a4 & 0x80000000) == 0)
      {
LABEL_5:
        uint64_t v5 = *(unsigned int *)(a2 + 16);
        if (!v5) {
          return v5;
        }
        if ((int)v5 <= a4)
        {
          if ((int)v5 < 1) {
            return v5;
          }
          uint64_t v12 = 0;
          while (1)
          {
            int v20 = 0;
            if (*(void *)a2)
            {
              int v13 = *(unsigned __int16 *)(*(void *)a2 + 2 * v12);
              int v14 = *(_DWORD *)(a1 + 52);
              BOOL v15 = __OFSUB__(v13, v14);
              int v16 = v13 - v14;
              if (v16 < 0 == v15) {
                int v13 = v16 + *(_DWORD *)(a1 + 48);
              }
              unsigned int v17 = v13 | 0x60000000;
            }
            else
            {
              unsigned int v17 = *(_DWORD *)(*(void *)(a2 + 8) + 4 * v12);
            }
            StringNoTrace = res_getStringNoTrace(a1, v17, &v20);
            if (!StringNoTrace) {
              break;
            }
            UErrorCode v19 = StringNoTrace;
            icu::UnicodeString::setTo(v7, 1, &v19, v20);
            ++v12;
            uint64_t v7 = (icu::UnicodeString *)((char *)v7 + 64);
            if (v5 == v12) {
              return v5;
            }
          }
          uint64_t v5 = 0;
          int v10 = 17;
        }
        else
        {
          int v10 = 15;
        }
LABEL_10:
        *a5 = v10;
        return v5;
      }
    }
    else if (!a4)
    {
      goto LABEL_5;
    }
    uint64_t v5 = 0;
    int v10 = 1;
    goto LABEL_10;
  }
  return 0;
}

uint64_t sub_18C8AB36C(uint64_t a1, icu::UnicodeString *a2, int a3, int *a4)
{
  unsigned int v7 = *(_DWORD *)(a1 + 24);
  if ((v7 & 0xFFFFFFFE) != 8)
  {
    if (*a4 > 0) {
      return 0;
    }
    if (a2)
    {
      if ((a3 & 0x80000000) == 0)
      {
        if (a3)
        {
          LODWORD(v14[0]) = 0;
          StringNoTrace = res_getStringNoTrace(*(void *)(a1 + 8), v7, (int *)v14);
          if (StringNoTrace)
          {
            int v13 = StringNoTrace;
            uint64_t v9 = 1;
            icu::UnicodeString::setTo(a2, 1, &v13, v14[0]);
            return v9;
          }
          uint64_t v9 = 0;
          int v11 = 17;
LABEL_12:
          *a4 = v11;
          return v9;
        }
LABEL_13:
        *a4 = 15;
        return 1;
      }
    }
    else if (!a3)
    {
      goto LABEL_13;
    }
    uint64_t v9 = 0;
    int v11 = 1;
    goto LABEL_12;
  }
  uint64_t v8 = *(void *)(a1 + 8);
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 80))(v14);
  return sub_18C8AB244(v8, (uint64_t)v14, a2, a3, a4);
}

icu::UnicodeString *sub_18C8AB490@<X0>(icu::UnicodeString *result@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 8) = 0u;
  *(void *)(a3 + 56) = 0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = &unk_1EDA47700;
  *(_WORD *)(a3 + 8) = 2;
  if (*a2 <= 0)
  {
    uint64_t v5 = result;
    int v18 = 0;
    StringNoTrace = res_getStringNoTrace(*((void *)result + 1), *((_DWORD *)result + 6), &v18);
    if (StringNoTrace)
    {
      unsigned int v17 = StringNoTrace;
      return icu::UnicodeString::setTo((icu::UnicodeString *)a3, 1, &v17, v18);
    }
    else
    {
      int v14 = 0;
      BOOL v15 = 0;
      uint64_t v16 = 0;
      BOOL result = (icu::UnicodeString *)(*(void *(**)(unsigned __int16 **__return_ptr, icu::UnicodeString *, int *))(*(void *)v5 + 80))(&v14, v5, a2);
      if (*a2 <= 0)
      {
        if ((int)v16 < 1) {
          goto LABEL_13;
        }
        uint64_t v7 = *((void *)v5 + 1);
        if (v14)
        {
          int v8 = *v14;
          int v9 = *(_DWORD *)(v7 + 52);
          BOOL v10 = __OFSUB__(v8, v9);
          int v11 = v8 - v9;
          if (v11 < 0 == v10) {
            int v8 = v11 + *(_DWORD *)(v7 + 48);
          }
          unsigned int v12 = v8 | 0x60000000;
        }
        else
        {
          unsigned int v12 = *v15;
        }
        BOOL result = (icu::UnicodeString *)res_getStringNoTrace(v7, v12, &v18);
        if (result)
        {
          int v13 = (const UChar *)result;
          return icu::UnicodeString::setTo((icu::UnicodeString *)a3, 1, &v13, v18);
        }
        else
        {
LABEL_13:
          *a2 = 17;
        }
      }
    }
  }
  return result;
}

uint64_t icu::ResourceArray::internalGetResource(void *a1, uint64_t a2, int a3)
{
  if (!*a1) {
    return *(unsigned int *)(a1[1] + 4 * a3);
  }
  int v3 = *(unsigned __int16 *)(*a1 + 2 * a3);
  int v4 = *(_DWORD *)(a2 + 52);
  BOOL v5 = __OFSUB__(v3, v4);
  int v6 = v3 - v4;
  if (v6 < 0 == v5) {
    int v3 = v6 + *(_DWORD *)(a2 + 48);
  }
  return v3 | 0x60000000u;
}

uint64_t res_getTableItemByKey(uint64_t a1, unsigned int a2, unsigned int *a3, const char **a4)
{
  if (!a4) {
    return 0xFFFFFFFFLL;
  }
  BOOL v5 = (char *)*a4;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = a2 & 0xFFFFFFF;
  unsigned int v9 = a2 >> 28;
  if (a2 >> 28 != 5)
  {
    if (v9 == 4)
    {
      if (v8)
      {
        long long v25 = (int *)(*(void *)(a1 + 8) + 4 * v8);
        int v28 = *v25;
        uint64_t v26 = (uint64_t)(v25 + 1);
        int v27 = v28;
        unsigned int v29 = sub_18C8AB830(a1, v26, v28, v5, a4);
        *a3 = v29;
        if ((v29 & 0x80000000) == 0) {
          return *(unsigned int *)(v26 + 4 * (int)(v29 + v27));
        }
      }
    }
    else if (v9 == 2)
    {
      if (v8)
      {
        BOOL v10 = (unsigned __int16 *)(*(void *)(a1 + 8) + 4 * v8);
        int v13 = *v10;
        uint64_t v12 = (uint64_t)(v10 + 1);
        unsigned int v11 = v13;
        unsigned int v14 = sub_18C8AB768(a1, v12, v13, v5, a4);
        *a3 = v14;
        if ((v14 & 0x80000000) == 0) {
          return *(unsigned int *)(v12 + 2 * v11 + 2 * ((v11 & 1) == 0) + 4 * v14);
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v16 = (unsigned __int16 *)(*(void *)(a1 + 16) + 2 * v8);
  int v19 = *v16;
  uint64_t v17 = (uint64_t)(v16 + 1);
  int v18 = v19;
  unsigned int v20 = sub_18C8AB768(a1, v17, v19, v5, a4);
  *a3 = v20;
  if ((v20 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  int v21 = *(unsigned __int16 *)(v17 + 2 * (v20 + v18));
  int v22 = *(_DWORD *)(a1 + 52);
  BOOL v23 = __OFSUB__(v21, v22);
  int v24 = v21 - v22;
  if (v24 < 0 == v23) {
    int v21 = v24 + *(_DWORD *)(a1 + 48);
  }
  return v21 | 0x60000000u;
}

uint64_t sub_18C8AB768(uint64_t a1, uint64_t a2, int a3, char *__s1, void *a5)
{
  if (a3 >= 1)
  {
    int v7 = a3;
    int v10 = 0;
    uint64_t v11 = *(int *)(a1 + 36);
    do
    {
      int v12 = v7 + v10;
      if (v7 + v10 < 0 != __OFADD__(v7, v10)) {
        ++v12;
      }
      uint64_t v13 = (v12 >> 1);
      uint64_t v14 = *(unsigned __int16 *)(a2 + 2 * (int)v13);
      if ((int)v11 <= (int)v14) {
        uint64_t v15 = *(void *)(a1 + 24) - v11;
      }
      else {
        uint64_t v15 = *(void *)(a1 + 8);
      }
      uint64_t v16 = v15 + v14;
      int v17 = strcmp(__s1, (const char *)(v15 + v14));
      if (v17 < 0)
      {
        int v7 = v13;
      }
      else
      {
        if (!v17)
        {
          *a5 = v16;
          return v13;
        }
        int v10 = v13 + 1;
      }
    }
    while (v10 < v7);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_18C8AB830(uint64_t a1, uint64_t a2, int a3, char *__s1, const char **a5)
{
  if (a3 >= 1)
  {
    int v7 = a3;
    int v10 = 0;
    do
    {
      int v11 = v7 + v10;
      if (v7 + v10 < 0 != __OFADD__(v7, v10)) {
        ++v11;
      }
      uint64_t v12 = (v11 >> 1);
      int v13 = *(_DWORD *)(a2 + 4 * (int)v12);
      uint64_t v14 = v13 & 0x7FFFFFFF;
      if (v13 >= 0) {
        uint64_t v15 = 8;
      }
      else {
        uint64_t v15 = 24;
      }
      uint64_t v16 = (const char *)(*(void *)(a1 + v15) + v14);
      int v17 = strcmp(__s1, v16);
      if (v17 < 0)
      {
        int v7 = v12;
      }
      else
      {
        if (!v17)
        {
          *a5 = v16;
          return v12;
        }
        int v10 = v12 + 1;
      }
    }
    while (v10 < v7);
  }
  return 0xFFFFFFFFLL;
}

uint64_t res_getTableItemByIndex(uint64_t a1, unsigned int a2, unsigned int a3, void *a4)
{
  if ((a3 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = a2 & 0xFFFFFFF;
  unsigned int v5 = a2 >> 28;
  if (a2 >> 28 == 5)
  {
    uint64_t v15 = (unsigned __int16 *)(*(void *)(a1 + 16) + 2 * v4);
    unsigned int v18 = *v15;
    uint64_t v16 = v15 + 1;
    unsigned int v17 = v18;
    if (v18 <= a3) {
      return 0xFFFFFFFFLL;
    }
    if (a4)
    {
      uint64_t v19 = v16[a3];
      uint64_t v20 = *(int *)(a1 + 36);
      if ((int)v20 <= (int)v19) {
        uint64_t v21 = *(void *)(a1 + 24) + v19 - v20;
      }
      else {
        uint64_t v21 = *(void *)(a1 + 8) + v19;
      }
      *a4 = v21;
    }
    int v29 = v16[v17 + a3];
    int v30 = *(_DWORD *)(a1 + 52);
    BOOL v31 = __OFSUB__(v29, v30);
    int v32 = v29 - v30;
    if (v32 < 0 == v31) {
      int v29 = v32 + *(_DWORD *)(a1 + 48);
    }
    return v29 | 0x60000000u;
  }
  else
  {
    if (v5 != 4)
    {
      if (v5 == 2)
      {
        if (v4)
        {
          uint64_t v6 = *(void *)(a1 + 8);
          int v7 = (unsigned __int16 *)(v6 + 4 * v4);
          unsigned int v10 = *v7;
          unsigned int v9 = v7 + 1;
          unsigned int v8 = v10;
          if (v10 > a3)
          {
            uint64_t v11 = (uint64_t)&v9[v8 + ((v8 & 1) == 0)];
            if (a4)
            {
              uint64_t v12 = v9[a3];
              uint64_t v13 = *(int *)(a1 + 36);
              if ((int)v13 <= (int)v12) {
                uint64_t v14 = *(void *)(a1 + 24) + v12 - v13;
              }
              else {
                uint64_t v14 = v6 + v12;
              }
              *a4 = v14;
            }
            return *(unsigned int *)(v11 + 4 * a3);
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v22 = *(void *)(a1 + 8);
    BOOL v23 = (int *)(v22 + 4 * v4);
    int v26 = *v23;
    int v24 = v23 + 1;
    int v25 = v26;
    if (v26 <= (int)a3) {
      return 0xFFFFFFFFLL;
    }
    if (a4)
    {
      unsigned int v27 = v24[a3];
      if ((v27 & 0x80000000) != 0)
      {
        uint64_t v22 = *(void *)(a1 + 24);
        v27 &= ~0x80000000;
      }
      *a4 = v22 + v27;
    }
    return v24[v25 + a3];
  }
}

uint64_t res_getResource(uint64_t a1, const char *a2)
{
  unsigned int v4 = a2;
  return res_getTableItemByKey(a1, *(_DWORD *)(a1 + 32), &v3, &v4);
}

uint64_t icu::ResourceTable::getKeyAndValue(icu::ResourceTable *this, unsigned int a2, const char **a3, icu::ResourceValue *a4)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 8) <= (signed int)a2) {
    return 0;
  }
  if (!*(void *)this)
  {
    uint64_t v4 = *(unsigned int *)(*((void *)this + 1) + 4 * a2);
    uint64_t v5 = *((void *)a4 + 1);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v9 = *(void *)(v5 + 24);
      v4 &= 0x7FFFFFFFu;
      goto LABEL_10;
    }
LABEL_8:
    uint64_t v9 = *(void *)(v5 + 8);
LABEL_10:
    int v7 = (const char *)(v9 + v4);
    goto LABEL_11;
  }
  uint64_t v4 = *(unsigned __int16 *)(*(void *)this + 2 * a2);
  uint64_t v5 = *((void *)a4 + 1);
  uint64_t v6 = *(int *)(v5 + 36);
  if ((int)v6 > (int)v4) {
    goto LABEL_8;
  }
  int v7 = (const char *)(*(void *)(v5 + 24) + v4 - v6);
LABEL_11:
  *a3 = v7;
  uint64_t v10 = *((void *)this + 2);
  if (v10)
  {
    uint64_t v11 = *((void *)a4 + 1);
    int v12 = *(unsigned __int16 *)(v10 + 2 * a2);
    int v13 = *(_DWORD *)(v11 + 52);
    BOOL v14 = __OFSUB__(v12, v13);
    int v15 = v12 - v13;
    if (v15 < 0 == v14) {
      int v12 = v15 + *(_DWORD *)(v11 + 48);
    }
    int v16 = v12 | 0x60000000;
  }
  else
  {
    int v16 = *(_DWORD *)(*((void *)this + 3) + 4 * a2);
  }
  *((_DWORD *)a4 + 6) = v16;
  return 1;
}

uint64_t icu::ResourceTable::findValue(icu::ResourceTable *this, char *__s1, icu::ResourceValue *a3)
{
  uint64_t v5 = *((void *)a3 + 1);
  if (!*(void *)this)
  {
    unsigned int v6 = sub_18C8AB830(v5, *((void *)this + 1), *((_DWORD *)this + 8), __s1, &v14);
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_3;
    }
    return 0;
  }
  unsigned int v6 = sub_18C8AB768(v5, *(void *)this, *((_DWORD *)this + 8), __s1, &v14);
  if ((v6 & 0x80000000) != 0) {
    return 0;
  }
LABEL_3:
  uint64_t v7 = *((void *)this + 2);
  if (v7)
  {
    int v8 = *(unsigned __int16 *)(v7 + 2 * v6);
    int v9 = *(_DWORD *)(v5 + 52);
    BOOL v10 = __OFSUB__(v8, v9);
    int v11 = v8 - v9;
    if (v11 < 0 == v10) {
      int v8 = v11 + *(_DWORD *)(v5 + 48);
    }
    int v12 = v8 | 0x60000000;
  }
  else
  {
    int v12 = *(_DWORD *)(*((void *)this + 3) + 4 * v6);
  }
  *((_DWORD *)a3 + 6) = v12;
  return 1;
}

uint64_t res_getArrayItem(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a3 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = a2 & 0xFFFFFFF;
  if (a2 >> 28 != 9)
  {
    if (a2 >> 28 == 8)
    {
      if (v3)
      {
        uint64_t v4 = (_DWORD *)(*(void *)(a1 + 8) + 4 * v3);
        if (*v4 > (signed int)a3) {
          return v4[a3 + 1];
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v6 = (unsigned __int16 *)(*(void *)(a1 + 16) + 2 * v3);
  if (*v6 <= a3) {
    return 0xFFFFFFFFLL;
  }
  int v7 = v6[a3 + 1];
  int v8 = *(_DWORD *)(a1 + 52);
  BOOL v9 = __OFSUB__(v7, v8);
  int v10 = v7 - v8;
  if (v10 < 0 == v9) {
    int v7 = v10 + *(_DWORD *)(a1 + 48);
  }
  return v7 | 0x60000000u;
}

uint64_t icu::ResourceArray::getValue(icu::ResourceArray *this, unsigned int a2, icu::ResourceValue *a3)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 4) <= (signed int)a2) {
    return 0;
  }
  if (*(void *)this)
  {
    uint64_t v3 = *((void *)a3 + 1);
    int v4 = *(unsigned __int16 *)(*(void *)this + 2 * a2);
    int v5 = *(_DWORD *)(v3 + 52);
    BOOL v6 = __OFSUB__(v4, v5);
    int v7 = v4 - v5;
    if (v7 < 0 == v6) {
      int v4 = v7 + *(_DWORD *)(v3 + 48);
    }
    int v8 = v4 | 0x60000000;
  }
  else
  {
    int v8 = *(_DWORD *)(*((void *)this + 1) + 4 * a2);
  }
  *((_DWORD *)a3 + 6) = v8;
  return 1;
}

uint64_t sub_18C8ABC8C(uint64_t a1, uint64_t a2, char **a3, const char **a4)
{
  uint64_t TableItemByKey = a2;
  int v5 = *a3;
  __endptr = 0;
  if (*v5)
  {
    unsigned int v9 = a2 >> 28;
    if (a2 >> 28 == 2 || (a2 & 0xE0000000) == 0x40000000 || (a2 & 0xE0000000) == 0x80000000)
    {
      do
      {
        if (*v5) {
          BOOL v10 = TableItemByKey == -1;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10) {
          break;
        }
        int v11 = v9 & 0xE;
        BOOL v12 = v11 == 4 || v9 == 2;
        if (v9 != 2 && v11 != 8 && v11 != 4) {
          break;
        }
        int v13 = strchr(v5, 47);
        BOOL v14 = v13;
        if (v13)
        {
          if (v13 == v5) {
            return 0xFFFFFFFFLL;
          }
          *int v13 = 0;
          int v15 = v13 + 1;
        }
        else
        {
          int v15 = &v5[strlen(v5)];
        }
        *a3 = v15;
        if (v12)
        {
          *a4 = v5;
          uint64_t TableItemByKey = res_getTableItemByKey(a1, TableItemByKey, &v18, a4);
        }
        else if (v11 == 8)
        {
          unsigned int v16 = strtol(v5, &__endptr, 10);
          if ((v16 & 0x80000000) != 0 || *__endptr) {
            uint64_t TableItemByKey = 0xFFFFFFFFLL;
          }
          else {
            uint64_t TableItemByKey = res_getArrayItem(a1, TableItemByKey, v16);
          }
          *a4 = 0;
        }
        else
        {
          uint64_t TableItemByKey = 0xFFFFFFFFLL;
        }
        unsigned int v9 = TableItemByKey >> 28;
        int v5 = *a3;
      }
      while (v14);
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return TableItemByKey;
}

uint64_t ures_swap(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3;
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  int v13 = udata_swapDataHeader(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0;
  }
  uint64_t v21 = *((unsigned __int8 *)a2 + 12);
  if (__PAIR64__(*((unsigned __int8 *)a2 + 13), v21) != 0x6500000052
    || *((unsigned char *)a2 + 14) != 115
    || *((unsigned char *)a2 + 15) != 66)
  {
    goto LABEL_13;
  }
  int v22 = v13;
  unsigned int v23 = *((unsigned __int8 *)a2 + 16);
  if (v23 == 1)
  {
    if (*((unsigned char *)a2 + 17)) {
      goto LABEL_9;
    }
LABEL_13:
    udata_printError(a1, (uint64_t)"ures_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not a resource bundle\n", v14, v15, v16, v17, v18, v19, v21);
    uint64_t result = 0;
    int v24 = 16;
LABEL_14:
    *a5 = v24;
    return result;
  }
  if ((v23 & 0xFE) != 2) {
    goto LABEL_13;
  }
LABEL_9:
  uint64_t v88 = 0;
  long long v86 = 0u;
  long long v87 = 0u;
  BYTE4(v88) = v23;
  if (v10 < 0)
  {
    signed int v25 = -1;
  }
  else
  {
    if (v10 - v13 <= 23)
    {
      udata_printError(a1, (uint64_t)"ures_swap(): too few bytes (%d after header) for a resource bundle\n", v14, v15, v16, v17, v18, v19, (v10 - v13));
LABEL_25:
      uint64_t result = 0;
      int v24 = 8;
      goto LABEL_14;
    }
    signed int v25 = (v10 - v13) >> 2;
  }
  int v26 = (unsigned int *)((char *)a2 + v13);
  uint64_t v85 = (*(uint64_t (**)(void))(a1 + 16))(*v26);
  unsigned int Int32 = udata_readInt32(a1, v26[1]);
  if (Int32 <= 4)
  {
    long long v34 = "ures_swap(): too few indexes for a 1.1+ resource bundle\n";
LABEL_24:
    udata_printError(a1, (uint64_t)v34, v27, v28, v29, v30, v31, v32, v78);
    goto LABEL_25;
  }
  signed int v35 = udata_readInt32(a1, v26[2]);
  signed int v84 = v35;
  if (Int32 >= 7) {
    signed int v35 = udata_readInt32(a1, v26[7]);
  }
  int v82 = v35;
  uint64_t v36 = udata_readInt32(a1, v26[4]);
  __src = (unsigned int *)((char *)a2 + v22);
  uint64_t v37 = udata_readInt32(a1, __src[5]);
  if ((v25 & 0x80000000) == 0 && v25 < (int)v36)
  {
    uint64_t v78 = v36;
    long long v34 = "ures_swap(): resource top %d exceeds bundle length %d\n";
    goto LABEL_24;
  }
  unsigned int v38 = Int32 + 1;
  int v39 = 4 * v84;
  if (v84 <= (int)v38) {
    int v39 = 0;
  }
  LODWORD(v88) = v39;
  if ((v10 & 0x80000000) == 0)
  {
    unsigned int v81 = v84 - v38;
    uint64_t v80 = v37;
    bzero(v89, 0x320uLL);
    unsigned int v40 = ((v10 + 31) >> 5) + 3;
    size_t v41 = v40 & 0xFFFFFFC;
    if (v41 > 0x320)
    {
      long long v42 = uprv_malloc(v40 & 0xFFFFFFC);
      *((void *)&v87 + sub_18C8A49A0((uint64_t)this, 1) = v42;
      if (!v42)
      {
        udata_printError(a1, (uint64_t)"ures_swap(): unable to allocate memory for tracking resources\n", v43, v44, v45, v46, v47, v48, v78);
        *a5 = 7;
        return 0;
      }
    }
    else
    {
      *((void *)&v87 + sub_18C8A49A0((uint64_t)this, 1) = v89;
      long long v42 = v89;
    }
    uint64_t v79 = v42;
    bzero(v42, v41);
    BOOL v49 = a2 == a4;
    UErrorCode v50 = (char *)a4 + v22;
    if (!v49) {
      memcpy(v50, __src, 4 * (int)v36);
    }
    bzero(v91, 0x640uLL);
    bzero(v90, 0x320uLL);
    udata_swapInvStringBlock(a1, (uint64_t)&__src[v38], 4 * v81, (uint64_t)&v50[4 * v38], a5);
    if (*a5 >= 1)
    {
      udata_printError(a1, (uint64_t)"ures_swap().udata_swapInvStringBlock(keys[%d]) failed\n", v51, v52, v53, v54, v55, v56, 4 * v81);
      return 0;
    }
    int v57 = v82 - v84;
    if (v82 > v84)
    {
      (*(void (**)(uint64_t, unsigned int *, void, char *, int *))(a1 + 48))(a1, &__src[v84], (4 * v57), &v50[4 * v84], a5);
      if (*a5 >= 1)
      {
        udata_printError(a1, (uint64_t)"ures_swap().swapArray16(16-bit units[%d]) failed\n", v58, v59, v60, v61, v62, v63, (2 * v57));
        return 0;
      }
    }
    *(void *)&long long v86 = v50;
    if (v23 > 1 || (int)v80 <= 200)
    {
      *((void *)&v86 + sub_18C8A49A0((uint64_t)this, 1) = v91;
      uint64_t v71 = v90;
    }
    else
    {
      long long v64 = (char *)uprv_malloc(8 * v80 + 4 * (int)v80);
      *((void *)&v86 + sub_18C8A49A0((uint64_t)this, 1) = v64;
      if (!v64)
      {
        udata_printError(a1, (uint64_t)"ures_swap(): unable to allocate memory for sorting tables (max length: %d)\n", v65, v66, v67, v68, v69, v70, v80);
        *a5 = 7;
        if (v79 != v89) {
          uprv_free(v79);
        }
        return 0;
      }
      uint64_t v71 = &v64[8 * v80];
    }
    *(void *)&long long v87 = v71;
    sub_18C8AC2B0(a1, (uint64_t)__src, (uint64_t)v50, v85, 0, (uint64_t)&v86, a5);
    if (*a5 >= 1) {
      udata_printError(a1, (uint64_t)"ures_swapResource(root res=%08x) failed\n", v72, v73, v74, v75, v76, v77, v85);
    }
    if (*((unsigned char **)&v86 + 1) != v91) {
      uprv_free(*((void **)&v86 + 1));
    }
    if (*((unsigned char **)&v87 + 1) != v89) {
      uprv_free(*((void **)&v87 + 1));
    }
    (*(void (**)(uint64_t, unsigned int *, void, char *, int *))(a1 + 56))(a1, __src, 4 * v38, v50, a5);
  }
  return (v22 + 4 * v36);
}

uint64_t sub_18C8AC2B0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, int *a7)
{
  BOOL v7 = a4 >> 28 > 9 || ((1 << (a4 >> 28)) & 0x2E0) == 0;
  unsigned int v8 = a4 & 0xFFFFFFF;
  if (v7 && v8 != 0)
  {
    uint64_t v12 = *(void *)(a6 + 24);
    uint64_t v13 = v8 >> 5;
    int v14 = *(_DWORD *)(v12 + 4 * v13);
    if ((v14 & (1 << a4)) == 0)
    {
      *(_DWORD *)(v12 + 4 * v13) = v14 | (1 << a4);
      uint64_t v18 = result;
      uint64_t v19 = (unsigned int *)(a2 + 4 * v8);
      uint64_t v20 = (unsigned int *)(a3 + 4 * v8);
      switch(a4 >> 28)
      {
        case 0u:
        case 3u:
          int Int32 = udata_readInt32(result, *v19);
          (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))(v18, v19, 4, v20, a7);
          int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 48);
          uint64_t v23 = (2 * Int32);
          int v24 = v20 + 1;
          uint64_t v25 = v18;
          int v26 = v19 + 1;
          goto LABEL_40;
        case 1u:
          uint64_t v28 = udata_readInt32(result, *v19);
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))(v18, v19, 4, v20, a7);
          if (a5)
          {
            uint64_t result = a5 == ""
                   ? ucol_looksLikeCollationBinary((unsigned __int8 *)v18, (unsigned __int16 *)v19 + 2, v28, v29, v30, v31, v32, v33): (*(unsigned int (**)(uint64_t, char *, uint64_t, const __int16 *, uint64_t))(v18 + 24))(v18, a5, 0xFFFFFFFFLL, L"%%CollationBin", 14) == 0;
            if (result)
            {
              return ucol_swap((unsigned __int8 *)v18, (uint64_t)(v19 + 1), v28, (unsigned __int16 *)v20 + 2, a7, v34, v35, v36);
            }
          }
          return result;
        case 2u:
          __srcb = (char *)(a3 + 4 * v8);
          uint64_t v37 = (*(uint64_t (**)(void))(result + 8))(*(unsigned __int16 *)v19);
          size_t v93 = __srcb + 2;
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v18 + 48))(v18, v19, 2);
          unsigned int v38 = (char *)v19 + 2;
          int v39 = 0;
          __int16 __dst = 0;
          unsigned int v40 = (v37 + 2) >> 1;
          goto LABEL_18;
        case 4u:
          __srcc = (char *)(a3 + 4 * v8);
          int v39 = v19 + 1;
          uint64_t v37 = udata_readInt32(result, *v19);
          __int16 __dst = (unsigned int *)(__srcc + 4);
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v18 + 56))(v18, v19, 4);
          unsigned int v38 = 0;
          size_t v93 = 0;
          unsigned int v40 = v37 + 1;
LABEL_18:
          if (!v37) {
            return result;
          }
          uint64_t v94 = v37;
          uint64_t v95 = v39;
          unsigned int v91 = v40 + v8;
          size_t v41 = (unsigned int *)(a2 + 4 * (int)(v40 + v8));
          __src = v38;
          if ((int)v37 < 1) {
            goto LABEL_29;
          }
          uint64_t v42 = 0;
          do
          {
            if (v38)
            {
              signed int v43 = (*(uint64_t (**)(void))(v18 + 8))(*(unsigned __int16 *)&v38[2 * v42]);
              BOOL v44 = *(_DWORD *)(a6 + 32) > v43;
            }
            else
            {
              signed int v43 = udata_readInt32(v18, v95[v42]);
              BOOL v44 = v43 >= 0;
            }
            if (v44) {
              uint64_t v45 = (const char *)(a3 + v43);
            }
            else {
              uint64_t v45 = "";
            }
            uint64_t v46 = v41;
            uint64_t v47 = (*(uint64_t (**)(void))(v18 + 16))(v41[v42]);
            sub_18C8AC2B0(v18, a2, a3, v47, v45, a6, a7);
            if (*a7 >= 1) {
              return udata_printError(v18, (uint64_t)"ures_swapResource(table res=%08x)[%d].recurse(%08x) failed\n", v48, v49, v50, v51, v52, v53, a4);
            }
            ++v42;
            unsigned int v38 = __src;
            size_t v41 = v46;
          }
          while (v94 != v42);
LABEL_29:
          if (*(unsigned __int8 *)(a6 + 36) > 1u || *(unsigned __int8 *)(v18 + 1) == *(unsigned __int8 *)(v18 + 3))
          {
            if (v38)
            {
              (*(void (**)(uint64_t, char *, void, char *, int *))(v18 + 48))(v18, v38, (2 * v94), v93, a7);
              int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
              uint64_t v23 = (4 * v94);
              uint64_t v25 = v18;
              int v26 = v41;
              int v24 = (unsigned int *)(a3 + 4 * (int)v91);
            }
            else
            {
              int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
              uint64_t v23 = (8 * v94);
              uint64_t v25 = v18;
              int v26 = v95;
              int v24 = __dst;
            }
            goto LABEL_40;
          }
          uint64_t v97 = (char *)(a3 + 4 * (int)v91);
          uint64_t v65 = v41;
          if (v38)
          {
            if ((int)v94 >= 1)
            {
              uint64_t v66 = 0;
              int v67 = 0;
              do
              {
                int v68 = (*(uint64_t (**)(void))(v18 + 8))(*(unsigned __int16 *)&__src[v66]);
                uint64_t v69 = (_DWORD *)(*(void *)(a6 + 8) + 4 * v66);
                *uint64_t v69 = v68;
                v69[1] = v67++;
                v66 += 2;
              }
              while (2 * v94 != v66);
            }
          }
          else if ((int)v94 >= 1)
          {
            uint64_t v70 = 0;
            uint64_t v71 = 4;
            do
            {
              int v72 = udata_readInt32(v18, v95[v70]);
              uint64_t v73 = (_DWORD *)(*(void *)(a6 + 8) + v71);
              *(v73 - sub_18C8A49A0((uint64_t)this, 1) = v72;
              *uint64_t v73 = v70++;
              v71 += 8;
            }
            while (v94 != v70);
          }
          uprv_sortArray(*(void *)(a6 + 8), v94, 8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_18C8ACAA0, *(void *)a6, 0, a7);
          if (*a7 >= 1) {
            return udata_printError(v18, (uint64_t)"ures_swapResource(table res=%08x).uprv_sortArray(%d items) failed\n", v74, v75, v76, v77, v78, v79, a4);
          }
          if (__src)
          {
            uint64_t v80 = v93;
            if (__src == v93) {
              uint64_t v80 = *(char **)(a6 + 16);
            }
            if ((int)v94 >= 1)
            {
              uint64_t v81 = 0;
              do
              {
                (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(v18 + 48))(v18, &__src[2 * *(int *)(*(void *)(a6 + 8) + 4 * v81 + 4)], 2, &v80[v81], a7);
                v81 += 2;
              }
              while (2 * v94 != v81);
            }
            int v82 = v94;
            if (v93 != v80)
            {
              size_t v83 = 2 * (int)v94;
              signed int v84 = v93;
              uint64_t v85 = v80;
LABEL_76:
              memcpy(v84, v85, v83);
            }
          }
          else
          {
            __srca = __dst;
            if (v95 == __dst) {
              __srca = *(unsigned int **)(a6 + 16);
            }
            if ((int)v94 >= 1)
            {
              uint64_t v86 = 0;
              long long v87 = (char *)__srca;
              do
              {
                (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(v18 + 56))(v18, &v95[*(int *)(*(void *)(a6 + 8) + v86 + 4)], 4, v87, a7);
                v87 += 4;
                v86 += 8;
              }
              while (8 * v94 != v86);
            }
            signed int v84 = (char *)__dst;
            uint64_t v85 = __srca;
            int v82 = v94;
            if (__dst != __srca)
            {
              size_t v83 = 4 * (int)v94;
              goto LABEL_76;
            }
          }
          uint64_t v88 = (char *)(a3 + 4 * (int)v91);
          if (a2 == a3) {
            uint64_t v88 = *(char **)(a6 + 16);
          }
          if (v82 >= 1)
          {
            uint64_t v89 = 0;
            long long v90 = v88;
            do
            {
              (*(void (**)(uint64_t, unsigned int *, uint64_t, char *, int *))(v18 + 56))(v18, &v65[*(int *)(*(void *)(a6 + 8) + v89 + 4)], 4, v90, a7);
              v90 += 4;
              v89 += 8;
            }
            while (8 * v82 != v89);
          }
          uint64_t result = (uint64_t)v97;
          if (v97 != v88)
          {
            uint64_t result = (uint64_t)memcpy(v97, v88, 4 * v82);
          }
          break;
        case 8u:
          uint64_t v54 = v19 + 1;
          int v55 = udata_readInt32(result, *v19);
          (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56))(v18, v19, 4, v20, a7);
          int v96 = v55;
          if (v55 < 1) {
            goto LABEL_38;
          }
          uint64_t v56 = 0;
          do
          {
            uint64_t v57 = (*(uint64_t (**)(void))(v18 + 16))(v54[v56]);
            sub_18C8AC2B0(v18, a2, a3, v57, 0, a6, a7);
            if (*a7 >= 1) {
              return udata_printError(v18, (uint64_t)"ures_swapResource(array res=%08x)[%d].recurse(%08x) failed\n", v58, v59, v60, v61, v62, v63, a4);
            }
            ++v56;
          }
          while (v96 != v56);
LABEL_38:
          int v24 = v20 + 1;
          int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
          uint64_t v23 = (4 * v96);
          uint64_t v25 = v18;
          int v26 = v54;
LABEL_40:
          return v22(v25, v26, v23, v24, a7);
        case 0xEu:
          int v64 = udata_readInt32(result, *v19);
          int v22 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(v18 + 56);
          uint64_t v23 = (4 * v64 + 4);
          uint64_t v25 = v18;
          int v26 = v19;
          int v24 = v20;
          goto LABEL_40;
        default:
          *a7 = 16;
          return result;
      }
    }
  }
  return result;
}

uint64_t sub_18C8ACAA0(uint64_t a1, int *a2, int *a3)
{
  return strcmp((const char *)(a1 + *a2), (const char *)(a1 + *a3));
}

void *uscript_openRun(uint64_t a1, int a2, int *a3)
{
  if (!a3) {
    return 0;
  }
  if (*a3 <= 0)
  {
    uint64_t result = uprv_malloc(0x128uLL);
    if (!result)
    {
      *a3 = 7;
      return result;
    }
    if (*a3 <= 0)
    {
      if ((a2 & 0x80000000) == 0 && (a1 != 0) != (a2 == 0))
      {
        result[1] = a1;
        *(_DWORD *)uint64_t result = a2;
        result[2] = 0;
        *((_DWORD *)result + 6) = -1;
        *((_DWORD *)result + 7sub_18C8A49A0((uint64_t)this, 1) = -1;
        result[36] = 0;
        return result;
      }
      *a3 = 1;
    }
    uprv_free(result);
  }
  return 0;
}

uint64_t uscript_setRunText(uint64_t result, uint64_t a2, int a3, int *a4)
{
  if (a4 && *a4 <= 0)
  {
    if (result && (a3 & 0x80000000) == 0 && (a2 != 0) != (a3 == 0))
    {
      *(void *)(result + 8) = a2;
      *(_DWORD *)uint64_t result = a3;
      *(void *)(result + 16) = 0;
      *(_DWORD *)(result + 24) = -1;
      *(_DWORD *)(result + 284) = -1;
      *(void *)(result + 288) = 0;
    }
    else
    {
      *a4 = 1;
    }
  }
  return result;
}

void uscript_closeRun(void *a1)
{
  if (a1) {
    uprv_free(a1);
  }
}

double uscript_resetRun(uint64_t a1)
{
  if (a1)
  {
    double result = 0.0;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = -1;
    *(_DWORD *)(a1 + 284) = -1;
    *(void *)(a1 + 288) = 0;
  }
  return result;
}

uint64_t uscript_nextRun(uint64_t result, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v58 = 0;
  if (result)
  {
    uint64_t v4 = result;
    int v5 = *(_DWORD *)(result + 20);
    int v6 = *(_DWORD *)result;
    if (v5 >= *(_DWORD *)result)
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(result + 292) = 0;
      *(_DWORD *)(result + 24) = 0;
      *(_DWORD *)(result + 16) = v5;
      while (1)
      {
        uint64_t v10 = *(void *)(v4 + 8);
        signed int v11 = *(unsigned __int16 *)(v10 + 2 * v5);
        int v12 = v6 - 1;
        BOOL v13 = (v11 & 0xFC00) == 0xD800 && v5 < v12;
        if (v13)
        {
          uint64_t v14 = v5 + 1;
          int v15 = *(unsigned __int16 *)(v10 + 2 * v14);
          if ((v15 & 0xFC00) == 0xDC00)
          {
            signed int v11 = v15 + (v11 << 10) - 56613888;
            *(_DWORD *)(v4 + 20) = v14;
          }
        }
        int Script = uscript_getScript(v11, &v58);
        int v17 = 2 * (v11 > 59);
        unsigned int v18 = 32;
        do
        {
          if (*(_DWORD *)&asc_18CA86514[2 * (v17 + (v18 >> 1))] <= v11) {
            v17 += v18 >> 1;
          }
          BOOL v13 = v18 > 3;
          v18 >>= 1;
        }
        while (v13);
        if (*(_DWORD *)&asc_18CA86514[2 * v17] != v11) {
          int v17 = -1;
        }
        if ((v17 & 0x80000000) == 0)
        {
          int v19 = *(_DWORD *)(v4 + 288);
          if (v17)
          {
            if (v19 >= 1)
            {
              int v29 = *(_DWORD *)(v4 + 284);
              while (1)
              {
                int v30 = v29;
                if (*(_DWORD *)(v4 + 8 * v29 + 28) == (v17 & 0xFFFFFFFE)) {
                  break;
                }
                int v31 = *(_DWORD *)(v4 + 292);
                BOOL v32 = __OFSUB__(v31, 1);
                int v33 = v31 - 1;
                if (v33 < 0 == v32) {
                  *(_DWORD *)(v4 + 292) = v33;
                }
                *(_DWORD *)(v4 + 288) = v19 - 1;
                int v34 = v30 + 31;
                BOOL v25 = -v34 < 0;
                int v35 = -v34 & 0x1F;
                int v36 = v34 & 0x1F;
                if (!v25) {
                  int v36 = -v35;
                }
                BOOL v37 = v19 < 2;
                if (v19 < 2) {
                  int v29 = -1;
                }
                else {
                  int v29 = v36;
                }
                *(_DWORD *)(v4 + 284) = v29;
                --v19;
                if (v37) {
                  goto LABEL_42;
                }
              }
              int Script = *(_DWORD *)(v4 + 8 * v29 + 32);
            }
          }
          else
          {
            int v20 = *(_DWORD *)(v4 + 24);
            if (v19 < 32) {
              int v21 = v19 + 1;
            }
            else {
              int v21 = 32;
            }
            *(_DWORD *)(v4 + 288) = v21;
            int v22 = *(_DWORD *)(v4 + 292);
            if (v22 < 32) {
              int v23 = v22 + 1;
            }
            else {
              int v23 = 32;
            }
            *(_DWORD *)(v4 + 292) = v23;
            int v24 = *(_DWORD *)(v4 + 284) + 1;
            BOOL v25 = -v24 < 0;
            int v26 = -v24 & 0x1F;
            int v27 = v24 & 0x1F;
            if (!v25) {
              int v27 = -v26;
            }
            *(_DWORD *)(v4 + 284) = v27;
            uint64_t v28 = v4 + 8 * v27;
            *(_DWORD *)(v28 + 28) = v17;
            *(_DWORD *)(v28 + 32) = v20;
          }
        }
LABEL_42:
        int v38 = *(_DWORD *)(v4 + 24);
        BOOL v39 = v38 <= 1 || Script < 2;
        if (!v39 && v38 != Script) {
          break;
        }
        if (Script >= 2 && v38 <= 1)
        {
          *(_DWORD *)(v4 + 24) = Script;
          int v42 = *(_DWORD *)(v4 + 292);
          int v43 = v42 - 1;
          if (v42 >= 1)
          {
            int v44 = *(_DWORD *)(v4 + 284) - v42 + 32;
            int v45 = v44 & 0x1F;
            int v46 = -v44;
            BOOL v25 = v46 < 0;
            int v47 = v46 & 0x1F;
            if (v25) {
              int v48 = v45;
            }
            else {
              int v48 = -v47;
            }
            do
            {
              int v49 = v48 + 1;
              BOOL v25 = -v49 < 0;
              int v50 = -v49 & 0x1F;
              int v48 = v49 & 0x1F;
              if (!v25) {
                int v48 = -v50;
              }
              *(_DWORD *)(v4 + 8 * v48 + 32) = Script;
              --v42;
            }
            while (v42);
            int v43 = -1;
          }
          *(_DWORD *)(v4 + 292) = v43;
          int v38 = Script;
        }
        if ((v17 & 0x80000001) == 1)
        {
          int v51 = *(_DWORD *)(v4 + 288);
          if (v51 >= 1)
          {
            int v52 = *(_DWORD *)(v4 + 292);
            BOOL v32 = __OFSUB__(v52, 1);
            int v53 = v52 - 1;
            if (v53 < 0 == v32) {
              *(_DWORD *)(v4 + 292) = v53;
            }
            *(_DWORD *)(v4 + 288) = v51 - 1;
            int v54 = *(_DWORD *)(v4 + 284) + 31;
            BOOL v25 = -v54 < 0;
            int v55 = -v54 & 0x1F;
            int v56 = v54 & 0x1F;
            if (!v25) {
              int v56 = -v55;
            }
            if (v51 < 2) {
              int v57 = -1;
            }
            else {
              int v57 = v56;
            }
            *(_DWORD *)(v4 + 284) = v57;
          }
        }
        int v5 = *(_DWORD *)(v4 + 20) + 1;
        *(_DWORD *)(v4 + 20) = v5;
        int v6 = *(_DWORD *)v4;
        if (v5 >= *(_DWORD *)v4) {
          goto LABEL_79;
        }
      }
      if (v11 >= 0x10000) {
        --*(_DWORD *)(v4 + 20);
      }
LABEL_79:
      if (a2) {
        *a2 = *(_DWORD *)(v4 + 16);
      }
      if (a3) {
        *a3 = *(_DWORD *)(v4 + 20);
      }
      if (a4) {
        *a4 = v38;
      }
      return 1;
    }
  }
  return result;
}

uint64_t uscript_getCode(char *__s1, int32_t *a2, int a3, int *a4)
{
  v19[8] = *(void **)MEMORY[0x1E4F143B8];
  if (*a4 > 0) {
    return 0;
  }
  int v6 = __s1;
  if (!__s1) {
    goto LABEL_15;
  }
  if (a2)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_6;
    }
LABEL_15:
    uint64_t v4 = 0;
    *a4 = 1;
    return v4;
  }
  if (a3) {
    goto LABEL_15;
  }
LABEL_6:
  if (!strcmp(__s1, "Aran")) {
    int v6 = "Arab";
  }
  unsigned int v9 = strrchr(v6, 45);
  if (v9 || (unsigned int v9 = strrchr(v6, 95)) != 0)
  {
    if (v9 - v6 == 7)
    {
      if (strlen(v6) != 11)
      {
LABEL_13:
        int v10 = 1;
LABEL_23:
        int v18 = 0;
        uint64_t v13 = sub_18C8AD18C((uint64_t)v6, a2, a3, a4);
        uint64_t v4 = v13;
        if (*a4 > 0 || v13) {
          return v4;
        }
        memset(&v19[1], 0, 56);
        v19[0] = (char *)&v19[1] + 5;
        LODWORD(v19[1]) = 40;
        v17[0] = 0;
        v17[1] = 0;
        icu::CharStringByteSink::CharStringByteSink(v17, (uint64_t)v19);
        ulocimp_addLikelySubtags(v6, v17, &v18);
        icu::CharStringByteSink::~CharStringByteSink((icu::CharStringByteSink *)v17);
        if (v18 > 0 || v18 == -124)
        {
          if (!v10) {
            goto LABEL_40;
          }
        }
        else
        {
          unsigned int v14 = sub_18C8AD18C((uint64_t)v19[0], a2, a3, a4);
          BOOL v15 = *a4 <= 0 && v14 == 0;
          if (v15) {
            uint64_t v4 = 0;
          }
          else {
            uint64_t v4 = v14;
          }
          if (!v15 || ((v10 ^ 1) & 1) != 0) {
            goto LABEL_41;
          }
        }
        PropertyValueEnusigned int m = u_getPropertyValueEnum(UCHAR_SCRIPT, v6);
        if (PropertyValueEnum != -1 && *a4 <= 0)
        {
          if (a3) {
            *a2 = PropertyValueEnum;
          }
          else {
            *a4 = 15;
          }
          uint64_t v4 = 1;
          goto LABEL_41;
        }
LABEL_40:
        uint64_t v4 = 0;
LABEL_41:
        if (BYTE4(v19[1])) {
          uprv_free(v19[0]);
        }
        return v4;
      }
    }
    else if (v9 - v6 != 3 || strlen(v6) <= 8)
    {
      goto LABEL_13;
    }
  }
  int32_t v12 = u_getPropertyValueEnum(UCHAR_SCRIPT, v6);
  if (v12 == -1)
  {
    int v10 = 0;
    goto LABEL_23;
  }
  if (*a4 > 0) {
    return 0;
  }
  if (a3) {
    *a2 = v12;
  }
  else {
    *a4 = 15;
  }
  return 1;
}

uint64_t sub_18C8AD18C(uint64_t a1, int32_t *a2, int a3, int *a4)
{
  uint64_t result = 0;
  v15[1] = *MEMORY[0x1E4F143B8];
  int v13 = 0;
  *(void *)alias = 0;
  v15[0] = 0;
  if (*a4 > 0) {
    return result;
  }
  uloc_getLanguage(a1, (char *)v15, 8, &v13);
  uint64_t result = 0;
  if (v13 > 0 || v13 == -124) {
    return result;
  }
  if (LOWORD(v15[0]) ^ 0x616A | BYTE2(v15[0]))
  {
    if (LOWORD(v15[0]) ^ 0x6F6B | BYTE2(v15[0]))
    {
      int Script = uloc_getScript(a1, alias, 8, &v13);
      uint64_t result = 0;
      if (v13 > 0 || v13 == -124) {
        return result;
      }
      if (LOWORD(v15[0]) ^ 0x687A | BYTE2(v15[0]) || *(_DWORD *)alias ^ 0x746E6148 | alias[4])
      {
        if (Script)
        {
          if (!(*(_DWORD *)alias ^ 0x6E617241 | alias[4])) {
            strcpy(alias, "Arab");
          }
          PropertyValueEnusigned int m = u_getPropertyValueEnum(UCHAR_SCRIPT, alias);
          if (PropertyValueEnum != -1)
          {
            int32_t v11 = (PropertyValueEnum - 73) >= 2 ? PropertyValueEnum : 17;
            if (*a4 <= 0)
            {
              if (a3 <= 0) {
                *a4 = 15;
              }
              else {
                *a2 = v11;
              }
              return 1;
            }
          }
        }
        return 0;
      }
      if (*a4 > 0) {
        return 0;
      }
      if (a3 >= 2)
      {
        uint64_t v12 = 0x500000011;
        goto LABEL_31;
      }
    }
    else
    {
      if (*a4 > 0) {
        return 0;
      }
      if (a3 >= 2)
      {
        uint64_t v12 = 0x1100000012;
LABEL_31:
        *(void *)a2 = v12;
        return 2;
      }
    }
    *a4 = 15;
    return 2;
  }
  if (*a4 > 0) {
    return 0;
  }
  if (a3 >= 3)
  {
    *(void *)a2 = 0x1400000016;
    a2[2] = 17;
  }
  else
  {
    *a4 = 15;
  }
  return 3;
}

uint64_t uscript_getSampleString(unsigned int a1, _WORD *a2, unsigned int a3, int *a4)
{
  if (*a4 > 0) {
    return 0;
  }
  if ((a3 & 0x80000000) != 0 || !a2 && a3)
  {
    *a4 = 1;
    return 0;
  }
  if (a1 <= 0xC7 && (int v5 = dword_18CA865B8[a1], v6 = v5 & 0x1FFFFF, (v5 & 0x1FFFFF) != 0))
  {
    if (v6 < 0x10000) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    if (v7 <= a3)
    {
      if (HIWORD(v6))
      {
        *a2 = (v6 >> 10) - 10304;
        a2[1] = v5 & 0x3FF | 0xDC00;
        uint64_t v7 = 2;
      }
      else
      {
        *a2 = v5;
        uint64_t v7 = 1;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  return u_terminateUChars((uint64_t)a2, a3, v7, a4);
}

uint64_t uscript_getSampleUnicodeString@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = &unk_1EDA47700;
  *(_WORD *)(a2 + 8) = 2;
  if (result <= 0xC7)
  {
    unsigned int v2 = dword_18CA865B8[result] & 0x1FFFFF;
    if (v2) {
      return icu::UnicodeString::append(a2, v2);
    }
  }
  return result;
}

uint64_t uscript_getUsage(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0;
  }
  else {
    return (dword_18CA865B8[a1] >> 21) & 7;
  }
}

uint64_t uscript_isRightToLeft(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0;
  }
  else {
    return HIBYTE(dword_18CA865B8[a1]) & 1;
  }
}

uint64_t uscript_breaksBetweenLetters(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0;
  }
  else {
    return (dword_18CA865B8[a1] >> 25) & 1;
  }
}

uint64_t uscript_isCased(unsigned int a1)
{
  if (a1 > 0xC7) {
    return 0;
  }
  else {
    return (dword_18CA865B8[a1] >> 26) & 1;
  }
}

double uset_openEmpty@<D0>(unint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  unsigned int v2 = (icu::UnicodeSet *)icu::UMemory::operator new(a2, (icu::UMemory *)0xC8, a1);
  if (v2) {
    return icu::UnicodeSet::UnicodeSet(v2);
  }
  return result;
}

icu::UnicodeSet *uset_open(int a1, unint64_t a2)
{
  int v2 = a2;
  double result = (icu::UnicodeSet *)icu::UMemory::operator new((icu::UMemory *)0xC8, a2);
  if (result) {
    return (icu::UnicodeSet *)icu::UnicodeSet::UnicodeSet(result, a1, v2);
  }
  return result;
}

void uset_close(icu::UnicodeSet *a1)
{
  if (a1)
  {
    icu::UnicodeSet::~UnicodeSet(a1);
    icu::UMemory::operator delete(v1);
  }
}

BOOL uset_isFrozen(uint64_t a1)
{
  return *(void *)(a1 + 40) || *(void *)(a1 + 88) != 0;
}

void *uset_addString(icu::UnicodeSet *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 >> 31, &v6);
  icu::UnicodeSet::add(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_addAllCodePoints(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  memset(v6, 0, sizeof(v6));
  icu::UnicodeString::UnicodeString((uint64_t)v6, a2, a3);
  icu::UnicodeSet::addAll(a1, (const icu::UnicodeString *)v6);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v6);
}

void *uset_removeString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::remove(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_removeAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::removeAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_retainString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::retain(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_retainAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::retainAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_complementString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::complement(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

void *uset_complementAllCodePoints(icu::UVector **a1, uint64_t a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = a2;
  icu::UnicodeString::UnicodeString(v7, a3 == -1, &v6);
  icu::UnicodeSet::complementAll(a1, (const icu::UnicodeString *)v7);
  return icu::UnicodeString::~UnicodeString(v4, (icu::UnicodeString *)v7);
}

icu::UVector *uset_containsString(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  memset(v8, 0, sizeof(v8));
  uint64_t v7 = a2;
  icu::UnicodeString::UnicodeString(v8, a3 == -1, &v7);
  uint64_t v4 = icu::UnicodeSet::contains(a1, (const icu::UnicodeString *)v8);
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v8);
  return v4;
}

BOOL uset_containsAllCodePoints(icu::UnicodeSet *a1, uint64_t a2, int a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  memset(v8, 0, sizeof(v8));
  uint64_t v7 = a2;
  icu::UnicodeString::UnicodeString(v8, a3 == -1, &v7);
  BOOL v4 = icu::UnicodeSet::containsAll(a1, (const icu::UnicodeString *)v8);
  icu::UnicodeString::~UnicodeString(v5, (icu::UnicodeString *)v8);
  return v4;
}

BOOL uset_containsSome(icu::UnicodeSet *a1, const icu::UnicodeSet *a2)
{
  return !icu::UnicodeSet::containsNone(a1, a2);
}

BOOL uset_equals(uint64_t a1, uint64_t a2)
{
  return icu::UnicodeSet::operator==(a1, a2);
}

uint64_t uset_getItemCount(icu::UnicodeSet *a1)
{
  int RangeCount = icu::UnicodeSet::getRangeCount(a1);
  return icu::UnicodeSet::stringsSize(a1) + RangeCount;
}

uint64_t uset_getItem(icu::UnicodeSet *a1, int a2, _DWORD *a3, _DWORD *a4, UChar *a5, int a6, int *a7)
{
  if (*a7 > 0) {
    return 0;
  }
  if (a2 < 0)
  {
    int v18 = 1;
  }
  else
  {
    int RangeCount = icu::UnicodeSet::getRangeCount(a1);
    signed int v16 = a2 - RangeCount;
    if (a2 < RangeCount)
    {
      *a3 = icu::UnicodeSet::getRangeStart(a1, a2);
      int RangeEnd = icu::UnicodeSet::getRangeEnd(a1, a2);
      uint64_t result = 0;
      *a4 = RangeEnd;
      return result;
    }
    if (v16 < (int)icu::UnicodeSet::stringsSize(a1))
    {
      uint64_t String = icu::UnicodeSet::getString((icu::UVector **)a1, v16);
      int v20 = a5;
      return icu::UnicodeString::extract(String, &v20, a6, a7);
    }
    int v18 = 8;
  }
  *a7 = v18;
  return 0xFFFFFFFFLL;
}

uint64_t uset_serialize(icu::UnicodeSet *a1, unsigned __int16 *a2, int a3, UErrorCode *a4)
{
  if (a4 && *(int *)a4 <= 0) {
    return icu::UnicodeSet::serialize(a1, a2, a3, a4);
  }
  else {
    return 0;
  }
}

uint64_t uset_getSerializedSet(uint64_t a1, __int16 *a2, int a3)
{
  if (a1)
  {
    if (a2 && a3 > 0)
    {
      uint64_t v3 = (unsigned __int16 *)(a2 + 1);
      unsigned int v4 = (unsigned __int16)*a2;
      if (*a2 < 0)
      {
        v4 &= 0x7FFFu;
        if (v4 + 2 <= a3)
        {
          uint64_t v3 = (unsigned __int16 *)(a2 + 2);
          *(_DWORD *)(a1 + 8) = (unsigned __int16)a2[1];
          goto LABEL_11;
        }
      }
      else if (v4 < a3)
      {
        *(_DWORD *)(a1 + 8) = v4;
LABEL_11:
        *(void *)a1 = v3;
        uint64_t v5 = 1;
        goto LABEL_12;
      }
    }
    unsigned int v4 = 0;
    uint64_t v5 = 0;
    *(_DWORD *)(a1 + 8) = 0;
LABEL_12:
    *(_DWORD *)(a1 + 12) = v4;
    return v5;
  }
  return 0;
}

uint64_t uset_setSerializedToOne(uint64_t result, unsigned int a2)
{
  if (result && a2 <= 0x10FFFF)
  {
    *(void *)uint64_t result = result + 16;
    if (a2 > 0xFFFE)
    {
      if (a2 == 0xFFFF)
      {
        *(void *)(result + 8) = 0x300000001;
        *(_DWORD *)(result + 16) = 0x1FFFF;
        *(_WORD *)(result + 20) = 0;
      }
      else
      {
        *(_DWORD *)(result + 8) = 0;
        if (a2 >= 0x10FFFF)
        {
          *(void *)(result + 12) = 0xFFFF001000000002;
        }
        else
        {
          *(_DWORD *)(result + 12) = 4;
          *(_WORD *)(result + 16) = HIWORD(a2);
          *(_WORD *)(result + 18) = a2;
          *(_WORD *)(result + 20) = (a2 + 1) >> 16;
          *(_WORD *)(result + 22) = a2 + 1;
        }
      }
    }
    else
    {
      *(void *)(result + 8) = 0x200000002;
      *(_WORD *)(result + 16) = a2;
      *(_WORD *)(result + 18) = a2 + 1;
    }
  }
  return result;
}

uint64_t uset_serializedContains(unsigned __int16 **a1, unsigned int a2)
{
  uint64_t v2 = 0;
  if (a1)
  {
    unsigned int v3 = HIWORD(a2);
    if (HIWORD(a2) <= 0x10u)
    {
      unsigned int v4 = *a1;
      if (v3)
      {
        int v6 = *((_DWORD *)a1 + 3);
        uint64_t v7 = *((int *)a1 + 2);
        int v8 = v6 - 2 - v7;
        unsigned int v9 = v4[v7];
        if (v3 < v9 || v3 == v9 && v4[(int)v7 + 1] > (unsigned __int16)a2)
        {
          int v8 = 0;
        }
        else
        {
          unsigned int v11 = v4[v6 - 2];
          if (v3 < v11 || v3 == v11 && v4[v6 - 1] > (unsigned __int16)a2)
          {
            unsigned int v12 = (v8 >> 1) & 0xFFFFFFFE;
            if (v12)
            {
              for (i = 0; i != v12; unsigned int v12 = ((int)(v8 + i) >> 1) & 0xFFFFFFFE)
              {
                unsigned int v14 = v4[(int)(v12 + v7)];
                if (v3 < v14 || v3 == v14 && (unsigned __int16)a2 < v4[(int)(v12 + v7) + 1]) {
                  int v8 = v12;
                }
                else {
                  unsigned int i = v12;
                }
              }
            }
          }
          else
          {
            int v8 = v6 - v7;
          }
        }
        return ((_BYTE)v7 + (v8 >> 1)) & 1;
      }
      else
      {
        if (*v4 <= a2)
        {
          int v5 = *((_DWORD *)a1 + 2);
          int v10 = v5 - 1;
          if (v4[v5 - 1] > a2)
          {
            if (v10 >= 2)
            {
              int v15 = 0;
              int v16 = v10 >> 1;
              --v5;
              do
              {
                if (v4[v16] > (int)a2) {
                  int v5 = v16;
                }
                else {
                  int v15 = v16;
                }
                int v16 = (v5 + v15) >> 1;
              }
              while (v16 != v15);
            }
            else
            {
              LOBYTE(v5) = v5 - 1;
            }
          }
        }
        else
        {
          LOBYTE(v5) = 0;
        }
        return v5 & 1;
      }
    }
  }
  return v2;
}

uint64_t uset_getSerializedRangeCount(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 8);
    int v2 = *(_DWORD *)(result + 12);
    BOOL v3 = __OFSUB__(v2, v1);
    int v4 = v2 - v1;
    if (v4 < 0 != v3) {
      ++v4;
    }
    int v5 = v1 + (v4 >> 1);
    if (v5 + 1 >= 0) {
      int v6 = v5 + 1;
    }
    else {
      int v6 = v5 + 2;
    }
    return (v6 >> 1);
  }
  return result;
}

uint64_t uset_getSerializedRange(uint64_t *a1, int a2, int *a3, int *a4)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0 && a3 && a4)
  {
    uint64_t v6 = *a1;
    signed int v7 = *((_DWORD *)a1 + 3);
    uint64_t v8 = *((int *)a1 + 2);
    unsigned int v9 = 2 * a2;
    if (2 * a2 >= (int)v8)
    {
      uint64_t v12 = 2 * (int)(v9 - v8);
      int v13 = v7 - v8;
      if ((int)v12 >= v13) {
        return 0;
      }
      uint64_t v14 = v6 + 2 * v8;
      uint64_t v15 = (int)v12;
      *a3 = *(unsigned __int16 *)(v14 + ((2 * v12) | 2)) | (*(unsigned __int16 *)(v14 + 2 * (int)v12) << 16);
      uint64_t v16 = (int)v12 + 2;
      if ((int)v16 < v13)
      {
        int v11 = *(unsigned __int16 *)(v14 + 2 * v15 + 6) | (*(unsigned __int16 *)(v14 + 2 * v16) << 16);
        goto LABEL_13;
      }
    }
    else
    {
      unsigned int v10 = v9 | 1;
      *a3 = *(unsigned __int16 *)(v6 + 2 * v9);
      if ((int)(v9 | 1) < (int)v8)
      {
        int v11 = *(unsigned __int16 *)(v6 + 2 * v10);
LABEL_13:
        int v17 = v11 - 1;
LABEL_16:
        *a4 = v17;
        return 1;
      }
      if ((int)v10 < v7)
      {
        int v11 = *(unsigned __int16 *)(v6 + 2 * (int)(v9 + 2)) | (*(unsigned __int16 *)(v6 + 2 * v10) << 16);
        goto LABEL_13;
      }
    }
    int v17 = 1114111;
    goto LABEL_16;
  }
  return result;
}

icu::UnicodeSet *uset_openPattern(uint64_t a1, int a2, UErrorCode *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  memset(v12, 0, sizeof(v12));
  uint64_t v11 = a1;
  icu::UnicodeString::UnicodeString(v12, a2 == -1, &v11);
  uint64_t v10 = v11;
  int v5 = (icu::UnicodeSet *)icu::UMemory::operator new(&v10, (icu::UMemory *)0xC8, v4);
  uint64_t v6 = v5;
  if (v5)
  {
    icu::UnicodeSet::UnicodeSet(v5, (const icu::UnicodeString *)v12, a3);
    uint64_t v7 = *(unsigned int *)a3;
    if ((int)v7 >= 1)
    {
      icu::UnicodeSet::~UnicodeSet(v6);
      icu::UMemory::operator delete(v8);
      uint64_t v6 = 0;
    }
  }
  else
  {
    uint64_t v7 = 7;
    *a3 = U_MEMORY_ALLOCATION_ERROR;
  }
  icu::UnicodeString::~UnicodeString((void *)v7, (icu::UnicodeString *)v12);
  return v6;
}

icu::UnicodeSet *uset_openPatternOptions(uint64_t a1, int a2, unsigned int a3, UErrorCode *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  uint64_t v13 = a1;
  icu::UnicodeString::UnicodeString(v14, a2 == -1, &v13);
  uint64_t v12 = v13;
  uint64_t v7 = (icu::UnicodeSet *)icu::UMemory::operator new(&v12, (icu::UMemory *)0xC8, v6);
  uint64_t v8 = v7;
  if (v7)
  {
    icu::UnicodeSet::UnicodeSet(v7, (const icu::UnicodeString *)v14, a3, 0, a4);
    uint64_t v9 = *(unsigned int *)a4;
    if ((int)v9 >= 1)
    {
      icu::UnicodeSet::~UnicodeSet(v8);
      icu::UMemory::operator delete(v10);
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v9 = 7;
    *a4 = U_MEMORY_ALLOCATION_ERROR;
  }
  icu::UnicodeString::~UnicodeString((void *)v9, (icu::UnicodeString *)v14);
  return v8;
}

uint64_t uset_applyPattern(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3, unsigned int a4, UErrorCode *a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a5 || *(int *)a5 > 0) {
    return 0;
  }
  if (a1)
  {
    memset(v13, 0, sizeof(v13));
    icu::UnicodeString::UnicodeString((uint64_t)v13, a2, a3);
    uint64_t v11 = &unk_1EDA44670;
    unint64_t v12 = 0xFFFFFFFF00000000;
    icu::UnicodeSet::applyPattern(a1, (const icu::UnicodeString *)v13, (icu::ParsePosition *)&v11, a4, 0, a5);
    uint64_t v6 = v12;
    icu::ParsePosition::~ParsePosition((icu::ParsePosition *)&v11);
    icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
  }
  else
  {
    uint64_t v6 = 0;
    *a5 = U_ILLEGAL_ARGUMENT_ERROR;
  }
  return v6;
}

void *uset_applyPropertyAlias(icu::UnicodeSet *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, UErrorCode *a6)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  icu::UnicodeString::UnicodeString((uint64_t)v14, a2, a3);
  memset(v13, 0, sizeof(v13));
  icu::UnicodeString::UnicodeString((uint64_t)v13, a4, a5);
  icu::UnicodeSet::applyPropertyAlias(a1, (const icu::UnicodeString *)v14, (const icu::UnicodeString *)v13, a6);
  icu::UnicodeString::~UnicodeString(v10, (icu::UnicodeString *)v13);
  return icu::UnicodeString::~UnicodeString(v11, (icu::UnicodeString *)v14);
}

BOOL uset_resemblesPattern(uint64_t a1, uint64_t a2, const icu::UnicodeString *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  icu::UnicodeString::UnicodeString((uint64_t)&v10, a1, a2);
  int v4 = a3 + 1;
  if (SWORD4(v10) < 0)
  {
    unsigned int v5 = HIDWORD(v10);
    if (v4 < SHIDWORD(v10)) {
      goto LABEL_5;
    }
LABEL_11:
    BOOL v8 = icu::UnicodeSet::resemblesPattern((icu::UnicodeSet *)&v10, a3);
    goto LABEL_12;
  }
  if (v4 >= WORD4(v10) >> 5) {
    goto LABEL_11;
  }
  unsigned int v5 = WORD4(v10) >> 5;
LABEL_5:
  if (v5 <= a3) {
    goto LABEL_11;
  }
  unint64_t v6 = (BYTE8(v10) & 2) != 0 ? (unint64_t)&v10 | 0xA : *((void *)&v11 + 1);
  uint64_t v7 = (void *)*(unsigned __int16 *)(v6 + 2 * (int)a3);
  if (v7 != 91) {
    goto LABEL_11;
  }
  BOOL v8 = 1;
LABEL_12:
  icu::UnicodeString::~UnicodeString(v7, (icu::UnicodeString *)&v10);
  return v8;
}

uint64_t uset_toPattern(icu::UnicodeSet *a1, UChar *a2, int a3, const icu::UnicodeString *a4, int *a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v16 = 0;
  long long v15 = 0u;
  long long v12 = &unk_1EDA47700;
  LOWORD(v13) = 2;
  icu::UnicodeSet::toPattern(a1, (icu::UnicodeString *)&v12, a4);
  long long v11 = a2;
  uint64_t v8 = icu::UnicodeString::extract((uint64_t)&v12, &v11, a3, a5);
  long long v10 = v11;
  icu::UnicodeString::~UnicodeString(&v10, (icu::UnicodeString *)&v12);
  return v8;
}

void *icu::UnicodeSetIterator::getStaticClassID(icu::UnicodeSetIterator *this)
{
  return &unk_1E9191F28;
}

void *icu::UnicodeSetIterator::getDynamicClassID(icu::UnicodeSetIterator *this)
{
  return &unk_1E9191F28;
}

icu::UnicodeSetIterator *icu::UnicodeSetIterator::UnicodeSetIterator(icu::UnicodeSetIterator *this, const icu::UnicodeSet *a2)
{
  *(void *)this = &unk_1EDA481A0;
  *((void *)this + 7) = 0;
  *((void *)this + 3) = a2;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

{
  *(void *)this = &unk_1EDA481A0;
  *((void *)this + 7) = 0;
  *((void *)this + 3) = a2;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

icu::UnicodeSet *icu::UnicodeSetIterator::reset(icu::UnicodeSetIterator *this, const icu::UnicodeSet *a2)
{
  *((void *)this + 3) = a2;
  return icu::UnicodeSetIterator::reset(this);
}

icu::UnicodeSetIterator *icu::UnicodeSetIterator::UnicodeSetIterator(icu::UnicodeSetIterator *this)
{
  *(void *)this = &unk_1EDA481A0;
  *((void *)this + 3) = 0;
  *((void *)this + 7) = 0;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

{
  *(void *)this = &unk_1EDA481A0;
  *((void *)this + 3) = 0;
  *((void *)this + 7) = 0;
  icu::UnicodeSetIterator::reset(this);
  return this;
}

icu::UnicodeSet *icu::UnicodeSetIterator::reset(icu::UnicodeSetIterator *this)
{
  uint64_t result = (icu::UnicodeSet *)*((void *)this + 3);
  if (result)
  {
    *((_DWORD *)this + 8) = icu::UnicodeSet::getRangeCount(result) - 1;
    uint64_t result = (icu::UnicodeSet *)icu::UnicodeSet::stringsSize(*((icu::UnicodeSet **)this + 3));
    int v3 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 13) = result;
    *(void *)((char *)this + 36) = 0xFFFFFFFF00000000;
    *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = 0;
    if ((v3 & 0x80000000) == 0)
    {
      *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), 0);
      uint64_t result = (icu::UnicodeSet *)icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), 0);
      *((_DWORD *)this + 10) = result;
    }
  }
  else
  {
    *((_DWORD *)this + 13) = 0;
    *(void *)&long long v4 = 0xFFFFFFFFLL;
    *((void *)&v4 + sub_18C8A49A0((uint64_t)this, 1) = 0xFFFFFFFFLL;
    *((_OWORD *)this + 2) = v4;
  }
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 2) = 0;
  return result;
}

void icu::UnicodeSetIterator::~UnicodeSetIterator(icu::UnicodeSetIterator *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  icu::UObject::~UObject(this);
}

{
  void *v1;
  uint64_t vars8;

  icu::UnicodeSetIterator::~UnicodeSetIterator(this);

  icu::UMemory::operator delete(v1);
}

uint64_t icu::UnicodeSetIterator::next(icu::UnicodeSetIterator *this)
{
  int v2 = *((_DWORD *)this + 11);
  if (v2 <= *((_DWORD *)this + 10))
  {
    uint64_t v6 = 0;
    *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = v2 + 1;
    *((_DWORD *)this + 2) = v2;
    *((_DWORD *)this + 3) = v2;
    goto LABEL_7;
  }
  int v3 = *((_DWORD *)this + 9);
  if (v3 < *((_DWORD *)this + 8))
  {
    int v4 = v3 + 1;
    *((_DWORD *)this + 9) = v3 + 1;
    *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), v3 + 1);
    int RangeEnd = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), v4);
    uint64_t v6 = 0;
    int v7 = *((_DWORD *)this + 11);
    *((_DWORD *)this + 10) = RangeEnd;
    *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = v7 + 1;
    *((_DWORD *)this + 2) = v7;
    *((_DWORD *)this + 3) = v7;
LABEL_7:
    *((void *)this + 2) = v6;
    return 1;
  }
  signed int v8 = *((_DWORD *)this + 12);
  if (v8 < *((_DWORD *)this + 13))
  {
    *((_DWORD *)this + 2) = -1;
    uint64_t v9 = *(icu::UVector **)(*((void *)this + 3) + 80);
    *((_DWORD *)this + 12) = v8 + 1;
    uint64_t v6 = icu::UVector::elementAt(v9, v8);
    goto LABEL_7;
  }
  return 0;
}

uint64_t icu::UnicodeSetIterator::loadRange(icu::UnicodeSetIterator *this, int a2)
{
  *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), a2);
  uint64_t result = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), a2);
  *((_DWORD *)this + 10) = result;
  return result;
}

uint64_t icu::UnicodeSetIterator::nextRange(icu::UnicodeSetIterator *this)
{
  *((void *)this + 2) = 0;
  int v3 = *((_DWORD *)this + 10);
  int v2 = *((_DWORD *)this + 11);
  if (v2 <= v3)
  {
    *((_DWORD *)this + 2) = v2;
    *((_DWORD *)this + 3) = v3;
    int v7 = v3 + 1;
    goto LABEL_5;
  }
  int v4 = *((_DWORD *)this + 9);
  if (v4 < *((_DWORD *)this + 8))
  {
    int v5 = v4 + 1;
    *((_DWORD *)this + 9) = v4 + 1;
    *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = icu::UnicodeSet::getRangeStart(*((icu::UnicodeSet **)this + 3), v4 + 1);
    int RangeEnd = icu::UnicodeSet::getRangeEnd(*((icu::UnicodeSet **)this + 3), v5);
    *((_DWORD *)this + 2) = *((_DWORD *)this + 11);
    *((_DWORD *)this + 3) = RangeEnd;
    int v7 = RangeEnd + 1;
    *((_DWORD *)this + 10) = RangeEnd;
LABEL_5:
    *((_DWORD *)this + 1sub_18C8A49A0((uint64_t)this, 1) = v7;
    return 1;
  }
  signed int v9 = *((_DWORD *)this + 12);
  if (v9 < *((_DWORD *)this + 13))
  {
    *((_DWORD *)this + 2) = -1;
    long long v10 = *(icu::UVector **)(*((void *)this + 3) + 80);
    *((_DWORD *)this + 12) = v9 + 1;
    *((void *)this + 2) = icu::UVector::elementAt(v10, v9);
    return 1;
  }
  return 0;
}

uint64_t *icu::UnicodeSetIterator::getString@<X0>(icu::UnicodeSetIterator *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (uint64_t *)*((void *)this + 2);
  if (!result)
  {
    unsigned int v5 = *((_DWORD *)this + 2);
    if (v5 == -1) {
      return 0;
    }
    uint64_t v6 = *((void *)this + 7);
    if (!v6)
    {
      uint64_t result = icu::UMemory::operator new(a3, (icu::UMemory *)0x40, a2);
      if (!result)
      {
        *((void *)this + 7) = 0;
LABEL_11:
        *((void *)this + 2) = result;
        return result;
      }
      uint64_t v6 = (uint64_t)result;
      *uint64_t result = (uint64_t)&unk_1EDA47700;
      *((_WORD *)result + 4) = 2;
      *((void *)this + 7) = result;
      unsigned int v5 = *((_DWORD *)this + 2);
    }
    icu::UnicodeString::unBogus(v6);
    if (*(__int16 *)(v6 + 8) < 0) {
      uint64_t v7 = *(unsigned int *)(v6 + 12);
    }
    else {
      uint64_t v7 = *(unsigned __int16 *)(v6 + 8) >> 5;
    }
    icu::UnicodeString::replace((icu::UnicodeString *)v6, 0, v7, v5);
    uint64_t result = (uint64_t *)*((void *)this + 7);
    goto LABEL_11;
  }
  return result;
}

uint64_t u_shapeArabic(UChar *src, uint64_t count, UChar *dest, int a4, int a5, int *a6)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  if (!a6 || *a6 > 0) {
    return 0;
  }
  signed int v8 = (__int16 *)src;
  if (!src) {
    goto LABEL_27;
  }
  uint64_t v7 = count;
  if ((int)count < -1) {
    goto LABEL_27;
  }
  BOOL v11 = dest || a4 == 0;
  BOOL v12 = !v11;
  if (a4 < 0) {
    goto LABEL_27;
  }
  if (v12) {
    goto LABEL_27;
  }
  int v14 = a5 & 0x18;
  unsigned int v15 = a5 & 0xE0000;
  if ((a5 & 0xE0000) != 0 && v14 == 24) {
    goto LABEL_27;
  }
  BOOL v16 = v15 && v14 == 16;
  BOOL v17 = v16;
  if ((a5 & 0x200) != 0) {
    goto LABEL_27;
  }
  if (v17) {
    goto LABEL_27;
  }
  int v18 = a5 & 0xE0;
  if (v18 == 160 || (a5 & 0x1001B) != 0x18 && (a5 & 0x4000) != 0) {
    goto LABEL_27;
  }
  int v21 = a5 & 0x10003;
  if ((a5 & 0x10003u) >= 4 && v21 != 0x10000) {
    goto LABEL_27;
  }
  if (v15 >> 17 > 6 || ((1 << (v15 >> 17)) & 0x5D) == 0) {
    goto LABEL_27;
  }
  if (count == -1) {
    uint64_t v7 = u_strlen(src);
  }
  if ((int)v7 > 0)
  {
    if (!dest
      || (v8 > (__int16 *)dest || &v8[v7] <= (__int16 *)dest)
      && (dest > (UChar *)v8 || &dest[a4] <= (UChar *)v8))
    {
      if ((a5 & 0x8000000) != 0) {
        __int16 v22 = -397;
      }
      else {
        __int16 v22 = 8203;
      }
      if (v14)
      {
        unsigned __int16 v88 = v22;
        bzero(desta, 0x258uLL);
        if ((a5 & 0x4000) != 0)
        {
          int v85 = v21;
          if ((a5 & 4) != 0) {
            int v24 = -1;
          }
          else {
            int v24 = 1;
          }
          if ((a5 & 4) != 0) {
            int v25 = -1;
          }
          else {
            int v25 = v7;
          }
          int v95 = v25;
          int v26 = uprv_malloc(4 * (int)v7);
          if (!v26)
          {
            uint64_t v29 = 0;
            int v30 = 7;
LABEL_149:
            *a6 = v30;
            return v29;
          }
          uint64_t v92 = v26;
          int v86 = v18;
          if ((a5 & 4) != 0) {
            int v27 = v7;
          }
          else {
            int v27 = -1;
          }
          int v28 = 2 * v7;
          if ((a5 & 4) == 0) {
            int v28 = -1;
          }
          int v97 = v28;
          if (v27 + v24 == v95)
          {
            uint64_t v7 = 0;
          }
          else
          {
            uint64_t v7 = 0;
            unsigned __int16 v89 = 0;
            int v31 = &v8[v27 + (uint64_t)v24];
            int v90 = v24;
            uint64_t v91 = 2 * v24;
            int v32 = v95 - (v27 + v24);
            unsigned __int8 v94 = 0;
            int v96 = 1;
            do
            {
              unsigned int v33 = (unsigned __int16)*v31;
              unsigned __int8 v34 = sub_18C8AF4A4(v33);
              if ((a5 & 0x4018) == 0x4018 && v96 && ((v34 | v94) & 0xC0) == 0xC0)
              {
                __int16 v35 = v89;
                if (v89 >= v33) {
                  __int16 v35 = v33;
                }
                unsigned __int16 v36 = v35 - 2542;
                v92[v97] = v36;
                unsigned __int8 v34 = sub_18C8AF4A4(v36);
                int v96 = 0;
                int v37 = v90;
              }
              else
              {
                int v37 = v90;
                v92[v97 + v90] = v33;
                uint64_t v7 = (v7 + 1);
                int v96 = 1;
                v97 += v90;
                unsigned __int16 v89 = v33;
              }
              int v31 = (__int16 *)((char *)v31 + v91);
              unsigned __int8 v94 = v34;
              v32 -= v37;
            }
            while (v32);
          }
          int v23 = v92;
          signed int v8 = &v92[v97 & (a5 << 29 >> 31)];
          int v21 = v85;
          int v18 = v86;
        }
        else
        {
          int v23 = 0;
        }
        if (!v21 || (uint64_t v29 = v7, v15 == 0x80000))
        {
          int v38 = v23;
          uint64_t v29 = sub_18C8AF540(v8, v7, a5);
          int v23 = v38;
        }
        if ((int)v29 > a4)
        {
          *a6 = 15;
          if (v23)
          {
            uint64_t v39 = v29;
            uprv_free(v23);
            return v39;
          }
          return v29;
        }
        size_t v93 = v23;
        int v87 = v18;
        if ((int)v7 <= (int)v29) {
          int v40 = v29;
        }
        else {
          int v40 = v7;
        }
        if (v40 >= 301)
        {
          int v42 = (UChar *)uprv_malloc((2 * v40));
          if (!v42)
          {
            *a6 = 7;
            if (v93) {
              uprv_free(v93);
            }
            return 0;
          }
          size_t v41 = v42;
        }
        else
        {
          int v40 = 300;
          size_t v41 = desta;
        }
        u_memcpy(v41, (const UChar *)v8, v7);
        if (v93) {
          uprv_free(v93);
        }
        if (v40 > (int)v7) {
          bzero(&v41[(int)v7], 2 * (v40 - (int)v7));
        }
        if ((a5 & 4) == 0)
        {
          LODWORD(v43) = 0;
          int v44 = (int)v7 > 0;
          if ((int)v7 >= 1 && *v41 == 32)
          {
            uint64_t v43 = 0;
            do
            {
              int v45 = v41[++v43];
              int v44 = (int)v7 > (int)v43;
            }
            while (v45 == 32 && (int)v7 > (int)v43);
          }
          if (v44)
          {
            int v47 = &v41[(int)v7 - 1];
            int v44 = -1;
            do
            {
              int v48 = *v47--;
              ++v44;
            }
            while (v48 == 32);
          }
          LODWORD(v49) = v7 + ~v44;
          if ((int)v49 > (int)v43)
          {
            uint64_t v49 = (int)v49;
            uint64_t v43 = (int)v43;
            do
            {
              UChar v50 = v41[v43];
              v41[v43] = v41[v49];
              v41[v49] = v50;
              ++v43;
              --v49;
            }
            while (v43 < v49);
          }
        }
        if ((~a5 & 0x4000004) != 0)
        {
          int v55 = 0;
          int v51 = 3;
          int v52 = 2;
          int v53 = 0x40000;
          int v54 = 393216;
        }
        else
        {
          int v51 = 2;
          int v52 = 3;
          int v53 = 393216;
          int v54 = 0x40000;
          int v55 = 1;
        }
        if (v14 != 24)
        {
          if (v14 == 16)
          {
            LODWORD(v98) = v88;
            *(void *)((char *)&v98 + 4) = __PAIR64__(v52, v51);
            HIDWORD(v98) = v53;
            int v99 = v54;
            int v100 = v55;
            uint64_t v57 = sub_18C8AFEA8(v41, v7, a5, a6, &v98);
          }
          else
          {
            if (v14 == 8)
            {
              if (!v15 || v15 == 786432)
              {
                LODWORD(v107) = v88;
                *(void *)((char *)&v107 + 4) = __PAIR64__(v52, v51);
                HIDWORD(v107) = v53;
                int v108 = v54;
                int v109 = v55;
                uint64_t v56 = sub_18C8AF694(v41, v7, a5, a6, 1, &v107);
                if (v15 == 786432) {
                  sub_18C8AFDC4(v41, v56);
                }
                uint64_t v57 = v56;
                goto LABEL_130;
              }
              v110[0] = v88;
              v110[1] = 0;
              int v111 = v51;
              int v112 = v52;
              int v113 = v53;
              int v114 = v54;
              int v115 = v55;
              int v58 = (long long *)v110;
              uint64_t v59 = v41;
              unsigned int v60 = v7;
              int v61 = a5;
              uint64_t v62 = a6;
              int v63 = 2;
              goto LABEL_129;
            }
            uint64_t v57 = 0;
          }
LABEL_130:
          uint64_t v64 = v57;
          if ((a5 & 4) == 0)
          {
            LODWORD(v65) = 0;
            int v66 = (int)v57 > 0;
            if ((int)v57 >= 1 && *v41 == 32)
            {
              uint64_t v65 = 0;
              do
              {
                int v67 = v41[++v65];
                int v66 = (int)v57 > (int)v65;
              }
              while (v67 == 32 && (int)v57 > (int)v65);
            }
            if (v66)
            {
              uint64_t v69 = &v41[(int)v57 - 1];
              int v66 = -1;
              do
              {
                int v70 = *v69--;
                ++v66;
              }
              while (v70 == 32);
            }
            LODWORD(v7sub_18C8A49A0((uint64_t)this, 1) = v57 + ~v66;
            if ((int)v71 > (int)v65)
            {
              uint64_t v71 = (int)v71;
              uint64_t v65 = (int)v65;
              do
              {
                UChar v72 = v41[v65];
                v41[v65] = v41[v71];
                v41[v71] = v72;
                ++v65;
                --v71;
              }
              while (v65 < v71);
            }
          }
          int32_t v73 = uprv_min(v57, a4);
          u_memcpy(dest, v41, v73);
          if (v41 != desta) {
            uprv_free(v41);
          }
          uint64_t v29 = v64;
          if ((int)v64 > a4)
          {
            int v30 = 15;
            goto LABEL_149;
          }
          int v18 = v87;
LABEL_152:
          if (v18)
          {
            if ((a5 & 0x300) == 0x100) {
              int v74 = 1776;
            }
            else {
              int v74 = 0;
            }
            if ((a5 & 0x300) != 0) {
              int v75 = v74;
            }
            else {
              int v75 = 1632;
            }
            unsigned __int8 v76 = 0;
            switch((v18 - 32) >> 5)
            {
              case 0u:
                if ((int)v29 >= 1)
                {
                  uint64_t v77 = v29;
                  uint64_t v78 = dest;
                  do
                  {
                    int v79 = *v78;
                    if ((v79 - 48) <= 9) {
                      *uint64_t v78 = v75 - 48 + v79;
                    }
                    ++v78;
                    --v77;
                  }
                  while (v77);
                }
                break;
              case 1u:
                if ((int)v29 >= 1)
                {
                  uint64_t v80 = v29;
                  uint64_t v81 = dest;
                  do
                  {
                    int v82 = *v81;
                    if ((v82 - v75) <= 9) {
                      *uint64_t v81 = v82 - v75 + 48;
                    }
                    ++v81;
                    --v80;
                  }
                  while (v80);
                }
                break;
              case 2u:
                goto LABEL_173;
              case 3u:
                unsigned __int8 v76 = 1;
LABEL_173:
                BOOL v83 = (a5 & 4) == 0;
                uint64_t v84 = v29;
                sub_18C8B0070((uint64_t)dest, v29, v75, v83, v76);
                uint64_t v29 = v84;
                break;
              default:
                return u_terminateUChars((uint64_t)dest, a4, v29, a6);
            }
          }
          return u_terminateUChars((uint64_t)dest, a4, v29, a6);
        }
        v101[0] = v88;
        v101[1] = 0;
        int v102 = v51;
        int v103 = v52;
        int v104 = v53;
        int v105 = v54;
        int v106 = v55;
        int v58 = (long long *)v101;
        uint64_t v59 = v41;
        unsigned int v60 = v7;
        int v61 = a5;
        uint64_t v62 = a6;
        int v63 = 0;
LABEL_129:
        uint64_t v57 = sub_18C8AF694(v59, v60, v61, v62, v63, v58);
        goto LABEL_130;
      }
      if (v7 <= a4)
      {
        u_memcpy(dest, (const UChar *)v8, v7);
        uint64_t v29 = v7;
        goto LABEL_152;
      }
      int v19 = 15;
LABEL_28:
      *a6 = v19;
      return v7;
    }
LABEL_27:
    uint64_t v7 = 0;
    int v19 = 1;
    goto LABEL_28;
  }

  return u_terminateUChars((uint64_t)dest, a4, 0, a6);
}

uint64_t sub_18C8AF4A4(int a1)
{
  if ((a1 - 1570) <= 0xB1) {
    return word_18CA868FC[a1 - 1570];
  }
  if (a1 == 8205) {
    return 3;
  }
  if ((a1 - 8301) < 3) {
    return 4;
  }
  if ((unsigned __int16)(a1 + 1200) <= 0x112u)
  {
    int v2 = a1 - 64336;
    int v3 = (unsigned __int8 *)&unk_18CA86A60;
    return v3[v2];
  }
  if ((unsigned __int16)(a1 + 400) <= 0x8Cu)
  {
    int v2 = a1 - 65136;
    int v3 = (unsigned __int8 *)&unk_18CA86B73;
    return v3[v2];
  }
  return 0;
}

uint64_t sub_18C8AF540(__int16 *a1, uint64_t a2, int a3)
{
  BOOL v3 = (a3 & 0x1000B) == 8 || (a3 & 0xE0018) == 524296;
  uint64_t v4 = a2;
  if (v3)
  {
    unint64_t v5 = (a2 - 1);
    if ((a3 & 4) == 0)
    {
      if ((int)a2 >= 1)
      {
        unint64_t v6 = 0;
        uint64_t v4 = a2;
        while (1)
        {
          int v7 = (unsigned __int16)a1[v6];
          if (v7 != 1604 || v6 >= v5)
          {
            if ((v7 & 0xFFF0) != 0xFE70) {
              goto LABEL_21;
            }
          }
          else
          {
            unsigned int v9 = (unsigned __int16)a1[v6 + 1] - 1570;
            BOOL v10 = v9 > 5;
            int v11 = (1 << v9) & 0x2B;
            if (v10 || v11 == 0) {
              goto LABEL_21;
            }
          }
          uint64_t v4 = (v4 - 1);
LABEL_21:
          if (a2 == ++v6) {
            goto LABEL_22;
          }
        }
      }
      return a2;
    }
    if ((int)a2 < 1) {
      return a2;
    }
    unint64_t v15 = 0;
    uint64_t v4 = a2;
    while (1)
    {
      int v16 = (unsigned __int16)a1[v15];
      BOOL v17 = (v16 - 1570) > 5 || ((1 << (v16 - 34)) & 0x2B) == 0;
      if (!v17 && v15 < v5) {
        break;
      }
      if ((v16 & 0xFFF0) == 0xFE70) {
        goto LABEL_41;
      }
LABEL_42:
      if (a2 == ++v15) {
        goto LABEL_22;
      }
    }
    if (a1[v15 + 1] != 1604) {
      goto LABEL_42;
    }
LABEL_41:
    uint64_t v4 = (v4 - 1);
    goto LABEL_42;
  }
LABEL_22:
  if ((a3 & 0x1001B) == 0x10 && (int)a2 >= 1)
  {
    uint64_t v13 = a2;
    do
    {
      __int16 v14 = *a1++;
      if ((unsigned __int16)(v14 + 267) >= 8u) {
        uint64_t v4 = v4;
      }
      else {
        uint64_t v4 = (v4 + 1);
      }
      --v13;
    }
    while (v13);
  }
  return v4;
}

uint64_t sub_18C8AF694(UChar *a1, unsigned int a2, int a3, _DWORD *a4, int a5, long long *a6)
{
  if ((a3 & 0x8000) == 0 && (int)a2 >= 1)
  {
    uint64_t v7 = a2;
    signed int v8 = a1;
    while (1)
    {
      int v9 = *v8;
      if ((unsigned __int16)(v9 + 1200) <= 0xAFu) {
        break;
      }
      if ((unsigned __int16)(v9 + 400) <= 0x8Cu)
      {
        LOWORD(v9) = word_18CA86D64[v9 - 65136];
LABEL_9:
        *signed int v8 = v9;
      }
LABEL_10:
      ++v8;
      if (!--v7) {
        goto LABEL_11;
      }
    }
    int v9 = word_18CA86C04[v9 - 64336];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_11:
  if (a2)
  {
    int v10 = a2 - 1;
    unsigned int v11 = sub_18C8AF4A4(a1[a2 - 1]);
    unsigned int v12 = 0;
    unsigned int v13 = 0;
    unsigned int v14 = 0;
    int v81 = 0;
    int v15 = 0;
    uint64_t v85 = 0;
    int v16 = -2;
    int v17 = v10;
    while (1)
    {
      if (v11 <= 0xFF && (sub_18C8AF4A4(a1[v17]) & 4) == 0)
      {
        int v18 = v17;
        goto LABEL_67;
      }
      if (v16 < 0)
      {
        int v19 = v17 - 1;
        while (v19 != -1)
        {
          unsigned int v20 = sub_18C8AF4A4(a1[v19]);
          if ((v20 & 4) == 0) {
            int v16 = v19;
          }
          v19 -= (v20 & 4) >> 2;
          if ((v16 & 0x80000000) == 0)
          {
            unsigned int v12 = v20;
            goto LABEL_23;
          }
        }
        unsigned int v12 = 0;
        int v16 = 3000;
        if ((v11 & 0x20) == 0)
        {
LABEL_29:
          int v18 = v17;
          goto LABEL_32;
        }
      }
      else
      {
LABEL_23:
        if ((v11 & 0x20) == 0) {
          goto LABEL_29;
        }
      }
      if ((v13 & 0x10) == 0) {
        goto LABEL_29;
      }
      unsigned int v21 = a1[v17] - 1570;
      if (v21 <= 5 && ((0x2Bu >> v21) & 1) != 0)
      {
        int v22 = word_18CA86EEA[(__int16)v21];
        a1[v17] = -1;
        a1[v10] = v22;
        int v17 = v10;
      }
      else
      {
        int v22 = 0;
      }
      unsigned int v11 = sub_18C8AF4A4(v22);
      LODWORD(v85) = 1;
      int v18 = v17;
      unsigned int v13 = v14;
LABEL_32:
      if (v18 < 1)
      {
        if (!v18)
        {
          int v23 = *a1;
          goto LABEL_37;
        }
      }
      else if (a1[v18 - 1] == 32)
      {
        int v23 = a1[v18];
LABEL_37:
        int v24 = v23 - 1591;
        if (v23 == 1574) {
          int v25 = 1;
        }
        else {
          int v25 = v15;
        }
        char v26 = (v24 != -5) & __CFADD__(v24, 5);
        int v27 = HIDWORD(v85);
        if (v26) {
          int v27 = 1;
        }
        HIDWORD(v85) = v27;
        if (!v26) {
          int v15 = v25;
        }
      }
      int v28 = byte_18CA86E7E[16 * (v12 & 3) + 4 * (v13 & 3) + (v11 & 3)];
      if ((v11 & 3) == 1)
      {
        v28 &= 1u;
        uint64_t v29 = v18;
        unsigned int v30 = a1[v18];
      }
      else
      {
        uint64_t v29 = v18;
        int v31 = &a1[v18];
        unsigned int v30 = *v31;
        if (v30 - 1619 >= 0xFFFFFFF8)
        {
          if (v13 & 2) != 0 && a5 == 1 && (v12)
          {
            if ((v30 & 0xFFFE) == 0x64C)
            {
              int v28 = 0;
            }
            else
            {
              int v28 = (v12 & 0x20) == 0;
              if ((v13 & 0x10) == 0) {
                int v28 = 1;
              }
            }
          }
          else
          {
            int v28 = 0;
            if (a5 == 2 && v30 == 1617)
            {
              LOWORD(v28) = 1;
LABEL_64:
              __int16 v32 = byte_18CA86EBE[v30 - 1611];
              LOWORD(v28) = v28 - 400;
LABEL_66:
              *int v31 = v28 + v32;
              goto LABEL_67;
            }
          }
        }
      }
      if ((v30 ^ 0x600) <= 0xFF)
      {
        int v31 = &a1[v29];
        if (v30 - 1619 < 0xFFFFFFF8)
        {
          if ((v11 & 8) != 0)
          {
            v28 += v11 >> 8;
            __int16 v32 = -1200;
          }
          else
          {
            if (v11 < 0x100 || (v11 & 4) != 0) {
              goto LABEL_67;
            }
            v28 += v11 >> 8;
            __int16 v32 = -400;
          }
          goto LABEL_66;
        }
        if (a5 != 2 || v30 == 1617) {
          goto LABEL_64;
        }
        *int v31 = -2;
        int v81 = 1;
      }
LABEL_67:
      if ((v11 & 4) == 0)
      {
        int v10 = v18;
        unsigned int v14 = v13;
        unsigned int v13 = v11;
      }
      int v17 = v18 - 1;
      if (v18 - 1 == v16)
      {
        int v16 = -2;
        unsigned int v11 = v12;
        if (!v18) {
          goto LABEL_77;
        }
      }
      else
      {
        if (!v18) {
          goto LABEL_77;
        }
        unsigned int v11 = sub_18C8AF4A4(a1[v17]);
      }
    }
  }
  uint64_t v85 = 0;
  int v15 = 0;
  int v81 = 0;
LABEL_77:
  uint64_t v33 = a2;
  uint64_t v34 = a2;
  if (v85 | v81)
  {
    int v35 = *((_DWORD *)a6 + 1);
    int v36 = *((_DWORD *)a6 + 2);
    int v37 = *((_DWORD *)a6 + 3);
    int v38 = *((_DWORD *)a6 + 4);
    int v39 = *((_DWORD *)a6 + 5);
    size_t v40 = (int)(2 * a2 + 2);
    size_t v41 = (char *)uprv_malloc(v40);
    if (!v41)
    {
      uint64_t v34 = 0;
      *a4 = 7;
      goto LABEL_156;
    }
    int v42 = v41;
    int v84 = v39;
    int v86 = v38;
    int v43 = a3 & 0xE0000;
    int v44 = a3 & 0x10003;
    if ((a3 & 0x10003) != 0)
    {
      uint64_t v34 = a2;
      if (v43 != 0x80000)
      {
LABEL_105:
        if (v44 == 1)
        {
          uint64_t v34 = a2;
          if ((int)a2 < 1)
          {
            if (v35 == 1)
            {
LABEL_115:
              BOOL v58 = v43 == v37;
              char v59 = 1;
              goto LABEL_116;
            }
LABEL_163:
            if (v43 != v37) {
              goto LABEL_133;
            }
            char v59 = 0;
            BOOL v58 = 1;
LABEL_116:
            bzero(v42, v40);
            if ((a2 & 0x80000000) == 0)
            {
              int v60 = 0;
              signed int v61 = a2;
              uint64_t v62 = a2;
              do
              {
                int v63 = a1[v62];
                if (v63 == 0xFFFF) {
                  char v64 = v59;
                }
                else {
                  char v64 = 0;
                }
                BOOL v65 = v63 == 65534 && v58;
                if ((v64 & 1) != 0 || v65)
                {
                  ++v61;
                  ++v60;
                }
                else
                {
                  *(_WORD *)&v42[2 * v61] = v63;
                }
                --v61;
                char v26 = v62-- <= 0;
              }
              while (!v26);
              if (v60 >= 1) {
                memset_pattern16(v42, asc_18CA86F00, 2 * v60);
              }
            }
            uint64_t v34 = a2;
            u_memcpy(a1, (const UChar *)v42, a2);
LABEL_133:
            if (v44 == v36 || v44 == 0x10000 && !v84)
            {
              BOOL v66 = v43 == v86;
              char v67 = 1;
              uint64_t v33 = a2;
            }
            else
            {
              BOOL v51 = v43 == v86;
              uint64_t v33 = a2;
              if (!v51) {
                goto LABEL_155;
              }
              char v67 = 0;
              BOOL v66 = 1;
            }
            bzero(v42, v40);
            if ((int)v33 < 1)
            {
              unsigned int v68 = 0;
              uint64_t v76 = 0;
            }
            else
            {
              unsigned int v68 = 0;
              int v69 = 0;
              uint64_t v70 = v33;
              uint64_t v71 = a1;
              do
              {
                int v73 = *v71++;
                int v72 = v73;
                if (v73 == 0xFFFF) {
                  char v74 = v67;
                }
                else {
                  char v74 = 0;
                }
                BOOL v75 = v72 == 65534 && v66;
                if ((v74 & 1) != 0 || v75)
                {
                  --v69;
                  ++v68;
                }
                else
                {
                  *(_WORD *)&v42[2 * v69] = v72;
                }
                ++v69;
                --v70;
              }
              while (v70);
              if ((v68 & 0x80000000) != 0) {
                goto LABEL_154;
              }
              uint64_t v76 = 2 * v33;
            }
            memset_pattern16(&v42[v76 - 2 * v68], asc_18CA86F00, 2 * (v68 + 1));
LABEL_154:
            u_memcpy(a1, (const UChar *)v42, v33);
            uint64_t v34 = v33;
LABEL_155:
            uprv_free(v42);
            goto LABEL_156;
          }
          uint64_t v56 = a2;
          uint64_t v57 = a1;
          do
          {
            if ((__int16)*v57 == -1) {
              UChar *v57 = 32;
            }
            ++v57;
            --v56;
          }
          while (v56);
          uint64_t v34 = a2;
        }
        if (v44 == v35 || v44 == 0x10000 && v84 == 1) {
          goto LABEL_115;
        }
        goto LABEL_163;
      }
    }
    bzero(v41, v40);
    if ((int)a2 < 1)
    {
      unsigned int v45 = 0;
      unsigned int v55 = 0;
    }
    else
    {
      unsigned int v45 = 0;
      int v46 = 0;
      int v47 = a1;
      uint64_t v48 = a2;
      do
      {
        int v50 = *v47++;
        int v49 = v50;
        BOOL v51 = v43 == 0x80000 && v49 == 65534;
        int v52 = v51;
        if ((v49 != 0xFFFF || v44 != 0) && v52 == 0)
        {
          *(_WORD *)&v42[2 * v46] = v49;
        }
        else
        {
          --v46;
          ++v45;
        }
        ++v46;
        --v48;
      }
      while (v48);
      unsigned int v55 = a2;
      if ((v45 & 0x80000000) != 0) {
        goto LABEL_104;
      }
    }
    bzero(&v42[2 * (v55 - (unint64_t)v45)], 2 * (v45 + 1));
LABEL_104:
    u_memcpy(a1, (const UChar *)v42, a2);
    uint64_t v34 = u_strlen(a1);
    goto LABEL_105;
  }
LABEL_156:
  if (HIDWORD(v85) | v15)
  {
    long long v87 = *a6;
    uint64_t v88 = *((void *)a6 + 2);
    return sub_18C8B018C(a1, v33, v34, a3, a4, 0, (uint64_t)&v87);
  }
  return v34;
}

uint64_t sub_18C8AFDC4(_WORD *a1, uint64_t a2)
{
  if ((int)a2 >= 1)
  {
    for (uint64_t i = a2; i; --i)
    {
      int v3 = (unsigned __int16)*a1;
      if ((v3 & 0xFFF0) == 0xFE70)
      {
        if (v3 != 65139 && v3 != 65141)
        {
          if (v3 == 65149) {
            goto LABEL_24;
          }
          if ((0xAA82uLL >> (v3 - 112)))
          {
            LOWORD(v3) = 1600;
            goto LABEL_24;
          }
          if (v3 != 65139 && v3 != 65141)
          {
            int v5 = 1 - byte_18CA86EDA[v3 - 65136];
            goto LABEL_20;
          }
        }
      }
      else if ((v3 - 64754) < 3 || v3 == 65149)
      {
        LOWORD(v3) = -387;
        goto LABEL_24;
      }
      int v5 = (unsigned __int16)(v3 + 930) < 6u;
LABEL_20:
      if (v3 == 65148 || !v5) {
        goto LABEL_25;
      }
      LOWORD(v3) = 32;
LABEL_24:
      *a1 = v3;
LABEL_25:
      ++a1;
    }
  }
  return a2;
}

uint64_t sub_18C8AFEA8(UChar *a1, uint64_t a2, int a3, _DWORD *a4, long long *a5)
{
  unint64_t v7 = (a2 - 1);
  if ((int)a2 < 1) {
    return a2;
  }
  uint64_t v20 = v5;
  uint64_t v21 = v6;
  unint64_t v8 = 0;
  int v9 = 0;
  do
  {
    int v10 = a1[v8];
    if ((unsigned __int16)(v10 + 1200) > 0xAFu)
    {
      if ((a3 & 0x3800000) == 0x1000000 && (v10 == 65152 || v10 == 1569) && v8 < v7)
      {
        unsigned int v12 = &a1[v8];
        int v13 = v12[1];
        if ((v13 - 65263) < 2 || v13 == 1609)
        {
          LOWORD(v10) = 32;
          a1[v8] = 32;
          v12[1] = 1574;
          goto LABEL_27;
        }
      }
      if ((a3 & 0x700000) != 0x200000
        || (v10 != 8203 ? (BOOL v14 = v10 == 65139) : (BOOL v14 = 1),
            v14 ? (BOOL v15 = v8 >= v7) : (BOOL v15 = 1),
            v15
         || (UChar v16 = a1[v8 + 1], (unsigned __int16)(v16 + 335) > 0xDu)
         || ((0xCCCuLL >> (v16 + 79)) & 1) != 0))
      {
        if ((unsigned __int16)(v10 + 400) > 0x84u) {
          goto LABEL_27;
        }
        LOWORD(v10) = word_18CA86D64[v10 - 65136];
      }
      else
      {
        LOWORD(v10) = 32;
      }
      a1[v8] = v10;
    }
    else
    {
      unsigned __int16 v11 = word_18CA86C04[v10 - 64336];
      if (v11)
      {
        a1[v8] = v11;
        LOWORD(v10) = v11;
      }
    }
LABEL_27:
    if ((unsigned __int16)(v10 + 259) >= 0xFFF8u) {
      int v9 = 1;
    }
    ++v8;
  }
  while (a2 != v8);
  if (v9)
  {
    long long v18 = *a5;
    uint64_t v19 = *((void *)a5 + 2);
    return sub_18C8B018C(a1, a2, a2, a3, a4, 1, (uint64_t)&v18);
  }
  return a2;
}

uint64_t sub_18C8B0070(uint64_t result, int a2, __int16 a3, int a4, unsigned __int8 a5)
{
  uint64_t v5 = (_WORD *)result;
  int v6 = a5;
  __int16 v7 = a3 - 48;
  if (a4)
  {
    if (a2 >= 1)
    {
      uint64_t v8 = a2;
      do
      {
        unsigned int v9 = (unsigned __int16)*v5;
        uint64_t result = ubidi_getClass(v9);
        if (result < 2)
        {
          int v6 = 0;
        }
        else if (result == 2)
        {
          if (v6)
          {
            if (v9 - 48 <= 9) {
              *uint64_t v5 = v9 + v7;
            }
            int v6 = 1;
          }
        }
        else if (result == 13)
        {
          int v6 = 1;
        }
        ++v5;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    unsigned int v10 = a2 - 1;
    if (a2 >= 1)
    {
      uint64_t v11 = a2 + 1;
      do
      {
        unsigned int v12 = (unsigned __int16)v5[v10];
        uint64_t v13 = v10;
        uint64_t result = ubidi_getClass(v12);
        if (result < 2)
        {
          int v6 = 0;
        }
        else if (result == 2)
        {
          if (v6)
          {
            if (v12 - 48 <= 9) {
              v5[v13] = v12 + v7;
            }
            int v6 = 1;
          }
        }
        else if (result == 13)
        {
          int v6 = 1;
        }
        --v11;
        unsigned int v10 = v13 - 1;
      }
      while (v11 > 1);
    }
  }
  return result;
}

uint64_t sub_18C8B018C(UChar *a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, int a6, uint64_t a7)
{
  int v14 = a4 & 0x10003;
  if ((a4 & 0x10003) == 0x10000 && a6 == 1)
  {
    if (*(_DWORD *)(a7 + 20))
    {
      uint64_t v19 = sub_18C8B072C(a1, a2, a5);
      if (*a5 == 20)
      {
        *a5 = 0;
        uint64_t v20 = sub_18C8B057C(a1, a2, a5);
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v19 = sub_18C8B057C(a1, a2, a5);
      if (*a5 == 20)
      {
        *a5 = 0;
        uint64_t v20 = sub_18C8B072C(a1, a2, a5);
LABEL_17:
        a3 = v20;
        if (*a5 != 20) {
          goto LABEL_27;
        }
        *a5 = 0;
        a3 = a2;
        if ((int)a2 < 1) {
          goto LABEL_27;
        }
        uint64_t v21 = a2;
        int v22 = a1 + 1;
        do
        {
          uint64_t v23 = (unsigned __int16)*v22;
          if ((unsigned __int16)(v23 + 259) >= 0xFFF8u)
          {
            if (*(v22 - 1) == 32)
            {
              *int v22 = 1604;
              *(v22 - sub_18C8A49A0((uint64_t)this, 1) = word_18CA86EC6[v23 - 65269];
            }
            else
            {
              *a5 = 20;
            }
          }
          ++v22;
          --v21;
        }
        while (v21);
        a3 = a2;
        goto LABEL_5;
      }
    }
    a3 = v19;
    goto LABEL_27;
  }
LABEL_5:
  if (a6 != 1)
  {
    BOOL v16 = (a4 & 0x3800000) == 0x1000000;
    BOOL v17 = (a4 & 0x700000) == 0x200000;
    if (a6)
    {
      BOOL v16 = 0;
      BOOL v18 = 0;
    }
    else
    {
      BOOL v18 = (a4 & 0x700000) == 0x200000;
    }
    if (a6) {
      BOOL v17 = 0;
    }
    goto LABEL_32;
  }
LABEL_27:
  if (v14 == *(_DWORD *)(a7 + 8)) {
    a3 = sub_18C8B057C(a1, a2, a5);
  }
  if (v14 == *(_DWORD *)(a7 + 4)) {
    a3 = sub_18C8B072C(a1, a2, a5);
  }
  BOOL v16 = 0;
  BOOL v18 = 0;
  BOOL v17 = 0;
LABEL_32:
  BOOL v24 = v14 == 1 && a6 == 1;
  int v25 = v24;
  if (v24 || v16 || v18)
  {
    a3 = a2;
    if ((int)a2 >= 1)
    {
      uint64_t v26 = 0;
      UChar v27 = *(_WORD *)a7;
      while (1)
      {
        if (!v17
          || (UChar v28 = a1[v26], (unsigned __int16)(v28 + 335) > 0xDu)
          || ((0xCCCuLL >> (v28 + 79)) & 1) != 0)
        {
          if (v16 && (uint64_t v30 = a1[v26], (unsigned __int16)(v30 + 373) >= 0xFFFEu))
          {
            if (!v26) {
              goto LABEL_58;
            }
            uint64_t v33 = (v26 - 1);
            if (a1[v33] != 32) {
              goto LABEL_58;
            }
            a1[v26] = word_18CA86ED6[v30 - 65161];
            a1[v33] = -384;
          }
          else
          {
            if (!v25) {
              goto LABEL_59;
            }
            int v31 = &a1[v26];
            uint64_t v32 = v31[1];
            if ((unsigned __int16)(v32 + 259) < 0xFFF8u) {
              goto LABEL_59;
            }
            if (a1[v26] != 32)
            {
LABEL_58:
              *a5 = 20;
              goto LABEL_59;
            }
            v31[1] = 1604;
            a1[v26] = word_18CA86EC6[v32 - 65269];
          }
        }
        else
        {
          if (!v26) {
            goto LABEL_58;
          }
          uint64_t v29 = (v26 - 1);
          if (a1[v29] != 32) {
            goto LABEL_58;
          }
          a1[v29] = v27;
        }
LABEL_59:
        if (a2 == ++v26)
        {
          a3 = a2;
          break;
        }
      }
    }
  }
  if (!v14 && a6 == 1)
  {
    a3 = sub_18C8AF540((__int16 *)a1, a2, a4);
    size_t v34 = 2 * (int)a3 + 2;
    int v35 = (UChar *)uprv_malloc(v34);
    if (v35)
    {
      int v36 = v35;
      bzero(v35, v34);
      if ((int)a3 >= 1)
      {
        uint64_t v37 = 0;
        int v38 = 0;
        do
        {
          uint64_t v39 = a1[v37];
          if ((unsigned __int16)(v39 + 259) >= 0xFFF8u)
          {
            v36[v38++] = word_18CA86EC6[v39 - 65269];
            LOWORD(v39) = 1604;
          }
          v36[v38] = v39;
          if (++v37 >= (unint64_t)a3) {
            break;
          }
          ++v38;
        }
        while (v38 < (int)a3);
      }
      u_memcpy(a1, v36, a3);
      uprv_free(v36);
    }
    else
    {
      a3 = 0;
      *a5 = 7;
    }
  }
  return a3;
}

uint64_t sub_18C8B057C(UChar *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4 = a2;
  size_t v6 = 2 * (int)a2 + 2;
  __int16 v7 = (UChar *)uprv_malloc(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    bzero(v7, v6);
    int v9 = 0;
    int v10 = v4 - 1;
    uint64_t v11 = 2 * (int)v4 - 2;
    do
    {
      int v12 = *(UChar *)((char *)a1 + v11);
      ++v9;
      v11 -= 2;
    }
    while (v12 == 32);
    uint64_t v13 = (v4 - v9);
    int v14 = v9 - 1;
    if ((v13 & 0x80000000) == 0 && (int)v4 >= 1)
    {
      int v15 = v4 - 1;
      while (1)
      {
        if (v14 < 1)
        {
          LOWORD(v16) = a1[v13];
          if (!v14 && (unsigned __int16)(v16 + 259) >= 0xFFF8u) {
            *a3 = 20;
          }
        }
        else
        {
          uint64_t v16 = a1[v13];
          if ((unsigned __int16)(v16 + 259) >= 0xFFF8u)
          {
            v8[v15--] = 1604;
            v8[v15] = word_18CA86EC6[v16 - 65269];
            --v14;
            goto LABEL_14;
          }
        }
        v8[v15] = v16;
LABEL_14:
        if ((int)v13 >= 1)
        {
          --v13;
          if (v15-- > 0) {
            continue;
          }
        }
        break;
      }
    }
    if (v14 >= 1)
    {
      u_memmove(v8, &v8[v14], v4);
      if (u_strlen(v8) < (int)v4)
      {
        int v18 = v4 - v14;
        if ((int)v4 - v14 >= v10) {
          int v18 = v4 - 1;
        }
        memset_pattern16(&v8[(int)v4 - (v10 - v18) - 1], asc_18CA86F00, 2 * (v10 - v18) + 2);
      }
    }
    u_memcpy(a1, v8, v4);
    uprv_free(v8);
  }
  else
  {
    uint64_t v4 = 0;
    *a3 = 7;
  }
  return v4;
}

uint64_t sub_18C8B072C(UChar *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4 = a2;
  size_t v6 = 2 * (int)a2 + 2;
  __int16 v7 = (UChar *)uprv_malloc(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    bzero(v7, v6);
    if (*a1 == 32)
    {
      uint64_t v9 = 0;
      do
        int v10 = a1[++v9];
      while (v10 == 32);
    }
    else
    {
      LODWORD(v9) = 0;
    }
    uint64_t v11 = (v4 - 1);
    if ((int)v4 >= 1)
    {
      int v12 = v4 - 1;
      while (1)
      {
        if ((int)v9 < 1)
        {
          LOWORD(v13) = a1[v11];
          if (!v9 && (unsigned __int16)(v13 + 259) >= 0xFFF8u) {
            *a3 = 20;
          }
        }
        else
        {
          uint64_t v13 = a1[v11];
          if ((unsigned __int16)(v13 + 259) >= 0xFFF8u)
          {
            v8[v12--] = 1604;
            v8[v12] = word_18CA86EC6[v13 - 65269];
            LODWORD(v9) = v9 - 1;
            goto LABEL_17;
          }
        }
        v8[v12] = v13;
LABEL_17:
        BOOL v14 = v11-- < 1;
        if (!v14)
        {
          BOOL v14 = v12-- <= 0;
          if (!v14) {
            continue;
          }
        }
        break;
      }
    }
    u_memcpy(a1, v8, v4);
    uprv_free(v8);
  }
  else
  {
    uint64_t v4 = 0;
    *a3 = 7;
  }
  return v4;
}

uint64_t usprep_open(char *a1, const char *a2, int *a3)
{
  if (a3 && *a3 <= 0)
  {
    if (atomic_load_explicit((atomic_uint *volatile)&dword_1E9191F38, memory_order_acquire) == 2
      || !icu::umtx_initImplPreInit((atomic_uint *)&dword_1E9191F38))
    {
      if (dword_1E9191F3C >= 1)
      {
        uint64_t v4 = 0;
        *a3 = dword_1E9191F3C;
        return v4;
      }
    }
    else
    {
      sub_18C8B1948(a3);
      dword_1E9191F3C = *a3;
      icu::umtx_initImplPostInit(&dword_1E9191F38);
    }
    if (*a3 <= 0)
    {
      v33[0] = a2;
      v33[1] = a1;
      umtx_lock((atomic_ullong *)&unk_1E9191F48);
      uint64_t v8 = uhash_get(qword_1E9191F30, (uint64_t)v33);
      if (v8)
      {
        uint64_t v4 = v8;
        ++*(_DWORD *)(v8 + 120);
        umtx_unlock((std::mutex **)&unk_1E9191F48);
        return v4;
      }
      umtx_unlock((std::mutex **)&unk_1E9191F48);
      uint64_t v9 = (uint64_t *)uprv_malloc(0x80uLL);
      int v10 = v9;
      if (!v9)
      {
        *a3 = 7;
LABEL_20:
        uprv_free(v10);
        return 0;
      }
      *((_OWORD *)v9 + 6) = 0u;
      *((_OWORD *)v9 + 7) = 0u;
      *((_OWORD *)v9 + 4) = 0u;
      *((_OWORD *)v9 + 5) = 0u;
      *((_OWORD *)v9 + 2) = 0u;
      *((_OWORD *)v9 + 3) = 0u;
      *(_OWORD *)uint64_t v9 = 0u;
      *((_OWORD *)v9 + sub_18C8A49A0((uint64_t)this, 1) = 0u;
      uprv_free(0);
      uint64_t v37 = 0;
      long long v35 = 0u;
      long long v36 = 0u;
      if (*a3 > 0) {
        goto LABEL_20;
      }
      uint64_t v11 = udata_openChoice(a1, "spp", a2, (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_18C8B1B5C, 0, (UErrorCode *)a3);
      if (*a3 > 0) {
        goto LABEL_20;
      }
      int v12 = v11;
      *(_DWORD *)UVersionInfo versionArray = 0;
      uint64_t Memory = udata_getMemory((uint64_t)v11);
      utrie_unserialize((uint64_t)&v35, (_DWORD *)(Memory + 64), *(_DWORD *)Memory, a3);
      *(void *)&long long v36 = nullsub_21;
      if (*a3 > 0) {
        goto LABEL_23;
      }
      umtx_lock((atomic_ullong *)&unk_1E9191F48);
      uint64_t v14 = v10[14];
      if (v14)
      {
        uint64_t Memory = udata_getMemory(v14);
      }
      else
      {
        _OWORD v10[14] = (uint64_t)v12;
        long long v15 = *(_OWORD *)Memory;
        long long v16 = *(_OWORD *)(Memory + 16);
        long long v17 = *(_OWORD *)(Memory + 48);
        *((_OWORD *)v10 + 2) = *(_OWORD *)(Memory + 32);
        *((_OWORD *)v10 + 3) = v17;
        *(_OWORD *)int v10 = v15;
        *((_OWORD *)v10 + sub_18C8A49A0((uint64_t)this, 1) = v16;
        long long v18 = v36;
        *((_OWORD *)v10 + 4) = v35;
        *((_OWORD *)v10 + 5) = v18;
        _OWORD v10[12] = v37;
        int v12 = 0;
      }
      umtx_unlock((std::mutex **)&unk_1E9191F48);
      v10[13] = Memory + *(int *)v10 + 64;
      u_getUnicodeVersion(versionArray);
      if (*a3 > 0)
      {
LABEL_23:
        udata_close(v12);
        goto LABEL_20;
      }
      signed int v19 = bswap32(*(unsigned int *)versionArray);
      if (v19 < (int)bswap32(dword_1E9191F40) && v19 < *((_DWORD *)v10 + 2) && (*((unsigned char *)v10 + 28) & 1) != 0)
      {
        *a3 = 3;
        goto LABEL_23;
      }
      *((unsigned char *)v10 + 124) = 1;
      if (v12)
      {
        udata_close(v12);
        if (!*((unsigned char *)v10 + 124) || *a3 > 0) {
          goto LABEL_20;
        }
      }
      char v20 = *((unsigned char *)v10 + 28);
      *((unsigned char *)v10 + 125) = v20 & 1;
      *((unsigned char *)v10 + 126) = (v20 & 2) != 0;
      uint64_t v21 = (char **)uprv_malloc(0x10uLL);
      uint64_t v32 = v21;
      if (v21)
      {
        *uint64_t v21 = 0;
        v21[1] = 0;
        uprv_free(0);
        unsigned int v22 = strlen(a2);
        uint64_t v23 = 0;
        if (v22 <= 0x7FFFFFFE)
        {
          uint64_t v23 = (char *)uprv_malloc(v22 + 1);
          if (v23)
          {
            uprv_free(0);
            if (!a1)
            {
              int v31 = 0;
              goto LABEL_43;
            }
            unsigned int v24 = strlen(a1);
            if (v24 <= 0x7FFFFFFE)
            {
              int v31 = (char *)uprv_malloc(v24 + 1);
              if (v31)
              {
                uprv_free(0);
LABEL_43:
                umtx_lock((atomic_ullong *)&unk_1E9191F48);
                uint64_t v28 = uhash_get(qword_1E9191F30, (uint64_t)v33);
                if (v28)
                {
                  uint64_t v29 = (uint64_t *)v28;
                  ++*(_DWORD *)(v28 + 120);
                  udata_close((_OWORD *)v10[14]);
                  uint64_t v30 = v10;
                  int v10 = v29;
                }
                else
                {
                  *uint64_t v32 = v23;
                  strcpy(v23, a2);
                  if (a1)
                  {
                    v32[1] = v31;
                    strcpy(v31, a1);
                    int v31 = 0;
                  }
                  *((_DWORD *)v10 + 30) = 1;
                  uhash_put(qword_1E9191F30, (uint64_t)v32, (uint64_t)v10, a3);
                  uint64_t v23 = 0;
                  uint64_t v30 = 0;
                  uint64_t v32 = 0;
                }
                uint64_t v26 = v10;
                umtx_unlock((std::mutex **)&unk_1E9191F48);
                int v27 = 1;
                int v10 = v30;
                int v25 = v31;
LABEL_40:
                uprv_free(v25);
                uprv_free(v23);
                uprv_free(v32);
                uprv_free(v10);
                uint64_t v4 = (uint64_t)v26;
                if (v27) {
                  return v4;
                }
                return 0;
              }
            }
          }
        }
      }
      else
      {
        uint64_t v23 = 0;
      }
      *a3 = 7;
      udata_close((_OWORD *)v10[14]);
      int v25 = 0;
      uint64_t v26 = 0;
      int v27 = 0;
      goto LABEL_40;
    }
  }
  return 0;
}

uint64_t usprep_openByType(unsigned int a1, int *a2)
{
  if (!a2 || *a2 > 0) {
    return 0;
  }
  if (a1 >= 0xE)
  {
    *a2 = 1;
    return 0;
  }
  return usprep_open(0, off_1E55088E0[a1], a2);
}

void usprep_close(uint64_t a1)
{
  if (a1)
  {
    umtx_lock((atomic_ullong *)&unk_1E9191F48);
    int v2 = *(_DWORD *)(a1 + 120);
    BOOL v3 = __OFSUB__(v2, 1);
    int v4 = v2 - 1;
    if (v4 < 0 == v3) {
      *(_DWORD *)(a1 + 120) = v4;
    }
    umtx_unlock((std::mutex **)&unk_1E9191F48);
  }
}

UChar *uprv_syntaxError(UChar *result, int a2, int a3, uint64_t a4)
{
  if (a4)
  {
    __int16 v7 = result;
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = a2;
    int v8 = a2 - 15;
    if (a2 < 16) {
      int v8 = 0;
    }
    uint64_t v9 = a4 + 8;
    int v10 = a2 - v8;
    uint64_t result = u_memcpy((UChar *)(a4 + 8), &result[v8], a2 - v8);
    *(_WORD *)(v9 + 2 * v10) = 0;
    int v11 = a2 + 15;
    if (a2 + 15 >= a3) {
      int v11 = a3;
    }
    if (a2 >= a3)
    {
      int32_t v13 = v11 - a2;
    }
    else
    {
      int v12 = &v7[a2];
      int32_t v13 = v11 - a2;
      uint64_t result = u_memcpy((UChar *)(a4 + 40), v12, v13);
    }
    *(_WORD *)(a4 + 2 * v13 + 40) = 0;
  }
  return result;
}

uint64_t usprep_prepare(uint64_t a1, UChar *s, int a3, UChar *a4, int a5, char a6, uint64_t a7, int *a8)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (*a8 <= 0)
  {
    if (a1)
    {
      int32_t v15 = a3;
      if (s)
      {
        if (a3 < -1) {
          goto LABEL_31;
        }
      }
      else if (a3)
      {
        goto LABEL_31;
      }
      if (a4)
      {
        if ((a5 & 0x80000000) == 0) {
          goto LABEL_10;
        }
      }
      else if (!a5)
      {
LABEL_10:
        if (a3 < 0) {
          int32_t v15 = u_strlen(s);
        }
        long long v62 = 0u;
        uint64_t v65 = 0;
        long long v64 = 0u;
        long long v63 = 0u;
        signed int v61 = (UChar *)&unk_1EDA47700;
        LOWORD(v62) = 2;
        uint64_t Buffer = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v61, v15);
        if (Buffer)
        {
          if ((v62 & 2) != 0) {
            int v18 = 27;
          }
          else {
            int v18 = DWORD2(v62);
          }
          int v19 = sub_18C8B13C0(a1, s, v15, Buffer, v18, a6, a7, a8);
          int v20 = v19;
          if (*a8 <= 0) {
            int v21 = v19;
          }
          else {
            int v21 = 0;
          }
          icu::UnicodeString::releaseBuffer((uint64_t)&v61, v21);
          uint64_t v23 = *a8;
          if (v23 != 15)
          {
LABEL_28:
            if ((int)v23 > 0)
            {
              uint64_t v8 = 0;
LABEL_102:
              icu::UnicodeString::~UnicodeString((void *)v23, (icu::UnicodeString *)&v61);
              return v8;
            }
            long long v57 = 0u;
            uint64_t v60 = 0;
            long long v59 = 0u;
            long long v58 = 0u;
            uint64_t v56 = (UChar *)&unk_1EDA47700;
            LOWORD(v57) = 2;
            if (*(unsigned char *)(a1 + 125))
            {
              v55[0] = &unk_1EDA43948;
              v55[1] = icu::Normalizer2::getNFKCInstance((icu::Normalizer2 *)a8, v22);
              v55[2] = sub_18C896F18((UErrorCode *)a8);
              if (*a8 > 0)
              {
                icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v55);
LABEL_100:
                uint64_t v8 = 0;
                goto LABEL_101;
              }
              icu::FilteredNormalizer2::normalize((icu::FilteredNormalizer2 *)v55, (const icu::UnicodeString *)&v61, (icu::UnicodeString *)&v56, (UErrorCode *)a8);
              icu::FilteredNormalizer2::~FilteredNormalizer2((icu::FilteredNormalizer2 *)v55);
            }
            else
            {
              icu::UnicodeString::fastCopyFrom(&v56, &v61);
            }
            uint64_t v29 = (UChar **)*a8;
            if ((int)v29 > 0) {
              goto LABEL_100;
            }
            if ((v57 & 0x11) != 0)
            {
              uint64_t v30 = 0;
            }
            else if ((v57 & 2) != 0)
            {
              uint64_t v30 = (UChar *)&v57 + 1;
            }
            else
            {
              uint64_t v30 = (UChar *)v58;
            }
            if ((v57 & 0x8000u) == 0) {
              int v31 = (unsigned __int16)v57 >> 5;
            }
            else {
              int v31 = DWORD1(v57);
            }
            if (v31 >= 1)
            {
              int v32 = 0;
              int v33 = 23;
              int v51 = -1;
              int v52 = 0;
              int v47 = -1;
              int v48 = 0;
              int v34 = 23;
              int v50 = v30;
              int v49 = v31;
              while (1)
              {
                uint64_t v35 = v32 + 1;
                unsigned int v36 = v30[v32];
                BOOL v37 = (v36 & 0xFC00) != 0xD800 || v35 == v31;
                if (v37 || (unsigned int v38 = v30[v35], (v38 & 0xFC00) != 0xDC00))
                {
                  if ((v36 & 0xFC00) == 0xD800) {
                    int v41 = 320;
                  }
                  else {
                    int v41 = 0;
                  }
                  unsigned int v40 = *(unsigned __int16 *)(*(void *)(a1 + 64)
                                            + 2
                                            * ((v36 & 0x1F)
                                             + 4
                                             * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2 * (v41 + (v36 >> 5)))));
                  int v42 = -1;
                  ++v32;
                }
                else
                {
                  v32 += 2;
                  unsigned int v36 = v38 + (v36 << 10) - 56613888;
                  if (v36 >= 0x110000)
                  {
                    unsigned int v40 = *(unsigned __int16 *)(a1 + 96);
                    int v42 = -2;
                  }
                  else
                  {
                    int v39 = (*(uint64_t (**)(void))(a1 + 80))(*(unsigned __int16 *)(*(void *)(a1 + 64)
                                                                                            + 2
                                                                                            * (((v36 >> 10) & 0x1F)
                                                                                             + 4
                                                                                             * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2 * (((v36 >> 10) + 55232) >> 5)))));
                    if (v39 < 1) {
                      unsigned int v40 = *(unsigned __int16 *)(a1 + 96);
                    }
                    else {
                      unsigned int v40 = *(unsigned __int16 *)(*(void *)(a1 + 64)
                    }
                                                + 2
                                                * ((v38 & 0x1F)
                                                 + 4
                                                 * *(unsigned __int16 *)(*(void *)(a1 + 64)
                                                                       + 2 * (v39 + ((v38 >> 5) & 0x1F)))));
                    int v42 = -2;
                    uint64_t v30 = v50;
                    int v31 = v49;
                  }
                }
                if (v40)
                {
                  if (v40 >> 4 <= 0xFFE)
                  {
                    if (v40)
                    {
LABEL_91:
                      *a8 = 66560;
                      int v46 = v32 + v42;
                      goto LABEL_99;
                    }
                  }
                  else if (v40 == 65522)
                  {
                    goto LABEL_91;
                  }
                }
                if (*(unsigned char *)(a1 + 126))
                {
                  int Class = ubidi_getClass(v36);
                  int v34 = Class;
                  if (v33 == 23) {
                    int v33 = Class;
                  }
                  if (Class) {
                    int v44 = v52;
                  }
                  else {
                    int v44 = 1;
                  }
                  int v45 = v51;
                  if (!Class) {
                    int v45 = v32 - 1;
                  }
                  int v51 = v45;
                  int v52 = v44;
                  if (Class == 13 || Class == 1)
                  {
                    int v47 = v32 - 1;
                    int v48 = 1;
                  }
                  uint64_t v30 = v50;
                  int v31 = v49;
                }
                if (v32 >= v31) {
                  goto LABEL_85;
                }
              }
            }
            int v47 = -1;
            int v48 = 0;
            int v34 = 23;
            int v33 = 23;
            int v51 = -1;
            LOBYTE(v52) = 0;
LABEL_85:
            if (*(unsigned char *)(a1 + 126))
            {
              if ((_BYTE)v52 && v48)
              {
                *a8 = 66562;
                if (v47 <= v51) {
                  int v46 = v51;
                }
                else {
                  int v46 = v47;
                }
                goto LABEL_99;
              }
              if (v48 && (v33 != 13 && v33 != 1 || v34 != 1 && v34 != 13))
              {
                *a8 = 66562;
                int v46 = v47;
LABEL_99:
                uprv_syntaxError(v30, v46, v31, a7);
                goto LABEL_100;
              }
            }
            int v54 = a4;
            uint64_t v8 = icu::UnicodeString::extract((uint64_t)&v56, &v54, a5, a8);
            int v53 = v54;
            uint64_t v29 = &v53;
LABEL_101:
            icu::UnicodeString::~UnicodeString(v29, (icu::UnicodeString *)&v56);
            goto LABEL_102;
          }
          uint64_t v24 = icu::UnicodeString::getBuffer((icu::UnicodeString *)&v61, v20);
          if (v24)
          {
            *a8 = 0;
            if ((v62 & 2) != 0) {
              int v25 = 27;
            }
            else {
              int v25 = DWORD2(v62);
            }
            int v26 = sub_18C8B13C0(a1, s, v15, v24, v25, a6, a7, a8);
            if (*a8 <= 0) {
              int v27 = v26;
            }
            else {
              int v27 = 0;
            }
            icu::UnicodeString::releaseBuffer((uint64_t)&v61, v27);
            uint64_t v23 = *a8;
            goto LABEL_28;
          }
        }
        uint64_t v8 = 0;
        uint64_t v23 = 7;
        *a8 = 7;
        goto LABEL_102;
      }
    }
LABEL_31:
    uint64_t v8 = 0;
    *a8 = 1;
    return v8;
  }
  return 0;
}

uint64_t sub_18C8B13C0(uint64_t a1, UChar *a2, int a3, uint64_t a4, int a5, char a6, uint64_t a7, int *a8)
{
  if (a3 >= 1)
  {
    int v13 = 0;
    uint64_t v14 = 0;
    int v15 = a6 & 1;
    int v36 = v15;
    while (1)
    {
      uint64_t v16 = v13 + 1;
      unsigned int v17 = a2[v13];
      BOOL v18 = (v17 & 0xFC00) != 0xD800 || v16 == a3;
      if (v18 || (unsigned int v19 = a2[v16], (v19 & 0xFC00) != 0xDC00))
      {
        int v22 = (v17 & 0xFC00) == 0xD800 ? 320 : 0;
        LOWORD(v2sub_18C8A49A0((uint64_t)this, 1) = *(_WORD *)(*(void *)(a1 + 64)
                               + 2
                               * ((v17 & 0x1F)
                                + 4 * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2 * (v22 + (v17 >> 5)))));
        int v23 = -1;
        ++v13;
      }
      else
      {
        v13 += 2;
        unsigned int v17 = v19 + (v17 << 10) - 56613888;
        if (v17 >= 0x110000)
        {
          int v21 = *(_DWORD *)(a1 + 96);
          int v23 = -2;
        }
        else
        {
          int v20 = (*(uint64_t (**)(void, uint64_t))(a1 + 80))(*(unsigned __int16 *)(*(void *)(a1 + 64)+ 2* (((v17 >> 10) & 0x1F)+ 4* *(unsigned __int16 *)(*(void *)(a1 + 64) + 2 * (((v17 >> 10) + 55232) >> 5)))), 4238353408);
          if (v20 < 1) {
            int v21 = *(_DWORD *)(a1 + 96);
          }
          else {
            LOWORD(v2sub_18C8A49A0((uint64_t)this, 1) = *(_WORD *)(*(void *)(a1 + 64)
          }
                                   + 2
                                   * ((v19 & 0x1F)
                                    + 4
                                    * *(unsigned __int16 *)(*(void *)(a1 + 64) + 2 * (v20 + ((v19 >> 5) & 0x1F)))));
          int v23 = -2;
          int v15 = v36;
        }
      }
      unsigned int v24 = (unsigned __int16)v21;
      if (!(_WORD)v21) {
        break;
      }
      if ((unsigned __int16)v21 >> 4 >= 0xFFFu)
      {
        int v25 = (unsigned __int16)v21 - 65520;
LABEL_23:
        LOWORD(v26) = 0;
        int v27 = 0;
        goto LABEL_24;
      }
      int v26 = (__int16)v21 >> 2;
      if ((v24 & 2) != 0) {
        LOWORD(v26) = v24 >> 2;
      }
      if ((v24 & 0xFFFC) == 0xFEFC)
      {
        int v25 = 3;
        goto LABEL_23;
      }
      int v27 = (v24 & 2) >> 1;
      int v25 = 1;
LABEL_24:
      if (!(v25 | v15))
      {
        uprv_syntaxError(a2, v13 + v23, a3, a7);
        *a8 = 66561;
        return 0;
      }
      if (v25 != 3)
      {
        if (v25 != 1) {
          goto LABEL_34;
        }
        int v28 = (__int16)v26;
        if (!v27)
        {
          v17 -= (__int16)v26;
LABEL_34:
          if ((int)v17 >= 0x10000)
          {
            uint64_t v31 = (int)v14 + 1;
            if ((int)v31 < a5)
            {
              *(_WORD *)(a4 + 2 * (int)v14) = (v17 >> 10) - 10304;
              *(_WORD *)(a4 + 2 * v3sub_18C8A49A0((uint64_t)this, 1) = v17 & 0x3FF | 0xDC00;
            }
            uint64_t v14 = (v14 + 2);
          }
          else
          {
            if ((int)v14 < a5) {
              *(_WORD *)(a4 + 2 * (int)v14) = v17;
            }
            uint64_t v14 = (v14 + 1);
          }
          goto LABEL_55;
        }
        int v29 = *(_DWORD *)(a1 + 16);
        if (*(_DWORD *)(a1 + 12) <= (__int16)v26 && v29 > (__int16)v26)
        {
          uint64_t v30 = 1;
          goto LABEL_51;
        }
        int v32 = *(_DWORD *)(a1 + 20);
        if (v29 <= (__int16)v26 && v32 > (__int16)v26)
        {
          uint64_t v30 = 2;
          goto LABEL_51;
        }
        if (v32 <= (__int16)v26 && *(_DWORD *)(a1 + 24) > (__int16)v26)
        {
          uint64_t v30 = 3;
          goto LABEL_51;
        }
        uint64_t v30 = *(unsigned __int16 *)(*(void *)(a1 + 104) + 2 * (__int16)v26);
        if (v30)
        {
          ++v28;
LABEL_51:
          uint64_t v14 = (int)v14;
          uint64_t v33 = 2 * v28;
          do
          {
            if (v14 < a5) {
              *(_WORD *)(a4 + 2 * v14) = *(_WORD *)(*(void *)(a1 + 104) + v33);
            }
            ++v14;
            v33 += 2;
            --v30;
          }
          while (v30);
        }
      }
LABEL_55:
      if (v13 >= a3) {
        goto LABEL_58;
      }
    }
    int v25 = 4;
    goto LABEL_23;
  }
  uint64_t v14 = 0;
LABEL_58:

  return u_terminateUChars(a4, a5, v14, a8);
}

uint64_t usprep_swap(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a3;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v13 = udata_swapDataHeader(a1, (unsigned __int16 *)a2, a3, a4, a5, a6, a7, a8);
  if (!a5 || *a5 > 0) {
    return 0;
  }
  uint64_t v21 = *(unsigned __int8 *)(a2 + 12);
  if (__PAIR64__(*(unsigned __int8 *)(a2 + 13), v21) != 0x5000000053
    || *(unsigned char *)(a2 + 14) != 82
    || *(unsigned char *)(a2 + 15) != 80
    || *(unsigned char *)(a2 + 16) != 3)
  {
    udata_printError(a1, (uint64_t)"usprep_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as StringPrep .spp data\n", v14, v15, v16, v17, v18, v19, v21);
    uint64_t result = 0;
    int v24 = 16;
LABEL_15:
    *a5 = v24;
    return result;
  }
  int v22 = v13;
  if (a4) {
    int v23 = (unsigned int *)((char *)a4 + v13);
  }
  else {
    int v23 = 0;
  }
  if ((v10 & 0x80000000) == 0)
  {
    uint64_t v10 = (v10 - v13);
    if ((int)v10 <= 63)
    {
      udata_printError(a1, (uint64_t)"usprep_swap(): too few bytes (%d after header) for StringPrep .spp data\n", v14, v15, v16, v17, v18, v19, v10);
LABEL_21:
      uint64_t result = 0;
      int v24 = 8;
      goto LABEL_15;
    }
  }
  uint64_t v25 = 0;
  int v26 = (unsigned int *)(a2 + v13);
  memset(v37, 0, sizeof(v37));
  do
  {
    *(_DWORD *)((char *)v37 + v25 * 4) = udata_readInt32(a1, v26[v25]);
    ++v25;
  }
  while (v25 != 16);
  uint64_t v33 = DWORD1(v37[0]);
  int v34 = v37[0];
  uint64_t v35 = SLODWORD(v37[0]) + 64;
  int v36 = v35 + DWORD1(v37[0]);
  if ((v10 & 0x80000000) == 0)
  {
    if ((int)v10 < v36)
    {
      udata_printError(a1, (uint64_t)"usprep_swap(): too few bytes (%d after header) for all of StringPrep .spp data\n", v27, v28, v29, v30, v31, v32, v10);
      goto LABEL_21;
    }
    if (v26 != v23) {
      memcpy(v23, v26, v36);
    }
    (*(void (**)(uint64_t, unsigned int *, uint64_t, unsigned int *, int *))(a1 + 56))(a1, v26, 64, v23, a5);
    utrie_swap(a1, v26 + 16, v34, (uint64_t)(v23 + 16), a5);
    (*(void (**)(uint64_t, char *, uint64_t, char *, int *))(a1 + 48))(a1, (char *)v26 + v35, v33, (char *)v23 + v35, a5);
  }
  return (v36 + v22);
}

void sub_18C8B1948(int *a1)
{
  int v2 = uhash_open((uint64_t)sub_18C8B19CC, (uint64_t)sub_18C8B1A08, 0, a1);
  if (*a1 >= 1) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = (uint64_t)v2;
  }
  qword_1E9191F30 = v3;

  sub_18C8546F4(1u, (uint64_t)sub_18C8B1A54);
}

uint64_t sub_18C8B19CC(unsigned __int8 **a1)
{
  int v1 = a1[1];
  unsigned int v2 = uhash_hashChars(*a1);
  return v2 + 37 * uhash_hashChars(v1);
}

uint64_t sub_18C8B1A08(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned int v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = uhash_compareChars(*a1, *a2);
  return uhash_compareChars(v2, v3) & v4;
}

BOOL sub_18C8B1A54()
{
  if (qword_1E9191F30)
  {
    int v8 = -1;
    umtx_lock((atomic_ullong *)&unk_1E9191F48);
    if (qword_1E9191F30)
    {
      uint64_t v0 = uhash_nextElement((uint64_t *)qword_1E9191F30, &v8);
      if (v0)
      {
        uint64_t v1 = v0;
        do
        {
          uint64_t v3 = *(_OWORD ***)(v1 + 8);
          uint64_t v2 = *(void *)(v1 + 16);
          uhash_removeElement(qword_1E9191F30, (_DWORD *)v1);
          udata_close(v3[14]);
          if (*(void *)v2)
          {
            uprv_free(*(void **)v2);
            *(void *)uint64_t v2 = 0;
          }
          BOOL v4 = *(void **)(v2 + 8);
          if (v4)
          {
            uprv_free(v4);
            *(void *)(v2 + 8) = 0;
          }
          uprv_free(v3);
          uprv_free((void *)v2);
          uint64_t v1 = uhash_nextElement((uint64_t *)qword_1E9191F30, &v8);
        }
        while (v1);
      }
    }
    umtx_unlock((std::mutex **)&unk_1E9191F48);
    uint64_t v5 = qword_1E9191F30;
    if (qword_1E9191F30)
    {
      int v6 = uhash_count(qword_1E9191F30);
      uint64_t v5 = qword_1E9191F30;
      if (!v6)
      {
        uhash_close((unsigned char *)qword_1E9191F30);
        uint64_t v5 = 0;
        qword_1E9191F30 = 0;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  atomic_store(0, &dword_1E9191F38);
  return v5 == 0;
}

uint64_t sub_18C8B1B5C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4)
{
  if (*a4 < 0x14u
    || *((unsigned char *)a4 + 4)
    || *((unsigned char *)a4 + 5)
    || *((unsigned char *)a4 + 8) != 83
    || *((unsigned char *)a4 + 9) != 80
    || *((unsigned char *)a4 + 10) != 82
    || *((unsigned char *)a4 + 11) != 80
    || *((unsigned char *)a4 + 12) != 3
    || *((unsigned char *)a4 + 14) != 5
    || *((unsigned char *)a4 + 15) != 2)
  {
    return 0;
  }
  dword_1E9191F40 = *((_DWORD *)a4 + 4);
  return 1;
}

void *icu::UStack::getStaticClassID(icu::UStack *this)
{
  return &unk_1E9191F98;
}

void *icu::UStack::getDynamicClassID(icu::UStack *this)
{
  return &unk_1E9191F98;
}

void *icu::UStack::UStack(icu::UStack *this, UErrorCode *a2)
{
  uint64_t result = (void *)icu::UVector::UVector(this, a2);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

{
  void *result;

  uint64_t result = (void *)icu::UVector::UVector(this, a2);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

void *icu::UStack::UStack(icu::UStack *this, unsigned int a2, UErrorCode *a3)
{
  uint64_t result = (void *)icu::UVector::UVector(this, a2, a3);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

{
  void *result;

  uint64_t result = (void *)icu::UVector::UVector(this, a2, a3);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

void *icu::UStack::UStack(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

{
  void *result;

  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

void *icu::UStack::UStack(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int *a5)
{
  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

{
  void *result;

  uint64_t result = (void *)icu::UVector::UVector(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1EDA481E0;
  return result;
}

void icu::UStack::~UStack(void **this)
{
  icu::UVector::~UVector(this);

  icu::UMemory::operator delete(v1);
}

uint64_t icu::UStack::pop(icu::UStack *this)
{
  int v1 = *((_DWORD *)this + 2);
  if (v1 < 1) {
    return 0;
  }
  else {
    return icu::UVector::orphanElementAt(this, v1 - 1);
  }
}

uint64_t icu::UStack::popi(icu::UStack *this)
{
  int v1 = *((_DWORD *)this + 2);
  int v2 = v1 - 1;
  if (v1 < 1) {
    return 0;
  }
  uint64_t v4 = icu::UVector::elementAti(this, v1 - 1);
  icu::UVector::removeElementAt((uint64_t (**)(void))this, v2);
  return v4;
}

uint64_t icu::UStack::search(icu::UStack *this, uint64_t a2)
{
  uint64_t result = icu::UVector::indexOf(this, a2, 0);
  if ((result & 0x80000000) == 0) {
    return (*((_DWORD *)this + 2) - result);
  }
  return result;
}

uint64_t u_getDefaultConverter(UErrorCode *a1)
{
  umtx_lock(0);
  uint64_t v2 = qword_1E9191FA0;
  if (qword_1E9191FA0)
  {
    qword_1E9191FA0 = 0;
    umtx_unlock(0);
  }
  else
  {
    umtx_unlock(0);
    uint64_t v3 = ucnv_open(0, a1);
    uint64_t v2 = (uint64_t)v3;
    if (*(int *)a1 >= 1)
    {
      ucnv_close(v3);
      return 0;
    }
  }
  return v2;
}

void u_releaseDefaultConverter(void *a1)
{
  umtx_lock(0);
  if (qword_1E9191FA0) {
    goto LABEL_5;
  }
  umtx_unlock(0);
  if (a1) {
    ucnv_reset((uint64_t)a1);
  }
  ucnv_enableCleanup();
  umtx_lock(0);
  if (qword_1E9191FA0)
  {
LABEL_5:
    umtx_unlock(0);
    if (a1)
    {
      ucnv_close(a1);
    }
  }
  else
  {
    qword_1E9191FA0 = (uint64_t)a1;
    umtx_unlock(0);
  }
}

void u_flushDefaultConverter()
{
  if (qword_1E9191FA0)
  {
    umtx_lock(0);
    uint64_t v0 = (void *)qword_1E9191FA0;
    if (qword_1E9191FA0)
    {
      qword_1E9191FA0 = 0;
      umtx_unlock(0);
      ucnv_close(v0);
    }
    else
    {
      umtx_unlock(0);
    }
  }
}

UChar *__cdecl u_uastrncpy(UChar *dst, const char *src, int32_t n)
{
  uint64_t v15 = dst;
  uint64_t v16 = src;
  int v14 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v14);
  BOOL v7 = v14 > 0 || DefaultConverter == 0;
  int v8 = dst;
  if (v7) {
    goto LABEL_18;
  }
  uint64_t v9 = (void *)DefaultConverter;
  ucnv_reset(DefaultConverter);
  int32_t v10 = 0;
  if (n && src)
  {
    uint64_t v11 = 0;
    int32_t v10 = n;
    while (src[v11])
    {
      if (n == ++v11) {
        goto LABEL_12;
      }
    }
    int32_t v10 = v11;
  }
LABEL_12:
  ucnv_toUnicode((uint64_t)v9, (char **)&v15, (unint64_t)&dst[n], (unint64_t *)&v16, (unint64_t)&src[v10], 0, 1, &v14);
  ucnv_reset((uint64_t)v9);
  u_releaseDefaultConverter(v9);
  if (v14 >= 1 && v14 != 15) {
    *dst = 0;
  }
  int v8 = v15;
  if (v15 < &dst[n]) {
LABEL_18:
  }
    *int v8 = 0;
  return dst;
}

UChar *__cdecl u_uastrcpy(UChar *dst, const char *src)
{
  int v9 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v9);
  BOOL v5 = v9 > 0 || DefaultConverter == 0;
  if (v5
    || (int v6 = (void *)DefaultConverter,
        int v7 = strlen(src),
        ucnv_toUChars((uint64_t)v6, (unint64_t)dst, 0xFFFFFFF, src, v7, &v9),
        u_releaseDefaultConverter(v6),
        v9 >= 1))
  {
    *dst = 0;
  }
  return dst;
}

char *__cdecl u_austrncpy(char *dst, const UChar *src, int32_t n)
{
  uint64_t v15 = dst;
  uint64_t v16 = src;
  int v14 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v14);
  BOOL v7 = v14 > 0 || DefaultConverter == 0;
  int v8 = dst;
  if (v7) {
    goto LABEL_18;
  }
  int v9 = (void *)DefaultConverter;
  ucnv_reset(DefaultConverter);
  int32_t v10 = 0;
  if (n && src)
  {
    uint64_t v11 = 0;
    int32_t v10 = n;
    while (src[v11])
    {
      if (n == ++v11) {
        goto LABEL_12;
      }
    }
    int32_t v10 = v11;
  }
LABEL_12:
  ucnv_fromUnicode((uint64_t)v9, (uint64_t *)&v15, (unint64_t)&dst[n], (unint64_t *)&v16, (unint64_t)&src[v10], 0, 1, &v14);
  ucnv_reset((uint64_t)v9);
  u_releaseDefaultConverter(v9);
  if (v14 >= 1 && v14 != 15) {
    *dst = 0;
  }
  int v8 = v15;
  if (v15 < &dst[n]) {
LABEL_18:
  }
    *int v8 = 0;
  return dst;
}

char *__cdecl u_austrcpy(char *dst, const UChar *src)
{
  int v10 = 0;
  uint64_t DefaultConverter = u_getDefaultConverter((UErrorCode *)&v10);
  BOOL v5 = v10 > 0 || DefaultConverter == 0;
  int v6 = dst;
  if (!v5)
  {
    BOOL v7 = (void *)DefaultConverter;
    int v8 = ucnv_fromUChars(DefaultConverter, (unint64_t)dst, 0xFFFFFFF, src, -1, &v10);
    u_releaseDefaultConverter(v7);
    int v6 = &dst[v8];
  }
  *int v6 = 0;
  return dst;
}

void *sub_18C8B2334()
{
  return &unk_1E9191FA8;
}

void sub_18C8B2344(icu::BreakIterator *a1)
{
  icu::BreakIterator::~BreakIterator(a1);

  icu::UMemory::operator delete(v1);
}

uint64_t sub_18C8B236C()
{
  return 0;
}

uint64_t sub_18C8B2374()
{
  return 0;
}

void sub_18C8B237C()
{
}

uint64_t sub_18C8B238C(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0) {
    *a3 = 16;
  }
  return 0;
}

uint64_t sub_18C8B23A8(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 8);
  int v3 = (__int16)v2;
  unsigned int v4 = v2 >> 5;
  if (v3 < 0) {
    unsigned int v4 = *(_DWORD *)(a2 + 12);
  }
  *(_DWORD *)(result + 484) = v4;
  return result;
}

int64_t sub_18C8B23C8(int64_t result, UText *ut, int *a3)
{
  if (*a3 <= 0)
  {
    uint64_t v4 = result;
    uint64_t result = utext_nativeLength(ut);
    if (result > 0x7FFFFFFF) {
      *a3 = 8;
    }
    else {
      *(_DWORD *)(v4 + 484) = result;
    }
  }
  return result;
}

void sub_18C8B241C()
{
}

uint64_t sub_18C8B242C()
{
  return 0;
}

uint64_t sub_18C8B2434(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18C8B243C()
{
  return 0;
}

uint64_t sub_18C8B2444(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18C8B244C()
{
  return 0;
}

uint64_t sub_18C8B2454(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18C8B245C()
{
  return 0;
}

uint64_t sub_18C8B2464()
{
  return 0;
}

uint64_t sub_18C8B246C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 484);
}

uint64_t sub_18C8B2474(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  if (*a4 <= 0) {
    *a4 = 16;
  }
  return 0;
}

void sub_18C8B2490(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3 <= 0) {
    *a3 = 16;
  }
}

uint64_t sub_18C8B24AC(icu::Locale *a1, const char *a2, char a3, uint64_t a4, uint64_t *a5, const icu::Locale *a6)
{
  v18[28] = *(char **)MEMORY[0x1E4F143B8];
  if (*(int *)a6 > 0) {
    return 0;
  }
  uint64_t v6 = a4;
  int v9 = a3 & 0xE0;
  if ((a3 & 0xE0) != 0 && a4)
  {
    uint64_t v6 = 0;
    *(_DWORD *)a6 = 1;
    return v6;
  }
  if (a4) {
    return v6;
  }
  if (v9 == 64)
  {
    if (a1) {
      icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a1);
    }
    else {
      icu::Locale::Locale((icu::Locale *)v18, a2, 0, 0, 0);
    }
    Sentenceuint64_t Instance = icu::BreakIterator::createSentenceInstance(v18, a6, v12, v13);
    goto LABEL_21;
  }
  if (v9 != 32)
  {
    if ((a3 & 0xE0) == 0)
    {
      if (a1) {
        icu::Locale::Locale((icu::Locale *)v18, (uint64_t)a1);
      }
      else {
        icu::Locale::Locale((icu::Locale *)v18, a2, 0, 0, 0);
      }
      Sentenceuint64_t Instance = icu::BreakIterator::createWordInstance(v18, a6, v10, v11);
LABEL_21:
      uint64_t v6 = (uint64_t)SentenceInstance;
      icu::Locale::~Locale((icu::Locale *)v18);
      goto LABEL_24;
    }
    uint64_t v6 = 0;
    int v15 = 1;
LABEL_23:
    *(_DWORD *)a6 = v15;
    goto LABEL_24;
  }
  uint64_t v14 = icu::UMemory::operator new((icu::UMemory *)0x1E8, (unint64_t)a2);
  uint64_t v6 = v14;
  if (!v14)
  {
    int v15 = 7;
    goto LABEL_23;
  }
  icu::BreakIterator::BreakIterator(v14);
  *(void *)uint64_t v6 = &unk_1EDA48220;
  *(_DWORD *)(v6 + 484) = 0;
LABEL_24:
  if (*a5) {
    (*(void (**)(uint64_t))(*(void *)*a5 + 8))(*a5);
  }
  *a5 = v6;
  return v6;
}

uint64_t icu::CaseMap::toTitle(char *a1, uint64_t a2, uint64_t a3, UChar *a4, uint64_t a5, unint64_t a6, uint64_t a7, icu::Edits *a8, const icu::Locale *a9)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v23 = 0;
  uint64_t v16 = sub_18C8B24AC(0, a1, a2, a3, &v23, a9);
  if (v16)
  {
    uint64_t v17 = v16;
    memset(v24, 0, sizeof(v24));
    int v22 = a4;
    icu::UnicodeString::UnicodeString(v24, a5 >> 31, &v22);
    (*(void (**)(uint64_t, _OWORD *))(*(void *)v17 + 56))(v17, v24);
    uint64_t v18 = sub_18C8B4FD8((unsigned __int8 *)a1);
    uint64_t v19 = sub_18C8B447C(v18, a2, v17, a6, a7, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18C8B2B84, a8, (int *)a9);
    icu::UnicodeString::~UnicodeString(v20, (icu::UnicodeString *)v24);
  }
  else
  {
    uint64_t v19 = 0;
  }
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  return v19;
}

int32_t u_strToTitle(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UBreakIterator *titleIter, const char *locale, UErrorCode *pErrorCode)
{
  uint64_t v9 = *(void *)&srcLength;
  uint64_t v11 = *(void *)&destCapacity;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 0;
  uint64_t v13 = sub_18C8B24AC(0, locale, 0, (uint64_t)titleIter, &v20, (const icu::Locale *)pErrorCode);
  if (v13)
  {
    uint64_t v14 = v13;
    memset(v21, 0, sizeof(v21));
    uint64_t v19 = src;
    icu::UnicodeString::UnicodeString(v21, v9 >> 31, &v19);
    (*(void (**)(uint64_t, _OWORD *))(*(void *)v14 + 56))(v14, v21);
    uint64_t v15 = sub_18C8B4FD8((unsigned __int8 *)locale);
    int32_t v16 = sub_18C8B45DC(v15, 0, v14, dest, v11, (UChar *)src, v9, (uint64_t (*)(uint64_t, uint64_t, uint64_t, UChar *, uint64_t, UChar *, uint64_t, void, int *))sub_18C8B2B84, (int *)pErrorCode);
    icu::UnicodeString::~UnicodeString(v17, (icu::UnicodeString *)v21);
  }
  else
  {
    int32_t v16 = 0;
  }
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  return v16;
}

uint64_t ucasemap_toTitle(uint64_t *a1, unint64_t a2, uint64_t a3, UChar *a4, uint64_t a5, const icu::Locale *a6)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*(int *)a6 <= 0)
  {
    if (!*a1)
    {
      *(void *)&v16[0] = 0;
      if (!sub_18C8B24AC(0, (const char *)a1 + 8, *((_DWORD *)a1 + 11), 0, (uint64_t *)v16, a6))
      {
        if (*(void *)&v16[0]) {
          (*(void (**)(void))(**(void **)&v16[0] + 8))();
        }
        return 0;
      }
      *a1 = *(void *)&v16[0];
    }
    memset(v16, 0, sizeof(v16));
    uint64_t v15 = a4;
    icu::UnicodeString::UnicodeString(v16, a5 >> 31, &v15);
    (*(void (**)(uint64_t, _OWORD *))(*(void *)*a1 + 56))(*a1, v16);
    uint64_t v6 = sub_18C8B447C(*((unsigned int *)a1 + 10), *((unsigned int *)a1 + 11), *a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, UChar *, uint64_t, icu::Edits *, int *))sub_18C8B2B84, 0, (int *)a6);
    icu::UnicodeString::~UnicodeString(v13, (icu::UnicodeString *)v16);
    return v6;
  }
  return 0;
}

__int32 *__cdecl u_strToWCS(__int32 *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  if (!pErrorCode || *(int *)pErrorCode > 0) {
    return 0;
  }
  if (src) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = srcLength == 0;
  }
  char v7 = !v6;
  if (destCapacity < 0 || srcLength < -1 || (v7 & 1) != 0 || !dest && destCapacity)
  {
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  return u_strToUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode);
}

UChar *__cdecl u_strFromWCS(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const __int32 *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  if (!pErrorCode || *(int *)pErrorCode > 0) {
    return 0;
  }
  if (src) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = srcLength == 0;
  }
  char v7 = !v6;
  if (destCapacity < 0 || srcLength < -1 || (v7 & 1) != 0 || !dest && destCapacity)
  {
    *UErrorCode pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
    return 0;
  }
  return u_strFromUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode);
}

uint64_t sub_18C8B2B84(int a1, int a2, uint64_t *a3, uint64_t a4, int a5, uint64_t a6, int a7, icu::Edits *a8, UErrorCode *a9)
{
  if (*(int *)a9 > 0) {
    return 0;
  }
  __int16 v10 = a2;
  if ((~a2 & 0x600) == 0)
  {
    uint64_t result = 0;
    *a9 = U_ILLEGAL_ARGUMENT_ERROR;
    return result;
  }
  uint64_t v67 = 0;
  v65[0] = a6;
  v65[1] = 0;
  uint64_t v66 = a7;
  if (a7 < 1)
  {
    unsigned int count = 0;
LABEL_139:
    if ((int)count <= a5)
    {
      if (a8) {
        icu::Edits::copyErrorTo(a8, a9);
      }
      return count;
    }
    int v55 = 15;
LABEL_144:
    *a9 = v55;
    return count;
  }
  uint64_t v13 = a3;
  LODWORD(v14) = 0;
  unsigned int count = 0;
  char v15 = 1;
  while (2)
  {
    int v16 = v14;
    uint64_t v17 = *v13;
    if (v15) {
      int v18 = (*(uint64_t (**)(uint64_t *))(v17 + 80))(v13);
    }
    else {
      int v18 = (*(uint64_t (**)(uint64_t *))(v17 + 104))(v13);
    }
    if (v18 > a7 || v18 == -1) {
      uint64_t v14 = a7;
    }
    else {
      uint64_t v14 = v18;
    }
    if (v16 >= (int)v14) {
      goto LABEL_129;
    }
    uint64_t v20 = v16 + 1;
    uint64_t v21 = (const UChar *)(a6 + 2 * v16);
    unsigned int v22 = *v21;
    if ((v22 & 0xFC00) != 0xD800 || v20 == v14)
    {
      if ((v10 & 0x200) != 0) {
        goto LABEL_23;
      }
    }
    else
    {
      int v26 = *(unsigned __int16 *)(a6 + 2 * v20);
      BOOL v27 = (v26 & 0xFC00) == 56320;
      unsigned int v28 = (v22 << 10) - 56613888 + v26;
      if (v27) {
        uint64_t v20 = (v16 + 2);
      }
      else {
        uint64_t v20 = v20;
      }
      if (v27) {
        unsigned int v22 = v28;
      }
      if ((v10 & 0x200) != 0)
      {
LABEL_23:
        int v24 = v16;
        uint64_t v25 = v20;
        goto LABEL_55;
      }
    }
    int v24 = v16;
    while (1)
    {
      uint64_t v25 = v20;
      unsigned int v29 = v22;
      if ((v10 & 0x400) == 0)
      {
        int v30 = u_charType(v22);
        if (((1 << v30) & 0xF020E2E) != 0) {
          goto LABEL_45;
        }
        if (v30 != 4) {
          goto LABEL_37;
        }
        unsigned int v29 = v22;
      }
      if (ucase_getType(v29)) {
        goto LABEL_45;
      }
LABEL_37:
      if (v25 == v14) {
        break;
      }
      uint64_t v20 = (int)v25 + 1;
      unsigned int v22 = *(unsigned __int16 *)(a6 + 2 * (int)v25);
      BOOL v31 = (v22 & 0xFC00) != 0xD800 || v20 == v14;
      int v24 = v25;
      if (!v31)
      {
        int v32 = *(unsigned __int16 *)(a6 + 2 * v20);
        int v24 = v25;
        if ((v32 & 0xFC00) == 0xDC00)
        {
          uint64_t v20 = (v25 + 2);
          unsigned int v22 = (v22 << 10) - 56613888 + v32;
          int v24 = v25;
        }
      }
    }
    uint64_t v25 = v14;
    int v24 = v14;
LABEL_45:
    BOOL v33 = __OFSUB__(v24, v16);
    int32_t v34 = v24 - v16;
    if (!((v34 < 0) ^ v33 | (v34 == 0)))
    {
      if (v34 < 1) {
        goto LABEL_53;
      }
      if (a8) {
        icu::Edits::addUnchanged(a8, v34);
      }
      if ((v10 & 0x4000) != 0)
      {
LABEL_53:
        unsigned int v35 = count;
        goto LABEL_54;
      }
      if ((count ^ 0x7FFFFFFF) < v34) {
        goto LABEL_143;
      }
      unsigned int v35 = v34 + count;
      if ((int)(v34 + count) <= a5) {
        u_memcpy((UChar *)(a4 + 2 * (int)count), v21, v34);
      }
LABEL_54:
      unsigned int count = v35;
      if ((v35 & 0x80000000) != 0) {
        goto LABEL_143;
      }
    }
LABEL_55:
    if ((int)v25 <= v24) {
      goto LABEL_128;
    }
    HIDWORD(v66) = v24;
    LODWORD(v67) = v25;
    *(void *)long long v64 = 0;
    int v36 = a1;
    signed int v37 = ucase_toFullTitle(v22, (uint64_t (*)(uint64_t, void))sub_18C8B3268, (uint64_t)v65, v64, a1);
    int v38 = sub_18C8B3364(a4, count, a5, v37, *(__int16 **)v64, (int)v25 - v24, v10, a8);
    if (v38 < 0)
    {
LABEL_143:
      unsigned int count = 0;
      int v55 = 8;
      goto LABEL_144;
    }
    int v39 = v38;
    if (a1 != 5 || (v40 = v24 + 1, (int)v40 >= (int)v14) || (int v41 = v37 ^ (v37 >> 31), v41 != 205) && v41 != 73)
    {
      int v44 = v38;
      goto LABEL_112;
    }
    uint64_t v25 = v24 + 2;
    int v42 = (UChar *)(a6 + 2 * v40);
    int v43 = *v42;
    if (v41 == 73)
    {
      if (v43 == 769)
      {
        if (v25 == v14)
        {
          uint64_t v25 = v24 + 1;
          goto LABEL_111;
        }
        int v43 = *(unsigned __int16 *)(a6 + 2 * v25);
        int v46 = 1;
        uint64_t v25 = (v24 + 3);
        unsigned int v45 = 1;
      }
      else
      {
        int v46 = 0;
        unsigned int v45 = 0;
      }
    }
    else
    {
      unsigned int v45 = 0;
      int v46 = 1;
    }
    if (v43 != 106)
    {
      if (v43 == 74)
      {
        ++v45;
        goto LABEL_72;
      }
      goto LABEL_85;
    }
LABEL_72:
    if (v46)
    {
      if (v25 == v14 || *(_WORD *)(a6 + 2 * (int)v25) != 769) {
        goto LABEL_85;
      }
      unsigned int counta = v43 == 106;
      uint64_t v25 = (v25 + 1);
      if (v43 != 106) {
        ++v45;
      }
    }
    else
    {
      unsigned int counta = 0;
    }
    if ((int)v25 < (int)v14)
    {
      UChar32 v47 = *(unsigned __int16 *)(a6 + 2 * (int)v25);
      if ((v47 & 0xFC00) == 0xD800)
      {
        uint64_t v48 = (int)v25 + 1;
        if (v48 != v14)
        {
          int v49 = *(unsigned __int16 *)(a6 + 2 * v48);
          if ((v49 & 0xFC00) == 0xDC00) {
            UChar32 v47 = (v47 << 10) - 56613888 + v49;
          }
        }
      }
      int8_t v50 = u_charType(v47);
      int v42 = (UChar *)(a6 + 2 * v40);
      if (((1 << v50) & 0x1C0) != 0)
      {
LABEL_85:
        uint64_t v25 = v24 + 1;
        int v44 = v39;
        int v36 = a1;
        goto LABEL_112;
      }
    }
    if (v45)
    {
      src = v42;
      if (a8) {
        icu::Edits::addUnchanged(a8, v45);
      }
      if ((v10 & 0x4000) == 0)
      {
        if ((v39 ^ 0x7FFFFFFFu) >= v45)
        {
          if ((int)(v45 + v39) <= a5) {
            u_memcpy((UChar *)(a4 + 2 * v39), src, v45);
          }
          v39 += v45;
        }
        else
        {
          int v39 = -1;
        }
      }
    }
    int v51 = v45 + v40;
    if (v43 != 106)
    {
      int v36 = a1;
      goto LABEL_105;
    }
    int v36 = a1;
    if (v39 < a5)
    {
      *(_WORD *)(a4 + 2 * v39) = 74;
      goto LABEL_101;
    }
    if (v39 == 0x7FFFFFFF) {
      int v39 = -1;
    }
    else {
LABEL_101:
    }
      ++v39;
    if (a8) {
      icu::Edits::addReplace(a8, 1, 1);
    }
    ++v51;
LABEL_105:
    if (!counta) {
      goto LABEL_111;
    }
    if (a8) {
      icu::Edits::addUnchanged(a8, counta);
    }
    if ((v10 & 0x4000) != 0)
    {
LABEL_111:
      int v44 = v39;
    }
    else if ((v39 ^ 0x7FFFFFFFu) >= counta)
    {
      if ((int)(v39 + counta) <= a5) {
        u_memcpy((UChar *)(a4 + 2 * v39), (const UChar *)(a6 + 2 * v51), counta);
      }
      int v44 = v39 + counta;
    }
    else
    {
      int v44 = -1;
    }
LABEL_112:
    signed int v52 = v14 - v25;
    if ((int)v14 <= (int)v25) {
      goto LABEL_127;
    }
    if ((v10 & 0x100) != 0)
    {
      if (v52 < 1) {
        goto LABEL_126;
      }
      if (a8) {
        icu::Edits::addUnchanged(a8, v14 - v25);
      }
      if ((v10 & 0x4000) != 0)
      {
LABEL_126:
        if (v44 < 0) {
          goto LABEL_143;
        }
      }
      else
      {
        if ((v44 ^ 0x7FFFFFFFu) < v52) {
          goto LABEL_143;
        }
        int v54 = v44;
        v44 += v52;
        if (v44 <= a5) {
          u_memcpy((UChar *)(a4 + 2 * v54), (const UChar *)(a6 + 2 * (int)v25), v14 - v25);
        }
      }
LABEL_127:
      unsigned int count = v44;
LABEL_128:
      uint64_t v13 = a3;
      goto LABEL_129;
    }
    if (a4) {
      uint64_t v53 = a4 + 2 * v44;
    }
    else {
      uint64_t v53 = 0;
    }
    unsigned int count = sub_18C8B3500(v36, v10, v53, a5 - v44, a6, (uint64_t)v65, v25, v14, a8, a9) + v44;
    if (*a9 == U_BUFFER_OVERFLOW_ERROR)
    {
      *a9 = U_ZERO_ERROR;
      goto LABEL_128;
    }
    uint64_t v13 = a3;
    if (*(int *)a9 <= 0)
    {
LABEL_129:
      char v15 = 0;
      if ((int)v14 >= a7)
      {
        if (*(int *)a9 > 0) {
          return count;
        }
        goto LABEL_139;
      }
      continue;
    }
    return count;
  }
}