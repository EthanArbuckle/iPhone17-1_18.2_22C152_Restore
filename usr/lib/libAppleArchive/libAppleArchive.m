AAByteStream AAFileStreamOpenWithPath(const char *path, int open_flags, mode_t open_mode)
{
  char v3;
  int v4;
  int v5;
  AAByteStream result;
  int *v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (char)path;
  v4 = open(path, open_flags, open_mode);
  if (v4 < 0)
  {
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AAFileStreamOpenWithPath", 428, 17, *v7, "open: %s", v8, v9, v3);
  }
  else
  {
    v5 = v4;
    result = AAFileStreamOpenWithFD(v4, 1);
    if (result) {
      return result;
    }
    close(v5);
  }
  return 0;
}

AAByteStream AAFileStreamOpenWithFD(int fd, int automatic_close)
{
  v4 = calloc(1uLL, 0x68uLL);
  v5 = malloc(0xCuLL);
  v6 = v5;
  if (v5 && v4)
  {
    _DWORD *v5 = fd;
    v5[1] = automatic_close;
    v5[2] = 0;
    void *v4 = v5;
    v4[1] = aaFileStreamClose;
    v4[2] = aaFileStreamRead;
    v4[3] = aaFileStreamWrite;
    v4[4] = aaFileStreamPRead;
    v4[5] = aaFileStreamPWrite;
    v4[7] = aaFileStreamAbort;
    v4[6] = aaFileStreamSeek;
    v4[8] = aaFileStreamTruncate;
    v4[9] = aaFileStreamFlush;
  }
  else
  {
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AAFileStreamOpenWithFD", 402, 17, *v7, "malloc", v8, v9, v11);
    free(v4);
    free(v6);
    return 0;
  }
  return (AAByteStream)v4;
}

int AAArchiveStreamClose(AAArchiveStream s)
{
  if (!s) {
    return 0;
  }
  if (*(void *)s) {
    int v2 = (*((uint64_t (**)(void))s + 1))();
  }
  else {
    int v2 = 0;
  }
  free(s);
  return v2;
}

uint64_t decodeStreamClose(char *a1)
{
  if (a1)
  {
    int v2 = a1 + 32;
    free(*((void **)a1 + 6));
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(*((void **)a1 + 8));
    free(*((void **)a1 + 149));
    free(*((void **)a1 + 145));
    memset_s(a1 + 1152, 0x10uLL, 0, 0x10uLL);
    AAHeaderDestroy(*((AAHeader *)a1 + 11));
    AAHeaderDestroy(*((AAHeader *)a1 + 12));
    if (*(void *)a1 >> 62)
    {
      double v3 = getRealTime() - *((double *)a1 + 151);
      v4 = (FILE **)MEMORY[0x263EF8348];
      fwrite("Decode archive\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      fprintf(*v4, "%12llu entries in archive\n", *((void *)a1 + 150));
      fprintf(*v4, "%12llu bytes in archive (uncompressed)\n", *((void *)a1 + 142));
      fprintf(*v4, "%12.0f MB/s\n", (double)*((unint64_t *)a1 + 142) * 0.000000953674316 / v3);
      fprintf(*v4, "%12.2f decoding time (s)\n", v3);
    }
    free(a1);
  }
  return 0;
}

void AAHeaderDestroy(AAHeader header)
{
  if (header)
  {
    free(*((void **)header + 1));
    free(*((void **)header + 4));
    memset_s((char *)header + 16, 0x18uLL, 0, 0x18uLL);
    free(header);
  }
}

uint64_t threadPipelineWorkerThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  double v3 = (pthread_mutex_t *)(a1 + 48);
  v4 = (pthread_cond_t *)(a1 + 112);
  v28 = (pthread_mutex_t *)(a1 + 168);
  v27 = (pthread_cond_t *)(a1 + 232);
  v5 = (pthread_mutex_t *)(a1 + 288);
  v6 = (pthread_cond_t *)(a1 + 352);
  while (1)
  {
    int v7 = *(_DWORD *)(a1 + 8);
    if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 56)))
    {
      v24 = "SharedArrayPush: pthread_mutex_lock failed\n";
      __int16 v25 = 117;
      goto LABEL_35;
    }
    uint64_t v12 = *(unsigned int *)(v2 + 40);
    unsigned int v11 = *(_DWORD *)(v2 + 44);
    int v13 = v12;
    if (v12 < v11)
    {
      *(_DWORD *)(*(void *)(v2 + 48) + 4 * v12) = v7;
      int v13 = *(_DWORD *)(v2 + 40);
    }
    *(_DWORD *)(v2 + 40) = v13 + 1;
    if (!v13)
    {
      if (pthread_cond_broadcast((pthread_cond_t *)(v2 + 120))) {
        break;
      }
    }
    if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 56)))
    {
      v24 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      __int16 v25 = 124;
      goto LABEL_35;
    }
    if (v12 >= v11)
    {
      v24 = "SharedArrayPush: stack is full\n";
      __int16 v25 = 125;
      goto LABEL_35;
    }
    if (pthread_mutex_lock(v3)) {
      goto LABEL_27;
    }
    while (1)
    {
      int v16 = *(_DWORD *)(a1 + 40);
      if (v16 > 0) {
        break;
      }
      if (pthread_cond_wait(v4, v3)) {
        goto LABEL_27;
      }
    }
    *(_DWORD *)(a1 + 40) = v16 - 1;
    if (pthread_mutex_unlock(v3))
    {
LABEL_27:
      v21 = "SemAcquire";
      __int16 v22 = 72;
      goto LABEL_28;
    }
    if ((*(void *)(a1 + 400) & 0x8000000000000000) != 0) {
      return a1;
    }
    if (((*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", 82, 87, 0, "worker proc reported an error", v17, v18, v26);
      atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
    }
    if (pthread_mutex_lock(v28)
      || (int v19 = *(_DWORD *)(a1 + 160), *(_DWORD *)(a1 + 160) = v19 + 1, !v19) && pthread_cond_broadcast(v27)
      || pthread_mutex_unlock(v28))
    {
      v21 = "SemRelease";
      __int16 v22 = 85;
      goto LABEL_28;
    }
    if (!pthread_mutex_lock(v5))
    {
      while (1)
      {
        int v20 = *(_DWORD *)(a1 + 280);
        if (v20 > 0) {
          break;
        }
        if (pthread_cond_wait(v6, v5)) {
          goto LABEL_26;
        }
      }
      *(_DWORD *)(a1 + 280) = v20 - 1;
      if (!pthread_mutex_unlock(v5)) {
        continue;
      }
    }
LABEL_26:
    v21 = "SemAcquire";
    __int16 v22 = 88;
    goto LABEL_28;
  }
  v24 = "SharedArrayPush: pthread_cond_broadcast failed\n";
  __int16 v25 = 122;
LABEL_35:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v25, 0, v24, v8, v9, v10, v26);
  v21 = "SharedArrayPush";
  __int16 v22 = 69;
LABEL_28:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", v22, 87, 0, v21, v14, v15, v26);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
  return a1;
}

uint64_t compressionWorkerProc(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  if (atomic_load((unsigned int *)(*a1 + 112)))
  {
    uint64_t result = 0;
    a1[6] = -1;
    return result;
  }
  uint64_t v12 = a1[2];
  a1[6] = v12;
  if (v12 == -2) {
    return 0;
  }
  if (v12 == -1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", 244, 37, 0, "NOP received", a7, a8, v20);
    return 0;
  }
  if (v12 < 0)
  {
    uint64_t v14 = "Invalid iBlock received";
    __int16 v15 = 246;
  }
  else
  {
    if (!*(_DWORD *)(v9 + 4))
    {
      unint64_t v16 = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 96))(a1[5], *(void *)(v9 + 16), a1[1], a1[3]);
      size_t v17 = a1[3];
      if ((v16 & 0x8000000000000000) != 0 || v16 >= v17)
      {
        memcpy((void *)a1[5], (const void *)a1[1], v17);
        unint64_t v16 = a1[3];
        size_t v17 = v16;
      }
      a1[7] = v16;
      a1[8] = v17;
      if (*(int *)(v9 + 24) >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Worker: encode block %5lld: %7llu => %7llu\n");
      }
      return 0;
    }
    if (a1[3] == a1[4])
    {
      memcpy((void *)a1[5], (const void *)a1[1], a1[3]);
      uint64_t v13 = a1[3];
      a1[7] = v13;
      goto LABEL_19;
    }
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(v9 + 96))(a1[5]);
    if ((v18 & 0x8000000000000000) == 0 && v18 == a1[4])
    {
      a1[7] = v18;
      uint64_t v13 = a1[3];
LABEL_19:
      a1[8] = v13;
      if (*(int *)(v9 + 24) >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Worker: decode block %5lld: %7llu => %7llu\n");
      }
      return 0;
    }
    uint64_t v20 = a1[6];
    uint64_t v14 = "invalid output size/decoder error: block=%lld, inSize=%lld, outSize=%lld, expectedOutSize=%lld";
    __int16 v15 = 292;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", v15, 37, 0, v14, a7, a8, v20);
  int v19 = 0;
  a1[6] = -1;
  atomic_compare_exchange_strong((atomic_uint *volatile)(v9 + 112), (unsigned int *)&v19, 1u);
  return 0xFFFFFFFFLL;
}

size_t PCompressLZFSEDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result) {
    return -1;
  }
  return result;
}

AAArchiveStream AAExtractArchiveOutputStreamOpen(const char *dir, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  unsigned int DefaultNThreads = n_threads;
  if (!n_threads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v10 = (uint64_t *)malloc(0x38uLL);
  unsigned int v11 = v10;
  if (v10) {
    memset_s(v10, 0x38uLL, 0, 0x38uLL);
  }
  memset(&v49, 0, sizeof(v49));
  uint64_t v12 = malloc(0x690uLL);
  uint64_t v13 = (uint64_t)v12;
  if (v12)
  {
    memset_s(v12, 0x690uLL, 0, 0x690uLL);
    if (v11)
    {
      if (!realpath_DARWIN_EXTSN(dir, (char *)v13))
      {
        int v22 = *__error();
        char v48 = (char)dir;
        v23 = "%s";
        __int16 v24 = 1611;
        goto LABEL_16;
      }
      if (stat((const char *)v13, &v49) || (v49.st_mode & 0xF000) != 0x4000)
      {
        char v48 = (char)dir;
        v23 = "Invalid directory: %s";
        __int16 v24 = 1612;
      }
      else
      {
        *(void *)(v13 + 1024) = flags;
        *(void *)(v13 + 1032) = msg_data;
        *(void *)(v13 + 1040) = msg_proc;
        *(double *)(v13 + 1656) = getRealTime();
        *(void *)(v13 + 1640) = 0;
        *(_DWORD *)(v13 + 1056) = 1;
        *(_DWORD *)(v13 + 1072) = 0;
        *(_DWORD *)(v13 + 1076) = DefaultNThreads;
        unint64_t v16 = calloc(DefaultNThreads, 4uLL);
        *(void *)(v13 + 1080) = v16;
        if (!v16)
        {
          uint64_t v20 = "SharedArrayInit: malloc failed\n";
          __int16 v21 = 55;
          goto LABEL_22;
        }
        if (pthread_mutex_init((pthread_mutex_t *)(v13 + 1088), 0))
        {
          uint64_t v20 = "SharedArrayInit: pthread_mutex_init failed\n";
          __int16 v21 = 56;
LABEL_22:
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v21, 0, v20, v17, v18, v19, v48);
          v23 = "SharedArrayInit";
          __int16 v24 = 1619;
          goto LABEL_15;
        }
        if (pthread_cond_init((pthread_cond_t *)(v13 + 1152), 0))
        {
          uint64_t v20 = "SharedArrayInit: pthread_cond_init failed\n";
          __int16 v21 = 57;
          goto LABEL_22;
        }
        unint64_t VolumeCapabilities = getVolumeCapabilities((const char *)v13);
        char v34 = -1;
        if (VolumeCapabilities < 0x7FFFFFFFFFFFFFFFLL) {
          char v34 = VolumeCapabilities;
        }
        uint64_t v35 = 268;
        if ((v34 & 8) == 0) {
          uint64_t v35 = 264;
        }
        unint64_t v36 = v35 & 0xFFFFFFFFFFFFFFDFLL | (32 * (v34 & 1));
        if ((flags & 0x20) == 0 && (v34 & 2) != 0) {
          uint64_t v37 = v36 | 0x40;
        }
        else {
          uint64_t v37 = v36;
        }
        *(void *)(v13 + 1048) = v37;
        if ((int)isDirEmpty((const char *)v13) >= 1) {
          *(_DWORD *)(v13 + 1056) = 0;
        }
        for (uint64_t i = 0; i != 240; i += 80)
        {
          *(_OWORD *)(v13 + i + 1376) = 0u;
          if (pthread_mutex_init((pthread_mutex_t *)(v13 + i + 1312), 0) < 0)
          {
            v39 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterInit", 472, 72, *v39, "pthread_mutex_init", v40, v41, v48);
            v23 = "cluster init";
            __int16 v24 = 1638;
            goto LABEL_15;
          }
        }
        *(void *)(v13 + 1200) = v13;
        if (pthread_mutex_init((pthread_mutex_t *)(v13 + 1216), 0))
        {
          int v22 = *__error();
          v23 = "pthread_mutex_init";
          __int16 v24 = 1643;
          goto LABEL_16;
        }
        if ((createThread((pthread_t *)(v13 + 1208), (uint64_t)retireThreadProc, v13 + 1200, 0) & 0x80000000) == 0)
        {
          *(_DWORD *)(v13 + 1060) = DefaultNThreads;
          if (DefaultNThreads < 0x2E8BA2E9)
          {
            v42 = calloc(DefaultNThreads, 0xB0uLL);
            *(void *)(v13 + 1064) = v42;
            if (v42)
            {
              if (!DefaultNThreads)
              {
LABEL_50:
                v11[3] = (uint64_t)extractStreamWriteHeader;
                v11[4] = (uint64_t)extractStreamWriteBlob;
                v11[2] = (uint64_t)extractStreamAbort;
                *unsigned int v11 = v13;
                v11[1] = (uint64_t)extractStreamClose;
                return (AAArchiveStream)v11;
              }
              uint64_t v43 = 0;
              uint64_t v44 = 176 * DefaultNThreads;
              while (1)
              {
                uint64_t v45 = *(void *)(v13 + 1064);
                uint64_t v46 = v45 + v43;
                *(void *)(v45 + v43) = v13;
                if (AASharedBufferPipeOpen((AAByteStream *)(v45 + v43 + 32), (AAByteStream *)(v45 + v43 + 40), 0x40000uLL) < 0)
                {
                  v23 = "creating shared data buffer";
                  __int16 v24 = 1654;
                  goto LABEL_15;
                }
                if (AASharedBufferPipeOpen((AAByteStream *)(v46 + 16), (AAByteStream *)(v46 + 24), 0x4000uLL) < 0)
                {
                  v23 = "creating shared command buffer";
                  __int16 v24 = 1655;
                  goto LABEL_15;
                }
                uint64_t v47 = v45 + v43;
                if ((SemInit(v47 + 48) & 0x80000000) != 0)
                {
                  v23 = "SemInit failed";
                  __int16 v24 = 1656;
                  goto LABEL_15;
                }
                if ((createThread((pthread_t *)(v47 + 8), (uint64_t)extractThreadProc, v46, 0) & 0x80000000) != 0) {
                  break;
                }
                v43 += 176;
                if (v44 == v43) {
                  goto LABEL_50;
                }
              }
              v23 = "creating worker thread";
              __int16 v24 = 1657;
              goto LABEL_15;
            }
          }
          else
          {
            *__error() = 12;
            *(void *)(v13 + 1064) = 0;
          }
          int v22 = *__error();
          v23 = "malloc";
          __int16 v24 = 1649;
          goto LABEL_16;
        }
        v23 = "creating retire thread";
        __int16 v24 = 1644;
      }
LABEL_15:
      int v22 = 0;
      goto LABEL_16;
    }
  }
  int v22 = *__error();
  v23 = "malloc";
  __int16 v24 = 1610;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"AAExtractArchiveOutputStreamOpen", v24, 72, v22, v23, v14, v15, v48);
  free(v11);
  extractStreamClose(v13, v25, v26, v27, v28, v29, v30, v31);
  return 0;
}

uint64_t createThread(pthread_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  *(void *)__relative_priority = 0;
  uint64_t v8 = calloc(1uLL, 0x2000uLL);
  if (!v8)
  {
    uint64_t v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 552, 5, *v19, "malloc", v20, v21, v36[0]);
    return -*__error();
  }
  uint64_t v9 = v8;
  uint64_t v10 = (pthread_attr_t *)calloc(1uLL, 0x40uLL);
  if (!v10)
  {
    int v22 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 555, 5, *v22, "malloc", v23, v24, v36[0]);
    uint64_t v25 = __error();
    uint64_t v13 = -*v25;
    if (!*v25) {
      return v13;
    }
    goto LABEL_10;
  }
  unsigned int v11 = v10;
  uint64_t v12 = pthread_attr_init(v10);
  if (v12)
  {
    uint64_t v13 = v12;
    int v14 = *__error();
    uint64_t v17 = "pthread_attr_init";
    __int16 v18 = 558;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", v18, 5, v14, v17, v15, v16, v36[0]);
    goto LABEL_6;
  }
  if (a4)
  {
    uint64_t v28 = pthread_attr_setstacksize(v11, a4);
    if (v28)
    {
      uint64_t v13 = v28;
      int v14 = *__error();
      uint64_t v17 = "pthread_attr_setstacksize";
      __int16 v18 = 564;
      goto LABEL_5;
    }
  }
  uint64_t v29 = pthread_self();
  uint64_t qos_class_np = pthread_get_qos_class_np(v29, (qos_class_t *)&__relative_priority[1], __relative_priority);
  if (qos_class_np)
  {
    uint64_t v13 = qos_class_np;
    int v14 = *__error();
    uint64_t v17 = "pthread_get_qos_class_np";
    __int16 v18 = 570;
    goto LABEL_5;
  }
  uint64_t v31 = pthread_attr_set_qos_class_np(v11, (qos_class_t)__relative_priority[1], __relative_priority[0]);
  if (v31)
  {
    uint64_t v13 = v31;
    int v14 = *__error();
    uint64_t v17 = "pthread_attr_set_qos_class_np";
    __int16 v18 = 572;
    goto LABEL_5;
  }
  v36[0] = MEMORY[0x263EF8330];
  v36[1] = 0x40000000;
  v36[2] = __createThread_block_invoke;
  v36[3] = &__block_descriptor_tmp;
  v36[4] = v9;
  dispatch_block_t v32 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v36);
  v9[2] = v32;
  if (v32)
  {
    *uint64_t v9 = a2;
    v9[1] = a3;
    *((_DWORD *)v9 + 7) = 1;
    *((_DWORD *)v9 + 24) = 530317312;
    uint64_t v13 = pthread_create(a1, v11, (void *(__cdecl *)(void *))threadWrapperProc, v9);
    if (v13)
    {
      int v14 = *__error();
      uint64_t v17 = "pthread_create";
      __int16 v18 = 591;
      goto LABEL_5;
    }
  }
  else
  {
    v33 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 578, 5, *v33, "dispatch_block_create", v34, v35, v36[0]);
    uint64_t v13 = -*__error();
  }
LABEL_6:
  pthread_attr_destroy(v11);
  free(v11);
  if (!v13) {
    return v13;
  }
LABEL_10:
  uint64_t v26 = (const void *)v9[2];
  if (v26) {
    _Block_release(v26);
  }
  free(v9);
  return v13;
}

int AASharedBufferPipeOpen(AAByteStream *ostream, AAByteStream *istream, size_t buffer_capacity)
{
  v6 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  int v7 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  uint64_t v15 = v7;
  if (v6 && v7)
  {
    uint64_t v16 = SharedBufferCreate(buffer_capacity, v8, v9, v10, v11, v12, v13, v14);
    if (v16)
    {
      uint64_t v19 = v16;
      int result = 0;
      *(void *)uint64_t v15 = v19;
      *((void *)v15 + 1) = aaSharedBufferOStreamClose;
      *((void *)v15 + 3) = aaSharedBufferWrite;
      *((void *)v15 + 7) = SharedBufferAbort;
      *(void *)v6 = v19;
      *((void *)v6 + 1) = aaSharedBufferIStreamClose;
      *((void *)v6 + 2) = aaSharedBufferRead;
      *((void *)v6 + 7) = SharedBufferAbort;
      *ostream = v15;
      *istream = v6;
      return result;
    }
    int v22 = "SharedBufferCreate";
    __int16 v23 = 503;
    int v21 = 0;
  }
  else
  {
    int v21 = *__error();
    int v22 = "malloc";
    __int16 v23 = 499;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AASharedBufferPipeOpen", v23, 17, v21, v22, v17, v18, v24);
  free(v6);
  free(v15);
  SharedBufferDestroy(0);
  return -1;
}

char *SharedBufferCreate(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 - 0x100000000 > 0xFFFFFFFF00000000)
  {
    int v9 = getpagesize();
    if (v9 <= 0x197)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 252, 73, 0, "Incompatible page size", v10, v11, v39);
      return 0;
    }
    uint64_t v14 = v9;
    if (a1 >> 2 < v9) {
      unint64_t v15 = 1;
    }
    else {
      unint64_t v15 = (a1 >> 2) / v9;
    }
    unint64_t v16 = v15 * v9;
    uint64_t v17 = (unsigned int *)valloc(v9 + 4 * v16);
    uint64_t v12 = v17;
    if (!v17)
    {
      char v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 262, 73, *v24, "malloc", v25, v26, v39);
      return (char *)v12;
    }
    *((void *)v17 + 50) = 0;
    *((_OWORD *)v17 + 23) = 0u;
    *((_OWORD *)v17 + 24) = 0u;
    *((_OWORD *)v17 + 21) = 0u;
    *((_OWORD *)v17 + 22) = 0u;
    *((_OWORD *)v17 + 19) = 0u;
    *((_OWORD *)v17 + 20) = 0u;
    *((_OWORD *)v17 + 17) = 0u;
    *((_OWORD *)v17 + 18) = 0u;
    *((_OWORD *)v17 + 15) = 0u;
    *((_OWORD *)v17 + 16) = 0u;
    *((_OWORD *)v17 + 13) = 0u;
    *((_OWORD *)v17 + 14) = 0u;
    *((_OWORD *)v17 + 11) = 0u;
    *((_OWORD *)v17 + 12) = 0u;
    *((_OWORD *)v17 + 9) = 0u;
    *((_OWORD *)v17 + 10) = 0u;
    *((_OWORD *)v17 + 7) = 0u;
    *((_OWORD *)v17 + 8) = 0u;
    *((_OWORD *)v17 + 5) = 0u;
    *((_OWORD *)v17 + 6) = 0u;
    *((_OWORD *)v17 + 3) = 0u;
    *((_OWORD *)v17 + 4) = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    *((_OWORD *)v17 + 2) = 0u;
    *(_OWORD *)uint64_t v17 = 0u;
    *((void *)v17 + 48) = -1;
    atomic_store(2u, v17 + 101);
    *(void *)uint64_t v17 = 0x600000000;
    uint64_t v18 = calloc(6uLL, 4uLL);
    *((void *)v12 + 1) = v18;
    if (v18)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v12 + 4), 0))
      {
        int v22 = "SharedArrayInit: pthread_mutex_init failed\n";
        __int16 v23 = 56;
      }
      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v12 + 20), 0))
        {
          *((void *)v12 + 16) = 0x600000000;
          uint64_t v31 = calloc(6uLL, 4uLL);
          *((void *)v12 + 17) = v31;
          if (v31)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v12 + 36), 0))
            {
              uint64_t v35 = "SharedArrayInit: pthread_mutex_init failed\n";
              __int16 v36 = 56;
            }
            else
            {
              if (!pthread_cond_init((pthread_cond_t *)(v12 + 52), 0))
              {
                uint64_t v37 = 0;
                for (uint64_t i = v12 + 68; ; i += 4)
                {
                  *uint64_t i = 0;
                  i[1] = 0;
                  *(i - 2) = (char *)v12 + v14;
                  *(i - 1) = v16;
                  if ((SharedArrayPush(v12 + 32, v37) & 0x80000000) != 0) {
                    break;
                  }
                  ++v37;
                  v14 += v16;
                  if (v37 == 4) {
                    return (char *)v12;
                  }
                }
                uint64_t v29 = "SharedArrayPush";
                __int16 v30 = 283;
                goto LABEL_19;
              }
              uint64_t v35 = "SharedArrayInit: pthread_cond_init failed\n";
              __int16 v36 = 57;
            }
          }
          else
          {
            uint64_t v35 = "SharedArrayInit: malloc failed\n";
            __int16 v36 = 55;
          }
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v36, 0, v35, v32, v33, v34, v39);
          uint64_t v29 = "SharedArrayInit";
          __int16 v30 = 270;
LABEL_19:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", v30, 73, 0, v29, v27, v28, v39);
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 4))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 20)))
          {
            free(*((void **)v12 + 1));
          }
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 36))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 52)))
          {
            free(*((void **)v12 + 17));
          }
          free(v12);
          return 0;
        }
        int v22 = "SharedArrayInit: pthread_cond_init failed\n";
        __int16 v23 = 57;
      }
    }
    else
    {
      int v22 = "SharedArrayInit: malloc failed\n";
      __int16 v23 = 55;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v23, 0, v22, v19, v20, v21, v39);
    uint64_t v29 = "SharedArrayInit";
    __int16 v30 = 269;
    goto LABEL_19;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 247, 73, 0, "SharedBuffer invalid capacity: %zu", a7, a8, a1);
  return 0;
}

uint64_t SemInit(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0)) {
    return 0xFFFFFFFFLL;
  }
  if (pthread_cond_init((pthread_cond_t *)(a1 + 72), 0)) {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

double getRealTime()
{
  v1.tv_sec = 0;
  *(void *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return (double)v1.tv_sec + (double)v1.tv_usec * 0.000001;
}

uint64_t getDefaultNThreads()
{
  unsigned int v5 = 0;
  size_t v4 = 4;
  if (!sysctlbyname("hw.physicalcpu", &v5, &v4, 0, 0)) {
    return v5;
  }
  v0 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getDefaultNThreads", 107, 3, *v0, "sysctlbyname", v1, v2, v4);
  return 1;
}

uint64_t isDirEmpty(const char *a1)
{
  char v1 = (char)a1;
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = opendir(a1);
  if (v2)
  {
    double v3 = v2;
    memset(&v14, 0, 512);
    uint64_t v13 = 0;
    while (1)
    {
      if (readdir_r(v3, &v14, &v13))
      {
        uint64_t v8 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"isDirEmpty", 438, 3, *v8, "readdir_r", v9, v10, v12);
        uint64_t v4 = 0xFFFFFFFFLL;
        goto LABEL_14;
      }
      if (!v13) {
        break;
      }
      if (v14.d_namlen != 1 || v14.d_name[0] != 46)
      {
        uint64_t v4 = 0;
        if (v14.d_namlen != 2 || v14.d_name[0] != 46 || v14.d_name[1] != 46) {
          goto LABEL_14;
        }
      }
    }
    uint64_t v4 = 1;
LABEL_14:
    closedir(v3);
  }
  else
  {
    unsigned int v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"isDirEmpty", 428, 3, *v5, "%s", v6, v7, v1);
    return 0xFFFFFFFFLL;
  }
  return v4;
}

uint64_t getVolumeCapabilities(const char *a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  bzero(&v11, 0x878uLL);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  int v7 = 0;
  memset(v6, 0, sizeof(v6));
  if (statfs(a1, &v11) < 0) {
    return -1;
  }
  LOWORD(v8) = 5;
  LODWORD(v9) = -2147352576;
  int v2 = getattrlist(v11.f_mntonname, &v8, v6, 0x24uLL, 1u);
  uint64_t result = -1;
  if (!v2 && LODWORD(v6[0]) == 36)
  {
    v3.i64[0] = *(void *)((char *)v6 + 4);
    int8x16_t v5 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vzip1q_s32(v3, v3), (uint32x4_t)xmmword_214B13000), (int8x16_t)xmmword_214B13010);
    *(int8x8_t *)v5.i8 = vorr_s8(*(int8x8_t *)v5.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
    return (v5.i32[0] | v5.i32[1]);
  }
  return result;
}

uint64_t extractStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = MEMORY[0x270FA5388](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v154 = *MEMORY[0x263EF8340];
  if (!result) {
    return result;
  }
  uint64_t v11 = result;
  unint64_t v140 = *(void *)(result + 1024);
  if (atomic_load((unsigned int *)(result + 1600)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1486, 72, 0, "stream cancelled", v9, v10, v139);
    int v13 = 0;
  }
  else
  {
    int v13 = 1;
  }
  if (*(void *)(v11 + 1632) || *(void *)(v11 + 1640))
  {
    extractStreamStateFail(v11);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1492, 72, 0, "invalid state on destroy", v14, v15, v139);
    int v13 = 0;
  }
  if (*(void *)(v11 + 1064))
  {
    int v141 = v13;
    unint64_t v16 = *(unsigned int *)(v11 + 1060);
    if (v16)
    {
      uint64_t v17 = 0;
      unint64_t v18 = 0;
      int v19 = 0;
      do
      {
        uint64_t v20 = *(void *)(v11 + 1064);
        if (v20)
        {
          uint64_t v21 = v20 + v17;
          if (*(void *)(v21 + 8)) {
            ++v19;
          }
          if (!v141)
          {
            int v22 = *(AAByteStream_impl **)(v21 + 32);
            if (v22)
            {
              AAByteStreamCancel(v22);
              unint64_t v16 = *(unsigned int *)(v11 + 1060);
            }
          }
        }
        ++v18;
        v17 += 176;
      }
      while (v18 < v16);
      if (v19)
      {
        for (int i = 0; i != v19; ++i)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 1088)))
          {
            __int16 v27 = 91;
            uint64_t v28 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_25:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v27, 0, v28, v24, v25, v26, v139);
          }
          else
          {
            while (1)
            {
              int v29 = *(_DWORD *)(v11 + 1072);
              if (v29) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(v11 + 1152), (pthread_mutex_t *)(v11 + 1088)))
              {
                __int16 v27 = 94;
                uint64_t v28 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_25;
              }
            }
            unsigned int v30 = v29 - 1;
            *(_DWORD *)(v11 + 1072) = v30;
            unsigned int v31 = *(_DWORD *)(*(void *)(v11 + 1080) + 4 * v30);
            if (pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1088))) {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v32, v33, v34, v139);
            }
            if (v31 != -1)
            {
              uint64_t v35 = *(void *)(v11 + 1064);
              __int16 v36 = (pthread_mutex_t *)(v35 + 176 * v31 + 56);
              if (!pthread_mutex_lock(v36))
              {
                uint64_t v37 = v35 + 176 * v31;
                int v38 = *(_DWORD *)(v37 + 48);
                *(_DWORD *)(v37 + 48) = v38 + 1;
                if (v38 || !pthread_cond_broadcast((pthread_cond_t *)(v35 + 176 * v31 + 120))) {
                  pthread_mutex_unlock(v36);
                }
              }
              uint64_t v153 = 0;
              int buf = 42;
              uint64_t v39 = v35 + 176 * v31;
              AAByteStreamWrite(*(AAByteStream *)(v39 + 16), &buf, 0xCuLL);
              joinThread(*(_opaque_pthread_t **)(v39 + 8));
              AAByteStreamClose(*(AAByteStream *)(v39 + 16));
              AAByteStreamClose(*(AAByteStream *)(v39 + 24));
              AAByteStreamClose(*(AAByteStream *)(v39 + 32));
              AAByteStreamClose(*(AAByteStream *)(v39 + 40));
              if (!pthread_mutex_destroy(v36)) {
                pthread_cond_destroy((pthread_cond_t *)(v35 + 176 * v31 + 120));
              }
            }
          }
        }
      }
    }
    free(*(void **)(v11 + 1064));
    int v13 = v141;
  }
  if (!pthread_mutex_destroy((pthread_mutex_t *)(v11 + 1088)) && !pthread_cond_destroy((pthread_cond_t *)(v11 + 1152))) {
    free(*(void **)(v11 + 1080));
  }
  if (*(void *)(v11 + 1208))
  {
    retireThreadEnqueue(v11 + 1200, 0);
    joinThread(*(_opaque_pthread_t **)(v11 + 1208));
    pthread_mutex_destroy((pthread_mutex_t *)(v11 + 1216));
  }
  if (*(void *)(v11 + 1632))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1541, 72, 0, "entry found in extract stream", v45, v46, v139);
    entryRelease(*(void *)(v11 + 1632), v47, v48, v49, v50, v51, v52, v53);
    int v13 = 0;
  }
  int v142 = v13;
  uint64_t v54 = 0;
  unint64_t v55 = *(void *)(v11 + 1024);
  unsigned int v147 = v55 & 1;
  uint64_t v56 = v11 + 1312;
  v57 = (void *)(v11 + 1384);
  char v144 = v55;
  uint64_t v145 = v11 + 1312;
  uint64_t v143 = (v55 >> 7) & 1;
  do
  {
    v150 = (void *)(v56 + 80 * v54 + 64);
    if (*v150)
    {
      uint64_t v58 = 0;
      v149 = (void *)(v145 + 80 * v54 + 72);
      BOOL v59 = (v144 & 0x10) == 0 && v54 == 2;
      char v60 = v59;
      if (v59) {
        int v61 = v143;
      }
      else {
        int v61 = 0;
      }
      int v148 = v61;
      char v146 = v60 ^ 1 | v143;
      while (1)
      {
        v62 = (uint64_t *)(*v149 + 32 * v58);
        v63 = v62 + 1;
        if (!v62[1]) {
          goto LABEL_103;
        }
        uint64_t v64 = v62[2];
        v65 = v57;
        if (v64 != -1 || (uint64_t v64 = *(void *)(*v149 + 32 * v58 + 24), v65 = (void *)(v11 + 1464), v64 != -1)) {
          v62 = (uint64_t *)(*v65 + 32 * v64);
        }
        uint64_t v66 = *v62;
        if (*v62)
        {
          if (*(_DWORD *)(v66 + 2300) == 3) {
            break;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1049, 72, 0, "no valid DAT entry for cluster %d/%llu", v45, v46, v54);
        while (1)
        {
          uint64_t v82 = *v63;
          if (!*v63) {
            break;
          }
          uint64_t *v63 = *(void *)(v82 + 8 * v54 + 2336);
          if (*(_DWORD *)(v82 + 2300) != -1)
          {
            *(_DWORD *)(v82 + 2300) = -1;
            v83 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v11 + 1040);
            if (v83) {
              v83(*(void *)(v11 + 1032), 22, v82, v82 + 2272);
            }
          }
          entryRelease(v82, v40, v41, v42, v43, v44, v45, v46);
        }
LABEL_103:
        if ((unint64_t)++v58 >= *v150) {
          goto LABEL_111;
        }
      }
      if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, (const char *)v66) & 0x80000000) != 0) {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1071, 72, 0, "invalid DAT path", v45, v46, v139);
      }
      while (1)
      {
        uint64_t v81 = *v63;
        if (!*v63)
        {
          v57 = (void *)(v11 + 1384);
          goto LABEL_103;
        }
        uint64_t *v63 = *(void *)(v81 + 8 * v54 + 2336);
        if (v81 == v66)
        {
          uint64_t v72 = v66;
          goto LABEL_100;
        }
        int Path = concatExtractPath(v151, 0x800uLL, (char *)v11, (const char *)v81);
        if (Path < 0) {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1082, 72, 0, "invalid path: %s", v67, v68, v81);
        }
        unlink(v151);
        if (!v54) {
          break;
        }
        if (v54 == 1) {
          goto LABEL_71;
        }
        if (v148) {
          break;
        }
        if ((v146 & 1) == 0)
        {
LABEL_71:
          int v70 = clonefile((const char *)&buf, v151, 0);
          char v71 = 0;
          if ((v70 & 0x80000000) == 0) {
            goto LABEL_80;
          }
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1116, 72, "failed to create clone: %s", v44, v45, v46, v81);
        }
        int v76 = copyFileWithAttributes((const char *)&buf, v151, 0, v147, 0);
        char v71 = 0;
        if (v76 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1123, 72, 0, "create copy: %s", v45, v46, v81);
          int v77 = 0;
LABEL_88:
          if ((applyEntryAttributes(v11, v81) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1129, 72, 0, "setting entry attributes: %s", v45, v46, v81);
            goto LABEL_92;
          }
          goto LABEL_89;
        }
LABEL_80:
        if (Path < 0)
        {
          int v77 = 0;
          if ((v71 & 1) == 0) {
            goto LABEL_88;
          }
        }
        else
        {
          if (*(_DWORD *)(v81 + 2300) != 2) {
            *(_DWORD *)(v81 + 2300) = 2;
          }
          int v77 = 1;
          if ((v71 & 1) == 0) {
            goto LABEL_88;
          }
        }
LABEL_89:
        if (v77)
        {
          int v78 = 3;
          goto LABEL_93;
        }
LABEL_92:
        int v78 = -1;
LABEL_93:
        if (*(_DWORD *)(v81 + 2300) != v78)
        {
          *(_DWORD *)(v81 + 2300) = v78;
          v79 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v11 + 1040);
          if (v79)
          {
            if (v78 == -1) {
              uint64_t v80 = 22;
            }
            else {
              uint64_t v80 = 21;
            }
            v79(*(void *)(v11 + 1032), v80, v81, v81 + 2272);
          }
        }
        uint64_t v72 = v81;
LABEL_100:
        entryRelease(v72, v40, v41, v42, v43, v44, v45, v46);
      }
      if (link((const char *)&buf, v151) < 0)
      {
        int v73 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessClusters", 1108, 72, v73, "failed to create hard link: %s", v74, v75, v81);
        goto LABEL_92;
      }
      char v71 = 1;
      goto LABEL_80;
    }
LABEL_111:
    ++v54;
    uint64_t v56 = v11 + 1312;
  }
  while (v54 != 3);
  if (!*(void *)(v11 + 1560))
  {
    *(void *)(v11 + 1560) = 0;
    goto LABEL_135;
  }
  uint64_t v84 = 0;
  int v85 = 1;
  while (2)
  {
    uint64_t v86 = *(void *)(*(void *)(v11 + 1568) + 8 * v84);
    if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, (const char *)v86) & 0x80000000) != 0)
    {
      __int16 v99 = 1007;
      v100 = "invalid 'H' PAT";
      goto LABEL_122;
    }
    if ((concatExtractPath(v151, 0x800uLL, (char *)v11, (const char *)(v86 + 1024)) & 0x80000000) != 0)
    {
      __int16 v99 = 1008;
      v100 = "invalid 'H' LNK";
LABEL_122:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessHLinks", v99, 72, 0, v100, v87, v88, v139);
LABEL_123:
      int v101 = 0;
      int v102 = -1;
      goto LABEL_124;
    }
    if (*(_DWORD *)(v11 + 1056)) {
      removeFile((const char *)&buf);
    }
    if (link(v151, (const char *)&buf))
    {
      int v96 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessHLinks", 1010, 72, v96, "link %s ->%s", v97, v98, (char)&buf);
      goto LABEL_123;
    }
    int v101 = 1;
    int v102 = 3;
LABEL_124:
    if (*(_DWORD *)(v86 + 2300) != v102)
    {
      *(_DWORD *)(v86 + 2300) = v102;
      v103 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v11 + 1040);
      if (v103)
      {
        if (v102 == -1) {
          uint64_t v104 = 22;
        }
        else {
          uint64_t v104 = 21;
        }
        v103(*(void *)(v11 + 1032), v104, v86, v86 + 2272);
      }
    }
    entryRelease(v86, v89, v90, v91, v92, v93, v94, v95);
    *(void *)(*(void *)(v11 + 1568) + 8 * v84) = 0;
    v85 &= v101;
    if ((unint64_t)++v84 < *(void *)(v11 + 1560)) {
      continue;
    }
    break;
  }
  *(void *)(v11 + 1560) = 0;
  if (!v85)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1550, 72, 0, "process hlinks", v45, v46, v139);
    int v142 = 0;
  }
LABEL_135:
  uint64_t v105 = *(void *)(v11 + 1584);
  if (!v105)
  {
    *(void *)(v11 + 1584) = 0;
    uint64_t v119 = v11 + 1312;
    goto LABEL_147;
  }
  uint64_t v106 = v105 - 1;
  int v107 = 1;
  while (2)
  {
    v108 = *(const char **)(*(void *)(v11 + 1592) + 8 * v106);
    if ((concatExtractPath((char *)&buf, 0x800uLL, (char *)v11, v108) & 0x80000000) != 0)
    {
      __int16 v117 = 983;
      v118 = "invalid 'D' PAT";
    }
    else
    {
      if ((applyEntryAttributes(v11, (uint64_t)v108) & 0x80000000) == 0)
      {
        int v116 = 1;
        goto LABEL_143;
      }
      __int16 v117 = 984;
      v118 = "applyEntryAttributes failed";
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamProcessDirs", v117, 72, 0, v118, v109, v110, v139);
    int v116 = 0;
LABEL_143:
    entryRelease((uint64_t)v108, v111, v112, v113, v114, v115, v109, v110);
    *(void *)(*(void *)(v11 + 1592) + 8 * v106) = 0;
    v107 &= v116;
    if (--v106 != -1) {
      continue;
    }
    break;
  }
  *(void *)(v11 + 1584) = 0;
  uint64_t v119 = v11 + 1312;
  if (!v107)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1553, 72, 0, "process dirs", v45, v46, v139);
    int v142 = 0;
  }
LABEL_147:
  unsigned int v120 = atomic_load((unsigned int *)(v11 + 1604));
  v121 = (FILE **)MEMORY[0x263EF8348];
  if (v120)
  {
    char v122 = atomic_load((unsigned int *)(v11 + 1604));
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamClose", 1556, 72, 0, "%u entries failed to extract", v45, v46, v122);
    BOOL v123 = 0;
  }
  else
  {
    BOOL v123 = v142 != 0;
    if (v142 && v140 >> 62)
    {
      double v124 = getRealTime() - *(double *)(v11 + 1656);
      BOOL v123 = 1;
      fwrite("Extract archive\n", 0x10uLL, 1uLL, *v121);
      fprintf(*v121, "%12u worker threads\n", *(_DWORD *)(v11 + 1060));
      fprintf(*v121, "%12u directories\n", *(_DWORD *)(v11 + 1672));
      fprintf(*v121, "%12u regular files\n", *(_DWORD *)(v11 + 1668));
      fprintf(*v121, "%12u symbolic links\n", *(_DWORD *)(v11 + 1676));
      fprintf(*v121, "%12u entries\n", *(_DWORD *)(v11 + 1664));
      fprintf(*v121, "%12.2f time (s)\n", v124);
    }
  }
  for (uint64_t j = 0; j != 3; ++j)
  {
    uint64_t v126 = v119 + 80 * j;
    uint64_t v128 = *(void *)(v126 + 64);
    v127 = (unint64_t *)(v126 + 64);
    if (v128)
    {
      unint64_t v129 = 0;
      v130 = (uint64_t *)(v145 + 80 * j + 72);
      do
      {
        uint64_t v131 = *v130;
        v132 = *(const char **)(*v130 + 32 * v129 + 8);
        if (v132)
        {
          do
          {
            fprintf(*v121, "pending %s\n", v132);
            v132 = *(const char **)&v132[8 * j + 2336];
          }
          while (v132);
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterFree", 485, 72, 0, "cluster has pending entries %d/%llu", v133, v134, j);
          while (1)
          {
            uint64_t v131 = *v130;
            uint64_t v135 = *v130 + 32 * v129;
            uint64_t v138 = *(void *)(v135 + 8);
            v137 = (void *)(v135 + 8);
            uint64_t v136 = v138;
            if (!v138) {
              break;
            }
            void *v137 = *(void *)(v136 + 8 * v129 + 2336);
            entryRelease(v136, v40, v41, v42, v43, v44, v45, v46);
          }
        }
        entryRelease(*(void *)(v131 + 32 * v129++), v40, v41, v42, v43, v44, v45, v46);
      }
      while (v129 < *v127);
    }
    uint64_t v119 = v11 + 1312;
    pthread_mutex_destroy((pthread_mutex_t *)(v145 + 80 * j));
    free(*(void **)(v145 + 80 * j + 72));
  }
  free(*(void **)(v11 + 1568));
  free(*(void **)(v11 + 1624));
  memset_s((void *)(v11 + 1616), 0x10uLL, 0, 0x10uLL);
  free(*(void **)(v11 + 1304));
  free(*(void **)(v11 + 1592));
  free((void *)v11);
  return (v123 - 1);
}

int AAByteStreamClose(AAByteStream s)
{
  if (!s) {
    return 0;
  }
  if (*(void *)s) {
    int v2 = (*((uint64_t (**)(void))s + 1))();
  }
  else {
    int v2 = 0;
  }
  free(s);
  return v2;
}

uint64_t sendEOF(uint64_t a1)
{
  int v2 = 0;
  uint64_t result = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 392), (unsigned int *)&v2, 1u);
  if (!v2)
  {
    if ((currentWriteBufferFull((unsigned int *)a1) & 0x80000000) == 0)
    {
      if ((SharedArrayEnqueue_0((unsigned int *)a1, -2) & 0x80000000) == 0) {
        return 0;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"sendEOF", 351, 73, 0, "SharedArrayEnqueue", v4, v5, v6);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t extractThreadSendCommand(uint64_t a1, int a2, size_t a3, const void *a4)
{
  int buf = a2;
  size_t v14 = a3;
  if (AAByteStreamWrite(*(AAByteStream *)(a1 + 16), &buf, 0xCuLL) == 12)
  {
    if (!a3 || AAByteStreamWrite(*(AAByteStream *)(a1 + 32), a4, a3) == a3) {
      return 0;
    }
    uint64_t v10 = "sending command payload";
    __int16 v11 = 713;
  }
  else
  {
    uint64_t v10 = "sending command";
    __int16 v11 = 708;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadSendCommand", v11, 72, 0, v10, v7, v8, v12);
  return 0xFFFFFFFFLL;
}

uint64_t SharedBufferWrite(size_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 400))) {
    return -1;
  }
  if (!a3) {
    return (int)sendEOF(a1);
  }
  uint64_t v10 = a2;
  return SharedBufferFillFromStream(a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferReadFromBufferProc, (uint64_t)&v10, a5, a6, a7, a8);
}

uint64_t SharedBufferFillFromStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (!atomic_load((unsigned int *)(a1 + 400)))
    {
      if (atomic_load((unsigned int *)(a1 + 392)))
      {
        __int16 v11 = "write after EOF";
        __int16 v12 = 365;
LABEL_26:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferFillFromStream", v12, 73, 0, v11, a7, a8, v45);
      }
      else
      {
        unint64_t v14 = a2;
        uint64_t v15 = 0;
        size_t v16 = a1 + 256;
        while (1)
        {
          uint64_t v17 = *(unsigned int *)(a1 + 384);
          if (v17 <= 3)
          {
            uint64_t v22 = *(void *)(v16 + 32 * v17 + 24);
          }
          else
          {
            if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 144)))
            {
              uint64_t v42 = "SharedArrayPop: pthread_mutex_lock failed\n";
              __int16 v43 = 91;
LABEL_25:
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v43, 0, v42, v18, v19, v20, v45);
              __int16 v11 = "SharedArrayPop";
              __int16 v12 = 378;
              goto LABEL_26;
            }
            while (1)
            {
              int v21 = *(_DWORD *)(a1 + 128);
              if (v21) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(a1 + 208), (pthread_mutex_t *)(a1 + 144)))
              {
                uint64_t v42 = "SharedArrayPop: pthread_cond_wait failed\n";
                __int16 v43 = 94;
                goto LABEL_25;
              }
            }
            unsigned int v23 = v21 - 1;
            *(_DWORD *)(a1 + 128) = v23;
            uint64_t v17 = *(unsigned int *)(*(void *)(a1 + 136) + 4 * v23);
            if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144)))
            {
              uint64_t v42 = "SharedArrayPop: pthread_mutex_unlock failed\n";
              __int16 v43 = 98;
              goto LABEL_25;
            }
            if (v17 > 3) {
              goto LABEL_27;
            }
            uint64_t v22 = 0;
            *(_DWORD *)(a1 + 384) = v17;
            size_t v28 = v16 + 32 * v17;
            *(void *)(v28 + 16) = 0;
            *(void *)(v28 + 24) = 0;
          }
          size_t v29 = v16;
          unsigned int v30 = (uint64_t *)(v16 + 32 * v17);
          uint64_t v32 = v30 + 1;
          uint64_t v31 = v30[1];
          uint64_t v35 = *v30;
          uint64_t v34 = v30 + 3;
          uint64_t v33 = v35;
          unint64_t v36 = v31 - v22;
          if (v36 >= v14) {
            unint64_t v37 = v14;
          }
          else {
            unint64_t v37 = v36;
          }
          uint64_t v38 = a3(a4, v33 + v22, v37);
          if (v38 < 0)
          {
            __int16 v11 = "stream read";
            __int16 v12 = 393;
            goto LABEL_26;
          }
          uint64_t v39 = v38;
          if (!v38) {
            break;
          }
          uint64_t v40 = *v34 + v38;
          *uint64_t v34 = v40;
          BOOL v41 = v40 == *v32;
          size_t v16 = v29;
          if (v41 && (currentWriteBufferFull((unsigned int *)a1) & 0x80000000) != 0) {
            goto LABEL_27;
          }
          v15 += v39;
          v14 -= v39;
          if (!v14) {
            goto LABEL_32;
          }
        }
        if ((sendEOF(a1) & 0x80000000) == 0)
        {
LABEL_32:
          if ((currentWriteBufferFull((unsigned int *)a1) & 0x80000000) == 0) {
            return v15;
          }
        }
      }
LABEL_27:
      SharedBufferAbort(a1, v24, v25, v26, v27, v18, v19, v20, v45);
    }
  }
  return -1;
}

uint64_t currentWriteBufferFull(unsigned int *a1)
{
  unsigned int v1 = a1[96];
  a1[96] = -1;
  if (v1 > 3 || (SharedArrayEnqueue_0(a1, v1) & 0x80000000) == 0) {
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"currentWriteBufferFull", 324, 73, 0, "SharedArrayEnqueue", v2, v3, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t SharedArrayEnqueue(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    uint64_t v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 157;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    if (v10 >= v11)
    {
      int v12 = *a1;
    }
    else
    {
      if (v10) {
        memmove((void *)(*((void *)a1 + 1) + 4), *((const void **)a1 + 1), 4 * v10);
      }
      **((_DWORD **)a1 + 1) = a2;
      int v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        uint64_t v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 168;
      }
      else
      {
        if (v10 < v11) {
          return 0;
        }
        uint64_t v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 169;
      }
    }
    else
    {
      uint64_t v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 166;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayEnqueue", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

uint64_t SharedArrayEnqueue_0(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    uint64_t v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 157;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    if (v10 >= v11)
    {
      int v12 = *a1;
    }
    else
    {
      if (v10) {
        memmove((void *)(*((void *)a1 + 1) + 4), *((const void **)a1 + 1), 4 * v10);
      }
      **((_DWORD **)a1 + 1) = a2;
      int v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        uint64_t v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 168;
      }
      else
      {
        if (v10 < v11) {
          return 0;
        }
        uint64_t v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 169;
      }
    }
    else
    {
      uint64_t v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 166;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayEnqueue", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

size_t SharedBufferReadFromBufferProc(const void **a1, void *__dst, size_t a3)
{
  *a1 = (char *)*a1 + a3;
  return a3;
}

ssize_t AAByteStreamWrite(AAByteStream s, const void *buf, size_t nbyte)
{
  uint64_t v3 = (uint64_t (*)(void, const void *, size_t))*((void *)s + 3);
  if (v3) {
    return v3(*(void *)s, buf, nbyte);
  }
  else {
    return -1;
  }
}

uint64_t aaSharedBufferOStreamClose(size_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (SharedBufferDecRefCount(a1)) {
    SharedBufferDestroy(a1);
  }
  return 0;
}

uint64_t aaSharedBufferIStreamClose(uint64_t a1)
{
  if (SharedBufferDecRefCount(a1)) {
    SharedBufferDestroy(a1);
  }
  return 0;
}

BOOL SharedBufferDecRefCount(uint64_t a1)
{
  return atomic_fetch_add((atomic_uint *volatile)(a1 + 404), 0xFFFFFFFF) == 1;
}

void SharedBufferDestroy(uint64_t a1)
{
  if (a1)
  {
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 80))) {
      free(*(void **)(a1 + 8));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 144)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 208))) {
      free(*(void **)(a1 + 136));
    }
    free((void *)a1);
  }
}

uint64_t afStreamClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 48));
    BOOL v3 = v2 == 0;
    if (AAByteStreamClose(*(AAByteStream *)(result + 40)) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamClose", 197, 67, 0, "closing AFSC stream", v4, v5, v15);
      BOOL v3 = 0;
    }
    if (*(void *)(v1 + 120) && *(void *)(v1 + 104))
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      while (1)
      {
        uint64_t v8 = (uint64_t *)(*(void *)(v1 + 120) + v6);
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        uint64_t v17 = 0;
        uint64_t v18 = *v8;
        uint64_t v19 = v8[1] - v18;
        if (fcntl(*(_DWORD *)v1, 99, &v17) < 0) {
          break;
        }
        ++v7;
        v6 += 16;
        if (v7 >= *(void *)(v1 + 104)) {
          goto LABEL_11;
        }
      }
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamClose", 209, 67, "F_PUNCHHOLE failed", v9, v10, v11, v16);
    }
LABEL_11:
    if ((*(unsigned char *)(v1 + 8) & 0x10) != 0 && fcntl(*(_DWORD *)v1, 51) == -1)
    {
      int v12 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamClose", 218, 67, *v12, "Final FULLFSYNC", v13, v14, 0);
    }
    if ((*(_DWORD *)v1 & 0x80000000) == 0 && !*(_DWORD *)(v1 + 4)) {
      close(*(_DWORD *)v1);
    }
    free(*(void **)(v1 + 80));
    memset_s((void *)(v1 + 64), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 120));
    free((void *)v1);
    return (v3 - 1);
  }
  return result;
}

pthread_mutex_t *retireThreadProc(pthread_mutex_t *a1)
{
  unsigned int v2 = (pthread_mutex_t *)&a1->__opaque[8];
  sig = (void *)a1->__sig;
  if (pthread_mutex_lock((pthread_mutex_t *)&a1->__opaque[8])) {
    goto LABEL_64;
  }
  while (1)
  {
    unint64_t v4 = *(void *)&a1[1].__opaque[16];
    if (v4 >= *(void *)&a1[1].__opaque[24])
    {
      if (!pthread_mutex_unlock(v2)) {
        goto LABEL_63;
      }
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v5 = *(void *)&a1[1].__opaque[32];
      *(void *)&a1[1].__opaque[16] = v4 + 1;
      uint64_t v6 = *(void *)(v5 + 8 * v4);
      if (!pthread_mutex_unlock(v2))
      {
        if (!v6) {
          return a1;
        }
        goto LABEL_9;
      }
    }
    uint64_t v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadDequeue", 643, 72, *v14, "pthread_mutex_unlock", v15, v16, v63);
    if (!v6) {
      return a1;
    }
LABEL_9:
    int v17 = *(_DWORD *)(v6 + 2300);
    if (v17 == -1) {
      goto LABEL_62;
    }
    if (v17 == 2)
    {
      *(_DWORD *)(v6 + 2300) = 3;
      uint64_t v18 = (void (*)(void, uint64_t, uint64_t, uint64_t))sig[130];
      if (v18) {
        v18(sig[129], 21, v6, v6 + 2272);
      }
    }
    uint64_t v19 = *(void *)(v6 + 2048);
    if (v19 != 70)
    {
LABEL_30:
      if (v19 == 72)
      {
        uint64_t v30 = sig[195];
        if (v30 == sig[194])
        {
          uint64_t v31 = 2 * v30;
          BOOL v32 = v30 == 0;
          uint64_t v33 = 32;
          if (!v32) {
            uint64_t v33 = v31;
          }
          sig[194] = v33;
          if ((unint64_t)(8 * v33) >= 0x2000000001)
          {
            *__error() = 12;
LABEL_56:
            sig[196] = 0;
            uint64_t v48 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"hlinkInsertEntry", 455, 72, *v48, "malloc", v49, v50, v63);
            sig[194] = 0;
            sig[195] = 0;
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadProc", 681, 72, 0, "hlinkInsertEntry failed: %s", v51, v52, v6);
            goto LABEL_59;
          }
          uint64_t v40 = (void *)sig[196];
          uint64_t v34 = realloc(v40, 8 * v33);
          if (!v34)
          {
            free(v40);
            goto LABEL_56;
          }
          sig[196] = v34;
          uint64_t v30 = sig[195];
        }
        else
        {
          uint64_t v34 = (void *)sig[196];
        }
        sig[195] = v30 + 1;
        v34[v30] = v6;
        atomic_fetch_add((atomic_uint *volatile)(v6 + 2304), 1u);
        uint64_t v19 = *(void *)(v6 + 2048);
      }
      if (v19 != 68) {
        goto LABEL_62;
      }
      uint64_t v41 = sig[198];
      if (v41 == sig[197])
      {
        uint64_t v42 = 2 * v41;
        BOOL v32 = v41 == 0;
        uint64_t v43 = 32;
        if (!v32) {
          uint64_t v43 = v42;
        }
        sig[197] = v43;
        if ((unint64_t)(8 * v43) >= 0x2000000001)
        {
          *__error() = 12;
LABEL_58:
          sig[199] = 0;
          uint64_t v53 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"dirInsertEntry", 433, 72, *v53, "malloc", v54, v55, v63);
          sig[197] = 0;
          sig[198] = 0;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadProc", 687, 72, 0, "dirInsertEntry failed: %s", v56, v57, v6);
          goto LABEL_59;
        }
        char v45 = (void *)sig[199];
        uint64_t v44 = realloc(v45, 8 * v43);
        if (!v44)
        {
          free(v45);
          goto LABEL_58;
        }
        sig[199] = v44;
        uint64_t v41 = sig[198];
      }
      else
      {
        uint64_t v44 = (void *)sig[199];
      }
      sig[198] = v41 + 1;
      v44[v41] = v6;
      atomic_fetch_add((atomic_uint *volatile)(v6 + 2304), 1u);
      goto LABEL_62;
    }
    unint64_t v20 = 0;
    int v21 = (pthread_mutex_t *)(sig + 164);
    while (1)
    {
      uint64_t v22 = *(void *)(v6 + 8 * v20 + 2312);
      if (v22 == -1) {
        goto LABEL_28;
      }
      if (pthread_mutex_lock(v21) < 0)
      {
        int v35 = *__error();
        __int16 v38 = 561;
        uint64_t v39 = "pthread_mutex_lock";
        goto LABEL_53;
      }
      uint64_t v25 = *(void *)v21[1].__opaque;
      if (!v20) {
        break;
      }
      uint64_t v26 = *(void *)(v6 + 2312);
      if (v26 == -1) {
        break;
      }
      *(void *)(v25 + 32 * v22 + 16) = v26;
      if (v20 >= 2)
      {
        uint64_t v27 = *(void *)(v6 + 2320);
        if (v27 != -1) {
          goto LABEL_24;
        }
      }
LABEL_27:
      if (pthread_mutex_unlock(v21) < 0) {
        goto LABEL_52;
      }
LABEL_28:
      ++v20;
      int v21 = (pthread_mutex_t *)((char *)v21 + 80);
      if (v20 == 3)
      {
        uint64_t v19 = *(void *)(v6 + 2048);
        goto LABEL_30;
      }
    }
    if (v20 >= 2)
    {
      uint64_t v27 = *(void *)(v6 + 2320);
      if (v27 != -1)
      {
LABEL_24:
        *(void *)(v25 + 32 * v22 + 24) = v27;
        goto LABEL_27;
      }
    }
    unint64_t v28 = v6 + 8 * v20;
    if (!*(void *)(v28 + 2336))
    {
      uint64_t v29 = v25 + 32 * v22;
      *(void *)(v28 + 2336) = *(void *)(v29 + 8);
      *(void *)(v29 + 8) = v6;
      atomic_fetch_add((atomic_uint *volatile)(v6 + 2304), 1u);
      goto LABEL_27;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterInsertEntry", 574, 72, 0, "entry already linked", v23, v24, v63);
    if ((pthread_mutex_unlock(v21) & 0x80000000) == 0) {
      goto LABEL_54;
    }
LABEL_52:
    int v35 = *__error();
    __int16 v38 = 585;
    uint64_t v39 = "pthread_mutex_unlock";
LABEL_53:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"clusterInsertEntry", v38, 72, v35, v39, v36, v37, v63);
LABEL_54:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadProc", 674, 72, 0, "clusterInsertEntry failed: %s", v46, v47, v6);
LABEL_59:
    if (*(_DWORD *)(v6 + 2300) != -1)
    {
      *(_DWORD *)(v6 + 2300) = -1;
      uint64_t v58 = (void (*)(void, uint64_t, uint64_t, uint64_t))sig[130];
      if (v58) {
        v58(sig[129], 22, v6, v6 + 2272);
      }
    }
LABEL_62:
    entryRelease(v6, v7, v8, v9, v10, v11, v12, v13);
LABEL_63:
    if (pthread_mutex_lock(v2))
    {
LABEL_64:
      BOOL v59 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadDequeue", 637, 72, *v59, "pthread_mutex_lock", v60, v61, v63);
      return a1;
    }
  }
}

void entryRelease(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && atomic_fetch_add((atomic_uint *volatile)(a1 + 2304), 0xFFFFFFFF) == 1)
  {
    int v9 = *(_DWORD *)(a1 + 2300);
    if (v9 != -1 && v9 != 3) {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryDestroy", 223, 72, 0, "invalid entry final state %d: %s", a7, a8, *(_DWORD *)(a1 + 2300));
    }
    if (atomic_load((unsigned int *)(a1 + 2304)))
    {
      char v12 = atomic_load((unsigned int *)(a1 + 2304));
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryDestroy", 224, 72, 0, "invalid entry final ref count %u: %s", a7, a8, v12);
    }
    if ((*(_DWORD *)(a1 + 2296) & 0x80000000) == 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryDestroy", 226, 72, 0, "invalid entry final fd", a7, a8, v13);
      close(*(_DWORD *)(a1 + 2296));
    }
    AAByteStreamClose(*(AAByteStream *)(a1 + 2288));
    free(*(void **)(a1 + 2216));
    memset_s((void *)(a1 + 2200), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 2240));
    memset_s((void *)(a1 + 2224), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 2264));
    memset_s((void *)(a1 + 2248), 0x18uLL, 0, 0x18uLL);
    free((void *)a1);
  }
}

uint64_t aaFileStreamClose(int *a1)
{
  if (a1)
  {
    if (a1[1])
    {
      int v2 = *a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }
    free(a1);
  }
  return 0;
}

uint64_t aaDecompressionStreamClose(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 56);
    switch(v2)
    {
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 312));
        break;
      case 4:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 96));
        break;
      case 3:
        lzma_end();
        break;
    }
    IDecoderStreamDestroy(*(void **)(a1 + 72));
    free(*(void **)(a1 + 24));
    memset_s((void *)(a1 + 8), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 48));
    memset_s((void *)(a1 + 32), 0x18uLL, 0, 0x18uLL);
    free((void *)a1);
  }
  return 0;
}

uint64_t ThreadPipelineDestroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (unsigned int *)result;
    int v2 = *(void **)(result + 8);
    if (v2)
    {
      uint64_t v3 = *(unsigned int *)result;
      if (!v3)
      {
        int v6 = 1;
        goto LABEL_41;
      }
      int v4 = 0;
      do
      {
        if (*v2) {
          ++v4;
        }
        v2 += 51;
        --v3;
      }
      while (v3);
      if (v4)
      {
        int v5 = 0;
        int v6 = 1;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 14)))
          {
            __int16 v10 = 91;
            uint64_t v11 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_15:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v10, 0, v11, v7, v8, v9, v41);
            unsigned int v15 = -1;
          }
          else
          {
            while (1)
            {
              unsigned int v12 = v1[10];
              if (v12) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 30), (pthread_mutex_t *)(v1 + 14)))
              {
                __int16 v10 = 94;
                uint64_t v11 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_15;
              }
            }
            unsigned int v22 = v12 - 1;
            v1[10] = v22;
            unsigned int v15 = *(_DWORD *)(*((void *)v1 + 6) + 4 * v22);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 14))) {
              goto LABEL_17;
            }
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v23, v24, v25, v41);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 237, 87, 0, "SharedArrayPop", v13, v14, v42);
          int v6 = 0;
LABEL_17:
          uint64_t v16 = *((void *)v1 + 1);
          uint64_t v17 = v16 + 408 * v15;
          *(void *)(v17 + 400) = -1;
          if (pthread_mutex_lock((pthread_mutex_t *)(v17 + 48))
            || (uint64_t v20 = v16 + 408 * v15, v21 = *(_DWORD *)(v20 + 40), *(_DWORD *)(v20 + 40) = v21 + 1, !v21)
            && pthread_cond_broadcast((pthread_cond_t *)(v16 + 408 * v15 + 112))
            || pthread_mutex_unlock((pthread_mutex_t *)(v17 + 48)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 245, 87, 0, "SemRelease", v18, v19, v41);
            int v6 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v17) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 246, 87, 0, "joinThread", v26, v27, v41);
            int v6 = 0;
          }
          *(void *)uint64_t v17 = 0;
          if (++v5 == v4)
          {
            if (!*v1) {
              goto LABEL_41;
            }
            goto LABEL_33;
          }
        }
      }
      int v6 = 1;
LABEL_33:
      unint64_t v28 = 0;
      uint64_t v29 = 352;
      do
      {
        uint64_t v30 = *((void *)v1 + 1);
        uint64_t v31 = v30 + v29;
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v30 + v29 - 304))) {
          pthread_cond_destroy((pthread_cond_t *)(v31 - 240));
        }
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v31 - 184))) {
          pthread_cond_destroy((pthread_cond_t *)(v30 + v29 - 120));
        }
        BOOL v32 = (pthread_cond_t *)(v30 + v29);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v32[-2].__opaque[24])) {
          pthread_cond_destroy(v32);
        }
        ++v28;
        v29 += 408;
      }
      while (v28 < *v1);
LABEL_41:
      free(*((void **)v1 + 1));
      *((void *)v1 + 1) = 0;
    }
    else
    {
      int v6 = 1;
    }
    uint64_t v33 = (_opaque_pthread_t **)*((void *)v1 + 2);
    if (v33)
    {
      if (*v33)
      {
        if ((SharedArrayEnqueue_0(v1 + 42, -1) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 272, 87, 0, "SharedArrayEnqueue", v34, v35, v41);
          int v6 = 0;
        }
        if ((joinThread(*v33) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 273, 87, 0, "joinThread", v36, v37, v41);
          int v6 = 0;
        }
        int *v33 = 0;
        uint64_t v33 = (_opaque_pthread_t **)*((void *)v1 + 2);
      }
      free(v33);
      *((void *)v1 + 2) = 0;
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 14)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 30))) {
      free(*((void **)v1 + 6));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 46)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 62))) {
      free(*((void **)v1 + 22));
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 76))) {
      pthread_cond_destroy((pthread_cond_t *)(v1 + 92));
    }
    int v40 = atomic_load(v1 + 104);
    if (v40 >= 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 285, 87, 0, "Threads reported errors", v38, v39, v41);
      int v6 = 0;
    }
    free(v1);
    if (v6) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t joinThread(_opaque_pthread_t *a1)
{
  uint64_t v27 = 0;
  uint64_t v1 = pthread_join(a1, &v27);
  if (v1)
  {
    uint64_t v4 = v1;
    int v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 623, 5, *v5, "pthread_join", v6, v7, v26);
    uint64_t v8 = 0;
    goto LABEL_26;
  }
  uint64_t v8 = v27;
  if (*((_WORD *)v27 + 14) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 627, 5, 0, "expected ref_count=1 for terminating thread", v2, v3, v26);
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_26;
  }
  pthread_key_t ErrorContextKey = getErrorContextKey();
  __int16 v10 = pthread_getspecific(ErrorContextKey);
  if (!v10) {
    goto LABEL_25;
  }
  uint64_t v11 = v10;
  int v12 = *v10;
  if ((*v10 & 0x80000000) == 0)
  {
    int v13 = v8[6];
    if (v13 < 0)
    {
      *__int16 v10 = v13;
      int v12 = v13;
    }
  }
  unsigned int v14 = *((unsigned __int16 *)v8 + 48);
  if (!*((_WORD *)v8 + 48))
  {
LABEL_15:
    if (v12)
    {
      uint64_t v4 = 0;
      *((_WORD *)v11 + 3) = 0;
      goto LABEL_26;
    }
    if (*((_WORD *)v8 + 15))
    {
      unint64_t v19 = 0;
      uint64_t v20 = *((unsigned __int16 *)v11 + 3);
      LODWORD(v21) = 16 - v20;
      if (v20 <= 0x10) {
        uint64_t v21 = v21;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = (uint64_t)&v11[v20 + 2];
      __int16 v23 = v20 + 1;
      do
      {
        if (v21 == v19) {
          break;
        }
        *(_DWORD *)(v22 + 4 * v19) = v8[v19 + 8];
        *((_WORD *)v11 + 3) = v23 + v19++;
      }
      while (v19 < *((unsigned __int16 *)v8 + 15));
    }
LABEL_25:
    uint64_t v4 = 0;
    goto LABEL_26;
  }
  unsigned int v15 = 0;
  while (1)
  {
    uint64_t v16 = (_WORD *)((char *)v8 + v15 + 100);
    uint64_t v4 = (unsigned __int16)*v16;
    if (!*v16) {
      break;
    }
    unsigned __int16 v17 = v15 + v4;
    if (v15 + v4 > v14) {
      goto LABEL_25;
    }
    uint64_t v18 = *((unsigned __int16 *)v11 + 36);
    if ((int)v18 + (int)v4 <= *((unsigned __int16 *)v11 + 37))
    {
      memcpy((char *)v11 + v18 + 76, v16, (unsigned __int16)*v16);
      *((_WORD *)v11 + 36) += v4;
      unsigned int v15 = v17;
      unsigned int v14 = *((unsigned __int16 *)v8 + 48);
      if (v14 > v17) {
        continue;
      }
    }
    int v12 = *v11;
    goto LABEL_15;
  }
LABEL_26:
  uint64_t v24 = (const void *)*((void *)v8 + 2);
  if (v24) {
    _Block_release(v24);
  }
  free(v8);
  return v4;
}

uint64_t threadWrapperProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  setThreadErrorContext((const void *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8, v17);
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  setThreadErrorContext(0, v9, v10, v11, v12, v13, v14, v15, v18);
  return a1;
}

size_t setThreadErrorContext(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t result = pthread_setspecific(ErrorContextKey, a1);
  if (result)
  {
    int v12 = *__error();
    return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"setThreadErrorContext", 65, 5, v12, "pthread_setspecific", v13, v14, a9);
  }
  return result;
}

uint64_t getErrorContextKey()
{
  if (pthread_once(&getErrorContextKey_errorContextOnce, (void (*)(void))createErrorContextKey))
  {
    v0 = __error();
    pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "getErrorContextKey", 53, 5, *v0, "pthread_once");
  }
  return gErrorContextKey;
}

void IDecoderStreamDestroy(void *a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a1[8])
    {
      while (1)
      {
        uint64_t v2 = SharedBufferRead(a1[8], (uint64_t)v10, 0x400uLL);
        if (v2 < 0) {
          break;
        }
        if (!v2) {
          goto LABEL_7;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 155, 39, 0, "flushing shared buffer", v3, v4, v9);
    }
LABEL_7:
    int v5 = (_opaque_pthread_t *)a1[7];
    if (v5)
    {
      if (joinThread(v5))
      {
        uint64_t v6 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 163, 39, *v6, "failed to join decoder thread", v7, v8, v9);
      }
    }
    SharedBufferDestroy(a1[8]);
    free(a1);
  }
}

uint64_t __createThread_block_invoke(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))(*(void *)(*(void *)(a1 + 32) + 8));
}

AAArchiveStream AADecodeArchiveInputStreamOpen(AAByteStream stream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  char v9 = (char *)malloc(0x4C0uLL);
  uint64_t v10 = v9;
  if (v9) {
    memset_s(v9, 0x4C0uLL, 0, 0x4C0uLL);
  }
  uint64_t v11 = malloc(0x38uLL);
  int v12 = v11;
  if (!v11 || (memset_s(v11, 0x38uLL, 0, 0x38uLL), !v10))
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 388;
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"AADecodeArchiveInputStreamOpen", v23, 61, v21, v22, v19, v20, v25);
    free(v12);
    decodeStreamClose(v10);
    return 0;
  }
  size_t v13 = *((void *)v10 + 5);
  if (!(v13 >> 18))
  {
    do
    {
      size_t v14 = (v13 >> 1) + v13;
      if (((v13 >> 1) & v13) != 0) {
        size_t v14 = ((v13 >> 1) & v13) + v13;
      }
      if (v13) {
        size_t v13 = v14;
      }
      else {
        size_t v13 = 0x4000;
      }
    }
    while (v13 < 0x40000);
    uint64_t v15 = (void *)*((void *)v10 + 6);
    uint64_t v16 = realloc(v15, v13);
    if (!v16)
    {
      free(v15);
      *((void *)v10 + 4) = 0;
      *((void *)v10 + 5) = 0;
      *((void *)v10 + 6) = 0;
      uint64_t v22 = "init buffer";
      __int16 v23 = 391;
      goto LABEL_24;
    }
    *((void *)v10 + 5) = v13;
    *((void *)v10 + 6) = v16;
  }
  *((void *)v10 + 1) = stream;
  *((_DWORD *)v10 + 14) = -1;
  *(_OWORD *)(v10 + 72) = xmmword_214B130F0;
  char v17 = malloc(0x10000uLL);
  *((void *)v10 + 8) = v17;
  if (!v17)
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 397;
    goto LABEL_19;
  }
  *((void *)v10 + 11) = AAHeaderCreate();
  AAHeader v18 = AAHeaderCreate();
  *((void *)v10 + 12) = v18;
  if (!*((void *)v10 + 11) || !v18)
  {
    uint64_t v22 = "allocating header";
    __int16 v23 = 400;
LABEL_24:
    int v21 = 0;
    goto LABEL_19;
  }
  *(void *)uint64_t v10 = flags;
  *((void *)v10 + 2) = msg_proc;
  *((void *)v10 + 3) = msg_data;
  *((double *)v10 + 151) = getRealTime();
  v12[5] = decodeStreamReadHeader;
  v12[6] = decodeStreamReadBlob;
  v12[2] = decodeStreamAbort;
  *int v12 = v10;
  v12[1] = decodeStreamClose;
  return (AAArchiveStream)v12;
}

AAHeader AAHeaderCreate(void)
{
  v0 = (AAHeader_impl *)malloc(0x30uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x30uLL, 0, 0x30uLL);
    if ((init_blob_with_magic((uint64_t)v1) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderCreate", 473, 101, 0, "init_blob_with_magic", v2, v3, v8);
      AAHeaderDestroy(v1);
      return 0;
    }
  }
  else
  {
    uint64_t v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderCreate", 470, 101, *v4, "malloc", v5, v6, v8);
  }
  return v1;
}

ssize_t AAArchiveStreamProcess(AAArchiveStream istream, AAArchiveStream ostream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v36 = 0;
  AAHeader header = 0;
  uint64_t __s = 0;
  uint64_t v10 = malloc(0x40000uLL);
  if (!v10)
  {
    int v32 = *__error();
    uint64_t v30 = "malloc";
    __int16 v31 = 24;
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStreamProcess.c", (uint64_t)"AAArchiveStreamProcess", v31, 16, v32, v30, v19, v20, (char)v34);
    ssize_t v12 = -1;
    goto LABEL_35;
  }
  int v11 = AAArchiveStreamReadHeader(istream, &header);
  if (v11 < 0)
  {
LABEL_29:
    AAArchiveStreamCancel(ostream);
    uint64_t v30 = "archive stream read error (header)";
    __int16 v31 = 32;
LABEL_33:
    int v32 = 0;
    goto LABEL_34;
  }
  ssize_t v12 = 0;
  while (v11)
  {
    if (!msg_proc) {
      goto LABEL_41;
    }
    size_t v13 = header;
    v14.ikey = 5521744;
    uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v14);
    if ((KeyIndex & 0x80000000) != 0) {
      goto LABEL_41;
    }
    unsigned int FieldString = AAHeaderGetFieldString(v13, KeyIndex, 0x400uLL, value, 0);
    int v17 = FieldString <= 1 ? 1 : FieldString;
    if (v17 < 1) {
      goto LABEL_41;
    }
    int v18 = ((uint64_t (*)(void *, uint64_t, char *, AAHeader))msg_proc)(msg_data, 50, value, header);
    if (v18 < 0)
    {
      uint64_t v30 = "callback cancel";
      __int16 v31 = 45;
      goto LABEL_33;
    }
    if (!v18)
    {
LABEL_41:
      if ((aaHeaderBlobArrayInitWithHeader((uint64_t)&__s, header) & 0x80000000) != 0)
      {
        uint64_t v30 = "capturing non-empty blobs";
        __int16 v31 = 55;
        goto LABEL_33;
      }
      if (AAArchiveStreamWriteHeader(ostream, header) < 0)
      {
        AAArchiveStreamCancel(istream);
        uint64_t v30 = "archive stream write error (header)";
        __int16 v31 = 61;
        goto LABEL_33;
      }
      ++v12;
      unint64_t v21 = __s;
      if (__s)
      {
        uint64_t v34 = msg_data;
        uint64_t v22 = 0;
        while (1)
        {
          __int16 v23 = (char *)v36 + 24 * v22;
          char v25 = (unint64_t *)(v23 + 8);
          unint64_t v24 = *((void *)v23 + 1);
          if (v24) {
            break;
          }
LABEL_26:
          if (++v22 >= v21)
          {
            msg_data = v34;
            goto LABEL_28;
          }
        }
        while (1)
        {
          if (v24 >= 0x40000) {
            size_t v26 = 0x40000;
          }
          else {
            size_t v26 = v24;
          }
          AAFieldKey v27 = *(AAFieldKey *)v23;
          if (AAArchiveStreamReadBlob(istream, v27, v10, v26) < 0)
          {
            AAArchiveStreamCancel(ostream);
            uint64_t v30 = "archive stream read error (blob)";
            __int16 v31 = 75;
            goto LABEL_33;
          }
          AAFieldKey v28 = *(AAFieldKey *)v23;
          if (AAArchiveStreamWriteBlob(ostream, v28, v10, v26) < 0) {
            break;
          }
          unint64_t v24 = *v25 - v26;
          BOOL v29 = *v25 == v26;
          *char v25 = v24;
          if (v29)
          {
            unint64_t v21 = __s;
            goto LABEL_26;
          }
        }
        AAArchiveStreamCancel(istream);
        uint64_t v30 = "archive stream write error (blob)";
        __int16 v31 = 80;
        goto LABEL_33;
      }
    }
LABEL_28:
    int v11 = AAArchiveStreamReadHeader(istream, &header);
    if (v11 < 0) {
      goto LABEL_29;
    }
  }
LABEL_35:
  AAHeaderDestroy(header);
  free(v36);
  memset_s(&__s, 0x10uLL, 0, 0x10uLL);
  free(v10);
  return v12;
}

uint64_t extractStreamWriteBlob(uint64_t a1, size_t a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 1600))) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  if (__smax && !*(_DWORD *)(a1 + 1608))
  {
    ssize_t v12 = *(void **)(a1 + 1632);
    uint64_t v13 = *(void *)(a1 + 1640);
    if (*(_OWORD *)(a1 + 1632) == 0)
    {
      AAFieldKey v14 = "no active entry or active thread";
      __int16 v15 = 1423;
LABEL_8:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteBlob", v15, 72, 0, v14, a7, a8, v60);
      extractStreamStateFail(a1);
      return 0xFFFFFFFFLL;
    }
    unsigned int v16 = *(_DWORD *)(a1 + 1648);
    if (v16 >= *(_DWORD *)(a1 + 1616))
    {
      uint64_t v19 = "invalid blob reference";
      __int16 v20 = 1424;
      goto LABEL_13;
    }
    uint64_t v17 = *(void *)(a1 + 1624);
    int v18 = *(_DWORD *)(v17 + 24 * v16);
    if (((v18 ^ a2) & 0xFFFFFF) != 0)
    {
      uint64_t v19 = "inconsistent blob key";
      __int16 v20 = 1428;
LABEL_13:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteBlob", v20, 72, 0, v19, a7, a8, v60);
      return 0xFFFFFFFFLL;
    }
    uint64_t v21 = v17 + 24 * v16;
    rsize_t v23 = *(void *)(v21 + 8);
    uint64_t v22 = (void *)(v21 + 8);
    if (v23 < __smax)
    {
      uint64_t v19 = "too many blob bytes received";
      __int16 v20 = 1429;
      goto LABEL_13;
    }
    uint64_t v25 = *(void *)&v18 & 0xFFFFFFLL;
    if ((*(void *)&v18 & 0xFFFFFFuLL) <= 0x544143)
    {
      if (v25 != 4408665)
      {
        if (v25 == 4997953)
        {
          if (v12)
          {
            uint64_t v26 = v12[278];
            BOOL v27 = __CFADD__(v26, __smax);
            unint64_t v28 = v26 + __smax;
            if (v27 || (v28 & 0x8000000000000000) != 0) {
              goto LABEL_112;
            }
            BOOL v29 = v12 + 278;
            a2 = v12[279];
            if (a2 < v28)
            {
              do
              {
                while (!a2)
                {
                  a2 = 0x4000;
                  if (v28 <= 0x4000)
                  {
                    __int16 v31 = (void **)(v12 + 280);
                    a2 = 0x4000;
                    goto LABEL_68;
                  }
                }
                size_t v30 = a2 >> 1;
                if ((a2 & (a2 >> 1)) != 0) {
                  size_t v30 = a2 & (a2 >> 1);
                }
                a2 += v30;
              }
              while (a2 < v28);
              __int16 v31 = (void **)(v12 + 280);
              if (a2 >= 0x2000000001)
              {
                uint64_t v61 = (void **)(v12 + 280);
                *__error() = 12;
                goto LABEL_111;
              }
LABEL_68:
              size_t v60 = a2;
              uint64_t v61 = v31;
              char v42 = *v31;
              uint64_t v43 = realloc(*v31, a2);
              if (v43)
              {
                v12[280] = v43;
                v12[279] = v60;
                goto LABEL_70;
              }
              free(v42);
LABEL_111:
              *uint64_t v61 = 0;
              *BOOL v29 = 0;
              v12[279] = 0;
              goto LABEL_112;
            }
LABEL_70:
            uint64_t v44 = v12[280];
            if (__src)
            {
              memcpy((void *)(v44 + *v29), __src, __smax);
            }
            else if (v44)
            {
              memset_s((void *)(v44 + *v29), __smax, 0, __smax);
            }
            *v29 += __smax;
            if ((__smax & 0x8000000000000000) != 0)
            {
LABEL_112:
              AAFieldKey v14 = "too many blob bytes received";
              __int16 v15 = 1438;
              goto LABEL_8;
            }
          }
          if (v13 && (extractThreadSendCommand(v13, 65, __smax, __src) & 0x80000000) != 0)
          {
            AAFieldKey v14 = "sending blob";
            __int16 v15 = 1439;
            goto LABEL_8;
          }
        }
        goto LABEL_97;
      }
      if (!v12) {
        goto LABEL_96;
      }
      uint64_t v37 = v12[281];
      BOOL v27 = __CFADD__(v37, __smax);
      unint64_t v38 = v37 + __smax;
      if (!v27 && (v38 & 0x8000000000000000) == 0)
      {
        uint64_t v39 = v12 + 281;
        a2 = v12[282];
        if (a2 < v38)
        {
          do
          {
            while (!a2)
            {
              a2 = 0x4000;
              if (v38 <= 0x4000)
              {
                char v41 = (void **)(v12 + 283);
                a2 = 0x4000;
                goto LABEL_76;
              }
            }
            size_t v40 = a2 >> 1;
            if ((a2 & (a2 >> 1)) != 0) {
              size_t v40 = a2 & (a2 >> 1);
            }
            a2 += v40;
          }
          while (a2 < v38);
          char v41 = (void **)(v12 + 283);
          if (a2 >= 0x2000000001)
          {
            char v63 = (void **)(v12 + 283);
            *__error() = 12;
            goto LABEL_117;
          }
LABEL_76:
          size_t v60 = a2;
          char v63 = v41;
          uint64_t v48 = *v41;
          uint64_t v49 = realloc(*v41, a2);
          if (v49)
          {
            v12[283] = v49;
            v12[282] = v60;
            goto LABEL_78;
          }
          free(v48);
LABEL_117:
          uint64_t *v63 = 0;
          void *v39 = 0;
          v12[282] = 0;
          goto LABEL_118;
        }
LABEL_78:
        uint64_t v50 = v12[283];
        if (__src)
        {
          memcpy((void *)(v50 + *v39), __src, __smax);
        }
        else if (v50)
        {
          memset_s((void *)(v50 + *v39), __smax, 0, __smax);
        }
        *v39 += __smax;
        if ((__smax & 0x8000000000000000) == 0)
        {
LABEL_96:
          if (v13 && (extractThreadSendCommand(v13, 89, __smax, __src) & 0x80000000) != 0)
          {
            AAFieldKey v14 = "sending blob";
            __int16 v15 = 1444;
            goto LABEL_8;
          }
          goto LABEL_97;
        }
      }
LABEL_118:
      AAFieldKey v14 = "too many blob bytes received";
      __int16 v15 = 1443;
      goto LABEL_8;
    }
    if (v25 == 5521732)
    {
      if (!v12 || v12[274] != -1)
      {
        if (!v13)
        {
          if ((extractStreamSendEntryToExtractThread(a1) & 0x80000000) != 0)
          {
            AAFieldKey v14 = "send entry to thread";
            __int16 v15 = 1453;
            goto LABEL_8;
          }
          uint64_t v13 = *(void *)(a1 + 1640);
        }
        if ((extractThreadSendCommand(v13, 68, __smax, __src) & 0x80000000) != 0)
        {
          AAFieldKey v14 = "sending DAT blob";
          __int16 v15 = 1457;
          goto LABEL_8;
        }
      }
      goto LABEL_97;
    }
    if (v25 != 5521752)
    {
LABEL_97:
      BOOL v51 = *v22 == __smax;
      *v22 -= __smax;
      if (!v51) {
        return 0;
      }
      int v52 = *(_DWORD *)(a1 + 1648);
      uint64_t v53 = (v52 + 1);
      *(_DWORD *)(a1 + 1648) = v53;
      uint64_t v54 = *(unsigned int *)(a1 + 1616);
      if (v53 < v54)
      {
        uint64_t v55 = *(void *)(a1 + 1624);
        if (!*(void *)(v55 + 24 * v53 + 8))
        {
          uint64_t v56 = (uint64_t *)(v55 + 24 * v53 + 32);
          uint64_t v57 = ~v53 + v54;
          int v58 = v52 + 2;
          do
          {
            LODWORD(v53) = v58;
            if (!v57) {
              break;
            }
            uint64_t v59 = *v56;
            v56 += 3;
            --v57;
            ++v58;
          }
          while (!v59);
          *(_DWORD *)(a1 + 1648) = v53;
        }
      }
      if (v53 < v54
        || (extractStreamEntryEnd(a1, a2, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) == 0)
      {
        return 0;
      }
      uint64_t v19 = "end entry failed";
      __int16 v20 = 1472;
      goto LABEL_13;
    }
    if (!v12) {
      goto LABEL_90;
    }
    uint64_t v32 = v12[275];
    BOOL v27 = __CFADD__(v32, __smax);
    unint64_t v33 = v32 + __smax;
    if (!v27 && (v33 & 0x8000000000000000) == 0)
    {
      uint64_t v34 = v12 + 275;
      a2 = v12[276];
      if (a2 < v33)
      {
        do
        {
          while (!a2)
          {
            a2 = 0x4000;
            if (v33 <= 0x4000)
            {
              uint64_t v36 = (void **)(v12 + 277);
              a2 = 0x4000;
              goto LABEL_72;
            }
          }
          size_t v35 = a2 >> 1;
          if ((a2 & (a2 >> 1)) != 0) {
            size_t v35 = a2 & (a2 >> 1);
          }
          a2 += v35;
        }
        while (a2 < v33);
        uint64_t v36 = (void **)(v12 + 277);
        if (a2 >= 0x2000000001)
        {
          v62 = (void **)(v12 + 277);
          *__error() = 12;
          goto LABEL_114;
        }
LABEL_72:
        size_t v60 = a2;
        v62 = v36;
        char v45 = *v36;
        uint64_t v46 = realloc(*v36, a2);
        if (v46)
        {
          v12[277] = v46;
          v12[276] = v60;
          goto LABEL_74;
        }
        free(v45);
LABEL_114:
        uint64_t *v62 = 0;
        *uint64_t v34 = 0;
        v12[276] = 0;
        goto LABEL_115;
      }
LABEL_74:
      uint64_t v47 = v12[277];
      if (__src)
      {
        memcpy((void *)(v47 + *v34), __src, __smax);
      }
      else if (v47)
      {
        memset_s((void *)(v47 + *v34), __smax, 0, __smax);
      }
      *v34 += __smax;
      if ((__smax & 0x8000000000000000) == 0)
      {
LABEL_90:
        if (v13 && (extractThreadSendCommand(v13, 88, __smax, __src) & 0x80000000) != 0)
        {
          AAFieldKey v14 = "sending blob";
          __int16 v15 = 1434;
          goto LABEL_8;
        }
        goto LABEL_97;
      }
    }
LABEL_115:
    AAFieldKey v14 = "too many blob bytes received";
    __int16 v15 = 1433;
    goto LABEL_8;
  }
  return result;
}

uint64_t decodeStreamReadBlob(uint64_t a1, int a2, char *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v25[2] = *MEMORY[0x263EF8340];
  if (a4)
  {
    unsigned int v9 = *(_DWORD *)(a1 + 1168);
    if (v9 >= *(_DWORD *)(a1 + 1152)) {
      goto LABEL_7;
    }
    while (1)
    {
      uint64_t v13 = *(void *)(a1 + 1160);
      uint64_t v14 = v13 + 24 * v9;
      unsigned int v16 = (void *)(v14 + 8);
      unint64_t v15 = *(void *)(v14 + 8);
      if (((*(_DWORD *)v14 ^ a2) & 0xFFFFFF) == 0)
      {
        if (v15) {
          break;
        }
      }
      if ((decodeStreamDiscard(a1, v15) & 0x80000000) != 0)
      {
        uint64_t v17 = "reading blob data";
        __int16 v18 = 321;
        goto LABEL_9;
      }
      *unsigned int v16 = 0;
      unsigned int v9 = *(_DWORD *)(a1 + 1168) + 1;
      *(_DWORD *)(a1 + 1168) = v9;
      if (v9 >= *(_DWORD *)(a1 + 1152)) {
        goto LABEL_7;
      }
    }
    if (v15 < a4)
    {
LABEL_7:
      uint64_t v17 = "invalid read blob request";
      __int16 v18 = 326;
    }
    else if ((decodeStreamReadData(a1, a3, a4) & 0x80000000) != 0)
    {
      uint64_t v17 = "read error";
      __int16 v18 = 329;
    }
    else
    {
      size_t v21 = *v16 - a4;
      BOOL v20 = *v16 == a4;
      *unsigned int v16 = v21;
      if (v20) {
        ++*(_DWORD *)(a1 + 1168);
      }
      uint64_t v22 = *(uint64_t (**)(void, uint64_t, uint64_t, void *))(a1 + 16);
      if (!v22) {
        return 0;
      }
      if (!*(unsigned char *)(a1 + 104)) {
        return 0;
      }
      if ((*(_DWORD *)v14 & 0xFFFFFF) != 0x544144) {
        return 0;
      }
      size_t v23 = *(void *)(v13 + 24 * v9 + 16) - v21;
      v25[0] = *(void *)(v13 + 24 * v9 + 16);
      v25[1] = v23;
      if ((v22(*(void *)(a1 + 24), 60, a1 + 104, v25) & 0x80000000) == 0) {
        return 0;
      }
      uint64_t v17 = "callback cancel";
      __int16 v18 = 342;
    }
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"decodeStreamReadBlob", v18, 61, 0, v17, a7, a8, v24);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t decodeStreamLoadHeader(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[9];
  size_t v9 = a2 - v8;
  if (a2 <= v8) {
    return 0;
  }
  if (a1[10] >= a2)
  {
    if ((decodeStreamReadData((uint64_t)a1, (char *)(a1[8] + v8), v9) & 0x80000000) == 0)
    {
      uint64_t result = 0;
      a1[9] += v9;
      return result;
    }
    int v11 = "read error";
    __int16 v12 = 96;
  }
  else
  {
    int v11 = "invalid header size";
    __int16 v12 = 94;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"decodeStreamLoadHeader", v12, 61, 0, v11, a7, a8, v14);
  return 0xFFFFFFFFLL;
}

uint64_t decodeStreamReadData(uint64_t a1, char *__dst, size_t a3)
{
  if (!a3) {
    return 0;
  }
  size_t v3 = a3;
  size_t v6 = *(void *)(a1 + 32);
  while (1)
  {
    if (v6 >= v3) {
      size_t v7 = v3;
    }
    else {
      size_t v7 = v6;
    }
    if (v7)
    {
      memcpy(__dst, *(const void **)(a1 + 48), v7);
      v3 -= v7;
      unint64_t v10 = *(void *)(a1 + 32);
      size_t v6 = v10 - v7;
      if (v10 < v7)
      {
        __int16 v12 = "updating buffer";
        __int16 v13 = 76;
        goto LABEL_19;
      }
      if (v10 != v7) {
        memmove(*(void **)(a1 + 48), (const void *)(*(void *)(a1 + 48) + v7), v10 - v7);
      }
      __dst += v7;
      *(void *)(a1 + 32) = v6;
      *(void *)(a1 + 1136) += v7;
      goto LABEL_13;
    }
    if ((decodeStreamRefillBuffer(a1) & 0x80000000) != 0)
    {
      __int16 v12 = "refill buffer failed";
      __int16 v13 = 82;
      goto LABEL_19;
    }
    size_t v6 = *(void *)(a1 + 32);
    if (!v6) {
      break;
    }
LABEL_13:
    if (!v3) {
      return 0;
    }
  }
  __int16 v12 = "load header failed";
  __int16 v13 = 84;
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"decodeStreamReadData", v13, 61, 0, v12, v8, v9, v14);
  return 0xFFFFFFFFLL;
}

int AAArchiveStreamWriteBlob(AAArchiveStream s, AAFieldKey key, const void *buf, size_t nbyte)
{
  uint64_t v4 = (uint64_t (*)(void, void, const void *, size_t))*((void *)s + 4);
  if (v4) {
    return v4(*(void *)s, key.ikey, buf, nbyte);
  }
  else {
    return -1;
  }
}

int AAArchiveStreamReadBlob(AAArchiveStream s, AAFieldKey key, void *buf, size_t nbyte)
{
  uint64_t v4 = (uint64_t (*)(void, void, void *, size_t))*((void *)s + 6);
  if (v4) {
    return v4(*(void *)s, key.ikey, buf, nbyte);
  }
  else {
    return -1;
  }
}

uint64_t decodeStreamReadHeader(uint64_t a1, AAHeader *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 1132)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  unint64_t v10 = *(void *)(a1 + 1136);
  unint64_t v11 = *(void *)(a1 + 1144);
  if (v11 < v10)
  {
    __int16 v12 = "invalid state";
    __int16 v13 = 193;
    goto LABEL_66;
  }
  if ((decodeStreamDiscard(a1, v11 - v10) & 0x80000000) != 0)
  {
    __int16 v12 = "truncated archive";
    __int16 v13 = 194;
    goto LABEL_66;
  }
  if (!*(void *)(a1 + 32))
  {
    if (*(_DWORD *)(a1 + 1128)) {
      goto LABEL_85;
    }
    if ((decodeStreamRefillBuffer(a1) & 0x80000000) != 0)
    {
      __int16 v12 = "refill buffer";
      __int16 v13 = 199;
      goto LABEL_66;
    }
    if (!*(void *)(a1 + 32))
    {
LABEL_85:
      if (*(_DWORD *)(a1 + 1128)) {
        return 0;
      }
    }
  }
  uint64_t v18 = *(void *)(a1 + 1136);
  *(unsigned char *)(a1 + 104) = 0;
  *(void *)(a1 + 72) = 0;
  if ((decodeStreamLoadHeader((void *)a1, 6uLL, v14, v15, v16, v17, a7, a8) & 0x80000000) != 0)
  {
    __int16 v12 = "truncated stream";
    __int16 v13 = 209;
    goto LABEL_66;
  }
  int v24 = *(_DWORD *)(a1 + 56);
  if (v24 < 0)
  {
    uint64_t v25 = *(int **)(a1 + 64);
    if (*v25 == 825246017 || *v25 == 826360153)
    {
      *(_DWORD *)(a1 + 56) = 0;
LABEL_32:
      int v30 = loadAndDecodeHeader_AA(a1, v19, v20, v21, v22, v23, a7, a8);
      goto LABEL_39;
    }
    if (*v25 == 925906736 && *((_WORD *)v25 + 2) == 12592)
    {
      int v31 = 1;
    }
    else
    {
      int v27 = *v25;
      int v28 = *((unsigned __int16 *)v25 + 2);
      if (v27 != 925906736 || v28 != 14128)
      {
        __int16 v12 = "Invalid/non-supported archive stream";
        __int16 v13 = 226;
        goto LABEL_66;
      }
      int v31 = 2;
    }
    *(_DWORD *)(a1 + 56) = v31;
    goto LABEL_38;
  }
  if ((v24 - 1) < 2)
  {
LABEL_38:
    int v30 = loadAndDecodeHeader_Cpio((uint64_t *)a1, (unint64_t *)&v52);
    goto LABEL_39;
  }
  if (v24 != 3)
  {
    if (v24)
    {
      __int16 v12 = "Invalid archive stream";
      __int16 v13 = 240;
      goto LABEL_66;
    }
    goto LABEL_32;
  }
  int v30 = loadAndDecodeHeader_Ustar(a1, (uint64_t *)&v52);
LABEL_39:
  if (v30 < 0)
  {
    __int16 v12 = "parsing entry header";
    __int16 v13 = 242;
    goto LABEL_66;
  }
  if (v30) {
    return 0;
  }
  uint64_t v33 = *(void *)(a1 + 72);
  uint64_t v34 = *(AAHeader_impl **)(a1 + 88);
  v35.ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(v34, v35);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(v34, KeyIndex, &v51), FieldUInt <= 1) ? (int v38 = 1) : (int v38 = FieldUInt), v38 <= 0))
  {
    __int16 v12 = "Invalid entry: no TYP field";
    __int16 v13 = 249;
    goto LABEL_66;
  }
  if (v51 != 77)
  {
    uint64_t v39 = *(AAHeader_impl **)(a1 + 88);
    v40.ikey = 5521744;
    uint32_t v41 = AAHeaderGetKeyIndex(v39, v40);
    if ((v41 & 0x80000000) == 0)
    {
      unsigned int FieldString = AAHeaderGetFieldString(v39, v41, 0x400uLL, (char *)(a1 + 104), 0);
      int v43 = FieldString <= 1 ? 1 : FieldString;
      if (v43 >= 1)
      {
        size_t v44 = strlen((const char *)(a1 + 104));
        if (!pathIsValid((unsigned char *)(a1 + 104), v44))
        {
          __int16 v12 = "Invalid entry path";
          __int16 v13 = 255;
          goto LABEL_66;
        }
      }
    }
  }
  char v45 = *(uint64_t (**)(void, uint64_t, uint64_t, void))(a1 + 16);
  if (v45 && *(unsigned char *)(a1 + 104) && (v45(*(void *)(a1 + 24), 60, a1 + 104, 0) & 0x80000000) != 0)
  {
    __int16 v12 = "callback cancel";
    __int16 v13 = 262;
    goto LABEL_66;
  }
  if ((aaHeaderBlobArrayInitWithHeader(a1 + 1152, *(AAHeader_impl **)(a1 + 88)) & 0x80000000) != 0)
  {
    __int16 v12 = "initializing blob array";
    __int16 v13 = 266;
    goto LABEL_66;
  }
  *(_DWORD *)(a1 + 1168) = 0;
  if (!*(_DWORD *)(a1 + 56)) {
    uint64_t v52 = aaHeaderBlobArrayPayloadSize((unsigned int *)(a1 + 1152));
  }
  if (!a2)
  {
LABEL_77:
    ++*(void *)(a1 + 1200);
    *(void *)(a1 + 1144) = v33 + v18 + v52;
    return 1;
  }
  uint64_t v46 = *a2;
  if (*a2)
  {
    if (AAHeaderAssign(*a2, *(AAHeader *)(a1 + 88)) < 0)
    {
      __int16 v12 = "header init";
      __int16 v13 = 286;
      goto LABEL_66;
    }
  }
  else
  {
    uint64_t v46 = AAHeaderClone(*(AAHeader *)(a1 + 88));
    if (!v46)
    {
      __int16 v12 = "header init";
      __int16 v13 = 282;
      goto LABEL_66;
    }
  }
  if ((*(unsigned char *)(a1 + 1) & 1) == 0
    || (v47.ikey = 5784649, (AAHeaderGetKeyIndex(v46, v47) & 0x80000000) == 0)
    || (v48.ikey = 5915721, (AAHeaderGetKeyIndex(v46, v48) & 0x80000000) == 0)
    || (v49.ikey = 5784649, (AAHeaderSetFieldUInt(v46, 0xFFFFFFFF, v49, v18) & 0x80000000) == 0)
    && (v50.ikey = 5915721, (AAHeaderSetFieldUInt(v46, 0xFFFFFFFF, v50, v52 + v33) & 0x80000000) == 0))
  {
    *a2 = v46;
    goto LABEL_77;
  }
  __int16 v12 = "inserting IDX,IDZ fields";
  __int16 v13 = 295;
LABEL_66:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"decodeStreamReadHeader", v13, 61, 0, v12, a7, a8, v51);
  if (!*(_DWORD *)(a1 + 1132))
  {
    *(_DWORD *)(a1 + 1132) = 1;
    AAByteStreamCancel(*(AAByteStream *)(a1 + 8));
  }
  return 0xFFFFFFFFLL;
}

uint64_t decodeStreamDiscard(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  unint64_t v2 = a2;
  unint64_t v4 = *(void *)(a1 + 32);
  while (1)
  {
    if (v4 >= v2) {
      unint64_t v5 = v2;
    }
    else {
      unint64_t v5 = v4;
    }
    if (v5)
    {
      unint64_t v6 = v4 - v5;
      if (v4 > v2) {
        memmove(*(void **)(a1 + 48), (const void *)(*(void *)(a1 + 48) + v5), v4 - v5);
      }
      *(void *)(a1 + 32) = v6;
      v2 -= v5;
      *(void *)(a1 + 1136) += v5;
      goto LABEL_12;
    }
    if ((decodeStreamRefillBuffer(a1) & 0x80000000) != 0)
    {
      unint64_t v10 = "refill buffer failed";
      __int16 v11 = 56;
      goto LABEL_17;
    }
    unint64_t v6 = *(void *)(a1 + 32);
    if (!v6) {
      break;
    }
LABEL_12:
    unint64_t v4 = v6;
    if (!v2) {
      return 0;
    }
  }
  unint64_t v10 = "discard data failed";
  __int16 v11 = 58;
LABEL_17:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"decodeStreamDiscard", v11, 61, 0, v10, v7, v8, v12);
  return 0xFFFFFFFFLL;
}

int AAArchiveStreamReadHeader(AAArchiveStream s, AAHeader *header)
{
  unint64_t v2 = (uint64_t (*)(void, AAHeader *))*((void *)s + 5);
  if (v2) {
    return v2(*(void *)s, header);
  }
  else {
    return -1;
  }
}

BOOL pathIsValid(unsigned char *a1, size_t __n)
{
  if (!__n) {
    return 1;
  }
  if (__n > 0x3FF) {
    return 0;
  }
  unint64_t v5 = memchr(a1, 0, __n);
  BOOL result = 0;
  if (v5) {
    return result;
  }
  if (*a1 == 47) {
    return 0;
  }
  uint64_t v6 = 0;
  do
  {
    uint64_t v7 = &a1[v6];
    uint64_t v8 = memchr(&a1[v6], 47, __n - v6);
    if (!v8) {
      break;
    }
    uint64_t v9 = v8 - a1;
    uint64_t v10 = v8 - a1 - v6;
    if (v8 - a1 == v6) {
      return 0;
    }
    if (v6 && v10 == 1)
    {
      int v11 = *v7;
      goto LABEL_13;
    }
    if (v10 == 2 && *v7 == 46)
    {
      int v11 = a1[v6 + 1];
LABEL_13:
      if (v11 == 46) {
        return 0;
      }
    }
    uint64_t v6 = v9 + 1;
  }
  while (v9 + 1 < __n);
  return v6 != __n;
}

uint64_t loadAndDecodeHeader_AA(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72) > 5uLL)
  {
    if ((decodeStreamLoadHeader((void *)a1, *(unsigned __int16 *)(*(void *)(a1 + 64) + 4), a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      uint64_t v8 = "truncated stream";
      __int16 v9 = 110;
    }
    else
    {
      if ((aaHeaderInitWithEncodedData(*(void *)(a1 + 88), *(unsigned __int16 **)(a1 + 64), *(void *)(a1 + 72)) & 0x80000000) == 0) {
        return 0;
      }
      uint64_t v8 = "corrupted archive header";
      __int16 v9 = 113;
    }
  }
  else
  {
    uint64_t v8 = "Invalid decoder state";
    __int16 v9 = 106;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"loadAndDecodeHeader_AA", v9, 61, 0, v8, a7, a8, v12);
  return 0xFFFFFFFFLL;
}

uint64_t extractStreamWriteHeader(uint64_t a1, AAHeader header, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v104 = *MEMORY[0x263EF8340];
  uint64_t size = 0;
  uint64_t value = -1;
  uint64_t offset = 0;
  uint64_t v9 = *(void *)(a1 + 1024);
  *(_DWORD *)(a1 + 1608) = 0;
  if (*(void *)(a1 + 1632) || *(void *)(a1 + 1640))
  {
    uint64_t v10 = "invalid extract state";
    __int16 v11 = 1245;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", v11, 72, 0, v10, a7, a8, v95);
LABEL_5:
    extractStreamStateFail(a1);
    return 0xFFFFFFFFLL;
  }
  v15.ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v15);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    uint64_t v32 = "AA entry missing TYP field";
    __int16 v33 = 1249;
LABEL_24:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", v33, 72, v32, v17, v18, v19, v95);
    goto LABEL_25;
  }
  if (value - 66 > 0x11 || ((1 << (value - 66)) & 0x24457) == 0)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1608) = 1;
    return result;
  }
  length[0] = 0;
  v21.ikey = 5521744;
  uint32_t v22 = AAHeaderGetKeyIndex(header, v21);
  if ((v22 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v22, 0x400uLL, __s, length) >= 2)
  {
    uint64_t v32 = "YAA entry missing/invalid PAT field";
    __int16 v33 = 1274;
    goto LABEL_24;
  }
  uint64_t v23 = *(uint64_t (**)(void, uint64_t, char *, AAHeader))(a1 + 1040);
  if (v23)
  {
    int v24 = v23(*(void *)(a1 + 1032), 20, __s, header);
    if (v24 < 0)
    {
      uint64_t v10 = "user cancelled";
      __int16 v11 = 1284;
      goto LABEL_4;
    }
    if (!v24)
    {
      int v25 = (*(uint64_t (**)(void, uint64_t, char *, size_t *))(a1 + 1040))(*(void *)(a1 + 1032), 27, __s, length);
      if (v25 < 0)
      {
        uint64_t v10 = "user cancelled";
        __int16 v11 = 1289;
        goto LABEL_4;
      }
      if (v25) {
        __strlcpy_chk();
      }
      goto LABEL_20;
    }
LABEL_25:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1608) = 1;
    return result;
  }
LABEL_20:
  uint64_t v26 = value;
  if (strlen(__s) >= 0x400)
  {
    BOOL v29 = "path too long";
    __int16 v30 = 198;
    int v31 = 0;
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"entryCreate", v30, 72, v31, v29, v27, v28, v95);
    *(void *)(a1 + 1632) = 0;
    uint64_t v10 = "entry creation";
    __int16 v11 = 1295;
    goto LABEL_4;
  }
  uint64_t v34 = (char *)malloc(0x938uLL);
  if (!v34)
  {
    int v31 = *__error();
    BOOL v29 = "malloc";
    __int16 v30 = 200;
    goto LABEL_34;
  }
  AAFieldKey v35 = v34;
  memset_s(v34, 0x938uLL, 0, 0x938uLL);
  __memcpy_chk();
  *((void *)v35 + 256) = v26;
  *((_DWORD *)v35 + 574) = -1;
  *((void *)v35 + 289) = -1;
  *((void *)v35 + 290) = -1;
  *((void *)v35 + 291) = -1;
  *((void *)v35 + 273) = -1;
  *((void *)v35 + 274) = -1;
  atomic_store(1u, (unsigned int *)v35 + 576);
  *(void *)(a1 + 1632) = v35;
  ++*(_DWORD *)(a1 + 1664);
  switch(value)
  {
    case 'L':
      ++*(_DWORD *)(a1 + 1676);
      break;
    case 'F':
      ++*(_DWORD *)(a1 + 1668);
      break;
    case 'D':
      ++*(_DWORD *)(a1 + 1672);
      break;
  }
  if ((aaHeaderBlobArrayInitWithHeader(a1 + 1616, header) & 0x80000000) != 0)
  {
    uint64_t v10 = "Eerror getting blobs from header";
    __int16 v11 = 1307;
    goto LABEL_4;
  }
  if ((aaEntryAttributesInitWithHeader(v35 + 2056, v35 + 2128, 0, header) & 0x80000000) != 0)
  {
    uint64_t v10 = "getting attributes from header";
    __int16 v11 = 1310;
    goto LABEL_4;
  }
  uint64_t v36 = *(uint64_t (**)(void, uint64_t, char *, char *))(a1 + 1040);
  if (v36)
  {
    if ((v36(*(void *)(a1 + 1032), 23, v35, v35 + 2056) & 0x80000000) != 0)
    {
      uint64_t v10 = "message callback cancelled operations";
      __int16 v11 = 1314;
      goto LABEL_4;
    }
    uint64_t v37 = *(uint64_t (**)(void, uint64_t, char *, char *))(a1 + 1040);
    if (v37
      && (*(unsigned char *)(a1 + 1030) & 0x10) != 0
      && (v37(*(void *)(a1 + 1032), 26, v35, v35 + 2128) & 0x80000000) != 0)
    {
      uint64_t v10 = "message callback cancelled operations";
      __int16 v11 = 1320;
      goto LABEL_4;
    }
  }
  if ((v35[2056] & 4) != 0 && (v35[2068] & 0x20) != 0 && (v35[2128] & 1) != 0 && *((_DWORD *)v35 + 534) == -1)
  {
    uint64_t v10 = "disable AFSC by clearing UF_COMPRESSED";
    __int16 v11 = 1325;
    goto LABEL_4;
  }
  v38.ikey = 4997953;
  uint32_t v39 = AAHeaderGetKeyIndex(header, v38);
  if ((v39 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v39, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000) != 0)
    {
LABEL_166:
      uint64_t v10 = "ACL blob allocation";
      __int16 v11 = 1331;
      goto LABEL_4;
    }
    size_t v40 = *((void *)v35 + 279);
    if (v40 < size)
    {
      do
      {
        while (!v40)
        {
          size_t v40 = 0x4000;
          if (size <= 0x4000)
          {
            char v42 = (void **)(v35 + 2240);
            size_t v40 = 0x4000;
            goto LABEL_66;
          }
        }
        size_t v41 = v40 >> 1;
        if ((v40 & (v40 >> 1)) != 0) {
          size_t v41 = v40 & (v40 >> 1);
        }
        v40 += v41;
      }
      while (v40 < size);
      char v42 = (void **)(v35 + 2240);
      if (v40 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_165;
      }
LABEL_66:
      int v43 = *v42;
      size_t v44 = realloc(*v42, v40);
      if (v44)
      {
        *((void *)v35 + 280) = v44;
        *((void *)v35 + 279) = v40;
        goto LABEL_68;
      }
      free(v43);
LABEL_165:
      void *v42 = 0;
      *((void *)v35 + 278) = 0;
      *((void *)v35 + 279) = 0;
      goto LABEL_166;
    }
  }
LABEL_68:
  v45.ikey = 5521752;
  uint32_t v46 = AAHeaderGetKeyIndex(header, v45);
  if ((v46 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v46, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000) != 0)
    {
LABEL_169:
      uint64_t v10 = "XAT blob allocation";
      __int16 v11 = 1335;
      goto LABEL_4;
    }
    size_t v47 = *((void *)v35 + 276);
    if (v47 < size)
    {
      do
      {
        while (!v47)
        {
          size_t v47 = 0x4000;
          if (size <= 0x4000)
          {
            AAFieldKey v49 = (void **)(v35 + 2216);
            size_t v47 = 0x4000;
            goto LABEL_81;
          }
        }
        size_t v48 = v47 >> 1;
        if ((v47 & (v47 >> 1)) != 0) {
          size_t v48 = v47 & (v47 >> 1);
        }
        v47 += v48;
      }
      while (v47 < size);
      AAFieldKey v49 = (void **)(v35 + 2216);
      if (v47 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_168;
      }
LABEL_81:
      AAFieldKey v50 = *v49;
      uint64_t v51 = realloc(*v49, v47);
      if (v51)
      {
        *((void *)v35 + 277) = v51;
        *((void *)v35 + 276) = v47;
        goto LABEL_83;
      }
      free(v50);
LABEL_168:
      *AAFieldKey v49 = 0;
      *((void *)v35 + 275) = 0;
      *((void *)v35 + 276) = 0;
      goto LABEL_169;
    }
  }
LABEL_83:
  v52.ikey = 4408665;
  uint32_t v53 = AAHeaderGetKeyIndex(header, v52);
  if ((v53 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v53, &size, &offset) <= 1)
  {
    if ((size & 0x8000000000000000) != 0)
    {
LABEL_172:
      uint64_t v10 = "YEC blob allocation";
      __int16 v11 = 1339;
      goto LABEL_4;
    }
    size_t v54 = *((void *)v35 + 282);
    if (v54 < size)
    {
      do
      {
        while (!v54)
        {
          size_t v54 = 0x4000;
          if (size <= 0x4000)
          {
            uint64_t v56 = (void **)(v35 + 2264);
            size_t v54 = 0x4000;
            goto LABEL_97;
          }
        }
        size_t v55 = v54 >> 1;
        if ((v54 & (v54 >> 1)) != 0) {
          size_t v55 = v54 & (v54 >> 1);
        }
        v54 += v55;
      }
      while (v54 < size);
      uint64_t v56 = (void **)(v35 + 2264);
      if (v54 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_171;
      }
LABEL_97:
      uint64_t v57 = *v56;
      int v58 = realloc(*v56, v54);
      if (v58)
      {
        *((void *)v35 + 283) = v58;
        *((void *)v35 + 282) = v54;
        goto LABEL_99;
      }
      free(v57);
LABEL_171:
      *uint64_t v56 = 0;
      *((void *)v35 + 281) = 0;
      *((void *)v35 + 282) = 0;
      goto LABEL_172;
    }
  }
LABEL_99:
  uint64_t v98 = 0;
  *((void *)v35 + 284) = -1;
  *((void *)v35 + 285) = -1;
  v59.ikey = 5784649;
  uint32_t v60 = AAHeaderGetKeyIndex(header, v59);
  if ((v60 & 0x80000000) == 0)
  {
    unsigned int FieldUInt = AAHeaderGetFieldUInt(header, v60, &v98);
    int v62 = FieldUInt <= 1 ? 1 : FieldUInt;
    if (v62 >= 1) {
      *((void *)v35 + 284) = v98;
    }
  }
  v63.ikey = 5915721;
  uint32_t v64 = AAHeaderGetKeyIndex(header, v63);
  if ((v64 & 0x80000000) == 0)
  {
    unsigned int v70 = AAHeaderGetFieldUInt(header, v64, &v98);
    int v71 = v70 <= 1 ? 1 : v70;
    if (v71 >= 1) {
      *((void *)v35 + 285) = v98;
    }
  }
  if (value == 70)
  {
    *((void *)v35 + 274) = -1;
    v72.ikey = 5521732;
    uint32_t v73 = AAHeaderGetKeyIndex(header, v72);
    if ((v73 & 0x80000000) == 0 && AAHeaderGetFieldBlob(header, v73, &size, &offset) <= 1) {
      *((void *)v35 + 274) = size;
    }
    uint64_t v74 = 0;
    int v75 = 0;
    uint64_t v76 = v9 & 0x10;
    int v77 = 0;
    do
    {
      if (v74 == 2 && v76) {
        break;
      }
      v78.ikey = 4410451;
      if (v74 != 2) {
        v78.ikey = 4144959;
      }
      if (v74 == 1) {
        v78.ikey = 4410435;
      }
      if (v74) {
        AAFieldKey v79 = v78;
      }
      else {
        v79.ikey = 4410440;
      }
      uint64_t v97 = -1;
      uint32_t v80 = AAHeaderGetKeyIndex(header, v79);
      if ((v80 & 0x80000000) == 0 && AAHeaderGetFieldUInt(header, v80, &v97) <= 1)
      {
        uint64_t v81 = v97;
        *(void *)&v35[8 * v74 + 2312] = v97;
        uint64_t v96 = 0;
        if (*((void *)v35 + 274) == -1) {
          uint64_t v82 = 0;
        }
        else {
          uint64_t v82 = (uint64_t)v35;
        }
        int updated = clusterEntryUpdateDAT(a1, v74, v81, v82, &v96);
        if (updated < 0)
        {
          uint64_t v10 = "cluster entry query";
          __int16 v11 = 1371;
          goto LABEL_4;
        }
        if (updated) {
          int v77 = 1;
        }
        if (v96) {
          BOOL v84 = updated == 0;
        }
        else {
          BOOL v84 = 0;
        }
        if (v84) {
          int v75 = 1;
        }
      }
      ++v74;
    }
    while (v74 != 3);
    if (!v77 && v75 && *((void *)v35 + 274) != -1) {
      *((void *)v35 + 274) = -1;
    }
  }
  else if ((value & 0xFFFFFFFFFFFFFFFBLL) == 0x48)
  {
    uint64_t v97 = 0;
    v85.ikey = 4935244;
    uint32_t v86 = AAHeaderGetKeyIndex(header, v85);
    if ((v86 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v86, 0x400uLL, v35 + 1024, &v97) > 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", 1389, 72, 0, "YAA link entry has no LNK field: %s", a7, a8, (char)__s);
      goto LABEL_5;
    }
  }
  else if ((value & 0xFFFFFFFFFFFFFFFELL) == 0x42)
  {
    v87.ikey = 5653828;
    uint32_t v88 = AAHeaderGetKeyIndex(header, v87);
    if ((v88 & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, v88, (uint64_t *)v35 + 273) >= 2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamWriteHeader", 1394, 72, 0, "YAA device entry has no DEV field: %s", a7, a8, (char)__s);
      goto LABEL_5;
    }
  }
  *(_DWORD *)(a1 + 1648) = 0;
  uint64_t v89 = *(unsigned int *)(a1 + 1616);
  if (v89 && (uint64_t v90 = *(void *)(a1 + 1624), !*(void *)(v90 + 8)))
  {
    uint64_t v92 = (uint64_t *)(v90 + 32);
    uint64_t v93 = 1;
    do
    {
      unsigned int v91 = v93;
      if (v89 == v93) {
        break;
      }
      uint64_t v94 = *v92;
      v92 += 3;
      ++v93;
    }
    while (!v94);
    *(_DWORD *)(a1 + 1648) = v91;
  }
  else
  {
    unsigned int v91 = 0;
  }
  if (v91 >= v89 && (extractStreamEntryEnd(a1, v65, v66, v67, v68, v69, a7, a8) & 0x80000000) != 0)
  {
    uint64_t v10 = "end entry";
    __int16 v11 = 1404;
    goto LABEL_4;
  }
  return 0;
}

int AAHeaderGetKeyIndex(AAHeader header, AAFieldKey key)
{
  uint64_t v2 = *(unsigned int *)header;
  if (v2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = (int *)*((void *)header + 1);
    while (1)
    {
      int v6 = *v5;
      v5 += 12;
      if (((v6 ^ key.ikey) & 0xFFFFFF) == 0) {
        break;
      }
      if (v2 == ++v4) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    LODWORD(v4) = -1;
  }
  return v4;
}

uint64_t aaHeaderBlobArrayInitWithHeader(uint64_t a1, AAHeader_impl *a2)
{
  *(_DWORD *)a1 = 0;
  uint64_t v4 = *(unsigned int *)a2;
  if (v4 <= *(_DWORD *)(a1 + 4))
  {
    if (!v4)
    {
      unsigned int v8 = 0;
LABEL_13:
      uint64_t result = 0;
      *(_DWORD *)a1 = v8;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 4) = v4;
    unint64_t v5 = *(void **)(a1 + 8);
    int v6 = realloc(v5, 24 * v4);
    if (!v6)
    {
      free(v5);
      *(void *)(a1 + 8) = 0;
      char v12 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderBlobArrayInitWithHeader", 441, 101, *v12, "malloc", v13, v14, v16);
      *(void *)a1 = 0;
      return 0xFFFFFFFFLL;
    }
    *(void *)(a1 + 8) = v6;
  }
  uint32_t v7 = 0;
  unsigned int v8 = 0;
  while (AAHeaderGetFieldType(a2, v7) != 5)
  {
LABEL_9:
    if (v4 == ++v7) {
      goto LABEL_13;
    }
  }
  uint64_t size = 0;
  if ((AAHeaderGetFieldBlob(a2, v7, &size, &v16) & 0x80000000) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    *(AAFieldKey *)(v11 + 24 * v8) = AAHeaderGetFieldKey(a2, v7);
    *(int64x2_t *)(*(void *)(a1 + 8) + 24 * v8++ + 8) = vdupq_lane_s64(size, 0);
    goto LABEL_9;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderBlobArrayInitWithHeader", 448, 101, 0, "get field blob failed", v9, v10, v16);
  return 0xFFFFFFFFLL;
}

int AAHeaderGetFieldType(AAHeader header, uint32_t i)
{
  if (*(_DWORD *)header > i) {
    return *(_DWORD *)(*((void *)header + 1) + 48 * i + 4);
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldType", 580, 101, 0, "invalid field index %u", v2, v3, i);
  return -1;
}

int AAHeaderGetFieldBlob(AAHeader header, uint32_t i, uint64_t *size, uint64_t *offset)
{
  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldBlob", 658, 101, 0, "invalid field index %u", v4, v5, i);
  }
  else
  {
    uint64_t v6 = *((void *)header + 1);
    if (*(_DWORD *)(v6 + 48 * i + 4) == 5)
    {
      int result = 0;
      uint64_t v8 = v6 + 48 * i;
      *uint64_t size = *(void *)(v8 + 32);
      *uint64_t offset = *(void *)(v8 + 24);
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldBlob", 660, 101, 0, "invalid type %d, expected BLOB", v4, v5, *(_DWORD *)(v6 + 48 * i + 4));
  }
  return -1;
}

int AAHeaderGetFieldString(AAHeader header, uint32_t i, size_t capacity, char *value, size_t *length)
{
  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldString", 602, 101, 0, "invalid field index %u", v5, v6, i);
    return -1;
  }
  uint64_t v7 = *((void *)header + 1);
  if (*(_DWORD *)(v7 + 48 * i + 4) != 2)
  {
    int v14 = *(_DWORD *)(v7 + 48 * i + 4);
    uint64_t v11 = "invalid type %d, expected STRING";
    __int16 v12 = 604;
    goto LABEL_11;
  }
  size_t v9 = *(unsigned int *)(v7 + 48 * i + 40);
  if (length) {
    *length = v9;
  }
  if (!capacity) {
    return 0;
  }
  if (v9 >= capacity) {
    return -1;
  }
  uint64_t v10 = (*(_DWORD *)(v7 + 48 * i + 12) + 6);
  if (v9 + v10 > *((void *)header + 2))
  {
    uint64_t v11 = "invalid blob segment";
    __int16 v12 = 612;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldString", v12, 101, 0, v11, v5, v6, v14);
    return -1;
  }
  memcpy(value, (const void *)(*((void *)header + 4) + v10), v9);
  int result = 0;
  value[v9] = 0;
  return result;
}

uint64_t aaHeaderInitWithEncodedData(uint64_t a1, unsigned __int16 *a2, unint64_t a3)
{
  init_blob_with_magic(a1);
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 40) = 0;
  if (a3 <= 5)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", 113, 101, 0, "invalid header size: %llu", v6, v7, a3);
    goto LABEL_63;
  }
  if (*(_DWORD *)a2 != 826360153 && *(_DWORD *)a2 != 825246017)
  {
    uint64_t v8 = "invalid header magic";
    __int16 v9 = 114;
    goto LABEL_62;
  }
  if (a2[2] != a3)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", 116, 101, 0, "header size mismatch: stored %u, got %llu", v6, v7, a2[2]);
    goto LABEL_63;
  }
  *(void *)(a1 + 16) = 0;
  uint64_t v10 = (void *)(a1 + 16);
  if ((a3 & 0x8000000000000000) != 0) {
    goto LABEL_61;
  }
  size_t v11 = *(void *)(a1 + 24);
  if (v11 >= a3)
  {
    uint64_t v14 = 0;
    AAFieldKey v15 = *(char **)(a1 + 32);
LABEL_22:
    memcpy(&v15[v14], a2, a3);
    goto LABEL_23;
  }
  do
  {
    while (!v11)
    {
      size_t v11 = 0x4000;
      if (a3 <= 0x4000)
      {
        uint64_t v13 = (void **)(a1 + 32);
        size_t v11 = 0x4000;
        goto LABEL_20;
      }
    }
    size_t v12 = v11 >> 1;
    if ((v11 & (v11 >> 1)) != 0) {
      size_t v12 = v11 & (v11 >> 1);
    }
    v11 += v12;
  }
  while (v11 < a3);
  uint64_t v13 = (void **)(a1 + 32);
  if (v11 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_60;
  }
LABEL_20:
  uint64_t v16 = *v13;
  AAFieldKey v15 = (char *)realloc(*v13, v11);
  if (!v15)
  {
    free(v16);
LABEL_60:
    *uint64_t v13 = 0;
    *uint64_t v10 = 0;
    *(void *)(a1 + 24) = 0;
LABEL_61:
    uint64_t v8 = "realloc blob";
    __int16 v9 = 121;
    goto LABEL_62;
  }
  *(void *)(a1 + 24) = v11;
  *(void *)(a1 + 32) = v15;
  uint64_t v14 = *(void *)(a1 + 16);
  if (a2) {
    goto LABEL_22;
  }
  memset_s(&v15[v14], a3, 0, a3);
LABEL_23:
  unint64_t v17 = *v10 + a3;
  *uint64_t v10 = v17;
  if (v17 < 4) {
    goto LABEL_61;
  }
  **(_DWORD **)(a1 + 32) = 825246017;
  if (a3 < 7) {
    return 0;
  }
  size_t v18 = 0;
  unint64_t v19 = 6;
  while (2)
  {
    if ((realloc_fields(a1, *(_DWORD *)a1 + 1) & 0x80000000) != 0)
    {
      uint64_t v8 = "realloc_fields";
      __int16 v9 = 127;
      goto LABEL_62;
    }
    uint64_t v20 = *(void *)(a1 + 8);
    unsigned int v21 = (*(_DWORD *)a1)++;
    if (v19 + 4 > a3)
    {
      uint64_t v8 = "truncated header";
      __int16 v9 = 130;
      goto LABEL_62;
    }
    uint64_t v22 = v20 + 48 * v21;
    uint64_t v23 = (char *)a2 + v19;
    *(_DWORD *)uint64_t v22 = *(_DWORD *)((char *)a2 + v19);
    int v24 = *(char *)(v22 + 3);
    *(_DWORD *)(v22 + 8) = v24;
    *(unsigned char *)(v22 + 3) = 0;
    switch(v24)
    {
      case '1':
        int v25 = 1;
        size_t v26 = 1;
        goto LABEL_50;
      case '2':
        int v25 = 1;
        goto LABEL_36;
      case '3':
      case '5':
      case '6':
      case '7':
      case '9':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case 'D':
      case 'E':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'Q':
      case 'R':
        goto LABEL_68;
      case '4':
        int v25 = 1;
        goto LABEL_40;
      case '8':
        int v25 = 1;
        goto LABEL_48;
      case 'A':
        int v25 = 5;
LABEL_36:
        size_t v26 = 2;
        goto LABEL_50;
      case 'B':
        int v25 = 5;
        goto LABEL_40;
      case 'C':
        int v25 = 5;
        goto LABEL_48;
      case 'F':
        int v25 = 3;
LABEL_40:
        size_t v26 = 4;
        goto LABEL_50;
      case 'G':
        int v25 = 3;
        size_t v26 = 20;
        goto LABEL_50;
      case 'H':
        int v25 = 3;
        size_t v26 = 32;
        goto LABEL_50;
      case 'I':
        int v25 = 3;
        size_t v26 = 48;
        goto LABEL_50;
      case 'J':
        int v25 = 3;
        size_t v26 = 64;
        goto LABEL_50;
      case 'P':
        if (v19 + 6 <= a3)
        {
          size_t v18 = *((unsigned __int16 *)v23 + 2);
          size_t v26 = v18 + 2;
          int v25 = 2;
LABEL_50:
          *(_DWORD *)(v20 + 48 * v21 + 4) = v25;
          if (v19 + 4 + v26 > a3)
          {
            uint64_t v8 = "truncated header";
            __int16 v9 = 161;
            goto LABEL_62;
          }
          uint64_t v27 = 0;
          uint64_t v28 = v20 + 48 * v21;
          *(void *)(v28 + 24) = 0;
          BOOL v29 = (void *)(v28 + 24);
          size_t v30 = v26 + 4;
          *((_DWORD *)v29 - 3) = v19;
          *((_DWORD *)v29 - 2) = v26 + 4;
          v29[2] = 0;
          int v31 = v29 + 2;
          v29[1] = 0;
          switch(v25)
          {
            case 1:
              memcpy(v31, v23 + 4, v26);
              uint64_t v27 = 0;
              break;
            case 2:
              uint64_t v27 = 0;
              *int v31 = v18;
              break;
            case 3:
              uint64_t v27 = 0;
              *int v31 = v26;
              break;
            case 5:
              uint64_t v32 = v20 + 48 * v21;
              memcpy((void *)(v32 + 32), v23 + 4, v26);
              *BOOL v29 = *(void *)(a1 + 40);
              uint64_t v27 = *(void *)(v32 + 32);
              break;
            default:
              break;
          }
          uint64_t result = 0;
          *(void *)(a1 + 40) += v27;
          v19 += v30;
          if (v19 >= a3) {
            return result;
          }
          continue;
        }
        uint64_t v8 = "truncated header";
        __int16 v9 = 153;
LABEL_62:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", v9, 101, 0, v8, v6, v7, v34);
LABEL_63:
        *(_DWORD *)a1 = 0;
        *(void *)(a1 + 16) = 0;
        uint64_t result = 0xFFFFFFFFLL;
        *(void *)(a1 + 40) = 0;
        return result;
      case 'S':
        int v25 = 4;
LABEL_48:
        size_t v26 = 8;
        goto LABEL_50;
      case 'T':
        int v25 = 4;
        size_t v26 = 12;
        goto LABEL_50;
      default:
        if (v24 != 42)
        {
LABEL_68:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"aaHeaderInitWithEncodedData", 159, 101, 0, "invalid field subtype: %d", v6, v7, v24);
          goto LABEL_63;
        }
        int v25 = 0;
        size_t v26 = 0;
        goto LABEL_50;
    }
  }
}

uint64_t realloc_fields(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 4);
  if (v3 >= a2) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 4);
  do
  {
    if (v4) {
      v4 += v4 >> 1;
    }
    else {
      unsigned int v4 = 16;
    }
  }
  while (v4 < a2);
  if (v3 >= v4) {
    return 0;
  }
  if (v4 < 0xAAAAAAAB)
  {
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v7 = realloc(v6, 48 * v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t result = 0;
      *(void *)(a1 + 8) = v8;
      *(_DWORD *)(a1 + 4) = v4;
      return result;
    }
    free(v6);
  }
  else
  {
    *__error() = 12;
  }
  *(void *)(a1 + 8) = 0;
  __int16 v9 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"realloc_fields", 35, 101, *v9, "malloc", v10, v11, v12);
  *(void *)a1 = 0;
  uint64_t result = 0xFFFFFFFFLL;
  *(void *)(a1 + 16) = 0;
  return result;
}

uint64_t init_blob_with_magic(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 16);
  size_t v3 = *(void *)(a1 + 24);
  if (v3 <= 5)
  {
    while (v3)
    {
      size_t v4 = v3 >> 1;
      if ((v3 & (v3 >> 1)) != 0) {
        size_t v4 = v3 & (v3 >> 1);
      }
      v3 += v4;
      if (v3 >= 6) {
        goto LABEL_8;
      }
    }
    size_t v3 = 0x4000;
LABEL_8:
    uint64_t v5 = *(void **)(a1 + 32);
    uint64_t v6 = realloc(v5, v3);
    if (!v6)
    {
      free(v5);
      *(_DWORD *)a1 = 0;
      v2[1] = 0;
      v2[2] = 0;
      *uint64_t v2 = 0;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"init_blob_with_magic", 61, 101, 0, "realloc_blob failed", v13, v14, v18);
      return 0xFFFFFFFFLL;
    }
    *(void *)(a1 + 24) = v3;
    *(void *)(a1 + 32) = v6;
  }
  *(void *)(a1 + 16) = 0;
  **(_DWORD **)(a1 + 32) = 825246017;
  unint64_t v7 = *(void *)(a1 + 16) + 4;
  *(void *)(a1 + 16) = v7;
  unint64_t v8 = v7 + 2;
  if (v7 >= 0xFFFFFFFFFFFFFFFELL || (v8 & 0x8000000000000000) != 0) {
    return 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  if (v9 >= v8)
  {
    AAFieldKey v15 = *(char **)(a1 + 32);
LABEL_28:
    uint64_t result = 0;
    *(_WORD *)&v15[v7] = 6;
    *v2 += 2;
  }
  else
  {
    size_t v10 = 0x4000;
    do
    {
      while (!v9)
      {
        unint64_t v9 = 0x4000;
        if (v8 <= 0x4000) {
          goto LABEL_26;
        }
      }
      unint64_t v11 = v9 >> 1;
      if ((v9 & (v9 >> 1)) != 0) {
        unint64_t v11 = v9 & (v9 >> 1);
      }
      v9 += v11;
    }
    while (v9 < v8);
    size_t v10 = v9;
    if (v9 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_30;
    }
LABEL_26:
    uint64_t v16 = *(void **)(a1 + 32);
    unint64_t v17 = (char *)realloc(v16, v10);
    if (v17)
    {
      AAFieldKey v15 = v17;
      *(void *)(a1 + 24) = v10;
      *(void *)(a1 + 32) = v17;
      unint64_t v7 = *(void *)(a1 + 16);
      goto LABEL_28;
    }
    free(v16);
LABEL_30:
    uint64_t result = 0;
    *(void *)(a1 + 32) = 0;
    *uint64_t v2 = 0;
    v2[1] = 0;
  }
  return result;
}

uint64_t aaHeaderBlobArrayPayloadSize(unsigned int *a1)
{
  uint64_t v1 = *a1;
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  size_t v4 = (uint64_t *)(*((void *)a1 + 1) + 8);
  do
  {
    uint64_t v5 = *v4;
    v4 += 3;
    result += v5;
    --v1;
  }
  while (v1);
  return result;
}

uint64_t aaEntryAttributesInitWithHeader(char *__s, char *a2, char *a3, AAHeader header)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (__s) {
    memset_s(__s, 0x48uLL, 0, 0x48uLL);
  }
  if (a2) {
    memset_s(a2, 0x38uLL, 0, 0x38uLL);
  }
  if (a3) {
    memset_s(a3, 0xACuLL, 0, 0xACuLL);
  }
  uint32_t FieldCount = AAHeaderGetFieldCount(header);
  if (FieldCount)
  {
    uint32_t v9 = FieldCount;
    uint32_t v10 = 0;
    uint64_t v24 = 0;
    AAHashFunction hash_function = 0;
    do
    {
      AAFieldKey FieldKey = AAHeaderGetFieldKey(header, v10);
      if (__s)
      {
        uint32_t v12 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) <= 0x474C45)
        {
          if (v12 == 4475207)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *__s |= 2u;
              *((_DWORD *)__s + 2) = v24;
            }
          }
          else if (v12 == 4475221)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *__s |= 1u;
              *((_DWORD *)__s + 1) = v24;
            }
          }
          else if (v12 == 4476749 && (AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
          {
            *__s |= 8u;
            *((_DWORD *)__s + 4) = v24;
          }
          goto LABEL_34;
        }
        if ((FieldKey.ikey & 0xFFFFFF) > 0x4D5442)
        {
          if (v12 != 5067843)
          {
            if (v12 != 5067853 || AAHeaderGetFieldTimespec(header, v10, (timespec *)(__s + 56)) < 0) {
              goto LABEL_34;
            }
            char v13 = *__s | 0x40;
            goto LABEL_31;
          }
          if ((AAHeaderGetFieldTimespec(header, v10, (timespec *)(__s + 40)) & 0x80000000) == 0)
          {
            char v13 = *__s | 0x20;
            goto LABEL_31;
          }
        }
        else
        {
          if (v12 == 4672582)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *__s |= 4u;
              *((_DWORD *)__s + 3) = v24;
            }
            goto LABEL_34;
          }
          if (v12 == 5067842 && (AAHeaderGetFieldTimespec(header, v10, (timespec *)(__s + 24)) & 0x80000000) == 0)
          {
            char v13 = *__s | 0x10;
LABEL_31:
            *uint64_t __s = v13;
          }
        }
      }
LABEL_34:
      if (a3)
      {
        uint32_t v14 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) <= 0x334852)
        {
          if (v14 == 3229779)
          {
            if ((AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
              && hash_function == 2)
            {
              *a3 |= 2u;
              *(_OWORD *)(a3 + 8) = *(_OWORD *)v25;
              *((_DWORD *)a3 + 6) = v26;
            }
          }
          else if (v14 == 3295315 {
                 && (AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
          }
                 && hash_function == 3)
          {
            *a3 |= 4u;
            long long v15 = v26;
            *(_OWORD *)(a3 + 28) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 44) = v15;
          }
        }
        else if (v14 == 3360851)
        {
          if ((AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0 && hash_function == 4)
          {
            *a3 |= 8u;
            long long v16 = v26;
            *(_OWORD *)(a3 + 60) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 76) = v16;
            *(_OWORD *)(a3 + 92) = v27;
          }
        }
        else if (v14 == 3491923)
        {
          if ((AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0 && hash_function == 5)
          {
            *a3 |= 0x10u;
            long long v17 = v26;
            *(_OWORD *)(a3 + 108) = *(_OWORD *)v25;
            *(_OWORD *)(a3 + 124) = v17;
            long long v18 = v28;
            *(_OWORD *)(a3 + 140) = v27;
            *(_OWORD *)(a3 + 156) = v18;
          }
        }
        else if (v14 == 5458755 {
               && (AAHeaderGetFieldHash(header, v10, 0x40uLL, &hash_function, v25) & 0x80000000) == 0
        }
               && hash_function == 1)
        {
          *a3 |= 1u;
          *((_DWORD *)a3 + 1) = *(_DWORD *)v25;
        }
      }
      if (a2)
      {
        uint32_t v19 = FieldKey.ikey & 0xFFFFFF;
        if ((FieldKey.ikey & 0xFFFFFF) > 0x524640)
        {
          if (v19 == 5391937)
          {
            if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
            {
              *a2 |= 2u;
              *((_DWORD *)a2 + 3) = v24;
            }
          }
          else if (v19 == 5523009 && (AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
          {
            *a2 |= 1u;
            *((_DWORD *)a2 + 2) = v24;
          }
        }
        else if (v19 == 4411984)
        {
          if ((AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
          {
            char v20 = *a2;
            *a2 |= 8u;
            switch(v24)
            {
              case 'A':
                int v21 = 1;
                goto LABEL_77;
              case 'B':
                int v21 = 2;
                goto LABEL_77;
              case 'C':
                int v21 = 3;
                goto LABEL_77;
              case 'D':
                int v21 = 4;
                goto LABEL_77;
              case 'E':
                int v21 = 5;
                goto LABEL_77;
              case 'F':
                int v21 = 6;
LABEL_77:
                *((_DWORD *)a2 + 1) = v21;
                break;
              default:
                *a2 = v20 & 0xF7;
                break;
            }
          }
        }
        else if (v19 == 4803654 && (AAHeaderGetFieldUInt(header, v10, &v24) & 0x80000000) == 0)
        {
          *a2 |= 4u;
          *((void *)a2 + 2) = v24;
        }
      }
      ++v10;
    }
    while (v9 != v10);
  }
  return 0;
}

AAFieldKey AAHeaderGetFieldKey(AAHeader header, uint32_t i)
{
  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldKey", 586, 101, 0, "invalid field index %u", v2, v3, i);
    return (AAFieldKey)0;
  }
  else
  {
    return *(AAFieldKey *)(*((void *)header + 1) + 48 * i);
  }
}

int AAHeaderGetFieldUInt(AAHeader header, uint32_t i, uint64_t *value)
{
  if (*(_DWORD *)header <= i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldUInt", 592, 101, 0, "invalid field index %u", v3, v4, i);
  }
  else
  {
    uint64_t v5 = *((void *)header + 1);
    if (*(_DWORD *)(v5 + 48 * i + 4) == 1)
    {
      int result = 0;
      *uint64_t value = *(void *)(v5 + 48 * i + 40);
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldUInt", 594, 101, 0, "invalid type %d, expected UINT", v3, v4, *(_DWORD *)(v5 + 48 * i + 4));
  }
  return -1;
}

int AAHeaderGetFieldTimespec(AAHeader header, uint32_t i, timespec *value)
{
  if (*(_DWORD *)header > i)
  {
    uint64_t v5 = *((void *)header + 1);
    if (*(_DWORD *)(v5 + 48 * i + 4) == 4)
    {
      int v6 = *(_DWORD *)(v5 + 48 * i + 8);
      if (v6 == 84)
      {
        int v11 = *(_DWORD *)(v5 + 48 * i + 12);
        uint64_t v12 = (v11 + 4);
        unint64_t v13 = *((void *)header + 2);
        uint64_t v14 = (v11 + 12);
        if (v12 + 8 > v13 || v14 + 4 > v13)
        {
          unint64_t v8 = "invalid blob segment";
          __int16 v9 = 649;
          goto LABEL_9;
        }
        uint64_t v16 = *((void *)header + 4);
        __darwin_time_t v17 = *(void *)(v16 + v12);
        uint64_t v18 = *(unsigned int *)(v16 + v14);
      }
      else if (v6 == 83)
      {
        uint64_t v7 = (*(_DWORD *)(v5 + 48 * i + 12) + 4);
        if ((unint64_t)(v7 + 8) > *((void *)header + 2))
        {
          unint64_t v8 = "invalid blob segment";
          __int16 v9 = 643;
LABEL_9:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldTimespec", v9, 101, 0, v8, v3, v4, v19);
          return -1;
        }
        uint64_t v18 = 0;
        __darwin_time_t v17 = *(void *)(*((void *)header + 4) + v7);
      }
      else
      {
        __darwin_time_t v17 = 0;
        uint64_t v18 = 0;
      }
      int result = 0;
      value->tv_sec = v17;
      value->tv_nsec = v18;
      return result;
    }
    int v19 = *(_DWORD *)(v5 + 48 * i + 4);
    unint64_t v8 = "invalid type %d, expected TIMESPEC";
    __int16 v9 = 637;
    goto LABEL_9;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderGetFieldTimespec", 635, 101, 0, "invalid field index %u", v3, v4, i);
  return -1;
}

uint32_t AAHeaderGetFieldCount(AAHeader header)
{
  return *(_DWORD *)header;
}

int AAArchiveStreamWriteHeader(AAArchiveStream s, AAHeader header)
{
  uint64_t v2 = (uint64_t (*)(void, AAHeader))*((void *)s + 3);
  if (v2) {
    return v2(*(void *)s, header);
  }
  else {
    return -1;
  }
}

uint64_t extractStreamEntryEnd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 1600))) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 1608)) {
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 1632);
  uint64_t v12 = *(void *)(a1 + 1640);
  if (*(_OWORD *)(a1 + 1632) == 0)
  {
    unint64_t v13 = "no active entry or active thread";
    __int16 v14 = 1202;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamEntryEnd", v14, 72, 0, v13, a7, a8, v16);
    extractStreamStateFail(a1);
    return 0xFFFFFFFFLL;
  }
  if (v11)
  {
    if ((extractStreamSendEntryToExtractThread(a1) & 0x80000000) != 0)
    {
      unint64_t v13 = "send entry to thread";
      __int16 v14 = 1207;
      goto LABEL_14;
    }
    uint64_t v12 = *(void *)(a1 + 1640);
  }
  long long v15 = (void *)(a1 + 1632);
  if (v12) {
    extractThreadSendCommand(v12, 69, 0, 0);
  }
  uint64_t result = 0;
  *long long v15 = 0;
  v15[1] = 0;
  return result;
}

int AAHeaderAssign(AAHeader header, AAHeader from_header)
{
  if ((realloc_fields((uint64_t)header, *(_DWORD *)from_header) & 0x80000000) != 0)
  {
    uint64_t v12 = "realloc_fields";
    __int16 v13 = 507;
  }
  else
  {
    memcpy(*((void **)header + 1), *((const void **)from_header + 1), 48 * *(unsigned int *)from_header);
    *(_DWORD *)AAHeader header = *(_DWORD *)from_header;
    *((void *)header + 2) = 0;
    int v6 = (unint64_t *)((char *)header + 16);
    size_t v7 = *((void *)from_header + 2);
    if ((v7 & 0x8000000000000000) == 0)
    {
      unint64_t v8 = (const void *)*((void *)from_header + 4);
      size_t v9 = *((void *)header + 3);
      if (v9 >= v7)
      {
LABEL_16:
        uint64_t v16 = *((void *)header + 4);
        if (v8)
        {
          memcpy((void *)(v16 + *v6), v8, v7);
        }
        else if (v16)
        {
          memset_s((void *)(v16 + *v6), v7, 0, v7);
        }
        unint64_t v17 = *v6 + v7;
        unint64_t *v6 = v17;
        if (v17 > 3)
        {
          int result = 0;
          **((_DWORD **)header + 4) = 825246017;
          *((void *)header + 5) = *((void *)from_header + 5);
          return result;
        }
      }
      else
      {
        do
        {
          while (!v9)
          {
            size_t v9 = 0x4000;
            if (v7 <= 0x4000)
            {
              uint64_t v11 = (void **)((char *)header + 32);
              size_t v9 = 0x4000;
              goto LABEL_14;
            }
          }
          size_t v10 = v9 >> 1;
          if ((v9 & (v9 >> 1)) != 0) {
            size_t v10 = v9 & (v9 >> 1);
          }
          v9 += v10;
        }
        while (v9 < v7);
        uint64_t v11 = (void **)((char *)header + 32);
        if (v9 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_23;
        }
LABEL_14:
        __int16 v14 = *v11;
        long long v15 = realloc(*v11, v9);
        if (v15)
        {
          *((void *)header + 3) = v9;
          *((void *)header + 4) = v15;
          goto LABEL_16;
        }
        free(v14);
LABEL_23:
        *uint64_t v11 = 0;
        unint64_t *v6 = 0;
        *((void *)header + 3) = 0;
      }
    }
    uint64_t v12 = "realloc blob";
    __int16 v13 = 514;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderAssign", v13, 101, 0, v12, v4, v5, v19);
  return -1;
}

uint64_t extractStreamSendEntryToExtractThread(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 1088);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1088)))
  {
    int v6 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v7 = 91;
LABEL_8:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v7, 0, v6, v3, v4, v5, v20);
    __int16 v13 = "SharedArrayPop failed";
    __int16 v14 = 1145;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractStreamSendEntryToExtractThread", v14, 72, 0, v13, v11, v12, v20);
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    int v8 = *(_DWORD *)(a1 + 1072);
    if (v8) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 1152), v2))
    {
      int v6 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v7 = 94;
      goto LABEL_8;
    }
  }
  unsigned int v9 = v8 - 1;
  *(_DWORD *)(a1 + 1072) = v9;
  unsigned int v10 = *(_DWORD *)(*(void *)(a1 + 1080) + 4 * v9);
  if (pthread_mutex_unlock(v2))
  {
    int v6 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v7 = 98;
    goto LABEL_8;
  }
  uint64_t v16 = *(void *)(a1 + 1064);
  uint64_t v17 = v16 + 176 * v10;
  *(void *)(a1 + 1640) = v17;
  *(void *)(v17 + 168) = *(void *)(a1 + 1632);
  *(void *)(a1 + 1632) = 0;
  if (pthread_mutex_lock((pthread_mutex_t *)(v17 + 56))
    || (uint64_t v18 = v16 + 176 * v10, v19 = *(_DWORD *)(v18 + 48), *(_DWORD *)(v18 + 48) = v19 + 1, !v19)
    && pthread_cond_broadcast((pthread_cond_t *)(v16 + 176 * v10 + 120))
    || pthread_mutex_unlock((pthread_mutex_t *)(v17 + 56)))
  {
    __int16 v13 = "SemRelease failed";
    __int16 v14 = 1150;
    goto LABEL_9;
  }
  if ((extractThreadSendCommand(v16 + 176 * v10, 66, 0, 0) & 0x80000000) != 0)
  {
    __int16 v13 = "extract thread BEGIN failed";
    __int16 v14 = 1153;
    goto LABEL_9;
  }
  return 0;
}

AAHeader AAHeaderClone(AAHeader header)
{
  uint64_t v2 = (AAHeader_impl *)malloc(0x30uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    memset_s(v2, 0x30uLL, 0, 0x30uLL);
    if (AAHeaderAssign(v3, header) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderClone", 495, 101, 0, "header copy", v4, v5, v10);
      AAHeaderDestroy(v3);
      return 0;
    }
  }
  else
  {
    int v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAHeader.c", (uint64_t)"AAHeaderClone", 492, 101, *v6, "malloc", v7, v8, v10);
  }
  return v3;
}

ssize_t decodeStreamRefillBuffer(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 1128))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    do
    {
      uint64_t v4 = *(void *)(a1 + 40);
      if (v4 == v3) {
        break;
      }
      ssize_t result = AAByteStreamRead(*(AAByteStream *)(a1 + 8), (void *)(*(void *)(a1 + 48) + v3), v4 - v3);
      if (!result)
      {
        *(_DWORD *)(a1 + 1128) = 1;
        return result;
      }
      if (result < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStream.c", (uint64_t)"decodeStreamRefillBuffer", 35, 61, 0, "istream read error", v5, v6, v8);
        return 0xFFFFFFFFLL;
      }
      uint64_t v3 = *(void *)(a1 + 32);
      unint64_t v7 = v3 + result;
      if (!__CFADD__(v3, result) && v7 <= *(void *)(a1 + 40))
      {
        *(void *)(a1 + 32) = v7;
        v3 += result;
      }
    }
    while (!*(_DWORD *)(a1 + 1128));
  }
  return 0;
}

size_t aaDecompressionStreamRead(uint64_t a1, uint64_t a2, size_t nbyte, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 68)) {
    return -1;
  }
  size_t v10 = nbyte;
  uint64_t v13 = *(void *)(a1 + 72);
  if (v13)
  {
    return IDecoderStreamRead(v13, a2, nbyte);
  }
  int v14 = *(_DWORD *)(a1 + 56);
  if (v14 == -1) {
    return -1;
  }
  if (!v14)
  {
    return aaDecompressionStreamReadInput(a1, a2, nbyte);
  }
  if (!nbyte) {
    return 0;
  }
  int v15 = 0;
  size_t v16 = 0;
  v83 = (unint64_t *)(a1 + 8);
LABEL_15:
  size_t v17 = *(void *)(a1 + 32);
  if (v17)
  {
    if (v10 >= v17) {
      size_t v8 = *(void *)(a1 + 32);
    }
    else {
      size_t v8 = v10;
    }
    memcpy((void *)(a2 + v16), *(const void **)(a1 + 48), v8);
    if ((v8 & 0x8000000000000000) == 0)
    {
      unint64_t v18 = *(void *)(a1 + 32);
      size_t v19 = v18 - v8;
      if (v18 >= v8)
      {
        if (v18 != v8) {
          memmove(*(void **)(a1 + 48), (const void *)(*(void *)(a1 + 48) + v8), v18 - v8);
        }
        *(void *)(a1 + 32) = v19;
      }
      v16 += v8;
      v10 -= v8;
      goto LABEL_141;
    }
    return v8;
  }
  if (*(_DWORD *)(a1 + 64)) {
    return v16;
  }
  unint64_t v21 = *(void *)(a1 + 8);
  unint64_t v20 = *(void *)(a1 + 16);
  if (v20 == v21) {
    goto LABEL_57;
  }
  if (*(_DWORD *)(a1 + 60)) {
    goto LABEL_56;
  }
  size_t v22 = v20 - v21;
  if (v20 == v21) {
    goto LABEL_55;
  }
  size_t v8 = 0;
  uint64_t v23 = *(AAByteStream_impl **)a1;
  while (1)
  {
    if (v21 != v20) {
      goto LABEL_41;
    }
    unint64_t v24 = v20 + 0x40000;
    if ((uint64_t)(v20 + 0x40000) < 0) {
      goto LABEL_144;
    }
    if (v20 > 0xFFFFFFFFFFFBFFFFLL)
    {
      unint64_t v21 = v20;
LABEL_41:
      size_t v26 = v20;
      goto LABEL_45;
    }
    do
    {
      while (!v20)
      {
        unint64_t v20 = 0x4000;
        size_t v26 = 0x4000;
        if (v24 <= 0x4000) {
          goto LABEL_43;
        }
      }
      unint64_t v25 = v20 >> 1;
      if ((v20 & (v20 >> 1)) != 0) {
        unint64_t v25 = v20 & (v20 >> 1);
      }
      v20 += v25;
    }
    while (v20 < v24);
    size_t v26 = v20;
    if (v20 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_156;
    }
LABEL_43:
    long long v27 = *(void **)(a1 + 24);
    long long v28 = realloc(v27, v26);
    if (!v28) {
      break;
    }
    *(void *)(a1 + 16) = v26;
    *(void *)(a1 + 24) = v28;
    unint64_t v21 = *(void *)(a1 + 8);
LABEL_45:
    if (v26 - v21 >= v22) {
      size_t v29 = v22;
    }
    else {
      size_t v29 = v26 - v21;
    }
    ssize_t v30 = AAByteStreamRead(v23, (void *)(*(void *)(a1 + 24) + v21), v29);
    if (v30 < 0) {
      goto LABEL_144;
    }
    if (!v30) {
      goto LABEL_53;
    }
    unint64_t v21 = *v83 + v30;
    if (__CFADD__(*v83, v30) || (unint64_t v20 = *(void *)(a1 + 16), v21 > v20))
    {
LABEL_144:
      size_t v8 = -1;
      goto LABEL_145;
    }
    unint64_t *v83 = v21;
    v8 += v30;
    v22 -= v30;
    if (!v22)
    {
LABEL_53:
      if ((v8 & 0x8000000000000000) != 0) {
        goto LABEL_145;
      }
      if (!v8) {
LABEL_55:
      }
        *(_DWORD *)(a1 + 60) = 1;
LABEL_56:
      unint64_t v21 = *v83;
LABEL_57:
      uint64_t v32 = *(unint64_t **)(a1 + 24);
      uint64_t v31 = *(void *)(a1 + 32);
      size_t v33 = *(void *)(a1 + 40) - v31;
      char v34 = (unsigned char *)(*(void *)(a1 + 48) + v31);
      switch(*(_DWORD *)(a1 + 56))
      {
        case 1:
          if (!v21)
          {
            if (!*(_DWORD *)(a1 + 60))
            {
LABEL_150:
              uint64_t v76 = "truncated stream header";
              __int16 v77 = 208;
              goto LABEL_158;
            }
LABEL_124:
            *(_DWORD *)(a1 + 64) = 1;
            goto LABEL_140;
          }
          if (v21 <= 0xF) {
            goto LABEL_150;
          }
          unint64_t v35 = v32[1];
          size_t v36 = bswap64(*v32);
          unint64_t v37 = bswap64(v35);
          size_t v38 = *(void *)(a1 + 80);
          if (v36 > v38 || v37 > v38)
          {
            uint64_t v76 = "corrupted stream header";
            __int16 v77 = 217;
            goto LABEL_158;
          }
          int v79 = v15;
          unint64_t v40 = v37 + 16;
          if (v37 + 16 > v21)
          {
            uint64_t v76 = "truncated stream payload";
            __int16 v77 = 218;
            goto LABEL_158;
          }
          if (v36 > v33)
          {
            uint64_t v76 = "unexpected output buffer size";
            __int16 v77 = 219;
            goto LABEL_158;
          }
          unint64_t v41 = *v32;
          if (*v32 != v35)
          {
            if ((*(uint64_t (**)(unsigned char *, size_t, unint64_t *))(a1 + 88))(v34, v33, v32 + 2) == v36) {
              goto LABEL_126;
            }
            uint64_t v76 = "block decompression failed";
            __int16 v77 = 229;
LABEL_158:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", v77, 20, 0, v76, a7, a8, v78);
            return -1;
          }
          memcpy(v34, v32 + 2, v36);
LABEL_126:
          if (v40)
          {
            unint64_t v72 = *v83 - v40;
            if (*v83 >= v40)
            {
              if (*v83 != v40) {
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v40), *v83 - v40);
              }
              unint64_t *v83 = v72;
            }
          }
          if (v41)
          {
            uint64_t v73 = *(void *)(a1 + 32);
            BOOL v74 = __CFADD__(v73, v36);
            size_t v75 = v73 + v36;
            int v15 = v79;
            if (!v74 && v75 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v75;
            }
          }
          else
          {
            int v15 = v79;
          }
LABEL_140:
          if (v15 >= 3)
          {
            uint64_t v76 = "truncated stream";
            __int16 v77 = 240;
            goto LABEL_158;
          }
LABEL_141:
          size_t v8 = v16;
          if (!v10) {
            return v8;
          }
          break;
        case 2:
          *(void *)(a1 + 328) = v32;
          *(void *)(a1 + 336) = v21;
          *(void *)(a1 + 312) = v34;
          *(void *)(a1 + 320) = v33;
          compression_status v42 = compression_stream_process((compression_stream *)(a1 + 312), *(_DWORD *)(a1 + 60) != 0);
          if (v42 < 0)
          {
            uint64_t v76 = "decoding compression payload";
            __int16 v77 = 162;
            goto LABEL_158;
          }
          compression_status v43 = v42;
          int v44 = v15;
          uint64_t v45 = *(void *)(a1 + 336);
          uint64_t v46 = *(void *)(a1 + 320);
          unint64_t v47 = v21 - v45;
          if (v21 != v45)
          {
            size_t v48 = *v83 - v47;
            if (*v83 >= v47)
            {
              if (*v83 != v47)
              {
                size_t v80 = *v83 - v47;
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v47), v48);
                size_t v48 = v80;
              }
              unint64_t *v83 = v48;
            }
          }
          if (v33 != v46)
          {
            uint64_t v49 = *(void *)(a1 + 32);
            size_t v50 = v49 + v33 - v46;
            if (!__CFADD__(v49, v33 - v46) && v50 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v50;
            }
          }
          if (v33 == v46 && v21 == v45) {
            int v15 = v44 + 1;
          }
          else {
            int v15 = 0;
          }
          if (v43 != COMPRESSION_STATUS_END) {
            goto LABEL_140;
          }
          goto LABEL_124;
        case 3:
          *(void *)(a1 + 176) = v32;
          *(void *)(a1 + 184) = v21;
          *(void *)(a1 + 200) = v34;
          *(void *)(a1 + 208) = v33;
          unsigned int v52 = lzma_code();
          unsigned int v53 = v52;
          if (v52 <= 0xA && ((1 << v52) & 0x403) != 0)
          {
            int v54 = v15;
            size_t v55 = *(unint64_t **)(a1 + 176);
            uint64_t v56 = *(unsigned char **)(a1 + 200);
            unint64_t v57 = (char *)v55 - (char *)v32;
            if (v55 != v32)
            {
              size_t v58 = *v83 - v57;
              if (*v83 >= v57)
              {
                if (*v83 != v57)
                {
                  size_t v81 = *v83 - v57;
                  memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v57), v58);
                  size_t v58 = v81;
                }
                unint64_t *v83 = v58;
              }
            }
            if (v56 != v34)
            {
              uint64_t v59 = *(void *)(a1 + 32);
              unint64_t v60 = v59 + v56 - v34;
              if (!__CFADD__(v59, v56 - v34) && v60 <= *(void *)(a1 + 40)) {
                *(void *)(a1 + 32) = v60;
              }
            }
            if (v56 == v34 && v55 == v32) {
              int v15 = v54 + 1;
            }
            else {
              int v15 = 0;
            }
            if (v53 == 1) {
              goto LABEL_124;
            }
          }
          else
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", 194, 20, 0, "decoding lzma payload", a7, a8, v78);
          }
          size_t v8 = -1;
          if (v53 <= 0xA && ((1 << v53) & 0x403) != 0) {
            goto LABEL_140;
          }
          return v8;
        case 4:
          *(void *)(a1 + 96) = v32;
          *(_DWORD *)(a1 + 104) = v21;
          *(void *)(a1 + 120) = v34;
          *(_DWORD *)(a1 + 128) = v33;
          int v62 = BZ2_bzDecompress((bz_stream *)(a1 + 96));
          if (v62 < 0)
          {
            uint64_t v76 = "decoding bzip2 payload";
            __int16 v77 = 178;
            goto LABEL_158;
          }
          int v63 = v62;
          int v64 = v15;
          uint64_t v65 = *(unint64_t **)(a1 + 96);
          uint64_t v66 = *(unsigned char **)(a1 + 120);
          unint64_t v67 = (char *)v65 - (char *)v32;
          if (v65 != v32)
          {
            size_t v68 = *v83 - v67;
            if (*v83 >= v67)
            {
              if (*v83 != v67)
              {
                size_t v82 = *v83 - v67;
                memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v67), v68);
                size_t v68 = v82;
              }
              unint64_t *v83 = v68;
            }
          }
          if (v66 != v34)
          {
            uint64_t v69 = *(void *)(a1 + 32);
            unint64_t v70 = v69 + v66 - v34;
            if (!__CFADD__(v69, v66 - v34) && v70 <= *(void *)(a1 + 40)) {
              *(void *)(a1 + 32) = v70;
            }
          }
          if (v66 == v34 && v65 == v32) {
            int v15 = v64 + 1;
          }
          else {
            int v15 = 0;
          }
          if (v63 != 4) {
            goto LABEL_140;
          }
          goto LABEL_124;
        default:
          return -1;
      }
      goto LABEL_15;
    }
  }
  free(v27);
LABEL_156:
  unint64_t *v83 = 0;
  *(void *)(a1 + 16) = 0;
  size_t v8 = -1;
  *(void *)(a1 + 24) = 0;
LABEL_145:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", 144, 20, 0, "stream read failed", a7, a8, v78);
  return v8;
}

uint64_t IDecoderStreamRead(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1) {
    return SharedBufferRead(*(void *)(a1 + 64), a2, a3);
  }
  else {
    return -1;
  }
}

uint64_t extractThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = MEMORY[0x270FA5388](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v132 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)v8;
  uint64_t v10 = *(void *)(*(void *)v8 + 1064);
  bzero(v130, 0x800uLL);
  bzero(__s, 0x800uLL);
  bzero(__s2, 0x800uLL);
  uint64_t v13 = (char *)malloc(0x40000uLL);
  if (!v13)
  {
    int v114 = *__error();
    uint64_t v115 = "malloc";
    __int16 v116 = 756;
LABEL_197:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", v116, 72, v114, v115, v11, v12, v118);
    free(v13);
    return v8;
  }
  if (*(_DWORD *)(v9 + 1060) <= -1171354717 * ((unint64_t)(v8 - v10) >> 4))
  {
    char v118 = -93 * ((unint64_t)(v8 - v10) >> 4);
    uint64_t v115 = "invalid thread ID %d";
    __int16 v116 = 757;
    int v114 = 0;
    goto LABEL_197;
  }
  int v123 = -1171354717 * ((unint64_t)(v8 - v10) >> 4);
  int v14 = 0;
  int v15 = (pthread_mutex_t *)(v9 + 1088);
  size_t v16 = (pthread_mutex_t *)(v8 + 56);
  size_t v17 = (pthread_cond_t *)(v8 + 120);
  uint64_t v120 = v9 + 1200;
  v121 = (pthread_cond_t *)(v9 + 1152);
  int v122 = -1;
  while (1)
  {
LABEL_4:
    if (v14) {
      goto LABEL_20;
    }
    if (pthread_mutex_lock(v15))
    {
      __int16 v21 = 117;
      size_t v22 = "SharedArrayPush: pthread_mutex_lock failed\n";
LABEL_14:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v21, 0, v22, v18, v19, v20, v118);
      goto LABEL_15;
    }
    uint64_t v23 = *(unsigned int *)(v9 + 1072);
    unsigned int v24 = *(_DWORD *)(v9 + 1076);
    int v25 = v23;
    if (v23 < v24)
    {
      *(_DWORD *)(*(void *)(v9 + 1080) + 4 * v23) = v123;
      int v25 = *(_DWORD *)(v9 + 1072);
    }
    *(_DWORD *)(v9 + 1072) = v25 + 1;
    if (!v25 && pthread_cond_broadcast(v121))
    {
      __int16 v21 = 122;
      size_t v22 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      goto LABEL_14;
    }
    if (pthread_mutex_unlock(v15))
    {
      __int16 v21 = 124;
      size_t v22 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      goto LABEL_14;
    }
    if (v23 >= v24)
    {
      __int16 v21 = 125;
      size_t v22 = "SharedArrayPush: stack is full\n";
      goto LABEL_14;
    }
LABEL_15:
    if (!pthread_mutex_lock(v16))
    {
      while (1)
      {
        int v26 = *(_DWORD *)(v8 + 48);
        if (v26 > 0) {
          break;
        }
        if (pthread_cond_wait(v17, v16)) {
          goto LABEL_20;
        }
      }
      *(_DWORD *)(v8 + 48) = v26 - 1;
      pthread_mutex_unlock(v16);
    }
LABEL_20:
    memset(buf, 0, 12);
    ssize_t v27 = AAByteStreamRead(*(AAByteStream *)(v8 + 24), buf, 0xCuLL);
    if (v27 != 12) {
      break;
    }
    switch(LODWORD(buf[0]))
    {
      case 'A':
        goto LABEL_25;
      case 'B':
        if (*(void *)(v8 + 168)) {
          goto LABEL_74;
        }
        __int16 v35 = 786;
        size_t v36 = "no entry in thread";
        goto LABEL_83;
      case 'C':
        goto LABEL_67;
      case 'D':
        uint64_t v42 = *(void *)(v8 + 168);
        if (!v42) {
          goto LABEL_74;
        }
        unint64_t v43 = *(void *)(v42 + 2192);
        if (v43 == -1)
        {
          __int16 v35 = 847;
          size_t v36 = "DAT size not received yet";
          goto LABEL_83;
        }
        if (*(void *)(v42 + 2288)) {
          goto LABEL_38;
        }
        if ((*(unsigned char *)(v42 + 2056) & 4) == 0)
        {
          uint64_t v76 = 0;
          int v77 = -1;
          goto LABEL_99;
        }
        uint64_t v76 = 0;
        int v77 = -1;
        if (!v43 || (*(_DWORD *)(v42 + 2068) & 0x20) == 0) {
          goto LABEL_99;
        }
        if (*(unsigned char *)(v42 + 2128))
        {
          int v77 = *(_DWORD *)(v42 + 2136);
          if ((*(unsigned char *)(v42 + 2128) & 0x10) == 0)
          {
LABEL_159:
            uint64_t v76 = 0;
            goto LABEL_99;
          }
        }
        else
        {
          int v77 = 0;
          if ((*(unsigned char *)(v42 + 2128) & 0x10) == 0) {
            goto LABEL_159;
          }
        }
        uint64_t v76 = *(unsigned int *)(v42 + 2156);
        unint64_t v86 = *(unsigned int *)(v42 + 2152);
        if (v86)
        {
          if (v43 <= v86)
          {
            uint64_t v76 = v76 & 0xFFFFFFFC;
            int v77 = 10;
          }
          else
          {
            v76 |= 3uLL;
          }
        }
LABEL_99:
        unsigned int v125 = v77;
        if ((*(unsigned char *)(v42 + 2128) & 8) != 0 && (*(unsigned char *)(v9 + 1030) & 2) != 0) {
          int v78 = *(_DWORD *)(v42 + 2132);
        }
        else {
          int v78 = -1;
        }
        int v119 = v78;
        if ((concatExtractPath(v130, 0x800uLL, (char *)v9, (const char *)v42) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 885, 72, 0, "invalid path: %s", v93, v94, v42);
          goto LABEL_84;
        }
        if (*(_DWORD *)(v9 + 1056)) {
          removeFile(v130);
        }
        __strlcpy_chk();
        char v95 = strrchr(__s, 47);
        if (!v95)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 890, 72, 0, "invalid path: %s", v96, v97, (char)v130);
          int v65 = 1;
          int v14 = 1;
          size_t v16 = (pthread_mutex_t *)(v8 + 56);
          goto LABEL_86;
        }
        *char v95 = 0;
        uint64_t v98 = v95 + 1;
        if (v122 < 0) {
          goto LABEL_154;
        }
        if (!strcmp(__s, __s2))
        {
          int v99 = v122;
        }
        else
        {
          close(v122);
LABEL_154:
          __strlcpy_chk();
          int v99 = open(__s2, 0);
          if (v99 < 0)
          {
            int v122 = v99;
            v100 = *(void **)(v42 + 2288);
            goto LABEL_170;
          }
        }
        int v122 = v99;
        v100 = aaArchiveFileOutputStreamOpenAt(v99, v98, *(void *)(v42 + 2192), v125, v76, v119, *(void *)(v9 + 1048));
        *(void *)(v42 + 2288) = v100;
LABEL_170:
        size_t v16 = (pthread_mutex_t *)(v8 + 56);
        if (!v100)
        {
          v108 = aaArchiveFileOutputStreamOpenAt(-1, v130, *(void *)(v42 + 2192), v125, v76, v119, *(void *)(v9 + 1048));
          *(void *)(v42 + 2288) = v108;
          if (!v108)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 904, 72, 0, "opening output file: %s", v109, v110, (char)v130);
LABEL_84:
            int v65 = 1;
LABEL_85:
            int v14 = 1;
            goto LABEL_86;
          }
        }
LABEL_38:
        unint64_t v44 = *(size_t *)((char *)buf + 4);
        if (!*(size_t *)((char *)buf + 4))
        {
          int v14 = 1;
          continue;
        }
        uint64_t v124 = v42;
        while (1)
        {
          if (v44 >= 0x40000) {
            size_t v45 = 0x40000;
          }
          else {
            size_t v45 = v44;
          }
          ssize_t v46 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), v13, v45);
          if (v46 < 0)
          {
            __int16 v35 = 912;
            goto LABEL_80;
          }
          ssize_t v47 = v46;
          size_t v48 = v15;
          uint64_t v49 = v9;
          uint64_t v50 = *(void *)(v124 + 2288);
          if (*(void *)(v50 + 24))
          {
            uint64_t v51 = 0;
            if (v46)
            {
              unsigned int v52 = v13;
              ssize_t v53 = v46;
              while (1)
              {
                uint64_t v54 = (*(uint64_t (**)(void, char *, ssize_t))(v50 + 24))(*(void *)v50, v52, v53);
                if (v54 < 1) {
                  break;
                }
                v52 += v54;
                v51 += v54;
                v53 -= v54;
                if (!v53) {
                  goto LABEL_52;
                }
              }
              uint64_t v51 = v54;
            }
          }
          else
          {
            uint64_t v51 = -1;
          }
LABEL_52:
          if (v51 != v47) {
            break;
          }
          int v14 = 1;
          unint64_t v44 = *(size_t *)((char *)buf + 4) - v47;
          BOOL v55 = *(size_t *)((char *)buf + 4) == v47;
          *(size_t *)((char *)buf + 4) -= v47;
          uint64_t v9 = v49;
          int v15 = v48;
          size_t v16 = (pthread_mutex_t *)(v8 + 56);
          size_t v17 = (pthread_cond_t *)(v8 + 120);
          if (v55) {
            goto LABEL_4;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 914, 72, 0, "write failed %zd", v33, v34, v51);
        int v65 = 1;
        int v14 = 1;
        uint64_t v9 = v49;
        int v15 = v48;
        goto LABEL_183;
      case 'E':
        uint64_t v56 = *(void *)(v8 + 168);
        if (!v56)
        {
          int v65 = 0;
          int v14 = 0;
LABEL_133:
          size_t v17 = (pthread_cond_t *)(v8 + 120);
          goto LABEL_86;
        }
        uint64_t v57 = *(void *)(v56 + 2048);
        if (v57 != 70) {
          goto LABEL_104;
        }
        size_t v58 = *(uint64_t (***)(uint64_t))(v56 + 2288);
        if (v58) {
          goto LABEL_59;
        }
        if (*(void *)(v56 + 2192)) {
          goto LABEL_103;
        }
        if ((*(unsigned char *)(v56 + 2128) & 8) != 0 && (*(unsigned char *)(v9 + 1030) & 2) != 0) {
          int v92 = *(_DWORD *)(v56 + 2132);
        }
        else {
          int v92 = -1;
        }
        if ((concatExtractPath(v130, 0x800uLL, (char *)v9, *(const char **)(v8 + 168)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 808, 72, 0, "invalid path: %s", v111, v112, v56);
        }
        else
        {
          if (*(_DWORD *)(v9 + 1056)) {
            removeFile(v130);
          }
          size_t v58 = (uint64_t (**)(uint64_t))aaArchiveFileOutputStreamOpenAt(-1, v130, *(void *)(v56 + 2192), 0xFFFFFFFF, 0, v92, *(void *)(v9 + 1048));
          *(void *)(v56 + 2288) = v58;
          if (v58)
          {
            uint64_t v57 = *(void *)(v56 + 2048);
            size_t v16 = (pthread_mutex_t *)(v8 + 56);
            if (v57 != 70) {
              goto LABEL_104;
            }
LABEL_59:
            *(_DWORD *)(v56 + 2296) = aaArchiveFileOutputStreamCloseAndReturnFD(v58, v28, v29, v30, v31, v32, v33, v34);
            *(void *)(v56 + 2288) = 0;
            int v61 = applyEntryAttributes(v9, v56);
            int v62 = *(_DWORD *)(v56 + 2296);
            if ((v62 & 0x80000000) == 0)
            {
              close(v62);
              *(_DWORD *)(v56 + 2296) = -1;
            }
            if (v61 < 0)
            {
              char v118 = v56;
              __int16 v84 = 822;
              goto LABEL_121;
            }
            if (*(_DWORD *)(v56 + 2300) != 2) {
              *(_DWORD *)(v56 + 2300) = 2;
            }
LABEL_103:
            uint64_t v57 = *(void *)(v56 + 2048);
LABEL_104:
            if (v57 == 70 || v57 == 72)
            {
LABEL_106:
              if ((retireThreadEnqueue(v120, *(void *)(v8 + 168)) & 0x80000000) == 0)
              {
                int v65 = 0;
                int v14 = 0;
                *(void *)(v8 + 168) = 0;
                goto LABEL_133;
              }
              __int16 v84 = 837;
              AAFieldKey v85 = "sending entry to retire thread";
LABEL_132:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", v84, 72, 0, v85, v59, v60, v118);
              int v14 = 0;
              int v65 = 1;
              goto LABEL_133;
            }
            if ((concatExtractPath(v131, 0x800uLL, (char *)v9, (const char *)v56) & 0x80000000) != 0)
            {
              char v118 = v56;
              __int16 v87 = 274;
              uint32_t v88 = "invalid path: %s";
            }
            else
            {
              uint64_t v81 = *(void *)(v56 + 2048);
              if (v81 == 68)
              {
                memset(&v127, 0, sizeof(v127));
                if (*(_DWORD *)(v9 + 1056) && !lstat(v131, &v127))
                {
                  if ((v127.st_mode & 0xF000) != 0x4000)
                  {
                    removeFile(v131);
                    goto LABEL_114;
                  }
LABEL_190:
                  if (*(_DWORD *)(v56 + 2300) != 2) {
                    *(_DWORD *)(v56 + 2300) = 2;
                  }
                  if (*(void *)(v56 + 2048) == 68 || (applyEntryAttributes(v9, v56) & 0x80000000) == 0) {
                    goto LABEL_106;
                  }
                  char v118 = v56;
                  __int16 v84 = 833;
LABEL_121:
                  AAFieldKey v85 = "applyEntryAttributes failed: %s";
                  goto LABEL_132;
                }
LABEL_114:
                if (!mkdir(v131, 0x1EDu))
                {
                  if ((*(unsigned char *)(v56 + 2056) & 3) != 0)
                  {
                    if (*(unsigned char *)(v56 + 2056)) {
                      uid_t v101 = *(_DWORD *)(v56 + 2060);
                    }
                    else {
                      uid_t v101 = -1;
                    }
                    if ((*(unsigned char *)(v56 + 2056) & 2) != 0) {
                      gid_t v113 = *(_DWORD *)(v56 + 2064);
                    }
                    else {
                      gid_t v113 = -1;
                    }
                    chown(v131, v101, v113);
                  }
                  goto LABEL_190;
                }
                if (!lstat(v131, &v127) && (v127.st_mode & 0xF000) == 0x4000) {
                  goto LABEL_190;
                }
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 305, 72, 0, "mkdir failed: %s", v82, v83, v56);
LABEL_131:
                char v118 = v56;
                __int16 v84 = 829;
                AAFieldKey v85 = "creating fs object: %s";
                goto LABEL_132;
              }
              if (*(_DWORD *)(v9 + 1056))
              {
                removeFile(v131);
                uint64_t v81 = *(void *)(v56 + 2048);
              }
              switch(v81)
              {
                case 'H':
                  if (!link((const char *)(v56 + 1024), v131)) {
                    goto LABEL_190;
                  }
                  int v102 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 320, 72, v102, "link %s", v103, v104, v56);
                  goto LABEL_131;
                case 'P':
                  if (!mkfifo(v131, 0x1A4u)) {
                    goto LABEL_190;
                  }
                  int v105 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 325, 72, v105, "mkfifo %s", v106, v107, v56);
                  goto LABEL_131;
                case 'L':
                  if (!symlink((const char *)(v56 + 1024), v131)) {
                    goto LABEL_190;
                  }
                  int v89 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", 315, 72, v89, "symlink %s", v90, v91, v56);
                  goto LABEL_131;
              }
              __int16 v87 = 330;
              uint32_t v88 = "not implemented yet";
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"createFilesystemObject", v87, 72, 0, v88, v79, v80, v118);
            goto LABEL_131;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 811, 72, 0, "opening output file: %s", v33, v34, (char)v130);
        }
        int v14 = 0;
        int v65 = 1;
LABEL_183:
        size_t v16 = (pthread_mutex_t *)(v8 + 56);
        size_t v17 = (pthread_cond_t *)(v8 + 120);
LABEL_86:
        unint64_t v69 = *(size_t *)((char *)buf + 4);
        if (*(size_t *)((char *)buf + 4))
        {
          while (1)
          {
            size_t v70 = v69 >= 0x40000 ? 0x40000 : v69;
            ssize_t v71 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), v13, v70);
            if (v71 < 0) {
              break;
            }
            unint64_t v69 = *(size_t *)((char *)buf + 4) - v71;
            *(size_t *)((char *)buf + 4) -= v71;
            if (!*(size_t *)((char *)buf + 4)) {
              goto LABEL_92;
            }
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 953, 72, 0, "reading payload", v72, v73, v118);
        }
        else
        {
LABEL_92:
          if (!v65) {
            continue;
          }
        }
        if ((extractThreadFailEntry((uint64_t *)v8) & 0x80000000) != 0) {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 959, 72, 0, "retire failed entry", v74, v75, v118);
        }
        break;
      case 'F':
        if ((extractThreadFailEntry((uint64_t *)v8) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 792, 72, 0, "retire failed entry", v63, v64, v118);
          int v14 = 0;
          int v65 = 1;
        }
        else
        {
          int v65 = 0;
          int v14 = 0;
        }
        goto LABEL_86;
      default:
        if ((LODWORD(buf[0]) - 88) >= 2)
        {
          if (LODWORD(buf[0]) == 42) {
            goto LABEL_199;
          }
LABEL_67:
          __int16 v35 = 942;
          size_t v36 = "Invalid thread command";
        }
        else
        {
LABEL_25:
          unint64_t v37 = *(unint64_t **)(v8 + 168);
          if (!v37) {
            goto LABEL_74;
          }
          size_t v38 = v37 + 281;
          uint32_t v39 = v37 + 275;
          unint64_t v40 = v37 + 278;
          if (LODWORD(buf[0]) != 65) {
            unint64_t v40 = 0;
          }
          if (LODWORD(buf[0]) == 88) {
            unint64_t v40 = v39;
          }
          if (LODWORD(buf[0]) == 89) {
            unint64_t v41 = v38;
          }
          else {
            unint64_t v41 = v40;
          }
          if (*v41 + *(size_t *)((char *)buf + 4) <= v41[1])
          {
            ssize_t v66 = AAByteStreamRead(*(AAByteStream *)(v8 + 40), (void *)(v41[2] + *v41), *(size_t *)((char *)buf + 4));
            if (v66 < 0)
            {
              __int16 v35 = 933;
LABEL_80:
              size_t v36 = "reading payload";
            }
            else
            {
              uint64_t v67 = *(size_t *)((char *)buf + 4);
              *(size_t *)((char *)buf + 4) -= v66;
              if (v66)
              {
                unint64_t v68 = *v41 + v66;
                if (!__CFADD__(*v41, v66) && v68 <= v41[1]) {
                  *unint64_t v41 = v68;
                }
              }
              if (v67 == v66)
              {
LABEL_74:
                int v65 = 0;
                goto LABEL_85;
              }
              __int16 v35 = 936;
              size_t v36 = "truncated read";
            }
          }
          else
          {
            __int16 v35 = 931;
            size_t v36 = "too many blob bytes received";
          }
        }
LABEL_83:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", v35, 72, 0, v36, v33, v34, v118);
        goto LABEL_84;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"extractThreadProc", 775, 72, 0, "reading thread command, %zd", v33, v34, v27);
LABEL_199:
  free(v13);
  if ((v122 & 0x80000000) == 0) {
    close(v122);
  }
  return v8;
}

ssize_t AAByteStreamRead(AAByteStream s, void *buf, size_t nbyte)
{
  uint64_t v3 = (uint64_t (*)(void, void *, size_t))*((void *)s + 2);
  if (v3) {
    return v3(*(void *)s, buf, nbyte);
  }
  else {
    return -1;
  }
}

uint64_t SharedBufferRead(size_t a1, uint64_t a2, unint64_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 400))) {
    return -1;
  }
  uint64_t v5 = a2;
  return SharedBufferFlushToStream(a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferWriteToBufferProc, (uint64_t)&v5);
}

uint64_t SharedBufferFlushToStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  if (!a2) {
    return -1;
  }
  if (atomic_load((unsigned int *)(a1 + 400))) {
    return -1;
  }
  if (!atomic_load((unsigned int *)(a1 + 396)))
  {
    unint64_t v11 = a2;
    uint64_t v6 = 0;
    unint64_t v41 = (unsigned int *)(a1 + 128);
    size_t v42 = a1 + 256;
    while (1)
    {
      unint64_t v12 = *(unsigned int *)(a1 + 388);
      if (v12 >= 4)
      {
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
        {
          __int16 v35 = "SharedArrayPop: pthread_mutex_lock failed\n";
          __int16 v36 = 91;
          goto LABEL_26;
        }
        while (!*(_DWORD *)a1)
        {
          if (pthread_cond_wait((pthread_cond_t *)(a1 + 80), (pthread_mutex_t *)(a1 + 16)))
          {
            __int16 v35 = "SharedArrayPop: pthread_cond_wait failed\n";
            __int16 v36 = 94;
            goto LABEL_26;
          }
        }
        unsigned int v16 = *(_DWORD *)a1 - 1;
        *(_DWORD *)a1 = v16;
        unint64_t v12 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v16);
        if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16)))
        {
          __int16 v35 = "SharedArrayPop: pthread_mutex_unlock failed\n";
          __int16 v36 = 98;
LABEL_26:
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v36, 0, v35, v13, v14, v15, (char)v41);
          unint64_t v37 = "SharedBufferFlushToStream";
          size_t v38 = "SharedArrayDequeue";
          __int16 v39 = 448;
LABEL_27:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)v37, v39, 73, 0, v38, v30, v31, (char)v41);
LABEL_28:
          SharedBufferAbort(a1, v17, v18, v19, v20, v13, v14, v15, (char)v41);
          return -1;
        }
        if (v12 == 4294967294)
        {
          int v40 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 396), (unsigned int *)&v40, 1u);
          return v6;
        }
        if (v12 > 3) {
          goto LABEL_28;
        }
        *(_DWORD *)(a1 + 388) = v12;
      }
      size_t v21 = v42 + 32 * v12;
      uint64_t v23 = (void *)(v21 + 24);
      uint64_t v22 = *(void *)(v21 + 24);
      uint64_t v26 = *(void *)(v21 + 16);
      int v25 = (void *)(v21 + 16);
      uint64_t v24 = v26;
      unint64_t v27 = v22 - v26;
      if (v27 >= v11) {
        unint64_t v28 = v11;
      }
      else {
        unint64_t v28 = v27;
      }
      uint64_t v29 = a3(a4, *(void *)(v42 + 32 * v12) + v24, v28);
      if (v29 <= 0)
      {
        unint64_t v37 = "SharedBufferFlushToStream";
        size_t v38 = "stream write";
        __int16 v39 = 469;
        goto LABEL_27;
      }
      uint64_t v32 = v29;
      uint64_t v33 = *v25 + v29;
      *int v25 = v33;
      if (v33 == *v23)
      {
        unsigned int v34 = *(_DWORD *)(a1 + 388);
        *(_DWORD *)(a1 + 388) = -1;
        if (v34 <= 3 && (SharedArrayPush(v41, v34) & 0x80000000) != 0)
        {
          unint64_t v37 = "currentReadBufferEmpty";
          size_t v38 = "SharedArrayPush";
          __int16 v39 = 337;
          goto LABEL_27;
        }
      }
      v6 += v32;
      v11 -= v32;
      if (!v11) {
        return v6;
      }
    }
  }
  return 0;
}

uint64_t SharedArrayPush(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    uint64_t v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 117;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    int v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((void *)a1 + 1) + 4 * v10) = a2;
      int v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        uint64_t v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 124;
      }
      else
      {
        if (v10 < v11) {
          return 0;
        }
        uint64_t v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 125;
      }
    }
    else
    {
      uint64_t v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 122;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

uint64_t SharedArrayPush_0(unsigned int *a1, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    uint64_t v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    __int16 v9 = 117;
  }
  else
  {
    uint64_t v10 = *a1;
    unsigned int v11 = a1[1];
    int v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((void *)a1 + 1) + 4 * v10) = a2;
      int v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        uint64_t v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        __int16 v9 = 124;
      }
      else
      {
        if (v10 < v11) {
          return 0;
        }
        uint64_t v8 = "SharedArrayPush: stack is full\n";
        __int16 v9 = 125;
      }
    }
    else
    {
      uint64_t v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v9 = 122;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

size_t SharedBufferWriteToBufferProc(void **a1, const void *a2, size_t a3)
{
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t afStreamWrite(uint64_t a1, uint64_t __src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!atomic_load((unsigned int *)(a1 + 48)))
  {
    unint64_t v10 = a3;
    uint64_t v12 = *(void *)(a1 + 24);
    if (__CFADD__(a3, v12) || (unint64_t)(a3 + v12) > *(void *)(a1 + 16))
    {
      char v32 = a3 + v12;
      unsigned int v16 = "received too many bytes %llu/%llu";
      __int16 v17 = 275;
      goto LABEL_13;
    }
    uint64_t v13 = (char *)__src;
    char v14 = *(void **)(a1 + 40);
    if (v14)
    {
      if (!v14[3])
      {
        uint64_t v9 = -1;
LABEL_46:
        if (v12 != *(void *)(a1 + 16) || (flushBuf(a1, __src, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
        {
          if ((v9 & 0x8000000000000000) == 0) {
            return v9;
          }
          goto LABEL_14;
        }
        unsigned int v16 = "flush buf";
        __int16 v17 = 298;
LABEL_13:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamWrite", v17, 67, 0, v16, a7, a8, v32);
        uint64_t v9 = -1;
LABEL_14:
        int v18 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 48), (unsigned int *)&v18, 1u);
        return v9;
      }
      if (a3)
      {
        uint64_t v9 = 0;
        while (1)
        {
          uint64_t v15 = ((uint64_t (*)(void, char *, unint64_t))v14[3])(*v14, v13, v10);
          if (v15 < 1) {
            break;
          }
          v13 += v15;
          v9 += v15;
          v10 -= v15;
          if (!v10) {
            goto LABEL_41;
          }
        }
        uint64_t v12 = *(void *)(a1 + 24);
        uint64_t v9 = v15;
        goto LABEL_46;
      }
    }
    else if (a3)
    {
      uint64_t v9 = 0;
      uint64_t v20 = (size_t *)(a1 + 64);
      size_t v19 = *(void *)(a1 + 64);
      do
      {
        uint64_t v21 = *(void *)(a1 + 56);
        size_t v22 = v21 - v19;
        if (v21 == v19)
        {
          if ((flushBuf(a1, __src, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
          {
            unsigned int v16 = "flush buf";
            __int16 v17 = 284;
            goto LABEL_13;
          }
          size_t v19 = *v20;
        }
        if (v10 < v22) {
          size_t v22 = v10;
        }
        BOOL v23 = __CFADD__(v19, v22);
        unint64_t v24 = v19 + v22;
        if (v23 || (v24 & 0x8000000000000000) != 0) {
          goto LABEL_55;
        }
        unint64_t v25 = *(void *)(a1 + 72);
        if (v25 < v24)
        {
          do
          {
            while (!v25)
            {
              unint64_t v25 = 0x4000;
              size_t v27 = 0x4000;
              if (v24 <= 0x4000) {
                goto LABEL_33;
              }
            }
            unint64_t v26 = v25 >> 1;
            if ((v25 & (v25 >> 1)) != 0) {
              unint64_t v26 = v25 & (v25 >> 1);
            }
            v25 += v26;
          }
          while (v25 < v24);
          size_t v27 = v25;
          if (v25 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_54;
          }
LABEL_33:
          unint64_t v28 = *(void **)(a1 + 80);
          uint64_t v29 = realloc(v28, v27);
          if (v29)
          {
            *(void *)(a1 + 72) = v27;
            *(void *)(a1 + 80) = v29;
            goto LABEL_35;
          }
          free(v28);
LABEL_54:
          *uint64_t v20 = 0;
          *(void *)(a1 + 72) = 0;
          *(void *)(a1 + 80) = 0;
LABEL_55:
          unsigned int v16 = "append to buf";
          __int16 v17 = 286;
          goto LABEL_13;
        }
LABEL_35:
        uint64_t v30 = *(void *)(a1 + 80);
        if (v13)
        {
          memcpy((void *)(v30 + *v20), v13, v22);
        }
        else if (v30)
        {
          memset_s((void *)(v30 + *v20), v22, 0, v22);
        }
        size_t v19 = *v20 + v22;
        *uint64_t v20 = v19;
        if ((v22 & 0x8000000000000000) != 0) {
          goto LABEL_55;
        }
        v13 += v22;
        v9 += v22;
        v10 -= v22;
      }
      while (v10);
LABEL_41:
      uint64_t v12 = *(void *)(a1 + 24);
      if (v9 >= 1)
      {
        v12 += v9;
        *(void *)(a1 + 24) = v12;
      }
      goto LABEL_46;
    }
    uint64_t v9 = 0;
    uint64_t v12 = *(void *)(a1 + 24);
    goto LABEL_46;
  }
  return -1;
}

uint64_t flushBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = *(void *)(a1 + 64);
  if (!v8) {
    return 0;
  }
  off_t v10 = *(void *)(a1 + 32);
  int v11 = *(_DWORD *)(a1 + 88);
  if (v10 + v8 < *(void *)(a1 + 16))
  {
    if (v11) {
      uint64_t v12 = -*(void *)(a1 + 96);
    }
    else {
      uint64_t v12 = -16384;
    }
    v8 &= v12;
  }
  uint64_t v13 = *(char **)(a1 + 80);
  if (!v11)
  {
    if (!v8) {
      return 0;
    }
    size_t v17 = v8;
    while (1)
    {
      ssize_t v18 = pwrite(*(_DWORD *)a1, v13, v17, v10);
      if (v18 < 0) {
        break;
      }
      v13 += v18;
      off_t v10 = *(void *)(a1 + 32) + v18;
      *(void *)(a1 + 32) = v10;
      v17 -= v18;
      if (!v17) {
        goto LABEL_64;
      }
    }
    int v16 = *__error();
    char v14 = "write";
    __int16 v15 = 170;
    goto LABEL_67;
  }
  if (((*(void *)(a1 + 96) - 1) & v10) != 0)
  {
    char v14 = "buffer offset not aligned to holes";
    __int16 v15 = 114;
LABEL_10:
    int v16 = 0;
LABEL_67:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"flushBuf", v15, 67, v16, v14, a7, a8, v50);
    return 0xFFFFFFFFLL;
  }
  if (!v8) {
    return 0;
  }
  size_t v19 = (uint64_t *)(a1 + 104);
  size_t v20 = v8;
  while (2)
  {
    size_t v21 = *(void *)(a1 + 96);
    if (v21 <= v20)
    {
      unint64_t v22 = 0;
      BOOL v23 = v13;
      unint64_t v24 = *(void *)(a1 + 96);
      do
      {
        unint64_t v25 = v24;
        if (v21)
        {
          unint64_t v26 = 0;
          do
          {
            uint64_t v27 = *(void *)&v23[v26];
            v26 += 8;
            if (v27) {
              BOOL v28 = 1;
            }
            else {
              BOOL v28 = v26 >= v21;
            }
          }
          while (!v28);
          if (v27) {
            break;
          }
        }
        unint64_t v24 = v21 + v25;
        v23 += v21;
        unint64_t v22 = v25;
      }
      while (v21 + v25 <= v20);
    }
    else
    {
      unint64_t v22 = 0;
    }
    uint64_t v29 = &v13[v22];
    size_t v30 = v22;
    do
    {
      size_t v31 = v30;
      v30 += v21;
      if (v30 > v20)
      {
        size_t v31 = v20;
        if (v22) {
          goto LABEL_41;
        }
        goto LABEL_51;
      }
      if (!v21)
      {
        size_t v31 = v22;
        if (v22) {
          goto LABEL_41;
        }
        goto LABEL_51;
      }
      unint64_t v32 = 0;
      do
      {
        uint64_t v33 = *(void *)&v29[v32];
        v32 += 8;
        if (v33) {
          BOOL v34 = 1;
        }
        else {
          BOOL v34 = v32 >= v21;
        }
      }
      while (!v34);
      v29 += v21;
    }
    while (v33);
    if (!v22)
    {
LABEL_51:
      unint64_t v39 = v10 + v22;
      goto LABEL_56;
    }
LABEL_41:
    uint64_t v35 = *v19;
    if (*v19)
    {
      uint64_t v36 = *(void *)(a1 + 120) + 16 * v35;
      uint64_t v38 = *(void *)(v36 - 8);
      unint64_t v37 = (void *)(v36 - 8);
      if (v38 == v10)
      {
        unint64_t v39 = v10 + v22;
        *unint64_t v37 = v10 + v22;
        goto LABEL_56;
      }
    }
    if (v35 == *(void *)(a1 + 112))
    {
      unint64_t v40 = 2 * v35;
      if (v40 <= 0x10) {
        unint64_t v40 = 16;
      }
      *(void *)(a1 + 112) = v40;
      if (16 * v40 >= 0x2000000001)
      {
        *__error() = 12;
      }
      else
      {
        unint64_t v41 = *(void **)(a1 + 120);
        size_t v42 = (char *)realloc(v41, 16 * v40);
        if (v42)
        {
          *(void *)(a1 + 120) = v42;
          uint64_t v35 = *(void *)(a1 + 104);
          off_t v10 = *(void *)(a1 + 32);
          goto LABEL_55;
        }
        free(v41);
      }
      *(void *)(a1 + 120) = 0;
      ssize_t v47 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"flushBuf", 140, 67, *v47, "malloc", v48, v49, v50);
      *size_t v19 = 0;
      *(void *)(a1 + 112) = 0;
      return 0xFFFFFFFFLL;
    }
    size_t v42 = *(char **)(a1 + 120);
LABEL_55:
    *size_t v19 = v35 + 1;
    unint64_t v43 = (off_t *)&v42[16 * v35];
    unint64_t v39 = v10 + v22;
    *unint64_t v43 = v10;
    v43[1] = v10 + v22;
LABEL_56:
    if (v39 == *(void *)(a1 + 16))
    {
      if (!v22 || v22 != v31)
      {
        char v14 = "invalid state";
        __int16 v15 = 151;
        goto LABEL_10;
      }
      v22 -= *(void *)(a1 + 96);
    }
    if (v31 > v22)
    {
      if (pwrite(*(_DWORD *)a1, &v13[v22], v31 - v22, v22 + v10) != v31 - v22)
      {
        char v14 = "writing data";
        __int16 v15 = 159;
        goto LABEL_10;
      }
      off_t v10 = *(void *)(a1 + 32);
    }
    v13 += v31;
    v10 += v31;
    *(void *)(a1 + 32) = v10;
    v20 -= v31;
    if (v20) {
      continue;
    }
    break;
  }
LABEL_64:
  unint64_t v44 = *(void *)(a1 + 64);
  size_t v45 = v44 - v8;
  if (v44 < v8) {
    return 0;
  }
  if (v44 != v8) {
    memmove(*(void **)(a1 + 80), (const void *)(*(void *)(a1 + 80) + v8), v44 - v8);
  }
  uint64_t result = 0;
  *(void *)(a1 + 64) = v45;
  return result;
}

uint64_t retireThreadEnqueue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
  {
    uint64_t v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadEnqueue", 597, 72, *v5, "pthread_mutex_lock", v6, v7, v21);
    return 0xFFFFFFFFLL;
  }
  unint64_t v10 = *(void *)(a1 + 88);
  unint64_t v9 = *(void *)(a1 + 96);
  unint64_t v11 = v9 - v10;
  if (v9 == v10)
  {
    unint64_t v9 = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
  }
  else if (v10 >= 0x40)
  {
    memmove(*(void **)(a1 + 104), (const void *)(*(void *)(a1 + 104) + 8 * v10), 8 * v11);
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = v11;
    unint64_t v9 = v11;
  }
  unint64_t v12 = *(void *)(a1 + 80);
  if (v9 < v12) {
    goto LABEL_14;
  }
  uint64_t v13 = 2 * v12;
  if (!v12) {
    uint64_t v13 = 256;
  }
  *(void *)(a1 + 80) = v13;
  if ((unint64_t)(8 * v13) < 0x2000000001)
  {
    char v14 = *(void **)(a1 + 104);
    __int16 v15 = realloc(v14, 8 * v13);
    if (!v15)
    {
      free(v14);
      goto LABEL_18;
    }
    *(void *)(a1 + 104) = v15;
    unint64_t v9 = *(void *)(a1 + 96);
    unint64_t v12 = *(void *)(a1 + 80);
LABEL_14:
    if (v9 < v12)
    {
      uint64_t v16 = *(void *)(a1 + 104);
      *(void *)(a1 + 96) = v9 + 1;
      *(void *)(v16 + 8 * v9) = a2;
    }
    int v17 = 1;
    goto LABEL_19;
  }
  *__error() = 12;
LABEL_18:
  int v17 = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
LABEL_19:
  if (pthread_mutex_unlock(v4))
  {
    ssize_t v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"retireThreadEnqueue", 623, 72, *v18, "pthread_mutex_unlock", v19, v20, v21);
    int v17 = 0;
  }
  if (v17) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t applyEntryAttributes(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  AAEntryACLBlob v4 = AAEntryACLBlobCreate();
  unint64_t v10 = (unint64_t *)AAEntryXATBlobCreate();
  rsize_t v11 = *(void *)(a2 + 2224);
  if (v11 && (aaEntryACLBlobInitWithEncodedData(v4, *(char **)(a2 + 2240), v11, v5, v6, v7, v8, v9) & 0x80000000) != 0)
  {
    uint64_t v19 = "invalid ACL blob";
    __int16 v20 = 354;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", v20, 72, 0, v19, v8, v9, v39);
    int v30 = 0;
    uint64_t v16 = 0;
    goto LABEL_32;
  }
  rsize_t v12 = *(void *)(a2 + 2200);
  if (v12 && (aaEntryXATBlobInitWithEncodedData(v10, *(char **)(a2 + 2216), v12, v5, v6, v7, v8, v9) & 0x80000000) != 0)
  {
    uint64_t v19 = "invalid XAT blob";
    __int16 v20 = 357;
    goto LABEL_22;
  }
  rsize_t v13 = *(void *)(a2 + 2248);
  if (v13)
  {
    uint64_t v16 = AAEntryYECBlobCreateWithEncodedData(*(void **)(a2 + 2264), v13);
    if (!v16)
    {
      int v17 = "invalid YEC blob";
      __int16 v18 = 361;
LABEL_25:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", v18, 72, 0, v17, v14, v15, v39);
LABEL_26:
      int v30 = 0;
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  char v21 = *(void (**)(void, uint64_t, uint64_t, unint64_t *))(a1 + 1040);
  if (v21)
  {
    v21(*(void *)(a1 + 1032), 24, a2, v10);
    (*(void (**)(void, uint64_t, uint64_t, AAEntryACLBlob))(a1 + 1040))(*(void *)(a1 + 1032), 25, a2, v4);
  }
  if (v16)
  {
    *(_DWORD *)unint64_t v40 = 0;
    if ((AAEntryYECBlobApplyToPath((uint64_t)v16, (char *)a1, (const char *)a2, (int *)v40, *(void *)(a1 + 1024), *(_DWORD *)(a1 + 1060)) & 0x80000000) != 0)
    {
      char v39 = v40[0];
      int v17 = "corrupted file data, ECC failed 0x%08x: %s";
      __int16 v18 = 377;
      goto LABEL_25;
    }
    if (*(_DWORD *)v40) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 378, 72, "ECC applied 0x%08x: %s", v22, v14, v15, v40[0]);
    }
  }
  if ((concatExtractPath(v40, 0x800uLL, (char *)a1, (const char *)a2) & 0x80000000) != 0)
  {
    char v39 = a1;
    int v17 = "invalid path: %s/%s";
    __int16 v18 = 391;
    goto LABEL_25;
  }
  uint64_t v26 = *(unsigned int *)(a2 + 2296);
  uint64_t v27 = v26;
  if ((v26 & 0x80000000) != 0)
  {
    uint64_t v27 = open(v40, 0x200000);
    if ((v27 & 0x80000000) != 0)
    {
      int v36 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 400, 72, v36, "open: %s", v37, v38, (char)v40);
      goto LABEL_26;
    }
  }
  if ((aaEntryXATBlobApplyToFD(v10, v27, *(void *)(a1 + 1024), v23, v24, v25, v14, v15) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 405, 72, 0, "applying XAT: %s", v28, v29, a2);
    int v30 = 0;
  }
  else
  {
    int v30 = 1;
  }
  if ((aaEntryACLBlobApplyToFD((unint64_t *)v4, v27, *(void *)(a1 + 1024)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 406, 72, 0, "applying ACL: %s", v31, v32, a2);
    int v30 = 0;
  }
  if ((aaEntryAttributesApplyToFD((char *)(a2 + 2056), v27, *(void *)(a1 + 1024)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAExtractArchiveOutputStream.c", (uint64_t)"applyEntryAttributes", 407, 72, 0, "applying ATTR: %s", v33, v34, a2);
    int v30 = 0;
    if ((v26 & 0x80000000) == 0) {
      goto LABEL_32;
    }
  }
  else if ((v26 & 0x80000000) == 0)
  {
    goto LABEL_32;
  }
  close(v27);
LABEL_32:
  AAEntryXATBlobDestroy((AAEntryXATBlob)v10);
  AAEntryACLBlobDestroy(v4);
  AAEntryYECBlobDestroy(v16);
  if (v30) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t concatExtractPath(char *a1, size_t a2, char *__s, const char *a4)
{
  size_t v8 = strlen(__s);
  size_t v9 = strlen(a4);
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 278, 3, 0, "invalid dir: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  unint64_t v12 = v9;
  if (v8 + v9 + 1 >= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 279, 3, 0, "dir/path too long: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  strlcpy(a1, __s, a2);
  if (!v12) {
    return 0;
  }
  int64_t v13 = 0;
  memset(&v29, 0, sizeof(v29));
  while (1)
  {
    uint64_t v14 = &a4[v13];
    uint64_t v15 = strchr((char *)&a4[v13], 47);
    int64_t v18 = v15 - a4;
    if (v15) {
      unint64_t v19 = v15 - a4;
    }
    else {
      unint64_t v19 = v12;
    }
    size_t v20 = v19 - v13;
    if (v19 == v13)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 297, 3, 0, "invalid path: %s", v16, v17, (char)a4);
      return 0xFFFFFFFFLL;
    }
    char v21 = v15;
    if (v20 != 2)
    {
      if (v20 == 1 && *v14 == 46) {
        goto LABEL_29;
      }
      goto LABEL_15;
    }
    if (*v14 == 46 && a4[v13 + 1] == 46) {
      break;
    }
LABEL_15:
    int v22 = lstat(a1, &v29);
    if (v13)
    {
      if (v22)
      {
        if (mkdir(a1, 0x1EDu) && (lstat(a1, &v29) || (v29.st_mode & 0xF000) != 0x4000))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 326, 3, 0, "a parent of path is not a directory: %s", v25, v26, (char)a4);
          return 0xFFFFFFFFLL;
        }
      }
      else if ((v29.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 316, 3, 0, "a parent of path is not a directory: %s", v23, v24, (char)a4);
        return 0xFFFFFFFFLL;
      }
    }
    else if (v22 || (int v27 = v29.st_mode & 0xF000, v27 != 0x4000) && v27 != 40960)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 311, 3, 0, "dir doesn't exist, or is invalid: %s", v23, v24, (char)__s);
      return 0xFFFFFFFFLL;
    }
    if (a1[v8 - 1] != 47) {
      a1[v8++] = 47;
    }
    memcpy(&a1[v8], &a4[v13], v20);
    v8 += v20;
    a1[v8] = 0;
LABEL_29:
    if (v21)
    {
      int64_t v13 = v18 + 1;
      if (v18 + 1 < v12) {
        continue;
      }
    }
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 304, 3, 0, "invalid path: %s", v16, v17, (char)a4);
  return 0xFFFFFFFFLL;
}

uint64_t aaEntryXATBlobApplyToFD(void *a1, int fd, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 8) != 0)
  {
    unint64_t v11 = flistxattr(fd, 0, 0, 0);
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v13 = *__error();
      uint64_t v16 = "listxattr";
      __int16 v17 = 28;
LABEL_40:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldXAT.c", (uint64_t)"clearXATFD", v17, 104, v13, v16, v14, v15, v43);
      int64_t v18 = 0;
      goto LABEL_41;
    }
    size_t v12 = v11;
    if (v11)
    {
      if (v11 >= 0x2000000001)
      {
        *__error() = 12;
LABEL_39:
        int v13 = *__error();
        uint64_t v16 = "malloc";
        __int16 v17 = 34;
        goto LABEL_40;
      }
      uint64_t v32 = (char *)malloc(v11);
      if (!v32) {
        goto LABEL_39;
      }
      int64_t v18 = v32;
      ssize_t v33 = flistxattr(fd, v32, v12, 0);
      if (v33 < 0)
      {
        int v38 = *__error();
        uint64_t v41 = "listxattr";
        __int16 v42 = 43;
        goto LABEL_47;
      }
      ssize_t v34 = v33;
      if (v33)
      {
        uint64_t v35 = 0;
        int v36 = v18;
        do
        {
          if (v18[v35])
          {
            ++v35;
          }
          else
          {
            if (fremovexattr(fd, v36, 0) < 0)
            {
              int v38 = *__error();
              char v43 = (char)v36;
              uint64_t v41 = "removexattr failed for name=%s";
              __int16 v42 = 57;
LABEL_47:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldXAT.c", (uint64_t)"clearXATFD", v42, 104, v38, v41, v39, v40, v43);
LABEL_41:
              free(v18);
              int v30 = "clearing extended attributes";
              __int16 v31 = 212;
LABEL_42:
              int v37 = 0;
LABEL_43:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldXAT.c", (uint64_t)"aaEntryXATBlobApplyToFD", v31, 104, v37, v30, a7, a8, v43);
              return 0xFFFFFFFFLL;
            }
            int v36 = &v18[++v35];
          }
        }
        while (v35 != v34);
      }
    }
    else
    {
      int64_t v18 = 0;
    }
    free(v18);
  }
  if (*a1)
  {
    uint64_t v19 = 0;
    while (1)
    {
      size_t v20 = (_DWORD *)(a1[5] + *(void *)(a1[2] + 8 * v19));
      unsigned int v23 = *v20;
      char v21 = (const char *)(v20 + 1);
      uint64_t v22 = v23;
      if (v23 < 5)
      {
        LOBYTE(v24) = 0;
LABEL_28:
        char v43 = v24;
        int v30 = "invalid XAT entry key %zu";
        __int16 v31 = 225;
        goto LABEL_42;
      }
      uint64_t v24 = 0;
      uint64_t v25 = (const char *)(a1[5] + *(void *)(a1[2] + 8 * v19) + v22);
      while (v21[v24])
      {
        uint64_t v26 = &v21[++v24];
        if (&v21[v24] >= v25)
        {
          if (!v24) {
            goto LABEL_28;
          }
          goto LABEL_18;
        }
      }
      uint64_t v26 = &v21[v24];
      if (!v24) {
        goto LABEL_28;
      }
LABEL_18:
      if (v26 == v25) {
        goto LABEL_28;
      }
      int v27 = v25 == v26 + 1 ? 0 : v26 + 1;
      if (fsetxattr(fd, v21, v27, v25 - (v26 + 1), 0, 0) < 0)
      {
        uint64_t v28 = __error();
        if ((a3 & 1) == 0 || *v28 != 1) {
          break;
        }
      }
      if ((unint64_t)++v19 >= *a1) {
        return 0;
      }
    }
    int v37 = *__error();
    int v30 = "setxattr";
    __int16 v31 = 238;
    goto LABEL_43;
  }
  return 0;
}

uint64_t aaEntryAttributesApplyToFD(char *a1, int a2, char a3)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  memset(&v50, 0, sizeof(v50));
  if (fstat(a2, &v50) < 0)
  {
    size_t v9 = __error();
    if ((a3 & 1) == 0 || *v9 != 13)
    {
      uint64_t v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 545, 102, *v10, "fstat", v11, v12, v48[0]);
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  v49[1] = 0;
  v49[2] = 0;
  v49[0] = 5;
  memset(v55, 0, sizeof(v55));
  v48[1] = 0;
  v48[2] = 0;
  v48[0] = 5;
  memset(v54, 0, sizeof(v54));
  char v6 = *a1;
  if ((*a1 & 0x20) != 0)
  {
    v55[0] = *(_OWORD *)(a1 + 40);
    int v7 = 512;
    HIDWORD(v49[0]) = 512;
    v54[0] = v55[0];
    HIDWORD(v48[0]) = 512;
    unsigned int v8 = 16;
    if ((v6 & 0x40) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v7 = 0;
  unsigned int v8 = 0;
  if ((*a1 & 0x40) != 0)
  {
LABEL_9:
    long long v14 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)((char *)v55 + v8) = v14;
    unsigned int v15 = v8 + 16;
    *(_OWORD *)((char *)v55 + v15) = v14;
    *(_OWORD *)((char *)v54 + v8) = v14;
    v8 |= 0x20u;
    v7 |= 0x1400u;
    HIDWORD(v49[0]) = v7;
    *(_OWORD *)((char *)v54 + v15) = v14;
    HIDWORD(v48[0]) = v7;
  }
LABEL_10:
  if ((v6 & 0x10) != 0)
  {
    long long v16 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)((char *)v55 + v8) = v16;
    *(_OWORD *)((char *)v54 + v8) = v16;
    v8 += 16;
    v7 |= 0x2000u;
    HIDWORD(v49[0]) = v7;
    HIDWORD(v48[0]) = v7;
  }
  int v17 = v7;
  unsigned int v18 = v8;
  if (v6)
  {
    int v19 = *((_DWORD *)a1 + 1);
    int v17 = v7;
    unsigned int v18 = v8;
    if (v19 != v50.st_uid)
    {
      *(_DWORD *)((char *)v55 + v8) = v19;
      unsigned int v18 = v8 + 4;
      int v17 = v7 | 0x8000;
      HIDWORD(v49[0]) = v7 | 0x8000;
    }
  }
  if ((v6 & 2) != 0)
  {
    int v20 = *((_DWORD *)a1 + 2);
    if (v20 != v50.st_gid)
    {
      *(_DWORD *)((char *)v55 + v18) = v20;
      v18 += 4;
      v17 |= 0x10000u;
      HIDWORD(v49[0]) = v17;
    }
  }
  if ((v6 & 8) != 0)
  {
    int v21 = *((_DWORD *)a1 + 4) & 0xFFF;
    if (v21 != (v50.st_mode & 0xFFF))
    {
      *(_DWORD *)((char *)v55 + v18) = v21;
      v18 += 4;
      v17 |= 0x20000u;
      HIDWORD(v49[0]) = v17;
      *(_DWORD *)((char *)v54 + v8) = v21;
      v8 += 4;
      v7 |= 0x20000u;
      HIDWORD(v48[0]) = v7;
    }
  }
  if ((v6 & 4) != 0)
  {
    unsigned int v22 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v50.st_flags >> 5) & 1));
    if (v22 != v50.st_flags)
    {
      *(_DWORD *)((char *)v55 + v18) = v22;
      v18 += 4;
      v17 |= 0x40000u;
      HIDWORD(v49[0]) = v17;
      *(_DWORD *)((char *)v54 + v8) = v22;
      v8 += 4;
      HIDWORD(v48[0]) = v7 | 0x40000;
    }
  }
  if (!v17) {
    return 0;
  }
  uint64_t result = fsetattrlist(a2, v49, v55, v18, 1u);
  if (result)
  {
    unsigned int v23 = __error();
    if ((a3 & 1) == 0 || *v23 != 1 || (uint64_t result = fsetattrlist(a2, v48, v54, v8, 1u), result))
    {
      uint64_t v24 = __error();
      if ((a3 & 1) != 0 && *v24 == 1) {
        return 0;
      }
      if (*a1)
      {
        uid_t v25 = *((_DWORD *)a1 + 1);
        if ((*a1 & 2) != 0)
        {
LABEL_35:
          gid_t v26 = *((_DWORD *)a1 + 2);
          if ((*a1 & 1) == 0) {
            goto LABEL_40;
          }
          goto LABEL_39;
        }
      }
      else
      {
        uid_t v25 = -1;
        if ((*a1 & 2) != 0) {
          goto LABEL_35;
        }
      }
      gid_t v26 = -1;
      if ((*a1 & 1) == 0)
      {
LABEL_40:
        int v27 = 1;
        if ((*a1 & 2) == 0 || v26 == v50.st_gid)
        {
LABEL_47:
          if ((*a1 & 8) != 0)
          {
            int v32 = *((_DWORD *)a1 + 4) & 0xFFF;
            if (v32 != (v50.st_mode & 0xFFF))
            {
              if (fchmod(a2, v32))
              {
                ssize_t v33 = __error();
                if ((a3 & 1) == 0 || *v33 != 1)
                {
                  ssize_t v34 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 659, 102, *v34, "fchmod", v35, v36, v48[0]);
                  int v27 = 0;
                }
              }
            }
          }
          char v37 = *a1;
          if ((*a1 & 0x40) != 0)
          {
            uint64_t v38 = *((void *)a1 + 8);
            __darwin_time_t v52 = *((void *)a1 + 7);
            v51.tv_sec = v52;
            int v53 = (int)v38 / 1000;
            v51.tv_usec = (int)v38 / 1000;
            if (futimes(a2, &v51))
            {
              uint64_t v39 = __error();
              if ((a3 & 1) == 0 || *v39 != 1)
              {
                uint64_t v40 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 667, 102, *v40, "futimes", v41, v42, v48[0]);
                int v27 = 0;
              }
            }
            char v37 = *a1;
          }
          if ((v37 & 4) != 0)
          {
            __uint32_t v43 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v50.st_flags >> 5) & 1));
            if (v50.st_flags != v43)
            {
              if (fchflags(a2, v43))
              {
                unint64_t v44 = __error();
                if ((a3 & 1) == 0 || *v44 != 1)
                {
                  size_t v45 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 681, 102, *v45, "fchflags", v46, v47, v48[0]);
                  int v27 = 0;
                }
              }
            }
          }
          if (v27) {
            return 0;
          }
          else {
            return 0xFFFFFFFFLL;
          }
        }
LABEL_42:
        if (!fchown(a2, v25, v26) || (uint64_t v28 = __error(), (a3 & 1) != 0) && *v28 == 1)
        {
          int v27 = 1;
        }
        else
        {
          stat v29 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToFD", 655, 102, *v29, "fchown", v30, v31, v48[0]);
          int v27 = 0;
        }
        goto LABEL_47;
      }
LABEL_39:
      if (v25 != v50.st_uid) {
        goto LABEL_42;
      }
      goto LABEL_40;
    }
  }
  return result;
}

uint64_t aaEntryACLBlobApplyToFD(unint64_t *a1, uint64_t a2, char a3)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  memset(&v51, 0, sizeof(v51));
  if (fstat(a2, &v51))
  {
    char v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c", (uint64_t)"aaEntryACLBlobApplyToFD", 370, 100, *v6, "fstat", v7, v8, v45);
    return 0xFFFFFFFFLL;
  }
  int v10 = v51.st_mode & 0xF000;
  if (v10 != 0x8000 && v10 != 0x4000) {
    return 0;
  }
  unint64_t v11 = *a1;
  if (!*a1) {
    return 0;
  }
  int v12 = 0;
  int v13 = (uint64_t *)a1[2];
  do
  {
    uint64_t v14 = *v13++;
    int v15 = *(char *)(a1[5] + 4 + v14);
    if (v15 == 68 || v15 == 65) {
      ++v12;
    }
    --v11;
  }
  while (v11);
  if (!v12) {
    return 0;
  }
  acl_t acl_p = 0;
  uint64_t v16 = sysconf(71);
  uint64_t v17 = sysconf(70);
  if (v16 <= v17) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = v16;
  }
  if (v18 <= 4096) {
    size_t v19 = 4096;
  }
  else {
    size_t v19 = v18;
  }
  if (v19 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_24:
    uid_t v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c", (uint64_t)"aaEntryACLBlobApplyToFD", 403, 100, *v25, "malloc", v26, v27, v45);
    unsigned int v23 = 0;
    goto LABEL_79;
  }
  int v20 = (char *)malloc(v19);
  if (!v20) {
    goto LABEL_24;
  }
  unsigned int v23 = v20;
  if ((a3 & 8) != 0)
  {
    fd_np = acl_p;
  }
  else
  {
    fd_np = acl_get_fd_np(a2, ACL_TYPE_EXTENDED);
    acl_t acl_p = fd_np;
  }
  if (!fd_np)
  {
    fd_np = acl_init(v12);
    acl_t acl_p = fd_np;
    if (!fd_np)
    {
      int v41 = *__error();
      uint64_t v42 = "acl_init";
      __int16 v43 = 415;
      goto LABEL_78;
    }
  }
  unint64_t v28 = *a1;
  if (!*a1)
  {
LABEL_60:
    if ((MEMORY[0x2166ADD70](a2, fd_np) & 0x80000000) != 0)
    {
      uint64_t v40 = __error();
      if ((a3 & 1) == 0 || *v40 != 1)
      {
        int v41 = *__error();
        uint64_t v42 = "acl_set_fd";
        __int16 v43 = 499;
        goto LABEL_78;
      }
    }
    uint64_t v9 = 0;
    goto LABEL_80;
  }
  uint64_t v29 = 0;
  while (1)
  {
    uint64_t v30 = (int *)(a1[5] + *(void *)(a1[2] + 8 * v29));
    acl_flagset_t flagset_p = 0;
    acl_entry_t entry_p = 0;
    memset(uu, 0, sizeof(uu));
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    *(_OWORD *)in = 0u;
    long long v53 = 0u;
    int v31 = *v30;
    int v32 = *((char *)v30 + 4);
    if (v32 == 65) {
      break;
    }
    if (v32 == 68)
    {
      acl_tag_t v33 = ACL_EXTENDED_DENY;
      goto LABEL_34;
    }
LABEL_58:
    if (++v29 >= v28)
    {
      fd_np = acl_p;
      goto LABEL_60;
    }
  }
  acl_tag_t v33 = ACL_EXTENDED_ALLOW;
LABEL_34:
  if ((*(void *)((unsigned char *)v30 + 5) & 0xFFFFFFFFFCFDFE0FLL) != 0)
  {
    uint64_t v45 = *(void *)((char *)v30 + 5);
    uint64_t v42 = "invalid ACE flags: 0x%016llx";
    __int16 v43 = 444;
    goto LABEL_77;
  }
  if ((*(void *)((unsigned char *)v30 + 13) & 0xFFFFFFFFFFEFC001) != 0)
  {
    uint64_t v45 = *(void *)((char *)v30 + 13);
    uint64_t v42 = "invalid ACE perms: 0x%016llx";
    __int16 v43 = 445;
    goto LABEL_77;
  }
  if ((v31 - 278) <= 0xFFFFFEFE)
  {
    uint64_t v42 = "qualifier too long";
    __int16 v43 = 448;
    goto LABEL_77;
  }
  int v34 = v31 - 22;
  __memcpy_chk();
  in[v34] = 0;
  HIDWORD(v35) = *((char *)v30 + 21) - 71;
  LODWORD(v35) = HIDWORD(v35);
  switch((v35 >> 1))
  {
    case 0u:
      memset(&v47, 0, 32);
      uint64_t v46 = 0;
      int v36 = getgrnam_r(in, (group *)&v47, v23, v19, &v46);
      BOOL v37 = 0;
      if (v36 || !v46) {
        goto LABEL_50;
      }
      int v38 = mbr_gid_to_uuid(v47.sid_authorities[2], uu);
      goto LABEL_49;
    case 1u:
      if (uuid_parse(in, uu)) {
        goto LABEL_69;
      }
      goto LABEL_51;
    case 6u:
      memset(&v47, 0, sizeof(v47));
      if (mbr_string_to_sid(in, &v47))
      {
        BOOL v37 = 0;
      }
      else
      {
        int v38 = mbr_sid_to_uuid(&v47, uu);
LABEL_49:
        BOOL v37 = v38 == 0;
      }
LABEL_50:
      if (v37)
      {
LABEL_51:
        if (acl_create_entry(&acl_p, &entry_p))
        {
          int v41 = *__error();
          uint64_t v42 = "acl_create_entry";
          __int16 v43 = 489;
          goto LABEL_78;
        }
        if (acl_set_tag_type(entry_p, v33))
        {
          int v41 = *__error();
          uint64_t v42 = "acl_set_tag_type";
          __int16 v43 = 490;
          goto LABEL_78;
        }
        if (acl_set_permset_mask_np(entry_p, *(void *)((char *)v30 + 13)))
        {
          int v41 = *__error();
          uint64_t v42 = "acl_set_permset_mask_np";
          __int16 v43 = 491;
          goto LABEL_78;
        }
        if (acl_get_flagset_np(entry_p, &flagset_p))
        {
          int v41 = *__error();
          uint64_t v42 = "acl_get_flagset_np";
          __int16 v43 = 492;
          goto LABEL_78;
        }
        if (acl_add_flag_np(flagset_p, *(acl_flag_t *)((char *)v30 + 5)))
        {
          int v41 = *__error();
          uint64_t v42 = "acl_add_flag_np";
          __int16 v43 = 493;
          goto LABEL_78;
        }
        if (acl_set_qualifier(entry_p, uu))
        {
          int v41 = *__error();
          uint64_t v42 = "acl_set_qualifier";
          __int16 v43 = 494;
          goto LABEL_78;
        }
        unint64_t v28 = *a1;
        goto LABEL_58;
      }
LABEL_69:
      LOBYTE(v45) = *((unsigned char *)v30 + 21);
      uint64_t v42 = "could not resolve qualifier (type %c): %s";
      __int16 v43 = 486;
LABEL_77:
      int v41 = 0;
LABEL_78:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c", (uint64_t)"aaEntryACLBlobApplyToFD", v43, 100, v41, v42, v21, v22, v45);
LABEL_79:
      uint64_t v9 = 0xFFFFFFFFLL;
LABEL_80:
      if (acl_p) {
        acl_free(acl_p);
      }
      free(v23);
      return v9;
    case 7u:
      memset(&v47, 0, sizeof(v47));
      uint64_t v46 = 0;
      int v39 = getpwnam_r(in, (passwd *)&v47, v23, v19, (passwd **)&v46);
      BOOL v37 = 0;
      if (v39 || !v46) {
        goto LABEL_50;
      }
      int v38 = mbr_uid_to_uuid(v47.sid_authorities[2], uu);
      goto LABEL_49;
    default:
      LOBYTE(v45) = *((unsigned char *)v30 + 21);
      uint64_t v42 = "invalid qualifier type: %d";
      __int16 v43 = 483;
      goto LABEL_77;
  }
}

void AAEntryYECBlobDestroy(void **a1)
{
  if (a1)
  {
    free(a1[2]);
    memset_s(a1, 0x18uLL, 0, 0x18uLL);
    free(a1);
  }
}

void AAEntryXATBlobDestroy(AAEntryXATBlob xat)
{
  if (xat)
  {
    free(*((void **)xat + 2));
    free(*((void **)xat + 5));
    memset_s((char *)xat + 24, 0x18uLL, 0, 0x18uLL);
    memset_s(xat, 0x30uLL, 0, 0x30uLL);
    free(xat);
  }
}

AAEntryXATBlob AAEntryXATBlobCreate(void)
{
  v0 = (AAEntryXATBlob_impl *)malloc(0x30uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x30uLL, 0, 0x30uLL);
  }
  else
  {
    uint64_t v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldXAT.c", (uint64_t)"AAEntryXATBlobCreate", 251, 104, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

void AAEntryACLBlobDestroy(AAEntryACLBlob acl)
{
  if (acl)
  {
    free(*((void **)acl + 2));
    free(*((void **)acl + 5));
    memset_s((char *)acl + 24, 0x18uLL, 0, 0x18uLL);
    memset_s(acl, 0x30uLL, 0, 0x30uLL);
    free(acl);
  }
}

AAEntryACLBlob AAEntryACLBlobCreate(void)
{
  v0 = (AAEntryACLBlob_impl *)malloc(0x30uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x30uLL, 0, 0x30uLL);
  }
  else
  {
    uint64_t v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldACL.c", (uint64_t)"AAEntryACLBlobCreate", 521, 100, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

void *aaArchiveFileOutputStreamOpenAt(int a1, const char *a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6, __int16 a7)
{
  uint64_t v14 = calloc(1uLL, 0x68uLL);
  int v15 = malloc(0x80uLL);
  uint64_t v16 = (uint64_t)v15;
  if (v15)
  {
    memset_s(v15, 0x80uLL, 0, 0x80uLL);
    if (v14)
    {
      *(_DWORD *)uint64_t v16 = -1;
      if ((a7 & 0x100) == 0)
      {
        if (a1 < 0) {
          unlink(a2);
        }
        else {
          unlinkat(a1, a2, 0);
        }
      }
      if (a7) {
        a6 = 4;
      }
      if (a6 < 1)
      {
        int v28 = *(_DWORD *)v16;
        if ((*(_DWORD *)v16 & 0x80000000) != 0)
        {
          char v46 = -92;
          int v28 = a1 < 0 ? open(a2, 1537) : openat(a1, a2, 1537);
          *(_DWORD *)uint64_t v16 = v28;
          if (v28 < 0)
          {
            int v21 = *__error();
            char v46 = (char)a2;
            uint64_t v24 = "%s";
            __int16 v25 = 358;
            goto LABEL_7;
          }
        }
      }
      else if (a1 < 0)
      {
        char v46 = -92;
        int v28 = open_dprotected_np(a2, 1537, a6, 0);
        *(_DWORD *)uint64_t v16 = v28;
        if (v28 < 0)
        {
LABEL_22:
          int v21 = *__error();
          char v46 = (char)a2;
          uint64_t v24 = "%s";
          __int16 v25 = 349;
          goto LABEL_7;
        }
      }
      else
      {
        int v27 = openat(a1, a2, 1537, 420);
        *(_DWORD *)uint64_t v16 = v27;
        if (v27 < 0) {
          goto LABEL_22;
        }
        char v46 = a6;
        if (fcntl(v27, 64) < 0)
        {
          int v21 = *__error();
          uint64_t v24 = "fcntl F_SETPROTECTIONCLASS";
          __int16 v25 = 347;
          goto LABEL_7;
        }
        int v28 = *(_DWORD *)v16;
        if ((*(_DWORD *)v16 & 0x80000000) != 0) {
          goto LABEL_22;
        }
      }
      if ((a7 & 8) != 0)
      {
        char v46 = 1;
        if (fcntl(v28, 48))
        {
          uint64_t v29 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAt", 366, 67, "Warning: F_NOCACHE failed with error %d: %s\n", v30, v31, v32, *v29);
        }
      }
      if ((a7 & 2) != 0)
      {
        char v46 = 1;
        if (fcntl(*(_DWORD *)v16, 68) == -1)
        {
          acl_tag_t v33 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAt", 375, 67, "Warning: F_SETSTATICCONTENT failed with error %d: %s\n", v34, v35, v36, *v33);
        }
      }
      if (a3 > 0)
      {
        if (a4 != -1 && (a7 & 4) != 0)
        {
          BOOL v37 = AAAFSCStreamOpen(*(_DWORD *)v16, a3, a4, a5, v17, v18, v19, v20);
          *(void *)(v16 + 40) = v37;
          if (!v37)
          {
            char v46 = (char)a2;
            uint64_t v24 = "ParallelCompressionAFSCStreamOpen failed: %s";
            __int16 v25 = 384;
            goto LABEL_60;
          }
        }
        if ((a7 & 0x40) != 0 && !*(void *)(v16 + 40))
        {
          uint64_t v38 = fpathconf(*(_DWORD *)v16, 27);
          if (v38 >= 1)
          {
            *(_DWORD *)(v16 + 88) = 1;
            if (v38 == 4096)
            {
              *(void *)(v16 + 96) = 4096;
            }
            else
            {
              unint64_t v39 = 0x10000;
              if (v38 < 0x10000) {
                unint64_t v39 = v38;
              }
              uint64_t v40 = 1024;
              do
              {
                unint64_t v41 = v40;
                v40 *= 2;
              }
              while (v41 < v39);
              *(void *)(v16 + 96) = v41;
            }
          }
        }
      }
      *(void *)(v16 + 16) = a3;
      *(void *)(v16 + 56) = 0x40000;
      if (*(void *)(v16 + 40)) {
        goto LABEL_58;
      }
      size_t v42 = *(void *)(v16 + 72);
      if (v42 >> 18) {
        goto LABEL_58;
      }
      do
      {
        size_t v43 = (v42 >> 1) + v42;
        if (((v42 >> 1) & v42) != 0) {
          size_t v43 = ((v42 >> 1) & v42) + v42;
        }
        if (v42) {
          size_t v42 = v43;
        }
        else {
          size_t v42 = 0x4000;
        }
      }
      while (v42 < 0x40000);
      unint64_t v44 = *(void **)(v16 + 80);
      uint64_t v45 = realloc(v44, v42);
      if (v45)
      {
        *(void *)(v16 + 72) = v42;
        *(void *)(v16 + 80) = v45;
LABEL_58:
        *uint64_t v14 = v16;
        v14[1] = afStreamClose;
        v14[7] = afStreamCancel;
        v14[3] = afStreamWrite;
        v14[12] = afStreamCloseWithState;
        return v14;
      }
      free(v44);
      *(void *)(v16 + 64) = 0;
      *(void *)(v16 + 72) = 0;
      *(void *)(v16 + 80) = 0;
      uint64_t v24 = "alloc blob";
      __int16 v25 = 429;
LABEL_60:
      int v21 = 0;
      goto LABEL_7;
    }
  }
  int v21 = *__error();
  uint64_t v24 = "malloc";
  __int16 v25 = 324;
LABEL_7:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAt", v25, 67, v21, v24, v22, v23, v46);
  afStreamClose(v16);
  free(v14);
  return 0;
}

uint64_t aaArchiveFileOutputStreamCloseAndReturnFD(uint64_t (**a1)(uint64_t result), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a1[1] == afStreamClose)
  {
    uint64_t v8 = *(unsigned int *)*a1;
    *((_DWORD *)*a1 + 1) = 1;
    if ((AAByteStreamClose((AAByteStream)a1) & 0x80000000) == 0) {
      return v8;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamCloseAndReturnFD", 526, 67, 0, "closing stream", v10, v11, v12);
    if ((v8 & 0x80000000) == 0) {
      close(v8);
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamCloseAndReturnFD", 519, 67, 0, "invalid stream", a7, a8, v12);
  }
  return 0xFFFFFFFFLL;
}

AAByteStream AADecompressionInputStreamOpen(AAByteStream compressed_stream, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)aaSequentialDecompressionIStreamOpen((uint64_t)compressed_stream, n_threads);
}

void *aaSequentialDecompressionIStreamOpen(uint64_t a1, int a2)
{
  if (!a2) {
    getDefaultNThreads();
  }
  uint64_t v3 = calloc(1uLL, 0x68uLL);
  uint64_t v4 = malloc(0x160uLL);
  uint64_t v5 = (uint64_t)v4;
  if (!v4 || (memset_s(v4, 0x160uLL, 0, 0x160uLL), !v3))
  {
    int v16 = *__error();
    uint64_t v17 = "malloc";
    __int16 v18 = 266;
LABEL_31:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaSequentialDecompressionIStreamOpen", v18, 20, v16, v17, v14, v15, v20);
    free(v3);
    aaDecompressionStreamClose(v5);
    return 0;
  }
  *(void *)uint64_t v5 = a1;
  *(_DWORD *)(v5 + 56) = -1;
  char v6 = (void *)(v5 + 8);
  size_t v7 = *(void *)(v5 + 16);
  if (!(v7 >> 16))
  {
    do
    {
      size_t v8 = (v7 >> 1) + v7;
      if (((v7 >> 1) & v7) != 0) {
        size_t v8 = ((v7 >> 1) & v7) + v7;
      }
      if (v7) {
        size_t v7 = v8;
      }
      else {
        size_t v7 = 0x4000;
      }
    }
    while (v7 < 0x10000);
    uint64_t v9 = *(void **)(v5 + 24);
    uint64_t v10 = realloc(v9, v7);
    if (!v10) {
      goto LABEL_29;
    }
    *(void *)(v5 + 16) = v7;
    *(void *)(v5 + 24) = v10;
  }
  size_t v11 = *(void *)(v5 + 40);
  if (v11 >> 16) {
    goto LABEL_23;
  }
  do
  {
    size_t v12 = (v11 >> 1) + v11;
    if (((v11 >> 1) & v11) != 0) {
      size_t v12 = ((v11 >> 1) & v11) + v11;
    }
    if (v11) {
      size_t v11 = v12;
    }
    else {
      size_t v11 = 0x4000;
    }
  }
  while (v11 < 0x10000);
  uint64_t v9 = *(void **)(v5 + 48);
  int v13 = realloc(v9, v11);
  if (!v13)
  {
    char v6 = (void *)(v5 + 32);
LABEL_29:
    free(v9);
    void *v6 = 0;
    v6[1] = 0;
    _OWORD v6[2] = 0;
    uint64_t v17 = "allocating buffer";
    __int16 v18 = 273;
    goto LABEL_30;
  }
  *(void *)(v5 + 40) = v11;
  *(void *)(v5 + 48) = v13;
LABEL_23:
  if (aaDecompressionStreamRefill(v5, 0xCuLL) < 0)
  {
    uint64_t v17 = "reading magic";
    __int16 v18 = 276;
LABEL_30:
    int v16 = 0;
    goto LABEL_31;
  }
  __memcpy_chk();
  if (*(_DWORD *)(v5 + 56) == -1) {
    *(_DWORD *)(v5 + 56) = 0;
  }
  *uint64_t v3 = v5;
  v3[1] = aaDecompressionStreamClose;
  v3[2] = aaDecompressionStreamRead;
  v3[7] = aaDecompressionStreamAbort;
  return v3;
}

uint64_t aaDecompressionStreamRefill(uint64_t a1, size_t a2)
{
  if (!a2) {
    return 0;
  }
  size_t v2 = a2;
  uint64_t v4 = 0;
  char v6 = (unint64_t *)(a1 + 8);
  uint64_t v5 = *(AAByteStream_impl **)a1;
  unint64_t v8 = *(void *)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  while (1)
  {
    if (v8 != v7) {
      goto LABEL_14;
    }
    unint64_t v9 = v7 + 0x40000;
    if ((uint64_t)(v7 + 0x40000) < 0) {
      return -1;
    }
    if (v7 <= 0xFFFFFFFFFFFBFFFFLL) {
      break;
    }
    unint64_t v8 = v7;
LABEL_14:
    size_t v11 = v7;
LABEL_18:
    if (v11 - v8 >= v2) {
      size_t v14 = v2;
    }
    else {
      size_t v14 = v11 - v8;
    }
    ssize_t v15 = AAByteStreamRead(v5, (void *)(*(void *)(a1 + 24) + v8), v14);
    if (v15 < 0) {
      return -1;
    }
    if (!v15) {
      return v4;
    }
    unint64_t v8 = *v6 + v15;
    if (__CFADD__(*v6, v15)) {
      return -1;
    }
    unint64_t v7 = *(void *)(a1 + 16);
    if (v8 > v7) {
      return -1;
    }
    unint64_t *v6 = v8;
    v4 += v15;
    v2 -= v15;
    if (!v2) {
      return v4;
    }
  }
  do
  {
    while (!v7)
    {
      unint64_t v7 = 0x4000;
      size_t v11 = 0x4000;
      if (v9 <= 0x4000) {
        goto LABEL_16;
      }
    }
    unint64_t v10 = v7 >> 1;
    if ((v7 & (v7 >> 1)) != 0) {
      unint64_t v10 = v7 & (v7 >> 1);
    }
    v7 += v10;
  }
  while (v7 < v9);
  size_t v11 = v7;
  if (v7 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_32;
  }
LABEL_16:
  size_t v12 = *(void **)(a1 + 24);
  int v13 = realloc(v12, v11);
  if (v13)
  {
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v13;
    unint64_t v8 = *(void *)(a1 + 8);
    goto LABEL_18;
  }
  free(v12);
LABEL_32:
  unint64_t *v6 = 0;
  v6[1] = 0;
  uint64_t v4 = -1;
  _OWORD v6[2] = 0;
  return v4;
}

uint64_t IDecoderStreamThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (ParallelCompressionDecode(a1, a2, a3, a4, a5, a6, a7, a8)) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamThreadProc", 100, 39, 0, "decoder failed", v8, v9, vars0);
  }
  return 0;
}

uint64_t ParallelCompressionDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v12 = 0u;
  long long v13 = 0u;
  int v8 = *(_DWORD *)(a1 + 4);
  DWORD2(v13) = *(_DWORD *)a1;
  DWORD1(v12) = 1;
  DWORD2(v12) = v8;
  long long v9 = *(_OWORD *)(a1 + 24);
  v11[0] = *(_OWORD *)(a1 + 8);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 40);
  return PCompressFilter((unsigned int *)&v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t PCompressFilter(unsigned int *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v117[2] = *MEMORY[0x263EF8340];
  enterThreadErrorContext((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v105);
  *(void *)uint64_t v115 = 0;
  long long v113 = 0u;
  *(_OWORD *)int v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v108 = 0u;
  unsigned int DefaultNThreads = a1[2];
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  a1[2] = DefaultNThreads;
  if (a1[1] == 1)
  {
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(void *)(a2 + 16), (uint64_t)&v116, 4) != 4)goto LABEL_34; {
    if (a3)
    }
      *a3 += 4;
    unsigned int v14 = 0;
    while (getHeader(v14, (uint64_t)v117) || v116 != LODWORD(v117[0]))
    {
      if (++v14 == 7)
      {
        if (compression_stream_identify_algorithm() == -1)
        {
          ssize_t v15 = "invalid header in input stream";
          __int16 v16 = 179;
        }
        else
        {
          ssize_t v15 = "compressed stream detected : try compression_tool";
          __int16 v16 = 178;
        }
LABEL_33:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processFileHeader", v16, 37, 0, v15, v12, v13, v106);
LABEL_34:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", 507, 37, 0, "processFileHeader", v12, v13, v106);
        goto LABEL_35;
      }
    }
    v117[0] = 0;
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(void *)(a2 + 16), (uint64_t)v117, 8) != 8)goto LABEL_34; {
    if (a3)
    }
      *a3 += 8;
    if (!v117[0])
    {
      ssize_t v15 = "invalid blockSize in input stream";
      __int16 v16 = 191;
      goto LABEL_33;
    }
    *((void *)a1 + 2) = bswap64(v117[0]);
    *a1 = v14;
    if ((int)a1[6] >= 1)
    {
      char v20 = (FILE **)MEMORY[0x263EF8348];
      int v21 = (FILE *)*MEMORY[0x263EF8348];
      DecoderDescription = PCompressGetDecoderDescription(v14);
      fprintf(v21, "Decoder: %s\n", DecoderDescription);
      fprintf(*v20, "Blocksize: %llu\n");
    }
  }
  else
  {
    unint64_t v17 = *((void *)a1 + 2);
    unsigned int EncoderDecoder = PCompressGetEncoderDecoder(*a1);
    if (getHeader(EncoderDecoder, (uint64_t)&v116)
      || pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(void *)(a2 + 40), (uint64_t)&v116, 4) != 4)
    {
      goto LABEL_34;
    }
    if (a3) {
      a3[1] += 4;
    }
    v117[0] = bswap64(v17);
    if (pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(void *)(a2 + 40), (uint64_t)v117, 8) != 8)goto LABEL_34; {
    if (a3)
    }
      a3[1] += 8;
    if ((int)a1[6] >= 1)
    {
      uint64_t v19 = (FILE *)*MEMORY[0x263EF8348];
      PCompressGetEncoderDescription(*a1);
      fprintf(v19, "Encoder: %s\n");
    }
  }
  long long v23 = *((_OWORD *)a1 + 1);
  long long v108 = *(_OWORD *)a1;
  long long v109 = v23;
  long long v113 = 0u;
  *(_OWORD *)int v114 = 0u;
  *(void *)uint64_t v115 = 0;
  long long v24 = *(_OWORD *)(a2 + 16);
  long long v110 = *(_OWORD *)a2;
  long long v111 = v24;
  long long v112 = *(_OWORD *)(a2 + 32);
  if (a3) {
    long long v113 = *(_OWORD *)a3;
  }
  unsigned int v25 = *a1;
  if (a1[1]) {
    DecoderFilter = PCompressGetDecoderFilter(v25);
  }
  else {
    DecoderFilter = PCompressGetEncoderFilter(v25);
  }
  v114[0] = DecoderFilter;
  uint64_t v31 = calloc((int)a1[2], 0x48uLL);
  v114[1] = v31;
  if (!v31)
  {
    __int16 v37 = 468;
LABEL_98:
    unint64_t v86 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", v37, 37, *v86, "malloc", v87, v88, v106);
LABEL_99:
    int v89 = "initFilterState";
    __int16 v90 = 510;
LABEL_105:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", v90, 37, 0, v89, v45, v46, v106);
    char v94 = 0;
    int v95 = 1;
    goto LABEL_106;
  }
  unint64_t v32 = a1[2];
  if ((int)v32 < 1) {
    goto LABEL_53;
  }
  acl_tag_t v33 = v31;
  size_t v34 = *((void *)a1 + 2);
  uint64_t v35 = malloc(v34);
  v33[1] = v35;
  uint64_t v36 = malloc(v34);
  v33[5] = v36;
  void *v33 = &v108;
  __int16 v37 = 477;
  if (!v35 || !v36) {
    goto LABEL_98;
  }
  unint64_t v38 = 0;
  unint64_t v39 = v33 + 9;
  do
  {
    if (v32 - 1 == v38) {
      goto LABEL_53;
    }
    uint64_t v40 = malloc(v34);
    v39[1] = v40;
    unint64_t v41 = malloc(v34);
    v39[5] = v41;
    void *v39 = &v108;
    ++v38;
    if (!v40) {
      break;
    }
    v39 += 9;
  }
  while (v41);
  size_t v42 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", 477, 37, *v42, "malloc", v43, v44, v106);
  if (v38 < v32) {
    goto LABEL_99;
  }
LABEL_53:
  unint64_t v107 = v109;
  signed int v47 = DWORD2(v108);
  uint64_t v48 = malloc(8 * SDWORD2(v108));
  if (!v48)
  {
    int v91 = *__error();
    int v92 = "malloc";
    __int16 v93 = 372;
LABEL_103:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", v93, 37, v91, v92, v59, v60, v106);
    goto LABEL_104;
  }
  uint64_t v49 = v48;
  if (v47 >= 1)
  {
    stat v50 = (char *)v114[1];
    stat v51 = v48;
    uint64_t v52 = v47;
    do
    {
      *v51++ = v50;
      v50 += 72;
      --v52;
    }
    while (v52);
  }
  long long v53 = ThreadPipelineCreate(v47, (uint64_t)v48, (uint64_t)compressionWorkerProc, (uint64_t)&v108, (uint64_t)outputStreamProc, 0);
  if (!v53)
  {
    int v92 = "creating pipeline";
    __int16 v93 = 375;
    int v91 = 0;
    goto LABEL_103;
  }
  uint64_t v61 = (uint64_t)v53;
  uint64_t v62 = 0;
  int v63 = 1;
  unint64_t v64 = v107;
  while (1)
  {
    if (atomic_load(v115))
    {
      int v63 = 0;
      goto LABEL_120;
    }
    if (!v63) {
      break;
    }
    uint64_t Worker = ThreadPipelineGetWorker(v61, v54, v55, v56, v57, v58, v59, v60);
    if (!Worker)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 387, 37, 0, "getting worker from pipeline", v67, v68, v106);
      int v82 = 0;
LABEL_94:
      int v63 = 0;
      goto LABEL_95;
    }
    uint64_t v69 = (uint64_t *)Worker;
    if (DWORD1(v108) == 1)
    {
      uint64_t v70 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, (uint64_t)v117, 16);
      uint64_t v77 = v70;
      if (v70)
      {
        if (v70 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 397, 37, 0, "reading block header", v75, v76, v106);
          int v82 = 0;
          int v83 = 0;
          uint64_t v77 = 0;
        }
        else if (v70 == 16)
        {
          unint64_t v78 = bswap64(v117[0]);
          unint64_t v79 = bswap64(v117[1]);
          if (v79 > v64 || v78 > v64)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 405, 37, 0, "Invalid block header payload=0x%llx raw=0x%llx block=0x%llx\n", v75, v76, v79);
            int v82 = 0;
            int v83 = 0;
            uint64_t v77 = 16;
          }
          else
          {
            uint64_t v80 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, v69[1], v79);
            if (v80 < 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 411, 37, 0, "reading block payload", v75, v76, v106);
              int v82 = 0;
              int v83 = 0;
              uint64_t v77 = 16;
            }
            else
            {
              uint64_t v77 = v80 + 16;
              if (v80 == v79)
              {
                unint64_t v81 = v78;
                int v82 = 0;
                v69[3] = v79;
                v69[4] = v81;
                int v83 = 1;
                v69[2] = v62;
              }
              else
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 415, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v75, v76, v80);
                int v82 = 0;
                int v83 = 0;
              }
            }
            unint64_t v64 = v107;
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 399, 37, 0, "Truncated block header (%lld/16 bytes read)", v75, v76, v70);
          int v82 = 0;
          int v83 = 0;
        }
      }
      else
      {
        int v82 = 1;
        int v83 = 1;
      }
    }
    else
    {
      uint64_t v84 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, *(void *)(Worker + 8), v64);
      if (v84 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 428, 37, 0, "reading block", v75, v76, v106);
        int v82 = 0;
LABEL_90:
        int v63 = 0;
        uint64_t v85 = -1;
        goto LABEL_91;
      }
      uint64_t v77 = v84;
      if (!v84)
      {
        uint64_t v85 = -2;
        int v82 = 1;
        goto LABEL_89;
      }
      int v82 = 0;
      v69[3] = v84;
      v69[4] = 0;
      int v83 = 1;
      v69[2] = v62;
    }
    *(void *)&long long v113 = v113 + v77;
    if (!v82 && v83)
    {
      int v82 = 0;
      int v63 = 1;
      goto LABEL_92;
    }
    if (!v83) {
      goto LABEL_90;
    }
    uint64_t v85 = -2;
LABEL_89:
    int v63 = 1;
LABEL_91:
    v69[2] = v85;
LABEL_92:
    if ((ThreadPipelineRunWorker(v61, (uint64_t)v69, v71, v72, v73, v74, v75, v76) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 445, 37, 0, "RunWorker", v59, v60, v106);
      goto LABEL_94;
    }
LABEL_95:
    ++v62;
    if (v82) {
      goto LABEL_120;
    }
  }
  atomic_load(v115);
LABEL_120:
  if ((ThreadPipelineDestroy(v61) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 447, 37, 0, "ThreadPipelineDestroy", v100, v101, v106);
    free(v49);
    goto LABEL_104;
  }
  free(v49);
  if (!v63)
  {
LABEL_104:
    int v89 = "processStream";
    __int16 v90 = 513;
    goto LABEL_105;
  }
  uint64_t v102 = (*(uint64_t (**)(void, void, void))(a2 + 24))(*(void *)(a2 + 40), 0, 0);
  if (v102 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v103, v104, v106);
    int v89 = "writing EOF";
    __int16 v90 = 520;
    goto LABEL_105;
  }
  int v95 = 0;
  *((void *)&v113 + 1) += v102;
  char v94 = 1;
LABEL_106:
  uint64_t v96 = v114[1];
  if (v114[1])
  {
    if (SDWORD2(v108) >= 1)
    {
      uint64_t v97 = 0;
      uint64_t v98 = 0;
      do
      {
        free(*(void **)((char *)v114[1] + v97 + 8));
        free(*(void **)((char *)v114[1] + v97 + 40));
        ++v98;
        v97 += 72;
      }
      while (v98 < SDWORD2(v108));
      uint64_t v96 = v114[1];
    }
    free(v96);
    v114[1] = 0;
  }
  char v99 = v94 ^ 1;
  if (!a3) {
    char v99 = 1;
  }
  if ((v99 & 1) == 0)
  {
    unsigned int v29 = 0;
    *(_OWORD *)a3 = v113;
    goto LABEL_40;
  }
  if (!v95)
  {
    unsigned int v29 = 0;
    goto LABEL_40;
  }
LABEL_35:
  int v27 = *(void (**)(void))(a2 + 32);
  if (v27) {
    v27(*(void *)(a2 + 40));
  }
  int v28 = *(void (**)(void))(a2 + 8);
  if (v28) {
    v28(*(void *)(a2 + 16));
  }
  unsigned int v29 = -1;
LABEL_40:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v29;
  }
  else {
    return result;
  }
}

uint64_t pcRead(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v4 = a4;
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t v9 = a1(a2, a3, v4);
    uint64_t v12 = v9;
    if (v9 < 0) {
      break;
    }
    if (v9)
    {
      a3 += v9;
      v8 += v9;
      v4 -= v9;
      if (v4) {
        continue;
      }
    }
    return v8;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcRead", 82, 37, 0, "pcRead failed", v10, v11, v14);
  return v12;
}

size_t aaDecompressionStreamReadInput(uint64_t a1, uint64_t a2, size_t nbyte)
{
  if (nbyte)
  {
    size_t v3 = nbyte;
    uint64_t v6 = 0;
    while (1)
    {
      size_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        if (v3 >= v7) {
          size_t v8 = *(void *)(a1 + 8);
        }
        else {
          size_t v8 = v3;
        }
        memcpy((void *)(a2 + v6), *(const void **)(a1 + 24), v8);
        if ((v8 & 0x8000000000000000) != 0) {
          return v8;
        }
        unint64_t v9 = *(void *)(a1 + 8);
        size_t v10 = v9 - v8;
        if (v9 >= v8)
        {
          if (v9 != v8) {
            memmove(*(void **)(a1 + 24), (const void *)(*(void *)(a1 + 24) + v8), v9 - v8);
          }
          *(void *)(a1 + 8) = v10;
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 60)) {
          return v6;
        }
        ssize_t v11 = AAByteStreamRead(*(AAByteStream *)a1, (void *)(a2 + v6), v3);
        size_t v8 = v11;
        if (v11 < 0) {
          return v8;
        }
        if (!v11)
        {
          *(_DWORD *)(a1 + 60) = 1;
          return v6;
        }
      }
      v6 += v8;
      v3 -= v8;
      if (!v3) {
        return v6;
      }
    }
  }
  return 0;
}

uint64_t aaFileStreamRead(int *a1, void *a2, size_t a3)
{
  if (a1[2]) {
    return -1;
  }
  ssize_t v3 = read(*a1, a2, a3);
  if (v3 < 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamRead", 92, 17, "aaFileStreamRead err=%zd buf=%p n=%zu", v4, v5, v6, v3);
  }
  return v3;
}

uint64_t getHeader(unsigned int a1, uint64_t a2)
{
  int DecoderKey = PCompressGetDecoderKey(a1);
  if (DecoderKey == 63) {
    return 0xFFFFFFFFLL;
  }
  char v5 = DecoderKey;
  uint64_t result = 0;
  *(_DWORD *)a2 = 538976288;
  *(_WORD *)a2 = 25200;
  *(unsigned char *)(a2 + 2) = 122;
  *(unsigned char *)(a2 + 3) = v5;
  return result;
}

unint64_t PCompressGetDecoderKey(unsigned int a1)
{
  unint64_t v1 = 0x2D62653466787AuLL >> (8 * a1);
  if (a1 >= 7) {
    LOBYTE(v1) = 63;
  }
  return v1 & 0x7F;
}

uint64_t ThreadPipelineRunWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 24);
  if (v8 == -1)
  {
    char v14 = "Missing call to GetWorker before RunWorker";
    __int16 v15 = 311;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = -1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v10 + 1;
  *(void *)(v9 + 408 * v8 + 400) = v10;
  if ((SharedArrayEnqueue_0((unsigned int *)(a1 + 168), v8) & 0x80000000) != 0)
  {
    char v14 = "SharedArrayEnqueue failed";
    __int16 v15 = 324;
    goto LABEL_10;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(v9 + 408 * v8 + 48))
    || (uint64_t v11 = v9 + 408 * v8, v12 = *(_DWORD *)(v11 + 40), *(_DWORD *)(v11 + 40) = v12 + 1, !v12)
    && pthread_cond_broadcast((pthread_cond_t *)(v9 + 408 * v8 + 112))
    || (uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 408 * v8 + 48)), result))
  {
    char v14 = "SemRelease failed";
    __int16 v15 = 325;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineRunWorker", v15, 87, 0, v14, a7, a8, v16);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t ThreadPipelineGetWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 24) != -1)
  {
    unsigned int v8 = "Missing call to RunWorker before GetWorker";
    __int16 v9 = 294;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineGetWorker", v9, 87, 0, v8, a7, a8, v21);
    return 0;
  }
  uint64_t v11 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    __int16 v15 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v16 = 91;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v16, 0, v15, v12, v13, v14, v21);
    unsigned int v8 = "SharedArrayPop failed";
    __int16 v9 = 298;
    goto LABEL_11;
  }
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 40);
    if (v17) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v11))
    {
      __int16 v15 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v16 = 94;
      goto LABEL_10;
    }
  }
  unsigned int v18 = v17 - 1;
  *(_DWORD *)(a1 + 40) = v18;
  unsigned int v19 = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v18);
  if (pthread_mutex_unlock(v11))
  {
    __int16 v15 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v16 = 98;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = v19;
  return *(void *)(*(void *)(a1 + 8) + 408 * v19 + 24);
}

uint64_t leaveThreadErrorContext(__CFError **a1, const __CFString **a2, int a3)
{
  userInfoValues[1] = *(void **)MEMORY[0x263EF8340];
  pthread_key_t ErrorContextKey = getErrorContextKey();
  size_t v7 = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (v7)
  {
    __int16 v15 = v7;
    unsigned __int16 v16 = v7[2] - 1;
    v7[2] = v16;
    if (!v16)
    {
      uint64_t v18 = v7[36];
      uint64_t v17 = *(unsigned int *)v7;
      if (!v7[36] && (v17 & 0x80000000) == 0)
      {
        if (!v7[3] || !a2 && !a3) {
          goto LABEL_46;
        }
        bzero(userInfoKeys, 0x400uLL);
        unint64_t v35 = 0;
        do
        {
          size_t v36 = strlen((const char *)userInfoKeys);
          if (v36 + 20 > 0x3FF) {
            break;
          }
          if (v36) {
            snprintf((char *)userInfoKeys + v36, 1024 - v36, ",0x%08x");
          }
          else {
            snprintf((char *)userInfoKeys, 0x400uLL, "Warnings:0x%08x");
          }
          ++v35;
        }
        while (v35 < v15[3]);
        CFStringRef v37 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], (const char *)userInfoKeys, 0x600u);
        if (!v37) {
          goto LABEL_46;
        }
        CFStringRef v38 = v37;
        if (a2)
        {
          *a2 = v37;
          goto LABEL_46;
        }
        CFIndex v45 = CFStringGetLength(v37) + 1;
        uint64_t v46 = (char *)calloc(1uLL, v45);
        if (v46)
        {
          signed int v47 = v46;
          CFStringGetCString(v38, v46, v45, 0x600u);
          fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n", v47);
          free(v47);
        }
        uint64_t v44 = v38;
LABEL_45:
        CFRelease(v44);
        goto LABEL_46;
      }
      if (!a1 && !a3) {
        goto LABEL_46;
      }
      size_t v19 = v18 + 32;
      char v20 = (char *)calloc(v18 + 32, 1uLL);
      if (!v20) {
        goto LABEL_46;
      }
      char v21 = v20;
      uint64_t v22 = v20;
      if ((v17 & 0x80000000) != 0)
      {
        snprintf(v20, v19, "Error 0x%08x\n", v17);
        uint64_t v22 = &v21[strlen(v21)];
      }
      unsigned int v23 = v15[36];
      if (v15[36])
      {
        unsigned int v24 = 0;
        do
        {
          unsigned int v25 = (unsigned __int16 *)((char *)v15 + v24 + 76);
          unsigned int v26 = *v25;
          unsigned int v27 = v26 + v24;
          if (v26 < 4 || v27 > v23) {
            break;
          }
          size_t v29 = v26 - 3;
          memcpy(v22, v25 + 1, v29);
          uint64_t v30 = &v22[v29];
          *uint64_t v30 = 10;
          uint64_t v22 = v30 + 1;
          unsigned int v24 = (unsigned __int16)v27;
          unsigned int v23 = v15[36];
        }
        while (v23 > (unsigned __int16)v27);
      }
      if (v22 > v21) {
        *(v22 - 1) = 0;
      }
      CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFStringRef v32 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], v21, 0x600u);
      if (!v32)
      {
        free(v21);
        goto LABEL_46;
      }
      CFStringRef v33 = v32;
      userInfoKeys[0] = *(void **)MEMORY[0x263EFFC70];
      userInfoValues[0] = (void *)v32;
      size_t v34 = CFErrorCreateWithUserInfoKeysAndValues(v31, @"com.apple.ParallelCompression", 1, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 1);
      CFRelease(v33);
      free(v21);
      if (v34)
      {
        if (!a1)
        {
          CFStringRef v39 = CFErrorCopyDescription(v34);
          if (v39)
          {
            CFStringRef v40 = v39;
            CFIndex v41 = CFStringGetLength(v39) + 1;
            size_t v42 = (char *)calloc(1uLL, v41);
            if (v42)
            {
              uint64_t v43 = v42;
              CFStringGetCString(v40, v42, v41, 0x600u);
              fprintf((FILE *)*MEMORY[0x263EF8348], "%s\n", v43);
              free(v43);
            }
            CFRelease(v40);
          }
          uint64_t v44 = v34;
          goto LABEL_45;
        }
        *a1 = v34;
      }
LABEL_46:
      setThreadErrorContext(0, v8, v9, v10, v11, v12, v13, v14, v49);
      free(v15);
      return v17;
    }
  }
  return 0;
}

_WORD *enterThreadErrorContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  uint64_t result = pthread_getspecific(ErrorContextKey);
  if (result)
  {
    ++result[2];
  }
  else
  {
    uint64_t v11 = calloc(1uLL, 0x2000uLL);
    if (v11)
    {
      v11[2] = 1;
      *((_DWORD *)v11 + 18) = 531890176;
      return (_WORD *)setThreadErrorContext(v11, v12, v13, v14, v15, v16, v17, v18, a9);
    }
    else
    {
      int v19 = *__error();
      return (_WORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThreadErrorContext", 76, 5, v19, "malloc", v20, v21, a9);
    }
  }
  return result;
}

unsigned int *ThreadPipelineCreate(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6)
{
  uint64_t v12 = (unsigned int *)calloc(1uLL, 0x1A8uLL);
  uint64_t v13 = v12;
  if (v12)
  {
    *uint64_t v12 = a1;
    uint64_t v14 = calloc(a1, 0x198uLL);
    *((void *)v13 + 1) = v14;
    if (v14)
    {
      uint64_t v15 = calloc(1uLL, 0x20uLL);
      *((void *)v13 + 2) = v15;
      if (v15)
      {
        size_t v16 = *v13;
        v13[10] = 0;
        v13[11] = v16;
        uint64_t v17 = calloc(v16, 4uLL);
        *((void *)v13 + 6) = v17;
        if (v17)
        {
          if (pthread_mutex_init((pthread_mutex_t *)(v13 + 14), 0))
          {
            uint64_t v21 = "SharedArrayInit: pthread_mutex_init failed\n";
            __int16 v22 = 56;
          }
          else
          {
            if (!pthread_cond_init((pthread_cond_t *)(v13 + 30), 0))
            {
              size_t v29 = *v13 + 1;
              v13[42] = 0;
              v13[43] = v29;
              uint64_t v30 = calloc(v29, 4uLL);
              *((void *)v13 + 22) = v30;
              if (v30)
              {
                if (pthread_mutex_init((pthread_mutex_t *)(v13 + 46), 0))
                {
                  size_t v34 = "SharedArrayInit: pthread_mutex_init failed\n";
                  __int16 v35 = 56;
                }
                else
                {
                  if (!pthread_cond_init((pthread_cond_t *)(v13 + 62), 0))
                  {
                    v13[6] = -1;
                    v13[74] = 0;
                    if (pthread_mutex_init((pthread_mutex_t *)(v13 + 76), 0)
                      || pthread_cond_init((pthread_cond_t *)(v13 + 92), 0))
                    {
                      unsigned int v26 = "SemInit";
                      __int16 v27 = 184;
                    }
                    else if (*v13)
                    {
                      uint64_t v36 = 0;
                      unint64_t v37 = 0;
                      while (1)
                      {
                        uint64_t v38 = *((void *)v13 + 1);
                        uint64_t v39 = v38 + v36;
                        *(void *)(v39 + 16) = v13;
                        *(_DWORD *)(v39 + 8) = v37;
                        *(void *)(v39 + 24) = *(void *)(a2 + 8 * v37);
                        *(void *)(v39 + 32) = a3;
                        *(_DWORD *)(v39 + 40) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 48), 0)
                          || pthread_cond_init((pthread_cond_t *)(v39 + 112), 0))
                        {
                          unsigned int v26 = "SemInit";
                          __int16 v27 = 194;
                          goto LABEL_14;
                        }
                        uint64_t v43 = v36;
                        uint64_t v40 = v38 + v36;
                        *(_DWORD *)(v40 + 160) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v40 + 168), 0)
                          || pthread_cond_init((pthread_cond_t *)(v40 + 232), 0))
                        {
                          unsigned int v26 = "SemInit";
                          __int16 v27 = 195;
                          goto LABEL_14;
                        }
                        *(_DWORD *)(v38 + v43 + 280) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v43 + 288), 0)
                          || pthread_cond_init((pthread_cond_t *)(v38 + v43 + 352), 0))
                        {
                          unsigned int v26 = "SemInit";
                          __int16 v27 = 196;
                          goto LABEL_14;
                        }
                        if ((createThread((pthread_t *)v39, (uint64_t)threadPipelineWorkerThreadProc, v39, a6) & 0x80000000) != 0) {
                          break;
                        }
                        ++v37;
                        uint64_t v36 = v43 + 408;
                        if (v37 >= *v13) {
                          goto LABEL_37;
                        }
                      }
                      unsigned int v26 = "Thread creation";
                      __int16 v27 = 197;
                    }
                    else
                    {
LABEL_37:
                      uint64_t v41 = *((void *)v13 + 2);
                      *(void *)(v41 + 8) = v13;
                      *(void *)(v41 + 16) = a4;
                      *(void *)(v41 + 24) = a5;
                      if ((createThread((pthread_t *)v41, (uint64_t)threadPipelineConsumerThreadProc, v41, 0) & 0x80000000) == 0) {
                        return v13;
                      }
                      unsigned int v26 = "Thread creation";
                      __int16 v27 = 206;
                    }
                    goto LABEL_14;
                  }
                  size_t v34 = "SharedArrayInit: pthread_cond_init failed\n";
                  __int16 v35 = 57;
                }
              }
              else
              {
                size_t v34 = "SharedArrayInit: malloc failed\n";
                __int16 v35 = 55;
              }
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v35, 0, v34, v31, v32, v33, v42);
              unsigned int v26 = "SharedArrayInit";
              __int16 v27 = 182;
LABEL_14:
              int v23 = 0;
              goto LABEL_15;
            }
            uint64_t v21 = "SharedArrayInit: pthread_cond_init failed\n";
            __int16 v22 = 57;
          }
        }
        else
        {
          uint64_t v21 = "SharedArrayInit: malloc failed\n";
          __int16 v22 = 55;
        }
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v22, 0, v21, v18, v19, v20, v42);
        unsigned int v26 = "SharedArrayInit";
        __int16 v27 = 180;
        goto LABEL_14;
      }
      int v23 = *__error();
      unsigned int v26 = "malloc";
      __int16 v27 = 179;
    }
    else
    {
      int v23 = *__error();
      unsigned int v26 = "malloc";
      __int16 v27 = 177;
    }
  }
  else
  {
    int v23 = *__error();
    unsigned int v26 = "malloc";
    __int16 v27 = 172;
  }
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineCreate", v27, 87, v23, v26, v24, v25, v42);
  ThreadPipelineDestroy((uint64_t)v13);
  return 0;
}

uint64_t (*PCompressGetDecoderFilter(unsigned int a1))()
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return off_26C59A4E8[a1];
  }
}

uint64_t IDecoderStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  uint64_t v10 = malloc(0x48uLL);
  uint64_t v18 = (uint64_t)v10;
  if (v10)
  {
    v10[2] = 0u;
    v10[3] = 0u;
    *uint64_t v10 = 0u;
    v10[1] = 0u;
    uint64_t v19 = SharedBufferCreate(a4, v11, v12, v13, v14, v15, v16, v17);
    *(void *)(v18 + 64) = v19;
    if (!v19)
    {
      int v23 = "fail to init buffer";
      __int16 v24 = 112;
      int v22 = 0;
      goto LABEL_7;
    }
    *(_DWORD *)uint64_t v18 = 0;
    *(_DWORD *)(v18 + 4) = a5;
    *(void *)(v18 + 8) = a1;
    *(void *)(v18 + 16) = a2;
    *(void *)(v18 + 24) = a3;
    *(void *)(v18 + 32) = SharedBufferWrite;
    *(void *)(v18 + 40) = SharedBufferAbort;
    *(void *)(v18 + 48) = v19;
    if (createThread((pthread_t *)(v18 + 56), (uint64_t)IDecoderStreamThreadProc, v18, 0))
    {
      int v22 = *__error();
      int v23 = "failed to start decoder thread";
      __int16 v24 = 125;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", v24, 39, v22, v23, v20, v21, v29);
      IDecoderStreamDestroy((void *)v18);
      return 0;
    }
  }
  else
  {
    uint64_t v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", 107, 39, *v25, "malloc", v26, v27, v29);
  }
  return v18;
}

uint64_t createErrorContextKey()
{
  uint64_t result = pthread_key_create((pthread_key_t *)&gErrorContextKey, 0);
  if (result)
  {
    uint64_t v1 = *__error();
    return pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "createErrorContextKey", 42, 5, v1, "pthread_key_create");
  }
  return result;
}

uint64_t threadPipelineConsumerThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)))
  {
    uint64_t v12 = (pthread_cond_t *)(v2 + 248);
    uint64_t v13 = (pthread_mutex_t *)(v2 + 304);
    int v28 = (pthread_cond_t *)(v2 + 368);
    do
    {
      while (1)
      {
        int v14 = *(_DWORD *)(v2 + 168);
        if (v14) {
          break;
        }
        if (pthread_cond_wait(v12, (pthread_mutex_t *)(v2 + 184)))
        {
          uint64_t v6 = "SharedArrayPop: pthread_cond_wait failed\n";
          __int16 v7 = 94;
          goto LABEL_3;
        }
      }
      unsigned int v15 = v14 - 1;
      *(_DWORD *)(v2 + 168) = v15;
      unsigned int v16 = *(_DWORD *)(*(void *)(v2 + 176) + 4 * v15);
      if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 184)))
      {
        uint64_t v6 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        __int16 v7 = 98;
        goto LABEL_3;
      }
      if (v16 == -2)
      {
        if (!pthread_mutex_lock(v13))
        {
          int v22 = *(_DWORD *)(v2 + 296);
          *(_DWORD *)(v2 + 296) = v22 + 1;
          if (v22 || !pthread_cond_broadcast(v28)) {
            pthread_mutex_unlock(v13);
          }
        }
      }
      else
      {
        if (v16 == -1) {
          return a1;
        }
        uint64_t v17 = v12;
        uint64_t v18 = *(void *)(v2 + 8);
        uint64_t v19 = v18 + 408 * v16;
        uint64_t v20 = (pthread_mutex_t *)(v19 + 168);
        if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 168))) {
          goto LABEL_30;
        }
        uint64_t v21 = (int *)(v19 + 160);
        while (*v21 <= 0)
        {
          if (pthread_cond_wait((pthread_cond_t *)(v18 + 408 * v16 + 232), v20)) {
            goto LABEL_30;
          }
        }
        --*v21;
        if (pthread_mutex_unlock(v20))
        {
LABEL_30:
          uint64_t v10 = "SemAcquire";
          __int16 v11 = 134;
          goto LABEL_31;
        }
        if (((*(uint64_t (**)(void, void))(a1 + 24))(*(void *)(a1 + 16), *(void *)(v18 + 408 * v16 + 24)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", 141, 87, 0, "consumer proc reported an error", v23, v24, (char)v28);
          atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
        }
        uint64_t v12 = v17;
        uint64_t v13 = (pthread_mutex_t *)(v2 + 304);
        if (pthread_mutex_lock((pthread_mutex_t *)(v18 + 408 * v16 + 288))
          || (uint64_t v25 = v18 + 408 * v16, v26 = *(_DWORD *)(v25 + 280), *(_DWORD *)(v25 + 280) = v26 + 1, !v26)
          && pthread_cond_broadcast((pthread_cond_t *)(v18 + 408 * v16 + 352))
          || pthread_mutex_unlock((pthread_mutex_t *)(v18 + 408 * v16 + 288)))
        {
          uint64_t v10 = "SemRelease";
          __int16 v11 = 144;
          goto LABEL_31;
        }
      }
    }
    while (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)));
  }
  uint64_t v6 = "SharedArrayPop: pthread_mutex_lock failed\n";
  __int16 v7 = 91;
LABEL_3:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v7, 0, v6, v3, v4, v5, (char)v28);
  uint64_t v10 = "SharedArrayDequeue";
  __int16 v11 = 114;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", v11, 87, 0, v10, v8, v9, (char)v28);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 416), 1u, memory_order_relaxed);
  return a1;
}

uint64_t outputStreamProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (atomic_load((unsigned int *)(a1 + 112))) {
    return 0;
  }
  unint64_t v12 = *(void *)(a2 + 48);
  if (v12 > 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v13 = 0;
LABEL_5:
    uint64_t result = 0;
    *(void *)(a1 + 88) += v13;
    return result;
  }
  if ((v12 & 0x8000000000000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 327, 37, 0, "invalid block ID in write thread %lld", a7, a8, *(void *)(a2 + 48));
LABEL_20:
    uint64_t v13 = 0;
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 4) != 1)
  {
    int8x16_t v17 = vrev64q_s8(*(int8x16_t *)(a2 + 56));
    int8x16_t v26 = vextq_s8(v17, v17, 8uLL);
    uint64_t v18 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(void *)(a1 + 72), (uint64_t)&v26, 16);
    if ((v18 & 0x8000000000000000) == 0)
    {
      uint64_t v13 = v18;
      if (v18 == 16)
      {
        uint64_t v19 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(void *)(a1 + 72), *(void *)(a2 + 40), *(void *)(a2 + 56));
        if (v19 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 351, 37, 0, "writing block payload", v20, v21, v25);
          uint64_t v13 = 16;
        }
        else
        {
          uint64_t v13 = v19 + 16;
          if (v19 == *(void *)(a2 + 56)) {
            goto LABEL_5;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 353, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v20, v21, v19);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 347, 37, 0, "Truncated block header (%lld/16 bytes written)", v15, v16, v18);
      }
      goto LABEL_22;
    }
    int v22 = "writing block header";
    __int16 v23 = 345;
    goto LABEL_19;
  }
  uint64_t v14 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(void *)(a1 + 72), *(void *)(a2 + 40), *(void *)(a2 + 56));
  if (v14 < 0)
  {
    int v22 = "writing block";
    __int16 v23 = 334;
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", v23, 37, 0, v22, v15, v16, v25);
    goto LABEL_20;
  }
  uint64_t v13 = v14;
  if (v14 == *(void *)(a2 + 56)) {
    goto LABEL_5;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 336, 37, 0, "Truncated block payload (%lld/%llu bytes written)", v15, v16, v14);
LABEL_22:
  int v24 = 0;
  *(void *)(a1 + 88) += v13;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 112), (unsigned int *)&v24, 1u);
  return 0xFFFFFFFFLL;
}

uint64_t pcWrite(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = a4;
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = a1(a2, a3, v6);
      uint64_t v12 = v9;
      if (v9 < 0) {
        break;
      }
      a3 += v9;
      v8 += v9;
      v6 -= v9;
      if (!v6) {
        return v8;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 131, 37, 0, "pcWrite failed", v10, v11, v16);
    return v12;
  }
  else
  {
    uint64_t v8 = a1(a2, 0, 0);
    if (v8 < 0) {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v13, v14, v16);
    }
  }
  return v8;
}

uint64_t compare_extents_by_position(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

void rawimg_destroy(uint64_t *a1)
{
  if (a1)
  {
    if (a1[270])
    {
      unint64_t v2 = 0;
      uint64_t v3 = 384;
      do
      {
        free(*(void **)(a1[268] + v3));
        ++v2;
        v3 += 440;
      }
      while (v2 < a1[270]);
    }
    pc_array_free(a1[267]);
    pc_array_free(a1[268]);
    free(a1);
  }
}

uint64_t rawimg_show(uint64_t result, int a2, int a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v5 = (void *)result;
    char v17 = 0;
    memset(v16, 0, sizeof(v16));
    uint64_t v6 = *(void *)(result + 2160);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t v9 = (void *)(*(void *)(result + 2144) + 400);
      do
      {
        v7 += *v9;
        v8 += *(v9 - 1);
        v9 += 55;
        --v6;
      }
      while (v6);
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v7 = 0;
    }
    uint64_t result = serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)(result + 2088));
    if (a3 > 1)
    {
      uint64_t v10 = (FILE **)MEMORY[0x263EF8348];
      uint64_t v11 = "Output";
      if (!a2) {
        uint64_t v11 = "Input";
      }
      uint64_t v12 = (const char *)&unk_214B013C1;
      if (v5[256]) {
        uint64_t v12 = (const char *)v5[256];
      }
      uint64_t result = fprintf((FILE *)*MEMORY[0x263EF8348], "%s variant <%s> | %llu bytes | %zu extents | %zu forks (%llu/%llu) | digest=%s\n", v11, v12, v5[265], v5[269], v5[270], v7, v8, (const char *)v16);
      if (a3 != 2)
      {
        uint64_t result = fprintf(*v10, " fork | %64s | algo |       size | compressed | V | C\n", "digest");
        if (v5[270])
        {
          uint64_t v13 = 0;
          unint64_t v14 = 0;
          do
          {
            uint64_t v15 = v5[268] + v13;
            serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)v15);
            uint64_t result = fprintf(*v10, "%5zu | %s | %4d | %10llu | %10llu | %d | %d\n", ++v14, (const char *)v16, *(unsigned __int8 *)(v15 + 432), *(void *)(v15 + 392), *(void *)(v15 + 400), *(_DWORD *)(v15 + 408) & 1, (*(_DWORD *)(v15 + 408) >> 1) & 1);
            v13 += 440;
          }
          while (v14 < v5[270]);
        }
      }
    }
  }
  return result;
}

uint64_t *rawimg_create_with_path(const char *a1)
{
  unint64_t v2 = (uint64_t *)calloc(1uLL, 0x878uLL);
  memset(&v23, 0, sizeof(v23));
  if (!v2)
  {
    int v20 = *__error();
    uint64_t v18 = "aaCalloc";
    __int16 v19 = 468;
    goto LABEL_17;
  }
  if (lstat(a1, &v23) || (v23.st_mode & 0xF000) != 0x8000)
  {
    uint64_t v18 = "lstat";
    __int16 v19 = 469;
LABEL_15:
    int v20 = 0;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_path", v19, 138, v20, v18, v3, v4, v23.st_dev);
    rawimg_destroy(v2);
    return 0;
  }
  v2[256] = (uint64_t)a1;
  v2[265] = v23.st_size;
  v2[267] = (uint64_t)pc_array_init(16);
  uint64_t v5 = pc_array_init(440);
  v2[268] = (uint64_t)v5;
  if (!v2[267] || !v5)
  {
    uint64_t v18 = "pc_array_init";
    __int16 v19 = 476;
    goto LABEL_15;
  }
  if ((apfs_scan_diskimage(a1, (uint64_t (*)(long long *, uint64_t))rawimg_add_fork, (uint64_t)rawimg_add_volume, (uint64_t)v2) & 0x80000000) != 0)
  {
    uint64_t v18 = "rawimg_query_forks";
    __int16 v19 = 479;
    goto LABEL_15;
  }
  uint64_t v6 = (void *)v2[268];
  uint64_t v7 = *(v6 - 8);
  v2[270] = v7;
  v2[269] = *(void *)(v2[267] - 64);
  if (v7)
  {
    pc_array_sort(v6, (int (__cdecl *)(const void *, const void *))compare_forks_by_extent);
    if ((pc_array_aggregate((char *)v2[268], (unsigned int (*)(char *, char *))compare_forks_by_extent, (uint64_t (*)(char *, char *))aggregate_identical_forks) & 0x80000000) != 0)
    {
      int v22 = "rawimg_remove_fork_duplicates";
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_remove_fork_duplicates", 454, 138, 0, "bad duplicate", v8, v9, v23.st_dev);
      __int16 v19 = 484;
      goto LABEL_23;
    }
    uint64_t v6 = (void *)v2[268];
    v2[270] = *(v6 - 8);
  }
  v2[268] = (uint64_t)pc_array_compact((uint64_t)v6);
  uint64_t v10 = pc_array_compact(v2[267]);
  v2[267] = (uint64_t)v10;
  if (!v10 || !v2[268])
  {
    int v22 = "rawimg_compact";
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_compact", 77, 138, 0, "pc_array_compress", v16, v17, v23.st_dev);
    __int16 v19 = 485;
LABEL_23:
    int v20 = 0;
    uint64_t v18 = v22;
    goto LABEL_17;
  }
  if ((rawimg_verify(v2, v11, v12, v13, v14, v15, v16, v17) & 0x80000000) != 0)
  {
    uint64_t v18 = "rawimg_verify";
    __int16 v19 = 486;
    goto LABEL_15;
  }
  qsort_r((void *)v2[268], v2[270], 0x1B8uLL, v2, (int (__cdecl *)(void *, const void *, const void *))compare_forks_by_position);
  return v2;
}

uint64_t rawimg_add_fork(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  memset(__src, 0, sizeof(__src));
  uint64_t v8 = *(unsigned int *)(a1 + 20);
  if (v8 && *(void *)a1)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    *((void *)&v24 + 1) = *(void *)a1;
    *(void *)&long long v25 = v11;
    *(void *)&long long v26 = *(void *)(*(void *)(a2 + 2136) - 64);
    *((void *)&v26 + 1) = v8;
    LOBYTE(v27) = *(_DWORD *)(a1 + 16);
    uint64_t v12 = pc_array_append(*(void *)(a2 + 2144), __src, a3, a4, a5, a6, a7, a8);
    *(void *)(a2 + 2144) = v12;
    if (v12)
    {
      if (*(int *)(a1 + 20) < 1) {
        return 0;
      }
      uint64_t v17 = 0;
      uint64_t v18 = *(void **)(a2 + 2136);
      while (1)
      {
        long long v22 = 0uLL;
        long long v22 = *(_OWORD *)(*(void *)(a1 + 24) + 16 * v17);
        uint64_t v18 = pc_array_append((uint64_t)v18, &v22, v13, v14, v15, v16, a7, a8);
        *(void *)(a2 + 2136) = v18;
        if (!v18) {
          break;
        }
        if (++v17 >= *(int *)(a1 + 20)) {
          return 0;
        }
      }
      int v20 = "pc_array_append";
      __int16 v21 = 440;
    }
    else
    {
      int v20 = "pc_array_append";
      __int16 v21 = 427;
    }
  }
  else
  {
    int v20 = "bad fork";
    __int16 v21 = 416;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_add_fork", v21, 138, 0, v20, a7, a8, v22);
  return 0xFFFFFFFFLL;
}

uint64_t rawimg_add_volume()
{
  return 0;
}

uint64_t rawimg_verify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[270];
  uint64_t v9 = a1[269];
  if (!v8 || !v9)
  {
    if (!(v8 + v9)) {
      return 0;
    }
    long long v26 = "bad variant";
    __int16 v27 = 184;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v27, 138, 0, v26, a7, a8, v61);
    uint64_t v28 = 0;
    uint64_t v17 = 0;
    goto LABEL_23;
  }
  uint64_t v11 = a1[267];
  uint64_t v12 = (void *)(v11 + 8);
  do
  {
    uint64_t v13 = *(v12 - 1);
    if ((unint64_t)(*v12 + v13) > a1[265])
    {
      long long v26 = "bad extent";
      __int16 v27 = 195;
      goto LABEL_22;
    }
    if ((v13 & 0xFFF) != 0)
    {
      long long v26 = "bad extent pos";
      __int16 v27 = 196;
      goto LABEL_22;
    }
    if ((*v12 & 0xFFFLL) != 0)
    {
      long long v26 = "bad extent size";
      __int16 v27 = 197;
      goto LABEL_22;
    }
    v12 += 2;
    --v9;
  }
  while (v9);
  uint64_t v14 = pc_array_indirect_sort(v11, compare_extents_by_position);
  uint64_t v17 = v14;
  if (!v14)
  {
    stat v23 = "pc_array_indirect_sort";
    __int16 v24 = 202;
    goto LABEL_27;
  }
  uint64_t v18 = 0;
  unint64_t v19 = a1[269];
  if (v19 <= 1) {
    uint64_t v20 = 1;
  }
  else {
    uint64_t v20 = a1[269];
  }
  uint64_t v21 = v20 - 1;
  while (v21 != v18)
  {
    long long v22 = (void **)&v14[v18++];
    if ((*v22)[1] + **v22 > *v22[1])
    {
      stat v23 = "extents overlapping";
      __int16 v24 = 205;
      goto LABEL_27;
    }
  }
  uint64_t v30 = a1[270];
  uint64_t v31 = a1[268];
  if (!v30)
  {
LABEL_42:
    uint64_t v28 = pc_array_indirect_sort(v31, compare_forks_by_extent);
    if (v28)
    {
      unint64_t v45 = a1[270];
      if (v45 <= 1) {
        uint64_t v46 = 1;
      }
      else {
        uint64_t v46 = a1[270];
      }
      uint64_t v47 = 856;
      while (--v46)
      {
        uint64_t v48 = (void *)(a1[268] + v47);
        v47 += 440;
        if (*(v48 - 55) == *v48)
        {
          char v49 = "duplicate fork";
          __int16 v50 = 239;
          goto LABEL_69;
        }
      }
      if (!v45)
      {
LABEL_59:
        uint64_t v25 = 0;
        goto LABEL_24;
      }
      uint64_t v51 = 0;
      uint64_t v52 = a1[268];
      while (1)
      {
        uint64_t v53 = *(void *)(v52 + 440 * v51 + 56);
        if (v53) {
          break;
        }
LABEL_58:
        if (++v51 == v45) {
          goto LABEL_59;
        }
      }
      unint64_t v54 = 0;
      uint64_t v55 = v52 + 440 * v51;
      uint64_t v56 = *(void *)(v55 + 384);
      uint64_t v57 = (unint64_t *)(v55 + 400);
      uint64_t v58 = (unsigned int *)(v56 + 8);
      while (1)
      {
        unint64_t v59 = *((void *)v58 - 1);
        if (v59 < v54)
        {
          char v49 = "bad chunk order";
          __int16 v50 = 256;
          goto LABEL_69;
        }
        unint64_t v54 = v59 + *v58;
        if (v54 > *v57) {
          break;
        }
        v58 += 3;
        if (!--v53) {
          goto LABEL_58;
        }
      }
      char v49 = "chunk out of bounds";
      __int16 v50 = 257;
    }
    else
    {
      char v49 = "pc_array_indirect_sort";
      __int16 v50 = 236;
    }
LABEL_69:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v50, 138, 0, v49, v43, v44, v61);
    goto LABEL_23;
  }
  uint64_t v32 = 0;
  while (2)
  {
    uint64_t v33 = v31 + 440 * v32;
    uint64_t v35 = *(void *)(v33 + 416);
    uint64_t v34 = *(void *)(v33 + 424);
    if (v34 + v35 > v19)
    {
      stat v23 = "bad fork";
      __int16 v24 = 216;
      goto LABEL_27;
    }
    if (!v34)
    {
      stat v23 = "no fork extents";
      __int16 v24 = 219;
      goto LABEL_27;
    }
    if (!*(void *)(v31 + 440 * v32 + 392))
    {
      stat v23 = "bad fork size";
      __int16 v24 = 222;
      goto LABEL_27;
    }
    uint64_t v36 = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
    if (!*(unsigned char *)(v31 + 440 * v32 + 432))
    {
      __int16 v60 = 155;
      goto LABEL_66;
    }
    unint64_t v37 = &a1[*(unsigned __int8 *)(v31 + 440 * v32 + 432)];
    if (*v37)
    {
LABEL_38:
      unint64_t v40 = 0;
      uint64_t v41 = (uint64_t *)(a1[267] + 16 * v35 + 8);
      do
      {
        uint64_t v42 = *v41;
        v41 += 2;
        v40 += v42;
        --v34;
      }
      while (v34);
      if (v40 < *(void *)(v31 + 440 * v32 + 400))
      {
        stat v23 = "bad fork size";
        __int16 v24 = 231;
        goto LABEL_27;
      }
      if (++v32 == v30) {
        goto LABEL_42;
      }
      continue;
    }
    break;
  }
  HIDWORD(v39) = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
  LODWORD(v39) = v36 - 4;
  unsigned int v38 = v39 >> 1;
  if (v38 < 6 && ((0x35u >> v38) & 1) != 0)
  {
    *unint64_t v37 = dword_214B128C0[v38];
    BYTE4(a1[v36]) = 0xFFFFFF06FFFFuLL >> (8 * v38);
    goto LABEL_38;
  }
  __int16 v60 = 167;
LABEL_66:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_init_algorithm", v60, 138, 0, "bad algo", v15, v16, v61);
  __int16 v24 = 225;
  stat v23 = "rawimg_init_algorithm";
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v24, 138, 0, v23, v15, v16, v61);
  uint64_t v28 = 0;
LABEL_23:
  uint64_t v25 = 0xFFFFFFFFLL;
LABEL_24:
  free(v17);
  free(v28);
  return v25;
}

uint64_t rawimg_get_digests(uint64_t a1, signed int a2, int a3, int a4)
{
  memset(&c, 0, sizeof(c));
  uint64_t v8 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 2048), 0, 0);
  uint64_t v11 = (AAByteStream_impl *)v8;
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 570, 138, 0, "AAFileStreamOpenWithPath", v9, v10, v150);
LABEL_78:
    unint64_t v79 = 0;
    int v82 = 0;
    uint64_t v80 = 0;
    __int16 v93 = 0;
    uint64_t v76 = 0;
    uint64_t v20 = 0;
LABEL_95:
    int v113 = 0;
    goto LABEL_96;
  }
  if (a4 && (io_set_nocache(v8) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 571, 138, "io_set_nocache %s", v12, v13, v14, *(void *)(a1 + 2048));
  }
  if (AAByteStreamSeek(v11, 0, 2) != *(void *)(a1 + 2120))
  {
    if (!a3) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 575, 138, "image size mismatch", v15, v16, v17, v150);
    }
    goto LABEL_78;
  }
  uint64_t v20 = aaSegmentStreamOpen(v11, (void *)a1);
  if (!v20)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 581, 138, 0, "aaSegmentStreamOpen", v18, v19, v150);
LABEL_94:
    unint64_t v79 = 0;
    int v82 = 0;
    uint64_t v80 = 0;
    __int16 v93 = 0;
    uint64_t v76 = 0;
    goto LABEL_95;
  }
  rawimg_free_chunks((void *)a1);
  if (*(void *)(a1 + 2160))
  {
    unint64_t v26 = 0;
    signed int v160 = a2;
    while (1)
    {
      uint64_t v27 = *(void *)(a1 + 2144);
      uint64_t v28 = v27 + 440 * v26;
      unint64_t v29 = *(void *)(v28 + 392) + 0xFFFFLL;
      *(void *)(v28 + 56) = v29 >> 16;
      uint64_t v30 = (uint64_t *)(v28 + 56);
      if (v29 >= 0x2AAAAAAAB0000)
      {
        *__error() = 12;
        *(void *)(v27 + 440 * v26 + 384) = 0;
LABEL_102:
        __int16 v117 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 307, 138, *v117, "aaCalloc", v118, v119, v150);
        uint64_t v55 = 0;
        goto LABEL_92;
      }
      uint64_t v31 = calloc(v29 >> 16, 0xCuLL);
      uint64_t v34 = v27 + 440 * v26;
      *(void *)(v34 + 384) = v31;
      if (!v31) {
        goto LABEL_102;
      }
      uint64_t v35 = (void **)(v34 + 384);
      uint64_t v36 = *v30;
      uint64_t v164 = v27;
      if (*(unsigned char *)(v27 + 440 * v26 + 432) == 4)
      {
        int v156 = a3;
        v158 = v11;
        unint64_t v162 = v26;
        unint64_t v37 = (void *)(v27 + 440 * v26);
        uint64_t v38 = v37[5];
        v152 = v35;
        uint64_t v154 = v37[50];
        v37[51] |= 4uLL;
        if (v20[4])
        {
          uint64_t v39 = 0;
          size_t v40 = 8 * v36;
          uint64_t v151 = 8 * v36 + 264;
          uint64_t v41 = v38 + 264;
          uint64_t v42 = v27 + 440 * v26 + 64;
          uint64_t v43 = v38;
          uint64_t v44 = 264;
          while (1)
          {
            uint64_t v45 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v42, v44, v43);
            if (v45 < 0) {
              break;
            }
            if (v45)
            {
              v42 += v45;
              v39 += v45;
              v43 += v45;
              v44 -= v45;
              if (v44) {
                continue;
              }
            }
            if (v39 != 264) {
              break;
            }
            if (v20[4])
            {
              uint64_t v46 = 0;
              uint64_t v47 = v164 + 440 * v162 + 328;
              uint64_t v48 = v38 + v154 - 50;
              uint64_t v49 = 50;
              while (1)
              {
                uint64_t v50 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v47, v49, v48);
                if (v50 < 0) {
                  break;
                }
                if (v50)
                {
                  v47 += v50;
                  v46 += v50;
                  v48 += v50;
                  v49 -= v50;
                  if (v49) {
                    continue;
                  }
                }
                if (v46 != 50) {
                  break;
                }
                if (v40 >= 0x2000000001)
                {
                  uint64_t v55 = 0;
                  *__error() = 12;
                  goto LABEL_91;
                }
                uint64_t v51 = (int *)malloc(v40);
                uint64_t v55 = v51;
                if (!v51) {
                  goto LABEL_91;
                }
                if (!v20[4]) {
                  goto LABEL_111;
                }
                if (v40)
                {
                  uint64_t v56 = 0;
                  uint64_t v57 = (char *)v51;
                  size_t v58 = v40;
                  while (1)
                  {
                    uint64_t v59 = ((uint64_t (*)(uint64_t *, char *, size_t, uint64_t))v20[4])(*v20, v57, v58, v41);
                    if (v59 < 0) {
                      break;
                    }
                    if (v59)
                    {
                      v57 += v59;
                      v56 += v59;
                      v41 += v59;
                      v58 -= v59;
                      if (v58) {
                        continue;
                      }
                    }
                    goto LABEL_42;
                  }
                  uint64_t v56 = v59;
LABEL_42:
                  if (v40 != v56)
                  {
LABEL_111:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 333, 138, 0, "fork chunks", v53, v54, v150);
                    goto LABEL_91;
                  }
                }
                uint64_t v61 = *v30;
                uint64_t v62 = *v152;
                if (!*v30)
                {
                  uint64_t v63 = 50;
                  size_t v60 = v151;
                  size_t v67 = v151;
                  uint64_t v11 = v158;
                  a3 = v156;
                  unint64_t v26 = v162;
                  goto LABEL_53;
                }
                uint64_t v68 = v62 + 1;
                uint64_t v69 = v55 + 1;
                uint64_t v70 = *v30;
                uint64_t v11 = v158;
                unint64_t v26 = v162;
                size_t v60 = v151;
                do
                {
                  *((void *)v68 - 1) = (*(v69 - 1) + 260);
                  int v71 = *v69;
                  v69 += 2;
                  *uint64_t v68 = v71;
                  v68 += 3;
                  --v70;
                }
                while (v70);
                uint64_t v63 = 50;
                a3 = v156;
                goto LABEL_47;
              }
            }
            char v105 = "fork footer";
            __int16 v106 = 328;
            goto LABEL_90;
          }
        }
        char v105 = "fork header";
        __int16 v106 = 325;
LABEL_90:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v106, 138, 0, v105, v32, v33, v150);
        uint64_t v55 = 0;
LABEL_91:
        uint64_t v11 = v158;
        a3 = v156;
        goto LABEL_92;
      }
      size_t v60 = 4 * v36 + 4;
      if (v60 >= 0x2000000001)
      {
        uint64_t v55 = 0;
        *__error() = 12;
        goto LABEL_92;
      }
      uint64_t v55 = (int *)malloc(v60);
      if (!v55) {
        goto LABEL_92;
      }
      if (v60 != AAByteStreamPRead((AAByteStream)v20, v55, v60, *(void *)(v164 + 440 * v26 + 40)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 351, 138, 0, "fork chunks", v53, v54, v150);
        goto LABEL_92;
      }
      uint64_t v61 = *v30;
      uint64_t v62 = *v35;
      uint64_t v63 = 0;
      if (*v30)
      {
        unint64_t v64 = v62 + 1;
        do
        {
          long long v65 = (unsigned int *)&v55[v63];
          uint64_t v66 = *v65;
          *((void *)v64 - 1) = v66;
          ++v63;
          *unint64_t v64 = v65[1] - v66;
          v64 += 3;
        }
        while (v61 != v63);
        uint64_t v63 = 0;
LABEL_47:
        uint64_t v72 = (unsigned int *)(v62 + 1);
        size_t v67 = v60;
        while (1)
        {
          size_t v73 = *((void *)v72 - 1);
          if (v73 < v67) {
            break;
          }
          size_t v67 = v73 + *v72;
          if (v67 > *(void *)(v164 + 440 * v26 + 400)) {
            break;
          }
          v72 += 3;
          if (!--v61) {
            goto LABEL_53;
          }
        }
        if (!a3)
        {
          uint64_t v103 = "bad chunk";
          __int16 v104 = 372;
LABEL_82:
          pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v104, 138, v103, v52, v53, v54, v150);
          goto LABEL_92;
        }
        goto LABEL_92;
      }
      size_t v67 = v60;
LABEL_53:
      if (*v62 != v60 || v67 + v63 != *(void *)(v164 + 440 * v26 + 400)) {
        break;
      }
      free(v55);
      ++v26;
      a2 = v160;
      if (v26 >= *(void *)(a1 + 2160)) {
        goto LABEL_56;
      }
    }
    if (!a3)
    {
      uint64_t v103 = "bad index";
      __int16 v104 = 381;
      goto LABEL_82;
    }
LABEL_92:
    free(v55);
    rawimg_free_chunks((void *)a1);
    if (!a3) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 587, 138, "bad chunk info", v110, v111, v112, v150);
    }
    goto LABEL_94;
  }
LABEL_56:
  *(void *)(a1 + 2128) |= 8uLL;
  uint64_t v76 = aaForkInputStreamOpen(v20, a1, 1, v21, v22, v23, v24, v25);
  if (!v76)
  {
    unint64_t v107 = "aaForkInputStreamOpen";
    __int16 v108 = 593;
    int v109 = 0;
LABEL_87:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v108, 138, v109, v107, v74, v75, v150);
    unint64_t v79 = 0;
    int v82 = 0;
    uint64_t v80 = 0;
LABEL_88:
    __int16 v93 = 0;
    goto LABEL_95;
  }
  unint64_t v77 = *(void *)(a1 + 2160) + ((unint64_t)(*(void *)(a1 + 2080) + 0x7FFFFFLL) >> 23);
  if (!is_mul_ok(v77, 0x38uLL) || 56 * v77 > 0x2000000000)
  {
    *__error() = 12;
    goto LABEL_86;
  }
  unint64_t v78 = calloc(*(void *)(a1 + 2160) + ((unint64_t)(*(void *)(a1 + 2080) + 0x7FFFFFLL) >> 23), 0x38uLL);
  if (!v78)
  {
LABEL_86:
    int v109 = *__error();
    unint64_t v107 = "aaCalloc";
    __int16 v108 = 601;
    goto LABEL_87;
  }
  unint64_t v79 = v78;
  if (a2 < 0)
  {
    *__error() = 12;
    uint64_t v80 = 0;
    int v82 = 0;
    *__error() = 12;
LABEL_104:
    uint64_t v120 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 606, 138, *v120, "aaCalloc", v121, v122, v150);
    goto LABEL_88;
  }
  uint64_t v80 = (uint64_t **)calloc(a2, 0x10uLL);
  unint64_t v81 = calloc(a2, 8uLL);
  int v82 = v81;
  if (!v80 || !v81) {
    goto LABEL_104;
  }
  if (a2)
  {
    uint64_t v83 = a2;
    uint64_t v84 = v80;
    uint64_t v85 = (uint64_t ***)v81;
    do
    {
      *v85++ = v84;
      *uint64_t v84 = v76;
      v84 += 2;
      --v83;
    }
    while (v83);
  }
  __int16 v93 = ThreadPoolCreate(a2, (uint64_t)v81, (uint64_t)rawimg_digest_worker);
  if (!v93)
  {
    int v123 = "ThreadPoolCreate";
    __int16 v124 = 613;
    goto LABEL_110;
  }
  unint64_t v153 = v77;
  v159 = v11;
  unint64_t v94 = *(void *)(a1 + 2056);
  if (v94 < *(void *)(a1 + 2072))
  {
    size_t v165 = 0;
    uint64_t v95 = -(uint64_t)v94;
    uint64_t v96 = v79;
    while (1)
    {
      uint64_t Worker = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
      if (!Worker)
      {
        uint64_t v143 = "ThreadPoolGetWorker";
        __int16 v144 = 622;
        goto LABEL_133;
      }
      *(void *)(Worker + 8) = v96;
      v96[6] = -1;
      v96[4] = v94;
      unint64_t v102 = v95 + *(void *)(a1 + 2072);
      if (v102 >= 0x800000) {
        unint64_t v102 = 0x800000;
      }
      v96[5] = v102;
      if ((ThreadPoolRunWorker((uint64_t)v93, Worker, v98, v99, v100, v101, v91, v92) & 0x80000000) != 0) {
        break;
      }
      ++v165;
      v94 += 0x800000;
      v95 -= 0x800000;
      v96 += 7;
      if (v94 >= *(void *)(a1 + 2072)) {
        goto LABEL_113;
      }
    }
    uint64_t v143 = "ThreadPoolRunWorker";
    __int16 v144 = 627;
    goto LABEL_133;
  }
  size_t v165 = 0;
LABEL_113:
  unint64_t v125 = *(void *)(a1 + 2160);
  if (!v125)
  {
    uint64_t v11 = v159;
    size_t v127 = v153;
    size_t v128 = v165;
LABEL_127:
    if (v128 <= v127)
    {
      if ((ThreadPoolSync(v93) & 0x80000000) == 0)
      {
        qsort(v79, v128, 0x38uLL, (int (__cdecl *)(const void *, const void *))compare_digest_tasks);
        CC_SHA256_Init(&c);
        if (v128)
        {
          uint64_t v145 = (char *)v79;
          do
          {
            CC_SHA256_Update(&c, v145, 0x20u);
            v145 += 56;
            --v128;
          }
          while (v128);
        }
        CC_SHA256_Final((unsigned __int8 *)(a1 + 2088), &c);
        if (*(void *)(a1 + 2160))
        {
          uint64_t v146 = 0;
          unint64_t v147 = 0;
          do
          {
            CC_SHA256_Init(&c);
            if (v79[7 * v146 + 6] == v147)
            {
              int v148 = &v79[7 * v146];
              do
              {
                CC_SHA256_Update(&c, v148, 0x20u);
                ++v146;
                uint64_t v149 = v148[13];
                v148 += 7;
              }
              while (v149 == v147);
            }
            CC_SHA256_Final((unsigned __int8 *)(*(void *)(a1 + 2144) + 440 * v147++), &c);
          }
          while (v147 < *(void *)(a1 + 2160));
        }
        *(void *)(a1 + 2128) |= 0x10uLL;
        int v113 = 1;
        goto LABEL_134;
      }
      int v123 = "ThreadPoolSync";
      __int16 v124 = 655;
    }
    else
    {
      int v123 = "too many tasks";
      __int16 v124 = 649;
    }
LABEL_110:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v124, 138, 0, v123, v91, v92, v150);
    goto LABEL_95;
  }
  uint64_t v126 = 0;
  uint64_t v11 = v159;
  size_t v127 = v153;
  size_t v128 = v165;
  while (1)
  {
    uint64_t v129 = *(void *)(a1 + 2144);
    uint64_t v130 = v129 + 440 * v126;
    if (*(void *)(v130 + 392)) {
      break;
    }
LABEL_123:
    if (++v126 >= v125) {
      goto LABEL_127;
    }
  }
  uint64_t v131 = 0;
  uint64_t v132 = 0;
  uint64_t v133 = (void *)(v130 + 392);
  uint64_t v161 = v126;
  v155 = v133;
  v157 = (void *)(v129 + 440 * v126 + 48);
  size_t v166 = v128;
  uint64_t v134 = &v79[7 * v128];
  while (1)
  {
    uint64_t v163 = v131;
    uint64_t v135 = v132;
    uint64_t v136 = v133;
    uint64_t v137 = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
    if (!v137)
    {
      uint64_t v143 = "ThreadPoolGetWorker";
      __int16 v144 = 641;
      goto LABEL_133;
    }
    *(void *)(v137 + 8) = v134;
    v134[6] = v161;
    v134[4] = v135 + *v157;
    unint64_t v142 = v163 + *v136;
    if (v142 >= 0x800000) {
      unint64_t v142 = 0x800000;
    }
    v134[5] = v142;
    if ((ThreadPoolRunWorker((uint64_t)v93, v137, v138, v139, v140, v141, v91, v92) & 0x80000000) != 0) {
      break;
    }
    ++v166;
    uint64_t v133 = v155;
    uint64_t v131 = v163 - 0x800000;
    v134 += 7;
    uint64_t v132 = v135 + 0x800000;
    if ((unint64_t)(v135 + 0x800000) >= *v155)
    {
      unint64_t v125 = *(void *)(a1 + 2160);
      uint64_t v11 = v159;
      uint64_t v126 = v161;
      size_t v127 = v153;
      size_t v128 = v166;
      goto LABEL_123;
    }
  }
  uint64_t v143 = "ThreadPoolRunWorker";
  __int16 v144 = 646;
LABEL_133:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v144, 138, 0, v143, v91, v92, v150);
  int v113 = 0;
LABEL_134:
  uint64_t v11 = v159;
LABEL_96:
  if ((ThreadPoolDestroy((uint64_t)v93) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 683, 138, 0, "ThreadPoolDestroy", v114, v115, v150);
    int v113 = 0;
  }
  free(v80);
  free(v82);
  free(v79);
  AAByteStreamClose((AAByteStream)v76);
  AAByteStreamClose((AAByteStream)v20);
  AAByteStreamClose(v11);
  if (v113) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void rawimg_free_chunks(void *a1)
{
  if (a1[270])
  {
    unint64_t v2 = 0;
    uint64_t v3 = 384;
    do
    {
      uint64_t v4 = a1[268] + v3;
      free(*(void **)v4);
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 - 328) = 0;
      *(void *)(v4 + 24) &= ~4uLL;
      ++v2;
      v3 += 440;
    }
    while (v2 < a1[270]);
  }
  a1[266] &= ~8uLL;
}

uint64_t rawimg_digest_worker(void *a1)
{
  uint64_t v2 = a1[1];
  memset(&v21, 0, sizeof(v21));
  uint64_t v3 = (char *)malloc(0x10000uLL);
  if (!v3)
  {
    int v17 = *__error();
    uint64_t v18 = "aaMalloc";
    __int16 v19 = 530;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_digest_worker", v19, 138, v17, v18, v4, v5, v21.count[0]);
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_21;
  }
  CC_SHA256_Init(&v21);
  unint64_t v6 = *(void *)(v2 + 40);
  if (v6)
  {
    unint64_t v7 = 0;
    while (1)
    {
      unint64_t v8 = v6 - v7;
      uint64_t v9 = v8 >= 0x10000 ? 0x10000 : v8;
      uint64_t v10 = *a1;
      if (!*(void *)(*a1 + 32)) {
        break;
      }
      if (v9)
      {
        uint64_t v11 = 0;
        unint64_t v12 = *(void *)(v2 + 32) + v7;
        uint64_t v13 = v3;
        uint64_t v14 = v9;
        while (1)
        {
          uint64_t v15 = (*(uint64_t (**)(void, char *, uint64_t, unint64_t))(v10 + 32))(*(void *)v10, v13, v14, v12);
          if (v15 < 0) {
            break;
          }
          if (v15)
          {
            v13 += v15;
            v11 += v15;
            v12 += v15;
            v14 -= v15;
            if (v14) {
              continue;
            }
          }
          goto LABEL_15;
        }
        uint64_t v11 = v15;
LABEL_15:
        if (v9 != v11) {
          break;
        }
      }
      CC_SHA256_Update(&v21, v3, v9);
      v7 += 0x10000;
      unint64_t v6 = *(void *)(v2 + 40);
      if (v7 >= v6) {
        goto LABEL_17;
      }
    }
    uint64_t v18 = "aaByteStreamPReadExpected";
    __int16 v19 = 537;
    int v17 = 0;
    goto LABEL_20;
  }
LABEL_17:
  CC_SHA256_Final((unsigned __int8 *)v2, &v21);
  uint64_t v16 = 0;
LABEL_21:
  free(v3);
  return v16;
}

uint64_t compare_digest_tasks(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void *)(a2 + 48);
  BOOL v4 = v2 >= v3;
  if (v2 == v3) {
    BOOL v4 = *(void *)(a1 + 32) >= *(void *)(a2 + 32);
  }
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 1;
  }
}

uint64_t rawimg_set_fork_types(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x21)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", 751, 138, 0, "too many variants", a7, a8, v41);
    unint64_t v8 = 0;
    goto LABEL_33;
  }
  if (a2 != 1)
  {
    unint64_t v8 = pc_array_init(16);
    if (v8)
    {
      if (!a2)
      {
LABEL_18:
        pc_array_sort(v8, (int (__cdecl *)(const void *, const void *))compare_copy_fork_5);
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_4, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        uint64_t v24 = *(v8 - 8);
        if (v24)
        {
          uint64_t v25 = v8 + 1;
          do
          {
            if ((*v25 & 1) == 0) {
              *(void *)(*((void *)v25 - 1) + 408) |= 1uLL;
            }
            v25 += 16;
            --v24;
          }
          while (v24);
        }
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_3, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        unint64_t v26 = *(v8 - 8);
        if (v26)
        {
          unint64_t v27 = 0;
          uint64_t v28 = 0;
          unint64_t v29 = v8 + 1;
          do
          {
            if (*v29 == ~(-1 << a2))
            {
              *(_OWORD *)&v8[2 * v28++] = *(_OWORD *)(v29 - 2);
              unint64_t v26 = *(v8 - 8);
            }
            ++v27;
            v29 += 4;
          }
          while (v27 < v26);
        }
        else
        {
          uint64_t v28 = 0;
        }
        *(v8 - 8) = v28;
        if (a2)
        {
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = *(void *)(a1 + 8 * v33);
            if (*(void *)(v34 + 2160))
            {
              unint64_t v35 = 0;
              uint64_t v36 = 408;
              do
              {
                uint64_t v37 = *(void *)(v34 + 2144);
                uint64_t v41 = v37 + v36 - 408;
                uint64_t v42 = 0;
                uint64_t v38 = bsearch(&v41, v8, *(v8 - 8), 0x10uLL, (int (__cdecl *)(const void *, const void *))compare_copy_fork_3);
                if (v38) {
                  BOOL v39 = 1;
                }
                else {
                  BOOL v39 = v33 == 0;
                }
                if (v39)
                {
                  if (v38) {
                    uint64_t v40 = 2;
                  }
                  else {
                    uint64_t v40 = 1;
                  }
                  *(void *)(v37 + v36) |= v40;
                }
                ++v35;
                v36 += 440;
              }
              while (v35 < *(void *)(v34 + 2160));
            }
            ++v33;
          }
          while (v33 != a2);
        }
        uint64_t v13 = 0;
        goto LABEL_34;
      }
      uint64_t v20 = 0;
      while (1)
      {
        uint64_t v21 = *(void *)(a1 + 8 * v20);
        if ((*(unsigned char *)(v21 + 2128) & 0x10) == 0)
        {
          uint64_t v30 = "no digests found";
          __int16 v31 = 778;
          goto LABEL_32;
        }
        if (*(void *)(v21 + 2160)) {
          break;
        }
LABEL_17:
        if (++v20 == a2) {
          goto LABEL_18;
        }
      }
      uint64_t v22 = 0;
      unint64_t v23 = 0;
      while (1)
      {
        uint64_t v41 = *(void *)(v21 + 2144) + v22;
        uint64_t v42 = (1 << v20);
        if ((*(unsigned char *)(v41 + 408) & 3) != 0)
        {
          uint64_t v30 = "bad flags";
          __int16 v31 = 789;
          goto LABEL_32;
        }
        unint64_t v8 = pc_array_append((uint64_t)v8, &v41, v14, v15, v16, v17, v18, v19);
        if (!v8) {
          break;
        }
        ++v23;
        v22 += 440;
        if (v23 >= *(void *)(v21 + 2160)) {
          goto LABEL_17;
        }
      }
      uint64_t v30 = "pc_array_append";
      __int16 v31 = 793;
    }
    else
    {
      uint64_t v30 = "pc_array_init";
      __int16 v31 = 771;
    }
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", v31, 138, 0, v30, v18, v19, v41);
LABEL_33:
    uint64_t v13 = 0xFFFFFFFFLL;
LABEL_34:
    pc_array_free((uint64_t)v8);
    return v13;
  }
  uint64_t v11 = *(void *)(*(void *)a1 + 2160);
  if (v11)
  {
    unint64_t v12 = (unint64_t *)(*(void *)(*(void *)a1 + 2144) + 408);
    do
    {
      *unint64_t v12 = *v12 & 0xFFFFFFFFFFFFFFFCLL | 1;
      v12 += 55;
      --v11;
    }
    while (v11);
  }
  return 0;
}

uint64_t compare_copy_fork_5(uint64_t a1, uint64_t a2)
{
  uint64_t result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!result)
  {
    int v5 = *(_DWORD *)(a1 + 8);
    int v6 = *(_DWORD *)(a2 + 8);
    uint64_t result = (v5 - v6);
    if (v5 == v6)
    {
      if (*(void *)(*(void *)a1 + 416) < *(void *)(*(void *)a2 + 416)) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1;
      }
    }
  }
  return result;
}

uint64_t compare_copy_fork_4(uint64_t a1, uint64_t a2)
{
  uint64_t result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!result) {
    return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
  }
  return result;
}

uint64_t aggregate_copy_fork(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) |= *(_DWORD *)(a2 + 8);
  return 0;
}

uint64_t compare_copy_fork_3(unint64_t **a1, unint64_t **a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = *a2;
  unint64_t v4 = bswap64(**a1);
  unint64_t v5 = bswap64(**a2);
  if (v4 == v5
    && (unint64_t v4 = bswap64(v2[1]), v5 = bswap64(v3[1]), v4 == v5)
    && (unint64_t v4 = bswap64(v2[2]), v5 = bswap64(v3[2]), v4 == v5)
    && (unint64_t v4 = bswap64(v2[3]), v5 = bswap64(v3[3]), v4 == v5))
  {
    uint64_t v7 = v2[50] - v3[50];
    if (v7)
    {
      if (v7 < 0) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 1;
      }
    }
    else
    {
      return *((unsigned __int8 *)v2 + 432) - *((unsigned __int8 *)v3 + 432);
    }
  }
  else if (v4 < v5)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t rawimg_save_to_stream(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a2 + 2128);
  if ((v8 & 0x10) != 0)
  {
    if ((v8 & 8) != 0)
    {
      long long v14 = *(_OWORD *)(a2 + 2104);
      v50[0] = *(_OWORD *)(a2 + 2088);
      v50[1] = v14;
      uint64_t v15 = 24;
      if (!a3) {
        uint64_t v15 = 16;
      }
      uint64_t v51 = *(void *)(a2 + 2120);
      uint64_t v52 = v15;
      long long v53 = *(_OWORD *)(a2 + 2152);
      if (a1[3])
      {
        uint64_t v16 = 0;
        uint64_t v17 = v50;
        uint64_t v18 = 64;
        while (1)
        {
          uint64_t v19 = ((uint64_t (*)(void, _OWORD *, uint64_t))a1[3])(*a1, v17, v18);
          if (v19 < 1) {
            break;
          }
          uint64_t v17 = (_OWORD *)((char *)v17 + v19);
          v16 += v19;
          v18 -= v19;
          if (!v18)
          {
            if (v16 != 64) {
              break;
            }
            if (!a1[3]) {
              goto LABEL_55;
            }
            uint64_t v20 = 16 * v53;
            if (16 * (void)v53)
            {
              uint64_t v21 = 0;
              uint64_t v22 = *(void *)(a2 + 2136);
              uint64_t v23 = 16 * v53;
              while (1)
              {
                uint64_t v24 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[3])(*a1, v22, v23);
                if (v24 < 1) {
                  break;
                }
                v22 += v24;
                v21 += v24;
                v23 -= v24;
                if (!v23) {
                  goto LABEL_21;
                }
              }
              uint64_t v21 = v24;
LABEL_21:
              if (v20 != v21)
              {
LABEL_55:
                uint64_t v9 = "aaByteStreamWriteExpected";
                __int16 v10 = 893;
                goto LABEL_19;
              }
            }
            if (!*((void *)&v53 + 1)) {
              return 0;
            }
            uint64_t v26 = 0;
            __n128 v27 = 0uLL;
LABEL_24:
            uint64_t v28 = *(void *)(a2 + 2144);
            *(__n128 *)((char *)v49 + 9) = v27;
            __n128 v48 = v27;
            v49[0] = v27;
            uint64_t v29 = v28 + 440 * v26;
            __n128 v48 = *(__n128 *)(v29 + 392);
            long long v30 = *(_OWORD *)(v29 + 408);
            v49[0] = v30;
            *(void *)&v49[1] = *(void *)(v29 + 424);
            BYTE8(v49[1]) = *(unsigned char *)(v29 + 432);
            if ((v30 & 1) == 0) {
              *(void *)&v49[0] = v30 & 0xFFFFFFFFFFFFFFFBLL;
            }
            if (a1[3])
            {
              uint64_t v31 = 0;
              uint64_t v32 = &v48;
              uint64_t v33 = 41;
              while (1)
              {
                uint64_t v34 = ((uint64_t (*)(void, __n128 *, uint64_t))a1[3])(*a1, v32, v33);
                if (v34 < 1) {
                  break;
                }
                uint64_t v32 = (__n128 *)((char *)v32 + v34);
                v31 += v34;
                v33 -= v34;
                if (!v33)
                {
                  if (v31 != 41) {
                    break;
                  }
                  __n128 v27 = 0uLL;
                  if (a3 && (v49[0] & 1) != 0)
                  {
                    if (!a1[3]) {
                      goto LABEL_60;
                    }
                    uint64_t v35 = 12 * *(void *)(v28 + 440 * v26 + 56);
                    if (v35)
                    {
                      uint64_t v36 = 0;
                      uint64_t v37 = *(void *)(v28 + 440 * v26 + 384);
                      uint64_t v38 = 12 * *(void *)(v28 + 440 * v26 + 56);
                      while (1)
                      {
                        uint64_t v39 = ((uint64_t (*)(void, uint64_t, uint64_t, __n128))a1[3])(*a1, v37, v38, v27);
                        if (v39 < 1) {
                          break;
                        }
                        v37 += v39;
                        v36 += v39;
                        v38 -= v39;
                        if (!v38) {
                          goto LABEL_40;
                        }
                      }
                      uint64_t v36 = v39;
LABEL_40:
                      __n128 v27 = 0uLL;
                      if (v35 != v36)
                      {
LABEL_60:
                        __int16 v10 = 925;
                        goto LABEL_57;
                      }
                    }
                    if ((v49[0] & 4) != 0)
                    {
                      if (a1[3])
                      {
                        uint64_t v40 = 0;
                        uint64_t v41 = v28 + 440 * v26 + 64;
                        uint64_t v42 = 264;
                        while (1)
                        {
                          uint64_t v43 = ((uint64_t (*)(void, uint64_t, uint64_t, __n128))a1[3])(*a1, v41, v42, v27);
                          if (v43 < 1) {
                            break;
                          }
                          v41 += v43;
                          v40 += v43;
                          v42 -= v43;
                          if (!v42)
                          {
                            if (v40 != 264) {
                              break;
                            }
                            if (a1[3])
                            {
                              uint64_t v44 = 0;
                              uint64_t v45 = v28 + 440 * v26 + 328;
                              uint64_t v46 = 50;
                              while (1)
                              {
                                uint64_t v47 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[3])(*a1, v45, v46);
                                if (v47 < 1) {
                                  break;
                                }
                                v45 += v47;
                                v44 += v47;
                                v46 -= v47;
                                if (!v46)
                                {
                                  __n128 v27 = 0uLL;
                                  if (v44 == 50) {
                                    goto LABEL_42;
                                  }
                                  break;
                                }
                              }
                            }
                            __int16 v10 = 934;
                            goto LABEL_57;
                          }
                        }
                      }
                      __int16 v10 = 932;
                      goto LABEL_57;
                    }
                  }
LABEL_42:
                  uint64_t result = 0;
                  if ((unint64_t)++v26 < *((void *)&v53 + 1)) {
                    goto LABEL_24;
                  }
                  return result;
                }
              }
            }
            __int16 v10 = 917;
LABEL_57:
            uint64_t v9 = "aaByteStreamWriteExpected";
            goto LABEL_19;
          }
        }
      }
      uint64_t v9 = "aaByteStreamWriteExpected";
      __int16 v10 = 888;
    }
    else
    {
      uint64_t v9 = "no chunk info";
      __int16 v10 = 877;
    }
  }
  else
  {
    uint64_t v9 = "no digest info";
    __int16 v10 = 876;
  }
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_save_to_stream", v10, 138, 0, v9, a7, a8, v48.n128_i8[0]);
  return 0xFFFFFFFFLL;
}

char *rawimg_create_with_stream(void *a1, int a2)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  unint64_t v4 = (char *)calloc(1uLL, 0x878uLL);
  uint64_t v7 = v4;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  if (!v4)
  {
    int v29 = *__error();
    __n128 v27 = "aaCalloc";
    __int16 v28 = 953;
    goto LABEL_20;
  }
  if (!a1[2]) {
    goto LABEL_17;
  }
  uint64_t v8 = 0;
  uint64_t v9 = v4 + 2120;
  __int16 v10 = &v61;
  uint64_t v11 = 64;
  do
  {
    uint64_t v12 = ((uint64_t (*)(void, long long *, uint64_t))a1[2])(*a1, v10, v11);
    if (v12 < 0) {
      goto LABEL_17;
    }
    if (!v12) {
      break;
    }
    __int16 v10 = (long long *)((char *)v10 + v12);
    v8 += v12;
    v11 -= v12;
  }
  while (v11);
  if (v8 == 64)
  {
    long long v13 = v62;
    *(_OWORD *)(v7 + 2088) = v61;
    *(_OWORD *)(v7 + 2104) = v13;
    long long v14 = v64;
    *uint64_t v9 = v63;
    *(_OWORD *)(v7 + 2152) = v14;
    *((void *)v7 + 267) = pc_array_init(16, v14);
    uint64_t v15 = pc_array_init(440, *((void *)v7 + 270));
    *((void *)v7 + 268) = v15;
    uint64_t v21 = *((void *)v7 + 267);
    if (v21 && v15)
    {
      uint64_t v22 = *((void *)v7 + 269);
      *(void *)(v21 - 64) = v22;
      *(v15 - 8) = *((void *)v7 + 270);
      if (!a1[2]) {
        goto LABEL_62;
      }
      uint64_t v23 = 16 * v22;
      if (!(16 * v22)) {
        goto LABEL_25;
      }
      uint64_t v24 = 0;
      uint64_t v25 = 16 * v22;
      while (1)
      {
        uint64_t v26 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v21, v25);
        if (v26 < 0) {
          break;
        }
        if (v26)
        {
          v21 += v26;
          v24 += v26;
          v25 -= v26;
          if (v25) {
            continue;
          }
        }
        goto LABEL_24;
      }
      uint64_t v24 = v26;
LABEL_24:
      if (v23 == v24)
      {
LABEL_25:
        if (!*((void *)&v64 + 1))
        {
LABEL_60:
          if ((rawimg_verify(v7, v16, v17, v18, v19, v20, v5, v6) & 0x80000000) == 0) {
            return v7;
          }
          __n128 v27 = "rawimg_verify";
          __int16 v28 = 1023;
          goto LABEL_18;
        }
        unint64_t v31 = 0;
        long long v32 = 0uLL;
        while (2)
        {
          uint64_t v33 = *((void *)v7 + 268);
          *(_OWORD *)&v60[9] = v32;
          long long v59 = v32;
          *(_OWORD *)size_t v60 = v32;
          if (a1[2])
          {
            uint64_t v34 = 0;
            uint64_t v35 = &v59;
            uint64_t v36 = 41;
            do
            {
              uint64_t v37 = ((uint64_t (*)(void, long long *, uint64_t))a1[2])(*a1, v35, v36);
              if (v37 < 0) {
                goto LABEL_63;
              }
              if (!v37) {
                break;
              }
              uint64_t v35 = (long long *)((char *)v35 + v37);
              v34 += v37;
              v36 -= v37;
            }
            while (v36);
            if (v34 != 41) {
              break;
            }
            uint64_t v38 = v33 + 440 * v31;
            *(void *)(v38 + 432) = 0;
            *(_OWORD *)(v38 + 400) = 0u;
            *(_OWORD *)(v38 + 416) = 0u;
            *(_OWORD *)(v38 + 368) = 0u;
            *(_OWORD *)(v38 + 384) = 0u;
            *(_OWORD *)(v38 + 336) = 0u;
            *(_OWORD *)(v38 + 352) = 0u;
            *(_OWORD *)(v38 + 304) = 0u;
            *(_OWORD *)(v38 + 320) = 0u;
            *(_OWORD *)(v38 + 272) = 0u;
            *(_OWORD *)(v38 + 288) = 0u;
            *(_OWORD *)(v38 + 240) = 0u;
            *(_OWORD *)(v38 + 256) = 0u;
            *(_OWORD *)(v38 + 208) = 0u;
            *(_OWORD *)(v38 + 224) = 0u;
            *(_OWORD *)(v38 + 176) = 0u;
            *(_OWORD *)(v38 + 192) = 0u;
            *(_OWORD *)(v38 + 144) = 0u;
            *(_OWORD *)(v38 + 160) = 0u;
            *(_OWORD *)(v38 + 112) = 0u;
            *(_OWORD *)(v38 + 128) = 0u;
            *(_OWORD *)(v38 + 80) = 0u;
            *(_OWORD *)(v38 + 96) = 0u;
            *(_OWORD *)(v38 + 48) = 0u;
            *(_OWORD *)(v38 + 64) = 0u;
            *(_OWORD *)(v38 + 16) = 0u;
            *(_OWORD *)(v38 + 32) = 0u;
            *(_OWORD *)uint64_t v38 = 0u;
            uint64_t v39 = v59;
            *(_OWORD *)(v38 + 392) = v59;
            uint64_t v40 = (unsigned char *)(v38 + 408);
            char v41 = v60[0];
            *(_OWORD *)(v38 + 408) = *(_OWORD *)v60;
            *(void *)(v38 + 424) = *(void *)&v60[16];
            *(unsigned char *)(v38 + 432) = v60[24];
            if (a2 && (v41 & 1) != 0)
            {
              size_t v42 = (unint64_t)(v39 + 0xFFFF) >> 16;
              uint64_t v43 = v33 + 440 * v31;
              *(void *)(v43 + 56) = v42;
              uint64_t v44 = (void *)(v43 + 56);
              if ((unint64_t)(v39 + 0xFFFF) >= 0x2AAAAAAAB0000)
              {
                *__error() = 12;
                *(void *)(v33 + 440 * v31 + 384) = 0;
              }
              else
              {
                uint64_t v45 = (char *)calloc(v42, 0xCuLL);
                *(void *)(v33 + 440 * v31 + 384) = v45;
                if (v45)
                {
                  if (!a1[2]) {
                    goto LABEL_66;
                  }
                  uint64_t v46 = 12 * *v44;
                  if (v46)
                  {
                    uint64_t v47 = v45;
                    uint64_t v48 = 0;
                    uint64_t v49 = 12 * *v44;
                    while (1)
                    {
                      uint64_t v50 = ((uint64_t (*)(void, char *, uint64_t))a1[2])(*a1, v47, v49);
                      if (v50 < 0) {
                        break;
                      }
                      if (v50)
                      {
                        v47 += v50;
                        v48 += v50;
                        v49 -= v50;
                        if (v49) {
                          continue;
                        }
                      }
                      goto LABEL_45;
                    }
                    uint64_t v48 = v50;
LABEL_45:
                    if (v46 != v48)
                    {
LABEL_66:
                      __n128 v27 = "aaByteStreamReadExpected";
                      __int16 v28 = 1008;
                      goto LABEL_18;
                    }
                  }
                  if ((*v40 & 4) != 0)
                  {
                    if (a1[2])
                    {
                      uint64_t v51 = 0;
                      uint64_t v52 = v33 + 440 * v31 + 64;
                      uint64_t v53 = 264;
                      while (1)
                      {
                        uint64_t v54 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v52, v53);
                        if (v54 < 0) {
                          break;
                        }
                        if (v54)
                        {
                          v52 += v54;
                          v51 += v54;
                          v53 -= v54;
                          if (v53) {
                            continue;
                          }
                        }
                        if (v51 != 264) {
                          break;
                        }
                        if (a1[2])
                        {
                          uint64_t v55 = 0;
                          uint64_t v56 = v33 + 440 * v31 + 328;
                          uint64_t v57 = 50;
                          while (1)
                          {
                            uint64_t v58 = ((uint64_t (*)(void, uint64_t, uint64_t))a1[2])(*a1, v56, v57);
                            if (v58 < 0) {
                              break;
                            }
                            if (v58)
                            {
                              v56 += v58;
                              v55 += v58;
                              v57 -= v58;
                              if (v57) {
                                continue;
                              }
                            }
                            if (v55 != 50) {
                              break;
                            }
                            goto LABEL_59;
                          }
                        }
                        __n128 v27 = "aaByteStreamReadExpected";
                        __int16 v28 = 1017;
                        goto LABEL_18;
                      }
                    }
                    __n128 v27 = "aaByteStreamReadExpected";
                    __int16 v28 = 1015;
                    goto LABEL_18;
                  }
                  goto LABEL_59;
                }
              }
              int v29 = *__error();
              __n128 v27 = "aaCalloc";
              __int16 v28 = 1003;
              goto LABEL_20;
            }
LABEL_59:
            ++v31;
            long long v32 = 0uLL;
            if (v31 < *((void *)&v64 + 1)) {
              continue;
            }
            goto LABEL_60;
          }
          break;
        }
LABEL_63:
        __n128 v27 = "aaByteStreamReadExpected";
        __int16 v28 = 986;
      }
      else
      {
LABEL_62:
        __n128 v27 = "aaByteStreamReadExpected";
        __int16 v28 = 976;
      }
    }
    else
    {
      __n128 v27 = "pc_array_init";
      __int16 v28 = 969;
    }
  }
  else
  {
LABEL_17:
    __n128 v27 = "aaByteStreamReadExpected";
    __int16 v28 = 957;
  }
LABEL_18:
  int v29 = 0;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_stream", v28, 138, v29, v27, v5, v6, v59);
  rawimg_destroy((uint64_t *)v7);
  return 0;
}

uint64_t compare_forks_by_extent(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 416);
  unint64_t v3 = *(void *)(a2 + 416);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aggregate_identical_forks(const void *a1, const void *a2)
{
  if (!memcmp(a1, a2, 0x1B8uLL)) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t compare_forks_by_position(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 2136) + 16 * *(void *)(a2 + 416)) < *(void *)(*(void *)(a1 + 2136)
                                                                                      + 16 * *(void *)(a3 + 416)))
    return 0xFFFFFFFFLL;
  else {
    return 1;
  }
}

uint64_t pc_array_compare(uint64_t (*a1)(void, void), void *a2, void *a3)
{
  return a1(*a2, *a3);
}

void *pc_array_init(uint64_t a1, uint64_t a2)
{
  BOOL v4 = malloc(a2 * a1 + 64);
  if (v4)
  {
    void *v4 = 0;
    v4[1] = a2;
    BOOL v5 = v4 + 8;
    v4[2] = a1;
  }
  else
  {
    uint64_t v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_init", 26, 139, *v6, "malloc", v7, v8, v10);
    return 0;
  }
  return v5;
}

void *pc_array_init(uint64_t a1)
{
  return pc_array_init(a1, 8);
}

void pc_array_free(uint64_t a1)
{
  if (a1) {
    free((void *)(a1 - 64));
  }
}

char *pc_array_compact(uint64_t a1)
{
  unint64_t v3 = *(void *)(a1 - 64);
  unint64_t v4 = *(void *)(a1 - 56);
  unint64_t v2 = (char *)(a1 - 64);
  if (v4 <= v3) {
    return v2 + 64;
  }
  *(void *)(a1 - 56) = v3;
  unint64_t v2 = (char *)reallocf(v2, *(void *)(a1 - 48) * v3 + 64);
  if (v2) {
    return v2 + 64;
  }
  uint64_t v6 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_compact", 56, 139, *v6, "reallocf", v7, v8, vars0);
  return 0;
}

void *pc_array_append(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = *(void *)(a1 - 64);
  unint64_t v10 = *(void *)(a1 - 56);
  uint64_t v11 = (void *)(a1 - 64);
  if (v10 > v9) {
    goto LABEL_7;
  }
  uint64_t v12 = 2 * v10;
  BOOL v13 = v10 == 0;
  unint64_t v14 = 16;
  if (!v13) {
    unint64_t v14 = v12;
  }
  *(void *)(a1 - 56) = v14;
  if (v14 <= v9)
  {
    uint64_t v17 = "too many elements";
    __int16 v18 = 70;
    int v19 = 0;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_append", v18, 139, v19, v17, a7, a8, v21);
    return 0;
  }
  uint64_t v15 = reallocf((void *)(a1 - 64), *(void *)(a1 - 48) * v14 + 64);
  if (!v15)
  {
    int v19 = *__error();
    uint64_t v17 = "reallocf";
    __int16 v18 = 72;
    goto LABEL_10;
  }
  uint64_t v11 = v15;
  unint64_t v9 = *v15;
LABEL_7:
  uint64_t v16 = v11 + 8;
  memcpy((char *)v11 + v11[2] * v9 + 64, __src, v11[2]);
  ++*v11;
  return v16;
}

void pc_array_sort(void *a1, int (__cdecl *__compar)(const void *, const void *))
{
}

void *pc_array_indirect_sort(uint64_t a1, void *a2)
{
  uint64_t v3 = a1;
  size_t v4 = *(void *)(a1 - 64);
  BOOL v5 = malloc(8 * v4);
  uint64_t v6 = v5;
  if (v5)
  {
    if (v4)
    {
      uint64_t v7 = *(void *)(v3 - 48);
      uint64_t v8 = v5;
      size_t v9 = v4;
      do
      {
        *v8++ = v3;
        v3 += v7;
        --v9;
      }
      while (v9);
    }
    qsort_r(v5, v4, 8uLL, a2, (int (__cdecl *)(void *, const void *, const void *))pc_array_compare);
  }
  else
  {
    unint64_t v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_indirect_sort", 95, 139, *v10, "malloc", v11, v12, v14);
  }
  return v6;
}

uint64_t pc_array_aggregate(char *a1, unsigned int (*a2)(char *, char *), uint64_t (*a3)(char *, char *))
{
  if (*((void *)a1 - 8) < 2uLL) {
    return 0;
  }
  uint64_t v7 = &a1[*((void *)a1 - 6)];
  unint64_t v8 = 1;
  uint64_t v9 = 1;
  unint64_t v10 = a1;
  while (1)
  {
    if (a2(v10, v7))
    {
      size_t v11 = *((void *)a1 - 6);
      v10 += v11;
      if (v10 < v7) {
        memcpy(v10, v7, v11);
      }
      ++v9;
      goto LABEL_9;
    }
    if ((a3(v10, v7) & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
LABEL_9:
    ++v8;
    v7 += *((void *)a1 - 6);
    if (v8 >= *((void *)a1 - 8))
    {
      uint64_t result = 0;
      *((void *)a1 - 8) = v9;
      return result;
    }
  }
}

char *PCompressGetEncoderDescription(unsigned int a1)
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return off_2642289E0[a1];
  }
}

uint64_t PCompressGetEncoderDecoder(uint64_t result)
{
  if (result >= 7) {
    return 0xFFFFFFFFLL;
  }
  else {
    return result;
  }
}

char *PCompressGetDecoderDescription(unsigned int a1)
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return off_264228A18[a1];
  }
}

void *AEADecryptAsyncStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  unsigned int DefaultNThreads = a6;
  if (!a6) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v12 = malloc(0x4A0uLL);
  uint64_t v13 = (uint64_t)v12;
  if (!v12)
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 884;
    goto LABEL_8;
  }
  memset_s(v12, 0x4A0uLL, 0, 0x4A0uLL);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 56), 0))
  {
    uint64_t v16 = "pthread_mutex_init";
    __int16 v17 = 885;
LABEL_6:
    int v18 = 0;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"AEADecryptAsyncStreamOpen", v17, 114, v18, v16, v14, v15, v29);
    decryptAsyncClose(v13);
    AAAsyncByteStreamClose(0);
    return 0;
  }
  *(void *)uint64_t v13 = a1;
  *(void *)(v13 + 8) = a2;
  *(void *)(v13 + 16) = a3;
  *(void *)(v13 + 24) = a4;
  *(void *)(v13 + 1128) = -1;
  *(void *)(v13 + 1144) = -1;
  *(void *)(v13 + 1152) = -1;
  *(_DWORD *)(v13 + 32) = a5 >> 62;
  *(void *)(v13 + 40) = a5;
  *(_DWORD *)(v13 + 1160) = DefaultNThreads;
  uint64_t v20 = calloc(DefaultNThreads, 8uLL);
  *(void *)(v13 + 1168) = v20;
  if (!v20)
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 899;
    goto LABEL_8;
  }
  if (*(_DWORD *)(v13 + 1160))
  {
    unint64_t v21 = 0;
    while (1)
    {
      uint64_t v22 = (uint64_t *)malloc(0x468uLL);
      uint64_t v23 = v22;
      if (v22)
      {
        memset_s(v22, 0x468uLL, 0, 0x468uLL);
        uint64_t *v23 = v13;
      }
      else
      {
        uint64_t v24 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"workerAlloc", 129, 114, *v24, "malloc", v25, v26, v29);
      }
      *(void *)(*(void *)(v13 + 1168) + 8 * v21) = v23;
      uint64_t v27 = *(void *)(v13 + 1168);
      if (!*(void *)(v27 + 8 * v21)) {
        break;
      }
      ++v21;
      uint64_t v20 = (void *)*(unsigned int *)(v13 + 1160);
      if (v21 >= (unint64_t)v20) {
        goto LABEL_20;
      }
    }
    uint64_t v16 = "Worker alloc";
    __int16 v17 = 903;
    goto LABEL_6;
  }
  uint64_t v27 = (uint64_t)v20;
  LODWORD(v20) = 0;
LABEL_20:
  __int16 v28 = ThreadPoolCreate(v20, v27, (uint64_t)workerProc);
  *(void *)(v13 + 1176) = v28;
  if (!v28)
  {
    uint64_t v16 = "creating worker pool";
    __int16 v17 = 906;
    goto LABEL_6;
  }
  *(_DWORD *)(v13 + 52) = 0;
  if (pushRange((void *)v13, 12))
  {
    uint64_t v16 = "add range";
    __int16 v17 = 910;
    goto LABEL_6;
  }
  *(void *)(v13 + 1128) = 0;
  uint64_t result = aaAsyncByteStreamAlloc(v13, (uint64_t)decryptAsyncClose, ~(a5 >> 55) & 4, 20.0, 1.0);
  if (!result)
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 921;
    goto LABEL_8;
  }
  result[2] = decryptAsyncGetRange;
  result[3] = decryptAsyncProcess;
  result[4] = decryptAsyncCancel;
  result[5] = decryptAsyncIsCancelled;
  return result;
}

uint64_t workerProc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)result;
  unint64_t v8 = *(void *)(result + 8);
  if (v8 >= *(void *)(*(void *)result + 1120))
  {
    uint64_t v26 = "Invalid range index";
    __int16 v27 = 183;
  }
  else
  {
    uint64_t v10 = *(void *)(v9 + 1136) + 32 * v8;
    int v13 = *(_DWORD *)(v10 + 28);
    uint64_t v12 = (_DWORD *)(v10 + 28);
    int v11 = v13;
    unint64_t v14 = *(v12 - 1);
    if (*(void *)(v9 + 1096) <= v14)
    {
      uint64_t v26 = "Invalid segment index";
      __int16 v27 = 191;
    }
    else
    {
      size_t v15 = *(void *)(v9 + 784);
      if (v15 >= 0x101) {
        goto LABEL_62;
      }
      uint64_t v16 = result;
      __int16 v17 = (unsigned int *)(*(void *)(v9 + 1104) + *(void *)(v9 + 800) * v14);
      unint64_t v50 = *(unsigned int *)(v9 + 152) * (unint64_t)v14;
      uint64_t v19 = *v17;
      uint64_t v18 = v17[1];
      uint64_t v20 = v17 + 2;
      unint64_t v21 = (char *)(result + 612);
      memcpy((void *)(result + 612), v17 + 2, v15);
      *(_DWORD *)(v16 + 608) = v15;
      memset_s(&v21[v15], 256 - v15, 0, 256 - v15);
      uint64_t result = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(v9 + 160));
      if (v19 == v18) {
        compression_algorithm v22 = 0;
      }
      else {
        compression_algorithm v22 = result;
      }
      int v23 = *(_DWORD *)(v16 + 16);
      if (v23 != 1)
      {
        if (v23)
        {
          uint64_t v26 = "Invalid op";
          __int16 v27 = 307;
        }
        else if (v11 == 3)
        {
          uint64_t v24 = *(uint64_t (**)(void, uint64_t, unint64_t, void, char *, void))(v9 + 16);
          if (!v24)
          {
LABEL_29:
            uint64_t result = 0;
            *uint64_t v12 = 4;
            return result;
          }
          int v25 = v24(*(void *)v9, v19, v50, *(unsigned int *)(v9 + 148), v21, *(unsigned int *)(v16 + 608));
          if ((v25 & 0x80000000) == 0)
          {
            if (v25)
            {
              *uint64_t v12 = 6;
              atomic_fetch_add((atomic_uint *volatile)(v9 + 120), 1u);
              if (*(_DWORD *)(v9 + 32) >= 3u) {
                fprintf((FILE *)*MEMORY[0x263EF8348], "Segment %u skipped, offset=%jd, payload=%u, raw=%u\n");
              }
              return 0;
            }
            goto LABEL_29;
          }
          uint64_t v26 = "Client selection callback reported an error";
          __int16 v27 = 220;
        }
        else
        {
          uint64_t v26 = "Invalid segment state";
          __int16 v27 = 207;
        }
        goto LABEL_48;
      }
      if (v11 == 2)
      {
        if (*(void *)(v16 + 32) == v18)
        {
          compression_algorithm algorithm = v22;
          uint64_t v28 = *(unsigned int *)(v9 + 324);
          if (v28 >= 0x101) {
            goto LABEL_62;
          }
          memcpy((void *)(v16 + 352), (char *)v20 + *(void *)(v9 + 784), *(unsigned int *)(v9 + 324));
          *(_DWORD *)(v16 + 348) = v28;
          memset_s((void *)(v16 + 352 + v28), 256 - v28, 0, 256 - v28);
          unsigned int v29 = *(_DWORD *)(v9 + 156);
          int v52 = 0;
          memset(v51, 0, sizeof(v51));
          memset(&__s[8], 0, 252);
          *(_WORD *)&__s[8] = 19267;
          *(void *)uint64_t __s = 0x5F41454100000006;
          memset(v53, 0, 260);
          memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
          unsigned int v49 = v29;
          unsigned int v30 = v14 / v29;
          *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v30;
          *(_DWORD *)uint64_t __s = 10;
          memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
          unint64_t v31 = *(uint64_t (**)(_OWORD *, void))(v9 + 384);
          if (v31 && *(_DWORD *)(v9 + 520))
          {
            int v32 = v31(v51, *(unsigned int *)(v9 + 312));
            memset_s(__s, 0x104uLL, 0, 0x104uLL);
            int v33 = 0;
            if ((v32 & 0x80000000) == 0) {
              goto LABEL_33;
            }
          }
          else
          {
            memset_s(__s, 0x104uLL, 0, 0x104uLL);
          }
          int v33 = 1;
LABEL_33:
          int v48 = v33;
          memset((char *)v53 + 8, 0, 224);
          memset((char *)&v53[14] + 8, 0, 28);
          WORD4(v53[0]) = 19283;
          *(void *)&v53[0] = 0x5F41454100000006;
          uint64_t result = memset_s((char *)v53 + 10, 0xFAuLL, 0, 0xFAuLL);
          uint64_t v34 = LODWORD(v53[0]);
          if (LODWORD(v53[0]) < 0xFD)
          {
            *(_DWORD *)((char *)v53 + LODWORD(v53[0]) + 4) = v14 - v30 * v49;
            LODWORD(v53[0]) = v34 + 4;
            memset_s((char *)v53 + v34 + 8, 252 - v34, 0, 252 - v34);
            memset(__s, 0, sizeof(__s));
            uint64_t v35 = *(uint64_t (**)(uint64_t, void, _OWORD *, _OWORD *, unsigned char *))(v9 + 384);
            if (v35 && LODWORD(v51[0]))
            {
              int v36 = v35(v16 + 88, *(unsigned int *)(v9 + 316), v51, v53, __s);
              memset_s(v53, 0x104uLL, 0, 0x104uLL);
              if ((v36 & 0x80000000) == 0)
              {
                memset_s(v51, 0x104uLL, 0, 0x104uLL);
                if (!v48)
                {
                  uint64_t v37 = *(uint64_t (**)(void, void))(v9 + 408);
                  if (v37
                    && *(_DWORD *)(v16 + 348) == *(_DWORD *)(v9 + 324)
                    && (uint64_t v38 = (void **)(v16 + 40),
                        (v37(*(void *)(v16 + 40), *(void *)(v16 + 32)) & 0x80000000) == 0))
                  {
                    uint64_t v40 = algorithm;
                    if (algorithm)
                    {
                      uint64_t v38 = (void **)(v16 + 64);
                      size_t v41 = compression_decode_buffer(*(uint8_t **)(v16 + 64), *(void *)(v16 + 48), *(const uint8_t **)(v16 + 40), *(void *)(v16 + 32), *(void **)(v16 + 80), algorithm);
                      *(void *)(v16 + 56) = v41;
                    }
                    else
                    {
                      size_t v41 = *(void *)(v16 + 32);
                    }
                    if (v41 == v19
                      && (uint64_t v43 = (uint64_t)*v38,
                          (aeaChecksum(v16 + 868, *(_DWORD *)(v9 + 148), *v38, v41, v39, v40, a7, a8) & 0x80000000) == 0)
                      && (size_t v44 = *(unsigned int *)(v16 + 868), *(void *)(v9 + 784) == v44)
                      && v44 == *(_DWORD *)(v16 + 608)
                      && !memcmp((const void *)(v16 + 872), v21, v44))
                    {
                      uint64_t v45 = *(uint64_t (**)(void, size_t, unint64_t, uint64_t))(v9 + 24);
                      if (!v45 || (v45(*(void *)v9, v41, v50, v43) & 0x80000000) == 0)
                      {
                        *uint64_t v12 = 5;
                        atomic_fetch_add((atomic_uint *volatile)(v9 + 120), 1u);
                        if (*(_DWORD *)(v9 + 32) >= 3u) {
                          fprintf((FILE *)*MEMORY[0x263EF8348], "Segment %u processed, offset=%jd, payload=%u, raw=%u\n");
                        }
                        return 0;
                      }
                      uint64_t v26 = "Client processing callback reported an error";
                      __int16 v27 = 297;
                    }
                    else
                    {
                      uint64_t v26 = "Segment data failed verification";
                      __int16 v27 = 285;
                    }
                  }
                  else
                  {
                    uint64_t v26 = "Segment decryption";
                    __int16 v27 = 259;
                  }
                  goto LABEL_48;
                }
                goto LABEL_45;
              }
            }
            else
            {
              memset_s(v53, 0x104uLL, 0, 0x104uLL);
            }
            memset_s(v51, 0x104uLL, 0, 0x104uLL);
LABEL_45:
            uint64_t v26 = "derive segment encryption key";
            __int16 v27 = 252;
            goto LABEL_48;
          }
LABEL_62:
          __break(1u);
          return result;
        }
        uint64_t v26 = "Segment payload size mismatch";
        __int16 v27 = 242;
      }
      else
      {
        uint64_t v26 = "Invalid segment state";
        __int16 v27 = 239;
      }
    }
  }
LABEL_48:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"workerProc", v27, 114, 0, v26, a7, a8, v46);
  int v42 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(v9 + 48), (unsigned int *)&v42, 1u);
  return 0xFFFFFFFFLL;
}

uint64_t pushRange(void *a1, uint64_t a2)
{
  unint64_t v4 = a1[140];
  unint64_t v5 = a1[139];
  if (v4 >= v5)
  {
    uint64_t v6 = 2 * v5;
    BOOL v7 = v5 == 0;
    uint64_t v8 = 32;
    if (!v7) {
      uint64_t v8 = v6;
    }
    a1[139] = v8;
    if ((unint64_t)(32 * v8) >= 0x2000000001)
    {
      *__error() = 12;
LABEL_13:
      a1[142] = 0;
      unint64_t v14 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"pushRange", 346, 114, *v14, "malloc", v15, v16, v18);
      a1[139] = 0;
      a1[140] = 0;
      return -1;
    }
    uint64_t v9 = (void *)a1[142];
    uint64_t v10 = realloc(v9, 32 * v8);
    if (!v10)
    {
      free(v9);
      goto LABEL_13;
    }
    a1[142] = v10;
    unint64_t v4 = a1[140];
  }
  uint64_t v11 = a1[142];
  if (v4) {
    uint64_t v12 = *(void *)(v11 + 32 * v4 - 32) + *(void *)(v11 + 32 * v4 - 24);
  }
  else {
    uint64_t v12 = 0;
  }
  a1[140] = v4 + 1;
  int v13 = (void *)(v11 + 32 * v4);
  memset_s(v13, 0x20uLL, 0, 0x20uLL);
  *int v13 = a2;
  v13[1] = v12;
  v13[2] = -1;
  *((_DWORD *)v13 + 6) = -1;
  return v4;
}

uint64_t decryptAsyncClose(uint64_t a1)
{
  unsigned int v2 = atomic_load((unsigned int *)(a1 + 48));
  BOOL v3 = v2 == 0;
  if ((ThreadPoolDestroy(*(void *)(a1 + 1176)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncClose", 850, 114, 0, "ThreadPoolDestroy", v4, v5, v18);
    BOOL v3 = 0;
  }
  uint64_t v6 = *(void **)(a1 + 1168);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)(a1 + 1160);
    if (v7)
    {
      for (unint64_t i = 0; i < v7; ++i)
      {
        uint64_t v9 = *(void *)(*(void *)(a1 + 1168) + 8 * i);
        if (v9)
        {
          uint64_t v10 = *(void **)(v9 + 40);
          if (v10) {
            memset_s(*(void **)(v9 + 40), *(void *)(v9 + 24), 0, *(void *)(v9 + 24));
          }
          free(v10);
          uint64_t v11 = *(void **)(v9 + 64);
          if (v11) {
            memset_s(*(void **)(v9 + 64), *(void *)(v9 + 48), 0, *(void *)(v9 + 48));
          }
          free(v11);
          uint64_t v12 = *(void **)(v9 + 80);
          if (v12) {
            memset_s(*(void **)(v9 + 80), *(void *)(v9 + 72), 0, *(void *)(v9 + 72));
          }
          free(v12);
          memset_s((void *)v9, 0x468uLL, 0, 0x468uLL);
          free((void *)v9);
          unint64_t v7 = *(unsigned int *)(a1 + 1160);
        }
      }
      uint64_t v6 = *(void **)(a1 + 1168);
    }
    free(v6);
  }
  int v13 = *(void **)(a1 + 808);
  if (v13) {
    memset_s(*(void **)(a1 + 808), *(void *)(a1 + 792), 0, *(void *)(a1 + 792));
  }
  free(v13);
  unint64_t v14 = *(void **)(a1 + 1136);
  if (v14) {
    memset_s(*(void **)(a1 + 1136), 32 * *(void *)(a1 + 1112), 0, 32 * *(void *)(a1 + 1112));
  }
  free(v14);
  uint64_t v15 = *(void **)(a1 + 1104);
  if (v15)
  {
    rsize_t v16 = *(void *)(a1 + 800) * *(void *)(a1 + 1088);
    memset_s(*(void **)(a1 + 1104), v16, 0, v16);
  }
  free(v15);
  AEAContextDestroy(*(AEAContext *)(a1 + 128));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
  memset_s((void *)a1, 0x4A0uLL, 0, 0x4A0uLL);
  free((void *)a1);
  return (v3 - 1);
}

uint64_t decryptAsyncGetRange(uint64_t a1, void *a2, void *a3)
{
  if (atomic_load((unsigned int *)(a1 + 48))) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v7 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    uint64_t v10 = "lockState";
    __int16 v11 = 743;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncGetRange", v11, 114, 0, v10, v8, v9, v22);
    int v20 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 48), (unsigned int *)&v20, 1u);
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 52) == 4)
  {
    uint64_t v12 = *(void *)(a1 + 1128);
    if (v12 < 0)
    {
LABEL_9:
      uint64_t v15 = atomic_load((unsigned int *)(a1 + 120));
      if (*(void *)(a1 + 1096) == v15) {
        *(_DWORD *)(a1 + 52) = 5;
      }
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 1136);
      while (1)
      {
        uint64_t v14 = v13 + 32 * v12;
        if (*(_DWORD *)(v14 + 28) == 4) {
          break;
        }
        uint64_t v12 = *(void *)(v14 + 16);
        *(void *)(a1 + 1128) = v12;
        if (v12 < 0) {
          goto LABEL_9;
        }
      }
    }
  }
  uint64_t v16 = *(void *)(a1 + 1128);
  if (v16 < 0)
  {
    if (*(_DWORD *)(a1 + 52) == 5)
    {
      *a2 = 0;
      *a3 = 0;
      uint64_t v19 = 1;
    }
    else
    {
      uint64_t v19 = 0;
    }
  }
  else
  {
    uint64_t v17 = *(void *)(a1 + 1136) + 32 * v16;
    uint64_t v18 = *(void *)(v17 + 8);
    *a2 = *(void *)v17;
    *a3 = v18;
    uint64_t v19 = 1;
    *(_DWORD *)(v17 + 28) = 1;
    *(void *)(a1 + 1128) = *(void *)(v17 + 16);
  }
  if (pthread_mutex_unlock(v7))
  {
    uint64_t v10 = "unlockState";
    __int16 v11 = 782;
    goto LABEL_18;
  }
  return v19;
}

uint64_t decryptAsyncProcess(uint64_t a1, uint64_t *a2, size_t a3, uint64_t a4)
{
  if (atomic_load((unsigned int *)(a1 + 48))) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    uint64_t v12 = "lockState";
    __int16 v13 = 796;
    goto LABEL_21;
  }
  __key[0] = 0;
  long long v26 = 0u;
  __key[1] = a4;
  uint64_t v14 = bsearch(__key, *(const void **)(a1 + 1136), *(void *)(a1 + 1120), 0x20uLL, (int (__cdecl *)(const void *, const void *))cmpRange);
  if (!v14)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", 800, 114, 0, "Invalid offset received: %jd\n", v18, v19, a4);
LABEL_18:
    int v21 = 1;
    goto LABEL_19;
  }
  if (v14[7] == 1)
  {
    v14[7] = 2;
    if (*(void *)v14 == a3)
    {
      switch(*(_DWORD *)(a1 + 52))
      {
        case 0:
          int v20 = processMagic(a1, a2, a3, v15, v16, v17, v18, v19);
          goto LABEL_15;
        case 1:
          int v20 = processPrologue((void *)a1, a2, a3);
          goto LABEL_15;
        case 2:
          int v20 = processClusterHeader(a1, a2, a3, v15, v16, v17, v18, v19);
          goto LABEL_15;
        case 3:
          int v20 = processPadding(a1, (uint64_t)a2, a3);
          goto LABEL_15;
        case 4:
          int v20 = processSegment(a1, ((uint64_t)v14 - *(void *)(a1 + 1136)) >> 5, a2, a3, v16, v17, v18, v19);
LABEL_15:
          if ((v20 & 0x80000000) == 0) {
            goto LABEL_16;
          }
          goto LABEL_17;
        default:
LABEL_17:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", 822, 114, 0, "Invalid archive", v18, v19, v24);
          break;
      }
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", 808, 114, 0, "Invalid size received: %zu\n", v18, v19, a3);
    }
    goto LABEL_18;
  }
LABEL_16:
  int v21 = 0;
LABEL_19:
  if (!pthread_mutex_unlock(v9))
  {
    if (!v21) {
      return 0;
    }
    goto LABEL_22;
  }
  uint64_t v12 = "unlockState";
  __int16 v13 = 825;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"decryptAsyncProcess", v13, 114, 0, v12, v10, v11, v24);
LABEL_22:
  int v22 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 48), (unsigned int *)&v22, 1u);
  return 0xFFFFFFFFLL;
}

void decryptAsyncCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 48), (unsigned int *)&v1, 1u);
}

uint64_t decryptAsyncIsCancelled(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 48));
}

uint64_t processMagic(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Magic received: %zu B\n", a3);
  }
  if (a3 == 12)
  {
    uint64_t v20 = 0;
    memset(v19, 0, sizeof(v19));
    memset(v15, 0, sizeof(v15));
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t v18 = 0;
    uint64_t v21 = *a2;
    int v22 = *((_DWORD *)a2 + 2);
    if ((aeaContainerParamsInitWithMagic((int *)v19, &v21, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0
      && (aeaCryptoInit((char *)(a1 + 312), (unsigned int *)v19) & 0x80000000) == 0
      && (aeaContainerOffsetsInit((uint64_t)v15, (unsigned int *)v19, (unsigned int *)(a1 + 312)) & 0x80000000) == 0)
    {
      uint64_t result = 0;
      **(void **)(a1 + 1136) = v16;
      *(_DWORD *)(a1 + 52) = 1;
      *(void *)(a1 + 1128) = 0;
      return result;
    }
    uint64_t v12 = "Invalid archive";
    __int16 v13 = 494;
  }
  else
  {
    uint64_t v12 = "Invalid magic";
    __int16 v13 = 487;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processMagic", v13, 114, 0, v12, a7, a8, v14);
  return 0xFFFFFFFFLL;
}

uint64_t processPrologue(void *a1, _DWORD *a2, size_t a3)
{
  if (*((_DWORD *)a1 + 8) >= 3u) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Prologue received: %zu B\n", a3);
  }
  uint64_t v6 = aeaContextCreateWithPrologue(a2, a3);
  a1[16] = v6;
  if (!v6)
  {
    uint64_t v12 = "creating encryption context";
    __int16 v13 = 514;
    goto LABEL_29;
  }
  uint64_t v9 = v6;
  uint64_t v10 = (uint64_t (*)(void, uint64_t))a1[1];
  if (v10)
  {
    if ((v10(*a1, v6) & 0x80000000) != 0)
    {
      uint64_t v12 = "Context setup callback returned an error";
      __int16 v13 = 518;
      goto LABEL_29;
    }
    uint64_t v9 = a1[16];
  }
  if ((aeaContextUnlock(v9, (uint64_t)(a1 + 17), (_DWORD *)a1 + 130, 0, 1, 0) & 0x80000000) != 0)
  {
    uint64_t v12 = "Archive unlock";
    __int16 v13 = 521;
    goto LABEL_29;
  }
  unsigned int v11 = aeaChecksumSize(*((_DWORD *)a1 + 37));
  a1[98] = v11;
  if (v11 <= 0x1F)
  {
    uint64_t v12 = "Invalid checksum mode for decrypt to file, at least 256 bits are required";
    __int16 v13 = 525;
LABEL_29:
    int v25 = 0;
LABEL_30:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processPrologue", v13, 114, v25, v12, v7, v8, v35);
    return 0xFFFFFFFFLL;
  }
  uint64_t result = aeaContainerOffsetsInit((uint64_t)(a1 + 26), (unsigned int *)a1 + 34, (unsigned int *)a1 + 78);
  if ((result & 0x80000000) != 0)
  {
    uint64_t v12 = "Invalid archive";
    __int16 v13 = 528;
    goto LABEL_29;
  }
  if (a1[1])
  {
    uint64_t v15 = a1[16];
    *(_OWORD *)uint64_t v15 = *(_OWORD *)(a1 + 17);
    long long v16 = *(_OWORD *)(a1 + 19);
    long long v17 = *(_OWORD *)(a1 + 21);
    long long v18 = *(_OWORD *)(a1 + 23);
    *(void *)(v15 + 64) = a1[25];
    *(_OWORD *)(v15 + 32) = v17;
    *(_OWORD *)(v15 + 48) = v18;
    *(_OWORD *)(v15 + 16) = v16;
    uint64_t result = ((uint64_t (*)(void, void))a1[1])(*a1, a1[16]);
    if ((result & 0x80000000) != 0)
    {
      uint64_t v12 = "Client post-unlock callback returned an error";
      __int16 v13 = 534;
      goto LABEL_29;
    }
  }
  if ((*((unsigned char *)a1 + 47) & 4) != 0) {
    *(_DWORD *)(a1[16] + 2740) = 1;
  }
  unint64_t v19 = *((unsigned int *)a1 + 39);
  unint64_t v20 = ((a1[21] + (unint64_t)*((unsigned int *)a1 + 38) - 1) / *((unsigned int *)a1 + 38) + v19 - 1) / v19;
  if (HIDWORD(v20)) {
    BOOL v21 = 0;
  }
  else {
    BOOL v21 = (v20 * v19) >> 32 == 0;
  }
  if (!v21)
  {
    uint64_t v12 = "Invalid archive, too many clusters";
    __int16 v13 = 546;
    goto LABEL_29;
  }
  *((_DWORD *)a1 + 195) = v20;
  uint64_t v22 = *((unsigned int *)a1 + 81);
  if (v22 >= 0x101)
  {
    __break(1u);
  }
  else
  {
    memcpy((char *)a1 + 820, (char *)a2 + a1[33], *((unsigned int *)a1 + 81));
    *((_DWORD *)a1 + 204) = v22;
    memset_s((char *)a1 + v22 + 820, 256 - v22, 0, 256 - v22);
    if (*((_DWORD *)a1 + 195))
    {
      uint64_t v23 = a1[98] + *((unsigned int *)a1 + 81) + 8;
      a1[100] = v23;
      unint64_t v24 = v20 * *((unsigned int *)a1 + 39);
      a1[136] = v24;
      a1[137] = 0;
      if (v24 * v23 >= 0x2000000001)
      {
        *__error() = 12;
        a1[138] = 0;
LABEL_38:
        int v25 = *__error();
        uint64_t v12 = "malloc";
        __int16 v13 = 569;
        goto LABEL_30;
      }
      int v32 = malloc(v24 * v23);
      a1[138] = v32;
      if (!v32) {
        goto LABEL_38;
      }
      uint64_t v33 = pushRange(a1, a1[38]);
      if (v33 < 0)
      {
        uint64_t v12 = "inserting first cluster header range";
        __int16 v13 = 573;
        goto LABEL_29;
      }
      uint64_t v34 = v33;
      uint64_t result = 0;
      *((_DWORD *)a1 + 13) = 2;
      a1[141] = v34;
      *((_DWORD *)a1 + 269) = 0;
    }
    else
    {
      int v26 = pushPaddingRange((uint64_t)a1);
      if (v26 < 0)
      {
        uint64_t v12 = "inserting padding range";
        __int16 v13 = 556;
        goto LABEL_29;
      }
      if (!v26 && (startStreaming((uint64_t)a1, v27, v28, v29, v30, v31, v7, v8) & 0x80000000) != 0)
      {
        uint64_t v12 = "Streaming data setup";
        __int16 v13 = 559;
        goto LABEL_29;
      }
      return 0;
    }
  }
  return result;
}

uint64_t processClusterHeader(uint64_t a1, void *__src, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  int v55 = 0;
  memset(v54, 0, sizeof(v54));
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Cluster header received: %zu B\n", __n);
  }
  unsigned int v11 = *(void **)(a1 + 808);
  if (v11)
  {
    size_t v12 = *(void *)(a1 + 792);
    goto LABEL_5;
  }
  size_t v12 = *(void *)(a1 + 304);
  *(void *)(a1 + 792) = v12;
  if (v12 >= 0x2000000001)
  {
    *__error() = 12;
    *(void *)(a1 + 808) = 0;
LABEL_50:
    int v51 = *__error();
    long long v17 = "malloc";
    __int16 v18 = 596;
LABEL_55:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processClusterHeader", v18, 114, v51, v17, a7, a8, v53);
    uint64_t v50 = 0xFFFFFFFFLL;
    goto LABEL_56;
  }
  unsigned int v11 = malloc(v12);
  *(void *)(a1 + 808) = v11;
  if (!v11) {
    goto LABEL_50;
  }
LABEL_5:
  if (v12 != __n)
  {
    long long v17 = "Invalid cluster header size";
    __int16 v18 = 600;
LABEL_54:
    int v51 = 0;
    goto LABEL_55;
  }
  memcpy(v11, __src, __n);
  int v13 = *(_DWORD *)(a1 + 1076);
  int v57 = 0;
  memset(v56, 0, sizeof(v56));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(void *)uint64_t __s = 0x5F41454100000006;
  memset(v58, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v13;
  *(_DWORD *)uint64_t __s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  char v14 = *(uint64_t (**)(_OWORD *, void))(a1 + 384);
  if (!v14 || !*(_DWORD *)(a1 + 520))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
LABEL_15:
    int v16 = 1;
    goto LABEL_16;
  }
  int v15 = v14(v56, *(unsigned int *)(a1 + 312));
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  int v16 = 0;
  if (v15 < 0) {
    goto LABEL_15;
  }
LABEL_16:
  memset((char *)v58 + 12, 0, 248);
  *(void *)((char *)v58 + 4) = 0x4B4548435F414541;
  LODWORD(v58[0]) = 8;
  memset_s((char *)v58 + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(__s, 0, sizeof(__s));
  unint64_t v19 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, unsigned char *))(a1 + 384);
  if (!v19 || !LODWORD(v56[0]))
  {
    memset_s(v58, 0x104uLL, 0, 0x104uLL);
    goto LABEL_52;
  }
  int v20 = v19(v54, *(unsigned int *)(a1 + 316), v56, v58, __s);
  memset_s(v58, 0x104uLL, 0, 0x104uLL);
  if (v20 < 0)
  {
LABEL_52:
    memset_s(v56, 0x104uLL, 0, 0x104uLL);
    goto LABEL_53;
  }
  memset_s(v56, 0x104uLL, 0, 0x104uLL);
  if (v16)
  {
LABEL_53:
    long long v17 = "Cluster header encryption key derivation";
    __int16 v18 = 611;
    goto LABEL_54;
  }
  BOOL v21 = *(uint64_t (**)(void, void, uint64_t, _OWORD *, void, void))(a1 + 408);
  if (!v21
    || *(_DWORD *)(a1 + 816) != *(_DWORD *)(a1 + 324)
    || (uint64_t result = v21(*(void *)(a1 + 808), *(void *)(a1 + 288), a1 + 816, v54, *(void *)(a1 + 808) + *(void *)(a1 + 288), *(void *)(a1 + 304) - *(void *)(a1 + 288)), (result & 0x80000000) != 0))
  {
    long long v17 = "Cluster header decryption";
    __int16 v18 = 622;
    goto LABEL_54;
  }
  size_t v23 = *(unsigned int *)(a1 + 324);
  int v24 = *(_DWORD *)(a1 + 156);
  if (v24)
  {
    int v25 = 0;
    size_t v26 = *(void *)(a1 + 784) + 8;
    int v27 = v24 * *(_DWORD *)(a1 + 1076);
    uint64_t v28 = *(void *)(a1 + 296);
    uint64_t v29 = *(void *)(a1 + 280);
    while (1)
    {
      unint64_t v30 = *(void *)(a1 + 1096);
      if (v30 >= *(void *)(a1 + 1088))
      {
        long long v17 = "Invalid archive";
        __int16 v18 = 634;
        goto LABEL_54;
      }
      uint64_t v31 = (unsigned int *)(*(void *)(a1 + 1104) + *(void *)(a1 + 800) * v30);
      memcpy(v31, (const void *)(*(void *)(a1 + 808) + v29), v26);
      uint64_t result = (uint64_t)memcpy((char *)v31 + v26, (const void *)(*(void *)(a1 + 808) + v28), v23);
      uint64_t v32 = *v31;
      if (!v32) {
        goto LABEL_42;
      }
      uint64_t v33 = *(void *)(a1 + 1120);
      if (v33) {
        uint64_t v33 = *(void *)(*(void *)(a1 + 1136) + 32 * v33 - 32) + *(void *)(*(void *)(a1 + 1136) + 32 * v33 - 24);
      }
      uint64_t v34 = v31[1];
      if ((unint64_t)(v33 + v34) > *(void *)(a1 + 176)
        || (unint64_t v35 = *(void *)(a1 + 1080) + v32, v36 = *(void *)(a1 + 168), v35 > v36))
      {
        long long v17 = "Invalid archive: segment size mismatch";
        __int16 v18 = 648;
        goto LABEL_54;
      }
      if (v34 > v32
        || (v35 != v36 ? (BOOL v37 = v32 >= *(_DWORD *)(a1 + 152)) : (BOOL v37 = 1), !v37))
      {
        unsigned int v53 = v31[1];
        long long v17 = "Invalid segment sizes: payload=%u raw=%u";
        __int16 v18 = 651;
        goto LABEL_54;
      }
      ++*(void *)(a1 + 1096);
      *(void *)(a1 + 1080) = v35;
      uint64_t result = pushRange((void *)a1, v34);
      if (result < 0) {
        break;
      }
      v29 += v26;
      v28 += v23;
      uint64_t v38 = *(void *)(a1 + 1136);
      uint64_t v39 = v38 + 32 * result;
      *(_DWORD *)(v39 + 24) = v27 + v25;
      *(_DWORD *)(v39 + 28) = 3;
      uint64_t v40 = *(void *)(a1 + 1152);
      uint64_t v41 = v38 + 32 * v40 + 16;
      if (v40 >= 0) {
        int v42 = (void *)v41;
      }
      else {
        int v42 = (void *)(a1 + 1144);
      }
      void *v42 = result;
      *(void *)(a1 + 1152) = result;
      if (++v25 >= *(_DWORD *)(a1 + 156))
      {
LABEL_42:
        LODWORD(v23) = *(_DWORD *)(a1 + 324);
        goto LABEL_43;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"pushSegmentRange", 386, 114, 0, "inserting segment range", a7, a8, v53);
    __int16 v18 = 658;
    int v51 = 0;
    long long v17 = "inserting segment range";
    goto LABEL_55;
  }
LABEL_43:
  if (v23 < 0x101)
  {
    memcpy((void *)(a1 + 820), (const void *)(*(void *)(a1 + 808) + *(void *)(a1 + 288)), v23);
    *(_DWORD *)(a1 + 816) = v23;
    memset_s((void *)(a1 + 820 + v23), 256 - v23, 0, 256 - v23);
    int v43 = *(_DWORD *)(a1 + 1076) + 1;
    *(_DWORD *)(a1 + 1076) = v43;
    if (v43 == *(_DWORD *)(a1 + 780))
    {
      int v44 = pushPaddingRange(a1);
      if (v44 < 0)
      {
        long long v17 = "inserting padding range";
        __int16 v18 = 669;
      }
      else
      {
        if (v44 || (startStreaming(a1, v45, v46, v47, v48, v49, a7, a8) & 0x80000000) == 0)
        {
          uint64_t v50 = 0;
LABEL_56:
          memset_s(v54, 0x104uLL, 0, 0x104uLL);
          return v50;
        }
        long long v17 = "Streaming data setup";
        __int16 v18 = 672;
      }
    }
    else
    {
      uint64_t v52 = pushRange((void *)a1, *(void *)(a1 + 304));
      if ((v52 & 0x8000000000000000) == 0)
      {
        uint64_t v50 = 0;
        *(void *)(a1 + 1128) = v52;
        goto LABEL_56;
      }
      long long v17 = "inserting next cluster header range";
      __int16 v18 = 679;
    }
    goto LABEL_54;
  }
  __break(1u);
  return result;
}

uint64_t processPadding(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Padding received: %zu B\n", a3);
  }
  int v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long __s = 0u;
  long long v28 = 0u;
  int v26 = 0;
  memset(v25, 0, sizeof(v25));
  if (*(void *)(a1 + 488)
    && (*(_DWORD *)((char *)v25 + 7) = 1262571615,
        *(void *)&v25[0] = 0x5F41454100000007,
        memset_s((void *)((unint64_t)v25 | 0xB), 0xF9uLL, 0, 0xF9uLL),
        (uint64_t v6 = *(uint64_t (**)(long long *, void))(a1 + 384)) != 0)
    && *(_DWORD *)(a1 + 520)
    && (v6(&__s, *(unsigned int *)(a1 + 312)) & 0x80000000) == 0)
  {
    uint64_t v7 = (*(uint64_t (**)(long long *))(a1 + 488))(&__s);
  }
  else
  {
    uint64_t v7 = 0;
  }
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v25, 0x104uLL, 0, 0x104uLL);
  if (!v7)
  {
    int v16 = "authenticating padding";
    __int16 v17 = 699;
    goto LABEL_25;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 496);
  BOOL v11 = !v10 || (v10(v7, a2, a3) & 0x80000000) != 0;
  int v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long __s = 0u;
  long long v28 = 0u;
  size_t v12 = *(uint64_t (**)(uint64_t, long long *))(a1 + 504);
  if (!v12) {
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 816) != *(_DWORD *)(a1 + 324)) {
    goto LABEL_22;
  }
  if ((v12(v7, &__s) & 0x80000000) != 0) {
    goto LABEL_22;
  }
  if (__s != *(_DWORD *)(a1 + 324)) {
    goto LABEL_22;
  }
  if (__s >= 8)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      v14 |= *(void *)((char *)&__s + v13 + 4) ^ *(void *)(a1 + 820 + v13);
      unint64_t v15 = v13 + 16;
      v13 += 8;
    }
    while (v15 <= __s);
    if (v14)
    {
LABEL_22:
      memset_s(&__s, 0x104uLL, 0, 0x104uLL);
LABEL_23:
      int v16 = "authenticating padding";
      __int16 v17 = 702;
      goto LABEL_25;
    }
  }
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  if (v11) {
    goto LABEL_23;
  }
  if ((startStreaming(a1, v19, v20, v21, v22, v23, v8, v9) & 0x80000000) == 0) {
    return 0;
  }
  int v16 = "Streaming data setup";
  __int16 v17 = 705;
LABEL_25:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processPadding", v17, 114, 0, v16, v8, v9, v24);
  return 0xFFFFFFFFLL;
}

uint64_t processSegment(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = a4;
  if (*(_DWORD *)(a1 + 32) >= 3u) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Segment received: %zu B\n", a4);
  }
  uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1176), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!Worker)
  {
    uint64_t v23 = "ThreadPoolGetWorker";
    __int16 v24 = 720;
    goto LABEL_9;
  }
  uint64_t v15 = Worker;
  int v16 = 1;
  if (*(void *)(Worker + 24) < v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processSegment", 723, 114, 0, "Invalid segment size", v13, v14, v26);
    int v16 = 0;
    size_t v8 = 0;
  }
  memcpy(*(void **)(v15 + 40), a3, v8);
  *(void *)(v15 + 32) = v8;
  *(_DWORD *)(v15 + 16) = 1;
  *(void *)(v15 + 8) = a2;
  if ((ThreadPoolRunWorker(*(void *)(a1 + 1176), v15, v17, v18, v19, v20, v21, v22) & 0x80000000) != 0)
  {
    uint64_t v23 = "ThreadPoolRunWorker";
    __int16 v24 = 728;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"processSegment", v24, 114, 0, v23, v13, v14, v26);
    int v16 = 0;
  }
  if (v16) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t cmpRange(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t pushPaddingRange(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)(a1 + 128) + 2740)) {
    return 0;
  }
  unint64_t v2 = *(void *)(a1 + 1120);
  if (v2) {
    unint64_t v2 = *(void *)(*(void *)(a1 + 1136) + 32 * v2 - 32) + *(void *)(*(void *)(a1 + 1136) + 32 * v2 - 24);
  }
  unint64_t v3 = *(void *)(a1 + 176);
  if (v3 == v2) {
    return 0;
  }
  if (v3 >= v2)
  {
    uint64_t v5 = pushRange((void *)a1, v3 - v2);
    if ((v5 & 0x8000000000000000) == 0)
    {
      *(_DWORD *)(a1 + 52) = 3;
      *(void *)(a1 + 1128) = v5;
      return 1;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"pushPaddingRange", 375, 114, 0, "inserting padding range", v6, v7, v8);
  }
  return 0xFFFFFFFFLL;
}

uint64_t startStreaming(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 780))
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 52) = 5;
    return result;
  }
  if (!*(_DWORD *)(a1 + 1160))
  {
LABEL_14:
    unint64_t v20 = *(void *)(a1 + 1120);
    if (v20)
    {
      unint64_t v21 = 0;
      uint64_t v22 = 24;
      do
      {
        if (*(_DWORD *)(*(void *)(a1 + 1136) + v22) != -1)
        {
          uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1176), a2, a3, a4, a5, a6, a7, a8);
          if (!Worker)
          {
            long long v36 = "ThreadPoolGetWorker";
            __int16 v37 = 449;
            goto LABEL_45;
          }
          *(_DWORD *)(Worker + 16) = 0;
          *(void *)(Worker + 8) = v21;
          if ((ThreadPoolRunWorker(*(void *)(a1 + 1176), Worker, v24, v25, v26, v27, a7, a8) & 0x80000000) != 0)
          {
            long long v36 = "ThreadPoolRunWorker";
            __int16 v37 = 452;
            goto LABEL_45;
          }
          unint64_t v20 = *(void *)(a1 + 1120);
        }
        ++v21;
        v22 += 32;
      }
      while (v21 < v20);
    }
    if ((ThreadPoolSync(*(unsigned int **)(a1 + 1176)) & 0x80000000) != 0)
    {
      long long v36 = "ThreadPoolSync";
      __int16 v37 = 454;
      goto LABEL_45;
    }
    uint64_t v28 = *(void *)(a1 + 1120);
    if (v28)
    {
      int v29 = 0;
      int v30 = 0;
      long long v31 = (int *)(*(void *)(a1 + 1136) + 28);
      do
      {
        int v33 = *v31;
        v31 += 8;
        int v32 = v33;
        if (v33 == 4) {
          int v34 = v30 + 1;
        }
        else {
          int v34 = v30;
        }
        if (v32 == 6) {
          ++v29;
        }
        else {
          int v30 = v34;
        }
        --v28;
      }
      while (v28);
      uint64_t v28 = (v29 + v30);
    }
    if (*(void *)(a1 + 1096) != v28 || *(void *)(a1 + 1080) != *(void *)(a1 + 168))
    {
      long long v36 = "Segment count/size mismatch";
      __int16 v37 = 467;
      goto LABEL_45;
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 52) = 4;
    *(void *)(a1 + 1128) = *(void *)(a1 + 1144);
    return result;
  }
  uint64_t v9 = 0;
  while (1)
  {
    uint64_t v10 = *(void **)(*(void *)(a1 + 1168) + 8 * v9);
    if (v10[3]) {
      goto LABEL_5;
    }
    uint64_t v11 = *v10;
    size_t v12 = *(unsigned int *)(*v10 + 152);
    uint64_t v13 = malloc(v12);
    v10[5] = v13;
    if (!v13)
    {
      __int16 v38 = 144;
      goto LABEL_44;
    }
    v10[3] = v12;
    compression_algorithm v14 = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(v11 + 160));
    if (!v14) {
      goto LABEL_5;
    }
    compression_algorithm v15 = v14;
    int v16 = malloc(v12);
    v10[8] = v16;
    if (!v16)
    {
      __int16 v38 = 152;
      goto LABEL_44;
    }
    v10[6] = v12;
    size_t v17 = compression_decode_scratch_buffer_size(v15);
    if (!v17) {
      goto LABEL_5;
    }
    size_t v18 = v17;
    if (v17 >= 0x2000000001) {
      break;
    }
    uint64_t v19 = malloc(v17);
    v10[10] = v19;
    if (!v19) {
      goto LABEL_43;
    }
    v10[9] = v18;
LABEL_5:
    if (++v9 >= (unint64_t)*(unsigned int *)(a1 + 1160)) {
      goto LABEL_14;
    }
  }
  *__error() = 12;
  v10[10] = 0;
LABEL_43:
  __int16 v38 = 159;
LABEL_44:
  long long v39 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"workerAllocBuffers", v38, 114, *v39, "malloc", v40, v41, v42);
  long long v36 = "Worker buffer allocation";
  __int16 v37 = 440;
LABEL_45:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAsyncStream.c", (uint64_t)"startStreaming", v37, 114, 0, v36, a7, a8, v42);
  return 0xFFFFFFFFLL;
}

void AAArchiveStreamCancel(AAArchiveStream s)
{
  int v1 = (void (*)(void))*((void *)s + 2);
  if (v1) {
    v1(*(void *)s);
  }
}

AAArchiveStream AACustomArchiveStreamOpen(void)
{
  v0 = (AAArchiveStream_impl *)malloc(0x38uLL);
  int v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x38uLL, 0, 0x38uLL);
  }
  else
  {
    unint64_t v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AACustomArchiveStreamOpen", 49, 14, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

void AACustomArchiveStreamSetData(AAArchiveStream s, void *data)
{
  *(void *)s = data;
}

void AACustomArchiveStreamSetCloseProc(AAArchiveStream s, AAArchiveStreamCloseProc proc)
{
  *((void *)s + 1) = proc;
}

void AACustomArchiveStreamSetCancelProc(AAArchiveStream s, AAArchiveStreamCancelProc proc)
{
  *((void *)s + 2) = proc;
}

void AACustomArchiveStreamSetWriteHeaderProc(AAArchiveStream s, AAArchiveStreamWriteHeaderProc proc)
{
  *((void *)s + 3) = proc;
}

void AACustomArchiveStreamSetWriteBlobProc(AAArchiveStream s, AAArchiveStreamWriteBlobProc proc)
{
  *((void *)s + 4) = proc;
}

void AACustomArchiveStreamSetReadHeaderProc(AAArchiveStream s, AAArchiveStreamReadHeaderProc proc)
{
  *((void *)s + 5) = proc;
}

void AACustomArchiveStreamSetReadBlobProc(AAArchiveStream s, AAArchiveStreamReadBlobProc proc)
{
  *((void *)s + 6) = proc;
}

uint64_t appendPathListWorkerProc(uint64_t **a1)
{
  uint64_t v188 = *MEMORY[0x263EF8340];
  unint64_t v2 = *a1;
  uint64_t v175 = **a1;
  bzero(path, 0x400uLL);
  bzero(v186, 0x800uLL);
  AAHeader header = AAHeaderCreate();
  if (header)
  {
    int v5 = 1;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 168, 14, 0, "creating header", v3, v4, (char)v154);
    int v5 = 0;
  }
  char v8 = AAEntryXATBlobCreate();
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 170, 14, 0, "creating XAT field", v6, v7, (char)v154);
    int v5 = 0;
  }
  uint64_t v11 = AAEntryACLBlobCreate();
  if (!v11)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 172, 14, 0, "creating XAT field", v9, v10, (char)v154);
    int v5 = 0;
  }
  compression_algorithm v14 = (void **)AAEntryYECBlobCreate();
  if (!v14)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 174, 14, 0, "creating YEC field", v12, v13, (char)v154);
    int v5 = 0;
  }
  v176 = v14;
  memset(&v183, 0, sizeof(v183));
  size[0] = 0;
  size[1] = 0;
  v182 = 0;
  uint64_t v15 = v2[136];
  int v16 = a1[1];
  size_t v17 = (unint64_t *)(v15 + 40 * (void)v16);
  unint64_t v18 = *v17;
  unint64_t v20 = v17[1];
  uint64_t v19 = v17 + 1;
  if (v18 < v20)
  {
    BOOL v21 = *((_DWORD *)v2 + 280) != 0;
    long long __s = (char *)(v2 + 3);
    uint64_t v22 = v15 + 40 * (void)v16;
    v173 = (size_t *)(v22 + 24);
    v174 = (size_t *)(v22 + 16);
    uint64_t v23 = (void **)(v22 + 32);
    while (1)
    {
      uint64_t v24 = v2[144];
      uint64_t v25 = v24 + (v18 << 7);
      if (!v21 && !*((_DWORD *)v2 + 280)) {
        break;
      }
      int v5 = 0;
      int v26 = 1;
      BOOL v21 = 1;
LABEL_15:
      *(_DWORD *)(v25 + 120) = v26;
      if (++v18 >= *v19) {
        goto LABEL_256;
      }
    }
    uint64_t v27 = v23;
    size_t path_length = 0;
    if (AAPathListNodeGetPath((AAPathList)v2[1], *(void *)(v24 + (v18 << 7) + 24), 0x400uLL, path, &path_length) < 0)
    {
      __int16 v43 = 192;
      uint64_t v44 = "AAPathListNodeGetPath";
      goto LABEL_145;
    }
    if ((concatPath(v186, 0x800uLL, __s, path) & 0x80000000) != 0)
    {
      __int16 v43 = 193;
      uint64_t v44 = "invalid path";
      goto LABEL_145;
    }
    int v30 = (uint64_t (*)(uint64_t, uint64_t, char *, void))v2[132];
    if (v30 && (v30(v2[131], 30, path, 0) & 0x80000000) != 0)
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 199, 14, "operation aborted", v31, v32, v33, (char)v154);
      int v48 = 0;
      BOOL v21 = 0;
      int v5 = 0;
      int v26 = 1;
      atomic_compare_exchange_strong((atomic_uint *volatile)v2 + 280, (unsigned int *)&v48, 1u);
    }
    else
    {
      if (lstat(v186, &v183) < 0)
      {
        int v45 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 202, 14, v45, "lstat %s", v46, v47, (char)v186);
        goto LABEL_146;
      }
      if ((aaHeaderInitWithPath(header, (AAFieldKeySet_impl *)v2[2], __s, path) & 0x80000000) != 0)
      {
        __int16 v43 = 203;
        uint64_t v44 = "initializing header from path";
        goto LABEL_145;
      }
      v34.ikey = 5521732;
      if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v34))
      {
        if ((v183.st_mode & 0xF000) == 0x8000)
        {
          v35.ikey = 5521732;
          if (AAHeaderSetFieldBlob(header, 0xFFFFFFFF, v35, v183.st_size) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 209, 14, 0, "inserting DAT: %s", v36, v37, (char)v186);
            goto LABEL_146;
          }
        }
      }
      v38.ikey = 5521752;
      if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v38)) {
        goto LABEL_36;
      }
      if ((aaEntryXATBlobInitWithPath(v8, __s, path) & 0x80000000) != 0)
      {
        __int16 v43 = 216;
        uint64_t v44 = "initializing XAT field from path";
        goto LABEL_145;
      }
      if (AAEntryXATBlobGetEntryCount(v8))
      {
        size_t EncodedSize = AAEntryXATBlobGetEncodedSize(v8);
        v40.ikey = 5521752;
        if (AAHeaderSetFieldBlob(header, 0xFFFFFFFF, v40, EncodedSize) < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 220, 14, 0, "inserting XAT: %s", v41, v42, (char)v186);
          goto LABEL_146;
        }
        char __n = 0;
      }
      else
      {
LABEL_36:
        char __n = 1;
      }
      v49.ikey = 4997953;
      if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v49)) {
        goto LABEL_45;
      }
      int v50 = v183.st_mode & 0xF000;
      if (v50 != 0x8000 && v50 != 0x4000) {
        goto LABEL_45;
      }
      int v51 = AAEntryACLBlobCreate();
      uint64_t v11 = v51;
      if (!v51)
      {
        __int16 v43 = 229;
        uint64_t v44 = "creating ACL field";
        goto LABEL_145;
      }
      if ((aaEntryACLBlobInitWithPath(v51, __s, path, v175) & 0x80000000) != 0)
      {
        __int16 v43 = 230;
        uint64_t v44 = "initializing ACL field from path";
        goto LABEL_145;
      }
      if (AAEntryACLBlobGetEntryCount(v11))
      {
        size_t v52 = AAEntryACLBlobGetEncodedSize(v11);
        v53.ikey = 4997953;
        if (AAHeaderSetFieldBlob(header, 0xFFFFFFFF, v53, v52) < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 234, 14, 0, "inserting ACL: %s", v54, v55, (char)v186);
          goto LABEL_146;
        }
        char v162 = 0;
      }
      else
      {
LABEL_45:
        char v162 = 1;
      }
      v56.ikey = 4408665;
      if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v56))
      {
        char v166 = 1;
        goto LABEL_54;
      }
      char v166 = 1;
      if ((v183.st_mode & 0xF000) != 0x8000 || v183.st_size < 1) {
        goto LABEL_54;
      }
      if ((aaEntryYECBlobInitWithPath(v176, 65552, __s, path) & 0x80000000) != 0)
      {
        __int16 v110 = 242;
        uint64_t v111 = "initializing YEC field from path";
      }
      else
      {
        uint64_t v59 = AAEntryYECBlobGetEncodedSize((uint64_t)v176);
        v60.ikey = 4408665;
        if ((AAHeaderSetFieldBlob(header, 0xFFFFFFFF, v60, v59) & 0x80000000) == 0)
        {
          char v166 = 0;
LABEL_54:
          v61.ikey = 5260889;
          if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v61))
          {
            int v161 = 1;
            goto LABEL_61;
          }
          int v161 = 1;
          if ((v183.st_mode & 0xF000) != 0x8000 || v183.st_size < 1)
          {
LABEL_61:
            v65.ikey = 4410440;
            if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v65)
              && (v183.st_mode & 0xF000) == 0x8000
              && v183.st_nlink >= 2u)
            {
              *(void *)(v24 + (v18 << 7) + 32) = v183.st_ino;
            }
            v66.ikey = 4410435;
            int v67 = AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v66);
            mode_t st_mode = v183.st_mode;
            if (v67 && (v183.st_mode & 0xF000) == 0x8000)
            {
              long long v184 = 0uLL;
              if (!fsctl(v186, 0x40104A0EuLL, &v184, 0) && (void)v184 == 2) {
                *(void *)(v24 + (v18 << 7) + 40) = *((void *)&v184 + 1);
              }
              mode_t st_mode = v183.st_mode;
            }
            if ((st_mode & 0xF000) == 0x8000)
            {
              v69.ikey = 4410451;
              if (AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v69))
              {
                uint64_t v70 = v24 + (v18 << 7);
                *(void *)(v70 + 48) = 0;
                uint64_t value = (uint8_t *)(v70 + 56);
                memset_s((void *)(v70 + 56), 0x40uLL, 0, 0x40uLL);
                AAHashFunction hash_function = 0;
                v71.ikey = 3491923;
                if (!AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v71)) {
                  goto LABEL_84;
                }
                v72.ikey = 3491923;
                uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v72);
                if ((KeyIndex & 0x80000000) != 0) {
                  goto LABEL_84;
                }
                unsigned int FieldHash = AAHeaderGetFieldHash(header, KeyIndex, 0x40uLL, &hash_function, value);
                int v75 = FieldHash <= 1 ? 1 : FieldHash;
                if (v75 <= 0)
                {
LABEL_84:
                  if ((v76.ikey = 3360851, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v76))
                    || (v77.ikey = 3360851, uint32_t v78 = AAHeaderGetKeyIndex(header, v77), (v78 & 0x80000000) != 0)
                    || ((unsigned int v79 = AAHeaderGetFieldHash(header, v78, 0x40uLL, &hash_function, value), v79 <= 1)
                      ? (int v80 = 1)
                      : (int v80 = v79),
                        v80 <= 0))
                  {
                    if ((v81.ikey = 3295315, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v81))
                      || (v82.ikey = 3295315, uint32_t v83 = AAHeaderGetKeyIndex(header, v82), (v83 & 0x80000000) != 0)
                      || ((unsigned int v84 = AAHeaderGetFieldHash(header, v83, 0x40uLL, &hash_function, value), v84 <= 1)
                        ? (int v85 = 1)
                        : (int v85 = v84),
                          v85 <= 0))
                    {
                      if ((v86.ikey = 3229779, !AAFieldKeySetContainsKey((AAFieldKeySet)v2[2], v86))
                        || (v87.ikey = 3229779, uint32_t v88 = AAHeaderGetKeyIndex(header, v87), (v88 & 0x80000000) != 0)
                        || ((unsigned int v89 = AAHeaderGetFieldHash(header, v88, 0x40uLL, &hash_function, value), v89 <= 1)
                          ? (int v90 = 1)
                          : (int v90 = v89),
                            v90 <= 0))
                      {
                        long long v184 = 0uLL;
                        int v185 = 0;
                        if ((getFileSHA1Digest(v186, (uint64_t)&v184) & 0x80000000) != 0)
                        {
                          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 284, 14, 0, "hashing file: %s", v91, v92, (char)v186);
                          goto LABEL_146;
                        }
                        long long v93 = v184;
                        *((_DWORD *)value + 4) = v185;
                        *(_OWORD *)uint64_t value = v93;
                      }
                    }
                  }
                }
              }
            }
            size_t v94 = AAHeaderGetEncodedSize(header);
            if ((__n & 1) == 0) {
              v94 += AAEntryXATBlobGetEncodedSize(v8);
            }
            if ((v162 & 1) == 0) {
              v94 += AAEntryACLBlobGetEncodedSize(v11);
            }
            if ((v166 & 1) == 0) {
              v94 += AAEntryYECBlobGetEncodedSize((uint64_t)v176);
            }
            uint64_t v95 = size[0];
            if (v161) {
              uint64_t v95 = 0;
            }
            uint64_t v96 = v95 + v94;
            *(void *)uint64_t v25 = *v174;
            uint64_t v97 = v24 + (v18 << 7);
            *(void *)(v97 + 8) = v96;
            *(void *)(v97 + 16) = AAHeaderGetEncodedSize(header);
            unint64_t v98 = *v174 + v96;
            if ((v98 & 0x8000000000000000) != 0) {
              goto LABEL_144;
            }
            unint64_t v99 = *v173;
            if (*v173 < v98)
            {
              do
              {
                while (!v99)
                {
                  unint64_t v99 = 0x4000;
                  size_t v101 = 0x4000;
                  if (v98 <= 0x4000) {
                    goto LABEL_122;
                  }
                }
                unint64_t v100 = v99 >> 1;
                if ((v99 & (v99 >> 1)) != 0) {
                  unint64_t v100 = v99 & (v99 >> 1);
                }
                v99 += v100;
              }
              while (v99 < v98);
              size_t v101 = v99;
              if (v99 >= 0x2000000001)
              {
                *__error() = 12;
                goto LABEL_143;
              }
LABEL_122:
              __srCC_SHA256_CTX c = *v27;
              unint64_t v102 = realloc(*v27, v101);
              if (v102)
              {
                const char *v27 = v102;
                size_t *v173 = v101;
                goto LABEL_124;
              }
              free(__src);
LABEL_143:
              size_t *v174 = 0;
              v174[1] = 0;
              v174[2] = 0;
LABEL_144:
              __int16 v43 = 302;
              uint64_t v44 = "reallocating block blob";
              goto LABEL_145;
            }
LABEL_124:
            __srca = AAHeaderGetEncodedData(header);
            size_t v103 = AAHeaderGetEncodedSize(header);
            size_t v104 = *v174;
            unint64_t v105 = *v174 + v103;
            if (__CFADD__(*v174, v103)) {
              goto LABEL_126;
            }
            uint64_t v23 = v27;
            if ((v105 & 0x8000000000000000) == 0)
            {
              size_t v106 = v103;
              unint64_t v107 = *v173;
              if (*v173 < v105)
              {
                do
                {
                  while (!v107)
                  {
                    unint64_t v107 = 0x4000;
                    size_t v109 = 0x4000;
                    if (v105 <= 0x4000) {
                      goto LABEL_150;
                    }
                  }
                  unint64_t v108 = v107 >> 1;
                  if ((v107 & (v107 >> 1)) != 0) {
                    unint64_t v108 = v107 & (v107 >> 1);
                  }
                  v107 += v108;
                }
                while (v107 < v105);
                size_t v109 = v107;
                if (v107 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_247;
                }
LABEL_150:
                v155 = *v27;
                uint64_t v112 = realloc(*v27, v109);
                if (v112)
                {
                  const char *v27 = v112;
                  size_t *v173 = v109;
                  uint64_t v23 = v27;
                  goto LABEL_152;
                }
                free(v155);
LABEL_247:
                size_t v104 = 0;
                size_t *v174 = 0;
                v174[1] = 0;
                v174[2] = 0;
LABEL_126:
                uint64_t v23 = v27;
                goto LABEL_158;
              }
LABEL_152:
              int v113 = (char *)*v23;
              if (__srca)
              {
                memcpy(&v113[*v174], __srca, v106);
                uint64_t v23 = v27;
                uint64_t v114 = v174;
              }
              else
              {
                uint64_t v114 = v174;
                if (v113)
                {
                  memset_s(&v113[*v174], v106, 0, v106);
                  uint64_t v23 = v27;
                  uint64_t v114 = v174;
                }
              }
              size_t v104 = *v114 + v106;
              *uint64_t v114 = v104;
            }
LABEL_158:
            if (__n) {
              goto LABEL_180;
            }
            __na = AAEntryXATBlobGetEncodedData(v8);
            size_t v115 = AAEntryXATBlobGetEncodedSize(v8);
            size_t v104 = *v174;
            unint64_t v116 = *v174 + v115;
            if (__CFADD__(*v174, v115)) {
              goto LABEL_161;
            }
            uint64_t v23 = v27;
            if ((v116 & 0x8000000000000000) == 0)
            {
              size_t v117 = v115;
              unint64_t v118 = *v173;
              if (*v173 < v116)
              {
                do
                {
                  while (!v118)
                  {
                    unint64_t v118 = 0x4000;
                    size_t v120 = 0x4000;
                    if (v116 <= 0x4000) {
                      goto LABEL_173;
                    }
                  }
                  unint64_t v119 = v118 >> 1;
                  if ((v118 & (v118 >> 1)) != 0) {
                    unint64_t v119 = v118 & (v118 >> 1);
                  }
                  v118 += v119;
                }
                while (v118 < v116);
                size_t v120 = v118;
                if (v118 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_249;
                }
LABEL_173:
                int v156 = *v27;
                uint64_t v121 = realloc(*v27, v120);
                if (v121)
                {
                  const char *v27 = v121;
                  size_t *v173 = v120;
                  uint64_t v23 = v27;
                  goto LABEL_175;
                }
                free(v156);
LABEL_249:
                size_t v104 = 0;
                size_t *v174 = 0;
                v174[1] = 0;
                v174[2] = 0;
LABEL_161:
                uint64_t v23 = v27;
                goto LABEL_180;
              }
LABEL_175:
              uint64_t v122 = (char *)*v23;
              if (__na)
              {
                memcpy(&v122[*v174], __na, v117);
                uint64_t v23 = v27;
                int v123 = v174;
              }
              else
              {
                int v123 = v174;
                if (v122)
                {
                  memset_s(&v122[*v174], v117, 0, v117);
                  uint64_t v23 = v27;
                  int v123 = v174;
                }
              }
              size_t v104 = *v123 + v117;
              *int v123 = v104;
            }
LABEL_180:
            if (v162) {
              goto LABEL_202;
            }
            __nb = AAEntryACLBlobGetEncodedData(v11);
            size_t v124 = AAEntryACLBlobGetEncodedSize(v11);
            size_t v104 = *v174;
            unint64_t v125 = *v174 + v124;
            if (__CFADD__(*v174, v124)) {
              goto LABEL_183;
            }
            uint64_t v23 = v27;
            if ((v125 & 0x8000000000000000) == 0)
            {
              size_t v126 = v124;
              unint64_t v127 = *v173;
              if (*v173 < v125)
              {
                do
                {
                  while (!v127)
                  {
                    unint64_t v127 = 0x4000;
                    size_t v129 = 0x4000;
                    if (v125 <= 0x4000) {
                      goto LABEL_195;
                    }
                  }
                  unint64_t v128 = v127 >> 1;
                  if ((v127 & (v127 >> 1)) != 0) {
                    unint64_t v128 = v127 & (v127 >> 1);
                  }
                  v127 += v128;
                }
                while (v127 < v125);
                size_t v129 = v127;
                if (v127 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_251;
                }
LABEL_195:
                uint64_t v163 = (void *)v124;
                __srcb = *v27;
                uint64_t v130 = realloc(*v27, v129);
                if (v130)
                {
                  const char *v27 = v130;
                  size_t *v173 = v129;
                  uint64_t v23 = v27;
                  size_t v126 = (size_t)v163;
                  goto LABEL_197;
                }
                free(__srcb);
LABEL_251:
                size_t v104 = 0;
                size_t *v174 = 0;
                v174[1] = 0;
                v174[2] = 0;
LABEL_183:
                uint64_t v23 = v27;
                goto LABEL_202;
              }
LABEL_197:
              uint64_t v131 = (char *)*v23;
              if (__nb)
              {
                memcpy(&v131[*v174], __nb, v126);
                uint64_t v23 = v27;
                uint64_t v132 = v174;
              }
              else
              {
                uint64_t v132 = v174;
                if (v131)
                {
                  memset_s(&v131[*v174], v126, 0, v126);
                  uint64_t v23 = v27;
                  uint64_t v132 = v174;
                }
              }
              size_t v104 = *v132 + v126;
              size_t *v132 = v104;
            }
LABEL_202:
            if (v166) {
              goto LABEL_224;
            }
            __nCC_SHA256_CTX c = (const void *)AAEntryYECBlobGetEncodedData((uint64_t)v176);
            uint64_t v133 = AAEntryYECBlobGetEncodedSize((uint64_t)v176);
            size_t v104 = *v174;
            unint64_t v134 = *v174 + v133;
            if (!__CFADD__(*v174, v133))
            {
              uint64_t v23 = v27;
              if ((v134 & 0x8000000000000000) != 0)
              {
LABEL_224:
                if ((v161 & 1) != 0
                  || (size_t v142 = size[0], v143 = __CFADD__(v104, size[0]), v144 = v104 + size[0], v143)
                  || (v144 & 0x8000000000000000) != 0)
                {
                  int v26 = 0;
                  BOOL v21 = 0;
                  goto LABEL_15;
                }
                uint64_t v145 = v182;
                unint64_t v146 = *v173;
                uint64_t __nd = size[0];
                if (*v173 >= v144)
                {
LABEL_240:
                  uint64_t v151 = (char *)*v23;
                  if (v145)
                  {
                    v152 = v174;
                    memcpy(&v151[*v174], v145, v142);
                    goto LABEL_244;
                  }
                  v152 = v174;
                  if (v151)
                  {
                    memset_s(&v151[*v174], v142, 0, __nd);
LABEL_244:
                    size_t v142 = __nd;
                    uint64_t v23 = v27;
                  }
                  int v26 = 0;
                  BOOL v21 = 0;
                  *v152 += v142;
                  goto LABEL_15;
                }
                do
                {
                  while (!v146)
                  {
                    unint64_t v146 = 0x4000;
                    size_t v148 = 0x4000;
                    if (v144 <= 0x4000) {
                      goto LABEL_238;
                    }
                  }
                  unint64_t v147 = v146 >> 1;
                  if ((v146 & (v146 >> 1)) != 0) {
                    unint64_t v147 = v146 & (v146 >> 1);
                  }
                  v146 += v147;
                }
                while (v146 < v144);
                size_t v148 = v146;
                if (v146 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_255;
                }
LABEL_238:
                size_t v165 = *v23;
                v167 = v182;
                uint64_t v149 = v23;
                char v150 = realloc(*v23, v148);
                if (v150)
                {
                  void *v149 = v150;
                  size_t v142 = __nd;
                  size_t *v173 = v148;
                  uint64_t v23 = v149;
                  uint64_t v145 = v167;
                  goto LABEL_240;
                }
                free(v165);
LABEL_255:
                int v26 = 0;
                BOOL v21 = 0;
                size_t *v174 = 0;
                v174[1] = 0;
                v174[2] = 0;
                goto LABEL_147;
              }
              size_t v135 = v133;
              unint64_t v136 = *v173;
              if (*v173 >= v134)
              {
LABEL_219:
                uint64_t v140 = (char *)*v23;
                if (__nc)
                {
                  memcpy(&v140[*v174], __nc, v135);
                  uint64_t v23 = v27;
                  uint64_t v141 = v174;
                }
                else
                {
                  uint64_t v141 = v174;
                  if (v140)
                  {
                    memset_s(&v140[*v174], v135, 0, v135);
                    uint64_t v23 = v27;
                    uint64_t v141 = v174;
                  }
                }
                size_t v104 = *v141 + v135;
                *uint64_t v141 = v104;
                goto LABEL_224;
              }
              do
              {
                while (!v136)
                {
                  unint64_t v136 = 0x4000;
                  size_t v138 = 0x4000;
                  if (v134 <= 0x4000) {
                    goto LABEL_217;
                  }
                }
                unint64_t v137 = v136 >> 1;
                if ((v136 & (v136 >> 1)) != 0) {
                  unint64_t v137 = v136 & (v136 >> 1);
                }
                v136 += v137;
              }
              while (v136 < v134);
              size_t v138 = v136;
              if (v136 >= 0x2000000001)
              {
                *__error() = 12;
                goto LABEL_253;
              }
LABEL_217:
              uint64_t v164 = *v27;
              uint64_t v139 = realloc(*v27, v138);
              if (v139)
              {
                const char *v27 = v139;
                size_t *v173 = v138;
                uint64_t v23 = v27;
                goto LABEL_219;
              }
              free(v164);
LABEL_253:
              size_t v104 = 0;
              size_t *v174 = 0;
              v174[1] = 0;
              v174[2] = 0;
            }
            uint64_t v23 = v27;
            goto LABEL_224;
          }
          if ((aaEntryYFPBlobInitWithPath(size, __s, path) & 0x80000000) == 0)
          {
            v62.ikey = 5260889;
            if ((AAHeaderSetFieldBlob(header, 0xFFFFFFFF, v62, size[0]) & 0x80000000) == 0)
            {
              int v161 = 0;
              goto LABEL_61;
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", 253, 14, 0, "inserting YFP: %s", v63, v64, (char)v186);
LABEL_146:
            BOOL v21 = 0;
            int v5 = 0;
            int v26 = 1;
            goto LABEL_147;
          }
          __int16 v43 = 251;
          uint64_t v44 = "initializing YFP field from path";
LABEL_145:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", v43, 14, 0, v44, v28, v29, (char)v154);
          goto LABEL_146;
        }
        uint64_t v154 = v186;
        __int16 v110 = 244;
        uint64_t v111 = "inserting YEC: %s";
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"appendPathListWorkerProc", v110, 14, 0, v111, v57, v58, (char)v154);
      BOOL v21 = 0;
      int v5 = 0;
      int v26 = 1;
    }
LABEL_147:
    uint64_t v23 = v27;
    goto LABEL_15;
  }
LABEL_256:
  AAHeaderDestroy(header);
  AAEntryXATBlobDestroy(v8);
  AAEntryACLBlobDestroy(v11);
  AAEntryYECBlobDestroy(v176);
  free(v182);
  memset_s(size, 0x18uLL, 0, 0x18uLL);
  if (v5) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

int AAArchiveStreamWritePathList(AAArchiveStream s, AAPathList path_list, AAFieldKeySet key_set, const char *dir, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  uint64_t v8 = MEMORY[0x270FA5388](s, path_list, key_set, dir, msg_data, msg_proc, flags, *(void *)&n_threads);
  int DefaultNThreads = v9;
  unint64_t v12 = v11;
  uint64_t v14 = v13;
  uint64_t v16 = v15;
  unint64_t v18 = v17;
  unint64_t v20 = v19;
  uint64_t v22 = v21;
  uint64_t v23 = (void *)v8;
  uint64_t v295 = *MEMORY[0x263EF8340];
  bzero(v280, 0x470uLL);
  double RealTime = getRealTime();
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  AAPathList v278 = v22;
  v279 = v20;
  unint64_t v284 = 1024;
  LODWORD(__count) = DefaultNThreads;
  unint64_t v277 = v12;
  uint64_t v281 = v16;
  uint64_t v282 = v14;
  if (!realpath_DARWIN_EXTSN(v18, v280))
  {
    int v28 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 375, 14, v28, "%s", v29, v30, (char)v18);
LABEL_19:
    uint64_t v42 = 0;
    __int16 v43 = 0;
    uint64_t v44 = 0;
LABEL_20:
    int v45 = 0;
    uint64_t v46 = 0;
    goto LABEL_21;
  }
  uint64_t v25 = AAPathListNodeFirst(v22);
  if (v25 != -1)
  {
    for (uint64_t i = v25; i != -1; uint64_t i = AAPathListNodeNext(v22, i))
      ++v283;
  }
  size_t v285 = (v283 + v284 - 1) / v284;
  size_t v27 = v283 << 7;
  if (v283 << 7 >= 0x2000000001)
  {
    *__error() = 12;
    v294 = 0;
LABEL_17:
    int v37 = *__error();
    AAFieldKey v40 = "malloc";
    __int16 v41 = 381;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v41, 14, v37, v40, v38, v39, (char)v238);
    goto LABEL_19;
  }
  uint64_t v31 = (char *)malloc(v27);
  v294 = v31;
  if (!v31) {
    goto LABEL_17;
  }
  memset(v31, 255, v27);
  uint64_t v32 = AAPathListNodeFirst(v22);
  if (v32 != -1)
  {
    uint64_t v33 = v32;
    uint64_t v34 = 24;
    do
    {
      *(void *)&v294[v34] = v33;
      uint64_t v33 = AAPathListNodeNext(v22, v33);
      v34 += 128;
    }
    while (v33 != -1);
  }
  if (is_mul_ok(v285, 0x28uLL) && 40 * v285 < 0x2000000001)
  {
    uint64_t v36 = (char *)calloc(v285, 0x28uLL);
  }
  else
  {
    AAFieldKey v35 = __error();
    uint64_t v36 = 0;
    *AAFieldKey v35 = 12;
  }
  v286 = v36;
  v288 = (char *)calloc(__count, 0x10uLL);
  uint64_t v54 = calloc(__count, 8uLL);
  v289 = v54;
  if (!v286 || !v288 || (uint64_t v55 = (uint64_t)v54) == 0)
  {
    int v37 = *__error();
    AAFieldKey v40 = "malloc";
    __int16 v41 = 389;
    goto LABEL_18;
  }
  uint64_t v56 = __count;
  if (__count)
  {
    uint64_t v57 = 0;
    do
    {
      uint64_t v58 = &v288[16 * v57];
      *(void *)uint64_t v58 = &v277;
      v289[v57++] = v58;
    }
    while (v57 != v56);
    uint64_t v55 = (uint64_t)v289;
  }
  uint64_t v44 = ThreadPoolCreate(v56, v55, (uint64_t)appendPathListWorkerProc);
  if (!v44)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 398, 14, 0, "ThreadPoolCreate", v64, v65, (char)v238);
    uint64_t v42 = 0;
    __int16 v43 = 0;
    goto LABEL_20;
  }
  if (v285)
  {
    unint64_t v66 = v12;
    uint64_t v67 = 0;
    unsigned int v68 = 1;
    while (1)
    {
      if (v290)
      {
LABEL_50:
        char v80 = 0;
        goto LABEL_57;
      }
      unint64_t v69 = v284;
      size_t v70 = v284 * v67;
      AAFieldKey v71 = &v286[40 * v67];
      *(void *)AAFieldKey v71 = v284 * v67;
      size_t v72 = v69 * v67 + v69;
      *((void *)v71 + 1) = v72;
      size_t v73 = v283;
      if (v70 >= v283) {
        *(void *)AAFieldKey v71 = v283;
      }
      if (v72 >= v73) {
        *((void *)v71 + 1) = v73;
      }
      uint64_t Worker = ThreadPoolGetWorker((uint64_t)v44, v59, v60, v61, v62, v63, v64, v65);
      if (!Worker)
      {
        AAFieldKey v81 = "ThreadPoolGetWorker";
        __int16 v82 = 410;
        goto LABEL_56;
      }
      *(void *)(Worker + 8) = v67;
      if ((ThreadPoolRunWorker((uint64_t)v44, Worker, v75, v76, v77, v78, v64, v65) & 0x80000000) != 0) {
        break;
      }
      uint64_t v67 = v68;
      BOOL v79 = v285 > v68++;
      if (!v79) {
        goto LABEL_50;
      }
    }
    AAFieldKey v81 = "ThreadPoolRunWorker";
    __int16 v82 = 412;
LABEL_56:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v82, 14, 0, v81, v64, v65, (char)v238);
    char v80 = 1;
LABEL_57:
    unint64_t v12 = v66;
  }
  else
  {
    char v80 = 0;
  }
  if ((ThreadPoolDestroy((uint64_t)v44) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 416, 14, 0, "ThreadPoolDestroy", v38, v39, (char)v238);
    if (!atomic_load(&v290)) {
      goto LABEL_19;
    }
LABEL_78:
    unint64_t v98 = (void (*)(void))v23[2];
    if (v98) {
      v98(*v23);
    }
    goto LABEL_19;
  }
  if (atomic_load(&v290)) {
    goto LABEL_78;
  }
  if (v80) {
    goto LABEL_19;
  }
  unint64_t v251 = v12;
  v252 = v23;
  size_t v84 = v285;
  if (v285)
  {
    unint64_t v85 = 0;
    uint64_t v86 = 0;
    AAFieldKey v87 = v286;
    uint32_t v88 = v294;
    do
    {
      unsigned int v89 = &v87[40 * v86];
      unint64_t v91 = *(void *)v89;
      unint64_t v90 = *((void *)v89 + 1);
      BOOL v79 = v90 > v91;
      unint64_t v92 = v90 - v91;
      if (v79)
      {
        long long v93 = &v88[128 * v91];
        do
        {
          *(void *)v93 += v85;
          v93 += 128;
          --v92;
        }
        while (v92);
      }
      v85 += *(void *)&v87[40 * v86++ + 16];
    }
    while (v86 != v84);
    if ((v85 & 0x8000000000000000) == 0)
    {
      size_t v94 = v292;
      if (v292 >= v85)
      {
        size_t v99 = 1;
        goto LABEL_86;
      }
      do
      {
        while (!v94)
        {
          size_t v94 = 0x4000;
          if (v85 <= 0x4000)
          {
            uint64_t v96 = v293;
            size_t v94 = 0x4000;
            goto LABEL_84;
          }
        }
        size_t v95 = v94 >> 1;
        if ((v94 & (v94 >> 1)) != 0) {
          size_t v95 = v94 & (v94 >> 1);
        }
        v94 += v95;
      }
      while (v94 < v85);
      if (v94 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_272;
      }
      uint64_t v96 = v293;
LABEL_84:
      unint64_t v100 = (char *)realloc(v96, v94);
      if (v100)
      {
        v293 = v100;
        unint64_t v292 = v94;
        size_t v99 = v285;
LABEL_86:
        if (v99)
        {
          size_t v101 = 0;
          do
          {
            unint64_t v102 = &v286[40 * v101];
            size_t v103 = *((void *)v102 + 2);
            unint64_t v104 = v291 + v103;
            if (!__CFADD__(v291, v103) && (v104 & 0x8000000000000000) == 0)
            {
              unint64_t v105 = (const void *)*((void *)v102 + 4);
              size_t v106 = v292;
              if (v292 >= v104)
              {
LABEL_103:
                if (v105)
                {
                  memcpy(&v293[v291], v105, v103);
                }
                else if (v293)
                {
                  memset_s(&v293[v291], v103, 0, v103);
                }
                v291 += v103;
              }
              else
              {
                do
                {
                  while (!v106)
                  {
                    size_t v106 = 0x4000;
                    if (v104 <= 0x4000)
                    {
                      unint64_t v108 = v293;
                      size_t v106 = 0x4000;
                      goto LABEL_101;
                    }
                  }
                  size_t v107 = v106 >> 1;
                  if ((v106 & (v106 >> 1)) != 0) {
                    size_t v107 = v106 & (v106 >> 1);
                  }
                  v106 += v107;
                }
                while (v106 < v104);
                if (v106 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_109;
                }
                unint64_t v108 = v293;
LABEL_101:
                size_t v109 = v108;
                __int16 v110 = (char *)realloc(v108, v106);
                if (v110)
                {
                  v293 = v110;
                  unint64_t v292 = v106;
                  goto LABEL_103;
                }
                free(v109);
LABEL_109:
                unint64_t v291 = 0;
                unint64_t v292 = 0;
                v293 = 0;
              }
            }
            uint64_t v111 = (void **)&v286[40 * v101];
            uint64_t v112 = v111 + 2;
            free(v111[4]);
            memset_s(v112, 0x18uLL, 0, 0x18uLL);
            ++v101;
          }
          while (v101 < v285);
        }
        goto LABEL_111;
      }
      free(v96);
LABEL_272:
      v293 = 0;
      unint64_t v291 = 0;
      unint64_t v292 = 0;
    }
    AAFieldKey v40 = "allocating final blob";
    __int16 v41 = 430;
    int v37 = 0;
    goto LABEL_18;
  }
LABEL_111:
  v113.uint64_t ikey = 4410440;
  if (AAFieldKeySetContainsKey(v20, v113))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_hlc);
    unint64_t v114 = v283;
    if (v283)
    {
      uint64_t v115 = 0;
      uint64_t v116 = 0;
      uint64_t v117 = 0;
      unint64_t v118 = v294;
      while (1)
      {
        unint64_t v119 = &v118[128 * v116];
        uint64_t v122 = *((void *)v119 + 4);
        size_t v120 = v119 + 32;
        uint64_t v121 = v122;
        if (v122 == -1)
        {
LABEL_128:
          uint64_t v250 = v117;
          uint64_t v254 = v115;
          goto LABEL_131;
        }
        unint64_t v123 = v116 + 1;
        if (v116 + 1 < v114)
        {
          uint64_t v124 = 1;
          unint64_t v125 = &v118[128 * v116 + 160];
          while (1)
          {
            uint64_t v126 = *(void *)v125;
            v125 += 128;
            if (v126 != v121) {
              break;
            }
            ++v124;
            if (!(v116 - v114 + v124))
            {
              uint64_t v124 = v114 - v116;
              unint64_t v123 = v114;
              goto LABEL_121;
            }
          }
          unint64_t v123 = v116 + v124;
LABEL_121:
          if (!v124) {
            goto LABEL_126;
          }
          if (v124 != 1) {
            break;
          }
        }
        *size_t v120 = -1;
LABEL_127:
        uint64_t v116 = v123;
        if (v123 >= v114) {
          goto LABEL_128;
        }
      }
      uint64_t v127 = v124;
      do
      {
        *size_t v120 = v115;
        v120 += 16;
        --v127;
      }
      while (v127);
LABEL_126:
      ++v115;
      v117 += v124;
      goto LABEL_127;
    }
    uint64_t v254 = 0;
    uint64_t v250 = 0;
LABEL_131:
    int v128 = 1;
  }
  else
  {
    uint64_t v254 = 0;
    uint64_t v250 = 0;
    int v128 = 0;
  }
  v129.uint64_t ikey = 4410435;
  if (AAFieldKeySetContainsKey(v20, v129))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_clc);
    unint64_t v130 = v283;
    if (v283)
    {
      uint64_t v131 = 0;
      uint64_t v132 = 0;
      uint64_t v133 = 0;
      unint64_t v134 = v294;
      while (1)
      {
        size_t v135 = &v134[128 * v132];
        uint64_t v138 = *((void *)v135 + 5);
        unint64_t v136 = v135 + 40;
        uint64_t v137 = v138;
        if (v138 == -1)
        {
LABEL_149:
          uint64_t v249 = v133;
          uint64_t v253 = v131;
          goto LABEL_152;
        }
        unint64_t v139 = v132 + 1;
        if (v132 + 1 < v130)
        {
          uint64_t v140 = 1;
          uint64_t v141 = &v134[128 * v132 + 168];
          while (1)
          {
            uint64_t v142 = *(void *)v141;
            v141 += 128;
            if (v142 != v137) {
              break;
            }
            ++v140;
            if (!(v132 - v130 + v140))
            {
              uint64_t v140 = v130 - v132;
              unint64_t v139 = v130;
              goto LABEL_142;
            }
          }
          unint64_t v139 = v132 + v140;
LABEL_142:
          if (!v140) {
            goto LABEL_147;
          }
          if (v140 != 1) {
            break;
          }
        }
        *unint64_t v136 = -1;
LABEL_148:
        uint64_t v132 = v139;
        if (v139 >= v130) {
          goto LABEL_149;
        }
      }
      uint64_t v143 = v140;
      do
      {
        *unint64_t v136 = v131;
        v136 += 16;
        --v143;
      }
      while (v143);
LABEL_147:
      ++v131;
      v133 += v140;
      goto LABEL_148;
    }
    uint64_t v253 = 0;
    uint64_t v249 = 0;
LABEL_152:
    int v128 = 1;
  }
  else
  {
    uint64_t v253 = 0;
    uint64_t v249 = 0;
  }
  v144.uint64_t ikey = 4410451;
  if (AAFieldKeySetContainsKey(v20, v144))
  {
    qsort(v294, v283, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_slc);
    v145.uint64_t ikey = 3295315;
    BOOL v255 = 1;
    if (!AAFieldKeySetContainsKey(v20, v145))
    {
      v146.uint64_t ikey = 3360851;
      if (!AAFieldKeySetContainsKey(v20, v146))
      {
        v147.uint64_t ikey = 3491923;
        if (!AAFieldKeySetContainsKey(v20, v147)) {
          BOOL v255 = 0;
        }
      }
    }
    size_t v148 = v283;
    if (v283)
    {
      uint64_t v149 = 0;
      size_t v150 = 0;
      uint64_t v257 = 0;
      v258 = v20;
      int v47 = 1;
      while (1)
      {
        uint64_t v151 = v294;
        v152 = &v294[128 * v150];
        uint64_t v154 = *((void *)v152 + 6);
        unint64_t v153 = v152 + 48;
        if (v154 == -1) {
          goto LABEL_189;
        }
        size_t v155 = v150 + 1;
        if (v150 + 1 >= v148) {
          goto LABEL_168;
        }
        size_t v263 = v148;
        size_t v265 = v150 + 1;
        *(void *)v267 = v150;
        uint64_t v270 = v149;
        int v156 = &v294[128 * v150 + 56];
        unint64_t v261 = v148 - v150;
        size_t v259 = v150 << 7;
        v157 = &v294[128 * v150 + 184];
        size_t v158 = v150 - v148;
        unint64_t v159 = 1;
        while (!memcmp(v156, v157, 0x40uLL))
        {
          ++v159;
          v157 += 128;
          if (!(v158 + v159))
          {
            unint64_t v159 = v261;
            unint64_t v160 = v263;
            size_t v161 = *(void *)v267;
            goto LABEL_167;
          }
        }
        size_t v161 = *(void *)v267;
        unint64_t v160 = *(void *)v267 + v159;
LABEL_167:
        unint64_t v162 = v159 - 1;
        unint64_t v20 = v258;
        uint64_t v149 = v270;
        size_t v155 = v265;
        if (v159 == 1)
        {
LABEL_168:
          *unint64_t v153 = -1;
          size_t v150 = v155;
        }
        else
        {
          size_t v163 = v160;
          if (v255) {
            goto LABEL_178;
          }
          uint64_t v164 = *(void *)&v151[128 * v161 + 24];
          size_t v165 = v161;
          if ((AAPathListNodeGetPath(v22, v164, 0x400uLL, path, 0) & 0x80000000) == 0)
          {
            if (v159 >= 2)
            {
              size_t v168 = v259 + 152;
              do
              {
                if (AAPathListNodeGetPath(v22, *(void *)&v294[v168], 0x400uLL, v276, 0) < 0)
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 528, 14, 0, "AAPathListNodeGetPath", v169, v170, (char)v238);
                  int v47 = 0;
                }
                else if ((int)areFilesEqual2() < 1)
                {
                  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 529, 14, "Hash collision detected: %s != %s", v171, v172, v173, (char)path);
                  uint64_t v175 = 0;
                  uint64_t v176 = -1;
                  goto LABEL_179;
                }
                v168 += 128;
                --v162;
              }
              while (v162);
            }
LABEL_178:
            v257 += v159;
            uint64_t v175 = 1;
            uint64_t v176 = v270;
LABEL_179:
            uint64_t v149 = v270 + v175;
            if (v159)
            {
              v174 = (uint64_t *)&v294[v259 + 48];
              do
              {
                uint64_t *v174 = v176;
                v174 += 16;
                --v159;
              }
              while (v159);
            }
            size_t v150 = v163;
            goto LABEL_183;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 525, 14, 0, "AAPathListNodeGetPath", v166, v167, (char)v238);
          int v47 = 0;
          size_t v150 = v165;
        }
LABEL_183:
        size_t v148 = v283;
        if (v150 >= v283) {
          goto LABEL_189;
        }
      }
    }
    uint64_t v257 = 0;
    uint64_t v149 = 0;
    int v47 = 1;
  }
  else
  {
    if (!v128)
    {
      uint64_t v257 = 0;
      uint64_t v149 = 0;
      int v47 = 1;
      goto LABEL_190;
    }
    uint64_t v257 = 0;
    uint64_t v149 = 0;
    int v47 = 1;
    size_t v148 = v283;
  }
LABEL_189:
  qsort(v294, v148, 0x80uLL, (int (__cdecl *)(const void *, const void *))cmp_entries_offset);
LABEL_190:
  if ((unint64_t)(v254 + 1) < 0x2000000001)
  {
    uint64_t v46 = calloc(v254 + 1, 1uLL);
  }
  else
  {
    uint64_t v46 = 0;
    *__error() = 12;
  }
  if ((unint64_t)(v253 + 1) < 0x2000000001)
  {
    int v45 = calloc(v253 + 1, 1uLL);
  }
  else
  {
    int v45 = 0;
    *__error() = 12;
  }
  if ((unint64_t)(v149 + 1) >= 0x2000000001)
  {
    uint64_t v44 = 0;
    *__error() = 12;
LABEL_198:
    v177 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 556, 14, *v177, "malloc", v178, v179, (char)v238);
    uint64_t v42 = 0;
    __int16 v43 = 0;
    goto LABEL_21;
  }
  v180 = (unsigned int *)calloc(v149 + 1, 1uLL);
  uint64_t v44 = v180;
  if (!v46 || !v45 || !v180) {
    goto LABEL_198;
  }
  __int16 v43 = AAHeaderCreate();
  if (!v43)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 560, 14, 0, "Header creation", v181, v182, (char)v238);
    uint64_t v42 = 0;
    goto LABEL_21;
  }
  uint64_t v42 = malloc(0x40000uLL);
  if (!v42)
  {
    int v226 = *__error();
    v227 = "malloc";
    __int16 v228 = 562;
LABEL_313:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v228, 14, v226, v227, v183, v184, (char)v238);
    goto LABEL_21;
  }
  uint64_t v271 = v149;
  if (!v283)
  {
    int v264 = 0;
    int v262 = 0;
    int v266 = 0;
    uint64_t v242 = 0;
LABEL_276:
    double v229 = getRealTime();
    if (v251 >> 62)
    {
      double v230 = v229;
      v231 = (FILE **)MEMORY[0x263EF8348];
      fwrite("Archive path list\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      bzero(path, 0x400uLL);
      if (!AAFieldKeySetSerialize(v20, 0x400uLL, path)) {
        fprintf(*v231, "%12s %s\n", "fields", path);
      }
      fprintf(*v231, "%12llu entries\n", v283);
      if (v254) {
        fprintf(*v231, "%12llu entries in %llu hard link clusters (HLC)\n", v250, v254);
      }
      if (v253) {
        fprintf(*v231, "%12llu entries in %llu clone clusters (CLC)\n", v249, v253);
      }
      if (v271) {
        fprintf(*v231, "%12llu entries in %llu same data clusters (SLC)\n", v257, v271);
      }
      if (v262) {
        fprintf(*v231, "%12u entries with XAT field\n", v262);
      }
      if (v266) {
        fprintf(*v231, "%12u entries with ACL field\n", v266);
      }
      double v232 = v230 - RealTime;
      if (v264) {
        fprintf(*v231, "%12u entries with YEC field\n", v266);
      }
      fprintf(*v231, "%12llu bytes in regular files DAT\n", v242);
      fprintf(*v231, "%12.2f time (s)\n", v232);
    }
    goto LABEL_22;
  }
  size_t v185 = 0;
  uint64_t v242 = 0;
  int v266 = 0;
  int v262 = 0;
  int v264 = 0;
  int v186 = 0;
  while (1)
  {
    v187 = v294;
    *(void *)v268 = v185;
    uint64_t v188 = &v294[128 * v185];
    unint64_t v190 = *(void *)v188;
    unint64_t v189 = *((void *)v188 + 1);
    unint64_t v191 = *((void *)v188 + 2);
    uint64_t v256 = v189 - v191;
    if (v189 < v191 || v190 >= v291)
    {
      v227 = "invalid header blob size";
      __int16 v228 = 570;
LABEL_312:
      int v226 = 0;
      goto LABEL_313;
    }
    uint64_t v244 = *((void *)v188 + 2);
    unint64_t v246 = *(void *)v188;
    if ((aaHeaderInitWithEncodedData((uint64_t)v43, (unsigned __int16 *)&v293[v190], v191) & 0x80000000) != 0)
    {
      v227 = "parse stored header";
      __int16 v228 = 571;
      goto LABEL_312;
    }
    if ((v251 & 2) != 0)
    {
      v193 = &v187[128 * *(void *)v268];
      uint64_t v194 = *((void *)v193 + 4);
      if (v194 == -1)
      {
        uint64_t v195 = *((void *)v193 + 5);
        if (v195 == -1)
        {
          uint64_t v196 = *(void *)&v187[128 * *(void *)v268 + 48];
          if (v196 == -1) {
            goto LABEL_222;
          }
          if (!*((unsigned char *)v44 + v196))
          {
            *((unsigned char *)v44 + v196) = 1;
            goto LABEL_222;
          }
        }
        else if (!v45[v195])
        {
          v45[v195] = 1;
          goto LABEL_222;
        }
      }
      else if (!v46[v194])
      {
        v46[v194] = 1;
        goto LABEL_222;
      }
      v197.uint64_t ikey = 5521732;
      uint32_t KeyIndex = AAHeaderGetKeyIndex(v43, v197);
      if ((KeyIndex & 0x80000000) == 0) {
        AAHeaderRemoveField(v43, KeyIndex);
      }
    }
LABEL_222:
    int v241 = v186;
    v199 = &v187[128 * *(void *)v268];
    uint64_t v200 = *((void *)v199 + 4);
    if (v200 != -1)
    {
      v201.uint64_t ikey = 4410440;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v201, v200) < 0)
      {
        v227 = "add HLC field";
        __int16 v228 = 605;
        goto LABEL_312;
      }
    }
    uint64_t v202 = *((void *)v199 + 5);
    if (v202 != -1)
    {
      v203.uint64_t ikey = 4410435;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v203, v202) < 0)
      {
        v227 = "add CLC field";
        __int16 v228 = 606;
        goto LABEL_312;
      }
    }
    uint64_t v204 = *(void *)&v187[128 * *(void *)v268 + 48];
    if (v204 != -1)
    {
      v205.uint64_t ikey = 4410451;
      if (AAHeaderSetFieldUInt(v43, 0xFFFFFFFF, v205, v204) < 0)
      {
        v227 = "add SLC field";
        __int16 v228 = 607;
        goto LABEL_312;
      }
    }
    v206 = (uint64_t (*)(void, AAHeader_impl *))v252[3];
    if (!v206 || (v206(*v252, v43) & 0x80000000) != 0)
    {
      v227 = "encoding header";
      __int16 v228 = 610;
      goto LABEL_312;
    }
    uint32_t FieldCount = AAHeaderGetFieldCount(v43);
    if (FieldCount) {
      break;
    }
LABEL_265:
    if (v256)
    {
      v227 = "blob byte count mismatch";
      __int16 v228 = 681;
      goto LABEL_312;
    }
    size_t v185 = (v241 + 1);
    int v186 = v241 + 1;
    if (v283 <= v185) {
      goto LABEL_276;
    }
  }
  uint64_t v260 = 0;
  uint64_t v247 = v244 + v246;
  v207 = &v187[128 * *(void *)v268];
  uint32_t v208 = 0;
  v240 = (uint64_t *)(v207 + 24);
  while (AAHeaderGetFieldType(v43, v208) != 5)
  {
LABEL_264:
    if (++v208 == FieldCount) {
      goto LABEL_265;
    }
  }
  uint64_t size = 0;
  uint64_t offset = 0;
  AAFieldKey FieldKey = AAHeaderGetFieldKey(v43, v208);
  uint32_t v210 = v208;
  AAFieldKey v211 = FieldKey;
  AAFieldKey v272 = FieldKey;
  uint32_t v243 = v210;
  if (AAHeaderGetFieldBlob(v43, v210, &size, &offset) < 0)
  {
    v227 = "get blob location";
    __int16 v228 = 622;
    goto LABEL_312;
  }
  if (v260 != offset)
  {
    v227 = "blob segment mismatch";
    __int16 v228 = 623;
    goto LABEL_312;
  }
  int v212 = v211.ikey & 0xFFFFFF;
  if ((v211.ikey & 0xFFFFFF) == 0x4C4341) {
    int v213 = v266 + 1;
  }
  else {
    int v213 = v266;
  }
  int v266 = v213;
  if (v212 == 5521752) {
    int v214 = v262 + 1;
  }
  else {
    int v214 = v262;
  }
  int v262 = v214;
  int v215 = v264;
  if (v212 == 4408665) {
    int v215 = v264 + 1;
  }
  int v264 = v215;
  if (v212 != 5521732)
  {
    if (size > v256)
    {
      v238 = &v272;
      v227 = "Blob segment out of range, key=%s";
      __int16 v228 = 667;
      goto LABEL_312;
    }
    v225 = (uint64_t (*)(void, void, char *))v252[4];
    if (!v225 || (v225(*v252, v211.ikey, &v293[v247]) & 0x80000000) != 0)
    {
      v227 = "sending blob data";
      __int16 v228 = 668;
      goto LABEL_312;
    }
    uint64_t v224 = size;
    v247 += size;
    v256 -= size;
    goto LABEL_263;
  }
  uint64_t v239 = size;
  if (AAPathListNodeGetPath(v278, *v240, 0x400uLL, v276, 0) < 0)
  {
    v227 = "getting entry path";
    __int16 v228 = 638;
    goto LABEL_312;
  }
  if ((concatPath(path, 0x800uLL, v280, v276) & 0x80000000) != 0)
  {
    v227 = "getting entry full path";
    __int16 v228 = 639;
    goto LABEL_312;
  }
  int v269 = open(path, 0);
  if (v269 < 0)
  {
    int v226 = *__error();
    v238 = (AAFieldKey *)path;
    v227 = "%s";
    __int16 v228 = 641;
    goto LABEL_313;
  }
  uint64_t v216 = size;
  if (!size)
  {
LABEL_257:
    close(v269);
    if (!v47) {
      goto LABEL_21;
    }
    v242 += v239;
    int v47 = 1;
    uint64_t v224 = size;
LABEL_263:
    v260 += v224;
    uint32_t v208 = v243;
    goto LABEL_264;
  }
  uint64_t v217 = 0;
  uint64_t ikey = v211.ikey;
  while (1)
  {
    if (v217 + 0x40000 <= v216) {
      size_t v218 = 0x40000;
    }
    else {
      size_t v218 = v216 - v217;
    }
    ssize_t v219 = read(v269, v42, v218);
    if (v219 < 0)
    {
      int v235 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 651, 14, v235, "read: %s", v236, v237, (char)path);
      goto LABEL_297;
    }
    ssize_t v222 = v219;
    if (!v219) {
      break;
    }
    v223 = (uint64_t (*)(void, uint64_t, void *, ssize_t))v252[4];
    if (!v223 || (v223(*v252, ikey, v42, v219) & 0x80000000) != 0)
    {
      v233 = "sending blob data";
      __int16 v234 = 653;
      goto LABEL_296;
    }
    v217 += v222;
    uint64_t v216 = size;
    if (v217 >= size) {
      goto LABEL_257;
    }
  }
  v238 = (AAFieldKey *)path;
  v233 = "truncated: %s";
  __int16 v234 = 652;
LABEL_296:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", v234, 14, 0, v233, v220, v221, (char)v238);
LABEL_297:
  close(v269);
LABEL_21:
  int v47 = 0;
LABEL_22:
  if ((ThreadPoolDestroy(0) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveStream.c", (uint64_t)"AAArchiveStreamWritePathList", 705, 14, 0, "ThreadPoolDestroy", v48, v49, (char)v238);
    int v47 = 0;
  }
  if (v286 && v285)
  {
    size_t v50 = 0;
    uint64_t v51 = 32;
    do
    {
      size_t v52 = &v286[v51 - 16];
      free(*(void **)&v286[v51]);
      memset_s(v52, 0x18uLL, 0, 0x18uLL);
      ++v50;
      v51 += 40;
    }
    while (v50 < v285);
  }
  free(v289);
  free(v288);
  free(v286);
  free(v294);
  free(v42);
  free(v46);
  free(v45);
  free(v44);
  AAHeaderDestroy(v43);
  free(v293);
  memset_s(&v291, 0x18uLL, 0, 0x18uLL);
  if (v47) {
    return 0;
  }
  else {
    return -1;
  }
}

uint64_t cmp_entries_hlc(void *a1, void *a2)
{
  unint64_t v4 = a1[4];
  unint64_t v2 = a2[4];
  BOOL v3 = v4 >= v2;
  LODWORD(v4) = v4 != v2;
  if (v3) {
    unint64_t v4 = v4;
  }
  else {
    unint64_t v4 = 0xFFFFFFFFLL;
  }
  if (!v4)
  {
    if (*a1 < *a2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *a1 != *a2;
    }
  }
  return v4;
}

uint64_t cmp_entries_clc(void *a1, void *a2)
{
  unint64_t v4 = a1[5];
  unint64_t v2 = a2[5];
  BOOL v3 = v4 >= v2;
  LODWORD(v4) = v4 != v2;
  if (v3) {
    unint64_t v4 = v4;
  }
  else {
    unint64_t v4 = 0xFFFFFFFFLL;
  }
  if (!v4)
  {
    if (*a1 < *a2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *a1 != *a2;
    }
  }
  return v4;
}

uint64_t cmp_entries_slc(void *a1, void *a2)
{
  unint64_t v3 = a1[6];
  unint64_t v4 = a2[6];
  BOOL v5 = v3 >= v4;
  BOOL v6 = v3 != v4;
  if (v5) {
    uint64_t result = v6;
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  if (!result)
  {
    uint64_t result = memcmp(a1 + 7, a2 + 7, 0x40uLL);
    if (!result)
    {
      if (*a1 < *a2) {
        return 0xFFFFFFFFLL;
      }
      else {
        return *a1 != *a2;
      }
    }
  }
  return result;
}

uint64_t cmp_entries_offset(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

AAByteStream AEADecryptionRandomAccessInputStreamOpen(AAByteStream encrypted_stream, AEAContext context, size_t alloc_limit, AAFlagSet flags, int n_threads)
{
  unsigned int DefaultNThreads = n_threads;
  if (n_threads <= 0) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((_DWORD *)context + 684) || !*((void *)context + 341))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionRandomAccessInputStreamOpen", 90, 32, 0, "Invalid context", v5, v6, v34);
    uint64_t v12 = 0;
    goto LABEL_28;
  }
  unint64_t v11 = malloc(0x38uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11)
  {
    int v31 = *__error();
    uint64_t v32 = "malloc";
    __int16 v33 = 94;
    goto LABEL_27;
  }
  memset_s(v11, 0x38uLL, 0, 0x38uLL);
  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  if ((flags & 0x400000000000000) != 0) {
    *((_DWORD *)context + 685) = 1;
  }
  uint64_t Existing = aeaContainerCreateExisting((uint64_t)context, encrypted_stream, 1, 0);
  *(void *)(v12 + 16) = Existing;
  if (!Existing)
  {
    uint64_t v32 = "unlock container";
    __int16 v33 = 106;
    int v31 = 0;
    goto LABEL_27;
  }
  *(_DWORD *)(v12 + 24) = DefaultNThreads;
  uint64_t v16 = calloc(DefaultNThreads, 0x10uLL);
  *(void *)(v12 + 32) = v16;
  if (!v16)
  {
    int v31 = *__error();
    uint64_t v32 = "malloc";
    __int16 v33 = 111;
    goto LABEL_27;
  }
  uint64_t v17 = *(void *)(v12 + 16);
  uint64_t v18 = *(unsigned int *)(v17 + 24);
  if (v18)
  {
    compression_algorithm v19 = aeaEffectiveCompressionAlgorithm(v18);
    *(void *)(v12 + 40) = compression_decode_scratch_buffer_size(v19);
    uint64_t v17 = *(void *)(v12 + 16);
  }
  unsigned int v20 = *(_DWORD *)(v12 + 24);
  if (!v20)
  {
LABEL_19:
    *(_OWORD *)context = *(_OWORD *)v17;
    long long v27 = *(_OWORD *)(v17 + 16);
    long long v28 = *(_OWORD *)(v17 + 32);
    long long v29 = *(_OWORD *)(v17 + 48);
    *((void *)context + 8) = *(void *)(v17 + 64);
    *((_OWORD *)context + 2) = v28;
    *((_OWORD *)context + 3) = v29;
    *((_OWORD *)context + 1) = v27;
    return (AAByteStream)AAGenericRandomAccessInputStreamOpen(*(void *)(v17 + 32), *(_DWORD *)(v17 + 16), v20, 4 * v20, v12, (uint64_t)RandomAccessDecryptionStreamGetBlock, (uint64_t)RandomAccessDecryptionStreamAbort, (uint64_t)RandomAccessDecryptionStreamDestroy, flags);
  }
  BOOL v21 = *(void **)(v12 + 32);
  size_t v22 = *(unsigned int *)(v17 + 16);
  uint64_t v23 = *(unsigned int *)(v12 + 24);
  while (1)
  {
    uint64_t v24 = malloc(v22);
    v21[1] = v24;
    if (!v24)
    {
      int v31 = *__error();
      uint64_t v32 = "malloc";
      __int16 v33 = 120;
      goto LABEL_27;
    }
    size_t v25 = *(void *)(v12 + 40);
    if (!v25) {
      goto LABEL_18;
    }
    if (v25 >= 0x2000000001) {
      break;
    }
    int v26 = malloc(v25);
    void *v21 = v26;
    if (!v26) {
      goto LABEL_26;
    }
LABEL_18:
    v21 += 2;
    if (!--v23) {
      goto LABEL_19;
    }
  }
  *__error() = 12;
  void *v21 = 0;
LABEL_26:
  int v31 = *__error();
  uint64_t v32 = "malloc";
  __int16 v33 = 124;
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionRandomAccessInputStreamOpen", v33, 32, v31, v32, v14, v15, v34);
LABEL_28:
  RandomAccessDecryptionStreamDestroy(v12);
  return 0;
}

uint64_t RandomAccessDecryptionStreamDestroy(uint64_t a1)
{
  if (a1)
  {
    unint64_t v2 = *(void **)(a1 + 32);
    if (!v2)
    {
LABEL_15:
      aeaContainerDestroy(*(void *)(a1 + 16));
      memset_s((void *)a1, 0x38uLL, 0, 0x38uLL);
      free((void *)a1);
      return 0;
    }
    if (*(_DWORD *)(a1 + 24))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(void *)(a1 + 32) + v3;
        uint64_t v6 = *(void **)(v5 + 8);
        if (v6)
        {
          rsize_t v7 = *(unsigned int *)(*(void *)(a1 + 16) + 16);
          memset_s(v6, v7, 0, v7);
        }
        free(v6);
        uint64_t v8 = *(void **)v5;
        if (*(void *)v5) {
          memset_s(*(void **)v5, *(void *)(a1 + 40), 0, *(void *)(a1 + 40));
        }
        free(v8);
        ++v4;
        unint64_t v9 = *(unsigned int *)(a1 + 24);
        v3 += 16;
      }
      while (v4 < v9);
      unint64_t v2 = *(void **)(a1 + 32);
      if (!v2) {
        goto LABEL_14;
      }
      rsize_t v10 = 16 * v9;
    }
    else
    {
      rsize_t v10 = 0;
    }
    memset_s(v2, v10, 0, v10);
LABEL_14:
    free(v2);
    goto LABEL_15;
  }
  return 0;
}

uint64_t RandomAccessDecryptionStreamGetBlock(uint64_t a1, unsigned int a2, unint64_t a3, uint8_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 24) > a2 && *(unsigned int *)(*(void *)(a1 + 16) + 400) > a3)
  {
    uint64_t v8 = *(void *)(a1 + 32) + 16 * a2;
    if ((aeaContainerLoadSegment(*(void *)(a1 + 16), *(void **)a1, a3, a4, *(const uint8_t **)(v8 + 8), *(void **)v8, a7, a8) & 0x8000000000000000) == 0)return 0; {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEARandomAccessDecryptionStream.c", (uint64_t)"RandomAccessDecryptionStreamGetBlock", 71, 32, 0, "Loading segment", v9, v10, vars0);
    }
  }
  return 0xFFFFFFFFLL;
}

void RandomAccessDecryptionStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = 1;
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t aaAssetDecodeStreamDone(uint64_t (**a1)(uint64_t result), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[1] == closeProc) {
    return *((_DWORD *)*a1 + 8) == 4;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamDone", 410, 131, 0, "invalid stream", a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t closeProc(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 8));
    uint64_t v3 = (void *)(result + 64);
    free(*(void **)(result + 80));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    AAHeaderDestroy(*(AAHeader *)(v1 + 88));
    free(*(void **)(v1 + 112));
    memset_s((void *)(v1 + 104), 0x10uLL, 0, 0x10uLL);
    unint64_t v4 = *(void (***)(void))(v1 + 128);
    if (v4)
    {
      if (*v4) {
        v4[1]();
      }
      free(v4);
    }
    uint64_t v5 = *(void (***)(void))(v1 + 136);
    if (v5)
    {
      if (*v5) {
        v5[1]();
      }
      free(v5);
    }
    memset_s((void *)v1, 0x90uLL, 0, 0x90uLL);
    free((void *)v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t aaAssetDecodeStreamSetParameterPtr(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((uint64_t (*)(uint64_t))a1[1] == closeProc)
  {
    uint64_t v9 = *a1;
    if (a2 == 103)
    {
      uint64_t result = 0;
      *(void *)(v9 + 24) = a3;
      return result;
    }
    if (a2 == 101)
    {
      uint64_t result = 0;
      *(void *)(v9 + 16) = a3;
      return result;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamSetParameterPtr", 420, 131, 0, "invalid stream", a7, a8, vars0);
  }
  return 0xFFFFFFFFLL;
}

void *aaAssetDecodeStreamOpen(uint64_t a1)
{
  unsigned int v2 = malloc(0x90uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 443;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpen", v11, 131, v9, v10, v5, v6, v13);
    closeProc((uint64_t)v3);
    return 0;
  }
  memset_s(v2, 0x90uLL, 0, 0x90uLL);
  *uint64_t v3 = a1;
  unint64_t v4 = AAHeaderCreate();
  v3[11] = v4;
  if (!v4)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 446;
    goto LABEL_10;
  }
  if ((aaHeaderBlobArrayInitWithHeader((uint64_t)(v3 + 13), v4) & 0x80000000) != 0)
  {
    uint64_t v10 = "blob array init";
    __int16 v11 = 447;
    int v9 = 0;
    goto LABEL_10;
  }
  v3[6] = -1;
  rsize_t v7 = malloc(0x38uLL);
  if (!v7)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 452;
    goto LABEL_10;
  }
  uint64_t v8 = v7;
  memset_s(v7, 0x38uLL, 0, 0x38uLL);
  *uint64_t v8 = v3;
  v8[1] = closeProc;
  v8[6] = closeWithStateProc;
  v8[3] = writeProc;
  v8[2] = cancelProc;
  return v8;
}

uint64_t closeWithStateProc(uint64_t a1, void *a2, void *a3)
{
  if (!a1) {
    return 0;
  }
  if (atomic_load((unsigned int *)(a1 + 8))) {
    return 0xFFFFFFFFLL;
  }
  int v8 = *(_DWORD *)(a1 + 96);
  v46[0] = *(_DWORD *)(a1 + 32);
  v46[1] = v8;
  long long v47 = *(_OWORD *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 120);
  uint64_t v48 = *(void *)(a1 + 56);
  uint64_t v49 = v9;
  unsigned int EncodedSize = AAHeaderGetEncodedSize(*(AAHeader *)(a1 + 88));
  uint64_t v14 = (uint64_t *)(a1 + 64);
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t v16 = (_DWORD *)(a1 + 104);
  int v15 = *(_DWORD *)(a1 + 104);
  unsigned int v50 = EncodedSize;
  int v51 = v15;
  uint64_t v52 = v13;
  uint64_t v17 = *(void *)(a1 + 136);
  BOOL v53 = *(void *)(a1 + 128) != 0;
  BOOL v54 = v17 != 0;
  if (a2[3])
  {
    uint64_t v18 = 0;
    compression_algorithm v19 = v46;
    uint64_t v20 = 58;
    while (1)
    {
      uint64_t v21 = ((uint64_t (*)(void, _DWORD *, uint64_t))a2[3])(*a2, v19, v20);
      if (v21 < 1) {
        break;
      }
      compression_algorithm v19 = (_DWORD *)((char *)v19 + v21);
      v18 += v21;
      v20 -= v21;
      if (!v20)
      {
        if (v18 < 0) {
          goto LABEL_36;
        }
        goto LABEL_12;
      }
    }
    if (v21 < 0) {
      goto LABEL_36;
    }
LABEL_12:
    EncodedData = AAHeaderGetEncodedData(*(AAHeader *)(a1 + 88));
    if (a2[3])
    {
      uint64_t v23 = v50;
      if (!v50) {
        goto LABEL_72;
      }
      uint64_t v24 = EncodedData;
      uint64_t v25 = 0;
      while (1)
      {
        uint64_t v26 = ((uint64_t (*)(void, const uint8_t *, uint64_t))a2[3])(*a2, v24, v23);
        if (v26 < 1) {
          break;
        }
        v24 += v26;
        v25 += v26;
        v23 -= v26;
        if (!v23) {
          goto LABEL_19;
        }
      }
      uint64_t v25 = v26;
LABEL_19:
      if ((v25 & 0x8000000000000000) == 0)
      {
LABEL_72:
        if (*v16)
        {
          uint64_t v27 = 0;
          while (a2[3])
          {
            uint64_t v28 = 0;
            uint64_t v29 = *(void *)(a1 + 112) + 24 * v27 + 8;
            uint64_t v30 = 8;
            while (1)
            {
              uint64_t v31 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v29, v30);
              if (v31 < 1) {
                break;
              }
              v29 += v31;
              v28 += v31;
              v30 -= v31;
              if (!v30) {
                goto LABEL_28;
              }
            }
            uint64_t v28 = v31;
LABEL_28:
            if (v28 < 0) {
              break;
            }
            if (++v27 >= (unint64_t)*v16) {
              goto LABEL_30;
            }
          }
          __int16 v36 = 376;
          goto LABEL_37;
        }
LABEL_30:
        if (!a2[3]) {
          goto LABEL_52;
        }
        uint64_t v32 = *v14;
        if (!*v14) {
          goto LABEL_51;
        }
        uint64_t v33 = 0;
        uint64_t v34 = *(void *)(a1 + 80);
        while (1)
        {
          uint64_t v35 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v34, v32);
          if (v35 < 1) {
            break;
          }
          v34 += v35;
          v33 += v35;
          v32 -= v35;
          if (!v32) {
            goto LABEL_50;
          }
        }
        uint64_t v33 = v35;
LABEL_50:
        if (v33 < 0) {
LABEL_52:
        }
          int v40 = 0;
        else {
LABEL_51:
        }
          int v40 = 1;
        if (v54)
        {
          __int16 v41 = *(void **)(a1 + 136);
          if (v41)
          {
            if (*v41)
            {
              int v42 = ((uint64_t (*)(void, void *, void))v41[6])(*v41, a2, 0);
              free(v41);
              if (v42 < 0) {
                int v40 = 0;
              }
            }
            else
            {
              free(*(void **)(a1 + 136));
            }
          }
        }
        *(void *)(a1 + 136) = 0;
        if (v53)
        {
          __int16 v43 = *(void **)(a1 + 128);
          if (v43)
          {
            if (*v43)
            {
              int v44 = ((uint64_t (*)(void, void *, void))v43[6])(*v43, a2, 0);
              free(v43);
              if (v44 < 0)
              {
                *(void *)(a1 + 128) = 0;
LABEL_69:
                __int16 v36 = 385;
                goto LABEL_37;
              }
            }
            else
            {
              free(*(void **)(a1 + 128));
            }
          }
        }
        *(void *)(a1 + 128) = 0;
        if (v40)
        {
          uint64_t v5 = 0;
          if (a3) {
            *a3 = *(void *)(a1 + 56);
          }
          goto LABEL_38;
        }
        goto LABEL_69;
      }
    }
  }
LABEL_36:
  __int16 v36 = 373;
LABEL_37:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"closeWithStateProc", v36, 131, 0, "write state", v11, v12, v45);
  uint64_t v5 = 0xFFFFFFFFLL;
LABEL_38:
  free(*(void **)(a1 + 80));
  memset_s((void *)(a1 + 64), 0x18uLL, 0, 0x18uLL);
  AAHeaderDestroy(*(AAHeader *)(a1 + 88));
  free(*(void **)(a1 + 112));
  memset_s((void *)(a1 + 104), 0x10uLL, 0, 0x10uLL);
  int v37 = *(void (***)(void))(a1 + 128);
  if (v37)
  {
    if (*v37) {
      v37[1]();
    }
    free(v37);
  }
  uint64_t v38 = *(void (***)(void))(a1 + 136);
  if (v38)
  {
    if (*v38) {
      v38[1]();
    }
    free(v38);
  }
  memset_s((void *)a1, 0x90uLL, 0, 0x90uLL);
  free((void *)a1);
  return v5;
}

uint64_t writeProc(void **a1, _WORD *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)a1 + 2)) {
    return -1;
  }
  int v13 = *((_DWORD *)a1 + 8);
  if (v13 == 4)
  {
    uint64_t v9 = 0;
LABEL_6:
    if (a3 && !v9)
    {
      uint64_t v14 = "no more writes possible";
      __int16 v15 = 325;
      goto LABEL_193;
    }
LABEL_172:
    if (v9 < 1)
    {
LABEL_177:
      if (v9 < 0) {
        goto LABEL_195;
      }
    }
    else
    {
      unint64_t v101 = (unint64_t)a1[6];
      if (v101 + 1 >= 2)
      {
        unint64_t v102 = a1[3];
        if (v102)
        {
          if ((((uint64_t (*)(void *, _WORD *, float))v102)(a1[2], __src, (float)((float)(unint64_t)a1[7] * 100.0) / (float)v101) & 0x80000000) != 0)
          {
            uint64_t v14 = "user cancelled in progress callback";
            __int16 v15 = 335;
            goto LABEL_193;
          }
        }
      }
    }
    return v9;
  }
  uint64_t v16 = __src;
  uint64_t v9 = 0;
  uint64_t v17 = (unint64_t *)(a1 + 8);
  while (2)
  {
    unint64_t v18 = *v17;
    if (!(*v17 | a3))
    {
      if (a1[7] >= a1[6]) {
        *((_DWORD *)a1 + 8) = 4;
      }
      goto LABEL_172;
    }
    switch(v13)
    {
      case 0:
        if (a1[7] >= a1[6])
        {
          *((_DWORD *)a1 + 8) = 4;
          goto LABEL_6;
        }
        if (v18 <= 5)
        {
          uint64_t v19 = 6;
          goto LABEL_22;
        }
        __srCC_SHA256_CTX c = a1[10];
        int v111 = *(_DWORD *)__src;
        unsigned __int16 v112 = __src[2];
        if (v111 != 825246017 && v111 != 826360153)
        {
          uint64_t v14 = "invalid header magic";
          __int16 v15 = 120;
          goto LABEL_193;
        }
        if (v112 <= 5uLL)
        {
          uint64_t v14 = "invalid header size";
          __int16 v15 = 122;
          goto LABEL_193;
        }
        size_t v24 = v112 - v18;
        if (v112 <= v18)
        {
          if (v112 != v18)
          {
            uint64_t v14 = "invalid state";
            __int16 v15 = 127;
            goto LABEL_193;
          }
          if ((aaHeaderInitWithEncodedData((uint64_t)a1[11], __src, v18) & 0x80000000) != 0
            || (aaHeaderBlobArrayInitWithHeader((uint64_t)(a1 + 13), (AAHeader_impl *)a1[11]) & 0x80000000) != 0)
          {
            uint64_t v14 = "invalid header";
            __int16 v15 = 130;
            goto LABEL_193;
          }
          uint64_t v109 = 0;
          uint64_t value = 0;
          uint64_t size = 0;
          uint64_t v108 = 0;
          uint64_t offset = 0;
          v63.uint64_t ikey = 5265748;
          uint64_t v64 = (AAHeader_impl *)a1[11];
          uint32_t KeyIndex = AAHeaderGetKeyIndex(v64, v63);
          if ((KeyIndex & 0x80000000) != 0
            || ((unsigned int FieldUInt = AAHeaderGetFieldUInt(v64, KeyIndex, &value), FieldUInt <= 1)
              ? (int v67 = 1)
              : (int v67 = FieldUInt),
                v67 <= 0))
          {
            uint64_t v14 = "missing TYP field";
            __int16 v15 = 137;
            goto LABEL_193;
          }
          unsigned int v68 = (AAHeader_impl *)a1[11];
          v69.uint64_t ikey = 5263193;
          uint32_t v70 = AAHeaderGetKeyIndex(v68, v69);
          if ((v70 & 0x80000000) != 0
            || ((unsigned int v71 = AAHeaderGetFieldUInt(v68, v70, &v109), v71 <= 1) ? (v72 = 1) : (v72 = v71), v72 <= 0))
          {
            uint64_t v109 = 0;
          }
          size_t v73 = (AAHeader_impl *)a1[11];
          v74.uint64_t ikey = 5521732;
          uint32_t v75 = AAHeaderGetKeyIndex(v73, v74);
          if ((v75 & 0x80000000) != 0)
          {
            int v77 = 0;
          }
          else
          {
            unsigned int FieldBlob = AAHeaderGetFieldBlob(v73, v75, &size, &offset);
            if (FieldBlob <= 1) {
              int v77 = 1;
            }
            else {
              int v77 = FieldBlob;
            }
          }
          uint64_t v86 = (AAHeader_impl *)a1[11];
          v87.uint64_t ikey = 5915721;
          uint32_t v88 = AAHeaderGetKeyIndex(v86, v87);
          if ((v88 & 0x80000000) == 0)
          {
            unsigned int v89 = AAHeaderGetFieldUInt(v86, v88, &v108);
            int v90 = v89 <= 1 ? 1 : v89;
            if (v90 >= 1) {
              a1[5] = (void *)((char *)a1[5] + v108);
            }
          }
          a1[8] = 0;
          *((_DWORD *)a1 + 24) = 0;
          if (v77 >= 1 && value == 77 && v109 && v109 != 80)
          {
            unint64_t v91 = aaHeaderBlobArrayPayloadSize((unsigned int *)a1 + 26);
            if (v91 != size)
            {
              uint64_t v14 = "invalid AssetArchive, extra blobs";
              __int16 v15 = 151;
              goto LABEL_193;
            }
            if (v91 <= 3)
            {
              uint64_t v14 = "invalid AssetArchive DAT blob size";
              __int16 v15 = 152;
              goto LABEL_193;
            }
            v92.uint64_t ikey = 5521732;
            uint32_t v93 = AAHeaderGetKeyIndex((AAHeader)a1[11], v92);
            if ((v93 & 0x80000000) != 0
              || AAHeaderRemoveField((AAHeader)a1[11], v93) < 0
              || (aaHeaderBlobArrayInitWithHeader((uint64_t)(a1 + 13), (AAHeader_impl *)a1[11]) & 0x80000000) != 0)
            {
              uint64_t v14 = "removing DAT";
              __int16 v15 = 160;
              goto LABEL_193;
            }
            v94.uint64_t ikey = 5328729;
            if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v94, v109) < 0)
            {
              uint64_t v14 = "append YOQ";
              __int16 v15 = 162;
              goto LABEL_193;
            }
            v95.uint64_t ikey = 5263193;
            uint32_t v96 = AAHeaderGetKeyIndex((AAHeader)a1[11], v95);
            if ((v96 & 0x80000000) != 0)
            {
              uint64_t v14 = "invalid index";
              __int16 v15 = 164;
              goto LABEL_193;
            }
            v97.uint64_t ikey = 5263193;
            if (AAHeaderSetFieldUInt((AAHeader)a1[11], v96, v97, 0x5BuLL) < 0)
            {
              uint64_t v14 = "set YOP";
              __int16 v15 = 165;
              goto LABEL_193;
            }
            unint64_t v98 = (uint64_t (*)(void, void *))(*a1)[4];
            if (!v98 || (v98(**a1, a1[11]) & 0x80000000) != 0)
            {
              uint64_t v14 = "header processing";
              __int16 v15 = 167;
              goto LABEL_193;
            }
            a1[15] = (void *)size;
            int v99 = 2;
          }
          else
          {
            unint64_t v100 = (uint64_t (*)(void, void *))(*a1)[4];
            if (!v100 || (v100(**a1, a1[11]) & 0x80000000) != 0)
            {
              uint64_t v14 = "header processing";
              __int16 v15 = 175;
              goto LABEL_193;
            }
            int v99 = 1;
          }
          *((_DWORD *)a1 + 8) = v99;
        }
        else if (v112 != v18)
        {
          goto LABEL_23;
        }
        goto LABEL_164;
      case 1:
        unint64_t v20 = *((unsigned int *)a1 + 26);
        unint64_t v21 = *((unsigned int *)a1 + 24);
        if (v21 >= v20) {
          goto LABEL_95;
        }
        size_t v22 = &a1[14][3 * v21 + 1];
        while (1)
        {
          uint64_t v23 = *v22;
          v22 += 3;
          if (v23) {
            break;
          }
          *((_DWORD *)a1 + 24) = ++v21;
          if (v20 == v21) {
            goto LABEL_137;
          }
        }
        unint64_t v21 = v21;
LABEL_95:
        if (v21 == v20) {
          goto LABEL_137;
        }
        uint64_t v56 = a1[14];
        uint64_t v57 = &v56[3 * v21];
        size_t v60 = v57[1];
        uint64_t v59 = v57 + 1;
        size_t v58 = v60;
        if (a3 >= v60) {
          size_t v61 = v58;
        }
        else {
          size_t v61 = a3;
        }
        uint64_t v62 = (uint64_t (*)(void, void, _WORD *, size_t))(*a1)[5];
        if (!v62 || (v62(**a1, LODWORD(v56[3 * v21]), v16, v61) & 0x80000000) != 0)
        {
          uint64_t v14 = "blob processing";
          __int16 v15 = 202;
          goto LABEL_193;
        }
        *v59 -= v61;
        a3 -= v61;
        uint64_t v16 = (_WORD *)((char *)v16 + v61);
        v9 += v61;
        a1[7] = (void *)((char *)a1[7] + v61);
        goto LABEL_164;
      case 2:
        if (v18 > 3)
        {
          int v46 = *(_DWORD *)a1[10];
          LODWORD(value) = v46;
          if (v46 != 825246017 && v46 != 826360153)
          {
            BOOL v48 = (unsigned __int16)value == 25200 && BYTE2(value) == 122;
            if (!v48
              || ((int v49 = v46 >> 24, ((v46 >> 24) - 45) <= 0x39)
                ? (BOOL v50 = ((1 << (HIBYTE(v46) - 45)) & 0x320000000000081) == 0)
                : (BOOL v50 = 1),
                  v50 && v49 != 120 && v49 != 122))
            {
              uint64_t v14 = "invalid DAT blob";
              __int16 v15 = 227;
              goto LABEL_193;
            }
          }
          uint64_t v51 = aaAssetDecodeStreamOpen(*a1);
          a1[17] = (void *)v51;
          if (!v51)
          {
            uint64_t v14 = "dat decoder stream";
            __int16 v15 = 231;
            goto LABEL_193;
          }
          if (v46 == 825246017 || v46 == 826360153)
          {
            uint64_t v78 = a1[16];
            if (!v78) {
              uint64_t v78 = a1[17];
            }
          }
          else
          {
            uint64_t v78 = aaAssetDecompressionStreamOpen(v51);
            a1[16] = v78;
            if (!v78)
            {
              uint64_t v14 = "dat decompression stream";
              __int16 v15 = 237;
              goto LABEL_193;
            }
          }
          BOOL v79 = (uint64_t (*)(void, uint64_t *, uint64_t))v78[3];
          if (!v79 || v79(*v78, &value, 4) != 4)
          {
            uint64_t v14 = "sending dat magic";
            __int16 v15 = 241;
            goto LABEL_193;
          }
          a1[15] = (void *)((char *)a1[15] - 4);
          a1[8] = 0;
          int v13 = 3;
          *((_DWORD *)a1 + 8) = 3;
LABEL_165:
          if (v13 == 4) {
            goto LABEL_6;
          }
          continue;
        }
        uint64_t v19 = 4;
LABEL_22:
        size_t v24 = v19 - v18;
LABEL_23:
        if (!a3) {
          goto LABEL_177;
        }
        if (v24 >= a3) {
          size_t v25 = a3;
        }
        else {
          size_t v25 = v24;
        }
        unint64_t v26 = v18 + v25;
        if (__CFADD__(v18, v25) || (v26 & 0x8000000000000000) != 0) {
          goto LABEL_192;
        }
        unint64_t v27 = (unint64_t)a1[9];
        if (v27 >= v26) {
          goto LABEL_88;
        }
        do
        {
          while (!v27)
          {
            unint64_t v27 = 0x4000;
            size_t v29 = 0x4000;
            if (v26 <= 0x4000) {
              goto LABEL_86;
            }
          }
          unint64_t v28 = v27 >> 1;
          if ((v27 & (v27 >> 1)) != 0) {
            unint64_t v28 = v27 & (v27 >> 1);
          }
          v27 += v28;
        }
        while (v27 < v26);
        size_t v29 = v27;
        if (v27 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_191;
        }
LABEL_86:
        BOOL v53 = a1[10];
        BOOL v54 = realloc(v53, v29);
        if (v54)
        {
          a1[9] = (void *)v29;
          a1[10] = v54;
LABEL_88:
          uint64_t v55 = a1[10];
          if (v16)
          {
            memcpy((char *)v55 + *v17, v16, v25);
          }
          else if (v55)
          {
            memset_s((char *)v55 + *v17, v25, 0, v25);
          }
          *v17 += v25;
          if ((v25 & 0x8000000000000000) != 0) {
            goto LABEL_192;
          }
          a3 -= v25;
          uint64_t v16 = (_WORD *)((char *)v16 + v25);
          v9 += v25;
          a1[7] = (void *)((char *)a1[7] + v25);
LABEL_164:
          int v13 = *((_DWORD *)a1 + 8);
          goto LABEL_165;
        }
        free(v53);
LABEL_191:
        *uint64_t v17 = 0;
        a1[9] = 0;
        a1[10] = 0;
LABEL_192:
        uint64_t v14 = "malloc";
        __int16 v15 = 314;
LABEL_193:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"writeProc", v15, 131, 0, v14, a7, a8, v105);
LABEL_194:
        uint64_t v9 = -1;
LABEL_195:
        int v103 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)a1 + 2, (unsigned int *)&v103, 1u);
        if (!v103)
        {
          unint64_t v104 = (void (*)(void))(*a1)[2];
          if (v104) {
            v104(**a1);
          }
        }
        return v9;
      case 3:
        uint64_t v30 = a1[15];
        if (a3 >= (unint64_t)v30) {
          uint64_t v31 = a1[15];
        }
        else {
          uint64_t v31 = (void *)a3;
        }
        if (!v31) {
          goto LABEL_46;
        }
        uint64_t v32 = a1[16];
        if (!v32) {
          uint64_t v32 = a1[17];
        }
        uint64_t v33 = (uint64_t (*)(void, _WORD *))v32[3];
        if (!v33 || (uint64_t v34 = v33(*v32, v16), v34 < 0))
        {
          uint64_t v14 = "writing DAT bytes";
          __int16 v15 = 255;
          goto LABEL_193;
        }
        a3 -= v34;
        uint64_t v16 = (_WORD *)((char *)v16 + v34);
        v9 += v34;
        a1[7] = (void *)((char *)a1[7] + v34);
        uint64_t v30 = (void *)((char *)a1[15] - v34);
        a1[15] = v30;
LABEL_46:
        if (v30) {
          goto LABEL_164;
        }
        uint64_t value = 0;
        uint64_t v35 = (AAHeader_impl *)a1[11];
        v36.uint64_t ikey = 5328729;
        uint32_t v37 = AAHeaderGetKeyIndex(v35, v36);
        if ((v37 & 0x80000000) == 0)
        {
          unsigned int v38 = AAHeaderGetFieldUInt(v35, v37, &value);
          int v39 = v38 <= 1 ? 1 : v38;
          if (v39 >= 1 && value == 77)
          {
            int v40 = a1[17];
            if (v40)
            {
              uint64_t v41 = *(void *)(*v40 + 40);
              int v42 = a1[7];
              a1[6] = (void *)((char *)v42 + v41);
              if (__CFADD__(v42, v41))
              {
                uint64_t v14 = "invalid sizes in manifest";
                __int16 v15 = 274;
                goto LABEL_193;
              }
            }
          }
        }
        __int16 v43 = (uint64_t (**)(void))a1[16];
        if (!v43) {
          goto LABEL_126;
        }
        if (*v43)
        {
          int v44 = v43[1]();
          free(v43);
          BOOL v45 = v44 >= 0;
        }
        else
        {
          free(a1[16]);
LABEL_126:
          BOOL v45 = 1;
        }
        a1[16] = 0;
        char v80 = (uint64_t (**)(void))a1[17];
        if (!v80) {
          goto LABEL_132;
        }
        if (*v80)
        {
          int v81 = v80[1]();
          free(v80);
          if (v81 < 0)
          {
            a1[17] = 0;
LABEL_205:
            uint64_t v14 = "dat archive invalid";
            __int16 v15 = 282;
            goto LABEL_193;
          }
        }
        else
        {
          free(a1[17]);
        }
LABEL_132:
        a1[17] = 0;
        if (!v45) {
          goto LABEL_205;
        }
        v82.uint64_t ikey = 5263193;
        uint32_t v83 = AAHeaderGetKeyIndex((AAHeader)a1[11], v82);
        if ((v83 & 0x80000000) != 0)
        {
          uint64_t v14 = "invalid index";
          __int16 v15 = 288;
          goto LABEL_193;
        }
        v84.uint64_t ikey = 5263193;
        if (AAHeaderSetFieldUInt((AAHeader)a1[11], v83, v84, 0x5DuLL) < 0)
        {
          uint64_t v14 = "set YOP";
          __int16 v15 = 289;
          goto LABEL_193;
        }
        unint64_t v85 = (uint64_t (*)(void, void *))(*a1)[4];
        if (!v85 || (v85(**a1, a1[11]) & 0x80000000) != 0)
        {
          uint64_t v14 = "header processing";
          __int16 v15 = 291;
          goto LABEL_193;
        }
LABEL_137:
        AAHeaderClear((AAHeader)a1[11]);
        int v13 = 0;
        *((_DWORD *)a1 + 26) = 0;
        *((_DWORD *)a1 + 8) = 0;
        goto LABEL_165;
      default:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"writeProc", 304, 131, 0, "invalid state %d", a7, a8, v13);
        goto LABEL_194;
    }
  }
}

atomic_uint *cancelProc(atomic_uint *result)
{
  int v1 = 0;
  atomic_compare_exchange_strong(result + 2, (unsigned int *)&v1, 1u);
  if (!v1)
  {
    unsigned int v2 = *(uint64_t (**)(void))(*(void *)result + 16);
    if (v2) {
      return (atomic_uint *)v2(**(void **)result);
    }
  }
  return result;
}

void (**aaAssetDecodeStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, void *a3))(void)
{
  unint64_t __s = 0;
  size_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v5 = (void (**)(void))aaAssetDecodeStreamOpen(a1);
  int v8 = v5;
  if (v5)
  {
    uint64_t v9 = *v5;
    memset(v52, 0, 58);
    if (*((void *)a2 + 2))
    {
      uint64_t v10 = 0;
      uint64_t v11 = v52;
      uint64_t v12 = 58;
      while (1)
      {
        uint64_t v13 = (*((uint64_t (**)(void, _OWORD *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
        if (v13 < 0) {
          break;
        }
        if (v13)
        {
          uint64_t v11 = (_OWORD *)((char *)v11 + v13);
          v10 += v13;
          v12 -= v13;
          if (v12) {
            continue;
          }
        }
        if (v10 != 58) {
          break;
        }
        int v14 = DWORD1(v52[0]);
        *((_DWORD *)v9 + 8) = v52[0];
        *((_DWORD *)v9 + 24) = v14;
        *(_OWORD *)((char *)v9 + 40) = *(_OWORD *)((char *)v52 + 8);
        uint64_t v15 = *(void *)&v52[2];
        *((void *)v9 + 7) = *((void *)&v52[1] + 1);
        *((void *)v9 + 15) = v15;
        size_t v16 = DWORD2(v52[2]);
        if ((DWORD2(v52[2]) - 0x10000) >= 0xFFFF0006)
        {
          unint64_t v20 = 0;
          unint64_t v21 = 0;
          size_t v22 = 0;
          uint64_t v23 = 0;
          do
          {
            if (v22 == v21)
            {
              unint64_t v24 = v21 + 0x40000;
              if ((uint64_t)(v21 + 0x40000) < 0) {
                goto LABEL_9;
              }
              if (v21 <= 0xFFFFFFFFFFFBFFFFLL)
              {
                do
                {
                  while (!v21)
                  {
                    unint64_t v21 = 0x4000;
                    size_t v26 = 0x4000;
                    if (v24 <= 0x4000) {
                      goto LABEL_35;
                    }
                  }
                  unint64_t v25 = v21 >> 1;
                  if ((v21 & (v21 >> 1)) != 0) {
                    unint64_t v25 = v21 & (v21 >> 1);
                  }
                  v21 += v25;
                }
                while (v21 < v24);
                size_t v26 = v21;
                if (v21 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_93;
                }
LABEL_35:
                unint64_t v27 = (char *)realloc(v20, v26);
                if (v27)
                {
                  size_t v54 = v26;
                  uint64_t v55 = v27;
                  unint64_t v20 = v27;
                  goto LABEL_37;
                }
                free(v20);
LABEL_93:
                unint64_t __s = 0;
                size_t v54 = 0;
                uint64_t v55 = 0;
                goto LABEL_9;
              }
            }
            size_t v26 = v21;
LABEL_37:
            if (v26 - v22 >= v16) {
              size_t v28 = v16;
            }
            else {
              size_t v28 = v26 - v22;
            }
            ssize_t v29 = AAByteStreamRead(a2, &v20[v22], v28);
            if (v29 < 0) {
              goto LABEL_9;
            }
            if (!v29) {
              break;
            }
            size_t v22 = __s + v29;
            if (!__CFADD__(__s, v29))
            {
              unint64_t v21 = v54;
              if (v22 <= v54) {
                continue;
              }
            }
            goto LABEL_9;
            __s += v29;
            v23 += v29;
            v16 -= v29;
          }
          while (v16);
          if (v23 < 0) {
            goto LABEL_9;
          }
          unint64_t v18 = v55;
          if ((aaHeaderInitWithEncodedData(*((void *)v9 + 11), (unsigned __int16 *)v55, __s) & 0x80000000) != 0) {
            goto LABEL_9;
          }
          uint64_t v30 = (_DWORD *)((char *)v9 + 104);
          if ((aaHeaderBlobArrayInitWithHeader((uint64_t)v9 + 104, *((AAHeader_impl **)v9 + 11)) & 0x80000000) != 0
            || *v30 != HIDWORD(v52[2]))
          {
            goto LABEL_9;
          }
          if (*v30)
          {
            uint64_t v31 = 0;
LABEL_51:
            if (*((void *)a2 + 2))
            {
              uint64_t v32 = 0;
              uint64_t v33 = *((void *)v9 + 14) + 24 * v31 + 8;
              uint64_t v34 = 8;
              while (1)
              {
                uint64_t v35 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v33, v34);
                if (v35 < 0) {
                  break;
                }
                if (v35)
                {
                  v33 += v35;
                  v32 += v35;
                  v34 -= v35;
                  if (v34) {
                    continue;
                  }
                }
                if (v32 < 0) {
                  break;
                }
                if (++v31 < (unint64_t)*v30) {
                  goto LABEL_51;
                }
                goto LABEL_58;
              }
            }
            BOOL v50 = "invalid blob state";
            __int16 v51 = 505;
            goto LABEL_99;
          }
LABEL_58:
          size_t v36 = *(void *)&v52[3];
          if (*(void *)&v52[3])
          {
            uint64_t v37 = 0;
            unsigned int v38 = (unint64_t *)((char *)v9 + 64);
            unint64_t v40 = *((void *)v9 + 8);
            unint64_t v39 = *((void *)v9 + 9);
            do
            {
              if (v40 == v39)
              {
                unint64_t v41 = v39 + 0x40000;
                if ((uint64_t)(v39 + 0x40000) < 0) {
                  goto LABEL_98;
                }
                if (v39 <= 0xFFFFFFFFFFFBFFFFLL)
                {
                  do
                  {
                    while (!v39)
                    {
                      unint64_t v39 = 0x4000;
                      size_t v43 = 0x4000;
                      if (v41 <= 0x4000) {
                        goto LABEL_73;
                      }
                    }
                    unint64_t v42 = v39 >> 1;
                    if ((v39 & (v39 >> 1)) != 0) {
                      unint64_t v42 = v39 & (v39 >> 1);
                    }
                    v39 += v42;
                  }
                  while (v39 < v41);
                  size_t v43 = v39;
                  if (v39 >= 0x2000000001)
                  {
                    *__error() = 12;
                    goto LABEL_97;
                  }
LABEL_73:
                  int v44 = (void *)*((void *)v9 + 10);
                  BOOL v45 = realloc(v44, v43);
                  if (v45)
                  {
                    *((void *)v9 + 9) = v43;
                    *((void *)v9 + 10) = v45;
                    unint64_t v40 = *((void *)v9 + 8);
                    goto LABEL_75;
                  }
                  free(v44);
LABEL_97:
                  *unsigned int v38 = 0;
                  *((void *)v9 + 9) = 0;
                  *((void *)v9 + 10) = 0;
                  goto LABEL_98;
                }
                unint64_t v40 = v39;
              }
              size_t v43 = v39;
LABEL_75:
              if (v43 - v40 >= v36) {
                size_t v46 = v36;
              }
              else {
                size_t v46 = v43 - v40;
              }
              ssize_t v47 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 10) + v40), v46);
              if (v47 < 0) {
                goto LABEL_98;
              }
              if (!v47) {
                break;
              }
              unint64_t v40 = *v38 + v47;
              if (!__CFADD__(*v38, v47))
              {
                unint64_t v39 = *((void *)v9 + 9);
                if (v40 <= v39) {
                  continue;
                }
              }
              goto LABEL_98;
              *unsigned int v38 = v40;
              v37 += v47;
              v36 -= v47;
            }
            while (v36);
            if (v37 < 0) {
              goto LABEL_98;
            }
          }
          if (BYTE9(v52[3])
            && (uint64_t v48 = aaAssetDecodeStreamOpenWithState(*(void *)v9, a2, 0), (*((void *)v9 + 17) = v48) == 0)
            || BYTE8(v52[3])
            && (int v49 = aaAssetDecompressionStreamOpenWithState(*((void *)v9 + 17), a2, 0),
                (*((void *)v9 + 16) = v49) == 0))
          {
LABEL_98:
            BOOL v50 = "read state";
            __int16 v51 = 512;
LABEL_99:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpenWithState", v51, 131, 0, v50, v6, v7, v52[0]);
            goto LABEL_12;
          }
          if (a3) {
            *a3 = *((void *)v9 + 7);
          }
          int v17 = 1;
        }
        else
        {
LABEL_9:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpenWithState", 502, 131, 0, "invalid header state", v6, v7, v52[0]);
          int v17 = 0;
          unint64_t v18 = v55;
        }
        goto LABEL_13;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecodeStream.c", (uint64_t)"aaAssetDecodeStreamOpenWithState", 487, 131, 0, "truncated state", v6, v7, v52[0]);
  }
  unint64_t v18 = 0;
LABEL_12:
  int v17 = 0;
LABEL_13:
  free(v18);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  if (v17) {
    uint64_t result = v8;
  }
  else {
    uint64_t result = 0;
  }
  if (v8 && (v17 & 1) == 0)
  {
    if (*v8) {
      v8[1]();
    }
    free(v8);
    return 0;
  }
  return result;
}

char *AAAssetBuilderCreate(uint64_t a1)
{
  unsigned int v2 = (char *)malloc(0xA0uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    memset_s(v2, 0xA0uLL, 0, 0xA0uLL);
    *(void *)uint64_t v3 = a1;
    *(_OWORD *)(v3 + 104) = xmmword_214B128E0;
    *(_OWORD *)(v3 + 120) = xmmword_214B128F0;
    *((_DWORD *)v3 + 34) = 774;
    *((_OWORD *)v3 + 9) = xmmword_214B12900;
  }
  else
  {
    unint64_t v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderCreate", 13, 26, *v4, "malloc", v5, v6, v8);
  }
  return v3;
}

void AAAssetBuilderDestroy(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t AAAssetBuilderAddVariantArchive(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 16);
  if (v8 >= 0xA)
  {
    uint64_t v9 = "too many inputs/outputs";
    __int16 v10 = 44;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderAddVariantArchive", v10, 26, 0, v9, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  if ((a2 - 1) >= 2)
  {
    uint64_t v9 = "invalid variant";
    __int16 v10 = 53;
    goto LABEL_7;
  }
  uint64_t v13 = a1 + 24;
  if (a2 == 2)
  {
    int v14 = (void *)(v13 + 8 * v8);
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 8);
    int v14 = (void *)(v13 + 8 * v16);
    memmove(v14 + 1, v14, 8 * (v8 - v16));
    unint64_t v8 = *(void *)(a1 + 16);
    ++*(void *)(a1 + 8);
  }
  uint64_t result = 0;
  *(void *)(a1 + 16) = v8 + 1;
  *int v14 = a3;
  return result;
}

uint64_t AAAssetBuilderAddFilter()
{
  return 0xFFFFFFFFLL;
}

uint64_t AAAssetBuilderSetParameter(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a2)
  {
    case 1:
      uint64_t result = 0;
      *(void *)(a1 + 104) = a3;
      break;
    case 2:
      uint64_t result = 0;
      *(void *)(a1 + 112) = a3;
      break;
    case 3:
      uint64_t result = 0;
      *(void *)(a1 + 120) = a3;
      break;
    case 4:
      uint64_t result = 0;
      *(void *)(a1 + 128) = a3;
      break;
    case 5:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 136) = a3;
      break;
    case 6:
      uint64_t result = 0;
      *(void *)(a1 + 144) = a3;
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderSetParameter", 104, 26, 0, "unsupported parameter", a7, a8, vars0);
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t AAAssetBuilderGetParameter(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a2)
  {
    case 1:
      uint64_t result = *(void *)(a1 + 104);
      break;
    case 2:
      uint64_t result = *(void *)(a1 + 112);
      break;
    case 3:
      uint64_t result = *(void *)(a1 + 120);
      break;
    case 4:
      uint64_t result = *(void *)(a1 + 128);
      break;
    case 5:
      uint64_t result = *(unsigned int *)(a1 + 136);
      break;
    case 6:
      uint64_t result = *(void *)(a1 + 144);
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetBuilder.c", (uint64_t)"AAAssetBuilderGetParameter", 129, 26, 0, "unsupported parameter key", a7, a8, vars0);
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t AEADecryptAndExtractChunk(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9, unint64_t a10, unsigned int a11)
{
  v30[3] = a6;
  int v31 = 0;
  v30[0] = a2;
  v30[1] = a5;
  v30[2] = a7;
  int v32 = a10 >> 62;
  ChunkAsyncStreamOpen = (uint64_t (**)(void))AEADecryptAndExtractChunkAsyncStreamOpen(a3, a4, (uint64_t)v30, (uint64_t)asyncContext, (uint64_t)asyncSelect, (uint64_t)asyncProgress, a8, a9, a10, a11);
  uint64_t v15 = ChunkAsyncStreamOpen;
  if (!ChunkAsyncStreamOpen)
  {
    uint64_t v19 = "AEADecryptAndExtractAsyncStreamOpen";
    __int16 v20 = 96;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c", (uint64_t)"AEADecryptAndExtractChunk", v20, 117, 0, v19, v13, v14, v27);
    int v21 = 0;
    goto LABEL_19;
  }
  if (!a1[10])
  {
    if ((AAAsyncByteStreamProcessAllRanges(ChunkAsyncStreamOpen, a1, a10, a11) & 0x8000000000000000) == 0)
    {
      int v21 = 1;
      goto LABEL_19;
    }
    uint64_t v19 = "AAAsyncByteStreamProcessAllRanges";
    __int16 v20 = 124;
    goto LABEL_18;
  }
  while (1)
  {
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    int Range = AAAsyncByteStreamGetRange(v15, &v29, &v28);
    if (Range < 0) {
      break;
    }
    if (Range)
    {
      if (!v29)
      {
        int v21 = 1;
        goto LABEL_16;
      }
      if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
      {
        size_t v22 = "AAByteStreamPReadAsync";
        __int16 v23 = 113;
        goto LABEL_15;
      }
    }
    else
    {
      usleep(0x186A0u);
    }
  }
  size_t v22 = "AAAsyncByteStreamGetRange";
  __int16 v23 = 108;
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c", (uint64_t)"AEADecryptAndExtractChunk", v23, 117, 0, v22, v17, v18, v27);
  int v21 = 0;
LABEL_16:
  if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
  {
    uint64_t v19 = "AAByteStreamPReadAsync barrier";
    __int16 v20 = 118;
    goto LABEL_18;
  }
LABEL_19:
  if ((AAAsyncByteStreamClose(v15) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtract.c", (uint64_t)"AEADecryptAndExtractChunk", 128, 117, 0, "AAAsyncByteStreamClose", v24, v25, v27);
    int v21 = 0;
  }
  if (v21) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t asyncContext(uint64_t result, _OWORD *context)
{
  uint64_t v3 = (_DWORD *)result;
  uint64_t v4 = *(void *)result;
  if (*(_DWORD *)(result + 32))
  {
    *(_OWORD *)uint64_t v4 = *context;
    long long v5 = context[1];
    long long v6 = context[2];
    long long v7 = context[3];
    *(void *)(v4 + 64) = *((void *)context + 8);
    *(_OWORD *)(v4 + 32) = v6;
    *(_OWORD *)(v4 + 48) = v7;
    *(_OWORD *)(v4 + 16) = v5;
    if (*(_DWORD *)(result + 36))
    {
      unint64_t v8 = (FILE **)MEMORY[0x263EF8348];
      uint64_t v9 = (FILE *)*MEMORY[0x263EF8348];
      int FieldUInt = AEAContextGetFieldUInt((AEAContext)context, 3u);
      if (FieldUInt <= 1284)
      {
        switch(FieldUInt)
        {
          case 0:
            uint64_t v15 = "none";
            goto LABEL_25;
          case 256:
            uint64_t v15 = "lz4";
            goto LABEL_25;
          case 774:
            uint64_t v15 = "lzma";
LABEL_25:
            uint64_t v16 = AEAContextGetFieldUInt((AEAContext)context, 4u);
            fprintf(v9, "  compression: %s %zu MB\n", v15, v16 >> 20);
            uint64_t v17 = *v8;
            unsigned int v18 = AEAContextGetFieldUInt((AEAContext)context, 2u);
            if (v18 > 2) {
              uint64_t v19 = "???";
            }
            else {
              uint64_t v19 = off_264228A50[v18];
            }
            fprintf(v17, "  checksum: %s\n", v19);
            __int16 v20 = *v8;
            uint64_t v21 = AEAContextGetFieldUInt((AEAContext)context, 0xEu);
            fprintf(v20, "  container size: %llu B\n", v21);
            size_t v22 = *v8;
            uint64_t v23 = AEAContextGetFieldUInt((AEAContext)context, 0xDu);
            fprintf(v22, "  raw size: %llu B\n", v23);
            return 0;
        }
      }
      else
      {
        if (FieldUInt <= 2048)
        {
          if (FieldUInt == 1285)
          {
            uint64_t v15 = "zlib";
            goto LABEL_25;
          }
          if (FieldUInt != 1794) {
            goto LABEL_24;
          }
          goto LABEL_20;
        }
        if (FieldUInt == 2049)
        {
LABEL_20:
          uint64_t v15 = "lzfse";
          goto LABEL_25;
        }
        if (FieldUInt == 2304)
        {
          uint64_t v15 = "lzvn";
          goto LABEL_25;
        }
      }
LABEL_24:
      uint64_t v15 = "???";
      goto LABEL_25;
    }
    return 0;
  }
  uint64_t v11 = *(unsigned int *)(v4 + 1112);
  if (v11 < 0x101)
  {
    memcpy((char *)context + 1116, (const void *)(v4 + 1116), *(unsigned int *)(v4 + 1112));
    *((_DWORD *)context + 278) = v11;
    uint64_t result = memset_s((char *)context + v11 + 1116, 256 - v11, 0, 256 - v11);
    uint64_t v12 = *(unsigned int *)(*(void *)v3 + 72);
    if (v12 < 0x101)
    {
      memcpy((char *)context + 76, (const void *)(*(void *)v3 + 76), *(unsigned int *)(*(void *)v3 + 72));
      *((_DWORD *)context + 18) = v12;
      uint64_t result = memset_s((char *)context + v12 + 76, 256 - v12, 0, 256 - v12);
      uint64_t v13 = *(unsigned int *)(*(void *)v3 + 2152);
      if (v13 < 0x101)
      {
        memcpy((char *)context + 2156, (const void *)(*(void *)v3 + 2156), *(unsigned int *)(*(void *)v3 + 2152));
        *((_DWORD *)context + 538) = v13;
        uint64_t result = memset_s((char *)context + v13 + 2156, 256 - v13, 0, 256 - v13);
        uint64_t v14 = *(unsigned int *)(*(void *)v3 + 332);
        if (v14 < 0x101)
        {
          memcpy(context + 21, (const void *)(*(void *)v3 + 336), *(unsigned int *)(*(void *)v3 + 332));
          *((_DWORD *)context + 83) = v14;
          memset_s((char *)context + v14 + 336, 256 - v14, 0, 256 - v14);
          v3[8] = 1;
          return 0;
        }
      }
    }
  }
  __break(1u);
  return result;
}

uint64_t asyncSelect(uint64_t a1)
{
  int v1 = *(uint64_t (**)(void))(a1 + 24);
  if (v1) {
    return v1(*(void *)(a1 + 8));
  }
  else {
    return 0;
  }
}

uint64_t asyncProgress(uint64_t a1)
{
  int v1 = *(uint64_t (**)(void))(a1 + 16);
  if (v1) {
    return v1(*(void *)(a1 + 8));
  }
  else {
    return 0;
  }
}

uint64_t AEADecryptAndExtract(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int a9)
{
  return AEADecryptAndExtractChunk(a1, a2, a3, a4, a5, a6, a7, 0, 0, a8, a9);
}

void *AAAssetExtractorCreate(const char *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  memset(&v56, 0, sizeof(v56));
  bzero(__s, 0x400uLL);
  bzero(path, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, __s)
    || stat(__s, &v56)
    || (v56.st_mode & 0xF000) != 0x4000
    || (concatPath(path, 0x400uLL, __s, ".AssetExtractCheckpoint") & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorCreate", 216, 15, 0, "invalid work dir: %s", v6, v7, (char)a1);
    Common = 0;
  }
  else
  {
    if (!stat(path, &v56))
    {
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      uint64_t v60 = 0;
      AAByteStream v8 = AAFileStreamOpenWithPath(path, 0, 0);
      if (v8)
      {
        Common = aaAssetExtractorCreateCommon((uint64_t)__s, (uint64_t)path, a3);
        if (Common)
        {
          char v59 = 0;
          uint64_t v57 = 0;
          uint64_t v58 = 0;
          if (*((void *)v8 + 2))
          {
            uint64_t v12 = 0;
            uint64_t v13 = &v57;
            uint64_t v14 = 17;
            while (1)
            {
              uint64_t v15 = (*((uint64_t (**)(void, uint64_t *, uint64_t))v8 + 2))(*(void *)v8, v13, v14);
              if (v15 < 0) {
                break;
              }
              if (v15)
              {
                uint64_t v13 = (uint64_t *)((char *)v13 + v15);
                v12 += v15;
                v14 -= v15;
                if (v14) {
                  continue;
                }
              }
              if (v12 < 0) {
                break;
              }
              void *Common = v57;
              *((_DWORD *)Common + 1038) = v58;
              Common[520] = BYTE4(v58);
              if (!BYTE5(v58)) {
                goto LABEL_31;
              }
              StreamOpenWithState = aaAssetExtractStreamOpenWithState(__s, v8, 0);
              Common[521] = StreamOpenWithState;
              if (!StreamOpenWithState) {
                goto LABEL_31;
              }
              if (BYTE6(v58))
              {
                __int16 v20 = aaAssetDecodeStreamOpenWithState((uint64_t)StreamOpenWithState, v8, &v62);
                Common[522] = v20;
                if (!v20) {
                  goto LABEL_31;
                }
              }
              if (HIBYTE(v58)
                && (uint64_t v21 = aaAssetDecompressionStreamOpenWithState(Common[522], v8, &v61), (Common[523] = v21) == 0)
                || v59
                && (size_t v22 = aaAssetDecryptionStreamOpenWithState(Common[522], v8, &v60), (Common[524] = v22) == 0))
              {
LABEL_31:
                uint64_t v34 = "invalid state";
                __int16 v35 = 121;
                goto LABEL_32;
              }
              if (a2)
              {
                if (v59)
                {
                  uint64_t v23 = &v60;
                }
                else if (HIBYTE(v58))
                {
                  uint64_t v23 = &v61;
                }
                else
                {
                  uint64_t v23 = Common + 520;
                  if (BYTE6(v58)) {
                    uint64_t v23 = &v62;
                  }
                }
                *a2 = *v23;
              }
              BOOL v50 = (uint64_t *)Common[522];
              if (!v50
                || (aaAssetDecodeStreamSetParameterPtr(v50, 101, (uint64_t)Common, v17, v18, v19, v9, v10) & 0x80000000) == 0
                && (aaAssetDecodeStreamSetParameterPtr((uint64_t *)Common[522], 103, (uint64_t)aaAssetExtractorProgress, v51, v52, v53, v9, v10) & 0x80000000) == 0)
              {
                AAByteStreamClose(v8);
                return Common;
              }
              uint64_t v34 = "mapping decode stream progress";
              __int16 v35 = 137;
              goto LABEL_32;
            }
          }
          uint64_t v34 = "invalid state";
          __int16 v35 = 112;
        }
        else
        {
          uint64_t v34 = "common constructor";
          __int16 v35 = 109;
        }
LABEL_32:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorCreateWithCheckpoint", v35, 15, 0, v34, v9, v10, v54);
      }
      else
      {
        int v31 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorCreateWithCheckpoint", 102, 15, *v31, "open: %s", v32, v33, (char)path);
        Common = 0;
      }
      AAByteStreamClose(v8);
      AAAssetExtractorDestroy((char *)Common, 0, v36, v37, v38, v39, v40, v41);
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorCreate", 229, 15, "could not resume from saved checkpoint", v42, v43, v44, v55);
      unlink(path);
    }
    Common = aaAssetExtractorCreateCommon((uint64_t)__s, (uint64_t)path, a3);
    if (Common)
    {
      StreamOpen = aaAssetExtractStreamOpen(a1, a3);
      Common[521] = StreamOpen;
      if (StreamOpen) {
        return Common;
      }
      uint64_t v48 = "extractor stream";
      __int16 v49 = 245;
    }
    else
    {
      uint64_t v48 = "common constructor";
      __int16 v49 = 240;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorCreate", v49, 15, 0, v48, v45, v46, v54);
  }
  AAAssetExtractorDestroy((char *)Common, 0, v24, v25, v26, v27, v28, v29);
  return 0;
}

void *aaAssetExtractorCreateCommon(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = malloc(0x1068uLL);
  long long v5 = v4;
  if (v4)
  {
    memset_s(v4, 0x1068uLL, 0, 0x1068uLL);
    void *v5 = a3;
    __strlcpy_chk();
    __strlcpy_chk();
  }
  else
  {
    uint64_t v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorCreateCommon", 76, 15, *v6, "malloc", v7, v8, v16);
    AAAssetExtractorDestroy(0, 0, v9, v10, v11, v12, v13, v14);
  }
  return v5;
}

uint64_t AAAssetExtractorDestroy(char *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (atomic_load((unsigned int *)a1 + 1034))
    {
LABEL_3:
      uint64_t v10 = 0xFFFFFFFFLL;
LABEL_4:
      int v11 = 1;
      goto LABEL_5;
    }
    uint64_t v17 = (uint64_t (**)(uint64_t))*((void *)a1 + 522);
    if (v17 && aaAssetDecodeStreamDone(v17, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
    {
      uint64_t v10 = 0;
      goto LABEL_4;
    }
    if (atomic_load((unsigned int *)a1 + 1036))
    {
      if (atomic_load((unsigned int *)a1 + 1034))
      {
LABEL_81:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorDestroy", 269, 15, 0, "storing checkpoint", a7, a8, v47);
        goto LABEL_3;
      }
      memset(v51, 0, 17);
      uint64_t v49 = -1;
      uint64_t v50 = -1;
      uint64_t v48 = -1;
      AAByteStream v22 = AAFileStreamOpenWithPath(a1 + 3080, 1537, 0x1A4u);
      uint64_t v25 = v22;
      if (!v22)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorStoreCheckpoint", 160, 15, 0, "open checkpoint path: %s", v23, v24, (_BYTE)a1 + 8);
LABEL_80:
        AAByteStreamClose(v25);
        unlink(a1 + 3080);
        goto LABEL_81;
      }
      v51[0] = *(void *)a1;
      LODWORD(v51[1]) = *((_DWORD *)a1 + 1038);
      BYTE4(v51[1]) = *((void *)a1 + 520);
      uint64_t v26 = (void **)(a1 + 4168);
      int16x8_t v27 = (int16x8_t)vuzp1q_s32((int32x4_t)vtstq_s64(*(int64x2_t *)(a1 + 4168), *(int64x2_t *)(a1 + 4168)), (int32x4_t)vtstq_s64(*(int64x2_t *)(a1 + 4184), *(int64x2_t *)(a1 + 4184)));
      *(int8x8_t *)v27.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v27), (int8x8_t)0x1000100010001);
      *(_DWORD *)((char *)&v51[1] + 5) = vmovn_s16(v27).u32[0];
      if (!*((void *)v22 + 3)) {
        goto LABEL_47;
      }
      uint64_t v28 = 0;
      uint64_t v29 = v51;
      uint64_t v30 = 17;
      while (1)
      {
        uint64_t v31 = (*((uint64_t (**)(void, void *, uint64_t))v25 + 3))(*(void *)v25, v29, v30);
        if (v31 < 1) {
          break;
        }
        uint64_t v29 = (void *)((char *)v29 + v31);
        v28 += v31;
        v30 -= v31;
        if (!v30) {
          goto LABEL_45;
        }
      }
      uint64_t v28 = v31;
LABEL_45:
      if (v28 < 0) {
LABEL_47:
      }
        int v37 = 0;
      else {
        int v37 = 1;
      }
      if (BYTE5(v51[1]))
      {
        uint64_t v38 = *v26;
        if (*v26)
        {
          if (*v38)
          {
            int v39 = ((uint64_t (*)(void, AAByteStream_impl *, void))v38[6])(*v38, v25, 0);
            free(v38);
            if (v39 < 0) {
              int v37 = 0;
            }
          }
          else
          {
            free(*v26);
          }
        }
      }
      *uint64_t v26 = 0;
      if (BYTE6(v51[1]))
      {
        uint64_t v40 = (void *)*((void *)a1 + 522);
        if (v40)
        {
          if (*v40)
          {
            int v41 = ((uint64_t (*)(void, AAByteStream_impl *, uint64_t *))v40[6])(*v40, v25, &v50);
            free(v40);
            if (v41 < 0) {
              int v37 = 0;
            }
          }
          else
          {
            free(*((void **)a1 + 522));
          }
        }
      }
      *((void *)a1 + 522) = 0;
      if (HIBYTE(v51[1]))
      {
        uint64_t v42 = (void *)*((void *)a1 + 523);
        if (v42)
        {
          if (*v42)
          {
            int v43 = ((uint64_t (*)(void, AAByteStream_impl *, uint64_t *))v42[6])(*v42, v25, &v49);
            free(v42);
            if (v43 < 0) {
              int v37 = 0;
            }
          }
          else
          {
            free(*((void **)a1 + 523));
          }
        }
      }
      *((void *)a1 + 523) = 0;
      if (LOBYTE(v51[2]))
      {
        uint64_t v44 = (void *)*((void *)a1 + 524);
        if (v44)
        {
          if (*v44)
          {
            int v45 = ((uint64_t (*)(void, AAByteStream_impl *, uint64_t *))v44[6])(*v44, v25, &v48);
            free(v44);
            if (v45 < 0)
            {
              *((void *)a1 + 524) = 0;
LABEL_79:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"aaAssetExtractorStoreCheckpoint", 179, 15, 0, "write checkpoint", v23, v24, v47);
              goto LABEL_80;
            }
          }
          else
          {
            free(*((void **)a1 + 524));
          }
        }
      }
      *((void *)a1 + 524) = 0;
      if (!v37) {
        goto LABEL_79;
      }
      AAByteStreamClose(v25);
      if (a2)
      {
        if (LOBYTE(v51[2]))
        {
          uint64_t v46 = &v48;
        }
        else if (HIBYTE(v51[1]))
        {
          uint64_t v46 = &v49;
        }
        else
        {
          uint64_t v46 = (uint64_t *)(a1 + 4160);
          if (BYTE6(v51[1])) {
            uint64_t v46 = &v50;
          }
        }
        *a2 = *v46;
      }
      AAByteStreamClose(0);
    }
    int v11 = 0;
    uint64_t v10 = 1;
LABEL_5:
    uint64_t v12 = (uint64_t (**)(void))*((void *)a1 + 523);
    if (v12)
    {
      if (*v12)
      {
        int v13 = v12[1]();
        free(v12);
        if (v13 < 0) {
          goto LABEL_37;
        }
      }
      else
      {
        free(*((void **)a1 + 523));
      }
    }
    uint64_t v18 = (uint64_t (**)(void))*((void *)a1 + 524);
    if (v18)
    {
      if (*v18)
      {
        int v19 = v18[1]();
        free(v18);
        if (v19 < 0) {
          goto LABEL_37;
        }
      }
      else
      {
        free(*((void **)a1 + 524));
      }
    }
    uint64_t v32 = (uint64_t (**)(void))*((void *)a1 + 522);
    if (v32)
    {
      if (*v32)
      {
        int v33 = v32[1]();
        free(v32);
        if (v33 < 0) {
          goto LABEL_37;
        }
      }
      else
      {
        free(*((void **)a1 + 522));
      }
    }
    uint64_t v34 = (uint64_t (**)(void))*((void *)a1 + 521);
    if (v34)
    {
      if (!*v34)
      {
        free(*((void **)a1 + 521));
        if (v11) {
          goto LABEL_38;
        }
        goto LABEL_40;
      }
      int v35 = v34[1]();
      free(v34);
      if (v35 < 0)
      {
LABEL_37:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorDestroy", 276, 15, 0, "internal streams", v14, v15, v47);
        uint64_t v10 = 0xFFFFFFFFLL;
        goto LABEL_38;
      }
    }
    if (v11)
    {
LABEL_38:
      unlink(a1 + 3080);
LABEL_41:
      memset_s(a1, 0x1068uLL, 0, 0x1068uLL);
      free(a1);
      return v10;
    }
LABEL_40:
    uint64_t v10 = 1;
    goto LABEL_41;
  }
  return 0;
}

uint64_t AAAssetExtractorWrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 4136))) {
    return -1;
  }
  uint64_t v9 = a3;
  if (!a3) {
    return 0;
  }
  int v12 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 4144), (unsigned int *)&v12, 1u);
  if (!v12) {
    unlink((const char *)(a1 + 3080));
  }
  int v13 = *(void **)(a1 + 4176);
  if (v13)
  {
    uint64_t v14 = 0;
  }
  else
  {
    unint64_t v31 = *(void *)(a1 + 4160);
    if (v31 > 3)
    {
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      do
      {
        char v32 = *(unsigned char *)(a2 + v14);
        *(void *)(a1 + 4160) = v31 + 1;
        *(unsigned char *)(a1 + v31 + 4152) = v32;
        unint64_t v31 = *(void *)(a1 + 4160);
      }
      while (v31 <= 3 && v9 - 1 != v14++);
      if (v31 < 4) {
        return v14;
      }
      v9 -= v14;
      a2 += v14;
    }
    uint64_t v34 = (char *)(a1 + 4152);
    if (*(_DWORD *)(a1 + 4152) == 825246017 || *(_DWORD *)v34 == 826360153)
    {
      int v37 = 0;
      int v38 = 0;
    }
    else if (*(_DWORD *)v34 == 826361153)
    {
      int v38 = 0;
      int v37 = 1;
    }
    else
    {
      int v35 = *(char *)(a1 + 4155);
      BOOL v36 = *(_WORD *)v34 == 25200 && *(unsigned char *)(a1 + 4154) == 122;
      if (!v36
        || ((int v37 = 0, v38 = 1, (v35 - 45) > 0x39)
         || ((1 << (v35 - 45)) & 0x320000000000081) == 0)
        && v35 != 120
        && v35 != 122)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorWrite", 323, 15, 0, "invalid stream type (0x%02x 0x%02x 0x%02x 0x%02x)", a7, a8, *v34);
        goto LABEL_23;
      }
    }
    int v39 = aaAssetDecodeStreamOpen(*(void *)(a1 + 4168));
    *(void *)(a1 + 4176) = v39;
    if (!v39)
    {
      int16x8_t v27 = "decoder stream";
      __int16 v28 = 330;
      goto LABEL_22;
    }
    if (v37)
    {
      int v43 = aaAssetDecryptionStreamOpen((uint64_t)v39, *(void *)(a1 + 4104), *(void *)(a1 + 4112));
      *(void *)(a1 + 4192) = v43;
      if (!v43)
      {
        int16x8_t v27 = "decryption stream";
        __int16 v28 = 334;
        goto LABEL_22;
      }
    }
    else
    {
      if (v38)
      {
        uint64_t v44 = aaAssetDecompressionStreamOpen((uint64_t)v39);
        *(void *)(a1 + 4184) = v44;
        if (!v44)
        {
          int16x8_t v27 = "decompression stream";
          __int16 v28 = 339;
          goto LABEL_22;
        }
      }
      int v45 = *(uint64_t (**)(void, void))(a1 + 4112);
      if (v45 && (v45(*(void *)(a1 + 4104), 0) & 0x80000000) != 0)
      {
        int16x8_t v27 = "callback cancel on non AEA container";
        __int16 v28 = 346;
        goto LABEL_22;
      }
    }
    if ((aaAssetDecodeStreamSetParameterPtr(*(uint64_t **)(a1 + 4176), 101, a1, v40, v41, v42, a7, a8) & 0x80000000) != 0
      || (aaAssetDecodeStreamSetParameterPtr(*(uint64_t **)(a1 + 4176), 103, (uint64_t)aaAssetExtractorProgress, v46, v47, v48, a7, a8) & 0x80000000) != 0)
    {
      int16x8_t v27 = "mapping decode stream progress";
      __int16 v28 = 352;
      goto LABEL_22;
    }
    uint64_t v49 = *(void **)(a1 + 4176);
    if (*(void *)(a1 + 4184)) {
      uint64_t v49 = *(void **)(a1 + 4184);
    }
    uint64_t v50 = *(void **)(a1 + 4192);
    if (!v50) {
      uint64_t v50 = v49;
    }
    uint64_t v51 = (uint64_t (*)(void, uint64_t, void))v50[3];
    if (v51) {
      uint64_t v52 = v51(*v50, a1 + 4152, *(void *)(a1 + 4160));
    }
    else {
      uint64_t v52 = -1;
    }
    if (v52 != *(void *)(a1 + 4160))
    {
      int16x8_t v27 = "invalid stream";
      __int16 v28 = 360;
      goto LABEL_22;
    }
    int v13 = *(void **)(a1 + 4176);
  }
  if (*(void *)(a1 + 4184)) {
    int v13 = *(void **)(a1 + 4184);
  }
  uint64_t v15 = *(void **)(a1 + 4192);
  if (!v15) {
    uint64_t v15 = v13;
  }
  char v16 = (uint64_t (*)(void, uint64_t, uint64_t))v15[3];
  if (!v16 || (uint64_t v17 = v16(*v15, a2, v9), v17 < 0))
  {
    int16x8_t v27 = "invalid stream";
    __int16 v28 = 370;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractor.c", (uint64_t)"AAAssetExtractorWrite", v28, 15, 0, v27, a7, a8, v53);
LABEL_23:
    int v29 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 4136), (unsigned int *)&v29, 1u);
    return -1;
  }
  uint64_t v23 = v17;
  uint64_t v24 = *(uint64_t (***)(uint64_t))(a1 + 4176);
  if (v24)
  {
    if (aaAssetDecodeStreamDone(v24, v18, v19, v20, v21, v22, a7, a8))
    {
      int v25 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 4140), (unsigned int *)&v25, 1u);
      if (!v25)
      {
        uint64_t v26 = *(uint64_t (**)(void, uint64_t, void *, void))(a1 + 4128);
        if (v26)
        {
          if ((v26(*(void *)(a1 + 4104), 92, &unk_214B013C1, 0) & 0x80000000) != 0)
          {
            int16x8_t v27 = "end of stream cancel";
            __int16 v28 = 381;
            goto LABEL_22;
          }
        }
      }
    }
  }
  v14 += v23;
  if (v14 < 0) {
    goto LABEL_23;
  }
  return v14;
}

uint64_t aaAssetExtractorProgress(uint64_t a1, float a2)
{
  if ((a2 >= 100.0 || ((float v2 = *(float *)(a1 + 4148), v2 > 0.0) ? (v3 = (float)(v2 + 1.0) <= a2) : (v3 = 1), v3))
    && (*(float *)(a1 + 4148) = a2, (uint64_t v4 = *(uint64_t (**)(void))(a1 + 4120)) != 0))
  {
    return v4(*(void *)(a1 + 4104));
  }
  else
  {
    return 0;
  }
}

uint64_t AAAssetExtractorSetParameterPtr(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 4136))) {
    return 0xFFFFFFFFLL;
  }
  if ((a2 - 105) >= 2)
  {
    if (a2 != 101
      || (aaAssetExtractStreamSetParameterPtr(*(uint64_t **)(a1 + 4168), 101, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      return 0xFFFFFFFFLL;
    }
    uint64_t result = 0;
    *(void *)(a1 + 4104) = a3;
  }
  else
  {
    int v12 = *(uint64_t **)(a1 + 4168);
    return aaAssetExtractStreamSetParameterPtr(v12, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t AAAssetExtractorSetParameterCallback(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 4136))) {
    return 0xFFFFFFFFLL;
  }
  if (a2 == 102)
  {
    uint64_t v12 = 4112;
  }
  else if (a2 == 103)
  {
    uint64_t v12 = 4120;
  }
  else
  {
    if (a2 != 104
      || (aaAssetExtractStreamSetParameterCallback(*(uint64_t (***)(uint64_t))(a1 + 4168), 104, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      return 0xFFFFFFFFLL;
    }
    uint64_t v12 = 4128;
  }
  uint64_t result = 0;
  *(void *)(a1 + v12) = a3;
  return result;
}

size_t PCompressCopyEncode(void *a1, size_t a2, void *__src, size_t __n)
{
  if (a2 < __n) {
    return -1;
  }
  size_t v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

size_t PCompressCopyDecode(void *a1, size_t a2, void *__src, size_t __n)
{
  if (a2 < __n) {
    return -1;
  }
  size_t v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

AEAAuthData AEAAuthDataCreate(void)
{
  v0 = (AEAAuthData_impl *)malloc(0x30uLL);
  int v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x30uLL, 0, 0x30uLL);
  }
  else
  {
    float v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataCreate", 19, 95, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

void AEAAuthDataDestroy(AEAAuthData auth_data)
{
  if (auth_data)
  {
    free(*((void **)auth_data + 2));
    free(*((void **)auth_data + 5));
    memset_s((char *)auth_data + 24, 0x18uLL, 0, 0x18uLL);
    memset_s(auth_data, 0x30uLL, 0, 0x30uLL);
    free(auth_data);
  }
}

AEAAuthData AEAAuthDataCreateWithContext(AEAContext context)
{
  size_t __s = 0;
  size_t v51 = 0;
  __ptr = 0;
  size_t v49 = 0;
  AEAAuthData v2 = AEAAuthDataCreate();
  if (v2)
  {
    if (AEAContextGetFieldBlob(context, 5u, 0, 0, 0, &v49) < 0)
    {
      uint64_t v8 = "AEAContextGetFieldBlob";
      __int16 v9 = 46;
      goto LABEL_74;
    }
    if (!v49) {
      goto LABEL_95;
    }
    if ((v49 & 0x8000000000000000) == 0)
    {
      size_t v5 = v51;
      if (v51 >= v49)
      {
        uint64_t v10 = __ptr;
      }
      else
      {
        do
        {
          while (!v5)
          {
            size_t v5 = 0x4000;
            if (v49 <= 0x4000)
            {
              uint64_t v7 = __ptr;
              size_t v5 = 0x4000;
              goto LABEL_18;
            }
          }
          size_t v6 = v5 >> 1;
          if ((v5 & (v5 >> 1)) != 0) {
            size_t v6 = v5 & (v5 >> 1);
          }
          v5 += v6;
        }
        while (v5 < v49);
        if (v5 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_72;
        }
        uint64_t v7 = __ptr;
LABEL_18:
        uint64_t v10 = realloc(v7, v5);
        if (!v10)
        {
          free(v7);
LABEL_72:
          size_t v51 = 0;
          __ptr = 0;
          size_t __s = 0;
          goto LABEL_73;
        }
        size_t v51 = v5;
        __ptr = v10;
      }
      if ((AEAContextGetFieldBlob(context, 5u, 0, v5 - __s, (uint8_t *)v10 + __s, &v49) & 0x80000000) == 0)
      {
        size_t v11 = __s;
        if (!v49) {
          goto LABEL_25;
        }
        size_t v11 = __s + v49;
        if (!__CFADD__(__s, v49) && v11 <= v51)
        {
          __s += v49;
LABEL_25:
          uint64_t v12 = (char *)__ptr;
          *(void *)AEAAuthData v2 = 0;
          *((void *)v2 + 3) = 0;
          int v13 = (void *)((char *)v2 + 24);
          if (v11)
          {
            char v14 = 0;
            uint64_t v15 = (unint64_t *)((char *)v2 + 32);
            char v16 = 1;
            while (2)
            {
              size_t v17 = 0;
              unint64_t v18 = 0;
              char v19 = v16;
              do
              {
                if (v17 + 4 > v11) {
                  goto LABEL_105;
                }
                uint64_t v20 = *(unsigned int *)&v12[v17];
                if (v20 < 4) {
                  goto LABEL_105;
                }
                BOOL v21 = __CFADD__(v20, v17);
                size_t v22 = v20 + v17;
                if (v21 || v22 > v11) {
                  goto LABEL_105;
                }
                if (v14)
                {
                  uint64_t v23 = *((void *)v2 + 2);
                  uint64_t v24 = (*(void *)v2)++;
                  *(void *)(v23 + 8 * v24) = v17;
                }
                ++v18;
                size_t v17 = v22;
              }
              while (v22 < v11);
              if (v22 != v11) {
                goto LABEL_105;
              }
              if ((v19 & 1) == 0)
              {
LABEL_61:
                *int v13 = 0;
                if ((v11 & 0x8000000000000000) == 0)
                {
                  unint64_t v34 = *v15;
                  if (*v15 < v11)
                  {
                    size_t v35 = 0x4000;
                    do
                    {
                      while (!v34)
                      {
                        unint64_t v34 = 0x4000;
                        if (v11 <= 0x4000) {
                          goto LABEL_78;
                        }
                      }
                      unint64_t v36 = v34 >> 1;
                      if ((v34 & (v34 >> 1)) != 0) {
                        unint64_t v36 = v34 & (v34 >> 1);
                      }
                      v34 += v36;
                    }
                    while (v34 < v11);
                    size_t v35 = v34;
                    if (v34 >= 0x2000000001)
                    {
                      *__error() = 12;
                      goto LABEL_104;
                    }
LABEL_78:
                    int v37 = (void *)*((void *)v2 + 5);
                    size_t v38 = v35;
                    int v39 = realloc(v37, v35);
                    if (v39)
                    {
                      *((void *)v2 + 4) = v38;
                      *((void *)v2 + 5) = v39;
                      goto LABEL_80;
                    }
                    free(v37);
LABEL_104:
                    *uint64_t v15 = 0;
                    *((void *)v2 + 5) = 0;
                    goto LABEL_105;
                  }
LABEL_80:
                  uint64_t v40 = *((void *)v2 + 5);
                  if (v12)
                  {
                    memcpy((void *)(v40 + *v13), v12, v11);
                  }
                  else if (v40)
                  {
                    memset_s((void *)(v40 + *v13), v11, 0, v11);
                  }
                  *((void *)v2 + 3) += v11;
                  unint64_t v41 = *(void *)v2;
                  if (*(void *)v2)
                  {
                    unint64_t v42 = 0;
                    while (1)
                    {
                      if (v41 <= v42)
                      {
                        int v43 = 0;
                        uint64_t v44 = 0xFFFFFFFFLL;
                      }
                      else
                      {
                        int v43 = (unsigned int *)(*((void *)v2 + 5) + *(void *)(*((void *)v2 + 2) + 8 * v42));
                        uint64_t v44 = *v43;
                        if (v44 < 5)
                        {
LABEL_97:
                          uint64_t v8 = "invalid auth_data key";
                          __int16 v9 = 74;
                          goto LABEL_74;
                        }
                      }
                      int v45 = (unsigned __int8 *)(v43 + 1);
                      uint64_t v46 = v44 - 4;
                      while (*v45++)
                      {
                        if (!--v46) {
                          goto LABEL_97;
                        }
                      }
                      if (++v42 == v41) {
                        goto LABEL_95;
                      }
                    }
                  }
                  break;
                }
LABEL_105:
                *(void *)AEAAuthData v2 = 0;
                *((void *)v2 + 3) = 0;
                uint64_t v8 = "invalid auth data blob";
                __int16 v9 = 62;
LABEL_74:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataCreateWithContext", v9, 95, 0, v8, v3, v4, v49);
                free(__ptr);
                memset_s(&__s, 0x18uLL, 0, 0x18uLL);
                AEAAuthDataDestroy(v2);
                return 0;
              }
              if (v18 > 0xFFFFFFFE) {
                goto LABEL_105;
              }
              unint64_t v25 = *((void *)v2 + 1);
              if (v25 < v18)
              {
                unint64_t v26 = *((void *)v2 + 1);
                do
                {
                  if (v26) {
                    v26 *= 2;
                  }
                  else {
                    unint64_t v26 = 16;
                  }
                }
                while (v26 < v18);
                if (v26 > v25)
                {
                  *((void *)v2 + 1) = v26;
                  if (8 * v26 >= 0x2000000001)
                  {
                    *__error() = 12;
                  }
                  else
                  {
                    int16x8_t v27 = (void *)*((void *)v2 + 2);
                    __int16 v28 = realloc(v27, 8 * v26);
                    if (v28)
                    {
                      *((void *)v2 + 2) = v28;
                      goto LABEL_48;
                    }
                    free(v27);
                  }
                  *((void *)v2 + 2) = 0;
                  goto LABEL_105;
                }
              }
LABEL_48:
              if ((v11 & 0x8000000000000000) != 0) {
                goto LABEL_105;
              }
              unint64_t v29 = *v15;
              if (*v15 < v11)
              {
                do
                {
                  while (!v29)
                  {
                    unint64_t v29 = 0x4000;
                    size_t v31 = 0x4000;
                    if (v11 <= 0x4000) {
                      goto LABEL_58;
                    }
                  }
                  unint64_t v30 = v29 >> 1;
                  if ((v29 & (v29 >> 1)) != 0) {
                    unint64_t v30 = v29 & (v29 >> 1);
                  }
                  v29 += v30;
                }
                while (v29 < v11);
                size_t v31 = v29;
                if (v29 >= 0x2000000001)
                {
                  *__error() = 12;
                  goto LABEL_99;
                }
LABEL_58:
                char v32 = (void *)*((void *)v2 + 5);
                int v33 = realloc(v32, v31);
                if (v33)
                {
                  *((void *)v2 + 4) = v31;
                  *((void *)v2 + 5) = v33;
                  goto LABEL_60;
                }
                free(v32);
LABEL_99:
                *int v13 = 0;
                *((void *)v2 + 4) = 0;
                *((void *)v2 + 5) = 0;
                goto LABEL_105;
              }
LABEL_60:
              char v16 = 0;
              char v14 = 1;
              if (v19) {
                continue;
              }
              goto LABEL_61;
            }
          }
LABEL_95:
          free(__ptr);
          memset_s(&__s, 0x18uLL, 0, 0x18uLL);
          return v2;
        }
      }
    }
LABEL_73:
    uint64_t v8 = "AEAContextGetFieldBlob";
    __int16 v9 = 59;
    goto LABEL_74;
  }
  return v2;
}

uint32_t AEAAuthDataGetEntryCount(AEAAuthData auth_data)
{
  return *(_DWORD *)auth_data;
}

int AEAAuthDataGetEntry(AEAAuthData auth_data, uint32_t i, size_t key_capacity, char *key, size_t *key_length, size_t data_capacity, uint8_t *data, size_t *data_size)
{
  if (*(void *)auth_data <= (unint64_t)i)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataGetEntry", 98, 95, 0, "invalid entry index %u", (uint64_t)data, (uint64_t)data_size, i);
    return -1;
  }
  uint64_t v8 = (unsigned int *)(*((void *)auth_data + 5) + *(void *)(*((void *)auth_data + 2) + 8 * i));
  __int16 v9 = v8 + 1;
  unint64_t v10 = *v8;
  if (v10 < 5) {
    goto LABEL_15;
  }
  size_t v14 = 0;
  while (v9[v14])
  {
    if ((unint64_t)++v14 + 4 >= v10) {
      goto LABEL_15;
    }
  }
  if ((int)v10 - 5 - (int)v14 >= v10)
  {
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataGetEntry", 109, 95, 0, "invalid auth_data blob", (uint64_t)data, (uint64_t)data_size, v17);
    return -1;
  }
  size_t v15 = (v10 - 5 - v14);
  if (key_length) {
    *key_length = v14;
  }
  if (data_size) {
    *data_uint64_t size = v15;
  }
  if (v14 >= key_capacity)
  {
    if (key_capacity) {
      return -1;
    }
  }
  else
  {
    memcpy(key, v9, v14);
    key[v14] = 0;
  }
  if (v15 > data_capacity)
  {
    if (!data_capacity) {
      return 0;
    }
    return -1;
  }
  memcpy(data, (char *)v8 + v10 - (v10 - 5 - v14), (v10 - 5 - v14));
  return 0;
}

int AEAAuthDataAppendEntry(AEAAuthData auth_data, const char *key, const uint8_t *data, size_t data_size)
{
  size_t v8 = strlen(key);
  size_t v11 = v8 + 1;
  size_t v12 = v8 + 5;
  if (v8 + 1 >= 0xFFFFFFFFFFFFFFFCLL || (rsize_t v15 = data_size + v12, __CFADD__(data_size, v12)) || v15 >= 0xFFFFFFFF)
  {
    int v13 = "invalid attribute size";
    __int16 v14 = 148;
LABEL_49:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataAppendEntry", v14, 95, 0, v13, v9, v10, (char)v43);
    return -1;
  }
  if (v15 < 4) {
    goto LABEL_48;
  }
  char v16 = (void *)((char *)auth_data + 24);
  unint64_t v17 = *((void *)auth_data + 3);
  unint64_t v18 = v17 + v15;
  if (__CFADD__(v17, v15)) {
    goto LABEL_48;
  }
  uint64_t v20 = *(void *)auth_data;
  unint64_t v19 = *((void *)auth_data + 1);
  unint64_t v21 = *(void *)auth_data + 1;
  if (v19 < v21)
  {
    unint64_t v22 = *((void *)auth_data + 1);
    do
    {
      if (v22) {
        v22 *= 2;
      }
      else {
        unint64_t v22 = 16;
      }
    }
    while (v22 < v21);
    if (v22 > v19)
    {
      uint64_t v24 = (void *)((char *)auth_data + 16);
      uint64_t v23 = (void **)*((void *)auth_data + 2);
      *((void *)auth_data + 1) = v22;
      if (8 * v22 >= 0x2000000001)
      {
        *__error() = 12;
LABEL_47:
        *(void *)auth_data = 0;
        void *v24 = 0;
        *((void *)auth_data + 3) = 0;
        goto LABEL_48;
      }
      int v43 = v23;
      uint64_t v44 = v20;
      unint64_t v25 = realloc(v23, 8 * v22);
      if (!v25)
      {
        free(v43);
        goto LABEL_47;
      }
      void *v24 = v25;
      uint64_t v20 = v44;
    }
  }
  if ((v18 & 0x8000000000000000) != 0) {
    goto LABEL_43;
  }
  size_t v26 = *((void *)auth_data + 4);
  if (v26 < v18)
  {
    do
    {
      while (!v26)
      {
        size_t v26 = 0x4000;
        if (v18 <= 0x4000)
        {
          size_t v26 = 0x4000;
          goto LABEL_29;
        }
      }
      size_t v27 = v26 >> 1;
      if ((v26 & (v26 >> 1)) != 0) {
        size_t v27 = v26 & (v26 >> 1);
      }
      v26 += v27;
    }
    while (v26 < v18);
    if (v26 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_42;
    }
LABEL_29:
    uint64_t v45 = v20;
    __int16 v28 = (void *)*((void *)auth_data + 5);
    unint64_t v29 = realloc(v28, v26);
    if (v29)
    {
      *((void *)auth_data + 4) = v26;
      *((void *)auth_data + 5) = v29;
      uint64_t v20 = v45;
      goto LABEL_31;
    }
    free(v28);
LABEL_42:
    *((void *)auth_data + 4) = 0;
    *((void *)auth_data + 5) = 0;
LABEL_43:
    *(void *)auth_data = 0;
    *((void *)auth_data + 3) = 0;
    goto LABEL_48;
  }
LABEL_31:
  uint64_t v30 = *v16;
  unint64_t v31 = *v16 + v15;
  if (__CFADD__(*v16, v15) || (v31 & 0x8000000000000000) != 0) {
    goto LABEL_48;
  }
  if (v26 < v31)
  {
    do
    {
      while (!v26)
      {
        size_t v26 = 0x4000;
        if (v31 <= 0x4000)
        {
          uint64_t v46 = v20;
          int v33 = (void **)((char *)auth_data + 40);
          size_t v26 = 0x4000;
          goto LABEL_53;
        }
      }
      size_t v32 = v26 >> 1;
      if ((v26 & (v26 >> 1)) != 0) {
        size_t v32 = v26 & (v26 >> 1);
      }
      v26 += v32;
    }
    while (v26 < v31);
    int v33 = (void **)((char *)auth_data + 40);
    if (v26 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_61;
    }
    uint64_t v46 = v20;
LABEL_53:
    int v43 = v33;
    int v37 = *v33;
    unint64_t v34 = (char *)realloc(v37, v26);
    if (v34)
    {
      *((void *)auth_data + 5) = v34;
      size_t v35 = (void *)((char *)auth_data + 40);
      *((void *)auth_data + 4) = v26;
      uint64_t v30 = *((void *)auth_data + 3);
      goto LABEL_55;
    }
    free(v37);
    int v33 = v43;
LABEL_61:
    void *v33 = 0;
    *char v16 = 0;
    *((void *)auth_data + 4) = 0;
    goto LABEL_48;
  }
  uint64_t v46 = v20;
  size_t v35 = (void *)((char *)auth_data + 40);
  unint64_t v34 = (char *)*((void *)auth_data + 5);
  if (v34)
  {
LABEL_55:
    memset_s(&v34[v30], v15, 0, v15);
    uint64_t v30 = *v16;
  }
  *((void *)auth_data + 3) = v30 + v15;
  uint64_t v38 = *((void *)auth_data + 2);
  uint64_t v39 = (*(void *)auth_data)++;
  *(void *)(v38 + 8 * v39) = v17;
  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > *v16 || (*(_DWORD *)(*v35 + v17) = v15, v46 < 0))
  {
LABEL_48:
    int v13 = "alloc auth_data entry";
    __int16 v14 = 152;
    goto LABEL_49;
  }
  uint64_t v40 = *((void *)auth_data + 5);
  uint64_t v41 = *(void *)(*((void *)auth_data + 2) + 8 * v46);
  *(_DWORD *)(v40 + v41) = v15;
  unint64_t v42 = (char *)(v40 + v41 + 4);
  memcpy(v42, key, v11);
  memcpy(&v42[v11], data, data_size);
  return 0;
}

int AEAAuthDataSetEntry(AEAAuthData auth_data, uint32_t i, const char *key, const uint8_t *data, size_t data_size)
{
  if (*(void *)auth_data <= (unint64_t)i)
  {
    uint64_t v24 = "invalid auth_data index";
    __int16 v25 = 172;
    goto LABEL_11;
  }
  size_t v12 = strlen(key);
  size_t v13 = v12 + 1;
  size_t v14 = v12 + 5;
  if (v12 + 1 >= 0xFFFFFFFFFFFFFFFCLL || (unint64_t v15 = data_size + v14, __CFADD__(data_size, v14)) || v15 >= 0xFFFFFFFF)
  {
    uint64_t v24 = "invalid attribute size";
    __int16 v25 = 180;
    goto LABEL_11;
  }
  if (v15 < 4) {
    goto LABEL_8;
  }
  unint64_t v16 = i;
  unint64_t v17 = *(void *)(*((void *)auth_data + 2) + 8 * i);
  unint64_t v18 = (char *)*((void *)auth_data + 5);
  unint64_t v19 = *(unsigned int *)&v18[v17];
  unint64_t v20 = v17 + v19;
  if (__CFADD__(v17, v19)
    || (v21 = (unint64_t *)((char *)auth_data + 24), unint64_t v22 = *((void *)auth_data + 3), v23 = v22 - v20, v22 < v20))
  {
LABEL_8:
    uint64_t v24 = "alloc auth_data entry";
    __int16 v25 = 183;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataSetEntry", v25, 95, 0, v24, v5, v6, v48);
    return -1;
  }
  uint64_t v27 = v15 - v19;
  if (v15 > v19)
  {
    unint64_t v28 = v22 + v27;
    if ((uint64_t)(v22 + v27) < 0) {
      goto LABEL_8;
    }
    unint64_t v29 = *((void *)auth_data + 4);
    if (v29 < v28)
    {
      size_t v30 = 0x4000;
      do
      {
        while (!v29)
        {
          unint64_t v29 = 0x4000;
          if (v28 <= 0x4000) {
            goto LABEL_29;
          }
        }
        unint64_t v31 = v29 >> 1;
        if ((v29 & (v29 >> 1)) != 0) {
          unint64_t v31 = v29 & (v29 >> 1);
        }
        v29 += v31;
      }
      while (v29 < v28);
      size_t v30 = v29;
      if (v29 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_44;
      }
LABEL_29:
      uint64_t v50 = v27;
      unint64_t v51 = v16;
      size_t v49 = v30;
      int v37 = (char *)realloc(v18, v30);
      if (v37)
      {
        uint64_t v27 = v50;
        *((void *)auth_data + 4) = v49;
        *((void *)auth_data + 5) = v37;
        unint64_t v18 = v37;
        unint64_t v16 = v51;
        unint64_t v21 = (unint64_t *)((char *)auth_data + 24);
        size_t v23 = v22 - v20;
        goto LABEL_31;
      }
      free(v18);
LABEL_44:
      *((void *)auth_data + 3) = 0;
      *((void *)auth_data + 4) = 0;
      *((void *)auth_data + 5) = 0;
      goto LABEL_8;
    }
LABEL_31:
    if (v22 != v20)
    {
      uint64_t v38 = &v18[v20];
      uint64_t v39 = &v18[v20 + v27];
      uint64_t v40 = v21;
      unint64_t v41 = v16;
      uint64_t v42 = v27;
      memmove(v39, v38, v23);
      uint64_t v27 = v42;
      unint64_t v16 = v41;
      unint64_t v21 = v40;
    }
    unint64_t v22 = *v21 + v27;
    goto LABEL_34;
  }
  if (v15 < v19)
  {
    uint64_t v32 = v19 - v15;
    if (v22 != v20)
    {
      int v33 = &v18[v20];
      unint64_t v34 = &v18[v20 - v32];
      unint64_t v35 = v16;
      uint64_t v36 = v32;
      memmove(v34, v33, v23);
      uint64_t v32 = v36;
      unint64_t v16 = v35;
      unint64_t v21 = (unint64_t *)((char *)auth_data + 24);
      unint64_t v20 = *((void *)auth_data + 3);
    }
    unint64_t v22 = v20 - v32;
LABEL_34:
    unint64_t *v21 = v22;
  }
  if (v17 >= 0xFFFFFFFFFFFFFFFCLL || v17 + 4 > v22) {
    goto LABEL_8;
  }
  *(_DWORD *)(*((void *)auth_data + 5) + v17) = v15;
  if (*(void *)auth_data > v16)
  {
    unint64_t v43 = v16;
    while (v17 < 0xFFFFFFFFFFFFFFFCLL && v17 + 4 <= *v21)
    {
      uint64_t v44 = *(unsigned int *)(*((void *)auth_data + 5) + v17);
      *(void *)(*((void *)auth_data + 2) + 8 * v43) = v17;
      v17 += v44;
      if (++v43 >= *(void *)auth_data) {
        goto LABEL_42;
      }
    }
    goto LABEL_8;
  }
LABEL_42:
  uint64_t v45 = *((void *)auth_data + 5);
  uint64_t v46 = *(void *)(*((void *)auth_data + 2) + 8 * v16);
  *(_DWORD *)(v45 + v46) = v15;
  uint64_t v47 = (char *)(v45 + v46 + 4);
  memcpy(v47, key, v13);
  memcpy(&v47[v13], data, data_size);
  return 0;
}

int AEAAuthDataClear(AEAAuthData auth_data)
{
  *(void *)auth_data = 0;
  *((void *)auth_data + 3) = 0;
  return 0;
}

int AEAAuthDataRemoveEntry(AEAAuthData auth_data, uint32_t i)
{
  uint64_t v4 = *(void *)auth_data;
  if (*(void *)auth_data <= (unint64_t)i
    || (unint64_t v6 = i,
        uint64_t v7 = *(void *)(*((void *)auth_data + 2) + 8 * i),
        uint64_t v8 = *((void *)auth_data + 5),
        uint64_t v9 = *(unsigned int *)(v8 + v7),
        BOOL v10 = __CFADD__(v7, v9),
        unint64_t v11 = v7 + v9,
        v10)
    || (unint64_t v12 = *((void *)auth_data + 3), v12 < v11))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAAuthData.c", (uint64_t)"AEAAuthDataRemoveEntry", 205, 95, 0, "invalid auth_data index %u", v2, v3, i);
    return -1;
  }
  else
  {
    if (v9)
    {
      if (v12 != v11)
      {
        memmove((void *)(v8 + v11 - v9), (const void *)(v8 + v11), v12 - v11);
        unint64_t v11 = *((void *)auth_data + 3);
        uint64_t v4 = *(void *)auth_data;
      }
      *((void *)auth_data + 3) = v11 - v9;
    }
    unint64_t v14 = v4 - 1;
    *(void *)auth_data = v14;
    if (v14 > v6)
    {
      uint64_t v15 = *((void *)auth_data + 2);
      do
      {
        *(void *)(v15 + 8 * v6) = *(void *)(v15 + 8 * v6 + 8) - v9;
        ++v6;
      }
      while (v6 < *(void *)auth_data);
    }
    return 0;
  }
}

size_t AEAAuthDataGetEncodedSize(AEAAuthData auth_data)
{
  return *((void *)auth_data + 3);
}

const uint8_t *__cdecl AEAAuthDataGetEncodedData(AEAAuthData auth_data)
{
  return (const uint8_t *)*((void *)auth_data + 5);
}

uint64_t apfs_scan_diskimage(const char *a1, uint64_t (*a2)(long long *, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  memset(&v60, 0, sizeof(v60));
  if (snprintf(__str, 0x400uLL, "%s.json", a1) > 0)
  {
    if (!stat(__str, &v60) && (v60.st_mode & 0xF000) == 0x8000)
    {
      unint64_t v11 = AAFileStreamOpenWithPath(__str, 0, 0);
      if (v11)
      {
        unint64_t v12 = 0;
LABEL_6:
        long long v67 = 0u;
        *(_OWORD *)unsigned int v68 = 0u;
        __srCC_SHA256_CTX c = 0;
        uint64_t v66 = 0;
        size_t v13 = (void **)AAJSONInputStreamOpen((uint64_t)v11);
        if (v13)
        {
          unint64_t v20 = v13;
          uint64_t v64 = 0;
          long long v62 = 0u;
          long long v63 = 0u;
          *(_OWORD *)__s1 = 0u;
          if ((AAJSONInputStreamRead((uint64_t)v13, (int *)__s1, v14, v15, v16, v17, v18, v19) & 0x80000000) == 0)
          {
            while (1)
            {
              int v27 = v64;
              if (!v64)
              {
                AAJSONInputStreamClose(v20);
                int v46 = 1;
                goto LABEL_66;
              }
              if (LODWORD(__s1[0]) < 2) {
                break;
              }
              if (LODWORD(__s1[0]) == 2)
              {
                if (v64 == 4)
                {
                  v68[1] = *(void *)(*(void *)&v68[2] - 64);
                  if ((a2(&v67, a4) & 0x80000000) != 0)
                  {
                    char v55 = "add_fork";
                    __int16 v56 = 58;
                    goto LABEL_88;
                  }
                  pc_array_free(*(uint64_t *)&v68[2]);
                  *(void *)&v68[2] = 0;
                  int v27 = v64;
                }
                if (v27 == 6)
                {
                  *(void *)&v68[2] = pc_array_append(*(uint64_t *)&v68[2], &__src, v21, v22, v23, v24, v25, v26);
                  if (!*(void *)&v68[2])
                  {
                    char v55 = "pc_array_append";
                    __int16 v56 = 67;
                    goto LABEL_88;
                  }
                }
              }
              else if (LODWORD(__s1[0]) == 4)
              {
                if (v64 == 7)
                {
                  unint64_t v29 = __s1[1];
                  if (!strcmp(__s1[1], "offset"))
                  {
                    __srCC_SHA256_CTX c = *((void *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v29, "length"))
                    {
                      char v55 = "bad map";
                      __int16 v56 = 83;
                      goto LABEL_88;
                    }
                    uint64_t v66 = *((void *)&v62 + 1);
                  }
                }
                else if (v64 == 5)
                {
                  unint64_t v28 = __s1[1];
                  if (!strcmp(__s1[1], "compression"))
                  {
                    v68[0] = BYTE8(v62);
                  }
                  else if (!strcmp(v28, "uncompressed_size"))
                  {
                    *(void *)&long long v67 = *((void *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v28, "size"))
                    {
                      char v55 = "bad map";
                      __int16 v56 = 77;
                      goto LABEL_88;
                    }
                    *((void *)&v67 + 1) = *((void *)&v62 + 1);
                  }
                }
              }
LABEL_38:
              uint64_t v64 = 0;
              long long v62 = 0u;
              long long v63 = 0u;
              *(_OWORD *)__s1 = 0u;
              if ((AAJSONInputStreamRead((uint64_t)v20, (int *)__s1, v21, v22, v23, v24, v25, v26) & 0x80000000) != 0) {
                goto LABEL_89;
              }
            }
            switch((int)v64)
            {
              case 2:
                if (!strcmp(__s1[1], "volumes")) {
                  goto LABEL_38;
                }
                char v55 = "bad map";
                __int16 v56 = 41;
                break;
              case 4:
                if (!strcmp(__s1[1], "files")) {
                  goto LABEL_38;
                }
                char v55 = "bad map";
                __int16 v56 = 42;
                break;
              case 5:
                long long v67 = 0u;
                *(_OWORD *)unsigned int v68 = 0u;
                *(void *)&v68[2] = pc_array_init(16);
                goto LABEL_38;
              case 6:
                if (!strcmp(__s1[1], "extents")) {
                  goto LABEL_38;
                }
                char v55 = "bad map";
                __int16 v56 = 43;
                break;
              case 8:
                char v55 = "bad map";
                __int16 v56 = 44;
                break;
              default:
                goto LABEL_38;
            }
LABEL_88:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", v56, 144, 0, v55, v25, v26, (char)v59);
          }
LABEL_89:
          char v54 = v20;
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", 27, 144, 0, "AAJSONInputStreamOpen", v18, v19, (char)v59);
          char v54 = 0;
        }
        AAJSONInputStreamClose(v54);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 181, 144, 0, "invalid image map JSON", v57, v58, (char)v59);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 114, 144, 0, "AAFileStreamOpenWithPath", v9, v10, (char)v59);
        unint64_t v12 = 0;
      }
      goto LABEL_65;
    }
    if (getenv("PC_APFS_DISKIMAGE_MAP") && (__strlcpy_chk(), !stat(__str, &v60)) && (v60.st_mode & 0xF000) == 0x8000
      || (size_t v30 = getenv("MASTERING_TOOLCHAIN_DIR")) != 0
      && (snprintf(__str, 0x400uLL, "%s%s/%s", v30, "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000|| (snprintf(__str, 0x400uLL, "%s/%s", "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000)
    {
      unint64_t v12 = (char *)malloc(0x40000uLL);
      if (v12)
      {
        unint64_t v11 = (AAByteStream_impl *)AATempStreamOpen(0x800000uLL);
        if (v11)
        {
          snprintf(v69, 0x400uLL, "%s \"%s\"", __str, a1);
          unint64_t v35 = popen(v69, "r");
          if (v35)
          {
            uint64_t v36 = v35;
            while (1)
            {
              if (feof(v36))
              {
                pclose(v36);
                AAByteStreamSeek(v11, 0, 0);
                goto LABEL_6;
              }
              size_t v37 = fread(v12, 1uLL, 0x40000uLL, v36);
              if (ferror(v36)) {
                break;
              }
              if (*((void *)v11 + 3))
              {
                uint64_t v40 = 0;
                if (v37)
                {
                  unint64_t v41 = v12;
                  size_t v42 = v37;
                  while (1)
                  {
                    uint64_t v43 = (*((uint64_t (**)(void, char *, size_t))v11 + 3))(*(void *)v11, v41, v42);
                    if (v43 < 1) {
                      break;
                    }
                    v41 += v43;
                    v40 += v43;
                    v42 -= v43;
                    if (!v42) {
                      goto LABEL_62;
                    }
                  }
                  uint64_t v40 = v43;
                }
              }
              else
              {
                uint64_t v40 = -1;
              }
LABEL_62:
              if (v40 != v37)
              {
                uint64_t v44 = "writing tool output";
                __int16 v45 = 172;
                goto LABEL_82;
              }
            }
            uint64_t v44 = "reading from tool pipe";
            __int16 v45 = 170;
LABEL_82:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v45, 144, 0, v44, v38, v39, (char)v59);
            AAByteStreamClose(v11);
            pclose(v36);
            goto LABEL_70;
          }
          int v53 = *__error();
          char v59 = v69;
          unint64_t v51 = "%s";
          __int16 v52 = 164;
        }
        else
        {
          unint64_t v51 = "temp stream open";
          __int16 v52 = 159;
          int v53 = 0;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v52, 144, v53, v51, v33, v34, (char)v59);
LABEL_69:
        AAByteStreamClose(v11);
LABEL_70:
        int v46 = 0;
        goto LABEL_71;
      }
      char v48 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 156, 144, *v48, "malloc", v49, v50, (char)v59);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 153, 144, 0, "could not locate the apfs diskimage map tool", v31, v32, (char)v59);
      unint64_t v12 = 0;
    }
    unint64_t v11 = 0;
    goto LABEL_69;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 110, 144, 0, "snprintf", v7, v8, (char)v59);
  unint64_t v12 = 0;
  unint64_t v11 = 0;
LABEL_65:
  int v46 = 0;
LABEL_66:
  AAByteStreamClose(v11);
LABEL_71:
  free(v12);
  if (v46) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t reStringAppend(uint64_t a1, const char *a2, uint64_t a3, char a4)
{
  uint64_t v8 = (void *)(a1 + 8);
  size_t v9 = a3 + *(void *)(a1 + 16) + 16;
  if (v9 <= *(void *)(a1 + 8)) {
    goto LABEL_5;
  }
  *(void *)(a1 + 8) = v9;
  if (v9 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_30:
    *(void *)a1 = 0;
    perror("malloc");
    *uint64_t v8 = 0;
    v8[1] = 0;
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(void **)a1;
  unint64_t v11 = realloc(*(void **)a1, v9);
  if (!v11)
  {
    free(v10);
    goto LABEL_30;
  }
  *(void *)a1 = v11;
LABEL_5:
  unint64_t v12 = "(^\\Q";
  if ((a4 & 4) == 0) {
    unint64_t v12 = "(^";
  }
  size_t v13 = "(\\Q";
  if ((a4 & 4) == 0) {
    size_t v13 = "(";
  }
  if (a4) {
    uint64_t v14 = v12;
  }
  else {
    uint64_t v14 = v13;
  }
  uint64_t v15 = "\\E)";
  if ((a4 & 4) == 0) {
    uint64_t v15 = ")";
  }
  uint64_t v16 = "\\E/)";
  if ((a4 & 4) == 0) {
    uint64_t v16 = "/)";
  }
  if ((a4 & 8) != 0) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = v15;
  }
  if ((a4 & 4) != 0) {
    uint64_t v18 = "\\E$)";
  }
  else {
    uint64_t v18 = "$)";
  }
  uint64_t v19 = *(void *)(a1 + 16);
  unint64_t v20 = *(unsigned char **)a1;
  if ((a4 & 2) != 0) {
    uint64_t v21 = v18;
  }
  else {
    uint64_t v21 = v17;
  }
  if (v19)
  {
    *(void *)(a1 + 16) = v19 + 1;
    v20[v19] = 124;
    unint64_t v20 = *(unsigned char **)a1;
    uint64_t v19 = *(void *)(a1 + 16);
  }
  strlcpy(&v20[v19], v14, *(void *)(a1 + 8) - v19);
  size_t v22 = strlen(v14);
  uint64_t v23 = *(void *)(a1 + 8);
  size_t v24 = *(void *)(a1 + 16) + v22;
  *(void *)(a1 + 16) = v24;
  strlcpy((char *)(*(void *)a1 + v24), a2, v23 - v24);
  uint64_t v25 = *(void *)(a1 + 8);
  uint64_t v26 = *(void *)(a1 + 16) + a3;
  *(void *)(a1 + 16) = v26;
  strlcpy((char *)(*(void *)a1 + v26), v21, v25 - v26);
  size_t v27 = strlen(v21);
  uint64_t result = 0;
  size_t v29 = *(void *)(a1 + 16) + v27;
  *(void *)(a1 + 16) = v29;
  *(unsigned char *)(*(void *)a1 + v29) = 0;
  return result;
}

void *AAPathFilterCreate()
{
  v0 = malloc(0xA8uLL);
  int v1 = v0;
  if (v0)
  {
    memset_s(v0, 0xA8uLL, 0, 0xA8uLL);
    v1[3] = StringTableCreate();
    v1[12] = StringTableCreate();
    v1[1] = StringTableCreate();
    uint64_t v2 = StringTableCreate();
    v1[2] = v2;
    if (!v1[3] || !v1[12] || !v1[1] || !v2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterCreate", 192, 130, 0, "StringTableCreate", v3, v4, v9);
      AAPathFilterDestroy((uint64_t)v1);
      return 0;
    }
  }
  else
  {
    uint64_t v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterCreate", 183, 130, *v5, "malloc", v6, v7, v9);
  }
  return v1;
}

void AAPathFilterDestroy(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 56)) {
      MEMORY[0x2166AE6C0](a1 + 64);
    }
    if (*(_DWORD *)(a1 + 128)) {
      MEMORY[0x2166AE6C0](a1 + 64);
    }
    StringTableDestroy(*(void ***)(a1 + 24));
    StringTableDestroy(*(void ***)(a1 + 96));
    StringTableDestroy(*(void ***)(a1 + 8));
    StringTableDestroy(*(void ***)(a1 + 16));
    free(*(void **)(a1 + 32));
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    free(*(void **)(a1 + 104));
    free((void *)a1);
  }
}

uint64_t AAPathFilterAddRule(uint64_t a1, unsigned int a2, unsigned int a3, char *__s, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)a1)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      MEMORY[0x2166AE6C0](a1 + 64);
      *(_DWORD *)(a1 + 56) = 0;
    }
    if (*(_DWORD *)(a1 + 128))
    {
      MEMORY[0x2166AE6C0](a1 + 64);
      *(_DWORD *)(a1 + 128) = 0;
    }
    *(_DWORD *)a1 = 0;
  }
  if (a2 >= 3)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 235, 130, 0, "invalid rule type: %u", a7, a8, a2);
  }
  else if (a3 >= 3)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 243, 130, 0, "invalid match type: %u", a7, a8, a3);
  }
  else
  {
    if (a2 == 2 && a3)
    {
      size_t v13 = "expected match type PREFIX for MAPTO rule";
      __int16 v14 = 246;
LABEL_58:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", v14, 130, 0, v13, a7, a8, v28);
      return 0xFFFFFFFFLL;
    }
    if (a2 == 2 && !a5)
    {
      size_t v13 = "mapto string is required for MAPTO rule";
      __int16 v14 = 248;
      goto LABEL_58;
    }
    if (a2 != 2 && a5)
    {
      size_t v13 = "mapto string is not allowed for non MAPTO rules";
      __int16 v14 = 250;
      goto LABEL_58;
    }
    if (!__s)
    {
      size_t v13 = "match string is required for all rules";
      __int16 v14 = 252;
      goto LABEL_58;
    }
    size_t v19 = strlen(__s);
    if (a3 != 1 && !pathIsValid(__s, v19))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 256, 130, 0, "invalid match path: %s", v17, v18, (char)__s);
      return 0xFFFFFFFFLL;
    }
    if (a5)
    {
      size_t v20 = strlen(a5);
      if (!pathIsValid(a5, v20))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 260, 130, 0, "invalid mapto path: %s", v17, v18, (char)a5);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      size_t v20 = 0;
    }
    if (a3 != 2 || v19 && !strchr(__s, 47))
    {
      if (a2 == 2)
      {
        if ((StringTableAppend(*(unsigned int **)(a1 + 8), __s, v19, 0, v15, v16, v17, v18) & 0x80000000) != 0)
        {
          size_t v13 = "StringTableAppend";
          __int16 v14 = 270;
          goto LABEL_58;
        }
        if ((StringTableAppend(*(unsigned int **)(a1 + 16), a5, v20, 0, v21, v22, a7, a8) & 0x80000000) != 0)
        {
          size_t v13 = "StringTableAppend";
          __int16 v14 = 271;
          goto LABEL_58;
        }
      }
      else
      {
        if (a2) {
          uint64_t v23 = a1 + 104;
        }
        else {
          uint64_t v23 = a1 + 32;
        }
        if (a3)
        {
          if (a3 != 2)
          {
            int v24 = reStringAppend(v23, __s, v19, 0);
            uint64_t result = 0;
            if ((v24 & 0x80000000) == 0) {
              return result;
            }
            size_t v13 = "error building regex";
            __int16 v14 = 283;
            goto LABEL_58;
          }
          v29[0] = 47;
          __memcpy_chk();
          size_t v27 = v19 + 1;
          v29[v19 + 1] = 0;
          if ((reStringAppend(v23, v29, v19 + 1, 6) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 299;
            goto LABEL_58;
          }
          v29[v27] = 47;
          v29[v19 + 2] = 0;
          if ((reStringAppend(v23, v29, v19 + 2, 4) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 303;
            goto LABEL_58;
          }
          __memcpy_chk();
          v29[v19] = 47;
          v29[v27] = 0;
          if ((reStringAppend(v23, v29, v19 + 1, 5) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 307;
            goto LABEL_58;
          }
          if ((reStringAppend(v23, __s, v19, 7) & 0x80000000) != 0)
          {
            size_t v13 = "error building regex";
            __int16 v14 = 310;
            goto LABEL_58;
          }
        }
        else
        {
          uint64_t v26 = 96;
          if (!a2) {
            uint64_t v26 = 24;
          }
          if ((StringTableAppend(*(unsigned int **)(a1 + v26), __s, v19, 0, v15, v16, v17, v18) & 0x80000000) != 0)
          {
            size_t v13 = "StringTableAppend";
            __int16 v14 = 289;
            goto LABEL_58;
          }
        }
      }
      return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterAddRule", 264, 130, 0, "invalid path for name match: %s", v17, v18, (char)__s);
  }
  return 0xFFFFFFFFLL;
}

uint64_t AAPathFilterApply(uint64_t a1, char *__s, size_t a3, char *a4)
{
  if (!*(_DWORD *)a1)
  {
    if (*(void *)(a1 + 48) && !*(_DWORD *)(a1 + 56))
    {
      int v13 = regcomp((regex_t *)(a1 + 64), *(const char **)(a1 + 32), 257);
      if (v13)
      {
        AAPathFilterApply_cold_2(v13, (const regex_t *)(a1 + 64));
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 56) = 1;
    }
    if (*(void *)(a1 + 120) && !*(_DWORD *)(a1 + 128))
    {
      int v14 = regcomp((regex_t *)(a1 + 136), *(const char **)(a1 + 104), 257);
      if (v14)
      {
        AAPathFilterApply_cold_1(v14, (const regex_t *)(a1 + 136));
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 128) = 1;
    }
    if ((StringTableSort(*(unsigned int **)(a1 + 24), 0) & 0x80000000) != 0)
    {
      __int16 v21 = 134;
    }
    else
    {
      if ((StringTableSort(*(unsigned int **)(a1 + 96), 0) & 0x80000000) == 0)
      {
        *(_DWORD *)a1 = 1;
        goto LABEL_2;
      }
      __int16 v21 = 135;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"prepareFilter", v21, 130, 0, "string table sort", v15, v16, v41);
LABEL_34:
    uint64_t v17 = "filter prepare";
    __int16 v18 = 325;
    goto LABEL_35;
  }
LABEL_2:
  size_t v8 = strlen(__s);
  if (!pathIsValid(__s, v8))
  {
    uint64_t v17 = "invalid input path";
    __int16 v18 = 327;
    goto LABEL_35;
  }
  if (!StringTableSize(*(unsigned int **)(a1 + 24)) && !*(_DWORD *)(a1 + 56)) {
    goto LABEL_25;
  }
  if (StringTableSize(*(unsigned int **)(a1 + 24)))
  {
    int v11 = StringTableMatchesPrefixSorted(*(void *)(a1 + 24), __s);
    BOOL v12 = v11 > 0;
    if (!*(_DWORD *)(a1 + 56))
    {
      if (v11 < 1) {
        return 2;
      }
      goto LABEL_25;
    }
  }
  else
  {
    if (!*(_DWORD *)(a1 + 56)) {
      return 2;
    }
    BOOL v12 = 0;
  }
  if (regexec((const regex_t *)(a1 + 64), __s, 0, 0, 0) && !v12) {
    return 2;
  }
LABEL_25:
  if (!StringTableSize(*(unsigned int **)(a1 + 96)) && !*(_DWORD *)(a1 + 128)) {
    goto LABEL_40;
  }
  if (StringTableSize(*(unsigned int **)(a1 + 96)))
  {
    int v19 = StringTableMatchesPrefixSorted(*(void *)(a1 + 96), __s);
    BOOL v20 = v19 > 0;
    if (!*(_DWORD *)(a1 + 128))
    {
      if (v19 <= 0) {
        goto LABEL_40;
      }
      return 2;
    }
  }
  else
  {
    if (!*(_DWORD *)(a1 + 128)) {
      goto LABEL_40;
    }
    BOOL v20 = 0;
  }
  int v23 = regexec((const regex_t *)(a1 + 136), __s, 0, 0, 0);
  uint64_t result = 2;
  if (v23)
  {
    if (!v20)
    {
LABEL_40:
      uint64_t result = StringTableSize(*(unsigned int **)(a1 + 8));
      if (!result) {
        return result;
      }
      unsigned int v24 = StringTableSize(*(unsigned int **)(a1 + 8));
      if (!v24) {
        return 2;
      }
      size_t v41 = a3;
      __dst = a4;
      uint64_t v25 = 0;
      size_t v26 = 0;
      uint64_t v27 = *(void *)(a1 + 8);
      uint64_t v28 = *(void *)(v27 + 32);
      uint64_t v29 = v24;
      uint64_t v30 = (unsigned int *)(*(void *)(v27 + 8) + 8);
      unsigned int v31 = -1;
      do
      {
        size_t v32 = *v30;
        if ((!v32
           || v8 >= v32
           && !memcmp((const void *)(v28 + *((void *)v30 - 1)), __s, *v30)
           && (v8 == v32 || __s[v32] == 47))
          && (v31 == -1 || v26 < v32))
        {
          unsigned int v31 = v25;
          size_t v26 = v32;
        }
        v30 += 4;
        ++v25;
      }
      while (v29 != v25);
      if (v31 == -1) {
        return 2;
      }
      if (!__dst) {
        return 0;
      }
      uint64_t v35 = *(void *)(a1 + 16);
      uint64_t v36 = *(void *)(v35 + 8);
      size_t v37 = *(unsigned int *)(v36 + 16 * v31 + 8);
      if (v37 >= v41)
      {
        uint64_t v17 = "insufficient out_capacity";
        __int16 v18 = 373;
      }
      else
      {
        size_t v38 = *(unsigned int *)(*(void *)(*(void *)(a1 + 8) + 8) + 16 * v31 + 8);
        memcpy(__dst, (const void *)(*(void *)(v35 + 32) + *(void *)(v36 + 16 * v31)), v37);
        if (v8 <= v38)
        {
LABEL_63:
          __dst[v37] = 0;
          return 1;
        }
        size_t v39 = v8 - v38 - (v37 == 0);
        size_t v40 = v39 + v37;
        if (v39 + v37 < v41)
        {
          memcpy(&__dst[v37], &__s[v8 - v39], v39);
          size_t v37 = v40;
          goto LABEL_63;
        }
        uint64_t v17 = "insufficient out_capacity";
        __int16 v18 = 379;
      }
LABEL_35:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathFilter.c", (uint64_t)"AAPathFilterApply", v18, 130, 0, v17, v9, v10, v41);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

size_t OUTLINED_FUNCTION_0@<X0>(int a1@<W0>, const regex_t *a2@<X1>, uint64_t a3@<X8>, uint64_t a4, uint64_t a5, long long a6, long long a7, long long a8, long long a9, long long a10, long long a11, int a12)
{
  *(void *)(v12 - 24) = a3;
  a12 = 0;
  a10 = 0u;
  a11 = 0u;
  a8 = 0u;
  a9 = 0u;
  a6 = 0u;
  a7 = 0u;
  return regerror(a1, a2, (char *)&a6, 0x64uLL);
}

size_t PCompressLZ4Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZ4Decode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result) {
    return -1;
  }
  return result;
}

BOOL aeaProfileIsValid(unsigned int a1)
{
  return a1 < 6;
}

uint64_t aeaContainerParamsInitWithProfile(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 6)
  {
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 48) = 32;
    *(void *)(a1 + 56) = 1;
    *(_OWORD *)(a1 + 12) = xmmword_214B12910;
    if (a2)
    {
      uint64_t v8 = 0;
      if (a2 == 5) {
        *(_DWORD *)(a1 + 8) = 0;
      }
    }
    else
    {
      uint64_t v8 = 0;
      *(void *)(a1 + 56) = 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithProfile", 31, 79, 0, "Invalid profile: %u", a7, a8, a2);
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t aeaChecksumSize(int a1)
{
  if (a1 == 2) {
    return 32;
  }
  else {
    return 8 * (a1 == 1);
  }
}

uint64_t aeaContainerParamsInitWithMagic(int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 == 826361153)
  {
    unsigned int v10 = a2[2];
    if (v10 < 0x4000001)
    {
      unsigned int v11 = a2[1];
      if ((v11 & 0xFFFFFF) < 6)
      {
        uint64_t v12 = 0;
        *a1 = v11 & 0xFFFFFF;
        a1[1] = v10;
        a1[2] = HIBYTE(v11);
        return v12;
      }
      char v14 = a2[1];
      uint64_t v8 = "Invalid profile: %u";
      __int16 v9 = 57;
    }
    else
    {
      uint64_t v8 = "Invalid AEA container (auth_data_size)";
      __int16 v9 = 55;
    }
  }
  else
  {
    uint64_t v8 = "Invalid magic bytes";
    __int16 v9 = 54;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithMagic", v9, 79, 0, v8, a7, a8, v14);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerParamsInitWithRootHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(unsigned __int8 *)(a2 + 25);
  if (v8 > 2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 74, 79, 0, "Invalid checksum in root header: %u", a7, a8, *(unsigned char *)(a2 + 25));
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 12) = v8;
  if (v8 == 2) {
    int v9 = 32;
  }
  else {
    int v9 = 8 * (v8 == 1);
  }
  *(_DWORD *)(a1 + 48) = v9;
  int v10 = *(char *)(a2 + 24);
  if (v10 <= 100)
  {
    switch(v10)
    {
      case '-':
        int v11 = 0;
        break;
      case '4':
        int v11 = 256;
        break;
      case 'b':
        int v11 = 1794;
        break;
      default:
        goto LABEL_21;
    }
  }
  else if (v10 > 119)
  {
    if (v10 == 120)
    {
      int v11 = 774;
    }
    else
    {
      if (v10 != 122) {
        goto LABEL_21;
      }
      int v11 = 1285;
    }
  }
  else
  {
    if (v10 != 101)
    {
      if (v10 == 102)
      {
        int v11 = 2304;
        goto LABEL_23;
      }
LABEL_21:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 81, 79, 0, "Invalid compression algorithm key in root header: %u", a7, a8, v10);
      return 0xFFFFFFFFLL;
    }
    int v11 = 2049;
  }
LABEL_23:
  *(_DWORD *)(a1 + 24) = v11;
  int v12 = *(_DWORD *)(a2 + 16);
  if ((v12 - 268435457) > 0xF0003FFE)
  {
    *(_DWORD *)(a1 + 16) = v12;
    int v13 = *(_DWORD *)(a2 + 20);
    if ((v13 - 262145) > 0xFFFC001E)
    {
      uint64_t v14 = 0;
      *(_DWORD *)(a1 + 20) = v13;
      *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
      return v14;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 89, 79, 0, "Invalid segments per cluster count in root header: %u", a7, a8, *(_DWORD *)(a2 + 20));
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaContainerParamsInitWithRootHeader", 85, 79, 0, "Invalid segment size in root header: %u", a7, a8, *(_DWORD *)(a2 + 16));
  }
  return 0xFFFFFFFFLL;
}

uint64_t aeaMagicInit(_DWORD *a1, _DWORD *a2)
{
  *a1 = 826361153;
  int v2 = a2[1];
  a1[1] = *a2 & 0xFFFFFF | (a2[2] << 24);
  a1[2] = v2;
  return 0;
}

uint64_t aeaRootHeaderInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a2 + 24);
  if (v8 <= 1284)
  {
    switch(v8)
    {
      case 0:
        char v9 = 45;
        goto LABEL_18;
      case 256:
        char v9 = 52;
        goto LABEL_18;
      case 774:
        char v9 = 120;
        goto LABEL_18;
    }
  }
  else if (v8 > 2048)
  {
    if (v8 == 2049)
    {
      char v9 = 101;
      goto LABEL_18;
    }
    if (v8 == 2304)
    {
      char v9 = 102;
      goto LABEL_18;
    }
  }
  else
  {
    if (v8 == 1285)
    {
      char v9 = 122;
      goto LABEL_18;
    }
    if (v8 == 1794)
    {
      char v9 = 98;
LABEL_18:
      uint64_t v10 = 0;
      *(unsigned char *)(a1 + 25) = *(_DWORD *)(a2 + 12);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(unsigned char *)(a1 + 24) = v9;
      *(_OWORD *)a1 = *(_OWORD *)(a2 + 32);
      return v10;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaRootHeaderInit", 117, 79, 0, "Invalid compression algorithm in context", a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerOffsetsInit(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v3 = a2[5];
  *(_OWORD *)a1 = xmmword_214B12920;
  uint64_t v4 = a2[1] + 12;
  uint64_t v5 = a3[12];
  uint64_t v6 = v4 + a3[11];
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v6;
  uint64_t v7 = v6 + v5;
  uint64_t v8 = a3[3];
  uint64_t v9 = v7 + a3[2];
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = v9;
  uint64_t v10 = v9 + v8;
  uint64_t v11 = v9 + v8 + 48;
  *(void *)(a1 + 48) = v10;
  *(void *)(a1 + 56) = v11;
  *(void *)(a1 + 64) = v11 + v8;
  *(void *)(a1 + 72) = 0;
  uint64_t v12 = (a2[12] + 8) * v3;
  *(void *)(a1 + 80) = v12;
  *(void *)(a1 + 88) = v12 + v8;
  *(void *)(a1 + 96) = v12 + v8 + v8 * (unint64_t)v3;
  return 0;
}

uint64_t aeaChecksum(uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t result = 0;
    *(_DWORD *)a1 = 0;
    return result;
  }
  CC_LONG v9 = a4;
  uint64_t v10 = a3;
  if (a2 == 2)
  {
    memset(&v20, 0, sizeof(v20));
    CC_SHA256_Init(&v20);
    CC_SHA256_Update(&v20, v10, v9);
    CC_SHA256_Final((unsigned __int8 *)(a1 + 4), &v20);
    *(_DWORD *)a1 = 32;
    uint64_t v16 = (void *)(a1 + 36);
    rsize_t v17 = 224;
    rsize_t v18 = 224;
LABEL_15:
    memset_s(v16, v17, 0, v18);
    return 0;
  }
  if (a2 == 1)
  {
    unint64_t v11 = (0xC6A4A7935BD1E995 * a4) ^ 0xE2236FDC26A5F6D2;
    unint64_t v12 = (unint64_t)a3 + a4;
    if (a4 >= 16)
    {
      do
      {
        unint64_t v11 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995
              * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * *v10) ^ ((0xC6A4A7935BD1E995 * *v10) >> 47))) ^ v11)) ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v10[1]) ^ ((0xC6A4A7935BD1E995 * v10[1]) >> 47))));
        int v13 = v10 + 2;
        uint64_t v14 = v10 + 4;
        v10 += 2;
      }
      while ((unint64_t)v14 <= v12);
    }
    else
    {
      int v13 = a3;
    }
    if ((unint64_t)(v13 + 1) <= v12)
    {
      do
      {
        unint64_t v11 = 0xC6A4A7935BD1E995
            * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * *v13) ^ ((0xC6A4A7935BD1E995 * *v13) >> 47))) ^ v11);
        BOOL v15 = (unint64_t)(v13 + 2) > v12;
        ++v13;
      }
      while (!v15);
    }
    if ((a4 & 7) != 0)
    {
      *(void *)v20.count = 0;
      __memcpy_chk();
      v11 *= 0xC6A4A7935BD1E995;
    }
    *(void *)(a1 + 4) = (0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v11 ^ (v11 >> 47))) >> 47);
    *(_DWORD *)a1 = 8;
    uint64_t v16 = (void *)(a1 + 12);
    rsize_t v17 = 248;
    rsize_t v18 = 248;
    goto LABEL_15;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaChecksum", 228, 79, 0, "Invalid checksum mode", a7, a8, v20.count[0]);
  return 0xFFFFFFFFLL;
}

uint64_t aeaEffectiveCompressionAlgorithm(uint64_t result)
{
  if (result == 256) {
    return 257;
  }
  else {
    return result;
  }
}

uint64_t aeaDeriveMainKeyExisting(unsigned int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, _DWORD *a9, _DWORD *a10, uint64_t (*a11)(uint64_t, void, char *, long long *, unsigned int *, void), uint64_t a12)
{
  uint64_t v134 = *MEMORY[0x263EF8340];
  int v63 = 0;
  memset(v62, 0, sizeof(v62));
  int v16 = *a2 & 0xFFFFFF | (a2[2] << 24);
  switch(*a2)
  {
    case 0:
      memset(v133, 0, sizeof(v133));
      long long v132 = 0uLL;
      long long v131 = 0uLL;
      long long v130 = 0uLL;
      long long v129 = 0uLL;
      long long v128 = 0uLL;
      long long v127 = 0uLL;
      long long v126 = 0uLL;
      long long v125 = 0uLL;
      long long v124 = 0uLL;
      long long v123 = 0uLL;
      long long v122 = 0uLL;
      long long v121 = 0uLL;
      long long v120 = 0uLL;
      *(_OWORD *)&__s[8] = 0uLL;
      if (*a6 != *a1) {
        goto LABEL_60;
      }
      if (*a10 != a1[2]) {
        goto LABEL_67;
      }
      if (a1[5]) {
        goto LABEL_59;
      }
      if (*a7 != a1[8]) {
        goto LABEL_112;
      }
      *(_DWORD *)&__s[7] = 1263354207;
      *(void *)size_t __s = 0x5F41454100000007;
      memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
      *(_DWORD *)size_t __s = 11;
      memset_s(&__s[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      size_t v59 = *a7;
      unint64_t v60 = *(unsigned int *)__s + v59;
      if (v60 >= 0x101) {
        goto LABEL_135;
      }
      memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v59);
      *(_DWORD *)size_t __s = v60;
      memset_s(&__s[v60 + 4], 256 - v60, 0, 256 - v60);
      CC_SHA256_CTX v20 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, unsigned char *, _DWORD *))*((void *)a1 + 9);
      if (!v20 || !*a6) {
        goto LABEL_113;
      }
      uint64_t v21 = *a1;
      uint64_t v22 = a3;
      int v23 = a6;
      goto LABEL_111;
    case 1:
    case 2:
      memset(v133, 0, sizeof(v133));
      long long v132 = 0uLL;
      long long v131 = 0uLL;
      long long v130 = 0uLL;
      long long v129 = 0uLL;
      long long v128 = 0uLL;
      long long v127 = 0uLL;
      long long v126 = 0uLL;
      long long v125 = 0uLL;
      long long v124 = 0uLL;
      long long v123 = 0uLL;
      long long v122 = 0uLL;
      long long v121 = 0uLL;
      long long v120 = 0uLL;
      *(_OWORD *)&__s[8] = 0uLL;
      if (*a4 != *a1) {
        goto LABEL_60;
      }
      if (*a10 != a1[2]) {
        goto LABEL_67;
      }
      if (a1[5]) {
        goto LABEL_59;
      }
      if (*a7 != a1[8]) {
        goto LABEL_112;
      }
      *(_DWORD *)&__s[7] = 1263354207;
      *(void *)size_t __s = 0x5F41454100000007;
      memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
      *(_DWORD *)size_t __s = 11;
      memset_s(&__s[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      memset_s(&__s[*(unsigned int *)__s + 4], 256 - *(unsigned int *)__s, 0, 256 - *(unsigned int *)__s);
      size_t v18 = *a7;
      unint64_t v19 = *(unsigned int *)__s + v18;
      if (v19 >= 0x101) {
        goto LABEL_135;
      }
      memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v18);
      *(_DWORD *)size_t __s = v19;
      memset_s(&__s[v19 + 4], 256 - v19, 0, 256 - v19);
      CC_SHA256_CTX v20 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, unsigned char *, _DWORD *))*((void *)a1 + 9);
      if (v20 && *a4)
      {
        uint64_t v21 = *a1;
        uint64_t v22 = a3;
        int v23 = a4;
        goto LABEL_111;
      }
LABEL_113:
      int v33 = -1;
      goto LABEL_114;
    case 3:
    case 4:
      if (!a11 || !*a8)
      {
        int v118 = 0;
        long long v117 = 0uLL;
        long long v116 = 0uLL;
        long long v115 = 0uLL;
        long long v114 = 0uLL;
        long long v113 = 0uLL;
        long long v112 = 0uLL;
        long long v111 = 0uLL;
        long long v110 = 0uLL;
        long long v109 = 0uLL;
        long long v108 = 0uLL;
        long long v107 = 0uLL;
        long long v106 = 0uLL;
        long long v105 = 0uLL;
        long long v104 = 0uLL;
        long long v103 = 0uLL;
        long long v102 = 0uLL;
        int v101 = 0;
        long long v100 = 0uLL;
        long long v99 = 0uLL;
        long long v98 = 0uLL;
        long long v97 = 0uLL;
        long long v96 = 0uLL;
        long long v95 = 0uLL;
        long long v94 = 0uLL;
        long long v93 = 0uLL;
        long long v92 = 0uLL;
        long long v91 = 0uLL;
        long long v90 = 0uLL;
        long long v89 = 0uLL;
        long long v88 = 0uLL;
        long long v87 = 0uLL;
        long long v86 = 0uLL;
        *(_OWORD *)char __n = 0uLL;
        if (*((void *)a1 + 9)
          && (uint64_t v34 = (uint64_t (*)(long long *, unsigned int *, _DWORD *))*((void *)a1 + 14)) != 0
          && *((void *)a1 + 20))
        {
          if (*a6 == a1[5])
          {
            if (*a9 == a1[4])
            {
              if ((v34(&v102, a6, a9) & 0x80000000) != 0)
              {
                int v43 = -4;
              }
              else if (v102 == a1[6])
              {
                if (((*((uint64_t (**)(size_t *, _DWORD *))a1 + 20))(__n, a9) & 0x80000000) != 0)
                {
                  int v43 = -6;
                }
                else
                {
                  memset(v133, 0, sizeof(v133));
                  long long v132 = 0u;
                  long long v131 = 0u;
                  long long v130 = 0u;
                  long long v129 = 0u;
                  long long v128 = 0u;
                  long long v127 = 0u;
                  long long v126 = 0u;
                  long long v125 = 0u;
                  long long v124 = 0u;
                  long long v123 = 0u;
                  long long v122 = 0u;
                  long long v121 = 0u;
                  long long v120 = 0u;
                  *(_OWORD *)&__s[8] = 0u;
                  if (v102 == *a1)
                  {
                    if (*a10 == a1[2])
                    {
                      if (*a6 == a1[5])
                      {
                        if (LODWORD(__n[0]) == *a6)
                        {
                          if (*a7 == a1[8])
                          {
                            *(_DWORD *)&__s[7] = 1263354207;
                            *(void *)size_t __s = 0x5F41454100000007;
                            memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
                            uint64_t v35 = *(unsigned int *)__s;
                            if (*(_DWORD *)__s >= 0xFDu) {
                              goto LABEL_135;
                            }
                            *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
                            *(_DWORD *)size_t __s = v35 + 4;
                            memset_s(&__s[v35 + 8], 252 - v35, 0, 252 - v35);
                            size_t v36 = *a6;
                            unint64_t v37 = *(unsigned int *)__s + v36;
                            if (v37 >= 0x101) {
                              goto LABEL_135;
                            }
                            memcpy(&__s[*(unsigned int *)__s + 4], a6 + 1, v36);
                            *(_DWORD *)size_t __s = v37;
                            memset_s(&__s[v37 + 4], 256 - v37, 0, 256 - v37);
                            unint64_t v38 = *(unsigned int *)__s + (unint64_t)LODWORD(__n[0]);
                            if (v38 >= 0x101) {
                              goto LABEL_135;
                            }
                            memcpy(&__s[*(unsigned int *)__s + 4], (char *)__n + 4, LODWORD(__n[0]));
                            *(_DWORD *)size_t __s = v38;
                            memset_s(&__s[v38 + 4], 256 - v38, 0, 256 - v38);
                            size_t v39 = *a7;
                            unint64_t v40 = *(unsigned int *)__s + v39;
                            if (v40 >= 0x101) {
                              goto LABEL_135;
                            }
                            memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v39);
                            *(_DWORD *)size_t __s = v40;
                            memset_s(&__s[v40 + 4], 256 - v40, 0, 256 - v40);
                            size_t v41 = (uint64_t (*)(_DWORD *, void, long long *, unsigned char *, _DWORD *))*((void *)a1 + 9);
                            int v42 = -1;
                            if (v41 && v102) {
                              int v42 = v41(a3, *a1, &v102, __s, a10);
                            }
                            if (*a3 == *a1) {
                              int v43 = v42;
                            }
                            else {
                              int v43 = -1006;
                            }
                            memset_s(__s, 0x104uLL, 0, 0x104uLL);
                            if (v43) {
                              memset_s(a3, 0x104uLL, 0, 0x104uLL);
                            }
                          }
                          else
                          {
                            int v43 = -1005;
                          }
                        }
                        else
                        {
                          int v43 = -1004;
                        }
                      }
                      else
                      {
                        int v43 = -1003;
                      }
                    }
                    else
                    {
                      int v43 = -1002;
                    }
                  }
                  else
                  {
                    int v43 = -1001;
                  }
                }
              }
              else
              {
                int v43 = -5;
              }
            }
            else
            {
              int v43 = -3;
            }
          }
          else
          {
            int v43 = -2;
          }
        }
        else
        {
          int v43 = -1;
        }
        memset_s(&v102, 0x104uLL, 0, 0x104uLL);
        uint64_t v47 = __n;
LABEL_70:
        memset_s(v47, 0x104uLL, 0, 0x104uLL);
        goto LABEL_71;
      }
      *(void *)&long long v102 = 0;
      uint64_t v25 = a6 + 1;
      if ((a11(a12, a1[6], (char *)v62 + 4, &v102, a6 + 1, *a6) & 0x80000000) != 0)
      {
        uint64_t v44 = "DH callback";
        __int16 v45 = 321;
        goto LABEL_74;
      }
      if ((void)v102 != a1[6])
      {
        uint64_t v44 = "DH callback returning invalid shared secret size";
        __int16 v45 = 322;
        goto LABEL_74;
      }
      if ((unint64_t)v102 >= 0x101) {
        goto LABEL_135;
      }
      LODWORD(v62[0]) = v102;
      memset_s((char *)v62 + v102 + 4, 256 - v102, 0, 256 - v102);
      memset(v133, 0, sizeof(v133));
      long long v132 = 0u;
      long long v131 = 0u;
      long long v130 = 0u;
      long long v129 = 0u;
      long long v128 = 0u;
      long long v127 = 0u;
      long long v126 = 0u;
      long long v125 = 0u;
      long long v124 = 0u;
      long long v123 = 0u;
      long long v122 = 0u;
      long long v121 = 0u;
      long long v120 = 0u;
      *(_OWORD *)&__s[8] = 0u;
      if (LODWORD(v62[0]) == *a1)
      {
        if (*a10 == a1[2])
        {
          if (*a6 == a1[5])
          {
            if (*a8 != *a6)
            {
              int v43 = -1004;
              goto LABEL_71;
            }
            if (*a7 != a1[8])
            {
LABEL_112:
              int v43 = -1005;
              goto LABEL_71;
            }
            *(_DWORD *)&__s[7] = 1263354207;
            *(void *)size_t __s = 0x5F41454100000007;
            memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
            uint64_t v26 = *(unsigned int *)__s;
            if (*(_DWORD *)__s < 0xFDu)
            {
              *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
              *(_DWORD *)size_t __s = v26 + 4;
              memset_s(&__s[v26 + 8], 252 - v26, 0, 252 - v26);
              size_t v27 = *a6;
              unint64_t v28 = *(unsigned int *)__s + v27;
              if (v28 < 0x101)
              {
                memcpy(&__s[*(unsigned int *)__s + 4], v25, v27);
                *(_DWORD *)size_t __s = v28;
                memset_s(&__s[v28 + 4], 256 - v28, 0, 256 - v28);
                size_t v29 = *a8;
                unint64_t v30 = *(unsigned int *)__s + v29;
                if (v30 < 0x101)
                {
                  memcpy(&__s[*(unsigned int *)__s + 4], a8 + 1, v29);
                  *(_DWORD *)size_t __s = v30;
                  memset_s(&__s[v30 + 4], 256 - v30, 0, 256 - v30);
                  size_t v31 = *a7;
                  unint64_t v32 = *(unsigned int *)__s + v31;
                  if (v32 < 0x101)
                  {
                    memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v31);
                    *(_DWORD *)size_t __s = v32;
                    memset_s(&__s[v32 + 4], 256 - v32, 0, 256 - v32);
                    CC_SHA256_CTX v20 = (uint64_t (*)(_DWORD *, uint64_t, _OWORD *, unsigned char *, _DWORD *))*((void *)a1 + 9);
                    int v33 = -1;
                    if (v20 && LODWORD(v62[0]))
                    {
                      uint64_t v21 = *a1;
                      int v23 = v62;
                      uint64_t v22 = a3;
LABEL_111:
                      int v33 = v20(v22, v21, v23, __s, a10);
                    }
LABEL_114:
                    if (*a3 == *a1) {
                      int v43 = v33;
                    }
                    else {
                      int v43 = -1006;
                    }
                    memset_s(__s, 0x104uLL, 0, 0x104uLL);
                    if (!v43) {
                      goto LABEL_71;
                    }
                    uint64_t v47 = (size_t *)a3;
                    goto LABEL_70;
                  }
                }
              }
            }
LABEL_135:
            __break(1u);
            JUMPOUT(0x214A99E1CLL);
          }
LABEL_59:
          int v43 = -1003;
        }
        else
        {
LABEL_67:
          int v43 = -1002;
        }
      }
      else
      {
LABEL_60:
        int v43 = -1001;
      }
LABEL_71:
      if ((v43 & 0x80000000) == 0)
      {
        uint64_t v48 = 0;
        goto LABEL_77;
      }
      char v61 = v43;
      uint64_t v44 = "Main key derivation failed (%d)";
      __int16 v45 = 353;
LABEL_74:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaDeriveMainKeyExisting", v45, 79, 0, v44, (uint64_t)a7, (uint64_t)a8, v61);
      if (a3) {
        memset_s(a3, 0x104uLL, 0, 0x104uLL);
      }
      uint64_t v48 = 0xFFFFFFFFLL;
LABEL_77:
      memset_s(v62, 0x104uLL, 0, 0x104uLL);
      return v48;
    case 5:
      int v118 = 0;
      long long v117 = 0uLL;
      long long v116 = 0uLL;
      long long v115 = 0uLL;
      long long v114 = 0uLL;
      long long v113 = 0uLL;
      long long v112 = 0uLL;
      long long v111 = 0uLL;
      long long v110 = 0uLL;
      long long v109 = 0uLL;
      long long v108 = 0uLL;
      long long v107 = 0uLL;
      long long v106 = 0uLL;
      long long v105 = 0uLL;
      long long v104 = 0uLL;
      long long v103 = 0uLL;
      long long v102 = 0uLL;
      int v101 = 0;
      long long v100 = 0uLL;
      long long v99 = 0uLL;
      long long v98 = 0uLL;
      long long v97 = 0uLL;
      long long v96 = 0uLL;
      long long v95 = 0uLL;
      long long v94 = 0uLL;
      long long v93 = 0uLL;
      long long v92 = 0uLL;
      long long v91 = 0uLL;
      long long v90 = 0uLL;
      long long v89 = 0uLL;
      long long v88 = 0uLL;
      long long v87 = 0uLL;
      long long v86 = 0uLL;
      *(_OWORD *)char __n = 0uLL;
      int v84 = 0;
      long long v83 = 0uLL;
      long long v82 = 0uLL;
      long long v81 = 0uLL;
      long long v79 = 0uLL;
      long long v80 = 0uLL;
      long long v77 = 0uLL;
      long long v78 = 0uLL;
      long long v75 = 0uLL;
      long long v76 = 0uLL;
      long long v73 = 0uLL;
      long long v74 = 0uLL;
      long long v71 = 0uLL;
      long long v72 = 0uLL;
      long long v69 = 0uLL;
      long long v70 = 0uLL;
      *(_OWORD *)unsigned int v68 = 0uLL;
      int v67 = 0;
      memset(v66, 0, sizeof(v66));
      int v65 = 0;
      memset(v64, 0, sizeof(v64));
      if (*((void *)a1 + 10) && *((void *)a1 + 9))
      {
        if (*a5 >= 0x14u)
        {
          if (*a10 == a1[2])
          {
            WORD2(__n[1]) = 21584;
            *(size_t *)((char *)__n + 4) = *(void *)"AEA_SCRYPT";
            LODWORD(__n[0]) = 10;
            memset_s((void *)((unint64_t)__n | 0xE), 0xF6uLL, 0, 0xF6uLL);
            if (((*((uint64_t (**)(long long *, void, _DWORD *, size_t *, size_t *))a1 + 9))(&v102, 2 * a1[2], a10, __n, v68) & 0x80000000) != 0)
            {
              int v43 = -4;
            }
            else
            {
              uint64_t v50 = a1[2];
              if (v50 >= 0x101) {
                goto LABEL_135;
              }
              __memcpy_chk();
              LODWORD(v66[0]) = v50;
              memset_s((char *)v66 + v50 + 4, 256 - v50, 0, 256 - v50);
              uint64_t v51 = a1[2];
              if (v51 >= 0x101) {
                goto LABEL_135;
              }
              __memcpy_chk();
              LODWORD(v64[0]) = v51;
              memset_s((char *)v64 + v51 + 4, 256 - v51, 0, 256 - v51);
              memset_s(&v102, 0x104uLL, 0, 0x104uLL);
              if (((*((uint64_t (**)(long long *, _DWORD *, void, void, _OWORD *))a1 + 10))(&v102, a5 + 1, *a5, a1[14], v66) & 0x80000000) != 0)
              {
                int v43 = -5;
              }
              else
              {
                memset(v133, 0, sizeof(v133));
                long long v132 = 0u;
                long long v131 = 0u;
                long long v130 = 0u;
                long long v129 = 0u;
                long long v128 = 0u;
                long long v127 = 0u;
                long long v126 = 0u;
                long long v125 = 0u;
                long long v124 = 0u;
                long long v123 = 0u;
                long long v122 = 0u;
                long long v121 = 0u;
                long long v120 = 0u;
                *(_OWORD *)&__s[8] = 0u;
                if (v102 == *a1)
                {
                  if (LODWORD(v64[0]) == a1[2])
                  {
                    if (LODWORD(v68[0]) == a1[5])
                    {
                      if (*a7 == a1[8])
                      {
                        *(_DWORD *)&__s[7] = 1263354207;
                        *(void *)size_t __s = 0x5F41454100000007;
                        memset_s(&__s[11], 0xF9uLL, 0, 0xF9uLL);
                        uint64_t v52 = *(unsigned int *)__s;
                        if (*(_DWORD *)__s >= 0xFDu) {
                          goto LABEL_135;
                        }
                        *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v16;
                        *(_DWORD *)size_t __s = v52 + 4;
                        memset_s(&__s[v52 + 8], 252 - v52, 0, 252 - v52);
                        unint64_t v53 = *(unsigned int *)__s + (unint64_t)LODWORD(v68[0]);
                        if (v53 >= 0x101) {
                          goto LABEL_135;
                        }
                        memcpy(&__s[*(unsigned int *)__s + 4], (char *)v68 + 4, LODWORD(v68[0]));
                        *(_DWORD *)size_t __s = v53;
                        memset_s(&__s[v53 + 4], 256 - v53, 0, 256 - v53);
                        unint64_t v54 = *(unsigned int *)__s + (unint64_t)LODWORD(v68[0]);
                        if (v54 >= 0x101) {
                          goto LABEL_135;
                        }
                        memcpy(&__s[*(unsigned int *)__s + 4], (char *)v68 + 4, LODWORD(v68[0]));
                        *(_DWORD *)size_t __s = v54;
                        memset_s(&__s[v54 + 4], 256 - v54, 0, 256 - v54);
                        size_t v55 = *a7;
                        unint64_t v56 = *(unsigned int *)__s + v55;
                        if (v56 >= 0x101) {
                          goto LABEL_135;
                        }
                        memcpy(&__s[*(unsigned int *)__s + 4], a7 + 1, v55);
                        *(_DWORD *)size_t __s = v56;
                        memset_s(&__s[v56 + 4], 256 - v56, 0, 256 - v56);
                        uint64_t v57 = (uint64_t (*)(_DWORD *, void, long long *, unsigned char *, _OWORD *))*((void *)a1 + 9);
                        int v58 = -1;
                        if (v57 && v102) {
                          int v58 = v57(a3, *a1, &v102, __s, v64);
                        }
                        if (*a3 == *a1) {
                          int v43 = v58;
                        }
                        else {
                          int v43 = -1006;
                        }
                        memset_s(__s, 0x104uLL, 0, 0x104uLL);
                        if (v43) {
                          memset_s(a3, 0x104uLL, 0, 0x104uLL);
                        }
                      }
                      else
                      {
                        int v43 = -1005;
                      }
                    }
                    else
                    {
                      int v43 = -1003;
                    }
                  }
                  else
                  {
                    int v43 = -1002;
                  }
                }
                else
                {
                  int v43 = -1001;
                }
              }
            }
          }
          else
          {
            int v43 = -3;
          }
        }
        else
        {
          int v43 = -2;
        }
      }
      else
      {
        int v43 = -1;
      }
      memset_s(&v102, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v66, 0x104uLL, 0, 0x104uLL);
      uint64_t v47 = (size_t *)v64;
      goto LABEL_70;
    default:
      uint64_t v44 = "Unsupported profile";
      __int16 v45 = 351;
      goto LABEL_74;
  }
}

uint64_t aeaDeriveMainKeyNew(unsigned int *a1, int *a2, long long *a3, int *a4, char *__s, int *a6, _DWORD *a7, unsigned int *a8, unsigned int *a9)
{
  uint64_t v117 = *MEMORY[0x263EF8340];
  int v16 = *a2;
  int v17 = a2[2];
  uint64_t v18 = a1[2];
  if (__s) {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }
  if (v18 > 0x100
    || (unint64_t v19 = (uint64_t (*)(char *, uint64_t))*((void *)a1 + 8)) == 0
    || (v19(__s + 4, v18) & 0x80000000) != 0)
  {
    uint64_t v22 = "generating random salt";
    __int16 v23 = 380;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaDeriveMainKeyNew", v23, 79, 0, v22, (uint64_t)a7, (uint64_t)a8, v60);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)size_t __s = v18;
  int v20 = v16 & 0xFFFFFF | (v17 << 24);
  switch(*a2)
  {
    case 0:
      uint64_t v37 = a1[12];
      if (a4) {
        memset_s(a4, 0x104uLL, 0, 0x104uLL);
      }
      if (v37 > 0x100
        || (unint64_t v38 = (uint64_t (*)(int *, uint64_t))*((void *)a1 + 8)) == 0
        || (v38(a4 + 1, v37) & 0x80000000) != 0)
      {
        uint64_t v22 = "generating random encryption key";
        __int16 v23 = 390;
        goto LABEL_12;
      }
      *a4 = v37;
      memset(v116, 0, sizeof(v116));
      long long v115 = 0u;
      long long v114 = 0u;
      long long v113 = 0u;
      long long v112 = 0u;
      long long v111 = 0u;
      long long v110 = 0u;
      long long v109 = 0u;
      long long v108 = 0u;
      long long v107 = 0u;
      long long v106 = 0u;
      long long v105 = 0u;
      long long v104 = 0u;
      long long v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if (v37 == *a1)
      {
        if (*(_DWORD *)__s == a1[2])
        {
          if (a1[5])
          {
LABEL_10:
            int v21 = -1003;
          }
          else
          {
            if (*a8 == a1[8])
            {
              *(_DWORD *)&v102[7] = 1263354207;
              *(void *)long long v102 = 0x5F41454100000007;
              memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
              *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
              *(_DWORD *)long long v102 = 11;
              memset_s(&v102[15], 0xF5uLL, 0, 0xF5uLL);
              memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
              memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
              size_t v39 = *a8;
              unint64_t v40 = *(unsigned int *)v102 + v39;
              if (v40 < 0x101)
              {
                memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v39);
                *(_DWORD *)long long v102 = v40;
                memset_s(&v102[v40 + 4], 256 - v40, 0, 256 - v40);
                size_t v41 = (uint64_t (*)(long long *, uint64_t, int *, unsigned char *, char *))*((void *)a1 + 9);
                if (v41)
                {
                  int v42 = a3;
                  if (*a4)
                  {
                    uint64_t v43 = *a1;
                    uint64_t v44 = a3;
                    __int16 v45 = a4;
LABEL_84:
                    int v59 = v41(v44, v43, v45, v102, __s);
                  }
                  else
                  {
LABEL_93:
                    int v59 = -1;
                  }
                }
                else
                {
LABEL_90:
                  int v59 = -1;
                  int v42 = a3;
                }
                if (*(_DWORD *)v42 == *a1) {
                  int v21 = v59;
                }
                else {
                  int v21 = -1006;
                }
                memset_s(v102, 0x104uLL, 0, 0x104uLL);
                if (!v21) {
                  goto LABEL_115;
                }
                p_sa = v42;
                goto LABEL_114;
              }
LABEL_124:
              __break(1u);
              JUMPOUT(0x214A9AB90);
            }
LABEL_87:
            int v21 = -1005;
          }
        }
        else
        {
LABEL_58:
          int v21 = -1002;
        }
      }
      else
      {
LABEL_50:
        int v21 = -1001;
      }
LABEL_115:
      if ((v21 & 0x80000000) == 0) {
        return 0;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"aeaDeriveMainKeyNew", 437, 79, 0, "Main key derivation failed (%d)", (uint64_t)a7, (uint64_t)a8, v21);
      return 0xFFFFFFFFLL;
    case 1:
    case 2:
      memset(v116, 0, sizeof(v116));
      long long v115 = 0u;
      long long v114 = 0u;
      long long v113 = 0u;
      long long v112 = 0u;
      long long v111 = 0u;
      long long v110 = 0u;
      long long v109 = 0u;
      long long v108 = 0u;
      long long v107 = 0u;
      long long v106 = 0u;
      long long v105 = 0u;
      long long v104 = 0u;
      long long v103 = 0u;
      *(_OWORD *)&v102[8] = 0u;
      if (*a6 != *a1) {
        goto LABEL_50;
      }
      if (v18 != a1[2]) {
        goto LABEL_58;
      }
      if (a1[5]) {
        goto LABEL_10;
      }
      if (*a8 != a1[8]) {
        goto LABEL_87;
      }
      *(_DWORD *)&v102[7] = 1263354207;
      *(void *)long long v102 = 0x5F41454100000007;
      memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
      *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
      *(_DWORD *)long long v102 = 11;
      memset_s(&v102[15], 0xF5uLL, 0, 0xF5uLL);
      memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
      memset_s(&v102[*(unsigned int *)v102 + 4], 256 - *(unsigned int *)v102, 0, 256 - *(unsigned int *)v102);
      size_t v57 = *a8;
      unint64_t v58 = *(unsigned int *)v102 + v57;
      if (v58 >= 0x101) {
        goto LABEL_124;
      }
      memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v57);
      *(_DWORD *)long long v102 = v58;
      memset_s(&v102[v58 + 4], 256 - v58, 0, 256 - v58);
      size_t v41 = (uint64_t (*)(long long *, uint64_t, int *, unsigned char *, char *))*((void *)a1 + 9);
      if (!v41) {
        goto LABEL_90;
      }
      int v42 = a3;
      if (!*a6) {
        goto LABEL_93;
      }
      uint64_t v43 = *a1;
      uint64_t v44 = a3;
      __int16 v45 = a6;
      goto LABEL_84;
    case 3:
    case 4:
      int v101 = 0;
      long long v100 = 0u;
      long long v99 = 0u;
      long long v98 = 0u;
      long long v97 = 0u;
      long long v96 = 0u;
      long long v95 = 0u;
      long long v94 = 0u;
      long long v93 = 0u;
      long long v92 = 0u;
      long long v91 = 0u;
      long long v90 = 0u;
      long long v89 = 0u;
      long long v88 = 0u;
      long long v87 = 0u;
      long long v86 = 0u;
      long long __sa = 0u;
      if (*((void *)a1 + 9)
        && (uint64_t v25 = (uint64_t (*)(long long *, int *, unsigned int *))*((void *)a1 + 13)) != 0)
      {
        if (*a9 == a1[5])
        {
          if ((v25(&__sa, a4, a9) & 0x80000000) != 0)
          {
            int v21 = -3;
          }
          else
          {
            int v26 = *a4;
            if (*a4 == a1[5])
            {
              if (__sa == a1[6])
              {
                memset(v116, 0, sizeof(v116));
                long long v115 = 0u;
                long long v114 = 0u;
                long long v113 = 0u;
                long long v112 = 0u;
                long long v111 = 0u;
                long long v110 = 0u;
                long long v109 = 0u;
                long long v108 = 0u;
                long long v107 = 0u;
                long long v106 = 0u;
                long long v105 = 0u;
                long long v104 = 0u;
                long long v103 = 0u;
                *(_OWORD *)&v102[8] = 0u;
                if (__sa == *a1)
                {
                  if (*(_DWORD *)__s == a1[2])
                  {
                    if (*a9 == v26)
                    {
                      if (*a8 == a1[8])
                      {
                        *(_DWORD *)&v102[7] = 1263354207;
                        *(void *)long long v102 = 0x5F41454100000007;
                        memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
                        uint64_t v27 = *(unsigned int *)v102;
                        if (*(_DWORD *)v102 >= 0xFDu) {
                          goto LABEL_124;
                        }
                        *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
                        *(_DWORD *)long long v102 = v27 + 4;
                        memset_s(&v102[v27 + 8], 252 - v27, 0, 252 - v27);
                        size_t v28 = *a4;
                        unint64_t v29 = *(unsigned int *)v102 + v28;
                        if (v29 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], a4 + 1, v28);
                        *(_DWORD *)long long v102 = v29;
                        memset_s(&v102[v29 + 4], 256 - v29, 0, 256 - v29);
                        size_t v30 = *a9;
                        unint64_t v31 = *(unsigned int *)v102 + v30;
                        if (v31 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], a9 + 1, v30);
                        *(_DWORD *)long long v102 = v31;
                        memset_s(&v102[v31 + 4], 256 - v31, 0, 256 - v31);
                        size_t v32 = *a8;
                        unint64_t v33 = *(unsigned int *)v102 + v32;
                        if (v33 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v32);
                        *(_DWORD *)long long v102 = v33;
                        memset_s(&v102[v33 + 4], 256 - v33, 0, 256 - v33);
                        uint64_t v34 = (uint64_t (*)(long long *, void, long long *, unsigned char *, char *))*((void *)a1 + 9);
                        int v35 = -1;
                        if (v34)
                        {
                          size_t v36 = a3;
                          if (__sa) {
                            int v35 = v34(a3, *a1, &__sa, v102, __s);
                          }
                        }
                        else
                        {
                          size_t v36 = a3;
                        }
                        if (*(_DWORD *)v36 == *a1) {
                          int v21 = v35;
                        }
                        else {
                          int v21 = -1006;
                        }
                        memset_s(v102, 0x104uLL, 0, 0x104uLL);
                        if (v21) {
                          memset_s(v36, 0x104uLL, 0, 0x104uLL);
                        }
                      }
                      else
                      {
                        int v21 = -1005;
                      }
                    }
                    else
                    {
                      int v21 = -1004;
                    }
                  }
                  else
                  {
                    int v21 = -1002;
                  }
                }
                else
                {
                  int v21 = -1001;
                }
              }
              else
              {
                int v21 = -5;
              }
            }
            else
            {
              int v21 = -4;
            }
          }
        }
        else
        {
          int v21 = -2;
        }
      }
      else
      {
        int v21 = -1;
      }
      p_sa = &__sa;
      goto LABEL_114;
    case 5:
      int v101 = 0;
      long long v100 = 0u;
      long long v99 = 0u;
      long long v98 = 0u;
      long long v97 = 0u;
      long long v96 = 0u;
      long long v95 = 0u;
      long long v94 = 0u;
      long long v93 = 0u;
      long long v92 = 0u;
      long long v91 = 0u;
      long long v90 = 0u;
      long long v89 = 0u;
      long long v88 = 0u;
      long long v87 = 0u;
      long long v86 = 0u;
      long long __sa = 0u;
      int v84 = 0;
      memset(v83, 0, sizeof(v83));
      int v82 = 0;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      *(_OWORD *)char __n = 0u;
      long long v67 = 0u;
      int v65 = 0;
      memset(v64, 0, sizeof(v64));
      int v63 = 0;
      memset(v62, 0, sizeof(v62));
      if (*((void *)a1 + 10) && *((void *)a1 + 9))
      {
        if (*a7 >= 0x14u)
        {
          if (v18 == a1[2])
          {
            WORD6(v83[0]) = 21584;
            *(void *)((char *)v83 + 4) = *(void *)"AEA_SCRYPT";
            LODWORD(v83[0]) = 10;
            memset_s((void *)((unint64_t)v83 | 0xE), 0xF6uLL, 0, 0xF6uLL);
            if (((*((uint64_t (**)(long long *, void, char *, _OWORD *, size_t *))a1 + 9))(&__sa, 2 * a1[2], __s, v83, __n) & 0x80000000) != 0)
            {
              int v21 = -4;
            }
            else
            {
              uint64_t v47 = a1[2];
              if (v47 >= 0x101) {
                goto LABEL_124;
              }
              __memcpy_chk();
              LODWORD(v64[0]) = v47;
              memset_s((char *)v64 + v47 + 4, 256 - v47, 0, 256 - v47);
              uint64_t v48 = a1[2];
              if (v48 >= 0x101) {
                goto LABEL_124;
              }
              __memcpy_chk();
              LODWORD(v62[0]) = v48;
              memset_s((char *)v62 + v48 + 4, 256 - v48, 0, 256 - v48);
              memset_s(&__sa, 0x104uLL, 0, 0x104uLL);
              if (((*((uint64_t (**)(long long *, _DWORD *, void, void, _OWORD *))a1 + 10))(&__sa, a7 + 1, *a7, a1[14], v64) & 0x80000000) != 0)
              {
                int v21 = -5;
              }
              else
              {
                memset(v116, 0, sizeof(v116));
                long long v115 = 0u;
                long long v114 = 0u;
                long long v113 = 0u;
                long long v112 = 0u;
                long long v111 = 0u;
                long long v110 = 0u;
                long long v109 = 0u;
                long long v108 = 0u;
                long long v107 = 0u;
                long long v106 = 0u;
                long long v105 = 0u;
                long long v104 = 0u;
                long long v103 = 0u;
                *(_OWORD *)&v102[8] = 0u;
                if (__sa == *a1)
                {
                  if (LODWORD(v62[0]) == a1[2])
                  {
                    if (LODWORD(__n[0]) == a1[5])
                    {
                      if (*a8 == a1[8])
                      {
                        *(_DWORD *)&v102[7] = 1263354207;
                        *(void *)long long v102 = 0x5F41454100000007;
                        memset_s(&v102[11], 0xF9uLL, 0, 0xF9uLL);
                        uint64_t v49 = *(unsigned int *)v102;
                        if (*(_DWORD *)v102 >= 0xFDu) {
                          goto LABEL_124;
                        }
                        *(_DWORD *)&v102[*(unsigned int *)v102 + 4] = v20;
                        *(_DWORD *)long long v102 = v49 + 4;
                        memset_s(&v102[v49 + 8], 252 - v49, 0, 252 - v49);
                        unint64_t v50 = *(unsigned int *)v102 + (unint64_t)LODWORD(__n[0]);
                        if (v50 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], (char *)__n + 4, LODWORD(__n[0]));
                        *(_DWORD *)long long v102 = v50;
                        memset_s(&v102[v50 + 4], 256 - v50, 0, 256 - v50);
                        unint64_t v51 = *(unsigned int *)v102 + (unint64_t)LODWORD(__n[0]);
                        if (v51 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], (char *)__n + 4, LODWORD(__n[0]));
                        *(_DWORD *)long long v102 = v51;
                        memset_s(&v102[v51 + 4], 256 - v51, 0, 256 - v51);
                        size_t v52 = *a8;
                        unint64_t v53 = *(unsigned int *)v102 + v52;
                        if (v53 >= 0x101) {
                          goto LABEL_124;
                        }
                        memcpy(&v102[*(unsigned int *)v102 + 4], a8 + 1, v52);
                        *(_DWORD *)long long v102 = v53;
                        memset_s(&v102[v53 + 4], 256 - v53, 0, 256 - v53);
                        unint64_t v54 = (uint64_t (*)(long long *, void, long long *, unsigned char *, _OWORD *))*((void *)a1 + 9);
                        int v55 = -1;
                        if (v54)
                        {
                          unint64_t v56 = a3;
                          if (__sa) {
                            int v55 = v54(a3, *a1, &__sa, v102, v62);
                          }
                        }
                        else
                        {
                          unint64_t v56 = a3;
                        }
                        if (*(_DWORD *)v56 == *a1) {
                          int v21 = v55;
                        }
                        else {
                          int v21 = -1006;
                        }
                        memset_s(v102, 0x104uLL, 0, 0x104uLL);
                        if (v21) {
                          memset_s(a3, 0x104uLL, 0, 0x104uLL);
                        }
                      }
                      else
                      {
                        int v21 = -1005;
                      }
                    }
                    else
                    {
                      int v21 = -1003;
                    }
                  }
                  else
                  {
                    int v21 = -1002;
                  }
                }
                else
                {
                  int v21 = -1001;
                }
              }
            }
          }
          else
          {
            int v21 = -3;
          }
        }
        else
        {
          int v21 = -2;
        }
      }
      else
      {
        int v21 = -1;
      }
      memset_s(&__sa, 0x104uLL, 0, 0x104uLL);
      memset_s(v83, 0x104uLL, 0, 0x104uLL);
      memset_s(v64, 0x104uLL, 0, 0x104uLL);
      p_sa = v62;
LABEL_114:
      memset_s(p_sa, 0x104uLL, 0, 0x104uLL);
      goto LABEL_115;
    default:
      uint64_t v22 = "Unsupported profile";
      __int16 v23 = 435;
      goto LABEL_12;
  }
}

int AEAStreamSign(AAByteStream encrypted_stream, AEAContext context)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  int v62 = 0;
  memset(__s, 0, sizeof(__s));
  int v60 = 0;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  *(_OWORD *)uint64_t v44 = 0u;
  long long v45 = 0u;
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  if (*(_DWORD *)context <= 5u && ((1 << *(_DWORD *)context) & 0x2A) != 0)
  {
    int v4 = 0;
    long long v40 = 0uLL;
    long long v41 = 0uLL;
    long long v38 = 0uLL;
    long long v39 = 0uLL;
    long long v36 = 0uLL;
    long long v37 = 0uLL;
    long long v34 = 0uLL;
    long long v35 = 0uLL;
    long long v32 = 0uLL;
    long long v33 = 0uLL;
    long long v30 = 0uLL;
    long long v31 = 0uLL;
    long long v29 = 0uLL;
    unint64_t v28 = 0;
    long long v26 = 0uLL;
    long long v27 = 0uLL;
    long long v24 = 0uLL;
    long long v25 = 0uLL;
    long long v22 = 0uLL;
    long long v23 = 0uLL;
LABEL_15:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v44, 0x104uLL, 0, 0x104uLL);
    memset_s(v42, 0x104uLL, 0, 0x104uLL);
    memset_s(&v22, 0x68uLL, 0, 0x68uLL);
    memset_s(&v29, 0xD0uLL, 0, 0xD0uLL);
    return v4;
  }
  uint64_t v5 = (char *)*((void *)context + 340);
  size_t v6 = *((void *)context + 341);
  long long v40 = 0uLL;
  long long v41 = 0uLL;
  long long v38 = 0uLL;
  long long v39 = 0uLL;
  long long v36 = 0uLL;
  long long v37 = 0uLL;
  long long v34 = 0uLL;
  long long v35 = 0uLL;
  long long v32 = 0uLL;
  long long v33 = 0uLL;
  long long v30 = 0uLL;
  long long v31 = 0uLL;
  long long v29 = 0uLL;
  unint64_t v28 = 0;
  long long v26 = 0uLL;
  long long v27 = 0uLL;
  long long v24 = 0uLL;
  long long v25 = 0uLL;
  long long v22 = 0uLL;
  long long v23 = 0uLL;
  if ((aeaCryptoInit((char *)&v29, (unsigned int *)context) & 0x80000000) != 0)
  {
    uint64_t v14 = "initializing crypto params";
    __int16 v15 = 467;
    goto LABEL_14;
  }
  uint64_t v9 = *((unsigned int *)context + 5);
  long long v22 = xmmword_214B12920;
  *(void *)&long long v23 = *((unsigned int *)context + 1) + 12;
  *((void *)&v23 + 1) = v23 + HIDWORD(v31);
  *(void *)&long long v24 = *((void *)&v23 + 1) + v32;
  *((void *)&v24 + 1) = v24 + DWORD2(v29);
  *(void *)&long long v25 = *((void *)&v24 + 1) + HIDWORD(v29);
  *((void *)&v25 + 1) = v25 + 48;
  long long v26 = (void)v25 + 48 + (unint64_t)HIDWORD(v29);
  uint64_t v10 = (*((unsigned int *)context + 12) + 8) * v9 + HIDWORD(v29);
  *(void *)&long long v27 = (*((unsigned int *)context + 12) + 8) * v9;
  *((void *)&v27 + 1) = v10;
  unint64_t v28 = v10 + HIDWORD(v29) * (unint64_t)v9;
  memset_s(&v5[v23], HIDWORD(v31), 0, HIDWORD(v31));
  if (!*((void *)&v36 + 1)
    || (int v11 = (*((uint64_t (**)(_OWORD *, char *, size_t))&v36 + 1))(v42, v5, v6),
        LODWORD(v42[0]) != DWORD1(v31))
    || v11 < 0)
  {
    uint64_t v14 = "digesting prologue";
    __int16 v15 = 474;
    goto LABEL_14;
  }
  unint64_t v12 = (uint64_t (*)(void, uint64_t, char *, _OWORD *, char *))*((void *)context + 302);
  if (v12)
  {
    *(void *)&v84[0] = 0;
    int result = v12(*((void *)context + 303), 256, (char *)__s + 4, v84, (char *)v42 + 4);
    if (result < 0)
    {
      uint64_t v14 = "signing prologue digest";
      __int16 v15 = 484;
      goto LABEL_14;
    }
    if (*(void *)&v84[0] > (unint64_t)DWORD2(v31))
    {
      uint64_t v14 = "invalid signature size";
      __int16 v15 = 485;
LABEL_14:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACommon.c", (uint64_t)"AEAStreamSign", v15, 79, 0, v14, v7, v8, v22);
      int v4 = -1;
      goto LABEL_15;
    }
    if (DWORD2(v31) >= 0x101) {
      goto LABEL_46;
    }
    LODWORD(__s[0]) = DWORD2(v31);
    int result = memset_s((char *)__s + DWORD2(v31) + 4, 256 - DWORD2(v31), 0, 256 - DWORD2(v31));
  }
  else if (!(void)v37 {
         || (int result = ((uint64_t (*)(_OWORD *, char *, _OWORD *))v37)(__s, (char *)context + 592, v42),
  }
             LODWORD(__s[0]) != DWORD2(v31))
         || result < 0)
  {
    uint64_t v14 = "signing prologue";
    __int16 v15 = 490;
    goto LABEL_14;
  }
  if (*(_DWORD *)context)
  {
    if (!(void)v38) {
      goto LABEL_36;
    }
    int v83 = 0;
    memset(v82, 0, sizeof(v82));
    int v81 = 0;
    memset(v80, 0, sizeof(v80));
    int v79 = 0;
    long long v78 = 0u;
    long long v77 = 0u;
    long long v76 = 0u;
    long long v75 = 0u;
    long long v74 = 0u;
    long long v73 = 0u;
    long long v72 = 0u;
    long long v71 = 0u;
    long long v70 = 0u;
    long long v69 = 0u;
    long long v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    long long v65 = 0u;
    long long v64 = 0u;
    *(_OWORD *)char __n = 0u;
    if (LODWORD(__s[0]) != DWORD2(v31)) {
      goto LABEL_35;
    }
    if (*((_DWORD *)context + 408) != v29) {
      goto LABEL_35;
    }
    *(void *)((char *)v80 + 4) = 0x324B45535F414541;
    LODWORD(v80[0]) = 8;
    memset_s((void *)((unint64_t)v80 | 0xC), 0xF8uLL, 0, 0xF8uLL);
    int v85 = 0;
    memset(v84, 0, sizeof(v84));
    if (!*((void *)&v33 + 1)) {
      goto LABEL_35;
    }
    if (!*((_DWORD *)context + 408)) {
      goto LABEL_35;
    }
    int result = (*((uint64_t (**)(_OWORD *, void, char *, _OWORD *, _OWORD *))&v33 + 1))(v82, DWORD1(v29), (char *)context + 1632, v80, v84);
    if (result < 0) {
      goto LABEL_35;
    }
    uint64_t v16 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) >= 0x101) {
      goto LABEL_46;
    }
    __memcpy_chk();
    LODWORD(v44[0]) = v16;
    memset_s((char *)v44 + v16 + 4, 256 - v16, 0, 256 - v16);
    int result = ((uint64_t (*)(char *, void, size_t *, _OWORD *, void, void))v38)((char *)v44 + 4, LODWORD(__s[0]), __n, v82, 0, 0);
    if (result < 0)
    {
LABEL_35:
      memset_s(v82, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v80, 0x104uLL, 0, 0x104uLL);
      goto LABEL_36;
    }
    unint64_t v17 = LODWORD(v44[0]) + (unint64_t)LODWORD(__n[0]);
    if (v17 < 0x101)
    {
      memcpy((char *)v44 + LODWORD(v44[0]) + 4, (char *)__n + 4, LODWORD(__n[0]));
      LODWORD(v44[0]) = v17;
      memset_s((char *)v44 + v17 + 4, 256 - v17, 0, 256 - v17);
      int v18 = v44[0];
      int v19 = HIDWORD(v31);
      memset_s(v82, 0x104uLL, 0, 0x104uLL);
      memset_s(__n, 0x104uLL, 0, 0x104uLL);
      memset_s(v80, 0x104uLL, 0, 0x104uLL);
      if (v18 == v19)
      {
LABEL_39:
        memcpy(&v5[v23], (char *)v44 + 4, LODWORD(v44[0]));
        if (AAByteStreamPWrite(encrypted_stream, v5, v6, 0) == v6)
        {
          if (*((void *)&v41 + 1))
          {
            int v21 = (*((uint64_t (**)(char *, char *, size_t))&v41 + 1))((char *)context + 1892, v5, v6);
            if (*((_DWORD *)context + 473) == DWORD1(v32) && (v21 & 0x80000000) == 0)
            {
              int v4 = 0;
              goto LABEL_15;
            }
          }
          uint64_t v14 = "digesting prologue";
          __int16 v15 = 505;
        }
        else
        {
          uint64_t v14 = "writing updated prologue";
          __int16 v15 = 502;
        }
        goto LABEL_14;
      }
LABEL_36:
      uint64_t v14 = "encrypt signature";
      __int16 v15 = 497;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v20 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) < 0x101)
    {
      __memcpy_chk();
      LODWORD(v44[0]) = v20;
      memset_s((char *)v44 + v20 + 4, 256 - v20, 0, 256 - v20);
      goto LABEL_39;
    }
  }
LABEL_46:
  __break(1u);
  return result;
}

size_t PCompressLZFSEEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t *AAVerifyDirectoryArchiveOutputStreamOpen(const char *a1, AAFieldKeySet_impl *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  int DefaultNThreads = a6;
  if (!a6) {
    int DefaultNThreads = getDefaultNThreads();
  }
  unint64_t v12 = (uint64_t *)malloc(0x38uLL);
  int v13 = v12;
  if (v12) {
    memset_s(v12, 0x38uLL, 0, 0x38uLL);
  }
  memset(&v73, 0, sizeof(v73));
  uint64_t v14 = malloc(0x4B8uLL);
  uint64_t v15 = (uint64_t)v14;
  if (v14 && (memset_s(v14, 0x4B8uLL, 0, 0x4B8uLL), v13))
  {
    if (realpath_DARWIN_EXTSN(a1, (char *)v15))
    {
      if (stat((const char *)v15, &v73) || (v73.st_mode & 0xF000) != 0x4000)
      {
        char v72 = (char)a1;
        uint64_t v44 = "Invalid directory: %s";
        __int16 v45 = 450;
        goto LABEL_64;
      }
      *(void *)(v15 + 1024) = a5;
      *(void *)(v15 + 1032) = a3;
      *(void *)(v15 + 1040) = a4;
      *(_DWORD *)(v15 + 1064) = DefaultNThreads;
      *(_DWORD *)(v15 + 1048) = a5 >> 62;
      *(void *)(v15 + 1088) = 0xFFFFFFFFLL;
      if (a2)
      {
        v18.uint64_t ikey = 4475221;
        if (AAFieldKeySetContainsKey(a2, v18)) {
          *(_DWORD *)(v15 + 1088) &= ~1u;
        }
        v19.uint64_t ikey = 4475207;
        if (AAFieldKeySetContainsKey(a2, v19)) {
          *(_DWORD *)(v15 + 1088) &= ~2u;
        }
        v20.uint64_t ikey = 4672582;
        if (AAFieldKeySetContainsKey(a2, v20)) {
          *(_DWORD *)(v15 + 1088) &= ~4u;
        }
        v21.uint64_t ikey = 4476749;
        if (AAFieldKeySetContainsKey(a2, v21)) {
          *(_DWORD *)(v15 + 1088) &= ~8u;
        }
        v22.uint64_t ikey = 5067842;
        if (AAFieldKeySetContainsKey(a2, v22)) {
          *(_DWORD *)(v15 + 1088) &= ~0x10u;
        }
        v23.uint64_t ikey = 5067843;
        if (AAFieldKeySetContainsKey(a2, v23)) {
          *(_DWORD *)(v15 + 1088) &= ~0x20u;
        }
        v24.uint64_t ikey = 5067853;
        if (AAFieldKeySetContainsKey(a2, v24)) {
          *(_DWORD *)(v15 + 1088) &= ~0x40u;
        }
        v25.uint64_t ikey = 5523009;
        if (AAFieldKeySetContainsKey(a2, v25)) {
          *(_DWORD *)(v15 + 1088) &= ~0x80u;
        }
        v26.uint64_t ikey = 5391937;
        if (AAFieldKeySetContainsKey(a2, v26)) {
          *(_DWORD *)(v15 + 1088) &= ~0x100u;
        }
        v27.uint64_t ikey = 4803654;
        if (AAFieldKeySetContainsKey(a2, v27)) {
          *(_DWORD *)(v15 + 1088) &= ~0x200u;
        }
        v28.uint64_t ikey = 4411984;
        if (AAFieldKeySetContainsKey(a2, v28)) {
          *(_DWORD *)(v15 + 1088) &= ~0x400u;
        }
        v29.uint64_t ikey = 5458755;
        if (AAFieldKeySetContainsKey(a2, v29)) {
          *(_DWORD *)(v15 + 1088) &= ~0x800u;
        }
        v30.uint64_t ikey = 3229779;
        if (AAFieldKeySetContainsKey(a2, v30)) {
          *(_DWORD *)(v15 + 1088) &= ~0x1000u;
        }
        v31.uint64_t ikey = 3295315;
        if (AAFieldKeySetContainsKey(a2, v31)) {
          *(_DWORD *)(v15 + 1088) &= ~0x2000u;
        }
        v32.uint64_t ikey = 3360851;
        if (AAFieldKeySetContainsKey(a2, v32)) {
          *(_DWORD *)(v15 + 1088) &= ~0x4000u;
        }
        v33.uint64_t ikey = 3491923;
        if (AAFieldKeySetContainsKey(a2, v33)) {
          *(_DWORD *)(v15 + 1088) &= ~0x8000u;
        }
        v34.uint64_t ikey = 5521732;
        if (AAFieldKeySetContainsKey(a2, v34)) {
          *(_DWORD *)(v15 + 1088) &= ~0x80000u;
        }
        v35.uint64_t ikey = 4408665;
        if (AAFieldKeySetContainsKey(a2, v35)) {
          *(_DWORD *)(v15 + 1088) &= ~0x10000u;
        }
        v36.uint64_t ikey = 5521752;
        if (AAFieldKeySetContainsKey(a2, v36)) {
          *(_DWORD *)(v15 + 1088) &= ~0x20000u;
        }
        v37.uint64_t ikey = 4997953;
        if (AAFieldKeySetContainsKey(a2, v37)) {
          *(_DWORD *)(v15 + 1088) &= ~0x40000u;
        }
      }
      if ((a5 & 0x80000000000000) == 0)
      {
        if (a5 >> 62) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "Scanning target directory: %s\n", a1);
        }
        long long v38 = AAPathListCreateWithDirectoryContents(a1, 0, *(void **)(v15 + 1032), *(AAEntryMessageProc *)(v15 + 1040), 0, DefaultNThreads);
        *(void *)(v15 + 1056) = v38;
        if (!v38)
        {
          char v72 = (char)a1;
          uint64_t v44 = "Scanning target directory failed: %s";
          __int16 v45 = 488;
          goto LABEL_64;
        }
        uint64_t v39 = AAPathListNodeFirst(v38);
        if (v39 == -1)
        {
          *(void *)(v15 + 1120) = 64;
          size_t v42 = 8;
        }
        else
        {
          uint64_t v40 = v39;
          uint64_t v41 = 0;
          do
          {
            ++*(void *)(v15 + 1152);
            if (v40 > v41) {
              uint64_t v41 = v40;
            }
            uint64_t v40 = AAPathListNodeNext(*(AAPathList *)(v15 + 1056), v40);
          }
          while (v40 != -1);
          *(void *)(v15 + 1120) = (v41 + 64) & 0xFFFFFFFFFFFFFFC0;
          size_t v42 = ((v41 + 64) >> 3) & 0x1FFFFFFFFFFFFFF8;
          if (v42 >= 0x2000000001)
          {
            *__error() = 12;
LABEL_87:
            *(void *)(v15 + 1128) = 0;
            int v43 = *__error();
            uint64_t v44 = "malloc";
            __int16 v45 = 499;
            goto LABEL_65;
          }
        }
        long long v54 = malloc(v42);
        if (!v54) {
          goto LABEL_87;
        }
        long long v55 = v54;
        memset_s(v54, v42, 0, v42);
        *(void *)(v15 + 1128) = v55;
      }
      long long v56 = calloc(*(unsigned int *)(v15 + 1064), 8uLL);
      *(void *)(v15 + 1072) = v56;
      if (v56)
      {
        if (*(_DWORD *)(v15 + 1064))
        {
          unint64_t v57 = 0;
          while (1)
          {
            long long v58 = (uint64_t *)malloc(0x5A8uLL);
            long long v59 = v58;
            if (!v58)
            {
              char v61 = __error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerDataAlloc", 80, 119, *v61, "malloc", v62, v63, v72);
              goto LABEL_83;
            }
            memset_s(v58, 0x5A8uLL, 0, 0x5A8uLL);
            *long long v59 = v15;
            unint64_t v60 = *(void *)(v15 + 1120);
            if (!v60) {
              goto LABEL_83;
            }
            if (v60 < 0x10000000008)
            {
              rsize_t v64 = v60 >> 3;
              long long v65 = malloc(v60 >> 3);
              if (v65)
              {
                uint64_t v66 = (uint64_t)v65;
                memset_s(v65, v64, 0, v64);
                v59[180] = v66;
                goto LABEL_83;
              }
            }
            else
            {
              *__error() = 12;
            }
            v59[180] = 0;
            long long v67 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerDataAlloc", 85, 119, *v67, "malloc", v68, v69, v72);
            workerDataFree((void **)v59);
            long long v59 = 0;
LABEL_83:
            *(void *)(*(void *)(v15 + 1072) + 8 * v57) = v59;
            uint64_t v70 = *(void *)(v15 + 1072);
            if (!*(void *)(v70 + 8 * v57))
            {
              uint64_t v44 = "allocation";
              __int16 v45 = 508;
              goto LABEL_64;
            }
            ++v57;
            long long v56 = (void *)*(unsigned int *)(v15 + 1064);
            if (v57 >= (unint64_t)v56) {
              goto LABEL_89;
            }
          }
        }
        uint64_t v70 = (uint64_t)v56;
        LODWORD(v56) = 0;
LABEL_89:
        long long v71 = ThreadPoolCreate(v56, v70, (uint64_t)workerProc_0);
        *(void *)(v15 + 1080) = v71;
        if (v71)
        {
          v13[3] = (uint64_t)verifyDirectoryStreamWriteHeader;
          v13[4] = (uint64_t)verifyDirectoryStreamWriteBlob;
          v13[2] = (uint64_t)verifyDirectoryStreamCancel;
          *int v13 = v15;
          v13[1] = (uint64_t)verifyDirectoryStreamClose;
          return v13;
        }
        uint64_t v44 = "ThreadPoolCreate";
        __int16 v45 = 511;
LABEL_64:
        int v43 = 0;
      }
      else
      {
        int v43 = *__error();
        uint64_t v44 = "malloc";
        __int16 v45 = 504;
      }
    }
    else
    {
      int v43 = *__error();
      char v72 = (char)a1;
      uint64_t v44 = "%s";
      __int16 v45 = 449;
    }
  }
  else
  {
    int v43 = *__error();
    uint64_t v44 = "malloc";
    __int16 v45 = 448;
  }
LABEL_65:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"AAVerifyDirectoryArchiveOutputStreamOpen", v45, 119, v43, v44, v16, v17, v72);
  free(v13);
  verifyDirectoryStreamClose(v15, v46, v47, v48, v49, v50, v51, v52);
  return 0;
}

uint64_t workerProc_0(uint64_t a1)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v3 = (char *)(a1 + 12);
  uint64_t v2 = *(void *)a1;
  memset(&v50, 0, sizeof(v50));
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v45 = 0u;
  if ((concatPath(v51, 0x800uLL, (char *)v2, (const char *)(a1 + 12)) & 0x80000000) == 0)
  {
    uint64_t v6 = *(void *)(v2 + 1056);
    if (v6)
    {
      unint64_t Node = AAPathListGetNode(v6, v3);
      if (Node != -1)
      {
        if (Node >= *(void *)(v2 + 1120))
        {
          AAFieldKey v21 = "invalid node index";
          __int16 v22 = 166;
LABEL_22:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerProc", v22, 119, 0, v21, v8, v9, v43);
          goto LABEL_23;
        }
        *(void *)(*(void *)(a1 + 1440) + ((Node >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << Node;
LABEL_8:
        uint64_t v10 = *(void *)(a1 + 1392);
        if (v10)
        {
          LOBYTE(v45) = v45 | 1;
          *((void *)&v45 + 1) = *(void *)(a1 + 1408);
          *(void *)&long long v46 = v10;
        }
        uint64_t v11 = *(void *)(a1 + 1344);
        if (v11)
        {
          LOBYTE(v45) = v45 | 2;
          *((void *)&v46 + 1) = *(void *)(a1 + 1360);
          *(void *)&long long v47 = v11;
        }
        uint64_t v12 = *(void *)(a1 + 1368);
        if (v12)
        {
          LOBYTE(v45) = v45 | 4;
          *((void *)&v47 + 1) = *(void *)(a1 + 1384);
          uint64_t v48 = v12;
        }
        if ((aaCheckAndFixWithPath((char *)(a1 + 1040), (unsigned __int8 *)(a1 + 1112), (unsigned __int8 *)(a1 + 1168), (unsigned __int8 *)&v45, *(void *)(v2 + 1088), (unsigned int *)&v49, (char *)v2, v3, *(void *)(v2 + 1024)) & 0x80000000) == 0)
        {
          if (v49)
          {
            int v13 = AAFieldKeySetCreate();
            uint64_t v16 = v13;
            if (!v13)
            {
              AAFieldKey v24 = "AAFieldKeySetCreate";
              __int16 v25 = 200;
LABEL_92:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerProc", v25, 119, 0, v24, v14, v15, v44);
              goto LABEL_24;
            }
            int v17 = v49;
            if (v49)
            {
              v26.uint64_t ikey = 4475221;
              BOOL v18 = AAFieldKeySetInsertKey(v13, v26) >= 0;
              int v17 = v49;
            }
            else
            {
              BOOL v18 = 1;
            }
            if ((v17 & 2) != 0)
            {
              v27.uint64_t ikey = 4475207;
              if (AAFieldKeySetInsertKey(v16, v27) < 0) {
                BOOL v18 = 0;
              }
              int v17 = v49;
            }
            if ((v17 & 8) != 0)
            {
              v28.uint64_t ikey = 4476749;
              if (AAFieldKeySetInsertKey(v16, v28) < 0) {
                BOOL v18 = 0;
              }
              int v17 = v49;
            }
            if ((v17 & 4) != 0)
            {
              v29.uint64_t ikey = 4672582;
              if (AAFieldKeySetInsertKey(v16, v29) < 0) {
                BOOL v18 = 0;
              }
              int v17 = v49;
            }
            if ((v17 & 0x40) != 0)
            {
              v32.uint64_t ikey = 5067853;
              if (AAFieldKeySetInsertKey(v16, v32) < 0) {
                BOOL v18 = 0;
              }
              int v17 = v49;
              if ((v49 & 0x10) == 0)
              {
LABEL_44:
                if ((v17 & 0x20) == 0) {
                  goto LABEL_48;
                }
                goto LABEL_45;
              }
            }
            else if ((v17 & 0x10) == 0)
            {
              goto LABEL_44;
            }
            v33.uint64_t ikey = 5067842;
            if (AAFieldKeySetInsertKey(v16, v33) < 0) {
              BOOL v18 = 0;
            }
            int v17 = v49;
            if ((v49 & 0x20) == 0)
            {
LABEL_48:
              if ((v17 & 0x80) != 0)
              {
                v34.uint64_t ikey = 5523009;
                if (AAFieldKeySetInsertKey(v16, v34) < 0) {
                  BOOL v18 = 0;
                }
                int v17 = v49;
                if ((v49 & 0x100) == 0)
                {
LABEL_50:
                  if ((v17 & 0x200) == 0) {
                    goto LABEL_54;
                  }
                  goto LABEL_51;
                }
              }
              else if ((v17 & 0x100) == 0)
              {
                goto LABEL_50;
              }
              v35.uint64_t ikey = 5391937;
              if (AAFieldKeySetInsertKey(v16, v35) < 0) {
                BOOL v18 = 0;
              }
              int v17 = v49;
              if ((v49 & 0x200) == 0)
              {
LABEL_54:
                if ((v17 & 0x400) != 0)
                {
                  v36.uint64_t ikey = 4411984;
                  if (AAFieldKeySetInsertKey(v16, v36) < 0) {
                    BOOL v18 = 0;
                  }
                  int v17 = v49;
                  if ((v49 & 0x80000) == 0)
                  {
LABEL_56:
                    if ((v17 & 0x10000) == 0) {
                      goto LABEL_57;
                    }
                    goto LABEL_80;
                  }
                }
                else if ((v17 & 0x80000) == 0)
                {
                  goto LABEL_56;
                }
                v37.uint64_t ikey = 5521732;
                if (AAFieldKeySetInsertKey(v16, v37) < 0) {
                  BOOL v18 = 0;
                }
                int v17 = v49;
                if ((v49 & 0x10000) == 0)
                {
LABEL_57:
                  if ((v17 & 0x20000) == 0) {
                    goto LABEL_58;
                  }
                  goto LABEL_83;
                }
LABEL_80:
                v38.uint64_t ikey = 4408665;
                if (AAFieldKeySetInsertKey(v16, v38) < 0) {
                  BOOL v18 = 0;
                }
                int v17 = v49;
                if ((v49 & 0x20000) == 0)
                {
LABEL_58:
                  if ((v17 & 0x40000) == 0) {
                    goto LABEL_87;
                  }
LABEL_86:
                  v40.uint64_t ikey = 4997953;
                  if (AAFieldKeySetInsertKey(v16, v40) < 0)
                  {
LABEL_91:
                    AAFieldKey v24 = "AAFieldKeySetInsertKey";
                    __int16 v25 = 216;
                    goto LABEL_92;
                  }
LABEL_87:
                  if (v18)
                  {
                    if ((sendMessage(v2, 74, (uint64_t)v3, v16) & 0x80000000) != 0) {
                      goto LABEL_89;
                    }
LABEL_27:
                    uint64_t v23 = 0;
                    goto LABEL_90;
                  }
                  goto LABEL_91;
                }
LABEL_83:
                v39.uint64_t ikey = 5521752;
                if (AAFieldKeySetInsertKey(v16, v39) < 0) {
                  BOOL v18 = 0;
                }
                if ((v49 & 0x40000) == 0) {
                  goto LABEL_87;
                }
                goto LABEL_86;
              }
LABEL_51:
              v31.uint64_t ikey = 4803654;
              if (AAFieldKeySetInsertKey(v16, v31) < 0) {
                BOOL v18 = 0;
              }
              int v17 = v49;
              goto LABEL_54;
            }
LABEL_45:
            v30.uint64_t ikey = 5067843;
            if (AAFieldKeySetInsertKey(v16, v30) < 0) {
              BOOL v18 = 0;
            }
            int v17 = v49;
            goto LABEL_48;
          }
          uint64_t v19 = v2;
          uint64_t v20 = 73;
LABEL_26:
          uint64_t v16 = 0;
          if ((sendMessage(v19, v20, (uint64_t)v3, 0) & 0x80000000) != 0)
          {
LABEL_89:
            int v41 = 0;
            atomic_compare_exchange_strong((atomic_uint *volatile)(v2 + 1136), (unsigned int *)&v41, 1u);
            uint64_t v23 = 0xFFFFFFFFLL;
            goto LABEL_90;
          }
          goto LABEL_27;
        }
        char v43 = (char)v3;
        AAFieldKey v21 = "CheckAndFix: %s";
        __int16 v22 = 190;
        goto LABEL_22;
      }
    }
    else if ((lstat(v51, &v50) & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    uint64_t v19 = v2;
    uint64_t v20 = 71;
    goto LABEL_26;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"workerProc", 153, 119, 0, "invalid path: %s", v4, v5, (char)v3);
LABEL_23:
  uint64_t v16 = 0;
LABEL_24:
  uint64_t v23 = 0;
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 1160), 1uLL, memory_order_relaxed);
LABEL_90:
  AAFieldKeySetDestroy(v16);
  return v23;
}

uint64_t verifyDirectoryStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void *)(result + 1096);
    if (v9)
    {
      uint64_t v10 = *(void *)(result + 1080);
      if (v10)
      {
        *(_DWORD *)(v9 + 8) = 0;
        ThreadPoolRunWorker(v10, v9, a3, a4, a5, a6, a7, a8);
        *(void *)(v8 + 1096) = 0;
      }
    }
    ThreadPoolDestroy(*(void *)(v8 + 1080));
    unsigned int v11 = atomic_load((unsigned int *)(v8 + 1136));
    if (v11 || (unint64_t v12 = atomic_load((unint64_t *)(v8 + 1160))) != 0)
    {
LABEL_7:
      int v13 = 0;
      char v14 = 1;
    }
    else
    {
      uint64_t v36 = *(void *)(v8 + 1072);
      if (v36)
      {
        unint64_t v37 = *(void *)(v8 + 1120);
        if (v37)
        {
          uint64_t v38 = *(unsigned int *)(v8 + 1064);
          if (v38)
          {
            for (uint64_t i = 0; i != v38; ++i)
            {
              uint64_t v40 = *(void *)(v36 + 8 * i);
              if (v40)
              {
                unint64_t v41 = 0;
                size_t v42 = *(uint64_t **)(v40 + 1440);
                char v43 = *(void **)(v8 + 1128);
                do
                {
                  uint64_t v44 = *v42++;
                  *v43++ |= v44;
                  v41 += 64;
                }
                while (v41 < v37);
              }
            }
          }
        }
      }
      long long v45 = *(AAPathList_impl **)(v8 + 1056);
      if (v45)
      {
        uint64_t v46 = AAPathListNodeFirst(v45);
        if (v46 != -1)
        {
          for (uint64_t j = v46; j != -1; uint64_t j = AAPathListNodeNext(*(AAPathList *)(v8 + 1056), j))
          {
            if (((*(void *)(*(void *)(v8 + 1128) + ((j >> 3) & 0x1FFFFFFFFFFFFFF8)) >> j) & 1) == 0)
            {
              if (AAPathListNodeGetPath(*(AAPathList *)(v8 + 1056), j, 0x400uLL, path, 0) < 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamClose", 385, 119, 0, "path too long", v48, v49, v50);
                goto LABEL_7;
              }
              if ((sendMessage(v8, 72, (uint64_t)path, 0) & 0x80000000) != 0) {
                goto LABEL_7;
              }
            }
          }
        }
      }
      char v14 = 0;
      int v13 = 1;
    }
    AAPathListDestroy(*(AAPathList *)(v8 + 1056));
    uint64_t v15 = *(void **)(v8 + 1072);
    if (v15)
    {
      if (*(_DWORD *)(v8 + 1064))
      {
        unint64_t v16 = 0;
        do
          workerDataFree(*(void ***)(*(void *)(v8 + 1072) + 8 * v16++));
        while (v16 < *(unsigned int *)(v8 + 1064));
        uint64_t v15 = *(void **)(v8 + 1072);
      }
      free(v15);
    }
    if ((v14 & 1) == 0 && *(_DWORD *)(v8 + 1048))
    {
      int v17 = (FILE **)MEMORY[0x263EF8348];
      BOOL v18 = (FILE *)*MEMORY[0x263EF8348];
      if (*(void *)(v8 + 1144) == *(void *)(v8 + 1152))
      {
        fprintf(v18, "%12llu entries\n");
      }
      else
      {
        fprintf(v18, "%12llu entries in archive\n", *(void *)(v8 + 1144));
        fprintf(*v17, "%12llu entries in directory\n");
      }
      uint64_t v19 = *v17;
      unint64_t v20 = atomic_load((unint64_t *)(v8 + 1176));
      fprintf(v19, "%12llu common, OK\n", v20);
      AAFieldKey v21 = *v17;
      unint64_t v22 = atomic_load((unint64_t *)(v8 + 1184));
      fprintf(v21, "%12llu common, not matching\n", v22);
      uint64_t v23 = *v17;
      unint64_t v24 = atomic_load((unint64_t *)(v8 + 1192));
      fprintf(v23, "%12llu added\n", v24);
      __int16 v25 = *v17;
      unint64_t v26 = atomic_load((unint64_t *)(v8 + 1200));
      fprintf(v25, "%12llu removed\n", v26);
      if (atomic_load((unint64_t *)(v8 + 1168)))
      {
        AAFieldKey v28 = *v17;
        unint64_t v29 = atomic_load((unint64_t *)(v8 + 1168));
        fprintf(v28, "%12llu differences ignored\n", v29);
      }
      if (atomic_load((unint64_t *)(v8 + 1160)))
      {
        AAFieldKey v31 = *v17;
        unint64_t v32 = atomic_load((unint64_t *)(v8 + 1160));
        fprintf(v31, "%12llu errors reported\n", v32);
      }
    }
    unint64_t v33 = atomic_load((unint64_t *)(v8 + 1184));
    if (v33
      || (unint64_t v34 = atomic_load((unint64_t *)(v8 + 1192))) != 0
      || (unint64_t v35 = atomic_load((unint64_t *)(v8 + 1200))) != 0)
    {
      int v13 = 0;
    }
    free(*(void **)(v8 + 1128));
    free((void *)v8);
    if (v13) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t verifyDirectoryStreamWriteHeader(uint64_t a1, AAHeader_impl *a2)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  if (atomic_load((unsigned int *)(a1 + 1136))) {
    return 0xFFFFFFFFLL;
  }
  uint64_t value = 0;
  bzero(v62, 0x400uLL);
  uint64_t size = 0;
  size_t length = 0;
  uint64_t offset = 0;
  if (*(void *)(a1 + 1096) || *(void *)(a1 + 1112))
  {
    uint64_t v7 = "invalid state";
    __int16 v8 = 247;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamWriteHeader", v8, 119, 0, v7, v5, v6, __size);
LABEL_6:
    int v9 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 1136), (unsigned int *)&v9, 1u);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 1104) = 0;
  ++*(void *)(a1 + 1144);
  v11.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(a2, v11);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(a2, KeyIndex, &value), FieldUInt <= 1) ? (int v15 = 1) : (int v15 = FieldUInt),
        v15 <= 0))
  {
    __int16 v16 = 252;
LABEL_16:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamWriteHeader", v16, 119, "invalid archive", v13, v5, v6, __size);
    goto LABEL_6;
  }
  if (value == 77)
  {
LABEL_14:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1104) = 1;
    return result;
  }
  v17.uint64_t ikey = 5521744;
  uint32_t v18 = AAHeaderGetKeyIndex(a2, v17);
  if ((v18 & 0x80000000) != 0
    || ((unsigned int FieldString = AAHeaderGetFieldString(a2, v18, 0x400uLL, v62, &length), FieldString <= 1)
      ? (int v24 = 1)
      : (int v24 = FieldString),
        v24 <= 0))
  {
    __int16 v16 = 254;
    goto LABEL_16;
  }
  __int16 v25 = *(uint64_t (**)(void, uint64_t, char *, AAHeader_impl *))(a1 + 1040);
  if (v25)
  {
    int v26 = v25(*(void *)(a1 + 1032), 70, v62, a2);
    if (v26 < 0)
    {
      uint64_t v7 = "user cancelled";
      __int16 v8 = 260;
      goto LABEL_5;
    }
    if (v26) {
      goto LABEL_14;
    }
  }
  uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1080), v20, v21, v22, v23, v13, v5, v6);
  if (!Worker)
  {
    uint64_t v7 = "ThreadPoolGetWorker";
    __int16 v8 = 266;
    goto LABEL_5;
  }
  uint64_t v28 = Worker;
  *(void *)(a1 + 1112) = AAHeaderGetPayloadSize(a2);
  *(_DWORD *)(v28 + 8) = value;
  __strlcpy_chk();
  *(void *)(v28 + 1344) = 0;
  *(void *)(v28 + 1368) = 0;
  *(void *)(v28 + 1392) = 0;
  *(void *)(v28 + 1416) = 0;
  *(void *)(v28 + 1432) = 0;
  *(void *)(v28 + 1424) = 0;
  if ((aaEntryAttributesInitWithHeader((char *)(v28 + 1040), (char *)(v28 + 1112), (char *)(v28 + 1168), a2) & 0x80000000) != 0)
  {
    uint64_t v7 = "invalid header";
    __int16 v8 = 277;
    goto LABEL_5;
  }
  v29.uint64_t ikey = 4997953;
  uint32_t v30 = AAHeaderGetKeyIndex(a2, v29);
  if ((v30 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v30, &size, &offset) <= 1)
  {
    uint64_t v31 = size;
    *(void *)(v28 + 1424) = size;
    if ((v31 & 0x8000000000000000) != 0)
    {
LABEL_83:
      uint64_t v7 = "ACL blob allocation";
      __int16 v8 = 284;
      goto LABEL_5;
    }
    unint64_t v32 = *(void *)(v28 + 1376);
    if (v32 < v31)
    {
      do
      {
        while (!v32)
        {
          unint64_t v32 = 0x4000;
          if (v31 <= 0x4000)
          {
            unint64_t v34 = (void **)(v28 + 1384);
            __uint64_t size = 0x4000;
            goto LABEL_44;
          }
        }
        unint64_t v33 = v32 >> 1;
        if ((v32 & (v32 >> 1)) != 0) {
          unint64_t v33 = v32 & (v32 >> 1);
        }
        v32 += v33;
      }
      while (v32 < v31);
      unint64_t v34 = (void **)(v28 + 1384);
      __uint64_t size = v32;
      if (v32 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_82;
      }
LABEL_44:
      unint64_t v35 = *v34;
      uint64_t v36 = realloc(*v34, __size);
      if (v36)
      {
        *(void *)(v28 + 1384) = v36;
        *(void *)(v28 + 1376) = __size;
        goto LABEL_46;
      }
      free(v35);
LABEL_82:
      *unint64_t v34 = 0;
      *(void *)(v28 + 1368) = 0;
      *(void *)(v28 + 1376) = 0;
      goto LABEL_83;
    }
  }
LABEL_46:
  v37.uint64_t ikey = 5521752;
  uint32_t v38 = AAHeaderGetKeyIndex(a2, v37);
  if ((v38 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v38, &size, &offset) <= 1)
  {
    uint64_t v39 = size;
    *(void *)(v28 + 1416) = size;
    if ((v39 & 0x8000000000000000) != 0)
    {
LABEL_86:
      uint64_t v7 = "XAT blob allocation";
      __int16 v8 = 290;
      goto LABEL_5;
    }
    unint64_t v40 = *(void *)(v28 + 1352);
    if (v40 < v39)
    {
      do
      {
        while (!v40)
        {
          unint64_t v40 = 0x4000;
          if (v39 <= 0x4000)
          {
            size_t v42 = (void **)(v28 + 1360);
            __uint64_t size = 0x4000;
            goto LABEL_59;
          }
        }
        unint64_t v41 = v40 >> 1;
        if ((v40 & (v40 >> 1)) != 0) {
          unint64_t v41 = v40 & (v40 >> 1);
        }
        v40 += v41;
      }
      while (v40 < v39);
      size_t v42 = (void **)(v28 + 1360);
      __uint64_t size = v40;
      if (v40 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_85;
      }
LABEL_59:
      char v43 = *v42;
      uint64_t v44 = realloc(*v42, __size);
      if (v44)
      {
        *(void *)(v28 + 1360) = v44;
        *(void *)(v28 + 1352) = __size;
        goto LABEL_61;
      }
      free(v43);
LABEL_85:
      uint64_t *v42 = 0;
      *(void *)(v28 + 1344) = 0;
      *(void *)(v28 + 1352) = 0;
      goto LABEL_86;
    }
  }
LABEL_61:
  v45.uint64_t ikey = 4408665;
  uint32_t v46 = AAHeaderGetKeyIndex(a2, v45);
  if ((v46 & 0x80000000) == 0 && AAHeaderGetFieldBlob(a2, v46, &size, &offset) <= 1)
  {
    uint64_t v51 = size;
    *(void *)(v28 + 1432) = size;
    if ((v51 & 0x8000000000000000) != 0)
    {
LABEL_89:
      uint64_t v7 = "YEC blob allocation";
      __int16 v8 = 296;
      goto LABEL_5;
    }
    size_t v52 = *(void *)(v28 + 1400);
    if (v52 < v51)
    {
      do
      {
        while (!v52)
        {
          size_t v52 = 0x4000;
          if (v51 <= 0x4000)
          {
            long long v54 = (void **)(v28 + 1408);
            size_t v52 = 0x4000;
            goto LABEL_74;
          }
        }
        size_t v53 = v52 >> 1;
        if ((v52 & (v52 >> 1)) != 0) {
          size_t v53 = v52 & (v52 >> 1);
        }
        v52 += v53;
      }
      while (v52 < v51);
      long long v54 = (void **)(v28 + 1408);
      if (v52 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_88;
      }
LABEL_74:
      long long v55 = *v54;
      long long v56 = realloc(*v54, v52);
      if (v56)
      {
        *(void *)(v28 + 1408) = v56;
        *(void *)(v28 + 1400) = v52;
        goto LABEL_76;
      }
      free(v55);
LABEL_88:
      *long long v54 = 0;
      *(void *)(v28 + 1392) = 0;
      *(void *)(v28 + 1400) = 0;
      goto LABEL_89;
    }
  }
LABEL_76:
  if (*(void *)(a1 + 1112))
  {
    uint64_t result = 0;
    *(void *)(a1 + 1096) = v28;
  }
  else
  {
    if ((ThreadPoolRunWorker(*(void *)(a1 + 1080), v28, v47, v48, v49, v50, v5, v6) & 0x80000000) != 0)
    {
      uint64_t v7 = "ThreadPoolRunWorker";
      __int16 v8 = 302;
      goto LABEL_5;
    }
    return 0;
  }
  return result;
}

uint64_t verifyDirectoryStreamWriteBlob(uint64_t a1, int a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 1136))) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 1104)) {
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 1096);
  if (!v11)
  {
    AAFieldKey v17 = "invalid state";
    __int16 v18 = 318;
LABEL_41:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAVerifyDirectoryArchiveOutputStream.c", (uint64_t)"verifyDirectoryStreamWriteBlob", v18, 119, 0, v17, a7, a8, v29);
    int v28 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 1136), (unsigned int *)&v28, 1u);
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = *(void *)&a2 & 0xFFFFFFLL;
  if ((*(void *)&a2 & 0xFFFFFFLL) == 0x434559)
  {
    int v15 = (void *)(v11 + 1392);
    __int16 v16 = (rsize_t *)(v11 + 1432);
  }
  else if (v14 == 4997953)
  {
    int v15 = (void *)(v11 + 1368);
    __int16 v16 = (rsize_t *)(v11 + 1424);
  }
  else
  {
    if (v14 != 5521752) {
      goto LABEL_34;
    }
    int v15 = (void *)(v11 + 1344);
    __int16 v16 = (rsize_t *)(v11 + 1416);
  }
  unint64_t v19 = *v15 + __smax;
  if (__CFADD__(*v15, __smax) || (v19 & 0x8000000000000000) != 0) {
    goto LABEL_40;
  }
  rsize_t v20 = *v16;
  size_t v21 = v15[1];
  if (v21 < v19)
  {
    do
    {
      while (!v21)
      {
        size_t v21 = 0x4000;
        if (v19 <= 0x4000)
        {
          size_t v21 = 0x4000;
          goto LABEL_25;
        }
      }
      size_t v22 = v21 >> 1;
      if ((v21 & (v21 >> 1)) != 0) {
        size_t v22 = v21 & (v21 >> 1);
      }
      v21 += v22;
    }
    while (v21 < v19);
    if (v21 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_39;
    }
LABEL_25:
    uint64_t v23 = (void *)v15[2];
    int v24 = realloc(v23, v21);
    if (v24)
    {
      v15[1] = v21;
      v15[2] = v24;
      goto LABEL_27;
    }
    free(v23);
LABEL_39:
    v15[1] = 0;
    v15[2] = 0;
    *int v15 = 0;
    goto LABEL_40;
  }
LABEL_27:
  uint64_t v25 = v15[2];
  if (__src)
  {
    memcpy((void *)(v25 + *v15), __src, __smax);
  }
  else if (v25)
  {
    memset_s((void *)(v25 + *v15), __smax, 0, __smax);
  }
  rsize_t v26 = *v15 + __smax;
  *int v15 = v26;
  if ((__smax & 0x8000000000000000) != 0)
  {
LABEL_40:
    AAFieldKey v17 = "blob append";
    __int16 v18 = 328;
    goto LABEL_41;
  }
  if (v26 > v20)
  {
    AAFieldKey v17 = "blob size mismatch";
    __int16 v18 = 329;
    goto LABEL_41;
  }
LABEL_34:
  rsize_t v27 = *(void *)(a1 + 1112) - __smax;
  *(void *)(a1 + 1112) = v27;
  if (v27) {
    return 0;
  }
  if ((ThreadPoolRunWorker(*(void *)(a1 + 1080), v11, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    AAFieldKey v17 = "ThreadPoolRunWorker";
    __int16 v18 = 337;
    goto LABEL_41;
  }
  uint64_t result = 0;
  *(void *)(a1 + 1096) = 0;
  return result;
}

void verifyDirectoryStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 1136), (unsigned int *)&v1, 1u);
}

void workerDataFree(void **a1)
{
  if (a1)
  {
    uint64_t v2 = a1 + 168;
    free(a1[170]);
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(a1[173]);
    memset_s(a1 + 171, 0x18uLL, 0, 0x18uLL);
    free(a1[176]);
    memset_s(a1 + 174, 0x18uLL, 0, 0x18uLL);
    free(a1[180]);
    free(a1);
  }
}

uint64_t sendMessage(uint64_t a1, uint64_t a2, uint64_t a3, AAFieldKeySet key_set)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  unsigned int v8 = *(_DWORD *)(a1 + 1048);
  if (v8)
  {
    switch((int)a2)
    {
      case 'G':
        fprintf((FILE *)*MEMORY[0x263EF8348], "REMOVED %s\n");
        break;
      case 'H':
        fprintf((FILE *)*MEMORY[0x263EF8348], "ADDED   %s\n");
        break;
      case 'I':
        if (v8 >= 2) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "OK      %s\n");
        }
        break;
      case 'J':
        long long v18 = 0u;
        long long v19 = 0u;
        long long v16 = 0u;
        long long v17 = 0u;
        long long v14 = 0u;
        long long v15 = 0u;
        *(_OWORD *)s = 0u;
        long long v13 = 0u;
        if (key_set) {
          AAFieldKeySetSerialize(key_set, 0x80uLL, s);
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "DIFFER  %s (%s)\n");
        break;
      default:
        break;
    }
  }
  int v9 = *(uint64_t (**)(void, uint64_t, uint64_t, AAFieldKeySet))(a1 + 1040);
  if (v9)
  {
    uint64_t result = v9(*(void *)(a1 + 1032), a2, a3, key_set);
    if ((result & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    if (a2 == 73)
    {
LABEL_17:
      uint64_t v11 = (atomic_ullong *)(a1 + 1176);
      goto LABEL_24;
    }
    if (result)
    {
      uint64_t v11 = (atomic_ullong *)(a1 + 1168);
LABEL_24:
      atomic_fetch_add_explicit(v11, 1uLL, memory_order_relaxed);
      return result;
    }
    switch(a2)
    {
      case 'G':
LABEL_16:
        uint64_t result = 0;
        uint64_t v11 = (atomic_ullong *)(a1 + 1200);
        goto LABEL_24;
      case 'J':
LABEL_23:
        uint64_t result = 0;
        uint64_t v11 = (atomic_ullong *)(a1 + 1184);
        goto LABEL_24;
      case 'H':
LABEL_22:
        uint64_t result = 0;
        uint64_t v11 = (atomic_ullong *)(a1 + 1192);
        goto LABEL_24;
    }
    return 0;
  }
  else
  {
    uint64_t result = 0;
    switch((int)a2)
    {
      case 'G':
        goto LABEL_16;
      case 'H':
        goto LABEL_22;
      case 'I':
        goto LABEL_17;
      case 'J':
        goto LABEL_23;
      default:
        return result;
    }
  }
}

size_t PCompressLZMA6Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZMADecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t aeaCryptoInit(char *__s, unsigned int *a2)
{
  if (__s) {
    memset_s(__s, 0xD0uLL, 0, 0xD0uLL);
  }
  if (aeaProfileIsValid(*a2))
  {
    int v6 = 0;
    int v7 = 0;
    switch(*a2)
    {
      case 0u:
        *((void *)__s + 9) = HKDFDerive;
        *((void *)__s + 8) = RNG;
        *((_DWORD *)__s + 13) = 32;
        *(void *)&long long v8 = 0x2000000020;
        *((void *)&v8 + 1) = 0x2000000020;
        *(_OWORD *)size_t __s = v8;
        *((void *)__s + 11) = AEADEncrypt_None_MAC256_KEY256;
        *((void *)__s + 12) = AEADDecrypt_None_MAC256_KEY256;
        *((void *)__s + 15) = Digest_SHA256;
        *((void *)__s + 16) = DSASign_ECDSA_P256;
        *((void *)__s + 17) = DSAVerify_ECDSA_P256;
        *(_OWORD *)(__s + 28) = xmmword_214B12940;
        *(void *)(__s + 44) = 0x2000000080;
        goto LABEL_13;
      case 1u:
        goto LABEL_8;
      case 2u:
        int v6 = 1;
LABEL_8:
        *((void *)__s + 9) = HKDFDerive;
        *((void *)__s + 8) = RNG;
        *((_DWORD *)__s + 13) = 32;
        *(_OWORD *)size_t __s = xmmword_214B12930;
        *((void *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        if (!v6) {
          break;
        }
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        int v7 = 1;
LABEL_11:
        *((void *)__s + 9) = HKDFDerive;
        *((void *)__s + 8) = RNG;
        *(_OWORD *)size_t __s = xmmword_214B12930;
        *((void *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 6) = 0x2000000041;
        *((void *)__s + 13) = DHESender_ECDHE_P256;
        *((void *)__s + 14) = DHERecipient_ECDHE_P256;
        *((void *)__s + 2) = 0x4100000061;
        *((_DWORD *)__s + 6) = 32;
        *((void *)__s + 20) = DerivePublicFromPrivate_ECP256;
        if (v7)
        {
LABEL_12:
          *((void *)__s + 15) = Digest_SHA256;
          *((void *)__s + 16) = DSASign_ECDSA_P256;
          *((void *)__s + 17) = DSAVerify_ECDSA_P256;
          *(_OWORD *)(__s + 28) = xmmword_214B12940;
          *((_DWORD *)__s + 11) = 160;
          *((void *)__s + 18) = AEADEncrypt_AESCTR_MAC256_KEY640;
          *((void *)__s + 19) = AEADDecrypt_AESCTR_MAC256_KEY640;
LABEL_13:
          *((void *)__s + 21) = DerivePublicFromPrivate_ECP256;
        }
        break;
      case 5u:
        *((void *)__s + 9) = HKDFDerive;
        *((void *)__s + 8) = RNG;
        *((_DWORD *)__s + 13) = 32;
        *(_OWORD *)size_t __s = xmmword_214B12930;
        *((void *)__s + 11) = AEADEncrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 12) = AEADDecrypt_AESCTR_MAC256_KEY640;
        *((void *)__s + 10) = ScryptDerive_KEY256;
        *((_DWORD *)__s + 14) = a2[2];
        break;
      default:
        *(_DWORD *)size_t __s = 32;
        *((void *)__s + 9) = HKDFDerive;
        *((void *)__s + 1) = 0x2000000020;
        *((void *)__s + 8) = RNG;
        *((_DWORD *)__s + 13) = 32;
        break;
    }
    uint64_t result = 0;
    *((void *)__s + 22) = HMACInit_SHA256;
    *((void *)__s + 23) = HMACUpdate_SHA256;
    *((void *)__s + 24) = HMACFinal_SHA256;
    *((void *)__s + 25) = Digest_SHA256;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"aeaCryptoInit", 1400, 94, 0, "Invalid profile", v4, v5, v10);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t HKDFDerive(_DWORD *a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((unint64_t)(a2 - 257) < 0xFFFFFFFFFFFFFF00 || *a3 == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HKDFDerive", 518, 94, 0, "Invalid KDF parameters", a7, a8, v20);
    return 0xFFFFFFFFLL;
  }
  else
  {
    ccsha256_di();
    unint64_t v12 = a1 + 1;
    int v13 = cchkdf();
    int v16 = v13;
    if (v13)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HKDFDerive", 547, 94, 0, "HKDF", v14, v15, (_BYTE)a1 + 4);
      *a1 = a2;
      memset_s((char *)v12 + a2, 256 - a2, 0, 256 - a2);
      long long v17 = (char *)a1;
      rsize_t v18 = 260;
      rsize_t v19 = 260;
    }
    else
    {
      *a1 = a2;
      long long v17 = (char *)v12 + a2;
      rsize_t v18 = 256 - a2;
      rsize_t v19 = 256 - a2;
    }
    memset_s(v17, v18, 0, v19);
    if (v16) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
}

uint64_t RNG()
{
  ccrng();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"RNG", 222, 94, 0, "generate random bytes", v0, v1, v3);
  return 0xFFFFFFFFLL;
}

uint64_t AEADEncrypt_None_MAC256_KEY256(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a4 == 32)
  {
    if ((HMACDerive_SHA256(a3, a4) & 0x80000000) == 0) {
      return 0;
    }
    char v10 = "HMAC derivation";
    __int16 v11 = 904;
  }
  else
  {
    char v10 = "AEAD invalid sizes";
    __int16 v11 = 901;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_None_MAC256_KEY256", v11, 94, 0, v10, a7, a8, v12);
  if (a3) {
    memset_s(a3, 0x104uLL, 0, 0x104uLL);
  }
  return 0xFFFFFFFFLL;
}

uint64_t AEADDecrypt_None_MAC256_KEY256(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a4 == 32 && *a3 == 32)
  {
    if ((HMACVerify_SHA256((uint64_t)a3, a4) & 0x80000000) == 0) {
      return 0;
    }
    int v9 = "HMAC verification";
    __int16 v10 = 924;
  }
  else
  {
    int v9 = "AEAD invalid sizes";
    __int16 v10 = 921;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_None_MAC256_KEY256", v10, 94, 0, v9, a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t AEADEncrypt_AESCTR_MAC256_KEY640(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  memset(v36, 0, sizeof(v36));
  memset(v33, 0, sizeof(v33));
  memset(v29, 0, sizeof(v29));
  if (*(_DWORD *)a4 != 80)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640", 946, 94, 0, "AEAD invalid sizes", a7, a8, v26);
    return 0xFFFFFFFFLL;
  }
  long long v31 = *(_OWORD *)(a4 + 4);
  long long v32 = *(_OWORD *)(a4 + 20);
  int v30 = 32;
  memset_s(v33, 0xE0uLL, 0, 0xE0uLL);
  v35[0] = *(_OWORD *)(a4 + 36);
  v35[1] = *(_OWORD *)(a4 + 52);
  unsigned int __s = 32;
  memset_s(v36, 0xE0uLL, 0, 0xE0uLL);
  long long v28 = *(_OWORD *)(a4 + 68);
  int v27 = 16;
  memset_s(v29, 0xF0uLL, 0, 0xF0uLL);
  char v12 = (size_t *)ccaes_ctr_crypt_mode();
  rsize_t v13 = *v12;
  if (*v12 < 0x2000000001)
  {
    uint64_t v15 = v12;
    int v16 = malloc(*v12);
    if (!v16) {
      goto LABEL_8;
    }
    long long v17 = v16;
    if (((unsigned int (*)(size_t *, void *, void, _OWORD *, long long *))v15[3])(v15, v16, __s, v35, &v28))
    {
      char v20 = "init";
      __int16 v21 = 991;
    }
    else if (((unsigned int (*)(void *, uint64_t, uint64_t, uint64_t))v15[5])(v17, a2, a1, a1))
    {
      char v20 = "encryption";
      __int16 v21 = 992;
    }
    else
    {
      if ((HMACDerive_SHA256(a3, &v30) & 0x80000000) == 0)
      {
        int v25 = 0;
        goto LABEL_12;
      }
      char v20 = "HMAC";
      __int16 v21 = 995;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640", v21, 94, 0, v20, v18, v19, v26);
    int v25 = 1;
LABEL_12:
    memset_s(v17, v13, 0, v13);
    goto LABEL_13;
  }
  *__error() = 12;
LABEL_8:
  size_t v22 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADEncrypt_AESCTR_MAC256_KEY640", 990, 94, *v22, "malloc", v23, v24, v26);
  long long v17 = 0;
  int v25 = 1;
LABEL_13:
  free(v17);
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v30, 0x104uLL, 0, 0x104uLL);
  memset_s(&v27, 0x104uLL, 0, 0x104uLL);
  if (a3)
  {
    if (v25) {
      memset_s(a3, 0x104uLL, 0, 0x104uLL);
    }
  }
  return (v25 << 31 >> 31);
}

uint64_t AEADDecrypt_AESCTR_MAC256_KEY640(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  memset(v38, 0, sizeof(v38));
  memset(v35, 0, sizeof(v35));
  memset(v31, 0, sizeof(v31));
  if (*(_DWORD *)a4 != 80)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", 1049, 94, 0, "AEAD invalid sizes", a7, a8, v28);
    return 0xFFFFFFFFLL;
  }
  long long v33 = *(_OWORD *)(a4 + 4);
  long long v34 = *(_OWORD *)(a4 + 20);
  int v32 = 32;
  memset_s(v35, 0xE0uLL, 0, 0xE0uLL);
  v37[0] = *(_OWORD *)(a4 + 36);
  v37[1] = *(_OWORD *)(a4 + 52);
  unsigned int __s = 32;
  memset_s(v38, 0xE0uLL, 0, 0xE0uLL);
  long long v30 = *(_OWORD *)(a4 + 68);
  int v29 = 16;
  memset_s(v31, 0xF0uLL, 0, 0xF0uLL);
  if ((HMACVerify_SHA256(a3, &v32) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", 1057, 94, 0, "HMAC", v12, v13, v28);
    int v17 = 0;
    goto LABEL_16;
  }
  uint64_t v14 = (size_t *)ccaes_ctr_crypt_mode();
  rsize_t v15 = *v14;
  if (*v14 < 0x2000000001)
  {
    uint64_t v18 = v14;
    uint64_t v19 = malloc(*v14);
    if (!v19) {
      goto LABEL_10;
    }
    char v20 = v19;
    if (((unsigned int (*)(size_t *, void *, void, _OWORD *, long long *))v18[3])(v18, v19, __s, v37, &v30))
    {
      uint64_t v23 = "init";
      __int16 v24 = 1094;
    }
    else
    {
      if (!((unsigned int (*)(void *, uint64_t, uint64_t, uint64_t))v18[5])(v20, a2, a1, a1))
      {
        int v17 = 1;
        goto LABEL_14;
      }
      uint64_t v23 = "encryption";
      __int16 v24 = 1095;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", v24, 94, 0, v23, v21, v22, v28);
    int v17 = 0;
LABEL_14:
    memset_s(v20, v15, 0, v15);
    goto LABEL_15;
  }
  *__error() = 12;
LABEL_10:
  int v25 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"AEADDecrypt_AESCTR_MAC256_KEY640", 1093, 94, *v25, "malloc", v26, v27, v28);
  int v17 = 0;
  char v20 = 0;
LABEL_15:
  free(v20);
LABEL_16:
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v32, 0x104uLL, 0, 0x104uLL);
  memset_s(&v29, 0x104uLL, 0, 0x104uLL);
  if (v17) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ScryptDerive_KEY256(_DWORD *a1, uint64_t a2, unint64_t a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0x14 || !*a5)
  {
    uint64_t v12 = "Invalid password/salt";
    __int16 v13 = 823;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"ScryptDerive_KEY256", v13, 94, 0, v12, a7, a8, v22);
    return 0xFFFFFFFFLL;
  }
  if (a4 >= 4)
  {
    uint64_t v12 = "Invalid hardness parameter";
    __int16 v13 = 832;
    goto LABEL_8;
  }
  size_t v9 = ccscrypt_storage_size();
  if ((v9 & 0x8000000000000000) != 0)
  {
    rsize_t v15 = "Invalid scrypt parameters";
    __int16 v16 = 842;
    int v17 = 0;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"ScryptDerive_KEY256", v16, 94, v17, v15, v10, v11, v22);
    uint64_t v19 = 0;
LABEL_17:
    free(v19);
    if (a1) {
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    }
    return 0xFFFFFFFFLL;
  }
  if (v9 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_15:
    int v17 = *__error();
    rsize_t v15 = "malloc";
    __int16 v16 = 844;
    goto LABEL_16;
  }
  uint64_t v18 = malloc(v9);
  if (!v18) {
    goto LABEL_15;
  }
  uint64_t v19 = v18;
  if (ccscrypt())
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"ScryptDerive_KEY256", 846, 94, 0, "scrypt", v20, v21, 32);
    goto LABEL_17;
  }
  *a1 = 32;
  memset_s(a1 + 9, 0xE0uLL, 0, 0xE0uLL);
  free(v19);
  return 0;
}

uint64_t DHESender_ECDHE_P256(void *a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 != 65)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHESender_ECDHE_P256", 581, 94, 0, "ECDHE_P256_Sender invalid sizes", a7, a8, v28);
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = (void *)MEMORY[0x2166ADDF0]();
  size_t v11 = (32 * *v10) | 0x10;
  size_t v12 = 24 * *v10 + 16;
  if (v11 < 0x2000000001)
  {
    __int16 v13 = malloc(v11);
  }
  else
  {
    __int16 v13 = 0;
    *__error() = 12;
  }
  if (v12 < 0x2000000001)
  {
    int v17 = malloc(v12);
    uint64_t v14 = v17;
    BOOL v15 = v13 == 0;
    BOOL v16 = v17 == 0;
    if (v13) {
      BOOL v18 = v17 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18)
    {
      if (ccec_x963_import_pub())
      {
        int v25 = "importing public key";
        __int16 v26 = 602;
      }
      else
      {
        ccrng();
        int v25 = "RNG lookup";
        __int16 v26 = 606;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHESender_ECDHE_P256", v26, 94, 0, v25, v23, v24, 32);
      BOOL v16 = 0;
LABEL_21:
      memset_s(v13, v11, 0, v11);
      free(v13);
      if (!v16) {
        memset_s(v14, v12, 0, v12);
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
    *__error() = 12;
    BOOL v15 = v13 == 0;
    BOOL v16 = 1;
  }
  uint64_t v19 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHESender_ECDHE_P256", 599, 94, *v19, "malloc", v20, v21, 32);
  if (!v15) {
    goto LABEL_21;
  }
  free(v13);
  if (!v16) {
    memset_s(v14, v12, 0, v12);
  }
LABEL_16:
  free(v14);
  if (a1) {
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  }
  if (a2) {
    memset_s(a2, 0x104uLL, 0, 0x104uLL);
  }
  return 0xFFFFFFFFLL;
}

uint64_t DHERecipient_ECDHE_P256(void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 != 97 || *a2 != 65)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHERecipient_ECDHE_P256", 704, 94, 0, "ECDHE_P256_Recipient invalid sizes", a7, a8, v27);
    return 0xFFFFFFFFLL;
  }
  size_t v9 = (void *)MEMORY[0x2166ADDF0]();
  size_t v10 = 24 * *v9 + 16;
  size_t v11 = (32 * *v9) | 0x10;
  if (v10 < 0x2000000001)
  {
    size_t v12 = malloc(v10);
  }
  else
  {
    size_t v12 = 0;
    *__error() = 12;
  }
  if (v11 < 0x2000000001)
  {
    int v17 = malloc(v11);
    uint64_t v14 = v17;
    BOOL v15 = v12 == 0;
    BOOL v16 = v17 == 0;
    if (v12) {
      BOOL v18 = v17 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18)
    {
      if (ccec_x963_import_priv())
      {
        int v25 = "importing full key";
        __int16 v26 = 725;
      }
      else if (ccec_x963_import_pub())
      {
        int v25 = "importing pub key";
        __int16 v26 = 728;
      }
      else
      {
        ccrng();
        int v25 = "RNG lookup";
        __int16 v26 = 732;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHERecipient_ECDHE_P256", v26, 94, 0, v25, v23, v24, 32);
      BOOL v16 = 0;
LABEL_25:
      memset_s(v12, v10, 0, v10);
      free(v12);
      if (!v16) {
        memset_s(v14, v11, 0, v11);
      }
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v14 = 0;
    *__error() = 12;
    BOOL v15 = v12 == 0;
    BOOL v16 = 1;
  }
  uint64_t v19 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DHERecipient_ECDHE_P256", 722, 94, *v19, "malloc", v20, v21, 32);
  if (!v15) {
    goto LABEL_25;
  }
  free(v12);
  if (!v16) {
    memset_s(v14, v11, 0, v11);
  }
LABEL_18:
  free(v14);
  if (a1) {
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  }
  return 0xFFFFFFFFLL;
}

uint64_t DerivePublicFromPrivate_ECP256(_DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 != 97)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DerivePublicFromPrivate_ECP256", 1346, 94, 0, "invalid private key size", a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  size_t v9 = (void *)MEMORY[0x2166ADDF0]();
  rsize_t v10 = (32 * *v9) | 0x10;
  if (v10 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_9;
  }
  size_t v11 = malloc((32 * *v9) | 0x10);
  if (!v11)
  {
LABEL_9:
    BOOL v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DerivePublicFromPrivate_ECP256", 1356, 94, *v15, "malloc", v16, v17, v19);
    if (a1) {
LABEL_10:
    }
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    return 0xFFFFFFFFLL;
  }
  size_t v12 = v11;
  if (ccec_x963_import_priv())
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DerivePublicFromPrivate_ECP256", 1359, 94, 0, "importing private key", v13, v14, v19);
    memset_s(v12, v10, 0, v10);
    free(v12);
    if (!a1) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_10;
  }
  ccec_x963_export();
  *a1 = 65;
  memset_s((char *)a1 + 69, 0xBFuLL, 0, 0xBFuLL);
  memset_s(v12, v10, 0, v10);
  free(v12);
  return 0;
}

uint64_t Digest_SHA256(uint64_t a1, const void *a2, CC_LONG a3)
{
  memset(&v7, 0, sizeof(v7));
  CC_SHA256_Init(&v7);
  CC_SHA256_Update(&v7, a2, a3);
  CC_SHA256_Final((unsigned __int8 *)(a1 + 4), &v7);
  *(_DWORD *)a1 = 32;
  return 0;
}

uint64_t DSASign_ECDSA_P256(void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 != 97)
  {
    rsize_t v10 = "invalid private key size";
    __int16 v11 = 1154;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSASign_ECDSA_P256", v11, 94, 0, v10, a7, a8, v22);
    return 0xFFFFFFFFLL;
  }
  if (*a3 != 32)
  {
    rsize_t v10 = "invalid digest size";
    __int16 v11 = 1155;
    goto LABEL_7;
  }
  size_t v9 = (32 * *(void *)MEMORY[0x2166ADDF0]()) | 0x10;
  if (v9 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_12;
  }
  uint64_t v13 = malloc(v9);
  if (!v13)
  {
LABEL_12:
    char v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSASign_ECDSA_P256", 1167, 94, *v19, "malloc", v20, v21, v22);
    if (!a1) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_18;
  }
  uint64_t v14 = v13;
  if (ccec_x963_import_priv())
  {
    uint64_t v17 = "importing private key";
    __int16 v18 = 1170;
  }
  else
  {
    char v22 = 0x80;
    if (a1) {
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    }
    ccrng();
    uint64_t v17 = "RNG lookup";
    __int16 v18 = 1176;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSASign_ECDSA_P256", v18, 94, 0, v17, v15, v16, v22);
  memset_s(v14, v9, 0, v9);
  free(v14);
  if (a1) {
LABEL_18:
  }
    memset_s(a1, 0x104uLL, 0, 0x104uLL);
  return 0xFFFFFFFFLL;
}

uint64_t DSAVerify_ECDSA_P256(unsigned int *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a1 == 128)
  {
    if (*a2 == 65)
    {
      if (*a3 == 32)
      {
        size_t v9 = 24 * *(void *)MEMORY[0x2166ADDF0]() + 16;
        if (v9 < 0x2000000001)
        {
          uint64_t v13 = malloc(v9);
          if (v13)
          {
            uint64_t v14 = v13;
            if (ccec_x963_import_pub())
            {
              uint64_t v17 = "importing public key";
              __int16 v18 = 1267;
            }
            else
            {
              unint64_t v22 = *a1;
              if (v22 >= 2 && *((unsigned char *)a1 + 4) == 48)
              {
                if ((unint64_t)*((unsigned __int8 *)a1 + 5) + 2 <= v22)
                {
                  ccec_verify();
                  uint64_t v17 = "Signature verification";
                  __int16 v18 = 1275;
                }
                else
                {
                  uint64_t v17 = "Invalid signature";
                  __int16 v18 = 1272;
                }
              }
              else
              {
                uint64_t v17 = "Invalid signature";
                __int16 v18 = 1270;
              }
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSAVerify_ECDSA_P256", v18, 94, 0, v17, v15, v16, v23);
            memset_s(v14, v9, 0, v9);
            goto LABEL_21;
          }
        }
        else
        {
          *__error() = 12;
        }
        char v19 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSAVerify_ECDSA_P256", 1264, 94, *v19, "malloc", v20, v21, v23);
        uint64_t v14 = 0;
LABEL_21:
        free(v14);
        return 0xFFFFFFFFLL;
      }
      rsize_t v10 = "invalid digest size";
      __int16 v11 = 1253;
    }
    else
    {
      rsize_t v10 = "Invalid public key size";
      __int16 v11 = 1252;
    }
  }
  else
  {
    rsize_t v10 = "Invalid signature size";
    __int16 v11 = 1251;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"DSAVerify_ECDSA_P256", v11, 94, 0, v10, a7, a8, v23);
  return 0xFFFFFFFFLL;
}

void *HMACInit_SHA256(_DWORD *a1)
{
  if (*a1 != 32) {
    return 0;
  }
  ccsha256_di();
  uint64_t v1 = malloc(0x1F8uLL);
  if (v1)
  {
    cchmac_init();
  }
  else
  {
    uint64_t v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HMACInit_SHA256", 388, 94, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

uint64_t HMACUpdate_SHA256(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  ccsha256_di();
  cchmac_update();
  return 0;
}

uint64_t HMACFinal_SHA256(void *a1, _DWORD *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  ccsha256_di();
  cchmac_final();
  *a2 = 32;
  memset_s(a2 + 9, 0xE0uLL, 0, 0xE0uLL);
  memset_s(a1, 0x1F8uLL, 0, 0x1F8uLL);
  free(a1);
  return 0;
}

uint64_t HMACDerive_SHA256(_DWORD *a1, _DWORD *a2)
{
  if (*a2 != 32) {
    return 0xFFFFFFFFLL;
  }
  ccsha256_di();
  uint64_t v3 = malloc(0x1F8uLL);
  if (v3)
  {
    cchmac_init();
    cchmac_update();
    cchmac_update();
    cchmac_update();
    cchmac_final();
    *a1 = 32;
    memset_s(a1 + 9, 0xE0uLL, 0, 0xE0uLL);
    memset_s(v3, 0x1F8uLL, 0, 0x1F8uLL);
    free(v3);
  }
  else
  {
    uint64_t v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEACrypto.c", (uint64_t)"HMACDerive_SHA256", 271, 94, *v5, "malloc", v6, v7, v8);
    if (a1) {
      memset_s(a1, 0x104uLL, 0, 0x104uLL);
    }
  }
  if (v3) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t HMACVerify_SHA256(uint64_t a1, _DWORD *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  BOOL v3 = *(_DWORD *)a1 != 32 || *a2 != 32;
  int v13 = 0;
  memset(__s, 0, sizeof(__s));
  int v4 = HMACDerive_SHA256(__s, a2);
  int64x2_t v10 = *(int64x2_t *)((char *)&__s[1] + 4);
  int64x2_t v11 = *(int64x2_t *)((char *)__s + 4);
  int64x2_t v8 = *(int64x2_t *)(a1 + 20);
  int64x2_t v9 = *(int64x2_t *)(a1 + 4);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  int v5 = v4 < 0 || v3;
  uint16x4_t v6 = (uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_s64(v11, v9), (int32x4_t)vceqq_s64(v10, v8))));
  v6.i16[0] = vmaxv_u16(v6);
  return ((v6.i32[0] | v5) << 31 >> 31);
}

AAByteStream AEADecryptionInputStreamOpen(AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  unsigned int DefaultNThreads = n_threads;
  if (n_threads <= 0) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((_DWORD *)context + 684) || !*((void *)context + 341))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"AEADecryptionInputStreamOpen", 461, 30, 0, "Invalid context", v4, v5, v52);
    int64x2_t v10 = 0;
    uint64_t v12 = 0;
LABEL_22:
    free(v10);
    aeaInputStreamClose(v12);
    return 0;
  }
  int64x2_t v10 = calloc(1uLL, 0x68uLL);
  int64x2_t v11 = malloc(0x428uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x428uLL, 0, 0x428uLL), !v10))
  {
    int v18 = *__error();
    uint64_t v16 = "malloc";
    __int16 v17 = 466;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"AEADecryptionInputStreamOpen", v17, 30, v18, v16, v13, v14, v52);
    goto LABEL_22;
  }
  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  if ((aeaContextUnlock((uint64_t)context, v12 + 144, (_DWORD *)(v12 + 788), 0, 1, 0) & 0x80000000) != 0)
  {
    uint64_t v16 = "unlock container";
    __int16 v17 = 473;
    goto LABEL_20;
  }
  unint64_t v15 = (*(void *)(v12 + 176) + (unint64_t)*(unsigned int *)(v12 + 160) - 1) / *(unsigned int *)(v12 + 160);
  if (v15 >= 0xFFFFFFFF)
  {
    uint64_t v16 = "Invalid data size";
    __int16 v17 = 477;
LABEL_20:
    int v18 = 0;
    goto LABEL_21;
  }
  *(_DWORD *)(v12 + 52) = v15;
  *(_DWORD *)(v12 + 44) = (v15 + *(_DWORD *)(v12 + 164) - 1) / *(_DWORD *)(v12 + 164);
  atomic_store(*((void *)context + 341), (unint64_t *)(v12 + 32));
  if ((aeaCryptoInit((char *)(v12 + 216), (unsigned int *)(v12 + 144)) & 0x80000000) != 0)
  {
    uint64_t v16 = "Invalid container";
    __int16 v17 = 486;
    goto LABEL_20;
  }
  AAByteStream result = (AAByteStream)aeaContainerOffsetsInit(v12 + 424, (unsigned int *)(v12 + 144), (unsigned int *)(v12 + 216));
  if ((result & 0x80000000) != 0)
  {
    uint64_t v16 = "deriving container offsets";
    __int16 v17 = 487;
    goto LABEL_20;
  }
  uint64_t v20 = *(unsigned int *)(v12 + 228);
  if (v20 < 0x101)
  {
    __memcpy_chk();
    *(_DWORD *)(v12 + 528) = v20;
    memset_s((void *)(v12 + 532 + v20), 256 - v20, 0, 256 - v20);
    size_t v21 = *(void *)(v12 + 520);
    *(void *)(v12 + 1056) = v21;
    if (v21 < 0x2000000001)
    {
      char v23 = malloc(v21);
    }
    else
    {
      unint64_t v22 = __error();
      char v23 = 0;
      *unint64_t v22 = 12;
    }
    *(void *)(v12 + 1048) = v23;
    if (*(void *)(v12 + 176) < 0x10000uLL || DefaultNThreads == 1)
    {
      *(void *)(v12 + 96) = 0;
      uint64_t v41 = *(unsigned int *)(v12 + 168);
      if (v41)
      {
        compression_algorithm v42 = aeaEffectiveCompressionAlgorithm(v41);
        size_t v43 = compression_decode_scratch_buffer_size(v42);
        *(void *)(v12 + 96) = v43;
      }
      else
      {
        size_t v43 = 0;
      }
      size_t v44 = *(unsigned int *)(v12 + 160);
      AAFieldKey v45 = malloc(v44);
      *(void *)(v12 + 72) = v45;
      *(void *)(v12 + 80) = malloc(v44);
      if (v43)
      {
        if (v43 < 0x2000000001)
        {
          uint64_t v47 = malloc(v43);
        }
        else
        {
          uint32_t v46 = __error();
          uint64_t v47 = 0;
          *uint32_t v46 = 12;
          AAFieldKey v45 = *(void **)(v12 + 72);
        }
        *(void *)(v12 + 88) = v47;
      }
      if (!v45 || !*(void *)(v12 + 80) || !*(void *)(v12 + 1048) || *(void *)(v12 + 96) && !*(void *)(v12 + 88))
      {
        int v18 = *__error();
        uint64_t v16 = "malloc";
        __int16 v17 = 513;
        goto LABEL_21;
      }
    }
    else
    {
      *(_DWORD *)(v12 + 112) = DefaultNThreads;
      uint64_t v24 = calloc(DefaultNThreads, 8uLL);
      *(void *)(v12 + 120) = v24;
      if (!v24)
      {
        int v18 = *__error();
        uint64_t v16 = "malloc";
        __int16 v17 = 520;
        goto LABEL_21;
      }
      uint64_t v32 = *(unsigned int *)(v12 + 112);
      if (v32)
      {
        uint64_t v33 = 0;
        uint64_t v34 = 8 * v32;
        while (1)
        {
          unint64_t v35 = malloc(0x240uLL);
          if (!v35)
          {
            int v18 = *__error();
            uint64_t v16 = "malloc";
            __int16 v17 = 524;
            goto LABEL_21;
          }
          uint64_t v36 = v35;
          *(void *)(*(void *)(v12 + 120) + v33) = v35;
          *unint64_t v35 = v12;
          size_t v37 = *(unsigned int *)(v12 + 160);
          uint32_t v38 = malloc(v37);
          v36[69] = v38;
          uint64_t v39 = malloc(v37);
          v36[70] = v39;
          if (!v38 || v39 == 0) {
            break;
          }
          v33 += 8;
          if (v34 == v33) {
            goto LABEL_53;
          }
        }
        int v18 = *__error();
        uint64_t v16 = "malloc";
        __int16 v17 = 529;
        goto LABEL_21;
      }
      LODWORD(v37) = *(_DWORD *)(v12 + 160);
LABEL_53:
      uint64_t v48 = SharedBufferCreate((2 * v37), v25, v26, v27, v28, v29, v30, v31);
      *(void *)(v12 + 104) = v48;
      if (!v48)
      {
        uint64_t v16 = "creating shared buffer";
        __int16 v17 = 532;
        goto LABEL_20;
      }
      uint64_t v49 = ThreadPipelineCreate(*(_DWORD *)(v12 + 112), *(void *)(v12 + 120), (uint64_t)streamWorkerProc, v12, (uint64_t)streamConsumerProc, 0);
      *(void *)(v12 + 128) = v49;
      if (!v49)
      {
        uint64_t v16 = "creating pipeline";
        __int16 v17 = 534;
        goto LABEL_20;
      }
      if ((createThread((pthread_t *)(v12 + 136), (uint64_t)streamThreadProc, v12, 0) & 0x80000000) != 0)
      {
        uint64_t v16 = "Stream thread creation";
        __int16 v17 = 535;
        goto LABEL_20;
      }
    }
    long long v50 = *(_OWORD *)(v12 + 192);
    *((_OWORD *)context + 2) = *(_OWORD *)(v12 + 176);
    *((_OWORD *)context + 3) = v50;
    *((void *)context + 8) = *(void *)(v12 + 208);
    long long v51 = *(_OWORD *)(v12 + 160);
    *(_OWORD *)context = *(_OWORD *)(v12 + 144);
    *((_OWORD *)context + 1) = v51;
    v10[2] = aeaInputStreamRead;
    v10[7] = aeaInputStreamCancel;
    *int64x2_t v10 = v12;
    v10[1] = aeaInputStreamClose;
    return (AAByteStream)v10;
  }
  __break(1u);
  return result;
}

uint64_t streamWorkerProc(uint64_t a1)
{
  size_t v1 = *(void *)a1;
  if (atomic_load((unsigned int *)(*(void *)a1 + 16))) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a1 + 568))
  {
    uint64_t v4 = (_DWORD *)(a1 + 8);
    if ((aeaInputStreamDecryptSegment(*(void *)a1, (unsigned int *)(a1 + 8), *(const uint8_t **)(a1 + 552), *(uint8_t **)(a1 + 560)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamWorkerProc", 298, 30, 0, "decrypting segment %u", v5, v6, *v4);
      aeaInputStreamCancel(v1, v7, v8, v9, v10, v11, v12, v13, v14);
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t streamConsumerProc(size_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 16))) {
    return 0xFFFFFFFFLL;
  }
  if (atomic_load((unsigned int *)(a1 + 24))) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 568))
  {
    int v12 = 0;
    uint64_t result = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v12, 1u);
    if (!v12)
    {
      SharedBufferWrite(*(void *)(a1 + 104), 0, 0, a4, a5, a6, a7, a8);
      return 0;
    }
  }
  else if (SharedBufferWrite(*(void *)(a1 + 104), *(void *)(a2 + 560), *(unsigned int *)(a2 + 12), a4, a5, a6, a7, a8) == *(_DWORD *)(a2 + 12))
  {
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamConsumerProc", 321, 30, 0, "SharedBufferWrite", v13, v14, v22);
    aeaInputStreamCancel(a1, v15, v16, v17, v18, v19, v20, v21, v23);
    return 0xFFFFFFFFLL;
  }
  return result;
}

size_t streamThreadProc(size_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 52))
  {
    int v9 = 0;
    int v10 = 1;
    while (1)
    {
      unsigned int v11 = atomic_load((unsigned int *)(a1 + 16));
      if (v11 || (unsigned int v12 = atomic_load((unsigned int *)(a1 + 20))) != 0)
      {
LABEL_13:
        if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 52)) {
          goto LABEL_16;
        }
        goto LABEL_17;
      }
      uint64_t Worker = ThreadPipelineGetWorker(*(void *)(a1 + 128), a2, a3, a4, a5, a6, a7, a8);
      if (!Worker)
      {
        unint64_t v40 = "getting worker from pipeline";
        __int16 v41 = 263;
        goto LABEL_26;
      }
      uint64_t v14 = Worker;
      *(_DWORD *)(Worker + 568) = 0;
      uint64_t v15 = (_DWORD *)(Worker + 8);
      memset_s((void *)(Worker + 8), 0x220uLL, 0, 0x220uLL);
      if ((aeaInputStreamLoadSegment(a1, v15, *(void *)(v14 + 552), v16, v17, v18, v19, v20) & 0x80000000) != 0) {
        break;
      }
      if (!v10) {
        goto LABEL_10;
      }
LABEL_11:
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 68);
      if ((ThreadPipelineRunWorker(*(void *)(a1 + 128), v14, v21, v22, v23, v24, v25, v26) & 0x80000000) != 0)
      {
        unint64_t v40 = "running worker";
        __int16 v41 = 269;
        goto LABEL_26;
      }
      if (++v9 >= *(_DWORD *)(a1 + 52)) {
        goto LABEL_13;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamThreadProc", 266, 30, 0, "loading segment", v25, v26, v43);
LABEL_10:
    memset_s(v15, 0x220uLL, 0, 0x220uLL);
    int v10 = 0;
    goto LABEL_11;
  }
  int v10 = 1;
LABEL_16:
  if ((aeaInputStreamAuthenticatePadding((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    unint64_t v40 = "authenticating padding";
    __int16 v41 = 275;
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"streamThreadProc", v41, 30, 0, v40, a7, a8, v43);
LABEL_27:
    aeaInputStreamCancel(a1, v35, v36, v37, v38, v39, a7, a8, v43);
    return a1;
  }
LABEL_17:
  uint64_t v27 = ThreadPipelineGetWorker(*(void *)(a1 + 128), a2, a3, a4, a5, a6, a7, a8);
  if (!v27)
  {
    unint64_t v40 = "getting worker from pipeline";
    __int16 v41 = 280;
    goto LABEL_26;
  }
  uint64_t v28 = v27;
  *(_DWORD *)(v27 + 568) = 1;
  memset_s((void *)(v27 + 8), 0x220uLL, 0, 0x220uLL);
  if ((ThreadPipelineRunWorker(*(void *)(a1 + 128), v28, v29, v30, v31, v32, v33, v34) & 0x80000000) != 0)
  {
    unint64_t v40 = "running worker";
    __int16 v41 = 283;
    goto LABEL_26;
  }
  if (!v10) {
    goto LABEL_27;
  }
  return a1;
}

uint64_t aeaInputStreamRead(size_t a1, uint64_t __dst, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (atomic_load((unsigned int *)(a1 + 16))) {
    return -1;
  }
  size_t v11 = a3;
  if (!a3) {
    return 0;
  }
  unsigned int v12 = (char *)__dst;
  size_t v14 = *(void *)(a1 + 104);
  if (v14)
  {
    uint64_t v9 = SharedBufferRead(v14, __dst, a3);
    if ((v9 & 0x8000000000000000) == 0) {
      return v9;
    }
    uint64_t v17 = "Multi-thread read";
    __int16 v18 = 353;
    goto LABEL_8;
  }
  uint64_t v9 = 0;
  unsigned int v26 = *(_DWORD *)(a1 + 64);
  do
  {
    unsigned int v27 = *(_DWORD *)(a1 + 68);
    if (v26 >= v27)
    {
      if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 52)) {
        break;
      }
      bzero(__s, 0x220uLL);
      if ((aeaInputStreamLoadSegment(a1, __s, *(void *)(a1 + 72), v28, v29, v30, v31, v32) & 0x80000000) != 0)
      {
        uint64_t v17 = "Segment load";
        __int16 v18 = 365;
        goto LABEL_8;
      }
      if ((aeaInputStreamDecryptSegment(a1, __s, *(const uint8_t **)(a1 + 72), *(uint8_t **)(a1 + 80)) & 0x80000000) != 0)
      {
        uint64_t v17 = "Segment decrypt";
        __int16 v18 = 366;
        goto LABEL_8;
      }
      memset_s(__s, 0x220uLL, 0, 0x220uLL);
      unsigned int v26 = *(_DWORD *)(a1 + 64);
      unsigned int v27 = *(_DWORD *)(a1 + 68);
    }
    size_t v33 = v27 - v26;
    if (v33 >= v11) {
      size_t v34 = v11;
    }
    else {
      size_t v34 = v33;
    }
    if (!v34) {
      break;
    }
    memcpy(v12, (const void *)(*(void *)(a1 + 80) + v26), v34);
    v9 += v34;
    v12 += v34;
    unsigned int v26 = *(_DWORD *)(a1 + 64) + v34;
    *(_DWORD *)(a1 + 64) = v26;
    v11 -= v34;
  }
  while (v11);
  if (v9) {
    return v9;
  }
  if (atomic_load((unsigned int *)(a1 + 28))) {
    return 0;
  }
  if ((aeaInputStreamAuthenticatePadding((uint64_t *)a1, __dst, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
  {
    int v36 = 0;
    uint64_t v9 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 28), (unsigned int *)&v36, 1u);
    return v9;
  }
  uint64_t v17 = "Padding authentication";
  __int16 v18 = 385;
LABEL_8:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamRead", v18, 30, 0, v17, v15, v16, v37);
  aeaInputStreamCancel(a1, v19, v20, v21, v22, v23, v24, v25, v38);
  return -1;
}

size_t aeaInputStreamCancel(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(result + 16), (unsigned int *)&v9, 1u);
  if (!v9)
  {
    size_t v10 = result;
    AAByteStreamCancel(*(AAByteStream *)result);
    uint64_t result = *(void *)(v10 + 104);
    if (result)
    {
      return SharedBufferAbort(result, v11, v12, v13, v14, v15, v16, v17, a9);
    }
  }
  return result;
}

uint64_t aeaInputStreamClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 136))
    {
      int v2 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(result + 20), (unsigned int *)&v2, 1u);
      while (SharedBufferFlushToStream(*(void *)(v1 + 104), 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))sharedBufferWriteToDrain, 0) > 0);
      joinThread(*(_opaque_pthread_t **)(v1 + 136));
    }
    ThreadPipelineDestroy(*(void *)(v1 + 128));
    SharedBufferDestroy(*(void *)(v1 + 104));
    uint64_t v5 = *(void **)(v1 + 120);
    if (v5)
    {
      unint64_t v6 = *(unsigned int *)(v1 + 112);
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void ***)(*(void *)(v1 + 120) + 8 * i);
          if (v8)
          {
            free(v8[69]);
            free(v8[70]);
            free(v8);
            unint64_t v6 = *(unsigned int *)(v1 + 112);
          }
        }
        uint64_t v5 = *(void **)(v1 + 120);
      }
      free(v5);
    }
    unsigned int v9 = atomic_load((unsigned int *)(v1 + 16));
    if (v9) {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamClose", 438, 30, 0, "Stream processing cancelled", v3, v4, v14);
    }
    size_t v10 = *(void **)(v1 + 1048);
    if (v10) {
      memset_s(*(void **)(v1 + 1048), *(void *)(v1 + 1056), 0, *(void *)(v1 + 1056));
    }
    free(v10);
    uint64_t v11 = *(void **)(v1 + 72);
    if (v11) {
      memset_s(*(void **)(v1 + 72), *(unsigned int *)(v1 + 160), 0, *(unsigned int *)(v1 + 160));
    }
    free(v11);
    uint64_t v12 = *(void **)(v1 + 80);
    if (v12) {
      memset_s(*(void **)(v1 + 80), *(unsigned int *)(v1 + 160), 0, *(unsigned int *)(v1 + 160));
    }
    free(v12);
    uint64_t v13 = *(void **)(v1 + 88);
    if (v13) {
      memset_s(*(void **)(v1 + 88), *(void *)(v1 + 96), 0, *(void *)(v1 + 96));
    }
    free(v13);
    memset_s((void *)v1, 0x428uLL, 0, 0x428uLL);
    free((void *)v1);
    if (v9) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t aeaInputStreamDecryptSegment(uint64_t a1, unsigned int *a2, const uint8_t *a3, uint8_t *a4)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  int v36 = 0;
  memset(v35, 0, sizeof(v35));
  int v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v7 = a2[2];
  unsigned int v8 = *a2;
  unsigned int v9 = *(_DWORD *)(a1 + 164);
  int v38 = 0;
  memset(v37, 0, sizeof(v37));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  *(void *)unsigned int __s = 0x5F41454100000006;
  memset(v39, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[*(unsigned int *)__s + 4] = v8 / v9;
  *(_DWORD *)unsigned int __s = 10;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  size_t v10 = *(uint64_t (**)(_OWORD *, void))(a1 + 288);
  if (v10 && *(_DWORD *)(a1 + 788))
  {
    int v11 = v10(v37, *(unsigned int *)(a1 + 216));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    int v12 = 0;
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_8;
    }
  }
  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }
  int v12 = 1;
LABEL_8:
  memset((char *)v39 + 8, 0, 224);
  memset((char *)&v39[14] + 8, 0, 28);
  WORD4(v39[0]) = 19283;
  *(void *)&v39[0] = 0x5F41454100000006;
  memset_s((char *)v39 + 10, 0xFAuLL, 0, 0xFAuLL);
  uint64_t v13 = LODWORD(v39[0]);
  if (LODWORD(v39[0]) >= 0xFD) {
    __break(1u);
  }
  *(_DWORD *)((char *)v39 + LODWORD(v39[0]) + 4) = v8 % v9;
  LODWORD(v39[0]) = v13 + 4;
  memset_s((char *)v39 + v13 + 8, 252 - v13, 0, 252 - v13);
  memset(__s, 0, sizeof(__s));
  char v14 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, unsigned char *))(a1 + 288);
  if (!v14 || !LODWORD(v37[0]))
  {
    memset_s(v39, 0x104uLL, 0, 0x104uLL);
    goto LABEL_23;
  }
  int v15 = v14(v35, *(unsigned int *)(a1 + 220), v37, v39, __s);
  memset_s(v39, 0x104uLL, 0, 0x104uLL);
  if (v15 < 0)
  {
LABEL_23:
    memset_s(v37, 0x104uLL, 0, 0x104uLL);
    goto LABEL_24;
  }
  memset_s(v37, 0x104uLL, 0, 0x104uLL);
  if (v12)
  {
LABEL_24:
    unsigned int v26 = "derivating segment key";
    __int16 v27 = 122;
    goto LABEL_25;
  }
  __int16 v18 = *(uint64_t (**)(const uint8_t *, uint64_t))(a1 + 312);
  if (v18 && a2[71] == *(_DWORD *)(a1 + 228) && (v18(a3, v7) & 0x80000000) == 0)
  {
    uint64_t v19 = *(unsigned int *)(a1 + 168);
    size_t v20 = a2[1];
    if (v19 && (size_t v21 = a2[2], v20 > v21))
    {
      if (v19 == 774)
      {
        int64_t v22 = PCompressLZMADecode(a4, *(unsigned int *)(a1 + 160), a3, v21);
        if (v22 >= 0) {
          size_t v25 = v22;
        }
        else {
          size_t v25 = 0;
        }
      }
      else
      {
        compression_algorithm v30 = aeaEffectiveCompressionAlgorithm(v19);
        size_t v25 = compression_decode_buffer(a4, *(unsigned int *)(a1 + 160), a3, a2[2], *(void **)(a1 + 88), v30);
      }
    }
    else
    {
      memcpy(a4, a3, v20);
      size_t v25 = a2[1];
    }
    if (v25 == a2[1])
    {
      if ((aeaChecksum((uint64_t)v33, *(_DWORD *)(a1 + 156), a4, v25, v23, v24, v16, v17) & 0x80000000) == 0)
      {
        uint64_t v28 = 0;
        goto LABEL_26;
      }
      unsigned int v26 = "computing segment checksum";
      __int16 v27 = 151;
    }
    else
    {
      unsigned int v26 = "Segment decompression";
      __int16 v27 = 148;
    }
  }
  else
  {
    unsigned int v26 = "decrypting segment";
    __int16 v27 = 125;
  }
LABEL_25:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamDecryptSegment", v27, 30, 0, v26, v16, v17, v31);
  uint64_t v28 = 0xFFFFFFFFLL;
LABEL_26:
  memset_s(v35, 0x104uLL, 0, 0x104uLL);
  memset_s(v33, 0x104uLL, 0, 0x104uLL);
  return v28;
}

uint64_t aeaInputStreamLoadSegment(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(result + 64) < *(_DWORD *)(result + 68))
  {
    unsigned int v8 = "Truncated segment";
    __int16 v9 = 168;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamLoadSegment", v9, 30, 0, v8, a7, a8, v41[0]);
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = result;
  if (*(_DWORD *)(result + 48) >= *(_DWORD *)(result + 52)) {
    return 0;
  }
  unsigned int v13 = *(_DWORD *)(result + 60);
  if (*(_DWORD *)(result + 56) >= v13)
  {
    int v42 = 0;
    memset(v41, 0, sizeof(v41));
    if (*(_DWORD *)(result + 40) >= *(_DWORD *)(result + 44))
    {
LABEL_37:
      if (!v13)
      {
LABEL_39:
        unsigned int v8 = "Invalid state";
        __int16 v9 = 177;
        goto LABEL_3;
      }
      goto LABEL_38;
    }
    uint64_t v14 = *(void *)result;
    unint64_t v15 = *(void *)(result + 520);
    if (*(void *)(*(void *)result + 16))
    {
      if (!v15) {
        goto LABEL_19;
      }
      uint64_t v16 = 0;
      uint64_t v17 = *(void *)(result + 1048);
      while (1)
      {
        uint64_t v18 = (*(uint64_t (**)(void, uint64_t, unint64_t))(v14 + 16))(*(void *)v14, v17, v15);
        if (v18 < 0) {
          break;
        }
        if (v18)
        {
          v17 += v18;
          v16 += v18;
          v15 -= v18;
          if (v15) {
            continue;
          }
        }
        goto LABEL_17;
      }
      uint64_t v16 = v18;
LABEL_17:
      unint64_t v15 = *(void *)(v10 + 520);
    }
    else
    {
      uint64_t v16 = -1;
    }
    if (v16 != v15)
    {
      uint64_t v23 = "loading cluster header";
      __int16 v24 = 86;
      goto LABEL_56;
    }
LABEL_19:
    atomic_fetch_add((atomic_ullong *volatile)(v10 + 32), v15);
    int v19 = *(_DWORD *)(v10 + 40);
    int v44 = 0;
    memset(v43, 0, sizeof(v43));
    memset(&__s[8], 0, 252);
    *(_WORD *)&__s[8] = 19267;
    memset(v45, 0, 260);
    memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
    *(_DWORD *)&__s[10] = v19;
    *(void *)unsigned int __s = 0x5F4145410000000ALL;
    memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
    size_t v20 = *(uint64_t (**)(_OWORD *, void))(v10 + 288);
    if (v20 && *(_DWORD *)(v10 + 788))
    {
      int v21 = v20(v43, *(unsigned int *)(v10 + 216));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      int v22 = 0;
      if ((v21 & 0x80000000) == 0)
      {
LABEL_26:
        memset((char *)v45 + 12, 0, 248);
        *(void *)((char *)v45 + 4) = 0x4B4548435F414541;
        LODWORD(v45[0]) = 8;
        memset_s((char *)v45 + 12, 0xF8uLL, 0, 0xF8uLL);
        memset(__s, 0, sizeof(__s));
        size_t v25 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, unsigned char *))(v10 + 288);
        if (v25 && LODWORD(v43[0]))
        {
          int v26 = v25(v41, *(unsigned int *)(v10 + 220), v43, v45, __s);
          memset_s(v45, 0x104uLL, 0, 0x104uLL);
          if ((v26 & 0x80000000) == 0)
          {
            memset_s(v43, 0x104uLL, 0, 0x104uLL);
            if (!v22)
            {
              __int16 v27 = *(uint64_t (**)(void, void, uint64_t, _OWORD *, void, void))(v10 + 312);
              if (v27)
              {
                if (*(_DWORD *)(v10 + 528) == *(_DWORD *)(v10 + 228))
                {
                  uint64_t result = v27(*(void *)(v10 + 1048), *(void *)(v10 + 504), v10 + 528, v41, *(void *)(v10 + 1048) + *(void *)(v10 + 504), *(void *)(v10 + 520) - *(void *)(v10 + 504));
                  if ((result & 0x80000000) == 0)
                  {
                    uint64_t v28 = *(unsigned int *)(v10 + 228);
                    if (v28 >= 0x101)
                    {
LABEL_62:
                      __break(1u);
                      return result;
                    }
                    memcpy((void *)(v10 + 532), (const void *)(*(void *)(v10 + 1048) + *(void *)(v10 + 504)), *(unsigned int *)(v10 + 228));
                    *(_DWORD *)(v10 + 528) = v28;
                    memset_s((void *)(v10 + 532 + v28), 256 - v28, 0, 256 - v28);
                    ++*(_DWORD *)(v10 + 40);
                    unsigned int v29 = *(_DWORD *)(v10 + 164);
                    if (v29 >= *(_DWORD *)(v10 + 52) - *(_DWORD *)(v10 + 48)) {
                      unsigned int v29 = *(_DWORD *)(v10 + 52) - *(_DWORD *)(v10 + 48);
                    }
                    *(_DWORD *)(v10 + 56) = 0;
                    *(_DWORD *)(v10 + 60) = v29;
                    *(void *)(v10 + 64) = 0;
                    uint64_t result = memset_s(v41, 0x104uLL, 0, 0x104uLL);
                    unsigned int v13 = *(_DWORD *)(v10 + 60);
                    goto LABEL_37;
                  }
                }
              }
              uint64_t v23 = "decrypting cluster";
              __int16 v24 = 95;
LABEL_56:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamUnlockCluster", v24, 30, 0, v23, a7, a8, v41[0]);
              memset_s(v41, 0x104uLL, 0, 0x104uLL);
              unsigned int v8 = "unlocking next cluster";
              __int16 v9 = 174;
              goto LABEL_3;
            }
LABEL_55:
            uint64_t v23 = "derivating cluster key";
            __int16 v24 = 90;
            goto LABEL_56;
          }
        }
        else
        {
          memset_s(v45, 0x104uLL, 0, 0x104uLL);
        }
        memset_s(v43, 0x104uLL, 0, 0x104uLL);
        goto LABEL_55;
      }
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    int v22 = 1;
    goto LABEL_26;
  }
LABEL_38:
  if (v13 > *(_DWORD *)(v10 + 164)) {
    goto LABEL_39;
  }
  unint64_t v30 = *(void *)(v10 + 496)
      + *(unsigned int *)(v10 + 56) * (unint64_t)(*(_DWORD *)(v10 + 192) + 8);
  *a2 = *(_DWORD *)(v10 + 48);
  a2[1] = *(_DWORD *)(*(void *)(v10 + 1048) + v30);
  a2[2] = *(_DWORD *)(v30 + *(void *)(v10 + 1048) + 4);
  uint64_t v31 = *(unsigned int *)(v10 + 192);
  if (v31 >= 0x101) {
    goto LABEL_62;
  }
  memcpy(a2 + 7, (const void *)(v30 + *(void *)(v10 + 1048) + 8), *(unsigned int *)(v10 + 192));
  a2[6] = v31;
  uint64_t result = memset_s((char *)a2 + v31 + 28, 256 - v31, 0, 256 - v31);
  uint64_t v32 = *(unsigned int *)(v10 + 228);
  if (v32 >= 0x101) {
    goto LABEL_62;
  }
  memcpy(a2 + 72, (const void *)(*(void *)(v10 + 1048) + *(void *)(v10 + 512) + (*(_DWORD *)(v10 + 56) * v32)), *(unsigned int *)(v10 + 228));
  a2[71] = v32;
  memset_s((char *)a2 + v32 + 288, 256 - v32, 0, 256 - v32);
  unsigned int v33 = a2[1];
  unsigned int v34 = *(_DWORD *)(v10 + 160);
  if (v33 > v34 || (unint64_t v35 = a2[2], v35 > v33) || v35 > v34)
  {
    unsigned int v8 = "Invalid segment sizes";
    __int16 v9 = 194;
    goto LABEL_3;
  }
  uint64_t v36 = *(void *)v10;
  if (!*(void *)(*(void *)v10 + 16)) {
    goto LABEL_60;
  }
  uint64_t v37 = 0;
  if (v35)
  {
    uint64_t v38 = a2[2];
    while (1)
    {
      uint64_t v39 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v36 + 16))(*(void *)v36, a3, v38);
      if (v39 < 0) {
        break;
      }
      if (v39)
      {
        a3 += v39;
        v37 += v39;
        v38 -= v39;
        if (v38) {
          continue;
        }
      }
      goto LABEL_58;
    }
    uint64_t v37 = v39;
  }
LABEL_58:
  if (v37 != v35)
  {
LABEL_60:
    unsigned int v8 = "reading segment data";
    __int16 v9 = 198;
    goto LABEL_3;
  }
  uint64_t result = 0;
  atomic_fetch_add((atomic_ullong *volatile)(v10 + 32), v35);
  ++*(_DWORD *)(v10 + 48);
  ++*(_DWORD *)(v10 + 56);
  int v40 = a2[1];
  *(_DWORD *)(v10 + 64) = 0;
  *(_DWORD *)(v10 + 68) = v40;
  return result;
}

uint64_t aeaInputStreamAuthenticatePadding(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)a1 + 12) < *((_DWORD *)a1 + 13))
  {
    unsigned int v8 = "Invalid state";
    __int16 v9 = 220;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", v9, 30, 0, v8, a7, a8, v37);
    int v13 = 0;
    uint64_t v14 = 0;
    goto LABEL_6;
  }
  unint64_t v11 = atomic_load((unint64_t *)a1 + 4);
  unint64_t v12 = a1[23];
  if (v11 > v12)
  {
    unsigned int v8 = "Invalid container offset";
    __int16 v9 = 221;
    goto LABEL_5;
  }
  unint64_t v16 = atomic_load((unint64_t *)a1 + 4);
  unint64_t v17 = v12 - v16;
  if (v12 == v16)
  {
    uint64_t v14 = 0;
    int v13 = 1;
    goto LABEL_6;
  }
  uint64_t v14 = (char *)malloc(0x100000uLL);
  if (!v14)
  {
    unsigned int v29 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", 227, 30, *v29, "malloc", v30, v31, v37);
    int v13 = 0;
    goto LABEL_6;
  }
  int v57 = 0;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long __s = 0u;
  long long v42 = 0u;
  int v40 = 0;
  memset(v39, 0, sizeof(v39));
  if (a1[49]
    && (*(_DWORD *)((char *)v39 + 7) = 1262571615,
        *(void *)&v39[0] = 0x5F41454100000007,
        memset_s((void *)((unint64_t)v39 | 0xB), 0xF9uLL, 0, 0xF9uLL),
        (uint64_t v18 = (uint64_t (*)(long long *, void))a1[36]) != 0)
    && *((_DWORD *)a1 + 197)
    && (v18(&__s, *((unsigned int *)a1 + 54)) & 0x80000000) == 0)
  {
    uint64_t v19 = ((uint64_t (*)(long long *))a1[49])(&__s);
  }
  else
  {
    uint64_t v19 = 0;
  }
  memset_s(&__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v39, 0x104uLL, 0, 0x104uLL);
  if (v19)
  {
    uint64_t v38 = v19;
    int v13 = 1;
    while (1)
    {
      unint64_t v22 = v17 >= 0x100000 ? 0x100000 : v17;
      uint64_t v23 = *a1;
      if (!*(void *)(*a1 + 16)) {
        break;
      }
      uint64_t v24 = 0;
      size_t v25 = v14;
      unint64_t v26 = v22;
      while (1)
      {
        uint64_t v27 = (*(uint64_t (**)(void, char *, unint64_t))(v23 + 16))(*(void *)v23, v25, v26);
        if (v27 < 0) {
          break;
        }
        if (v27)
        {
          v25 += v27;
          v24 += v27;
          v26 -= v27;
          if (v26) {
            continue;
          }
        }
        goto LABEL_30;
      }
      uint64_t v24 = v27;
LABEL_30:
      if (v24 != v22) {
        break;
      }
      uint64_t v28 = (uint64_t (*)(uint64_t, char *, unint64_t))a1[50];
      if (!v28 || (v28(v38, v14, v22) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", 240, 30, 0, "authenticating padding", v20, v21, v37);
        int v13 = 0;
      }
      atomic_fetch_add(a1 + 4, v22);
      v17 -= v22;
      if (!v17) {
        goto LABEL_38;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", 239, 30, 0, "reading padding", v20, v21, v37);
    int v13 = 0;
LABEL_38:
    int v57 = 0;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long __s = 0u;
    long long v42 = 0u;
    uint64_t v32 = (uint64_t (*)(uint64_t, long long *))a1[51];
    if (v32)
    {
      if (*((_DWORD *)a1 + 132) == *((_DWORD *)a1 + 57)
        && (v32(v38, &__s) & 0x80000000) == 0
        && __s == *((_DWORD *)a1 + 57))
      {
        if (__s < 8) {
          goto LABEL_50;
        }
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        do
        {
          v34 |= *(void *)((char *)&__s + v33 * 8 + 4) ^ *(uint64_t *)((char *)&a1[v33 + 66] + 4);
          unint64_t v35 = v33 * 8 + 16;
          ++v33;
        }
        while (v35 <= __s);
        if (!v34)
        {
LABEL_50:
          memset_s(&__s, 0x104uLL, 0, 0x104uLL);
          goto LABEL_49;
        }
      }
    }
    memset_s(&__s, 0x104uLL, 0, 0x104uLL);
    __int16 v36 = 245;
  }
  else
  {
    __int16 v36 = 230;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEASequentialDecryptionStream.c", (uint64_t)"aeaInputStreamAuthenticatePadding", v36, 30, 0, "authenticating padding", v20, v21, v37);
  int v13 = 0;
LABEL_49:
  memset_s(v14, 0x100000uLL, 0, 0x100000uLL);
LABEL_6:
  free(v14);
  if (v13) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sharedBufferWriteToDrain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

void *aaCacheStreamOpen(AAByteStream_impl *a1, unint64_t a2, int a3, int a4, unint64_t a5)
{
  uint64_t v10 = calloc(1uLL, 0x68uLL);
  unint64_t v11 = calloc(1uLL, 0x70uLL);
  uint64_t v14 = (uint64_t)v11;
  if (!v11 || !v10)
  {
    int v18 = *__error();
    unint64_t v16 = "aaCalloc";
    __int16 v17 = 472;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamOpen", v17, 146, v18, v16, v12, v13, v35);
    free(v10);
    aaCacheStreamClose(v14, v27, v28, v29, v30, v31, v32, v33);
    return 0;
  }
  *(void *)unint64_t v11 = a1;
  v11[26] = a4;
  v11[27] = a5 >> 62;
  uint64_t v15 = ((1 << a3) - 1);
  v11[23] = 1 << a3;
  v11[24] = v15;
  v11[21] = (v15 | a2) >> a3;
  v11[22] = a3;
  if (a2 - 1073741825 <= 0xFFFFFFFFBFFFFFFFLL)
  {
    unint64_t v16 = "cache too big";
    __int16 v17 = 484;
LABEL_17:
    int v18 = 0;
    goto LABEL_18;
  }
  off_t v19 = AAByteStreamSeek(a1, 0, 2);
  *(void *)(v14 + 24) = v19;
  *(void *)(v14 + 32) = v19;
  if (v19 < 0)
  {
    unint64_t v16 = "AAByteStreamSeek";
    __int16 v17 = 488;
    goto LABEL_17;
  }
  size_t v20 = *(unsigned int *)(v14 + 84);
  if (v20 >= 0xCCCCCCCD)
  {
    *__error() = 12;
    *(void *)(v14 + 72) = 0;
LABEL_16:
    unint64_t v16 = "aaCalloc";
    __int16 v17 = 492;
    goto LABEL_17;
  }
  uint64_t v21 = calloc(v20, 0x28uLL);
  *(void *)(v14 + 72) = v21;
  if (!v21) {
    goto LABEL_16;
  }
  if (*(_DWORD *)(v14 + 84))
  {
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    size_t v24 = *(unsigned int *)(v14 + 92);
    while (1)
    {
      size_t v25 = calloc(1uLL, v24);
      uint64_t v26 = *(void *)(v14 + 72) + v22;
      *(void *)(v26 + 16) = v25;
      if (!v25) {
        break;
      }
      bzero(v25, *(unsigned int *)(v14 + 92));
      *(void *)uint64_t v26 = -1;
      size_t v24 = *(unsigned int *)(v14 + 92);
      *(_DWORD *)(v26 + 28) = 0;
      *(_DWORD *)(v26 + 32) = 0;
      *(_DWORD *)(v26 + 24) = v24;
      ++v23;
      v22 += 40;
      if (v23 >= *(unsigned int *)(v14 + 84)) {
        goto LABEL_15;
      }
    }
    unint64_t v16 = "aaCalloc";
    __int16 v17 = 498;
    goto LABEL_17;
  }
LABEL_15:
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetSeekProc((AAByteStream)v10, (AAByteStreamSeekProc)aaCacheStreamSeek);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)aaCacheStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)aaCacheStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v10, (AAByteStreamReadProc)aaCacheStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v10, (AAByteStreamWriteProc)aaCacheStreamWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)aaCacheStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)aaCacheStreamClose);
  v10[8] = aaCacheStreamTruncate;
  return v10;
}

uint64_t aaCacheStreamSeek(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1;
  }
  if (a3)
  {
    if (a3 == 2)
    {
      unsigned int v8 = (void *)(a1 + 24);
    }
    else
    {
      if (a3 != 1)
      {
LABEL_10:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamSeek", 392, 146, 0, "bad seek", a7, a8, vars0);
        return -1;
      }
      unsigned int v8 = (void *)(a1 + 16);
    }
    a2 += *v8;
  }
  if (a2 < 0) {
    goto LABEL_10;
  }
  *(void *)(a1 + 16) = a2;
  return a2;
}

uint64_t aaCacheStreamPRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1;
  }
  uint64_t v9 = a4;
  uint64_t v11 = *(void *)(a1 + 24);
  BOOL v12 = v11 <= a4;
  int64_t v13 = v11 - a4;
  if (v12) {
    return 0;
  }
  if (v13 >= a3) {
    unint64_t v14 = a3;
  }
  else {
    unint64_t v14 = v13;
  }
  if (v14)
  {
    uint64_t v8 = 0;
    while (1)
    {
      unint64_t v16 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v9 & v16) >= v14) {
        size_t v17 = v14;
      }
      else {
        size_t v17 = *(unsigned int *)(a1 + 92) - (v9 & v16);
      }
      int v18 = cachePageGet(a1, v9 & ~v16, a3, a4, a5, a6, a7, a8);
      if (!v18)
      {
        uint64_t v29 = "cachePageGet";
        __int16 v30 = 224;
        goto LABEL_25;
      }
      size_t v25 = v18;
      uint64_t v26 = v16 & v9;
      if ((v26 < *((_DWORD *)v18 + 6) || (v26 + v17) > *((_DWORD *)v18 + 7))
        && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v18, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        break;
      }
      memcpy(a2, (const void *)(*((void *)v25 + 2) + v26), v17);
      ++*(void *)(a1 + 40);
      uint64_t v27 = *(void *)(a1 + 8) + 1;
      *(void *)(a1 + 8) = v27;
      *((void *)v25 + 1) = v27;
      if ((v17 & 0x8000000000000000) != 0) {
        goto LABEL_26;
      }
      v8 += v17;
      a2 += v17;
      v9 += v17;
      v14 -= v17;
      if (!v14) {
        goto LABEL_21;
      }
    }
    uint64_t v29 = "cachePageReadFromDisk";
    __int16 v30 = 229;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheRead", v30, 146, 0, v29, v23, v24, v31);
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPRead", 313, 146, 0, "cacheRead", a7, a8, v31);
    return -1;
  }
  uint64_t v8 = 0;
LABEL_21:
  *(void *)(a1 + 16) = v9;
  return v8;
}

uint64_t aaCacheStreamPWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return -1;
  }
  uint64_t v8 = a4;
  unint64_t v9 = a3;
  if (a3)
  {
    uint64_t v12 = 0;
    while (1)
    {
      unint64_t v13 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v8 & v13) >= v9) {
        size_t v14 = v9;
      }
      else {
        size_t v14 = *(unsigned int *)(a1 + 92) - (v8 & v13);
      }
      uint64_t v15 = cachePageGet(a1, v8 & ~v13, a3, a4, a5, a6, a7, a8);
      if (!v15)
      {
        __int16 v30 = "cachePageGet";
        __int16 v31 = 254;
        goto LABEL_28;
      }
      uint64_t v22 = v15;
      uint64_t v23 = v13 & v8;
      unsigned int v24 = v23 + v14;
      unsigned int v25 = *((_DWORD *)v15 + 6);
      unsigned int v26 = *((_DWORD *)v15 + 7);
      if (v25 < v26)
      {
        BOOL v27 = v24 < v25 || v23 > v26;
        if (v27
          && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v15, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
        {
          break;
        }
      }
      memcpy((void *)(*((void *)v22 + 2) + v23), a2, v14);
      ++*(void *)(a1 + 48);
      if (v23 < *((_DWORD *)v22 + 6)) {
        *((_DWORD *)v22 + 6) = v23;
      }
      if (v24 > *((_DWORD *)v22 + 7)) {
        *((_DWORD *)v22 + 7) = v24;
      }
      uint64_t v28 = *(void *)(a1 + 8) + 1;
      *(void *)(a1 + 8) = v28;
      *((void *)v22 + 1) = v28;
      *((_DWORD *)v22 + 8) = 1;
      uint64_t v29 = v8 + (int)v14;
      if (*(void *)(a1 + 24) < v29) {
        *(void *)(a1 + 24) = v29;
      }
      if ((v14 & 0x8000000000000000) != 0) {
        goto LABEL_29;
      }
      v12 += v14;
      a2 += v14;
      v8 += v14;
      v9 -= v14;
      if (!v9) {
        goto LABEL_25;
      }
    }
    __int16 v30 = "cachePageReadFromDisk";
    __int16 v31 = 262;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheWrite", v31, 146, 0, v30, v20, v21, v33);
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPWrite", 346, 146, 0, "cacheWrite", a7, a8, v33);
    return -1;
  }
  uint64_t v12 = 0;
LABEL_25:
  *(void *)(a1 + 16) = v8;
  return v12;
}

uint64_t aaCacheStreamRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPRead(a1, a2, a3, *(void *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPWrite(a1, a2, a3, *(void *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamCancel(uint64_t result)
{
  *(_DWORD *)(result + 100) = 1;
  return result;
}

uint64_t aaCacheStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    if (*(void *)(result + 72))
    {
      if ((cacheFlush(result, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 440, 146, 0, "cacheFlush", v9, v10, v16);
        int v11 = 0;
      }
      else
      {
        int v11 = 1;
      }
      if (*(_DWORD *)(v8 + 84))
      {
        unint64_t v12 = 0;
        uint64_t v13 = 16;
        do
        {
          free(*(void **)(*(void *)(v8 + 72) + v13));
          ++v12;
          v13 += 40;
        }
        while (v12 < *(unsigned int *)(v8 + 84));
      }
      free(*(void **)(v8 + 72));
    }
    else
    {
      int v11 = 1;
    }
    if (*(_DWORD *)(v8 + 104) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 446, 146, 0, "AAByteStreamClose", v14, v15, v16);
      int v11 = 0;
    }
    if (*(int *)(v8 + 108) >= 1) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "CacheStream: read ops %zu/%zu, write ops %zu/%zu\n", *(void *)(v8 + 56), *(void *)(v8 + 40), *(void *)(v8 + 64), *(void *)(v8 + 48));
    }
    free((void *)v8);
    if (v11) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t aaCacheStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 100))
  {
    if ((cacheFlush(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      uint64_t v13 = "cacheFlush";
      __int16 v14 = 411;
    }
    else
    {
      if ((AAByteStreamTruncate(*(void **)a1) & 0x80000000) == 0)
      {
        uint64_t result = 0;
        *(void *)(a1 + 24) = a2;
        *(void *)(a1 + 32) = a2;
        return result;
      }
      uint64_t v13 = "AAByteStreamTruncate";
      __int16 v14 = 412;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamTruncate", v14, 146, 0, v13, v10, v11, v15);
  }
  return 0xFFFFFFFFLL;
}

long long *cachePageGet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 72);
  unsigned int v9 = *(_DWORD *)(a1 + 84) - 1;
  unsigned int v10 = v9 & ((unint64_t)(0x16069317E428CA9 * a2) >> 32);
  uint64_t v11 = (long long *)(v8 + 40 * v10);
  if (*(void *)v11 != a2)
  {
    unsigned int v14 = v10 & 0xFFFFFC00;
    unsigned int v15 = v10 | 0x3FF;
    if ((v10 | 0x3FF) >= v9) {
      unsigned int v15 = *(_DWORD *)(a1 + 84) - 1;
    }
    if (v14 <= v15)
    {
      unsigned int v16 = v10 & 0xFFFFFC00;
      while (*(void *)(v8 + 40 * v14) != a2)
      {
        if (*(void *)(v8 + 40 * v14 + 8) < *(void *)(v8 + 40 * v16 + 8)) {
          unsigned int v16 = v14;
        }
        if (++v14 > v15) {
          goto LABEL_11;
        }
      }
    }
    unsigned int v16 = v14;
LABEL_11:
    uint64_t v17 = *((void *)v11 + 4);
    long long v19 = *v11;
    long long v18 = v11[1];
    uint64_t v20 = (long long *)(v8 + 40 * v16);
    uint64_t v21 = *((void *)v20 + 4);
    long long v22 = v20[1];
    *uint64_t v11 = *v20;
    v11[1] = v22;
    *((void *)v11 + 4) = v21;
    uint64_t v23 = *(void *)(a1 + 72) + 40 * v16;
    *(_OWORD *)uint64_t v23 = v19;
    *(_OWORD *)(v23 + 16) = v18;
    *(void *)(v23 + 32) = v17;
    if (*(void *)v11 != a2)
    {
      if ((cachePageEvict((uint64_t *)a1, v8 + 40 * v10, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageGet", 162, 146, 0, "cachePageEvict", v24, v25, v29);
        return 0;
      }
      else
      {
        uint64_t v26 = v8 + 40 * v10;
        bzero(*(void **)(v26 + 16), *(unsigned int *)(a1 + 92));
        int v27 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)(v26 + 28) = 0;
        *(_DWORD *)(v26 + 32) = 0;
        *(_DWORD *)(v26 + 24) = v27;
        *(void *)uint64_t v11 = a2;
      }
    }
  }
  return v11;
}

uint64_t cachePageReadFromDisk(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *((unsigned int *)a2 + 6);
  unsigned int v10 = *((_DWORD *)a2 + 7);
  if (v10 >= v11) {
    size_t v12 = v10 - v11;
  }
  else {
    size_t v12 = 0;
  }
  int v13 = *((_DWORD *)a2 + 8);
  if (v10 <= v11 || v13 == 0)
  {
    unsigned int v15 = 0;
  }
  else
  {
    unsigned int v16 = malloc(v12);
    unsigned int v15 = v16;
    if (!v16)
    {
      uint64_t v24 = "aaMalloc";
      __int16 v25 = 184;
LABEL_33:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageReadFromDisk", v25, 146, 0, v24, a7, a8, v30);
      uint64_t v27 = 0xFFFFFFFFLL;
      goto LABEL_34;
    }
    memcpy(v16, (const void *)(a2[2] + v11), v12);
  }
  uint64_t v17 = *a2;
  if (a1[4] - *a2 >= *((unsigned int *)a1 + 23)) {
    uint64_t v18 = *((unsigned int *)a1 + 23);
  }
  else {
    uint64_t v18 = a1[4] - *a2;
  }
  if (v18 < 1) {
    goto LABEL_26;
  }
  uint64_t v19 = *a1;
  if (!*(void *)(*a1 + 32)) {
    goto LABEL_32;
  }
  unsigned int v31 = v10;
  size_t v32 = v12;
  uint64_t v20 = 0;
  uint64_t v21 = a2[2];
  uint64_t v22 = v18;
  while (1)
  {
    uint64_t v23 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v19 + 32))(*(void *)v19, v21, v22, v17);
    if (v23 < 0) {
      break;
    }
    if (v23)
    {
      v21 += v23;
      v20 += v23;
      v17 += v23;
      v22 -= v23;
      if (v22) {
        continue;
      }
    }
    goto LABEL_24;
  }
  uint64_t v20 = v23;
LABEL_24:
  size_t v12 = v32;
  unsigned int v10 = v31;
  if (v18 != v20)
  {
LABEL_32:
    uint64_t v24 = "AAByteStreamPRead";
    __int16 v25 = 193;
    goto LABEL_33;
  }
  ++a1[7];
  int v13 = *((_DWORD *)a2 + 8);
LABEL_26:
  if (v10 > v11 && v13 != 0) {
    memcpy((void *)(a2[2] + *((unsigned int *)a2 + 6)), v15, v12);
  }
  uint64_t v27 = 0;
  int v28 = *((_DWORD *)a1 + 23);
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 7) = v28;
LABEL_34:
  free(v15);
  return v27;
}

uint64_t cachePageEvict(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 25)) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a2 + 32)) {
    return 0;
  }
  uint64_t v9 = *(unsigned int *)(a2 + 24);
  unsigned int v10 = *(_DWORD *)(a2 + 28);
  if (v10 <= v9) {
    return 0;
  }
  uint64_t v12 = *(void *)a2 + v9;
  uint64_t v13 = v10 - v9;
  if (v13 >= a1[3] - v12) {
    uint64_t v14 = a1[3] - v12;
  }
  else {
    uint64_t v14 = v13;
  }
  if (v14 <= 0)
  {
    uint64_t v21 = "bad page";
    __int16 v22 = 87;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageEvict", v22, 146, 0, v21, a7, a8, v23);
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = *a1;
  if (!*(void *)(*a1 + 40)) {
    goto LABEL_20;
  }
  uint64_t v16 = 0;
  uint64_t v17 = *(void *)(a2 + 16) + v9;
  uint64_t v18 = *(void *)a2 + v9;
  uint64_t v19 = v14;
  while (1)
  {
    uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v15 + 40))(*(void *)v15, v17, v19, v18);
    if (v20 < 1) {
      break;
    }
    v17 += v20;
    v16 += v20;
    v18 += v20;
    v19 -= v20;
    if (!v19) {
      goto LABEL_16;
    }
  }
  uint64_t v16 = v20;
LABEL_16:
  if (v14 != v16)
  {
LABEL_20:
    uint64_t v21 = "aaByteStreamPWriteExpected";
    __int16 v22 = 90;
    goto LABEL_21;
  }
  ++a1[8];
  if (a1[4] < v14 + v12)
  {
    uint64_t result = 0;
    a1[4] = v14 + v12;
    return result;
  }
  return 0;
}

uint64_t cacheFlush(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 100)) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 84))
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    while ((cachePageEvict((uint64_t *)a1, *(void *)(a1 + 72) + v10, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 72) + v10;
      bzero(*(void **)(v14 + 16), *(unsigned int *)(a1 + 92));
      *(void *)uint64_t v14 = -1;
      int v15 = *(_DWORD *)(a1 + 92);
      *(_DWORD *)(v14 + 28) = 0;
      *(_DWORD *)(v14 + 32) = 0;
      *(_DWORD *)(v14 + 24) = v15;
      ++v11;
      v10 += 40;
      if (v11 >= *(unsigned int *)(a1 + 84)) {
        return 0;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheFlush", 115, 146, 0, "cachePageEvict", v12, v13, v16);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t aeaOutputStreamRunThreads(uint64_t a1)
{
  size_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(v3 + 24);
  size_t v5 = *(unsigned int *)(v3 + 16);
  if (v4)
  {
    compression_algorithm v6 = aeaEffectiveCompressionAlgorithm(v4);
    size_t v7 = compression_encode_scratch_buffer_size(v6);
  }
  else
  {
    size_t v7 = 0;
  }
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = v2;
  uint64_t v8 = calloc(v2, 4uLL);
  *(void *)(a1 + 72) = v8;
  if (!v8)
  {
    uint64_t v12 = "SharedArrayInit: malloc failed\n";
    __int16 v13 = 55;
    goto LABEL_10;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 80), 0))
  {
    uint64_t v12 = "SharedArrayInit: pthread_mutex_init failed\n";
    __int16 v13 = 56;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v13, 0, v12, v9, v10, v11, v40);
    char v16 = "SharedArrayInit";
    __int16 v17 = 323;
LABEL_11:
    int v18 = 0;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamRunThreads", v17, 41, v18, v16, v14, v15, v40);
    return 0xFFFFFFFFLL;
  }
  if (pthread_cond_init((pthread_cond_t *)(a1 + 144), 0))
  {
    uint64_t v12 = "SharedArrayInit: pthread_cond_init failed\n";
    __int16 v13 = 57;
    goto LABEL_10;
  }
  size_t v20 = (v2 + 1);
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = v20;
  uint64_t v21 = calloc(v20, 4uLL);
  *(void *)(a1 + 200) = v21;
  if (!v21)
  {
    __int16 v25 = "SharedArrayInit: malloc failed\n";
    __int16 v26 = 55;
    goto LABEL_19;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(a1 + 208), 0))
  {
    __int16 v25 = "SharedArrayInit: pthread_mutex_init failed\n";
    __int16 v26 = 56;
LABEL_19:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v26, 0, v25, v22, v23, v24, v40);
    char v16 = "SharedArrayInit";
    __int16 v17 = 324;
    goto LABEL_11;
  }
  if (pthread_cond_init((pthread_cond_t *)(a1 + 272), 0))
  {
    __int16 v25 = "SharedArrayInit: pthread_cond_init failed\n";
    __int16 v26 = 57;
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 56) = -1;
  if (v2 >= 0x89AE409)
  {
    *__error() = 12;
    *(void *)(a1 + 48) = 0;
LABEL_50:
    int v18 = *__error();
    char v16 = "malloc";
    __int16 v17 = 329;
    goto LABEL_12;
  }
  uint64_t v27 = calloc(v2, 0x3B8uLL);
  *(void *)(a1 + 48) = v27;
  if (!v27) {
    goto LABEL_50;
  }
  if (v2)
  {
    uint64_t v28 = 0;
    int v29 = 0;
    uint64_t v30 = 952 * v2;
    while (1)
    {
      uint64_t v31 = *(void *)(a1 + 48);
      uint64_t v32 = v31 + v28;
      *(_DWORD *)(v31 + v28 + 592) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v31 + v28 + 600), 0)
        || pthread_cond_init((pthread_cond_t *)(v32 + 664), 0)
        || (*(_DWORD *)(v31 + v28 + 712) = 0, pthread_mutex_init((pthread_mutex_t *)(v31 + v28 + 720), 0))
        || pthread_cond_init((pthread_cond_t *)(v31 + v28 + 784), 0)
        || (*(_DWORD *)(v31 + v28 + 832) = 0, pthread_mutex_init((pthread_mutex_t *)(v31 + v28 + 840), 0))
        || pthread_cond_init((pthread_cond_t *)(v31 + v28 + 904), 0))
      {
        char v16 = "SemInit";
        __int16 v17 = 333;
        goto LABEL_11;
      }
      uint64_t v33 = v31 + v28;
      *(_DWORD *)(v33 + 8) = v29;
      *(void *)(v33 + 16) = a1;
      uint64_t v34 = malloc(v5);
      *(void *)(v33 + 32) = v34;
      *(void *)(v33 + 40) = malloc(v5);
      if (v7)
      {
        if (v7 < 0x2000000001)
        {
          __int16 v36 = malloc(v7);
        }
        else
        {
          char v35 = __error();
          __int16 v36 = 0;
          *char v35 = 12;
          uint64_t v34 = *(void **)(v33 + 32);
        }
      }
      else
      {
        __int16 v36 = 0;
      }
      *(void *)(v33 + 24) = v36;
      if (!v34 || (v7 ? (BOOL v37 = v36 == 0) : (BOOL v37 = 0), !v37 ? (v38 = 0) : (v38 = 1), !*(void *)(v33 + 40) || v38))
      {
        int v18 = *__error();
        char v16 = "malloc";
        __int16 v17 = 339;
        goto LABEL_12;
      }
      if ((createThread((pthread_t *)v32, (uint64_t)aeaOutputStreamWorkerThreadProc, v32, 0) & 0x80000000) != 0) {
        break;
      }
      ++v29;
      v28 += 952;
      if (v30 == v28) {
        goto LABEL_47;
      }
    }
    char v16 = "Thread creation";
    __int16 v17 = 340;
    goto LABEL_11;
  }
LABEL_47:
  uint64_t v39 = (pthread_t *)calloc(1uLL, 0x10uLL);
  *(void *)(a1 + 320) = v39;
  if (!v39)
  {
    int v18 = *__error();
    char v16 = "malloc";
    __int16 v17 = 345;
    goto LABEL_12;
  }
  v39[1] = (pthread_t)a1;
  if ((createThread(v39, (uint64_t)aeaOutputStreamWriterThreadProc, (uint64_t)v39, 0) & 0x80000000) != 0)
  {
    char v16 = "Thread creation";
    __int16 v17 = 347;
    goto LABEL_11;
  }
  return 0;
}

uint64_t aeaOutputStreamWorkerThreadProc(uint64_t a1)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(v2 + 24);
  dst_uint64_t size = *(unsigned int *)(v3 + 16);
  unsigned int v56 = *(_DWORD *)(v3 + 24);
  int v61 = *(_DWORD *)(a1 + 8);
  uint64_t v4 = (pthread_mutex_t *)(a1 + 600);
  int v65 = 0;
  size_t v5 = (pthread_cond_t *)(a1 + 664);
  uint64_t v62 = (unsigned int *)(a1 + 48);
  uint64_t v63 = (pthread_mutex_t *)(v2 + 80);
  long long v55 = (_DWORD *)(v3 + 668);
  uint64_t v53 = a1 + 332;
  uint64_t v58 = (pthread_mutex_t *)(a1 + 720);
  uint64_t v59 = a1 + 72;
  long long v54 = (pthread_cond_t *)(a1 + 784);
  compression_algorithm v6 = (pthread_mutex_t *)(a1 + 840);
  size_t v7 = (pthread_cond_t *)(a1 + 904);
  uint64_t v8 = (char *)v68 + 8;
  int v60 = 1;
  memset(v64, 0, sizeof(v64));
  while (1)
  {
    if (pthread_mutex_lock(v63))
    {
      long long v46 = "SharedArrayPush: pthread_mutex_lock failed\n";
      __int16 v47 = 117;
      goto LABEL_72;
    }
    uint64_t v12 = *(unsigned int *)(v2 + 64);
    unsigned int v13 = *(_DWORD *)(v2 + 68);
    int v14 = v12;
    if (v12 < v13)
    {
      *(_DWORD *)(*(void *)(v2 + 72) + 4 * v12) = v61;
      int v14 = *(_DWORD *)(v2 + 64);
    }
    *(_DWORD *)(v2 + 64) = v14 + 1;
    if (!v14 && pthread_cond_broadcast((pthread_cond_t *)(v2 + 144)))
    {
      long long v46 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      __int16 v47 = 122;
      goto LABEL_72;
    }
    if (pthread_mutex_unlock(v63))
    {
      long long v46 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      __int16 v47 = 124;
LABEL_72:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v47, 0, v46, v9, v10, v11, v48);
      long long v44 = "SharedArrayPush";
      __int16 v45 = 76;
      goto LABEL_62;
    }
    if (v12 >= v13)
    {
      long long v46 = "SharedArrayPush: stack is full\n";
      __int16 v47 = 125;
      goto LABEL_72;
    }
    if (pthread_mutex_lock(v4)) {
      goto LABEL_61;
    }
    while (1)
    {
      int v17 = *(_DWORD *)(a1 + 592);
      if (v17 > 0) {
        break;
      }
      if (pthread_cond_wait(v5, v4)) {
        goto LABEL_61;
      }
    }
    *(_DWORD *)(a1 + 592) = v17 - 1;
    if (pthread_mutex_unlock(v4))
    {
LABEL_61:
      long long v44 = "SemAcquire";
      __int16 v45 = 77;
      goto LABEL_62;
    }
    if (*v62 == -1)
    {
      if (!v60) {
LABEL_63:
      }
        atomic_fetch_add((atomic_uint *volatile)(v2 + 40), 1u);
      return a1;
    }
    if ((aeaChecksum(v59, *(_DWORD *)(v3 + 12), *(void **)(a1 + 32), *(unsigned int *)(a1 + 52), v18, v19, v15, v16) & 0x80000000) != 0)
    {
      __int16 v23 = 83;
      uint64_t v24 = "Segment checksum failed";
      goto LABEL_50;
    }
    *(_DWORD *)(a1 + 56) = 0;
    if (v56 != 774)
    {
      if (!v56)
      {
        size_t v22 = *(unsigned int *)(a1 + 52);
LABEL_26:
        memcpy(*(void **)(a1 + 40), *(const void **)(a1 + 32), v22);
        size_t v26 = *(unsigned int *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v26;
        goto LABEL_27;
      }
      compression_algorithm v27 = aeaEffectiveCompressionAlgorithm(v56);
      LODWORD(v25) = compression_encode_buffer(*(uint8_t **)(a1 + 40), dst_size, *(const uint8_t **)(a1 + 32), *(unsigned int *)(a1 + 52), *(void **)(a1 + 24), v27);
LABEL_23:
      size_t v26 = v25;
      *(_DWORD *)(a1 + 56) = v25;
      goto LABEL_24;
    }
    int64_t v25 = PCompressLZMA6Encode(*(uint8_t **)(a1 + 40), dst_size, *(const uint8_t **)(a1 + 32), *(unsigned int *)(a1 + 52));
    if (v25 >= 1) {
      goto LABEL_23;
    }
    size_t v26 = *(unsigned int *)(a1 + 56);
LABEL_24:
    size_t v22 = *(unsigned int *)(a1 + 52);
    if (!v26 || v26 >= v22) {
      goto LABEL_26;
    }
LABEL_27:
    uint64_t v28 = *(void **)(a1 + 32);
    if (v28)
    {
      memset_s(v28, dst_size, 0, dst_size);
      size_t v26 = *(unsigned int *)(a1 + 56);
    }
    if (!v26)
    {
      __int16 v23 = 107;
      uint64_t v24 = "Segment compression failed";
      goto LABEL_50;
    }
    long long v52 = v8;
    size_t v49 = v26;
    unsigned int v29 = *v62;
    unsigned int v30 = *(_DWORD *)(v3 + 20);
    int v67 = 0;
    memset(v66, 0, sizeof(v66));
    memset((char *)__s + 8, 0, 252);
    int v69 = 0;
    memset(v68, 0, sizeof(v68));
    WORD4(__s[0]) = 19267;
    *(void *)&__s[0] = 0x5F41454100000006;
    uint64_t result = memset_s((char *)__s + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v32 = LODWORD(__s[0]);
    if (LODWORD(__s[0]) >= 0xFD) {
      break;
    }
    int v50 = v29 / v30;
    unsigned int v51 = v29;
    *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v29 / v30;
    LODWORD(__s[0]) = v32 + 4;
    memset_s((char *)__s + v32 + 8, 252 - v32, 0, 252 - v32);
    uint64_t v33 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, _OWORD *))(v3 + 144);
    if (v33 && *v55)
    {
      int v34 = v33(v66, *(unsigned int *)(v3 + 72), v55, __s, v68);
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      int v35 = 0;
      if ((v34 & 0x80000000) == 0) {
        goto LABEL_37;
      }
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    int v35 = 1;
LABEL_37:
    *(_OWORD *)((char *)v52 + 236) = 0u;
    v52[13] = 0u;
    v52[14] = 0u;
    v52[11] = 0u;
    v52[12] = 0u;
    v52[9] = 0u;
    v52[10] = 0u;
    v52[7] = 0u;
    v52[8] = 0u;
    v52[5] = 0u;
    v52[6] = 0u;
    v52[3] = 0u;
    _OWORD v52[4] = 0u;
    v52[1] = 0u;
    v52[2] = 0u;
    *long long v52 = 0u;
    WORD4(v68[0]) = 19283;
    *(void *)&v68[0] = 0x5F41454100000006;
    uint64_t result = memset_s((char *)v68 + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v36 = LODWORD(v68[0]);
    if (LODWORD(v68[0]) >= 0xFD) {
      break;
    }
    *(_DWORD *)((char *)v68 + LODWORD(v68[0]) + 4) = v51 - v50 * v30;
    LODWORD(v68[0]) = v36 + 4;
    memset_s((char *)v68 + v36 + 8, 252 - v36, 0, 252 - v36);
    memset(__s, 0, 260);
    BOOL v37 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, _OWORD *))(v3 + 144);
    if (!v37 || !LODWORD(v66[0]))
    {
      memset_s(v68, 0x104uLL, 0, 0x104uLL);
      uint64_t v8 = (char *)v52;
LABEL_48:
      memset_s(v66, 0x104uLL, 0, 0x104uLL);
LABEL_49:
      __int16 v23 = 119;
      uint64_t v24 = "Segment key derivation failed";
      goto LABEL_50;
    }
    int v38 = v35;
    int v39 = v37(v64, *(unsigned int *)(v3 + 76), v66, v68, __s);
    memset_s(v68, 0x104uLL, 0, 0x104uLL);
    uint64_t v8 = (char *)v52;
    if (v39 < 0) {
      goto LABEL_48;
    }
    memset_s(v66, 0x104uLL, 0, 0x104uLL);
    if (v38) {
      goto LABEL_49;
    }
    char v40 = *(uint64_t (**)(void, size_t, uint64_t, _OWORD *, void, void))(v3 + 160);
    if (v40)
    {
      int v41 = v40(*(void *)(a1 + 40), v49, v53, v64, 0, 0);
      if (*(_DWORD *)(a1 + 332) == *(_DWORD *)(v3 + 84) && (v41 & 0x80000000) == 0) {
        goto LABEL_51;
      }
    }
    __int16 v23 = 120;
    uint64_t v24 = "Segment encryption failed";
LABEL_50:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWorkerThreadProc", v23, 41, 0, v24, v20, v21, v48);
    memset_s(v62, 0x220uLL, 0, 0x220uLL);
    int v60 = 0;
    unsigned int *v62 = -1;
LABEL_51:
    memset_s(v64, 0x104uLL, 0, 0x104uLL);
    if (pthread_mutex_lock(v58)
      || (int v42 = *(_DWORD *)(a1 + 712), *(_DWORD *)(a1 + 712) = v42 + 1, !v42) && pthread_cond_broadcast(v54)
      || pthread_mutex_unlock(v58))
    {
      long long v44 = "SemRelease";
      __int16 v45 = 133;
LABEL_62:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWorkerThreadProc", v45, 41, 0, v44, v15, v16, v48);
      goto LABEL_63;
    }
    if (!pthread_mutex_lock(v6))
    {
      while (1)
      {
        int v43 = *(_DWORD *)(a1 + 832);
        if (v43 > 0) {
          break;
        }
        if (pthread_cond_wait(v7, v6)) {
          goto LABEL_60;
        }
      }
      *(_DWORD *)(a1 + 832) = v43 - 1;
      if (!pthread_mutex_unlock(v6)) {
        continue;
      }
    }
LABEL_60:
    long long v44 = "SemAcquire";
    __int16 v45 = 135;
    goto LABEL_62;
  }
  __break(1u);
  return result;
}

uint64_t aeaOutputStreamWriterThreadProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  rsize_t v3 = *(unsigned int *)(*(void *)(v2 + 24) + 16);
  int v4 = 1;
  while (1)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 208)))
    {
      compression_algorithm v27 = "SharedArrayPop: pthread_mutex_lock failed\n";
      __int16 v28 = 91;
      goto LABEL_24;
    }
    while (1)
    {
      int v8 = *(_DWORD *)(v2 + 192);
      if (v8) {
        break;
      }
      if (pthread_cond_wait((pthread_cond_t *)(v2 + 272), (pthread_mutex_t *)(v2 + 208)))
      {
        compression_algorithm v27 = "SharedArrayPop: pthread_cond_wait failed\n";
        __int16 v28 = 94;
        goto LABEL_24;
      }
    }
    unsigned int v9 = v8 - 1;
    *(_DWORD *)(v2 + 192) = v9;
    unsigned int v10 = *(_DWORD *)(*(void *)(v2 + 200) + 4 * v9);
    if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 208)))
    {
      compression_algorithm v27 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      __int16 v28 = 98;
LABEL_24:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v28, 0, v27, v5, v6, v7, v30);
      int64_t v25 = "SharedArrayDequeue";
      __int16 v26 = 151;
LABEL_26:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWriterThreadProc", v26, 41, 0, v25, v6, v7, v30);
LABEL_27:
      atomic_fetch_add((atomic_uint *volatile)(v2 + 40), 1u);
      return a1;
    }
    if (v10 == -1) {
      break;
    }
    if (v10 >= *(_DWORD *)(v2 + 16))
    {
      int64_t v25 = "Invalid worker id";
      __int16 v26 = 155;
      goto LABEL_26;
    }
    int v31 = v4;
    rsize_t v11 = v3;
    uint64_t v12 = *(void *)(v2 + 48);
    uint64_t v13 = v12 + 952 * v10;
    int v14 = (pthread_mutex_t *)(v13 + 720);
    if (pthread_mutex_lock((pthread_mutex_t *)(v13 + 720))) {
      goto LABEL_25;
    }
    uint64_t v15 = (int *)(v13 + 712);
    while (*v15 <= 0)
    {
      if (pthread_cond_wait((pthread_cond_t *)(v12 + 952 * v10 + 784), v14)) {
        goto LABEL_25;
      }
    }
    --*v15;
    if (pthread_mutex_unlock(v14))
    {
LABEL_25:
      int64_t v25 = "SemAcquire";
      __int16 v26 = 159;
      goto LABEL_26;
    }
    uint64_t v18 = v12 + 952 * v10;
    uint64_t v20 = *(void *)(v18 + 40);
    uint64_t v19 = v18 + 40;
    if ((aeaContainerAppendSegment(*(void *)(v2 + 24), *(void *)v2, (void *)(v19 + 8), v20, v16, v17, v6, v7) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWriterThreadProc", 164, 41, 0, "Segment insertion", v21, v22, v30);
      int v31 = 0;
    }
    rsize_t v3 = v11;
    if (*(void *)v19) {
      memset_s(*(void **)v19, v11, 0, v11);
    }
    memset_s((void *)(v19 + 8), 0x220uLL, 0, 0x220uLL);
    int v4 = v31;
    if (pthread_mutex_lock((pthread_mutex_t *)(v12 + 952 * v10 + 840))
      || (v23 = v12 + 952 * v10, int v24 = *(_DWORD *)(v23 + 832), *(_DWORD *)(v23 + 832) = v24 + 1, !v24)
      && pthread_cond_broadcast((pthread_cond_t *)(v12 + 952 * v10 + 904))
      || pthread_mutex_unlock((pthread_mutex_t *)(v12 + 952 * v10 + 840)))
    {
      int64_t v25 = "SemRelease";
      __int16 v26 = 175;
      goto LABEL_26;
    }
  }
  if (!v4) {
    goto LABEL_27;
  }
  return a1;
}

AAByteStream AEAEncryptionOutputStreamOpen(AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  int DefaultNThreads = n_threads;
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (n_threads <= 0) {
    int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((void *)encrypted_stream + 5))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpen", 367, 41, 0, "Invalid encrypted stream", v4, v5, v25);
    uint64_t v12 = 0;
    unsigned int v10 = 0;
LABEL_23:
    free(v10);
    aeaOutputStreamCloseAndUpdateContext(v12, 0);
    return 0;
  }
  unsigned int v10 = calloc(1uLL, 0x68uLL);
  rsize_t v11 = malloc(0x148uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x148uLL, 0, 0x148uLL), !v10))
  {
    int v22 = *__error();
    uint64_t v23 = "malloc";
    __int16 v24 = 372;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpen", v24, 41, v22, v23, v14, v15, v25);
    goto LABEL_23;
  }
  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  *(_DWORD *)(v12 + 16) = DefaultNThreads;
  uint64_t New = aeaContainerCreateNew((uint64_t)context);
  *(void *)(v12 + 24) = New;
  if (!New)
  {
    uint64_t v23 = "Invalid encryption parameters";
    __int16 v24 = 379;
LABEL_21:
    int v22 = 0;
    goto LABEL_22;
  }
  AAByteStream result = (AAByteStream)aeaOutputStreamRunThreads(v12);
  if ((result & 0x80000000) != 0)
  {
    uint64_t v23 = "Running stream threads";
    __int16 v24 = 380;
    goto LABEL_21;
  }
  v10[3] = aeaOutputStreamWrite;
  v10[7] = aeaOutputStreamAbort;
  *unsigned int v10 = v12;
  v10[1] = aeaOutputStreamClose;
  uint64_t v17 = *(void *)(v12 + 24);
  uint64_t v18 = *(unsigned int *)(v17 + 668);
  if (v18 < 0x101)
  {
    memcpy((char *)context + 1376, (const void *)(v17 + 672), *(unsigned int *)(v17 + 668));
    *((_DWORD *)context + 343) = v18;
    memset_s((char *)context + v18 + 1376, 256 - v18, 0, 256 - v18);
    uint64_t v19 = *(void *)(v12 + 24);
    if (*(_DWORD *)v19 <= 5u && ((1 << *(_DWORD *)v19) & 0x2B) != 0) {
      return (AAByteStream)v10;
    }
    memset(v40, 0, sizeof(v40));
    long long v39 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    long long v36 = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    long long v33 = 0u;
    long long v32 = 0u;
    long long v31 = 0u;
    long long v30 = 0u;
    long long v29 = 0u;
    long long v28 = 0u;
    long long v27 = 0u;
    *(_OWORD *)&__s[1] = 0u;
    *(_DWORD *)((char *)__s + 7) = 1262834527;
    __s[0] = 0x5F41454100000007;
    char v25 = 0;
    memset_s((char *)&__s[1] + 3, 0xF9uLL, 0, 0xF9uLL);
    uint64_t v20 = *(uint64_t (**)(char *, void))(v19 + 144);
    if (v20 && *(_DWORD *)(v19 + 668))
    {
      int v21 = v20((char *)context + 1632, *(unsigned int *)(v19 + 72));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      if ((v21 & 0x80000000) == 0) {
        return (AAByteStream)v10;
      }
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    uint64_t v23 = "deriving signature encryption key";
    __int16 v24 = 398;
    goto LABEL_21;
  }
  __break(1u);
  return result;
}

uint64_t aeaOutputStreamWrite(uint64_t a1, char *__src, unint64_t a3)
{
  if (*(_DWORD *)(a1 + 36)) {
    return -1;
  }
  unint64_t v3 = a3;
  if (!a3) {
    return 0;
  }
  uint64_t v6 = 0;
  int v7 = *(_DWORD *)(*(void *)(a1 + 24) + 16);
  int v8 = (pthread_mutex_t *)(a1 + 80);
  unsigned int v9 = (pthread_cond_t *)(a1 + 144);
  while (1)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 56);
    if (v10 != -1)
    {
      uint64_t v11 = *(void *)(a1 + 48) + 952 * v10;
      goto LABEL_13;
    }
    if (pthread_mutex_lock(v8))
    {
      int v22 = "SharedArrayPop: pthread_mutex_lock failed\n";
      __int16 v23 = 91;
LABEL_20:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v23, 0, v22, v12, v13, v14, v27);
      __int16 v24 = "SharedArrayPop failed";
      __int16 v25 = 282;
      goto LABEL_21;
    }
    while (1)
    {
      int v15 = *(_DWORD *)(a1 + 64);
      if (v15) {
        break;
      }
      if (pthread_cond_wait(v9, v8))
      {
        int v22 = "SharedArrayPop: pthread_cond_wait failed\n";
        __int16 v23 = 94;
        goto LABEL_20;
      }
    }
    unsigned int v16 = v15 - 1;
    *(_DWORD *)(a1 + 64) = v16;
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(void *)(a1 + 72) + 4 * v16);
    if (pthread_mutex_unlock(v8))
    {
      int v22 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      __int16 v23 = 98;
      goto LABEL_20;
    }
    unsigned int v17 = *(_DWORD *)(a1 + 56);
    if (v17 >= *(_DWORD *)(a1 + 16)) {
      break;
    }
    uint64_t v11 = *(void *)(a1 + 48) + 952 * v17;
    memset_s((void *)(v11 + 48), 0x220uLL, 0, 0x220uLL);
    int v18 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v18 + 1;
    *(_DWORD *)(v11 + 48) = v18;
LABEL_13:
    uint64_t v19 = *(unsigned int *)(v11 + 52);
    if ((v7 - v19) >= v3) {
      size_t v20 = v3;
    }
    else {
      size_t v20 = (v7 - v19);
    }
    memcpy((void *)(*(void *)(v11 + 32) + v19), __src, v20);
    int v21 = *(_DWORD *)(v11 + 52) + v20;
    *(_DWORD *)(v11 + 52) = v21;
    if (v21 == v7 && (aeaOutputStreamRunCurrentWorker(a1) & 0x80000000) != 0)
    {
      __int16 v24 = "Sending task to worker failed";
      __int16 v25 = 305;
      goto LABEL_21;
    }
    __src += v20;
    v6 += v20;
    v3 -= v20;
    if (!v3) {
      return v6;
    }
  }
  __int16 v24 = "Invalid worker_id";
  __int16 v25 = 283;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamWrite", v25, 41, 0, v24, v13, v14, v27);
  return -1;
}

void aeaOutputStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 36))
  {
    *(_DWORD *)(a1 + 36) = 1;
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t aeaOutputStreamClose(uint64_t a1)
{
  return aeaOutputStreamCloseAndUpdateContext(a1, 0);
}

AAByteStream AEAEncryptionOutputStreamOpenExisting(AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  int DefaultNThreads = n_threads;
  uint64_t v72 = *MEMORY[0x263EF8340];
  if (n_threads <= 0) {
    int DefaultNThreads = getDefaultNThreads();
  }
  if (!*((void *)encrypted_stream + 5) || !*((void *)encrypted_stream + 4))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", 430, 41, 0, "Invalid encrypted stream", v4, v5, v55);
    uint64_t v12 = 0;
    unsigned int v10 = 0;
LABEL_40:
    free(v10);
    aeaOutputStreamCloseAndUpdateContext(v12, 0);
    return 0;
  }
  unsigned int v10 = calloc(1uLL, 0x68uLL);
  uint64_t v11 = malloc(0x148uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x148uLL, 0, 0x148uLL), !v10))
  {
    int v30 = *__error();
    long long v31 = "malloc";
    __int16 v32 = 435;
LABEL_39:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", v32, 41, v30, v31, v14, v15, v55);
    goto LABEL_40;
  }
  *(void *)uint64_t v12 = encrypted_stream;
  *(void *)(v12 + 8) = flags;
  *(_DWORD *)(v12 + 16) = DefaultNThreads;
  AAByteStream result = (AAByteStream)aeaContainerCreateExisting((uint64_t)context, encrypted_stream, 0, 1);
  *(void *)(v12 + 24) = result;
  if (!result)
  {
    long long v31 = "load container";
    __int16 v32 = 443;
    goto LABEL_38;
  }
  if ((flags & 0x4000000000000) == 0)
  {
    if ((aeaContainerReencrypt((uint64_t)result, encrypted_stream, (int *)context + 18, (_DWORD *)context + 538, (unsigned int *)context + 83, (unsigned int *)context + 213) & 0x80000000) != 0)
    {
      long long v31 = "re-encrypting container";
      __int16 v32 = 454;
      goto LABEL_38;
    }
    AAByteStream result = *(AAByteStream *)(v12 + 24);
  }
  size_t v16 = *((unsigned int *)result + 167);
  if (v16 < 0x101)
  {
    memcpy((char *)context + 1376, (char *)result + 672, v16);
    *((_DWORD *)context + 343) = v16;
    memset_s((char *)context + v16 + 1376, 256 - v16, 0, 256 - v16);
    uint64_t v17 = *(void *)(v12 + 24);
    if (*(_DWORD *)v17 <= 5u && ((1 << *(_DWORD *)v17) & 0x2B) != 0) {
      goto LABEL_14;
    }
    memset(v71, 0, sizeof(v71));
    long long v70 = 0u;
    long long v69 = 0u;
    long long v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    long long v65 = 0u;
    long long v64 = 0u;
    long long v63 = 0u;
    long long v62 = 0u;
    long long v61 = 0u;
    long long v60 = 0u;
    long long v59 = 0u;
    long long v58 = 0u;
    *(_OWORD *)&__s[1] = 0u;
    *(_DWORD *)((char *)__s + 7) = 1262834527;
    __s[0] = 0x5F41454100000007;
    memset_s((char *)&__s[1] + 3, 0xF9uLL, 0, 0xF9uLL);
    long long v37 = *(uint64_t (**)(char *, void))(v17 + 144);
    if (v37 && *(_DWORD *)(v17 + 668))
    {
      int v38 = v37((char *)context + 1632, *(unsigned int *)(v17 + 72));
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
      if ((v38 & 0x80000000) == 0)
      {
        uint64_t v17 = *(void *)(v12 + 24);
LABEL_14:
        if ((aeaContainerRemovePadding(v17, encrypted_stream) & 0x80000000) == 0)
        {
          uint64_t v18 = *(void *)(v12 + 24);
          size_t v19 = *(unsigned int *)(v18 + 16);
          int v20 = *(_DWORD *)(v18 + 400);
          if (!v20 || *(_DWORD *)(*(void *)(v18 + 392) + 544 * (v20 - 1) + 4) >= v19)
          {
            long long v29 = 0;
            rsize_t v28 = 0;
            int v22 = 0;
            __int16 v25 = 0;
            unint64_t v33 = 0;
LABEL_25:
            *(_DWORD *)(v12 + 32) = v20;
            if ((aeaOutputStreamRunThreads(v12) & 0x80000000) != 0)
            {
              long long v39 = "Running stream threads";
              __int16 v40 = 499;
            }
            else
            {
              v10[3] = aeaOutputStreamWrite;
              v10[7] = aeaOutputStreamAbort;
              *unsigned int v10 = v12;
              v10[1] = aeaOutputStreamClose;
              if (!v33 || aeaOutputStreamWrite(v12, v25, v33) == v33)
              {
                int v36 = 1;
                goto LABEL_59;
              }
              long long v39 = "writing back last segment data";
              __int16 v40 = 511;
            }
            int v41 = 0;
LABEL_58:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", v40, 41, v41, v39, v34, v35, v55);
            int v36 = 0;
LABEL_59:
            if (!v22) {
              goto LABEL_61;
            }
            goto LABEL_60;
          }
          uint64_t v21 = *(unsigned int *)(v18 + 24);
          int v22 = (uint8_t *)malloc(*(unsigned int *)(v18 + 16));
          __int16 v25 = (char *)malloc(v19);
          if (v21)
          {
            compression_algorithm v26 = aeaEffectiveCompressionAlgorithm(v21);
            size_t v27 = compression_decode_scratch_buffer_size(v26);
            rsize_t v28 = v27;
            if (v27)
            {
              if (v27 < 0x2000000001)
              {
                long long v29 = malloc(v27);
              }
              else
              {
                long long v29 = 0;
                *__error() = 12;
              }
              int v42 = 1;
LABEL_49:
              if (v29) {
                int v42 = 0;
              }
              if (!v22 || !v25 || v42)
              {
                int v41 = *__error();
                long long v39 = "malloc";
                __int16 v40 = 483;
                goto LABEL_58;
              }
              rsize_t v56 = v28;
              uint64_t v43 = *(void *)(v12 + 24);
              unsigned int v44 = *(_DWORD *)(v43 + 400) - 1;
              uint64_t v45 = *(void *)(v43 + 392);
              uint64_t Segment = aeaContainerLoadSegment(v43, encrypted_stream, v44, (uint8_t *)v25, v22, v29, v23, v24);
              if (Segment == *(_DWORD *)(v45 + 544 * v44 + 4))
              {
                unint64_t v33 = Segment;
                rsize_t v28 = v56;
                if ((aeaContainerRemoveLastSegment(*(uint64x2_t **)(v12 + 24), encrypted_stream, v47, v48, v49, v50, v51, v52) & 0x80000000) == 0)
                {
                  int v20 = *(_DWORD *)(*(void *)(v12 + 24) + 400);
                  goto LABEL_25;
                }
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", 493, 41, 0, "removing last segment", v53, v54, v55);
                int v36 = 0;
              }
              else
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamOpenExisting", 489, 41, 0, "load and decrypt last segment", v51, v52, v55);
                int v36 = 0;
                rsize_t v28 = v56;
              }
LABEL_60:
              memset_s(v22, v19, 0, v19);
LABEL_61:
              free(v22);
              if (v25) {
                memset_s(v25, v19, 0, v19);
              }
              free(v25);
              if (v29) {
                memset_s(v29, v28, 0, v28);
              }
              free(v29);
              if (v36) {
                return (AAByteStream)v10;
              }
              goto LABEL_40;
            }
            int v42 = 0;
          }
          else
          {
            int v42 = 0;
            rsize_t v28 = 0;
          }
          long long v29 = 0;
          goto LABEL_49;
        }
        long long v31 = "removing padding";
        __int16 v32 = 471;
        goto LABEL_38;
      }
    }
    else
    {
      memset_s(__s, 0x104uLL, 0, 0x104uLL);
    }
    long long v31 = "deriving signature encryption key";
    __int16 v32 = 467;
LABEL_38:
    int v30 = 0;
    goto LABEL_39;
  }
  __break(1u);
  return result;
}

int AEAEncryptionOutputStreamCloseAndUpdateContext(AAByteStream stream, AEAContext context)
{
  if (stream)
  {
    AAByteStream v4 = stream;
    if (*((uint64_t (**)(uint64_t))stream + 1) == aeaOutputStreamClose)
    {
      uint64_t v5 = *(void *)stream;
      *(void *)AAByteStream v4 = 0;
      int updated = aeaOutputStreamCloseAndUpdateContext(v5, (uint64_t)context);
      free(v4);
      LODWORD(stream) = updated;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"AEAEncryptionOutputStreamCloseAndUpdateContext", 534, 41, 0, "Invalid stream type", v2, v3, v8);
      LODWORD(stream) = -1;
    }
  }
  return (int)stream;
}

uint64_t aeaOutputStreamCloseAndUpdateContext(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  uint64_t v3 = *(void **)(result + 48);
  uint64_t v43 = a2;
  if (v3 && (uint64_t v4 = *(unsigned int *)(result + 16), v4))
  {
    int v5 = 0;
    do
    {
      if (*v3) {
        ++v5;
      }
      v3 += 119;
      --v4;
    }
    while (v4);
  }
  else
  {
    int v5 = 0;
  }
  if ((aeaOutputStreamRunCurrentWorker(result) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 207, 41, 0, "Sending task to worker", v6, v7, v43);
    int v45 = 0;
  }
  else
  {
    int v45 = 1;
  }
  if (v5 >= 1)
  {
    for (int i = 0; i != v5; ++i)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 80)))
      {
        __int16 v12 = 91;
        uint64_t v13 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_20:
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v12, 0, v13, v9, v10, v11, v43);
        unsigned int v17 = -1;
      }
      else
      {
        while (1)
        {
          int v14 = *(_DWORD *)(v2 + 64);
          if (v14) {
            break;
          }
          if (pthread_cond_wait((pthread_cond_t *)(v2 + 144), (pthread_mutex_t *)(v2 + 80)))
          {
            __int16 v12 = 94;
            uint64_t v13 = "SharedArrayPop: pthread_cond_wait failed\n";
            goto LABEL_20;
          }
        }
        unsigned int v25 = v14 - 1;
        *(_DWORD *)(v2 + 64) = v25;
        unsigned int v17 = *(_DWORD *)(*(void *)(v2 + 72) + 4 * v25);
        if (!pthread_mutex_unlock((pthread_mutex_t *)(v2 + 80))) {
          goto LABEL_22;
        }
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v26, v27, v28, v43);
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 213, 41, 0, "SharedArrayPop", v15, v16, v44);
      int v45 = 0;
LABEL_22:
      uint64_t v18 = *(void *)(v2 + 48);
      uint64_t v19 = v18 + 952 * v17;
      memset_s((void *)(v19 + 48), 0x220uLL, 0, 0x220uLL);
      *(_DWORD *)(v19 + 48) = -1;
      int v20 = (pthread_mutex_t *)(v19 + 600);
      if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 600))
        || (v23 = v18 + 952 * v17, int v24 = *(_DWORD *)(v23 + 592), *(_DWORD *)(v23 + 592) = v24 + 1, !v24)
        && pthread_cond_broadcast((pthread_cond_t *)(v18 + 952 * v17 + 664))
        || pthread_mutex_unlock((pthread_mutex_t *)(v19 + 600)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 217, 41, 0, "SemRelease", v21, v22, v43);
        int v45 = 0;
      }
      joinThread(*(_opaque_pthread_t **)v19);
      long long v29 = (void **)(v18 + 952 * v17);
      free(v29[4]);
      free(v29[5]);
      free(v29[3]);
      if (!pthread_mutex_destroy(v20)) {
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952 * v17 + 664));
      }
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v18 + 952 * v17 + 720))) {
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952 * v17 + 784));
      }
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v18 + 952 * v17 + 840))) {
        pthread_cond_destroy((pthread_cond_t *)(v18 + 952 * v17 + 904));
      }
    }
  }
  int v30 = *(void **)(v2 + 320);
  if (v30)
  {
    uint64_t v31 = v43;
    int v32 = v45;
    if (*v30)
    {
      if ((SharedArrayEnqueue((unsigned int *)(v2 + 192), -1) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 230, 41, 0, "SharedArrayEnqueue", v33, v34, v43);
        int v32 = 0;
      }
      joinThread(**(_opaque_pthread_t ***)(v2 + 320));
    }
  }
  else
  {
    uint64_t v31 = v43;
    int v32 = v45;
  }
  AAByteStream result = *(void *)(v2 + 24);
  if (result && (AAByteStream result = aeaContainerFinish(result, *(AAByteStream_impl **)v2), (result & 0x80000000) != 0))
  {
    AAByteStream result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamCloseAndUpdateContext", 235, 41, 0, "finishing container", v35, v36, v43);
    int v32 = 0;
    if (v31) {
      goto LABEL_46;
    }
  }
  else if (v31)
  {
LABEL_46:
    uint64_t v37 = *(void *)(v2 + 24);
    *(_OWORD *)uint64_t v31 = *(_OWORD *)v37;
    long long v38 = *(_OWORD *)(v37 + 16);
    long long v39 = *(_OWORD *)(v37 + 32);
    long long v40 = *(_OWORD *)(v37 + 48);
    *(void *)(v31 + 64) = *(void *)(v37 + 64);
    *(_OWORD *)(v31 + 32) = v39;
    *(_OWORD *)(v31 + 48) = v40;
    *(_OWORD *)(v31 + 16) = v38;
    uint64_t v41 = *(void *)(v2 + 24);
    uint64_t v42 = *(unsigned int *)(v41 + 1448);
    if (v42 >= 0x101)
    {
      __break(1u);
      return result;
    }
    memcpy((void *)(v31 + 1896), (const void *)(v41 + 1452), *(unsigned int *)(v41 + 1448));
    *(_DWORD *)(v31 + 1892) = v42;
    memset_s((void *)(v31 + 1896 + v42), 256 - v42, 0, 256 - v42);
  }
  if (!pthread_mutex_destroy((pthread_mutex_t *)(v2 + 80)) && !pthread_cond_destroy((pthread_cond_t *)(v2 + 144))) {
    free(*(void **)(v2 + 72));
  }
  if (!pthread_mutex_destroy((pthread_mutex_t *)(v2 + 208)) && !pthread_cond_destroy((pthread_cond_t *)(v2 + 272))) {
    free(*(void **)(v2 + 200));
  }
  free(*(void **)(v2 + 48));
  free(*(void **)(v2 + 320));
  aeaContainerDestroy(*(void *)(v2 + 24));
  memset_s((void *)v2, 0x148uLL, 0, 0x148uLL);
  free((void *)v2);
  if (v32) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aeaOutputStreamRunCurrentWorker(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 56);
  if (v1 == -1) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    return 0;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(v3 + 952 * v1 + 600))
    || (v6 = v3 + 952 * v1, int v7 = *(_DWORD *)(v6 + 592), *(_DWORD *)(v6 + 592) = v7 + 1, !v7)
    && pthread_cond_broadcast((pthread_cond_t *)(v3 + 952 * v1 + 664))
    || pthread_mutex_unlock((pthread_mutex_t *)(v3 + 952 * v1 + 600)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamRunCurrentWorker", 188, 41, 0, "SemRelease", v4, v5, v12);
    int v8 = 0;
  }
  else
  {
    int v8 = 1;
  }
  if ((SharedArrayEnqueue((unsigned int *)(a1 + 192), *(_DWORD *)(a1 + 56)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAEncryptionStream.c", (uint64_t)"aeaOutputStreamRunCurrentWorker", 189, 41, 0, "SharedArrayEnqueue", v10, v11, v12);
    int v8 = 0;
  }
  *(_DWORD *)(a1 + 56) = -1;
  if (v8) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t treeDeleteRangeWithPoint(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  if (*a2 < 0) {
    return 0;
  }
  char v9 = a3;
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = (void *)(v12 + 56 * v8);
  if (*v13 > a3)
  {
    if ((treeDeleteRangeWithPoint(a1, v12 + 56 * v8 + 24, a3) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 456, 107, 0, "treeDelete: %zd", v18, v19, v9);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_30;
  }
  if (*(void *)(v12 + 56 * v8 + 8) <= a3)
  {
    if ((treeDeleteRangeWithPoint(a1, v12 + 56 * v8 + 32, a3) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 463, 107, 0, "treeDelete: %zd", v18, v19, v9);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_30;
  }
  uint64_t v20 = v12 + 56 * v8;
  uint64_t v23 = *(void *)(v20 + 24);
  uint64_t v21 = v20 + 24;
  uint64_t v22 = v23;
  uint64_t v24 = v21 + 8;
  uint64_t v25 = *(void *)(v21 + 8);
  if ((v23 & 0x8000000000000000) == 0)
  {
    if (v25 < 0) {
      int v26 = 0;
    }
    else {
      int v26 = *(_DWORD *)(v12 + 56 * v25 + 48);
    }
    int v27 = *(_DWORD *)(v12 + 56 * v22 + 48);
LABEL_15:
    if (v26 >= v27)
    {
      if ((v25 & 0x8000000000000000) == 0)
      {
        do
        {
          uint64_t v28 = v25;
          uint64_t v25 = *(void *)(v12 + 56 * v25 + 24);
        }
        while ((v25 & 0x8000000000000000) == 0);
        goto LABEL_29;
      }
      uint64_t v31 = v8;
      while (1)
      {
        uint64_t v28 = *(void *)(v12 + 56 * v31 + 16);
        if (v28 < 0) {
          break;
        }
        BOOL v30 = *(void *)(v12 + 56 * v28 + 32) == v31;
        uint64_t v31 = *(void *)(v12 + 56 * v31 + 16);
        if (!v30) {
          goto LABEL_29;
        }
      }
    }
    else
    {
      if ((v22 & 0x8000000000000000) == 0)
      {
        do
        {
          uint64_t v28 = v22;
          uint64_t v22 = *(void *)(v12 + 56 * v22 + 32);
        }
        while ((v22 & 0x8000000000000000) == 0);
LABEL_25:
        uint64_t v24 = v21;
LABEL_29:
        long long v32 = *(_OWORD *)(v12 + 56 * v28);
        *(_OWORD *)uint64_t v13 = v32;
        if ((treeDeleteRangeWithPoint(a1, v24, v32) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 493, 107, 0, "treeDelete: %zd", v18, v19, v9);
          return 0xFFFFFFFFLL;
        }
LABEL_30:
        uint64_t v33 = *(void *)(a1 + 8);
        uint64_t v34 = (void *)(v33 + 56 * v8);
        uint64_t v35 = v34[3];
        if (v35 < 0) {
          unsigned int v36 = 0;
        }
        else {
          unsigned int v36 = *(_DWORD *)(v33 + 56 * v35 + 48);
        }
        uint64_t v37 = *(void *)(v33 + 56 * v8 + 32);
        if (v37 < 0) {
          unsigned int v38 = 0;
        }
        else {
          unsigned int v38 = *(_DWORD *)(v33 + 56 * v37 + 48);
        }
        if (v38 > v36) {
          unsigned int v36 = v38;
        }
        uint64_t v39 = v33 + 56 * v8;
        *(_DWORD *)(v39 + 48) = v36 + 1;
        uint64_t v40 = *(void *)(v39 + 8) - *v34;
        if (v35 < 0) {
          uint64_t v41 = 0;
        }
        else {
          uint64_t v41 = *(void *)(v33 + 56 * v35 + 40);
        }
        uint64_t v42 = v40 + v41;
        if (v37 < 0) {
          uint64_t v43 = 0;
        }
        else {
          uint64_t v43 = *(void *)(v33 + 56 * v37 + 40);
        }
        *(void *)(v33 + 56 * v8 + 40) = v42 + v43;
        if ((treeRebalance(a1, a2, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 499, 107, 0, "treeRebalance: %zd", v44, v45, v8);
          return 0xFFFFFFFFLL;
        }
        return 0;
      }
      uint64_t v29 = v8;
      while (1)
      {
        uint64_t v28 = *(void *)(v12 + 56 * v29 + 16);
        if (v28 < 0) {
          break;
        }
        BOOL v30 = *(void *)(v12 + 56 * v28 + 24) == v29;
        uint64_t v29 = *(void *)(v12 + 56 * v29 + 16);
        if (!v30) {
          goto LABEL_25;
        }
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeDeleteRangeWithPoint", 490, 107, 0, "no nodePrev/Next: %zd", a7, a8, v8);
    return 0xFFFFFFFFLL;
  }
  if ((v25 & 0x8000000000000000) == 0)
  {
    int v27 = 0;
    int v26 = *(_DWORD *)(v12 + 56 * v25 + 48);
    goto LABEL_15;
  }
  uint64_t result = 0;
  *(void *)(v12 + 56 * v8 + 16) = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v8;
  *a2 = -1;
  return result;
}

uint64_t treeRebalance(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  uint64_t v35 = v8;
  if (v8 < 0) {
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v12 = *(void *)(v11 + 56 * v8 + 32);
  int v13 = v12 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v12 + 48);
  uint64_t v14 = *(void *)(v11 + 56 * v8 + 24);
  int v15 = v14 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v14 + 48);
  int v16 = v13 - v15;
  if ((v16 + 1) < 3) {
    return 0;
  }
  if (v16 == -2)
  {
    if ((v14 & 0x8000000000000000) == 0)
    {
      uint64_t v20 = *(void *)(v11 + 56 * v14 + 32);
      int v21 = v20 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v20 + 48);
      uint64_t v28 = *(void *)(v11 + 56 * v14 + 24);
      int v29 = v28 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v28 + 48);
      if (v21 > v29)
      {
        uint64_t v34 = v14;
        if ((treeRotateLeft(a1, &v34) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 360, 107, 0, "treeRotateLeft %zd", v30, v31, v34);
          return 0xFFFFFFFFLL;
        }
        *(void *)(*(void *)(a1 + 8) + 56 * v8 + 24) = v34;
      }
    }
    if ((treeRotateRight(a1, &v35) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 364, 107, 0, "treeRotateRight %zd", v32, v33, v35);
      return 0xFFFFFFFFLL;
    }
    goto LABEL_36;
  }
  if (v16 == 2)
  {
    if ((v12 & 0x8000000000000000) == 0)
    {
      uint64_t v18 = *(void *)(v11 + 56 * v12 + 32);
      int v19 = v18 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v18 + 48);
      uint64_t v22 = *(void *)(v11 + 56 * v12 + 24);
      int v23 = v22 < 0 ? 0 : *(_DWORD *)(v11 + 56 * v22 + 48);
      if (v19 < v23)
      {
        uint64_t v34 = v12;
        if ((treeRotateRight(a1, &v34) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 347, 107, 0, "treeRotateRight %zd", v24, v25, v34);
          return 0xFFFFFFFFLL;
        }
        *(void *)(*(void *)(a1 + 8) + 56 * v8 + 32) = v34;
      }
    }
    if ((treeRotateLeft(a1, &v35) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 351, 107, 0, "treeRotateRight %zd", v26, v27, v35);
      return 0xFFFFFFFFLL;
    }
LABEL_36:
    uint64_t result = 0;
    *a2 = v35;
    return result;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeRebalance", 366, 107, 0, "invalid imbalance: %d", a7, a8, v16);
  return 0xFFFFFFFFLL;
}

uint64_t treeSub(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = (uint64_t *)(a1 + 2);
  uint64_t v8 = a1[2];
  if (v8 < 0) {
    return 0;
  }
  while (2)
  {
    unint64_t v13 = a1[1];
    while (1)
    {
      uint64_t v14 = (uint64_t *)(v13 + 56 * v8);
      uint64_t v15 = *v14;
      if (*v14 >= a3)
      {
        uint64_t v20 = (uint64_t *)(v13 + 56 * v8 + 24);
        goto LABEL_7;
      }
      unint64_t v16 = v13 + 56 * v8;
      uint64_t v19 = *(void *)(v16 + 8);
      uint64_t v18 = (uint64_t *)(v16 + 8);
      uint64_t v17 = v19;
      if (v19 > a2) {
        break;
      }
      uint64_t v20 = (uint64_t *)(v13 + 56 * v8 + 32);
LABEL_7:
      uint64_t v8 = *v20;
      if (v8 < 0) {
        return 0;
      }
    }
    if (v15 < a2 || v17 > a3)
    {
      if (v15 >= a2)
      {
        *uint64_t v14 = a3;
      }
      else
      {
        *uint64_t v18 = a2;
        if (v17 > a3 && (treeAdd(a1, -1, v9, a3, v17, a6, a7, a8) & 0x80000000) != 0)
        {
          int v23 = "treeAdd";
          __int16 v24 = 538;
          goto LABEL_23;
        }
      }
LABEL_20:
      uint64_t result = 0;
      uint64_t v8 = *v9;
      if (*v9 < 0) {
        return result;
      }
      continue;
    }
    break;
  }
  if ((treeDeleteRangeWithPoint((uint64_t)a1, v9, v15, a4, v17, a6, a7, a8) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  int v23 = "treeDeleteRangeWithPoint";
  __int16 v24 = 525;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeSub", v24, 107, 0, v23, a7, a8, v25);
  return 0xFFFFFFFFLL;
}

uint64_t treeAdd(unint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a5 - a4;
  if (a5 <= a4) {
    return 0;
  }
  uint64_t v13 = *a3;
  uint64_t v55 = v13;
  if (v13 < 0)
  {
    uint64_t v13 = a1[3];
    if ((v13 & 0x8000000000000000) == 0)
    {
      uint64_t v15 = (char *)a1[1];
      goto LABEL_5;
    }
    if (*a1) {
      unint64_t v36 = 2 * *a1;
    }
    else {
      unint64_t v36 = 32;
    }
    if (56 * v36 < 0x2000000001)
    {
      long long v46 = (void *)a1[1];
      uint64_t v15 = (char *)realloc(v46, 56 * v36);
      if (v15)
      {
        a1[1] = (unint64_t)v15;
        uint64_t v47 = *a1;
        if (*a1 >= v36)
        {
          uint64_t v13 = -1;
        }
        else
        {
          uint64_t v48 = (uint64_t *)&v15[56 * v47 + 16];
          uint64_t v49 = -1;
          do
          {
            *uint64_t v48 = v49;
            v48 += 7;
            uint64_t v49 = v47++;
          }
          while (v36 != v47);
          uint64_t v13 = v47 - 1;
        }
        *a1 = v36;
LABEL_5:
        unint64_t v16 = &v15[56 * v13];
        a1[3] = *((void *)v16 + 2);
        *((void *)v16 + 2) = a2;
        *((void *)v16 + 3) = -1;
        *(void *)unint64_t v16 = a4;
        *((void *)v16 + 1) = a5;
        *((_DWORD *)v16 + 12) = 1;
        *((void *)v16 + 4) = -1;
        *((void *)v16 + 5) = v8;
        uint64_t v55 = v13;
        if ((v13 & 0x8000000000000000) == 0) {
          goto LABEL_6;
        }
LABEL_75:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 391, 107, 0, "nodeAlloc", a7, a8, v53);
        return 0xFFFFFFFFLL;
      }
      free(v46);
    }
    else
    {
      *__error() = 12;
    }
    a1[1] = 0;
    uint64_t v50 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"nodeAlloc", 43, 107, *v50, "malloc", v51, v52, v53);
    goto LABEL_75;
  }
LABEL_6:
  unint64_t v17 = a1[1];
  uint64_t v18 = (uint64_t *)(v17 + 56 * v13);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[3];
  if (v20 < 0)
  {
    int64_t v23 = 0x8000000000000000;
  }
  else
  {
    uint64_t v21 = v18[3];
    do
    {
      uint64_t v22 = v21;
      uint64_t v21 = *(void *)(v17 + 56 * v21 + 32);
    }
    while ((v21 & 0x8000000000000000) == 0);
    int64_t v23 = *(void *)(v17 + 56 * v22 + 8);
  }
  if (v19 > a4 && v19 <= a5 && v23 < v19)
  {
    if (a4 <= v23) {
      uint64_t v19 = v23;
    }
    else {
      uint64_t v19 = a4;
    }
    *uint64_t v18 = v19;
  }
  uint64_t v25 = *(void *)(v17 + 56 * v13 + 32);
  if (v25 < 0)
  {
    uint64_t v27 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    do
    {
      uint64_t v26 = v25;
      uint64_t v25 = *(void *)(v17 + 56 * v25 + 24);
    }
    while ((v25 & 0x8000000000000000) == 0);
    uint64_t v27 = *(void *)(v17 + 56 * v26);
  }
  uint64_t v30 = v18[1];
  uint64_t v28 = v18 + 1;
  uint64_t v29 = v30;
  if (v30 < a5 && v29 >= a4 && v27 > v29)
  {
    if (v27 >= a5) {
      uint64_t v29 = a5;
    }
    else {
      uint64_t v29 = v27;
    }
    uint64_t *v28 = v29;
  }
  if (v19 > a4)
  {
    if (v19 >= a5) {
      uint64_t v31 = a5;
    }
    else {
      uint64_t v31 = v19;
    }
    uint64_t v54 = v20;
    if ((treeAdd(a1, v13, &v54, a4, v31) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 418, 107, 0, "treeAdd: %zd", a7, a8, v54);
      return 0xFFFFFFFFLL;
    }
    unint64_t v17 = a1[1];
    *(void *)(v17 + 56 * v13 + 24) = v54;
  }
  if (v29 < a5)
  {
    if (v29 <= a4) {
      uint64_t v32 = a4;
    }
    else {
      uint64_t v32 = v29;
    }
    uint64_t v54 = *(void *)(v17 + 56 * v13 + 32);
    if ((treeAdd(a1, v13, &v54, v32, a5) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 428, 107, 0, "treeAdd: %zd", a7, a8, v54);
      return 0xFFFFFFFFLL;
    }
    unint64_t v17 = a1[1];
    *(void *)(v17 + 56 * v13 + 32) = v54;
  }
  if ((v13 & 0x8000000000000000) == 0)
  {
    uint64_t v33 = (void *)(v17 + 56 * v13);
    uint64_t v34 = v33[3];
    if (v34 < 0) {
      unsigned int v35 = 0;
    }
    else {
      unsigned int v35 = *(_DWORD *)(v17 + 56 * v34 + 48);
    }
    uint64_t v37 = *(void *)(v17 + 56 * v13 + 32);
    if (v37 < 0) {
      unsigned int v38 = 0;
    }
    else {
      unsigned int v38 = *(_DWORD *)(v17 + 56 * v37 + 48);
    }
    if (v38 > v35) {
      unsigned int v35 = v38;
    }
    unint64_t v39 = v17 + 56 * v13;
    *(_DWORD *)(v39 + 48) = v35 + 1;
    uint64_t v40 = *(void *)(v39 + 8) - *v33;
    if (v34 < 0) {
      uint64_t v41 = 0;
    }
    else {
      uint64_t v41 = *(void *)(v17 + 56 * v34 + 40);
    }
    uint64_t v42 = v40 + v41;
    if (v37 < 0) {
      uint64_t v43 = 0;
    }
    else {
      uint64_t v43 = *(void *)(v17 + 56 * v37 + 40);
    }
    *(void *)(v17 + 56 * v13 + 40) = v42 + v43;
  }
  if ((treeRebalance((uint64_t)a1, &v55, (uint64_t)a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
  {
    uint64_t result = 0;
    *a3 = v55;
    return result;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"treeAdd", 434, 107, 0, "treeRebalance: %zd", v44, v45, v55);
  return 0xFFFFFFFFLL;
}

void *AAByteRangeCreate()
{
  uint64_t v0 = malloc(0x20uLL);
  unsigned int v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x20uLL, 0, 0x20uLL);
    v1[2] = -1;
    v1[3] = -1;
  }
  else
  {
    uint64_t v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeCreate", 551, 107, *v2, "malloc", v3, v4, v6);
    AAByteRangeDestroy(0);
  }
  return v1;
}

void AAByteRangeDestroy(void **a1)
{
  if (a1)
  {
    free(a1[1]);
    free(a1);
  }
}

void *AAByteRangeClone(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    __int16 v6 = 563;
    goto LABEL_10;
  }
  memset_s(v2, 0x20uLL, 0, 0x20uLL);
  v3[2] = -1;
  v3[3] = -1;
  if ((*(void *)(a1 + 16) & 0x8000000000000000) == 0)
  {
    size_t v4 = *(void *)a1;
    if (is_mul_ok(*(void *)a1, 0x38uLL) && 56 * v4 < 0x2000000001)
    {
      uint64_t v5 = calloc(v4, 0x38uLL);
      v3[1] = v5;
      if (v5)
      {
        memcpy(v5, *(const void **)(a1 + 8), 56 * *(void *)a1);
        *uint64_t v3 = *(void *)a1;
        *((_OWORD *)v3 + 1) = *(_OWORD *)(a1 + 16);
        return v3;
      }
    }
    else
    {
      *__error() = 12;
      v3[1] = 0;
    }
    __int16 v6 = 570;
LABEL_10:
    int v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeClone", v6, 107, *v7, "malloc", v8, v9, v11);
    AAByteRangeDestroy((void **)v3);
    return 0;
  }
  return v3;
}

uint64_t AAByteRangeAdd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == a3) {
    return 0;
  }
  if (a2 <= a3)
  {
    if ((treeAdd((unint64_t *)a1, -1, (uint64_t *)(a1 + 16), a2, a3, a6, a7, a8) & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v10 = "addSegment";
    __int16 v11 = 595;
  }
  else
  {
    uint64_t v10 = "Invalid segment bounds";
    __int16 v11 = 593;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeAdd", v11, 107, 0, v10, a7, a8, v8);
  return 0xFFFFFFFFLL;
}

uint64_t AAByteRangeSub(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == a3) {
    return 0;
  }
  if (a2 <= a3)
  {
    if ((a1[2] & 0x8000000000000000) != 0 || (treeSub(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v10 = "subSegment";
    __int16 v11 = 612;
  }
  else
  {
    uint64_t v10 = "Invalid segment bounds";
    __int16 v11 = 609;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteRange.c", (uint64_t)"AAByteRangeSub", v11, 107, 0, v10, a7, a8, v8);
  return 0xFFFFFFFFLL;
}

uint64_t AAByteRangeSizeAtOffset(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 < 0) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  while (1)
  {
    __int16 v6 = (uint64_t *)(v5 + 56 * v2);
    uint64_t v9 = *v6;
    char v8 = v6 + 3;
    uint64_t v7 = v9;
    uint64_t v10 = a2 - v9;
    if (a2 > v9) {
      break;
    }
LABEL_9:
    uint64_t v2 = *v8;
    if (*v8 < 0) {
      return result;
    }
  }
  uint64_t v11 = *v8;
  if (v11 < 0) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = *(void *)(v5 + 56 * v11 + 40);
  }
  uint64_t v13 = v12 + result;
  uint64_t v14 = *(void *)(v5 + 56 * v2 + 8);
  if (v14 < a2)
  {
    uint64_t result = v14 - v7 + v13;
    char v8 = (uint64_t *)(v5 + 56 * v2 + 32);
    goto LABEL_9;
  }
  return v10 + v13;
}

uint64_t AAByteRangeOffsetAtSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if ((v2 & 0x8000000000000000) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    do
    {
      size_t v4 = (uint64_t *)(v3 + 56 * v2);
      if (a2 > v4[5]) {
        break;
      }
      uint64_t v5 = *(void *)(v3 + 56 * v2 + 24);
      if (v5 < 0) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = *(void *)(v3 + 56 * v5 + 40);
      }
      BOOL v7 = __OFSUB__(a2, v6);
      uint64_t v8 = a2 - v6;
      if (!((v8 < 0) ^ v7 | (v8 == 0)))
      {
        uint64_t v9 = *v4;
        uint64_t v10 = *(void *)(v3 + 56 * v2 + 8) - v9;
        a2 = v8 - v10;
        if (v8 <= v10) {
          return v9 + v8;
        }
        uint64_t v5 = *(void *)(v3 + 56 * v2 + 32);
      }
      uint64_t v2 = v5;
    }
    while ((v5 & 0x8000000000000000) == 0);
  }
  return -1;
}

uint64_t AAByteRangeFirst(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t First = findFirst(a1, *(void *)(a1 + 16), a2);
  if (First < 0) {
    return -1;
  }
  uint64_t v8 = First;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(v9 + 56 * First);
  while (1)
  {
    uint64_t result = v8;
    uint64_t v12 = v9 + 56 * v8;
    uint64_t v13 = *(void *)(v12 + 8);
    uint64_t v14 = *(void *)(v12 + 32);
    uint64_t v15 = result;
    if (v14 < 0) {
      break;
    }
    do
    {
      uint64_t v8 = v14;
      uint64_t v14 = *(void *)(v9 + 56 * v14 + 24);
    }
    while ((v14 & 0x8000000000000000) == 0);
LABEL_8:
    if (*(void *)(v9 + 56 * v8) != v13) {
      goto LABEL_9;
    }
  }
  while (1)
  {
    uint64_t v8 = *(void *)(v9 + 56 * v15 + 16);
    if (v8 < 0) {
      break;
    }
    BOOL v16 = *(void *)(v9 + 56 * v8 + 32) == v15;
    uint64_t v15 = *(void *)(v9 + 56 * v15 + 16);
    if (!v16) {
      goto LABEL_8;
    }
  }
LABEL_9:
  *a3 = v10;
  *a4 = v13;
  return result;
}

uint64_t findFirst(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0) {
    return -1;
  }
  uint64_t v4 = a2;
  uint64_t v6 = *(void *)(a1 + 8);
  while (1)
  {
    if (*(void *)(v6 + 56 * v4) > a3)
    {
      uint64_t First = findFirst(a1, *(void *)(v6 + 56 * v4 + 24), a3);
      if ((First & 0x8000000000000000) == 0) {
        break;
      }
    }
    if (*(void *)(v6 + 56 * v4 + 8) > a3) {
      return v4;
    }
    uint64_t v4 = *(void *)(v6 + 56 * v4 + 32);
    if (v4 < 0) {
      return -1;
    }
  }
  return First;
}

uint64_t AAByteRangeNext(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a2 < 0) {
    return -1;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(v4 + 56 * a2 + 32);
  if (v5 < 0)
  {
    while (1)
    {
      uint64_t result = *(void *)(v4 + 56 * a2 + 16);
      if (result < 0) {
        break;
      }
      BOOL v7 = *(void *)(v4 + 56 * result + 32) == a2;
      a2 = *(void *)(v4 + 56 * a2 + 16);
      if (!v7) {
        goto LABEL_9;
      }
    }
  }
  else
  {
    do
    {
      uint64_t result = v5;
      uint64_t v5 = *(void *)(v4 + 56 * v5 + 24);
    }
    while ((v5 & 0x8000000000000000) == 0);
LABEL_9:
    uint64_t v8 = (void *)(v4 + 56 * result);
    *a3 = *v8;
    *a4 = v8[1];
  }
  return result;
}

uint64_t treeRotateRight(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = v3 + 56 * v2;
  uint64_t v7 = *(void *)(v4 + 24);
  uint64_t v6 = (void *)(v4 + 24);
  uint64_t v5 = v7;
  if (v7 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v3 + 56 * v5;
  uint64_t v9 = *(void *)(v8 + 32);
  *(void *)(v8 + 32) = v2;
  uint64_t v10 = v3 + 56 * v2;
  *(void *)(v8 + 16) = *(void *)(v10 + 16);
  *(void *)(v10 + 16) = v5;
  void *v6 = v9;
  if (v9 < 0)
  {
    unsigned int v12 = 0;
  }
  else
  {
    uint64_t v11 = v3 + 56 * v9;
    *(void *)(v11 + 16) = v2;
    unsigned int v12 = *(_DWORD *)(v11 + 48);
  }
  uint64_t v14 = (void *)(v3 + 56 * v2);
  uint64_t v15 = v14[4];
  if (v15 < 0) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = *(_DWORD *)(v3 + 56 * v15 + 48);
  }
  if (v16 > v12) {
    unsigned int v12 = v16;
  }
  unsigned int v17 = v12 + 1;
  uint64_t v18 = v3 + 56 * v2;
  *(_DWORD *)(v18 + 48) = v17;
  uint64_t v19 = *(void *)(v18 + 8) - *v14;
  if (v9 < 0) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = *(void *)(v3 + 56 * v9 + 40);
  }
  uint64_t v21 = v19 + v20;
  if (v15 < 0) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = *(void *)(v3 + 56 * v15 + 40);
  }
  uint64_t v23 = v21 + v22;
  *(void *)(v3 + 56 * v2 + 40) = v23;
  __int16 v24 = (void *)(v3 + 56 * v5);
  uint64_t v25 = v24[3];
  if (v25 < 0) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = *(_DWORD *)(v3 + 56 * v25 + 48);
  }
  if (v17 <= v26) {
    unsigned int v17 = v26;
  }
  uint64_t v27 = v3 + 56 * v5;
  *(_DWORD *)(v27 + 48) = v17 + 1;
  if (v25 < 0) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = *(void *)(v3 + 56 * v25 + 40);
  }
  uint64_t result = 0;
  *(void *)(v3 + 56 * v5 + 40) = *(void *)(v27 + 8) - *v24 + v28 + v23;
  *a2 = v5;
  return result;
}

uint64_t treeRotateLeft(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = v3 + 56 * v2;
  uint64_t v7 = *(void *)(v4 + 32);
  uint64_t v6 = (void *)(v4 + 32);
  uint64_t v5 = v7;
  if (v7 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = v3 + 56 * v5;
  uint64_t v9 = *(void *)(v8 + 24);
  uint64_t v10 = v3 + 56 * v2;
  *(void *)(v8 + 16) = *(void *)(v10 + 16);
  *(void *)(v8 + 24) = v2;
  *(void *)(v10 + 16) = v5;
  void *v6 = v9;
  if ((v9 & 0x8000000000000000) == 0) {
    *(void *)(v3 + 56 * v9 + 16) = v2;
  }
  uint64_t v11 = (void *)(v3 + 56 * v2);
  uint64_t v12 = v11[3];
  if (v12 < 0)
  {
    unsigned int v13 = 0;
    if ((v9 & 0x8000000000000000) == 0) {
      goto LABEL_7;
    }
LABEL_10:
    unsigned int v14 = 0;
    goto LABEL_11;
  }
  unsigned int v13 = *(_DWORD *)(v3 + 56 * v12 + 48);
  if (v9 < 0) {
    goto LABEL_10;
  }
LABEL_7:
  unsigned int v14 = *(_DWORD *)(v3 + 56 * v9 + 48);
LABEL_11:
  if (v14 > v13) {
    unsigned int v13 = v14;
  }
  unsigned int v16 = v13 + 1;
  uint64_t v17 = v3 + 56 * v2;
  *(_DWORD *)(v17 + 48) = v16;
  uint64_t v18 = *(void *)(v17 + 8) - *v11;
  if (v12 < 0) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = *(void *)(v3 + 56 * v12 + 40);
  }
  uint64_t v20 = v18 + v19;
  if (v9 < 0) {
    uint64_t v21 = 0;
  }
  else {
    uint64_t v21 = *(void *)(v3 + 56 * v9 + 40);
  }
  uint64_t v22 = v20 + v21;
  *(void *)(v3 + 56 * v2 + 40) = v22;
  uint64_t v23 = (void *)(v3 + 56 * v5);
  uint64_t v24 = v23[4];
  if (v24 < 0) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = *(_DWORD *)(v3 + 56 * v24 + 48);
  }
  if (v25 > v16) {
    unsigned int v16 = v25;
  }
  uint64_t v26 = v3 + 56 * v5;
  *(_DWORD *)(v26 + 48) = v16 + 1;
  uint64_t v27 = *(void *)(v26 + 8) - *v23 + v22;
  if (v24 < 0) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = *(void *)(v3 + 56 * v24 + 40);
  }
  uint64_t result = 0;
  *(void *)(v3 + 56 * v5 + 40) = v27 + v28;
  *a2 = v5;
  return result;
}

void afStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 48), (unsigned int *)&v1, 1u);
}

uint64_t afStreamCloseWithState(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 48))) {
    return 0xFFFFFFFFLL;
  }
  if ((flushBuf(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamCloseWithState", 236, 67, 0, "flush buf", v13, v14, v31[0]);
    int v15 = 0;
  }
  else
  {
    int v15 = 1;
  }
  long long v16 = *(_OWORD *)(a1 + 24);
  v31[0] = *(_OWORD *)(a1 + 8);
  v31[1] = v16;
  uint64_t v17 = (uint64_t *)(a1 + 64);
  long long v18 = *(_OWORD *)(a1 + 96);
  v31[2] = *(_OWORD *)(a1 + 56);
  v31[3] = v18;
  BOOL v32 = *(void *)(a1 + 40) != 0;
  char v33 = *(_DWORD *)(a1 + 88);
  if (!a2[3]) {
    goto LABEL_32;
  }
  uint64_t v19 = 0;
  uint64_t v20 = v31;
  uint64_t v21 = 66;
  while (1)
  {
    uint64_t v22 = ((uint64_t (*)(void, _OWORD *, uint64_t))a2[3])(*a2, v20, v21);
    if (v22 < 1) {
      break;
    }
    uint64_t v20 = (_OWORD *)((char *)v20 + v22);
    v19 += v22;
    v21 -= v22;
    if (!v21)
    {
      if (v19 < 0) {
        goto LABEL_32;
      }
      goto LABEL_13;
    }
  }
  if (v22 < 0) {
    goto LABEL_32;
  }
LABEL_13:
  if (!a2[3]) {
    goto LABEL_32;
  }
  uint64_t v23 = *v17;
  if (*v17)
  {
    uint64_t v24 = 0;
    uint64_t v25 = *(void *)(a1 + 80);
    while (1)
    {
      uint64_t v26 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v25, v23);
      if (v26 < 1) {
        break;
      }
      v25 += v26;
      v24 += v26;
      v23 -= v26;
      if (!v23)
      {
        if (v24 < 0) {
          goto LABEL_32;
        }
        goto LABEL_21;
      }
    }
    if (v26 < 0) {
      goto LABEL_32;
    }
LABEL_21:
    if (!a2[3]) {
      goto LABEL_32;
    }
  }
  uint64_t v27 = 16 * *(void *)(a1 + 104);
  if (v27)
  {
    uint64_t v28 = 0;
    uint64_t v29 = *(void *)(a1 + 120);
    while (1)
    {
      uint64_t v30 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v29, v27);
      if (v30 < 1) {
        break;
      }
      v29 += v30;
      v28 += v30;
      v27 -= v30;
      if (!v27) {
        goto LABEL_28;
      }
    }
    uint64_t v28 = v30;
LABEL_28:
    if (v28 < 0) {
      goto LABEL_32;
    }
  }
  if ((AAByteStreamCloseWithState(*(uint64_t (***)(void))(a1 + 40)) & 0x80000000) != 0)
  {
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"afStreamCloseWithState", 253, 67, 0, "serializing state", v13, v14, v31[0]);
    int v15 = 0;
  }
  else if (a3)
  {
    *a3 = *(void *)(a1 + 24);
  }
  if ((*(_DWORD *)a1 & 0x80000000) == 0 && !*(_DWORD *)(a1 + 4)) {
    close(*(_DWORD *)a1);
  }
  free(*(void **)(a1 + 80));
  memset_s((void *)(a1 + 64), 0x18uLL, 0, 0x18uLL);
  free(*(void **)(a1 + 120));
  free((void *)a1);
  if (v15) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void *aaArchiveFileOutputStreamOpenAtWithState(int a1, const char *a2, AAByteStream_impl *a3, void *a4)
{
  __int16 v61 = 0;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  uint64_t v8 = calloc(1uLL, 0x68uLL);
  uint64_t v9 = malloc(0x80uLL);
  uint64_t v10 = (uint64_t)v9;
  if (!v9 || (memset_s(v9, 0x80uLL, 0, 0x80uLL), !v8))
  {
    int v14 = *__error();
    int v15 = "malloc";
    __int16 v16 = 462;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState", v16, 67, v14, v15, v12, v13, v56);
LABEL_26:
    afStreamClose(v10);
    free(v8);
    return 0;
  }
  *(_DWORD *)uint64_t v10 = -1;
  char v56 = -92;
  if (a1 < 0) {
    int v11 = open(a2, 1);
  }
  else {
    int v11 = openat(a1, a2, 1);
  }
  *(_DWORD *)uint64_t v10 = v11;
  if (v11 < 0)
  {
    int v34 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState", 470, 67, v34, "%s", v35, v36, (char)a2);
    goto LABEL_26;
  }
  if (!*((void *)a3 + 2))
  {
LABEL_23:
    int v15 = "loading state";
    __int16 v16 = 473;
LABEL_24:
    int v14 = 0;
    goto LABEL_25;
  }
  uint64_t v17 = 0;
  long long v18 = &v57;
  uint64_t v19 = 66;
  do
  {
    uint64_t v20 = (*((uint64_t (**)(void, long long *, uint64_t))a3 + 2))(*(void *)a3, v18, v19);
    if (v20 < 0) {
      goto LABEL_23;
    }
    if (!v20) {
      break;
    }
    long long v18 = (long long *)((char *)v18 + v20);
    v17 += v20;
    v19 -= v20;
  }
  while (v19);
  if (v17 < 0) {
    goto LABEL_23;
  }
  size_t v24 = *((void *)&v60 + 1);
  uint64_t v25 = v60;
  *(void *)(v10 + 104) = *((void *)&v60 + 1);
  uint64_t v26 = (void *)(v10 + 104);
  long long v27 = v58;
  *(_OWORD *)(v10 + 8) = v57;
  *(_OWORD *)(v10 + 24) = v27;
  unint64_t v28 = v59;
  *(void *)(v10 + 56) = v59;
  *(_DWORD *)(v10 + 88) = HIBYTE(v61);
  *(void *)(v10 + 96) = v25;
  *(void *)(v10 + 112) = v24;
  if ((v28 & 0x8000000000000000) != 0)
  {
LABEL_78:
    int v15 = "alloc buf";
    __int16 v16 = 485;
    goto LABEL_24;
  }
  uint64_t v29 = (unint64_t *)(v10 + 64);
  size_t v30 = *(void *)(v10 + 72);
  if (v30 < v28)
  {
    do
    {
      while (!v30)
      {
        size_t v30 = 0x4000;
        if (v28 <= 0x4000)
        {
          BOOL v32 = (void **)(v10 + 80);
          size_t v30 = 0x4000;
          goto LABEL_31;
        }
      }
      size_t v31 = v30 >> 1;
      if ((v30 & (v30 >> 1)) != 0) {
        size_t v31 = v30 & (v30 >> 1);
      }
      v30 += v31;
    }
    while (v30 < v28);
    BOOL v32 = (void **)(v10 + 80);
    if (v30 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_77;
    }
LABEL_31:
    uint64_t v37 = *v32;
    unsigned int v38 = realloc(*v32, v30);
    if (v38)
    {
      *(void *)(v10 + 72) = v30;
      *(void *)(v10 + 80) = v38;
      size_t v24 = *(void *)(v10 + 112);
      goto LABEL_33;
    }
    free(v37);
LABEL_77:
    *BOOL v32 = 0;
    *uint64_t v29 = 0;
    *(void *)(v10 + 72) = 0;
    goto LABEL_78;
  }
LABEL_33:
  if (v24)
  {
    if (v24 >= 0x200000001)
    {
      *__error() = 12;
      *(void *)(v10 + 120) = 0;
LABEL_75:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAArchiveFileStream.c", (uint64_t)"aaArchiveFileOutputStreamOpenAtWithState", 487, 67, 0, "alloc holes", v12, v13, 164);
      *uint64_t v26 = 0;
      *(void *)(v10 + 112) = 0;
      goto LABEL_26;
    }
    unint64_t v39 = calloc(v24, 0x10uLL);
    *(void *)(v10 + 120) = v39;
    if (!v39) {
      goto LABEL_75;
    }
  }
  size_t v40 = *((void *)&v59 + 1);
  if (*((void *)&v59 + 1))
  {
    uint64_t v41 = 0;
    unint64_t v43 = *(void *)(v10 + 64);
    unint64_t v42 = *(void *)(v10 + 72);
    do
    {
      if (v43 == v42)
      {
        unint64_t v44 = v42 + 0x40000;
        if ((uint64_t)(v42 + 0x40000) < 0) {
          goto LABEL_83;
        }
        if (v42 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v42)
            {
              unint64_t v42 = 0x4000;
              size_t v46 = 0x4000;
              if (v44 <= 0x4000) {
                goto LABEL_52;
              }
            }
            unint64_t v45 = v42 >> 1;
            if ((v42 & (v42 >> 1)) != 0) {
              unint64_t v45 = v42 & (v42 >> 1);
            }
            v42 += v45;
          }
          while (v42 < v44);
          size_t v46 = v42;
          if (v42 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_82;
          }
LABEL_52:
          uint64_t v47 = *(void **)(v10 + 80);
          uint64_t v48 = realloc(v47, v46);
          if (v48)
          {
            *(void *)(v10 + 72) = v46;
            *(void *)(v10 + 80) = v48;
            unint64_t v43 = *(void *)(v10 + 64);
            goto LABEL_54;
          }
          free(v47);
LABEL_82:
          *uint64_t v29 = 0;
          *(void *)(v10 + 72) = 0;
          *(void *)(v10 + 80) = 0;
          goto LABEL_83;
        }
        unint64_t v43 = v42;
      }
      size_t v46 = v42;
LABEL_54:
      if (v46 - v43 >= v40) {
        size_t v49 = v40;
      }
      else {
        size_t v49 = v46 - v43;
      }
      ssize_t v50 = AAByteStreamRead(a3, (void *)(*(void *)(v10 + 80) + v43), v49);
      if (v50 < 0) {
        goto LABEL_83;
      }
      if (!v50) {
        break;
      }
      unint64_t v43 = *v29 + v50;
      if (!__CFADD__(*v29, v50))
      {
        unint64_t v42 = *(void *)(v10 + 72);
        if (v43 <= v42) {
          continue;
        }
      }
      goto LABEL_83;
      *uint64_t v29 = v43;
      v41 += v50;
      v40 -= v50;
    }
    while (v40);
    if (v41 < 0) {
      goto LABEL_83;
    }
  }
  if (!*((void *)a3 + 2))
  {
LABEL_83:
    int v15 = "loading state";
    __int16 v16 = 491;
    goto LABEL_24;
  }
  uint64_t v51 = 16 * *v26;
  if (v51)
  {
    uint64_t v52 = 0;
    uint64_t v53 = *(void *)(v10 + 120);
    while (1)
    {
      uint64_t v54 = (*((uint64_t (**)(void, uint64_t, uint64_t))a3 + 2))(*(void *)a3, v53, v51);
      if (v54 < 0) {
        goto LABEL_83;
      }
      if (v54)
      {
        v53 += v54;
        v52 += v54;
        v51 -= v54;
        if (v51) {
          continue;
        }
      }
      if (v52 < 0) {
        goto LABEL_83;
      }
      break;
    }
  }
  if ((_BYTE)v61)
  {
    uint64_t v55 = AAAFSCStreamOpenWithState(*(_DWORD *)v10, a3, 0, v21, v22, v23, v12, v13);
    *(void *)(v10 + 40) = v55;
    if (!v55)
    {
      int v15 = "loading AFSC stream state";
      __int16 v16 = 495;
      goto LABEL_24;
    }
  }
  if (a4) {
    *a4 = *(void *)(v10 + 24);
  }
  *uint64_t v8 = v10;
  v8[1] = afStreamClose;
  v8[7] = afStreamCancel;
  v8[3] = afStreamWrite;
  v8[12] = afStreamCloseWithState;
  return v8;
}

uint64_t fullReplacementBXPatch5(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  int v34 = 0;
  uint64_t v12 = *(void *)(a1 + 32);
  if (a5 >= 1) {
    fwrite("Full replacement patch\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  if (v12 + 60 <= a2)
  {
    if (v12 + 60 < a2) {
      fwrite("Extra bytes in patch (ignored)", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    int v14 = (char *)malloc(0x20000uLL);
    if (v14)
    {
      uint64_t v17 = ILowMemoryDecoderStreamCreateWithBuffer(a1 + 60, v12, 0x20000uLL);
      if (v17)
      {
        long long v18 = (CC_SHA1_CTX *)OSHA1StreamCreate(a3, 0, a4);
        if (v18)
        {
          uint64_t v19 = v18;
          unint64_t v20 = *(void *)(a1 + 16);
          if (v20)
          {
            unint64_t v21 = 0;
            while (1)
            {
              unint64_t v22 = v20 - v21;
              if (v22 >= 0x20000) {
                size_t v23 = 0x20000;
              }
              else {
                size_t v23 = v22;
              }
              if (ILowMemoryDecoderStreamRead(v17, v14, v23) != v23)
              {
                uint64_t v26 = "reading from payload stream";
                __int16 v27 = 62;
                goto LABEL_32;
              }
              if (OSHA1StreamWrite(v19, v14, v23) != v23) {
                break;
              }
              v21 += v23;
              unint64_t v20 = *(void *)(a1 + 16);
              if (v21 >= v20) {
                goto LABEL_18;
              }
            }
            uint64_t v26 = "writing to digest stream";
            __int16 v27 = 64;
          }
          else
          {
LABEL_18:
            OSHA1StreamDestroy(v19, (unsigned __int8 *)&v32);
            if (v32 == *(void *)(a1 + 40)
              && v33 == *(void *)(a1 + 48)
              && v34 == (unint64_t)*(unsigned int *)(a1 + 56))
            {
              uint64_t v13 = 0;
LABEL_34:
              free(v14);
              ILowMemoryDecoderStreamDestroy(v17);
              return v13;
            }
            uint64_t v26 = "Invalid output digest after patch application";
            __int16 v27 = 71;
          }
        }
        else
        {
          uint64_t v26 = "Digest stream init";
          __int16 v27 = 52;
        }
      }
      else
      {
        uint64_t v26 = "Payload stream init";
        __int16 v27 = 51;
      }
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", v27, 42, 0, v26, v15, v16, v32);
    }
    else
    {
      unint64_t v28 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 50, 42, *v28, "malloc", v29, v30, v32);
      uint64_t v17 = 0;
    }
    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 45, 42, 0, "Missing bytes in patch", a7, a8, v32);
  return 0xFFFFFFFFLL;
}

uint64_t BXDiff5GetPatchInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 < 8) {
    return 0xFFFFFFFFLL;
  }
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 >= 0x3C && *(void *)a1 == 0x3035464649445842)
  {
    uint64_t result = 0;
    *(void *)a3 = *(void *)(a1 + 16);
    int v5 = *(_DWORD *)(a1 + 12) & 1;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8) == 0;
    *(_DWORD *)(a3 + 12) = v5;
  }
  return result;
}

uint64_t BXPatch5StreamWithFlags(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t (*a6)(uint64_t, void *, uint64_t), uint64_t a7, uint64_t a8)
{
  uint64_t v157 = *MEMORY[0x263EF8340];
  if (a5 <= 0x3B)
  {
    uint64_t v8 = "Invalid patch size";
    __int16 v9 = 264;
    goto LABEL_50;
  }
  if (*(void *)a4 != 0x3035464649445842)
  {
    uint64_t v8 = "Invalid patch header";
    __int16 v9 = 265;
    goto LABEL_50;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 8);
  unint64_t v13 = 28 * v12 + 60;
  if (v13 > a5)
  {
    uint64_t v8 = "Invalid patch size";
    __int16 v9 = 269;
    goto LABEL_50;
  }
  int v16 = a8 & 1;
  uint64_t v17 = *(void *)(a4 + 24);
  BOOL v18 = __CFADD__(v13, v17);
  uint64_t v19 = v13 + v17;
  if (v18) {
    uint64_t v19 = -1;
  }
  if (!v12)
  {
    uint64_t v39 = *(void *)(a4 + 32);
    BOOL v18 = __CFADD__(v19, v39);
    unint64_t v40 = v19 + v39;
    if (v18) {
      unint64_t v40 = -1;
    }
    if (v40 <= a5)
    {
      return fullReplacementBXPatch5(a4, a5, (uint64_t)a6, a7, a8 & 1, (uint64_t)a6, a7, a8);
    }
    goto LABEL_42;
  }
  uint64_t v23 = *(unsigned int *)(a4 + 8);
  size_t v24 = (uint64_t *)(a4 + 60);
  do
  {
    uint64_t v25 = *v24;
    size_t v24 = (uint64_t *)((char *)v24 + 28);
    BOOL v18 = __CFADD__(v19, v25);
    v19 += v25;
    if (v18) {
      uint64_t v19 = -1;
    }
    --v23;
  }
  while (v23);
  uint64_t v26 = *(void *)(a4 + 32);
  BOOL v18 = __CFADD__(v19, v26);
  unint64_t v27 = v19 + v26;
  if (v18) {
    unint64_t v27 = -1;
  }
  if (v27 > a5)
  {
LABEL_42:
    uint64_t v8 = "Invalid patch size";
    __int16 v9 = 278;
    goto LABEL_50;
  }
  uint64_t v151 = (uint64_t *)(a4 + 60);
  *(void *)md = 0;
  uint64_t v155 = 0;
  int v156 = 0;
  memset(&c, 0, sizeof(c));
  unint64_t v28 = malloc(0x40000uLL);
  if (!v28)
  {
    int v42 = *__error();
    unint64_t v43 = "malloc";
    __int16 v44 = 156;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"getStreamSHA1Digest", v44, 42, v42, v43, v32, v33, v130);
    free(v28);
    goto LABEL_49;
  }
  int v149 = v16;
  CC_SHA1_Deprecated_Init(&c);
  unint64_t v29 = 0;
  if (a3)
  {
    while (1)
    {
      uint64_t v30 = v29 + 0x40000 <= a3 ? 0x40000 : a3 - v29;
      uint64_t v31 = a1(a2, v28, v30, v29);
      if (v31 <= 0) {
        break;
      }
      uint64_t v34 = v31;
      CC_SHA1_Deprecated_Update(&c, v28, v31);
      v29 += v34;
      if (v29 >= a3) {
        goto LABEL_27;
      }
    }
    unint64_t v43 = "inProc read";
    __int16 v44 = 165;
    int v42 = 0;
    goto LABEL_48;
  }
LABEL_27:
  CC_SHA1_Deprecated_Final(md, &c);
  free(v28);
  if (v29 != a3)
  {
LABEL_49:
    uint64_t v8 = "Input digest failed";
    __int16 v9 = 285;
    goto LABEL_50;
  }
  if (!v149)
  {
    uint64_t v36 = a4 + 40;
    if (*(void *)md != *(void *)(a4 + 40)
      || v155 != *(void *)(a4 + 48)
      || v156 != (unint64_t)*(unsigned int *)(a4 + 56))
    {
      goto LABEL_58;
    }
LABEL_78:
    if ((copyStream(a1, a2, a3, a6, a7) & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v8 = "Output copy failed\n";
    __int16 v9 = 293;
LABEL_50:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v9, 42, 0, v8, a7, a8, v130);
    return 0xFFFFFFFFLL;
  }
  unint64_t v45 = (FILE **)MEMORY[0x263EF8348];
  fprintf((FILE *)*MEMORY[0x263EF8348], "Input variants in patch: %u\n", *(_DWORD *)(a4 + 8));
  uint64_t v36 = a4 + 40;
  if (*(void *)md == *(void *)(a4 + 40)
    && v155 == *(void *)(a4 + 48)
    && v156 == (unint64_t)*(unsigned int *)(a4 + 56))
  {
    fwrite("No-op patch matching, writing input\n", 0x24uLL, 1uLL, *v45);
    goto LABEL_78;
  }
LABEL_58:
  uint64_t v48 = *(unsigned int *)(a4 + 8);
  if (!v48)
  {
LABEL_68:
    uint64_t v8 = "Input doesn't match any of the expected patch inputs";
    __int16 v9 = 310;
    goto LABEL_50;
  }
  uint64_t v49 = 0;
  uint64_t v50 = a4 + 68;
  while (1)
  {
    BOOL v51 = *(void *)md == *(void *)v50 && v155 == *(void *)(v50 + 8);
    if (v51 && v156 == (unint64_t)*(unsigned int *)(v50 + 16)) {
      break;
    }
    ++v49;
    v50 += 28;
    if (v48 == v49) {
      goto LABEL_68;
    }
  }
  uint64_t v146 = v49;
  if (v149)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Patch matching entry %u\n", v49);
    uint64_t v49 = v146;
    uint64_t v48 = *(unsigned int *)(a4 + 8);
  }
  uint64_t v135 = v36;
  uint64_t v53 = v151;
  uint64_t v142 = (uint64_t)v151 + 28 * v48;
  uint64_t v144 = *(void *)(a4 + 24);
  uint64_t v54 = v142 + v144;
  if (v48)
  {
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    do
    {
      if (v49 == v55) {
        uint64_t v56 = v54;
      }
      uint64_t v57 = *v53;
      uint64_t v53 = (uint64_t *)((char *)v53 + 28);
      v54 += v57;
      ++v55;
    }
    while (v48 != v55);
  }
  else
  {
    uint64_t v56 = 0;
  }
  uint64_t v138 = *(void *)(a4 + 32);
  uint64_t v140 = *(void *)(v50 - 8);
  if (v54 + v138 - a4 != a5)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 331, 42, "Warning: extra bytes in patch (ignored)\n", v35, a7, a8, v130);
    LODWORD(v48) = *(_DWORD *)(a4 + 8);
  }
  unint64_t v137 = *(void *)(a4 + 16);
  uint64_t v58 = 8 * (v48 + 2);
  v152 = (char *)malloc(0x20000uLL);
  long long v59 = malloc(0x20000uLL);
  size_t v136 = v58;
  size_t v60 = v58;
  __int16 v61 = v152;
  size_t v150 = malloc(v60);
  enterThreadErrorContext((uint64_t)v150, v62, v63, v64, v65, v66, v67, v68, v130);
  size_t v148 = v59;
  if (!v59 || !v152 || !v150)
  {
    int v112 = *__error();
    long long v113 = "malloc";
    __int16 v114 = 351;
LABEL_135:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v114, 42, v112, v113, v69, v70, v131);
    uint64_t v115 = 0;
    uint64_t v73 = 0;
    uint64_t v116 = 0;
    long long v109 = 0;
    long long v110 = 0;
    unsigned int v111 = -1;
    long long v91 = v148;
    goto LABEL_157;
  }
  uint64_t v145 = ILowMemoryDecoderStreamCreateWithBuffer(v142, v144, 0x20000uLL);
  if (!v145)
  {
    long long v113 = "Control stream init";
    __int16 v114 = 352;
    int v112 = 0;
    goto LABEL_135;
  }
  uint64_t v73 = ILowMemoryDecoderStreamCreateWithBuffer(v56, v140, 0x20000uLL);
  if (!v73)
  {
    uint64_t v117 = "Diff stream init";
    __int16 v118 = 353;
LABEL_138:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v118, 42, 0, v117, v71, v72, v131);
    uint64_t v116 = 0;
    long long v109 = 0;
    long long v110 = 0;
    unsigned int v111 = -1;
    long long v91 = v148;
    uint64_t v115 = v145;
    goto LABEL_157;
  }
  uint64_t v143 = ILowMemoryDecoderStreamCreateWithBuffer(v54, v138, 0x20000uLL);
  if (!v143)
  {
    uint64_t v117 = "Archive stream init";
    __int16 v118 = 354;
    goto LABEL_138;
  }
  long long v74 = (CC_SHA1_CTX *)OSHA1StreamCreate((uint64_t)a6, 0, a7);
  if (!v74)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 355, 42, 0, "Digest stream init", v75, v76, v131);
    long long v109 = 0;
    long long v110 = 0;
    unsigned int v111 = -1;
    long long v91 = v148;
    uint64_t v115 = v145;
LABEL_143:
    uint64_t v116 = v143;
    goto LABEL_157;
  }
  uint64_t v139 = v73;
  uint64_t v134 = v74;
  uint64_t v141 = OBufferedStreamCreate((uint64_t)OSHA1StreamWrite, (uint64_t)OSHA1StreamAbort, (uint64_t)v74, 0x20000uLL);
  if (!v141)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 356, 42, 0, "OBufferedStreamCreate", v82, v83, v131);
    long long v109 = 0;
    unsigned int v111 = -1;
    __int16 v61 = v152;
    long long v91 = v148;
    uint64_t v116 = v143;
    uint64_t v115 = v145;
    goto LABEL_156;
  }
  if (!v137)
  {
LABEL_125:
    OBufferedStreamDestroy((void ***)v141, v77, v78, v79, v80, v81, v82, v83);
    OSHA1StreamDestroy(v134, md);
    if (*(void *)md == *(void *)v135
      && v155 == *(void *)(v135 + 8)
      && v156 == (unint64_t)*(unsigned int *)(v135 + 16))
    {
      long long v109 = 0;
      long long v110 = 0;
      unsigned int v111 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 421, 42, 0, "Invalid output digest after patch application", v105, v106, v131);
      long long v109 = 0;
      long long v110 = 0;
      unsigned int v111 = -1;
    }
    __int16 v61 = v152;
    long long v91 = v148;
    uint64_t v115 = v145;
    uint64_t v73 = v139;
    goto LABEL_143;
  }
  unint64_t v84 = 0;
  uint64_t v85 = 0;
  uint64_t v133 = (v146 + 2);
  while (1)
  {
    if (ILowMemoryDecoderStreamRead(v145, (char *)v150, v136) != v136)
    {
      long long v121 = "reading from control stream";
      __int16 v122 = 362;
      goto LABEL_153;
    }
    uint64_t v86 = *((void *)v150 + 1);
    if (*(uint64_t *)v150 >= 0) {
      unint64_t v87 = *(void *)v150;
    }
    else {
      unint64_t v87 = 0x8000000000000000 - *(void *)v150;
    }
    unint64_t v88 = 0x8000000000000000 - v86;
    if (v86 >= 0) {
      unint64_t v88 = *((void *)v150 + 1);
    }
    unint64_t v147 = v88;
    uint64_t v89 = *((void *)v150 + v133);
    if (v89 < 0) {
      uint64_t v89 = 0x8000000000000000 - v89;
    }
    uint64_t v132 = v89;
    if (v85 < 0 || v87 + v85 > a3)
    {
      long long v121 = "Invalid in segment in patch";
      __int16 v122 = 369;
      goto LABEL_153;
    }
    if (v87 + v84 + v147 > *(void *)(a4 + 16))
    {
      long long v121 = "Invalid out segment in patch";
      __int16 v122 = 370;
LABEL_153:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v122, 42, 0, v121, v82, v83, v131);
      unsigned int v111 = -1;
      __int16 v61 = v152;
LABEL_154:
      long long v91 = v148;
      goto LABEL_155;
    }
    if (v87) {
      break;
    }
LABEL_116:
    if (v147)
    {
      unint64_t v99 = 0;
      unint64_t v100 = v147;
      while (1)
      {
        unint64_t v101 = v100 - v99;
        if (v101 >= 0x20000) {
          size_t v102 = 0x20000;
        }
        else {
          size_t v102 = v101;
        }
        if (ILowMemoryDecoderStreamRead(v143, v152, v102) != v102)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 405, 42, 0, "reading from archive stream", v103, v104, v131);
          unsigned int v111 = -1;
          __int16 v61 = v152;
          goto LABEL_154;
        }
        if (OBufferedStreamWrite((unint64_t **)v141, v152, v102) != v102) {
          break;
        }
        v99 += v102;
        v84 += v102;
        unint64_t v100 = v147;
        if (v99 >= v147) {
          goto LABEL_124;
        }
      }
      long long v121 = "writing to digest stream";
      __int16 v122 = 407;
      goto LABEL_153;
    }
LABEL_124:
    v85 += v132;
    if (v84 >= v137) {
      goto LABEL_125;
    }
  }
  unint64_t v90 = 0;
  long long v91 = v148;
  unint64_t v92 = v87;
  while (1)
  {
    unint64_t v93 = v92 - v90;
    if (v93 >= 0x20000) {
      size_t v94 = 0x20000;
    }
    else {
      size_t v94 = v93;
    }
    if (ILowMemoryDecoderStreamRead(v139, v152, v94) != v94)
    {
      unint64_t v119 = "reading from diff stream";
      __int16 v120 = 379;
      goto LABEL_147;
    }
    if (a1(a2, v148, v94, v85) != v94)
    {
      unint64_t v119 = "reading from input stream";
      __int16 v120 = 381;
      goto LABEL_147;
    }
    long long v95 = (char *)v148;
    long long v96 = v152;
    for (size_t i = v94; i; --i)
    {
      char v98 = *v95++;
      *v96++ += v98;
    }
    if (OBufferedStreamWrite((unint64_t **)v141, v152, v94) != v94) {
      break;
    }
    v90 += v94;
    v85 += v94;
    v84 += v94;
    unint64_t v92 = v87;
    if (v90 >= v87) {
      goto LABEL_116;
    }
  }
  unint64_t v119 = "writing to digest stream";
  __int16 v120 = 390;
LABEL_147:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v120, 42, 0, v119, v82, v83, v131);
  unsigned int v111 = -1;
  __int16 v61 = v152;
LABEL_155:
  uint64_t v116 = v143;
  uint64_t v115 = v145;
  uint64_t v73 = v139;
  long long v109 = (void ***)v141;
LABEL_156:
  long long v110 = v134;
LABEL_157:
  free(v150);
  free(v61);
  free(v91);
  OBufferedStreamDestroy(v109, v123, v124, v125, v126, v127, v128, v129);
  OSHA1StreamDestroy(v110, md);
  ILowMemoryDecoderStreamDestroy(v115);
  ILowMemoryDecoderStreamDestroy(v73);
  ILowMemoryDecoderStreamDestroy(v116);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return v111;
  }
  else {
    return result;
  }
}

uint64_t BXPatch5FileWithFlags(const char *a1, uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5, uint64_t a6)
{
  char v11 = (char)a1;
  st_uint64_t size = 0;
  memset(&v22, 0, sizeof(v22));
  unsigned int v12 = open(a1, 0);
  uint64_t v23 = v12;
  if ((v12 & 0x80000000) != 0)
  {
    BOOL v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 235, 42, *v18, "open: %s", v19, v20, v11);
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v13 = v12;
    if (fstat(v12, &v22))
    {
      int v14 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 236, 42, *v14, "fstat: %s", v15, v16, v11);
      uint64_t v17 = 0xFFFFFFFFLL;
LABEL_6:
      close(v13);
      return v17;
    }
    st_uint64_t size = v22.st_size;
    uint64_t v17 = BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsFileStreamPRead, (uint64_t)&v23, v22.st_size, a2, a3, a4, a5, a6);
    int v13 = v23;
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  return v17;
}

ssize_t BXPatch5WithFlagsFileStreamPRead(uint64_t a1, void *a2, size_t a3, off_t a4)
{
  if (!a3) {
    return 0;
  }
  ssize_t result = -1;
  if (!__CFADD__(a4, a3) && a4 + a3 <= *(void *)(a1 + 8)) {
    return pread(*(_DWORD *)a1, a2, a3, a4);
  }
  return result;
}

uint64_t copyStream(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5)
{
  uint64_t v10 = malloc(0x40000uLL);
  if (!v10)
  {
    int v18 = *__error();
    uint64_t v19 = "malloc";
    __int16 v20 = 188;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"copyStream", v20, 42, v18, v19, v14, v15, v22);
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  unint64_t v11 = 0;
  if (a3)
  {
    while (1)
    {
      if (v11 + 0x40000 <= a3) {
        uint64_t v12 = 0x40000;
      }
      else {
        uint64_t v12 = a3 - v11;
      }
      uint64_t v13 = a1(a2, v10, v12, v11);
      if (v13 <= 0)
      {
        uint64_t v19 = "inProc read";
        __int16 v20 = 196;
        goto LABEL_15;
      }
      uint64_t v16 = a4(a5, v10, v13);
      if (v16 <= 0) {
        break;
      }
      v11 += v16;
      if (v11 >= a3) {
        goto LABEL_9;
      }
    }
    uint64_t v19 = "outProc write";
    __int16 v20 = 198;
LABEL_15:
    int v18 = 0;
    goto LABEL_16;
  }
LABEL_9:
  if (v11 == a3) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = 0xFFFFFFFFLL;
  }
LABEL_17:
  free(v10);
  return v17;
}

uint64_t BXPatch5InPlace(const char *a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v152 = *MEMORY[0x263EF8340];
  if (a3 <= 0x3B)
  {
    uint64_t v8 = "Invalid patch size";
    __int16 v9 = 441;
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v9, 42, 0, v8, a7, a8, v125);
    return 0xFFFFFFFFLL;
  }
  if (*(void *)a2 != 0x3035464649445842)
  {
    uint64_t v8 = "Invalid patch header";
    __int16 v9 = 442;
    goto LABEL_29;
  }
  if ((*(unsigned char *)(a2 + 12) & 1) == 0)
  {
    uint64_t v8 = "Patch can't be applied in-place";
    __int16 v9 = 445;
    goto LABEL_29;
  }
  if (a4 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Input variants in patch: %u\n", *(_DWORD *)(a2 + 8));
  }
  uint64_t v149 = 0;
  uint64_t v150 = 0;
  int v151 = 0;
  uint64_t FileSHA1Digest = getFileSHA1Digest(a1, (uint64_t)&v149);
  if (FileSHA1Digest)
  {
    uint64_t v8 = "computing file digest";
    __int16 v9 = 450;
    goto LABEL_29;
  }
  if (v149 == *(void *)(a2 + 40)
    && v150 == *(void *)(a2 + 48)
    && v151 == (unint64_t)*(unsigned int *)(a2 + 56))
  {
    if (a4 >= 1) {
      fwrite("No-op patch matching, do nothing\n", 0x21uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    return 0;
  }
  uint64_t v22 = *(unsigned int *)(a2 + 8);
  if (!v22)
  {
LABEL_28:
    uint64_t v8 = "Input doesn't match any of the expected patch inputs (in-place)";
    __int16 v9 = 467;
    goto LABEL_29;
  }
  uint64_t v23 = 0;
  size_t v24 = (uint64_t *)(a2 + 60);
  uint64_t v25 = a2 + 68;
  while (1)
  {
    BOOL v26 = v149 == *(void *)v25 && v150 == *(void *)(v25 + 8);
    if (v26 && v151 == (unint64_t)*(unsigned int *)(v25 + 16)) {
      break;
    }
    ++v23;
    v25 += 28;
    if (v22 == v23) {
      goto LABEL_28;
    }
  }
  if (a4 >= 1)
  {
    uint64_t FileSHA1Digest = fprintf((FILE *)*MEMORY[0x263EF8348], "In-place patch matching entry %u\n", v23);
    uint64_t v22 = *(unsigned int *)(a2 + 8);
  }
  uint64_t v29 = (uint64_t)v24 + 28 * v22 + *(void *)(a2 + 24);
  uint64_t v147 = *(void *)(a2 + 24);
  uint64_t v143 = (char *)v24 + 28 * v22;
  if (v22)
  {
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    do
    {
      if (v23 == v30) {
        uint64_t v31 = v29;
      }
      uint64_t v32 = *v24;
      size_t v24 = (uint64_t *)((char *)v24 + 28);
      v29 += v32;
      ++v30;
    }
    while (v22 != v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v33 = *(void *)(v25 - 8);
  uint64_t v128 = *(void *)(a2 + 32);
  if (v29 + v128 - a2 != a3)
  {
    uint64_t FileSHA1Digest = pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 489, 42, "Warning: extra bytes in patch (ignored)\n", v19, a7, a8, v125);
    LODWORD(v22) = *(_DWORD *)(a2 + 8);
  }
  enterThreadErrorContext(FileSHA1Digest, v15, v16, v17, v18, v19, a7, a8, v125);
  uint64_t v134 = malloc(0x1000uLL);
  if (!v134)
  {
    int v54 = *__error();
    __int16 v57 = 511;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v57, 42, v54, "malloc", v55, v56, v126);
    unint64_t v40 = 0;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    goto LABEL_95;
  }
  uint64_t v34 = malloc(0x1000uLL);
  if (!v34)
  {
    int v54 = *__error();
    __int16 v57 = 513;
    goto LABEL_62;
  }
  char v130 = v34;
  uint64_t v135 = (v22 + 2);
  uint64_t v136 = 8 * v135;
  uint64_t v133 = (char *)malloc(8 * v135);
  uint64_t v35 = ILowMemoryDecoderStreamCreateWithBuffer((uint64_t)v143, v147, 0x1000uLL);
  if (!v35)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 517, 42, 0, "Control stream init", v36, v37, v126);
    unint64_t v40 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
LABEL_64:
    uint64_t v66 = v130;
    uint64_t v65 = v133;
    goto LABEL_95;
  }
  uint64_t v127 = v33;
  uint64_t v139 = v35;
  uint64_t v140 = 0;
  unsigned int v38 = 0;
  unint64_t v39 = 0;
  unint64_t v40 = 0;
  uint64_t v41 = v133;
  for (size_t i = 8 * (v22 + 2); ; v38 = &v144[i])
  {
    uint64_t v144 = v38;
    uint64_t v148 = v39;
    if (v39 == v140)
    {
      uint64_t v43 = v39 + (v39 >> 1);
      if (v39 >> 5 <= 0xC34) {
        uint64_t v43 = 2 * v39;
      }
      if (!v39) {
        uint64_t v43 = 2000;
      }
      uint64_t v140 = v43;
      __int16 v44 = (char *)reallocf(v40, i * v43);
      size_t i = 8 * (v22 + 2);
      uint64_t v41 = v133;
      unint64_t v40 = v44;
      if (!v44)
      {
        uint64_t v65 = v133;
        int v94 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 527, 42, v94, "malloc", v95, v96, v126);
LABEL_92:
        uint64_t v67 = 0;
        uint64_t v68 = 0;
        uint64_t v69 = 0;
        uint64_t v66 = v130;
LABEL_94:
        uint64_t v70 = v139;
        goto LABEL_95;
      }
    }
    uint64_t v45 = ILowMemoryDecoderStreamRead(v139, v41, i);
    if (!v45) {
      break;
    }
    uint64_t v48 = (uint64_t *)v41;
    uint64_t v49 = v144;
    uint64_t v50 = (v22 + 2);
    if (v45 != i)
    {
      uint64_t v65 = v41;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 533, 42, 0, "reading from control stream S=%lld", v46, v47, v45);
      goto LABEL_92;
    }
    do
    {
      uint64_t v52 = *v48++;
      uint64_t v51 = v52;
      unint64_t v53 = 0x8000000000000000 - v52;
      if (v52 < 0) {
        uint64_t v51 = v53;
      }
      *(void *)&v49[(void)v40] = v51;
      v49 += 8;
      --v50;
    }
    while (v50);
    unint64_t v39 = v148 + 1;
  }
  if (a4 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%zu controls in patch (%zu B allocated)\n", v148, v136 * v140);
  }
  uint64_t v71 = PagedFileCreate(a1, *(void *)(a2 + 16), 0x2800000uLL, a4);
  if (!v71)
  {
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v66 = v130;
    uint64_t v65 = v133;
    goto LABEL_94;
  }
  uint64_t v67 = v71;
  if (v148)
  {
    unint64_t v72 = 0;
    uint64_t v73 = (unint64_t *)v40;
    uint64_t v74 = v148;
    do
    {
      unint64_t v131 = *v73;
      unint64_t v141 = v72;
      uint64_t v145 = (void *)v73[(v23 + 2)];
      PagedFileRetainIn(v67, v72, *v73, v60, v61, v62, v63, v64);
      unint64_t v72 = (unint64_t)v145 + v131 + v141;
      uint64_t v73 = (unint64_t *)((char *)v73 + v136);
      --v74;
    }
    while (v74);
  }
  PagedFileReleaseAllIn((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
  if (a4 > 1) {
    PagedFileDump((uint64_t)v67, "Input retained");
  }
  uint64_t v75 = ILowMemoryDecoderStreamCreateWithBuffer(v31, v127, 0x1000uLL);
  uint64_t v70 = v139;
  if (!v75)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 563, 42, 0, "Diff stream init", v76, v77, v126);
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    goto LABEL_64;
  }
  uint64_t v142 = v75;
  uint64_t v146 = v67;
  if (v148)
  {
    uint64_t v78 = 0;
    unint64_t v79 = 0;
    unint64_t v80 = 0;
    uint64_t v81 = (v23 + 2);
    uint64_t v82 = (char *)v130;
    uint64_t v129 = v81;
    while (1)
    {
      uint64_t v83 = (unint64_t *)((char *)v40 + 8 * v78 * v135);
      unint64_t v84 = *v83;
      unint64_t v85 = v83[1];
      unint64_t v137 = v83[v81];
      if (a4 >= 3)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "DIFF STREAM: I=%zu OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu IDELTA=%lld\n", v78, v79, v80, v84, v85, v137);
        PagedFileDump((uint64_t)v146, "Before applying control");
        uint64_t v82 = (char *)v130;
      }
      unint64_t v132 = v85;
      if (v84) {
        break;
      }
LABEL_88:
      v80 += v137;
      v79 += v132;
      ++v78;
      uint64_t v81 = v129;
      if (v78 == v148) {
        goto LABEL_105;
      }
    }
    while (1)
    {
      if (v84 >= 0x1000) {
        size_t v86 = 4096;
      }
      else {
        size_t v86 = v84;
      }
      if (ILowMemoryDecoderStreamRead(v142, v82, v86) != v86)
      {
        unint64_t v119 = "reading from diff stream";
        __int16 v120 = 584;
        goto LABEL_130;
      }
      if (PagedFileReadAndReleaseIn((uint64_t)v146, v80, v86, (uint64_t)v134, v87, v88, v89, v90))
      {
        unint64_t v119 = "reading from input stream";
        __int16 v120 = 587;
        goto LABEL_130;
      }
      for (uint64_t j = 0; j != v86; ++j)
        *((unsigned char *)v130 + j) += v134[j];
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v79, v86, (uint64_t)v130, v91, v92, v89, v90)) {
        break;
      }
      v80 += v86;
      v79 += v86;
      v84 -= v86;
      uint64_t v82 = (char *)v130;
      if (!v84) {
        goto LABEL_88;
      }
    }
    unint64_t v119 = "writing output";
    __int16 v120 = 593;
LABEL_130:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v120, 42, 0, v119, v89, v90, v126);
    uint64_t v68 = 0;
LABEL_137:
    uint64_t v66 = v130;
LABEL_138:
    uint64_t v65 = v133;
    uint64_t v70 = v139;
    uint64_t v67 = v146;
LABEL_139:
    uint64_t v69 = v142;
LABEL_95:
    PagedFileDestroy((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
    free(v40);
    free(v65);
    free(v134);
    free(v66);
    ILowMemoryDecoderStreamDestroy(v70);
    ILowMemoryDecoderStreamDestroy(v69);
    ILowMemoryDecoderStreamDestroy(v68);
LABEL_96:
    int v97 = 0;
    goto LABEL_97;
  }
  unint64_t v80 = 0;
LABEL_105:
  uint64_t v67 = v146;
  if (a4 >= 2) {
    PagedFileDump((uint64_t)v146, "Diff stream applied");
  }
  if (!PagedFileHasNoIn((uint64_t)v146))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 608, 42, 0, "some input bytes are still mapped after diff expansion", v99, v100, v126);
    uint64_t v68 = 0;
    uint64_t v66 = v130;
    uint64_t v65 = v133;
    uint64_t v70 = v139;
    goto LABEL_139;
  }
  uint64_t v68 = ILowMemoryDecoderStreamCreateWithBuffer(v29, v128, 0x1000uLL);
  if (!v68)
  {
    long long v121 = "Archive stream init";
    __int16 v122 = 611;
LABEL_136:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v122, 42, 0, v121, v101, v102, v126);
    goto LABEL_137;
  }
  if (v148)
  {
    uint64_t v138 = 0;
    unint64_t v103 = 0;
    while (1)
    {
      uint64_t v104 = (char *)v40 + 8 * v138 * v135;
      uint64_t v106 = *(void *)v104;
      unint64_t v105 = *((void *)v104 + 1);
      if (a4 >= 3) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "ARCHIVE STREAM: OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu\n", v103, v80, v106, v105);
      }
      v103 += v106;
      if (v105) {
        break;
      }
LABEL_121:
      if (++v138 == v148) {
        goto LABEL_122;
      }
    }
    uint64_t v66 = v130;
    while (1)
    {
      if (v105 >= 0x1000) {
        size_t v107 = 4096;
      }
      else {
        size_t v107 = v105;
      }
      if (ILowMemoryDecoderStreamRead(v68, (char *)v66, v107) != v107)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 630, 42, 0, "reading from archive stream", v110, v111, v126);
        goto LABEL_138;
      }
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v103, v107, (uint64_t)v66, v108, v109, v110, v111)) {
        break;
      }
      v103 += v107;
      v105 -= v107;
      uint64_t v66 = v130;
      if (!v105) {
        goto LABEL_121;
      }
    }
    long long v121 = "writing output";
    __int16 v122 = 633;
    goto LABEL_136;
  }
LABEL_122:
  if (a4 >= 2) {
    PagedFileDump((uint64_t)v146, "Archive stream applied");
  }
  if (!PagedFileHasAllOut((uint64_t)v146))
  {
    long long v121 = "some output bytes are missing or referenced more than once after archive expansion";
    __int16 v122 = 643;
    goto LABEL_136;
  }
  PagedFileDestroy((uint64_t)v146, v112, v113, v114, v115, v116, v101, v102);
  free(v40);
  free(v133);
  free(v134);
  free(v130);
  ILowMemoryDecoderStreamDestroy(v139);
  ILowMemoryDecoderStreamDestroy(v142);
  ILowMemoryDecoderStreamDestroy(v68);
  if (getFileSHA1Digest(a1, (uint64_t)&v149))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 658, 42, 0, "computing file digest", v117, v118, v126);
    int v97 = 0;
  }
  else
  {
    int v97 = 1;
  }
  if (v149 != *(void *)(a2 + 40)
    || v150 != *(void *)(a2 + 48)
    || v151 != (unint64_t)*(unsigned int *)(a2 + 56))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 659, 42, 0, "Invalid output digest", v117, v118, v126);
    goto LABEL_96;
  }
LABEL_97:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v97) {
    unsigned int v98 = 0;
  }
  else {
    unsigned int v98 = -1;
  }
  if ((int)result >= 0) {
    return v98;
  }
  else {
    return result;
  }
}

size_t PCompressLZVNEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_encode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result) {
    return -1;
  }
  return result;
}

size_t PCompressLZVNDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result = compression_decode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t AEADecryptInPlace(AAByteStream_impl *a1, AEAContext_impl *a2, uint64_t a3, uint64_t (*a4)(void, float), AAFlagSet a5, int a6)
{
  unint64_t v11 = (AAByteStream_impl *)aaInPlaceStreamOpen(a1);
  uint64_t v14 = v11;
  if (v11)
  {
    uint64_t v17 = AEADecryptionRandomAccessInputStreamOpen(v11, a2, 0xFFFFFFFFFFFFFFFFLL, a5, a6);
    if (v17)
    {
      uint64_t FieldUInt = AEAContextGetFieldUInt(a2, 0xDu);
      if ((FieldUInt & 0x8000000000000000) != 0)
      {
        __int16 v20 = "bad output size";
        __int16 v21 = 80;
      }
      else
      {
        if ((processWithProgress(v17, v14, 0, FieldUInt, a3, a4) & 0x80000000) == 0)
        {
          int v19 = 1;
          goto LABEL_12;
        }
        __int16 v20 = "processWithProgress";
        __int16 v21 = 83;
      }
    }
    else
    {
      __int16 v20 = "AEADecryptionRandomAccessInputStreamOpen";
      __int16 v21 = 76;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEADecryptInPlace", v21, 127, 0, v20, v15, v16, v25);
    AAByteStreamCancel(v14);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEADecryptInPlace", 72, 127, 0, "aaInPlaceStreamOpen", v12, v13, v25);
    uint64_t v17 = 0;
  }
  int v19 = 0;
LABEL_12:
  if (AAByteStreamClose(v17) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEADecryptInPlace", 87, 127, 0, "AAByteStreamClose", v22, v23, v25);
    int v19 = 0;
  }
  AAByteStreamClose(v14);
  if (v19) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t processWithProgress(AAByteStream_impl *a1, AAByteStream_impl *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void, float))
{
  uint64_t v8 = a4;
  if (a3 && a4)
  {
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = (char *)malloc(0x40000uLL);
    if (v12)
    {
      if (a3)
      {
        uint64_t v15 = a3;
        uint64_t v44 = a5;
        uint64_t v45 = v8;
LABEL_7:
        uint64_t v16 = v15;
        if (v15 >= 0x40000) {
          uint64_t v15 = 0x40000;
        }
        if (*((void *)a1 + 2))
        {
          uint64_t v17 = a6;
          uint64_t v18 = 0;
          int v19 = v12;
          uint64_t v20 = v15;
          while (1)
          {
            uint64_t v21 = (*((uint64_t (**)(void, char *, uint64_t))a1 + 2))(*(void *)a1, v19, v20);
            if (v21 < 0) {
              break;
            }
            if (v21)
            {
              v19 += v21;
              v18 += v21;
              v20 -= v21;
              if (v20) {
                continue;
              }
            }
            if (v18 <= 0) {
              break;
            }
            if (*((void *)a2 + 3))
            {
              uint64_t v22 = 0;
              uint64_t v23 = v12;
              uint64_t v24 = v15;
              while (1)
              {
                uint64_t v25 = (*((uint64_t (**)(void, char *, uint64_t))a2 + 3))(*(void *)a2, v23, v24);
                if (v25 < 1) {
                  break;
                }
                v23 += v25;
                v22 += v25;
                v24 -= v25;
                if (!v24)
                {
                  if (v22 <= 0) {
                    break;
                  }
                  uint64_t v15 = v16 - v15;
                  a6 = v17;
                  a5 = v44;
                  if (a6 && (a6(v44, (float)((float)(a3 - v15) * 100.0) / (float)a3) & 0x80000000) != 0)
                  {
                    unint64_t v40 = "progress_proc";
                    __int16 v41 = 33;
                    goto LABEL_48;
                  }
                  uint64_t v8 = v45;
                  if (v15) {
                    goto LABEL_7;
                  }
                  goto LABEL_23;
                }
              }
            }
            unint64_t v40 = "aaByteStreamWriteExpected";
            __int16 v41 = 31;
            goto LABEL_48;
          }
        }
        unint64_t v40 = "aaByteStreamReadExpected";
        __int16 v41 = 30;
      }
      else
      {
LABEL_23:
        if (!v8)
        {
LABEL_42:
          free(v12);
          return 0;
        }
        float v26 = (float)v8;
        uint64_t v27 = v8;
        uint64_t v43 = a6;
        uint64_t v46 = v8;
LABEL_25:
        if (v27 >= 0x40000) {
          uint64_t v28 = 0x40000;
        }
        else {
          uint64_t v28 = v27;
        }
        if (*((void *)a1 + 4))
        {
          uint64_t v29 = 0;
          v27 -= v28;
          uint64_t v30 = v12;
          uint64_t v31 = v27;
          uint64_t v32 = v28;
          while (1)
          {
            uint64_t v33 = (*((uint64_t (**)(void, char *, uint64_t, uint64_t))a1 + 4))(*(void *)a1, v30, v32, v31);
            if (v33 < 0) {
              break;
            }
            if (v33)
            {
              v30 += v33;
              v29 += v33;
              v31 += v33;
              v32 -= v33;
              if (v32) {
                continue;
              }
            }
            if (v29 <= 0) {
              break;
            }
            if (*((void *)a2 + 5))
            {
              uint64_t v34 = 0;
              uint64_t v35 = v12;
              uint64_t v36 = v27;
              while (1)
              {
                uint64_t v37 = (*((uint64_t (**)(void, char *, uint64_t, uint64_t))a2 + 5))(*(void *)a2, v35, v28, v36);
                if (v37 < 1) {
                  break;
                }
                v35 += v37;
                v34 += v37;
                v36 += v37;
                v28 -= v37;
                if (!v28)
                {
                  if (v34 <= 0) {
                    break;
                  }
                  if (v43 && (v43(a5, (float)((float)(v46 - v27) * 100.0) / v26) & 0x80000000) != 0)
                  {
                    unint64_t v40 = "progress_proc";
                    __int16 v41 = 43;
                    goto LABEL_48;
                  }
                  if (v27) {
                    goto LABEL_25;
                  }
                  goto LABEL_42;
                }
              }
            }
            unint64_t v40 = "aaByteStreamPWriteExpected";
            __int16 v41 = 42;
            goto LABEL_48;
          }
        }
        unint64_t v40 = "aaByteStreamPReadExpected";
        __int16 v41 = 41;
      }
LABEL_48:
      int v39 = 0;
    }
    else
    {
      int v39 = *__error();
      unint64_t v40 = "malloc";
      __int16 v41 = 24;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"processWithProgress", v41, 127, v39, v40, v13, v14, v42);
  }
  free(v12);
  AAByteStreamCancel(a1);
  AAByteStreamCancel(a2);
  return 0xFFFFFFFFLL;
}

uint64_t AEAEncryptInPlace(AAByteStream_impl *a1, AEAContext_impl *a2, uint64_t a3, uint64_t (*a4)(void, float), unint64_t a5, int a6)
{
  off_t v12 = AAByteStreamSeek(a1, 0, 2);
  if (v12 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", 106, 127, 0, "AAByteStreamSeek", v13, v14, v30);
    int v19 = 0;
LABEL_11:
    uint64_t v23 = 0;
LABEL_17:
    uint64_t v26 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
  uint64_t v15 = v12;
  uint64_t v16 = (AAByteStream_impl *)aaInPlaceStreamOpen(a1);
  int v19 = v16;
  if (!v16)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", 110, 127, 0, "aaInPlaceStreamOpen", v17, v18, v30);
    goto LABEL_11;
  }
  uint64_t v20 = 3;
  if (a5 < 3) {
    uint64_t v20 = a5;
  }
  uint64_t v23 = AEAEncryptionOutputStreamOpen(v16, a2, v20 << 62, a6);
  if (!v23)
  {
    uint64_t v27 = "AEAEncryptionOutputStreamOpen";
    __int16 v28 = 114;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", v28, 127, 0, v27, v21, v22, v30);
LABEL_16:
    AAByteStreamCancel(v19);
    goto LABEL_17;
  }
  if ((processWithProgress(v19, v23, v15, 0, a3, a4) & 0x80000000) != 0)
  {
    uint64_t v27 = "processWithProgress";
    __int16 v28 = 117;
    goto LABEL_14;
  }
  if (AEAEncryptionOutputStreamCloseAndUpdateContext(v23, a2) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAInplace.c", (uint64_t)"AEAEncryptInPlace", 121, 127, 0, "AEAEncryptionOutputStreamCloseAndUpdateContext", v24, v25, v30);
    uint64_t v23 = 0;
    goto LABEL_16;
  }
  uint64_t v23 = 0;
  uint64_t v26 = 0;
LABEL_18:
  AAByteStreamClose(v23);
  AAByteStreamClose(v19);
  return v26;
}

uint64_t AEAKeychainGenerateItem(int a1, unint64_t a2, unint64_t a3, void *bytes, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a1 == 1)
    {
      unint64_t v10 = (a2 + 7) >> 3;
      if (v10 <= a3)
      {
        uint64_t result = CCRandomGenerateBytes(bytes, (a2 + 7) >> 3);
        if (!result)
        {
          *a5 = v10;
          return result;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"RNG", 24, 96, 0, "generate random bytes", v15, v16, v26);
        unint64_t v11 = "RNG failed";
        __int16 v12 = 43;
      }
      else
      {
        unint64_t v11 = "Insufficient buffer capacity";
        __int16 v12 = 42;
      }
    }
    else
    {
      unint64_t v11 = "Invalid item type";
      __int16 v12 = 78;
    }
  }
  else
  {
    unint64_t v13 = vcvtps_u32_f32((float)a2 / 16.61);
    if (6 * v13 <= a3)
    {
      unsigned int bytesa = 0;
      if (!v13)
      {
LABEL_24:
        uint64_t result = 0;
        *((unsigned char *)bytes + v13) = 0;
        *a5 = v13;
        return result;
      }
      unsigned int v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      int v20 = 0;
      unint64_t v21 = 5 * v13;
      if (v21 <= 1) {
        uint64_t v22 = 1;
      }
      else {
        uint64_t v22 = v21;
      }
      while (1)
      {
        if (0xCCCCCCCCCCCCCCCDLL * v18 <= 0x3333333333333333 && v19 != 0) {
          *((unsigned char *)bytes + v19++) = 45;
        }
        if (!v20) {
          break;
        }
LABEL_23:
        unint64_t v13 = v19 + 1;
        *((unsigned char *)bytes + v19) = (v17 % 0xA) | 0x30;
        unsigned int bytesa = v17 / 0xA;
        --v20;
        ++v18;
        v17 /= 0xAu;
        ++v19;
        if (v18 == v22) {
          goto LABEL_24;
        }
      }
      while (!CCRandomGenerateBytes(&bytesa, 4uLL))
      {
        if (bytesa <= 0xEE6B27FF)
        {
          unsigned int v17 = bytesa % 0x3B9ACA00;
          int v20 = 9;
          goto LABEL_23;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"RNG", 24, 96, 0, "generate random bytes", v24, v25, v26);
      unint64_t v11 = "RNG failed";
      __int16 v12 = 64;
    }
    else
    {
      unint64_t v11 = "Insufficient buffer capacity";
      __int16 v12 = 52;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainGenerateItem", v12, 96, 0, v11, a7, a8, v26);
  return 0xFFFFFFFFLL;
}

uint64_t AEAKeychainStoreItem(unsigned __int8 *a1, uint64_t a2, int a3, const UInt8 *a4, CFIndex a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2 || !a5)
  {
    uint64_t v22 = "Invalid args";
    __int16 v23 = 178;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", v23, 96, 0, v22, a7, a8, v26);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v22 = "create attributes";
    __int16 v23 = 182;
    goto LABEL_10;
  }
  unint64_t v11 = Attributes;
  CFDataRef v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], a4, a5);
  if (!v12)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", 186, 96, 0, "create item data", v13, v14, v26);
    CFRelease(v11);
    return 0xFFFFFFFFLL;
  }
  CFDataRef v15 = v12;
  CFDictionaryAddValue(v11, (const void *)*MEMORY[0x263F175A8], v12);
  SecAccessControlRef v18 = SecAccessControlCreateWithFlags(0, (CFTypeRef)*MEMORY[0x263F16EC8], 1uLL, 0);
  if (!v18)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", 191, 96, 0, "create access control", v16, v17, v26);
    goto LABEL_15;
  }
  CFDictionaryAddValue(v11, (const void *)*MEMORY[0x263F16E70], v18);
  OSStatus v19 = SecItemAdd(v11, 0);
  if (v19)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainStoreItem", 196, 96, 0, "adding item to the keychain: %d", v20, v21, v19);
LABEL_15:
    uint64_t v24 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  uint64_t v24 = 0;
LABEL_17:
  CFRelease(v11);
  CFRelease(v15);
  if (v18) {
    CFRelease(v18);
  }
  return v24;
}

__CFDictionary *aeaKeychainCreateAttributes(unsigned __int8 *a1, uint64_t a2, int a3)
{
  uint64_t v6 = (const void **)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "kSecUseDataProtectionKeychain");
  if (!v6)
  {
    unint64_t v11 = "Keychain support not available";
    __int16 v12 = 115;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", v12, 96, 0, v11, v7, v8, v35);
    return 0;
  }
  __int16 v9 = *v6;
  if (a3)
  {
    if (a3 != 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 124, 96, 0, "Invalid item type %d", v7, v8, a3);
      return 0;
    }
    unint64_t v10 = "kAEA";
  }
  else
  {
    unint64_t v10 = "pAEA";
  }
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFNumberRef v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, v10);
  if (!v14)
  {
    unint64_t v11 = "create attributes";
    __int16 v12 = 128;
    goto LABEL_12;
  }
  CFNumberRef v15 = v14;
  size_t v16 = (2 * a2) | 1;
  if (v16 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_20:
    char v30 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 132, 96, *v30, "malloc", v31, v32, v35);
    uint64_t v33 = v15;
LABEL_21:
    CFRelease(v33);
    return 0;
  }
  uint64_t v17 = (const char *)malloc(v16);
  if (!v17) {
    goto LABEL_20;
  }
  SecAccessControlRef v18 = (char *)v17;
  uint64_t v19 = 2 * a2;
  if (a2)
  {
    uint64_t v20 = v17 + 1;
    do
    {
      unsigned int v21 = *a1++;
      *(v20 - 1) = aeaKeychainCreateAttributes_hex[(unint64_t)v21 >> 4];
      *uint64_t v20 = aeaKeychainCreateAttributes_hex[v21 & 0xF];
      v20 += 2;
      --a2;
    }
    while (a2);
  }
  v17[v19] = 0;
  CFStringRef v24 = CFStringCreateWithCString(v13, v17, 0x600u);
  if (v24)
  {
    Mutable = CFDictionaryCreateMutable(v13, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    __int16 v28 = Mutable;
    if (Mutable)
    {
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x263F171B8], (const void *)*MEMORY[0x263F171C8]);
      CFDictionaryAddValue(v28, v9, (const void *)*MEMORY[0x263EFFB40]);
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x263F17108], v15);
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x263F17090], @"AppleEncryptedArchive");
      CFDictionaryAddValue(v28, (const void *)*MEMORY[0x263F16ED8], v24);
      int v29 = 0;
      goto LABEL_27;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 144, 96, 0, "create attributes", v26, v27, v35);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"aeaKeychainCreateAttributes", 141, 96, 0, "create attributes", v22, v23, v35);
    __int16 v28 = 0;
  }
  int v29 = 1;
LABEL_27:
  free(v18);
  CFRelease(v15);
  if (v24) {
    CFRelease(v24);
  }
  if (v29 && v28)
  {
    uint64_t v33 = v28;
    goto LABEL_21;
  }
  return v28;
}

uint64_t AEAKeychainLoadItem(unsigned __int8 *a1, uint64_t a2, int a3, unint64_t a4, void *a5, size_t *a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result = 0;
  if (!a2)
  {
    uint64_t v17 = "Invalid args";
    __int16 v18 = 219;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainLoadItem", v18, 96, 0, v17, a7, a8, v28);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v17 = "create attributes";
    __int16 v18 = 223;
    goto LABEL_7;
  }
  CFDictionaryRef v12 = Attributes;
  CFDictionaryAddValue(Attributes, (const void *)*MEMORY[0x263F17520], (const void *)*MEMORY[0x263EFFB40]);
  OSStatus v13 = SecItemCopyMatching(v12, &result);
  if (v13 == -25300)
  {
    uint64_t v16 = 0;
    goto LABEL_18;
  }
  if (!a5 || v13)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainLoadItem", 231, 96, 0, "searching item in keychain: %d", v14, v15, v13);
  }
  else
  {
    CFTypeID v19 = CFGetTypeID(result);
    if (v19 == CFDataGetTypeID())
    {
      CFIndex Length = CFDataGetLength((CFDataRef)result);
      if (Length - 1 < a4)
      {
        size_t v23 = Length;
        BytePtr = CFDataGetBytePtr((CFDataRef)result);
        memcpy(a5, BytePtr, v23);
        *a6 = v23;
        uint64_t v16 = 1;
        goto LABEL_18;
      }
      uint64_t v25 = "Invalid data size";
      __int16 v26 = 236;
    }
    else
    {
      uint64_t v25 = "Invalid return type";
      __int16 v26 = 234;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainLoadItem", v26, 96, 0, v25, v20, v21, v28);
  }
  uint64_t v16 = 0xFFFFFFFFLL;
LABEL_18:
  CFRelease(v12);
  if (result) {
    CFRelease(result);
  }
  return v16;
}

uint64_t AEAKeychainHasItem(unsigned __int8 *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef result = 0;
  if (!a2)
  {
    uint64_t v14 = "Invalid args";
    __int16 v15 = 258;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainHasItem", v15, 96, 0, v14, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v14 = "create attributes";
    __int16 v15 = 262;
    goto LABEL_8;
  }
  CFDictionaryRef v9 = Attributes;
  CFDictionaryAddValue(Attributes, (const void *)*MEMORY[0x263F17518], (const void *)*MEMORY[0x263EFFB40]);
  OSStatus v10 = SecItemCopyMatching(v9, &result);
  if (v10 == -25300)
  {
    uint64_t v13 = 0;
  }
  else if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainHasItem", 270, 96, 0, "searching item in keychain: %d", v11, v12, v10);
    uint64_t v13 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v13 = 1;
  }
  CFRelease(v9);
  if (result) {
    CFRelease(result);
  }
  return v13;
}

uint64_t AEAKeychainRemoveItem(unsigned __int8 *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t v14 = "Invalid args";
    __int16 v15 = 289;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainRemoveItem", v15, 96, 0, v14, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  Attributes = aeaKeychainCreateAttributes(a1, a2, a3);
  if (!Attributes)
  {
    uint64_t v14 = "create attributes";
    __int16 v15 = 293;
    goto LABEL_8;
  }
  CFDictionaryRef v9 = Attributes;
  OSStatus v10 = SecItemDelete(Attributes);
  if (v10 == -25300)
  {
    uint64_t v13 = 0;
  }
  else if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAKeychain.c", (uint64_t)"AEAKeychainRemoveItem", 298, 96, 0, "removing item from keychain: %d", v11, v12, v10);
    uint64_t v13 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v13 = 1;
  }
  CFRelease(v9);
  return v13;
}

uint64_t PCompressZLIB5Encode(uint64_t a1, unint64_t a2, const uint8_t *a3, size_t a4)
{
  BOOL v4 = a2 >= 2;
  size_t v5 = a2 - 2;
  if (!v4) {
    return -1;
  }
  *(_WORD *)a1 = 24184;
  size_t v7 = compression_encode_buffer((uint8_t *)(a1 + 2), v5, a3, a4, 0, COMPRESSION_ZLIB);
  if (v7) {
    return v7 + 2;
  }
  else {
    return -1;
  }
}

size_t PCompressZLIBDecode(uint8_t *a1, size_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = a4 >= 2;
  size_t v5 = a4 - 2;
  if (!v4) {
    return -1;
  }
  size_t result = compression_decode_buffer(a1, a2, (const uint8_t *)(a3 + 2), v5, 0, COMPRESSION_ZLIB);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t ParallelCompressionEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = 0;
  unsigned int v8 = *(_DWORD *)(a1 + 4);
  LODWORD(v15) = *(_DWORD *)a1;
  uint64_t v14 = *(void *)(a1 + 16);
  v12[1] = 0;
  uint64_t v13 = v8;
  v12[0] = *(_DWORD *)(a1 + 8);
  long long v9 = *(_OWORD *)(a1 + 40);
  v11[0] = *(_OWORD *)(a1 + 24);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 56);
  return PCompressFilter(v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t (*PCompressGetEncoderFilter(unsigned int a1))()
{
  if (a1 > 6) {
    return 0;
  }
  else {
    return off_26C59A4B0[a1];
  }
}

uint64_t RawImagePatchInternal(uint64_t a1, AAByteStream_impl *a2)
{
  int v5 = *(_DWORD *)(a1 + 40);
  int DefaultNThreads = *(_DWORD *)(a1 + 44);
  if (!DefaultNThreads)
  {
    int DefaultNThreads = getDefaultNThreads();
    *(_DWORD *)(a1 + 44) = DefaultNThreads;
  }
  if (DefaultNThreads >= 3) {
    *(_DWORD *)(a1 + 44) = 2;
  }
  if (!*(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = *(void *)(a1 + 24);
  }
  uint64_t v6 = a2;
  if (!a2)
  {
    __int16 v18 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 32), 0, 0);
    uint64_t v6 = (AAByteStream_impl *)v18;
    if (!v18)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 542, 135, 0, "AAFileStreamOpenWithPath", v19, v20, v254);
      uint64_t v31 = 0;
      char v30 = 0;
      int v29 = 0;
      char v28 = 0;
      int v27 = 0;
      goto LABEL_30;
    }
    if ((v5 & 1) != 0 && (io_set_nocache(v18) & 0x80000000) != 0) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 543, 135, "io_set_nocache %s", v21, v22, v23, *(void *)(a1 + 32));
    }
  }
  size_t v7 = malloc(0x2EuLL);
  OSStatus v10 = v7;
  if (!v7)
  {
    int v17 = *__error();
    uint64_t v15 = "aaMalloc";
    __int16 v16 = 108;
    goto LABEL_24;
  }
  if (!*((void *)v6 + 2)) {
    goto LABEL_17;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 46;
  uint64_t v13 = v7;
  do
  {
    uint64_t v14 = (*((uint64_t (**)(void, void *, uint64_t))v6 + 2))(*(void *)v6, v13, v12);
    if (v14 < 0) {
      goto LABEL_17;
    }
    if (!v14) {
      break;
    }
    uint64_t v13 = (void *)((char *)v13 + v14);
    v11 += v14;
    v12 -= v14;
  }
  while (v12);
  if (v11 != 46)
  {
LABEL_17:
    uint64_t v15 = "aaByteStreamReadExpected";
    __int16 v16 = 110;
    goto LABEL_18;
  }
  if (*v10 != 0x3031464649444952
    || !*((_WORD *)v10 + 4)
    || !*(void *)((char *)v10 + 18)
    || (size_t v35 = *(void *)((char *)v10 + 30), v35 < 0x2F)
    || v35 >= *(void *)((char *)v10 + 38))
  {
    uint64_t v15 = "bad header";
    __int16 v16 = 118;
LABEL_18:
    int v17 = 0;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v16, 135, v17, v15, v8, v9, v254);
LABEL_25:
    free(v10);
    CFStringRef v24 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 548, 135, *v24, "patch_read_header", v25, v26, v255);
    int v27 = 0;
    char v28 = 0;
    int v29 = 0;
    char v30 = 0;
LABEL_26:
    uint64_t v31 = 0;
    goto LABEL_27;
  }
  if (v35 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_50:
    uint64_t v44 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", 122, 135, *v44, "aaReallocf", v45, v46, v254);
    OSStatus v10 = 0;
    goto LABEL_25;
  }
  uint64_t v36 = (char *)realloc(v10, v35);
  if (!v36)
  {
    free(v10);
    goto LABEL_50;
  }
  char v30 = v36;
  uint64_t v39 = *(void *)(v36 + 30) - 46;
  if (*((void *)v6 + 2))
  {
    if (*(void *)(v36 + 30) == 46) {
      goto LABEL_54;
    }
    uint64_t v40 = 0;
    __int16 v41 = v36 + 46;
    uint64_t v42 = *(void *)(v36 + 30) - 46;
    while (1)
    {
      uint64_t v43 = (*((uint64_t (**)(void, char *, uint64_t))v6 + 2))(*(void *)v6, v41, v42);
      if (v43 < 0) {
        break;
      }
      if (v43)
      {
        v41 += v43;
        v40 += v43;
        v42 -= v43;
        if (v42) {
          continue;
        }
      }
      goto LABEL_53;
    }
    uint64_t v40 = v43;
  }
  else
  {
    uint64_t v40 = -1;
  }
LABEL_53:
  if (v39 != v40)
  {
    unint64_t v53 = "aaByteStreamReadExpected";
    __int16 v54 = 124;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v54, 135, 0, v53, v37, v38, v254);
    OSStatus v10 = v30;
    goto LABEL_25;
  }
LABEL_54:
  uint64_t v47 = 0;
  unint64_t v48 = *(void *)(v30 + 38);
  uint64_t v49 = *((unsigned __int16 *)v30 + 4);
  do
  {
    unint64_t v50 = *(void *)&v30[v47 + 46];
    if (v48 >= v50)
    {
      unint64_t v53 = "bad header";
      __int16 v54 = 130;
      goto LABEL_62;
    }
    v47 += 8;
    unint64_t v48 = v50;
  }
  while (8 * v49 + 8 != v47);
  if (*(int *)(a1 + 48) >= 1)
  {
    uint64_t v51 = (FILE **)MEMORY[0x263EF8348];
    if (v49 == 1) {
      uint64_t v52 = "*full replacement*";
    }
    else {
      uint64_t v52 = *(const char **)(a1 + 16);
    }
    uint64_t v55 = "(stream based)";
    if (*(void *)(a1 + 32)) {
      uint64_t v55 = *(const char **)(a1 + 32);
    }
    int v56 = *(_DWORD *)(a1 + 40);
    if (v56) {
      __int16 v57 = "no";
    }
    else {
      __int16 v57 = "yes";
    }
    if ((v56 & 2) != 0) {
      uint64_t v58 = "yes";
    }
    else {
      uint64_t v58 = "no";
    }
    fprintf((FILE *)*MEMORY[0x263EF8348], "ImagePatch\n  Input:        %s\n  Output:       %s\n  Patch:        %s\n  CryptexCache: %s\n  StaticContent: %s\n", v52, *(const char **)(a1 + 24), v55, v57, v58);
    if (*(int *)(a1 + 48) >= 2)
    {
      fprintf(*v51, "  - Variants:   %d\n  - Flags:      %llx\n  - # controls: %llu\n  - Patch size: %llu bytes\n    - Metadata: %llu bytes\n    - Controls: %llu bytes\n", *((unsigned __int16 *)v30 + 4), *(void *)(v30 + 10), *(void *)(v30 + 18), *(void *)&v30[8 * *((unsigned __int16 *)v30 + 4) + 46], *(void *)(v30 + 38) - *(void *)(v30 + 30), *(void *)(v30 + 46) - *(void *)(v30 + 38));
      if (*((_WORD *)v30 + 4))
      {
        unint64_t v59 = 0;
        do
        {
          if (v59) {
            uint64_t v60 = "Diff";
          }
          else {
            uint64_t v60 = "Literal";
          }
          unint64_t v61 = v59 + 1;
          fprintf(*v51, "    - %s stream: %llu bytes\n", v60, *(void *)&v30[8 * v59 + 54] - *(void *)&v30[8 * v59 + 46]);
          unint64_t v59 = v61;
        }
        while (v61 < *((unsigned __int16 *)v30 + 4));
      }
    }
  }
  uint64_t v62 = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)(v30 + 30), *(void *)(v30 + 38));
  uint64_t v65 = v62;
  if (!v62)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 187, 135, 0, "aaIntervalInputStreamOpen", v63, v64, v254);
    int v29 = 0;
    AAByteStream v70 = 0;
    goto LABEL_95;
  }
  uint64_t v66 = *(unsigned int *)(a1 + 48);
  if (v66 <= 3) {
    AAFlagSet v67 = v66 << 62;
  }
  else {
    AAFlagSet v67 = 0xC000000000000000;
  }
  AAByteStream v70 = AADecompressionInputStreamOpen(v62, v67, *(_DWORD *)(a1 + 44));
  if (!v70)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 189, 135, 0, "AADecompressionInputStreamOpen", v68, v69, v254);
    int v29 = 0;
    goto LABEL_95;
  }
  int v29 = calloc(*((unsigned __int16 *)v30 + 4), 8uLL);
  if (!v29)
  {
    uint64_t v76 = "aaCalloc";
    __int16 v77 = 193;
    goto LABEL_94;
  }
  if (*((_WORD *)v30 + 4))
  {
    uint64_t v73 = 0;
    while (1)
    {
      uint64_t v74 = rawimg_create_with_stream(v70, v73 == 0);
      v29[v73] = v74;
      if (!v74) {
        break;
      }
      if (++v73 >= (unint64_t)*((unsigned __int16 *)v30 + 4)) {
        goto LABEL_89;
      }
    }
    uint64_t v76 = "rawimg_create_with_stream";
    __int16 v77 = 199;
LABEL_94:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", v77, 135, 0, v76, v71, v72, v254);
LABEL_95:
    free(v29);
    char v75 = 1;
  }
  else
  {
LABEL_89:
    char v75 = 0;
  }
  int v78 = AAByteStreamClose(v70);
  int v79 = AAByteStreamClose(v65);
  if (!v29 || (v75 & 1) != 0 || v79 < 0 || v78 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 552, 135, 0, "patch_read_variants", v80, v81, v254);
    int v27 = 0;
    char v28 = 0;
    int v29 = 0;
    goto LABEL_26;
  }
  uint64_t v82 = calloc(*((unsigned __int16 *)v30 + 4), 0x20uLL);
  uint64_t v31 = v82;
  if (!v82)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 556, 135, 0, "aaCalloc", v83, v84, v254);
    char v28 = 0;
    goto LABEL_374;
  }
  if (*((_WORD *)v30 + 4))
  {
    unint64_t v85 = 0;
    size_t v86 = v82;
    do
    {
      long long v87 = *(_OWORD *)(v29[v85] + 2104);
      *size_t v86 = *(_OWORD *)(v29[v85] + 2088);
      v86[1] = v87;
      v86 += 2;
      ++v85;
      unint64_t v88 = *((unsigned __int16 *)v30 + 4);
    }
    while (v85 < v88);
    *(void *)(*v29 + 2048) = *(void *)(a1 + 24);
    if (v88 == 1)
    {
      char v28 = 0;
      int v273 = 0;
      v279 = 0;
      s = 0;
      unint64_t v291 = 0;
      AAByteStream compressed_stream = 0;
      size_t v283 = 0;
      uint64_t v89 = *v29;
      int v90 = *(_DWORD *)(a1 + 40);
      int v91 = v90 & 1;
      goto LABEL_106;
    }
  }
  else
  {
    *(void *)(*v29 + 2048) = *(void *)(a1 + 24);
  }
  uint64_t v106 = (long long *)malloc(0x2000uLL);
  char v28 = v106;
  if (!v106)
  {
    long long v121 = "aaMalloc";
    __int16 v122 = 568;
    goto LABEL_373;
  }
  saveThreadErrorContext(v106);
  uint64_t v109 = *((unsigned __int16 *)v30 + 4);
  if (!*((_WORD *)v30 + 4))
  {
LABEL_138:
    restoreThreadErrorContext(v28);
    goto LABEL_139;
  }
  uint64_t v110 = &v31[4 * v109 - 4];
  uint64_t v111 = (char *)(v29 - 1);
  while (1)
  {
    uint64_t v295 = v109;
    uint64_t v112 = v109 - 1;
    *(void *)(*(void *)&v111[8 * v109] + 2048) = *(void *)(a1 + 16);
    if (!rawimg_get_digests(*(void *)&v111[8 * v109], 4, 1, 1))
    {
      uint64_t v113 = *(void **)&v111[8 * v295];
      uint64_t v114 = v113[261];
      uint64_t v115 = v113[262];
      uint64_t v116 = v113[263];
      uint64_t v117 = v113[264];
      BOOL v118 = *v110 == v114 && v110[1] == v115;
      BOOL v119 = v118 && v110[2] == v116;
      if (v119 && v110[3] == v117) {
        break;
      }
    }
    v110 -= 4;
    uint64_t v109 = v112;
    if (!v112) {
      goto LABEL_138;
    }
  }
  restoreThreadErrorContext(v28);
  int v273 = v112;
  if ((v112 & 0x80000000) != 0)
  {
LABEL_139:
    long long v121 = "ImagePatch: No variant found";
    __int16 v122 = 586;
    goto LABEL_373;
  }
  if (v295 == 1) {
    goto LABEL_285;
  }
  uint64_t v188 = &v31[4 * v112];
  uint64_t v189 = *v188;
  uint64_t v190 = v188[1];
  uint64_t v192 = v188[2];
  uint64_t v191 = v188[3];
  if (*v31 == v189 && v31[1] == v190 && v31[2] == v192 && v31[3] == v191)
  {
    *(void *)(*v29 + 2048) = *(void *)(a1 + 16);
LABEL_285:
    uint64_t v211 = *v29;
    int v212 = *(const char **)(*v29 + 2048);
    int v213 = *(const char **)(a1 + 24);
    int v214 = strcmp(v212, v213);
    int v215 = *(_DWORD *)(a1 + 48);
    if (v214)
    {
      if (v215 >= 2)
      {
        fwrite("ImagePatch: Digest match. Copy input to output.\n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
        uint64_t v211 = *v29;
      }
      if ((copyFileSegment(v212, 0, *(void *)(v211 + 2120), v213) & 0x80000000) != 0)
      {
        long long v121 = "copyFileSegment";
        __int16 v122 = 607;
        goto LABEL_373;
      }
    }
    else if (v215 >= 2)
    {
      uint64_t v216 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v217 = "ImagePatch: Digest match. Output already correct.\n";
      size_t v218 = 50;
      goto LABEL_381;
    }
LABEL_382:
    int v27 = 1;
    rawimg_show(*v29, 1, *(_DWORD *)(a1 + 48));
    if (*(void *)a1
      && ((*(uint64_t (**)(void, uint64_t))a1)(*(void *)(a1 + 8), 100) & 0x80000000) != 0)
    {
      long long v121 = "callback signaled abort";
      __int16 v122 = 641;
      goto LABEL_373;
    }
    goto LABEL_375;
  }
  rawimg_show(v29[v112], 0, *(_DWORD *)(a1 + 48));
  int v90 = *(_DWORD *)(a1 + 40);
  int v91 = v90 & 1;
  uint64_t v289 = *v29;
  unint64_t v292 = (void *)v29[v273];
  uint64_t v196 = (const char *)v292[256];
  int v287 = strcmp(v196, *(const char **)(*v29 + 2048));
  if (!v287)
  {
    if (v30[10])
    {
      if (*(_DWORD *)(a1 + 48)) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "ImagePatch: Patching with excess space <= %d bytes.\n", *(_DWORD *)(v30 + 26));
      }
    }
    else
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 245, 135, "ImagePatch: Patch not created with in place. No bound on needed excess space.", v197, v198, v199, v254);
    }
    unint64_t v227 = v292[265];
    if (*(void *)(v289 + 2120) > v227) {
      unint64_t v227 = *(void *)(v289 + 2120);
    }
    uint64_t v285 = v227;
    v294 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v289 + 2048), 2, 0x1A4u);
    if (!v294)
    {
      uint64_t v244 = "AAFileStreamOpenWithPath";
      __int16 v245 = 252;
      goto LABEL_352;
    }
    if (v90)
    {
      if ((io_set_nocache(v294) & 0x80000000) != 0) {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 257, 135, "io_set_nocache %s", v228, v229, v230, *(void *)(v289 + 2048));
      }
      LODWORD(v231) = *(_DWORD *)(a1 + 48);
      uint64_t v231 = v231 >= 3 ? 3 : v231;
      v294 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v294, 0x1000000uLL, 14, 1, v231 << 62);
      if (!v294)
      {
        uint64_t v244 = "aaCacheStreamOpen";
        __int16 v245 = 259;
        goto LABEL_352;
      }
    }
    v279 = (unsigned int **)aaInSituStreamOpen(v294, v285, *(_DWORD *)(v30 + 26), *(_DWORD *)(a1 + 48), 1);
    if (!v279)
    {
      uint64_t v244 = "aaInSituStreamOpen";
      __int16 v245 = 264;
      goto LABEL_352;
    }
    if (*((unsigned __int16 *)v30 + 4) <= 1u)
    {
      s = 0;
      unint64_t v291 = 0;
      AAByteStream compressed_stream = 0;
      size_t v283 = 0;
      int v272 = 0;
      v293 = v279;
      uint64_t v123 = aaSegmentStreamOpen(v279, (void *)v289);
      goto LABEL_145;
    }
    v293 = v279;
LABEL_330:
    s = aaSegmentStreamOpen(v279, v292);
    if (!s)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 290, 135, 0, "aaSegmentStreamOpen", v235, v236, v254);
      v280 = 0;
      v288 = 0;
      size_t v283 = 0;
      unint64_t v284 = 0;
      AAByteStream compressed_stream = 0;
      v296 = 0;
      v286 = 0;
      unint64_t v291 = 0;
      s = 0;
      goto LABEL_353;
    }
    unint64_t v291 = aaForkInputStreamOpen(s, (uint64_t)v292, 0, v232, v233, v234, v235, v236);
    if (!v291)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 292, 135, 0, "aaForkInputStreamOpen", v237, v238, v254);
      v280 = 0;
      v288 = 0;
      size_t v283 = 0;
      unint64_t v284 = 0;
      AAByteStream compressed_stream = 0;
      v296 = 0;
      v286 = 0;
      unint64_t v291 = 0;
      goto LABEL_353;
    }
    AAByteStream compressed_stream = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)&v30[8 * v273 + 46], *(void *)&v30[8 * v295 + 46]);
    if (compressed_stream)
    {
      LODWORD(v241) = *(_DWORD *)(a1 + 48);
      if (v241 >= 3) {
        uint64_t v241 = 3;
      }
      else {
        uint64_t v241 = v241;
      }
      size_t v283 = AADecompressionInputStreamOpen(compressed_stream, v241 << 62, *(_DWORD *)(a1 + 44));
      if (v283)
      {
        if (v287) {
          goto LABEL_312;
        }
        int v272 = 0;
        goto LABEL_144;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 298, 135, 0, "AADecompressionInputStreamOpen", v242, v243, v254);
      v280 = 0;
      v288 = 0;
      size_t v283 = 0;
      unint64_t v284 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 296, 135, 0, "aaIntervalInputStreamOpen", v239, v240, v254);
      v280 = 0;
      v288 = 0;
      size_t v283 = 0;
      unint64_t v284 = 0;
      AAByteStream compressed_stream = 0;
    }
LABEL_279:
    v296 = 0;
    v286 = 0;
    goto LABEL_353;
  }
  if (*((unsigned __int16 *)v30 + 4) > 1u)
  {
    v279 = (unsigned int **)AAFileStreamOpenWithPath(v196, 0, 0);
    if (v279)
    {
      if ((v90 & 1) == 0) {
        goto LABEL_277;
      }
      if ((io_set_nocache(v279) & 0x80000000) != 0) {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 284, 135, "io_set_nocache %s", v202, v203, v204, v292[256]);
      }
      LODWORD(v205) = *(_DWORD *)(a1 + 48);
      uint64_t v205 = v205 >= 3 ? 3 : v205;
      int v91 = 1;
      v279 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v279, 0x1000000uLL, 14, 1, v205 << 62);
      if (v279)
      {
LABEL_277:
        v293 = 0;
        goto LABEL_330;
      }
      uint64_t v244 = "aaCacheStreamOpen";
      __int16 v245 = 286;
    }
    else
    {
      uint64_t v244 = "AAFileStreamOpenWithPath";
      __int16 v245 = 281;
    }
LABEL_352:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v245, 135, 0, v244, v200, v201, v254);
    v280 = 0;
    v288 = 0;
    size_t v283 = 0;
    unint64_t v284 = 0;
    AAByteStream compressed_stream = 0;
    v293 = 0;
    v296 = 0;
    v286 = 0;
    unint64_t v291 = 0;
    s = 0;
    v279 = 0;
LABEL_353:
    int v290 = 0;
    uint64_t v281 = 0;
    goto LABEL_354;
  }
  v279 = 0;
  s = 0;
  unint64_t v291 = 0;
  AAByteStream compressed_stream = 0;
  size_t v283 = 0;
LABEL_312:
  uint64_t v89 = v289;
LABEL_106:
  uint64_t v289 = v89;
  v293 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v89 + 2048), 1538, 0x1A4u);
  if (!v293)
  {
    uint64_t v104 = "AAFileStreamOpenWithPath";
    __int16 v105 = 305;
    goto LABEL_142;
  }
  if ((v90 & 2) != 0 && (io_hint_static_content(v293) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 308, 135, "ImagePatch: Static content hint failed.", v94, v95, v96, v254);
  }
  if ((io_preallocate(v293, *(void *)(v289 + 2120)) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 311, 135, "ImagePatch: Preallocation failed.", v97, v98, v99, v254);
  }
  if (v91)
  {
    if ((io_set_nocache(v293) & 0x80000000) != 0) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 316, 135, "io_set_nocache %s", v100, v101, v102, *(void *)(v289 + 2048));
    }
    LODWORD(v103) = *(_DWORD *)(a1 + 48);
    if (v103 >= 3) {
      uint64_t v103 = 3;
    }
    else {
      uint64_t v103 = v103;
    }
    int v272 = 1;
    v293 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v293, 0x100000uLL, 14, 1, v103 << 62);
    if (!v293)
    {
      uint64_t v104 = "aaCacheStreamOpen";
      __int16 v105 = 318;
LABEL_142:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v105, 135, 0, v104, v92, v93, v254);
      v280 = 0;
      v286 = 0;
      v288 = 0;
      unint64_t v284 = 0;
      v293 = 0;
      v296 = 0;
      goto LABEL_353;
    }
  }
  else
  {
    int v272 = 1;
  }
LABEL_144:
  uint64_t v123 = aaSegmentStreamOpen(v293, (void *)v289);
LABEL_145:
  v286 = (AAByteStream_impl *)v123;
  if (!v123)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 322, 135, 0, "aaSegmentStreamOpen", v124, v125, v254);
    v280 = 0;
    v288 = 0;
    unint64_t v284 = 0;
    goto LABEL_279;
  }
  v296 = aaForkOutputStreamOpen((uint64_t)v123, (void *)v289);
  if (!v296)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 324, 135, 0, "aaForkOutputStreamOpen", v126, v127, v254);
    v280 = 0;
    v288 = 0;
    unint64_t v284 = 0;
    v296 = 0;
    goto LABEL_353;
  }
  unint64_t v284 = aaIntervalInputStreamOpen((uint64_t)v6, *(void *)(v30 + 46), *(void *)(v30 + 54));
  if (!v284)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 328, 135, 0, "aaIntervalInputStreamOpen", v128, v129, v254);
    v280 = 0;
    v288 = 0;
    unint64_t v284 = 0;
    goto LABEL_353;
  }
  LODWORD(v130) = *(_DWORD *)(a1 + 48);
  if (v130 >= 3) {
    uint64_t v130 = 3;
  }
  else {
    uint64_t v130 = v130;
  }
  v288 = AADecompressionInputStreamOpen(v284, v130 << 62, *(_DWORD *)(a1 + 44));
  if (!v288)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 330, 135, 0, "AADecompressionInputStreamOpen", v131, v132, v254);
    v280 = 0;
    v288 = 0;
    goto LABEL_353;
  }
  v280 = calloc(1uLL, 0x10040uLL);
  if (!v280)
  {
    v206 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_create", 36, 135, *v206, "aaCalloc", v207, v208, v254);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 338, 135, 0, "control_reader_create", v209, v210, v256);
    v280 = 0;
    goto LABEL_353;
  }
  *((void *)v280 + 0x2000) = v6;
  *((void *)v280 + 8195) = v30;
  *((void *)v280 + 8196) = a1;
  uint64_t v139 = *((unsigned __int16 *)v30 + 4) + 1;
  *((void *)v280 + 8197) = 0x2000 / v139 * v139;
  *((void *)v280 + 8198) = -1;
  uint64_t v140 = *(void *)(v30 + 18);
  *((void *)v280 + 8199) = v140 * v139;
  char v141 = v272;
  if (!v140) {
    char v141 = 1;
  }
  if ((v141 & 1) == 0)
  {
    unint64_t v282 = 0;
    uint64_t v219 = 0;
    while (1)
    {
      uint64_t v220 = (unint64_t *)ctrl_reader_get((uint64_t)v280, v282, v133, v134, v135, v136, v137, v138);
      if (!v220)
      {
        uint64_t v224 = "ctrl_reader_get";
        __int16 v225 = 349;
        goto LABEL_308;
      }
      if ((*v220 & 0x8000000000000000) == 0) {
        unint64_t v221 = *v220;
      }
      else {
        unint64_t v221 = 0x8000000000000000 - *v220;
      }
      uint64_t v222 = v220[v273 + 1];
      if (v222 < 0) {
        uint64_t v222 = 0x8000000000000000 - v222;
      }
      uint64_t v271 = v222;
      if (v221) {
        break;
      }
LABEL_305:
      v219 += v271;
      if (++v282 >= *(void *)(v30 + 18)) {
        goto LABEL_156;
      }
    }
    while (1)
    {
      uint64_t v223 = v221 >= 0x10000 ? 0x10000 : v221;
      if (v223 != aaByteStreamSimulate(v291)) {
        break;
      }
      v219 += v223;
      v221 -= v223;
      if (!v221) {
        goto LABEL_305;
      }
    }
    uint64_t v224 = "aaByteStreamSimulate";
    __int16 v225 = 358;
LABEL_308:
    int v226 = 0;
    goto LABEL_314;
  }
LABEL_156:
  uint64_t v281 = calloc(1uLL, 0x20000uLL);
  if (!v281)
  {
    int v226 = *__error();
    uint64_t v224 = "aaCalloc";
    __int16 v225 = 371;
LABEL_314:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v225, 135, v226, v224, v137, v138, v254);
    goto LABEL_353;
  }
  unint64_t v267 = 0;
  unint64_t v263 = 0;
  uint64_t v258 = v273 + 1;
  unint64_t v148 = *(void *)(v30 + 18);
  unsigned int v259 = 1;
  while (!v148)
  {
LABEL_250:
    int v187 = v272;
    if (v259 > 1) {
      int v187 = 1;
    }
    ++v259;
    if (v187 == 1)
    {
      if ((AAByteStreamTruncate(v293) & 0x80000000) == 0)
      {
        int v290 = 1;
        goto LABEL_354;
      }
      unint64_t v246 = "AAByteStreamTruncate";
      __int16 v247 = 457;
LABEL_390:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v247, 135, 0, v246, v146, v147, v254);
      int v290 = 0;
LABEL_354:
      if (v279 == v293) {
        v248 = 0;
      }
      else {
        v248 = (AAByteStream_impl *)v279;
      }
      goto LABEL_357;
    }
  }
  unint64_t v260 = 0;
  unint64_t v268 = 0;
  uint64_t v262 = 0;
  while (2)
  {
    uint64_t v149 = (unint64_t *)ctrl_reader_get((uint64_t)v280, v260, v142, v143, v144, v145, v146, v147);
    if (!v149)
    {
      unint64_t v246 = "ctrl_reader_get";
      __int16 v247 = 387;
      goto LABEL_390;
    }
    unint64_t v150 = *v149;
    uint64_t v151 = v149[1];
    if ((*v149 & 0x8000000000000000) != 0) {
      unint64_t v150 = 0x8000000000000000 - *v149;
    }
    unint64_t v265 = v150;
    unint64_t v152 = 0x8000000000000000 - v151;
    if (v151 >= 0) {
      unint64_t v152 = v149[1];
    }
    unint64_t v264 = v152;
    uint64_t v153 = v149[v258];
    if (v153 < 0) {
      uint64_t v153 = 0x8000000000000000 - v153;
    }
    uint64_t v257 = v153;
    if (v259 == 2)
    {
      v268 += v265;
      if ((v272 & 1) == 0 && v268 < *(void *)(v289 + 2056)) {
        goto LABEL_170;
      }
LABEL_218:
      if (v264)
      {
        unint64_t v266 = 0;
        while (1)
        {
          uint64_t v174 = v264 - v266;
          if (v264 - v266 >= 0x10000) {
            uint64_t v174 = 0x10000;
          }
          uint64_t v270 = v174;
          if (!*((void *)v288 + 2))
          {
LABEL_342:
            unint64_t v246 = "aaByteStreamReadExpected";
            __int16 v247 = 439;
            goto LABEL_390;
          }
          if (v174)
          {
            uint64_t v175 = 0;
            uint64_t v176 = v281;
            uint64_t v177 = v174;
            while (1)
            {
              uint64_t v178 = (*((uint64_t (**)(void, unsigned char *, uint64_t))v288 + 2))(*(void *)v288, v176, v177);
              if (v178 < 0) {
                break;
              }
              if (v178)
              {
                v176 += v178;
                v175 += v178;
                v177 -= v178;
                if (v177) {
                  continue;
                }
              }
              goto LABEL_232;
            }
            uint64_t v175 = v178;
LABEL_232:
            if (v270 != v175) {
              goto LABEL_342;
            }
            if (!*((void *)v296 + 5)) {
              goto LABEL_343;
            }
            uint64_t v276 = 0;
            uint64_t v179 = v281;
            unint64_t v180 = v268;
            uint64_t v181 = v270;
            while (1)
            {
              uint64_t v182 = (*((uint64_t (**)(void, unsigned char *, uint64_t, unint64_t))v296 + 5))(*(void *)v296, v179, v181, v180);
              if (v182 < 1) {
                break;
              }
              v179 += v182;
              v276 += v182;
              v180 += v182;
              v181 -= v182;
              if (!v181) {
                goto LABEL_239;
              }
            }
            uint64_t v276 = v182;
LABEL_239:
            if (v270 != v276)
            {
LABEL_343:
              unint64_t v246 = "aaByteStreamWriteExpected";
              __int16 v247 = 440;
              goto LABEL_390;
            }
          }
          else if (!*((void *)v296 + 5))
          {
            goto LABEL_343;
          }
          unint64_t v183 = v270 + v267;
          v267 += v270;
          if (*(void *)a1) {
            BOOL v184 = v183 > v263;
          }
          else {
            BOOL v184 = 0;
          }
          if (v184)
          {
            unint64_t v185 = *(void *)(v289 + 2080);
            if (v267 < v185)
            {
              unint64_t v186 = ((v185 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
              if (((*(uint64_t (**)(void, unint64_t))a1)(*(void *)(a1 + 8), v267 / (v185 / 0x64 + 1)) & 0x80000000) != 0)
              {
                __int16 v253 = 450;
                goto LABEL_393;
              }
              unint64_t v263 = v267 + (v186 >> 2);
            }
          }
          v268 += v270;
          v266 += v270;
          if (v266 >= v264) {
            goto LABEL_249;
          }
        }
      }
      goto LABEL_249;
    }
    if (!v265)
    {
LABEL_215:
      v262 += v257;
      if ((v272 & 1) != 0 || v259 != 1 || v268 < *(void *)(v289 + 2056)) {
        goto LABEL_218;
      }
LABEL_170:
      v268 += v264;
LABEL_249:
      unint64_t v148 = *(void *)(v30 + 18);
      if (++v260 >= v148) {
        goto LABEL_250;
      }
      continue;
    }
    break;
  }
  unint64_t v261 = 0;
  while (2)
  {
    uint64_t v154 = v265 - v261;
    if (v265 - v261 >= 0x10000) {
      uint64_t v154 = 0x10000;
    }
    uint64_t v269 = v154;
    if (!v291[4]) {
      goto LABEL_346;
    }
    if (v154)
    {
      uint64_t v274 = 0;
      uint64_t v155 = v281;
      uint64_t v156 = v262;
      uint64_t v157 = v154;
      while (1)
      {
        uint64_t v158 = ((uint64_t (*)(uint64_t, unsigned char *, uint64_t, uint64_t))v291[4])(*v291, v155, v157, v156);
        if (v158 < 0) {
          break;
        }
        if (v158)
        {
          v155 += v158;
          v274 += v158;
          v156 += v158;
          v157 -= v158;
          if (v157) {
            continue;
          }
        }
        goto LABEL_183;
      }
      uint64_t v274 = v158;
LABEL_183:
      if (v269 != v274)
      {
LABEL_346:
        unint64_t v246 = "aaByteStreamPReadExpected";
        __int16 v247 = 400;
        goto LABEL_390;
      }
    }
    unint64_t v159 = *(void *)(v289 + 2072);
    if (v268 >= v159)
    {
LABEL_198:
      if (!*((void *)v296 + 5)) {
        goto LABEL_348;
      }
      if (v269)
      {
        uint64_t v275 = 0;
        uint64_t v166 = v281;
        unint64_t v167 = v268;
        uint64_t v168 = v269;
        while (1)
        {
          uint64_t v169 = (*((uint64_t (**)(void, unsigned char *, uint64_t, unint64_t))v296 + 5))(*(void *)v296, v166, v168, v167);
          if (v169 < 1) {
            break;
          }
          v166 += v169;
          v275 += v169;
          v167 += v169;
          v168 -= v169;
          if (!v168) {
            goto LABEL_205;
          }
        }
        uint64_t v275 = v169;
LABEL_205:
        if (v269 != v275)
        {
LABEL_348:
          unint64_t v246 = "aaByteStreamWriteExpected";
          __int16 v247 = 412;
          goto LABEL_390;
        }
      }
    }
    else
    {
      if (v269 + v268 > v159)
      {
        unint64_t v246 = "bad controls";
        __int16 v247 = 406;
        goto LABEL_390;
      }
      if (!*((void *)v283 + 2)) {
        goto LABEL_386;
      }
      if (v269)
      {
        uint64_t v160 = 0;
        size_t v161 = v281 + 0x10000;
        uint64_t v162 = v269;
        while (1)
        {
          uint64_t v163 = (*((uint64_t (**)(void, char *, uint64_t))v283 + 2))(*(void *)v283, v161, v162);
          if (v163 < 0) {
            break;
          }
          if (v163)
          {
            v161 += v163;
            v160 += v163;
            v162 -= v163;
            if (v162) {
              continue;
            }
          }
          goto LABEL_196;
        }
        uint64_t v160 = v163;
LABEL_196:
        uint64_t v164 = v281;
        uint64_t v165 = v269;
        if (v269 != v160)
        {
LABEL_386:
          unint64_t v246 = "aaByteStreamReadExpected";
          __int16 v247 = 407;
          goto LABEL_390;
        }
        do
        {
          *v164 += v164[0x10000];
          ++v164;
          --v165;
        }
        while (v165);
        goto LABEL_198;
      }
      if (!*((void *)v296 + 5)) {
        goto LABEL_348;
      }
    }
    unint64_t v170 = v267 + v269;
    v267 += v269;
    if (*(void *)a1) {
      BOOL v171 = v170 > v263;
    }
    else {
      BOOL v171 = 0;
    }
    if (!v171 || (unint64_t v172 = *(void *)(v289 + 2080), v267 >= v172))
    {
LABEL_214:
      v262 += v269;
      v268 += v269;
      v261 += v269;
      if (v261 >= v265) {
        goto LABEL_215;
      }
      continue;
    }
    break;
  }
  unint64_t v173 = ((v172 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
  if (((*(uint64_t (**)(void, unint64_t))a1)(*(void *)(a1 + 8), v267 / (v172 / 0x64 + 1)) & 0x80000000) == 0)
  {
    unint64_t v263 = v267 + (v173 >> 2);
    goto LABEL_214;
  }
  __int16 v253 = 422;
LABEL_393:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v253, 135, 0, "callback signaled abort", v146, v147, v254);
  if (v279 == v293) {
    v248 = 0;
  }
  else {
    v248 = (AAByteStream_impl *)v279;
  }
  if (v283) {
    AAByteStreamCancel(v283);
  }
  AAByteStreamCancel(v288);
  int v290 = 0;
LABEL_357:
  if (v280)
  {
    AAByteStreamClose(*((AAByteStream *)v280 + 8194));
    AAByteStreamClose(*((AAByteStream *)v280 + 8193));
    free(v280);
  }
  free(v281);
  AAByteStreamClose((AAByteStream)v291);
  AAByteStreamClose((AAByteStream)s);
  AAByteStreamClose(v248);
  AAByteStreamClose(v296);
  AAByteStreamClose(v286);
  AAByteStreamClose((AAByteStream)v293);
  AAByteStreamClose(v283);
  AAByteStreamClose(compressed_stream);
  AAByteStreamClose(v288);
  AAByteStreamClose(v284);
  if (v290)
  {
    if (rawimg_get_digests(*v29, 4, 0, 1)
      || (*v31 == *(void *)(*v29 + 2088) ? (BOOL v249 = v31[1] == *(void *)(*v29 + 2096)) : (BOOL v249 = 0),
          v249 ? (BOOL v250 = v31[2] == *(void *)(*v29 + 2104)) : (BOOL v250 = 0),
          v250 ? (BOOL v251 = v31[3] == *(void *)(*v29 + 2112)) : (BOOL v251 = 0),
          !v251))
    {
      long long v121 = "digest mismatch";
      __int16 v122 = 630;
      goto LABEL_373;
    }
    if (*(int *)(a1 + 48) >= 2)
    {
      uint64_t v216 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v217 = "ImagePatch: Digest match. Output reconstructed.\n";
      size_t v218 = 48;
LABEL_381:
      fwrite(v217, v218, 1uLL, v216);
    }
    goto LABEL_382;
  }
  long long v121 = "patch_apply";
  __int16 v122 = 621;
LABEL_373:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", v122, 135, 0, v121, v107, v108, v254);
LABEL_374:
  int v27 = 0;
LABEL_375:
  if (*((_WORD *)v30 + 4))
  {
    unint64_t v252 = 0;
    do
      rawimg_destroy((uint64_t *)v29[v252++]);
    while (v252 < *((unsigned __int16 *)v30 + 4));
  }
LABEL_27:
  if (!a2)
  {
LABEL_30:
    if (AAByteStreamClose(v6) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 649, 135, 0, "AAByteStreamClose", v32, v33, v254);
      int v27 = 0;
    }
  }
  free(v31);
  free(v30);
  free(v29);
  free(v28);
  if (v27) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ctrl_reader_get(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1 + 0x10000;
  uint64_t v9 = *(void *)(a1 + 65560);
  if (*(void *)(v9 + 18) <= a2) {
    return 0;
  }
  unint64_t v11 = a2 + a2 * *(unsigned __int16 *)(v9 + 8);
  if (v11 >= *(void *)(a1 + 65584)) {
    goto LABEL_8;
  }
  uint64_t v12 = *(void *)(a1 + 65568);
  *(void *)(a1 + 65584) = -*(void *)(a1 + 65576);
  AAByteStreamClose(*(AAByteStream *)(a1 + 65552));
  *(void *)(v8 + 16) = 0;
  AAByteStreamClose(*(AAByteStream *)(v8 + 8));
  *(void *)(v8 + 8) = 0;
  uint64_t v13 = aaIntervalInputStreamOpen(*(void *)v8, *(void *)(v9 + 38), *(void *)(v9 + 46));
  *(void *)(v8 + 8) = v13;
  if (!v13)
  {
    int v27 = "aaIntervalInputStreamOpen";
    __int16 v28 = 81;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_get", v28, 135, 0, v27, a7, a8, v30);
    return 0;
  }
  uint64_t v14 = *(unsigned int *)(v12 + 48);
  if (v14 <= 3) {
    AAFlagSet v15 = v14 << 62;
  }
  else {
    AAFlagSet v15 = 0xC000000000000000;
  }
  AAByteStream v16 = AADecompressionInputStreamOpen(v13, v15, *(_DWORD *)(v12 + 44));
  *(void *)(v8 + 16) = v16;
  if (!v16)
  {
    int v27 = "AADecompressionInputStreamOpen";
    __int16 v28 = 83;
    goto LABEL_24;
  }
LABEL_8:
  while (1)
  {
    unint64_t v17 = *(void *)(v8 + 40);
    uint64_t v18 = *(void *)(v8 + 48);
    uint64_t v19 = v17 + v18;
    if (v11 < v17 + v18) {
      return a1 + 8 * (v11 - v18);
    }
    *(void *)(v8 + 48) = v19;
    unint64_t v20 = *(void *)(v8 + 56) - v19;
    if (v20 < v17) {
      unint64_t v17 = v20;
    }
    uint64_t v21 = *(void *)(v8 + 16);
    if (*(void *)(v21 + 16))
    {
      uint64_t v22 = 0;
      uint64_t v23 = 8 * v17;
      if (8 * v17)
      {
        uint64_t v24 = a1;
        uint64_t v25 = 8 * v17;
        while (1)
        {
          uint64_t v26 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v21 + 16))(*(void *)v21, v24, v25);
          if (v26 < 0) {
            break;
          }
          if (v26)
          {
            v24 += v26;
            v22 += v26;
            v25 -= v26;
            if (v25) {
              continue;
            }
          }
          goto LABEL_19;
        }
        uint64_t v22 = v26;
      }
LABEL_19:
      if (v23 == v22) {
        continue;
      }
    }
    int v27 = "aaByteStreamReadExpected";
    __int16 v28 = 91;
    goto LABEL_24;
  }
}

off_t AARandomAccessByteStreamProcess(AAByteStream istream, AAByteStream ostream, off_t max_offset, size_t block_size, AAFlagSet flags, int n_threads)
{
  if ((uint64_t)block_size <= 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"AARandomAccessByteStreamProcess", 315, 89, 0, "Invalid arguments", v6, v7, v89);
    return -1;
  }
  LODWORD(v8) = n_threads;
  if ((flags & 0x400) == 0)
  {
    if (n_threads <= 0) {
      LODWORD(v8) = getDefaultNThreads();
    }
    AAByteStream __s = 0;
    off_t v92 = 0;
    uint64_t v93 = 0;
    memset_s(&__s, 0x18uLL, 0, 0x18uLL);
    AAByteStream __s = ostream;
    uint64_t v8 = v8;
    uint64_t v13 = (void ***)calloc(v8, 8uLL);
    if (v13)
    {
      uint64_t v14 = v13;
      if (v8)
      {
        AAFlagSet v15 = (AAByteStream **)v13;
        uint64_t v16 = v8;
        while (1)
        {
          unint64_t v17 = (AAByteStream *)malloc(0x38uLL);
          if (!v17)
          {
            int v75 = *__error();
            __int16 v78 = 125;
            goto LABEL_58;
          }
          uint64_t v18 = v17;
          memset_s(v17, 0x38uLL, 0, 0x38uLL);
          *AAFlagSet v15 = v18;
          v18[1] = (AAByteStream)block_size;
          v18[2] = 0;
          *uint64_t v18 = istream;
          if (block_size >= 0x2000000001) {
            break;
          }
          uint64_t v19 = (AAByteStream_impl *)malloc(block_size);
          v18[3] = v19;
          if (!v19) {
            goto LABEL_57;
          }
          ++v15;
          if (!--v16) {
            goto LABEL_12;
          }
        }
        *__error() = 12;
        v18[3] = 0;
LABEL_57:
        int v75 = *__error();
        __int16 v78 = 131;
LABEL_58:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processSequential", v78, 89, v75, "malloc", v76, v77, v89);
        int v27 = 0;
      }
      else
      {
LABEL_12:
        int v27 = ThreadPipelineCreate(v8, (uint64_t)v14, (uint64_t)sequentialReaderProc, (uint64_t)&__s, (uint64_t)sequentialWriterProc, 0);
        if (v27)
        {
          off_t v28 = 0;
          if ((unint64_t)max_offset >= 0x7FFFFFFFFFFFFFFFLL) {
            off_t v29 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            off_t v29 = max_offset;
          }
          while (1)
          {
            unsigned int v30 = atomic_load((unsigned int *)&v93 + 1);
            if (v30
              || (unsigned int v31 = atomic_load((unsigned int *)&v93)) != 0
              || ((uint64_t)(v28 + block_size) >= v29 ? (off_t v32 = v29) : (off_t v32 = v28 + block_size), v32 < v28))
            {
              char v73 = 0;
              goto LABEL_65;
            }
            uint64_t Worker = ThreadPipelineGetWorker((uint64_t)v27, v20, v21, v22, v23, v24, v25, v26);
            if (!Worker) {
              break;
            }
            *(void *)(Worker + 32) = v32 - v28;
            *(void *)(Worker + 40) = v28;
            off_t v28 = v32;
            if ((ThreadPipelineRunWorker((uint64_t)v27, Worker, v34, v35, v36, v37, v25, v26) & 0x80000000) != 0)
            {
              uint64_t v38 = "running task";
              __int16 v39 = 158;
              goto LABEL_63;
            }
          }
          uint64_t v38 = "allocating reader";
          __int16 v39 = 153;
        }
        else
        {
          uint64_t v38 = "ThreadPipelineCreate";
          __int16 v39 = 136;
        }
LABEL_63:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processSequential", v39, 89, 0, v38, v25, v26, v89);
      }
      char v73 = 1;
LABEL_65:
      ThreadPipelineDestroy((uint64_t)v27);
      if (v8)
      {
        uint64_t v83 = v14;
        do
        {
          uint64_t v84 = *v83++;
          free(v84[3]);
          free(v84);
          --v8;
        }
        while (v8);
      }
      free(v14);
      if ((v73 & 1) == 0) {
        return v92;
      }
    }
    else
    {
      AAFlagSet v67 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processSequential", 121, 89, *v67, "malloc", v68, v69, v89);
      ThreadPipelineDestroy(0);
    }
    return -1;
  }
  if (n_threads <= 0) {
    LODWORD(v8) = getDefaultNThreads();
  }
  LODWORD(__s) = 0;
  unsigned int v94 = 0;
  uint64_t v40 = v8;
  __int16 v41 = (AAByteStream **)calloc(v8, 8uLL);
  if (!v41)
  {
    AAByteStream v70 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processRandomAccess", 246, 89, *v70, "malloc", v71, v72, v89);
    ThreadPoolDestroy(0);
    return -1;
  }
  uint64_t v90 = (uint64_t)v41;
  if (v8)
  {
    uint64_t v42 = v41;
    uint64_t v8 = v8;
    while (1)
    {
      uint64_t v43 = (AAByteStream *)malloc(0x48uLL);
      if (!v43)
      {
        int v79 = *__error();
        __int16 v82 = 250;
        goto LABEL_61;
      }
      uint64_t v44 = v43;
      memset_s(v43, 0x48uLL, 0, 0x48uLL);
      uint64_t *v42 = v44;
      *uint64_t v44 = istream;
      v44[1] = ostream;
      v44[4] = (AAByteStream)&__s;
      v44[5] = (AAByteStream)&v94;
      size_t v44[2] = (AAByteStream)block_size;
      if (block_size >= 0x2000000001) {
        break;
      }
      uint64_t v45 = (AAByteStream_impl *)malloc(block_size);
      v44[3] = v45;
      if (!v45) {
        goto LABEL_60;
      }
      ++v42;
      if (!--v8) {
        goto LABEL_35;
      }
    }
    *__error() = 12;
    v44[3] = 0;
LABEL_60:
    int v79 = *__error();
    __int16 v82 = 258;
LABEL_61:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processRandomAccess", v82, 89, v79, "malloc", v80, v81, max_offset);
    __int16 v54 = 0;
    char v74 = 1;
    uint64_t v46 = (uint64_t *)v90;
  }
  else
  {
LABEL_35:
    uint64_t v46 = (uint64_t *)v90;
    __int16 v54 = ThreadPoolCreate(v40, v90, (uint64_t)randomAccessWorkerProc);
    if (v54)
    {
      off_t v55 = 0;
      if ((unint64_t)max_offset >= 0x7FFFFFFFFFFFFFFFLL) {
        off_t v56 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        off_t v56 = max_offset;
      }
      while (1)
      {
        unsigned int v57 = atomic_load((unsigned int *)&__s);
        if (v57
          || (unsigned int v58 = atomic_load(&v94)) != 0
          || ((uint64_t)(v55 + block_size) >= v56 ? (off_t v59 = v56) : (off_t v59 = v55 + block_size), v59 < v55))
        {
          char v74 = 0;
          goto LABEL_72;
        }
        uint64_t v60 = ThreadPoolGetWorker((uint64_t)v54, v47, v48, v49, v50, v51, v52, v53);
        if (!v60) {
          break;
        }
        *(void *)(v60 + 56) = v59 - v55;
        *(void *)(v60 + 64) = v55;
        off_t v55 = v59;
        if ((ThreadPoolRunWorker((uint64_t)v54, v60, v61, v62, v63, v64, v52, v53) & 0x80000000) != 0)
        {
          uint64_t v65 = "running task";
          __int16 v66 = 285;
          goto LABEL_71;
        }
      }
      uint64_t v65 = "allocating reader";
      __int16 v66 = 280;
    }
    else
    {
      uint64_t v65 = "ThreadPipelineCreate";
      __int16 v66 = 263;
    }
LABEL_71:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"processRandomAccess", v66, 89, 0, v65, v52, v53, max_offset);
    char v74 = 1;
  }
LABEL_72:
  ThreadPoolDestroy((uint64_t)v54);
  off_t v85 = 0;
  if (v40)
  {
    size_t v86 = v46;
    do
    {
      uint64_t v87 = *v86++;
      v85 += *(void *)(v87 + 48);
      free(*(void **)(v87 + 24));
      free((void *)v87);
      --v40;
    }
    while (v40);
  }
  free(v46);
  if (v74) {
    return -1;
  }
  return v85;
}

uint64_t sequentialReaderProc(uint64_t a1)
{
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  size_t v2 = *(void *)(a1 + 32);
  if (v2 <= *(void *)(a1 + 8))
  {
    if (!v2) {
      return 0;
    }
    ssize_t v3 = AAByteStreamPRead(*(AAByteStream *)a1, *(void **)(a1 + 24), v2, *(void *)(a1 + 40));
    if ((v3 & 0x8000000000000000) == 0)
    {
      ssize_t v6 = v3;
      uint64_t result = 0;
      *(void *)(a1 + 16) = v6;
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"sequentialReaderProc", 49, 89, 0, "PRead", v4, v5, v8);
  }
  *(_DWORD *)(a1 + 48) = 1;
  return 0xFFFFFFFFLL;
}

uint64_t sequentialWriterProc(uint64_t a1, uint64_t a2)
{
  size_t v2 = (atomic_uint *)(a1 + 20);
  if (atomic_load((unsigned int *)(a1 + 20))) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a2 + 48))
  {
    size_t v7 = *(void *)(a2 + 16);
    if (!v7)
    {
      uint64_t result = 0;
      size_t v2 = (atomic_uint *)(a1 + 16);
      goto LABEL_5;
    }
    char v8 = *(char **)(a2 + 24);
    while (1)
    {
      ssize_t v9 = AAByteStreamWrite(*(AAByteStream *)a1, v8, v7);
      if (v9 <= 0) {
        break;
      }
      v8 += v9;
      *(void *)(a1 + 8) += v9;
      v7 -= v9;
      if (!v7) {
        return 0;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"sequentialWriterProc", 87, 89, 0, "Write failed", v10, v11, v12);
  }
  uint64_t result = 0xFFFFFFFFLL;
LABEL_5:
  int v5 = 0;
  atomic_compare_exchange_strong(v2, (unsigned int *)&v5, 1u);
  return result;
}

uint64_t randomAccessWorkerProc(uint64_t a1)
{
  if (!atomic_load(*(unsigned int **)(a1 + 32)))
  {
    size_t v3 = *(void *)(a1 + 56);
    if (v3 <= *(void *)(a1 + 16))
    {
      if (!v3) {
        return 0;
      }
      ssize_t v4 = AAByteStreamPRead(*(AAByteStream *)a1, *(void **)(a1 + 24), v3, *(void *)(a1 + 64));
      if (v4 < 0)
      {
        ssize_t v9 = "PRead";
        __int16 v10 = 207;
      }
      else
      {
        ssize_t v7 = v4;
        if (!v4)
        {
          int v11 = 0;
          uint64_t result = 0;
          atomic_compare_exchange_strong(*(atomic_uint *volatile *)(a1 + 40), (unsigned int *)&v11, 1u);
          return result;
        }
        if (AAByteStreamPWrite(*(AAByteStream *)(a1 + 8), *(const void **)(a1 + 24), v4, *(void *)(a1 + 64)) == v4)
        {
          uint64_t result = 0;
          *(void *)(a1 + 48) += v7;
          return result;
        }
        ssize_t v9 = "Write";
        __int16 v10 = 219;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessByteStreamProcess.c", (uint64_t)"randomAccessWorkerProc", v10, 89, 0, v9, v5, v6, v13);
    }
    int v12 = 0;
    atomic_compare_exchange_strong(*(atomic_uint *volatile *)(a1 + 32), (unsigned int *)&v12, 1u);
  }
  return 0xFFFFFFFFLL;
}

void *AEADecryptionDirectRandomAccessInputStreamOpen(AAByteStream_impl *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 <= 0) {
    getDefaultNThreads();
  }
  if (!*(_DWORD *)(a2 + 2736) || !*(void *)(a2 + 2728))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionDirectRandomAccessInputStreamOpen", 148, 122, 0, "Invalid context", a7, a8, v25);
    char v13 = 0;
    int v11 = 0;
LABEL_17:
    BlockDecryptionStreamClose(v13);
    free(v11);
    return 0;
  }
  int v11 = calloc(1uLL, 0x68uLL);
  int v12 = (uint64_t *)malloc(0x30uLL);
  char v13 = v12;
  if (!v12 || (memset_s(v12, 0x30uLL, 0, 0x30uLL), !v11))
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 153;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"AEADecryptionDirectRandomAccessInputStreamOpen", v23, 122, v21, v22, v15, v16, v25);
    goto LABEL_17;
  }
  *char v13 = (uint64_t)a1;
  v13[1] = a3;
  if ((a3 & 0x400000000000000) != 0) {
    *(_DWORD *)(a2 + 2740) = 1;
  }
  uint64_t Existing = aeaContainerCreateExisting(a2, a1, 1, 0);
  v13[2] = Existing;
  if (!Existing)
  {
    uint64_t v22 = "unlock container";
    __int16 v23 = 166;
    int v21 = 0;
    goto LABEL_16;
  }
  if (*(_DWORD *)(Existing + 24))
  {
    compression_algorithm v17 = aeaEffectiveCompressionAlgorithm(*(unsigned int *)(Existing + 24));
    v13[3] = compression_decode_scratch_buffer_size(v17);
    uint64_t Existing = v13[2];
  }
  *int v11 = v13;
  v11[1] = BlockDecryptionStreamClose;
  v11[7] = BlockDecryptionStreamCancel;
  v11[4] = BlockDecryptionStreamPRead;
  v11[2] = BlockDecryptionStreamRead;
  *(_OWORD *)a2 = *(_OWORD *)Existing;
  long long v18 = *(_OWORD *)(Existing + 16);
  long long v19 = *(_OWORD *)(Existing + 32);
  long long v20 = *(_OWORD *)(Existing + 48);
  *(void *)(a2 + 64) = *(void *)(Existing + 64);
  *(_OWORD *)(a2 + 32) = v19;
  *(_OWORD *)(a2 + 48) = v20;
  *(_OWORD *)(a2 + 16) = v18;
  return v11;
}

uint64_t BlockDecryptionStreamClose(uint64_t *a1)
{
  if (a1)
  {
    aeaContainerDestroy(a1[2]);
    free(a1);
  }
  return 0;
}

void BlockDecryptionStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 32), (unsigned int *)&v1, 1u);
  if (!v1) {
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t BlockDecryptionStreamPRead(uint64_t a1, uint8_t *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a4 & 0x8000000000000000) != 0)
  {
    ssize_t v9 = "negative offset";
    __int16 v10 = 55;
    goto LABEL_6;
  }
  unint64_t v8 = a4;
  if (__CFADD__(a4, a3))
  {
    ssize_t v9 = "invalid request";
    __int16 v10 = 59;
LABEL_6:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", v10, 122, 0, v9, a7, a8, v40);
    int v11 = 0;
    int v12 = 0;
    char v13 = 0;
    uint64_t v14 = -1;
    goto LABEL_47;
  }
  uint64_t v16 = *(void *)(a1 + 16);
  unint64_t v17 = *(void *)(v16 + 32);
  if (v17 <= a4) {
    goto LABEL_46;
  }
  if (a4 + a3 < v17) {
    unint64_t v17 = a4 + a3;
  }
  if (v17 <= a4)
  {
LABEL_46:
    int v11 = 0;
    uint64_t v14 = 0;
    int v12 = 0;
    char v13 = 0;
    goto LABEL_47;
  }
  uint64_t v14 = 0;
  char v13 = 0;
  int v12 = 0;
  int v11 = 0;
  int v42 = *(_DWORD *)(v16 + 24);
  size_t v19 = *(unsigned int *)(v16 + 16);
  unint64_t v41 = v17;
  __uint64_t size = v19;
  while (1)
  {
    long long v20 = v12;
    size_t v21 = v8 / v19;
    uint64_t v22 = *(void *)(a1 + 16);
    if (v8 / v19 >= *(unsigned int *)(v22 + 400))
    {
      uint64_t v36 = v13;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", 69, 122, 0, "invalid state", a7, a8, v40);
      char v13 = v36;
LABEL_50:
      uint64_t v14 = -1;
      int v12 = (uint8_t *)v20;
      goto LABEL_47;
    }
    size_t v23 = v21 * v19;
    uint64_t v24 = *(unsigned int *)(*(void *)(v22 + 392) + 544 * v21 + 4);
    size_t v25 = v21 * v19 + v24;
    if (v8 <= v23) {
      size_t v26 = v23;
    }
    else {
      size_t v26 = v8;
    }
    if (v25 >= v17) {
      size_t v25 = v17;
    }
    size_t v43 = v26;
    size_t v27 = v25 - v26;
    BOOL v28 = v23 >= v8 && v27 == v24;
    char v29 = v28;
    char v45 = v29;
    if (v28)
    {
      uint64_t v47 = a2;
      goto LABEL_29;
    }
    uint64_t v47 = v13;
    if (!v13)
    {
      char v13 = (uint8_t *)malloc(__size);
      uint64_t v47 = v13;
      if (!v13)
      {
        uint64_t v37 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", 93, 122, *v37, "malloc", v38, v39, v40);
        char v13 = 0;
        goto LABEL_50;
      }
    }
LABEL_29:
    uint64_t v46 = v13;
    if (v42)
    {
      int v12 = (uint8_t *)v20;
      if (!v20) {
        int v12 = (uint8_t *)malloc(__size);
      }
      if (!v11)
      {
        size_t v30 = *(void *)(a1 + 24);
        if (v30)
        {
          if (v30 < 0x2000000001)
          {
            int v11 = malloc(v30);
          }
          else
          {
            int v11 = 0;
            *__error() = 12;
          }
        }
      }
      if (!v12 || !v11 && *(void *)(a1 + 24))
      {
        int v33 = *__error();
        uint64_t v34 = "malloc";
        __int16 v35 = 100;
        goto LABEL_52;
      }
      long long v20 = v12;
      uint64_t v22 = *(void *)(a1 + 16);
    }
    uint64_t v31 = v22;
    int v12 = (uint8_t *)v20;
    if (aeaContainerLoadSegment(v31, *(void **)a1, v21, v47, v20, v11, a7, a8) < 0) {
      break;
    }
    if ((v45 & 1) == 0) {
      memcpy(a2, &v47[v43 - v23], v27);
    }
    v8 += v27;
    a2 += v27;
    v14 += v27;
    unint64_t v17 = v41;
    char v13 = v46;
    size_t v19 = __size;
    if (v8 >= v41) {
      goto LABEL_47;
    }
  }
  uint64_t v34 = "loading segment";
  __int16 v35 = 105;
  int v33 = 0;
LABEL_52:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADirectRandomAccessDecryptionStream.c", (uint64_t)"BlockDecryptionStreamPRead", v35, 122, v33, v34, a7, a8, v40);
  uint64_t v14 = -1;
  char v13 = v46;
LABEL_47:
  free(v13);
  free(v12);
  free(v11);
  return v14;
}

uint64_t BlockDecryptionStreamRead(uint64_t a1, uint8_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return BlockDecryptionStreamPRead(a1, a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 40), a3), a5, a6, a7, a8);
}

uint64_t ECC65537GetParity(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (a1 > 0x1FFE0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = (a1 & 1) + a1;
  if (v4)
  {
    int8x16_t v5 = 0uLL;
    int8x8_t v6 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_214B129D0))));
    int8x16_t v7 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_214B129E0), (int16x8_t)vceqzq_s32((int32x4_t)qword_214B129F0)));
    v8.i64[0] = 0xFFFF0000FFFFLL;
    v8.i64[1] = 0xFFFF0000FFFFLL;
    v9.i64[0] = 0x1000000010000;
    v9.i64[1] = 0x1000000010000;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    int8x16_t v11 = 0uLL;
    int8x16_t v12 = 0uLL;
    int32x4_t v13 = 0uLL;
    do
    {
      uint64_t v14 = v4 - 2;
      if (v4 <= a1) {
        __int32 v15 = *(unsigned __int16 *)(a2 + v14);
      }
      else {
        __int32 v15 = *(unsigned __int8 *)(a2 + v14);
      }
      int32x4_t v16 = (int32x4_t)vextq_s8(v12, (int8x16_t)v13, 0xCuLL);
      int32x4_t v17 = (int32x4_t)vextq_s8(v11, v12, 0xCuLL);
      int32x4_t v18 = (int32x4_t)vextq_s8(qword_214B129F0, v5, 0xCuLL);
      int32x4_t v19 = vdupq_laneq_s32(v13, 3);
      v18.i32[0] = v15;
      int32x4_t v20 = (int32x4_t)vextq_s8(v5, v11, 0xCuLL);
      int32x4_t v21 = vmulq_laneq_s32((int32x4_t)xmmword_214B129E0, v13, 3);
      int32x4_t v22 = vmulq_laneq_s32((int32x4_t)qword_214B129F0, v13, 3);
      int32x4_t v23 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v13, 3);
      int32x4_t v24 = vmulq_laneq_s32(unk_214B129D0, v13, 3);
      int16x8_t v25 = (int16x8_t)vceqzq_s32(v19);
      int8x16_t v26 = (int8x16_t)vuzp1q_s16(v25, v25);
      int8x8_t v27 = vmovn_s16((int16x8_t)vmvnq_s8(v26));
      int8x8_t v28 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v23), (int16x8_t)vceqzq_s32(v24)));
      int8x16_t v29 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v21), (int16x8_t)vceqzq_s32(v22));
      int8x16_t v30 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v22, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x10uLL));
      int8x16_t v31 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v21, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x10uLL));
      int8x16_t v32 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v24, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x10uLL));
      int8x16_t v33 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v23, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x10uLL));
      *(int8x8_t *)v26.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v7, v26), v29));
      int32x4_t v34 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v30, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v30)), (int8x16_t)vqsubq_u32((uint32x4_t)v30, v9)));
      int32x4_t v35 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v31, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v31)), (int8x16_t)vqsubq_u32((uint32x4_t)v31, v9)));
      *(int8x8_t *)v26.i8 = vand_s8(vand_s8(v6, v28), v27);
      int8x16_t v36 = (int8x16_t)vsubq_s32(v18, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v33, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v33)), (int8x16_t)vqsubq_u32((uint32x4_t)v33, v9))));
      int8x16_t v37 = (int8x16_t)vsubq_s32(v20, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v32, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v32)), (int8x16_t)vqsubq_u32((uint32x4_t)v32, v9))));
      int8x16_t v38 = (int8x16_t)vsubq_s32(v17, v35);
      int8x16_t v39 = (int8x16_t)vsubq_s32(v16, v34);
      int32x4_t v13 = (int32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v39)), (int8x16_t)vqsubq_u32((uint32x4_t)v39, v9));
      int8x16_t v12 = vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v9));
      int8x16_t v11 = vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v9));
      int8x16_t v5 = vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v9));
      unsigned int v4 = v14;
    }
    while (v14);
  }
  else
  {
    int8x16_t v5 = 0uLL;
    int8x16_t v11 = 0uLL;
    int8x16_t v12 = 0uLL;
    int32x4_t v13 = 0uLL;
  }
  uint64_t v40 = 0;
  int v41 = 0;
  v44[0] = v5;
  v44[1] = v11;
  size_t v44[2] = v12;
  v44[3] = v13;
  do
  {
    int v42 = *((_DWORD *)v44 + v40);
    if (v42) {
      int v43 = 65537 - v42;
    }
    else {
      int v43 = 0;
    }
    v41 |= (1 << v40) & (v43 << 15 >> 31);
    *(_WORD *)(a3 + 2 * v40++) = v43;
  }
  while (v40 != 16);
  uint64_t result = 0;
  *(_WORD *)(a3 + 32) = v41;
  return result;
}

uint64_t ECC65537CheckAndFix(unsigned int a1, uint64_t a2, uint16x8_t *a3, _DWORD *a4)
{
  uint64_t v118 = *MEMORY[0x263EF8340];
  int8x16_t v7 = 0uLL;
  unsigned int v8 = (a1 & 1) + a1;
  if (v8)
  {
    int8x16_t v9 = 0uLL;
    int8x8_t v10 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_214B129D0))));
    int8x16_t v11 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_214B129E0), (int16x8_t)vceqzq_s32((int32x4_t)qword_214B129F0)));
    v12.i64[0] = 0xFFFF0000FFFFLL;
    v12.i64[1] = 0xFFFF0000FFFFLL;
    v13.i64[0] = 0x1000000010000;
    v13.i64[1] = 0x1000000010000;
    v14.i64[0] = 0x100000001;
    v14.i64[1] = 0x100000001;
    int8x16_t v15 = 0uLL;
    int8x16_t v16 = 0uLL;
    int32x4_t v17 = 0uLL;
    unsigned int v18 = (a1 & 1) + a1;
    do
    {
      uint64_t v19 = v18 - 2;
      if (v18 <= a1) {
        __int32 v20 = *(unsigned __int16 *)(a2 + v19);
      }
      else {
        __int32 v20 = *(unsigned __int8 *)(a2 + v19);
      }
      int32x4_t v21 = (int32x4_t)vextq_s8(v16, (int8x16_t)v17, 0xCuLL);
      int32x4_t v22 = (int32x4_t)vextq_s8(v15, v16, 0xCuLL);
      int32x4_t v23 = (int32x4_t)vextq_s8((int8x16_t)0, v9, 0xCuLL);
      int32x4_t v24 = vdupq_laneq_s32(v17, 3);
      v23.i32[0] = v20;
      int32x4_t v25 = (int32x4_t)vextq_s8(v9, v15, 0xCuLL);
      int32x4_t v26 = vmulq_laneq_s32((int32x4_t)xmmword_214B129E0, v17, 3);
      int32x4_t v27 = vmulq_laneq_s32((int32x4_t)qword_214B129F0, v17, 3);
      int32x4_t v28 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v17, 3);
      int32x4_t v29 = vmulq_laneq_s32(unk_214B129D0, v17, 3);
      int16x8_t v30 = (int16x8_t)vceqzq_s32(v24);
      int8x16_t v31 = (int8x16_t)vuzp1q_s16(v30, v30);
      int8x8_t v32 = vmovn_s16((int16x8_t)vmvnq_s8(v31));
      int8x8_t v33 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v28), (int16x8_t)vceqzq_s32(v29)));
      int8x16_t v34 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v26), (int16x8_t)vceqzq_s32(v27));
      int8x16_t v35 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v27, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x10uLL));
      int8x16_t v36 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v26, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x10uLL));
      int8x16_t v37 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v29, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL));
      int8x16_t v38 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v28, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x10uLL));
      *(int8x8_t *)v31.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v11, v31), v34));
      int32x4_t v39 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v35, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v35)), (int8x16_t)vqsubq_u32((uint32x4_t)v35, v13)));
      int32x4_t v40 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v13)));
      *(int8x8_t *)v31.i8 = vand_s8(vand_s8(v10, v33), v32);
      int8x16_t v41 = (int8x16_t)vsubq_s32(v23, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v13))));
      int8x16_t v42 = (int8x16_t)vsubq_s32(v25, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v13))));
      int8x16_t v43 = (int8x16_t)vsubq_s32(v22, v40);
      int8x16_t v44 = (int8x16_t)vsubq_s32(v21, v39);
      int32x4_t v17 = (int32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v44)), (int8x16_t)vqsubq_u32((uint32x4_t)v44, v13));
      int8x16_t v16 = vorrq_s8(vandq_s8(v43, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v43)), (int8x16_t)vqsubq_u32((uint32x4_t)v43, v13));
      int8x16_t v15 = vorrq_s8(vandq_s8(v42, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v42)), (int8x16_t)vqsubq_u32((uint32x4_t)v42, v13));
      int8x16_t v9 = vorrq_s8(vandq_s8(v41, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v41)), (int8x16_t)vqsubq_u32((uint32x4_t)v41, v13));
      unsigned int v18 = v19;
    }
    while (v19);
  }
  else
  {
    int8x16_t v9 = 0uLL;
    int8x16_t v15 = 0uLL;
    int8x16_t v16 = 0uLL;
    int32x4_t v17 = 0uLL;
  }
  uint64_t v45 = 0;
  v117[0] = v9;
  v117[1] = v15;
  v117[2] = v16;
  v117[3] = v17;
  int32x4_t v46 = (int32x4_t)xmmword_214B12990;
  int8x16_t v47 = (int8x16_t)vdupq_n_s32(a3[2].u16[0]);
  int32x4_t v48 = (int32x4_t)xmmword_214B129A0;
  v49.i64[0] = 0x100000001;
  v49.i64[1] = 0x100000001;
  v50.i64[0] = 0x1000000010000;
  v50.i64[1] = 0x1000000010000;
  v51.i64[0] = 0x800000008;
  v51.i64[1] = 0x800000008;
  int8x16_t v52 = 0uLL;
  do
  {
    uint16x8_t v53 = *a3++;
    int8x16_t v54 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v53.i8);
    int8x16_t v55 = (int8x16_t)vmovl_high_u16(v53);
    off_t v56 = (int8x16_t *)&v117[v45];
    int32x4_t v57 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v46), v47)), v55, (int8x16_t)(*(_OWORD *)&v55 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45 + 1]);
    int32x4_t v58 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v48), v47)), v54, (int8x16_t)(*(_OWORD *)&v54 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45]);
    int8x16_t v59 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v57, v50), (uint32x4_t)v57);
    int8x16_t v60 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v58, v50), (uint32x4_t)v58);
    *off_t v56 = v60;
    v56[1] = v59;
    int8x16_t v52 = vorrq_s8(v59, v52);
    int8x16_t v7 = vorrq_s8(v60, v7);
    int32x4_t v48 = vaddq_s32(v48, v51);
    int32x4_t v46 = vaddq_s32(v46, v51);
    v45 += 2;
  }
  while (v45 != 4);
  int8x16_t v61 = vorrq_s8(v7, v52);
  if (vorr_s8(*(int8x8_t *)v61.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL)))
  {
    uint64_t v62 = (int *)calloc(1uLL, 0x4C0uLL);
    if (v62)
    {
      uint64_t v63 = v62;
      uint64_t v64 = 0;
      unsigned int v65 = v8 >> 1;
      int v66 = 1;
      do
      {
        v63[v64] = ecc65537PolyEval(16, (uint64_t)v117, v66);
        unsigned int v67 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        if (v67 + 65537 >= v67) {
          int v66 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        }
        else {
          int v66 = v67 + 65537;
        }
        ++v64;
      }
      while (v64 != 16);
      uint64_t v115 = a4;
      uint64_t v68 = 0;
      uint64_t v69 = 48;
      do
      {
        AAByteStream v70 = &v63[v69];
        long long v71 = *(_OWORD *)&v63[v68];
        long long v72 = *(_OWORD *)&v63[v68 + 4];
        v70[8] = v63[v68 + 8];
        *(_OWORD *)AAByteStream v70 = v71;
        *((_OWORD *)v70 + 1) = v72;
        v69 += 16;
        ++v68;
      }
      while (v68 != 8);
      int v73 = ecc65537Triangulate(8, 9, (uint64_t)(v63 + 48));
      if (v73 >= 1)
      {
        int v74 = v73;
        if ((ecc65537Solve(v73, v63 + 48, (uint64_t)(v63 + 16)) & 0x80000000) == 0)
        {
          uint64_t v114 = v63 + 48;
          unsigned int v75 = v74;
          int v76 = 0;
          int v77 = 0;
          unsigned int v116 = v75;
          int v78 = v75 + 1;
          unsigned int v79 = v65 + 16;
          int v80 = 1;
          do
          {
            if (!ecc65537PolyEval(v78, (uint64_t)(v63 + 16), v80) && v77 <= 7)
            {
              uint64_t v81 = &v63[v77++];
              v81[32] = v76;
            }
            unsigned int v82 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            if (v82 + 65537 >= v82) {
              int v80 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            }
            else {
              int v80 = v82 + 65537;
            }
            ++v76;
          }
          while (v79 != v76);
          if (v77 == v116)
          {
            uint64_t v83 = 0;
            uint64_t v84 = v116;
            do
            {
              uint64_t v85 = 0;
              uint64_t v86 = (16 * v83);
              do
              {
                int v87 = v63[v85 + 32] * v83;
                if (v87)
                {
                  int v88 = 3;
                  if (v87 < 0)
                  {
                    int v88 = ecc65537Inv(3);
                    int v87 = -v87;
                  }
                  unsigned int v89 = (unsigned __int16)v87;
                  unsigned int v90 = 1;
                  while (1)
                  {
                    if (v89)
                    {
                      if (v88 && v90 && !(v90 * v88))
                      {
                        unsigned int v90 = 1;
                      }
                      else
                      {
                        unsigned int v90 = (unsigned __int16)(v90 * v88) - ((v90 * v88) >> 16);
                        if (v90 + 65537 < v90) {
                          v90 += 65537;
                        }
                      }
                    }
                    if (v89 < 2) {
                      break;
                    }
                    v89 >>= 1;
                    unsigned int v91 = v88 * v88;
                    if (v88)
                    {
                      int v88 = 1;
                      if (!v91) {
                        continue;
                      }
                    }
                    unsigned int v92 = (unsigned __int16)v91 - HIWORD(v91);
                    if (v92 + 65537 >= v92) {
                      int v88 = v92;
                    }
                    else {
                      int v88 = v92 + 65537;
                    }
                  }
                }
                else
                {
                  unsigned int v90 = 1;
                }
                v63[v85 + 48 + v86] = v90;
                ++v85;
              }
              while (v85 != v116);
              int v93 = v63[v83];
              if (v93) {
                int v94 = 65537 - v93;
              }
              else {
                int v94 = 0;
              }
              v63[(int)(v86 + v116) + 48] = v94;
              ++v83;
            }
            while (v83 != v116);
            if (ecc65537Triangulate(v116, v78, (uint64_t)v114) == v116)
            {
              uint64_t v95 = v63 + 40;
              if ((ecc65537Solve(v116, v114, (uint64_t)(v63 + 40)) & 0x80000000) == 0)
              {
                uint64_t v97 = 0;
                int v98 = 0;
                while (1)
                {
                  int v99 = *(v95 - 8);
                  if (a1 > 2 * v99)
                  {
                    uint64_t v100 = (2 * v99);
                    BOOL v101 = (int)v100 + 2 <= a1 || a1 - v100 == 2;
                    int v102 = v101;
                    if (v101) {
                      int v103 = *(unsigned __int16 *)(a2 + v100);
                    }
                    else {
                      int v103 = *(unsigned __int8 *)(a2 + v100);
                    }
                    unsigned int v104 = v103 - *v95;
                    if (v104 + 65537 < v104) {
                      v104 += 65537;
                    }
                    if (HIWORD(v104)) {
                      goto LABEL_85;
                    }
                    int v105 = v104 ^ v103;
                    v96.i32[0] = v105;
                    int8x8_t v96 = vcnt_s8(v96);
                    v96.i16[0] = vaddlv_u8((uint8x8_t)v96);
                    v98 += v96.i32[0];
                    if ((_BYTE)v105) {
                      unsigned int v106 = v97 + 1;
                    }
                    else {
                      unsigned int v106 = v97;
                    }
                    if ((v105 & 0xFF00) != 0) {
                      uint64_t v97 = v106 + 1;
                    }
                    else {
                      uint64_t v97 = v106;
                    }
                    if (v102) {
                      *(_WORD *)(a2 + v100) = v104;
                    }
                    else {
                      *(unsigned char *)(a2 + v100) = v104;
                    }
                  }
                  ++v95;
                  uint64_t v107 = v97;
                  if (!--v84) {
                    goto LABEL_86;
                  }
                }
              }
            }
          }
        }
      }
      int v98 = 0;
      LODWORD(v97) = 0;
LABEL_85:
      uint64_t v107 = 0xFFFFFFFFLL;
LABEL_86:
      free(v63);
      if (v115 && (v107 & 0x80000000) == 0)
      {
        int v108 = v115[1] + v97;
        *v115 += v98;
        v115[1] = v108;
      }
    }
    else
    {
      uint64_t v109 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection_ECC65537.c", (uint64_t)"ECC65537CheckAndFix", 423, 63, *v109, "malloc", v110, v111, v113);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    return 0;
  }
  return v107;
}

uint64_t ecc65537PolyEval(int a1, uint64_t a2, int a3)
{
  if (a1 < 1) {
    return 0;
  }
  LODWORD(result) = 0;
  unint64_t v5 = a1 + 1;
  do
  {
    if (a3 && result && !(result * a3))
    {
      unsigned int v6 = 1;
    }
    else
    {
      unsigned int v6 = (unsigned __int16)(result * a3) - ((result * a3) >> 16);
      if (v6 + 65537 < v6) {
        v6 += 65537;
      }
    }
    unsigned int v7 = v6 + *(_DWORD *)(a2 + 4 * (v5 - 2));
    if (v7 - 65537 >= v7) {
      uint64_t result = v7;
    }
    else {
      uint64_t result = v7 - 65537;
    }
    --v5;
  }
  while (v5 > 1);
  return result;
}

uint64_t ecc65537Triangulate(uint64_t a1, int a2, uint64_t a3)
{
  if ((int)a1 < 1) {
    return 0;
  }
  unsigned int v3 = 0;
  uint64_t v4 = 0;
  int v5 = 0;
  LODWORD(v6) = 0;
  int v7 = 16;
  uint64_t v8 = 1;
  while (1)
  {
    if (v5 >= a2)
    {
      LODWORD(v11) = v6;
    }
    else
    {
      unsigned int v9 = v5 + v3;
LABEL_5:
      unsigned int v10 = v9;
      uint64_t v11 = v4;
      while (!*(_DWORD *)(a3 + 4 * (int)v10))
      {
        ++v11;
        v10 += 16;
        if (a1 == v11)
        {
          ++v5;
          ++v9;
          if (v5 != a2) {
            goto LABEL_5;
          }
          return v4;
        }
      }
    }
    uint64_t v6 = v4;
    if (v5 == a2) {
      return v6;
    }
    if (v4 == v11 || a2 <= 0)
    {
      int v12 = 16 * v4;
    }
    else
    {
      int v12 = 16 * v4;
      uint32x4_t v13 = (int *)(a3 + 64 * v11);
      uint64_t v14 = a2;
      unsigned int v15 = v3;
      do
      {
        int v16 = *v13;
        *v13++ = *(_DWORD *)(a3 + 4 * v15);
        *(_DWORD *)(a3 + 4 * v15++) = v16;
        --v14;
      }
      while (v14);
    }
    if (++v4 < (unint64_t)a1)
    {
      int v17 = *(_DWORD *)(a3 + 4 * (v12 + v5));
      uint64_t v18 = v5 + 1;
      uint64_t v19 = (int *)(a3 + 4 * (v12 + v18));
      int v20 = v7;
      uint64_t v21 = v8;
      do
      {
        int v22 = v5 + 16 * v21;
        int v23 = *(_DWORD *)(a3 + 4 * v22);
        if (v23)
        {
          *(_DWORD *)(a3 + 4 * v22) = 0;
          if ((int)v18 < a2)
          {
            int32x4_t v24 = (_WORD *)(a3 + 4 * (v18 + v20));
            int v25 = a2 - 1 - v5;
            int32x4_t v26 = v19;
            do
            {
              if (v17 && (*(_DWORD *)v24 ? (BOOL v27 = *(_DWORD *)v24 * v17 == 0) : (BOOL v27 = 0), v27))
              {
                unsigned int v28 = 1;
              }
              else
              {
                unsigned int v28 = (unsigned __int16)(*v24 * v17) - ((*(_DWORD *)v24 * v17) >> 16);
                if (v28 + 65537 < v28) {
                  v28 += 65537;
                }
              }
              int v30 = *v26++;
              int v29 = v30;
              int v31 = v30 * v23;
              unsigned int v32 = (unsigned __int16)(v30 * v23) - ((v30 * v23) >> 16);
              if (v32 + 65537 < v32) {
                v32 += 65537;
              }
              if (v29) {
                BOOL v33 = v31 == 0;
              }
              else {
                BOOL v33 = 0;
              }
              if (v33) {
                int v34 = 1;
              }
              else {
                int v34 = v32;
              }
              unsigned int v35 = v28 - v34;
              if (v35 + 65537 < v35) {
                v35 += 65537;
              }
              *(_DWORD *)int32x4_t v24 = v35;
              v24 += 2;
              --v25;
            }
            while (v25);
          }
        }
        ++v21;
        v20 += 16;
      }
      while (v21 != a1);
    }
    ++v8;
    v3 += 16;
    v7 += 16;
    if (v4 == a1) {
      return a1;
    }
  }
}

uint64_t ecc65537Solve(int a1, int *a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (a1 <= 0)
  {
    uint64_t v24 = 0;
    *(_DWORD *)(a3 + 4 * a1) = 1;
  }
  else
  {
    uint64_t v5 = a1;
    uint64_t v6 = a2;
    do
    {
      int v7 = *v6;
      v6 += 17;
      if (!v7) {
        return 0xFFFFFFFFLL;
      }
      --v5;
    }
    while (v5);
    *(_DWORD *)(a3 + 4 * a1) = 1;
    uint64_t v8 = a1;
    int v9 = 16 * a1 - 16;
    uint64_t v10 = a1;
    do
    {
      if (v10 <= v8)
      {
        unsigned int v11 = 0;
        uint64_t v12 = v8;
        do
        {
          int v13 = *(_DWORD *)(a3 + 4 * v12);
          int v14 = a2[v9 + v12];
          if (v13) {
            BOOL v15 = v14 == 0;
          }
          else {
            BOOL v15 = 1;
          }
          if (!v15 && v14 * v13 == 0)
          {
            unsigned int v17 = 1;
          }
          else
          {
            unsigned int v17 = (unsigned __int16)(v14 * v13) - ((v14 * v13) >> 16);
            if (v17 + 65537 < v17) {
              v17 += 65537;
            }
          }
          unsigned int v18 = v17 + v11;
          if (v18 - 65537 >= v18) {
            unsigned int v11 = v18;
          }
          else {
            unsigned int v11 = v18 - 65537;
          }
          BOOL v19 = v12-- <= v10;
        }
        while (!v19);
      }
      else
      {
        unsigned int v11 = 0;
      }
      int v20 = ecc65537Inv(a2[17 * v10 - 17]);
      if (v11 && (v20 ? (BOOL v21 = v20 * v11 == 0) : (BOOL v21 = 0), v21))
      {
        unsigned int v22 = 1;
      }
      else
      {
        unsigned int v22 = (unsigned __int16)(v20 * v11) - ((v20 * v11) >> 16);
        if (v22 + 65537 < v22) {
          v22 += 65537;
        }
      }
      if (65537 - v22 >= -v22) {
        int v23 = -v22;
      }
      else {
        int v23 = 65537 - v22;
      }
      *(_DWORD *)(a3 + 4 * (v10 - 1)) = v23;
      v9 -= 16;
      BOOL v19 = v10-- <= 1;
    }
    while (!v19);
    return 0;
  }
  return v24;
}

uint64_t ecc65537Inv(uint64_t a1)
{
  if (a1 == 1)
  {
    LODWORD(v1) = 1;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 1;
    uint64_t v4 = 65537;
    do
    {
      if (a1 <= v4)
      {
        char v5 = -1;
        do
        {
          unsigned int v6 = a1 << (v5 + 2);
          ++v5;
        }
        while (v6 <= v4);
        uint64_t v4 = (v4 - (a1 << v5));
        uint64_t v2 = (v2 - (v3 << v5));
      }
      uint64_t v1 = v2;
      uint64_t v7 = v4;
      uint64_t v2 = v3;
      uint64_t v3 = v1;
      uint64_t v4 = a1;
      a1 = v7;
    }
    while (v7 != 1);
  }
  int v8 = v1
     + 65537
     * (((v1 & ~((int)v1 >> 31)) - (v1 + (v1 >> 31))) / 0x10001
      + (v1 >> 31));
  if (v8 <= 0x10000) {
    unsigned int v9 = 0x10000;
  }
  else {
    unsigned int v9 = v1
  }
       + 65537
       * (((v1 & ~((int)v1 >> 31)) - (v1 + (v1 >> 31))) / 0x10001
        + (v1 >> 31));
  return v9 % 0x10001 - v9 + v8;
}

uint64_t ParallelCompressionGetCompressedSize(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3 = a2;
  if (a2 >= 0x400)
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    uint64_t v19 = 0;
    uint64_t v7 = IMemStreamCreate(a1, a2);
    if (v7)
    {
      DWORD2(v20) = a3;
      LODWORD(v20) = 0;
      DWORD1(v20) = getDefaultNThreads();
      *(void *)&long long v21 = 0x200000;
      *((void *)&v21 + 1) = IMemStreamRead;
      *((void *)&v22 + 1) = v7;
      *(void *)&long long v23 = getCompressedSizeCounterProc;
      uint64_t v24 = &v19;
      if (!ParallelCompressionEncode((uint64_t)&v20, v8, v9, v10, v11, v12, v13, v14))
      {
        if (v19 < v3) {
          uint64_t v3 = v19;
        }
        goto LABEL_9;
      }
      BOOL v15 = "ParallelCompressionEncode";
      __int16 v16 = 75;
    }
    else
    {
      BOOL v15 = "IMemStreamCreate";
      __int16 v16 = 64;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ParallelCompressionGetCompressedSize", v16, 39, 0, v15, v5, v6, v18);
    uint64_t v3 = -1;
LABEL_9:
    OMemStreamDestroy(v7);
  }
  return v3;
}

uint64_t getCompressedSizeCounterProc(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 += a3;
  return a3;
}

size_t IDecoderStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result) {
    return SharedBufferAbort(*(void *)(result + 64), a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

uint64_t ILowMemoryDecoderStreamCreate(uint64_t (*a1)(uint64_t, uint64_t, unint64_t), uint64_t a2, uint64_t a3, size_t a4)
{
  uint64_t v8 = malloc(0xD8uLL);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    v8[26] = 0;
    *((_OWORD *)v8 + 11) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    *((_OWORD *)v8 + 2) = 0u;
    if (a4 <= 0x1000) {
      a4 = 4096;
    }
    *(_OWORD *)uint64_t v8 = 0uLL;
    uint64_t v10 = MemBufferCreate(a4);
    *(void *)(v9 + 56) = v10;
    if (!v10) {
      goto LABEL_27;
    }
    uint64_t v11 = MemBufferCreate(a4);
    *(void *)(v9 + 64) = v11;
    if (!v11) {
      goto LABEL_27;
    }
    *(_DWORD *)(v9 + 32) = -1;
    *(void *)uint64_t v9 = a1;
    *(void *)(v9 + 8) = a2;
    *(void *)(v9 + 16) = a3;
    if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0xCuLL, a1, a3) != 12)
    {
      uint64_t v19 = "couldn't read enough header bytes from compressed file";
      __int16 v20 = 465;
      goto LABEL_26;
    }
    uint64_t DataPtr = MemBufferGetDataPtr(*(void *)(v9 + 56));
    if ((*(_DWORD *)(v9 + 32) & 0x80000000) != 0)
    {
      BOOL v15 = (unsigned __int8 *)DataPtr;
      if (*(_WORD *)DataPtr == 25200 && *(unsigned char *)(DataPtr + 2) == 122)
      {
        unsigned int v25 = 0;
        while (1)
        {
          int v26 = v15[3];
          if (v26 == PCompressGetDecoderKey(v25)) {
            break;
          }
          if (++v25 == 7)
          {
            if ((*(_DWORD *)(v9 + 32) & 0x80000000) == 0) {
              return v9;
            }
            goto LABEL_12;
          }
        }
        *(void *)(v9 + 40) = bswap64(*(void *)(v15 + 4));
        *(void *)(v9 + 48) = PCompressGetDecoderFilter(v25);
        MemBufferDecreaseSize(*(void *)(v9 + 56), 0xCuLL, v34, v35, v36, v37, v38, v39);
        if ((MemBufferIncreaseCapacity(*(void *)(v9 + 56), *(void *)(v9 + 40)) & 0x8000000000000000) != 0)
        {
          uint64_t v19 = "MemBufferIncreaseCapacity in";
          __int16 v20 = 487;
        }
        else
        {
          if ((MemBufferIncreaseCapacity(*(void *)(v9 + 64), *(void *)(v9 + 40)) & 0x8000000000000000) == 0)
          {
            *(_DWORD *)(v9 + 32) = 0;
            return v9;
          }
          uint64_t v19 = "MemBufferIncreaseCapacity out";
          __int16 v20 = 488;
        }
        goto LABEL_26;
      }
LABEL_12:
      if (*(_DWORD *)v15 == 1484404733 && *((_WORD *)v15 + 2) == 90)
      {
        if (!lzma_stream_decoder())
        {
          *(_DWORD *)(v9 + 32) = 1;
          return v9;
        }
        uint64_t v19 = "lzma_stream_decoder";
        __int16 v20 = 503;
        goto LABEL_26;
      }
      BOOL v18 = *(_WORD *)v15 == 23106 && v15[2] == 104;
      if (v18 && v15[3] - 49 <= 8)
      {
        if (BZ2_bzDecompressInit((bz_stream *)(v9 + 72), 0, 0))
        {
          uint64_t v19 = "BZ2_bzDecompressInit";
          __int16 v20 = 514;
LABEL_26:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", v20, 39, 0, v19, v12, v13, v47);
LABEL_27:
          ILowMemoryDecoderStreamDestroy(v9);
          return 0;
        }
        int v44 = 3;
LABEL_54:
        *(_DWORD *)(v9 + 32) = v44;
        return v9;
      }
      int v27 = *v15;
      if (v27 == 120)
      {
        if (-1108378657 * (v15[1] | 0x7800u) <= 0x8421084)
        {
          if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB) == COMPRESSION_STATUS_OK)
          {
            MemBufferDecreaseSize(*(void *)(v9 + 56), 2uLL, v40, v41, v42, v43, v12, v13);
            *(_DWORD *)(v9 + 32) = 2;
            return v9;
          }
          uint64_t v19 = "compression_stream_init";
          __int16 v20 = 570;
          goto LABEL_26;
        }
      }
      else if (v27 == 31 && v15[1] == 139 && v15[2] == 8)
      {
        if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0x1000uLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))v9, *(void *)(v9 + 16)) < 0)
        {
          uint64_t v19 = "reading gzip header data";
          __int16 v20 = 525;
          goto LABEL_26;
        }
        unint64_t DataSize = MemBufferGetDataSize(*(void *)(v9 + 56));
        if ((v15[3] & 4) != 0)
        {
          if (DataSize <= 0xB)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 531;
            goto LABEL_26;
          }
          unint64_t v33 = *((unsigned __int16 *)v15 + 5) + 12;
          if (v33 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 534;
            goto LABEL_26;
          }
        }
        else
        {
          unint64_t v33 = 10;
        }
        if ((v15[3] & 8) != 0)
        {
          unint64_t v45 = v33 + 2;
          if (v33 + 2 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 539;
            goto LABEL_26;
          }
          if (v33 + 2 < DataSize)
          {
            while (v15[v33 + 1])
            {
              if (DataSize - 2 == ++v33)
              {
                unint64_t v45 = DataSize;
                goto LABEL_63;
              }
            }
            unint64_t v45 = v33 + 2;
          }
        }
        else
        {
          unint64_t v45 = v33;
        }
LABEL_63:
        if ((v15[3] & 0x10) != 0)
        {
          unint64_t v46 = v45 + 2;
          if (v45 + 2 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 545;
            goto LABEL_26;
          }
          if (v45 + 2 < DataSize)
          {
            while (v15[v45 + 1])
            {
              if (DataSize - 2 == ++v45)
              {
                unint64_t v46 = DataSize;
                goto LABEL_65;
              }
            }
            unint64_t v46 = v45 + 2;
          }
        }
        else
        {
          unint64_t v46 = v45;
        }
LABEL_65:
        if ((v15[3] & 2) != 0)
        {
          v46 += 2;
          if (v46 > DataSize)
          {
            uint64_t v19 = "parsing gzip header";
            __int16 v20 = 551;
            goto LABEL_26;
          }
        }
        MemBufferDecreaseSize(*(void *)(v9 + 56), v46, v29, v30, v31, v32, v12, v13);
        if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB))
        {
          uint64_t v19 = "compression_stream_init";
          __int16 v20 = 557;
          goto LABEL_26;
        }
        int v44 = 2;
        goto LABEL_54;
      }
      uint64_t v19 = "Could not identify compressed stream format";
      __int16 v20 = 579;
      goto LABEL_26;
    }
  }
  else
  {
    long long v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", 452, 39, *v21, "malloc", v22, v23, v47);
  }
  return v9;
}

void ILowMemoryDecoderStreamDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 32);
    switch(v2)
    {
      case 3:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 72));
        break;
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 72));
        break;
      case 1:
        lzma_end();
        break;
    }
    MemBufferDestroy(*(void ***)(a1 + 56));
    MemBufferDestroy(*(void ***)(a1 + 64));
    OMemStreamDestroy(*(void **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t ILowMemoryDecoderStreamCreateWithBuffer(uint64_t a1, uint64_t a2, size_t a3)
{
  uint64_t v4 = IMemStreamCreate(a1, a2);
  if (v4)
  {
    uint64_t v7 = v4;
    uint64_t result = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMemStreamRead, (uint64_t)IMemStreamAbort, (uint64_t)v4, a3);
    if (result)
    {
      *(void *)(result + 24) = v7;
      return result;
    }
    OMemStreamDestroy(v7);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreateWithBuffer", 596, 39, 0, "IMemStreamCreate failed", v5, v6, v9);
  }
  return 0;
}

uint64_t ILowMemoryDecoderStreamRead(uint64_t a1, char *a2, size_t a3)
{
  if (a1)
  {
    int v6 = 0;
    uint64_t v7 = 0;
    stream = (bz_stream *)(a1 + 72);
    do
    {
      if (!a3) {
        return v7;
      }
      unint64_t DataSize = MemBufferGetDataSize(*(void *)(a1 + 64));
      if (DataSize >= a3) {
        size_t v9 = a3;
      }
      else {
        size_t v9 = DataSize;
      }
      if (v9)
      {
        uint64_t DataPtr = (const void *)MemBufferGetDataPtr(*(void *)(a1 + 64));
        memcpy(a2, DataPtr, v9);
        MemBufferDecreaseSize(*(void *)(a1 + 64), v9, v11, v12, v13, v14, v15, v16);
        v7 += v9;
        a3 -= v9;
        if (!a3) {
          return v7;
        }
        a2 += v9;
      }
      if (*(_DWORD *)(a1 + 208)) {
        return v7;
      }
      unsigned int v17 = *(unint64_t **)(a1 + 56);
      if (!*(_DWORD *)(a1 + 32))
      {
        unint64_t v43 = MemBufferGetDataSize((uint64_t)v17);
        uint64_t v44 = v43;
        if (v43 <= 0xF)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), 16 - v43, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(void *)(a1 + 16)) < 0)
          {
            unsigned int v106 = "reading block header failed";
            __int16 v107 = 645;
            goto LABEL_76;
          }
          uint64_t v44 = MemBufferGetDataSize(*(void *)(a1 + 56));
          if (!v44)
          {
            *(_DWORD *)(a1 + 208) = 1;
            return v7;
          }
        }
        unint64_t v45 = (unint64_t *)MemBufferGetDataPtr(*(void *)(a1 + 56));
        unint64_t v51 = *v45;
        unint64_t v50 = v45[1];
        unint64_t v52 = bswap64(*v45);
        unint64_t v53 = bswap64(v50);
        unint64_t v54 = *(void *)(a1 + 40);
        if (v52 > v54 || v53 > v54)
        {
          unsigned int v106 = "invalid block header";
          __int16 v107 = 655;
          goto LABEL_76;
        }
        MemBufferDecreaseSize(*(void *)(a1 + 56), 0x10uLL, v46, v47, v48, v49, v18, v19);
        BOOL v56 = v53 >= v44 - 16;
        unint64_t v57 = v53 - (v44 - 16);
        if (v57 != 0 && v56)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), v57, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(void *)(a1 + 16)) != v57)
          {
            unsigned int v106 = "reading block payload failed";
            __int16 v107 = 665;
            goto LABEL_76;
          }
          MemBufferGetDataSize(*(void *)(a1 + 56));
        }
        if (v51 == v50)
        {
          FreePtr = (void *)MemBufferGetFreePtr(*(void *)(a1 + 64));
          int8x16_t v59 = (const void *)MemBufferGetDataPtr(*(void *)(a1 + 56));
          memcpy(FreePtr, v59, v52);
        }
        else
        {
          uint64_t v97 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, unint64_t))(a1 + 48);
          uint64_t v98 = MemBufferGetFreePtr(*(void *)(a1 + 64));
          uint64_t v99 = MemBufferGetDataPtr(*(void *)(a1 + 56));
          if (v97(v98, v52, v99, v53) != v52)
          {
            unsigned int v106 = "decoding block payload failed";
            __int16 v107 = 677;
            goto LABEL_76;
          }
        }
        MemBufferDecreaseSize(*(void *)(a1 + 56), v53, v60, v61, v62, v63, v18, v19);
        MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v52, v100, v101, v102, v103, v104, v105);
        goto LABEL_62;
      }
      if (MemBufferFillFromIStream(v17, 0xFFFFFFFFFFFFFFFFLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(void *)(a1 + 16)) < 0)
      {
        unsigned int v106 = "reading payload failed";
        __int16 v107 = 687;
        goto LABEL_76;
      }
      uint64_t v20 = MemBufferGetDataPtr(*(void *)(a1 + 56));
      uint64_t v21 = MemBufferGetDataSize(*(void *)(a1 + 56));
      uint64_t v22 = MemBufferGetFreePtr(*(void *)(a1 + 64));
      uint64_t FreeSize = MemBufferGetFreeSize(*(void **)(a1 + 64));
      uint64_t v26 = FreeSize;
      int v27 = *(_DWORD *)(a1 + 32);
      switch(v27)
      {
        case 1:
          *(void *)(a1 + 72) = v20;
          *(void *)(a1 + 80) = v21;
          *(void *)(a1 + 96) = v22;
          *(void *)(a1 + 104) = FreeSize;
          unsigned int v64 = lzma_code();
          unsigned int v71 = v64;
          if (v64 > 0xA || ((1 << v64) & 0x403) == 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 738, 39, 0, "decoding lzma payload", v69, v70, v109);
            int v81 = 1;
            goto LABEL_60;
          }
          uint64_t v72 = *(void *)(a1 + 72);
          uint64_t v73 = *(void *)(a1 + 96);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v72 - v20, v65, v66, v67, v68, v69, v70);
          if (v73 == v22 && v72 == v20) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v73 - v22, v74, v75, v76, v77, v78, v79);
          if (v71 != 1)
          {
            int v81 = 14;
LABEL_60:
            if (v71 > 0xA || ((1 << v71) & 0x403) == 0) {
              continue;
            }
            goto LABEL_62;
          }
          break;
        case 3:
          *(void *)(a1 + 72) = v20;
          *(_DWORD *)(a1 + 80) = v21;
          *(void *)(a1 + 96) = v22;
          *(_DWORD *)(a1 + 104) = FreeSize;
          int v82 = BZ2_bzDecompress(stream);
          if (v82 < 0)
          {
            unsigned int v106 = "decoding bzip2 payload";
            __int16 v107 = 722;
            goto LABEL_76;
          }
          int v87 = v82;
          uint64_t v88 = *(void *)(a1 + 72);
          uint64_t v89 = *(void *)(a1 + 96);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v88 - v20, v83, v84, v85, v86, v18, v19);
          if (v89 == v22 && v88 == v20) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v89 - v22, v90, v91, v92, v93, v94, v95);
          if (v87 != 4) {
            goto LABEL_62;
          }
          break;
        case 2:
          *(void *)(a1 + 88) = v20;
          *(void *)(a1 + 96) = v21;
          *(void *)(a1 + 72) = v22;
          *(void *)(a1 + 80) = FreeSize;
          compression_status v28 = compression_stream_process((compression_stream *)stream, 0);
          if (v28 < 0)
          {
            unsigned int v106 = "decoding zlib payload";
            __int16 v107 = 706;
            goto LABEL_76;
          }
          compression_status v33 = v28;
          uint64_t v34 = *(void *)(a1 + 96);
          uint64_t v35 = *(void *)(a1 + 80);
          MemBufferDecreaseSize(*(void *)(a1 + 56), v21 - v34, v29, v30, v31, v32, v18, v19);
          if (v26 == v35 && v21 == v34) {
            ++v6;
          }
          else {
            int v6 = 0;
          }
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v26 - v35, v36, v37, v38, v39, v40, v41);
          if (v33 != COMPRESSION_STATUS_END) {
            goto LABEL_62;
          }
          break;
        default:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 748, 39, 0, "invalid decoder: %d", v24, v25, *(_DWORD *)(a1 + 32));
          return -1;
      }
      *(_DWORD *)(a1 + 208) = 1;
LABEL_62:
      if (v6 >= 3)
      {
        unsigned int v106 = "Truncated stream";
        __int16 v107 = 753;
LABEL_76:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", v107, 39, 0, v106, v18, v19, v109);
        return -1;
      }
      int v81 = 0;
    }
    while (!v81);
  }
  return -1;
}

uint64_t rawimg_force_in_place(void *a1, unint64_t *a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*(void *)(a4 + 2120) <= a3[265]) {
    uint64_t v12 = a3[265];
  }
  else {
    uint64_t v12 = *(void *)(a4 + 2120);
  }
  uint64_t v15 = AAFileStreamOpenWithPath(*(const char **)(a4 + 2048), 0, 0);
  if (!v15)
  {
    uint64_t v99 = "AAFileStreamOpenWithPath";
    __int16 v100 = 234;
LABEL_121:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v100, 141, 0, v99, v13, v14, v145);
    unint64_t v43 = 0;
    uint64_t v40 = 0;
    compression_status v33 = 0;
    uint64_t v30 = 0;
    unsigned int v17 = 0;
LABEL_122:
    int v110 = 0;
    goto LABEL_123;
  }
  unint64_t v16 = (unint64_t)(a5 + 0x3FFF) >> 14;
  unsigned int v17 = (uint64_t *)calloc(1uLL, 0x68uLL);
  uint64_t v18 = calloc(1uLL, 0x28uLL);
  uint64_t v21 = v18;
  if ((v16 & 0x80000000) != 0)
  {
    uint64_t v101 = "too little excess";
    __int16 v102 = 184;
LABEL_120:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"aaSimStreamOpen", v102, 141, 0, v101, v19, v20, v145);
    free(v17);
    SimStreamClose((uint64_t)v21, v103, v104, v105, v106, v107, v108, v109);
    uint64_t v99 = "aaSimStreamOpen";
    __int16 v100 = 236;
    goto LABEL_121;
  }
  if (!v17 || !v18)
  {
    uint64_t v101 = "aaCalloc";
    __int16 v102 = 185;
    goto LABEL_120;
  }
  *uint64_t v18 = v15;
  *((_DWORD *)v18 + 4) = (unint64_t)(v12 + 0x3FFF) >> 14;
  *((_DWORD *)v18 + 8) = v16;
  *((_DWORD *)v18 + 9) = a6;
  if (((v12 + 0x3FFF) & 0x200000000000) != 0)
  {
    *__error() = 12;
    v21[1] = 0;
    goto LABEL_119;
  }
  uint64_t v22 = calloc(((unint64_t)(v12 + 0x3FFF) >> 14), 5uLL);
  v21[1] = v22;
  if (!v22)
  {
LABEL_119:
    uint64_t v101 = "aaCalloc";
    __int16 v102 = 195;
    goto LABEL_120;
  }
  AACustomByteStreamSetData((AAByteStream)v17, v21);
  AACustomByteStreamSetCloseProc((AAByteStream)v17, (AAByteStreamCloseProc)SimStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v17, (AAByteStreamPReadProc)SimStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v17, (AAByteStreamPWriteProc)SimStreamPWrite);
  v17[11] = (uint64_t)SimStreamSimulate;
  uint64_t v23 = *v17;
  uint64_t v24 = aaSegmentStreamOpen(v17, a3);
  uint64_t v30 = (AAByteStream_impl *)v24;
  if (!v24)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 241, 141, 0, "aaSegmentStreamOpen", v28, v29, v145);
    unint64_t v43 = 0;
    uint64_t v40 = 0;
    compression_status v33 = 0;
    goto LABEL_122;
  }
  compression_status v33 = aaForkInputStreamOpen(v24, (uint64_t)a3, 0, v25, v26, v27, v28, v29);
  if (!v33)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 243, 141, 0, "aaForkInputStreamOpen", v31, v32, v145);
    unint64_t v43 = 0;
    uint64_t v40 = 0;
    goto LABEL_122;
  }
  uint64_t v34 = aaSegmentStreamOpen(v17, (void *)a4);
  uint64_t v40 = (AAByteStream_impl *)v34;
  if (!v34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 247, 141, 0, "aaSegmentStreamOpen", v38, v39, v145);
    unint64_t v43 = 0;
    goto LABEL_122;
  }
  uint64_t v169 = v23;
  unint64_t v43 = aaForkInputStreamOpen(v34, a4, 0, v35, v36, v37, v38, v39);
  if (!v43)
  {
    uint64_t v97 = "aaForkOutputStreamOpen";
    __int16 v98 = 249;
LABEL_142:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v98, 141, 0, v97, v41, v42, v145);
    goto LABEL_122;
  }
  uint64_t v154 = 0;
  int64x2_t v152 = vdupq_n_s64(0x8000000000000000);
  int v151 = 1;
  BOOL v171 = a1;
  uint64_t v168 = v40;
  int v153 = a6;
  unint64_t v170 = a2;
  while (2)
  {
    bzero(*(void **)(v169 + 8), 5 * *(int *)(v169 + 16));
    int v44 = *(_DWORD *)(v169 + 16);
    *(void *)(v169 + 24) = 0;
    *(_DWORD *)(v169 + 20) = v44;
    unint64_t v45 = *a2;
    if (*a2)
    {
      uint64_t v46 = 0;
      unint64_t v47 = 0;
      do
      {
        uint64_t v48 = (unint64_t *)(*a1 + 24 * v47);
        if ((*v48 & 0x8000000000000000) == 0) {
          unint64_t v49 = *v48;
        }
        else {
          unint64_t v49 = 0x8000000000000000 - *v48;
        }
        uint64_t v50 = v48[2];
        uint64_t v51 = 0x8000000000000000 - v50;
        if (v50 >= 0) {
          uint64_t v51 = v50;
        }
        if (v49)
        {
          uint64_t v161 = v51;
          unint64_t v164 = v47;
          for (unint64_t i = 0; i < v49; i += v53)
          {
            if (v49 - i >= 0x10000) {
              uint64_t v53 = 0x10000;
            }
            else {
              uint64_t v53 = v49 - i;
            }
            if (v53 != aaByteStreamSimulate(v33))
            {
              uint64_t v124 = "aaByteStreamSimulate";
              __int16 v125 = 270;
              goto LABEL_144;
            }
          }
          a1 = v171;
          unint64_t v45 = *v170;
          uint64_t v51 = v161;
          unint64_t v47 = v164;
        }
        v46 += v49 + v51;
        ++v47;
      }
      while (v47 < v45);
    }
    int v54 = 1;
    unint64_t v55 = v45;
    uint64_t v156 = v30;
    do
    {
      if (!v55) {
        goto LABEL_59;
      }
      unint64_t v56 = 0;
      unint64_t v57 = 0;
      uint64_t v58 = 0;
      int v165 = v54;
      do
      {
        int8x16_t v59 = (unint64_t *)(*v171 + 24 * v56);
        uint64_t v60 = v59[1];
        unint64_t v61 = 0x8000000000000000 - *v59;
        if ((*v59 & 0x8000000000000000) == 0) {
          unint64_t v61 = *v59;
        }
        if (v60 >= 0) {
          unint64_t v62 = v59[1];
        }
        else {
          unint64_t v62 = 0x8000000000000000 - v60;
        }
        uint64_t v63 = v59[2];
        if (v63 < 0) {
          uint64_t v63 = 0x8000000000000000 - v63;
        }
        if (v54 == 2)
        {
          v57 += v61;
          if (v57 < *(void *)(a4 + 2056)) {
            goto LABEL_57;
          }
        }
        else
        {
          uint64_t v157 = v63;
          unint64_t v159 = v62;
          unint64_t v162 = v56;
          if (v61)
          {
            unint64_t v64 = 0;
            while (1)
            {
              unint64_t v65 = v61;
              if (v61 - v64 >= 0x10000) {
                uint64_t v66 = 0x10000;
              }
              else {
                uint64_t v66 = v61 - v64;
              }
              if (v66 != aaByteStreamSimulate(v33))
              {
                __int16 v126 = 298;
                goto LABEL_148;
              }
              if (v66 != aaByteStreamSimulate(v43)) {
                break;
              }
              v58 += v66;
              v57 += v66;
              v64 += v66;
              unint64_t v61 = v65;
              if (v64 >= v65) {
                goto LABEL_52;
              }
            }
            __int16 v126 = 299;
LABEL_148:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v126, 141, 0, "aaByteStreamSimulate", v41, v42, v145);
            int v110 = 0;
            uint64_t v40 = v168;
            uint64_t v30 = v156;
            goto LABEL_123;
          }
LABEL_52:
          v58 += v157;
          int v54 = v165;
          if (v165 == 1)
          {
            unint64_t v56 = v162;
            unint64_t v62 = v159;
            uint64_t v30 = v156;
            if (v57 >= *(void *)(a4 + 2056)) {
              goto LABEL_57;
            }
          }
          else
          {
            unint64_t v56 = v162;
            unint64_t v62 = v159;
            uint64_t v30 = v156;
          }
        }
        uint64_t v67 = aaByteStreamSimulate(v43);
        int v54 = v165;
        if (v62 != v67)
        {
          uint64_t v124 = "aaByteStreamSimulate";
          __int16 v125 = 310;
          goto LABEL_144;
        }
LABEL_57:
        v57 += v62;
        ++v56;
        unint64_t v45 = *v170;
      }
      while (v56 < *v170);
      unint64_t v55 = *v170;
LABEL_59:
      ++v54;
    }
    while (v54 != 3);
    int v68 = *(_DWORD *)(v169 + 28);
    if (v153 >= 3)
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "ForceInPlace %d: excess_pages=%d/%d, converted bytes=%llu, %zu controls\n", v151, v68, *(_DWORD *)(v169 + 32), v154, v45);
      int v68 = *(_DWORD *)(v169 + 28);
    }
    int v69 = *(_DWORD *)(v169 + 32);
    BOOL v70 = __OFSUB__(v68, v69);
    int v71 = v68 - v69;
    if (!((v71 < 0) ^ v70 | (v71 == 0)))
    {
      int v72 = v71 + 1;
      unint64_t v73 = (uint64_t)(v72 >> 1) << 14;
      if (v72 < 2)
      {
        int v74 = 0;
        a2 = v170;
        a1 = v171;
        uint64_t v75 = v154;
        goto LABEL_112;
      }
      uint64_t v149 = 0;
      unint64_t v146 = -1;
      unint64_t v76 = 1;
      a2 = v170;
      a1 = v171;
      uint64_t v75 = v154;
      int64x2_t v77 = v152;
      while (2)
      {
        unint64_t v78 = *(void *)(a4 + 2080);
        unint64_t v79 = *a2;
        if (*a2)
        {
          int v74 = 0;
          unint64_t v147 = v76 - 1;
          unint64_t v148 = v76;
          uint64_t v80 = 24 * v79;
          while (1)
          {
            uint64_t v81 = *a1 + v80;
            int v82 = (int8x16_t *)(v81 - 24);
            int64x2_t v83 = *(int64x2_t *)(v81 - 24);
            int64x2_t v84 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v83), (int8x16_t)vsubq_s64(v77, v83), (int8x16_t)v83);
            uint64_t v85 = *(void *)(v81 - 8);
            unint64_t v86 = 0x8000000000000000 - v85;
            if (v85 >= 0) {
              unint64_t v86 = *(void *)(v81 - 8);
            }
            v78 -= vaddvq_s64(v84);
            if (!v73) {
              goto LABEL_94;
            }
            unint64_t v87 = v84.i64[0];
            if (!v84.i64[0]) {
              goto LABEL_94;
            }
            if (v76 == 1) {
              break;
            }
            if (v76 != 2)
            {
              if (v76 != 3) {
                goto LABEL_94;
              }
              unint64_t v88 = *(void *)(a4 + 2056);
              goto LABEL_78;
            }
            if (v78 >= *(void *)(a4 + 2072))
            {
              if (v84.i64[0] > v73)
              {
                uint64_t v89 = v146;
                uint64_t v90 = v149;
                if (v146 > v84.i64[0]) {
                  uint64_t v90 = v81 - 24;
                }
                uint64_t v149 = v90;
                if (v146 >= v84.i64[0]) {
                  uint64_t v89 = v84.i64[0];
                }
                unint64_t v146 = v89;
                goto LABEL_94;
              }
              goto LABEL_89;
            }
LABEL_94:
            v80 -= 24;
            --v79;
            a1 = v171;
            if (!v79) {
              goto LABEL_97;
            }
          }
          if (v78 < *(void *)(a4 + 2056)) {
            goto LABEL_94;
          }
          unint64_t v88 = *(void *)(a4 + 2072);
LABEL_78:
          if (v78 < v88)
          {
            if (v84.i64[0] >= v73) {
              unint64_t v87 = v73;
            }
LABEL_89:
            if (v153 >= 4)
            {
              unint64_t v91 = v73;
              uint64_t v155 = v75;
              uint64_t v163 = v81;
              unint64_t v166 = v78;
              unint64_t v158 = v86;
              unint64_t v160 = v87;
              int64x2_t v150 = v84;
              fprintf((FILE *)*MEMORY[0x263EF8348], "Dropping %llu bytes at %llu, needed=%llu bytes, type %s\n", v87, v78, v73, rawimg_force_in_place_pass_name[v147]);
              int64x2_t v84 = v150;
              unint64_t v86 = v158;
              unint64_t v87 = v160;
              uint64_t v81 = v163;
              unint64_t v78 = v166;
              unint64_t v76 = v148;
              uint64_t v75 = v155;
              unint64_t v73 = v91;
              int64x2_t v77 = v152;
            }
            v83.i64[0] = v87;
            v92.i64[0] = vsubq_s64(v84, v83).u64[0];
            v92.i64[1] = vaddq_s64(v84, vdupq_n_s64(v87)).i64[1];
            *int v82 = vbslq_s8((int8x16_t)vcltzq_s64(v92), (int8x16_t)vsubq_s64(v77, v92), (int8x16_t)v92);
            unint64_t v93 = v87 + v86;
            if ((uint64_t)(v87 + v86) < 0) {
              unint64_t v93 = 0x8000000000000000 - (v87 + v86);
            }
            *(void *)(v81 - 8) = v93;
            v75 += v87;
            v73 -= v87;
            int v74 = 1;
            goto LABEL_94;
          }
          goto LABEL_94;
        }
        int v74 = 0;
LABEL_97:
        if (v78)
        {
          uint64_t v124 = "control sequence broken";
          __int16 v125 = 411;
          goto LABEL_144;
        }
        a2 = v170;
        if (v76 != 3 || v74 || !v73 || !v149)
        {
          if (v76 > 2) {
            goto LABEL_112;
          }
          if (v74) {
            goto LABEL_112;
          }
          ++v76;
          if (!v73) {
            goto LABEL_112;
          }
          continue;
        }
        break;
      }
      uint64_t v94 = v75;
      if (*(uint64_t *)v149 >= 0) {
        unint64_t v95 = *(void *)v149;
      }
      else {
        unint64_t v95 = 0x8000000000000000 - *(void *)v149;
      }
      int64x2_t v167 = *(int64x2_t *)(v149 + 8);
      if (v153 >= 4) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Dropping copy fork with %llu bytes, needed=%llu bytesx\n", v95, v73);
      }
      unint64_t v73 = 0;
      *(void *)uint64_t v149 = 0;
      int64x2_t v96 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v167), (int8x16_t)vsubq_s64(v152, v167), (int8x16_t)v167), vdupq_n_s64(v95));
      *(int8x16_t *)(v149 + 8) = vbslq_s8((int8x16_t)vcltzq_s64(v96), (int8x16_t)vsubq_s64(v152, v96), (int8x16_t)v96);
      uint64_t v75 = v95 + v94;
      int v74 = 1;
      a2 = v170;
      a1 = v171;
LABEL_112:
      uint64_t v154 = v75;
      ++v151;
      uint64_t v40 = v168;
      if (!v74 && v73)
      {
        uint64_t v97 = "no possible conversions";
        __int16 v98 = 441;
        goto LABEL_142;
      }
      continue;
    }
    break;
  }
  uint64_t v127 = (void *)*v171;
  unint64_t v128 = *v170;
  if (!*v170) {
    goto LABEL_155;
  }
  if (v128 != 1)
  {
    uint64_t v129 = 0;
    uint64_t v130 = v127[1] + *v127;
    uint64_t v131 = v127 + 3;
    unint64_t v132 = 1;
    while (1)
    {
      uint64_t v133 = *v131;
      uint64_t v134 = v131[1];
      if (v130 != *(void *)(a4 + 2072))
      {
        uint64_t v135 = &v127[3 * v129];
        uint64_t v138 = v135[1];
        uint64_t v137 = v135 + 1;
        uint64_t v136 = v138;
        if (!v133)
        {
          uint64_t v141 = v127[3 * v129 + 2];
LABEL_167:
          v127[3 * v129] += v133;
          void *v137 = v136 + v134;
          uint64_t v142 = 0x8000000000000000 - v141;
          if (v141 >= 0) {
            uint64_t v142 = v141;
          }
          uint64_t v143 = v131[2];
          if (v143 < 0) {
            uint64_t v143 = 0x8000000000000000 - v143;
          }
          BOOL v70 = __OFADD__(v143, v142);
          uint64_t v144 = v143 + v142;
          if (v144 < 0 != v70) {
            uint64_t v144 = 0x8000000000000000 - v144;
          }
          v127[3 * v129 + 2] = v144;
          goto LABEL_174;
        }
        if (!v136)
        {
          uint64_t v136 = v127[3 * v129 + 2];
          if (!v136)
          {
            uint64_t v141 = 0;
            goto LABEL_167;
          }
        }
      }
      ++v129;
      long long v139 = *(_OWORD *)v131;
      uint64_t v140 = &v127[3 * v129];
      v140[2] = v131[2];
      *(_OWORD *)uint64_t v140 = v139;
LABEL_174:
      v130 += v134 + v133;
      ++v132;
      v131 += 3;
      if (v132 >= *v170) {
        goto LABEL_154;
      }
    }
  }
  uint64_t v129 = 0;
LABEL_154:
  unint64_t v128 = v129 + 1;
  *unint64_t v170 = v128;
LABEL_155:
  *BOOL v171 = v127;
  if (v127)
  {
    if (v153 >= 2) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "ForceInPlace: %zu controls. Dropped %llu bytes to stay within budget.\n", v128, v154);
    }
    int v110 = 1;
  }
  else
  {
    uint64_t v124 = "merge_controls";
    __int16 v125 = 447;
LABEL_144:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v125, 141, 0, v124, v41, v42, v145);
    int v110 = 0;
  }
  uint64_t v40 = v168;
LABEL_123:
  if (AAByteStreamClose((AAByteStream)v33) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 458, 141, 0, "AAByteStreamClose", v111, v112, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose(v30) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 459, 141, 0, "AAByteStreamClose", v113, v114, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v43) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 460, 141, 0, "AAByteStreamClose", v115, v116, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose(v40) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 461, 141, 0, "AAByteStreamClose", v117, v118, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v17) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 462, 141, 0, "AAByteStreamClose", v119, v120, v145);
    int v110 = 0;
  }
  if (AAByteStreamClose(v15) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 463, 141, 0, "AAByteStreamClose", v121, v122, v145);
    int v110 = 0;
  }
  if (v110) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t SimStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  int v9 = *(_DWORD *)(a1 + 16);
  if (v9 < 1) {
    goto LABEL_8;
  }
  int v10 = 0;
  uint64_t v11 = *(int **)(a1 + 8);
  uint64_t v12 = *(unsigned int *)(a1 + 16);
  do
  {
    int v13 = *v11;
    uint64_t v11 = (int *)((char *)v11 + 5);
    v10 += v13;
    --v12;
  }
  while (v12);
  if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 148, 141, 0, "%i dangling reads", a7, a8, v10);
    int v9 = *(_DWORD *)(a1 + 16);
    uint64_t v14 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    uint64_t v14 = 0;
  }
  int v15 = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28) + v9 != *(_DWORD *)(a1 + 20) + v15)
  {
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 152, 141, "file + excess != written + free", a6, a7, a8, v17);
    int v9 = *(_DWORD *)(a1 + 16);
    int v15 = *(_DWORD *)(a1 + 24);
  }
  if (v9 < v15) {
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 154, 141, "file < written", a6, a7, a8, v17);
  }
  if (*(int *)(a1 + 36) >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "SimStream: pages: %i file, %i written, %i free, %i excess (%iK)\n", *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 28), 16 * *(_DWORD *)(a1 + 28));
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
  return v14;
}

ssize_t SimStreamPRead(AAByteStream *a1, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*a1, a2, a3, a4);
}

ssize_t SimStreamPWrite(AAByteStream *a1, const void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPWrite(*a1, a2, a3, a4);
}

uint64_t SimStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 < 1) {
    return a4;
  }
  if (a2 > 2)
  {
    uint64_t v20 = "not implemented";
    __int16 v21 = 87;
    goto LABEL_20;
  }
  int64_t v9 = a5 + a4;
  uint64_t v10 = *(void *)(a1 + 8);
  while (1)
  {
    uint64_t v11 = (int *)(v10 + 5 * (a5 >> 14));
    if (a2) {
      break;
    }
    if (!(*v11)++)
    {
      int v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = v14 - 1;
      if (!v14)
      {
        uint64_t v20 = "no free pages";
        __int16 v21 = 94;
        goto LABEL_20;
      }
    }
LABEL_17:
    a5 = (a5 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if (a5 >= v9) {
      return a4;
    }
  }
  if (a2 != 1)
  {
    uint64_t v15 = v10 + 5 * (a5 >> 14);
    int v17 = *(unsigned __int8 *)(v15 + 4);
    unint64_t v16 = (unsigned char *)(v15 + 4);
    if (!v17)
    {
      *unint64_t v16 = 1;
      int v18 = *(_DWORD *)(a1 + 20);
      if (v18) {
        *(_DWORD *)(a1 + 20) = v18 - 1;
      }
      else {
        ++*(_DWORD *)(a1 + 28);
      }
      ++*(_DWORD *)(a1 + 24);
    }
    goto LABEL_17;
  }
  if (*v11 > 0)
  {
    int v12 = *v11 - 1;
    *uint64_t v11 = v12;
    if (!v12) {
      ++*(_DWORD *)(a1 + 20);
    }
    goto LABEL_17;
  }
  uint64_t v20 = "data not locked";
  __int16 v21 = 99;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamSimulate", v21, 141, 0, v20, a7, a8, v8);
  return -1;
}

int AEAContextDecryptAttributes(AEAContext context)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v16 = 0;
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  if (*((_DWORD *)context + 684) && *((void *)context + 341))
  {
    if ((aeaContextUnlock((uint64_t)context, (uint64_t)&v10, __s, 0, 1, 0) & 0x80000000) != 0)
    {
      uint64_t v4 = "unlock container";
      __int16 v5 = 18;
    }
    else
    {
      if (((unint64_t)v12 + v11 - 1) / v11 < 0xFFFFFFFF)
      {
        int v6 = 0;
        long long v8 = v13;
        *((_OWORD *)context + 2) = v12;
        *((_OWORD *)context + 3) = v8;
        *((void *)context + 8) = v14;
        long long v9 = v11;
        *(_OWORD *)context = v10;
        *((_OWORD *)context + 1) = v9;
        goto LABEL_8;
      }
      uint64_t v4 = "Invalid data size";
      __int16 v5 = 22;
    }
  }
  else
  {
    uint64_t v4 = "invalid context";
    __int16 v5 = 15;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContextValidate.c", (uint64_t)"AEAContextDecryptAttributes", v5, 121, 0, v4, v1, v2, v10);
  int v6 = -1;
LABEL_8:
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(&v10, 0x48uLL, 0, 0x48uLL);
  return v6;
}

size_t SharedBufferAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
  {
    long long v9 = (unsigned int *)result;
    int v10 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(result + 400), (unsigned int *)&v10, 1u);
    if (!v10)
    {
      if ((SharedArrayPush((unsigned int *)(result + 128), -1) & 0x80000000) != 0) {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 500, 73, 0, "SharedArrayPush", v11, v12, v15);
      }
      uint64_t result = SharedArrayEnqueue_0(v9, -1);
      if ((result & 0x80000000) != 0)
      {
        return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 501, 73, 0, "SharedArrayPush", v13, v14, a9);
      }
    }
  }
  return result;
}

uint64_t *AARemoveArchiveOutputStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int DefaultNThreads = a5;
  if (!a5) {
    int DefaultNThreads = getDefaultNThreads();
  }
  int v10 = (uint64_t *)malloc(0x38uLL);
  uint64_t v11 = v10;
  if (v10) {
    memset_s(v10, 0x38uLL, 0, 0x38uLL);
  }
  memset(&v39, 0, sizeof(v39));
  uint64_t v12 = malloc(0x478uLL);
  uint64_t v13 = (uint64_t)v12;
  if (v12 && (memset_s(v12, 0x478uLL, 0, 0x478uLL), v11))
  {
    if (realpath_DARWIN_EXTSN(a1, (char *)v13))
    {
      if (stat((const char *)v13, &v39) || (v39.st_mode & 0xF000) != 0x4000)
      {
        char v38 = (char)a1;
        uint64_t v27 = "Invalid directory: %s";
        __int16 v28 = 393;
        goto LABEL_24;
      }
      *(void *)(v13 + 1024) = a4;
      *(void *)(v13 + 1032) = a2;
      *(void *)(v13 + 1040) = a3;
      *(double *)(v13 + 1048) = getRealTime();
      *(_DWORD *)(v13 + 1120) = DefaultNThreads;
      int v16 = StringTableCreate();
      *(void *)(v13 + 1088) = v16;
      if (!v16)
      {
        uint64_t v27 = "string table creation";
        __int16 v28 = 402;
        goto LABEL_24;
      }
      uint64_t v17 = calloc(*(unsigned int *)(v13 + 1120), 8uLL);
      *(void *)(v13 + 1128) = v17;
      if (v17)
      {
        if (*(_DWORD *)(v13 + 1120))
        {
          unint64_t v18 = 0;
          while (1)
          {
            uint64_t v19 = malloc(0x1040uLL);
            uint64_t v20 = (uint64_t)v19;
            if (v19)
            {
              memset_s(v19, 0x1040uLL, 0, 0x1040uLL);
              *(_DWORD *)(v20 + 2064) = -1;
              *(void *)uint64_t v20 = v13;
              __int16 v21 = StringTableCreate();
              *(void *)(v20 + 2072) = v21;
              if (v21) {
                goto LABEL_19;
              }
              __int16 v22 = 82;
              int v23 = 0;
              uint64_t v24 = "StringTableCreate";
            }
            else
            {
              int v23 = *__error();
              __int16 v22 = 78;
              uint64_t v24 = "malloc";
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"workerCreate", v22, 123, v23, v24, v14, v15, v38);
            workerDestroy(v20);
            uint64_t v20 = 0;
LABEL_19:
            *(void *)(*(void *)(v13 + 1128) + 8 * v18) = v20;
            uint64_t v25 = *(void *)(v13 + 1128);
            if (!*(void *)(v25 + 8 * v18))
            {
              uint64_t v27 = "creating new worker";
              __int16 v28 = 410;
              goto LABEL_24;
            }
            ++v18;
            uint64_t v17 = (void *)*(unsigned int *)(v13 + 1120);
            if (v18 >= (unint64_t)v17) {
              goto LABEL_31;
            }
          }
        }
        uint64_t v25 = (uint64_t)v17;
        LODWORD(v17) = 0;
LABEL_31:
        uint64_t v37 = ThreadPoolCreate(v17, v25, (uint64_t)workerProc_1);
        *(void *)(v13 + 1136) = v37;
        if (v37)
        {
          _OWORD v11[3] = (uint64_t)removeStreamWriteHeader;
          v11[4] = (uint64_t)removeStreamWriteBlob;
          v11[2] = (uint64_t)removeStreamAbort;
          *uint64_t v11 = v13;
          v11[1] = (uint64_t)removeStreamClose;
          return v11;
        }
        uint64_t v27 = "ThreadPoolCreate";
        __int16 v28 = 415;
LABEL_24:
        int v26 = 0;
      }
      else
      {
        int v26 = *__error();
        uint64_t v27 = "malloc";
        __int16 v28 = 406;
      }
    }
    else
    {
      int v26 = *__error();
      char v38 = (char)a1;
      uint64_t v27 = "%s";
      __int16 v28 = 392;
    }
  }
  else
  {
    int v26 = *__error();
    uint64_t v27 = "malloc";
    __int16 v28 = 391;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"AARemoveArchiveOutputStreamOpen", v28, 123, v26, v27, v14, v15, v38);
  free(v11);
  removeStreamClose(v13, v29, v30, v31, v32, v33, v34, v35);
  return 0;
}

uint64_t workerProc_1(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  if (*(void *)(a1 + 2080))
  {
    unint64_t v3 = 0;
    uint64_t v4 = (unsigned int *)(a1 + 2088);
    do
    {
      if ((processEntry(a1, v4, *(void *)(a1 + 2072)) & 0x80000000) != 0)
      {
        __int16 v11 = 185;
        goto LABEL_14;
      }
      ++v3;
      v4 += 2;
    }
    while (v3 < *(void *)(a1 + 2080));
  }
  unint64_t v7 = *(void *)(a1 + 4136);
  unint64_t v8 = *(void *)(a1 + 4144);
  if (v7 < v8)
  {
    uint64_t v9 = 8 * v7;
    do
    {
      uint64_t v10 = *(void *)(v2 + 1112) + v9;
      if (*(_DWORD *)(a1 + 4152) == *(unsigned __int16 *)(v10 + 6))
      {
        if ((processEntry(a1, (unsigned int *)v10, *(void *)(v2 + 1088)) & 0x80000000) != 0)
        {
          __int16 v11 = 193;
LABEL_14:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"workerProc", v11, 123, 0, "entry failed", v5, v6, v14);
          int v12 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)(v2 + 1056), (unsigned int *)&v12, 1u);
          return 0;
        }
        unint64_t v8 = *(void *)(a1 + 4144);
      }
      ++v7;
      v9 += 8;
    }
    while (v7 < v8);
  }
  return 0;
}

uint64_t removeStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    unint64_t v9 = *(void *)(result + 1024);
    if (atomic_load((unsigned int *)(result + 1056)))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamClose", 314, 123, 0, "stream cancelled", a7, a8, v38);
      int v11 = 0;
    }
    else
    {
      int v11 = 1;
    }
    uint64_t v12 = *(void *)(v8 + 1080);
    if (v12)
    {
      if ((ThreadPoolRunWorker(*(void *)(v8 + 1136), v12, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamClose", 319, 123, 0, "ThreadPoolRunWorker", a7, a8, v38);
        int v11 = 0;
      }
      *(void *)(v8 + 1080) = 0;
    }
    uint64_t v13 = *(void *)(v8 + 1104);
    if (v13)
    {
      unsigned int v14 = 0;
      uint64_t v15 = (unsigned __int16 *)(*(void *)(v8 + 1112) + 6);
      unint64_t v16 = (v13 + (unint64_t)*(unsigned int *)(v8 + 1120) - 1) / (4 * *(_DWORD *)(v8 + 1120));
      do
      {
        unsigned int v18 = *v15;
        v15 += 4;
        unsigned int v17 = v18;
        if (v18 > v14) {
          unsigned int v14 = v17;
        }
        --v13;
      }
      while (v13);
      uint64_t v19 = v16 <= 0xC8 ? 200 : v16;
      if (v11)
      {
        while (1)
        {
          if (*(void *)(v8 + 1104))
          {
            unint64_t v20 = 0;
            while (1)
            {
              uint64_t Worker = ThreadPoolGetWorker(*(void *)(v8 + 1136), v12, a3, a4, a5, a6, a7, a8);
              if (!Worker)
              {
                __int16 v28 = 335;
                uint64_t v29 = "ThreadPoolGetWorker";
                goto LABEL_28;
              }
              *(void *)(Worker + 2080) = 0;
              *(void *)(Worker + 4136) = v20;
              v20 += v19;
              unint64_t v26 = *(void *)(v8 + 1104);
              if (v20 < v26) {
                unint64_t v26 = v20;
              }
              *(void *)(Worker + 4144) = v26;
              *(_DWORD *)(Worker + 4152) = v14;
              if ((ThreadPoolRunWorker(*(void *)(v8 + 1136), Worker, v22, v23, v24, v25, a7, a8) & 0x80000000) != 0) {
                break;
              }
              if (v20 >= *(void *)(v8 + 1104)) {
                goto LABEL_25;
              }
            }
            __int16 v28 = 340;
            uint64_t v29 = "ThreadPoolRunWorker";
LABEL_28:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamClose", v28, 123, 0, v29, a7, a8, v38);
            int v11 = 0;
            char v27 = 1;
          }
          else
          {
LABEL_25:
            char v27 = 0;
            int v11 = 1;
          }
          ThreadPoolSync(*(unsigned int **)(v8 + 1136));
          if (!v14) {
            break;
          }
          --v14;
          if (v27)
          {
            int v11 = 0;
            break;
          }
        }
      }
    }
    ThreadPoolDestroy(*(void *)(v8 + 1136));
    uint64_t v30 = *(void **)(v8 + 1128);
    if (v30)
    {
      if (*(_DWORD *)(v8 + 1120))
      {
        unint64_t v31 = 0;
        do
          workerDestroy(*(void *)(*(void *)(v8 + 1128) + 8 * v31++));
        while (v31 < *(unsigned int *)(v8 + 1120));
        uint64_t v30 = *(void **)(v8 + 1128);
      }
      free(v30);
    }
    StringTableDestroy(*(void ***)(v8 + 1088));
    free(*(void **)(v8 + 1112));
    if (v11 && v9 >> 62)
    {
      double v32 = getRealTime() - *(double *)(v8 + 1048);
      uint64_t v33 = (FILE **)MEMORY[0x263EF8348];
      fwrite("Remove archive\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      uint64_t v34 = *v33;
      unint64_t v35 = atomic_load((unint64_t *)(v8 + 1064));
      fprintf(v34, "%12llu entries removed\n", v35);
      uint64_t v36 = *v33;
      unint64_t v37 = atomic_load((unint64_t *)(v8 + 1072));
      fprintf(v36, "%12llu entries skipped\n", v37);
      fprintf(*v33, "%12.2f time (s)\n", v32);
    }
    free((void *)v8);
    if (v11) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t removeStreamWriteHeader(uint64_t a1, AAHeader header)
{
  *(void *)&v65[1023] = *MEMORY[0x263EF8340];
  uint64_t value = -1;
  if (atomic_load((unsigned int *)(a1 + 1056))) {
    return 0xFFFFFFFFLL;
  }
  v7.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v7);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    uint64_t v25 = "AA entry missing TYP field";
    __int16 v26 = 215;
LABEL_21:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamWriteHeader", v26, 123, v25, v9, v10, v11, v59);
    goto LABEL_22;
  }
  if (value == 77) {
    goto LABEL_22;
  }
  length[0] = 0;
  v12.uint64_t ikey = 5521744;
  uint32_t v13 = AAHeaderGetKeyIndex(header, v12);
  if ((v13 & 0x80000000) != 0 || AAHeaderGetFieldString(header, v13, 0x400uLL, &__s, length) >= 2)
  {
    uint64_t v25 = "AA entry missing/invalid PAT field";
    __int16 v26 = 224;
    goto LABEL_21;
  }
  unsigned int v18 = *(uint64_t (**)(void, uint64_t, char *, AAHeader))(a1 + 1040);
  if (v18)
  {
    int v19 = v18(*(void *)(a1 + 1032), 80, &__s, header);
    if (v19 < 0)
    {
      __int16 v28 = "user cancelled";
      __int16 v29 = 234;
      goto LABEL_49;
    }
    if (v19)
    {
LABEL_22:
      int v27 = 1;
      goto LABEL_23;
    }
    int v20 = (*(uint64_t (**)(void, uint64_t, char *, size_t *))(a1 + 1040))(*(void *)(a1 + 1032), 81, &__s, length);
    if (v20 < 0)
    {
      __int16 v28 = "user cancelled";
      __int16 v29 = 239;
      goto LABEL_49;
    }
    if (v20) {
      __strlcpy_chk();
    }
  }
  if (value != 68)
  {
    uint64_t v30 = *(void *)(a1 + 1080);
    if (!v30)
    {
      uint64_t Worker = ThreadPoolGetWorker(*(void *)(a1 + 1136), v14, v15, v16, v17, v9, v10, v11);
      *(void *)(a1 + 1080) = Worker;
      if (!Worker)
      {
        __int16 v28 = "ThreadPoolGetWorker";
        __int16 v29 = 269;
        goto LABEL_49;
      }
      uint64_t v30 = Worker;
      *(void *)(Worker + 2080) = 0;
      StringTableClear(*(void *)(Worker + 2072));
      *(_OWORD *)(v30 + 4136) = 0u;
      *(_DWORD *)(v30 + 4152) = -1;
    }
    int v60 = 0;
    size_t v32 = strlen(&__s);
    if ((StringTableAppend(*(unsigned int **)(v30 + 2072), &__s, v32, &v60, v33, v34, v35, v36) & 0x80000000) != 0)
    {
      __int16 v28 = "StringTableAppend";
      __int16 v29 = 278;
      goto LABEL_49;
    }
    uint64_t v41 = *(void *)(v30 + 2080);
    uint64_t v42 = v30 + 8 * v41++;
    *(void *)(v30 + 2080) = v41;
    *(_DWORD *)(v42 + 2088) = v60;
    *(_WORD *)(v42 + 2092) = value;
    *(_WORD *)(v42 + 2094) = 0;
    if (v41 == 256)
    {
      if ((ThreadPoolRunWorker(*(void *)(a1 + 1136), v30, v37, v38, v39, v40, v10, v11) & 0x80000000) != 0)
      {
        __int16 v28 = "ThreadPoolRunWorker";
        __int16 v29 = 287;
        goto LABEL_49;
      }
      *(void *)(a1 + 1080) = 0;
    }
    goto LABEL_22;
  }
  uint64_t v21 = *(void *)(a1 + 1104);
  if (v21 == *(void *)(a1 + 1096))
  {
    uint64_t v22 = 2 * v21;
    BOOL v23 = v21 == 0;
    uint64_t v24 = 256;
    if (!v23) {
      uint64_t v24 = v22;
    }
    *(void *)(a1 + 1096) = v24;
    if ((unint64_t)(8 * v24) >= 0x2000000001)
    {
      *__error() = 12;
LABEL_52:
      *(void *)(a1 + 1096) = 0;
      *(void *)(a1 + 1104) = 0;
      *(void *)(a1 + 1112) = 0;
      int v58 = *__error();
      __int16 v28 = "malloc";
      __int16 v29 = 250;
      goto LABEL_50;
    }
    unint64_t v43 = *(void **)(a1 + 1112);
    int v44 = realloc(v43, 8 * v24);
    if (!v44)
    {
      free(v43);
      goto LABEL_52;
    }
    *(void *)(a1 + 1112) = v44;
  }
  int v61 = 0;
  size_t v45 = strlen(&__s);
  if ((StringTableAppend(*(unsigned int **)(a1 + 1088), &__s, v45, &v61, v46, v47, v48, v49) & 0x80000000) == 0)
  {
    uint64_t v50 = *(void *)(a1 + 1112);
    uint64_t v51 = *(void *)(a1 + 1104);
    *(void *)(a1 + 1104) = v51 + 1;
    uint64_t v52 = v50 + 8 * v51;
    *(_DWORD *)uint64_t v52 = v61;
    *(_WORD *)(v52 + 4) = value;
    *(_WORD *)(v52 + 6) = 0;
    uint64_t v53 = (_WORD *)(v52 + 6);
    int v54 = __s;
    if (__s)
    {
      __int16 v55 = 0;
      unint64_t v56 = v65;
      do
      {
        if (v54 == 47) {
          ++v55;
        }
        *uint64_t v53 = v55;
        int v57 = *v56++;
        int v54 = v57;
      }
      while (v57);
    }
    goto LABEL_22;
  }
  __int16 v28 = "StringTableAppend";
  __int16 v29 = 253;
LABEL_49:
  int v58 = 0;
LABEL_50:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"removeStreamWriteHeader", v29, 123, v58, v28, v10, v11, v59);
  int v27 = 0;
LABEL_23:
  if (v27) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t removeStreamWriteBlob(uint64_t a1)
{
  if (atomic_load((unsigned int *)(a1 + 1056))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

void removeStreamAbort(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 1056), (unsigned int *)&v1, 1u);
}

void workerDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 2064);
    if ((v2 & 0x80000000) == 0) {
      close(v2);
    }
    StringTableDestroy(*(void ***)(a1 + 2072));
    free((void *)a1);
  }
}

uint64_t processEntry(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  memset(&v36, 0, sizeof(v36));
  uint64_t v5 = *(char **)a1;
  uint64_t v6 = (const char *)(*(void *)(a3 + 32) + *(void *)(*(void *)(a3 + 8) + 16 * *a2));
  if ((concatPath(__s, 0x400uLL, *(char **)a1, v6) & 0x80000000) != 0)
  {
    uint64_t v17 = "invalid path";
    __int16 v18 = 114;
LABEL_11:
    int v19 = 0;
    goto LABEL_12;
  }
  uint64_t v9 = strrchr(__s, 47);
  if (!v9)
  {
    uint64_t v17 = "invalid path";
    __int16 v18 = 118;
    goto LABEL_11;
  }
  uint64_t v10 = v9;
  *uint64_t v9 = 0;
  uint64_t v11 = v9 + 1;
  size_t v12 = strlen(__s);
  size_t v15 = v12;
  int v16 = *(_DWORD *)(a1 + 2064);
  if ((v16 & 0x80000000) == 0)
  {
    if (v12 == *(void *)(a1 + 2056) && !strcmp(__s, (const char *)(a1 + 8))) {
      goto LABEL_15;
    }
    close(v16);
    *(_DWORD *)(a1 + 2064) = -1;
  }
  if (v15 >= 0x800)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"workerUpdateDir", 95, 123, 0, "directory path too long", v13, v14, v35);
    goto LABEL_19;
  }
  *(void *)(a1 + 2056) = v15;
  memcpy((void *)(a1 + 8), __s, v15);
  *(unsigned char *)(a1 + 8 + v15) = 0;
  int v23 = open((const char *)(a1 + 8), 0);
  *(_DWORD *)(a1 + 2064) = v23;
  if (v23 < 0)
  {
LABEL_19:
    __int16 v28 = (uint64_t (*)(void, uint64_t, const char *, void))*((void *)v5 + 130);
    if (!v28) {
      goto LABEL_28;
    }
    int v29 = v28(*((void *)v5 + 129), 82, v6, 0);
    if (!v29) {
      goto LABEL_28;
    }
    BOOL v26 = 0;
    BOOL v27 = v29 >= 0;
    goto LABEL_26;
  }
LABEL_15:
  *uint64_t v10 = 47;
  if (fstatat(*(_DWORD *)(a1 + 2064), v11, &v36, 32) < 0)
  {
    if (*__error() == 2) {
      goto LABEL_19;
    }
    int v19 = *__error();
    uint64_t v17 = __s;
    __int16 v18 = 128;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"processEntry", v18, 123, v19, v17, v7, v8, v35);
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARemoveArchiveOutputStream.c", (uint64_t)"processEntry", 167, 123, 0, "Entry failed: %s", v20, v21, (char)v6);
    return 0xFFFFFFFFLL;
  }
  int v24 = aaEntryTypeFromMode(v36.st_mode);
  int v25 = *((unsigned __int16 *)a2 + 2);
  if (v24 == v25)
  {
    BOOL v26 = 0;
    BOOL v27 = 1;
  }
  else
  {
    uint64_t v30 = (uint64_t (*)(void, uint64_t, const char *, void))*((void *)v5 + 130);
    if (!v30) {
      goto LABEL_28;
    }
    int v31 = v30(*((void *)v5 + 129), 83, v6, 0);
    BOOL v26 = v31 == 0;
    BOOL v27 = v31 >= 0;
    if (v31 < 1) {
      goto LABEL_26;
    }
    int v25 = *((unsigned __int16 *)a2 + 2);
  }
  if (unlinkat(*(_DWORD *)(a1 + 2064), v11, (v25 == 68) << 7) < 0)
  {
    uint64_t v33 = (uint64_t (*)(void, uint64_t, const char *, void))*((void *)v5 + 130);
    if (v33)
    {
      int v34 = v33(*((void *)v5 + 129), 84, v6, 0);
      if (!v34) {
        BOOL v26 = 1;
      }
      if (v34 < 0) {
        goto LABEL_13;
      }
    }
    else
    {
      BOOL v26 = 1;
    }
  }
LABEL_26:
  if (!v27) {
    goto LABEL_13;
  }
  if (!v26)
  {
    uint64_t result = 0;
    size_t v32 = (atomic_ullong *)(v5 + 1064);
    goto LABEL_29;
  }
LABEL_28:
  uint64_t result = 0;
  size_t v32 = (atomic_ullong *)(v5 + 1072);
LABEL_29:
  atomic_fetch_add_explicit(v32, 1uLL, memory_order_relaxed);
  return result;
}

uint64_t AEADecryptToFileChunk(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, unsigned int a9)
{
  int v9 = a8;
  uint64_t v30 = 0;
  v29[0] = a2;
  v29[1] = a4;
  v29[2] = a5;
  v29[3] = a8 >> 62;
  LODWORD(v30) = a1[10] != 0;
  uint64_t v11 = (uint64_t (**)(void))AEADecryptToFileChunkAsyncStreamOpen(a3, (uint64_t)v29, (uint64_t)asyncContext_0, (uint64_t)asyncProgress_0, a6, a7, a8, a9);
  uint64_t v14 = v11;
  if (!v11)
  {
    __int16 v18 = "AEADecryptToFileAsyncStreamOpen";
    __int16 v19 = 87;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c", (uint64_t)"AEADecryptToFileChunk", v19, 56, 0, v18, v12, v13, v26);
    int v20 = 0;
    goto LABEL_19;
  }
  if (!a1[10])
  {
    if ((AAAsyncByteStreamProcessAllRanges(v11, a1, v9, a9) & 0x8000000000000000) == 0)
    {
      int v20 = 1;
      goto LABEL_19;
    }
    __int16 v18 = "AAAsyncByteStreamProcessAllRanges";
    __int16 v19 = 115;
    goto LABEL_18;
  }
  while (1)
  {
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    int Range = AAAsyncByteStreamGetRange(v14, &v28, &v27);
    if (Range < 0) {
      break;
    }
    if (Range)
    {
      if (!v28)
      {
        int v20 = 1;
        goto LABEL_16;
      }
      if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
      {
        uint64_t v21 = "AAByteStreamPReadAsync";
        __int16 v22 = 104;
        goto LABEL_15;
      }
    }
    else
    {
      usleep(0x186A0u);
    }
  }
  uint64_t v21 = "AAAsyncByteStreamGetRange";
  __int16 v22 = 99;
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c", (uint64_t)"AEADecryptToFileChunk", v22, 56, 0, v21, v16, v17, v26);
  int v20 = 0;
LABEL_16:
  if ((AAByteStreamPReadAsync(a1) & 0x80000000) != 0)
  {
    __int16 v18 = "AAByteStreamPReadAsync barrier";
    __int16 v19 = 109;
    goto LABEL_18;
  }
LABEL_19:
  if ((AAAsyncByteStreamClose(v14) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFile.c", (uint64_t)"AEADecryptToFileChunk", 119, 56, 0, "AAAsyncByteStreamClose", v23, v24, v26);
    int v20 = 0;
  }
  if (v20) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t asyncContext_0(uint64_t result, _OWORD *context)
{
  unint64_t v3 = (_DWORD *)result;
  uint64_t v4 = *(void *)result;
  if (*(_DWORD *)(result + 28))
  {
    *(_OWORD *)uint64_t v4 = *context;
    long long v5 = context[1];
    long long v6 = context[2];
    long long v7 = context[3];
    *(void *)(v4 + 64) = *((void *)context + 8);
    *(_OWORD *)(v4 + 32) = v6;
    *(_OWORD *)(v4 + 48) = v7;
    *(_OWORD *)(v4 + 16) = v5;
    if (*(_DWORD *)(result + 24))
    {
      uint64_t v8 = (FILE **)MEMORY[0x263EF8348];
      int v9 = (FILE *)*MEMORY[0x263EF8348];
      int FieldUInt = AEAContextGetFieldUInt((AEAContext)context, 3u);
      if (FieldUInt <= 1284)
      {
        switch(FieldUInt)
        {
          case 0:
            size_t v15 = "none";
            goto LABEL_25;
          case 256:
            size_t v15 = "lz4";
            goto LABEL_25;
          case 774:
            size_t v15 = "lzma";
LABEL_25:
            uint64_t v16 = AEAContextGetFieldUInt((AEAContext)context, 4u);
            fprintf(v9, "  compression: %s %zu MB\n", v15, v16 >> 20);
            uint64_t v17 = *v8;
            unsigned int v18 = AEAContextGetFieldUInt((AEAContext)context, 2u);
            if (v18 > 2) {
              __int16 v19 = "???";
            }
            else {
              __int16 v19 = off_264228A80[v18];
            }
            fprintf(v17, "  checksum: %s\n", v19);
            int v20 = *v8;
            uint64_t v21 = AEAContextGetFieldUInt((AEAContext)context, 0xEu);
            fprintf(v20, "  container size: %llu B\n", v21);
            __int16 v22 = *v8;
            uint64_t v23 = AEAContextGetFieldUInt((AEAContext)context, 0xDu);
            fprintf(v22, "  raw size: %llu B\n", v23);
            if (v3[8]) {
              uint64_t v24 = "yes";
            }
            else {
              uint64_t v24 = "no";
            }
            fprintf(*v8, "  async read stream: %s\n", v24);
            return 0;
        }
      }
      else
      {
        if (FieldUInt <= 2048)
        {
          if (FieldUInt == 1285)
          {
            size_t v15 = "zlib";
            goto LABEL_25;
          }
          if (FieldUInt != 1794) {
            goto LABEL_24;
          }
          goto LABEL_20;
        }
        if (FieldUInt == 2049)
        {
LABEL_20:
          size_t v15 = "lzfse";
          goto LABEL_25;
        }
        if (FieldUInt == 2304)
        {
          size_t v15 = "lzvn";
          goto LABEL_25;
        }
      }
LABEL_24:
      size_t v15 = "???";
      goto LABEL_25;
    }
    return 0;
  }
  uint64_t v11 = *(unsigned int *)(v4 + 1112);
  if (v11 < 0x101)
  {
    memcpy((char *)context + 1116, (const void *)(v4 + 1116), *(unsigned int *)(v4 + 1112));
    *((_DWORD *)context + 278) = v11;
    uint64_t result = memset_s((char *)context + v11 + 1116, 256 - v11, 0, 256 - v11);
    uint64_t v12 = *(unsigned int *)(*(void *)v3 + 72);
    if (v12 < 0x101)
    {
      memcpy((char *)context + 76, (const void *)(*(void *)v3 + 76), *(unsigned int *)(*(void *)v3 + 72));
      *((_DWORD *)context + 18) = v12;
      uint64_t result = memset_s((char *)context + v12 + 76, 256 - v12, 0, 256 - v12);
      uint64_t v13 = *(unsigned int *)(*(void *)v3 + 2152);
      if (v13 < 0x101)
      {
        memcpy((char *)context + 2156, (const void *)(*(void *)v3 + 2156), *(unsigned int *)(*(void *)v3 + 2152));
        *((_DWORD *)context + 538) = v13;
        uint64_t result = memset_s((char *)context + v13 + 2156, 256 - v13, 0, 256 - v13);
        uint64_t v14 = *(unsigned int *)(*(void *)v3 + 332);
        if (v14 < 0x101)
        {
          memcpy(context + 21, (const void *)(*(void *)v3 + 336), *(unsigned int *)(*(void *)v3 + 332));
          *((_DWORD *)context + 83) = v14;
          memset_s((char *)context + v14 + 336, 256 - v14, 0, 256 - v14);
          v3[7] = 1;
          return 0;
        }
      }
    }
  }
  __break(1u);
  return result;
}

uint64_t asyncProgress_0(uint64_t a1)
{
  int v1 = *(uint64_t (**)(void))(a1 + 16);
  if (v1) {
    return v1(*(void *)(a1 + 8));
  }
  else {
    return 0;
  }
}

uint64_t AEADecryptToFile(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7)
{
  return AEADecryptToFileChunk(a1, a2, a3, a4, a5, 0, 0, a6, a7);
}

uint64_t aaCompositeChunkAsyncStreamOpen(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v5 = a1;
  if (a1 && a2)
  {
    uint64_t v10 = malloc(0x10uLL);
    uint64_t v11 = (uint64_t)v10;
    if (v10)
    {
      memset_s(v10, 0x10uLL, 0, 0x10uLL);
      *(void *)uint64_t v11 = v5;
      size_t v15 = AAChunkAsyncStreamOpen(v5, a2, a3, a4 | 0x200000000000000, a5, v12, v13, v14);
      *(void *)(v11 + 8) = v15;
      if (v15)
      {
        unsigned int v18 = aaAsyncByteStreamAlloc(v11, (uint64_t)compositeChunkAsyncClose, ~(a4 >> 55) & 4, 20.0, 1.0);
        if (v18)
        {
          uint64_t v5 = (uint64_t)v18;
          v18[2] = compositeChunkAsyncGetRange;
          v18[3] = compositeChunkAsyncProcess;
          v18[4] = compositeChunkAsyncCancel;
          v18[5] = compositeChunkAsyncIsCancelled;
          return v5;
        }
        int v20 = "async stream alloc";
        __int16 v21 = 89;
      }
      else
      {
        int v20 = "AAChunkAsyncStreamOpen";
        __int16 v21 = 86;
      }
      int v19 = 0;
    }
    else
    {
      int v19 = *__error();
      int v20 = "malloc";
      __int16 v21 = 78;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompositeChunkAsyncStream.c", (uint64_t)"aaCompositeChunkAsyncStreamOpen", v21, 145, v19, v20, v16, v17, v23);
    compositeChunkAsyncClose((uint64_t (***)(void))v11);
    AAAsyncByteStreamClose(0);
    return 0;
  }
  return v5;
}

uint64_t (***compositeChunkAsyncClose(uint64_t (***result)(void)))(void)
{
  if (result)
  {
    int v1 = result;
    int v2 = AAAsyncByteStreamClose(result[1]);
    int v3 = AAAsyncByteStreamClose(*v1) | v2;
    free(v1);
    return (uint64_t (***)(void))(v3 >> 31);
  }
  return result;
}

uint64_t compositeChunkAsyncGetRange(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return AAAsyncByteStreamGetRange(*(void **)(a1 + 8), a2, a3);
}

uint64_t compositeChunkAsyncProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*(uint64_t **)(a1 + 8), a2, a3, a4);
}

void *compositeChunkAsyncCancel(uint64_t a1)
{
  return AAAsyncByteStreamCancel(*(void **)(a1 + 8));
}

uint64_t compositeChunkAsyncIsCancelled(uint64_t a1)
{
  return aaAsyncByteStreamIsCancelled(*(void **)(a1 + 8));
}

void aeaContainerDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(void **)(a1 + 384);
    if (v2) {
      memset_s(*(void **)(a1 + 384), *(unsigned int *)(a1 + 4), 0, *(unsigned int *)(a1 + 4));
    }
    free(v2);
    int v3 = *(void **)(a1 + 392);
    if (v3) {
      memset_s(*(void **)(a1 + 392), 544 * *(unsigned int *)(a1 + 400), 0, 544 * *(unsigned int *)(a1 + 400));
    }
    free(v3);
    memset_s((void *)a1, 0x6C0uLL, 0, 0x6C0uLL);
    free((void *)a1);
  }
}

uint64_t aeaContainerCreateNew(uint64_t a1)
{
  int v2 = malloc(0x6C0uLL);
  uint64_t v3 = (uint64_t)v2;
  if (!v2)
  {
    int v14 = *__error();
    uint64_t v12 = "malloc";
    __int16 v13 = 22;
    goto LABEL_28;
  }
  memset_s(v2, 0x6C0uLL, 0, 0x6C0uLL);
  long long v4 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v3 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(v3 + 48) = v4;
  *(void *)(v3 + 64) = *(void *)(a1 + 64);
  long long v5 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)a1;
  *(_OWORD *)(v3 + 16) = v5;
  if ((aeaCryptoInit((char *)(v3 + 72), (unsigned int *)v3) & 0x80000000) != 0)
  {
    uint64_t v12 = "Invalid context";
    __int16 v13 = 28;
    goto LABEL_27;
  }
  size_t v8 = *(unsigned int *)(v3 + 4);
  if (v8)
  {
    int v9 = malloc(*(unsigned int *)(v3 + 4));
    *(void *)(v3 + 384) = v9;
    if (v9)
    {
      memcpy(v9, *(const void **)(a1 + 2712), v8);
      goto LABEL_6;
    }
    int v14 = *__error();
    uint64_t v12 = "malloc";
    __int16 v13 = 34;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateNew", v13, 28, v14, v12, v6, v7, v19);
    aeaContainerDestroy(v3);
    return 0;
  }
LABEL_6:
  if (*(_DWORD *)v3 <= 5u && ((1 << *(_DWORD *)v3) & 0x2A) != 0) {
    goto LABEL_10;
  }
  if (*(_DWORD *)(a1 + 592))
  {
    size_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 240);
    if (!v15) {
      goto LABEL_23;
    }
    int v16 = v15(a1 + 332, a1 + 592);
    if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v3 + 104) || v16 < 0) {
      goto LABEL_23;
    }
    unsigned int v17 = *(_DWORD *)(a1 + 592);
    if (v17 >= 0x101)
    {
      __break(1u);
LABEL_23:
      uint64_t v12 = "Invalid signing private key in context";
      __int16 v13 = 45;
      goto LABEL_27;
    }
  }
  else
  {
    unsigned int v17 = 0;
  }
  __memcpy_chk();
  *(_DWORD *)(v3 + 1188) = v17;
  memset_s((void *)(v3 + 1192 + v17), 256 - v17, 0, 256 - v17);
  *(_OWORD *)(v3 + 1712) = *(_OWORD *)(a1 + 2416);
  if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v3 + 104))
  {
    uint64_t v12 = "Invalid signing public key in context";
    __int16 v13 = 55;
    goto LABEL_27;
  }
LABEL_10:
  if ((aeaContainerOffsetsInit(v3 + 280, (unsigned int *)v3, (unsigned int *)(v3 + 72)) & 0x80000000) != 0)
  {
    uint64_t v12 = "deriving container offsets";
    __int16 v13 = 59;
    goto LABEL_27;
  }
  uint64_t v11 = *(void *)(v3 + 344);
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = v11;
  if ((aeaDeriveMainKeyNew((unsigned int *)(v3 + 72), (int *)v3, (long long *)(v3 + 668), (int *)(v3 + 928), (char *)(v3 + 408), (int *)(a1 + 72), (_DWORD *)(a1 + 2152), (unsigned int *)(a1 + 332), (unsigned int *)(a1 + 852)) & 0x80000000) != 0)
  {
    uint64_t v12 = "Main key derivation";
    __int16 v13 = 75;
LABEL_27:
    int v14 = 0;
    goto LABEL_28;
  }
  return v3;
}

uint64_t aeaContainerCreateExisting(uint64_t a1, AAByteStream_impl *a2, int a3, int a4)
{
  uint64_t v124 = *MEMORY[0x263EF8340];
  int v104 = 0;
  memset(__s, 0, sizeof(__s));
  int v102 = 0;
  memset(v101, 0, sizeof(v101));
  int v100 = 0;
  memset(v99, 0, sizeof(v99));
  memset(v98, 0, sizeof(v98));
  size_t v8 = malloc(0x6C0uLL);
  uint64_t v9 = (uint64_t)v8;
  if (!v8)
  {
    int v20 = *__error();
    __int16 v21 = "malloc";
    __int16 v22 = 95;
    goto LABEL_41;
  }
  memset_s(v8, 0x6C0uLL, 0, 0x6C0uLL);
  uint64_t v10 = (_DWORD *)(v9 + 668);
  if ((aeaContextUnlock(a1, v9, (_DWORD *)(v9 + 668), (_DWORD *)(v9 + 408), a3, a4) & 0x80000000) != 0)
  {
    __int16 v21 = "unlocking context";
    __int16 v22 = 99;
LABEL_40:
    int v20 = 0;
    goto LABEL_41;
  }
  if ((aeaCryptoInit((char *)(v9 + 72), (unsigned int *)v9) & 0x80000000) != 0)
  {
    __int16 v21 = "Invalid container";
    __int16 v22 = 102;
    goto LABEL_40;
  }
  if ((aeaContainerOffsetsInit(v9 + 280, (unsigned int *)v9, (unsigned int *)(v9 + 72)) & 0x80000000) != 0)
  {
    __int16 v21 = "deriving container offsets";
    __int16 v22 = 103;
    goto LABEL_40;
  }
  size_t v13 = *(unsigned int *)(v9 + 4);
  if (v13)
  {
    int v14 = malloc(*(unsigned int *)(v9 + 4));
    *(void *)(v9 + 384) = v14;
    if (v14)
    {
      memcpy(v14, *(const void **)(a1 + 2712), v13);
      goto LABEL_8;
    }
    int v20 = *__error();
    __int16 v21 = "malloc";
    __int16 v22 = 110;
LABEL_41:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", v22, 28, v20, v21, v11, v12, v90);
    size_t v19 = 0;
    goto LABEL_42;
  }
LABEL_8:
  if (*(_DWORD *)v9 > 5u || ((1 << *(_DWORD *)v9) & 0x2A) == 0)
  {
    if (*(_DWORD *)(a1 + 592))
    {
      int v31 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 240);
      if (!v31) {
        goto LABEL_36;
      }
      int v32 = v31(a1 + 332, a1 + 592);
      if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v9 + 104) || v32 < 0) {
        goto LABEL_36;
      }
      unsigned int v33 = *(_DWORD *)(a1 + 592);
      if (v33 >= 0x101)
      {
LABEL_35:
        __break(1u);
LABEL_36:
        __int16 v21 = "Invalid signing private key in context";
        __int16 v22 = 121;
        goto LABEL_40;
      }
    }
    else
    {
      unsigned int v33 = 0;
    }
    __memcpy_chk();
    *(_DWORD *)(v9 + 1188) = v33;
    memset_s((void *)(v9 + 1192 + v33), 256 - v33, 0, 256 - v33);
    *(_OWORD *)(v9 + 1712) = *(_OWORD *)(a1 + 2416);
    if (*(_DWORD *)(a1 + 332) != *(_DWORD *)(v9 + 104))
    {
      __int16 v21 = "Invalid signing public key in context";
      __int16 v22 = 131;
      goto LABEL_40;
    }
  }
  uint64_t v15 = *(unsigned int *)(v9 + 120);
  if (v15 >= 0x101) {
    goto LABEL_35;
  }
  __memcpy_chk();
  *(_DWORD *)(v9 + 928) = v15;
  memset_s((void *)(v9 + 932 + v15), 256 - v15, 0, 256 - v15);
  uint64_t v16 = *(unsigned int *)(v9 + 84);
  if (v16 >= 0x101) {
    goto LABEL_35;
  }
  __memcpy_chk();
  LODWORD(v99[0]) = v16;
  memset_s((char *)v99 + v16 + 4, 256 - v16, 0, 256 - v16);
  uint64_t v17 = *(unsigned int *)(v9 + 84);
  if (v17 >= 0x101) {
    goto LABEL_35;
  }
  __memcpy_chk();
  LODWORD(v101[0]) = v17;
  memset_s((char *)v101 + v17 + 4, 256 - v17, 0, 256 - v17);
  off_t v18 = AAByteStreamSeek(a2, 0, 2);
  if ((v18 & 0x8000000000000000) == 0 && v18 != *(void *)(v9 + 40))
  {
    __int16 v21 = "Container size mismatch";
    __int16 v22 = 143;
    goto LABEL_40;
  }
  if (*(void *)(v9 + 376) <= 0x100000uLL) {
    size_t v19 = 0x100000;
  }
  else {
    size_t v19 = *(void *)(v9 + 376);
  }
  if (v19 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_28:
    unint64_t v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", 151, 28, *v28, "malloc", v29, v30, v90);
LABEL_42:
    uint64_t v24 = 0;
    goto LABEL_43;
  }
  char v23 = (char *)malloc(v19);
  if (!v23) {
    goto LABEL_28;
  }
  uint64_t v24 = v23;
  unint64_t v25 = (*(void *)(v9 + 32) + (unint64_t)*(unsigned int *)(v9 + 16) - 1) / *(unsigned int *)(v9 + 16);
  if (HIDWORD(v25))
  {
    char v26 = "Invalid sizes in root header";
    __int16 v27 = 155;
    goto LABEL_51;
  }
  *(_DWORD *)(v9 + 400) = v25;
  unsigned int v36 = *(_DWORD *)(v9 + 20);
  unsigned int v37 = (v25 + v36 - 1) / v36;
  *(_DWORD *)(v9 + 404) = v37;
  if (((v36 * (unint64_t)v37) & 0xFFFFFFFF00000000) != 0)
  {
    char v26 = "Invalid sizes in root header";
    __int16 v27 = 158;
    goto LABEL_51;
  }
  size_t v39 = v37 * v36;
  if (v39 >= 0xF0F0F10)
  {
    *__error() = 12;
    *(void *)(v9 + 392) = 0;
LABEL_99:
    int v38 = *__error();
    char v26 = "malloc";
    __int16 v27 = 171;
    goto LABEL_52;
  }
  uint64_t v40 = calloc(v39, 0x220uLL);
  *(void *)(v9 + 392) = v40;
  if (!v40) {
    goto LABEL_99;
  }
  size_t v91 = v19;
  unint64_t v41 = *(void *)(v9 + 344);
  int64x2_t v92 = (unsigned int *)(v9 + 72);
  unint64_t v93 = a2;
  if (!*(_DWORD *)(v9 + 404))
  {
LABEL_97:
    unint64_t v69 = *(void *)(v9 + 40);
    unint64_t v70 = v41;
    BOOL v71 = v69 >= v41;
    unint64_t v72 = v69 - v41;
    if (!v71)
    {
      char v26 = "Invalid container size";
      __int16 v27 = 230;
      goto LABEL_51;
    }
    *(void *)(v9 + 64) = v72;
    if (!v72 || *(_DWORD *)(a1 + 2740))
    {
      int v34 = 1;
      goto LABEL_44;
    }
    memset(v123, 0, sizeof(v123));
    memset(v122, 0, 260);
    int v121 = 0;
    long long v120 = 0u;
    long long v119 = 0u;
    long long v118 = 0u;
    long long v117 = 0u;
    long long v116 = 0u;
    long long v115 = 0u;
    long long v114 = 0u;
    long long v113 = 0u;
    long long v112 = 0u;
    long long v111 = 0u;
    long long v110 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v105 = 0u;
    if (*(void *)(v9 + 248)
      && (*(_DWORD *)((char *)v122 + 7) = 1262571615,
          *(void *)&v122[0] = 0x5F41454100000007,
          memset_s((void *)((unint64_t)v122 | 0xB), 0xF9uLL, 0, 0xF9uLL),
          (unint64_t v73 = *(uint64_t (**)(unsigned char *, void, _DWORD *, _OWORD *, long long *))(v9 + 144)) != 0)
      && *v10
      && (v73(v123, *v92, v10, v122, &v105) & 0x80000000) == 0)
    {
      uint64_t v74 = (*(uint64_t (**)(unsigned char *))(v9 + 248))(v123);
    }
    else
    {
      uint64_t v74 = 0;
    }
    memset_s(v123, 0x104uLL, 0, 0x104uLL);
    memset_s(v122, 0x104uLL, 0, 0x104uLL);
    if (v74)
    {
      while (1)
      {
        if (v72 >= 0x100000) {
          uint64_t v77 = 0x100000;
        }
        else {
          uint64_t v77 = v72;
        }
        if (!*((void *)v93 + 4)) {
          goto LABEL_131;
        }
        uint64_t v78 = 0;
        unint64_t v79 = v24;
        unint64_t v80 = v70;
        uint64_t v81 = v77;
        while (1)
        {
          uint64_t v82 = (*((uint64_t (**)(void, char *, uint64_t, unint64_t))v93 + 4))(*(void *)v93, v79, v81, v80);
          if (v82 < 0) {
            break;
          }
          if (v82)
          {
            v79 += v82;
            v78 += v82;
            v80 += v82;
            v81 -= v82;
            if (v81) {
              continue;
            }
          }
          goto LABEL_125;
        }
        uint64_t v78 = v82;
LABEL_125:
        if (v78 != v77)
        {
LABEL_131:
          int64x2_t v84 = "loading padding";
          __int16 v85 = 250;
          goto LABEL_142;
        }
        int64x2_t v83 = *(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 256);
        if (!v83 || (v83(v74, v24, v77) & 0x80000000) != 0) {
          break;
        }
        v70 += v77;
        v72 -= v77;
        if (!v72)
        {
          int v34 = 1;
          goto LABEL_133;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", 252, 28, 0, "authenticating padding", v75, v76, v90);
      int v34 = 0;
LABEL_133:
      memset(v123, 0, sizeof(v123));
      unint64_t v86 = *(uint64_t (**)(uint64_t, unsigned char *))(v9 + 264);
      if (v86)
      {
        if (LODWORD(v99[0]) == *(_DWORD *)(v9 + 84)
          && (v86(v74, v123) & 0x80000000) == 0
          && *(_DWORD *)v123 == *(_DWORD *)(v9 + 84))
        {
          if (*(_DWORD *)v123 < 8u) {
            goto LABEL_144;
          }
          uint64_t v87 = 0;
          uint64_t v88 = 4;
          do
          {
            v87 |= *(void *)&v123[v88] ^ *(void *)((char *)v99 + v88);
            unint64_t v89 = v88 + 12;
            v88 += 8;
          }
          while (v89 <= *(unsigned int *)v123);
          if (!v87)
          {
LABEL_144:
            memset_s(v123, 0x104uLL, 0, 0x104uLL);
            goto LABEL_143;
          }
        }
      }
      memset_s(v123, 0x104uLL, 0, 0x104uLL);
      int64x2_t v84 = "authenticating padding";
      __int16 v85 = 257;
    }
    else
    {
      int64x2_t v84 = "authenticating padding";
      __int16 v85 = 241;
    }
LABEL_142:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", v85, 28, 0, v84, v75, v76, v90);
    int v34 = 0;
LABEL_143:
    size_t v19 = v91;
    goto LABEL_44;
  }
  int v95 = 0;
  uint64_t v42 = *(void *)(v9 + 376);
  char v90 = v9 - 100;
  while (1)
  {
    unint64_t v94 = v41;
    uint64_t v96 = v42;
    if (*((void *)a2 + 4))
    {
      uint64_t v43 = 0;
      if (v42)
      {
        int v44 = v24;
        while (1)
        {
          uint64_t v45 = (*((uint64_t (**)(void, char *, uint64_t, unint64_t))a2 + 4))(*(void *)a2, v44, v42, v41);
          if (v45 < 0) {
            break;
          }
          if (v45)
          {
            v44 += v45;
            v43 += v45;
            v41 += v45;
            v42 -= v45;
            if (v42) {
              continue;
            }
          }
          goto LABEL_67;
        }
        uint64_t v43 = v45;
      }
    }
    else
    {
      uint64_t v43 = -1;
    }
LABEL_67:
    if (v43 != v96)
    {
      char v26 = "loading cluster header";
      __int16 v27 = 183;
      goto LABEL_51;
    }
    int v121 = 0;
    long long v120 = 0u;
    long long v119 = 0u;
    long long v118 = 0u;
    long long v117 = 0u;
    long long v116 = 0u;
    long long v115 = 0u;
    long long v114 = 0u;
    long long v113 = 0u;
    long long v112 = 0u;
    long long v111 = 0u;
    long long v110 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v105 = 0u;
    memset(&v123[8], 0, 252);
    memset(v122, 0, 260);
    *(_WORD *)&v123[8] = 19267;
    *(void *)uint64_t v123 = 0x5F41454100000006;
    memset_s(&v123[10], 0xFAuLL, 0, 0xFAuLL);
    uint64_t v46 = *(unsigned int *)v123;
    if (*(_DWORD *)v123 >= 0xFDu) {
      goto LABEL_35;
    }
    *(_DWORD *)&v123[*(unsigned int *)v123 + 4] = v95;
    *(_DWORD *)uint64_t v123 = v46 + 4;
    memset_s(&v123[v46 + 8], 252 - v46, 0, 252 - v46);
    uint64_t v47 = *(uint64_t (**)(long long *, void, _DWORD *, unsigned char *, _OWORD *))(v9 + 144);
    if (!v47 || !*v10)
    {
      memset_s(v123, 0x104uLL, 0, 0x104uLL);
LABEL_74:
      int v49 = 1;
      goto LABEL_75;
    }
    int v48 = v47(&v105, *v92, v10, v123, v122);
    memset_s(v123, 0x104uLL, 0, 0x104uLL);
    int v49 = 0;
    if (v48 < 0) {
      goto LABEL_74;
    }
LABEL_75:
    memset((char *)v122 + 12, 0, 248);
    *(void *)((char *)v122 + 4) = 0x4B4548435F414541;
    LODWORD(v122[0]) = 8;
    memset_s((char *)v122 + 12, 0xF8uLL, 0, 0xF8uLL);
    memset(v123, 0, sizeof(v123));
    uint64_t v50 = *(uint64_t (**)(_OWORD *, void, long long *, _OWORD *, unsigned char *))(v9 + 144);
    if (!v50 || !v105) {
      break;
    }
    int v51 = v50(__s, *(unsigned int *)(v9 + 76), &v105, v122, v123);
    memset_s(v122, 0x104uLL, 0, 0x104uLL);
    if (v51 < 0) {
      goto LABEL_106;
    }
    memset_s(&v105, 0x104uLL, 0, 0x104uLL);
    if (v49) {
      goto LABEL_107;
    }
    uint64_t v52 = *(uint64_t (**)(char *, void, _OWORD *, _OWORD *, char *, void))(v9 + 168);
    if (!v52
      || LODWORD(v99[0]) != *(_DWORD *)(v9 + 84)
      || (v52(v24, *(void *)(v9 + 360), v99, __s, &v24[*(void *)(v9 + 360)], *(void *)(v9 + 376) - *(void *)(v9 + 360)) & 0x80000000) != 0)
    {
      char v26 = "decrypting cluster header";
      __int16 v27 = 195;
      goto LABEL_51;
    }
    uint64_t v53 = *(unsigned int *)(v9 + 84);
    if (v53 >= 0x101) {
      goto LABEL_35;
    }
    __memcpy_chk();
    LODWORD(v99[0]) = v53;
    memset_s((char *)v99 + v53 + 4, 256 - v53, 0, 256 - v53);
    LODWORD(v54) = *(_DWORD *)(v9 + 20);
    if (v54)
    {
      unsigned int v55 = 0;
      uint64_t v97 = *(void *)(v9 + 368);
      uint64_t v56 = *(void *)(v9 + 352);
      do
      {
        unsigned int v57 = v55 + v95 * v54;
        if (v57 >= *(_DWORD *)(v9 + 400))
        {
          uint64_t v42 = *(void *)(v9 + 376);
          a2 = v93;
          unint64_t v41 = v42 + v94;
          uint64_t v10 = (_DWORD *)(v9 + 668);
          size_t v19 = v91;
          goto LABEL_93;
        }
        uint64_t v58 = *(void *)(v9 + 392);
        char v59 = (unsigned int *)(v58 + 544 * v57);
        *char v59 = v57;
        v59[1] = *(_DWORD *)&v24[v56];
        v59[2] = *(_DWORD *)&v24[v56 + 4];
        uint64_t v60 = *(unsigned int *)(v9 + 48);
        if (v60 >= 0x101) {
          goto LABEL_35;
        }
        uint64_t v61 = v56 + 8;
        uint64_t v62 = v58 + 544 * v57;
        memcpy((void *)(v62 + 28), &v24[v61], *(unsigned int *)(v9 + 48));
        *(_DWORD *)(v62 + 24) = v60;
        memset_s((void *)(v62 + 28 + v60), 256 - v60, 0, 256 - v60);
        uint64_t v63 = *(unsigned int *)(v9 + 84);
        if (v63 >= 0x101) {
          goto LABEL_35;
        }
        uint64_t v64 = v58 + 544 * v57;
        uint64_t v56 = v61 + *(unsigned int *)(v9 + 48);
        memcpy((void *)(v64 + 288), &v24[v97], *(unsigned int *)(v9 + 84));
        *(_DWORD *)(v64 + 284) = v63;
        memset_s((void *)(v64 + 288 + v63), 256 - v63, 0, 256 - v63);
        v97 += *(unsigned int *)(v9 + 84);
        ++v55;
        LODWORD(v54) = *(_DWORD *)(v9 + 20);
      }
      while (v55 < v54);
      uint64_t v42 = *(void *)(v9 + 376);
      a2 = v93;
      unint64_t v41 = v42 + v94;
      uint64_t v10 = (_DWORD *)(v9 + 668);
      size_t v19 = v91;
      if (!v54) {
        goto LABEL_96;
      }
LABEL_93:
      unint64_t v65 = (v54 * v95);
      unint64_t v66 = *(unsigned int *)(v9 + 400);
      uint64_t v54 = v54;
      uint64_t v67 = 544 * v65;
      do
      {
        if (v65 >= v66) {
          break;
        }
        uint64_t v68 = *(void *)(v9 + 392) + v67;
        *(void *)(v68 + 16) = v41;
        v41 += *(unsigned int *)(v68 + 8);
        v67 += 544;
        ++v65;
        --v54;
      }
      while (v54);
    }
    else
    {
      uint64_t v42 = *(void *)(v9 + 376);
      unint64_t v41 = v42 + v94;
    }
LABEL_96:
    if (++v95 >= *(_DWORD *)(v9 + 404)) {
      goto LABEL_97;
    }
  }
  memset_s(v122, 0x104uLL, 0, 0x104uLL);
LABEL_106:
  memset_s(&v105, 0x104uLL, 0, 0x104uLL);
LABEL_107:
  char v26 = "deriving cluster header key";
  __int16 v27 = 187;
LABEL_51:
  int v38 = 0;
LABEL_52:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerCreateExisting", v27, 28, v38, v26, v11, v12, v90);
LABEL_43:
  int v34 = 0;
LABEL_44:
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v101, 0x104uLL, 0, 0x104uLL);
  memset_s(v99, 0x104uLL, 0, 0x104uLL);
  memset_s(v98, 0x30uLL, 0, 0x30uLL);
  if (v24) {
    memset_s(v24, v19, 0, v19);
  }
  free(v24);
  if (!v34)
  {
    aeaContainerDestroy(v9);
    return 0;
  }
  return v9;
}

uint64_t aeaContainerAppendSegment(uint64_t a1, uint64_t a2, void *__src, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)__src == -1)
  {
    __int16 v22 = "Invalid segment id\n";
    __int16 v23 = 280;
  }
  else
  {
    unsigned int v12 = *(_DWORD *)(a1 + 400);
    int v13 = *(_DWORD *)(a1 + 404);
    unsigned int v14 = *(_DWORD *)(a1 + 20);
    if (v12 < v14 * v13)
    {
      uint64_t v15 = *(void *)(a1 + 40);
      goto LABEL_4;
    }
    *(_DWORD *)(a1 + 404) = v13 + 1;
    unint64_t v24 = v14 * (unint64_t)(v13 + 1);
    if (v24 < 0xFFFFFFFF)
    {
      if (v24 < 0xF0F0F10)
      {
        unint64_t v25 = *(void **)(a1 + 392);
        char v26 = (char *)realloc(v25, 544 * v24);
        if (v26)
        {
          *(void *)(a1 + 392) = v26;
          memset_s(&v26[544 * *(unsigned int *)(a1 + 400)], 544 * (v24 - *(unsigned int *)(a1 + 400)), 0, 544 * (v24 - *(unsigned int *)(a1 + 400)));
          uint64_t v15 = *(void *)(a1 + 40) + *(void *)(a1 + 376);
          *(void *)(a1 + 40) = v15;
          unsigned int v12 = *(_DWORD *)(a1 + 400);
LABEL_4:
          __src[2] = v15;
          uint64_t v16 = *((unsigned int *)__src + 2);
          memcpy((void *)(*(void *)(a1 + 392) + 544 * v12), __src, 0x220uLL);
          ++*(_DWORD *)(a1 + 400);
          uint64_t v17 = *(void *)(a1 + 40) + v16;
          *(void *)(a1 + 32) += *((unsigned int *)__src + 1);
          *(void *)(a1 + 40) = v17;
          if (*(void *)(a2 + 40))
          {
            uint64_t v18 = 0;
            if (v16)
            {
              uint64_t v19 = __src[2];
              uint64_t v20 = v16;
              while (1)
              {
                uint64_t v21 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(a2 + 40))(*(void *)a2, a4, v20, v19);
                if (v21 < 1) {
                  break;
                }
                a4 += v21;
                v18 += v21;
                v19 += v21;
                v20 -= v21;
                if (!v20) {
                  goto LABEL_9;
                }
              }
              uint64_t v18 = v21;
              if ((v21 & 0x8000000000000000) == 0)
              {
LABEL_19:
                if (v18 == v16) {
                  return 0;
                }
              }
            }
            else
            {
LABEL_9:
              if ((v18 & 0x8000000000000000) == 0) {
                goto LABEL_19;
              }
            }
          }
          __int16 v22 = "Segment write";
          __int16 v23 = 308;
          goto LABEL_22;
        }
        free(v25);
      }
      else
      {
        *__error() = 12;
      }
      *(void *)(a1 + 392) = 0;
      int v28 = *__error();
      __int16 v22 = "malloc";
      __int16 v23 = 289;
      goto LABEL_23;
    }
    __int16 v22 = "Container size limit reached";
    __int16 v23 = 287;
  }
LABEL_22:
  int v28 = 0;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerAppendSegment", v23, 28, v28, v22, a7, a8, v29);
  return 0xFFFFFFFFLL;
}

uint64_t aeaContainerRemovePadding(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 40) -= v2;
    *(void *)(a1 + 64) = 0;
    if ((AAByteStreamTruncate(a2) & 0x80000000) != 0) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerRemovePadding", 328, 28, "Warning: container truncate failed", v3, v4, v5, vars0);
    }
  }
  return 0;
}

uint64_t aeaContainerRemoveLastSegment(uint64x2_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int32 v8 = a1[25].i32[0];
  if (!v8)
  {
    uint64_t v10 = "No segments to remove";
    __int16 v11 = 339;
    goto LABEL_5;
  }
  if (a1[4].i64[0])
  {
    uint64_t v10 = "Padding was not removed";
    __int16 v11 = 340;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerRemoveLastSegment", v11, 28, 0, v10, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = a1[24].i64[1] + 544 * (v8 - 1);
  __int32 v15 = a1[25].i32[1];
  a1[25].i32[0] = v8 - 1;
  a1[25].i32[1] = (v8 + a1[1].i32[1] - 2) / a1[1].i32[1];
  a1[2] = vsubw_u32(a1[2], *(uint32x2_t *)(v14 + 4));
  memset_s((void *)v14, 0x220uLL, 0, 0x220uLL);
  if (v15 != a1[25].i32[1]) {
    a1[2].i64[1] -= a1[23].i64[1];
  }
  if ((AAByteStreamTruncate(a2) & 0x80000000) != 0) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerRemoveLastSegment", 364, 28, "Warning: container truncate failed", v16, v17, v18, v19);
  }
  return 0;
}

uint64_t aeaContainerReencrypt(uint64_t a1, AAByteStream_impl *a2, int *a3, _DWORD *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t v137 = *MEMORY[0x263EF8340];
  int v117 = 0;
  long long v116 = 0u;
  long long v115 = 0u;
  long long v114 = 0u;
  long long v113 = 0u;
  long long v112 = 0u;
  long long v111 = 0u;
  long long v110 = 0u;
  long long v109 = 0u;
  long long v108 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  *(_OWORD *)char __n = 0u;
  int v100 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  *(_OWORD *)int64x2_t v84 = 0u;
  long long v85 = 0u;
  int v83 = 0;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  *(_OWORD *)uint64_t v67 = 0u;
  long long v68 = 0u;
  size_t v12 = *(unsigned int *)(a1 + 16);
  BOOL v14 = (*(_DWORD *)a1 & 0x3F) == 0 && *(_DWORD *)a1 < 6u;
  BOOL v63 = v14;
  memset(v65, 0, sizeof(v65));
  int v66 = 0;
  __int32 v15 = (char *)malloc(v12);
  if (!v15)
  {
    uint64_t v50 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerReencrypt", 390, 28, *v50, "malloc", v51, v52, v56);
    int v49 = 0;
    goto LABEL_70;
  }
  uint64_t v60 = (unsigned int *)(a1 + 72);
  if ((aeaDeriveMainKeyNew((unsigned int *)(a1 + 72), (int *)a1, (long long *)v84, (int *)v67, (char *)__n, a3, a4, a5, a6) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerReencrypt", 400, 28, 0, "generating new main key", v16, v17, v57);
    int v49 = 0;
    goto LABEL_69;
  }
  if (!*(_DWORD *)(a1 + 400))
  {
LABEL_53:
    uint64_t v46 = LODWORD(__n[0]);
    if (LODWORD(__n[0]) >= 0x101) {
      goto LABEL_74;
    }
    memcpy((void *)(a1 + 412), (char *)__n + 4, LODWORD(__n[0]));
    *(_DWORD *)(a1 + 408) = v46;
    memset_s((void *)(a1 + 412 + v46), 256 - v46, 0, 256 - v46);
    uint64_t v47 = LODWORD(v84[0]);
    if (LODWORD(v84[0]) >= 0x101
      || (memcpy((void *)(a1 + 672), (char *)v84 + 4, LODWORD(v84[0])),
          *(_DWORD *)(a1 + 668) = v47,
          memset_s((void *)(a1 + 672 + v47), 256 - v47, 0, 256 - v47),
          uint64_t v48 = LODWORD(v67[0]),
          LODWORD(v67[0]) >= 0x101))
    {
LABEL_74:
      __break(1u);
    }
    memcpy((void *)(a1 + 932), (char *)v67 + 4, LODWORD(v67[0]));
    *(_DWORD *)(a1 + 928) = v48;
    memset_s((void *)(a1 + 932 + v48), 256 - v48, 0, 256 - v48);
    int v49 = 1;
    goto LABEL_69;
  }
  unsigned int v18 = 0;
  char v59 = (_DWORD *)(a1 + 668);
  char v19 = (char *)v136 + 4;
  while (1)
  {
    if (!*((void *)a2 + 4)) {
      goto LABEL_60;
    }
    uint64_t v20 = v19;
    uint64_t v61 = *(void *)(a1 + 392);
    uint64_t v21 = v61 + 544 * v18;
    size_t v22 = *(unsigned int *)(v21 + 8);
    unsigned int v62 = *(_DWORD *)(a1 + 20);
    __int16 v23 = (off_t *)(v21 + 16);
    size_t v64 = v22;
    uint64_t v58 = v23;
    uint64_t v24 = 0;
    if (v22)
    {
      off_t v25 = *v23;
      char v26 = v15;
      while (1)
      {
        uint64_t v27 = (*((uint64_t (**)(void, char *, size_t, off_t))a2 + 4))(*(void *)a2, v26, v22, v25);
        if (v27 < 0) {
          break;
        }
        if (v27)
        {
          v26 += v27;
          v24 += v27;
          v25 += v27;
          v22 -= v27;
          if (v22) {
            continue;
          }
        }
        goto LABEL_19;
      }
      uint64_t v24 = v27;
    }
LABEL_19:
    if (v24 != v64)
    {
LABEL_60:
      uint64_t v53 = "loading compressed segment";
      __int16 v54 = 412;
      goto LABEL_68;
    }
    char v19 = v20;
    int v134 = 0;
    long long v133 = 0uLL;
    long long v132 = 0uLL;
    long long v131 = 0uLL;
    long long v130 = 0uLL;
    long long v129 = 0uLL;
    long long v128 = 0uLL;
    long long v127 = 0uLL;
    long long v126 = 0uLL;
    long long v125 = 0uLL;
    long long v124 = 0uLL;
    long long v123 = 0uLL;
    long long v122 = 0uLL;
    long long v121 = 0uLL;
    long long v120 = 0uLL;
    long long v119 = 0uLL;
    long long v118 = 0uLL;
    *(_OWORD *)((char *)&v136[15] + 4) = 0uLL;
    *(_OWORD *)((char *)&v136[13] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[14] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[11] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[12] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[9] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[10] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[7] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[8] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[5] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[6] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[3] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[4] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[1] + 8) = 0uLL;
    *(_OWORD *)((char *)&v136[2] + 8) = 0uLL;
    *(_OWORD *)((char *)v136 + 8) = 0uLL;
    memset(v135, 0, 260);
    *((_WORD *)v20 + 2) = 19267;
    *(_DWORD *)uint64_t v20 = 1598113089;
    LODWORD(v136[0]) = 6;
    memset_s((char *)v136 + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v28 = LODWORD(v136[0]);
    if (LODWORD(v136[0]) >= 0xFD) {
      goto LABEL_74;
    }
    *(_DWORD *)&v20[LODWORD(v136[0])] = v18 / v62;
    LODWORD(v136[0]) = v28 + 4;
    memset_s(&v20[v28 + 4], 252 - v28, 0, 252 - v28);
    char v29 = *(uint64_t (**)(long long *, void, _DWORD *, _OWORD *, _OWORD *))(a1 + 144);
    if (v29 && *v59)
    {
      int v30 = v29(&v118, *v60, v59, v136, v135);
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
      int v31 = 0;
      if ((v30 & 0x80000000) == 0) {
        goto LABEL_27;
      }
    }
    else
    {
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
    }
    int v31 = 1;
LABEL_27:
    memset((char *)v135 + 8, 0, 252);
    WORD4(v135[0]) = 19283;
    *(void *)&v135[0] = 0x5F41454100000006;
    memset_s((char *)v135 + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v32 = LODWORD(v135[0]);
    if (LODWORD(v135[0]) >= 0xFD) {
      goto LABEL_74;
    }
    *(_DWORD *)((char *)v135 + LODWORD(v135[0]) + 4) = v18 % v62;
    LODWORD(v135[0]) = v32 + 4;
    memset_s((char *)v135 + v32 + 8, 252 - v32, 0, 252 - v32);
    memset(v136, 0, 260);
    unsigned int v33 = *(uint64_t (**)(_OWORD *, void, long long *, _OWORD *, _OWORD *))(a1 + 144);
    if (!v33 || !v118)
    {
      memset_s(v135, 0x104uLL, 0, 0x104uLL);
LABEL_63:
      memset_s(&v118, 0x104uLL, 0, 0x104uLL);
LABEL_64:
      uint64_t v53 = "deriving segment key";
      __int16 v54 = 416;
      goto LABEL_68;
    }
    int v34 = v33(v65, *(unsigned int *)(a1 + 76), &v118, v135, v136);
    memset_s(v135, 0x104uLL, 0, 0x104uLL);
    if (v34 < 0) {
      goto LABEL_63;
    }
    memset_s(&v118, 0x104uLL, 0, 0x104uLL);
    if (v31) {
      goto LABEL_64;
    }
    char v35 = *(uint64_t (**)(char *, size_t, uint64_t, _OWORD *, void, void))(a1 + 168);
    if (!v35
      || (unsigned int v36 = (_DWORD *)(v61 + 544 * v18 + 284), *v36 != *(_DWORD *)(a1 + 84))
      || (v35(v15, v64, v61 + 544 * v18 + 284, v65, 0, 0) & 0x80000000) != 0)
    {
      uint64_t v53 = "decrypting segment data";
      __int16 v54 = 418;
      goto LABEL_68;
    }
    int v134 = 0;
    long long v133 = 0u;
    long long v132 = 0u;
    long long v131 = 0u;
    long long v130 = 0u;
    long long v129 = 0u;
    long long v128 = 0u;
    long long v127 = 0u;
    long long v126 = 0u;
    long long v125 = 0u;
    long long v124 = 0u;
    long long v123 = 0u;
    long long v122 = 0u;
    long long v121 = 0u;
    long long v120 = 0u;
    long long v119 = 0u;
    long long v118 = 0u;
    memset((char *)v136 + 8, 0, 252);
    memset(v135, 0, 260);
    *((_WORD *)v20 + 2) = 19267;
    *(_DWORD *)uint64_t v20 = 1598113089;
    LODWORD(v136[0]) = 6;
    memset_s((char *)v136 + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v37 = LODWORD(v136[0]);
    if (LODWORD(v136[0]) >= 0xFD) {
      goto LABEL_74;
    }
    *(_DWORD *)&v20[LODWORD(v136[0])] = v18 / v62;
    LODWORD(v136[0]) = v37 + 4;
    memset_s(&v20[v37 + 4], 252 - v37, 0, 252 - v37);
    int v38 = *(uint64_t (**)(long long *, void, size_t *, _OWORD *, _OWORD *))(a1 + 144);
    if (v38 && LODWORD(v84[0]))
    {
      int v39 = v38(&v118, *v60, v84, v136, v135);
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
      int v40 = 0;
      if ((v39 & 0x80000000) == 0) {
        goto LABEL_42;
      }
    }
    else
    {
      memset_s(v136, 0x104uLL, 0, 0x104uLL);
    }
    int v40 = 1;
LABEL_42:
    memset((char *)v135 + 8, 0, 252);
    WORD4(v135[0]) = 19283;
    *(void *)&v135[0] = 0x5F41454100000006;
    memset_s((char *)v135 + 10, 0xFAuLL, 0, 0xFAuLL);
    uint64_t v41 = LODWORD(v135[0]);
    if (LODWORD(v135[0]) >= 0xFD) {
      goto LABEL_74;
    }
    *(_DWORD *)((char *)v135 + LODWORD(v135[0]) + 4) = v18 % v62;
    LODWORD(v135[0]) = v41 + 4;
    memset_s((char *)v135 + v41 + 8, 252 - v41, 0, 252 - v41);
    memset(v136, 0, 260);
    uint64_t v42 = *(uint64_t (**)(_OWORD *, void, long long *, _OWORD *, _OWORD *))(a1 + 144);
    if (!v42 || !v118)
    {
      memset_s(v135, 0x104uLL, 0, 0x104uLL);
LABEL_66:
      memset_s(&v118, 0x104uLL, 0, 0x104uLL);
LABEL_67:
      uint64_t v53 = "deriving segment key";
      __int16 v54 = 422;
      goto LABEL_68;
    }
    int v43 = v42(v65, *(unsigned int *)(a1 + 76), &v118, v135, v136);
    memset_s(v135, 0x104uLL, 0, 0x104uLL);
    if (v43 < 0) {
      goto LABEL_66;
    }
    memset_s(&v118, 0x104uLL, 0, 0x104uLL);
    if (v40) {
      goto LABEL_67;
    }
    int v44 = *(uint64_t (**)(char *, size_t, _DWORD *, _OWORD *, void, void))(a1 + 160);
    if (!v44 || (int v45 = v44(v15, v64, v36, v65, 0, 0), *v36 != *(_DWORD *)(a1 + 84)) || v45 < 0)
    {
      uint64_t v53 = "decrypting segment data";
      __int16 v54 = 424;
      goto LABEL_68;
    }
    if (!v63 && AAByteStreamPWrite(a2, v15, v64, *v58) != v64) {
      break;
    }
    if (++v18 >= *(_DWORD *)(a1 + 400)) {
      goto LABEL_53;
    }
  }
  uint64_t v53 = "storing compressed segment";
  __int16 v54 = 429;
LABEL_68:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerReencrypt", v54, 28, 0, v53, v16, v17, v57);
  int v49 = 0;
LABEL_69:
  memset_s(v15, v12, 0, v12);
LABEL_70:
  free(v15);
  memset_s(v84, 0x104uLL, 0, 0x104uLL);
  memset_s(__n, 0x104uLL, 0, 0x104uLL);
  memset_s(v67, 0x104uLL, 0, 0x104uLL);
  memset_s(v65, 0x104uLL, 0, 0x104uLL);
  if (v49) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aeaContainerLoadSegment(uint64_t a1, void *a2, unsigned int a3, uint8_t *a4, const uint8_t *a5, void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  int v51 = 0;
  memset(v50, 0, sizeof(v50));
  int v49 = 0;
  memset(v48, 0, sizeof(v48));
  int v47 = 0;
  memset(v46, 0, sizeof(v46));
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8) {
    uint64_t v9 = (char *)a5;
  }
  else {
    uint64_t v9 = (char *)a4;
  }
  if (*(_DWORD *)(a1 + 400) <= a3)
  {
    uint64_t v21 = "Invalid segment index";
    __int16 v22 = 463;
    goto LABEL_41;
  }
  if (!a2[4]) {
    goto LABEL_20;
  }
  uint64_t v13 = *(void *)(a1 + 392);
  uint64_t v14 = v13 + 544 * a3;
  uint64_t v15 = *(unsigned int *)(v14 + 8);
  size_t __n = *(unsigned int *)(v14 + 4);
  uint64_t v42 = v13;
  if (v15)
  {
    uint64_t v16 = 0;
    uint64_t v17 = *(void *)(v13 + 544 * a3 + 16);
    unsigned int v18 = v9;
    size_t v19 = *(unsigned int *)(v14 + 8);
    while (1)
    {
      uint64_t v20 = ((uint64_t (*)(void, char *, uint64_t, uint64_t))a2[4])(*a2, v9, v15, v17);
      if (v20 < 0) {
        break;
      }
      if (v20)
      {
        v9 += v20;
        v16 += v20;
        v17 += v20;
        v15 -= v20;
        if (v15) {
          continue;
        }
      }
      goto LABEL_15;
    }
    uint64_t v16 = v20;
  }
  else
  {
    unsigned int v18 = v9;
    size_t v19 = *(unsigned int *)(v14 + 8);
    uint64_t v16 = 0;
  }
LABEL_15:
  if (v16 != v19)
  {
LABEL_20:
    uint64_t v21 = "loading segment";
    __int16 v22 = 471;
    goto LABEL_41;
  }
  int v39 = v18;
  unsigned int v23 = *(_DWORD *)(a1 + 20);
  int v53 = 0;
  memset(v52, 0, sizeof(v52));
  memset(&__s[8], 0, 252);
  *(_WORD *)&__s[8] = 19267;
  memset(v54, 0, 260);
  memset_s(&__s[10], 0xFAuLL, 0, 0xFAuLL);
  *(_DWORD *)&__s[10] = a3 / v23;
  *(void *)char __s = 0x5F4145410000000ALL;
  memset_s(&__s[14], 0xF6uLL, 0, 0xF6uLL);
  uint64_t v24 = *(uint64_t (**)(_OWORD *, void))(a1 + 144);
  if (v24 && *(_DWORD *)(a1 + 668))
  {
    int v25 = v24(v52, *(unsigned int *)(a1 + 72));
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    int v26 = 0;
    if ((v25 & 0x80000000) == 0) {
      goto LABEL_23;
    }
  }
  else
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
  }
  int v26 = 1;
LABEL_23:
  memset((char *)v54 + 8, 0, 224);
  memset((char *)&v54[14] + 8, 0, 28);
  WORD4(v54[0]) = 19283;
  *(void *)&v54[0] = 0x5F41454100000006;
  uint64_t result = memset_s((char *)v54 + 10, 0xFAuLL, 0, 0xFAuLL);
  uint64_t v28 = LODWORD(v54[0]);
  if (LODWORD(v54[0]) < 0xFD)
  {
    *(_DWORD *)((char *)v54 + LODWORD(v54[0]) + 4) = a3 % v23;
    LODWORD(v54[0]) = v28 + 4;
    memset_s((char *)v54 + v28 + 8, 252 - v28, 0, 252 - v28);
    memset(__s, 0, sizeof(__s));
    char v29 = *(uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, unsigned char *))(a1 + 144);
    if (v29 && LODWORD(v52[0]))
    {
      int v30 = v29(v48, *(unsigned int *)(a1 + 76), v52, v54, __s);
      memset_s(v54, 0x104uLL, 0, 0x104uLL);
      if ((v30 & 0x80000000) == 0)
      {
        memset_s(v52, 0x104uLL, 0, 0x104uLL);
        if (!v26)
        {
          int v31 = *(uint64_t (**)(char *, size_t))(a1 + 168);
          if (v31 && *(_DWORD *)(v42 + 544 * a3 + 284) == *(_DWORD *)(a1 + 84) && (v31(v39, v19) & 0x80000000) == 0)
          {
            uint64_t v34 = __n;
            if (v8)
            {
              uint64_t v35 = *(unsigned int *)(a1 + 24);
              if (v35 && __n > v19)
              {
                if (v35 == 774)
                {
                  int64_t v36 = PCompressLZMADecode(a4, *(unsigned int *)(a1 + 16), a5, v19);
                  if (v36 >= 0) {
                    int64_t v36 = v36;
                  }
                  else {
                    int64_t v36 = 0;
                  }
                }
                else
                {
                  compression_algorithm v37 = aeaEffectiveCompressionAlgorithm(v35);
                  int64_t v36 = compression_decode_buffer(a4, *(unsigned int *)(a1 + 16), a5, v19, a6, v37);
                }
                if (v36 != __n)
                {
                  uint64_t v21 = "Segment decompression";
                  __int16 v22 = 511;
                  goto LABEL_41;
                }
              }
              else
              {
                memcpy(a4, a5, __n);
              }
            }
            if ((aeaChecksum((uint64_t)v46, *(_DWORD *)(a1 + 12), a4, __n, v32, v33, a7, a8) & 0x80000000) != 0)
            {
              uint64_t v21 = "computing segment checksum";
              __int16 v22 = 515;
            }
            else
            {
              size_t v38 = *(unsigned int *)(a1 + 48);
              if (!v38 || !memcmp((char *)v46 + 4, (const void *)(v42 + 544 * a3 + 28), v38)) {
                goto LABEL_42;
              }
              uint64_t v21 = "Checksum verification failed, data corrupted";
              __int16 v22 = 519;
            }
          }
          else
          {
            uint64_t v21 = "decrypting segment data";
            __int16 v22 = 485;
          }
LABEL_41:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerLoadSegment", v22, 28, 0, v21, a7, a8, (char)v39);
          uint64_t v34 = -1;
LABEL_42:
          memset_s(v50, 0x104uLL, 0, 0x104uLL);
          memset_s(v48, 0x104uLL, 0, 0x104uLL);
          memset_s(v46, 0x104uLL, 0, 0x104uLL);
          return v34;
        }
LABEL_40:
        uint64_t v21 = "deriving segment key";
        __int16 v22 = 481;
        goto LABEL_41;
      }
    }
    else
    {
      memset_s(v54, 0x104uLL, 0, 0x104uLL);
    }
    memset_s(v52, 0x104uLL, 0, 0x104uLL);
    goto LABEL_40;
  }
  __break(1u);
  return result;
}

unint64_t aeaPaddedContainerSize(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (a2 > 0xF) {
      goto LABEL_8;
    }
    if (a2)
    {
      if (a2 == 1)
      {
        if (result >= 8)
        {
          int v9 = __clz(result);
          int v10 = __clz(v9 ^ 0x3F) - v9;
          if (v10 < -31) {
            return -1;
          }
          a2 = 1 << (v10 + 31);
LABEL_8:
          if (!__CFADD__(result, a2 - 1)) {
            return (result + a2 - 1) / a2 * a2;
          }
          return -1;
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaPaddedContainerSize", 585, 28, 0, "Invalid padding_alignment", a7, a8, v8);
        return -1;
      }
    }
  }
  return result;
}

uint64_t aeaContainerFinish(uint64_t a1, AAByteStream_impl *a2)
{
  uint64_t v208 = *MEMORY[0x263EF8340];
  size_t v3 = *(void *)(a1 + 344);
  size_t v4 = *(void *)(a1 + 376);
  if (v3 <= v4) {
    unint64_t v5 = *(void *)(a1 + 376);
  }
  else {
    unint64_t v5 = *(void *)(a1 + 344);
  }
  int v171 = 0;
  if (v5 <= 0x100000) {
    rsize_t v6 = 0x100000;
  }
  else {
    rsize_t v6 = v5;
  }
  memset(__s, 0, sizeof(__s));
  int v169 = 0;
  long long v168 = 0u;
  long long v167 = 0u;
  long long v166 = 0u;
  long long v165 = 0u;
  long long v164 = 0u;
  long long v163 = 0u;
  long long v162 = 0u;
  long long v161 = 0u;
  long long v160 = 0u;
  long long v159 = 0u;
  long long v158 = 0u;
  long long v157 = 0u;
  long long v156 = 0u;
  long long v155 = 0u;
  long long v154 = 0u;
  *(_OWORD *)int v153 = 0u;
  int v152 = 0;
  memset(v151, 0, sizeof(v151));
  int v150 = 0;
  memset(v149, 0, sizeof(v149));
  int v148 = 0;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  *(_OWORD *)long long v132 = 0u;
  long long v133 = 0u;
  int v131 = 0;
  memset(v130, 0, sizeof(v130));
  int v129 = 0;
  memset(v128, 0, sizeof(v128));
  int v124 = 0;
  uint64_t v123 = 0;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v125 = 0u;
  if (v6 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_21:
    uint64_t v24 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", 620, 28, *v24, "malloc", v25, v26, nbyte);
    int v9 = 0;
    rsize_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = 0xFFFFFFFFLL;
    char v30 = 1;
LABEL_25:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v153, 0x104uLL, 0, 0x104uLL);
    memset_s(v130, 0x104uLL, 0, 0x104uLL);
    memset_s(v151, 0x104uLL, 0, 0x104uLL);
    memset_s(v149, 0x104uLL, 0, 0x104uLL);
    memset_s(v132, 0x104uLL, 0, 0x104uLL);
    memset_s(v128, 0x104uLL, 0, 0x104uLL);
    memset_s(&v125, 0x30uLL, 0, 0x30uLL);
    memset_s(&v123, 0xCuLL, 0, 0xCuLL);
    if ((v30 & 1) == 0) {
      memset_s(v9, v6, 0, v6);
    }
    free(v9);
    if (v28) {
      memset_s(v28, v27, 0, v27);
    }
    free(v28);
    uint64_t v33 = *(void **)(a1 + 384);
    if (v33) {
      memset_s(*(void **)(a1 + 384), *(unsigned int *)(a1 + 4), 0, *(unsigned int *)(a1 + 4));
    }
    free(v33);
    *(void *)(a1 + 384) = 0;
    return v29;
  }
  char v8 = (char *)malloc(v6);
  if (!v8) {
    goto LABEL_21;
  }
  int v9 = v8;
  unsigned int v10 = *(_DWORD *)(a1 + 84);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v10 > 0x100 || (uint64_t v13 = *(uint64_t (**)(void))(a1 + 136)) == 0 || (v13() & 0x80000000) != 0)
  {
    int v31 = "generating last cluster random MAC";
    __int16 v32 = 624;
    goto LABEL_23;
  }
  LODWORD(__s[0]) = v10;
  unint64_t v18 = *(void *)(a1 + 56);
  if (v18)
  {
    unint64_t v19 = *(void *)(a1 + 40);
    unint64_t v20 = aeaPaddedContainerSize(v19, v18, v14, v15, v16, v17, v11, v12);
    if (v20 == -1)
    {
      int v31 = "Container size is too large to allow padding";
      __int16 v32 = 631;
      goto LABEL_23;
    }
    unint64_t v21 = v20;
    if (v20 > v19)
    {
      memset(v207, 0, sizeof(v207));
      memset(v206, 0, 260);
      int v205 = 0;
      long long v204 = 0u;
      long long v203 = 0u;
      long long v202 = 0u;
      long long v201 = 0u;
      long long v200 = 0u;
      long long v199 = 0u;
      long long v198 = 0u;
      long long v197 = 0u;
      long long v196 = 0u;
      long long v195 = 0u;
      long long v194 = 0u;
      long long v193 = 0u;
      long long v192 = 0u;
      long long v191 = 0u;
      long long v190 = 0u;
      long long v189 = 0u;
      if (*(void *)(a1 + 248)
        && (*(_DWORD *)((char *)v206 + 7) = 1262571615,
            *(void *)&v206[0] = 0x5F41454100000007,
            memset_s((void *)((unint64_t)v206 | 0xB), 0xF9uLL, 0, 0xF9uLL),
            (__int16 v22 = *(uint64_t (**)(unsigned char *, void))(a1 + 144)) != 0)
        && *(_DWORD *)(a1 + 668)
        && (v22(v207, *(unsigned int *)(a1 + 72)) & 0x80000000) == 0)
      {
        uint64_t v23 = (*(uint64_t (**)(unsigned char *))(a1 + 248))(v207);
      }
      else
      {
        uint64_t v23 = 0;
      }
      memset_s(v207, 0x104uLL, 0, 0x104uLL);
      memset_s(v206, 0x104uLL, 0, 0x104uLL);
      if (v23)
      {
        size_t nbyte = v3;
        while (1)
        {
          if (v21 - v19 >= 0x100000) {
            size_t v35 = 0x100000;
          }
          else {
            size_t v35 = v21 - v19;
          }
          int64_t v36 = *(uint64_t (**)(char *, size_t))(a1 + 136);
          if (!v36 || (v36(v9, v35) & 0x80000000) != 0)
          {
            int v40 = "generating padding";
            __int16 v41 = 640;
            goto LABEL_50;
          }
          compression_algorithm v37 = *(uint64_t (**)(uint64_t, char *, size_t))(a1 + 256);
          if (!v37 || (v37(v23, v9, v35) & 0x80000000) != 0)
          {
            int v40 = "hashing padding";
            __int16 v41 = 641;
            goto LABEL_50;
          }
          ssize_t v38 = AAByteStreamPWrite(a2, v9, v35, v19);
          if (v38 <= 0) {
            break;
          }
          v19 += v38;
          if (v19 >= v21)
          {
            int v39 = 0;
            goto LABEL_51;
          }
        }
        int v40 = "writing padding";
        __int16 v41 = 643;
LABEL_50:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v41, 28, 0, v40, v11, v12, v3);
        int v39 = 1;
LABEL_51:
        uint64_t v42 = *(uint64_t (**)(uint64_t, _OWORD *))(a1 + 264);
        size_t v3 = nbyte;
        if (v42)
        {
          if ((v42(v23, __s) & 0x80000000) == 0 && LODWORD(__s[0]) == *(_DWORD *)(a1 + 84))
          {
            if (!v39)
            {
              *(void *)(a1 + 40) = v19;
              goto LABEL_56;
            }
            goto LABEL_114;
          }
          memset_s(__s, 0x104uLL, 0, 0x104uLL);
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", 646, 28, 0, "hashing padding", v11, v12, nbyte);
LABEL_114:
        int v31 = "Padding generation and hashing failed";
        __int16 v32 = 648;
        goto LABEL_23;
      }
      int v31 = "hashing padding";
      __int16 v32 = 636;
LABEL_23:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v32, 28, 0, v31, v11, v12, nbyte);
      char v30 = 0;
      rsize_t v27 = 0;
      uint64_t v28 = 0;
LABEL_24:
      uint64_t v29 = 0xFFFFFFFFLL;
      goto LABEL_25;
    }
  }
LABEL_56:
  size_t nbyte = v3;
  rsize_t __n = v6;
  int v117 = (_DWORD *)(a1 + 668);
  long long v118 = a2;
  int v43 = *(_DWORD *)(a1 + 404);
  int v44 = v43 - 1;
  while (v43)
  {
    int v45 = *(_DWORD *)(a1 + 20);
    int v120 = v44;
    int v121 = v43 - 1;
    unint64_t v46 = (v45 * (v43 - 1));
    unsigned int v47 = v45 * v43;
    unsigned int v48 = *(_DWORD *)(a1 + 400);
    if (v47 >= v48) {
      unint64_t v49 = v48;
    }
    else {
      unint64_t v49 = v47;
    }
    uint64_t v50 = *(void *)(a1 + 392);
    uint64_t v119 = *(void *)(v50 + 544 * v46 + 16);
    unint64_t v51 = *(void *)(a1 + 368);
    unint64_t v122 = *(void *)(a1 + 376);
    unint64_t v52 = 0;
    if (v46 < v49)
    {
      int v53 = (_DWORD *)(v50 + 544 * (v45 * v44));
      do
      {
        __int16 v54 = &v9[v52];
        *(_DWORD *)__int16 v54 = v53[1];
        *((_DWORD *)v54 + 1) = v53[2];
        unint64_t v55 = v52 + 8;
        memcpy(&v9[v55], v53 + 7, v53[6]);
        unint64_t v52 = v55 + v53[6];
        memcpy(&v9[v51], v53 + 72, v53[71]);
        v51 += v53[71];
        ++v46;
        v53 += 136;
      }
      while (v46 < v49);
    }
    unint64_t v56 = *(void *)(a1 + 360);
    unint64_t v57 = v122;
    if (v56 > v52)
    {
      memset_s(&v9[v52], v56 - v52, 0, v56 - v52);
      unint64_t v57 = *(void *)(a1 + 376);
    }
    unint64_t v58 = v57 - v51;
    a2 = v118;
    if (v57 > v51)
    {
      char v59 = *(uint64_t (**)(char *, unint64_t))(a1 + 136);
      if (!v59 || (v59(&v9[v51], v58) & 0x80000000) != 0)
      {
        long long v69 = "generating random padding";
        __int16 v70 = 687;
        goto LABEL_109;
      }
    }
    memcpy(&v9[*(void *)(a1 + 360)], (char *)__s + 4, LODWORD(__s[0]));
    int v205 = 0;
    long long v204 = 0u;
    long long v203 = 0u;
    long long v202 = 0u;
    long long v201 = 0u;
    long long v200 = 0u;
    long long v199 = 0u;
    long long v198 = 0u;
    long long v197 = 0u;
    long long v196 = 0u;
    long long v195 = 0u;
    long long v194 = 0u;
    long long v193 = 0u;
    long long v192 = 0u;
    long long v191 = 0u;
    long long v190 = 0u;
    long long v189 = 0u;
    memset(&v207[8], 0, 252);
    memset(v206, 0, 260);
    *(_WORD *)&v207[8] = 19267;
    *(void *)uint64_t v207 = 0x5F41454100000006;
    uint64_t result = memset_s(&v207[10], 0xFAuLL, 0, 0xFAuLL);
    uint64_t v60 = *(unsigned int *)v207;
    if (*(_DWORD *)v207 >= 0xFDu) {
      goto LABEL_162;
    }
    *(_DWORD *)&v207[*(unsigned int *)v207 + 4] = v121;
    *(_DWORD *)uint64_t v207 = v60 + 4;
    memset_s(&v207[v60 + 8], 252 - v60, 0, 252 - v60);
    uint64_t v61 = *(uint64_t (**)(long long *, void, _DWORD *, unsigned char *, _OWORD *))(a1 + 144);
    if (!v61 || !*v117)
    {
      memset_s(v207, 0x104uLL, 0, 0x104uLL);
LABEL_75:
      int v63 = 1;
      goto LABEL_76;
    }
    int v62 = v61(&v189, *(unsigned int *)(a1 + 72), v117, v207, v206);
    memset_s(v207, 0x104uLL, 0, 0x104uLL);
    int v63 = 0;
    if (v62 < 0) {
      goto LABEL_75;
    }
LABEL_76:
    memset((char *)v206 + 12, 0, 248);
    *(void *)((char *)v206 + 4) = 0x4B4548435F414541;
    LODWORD(v206[0]) = 8;
    memset_s((char *)v206 + 12, 0xF8uLL, 0, 0xF8uLL);
    memset(v207, 0, sizeof(v207));
    size_t v64 = *(uint64_t (**)(_OWORD *, void, long long *, _OWORD *, unsigned char *))(a1 + 144);
    if (!v64 || !v189)
    {
      memset_s(v206, 0x104uLL, 0, 0x104uLL);
LABEL_107:
      memset_s(&v189, 0x104uLL, 0, 0x104uLL);
LABEL_108:
      long long v69 = "derivating secondary key";
      __int16 v70 = 695;
LABEL_109:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v70, 28, 0, v69, v11, v12, nbyte);
      char v30 = 0;
      rsize_t v27 = 0;
      uint64_t v28 = 0;
LABEL_110:
      uint64_t v29 = 0xFFFFFFFFLL;
LABEL_111:
      rsize_t v6 = __n;
      goto LABEL_25;
    }
    int v65 = v64(v151, *(unsigned int *)(a1 + 76), &v189, v206, v207);
    memset_s(v206, 0x104uLL, 0, 0x104uLL);
    if (v65 < 0) {
      goto LABEL_107;
    }
    memset_s(&v189, 0x104uLL, 0, 0x104uLL);
    if (v63) {
      goto LABEL_108;
    }
    int v66 = *(uint64_t (**)(char *, void, _OWORD *, _OWORD *, char *, size_t))(a1 + 160);
    if (!v66
      || (int v67 = v66(v9, *(void *)(a1 + 360), __s, v151, &v9[*(void *)(a1 + 360)], v4 - *(void *)(a1 + 360)),
          LODWORD(__s[0]) != *(_DWORD *)(a1 + 84))
      || v67 < 0)
    {
      long long v69 = "Cluster header encryption";
      __int16 v70 = 702;
      goto LABEL_109;
    }
    ssize_t v68 = AAByteStreamPWrite(v118, v9, v4, v119 - v122);
    int v44 = v120 - 1;
    int v43 = v121;
    if (v68 != v4)
    {
      long long v69 = "writing cluster header";
      __int16 v70 = 707;
      goto LABEL_109;
    }
  }
  rsize_t v6 = __n;
  memset_s(v9, __n, 0, __n);
  if ((aeaMagicInit(&v123, (_DWORD *)a1) & 0x80000000) != 0)
  {
    int v31 = "encoding magic";
    __int16 v32 = 717;
    goto LABEL_23;
  }
  uint64_t v71 = *(void *)(a1 + 288);
  long long v72 = &v9[*(void *)(a1 + 280)];
  *(void *)long long v72 = v123;
  *((_DWORD *)v72 + 2) = v124;
  memcpy(&v9[v71], *(const void **)(a1 + 384), *(unsigned int *)(a1 + 4));
  memcpy(&v9[*(void *)(a1 + 336)], (char *)__s + 4, LODWORD(__s[0]));
  if ((aeaRootHeaderInit((uint64_t)&v125, a1, v73, v74, v75, v76, v77, v78) & 0x80000000) != 0)
  {
    int v31 = "encoding root header";
    __int16 v32 = 727;
    goto LABEL_23;
  }
  size_t v79 = LODWORD(__s[0]);
  size_t v80 = *(unsigned int *)(a1 + 4);
  rsize_t v27 = (v80 + LODWORD(__s[0]));
  long long v81 = (char *)malloc(v27);
  uint64_t v28 = v81;
  if (!v81)
  {
    int v103 = *__error();
    long long v99 = "malloc";
    __int16 v100 = 732;
LABEL_121:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v100, 28, v103, v99, v93, v94, nbyte);
    char v30 = 0;
    goto LABEL_110;
  }
  memcpy(v81, (char *)__s + 4, v79);
  memcpy(&v28[v79], *(const void **)(a1 + 384), v80);
  memset((char *)v206 + 12, 0, 248);
  *(void *)((char *)v206 + 4) = 0x4B4548525F414541;
  LODWORD(v206[0]) = 8;
  memset_s((char *)v206 + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(v207, 0, sizeof(v207));
  long long v82 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, unsigned char *))(a1 + 144);
  if (!v82 || !*v117)
  {
    memset_s(v206, 0x104uLL, 0, 0x104uLL);
    rsize_t v6 = __n;
    goto LABEL_118;
  }
  int v83 = v82(v151, *(unsigned int *)(a1 + 76), v117, v206, v207);
  memset_s(v206, 0x104uLL, 0, 0x104uLL);
  rsize_t v6 = __n;
  if (v83 < 0)
  {
LABEL_118:
    uint64_t v101 = "derivating RHEK";
    __int16 v102 = 739;
LABEL_119:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContainer.c", (uint64_t)"aeaContainerFinish", v102, 28, 0, v101, v84, v85, nbyte);
    char v30 = 0;
    goto LABEL_24;
  }
  long long v86 = *(uint64_t (**)(long long *, uint64_t, size_t *, _OWORD *, char *, rsize_t))(a1 + 160);
  if (!v86
    || (int v87 = v86(&v125, 48, v153, v151, v28, v27), v88 = LODWORD(v153[0]), LODWORD(v153[0]) != *(_DWORD *)(a1 + 84))
    || v87 < 0)
  {
    uint64_t v101 = "Root header encryption";
    __int16 v102 = 745;
    goto LABEL_119;
  }
  uint64_t v89 = *(void *)(a1 + 320);
  long long v90 = &v9[*(void *)(a1 + 328)];
  long long v91 = v126;
  *(_OWORD *)long long v90 = v125;
  *((_OWORD *)v90 + 1) = v91;
  *((_OWORD *)v90 + 2) = v127;
  memcpy(&v9[v89], (char *)v153 + 4, v88);
  memcpy(&v9[*(void *)(a1 + 312)], (const void *)(a1 + 412), *(unsigned int *)(a1 + 408));
  size_t v92 = *(unsigned int *)(a1 + 928);
  if (v92 != *(_DWORD *)(a1 + 120))
  {
    uint64_t v101 = "Invalid encryption data size";
    __int16 v102 = 753;
    goto LABEL_119;
  }
  memcpy(&v9[*(void *)(a1 + 304)], (const void *)(a1 + 932), v92);
  if (!*(_DWORD *)(a1 + 1188) && !*(void *)(a1 + 1712))
  {
LABEL_153:
    long long v113 = *(uint64_t (**)(uint64_t, char *, size_t))(a1 + 272);
    if (v113
      && (int v114 = v113(a1 + 1448, v9, nbyte), *(_DWORD *)(a1 + 1448) == *(_DWORD *)(a1 + 124))
      && (v114 & 0x80000000) == 0)
    {
      if (AAByteStreamPWrite(a2, v9, nbyte, 0) == nbyte)
      {
        char v30 = 0;
        uint64_t v29 = 0;
        goto LABEL_111;
      }
      long long v99 = "writing container headers";
      __int16 v100 = 801;
    }
    else
    {
      long long v99 = "digesting prologue";
      __int16 v100 = 797;
    }
    goto LABEL_125;
  }
  long long v95 = *(uint64_t (**)(_OWORD *, char *, size_t))(a1 + 192);
  if (!v95 || (int v96 = v95(v128, v9, nbyte), LODWORD(v128[0]) != *(_DWORD *)(a1 + 108)) || v96 < 0)
  {
    long long v99 = "digesting prologue";
    __int16 v100 = 760;
LABEL_125:
    int v103 = 0;
    goto LABEL_121;
  }
  long long v97 = *(uint64_t (**)(void, uint64_t, char *, unsigned char *, char *))(a1 + 1712);
  if (!v97)
  {
    long long v104 = *(uint64_t (**)(_OWORD *, uint64_t, _OWORD *))(a1 + 200);
    if (!v104
      || (uint64_t result = v104(v149, a1 + 1188, v128), LODWORD(v149[0]) != *(_DWORD *)(a1 + 112))
      || (result & 0x80000000) != 0)
    {
      long long v99 = "signing prologue";
      __int16 v100 = 779;
      goto LABEL_125;
    }
LABEL_133:
    if (*(_DWORD *)a1)
    {
      memset(&v207[8], 0, 252);
      memset(v206, 0, 260);
      *(_DWORD *)&v207[7] = 1262834527;
      *(void *)uint64_t v207 = 0x5F41454100000007;
      memset_s(&v207[11], 0xF9uLL, 0, 0xF9uLL);
      long long v105 = *(uint64_t (**)(_OWORD *, void, _DWORD *, unsigned char *, _OWORD *))(a1 + 144);
      if (v105 && *v117)
      {
        int v106 = v105(v130, *(unsigned int *)(a1 + 72), v117, v207, v206);
        memset_s(v207, 0x104uLL, 0, 0x104uLL);
        if ((v106 & 0x80000000) == 0)
        {
          if (*(void *)(a1 + 216))
          {
            memset(v206, 0, 260);
            int v205 = 0;
            long long v204 = 0u;
            long long v203 = 0u;
            long long v202 = 0u;
            long long v201 = 0u;
            long long v200 = 0u;
            long long v199 = 0u;
            long long v198 = 0u;
            long long v197 = 0u;
            long long v196 = 0u;
            long long v195 = 0u;
            long long v194 = 0u;
            long long v193 = 0u;
            long long v192 = 0u;
            long long v191 = 0u;
            long long v190 = 0u;
            long long v189 = 0u;
            int v188 = 0;
            long long v187 = 0u;
            long long v186 = 0u;
            long long v185 = 0u;
            long long v184 = 0u;
            long long v183 = 0u;
            long long v182 = 0u;
            long long v181 = 0u;
            long long v180 = 0u;
            long long v179 = 0u;
            long long v178 = 0u;
            long long v177 = 0u;
            long long v176 = 0u;
            long long v175 = 0u;
            long long v174 = 0u;
            long long v173 = 0u;
            *(_OWORD *)unint64_t v172 = 0u;
            if (LODWORD(v149[0]) == *(_DWORD *)(a1 + 112) && LODWORD(v130[0]) == *(_DWORD *)(a1 + 72))
            {
              *(void *)((char *)&v189 + 4) = 0x324B45535F414541;
              LODWORD(v189) = 8;
              memset_s((void *)((unint64_t)&v189 | 0xC), 0xF8uLL, 0, 0xF8uLL);
              memset(v207, 0, sizeof(v207));
              long long v107 = *(uint64_t (**)(_OWORD *, void, _OWORD *, long long *, unsigned char *))(a1 + 144);
              if (v107)
              {
                if (LODWORD(v130[0]))
                {
                  uint64_t result = v107(v206, *(unsigned int *)(a1 + 76), v130, &v189, v207);
                  if ((result & 0x80000000) == 0)
                  {
                    uint64_t v108 = LODWORD(v149[0]);
                    if (LODWORD(v149[0]) >= 0x101) {
                      goto LABEL_162;
                    }
                    __memcpy_chk();
                    LODWORD(v132[0]) = v108;
                    memset_s((char *)v132 + v108 + 4, 256 - v108, 0, 256 - v108);
                    uint64_t result = (*(uint64_t (**)(char *, void, size_t *, _OWORD *, void, void))(a1 + 216))((char *)v132 + 4, LODWORD(v149[0]), v172, v206, 0, 0);
                    if ((result & 0x80000000) == 0)
                    {
                      unint64_t v109 = LODWORD(v132[0]) + (unint64_t)LODWORD(v172[0]);
                      if (v109 >= 0x101) {
                        goto LABEL_162;
                      }
                      memcpy((char *)v132 + LODWORD(v132[0]) + 4, (char *)v172 + 4, LODWORD(v172[0]));
                      LODWORD(v132[0]) = v109;
                      memset_s((char *)v132 + v109 + 4, 256 - v109, 0, 256 - v109);
                      int v110 = v132[0];
                      int v111 = *(_DWORD *)(a1 + 116);
                      memset_s(v206, 0x104uLL, 0, 0x104uLL);
                      memset_s(v172, 0x104uLL, 0, 0x104uLL);
                      memset_s(&v189, 0x104uLL, 0, 0x104uLL);
                      if (v110 != v111) {
                        goto LABEL_161;
                      }
                      goto LABEL_152;
                    }
                  }
                }
              }
            }
            memset_s(v206, 0x104uLL, 0, 0x104uLL);
            memset_s(v172, 0x104uLL, 0, 0x104uLL);
            memset_s(&v189, 0x104uLL, 0, 0x104uLL);
          }
LABEL_161:
          long long v99 = "encrypt signature";
          __int16 v100 = 789;
          goto LABEL_125;
        }
      }
      else
      {
        memset_s(v207, 0x104uLL, 0, 0x104uLL);
      }
      long long v99 = "deriving signature encryption key";
      __int16 v100 = 787;
      goto LABEL_125;
    }
    uint64_t v112 = LODWORD(v149[0]);
    if (LODWORD(v149[0]) >= 0x101) {
      goto LABEL_162;
    }
    __memcpy_chk();
    LODWORD(v132[0]) = v112;
    memset_s((char *)v132 + v112 + 4, 256 - v112, 0, 256 - v112);
LABEL_152:
    memcpy(&v9[*(void *)(a1 + 296)], (char *)v132 + 4, LODWORD(v132[0]));
    goto LABEL_153;
  }
  *(void *)uint64_t v207 = 0;
  uint64_t result = v97(*(void *)(a1 + 1720), 256, (char *)v149 + 4, v207, (char *)v128 + 4);
  if ((result & 0x80000000) != 0)
  {
    long long v99 = "Signing callback";
    __int16 v100 = 772;
    goto LABEL_125;
  }
  unint64_t v98 = *(unsigned int *)(a1 + 112);
  if (*(void *)v207 > v98)
  {
    long long v99 = "Invalid callback size return value";
    __int16 v100 = 773;
    goto LABEL_125;
  }
  if (v98 < 0x101)
  {
    LODWORD(v149[0]) = *(_DWORD *)(a1 + 112);
    uint64_t result = memset_s((char *)v149 + v98 + 4, 256 - v98, 0, 256 - v98);
    goto LABEL_133;
  }
LABEL_162:
  __break(1u);
  return result;
}

void *AAMemoryInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 && a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 132, 68, 0, "Invalid arguments", a7, a8, v17);
    unsigned int v10 = 0;
    uint64_t v11 = 0;
LABEL_8:
    free(v11);
    free(v10);
    return 0;
  }
  unsigned int v10 = calloc(1uLL, 0x68uLL);
  uint64_t v12 = malloc(0x20uLL);
  uint64_t v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    uint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 137, 68, *v13, "malloc", v14, v15, v17);
    goto LABEL_8;
  }
  *uint64_t v11 = a1;
  v11[1] = a2;
  *unsigned int v10 = v11;
  v10[1] = memoryInputStreamClose;
  v10[7] = memoryInputStreamCancel;
  v10[2] = memoryInputStreamRead;
  v10[4] = memoryInputStreamPRead;
  v10[6] = memoryInputStreamSeek;
  return v10;
}

uint64_t memoryInputStreamClose(void *a1)
{
  return 0;
}

void memoryInputStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v1, 1u);
}

size_t memoryInputStreamRead(uint64_t a1, void *a2, unint64_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 24))) {
    return -1;
  }
  else {
    return memoryInputStreamPRead(a1, a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 16), a3));
  }
}

size_t memoryInputStreamPRead(uint64_t a1, void *__dst, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = atomic_load((unsigned int *)(a1 + 24));
  size_t v5 = -1;
  if ((a4 & 0x8000000000000000) == 0 && !v4)
  {
    unint64_t v6 = *(void *)(a1 + 8);
    unint64_t v7 = (uint64_t)v6 >= a4 ? a4 : *(void *)(a1 + 8);
    if (!__CFADD__(v7, a3))
    {
      if (v7 + a3 < v6) {
        unint64_t v6 = v7 + a3;
      }
      size_t v5 = v6 - v7;
      if (v6 <= v7) {
        return 0;
      }
      else {
        memcpy(__dst, (const void *)(*(void *)a1 + v7), v5);
      }
    }
  }
  return v5;
}

uint64_t memoryInputStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  if (!atomic_load((unsigned int *)(a1 + 24)))
  {
    if (a3)
    {
      if (a3 == 1)
      {
        a2 += atomic_fetch_add((atomic_ullong *volatile)(a1 + 16), a2);
        return a2;
      }
      if (a3 != 2) {
        return -1;
      }
      a2 += *(void *)(a1 + 8);
    }
    atomic_store(a2, (unint64_t *)(a1 + 16));
    return a2;
  }
  return -1;
}

void *AAMemoryOutputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 && a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamOpen", 169, 68, 0, "Invalid arguments", a7, a8, v17);
    unsigned int v10 = 0;
    uint64_t v11 = 0;
LABEL_8:
    free(v11);
    free(v10);
    return 0;
  }
  unsigned int v10 = calloc(1uLL, 0x68uLL);
  uint64_t v12 = malloc(0x20uLL);
  uint64_t v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    uint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamOpen", 174, 68, *v13, "malloc", v14, v15, v17);
    goto LABEL_8;
  }
  v11[1] = 0;
  v11[2] = a2;
  *uint64_t v11 = a1;
  *unsigned int v10 = v11;
  v10[1] = memoryOutputStreamClose;
  v10[7] = memoryOutputStreamCancel;
  v10[3] = memoryOutputStreamWrite;
  return v10;
}

uint64_t memoryOutputStreamClose(void *a1)
{
  return 0;
}

void memoryOutputStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v1, 1u);
}

size_t memoryOutputStreamWrite(void *a1, const void *a2, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = __n;
  if (__n)
  {
    uint64_t v10 = a1[1];
    size_t v11 = v10 + __n;
    if (__CFADD__(v10, __n))
    {
      uint64_t v12 = "invalid size";
      __int16 v13 = 102;
    }
    else
    {
      if (v11 <= a1[2])
      {
        memcpy((void *)(*a1 + v10), a2, __n);
        a1[1] = v11;
        return v8;
      }
      uint64_t v12 = "buffer full";
      __int16 v13 = 103;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"memoryOutputStreamWrite", v13, 68, 0, v12, a7, a8, v15);
    return -1;
  }
  return v8;
}

uint64_t AAMemoryOutputStreamCloseWithSize(uint64_t (**a1)(void *a1), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  if (a1[1] == memoryOutputStreamClose)
  {
    uint64_t v9 = *((void *)*a1 + 1);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamCloseWithSize", 201, 68, 0, "invalid stream type", a7, a8, v13);
    uint64_t v9 = -1;
  }
  if (AAByteStreamClose((AAByteStream)a1) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryOutputStreamCloseWithSize", 207, 68, 0, "close stream", v10, v11, v13);
    return -1;
  }
  return v9;
}

AAByteStream_impl *aaForkOutputStreamOpen(uint64_t a1, void *a2)
{
  unsigned int v4 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  size_t v5 = calloc(1uLL, 0x20050uLL);
  size_t v8 = v5;
  if (!v4 || !v5)
  {
    int v17 = *__error();
    unint64_t v18 = "malloc";
    __int16 v19 = 405;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", v19, 136, v17, v18, v6, v7, v38);
    goto LABEL_14;
  }
  if (!*(void *)(a1 + 40) || !*(void *)(a1 + 32))
  {
    unint64_t v18 = "stream not compatible\n";
    __int16 v19 = 406;
    int v17 = 0;
    goto LABEL_13;
  }
  uint64_t v9 = v5 + 16385;
  AACustomByteStreamSetData(v4, v5);
  AACustomByteStreamSetWriteProc(v4, (AAByteStreamWriteProc)ForkOutputStreamWrite);
  AACustomByteStreamSetPWriteProc(v4, (AAByteStreamPWriteProc)ForkOutputStreamPWrite);
  AACustomByteStreamSetCancelProc(v4, (AAByteStreamCancelProc)ForkOutputStreamCancel);
  AACustomByteStreamSetCloseProc(v4, (AAByteStreamCloseProc)ForkOutputStreamClose);
  *uint64_t v9 = a1;
  v8[16386] = a2;
  if (a2[258]) {
    size_t v10 = a2[270] + 1;
  }
  else {
    size_t v10 = a2[270];
  }
  v8[16390] = v10;
  if (is_mul_ok(v10, 0x30uLL) && 48 * v10 < 0x2000000001)
  {
    uint64_t v16 = calloc(v10, 0x30uLL);
  }
  else
  {
    char v13 = __error();
    uint64_t v16 = 0;
    *char v13 = 12;
  }
  v8[16389] = v16;
  *(_OWORD *)(v8 + 16391) = 0u;
  *((_DWORD *)v8 + 32786) = 0;
  if (!v16)
  {
    int v17 = *__error();
    unint64_t v18 = "aaCalloc";
    __int16 v19 = 423;
    goto LABEL_13;
  }
  uint64_t v28 = 0;
  uint64_t v29 = a2[270];
  uint64_t v30 = a2[258];
  char v31 = 1;
  __int16 v32 = v16;
  while (1)
  {
    if (v29)
    {
      uint64_t v33 = (void *)a2[268];
      for (uint64_t i = v29; i; --i)
      {
        uint64_t v35 = v33[51];
        if (v31)
        {
          if (v35)
          {
            *__int16 v32 = v33;
            v32[1] = v28;
            int64_t v36 = (void *)v33[48];
            uint64_t v37 = v33[49];
            v32[2] = 0;
            v32[3] = v37;
            v32[4] = *v36;
LABEL_26:
            v32[5] = v33[5];
            v28 += v37;
            v8[16392] = v28;
            v32 += 6;
          }
        }
        else if ((v35 & 2) != 0)
        {
          v32[1] = v28;
          v32[2] = 0;
          uint64_t v37 = v33[4];
          v32[3] = v37;
          goto LABEL_26;
        }
        v33 += 55;
      }
    }
    if ((v31 & 1) == 0) {
      break;
    }
    char v31 = 0;
    uint64_t v14 = v28;
    uint64_t v15 = v28;
    if (v30)
    {
      char v31 = 0;
      v32[1] = v28;
      v32[2] = 0;
      v32[3] = v30;
      v32[5] = 0;
      uint64_t v14 = v30 + v28;
      v32 += 6;
      uint64_t v15 = v28;
      uint64_t v28 = v14;
      v8[16392] = v14;
    }
  }
  a2[257] = v15;
  a2[259] = v14;
  if (v32 == &v16[6 * v8[16390]])
  {
    a2[260] = v28;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", 477, 136, 0, "bad variant", v11, v12, v38);
    a2[260] = v8[16392];
LABEL_14:
    free(v4);
    ForkOutputStreamClose((void **)v8, v20, v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return v4;
}

uint64_t ForkOutputStreamWrite(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = (void **)(a1 + 32770);
  if (a1[32786])
  {
    uint64_t v9 = "bad write mode";
    __int16 v10 = 198;
    goto LABEL_3;
  }
  unint64_t v11 = a3;
  if (!a3) {
    return v11;
  }
  char v13 = (const uint8_t *)a1;
  unint64_t v14 = 0;
  dst_buffer = (uint8_t *)a1 + 65537;
  __dst = (char *)a1 + 65538;
  long long v155 = a1 + 32770;
  while (1)
  {
    uint64_t v15 = v8[6];
    if (v15 == v8[5])
    {
      uint64_t v9 = "segment out of range";
      __int16 v10 = 202;
      goto LABEL_3;
    }
    int v153 = v8[4];
    uint64_t v16 = &v153[6 * (void)v15];
    unint64_t v18 = v16 + 2;
    size_t v17 = v16[2];
    unint64_t v19 = v11 - v14;
    uint64_t v21 = v16 + 3;
    size_t v20 = v16[3];
    if (v11 - v14 >= 0x10000 - (unint64_t)(unsigned __int16)v17) {
      unint64_t v19 = 0x10000 - (unsigned __int16)v17;
    }
    if (v20 - v17 >= v19) {
      size_t v22 = v19;
    }
    else {
      size_t v22 = v20 - v17;
    }
    memcpy((void *)&v13[(unsigned __int16)v17], (const void *)(a2 + v14), v22);
    size_t v23 = v22 + *v18;
    int v152 = v16 + 2;
    *unint64_t v18 = v23;
    uint64_t v149 = v16 + 3;
    size_t v24 = *v21;
    if (v23 == *v21) {
      v8[6] = (void *)((char *)v8[6] + 1);
    }
    size_t v25 = (unsigned __int16)v23;
    if ((_WORD)v23)
    {
      if (v23 < v24) {
        goto LABEL_134;
      }
    }
    else
    {
      size_t v25 = 0x10000;
    }
    size_t v150 = v22;
    uint64_t v26 = (void *)*v16;
    if (!*v16)
    {
      uint64_t v30 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        uint64_t v31 = 0;
        size_t v32 = v23 - v25 + v153[6 * (void)v15 + 5];
        uint64_t v33 = a1;
        size_t v34 = v25;
        while (1)
        {
          uint64_t v35 = (*(uint64_t (**)(void, _DWORD *, size_t, size_t))(v30 + 40))(*(void *)v30, v33, v34, v32);
          if (v35 < 1) {
            break;
          }
          uint64_t v33 = (_DWORD *)((char *)v33 + v35);
          v31 += v35;
          v32 += v35;
          v34 -= v35;
          if (!v34) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = v35;
      }
      else
      {
        uint64_t v31 = -1;
      }
LABEL_85:
      BOOL v87 = v25 == v31;
      size_t v8 = (void **)v155;
      char v13 = (const uint8_t *)a1;
      size_t v22 = v150;
      if (!v87)
      {
        uint64_t v9 = "aaByteStreamPWriteExpected";
        __int16 v10 = 230;
        goto LABEL_3;
      }
      goto LABEL_134;
    }
    unint64_t v27 = v26[7];
    unint64_t v145 = v14;
    int v148 = &v153[6 * (void)v15];
    if ((unint64_t)v8[3] < v27)
    {
      v8[3] = (void *)v27;
      if (24 * v27 >= 0x2000000001)
      {
        *__error() = 12;
      }
      else
      {
        uint64_t v28 = v8[2];
        uint64_t v29 = realloc(v28, 24 * v27);
        if (v29)
        {
          v8[2] = v29;
          size_t v23 = *v152;
          goto LABEL_30;
        }
        free(v28);
      }
      v8[2] = 0;
      uint64_t v9 = "aaReallocf";
      __int16 v10 = 240;
      goto LABEL_3;
    }
    uint64_t v29 = v8[2];
LABEL_30:
    unint64_t v36 = (v23 - 1) >> 16;
    uint64_t v37 = v26[48] + 12 * v36;
    unint64_t v156 = v36;
    char v38 = &v29[3 * v36];
    size_t v39 = compression_encode_buffer(dst_buffer, 0x10000uLL, v13, v25, 0, (compression_algorithm)LODWORD(v8[1][*((unsigned __int8 *)v26 + 432)]));
    if (v39 - 1 >= v25) {
      size_t v40 = v25 + 1;
    }
    else {
      size_t v40 = v39;
    }
    v38[1] = v40;
    __int16 v41 = v38 + 1;
    long long v144 = v38;
    v38[2] = v40;
    uint64_t v42 = v38 + 2;
    int v43 = &v153[6 * (void)v15];
    uint64_t v44 = v43[4];
    long long v157 = v43 + 4;
    size_t v45 = *(void *)v37 + *(unsigned int *)(v37 + 8);
    size_t v46 = v40;
    if (v44 + v40 < v45)
    {
      size_t v46 = v45 - v44;
      size_t *v42 = v45 - v44;
    }
    if (v46 == v25 + 1)
    {
      *__int16 v41 = v25 + 1;
      uint8_t *dst_buffer = BYTE4(v8[1][*((unsigned __int8 *)v26 + 432)]);
      memcpy(__dst, a1, v25);
      size_t v40 = *v41;
      size_t v46 = *v42;
    }
    bzero(&dst_buffer[v40], v46 - v40);
    uint64_t v47 = v26[50];
    uint64_t v48 = *v157;
    unint64_t v49 = v47 - *v157;
    unint64_t v50 = *v42 - v49;
    long long v147 = v15;
    if (*v42 > v49) {
      break;
    }
LABEL_76:
    *long long v144 = v48;
    size_t v80 = *v42;
    uint64_t v81 = (uint64_t)*v8;
    if ((*v8)[5])
    {
      if (!v80) {
        goto LABEL_89;
      }
      uint64_t v82 = 0;
      uint64_t v83 = v153[6 * (void)v15 + 5] + v48;
      uint64_t v84 = dst_buffer;
      size_t v85 = *v42;
      while (1)
      {
        uint64_t v86 = (*(uint64_t (**)(void, uint8_t *, size_t, uint64_t))(v81 + 40))(*(void *)v81, v84, v85, v83);
        if (v86 < 1) {
          break;
        }
        v84 += v86;
        v82 += v86;
        v83 += v86;
        v85 -= v86;
        if (!v85) {
          goto LABEL_88;
        }
      }
      uint64_t v82 = v86;
    }
    else
    {
      uint64_t v82 = -1;
    }
LABEL_88:
    size_t v8 = (void **)v155;
    uint64_t v15 = v147;
    uint64_t v16 = v148;
    if (v80 != v82)
    {
      uint64_t v9 = "aaByteStreamPWriteExpected";
      __int16 v10 = 287;
      goto LABEL_3;
    }
LABEL_89:
    *v157 += v80;
    size_t v22 = v150;
    char v13 = (const uint8_t *)a1;
    unint64_t v14 = v145;
    if (*v152 == *v149)
    {
      size_t v88 = (void *)*v16;
      uint64_t v89 = *(void *)(*v16 + 408);
      uint64_t v90 = *(void *)(*v16 + 56);
      uint64_t v91 = 2 * v90;
      if ((v89 & 4) == 0) {
        uint64_t v91 = v90 + 1;
      }
      size_t v92 = 4 * v91;
      if ((unint64_t)(4 * v91) >= 0x2000000001)
      {
        *__error() = 12;
LABEL_148:
        long long v135 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", 81, 136, *v135, "aaMalloc", v136, v137, v138);
        int v96 = 0;
        goto LABEL_142;
      }
      uint64_t v93 = malloc(v92);
      if (!v93) {
        goto LABEL_148;
      }
      int v96 = v93;
      if ((v89 & 4) != 0)
      {
        uint64_t v107 = (uint64_t)*v8;
        if ((*v8)[5])
        {
          uint64_t v108 = 0;
          unint64_t v109 = &v153[6 * (void)v147 + 5];
          int v110 = v88 + 41;
          uint64_t v111 = *v109 + v88[50] - 50;
          uint64_t v112 = 50;
          while (1)
          {
            uint64_t v113 = (*(uint64_t (**)(void, void *, uint64_t, uint64_t))(v107 + 40))(*(void *)v107, v110, v112, v111);
            if (v113 < 1) {
              break;
            }
            int v110 = (void *)((char *)v110 + v113);
            v108 += v113;
            v111 += v113;
            v112 -= v113;
            if (!v112)
            {
              if (v108 != 50) {
                break;
              }
              int v114 = (void *)*v155;
              if (*(void *)(*v155 + 40))
              {
                uint64_t v115 = 0;
                long long v116 = v88 + 8;
                uint64_t v117 = *v109;
                uint64_t v118 = 264;
                while (1)
                {
                  uint64_t v119 = ((uint64_t (*)(void, void *, uint64_t, uint64_t))v114[5])(*v114, v116, v118, v117);
                  if (v119 < 1) {
                    break;
                  }
                  long long v116 = (void *)((char *)v116 + v119);
                  v115 += v119;
                  v117 += v119;
                  v118 -= v119;
                  if (!v118)
                  {
                    if (v115 != 264) {
                      break;
                    }
                    uint64_t v120 = v88[7];
                    size_t v8 = (void **)v155;
                    if (v120)
                    {
                      int v121 = (void *)(v155[2] + 16);
                      unint64_t v122 = v96 + 1;
                      do
                      {
                        *(v122 - 1) = *((_DWORD *)v121 - 4) - 260;
                        uint64_t v123 = *v121;
                        v121 += 3;
                        *unint64_t v122 = v123;
                        v122 += 2;
                        --v120;
                      }
                      while (v120);
                    }
                    uint64_t v101 = *v109 + 264;
                    unint64_t v14 = v145;
                    goto LABEL_99;
                  }
                }
              }
              long long v133 = "aaByteStreamPWriteExpected";
              __int16 v134 = 94;
              goto LABEL_141;
            }
          }
        }
        long long v133 = "aaByteStreamPWriteExpected";
        __int16 v134 = 89;
LABEL_141:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", v134, 136, 0, v133, v94, v95, v138);
LABEL_142:
        free(v96);
        uint64_t v9 = "fork_write_index";
        __int16 v10 = 294;
        goto LABEL_3;
      }
      if (v90)
      {
        long long v97 = v93 + 1;
        unint64_t v98 = (int *)(v8[2] + 2);
        do
        {
          int v99 = *(v98 - 4);
          *(v97 - 1) = v99;
          int v100 = *v98;
          v98 += 6;
          *v97++ = v100 + v99;
          --v90;
        }
        while (v90);
      }
      uint64_t v101 = v153[6 * (void)v15 + 5];
      unint64_t v14 = v145;
LABEL_99:
      uint64_t v102 = (uint64_t)*v8;
      if (!(*v8)[5]) {
        goto LABEL_149;
      }
      if (v92)
      {
        uint64_t v103 = 0;
        long long v104 = v96;
        size_t v105 = v92;
        while (1)
        {
          uint64_t v106 = (*(uint64_t (**)(void, _DWORD *, size_t, uint64_t))(v102 + 40))(*(void *)v102, v104, v105, v101);
          if (v106 < 1) {
            break;
          }
          long long v104 = (_DWORD *)((char *)v104 + v106);
          v103 += v106;
          v101 += v106;
          v105 -= v106;
          if (!v105) {
            goto LABEL_120;
          }
        }
        uint64_t v103 = v106;
LABEL_120:
        BOOL v87 = v92 == v103;
        size_t v8 = (void **)v155;
        unint64_t v14 = v145;
        if (!v87)
        {
LABEL_149:
          long long v133 = "aaByteStreamPWriteExpected";
          __int16 v134 = 117;
          goto LABEL_141;
        }
      }
      uint64_t v124 = v88[4];
      uint64_t v125 = v88[50];
      unint64_t v126 = v124 - v125;
      if (v124 != v125)
      {
        if (v126 >= 0x1000)
        {
          long long v133 = "too much padding";
          __int16 v134 = 123;
          goto LABEL_141;
        }
        bzero(dst_buffer, v124 - v125);
        uint64_t v127 = (uint64_t)*v8;
        if (!(*v8)[5]) {
          goto LABEL_150;
        }
        if (v126)
        {
          uint64_t v128 = 0;
          uint64_t v129 = v153[6 * (void)v147 + 5] + v88[50];
          long long v130 = dst_buffer;
          unint64_t v131 = v126;
          while (1)
          {
            uint64_t v132 = (*(uint64_t (**)(void, uint8_t *, unint64_t, uint64_t))(v127 + 40))(*(void *)v127, v130, v131, v129);
            if (v132 < 1) {
              break;
            }
            v130 += v132;
            v128 += v132;
            v129 += v132;
            v131 -= v132;
            if (!v131) {
              goto LABEL_131;
            }
          }
          uint64_t v128 = v132;
LABEL_131:
          BOOL v87 = v126 == v128;
          size_t v8 = (void **)v155;
          unint64_t v14 = v145;
          if (!v87)
          {
LABEL_150:
            long long v133 = "aaByteStreamPWriteExpected";
            __int16 v134 = 126;
            goto LABEL_141;
          }
        }
      }
      free(v96);
      unint64_t v11 = a3;
      char v13 = (const uint8_t *)a1;
      size_t v22 = v150;
    }
LABEL_134:
    v14 += v22;
    if (v14 >= v11) {
      return v11;
    }
  }
  int v51 = v153 + 48 * v15 + 40;
  long long v154 = &v153[6 * (void)v15 + 5];
  unint64_t v52 = v156;
  long long v140 = v42;
  do
  {
    if (!v52)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", 142, 136, 0, "realignment failed", a7, a8, v138);
      goto LABEL_139;
    }
    int v53 = v8[2];
    __int16 v54 = &v53[3 * v52 - 3];
    uint64_t v57 = v54[2];
    unint64_t v55 = v54 + 2;
    uint64_t v56 = v57;
    uint64_t v58 = *(v55 - 1);
    unint64_t v59 = v57 - v58;
    unint64_t v60 = v50 - (v57 - v58);
    if (v50 > v57 - v58)
    {
      *unint64_t v55 = v58;
      --v52;
      goto LABEL_73;
    }
    *unint64_t v55 = v56 - v50;
    uint64_t v48 = v53[3 * v52 - 3] + v56 - v50;
    uint64_t *v157 = v48;
    if (v52 >= v156) {
      goto LABEL_76;
    }
    unint64_t v141 = v59;
    unint64_t v142 = v50;
    while (1)
    {
      uint64_t v61 = &v8[2][3 * v52];
      uint64_t v62 = *v154;
      uint64_t v63 = v61[1];
      uint64_t v64 = *v61 + *v154;
      uint64_t v65 = (uint64_t)*v8;
      if ((*v8)[11])
      {
        if (v63 != aaByteStreamSimulate(*v8))
        {
          __int16 v77 = 173;
          uint64_t v78 = "aaByteStreamSimulate";
          goto LABEL_72;
        }
        goto LABEL_59;
      }
      if (*(void *)(v65 + 32))
      {
        if (!v63)
        {
          if (!*(void *)(v65 + 40)) {
            goto LABEL_70;
          }
          goto LABEL_68;
        }
        uint64_t v66 = 0;
        int v67 = a1;
        uint64_t v68 = v61[1];
        while (1)
        {
          uint64_t v69 = (*(uint64_t (**)(void, _DWORD *, uint64_t, uint64_t))(v65 + 32))(*(void *)v65, v67, v68, v64);
          if (v69 < 0) {
            break;
          }
          if (v69)
          {
            int v67 = (_DWORD *)((char *)v67 + v69);
            v66 += v69;
            v64 += v69;
            v68 -= v69;
            if (v68) {
              continue;
            }
          }
          goto LABEL_58;
        }
        uint64_t v66 = v69;
      }
      else
      {
        uint64_t v66 = -1;
      }
LABEL_58:
      size_t v8 = (void **)v155;
      if (v63 != v66) {
        break;
      }
LABEL_59:
      uint64_t v70 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        if (!v63) {
          goto LABEL_68;
        }
        uint64_t v71 = 0;
        uint64_t v72 = v62 + v48;
        uint64_t v73 = a1;
        uint64_t v74 = v63;
        while (1)
        {
          uint64_t v75 = (*(uint64_t (**)(void, _DWORD *, uint64_t, uint64_t))(v70 + 40))(*(void *)v70, v73, v74, v72);
          if (v75 < 1) {
            break;
          }
          uint64_t v73 = (_DWORD *)((char *)v73 + v75);
          v71 += v75;
          v72 += v75;
          v74 -= v75;
          if (!v74) {
            goto LABEL_67;
          }
        }
        uint64_t v71 = v75;
      }
      else
      {
        uint64_t v71 = -1;
      }
LABEL_67:
      size_t v8 = (void **)v155;
      if (v63 != v71)
      {
LABEL_70:
        __int16 v77 = 180;
        uint64_t v78 = "aaByteStreamPWriteExpected";
        goto LABEL_72;
      }
LABEL_68:
      uint64_t v76 = *v157;
      *uint64_t v61 = *v157;
      uint64_t v48 = v76 + v63;
      uint64_t *v157 = v76 + v63;
      if (++v52 == v156) {
        goto LABEL_75;
      }
    }
    __int16 v77 = 176;
    uint64_t v78 = "aaByteStreamPReadExpected";
LABEL_72:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", v77, 136, 0, v78, a7, a8, v138);
    int v51 = -1;
    unint64_t v50 = v142;
    unint64_t v11 = a3;
    unint64_t v60 = v142;
    uint64_t v15 = v147;
    uint64_t v16 = v148;
    uint64_t v42 = v140;
    unint64_t v59 = v141;
LABEL_73:
    BOOL v79 = v50 > v59;
    unint64_t v50 = v60;
  }
  while (v79);
  if ((v51 & 0x80000000) == 0)
  {
LABEL_75:
    uint64_t v48 = *v157;
    unint64_t v11 = a3;
    uint64_t v15 = v147;
    uint64_t v16 = v148;
    uint64_t v42 = v140;
    goto LABEL_76;
  }
LABEL_139:
  uint64_t v9 = "realign_fork";
  __int16 v10 = 279;
LABEL_3:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamWrite", v10, 136, 0, v9, a7, a8, v138);
  return -1;
}

uint64_t ForkOutputStreamPWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a4;
  uint64_t v9 = (uint64_t *)(a1 + 131080);
  if (*(_DWORD *)(a1 + 131144)) {
    goto LABEL_2;
  }
  uint64_t v25 = a1;
  uint64_t v26 = *(void *)(a1 + 131112);
  uint64_t v27 = *(void *)(a1 + 131128);
  uint64_t v28 = (void *)(v26 + 48 * v27);
  uint64_t v29 = v28[2];
  if (v29 + v28[1] != a4)
  {
    uint64_t v31 = (unsigned __int16)v28[2];
    if ((unsigned __int16)v28[2])
    {
      if (*v28)
      {
        size_t v32 = "pending compressed fork";
        __int16 v33 = 323;
        goto LABEL_50;
      }
      uint64_t v34 = *v9;
      if (!*(void *)(*v9 + 40)) {
        goto LABEL_49;
      }
      unint64_t v35 = a3;
      uint64_t v36 = 0;
      unint64_t v37 = (v29 & 0xFFFFFFFFFFFF0000) + *(void *)(v26 + 48 * v27 + 40);
      uint64_t v38 = (unsigned __int16)v28[2];
      while (1)
      {
        uint64_t v39 = (*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t))(v34 + 40))(*(void *)v34, v25, v38, v37);
        if (v39 < 1) {
          break;
        }
        v25 += v39;
        v36 += v39;
        v37 += v39;
        v38 -= v39;
        if (!v38) {
          goto LABEL_47;
        }
      }
      uint64_t v36 = v39;
LABEL_47:
      a3 = v35;
      if (v31 != v36)
      {
LABEL_49:
        size_t v32 = "aaByteStreamPWriteExpected";
        __int16 v33 = 325;
LABEL_50:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamPWrite", v33, 136, 0, v32, a7, a8, a2);
        return -1;
      }
    }
    *((_DWORD *)v9 + 16) = 1;
LABEL_2:
    unint64_t v10 = 0;
    if (a3)
    {
      unint64_t v41 = a3;
      while (1)
      {
        if (v9[7] <= v8)
        {
LABEL_37:
          size_t v32 = "no segment found";
          __int16 v33 = 340;
          goto LABEL_50;
        }
        uint64_t v11 = v9[4];
        unint64_t v12 = v9[5];
        if (v12 < 2)
        {
          if (!v11) {
            goto LABEL_37;
          }
          uint64_t v13 = 0;
        }
        else
        {
          uint64_t v13 = 0;
          do
          {
            if (*(void *)(v11 + 48 * ((v13 + v12) >> 1) + 8) > v8) {
              unint64_t v12 = (v13 + v12) >> 1;
            }
            else {
              uint64_t v13 = (v13 + v12) >> 1;
            }
          }
          while (v13 + 1 < v12);
        }
        if (*(void *)(v11 + 48 * v13))
        {
          size_t v32 = "compressed fork";
          __int16 v33 = 341;
          goto LABEL_50;
        }
        unint64_t v14 = (void *)(v11 + 48 * v13);
        unint64_t v15 = v8 - v14[1];
        unint64_t v16 = v14[3];
        if (a3 - v10 >= v16 - v15) {
          unint64_t v17 = v16 - v15;
        }
        else {
          unint64_t v17 = a3 - v10;
        }
        unint64_t v18 = v17 + v14[2];
        v14[2] = v18;
        if (v18 > v16)
        {
          size_t v32 = "too much data";
          __int16 v33 = 349;
          goto LABEL_50;
        }
        uint64_t v19 = *v9;
        if (*(void *)(*v9 + 40))
        {
          if (!v17) {
            goto LABEL_28;
          }
          uint64_t v20 = 0;
          unint64_t v21 = a2 + v10;
          unint64_t v22 = *(void *)(v11 + 48 * v13 + 40) + v15;
          unint64_t v23 = v17;
          while (1)
          {
            uint64_t v24 = (*(uint64_t (**)(void, unint64_t, unint64_t, unint64_t))(v19 + 40))(*(void *)v19, v21, v23, v22);
            if (v24 < 1) {
              break;
            }
            v21 += v24;
            v20 += v24;
            v22 += v24;
            v23 -= v24;
            if (!v23) {
              goto LABEL_27;
            }
          }
          uint64_t v20 = v24;
        }
        else
        {
          uint64_t v20 = -1;
        }
LABEL_27:
        a3 = v41;
        if (v17 != v20)
        {
          size_t v32 = "aaByteStreamPWriteExpected";
          __int16 v33 = 353;
          goto LABEL_50;
        }
LABEL_28:
        v8 += v17;
        v10 += v17;
        if (v10 >= a3) {
          return v10;
        }
      }
    }
    return v10;
  }

  return ForkOutputStreamWrite((_DWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
}

void ForkOutputStreamCancel(uint64_t a1)
{
}

uint64_t ForkOutputStreamClose(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v9 = a1 + 16387;
    unint64_t v10 = a1[16389];
    if (v10)
    {
      uint64_t v11 = (char *)v9[3];
      if (v11)
      {
        unint64_t v12 = v10 + 3;
        while (*(v12 - 1) == *v12)
        {
          v12 += 6;
          if (!--v11) {
            goto LABEL_7;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamClose", 382, 136, 0, "data missing", a7, a8, v15);
        int v13 = 0;
        unint64_t v10 = v9[2];
      }
      else
      {
LABEL_7:
        int v13 = 1;
      }
      free(v10);
    }
    else
    {
      int v13 = 1;
    }
    free(*v9);
    free(a1);
  }
  else
  {
    int v13 = 1;
  }
  if (v13) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t BlobBufferStore(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  size_t v8 = *(void *)(a1 + 8) + a3;
  if ((BlobBufferIncreaseCapacity(a1, v8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferStore", 19, 6, 0, "BlobBufferStore", v9, v10, v12);
    return 0xFFFFFFFFLL;
  }
  else
  {
    if (a2) {
      memcpy((void *)(*(void *)(a1 + 16) + *(void *)(a1 + 8)), a2, a3);
    }
    if (a4)
    {
      *a4 = *(void *)(a1 + 8);
      a4[1] = a3;
    }
    uint64_t result = 0;
    *(void *)(a1 + 8) = v8;
  }
  return result;
}

uint64_t BlobBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  size_t v2 = *(void *)a1;
  if (*(void *)a1 >= a2) {
    return 0;
  }
  do
  {
    uint64_t v4 = v2 + (v2 >> 1);
    if (__CFADD__(v2, v2 >> 1)) {
      uint64_t v4 = -1;
    }
    if (v2) {
      size_t v2 = v4;
    }
    else {
      size_t v2 = 0x10000;
    }
  }
  while (v2 < a2);
  size_t v5 = reallocf(*(void **)(a1 + 16), v2);
  *(void *)(a1 + 16) = v5;
  if (v5)
  {
    uint64_t result = 0;
    *(void *)a1 = v2;
  }
  else
  {
    uint64_t v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferIncreaseCapacity", 58, 6, *v7, "malloc", v8, v9, v10);
    return 0xFFFFFFFFLL;
  }
  return result;
}

void BlobBufferFree(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
}

void *StringTableCreate()
{
  uint64_t v0 = calloc(1uLL, 0x28uLL);
  if (!v0)
  {
    int v1 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableCreate", 30, 35, *v1, "malloc", v2, v3, v5);
  }
  return v0;
}

uint64_t stringTableReserve(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2) {
    return 0;
  }
  unsigned int v4 = v2 ? v2 + (v2 >> 1) : 32;
  if (v4 <= a2) {
    unsigned int v4 = a2;
  }
  *(_DWORD *)(a1 + 4) = v4;
  char v5 = reallocf(*(void **)(a1 + 8), 16 * v4);
  *(void *)(a1 + 8) = v5;
  if (v5) {
    return 0;
  }
  uint64_t v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"stringTableReserve", 23, 35, *v7, "malloc", v8, v9, v10);
  return 0xFFFFFFFFLL;
}

void StringTableDestroy(void **a1)
{
  if (a1)
  {
    BlobBufferFree((uint64_t)(a1 + 2));
    free(a1[1]);
    free(a1);
  }
}

uint64_t StringTableClear(uint64_t result)
{
  *(void *)(result + 24) = 0;
  *(_DWORD *)uint64_t result = 0;
  return result;
}

uint64_t StringTableAppend(unsigned int *a1, const void *a2, size_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    *a4 = *a1;
  }
  if (HIDWORD(a3))
  {
    uint64_t v11 = "string too long for StringTable";
    __int16 v12 = 74;
  }
  else if (stringTableReserve((uint64_t)a1, *a1 + 1))
  {
    uint64_t v11 = "increasing string table capacity";
    __int16 v12 = 77;
  }
  else
  {
    v17[0] = 0;
    v17[1] = 0;
    if (!BlobBufferStore((uint64_t)(a1 + 4), 0, a3 + 1, v17))
    {
      uint64_t v14 = *((void *)a1 + 1) + 16 * *a1;
      uint64_t v15 = v17[0];
      *(void *)uint64_t v14 = v17[0];
      *(_DWORD *)(v14 + 8) = a3;
      unint64_t v16 = (void *)(*((void *)a1 + 4) + v15);
      memcpy(v16, a2, a3);
      uint64_t result = 0;
      *((unsigned char *)v16 + a3) = 0;
      ++*a1;
      return result;
    }
    uint64_t v11 = "insertion failed in string table";
    __int16 v12 = 81;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppend", v12, 35, 0, v11, a7, a8, v17[0]);
  return 0xFFFFFFFFLL;
}

uint64_t StringTableAppendTable(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  if (a3) {
    *a3 = *(_DWORD *)a1;
  }
  if (!*a2) {
    return 0;
  }
  if (stringTableReserve(a1, *(_DWORD *)a1 + *a2))
  {
    uint64_t v7 = "increasing string table capacity";
    __int16 v8 = 152;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppendTable", v8, 35, 0, v7, v5, v6, v15[0]);
    return 0xFFFFFFFFLL;
  }
  v15[0] = 0;
  v15[1] = 0;
  if (BlobBufferStore(a1 + 16, *((const void **)a2 + 4), *((void *)a2 + 3), v15))
  {
    uint64_t v7 = "increasing blob capacity failed";
    __int16 v8 = 156;
    goto LABEL_9;
  }
  if (*a2)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    uint64_t v12 = *(void *)(a1 + 8);
    do
    {
      unsigned int v13 = v11 + *(_DWORD *)a1;
      *(_OWORD *)(v12 + 16 * v13) = *(_OWORD *)(*((void *)a2 + 1) + v10);
      uint64_t v12 = *(void *)(a1 + 8);
      *(void *)(v12 + 16 * v13) += v15[0];
      ++v11;
      unint64_t v14 = *a2;
      v10 += 16;
    }
    while (v11 < v14);
  }
  else
  {
    LODWORD(v14) = 0;
  }
  uint64_t result = 0;
  *(_DWORD *)a1 += v14;
  return result;
}

size_t StringTableSort(unsigned int *a1, void *a2)
{
  size_t result = *a1;
  if (result)
  {
    if (a2)
    {
      uint64_t v5 = calloc(result, 4uLL);
      if (!v5)
      {
        unsigned int v13 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableSort", 195, 35, *v13, "malloc", v14, v15, v16);
        return 0xFFFFFFFFLL;
      }
      uint64_t v6 = v5;
      *a2 = v5;
      size_t result = *a1;
      if (result)
      {
        uint64_t v7 = 0;
        __int16 v8 = (_DWORD *)(*((void *)a1 + 1) + 12);
        do
        {
          *__int16 v8 = v7;
          v8 += 4;
          ++v7;
        }
        while (result != v7);
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    qsort_r(*((void **)a1 + 1), result, 0x10uLL, a1, (int (__cdecl *)(void *, const void *, const void *))stringTableIndexCompareProc);
    if (*a1 < 2)
    {
      unsigned int v11 = 1;
    }
    else
    {
      uint64_t v9 = 0;
      unint64_t v10 = 1;
      unsigned int v11 = 1;
      do
      {
        uint64_t v12 = *((void *)a1 + 1);
        if (!strcmp((const char *)(*((void *)a1 + 4) + *(void *)(v12 + 16 * (v11 - 1))), (const char *)(*((void *)a1 + 4) + *(void *)(v12 + v9 + 16))))
        {
          if (v6) {
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11 - 1;
          }
        }
        else
        {
          if (v6) {
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11;
          }
          if (v10 != v11) {
            *(_OWORD *)(v12 + 16 * v11) = *(_OWORD *)(v12 + v9 + 16);
          }
          ++v11;
        }
        ++v10;
        v9 += 16;
      }
      while (v10 < *a1);
    }
    size_t result = 0;
    *a1 = v11;
  }
  return result;
}

uint64_t stringTableIndexCompareProc(uint64_t a1, void *a2, void *a3)
{
  return strcmp((const char *)(*(void *)(a1 + 32) + *a2), (const char *)(*(void *)(a1 + 32) + *a3));
}

uint64_t StringTableSearchSortedWithLength(uint64_t a1, char *__s1, size_t a3, unsigned int *a4)
{
  int v5 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1) {
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(a1 + 8);
  size_t v10 = *(unsigned int *)(v9 + 8);
  int v11 = strncmp(__s1, (const char *)(*(void *)(a1 + 32) + *(void *)v9), a3);
  if (v11)
  {
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_6:
    uint64_t result = 0;
    if (!a4) {
      return result;
    }
    unsigned int v13 = -1;
    goto LABEL_8;
  }
  if (v10 > a3) {
    goto LABEL_6;
  }
  if (v10 >= a3)
  {
    uint64_t result = 1;
    if (!a4) {
      return result;
    }
    unsigned int v13 = 0;
    goto LABEL_8;
  }
LABEL_11:
  unsigned int v13 = v5 - 1;
  int v14 = StringTableCmp(a1, v13, __s1, a3);
  if (v14 >= 1)
  {
    uint64_t result = 0;
    if (!a4) {
      return result;
    }
LABEL_8:
    *a4 = v13;
    return result;
  }
  if (v14)
  {
    if (v13 < 2)
    {
      unsigned int v15 = 0;
LABEL_28:
      uint64_t result = 0;
      unsigned int v13 = v15;
      if (a4) {
        goto LABEL_8;
      }
    }
    else
    {
      unsigned int v15 = 0;
      while (1)
      {
        int v16 = StringTableCmp(a1, v15 + ((v13 - v15) >> 1), __s1, a3);
        if (!v16) {
          break;
        }
        if (v16 < 0) {
          unsigned int v13 = v15 + ((v13 - v15) >> 1);
        }
        else {
          v15 += (v13 - v15) >> 1;
        }
        if (v15 + 1 >= v13) {
          goto LABEL_28;
        }
      }
      uint64_t result = 1;
      unsigned int v13 = v15 + ((v13 - v15) >> 1);
      if (a4) {
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t result = 1;
    if (a4) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t StringTableMatchesPrefixSorted(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (StringTableSearchSortedWithLength(a1, __s, v4, 0)) {
    return 1;
  }
  if (v4)
  {
    size_t v6 = v4 - 1;
    while (__s[v6] != 47 || !StringTableSearchSortedWithLength(a1, __s, v6, 0))
    {
      if (--v6 == -1) {
        return 0;
      }
    }
    return 1;
  }
  return 0;
}

uint64_t StringTableSize(unsigned int *a1)
{
  return *a1;
}

uint64_t StringTableCmp(uint64_t a1, unsigned int a2, char *__s1, size_t __n)
{
  uint64_t v5 = *(void *)(a1 + 8) + 16 * a2;
  size_t v6 = *(unsigned int *)(v5 + 8);
  LODWORD(result) = strncmp(__s1, (const char *)(*(void *)(a1 + 32) + *(void *)v5), __n);
  if (v6 <= __n) {
    unsigned int v8 = v6 < __n;
  }
  else {
    unsigned int v8 = -1;
  }
  if (result) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t ECCFixThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 40) & 0x80000000) != 0)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = malloc(*(unsigned int *)(a1 + 28));
    if (!v9)
    {
      size_t v10 = "creating workBuffer";
      __int16 v11 = 157;
LABEL_31:
      int v25 = 0;
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ECCFixThreadProc", v11, 64, v25, v10, a7, a8, v27);
      goto LABEL_33;
    }
  }
  for (unint64_t i = *(void *)(a1 + 8); i < *(void *)(a1 + 16); ++i)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 28);
    uint64_t v14 = i * v13;
    unint64_t v15 = *(void *)(a1 + 64);
    if (v15 < i * v13)
    {
      size_t v10 = "Invalid block index";
      __int16 v11 = 166;
      goto LABEL_31;
    }
    if (v14 + v13 <= v15) {
      size_t v16 = v13;
    }
    else {
      size_t v16 = (v15 - v14);
    }
    int v17 = *(_DWORD *)(a1 + 40);
    if (v17 < 0)
    {
      uint64_t v19 = *(void *)(a1 + 48) + v14;
    }
    else
    {
      ssize_t v18 = pread(v17, v9, v16, *(void *)(a1 + 56) + v14);
      if (v18 < 0)
      {
        int v25 = *__error();
        size_t v10 = "reading data segment";
        __int16 v11 = 174;
        goto LABEL_32;
      }
      uint64_t v19 = (uint64_t)v9;
      if (v16 != v18)
      {
        LOBYTE(v27) = v18;
        size_t v10 = "Truncated read n=%zd pos=%llu read=%u fd=%d";
        __int16 v11 = 175;
        goto LABEL_31;
      }
    }
    uint64_t v20 = *(unsigned int *)(a1 + 32);
    if (i * v20 + v20 > *(void *)(a1 + 80))
    {
      size_t v10 = "Parity buffer out of range";
      __int16 v11 = 187;
      goto LABEL_31;
    }
    if (*(_DWORD *)(a1 + 24) != 1)
    {
      int v27 = *(_DWORD *)(a1 + 24);
      size_t v10 = "invalid variant %u";
      __int16 v11 = 205;
      goto LABEL_31;
    }
    uint64_t v28 = 0;
    int v21 = ECC65537CheckAndFix(v16, v19, (uint16x8_t *)(*(void *)(a1 + 72) + i * v20), &v28);
    if (v21 < 0)
    {
      ++*(void *)(a1 + 88);
    }
    else if (v21)
    {
      ++*(void *)(a1 + 96);
      v22.i64[0] = v28;
      v22.i64[1] = HIDWORD(v28);
      *(int64x2_t *)(a1 + 104) = vaddq_s64(*(int64x2_t *)(a1 + 104), (int64x2_t)vextq_s8(v22, v22, 8uLL));
      int v23 = *(_DWORD *)(a1 + 40);
      if ((v23 & 0x80000000) == 0)
      {
        ssize_t v24 = pwrite(v23, v9, v16, *(void *)(a1 + 56) + v14);
        if (v24 < 0)
        {
          int v25 = *__error();
          size_t v10 = "writing data segment";
          __int16 v11 = 211;
          goto LABEL_32;
        }
        if (v16 != v24)
        {
          LOBYTE(v27) = v24;
          size_t v10 = "Truncated write n=%zd pos=%llu read=%u fd=%d";
          __int16 v11 = 212;
          goto LABEL_31;
        }
      }
    }
  }
LABEL_33:
  free(v9);
  return 0;
}

uint64_t ParallelArchiveECCFixFileSegment(int a1, off_t a2, unint64_t a3, long long *a4, unint64_t a5, uint64_t a6)
{
  return ParallelArchiveECCFixCommon(a1, 0, a2, a3, a4, a5, a6);
}

uint64_t ParallelArchiveECCFixCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, long long *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v114 = *MEMORY[0x263EF8340];
  unsigned int DefaultNThreads = *(_DWORD *)(a7 + 4);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  int v91 = *(_DWORD *)a7;
  uint64_t v111 = 0;
  uint64_t v112 = 0;
  int v113 = 0;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v108 = 0u;
  double RealTime = getRealTime();
  *(void *)(a7 + 16) = 0;
  *(_DWORD *)(a7 + 12) = 0;
  enterThreadErrorContext(v16, v17, v18, v19, v20, v21, v22, v23, v81);
  unint64_t v90 = a4;
  if (a6 <= 0x2F)
  {
    uint64_t v26 = "Truncated ECC buffer";
    __int16 v27 = 452;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v27, 64, 0, v26, v24, v25, v82);
LABEL_10:
    int v29 = 0;
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
    unsigned int v34 = 0;
    int v35 = 0;
    goto LABEL_11;
  }
  long long v28 = a5[1];
  long long v108 = *a5;
  long long v109 = v28;
  long long v110 = a5[2];
  if ((void)v108 != 0x3031304343455842)
  {
    uint64_t v26 = "Invalid ECC magic";
    __int16 v27 = 454;
    goto LABEL_9;
  }
  if (HIDWORD(v110))
  {
    uint64_t v26 = "Invalid ECC header";
    __int16 v27 = 455;
    goto LABEL_9;
  }
  unsigned int v89 = DWORD2(v110);
  if (!DWORD2(v110))
  {
    uint64_t v26 = "Invalid ECC header";
    __int16 v27 = 456;
    goto LABEL_9;
  }
  if (*((void *)&v108 + 1) != a4)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 457, 64, 0, "Input buffer size mismatch: expected %llu B, got %llu B", v24, v25, SBYTE8(v108));
    goto LABEL_10;
  }
  int v35 = DWORD1(v110);
  if (DWORD1(v110) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 476, 64, 0, "Invalid ECC variant: %u", v24, v25, SBYTE4(v110));
    int v29 = 0;
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
LABEL_55:
    unsigned int v34 = v89;
    goto LABEL_11;
  }
  if (DWORD2(v110) >= 0x1FFE1)
  {
    unsigned int v34 = DWORD2(v110);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 472, 64, 0, "Invalid blockSize: %u", v24, v25, SBYTE8(v110));
    int v29 = 0;
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
    int v35 = 1;
    goto LABEL_11;
  }
  unint64_t v49 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  uint64_t v84 = 34 * v49;
  if (34 * v49 + 48 != a6)
  {
    unint64_t v52 = "Invalid ECC buffer size";
    __int16 v53 = 481;
    goto LABEL_52;
  }
  unint64_t v86 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  if (v49 >= DefaultNThreads) {
    unsigned int v50 = DefaultNThreads;
  }
  else {
    unsigned int v50 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  }
  if (v50 <= 1) {
    size_t v51 = 1;
  }
  else {
    size_t v51 = v50;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      unint64_t v52 = "computing buffer digest";
      __int16 v53 = 495;
      goto LABEL_52;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v111) & 0x80000000) != 0)
  {
    unint64_t v52 = "computing file digest";
    __int16 v53 = 491;
LABEL_52:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v53, 64, 0, v52, v24, v25, v82);
    int v29 = 0;
    unint64_t v30 = 0;
LABEL_53:
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
LABEL_54:
    int v35 = 1;
    goto LABEL_55;
  }
  unint64_t v87 = (v86 + v51 - 1) / v51;
  if (v91 >= 1)
  {
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    __int16 v54 = (FILE **)MEMORY[0x263EF8348];
    fwrite("ParallelArchiveECCFixCommon:\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf(*v54, "  Input data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
    fprintf(*v54, "  Expected SHA1: %s\n", (const char *)&v92);
    fwrite("  ECC variant: ", 0xFuLL, 1uLL, *v54);
    fwrite("RS65537\n", 8uLL, 1uLL, *v54);
    fprintf(*v54, "%12llu data size\n", a4);
    fprintf(*v54, "%12u block size\n", v89);
    fprintf(*v54, "%12u ECC parity size per block\n", 34);
    fprintf(*v54, "%11.2f%% parity/data ratio\n", 3400.0 / (double)v89);
    fprintf(*v54, "%12zu block count\n", v86);
    fprintf(*v54, "%12zu ECC buffer size\n", a6);
    fprintf(*v54, "%12u worker threads\n", v51);
    fprintf(*v54, "%12zu blocks per thread\n", v87);
  }
  if (v111 == (void)v109 && v112 == *((void *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    unint64_t v30 = 0;
    unint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
    int v29 = 1;
    goto LABEL_54;
  }
  uint64_t v57 = calloc(v51, 0x78uLL);
  unint64_t v30 = (unint64_t)v57;
  if (!v57)
  {
    uint64_t v72 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 526, 64, *v72, "malloc %u threads", v73, v74, v51);
    int v29 = 0;
    goto LABEL_53;
  }
  uint64_t v58 = 0;
  uint64_t v83 = a5 + 3;
  size_t v59 = v51;
  uint64_t v60 = (uint64_t)v57;
  int v29 = 1;
  unint64_t v61 = (v86 + v51 - 1) / v51;
  do
  {
    unint64_t v62 = v61 * v58;
    if (v61 * v58 < v86)
    {
      unint64_t v63 = v62 + v87;
      if (v62 + v87 >= v86) {
        unint64_t v63 = v86;
      }
      *(void *)(v60 + 8) = v62;
      *(void *)(v60 + 16) = v63;
      *(_DWORD *)(v60 + 40) = a1;
      *(void *)(v60 + 48) = a2;
      *(void *)(v60 + 56) = a3;
      *(void *)(v60 + 64) = v90;
      *(void *)(v60 + 72) = v83;
      *(void *)(v60 + 80) = v84;
      *(_DWORD *)(v60 + 24) = 1;
      *(_DWORD *)(v60 + 28) = v89;
      *(void *)(v60 + 32) = 34;
      int Thread = createThread((pthread_t *)v60, (uint64_t)ECCFixThreadProc, v60, 0);
      unint64_t v61 = (v86 + v51 - 1) / v51;
      if (Thread)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 549, 64, 0, "createThread", v65, v66, v82);
        unint64_t v61 = (v86 + v51 - 1) / v51;
        int v29 = 0;
      }
    }
    ++v58;
    v60 += 120;
    --v59;
  }
  while (v59);
  int64x2_t v67 = 0uLL;
  int64x2_t v68 = 0uLL;
  do
  {
    if (*(void *)v30)
    {
      int64x2_t v85 = v68;
      int64x2_t v88 = v67;
      if (joinThread(*(_opaque_pthread_t **)v30))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 556, 64, 0, "joinThread", v69, v70, v82);
        int v29 = 0;
      }
      int64x2_t v68 = vaddq_s64(*(int64x2_t *)(v30 + 104), v85);
      int64x2_t v67 = vaddq_s64(*(int64x2_t *)(v30 + 88), v88);
    }
    v30 += 120;
    --v51;
  }
  while (v51);
  unint64_t v32 = v67.u64[1];
  unint64_t v33 = v67.i64[0];
  unint64_t v30 = v68.u64[1];
  unint64_t v71 = v68.i64[0];
  if (v67.i64[0]) {
    goto LABEL_81;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, v90, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      __int16 v77 = "computing buffer digest";
      __int16 v78 = 574;
      goto LABEL_102;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, v90, (uint64_t)&v111) & 0x80000000) != 0)
  {
    __int16 v77 = "computing file digest";
    __int16 v78 = 570;
LABEL_102:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v78, 64, 0, v77, v75, v76, v82);
    int v29 = 0;
    unint64_t v33 = 0;
LABEL_81:
    int v35 = 1;
    unsigned int v34 = v89;
LABEL_82:
    unint64_t v31 = v71;
    goto LABEL_11;
  }
  unsigned int v34 = v89;
  if (v91 >= 1)
  {
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf((FILE *)*MEMORY[0x263EF8348], "  Output data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
  }
  if (v111 == (void)v109 && v112 == *((void *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    unint64_t v33 = 0;
    int v35 = 1;
    goto LABEL_82;
  }
  unint64_t v30 = 0;
  unint64_t v31 = 0;
  unint64_t v32 = 0;
  int v35 = 1;
  unint64_t v33 = v86;
LABEL_11:
  uint64_t result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (!v29) {
    return 0xFFFFFFFFLL;
  }
  int v37 = 0x7FFF;
  if (v30 < 0x7FFF) {
    int v37 = v30;
  }
  int v38 = v37 << 8;
  int v39 = 255;
  if (v32 < 0xFF) {
    int v39 = v32;
  }
  int v40 = v38 | v39;
  int v41 = 255;
  if (v33 < 0xFF) {
    int v41 = v33;
  }
  int v42 = v38 | v41 | 0x800000;
  if (v33) {
    int v43 = v42;
  }
  else {
    int v43 = v40;
  }
  if (v91 <= 0)
  {
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v34;
    *(_DWORD *)(a7 + 20) = v43;
    if (v33) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    unsigned int v44 = v34;
    size_t v45 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu fixed blocks\n", v32);
    unint64_t v46 = v31;
    fprintf(*v45, "%12llu fixed bytes\n", v31);
    fprintf(*v45, "%12llu fixed bits\n", v30);
    if (v33)
    {
      fprintf(*v45, "%12llu INVALID BLOCKS\n", v33);
      uint64_t v47 = "FAIL";
    }
    else
    {
      uint64_t v47 = "OK";
    }
    fprintf(*v45, "    0x%06x diagnostic code\n", v43);
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v44;
    *(_DWORD *)(a7 + 20) = v43;
    double v48 = getRealTime();
    fprintf(*v45, "Total time %.2fs, %.2f MB/s (%s)\n", v48 - RealTime, (double)v90 * 0.000000953674316 / (v48 - RealTime), v47);
    unint64_t v31 = v46;
    if (v33) {
      return 0xFFFFFFFFLL;
    }
  }
  if (v31 >= 0x7FFFFFFF) {
    return 0x7FFFFFFFLL;
  }
  else {
    return v31;
  }
}

uint64_t ParallelArchiveECCVerifyCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, long long *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v18 = 0;
  if (a6 <= 0x2F)
  {
    unsigned int v8 = "Truncated ECC buffer";
    __int16 v9 = 390;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCVerifyCommon", v9, 64, 0, v8, a7, a8, v13);
    return 0xFFFFFFFFLL;
  }
  long long v13 = *a5;
  long long v14 = a5[1];
  long long v15 = a5[2];
  if (*(void *)a5 != 0x3031304343455842)
  {
    unsigned int v8 = "Invalid ECC magic";
    __int16 v9 = 392;
    goto LABEL_7;
  }
  if (HIDWORD(v15))
  {
    unsigned int v8 = "Invalid ECC header";
    __int16 v9 = 393;
    goto LABEL_7;
  }
  if (!DWORD2(v15))
  {
    unsigned int v8 = "Invalid ECC header";
    __int16 v9 = 394;
    goto LABEL_7;
  }
  if (*((void *)&v13 + 1) != a4) {
    return 0;
  }
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v16) & 0x80000000) != 0)
    {
      unsigned int v8 = "computing buffer digest";
      __int16 v9 = 404;
      goto LABEL_7;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v16) & 0x80000000) != 0)
  {
    unsigned int v8 = "computing file digest";
    __int16 v9 = 400;
    goto LABEL_7;
  }
  return v16 == (void)v14 && v17 == *((void *)&v14 + 1) && v18 == (unint64_t)v15;
}

uint64_t ParallelArchiveECCVerifyFileSegment(int a1, off_t a2, unint64_t a3, long long *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ParallelArchiveECCVerifyCommon(a1, 0, a2, a3, a4, a5, a7, a8);
}

void *OECCStreamCreate(int a1, unsigned int a2, uint64_t a3)
{
  size_t v6 = calloc(1uLL, 0xB0uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *(_DWORD *)size_t v6 = a1;
    v6[4] = a3;
    *((_DWORD *)v6 + 10) = a2;
    unsigned int v8 = malloc(a2);
    v7[8] = v8;
    if (v8)
    {
      if (a1 != 1)
      {
        __int16 v11 = "Invalid ECC algorithm";
        __int16 v12 = 857;
        goto LABEL_9;
      }
      if (a2 >= 0x1FFE1)
      {
        __int16 v11 = "Invalid ECC block size";
        __int16 v12 = 853;
LABEL_9:
        int v13 = 0;
        goto LABEL_10;
      }
      *((_DWORD *)v7 + 6) = 34;
      size_t v15 = 34 * ((a3 + (unint64_t)a2 - 1) / a2) + 48;
      v7[2] = v15;
      uint64_t v16 = malloc(v15);
      v7[1] = v16;
      if (v16)
      {
        CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)((char *)v7 + 76));
        v7[7] = 48;
        checkEOF((int *)v7);
        return v7;
      }
      int v13 = *__error();
      __int16 v11 = "malloc";
      __int16 v12 = 862;
    }
    else
    {
      int v13 = *__error();
      __int16 v11 = "malloc";
      __int16 v12 = 846;
    }
  }
  else
  {
    int v13 = *__error();
    __int16 v11 = "malloc";
    __int16 v12 = 841;
  }
LABEL_10:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamCreate", v12, 64, v13, v11, v9, v10, v17);
  OECCStreamDestroy((void **)v7);
  return 0;
}

int *checkEOF(int *result)
{
  if (*((void *)result + 6) == *((void *)result + 4) && !result[43])
  {
    result[43] = 1;
    uint64_t v1 = *((void *)result + 1);
    *(void *)uint64_t v1 = 0x3031304343455842;
    int v2 = *result;
    *(void *)(v1 + 8) = *((void *)result + 4);
    *(_DWORD *)(v1 + 44) = 0;
    int v3 = result[10];
    *(_DWORD *)(v1 + 36) = v2;
    *(_DWORD *)(v1 + 40) = v3;
    return (int *)CC_SHA1_Deprecated_Final((unsigned __int8 *)(v1 + 16), (CC_SHA1_CTX *)(result + 19));
  }
  return result;
}

void OECCStreamDestroy(void **a1)
{
  if (a1)
  {
    free(a1[8]);
    free(a1[1]);
    free(a1);
  }
}

uint64_t OECCStreamGetDataPtr(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172)) {
    return *(void *)(a1 + 8);
  }
  else {
    return 0;
  }
}

uint64_t OECCStreamGetDataSize(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172)) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

uint64_t OECCStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 48);
  BOOL v9 = __CFADD__(v8, a3);
  unint64_t v10 = v8 + a3;
  int v11 = v9;
  if (v10 <= *(void *)(a1 + 32) && v11 == 0)
  {
    uint64_t v16 = a3;
    char v17 = a2;
    CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 76), a2, a3);
    uint64_t v15 = 0;
    if (v16)
    {
      unsigned int v19 = *(_DWORD *)(a1 + 72);
      do
      {
        unint64_t v20 = *(unsigned int *)(a1 + 40);
        size_t v21 = v16 + (unint64_t)v19 <= v20 ? v16 : v20 - v19;
        memcpy((void *)(*(void *)(a1 + 64) + v19), v17, v21);
        unsigned int v22 = *(_DWORD *)(a1 + 72) + v21;
        *(_DWORD *)(a1 + 72) = v22;
        size_t v23 = *(void *)(a1 + 48) + v21;
        *(void *)(a1 + 48) = v23;
        v15 += v21;
        if (v22 < *(_DWORD *)(a1 + 40) && v23 < *(void *)(a1 + 32)) {
          break;
        }
        uint64_t v24 = *(void *)(a1 + 56);
        if (v24 + (unint64_t)*(unsigned int *)(a1 + 24) > *(void *)(a1 + 16))
        {
          int v13 = "ECC buffer overflow";
          __int16 v14 = 914;
          goto LABEL_9;
        }
        if (*(_DWORD *)a1 != 1)
        {
          int v13 = "Invalid ECC algorithm";
          __int16 v14 = 921;
          goto LABEL_9;
        }
        if ((ECC65537GetParity(v22, *(void *)(a1 + 64), *(void *)(a1 + 8) + v24) & 0x80000000) != 0)
        {
          int v13 = "ECC generation failed";
          __int16 v14 = 918;
          goto LABEL_9;
        }
        unsigned int v19 = 0;
        v17 += v21;
        *(void *)(a1 + 56) += *(unsigned int *)(a1 + 24);
        *(_DWORD *)(a1 + 72) = 0;
        v16 -= v21;
      }
      while (v16);
    }
    checkEOF((int *)a1);
  }
  else
  {
    int v13 = "Too many bytes received";
    __int16 v14 = 892;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamWrite", v14, 64, 0, v13, a7, a8, v26);
    return -1;
  }
  return v15;
}

uint64_t initBestMatchThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = MEMORY[0x270FA5388](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v80 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)v8;
  unsigned int v10 = *(_DWORD *)(v8 + 20);
  bzero(v79, 0x3000uLL);
  bzero(v78, 0x7000uLL);
  unsigned int v11 = *(_DWORD *)(v8 + 12);
  unsigned int v12 = *(_DWORD *)(v8 + 16);
  unsigned int v13 = *(_DWORD *)(v9 + 36);
  unsigned int v14 = v13 - v10;
  if (v13 < v10) {
    unsigned int v14 = 0;
  }
  if (v12 + v10 > v13) {
    unsigned int v12 = v14;
  }
  if (v11 < v12)
  {
    for (unsigned int i = *(_DWORD *)(v8 + 12); i < v12; ++i)
    {
      uint64_t v16 = *(void *)(v9 + 48);
      unsigned int v17 = *(_DWORD *)(v16 + 8 * i + 4);
      if (v17 < 0x400)
      {
        uint64_t v18 = i;
        uint64_t v19 = *(void *)(v9 + 24);
        unsigned int v20 = 0;
        if (v10)
        {
          size_t v21 = (int *)(v19 + i);
          unsigned int v22 = v10;
          do
          {
            int v23 = *v21++;
            unsigned int v20 = -1640531535 * (v23 + v20) - 1640531535;
            v22 -= 4;
          }
          while (v22);
        }
        uint64_t v24 = *(void *)(v8 + 32);
        int v25 = v20 ^ HIWORD(v20);
        unsigned int v26 = v20 >> *(_DWORD *)(v9 + 44);
        if (*(unsigned __int16 *)(v24 + 6 * v26 + 4) == (unsigned __int16)v25)
        {
          unsigned int v27 = *(_DWORD *)(v24 + 6 * v26);
          if (v27 >= *(_DWORD *)(v8 + 8))
          {
            int v28 = ((_WORD)i - (_WORD)v27) & 0x3FF;
            int v29 = &v79[3 * (((_WORD)i - (_WORD)v27) & 0x3FF)];
            if (v27 != v29[1] + i - *v29 || v79[3 * (((_WORD)i - (_WORD)v27) & 0x3FF) + 2] + *v29 < i)
            {
              int v30 = v27 & 0x3FF;
              unint64_t v31 = (unsigned int *)&v78[28 * (v27 & 0x3FF)];
              if (*v31 == v27)
              {
                unint64_t v32 = &v78[28 * (v27 & 0x3FF)];
                int v33 = *((_DWORD *)v32 + 2);
                int v34 = i - v33;
                if (v33 != *((_DWORD *)v32 + 5) + i - v33) {
                  goto LABEL_26;
                }
                int v35 = &v78[28 * (v27 & 0x3FF)];
                int v37 = v35[3];
                int v36 = v35[4];
                int v38 = v36 + v34;
                unsigned int v39 = v35[1];
                if (v36 + v34 <= v39) {
                  int v38 = v35[1];
                }
                uint64_t v40 = (v38 + v34);
                unsigned int v41 = v35[6] + v36;
                if (v41 >= v37 + v39) {
                  unsigned int v41 = v37 + v39;
                }
                BOOL v42 = v41 >= v40;
                int v43 = v41 - v40;
                if (v43 != 0 && v42)
                {
                  unsigned int v27 = v27 - i + v40;
                  uint64_t v18 = v40;
                }
                else
                {
LABEL_26:
                  int v43 = 0;
LABEL_27:
                  LODWORD(v40) = i;
                }
                unsigned int v45 = 0;
                if (v27 >= v40 - v11) {
                  unsigned int v46 = v40 - v11;
                }
                else {
                  unsigned int v46 = v27;
                }
                uint64_t v47 = *(void *)(v9 + 16);
                uint64_t v48 = v47 + v27;
                uint64_t v49 = v19 + v18;
                unsigned int v50 = -1;
                while (1)
                {
                  v45 += 8;
                  if (v45 > v46) {
                    break;
                  }
                  v50 += 8;
                  unint64_t v51 = *(void *)(v49 - v45) ^ *(void *)(v48 - v45);
                  if (v51)
                  {
                    unsigned int v50 = v45 + (__clz(v51) >> 3) - 8;
                    goto LABEL_39;
                  }
                }
                while (1)
                {
                  unsigned int v52 = v50 + 2;
                  if (v50 + 2 > v46) {
                    break;
                  }
                  ++v50;
                  if (*(unsigned __int8 *)(v48 - v52) != *(unsigned __int8 *)(v49 - v52)) {
                    goto LABEL_39;
                  }
                }
                unsigned int v50 = v46;
LABEL_39:
                uint64_t v53 = v27 - v50;
                uint64_t v54 = v40 - v50;
                unsigned int v55 = v50 + v43;
                unsigned int v56 = *(_DWORD *)(v9 + 32) - v53;
                LODWORD(v57) = *(_DWORD *)(v9 + 36) - v54;
                if (v56 >= v57) {
                  unint64_t v57 = v57;
                }
                else {
                  unint64_t v57 = v56;
                }
                uint64_t v58 = v47 + v53;
                uint64_t v59 = v19 + v54;
                while (1)
                {
                  unsigned int v60 = v55 + 8;
                  if (v55 + 8 > v57) {
                    break;
                  }
                  uint64_t v61 = *(void *)(v58 + v55);
                  uint64_t v62 = *(void *)(v59 + v55);
                  v55 += 8;
                  unint64_t v63 = v62 ^ v61;
                  if (v63)
                  {
                    LODWORD(v57) = v60 + (__clz(__rbit64(v63)) >> 3) - 8;
                    goto LABEL_52;
                  }
                }
                if (v55 < v57)
                {
                  uint64_t v64 = v55;
                  while (*(unsigned __int8 *)(v58 + v64) == *(unsigned __int8 *)(v59 + v64))
                  {
                    if (++v64 >= v57) {
                      goto LABEL_52;
                    }
                  }
                  LODWORD(v57) = v64;
                }
LABEL_52:
                if (v57 >= v10)
                {
                  *int v29 = v54;
                  v29[1] = v53;
                  v79[3 * v28 + 2] = v57;
                  uint64_t v65 = &v78[28 * v30];
                  int v66 = v65[1];
                  int v67 = v65[3];
                  v65[5] = v33;
                  v65[6] = v67;
                  v65[1] = v54;
                  v65[2] = i;
                  v65[3] = v57;
                  v65[4] = v66;
                  int64x2_t v68 = (_DWORD *)(v16 + 8 * v54);
                  if (v57 > v68[1])
                  {
                    *int64x2_t v68 = v53;
                    *(_DWORD *)(*(void *)(v9 + 48) + 8 * v54 + 4) = v57;
                    if ((int)v57 + (int)v54 > i + 1024) {
                      unsigned int i = v57 + v54 - 1024;
                    }
                  }
                }
                continue;
              }
              int v33 = 0;
              int v43 = 0;
              *unint64_t v31 = v27;
              unsigned int v44 = &v78[28 * (v27 & 0x3FF)];
              *((void *)v44 + 1) = 0;
              *((_DWORD *)v44 + 1) = 0;
              goto LABEL_27;
            }
          }
        }
      }
      else
      {
        unsigned int i = i + v17 - 1024;
      }
    }
  }
  if (*(_DWORD *)(v8 + 24))
  {
    unsigned int v69 = *(_DWORD *)(v8 + 16);
    unint64_t v70 = (*(_DWORD *)(v8 + 12) + 1);
    if (v70 < v69)
    {
      uint64_t v71 = 8 * (*(_DWORD *)(v8 + 12) + 1);
      do
      {
        uint64_t v72 = *(void *)(v9 + 48);
        uint64_t v73 = v72 + v71;
        unsigned int v74 = *(_DWORD *)(v72 + v71 - 4);
        if (v74 > v10 && v74 > *(_DWORD *)(v72 + v71 + 4))
        {
          unsigned int v76 = *(_DWORD *)(v73 - 8) + 1;
          if (v76 < *(_DWORD *)(v9 + 32))
          {
            *(_DWORD *)(v72 + v71) = v76;
            *(_DWORD *)(v73 + 4) = v74 - 1;
            unsigned int v69 = *(_DWORD *)(v8 + 16);
          }
        }
        ++v70;
        v71 += 8;
      }
      while (v70 < v69);
    }
  }
  return 0;
}

uint64_t BXDiffMatchesCreate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v182 = *MEMORY[0x263EF8340];
  uint64_t v177 = 0;
  uint64_t v178 = 0;
  uint64_t v179 = 0;
  int v8 = *a5;
  if (!*a5) {
    int v8 = 6;
  }
  if (a4 >= 0x4B000) {
    int v9 = v8;
  }
  else {
    int v9 = 20;
  }
  if (a2 > 0xFFFFFFFE || (unint64_t v10 = a4, a4 >= 0xFFFFFFFF))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", 994, 92, 0, "isize,osize too large", a7, a8, v167);
    return 0;
  }
  uint64_t v15 = calloc(1uLL, 0x40uLL);
  uint64_t v16 = (uint64_t)v15;
  if (!v15)
  {
    int v87 = *__error();
    int64x2_t v88 = "malloc";
    __int16 v89 = 998;
    goto LABEL_108;
  }
  uint64_t v17 = *(void *)a5;
  void v15[2] = a5[2];
  *(void *)uint64_t v15 = v17;
  int DefaultNThreads = a5[2];
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  *(_DWORD *)(v16 + 8) = DefaultNThreads;
  *(void *)(v16 + 16) = a1;
  *(void *)(v16 + 24) = a3;
  *(_DWORD *)(v16 + 32) = a2;
  *(_DWORD *)(v16 + 36) = v10;
  if ((getProfile(&v177, v9) & 0x80000000) != 0)
  {
    int v167 = *a5;
    int64x2_t v88 = "loading profile: %d";
    __int16 v89 = 1008;
    goto LABEL_106;
  }
  if ((int)v177 >= 1)
  {
    getRealTime();
    size_t v21 = malloc(4 * a2 + 1028);
    unsigned int v22 = malloc(8 * a2);
    int v23 = v22;
    if (!v21 || !v22)
    {
      unint64_t v90 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"qsufsort32", 377, 92, *v90, "malloc", v91, v92, v167);
      free(v21);
      free(v23);
      *(void *)(v16 + 56) = 0;
      __int16 v89 = 1021;
      int v87 = 0;
      int64x2_t v88 = "qsufsort32";
      goto LABEL_108;
    }
    uint64_t v24 = v21 + 257;
    v21[257] = a2;
    *unsigned int v22 = 0;
    if (a2)
    {
      unint64_t v170 = v21;
      unint64_t v172 = v10;
      uint64_t v174 = v16;
      unsigned int v25 = 0;
      int v175 = a2 ^ 0x80000000;
      unsigned int v26 = v22 + 1;
      do
      {
        if (*v23 == v175) {
          break;
        }
        unsigned int v27 = 0;
        unsigned int v28 = -1;
        do
        {
          int v29 = &v23[2 * v27];
          uint64_t v30 = *v29;
          if ((v30 & 0x80000000) != 0)
          {
            LODWORD(v31) = v30 ^ 0x80000000;
          }
          else
          {
            uint64_t v31 = v24[v30];
            if (v25)
            {
              if (v31 > v27)
              {
                uint64_t v32 = v31 - v27;
                int v33 = &v26[2 * v27];
                do
                {
                  _DWORD *v33 = v24[*(v33 - 1) + v25];
                  v33 += 2;
                  --v32;
                }
                while (v32);
              }
            }
            else if (v31 > v27)
            {
              int v34 = 0;
              uint64_t v35 = (v31 - 1);
              int v36 = &v26[2 * v35];
              int v37 = (unsigned __int8 *)(a1 + v35);
              int v38 = 1;
              unsigned int v39 = v31;
              do
              {
                unsigned int v40 = *v37--;
                int v41 = __PAIR64__(v40, v34) >> 8;
                unsigned int v42 = v39 + 2;
                unsigned int v43 = v39 - 1;
                int v44 = v41 | 0xFF;
                int v34 = v38 + (v41 & 0xFFFFFF00);
                if (v42 < v31) {
                  int v34 = v44;
                }
                *(v36 - 1) = v43;
                *int v36 = v34;
                v36 -= 2;
                ++v38;
                unsigned int v39 = v43;
              }
              while (v27 < v43);
            }
            quicksort64(v31 - v27, (unint64_t *)&v23[2 * v27], 24);
            unsigned int v45 = v27 + 1;
            if (v27 + 1 <= v31)
            {
              unsigned int v46 = v29[1];
              do
              {
                unsigned int v47 = v46;
                if (v45 >= v31) {
                  unsigned int v46 = 0;
                }
                else {
                  unsigned int v46 = v26[2 * v45];
                }
                if (v47 != v46)
                {
                  if (v45 - v27 < 2)
                  {
                    if (v28 >= a2) {
                      unsigned int v28 = v27;
                    }
                  }
                  else if (v28 < a2)
                  {
                    v23[2 * v28] = v27 ^ 0x80000000;
                    unsigned int v28 = -1;
                  }
                  if (v45 > v27)
                  {
                    unint64_t v48 = v45 - (unint64_t)v27;
                    uint64_t v49 = &v23[2 * v27];
                    do
                    {
                      int v50 = *v49;
                      v49 += 2;
                      v24[v50] = v45;
                      --v48;
                    }
                    while (v48);
                    unsigned int v27 = v45;
                  }
                }
                ++v45;
              }
              while (v45 <= v31);
            }
          }
          unsigned int v27 = v31;
        }
        while (v31 < a2);
        if (v28 < a2) {
          v23[2 * v28] = v175;
        }
        if (v25 >= 3) {
          v25 *= 2;
        }
        else {
          unsigned int v25 = 3;
        }
      }
      while (v25 < a2);
      uint64_t v51 = 0;
      unint64_t v10 = v172;
      uint64_t v16 = v174;
      size_t v21 = v170;
      do
      {
        *(void *)&v23[2 * (v24[v51] - 1)] = v51;
        ++v51;
      }
      while (a2 != v51);
    }
    if (a2)
    {
      unsigned int v52 = (uint64_t *)v23;
      uint64_t v53 = v24;
      unint64_t v54 = a2;
      do
      {
        uint64_t v55 = *v52++;
        *v53++ = v55;
        --v54;
      }
      while (v54);
    }
    int v56 = 0;
    _DWORD *v21 = 0;
    v21[256] = a2;
    for (unint64_t i = 1; i != 256; ++i)
    {
      unsigned int v58 = a2;
      if (v56 != a2)
      {
        if (v56 + 1 >= a2)
        {
          unsigned int v58 = a2;
        }
        else
        {
          unsigned int v58 = a2;
          do
          {
            if (i <= *(unsigned __int8 *)(a1 + v24[v56 + ((v58 - v56) >> 1)])) {
              unsigned int v58 = v56 + ((v58 - v56) >> 1);
            }
            else {
              v56 += (v58 - v56) >> 1;
            }
          }
          while (v58 > v56 + 1);
        }
        uint64_t v59 = v24[v56];
        if (v59 != a2 && i == *(unsigned __int8 *)(a1 + v59)) {
          unsigned int v58 = v56;
        }
      }
      v21[i] = v58;
      int v56 = v58;
    }
    free(v23);
    *(void *)(v16 + 56) = v21;
    getRealTime();
  }
  if (SHIDWORD(v177) >= 1)
  {
    unsigned int v60 = malloc(8 * v10);
    *(void *)(v16 + 48) = v60;
    if (!v60)
    {
      int v87 = *__error();
      int64x2_t v88 = "malloc";
      __int16 v89 = 1033;
      goto LABEL_108;
    }
    if (*(_DWORD *)(v16 + 36))
    {
      uint64_t v61 = 0;
      unint64_t v62 = 0;
      do
      {
        *(void *)(*(void *)(v16 + 48) + v61) = 0xFFFFFFFFLL;
        ++v62;
        v61 += 8;
      }
      while (v62 < *(unsigned int *)(v16 + 36));
    }
  }
  uint64_t v63 = *(void *)(v16 + 48);
  if (*(void *)(v16 + 56))
  {
    if (v63)
    {
      int v65 = HIDWORD(v178);
      unsigned int v64 = v179;
      getRealTime();
      unsigned int v66 = *(_DWORD *)(v16 + 36);
      if (v66)
      {
        unsigned int v67 = 0;
        unsigned int v68 = 1;
        do
        {
          unsigned int v69 = v67;
          unint64_t v70 = (_DWORD *)(*(void *)(v16 + 48) + 8 * v67);
          if (v70[1] < v64)
          {
            uint64_t v71 = *(void *)(v16 + 56);
            uint64_t v72 = (unsigned int *)(v71 + 4 * *(unsigned __int8 *)(*(void *)(v16 + 24) + v67));
            unsigned int v73 = *v72;
            unsigned int v74 = v72[1] + 1;
            LODWORD(v180) = -1;
            unsigned int v75 = bestMatchInRange(v16, v71 + 1028, v67, v73, v74, &v180);
            int v76 = (int)v180;
            *unint64_t v70 = v180;
            *(_DWORD *)(*(void *)(v16 + 48) + 8 * v67 + 4) = v75;
            if (v75 >= v64)
            {
              if ((v76 + 1) < *(_DWORD *)(v16 + 32))
              {
                uint64_t v77 = 8 * v68;
                unsigned int v78 = v75 - 1;
                int v79 = 1;
                do
                {
                  BOOL v80 = v67 + v79 < *(_DWORD *)(v16 + 36) && v78 >= v64;
                  if (!v80) {
                    break;
                  }
                  *(_DWORD *)(*(void *)(v16 + 48) + v77) = v76 + v79;
                  *(_DWORD *)(*(void *)(v16 + 48) + v77 + 4) = v78;
                  v77 += 8;
                  ++v79;
                  --v78;
                }
                while ((v76 + v79) < *(_DWORD *)(v16 + 32));
              }
              if (v67 && v76)
              {
                uint64_t v81 = 0;
                uint64_t v82 = v67 - 1;
                uint64_t v83 = 8 * v67;
                unsigned int v84 = v75 + 1;
                do
                {
                  uint64_t v85 = *(void *)(v16 + 48) + v83;
                  if (*(_DWORD *)(v85 - 8) != -1) {
                    break;
                  }
                  if (*(unsigned __int8 *)(*(void *)(v16 + 16) + (v76 + v81 - 1)) != *(unsigned __int8 *)(*(void *)(v16 + 24) + v82 + v81)) {
                    break;
                  }
                  *(_DWORD *)(v85 - 8) = v76 - 1 + v81;
                  *(_DWORD *)(*(void *)(v16 + 48) + v83 - 4) = v84;
                  if (!(v82 + v81)) {
                    break;
                  }
                  int v86 = v76 + v81--;
                  v83 -= 8;
                  ++v84;
                }
                while (v86 != 1);
              }
            }
            unsigned int v66 = *(_DWORD *)(v16 + 36);
          }
          v67 += v65;
          v68 += v65;
        }
        while (v69 + v65 < v66);
      }
LABEL_185:
      getRealTime();
    }
    goto LABEL_186;
  }
  if (!v63)
  {
LABEL_186:
    if ((int)v177 >= 2)
    {
      free(*(void **)(v16 + 56));
      *(void *)(v16 + 56) = 0;
    }
    return v16;
  }
  int v94 = -13;
  do
  {
    int v95 = v94 + 33;
    unsigned int v96 = 1 << (v94++ + 33 + v178);
  }
  while (v95 < SHIDWORD(v179) && v96 < *(_DWORD *)(v16 + 32));
  *(_DWORD *)(v16 + 40) = v94 + 32;
  *(_DWORD *)(v16 + 44) = -v94;
  unsigned int v97 = v179;
  getRealTime();
  size_t v98 = *(unsigned int *)(v16 + 8);
  long long v180 = 0;
  long long v181 = 0;
  int v99 = 1;
  unsigned int v101 = *(_DWORD *)(v16 + 32);
  unsigned int v100 = *(_DWORD *)(v16 + 36);
  if (v101 >= v100) {
    unsigned int v101 = *(_DWORD *)(v16 + 36);
  }
  if (v101 < 2 * v97)
  {
    long long v102 = 0;
    long long v103 = 0;
    goto LABEL_184;
  }
  uint64_t v104 = 0;
  size_t v105 = 6 * (1 << *(_DWORD *)(v16 + 40));
  unsigned int v176 = ((v98 + v100 - 1) / v98 + 0xFFFF) & 0xFFFF0000;
  char v106 = 1;
  do
  {
    long long v107 = calloc(1uLL, v105);
    *(&v180 + v104) = v107;
    if (!v107)
    {
      uint64_t v123 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 852, 92, *v123, "malloc", v124, v125, v167);
      long long v102 = 0;
      long long v103 = 0;
LABEL_183:
      int v99 = 0;
      goto LABEL_184;
    }
    char v108 = (v98 != 1) & v106;
    uint64_t v104 = 1;
    char v106 = 0;
  }
  while ((v108 & 1) != 0);
  long long v102 = calloc(v98, 0x28uLL);
  long long v109 = (uint64_t *)malloc(8 * v98);
  long long v103 = v109;
  if (!v102 || !v109)
  {
    int v126 = *__error();
    int v121 = "malloc";
    __int16 v122 = 862;
LABEL_182:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v122, 92, v126, v121, v115, v116, v167);
    goto LABEL_183;
  }
  if (!v98) {
    goto LABEL_129;
  }
  uint64_t v117 = v109;
  uint64_t v118 = v102;
  size_t v119 = v98;
  do
  {
    *v117++ = (uint64_t)v118;
    v118[5] = v97;
    *(void *)uint64_t v118 = v16;
    v118 += 10;
    --v119;
  }
  while (v119);
  if (v98 == 1)
  {
    uint64_t v120 = 0;
  }
  else
  {
LABEL_129:
    uint64_t v120 = ThreadPoolCreate(v98, (uint64_t)v109, (uint64_t)initBestMatchThreadProc);
    if (!v120)
    {
      int v121 = "ThreadPoolCreate";
      __int16 v122 = 874;
      goto LABEL_181;
    }
  }
  unsigned int v127 = *(_DWORD *)(v16 + 32);
  if (v127)
  {
    int v171 = v103;
    long long v168 = v102;
    unsigned int v128 = 0;
    unsigned int v129 = 0;
    while (1)
    {
      unsigned int v169 = v128;
      long long v130 = *(&v180 + v128);
      BOOL v80 = v127 >= v97;
      unsigned int v131 = v127 - v97;
      if (!v80) {
        unsigned int v131 = 0;
      }
      unsigned int v173 = v129 + v96;
      if (v129 + v96 < v131) {
        unsigned int v131 = v129 + v96;
      }
      unsigned int v132 = v129 + 4;
      if (v129 + 4 < v131)
      {
        uint64_t v133 = *(void *)(v16 + 16);
        unsigned int v134 = v129;
        do
        {
          unsigned int v135 = v132;
          if (v97)
          {
            unsigned int v136 = 0;
            uint64_t v137 = (int *)(v133 + v134);
            char v138 = v137;
            unsigned int v139 = v97;
            do
            {
              int v140 = *v138++;
              unsigned int v136 = -1640531535 * (v140 + v136) - 1640531535;
              v139 -= 4;
            }
            while (v139);
            unsigned int v141 = 0;
            int v142 = *(_DWORD *)(v16 + 44);
            unsigned int v143 = v136 >> v142;
            long long v144 = (int *)((char *)v137 + 1);
            unsigned int v145 = v97;
            do
            {
              int v146 = *v144++;
              unsigned int v141 = -1640531535 * (v146 + v141) - 1640531535;
              v145 -= 4;
            }
            while (v145);
            unsigned int v147 = 0;
            unsigned int v148 = v141 >> v142;
            uint64_t v149 = (int *)((char *)v137 + 2);
            unsigned int v150 = v97;
            do
            {
              int v151 = *v149++;
              unsigned int v147 = -1640531535 * (v151 + v147) - 1640531535;
              v150 -= 4;
            }
            while (v150);
            LODWORD(v110) = 0;
            __int16 v152 = HIWORD(v136) ^ v136;
            unsigned int v153 = v147 >> v142;
            long long v154 = (unsigned int *)((char *)v137 + 3);
            unsigned int v155 = v97;
            do
            {
              unsigned int v156 = *v154++;
              uint64_t v115 = v156;
              uint64_t v110 = -1640531535 * (v156 + v110) - 1640531535;
              v155 -= 4;
            }
            while (v155);
            __int16 v157 = HIWORD(v141) ^ v141;
            __int16 v158 = HIWORD(v147) ^ v147;
            uint64_t v112 = (_DWORD *)((char *)v130 + 6 * v143);
            int v113 = (_DWORD *)((char *)v130 + 6 * v148);
            uint64_t v111 = (_DWORD *)((char *)v130 + 6 * v153);
          }
          else
          {
            unsigned int v153 = 0;
            __int16 v158 = 0;
            unsigned int v143 = 0;
            __int16 v152 = 0;
            __int16 v157 = 0;
            unsigned int v148 = 0;
            uint64_t v110 = 0;
            int v142 = *(_DWORD *)(v16 + 44);
            uint64_t v111 = v130;
            uint64_t v112 = v130;
            int v113 = v130;
          }
          uint64_t v114 = v110 ^ WORD1(v110);
          long long v159 = (char *)v130 + 6 * (v110 >> v142);
          *uint64_t v112 = v134;
          *((_WORD *)v130 + 3 * v143 + 2) = v152;
          *int v113 = v134 + 1;
          *((_WORD *)v130 + 3 * v148 + 2) = v157;
          *uint64_t v111 = v134 + 2;
          *((_WORD *)v130 + 3 * v153 + 2) = v158;
          *(_DWORD *)long long v159 = v134 + 3;
          *((_WORD *)v159 + 2) = v110 ^ WORD1(v110);
          unsigned int v132 = v135 + 4;
          unsigned int v134 = v135;
        }
        while (v135 + 4 < v131);
      }
      if (v120 && (ThreadPoolSync(v120) & 0x80000000) != 0) {
        break;
      }
      if (v98)
      {
        int v160 = 0;
        int v161 = v98;
        while (1)
        {
          uint64_t v162 = v120
               ? ThreadPoolGetWorker((uint64_t)v120, v110, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116)
               : *v171;
          if (!v162) {
            break;
          }
          *(void *)(v162 + 32) = v130;
          *(_DWORD *)(v162 + 24) = v173 >= *(_DWORD *)(v16 + 32);
          *(_DWORD *)(v162 + 8) = v129;
          *(_DWORD *)(v162 + 12) = v160 * v176;
          unsigned int v163 = v160 * v176 + v176;
          *(_DWORD *)(v162 + 16) = v163;
          unsigned int v164 = *(_DWORD *)(v16 + 36);
          if (v160 * v176 > v164) {
            *(_DWORD *)(v162 + 12) = v164;
          }
          if (v163 > v164) {
            *(_DWORD *)(v162 + 16) = v164;
          }
          if (v120)
          {
            if ((ThreadPoolRunWorker((uint64_t)v120, v162, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116) & 0x80000000) != 0)
            {
              long long v165 = "ThreadPoolRunWorker";
              __int16 v166 = 920;
              goto LABEL_178;
            }
          }
          else
          {
            initBestMatchThreadProc(v162, v162, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116);
          }
          ++v160;
          if (!--v161) {
            goto LABEL_171;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 910, 92, 0, "ThreadPoolGetWorker", v115, v116, v167);
        int v99 = 0;
        goto LABEL_175;
      }
LABEL_171:
      unsigned int v128 = v169 ^ (v120 != 0);
      unsigned int v127 = *(_DWORD *)(v16 + 32);
      v129 += v96;
      if (v173 >= v127)
      {
        int v99 = 1;
LABEL_175:
        long long v102 = v168;
        long long v103 = v171;
        goto LABEL_176;
      }
    }
    long long v165 = "ThreadPoolSync";
    __int16 v166 = 906;
LABEL_178:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v166, 92, 0, v165, v115, v116, v167);
    int v99 = 0;
    long long v102 = v168;
    long long v103 = v171;
    goto LABEL_179;
  }
  int v99 = 1;
LABEL_176:
  if (v120)
  {
LABEL_179:
    if ((ThreadPoolDestroy((uint64_t)v120) & 0x80000000) == 0) {
      goto LABEL_184;
    }
    int v121 = "ThreadPoolDestroy";
    __int16 v122 = 930;
LABEL_181:
    int v126 = 0;
    goto LABEL_182;
  }
LABEL_184:
  free(v102);
  free(v103);
  free(v180);
  free(v181);
  if (v99) {
    goto LABEL_185;
  }
  int64x2_t v88 = "initBestMatchFromHashes";
  __int16 v89 = 1069;
LABEL_106:
  int v87 = 0;
LABEL_108:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", v89, 92, v87, v88, v19, v20, v167);
  BXDiffMatchesDestroy((void **)v16);
  return 0;
}

size_t getProfile(_DWORD *a1, int a2)
{
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  if (a2) {
    int v3 = a2;
  }
  else {
    int v3 = 6;
  }
  switch(v3)
  {
    case 2:
      long long v4 = xmmword_214B12AE0;
      goto LABEL_10;
    case 3:
      long long v4 = xmmword_214B12AD0;
      goto LABEL_10;
    case 4:
      long long v4 = xmmword_214B12AC0;
      goto LABEL_10;
    case 5:
      long long v4 = xmmword_214B12AB0;
      goto LABEL_10;
    case 6:
      *(_OWORD *)a1 = xmmword_214B12AB0;
      uint64_t v5 = 0x1A00000010;
      goto LABEL_30;
    case 7:
      long long v6 = xmmword_214B12AB0;
      goto LABEL_15;
    case 8:
      *(_OWORD *)a1 = xmmword_214B12AA0;
      uint64_t v5 = 0x1A0000000CLL;
      goto LABEL_30;
    case 9:
      long long v6 = xmmword_214B12AA0;
LABEL_15:
      *(_OWORD *)a1 = v6;
      uint64_t v5 = 0x1A00000008;
      goto LABEL_30;
    case 10:
      long long v7 = xmmword_214B12A90;
      goto LABEL_24;
    case 11:
      long long v7 = xmmword_214B12A80;
      goto LABEL_24;
    case 12:
      long long v7 = xmmword_214B12A70;
      goto LABEL_24;
    case 13:
      long long v8 = xmmword_214B12A60;
      goto LABEL_26;
    case 14:
      long long v8 = xmmword_214B12A50;
      goto LABEL_26;
    case 15:
      long long v7 = xmmword_214B12A40;
      goto LABEL_24;
    case 16:
      long long v7 = xmmword_214B12A30;
      goto LABEL_24;
    case 17:
      long long v7 = xmmword_214B12A20;
LABEL_24:
      *(_OWORD *)a1 = v7;
      uint64_t v5 = 24;
      goto LABEL_30;
    case 18:
      long long v8 = xmmword_214B12A20;
LABEL_26:
      *(_OWORD *)a1 = v8;
      uint64_t v5 = 16;
      goto LABEL_30;
    case 19:
      *(_OWORD *)a1 = xmmword_214B12A20;
      uint64_t v5 = 8;
      goto LABEL_30;
    case 20:
      *a1 = 1;
      *(void *)(a1 + 3) = 0;
      *(void *)(a1 + 1) = 0;
      a1[5] = 0;
      goto LABEL_31;
    case 21:
      *(_OWORD *)a1 = xmmword_214B12AB0;
      uint64_t v5 = 0x1800000010;
      goto LABEL_30;
    default:
      long long v4 = xmmword_214B12AF0;
LABEL_10:
      *(_OWORD *)a1 = v4;
      uint64_t v5 = 0x1A00000018;
LABEL_30:
      *((void *)a1 + 2) = v5;
LABEL_31:
      size_t result = (size_t)getenv("BXDIFF_MATCHES_PROFILE");
      if (!result) {
        return result;
      }
      size_t v10 = result;
      size_t result = strlen((const char *)result);
      if (!result) {
        return result;
      }
      size_t v11 = result;
      uint64_t v12 = 0;
      uint64_t v13 = MEMORY[0x263EF8318];
      break;
  }
  while (1)
  {
    unsigned int v14 = __tolower(*(char *)(v10 + v12));
    unsigned int v17 = v14;
    if (v14 > 0x7F)
    {
      if (__maskrune(v14, 0x4000uLL)) {
        goto LABEL_52;
      }
    }
    else if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000) != 0)
    {
      goto LABEL_52;
    }
    char v18 = v17 - 58;
    if (v17 - 58 > 0x39) {
      goto LABEL_44;
    }
    if (((1 << v18) & 0x224820000000000) != 0) {
      break;
    }
    if (((1 << v18) & 3) != 0) {
      goto LABEL_52;
    }
LABEL_44:
    if (v17 != 44)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 505, 92, 0, "Invalid profile code: %c", v15, v16, v17);
      goto LABEL_56;
    }
LABEL_52:
    if (v11 == ++v12) {
      return 0;
    }
  }
  __endptr = 0;
  int v19 = strtol((const char *)(v10 + v12 + 1), &__endptr, 10);
  if (!*__error())
  {
    switch(v17)
    {
      case 'c':
        unsigned int v22 = a1 + 1;
        goto LABEL_51;
      case 'd':
        unsigned int v22 = a1 + 3;
        goto LABEL_51;
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
        goto LABEL_55;
      case 'i':
        unsigned int v22 = a1 + 2;
        goto LABEL_51;
      case 'l':
        unsigned int v22 = a1 + 4;
        goto LABEL_51;
      default:
        unsigned int v22 = a1;
        if (v17 != 115)
        {
LABEL_55:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 515, 92, 0, "Invalid profile code: %c", v20, v21, v17);
          goto LABEL_56;
        }
LABEL_51:
        *unsigned int v22 = v19;
        break;
    }
    goto LABEL_52;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 508, 92, 0, "Invalid profile value: %s", v20, v21, v10 + v12 + 1);
LABEL_56:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"getProfile", 560, 92, 0, "parsing profile: %s", v23, v24, v10);
  return 0xFFFFFFFFLL;
}

void BXDiffMatchesDestroy(void **a1)
{
  if (a1)
  {
    free(a1[7]);
    free(a1[6]);
    free(a1);
  }
}

uint64_t BXDiffMatchesGetBestMatch(uint64_t a1, unsigned int a2, void *a3)
{
  unsigned int v10 = 0;
  if (*(_DWORD *)(a1 + 36) <= a2)
  {
    uint64_t v7 = 0;
    goto LABEL_6;
  }
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    long long v6 = (unsigned int *)(v5 + 8 * a2);
    uint64_t v7 = *v6;
    unsigned int v10 = v7;
    if (v7 != -1)
    {
      LODWORD(result) = v6[1];
      goto LABEL_7;
    }
  }
  uint64_t v7 = *(void *)(a1 + 56);
  if (!v7)
  {
LABEL_6:
    LODWORD(result) = 0;
    goto LABEL_7;
  }
  int v9 = (unsigned int *)(v7 + 4 * *(unsigned __int8 *)(*(void *)(a1 + 24) + a2));
  uint64_t result = bestMatchInRange(a1, v7 + 1028, a2, *v9, v9[1], &v10);
  uint64_t v7 = v10;
  if (v5) {
    *(void *)(v5 + 8 * a2) = v10 | (unint64_t)(result << 32);
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t bestMatchInRange(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, _DWORD *a6)
{
  if (a5 <= a4)
  {
    int v19 = 0;
    uint64_t result = 0;
  }
  else
  {
    unsigned int v6 = 0;
    uint64_t v7 = *(unsigned int *)(a2 + 4 * a4);
    uint64_t v8 = a4;
    int v9 = *(_DWORD *)(a1 + 32);
    unsigned int v10 = *(_DWORD *)(a1 + 36) - a3;
    if (v10 >= v9 - (int)v7) {
      uint64_t v11 = (v9 - v7);
    }
    else {
      uint64_t v11 = v10;
    }
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v13 = *(void *)(a1 + 24);
    uint64_t v14 = v13 + a3;
    while (1)
    {
      unsigned int v15 = v6 + 8;
      if (v6 + 8 > v11) {
        break;
      }
      uint64_t v16 = *(void *)(v12 + v7 + v6);
      uint64_t v17 = *(void *)(v14 + v6);
      v6 += 8;
      unint64_t v18 = v17 ^ v16;
      if (v18)
      {
        LODWORD(v11) = v15 + (__clz(__rbit64(v18)) >> 3) - 8;
        goto LABEL_16;
      }
    }
    if (v6 < v11)
    {
      uint64_t v21 = v11 - v6;
      unsigned int v22 = (unsigned __int8 *)(v13 + a3 + v6);
      uint64_t v23 = (unsigned __int8 *)(v12 + v7 + v6);
      while (1)
      {
        int v25 = *v23++;
        int v24 = v25;
        int v26 = *v22++;
        if (v24 != v26) {
          break;
        }
        ++v6;
        if (!--v21) {
          goto LABEL_16;
        }
      }
      LODWORD(v11) = v6;
    }
LABEL_16:
    unsigned int v27 = 0;
    uint64_t v28 = a5 - 1;
    uint64_t v29 = *(unsigned int *)(a2 + 4 * v28);
    LODWORD(v30) = v9 - v29;
    if (v10 >= v9 - (int)v29) {
      uint64_t v30 = v30;
    }
    else {
      uint64_t v30 = v10;
    }
    while (1)
    {
      unsigned int v31 = v27 + 8;
      if (v27 + 8 > v30) {
        break;
      }
      uint64_t v32 = *(void *)(v12 + v29 + v27);
      uint64_t v33 = *(void *)(v14 + v27);
      v27 += 8;
      unint64_t v34 = v33 ^ v32;
      if (v34)
      {
        LODWORD(v30) = v31 + (__clz(__rbit64(v34)) >> 3) - 8;
        goto LABEL_28;
      }
    }
    if (v27 < v30)
    {
      uint64_t v35 = v30 - v27;
      int v36 = (unsigned __int8 *)(v13 + a3 + v27);
      int v37 = (unsigned __int8 *)(v12 + v29 + v27);
      while (1)
      {
        int v39 = *v37++;
        int v38 = v39;
        int v40 = *v36++;
        if (v38 != v40) {
          break;
        }
        ++v27;
        if (!--v35) {
          goto LABEL_28;
        }
      }
      LODWORD(v30) = v27;
    }
LABEL_28:
    unint64_t v41 = v28 - v8;
    if ((unint64_t)(v28 - v8) < 2)
    {
      uint64_t v42 = v8;
    }
    else
    {
      do
      {
        uint64_t v42 = v8 + (v41 >> 1);
        uint64_t v43 = *(unsigned int *)(a2 + 4 * v42);
        LODWORD(v44) = v9 - v43;
        if (v10 >= v9 - (int)v43) {
          unint64_t v44 = v44;
        }
        else {
          unint64_t v44 = v10;
        }
        if (v11 >= v30) {
          LODWORD(v45) = v30;
        }
        else {
          LODWORD(v45) = v11;
        }
        uint64_t v46 = v12 + v43;
        while (1)
        {
          int v47 = v45 + 8;
          if ((int)v45 + 8 > v44) {
            break;
          }
          uint64_t v48 = *(void *)(v46 + v45);
          uint64_t v49 = *(void *)(v14 + v45);
          LODWORD(v45) = v45 + 8;
          unint64_t v50 = v49 ^ v48;
          if (v50)
          {
            LODWORD(v45) = v47 + (__clz(__rbit64(v50)) >> 3) - 8;
            goto LABEL_39;
          }
        }
        if (v45 >= v44)
        {
LABEL_46:
          LODWORD(v45) = v44;
          goto LABEL_47;
        }
        uint64_t v45 = v45;
        while (*(unsigned __int8 *)(v46 + v45) == *(unsigned __int8 *)(v14 + v45))
        {
          if (++v45 >= v44) {
            goto LABEL_46;
          }
        }
LABEL_39:
        if (v45 < v44
          && *(unsigned __int8 *)(v13 + v45 + a3) < *(unsigned __int8 *)(v12 + (v45 + v43)))
        {
          uint64_t v28 = v42;
          uint64_t v42 = v8;
          LODWORD(v30) = v45;
          goto LABEL_48;
        }
LABEL_47:
        LODWORD(v11) = v45;
        uint64_t v8 = v42;
LABEL_48:
        unint64_t v41 = v28 - v42;
      }
      while ((unint64_t)(v28 - v42) > 1);
    }
    if (v11 <= v30) {
      uint64_t v51 = v28;
    }
    else {
      uint64_t v51 = v42;
    }
    if (v11 <= v30) {
      uint64_t result = v30;
    }
    else {
      uint64_t result = v11;
    }
    int v19 = *(_DWORD *)(a2 + 4 * v51);
  }
  *a6 = v19;
  return result;
}

uint64_t BXDiffMatchesIBuf(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t BXDiffMatchesISize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BXDiffMatchesOBuf(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t BXDiffMatchesOSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

unint64_t quicksort64(unint64_t result, unint64_t *a2, int a3)
{
  BOOL v3 = result > 2;
  if (result >= 2)
  {
    unint64_t v6 = result;
    while (1)
    {
      if (!v3)
      {
        switch(v6)
        {
          case 2uLL:
            unint64_t v33 = *a2;
            unint64_t v34 = a2[1];
            if (HIDWORD(*a2) > HIDWORD(v34))
            {
              *a2 = v34;
              a2[1] = v33;
            }
            break;
          case 3uLL:
            unint64_t v55 = *a2;
            unint64_t v56 = a2[2];
            unint64_t v57 = HIDWORD(*a2);
            if (v57 <= HIDWORD(v56))
            {
              unint64_t v58 = a2[2];
              unint64_t v56 = *a2;
            }
            else
            {
              unint64_t v57 = HIDWORD(v56);
              *a2 = v56;
              a2[2] = v55;
              unint64_t v58 = v55;
            }
            unint64_t v67 = a2[1];
            if (v57 <= HIDWORD(v67))
            {
              unint64_t v57 = HIDWORD(v67);
            }
            else
            {
              *a2 = v67;
              a2[1] = v56;
              unint64_t v67 = v56;
            }
            if (v57 > HIDWORD(v58))
            {
              a2[1] = v58;
              a2[2] = v67;
            }
            break;
          case 4uLL:
            unint64_t v36 = *a2;
            unint64_t v35 = a2[1];
            if (HIDWORD(*a2) <= HIDWORD(v35))
            {
              unint64_t v37 = a2[1];
              unint64_t v35 = *a2;
            }
            else
            {
              *a2 = v35;
              a2[1] = v36;
              unint64_t v37 = v36;
            }
            unint64_t v60 = a2[2];
            unint64_t v59 = a2[3];
            unint64_t v61 = HIDWORD(v60);
            if (HIDWORD(v60) <= HIDWORD(v59))
            {
              unint64_t v62 = a2[3];
              unint64_t v59 = a2[2];
            }
            else
            {
              unint64_t v61 = HIDWORD(v59);
              a2[2] = v59;
              a2[3] = v60;
              unint64_t v62 = v60;
            }
            if (v61 >= HIDWORD(v35))
            {
              unint64_t v35 = v59;
            }
            else
            {
              *a2 = v59;
              a2[2] = v35;
            }
            unint64_t v69 = HIDWORD(v37);
            if (HIDWORD(v37) <= HIDWORD(v62))
            {
              unint64_t v62 = v37;
            }
            else
            {
              unint64_t v69 = HIDWORD(v62);
              a2[1] = v62;
              a2[3] = v37;
            }
            if (v69 > HIDWORD(v35))
            {
              a2[1] = v35;
              a2[2] = v62;
            }
            break;
          case 5uLL:
            unint64_t v38 = *a2;
            unint64_t v39 = a2[1];
            if (HIDWORD(*a2) <= HIDWORD(v39))
            {
              unint64_t v40 = a2[1];
              unint64_t v39 = *a2;
            }
            else
            {
              *a2 = v39;
              a2[1] = v38;
              unint64_t v40 = v38;
            }
            unint64_t v64 = a2[2];
            unint64_t v63 = a2[3];
            unint64_t v65 = HIDWORD(v64);
            if (HIDWORD(v64) <= HIDWORD(v63))
            {
              unint64_t v66 = a2[3];
              unint64_t v63 = a2[2];
            }
            else
            {
              unint64_t v65 = HIDWORD(v63);
              a2[2] = v63;
              a2[3] = v64;
              unint64_t v66 = v64;
            }
            if (v65 >= HIDWORD(v39))
            {
              unint64_t v68 = v63;
              unint64_t v63 = v39;
            }
            else
            {
              *a2 = v63;
              a2[2] = v39;
              unint64_t v68 = v39;
            }
            unint64_t v70 = a2[4];
            unint64_t v71 = HIDWORD(v40);
            if (HIDWORD(v40) <= HIDWORD(v70))
            {
              unint64_t v72 = a2[4];
              unint64_t v70 = v40;
            }
            else
            {
              unint64_t v71 = HIDWORD(v70);
              a2[1] = v70;
              a2[4] = v40;
              unint64_t v72 = v40;
            }
            if (v71 >= HIDWORD(v63))
            {
              unint64_t v63 = v70;
            }
            else
            {
              *a2 = v70;
              a2[1] = v63;
            }
            unint64_t v73 = HIDWORD(v68);
            if (HIDWORD(v68) <= HIDWORD(v66))
            {
              unint64_t v74 = v66;
              unint64_t v66 = v68;
            }
            else
            {
              unint64_t v73 = HIDWORD(v66);
              a2[2] = v66;
              a2[3] = v68;
              unint64_t v74 = v68;
            }
            if (v73 >= HIDWORD(v63))
            {
              unint64_t v63 = v66;
            }
            else
            {
              a2[1] = v66;
              a2[2] = v63;
            }
            unint64_t v75 = HIDWORD(v74);
            if (HIDWORD(v74) <= HIDWORD(v72))
            {
              unint64_t v72 = v74;
            }
            else
            {
              unint64_t v75 = HIDWORD(v72);
              a2[3] = v72;
              a2[4] = v74;
            }
            if (v75 < HIDWORD(v63))
            {
              a2[2] = v72;
              a2[3] = v63;
            }
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (a3 <= 0) {
        break;
      }
      unint64_t v7 = v6 >> 2;
      uint64_t v8 = &a2[v6 >> 1];
      unint64_t v9 = *a2;
      unint64_t v10 = v8[-(v6 >> 2)];
      if (HIDWORD(*a2) > HIDWORD(v10))
      {
        *a2 = v10;
        v8[-(v6 >> 2)] = v9;
        unint64_t v11 = v9;
      }
      else
      {
        unint64_t v11 = v8[-(v6 >> 2)];
        unint64_t v10 = *a2;
      }
      unint64_t v12 = *v8;
      unint64_t v13 = v8[v7];
      unint64_t v14 = HIDWORD(*v8);
      if (v14 <= HIDWORD(v13))
      {
        unint64_t v15 = v8[v7];
        unint64_t v13 = *v8;
      }
      else
      {
        unint64_t v14 = HIDWORD(v13);
        *uint64_t v8 = v13;
        v8[v7] = v12;
        unint64_t v15 = v12;
      }
      if (v14 >= HIDWORD(v10))
      {
        unint64_t v16 = v13;
        unint64_t v13 = v10;
      }
      else
      {
        *a2 = v13;
        *uint64_t v8 = v10;
        unint64_t v16 = v10;
      }
      uint64_t v17 = &a2[v6];
      unint64_t v18 = *(v17 - 1);
      unint64_t v19 = HIDWORD(v11);
      if (HIDWORD(v11) <= HIDWORD(v18))
      {
        unint64_t v20 = *(v17 - 1);
        unint64_t v18 = v11;
      }
      else
      {
        unint64_t v19 = HIDWORD(v18);
        v8[-(v6 >> 2)] = v18;
        *(v17 - 1) = v11;
        unint64_t v20 = v11;
      }
      if (v19 >= HIDWORD(v13))
      {
        unint64_t v13 = v18;
      }
      else
      {
        *a2 = v18;
        v8[-(v6 >> 2)] = v13;
      }
      unint64_t v21 = HIDWORD(v16);
      if (HIDWORD(v16) <= HIDWORD(v15))
      {
        unint64_t v22 = v15;
        unint64_t v15 = v16;
      }
      else
      {
        unint64_t v21 = HIDWORD(v15);
        *uint64_t v8 = v15;
        v8[v7] = v16;
        unint64_t v22 = v16;
      }
      if (v21 >= HIDWORD(v13))
      {
        unint64_t v13 = v15;
      }
      else
      {
        v8[-(v6 >> 2)] = v15;
        *uint64_t v8 = v13;
      }
      unint64_t v23 = HIDWORD(v22);
      if (HIDWORD(v22) <= HIDWORD(v20))
      {
        unint64_t v20 = v22;
      }
      else
      {
        unint64_t v23 = HIDWORD(v20);
        v8[v7] = v20;
        *(v17 - 1) = v22;
      }
      if (v23 < HIDWORD(v13))
      {
        *uint64_t v8 = v20;
        v8[v7] = v13;
      }
      unint64_t v24 = 0;
      unint64_t v25 = *((unsigned int *)v8 + 1);
      int v26 = a2 - 1;
      unint64_t v27 = v6;
      while (1)
      {
        if (v24 < v6)
        {
          while (HIDWORD(a2[v24]) < v25)
          {
            if (v6 == ++v24)
            {
              unint64_t v24 = v6;
              goto LABEL_38;
            }
          }
        }
        do
        {
LABEL_38:
          unint64_t v28 = v27;
          if (!v27) {
            break;
          }
          --v27;
        }
        while (HIDWORD(v26[v28]) >= v25);
        if (v24 >= v28) {
          break;
        }
        if (v24 + 1 != v28)
        {
          unint64_t v29 = a2[v24];
          a2[v24] = v26[v28];
          v26[v28] = v29;
        }
        unint64_t v27 = v28 - 1;
        ++v24;
      }
      for (unint64_t i = v28; i < v6; ++i)
      {
        unint64_t v31 = a2[i];
        if (v25 == HIDWORD(v31))
        {
          if (i != v28)
          {
            unint64_t v32 = a2[v28];
            a2[v28] = v31;
            a2[i] = v32;
          }
          ++v28;
        }
      }
      --a3;
      uint64_t result = quicksort64();
      v6 -= v28;
      a2 += v28;
      BOOL v3 = v6 > 2;
      if (v6 < 2) {
        return result;
      }
    }
    for (uint64_t j = 1; j != v6; ++j)
    {
      unint64_t v42 = a2[j];
      unint64_t v43 = j;
      while (1)
      {
        unint64_t v44 = v43 - 1;
        unint64_t v45 = (v43 - 1) >> 1;
        unint64_t v46 = a2[v45];
        if (v46 >= v42) {
          break;
        }
        a2[v43] = v46;
        unint64_t v43 = (v43 - 1) >> 1;
        if (v44 <= 1) {
          goto LABEL_63;
        }
      }
      unint64_t v45 = v43;
LABEL_63:
      a2[v45] = v42;
    }
    unint64_t v47 = v6 - 1;
    unint64_t v48 = a2[v6 - 1];
    a2[v6 - 1] = *a2;
    if (v6 - 1 >= 2)
    {
      do
      {
        uint64_t v49 = 0;
        unint64_t v50 = 0;
        unint64_t v51 = 1;
        while (1)
        {
          unint64_t v52 = a2[v51];
          unint64_t v53 = v49 + 2;
          if (v49 + 2 < v47)
          {
            unint64_t v54 = a2[v53];
            if (v52 >= v54) {
              unint64_t v53 = v51;
            }
            if (v52 <= v54) {
              unint64_t v52 = v54;
            }
          }
          else
          {
            unint64_t v53 = v51;
          }
          if (v48 >= v52) {
            break;
          }
          a2[v50] = v52;
          uint64_t v49 = 2 * v53;
          unint64_t v51 = (2 * v53) | 1;
          unint64_t v50 = v53;
          if (v51 >= v47) {
            goto LABEL_75;
          }
        }
        unint64_t v53 = v50;
LABEL_75:
        a2[v53] = v48;
        unint64_t v48 = a2[--v47];
        a2[v47] = *a2;
      }
      while (v47 > 1);
    }
    *a2 = v48;
  }
  return result;
}

void **MemBufferCreate(size_t a1)
{
  int v2 = (void **)malloc(0x28uLL);
  BOOL v3 = v2;
  if (v2)
  {
    v2[4] = 0;
    *(_OWORD *)int v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    if ((MemBufferIncreaseCapacity((uint64_t)v2, a1) & 0x8000000000000000) != 0)
    {
      free(v3[4]);
      free(v3);
      return 0;
    }
  }
  else
  {
    long long v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferCreate", 41, 36, *v4, "malloc", v5, v6, v8);
  }
  return v3;
}

unint64_t MemBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  unint64_t result = *(void *)a1;
  if (result < a2)
  {
    uint64_t v5 = reallocf(*(void **)(a1 + 32), a2);
    *(void *)(a1 + 32) = v5;
    if (v5)
    {
      *(void *)a1 = a2;
      return a2;
    }
    else
    {
      uint64_t v6 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseCapacity", 91, 36, *v6, "malloc", v7, v8, v9);
      return -1;
    }
  }
  return result;
}

void MemBufferDestroy(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1);
  }
}

uint64_t MemBufferGetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t MemBufferGetFreeSize(void *a1)
{
  return *a1 - a1[1];
}

uint64_t MemBufferGetDataPtr(uint64_t a1)
{
  return *(void *)(a1 + 32) + *(void *)(a1 + 16);
}

uint64_t MemBufferGetFreePtr(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      memmove(*(void **)(a1 + 32), (const void *)(*(void *)(a1 + 32) + v3), v2);
      uint64_t v4 = *(void *)(a1 + 8);
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = v4;
    }
  }
  return *(void *)(a1 + 32) + *(void *)(a1 + 24);
}

uint64_t MemBufferDecreaseSize(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = (void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t result = v10 - a2;
  if (v10 >= a2)
  {
    if (v10 == a2)
    {
      uint64_t result = 0;
      *char v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
    }
    else
    {
      unint64_t v12 = *(void *)(a1 + 16) + a2;
      *(void *)(a1 + 8) = result;
      *(void *)(a1 + 16) = v12;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferDecreaseSize", 117, 36, 0, "MemBufferDecreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return result;
}

uint64_t MemBufferIncreaseSize(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[3] + a2;
  if (v8 <= *a1)
  {
    a1[3] = v8;
    unint64_t v9 = a1[1] + a2;
    a1[1] = v9;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseSize", 137, 36, 0, "MemBufferIncreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return v9;
}

uint64_t MemBufferFillFromBuffer(unint64_t *a1, size_t a2, const void *a3)
{
  size_t v6 = *a1 - a1[1];
  FreePtr = (void *)MemBufferGetFreePtr((uint64_t)a1);
  if (v6 >= a2)
  {
    memcpy(FreePtr, a3, a2);
    return MemBufferIncreaseSize(a1, a2, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFillFromBuffer", 162, 36, 0, "MemBufferFillFromBuffer n is too large: %zu", v8, v9, a2);
    return -1;
  }
}

uint64_t MemBufferFillFromIStream(unint64_t *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  unint64_t v8 = *a1 - a1[1];
  uint64_t FreePtr = MemBufferGetFreePtr((uint64_t)a1);
  if (v8 >= a2) {
    unint64_t v8 = a2;
  }
  if (v8)
  {
    uint64_t v16 = FreePtr;
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = a3(a4, v16, v8);
      if (v18 < 0) {
        return -1;
      }
      if (v18)
      {
        v16 += v18;
        v17 += v18;
        v8 -= v18;
        if (v8) {
          continue;
        }
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v17 = 0;
LABEL_10:
    return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
  }
}

uint64_t MemBufferFlushToOStream(void *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[1] >= a2) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = a1[1];
  }
  if (v9)
  {
    unint64_t v12 = 0;
    uint64_t v13 = a1[4] + a1[2];
    while (1)
    {
      uint64_t v14 = a3(a4, v13, v9);
      if (v14 < 0) {
        return -1;
      }
      if (!v14)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFlushToOStream", 265, 36, 0, "MemBuffer write proc returned 0", a7, a8, v16);
        return -1;
      }
      v13 += v14;
      v12 += v14;
      v9 -= v14;
      if (!v9) {
        goto LABEL_11;
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
LABEL_11:
    return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

uint64_t MemBufferTransmit(unint64_t *a1, unint64_t a2, size_t (*a3)(int a1, void *a2, size_t a3), uint64_t a4, uint64_t (*a5)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a2;
  if ((unint64_t)a3 | (unint64_t)a5)
  {
    if (a3) {
      uint64_t v11 = a4;
    }
    else {
      uint64_t v11 = 0;
    }
    if (a3) {
      unint64_t v12 = a3;
    }
    else {
      unint64_t v12 = IZeroStreamRead;
    }
    if (a5) {
      uint64_t v13 = a5;
    }
    else {
      uint64_t v13 = ONullStreamWrite;
    }
    if (a5) {
      uint64_t v14 = a6;
    }
    else {
      uint64_t v14 = 0;
    }
    if (*a1)
    {
      a1[1] = 0;
      a1[2] = 0;
      a1[3] = 0;
      uint64_t v9 = 0;
      if (!a2) {
        return v9;
      }
      while (1)
      {
        if (*a1 >= v8) {
          size_t v15 = v8;
        }
        else {
          size_t v15 = *a1;
        }
        uint64_t v16 = v12(v11, (void *)a1[4], v15);
        if (v16 < 0)
        {
          unint64_t v19 = "read failed";
          __int16 v20 = 294;
          goto LABEL_30;
        }
        unint64_t v17 = v16;
        unint64_t v18 = v13(v14, a1[4], v16);
        if ((v18 & 0x8000000000000000) != 0)
        {
          unint64_t v19 = "write failed";
          __int16 v20 = 298;
          goto LABEL_30;
        }
        if (v18 < v17) {
          break;
        }
        if (v17)
        {
          v9 += v17;
          if (v8 == -1) {
            unint64_t v8 = -1;
          }
          else {
            v8 -= v17;
          }
          if (v8) {
            continue;
          }
        }
        return v9;
      }
      unint64_t v19 = "truncated write";
      __int16 v20 = 299;
    }
    else
    {
      unint64_t v19 = "MemBuffer is not allocated";
      __int16 v20 = 281;
    }
LABEL_30:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferTransmit", v20, 36, 0, v19, a7, a8, v22);
    return -1;
  }
  return a2;
}

void MappedBufferDestroy(void *a1)
{
  if (a1)
  {
    size_t v2 = (void *)a1[1];
    if (v2 != (void *)-1) {
      munmap(v2, a1[2]);
    }
    if (*((_DWORD *)a1 + 1) && (*(_DWORD *)a1 & 0x80000000) == 0) {
      close(*(_DWORD *)a1);
    }
    free(a1);
  }
}

void *MappedBufferCreateWithFD(int a1, unint64_t a2, unint64_t a3)
{
  size_t v6 = malloc(0x28uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    v6[3] = 0;
    v6[4] = 0;
    v6[1] = -1;
    _OWORD v6[2] = 0;
    memset(&v23, 0, sizeof(v23));
    int v8 = getpagesize();
    *(_DWORD *)uint64_t v7 = a1;
    *((_DWORD *)v7 + 1) = 0;
    if (a1 < 0)
    {
      uint64_t v13 = "invalid file descriptor";
      __int16 v14 = 397;
LABEL_17:
      int v12 = 0;
      goto LABEL_18;
    }
    int v11 = v8;
    if (fstat(a1, &v23))
    {
      int v12 = *__error();
      uint64_t v13 = "MappedBuffer fstat";
      __int16 v14 = 400;
LABEL_18:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFD", v14, 36, v12, v13, v9, v10, v22);
      MappedBufferDestroy(v7);
      return 0;
    }
    if (v23.st_size <= a2)
    {
      char v22 = a2;
      uint64_t v13 = "invalid offset=%llu for fd";
      __int16 v14 = 401;
      goto LABEL_17;
    }
    if (a3 == -1)
    {
      a3 = v23.st_size - a2;
    }
    else if (a3 + a2 > v23.st_size)
    {
      char v22 = a2;
      uint64_t v13 = "invalid offset=%llu, size=%llu for fd";
      __int16 v14 = 405;
      goto LABEL_17;
    }
    if (!a3)
    {
      char v22 = 0;
      uint64_t v13 = "invalid size=%llu for fd";
      __int16 v14 = 407;
      goto LABEL_17;
    }
    v7[4] = a3;
    off_t v18 = a2 / v11 * v11;
    unint64_t v19 = a2 % v11;
    v7[2] = v19 + a3;
    __int16 v20 = (char *)mmap(0, v19 + a3, 1, 1, a1, v18);
    v7[1] = v20;
    if (v20 == (char *)-1)
    {
      int v12 = *__error();
      uint64_t v13 = "mmap file segment";
      __int16 v14 = 417;
      goto LABEL_18;
    }
    v7[3] = &v20[v19];
  }
  else
  {
    size_t v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFD", 382, 36, *v15, "malloc", v16, v17, v22);
  }
  return v7;
}

uint64_t MappedBufferGetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

size_t IZeroStreamRead(int a1, void *a2, size_t a3)
{
  return a3;
}

uint64_t ONullStreamWrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

void *OSHA1StreamCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v6 = malloc(0x80uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *(_OWORD *)size_t v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)v6);
    v7[13] = a1;
    v7[14] = a2;
    v7[15] = a3;
  }
  else
  {
    int v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OSHA1StreamCreate", 76, 29, *v8, "malloc", v9, v10, v12);
  }
  return v7;
}

void OSHA1StreamDestroy(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  if (c)
  {
    CC_SHA1_Deprecated_Final(md, c);
    free(c);
  }
}

uint64_t OSHA1StreamWrite(CC_SHA1_CTX *c, const void *a2, uint64_t a3)
{
  if (!c || c[1].h0) {
    return -1;
  }
  uint64_t v4 = a3;
  CC_SHA1_Deprecated_Update(c, a2, a3);
  uint64_t v7 = *(uint64_t (**)(uint64_t, const void *, uint64_t))&c[1].h2;
  if (!v7) {
    return v4;
  }
  uint64_t v8 = *(void *)&c[1].Nh;

  return v7(v8, a2, v4);
}

uint64_t OSHA1StreamAbort(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    size_t v2 = *(uint64_t (**)(void))(result + 112);
    if (v2) {
      uint64_t result = v2(*(void *)(result + 120));
    }
    *(_DWORD *)(v1 + 96) = 1;
  }
  return result;
}

uint64_t IFileStreamCreateWithFilename(const char *a1, unint64_t a2, uint64_t a3)
{
  size_t v6 = (char *)malloc(0x70uLL);
  uint64_t v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((void *)v6 + 13) = 0;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    uint64_t v8 = (pthread_mutex_t *)(v6 + 40);
    *(void *)uint64_t v7 = 0x1FFFFFFFFLL;
    uint64_t v9 = a2 + a3;
    if (__CFADD__(a2, a3)) {
      uint64_t v9 = -1;
    }
    *(void *)(v7 + 16) = a2;
    *(void *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0))
    {
      char v12 = "pthread_mutex_init";
      __int16 v13 = 293;
    }
    else
    {
      int v16 = open(a1, 0);
      *(_DWORD *)uint64_t v7 = v16;
      if (v16 < 0)
      {
        int v14 = *__error();
        char v17 = (char)a1;
        char v12 = "%s";
        __int16 v13 = 297;
        goto LABEL_9;
      }
      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0) {
        return v7;
      }
      char v12 = "seek error";
      __int16 v13 = 303;
    }
    int v14 = 0;
  }
  else
  {
    int v14 = *__error();
    char v12 = "malloc";
    __int16 v13 = 282;
  }
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFilename", v13, 29, v14, v12, v10, v11, v17);
  IFileStreamDestroy((char *)v7);
  return 0;
}

uint64_t clampIfRegularFile(uint64_t a1)
{
  memset(&v4, 0, sizeof(v4));
  uint64_t result = fstat(*(_DWORD *)a1, &v4);
  if (!result && (v4.st_mode & 0xF000) == 0x8000)
  {
    st_uint64_t size = v4.st_size;
    if (*(void *)(a1 + 16) > v4.st_size) {
      *(void *)(a1 + 16) = v4.st_size;
    }
    if (*(void *)(a1 + 24) > st_size) {
      *(void *)(a1 + 24) = st_size;
    }
  }
  return result;
}

uint64_t seekTo(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 32) == a2) {
    return 0;
  }
  off_t v4 = lseek(*(_DWORD *)a1, a2, 0);
  if ((v4 & 0x8000000000000000) == 0)
  {
    unint64_t v7 = v4;
    *(void *)(a1 + 32) = v4;
LABEL_4:
    if (v7 == a2) {
      return 0;
    }
    uint64_t v9 = "pos not reached";
    __int16 v10 = 261;
    goto LABEL_10;
  }
  if (*__error() != 32)
  {
    int v11 = *__error();
    uint64_t v9 = "lseek failed";
    __int16 v10 = 258;
    goto LABEL_12;
  }
  unint64_t v7 = *(void *)(a1 + 32);
  if (v7 <= a2)
  {
    char v12 = valloc(0x4000uLL);
    if (!v12)
    {
      int v11 = *__error();
      uint64_t v9 = "malloc";
      __int16 v10 = 244;
      goto LABEL_12;
    }
    for (unint64_t i = v12; v7 < a2; *(void *)(a1 + 32) = v7)
    {
      if (v7 + 0x4000 <= a2) {
        size_t v14 = 0x4000;
      }
      else {
        size_t v14 = a2 - v7;
      }
      ssize_t v15 = read(*(_DWORD *)a1, i, v14);
      unint64_t v7 = *(void *)(a1 + 32);
      if (v15 < 1) {
        break;
      }
      v7 += v15;
    }
    free(i);
    goto LABEL_4;
  }
  uint64_t v9 = "lseek failed and pos < s->pos";
  __int16 v10 = 240;
LABEL_10:
  int v11 = 0;
LABEL_12:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"seekTo", v10, 29, v11, v9, v5, v6, v16);
  return 0xFFFFFFFFLL;
}

void IFileStreamDestroy(char *a1)
{
  if (a1)
  {
    if (*((_DWORD *)a1 + 1))
    {
      int v2 = *(_DWORD *)a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 40));
    free(a1);
  }
}

uint64_t IFileStreamCreateWithFD(int a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (char *)malloc(0x70uLL);
  uint64_t v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((void *)v6 + 13) = 0;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    uint64_t v8 = (pthread_mutex_t *)(v6 + 40);
    *(_DWORD *)uint64_t v7 = a1;
    *(_DWORD *)(v7 + 4) = 0;
    uint64_t v9 = a2 + a3;
    if (__CFADD__(a2, a3)) {
      uint64_t v9 = -1;
    }
    *(void *)(v7 + 16) = a2;
    *(void *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0))
    {
      char v12 = "pthread_mutex_init";
      __int16 v13 = 325;
    }
    else
    {
      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0) {
        return v7;
      }
      char v12 = "seek error";
      __int16 v13 = 331;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFD", v13, 29, 0, v12, v10, v11, v18);
    IFileStreamDestroy((char *)v7);
    return 0;
  }
  else
  {
    size_t v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFD", 314, 29, *v14, "malloc", v15, v16, v18);
  }
  return v7;
}

unint64_t IFileStreamRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (!a3) {
    return 0;
  }
  unint64_t v11 = *(void *)(a1 + 32);
  if (v11 < *(void *)(a1 + 16))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 358, 29, 0, "pos out of range", a7, a8, v21);
    return -1;
  }
  if (~v11 < a3) {
    size_t v12 = ~v11;
  }
  else {
    size_t v12 = a3;
  }
  unint64_t v13 = a3 + v11;
  if (__CFADD__(a3, v11)) {
    unint64_t v13 = -1;
  }
  unint64_t v14 = *(void *)(a1 + 24);
  if (v13 <= v14) {
    size_t v15 = v12;
  }
  else {
    size_t v15 = v14 - v11;
  }
  if (v15)
  {
    unint64_t v8 = 0;
    while (1)
    {
      ssize_t v17 = read(*(_DWORD *)a1, a2, v15);
      if (v17 < 0) {
        break;
      }
      if (v17)
      {
        a2 += v17;
        v8 += v17;
        v15 -= v17;
        if (v15) {
          continue;
        }
      }
      unint64_t v11 = *(void *)(a1 + 32);
      goto LABEL_24;
    }
    char v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 374, 29, *v18, "read", v19, v20, v21);
    *(void *)(a1 + 32) += v8;
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 104), v8);
    return -1;
  }
  unint64_t v8 = 0;
LABEL_24:
  *(void *)(a1 + 32) = v11 + v8;
  atomic_fetch_add((atomic_ullong *volatile)(a1 + 104), v8);
  return v8;
}

int *OFileStreamCreateWithFilename(const char *a1, uint64_t a2)
{
  off_t v4 = (int *)malloc(0x20uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *((void *)v4 + 2) = a2;
    *((void *)v4 + 3) = 0;
    v4[1] = 1;
    *((void *)v4 + 1) = 0;
    int v6 = open(a1, 1537, 420);
    int *v5 = v6;
    if (v6 < 0)
    {
      uint64_t v7 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 490, 29, *v7, "%s", v8, v9, (char)a1);
      free(v5);
      return 0;
    }
  }
  else
  {
    uint64_t v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 484, 29, *v10, "malloc", v11, v12, v14);
  }
  return v5;
}

void OFileStreamDestroy(int *a1)
{
  if (a1)
  {
    if (a1[1])
    {
      int v2 = *a1;
      if ((v2 & 0x80000000) == 0) {
        close(v2);
      }
    }
    free(a1);
  }
}

uint64_t OFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3)
{
  if (*(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (*(void *)(a1 + 16) >= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = *(void *)(a1 + 16);
  }
  if (v5)
  {
    uint64_t v3 = 0;
    while (1)
    {
      size_t v7 = v5 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v5;
      ssize_t v8 = write(*(_DWORD *)a1, __buf, v7);
      if (v8 < 0) {
        break;
      }
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 16);
        if (v9 != -1) {
          *(void *)(a1 + 16) = v9 - v8;
        }
        __buf += v8;
        v3 += v8;
        v5 -= v8;
        if (v5) {
          continue;
        }
      }
      goto LABEL_18;
    }
    uint64_t v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamWrite", 538, 29, *v11, "write", v12, v13, v14);
    return -1;
  }
  uint64_t v3 = 0;
LABEL_18:
  *(void *)(a1 + 24) += v3;
  return v3;
}

int *OArchiveFileStreamCreate(const char *a1, unint64_t a2, unsigned int a3, int a4, int a5)
{
  uint64_t v10 = (int *)malloc(0x60uLL);
  uint64_t v11 = v10;
  if (v10)
  {
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *(_OWORD *)uint64_t v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    if ((a3 & 0x100) == 0) {
      unlink(a1);
    }
    v11[1] = (a3 >> 4) & 1;
    *((void *)v11 + 2) = a2;
    if (a3) {
      int v12 = 4;
    }
    else {
      int v12 = a4;
    }
    if (v12 < 1)
    {
      int v13 = open(a1, 1537, 420);
      *uint64_t v11 = v13;
      if (v13 < 0)
      {
        __int16 v14 = 648;
        goto LABEL_31;
      }
    }
    else
    {
      int v13 = open_dprotected_np(a1, 1537, v12, 0, 420);
      *uint64_t v11 = v13;
      if (v13 < 0)
      {
        __int16 v14 = 640;
LABEL_31:
        unint64_t v37 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", v14, 29, *v37, "%s", v38, v39, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v40, v41, v42, v43, v44, v45, v46);
        goto LABEL_32;
      }
    }
    if ((a3 & 8) != 0 && fcntl(v13, 48, 1)) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 656, 29, "Warning: F_NOCACHE failed: %s\n", v18, v19, v20, (char)a1);
    }
    if ((a3 & 2) != 0 && fcntl(v13, 68, 1) == -1)
    {
      char v21 = __error();
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 665, 29, "Warning: F_SETSTATICCONTENT failed with error %d: %s\n", v22, v23, v24, *v21);
    }
    if (a2 && (a3 & 4) != 0 && a5 != -1)
    {
      if ((a3 & 0x80) != 0) {
        int v25 = 6;
      }
      else {
        int v25 = 4;
      }
      int v26 = ParallelCompressionAFSCStreamOpen(v13, a2, a5, v25);
      *((void *)v11 + 3) = v26;
      if (!v26)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 677, 29, 0, "ParallelCompressionAFSCStreamOpen failed: %s", v27, v28, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v29, v30, v31, v32, v33, v34, v35);
        close(v13);
LABEL_32:
        free(v11);
        return 0;
      }
    }
    else if ((a3 & 0x40) != 0)
    {
      uint64_t v36 = fpathconf(v13, 27);
      if (v36 >= 1)
      {
        v11[10] = 1;
        if (v36 == 4096)
        {
          v11[18] = 4096;
        }
        else
        {
          unsigned int v48 = 0x10000;
          if (v36 < 0x10000) {
            unsigned int v48 = v36;
          }
          int v49 = 1024;
          do
          {
            unsigned int v50 = v49;
            v49 *= 2;
          }
          while (v50 < v48);
          v11[18] = v50;
        }
      }
    }
  }
  else
  {
    size_t v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 617, 29, *v15, "malloc", v16, v17, v51);
  }
  return v11;
}

uint64_t OArchiveFileStreamDestroy(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OArchiveFileStreamDestroyEx(a1, 0, 0, 0, a5, a6, a7, a8);
}

uint64_t OArchiveFileStreamDestroyEx(unsigned int *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v10 = a2;
  if (*((void *)a1 + 2)) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 863, 29, "OArchiveFileStream didn't receive enough data before being destroyed\n", a6, a7, a8, v27);
  }
  ParallelCompressionAFSCStreamClose(*((void *)a1 + 3), a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if ((*a1 & 0x80000000) != 0)
  {
    uint64_t v13 = 0;
    uint64_t v19 = 0xFFFFFFFFLL;
    if (!a3) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (*((void *)a1 + 7))
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v15 = *((void *)a1 + 8);
    while (fcntl(*a1, 99, v15 + v12) != -1)
    {
      uint64_t v15 = *((void *)a1 + 8);
      v13 += *(void *)(v15 + v12 + 16);
      ++v14;
      v12 += 24;
      if (v14 >= *((void *)a1 + 7)) {
        goto LABEL_15;
      }
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 875, 29, "F_PUNCHHOLE failed", v16, v17, v18, v27);
  }
  else
  {
    uint64_t v13 = 0;
  }
LABEL_15:
  if (a1[1])
  {
    char v27 = 0;
    if (fcntl(*a1, 51) == -1)
    {
      uint64_t v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 883, 29, *v20, "Final FULLSYNC", v21, v22, 0);
    }
  }
  uint64_t v19 = *a1;
  if (!v10)
  {
    if (close(*a1))
    {
      uint64_t v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 890, 29, *v24, "close", v25, v26, v27);
    }
    uint64_t v19 = 0xFFFFFFFFLL;
    *a1 = -1;
    if (!a3) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (a3) {
LABEL_20:
  }
    *a3 = *((void *)a1 + 4) - v13;
LABEL_21:
  if (a4) {
    *a4 = v13;
  }
  free(*((void **)a1 + 8));
  free(a1);
  return v19;
}

uint64_t OArchiveFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1;
  }
  unint64_t v11 = a3;
  if (a3)
  {
    uint64_t v9 = 0;
    unsigned int v48 = (unint64_t *)(a1 + 48);
    unint64_t v13 = *(void *)(a1 + 16);
    while (v13)
    {
      if (v13 >= v11) {
        unint64_t v13 = v11;
      }
      if (v13 >= 0x40000000) {
        unint64_t v14 = 0x40000000;
      }
      else {
        unint64_t v14 = v13;
      }
      uint64_t v15 = *(void *)(a1 + 24);
      if (v15)
      {
        uint64_t v16 = ParallelCompressionAFSCStreamWrite(v15, (uint64_t)__buf, v14, a4, a5, a6, a7, a8);
        ssize_t v17 = v16;
        if (v16 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 955, 29, 0, "ParallelCompressionAFSCStreamWrite failed with status %d", a7, a8, v16);
          return -1;
        }
      }
      else
      {
        if ((*(_DWORD *)a1 & 0x80000000) != 0) {
          return -1;
        }
        ssize_t v17 = write(*(_DWORD *)a1, __buf, v14);
        if (v17 < 0)
        {
          int v44 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 960, 29, v44, "write", v45, v46, v47);
          return -1;
        }
      }
      if (*(_DWORD *)(a1 + 40))
      {
        unint64_t v18 = 0;
        LODWORD(v19) = *(_DWORD *)(a1 + 72);
        int v20 = *(_DWORD *)(a1 + 76);
        do
        {
          uint64_t v21 = (v19 - v20);
          if (v18 + v21 <= v14) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = (v14 - v18);
          }
          uint64_t v23 = &__buf[v18];
          uint64_t v24 = &__buf[v18 + v22];
          if (((unint64_t)&__buf[v18] & 7) != 0 && v22)
          {
            uint64_t v25 = &__buf[v18 + 1];
            while (!*v23)
            {
              if (++v23 < v24)
              {
                if ((unint64_t)(v25++ & 7)) {
                  continue;
                }
              }
              goto LABEL_29;
            }
LABEL_35:
            int v28 = 1;
          }
          else
          {
LABEL_29:
            while (v23 + 8 <= v24)
            {
              uint64_t v27 = *(void *)v23;
              v23 += 8;
              if (v27) {
                goto LABEL_35;
              }
            }
            while (v23 < v24)
            {
              if (*v23) {
                goto LABEL_35;
              }
              ++v23;
            }
            int v28 = 0;
          }
          int v29 = *(_DWORD *)(a1 + 88) | v28;
          *(_DWORD *)(a1 + 88) = v29;
          v20 += v22;
          *(_DWORD *)(a1 + 76) = v20;
          if (v20 == v19)
          {
            if (!v29)
            {
              uint64_t v30 = *(void *)(a1 + 80);
              unint64_t v31 = *(void *)(a1 + 56);
              if (v31
                && (uint64_t v32 = *(void *)(a1 + 64) + 24 * v31,
                    uint64_t v35 = *(void *)(v32 - 8),
                    uint64_t v33 = (void *)(v32 - 8),
                    uint64_t v34 = v35,
                    v35 + *(v33 - 1) == v30))
              {
                void *v33 = v34 + v19;
              }
              else
              {
                unint64_t v36 = *v48;
                if (v31 >= *v48)
                {
                  uint64_t v37 = v36 + (v36 >> 1);
                  BOOL v38 = v36 == 0;
                  uint64_t v39 = 32;
                  if (!v38) {
                    uint64_t v39 = v37;
                  }
                  *(void *)(a1 + 48) = v39;
                  uint64_t v40 = reallocf(*(void **)(a1 + 64), 24 * v39);
                  *(void *)(a1 + 64) = v40;
                  if (!v40)
                  {
                    *unsigned int v48 = 0;
                    v48[1] = 0;
                    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 994, 29, "malloc holes failed", a6, a7, a8, v47);
                  }
                }
                unint64_t v41 = *(void *)(a1 + 56);
                if (v41 >= *(void *)(a1 + 48))
                {
                  LODWORD(v19) = *(_DWORD *)(a1 + 72);
                }
                else
                {
                  uint64_t v42 = *(void *)(a1 + 64);
                  *(void *)(a1 + 56) = v41 + 1;
                  uint64_t v43 = (void *)(v42 + 24 * v41);
                  *uint64_t v43 = 0;
                  v43[1] = 0;
                  v43[1] = v30;
                  v43[2] = 0;
                  uint64_t v19 = *(unsigned int *)(a1 + 72);
                  v43[2] = v19;
                }
              }
            }
            int v20 = 0;
            *(void *)(a1 + 80) += v19;
            *(_DWORD *)(a1 + 76) = 0;
            *(_DWORD *)(a1 + 88) = 0;
          }
          v18 += v22;
        }
        while (v18 < v14);
      }
      __buf += v17;
      v9 += v17;
      unint64_t v13 = *(void *)(a1 + 16) - v17;
      *(void *)(a1 + 16) = v13;
      v11 -= v17;
      if (!v11) {
        break;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  *(void *)(a1 + 32) += v9;
  return v9;
}

void *OMemStreamCreate(uint64_t a1, uint64_t a2)
{
  off_t v4 = malloc(0x20uLL);
  unint64_t v5 = v4;
  if (v4)
  {
    void *v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    v4[3] = 0;
  }
  else
  {
    int v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OMemStreamCreate", 1050, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

uint64_t OMemStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (*(void *)(a1 + 16) >= a3) {
    size_t v4 = a3;
  }
  else {
    size_t v4 = *(void *)(a1 + 16);
  }
  memcpy(*(void **)a1, a2, v4);
  *(void *)a1 += v4;
  size_t v5 = *(void *)(a1 + 24) + v4;
  *(void *)(a1 + 16) -= v4;
  *(void *)(a1 + 24) = v5;
  return v4;
}

void *IMemStreamCreate(uint64_t a1, uint64_t a2)
{
  size_t v4 = malloc(0x20uLL);
  size_t v5 = v4;
  if (v4)
  {
    void *v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    v4[3] = 0;
  }
  else
  {
    int v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMemStreamCreate", 1112, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

size_t IMemStreamRead(uint64_t a1, void *__dst, size_t a3)
{
  if (!a1 || *(_DWORD *)(a1 + 8)) {
    return -1;
  }
  if (*(void *)(a1 + 16) >= a3) {
    size_t v4 = a3;
  }
  else {
    size_t v4 = *(void *)(a1 + 16);
  }
  memcpy(__dst, *(const void **)a1, v4);
  *(void *)a1 += v4;
  size_t v5 = *(void *)(a1 + 24) + v4;
  *(void *)(a1 + 16) -= v4;
  *(void *)(a1 + 24) = v5;
  return v4;
}

uint64_t IMemStreamAbort(uint64_t result)
{
  if (result) {
    *(_DWORD *)(result + 8) = 1;
  }
  return result;
}

char *OBufferedStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4)
{
  uint64_t v8 = (char *)malloc(0x28uLL);
  uint64_t v9 = v8;
  if (v8)
  {
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 8) = 0u;
    char v10 = MemBufferCreate(a4);
    *(void *)uint64_t v9 = v10;
    if (v10)
    {
      *((void *)v9 + 1) = a1;
      *((void *)v9 + 2) = a2;
      *((void *)v9 + 3) = a3;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1182, 29, 0, "creating internal buffer", v11, v12, v24);
      OBufferedStreamDestroy((void ***)v9, v16, v17, v18, v19, v20, v21, v22);
      return 0;
    }
  }
  else
  {
    unint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1176, 29, *v13, "malloc", v14, v15, v24);
  }
  return v9;
}

void OBufferedStreamDestroy(void ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], a5, a6, a7, a8);
    MemBufferDestroy(*a1);
    free(a1);
  }
}

uint64_t OBufferedStreamWrite(unint64_t **a1, char *a2, unint64_t a3)
{
  if (a1 && !*((_DWORD *)a1 + 8))
  {
    unint64_t v6 = a3;
    if (!a3) {
      return 0;
    }
    uint64_t v4 = 0;
    while (1)
    {
      unint64_t FreeSize = MemBufferGetFreeSize(*a1);
      if (!FreeSize)
      {
        if (MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], v9, v10, v11, v12) < 0)return -1; {
        unint64_t FreeSize = MemBufferGetFreeSize(*a1);
        }
      }
      size_t v13 = v6 >= FreeSize ? FreeSize : v6;
      if (MemBufferFillFromBuffer(*a1, v13, a2) < 0) {
        break;
      }
      a2 += v13;
      v4 += v13;
      v6 -= v13;
      if (!v6) {
        return v4;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamWrite", 1221, 29, 0, "MemBufferFillFromBuffer failed", v14, v15, v16);
  }
  return -1;
}

void *aaAssetDecompressionStreamOpen(uint64_t a1)
{
  int v2 = malloc(0x70uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    __int16 v6 = 277;
LABEL_6:
    uint64_t v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"aaAssetDecompressionStreamOpen", v6, 132, *v7, "malloc", v8, v9, v11);
    closeProc_0((uint64_t)v3);
    return 0;
  }
  memset_s(v2, 0x70uLL, 0, 0x70uLL);
  *uint64_t v3 = a1;
  uint64_t v4 = malloc(0x38uLL);
  if (!v4)
  {
    __int16 v6 = 282;
    goto LABEL_6;
  }
  size_t v5 = v4;
  memset_s(v4, 0x38uLL, 0, 0x38uLL);
  void *v5 = v3;
  v5[1] = closeProc_0;
  v5[6] = closeWithStateProc_0;
  v5[3] = writeProc_0;
  v5[2] = cancelProc_0;
  return v5;
}

uint64_t closeProc_0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 8));
    uint64_t v3 = (void *)(result + 56);
    free(*(void **)(result + 72));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    free(v1[12]);
    memset_s(v1 + 10, 0x18uLL, 0, 0x18uLL);
    memset_s(v1, 0x70uLL, 0, 0x70uLL);
    free(v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t closeWithStateProc_0(uint64_t result, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v9 = result;
    unsigned int v10 = atomic_load((unsigned int *)(result + 8));
    uint64_t v12 = (uint64_t *)(result + 80);
    uint64_t v11 = *(void *)(result + 80);
    uint64_t v32 = *(void *)(result + 24);
    long long v13 = *(_OWORD *)(result + 48);
    long long v33 = *(_OWORD *)(result + 32);
    long long v34 = v13;
    BOOL v14 = v10 == 0;
    uint64_t v15 = (uint64_t *)(result + 56);
    uint64_t v16 = *(void *)(result + 104);
    uint64_t v35 = v11;
    uint64_t v36 = v16;
    if (a2[3])
    {
      uint64_t v18 = 0;
      uint64_t v19 = &v32;
      uint64_t v20 = 56;
      while (1)
      {
        uint64_t v21 = ((uint64_t (*)(void, uint64_t *, uint64_t))a2[3])(*a2, v19, v20);
        if (v21 < 1) {
          break;
        }
        uint64_t v19 = (uint64_t *)((char *)v19 + v21);
        v18 += v21;
        v20 -= v21;
        if (!v20)
        {
          if (v18 != 56) {
            break;
          }
          if (!a2[3]) {
            goto LABEL_29;
          }
          uint64_t v22 = *v15;
          if (*v15)
          {
            uint64_t v23 = 0;
            uint64_t v24 = *(void *)(v9 + 72);
            while (1)
            {
              uint64_t v25 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v24, v22);
              if (v25 < 1) {
                break;
              }
              v24 += v25;
              v23 += v25;
              v22 -= v25;
              if (!v22) {
                goto LABEL_18;
              }
            }
            uint64_t v23 = v25;
LABEL_18:
            if (v23 < 0 || !a2[3]) {
              goto LABEL_29;
            }
          }
          uint64_t v27 = *v12;
          if (*v12)
          {
            uint64_t v28 = 0;
            uint64_t v29 = *(void *)(v9 + 96);
            while (1)
            {
              uint64_t v30 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v29, v27);
              if (v30 < 1) {
                break;
              }
              v29 += v30;
              v28 += v30;
              v27 -= v30;
              if (!v27) {
                goto LABEL_26;
              }
            }
            uint64_t v28 = v30;
LABEL_26:
            if (v28 < 0)
            {
LABEL_29:
              __int16 v26 = 250;
              goto LABEL_14;
            }
          }
          if (a3) {
            *a3 = *(void *)(v9 + 104);
          }
          goto LABEL_15;
        }
      }
    }
    __int16 v26 = 245;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"closeWithStateProc", v26, 132, 0, "write state", a7, a8, v31);
    BOOL v14 = 0;
LABEL_15:
    free(*(void **)(v9 + 72));
    memset_s(v12 - 3, 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v9 + 96));
    memset_s(v12, 0x18uLL, 0, 0x18uLL);
    memset_s((void *)v9, 0x70uLL, 0, 0x70uLL);
    free((void *)v9);
    return (v14 - 1);
  }
  return result;
}

uint64_t writeProc_0(void **a1, char *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)a1 + 2)) {
    return -1;
  }
  uint64_t v9 = 0;
  BOOL v14 = (unint64_t *)(a1 + 7);
  unint64_t v13 = (unint64_t)a1[7];
  uint64_t v15 = (unint64_t *)(a1 + 10);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v16 = *((_DWORD *)a1 + 6);
        if (v16 != 2) {
          break;
        }
        uint64_t v17 = a1[5];
        size_t v18 = (size_t)v17 - v13;
        if ((unint64_t)v17 <= v13)
        {
          long long v34 = (uint64_t (*)(char *))a1[2];
          if (v34 && a1[6] != v17)
          {
            if (v17 != (void *)v13 || (uint64_t v39 = (char *)a1[10], (char *)a1[11] - v39 < (unint64_t)a1[4]))
            {
              unint64_t v56 = "invalid state";
              __int16 v57 = 174;
              goto LABEL_126;
            }
            uint64_t v40 = v34(&v39[(void)a1[12]]);
            if ((void *)v40 != a1[6])
            {
              unint64_t v56 = "corrupted stream";
              __int16 v57 = 176;
              goto LABEL_126;
            }
            unint64_t v13 = *v15;
            if (v40)
            {
              BOOL v41 = __CFADD__(v13, v40);
              v13 += v40;
              if (v41 || v13 > (unint64_t)a1[11])
              {
                unint64_t v56 = "invalid size";
                __int16 v57 = 177;
                goto LABEL_126;
              }
              *uint64_t v15 = v13;
            }
            uint64_t v35 = v15;
            if (v13)
            {
LABEL_67:
              unint64_t v42 = v35[2];
              while (1)
              {
                uint64_t v43 = (uint64_t (*)(void, unint64_t, unint64_t))(*a1)[3];
                if (!v43) {
                  break;
                }
                uint64_t v44 = v43(**a1, v42, v13);
                if (v44 <= 0) {
                  break;
                }
                v42 += v44;
                v13 -= v44;
                if (!v13) {
                  goto LABEL_71;
                }
              }
              unint64_t v56 = "write";
              __int16 v57 = 187;
              goto LABEL_126;
            }
          }
          else
          {
            uint64_t v35 = v14;
            if (v13) {
              goto LABEL_67;
            }
          }
LABEL_71:
          unint64_t v13 = 0;
          a1[7] = 0;
          a1[10] = 0;
          *((_DWORD *)a1 + 6) = 1;
        }
        else
        {
          if (!a3) {
            goto LABEL_106;
          }
LABEL_7:
          if (v18 >= a3) {
            size_t v19 = a3;
          }
          else {
            size_t v19 = v18;
          }
          unint64_t v20 = v13 + v19;
          if (__CFADD__(v13, v19) || (v20 & 0x8000000000000000) != 0) {
            goto LABEL_119;
          }
          unint64_t v21 = (unint64_t)a1[8];
          if (v21 < v20)
          {
            do
            {
              while (!v21)
              {
                unint64_t v21 = 0x4000;
                size_t v23 = 0x4000;
                if (v20 <= 0x4000) {
                  goto LABEL_51;
                }
              }
              unint64_t v22 = v21 >> 1;
              if ((v21 & (v21 >> 1)) != 0) {
                unint64_t v22 = v21 & (v21 >> 1);
              }
              v21 += v22;
            }
            while (v21 < v20);
            size_t v23 = v21;
            if (v21 >= 0x2000000001)
            {
              *__error() = 12;
              goto LABEL_118;
            }
LABEL_51:
            uint64_t v36 = a1[9];
            uint64_t v37 = realloc(v36, v23);
            if (v37)
            {
              a1[8] = (void *)v23;
              a1[9] = v37;
              goto LABEL_53;
            }
            free(v36);
LABEL_118:
            *BOOL v14 = 0;
            v14[1] = 0;
            v14[2] = 0;
LABEL_119:
            unint64_t v56 = "malloc";
            __int16 v57 = 209;
            goto LABEL_126;
          }
LABEL_53:
          BOOL v38 = a1[9];
          if (__src)
          {
            memcpy((char *)v38 + *v14, __src, v19);
          }
          else if (v38)
          {
            memset_s((char *)v38 + *v14, v19, 0, v19);
          }
          unint64_t v13 = *v14 + v19;
          *BOOL v14 = v13;
          if ((v19 & 0x8000000000000000) != 0) {
            goto LABEL_119;
          }
          a3 -= v19;
          __src += v19;
          v9 += v19;
          a1[13] = (void *)((char *)a1[13] + v19);
        }
      }
      if (v16 == 1) {
        break;
      }
      if (v16)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"writeProc", 199, 132, 0, "invalid state %d", a7, a8, *((_DWORD *)a1 + 6));
        goto LABEL_127;
      }
      if (!(a3 | v13)) {
        goto LABEL_106;
      }
      if (v13 <= 0xB)
      {
        uint64_t v55 = 12;
        goto LABEL_105;
      }
      uint64_t v24 = a1[9];
      *(void *)unint64_t v62 = *(void *)v24;
      *(_DWORD *)&v62[8] = v24[2];
      if ((unsigned __int16)*(void *)v24 != 25200 || BYTE2(*(void *)v24) != 122)
      {
LABEL_111:
        unint64_t v56 = "invalid compressed stream";
        __int16 v57 = 106;
        goto LABEL_126;
      }
      if (v62[3] <= 100)
      {
        switch(v62[3])
        {
          case '-':
            int v27 = 0;
            __int16 v26 = 0;
            break;
          case '4':
            __int16 v26 = PCompressLZ4Decode;
            int v27 = 256;
            break;
          case 'b':
            __int16 v26 = PCompressLZBITMAPDecode;
            int v27 = 1794;
            break;
          default:
            goto LABEL_111;
        }
      }
      else if (v62[3] > 119)
      {
        if (v62[3] == 120)
        {
          __int16 v26 = PCompressLZMADecode;
          int v27 = 774;
        }
        else
        {
          if (v62[3] != 122) {
            goto LABEL_111;
          }
          __int16 v26 = PCompressZLIBDecode;
          int v27 = 1285;
        }
      }
      else if (v62[3] == 101)
      {
        __int16 v26 = PCompressLZFSEDecode;
        int v27 = 2049;
      }
      else
      {
        if (v62[3] != 102) {
          goto LABEL_111;
        }
        __int16 v26 = PCompressLZVNDecode;
        int v27 = 2304;
      }
      *((_DWORD *)a1 + 7) = v27;
      unint64_t v45 = bswap64(*(unint64_t *)&v62[4]);
      a1[4] = (void *)v45;
      a1[2] = v26;
      if ((v45 & 0x8000000000000000) != 0) {
        goto LABEL_125;
      }
      unint64_t v46 = (unint64_t)a1[8];
      if (v46 < v45)
      {
        do
        {
          while (!v46)
          {
            unint64_t v46 = 0x4000;
            size_t v48 = 0x4000;
            if (v45 <= 0x4000) {
              goto LABEL_89;
            }
          }
          unint64_t v47 = v46 >> 1;
          if ((v46 & (v46 >> 1)) != 0) {
            unint64_t v47 = v46 & (v46 >> 1);
          }
          v46 += v47;
        }
        while (v46 < v45);
        size_t v48 = v46;
        if (v46 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_124;
        }
LABEL_89:
        int v49 = realloc(v24, v48);
        if (!v49)
        {
          free(v24);
          goto LABEL_124;
        }
        a1[8] = (void *)v48;
        a1[9] = v49;
        unint64_t v45 = (unint64_t)a1[4];
        if ((v45 & 0x8000000000000000) != 0) {
          goto LABEL_125;
        }
      }
      unint64_t v50 = (unint64_t)a1[11];
      if (v50 < v45)
      {
        do
        {
          while (!v50)
          {
            unint64_t v50 = 0x4000;
            size_t v52 = 0x4000;
            if (v45 <= 0x4000) {
              goto LABEL_100;
            }
          }
          unint64_t v51 = v50 >> 1;
          if ((v50 & (v50 >> 1)) != 0) {
            unint64_t v51 = v50 & (v50 >> 1);
          }
          v50 += v51;
        }
        while (v50 < v45);
        size_t v52 = v50;
        if (v50 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_123;
        }
LABEL_100:
        unint64_t v53 = a1[12];
        unint64_t v54 = realloc(v53, v52);
        if (v54)
        {
          a1[11] = (void *)v52;
          a1[12] = v54;
          goto LABEL_102;
        }
        free(v53);
LABEL_123:
        BOOL v14 = v15;
LABEL_124:
        *BOOL v14 = 0;
        v14[1] = 0;
        v14[2] = 0;
LABEL_125:
        unint64_t v56 = "reserve buffers";
        __int16 v57 = 128;
LABEL_126:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"writeProc", v57, 132, 0, v56, a7, a8, v61);
LABEL_127:
        uint64_t v9 = -1;
        goto LABEL_128;
      }
LABEL_102:
      unint64_t v13 = 0;
      a1[7] = 0;
      *((_DWORD *)a1 + 6) = 1;
    }
    if (!(a3 | v13)) {
      goto LABEL_106;
    }
    if (v13 <= 0xF) {
      break;
    }
    uint64_t v28 = a1[9];
    unint64_t v29 = v28[1];
    unint64_t v30 = bswap64(*v28);
    unint64_t v31 = bswap64(v29);
    a1[5] = (void *)v31;
    a1[6] = (void *)v30;
    if (v30 < v31
      || ((uint64_t v32 = a1[4], v30 <= (unint64_t)v32) ? (v33 = v31 > (unint64_t)v32) : (v33 = 1), v33))
    {
      unint64_t v56 = "invalid compressed stream";
      __int16 v57 = 149;
      goto LABEL_126;
    }
    unint64_t v13 = 0;
    a1[7] = 0;
    *((_DWORD *)a1 + 6) = 2;
  }
  uint64_t v55 = 16;
LABEL_105:
  size_t v18 = v55 - v13;
  if (a3) {
    goto LABEL_7;
  }
LABEL_106:
  if ((v9 & 0x8000000000000000) == 0) {
    return v9;
  }
LABEL_128:
  int v58 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)a1 + 2, (unsigned int *)&v58, 1u);
  if (!v58)
  {
    unint64_t v59 = (void (*)(void))(*a1)[2];
    if (v59) {
      v59(**a1);
    }
  }
  return v9;
}

atomic_uint *cancelProc_0(atomic_uint *result)
{
  int v1 = 0;
  atomic_compare_exchange_strong(result + 2, (unsigned int *)&v1, 1u);
  if (!v1)
  {
    unsigned int v2 = *(uint64_t (**)(void))(*(void *)result + 16);
    if (v2) {
      return (atomic_uint *)v2(**(void **)result);
    }
  }
  return result;
}

void (**aaAssetDecompressionStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, void *a3))(void)
{
  size_t v5 = (void (**)(void))aaAssetDecompressionStreamOpen(a1);
  uint64_t v8 = v5;
  if (!v5) {
    return v8;
  }
  uint64_t v9 = *v5;
  uint64_t v61 = 0;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v58 = 0u;
  if (!*((void *)a2 + 2))
  {
LABEL_14:
    unint64_t v21 = "truncated state";
    __int16 v22 = 316;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecompressionStream.c", (uint64_t)"aaAssetDecompressionStreamOpenWithState", v22, 132, 0, v21, v6, v7, v58);
    if (*v8) {
      v8[1]();
    }
    free(v8);
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = &v58;
  uint64_t v12 = 56;
  do
  {
    uint64_t v13 = (*((uint64_t (**)(void, long long *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
    if (v13 < 0) {
      goto LABEL_14;
    }
    if (!v13) {
      break;
    }
    uint64_t v11 = (long long *)((char *)v11 + v13);
    v10 += v13;
    v12 -= v13;
  }
  while (v12);
  if (v10 < 0) {
    goto LABEL_14;
  }
  unsigned int v15 = v58;
  int v14 = DWORD1(v58);
  *((_DWORD *)v9 + 6) = v58;
  *((_DWORD *)v9 + 7) = v14;
  unint64_t v16 = *((void *)&v58 + 1);
  unint64_t v17 = v59;
  *((void *)v9 + 4) = *((void *)&v58 + 1);
  *((void *)v9 + 5) = v17;
  unint64_t v18 = *((void *)&v59 + 1);
  uint64_t v19 = v61;
  *((void *)v9 + 6) = *((void *)&v59 + 1);
  *((void *)v9 + 13) = v19;
  if (v15 >= 3)
  {
    unint64_t v21 = "invalid state";
    __int16 v22 = 330;
    goto LABEL_15;
  }
  unint64_t v20 = PCompressZLIBDecode;
  if (v14 <= 1284)
  {
    switch(v14)
    {
      case 0:
        unint64_t v20 = 0;
        goto LABEL_30;
      case 256:
        unint64_t v20 = PCompressLZ4Decode;
        goto LABEL_30;
      case 774:
        unint64_t v20 = PCompressLZMADecode;
        goto LABEL_30;
    }
    goto LABEL_45;
  }
  if (v14 > 2048)
  {
    if (v14 == 2049)
    {
      unint64_t v20 = PCompressLZFSEDecode;
      goto LABEL_30;
    }
    if (v14 == 2304)
    {
      unint64_t v20 = PCompressLZVNDecode;
      goto LABEL_30;
    }
    goto LABEL_45;
  }
  if (v14 != 1285)
  {
    if (v14 == 1794)
    {
      unint64_t v20 = PCompressLZBITMAPDecode;
      goto LABEL_30;
    }
LABEL_45:
    unint64_t v21 = "invalid compression algo";
    __int16 v22 = 342;
    goto LABEL_15;
  }
LABEL_30:
  *((void *)v9 + 2) = v20;
  if (v17 > v16 || v18 > v16 || (unint64_t)v60 > v17 || v17 > v18 || *((void *)&v60 + 1) > v18)
  {
    unint64_t v21 = "invalid sizes";
    __int16 v22 = 352;
    goto LABEL_15;
  }
  if ((v16 & 0x8000000000000000) != 0) {
    goto LABEL_121;
  }
  uint64_t v24 = (unint64_t *)((char *)v9 + 56);
  size_t v25 = *((void *)v9 + 8);
  if (v25 < v16)
  {
    do
    {
      while (!v25)
      {
        size_t v25 = 0x4000;
        if (v16 <= 0x4000)
        {
          int v27 = (void **)((char *)v9 + 72);
          size_t v25 = 0x4000;
          goto LABEL_48;
        }
      }
      size_t v26 = v25 >> 1;
      if ((v25 & (v25 >> 1)) != 0) {
        size_t v26 = v25 & (v25 >> 1);
      }
      v25 += v26;
    }
    while (v25 < v16);
    int v27 = (void **)((char *)v9 + 72);
    if (v25 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_117:
      const char *v27 = 0;
      unint64_t *v24 = 0;
      *((void *)v9 + 8) = 0;
      goto LABEL_121;
    }
LABEL_48:
    uint64_t v28 = *v27;
    unint64_t v29 = realloc(*v27, v25);
    if (!v29)
    {
      free(v28);
      goto LABEL_117;
    }
    *((void *)v9 + 8) = v25;
    *((void *)v9 + 9) = v29;
    unint64_t v16 = *((void *)v9 + 4);
    if ((v16 & 0x8000000000000000) != 0) {
      goto LABEL_121;
    }
  }
  unint64_t v31 = (unint64_t *)((char *)v9 + 88);
  size_t v30 = *((void *)v9 + 11);
  if (v30 < v16)
  {
    do
    {
      while (!v30)
      {
        size_t v30 = 0x4000;
        if (v16 <= 0x4000)
        {
          size_t v30 = 0x4000;
          goto LABEL_60;
        }
      }
      size_t v32 = v30 >> 1;
      if ((v30 & (v30 >> 1)) != 0) {
        size_t v32 = v30 & (v30 >> 1);
      }
      v30 += v32;
    }
    while (v30 < v16);
    if (v30 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_119;
    }
LABEL_60:
    BOOL v33 = (void *)*((void *)v9 + 12);
    long long v34 = realloc(v33, v30);
    if (v34)
    {
      *((void *)v9 + 11) = v30;
      *((void *)v9 + 12) = v34;
      goto LABEL_62;
    }
    free(v33);
LABEL_119:
    *((void *)v9 + 11) = 0;
    *((void *)v9 + 12) = 0;
LABEL_120:
    *((void *)v9 + 10) = 0;
LABEL_121:
    unint64_t v21 = "truncated state";
    __int16 v22 = 359;
    goto LABEL_15;
  }
LABEL_62:
  size_t v35 = v60;
  if ((void)v60)
  {
    uint64_t v36 = 0;
    unint64_t v38 = *((void *)v9 + 7);
    unint64_t v37 = *((void *)v9 + 8);
    do
    {
      if (v38 == v37)
      {
        unint64_t v39 = v37 + 0x40000;
        if ((uint64_t)(v37 + 0x40000) < 0) {
          goto LABEL_121;
        }
        if (v37 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v37)
            {
              unint64_t v37 = 0x4000;
              size_t v41 = 0x4000;
              if (v39 <= 0x4000) {
                goto LABEL_77;
              }
            }
            unint64_t v40 = v37 >> 1;
            if ((v37 & (v37 >> 1)) != 0) {
              unint64_t v40 = v37 & (v37 >> 1);
            }
            v37 += v40;
          }
          while (v37 < v39);
          size_t v41 = v37;
          if (v37 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_124;
          }
LABEL_77:
          unint64_t v42 = (void *)*((void *)v9 + 9);
          uint64_t v43 = realloc(v42, v41);
          if (v43)
          {
            *((void *)v9 + 8) = v41;
            *((void *)v9 + 9) = v43;
            unint64_t v38 = *((void *)v9 + 7);
            goto LABEL_79;
          }
          free(v42);
LABEL_124:
          unint64_t *v24 = 0;
          *((void *)v9 + 8) = 0;
          *((void *)v9 + 9) = 0;
          goto LABEL_121;
        }
        unint64_t v38 = v37;
      }
      size_t v41 = v37;
LABEL_79:
      if (v41 - v38 >= v35) {
        size_t v44 = v35;
      }
      else {
        size_t v44 = v41 - v38;
      }
      ssize_t v45 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 9) + v38), v44);
      if (v45 < 0) {
        goto LABEL_121;
      }
      if (!v45) {
        break;
      }
      unint64_t v38 = *v24 + v45;
      if (!__CFADD__(*v24, v45))
      {
        unint64_t v37 = *((void *)v9 + 8);
        if (v38 <= v37) {
          continue;
        }
      }
      goto LABEL_121;
      unint64_t *v24 = v38;
      v36 += v45;
      v35 -= v45;
    }
    while (v35);
    if (v36 < 0) {
      goto LABEL_121;
    }
  }
  size_t v46 = *((void *)&v60 + 1);
  if (*((void *)&v60 + 1))
  {
    uint64_t v47 = 0;
    unint64_t v49 = *((void *)v9 + 10);
    unint64_t v48 = *((void *)v9 + 11);
    do
    {
      if (v49 == v48)
      {
        unint64_t v50 = v48 + 0x40000;
        if ((uint64_t)(v48 + 0x40000) < 0) {
          goto LABEL_121;
        }
        if (v48 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v48)
            {
              unint64_t v48 = 0x4000;
              size_t v52 = 0x4000;
              if (v50 <= 0x4000) {
                goto LABEL_103;
              }
            }
            unint64_t v51 = v48 >> 1;
            if ((v48 & (v48 >> 1)) != 0) {
              unint64_t v51 = v48 & (v48 >> 1);
            }
            v48 += v51;
          }
          while (v48 < v50);
          size_t v52 = v48;
          if (v48 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_127;
          }
LABEL_103:
          unint64_t v53 = (void *)*((void *)v9 + 12);
          unint64_t v54 = realloc(v53, v52);
          if (v54)
          {
            *((void *)v9 + 11) = v52;
            *((void *)v9 + 12) = v54;
            unint64_t v49 = *((void *)v9 + 10);
            goto LABEL_105;
          }
          free(v53);
LABEL_127:
          *unint64_t v31 = 0;
          *((void *)v9 + 12) = 0;
          goto LABEL_120;
        }
        unint64_t v49 = v48;
      }
      size_t v52 = v48;
LABEL_105:
      if (v52 - v49 >= v46) {
        size_t v55 = v46;
      }
      else {
        size_t v55 = v52 - v49;
      }
      ssize_t v56 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 12) + v49), v55);
      if (v56 < 0) {
        goto LABEL_121;
      }
      if (!v56) {
        break;
      }
      uint64_t v57 = *((void *)v9 + 10);
      unint64_t v49 = v57 + v56;
      if (!__CFADD__(v57, v56))
      {
        unint64_t v48 = *v31;
        if (v49 <= *v31) {
          continue;
        }
      }
      goto LABEL_121;
      *((void *)v9 + 10) = v49;
      v47 += v56;
      v46 -= v56;
    }
    while (v46);
    if (v47 < 0) {
      goto LABEL_121;
    }
  }
  if (a3) {
    *a3 = *((void *)v9 + 13);
  }
  return v8;
}

uint64_t ThreadPipelineFlush(uint64_t a1)
{
  if ((SharedArrayEnqueue_0((unsigned int *)(a1 + 168), -2) & 0x80000000) != 0)
  {
    size_t v5 = "SharedArrayEnqueue failed";
    __int16 v6 = 333;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineFlush", v6, 87, 0, v5, v2, v3, v8);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 304))) {
    goto LABEL_8;
  }
  while (1)
  {
    int v4 = *(_DWORD *)(a1 + 296);
    if (v4 > 0) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 368), (pthread_mutex_t *)(a1 + 304))) {
      goto LABEL_8;
    }
  }
  *(_DWORD *)(a1 + 296) = v4 - 1;
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  if (result)
  {
LABEL_8:
    size_t v5 = "SemAquire failed";
    __int16 v6 = 336;
    goto LABEL_9;
  }
  return result;
}

void *AARangeInputStreamOpen(uint64_t a1, uint64_t a2)
{
  int v4 = calloc(1uLL, 0x68uLL);
  size_t v5 = malloc(0x30uLL);
  __int16 v6 = v5;
  if (!v5 || (memset_s(v5, 0x30uLL, 0, 0x30uLL), !v4))
  {
    int v10 = *__error();
    uint64_t v11 = "malloc";
    __int16 v12 = 81;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARangeInputStream.c", (uint64_t)"AARangeInputStreamOpen", v12, 118, v10, v11, v8, v9, v14);
    free(v6);
    free(v4);
    return 0;
  }
  void *v6 = a1;
  uint64_t v7 = AAByteRangeClone(a2);
  v6[1] = v7;
  if (!v7)
  {
    uint64_t v11 = "AAByteRangeClone";
    __int16 v12 = 86;
    int v10 = 0;
    goto LABEL_7;
  }
  v6[4] = AAByteRangeFirst((uint64_t)v7, 0, v6 + 2, v6 + 3);
  void *v4 = v6;
  v4[1] = rangeInputStreamClose;
  v4[7] = rangeInputStreamCancel;
  v4[2] = rangeInputStreamRead;
  return v4;
}

uint64_t rangeInputStreamClose(void ***a1)
{
  return 0;
}

void rangeInputStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 40), (unsigned int *)&v1, 1u);
  if (!v1) {
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t rangeInputStreamRead(uint64_t a1, char *buf, unint64_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 40))) {
    return -1;
  }
  uint64_t v4 = 0;
  if ((*(void *)(a1 + 32) & 0x8000000000000000) == 0)
  {
    unint64_t v7 = a3;
    if (a3)
    {
      uint64_t v4 = 0;
      int v10 = (off_t *)(a1 + 16);
      off_t v9 = *(void *)(a1 + 16);
      uint64_t v11 = (off_t *)(a1 + 24);
      while (1)
      {
        off_t v12 = *v11;
        if (v9 >= *v11)
        {
          uint64_t v13 = AAByteRangeNext(*(void *)(a1 + 8), *(void *)(a1 + 32), (void *)(a1 + 16), (void *)(a1 + 24));
          *(void *)(a1 + 32) = v13;
          if (v13 < 0) {
            return v4;
          }
          off_t v9 = *v10;
          off_t v12 = *v11;
        }
        uint64_t v14 = v7 >= 0x10000000 ? 0x10000000 : v7;
        size_t v15 = v9 + v14 <= v12 ? v14 : v12 - v9;
        ssize_t v16 = AAByteStreamPRead(*(AAByteStream *)a1, buf, v15, v9);
        if (v16 < 1) {
          break;
        }
        off_t v9 = *v10 + v16;
        *int v10 = v9;
        buf += v16;
        v4 += v16;
        v7 -= v16;
        if (!v7) {
          return v4;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARangeInputStream.c", (uint64_t)"rangeInputStreamRead", 59, 118, 0, "Stream pread", v17, v18, v20);
      int v19 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 40), (unsigned int *)&v19, 1u);
      if (!v19) {
        AAByteStreamCancel(*(AAByteStream *)a1);
      }
      return -1;
    }
  }
  return v4;
}

_DWORD *ParallelCompressionAFSCStreamOpen(int a1, unint64_t a2, int a3, int a4)
{
  int v10 = calloc(1uLL, 0x78uLL);
  if (!v10)
  {
    uint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", 163, 86, *v13, "malloc", v14, v15, v35);
LABEL_39:
    free(v10);
    return 0;
  }
  if (!a2)
  {
    uint64_t v11 = "File too small for AFSC";
    __int16 v12 = 167;
LABEL_7:
    int v16 = 0;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", v12, 86, v16, v11, v8, v9, v35);
    free(*((void **)v10 + 5));
    free(*((void **)v10 + 8));
    free(*((void **)v10 + 10));
    free(*((void **)v10 + 11));
    goto LABEL_39;
  }
  if (a2 >= 0xFA000001)
  {
    uint64_t v11 = "File too large for AFSC";
    __int16 v12 = 168;
    goto LABEL_7;
  }
  if (a3) {
    int v17 = a3;
  }
  else {
    int v17 = 4;
  }
  int v18 = v17 - 3;
  if (v17 - 3) <= 0xA && ((0x551u >> v18)) {
    int v17 = dword_214B12B9C[v18];
  }
  compression_algorithm v19 = 0;
  size_t v20 = 0;
  char v21 = -52;
  compression_algorithm v22 = 1285;
  char v23 = -1;
  switch(v17)
  {
    case 4:
      goto LABEL_19;
    case 8:
      compression_algorithm v22 = 2304;
      char v23 = 6;
      goto LABEL_19;
    case 10:
      goto LABEL_22;
    case 12:
      compression_algorithm v22 = COMPRESSION_LZFSE;
      goto LABEL_19;
    case 14:
      compression_algorithm v22 = COMPRESSION_LZBITMAP;
LABEL_19:
      size_t v20 = compression_encode_scratch_buffer_size(v22);
      size_t v24 = compression_decode_scratch_buffer_size(v22);
      if (v20 <= v24) {
        size_t v20 = v24;
      }
      compression_algorithm v19 = v22;
      char v21 = v23;
LABEL_22:
      *int v10 = a1;
      unint64_t v25 = (a2 + 0xFFFF) >> 16;
      *((void *)v10 + 1) = a2;
      v10[4] = v17;
      v10[5] = v19;
      *((unsigned char *)v10 + 24) = v21;
      v10[7] = a4;
      v10[8] = v25;
      size_t v26 = calloc(v25 + 1, 4uLL);
      *((void *)v10 + 5) = v26;
      if (!v26)
      {
        int v16 = *__error();
        uint64_t v11 = "malloc";
        __int16 v12 = 210;
        goto LABEL_38;
      }
      int v27 = v26;
      *((_OWORD *)v10 + 3) = xmmword_214B12B50;
      uint64_t v28 = malloc(0x100000uLL);
      *((void *)v10 + 8) = v28;
      if (!v28)
      {
        int v16 = *__error();
        uint64_t v11 = "malloc";
        __int16 v12 = 214;
        goto LABEL_38;
      }
      *((void *)v10 + 9) = 0;
      unint64_t v29 = malloc(0x10000uLL);
      *((void *)v10 + 10) = v29;
      if (!v29)
      {
        int v16 = *__error();
        uint64_t v11 = "malloc";
        __int16 v12 = 217;
        goto LABEL_38;
      }
      if (v20)
      {
        size_t v30 = malloc(v20);
        *((void *)v10 + 11) = v30;
        if (!v30)
        {
          int v16 = *__error();
          uint64_t v11 = "malloc";
          __int16 v12 = 221;
          goto LABEL_38;
        }
      }
      char v31 = 2;
      if (v10[4] == 4) {
        char v31 = 3;
      }
      uint64_t v32 = 4;
      if (v10[4] == 4) {
        uint64_t v32 = 264;
      }
      unint64_t v33 = ((unint64_t)v10[8] << v31) + v32;
      if (HIDWORD(v33))
      {
        uint64_t v11 = "File too large for AFSC";
        __int16 v12 = 235;
        goto LABEL_7;
      }
      v10[27] = v33;
      _DWORD *v27 = v33;
      v10[26] = 0;
      *((void *)v10 + 12) = 0;
      v10[28] = 0;
      break;
    default:
      char v35 = v17;
      uint64_t v11 = "invalid compression type %d";
      __int16 v12 = 192;
      goto LABEL_7;
  }
  return v10;
}

uint64_t ParallelCompressionAFSCStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 96) + a3 <= *(void *)(a1 + 8))
  {
    if (!a3) {
      return 0;
    }
    unint64_t v10 = 0;
    size_t v14 = *(void *)(a1 + 56);
    while (v14 + 65537 <= *(void *)(a1 + 48) || (flushToResourceFork(a1) & 0x80000000) == 0)
    {
      uint64_t v15 = *(void *)(a1 + 72);
      if (0x10000 - v15 + v10 <= a3) {
        size_t v16 = 0x10000 - v15;
      }
      else {
        size_t v16 = a3 - v10;
      }
      if (v16 == 0x10000)
      {
        int v17 = (char *)(a2 + v10);
      }
      else
      {
        int v17 = *(char **)(a1 + 80);
        memcpy(&v17[v15], (const void *)(a2 + v10), v16);
        uint64_t v15 = *(void *)(a1 + 72);
      }
      size_t v18 = *(void *)(a1 + 96) + v16;
      *(void *)(a1 + 96) = v18;
      v10 += v16;
      size_t v19 = v15 + v16;
      *(void *)(a1 + 72) = v15 + v16;
      if ((v15 + v16) >> 16 || v18 >= *(void *)(a1 + 8))
      {
        uint64_t v21 = *(void *)(a1 + 56);
        uint64_t v20 = *(void *)(a1 + 64);
        compression_algorithm v22 = (unsigned char *)(v20 + v21);
        compression_algorithm v23 = *(_DWORD *)(a1 + 20);
        BOOL v24 = v19 < 0x78 || v23 == 0;
        if (v24
          || (size_t v25 = compression_encode_buffer((uint8_t *)(v20 + v21), 0x10000uLL, (const uint8_t *)v17, v19, *(void **)(a1 + 88), v23)) == 0|| (*(unsigned char *)(a1 + 28) & 1) != 0 && (v26 = v25 + (v25 >> 6), size_t v25 = v26 + 32, v26 == -32)|| v25 > *(void *)(a1 + 72) + 1)
        {
          *compression_algorithm v22 = *(unsigned char *)(a1 + 24);
          memcpy(v22 + 1, v17, *(void *)(a1 + 72));
          size_t v25 = *(void *)(a1 + 72) + 1;
        }
        *(void *)(a1 + 72) = 0;
        size_t v14 = *(void *)(a1 + 56) + v25;
        *(void *)(a1 + 56) = v14;
        *(_DWORD *)(*(void *)(a1 + 40) + 4 * ++*(_DWORD *)(a1 + 104)) = *(_DWORD *)(*(void *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 104))
                                                                                        + v25;
        if (v10 < a3) {
          continue;
        }
      }
      return v10;
    }
    uint64_t v8 = "update resource fork";
    __int16 v9 = 270;
  }
  else
  {
    uint64_t v8 = "too many bytes received";
    __int16 v9 = 262;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamWrite", v9, 86, 0, v8, a7, a8, v28);
  return -1;
}

uint64_t flushToResourceFork(uint64_t a1)
{
  int v2 = fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), *(void *)(a1 + 56), *(_DWORD *)(a1 + 108), 0);
  if (v2 < 0)
  {
    uint64_t v3 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"flushToResourceFork", 142, 86, *v3, "fsetxattr resource fork", v4, v5, v8);
  }
  int v6 = *(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 108) = v6;
  *(_DWORD *)(a1 + 112) = 1;
  return (v2 >> 31);
}

uint64_t ParallelCompressionAFSCStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 0;
  }
  memset(&v42, 0, sizeof(v42));
  if (*(void *)(a1 + 96) >= *(void *)(a1 + 8) && !*(void *)(a1 + 72))
  {
    unsigned int v14 = *(_DWORD *)(a1 + 112);
    int v15 = *(_DWORD *)(a1 + 20);
    if (v15) {
      int v15 = (*(unsigned __int8 *)(a1 + 28) >> 1) & 1;
    }
    if (*(_DWORD *)(a1 + 32) > 1u) {
      int v15 = 1;
    }
    if ((unint64_t)(*(void *)(a1 + 56) - 3569) < 0xFFFFFFFFFFFFF1FFLL) {
      int v15 = 1;
    }
    if (v14 | v15)
    {
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        __int16 v9 = "update resource fork";
        __int16 v10 = 341;
        goto LABEL_5;
      }
      unsigned int v14 = *(_DWORD *)(a1 + 112);
    }
    int v16 = (__PAIR64__(*(_DWORD *)(a1 + 16), v14) - 1) >> 32;
    uint64_t v17 = *(void *)(a1 + 8);
    uint64_t v18 = *(void *)(a1 + 80);
    *(_DWORD *)uint64_t v18 = 1668116582;
    *(_DWORD *)(v18 + 4) = v16;
    *(void *)(v18 + 8) = v17;
    size_t v19 = 16;
    *(void *)(a1 + 72) = 16;
    if (!*(_DWORD *)(a1 + 112))
    {
      memcpy((void *)(*(void *)(a1 + 80) + 16), *(const void **)(a1 + 64), *(void *)(a1 + 56));
      size_t v19 = *(void *)(a1 + 72) + *(void *)(a1 + 56);
      *(void *)(a1 + 72) = v19;
      *(void *)(a1 + 56) = 0;
    }
    if (fsetxattr(*(_DWORD *)a1, "com.apple.decmpfs", *(const void **)(a1 + 80), v19, 0, 0) < 0)
    {
      int v11 = *__error();
      __int16 v9 = "fsetxattr decmpfs";
      __int16 v10 = 363;
      goto LABEL_6;
    }
    if (!*(_DWORD *)(a1 + 112))
    {
      unsigned int v21 = 0;
      goto LABEL_36;
    }
    if (*(_DWORD *)(a1 + 16) == 4)
    {
      uint64_t v20 = *(void *)(a1 + 64);
      *(_OWORD *)uint64_t v20 = old_resource_fork_map;
      *(_OWORD *)(v20 + 16) = unk_214B12B78;
      *(_OWORD *)(v20 + 32) = xmmword_214B12B88;
      *(_WORD *)(v20 + 48) = 0;
      *(void *)(a1 + 56) = 50;
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        __int16 v9 = "update resource fork";
        __int16 v10 = 373;
        goto LABEL_5;
      }
      unsigned int v21 = *(_DWORD *)(a1 + 108);
      if (*(_DWORD *)(a1 + 16) == 4)
      {
        int v22 = *(_DWORD *)(a1 + 32);
        if ((unint64_t)(8 * v22) + 264 > *(void *)(a1 + 48))
        {
          LOBYTE(v41) = 8 * v22 + 8;
          __int16 v9 = "File a radar to increase obuf_capacity, sz=%zu";
          __int16 v10 = 382;
          goto LABEL_5;
        }
        long long v43 = 0u;
        long long v44 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v53 = 0u;
        long long v54 = 0u;
        long long v57 = 0u;
        uint64_t v32 = *(void *)(a1 + 64);
        *(_DWORD *)uint64_t v32 = 0x10000;
        *(int8x8_t *)(v32 + 4) = vrev32_s8((int8x8_t)vadd_s32(vdup_n_s32(v21), (int32x2_t)0xFFFFFECEFFFFFFCELL));
        *(_DWORD *)(v32 + 12) = 838860800;
        long long v33 = v44;
        *(_OWORD *)(v32 + 16) = v43;
        *(_OWORD *)(v32 + 32) = v33;
        long long v34 = v48;
        *(_OWORD *)(v32 + 80) = v47;
        *(_OWORD *)(v32 + 96) = v34;
        long long v35 = v46;
        *(_OWORD *)(v32 + 48) = v45;
        *(_OWORD *)(v32 + 64) = v35;
        long long v36 = v52;
        *(_OWORD *)(v32 + 144) = v51;
        *(_OWORD *)(v32 + 160) = v36;
        long long v37 = v50;
        *(_OWORD *)(v32 + 112) = v49;
        *(_OWORD *)(v32 + 128) = v37;
        long long v38 = v56;
        *(_OWORD *)(v32 + 208) = v55;
        *(_OWORD *)(v32 + 224) = v38;
        long long v39 = v54;
        *(_OWORD *)(v32 + 176) = v53;
        *(_OWORD *)(v32 + 192) = v39;
        *(_OWORD *)(v32 + 240) = v57;
        *(_DWORD *)(v32 + 256) = bswap32(v21 - 310);
        *(_DWORD *)(v32 + 260) = v22;
        size_t v23 = 264;
        *(void *)(a1 + 56) = 264;
        if (*(_DWORD *)(a1 + 32))
        {
          unint64_t v40 = 0;
          size_t v23 = 264;
          do
          {
            *(void *)(*(void *)(a1 + 64) + v23) = (*(_DWORD *)(*(void *)(a1 + 40) + 4 * v40) - 260) | ((unint64_t)(*(_DWORD *)(*(void *)(a1 + 40) + 4 * v40 + 4) - *(_DWORD *)(*(void *)(a1 + 40) + 4 * v40)) << 32);
            ++v40;
            size_t v23 = *(void *)(a1 + 56) + 8;
            *(void *)(a1 + 56) = v23;
          }
          while (v40 < *(unsigned int *)(a1 + 32));
        }
        goto LABEL_35;
      }
    }
    else
    {
      unsigned int v21 = *(_DWORD *)(a1 + 108);
    }
    size_t v23 = (4 * *(_DWORD *)(a1 + 32) + 4);
    if (*(void *)(a1 + 48) < v23)
    {
      int v41 = 4 * *(_DWORD *)(a1 + 32) + 4;
      __int16 v9 = "File a radar to increase obuf_capacity, sz=%zu";
      __int16 v10 = 408;
      goto LABEL_5;
    }
    memcpy(*(void **)(a1 + 64), *(const void **)(a1 + 40), (4 * *(_DWORD *)(a1 + 32) + 4));
    *(void *)(a1 + 56) = v23;
LABEL_35:
    if (fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), v23, 0, 0) < 0)
    {
      int v11 = *__error();
      __int16 v9 = "fsetxattr resource fork header";
      __int16 v10 = 418;
      goto LABEL_6;
    }
LABEL_36:
    if (ftruncate(*(_DWORD *)a1, 0))
    {
      int v11 = *__error();
      __int16 v9 = "ftruncate";
      __int16 v10 = 422;
      goto LABEL_6;
    }
    if ((*(unsigned char *)(a1 + 28) & 4) != 0 || !*(_DWORD *)(a1 + 112) || 93 * *(void *)(a1 + 8) / 0x64uLL >= v21)
    {
      if (fstat(*(_DWORD *)a1, &v42))
      {
        int v11 = *__error();
        __int16 v9 = "fstat";
        __int16 v10 = 465;
        goto LABEL_6;
      }
      if (fchflags(*(_DWORD *)a1, v42.st_flags | 0x20) < 0)
      {
        int v11 = *__error();
        __int16 v9 = "fchflags UF_COMPRESSED";
        __int16 v10 = 466;
        goto LABEL_6;
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 32))
      {
        unint64_t v24 = 0;
        off_t v25 = 0;
        while (1)
        {
          size_t v26 = (u_int32_t *)(*(void *)(a1 + 40) + 4 * v24);
          u_int32_t v27 = v26[1];
          size_t v28 = v27 - *v26;
          if (v27 == *v26 || v28 >= 0x10002)
          {
            __int16 v9 = "Invalid chunk size";
            __int16 v10 = 437;
            goto LABEL_5;
          }
          if (fgetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(void **)(a1 + 64), v27 - *v26, *v26, 32) != v28)
          {
            __int16 v9 = "reading chunk";
            __int16 v10 = 440;
            goto LABEL_5;
          }
          size_t v30 = *(const uint8_t **)(a1 + 64);
          if (*v30 == *(unsigned __int8 *)(a1 + 24))
          {
            size_t v31 = (v28 - 1);
            memcpy(*(void **)(a1 + 80), v30 + 1, v31);
          }
          else
          {
            size_t v31 = compression_decode_buffer(*(uint8_t **)(a1 + 80), 0x10000uLL, v30, v28, *(void **)(a1 + 88), (compression_algorithm)*(_DWORD *)(a1 + 20));
          }
          if (v31 != 0x10000)
          {
            if (!v31)
            {
              __int16 v9 = "Decompression";
              __int16 v10 = 451;
              goto LABEL_5;
            }
            if (v31 + v25 != *(void *)(a1 + 8)) {
              break;
            }
          }
          if (pwrite(*(_DWORD *)a1, *(const void **)(a1 + 80), v31, v25) != v31)
          {
            __int16 v9 = "writing chunk";
            __int16 v10 = 454;
            goto LABEL_5;
          }
          ++v24;
          v25 += v31;
          if (v24 >= *(unsigned int *)(a1 + 32)) {
            goto LABEL_56;
          }
        }
        __int16 v9 = "Invalid uncompressed chunk size";
        __int16 v10 = 452;
        goto LABEL_5;
      }
LABEL_56:
      if (fremovexattr(*(_DWORD *)a1, "com.apple.ResourceFork", 32) < 0)
      {
        int v11 = *__error();
        __int16 v9 = "Removing xattr";
        __int16 v10 = 459;
        goto LABEL_6;
      }
      if (fremovexattr(*(_DWORD *)a1, "com.apple.decmpfs", 32) < 0)
      {
        int v11 = *__error();
        __int16 v9 = "Removing xattr";
        __int16 v10 = 460;
        goto LABEL_6;
      }
    }
    uint64_t v12 = 0;
    goto LABEL_7;
  }
  __int16 v9 = "not enough bytes received";
  __int16 v10 = 325;
LABEL_5:
  int v11 = 0;
LABEL_6:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamClose", v10, 86, v11, v9, a7, a8, v41);
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_7:
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 88));
  free((void *)a1);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadataFD(int a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  memset(&v24, 0, sizeof(v24));
  if (fstat(a1, &v24))
  {
    char v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", 488, 86, *v8, "fstat", v9, v10, v23);
    int v11 = 0;
LABEL_22:
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  if ((v24.st_flags & 0x20) != 0)
  {
    int v11 = (off_t *)malloc(0x1000uLL);
    if (v11)
    {
      unint64_t v13 = fgetxattr(a1, "com.apple.decmpfs", v11, 0x1000uLL, 0, 32);
      if ((v13 & 0x8000000000000000) != 0)
      {
        int v16 = "Missing decmpfs xattr";
        __int16 v17 = 504;
      }
      else if (v13 > 0xF)
      {
        if (*(_DWORD *)v11 == 1668116582)
        {
          unsigned int v19 = *((_DWORD *)v11 + 1);
          if (v19 > 0xE) {
            goto LABEL_27;
          }
          off_t v20 = v11[1];
          if (((1 << v19) & 0x2A88) != 0)
          {
            uint64_t v12 = 0;
            *a2 = v20;
            *a3 = v19;
            goto LABEL_5;
          }
          if (((1 << v19) & 0x5510) != 0)
          {
            *a2 = v20;
            *a3 = v19;
            unint64_t v21 = fgetxattr(a1, "com.apple.ResourceFork", 0, 0, 0, 32);
            if ((v21 & 0x8000000000000000) != 0)
            {
              int v16 = "Missing resource fork xattr";
              __int16 v17 = 532;
            }
            else
            {
              if (!HIDWORD(v21))
              {
                uint64_t v12 = 0;
                *a4 = v21;
                goto LABEL_23;
              }
              int v16 = "Invalid resource fork xattr";
              __int16 v17 = 533;
            }
          }
          else
          {
LABEL_27:
            int v23 = *((_DWORD *)v11 + 1);
            int v16 = "Invalid compression type %u in decmpfs xattr";
            __int16 v17 = 524;
          }
        }
        else
        {
          int v16 = "Invalid decmpfs xattr";
          __int16 v17 = 507;
        }
      }
      else
      {
        int v16 = "Truncated decmpfs xattr";
        __int16 v17 = 505;
      }
      int v18 = 0;
    }
    else
    {
      int v18 = *__error();
      int v16 = "malloc";
      __int16 v17 = 501;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", v17, 86, v18, v16, v14, v15, v23);
    goto LABEL_22;
  }
  int v11 = 0;
  uint64_t v12 = 0;
  *a2 = v24.st_size;
  *a3 = -1;
LABEL_5:
  *a4 = 0;
LABEL_23:
  free(v11);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadata(const char *a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  char v7 = (char)a1;
  int v8 = open(a1, 0);
  if (v8 < 0)
  {
    unint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 550, 86, *v13, "open %s", v14, v15, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v9 = v8;
    if ((ParallelCompressionAFSCGetMetadataFD(v8, a2, a3, a4) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 553, 86, 0, "retrieving AFSC metadata: %s", v10, v11, v7);
      uint64_t v12 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v12 = 0;
    }
    close(v9);
  }
  return v12;
}

uint64_t ParallelCompressionAFSCFixupMetadata(const std::__fs::filesystem::path *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v213 = *MEMORY[0x263EF8340];
  unsigned int v195 = -1;
  u_int32_t v194 = 0;
  unint64_t v193 = 0;
  memset(&v192, 0, sizeof(v192));
  int v211 = 0;
  long long v209 = 0u;
  long long v210 = 0u;
  long long v207 = 0u;
  long long v208 = 0u;
  long long v205 = 0u;
  long long v206 = 0u;
  long long v203 = 0u;
  long long v204 = 0u;
  long long v201 = 0u;
  long long v202 = 0u;
  long long v199 = 0u;
  long long v200 = 0u;
  long long v197 = 0u;
  long long v198 = 0u;
  long long v196 = 0u;
  value[0] = 0;
  value[1] = 0;
  if ((unint64_t)__strlcpy_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 581, 86, 0, "Path too long: %s", v6, v7, (char)a1);
LABEL_5:
    int v17 = 0;
    int v18 = 0;
LABEL_134:
    long long v45 = 0;
    unint64_t v75 = 0;
    uint64_t v77 = 0;
    int v35 = -1;
LABEL_135:
    int v37 = -1;
    goto LABEL_136;
  }
  if ((unint64_t)__strlcat_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 582, 86, 0, "Path too long: %s", v15, v16, (char)a1);
    goto LABEL_5;
  }
  int v18 = (int *)malloc(0x100000uLL);
  if (!v18)
  {
    int v23 = *__error();
    unint64_t v21 = "malloc";
    __int16 v22 = 586;
LABEL_133:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v22, 86, v23, v21, v13, v14, v170);
    int v17 = 0;
    goto LABEL_134;
  }
  if (a2) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = 4;
  }
  if ((v19 + 1) > 0xF) {
    goto LABEL_131;
  }
  int v20 = 1 << (v19 + 1);
  if ((v20 & 0x5511) != 0)
  {
    if (a3)
    {
      char v170 = a3;
      unint64_t v21 = "Invalid resource fork size request: %u";
      __int16 v22 = 605;
LABEL_132:
      int v23 = 0;
      goto LABEL_133;
    }
    goto LABEL_16;
  }
  if ((v20 & 0xAA20) == 0)
  {
LABEL_131:
    char v170 = v19;
    unint64_t v21 = "Invalid compression type request %d";
    __int16 v22 = 608;
    goto LABEL_132;
  }
LABEL_16:
  if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
  {
LABEL_130:
    char v170 = (char)a1;
    unint64_t v21 = "obtain AFSC data: %s";
    __int16 v22 = 615;
    goto LABEL_132;
  }
  char v24 = 0;
  int v181 = 0;
  int v25 = 0;
  uint64_t v182 = v18 + 3;
  long long v180 = (unint64_t *)(v18 + 66);
  int8x8_t v26 = (int8x8_t)vadd_s32(vdup_n_s32(a3), (int32x2_t)0xFFFFFECEFFFFFFCELL);
  int8x8_t v27 = vrev32_s8(v26);
  u_int32_t position = v26.i32[0];
  unsigned int v177 = bswap32(a3 - 310);
  uint64_t v28 = (int)v19 - 4;
  unsigned int v185 = (0x551u >> (v19 - 4)) & 1;
  while (1)
  {
    unint64_t v29 = v193;
    if (v193 >= 0xFA000001)
    {
      unint64_t v21 = "Invalid AFSC data";
      __int16 v22 = 616;
      goto LABEL_132;
    }
    char v187 = v24;
    if (v195 == v19)
    {
      if (!a3 || v194 == a3) {
        goto LABEL_152;
      }
      if ((v19 & 0x80000000) == 0) {
        goto LABEL_55;
      }
    }
    else if ((v19 & 0x80000000) == 0)
    {
      uint64_t v174 = v28;
      int v30 = 4;
      if (v19 > 0xE)
      {
        int v33 = v19;
      }
      else
      {
        int v31 = 1 << v19;
        if (((1 << v19) & 0x5510) != 0) {
          int v32 = 6;
        }
        else {
          int v32 = 4;
        }
        if ((v31 & 0x2A88) != 0) {
          int v30 = 4;
        }
        else {
          int v30 = v32;
        }
        if ((v31 & 0x2A88) != 0) {
          int v33 = v19 + 1;
        }
        else {
          int v33 = v19;
        }
      }
      int v34 = open((const char *)a1, 0);
      int v35 = v34;
      if ((v34 & 0x80000000) == 0)
      {
        if (!fstat(v34, &v192))
        {
          int v178 = v25;
          int v36 = mkstemp((char *)&__from);
          int v37 = v36;
          if (v36 < 0)
          {
            __int16 v157 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 664, 86, *v157, "mkstemp", v158, v159, v170);
            int v17 = 0;
            long long v45 = 0;
          }
          else
          {
            long long v45 = ParallelCompressionAFSCStreamOpen(v36, v29, v33, v30);
            if (v45)
            {
              uint64_t v183 = v19;
              int fd = v35;
              int v188 = v18;
              uint64_t v46 = 0;
              unint64_t v47 = 0;
              uint64_t v48 = 0x100000;
              unint64_t v49 = 0x100000;
              while (1)
              {
                unint64_t v50 = v29 >= v49 ? v49 : v29;
                if (v49 - 0x100000 >= v29) {
                  break;
                }
                int64_t v51 = v50 + v46;
                ssize_t v52 = read(fd, v188, v50 + v46);
                if (v52 < 0)
                {
                  int v126 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 675, 86, v126, "read: %s", v127, v128, (char)a1);
                  goto LABEL_149;
                }
                if (v52 < v51)
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 676, 86, 0, "truncated read: %s", v56, v57, (char)a1);
LABEL_149:
                  int v17 = 0;
LABEL_150:
                  unint64_t v75 = 0;
                  uint64_t v77 = 0;
                  int v18 = v188;
                  goto LABEL_151;
                }
                v47 += 0x100000;
                uint64_t v58 = ParallelCompressionAFSCStreamWrite((uint64_t)v45, (uint64_t)v188, v51, v53, v54, v55, v56, v57);
                v49 += 0x100000;
                v46 -= 0x100000;
                if (v29 >= v47) {
                  unint64_t v59 = v47;
                }
                else {
                  unint64_t v59 = v29;
                }
                v48 -= 0x100000;
                if (v58 < (uint64_t)(v59 + v48))
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 678, 86, 0, "write to stream failed: %s", v43, v44, (char)a1);
                  goto LABEL_149;
                }
              }
              if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v38, v39, v40, v41, v42, v43, v44) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 683, 86, 0, "Stream close error", v93, v94, v170);
                int v17 = 0;
                long long v45 = 0;
                goto LABEL_150;
              }
              fchown(v37, v192.st_uid, v192.st_gid);
              fchmod(v37, v192.st_mode & 0xFFF);
              close(fd);
              close(v37);
              rename(&__from, a1, v95);
              int v97 = v96;
              unlink((const char *)&__from);
              int v18 = v188;
              uint64_t v19 = v183;
              uint64_t v28 = v174;
              int v25 = v178;
              if ((v97 & 0x80000000) == 0) {
                goto LABEL_55;
              }
              int v23 = *__error();
              char v170 = (char)a1;
              unint64_t v21 = "rename: %s";
              __int16 v22 = 694;
              goto LABEL_133;
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 667, 86, 0, "creating compression stream %s", v43, v44, (char)a1);
            int v17 = 0;
          }
          unint64_t v75 = 0;
          uint64_t v77 = 0;
          goto LABEL_136;
        }
        int v141 = *__error();
        char v170 = (char)a1;
        long long v144 = "stat: %s";
        __int16 v145 = 661;
        goto LABEL_170;
      }
      int v146 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 660, 86, v146, "open: %s", v147, v148, (char)a1);
LABEL_171:
      int v17 = 0;
      long long v45 = 0;
      unint64_t v75 = 0;
      uint64_t v77 = 0;
      goto LABEL_135;
    }
    int v60 = open((const char *)a1, 9);
    int v35 = v60;
    if (v60 < 0)
    {
      int v135 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 629, 86, v135, "open %s", v136, v137, (char)a1);
      goto LABEL_171;
    }
    if (write(v60, 0, 0) < 0)
    {
      int v141 = *__error();
      long long v144 = "write";
      __int16 v145 = 630;
LABEL_170:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v145, 86, v141, v144, v142, v143, v170);
      goto LABEL_171;
    }
    if (close(v35) < 0)
    {
      int v23 = *__error();
      unint64_t v21 = "close";
      __int16 v22 = 631;
      goto LABEL_133;
    }
    unsigned int v195 = -1;
    u_int32_t v194 = 0;
LABEL_55:
    if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
    {
      char v170 = (char)a1;
      unint64_t v21 = "obtain AFSC data: %s";
      __int16 v22 = 699;
      goto LABEL_132;
    }
    if (v195 != v19)
    {
      unint64_t v21 = "Couldn't convert to requested compression type";
      __int16 v22 = 700;
      goto LABEL_132;
    }
    if (!a3) {
      goto LABEL_152;
    }
    u_int32_t v61 = v194;
    unsigned int v62 = a3 - v194;
    if (a3 == v194) {
      goto LABEL_152;
    }
    if (a3 >= v194) {
      break;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 711, 86, "Can't shrink resource fork: %s (current %u, target %u)", v12, v13, v14, (char)a1);
LABEL_61:
    if (v187)
    {
      unint64_t v21 = "Second pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)";
      char v170 = (char)a1;
      __int16 v22 = 852;
      goto LABEL_132;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 859, 86, "First pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)", v12, v13, v14, (char)a1);
    int v63 = open((const char *)a1, 9);
    int v35 = v63;
    if (v63 < 0)
    {
      int v138 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 864, 86, v138, "open %s", v139, v140, (char)a1);
      goto LABEL_171;
    }
    if (write(v63, 0, 0) < 0)
    {
      int v141 = *__error();
      long long v144 = "write";
      __int16 v145 = 865;
      goto LABEL_170;
    }
    if (close(v35) < 0)
    {
      int v23 = *__error();
      unint64_t v21 = "close";
      __int16 v22 = 866;
      goto LABEL_133;
    }
    unsigned int v195 = -1;
    u_int32_t v194 = 0;
    int v64 = ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194);
    char v24 = 1;
    if (v64 < 0) {
      goto LABEL_130;
    }
  }
  if (v28 > 0xA || !v185)
  {
    char v170 = v19;
    unint64_t v21 = "Invalid compression type %u";
    __int16 v22 = 722;
    goto LABEL_132;
  }
  uint64_t v184 = v19;
  int v186 = dword_214B12BC8[v28];
  int v65 = open((const char *)a1, 0);
  int v66 = v65;
  if (v65 < 0)
  {
    int v149 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 727, 86, v149, "open: %s", v150, v151, (char)a1);
LABEL_176:
    int v17 = 0;
    long long v45 = 0;
    unint64_t v75 = 0;
    uint64_t v77 = 0;
    int v37 = -1;
    int v35 = v66;
    goto LABEL_136;
  }
  if (fstat(v65, &v192))
  {
    int v152 = *__error();
    unsigned int v155 = "fstat";
    __int16 v156 = 728;
LABEL_175:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v156, 86, v152, v155, v153, v154, v170);
    goto LABEL_176;
  }
  if (fgetxattr(v66, "com.apple.decmpfs", value, 0x10uLL, 0, 32) != 16)
  {
    int v152 = *__error();
    unsigned int v155 = "Reading decmpfs";
    __int16 v156 = 729;
    goto LABEL_175;
  }
  int fd = v66;
  if (fchflags(v66, v192.st_flags & 0xFFFFFFDF) < 0)
  {
    int v121 = *__error();
    uint64_t v124 = "fchflags UF_COMPRESSED";
    __int16 v125 = 730;
LABEL_145:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v125, 86, v121, v124, v122, v123, v170);
    int v17 = 0;
    long long v45 = 0;
    unint64_t v75 = 0;
    uint64_t v77 = 0;
    goto LABEL_146;
  }
  int v179 = v25;
  unint64_t v67 = v29 + 0xFFFF;
  unint64_t v173 = (v29 + 0xFFFF) >> 16;
  uint64_t v175 = v28;
  unsigned int v68 = v61 + 0x100000;
  int v69 = -v61;
  u_int32_t v70 = v61;
  while (1)
  {
    unsigned int v71 = a3 >= v68 ? v68 : a3;
    if (v70 >= a3) {
      break;
    }
    size_t v72 = v71 + v69;
    if (v70 == v61) {
      __memset_chk();
    }
    int v73 = fsetxattr(fd, "com.apple.ResourceFork", v18, v72, v70, 0);
    v68 += 0x100000;
    v69 -= 0x100000;
    v70 += 0x100000;
    if (v73)
    {
      int v121 = *__error();
      uint64_t v124 = "Expanding resource fork";
      __int16 v125 = 738;
      goto LABEL_145;
    }
  }
  int v74 = v173;
  unint64_t v75 = malloc((4 * v173 + 4));
  size_t size = (4 * v173 + 4);
  int v76 = (int *)malloc(size);
  uint64_t v77 = v76;
  if (v75) {
    BOOL v78 = v76 == 0;
  }
  else {
    BOOL v78 = 1;
  }
  if (v78)
  {
    int v160 = *__error();
    unsigned int v163 = "malloc";
    __int16 v164 = 744;
    goto LABEL_183;
  }
  uint64_t v171 = (v67 >> 16);
  if (v184 != 4)
  {
    int v35 = fd;
    size_t v89 = (4 * v173 + 4);
    if (fgetxattr(fd, "com.apple.ResourceFork", v75, size, 0, 32) == size)
    {
LABEL_98:
      long long v189 = v18;
      memcpy(v77, v75, v89);
      v77[v173] = v75[v173] + v62;
      while (v62 && v74)
      {
        uint64_t v98 = (v74 - 1);
        u_int32_t v99 = v75[v98];
        size_t v100 = v75[v74] - v99;
        if (fgetxattr(v35, "com.apple.ResourceFork", v189, v100, v99, 32) != v100)
        {
          unsigned int v129 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 777, 86, *v129, "Reading chunk", v130, v131, v170);
          int v17 = 0;
          long long v45 = 0;
          int v37 = -1;
          int v18 = v189;
          goto LABEL_136;
        }
        unsigned int v101 = 0x10000 - v100;
        if (v186 == *(unsigned __int8 *)v189 || v100 > 0x10000) {
          unsigned int v101 = 0;
        }
        if (v62 >= v101) {
          size_t v103 = v101;
        }
        else {
          size_t v103 = v62;
        }
        if (v103) {
          bzero((char *)v189 + v100, v103);
        }
        size_t v104 = (v103 + v100);
        u_int32_t v105 = v77[v74] - v104;
        v77[v98] = v105;
        v62 -= v103;
        int v35 = fd;
        --v74;
        if (fsetxattr(fd, "com.apple.ResourceFork", v189, v104, v105, 0))
        {
          unsigned int v132 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 791, 86, *v132, "Writing chunk", v133, v134, v170);
          int v17 = 0;
          long long v45 = 0;
          int v37 = -1;
          int v18 = v189;
          goto LABEL_136;
        }
      }
      uint64_t v19 = v184;
      if (v184 == 4)
      {
        int v18 = v189;
        int v25 = v179;
        *long long v189 = v179;
        *(int8x8_t *)(v189 + 1) = v27;
        long long v106 = v209;
        *((_OWORD *)v182 + 12) = v208;
        *((_OWORD *)v182 + 13) = v106;
        *((_OWORD *)v182 + 14) = v210;
        v182[60] = v211;
        long long v107 = v205;
        *((_OWORD *)v182 + 8) = v204;
        *((_OWORD *)v182 + 9) = v107;
        long long v108 = v207;
        *((_OWORD *)v182 + 10) = v206;
        *((_OWORD *)v182 + 11) = v108;
        long long v109 = v201;
        *((_OWORD *)v182 + 4) = v200;
        *((_OWORD *)v182 + 5) = v109;
        long long v110 = v203;
        *((_OWORD *)v182 + 6) = v202;
        *((_OWORD *)v182 + 7) = v110;
        long long v111 = v197;
        *(_OWORD *)uint64_t v182 = v196;
        *((_OWORD *)v182 + 1) = v111;
        long long v112 = v199;
        *((_OWORD *)v182 + 2) = v198;
        *((_OWORD *)v182 + 3) = v112;
        v189[64] = v177;
        v189[65] = v181;
        uint64_t v113 = v171;
        if (v173)
        {
          uint64_t v114 = v77 + 1;
          int v115 = *v77;
          uint64_t v116 = v180;
          do
          {
            int v117 = *v114++;
            *v116++ = (v115 - 260) | ((unint64_t)(v117 - v115) << 32);
            int v115 = v117;
            --v113;
          }
          while (v113);
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", v189, (8 * v173) + 264, 0, 0))
        {
          int v165 = *__error();
          long long v168 = "Writing resource fork header";
          __int16 v169 = 817;
          goto LABEL_189;
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", &old_resource_fork_map, 0x32uLL, position, 0))
        {
          int v165 = *__error();
          long long v168 = "Writing resource map";
          __int16 v169 = 820;
          goto LABEL_189;
        }
      }
      else
      {
        int v18 = v189;
        int v25 = v179;
        if (fsetxattr(v35, "com.apple.ResourceFork", v77, size, 0, 0))
        {
          int v165 = *__error();
          long long v168 = "Writing chunk sizes";
          __int16 v169 = 827;
          goto LABEL_189;
        }
      }
      if (fsetxattr(v35, "com.apple.decmpfs", value, 0x10uLL, 0, 0))
      {
        int v165 = *__error();
        long long v168 = "Writing decmpfs";
        __int16 v169 = 831;
      }
      else
      {
        if ((fchflags(v35, v192.st_flags | 0x20) & 0x80000000) == 0)
        {
          close(v35);
          free(v75);
          free(v77);
          if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) == 0)
          {
            if (v195 != v184)
            {
              uint64_t v28 = v175;
              goto LABEL_61;
            }
            uint64_t v28 = v175;
            if (v194 != a3) {
              goto LABEL_61;
            }
LABEL_152:
            if (v187) {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 876, 86, "Second pass fixup succeeded: %s", v12, v13, v14, (char)a1);
            }
            long long v45 = 0;
            unint64_t v75 = 0;
            uint64_t v77 = 0;
            int v35 = -1;
            int v17 = 1;
            goto LABEL_135;
          }
          char v170 = (char)a1;
          unint64_t v21 = "obtain AFSC data: %s";
          __int16 v22 = 840;
          goto LABEL_132;
        }
        int v165 = *__error();
        long long v168 = "fchflags UF_COMPRESSED";
        __int16 v169 = 832;
      }
    }
    else
    {
      int v165 = *__error();
      long long v168 = "Reading chunk sizes";
      __int16 v169 = 763;
    }
LABEL_189:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v169, 86, v165, v168, v166, v167, v170);
    int v17 = 0;
    long long v45 = 0;
    goto LABEL_135;
  }
  if (fgetxattr(fd, "com.apple.ResourceFork", v18, (8 * v173) + 264, 0, 32) == (8 * v173)
                                                                                              + 264)
  {
    int v79 = *v18;
    long long v80 = *((_OWORD *)v182 + 13);
    long long v208 = *((_OWORD *)v182 + 12);
    long long v209 = v80;
    long long v210 = *((_OWORD *)v182 + 14);
    int v211 = v182[60];
    long long v81 = *((_OWORD *)v182 + 9);
    long long v204 = *((_OWORD *)v182 + 8);
    long long v205 = v81;
    long long v82 = *((_OWORD *)v182 + 11);
    long long v206 = *((_OWORD *)v182 + 10);
    long long v207 = v82;
    long long v83 = *((_OWORD *)v182 + 5);
    long long v200 = *((_OWORD *)v182 + 4);
    long long v201 = v83;
    long long v84 = *((_OWORD *)v182 + 7);
    long long v202 = *((_OWORD *)v182 + 6);
    long long v203 = v84;
    long long v85 = *((_OWORD *)v182 + 1);
    long long v196 = *(_OWORD *)v182;
    long long v197 = v85;
    long long v86 = *((_OWORD *)v182 + 3);
    long long v198 = *((_OWORD *)v182 + 2);
    long long v199 = v86;
    int v181 = v18[65];
    int v35 = fd;
    int v179 = v79;
    if (v173)
    {
      int v87 = v75 + 1;
      uint64_t v88 = (v67 >> 16);
      size_t v89 = (4 * v173 + 4);
      unint64_t v90 = v180;
      do
      {
        int v91 = *(_DWORD *)v90;
        int v92 = *((_DWORD *)v90++ + 1);
        v91 += 260;
        *(v87 - 1) = v91;
        *v87++ = v91 + v92;
        --v88;
      }
      while (v88);
    }
    else
    {
      size_t v89 = 4;
    }
    goto LABEL_98;
  }
  int v160 = *__error();
  unsigned int v163 = "Reading chunk sizes";
  __int16 v164 = 749;
LABEL_183:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v164, 86, v160, v163, v161, v162, v170);
  int v17 = 0;
  long long v45 = 0;
LABEL_146:
  int v37 = -1;
LABEL_151:
  int v35 = fd;
LABEL_136:
  if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v8, v9, v10, v11, v12, v13, v14) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 877, 86, 0, "Stream close error", v118, v119, v170);
    int v17 = 0;
  }
  if ((v35 & 0x80000000) == 0) {
    close(v35);
  }
  if ((v37 & 0x80000000) == 0)
  {
    close(v37);
    unlink((const char *)&__from);
  }
  free(v18);
  free(v75);
  free(v77);
  if (v17) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ParallelCompressionAFSCCompress(const char *a1, int a2)
{
  unint64_t v61 = 0;
  unsigned int v60 = -1;
  if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v61, &v60, &v59) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 907, 86, 0, "looking up AFSC data: %s", v4, v5, (char)a1);
    return 0xFFFFFFFFLL;
  }
  unint64_t v6 = v61;
  if (!v61) {
    return 0;
  }
  if (v60 == -1)
  {
    if (!a2) {
      return 0;
    }
    int v17 = malloc(0x10000uLL);
    if (v17)
    {
      int v18 = open(a1, 2);
      if ((v18 & 0x80000000) == 0)
      {
        int v19 = v18;
        int v20 = ParallelCompressionAFSCStreamOpen(v18, v6, 0, 0);
        if (v20)
        {
          uint64_t v28 = (uint64_t)v20;
          uint64_t v29 = 0;
          unint64_t v30 = 0;
          uint64_t v31 = 0x10000;
          unint64_t v32 = 0x10000;
          while (1)
          {
            if (v6 >= v32) {
              unint64_t v33 = v32;
            }
            else {
              unint64_t v33 = v6;
            }
            if (v32 - 0x10000 >= v6)
            {
              int v51 = 1;
              goto LABEL_43;
            }
            unint64_t v34 = v33 + v29;
            ssize_t v35 = read(v19, v17, v33 + v29);
            if (v35 < 0)
            {
              int v52 = *__error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 950, 86, v52, "read: %s", v53, v54, (char)a1);
              goto LABEL_42;
            }
            if (v34 != v35)
            {
              char v58 = (char)a1;
              uint64_t v41 = "truncated read: %s";
              __int16 v42 = 951;
              goto LABEL_41;
            }
            uint64_t v39 = ParallelCompressionAFSCStreamWrite(v28, (uint64_t)v17, v34, v36, v37, v38, v26, v27);
            if (v39 < 0) {
              break;
            }
            v30 += 0x10000;
            v32 += 0x10000;
            v29 -= 0x10000;
            if (v6 >= v30) {
              unint64_t v40 = v30;
            }
            else {
              unint64_t v40 = v6;
            }
            v31 -= 0x10000;
            if (v40 + v31 != v39)
            {
              char v58 = (char)a1;
              uint64_t v41 = "truncated write: %s";
              __int16 v42 = 954;
              goto LABEL_41;
            }
          }
          char v58 = (char)a1;
          uint64_t v41 = "Stream write failed: %s";
          __int16 v42 = 953;
LABEL_41:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v42, 86, 0, v41, v26, v27, v58);
LABEL_42:
          int v51 = 0;
LABEL_43:
          if ((ParallelCompressionAFSCStreamClose(v28, v21, v22, v23, v24, v25, v26, v27) & 0x80000000) == 0) {
            goto LABEL_46;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 956, 86, 0, "AFSC compression failed: %s", v55, v56, (char)a1);
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 942, 86, 0, "creating AFSC stream: %s", v26, v27, (char)a1);
        }
        int v51 = 0;
LABEL_46:
        close(v19);
LABEL_47:
        free(v17);
        if (v51) {
          return 0;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }
      int v46 = *__error();
      char v57 = (char)a1;
      unint64_t v49 = "open: %s";
      __int16 v50 = 940;
    }
    else
    {
      int v46 = *__error();
      unint64_t v49 = "malloc";
      __int16 v50 = 938;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v50, 86, v46, v49, v47, v48, v57);
    int v51 = 0;
    goto LABEL_47;
  }
  if (a2) {
    return 0;
  }
  int v7 = open(a1, 9);
  if (v7 < 0)
  {
    int v43 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 921, 86, v43, "open: %s", v44, v45, (char)a1);
    return 0xFFFFFFFFLL;
  }
  int v8 = v7;
  ssize_t v9 = write(v7, 0, 0);
  if (v9 < 0)
  {
    uint64_t v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 922, 86, *v10, "write: %s", v11, v12, (char)a1);
  }
  if (close(v8) < 0)
  {
    uint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 923, 86, *v13, "close: %s", v14, v15, (char)a1);
  }
  return v9 >> 63;
}

void *AAChunkInputStreamOpen(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, int a5)
{
  int DefaultNThreads = a5;
  if (!a5) {
    int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v10 = calloc(1uLL, 0x68uLL);
  uint64_t v11 = malloc(0x90uLL);
  uint64_t v12 = (uint64_t)v11;
  if (!v11 || (memset_s(v11, 0x90uLL, 0, 0x90uLL), !v10))
  {
    int v21 = *__error();
    uint64_t v24 = "malloc";
    __int16 v25 = 277;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"AAChunkInputStreamOpen", v25, 66, v21, v24, v22, v23, v27);
    free(v10);
    streamClose(v12);
    return 0;
  }
  *(void *)uint64_t v12 = a1;
  *(void *)(v12 + 8) = a2;
  *(void *)(v12 + 16) = a4;
  unint64_t v13 = DefaultNThreads;
  if (DefaultNThreads * a2 > a3) {
    unint64_t v13 = a3 / a2;
  }
  if (v13 <= 1) {
    unint64_t v14 = 1;
  }
  else {
    unint64_t v14 = v13;
  }
  *(void *)(v12 + 128) = v14;
  if (!is_mul_ok(v14, 0x30uLL) || 48 * v14 >= 0x2000000001)
  {
    *__error() = 12;
    *(void *)(v12 + 136) = 0;
    goto LABEL_22;
  }
  uint64_t v15 = (char *)calloc(v14, 0x30uLL);
  *(void *)(v12 + 136) = v15;
  if (!v15)
  {
LABEL_22:
    int v21 = *__error();
    uint64_t v24 = "malloc";
    __int16 v25 = 290;
    goto LABEL_23;
  }
  uint64_t v16 = *(void *)(v12 + 128);
  if (v16)
  {
    int v17 = v15;
    size_t v18 = *(void *)(v12 + 8);
    int v19 = v15 + 16;
    while (1)
    {
      *(v19 - 2) = -1;
      if (v18 >= 0x2000000001) {
        break;
      }
      int v20 = malloc(v18);
      *int v19 = v20;
      if (!v20) {
        goto LABEL_26;
      }
      v19 += 6;
      if (!--v16) {
        goto LABEL_18;
      }
    }
    *__error() = 12;
    *((void *)v17 + 2) = 0;
LABEL_26:
    int v21 = *__error();
    uint64_t v24 = "malloc";
    __int16 v25 = 296;
    goto LABEL_23;
  }
LABEL_18:
  if (pthread_mutex_init((pthread_mutex_t *)(v12 + 32), 0) < 0)
  {
    int v21 = *__error();
    uint64_t v24 = "pthread_mutex_init";
    __int16 v25 = 298;
    goto LABEL_23;
  }
  *uint64_t v10 = v12;
  v10[1] = streamClose;
  v10[7] = streamAbort;
  v10[4] = streamPRead;
  v10[2] = streamRead;
  v10[6] = streamSeek;
  return v10;
}

uint64_t streamClose(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 16) >> 62)
    {
      int v2 = (FILE **)MEMORY[0x263EF8348];
      fwrite("ChunkInputStream\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      fprintf(*v2, "%12zu chunk size (B)\n", *(void *)(a1 + 8));
      fprintf(*v2, "%12zu chunks in cache\n", *(void *)(a1 + 128));
      uint64_t v3 = *v2;
      unint64_t v4 = atomic_load((unint64_t *)(a1 + 112));
      fprintf(v3, "%12llu bytes read from upstream\n", v4);
      uint64_t v5 = *v2;
      unint64_t v6 = atomic_load((unint64_t *)(a1 + 120));
      fprintf(v5, "%12llu bytes read from clients\n", v6);
      int v7 = *v2;
      unint64_t v8 = atomic_load((unint64_t *)(a1 + 120));
      double v9 = (double)v8 * 100.0;
      unint64_t v10 = atomic_load((unint64_t *)(a1 + 112));
      fprintf(v7, "%12.2f percent usage\n", v9 / (double)v10);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
    uint64_t v11 = *(void **)(a1 + 136);
    if (v11)
    {
      if (*(void *)(a1 + 128))
      {
        unint64_t v12 = 0;
        uint64_t v13 = 16;
        do
        {
          free(*(void **)(*(void *)(a1 + 136) + v13));
          ++v12;
          v13 += 48;
        }
        while (v12 < *(void *)(a1 + 128));
        uint64_t v11 = *(void **)(a1 + 136);
      }
      free(v11);
    }
    free((void *)a1);
  }
  return 0;
}

void streamAbort(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v1, 1u);
  if (!v1) {
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t streamPRead(uint64_t a1, char *a2, uint64_t a3, unint64_t a4)
{
  if (!atomic_load((unsigned int *)(a1 + 24)))
  {
    if (!a3) {
      return 0;
    }
    unint64_t v6 = a4;
    unint64_t v7 = a4 + a3;
    if (a4 + a3 <= a4) {
      return 0;
    }
    uint64_t v5 = 0;
    unint64_t v10 = (pthread_mutex_t *)(a1 + 32);
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v49 = v11;
    unint64_t v50 = a4 + a3;
    while (1)
    {
      unint64_t v12 = v6 / v11;
      unint64_t v13 = v6 / v11 * v11;
      if (v13 <= v6) {
        unint64_t v14 = v6;
      }
      else {
        unint64_t v14 = v6 / v11 * v11;
      }
      unint64_t v15 = v13 + v11;
      if (v7 < v15) {
        unint64_t v15 = v7;
      }
      unint64_t v51 = v15;
      uint64_t v16 = v10;
      if (pthread_mutex_lock(v10) < 0) {
        break;
      }
      uint64_t v19 = *(void *)(a1 + 128);
      if (v19)
      {
        uint64_t v20 = *(void *)(a1 + 136);
        uint64_t v21 = v20;
        uint64_t v22 = *(void *)(a1 + 128);
        do
        {
          if (*(void *)v21 == v12)
          {
LABEL_32:
            __int16 v25 = v16;
            *(void *)(v21 + 8) = atomic_fetch_add((atomic_ullong *volatile)(a1 + 96), 1uLL);
            atomic_fetch_add((atomic_uint *volatile)(v21 + 40), 1u);
            goto LABEL_33;
          }
          v21 += 48;
          --v22;
        }
        while (v22);
        uint64_t v21 = *(void *)(a1 + 136);
        uint64_t v23 = *(void *)(a1 + 128);
        do
        {
          if (*(void *)v21 == -1)
          {
            uint64_t v24 = -1;
LABEL_28:
            if (v24 != v12)
            {
              int v26 = atomic_load((unsigned int *)(v21 + 40));
              if (v26 >= 1)
              {
                do
                {
                  pthread_yield_np();
                  int v27 = atomic_load((unsigned int *)(v21 + 40));
                }
                while (v27 > 0);
              }
              *(void *)uint64_t v21 = v12;
              *(void *)(v21 + 24) = 0;
              atomic_store(0, (unsigned int *)(v21 + 32));
              atomic_store(0, (unsigned int *)(v21 + 36));
              atomic_store(0, (unsigned int *)(v21 + 40));
            }
            goto LABEL_32;
          }
          v21 += 48;
          --v23;
        }
        while (v23);
        uint64_t v21 = 0;
        do
        {
          if (!v21 || *(void *)(v20 + 8) < *(void *)(v21 + 8)) {
            uint64_t v21 = v20;
          }
          v20 += 48;
          --v19;
        }
        while (v19);
        if (v21)
        {
          uint64_t v24 = *(void *)v21;
          goto LABEL_28;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamGetChunk", 75, 66, 0, "Invalid state", v17, v18, v48);
      uint64_t v21 = 0;
      __int16 v25 = v16;
LABEL_33:
      if (pthread_mutex_unlock(v25) < 0)
      {
        unint64_t v30 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamGetChunk", 107, 66, *v30, "pthread_mutex_unlock", v31, v32, v48);
      }
      if (!v21) {
        goto LABEL_54;
      }
      while (!atomic_load((unsigned int *)(v21 + 32)))
      {
        unsigned int v34 = atomic_load((unsigned int *)(a1 + 24));
        if (v34) {
          goto LABEL_57;
        }
        atomic_compare_exchange_strong((atomic_uint *volatile)(v21 + 36), &v34, 1u);
        if (v34)
        {
          pthread_yield_np();
        }
        else
        {
          ssize_t v35 = AAByteStreamPRead(*(AAByteStream *)a1, *(void **)(v21 + 16), *(void *)(a1 + 8), *(void *)(a1 + 8) * v12);
          if (v35 < 0)
          {
            uint64_t v41 = "Stream read";
            __int16 v42 = 132;
LABEL_56:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamReadChunkData", v42, 66, 0, v41, v28, v29, v48);
LABEL_57:
            atomic_fetch_add((atomic_uint *volatile)(v21 + 40), 0xFFFFFFFF);
            goto LABEL_58;
          }
          int v36 = 0;
          *(void *)(v21 + 24) = v35;
          atomic_compare_exchange_strong((atomic_uint *volatile)(v21 + 32), (unsigned int *)&v36, 1u);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 112), v35, memory_order_relaxed);
        }
      }
      unint64_t v37 = v14 - v13;
      unint64_t v38 = *(void *)(v21 + 24);
      if (v38 < v14 - v13)
      {
        uint64_t v41 = "Read out of range";
        __int16 v42 = 148;
        goto LABEL_56;
      }
      if (v38 >= v51 - v13) {
        size_t v39 = v51 - v14;
      }
      else {
        size_t v39 = v38 - (v14 - v13);
      }
      memcpy(a2, (const void *)(*(void *)(v21 + 16) + v37), v39);
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 120), v39, memory_order_relaxed);
      atomic_fetch_add((atomic_uint *volatile)(v21 + 40), 0xFFFFFFFF);
      if ((v39 & 0x8000000000000000) != 0) {
        goto LABEL_60;
      }
      if (v39)
      {
        v5 += v39;
        v6 += v39;
        a2 += v39;
        unint64_t v11 = v49;
        unint64_t v7 = v50;
        unint64_t v10 = v16;
        if (v6 < v50) {
          continue;
        }
      }
      return v5;
    }
    int v43 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamGetChunk", 51, 66, *v43, "pthread_mutex_lock", v44, v45, v48);
LABEL_54:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamReadChunkData", 119, 66, 0, "get a valid chunk from cache", v28, v29, v48);
LABEL_58:
    int v46 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v46, 1u);
    if (!v46) {
      AAByteStreamCancel(*(AAByteStream *)a1);
    }
LABEL_60:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkInputStream.c", (uint64_t)"streamPRead", 215, 66, 0, "Reading chunk data failed", v28, v29, v48);
    int v47 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v47, 1u);
    if (!v47) {
      AAByteStreamCancel(*(AAByteStream *)a1);
    }
  }
  return -1;
}

uint64_t streamRead(uint64_t a1, char *a2, unint64_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 24))) {
    return -1;
  }
  else {
    return streamPRead(a1, a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 104), a3));
  }
}

uint64_t streamSeek(uint64_t a1, off_t a2, int a3)
{
  if (atomic_load((unsigned int *)(a1 + 24))) {
    return -1;
  }
  if (!a3) {
    goto LABEL_8;
  }
  if (a3 == 1)
  {
    a2 += atomic_fetch_add((atomic_ullong *volatile)(a1 + 104), a2);
    return a2;
  }
  if (a3 != 2) {
    return -1;
  }
  a2 = AAByteStreamSeek(*(AAByteStream *)a1, a2, 2);
  if (a2 < 0) {
    return -1;
  }
LABEL_8:
  atomic_store(a2, (unint64_t *)(a1 + 104));
  return a2;
}

uint64_t CC_CKSUM_Init(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  return 1;
}

uint64_t CC_CKSUM_Update(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3 = *(_DWORD *)a1;
  if (a3)
  {
    uint64_t v4 = a3;
    uint64_t v5 = a3;
    do
    {
      int v6 = *a2++;
      unsigned int v3 = CKSUMTable[v6 ^ HIBYTE(v3)] ^ (v3 << 8);
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(_DWORD *)a1 = v3;
  *(void *)(a1 + 8) += v4;
  return 1;
}

uint64_t CC_CKSUM_Final(unsigned int *a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)a2;
  unint64_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    do
    {
      unsigned int v2 = CKSUMTable[v3 ^ HIBYTE(v2)] ^ (v2 << 8);
      BOOL v4 = v3 > 0xFF;
      v3 >>= 8;
    }
    while (v4);
  }
  *a1 = ~v2;
  return 1;
}

uint64_t (**AAChunkAsyncStreamOpen(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8))(void)
{
  int DefaultNThreads = a5;
  if (a5)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"AAChunkAsyncStreamOpen", 651, 143, 0, "invalid chunk size", a7, a8, v28);
    uint64_t v16 = 0;
LABEL_16:
    chunkAsyncClose(v16);
    uint64_t v18 = 0;
    goto LABEL_17;
  }
  int DefaultNThreads = getDefaultNThreads();
  if (!a2) {
    goto LABEL_12;
  }
LABEL_3:
  unint64_t v13 = malloc(0xF0uLL);
  uint64_t v16 = (uint64_t)v13;
  if (!v13)
  {
    __int16 v24 = 655;
    int v25 = 0;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"AAChunkAsyncStreamOpen", v24, 143, v25, "malloc", v14, v15, v28);
    goto LABEL_16;
  }
  memset_s(v13, 0xF0uLL, 0, 0xF0uLL);
  uint64_t v17 = (uint64_t (**)(void))aaAsyncByteStreamAlloc(v16, (uint64_t)chunkAsyncClose, ~(a4 >> 55) & 4, 20.0, 1.0);
  if (!v17)
  {
    int v25 = *__error();
    __int16 v24 = 657;
    goto LABEL_15;
  }
  uint64_t v18 = v17;
  *(void *)(v16 + 8) = a2;
  *(void *)(v16 + 16) = a4;
  *(void *)uint64_t v16 = a1;
  *(_DWORD *)(v16 + 24) = a4 >> 62;
  if (a3 == -1) {
    unint64_t v19 = DefaultNThreads;
  }
  else {
    unint64_t v19 = a3 / a2;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(v16 + 32), 0))
  {
    uint64_t v22 = "mutex init";
    __int16 v23 = 668;
  }
  else
  {
    if (v19 <= 1) {
      unint64_t v27 = 1;
    }
    else {
      unint64_t v27 = v19;
    }
    if ((lockedStateReserveActiveChunks(v16, v27) & 0x80000000) != 0)
    {
      uint64_t v22 = "init active chunks";
      __int16 v23 = 669;
    }
    else
    {
      v18[2] = (uint64_t (*)(void))chunkAsyncGetRange;
      v18[3] = (uint64_t (*)(void))chunkAsyncProcess;
      v18[4] = (uint64_t (*)(void))chunkAsyncCancel;
      v18[5] = (uint64_t (*)(void))chunkAsyncIsCancelled;
      if ((createThread((pthread_t *)(v16 + 192), (uint64_t)streamProc, v16, 0) & 0x80000000) == 0) {
        return v18;
      }
      uint64_t v22 = "createThread";
      __int16 v23 = 678;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"AAChunkAsyncStreamOpen", v23, 143, 0, v22, v20, v21, v28);
LABEL_17:
  AAAsyncByteStreamClose(v18);
  return 0;
}

uint64_t chunkAsyncClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(result + 204), (unsigned int *)&v2, 1u);
    unint64_t v3 = *(_opaque_pthread_t **)(result + 192);
    if (v3) {
      joinThread(v3);
    }
    unsigned int v4 = atomic_load((unsigned int *)(v1 + 200));
    if (*(_DWORD *)(v1 + 24))
    {
      uint64_t v5 = (FILE **)MEMORY[0x263EF8348];
      fwrite("AAChunkAsyncStream\n", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      fprintf(*v5, "%12zu chunk size\n", *(void *)(v1 + 8));
      fprintf(*v5, "%12zu allocated chunks\n", *(void *)(v1 + 96));
      int v6 = *v5;
      unint64_t v7 = atomic_load((unint64_t *)(v1 + 208));
      fprintf(v6, "%12llu ranges requested\n", v7);
      unint64_t v8 = *v5;
      unint64_t v9 = atomic_load((unint64_t *)(v1 + 224));
      fprintf(v8, "%12llu chunks processed\n", v9);
      fprintf(*v5, "%12zu bytes in chunks (%.2f MB)\n", *(void *)(v1 + 8) * *(void *)(v1 + 96), (double)(unint64_t)(*(void *)(v1 + 8) * *(void *)(v1 + 96)) * 0.000000953674316);
      unint64_t v10 = *v5;
      unint64_t v11 = atomic_load((unint64_t *)(v1 + 216));
      unint64_t v12 = atomic_load((unint64_t *)(v1 + 216));
      fprintf(v10, "%12llu bytes requested in ranges (%.2f MB)\n", v11, (double)v12 * 0.000000953674316);
      unint64_t v13 = *v5;
      unint64_t v14 = atomic_load((unint64_t *)(v1 + 232));
      unint64_t v15 = atomic_load((unint64_t *)(v1 + 232));
      fprintf(v13, "%12llu bytes processed in chunks (%.2f MB)\n", v14, (double)v15 * 0.000000953674316);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
    free(*(void **)(v1 + 168));
    if (*(void *)(v1 + 96))
    {
      unint64_t v16 = 0;
      uint64_t v17 = 40;
      do
      {
        free(*(void **)(*(void *)(v1 + 104) + v17));
        ++v16;
        v17 += 48;
      }
      while (v16 < *(void *)(v1 + 96));
    }
    free(*(void **)(v1 + 104));
    free(*(void **)(v1 + 120));
    free(*(void **)(v1 + 184));
    memset_s((void *)v1, 0xF0uLL, 0, 0xF0uLL);
    free((void *)v1);
    if (v4) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t lockedStateReserveActiveChunks(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 96) >= a2) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 24) >= 3u) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "    %zu active chunks\n", a2);
  }
  if (48 * a2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_15:
    *(void *)(a1 + 104) = 0;
    int v14 = *__error();
    __int16 v17 = 147;
    goto LABEL_16;
  }
  uint64_t v5 = *(void **)(a1 + 104);
  int v6 = realloc(v5, 48 * a2);
  if (!v6)
  {
    free(v5);
    goto LABEL_15;
  }
  *(void *)(a1 + 104) = v6;
  unint64_t v7 = *(void *)(a1 + 96);
  unint64_t v8 = a2 - v7;
  if (a2 <= v7)
  {
LABEL_13:
    uint64_t result = 0;
    *(void *)(a1 + 96) = a2;
    return result;
  }
  uint64_t v9 = 48 * v7;
  while (1)
  {
    uint64_t v10 = *(void *)(a1 + 104);
    size_t v11 = *(void *)(a1 + 8);
    if (v11 >= 0x2000000001) {
      break;
    }
    unint64_t v12 = malloc(v11);
    uint64_t v13 = v10 + v9;
    *(void *)(v10 + v9 + 40) = v12;
    if (!v12) {
      goto LABEL_18;
    }
    *(_DWORD *)uint64_t v13 = 0;
    *(void *)(v13 + 16) = 0;
    *(void *)(v13 + 24) = 0;
    v9 += 48;
    *(void *)(v13 + 8) = -1;
    if (!--v8) {
      goto LABEL_13;
    }
  }
  *__error() = 12;
  *(void *)(v10 + v9 + 40) = 0;
LABEL_18:
  int v14 = *__error();
  __int16 v17 = 152;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"lockedStateReserveActiveChunks", v17, 143, v14, "malloc", v15, v16, v18);
  return 0xFFFFFFFFLL;
}

uint64_t chunkAsyncGetRange(uint64_t a1, void *a2, void *a3)
{
  if (atomic_load((unsigned int *)(a1 + 200))) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v7 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncGetRange", 519, 143, 0, "lock", v8, v9, v24);
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = *(void *)(a1 + 96);
  if (v12)
  {
    uint64_t v13 = 0;
    int v14 = *(int **)(a1 + 104);
    while (1)
    {
      int v15 = *v14;
      v14 += 12;
      if (v15 == 1) {
        break;
      }
      if (v12 == ++v13) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  if (v13 != v12)
  {
    uint64_t v16 = *(void *)(a1 + 104);
    uint64_t v17 = v16 + 48 * v13;
    *(_DWORD *)uint64_t v17 = 2;
    *a3 = *(void *)(v17 + 16);
    uint64_t v20 = v17 + 16;
    uint64_t v19 = *(void *)(v17 + 16);
    uint64_t v18 = *(void *)(v20 + 8);
    *a2 = v18 - v19;
    if (*(_DWORD *)(a1 + 24) >= 3u) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "<-- chunk %10llx %10llx -- %8zu\n", v19, v18, *(void *)(v16 + 48 * v13 + 8));
    }
    goto LABEL_19;
  }
LABEL_13:
  if (!*(void *)(a1 + 160) && *(_DWORD *)(a1 + 128))
  {
    *a2 = 0;
    *a3 = 0;
LABEL_19:
    if (*(_DWORD *)(a1 + 24) < 3u || *a2)
    {
      uint64_t v10 = 1;
    }
    else
    {
      uint64_t v10 = 1;
      fwrite("<-- EOF\n", 8uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    goto LABEL_22;
  }
  uint64_t v10 = 0;
LABEL_22:
  if (!pthread_mutex_unlock(v7)) {
    return v10;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncGetRange", 546, 143, 0, "unlock", v21, v22, v24);
  int v23 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 200), (unsigned int *)&v23, 1u);
  if (!v23) {
    AAAsyncByteStreamCancel(*(void **)a1);
  }
  return 0xFFFFFFFFLL;
}

uint64_t chunkAsyncProcess(uint64_t a1, const void *a2, unint64_t a3, unint64_t a4)
{
  if (atomic_load((unsigned int *)(a1 + 200))) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    uint64_t v12 = "lock";
    __int16 v13 = 556;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncProcess", v13, 143, 0, v12, v10, v11, v20);
    return 0xFFFFFFFFLL;
  }
  if ((a4 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = "invalid range";
    __int16 v13 = 559;
    goto LABEL_4;
  }
  v21[0] = a4;
  v21[1] = a4 + a3;
  if (__CFADD__(a4, a3))
  {
    uint64_t v12 = "invalid range";
    __int16 v13 = 561;
    goto LABEL_4;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 232), a3, memory_order_relaxed);
  atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 224), 1uLL, memory_order_relaxed);
  uint64_t v15 = *(void *)(a1 + 96);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 104);
    while (*(_DWORD *)v16 != 2 || rangeCmp((unint64_t *)(v16 + 16), v21))
    {
      v16 += 48;
      if (!--v15) {
        goto LABEL_17;
      }
    }
    memcpy(*(void **)(v16 + 40), a2, a3);
    *(_DWORD *)uint64_t v16 = 3;
    if (*(_DWORD *)(a1 + 24) >= 3u) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "--> chunk %10llx %10llx -- %8zu\n", *(void *)(v16 + 16), *(void *)(v16 + 24), *(void *)(v16 + 8));
    }
  }
LABEL_17:
  uint64_t result = pthread_mutex_unlock(v9);
  if (result)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"chunkAsyncProcess", 582, 143, 0, "unlock", v17, v18, v20);
    int v19 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 200), (unsigned int *)&v19, 1u);
    if (!v19) {
      AAAsyncByteStreamCancel(*(void **)a1);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

atomic_uint *chunkAsyncCancel(atomic_uint *result)
{
  int v1 = 0;
  atomic_compare_exchange_strong(result + 50, (unsigned int *)&v1, 1u);
  if (!v1) {
    return (atomic_uint *)AAAsyncByteStreamCancel(*(void **)result);
  }
  return result;
}

uint64_t chunkAsyncIsCancelled(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 200));
}

void **streamProc(void **a1)
{
  if (atomic_load((unsigned int *)a1 + 51)) {
    return a1;
  }
  unint64_t v172 = a1 + 17;
  unint64_t v173 = (uint64_t *)(a1 + 19);
  unint64_t v3 = (pthread_mutex_t *)(a1 + 4);
  uint64_t v174 = (pthread_mutex_t *)(a1 + 4);
  while (1)
  {
    if (*((_DWORD *)a1 + 32))
    {
LABEL_4:
      uint64_t v4 = 0;
      goto LABEL_5;
    }
    unint64_t v53 = (void)a1[1] * (void)a1[12];
    uint64_t v54 = a1[20];
    if (v54)
    {
      unint64_t v55 = 0;
      uint64_t v56 = a1[21] + 1;
      do
      {
        unint64_t v55 = *v56 + v55 - *(v56 - 1);
        v56 += 2;
        uint64_t v54 = (void *)((char *)v54 - 1);
      }
      while (v54);
      unint64_t v176 = v53 + (v53 >> 2);
      if (v55 > v176) {
        goto LABEL_4;
      }
    }
    else
    {
      unint64_t v55 = 0;
      unint64_t v176 = v53 + (v53 >> 2);
    }
    uint64_t v4 = 0;
    while (1)
    {
      unint64_t v178 = 0;
      unint64_t v179 = 0;
      int Range = AAAsyncByteStreamGetRange(*a1, &v178, (uint64_t *)&v179);
      if (Range < 0)
      {
        __int16 v157 = "GetRange";
        __int16 v158 = 220;
LABEL_269:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateFetchRanges", v158, 143, 0, v157, v58, v59, v170);
        goto LABEL_270;
      }
      if (!Range) {
        goto LABEL_200;
      }
      if (!v178) {
        break;
      }
      unint64_t v60 = v179;
      if ((v179 & 0x8000000000000000) != 0)
      {
        __int16 v157 = "invalid range";
        __int16 v158 = 228;
        goto LABEL_269;
      }
      unint64_t v61 = (void *)(v179 + v178);
      *(void *)&long long v180 = v179;
      *((void *)&v180 + 1) = v179 + v178;
      if (__CFADD__(v179, v178))
      {
        __int16 v157 = "invalid range overflow";
        __int16 v158 = 230;
        goto LABEL_269;
      }
      unsigned int v62 = a1[20];
      if (!v62) {
        goto LABEL_98;
      }
      uint64_t v63 = v4;
      int v64 = a1[21];
      if (rangeCmp(v64, (unint64_t *)&v180))
      {
        int v65 = 0;
        int v66 = v64 + 2;
        do
        {
          if ((void *)((char *)v62 - 1) == v65) {
            goto LABEL_98;
          }
          int v67 = rangeCmp(v66, (unint64_t *)&v180);
          v66 += 2;
          int v65 = (void *)((char *)v65 + 1);
        }
        while (v67);
        if (v65 >= v62)
        {
LABEL_98:
          uint64_t v68 = *v173;
          if ((unint64_t)v62 < *v173)
          {
LABEL_104:
            if (*((_DWORD *)a1 + 6) >= 3u) {
              fprintf((FILE *)*MEMORY[0x263EF8348], "<<< range %10llx %10llx\n", v60, v61);
            }
            int v74 = a1[20];
            int v73 = a1[21];
            a1[20] = (void *)((char *)v74 + 1);
            *(_OWORD *)&v73[2 * (void)v74] = v180;
            v55 += (unint64_t)v61 - v60;
            atomic_fetch_add_explicit((atomic_ullong *volatile)a1 + 27, (unint64_t)v61 - v60, memory_order_relaxed);
            atomic_fetch_add_explicit((atomic_ullong *volatile)a1 + 26, 1uLL, memory_order_relaxed);
            unint64_t v75 = a1[17];
            int v76 = a1[18];
            unint64_t v3 = v174;
            if (v75 == v76)
            {
              *unint64_t v172 = v180;
            }
            else if (v61 != (void *)v60)
            {
              if ((unint64_t)v75 >= v60) {
                unint64_t v75 = (void *)v60;
              }
              if (v61 > v76) {
                int v76 = v61;
              }
              a1[17] = v75;
              a1[18] = v76;
            }
            uint64_t v4 = 1;
            goto LABEL_115;
          }
          uint64_t v69 = 2 * v68;
          BOOL v33 = v68 == 0;
          uint64_t v70 = 32;
          if (!v33) {
            uint64_t v70 = v69;
          }
          uint64_t *v173 = v70;
          if ((unint64_t)(16 * v70) >= 0x2000000001)
          {
            *__error() = 12;
          }
          else
          {
            unsigned int v71 = a1[21];
            size_t v72 = realloc(v71, 16 * v70);
            if (v72)
            {
              a1[21] = v72;
              goto LABEL_104;
            }
            free(v71);
          }
          a1[21] = 0;
          uint64_t v167 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateFetchRanges", 248, 143, *v167, "malloc", v168, v169, v170);
          uint64_t *v173 = 0;
          v173[1] = 0;
LABEL_270:
          uint64_t v159 = "fetching ranges";
          __int16 v160 = 493;
          goto LABEL_279;
        }
      }
      unint64_t v3 = v174;
      uint64_t v4 = v63;
LABEL_115:
      if (v55 > v176) {
        goto LABEL_200;
      }
    }
    if (*((_DWORD *)a1 + 6) >= 3u) {
      fwrite("<<< range EOF\n", 0xEuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    *((_DWORD *)a1 + 32) = 1;
LABEL_200:
    if (v4) {
      stateSortRanges((uint64_t)a1);
    }
LABEL_5:
    if (pthread_mutex_lock(v3))
    {
      uint64_t v161 = "lock";
      __int16 v162 = 276;
      goto LABEL_273;
    }
    unint64_t v7 = a1[20];
    if (!v7) {
      goto LABEL_118;
    }
    int v8 = 0;
    unint64_t v9 = 0;
    char v10 = 1;
    while (2)
    {
      uint64_t v11 = a1[21];
      unint64_t v12 = (unint64_t)a1[1];
      while (2)
      {
        __int16 v13 = &v11[2 * v9];
        uint64_t v15 = (unint64_t *)(v13 + 1);
        unint64_t v14 = v13[1];
        unint64_t v16 = *v13;
        unint64_t v17 = *v13 / v12;
        unint64_t v18 = (v14 + v12 - 1) / v12;
        if (v17 < v18)
        {
          unint64_t v19 = (unint64_t)a1[14];
          if (v19 <= v17) {
            unint64_t v19 = v16 / v12;
          }
          BOOL v20 = 1;
          unint64_t v21 = v11[2 * v9];
          unint64_t v22 = v16 / v12;
          while (v22 != v19)
          {
            uint64_t v23 = a1[15][v22];
            if (v23 == -1) {
              break;
            }
            char v24 = a1[13];
            int v25 = v24[6 * v23];
            if (!v25 || v22 != v24[6 * v23 + 1])
            {
              __int16 v49 = 291;
              int v50 = 0;
              unint64_t v51 = "invalid state";
              goto LABEL_78;
            }
            if (v25 != 3) {
              break;
            }
            if (v21 == v14
              || (v21 <= v22 * v12 ? (unint64_t v26 = v22 * v12) : (unint64_t v26 = v21),
                  v22 * v12 + v12 >= v14 ? (unint64_t v27 = (char *)v13[1]) : (unint64_t v27 = (char *)(v22 * v12 + v12)),
                  v26 >= (unint64_t)v27))
            {
              unint64_t v26 = 0;
              unint64_t v27 = 0;
            }
            unint64_t v28 = 0;
            uint64_t v29 = &v24[6 * v23];
            unint64_t v31 = v29[2];
            unint64_t v30 = v29[3];
            if (v31 != v30) {
              unint64_t v21 = v13[1];
            }
            unint64_t v32 = 0;
            if (v14 != v16 && v31 != v30)
            {
              if (v16 <= v31) {
                unint64_t v32 = v31;
              }
              else {
                unint64_t v32 = v11[2 * v9];
              }
              if (v30 >= v14) {
                unint64_t v28 = v13[1];
              }
              else {
                unint64_t v28 = v30;
              }
              if (v32 >= v28)
              {
                unint64_t v28 = 0;
                unint64_t v32 = 0;
              }
              else if (v27 == (char *)v26)
              {
                break;
              }
              unint64_t v21 = v11[2 * v9];
            }
            BOOL v33 = v27 != (char *)v26 && v28 == v32;
            BOOL v34 = v33;
            if ((unint64_t)v27 < v28 || v32 != v26 || v34) {
              break;
            }
            if (v28 >= (unint64_t)v27)
            {
              BOOL v20 = ++v22 < v18;
              if (v22 != v18) {
                continue;
              }
            }
            if (!v20) {
              goto LABEL_56;
            }
            break;
          }
          if (++v9 < (unint64_t)v7) {
            continue;
          }
          if ((v10 & 1) == 0)
          {
LABEL_257:
            stateSortRanges((uint64_t)a1);
            int v52 = 0;
            goto LABEL_119;
          }
LABEL_118:
          int v52 = 0;
          int v8 = 0;
          goto LABEL_119;
        }
        break;
      }
LABEL_56:
      int v175 = v8;
      unint64_t v35 = v14 - v16;
      if (v14 - v16 > (unint64_t)a1[22])
      {
        a1[22] = (void *)v35;
        if (v35 >= 0x2000000001)
        {
          *__error() = 12;
        }
        else
        {
          uint64_t v36 = v4;
          unint64_t v37 = a1[23];
          unint64_t v38 = realloc(v37, v14 - v16);
          if (v38)
          {
            a1[23] = v38;
            uint64_t v4 = v36;
            goto LABEL_60;
          }
          free(v37);
          uint64_t v4 = v36;
          unint64_t v3 = v174;
        }
        a1[23] = 0;
        uint64_t v154 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", 314, 143, *v154, "malloc", v155, v156, v170);
        a1[22] = 0;
        int v52 = 1;
LABEL_259:
        int v8 = v175;
        goto LABEL_119;
      }
LABEL_60:
      if (v17 < v18)
      {
        unint64_t v39 = 0;
        while (1)
        {
          unint64_t v40 = a1[13];
          uint64_t v41 = a1[15][v17];
          __int16 v42 = &v40[6 * v41];
          unint64_t v43 = v42[2];
          unint64_t v44 = v42[3];
          if (v43 == v44) {
            goto LABEL_69;
          }
          unint64_t v45 = *v13;
          if (*v13 == *v15) {
            goto LABEL_69;
          }
          if (v45 <= v43) {
            unint64_t v45 = v43;
          }
          if (v44 >= *v15) {
            unint64_t v44 = *v15;
          }
          if (v45 >= v44)
          {
LABEL_69:
            unint64_t v45 = 0;
            unint64_t v44 = 0;
          }
          unint64_t v46 = v44 - v45 + v39;
          if (v46 > v35) {
            break;
          }
          memcpy((char *)a1[23] + v39, (const void *)(v40[6 * v41 + 5] + v45 - v43), v44 - v45);
          ++v17;
          unint64_t v39 = v46;
          if (v17 == v18) {
            goto LABEL_72;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", 328, 143, 0, "invalid state", v5, v6, v170);
        int v52 = 1;
        unint64_t v3 = v174;
        goto LABEL_259;
      }
LABEL_72:
      uint64_t v47 = *v15;
      uint64_t v48 = *v13;
      if (*((_DWORD *)a1 + 6) >= 3u)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], ">>> range %10llx %10llx\n", *v13, v47);
        uint64_t v47 = *v15;
        uint64_t v48 = *v13;
      }
      unint64_t v3 = v174;
      int v8 = v175;
      if ((AAAsyncByteStreamProcess(*a1, (uint64_t)a1[23], v47 - v48, v48) & 0x80000000) == 0)
      {
        char v10 = 0;
        *__int16 v13 = 0;
        v13[1] = 0;
        unint64_t v7 = a1[20];
        ++v9;
        int v8 = 1;
        if (v9 >= (unint64_t)v7) {
          goto LABEL_257;
        }
        continue;
      }
      break;
    }
    int v50 = *__error();
    __int16 v49 = 336;
    unint64_t v51 = "process range";
LABEL_78:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", v49, 143, v50, v51, v5, v6, v170);
    int v52 = 1;
LABEL_119:
    if (pthread_mutex_unlock(v3))
    {
      uint64_t v161 = "unlock";
      __int16 v162 = 347;
LABEL_273:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateRetireRanges", v162, 143, 0, v161, v5, v6, v170);
LABEL_274:
      uint64_t v159 = "retiring ranges";
      __int16 v160 = 497;
      goto LABEL_279;
    }
    if (v52) {
      goto LABEL_274;
    }
    if (!a1[20])
    {
      int v85 = 0;
      goto LABEL_252;
    }
    if (pthread_mutex_lock(v3)) {
      break;
    }
    unint64_t v77 = (unint64_t)a1[14];
    unint64_t v78 = (unint64_t)a1[12];
    int v79 = a1[20];
    if (v79)
    {
      unint64_t v80 = (unint64_t)a1[1];
      long long v81 = a1[21] + 1;
      do
      {
        unint64_t v82 = (v80 - 1 + *v81) / v80;
        if (v82 > v77) {
          unint64_t v77 = (v80 - 1 + *v81) / v80;
        }
        if (v82 - *(v81 - 1) / v80 > v78) {
          unint64_t v78 = v82 - *(v81 - 1) / v80;
        }
        v81 += 2;
        int v79 = (void *)((char *)v79 - 1);
      }
      while (v79);
    }
    if ((lockedStateReserveActiveChunks((uint64_t)a1, v78) & 0x80000000) != 0) {
      goto LABEL_247;
    }
    if ((unint64_t)a1[14] >= v77) {
      goto LABEL_141;
    }
    if (*((_DWORD *)a1 + 6) >= 3u) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "    %zu chunks\n", v77);
    }
    if (8 * v77 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_246;
    }
    uint64_t v86 = v4;
    uint64_t v4 = (uint64_t)a1[15];
    int v87 = realloc((void *)v4, 8 * v77);
    if (!v87)
    {
      free((void *)v4);
      LODWORD(v4) = v86;
LABEL_246:
      a1[15] = 0;
      uint64_t v150 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"lockedStateReserveChunks", 172, 143, *v150, "malloc", v151, v152, v170);
      a1[14] = 0;
LABEL_247:
      __int16 v118 = 375;
      uint64_t v119 = "reserving chunks";
      goto LABEL_248;
    }
    a1[15] = v87;
    unint64_t v88 = (unint64_t)a1[14];
    if (v88 < v77) {
      memset(&v87[v88], 255, 8 * v77 - 8 * v88);
    }
    a1[14] = (void *)v77;
    uint64_t v4 = v86;
LABEL_141:
    size_t v89 = a1[12];
    if (v89)
    {
      unint64_t v90 = a1[13] + 4;
      int v91 = a1[12];
      do
      {
        *unint64_t v90 = 0;
        v90 += 6;
        int v91 = (void *)((char *)v91 - 1);
      }
      while (v91);
    }
    int v92 = a1[20];
    if (v92)
    {
      uint64_t v93 = 0;
      uint64_t v94 = a1[21];
      unint64_t v95 = (unint64_t)a1[1];
      while (1)
      {
        int v96 = &v94[2 * v93];
        unint64_t v97 = *v96;
        unint64_t v98 = v96[1];
        unint64_t v99 = v97 / v95;
        unint64_t v100 = (v95 - 1 + v98) / v95;
        if (v97 / v95 < v100) {
          break;
        }
LABEL_184:
        if ((void *)++v93 == v92) {
          goto LABEL_185;
        }
      }
      unsigned int v101 = a1[15];
      unint64_t v102 = v98;
      while (2)
      {
        uint64_t v103 = v101[v99];
        if (v103 != -1)
        {
          size_t v104 = a1[13];
          if (!LODWORD(v104[6 * v103]) || v99 != v104[6 * v103 + 1])
          {
            __int16 v118 = 389;
            uint64_t v119 = "invalid state";
LABEL_248:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", v118, 143, 0, v119, v83, v84, v170);
            int v85 = 0;
LABEL_249:
            int v149 = 1;
            goto LABEL_250;
          }
          if (v97 == v102) {
            goto LABEL_157;
          }
          unint64_t v105 = v99 * v95;
          long long v106 = (char *)(v99 * v95 + v95);
          if (v97 > v99 * v95) {
            unint64_t v105 = v97;
          }
          if ((unint64_t)v106 >= v102) {
            long long v106 = (char *)v102;
          }
          if (v105 >= (unint64_t)v106)
          {
LABEL_157:
            unint64_t v105 = 0;
            long long v106 = 0;
          }
          unint64_t v83 = 0;
          long long v107 = &v104[6 * v103];
          unint64_t v109 = v107[2];
          unint64_t v108 = v107[3];
          if (v109 != v108) {
            unint64_t v102 = v97;
          }
          unint64_t v84 = 0;
          if (v97 != v98 && v109 != v108)
          {
            if (v97 <= v109) {
              unint64_t v84 = v109;
            }
            else {
              unint64_t v84 = v97;
            }
            if (v108 >= v98) {
              unint64_t v83 = v98;
            }
            else {
              unint64_t v83 = v108;
            }
            if (v84 >= v83)
            {
              unint64_t v83 = 0;
              unint64_t v84 = 0;
            }
            else
            {
              unint64_t v102 = v98;
              if (v106 == (char *)v105) {
                goto LABEL_183;
              }
            }
            unint64_t v102 = v98;
          }
          BOOL v111 = v106 != (char *)v105 && v83 == v84;
          if (v106 == (char *)v83 && v84 == v105 && !v111) {
            ++v104[6 * v103 + 4];
          }
        }
LABEL_183:
        if (++v99 == v100) {
          goto LABEL_184;
        }
        continue;
      }
    }
LABEL_185:
    if (v89)
    {
      uint64_t v112 = 0;
      int v85 = 0;
      unint64_t v113 = 0;
      while (1)
      {
        uint64_t v114 = a1[13];
        if (!v114[v112 + 4] && LODWORD(v114[v112]))
        {
          int v115 = &v114[v112];
          unint64_t v116 = v114[v112 + 1];
          if (v116 >= (unint64_t)a1[14])
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", 410, 143, 0, "invalid chunk index", v83, v84, v170);
            goto LABEL_249;
          }
          a1[15][v116] = -1;
          *(_DWORD *)int v115 = 0;
          v115[2] = 0;
          unsigned int v115[3] = 0;
          v115[1] = -1;
          size_t v89 = a1[12];
          int v85 = 1;
        }
        ++v113;
        v112 += 6;
        if (v113 >= (unint64_t)v89)
        {
          if (v89)
          {
            int v117 = a1[13] + 4;
            do
            {
              *int v117 = 0;
              v117 += 6;
              size_t v89 = (void *)((char *)v89 - 1);
            }
            while (v89);
          }
          goto LABEL_203;
        }
      }
    }
    int v85 = 0;
LABEL_203:
    uint64_t v120 = a1[20];
    if (!v120)
    {
      int v149 = 0;
      goto LABEL_250;
    }
    unint64_t v121 = 0;
    int v177 = v8;
    while (1)
    {
      uint64_t v122 = &a1[21][2 * v121];
      unint64_t v123 = (unint64_t)a1[1];
      unint64_t v124 = *v122 / v123;
      uint64_t v171 = v122;
      uint64_t v126 = v122[1];
      __int16 v125 = v122 + 1;
      unint64_t v127 = (v123 + v126 - 1) / v123;
      if (!v121 && v124 < v127)
      {
        uint64_t v128 = a1[15];
        unint64_t v129 = v124;
        do
        {
          uint64_t v130 = v128[v129];
          if (v130 != -1) {
            a1[13][6 * v130 + 4] = 1;
          }
          ++v129;
        }
        while (v129 != v127);
      }
      if (v124 < v127) {
        break;
      }
LABEL_241:
      int v149 = 0;
      ++v121;
      int v8 = v177;
      if (v121 >= (unint64_t)v120) {
        goto LABEL_250;
      }
    }
    while (2)
    {
      uint64_t v131 = a1[15];
      if (v131[v124] != -1) {
        goto LABEL_239;
      }
      unsigned int v132 = a1[12];
      if (v132)
      {
        uint64_t v133 = v4;
        uint64_t v134 = 0;
        int v135 = (int *)a1[13];
        while (1)
        {
          int v136 = *v135;
          v135 += 12;
          if (!v136) {
            break;
          }
          uint64_t v134 = (void *)((char *)v134 + 1);
          if (v132 == v134) {
            goto LABEL_220;
          }
        }
      }
      else
      {
        uint64_t v133 = v4;
        uint64_t v134 = 0;
      }
      if (v134 != v132) {
        goto LABEL_228;
      }
LABEL_220:
      if (!v121)
      {
        uint64_t v134 = 0;
        if (v132)
        {
          uint64_t v137 = a1[13] + 4;
          while (1)
          {
            uint64_t v138 = *v137;
            v137 += 6;
            if (!v138) {
              break;
            }
            uint64_t v134 = (void *)((char *)v134 + 1);
            if (v132 == v134) {
              goto LABEL_243;
            }
          }
        }
        if (v134 == v132)
        {
LABEL_243:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", 451, 143, 0, "no available chunk", v83, v84, v170);
          int v149 = 1;
          goto LABEL_244;
        }
        uint64_t v139 = (uint64_t)&a1[13][6 * (void)v134];
        uint64_t v140 = *(void *)(v139 + 8);
        v131[v140] = -1;
        *(_DWORD *)uint64_t v139 = 0;
        *(void *)(v139 + 16) = 0;
        *(void *)(v139 + 24) = 0;
        *(void *)(v139 + 8) = -1;
        fprintf((FILE *)*MEMORY[0x263EF8348], "BYE chunk %8zu evicted\n", v140);
        uint64_t v131 = a1[15];
LABEL_228:
        uint64_t v141 = (uint64_t)&a1[13][6 * (void)v134];
        *(void *)(v141 + 8) = v124;
        v131[v124] = v134;
        *(_DWORD *)uint64_t v141 = 1;
        *(void *)(v141 + 32) = v121 == 0;
        uint64_t v142 = a1[1];
        unint64_t v143 = (void)v142 * *(void *)(v141 + 8);
        *(void *)(v141 + 16) = v143;
        long long v144 = (unint64_t *)(v141 + 16);
        __int16 v145 = (char *)v142 + v143;
        *(void *)(v141 + 24) = (char *)v142 + v143;
        int v146 = (char **)(v141 + 24);
        if (!v142) {
          goto LABEL_235;
        }
        uint64_t v148 = (char *)a1[17];
        uint64_t v147 = (char *)a1[18];
        if (v148 == v147) {
          goto LABEL_235;
        }
        if ((unint64_t)v148 > v143) {
          unint64_t v143 = (unint64_t)a1[17];
        }
        *long long v144 = v143;
        if (v145 >= v147) {
          __int16 v145 = v147;
        }
        *int v146 = v145;
        if (v143 >= (unint64_t)v145)
        {
LABEL_235:
          *long long v144 = 0;
          v144[1] = 0;
        }
        uint64_t v4 = v133;
        if (*((_DWORD *)a1 + 6) >= 3u) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "SET range %10llx %10llx -- %8zu\n", *v171, *v125, v124);
        }
        int v85 = 1;
LABEL_239:
        if (++v124 == v127)
        {
          uint64_t v120 = a1[20];
          goto LABEL_241;
        }
        continue;
      }
      break;
    }
    int v149 = 0;
LABEL_244:
    LODWORD(v4) = v133;
    int v8 = v177;
LABEL_250:
    if (pthread_mutex_unlock(v3))
    {
      unsigned int v163 = "unlock";
      __int16 v164 = 478;
      goto LABEL_277;
    }
    if (v149) {
      goto LABEL_278;
    }
LABEL_252:
    if (!(v8 | v4 | v85)) {
      usleep(0x9C40u);
    }
    if (atomic_load((unsigned int *)a1 + 51)) {
      return a1;
    }
  }
  unsigned int v163 = "lock";
  __int16 v164 = 359;
LABEL_277:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"stateUpdateChunks", v164, 143, 0, v163, v5, v6, v170);
LABEL_278:
  uint64_t v159 = "updating chunks";
  __int16 v160 = 501;
LABEL_279:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkAsyncStream.c", (uint64_t)"streamProc", v160, 143, 0, v159, v5, v6, v170);
  int v165 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)a1 + 50, (unsigned int *)&v165, 1u);
  if (!v165) {
    AAAsyncByteStreamCancel(*a1);
  }
  return a1;
}

uint64_t rangeCmp(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  if (v3 == *a1 && v5 != v4) {
    return 1;
  }
  if (v3 >= v5) {
    int v7 = v5 < v3;
  }
  else {
    int v7 = -1;
  }
  if (v4 >= v2) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 1;
  }
  if ((v5 != v4 || v3 == v2) && v2 >= v4) {
    return v8;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void stateSortRanges(uint64_t a1)
{
  size_t v1 = *(void *)(a1 + 160);
  if (v1)
  {
    qsort(*(void **)(a1 + 168), v1, 0x10uLL, (int (__cdecl *)(const void *, const void *))rangeCmp);
    uint64_t v3 = *(void *)(a1 + 160);
    if (v3)
    {
      uint64_t v4 = v3 - 1;
      unint64_t v5 = (void *)(*(void *)(a1 + 168) + 16 * v3 - 8);
      do
      {
        if (*(v5 - 1) != *v5) {
          break;
        }
        v5 -= 2;
        *(void *)(a1 + 160) = v4--;
      }
      while (v4 != -1);
    }
  }
}

unint64_t AAAsyncByteStreamProcessAllRanges(void *a1, void *a2, int a3, size_t __count)
{
  if (!__count) {
    LODWORD(__count) = getDefaultNThreads();
  }
  unsigned int v47 = 0;
  unint64_t v46 = 0;
  uint64_t v6 = __count;
  int v7 = (void ***)calloc(__count, 8uLL);
  unsigned int v8 = v7;
  if (!v7)
  {
    unint64_t v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 79, 116, *v17, "malloc", v18, v19, v44);
    uint64_t v15 = 0;
    goto LABEL_15;
  }
  if (v6)
  {
    uint64_t v9 = v6;
    char v10 = v7;
    do
    {
      uint64_t v11 = (void **)malloc(0x48uLL);
      unint64_t v12 = v11;
      if (!v11)
      {
        BOOL v20 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 83, 116, *v20, "malloc", v21, v22, v44);
        uint64_t v15 = 0;
        goto LABEL_16;
      }
      memset_s(v11, 0x48uLL, 0, 0x48uLL);
      *unint64_t v12 = a2;
      v12[1] = a1;
      unsigned int v12[2] = &v47;
      v12[3] = &v46;
      *v10++ = v12;
      --v9;
    }
    while (v9);
  }
  uint64_t v15 = ThreadPoolCreate(v6, (uint64_t)v8, (uint64_t)workerProc_2);
  if (!v15)
  {
    uint64_t v23 = "ThreadPoolCreate";
    __int16 v24 = 93;
    goto LABEL_14;
  }
  if (atomic_load(&v47))
  {
LABEL_10:
    LODWORD(v12) = 1;
    goto LABEL_16;
  }
  LODWORD(v12) = 1;
  while (1)
  {
    uint64_t v44 = 0;
    unint64_t v45 = 0;
    int Range = AAAsyncByteStreamGetRange(a1, &v45, &v44);
    if (Range < 0)
    {
      uint64_t v23 = "AAAsyncByteStreamGetRange";
      __int16 v24 = 101;
      goto LABEL_14;
    }
    if (!Range)
    {
      usleep(0x4E20u);
      goto LABEL_38;
    }
    if (!v45) {
      goto LABEL_10;
    }
    uint64_t Worker = ThreadPoolGetWorker((uint64_t)v15, v32, v33, v34, v35, v36, v13, v14);
    if (!Worker) {
      break;
    }
    uint64_t v42 = v44;
    *(void *)(Worker + 32) = v45;
    *(void *)(Worker + 40) = v42;
    if ((ThreadPoolRunWorker((uint64_t)v15, Worker, v38, v39, v40, v41, v13, v14) & 0x80000000) != 0)
    {
      uint64_t v23 = "ThreadPoolRunWorker";
      __int16 v24 = 110;
      goto LABEL_14;
    }
LABEL_38:
    if (atomic_load(&v47)) {
      goto LABEL_16;
    }
  }
  uint64_t v23 = "ThreadPoolGetWorker";
  __int16 v24 = 107;
LABEL_14:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", v24, 116, 0, v23, v13, v14, v44);
LABEL_15:
  LODWORD(v12) = 0;
LABEL_16:
  if ((ThreadPoolDestroy((uint64_t)v15) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 115, 116, 0, "Threads reported errors", v25, v26, v44);
    LODWORD(v12) = 0;
  }
  if (v8)
  {
    if (v6)
    {
      unint64_t v27 = v8;
      do
      {
        unint64_t v28 = *v27;
        if (*v27)
        {
          free(v28[8]);
          free(v28);
        }
        ++v27;
        --v6;
      }
      while (v6);
    }
    free(v8);
  }
  if (atomic_load(&v47))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"AAAsyncByteStreamProcessAllRanges", 127, 116, 0, "Threads reported errors", v25, v26, v44);
    return -1;
  }
  if (v12) {
    return atomic_load(&v46);
  }
  else {
    return -1;
  }
}

uint64_t workerProc_2(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 48) < v2)
  {
    *(void *)(a1 + 48) = v2;
    if (v2 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_16:
      *(void *)(a1 + 64) = 0;
      unint64_t v12 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"workerProc", 36, 116, *v12, "malloc", v13, v14, v16);
      *(void *)(a1 + 48) = 0;
      goto LABEL_17;
    }
    uint64_t v3 = *(void **)(a1 + 64);
    uint64_t v4 = realloc(v3, v2);
    if (!v4)
    {
      free(v3);
      goto LABEL_16;
    }
    *(void *)(a1 + 64) = v4;
    size_t v2 = *(void *)(a1 + 32);
  }
  *(void *)(a1 + 56) = 0;
  unint64_t v5 = 0;
  if (v2)
  {
    while (1)
    {
      ssize_t v6 = AAByteStreamPRead(*(AAByteStream *)a1, (void *)(*(void *)(a1 + 64) + v5), v2 - v5, *(void *)(a1 + 40) + v5);
      if (v6 < 0) {
        break;
      }
      unint64_t v5 = *(void *)(a1 + 56);
      if (v6)
      {
        v5 += v6;
        *(void *)(a1 + 56) = v5;
        size_t v2 = *(void *)(a1 + 32);
        if (v5 < v2) {
          continue;
        }
      }
      goto LABEL_10;
    }
    char v10 = "istream read";
    __int16 v11 = 43;
  }
  else
  {
LABEL_10:
    if ((AAAsyncByteStreamProcess(*(uint64_t **)(a1 + 8), *(void *)(a1 + 64), v5, *(void *)(a1 + 40)) & 0x80000000) == 0)
    {
      uint64_t result = 0;
      atomic_fetch_add_explicit(*(atomic_ullong *volatile *)(a1 + 24), *(void *)(a1 + 56), memory_order_relaxed);
      return result;
    }
    char v10 = "stream process";
    __int16 v11 = 50;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAsyncByteStreamProcessAllRanges.c", (uint64_t)"workerProc", v11, 116, 0, v10, v7, v8, v16);
LABEL_17:
  int v15 = 0;
  *(void *)(a1 + 56) = 0;
  atomic_compare_exchange_strong(*(atomic_uint *volatile *)(a1 + 16), (unsigned int *)&v15, 1u);
  return 0xFFFFFFFFLL;
}

void *reallocToFit(void *a1, size_t __size)
{
  if (__size >= 0x1000)
  {
    uint64_t v4 = malloc(__size);
    if (v4)
    {
      unint64_t v5 = v4;
      memcpy(v4, a1, __size);
      free(a1);
      return v5;
    }
  }
  return a1;
}

uint64_t sha1ToString(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = (unsigned char *)(result + 1);
  do
  {
    unint64_t v4 = *(unsigned __int8 *)(a2 + v2);
    *(v3 - 1) = serializeHexString_digit[v4 >> 4];
    *uint64_t v3 = serializeHexString_digit[v4 & 0xF];
    v3 += 2;
    ++v2;
  }
  while (v2 != 20);
  *(unsigned char *)(result + 40) = 0;
  return result;
}

uint64_t serializeHexString(uint64_t result, unsigned int a2, unsigned __int8 *a3)
{
  if (a2)
  {
    uint64_t v3 = 0;
    do
    {
      unsigned int v4 = *a3++;
      *(unsigned char *)(result + v3) = serializeHexString_digit[(unint64_t)v4 >> 4];
      *(unsigned char *)(result + (v3 + 1)) = serializeHexString_digit[v4 & 0xF];
      v3 += 2;
    }
    while (2 * a2 != v3);
  }
  *(unsigned char *)(result + 2 * a2) = 0;
  return result;
}

uint64_t sha1cmp(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = bswap64(*(void *)a1);
  unint64_t v3 = bswap64(*(void *)a2);
  if (v2 == v3)
  {
    unint64_t v2 = bswap64(*(void *)(a1 + 8));
    unint64_t v3 = bswap64(*(void *)(a2 + 8));
    if (v2 == v3)
    {
      unint64_t v2 = bswap32(*(_DWORD *)(a1 + 16));
      unint64_t v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3) {
        return 0;
      }
    }
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

const char *makePath(const char *result, unint64_t a2)
{
  unint64_t v3 = result;
  memset(&v6, 0, sizeof(v6));
  if (a2)
  {
    unint64_t v4 = a2;
    do
    {
      if (v3[v4] == 47)
      {
        v3[v4] = 0;
        uint64_t result = (const char *)stat(v3, &v6);
        if (!result) {
          break;
        }
      }
      --v4;
    }
    while (v4);
  }
  else
  {
    unint64_t v4 = 0;
  }
  if (v4 < a2)
  {
    int v5 = 1;
    do
    {
      if (!v3[v4])
      {
        if (!v5) {
          uint64_t result = (const char *)mkdir(v3, 0x1EDu);
        }
        int v5 = 0;
        v3[v4] = 47;
      }
      ++v4;
    }
    while (a2 != v4);
  }
  return result;
}

uint64_t normalizePath(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  while (2)
  {
    uint64_t v3 = v1 - 1;
    while (1)
    {
      while (1)
      {
        uint64_t v4 = v2++;
        int v5 = *(unsigned __int8 *)(a1 + v4);
        if (v5 != 47) {
          break;
        }
        if (v1)
        {
          int v6 = *(unsigned __int8 *)(a1 + v3);
          if (v6 != 47) {
            goto LABEL_9;
          }
        }
      }
      if (!*(unsigned char *)(a1 + v4)) {
        goto LABEL_28;
      }
      if (v1)
      {
        int v6 = *(unsigned __int8 *)(a1 + v3);
LABEL_9:
        char v7 = 0;
        BOOL v8 = v6 == 47;
        goto LABEL_11;
      }
      char v7 = 1;
      BOOL v8 = 1;
LABEL_11:
      if (v5 != 46 || !v8) {
        goto LABEL_26;
      }
      int v10 = *(unsigned __int8 *)(a1 + v2);
      if (v10 != 47) {
        break;
      }
      uint64_t v2 = v4 + 2;
    }
    if (*(unsigned char *)(a1 + v2))
    {
      if (v10 != 46 || *(unsigned char *)(v4 + a1 + 2) != 47 && *(unsigned char *)(v4 + a1 + 2))
      {
LABEL_26:
        *(unsigned char *)(a1 + v1++) = v5;
        continue;
      }
      if ((v7 & 1) == 0)
      {
        do
        {
          uint64_t v11 = v1 - 1;
          if (v1 == 1) {
            break;
          }
          int v12 = *(unsigned __int8 *)(a1 - 2 + v1--);
        }
        while (v12 != 47);
        uint64_t v2 = v4 + 3;
        uint64_t v1 = v11;
        if (!*(unsigned char *)(v4 + a1 + 2))
        {
          uint64_t v1 = v11;
          goto LABEL_28;
        }
        continue;
      }
      return 0xFFFFFFFFLL;
    }
    else
    {
      do
      {
LABEL_28:
        uint64_t v14 = v1;
        if (!v1) {
          break;
        }
        --v1;
      }
      while (*(unsigned char *)(a1 + v14 - 1) == 47);
      uint64_t v13 = 0;
      *(unsigned char *)(a1 + v14) = 0;
    }
    return v13;
  }
}

uint64_t concatPath(char *a1, unint64_t a2, char *__s, const char *a4)
{
  size_t v8 = strlen(__s);
  size_t v9 = strlen(a4);
  if (v8 + v9 + 2 > a2) {
    return 0xFFFFFFFFLL;
  }
  size_t v11 = v9;
  if (a1 != __s) {
    memcpy(a1, __s, v8);
  }
  if (v11)
  {
    if (!v8 || a1[v8 - 1] != 47) {
      a1[v8++] = 47;
    }
    memcpy(&a1[v8], a4, v11);
    v8 += v11;
  }
  uint64_t result = 0;
  a1[v8] = 0;
  return result;
}

uint64_t getTempDir(char *a1, size_t a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = (const char *)confstr(65537, a1, a2);
  if (!v4)
  {
    if (issetugid())
    {
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v4 = getenv("TMPDIR");
      if (v4) {
        uint64_t v4 = (const char *)strlcpy(a1, v4, a2);
      }
    }
  }
  if ((unint64_t)v4 >= a2) {
    return 0xFFFFFFFFLL;
  }
  size_t v6 = strlen(a1);
  do
  {
    size_t v7 = v6;
    if (!v6) {
      break;
    }
    --v6;
  }
  while (a1[v7 - 1] == 47);
  a1[v7] = 0;
  if (v7) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t storeFileContents(const char *a1, uint64_t a2, unint64_t a3)
{
  char v5 = (char)a1;
  int v6 = open(a1, 1537, 420);
  if (v6 < 0)
  {
    uint64_t v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 535, 3, *v14, "%s", v15, v16, v5);
    int v13 = 0;
  }
  else
  {
    int v7 = v6;
    if (a3)
    {
      unint64_t v8 = 0;
      while (1)
      {
        if (a3 - v8 >= 0x10000000) {
          size_t v9 = 0x10000000;
        }
        else {
          size_t v9 = a3 - v8;
        }
        ssize_t v10 = write(v7, (const void *)(a2 + v8), v9);
        if (v10 < 0)
        {
          int v17 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 544, 3, v17, "%s", v18, v19, v5);
          goto LABEL_14;
        }
        if (!v10) {
          break;
        }
        v8 += v10;
        if (v8 >= a3) {
          goto LABEL_10;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 545, 3, 0, "write error: %s", v11, v12, v5);
LABEL_14:
      int v13 = 0;
    }
    else
    {
LABEL_10:
      int v13 = 1;
    }
    close(v7);
  }
  if (v13) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t copyFileSegment(const char *a1, unint64_t a2, unint64_t a3, const char *a4)
{
  ssize_t v10 = (unint64_t *)MemBufferCreate(0x100000uLL);
  if (v10)
  {
    int v13 = (char *)IFileStreamCreateWithFilename(a1, a2, a3);
    if (v13)
    {
      uint64_t v16 = OFileStreamCreateWithFilename(a4, a3);
      if (v16)
      {
        if ((MemBufferTransmit(v10, a3, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OFileStreamWrite, (uint64_t)v16, v14, v15) & 0x8000000000000000) == 0)
        {
          int v19 = 0;
          goto LABEL_11;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 569, 3, 0, "copy failed: %s to %s", v17, v18, (char)a1);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 566, 3, 0, "opening file: %s", v14, v15, (char)a4);
      }
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 565, 3, 0, "opening file: %s", v11, v12, (char)a1);
      uint64_t v16 = 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 564, 3, 0, "mem buffer creation", v8, v9, v21);
    uint64_t v16 = 0;
    int v13 = 0;
  }
  int v19 = 1;
LABEL_11:
  IFileStreamDestroy(v13);
  OFileStreamDestroy(v16);
  MemBufferDestroy((void **)v10);
  if (v19) {
    unlink(a4);
  }
  return (v19 << 31 >> 31);
}

uint64_t updateFileAttributes(const char *a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v24.tv_seCC_SHA1_CTX c = *(void *)(a2 + 32);
  v24.tv_useCC_SHA1_CTX c = 0;
  uint64_t v25 = *(void *)(a2 + 48);
  int v26 = 0;
  memset(&v23, 0, sizeof(v23));
  if (stat(a1, &v23))
  {
    if (*__error() == 1) {
      return 0;
    }
    __int16 v7 = 604;
LABEL_24:
    int v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", v7, 3, *v19, "%s", v20, v21, (char)a1);
    return 0xFFFFFFFFLL;
  }
  uid_t v5 = *(_DWORD *)(a2 + 16);
  if (v23.st_uid == v5)
  {
    gid_t v6 = *(_DWORD *)(a2 + 20);
    if (v23.st_gid == v6) {
      goto LABEL_11;
    }
  }
  else
  {
    gid_t v6 = *(_DWORD *)(a2 + 20);
  }
  if (chown(a1, v5, v6) && *__error() != 1)
  {
    uint64_t v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", 610, 3, *v8, "%s", v9, v10, (char)a1);
    uint64_t v4 = 0xFFFFFFFFLL;
    goto LABEL_13;
  }
LABEL_11:
  uint64_t v4 = 0;
LABEL_13:
  int v11 = *(unsigned __int16 *)(a2 + 4);
  if (v23.st_mode != v11 && chmod(a1, v11 & 0xFFF) && *__error() != 1)
  {
    uint64_t v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", 614, 3, *v12, "%s", v13, v14, (char)a1);
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  __uint32_t v15 = *(_DWORD *)(a2 + 116) & 0xFFFFFFDF | (32 * ((v23.st_flags >> 5) & 1));
  if (v23.st_flags != v15 && chflags(a1, v15) && *__error() != 1)
  {
    uint64_t v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"updateFileAttributes", 621, 3, *v16, "%s", v17, v18, (char)a1);
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if (utimes(a1, &v24) && *__error() != 1)
  {
    __int16 v7 = 624;
    goto LABEL_24;
  }
  return v4;
}

uint64_t copyFileWithAttributes(const char *a1, const char *a2, int a3, uint64_t a4, int a5)
{
  memset(&v54, 0, sizeof(v54));
  int v9 = open(a1, 0);
  if (v9 < 0)
  {
    uint64_t v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 645, 3, *v16, "%s", v17, v18, (char)a1);
LABEL_18:
    timeval v24 = 0;
LABEL_19:
    unint64_t v28 = 0;
LABEL_20:
    uint64_t v32 = 0;
LABEL_21:
    IFileStreamDestroy(v24);
    OArchiveFileStreamDestroy((unsigned int *)v28, v44, v45, v46, v47, v48, v49, v50);
    MemBufferDestroy(v32);
    unlink(a2);
    return 0xFFFFFFFFLL;
  }
  int v10 = v9;
  if (fstat(v9, &v54))
  {
    int v13 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 646, 3, v13, "%s", v14, v15, (char)a1);
LABEL_17:
    close(v10);
    goto LABEL_18;
  }
  if ((v54.st_mode & 0xF000) != 0x8000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 647, 3, 0, "not a regular file: %s", v11, v12, (char)a1);
    goto LABEL_17;
  }
  int FileProtectionClassFD = getFileProtectionClassFD(v10);
  close(v10);
  st_size_t size = v54.st_size;
  __uint32_t st_flags = v54.st_flags;
  timeval v24 = (char *)IFileStreamCreateWithFilename(a1, 0, v54.st_size);
  if (!v24)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 666, 3, 0, "open failed: %s", v22, v23, (char)a1);
    goto LABEL_19;
  }
  if ((st_flags & 0x40000020) == 0x20) {
    int v25 = a5 | 4;
  }
  else {
    int v25 = a5;
  }
  unint64_t v28 = OArchiveFileStreamCreate(a2, st_size, v25 | 8u, FileProtectionClassFD, a3);
  if (!v28)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 667, 3, 0, "open failed: %s", v26, v27, (char)a1);
    goto LABEL_20;
  }
  uint64_t v29 = (unint64_t *)MemBufferCreate(0x100000uLL);
  uint64_t v32 = (void **)v29;
  if (!v29)
  {
    unint64_t v51 = "alloc";
    __int16 v52 = 670;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", v52, 3, 0, v51, v30, v31, v53);
    goto LABEL_21;
  }
  uint64_t v33 = MemBufferTransmit(v29, st_size, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v24, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OArchiveFileStreamWrite, (uint64_t)v28, v30, v31);
  if (v33 < 0 || v33 != st_size)
  {
    char v53 = v33;
    unint64_t v51 = "copy failed %lld";
    __int16 v52 = 674;
    goto LABEL_28;
  }
  IFileStreamDestroy(v24);
  OArchiveFileStreamDestroy((unsigned int *)v28, v34, v35, v36, v37, v38, v39, v40);
  MemBufferDestroy(v32);
  uint64_t result = updateFileAttributes(a2, (uint64_t)&v54);
  if (!result) {
    return result;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileWithAttributes", 690, 3, 0, "update file attributes", v42, v43, v53);
  return 0xFFFFFFFFLL;
}

uint64_t getFileProtectionClassFD(int a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v4[1] = 0;
  v4[2] = 0;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005;
  int v1 = fgetattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0) {
    return DWORD1(v5[0]);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t getFileAPFSInternalFlagsFD()
{
  return 0;
}

uint64_t statIsCompressed(unsigned int a1)
{
  if ((a1 & 0x40000000) != 0) {
    return 0;
  }
  else {
    return (a1 >> 5) & 1;
  }
}

uint64_t setFileAPFSInternalFlags(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t areFilesEqual(const char *a1, const char *a2)
{
  memset(&v39, 0, sizeof(v39));
  memset(&v38, 0, sizeof(v38));
  if (stat(a1, &v39))
  {
    int v4 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 708, 3, v4, "%s", v5, v6, (char)a1);
LABEL_5:
    int v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_6;
  }
  if (stat(a2, &v38))
  {
    int v7 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 709, 3, v7, "%s", v8, v9, (char)a2);
    goto LABEL_5;
  }
  if ((v39.st_mode & 0xF000) != 0x8000 || (v38.st_mode & 0xF000) != 0x8000 || v39.st_size != v38.st_size)
  {
    int v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    goto LABEL_6;
  }
  int v14 = open(a1, 0);
  if (v14 < 0)
  {
    int v22 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 714, 3, v22, "%s", v23, v24, (char)a1);
    goto LABEL_5;
  }
  int v15 = v14;
  int v16 = open(a2, 0);
  if (v16 < 0)
  {
    int v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 716, 3, *v25, "%s", v26, v27, (char)a2);
    close(v15);
    goto LABEL_5;
  }
  int v17 = v16;
  uint64_t v11 = malloc(0x40000uLL);
  uint64_t v18 = malloc(0x40000uLL);
  int v10 = v18;
  if (!v11 || !v18)
  {
    unint64_t v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 719, 3, *v28, "malloc", v29, v30, v37);
    close(v15);
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_29;
  }
  while (1)
  {
    ssize_t v19 = read(v15, v11, 0x40000uLL);
    if (v19 < 0)
    {
      int v31 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 723, 3, v31, "%s read", v32, v33, (char)a1);
LABEL_26:
      uint64_t v12 = 0xFFFFFFFFLL;
      goto LABEL_28;
    }
    size_t v20 = v19;
    ssize_t v21 = read(v17, v10, 0x40000uLL);
    if (v21 < 0)
    {
      int v34 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 725, 3, v34, "%s read", v35, v36, (char)a2);
      goto LABEL_26;
    }
    if (v20 != v21) {
      goto LABEL_19;
    }
    if (!v20) {
      break;
    }
    if (memcmp(v11, v10, v20))
    {
LABEL_19:
      uint64_t v12 = 0;
      goto LABEL_28;
    }
  }
  uint64_t v12 = 1;
LABEL_28:
  close(v15);
  if ((v17 & 0x80000000) == 0) {
LABEL_29:
  }
    close(v17);
LABEL_6:
  free(v11);
  free(v10);
  return v12;
}

uint64_t areFilesEqual2()
{
  uint64_t v0 = (char *)MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (concatPath(v7, 0x800uLL, v0, v4) || concatPath(v6, 0x800uLL, v3, v2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return areFilesEqual(v7, v6);
  }
}

uint64_t getFilesystemBlockSize(const char *a1)
{
  char v1 = (char)a1;
  uint64_t v7 = *MEMORY[0x263EF8340];
  memset(&v6, 0, 512);
  if ((statfs(a1, &v6) & 0x80000000) == 0) {
    return v6.f_bsize;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFilesystemBlockSize", 752, 3, "statfs failed: %s\n", v2, v3, v4, v1);
  return 4096;
}

uint64_t getFileDiskUsage(const char *a1)
{
  memset(&v12, 0, sizeof(v12));
  if (lstat(a1, &v12))
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDiskUsage", 765, 3, "stat failed: %s\n", v2, v3, v4, (char)a1);
    return -1;
  }
  else
  {
    if (v12.st_blocks << 9 >= (unint64_t)v12.st_size || v12.st_blocks << 9 == 0) {
      st_size_t size = v12.st_size;
    }
    else {
      st_size_t size = v12.st_blocks << 9;
    }
    if ((v12.st_mode & 0xF000) == 0x8000)
    {
      uint64_t v10 = 0;
      off_t v11 = 0;
      int v7 = ParallelCompressionAFSCGetMetadata(a1, &v11, (unsigned int *)&v10 + 1, &v10);
      if (HIDWORD(v10) != -1 && v7 == 0) {
        return v10;
      }
    }
  }
  return st_size;
}

uint64_t getFileProtectionClass(const char *a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v4[1] = 0;
  v4[2] = 0;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005;
  int v1 = getattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0) {
    return DWORD1(v5[0]);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t getBufferSHA1Digest(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  memset(&v11, 0, sizeof(v11));
  CC_SHA1_Init(&v11);
  if (a2)
  {
    unint64_t v6 = 0;
    CC_LONG v7 = a2;
    do
    {
      unint64_t v8 = v6 + 0x100000;
      if (v6 + 0x100000 <= a2) {
        CC_LONG v9 = 0x100000;
      }
      else {
        CC_LONG v9 = v7;
      }
      CC_SHA1_Update(&v11, (const void *)(a1 + v6), v9);
      v7 -= 0x100000;
      unint64_t v6 = v8;
    }
    while (v8 < a2);
  }
  CC_SHA1_Final(a3, &v11);
  return 0;
}

uint64_t getFileSHA1Digest(const char *a1, uint64_t a2)
{
  return getFileSegmentSHA1Digest(a1, 0, 0xFFFFFFFFFFFFFFFFLL, a2);
}

uint64_t getFileSegmentSHA1Digest(const char *a1, off_t a2, unint64_t a3, uint64_t a4)
{
  char v7 = (char)a1;
  int v8 = open(a1, 0);
  if (v8 < 0)
  {
    stat v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1Digest", 1025, 3, *v12, "%s", v13, v14, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v9 = v8;
    uint64_t FileSegmentSHA1DigestFD = getFileSegmentSHA1DigestFD(v8, a2, a3, a4);
    close(v9);
    return FileSegmentSHA1DigestFD;
  }
}

uint64_t getFileSegmentSHA1DigestFD(int a1, off_t a2, unint64_t a3, uint64_t a4)
{
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 16) = 0;
  char v24 = 1;
  if (fcntl(a1, 48)) {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1044, 3, "Warning: couldn't set F_NOCACHE\n", v8, v9, v10, 1);
  }
  memset(&c, 0, sizeof(c));
  CC_SHA1_CTX v11 = valloc(0x100000uLL);
  if (!v11)
  {
    int v18 = *__error();
    ssize_t v21 = "malloc";
    __int16 v22 = 1049;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", v22, 3, v18, v21, v19, v20, v24);
LABEL_16:
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  CC_SHA1_Init(&c);
  if (a3)
  {
    while (1)
    {
      if (a3 >= 0x100000) {
        size_t v12 = 0x100000;
      }
      else {
        size_t v12 = a3;
      }
      unint64_t v13 = pread(a1, v11, v12, a2);
      if ((v13 & 0x8000000000000000) != 0)
      {
        int v18 = *__error();
        ssize_t v21 = "read";
        __int16 v22 = 1059;
        goto LABEL_15;
      }
      unint64_t v16 = v13;
      if (!v13) {
        goto LABEL_12;
      }
      if (v13 > v12) {
        break;
      }
      CC_SHA1_Update(&c, v11, v13);
      a2 += v16;
      a3 -= v16;
      if (!a3) {
        goto LABEL_12;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1062, 3, 0, "error: read more bytes than requested: %zd (requested %zu)", v14, v15, v13);
    goto LABEL_16;
  }
LABEL_12:
  CC_SHA1_Final((unsigned __int8 *)a4, &c);
  uint64_t v17 = 0;
LABEL_17:
  free(v11);
  return v17;
}

uint64_t enumerateTree(void *a1, char *__s)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  size_t v3 = strlen(__s);
  if (v3 - 1024 < 0xFFFFFFFFFFFFFBFFLL) {
    return 0xFFFFFFFFLL;
  }
  size_t v5 = v3;
  bzero(v7, 0x400uLL);
  __memcpy_chk();
  do
  {
    uint64_t v6 = v5;
    if (!v5) {
      break;
    }
    --v5;
  }
  while (v7[v6 - 1] == 47);
  v7[v6] = 0;
  return enumerateTree_rec(a1, v7, v6);
}

uint64_t removeFile(const char *a1)
{
  memset(&v3, 0, sizeof(v3));
  if (lstat(a1, &v3)) {
    return 0;
  }
  if ((v3.st_mode & 0xF000) == 0x4000) {
    return 0xFFFFFFFFLL;
  }
  if ((v3.st_flags & 0x20002) != 0) {
    lchflags(a1, v3.st_flags & 0xFFFDFFFD);
  }
  return unlink(a1);
}

uint64_t enumerateTree_rec(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (a3) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = "/";
  }
  char v7 = opendir(v6);
  if (v7)
  {
    memset(&v33, 0, 512);
    uint64_t v32 = 0;
    uint64_t v8 = (uint64_t (*)(void, const char *))a1[1];
    if (v8 && (v8(*a1, a2) & 0x80000000) != 0)
    {
LABEL_35:
      int v28 = 0;
    }
    else
    {
      uint64_t v9 = a3 + 1;
      uint64_t v10 = (char *)&a2[a3];
      CC_SHA1_CTX v11 = (char *)&a2[a3 + 1];
      while (1)
      {
        if (readdir_r(v7, &v33, &v32))
        {
          int v25 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1143, 3, *v25, "readdir_r", v26, v27, v30);
          goto LABEL_35;
        }
        if (!v32) {
          break;
        }
        size_t d_namlen = v33.d_namlen;
        if ((v33.d_namlen != 1 || v33.d_name[0] != 46)
          && (v33.d_namlen != 2 || v33.d_name[0] != 46 || v33.d_name[1] != 46))
        {
          unint64_t v13 = v9 + v33.d_namlen;
          if (v13 > 0x3FF) {
            goto LABEL_35;
          }
          *uint64_t v10 = 47;
          memcpy(v11, v33.d_name, d_namlen);
          a2[v13] = 0;
          memset(&v31, 0, sizeof(v31));
          int v14 = lstat(a2, &v31);
          if (v14)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1170, 3, "lstat after readdir failed (errno=%d): %s", v15, v16, v17, v14);
          }
          else if ((v31.st_flags & 0x40000000) != 0)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1175, 3, "skip dataless: %s", v15, v16, v17, (char)a2);
          }
          else
          {
            int d_type = v33.d_type;
            if (!v33.d_type)
            {
              if ((v31.st_mode & 0xF000) == 0x4000)
              {
                int d_type = 4;
                v33.int d_type = 4;
              }
              else
              {
                int d_type = 0;
              }
            }
            uint64_t v19 = (int (*)(void, const char *))a1[3];
            if (v19)
            {
              BOOL v20 = v19(*a1, a2) >= 0;
              int d_type = v33.d_type;
            }
            else
            {
              BOOL v20 = 1;
            }
            if (d_type == 4 && (int)enumerateTree_rec(a1, a2, v13) < 0) {
              BOOL v20 = 0;
            }
            *uint64_t v10 = 0;
            if (!v20) {
              goto LABEL_35;
            }
          }
        }
      }
      int v28 = 1;
    }
    closedir(v7);
    uint64_t v29 = (int (*)(void, const char *))a1[2];
    if (v29 && v29(*a1, a2) < 0) {
      int v28 = 0;
    }
    if (v28) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssize_t v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1126, 3, *v21, "%s", v22, v23, (char)a2);
    return 0xFFFFFFFFLL;
  }
}

uint64_t removeTree(char *__s)
{
  v2[0] = 0;
  v2[1] = 0;
  v2[3] = removeEntryProc;
  v2[2] = removeLeaveDirProc;
  return enumerateTree(v2, __s);
}

uint64_t removeEntryProc(int a1, char *a2)
{
  memset(&v8, 0, sizeof(v8));
  if (lstat(a2, &v8))
  {
    __int16 v3 = 1247;
LABEL_3:
    uint64_t v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeEntryProc", v3, 3, *v4, "%s", v5, v6, (char)a2);
    return 0xFFFFFFFFLL;
  }
  if ((v8.st_mode & 0xF000) == 0x4000) {
    return 0;
  }
  uint64_t result = unlink(a2);
  if (result)
  {
    __int16 v3 = 1250;
    goto LABEL_3;
  }
  return result;
}

uint64_t removeLeaveDirProc(int a1, char *a2)
{
  char v2 = (char)a2;
  uint64_t result = rmdir(a2);
  if (result)
  {
    uint64_t v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeLeaveDirProc", 1258, 3, *v4, "%s", v5, v6, v2);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t statIsDataless(unsigned int a1)
{
  return (a1 >> 30) & 1;
}

uint64_t aaAssetExtractStreamSetParameterPtr(uint64_t *a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((uint64_t (*)(uint64_t))a1[1] == closeProc_1)
  {
    char v9 = (char)a3;
    uint64_t v10 = *a1;
    memset(&v18, 0, sizeof(v18));
    switch(a2)
    {
      case 'e':
        uint64_t result = 0;
        *(void *)(v10 + 1040) = a3;
        return result;
      case 'j':
        int v14 = (const char *)(v10 + 3516);
        if (!realpath_DARWIN_EXTSN(a3, (char *)(v10 + 3516)) || stat(v14, &v18) < 0 || (v18.st_mode & 0xF000) != 0x4000)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterPtr", 820, 133, 0, "invalid output dir: %s", v15, v16, v9);
          return 0xFFFFFFFFLL;
        }
        break;
      case 'i':
        CC_SHA1_CTX v11 = (const char *)(v10 + 2492);
        if (a3)
        {
          if (!realpath_DARWIN_EXTSN(a3, (char *)(v10 + 2492))
            || stat(v11, &v18) < 0
            || (v18.st_mode & 0xF000) != 0x4000)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterPtr", 816, 133, 0, "invalid input dir: %s", v12, v13, v9);
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          memset_s((void *)(v10 + 2492), 0x400uLL, 0, 0x400uLL);
        }
        break;
      default:
        return 0xFFFFFFFFLL;
    }
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterPtr", 808, 133, 0, "invalid stream", a7, a8, v17);
  return 0xFFFFFFFFLL;
}

uint64_t closeProc_1(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 8));
    AAHeaderDestroy(*(AAHeader *)(result + 4768));
    free(*(void **)(v1 + 4800));
    memset_s((void *)(v1 + 4784), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4824));
    memset_s((void *)(v1 + 4808), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4848));
    memset_s((void *)(v1 + 4832), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v1 + 4888));
    memset_s((void *)(v1 + 4872), 0x18uLL, 0, 0x18uLL);
    AAByteStreamClose(*(AAByteStream *)(v1 + 4864));
    AAByteStreamClose(*(AAByteStream *)(v1 + 4856));
    free((void *)v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t aaAssetExtractStreamSetParameterCallback(uint64_t (**a1)(uint64_t result), int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    char v9 = "NULL stream";
    __int16 v10 = 834;
    goto LABEL_5;
  }
  if (a1[1] != closeProc_1)
  {
    char v9 = "invalid stream";
    __int16 v10 = 835;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamSetParameterCallback", v10, 133, 0, v9, a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
  if (a2 == 104)
  {
    uint64_t result = 0;
    *((void *)*a1 + 131) = a3;
    return result;
  }
  return 0xFFFFFFFFLL;
}

uint64_t *aaAssetExtractStreamOpen(const char *a1, uint64_t a2)
{
  memset(&v22, 0, sizeof(v22));
  uint64_t v4 = malloc(0x1320uLL);
  uint64_t v5 = (uint64_t)v4;
  if (!v4)
  {
    __int16 v10 = 855;
LABEL_9:
    CC_SHA1_CTX v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"openProc", v10, 133, *v11, "malloc", v12, v13, v20);
    closeProc_1(v5);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpen", 885, 133, 0, "create extract stream", v14, v15, v21);
    closeProc_1(0);
    return 0;
  }
  memset_s(v4, 0x1320uLL, 0, 0x1320uLL);
  uint64_t v6 = (uint64_t *)malloc(0x38uLL);
  if (!v6)
  {
    __int16 v10 = 859;
    goto LABEL_9;
  }
  char v7 = v6;
  memset_s(v6, 0x38uLL, 0, 0x38uLL);
  uint64_t *v7 = v5;
  v7[1] = (uint64_t)closeProc_1;
  v7[6] = (uint64_t)closeWithStateProc_1;
  v7[4] = (uint64_t)writeHeaderProc;
  v7[5] = (uint64_t)writeBlobProc;
  v7[2] = (uint64_t)cancelProc_1;
  *(void *)uint64_t v5 = a2;
  *(void *)(v5 + 4752) = 0x100000;
  if (!realpath_DARWIN_EXTSN(a1, (char *)(v5 + 12)))
  {
    int v16 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpen", 893, 133, v16, a1, v17, v18, v20);
    goto LABEL_12;
  }
  if (stat((const char *)(v5 + 12), &v22) || (v22.st_mode & 0xF000) != 0x4000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpen", 894, 133, 0, "Not a directory: %s", v8, v9, (char)a1);
LABEL_12:
    if (*v7) {
      ((void (*)(void))v7[1])();
    }
    free(v7);
    return 0;
  }
  __strlcpy_chk();
  return v7;
}

uint64_t *aaAssetExtractStreamOpenWithState(const char *a1, AAByteStream_impl *a2, void *a3)
{
  uint64_t v125 = *MEMORY[0x263EF8340];
  data_size_t size = 0;
  size_t v122 = 0;
  data = 0;
  int v120 = 0;
  long long v118 = 0u;
  long long v119 = 0u;
  uint32x4_t v116 = 0u;
  long long v117 = 0u;
  long long v115 = 0u;
  unint64_t __s = 0;
  size_t v113 = 0;
  __ptr = 0;
  StreamOpen = aaAssetExtractStreamOpen(a1, 0);
  uint64_t v8 = StreamOpen;
  if (!StreamOpen)
  {
    uint64_t v14 = "create extract stream";
    __int16 v15 = 927;
    goto LABEL_225;
  }
  uint64_t v9 = *StreamOpen;
  if (*((void *)a2 + 2))
  {
    uint64_t v10 = 0;
    CC_SHA1_CTX v11 = &v115;
    uint64_t v12 = 84;
    while (1)
    {
      uint64_t v13 = (*((uint64_t (**)(void, long long *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
      if (v13 < 0) {
        break;
      }
      if (v13)
      {
        CC_SHA1_CTX v11 = (long long *)((char *)v11 + v13);
        v10 += v13;
        v12 -= v13;
        if (v12) {
          continue;
        }
      }
      goto LABEL_11;
    }
    uint64_t v10 = v13;
LABEL_11:
    uint32x4_t v16 = v116;
  }
  else
  {
    uint64_t v10 = -1;
    uint32x4_t v16 = 0uLL;
  }
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32(v16, (uint32x4_t)xmmword_214B13020))) & 1) != 0 || v10 < 0)
  {
    uint64_t v14 = "invalid state";
    __int16 v15 = 935;
    goto LABEL_225;
  }
  *(void *)uint64_t v9 = v115;
  uint64_t v17 = v117;
  *(void *)(v9 + 4752) = *((void *)&v115 + 1);
  *(void *)(v9 + 4776) = v17;
  *(_DWORD *)(v9 + 4740) = BYTE2(v120);
  *(_DWORD *)(v9 + 4744) = HIBYTE(v120);
  *(void *)(v9 + 4760) = *((void *)&v117 + 1);
  if (!*((void *)a2 + 2)) {
    goto LABEL_224;
  }
  uint64_t v18 = v16.u32[0];
  if (v16.i32[0])
  {
    uint64_t v19 = 0;
    uint64_t v20 = v9 + 2492;
    do
    {
      uint64_t v21 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v20, v18);
      if (v21 < 0) {
        goto LABEL_224;
      }
      if (!v21) {
        break;
      }
      v20 += v21;
      v19 += v21;
      v18 -= v21;
    }
    while (v18);
    if (v19 < 0 || !*((void *)a2 + 2)) {
      goto LABEL_224;
    }
  }
  uint64_t v22 = v116.u32[1];
  if (v116.i32[1])
  {
    uint64_t v23 = 0;
    uint64_t v24 = v9 + 3516;
    do
    {
      uint64_t v25 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v24, v22);
      if (v25 < 0) {
        goto LABEL_224;
      }
      if (!v25) {
        break;
      }
      v24 += v25;
      v23 += v25;
      v22 -= v25;
    }
    while (v22);
    if (v23 < 0) {
      goto LABEL_224;
    }
  }
  if (!*((void *)a2 + 2)) {
    goto LABEL_224;
  }
  uint64_t v26 = v116.u32[2];
  if (v116.i32[2])
  {
    uint64_t v27 = 0;
    uint64_t v28 = v9 + 4540;
    do
    {
      uint64_t v29 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v28, v26);
      if (v29 < 0) {
        goto LABEL_224;
      }
      if (!v29) {
        break;
      }
      v28 += v29;
      v27 += v29;
      v26 -= v29;
    }
    while (v26);
    if (v27 < 0) {
      goto LABEL_224;
    }
  }
  size_t v30 = v116.u32[3];
  if (v116.i32[3])
  {
    stat v31 = 0;
    unint64_t v32 = 0;
    size_t v33 = 0;
    uint64_t v34 = 0;
    do
    {
      if (v33 != v32) {
        goto LABEL_47;
      }
      unint64_t v35 = v32 + 0x40000;
      if ((uint64_t)(v32 + 0x40000) < 0) {
        goto LABEL_224;
      }
      if (v32 <= 0xFFFFFFFFFFFBFFFFLL)
      {
        do
        {
          while (!v32)
          {
            unint64_t v32 = 0x4000;
            size_t v37 = 0x4000;
            if (v35 <= 0x4000) {
              goto LABEL_49;
            }
          }
          unint64_t v36 = v32 >> 1;
          if ((v32 & (v32 >> 1)) != 0) {
            unint64_t v36 = v32 & (v32 >> 1);
          }
          v32 += v36;
        }
        while (v32 < v35);
        size_t v37 = v32;
        if (v32 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_187;
        }
LABEL_49:
        stat v38 = (uint8_t *)realloc(v31, v37);
        if (!v38)
        {
          free(v31);
LABEL_187:
          p_data_size_t size = &data_size;
          goto LABEL_223;
        }
        size_t v122 = v37;
        data = v38;
        stat v31 = v38;
      }
      else
      {
LABEL_47:
        size_t v37 = v32;
      }
      if (v37 - v33 >= v30) {
        size_t v39 = v30;
      }
      else {
        size_t v39 = v37 - v33;
      }
      ssize_t v40 = AAByteStreamRead(a2, &v31[v33], v39);
      if (v40 < 0) {
        goto LABEL_224;
      }
      if (!v40) {
        break;
      }
      size_t v33 = data_size + v40;
      if (__CFADD__(data_size, v40)) {
        goto LABEL_224;
      }
      unint64_t v32 = v122;
      if (v33 > v122) {
        goto LABEL_224;
      }
      data_size += v40;
      v34 += v40;
      v30 -= v40;
    }
    while (v30);
    if (v34 < 0) {
      goto LABEL_224;
    }
  }
  size_t v41 = *((void *)&v118 + 1);
  if (!*((void *)&v118 + 1)) {
    goto LABEL_86;
  }
  uint64_t v42 = 0;
  p_data_size_t size = (size_t *)(v9 + 4784);
  unint64_t v44 = *(void *)(v9 + 4784);
  unint64_t v45 = *(void *)(v9 + 4792);
  do
  {
    if (v44 != v45) {
      goto LABEL_73;
    }
    unint64_t v46 = v45 + 0x40000;
    if ((uint64_t)(v45 + 0x40000) < 0) {
      goto LABEL_224;
    }
    if (v45 > 0xFFFFFFFFFFFBFFFFLL)
    {
      unint64_t v44 = v45;
LABEL_73:
      size_t v48 = v45;
      goto LABEL_77;
    }
    do
    {
      while (!v45)
      {
        unint64_t v45 = 0x4000;
        size_t v48 = 0x4000;
        if (v46 <= 0x4000) {
          goto LABEL_75;
        }
      }
      unint64_t v47 = v45 >> 1;
      if ((v45 & (v45 >> 1)) != 0) {
        unint64_t v47 = v45 & (v45 >> 1);
      }
      v45 += v47;
    }
    while (v45 < v46);
    size_t v48 = v45;
    if (v45 >= 0x2000000001)
    {
LABEL_222:
      *__error() = 12;
      goto LABEL_223;
    }
LABEL_75:
    uint64_t v49 = *(void **)(v9 + 4800);
    uint64_t v50 = realloc(v49, v48);
    if (!v50)
    {
LABEL_185:
      free(v49);
LABEL_223:
      *p_data_size_t size = 0;
      p_data_size[1] = 0;
      p_data_uint64_t size[2] = 0;
      goto LABEL_224;
    }
    *(void *)(v9 + 4800) = v50;
    *(void *)(v9 + 4792) = v48;
    unint64_t v44 = *(void *)(v9 + 4784);
LABEL_77:
    if (v48 - v44 >= v41) {
      size_t v51 = v41;
    }
    else {
      size_t v51 = v48 - v44;
    }
    ssize_t v52 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4800) + v44), v51);
    if (v52 < 0) {
      goto LABEL_224;
    }
    if (!v52) {
      break;
    }
    unint64_t v44 = *p_data_size + v52;
    if (!__CFADD__(*p_data_size, v52))
    {
      unint64_t v45 = *(void *)(v9 + 4792);
      if (v44 <= v45) {
        continue;
      }
    }
    goto LABEL_224;
    *p_data_size_t size = v44;
    v42 += v52;
    v41 -= v52;
  }
  while (v41);
  if (v42 < 0) {
    goto LABEL_224;
  }
LABEL_86:
  size_t v53 = v119;
  if (!(void)v119) {
    goto LABEL_112;
  }
  uint64_t v54 = 0;
  p_data_size_t size = (size_t *)(v9 + 4808);
  unint64_t v55 = *(void *)(v9 + 4808);
  unint64_t v56 = *(void *)(v9 + 4816);
  while (2)
  {
    if (v55 != v56) {
      goto LABEL_99;
    }
    unint64_t v57 = v56 + 0x40000;
    if ((uint64_t)(v56 + 0x40000) < 0) {
      goto LABEL_224;
    }
    if (v56 > 0xFFFFFFFFFFFBFFFFLL)
    {
      unint64_t v55 = v56;
LABEL_99:
      size_t v59 = v56;
      goto LABEL_103;
    }
    do
    {
      while (!v56)
      {
        unint64_t v56 = 0x4000;
        size_t v59 = 0x4000;
        if (v57 <= 0x4000) {
          goto LABEL_101;
        }
      }
      unint64_t v58 = v56 >> 1;
      if ((v56 & (v56 >> 1)) != 0) {
        unint64_t v58 = v56 & (v56 >> 1);
      }
      v56 += v58;
    }
    while (v56 < v57);
    size_t v59 = v56;
    if (v56 >= 0x2000000001) {
      goto LABEL_222;
    }
LABEL_101:
    uint64_t v49 = *(void **)(v9 + 4824);
    unint64_t v60 = realloc(v49, v59);
    if (!v60) {
      goto LABEL_185;
    }
    *(void *)(v9 + 4824) = v60;
    *(void *)(v9 + 4816) = v59;
    unint64_t v55 = *(void *)(v9 + 4808);
LABEL_103:
    if (v59 - v55 >= v53) {
      size_t v61 = v53;
    }
    else {
      size_t v61 = v59 - v55;
    }
    ssize_t v62 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4824) + v55), v61);
    if (v62 < 0) {
      goto LABEL_224;
    }
    if (v62)
    {
      unint64_t v55 = *p_data_size + v62;
      if (__CFADD__(*p_data_size, v62)) {
        goto LABEL_224;
      }
      unint64_t v56 = *(void *)(v9 + 4816);
      if (v55 > v56) {
        goto LABEL_224;
      }
      *p_data_size_t size = v55;
      v54 += v62;
      v53 -= v62;
      if (v53) {
        continue;
      }
    }
    break;
  }
  if (v54 < 0) {
    goto LABEL_224;
  }
LABEL_112:
  size_t v63 = *((void *)&v119 + 1);
  if (*((void *)&v119 + 1))
  {
    uint64_t v64 = 0;
    p_data_size_t size = (size_t *)(v9 + 4832);
    unint64_t v65 = *(void *)(v9 + 4832);
    unint64_t v66 = *(void *)(v9 + 4840);
    while (1)
    {
      if (v65 == v66)
      {
        unint64_t v67 = v66 + 0x40000;
        if ((uint64_t)(v66 + 0x40000) < 0) {
          goto LABEL_224;
        }
        if (v66 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v66)
            {
              unint64_t v66 = 0x4000;
              size_t v69 = 0x4000;
              if (v67 <= 0x4000) {
                goto LABEL_127;
              }
            }
            unint64_t v68 = v66 >> 1;
            if ((v66 & (v66 >> 1)) != 0) {
              unint64_t v68 = v66 & (v66 >> 1);
            }
            v66 += v68;
          }
          while (v66 < v67);
          size_t v69 = v66;
          if (v66 >= 0x2000000001) {
            goto LABEL_222;
          }
LABEL_127:
          uint64_t v49 = *(void **)(v9 + 4848);
          uint64_t v70 = realloc(v49, v69);
          if (!v70) {
            goto LABEL_185;
          }
          *(void *)(v9 + 4848) = v70;
          *(void *)(v9 + 4840) = v69;
          unint64_t v65 = *(void *)(v9 + 4832);
          goto LABEL_129;
        }
        unint64_t v65 = v66;
      }
      size_t v69 = v66;
LABEL_129:
      if (v69 - v65 >= v63) {
        size_t v71 = v63;
      }
      else {
        size_t v71 = v69 - v65;
      }
      ssize_t v72 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4848) + v65), v71);
      if (v72 < 0) {
        goto LABEL_224;
      }
      if (!v72) {
        goto LABEL_137;
      }
      unint64_t v65 = *p_data_size + v72;
      if (__CFADD__(*p_data_size, v72)) {
        goto LABEL_224;
      }
      unint64_t v66 = *(void *)(v9 + 4840);
      if (v65 > v66) {
        goto LABEL_224;
      }
      *p_data_size_t size = v65;
      v64 += v72;
      v63 -= v72;
      if (!v63)
      {
LABEL_137:
        if ((v64 & 0x8000000000000000) == 0) {
          break;
        }
LABEL_224:
        uint64_t v14 = "write state";
        __int16 v15 = 953;
        goto LABEL_225;
      }
    }
  }
  *(unsigned char *)(v9 + v116.u32[0] + 2492) = 0;
  *(unsigned char *)(v9 + v116.u32[1] + 3516) = 0;
  *(unsigned char *)(v9 + v116.u32[2] + 4540) = 0;
  if (v116.i32[3])
  {
    AAHeader v73 = AAHeaderCreateWithEncodedData(data_size, data);
    *(void *)(v9 + 4768) = v73;
    if (!v73)
    {
      uint64_t v14 = "invalid header in state";
      __int16 v15 = 959;
      goto LABEL_225;
    }
  }
  if (!BYTE1(v120))
  {
    size_t v93 = v118;
    if (!(void)v118) {
      goto LABEL_214;
    }
    uint64_t v94 = 0;
    unint64_t v95 = (unint64_t *)(v9 + 4872);
    unint64_t v96 = *(void *)(v9 + 4872);
    unint64_t v97 = *(void *)(v9 + 4880);
    while (1)
    {
      if (v96 != v97) {
        goto LABEL_201;
      }
      unint64_t v98 = v97 + 0x40000;
      if ((uint64_t)(v97 + 0x40000) < 0) {
        goto LABEL_252;
      }
      if (v97 > 0xFFFFFFFFFFFBFFFFLL) {
        break;
      }
      do
      {
        while (!v97)
        {
          unint64_t v97 = 0x4000;
          size_t v100 = 0x4000;
          if (v98 <= 0x4000) {
            goto LABEL_203;
          }
        }
        unint64_t v99 = v97 >> 1;
        if ((v97 & (v97 >> 1)) != 0) {
          unint64_t v99 = v97 & (v97 >> 1);
        }
        v97 += v99;
      }
      while (v97 < v98);
      size_t v100 = v97;
      if (v97 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_251;
      }
LABEL_203:
      unsigned int v101 = *(void **)(v9 + 4888);
      unint64_t v102 = realloc(v101, v100);
      if (!v102)
      {
        free(v101);
LABEL_251:
        *unint64_t v95 = 0;
        *(void *)(v9 + 4880) = 0;
        *(void *)(v9 + 4888) = 0;
        goto LABEL_252;
      }
      *(void *)(v9 + 4888) = v102;
      *(void *)(v9 + 4880) = v100;
      unint64_t v96 = *(void *)(v9 + 4872);
LABEL_205:
      if (v100 - v96 >= v93) {
        size_t v103 = v93;
      }
      else {
        size_t v103 = v100 - v96;
      }
      ssize_t v104 = AAByteStreamRead(a2, (void *)(*(void *)(v9 + 4888) + v96), v103);
      if (v104 < 0) {
        goto LABEL_252;
      }
      if (!v104) {
        goto LABEL_213;
      }
      unint64_t v96 = *v95 + v104;
      if (__CFADD__(*v95, v104)) {
        goto LABEL_252;
      }
      unint64_t v97 = *(void *)(v9 + 4880);
      if (v96 > v97) {
        goto LABEL_252;
      }
      *unint64_t v95 = v96;
      v94 += v104;
      v93 -= v104;
      if (!v93)
      {
LABEL_213:
        if ((v94 & 0x8000000000000000) == 0) {
          goto LABEL_214;
        }
LABEL_252:
        uint64_t v14 = "truncated state";
        __int16 v15 = 983;
LABEL_225:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpenWithState", v15, 133, 0, v14, v6, v7, v110);
        goto LABEL_226;
      }
    }
    unint64_t v96 = v97;
LABEL_201:
    size_t v100 = v97;
    goto LABEL_205;
  }
  int v74 = AATempFileStreamOpenWithDirectory((const char *)(v9 + 12));
  *(void *)(v9 + 4864) = v74;
  if (!v74)
  {
    uint64_t v14 = "create temp file";
    __int16 v15 = 965;
    goto LABEL_225;
  }
  uint64_t v75 = v118;
  if (!(void)v118) {
    goto LABEL_214;
  }
  uint64_t v76 = 0;
  while (2)
  {
    unint64_t __s = 0;
    uint64_t v111 = v76;
    unint64_t v77 = v75 - v76;
    if (v77 >= 0x40000) {
      unint64_t v78 = 0x40000;
    }
    else {
      unint64_t v78 = v77;
    }
    if (!v78)
    {
LABEL_243:
      uint64_t v75 = v118;
      uint64_t v76 = v111;
      break;
    }
    unint64_t v79 = 0;
    uint64_t v80 = 0;
    unint64_t v81 = v113;
    while (2)
    {
      if (v79 == v81)
      {
        unint64_t v82 = v81 + 0x40000;
        if ((uint64_t)(v81 + 0x40000) < 0) {
          goto LABEL_248;
        }
        if (v81 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v81)
            {
              unint64_t v81 = 0x4000;
              size_t v84 = 0x4000;
              if (v82 <= 0x4000) {
                goto LABEL_160;
              }
            }
            unint64_t v83 = v81 >> 1;
            if ((v81 & (v81 >> 1)) != 0) {
              unint64_t v83 = v81 & (v81 >> 1);
            }
            v81 += v83;
          }
          while (v81 < v82);
          size_t v84 = v81;
          if (v81 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_247;
          }
LABEL_160:
          int v85 = realloc(__ptr, v84);
          if (v85)
          {
            size_t v113 = v84;
            __ptr = v85;
            unint64_t v81 = v84;
            goto LABEL_162;
          }
          free(__ptr);
LABEL_247:
          unint64_t __s = 0;
          size_t v113 = 0;
          __ptr = 0;
          goto LABEL_248;
        }
      }
LABEL_162:
      if (v81 - v79 >= v78) {
        size_t v86 = v78;
      }
      else {
        size_t v86 = v81 - v79;
      }
      ssize_t v87 = AAByteStreamRead(a2, (char *)__ptr + v79, v86);
      if (v87 < 0) {
        goto LABEL_248;
      }
      if (!v87) {
        break;
      }
      BOOL v88 = __CFADD__(v79, v87);
      v79 += v87;
      if (v88 || v79 > v81) {
        goto LABEL_248;
      }
      unint64_t __s = v79;
      v80 += v87;
      v78 -= v87;
      if (v78) {
        continue;
      }
      break;
    }
    if (v80 < 0)
    {
LABEL_248:
      uint64_t v14 = "reading state";
      __int16 v15 = 973;
      goto LABEL_225;
    }
    if (!v80) {
      goto LABEL_243;
    }
    uint64_t v89 = *(void *)(v9 + 4864);
    if (*(void *)(v89 + 24))
    {
      uint64_t v90 = 0;
      if (v79)
      {
        int v91 = (char *)__ptr;
        while (1)
        {
          uint64_t v92 = (*(uint64_t (**)(void, char *, unint64_t))(v89 + 24))(*(void *)v89, v91, v79);
          if (v92 < 1) {
            break;
          }
          v91 += v92;
          v90 += v92;
          v79 -= v92;
          if (!v79) {
            goto LABEL_180;
          }
        }
        uint64_t v90 = v92;
      }
    }
    else
    {
      uint64_t v90 = -1;
    }
LABEL_180:
    if (v90 != v80)
    {
      uint64_t v14 = "write DAT file";
      __int16 v15 = 976;
      goto LABEL_225;
    }
    uint64_t v76 = v80 + v111;
    uint64_t v75 = v118;
    if (v80 + v111 < (unint64_t)v118) {
      continue;
    }
    break;
  }
  if (v76 != v75)
  {
    uint64_t v14 = "truncated state";
    __int16 v15 = 979;
    goto LABEL_225;
  }
LABEL_214:
  if ((updateFromHeader((unsigned char *)v9) & 0x80000000) != 0)
  {
    uint64_t v14 = "deriving fields from header";
    __int16 v15 = 987;
    goto LABEL_225;
  }
  if ((_BYTE)v120)
  {
    if (!*(_DWORD *)(v9 + 1056))
    {
      uint64_t v14 = "missing PAT";
      __int16 v15 = 995;
      goto LABEL_225;
    }
    if ((concatExtractPath(v124, 0x400uLL, (char *)(v9 + 3516), (const char *)(v9 + 1064)) & 0x80000000) == 0)
    {
      long long v107 = aaArchiveFileOutputStreamOpenAtWithState(-1, v124, a2, a3);
      *(void *)(v9 + 4856) = v107;
      if (!v107)
      {
        uint64_t v14 = "aaArchiveFileOutputStreamOpenAtWithState";
        __int16 v15 = 1000;
        goto LABEL_225;
      }
      goto LABEL_219;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"aaAssetExtractStreamOpenWithState", 996, 133, 0, "invalid PAT: %s", v105, v106, v9 + 40);
LABEL_226:
    int v108 = 0;
  }
  else
  {
LABEL_219:
    if (a3) {
      *a3 = -1;
    }
    int v108 = 1;
  }
  free(data);
  memset_s(&data_size, 0x18uLL, 0, 0x18uLL);
  free(__ptr);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  if (v108) {
    uint64_t result = v8;
  }
  else {
    uint64_t result = 0;
  }
  if (v8 && (v108 & 1) == 0)
  {
    if (*v8) {
      ((void (*)(void))v8[1])();
    }
    free(v8);
    return 0;
  }
  return result;
}

uint64_t updateFromHeader(unsigned char *a1)
{
  uint64_t size = 0;
  size_t length = 0;
  uint64_t v46 = 0;
  uint64_t offset = 0;
  *((void *)a1 + 132) = 0;
  unsigned int v2 = a1 + 2112;
  *((void *)a1 + 261) = 0;
  *((void *)a1 + 263) = 0;
  *((void *)a1 + 262) = 0;
  memset_s(a1 + 2112, 0x48uLL, 0, 0x48uLL);
  memset_s(a1 + 2184, 0x38uLL, 0, 0x38uLL);
  memset_s(a1 + 2240, 0xACuLL, 0, 0xACuLL);
  memset_s(a1 + 2416, 0x38uLL, 0, 0x38uLL);
  __int16 v3 = (AAHeader_impl *)*((void *)a1 + 596);
  if (!v3) {
    return 0;
  }
  v4.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(*((AAHeader *)a1 + 596), v4);
  if ((KeyIndex & 0x80000000) != 0
    || ((unsigned int FieldUInt = AAHeaderGetFieldUInt(v3, KeyIndex, (uint64_t *)a1 + 261), FieldUInt <= 1)
      ? (int v9 = 1)
      : (int v9 = FieldUInt),
        v9 <= 0))
  {
    uint64_t v42 = "missing TYP";
    __int16 v43 = 141;
LABEL_46:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"updateFromHeader", v43, 133, 0, v42, v6, v7, v46);
    return 0xFFFFFFFFLL;
  }
  if ((aaEntryAttributesInitWithHeader(v2, a1 + 2184, a1 + 2240, *((AAHeader *)a1 + 596)) & 0x80000000) != 0)
  {
    uint64_t v42 = "attributes from header";
    __int16 v43 = 142;
    goto LABEL_46;
  }
  uint64_t v10 = (AAHeader_impl *)*((void *)a1 + 596);
  v11.uint64_t ikey = 5521744;
  uint32_t v12 = AAHeaderGetKeyIndex(v10, v11);
  if ((v12 & 0x80000000) == 0)
  {
    unsigned int FieldString = AAHeaderGetFieldString(v10, v12, 0x400uLL, a1 + 1064, &length);
    int v14 = FieldString <= 1 ? 1 : FieldString;
    if (v14 >= 1) {
      *((_DWORD *)a1 + 264) = 1;
    }
  }
  __int16 v15 = (AAHeader_impl *)*((void *)a1 + 596);
  v16.uint64_t ikey = 4408665;
  uint32_t v17 = AAHeaderGetKeyIndex(v15, v16);
  if ((v17 & 0x80000000) == 0)
  {
    unsigned int FieldBlob = AAHeaderGetFieldBlob(v15, v17, &size, &offset);
    int v19 = FieldBlob <= 1 ? 1 : FieldBlob;
    if (v19 >= 1)
    {
      a1[2416] |= 1u;
      *((void *)a1 + 304) = size;
    }
  }
  uint64_t v20 = (AAHeader_impl *)*((void *)a1 + 596);
  v21.uint64_t ikey = 5521752;
  uint32_t v22 = AAHeaderGetKeyIndex(v20, v21);
  if ((v22 & 0x80000000) == 0)
  {
    unsigned int v23 = AAHeaderGetFieldBlob(v20, v22, &size, &offset);
    int v24 = v23 <= 1 ? 1 : v23;
    if (v24 >= 1)
    {
      a1[2416] |= 2u;
      *((void *)a1 + 306) = size;
    }
  }
  uint64_t v25 = (AAHeader_impl *)*((void *)a1 + 596);
  v26.uint64_t ikey = 4997953;
  uint32_t v27 = AAHeaderGetKeyIndex(v25, v26);
  if ((v27 & 0x80000000) == 0)
  {
    unsigned int v28 = AAHeaderGetFieldBlob(v25, v27, &size, &offset);
    int v29 = v28 <= 1 ? 1 : v28;
    if (v29 >= 1)
    {
      a1[2416] |= 4u;
      *((void *)a1 + 308) = size;
    }
  }
  size_t v30 = (AAHeader_impl *)*((void *)a1 + 596);
  v31.uint64_t ikey = 5521732;
  uint32_t v32 = AAHeaderGetKeyIndex(v30, v31);
  if ((v32 & 0x80000000) == 0)
  {
    unsigned int v33 = AAHeaderGetFieldBlob(v30, v32, &size, &offset);
    int v34 = v33 <= 1 ? 1 : v33;
    if (v34 >= 1)
    {
      *((_DWORD *)a1 + 265) = 1;
      *((void *)a1 + 263) = size;
    }
  }
  uint64_t v35 = *((void *)a1 + 595);
  *((void *)a1 + 262) = v35;
  if (!v35)
  {
    unint64_t v36 = (AAHeader_impl *)*((void *)a1 + 596);
    v37.uint64_t ikey = 5263193;
    uint32_t v38 = AAHeaderGetKeyIndex(v36, v37);
    if ((v38 & 0x80000000) != 0
      || ((v39 = AAHeaderGetFieldUInt(v36, v38, &v46), v39 <= 1) ? (int v40 = 1) : (int v40 = v39), v40 < 1))
    {
      uint64_t v41 = *((void *)a1 + 262);
    }
    else
    {
      uint64_t v41 = v46;
      *((void *)a1 + 262) = v46;
    }
    if (!v41 && *((void *)a1 + 261) != 77) {
      *((void *)a1 + 262) = 69;
    }
  }
  *((void *)a1 + 310) = 40;
  *((_DWORD *)a1 + 618) = -1;
  *((_DWORD *)a1 + 622) = -1;
  if ((a1[2112] & 4) != 0)
  {
    char v45 = a1[2184];
    if ((a1[2124] & 0x20) != 0)
    {
      *((void *)a1 + 310) = 44;
      *((_DWORD *)a1 + 622) = 0;
      if (v45) {
        *((_DWORD *)a1 + 622) = *((_DWORD *)a1 + 548);
      }
    }
  }
  else
  {
    char v45 = a1[2184];
  }
  if ((v45 & 8) != 0)
  {
    uint64_t result = 0;
    *((_DWORD *)a1 + 618) = *((_DWORD *)a1 + 547);
    return result;
  }
  return 0;
}

uint64_t closeWithStateProc_1(uint64_t *a1, void *a2, void *a3)
{
  if (atomic_load((unsigned int *)a1 + 2)) {
    return 0xFFFFFFFFLL;
  }
  int v99 = 0;
  long long v97 = 0u;
  long long v98 = 0u;
  unint64_t __s = 0;
  size_t v88 = 0;
  uint64_t v8 = *a1;
  uint64_t v9 = a1[594];
  uint64_t v89 = 0;
  v90[0] = v8;
  v90[1] = v9;
  uint64_t v10 = (uint64_t)a1 + 2492;
  unsigned int v91 = strlen((const char *)a1 + 2492);
  uint64_t v11 = (uint64_t)a1 + 3516;
  unsigned int v92 = strlen((const char *)a1 + 3516);
  uint64_t v12 = (uint64_t)a1 + 4540;
  unsigned int v93 = strlen((const char *)a1 + 4540);
  BYTE2(v99) = *((_DWORD *)a1 + 1185);
  HIBYTE(v99) = *((_DWORD *)a1 + 1186);
  __int16 v15 = (AAHeader_impl *)a1[596];
  if (v15) {
    LODWORD(v15) = AAHeaderGetEncodedSize(v15);
  }
  unsigned int v94 = v15;
  uint64_t v16 = a1[595];
  uint64_t v95 = a1[597];
  uint64_t v96 = v16;
  uint64_t v17 = a1[601];
  *((void *)&v97 + 1) = a1[598];
  *(void *)&long long v98 = v17;
  *((void *)&v98 + 1) = a1[604];
  uint64_t v18 = (AAByteStream_impl *)a1[608];
  if (v18)
  {
    off_t v19 = AAByteStreamSeek(v18, 0, 2);
    char v20 = 1;
  }
  else
  {
    char v20 = 0;
    off_t v19 = a1[609];
  }
  BYTE1(v99) = v20;
  *(void *)&long long v97 = v19;
  LOBYTE(v99) = a1[607] != 0;
  if (!a2[3]) {
    goto LABEL_120;
  }
  uint64_t v21 = 0;
  uint32_t v22 = v90;
  uint64_t v23 = 84;
  do
  {
    uint64_t v24 = ((uint64_t (*)(void, void *, uint64_t))a2[3])(*a2, v22, v23);
    if (v24 < 1)
    {
      if ((v24 & 0x8000000000000000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_120;
    }
    uint32_t v22 = (void *)((char *)v22 + v24);
    v21 += v24;
    v23 -= v24;
  }
  while (v23);
  if (v21 < 0) {
    goto LABEL_120;
  }
LABEL_15:
  if (!a2[3]) {
    goto LABEL_120;
  }
  uint64_t v25 = v91;
  if (!v91) {
    goto LABEL_24;
  }
  uint64_t v26 = 0;
  while (2)
  {
    uint64_t v27 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v10, v25);
    if (v27 < 1)
    {
      if ((v27 & 0x8000000000000000) == 0) {
        goto LABEL_23;
      }
      goto LABEL_120;
    }
    v10 += v27;
    v26 += v27;
    v25 -= v27;
    if (v25) {
      continue;
    }
    break;
  }
  if (v26 < 0) {
    goto LABEL_120;
  }
LABEL_23:
  if (!a2[3])
  {
LABEL_120:
    size_t v71 = "write state";
    __int16 v72 = 747;
    goto LABEL_121;
  }
LABEL_24:
  uint64_t v28 = v92;
  if (v92)
  {
    uint64_t v29 = 0;
    while (1)
    {
      uint64_t v30 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v11, v28);
      if (v30 < 1) {
        break;
      }
      v11 += v30;
      v29 += v30;
      v28 -= v30;
      if (!v28) {
        goto LABEL_30;
      }
    }
    uint64_t v29 = v30;
LABEL_30:
    if (v29 < 0) {
      goto LABEL_120;
    }
  }
  if (!a2[3]) {
    goto LABEL_120;
  }
  uint64_t v31 = v93;
  if (v93)
  {
    uint64_t v32 = 0;
    while (1)
    {
      uint64_t v33 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v12, v31);
      if (v33 < 1) {
        break;
      }
      v12 += v33;
      v32 += v33;
      v31 -= v33;
      if (!v31) {
        goto LABEL_38;
      }
    }
    uint64_t v32 = v33;
LABEL_38:
    if (v32 < 0) {
      goto LABEL_120;
    }
  }
  int v34 = (AAHeader_impl *)a1[596];
  if (!v34) {
    goto LABEL_48;
  }
  EncodedData = AAHeaderGetEncodedData(v34);
  if (!a2[3]) {
    goto LABEL_120;
  }
  uint64_t v36 = v94;
  if (!v94) {
    goto LABEL_49;
  }
  AAFieldKey v37 = EncodedData;
  uint64_t v38 = 0;
  while (1)
  {
    uint64_t v39 = ((uint64_t (*)(void, const uint8_t *, uint64_t))a2[3])(*a2, v37, v36);
    if (v39 < 1) {
      break;
    }
    v37 += v39;
    v38 += v39;
    v36 -= v39;
    if (!v36) {
      goto LABEL_47;
    }
  }
  uint64_t v38 = v39;
LABEL_47:
  if (v38 < 0) {
    goto LABEL_120;
  }
LABEL_48:
  if (!a2[3]) {
    goto LABEL_120;
  }
LABEL_49:
  uint64_t v40 = *((void *)&v97 + 1);
  if (*((void *)&v97 + 1))
  {
    uint64_t v41 = 0;
    uint64_t v42 = a1[600];
    while (1)
    {
      uint64_t v43 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v42, v40);
      if (v43 < 1) {
        break;
      }
      v42 += v43;
      v41 += v43;
      v40 -= v43;
      if (!v40) {
        goto LABEL_55;
      }
    }
    uint64_t v41 = v43;
LABEL_55:
    if (v41 < 0) {
      goto LABEL_120;
    }
  }
  if (!a2[3]) {
    goto LABEL_120;
  }
  uint64_t v44 = v98;
  if ((void)v98)
  {
    uint64_t v45 = 0;
    uint64_t v46 = a1[603];
    while (1)
    {
      uint64_t v47 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v46, v44);
      if (v47 < 1) {
        break;
      }
      v46 += v47;
      v45 += v47;
      v44 -= v47;
      if (!v44) {
        goto LABEL_63;
      }
    }
    uint64_t v45 = v47;
LABEL_63:
    if (v45 < 0 || !a2[3]) {
      goto LABEL_120;
    }
  }
  uint64_t v48 = *((void *)&v98 + 1);
  if (*((void *)&v98 + 1))
  {
    uint64_t v49 = 0;
    uint64_t v50 = a1[606];
    while (1)
    {
      uint64_t v51 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v50, v48);
      if (v51 < 1) {
        break;
      }
      v50 += v51;
      v49 += v51;
      v48 -= v51;
      if (!v48) {
        goto LABEL_71;
      }
    }
    uint64_t v49 = v51;
LABEL_71:
    if (v49 < 0) {
      goto LABEL_120;
    }
  }
  if (!a1[608])
  {
    if (a2[3])
    {
      uint64_t v77 = v97;
      if (!(void)v97) {
        goto LABEL_133;
      }
      uint64_t v78 = 0;
      uint64_t v79 = a1[611];
      while (1)
      {
        uint64_t v80 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v79, v77);
        if (v80 < 1) {
          break;
        }
        v79 += v80;
        v78 += v80;
        v77 -= v80;
        if (!v77) {
          goto LABEL_132;
        }
      }
      uint64_t v78 = v80;
LABEL_132:
      if ((v78 & 0x8000000000000000) == 0) {
        goto LABEL_133;
      }
    }
    size_t v71 = "write state";
    __int16 v72 = 769;
    goto LABEL_121;
  }
  uint64_t v52 = v97;
  if (!(void)v97) {
    goto LABEL_133;
  }
  int v85 = 0;
  size_t v53 = 0;
  unint64_t v54 = 0;
  unint64_t v55 = 0;
  while (2)
  {
    unint64_t __s = 0;
    unint64_t v56 = v52 - v55;
    if (v56 >= 0x40000) {
      unint64_t v57 = 0x40000;
    }
    else {
      unint64_t v57 = v56;
    }
    if (!v57)
    {
LABEL_142:
      uint64_t v52 = v97;
      break;
    }
    unint64_t v58 = 0;
    uint64_t v59 = 0;
    s = (AAByteStream_impl *)a1[608];
    unint64_t v84 = v55;
    off_t v60 = v55;
    while (2)
    {
      if (v58 == v54)
      {
        unint64_t v61 = v54 + 0x40000;
        if ((uint64_t)(v54 + 0x40000) < 0) {
          goto LABEL_147;
        }
        if (v54 <= 0xFFFFFFFFFFFBFFFFLL)
        {
          do
          {
            while (!v54)
            {
              unint64_t v54 = 0x4000;
              size_t v63 = 0x4000;
              if (v61 <= 0x4000) {
                goto LABEL_93;
              }
            }
            unint64_t v62 = v54 >> 1;
            if ((v54 & (v54 >> 1)) != 0) {
              unint64_t v62 = v54 & (v54 >> 1);
            }
            v54 += v62;
          }
          while (v54 < v61);
          size_t v63 = v54;
          if (v54 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_146;
          }
LABEL_93:
          uint64_t v64 = (char *)realloc(v53, v63);
          if (v64)
          {
            size_t v88 = v63;
            uint64_t v89 = v64;
            int v85 = v64;
            unint64_t v58 = __s;
            goto LABEL_95;
          }
          free(v53);
LABEL_146:
          unint64_t __s = 0;
          size_t v88 = 0;
          uint64_t v89 = 0;
          goto LABEL_147;
        }
        unint64_t v58 = v54;
      }
      size_t v63 = v54;
      uint64_t v64 = v53;
LABEL_95:
      if (v63 - v58 >= v57) {
        size_t v65 = v57;
      }
      else {
        size_t v65 = v63 - v58;
      }
      size_t v53 = v64;
      ssize_t v66 = AAByteStreamPRead(s, &v64[v58], v65, v60);
      if (v66 < 0) {
        goto LABEL_147;
      }
      if (v66)
      {
        unint64_t v58 = __s + v66;
        if (__CFADD__(__s, v66)) {
          goto LABEL_147;
        }
        unint64_t v54 = v88;
        if (v58 > v88) {
          goto LABEL_147;
        }
        __s += v66;
        v59 += v66;
        v60 += v66;
        v57 -= v66;
        if (!v57) {
          goto LABEL_105;
        }
        continue;
      }
      break;
    }
    unint64_t v54 = v63;
LABEL_105:
    if (v59 < 0)
    {
LABEL_147:
      size_t v71 = "reading DAT file";
      __int16 v72 = 759;
      goto LABEL_121;
    }
    unint64_t v55 = v84;
    if (!v59) {
      goto LABEL_142;
    }
    if (a2[3])
    {
      unint64_t v67 = __s;
      if (__s)
      {
        uint64_t v68 = 0;
        size_t v69 = v85;
        while (1)
        {
          uint64_t v70 = ((uint64_t (*)(void, char *, unint64_t))a2[3])(*a2, v69, v67);
          if (v70 < 1) {
            break;
          }
          v69 += v70;
          v68 += v70;
          v67 -= v70;
          if (!v67)
          {
            size_t v53 = v85;
            goto LABEL_116;
          }
        }
        size_t v53 = v85;
        uint64_t v68 = v70;
LABEL_116:
        unint64_t v55 = v84;
      }
      else
      {
        uint64_t v68 = 0;
        size_t v53 = v85;
      }
    }
    else
    {
      uint64_t v68 = -1;
    }
    if (v68 != v59)
    {
      size_t v71 = "write state";
      __int16 v72 = 762;
LABEL_121:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"closeWithStateProc", v72, 133, 0, v71, v13, v14, v84);
      uint64_t v4 = 0xFFFFFFFFLL;
      AAHeader v73 = a1 + 604;
      goto LABEL_122;
    }
    v55 += v59;
    uint64_t v52 = v97;
    if (v55 < (unint64_t)v97) {
      continue;
    }
    break;
  }
  if (v55 != v52)
  {
    size_t v71 = "truncated DAT file";
    __int16 v72 = 765;
    goto LABEL_121;
  }
LABEL_133:
  unint64_t v81 = (uint64_t (**)(void))a1[607];
  if (!v81)
  {
    AAHeader v73 = a1 + 604;
    goto LABEL_138;
  }
  AAHeader v73 = a1 + 604;
  if ((AAByteStreamCloseWithState(v81) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"closeWithStateProc", 775, 133, 0, "write state", v82, v83, v84);
    a1[607] = 0;
    uint64_t v4 = 0xFFFFFFFFLL;
LABEL_122:
    uint64_t v75 = a1 + 598;
    int v74 = a1 + 601;
    goto LABEL_123;
  }
  a1[607] = 0;
LABEL_138:
  uint64_t v75 = a1 + 598;
  int v74 = a1 + 601;
  uint64_t v4 = 0;
  if (a3) {
    *a3 = -1;
  }
LABEL_123:
  free(v89);
  memset_s(&__s, 0x18uLL, 0, 0x18uLL);
  AAHeaderDestroy((AAHeader)a1[596]);
  free((void *)a1[600]);
  memset_s(v75, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[603]);
  memset_s(v74, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[606]);
  memset_s(v73, 0x18uLL, 0, 0x18uLL);
  free((void *)a1[611]);
  memset_s(a1 + 609, 0x18uLL, 0, 0x18uLL);
  AAByteStreamClose((AAByteStream)a1[608]);
  AAByteStreamClose((AAByteStream)a1[607]);
  free(a1);
  return v4;
}

uint64_t writeHeaderProc(uint64_t a1, AAHeader header)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  if (atomic_load((unsigned int *)(a1 + 8))) {
    return 0xFFFFFFFFLL;
  }
  size_t length = 0;
  uint64_t value = 0;
  v5.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v5);
  if ((KeyIndex & 0x80000000) != 0
    || ((unsigned int v9 = AAHeaderGetFieldUInt(header, KeyIndex, &value), v9 <= 1) ? (v10 = 1) : (v10 = v9), v10 <= 0))
  {
    uint64_t v18 = "missing TYP";
    __int16 v19 = 569;
  }
  else
  {
    v11.uint64_t ikey = 4997708;
    uint32_t v12 = AAHeaderGetKeyIndex(header, v11);
    if ((v12 & 0x80000000) == 0)
    {
      unsigned int FieldString = AAHeaderGetFieldString(header, v12, 0xC8uLL, __s1, &length);
      int v14 = FieldString <= 1 ? 1 : FieldString;
      if (v14 >= 1)
      {
        if (strcmp(__s1, (const char *)(a1 + 4540)))
        {
          __strlcpy_chk();
          *(_DWORD *)(a1 + 4740) = 0;
          __int16 v15 = *(uint64_t (**)(void, uint64_t, char *, void))(a1 + 1048);
          if (v15)
          {
            int v16 = v15(*(void *)(a1 + 1040), 90, __s1, 0);
            if (v16 < 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"updateLabel", 205, 133, 0, "Caller cancelled", v7, v8, v47);
              uint64_t v18 = "updating label";
              __int16 v19 = 571;
              goto LABEL_20;
            }
            if (v16) {
              *(_DWORD *)(a1 + 4740) = 1;
            }
          }
        }
      }
    }
    if (*(_DWORD *)(a1 + 4740)) {
      return 0;
    }
    if (value == 77)
    {
      v50[0] = 0;
      v21.uint64_t ikey = 5263193;
      uint32_t v22 = AAHeaderGetKeyIndex(header, v21);
      if ((v22 & 0x80000000) == 0)
      {
        unsigned int FieldUInt = AAHeaderGetFieldUInt(header, v22, v50);
        int v24 = FieldUInt <= 1 ? 1 : FieldUInt;
        if (v24 >= 1)
        {
          if (v50[0] == 93)
          {
            *(void *)(a1 + 4760) = 0;
            return 0;
          }
          if (v50[0] == 91)
          {
            v25.uint64_t ikey = 5328729;
            uint32_t v26 = AAHeaderGetKeyIndex(header, v25);
            if ((v26 & 0x80000000) == 0)
            {
              unsigned int v27 = AAHeaderGetFieldUInt(header, v26, (uint64_t *)(a1 + 4760));
              int v28 = v27 <= 1 ? 1 : v27;
              if (v28 >= 1 && *(void *)(a1 + 4760)) {
                return 0;
              }
            }
            uint64_t v18 = "expected valid YOQ field";
            __int16 v19 = 584;
            goto LABEL_20;
          }
        }
      }
    }
    if (*(void *)(a1 + 4864)
      || *(void *)(a1 + 4856)
      || *(void *)(a1 + 4768)
      || *(void *)(a1 + 4872)
      || *(void *)(a1 + 4784)
      || *(void *)(a1 + 4808)
      || *(void *)(a1 + 4832))
    {
      uint64_t v18 = "invalid extractor state (blobs)";
      __int16 v19 = 603;
    }
    else
    {
      *(void *)(a1 + 4768) = AAHeaderClone(header);
      *(void *)(a1 + 4776) = AAHeaderGetPayloadSize(header);
      if ((updateFromHeader((unsigned char *)a1) & 0x80000000) == 0)
      {
        if (*(void *)(a1 + 2096) == 77)
        {
          int v34 = (_DWORD *)(a1 + 1056);
        }
        else
        {
          if (!*(_DWORD *)(a1 + 4744))
          {
            uint64_t v18 = "invalid AssetArchive stream (missing manifest)";
            __int16 v19 = 616;
            goto LABEL_20;
          }
          int v34 = (_DWORD *)(a1 + 1056);
          if (*(_DWORD *)(a1 + 1056))
          {
            uint64_t v40 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(a1 + 1048);
            if (v40)
            {
              LOBYTE(v50[0]) = 0;
              int v41 = v40(*(void *)(a1 + 1040), 91, a1 + 1064, v50);
              if (v41 < 0)
              {
                uint64_t v18 = "Caller cancelled";
                __int16 v19 = 626;
                goto LABEL_20;
              }
              if (v41)
              {
                __strlcpy_chk();
                v42.uint64_t ikey = 5521744;
                int v43 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 4768), v42);
                if (v43 < 0)
                {
                  uint64_t v18 = "no PAT field in header";
                  __int16 v19 = 632;
                  goto LABEL_20;
                }
                uint32_t v44 = v43;
                size_t v45 = strlen((const char *)(a1 + 1064));
                v46.uint64_t ikey = 5521744;
                if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 4768), v44, v46, (const char *)(a1 + 1064), v45) < 0)
                {
                  uint64_t v18 = "set PAT";
                  __int16 v19 = 633;
                  goto LABEL_20;
                }
              }
            }
          }
        }
        if (*(void *)(a1 + 2088) == 70 && *(void *)(a1 + 2096) == 69)
        {
          if (!*v34)
          {
            uint64_t v18 = "missing PAT";
            __int16 v19 = 640;
            goto LABEL_20;
          }
          if ((concatExtractPath((char *)v50, 0x400uLL, (char *)(a1 + 3516), (const char *)(a1 + 1064)) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"writeHeaderProc", 641, 133, 0, "invalid PAT: %s", v35, v36, a1 + 40);
            goto LABEL_21;
          }
          size_t v37 = strlen((const char *)v50);
          makePath((const char *)v50, v37);
          uint64_t v38 = aaArchiveFileOutputStreamOpenAt(-1, (const char *)v50, *(void *)(a1 + 2104), *(_DWORD *)(a1 + 2488), 0, *(_DWORD *)(a1 + 2472), *(void *)(a1 + 2480));
          *(void *)(a1 + 4856) = v38;
          if (!v38)
          {
            uint64_t v18 = "file stream";
            __int16 v19 = 647;
            goto LABEL_20;
          }
        }
        if (!*(_DWORD *)(a1 + 1060)
          || *(void *)(a1 + 4856)
          || *(void *)(a1 + 2104) < *(void *)(a1 + 4752)
          || (uint64_t v39 = AATempFileStreamOpenWithDirectory((const char *)(a1 + 12)), (*(void *)(a1 + 4864) = v39) != 0))
        {
          if (*(void *)(a1 + 4776)
            || (processEntry_0((unsigned char *)a1, v29, v30, v31, v32, v33, v7, v8) & 0x80000000) == 0)
          {
            return 0;
          }
          uint64_t v18 = "entry processing";
          __int16 v19 = 658;
        }
        else
        {
          uint64_t v18 = "temp stream";
          __int16 v19 = 654;
        }
        goto LABEL_20;
      }
      uint64_t v18 = "extract entry attributes from header";
      __int16 v19 = 610;
    }
  }
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"writeHeaderProc", v19, 133, 0, v18, v7, v8, v47);
LABEL_21:
  int v20 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 8), (unsigned int *)&v20, 1u);
  return 0xFFFFFFFFLL;
}

uint64_t writeBlobProc(uint64_t a1, size_t a2, uint64_t __src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 8))) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  if (!__smax || *(_DWORD *)(a1 + 4740)) {
    return result;
  }
  if (*(void *)(a1 + 4776) < __smax)
  {
    uint32_t v12 = "blob size mismatch";
    __int16 v13 = 672;
LABEL_93:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"writeBlobProc", v13, 133, 0, v12, a7, a8, v51);
    int v46 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 8), (unsigned int *)&v46, 1u);
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)(a1 + 4768))
  {
    uint32_t v12 = "invalid state";
    __int16 v13 = 673;
    goto LABEL_93;
  }
  int v14 = (char *)__src;
  uint64_t result = 0;
  uint64_t v15 = a2 & 0xFFFFFF;
  if ((a2 & 0xFFFFFF) <= 0x544143)
  {
    if (v15 != 4408665)
    {
      if (v15 == 4997953)
      {
        uint64_t v16 = *(void *)(a1 + 4832);
        BOOL v17 = __CFADD__(v16, __smax);
        unint64_t v18 = v16 + __smax;
        if (!v17 && (v18 & 0x8000000000000000) == 0)
        {
          __int16 v19 = (void *)(a1 + 4832);
          size_t v20 = *(void *)(a1 + 4840);
          if (v20 >= v18) {
            goto LABEL_74;
          }
          do
          {
            while (!v20)
            {
              size_t v20 = 0x4000;
              if (v18 <= 0x4000)
              {
                uint32_t v22 = (void **)(a1 + 4848);
                size_t v20 = 0x4000;
                goto LABEL_72;
              }
            }
            size_t v21 = v20 >> 1;
            if ((v20 & (v20 >> 1)) != 0) {
              size_t v21 = v20 & (v20 >> 1);
            }
            v20 += v21;
          }
          while (v20 < v18);
          uint32_t v22 = (void **)(a1 + 4848);
          if (v20 >= 0x2000000001) {
            goto LABEL_83;
          }
LABEL_72:
          uint64_t v40 = *v22;
          int v41 = realloc(*v22, v20);
          if (v41)
          {
            *(void *)(a1 + 4848) = v41;
            *(void *)(a1 + 4840) = v20;
LABEL_74:
            uint64_t v42 = *(void *)(a1 + 4848);
            if (!v14) {
              goto LABEL_80;
            }
            goto LABEL_87;
          }
          goto LABEL_94;
        }
LABEL_68:
        uint64_t v24 = -1;
        goto LABEL_69;
      }
      return result;
    }
    uint64_t v27 = *(void *)(a1 + 4784);
    BOOL v17 = __CFADD__(v27, __smax);
    unint64_t v28 = v27 + __smax;
    if (v17 || (v28 & 0x8000000000000000) != 0) {
      goto LABEL_68;
    }
    __int16 v19 = (void *)(a1 + 4784);
    size_t v29 = *(void *)(a1 + 4792);
    if (v29 >= v28)
    {
LABEL_79:
      uint64_t v42 = *(void *)(a1 + 4800);
      if (!v14) {
        goto LABEL_80;
      }
      goto LABEL_87;
    }
    do
    {
      while (!v29)
      {
        size_t v29 = 0x4000;
        if (v28 <= 0x4000)
        {
          uint32_t v22 = (void **)(a1 + 4800);
          size_t v29 = 0x4000;
          goto LABEL_77;
        }
      }
      size_t v30 = v29 >> 1;
      if ((v29 & (v29 >> 1)) != 0) {
        size_t v30 = v29 & (v29 >> 1);
      }
      v29 += v30;
    }
    while (v29 < v28);
    uint32_t v22 = (void **)(a1 + 4800);
    if (v29 >= 0x2000000001) {
      goto LABEL_83;
    }
LABEL_77:
    uint64_t v40 = *v22;
    int v43 = realloc(*v22, v29);
    if (v43)
    {
      *(void *)(a1 + 4800) = v43;
      *(void *)(a1 + 4792) = v29;
      goto LABEL_79;
    }
LABEL_94:
    char v47 = v40;
    goto LABEL_95;
  }
  if (v15 == 5521752)
  {
    uint64_t v31 = *(void *)(a1 + 4808);
    BOOL v17 = __CFADD__(v31, __smax);
    unint64_t v32 = v31 + __smax;
    if (v17 || (v32 & 0x8000000000000000) != 0) {
      goto LABEL_68;
    }
    __int16 v19 = (void *)(a1 + 4808);
    size_t v33 = *(void *)(a1 + 4816);
    if (v33 < v32)
    {
      do
      {
        while (!v33)
        {
          size_t v33 = 0x4000;
          if (v32 <= 0x4000)
          {
            uint32_t v22 = (void **)(a1 + 4824);
            size_t v33 = 0x4000;
            goto LABEL_84;
          }
        }
        size_t v34 = v33 >> 1;
        if ((v33 & (v33 >> 1)) != 0) {
          size_t v34 = v33 & (v33 >> 1);
        }
        v33 += v34;
      }
      while (v33 < v32);
      uint32_t v22 = (void **)(a1 + 4824);
      if (v33 >= 0x2000000001)
      {
LABEL_83:
        *__error() = 12;
        goto LABEL_96;
      }
LABEL_84:
      uint64_t v40 = *v22;
      uint32_t v44 = realloc(*v22, v33);
      if (!v44) {
        goto LABEL_94;
      }
      *(void *)(a1 + 4824) = v44;
      *(void *)(a1 + 4816) = v33;
    }
    uint64_t v42 = *(void *)(a1 + 4824);
    if (!v14) {
      goto LABEL_80;
    }
    goto LABEL_87;
  }
  if (v15 == 5521732)
  {
    uint64_t v23 = *(void **)(a1 + 4856);
    if (v23)
    {
      if (!v23[3]) {
        goto LABEL_68;
      }
      uint64_t v24 = 0;
      rsize_t v25 = __smax;
      while (1)
      {
        uint64_t v26 = ((uint64_t (*)(void, char *, rsize_t))v23[3])(*v23, v14, v25);
        if (v26 < 1) {
          break;
        }
        v14 += v26;
        v24 += v26;
        v25 -= v26;
        if (!v25) {
          goto LABEL_69;
        }
      }
    }
    else
    {
      uint64_t v35 = *(void **)(a1 + 4864);
      if (!v35)
      {
        uint64_t v37 = *(void *)(a1 + 4872);
        BOOL v17 = __CFADD__(v37, __smax);
        unint64_t v38 = v37 + __smax;
        if (!v17 && (v38 & 0x8000000000000000) == 0)
        {
          __int16 v19 = (void *)(a1 + 4872);
          a2 = *(void *)(a1 + 4880);
          if (a2 < v38)
          {
            do
            {
              while (!a2)
              {
                a2 = 0x4000;
                if (v38 <= 0x4000)
                {
                  uint32_t v22 = (void **)(a1 + 4888);
                  a2 = 0x4000;
                  goto LABEL_98;
                }
              }
              size_t v39 = a2 >> 1;
              if ((a2 & (a2 >> 1)) != 0) {
                size_t v39 = a2 & (a2 >> 1);
              }
              a2 += v39;
            }
            while (a2 < v38);
            uint32_t v22 = (void **)(a1 + 4888);
            if (a2 >= 0x2000000001) {
              goto LABEL_83;
            }
LABEL_98:
            uint64_t v48 = *v22;
            size_t v49 = a2;
            uint64_t v50 = realloc(*v22, a2);
            if (!v50)
            {
              char v47 = v48;
LABEL_95:
              free(v47);
LABEL_96:
              *uint32_t v22 = 0;
              uint64_t v24 = -1;
              *__int16 v19 = 0;
              v19[1] = 0;
LABEL_69:
              if (v24 != __smax)
              {
                uint32_t v12 = "store blob";
                __int16 v13 = 688;
                goto LABEL_93;
              }
LABEL_89:
              rsize_t v45 = *(void *)(a1 + 4776) - __smax;
              *(void *)(a1 + 4776) = v45;
              if (v45 || (processEntry_0((unsigned char *)a1, a2, __src, __smax, a5, a6, a7, a8) & 0x80000000) == 0) {
                return 0;
              }
              uint32_t v12 = "entry processing";
              __int16 v13 = 693;
              goto LABEL_93;
            }
            *(void *)(a1 + 4888) = v50;
            *(void *)(a1 + 4880) = v49;
          }
          uint64_t v42 = *(void *)(a1 + 4888);
          if (!v14)
          {
LABEL_80:
            if (v42) {
              memset_s((void *)(v42 + *v19), __smax, 0, __smax);
            }
            goto LABEL_88;
          }
LABEL_87:
          memcpy((void *)(v42 + *v19), v14, __smax);
LABEL_88:
          *v19 += __smax;
          goto LABEL_89;
        }
        goto LABEL_68;
      }
      if (!v35[3]) {
        goto LABEL_68;
      }
      uint64_t v24 = 0;
      rsize_t v36 = __smax;
      while (1)
      {
        uint64_t v26 = ((uint64_t (*)(void, char *, rsize_t))v35[3])(*v35, v14, v36);
        if (v26 < 1) {
          break;
        }
        v14 += v26;
        v24 += v26;
        v36 -= v26;
        if (!v36) {
          goto LABEL_69;
        }
      }
    }
    uint64_t v24 = v26;
    goto LABEL_69;
  }
  return result;
}

void cancelProc_1(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 8), (unsigned int *)&v1, 1u);
}

uint64_t processEntry_0(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v127 = *MEMORY[0x263EF8340];
  size_t length = 0;
  memset(&v106, 0, sizeof(v106));
  AAHashFunction hash_function = 0;
  long long v110 = 0u;
  long long v111 = 0u;
  *(_OWORD *)uint64_t value = 0u;
  long long v109 = 0u;
  unint64_t v9 = *(void *)a1;
  int v10 = a1 + 2492;
  int v11 = a1[2492];
  if (a1[2492]) {
    BOOL v12 = strcmp(a1 + 2492, a1 + 3516) == 0;
  }
  else {
    BOOL v12 = 0;
  }
  if ((v9 & 2) != 0) {
    uint64_t v13 = 0x20000000000001;
  }
  else {
    uint64_t v13 = 0x20000000000000;
  }
  int v14 = a1 + 2416;
  char v15 = a1[2416];
  if (v15)
  {
    if (*((void *)a1 + 304) != *((void *)a1 + 598))
    {
      uint64_t v24 = "blob size mismatch";
      __int16 v25 = 235;
      goto LABEL_31;
    }
    *((void *)a1 + 303) = *((void *)a1 + 600);
  }
  if ((v15 & 2) != 0)
  {
    if (*((void *)a1 + 306) != *((void *)a1 + 601))
    {
      uint64_t v24 = "blob size mismatch";
      __int16 v25 = 240;
      goto LABEL_31;
    }
    *((void *)a1 + 305) = *((void *)a1 + 603);
  }
  if ((v15 & 4) != 0)
  {
    if (*((void *)a1 + 308) != *((void *)a1 + 604))
    {
      uint64_t v24 = "blob size mismatch";
      __int16 v25 = 245;
      goto LABEL_31;
    }
    *((void *)a1 + 307) = *((void *)a1 + 606);
  }
  uint64_t v16 = *((void *)a1 + 262);
  unint64_t v17 = v9 >> 62;
  switch(v16)
  {
    case 'C':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        __int16 v25 = 398;
        break;
      }
      if (!v11)
      {
        uint64_t v24 = "no input dir";
        __int16 v25 = 399;
        break;
      }
      if (v17 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Copy %c %s\n", (char)a1[2088], a1 + 1064);
      }
      if (v12) {
        goto LABEL_39;
      }
      if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 402, 133, 0, "invalid PAT: %s", v18, v19, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 403, 133, 0, "invalid PAT: %s", v20, v21, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if ((aaCopyFile(v114, __s, v13) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 404, 133, 0, "copy file: %s", v22, v23, (char)__s);
        goto LABEL_32;
      }
      if (*((void *)a1 + 598) && (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        uint64_t v24 = "apply YEC (copy)";
        __int16 v25 = 406;
        break;
      }
      goto LABEL_39;
    case 'E':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        __int16 v25 = 262;
        break;
      }
      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 263, 133, 0, "invalid PAT: %s", v30, v31, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if (v17 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Extract %c %s\n", (char)a1[2088], a1 + 1064);
      }
      size_t v32 = strlen(__s);
      makePath(__s, v32);
      uint64_t v33 = *((void *)a1 + 261);
      switch(v33)
      {
        case 'L':
          size_t v69 = (AAHeader_impl *)*((void *)a1 + 596);
          v70.uint64_t ikey = 4935244;
          uint32_t KeyIndex = AAHeaderGetKeyIndex(v69, v70);
          if ((KeyIndex & 0x80000000) != 0
            || ((unsigned int FieldString = AAHeaderGetFieldString(v69, KeyIndex, 0x400uLL, v114, &length), FieldString <= 1)
              ? (int v73 = 1)
              : (int v73 = FieldString),
                v73 <= 0))
          {
            uint64_t v24 = "missing LNK";
            __int16 v25 = 279;
            goto LABEL_31;
          }
          unlink(__s);
          if ((symlink(v114, __s) & 0x80000000) == 0) {
            goto LABEL_39;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 281, 133, 0, "creating symlink: %s", v74, v75, (char)__s);
          goto LABEL_32;
        case 'F':
          uint64_t v76 = (AAByteStream_impl *)*((void *)a1 + 607);
          if (!v76)
          {
            uint64_t v24 = "no file stream";
            __int16 v25 = 286;
            goto LABEL_31;
          }
          AAByteStreamClose(v76);
          *((void *)a1 + 607) = 0;
          if (*((void *)a1 + 598) && (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
          {
            uint64_t v24 = "apply YEC (extract)";
            __int16 v25 = 288;
            goto LABEL_31;
          }
          break;
        case 'D':
          unlink(__s);
          if (mkdir(__s, 0x1EDu) < 0 && (*__error() != 17 || stat(__s, &v106) || (v106.st_mode & 0xF000) != 0x4000))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 274, 133, 0, "creating dir: %s", v34, v35, (char)__s);
            goto LABEL_32;
          }
          break;
        default:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 292, 133, 0, "Unsupported entry type (extract): %c\n", a7, a8, v33);
          goto LABEL_32;
      }
      goto LABEL_39;
    case 'I':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        __int16 v25 = 425;
        break;
      }
      if (!v11)
      {
        uint64_t v24 = "no input dir";
        __int16 v25 = 426;
        break;
      }
      if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 427, 133, 0, "invalid PAT: %s", v36, v37, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      if (v17 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Src check %c %s\n", (char)a1[2088], a1 + 1064);
      }
      uint32_t FieldCount = AAHeaderGetFieldCount(*((AAHeader *)a1 + 596));
      *(_OWORD *)unint64_t __s = 0u;
      memset(v113, 0, 156);
      if (!FieldCount) {
        goto LABEL_183;
      }
      uint32_t v41 = FieldCount;
      uint32_t v42 = 0;
      uint64_t v43 = 0;
      do
      {
        if (AAHeaderGetFieldType(*((AAHeader *)a1 + 596), v42) != 3)
        {
          int v48 = 0;
          goto LABEL_96;
        }
        AAFieldKey FieldKey = AAHeaderGetFieldKey(*((AAHeader *)a1 + 596), v42);
        if (!v43)
        {
          uint32_t v51 = FieldKey.ikey & 0xFFFFFF;
          if ((FieldKey.ikey & 0xFFFFFF) == 0x324853)
          {
            uint64_t v43 = 0x2000;
          }
          else if (v51 == 3491923)
          {
            uint64_t v43 = 0x8000;
          }
          else
          {
            if (v51 != 3360851)
            {
              int v48 = 0;
              uint64_t v43 = 0;
              goto LABEL_96;
            }
            uint64_t v43 = 0x4000;
          }
        }
        if (!*(_DWORD *)__s && (aaEntryHashesInitWithPath(__s, v43, v10, a1 + 1064) & 0x80000000) != 0)
        {
          long long v98 = v114;
          uint64_t v77 = "computing file digest: %s";
          __int16 v78 = 454;
          goto LABEL_206;
        }
        if (AAHeaderGetFieldHash(*((AAHeader *)a1 + 596), v42, 0x40uLL, &hash_function, value) < 0)
        {
          uint64_t v77 = "retrieving digest from header";
          __int16 v78 = 458;
LABEL_206:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v78, 133, 0, v77, v39, v40, (char)v98);
          goto LABEL_207;
        }
        if ((__s[0] & 4) != 0 && hash_function == 3)
        {
          BOOL v47 = *(void *)((char *)v113 + 12) == *(void *)value
             && *(void *)((char *)&v113[1] + 4) == *(void *)&value[8]
             && *(void *)((char *)&v113[1] + 12) == (void)v109
             && *(void *)((char *)&v113[2] + 4) == *((void *)&v109 + 1);
          goto LABEL_93;
        }
        if ((__s[0] & 8) != 0 && hash_function == 4)
        {
          size_t v49 = (char *)&v113[2] + 12;
          size_t v50 = 48;
          goto LABEL_92;
        }
        int v48 = 0;
        if ((__s[0] & 0x10) != 0 && hash_function == 5)
        {
          size_t v49 = (char *)&v113[5] + 12;
          size_t v50 = 64;
LABEL_92:
          BOOL v47 = memcmp(v49, value, v50) == 0;
LABEL_93:
          int v48 = v47;
        }
LABEL_96:
        ++v42;
      }
      while (v42 < v41 && !v48);
      if (v48)
      {
LABEL_128:
        int v28 = 1;
        goto LABEL_208;
      }
LABEL_183:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 465, 133, 0, "patch doesn't match source file: %s", v39, v40, (char)v114);
LABEL_207:
      int v28 = 0;
LABEL_208:
      uint64_t v26 = 0;
LABEL_209:
      uint64_t v27 = 0;
LABEL_34:
      AAHeaderDestroy(*((AAHeader *)a1 + 596));
      *((void *)a1 + 596) = 0;
      AAByteStreamClose(*((AAByteStream *)a1 + 608));
      *((void *)a1 + 608) = 0;
      AAByteStreamClose(*((AAByteStream *)a1 + 607));
      *((void *)a1 + 607) = 0;
      *((void *)a1 + 609) = 0;
      *((void *)a1 + 598) = 0;
      *((void *)a1 + 601) = 0;
      *((void *)a1 + 604) = 0;
      memset_s(a1 + 2112, 0x48uLL, 0, 0x48uLL);
      memset_s(a1 + 2184, 0x38uLL, 0, 0x38uLL);
      memset_s(a1 + 2240, 0xACuLL, 0, 0xACuLL);
      memset_s(a1 + 2416, 0x38uLL, 0, 0x38uLL);
      AAByteStreamClose(v27);
      MappedBufferDestroy(v26);
      if (v28) {
        return 0;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    case 'M':
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      int v28 = 1;
      *((_DWORD *)a1 + 1186) = 1;
      goto LABEL_34;
    case 'O':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        __int16 v25 = 472;
        break;
      }
      if (v17 < 2) {
        goto LABEL_127;
      }
      uint64_t v126 = 0;
      long long v125 = 0u;
      long long v124 = 0u;
      long long v123 = 0u;
      long long v122 = 0u;
      long long v121 = 0u;
      long long v120 = 0u;
      long long v119 = 0u;
      long long v118 = 0u;
      long long v117 = 0u;
      long long v116 = 0u;
      long long v115 = 0u;
      *(_OWORD *)uint64_t v114 = 0u;
      char v52 = a1[2112];
      if (v52)
      {
        __strlcat_chk();
        char v52 = a1[2112];
        if ((v52 & 2) == 0)
        {
LABEL_107:
          if ((v52 & 8) == 0) {
            goto LABEL_108;
          }
          goto LABEL_150;
        }
      }
      else if ((a1[2112] & 2) == 0)
      {
        goto LABEL_107;
      }
      __strlcat_chk();
      char v52 = a1[2112];
      if ((v52 & 8) == 0)
      {
LABEL_108:
        if ((v52 & 4) == 0) {
          goto LABEL_109;
        }
        goto LABEL_151;
      }
LABEL_150:
      __strlcat_chk();
      char v52 = a1[2112];
      if ((v52 & 4) == 0)
      {
LABEL_109:
        if ((v52 & 0x40) == 0) {
          goto LABEL_110;
        }
        goto LABEL_152;
      }
LABEL_151:
      __strlcat_chk();
      char v52 = a1[2112];
      if ((v52 & 0x40) == 0)
      {
LABEL_110:
        if ((v52 & 0x10) == 0) {
          goto LABEL_111;
        }
        goto LABEL_153;
      }
LABEL_152:
      __strlcat_chk();
      char v52 = a1[2112];
      if ((v52 & 0x10) == 0)
      {
LABEL_111:
        if ((v52 & 0x20) == 0) {
          goto LABEL_113;
        }
        goto LABEL_112;
      }
LABEL_153:
      __strlcat_chk();
      if ((a1[2112] & 0x20) != 0) {
LABEL_112:
      }
        __strlcat_chk();
LABEL_113:
      char v53 = a1[2184];
      if ((v53 & 2) != 0)
      {
        __strlcat_chk();
        char v53 = a1[2184];
        if ((v53 & 1) == 0)
        {
LABEL_115:
          if ((v53 & 8) == 0) {
            goto LABEL_116;
          }
          goto LABEL_157;
        }
      }
      else if ((a1[2184] & 1) == 0)
      {
        goto LABEL_115;
      }
      __strlcat_chk();
      char v53 = a1[2184];
      if ((v53 & 8) == 0)
      {
LABEL_116:
        if ((v53 & 4) == 0) {
          goto LABEL_118;
        }
        goto LABEL_117;
      }
LABEL_157:
      __strlcat_chk();
      if ((a1[2184] & 4) == 0)
      {
LABEL_118:
        char v54 = a1[2240];
        if ((v54 & 4) != 0)
        {
          __strlcat_chk();
          char v54 = a1[2240];
          if ((v54 & 8) == 0)
          {
LABEL_120:
            if ((v54 & 0x10) == 0) {
              goto LABEL_122;
            }
            goto LABEL_121;
          }
        }
        else if ((a1[2240] & 8) == 0)
        {
          goto LABEL_120;
        }
        __strlcat_chk();
        if ((a1[2240] & 0x10) == 0)
        {
LABEL_122:
          char v55 = *v14;
          if (*v14)
          {
            __strlcat_chk();
            char v55 = *v14;
            if ((*v14 & 2) == 0)
            {
LABEL_124:
              if ((v55 & 4) == 0) {
                goto LABEL_126;
              }
              goto LABEL_125;
            }
          }
          else if ((*v14 & 2) == 0)
          {
            goto LABEL_124;
          }
          __strlcat_chk();
          if ((*v14 & 4) == 0)
          {
LABEL_126:
            fprintf((FILE *)*MEMORY[0x263EF8348], "Dst fixup %c%s %s\n", (char)a1[2088], v114, a1 + 1064);
LABEL_127:
            *(void *)uint64_t v114 = 0;
            if ((aaCheckAndFixWithPath(a1 + 2112, a1 + 2184, a1 + 2240, a1 + 2416, -1, (unsigned int *)v114, a1 + 3516, a1 + 1064, v13) & 0x80000000) == 0)goto LABEL_128; {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 503, 133, 0, "fixup failed: %s", v56, v57, (char)__s);
            }
            goto LABEL_207;
          }
LABEL_125:
          __strlcat_chk();
          goto LABEL_126;
        }
LABEL_121:
        __strlcat_chk();
        goto LABEL_122;
      }
LABEL_117:
      __strlcat_chk();
      goto LABEL_118;
    case 'P':
      if (!*((_DWORD *)a1 + 264))
      {
        uint64_t v24 = "missing PAT";
        __int16 v25 = 301;
        break;
      }
      if (v17 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Patch %s\n", a1 + 1064);
      }
      if (!v11)
      {
        uint64_t v24 = "no input dir";
        __int16 v25 = 303;
        break;
      }
      if (*((void *)a1 + 607))
      {
        uint64_t v24 = "file stream already opened";
        __int16 v25 = 304;
        break;
      }
      if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 305, 133, 0, "invalid PAT: %s", v60, v61, (_BYTE)a1 + 40);
        goto LABEL_32;
      }
      uint64_t v103 = 0;
      uint64_t v104 = 0;
      unint64_t v62 = (unsigned int **)*((void *)a1 + 608);
      if (v62)
      {
        int FD = aaFileStreamGetFD(v62);
        uint64_t v64 = MappedBufferCreateWithFD(FD, 0, 0xFFFFFFFFFFFFFFFFLL);
        uint64_t v26 = v64;
        if (!v64)
        {
          uint64_t v89 = "mapping patch file";
          __int16 v90 = 316;
          goto LABEL_230;
        }
        unint64_t v67 = (void *)BXDiffMatchesOBuf((uint64_t)v64);
        unint64_t DataSize = MappedBufferGetDataSize((uint64_t)v26);
      }
      else
      {
        uint64_t v26 = 0;
        unint64_t v67 = (void *)*((void *)a1 + 611);
        unint64_t DataSize = *((void *)a1 + 609);
      }
      size_t v79 = strlen(__s);
      makePath(__s, v79);
      if (DataSize < 9 || *v67 != 0x3031464649444952)
      {
        if ((BXDiff5GetPatchInfo((uint64_t)v67, DataSize, (uint64_t)&v103) & 0x80000000) != 0)
        {
          LOBYTE(v98) = (_BYTE)a1 + 40;
          uint64_t v89 = "invalid patch: %s";
          __int16 v90 = 353;
        }
        else if (v104)
        {
          size_t v86 = aaArchiveFileOutputStreamOpenAt(-1, __s, v103, *((_DWORD *)a1 + 622), 0, *((_DWORD *)a1 + 618), *((void *)a1 + 310));
          *((void *)a1 + 607) = v86;
          if (v86)
          {
            if ((BXPatch5StreamWithFlags(0, 0, 0, (uint64_t)v67, DataSize, (uint64_t (*)(uint64_t, void *, uint64_t))aaByteStreamPCWriteProc, (uint64_t)v86, 2) & 0x80000000) == 0)
            {
LABEL_198:
              AAByteStreamClose(*((AAByteStream *)a1 + 607));
              *((void *)a1 + 607) = 0;
              goto LABEL_199;
            }
            long long v98 = __s;
            uint64_t v89 = "patching failed: %s";
            __int16 v90 = 364;
          }
          else
          {
            uint64_t v89 = "file stream";
            __int16 v90 = 359;
          }
        }
        else if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
        {
          LOBYTE(v98) = (_BYTE)a1 + 40;
          uint64_t v89 = "invalid PAT: %s";
          __int16 v90 = 371;
        }
        else if (v12)
        {
          if (HIDWORD(v104))
          {
            if ((BXPatch5InPlace(__s, (uint64_t)v67, DataSize, 0, v91, v92, v65, v66) & 0x80000000) == 0)
            {
LABEL_199:
              MappedBufferDestroy(v26);
              if (!*((void *)a1 + 598) || (applyYEC((uint64_t *)a1 + 598, a1 + 3516, a1 + 1064) & 0x80000000) == 0)
              {
                uint64_t v26 = 0;
                int v28 = 1;
                goto LABEL_209;
              }
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 392, 133, 0, "apply YEC (patch)", v87, v88, (char)v98);
              uint64_t v26 = 0;
              goto LABEL_232;
            }
            uint64_t v89 = "in-place patching failed";
            __int16 v90 = 376;
          }
          else
          {
            uint64_t v89 = "patch doesn't allow in-place";
            __int16 v90 = 375;
          }
        }
        else
        {
          long long v97 = aaArchiveFileOutputStreamOpenAt(-1, __s, v103, *((_DWORD *)a1 + 622), 0, *((_DWORD *)a1 + 618), *((void *)a1 + 310));
          *((void *)a1 + 607) = v97;
          if (!v97)
          {
            uint64_t v89 = "file stream";
            __int16 v90 = 381;
            goto LABEL_231;
          }
          if ((BXPatch5FileWithFlags(v114, (uint64_t)v67, DataSize, (uint64_t (*)(uint64_t, void *, uint64_t))aaByteStreamPCWriteProc, (uint64_t)v97, 2) & 0x80000000) == 0)goto LABEL_198; {
          long long v98 = __s;
          }
          uint64_t v89 = "patching failed: %s";
          __int16 v90 = 386;
        }
LABEL_230:
        LODWORD(v97) = 0;
LABEL_231:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v90, 133, (int)v97, v89, v65, v66, (char)v98);
LABEL_232:
        int v28 = 0;
        goto LABEL_209;
      }
      uint64_t v102 = 0;
      long long v100 = 0u;
      long long v101 = 0u;
      long long v99 = 0u;
      uint64_t v27 = (AAByteStream_impl *)AAMemoryInputStreamOpen((uint64_t)v67, DataSize, v80, v81, v82, v83, v84, v85);
      if (v27)
      {
        if ((concatPath(v114, 0x400uLL, v10, a1 + 1064) & 0x80000000) != 0)
        {
          LOBYTE(v98) = (_BYTE)a1 + 40;
          uint64_t v95 = "invalid PAT: %s";
          __int16 v96 = 339;
        }
        else
        {
          *(void *)&long long v100 = v114;
          *((void *)&v100 + 1) = __s;
          int v28 = 1;
          DWORD2(v101) = 1;
          LODWORD(v102) = 1;
          if ((RawImagePatchInternal((uint64_t)&v99, v27) & 0x80000000) == 0) {
            goto LABEL_34;
          }
          uint64_t v95 = "RawImagePatchInternal";
          __int16 v96 = 348;
        }
      }
      else
      {
        uint64_t v95 = "AAMemoryInputStreamOpen";
        __int16 v96 = 336;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v96, 133, 0, v95, v93, v94, (char)v98);
      goto LABEL_33;
    case 'R':
      if (*((_DWORD *)a1 + 264))
      {
        if (v11)
        {
          if (v17 >= 2) {
            fprintf((FILE *)*MEMORY[0x263EF8348], "Remove %c %s\n", (char)a1[2088], a1 + 1064);
          }
          if (!v12) {
            goto LABEL_39;
          }
          if ((concatExtractPath(__s, 0x400uLL, a1 + 3516, a1 + 1064) & 0x80000000) == 0)
          {
            unlink(__s);
LABEL_39:
            uint64_t v26 = 0;
            uint64_t v27 = 0;
            int v28 = 1;
            goto LABEL_34;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", 417, 133, 0, "invalid PAT: %s", v58, v59, (_BYTE)a1 + 40);
LABEL_32:
          uint64_t v26 = 0;
          uint64_t v27 = 0;
LABEL_33:
          int v28 = 0;
          goto LABEL_34;
        }
        uint64_t v24 = "no input dir";
        __int16 v25 = 413;
      }
      else
      {
        uint64_t v24 = "missing PAT";
        __int16 v25 = 412;
      }
      break;
    default:
      fprintf((FILE *)*MEMORY[0x263EF8348], "TODO(%c) %c %s\n", (char)v16, (char)a1[2088], a1 + 1064);
      goto LABEL_39;
  }
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"processEntry", v25, 133, 0, v24, a7, a8, (char)v98);
  goto LABEL_32;
}

uint64_t applyYEC(uint64_t *a1, char *a2, const char *a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a1;
  if (!*a1) {
    return 0;
  }
  char v4 = (char)a3;
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  memset(v18, 0, 172);
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  LOBYTE(v10) = 1;
  *((void *)&v10 + 1) = a1[2];
  *(void *)&long long v11 = v3;
  uint64_t v9 = 0;
  int v7 = aaCheckAndFixWithPath(v16, (unsigned __int8 *)v14, v18, (unsigned __int8 *)&v10, -1, (unsigned int *)&v9, a2, a3, 0x20000000000000);
  if (v7 < 0) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetExtractStream.c", (uint64_t)"applyYEC", 113, 133, 0, "ECC failed: %s", v5, v6, v4);
  }
  return (v7 >> 31);
}

size_t appendThreadErrorContextString(size_t result)
{
  if (result)
  {
    int v1 = (const void *)result;
    uint64_t result = strlen((const char *)result);
    if (result - 8193 >= 0xFFFFFFFFFFFFE000)
    {
      size_t v2 = result;
      pthread_key_t ErrorContextKey = getErrorContextKey();
      uint64_t result = (size_t)pthread_getspecific(ErrorContextKey);
      if (result)
      {
        size_t v4 = result;
        __int16 v5 = v2 + 3;
        uint64_t v6 = *(unsigned __int16 *)(result + 72);
        if (v6 + (unsigned __int16)(v2 + 3) <= *(unsigned __int16 *)(result + 74))
        {
          size_t v7 = result + v6;
          *(_WORD *)(v7 + 76) = v5;
          size_t v8 = v7 + 78;
          uint64_t result = (size_t)memcpy((void *)(v7 + 78), v1, v2);
          *(unsigned char *)(v8 + v2) = 0;
          *(_WORD *)(v4 + 72) += v5;
        }
      }
    }
  }
  return result;
}

_WORD *updateThreadErrorContextErrorCode(_WORD *result)
{
  if ((result & 0x80000000) != 0)
  {
    int v1 = (int)result;
    pthread_key_t ErrorContextKey = getErrorContextKey();
    uint64_t result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*(_DWORD *)result & 0x80000000) == 0)
      {
        *(_DWORD *)uint64_t result = v1;
        result[3] = 0;
      }
    }
  }
  return result;
}

_DWORD *updateThreadErrorContextWarningCode(_DWORD *result)
{
  if ((result & 0x80000000) != 0)
  {
    int v1 = (int)result;
    pthread_key_t ErrorContextKey = getErrorContextKey();
    uint64_t result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*result & 0x80000000) == 0)
      {
        uint64_t v3 = *((unsigned __int16 *)result + 3);
        if (v3 <= 0xF)
        {
          result[v3 + 2] = v1;
          *((_WORD *)result + 3) = v3 + 1;
        }
      }
    }
  }
  return result;
}

unsigned __int16 *saveThreadErrorContext(void *a1)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  uint64_t result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    size_t v4 = result;
    bzero(a1, 0x2000uLL);
    uint64_t v5 = v4[36];
    if (v5 <= 0x1FB4) {
      size_t v6 = v5 + 76;
    }
    else {
      size_t v6 = 0;
    }
    return (unsigned __int16 *)memcpy(a1, v4, v6);
  }
  return result;
}

unsigned __int16 *restoreThreadErrorContext(long long *a1)
{
  pthread_key_t ErrorContextKey = getErrorContextKey();
  uint64_t result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    long long v4 = a1[1];
    long long v13 = *a1;
    long long v14 = v4;
    long long v5 = a1[3];
    long long v15 = a1[2];
    *(_OWORD *)uint64_t v16 = v5;
    *(_OWORD *)&v16[12] = *(long long *)((char *)a1 + 60);
    if ((v13 & 0x80000000) == 0)
    {
      unsigned int v6 = WORD3(v13);
      if ((*(_DWORD *)result & 0x80000000) != 0 && WORD3(v13) <= 0xFu)
      {
        unsigned int v6 = WORD3(v13) + 1;
        *((_DWORD *)&v13 + WORD3(v13) + 2) = *(_DWORD *)result;
      }
      unint64_t v7 = result[3];
      if (result[3] && v6 <= 0xF)
      {
        unint64_t v8 = 0;
        do
        {
          int v9 = *(_DWORD *)&result[2 * v8 + 4];
          if (v8 >= v6 || *((_DWORD *)&v13 + v8 + 2) != v9)
          {
            uint64_t v10 = v6++;
            *((_DWORD *)&v13 + v10 + 2) = v9;
          }
          ++v8;
        }
        while (v8 < v7 && v6 < 0x10);
      }
      WORD3(v13) = v6;
    }
    long long v11 = *(_OWORD *)v16;
    *((_OWORD *)result + 2) = v15;
    *((_OWORD *)result + 3) = v11;
    *(_OWORD *)(result + 30) = *(_OWORD *)&v16[12];
    long long v12 = v14;
    *(_OWORD *)uint64_t result = v13;
    *((_OWORD *)result + 1) = v12;
    if (*(unsigned __int16 *)&v16[24] <= 0x1FB4uLL) {
      return (unsigned __int16 *)memcpy(result + 38, (char *)a1 + 76, *(unsigned __int16 *)&v16[24]);
    }
  }
  return result;
}

size_t ParallelCompressionUpdateError(_WORD *a1, size_t a2)
{
  updateThreadErrorContextErrorCode(a1);

  return appendThreadErrorContextString(a2);
}

AAArchiveStream AAConvertArchiveOutputStreamOpen(AAArchiveStream stream, AAFieldKeySet insert_key_set, AAFieldKeySet remove_key_set, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  long long v13 = (AAArchiveStream **)malloc(0x38uLL);
  long long v14 = v13;
  if (v13) {
    memset_s(v13, 0x38uLL, 0, 0x38uLL);
  }
  long long v15 = (AAArchiveStream *)malloc(0x310uLL);
  uint64_t v16 = v15;
  if (!v15 || (memset_s(v15, 0x310uLL, 0, 0x310uLL), !v14))
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 507;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"AAConvertArchiveOutputStreamOpen", v23, 111, v21, v22, v18, v19, v25);
    free(v14);
    convertStreamClose((uint64_t)v16);
    return 0;
  }
  *uint64_t v16 = stream;
  v16[1] = AAFieldKeySetClone(insert_key_set);
  AAFieldKeySet v17 = AAFieldKeySetClone(remove_key_set);
  v16[2] = v17;
  if (!v16[1] || !v17)
  {
    uint64_t v22 = "copy key set";
    __int16 v23 = 512;
    int v21 = 0;
    goto LABEL_11;
  }
  v16[3] = (AAArchiveStream)flags;
  _OWORD v16[4] = (AAArchiveStream)msg_data;
  v16[5] = (AAArchiveStream)msg_proc;
  v16[12] = (AAArchiveStream)0x10000;
  uint64_t v20 = (AAArchiveStream_impl *)malloc(0x10000uLL);
  v16[13] = v20;
  if (!v20)
  {
    int v21 = *__error();
    uint64_t v22 = "malloc";
    __int16 v23 = 518;
    goto LABEL_11;
  }
  _OWORD v14[3] = (AAArchiveStream *)convertStreamWriteHeader;
  v14[4] = (AAArchiveStream *)convertStreamWriteBlob;
  v14[2] = (AAArchiveStream *)convertStreamAbort;
  *long long v14 = v16;
  v14[1] = (AAArchiveStream *)convertStreamClose;
  return (AAArchiveStream)v14;
}

uint64_t convertStreamClose(uint64_t a1)
{
  if (a1)
  {
    AAFieldKeySetDestroy(*(AAFieldKeySet *)(a1 + 8));
    AAFieldKeySetDestroy(*(AAFieldKeySet *)(a1 + 16));
    AAHeaderDestroy(*(AAHeader *)(a1 + 56));
    OECCStreamDestroy(*(void ***)(a1 + 776));
    free(*(void **)(a1 + 128));
    memset_s((void *)(a1 + 112), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 104));
    free(*(void **)(a1 + 88));
    memset_s((void *)(a1 + 80), 0x10uLL, 0, 0x10uLL);
    free((void *)a1);
  }
  return 0;
}

uint64_t convertStreamWriteHeader(uint64_t a1, AAHeader header)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 48)) {
    return 0;
  }
  uint64_t value = 0;
  *(_OWORD *)uint64_t v81 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 112) = 0;
  v6.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v6);
  if ((KeyIndex & 0x80000000) != 0 || AAHeaderGetFieldUInt(header, KeyIndex, &value) >= 2)
  {
    long long v15 = "Invalid entry missing TYP field (skipped)";
    __int16 v16 = 237;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamWriteHeader", v16, 111, v15, v8, v9, v10, v72);
LABEL_11:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 52) = 1;
    return result;
  }
  v11.uint64_t ikey = 5521744;
  uint32_t v12 = AAHeaderGetKeyIndex(header, v11);
  if ((v12 & 0x80000000) != 0)
  {
    int v14 = 0;
  }
  else
  {
    unsigned int FieldString = AAHeaderGetFieldString(header, v12, 0x400uLL, __s, 0);
    if (FieldString <= 1) {
      int v14 = 1;
    }
    else {
      int v14 = FieldString;
    }
  }
  if (v14 <= 0 && value != 77)
  {
    long long v15 = "Invalid non metadata entry missing PAT field (skipped)";
    __int16 v16 = 244;
    goto LABEL_10;
  }
  if (v14 >= 1)
  {
    AAFieldKeySet v17 = *(uint64_t (**)(void, uint64_t, char *, AAHeader))(a1 + 40);
    if (v17)
    {
      int v18 = v17(*(void *)(a1 + 32), 40, __s, header);
      if (v18 < 0) {
        goto LABEL_103;
      }
      if (v18) {
        goto LABEL_11;
      }
      int v19 = (*(uint64_t (**)(void, uint64_t, char *, unsigned char *))(a1 + 40))(*(void *)(a1 + 32), 41, __s, v85);
      if (v19 < 0)
      {
LABEL_103:
        *(_DWORD *)(a1 + 48) = 1;
        return 0xFFFFFFFFLL;
      }
      if (v19) {
        __strlcpy_chk();
      }
    }
  }
  if (value == 77 && (*(unsigned char *)(a1 + 25) & 2) != 0) {
    goto LABEL_11;
  }
  if ((aaHeaderBlobArrayInitWithHeader(a1 + 80, header) & 0x80000000) != 0)
  {
    AAFieldKey v70 = "capturing non-empty blobs";
    __int16 v71 = 262;
    goto LABEL_132;
  }
  AAHeader v22 = AAHeaderCreate();
  *(void *)(a1 + 56) = v22;
  if (!v22)
  {
    AAFieldKey v70 = "create new header";
    __int16 v71 = 266;
LABEL_132:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamWriteHeader", v71, 111, 0, v70, v20, v21, v72);
    if (!*(_DWORD *)(a1 + 48))
    {
      *(_DWORD *)(a1 + 48) = 1;
      AAArchiveStreamCancel(*(AAArchiveStream *)a1);
    }
    return 0xFFFFFFFFLL;
  }
  uint32_t FieldCount = AAHeaderGetFieldCount(header);
  if (!FieldCount) {
    goto LABEL_108;
  }
  uint32_t v29 = FieldCount;
  int v73 = 0;
  uint32_t v30 = 0;
  uint64_t v72 = a1 + 144;
  do
  {
    AAFieldKey FieldKey = AAHeaderGetFieldKey(header, v30);
    AAFieldKey v32 = FieldKey;
    int v33 = AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 16), v32);
    uint64_t v34 = *(void *)FieldKey.skey & 0xFFFFFFLL;
    if ((*(void *)FieldKey.skey & 0xFFFFFFLL) == 0x544144)
    {
      size.tv_seCC_SHA1_CTX c = 0;
      uint64_t offset = 0;
      if (AAHeaderGetFieldBlob(header, v30, (uint64_t *)&size, &offset) < 0)
      {
        AAFieldKey v70 = "getting header blob field";
        __int16 v71 = 290;
        goto LABEL_132;
      }
      if (!v33
        || ((*(void *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F ? (uint64_t v35 = 5521744) : (uint64_t v35 = 5265748), v34 == v35))
      {
        AAFieldKey v36 = FieldKey;
        if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v36, size.tv_sec) < 0)
        {
          AAFieldKey v70 = "inserting header field";
          __int16 v71 = 295;
          goto LABEL_132;
        }
        int v73 = 1;
      }
      v37.uint64_t ikey = 3229779;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v37))
      {
        v38.uint64_t ikey = 3229779;
        if (AAHeaderGetKeyIndex(header, v38) < 0)
        {
          v39.uint64_t ikey = 3229779;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v39, 2u, v81) < 0)
          {
            AAFieldKey v70 = "inserting header field";
            __int16 v71 = 300;
            goto LABEL_132;
          }
          *(unsigned char *)(a1 + 136) |= 2u;
          CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)(a1 + 160));
        }
      }
      v40.uint64_t ikey = 3295315;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v40))
      {
        v41.uint64_t ikey = 3295315;
        if (AAHeaderGetKeyIndex(header, v41) < 0)
        {
          v42.uint64_t ikey = 3295315;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v42, 3u, v81) < 0)
          {
            AAFieldKey v70 = "inserting header field";
            __int16 v71 = 306;
            goto LABEL_132;
          }
          *(unsigned char *)(a1 + 136) |= 4u;
          CC_SHA256_Init((CC_SHA256_CTX *)(a1 + 256));
        }
      }
      v43.uint64_t ikey = 3360851;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v43))
      {
        v44.uint64_t ikey = 3360851;
        if (AAHeaderGetKeyIndex(header, v44) < 0)
        {
          v45.uint64_t ikey = 3360851;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v45, 4u, v81) < 0)
          {
            AAFieldKey v70 = "inserting header field";
            __int16 v71 = 312;
            goto LABEL_132;
          }
          *(unsigned char *)(a1 + 136) |= 8u;
          CC_SHA384_Init((CC_SHA512_CTX *)(a1 + 360));
        }
      }
      v46.uint64_t ikey = 3491923;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v46))
      {
        v47.uint64_t ikey = 3491923;
        if (AAHeaderGetKeyIndex(header, v47) < 0)
        {
          v48.uint64_t ikey = 3491923;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v48, 5u, v81) < 0)
          {
            AAFieldKey v70 = "inserting header field";
            __int16 v71 = 318;
            goto LABEL_132;
          }
          *(unsigned char *)(a1 + 136) |= 0x10u;
          CC_SHA512_Init((CC_SHA512_CTX *)(a1 + 568));
        }
      }
      v49.uint64_t ikey = 5458755;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v49))
      {
        v50.uint64_t ikey = 5458755;
        if (AAHeaderGetKeyIndex(header, v50) < 0)
        {
          v51.uint64_t ikey = 5458755;
          if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v51, 1u, v81) < 0)
          {
            AAFieldKey v70 = "inserting header field";
            __int16 v71 = 324;
            goto LABEL_132;
          }
          *(unsigned char *)(a1 + 136) |= 1u;
          CC_CKSUM_Init(v72);
        }
      }
      v52.uint64_t ikey = 5917011;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v52))
      {
        v53.uint64_t ikey = 5917011;
        if (AAHeaderGetKeyIndex(header, v53) < 0)
        {
          v54.uint64_t ikey = 5917011;
          if (AAHeaderSetFieldUInt(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v54, size.tv_sec) < 0)
          {
            AAFieldKey v70 = "inserting header field";
            __int16 v71 = 330;
            goto LABEL_132;
          }
        }
      }
      v55.uint64_t ikey = 4408665;
      if (AAFieldKeySetContainsKey(*(AAFieldKeySet *)(a1 + 8), v55))
      {
        v56.uint64_t ikey = 4408665;
        if (AAHeaderGetKeyIndex(header, v56) < 0)
        {
          if (size.tv_sec)
          {
            v57.uint64_t ikey = 4408665;
            if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v57, 0) < 0)
            {
              AAFieldKey v70 = "inserting header field";
              __int16 v71 = 334;
              goto LABEL_132;
            }
            *(unsigned char *)(a1 + 136) |= 0x20u;
            uint64_t v58 = OECCStreamCreate(1, 0x4000u, size.tv_sec);
            *(void *)(a1 + 776) = v58;
            if (!v58)
            {
              AAFieldKey v70 = "creating YEC context";
              __int16 v71 = 337;
              goto LABEL_132;
            }
          }
        }
      }
      if (!v33
        || ((*(void *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F ? (uint64_t v59 = 5521744) : (uint64_t v59 = 5265748), v34 == v59))
      {
        if (*(_DWORD *)(a1 + 136))
        {
          AAFieldKey v70 = "can't generate a field from DAT, and keep DAT at the same time";
          __int16 v71 = 342;
          goto LABEL_132;
        }
      }
    }
    if (v33)
    {
      if ((*(void *)FieldKey.skey & 0xFFFFFFuLL) > 0x54414F)
      {
        if (v34 == 5521744)
        {
LABEL_85:
          size_t v63 = strlen(__s);
          AAFieldKey v64 = FieldKey;
          if (AAHeaderSetFieldString(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v64, __s, v63) < 0)
          {
            AAFieldKey v70 = "inserting header field";
            __int16 v71 = 350;
            goto LABEL_132;
          }
          goto LABEL_86;
        }
        uint64_t v60 = 5653828;
        goto LABEL_80;
      }
      if (v34 != 4935244)
      {
        uint64_t v60 = 5265748;
LABEL_80:
        if (v34 != v60) {
          goto LABEL_86;
        }
      }
    }
    else if (v34 == 5521744)
    {
      goto LABEL_85;
    }
    if (v34 != 5521732)
    {
      int FieldType = AAHeaderGetFieldType(header, v30);
      uint64_t v78 = 0;
      uint64_t offset = 0;
      uint64_t v76 = 0;
      uint64_t v77 = 0;
      AAHashFunction hash_function = 0;
      size.tv_seCC_SHA1_CTX c = 0;
      size.tv_nseCC_SHA1_CTX c = 0;
      switch(FieldType)
      {
        case 0:
          AAFieldKey v62 = FieldKey;
          if ((AAHeaderSetFieldFlag(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v62) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          AAFieldKey v70 = "inserting header field";
          __int16 v71 = 375;
          goto LABEL_132;
        case 1:
          if (AAHeaderGetFieldUInt(header, v30, &v76) < 0)
          {
            AAFieldKey v70 = "Invalid input header";
            __int16 v71 = 367;
            goto LABEL_132;
          }
          AAFieldKey v65 = FieldKey;
          if ((AAHeaderSetFieldUInt(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v65, v76) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          AAFieldKey v70 = "inserting header field";
          __int16 v71 = 368;
          break;
        case 2:
          if (AAHeaderGetFieldString(header, v30, *(void *)(a1 + 96), *(char **)(a1 + 104), &offset) < 0)
          {
            AAFieldKey v70 = "Invalid input header";
            __int16 v71 = 371;
            goto LABEL_132;
          }
          AAFieldKey v66 = FieldKey;
          if ((AAHeaderSetFieldString(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v66, *(const char **)(a1 + 104), offset) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          AAFieldKey v70 = "inserting header field";
          __int16 v71 = 372;
          goto LABEL_132;
        case 3:
          if (AAHeaderGetFieldHash(header, v30, *(void *)(a1 + 96), &hash_function, *(uint8_t **)(a1 + 104)) < 0)
          {
            AAFieldKey v70 = "Invalid input header";
            __int16 v71 = 378;
            goto LABEL_132;
          }
          AAFieldKey v67 = FieldKey;
          if ((AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v67, hash_function, *(const uint8_t **)(a1 + 104)) & 0x80000000) == 0)goto LABEL_86; {
          AAFieldKey v70 = "inserting header field";
          }
          __int16 v71 = 379;
          goto LABEL_132;
        case 4:
          if (AAHeaderGetFieldTimespec(header, v30, &size) < 0)
          {
            AAFieldKey v70 = "Invalid input header";
            __int16 v71 = 382;
            goto LABEL_132;
          }
          AAFieldKey v68 = FieldKey;
          if ((AAHeaderSetFieldTimespec(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v68, &size) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          AAFieldKey v70 = "inserting header field";
          __int16 v71 = 383;
          goto LABEL_132;
        case 5:
          if (AAHeaderGetFieldBlob(header, v30, &v78, &v77) < 0)
          {
            AAFieldKey v70 = "Invalid input header";
            __int16 v71 = 363;
            goto LABEL_132;
          }
          AAFieldKey v69 = FieldKey;
          if ((AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), 0xFFFFFFFF, v69, v78) & 0x80000000) == 0) {
            goto LABEL_86;
          }
          AAFieldKey v70 = "inserting header field";
          __int16 v71 = 364;
          goto LABEL_132;
        default:
          AAFieldKey v70 = "Invalid header field type";
          __int16 v71 = 385;
          goto LABEL_132;
      }
      goto LABEL_132;
    }
LABEL_86:
    ++v30;
  }
  while (v29 != v30);
  if (v73 && (sendHeader(a1) & 0x80000000) != 0)
  {
    AAFieldKey v70 = "sending header";
    __int16 v71 = 392;
    goto LABEL_132;
  }
LABEL_108:
  *(_DWORD *)(a1 + 76) = 0;
  if ((convertStreamToNextNonEmptyBlob(a1, v24, v25, v26, v27, v28, v20, v21) & 0x80000000) != 0)
  {
    AAFieldKey v70 = "iterating to next blob";
    __int16 v71 = 396;
    goto LABEL_132;
  }
  if (*(_DWORD *)(a1 + 76) >= *(_DWORD *)(a1 + 80) && (convertStreamEndEntry(a1) & 0x80000000) != 0)
  {
    AAFieldKey v70 = "finishing entry";
    __int16 v71 = 399;
    goto LABEL_132;
  }
  return 0;
}

uint64_t convertStreamWriteBlob(uint64_t a1, uint64_t a2, void *__src, rsize_t __smax, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 48)) {
    return 0;
  }
  uint64_t result = 0;
  if (__smax && !*(_DWORD *)(a1 + 52))
  {
    unsigned int v11 = *(_DWORD *)(a1 + 76);
    if (v11 >= *(_DWORD *)(a1 + 80))
    {
      int v14 = "invalid state";
      __int16 v15 = 414;
      goto LABEL_9;
    }
    uint64_t v12 = *(void *)(a1 + 88);
    int v13 = *(_DWORD *)(v12 + 24 * v11);
    if (((v13 ^ a2) & 0xFFFFFF) != 0)
    {
      int v14 = "invalid state";
      __int16 v15 = 416;
      goto LABEL_9;
    }
    v17.uint64_t ikey = a2;
    if (!*(_DWORD *)(a1 + 68))
    {
      if ((convertStreamBeginBlob(a1, (AAFieldKey)a2, *(void *)(v12 + 24 * v11 + 8)) & 0x80000000) != 0)
      {
        int v14 = "starting blob";
        __int16 v15 = 422;
        goto LABEL_9;
      }
      *(_DWORD *)(a1 + 68) = 1;
    }
    if ((*(void *)&v13 & 0xFFFFFFLL) != 0x544144) {
      goto LABEL_30;
    }
    char v18 = *(unsigned char *)(a1 + 136);
    if ((v18 & 2) != 0)
    {
      CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 160), __src, __smax);
      char v18 = *(unsigned char *)(a1 + 136);
      if ((v18 & 4) == 0)
      {
LABEL_19:
        if ((v18 & 8) == 0) {
          goto LABEL_20;
        }
        goto LABEL_26;
      }
    }
    else if ((*(unsigned char *)(a1 + 136) & 4) == 0)
    {
      goto LABEL_19;
    }
    CC_SHA256_Update((CC_SHA256_CTX *)(a1 + 256), __src, __smax);
    char v18 = *(unsigned char *)(a1 + 136);
    if ((v18 & 8) == 0)
    {
LABEL_20:
      if ((v18 & 0x10) == 0) {
        goto LABEL_21;
      }
      goto LABEL_27;
    }
LABEL_26:
    CC_SHA384_Update((CC_SHA512_CTX *)(a1 + 360), __src, __smax);
    char v18 = *(unsigned char *)(a1 + 136);
    if ((v18 & 0x10) == 0)
    {
LABEL_21:
      if ((v18 & 1) == 0) {
        goto LABEL_22;
      }
      goto LABEL_28;
    }
LABEL_27:
    CC_SHA512_Update((CC_SHA512_CTX *)(a1 + 568), __src, __smax);
    char v18 = *(unsigned char *)(a1 + 136);
    if ((v18 & 1) == 0)
    {
LABEL_22:
      if ((v18 & 0x20) == 0) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }
LABEL_28:
    CC_CKSUM_Update(a1 + 144, (unsigned __int8 *)__src, __smax);
    if ((*(unsigned char *)(a1 + 136) & 0x20) == 0)
    {
LABEL_30:
      if (*(_DWORD *)(a1 + 72))
      {
        if (*(_DWORD *)(a1 + 64))
        {
          AAFieldKey v19 = v17;
          if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v19, __src, __smax) < 0)
          {
            int v14 = "sending blob data";
            __int16 v15 = 449;
            goto LABEL_9;
          }
          goto LABEL_33;
        }
        uint64_t v28 = (void *)(a1 + 112);
        uint64_t v27 = *(void *)(a1 + 112);
        BOOL v29 = __CFADD__(v27, __smax);
        unint64_t v30 = v27 + __smax;
        if (v29 || (v30 & 0x8000000000000000) != 0) {
          goto LABEL_66;
        }
        size_t v31 = *(void *)(a1 + 120);
        if (v31 < v30)
        {
          do
          {
            while (!v31)
            {
              size_t v31 = 0x4000;
              if (v30 <= 0x4000)
              {
                int v33 = (void **)(a1 + 128);
                size_t v31 = 0x4000;
                goto LABEL_56;
              }
            }
            size_t v32 = v31 >> 1;
            if ((v31 & (v31 >> 1)) != 0) {
              size_t v32 = v31 & (v31 >> 1);
            }
            v31 += v32;
          }
          while (v31 < v30);
          int v33 = (void **)(a1 + 128);
          if (v31 >= 0x2000000001)
          {
            *__error() = 12;
            goto LABEL_65;
          }
LABEL_56:
          uint64_t v34 = *v33;
          uint64_t v35 = realloc(*v33, v31);
          if (v35)
          {
            *(void *)(a1 + 120) = v31;
            *(void *)(a1 + 128) = v35;
            goto LABEL_58;
          }
          free(v34);
LABEL_65:
          void *v33 = 0;
          void *v28 = 0;
          *(void *)(a1 + 120) = 0;
          goto LABEL_66;
        }
LABEL_58:
        uint64_t v36 = *(void *)(a1 + 128);
        if (__src)
        {
          memcpy((void *)(v36 + *v28), __src, __smax);
        }
        else if (v36)
        {
          memset_s((void *)(v36 + *v28), __smax, 0, __smax);
        }
        *v28 += __smax;
        if ((__smax & 0x8000000000000000) != 0)
        {
LABEL_66:
          int v14 = "accumulating blob data";
          __int16 v15 = 445;
          goto LABEL_9;
        }
      }
LABEL_33:
      uint64_t v20 = v12 + 24 * v11;
      rsize_t v21 = *(void *)(v20 + 8) - __smax;
      *(void *)(v20 + 8) = v21;
      if (v21) {
        return 0;
      }
      if ((convertStreamEndBlob(a1, a2, (uint64_t)__src, __smax, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        int v14 = "finishing blob";
        __int16 v15 = 457;
        goto LABEL_9;
      }
      *(_DWORD *)(a1 + 68) = 0;
      ++*(_DWORD *)(a1 + 76);
      if ((convertStreamToNextNonEmptyBlob(a1, v22, v23, v24, v25, v26, a7, a8) & 0x80000000) != 0)
      {
        int v14 = "iterating to next blob";
        __int16 v15 = 461;
        goto LABEL_9;
      }
      if (*(_DWORD *)(a1 + 76) < *(_DWORD *)(a1 + 80) || (convertStreamEndEntry(a1) & 0x80000000) == 0) {
        return 0;
      }
      int v14 = "finishing entry";
      __int16 v15 = 465;
LABEL_9:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamWriteBlob", v15, 111, 0, v14, a7, a8, v37);
      if (!*(_DWORD *)(a1 + 48))
      {
        *(_DWORD *)(a1 + 48) = 1;
        AAArchiveStreamCancel(*(AAArchiveStream *)a1);
      }
      return 0xFFFFFFFFLL;
    }
LABEL_29:
    if (OECCStreamWrite(*(void *)(a1 + 776), (char *)__src, __smax, __smax, a5, a6, a7, a8) != __smax)
    {
      int v14 = "updating YEC field";
      __int16 v15 = 436;
      goto LABEL_9;
    }
    goto LABEL_30;
  }
  return result;
}

void convertStreamAbort(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = 1;
    AAArchiveStreamCancel(*(AAArchiveStream *)a1);
  }
}

uint64_t sendHeader(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 48)) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(a1 + 64))
  {
    if (AAArchiveStreamWriteHeader(*(AAArchiveStream *)a1, *(AAHeader *)(a1 + 56)) < 0)
    {
      uint64_t v12 = "Encoding failed";
      __int16 v13 = 56;
    }
    else
    {
      unint64_t v5 = 0;
      *(_DWORD *)(a1 + 64) = 1;
      unint64_t v6 = *(void *)(a1 + 112);
      uint64_t v7 = *(void *)(a1 + 128);
      while (1)
      {
        if (v5 >= v6)
        {
          uint64_t result = 0;
          *(void *)(a1 + 112) = 0;
          return result;
        }
        unint64_t v8 = v5 + 24;
        if (v5 + 24 > v6)
        {
          uint64_t v12 = "Invalid payload";
          __int16 v13 = 66;
          goto LABEL_16;
        }
        uint64_t v9 = (AAFieldKey *)(v7 + v5);
        size_t v10 = *(void *)(v7 + v5 + 8);
        unint64_t v5 = v10 + v8;
        if (v10 + v8 > v6) {
          break;
        }
        AAFieldKey v11 = *v9;
        if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v11, (const void *)(v7 + v8), v10) < 0)
        {
          uint64_t v12 = "Blob encoding failed";
          __int16 v13 = 70;
          goto LABEL_16;
        }
      }
      uint64_t v12 = "Invalid payload";
      __int16 v13 = 69;
    }
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"sendHeader", v13, 111, 0, v12, v3, v4, v14);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t convertStreamToNextNonEmptyBlob(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 76);
  if (v8 >= *(_DWORD *)(a1 + 80)) {
    return 0;
  }
  int v10 = 1;
  do
  {
    uint64_t v11 = *(void *)(a1 + 88);
    if (*(void *)(v11 + 24 * v8 + 8)) {
      break;
    }
    AAFieldKey v12 = *(AAFieldKey *)(v11 + 24 * v8);
    int v13 = convertStreamBeginBlob(a1, v12, 0);
    if ((int)(convertStreamEndBlob(a1, v14, v15, v16, v17, v18, v19, v20) | v13) < 0) {
      int v10 = 0;
    }
    unsigned int v21 = *(_DWORD *)(a1 + 80);
    unsigned int v8 = *(_DWORD *)(a1 + 76) + 1;
    *(_DWORD *)(a1 + 76) = v8;
  }
  while (v8 < v21);
  if (v10) {
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamToNextNonEmptyBlob", 204, 111, 0, "iterating to next non-empty blob", a7, a8, v23);
  return 0xFFFFFFFFLL;
}

uint64_t convertStreamEndEntry(uint64_t a1)
{
  int v4 = sendHeader(a1);
  if (v4 < 0) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamEndEntry", 182, 111, 0, "send header", v2, v3, v6);
  }
  AAHeaderDestroy(*(AAHeader *)(a1 + 56));
  *(void *)(a1 + 56) = 0;
  OECCStreamDestroy(*(void ***)(a1 + 776));
  *(void *)(a1 + 776) = 0;
  free(*(void **)(a1 + 128));
  memset_s((void *)(a1 + 112), 0x18uLL, 0, 0x18uLL);
  return (v4 >> 31);
}

uint64_t convertStreamBeginBlob(uint64_t a1, AAFieldKey a2, uint64_t a3)
{
  int KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), a2);
  *(_DWORD *)(a1 + 72) = KeyIndex >= 0;
  if (KeyIndex < 0 || *(_DWORD *)(a1 + 64))
  {
LABEL_3:
    int v9 = 1;
    goto LABEL_40;
  }
  uint64_t v11 = (void *)(a1 + 112);
  unint64_t v10 = *(void *)(a1 + 112);
  unint64_t v12 = a3 + v10 + 24;
  if ((v12 & 0x8000000000000000) != 0) {
    goto LABEL_29;
  }
  size_t v13 = *(void *)(a1 + 120);
  if (v13 < v12)
  {
    do
    {
      while (!v13)
      {
        size_t v13 = 0x4000;
        if (v12 <= 0x4000)
        {
          uint64_t v15 = (void **)(a1 + 128);
          size_t v13 = 0x4000;
          goto LABEL_15;
        }
      }
      size_t v14 = v13 >> 1;
      if ((v13 & (v13 >> 1)) != 0) {
        size_t v14 = v13 & (v13 >> 1);
      }
      v13 += v14;
    }
    while (v13 < v12);
    uint64_t v15 = (void **)(a1 + 128);
    if (v13 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_28;
    }
LABEL_15:
    uint64_t v16 = *v15;
    uint64_t v17 = realloc(*v15, v13);
    if (v17)
    {
      *(void *)(a1 + 120) = v13;
      *(void *)(a1 + 128) = v17;
      unint64_t v10 = *(void *)(a1 + 112);
      goto LABEL_17;
    }
    free(v16);
LABEL_28:
    *uint64_t v15 = 0;
    *uint64_t v11 = 0;
    *(void *)(a1 + 120) = 0;
LABEL_29:
    unsigned int v21 = "allocating blob buffer";
    __int16 v22 = 87;
    goto LABEL_39;
  }
LABEL_17:
  unint64_t v18 = v10 + 24;
  if (v10 < 0xFFFFFFFFFFFFFFE8 && (v18 & 0x8000000000000000) == 0)
  {
    if (v13 >= v18)
    {
      char v23 = *(char **)(a1 + 128);
LABEL_35:
      uint64_t v25 = &v23[v10];
      *(AAFieldKey *)uint64_t v25 = a2;
      *((_DWORD *)v25 + 1) = 0;
      *((void *)v25 + 1) = a3;
      *((void *)v25 + 2) = 0;
      *v11 += 24;
      goto LABEL_3;
    }
    do
    {
      while (!v13)
      {
        size_t v13 = 0x4000;
        if (v18 <= 0x4000)
        {
          uint64_t v20 = (void **)(a1 + 128);
          size_t v13 = 0x4000;
          goto LABEL_33;
        }
      }
      size_t v19 = v13 >> 1;
      if ((v13 & (v13 >> 1)) != 0) {
        size_t v19 = v13 & (v13 >> 1);
      }
      v13 += v19;
    }
    while (v13 < v18);
    uint64_t v20 = (void **)(a1 + 128);
    if (v13 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_37;
    }
LABEL_33:
    uint64_t v24 = *v20;
    char v23 = (char *)realloc(*v20, v13);
    if (v23)
    {
      *(void *)(a1 + 120) = v13;
      *(void *)(a1 + 128) = v23;
      unint64_t v10 = *(void *)(a1 + 112);
      goto LABEL_35;
    }
    free(v24);
LABEL_37:
    *uint64_t v20 = 0;
    *uint64_t v11 = 0;
    *(void *)(a1 + 120) = 0;
  }
  unsigned int v21 = "accumulating blob data";
  __int16 v22 = 91;
LABEL_39:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamBeginBlob", v22, 111, 0, v21, v7, v8, v27);
  int v9 = 0;
LABEL_40:
  if (v9) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t convertStreamEndBlob(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if ((*(_DWORD *)(*(void *)(a1 + 88) + 24 * *(unsigned int *)(a1 + 76)) & 0xFFFFFF) != 0x544144) {
    goto LABEL_31;
  }
  int v9 = *(_DWORD *)(a1 + 136);
  if (!v9)
  {
LABEL_28:
    if ((sendHeader(a1) & 0x80000000) != 0)
    {
      unint64_t v10 = "send header";
      __int16 v11 = 162;
      goto LABEL_46;
    }
    if ((*(unsigned char *)(a1 + 136) & 0x20) != 0)
    {
      size_t DataSize = OECCStreamGetDataSize(*(void *)(a1 + 776));
      uint64_t DataPtr = (const void *)OECCStreamGetDataPtr(*(void *)(a1 + 776));
      v33.uint64_t ikey = 4408665;
      if (AAArchiveStreamWriteBlob(*(AAArchiveStream *)a1, v33, DataPtr, DataSize) < 0)
      {
        unint64_t v10 = "sending blob data";
        __int16 v11 = 169;
        goto LABEL_46;
      }
    }
LABEL_31:
    int v34 = 1;
    goto LABEL_47;
  }
  if (!*(_DWORD *)(a1 + 64))
  {
    if ((v9 & 2) != 0)
    {
      CC_SHA1_Deprecated_Final((unsigned __int8 *)md, (CC_SHA1_CTX *)(a1 + 160));
      v12.uint64_t ikey = 3229779;
      uint32_t KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v12);
      if ((KeyIndex & 0x80000000) != 0)
      {
        unint64_t v10 = "Missing field in new header";
        __int16 v11 = 117;
        goto LABEL_46;
      }
      v14.uint64_t ikey = 3229779;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), KeyIndex, v14, 2u, (const uint8_t *)md) < 0)
      {
        unint64_t v10 = "updating new header field";
        __int16 v11 = 118;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(unsigned char *)(a1 + 136);
    }
    if ((v9 & 4) != 0)
    {
      CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(a1 + 256));
      v15.uint64_t ikey = 3295315;
      uint32_t v16 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v15);
      if ((v16 & 0x80000000) != 0)
      {
        unint64_t v10 = "Missing field in new header";
        __int16 v11 = 125;
        goto LABEL_46;
      }
      v17.uint64_t ikey = 3295315;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v16, v17, 3u, (const uint8_t *)md) < 0)
      {
        unint64_t v10 = "updating new header field";
        __int16 v11 = 126;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(unsigned char *)(a1 + 136);
    }
    if ((v9 & 8) != 0)
    {
      CC_SHA384_Final((unsigned __int8 *)md, (CC_SHA512_CTX *)(a1 + 360));
      v18.uint64_t ikey = 3360851;
      uint32_t v19 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v18);
      if ((v19 & 0x80000000) != 0)
      {
        unint64_t v10 = "Missing field in new header";
        __int16 v11 = 133;
        goto LABEL_46;
      }
      v20.uint64_t ikey = 3360851;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v19, v20, 4u, (const uint8_t *)md) < 0)
      {
        unint64_t v10 = "updating new header field";
        __int16 v11 = 134;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(unsigned char *)(a1 + 136);
    }
    if ((v9 & 0x10) != 0)
    {
      CC_SHA512_Final((unsigned __int8 *)md, (CC_SHA512_CTX *)(a1 + 568));
      v21.uint64_t ikey = 3491923;
      uint32_t v22 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v21);
      if ((v22 & 0x80000000) != 0)
      {
        unint64_t v10 = "Missing field in new header";
        __int16 v11 = 141;
        goto LABEL_46;
      }
      v23.uint64_t ikey = 3491923;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v22, v23, 5u, (const uint8_t *)md) < 0)
      {
        unint64_t v10 = "updating new header field";
        __int16 v11 = 142;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(unsigned char *)(a1 + 136);
    }
    if (v9)
    {
      CC_CKSUM_Final(md, a1 + 144);
      v24.uint64_t ikey = 5458755;
      uint32_t v25 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v24);
      if ((v25 & 0x80000000) != 0)
      {
        unint64_t v10 = "Missing field in new header";
        __int16 v11 = 149;
        goto LABEL_46;
      }
      v26.uint64_t ikey = 5458755;
      if (AAHeaderSetFieldHash(*(AAHeader *)(a1 + 56), v25, v26, 1u, (const uint8_t *)md) < 0)
      {
        unint64_t v10 = "updating new header field";
        __int16 v11 = 150;
        goto LABEL_46;
      }
      LOBYTE(v9) = *(unsigned char *)(a1 + 136);
    }
    if ((v9 & 0x20) != 0)
    {
      uint64_t v27 = OECCStreamGetDataSize(*(void *)(a1 + 776));
      v28.uint64_t ikey = 4408665;
      uint32_t v29 = AAHeaderGetKeyIndex(*(AAHeader *)(a1 + 56), v28);
      if ((v29 & 0x80000000) != 0)
      {
        unint64_t v10 = "Missing field in new header";
        __int16 v11 = 157;
        goto LABEL_46;
      }
      v30.uint64_t ikey = 4408665;
      if (AAHeaderSetFieldBlob(*(AAHeader *)(a1 + 56), v29, v30, v27) < 0)
      {
        unint64_t v10 = "updating new header field";
        __int16 v11 = 158;
        goto LABEL_46;
      }
    }
    goto LABEL_28;
  }
  unint64_t v10 = "Header has already been sent";
  __int16 v11 = 111;
LABEL_46:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAConvertArchiveOutputStream.c", (uint64_t)"convertStreamEndBlob", v11, 111, 0, v10, a7, a8, v36);
  int v34 = 0;
LABEL_47:
  if (v34) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void *aaInPlaceStreamOpen(AAByteStream_impl *a1)
{
  uint64_t v2 = calloc(1uLL, 0x68uLL);
  uint64_t v3 = (pthread_mutex_t *)calloc(1uLL, 0x80uLL);
  char v6 = v3;
  if (!v3 || !v2)
  {
    int v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamOpen", 237, 126, *v9, "malloc", v10, v11, v19);
    free(v2);
    if (!v6) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (!*((void *)a1 + 4) || !*((void *)a1 + 5) || !*((void *)a1 + 6) || !*((void *)a1 + 8))
  {
    uint64_t v7 = "stream not in-place compatible\n";
    __int16 v8 = 243;
    goto LABEL_12;
  }
  if (pthread_mutex_init(v3, 0))
  {
    uint64_t v7 = "mutex failed";
    __int16 v8 = 246;
LABEL_12:
    int v12 = 0;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamOpen", v8, 126, v12, v7, v4, v5, v19);
    free(v2);
LABEL_14:
    pthread_mutex_destroy(v6);
    free(*(void **)&v6[1].__opaque[32]);
LABEL_15:
    free(v6);
    return 0;
  }
  v6[1].__sig = (uint64_t)a1;
  *(void *)v6[1].__opaque = 0;
  *(void *)&v6[1].__opaque[16] = 0;
  unint64_t v14 = AAByteStreamSeek(a1, 0, 2);
  *(void *)&v6[1].__opaque[8] = v14;
  *(void *)&v6[1].__opaque[24] = 0;
  if ((v14 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = "bad input size";
    __int16 v8 = 252;
    goto LABEL_12;
  }
  *(void *)&v6[1].__opaque[40] = (v14 + 0xFFFFF) >> 20;
  if (v14 >= 0x20000000000001)
  {
    *__error() = 12;
    *(void *)&v6[1].__opaque[32] = 0;
LABEL_26:
    int v12 = *__error();
    uint64_t v7 = "malloc";
    __int16 v8 = 257;
    goto LABEL_13;
  }
  AAFieldKey v15 = (char *)calloc((v14 + 0xFFFFF) >> 20, 0x10uLL);
  *(void *)&v6[1].__opaque[32] = v15;
  if (!v15) {
    goto LABEL_26;
  }
  uint64_t v16 = *(void *)&v6[1].__opaque[40];
  if (v16)
  {
    AAFieldKey v17 = v15 + 8;
    for (uint64_t i = v16 - 1; ; --i)
    {
      *(v17 - 1) = 0;
      if (!i) {
        break;
      }
      *AAFieldKey v17 = 0x100000;
      v17 += 2;
    }
    *AAFieldKey v17 = ((*(_DWORD *)&v6[1].__opaque[8] - 1) & 0xFFFFF) + 1;
  }
  AACustomByteStreamSetData((AAByteStream)v2, v6);
  AACustomByteStreamSetPReadProc((AAByteStream)v2, (AAByteStreamPReadProc)aaInPlaceStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v2, (AAByteStreamPWriteProc)aaInPlaceStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v2, (AAByteStreamReadProc)aaInPlaceStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v2, (AAByteStreamWriteProc)aaInPlaceStreamWrite);
  AACustomByteStreamSetSeekProc((AAByteStream)v2, (AAByteStreamSeekProc)aaInPlaceStreamSeek);
  AACustomByteStreamSetCloseProc((AAByteStream)v2, (AAByteStreamCloseProc)aaInPlaceStreamClose);
  AACustomByteStreamSetCancelProc((AAByteStream)v2, (AAByteStreamCancelProc)aaInPlaceStreamCancel);
  return v2;
}

uint64_t aaInPlaceStreamPRead(uint64_t a1, void *a2, size_t a3, uint64_t a4)
{
  return blockReader(a1, a2, a3, a4, 0);
}

uint64_t aaInPlaceStreamPWrite(uint64_t a1, const void *a2, size_t a3, uint64_t a4)
{
  return blockWriter(a1, a2, a3, a4, 0);
}

uint64_t aaInPlaceStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return blockReader(a1, a2, a3, 0, 1);
}

uint64_t aaInPlaceStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  return blockWriter(a1, a2, a3, 0, 1);
}

uint64_t aaInPlaceStreamSeek(uint64_t a1, off_t a2, int a3)
{
  if (pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamSeek", 176, 126, 0, "MutexLock", v6, v7, v11);
    *(_DWORD *)(a1 + 120) = 1;
    return -1;
  }
  if (*(_DWORD *)(a1 + 120))
  {
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return -1;
  }
  off_t v10 = AAByteStreamSeek(*(AAByteStream *)(a1 + 64), a2, a3);
  off_t v8 = v10;
  if ((v10 & 0x8000000000000000) == 0)
  {
    *(void *)(a1 + 88) = v10;
    *(void *)(a1 + 72) = v10;
  }
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return v8;
}

uint64_t aaInPlaceStreamClose(pthread_mutex_t *a1)
{
  if (!a1) {
    return 0;
  }
  if (!*(_DWORD *)&a1[1].__opaque[48]
    && *(void *)&a1[1].__opaque[24] < *(void *)&a1[1].__opaque[8]
    && (AAByteStreamTruncate((void *)a1[1].__sig) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamClose", 210, 126, 0, "truncate failed", v2, v3, v10);
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v4 = 0;
  }
  pthread_mutex_destroy(a1);
  uint64_t v5 = *(char **)&a1[1].__opaque[32];
  if (v5)
  {
    if (*(void *)&a1[1].__opaque[40])
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      do
      {
        free(*(void **)&v5[v6]);
        uint64_t v5 = *(char **)&a1[1].__opaque[32];
        unint64_t v8 = *(void *)&a1[1].__opaque[40];
        *(void *)&v5[v6] = 0;
        ++v7;
        v6 += 16;
      }
      while (v7 < v8);
    }
    free(v5);
  }
  free(a1);
  return v4;
}

uint64_t aaInPlaceStreamCancel(uint64_t a1)
{
  if (pthread_mutex_lock((pthread_mutex_t *)a1)) {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"aaInPlaceStreamCancel", 191, 126, 0, "MutexLock", v2, v3, v5);
  }
  if (!*(_DWORD *)(a1 + 120))
  {
    *(_DWORD *)(a1 + 120) = 1;
    AAByteStreamCancel(*(AAByteStream *)(a1 + 64));
  }

  return pthread_mutex_unlock((pthread_mutex_t *)a1);
}

uint64_t blockReader(uint64_t a1, void *a2, size_t a3, uint64_t a4, int a5)
{
  if (!pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    if (*(_DWORD *)(a1 + 120))
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return -1;
    }
    if (a5)
    {
      a4 = *(void *)(a1 + 72);
      if (!a3) {
        goto LABEL_24;
      }
    }
    else
    {
      *(void *)(a1 + 72) = a4;
      if (!a3) {
        goto LABEL_24;
      }
    }
    if (*(void *)(a1 + 80) <= a4)
    {
      a3 = 0;
    }
    else
    {
      size_t v13 = blockGetFromCache(a1, a4);
      if (v13)
      {
        uint64_t v16 = v13;
        unint64_t v17 = (unint64_t)v13[1];
        if (v17)
        {
          if (0x100000 - (a4 & 0xFFFFFuLL) < v17) {
            unint64_t v17 = 0x100000 - (a4 & 0xFFFFF);
          }
          if (v17 < a3) {
            a3 = v17;
          }
          memcpy(a2, &(*v13)[a4 & 0xFFFFF], a3);
          size_t v18 = (size_t)&v16[1][-a3];
          v16[1] = (char *)v18;
          if (!v18)
          {
            free(*v16);
            *uint64_t v16 = 0;
          }
          *(void *)(a1 + 72) += a3;
          goto LABEL_24;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockPRead", 72, 126, 0, "block already consumed", v14, v15, v19);
      }
      *(_DWORD *)(a1 + 120) = 1;
      a3 = -1;
    }
LABEL_24:
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return a3;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockReader", 111, 126, 0, "MutexLock", v10, v11, v19);
  *(_DWORD *)(a1 + 120) = 1;
  return -1;
}

char **blockGetFromCache(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(*(void *)(a1 + 104) + 16 * (a2 >> 20));
  uint64_t v3 = (char **)v2;
  if (!*v2)
  {
    size_t v6 = v2[1];
    char v5 = v2 + 1;
    size_t v4 = v6;
    if (v6)
    {
      if (v4 >= 0x2000000001)
      {
        *__error() = 12;
        *uint64_t v3 = 0;
LABEL_12:
        int v17 = *__error();
        size_t v18 = "malloc";
        __int16 v19 = 52;
LABEL_13:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockGetFromCache", v19, 126, v17, v18, v10, v11, v21);
        return 0;
      }
      int v9 = (char *)malloc(v4);
      *uint64_t v3 = v9;
      if (!v9) {
        goto LABEL_12;
      }
      uint64_t v12 = *(void *)(a1 + 64);
      if (*(void *)(v12 + 32))
      {
        size_t v13 = v9;
        uint64_t v14 = 0;
        unint64_t v15 = a2 & 0xFFFFFFFFFFF00000;
        while (1)
        {
          uint64_t v16 = (*(uint64_t (**)(void, char *, size_t, unint64_t))(v12 + 32))(*(void *)v12, v13, v4, v15);
          if (v16 < 0) {
            break;
          }
          if (v16)
          {
            v13 += v16;
            v14 += v16;
            v15 += v16;
            v4 -= v16;
            if (v4) {
              continue;
            }
          }
          goto LABEL_17;
        }
        uint64_t v14 = v16;
LABEL_17:
        size_t v4 = *v5;
      }
      else
      {
        uint64_t v14 = -1;
      }
      if (v14 != v4)
      {
        size_t v18 = "stream read error";
        __int16 v19 = 58;
        int v17 = 0;
        goto LABEL_13;
      }
    }
  }
  return v3;
}

uint64_t blockWriter(uint64_t a1, const void *a2, size_t a3, uint64_t a4, int a5)
{
  if (!pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    if (*(_DWORD *)(a1 + 120))
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return -1;
    }
    if (a5)
    {
      a4 = *(void *)(a1 + 88);
      if (a3) {
        goto LABEL_9;
      }
    }
    else
    {
      *(void *)(a1 + 88) = a4;
      if (a3)
      {
LABEL_9:
        if (*(void *)(a1 + 80) > a4)
        {
          if (!blockGetFromCache(a1, a4))
          {
            uint64_t v12 = -1;
LABEL_20:
            *(_DWORD *)(a1 + 120) = 1;
            goto LABEL_21;
          }
          if (0x100000 - (a4 & 0xFFFFFuLL) < a3) {
            a3 = 0x100000 - (a4 & 0xFFFFF);
          }
        }
        ssize_t v14 = AAByteStreamPWrite(*(AAByteStream *)(a1 + 64), a2, a3, a4);
        uint64_t v12 = v14;
        if ((v14 & 0x8000000000000000) == 0)
        {
          if (v14)
          {
            ssize_t v15 = *(void *)(a1 + 96);
            ssize_t v16 = *(void *)(a1 + 88) + v14;
            *(void *)(a1 + 88) = v16;
            if (v15 < v16) {
              *(void *)(a1 + 96) = v16;
            }
          }
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }
    uint64_t v12 = 0;
LABEL_21:
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    return v12;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAInPlaceStream.c", (uint64_t)"blockWriter", 131, 126, 0, "MutexLock", v10, v11, v17);
  *(_DWORD *)(a1 + 120) = 1;
  return -1;
}

uint64_t io_hint_static_content(unsigned int **a1)
{
  int FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    size_t v6 = "file not open";
    __int16 v7 = 63;
  }
  else
  {
    char v8 = 1;
    if (fcntl(FD, 68) != -1) {
      return 0;
    }
    size_t v6 = "static content hint failed";
    __int16 v7 = 64;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_hint_static_content", v7, 137, v6, v2, v3, v4, v8);
  return 0xFFFFFFFFLL;
}

uint64_t io_preallocate(unsigned int **a1, unint64_t a2)
{
  getRealTime();
  int FD = aaFileStreamGetFD(a1);
  memset(&v25, 0, sizeof(v25));
  if (FD < 0)
  {
    ssize_t v15 = "file not open";
    __int16 v16 = 84;
LABEL_12:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", v16, 137, v15, v5, v6, v7, v21);
    LOBYTE(v10) = 0;
    goto LABEL_13;
  }
  int v8 = FD;
  if (fstat(FD, &v25) || v25.st_size)
  {
    ssize_t v15 = "file not empty";
    __int16 v16 = 85;
    goto LABEL_12;
  }
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 88, 137, "preallocating %llu B", v5, v6, v7, a2);
  if (!a2)
  {
    uint64_t v14 = 0;
    LOBYTE(v10) = 0;
    goto LABEL_14;
  }
  int v9 = 0;
  unint64_t v10 = 0;
  while (1)
  {
    v23[0] = 0x300000002;
    v23[1] = 0;
    v23[2] = a2 - v10;
    uint64_t v24 = 0;
    if (fcntl(v8, 42, v23) == -1 || v24 <= 0) {
      break;
    }
    v10 += v24;
    ++v9;
    if (v10 >= a2)
    {
      uint64_t v14 = 0;
      goto LABEL_14;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 99, 137, "preallocation failed", v11, v12, v13, v22);
LABEL_13:
  uint64_t v14 = 0xFFFFFFFFLL;
LABEL_14:
  getRealTime();
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 110, 137, "preallocation %llu/%llu B took %0.2f seconds (# of calls=%i)", v17, v18, v19, v10);
  return v14;
}

uint64_t io_set_nocache(unsigned int **a1)
{
  int FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    uint64_t v5 = "aaFileStreamGetFD";
    __int16 v6 = 126;
    int v7 = 0;
  }
  else
  {
    char v8 = 1;
    if (fcntl(FD, 48) != -1) {
      return 0;
    }
    int v7 = *__error();
    uint64_t v5 = "fcntl";
    __int16 v6 = 127;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_set_nocache", v6, 137, v7, v5, v2, v3, v8);
  return 0xFFFFFFFFLL;
}

uint64_t **aaSegmentStreamOpen(void *a1, void *a2)
{
  uint64_t v3 = (uint64_t **)SegmentStreamCreate(a1, (uint64_t)a2);
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *v3;
    uint64_t v12 = pc_array_indirect_sort(a2[267], compare_extents_by_position);
    if (v12)
    {
      unint64_t v13 = 0;
      unint64_t v14 = 0;
      unint64_t v15 = a2[269];
      do
      {
        if (v13 >= v15)
        {
          unint64_t v17 = 0;
          __int16 v16 = a2 + 265;
        }
        else
        {
          __int16 v16 = (unint64_t *)v12[v13];
          unint64_t v17 = v16[1];
        }
        unint64_t v18 = *v16;
        BOOL v19 = *v16 >= v14;
        unint64_t v20 = *v16 - v14;
        if (v20 != 0 && v19)
        {
          uint64_t v40 = v5[397];
          unint64_t v41 = v20;
          unint64_t v42 = v14;
          int v43 = 0;
          char v44 = 0;
          v5[397] = v40 + v20;
          char v21 = pc_array_append(v5[395], &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v21;
          if (!v21)
          {
            char v37 = "segment_add";
            __int16 v38 = 476;
            goto LABEL_28;
          }
          unint64_t v15 = a2[269];
        }
        unint64_t v14 = v18 + v17;
        ++v13;
      }
      while (v13 <= v15);
      uint64_t v22 = v5[397];
      a2[258] = v22;
      unint64_t v23 = a2[270];
      if (v23)
      {
        uint64_t v24 = 0;
        while (1)
        {
          uint64_t v25 = a2[267];
          uint64_t v26 = a2[268] + 440 * v24;
          *(void *)(v26 + 32) = 0;
          uint64_t v27 = (void *)(v26 + 32);
          v27[1] = v5[397];
          if (v27[49]) {
            break;
          }
LABEL_19:
          if (++v24 >= v23)
          {
            uint64_t v22 = v5[397];
            goto LABEL_21;
          }
        }
        uint64_t v28 = 0;
        uint32_t v29 = (void *)v5[395];
        AAFieldKey v30 = (uint64_t *)(v25 + 16 * v27[48] + 8);
        while (1)
        {
          unint64_t v32 = *(v30 - 1);
          unint64_t v31 = *v30;
          uint64_t v40 = v5[397];
          unint64_t v41 = v31;
          unint64_t v42 = v32;
          int v43 = 0;
          char v44 = 0;
          v5[397] = v40 + v31;
          uint32_t v29 = pc_array_append((uint64_t)v29, &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v29;
          if (!v29) {
            break;
          }
          uint64_t v33 = *v30;
          v30 += 2;
          *v27 += v33;
          if ((unint64_t)++v28 >= v27[49])
          {
            unint64_t v23 = a2[270];
            goto LABEL_19;
          }
        }
        char v37 = "segment_add";
        __int16 v38 = 500;
      }
      else
      {
LABEL_21:
        v5[396] = *(void *)(v5[395] - 64);
        if (v22 == a2[265])
        {
          free(v12);
          return v4;
        }
        char v37 = "bad image";
        __int16 v38 = 507;
      }
    }
    else
    {
      char v37 = "pc_array_indirect_sort";
      __int16 v38 = 465;
    }
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", v38, 137, 0, v37, v10, v11, v40);
  }
  else
  {
    int v34 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", 457, 137, *v34, "aaSegmentStreamOpen", v35, v36, v40);
    uint64_t v12 = 0;
    uint64_t v5 = 0;
  }
  free(v12);
  free(v4);
  SegmentStreamClose((uint64_t)v5);
  return 0;
}

void *SegmentStreamCreate(void *a1, uint64_t a2)
{
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  uint64_t v5 = calloc(1uLL, 0xC78uLL);
  uint64_t v8 = v5;
  if (!v4 || !v5)
  {
    int v9 = *__error();
    uint64_t v10 = "malloc";
    __int16 v11 = 416;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamCreate", v11, 137, v9, v10, v6, v7, v13);
    free(v4);
    SegmentStreamClose((uint64_t)v8);
    return 0;
  }
  if (!a1[4] || !a1[5])
  {
    uint64_t v10 = "stream not compatible";
    __int16 v11 = 417;
    int v9 = 0;
    goto LABEL_9;
  }
  void *v5 = a1;
  v5[1] = a2;
  v5[395] = pc_array_init(29);
  AACustomByteStreamSetData((AAByteStream)v4, v8);
  AACustomByteStreamSetPReadProc((AAByteStream)v4, (AAByteStreamPReadProc)SegmentStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v4, (AAByteStreamPWriteProc)SegmentStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v4, (AAByteStreamCancelProc)SegmentStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v4, (AAByteStreamCloseProc)SegmentStreamClose);
  if (a1[11]) {
    v4[11] = SegmentStreamSimulate;
  }
  return v4;
}

uint64_t SegmentStreamClose(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 3152))
    {
      for (uint64_t i = 16; i != 3088; i += 24)
        free(*(void **)(a1 + i));
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 3088));
    }
    pc_array_free(*(void *)(a1 + 3160));
    free((void *)a1);
  }
  return 0;
}

uint64_t *aaForkInputStreamOpen(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a2 + 2128) & 8) == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 538, 137, 0, "no chunk info", a7, a8, v58);
    uint64_t v8 = 0;
LABEL_13:
    uint64_t v13 = 0;
    goto LABEL_16;
  }
  uint64_t v10 = (void *)a2;
  uint64_t v12 = SegmentStreamCreate(a1, a2);
  uint64_t v8 = v12;
  if (!v12)
  {
    uint64_t v26 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 542, 137, *v26, "SegmentStreamCreate", v27, v28, v58);
    goto LABEL_13;
  }
  uint64_t v13 = *v12;
  if (a1[11]) {
    *(_DWORD *)(v13 + 3184) = 1;
  }
  uint64_t v14 = 0;
  *(void *)(v13 + 3152) = 1;
  do
  {
    unint64_t v15 = malloc(0x10000uLL);
    uint64_t v16 = v13 + v14;
    *(void *)(v16 + 16) = v15;
    *(void *)(v16 + 24) = -1;
    if (!v15)
    {
      int v25 = *__error();
      unint64_t v23 = "malloc";
      __int16 v24 = 554;
      goto LABEL_15;
    }
    v14 += 24;
  }
  while (v14 != 3072);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 3088), 0))
  {
    unint64_t v23 = "MutexInit";
    __int16 v24 = 556;
    goto LABEL_11;
  }
  uint64_t v59 = v8;
  char v63 = 0;
  uint64_t v61 = v10;
  char v62 = 1;
  int v60 = a3;
  while (!v10[270])
  {
LABEL_36:
    uint64_t v8 = v59;
    if ((v62 & 1) == 0)
    {
      *(void *)(v13 + 3168) = *(void *)(*(void *)(v13 + 3160) - 64);
      v10[260] = *(void *)(v13 + 3176);
      return v8;
    }
    uint64_t v53 = *(void *)(v13 + 3176);
    v10[257] = v53;
    unint64_t v54 = v10[258];
    if (v54)
    {
      __srCC_SHA1_CTX c = v53;
      long long v67 = v54;
      int v68 = 0;
      char v69 = 0;
      *(void *)(v13 + 3176) = v54 + v53;
      AAFieldKey v55 = pc_array_append(*(void *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(void *)(v13 + 3160) = v55;
      if (!v55)
      {
        unint64_t v23 = "segment_add";
        __int16 v24 = 607;
LABEL_11:
        int v25 = 0;
LABEL_15:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v24, 137, v25, v23, v21, v22, v58);
        goto LABEL_16;
      }
      uint64_t v53 = *(void *)(v13 + 3176);
    }
    char v62 = 0;
    v10[259] = v53;
    char v63 = 1;
  }
  unint64_t v30 = 0;
  while (1)
  {
    uint64_t v65 = v10[268];
    if (a3) {
      LOBYTE(v31) = 1;
    }
    else {
      uint64_t v31 = *(void *)(v10[268] + 440 * v30 + 408);
    }
    char v64 = v31;
    if (!(v63 & 1 | ((v31 & 1) == 0))) {
      break;
    }
LABEL_33:
    if (!(v62 & 1 | ((v64 & 2) == 0)))
    {
      uint64_t v49 = *(void *)(v13 + 3176);
      uint64_t v50 = v65 + 440 * v30;
      *(void *)(v50 + 48) = v49;
      long long v51 = *(_OWORD *)(v50 + 32);
      __srCC_SHA1_CTX c = v49;
      long long v67 = v51;
      int v68 = 0;
      char v69 = 0;
      *(void *)(v13 + 3176) = v51 + v49;
      AAFieldKey v52 = pc_array_append(*(void *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(void *)(v13 + 3160) = v52;
      if (!v52)
      {
        AAFieldKey v56 = "segment_add";
        __int16 v57 = 597;
        goto LABEL_42;
      }
    }
LABEL_35:
    ++v30;
    uint64_t v10 = v61;
    a3 = v60;
    if (v30 >= v61[270]) {
      goto LABEL_36;
    }
  }
  uint64_t v32 = v65 + 440 * v30;
  if (!*(void *)(v32 + 384))
  {
    AAFieldKey v56 = "no chunks found";
    __int16 v57 = 572;
    goto LABEL_42;
  }
  uint64_t v33 = v65 + 440 * v30;
  uint64_t v35 = *(void *)(v33 + 56);
  int v34 = (unint64_t *)(v33 + 56);
  *(v34 - 1) = *(void *)(v13 + 3176);
  if (!v35) {
    goto LABEL_35;
  }
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  __int16 v38 = (void *)(v32 + 384);
  uint64_t v39 = v65 + 440 * v30;
  unint64_t v40 = *(void *)(v39 + 392);
  unint64_t v41 = (void *)(v39 + 40);
  unint64_t v42 = (char *)(v39 + 432);
  int v43 = *(void **)(v13 + 3160);
  while (1)
  {
    uint64_t v44 = *v38 + v36;
    uint64_t v45 = v40 >= 0x10000 ? 0x10000 : v40;
    uint64_t v46 = *(void *)v44 + *v41;
    int v47 = *(_DWORD *)(v44 + 8);
    char v48 = *v42;
    __srCC_SHA1_CTX c = *(void *)(v13 + 3176);
    *(void *)&long long v67 = v45;
    *((void *)&v67 + 1) = v46;
    int v68 = v47;
    char v69 = v48;
    *(void *)(v13 + 3176) = __src + v45;
    int v43 = pc_array_append((uint64_t)v43, &__src, v17, v18, v19, v20, v21, v22);
    *(void *)(v13 + 3160) = v43;
    if (!v43) {
      break;
    }
    v40 -= v45;
    ++v37;
    v36 += 12;
    if (v37 >= *v34) {
      goto LABEL_33;
    }
  }
  AAFieldKey v56 = "segment_add";
  __int16 v57 = 584;
LABEL_42:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v57, 137, 0, v56, v21, v22, v58);
  uint64_t v8 = v59;
LABEL_16:
  free(v8);
  SegmentStreamClose(v13);
  return 0;
}

AAByteStream_impl *aaIntervalInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  uint64_t v7 = calloc(1uLL, 0x20uLL);
  uint64_t v10 = v7;
  if (v6 && v7)
  {
    if (a3 >= a2)
    {
      void *v7 = a1;
      v7[1] = a2;
      v7[2] = a3 - a2;
      v7[3] = 0;
      AACustomByteStreamSetData(v6, v7);
      AACustomByteStreamSetReadProc(v6, (AAByteStreamReadProc)IntervalStreamRead);
      AACustomByteStreamSetPReadProc(v6, (AAByteStreamPReadProc)IntervalStreamPRead);
      AACustomByteStreamSetSeekProc(v6, (AAByteStreamSeekProc)IntervalStreamSeek);
      AACustomByteStreamSetCancelProc(v6, (AAByteStreamCancelProc)IntervalStreamCancel);
      AACustomByteStreamSetCloseProc(v6, (AAByteStreamCloseProc)IntervalStreamClose);
      return v6;
    }
    __int16 v11 = "bad interval";
    __int16 v12 = 703;
    int v13 = 0;
  }
  else
  {
    int v13 = *__error();
    __int16 v11 = "malloc";
    __int16 v12 = 702;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaIntervalInputStreamOpen", v12, 137, v13, v11, v8, v9, v15);
  free(v6);
  free(v10);
  return 0;
}

ssize_t IntervalStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return IntervalStreamPRead(a1, a2, a3, *(void *)(a1 + 24));
}

ssize_t IntervalStreamPRead(uint64_t a1, void *a2, size_t a3, int64_t a4)
{
  if (!a3) {
    return 0;
  }
  int64_t v5 = *(void *)(a1 + 16);
  if (v5 == a4) {
    return 0;
  }
  if (v5 < a4) {
    return -1;
  }
  if ((uint64_t)(a4 + a3) > v5) {
    a3 = v5 - a4;
  }
  ssize_t result = AAByteStreamPRead(*(AAByteStream *)a1, a2, a3, *(void *)(a1 + 8) + a4);
  if (result < 0) {
    return -1;
  }
  *(void *)(a1 + 24) += result;
  return result;
}

uint64_t IntervalStreamSeek(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = (void *)(a1 + 24);
    if (a3 != 1)
    {
      if (a3 != 2) {
        return -1;
      }
      uint64_t v3 = (void *)(a1 + 16);
    }
    a2 += *v3;
  }
  if ((a2 & 0x8000000000000000) == 0 && a2 <= *(void *)(a1 + 16))
  {
    *(void *)(a1 + 24) = a2;
    return a2;
  }
  return -1;
}

void IntervalStreamCancel(AAByteStream *a1)
{
}

uint64_t IntervalStreamClose(void *a1)
{
  return 0;
}

uint64_t SegmentStreamPRead(void **a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0;
  }
  unint64_t v5 = a3;
  unint64_t v7 = 0;
  uint64_t v8 = (pthread_mutex_t *)(a1 + 386);
  uint64_t v9 = a1 + 2;
  int v73 = (unint64_t *)(a1 + 4);
  uint64_t v75 = (pthread_mutex_t *)(a1 + 386);
  while (1)
  {
    uint64_t v10 = segment_find(a1, a4);
    if (!v10)
    {
      char v63 = "no segment found";
      __int16 v64 = 321;
      goto LABEL_74;
    }
    uint64_t v13 = v10;
    unint64_t v14 = a4 - *(void *)v10;
    if (v5 - v7 >= *(void *)(v10 + 8) - v14) {
      size_t v15 = *(void *)(v10 + 8) - v14;
    }
    else {
      size_t v15 = v5 - v7;
    }
    if (!*(_DWORD *)(v10 + 24))
    {
      uint64_t v22 = (uint64_t)*a1;
      if ((*a1)[4])
      {
        if (!v15) {
          goto LABEL_41;
        }
        uint64_t v23 = 0;
        uint64_t v24 = a2 + v7;
        size_t v25 = v15;
        unint64_t v26 = *(void *)(v10 + 16) + a4 - *(void *)v10;
        size_t __n = v25;
        while (1)
        {
          uint64_t v27 = (*(uint64_t (**)(void, uint64_t, size_t, unint64_t))(v22 + 32))(*(void *)v22, v24, v25, v26);
          if (v27 < 0) {
            break;
          }
          if (v27)
          {
            v24 += v27;
            v23 += v27;
            v26 += v27;
            v25 -= v27;
            if (v25) {
              continue;
            }
          }
          goto LABEL_39;
        }
        uint64_t v23 = v27;
      }
      else
      {
        size_t __n = v15;
        uint64_t v23 = -1;
      }
LABEL_39:
      size_t v15 = __n;
      BOOL v51 = __n == v23;
      uint64_t v8 = v75;
      unint64_t v5 = a3;
      if (!v51)
      {
        char v63 = "aaSegmentStreamProcess";
        __int16 v64 = 337;
        goto LABEL_74;
      }
LABEL_41:
      if (*((_DWORD *)a1 + 796) && v15 != aaByteStreamSimulate(*a1))
      {
        char v63 = "aaByteStreamSimulate";
        __int16 v64 = 340;
        goto LABEL_74;
      }
      goto LABEL_57;
    }
    uint64_t v81 = *(unsigned __int8 *)(v10 + 28);
    long long v82 = a1[1];
    if (pthread_mutex_lock(v8))
    {
      int v60 = "MutexLock";
      __int16 v61 = 169;
LABEL_62:
      int v62 = 0;
      goto LABEL_68;
    }
    uint64_t v18 = *(void *)(v13 + 16);
    unint64_t v19 = ((unint64_t)(0x317E428CA9 * v18) >> 32) & 0x7F;
    uint64_t v20 = &v9[3 * v19];
    if (v20[1] != v18) {
      break;
    }
    uint64_t v21 = (uint64_t)a1[394] + 1;
    a1[394] = (void *)v21;
    v9[3 * v19 + 2] = (void *)v21;
LABEL_26:
    memcpy((void *)(a2 + v7), (const void *)(*v20 + v14), v15);
    unint64_t v41 = 0;
LABEL_53:
    if (pthread_mutex_unlock(v8))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", 208, 137, 0, "MutexUnlock", v56, v57, v68);
      goto LABEL_73;
    }
    free(v41);
    if (*((_DWORD *)a1 + 796))
    {
      size_t v58 = v15;
      uint64_t v59 = *(unsigned int *)(v13 + 24);
      BOOL v51 = aaByteStreamSimulate(*a1) == v59;
      size_t v15 = v58;
      if (!v51)
      {
        char v63 = "aaByteStreamSimulate";
        __int16 v64 = 333;
        goto LABEL_74;
      }
    }
LABEL_57:
    a4 += v15;
    v7 += v15;
    if (v7 >= v5) {
      return v7;
    }
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  unint64_t v30 = v73;
  while (*(v30 - 1) != v18)
  {
    unint64_t v31 = *v30;
    v30 += 3;
    if (v31 < (unint64_t)v9[3 * v29 + 2]) {
      uint64_t v29 = v28;
    }
    if (++v28 == 128) {
      goto LABEL_25;
    }
  }
  uint64_t v29 = v28;
LABEL_25:
  uint64_t v32 = (void *)v20[2];
  long long v33 = *(_OWORD *)v20;
  int v34 = &v9[3 * v29];
  uint64_t v35 = v34[2];
  *(_OWORD *)uint64_t v20 = *(_OWORD *)v34;
  v20[2] = v35;
  *(_OWORD *)int v34 = v33;
  v34[2] = v32;
  uint64_t v36 = v20[1];
  uint64_t v37 = *(void *)(v13 + 16);
  uint64_t v38 = (uint64_t)a1[394] + 1;
  a1[394] = (void *)v38;
  uint64_t v39 = &v9[3 * v19];
  v39[2] = (void *)v38;
  unint64_t v40 = (uint64_t *)(v39 + 2);
  if (v36 == v37) {
    goto LABEL_26;
  }
  AAFieldKey v70 = v40;
  __int16 v71 = v20 + 1;
  uint64_t v72 = (void **)v20;
  if (pthread_mutex_unlock(v8))
  {
    int v60 = "MutexUnlock";
    __int16 v61 = 175;
    goto LABEL_62;
  }
  uint64_t v42 = *(unsigned int *)(v13 + 24);
  size_t v43 = *(void *)(v13 + 8) + v42;
  if (v43 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_67:
    int v62 = *__error();
    int v60 = "aaMalloc";
    __int16 v61 = 179;
LABEL_68:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v61, 137, v62, v60, v16, v17, v68);
    unint64_t v41 = 0;
    goto LABEL_73;
  }
  src_buffer = (uint8_t *)malloc(v43);
  if (!src_buffer) {
    goto LABEL_67;
  }
  uint64_t v46 = (uint64_t)*a1;
  if ((*a1)[4])
  {
    size_t __na = v15;
    unint64_t v80 = v14;
    uint64_t v69 = v42;
    uint64_t v47 = 0;
    if (v42)
    {
      uint64_t v48 = *(void *)(v13 + 16);
      uint64_t v49 = src_buffer;
      while (1)
      {
        uint64_t v50 = (*(uint64_t (**)(void, uint8_t *, uint64_t, uint64_t))(v46 + 32))(*(void *)v46, v49, v42, v48);
        if (v50 < 0) {
          break;
        }
        if (v50)
        {
          v49 += v50;
          v47 += v50;
          v48 += v50;
          v42 -= v50;
          if (v42) {
            continue;
          }
        }
        goto LABEL_45;
      }
      uint64_t v47 = v50;
    }
LABEL_45:
    BOOL v51 = v47 == v69;
    uint64_t v8 = v75;
    unint64_t v5 = a3;
    if (v51)
    {
      size_t v52 = *(void *)(v13 + 8);
      if (*src_buffer == BYTE4(v82[v81]))
      {
        if (v52 + 1 != *(_DWORD *)(v13 + 24))
        {
          uint64_t v65 = "chunk error";
          __int16 v66 = 189;
          goto LABEL_72;
        }
        uint64_t v53 = src_buffer + 1;
      }
      else
      {
        size_t v54 = *(unsigned int *)(v13 + 24);
        uint64_t v53 = &src_buffer[v54];
        if (compression_decode_buffer(&src_buffer[v54], v52, src_buffer, v54, 0, (compression_algorithm)LODWORD(v82[v81])) != *(void *)(v13 + 8))
        {
          uint64_t v65 = "compression_decode_buffer";
          __int16 v66 = 195;
          goto LABEL_72;
        }
      }
      memcpy((void *)(a2 + v7), &v53[v80], __na);
      if (pthread_mutex_lock(v75))
      {
        uint64_t v65 = "MutexLock";
        __int16 v66 = 202;
        goto LABEL_72;
      }
      memcpy(*v72, v53, *(void *)(v13 + 8));
      *__int16 v71 = *(void *)(v13 + 16);
      uint64_t v55 = (uint64_t)a1[394] + 1;
      a1[394] = (void *)v55;
      *AAFieldKey v70 = v55;
      size_t v15 = __na;
      unint64_t v41 = src_buffer;
      goto LABEL_53;
    }
  }
  uint64_t v65 = "aaByteStreamPReadExpected";
  __int16 v66 = 183;
LABEL_72:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v66, 137, 0, v65, v44, v45, v68);
  unint64_t v41 = src_buffer;
LABEL_73:
  free(v41);
  char v63 = "segment_decode_to_buffer";
  __int16 v64 = 330;
LABEL_74:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPRead", v64, 137, 0, v63, v11, v12, v68);
  return -1;
}

uint64_t SegmentStreamPWrite(void *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a3) {
    return 0;
  }
  unint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = segment_find(a1, a4);
    if (!v8)
    {
      unint64_t v19 = "no segment found";
      __int16 v20 = 363;
      goto LABEL_23;
    }
    unint64_t v11 = a4 - *(void *)v8;
    if (a3 - v7 >= *(void *)(v8 + 8) - v11) {
      unint64_t v12 = *(void *)(v8 + 8) - v11;
    }
    else {
      unint64_t v12 = a3 - v7;
    }
    if (*(_DWORD *)(v8 + 24))
    {
      unint64_t v19 = "compressed content";
      __int16 v20 = 370;
      goto LABEL_23;
    }
    uint64_t v13 = *a1;
    if (!*(void *)(*a1 + 40))
    {
      uint64_t v14 = -1;
      goto LABEL_16;
    }
    if (v12) {
      break;
    }
LABEL_17:
    a4 += v12;
    v7 += v12;
    if (v7 >= a3) {
      return v7;
    }
  }
  uint64_t v14 = 0;
  uint64_t v15 = a2 + v7;
  unint64_t v16 = *(void *)(v8 + 16) + v11;
  unint64_t v17 = v12;
  while (1)
  {
    uint64_t v18 = (*(uint64_t (**)(void, uint64_t, unint64_t, unint64_t))(v13 + 40))(*(void *)v13, v15, v17, v16);
    if (v18 < 1) {
      break;
    }
    v15 += v18;
    v14 += v18;
    v16 += v18;
    v17 -= v18;
    if (!v17) {
      goto LABEL_16;
    }
  }
  uint64_t v14 = v18;
LABEL_16:
  if (v12 == v14) {
    goto LABEL_17;
  }
  unint64_t v19 = "aaByteStreamPWriteExpected";
  __int16 v20 = 374;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPWrite", v20, 137, 0, v19, v9, v10, v22);
  return -1;
}

void SegmentStreamCancel(AAByteStream *a1)
{
}

uint64_t SegmentStreamSimulate(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  unint64_t v8 = 0;
  while (a4 > v8)
  {
    uint64_t v9 = segment_find(a1, a5);
    if (!v9)
    {
      uint64_t v14 = "no segment found";
      __int16 v15 = 276;
      goto LABEL_12;
    }
    unint64_t v12 = *(void *)(v9 + 8) - (a5 - *(void *)v9);
    if (a4 - v8 < v12) {
      unint64_t v12 = a4 - v8;
    }
    a5 += v12;
    v8 += v12;
    if (*(_DWORD *)(v9 + 24)) {
      unint64_t v13 = *(unsigned int *)(v9 + 24);
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 != aaByteStreamSimulate((void *)*a1))
    {
      uint64_t v14 = "aaByteStreamSimulate";
      __int16 v15 = 303;
LABEL_12:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamSimulate", v15, 137, 0, v14, v10, v11, v17);
      return -1;
    }
  }
  return v8;
}

uint64_t segment_find(void *a1, unint64_t a2)
{
  if (a1[397] <= a2) {
    return 0;
  }
  unint64_t v2 = a1[396];
  uint64_t v3 = a1[395];
  if (v2 < 2)
  {
    unint64_t v4 = 0;
  }
  else
  {
    unint64_t v4 = 0;
    do
    {
      if (*(void *)(v3 + 29 * ((v2 + v4) >> 1)) > a2) {
        unint64_t v2 = (v2 + v4) >> 1;
      }
      else {
        unint64_t v4 = (v2 + v4) >> 1;
      }
    }
    while (v4 + 1 < v2);
  }
  return v3 + 29 * v4;
}

uint64_t load_variants(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = (const char **)(a2 + 16);
  unint64_t v7 = (FILE **)MEMORY[0x263EF8348];
  while (1)
  {
    unint64_t v8 = v6;
    if (v4) {
      unint64_t v8 = (const char **)(*(void *)(a2 + 8) + 8 * v4 - 8);
    }
    uint64_t v9 = rawimg_create_with_path(*v8);
    *(void *)(a1 + 8 * v4) = v9;
    if (!v9)
    {
      char v22 = "rawimg_create_with_file";
      __int16 v23 = 37;
      goto LABEL_26;
    }
    if ((rawimg_get_digests((uint64_t)v9, *(_DWORD *)(a2 + 36), 0, 0) & 0x80000000) != 0) {
      break;
    }
    unint64_t v12 = *(uint64_t **)(a1 + 8 * v4);
    if (v4 < 2)
    {
LABEL_19:
      *(void *)(a1 + 8 * v5++) = v12;
    }
    else
    {
      uint64_t v13 = 1;
      while (1)
      {
        uint64_t v14 = *(void **)(a1 + 8 * v13);
        uint64_t v15 = v14[261];
        uint64_t v16 = v14[262];
        uint64_t v17 = v14[263];
        uint64_t v18 = v14[264];
        BOOL v19 = v12[261] == v15 && v12[262] == v16;
        BOOL v20 = v19 && v12[263] == v17;
        if (v20 && v12[264] == v18) {
          break;
        }
        if (v4 == ++v13) {
          goto LABEL_19;
        }
      }
      rawimg_destroy(v12);
      if (*(_DWORD *)(a2 + 40)) {
        fprintf(*v7, "ImageDiff: Removed non-unique input variant <%s>.\n", *(const char **)(*(void *)(a1 + 8 * v4) + 2048));
      }
    }
    if (++v4 > *(void *)a2) {
      return v5;
    }
  }
  char v22 = "rawimg_get_digests";
  __int16 v23 = 38;
LABEL_26:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"load_variants", v23, 134, 0, v22, v10, v11, v25);
  return 0;
}

uint64_t patch_write_controls(AAByteStream_impl *a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  off_t v8 = AAByteStreamSeek(a1, 0, 1);
  *(void *)(a3 + 38) = v8;
  if (v8 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 331, 134, 0, "AAByteStreamSeek", v9, v10, v33);
    uint64_t v20 = 0;
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(a4 + 40);
    if (v11 <= 3) {
      AAFlagSet v12 = v11 << 62;
    }
    else {
      AAFlagSet v12 = 0xC000000000000000;
    }
    AAByteStream v13 = AACompressionOutputStreamOpen(a1, 0x306u, 0x100000uLL, v12, *(_DWORD *)(a4 + 36));
    uint64_t v16 = v13;
    if (v13)
    {
      unint64_t v17 = a2[2];
      if (v17 < 2)
      {
        unint64_t v21 = a2[3];
        uint64_t v18 = (uint64_t *)(v21 + 56);
        BOOL v19 = (uint64_t *)(v21 + 40);
      }
      else
      {
        uint64_t v18 = (uint64_t *)(a2 + 11);
        BOOL v19 = (uint64_t *)(a2 + 9);
      }
      uint64_t v22 = *v18;
      *(void *)(a3 + 18) = v22;
      uint64_t v20 = *v19;
      if (*((void *)v13 + 3))
      {
        uint64_t v23 = 8 * v17 + 16;
        uint64_t v24 = v23 * v22;
        if (!(v23 * v22)) {
          goto LABEL_19;
        }
        uint64_t v25 = 0;
        uint64_t v26 = *v19;
        uint64_t v27 = v23 * v22;
        while (1)
        {
          uint64_t v28 = (*((uint64_t (**)(void, uint64_t, uint64_t))v16 + 3))(*(void *)v16, v26, v27);
          if (v28 < 1) {
            break;
          }
          v26 += v28;
          v25 += v28;
          v27 -= v28;
          if (!v27) {
            goto LABEL_18;
          }
        }
        uint64_t v25 = v28;
LABEL_18:
        if (v24 == v25)
        {
LABEL_19:
          int v29 = 0;
          goto LABEL_22;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 350, 134, 0, "aaByteStreamWriteExpected", v14, v15, v33);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 335, 134, 0, "AACompressionOutputStreamOpen", v14, v15, v33);
      uint64_t v20 = 0;
    }
  }
  int v29 = 1;
LABEL_22:
  if (AAByteStreamClose(v16) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 353, 134, 0, "AAByteStreamClose", v30, v31, v33);
  }
  else if (!v29)
  {
    return v20;
  }
  return 0;
}

uint64_t RawImageDiff(uint64_t a1)
{
  uint64_t v326 = *MEMORY[0x263EF8340];
  long long v324 = 0u;
  long long v325 = 0u;
  long long v322 = 0u;
  long long v323 = 0u;
  long long v320 = 0u;
  long long v321 = 0u;
  long long v319 = 0u;
  if (!*(_DWORD *)(a1 + 36)) {
    *(_DWORD *)(a1 + 36) = getDefaultNThreads();
  }
  if (*(_DWORD *)(a1 + 40))
  {
    unint64_t v2 = (FILE **)MEMORY[0x263EF8348];
    fwrite("ImageDiff\n", 0xAuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    unint64_t v3 = *(void *)a1;
    if (*(void *)a1)
    {
      unint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(const char **)(*(void *)(a1 + 8) + 8 * v4);
        if (v5)
        {
          fprintf(*v2, "  Input %zu: %s\n", v4, v5);
          unint64_t v3 = *(void *)a1;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    if (*(void *)(a1 + 16)) {
      fprintf(*v2, "  Output: %s\n", *(const char **)(a1 + 16));
    }
    if (*(void *)(a1 + 24)) {
      fprintf(*v2, "  Patch: %s\n", *(const char **)(a1 + 24));
    }
    if (*(_DWORD *)(a1 + 32)) {
      uint64_t v6 = "yes";
    }
    else {
      uint64_t v6 = "no";
    }
    fprintf(*v2, "  In-place: %s\n", v6);
  }
  size_t v7 = *(void *)a1 + 1;
  if (v7 > 0x400000000)
  {
    *__error() = 12;
LABEL_95:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", 592, 134, 0, "aaCalloc", v8, v9, v282);
    uint64_t v104 = 0xFFFFFFFFLL;
    goto LABEL_117;
  }
  uint64_t v10 = (uint64_t *)calloc(v7, 8uLL);
  if (!v10) {
    goto LABEL_95;
  }
  uint64_t v11 = v10;
  unint64_t variants = load_variants((uint64_t)v10, a1);
  if (!variants)
  {
    uint64_t v105 = "load_variants";
    __int16 v106 = 596;
    goto LABEL_113;
  }
  *(void *)a1 = variants - 1;
  if ((rawimg_set_fork_types((uint64_t)v11, variants, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    uint64_t v105 = "rawimg_set_fork_types";
    __int16 v106 = 600;
    goto LABEL_113;
  }
  unint64_t v19 = *(void *)a1;
  if ((*(void *)a1 & 0x80000000) == 0)
  {
    uint64_t v20 = *(void *)a1;
    do
    {
      rawimg_show(v11[v20], v20 == 0, *(_DWORD *)(a1 + 40));
      --v20;
    }
    while (v20 != -1);
    unint64_t v19 = *(void *)a1;
  }
  uint64_t v21 = *v11;
  uint64_t v22 = (void **)(*(void *)(*v11 + 2120) / 0x64uLL + 0x2000000);
  long long v319 = 0u;
  long long v320 = 0u;
  long long v321 = 0u;
  long long v322 = 0u;
  long long v323 = 0u;
  long long v324 = 0u;
  long long v325 = 0u;
  *(int32x2_t *)((char *)&v319 + 4) = vrev64_s32(*(int32x2_t *)(a1 + 36));
  *(void *)&long long v320 = v19;
  if (v19 <= 1) {
    unint64_t v23 = 1;
  }
  else {
    unint64_t v23 = v19;
  }
  if (!is_mul_ok(v23, 0x50uLL) || 80 * v23 >= 0x2000000001)
  {
    *__error() = 12;
    *((void *)&v320 + 1) = 0;
    goto LABEL_99;
  }
  uint64_t v24 = (char *)calloc(v23, 0x50uLL);
  *((void *)&v320 + 1) = v24;
  if (!v24)
  {
LABEL_99:
    int v107 = *__error();
    __int16 v110 = 205;
LABEL_100:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v110, 134, v107, "aaCalloc", v108, v109, v282);
    uint64_t v45 = 0;
    uint64_t v37 = 0;
    uint64_t v30 = 0;
LABEL_101:
    char v63 = 0;
    uint64_t v59 = 0;
    size_t v52 = 0;
    goto LABEL_102;
  }
  uint64_t v25 = v24;
  if (v19)
  {
    uint64_t v26 = v24 + 36;
    do
    {
      *uint64_t v26 = 1;
      v26 += 20;
      --v19;
    }
    while (v19);
  }
  if (!*(void *)a1)
  {
    BOOL v250 = calloc(1uLL, 0x18uLL);
    *((void *)v25 + 5) = v250;
    if (v250)
    {
      uint64_t v45 = 0;
      uint64_t v30 = 0;
      char v63 = 0;
      uint64_t v59 = 0;
      size_t v52 = 0;
      uint64_t v251 = *(void *)(v21 + 2080);
      if (v251 < 0) {
        uint64_t v251 = 0x8000000000000000 - v251;
      }
      v250[1] = v251;
      int v111 = 1;
      *((void *)v25 + 7) = 1;
      uint64_t v37 = 0;
      goto LABEL_103;
    }
    int v107 = *__error();
    __int16 v110 = 213;
    goto LABEL_100;
  }
  AAByteStream v27 = AAFileStreamOpenWithPath(*(const char **)(v21 + 2048), 0, 0);
  uint64_t v30 = v27;
  if (!v27)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 223, 134, 0, "AAFileStreamOpenWithPath", v28, v29, v282);
    uint64_t v45 = 0;
    uint64_t v37 = 0;
    goto LABEL_101;
  }
  uint64_t v31 = aaSegmentStreamOpen(v27, (void *)v21);
  uint64_t v37 = (AAByteStream_impl *)v31;
  if (!v31)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 225, 134, 0, "aaSegmentStreamOpen", v35, v36, v282);
    uint64_t v45 = 0;
    goto LABEL_101;
  }
  uint64_t v45 = aaForkInputStreamOpen(v31, v21, 0, v32, v33, v34, v35, v36);
  if (!v45)
  {
    unint64_t v252 = "aaForkInputStreamOpen";
    __int16 v253 = 227;
LABEL_290:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v253, 134, 0, v252, v43, v44, v282);
    goto LABEL_101;
  }
  unint64_t v46 = 0;
  int64x2_t v303 = vdupq_n_s64(0x8000000000000000);
  v311 = v37;
  AAByteStream v315 = (AAByteStream)v22;
  while (1)
  {
    if (v46 >= (unint64_t)v320)
    {
      if ((unint64_t)v320 < 2)
      {
        char v63 = 0;
        uint64_t v59 = 0;
        size_t v52 = 0;
        int v111 = 1;
      }
      else
      {
        if (bxdiff5CreateComboControls((uint64_t)&v319, v38, v39, v40, v41, v42, v43, v44))
        {
          unint64_t v252 = "bxdiff5CreateComboControls";
          __int16 v253 = 270;
          goto LABEL_290;
        }
        if ((controls_combo_enforce_copy_fork_boundary(*v11, &v319, v265, v266, v267, v268, v43, v44) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 272, 134, 0, "controls_combo_enforce_copy_fork_boundary", v280, v281, v282);
          char v63 = 0;
          uint64_t v59 = 0;
          size_t v52 = 0;
          int v111 = 0;
        }
        else
        {
          if (*(_DWORD *)(a1 + 40)) {
            fprintf((FILE *)*MEMORY[0x263EF8348], "ImageDiff: Constructed %zd combo controls.\n", *((size_t *)&v324 + 1));
          }
          char v63 = 0;
          uint64_t v59 = 0;
          size_t v52 = 0;
          int v111 = 1;
        }
        uint64_t v37 = v311;
      }
      goto LABEL_103;
    }
    uint64_t v22 = (void **)v30;
    unint64_t v317 = v46;
    unint64_t v47 = v46 + 1;
    uint64_t v48 = v11[v46 + 1];
    AAByteStream v49 = AAFileStreamOpenWithPath(*(const char **)(v48 + 2048), 0, 0);
    size_t v52 = v49;
    if (!v49)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 236, 134, 0, "AAFileStreamOpenWithPath", v50, v51, v282);
      char v63 = 0;
      uint64_t v59 = 0;
LABEL_318:
      int v111 = 0;
      uint64_t v30 = (AAByteStream_impl *)v22;
      LODWORD(v22) = v315;
      goto LABEL_103;
    }
    uint64_t v53 = aaSegmentStreamOpen(v49, (void *)v48);
    uint64_t v59 = (AAByteStream_impl *)v53;
    if (!v53)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 238, 134, 0, "aaSegmentStreamOpen", v57, v58, v282);
      char v63 = 0;
      goto LABEL_318;
    }
    unint64_t v309 = v47;
    int v60 = aaForkInputStreamOpen(v53, v48, 0, v54, v55, v56, v57, v58);
    char v63 = (AAByteStream_impl *)v60;
    if (!v60)
    {
      uint64_t v269 = "aaForkInputStreamOpen";
      __int16 v270 = 240;
LABEL_317:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v270, 134, 0, v269, v61, v62, v282);
      goto LABEL_318;
    }
    v313 = (unsigned char *)v48;
    if ((GetLargeFileControlsWithStreams((uint64_t)v60, *(void *)(v48 + 2072), (unint64_t)v45, *(void *)(v21 + 2072), (void **)(*((void *)&v320 + 1) + 80 * v317 + 40), (uint64_t *)(*((void *)&v320 + 1) + 80 * v317 + 56), (uint64_t *)&v319) & 0x80000000) != 0)
    {
      uint64_t v269 = "GetLargeFileControlsWithStreams";
      __int16 v270 = 246;
      goto LABEL_317;
    }
    uint64_t v64 = *(void *)(v21 + 2160);
    uint64_t v30 = (AAByteStream_impl *)v22;
    uint64_t v22 = (void **)v315;
    if (v64)
    {
      uint64_t v65 = *((void *)&v320 + 1) + 80 * v317;
      AAByteStream v307 = (AAByteStream)(v65 + 56);
      uint64_t v66 = *(void *)(v65 + 56);
      if (!v66)
      {
        char v256 = "empty controls";
        __int16 v257 = 124;
LABEL_293:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", v257, 134, 0, v256, v61, v62, v282);
        goto LABEL_294;
      }
      if ((*(unsigned char *)(v21 + 2128) & 0x10) == 0 || (v313[2128] & 0x10) == 0)
      {
        char v256 = "no digests found";
        __int16 v257 = 126;
        goto LABEL_293;
      }
      uint64_t v22 = (void **)(v65 + 40);
      size_t v67 = 24 * (v66 + v64);
      if (v67 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_332;
      }
      int v305 = *(_DWORD *)(a1 + 40);
      char v68 = *v22;
      uint64_t v69 = (uint64_t *)realloc(*v22, v67);
      if (!v69)
      {
        free(v68);
        uint64_t v37 = v311;
LABEL_332:
        *uint64_t v22 = 0;
        uint64_t v276 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", 130, 134, *v276, "aaReallocf", v277, v278, v282);
        LODWORD(v22) = v315;
LABEL_294:
        uint64_t v258 = "controls_append_copy_forks";
        __int16 v259 = 250;
LABEL_295:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v259, 134, 0, v258, v99, v100, v282);
        goto LABEL_102;
      }
      *uint64_t v22 = v69;
      uint64_t v70 = *(void *)v307;
      if (*(void *)v307)
      {
        uint64_t v71 = 0;
        uint64_t v72 = v69 + 2;
        uint64_t v73 = *(void *)v307;
        uint64_t v22 = (void **)v315;
        uint64_t v37 = v311;
        do
        {
          uint64_t v74 = *(v72 - 2);
          if (v74 < 0) {
            uint64_t v74 = 0x8000000000000000 - v74;
          }
          uint64_t v76 = *v72;
          v72 += 3;
          uint64_t v75 = v76;
          unint64_t v77 = 0x8000000000000000 - v76;
          if (v76 < 0) {
            uint64_t v75 = v77;
          }
          v71 += v74 + v75;
          --v73;
        }
        while (v73);
      }
      else
      {
        uint64_t v71 = 0;
        uint64_t v22 = (void **)v315;
        uint64_t v37 = v311;
      }
      unint64_t v78 = *(void *)(v21 + 2160);
      if (v78)
      {
        unint64_t v79 = 0;
        uint64_t v80 = *(void *)(v21 + 2144);
        uint64_t v81 = (char *)(v69 - 1);
        do
        {
          uint64_t v82 = v80 + 440 * v79;
          if ((*(unsigned char *)(v82 + 408) & 2) != 0)
          {
            uint64_t v83 = *((void *)v313 + 270);
            if (!v83) {
              goto LABEL_292;
            }
            uint64_t v84 = *((void *)v313 + 268);
            uint64_t v85 = (void *)(v80 + 440 * v79);
            size_t v86 = v85 + 49;
            uint64_t v87 = v85 + 50;
            uint64_t v88 = v85 + 4;
            while (1)
            {
              if ((*(unsigned char *)(v84 + 408) & 2) != 0 && *(void *)(v84 + 392) == *v86 && *(void *)(v84 + 400) == *v87)
              {
                uint64_t v89 = *(void *)(v84 + 32);
                if (v89 == *v88)
                {
                  uint64_t v61 = *(void *)(v82 + 8);
                  uint64_t v62 = *(void *)(v84 + 16);
                  BOOL v90 = *(void *)v84 == *(void *)v82 && *(void *)(v84 + 8) == v61;
                  BOOL v91 = v90 && v62 == *(void *)(v82 + 16);
                  uint64_t v22 = (void **)v315;
                  BOOL v92 = v91 && *(void *)(v84 + 24) == *(void *)(v82 + 24);
                  uint64_t v37 = v311;
                  if (v92) {
                    break;
                  }
                }
              }
              v84 += 440;
              if (!--v83) {
                goto LABEL_292;
              }
            }
            uint64_t v93 = *(void *)(v84 + 48);
            if (v93 < 0)
            {
LABEL_292:
              char v256 = "copy fork not found";
              __int16 v257 = 161;
              goto LABEL_293;
            }
            uint64_t v94 = 3 * v70++;
            *(void *)AAByteStream v307 = v70;
            uint64_t v95 = (char *)&v69[v94];
            uint64_t v96 = 8 * v94;
            *((void *)v95 + 1) = 0;
            *((void *)v95 + 2) = 0;
            uint64_t v97 = *(void *)&v81[8 * v94];
            if (v97 < 0) {
              uint64_t v97 = 0x8000000000000000 - v97;
            }
            v98.i64[0] = v97 + v93 - v71;
            v98.i64[1] = v89;
            *(int8x16_t *)&v81[v96] = vbslq_s8((int8x16_t)vcltzq_s64(v98), (int8x16_t)vsubq_s64(v303, v98), (int8x16_t)v98);
            uint64_t v71 = v93 + v89;
            unint64_t v78 = *(void *)(v21 + 2160);
          }
          ++v79;
        }
        while (v79 < v78);
      }
      if (v305 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "ImageDiff: Processed copy forks: %zd controls\n", v70);
      }
    }
    if ((*(unsigned char *)(a1 + 32) & 1) != 0
      && (rawimg_force_in_place((void *)(*((void *)&v320 + 1) + 80 * v317 + 40), (unint64_t *)(*((void *)&v320 + 1) + 80 * v317 + 56), v313, v21, (uint64_t)v22, *(_DWORD *)(a1 + 40)) & 0x80000000) != 0)
    {
      uint64_t v258 = "rawimg_force_in_place";
      __int16 v259 = 258;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v63) < 0)
    {
      uint64_t v258 = "AAByteStreamClose";
      __int16 v259 = 262;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v59) < 0) {
      break;
    }
    int v103 = AAByteStreamClose(v52);
    unint64_t v46 = v309;
    if (v103 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 264, 134, 0, "AAByteStreamClose", v43, v44, v282);
      char v63 = 0;
      uint64_t v59 = 0;
      goto LABEL_102;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 263, 134, 0, "AAByteStreamClose", v101, v102, v282);
  char v63 = 0;
LABEL_102:
  int v111 = 0;
LABEL_103:
  if (AAByteStreamClose((AAByteStream)v45) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 280, 134, 0, "AAByteStreamClose", v112, v113, v282);
    int v111 = 0;
  }
  if (AAByteStreamClose(v37) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 281, 134, 0, "AAByteStreamClose", v114, v115, v282);
    if ((AAByteStreamClose(v30) & 0x80000000) == 0) {
      goto LABEL_112;
    }
LABEL_111:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 282, 134, 0, "AAByteStreamClose", v116, v117, v282);
    goto LABEL_112;
  }
  if (AAByteStreamClose(v30) < 0) {
    goto LABEL_111;
  }
  if (!v111)
  {
LABEL_112:
    AAByteStreamClose(v63);
    AAByteStreamClose(v59);
    AAByteStreamClose(v52);
    BXDiff5Data_free((uint64_t)&v319);
    uint64_t v105 = "controls_create_with_variants";
    __int16 v106 = 612;
    goto LABEL_113;
  }
  int v118 = (int)v22;
  unint64_t v119 = 8 * *(void *)a1 + 62;
  if (v119 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_281;
  }
  int v122 = *(_DWORD *)(a1 + 32);
  long long v123 = (char *)calloc(1uLL, 8 * *(void *)a1 + 62);
  if (!v123)
  {
LABEL_281:
    __int16 v247 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 515, 134, *v247, "aaCalloc", v248, v249, v282);
    uint64_t v124 = 0;
    unint64_t v129 = 0;
LABEL_303:
    int v262 = 1;
    goto LABEL_304;
  }
  uint64_t v124 = (uint64_t)v123;
  *(void *)long long v123 = 0x3031464649444952;
  *((_WORD *)v123 + 4) = *(_WORD *)a1 + 1;
  *(void *)(v123 + 10) = v122 & 1;
  if (v122) {
    int v125 = v118;
  }
  else {
    int v125 = 0;
  }
  *(_DWORD *)(v123 + 26) = v125;
  *(void *)(v123 + 30) = v119;
  uint64_t v126 = AAFileStreamOpenWithPath(*(const char **)(a1 + 24), 1537, 0x1A4u);
  unint64_t v129 = v126;
  if (!v126)
  {
    char v254 = "AAFileStreamOpenWithPath";
    __int16 v255 = 526;
LABEL_302:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", v255, 134, 0, v254, v127, v128, v282);
    goto LABEL_303;
  }
  if (AAByteStreamSeek(v126, v119, 0) < 0)
  {
    char v254 = "AAByteStreamSeek";
    __int16 v255 = 527;
    goto LABEL_302;
  }
  uint64_t v130 = *(unsigned int *)(a1 + 40);
  if (v130 <= 3) {
    AAFlagSet v131 = v130 << 62;
  }
  else {
    AAFlagSet v131 = 0xC000000000000000;
  }
  uint64_t v137 = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v131, *(_DWORD *)(a1 + 36));
  if (!v137)
  {
    unint64_t v260 = "AACompressionOutputStreamOpen";
    __int16 v261 = 305;
    goto LABEL_299;
  }
  unint64_t v138 = 0;
  do
  {
    if ((rawimg_save_to_stream(v137, v11[v138], v138 == 0, v132, v133, v134, v135, v136) & 0x80000000) != 0)
    {
      unint64_t v260 = "rawimg_save_to_stream";
      __int16 v261 = 311;
LABEL_299:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", v261, 134, 0, v260, v135, v136, v282);
      if ((AAByteStreamClose(v137) & 0x80000000) == 0)
      {
LABEL_301:
        char v254 = "patch_write_metadata";
        __int16 v255 = 530;
        goto LABEL_302;
      }
LABEL_300:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", 315, 134, 0, "AAByteStreamClose", v127, v128, v282);
      goto LABEL_301;
    }
    ++v138;
  }
  while (v138 <= *(void *)a1);
  if (AAByteStreamClose(v137) < 0) {
    goto LABEL_300;
  }
  uint64_t v139 = patch_write_controls(v129, (unint64_t *)&v319, v124, a1);
  if (!v139)
  {
    char v254 = "patch_write_controls";
    __int16 v255 = 534;
    goto LABEL_302;
  }
  uint64_t v292 = v139;
  uint64_t v140 = 0;
  do
  {
    uint64_t v141 = v11[v140];
    uint64_t v300 = *v11;
    off_t v142 = AAByteStreamSeek(v129, 0, 1);
    v299 = (off_t *)(v124 + 46 + 8 * v140);
    off_t *v299 = v142;
    uint64_t v310 = v140;
    if (v142 < 0)
    {
      __int16 v160 = 383;
      uint64_t v161 = "AAByteStreamSeek";
LABEL_147:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v160, 134, 0, v161, v143, v144, v282);
      v312 = 0;
      v314 = 0;
      v318 = 0;
      v302 = 0;
      v304 = 0;
      v316 = 0;
      v306 = 0;
      v308 = 0;
      goto LABEL_148;
    }
    LODWORD(v145) = *(_DWORD *)(a1 + 40);
    if (v145 >= 3) {
      uint64_t v145 = 3;
    }
    else {
      uint64_t v145 = v145;
    }
    s = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v145 << 62, *(_DWORD *)(a1 + 36));
    if (!s)
    {
      __int16 v160 = 387;
      uint64_t v161 = "AACompressionOutputStreamOpen";
      goto LABEL_147;
    }
    if (v140)
    {
      AAByteStream v146 = AAFileStreamOpenWithPath(*(const char **)(v141 + 2048), 0, 0);
      if (!v146)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 394, 134, 0, "AAFileStreamOpenWithPath", v147, v148, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        v306 = 0;
        v308 = 0;
        goto LABEL_254;
      }
      v308 = v146;
      int v149 = aaSegmentStreamOpen(v146, (void *)v141);
      if (!v149)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 396, 134, 0, "aaSegmentStreamOpen", v153, v154, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        v306 = 0;
        goto LABEL_254;
      }
      v306 = (AAByteStream_impl *)v149;
      v316 = (AAByteStream_impl *)aaForkInputStreamOpen(v149, v141, 0, v150, v151, v152, v153, v154);
      if (!v316)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 398, 134, 0, "aaForkInputStreamOpen", v155, v156, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        goto LABEL_254;
      }
      v312 = malloc(0x10000uLL);
      if (!v312)
      {
        __int16 v157 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 400, 134, *v157, "aaMalloc", v158, v159, v282);
        v312 = 0;
        v314 = 0;
        goto LABEL_235;
      }
    }
    else
    {
      v312 = 0;
      v316 = 0;
      v306 = 0;
      v308 = 0;
    }
    uint64_t v164 = v300;
    AAByteStream v165 = AAFileStreamOpenWithPath(*(const char **)(v300 + 2048), 0, 0);
    if (!v165)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 405, 134, 0, "AAFileStreamOpenWithPath", v166, v167, v282);
      v314 = 0;
LABEL_235:
      v318 = 0;
      v302 = 0;
      v304 = 0;
LABEL_254:
      int v163 = 0;
      __int16 v162 = s;
      goto LABEL_255;
    }
    v304 = v165;
    uint64_t v168 = aaSegmentStreamOpen(v165, (void *)v300);
    if (!v168)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 407, 134, 0, "aaSegmentStreamOpen", v172, v173, v282);
      v314 = 0;
      v318 = 0;
      v302 = 0;
      goto LABEL_254;
    }
    v302 = (AAByteStream_impl *)v168;
    v318 = aaForkInputStreamOpen(v168, v300, 0, v169, v170, v171, v172, v173);
    if (!v318)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 409, 134, 0, "aaForkInputStreamOpen", v174, v175, v282);
      v314 = 0;
      v318 = 0;
      goto LABEL_254;
    }
    unint64_t v176 = malloc(0x10000uLL);
    if (!v176)
    {
      unint64_t v221 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 411, 134, *v221, "aaMalloc", v222, v223, v282);
      v314 = 0;
      goto LABEL_254;
    }
    v314 = v176;
    uint64_t v179 = v292;
    if (*(void *)(v124 + 18))
    {
      uint64_t v180 = 0;
      unint64_t v181 = 0;
      uint64_t v182 = 0;
      unint64_t v183 = 0;
      uint64_t v283 = v140 + 1;
      while (1)
      {
        unint64_t v289 = v183;
        v288 = (unint64_t *)(v179 + 8 * (v183 + v183 * *(unsigned __int16 *)(v124 + 8)));
        uint64_t v184 = v288[1];
        unint64_t v185 = 0x8000000000000000 - *v288;
        if ((*v288 & 0x8000000000000000) == 0) {
          unint64_t v185 = *v288;
        }
        unint64_t v186 = 0x8000000000000000 - v184;
        if (v184 >= 0) {
          unint64_t v186 = v288[1];
        }
        if (v140)
        {
          unint64_t v286 = v186;
          unint64_t v187 = *(void *)(v164 + 2072);
          if (v181 < v187 && v185 + v181 > v187)
          {
            __int16 v227 = 427;
            goto LABEL_246;
          }
          BOOL v188 = v181 >= v187;
          if (v181 >= v187) {
            unint64_t v189 = v185 + v181;
          }
          else {
            unint64_t v189 = v181;
          }
          if (v181 >= v187) {
            unint64_t v190 = v185;
          }
          else {
            unint64_t v190 = 0;
          }
          unint64_t v293 = v189;
          uint64_t v295 = v190 + v180;
          uint64_t v284 = v182;
          if (!v188 && v185)
          {
            unint64_t v191 = v185;
            unint64_t v290 = v185;
            while (1)
            {
              unint64_t v291 = v191;
              if (v191 >= 0x10000) {
                uint64_t v192 = 0x10000;
              }
              else {
                uint64_t v192 = v191;
              }
              if (!*((void *)v316 + 4)) {
                goto LABEL_248;
              }
              uint64_t v193 = 0;
              u_int32_t v194 = v312;
              uint64_t v195 = v295;
              unint64_t v297 = v192;
              while (1)
              {
                uint64_t v196 = (*((uint64_t (**)(void, unsigned char *, uint64_t, uint64_t))v316 + 4))(*(void *)v316, v194, v192, v195);
                if (v196 < 0) {
                  break;
                }
                if (v196)
                {
                  v194 += v196;
                  v193 += v196;
                  v195 += v196;
                  v192 -= v196;
                  if (v192) {
                    continue;
                  }
                }
                goto LABEL_183;
              }
              uint64_t v193 = v196;
LABEL_183:
              unint64_t v197 = v297;
              if (v297 != v193)
              {
LABEL_248:
                __int16 v227 = 442;
                goto LABEL_251;
              }
              long long v198 = v314;
              if (!v318[4]) {
                goto LABEL_250;
              }
              uint64_t v199 = 0;
              unint64_t v200 = v293;
              while (1)
              {
                uint64_t v201 = ((uint64_t (*)(uint64_t, unsigned char *, unint64_t, unint64_t))v318[4])(*v318, v198, v197, v200);
                if (v201 < 0) {
                  break;
                }
                if (v201)
                {
                  v198 += v201;
                  v199 += v201;
                  v200 += v201;
                  v197 -= v201;
                  if (v197) {
                    continue;
                  }
                }
                goto LABEL_191;
              }
              uint64_t v199 = v201;
LABEL_191:
              unint64_t v202 = v297;
              long long v203 = v314;
              if (v297 != v199)
              {
LABEL_250:
                __int16 v227 = 443;
                goto LABEL_251;
              }
              uint64_t v204 = 0;
              uint64_t v205 = v297 <= 1 ? 1 : v297;
              do
              {
                v314[v204] -= v312[v204];
                ++v204;
              }
              while (v205 != v204);
              if (!*((void *)s + 3)) {
                break;
              }
              uint64_t v206 = 0;
              while (1)
              {
                uint64_t v207 = (*((uint64_t (**)(void, unsigned char *, unint64_t))s + 3))(*(void *)s, v203, v202);
                if (v207 < 1) {
                  break;
                }
                v203 += v207;
                v206 += v207;
                v202 -= v207;
                if (!v202) {
                  goto LABEL_202;
                }
              }
              uint64_t v206 = v207;
LABEL_202:
              unint64_t v176 = v314;
              if (v297 != v206) {
                break;
              }
              v295 += v297;
              v293 += v297;
              unint64_t v191 = v291 - v297;
              unint64_t v185 = v290;
              if (v291 == v297) {
                goto LABEL_204;
              }
            }
            __int16 v227 = 447;
            uint64_t v228 = "aaByteStreamWriteExpected";
            goto LABEL_253;
          }
LABEL_204:
          uint64_t v182 = v284;
          uint64_t v208 = v288[v283];
          if (v208 < 0) {
            uint64_t v208 = 0x8000000000000000 - v208;
          }
          uint64_t v180 = v208 + v295;
          unint64_t v181 = v293 + v286;
          uint64_t v164 = v300;
        }
        else
        {
          v181 += v185;
          if (v186)
          {
            uint64_t v294 = v180;
            uint64_t v285 = v182;
            unint64_t v287 = v186;
            unint64_t v209 = v186;
            while (1)
            {
              uint64_t v210 = v209 >= 0x10000 ? 0x10000 : v209;
              if (!v318[4]) {
                break;
              }
              uint64_t v211 = 0;
              int v212 = v176;
              unint64_t v296 = v181;
              uint64_t v298 = v210;
              unint64_t v213 = v181;
              while (1)
              {
                uint64_t v214 = ((uint64_t (*)(uint64_t, char *, uint64_t, unint64_t))v318[4])(*v318, v212, v210, v213);
                if (v214 < 0) {
                  break;
                }
                if (v214)
                {
                  v212 += v214;
                  v211 += v214;
                  v213 += v214;
                  v210 -= v214;
                  if (v210) {
                    continue;
                  }
                }
                goto LABEL_219;
              }
              uint64_t v211 = v214;
LABEL_219:
              uint64_t v215 = v298;
              uint64_t v216 = v314;
              if (v298 != v211) {
                break;
              }
              unint64_t v217 = v209;
              __int16 v162 = s;
              if (!*((void *)s + 3)) {
                goto LABEL_249;
              }
              uint64_t v218 = 0;
              while (1)
              {
                uint64_t v219 = (*((uint64_t (**)(void, unsigned char *, uint64_t))s + 3))(*(void *)s, v216, v215);
                if (v219 < 1) {
                  break;
                }
                v216 += v219;
                v218 += v219;
                v215 -= v219;
                if (!v215) {
                  goto LABEL_226;
                }
              }
              uint64_t v218 = v219;
LABEL_226:
              unint64_t v176 = v314;
              if (v298 != v218)
              {
LABEL_249:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 467, 134, 0, "aaByteStreamWriteExpected", v177, v178, v282);
                goto LABEL_149;
              }
              unint64_t v181 = v298 + v296;
              unint64_t v209 = v217 - v298;
              if (v217 == v298)
              {
                uint64_t v182 = v285;
                unint64_t v185 = v287;
                uint64_t v140 = v310;
                uint64_t v164 = v300;
                unint64_t v220 = v289;
                uint64_t v180 = v294;
                goto LABEL_231;
              }
            }
            __int16 v227 = 466;
LABEL_251:
            uint64_t v228 = "aaByteStreamPReadExpected";
            goto LABEL_253;
          }
          unint64_t v185 = 0;
        }
        unint64_t v220 = v289;
LABEL_231:
        v182 += v185;
        unint64_t v183 = v220 + 1;
        uint64_t v179 = v292;
        if (v183 >= *(void *)(v124 + 18)) {
          goto LABEL_242;
        }
      }
    }
    uint64_t v182 = 0;
    unint64_t v181 = 0;
LABEL_242:
    if (v181 != *(void *)(v164 + 2080))
    {
      __int16 v227 = 472;
LABEL_246:
      uint64_t v228 = "bad controls";
LABEL_253:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v227, 134, 0, v228, v177, v178, v282);
      goto LABEL_254;
    }
    uint64_t v224 = v182;
    if (AAByteStreamClose(s) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 475, 134, 0, "AAByteStreamClose", v225, v226, v282);
      int v163 = 0;
    }
    else
    {
      int v163 = 1;
    }
    off_t v243 = AAByteStreamSeek(v129, 0, 1);
    v299[1] = v243;
    if ((v243 & 0x8000000000000000) == 0)
    {
      if (*(int *)(a1 + 40) >= 2)
      {
        unint64_t v246 = "Diff";
        if (!v310) {
          unint64_t v246 = "Literal";
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "%s stream: %llu bytes -> %llu bytes\n", v246, v224, v243 - *v299);
      }
      __int16 v162 = 0;
      goto LABEL_255;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 480, 134, 0, "AAByteStreamSeek", v244, v245, v282);
LABEL_148:
    __int16 v162 = 0;
LABEL_149:
    int v163 = 0;
LABEL_255:
    if (AAByteStreamClose(v162) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 489, 134, 0, "AAByteStreamClose", v229, v230, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v316) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 490, 134, 0, "AAByteStreamClose", v231, v232, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v306) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 491, 134, 0, "AAByteStreamClose", v233, v234, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v308) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 492, 134, 0, "AAByteStreamClose", v235, v236, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose((AAByteStream)v318) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 493, 134, 0, "AAByteStreamClose", v237, v238, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v302) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 494, 134, 0, "AAByteStreamClose", v239, v240, v282);
      int v163 = 0;
    }
    if (AAByteStreamClose(v304) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 495, 134, 0, "AAByteStreamClose", v241, v242, v282);
      int v163 = 0;
    }
    free(v312);
    free(v314);
    if (!v163)
    {
      char v254 = "patch_write_stream";
      __int16 v255 = 539;
      goto LABEL_302;
    }
    uint64_t v140 = v310 + 1;
  }
  while ((unint64_t)(v310 + 1) <= *(void *)a1);
  if (!*((void *)v129 + 5)) {
    goto LABEL_341;
  }
  uint64_t v271 = 0;
  uint64_t v272 = 0;
  uint64_t v273 = v124;
  unint64_t v274 = v119;
  while (1)
  {
    uint64_t v275 = (*((uint64_t (**)(void, uint64_t, unint64_t, uint64_t))v129 + 5))(*(void *)v129, v273, v274, v272);
    if (v275 < 1) {
      break;
    }
    v273 += v275;
    v271 += v275;
    v272 += v275;
    v274 -= v275;
    if (!v274) {
      goto LABEL_335;
    }
  }
  uint64_t v271 = v275;
LABEL_335:
  if (v119 != v271)
  {
LABEL_341:
    char v254 = "aaByteStreamPWriteExpected";
    __int16 v255 = 543;
    goto LABEL_302;
  }
  int v279 = *(_DWORD *)(a1 + 40);
  if (v279 > 1)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "  Metadata: %llu bytes\n  Controls: %llu bytes\n", *(void *)(v124 + 38) - *(void *)(v124 + 30), *(void *)(v124 + 46) - *(void *)(v124 + 38));
    int v279 = *(_DWORD *)(a1 + 40);
  }
  if (v279 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu final patch size\n", *(void *)(v124 + 8 * *(unsigned __int16 *)(v124 + 8) + 46));
  }
  int v262 = 0;
LABEL_304:
  if (AAByteStreamClose(v129) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 562, 134, 0, "AAByteStreamClose", v263, v264, v282);
    free((void *)v124);
  }
  else
  {
    free((void *)v124);
    if (!v262)
    {
      uint64_t v104 = 0;
      goto LABEL_114;
    }
  }
  uint64_t v105 = "patch_write";
  __int16 v106 = 615;
LABEL_113:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", v106, 134, 0, v105, v17, v18, v282);
  uint64_t v104 = 0xFFFFFFFFLL;
LABEL_114:
  unint64_t v120 = 0;
  do
    rawimg_destroy((uint64_t *)v11[v120++]);
  while (v120 <= *(void *)a1);
  free(v11);
LABEL_117:
  BXDiff5Data_free((uint64_t)&v319);
  return v104;
}

double BXDiff5Data_free(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    if (*(void *)(a1 + 16))
    {
      unint64_t v3 = 0;
      uint64_t v4 = 40;
      do
      {
        free(*(void **)(*(void *)(a1 + 24) + v4));
        ++v3;
        v4 += 80;
      }
      while (v3 < *(void *)(a1 + 16));
      unint64_t v2 = *(void **)(a1 + 24);
    }
    free(v2);
  }
  free(*(void **)(a1 + 72));
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t controls_combo_enforce_copy_fork_boundary(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  unint64_t v9 = a2[11];
  if (v9)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v36 = a2[2];
    uint64_t v14 = v36 + 2;
    uint64_t v15 = 8 * (v36 + 2);
    if (v36 == 0 || v36 >= 0xFFFFFFFFFFFFFFFELL) {
      uint64_t v14 = 2;
    }
    uint64_t v35 = 8 * v14 - 8;
    uint64_t v16 = -1;
    while (1)
    {
      uint64_t v17 = (char *)a2[9];
      uint64_t v18 = *(void *)&v17[v11];
      if (v18 >= 0) {
        unint64_t v19 = *(void *)&v17[v11];
      }
      else {
        unint64_t v19 = 0x8000000000000000 - v18;
      }
      unint64_t v20 = *(void *)(v8 + 2072);
      unint64_t v21 = v19 + v13;
      uint64_t v22 = v20 - v13;
      if (v20 > v13 && v21 > v20)
      {
        unint64_t v25 = v9 + 1;
        a2[11] = v25;
        if (v15 * v25 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_32;
        }
        uint64_t v26 = (char *)realloc(v17, v15 * v25);
        if (!v26)
        {
          free(v17);
LABEL_32:
          a2[9] = 0;
          uint64_t v32 = "aaReallocf";
          __int16 v33 = 88;
LABEL_33:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_combo_enforce_copy_fork_boundary", v33, 134, 0, v32, a7, a8, v34);
          return 0xFFFFFFFFLL;
        }
        a2[9] = v26;
        AAByteStream v27 = (uint64_t *)&v26[v11];
        uint64_t v28 = (unint64_t *)&v26[v11 + v15];
        memmove(v28, &v26[v11], v15 * (v16 + a2[11]));
        uint64_t v29 = 0x8000000000000000 - v22;
        if (v22 >= 0) {
          uint64_t v29 = v22;
        }
        uint64_t *v27 = v29;
        if (v36 <= 0xFFFFFFFFFFFFFFFDLL) {
          bzero(v27 + 1, v35);
        }
        unint64_t v30 = v19 - v22;
        if ((uint64_t)(v19 - v22) < 0) {
          unint64_t v30 = 0x8000000000000000 - (v19 - v22);
        }
        unint64_t *v28 = v30;
        unint64_t v9 = a2[11];
        unint64_t v13 = v20;
        uint64_t v8 = a1;
      }
      else
      {
        uint64_t v24 = *(void *)&v17[v11 + 8];
        if (v24 < 0) {
          uint64_t v24 = 0x8000000000000000 - v24;
        }
        unint64_t v13 = v21 + v24;
      }
      ++v12;
      v11 += v15;
      --v16;
      if (v12 >= v9) {
        goto LABEL_27;
      }
    }
  }
  unint64_t v13 = 0;
LABEL_27:
  if (v13 != *(void *)(v8 + 2080))
  {
    uint64_t v32 = "SIZE MISMATCH";
    __int16 v33 = 108;
    goto LABEL_33;
  }
  return 0;
}

uint64_t *AEADecryptToFileAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  strcpy(v30, ".tmp_decrypt");
  memset(&v29, 0, sizeof(v29));
  unint64_t v12 = malloc(0x898uLL);
  uint64_t v13 = (uint64_t)v12;
  if (v12)
  {
    memset_s(v12, 0x898uLL, 0, 0x898uLL);
    uint64_t v14 = (uint64_t *)malloc(0x38uLL);
    uint64_t v15 = v14;
    if (v14)
    {
      memset_s(v14, 0x38uLL, 0, 0x38uLL);
      *(void *)(v13 + 8) = a2;
      *(void *)(v13 + 16) = a3;
      *(void *)(v13 + 24) = a4;
      *(void *)(v13 + 2084) = -1;
      *(_DWORD *)(v13 + 2080) = a5 >> 62;
      if (pthread_mutex_init((pthread_mutex_t *)(v13 + 2136), 0))
      {
        uint64_t v18 = "MutexInit";
        __int16 v19 = 290;
      }
      else if (strlen(a1) - 1012 > 0xFFFFFFFFFFFFFBFELL)
      {
        __strlcpy_chk();
        __strlcpy_chk();
        __strlcat_chk();
        int v25 = stat((const char *)(v13 + 32), &v29);
        if (v25 || (v29.st_mode & 0xF000) == 0x8000)
        {
          int v26 = stat((const char *)(v13 + 1056), &v29);
          if (v26 || (v29.st_mode & 0xF000) == 0x8000)
          {
            if (v26 | v25)
            {
              AAByteStream v27 = AEADecryptAsyncStreamOpen(v13, (uint64_t)setupContext, (uint64_t)verifySegment, (uint64_t)processSegment_0, a5, a6);
              *(void *)uint64_t v13 = v27;
              if (v27)
              {
                *uint64_t v15 = v13;
                v15[1] = (uint64_t)decryptToFileAsyncClose;
                _OWORD v15[4] = (uint64_t)decryptToFileAsyncCancel;
                void v15[2] = (uint64_t)decryptToFileAsyncGetRange;
                v15[3] = (uint64_t)decryptToFileAsyncProcess;
                return v15;
              }
              uint64_t v18 = "creating DecryptAsyncStream";
              __int16 v19 = 313;
            }
            else
            {
              char v28 = v13 + 32;
              uint64_t v18 = "Both file and temp file exist: %s";
              __int16 v19 = 309;
            }
          }
          else
          {
            char v28 = v13 + 32;
            uint64_t v18 = "Temp file exists but is not a regular file: %s";
            __int16 v19 = 306;
          }
        }
        else
        {
          char v28 = v13 + 32;
          uint64_t v18 = "File exists but is not a regular file: %s";
          __int16 v19 = 301;
        }
      }
      else
      {
        char v28 = (char)a1;
        uint64_t v18 = "Filename is too long: %s";
        __int16 v19 = 293;
      }
      int v23 = 0;
    }
    else
    {
      int v23 = *__error();
      uint64_t v18 = "malloc";
      __int16 v19 = 281;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"AEADecryptToFileAsyncStreamOpen", v19, 98, v23, v18, v16, v17, v28);
  }
  else
  {
    unint64_t v20 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"AEADecryptToFileAsyncStreamOpen", 279, 98, *v20, "malloc", v21, v22, v28);
    uint64_t v15 = 0;
  }
  decryptToFileAsyncClose(v13);
  free(v15);
  return 0;
}

uint64_t setupContext(uint64_t a1, AEAContext context, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(&v20, 0, sizeof(v20));
  uint64_t v10 = *(uint64_t (**)(void, AEAContext))(a1 + 16);
  if (v10 && (v10(*(void *)(a1 + 8), context) & 0x80000000) != 0)
  {
    uint64_t v11 = "Client context callback returned an error";
    __int16 v12 = 58;
    goto LABEL_9;
  }
  if (!*(_DWORD *)(a1 + 2096))
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 2096) = 1;
    return result;
  }
  if ((*(_DWORD *)(a1 + 2084) & 0x80000000) == 0 || (*(_DWORD *)(a1 + 2088) & 0x80000000) == 0)
  {
    uint64_t v11 = "Invalid state, file already open";
    __int16 v12 = 64;
LABEL_9:
    int v14 = 0;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"setupContext", v12, 98, v14, v11, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 2104) = AEAContextGetFieldUInt(context, 0xDu);
  *(void *)(a1 + 2112) = AEAContextGetFieldUInt(context, 4u);
  if (!stat((const char *)(a1 + 32), &v20) && (v20.st_mode & 0xF000) == 0x8000)
  {
    if (v20.st_size && v20.st_size != *(void *)(a1 + 2104))
    {
      char v19 = a1 + 32;
      uint64_t v11 = "Destination file exists and size doesn't match: %s";
      __int16 v12 = 77;
      goto LABEL_9;
    }
    rename((const std::__fs::filesystem::path *)(a1 + 32), (const std::__fs::filesystem::path *)(a1 + 1056), v15);
    if (v16)
    {
      int v14 = *__error();
      char v19 = a1 + 32;
      uint64_t v11 = "rename: %s";
      __int16 v12 = 82;
      goto LABEL_10;
    }
    if (*(_DWORD *)(a1 + 2080)) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Verifying file: %s\n", (const char *)(a1 + 32));
    }
  }
  if (stat((const char *)(a1 + 1056), &v20) || (v20.st_mode & 0xF000) != 0x8000)
  {
    *(_DWORD *)(a1 + 2088) = open((const char *)(a1 + 1056), 1537, 420);
    *(_DWORD *)(a1 + 2092) = 1;
    int v17 = *(_DWORD *)(a1 + 2084);
  }
  else
  {
    int v17 = open((const char *)(a1 + 1056), 0);
    *(_DWORD *)(a1 + 2084) = v17;
  }
  int v18 = *(_DWORD *)(a1 + 2088);
  if (v17 < 0)
  {
    if (v18 < 0)
    {
      int v14 = *__error();
      char v19 = a1 + 32;
      uint64_t v11 = "open: %s";
      __int16 v12 = 98;
      goto LABEL_10;
    }
  }
  else if (v18 < 0)
  {
    return 0;
  }
  uint64_t result = ftruncate(v18, *(void *)(a1 + 2104));
  if (result)
  {
    int v14 = *__error();
    char v19 = a1 + 32;
    uint64_t v11 = "truncate to final size: %s";
    __int16 v12 = 101;
    goto LABEL_10;
  }
  return result;
}

uint64_t verifySegment(uint64_t a1, unint64_t a2, uint64_t a3, int a4, const void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (!*(_DWORD *)(a1 + 2092))
  {
    size_t v11 = *(void *)(a1 + 2112);
    if (v11 < a2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"verifySegment", 117, 98, 0, "Invalid segment size", a7, a8, v31);
      return 0xFFFFFFFFLL;
    }
    int v33 = 0;
    memset(v32, 0, sizeof(v32));
    if (v11 < 0x2000000001)
    {
      __int16 v12 = malloc(v11);
      if (v12)
      {
        unint64_t v21 = 0;
        while (a2 > v21)
        {
          ssize_t v22 = pread(*(_DWORD *)(a1 + 2084), (char *)v12 + v21, a2 - v21, v21 + a3);
          if (v22) {
            int v23 = 0;
          }
          else {
            int v23 = 5;
          }
          v21 += v22 & ~(v22 >> 63);
          if (v22 < 0) {
            int v23 = 4;
          }
          if (v23)
          {
            if (v23 == 4) {
              goto LABEL_21;
            }
            break;
          }
        }
        if (v21 == a2)
        {
          int v24 = aeaChecksum((uint64_t)v32, a4, v12, a2, v17, v18, v19, v20);
          uint64_t v8 = 0;
          if (v24 < 0 || LODWORD(v32[0]) != a6) {
            goto LABEL_22;
          }
          if (!memcmp((char *)v32 + 4, a5, a6))
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 2128), a2, memory_order_relaxed);
            AAByteStream v27 = *(uint64_t (**)(void, __n128))(a1 + 24);
            if (v27
              && ((unint64_t v28 = *(void *)(a1 + 2104)) == 0
                ? (v25.n128_u64[0] = 0)
                : (v25.n128_f32[0] = (float)((float)*(unint64_t *)(a1 + 2128) * 100.0) / (float)v28),
                  (v27(*(void *)(a1 + 8), v25) & 0x80000000) != 0))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"verifySegment", 144, 98, 0, "Client progress callback reported an error", v29, v30, v31);
              uint64_t v8 = 0xFFFFFFFFLL;
            }
            else
            {
              if (*(_DWORD *)(a1 + 2080) >= 3u) {
                fprintf((FILE *)*MEMORY[0x263EF8348], "Segment verified: offset=%llu size=%zu\n", a3, a2);
              }
              uint64_t v8 = 1;
            }
            goto LABEL_22;
          }
        }
      }
LABEL_21:
      uint64_t v8 = 0;
    }
    else
    {
      __int16 v12 = 0;
      uint64_t v8 = 0;
      *__error() = 12;
    }
LABEL_22:
    free(v12);
    return v8;
  }
  return 0;
}

uint64_t processSegment_0(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, __n128 a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if ((*(_DWORD *)(a1 + 2088) & 0x80000000) == 0)
  {
LABEL_2:
    unint64_t v13 = 0;
    do
    {
      unint64_t v14 = v13;
      if (a2 <= v13) {
        break;
      }
      ssize_t v15 = pwrite(*(_DWORD *)(a1 + 2088), (const void *)(a4 + v13), a2 - v13, v13 + a3);
      unint64_t v13 = v15 + v14;
    }
    while (v15 > 0);
    if (a2 == v14)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 2128), a2, memory_order_relaxed);
      if (*(_DWORD *)(a1 + 2080) >= 3u) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Segment processed: offset=%llu size=%zu\n", a3, a2);
      }
    }
    else
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 2120), a2, memory_order_relaxed);
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"processSegment", 181, 98, 0, "Segment write failed: offset=%llu size=%zu\n", a8, a9, a3);
    }
    uint64_t v18 = *(uint64_t (**)(void, __n128))(a1 + 24);
    if (!v18) {
      return 0;
    }
    unint64_t v19 = *(void *)(a1 + 2104);
    if (v19) {
      a5.n128_f32[0] = (float)((float)*(unint64_t *)(a1 + 2128) * 100.0) / (float)v19;
    }
    else {
      a5.n128_u64[0] = 0;
    }
    if ((v18(*(void *)(a1 + 8), a5) & 0x80000000) == 0) {
      return 0;
    }
    int v16 = "Client progress callback reported an error";
    __int16 v17 = 190;
    goto LABEL_22;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2136)))
  {
    int v16 = "MutexInit";
    __int16 v17 = 165;
  }
  else
  {
    if ((*(_DWORD *)(a1 + 2088) & 0x80000000) != 0) {
      *(_DWORD *)(a1 + 2088) = open((const char *)(a1 + 1056), 2);
    }
    if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2136)))
    {
      if ((*(_DWORD *)(a1 + 2088) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"processSegment", 168, 98, 0, "Can't reopen %s for writing", a8, a9, a1 + 32);
        return 0xFFFFFFFFLL;
      }
      goto LABEL_2;
    }
    int v16 = "MutexUnlock";
    __int16 v17 = 167;
  }
LABEL_22:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"processSegment", v17, 98, 0, v16, a8, a9, v21);
  return 0xFFFFFFFFLL;
}

uint64_t decryptToFileAsyncClose(uint64_t a1)
{
  if (a1)
  {
    uint64_t v4 = AAAsyncByteStreamClose(*(uint64_t (***)(void))a1);
    if ((v4 & 0x80000000) != 0) {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"decryptToFileAsyncClose", 207, 98, 0, "Async stream reported errors", v2, v3, v18);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 2136));
    unint64_t v7 = atomic_load((unint64_t *)(a1 + 2128));
    unint64_t v8 = atomic_load((unint64_t *)(a1 + 2120));
    if (!v4)
    {
      if (v7 == *(void *)(a1 + 2104) && v8 == 0)
      {
        uint64_t v4 = 0;
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"decryptToFileAsyncClose", 216, 98, 0, "Some segments failed to process", v5, v6, v18);
        uint64_t v4 = 0xFFFFFFFFLL;
      }
    }
    int v10 = *(_DWORD *)(a1 + 2084);
    if (v10 < 0)
    {
      int v12 = *(_DWORD *)(a1 + 2088);
      if (v12 < 0)
      {
        if (v4) {
          goto LABEL_24;
        }
        goto LABEL_21;
      }
    }
    else
    {
      close(v10);
      int v12 = *(_DWORD *)(a1 + 2088);
      if (v12 < 0)
      {
        if (!v4)
        {
LABEL_18:
          rename((const std::__fs::filesystem::path *)(a1 + 1056), (const std::__fs::filesystem::path *)(a1 + 32), v11);
          if (v13)
          {
            unint64_t v14 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"decryptToFileAsyncClose", 227, 98, *v14, "rename: %s", v15, v16, a1 + 32);
            uint64_t v4 = 0xFFFFFFFFLL;
            goto LABEL_24;
          }
LABEL_21:
          if (*(_DWORD *)(a1 + 2080) >= 2u) {
            fprintf((FILE *)*MEMORY[0x263EF8348], "Decrypted file: %s\n", (const char *)(a1 + 32));
          }
          uint64_t v4 = 0;
        }
LABEL_24:
        free((void *)a1);
        return v4;
      }
    }
    close(v12);
    if (!v4) {
      goto LABEL_18;
    }
    goto LABEL_24;
  }
  return 0;
}

void *decryptToFileAsyncCancel(void **a1)
{
  return AAAsyncByteStreamCancel(*a1);
}

uint64_t decryptToFileAsyncGetRange(void **a1, unint64_t *a2, uint64_t *a3)
{
  return AAAsyncByteStreamGetRange(*a1, a2, a3);
}

uint64_t decryptToFileAsyncProcess(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*a1, a2, a3, a4);
}

uint64_t AEADecryptToFileChunkAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, unsigned int a8)
{
  int v12 = AEADecryptToFileAsyncStreamOpen(a1, a2, a3, a4, a7 | 0x200000000000000, a8);
  if (v12)
  {
    return aaCompositeChunkAsyncStreamOpen((uint64_t)v12, a5, a6, a7, a8);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptToFileAsyncStream.c", (uint64_t)"AEADecryptToFileChunkAsyncStreamOpen", 349, 98, 0, "AEADecryptToFileAsyncStreamOpen", v13, v14, v16);
    return 0;
  }
}

void *AATempStreamOpen(unint64_t a1)
{
  return AATempStreamOpenWithDirectory(a1, 0);
}

void *AATempStreamOpenWithDirectory(unint64_t a1, const char *a2)
{
  uint64_t v4 = calloc(1uLL, 0x68uLL);
  uint64_t v5 = (char *)malloc(0x88uLL);
  uint64_t v6 = v5;
  if (v5 && (memset_s(v5, 0x88uLL, 0, 0x88uLL), v4))
  {
    if (a2)
    {
      size_t v7 = strlen(a2);
      size_t v8 = v7 + 1;
      if (v7 + 1 < 0x2000000001)
      {
        uint64_t v15 = malloc(v7 + 1);
        unint64_t v9 = v15;
        if (v15) {
          memcpy(v15, a2, v8);
        }
      }
      else
      {
        unint64_t v9 = 0;
        *__error() = 12;
      }
    }
    else
    {
      unint64_t v9 = 0;
    }
    *((void *)v6 + 13) = v9;
    uint64_t v16 = a1 >> 20;
    if (a1 == -1) {
      uint64_t v16 = -1;
    }
    *((void *)v6 + 1) = 0x100000;
    *((void *)v6 + 2) = v16;
    if ((pthread_mutex_init((pthread_mutex_t *)(v6 + 40), 0) & 0x80000000) == 0)
    {
      void *v4 = v6;
      v4[1] = tempStreamClose;
      v4[7] = tempStreamCancel;
      v4[2] = tempStreamRead;
      v4[4] = tempStreamPRead;
      v4[6] = tempStreamSeek;
      void v4[3] = tempStreamWrite;
      v4[5] = tempStreamPWrite;
      v4[8] = tempStreamTruncate;
      return v4;
    }
    int v10 = *__error();
    uint64_t v13 = "mutex init";
    __int16 v14 = 326;
  }
  else
  {
    int v10 = *__error();
    uint64_t v13 = "malloc";
    __int16 v14 = 320;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"AATempStreamOpenWithDirectory", v14, 50, v10, v13, v11, v12, v18);
  free(v6);
  free(v4);
  return 0;
}

uint64_t tempStreamClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 128));
    AAByteStreamClose(*(AAByteStream *)(result + 112));
    uint64_t v3 = *(void **)(v1 + 32);
    if (v3)
    {
      if (*(void *)(v1 + 24))
      {
        unint64_t v4 = 0;
        do
          free(*(void **)(*(void *)(v1 + 32) + 8 * v4++));
        while (v4 < *(void *)(v1 + 24));
        uint64_t v3 = *(void **)(v1 + 32);
      }
      free(v3);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
    free(*(void **)(v1 + 104));
    free((void *)v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

void tempStreamCancel(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v1, 1u);
}

ssize_t tempStreamRead(uint64_t a1, void *a2, size_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  if (*(void *)(a1 + 112)) {
    return AAByteStreamRead(*(AAByteStream *)(a1 + 112), a2, a3);
  }
  return tempStreamPRead(a1, (char *)a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 120), a3));
}

ssize_t tempStreamPRead(uint64_t a1, char *buf, size_t a3, off_t offset)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  unint64_t v7 = offset;
  size_t v8 = buf;
  int v10 = *(AAByteStream_impl **)(a1 + 112);
  if (!v10)
  {
    if (((offset | a3) & 0x8000000000000000) == 0)
    {
      int64_t v11 = offset + a3;
      if (!__OFADD__(offset, a3))
      {
        if (*(void *)a1 <= offset) {
          return 0;
        }
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
        {
          int v20 = *__error();
          int v23 = "mutex lock";
          __int16 v24 = 120;
        }
        else
        {
          if (v11 >= *(void *)a1) {
            unint64_t v12 = *(void *)a1;
          }
          else {
            unint64_t v12 = v11;
          }
          uint64_t v5 = 0;
          if (v12 > v7)
          {
            unint64_t v13 = *(void *)(a1 + 8);
            unint64_t v14 = v7 / v13;
            unint64_t v15 = v7 / v13 * v13;
            unint64_t v16 = v15 + v13;
            do
            {
              if (v16 >= v12) {
                unint64_t v17 = v12;
              }
              else {
                unint64_t v17 = v16;
              }
              memcpy(v8, (const void *)(*(void *)(*(void *)(a1 + 32) + 8 * v14) + v7 - v15), v17 - v7);
              v8 += v17 - v7;
              v5 += v17 - v7;
              ++v14;
              uint64_t v18 = *(void *)(a1 + 8);
              v15 += v18;
              unint64_t v7 = v17;
              BOOL v19 = v12 > v16;
              v16 += v18;
            }
            while (v19);
          }
          if ((pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) & 0x80000000) == 0) {
            return v5;
          }
          int v20 = *__error();
          int v23 = "mutex unlock";
          __int16 v24 = 148;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPRead", v24, 50, v20, v23, v21, v22, v26);
        int v25 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v25, 1u);
      }
    }
    return -1;
  }

  return AAByteStreamPRead(v10, buf, a3, offset);
}

off_t tempStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  if (!*(void *)(a1 + 112))
  {
    if (a3)
    {
      if (a3 == 1)
      {
        a2 += atomic_fetch_add((atomic_ullong *volatile)(a1 + 120), a2);
        return a2;
      }
      if (a3 != 2) {
        return -1;
      }
      a2 += *(void *)a1;
    }
    atomic_store(a2, (unint64_t *)(a1 + 120));
    return a2;
  }
  return AAByteStreamSeek(*(AAByteStream *)(a1 + 112), a2, a3);
}

ssize_t tempStreamWrite(uint64_t a1, void *a2, size_t a3)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  if (*(void *)(a1 + 112)) {
    return AAByteStreamWrite(*(AAByteStream *)(a1 + 112), a2, a3);
  }
  return tempStreamPWrite(a1, (char *)a2, a3, atomic_fetch_add((atomic_ullong *volatile)(a1 + 120), a3));
}

ssize_t tempStreamPWrite(uint64_t a1, char *buf, size_t nbyte, unint64_t offset)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return -1;
  }
  unint64_t v7 = offset;
  unint64_t v9 = buf;
  int64_t v11 = *(AAByteStream_impl **)(a1 + 112);
  if (!v11)
  {
    if (((offset | nbyte) & 0x8000000000000000) != 0) {
      return -1;
    }
    int64_t v12 = offset + nbyte;
    if (__OFADD__(offset, nbyte)) {
      return -1;
    }
    unint64_t v13 = (pthread_mutex_t *)(a1 + 40);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
    {
      int v26 = *__error();
      uint64_t v29 = "mutex lock";
      __int16 v30 = 164;
      goto LABEL_37;
    }
    if (v12 <= *(void *)a1) {
      uint64_t v20 = *(void *)a1;
    }
    else {
      uint64_t v20 = v7 + nbyte;
    }
    if ((resizeStream(a1, v20, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
    {
      char v31 = "resizing stream";
      __int16 v32 = 170;
    }
    else
    {
      int v23 = *(AAByteStream_impl **)(a1 + 112);
      if (!v23)
      {
        if (v12 <= v7)
        {
          ssize_t v5 = 0;
        }
        else
        {
          ssize_t v5 = 0;
          unint64_t v33 = *(void *)(a1 + 8);
          unint64_t v34 = v7 / v33;
          unint64_t v35 = v7 / v33 * v33;
          unint64_t v36 = v35 + v33;
          do
          {
            if (v36 >= v12) {
              unint64_t v37 = v12;
            }
            else {
              unint64_t v37 = v36;
            }
            memcpy((void *)(*(void *)(*(void *)(a1 + 32) + 8 * v34) + v7 - v35), v9, v37 - v7);
            v9 += v37 - v7;
            v5 += v37 - v7;
            ++v34;
            uint64_t v38 = *(void *)(a1 + 8);
            v35 += v38;
            unint64_t v7 = v37;
            BOOL v39 = v12 > v36;
            v36 += v38;
          }
          while (v39);
        }
        int v25 = 0;
        uint64_t v40 = *(void *)a1;
        if (v12 > *(void *)a1) {
          uint64_t v40 = v12;
        }
        *(void *)a1 = v40;
        unint64_t v13 = (pthread_mutex_t *)(a1 + 40);
        goto LABEL_33;
      }
      ssize_t v24 = AAByteStreamPWrite(v23, v9, nbyte, v7);
      if ((v24 & 0x8000000000000000) == 0)
      {
        ssize_t v5 = v24;
        int v25 = 0;
LABEL_33:
        if ((pthread_mutex_unlock(v13) & 0x80000000) == 0)
        {
          if (!v25) {
            return v5;
          }
          goto LABEL_38;
        }
        int v26 = *__error();
        uint64_t v29 = "mutex unlock";
        __int16 v30 = 209;
LABEL_37:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", v30, 50, v26, v29, v27, v28, v42);
LABEL_38:
        int v41 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v41, 1u);
        return -1;
      }
      char v31 = "temp file write";
      __int16 v32 = 176;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", v32, 50, 0, v31, v21, v22, v42);
    ssize_t v5 = 0;
    int v25 = 1;
    goto LABEL_33;
  }

  return AAByteStreamPWrite(v11, buf, nbyte, offset);
}

uint64_t tempStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(a1 + 128))) {
    return 0xFFFFFFFFLL;
  }
  int64_t v12 = *(void **)(a1 + 112);
  if (v12)
  {
    return AAByteStreamTruncate(v12);
  }
  if (a2 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 271, 50, 0, "invalid length", a7, a8, v30);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    uint64_t v22 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 272, 50, *v22, "mutex lock", v23, v24, v30);
    int v25 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v25, 1u);
    return 0xFFFFFFFFLL;
  }
  if ((resizeStream(a1, a2, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 274, 50, 0, "resize stream", v19, v20, v30);
    int v21 = 0;
  }
  else
  {
    int v21 = 1;
  }
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    int v26 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 276, 50, *v26, "mutex lock", v27, v28, v30);
    int v29 = 0;
    int v21 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 128), (unsigned int *)&v29, 1u);
  }
  if (v21) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t resizeStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 112))
  {
    size_t v8 = "invalid state";
    __int16 v9 = 64;
LABEL_3:
    int v10 = 0;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"resizeStream", v9, 50, v10, v8, a7, a8, v42);
    return 0xFFFFFFFFLL;
  }
  if (*(void *)a1 >= a2) {
    goto LABEL_51;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  if (__OFADD__(a2, v14))
  {
    char v42 = a2;
    size_t v8 = "new size out of range: %zu";
    __int16 v9 = 70;
    goto LABEL_3;
  }
  uint64_t v15 = (a2 + v14 - 1) / v14;
  if (v15 <= *(void *)(a1 + 16))
  {
    unint64_t v32 = *(void *)(a1 + 24);
    while (v32 < v15)
    {
      if (v32) {
        v32 *= 2;
      }
      else {
        unint64_t v32 = 32;
      }
    }
    if (8 * v32 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_55:
      *(void *)(a1 + 32) = 0;
      int v10 = *__error();
      size_t v8 = "malloc";
      __int16 v9 = 89;
      goto LABEL_4;
    }
    unint64_t v33 = *(void **)(a1 + 32);
    unint64_t v34 = (char *)realloc(v33, 8 * v32);
    if (!v34)
    {
      free(v33);
      goto LABEL_55;
    }
    *(void *)(a1 + 32) = v34;
    memset_s(&v34[8 * *(void *)(a1 + 24)], 8 * (v32 - *(void *)(a1 + 24)), 0, 8 * (v32 - *(void *)(a1 + 24)));
    *(void *)(a1 + 24) = v32;
    uint64_t v35 = v15 - 1;
    while (v35 != -1 && !*(void *)(*(void *)(a1 + 32) + 8 * v35))
    {
      rsize_t v36 = *(void *)(a1 + 8);
      if (v36 < 0x2000000001)
      {
        uint64_t v38 = malloc(*(void *)(a1 + 8));
        unint64_t v37 = v38;
        if (v38) {
          memset_s(v38, v36, 0, v36);
        }
      }
      else
      {
        unint64_t v37 = 0;
        *__error() = 12;
      }
      *(void *)(*(void *)(a1 + 32) + 8 * v35) = v37;
      if (!*(void *)(*(void *)(a1 + 32) + 8 * v35--))
      {
        int v10 = *__error();
        size_t v8 = "malloc";
        __int16 v9 = 99;
        goto LABEL_4;
      }
    }
LABEL_51:
    uint64_t result = 0;
    *(void *)a1 = a2;
    return result;
  }
  uint64_t v16 = AATempFileStreamOpenWithDirectory(*(const char **)(a1 + 104));
  *(void *)(a1 + 112) = v16;
  if (!v16)
  {
    uint64_t v40 = "AATempFileStreamOpen";
    __int16 v41 = 36;
LABEL_57:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"offloadToFile", v41, 50, 0, v40, v17, v18, v42);
    size_t v8 = "offload to file";
    __int16 v9 = 76;
    goto LABEL_3;
  }
  uint64_t v19 = (void *)(a1 + 24);
  if (*(void *)(a1 + 24))
  {
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    while (*(void *)a1 > v21)
    {
      if (*(void *)(a1 + 8) >= *(void *)a1 - v21) {
        uint64_t v22 = *(void *)a1 - v21;
      }
      else {
        uint64_t v22 = *(void *)(a1 + 8);
      }
      uint64_t v23 = *(void *)(a1 + 112);
      if (*(void *)(v23 + 24))
      {
        uint64_t v24 = 0;
        if (v22)
        {
          uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8 * v20);
          uint64_t v26 = v22;
          while (1)
          {
            uint64_t v27 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v23 + 24))(*(void *)v23, v25, v26);
            if (v27 < 1) {
              break;
            }
            v25 += v27;
            v24 += v27;
            v26 -= v27;
            if (!v26) {
              goto LABEL_26;
            }
          }
          uint64_t v24 = v27;
        }
      }
      else
      {
        uint64_t v24 = -1;
      }
LABEL_26:
      if (v24 != v22)
      {
        uint64_t v40 = "writing data to temp file";
        __int16 v41 = 43;
        goto LABEL_57;
      }
      v21 += v22;
      if ((unint64_t)++v20 >= *v19)
      {
        if (!*v19) {
          goto LABEL_31;
        }
        break;
      }
    }
    unint64_t v28 = 0;
    do
      free(*(void **)(*(void *)(a1 + 32) + 8 * v28++));
    while (v28 < *(void *)(a1 + 24));
  }
LABEL_31:
  free(*(void **)(a1 + 32));
  *uint64_t v19 = 0;
  *(void *)(a1 + 32) = 0;
  if ((AAByteStreamTruncate(*(void **)(a1 + 112)) & 0x80000000) != 0)
  {
    size_t v8 = "truncate temp file";
    __int16 v9 = 78;
    goto LABEL_3;
  }
  int v29 = *(AAByteStream_impl **)(a1 + 112);
  off_t v30 = atomic_load((unint64_t *)(a1 + 120));
  off_t v31 = AAByteStreamSeek(v29, v30, 0);
  uint64_t result = 0;
  if (v31 < 0)
  {
    size_t v8 = "seek temp file";
    __int16 v9 = 80;
    goto LABEL_3;
  }
  return result;
}

uint64_t bxdiff5Alloc(size_t a1, uint64_t *a2, uint64_t a3)
{
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(void *)(a3 + 16) = a1;
  uint64_t v3 = *a2;
  *(_DWORD *)(a3 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a3 = v3;
  if (a1) {
    *(void *)(a3 + 24) = calloc(a1, 0x50uLL);
  }
  return 0;
}

uint64_t bxdiff5Free(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    int v11 = 1;
    do
    {
      uint64_t v12 = *(void *)(a1 + 24);
      if (*(void *)(v12 + v9))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 40, 54, 0, "in[%zu] is not NULL", a7, a8, v10);
        int v11 = 0;
        uint64_t v12 = *(void *)(a1 + 24);
      }
      if (*(void *)(v12 + v9 + 64))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 41, 54, 0, "inPatch[%zu] is not NULL", a7, a8, v10);
        int v11 = 0;
        uint64_t v12 = *(void *)(a1 + 24);
      }
      if (*(void *)(v12 + v9 + 40))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 42, 54, 0, "inControls[%zu] is not NULL", a7, a8, v10);
        int v11 = 0;
      }
      ++v10;
      v9 += 80;
    }
    while (v10 < *(void *)(a1 + 16));
  }
  else
  {
    int v11 = 1;
  }
  if (*(void *)(a1 + 32))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 44, 54, 0, "out is not NULL", a7, a8, v14);
    int v11 = 0;
  }
  if (*(void *)(a1 + 72))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 45, 54, 0, "comboControls is not NULL", a7, a8, v14);
    int v11 = 0;
  }
  if (*(void *)(a1 + 96))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 46, 54, 0, "comboPatch is not NULL", a7, a8, v14);
    int v11 = 0;
  }
  free(*(void **)(a1 + 24));
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  if (v11) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 0xFFFFFFFFLL;
  }
  *(_OWORD *)a1 = 0uLL;
  return result;
}

uint64_t bxdiff5Dump(uint64_t a1, FILE *a2)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v4 = 0;
    ssize_t v5 = (int *)(*(void *)(a1 + 24) + 36);
    uint64_t v6 = *(void *)(a1 + 16);
    do
    {
      int v7 = *v5;
      v5 += 20;
      if (v7) {
        ++v4;
      }
      --v6;
    }
    while (v6);
  }
  else
  {
    uint64_t v4 = 0;
  }
  fprintf(a2, "BXDiff5Data: n=%zu, nUnique=%zu\n", *(void *)(a1 + 16), v4);
  if (*(void *)(a1 + 16))
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 16;
    do
    {
      fprintf(a2, "- input %zu\n", v9);
      uint64_t v11 = *(void *)(a1 + 24);
      if (*(void *)(v11 + 80 * v9))
      {
        fprintf(a2, "    in set, inSize=%zu, inSHA1=", *(void *)(v11 + 80 * v9 + 8));
        for (uint64_t i = 0; i != 20; ++i)
          fprintf(a2, "%02x", *(unsigned __int8 *)(*(void *)(a1 + 24) + v10 + i));
        uint64_t v13 = "unique";
        if (!*(_DWORD *)(*(void *)(a1 + 24) + 80 * v9 + 36)) {
          uint64_t v13 = "non unique";
        }
        fprintf(a2, ", %s", v13);
        fputc(10, a2);
      }
      else
      {
        fwrite("    in is NULL\n", 0xFuLL, 1uLL, a2);
      }
      uint64_t v14 = *(void *)(a1 + 24);
      if (*(void *)(v14 + 80 * v9 + 40))
      {
        uint64_t v15 = v14 + 80 * v9;
        unint64_t v16 = 3 * *(void *)(v15 + 56);
        fprintf(a2, "    inControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(void *)(v15 + 56), *(_DWORD *)(v15 + 48), (v16 >> 17) & 0xFFFFFFFFFFFLL);
        v8 += 8 * v16;
      }
      else
      {
        fwrite("    inControls is NULL\n", 0x17uLL, 1uLL, a2);
      }
      uint64_t v17 = *(void *)(a1 + 24);
      if (*(void *)(v17 + 80 * v9 + 64))
      {
        unint64_t v18 = *(void *)(v17 + 80 * v9 + 72);
        fprintf(a2, "    inPatch set, inPatchSize=%zu (%zu MB)\n", v18, v18 >> 20);
        v8 += v18;
      }
      else
      {
        fwrite("    inPatch is NULL\n", 0x14uLL, 1uLL, a2);
      }
      ++v9;
      v10 += 80;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    unint64_t v8 = 0;
  }
  fwrite("- output\n", 9uLL, 1uLL, a2);
  if (*(void *)(a1 + 32))
  {
    fprintf(a2, "    out set, outSize=%zu, outSHA1=", *(void *)(a1 + 40));
    for (uint64_t j = 0; j != 20; ++j)
      fprintf(a2, "%02x", *(unsigned __int8 *)(a1 + 48 + j));
    fputc(10, a2);
  }
  else
  {
    fwrite("    out is NULL\n", 0x10uLL, 1uLL, a2);
  }
  if (*(void *)(a1 + 72))
  {
    unint64_t v20 = (8 * v4 + 16) * *(void *)(a1 + 88);
    fprintf(a2, "    comboControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(void *)(a1 + 88), *(_DWORD *)(a1 + 80), v20 >> 20);
    v8 += v20;
  }
  else
  {
    fwrite("    comboControls is NULL\n", 0x1AuLL, 1uLL, a2);
  }
  if (*(void *)(a1 + 96))
  {
    unint64_t v21 = *(void *)(a1 + 104);
    fprintf(a2, "    comboPatch set, comboPatchSize=%zu (%zu MB)\n", v21, v21 >> 20);
    v8 += v21;
  }
  else
  {
    fwrite("    comboPatch is NULL\n", 0x17uLL, 1uLL, a2);
  }
  fprintf(a2, "Total size %zu MB\n", v8 >> 20);
  return 0;
}

uint64_t bxdiff5SetIn(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[2] <= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", 122, 54, 0, "invalid I=%zu", a7, a8, a2);
    return 0xFFFFFFFFLL;
  }
  if (!a3 || !a4)
  {
    unint64_t v16 = "invalid in,inSize";
    __int16 v17 = 123;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", v17, 54, 0, v16, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  if (!a1[4])
  {
    unint64_t v16 = "missing out";
    __int16 v17 = 124;
    goto LABEL_16;
  }
  uint64_t v10 = a1[3] + 80 * a2;
  *(void *)uint64_t v10 = a3;
  *(void *)(v10 + 8) = a4;
  getBufferSHA1Digest(a3, a4, (unsigned __int8 *)(v10 + 16));
  unint64_t v11 = a1[2];
  uint64_t v12 = a1[3];
  *(_DWORD *)(v12 + 80 * a2 + 36) = 1;
  if (v11)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    while (1)
    {
      if (a2 != v14)
      {
        uint64_t v15 = a1[3];
        if (*(void *)(v15 + v13))
        {
          if (!sha1cmp(v15 + 80 * a2 + 16, v15 + v13 + 16))
          {
            uint64_t v12 = a1[3];
            *(_DWORD *)(v12 + 80 * a2 + 36) = 0;
            break;
          }
          unint64_t v11 = a1[2];
        }
      }
      ++v14;
      v13 += 80;
      if (v14 >= v11)
      {
        uint64_t v12 = a1[3];
        break;
      }
    }
  }
  uint64_t result = sha1cmp(v12 + 80 * a2 + 16, (uint64_t)(a1 + 6));
  if (result) {
    return 0;
  }
  *(_DWORD *)(a1[3] + 80 * a2 + 36) = 0;
  return result;
}

uint64_t bxdiff5SetOut(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 && a3)
  {
    *(void *)(a1 + 32) = a2;
    *(void *)(a1 + 40) = a3;
    getBufferSHA1Digest(a2, a3, (unsigned __int8 *)(a1 + 48));
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetOut", 155, 54, 0, "invalid out,outSize", a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5CreateInControls(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    unint64_t v14 = "invalid input index";
    __int16 v15 = 247;
    goto LABEL_5;
  }
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = v10 + 80 * a2;
  uint64_t v13 = *(void *)(v11 + 40);
  uint64_t v12 = (int8x16_t **)(v11 + 40);
  if (v13)
  {
    unint64_t v14 = "input controls already present";
    __int16 v15 = 248;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateInControls", v15, 54, 0, v14, a7, a8, v25);
    return 0xFFFFFFFFLL;
  }
  uint64_t v17 = *(void *)(v10 + 80 * a2);
  if (!v17 || (unint64_t v18 = *(void *)(v10 + 80 * a2 + 8)) == 0)
  {
    unint64_t v14 = "input is missing or invalid";
    __int16 v15 = 249;
    goto LABEL_5;
  }
  if (!*(_DWORD *)(v10 + 80 * a2 + 36)) {
    return 0;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  unint64_t v21 = *(void *)(a1 + 40);
  uint64_t v22 = (uint64_t *)(v10 + 80 * a2 + 56);
  if (!(v18 >> 28) || v21 >> 28 == 0)
  {
    if ((getBXDiffControls(v17, v18, v20, v21, v12, (uint64_t)v22, (int *)a1, a8) & 0x80000000) != 0)
    {
      unint64_t v14 = "generic controls";
      __int16 v15 = 270;
      goto LABEL_5;
    }
  }
  else
  {
    int LargeFileControls = GetLargeFileControls(v17, v18, v20, v21, (void **)v12, v22, (uint64_t *)a1, a8);
    if (LargeFileControls < 0)
    {
      unint64_t v14 = "largefile controls";
      __int16 v15 = 262;
      goto LABEL_5;
    }
  }
  if (!a3) {
    return 0;
  }
  if ((forceInPlaceControls(*(void *)(*(void *)(a1 + 24) + 80 * a2 + 8), *(void *)(a1 + 40), *(void *)(*(void *)(a1 + 24) + 80 * a2 + 40), *(void *)(*(void *)(a1 + 24) + 80 * a2 + 56), *(_DWORD *)(a1 + 4)) & 0x80000000) != 0)
  {
    unint64_t v14 = "forceInPlaceControls";
    __int16 v15 = 278;
    goto LABEL_5;
  }
  uint64_t result = 0;
  *(_DWORD *)(*(void *)(a1 + 24) + 80 * a2 + 48) = 1;
  return result;
}

uint64_t bxdiff5CreateComboControls(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = *(void *)(a1 + 16);
  if (!v8) {
    goto LABEL_7;
  }
  unint64_t v10 = 0;
  uint64_t v11 = (int *)(*(void *)(a1 + 24) + 36);
  uint64_t v12 = *(void *)(a1 + 16);
  do
  {
    int v13 = *v11;
    v11 += 20;
    if (v13) {
      ++v10;
    }
    --v12;
  }
  while (v12);
  if (v10 > 1)
  {
    *(_DWORD *)(a1 + 80) = 1;
    __int16 v15 = (uint64_t *)calloc(v8, 0x18uLL);
    if (v15)
    {
      unint64_t v16 = v15;
      uint64_t v17 = v15;
      size_t v18 = v8;
      do
      {
        initDiffSegmentVector(v17);
        v17 += 3;
        --v18;
      }
      while (v18);
      uint64_t v25 = 0;
      unint64_t v26 = 0;
      uint64_t v27 = *(void *)(a1 + 24);
      do
      {
        if (*(_DWORD *)(v27 + v25 + 36))
        {
          uint64_t v28 = *(void *)(v27 + v25 + 40);
          if (!v28)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 309, 54, 0, "missing controls for input %zu", v23, v24, v18);
            goto LABEL_28;
          }
          if ((pushControls((unint64_t *)&v16[3 * v26], v28, *(void *)(v27 + v25 + 56), 0, 0) & 0x80000000) != 0)
          {
            unint64_t v33 = "pushControls";
            __int16 v34 = 312;
            goto LABEL_27;
          }
          uint64_t v27 = *(void *)(a1 + 24);
          if (!*(_DWORD *)(v27 + v25 + 48)) {
            *(_DWORD *)(a1 + 80) = 0;
          }
          ++v26;
        }
        ++v18;
        v25 += 80;
      }
      while (v8 != v18);
      if ((mergeDiffSegmentVectors(v26, v16, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        unint64_t v33 = "mergeDiffSegmentVectors";
        __int16 v34 = 321;
      }
      else
      {
        if ((getComboControlsFromMergedDiffSegmentVectors((char *)v26, v16, (void *)(a1 + 72), (uint64_t *)(a1 + 88)) & 0x80000000) == 0)
        {
          int v29 = 1;
          goto LABEL_29;
        }
        unint64_t v33 = "getComboControlsFromMergedDiffSegmentVectors";
        __int16 v34 = 324;
      }
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", v34, 54, 0, v33, v23, v24, v37);
LABEL_28:
      int v29 = 0;
LABEL_29:
      if (v8 <= 1) {
        uint64_t v35 = 1;
      }
      else {
        uint64_t v35 = v8;
      }
      uint64_t v36 = (uint64_t)v16;
      do
      {
        BlobBufferFree(v36);
        v36 += 24;
        --v35;
      }
      while (v35);
      free(v16);
    }
    else
    {
      off_t v30 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 300, 54, *v30, "malloc", v31, v32, v37);
      int v29 = 0;
    }
    if (v29) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 289, 54, 0, "creating combo controls requires 2 or more unique inputs", a7, a8, v37);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5CreateInPatch(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24) + 80 * a2;
  return bxdiff5CreatePatchBackend(1, v2, v2 + 8, v2 + 16, *(void *)(a1 + 32), *(void *)(a1 + 40), a1 + 48, *(void *)(v2 + 40), *(void *)(v2 + 56), (void *)(v2 + 64), (size_t *)(v2 + 72), *(_DWORD *)(v2 + 48), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
}

uint64_t bxdiff5CreatePatchBackend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t __size, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, size_t *a11, int a12, int a13, unsigned int a14)
{
  uint64_t v19 = a10;
  size_t v18 = a11;
  uint64_t v22 = (char *)malloc(__size);
  if (!v22)
  {
    int v28 = *__error();
    int v29 = "malloc";
    __int16 v30 = 447;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", v30, 54, v28, v29, v20, v21, v86);
    __int16 v34 = 0;
LABEL_49:
    free(v22);
    free(v34);
    size_t v67 = 0;
    size_t v68 = 0;
    uint64_t v69 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  uint64_t v23 = a9;
  if (a9)
  {
    int64x2_t v24 = 0uLL;
    int64x2_t v25 = vdupq_n_s64(0x8000000000000000);
    unint64_t v26 = (int64x2_t *)a8;
    uint64_t v27 = a9;
    do
    {
      int64x2_t v24 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*v26), (int8x16_t)vsubq_s64(v25, *v26), *(int8x16_t *)v26), v24);
      unint64_t v26 = (int64x2_t *)((char *)v26 + 8 * a1 + 16);
      --v27;
    }
    while (v27);
  }
  else
  {
    int64x2_t v24 = 0uLL;
  }
  uint64_t v88 = a1 + 2;
  if (a13 > 1)
  {
    *(int64x2_t *)__dsta = v24;
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 backend, out: %zu B, diff: %zu B, lit: %zu B, ctrl: %zu B\n", __size, v24.u64[0], v24.u64[1], 8 * (a1 + 2) * a9);
    int64x2_t v24 = *(int64x2_t *)__dsta;
  }
  if (vaddvq_s64(v24) != __size)
  {
    int v29 = "size inconsistency: diff + archive != out";
    __int16 v30 = 458;
    int v28 = 0;
    goto LABEL_48;
  }
  __dst = v22;
  uint64_t v31 = 28 * a1 + lzma_stream_buffer_bound() * a1;
  size_t v32 = v31 + lzma_stream_buffer_bound() + 60;
  if (a13 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch allocated: %zu B\n", v32);
  }
  unint64_t v33 = malloc(v32);
  __int16 v34 = v33;
  if (!v33)
  {
    uint64_t v71 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 469, 54, *v71, "malloc", v72, v73, v86);
LABEL_52:
    uint64_t v19 = a10;
    uint64_t v22 = __dst;
    goto LABEL_49;
  }
  *(_OWORD *)((char *)v33 + 44) = 0u;
  v33[1] = 0u;
  v33[2] = 0u;
  _OWORD *v33 = 0u;
  uint64_t v87 = (char *)v33 + 60;
  bzero((char *)v33 + 60, 28 * a1);
  *__int16 v34 = 0x3035464649445842;
  v34[2] = __size;
  *(_OWORD *)(v34 + 5) = *(_OWORD *)a7;
  *((_DWORD *)v34 + 14) = *(_DWORD *)(a7 + 16);
  *((_DWORD *)v34 + 2) = a1;
  *((_DWORD *)v34 + 3) = a12 != 0;
  if (a1)
  {
    uint64_t v35 = (char *)v34 + 68;
    uint64_t v36 = a1;
    do
    {
      *(_OWORD *)uint64_t v35 = *(_OWORD *)a4;
      *((_DWORD *)v35 + 4) = *(_DWORD *)(a4 + 16);
      a4 += 20;
      v35 += 28;
      --v36;
    }
    while (v36);
  }
  char v37 = (char *)v34 + v32;
  uint64_t v38 = (uint64_t)&v87[28 * a1];
  if (a13 > 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch headers: %zu B\n", v38 - (void)v34);
  }
  uint64_t v19 = a10;
  uint64_t v39 = plzmaEncodeBuffer(v38, (uint64_t)&v37[-v38], a8, 8 * (a1 + 2) * a9, a14);
  if (v39 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 499, 54, 0, "Payload compression", v40, v41, v86);
    uint64_t v22 = __dst;
    goto LABEL_49;
  }
  uint64_t v42 = v38 + v39;
  v34[3] = v39;
  if (a13 >= 2) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch control payload: %zu B\n", v39);
  }
  uint64_t v22 = __dst;
  if (a1)
  {
    uint64_t v43 = 0;
    uint64_t v44 = a5;
    while (!a9)
    {
      uint64_t v48 = v22;
LABEL_42:
      uint64_t v63 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)v22, v48 - v22, a14);
      if (v63 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 530, 54, 0, "Payload compression", v64, v65, v86);
        goto LABEL_52;
      }
      uint64_t v66 = v63;
      *(void *)&v87[28 * v43] = v63;
      if (a13 >= 2) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch diff[%zu] payload: %zu B\n", v43, v63);
      }
      v42 += v66;
      ++v43;
      uint64_t v22 = __dst;
      uint64_t v44 = a5;
      if (v43 == a1) {
        goto LABEL_56;
      }
    }
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = v22;
    while (1)
    {
      AAByteStream v49 = (int64_t *)(a8 + 8 * v45 * v88);
      uint64_t v50 = v49[1];
      int64_t v51 = 0x8000000000000000 - *v49;
      if (*v49 >= 0) {
        int64_t v51 = *v49;
      }
      unint64_t v52 = 0x8000000000000000 - v50;
      if (v50 >= 0) {
        unint64_t v52 = v49[1];
      }
      uint64_t v53 = v49[v43 + 2];
      if (v53 < 0) {
        uint64_t v53 = 0x8000000000000000 - v53;
      }
      if (v46 < 0) {
        break;
      }
      uint64_t v54 = v51 + v46;
      if (v51 + v46 > __size) {
        break;
      }
      if (v47 < 0 || (uint64_t v55 = v51 + v47, v51 + v47 > *(void *)(a3 + 8 * v43)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 519, 54, 0, "in[%zu] access out of range", a2, v88, v43);
        goto LABEL_69;
      }
      if (v51 >= 1)
      {
        uint64_t v56 = (char *)(*(void *)(a2 + 8 * v43) + v47);
        uint64_t v57 = (char *)(v44 + v46);
        uint64_t v58 = v48;
        int64_t v59 = v51;
        do
        {
          char v61 = *v57++;
          char v60 = v61;
          char v62 = *v56++;
          *v58++ = v60 - v62;
          --v59;
        }
        while (v59);
      }
      v48 += v51;
      uint64_t v46 = v54 + v52;
      uint64_t v47 = v55 + v53;
      if (++v45 == a9) {
        goto LABEL_42;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 518, 54, 0, "out access out of range", a2, v88, v86);
    goto LABEL_69;
  }
  uint64_t v44 = a5;
LABEL_56:
  if (a9)
  {
    size_t v74 = 0;
    uint64_t v75 = (size_t *)(a8 + 8);
    uint64_t v76 = 8 * a1 + 16;
    uint64_t v22 = __dst;
    do
    {
      uint64_t v77 = *(v75 - 1);
      if (v77 < 0) {
        uint64_t v77 = 0x8000000000000000 - v77;
      }
      if ((*v75 & 0x8000000000000000) == 0) {
        size_t v78 = *v75;
      }
      else {
        size_t v78 = 0x8000000000000000 - *v75;
      }
      size_t v79 = v77 + v74;
      memcpy(v22, (const void *)(v44 + v77 + v74), v78);
      uint64_t v44 = a5;
      v22 += v78;
      size_t v74 = v79 + v78;
      uint64_t v75 = (size_t *)((char *)v75 + v76);
      --v23;
    }
    while (v23);
  }
  uint64_t v80 = v22 - __dst;
  uint64_t v22 = __dst;
  uint64_t v81 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)__dst, v80, a14);
  if (v81 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 554, 54, 0, "Payload compression", v82, v83, v86);
    size_t v18 = a11;
LABEL_69:
    uint64_t v19 = a10;
    goto LABEL_49;
  }
  uint64_t v84 = v42 + v81;
  v34[4] = v81;
  if (a13 <= 1)
  {
    size_t v68 = v84 - (void)v34;
  }
  else
  {
    uint64_t v85 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch archive payload: %zu B\n", v81);
    size_t v68 = v84 - (void)v34;
    fprintf(*v85, "BXDiff5 patch total size: %zu B\n", v84 - (void)v34);
  }
  size_t v18 = a11;
  uint64_t v19 = a10;
  free(__dst);
  size_t v67 = reallocToFit(v34, v68);
  uint64_t v69 = 0;
LABEL_50:
  *uint64_t v19 = v67;
  *size_t v18 = v68;
  return v69;
}

uint64_t bxdiff5CreateComboPatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72))
  {
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      size_t v10 = 0;
      uint64_t v11 = (int *)(*(void *)(a1 + 24) + 36);
      do
      {
        int v12 = *v11;
        v11 += 20;
        if (v12) {
          ++v10;
        }
        --v9;
      }
      while (v9);
    }
    else
    {
      size_t v10 = 0;
    }
    unint64_t v14 = calloc(v10, 8uLL);
    __int16 v15 = calloc(v10, 8uLL);
    unint64_t v16 = (char *)calloc(v10, 0x14uLL);
    uint64_t v17 = v16;
    if (v14) {
      BOOL v18 = v15 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (v18 || v16 == 0)
    {
      uint64_t v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 609, 54, *v20, "malloc", v21, v22, v32);
      uint64_t PatchBackend = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v23 = *(void *)(a1 + 16);
      if (v23)
      {
        uint64_t v24 = 0;
        unint64_t v25 = 0;
        uint64_t v26 = 0;
        do
        {
          uint64_t v27 = *(void *)(a1 + 24);
          if (*(_DWORD *)(v27 + v24 + 36))
          {
            v14[v26] = *(void *)(v27 + v24);
            uint64_t v28 = *(void *)(a1 + 24) + v24;
            v15[v26] = *(void *)(v28 + 8);
            int v29 = &v16[20 * v26];
            long long v30 = *(_OWORD *)(v28 + 16);
            *((_DWORD *)v29 + 4) = *(_DWORD *)(v28 + 32);
            *(_OWORD *)int v29 = v30;
            ++v26;
            unint64_t v23 = *(void *)(a1 + 16);
          }
          ++v25;
          v24 += 80;
        }
        while (v25 < v23);
      }
      uint64_t PatchBackend = bxdiff5CreatePatchBackend(v10, (uint64_t)v14, (uint64_t)v15, (uint64_t)v16, *(void *)(a1 + 32), *(void *)(a1 + 40), a1 + 48, *(void *)(a1 + 72), *(void *)(a1 + 88), (void *)(a1 + 96), (size_t *)(a1 + 104), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
    }
    free(v14);
    free(v15);
    free(v17);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 600, 54, 0, "missing combo controls", a7, a8, v32);
    return 0xFFFFFFFFLL;
  }
  return PatchBackend;
}

uint64_t BXDiff5(uint64_t a1, void **a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return BXDiff5WithIndividualPatches(a1, a2, a3, 0, 0, a6, a7, a8);
}

uint64_t BXDiff5WithIndividualPatches(uint64_t a1, void **a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  if (HIDWORD(*(void *)a1))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 645, 54, 0, "Invalid number of inputs: %zu", a7, a8, *(void *)a1);
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = (void *)a5;
  size_t v10 = (void *)a4;
  int v14 = *(_DWORD *)(a1 + 48);
  enterThreadErrorContext(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v93);
  size_t v15 = *(void *)a1;
  int v16 = *(_DWORD *)(a1 + 52);
  if (v10) {
    BOOL v17 = v9 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  int v18 = !v17;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  *(_OWORD *)__int16 v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v102 = 0u;
  int v19 = *(_DWORD *)(a1 + 44);
  int v99 = v18;
  LODWORD(v100) = *(_DWORD *)(a1 + 40);
  HIDWORD(v100) = v16;
  int v101 = v19;
  bxdiff5Alloc(v15, &v100, (uint64_t)&v102);
  *a2 = 0;
  *a3 = 0;
  if (v10 && v15) {
    bzero(v10, 8 * v15);
  }
  if (v9 && v15) {
    bzero(v9, 8 * v15);
  }
  if (bxdiff5SetOut((uint64_t)&v102, *(void *)(a1 + 24), *(void *)(a1 + 32), v20, v21, v22, v23, v24))
  {
    char v32 = "bxdiff5SetOut";
    __int16 v33 = 672;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", v33, 54, 0, v32, v30, v31, v94);
    LODWORD(v34) = 0;
    goto LABEL_18;
  }
  if (v15)
  {
    unint64_t v45 = 0;
    while (!bxdiff5SetIn(&v102, v45, *(void *)(*(void *)(a1 + 8) + 8 * v45), *(void *)(*(void *)(a1 + 16) + 8 * v45), v28, v29, v30, v31))
    {
      if (v15 == ++v45) {
        goto LABEL_28;
      }
    }
    char v32 = "bxdiff5SetIn";
    __int16 v33 = 675;
    goto LABEL_17;
  }
LABEL_28:
  uint64_t v46 = v103;
  if ((void)v103)
  {
    uint64_t v47 = 0;
    uint64_t v48 = (int *)(*((void *)&v103 + 1) + 36);
    do
    {
      int v49 = *v48;
      v48 += 20;
      if (v49) {
        ++v47;
      }
      --v46;
    }
    while (v46);
    if (!v47) {
      *(_DWORD *)(*((void *)&v103 + 1) + 36) = 1;
    }
  }
  if (v16 >= 2) {
    bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
  }
  if (v15)
  {
    uint64_t v50 = v103;
    uint64_t v96 = a2;
    if ((void)v103)
    {
      unint64_t v34 = 0;
      int64_t v51 = (int *)(*((void *)&v103 + 1) + 36);
      do
      {
        int v52 = *v51;
        v51 += 20;
        if (v52) {
          ++v34;
        }
        --v50;
      }
      while (v50);
      if (v34 == 1)
      {
        uint64_t v53 = 0;
        uint64_t v54 = (int *)(*((void *)&v103 + 1) + 36);
        while (1)
        {
          int v55 = *v54;
          v54 += 20;
          if (v55) {
            break;
          }
          if (v15 == ++v53)
          {
            char v32 = "could not find unique input";
            __int16 v33 = 699;
            goto LABEL_17;
          }
        }
        char v67 = v14;
        int v98 = v16;
        int v99 = 0;
        uint64_t v97 = a3;
        int v68 = 1;
        unint64_t v34 = 1;
LABEL_59:
        unint64_t v69 = 0;
        int v70 = v67 & 2;
        if (v15 <= 1) {
          uint64_t v71 = 1;
        }
        else {
          uint64_t v71 = v15;
        }
        uint64_t v72 = 36;
        do
        {
          if (*(_DWORD *)(*((void *)&v103 + 1) + v72))
          {
            if (bxdiff5CreateInControls((uint64_t)&v102, v69, v70, v27, v28, v29, v30, v31))
            {
              char v32 = "bxdiff5CreateInControls";
              __int16 v33 = 710;
              goto LABEL_17;
            }
            int v73 = v53 == v69 ? v68 : 0;
            if ((v99 || v73) && bxdiff5CreateInPatch((uint64_t)&v102, v69))
            {
              char v32 = "bxdiff5CreateInPatch";
              __int16 v33 = 718;
              goto LABEL_17;
            }
          }
          ++v69;
          v72 += 80;
        }
        while (v71 != v69);
        if (v98 >= 2) {
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
        }
        if (v34 >= 2)
        {
          if (bxdiff5CreateComboControls((uint64_t)&v102, v25, v26, v27, v28, v29, v30, v31))
          {
            char v32 = "bxdiff5CreateComboControls";
            __int16 v33 = 730;
            goto LABEL_17;
          }
          uint64_t v79 = 0;
          uint64_t v80 = *((void *)&v103 + 1);
          uint64_t v81 = v71;
          do
          {
            free(*(void **)(v80 + v79 + 40));
            uint64_t v80 = *((void *)&v103 + 1);
            uint64_t v89 = *((void *)&v103 + 1) + v79;
            *(void *)(v89 + 40) = 0;
            *(void *)(v89 + 56) = 0;
            v79 += 80;
            --v81;
          }
          while (v81);
          if (v98 > 1) {
            bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
          }
          if (bxdiff5CreateComboPatch((uint64_t)&v102, v82, v83, v84, v85, v86, v87, v88))
          {
            char v32 = "bxdiff5CreateComboPatch";
            __int16 v33 = 747;
            goto LABEL_17;
          }
        }
        if (v98 >= 2) {
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x263EF8348]);
        }
        if (v34 >= 2)
        {
          uint64_t v90 = *((void *)&v108 + 1);
          *uint64_t v96 = (void *)v108;
          *uint64_t v97 = v90;
          long long v108 = 0uLL;
          if (!v99) {
            goto LABEL_97;
          }
          BOOL v91 = (void *)(*((void *)&v103 + 1) + 64);
          do
          {
            *v10++ = *v91;
            *v9++ = v91[1];
            *BOOL v91 = 0;
            v91[1] = 0;
            v91 += 10;
            --v71;
          }
          while (v71);
        }
        if (v34 == 1)
        {
          uint64_t v92 = *((void *)&v103 + 1) + 80 * v53;
          *uint64_t v96 = *(void **)(v92 + 64);
          *uint64_t v97 = *(void *)(v92 + 72);
          *(void *)(v92 + 64) = 0;
          *(void *)(v92 + 72) = 0;
          goto LABEL_18;
        }
LABEL_97:
        LODWORD(v34) = 1;
LABEL_18:
        if (v15)
        {
          uint64_t v35 = 0;
          uint64_t v36 = *((void *)&v103 + 1);
          do
          {
            uint64_t v37 = v36 + v35;
            *(void *)uint64_t v37 = 0;
            free(*(void **)(v37 + 40));
            uint64_t v36 = *((void *)&v103 + 1);
            *(void *)(*((void *)&v103 + 1) + v35 + 40) = 0;
            v35 += 80;
            --v15;
          }
          while (v15);
        }
        goto LABEL_21;
      }
      char v67 = v14;
      int v98 = v16;
      uint64_t v97 = a3;
      int v68 = 0;
    }
    else
    {
      char v67 = v14;
      int v98 = v16;
      uint64_t v97 = a3;
      int v68 = 0;
      unint64_t v34 = 0;
    }
    uint64_t v53 = -1;
    goto LABEL_59;
  }
  long long v56 = v104;
  int v57 = DWORD1(v102);
  unsigned int v58 = DWORD2(v102);
  uint64_t v59 = lzma_stream_buffer_bound();
  size_t v60 = v59 + 60;
  if (v57 >= 1) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch capacity: %zu B\n", v60);
  }
  char v61 = (char *)malloc(v60);
  char v62 = v61;
  if (v61)
  {
    *(_OWORD *)char v61 = 0u;
    *((_OWORD *)v61 + 1) = 0u;
    *(_OWORD *)(v61 + 44) = 0u;
    *((_OWORD *)v61 + 2) = 0u;
    *(void *)char v61 = 0x3035464649445842;
    *((void *)v61 + 1) = 0;
    *((void *)v61 + 2) = *((void *)&v56 + 1);
    *(_OWORD *)(v61 + 40) = v105;
    *((_DWORD *)v61 + 14) = v106[0];
    uint64_t v63 = plzmaEncodeBuffer((uint64_t)(v61 + 60), v59, v56, *((uint64_t *)&v56 + 1), v58);
    if ((v63 & 0x8000000000000000) == 0)
    {
      uint64_t v66 = (char *)v62 + v63 + 60;
      v62[4] = v63;
      if (v57 >= 1) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "BXDiff5 patch archive payload size: %zu B\n", v63);
      }
      *a2 = reallocToFit(v62, v66 - (char *)v62);
      *a3 = v66 - (char *)v62;
      LODWORD(v34) = 1;
      goto LABEL_21;
    }
    uint64_t v75 = "Payload compression";
    __int16 v76 = 406;
    int v74 = 0;
  }
  else
  {
    int v74 = *__error();
    uint64_t v75 = "malloc patch";
    __int16 v76 = 386;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateFullReplacementBackend", v76, 54, v74, v75, v64, v65, v94);
  free(v62);
  *a2 = 0;
  *a3 = 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 689, 54, 0, "bxdiff5CreateFullReplacementBackend", v77, v78, v95);
  LODWORD(v34) = 0;
LABEL_21:
  *(void *)&long long v104 = 0;
  free(v106[1]);
  v106[1] = 0;
  bxdiff5Free((uint64_t)&v102, v38, v39, v40, v41, v42, v43, v44);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0) {
    return (v34 - 1);
  }
  else {
    return result;
  }
}

uint64_t plzmaEncodeBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  size_t v10 = IMemStreamCreate(a3, a4);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", 348, 54, 0, "is", v8, v9, v25);
    int v19 = 0;
LABEL_8:
    int v22 = 1;
    goto LABEL_9;
  }
  uint64_t v11 = OMemStreamCreate(a1, a2);
  int v19 = v11;
  if (!v11)
  {
    uint64_t v20 = "os";
    __int16 v21 = 349;
    goto LABEL_7;
  }
  *(void *)((char *)&v25 + 4) = a5 | 0x100000000;
  LODWORD(v25) = 0;
  *(void *)&long long v26 = 0x100000;
  *((void *)&v26 + 1) = IMemStreamRead;
  *((void *)&v27 + 1) = v10;
  *(void *)&long long v28 = OMemStreamWrite;
  uint64_t v29 = v11;
  if (ParallelCompressionEncode((uint64_t)&v25, v12, v13, v14, v15, v16, v17, v18))
  {
    uint64_t v20 = "encode";
    __int16 v21 = 358;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", v21, 54, 0, v20, v17, v18, v25);
    goto LABEL_8;
  }
  int v22 = 0;
LABEL_9:
  uint64_t v23 = BXDiffMatchesOBuf((uint64_t)v19);
  OMemStreamDestroy(v10);
  OMemStreamDestroy(v19);
  if (v22) {
    return -1;
  }
  else {
    return v23;
  }
}

void *aaInSituStreamOpen(void *a1, uint64_t a2, int a3, int a4, int a5)
{
  size_t v10 = calloc(1uLL, 0x68uLL);
  uint64_t v11 = calloc(1uLL, 0x140uLL);
  uint64_t v14 = (uint64_t)v11;
  if (!v10 || !v11)
  {
    uint64_t v23 = "aaCalloc";
    __int16 v24 = 336;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"aaInSituStreamOpen", v24, 140, 0, v23, v12, v13, v33);
    free(v10);
    InSituStreamClose(v14, v25, v26, v27, v28, v29, v30, v31);
    return 0;
  }
  *(void *)uint64_t v11 = a1;
  v11[78] = a5;
  unint64_t v15 = (unint64_t)(a2 + 0x3FFF) >> 14;
  v11[72] = v15;
  LODWORD(v15) = v15 + ((a3 + 0x3FFF) >> 14) + ((int)v15 >> 2);
  v11[79] = a4;
  size_t v16 = (v15 + 256);
  *(_DWORD *)(v14 + 292) = v16;
  if ((int)v15 + 256 < 0)
  {
    *__error() = 12;
    *(void *)(v14 + 8) = 0;
    goto LABEL_14;
  }
  uint64_t v17 = calloc(v16, 0xDuLL);
  *(void *)(v14 + 8) = v17;
  if (!v17)
  {
LABEL_14:
    uint64_t v23 = "aaCalloc";
    __int16 v24 = 347;
    goto LABEL_16;
  }
  *(void *)&long long v18 = -1;
  *((void *)&v18 + 1) = -1;
  *(_OWORD *)(v14 + 240) = v18;
  *(_OWORD *)(v14 + 256) = v18;
  *(_OWORD *)(v14 + 208) = v18;
  *(_OWORD *)(v14 + 224) = v18;
  *(_OWORD *)(v14 + 176) = v18;
  *(_OWORD *)(v14 + 192) = v18;
  *(_OWORD *)(v14 + 144) = v18;
  *(_OWORD *)(v14 + 160) = v18;
  *(_OWORD *)(v14 + 112) = v18;
  *(_OWORD *)(v14 + 128) = v18;
  *(_OWORD *)(v14 + 80) = v18;
  *(_OWORD *)(v14 + 96) = v18;
  *(_OWORD *)(v14 + 48) = v18;
  *(_OWORD *)(v14 + 64) = v18;
  *(_OWORD *)(v14 + 16) = v18;
  *(_OWORD *)(v14 + 32) = v18;
  int v19 = *(_DWORD *)(v14 + 292);
  if (v19 >= 1)
  {
    uint64_t v20 = 0;
    for (uint64_t i = 0; i < v19; ++i)
    {
      uint64_t v22 = *(void *)(v14 + 8) + v20;
      *(_DWORD *)(v22 + 1) = i;
      *(void *)(v22 + 5) = 0xFFFFFFFF00000000;
      if (i < *(int *)(v14 + 288))
      {
        free_page(v14, i);
        int v19 = *(_DWORD *)(v14 + 292);
      }
      v20 += 13;
    }
  }
  if ((AAByteStreamTruncate(a1) & 0x80000000) != 0)
  {
    uint64_t v23 = "AAByteStreamTruncate";
    __int16 v24 = 362;
    goto LABEL_16;
  }
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)InSituStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)InSituStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)InSituStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  v10[8] = InSituTruncate;
  v10[11] = InSituStreamSimulate;
  return v10;
}

uint64_t free_page(uint64_t result, int a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); ; a2 = *(_DWORD *)(i + 13 * a2 + 1))
  {
    ssize_t v5 = (unsigned char *)(i + 13 * a2);
    int v6 = *v5;
    if (v6 != 2) {
      break;
    }
  }
  if (v6 == 1)
  {
    unsigned char *v5 = 0;
    *(_DWORD *)(i + 13 * a2 + 5) = 0;
  }
  ++*(_DWORD *)(result + 296);
  uint64_t v7 = i + 13 * a2;
  int v9 = *(_DWORD *)(v7 + 9);
  uint64_t v8 = (_DWORD *)(v7 + 9);
  if (v9 < 0)
  {
    int v10 = *(_DWORD *)(result + 276);
    *(_DWORD *)(result + 276) = v10 - 1;
    if (v10 >= 2)
    {
      int v11 = *(_DWORD *)(result + 272);
    }
    else
    {
      *(_DWORD *)(result + 276) = 32;
      uint64_t result = rand();
      int v11 = result & 0x3F;
      *(_DWORD *)(v3 + 272) = v11;
    }
    uint64_t v12 = v3 + 4 * v11;
    *uint64_t v8 = *(_DWORD *)(v12 + 16);
    *(_DWORD *)(v12 + 16) = a2;
  }
  return result;
}

uint64_t InSituStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(unsigned int *)(result + 292);
    if ((int)v9 < 1) {
      goto LABEL_7;
    }
    int v10 = 0;
    int v11 = (int *)(*(void *)(result + 8) + 5);
    do
    {
      int v12 = *v11;
      int v11 = (int *)((char *)v11 + 13);
      v10 += v12;
      --v9;
    }
    while (v9);
    if (v10)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 298, 140, 0, "%i dangling reads", a7, a8, v10);
      int v13 = 0;
    }
    else
    {
LABEL_7:
      int v13 = 1;
    }
    int v14 = *(_DWORD *)(v8 + 288);
    int v15 = *(_DWORD *)(v8 + 308);
    if (*(_DWORD *)(v8 + 300) + v14 != *(_DWORD *)(v8 + 296) + v15)
    {
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 301, 140, "file + excess != written + free", a6, a7, a8, v18);
      int v14 = *(_DWORD *)(v8 + 288);
      int v15 = *(_DWORD *)(v8 + 308);
    }
    if (v14 < v15) {
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 302, 140, "file < written", a6, a7, a8, v18);
    }
    if (*(_DWORD *)(v8 + 316)) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "InSituStream: pages: %i file, %i written, %i remapped, %i free, %i excess (%iK)\n", *(_DWORD *)(v8 + 288), *(_DWORD *)(v8 + 308), *(_DWORD *)(v8 + 304), *(_DWORD *)(v8 + 296), *(_DWORD *)(v8 + 300), 16 * *(_DWORD *)(v8 + 300));
    }
    free(*(void **)(v8 + 8));
    if (*(_DWORD *)(v8 + 312) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 319, 140, 0, "AAByteStreamClose", v16, v17, v18);
      int v13 = 0;
    }
    free((void *)v8);
    if (v13) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t InSituStreamPRead(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  unint64_t v11 = 0;
  while (1)
  {
    uint64_t v12 = a1[1];
    uint64_t v13 = (v11 + a4) & 0x3FFF;
    uint64_t v14 = a3 - v11 >= 0x4000 - v13 ? 0x4000 - v13 : a3 - v11;
    if (!*(_DWORD *)(v12 + 13 * (int)((v11 + a4) >> 14) + 5)) {
      break;
    }
    uint64_t v15 = *a1;
    if (!*(void *)(*a1 + 32)) {
      goto LABEL_19;
    }
    if (v14)
    {
      uint64_t v16 = 0;
      uint64_t v17 = v13 | ((uint64_t)*(int *)(v12 + 13 * (int)((uint64_t)(v11 + a4) >> 14) + 1) << 14);
      uint64_t v18 = a2 + v11;
      uint64_t v19 = v14;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v15 + 32))(*(void *)v15, v18, v19, v17);
        if (v20 < 0) {
          break;
        }
        if (v20)
        {
          v18 += v20;
          v16 += v20;
          v17 += v20;
          v19 -= v20;
          if (v19) {
            continue;
          }
        }
        goto LABEL_15;
      }
      uint64_t v16 = v20;
LABEL_15:
      if (v14 != v16)
      {
LABEL_19:
        __int16 v21 = "aaByteStreamPReadExpected";
        __int16 v22 = 238;
        goto LABEL_21;
      }
    }
    v11 += v14;
    if (v11 >= a3) {
      return v11;
    }
  }
  __int16 v21 = "data not locked";
  __int16 v22 = 235;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPRead", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

uint64_t InSituStreamPWrite(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0;
  }
  unint64_t v11 = 0;
  while (1)
  {
    uint64_t v12 = v11 + a4;
    unint64_t v13 = (v11 + a4) >> 14;
    uint64_t v14 = (unsigned char *)(a1[1] + 13 * (int)v13);
    if (a3 - v11 >= 0x4000 - ((v11 + a4) & 0x3FFF)) {
      uint64_t v15 = 0x4000 - ((v11 + a4) & 0x3FFF);
    }
    else {
      uint64_t v15 = a3 - v11;
    }
    if (*v14 == 2) {
      goto LABEL_9;
    }
    if ((remap_page(a1, v13) & 0x80000000) != 0) {
      break;
    }
    *uint64_t v14 = 2;
    --*((_DWORD *)a1 + 74);
    ++*((_DWORD *)a1 + 77);
LABEL_9:
    uint64_t v16 = *a1;
    if (!*(void *)(*a1 + 40)) {
      goto LABEL_20;
    }
    if (v15)
    {
      uint64_t v17 = 0;
      uint64_t v18 = a2 + v11;
      uint64_t v19 = v15;
      while (1)
      {
        uint64_t v20 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v16 + 40))(*(void *)v16, v18, v19, v12);
        if (v20 < 1) {
          break;
        }
        v18 += v20;
        v17 += v20;
        v12 += v20;
        v19 -= v20;
        if (!v19) {
          goto LABEL_16;
        }
      }
      uint64_t v17 = v20;
LABEL_16:
      if (v15 != v17)
      {
LABEL_20:
        __int16 v21 = "aaByteStreamPWriteExpected";
        __int16 v22 = 268;
        goto LABEL_22;
      }
    }
    v11 += v15;
    if (v11 >= a3) {
      return v11;
    }
  }
  __int16 v21 = "remap_page";
  __int16 v22 = 261;
LABEL_22:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPWrite", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

void InSituStreamCancel(AAByteStream *a1)
{
}

uint64_t InSituTruncate(void **a1)
{
  return AAByteStreamTruncate(*a1);
}

uint64_t InSituStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a5;
  uint64_t v9 = a4;
  if (a2 == 3)
  {
    uint64_t v11 = *(void *)a1;
    if (!*(void *)(*(void *)a1 + 32)) {
      return -1;
    }
    if (!a4) {
      return 0;
    }
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t))(v11 + 32))(*(void *)v11, a3, v9, v8);
      if (v14 < 0) {
        break;
      }
      if (v14)
      {
        a3 += v14;
        v13 += v14;
        v8 += v14;
        v9 -= v14;
        if (v9) {
          continue;
        }
      }
      return v13;
    }
    return v14;
  }
  if (a4 < 1) {
    return v9;
  }
  if (a2 > 1)
  {
    uint64_t v23 = "not implemented";
    __int16 v24 = 197;
    goto LABEL_24;
  }
  int64_t v16 = a5 + a4;
  while (1)
  {
    uint64_t v17 = *(void *)(a1 + 8) + 13 * (int)(v8 >> 14);
    int v20 = *(_DWORD *)(v17 + 5);
    uint64_t v18 = (int *)(v17 + 5);
    int v19 = v20;
    if (!a2) {
      break;
    }
    if (v19 <= 0)
    {
      uint64_t v23 = "data not locked";
      __int16 v24 = 209;
      goto LABEL_24;
    }
    int v21 = v19 - 1;
    *uint64_t v18 = v21;
    if (!v21) {
      free_page(a1, v8 >> 14);
    }
LABEL_18:
    unint64_t v8 = (v8 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if ((uint64_t)v8 >= v16) {
      return v9;
    }
  }
  *uint64_t v18 = v19 + 1;
  if (v19) {
    goto LABEL_18;
  }
  int v22 = *(_DWORD *)(a1 + 296);
  *(_DWORD *)(a1 + 296) = v22 - 1;
  if (v22) {
    goto LABEL_18;
  }
  uint64_t v23 = "no free pages";
  __int16 v24 = 204;
LABEL_24:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamSimulate", v24, 140, 0, v23, a7, a8, v26);
  return -1;
}

uint64_t remap_page(_DWORD *a1, int a2)
{
  uint64_t v2 = *((void *)a1 + 1);
  uint64_t v3 = v2 + 13 * a2;
  int v5 = *(_DWORD *)(v3 + 5);
  uint64_t v4 = (_DWORD *)(v3 + 5);
  if (v5)
  {
    if (*(unsigned char *)(v2 + 13 * a2) == 1)
    {
      uint64_t result = remap_page(a1, *(unsigned int *)(v2 + 13 * a2 + 1));
      _DWORD *v4 = 0;
      return result;
    }
    uint64_t v11 = (char *)malloc(0x4000uLL);
    uint64_t v14 = v11;
    if (v11)
    {
      int v15 = a1[74];
      if (v15 <= 0)
      {
        int v26 = a1[72];
        int v27 = a1[75];
        a1[75] = v27 + 1;
        unsigned int v19 = v27 + v26;
        if (v27 + v26 >= a1[73])
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"allocate_page", 97, 140, 0, "too many excess pages", v12, v13, v42);
        }
        else if ((v19 & 0x80000000) == 0)
        {
LABEL_20:
          uint64_t v28 = *(void *)a1;
          if (*(void *)(*(void *)a1 + 32))
          {
            uint64_t v29 = 0;
            uint64_t v30 = (unsigned int *)(v2 + 13 * a2 + 1);
            uint64_t v31 = (uint64_t)(int)*v30 << 14;
            uint64_t v32 = 0x4000;
            char v33 = v11;
            while (1)
            {
              uint64_t v34 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t))(v28 + 32))(*(void *)v28, v33, v32, v31);
              if (v34 < 0) {
                break;
              }
              if (v34)
              {
                v33 += v34;
                v29 += v34;
                v31 += v34;
                v32 -= v34;
                if (v32) {
                  continue;
                }
              }
              if (v29 != 0x4000) {
                break;
              }
              uint64_t v35 = *(void *)a1;
              if (*(void *)(*(void *)a1 + 40))
              {
                uint64_t v36 = 0;
                unint64_t v37 = (unint64_t)v19 << 14;
                uint64_t v38 = 0x4000;
                uint64_t v39 = v14;
                while (1)
                {
                  uint64_t v40 = (*(uint64_t (**)(void, char *, uint64_t, unint64_t))(v35 + 40))(*(void *)v35, v39, v38, v37);
                  if (v40 < 1) {
                    break;
                  }
                  v39 += v40;
                  v36 += v40;
                  v37 += v40;
                  v38 -= v40;
                  if (!v38)
                  {
                    if (v36 != 0x4000) {
                      break;
                    }
                    uint64_t v10 = 0;
                    *uint64_t v30 = v19;
                    uint64_t v41 = *((void *)a1 + 1) + 13 * v19;
                    *(unsigned char *)uint64_t v41 = 1;
                    *(_DWORD *)(v41 + 1) = a2;
                    *(_DWORD *)(v41 + 5) = 0x7FFFFFFF;
                    ++a1[76];
                    ++a1[74];
                    goto LABEL_35;
                  }
                }
              }
              __int16 v24 = "aaByteStreamPWriteExpected";
              __int16 v25 = 158;
              goto LABEL_34;
            }
          }
          __int16 v24 = "aaByteStreamPReadExpected";
          __int16 v25 = 157;
          goto LABEL_34;
        }
      }
      else
      {
        int v16 = a1[70];
        a1[74] = v15 - 1;
        int v17 = a1[73];
        if (v17)
        {
          uint64_t v18 = &a1[(v16 & 0x3F) + 4];
          do
          {
            unsigned int v19 = *v18;
            if ((*v18 & 0x80000000) != 0
              || (int v20 = a1[71], v21 = __OFSUB__(v20, 1), --v20, a1[71] = v20, (v20 < 0) ^ v21 | (v20 == 0)))
            {
              a1[71] = 32;
              int v22 = a1[70] + 1;
              a1[70] = v22;
              uint64_t v18 = &a1[(v22 & 0x3F) + 4];
            }
            else
            {
              uint64_t v23 = v2 + 13 * v19;
              *uint64_t v18 = *(_DWORD *)(v23 + 9);
              *(_DWORD *)(v23 + 9) = -1;
              if (!*(_DWORD *)(v23 + 5) && !*(unsigned char *)(v2 + 13 * v19)) {
                goto LABEL_20;
              }
            }
            --v17;
          }
          while (v17);
        }
      }
      __int16 v24 = "allocate_page";
      __int16 v25 = 153;
    }
    else
    {
      __int16 v24 = "aaMalloc";
      __int16 v25 = 149;
    }
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"remap_page", v25, 140, 0, v24, v12, v13, v42);
    uint64_t v10 = 0xFFFFFFFFLL;
LABEL_35:
    free(v14);
    return v10;
  }
  return 0;
}

uint64_t aeaContextUnlock(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int a5, int a6)
{
  uint64_t v134 = *MEMORY[0x263EF8340];
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v66 = 0u;
  memset(v65, 0, sizeof(v65));
  uint64_t v64 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v61 = 0u;
  memset(v60, 0, sizeof(v60));
  long long v127 = 0u;
  long long v126 = 0u;
  long long v125 = 0u;
  int v124 = 0;
  long long v123 = 0u;
  long long v122 = 0u;
  long long v121 = 0u;
  long long v120 = 0u;
  long long v119 = 0u;
  long long v118 = 0u;
  long long v117 = 0u;
  long long v116 = 0u;
  long long v115 = 0u;
  long long v114 = 0u;
  long long v113 = 0u;
  long long v112 = 0u;
  long long v111 = 0u;
  long long v110 = 0u;
  long long v109 = 0u;
  *(_OWORD *)long long v108 = 0u;
  int v107 = 0;
  long long v106 = 0u;
  long long v105 = 0u;
  long long v104 = 0u;
  long long v103 = 0u;
  long long v102 = 0u;
  long long v101 = 0u;
  long long v100 = 0u;
  long long v99 = 0u;
  long long v98 = 0u;
  long long v97 = 0u;
  long long v96 = 0u;
  long long v95 = 0u;
  long long v94 = 0u;
  long long v93 = 0u;
  long long v92 = 0u;
  *(_OWORD *)size_t __n = 0u;
  int v90 = 0;
  memset(v89, 0, sizeof(v89));
  int v88 = 0;
  memset(v87, 0, sizeof(v87));
  int v86 = 0;
  memset(v85, 0, sizeof(v85));
  int v84 = 0;
  memset(v83, 0, sizeof(v83));
  int v82 = 0;
  memset(v81, 0, sizeof(v81));
  int v80 = 0;
  memset(v79, 0, sizeof(v79));
  int v78 = 0;
  memset(v77, 0, sizeof(v77));
  int v12 = *(_DWORD *)(a1 + 1372);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  long long v13 = *(_OWORD *)(a1 + 16);
  long long v14 = *(_OWORD *)(a1 + 32);
  long long v15 = *(_OWORD *)(a1 + 48);
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  *(_OWORD *)(a2 + 32) = v14;
  *(_OWORD *)(a2 + 48) = v15;
  *(_OWORD *)(a2 + 16) = v13;
  if ((aeaCryptoInit((char *)v65, (unsigned int *)a2) & 0x80000000) != 0)
  {
    int v22 = "initializing crypto params";
    __int16 v23 = 33;
    goto LABEL_74;
  }
  if ((aeaContainerOffsetsInit((uint64_t)v60, (unsigned int *)a2, (unsigned int *)v65) & 0x80000000) != 0)
  {
    int v22 = "deriving container offsets";
    __int16 v23 = 34;
    goto LABEL_74;
  }
  uint64_t v18 = DWORD2(v65[0]);
  if (DWORD2(v65[0]) >= 0x101) {
    goto LABEL_78;
  }
  uint64_t v59 = a4;
  __memcpy_chk();
  LODWORD(v108[0]) = v18;
  memset_s((char *)v108 + v18 + 4, 256 - v18, 0, 256 - v18);
  uint64_t v19 = v67;
  if (v67 >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(v87[0]) = v19;
  memset_s((char *)v87 + v19 + 4, 256 - v19, 0, 256 - v19);
  if (*(_DWORD *)a2 <= 4u && ((1 << *(_DWORD *)a2) & 0x15) != 0)
  {
    uint64_t v20 = *(unsigned int *)(a1 + 332);
    if (v20)
    {
      if (v20 >= 0x101) {
        goto LABEL_78;
      }
      __memcpy_chk();
      LODWORD(v89[0]) = v20;
      memset_s((char *)v89 + v20 + 4, 256 - v20, 0, 256 - v20);
    }
    else if (*(_DWORD *)(a1 + 592))
    {
      if (!*((void *)&v74 + 1)
        || (int v46 = (*((uint64_t (**)(_OWORD *, uint64_t))&v74 + 1))(v89, a1 + 592),
            LODWORD(v89[0]) != v66)
        || v46 < 0)
      {
        int v22 = "deriving signing public key";
        __int16 v23 = 47;
        goto LABEL_74;
      }
    }
  }
  if (!a6 || !v12)
  {
    if ((aeaDeriveMainKeyExisting((unsigned int *)v65, (_DWORD *)a2, __n, (_DWORD *)(a1 + 72), (_DWORD *)(a1 + 2152), (unsigned int *)v87, (unsigned int *)v89, (unsigned int *)(a1 + 852), (_DWORD *)(a1 + 1112), v108, *(uint64_t (**)(uint64_t, void, char *, long long *, unsigned int *, void))(a1 + 2432), *(void *)(a1 + 2440)) & 0x80000000) == 0)goto LABEL_17; {
    int v22 = "Main key derivation";
    }
    __int16 v23 = 70;
LABEL_74:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextUnlock", v23, 57, 0, v22, v16, v17, v58);
    char v33 = 0;
    goto LABEL_75;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 1372);
  if (v21 >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(__n[0]) = v21;
  memset_s((char *)__n + v21 + 4, 256 - v21, 0, 256 - v21);
LABEL_17:
  if (!a5) {
    goto LABEL_20;
  }
  if (*(_DWORD *)a2 > 5u)
  {
    int v22 = "Unsupported signature mode";
    __int16 v23 = 102;
    goto LABEL_74;
  }
  int v24 = 1 << *(_DWORD *)a2;
  if ((v24 & 0x2A) != 0) {
    goto LABEL_20;
  }
  if ((v24 & 0x14) == 0)
  {
    uint64_t v55 = *(unsigned int *)(a1 + 2448);
    if (v55 >= 0x101) {
      goto LABEL_78;
    }
    __memcpy_chk();
    LODWORD(v83[0]) = v55;
    memset_s((char *)v83 + v55 + 4, 256 - v55, 0, 256 - v55);
    goto LABEL_63;
  }
  memset(&v133[8], 0, 252);
  memset(__s, 0, 260);
  *(_DWORD *)&v133[7] = 1262834527;
  *(void *)uint64_t v133 = 0x5F41454100000007;
  memset_s(&v133[11], 0xF9uLL, 0, 0xF9uLL);
  if (!*((void *)&v68 + 1) || !LODWORD(__n[0]))
  {
    memset_s(v133, 0x104uLL, 0, 0x104uLL);
    goto LABEL_70;
  }
  int v47 = (*((uint64_t (**)(_OWORD *, void, size_t *, unsigned char *, _OWORD *))&v68 + 1))(v85, LODWORD(v65[0]), __n, v133, __s);
  memset_s(v133, 0x104uLL, 0, 0x104uLL);
  if (v47 < 0)
  {
LABEL_70:
    int v22 = "deriving signature encryption key";
    __int16 v23 = 89;
    goto LABEL_74;
  }
  if (!*((void *)&v73 + 1))
  {
LABEL_73:
    int v22 = "decrypting signature";
    __int16 v23 = 90;
    goto LABEL_74;
  }
  memset(__s, 0, 260);
  int v131 = 0;
  memset(v130, 0, sizeof(v130));
  int v129 = 0;
  memset(v128, 0, sizeof(v128));
  if (*(_DWORD *)(a1 + 2448) != HIDWORD(v66)) {
    goto LABEL_72;
  }
  if (LODWORD(v85[0]) != LODWORD(v65[0])) {
    goto LABEL_72;
  }
  *(void *)((char *)v130 + 4) = 0x324B45535F414541;
  LODWORD(v130[0]) = 8;
  memset_s((void *)((unint64_t)v130 | 0xC), 0xF8uLL, 0, 0xF8uLL);
  memset(v133, 0, sizeof(v133));
  if (!*((void *)&v68 + 1)
    || !LODWORD(v85[0])
    || ((*((uint64_t (**)(_OWORD *, void, _OWORD *, _OWORD *, unsigned char *))&v68 + 1))(__s, DWORD1(v65[0]), v85, v130, v133) & 0x80000000) != 0)
  {
    goto LABEL_72;
  }
  uint64_t v48 = DWORD2(v66);
  if (DWORD2(v66) >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(v83[0]) = v48;
  memset_s((char *)v83 + v48 + 4, 256 - v48, 0, 256 - v48);
  uint64_t v49 = HIDWORD(v65[0]);
  if (HIDWORD(v65[0]) >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(v128[0]) = v49;
  memset_s((char *)v128 + v49 + 4, 256 - v49, 0, 256 - v49);
  if (((*((uint64_t (**)(char *, void, _OWORD *, _OWORD *, void, void))&v73 + 1))((char *)v83 + 4, LODWORD(v83[0]), v128, __s, 0, 0) & 0x80000000) != 0)
  {
LABEL_72:
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    memset_s(v128, 0x104uLL, 0, 0x104uLL);
    memset_s(v130, 0x104uLL, 0, 0x104uLL);
    goto LABEL_73;
  }
  int v50 = v83[0];
  int v51 = DWORD2(v66);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  memset_s(v128, 0x104uLL, 0, 0x104uLL);
  memset_s(v130, 0x104uLL, 0, 0x104uLL);
  if (v50 != v51) {
    goto LABEL_73;
  }
LABEL_63:
  if (!*((void *)&v71 + 1)
    || (int v56 = (*((uint64_t (**)(_OWORD *, void, void))&v71 + 1))(v81, *(void *)(a1 + 2720), *(void *)(a1 + 2728)), LODWORD(v81[0]) != DWORD1(v66))|| v56 < 0)
  {
    int v22 = "digesting prologue";
    __int16 v23 = 94;
    goto LABEL_74;
  }
  if (!*((void *)&v72 + 1)
    || ((*((uint64_t (**)(_OWORD *, _OWORD *, _OWORD *))&v72 + 1))(v83, v89, v81) & 0x80000000) != 0)
  {
    int v22 = "verifying signature";
    __int16 v23 = 97;
    goto LABEL_74;
  }
LABEL_20:
  uint64_t v25 = HIDWORD(v65[0]);
  if (HIDWORD(v65[0]) >= 0x101) {
    goto LABEL_78;
  }
  __memcpy_chk();
  LODWORD(v79[0]) = v25;
  memset_s((char *)v79 + v25 + 4, 256 - v25, 0, 256 - v25);
  uint64_t v26 = *(void *)(a1 + 2720);
  long long v28 = *(_OWORD *)(v26 + v61 + 16);
  long long v27 = *(_OWORD *)(v26 + v61 + 32);
  long long v125 = *(_OWORD *)(v26 + v61);
  long long v126 = v28;
  long long v127 = v27;
  size_t v29 = HIDWORD(v65[0]);
  size_t v30 = *(unsigned int *)(a2 + 4);
  size_t v31 = (v30 + HIDWORD(v65[0]));
  uint64_t v32 = (char *)malloc(v31);
  char v33 = v32;
  if (!v32)
  {
    int v52 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextUnlock", 113, 57, *v52, "malloc", v53, v54, v58);
LABEL_75:
    uint64_t v43 = 0xFFFFFFFFLL;
    goto LABEL_76;
  }
  memcpy(v32, (const void *)(v26 + *((void *)&v61 + 1)), v29);
  memcpy(&v33[v29], (const void *)(v26 + *((void *)&v60[0] + 1)), v30);
  memset((char *)__s + 12, 0, 248);
  *(void *)((char *)__s + 4) = 0x4B4548525F414541;
  LODWORD(__s[0]) = 8;
  memset_s((char *)__s + 12, 0xF8uLL, 0, 0xF8uLL);
  memset(v133, 0, sizeof(v133));
  if (!*((void *)&v68 + 1) || !LODWORD(__n[0]))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
LABEL_58:
    uint64_t v43 = 0xFFFFFFFFLL;
    goto LABEL_59;
  }
  int v34 = (*((uint64_t (**)(_OWORD *, void, size_t *, _OWORD *, unsigned char *))&v68 + 1))(v77, DWORD1(v65[0]), __n, __s, v133);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v34 < 0
    || !(void)v70
    || LODWORD(v79[0]) != HIDWORD(v65[0])
    || (((uint64_t (*)(long long *, uint64_t, _OWORD *, _OWORD *, char *, size_t))v70)(&v125, 48, v79, v77, v33, v31) & 0x80000000) != 0)
  {
    goto LABEL_58;
  }
  if ((aeaContainerParamsInitWithRootHeader(a2, (uint64_t)&v125, v35, v36, v37, v38, v39, v40) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextUnlock", 126, 57, 0, "Invalid root header", v41, v42, v58);
    goto LABEL_58;
  }
  uint64_t v43 = (uint64_t)v59;
  if (a3)
  {
    uint64_t v44 = LODWORD(__n[0]);
    if (LODWORD(__n[0]) >= 0x101) {
      goto LABEL_78;
    }
    memcpy(a3 + 1, (char *)__n + 4, LODWORD(__n[0]));
    *a3 = v44;
    memset_s((char *)a3 + v44 + 4, 256 - v44, 0, 256 - v44);
  }
  if (v59)
  {
    uint64_t v45 = LODWORD(v108[0]);
    if (LODWORD(v108[0]) < 0x101)
    {
      memcpy(v59 + 1, (char *)v108 + 4, LODWORD(v108[0]));
      *uint64_t v59 = v45;
      memset_s((char *)v59 + v45 + 4, 256 - v45, 0, 256 - v45);
      uint64_t v43 = 0;
      goto LABEL_59;
    }
LABEL_78:
    __break(1u);
  }
LABEL_59:
  memset_s(v33, v31, 0, v31);
LABEL_76:
  free(v33);
  memset_s(v65, 0xD0uLL, 0, 0xD0uLL);
  memset_s(v60, 0x68uLL, 0, 0x68uLL);
  memset_s(&v125, 0x30uLL, 0, 0x30uLL);
  memset_s(v87, 0x104uLL, 0, 0x104uLL);
  memset_s(v85, 0x104uLL, 0, 0x104uLL);
  memset_s(v83, 0x104uLL, 0, 0x104uLL);
  memset_s(v81, 0x104uLL, 0, 0x104uLL);
  memset_s(v108, 0x104uLL, 0, 0x104uLL);
  memset_s(__n, 0x104uLL, 0, 0x104uLL);
  memset_s(v79, 0x104uLL, 0, 0x104uLL);
  memset_s(v77, 0x104uLL, 0, 0x104uLL);
  memset_s(v89, 0x104uLL, 0, 0x104uLL);
  return v43;
}

uint64_t aeaContextCreateWithPrologue(_DWORD *a1, size_t a2)
{
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  memset(__s, 0, sizeof(__s));
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v4 = (AEAContext_impl *)malloc(0xAB8uLL);
  int v5 = v4;
  if (!v4)
  {
    int v14 = *__error();
    int v12 = "malloc";
    __int16 v13 = 161;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"aeaContextCreateWithPrologue", v13, 57, v14, v12, v10, v11, v23);
    AEAContextDestroy(v5);
    return 0;
  }
  memset_s(v4, 0xAB8uLL, 0, 0xAB8uLL);
  *((_DWORD *)v5 + 684) = 1;
  if (a2 <= 0xB)
  {
    int v12 = "Invalid prologue";
    __int16 v13 = 167;
LABEL_15:
    int v14 = 0;
    goto LABEL_16;
  }
  if ((aeaContainerParamsInitWithMagic((int *)v5, a1, v6, v7, v8, v9, v10, v11) & 0x80000000) != 0)
  {
    int v12 = "Invalid magic";
    __int16 v13 = 168;
    goto LABEL_15;
  }
  if ((aeaCryptoInit((char *)__s, (unsigned int *)v5) & 0x80000000) != 0)
  {
    int v12 = "Invalid container";
    __int16 v13 = 169;
    goto LABEL_15;
  }
  if ((aeaContainerOffsetsInit((uint64_t)&v23, (unsigned int *)v5, (unsigned int *)__s) & 0x80000000) != 0)
  {
    int v12 = "deriving container offsets";
    __int16 v13 = 170;
    goto LABEL_15;
  }
  if ((void)v27 != a2)
  {
    int v12 = "Prologue size mismatch";
    __int16 v13 = 171;
    goto LABEL_15;
  }
  *((void *)v5 + 341) = a2;
  if (a2 >= 0x2000000001)
  {
    *__error() = 12;
    *((void *)v5 + 340) = 0;
LABEL_28:
    int v14 = *__error();
    int v12 = "malloc";
    __int16 v13 = 176;
    goto LABEL_16;
  }
  uint64_t v16 = (char *)malloc(a2);
  *((void *)v5 + 340) = v16;
  if (!v16) {
    goto LABEL_28;
  }
  uint64_t v17 = v16;
  memcpy(v16, a1, a2);
  size_t v18 = *((unsigned int *)v5 + 1);
  if (v18)
  {
    uint64_t v19 = malloc(*((unsigned int *)v5 + 1));
    *((void *)v5 + 339) = v19;
    if (!v19)
    {
      int v14 = *__error();
      int v12 = "malloc";
      __int16 v13 = 184;
      goto LABEL_16;
    }
    memcpy(v19, &v17[*((void *)&v23 + 1)], v18);
  }
  if (!*((void *)&v41 + 1)
    || (uint64_t result = (*((uint64_t (**)(uint64_t, char *, size_t))&v41 + 1))((uint64_t)v5 + 1892, v17, a2),
        *((_DWORD *)v5 + 473) != DWORD1(v32))
    || (result & 0x80000000) != 0)
  {
    int v12 = "digesting prologue";
    __int16 v13 = 189;
    goto LABEL_15;
  }
  rsize_t v20 = HIDWORD(v31);
  if (HIDWORD(v31) < 0x101)
  {
    uint64_t v21 = *((void *)v5 + 340);
    int v22 = (void *)(v21 + v24);
    __memcpy_chk();
    *((_DWORD *)v5 + 612) = v20;
    memset_s((char *)v5 + v20 + 2452, 256 - v20, 0, 256 - v20);
    if (v21) {
      memset_s(v22, v20, 0, v20);
    }
    return (uint64_t)v5;
  }
  __break(1u);
  return result;
}

void AEAContextDestroy(AEAContext context)
{
  if (context)
  {
    uint64_t v2 = (void *)*((void *)context + 339);
    if (v2) {
      memset_s(*((void **)context + 339), *((unsigned int *)context + 1), 0, *((unsigned int *)context + 1));
    }
    free(v2);
    uint64_t v3 = (void *)*((void *)context + 340);
    if (v3) {
      memset_s(*((void **)context + 340), *((void *)context + 341), 0, *((void *)context + 341));
    }
    free(v3);
    memset_s(context, 0xAB8uLL, 0, 0xAB8uLL);
    free(context);
  }
}

AEAContext AEAContextCreateWithProfile(AEAProfile profile)
{
  uint64_t v2 = (AEAContext_impl *)malloc(0xAB8uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    int v12 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithProfile", 237, 57, v12, "malloc", v13, v14, v16);
    goto LABEL_5;
  }
  memset_s(v2, 0xAB8uLL, 0, 0xAB8uLL);
  *((_DWORD *)v3 + 684) = 0;
  if ((aeaContainerParamsInitWithProfile((uint64_t)v3, profile, v4, v5, v6, v7, v8, v9) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithProfile", 243, 57, 0, "Invalid profile: %u", v10, v11, profile);
LABEL_5:
    AEAContextDestroy(v3);
    return 0;
  }
  return v3;
}

AEAContext AEAContextCreateWithEncryptedStream(AAByteStream encrypted_stream)
{
  memset(__s, 0, sizeof(__s));
  uint64_t v36 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v34 = 0;
  *(_OWORD *)__timespec size = 0u;
  long long v33 = 0u;
  memset(v31, 0, sizeof(v31));
  int v30 = 0;
  uint64_t v29 = 0;
  if (*((void *)encrypted_stream + 2))
  {
    uint64_t v4 = 0;
    uint64_t v5 = &v29;
    uint64_t v6 = 12;
    do
    {
      uint64_t v7 = (*((uint64_t (**)(void, uint64_t *, uint64_t))encrypted_stream + 2))(*(void *)encrypted_stream, v5, v6);
      if (v7 < 0) {
        goto LABEL_12;
      }
      if (!v7) {
        break;
      }
      uint64_t v5 = (uint64_t *)((char *)v5 + v7);
      v4 += v7;
      v6 -= v7;
    }
    while (v6);
    if (v4 != 12) {
      goto LABEL_12;
    }
    if ((aeaContainerParamsInitWithMagic((int *)v35, &v29, v8, v9, v10, v11, v1, v2) & 0x80000000) != 0)
    {
      uint64_t v13 = "Invalid magic";
      __int16 v14 = 264;
      goto LABEL_13;
    }
    if ((aeaCryptoInit((char *)__s, (unsigned int *)v35) & 0x80000000) != 0)
    {
      uint64_t v13 = "Invalid container";
      __int16 v14 = 265;
      goto LABEL_13;
    }
    if ((aeaContainerOffsetsInit((uint64_t)v31, (unsigned int *)v35, (unsigned int *)__s) & 0x80000000) != 0)
    {
      uint64_t v13 = "deriving container offsets";
      __int16 v14 = 266;
      goto LABEL_13;
    }
    size_t v12 = __size[0];
    if (__size[0] >= 0x2000000001)
    {
      *__error() = 12;
LABEL_28:
      int v15 = *__error();
      uint64_t v13 = "malloc";
      __int16 v14 = 271;
      goto LABEL_14;
    }
    uint64_t v19 = malloc(__size[0]);
    if (!v19) {
      goto LABEL_28;
    }
    char v16 = v19;
    *(void *)uint64_t v19 = v29;
    v19[2] = v30;
    if (*((void *)encrypted_stream + 2))
    {
      uint64_t v22 = 0;
      if (v12 != 12)
      {
        long long v23 = (char *)(v19 + 3);
        size_t v24 = v12 - 12;
        while (1)
        {
          uint64_t v25 = (*((uint64_t (**)(void, char *, size_t))encrypted_stream + 2))(*(void *)encrypted_stream, v23, v24);
          if (v25 < 0) {
            break;
          }
          if (v25)
          {
            v23 += v25;
            v22 += v25;
            v24 -= v25;
            if (v24) {
              continue;
            }
          }
          goto LABEL_31;
        }
        uint64_t v22 = v25;
      }
    }
    else
    {
      uint64_t v22 = -1;
    }
LABEL_31:
    if (v22 == v12 - 12)
    {
      uint64_t v26 = aeaContextCreateWithPrologue(v16, v12);
      if (v26)
      {
        uint64_t v17 = (AEAContext_impl *)v26;
        free(v16);
        return v17;
      }
      long long v27 = "Context creation";
      __int16 v28 = 280;
    }
    else
    {
      long long v27 = "reading prologue";
      __int16 v28 = 276;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithEncryptedStream", v28, 57, 0, v27, v20, v21, v29);
  }
  else
  {
LABEL_12:
    uint64_t v13 = "reading magic";
    __int16 v14 = 263;
LABEL_13:
    int v15 = 0;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextCreateWithEncryptedStream", v14, 57, v15, v13, v1, v2, v29);
    char v16 = 0;
  }
  free(v16);
  AEAContextDestroy(0);
  return 0;
}

uint64_t AEAContextGetFieldUInt(AEAContext context, AEAContextField field)
{
  switch(field)
  {
    case 0u:
      uint64_t result = *(unsigned int *)context;
      break;
    case 1u:
      uint64_t result = *((void *)context + 7);
      break;
    case 2u:
      uint64_t result = *((unsigned int *)context + 3);
      break;
    case 3u:
      uint64_t result = *((unsigned int *)context + 6);
      break;
    case 4u:
      uint64_t result = *((unsigned int *)context + 4);
      break;
    case 0xDu:
      uint64_t result = *((void *)context + 4);
      break;
    case 0xEu:
      uint64_t result = *((void *)context + 5);
      break;
    case 0x11u:
      uint64_t result = *((unsigned int *)context + 5);
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGetFieldUInt", 314, 57, 0, "Invalid field", v2, v3, vars0);
      uint64_t result = -1;
      break;
  }
  return result;
}

int AEAContextGetFieldBlob(AEAContext context, AEAContextField field, AEAContextFieldRepresentation representation, size_t buf_capacity, uint8_t *buf, size_t *buf_size)
{
  if (field > 0x13) {
    goto LABEL_14;
  }
  if (((1 << field) & 0xC1260) != 0)
  {
    if (representation)
    {
      uint64_t v8 = "Invalid representation";
      __int16 v9 = 337;
LABEL_23:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGetFieldBlob", v9, 57, 0, v8, v6, v7, vars0);
      return -1;
    }
    goto LABEL_7;
  }
  if (((1 << field) & 0xD80) == 0)
  {
LABEL_14:
    uint64_t v8 = "Invalid field";
    __int16 v9 = 346;
    goto LABEL_23;
  }
  if (representation != 1)
  {
    uint64_t v8 = "Invalid representation";
    __int16 v9 = 343;
    goto LABEL_23;
  }
LABEL_7:
  switch(field)
  {
    case 5u:
      if (buf_size) {
        *buf_timespec size = *((unsigned int *)context + 1);
      }
      if (!buf_capacity) {
        goto LABEL_30;
      }
      size_t v10 = *((unsigned int *)context + 1);
      if (v10 > buf_capacity)
      {
        uint64_t v8 = "buf_capacity is too small";
        __int16 v9 = 358;
        goto LABEL_23;
      }
      memcpy(buf, *((const void **)context + 339), v10);
LABEL_30:
      int result = 0;
      break;
    case 6u:
      uint64_t v11 = (unsigned int *)((char *)context + 1372);
      goto LABEL_26;
    case 7u:
      uint64_t v11 = (unsigned int *)((char *)context + 332);
      goto LABEL_26;
    case 8u:
      uint64_t v11 = (unsigned int *)((char *)context + 592);
      goto LABEL_26;
    case 9u:
      uint64_t v11 = (unsigned int *)((char *)context + 72);
      goto LABEL_26;
    case 0xAu:
      uint64_t v11 = (unsigned int *)((char *)context + 852);
      goto LABEL_26;
    case 0xBu:
      uint64_t v11 = (unsigned int *)((char *)context + 1112);
      goto LABEL_26;
    case 0xCu:
      uint64_t v11 = (unsigned int *)((char *)context + 1632);
      goto LABEL_26;
    case 0x12u:
      uint64_t v11 = (unsigned int *)((char *)context + 1892);
      goto LABEL_26;
    case 0x13u:
      uint64_t v11 = (unsigned int *)((char *)context + 2152);
LABEL_26:
      return getFieldBlob(v11, buf_capacity, buf, buf_size, (uint64_t)buf, (uint64_t)buf_size, v6, v7);
    default:
      uint64_t v8 = "Invalid field";
      __int16 v9 = 375;
      goto LABEL_23;
  }
  return result;
}

uint64_t getFieldBlob(unsigned int *a1, size_t a2, void *__dst, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    *a4 = *a1;
  }
  if (a2)
  {
    size_t v8 = *a1;
    if (v8 > a2)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"getFieldBlob", 212, 57, 0, "buf_capacity is too small", a7, a8, vars0);
      return 0xFFFFFFFFLL;
    }
    memcpy(__dst, a1 + 1, v8);
  }
  return 0;
}

int AEAContextSetFieldUInt(AEAContext context, AEAContextField field, uint64_t value)
{
  if (field == 1 || !*((_DWORD *)context + 684))
  {
    switch(field)
    {
      case 1u:
        if (value - 16 >= 0xFFFFFFFFFFFFFFF2)
        {
          uint64_t v6 = "Invalid padding size";
          __int16 v7 = 415;
          goto LABEL_4;
        }
        int result = 0;
        *((void *)context + 7) = value;
        return result;
      case 2u:
        if (value > 2)
        {
          uint64_t v6 = "Invalid checksum mode";
          __int16 v7 = 429;
          goto LABEL_4;
        }
        *((_DWORD *)context + 3) = value;
        int v10 = aeaChecksumSize(value);
        int result = 0;
        *((_DWORD *)context + 12) = v10;
        return result;
      case 3u:
        if ((uint64_t)value <= 1284)
        {
          if (value && value != 256 && value != 774) {
            goto LABEL_36;
          }
        }
        else if ((uint64_t)value > 2048)
        {
          if (value != 2304 && value != 2049) {
            goto LABEL_36;
          }
        }
        else if (value != 1285 && value != 1794)
        {
LABEL_36:
          uint64_t v6 = "Invalid compression algorithm";
          __int16 v7 = 398;
          goto LABEL_4;
        }
        int result = 0;
        *((_DWORD *)context + 6) = value;
        return result;
      case 4u:
        int result = 0;
        uint64_t v11 = 0x4000;
        if (value > 0x4000) {
          uint64_t v11 = value;
        }
        if (v11 >= 0x10000000) {
          LODWORD(v11) = 0x10000000;
        }
        *((_DWORD *)context + 4) = v11;
        return result;
      default:
        if (field != 17)
        {
          uint64_t v6 = "Invalid field";
          __int16 v7 = 439;
          goto LABEL_4;
        }
        int result = 0;
        uint64_t v9 = 32;
        if (value > 0x20) {
          uint64_t v9 = value;
        }
        if (v9 >= 0x40000) {
          LODWORD(v9) = 0x40000;
        }
        *((_DWORD *)context + 5) = v9;
        return result;
    }
  }
  uint64_t v6 = "Context can't be modified";
  __int16 v7 = 384;
LABEL_4:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextSetFieldUInt", v7, 57, 0, v6, v3, v4, v12);
  return -1;
}

int AEAContextSetFieldBlob(AEAContext context, AEAContextField field, AEAContextFieldRepresentation representation, const uint8_t *buf, size_t buf_size)
{
  if (field > 0x13) {
    goto LABEL_14;
  }
  if (((1 << field) & 0x81260) == 0)
  {
    if (((1 << field) & 0xD80) != 0)
    {
      if (representation != 1)
      {
        uint64_t v11 = "Invalid representation";
        __int16 v12 = 464;
        goto LABEL_23;
      }
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v11 = "Invalid field";
    __int16 v12 = 467;
LABEL_23:
    int v14 = 0;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextSetFieldBlob", v12, 57, v14, v11, v6, v7, v18);
    return -1;
  }
  if (representation)
  {
    uint64_t v11 = "Invalid representation";
    __int16 v12 = 458;
    goto LABEL_23;
  }
  if (field == 19 && buf_size <= 0x13)
  {
    uint64_t v11 = "Password is too short";
    __int16 v12 = 471;
    goto LABEL_23;
  }
LABEL_7:
  switch(field)
  {
    case 5u:
      if (*((_DWORD *)context + 684))
      {
        uint64_t v11 = "Context can't be modified";
        __int16 v12 = 477;
        goto LABEL_23;
      }
      char v16 = (void *)*((void *)context + 339);
      if (v16) {
        memset_s(*((void **)context + 339), *((unsigned int *)context + 1), 0, *((unsigned int *)context + 1));
      }
      free(v16);
      *((void *)context + 339) = 0;
      *((_DWORD *)context + 1) = 0;
      if (!buf_size) {
        goto LABEL_36;
      }
      if (buf_size >= 0x4000001)
      {
        char v18 = buf_size;
        uint64_t v11 = "Invalid auth data size: %zu";
        __int16 v12 = 483;
        goto LABEL_23;
      }
      uint64_t v17 = malloc(buf_size);
      *((void *)context + 339) = v17;
      if (!v17)
      {
        int v14 = *__error();
        uint64_t v11 = "malloc";
        __int16 v12 = 486;
        goto LABEL_24;
      }
      *((_DWORD *)context + 1) = buf_size;
      memcpy(v17, buf, buf_size);
LABEL_36:
      int result = 0;
      break;
    case 6u:
      uint64_t v13 = (char *)context + 1372;
      goto LABEL_26;
    case 7u:
      uint64_t v13 = (char *)context + 332;
      goto LABEL_26;
    case 8u:
      uint64_t v13 = (char *)context + 592;
      goto LABEL_26;
    case 9u:
      uint64_t v13 = (char *)context + 72;
      goto LABEL_26;
    case 0xAu:
      uint64_t v13 = (char *)context + 852;
      goto LABEL_26;
    case 0xBu:
      uint64_t v13 = (char *)context + 1112;
      goto LABEL_26;
    case 0xCu:
      uint64_t v13 = (char *)context + 1632;
      goto LABEL_26;
    case 0x13u:
      uint64_t v13 = (char *)context + 2152;
LABEL_26:
      return setFieldBlob(v13, buf, buf_size, (uint64_t)buf, buf_size, v5, v6, v7);
    default:
      uint64_t v11 = "Invalid field";
      __int16 v12 = 502;
      goto LABEL_23;
  }
  return result;
}

uint64_t setFieldBlob(_DWORD *a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0x101)
  {
    uint64_t v11 = a1 + 1;
    memcpy(a1 + 1, a2, a3);
    *a1 = a3;
    memset_s((char *)v11 + a3, 256 - a3, 0, 256 - a3);
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"setFieldBlob", 223, 57, 0, "Invalid field size", a7, a8, v12);
    return 0xFFFFFFFFLL;
  }
}

int AEAContextGenerateFieldBlob(AEAContext context, AEAContextField field)
{
  unint64_t v11 = 0;
  if (field == 19)
  {
    uint64_t v5 = (char *)context + 2156;
    int result = AEAKeychainGenerateItem(0, 0x63uLL, 0x100uLL, (char *)context + 2156, &v11, 0, v2, v3);
    if ((result & 0x80000000) == 0)
    {
      unint64_t v7 = v11;
      if (v11 < 0x101)
      {
        *((_DWORD *)context + 538) = v11;
        goto LABEL_9;
      }
      goto LABEL_15;
    }
    size_t v8 = "generate random field";
    __int16 v9 = 527;
  }
  else if (field == 9)
  {
    uint64_t v5 = (char *)context + 76;
    int result = AEAKeychainGenerateItem(1, 0x100uLL, 0x100uLL, (char *)context + 76, &v11, 0, v2, v3);
    if ((result & 0x80000000) == 0)
    {
      unint64_t v7 = v11;
      if (v11 < 0x101)
      {
        *((_DWORD *)context + 18) = v11;
LABEL_9:
        memset_s(&v5[v7], 256 - v7, 0, 256 - v7);
        return 0;
      }
LABEL_15:
      __break(1u);
      return result;
    }
    size_t v8 = "generate random field";
    __int16 v9 = 520;
  }
  else
  {
    size_t v8 = "Invalid field";
    __int16 v9 = 532;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGenerateFieldBlob", v9, 57, 0, v8, v2, v3, v10);
  return -1;
}

uint64_t AEAContextSetFieldCallback(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == 16)
  {
    uint64_t result = 0;
    a1[305] = a3;
    a1[304] = a4;
  }
  else if (a2 == 15)
  {
    uint64_t result = 0;
    a1[303] = a3;
    a1[302] = a4;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextSetFieldCallback", 555, 57, 0, "Invalid field", a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t AEAContextGetContainerSizeUpperBound(uint64_t a1, uint64_t a2)
{
  memset(__s, 0, sizeof(__s));
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  memset(v16, 0, sizeof(v16));
  if ((aeaCryptoInit((char *)__s, (unsigned int *)a1) & 0x80000000) != 0)
  {
    uint64_t v13 = "Invalid context";
    __int16 v14 = 569;
    goto LABEL_13;
  }
  if ((aeaContainerOffsetsInit((uint64_t)v16, (unsigned int *)a1, (unsigned int *)__s) & 0x80000000) != 0)
  {
    uint64_t v13 = "deriving container offsets";
    __int16 v14 = 572;
    goto LABEL_13;
  }
  unint64_t v10 = v19
      * (((a2 + (unint64_t)*(unsigned int *)(a1 + 16) - 1) / *(unsigned int *)(a1 + 16)
        + *(unsigned int *)(a1 + 20)
        - 1)
       / *(unsigned int *)(a1 + 20));
  BOOL v11 = __CFADD__((void)v17, v10);
  uint64_t v12 = v17 + v10;
  if (v11)
  {
    uint64_t v13 = "invalid sizes";
    __int16 v14 = 580;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEAContext.c", (uint64_t)"AEAContextGetContainerSizeUpperBound", v14, 57, 0, v13, v4, v5, v16[0]);
    return -1;
  }
  if (__CFADD__(v12, a2))
  {
    uint64_t v13 = "invalid sizes";
    __int16 v14 = 581;
    goto LABEL_13;
  }
  unint64_t result = aeaPaddedContainerSize(v12 + a2, *(void *)(a1 + 56), v6, v7, v8, v9, v4, v5);
  if (result == -1)
  {
    uint64_t v13 = "Container size is too large to allow padding";
    __int16 v14 = 585;
    goto LABEL_13;
  }
  return result;
}

uint64_t LargeFileWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = MEMORY[0x270FA5388](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v80 = *MEMORY[0x263EF8340];
  *(void *)(v8 + 8) = 0;
  if (atomic_load((unsigned int *)(*(void *)v8 + 104))) {
    return 0;
  }
  unint64_t v10 = (void *)v8;
  BOOL v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = *(void *)v8;
  uint64_t v15 = *(unsigned int *)(v8 + 32);
  char v16 = (unint64_t *)(v8 + 16);
  int v78 = 0;
  if ((unint64_t)(*(void *)(v14 + 56) - (v15 << 21)) >= 0x200000) {
    size_t v17 = 0x200000;
  }
  else {
    size_t v17 = *(void *)(v14 + 56) - (v15 << 21);
  }
  size_t v18 = v17 - 17;
  if (v17 >= 0x11)
  {
    uint64_t v12 = malloc(0x1000000uLL);
    BOOL v11 = (unsigned __int8 *)malloc(v17);
    uint64_t v22 = (char *)malloc(0x40000uLL);
    uint64_t v13 = v22;
    if (!v12 || (v11 ? (BOOL v23 = v22 == 0) : (BOOL v23 = 1), v23))
    {
      int v33 = *__error();
      uint64_t v34 = "aaMalloc";
      __int16 v35 = 496;
LABEL_72:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", v35, 112, v33, v34, v24, v25, v70);
      int v21 = 0;
      goto LABEL_73;
    }
    long long v72 = v16;
    memset(__b, 255, sizeof(__b));
    uint64_t v26 = *(void **)(v14 + 24);
    if (!v26[4]) {
      goto LABEL_70;
    }
    __base = v13;
    uint64_t v27 = 0;
    size_t v28 = v17;
    uint64_t v29 = v15 << 21;
    int v30 = v11;
    int v73 = v15;
    unint64_t v74 = v28;
    size_t v31 = v28;
    while (1)
    {
      uint64_t v32 = ((uint64_t (*)(void, unsigned __int8 *, size_t, uint64_t))v26[4])(*v26, v30, v31, v29);
      if (v32 < 0) {
        break;
      }
      if (v32)
      {
        v30 += v32;
        v27 += v32;
        v29 += v32;
        v31 -= v32;
        if (v31) {
          continue;
        }
      }
      goto LABEL_25;
    }
    uint64_t v27 = v32;
LABEL_25:
    LODWORD(v15) = v73;
    size_t v17 = v74;
    BOOL v23 = v74 == v27;
    uint64_t v13 = __base;
    if (v23)
    {
      uint64_t v36 = 0;
      unsigned int v37 = 0;
      do
        unsigned int v37 = -1640531535 * (v37 + v11[v36++]);
      while (v36 != 16);
      uint64_t v75 = (uint64_t)v12;
      unint64_t v38 = 0;
      unint64_t v39 = 0;
      unint64_t v40 = 0;
      unsigned int v41 = 0;
      int v42 = *(_DWORD *)(v14 + 76);
      uint64_t v43 = 16;
      do
      {
        if (v40 >= v38 || (*(_DWORD *)(v14 + 68) & ~v37) == 0)
        {
          unint64_t v38 = v40 + (2 * *(_DWORD *)(v14 + 72));
          if (v40 >= v39)
          {
            uint64_t v44 = *(unsigned int *)(*(void *)(v14 + 40) + 4 * (v37 >> -*(unsigned char *)(v14 + 64)));
            if (v44 != -1)
            {
              uint64_t v45 = __ROR8__(__ROR8__(2654435761 * *(void *)&v11[v40], 41) + 2654435761 * *(void *)&v11[v40 + 8], 41);
              int v46 = HIDWORD(v45) ^ v45;
              uint64_t v47 = *(void *)(v14 + 32);
              while (1)
              {
                uint64_t v48 = v47 + 16 * v44;
                if (*(_DWORD *)(v48 + 8) == v46) {
                  break;
                }
                uint64_t v44 = *(unsigned int *)(v48 + 12);
                if (v44 == -1) {
                  goto LABEL_46;
                }
              }
              uint64_t v49 = *(void *)(v47 + 16 * v44);
              uint64_t v50 = v49 >> 20;
              unint64_t v51 = v49 & 0xFFFFFFFFFFF00000;
              int v52 = __b[v50];
              if (v52 == -1)
              {
LABEL_42:
                if (v41 != 0x4000)
                {
                  uint64_t v54 = &__base[16 * v41];
                  *(void *)uint64_t v54 = v51;
                  *((_DWORD *)v54 + 2) = v52;
                  *((_DWORD *)v54 + 3) = 1;
                  __b[v50] = v41++;
                }
              }
              else
              {
                uint64_t v53 = __b[v50];
                while (*(void *)&__base[16 * v53] != v51)
                {
                  uint64_t v53 = *(unsigned int *)&__base[16 * v53 + 8];
                  if (v53 == -1) {
                    goto LABEL_42;
                  }
                }
                ++*(_DWORD *)&__base[16 * v53 + 12];
              }
              unint64_t v39 = v43;
            }
          }
        }
LABEL_46:
        unsigned int v37 = -1640531535 * (v37 + v11[v43]) - v42 * v11[v40];
        uint64_t v43 = v40 + 17;
        BOOL v23 = v40++ == v18;
      }
      while (!v23);
      if (!v41)
      {
        char v16 = v72;
        goto LABEL_6;
      }
      uint64_t v71 = (uint64_t)v11;
      qsort(__base, v41, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_rating);
      if (v41 >= 0x10) {
        size_t v55 = 16;
      }
      else {
        size_t v55 = v41;
      }
      size_t v76 = v55;
      qsort(__base, v55, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_position);
      uint64_t v58 = 0;
      LODWORD(v17) = 0;
      do
      {
        uint64_t v59 = *(void *)&v13[16 * v58];
        if ((unint64_t)(*(void *)(v14 + 48) - v59) >= 0x100000) {
          uint64_t v60 = 0x100000;
        }
        else {
          uint64_t v60 = *(void *)(v14 + 48) - v59;
        }
        long long v61 = *(void **)(v14 + 16);
        if (!v61[4]) {
          goto LABEL_80;
        }
        if (v60)
        {
          uint64_t v62 = 0;
          uint64_t v63 = v75 + v17;
          uint64_t v64 = v60;
          while (1)
          {
            uint64_t v65 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v61[4])(*v61, v63, v64, v59);
            if (v65 < 0) {
              break;
            }
            if (v65)
            {
              v63 += v65;
              v62 += v65;
              v59 += v65;
              v64 -= v65;
              if (v64) {
                continue;
              }
            }
            goto LABEL_64;
          }
          uint64_t v62 = v65;
LABEL_64:
          BOOL v23 = v60 == v62;
          uint64_t v13 = __base;
          if (!v23)
          {
LABEL_80:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", 546, 112, 0, "aaByteStreamPReadExpected", v56, v57, v70);
            int v21 = 0;
            uint64_t v12 = (void *)v75;
            BOOL v11 = (unsigned __int8 *)v71;
            goto LABEL_73;
          }
        }
        size_t v17 = (v17 + v60);
        ++v58;
      }
      while (v58 != v76);
      uint64_t v12 = (void *)v75;
      BOOL v11 = (unsigned __int8 *)v71;
      char v16 = v72;
      if ((getBXDiffControls(v75, v17, v71, v74, (int8x16_t **)&v78, (uint64_t)v72, (int *)v14, v57) & 0x80000000) != 0)
      {
        uint64_t v34 = "generic controls";
        __int16 v35 = 550;
      }
      else
      {
        int v78 = convert_block_controls(v72, v78, *v72, (uint64_t)v13, v66, v67, v24, v25);
        if (v78)
        {
          LODWORD(v15) = v73;
          goto LABEL_8;
        }
        uint64_t v34 = "convert_block_controls";
        __int16 v35 = 552;
      }
    }
    else
    {
LABEL_70:
      uint64_t v34 = "aaByteStreamPReadExpected";
      __int16 v35 = 501;
    }
    int v33 = 0;
    goto LABEL_72;
  }
LABEL_6:
  uint64_t v19 = malloc(0x18uLL);
  int v78 = v19;
  if (!v19)
  {
    int v33 = *__error();
    uint64_t v34 = "aaMalloc";
    __int16 v35 = 534;
    goto LABEL_72;
  }
  size_t v20 = v17;
  LODWORD(v17) = 0;
  *uint64_t v19 = 0;
  v19[1] = v20;
  v19[2] = 0;
  *char v16 = 1;
LABEL_8:
  if (*(int *)(v14 + 4) >= 3) {
    fprintf((FILE *)*MEMORY[0x263EF8348], " LargeFile: Block = %5u, %5u K cache, %6zu controls\n", v15, v17 >> 10, *v16);
  }
  int v21 = 1;
LABEL_73:
  free(v12);
  free(v11);
  free(v13);
  if ((v21 & 1) == 0) {
    free(v78);
  }
  long long v68 = v78;
  if (!v21) {
    long long v68 = 0;
  }
  v10[1] = v68;
  if (v68) {
    return 0;
  }
  atomic_compare_exchange_strong((atomic_uint *volatile)(*v10 + 104), (unsigned int *)&v68, 1u);
  return 0xFFFFFFFFLL;
}

uint64_t LargeFileConsumer(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (atomic_load((unsigned int *)(*a2 + 104))) {
    return 0;
  }
  uint64_t result = a2[1];
  if (result)
  {
    if (a2[2])
    {
      uint64_t v12 = 0;
      unint64_t v13 = 0;
      uint64_t v14 = *(char **)a1;
      do
      {
        uint64_t v14 = add_control(v14, (unint64_t *)(a1 + 8), (unint64_t *)(a1 + 16), *(void *)(a2[1] + v12), *(void *)(a2[1] + v12 + 8), *(void *)(a2[1] + v12 + 16), a7, a8);
        *(void *)a1 = v14;
        if (!v14) {
          break;
        }
        ++v13;
        v12 += 24;
      }
      while (v13 < a2[2]);
      uint64_t result = a2[1];
    }
    free((void *)result);
    if (!*(void *)a1)
    {
      uint64_t v15 = *(char **)a1;
      atomic_compare_exchange_strong((atomic_uint *volatile)(*a2 + 104), (unsigned int *)&v15, 1u);
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  return result;
}

uint64_t GetLargeFileControlsWithStreams(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7)
{
  double RealTime = getRealTime();
  unsigned int DefaultNThreads = *((_DWORD *)a7 + 2);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  *(void *)long long v109 = 0;
  long long v107 = 0u;
  *(_OWORD *)long long v108 = 0u;
  *(_OWORD *)long long v105 = 0u;
  long long v106 = 0u;
  uint64_t v102 = 0;
  long long v98 = 0;
  uint64_t v99 = 0;
  uint64_t v103 = a1;
  long long v104 = a3;
  uint64_t v16 = *a7;
  int v17 = 16;
  unint64_t v100 = 0;
  v101[1] = HIDWORD(v16);
  v101[0] = 21;
  int v18 = __clz((a2 + 15) >> 4);
  LODWORD(v102) = 1;
  v105[1] = (void *)a2;
  *(void *)&long long v106 = a4;
  if (1 << ~(_BYTE)v18 >= (a2 + 15) >> 4) {
    unsigned int v19 = 63 - v18;
  }
  else {
    unsigned int v19 = 64 - v18;
  }
  LODWORD(v107) = 16;
  if (v19 >= 0x1E)
  {
    do
    {
      --v19;
      v17 *= 2;
    }
    while (v19 > 0x1D);
    LODWORD(v107) = v17;
    unsigned int v19 = 29;
  }
  DWORD2(v106) = v19;
  HIDWORD(v106) = v17 - 1;
  DWORD1(v107) = 840293553;
  if (DefaultNThreads < 0xCCCCCCCD)
  {
    size_t v20 = calloc(DefaultNThreads, 0x28uLL);
  }
  else
  {
    size_t v20 = 0;
    *__error() = 12;
  }
  v108[0] = v20;
  int v21 = calloc(DefaultNThreads, 8uLL);
  v108[1] = v21;
  if (!v20 || !v21)
  {
    int v49 = *__error();
    uint64_t v50 = "aaCalloc";
    __int16 v51 = 672;
LABEL_35:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v51, 112, v49, v50, v22, v23, v95);
    goto LABEL_36;
  }
  *((void *)&v104 + 1) = pc_array_init(16, (5 * (a2 / v107)) >> 2);
  if (!*((void *)&v104 + 1))
  {
    uint64_t v50 = "pc_array_init";
    __int16 v51 = 678;
LABEL_34:
    int v49 = 0;
    goto LABEL_35;
  }
  uint64_t v24 = malloc(4 << SBYTE8(v106));
  v105[0] = v24;
  if (!v24)
  {
    int v49 = *__error();
    uint64_t v50 = "malloc";
    __int16 v51 = 683;
    goto LABEL_35;
  }
  memset(v24, 255, 4 << SBYTE8(v106));
  uint64_t v25 = calloc(DefaultNThreads, 0x20uLL);
  uint64_t v26 = calloc(DefaultNThreads, 8uLL);
  uint64_t v27 = v26;
  if (!v25 || !v26)
  {
    uint64_t v54 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 433, 112, *v54, "aaCalloc", v55, v56, v95);
    unint64_t v39 = 0;
LABEL_49:
    int v48 = 0;
    goto LABEL_50;
  }
  if (DefaultNThreads)
  {
    size_t v28 = v25;
    uint64_t v29 = v26;
    uint64_t v30 = DefaultNThreads;
    size_t v31 = v25;
    do
    {
      *size_t v31 = v101;
      v31 += 4;
      *v29++ = v28;
      size_t v28 = v31;
      --v30;
    }
    while (v30);
  }
  unint64_t v39 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v26, (uint64_t)fingerprint_worker, (uint64_t)v101, (uint64_t)fingerprint_consumer, 0);
  if (!v39)
  {
    uint64_t v57 = "ThreadPipelineCreate";
    __int16 v58 = 444;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v58, 112, 0, v57, v37, v38, v95);
    goto LABEL_49;
  }
  long long v97 = a6;
  if (!v105[1])
  {
LABEL_29:
    a6 = v97;
    if ((ThreadPipelineFlush((uint64_t)v39) & 0x80000000) != 0)
    {
      uint64_t v57 = "ThreadPipelineFlush";
      __int16 v58 = 461;
    }
    else
    {
      *((void *)&v104 + 1) = pc_array_compact(*((uint64_t *)&v104 + 1));
      if (*((void *)&v104 + 1))
      {
        int v48 = 1;
        goto LABEL_50;
      }
      uint64_t v57 = "pc_array_compact";
      __int16 v58 = 465;
    }
    goto LABEL_48;
  }
  uint64_t v40 = 0;
  unsigned int v41 = 0;
  while (1)
  {
    uint64_t Worker = (void *)ThreadPipelineGetWorker((uint64_t)v39, v32, v33, v34, v35, v36, v37, v38);
    if (!Worker)
    {
      uint64_t v59 = "ThreadPipelineGetWorker";
      __int16 v60 = 451;
      goto LABEL_45;
    }
    Worker[1] = 0;
    Worker[2] = v41;
    uint64_t v47 = (uint64_t)v105[1] + v40;
    if ((unint64_t)v105[1] + v40 >= 0x200000) {
      uint64_t v47 = 0x200000;
    }
    Worker[3] = v47;
    if ((ThreadPipelineRunWorker((uint64_t)v39, (uint64_t)Worker, v43, v44, v45, v46, v37, v38) & 0x80000000) != 0) {
      break;
    }
    v41 += 0x200000;
    v40 -= 0x200000;
    if (v41 >= v105[1]) {
      goto LABEL_29;
    }
  }
  uint64_t v59 = "ThreadPipelineRunWorker";
  __int16 v60 = 457;
LABEL_45:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v60, 112, 0, v59, v37, v38, v95);
  int v48 = 0;
  a6 = v97;
LABEL_50:
  if ((ThreadPipelineDestroy((uint64_t)v39) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 468, 112, 0, "ThreadPipelineDestroy", v61, v62, v95);
    int v48 = 0;
  }
  free(v25);
  free(v27);
  if (!v48) {
    goto LABEL_36;
  }
  if (*((int *)a7 + 1) >= 3)
  {
    uint64_t v65 = (FILE *)*MEMORY[0x263EF8348];
    unint64_t v66 = (unint64_t)(4 << SBYTE8(v106)) >> 20;
    uint64_t v67 = a5;
    uint64_t v68 = (*(void *)(*((void *)&v104 + 1) - 64) >> 16) & 0xFFFFFFFFFFFLL;
    unint64_t v69 = (unint64_t)v105[1] >> 20;
    double v70 = getRealTime();
    uint64_t v96 = v68;
    a5 = v67;
    fprintf(v65, " LargeFile: Using %zu M for hashing.\n LargeFile: Using %zu M for fingerprints.\n LargeFile: Parsed %zu M in %0.2f (s). Added %zu/%zu fingerprints.\n", v66, v96, v69, v70 - RealTime, *(void *)(*((void *)&v104 + 1) - 64), (unint64_t)v105[1] / v107);
  }
  long long v98 = add_control(0, (unint64_t *)&v99, &v100, 0, 0, 0, v63, v64);
  if (!v98) {
    goto LABEL_36;
  }
  if (DefaultNThreads)
  {
    for (uint64_t i = 0; i != DefaultNThreads; *((void *)v108[1] + i++) = v72)
    {
      long long v72 = (char *)v108[0] + 40 * i;
      *long long v72 = v101;
    }
  }
  int v73 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v108[1], (uint64_t)LargeFileWorker, (uint64_t)&v98, (uint64_t)LargeFileConsumer, 0);
  *((void *)&v107 + 1) = v73;
  if (!v73)
  {
    uint64_t v50 = "creating pipeline";
    __int16 v51 = 711;
    goto LABEL_34;
  }
  if (!a4)
  {
LABEL_67:
    if ((ThreadPipelineDestroy((uint64_t)v73) & 0x80000000) == 0)
    {
      *((void *)&v107 + 1) = 0;
      uint64_t v99 = sanitize_internal_controls(v98, v99);
      convert_internal_controls((uint64_t)&v98);
      if (*((int *)a7 + 1) >= 2)
      {
        uint64_t v89 = (FILE *)*MEMORY[0x263EF8348];
        uint64_t v90 = v99;
        double v91 = getRealTime();
        fprintf(v89, "LargeFile: Constructed %zu controls in %0.2f (s).\n", v90, v91 - RealTime);
      }
      int v52 = 0;
      uint64_t v92 = v99;
      *a5 = v98;
      *a6 = v92;
      goto LABEL_37;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", 725, 112, 0, "ThreadPipelineDestroy failed", v87, v88, v95);
    *((void *)&v107 + 1) = 0;
LABEL_36:
    int v52 = 1;
    goto LABEL_37;
  }
  unsigned int v79 = 1;
  while (1)
  {
    uint64_t v80 = ThreadPipelineGetWorker(*((uint64_t *)&v107 + 1), v74, v75, v76, v77, v78, v22, v23);
    if (!v80) {
      break;
    }
    *(_DWORD *)(v80 + 32) = v79 - 1;
    if ((ThreadPipelineRunWorker(*((uint64_t *)&v107 + 1), v80, v81, v82, v83, v84, v22, v23) & 0x80000000) != 0
      || (unsigned int v85 = atomic_load(v109)) != 0)
    {
      long long v93 = "RunWorker";
      __int16 v94 = 723;
      goto LABEL_75;
    }
    uint64_t v86 = v79++;
    if (a4 <= v86 << 21)
    {
      int v73 = (unsigned int *)*((void *)&v107 + 1);
      goto LABEL_67;
    }
  }
  long long v93 = "getting worker from pipeline";
  __int16 v94 = 718;
LABEL_75:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v94, 112, 0, v93, v22, v23, v95);
  int v52 = 1;
LABEL_37:
  ThreadPipelineDestroy(*((uint64_t *)&v107 + 1));
  free(v108[0]);
  free(v108[1]);
  free(v105[0]);
  pc_array_free(*((uint64_t *)&v104 + 1));
  if (v52)
  {
    free(v98);
    *a5 = 0;
    *a6 = 0;
  }
  return (v52 << 31 >> 31);
}

char *add_control(char *__ptr, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = __ptr;
  unint64_t v13 = *a2;
  if (*a2 < *a3) {
    goto LABEL_2;
  }
  unint64_t v15 = v13 + (v13 >> 1) + 1;
  *a3 = v15;
  if (*a2 >= v15)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 213, 112, 0, "too many controls", a7, a8, v21);
    free(v12);
    return 0;
  }
  if (24 * v15 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_10:
    int v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 215, 112, *v17, "aaReallocf", v18, v19, v21);
    return 0;
  }
  uint64_t v16 = (char *)realloc(__ptr, 24 * v15);
  if (!v16)
  {
    free(v12);
    goto LABEL_10;
  }
  unint64_t v13 = *a2;
  uint64_t v12 = v16;
LABEL_2:
  *a2 = v13 + 1;
  uint64_t v14 = &v12[24 * v13];
  *(void *)uint64_t v14 = a4;
  *((void *)v14 + 1) = a5;
  *((void *)v14 + 2) = a6;
  return v12;
}

uint64_t sanitize_internal_controls(void *a1, uint64_t a2)
{
  uint64_t v2 = (char *)a1;
  if (a2 >= 2)
  {
    unint64_t v3 = (unint64_t)&a1[3 * a2];
    uint64_t v4 = a1 + 3;
    uint64_t v5 = a1;
    uint64_t v6 = (char *)a1;
    do
    {
      uint64_t v7 = v5;
      while (1)
      {
        uint64_t v5 = v4;
        uint64_t v8 = *v4;
        if (!v8)
        {
          uint64_t v9 = *((void *)v6 + 1) + v7[4];
          goto LABEL_9;
        }
        if (*((void *)v6 + 1) || *(void *)v6 + *((void *)v6 + 2) != v7[5]) {
          break;
        }
        *(void *)v6 += v8;
        uint64_t v9 = v7[4];
LABEL_9:
        *((void *)v6 + 1) = v9;
        uint64_t v4 = v5 + 3;
        uint64_t v7 = v5;
        if ((unint64_t)(v5 + 3) >= v3)
        {
          uint64_t v2 = v6;
          return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
        }
      }
      uint64_t v2 = v6 + 24;
      long long v10 = *(_OWORD *)v5;
      *((void *)v6 + 5) = v5[2];
      *(_OWORD *)(v6 + 24) = v10;
      uint64_t v4 = v5 + 3;
      v6 += 24;
    }
    while ((unint64_t)(v5 + 3) < v3);
  }
  return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
}

uint64_t convert_internal_controls(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 8);
  if (v1)
  {
    unint64_t v2 = 0;
    unint64_t v3 = *(uint64_t **)result;
    int64x2_t v4 = vdupq_n_s64(0x8000000000000000);
    do
    {
      uint64_t v5 = *v3;
      uint64_t v6 = v3[2] + *v3;
      ++v2;
      uint64_t v7 = v6;
      if (v2 < v1) {
        uint64_t v7 = v3[5];
      }
      if (v5 < 0) {
        uint64_t v5 = 0x8000000000000000 - v5;
      }
      *unint64_t v3 = v5;
      v8.i64[0] = v3[1];
      v8.i64[1] = v7 - v6;
      *(int8x16_t *)(v3 + 1) = vbslq_s8((int8x16_t)vcltzq_s64(v8), (int8x16_t)vsubq_s64(v4, v8), (int8x16_t)v8);
      v3 += 3;
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t GetLargeFileControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v14 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a1, a2, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  char v21 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a3, a4, v15, v16, v17, v18, v19, v20);
  uint64_t v24 = v21;
  if (!v14 || !v21)
  {
    uint64_t v26 = "AAMemoryInputStreamOpen";
    __int16 v27 = 758;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControls", v27, 112, 0, v26, v22, v23, v29);
    uint64_t v25 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }
  if ((GetLargeFileControlsWithStreams((uint64_t)v14, a2, (unint64_t)v21, a4, a5, a6, a7) & 0x80000000) != 0)
  {
    uint64_t v26 = "GetLargeFileControlsWithStreams";
    __int16 v27 = 761;
    goto LABEL_7;
  }
  uint64_t v25 = 0;
LABEL_8:
  AAByteStreamClose(v14);
  AAByteStreamClose(v24);
  return v25;
}

uint64_t chunk_compare_by_rating(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12));
}

uint64_t chunk_compare_by_position(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

char *convert_block_controls(unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v26 = 0;
  *a1 = 0;
  if (a3)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      uint64_t v14 = a2[3 * v11];
      if (v14 >= 0) {
        uint64_t v15 = a2[3 * v11];
      }
      else {
        uint64_t v15 = 0x8000000000000000 - v14;
      }
      while (1)
      {
        uint64_t v16 = v12 & 0xFFFFF;
        uint64_t v17 = 0x100000 - (v12 & 0xFFFFF);
        if (v17 >= v15) {
          break;
        }
        uint64_t v18 = add_control(v13, a1, &v26, 0x100000 - (v12 & 0xFFFFF), 0, *(void *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
        if (!v18)
        {
          __int16 v23 = 251;
LABEL_18:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"convert_block_controls", v23, 112, 0, "add_control", a7, a8, a3);
          goto LABEL_19;
        }
        unint64_t v13 = v18;
        v15 -= v17;
        v12 += v17;
      }
      uint64_t v19 = a2[3 * v11 + 1];
      if (v19 >= 0) {
        uint64_t v20 = a2[3 * v11 + 1];
      }
      else {
        uint64_t v20 = 0x8000000000000000 - v19;
      }
      char v21 = add_control(v13, a1, &v26, v15, v20, *(void *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
      if (!v21)
      {
        __int16 v23 = 255;
        goto LABEL_18;
      }
      unint64_t v13 = v21;
      uint64_t v22 = a2[3 * v11 + 2];
      if (v22 < 0) {
        uint64_t v22 = 0x8000000000000000 - v22;
      }
      v12 += v15 + v22;
      ++v11;
    }
    while (v11 != a3);
  }
  else
  {
LABEL_19:
    unint64_t v13 = 0;
  }
  free(a2);
  return v13;
}

uint64_t fingerprint_worker(uint64_t *a1)
{
  size_t v2 = a1[3];
  if (v2 < 0x11) {
    return 0;
  }
  if (v2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", 325, 112, 0, "aaMalloc", v4, v5, v40);
    int64x2_t v8 = 0;
    uint64_t v15 = 0;
    goto LABEL_32;
  }
  uint64_t v6 = *a1;
  uint64_t v7 = (unsigned __int8 *)malloc(v2);
  if (!v7) {
    goto LABEL_14;
  }
  int64x2_t v8 = v7;
  uint64_t v15 = pc_array_init(16);
  if (!v15)
  {
    __int16 v23 = "pc_array_init";
    __int16 v24 = 329;
    goto LABEL_31;
  }
  uint64_t v16 = a1[3];
  uint64_t v17 = *(void **)(v6 + 16);
  if (!v17[4])
  {
    uint64_t v18 = -1;
LABEL_18:
    if (v16 != v18)
    {
      __int16 v23 = "aaByteStreamPReadExpected";
      __int16 v24 = 333;
      goto LABEL_31;
    }
    goto LABEL_19;
  }
  if (v16)
  {
    uint64_t v18 = 0;
    uint64_t v19 = a1[2];
    uint64_t v20 = v8;
    uint64_t v21 = a1[3];
    while (1)
    {
      uint64_t v22 = ((uint64_t (*)(void, unsigned __int8 *, uint64_t, uint64_t))v17[4])(*v17, v20, v21, v19);
      if (v22 < 0) {
        break;
      }
      if (v22)
      {
        v20 += v22;
        v18 += v22;
        v19 += v22;
        v21 -= v22;
        if (v21) {
          continue;
        }
      }
      goto LABEL_18;
    }
    uint64_t v18 = v22;
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v25 = 0;
  unsigned int v26 = 0;
  do
    unsigned int v26 = -1640531535 * (v26 + v8[v25++]);
  while (v25 != 16);
  unint64_t v27 = a1[3];
  if (v27 < 0x11)
  {
LABEL_29:
    uint64_t v3 = 0;
    a1[1] = (uint64_t)v15;
    uint64_t v15 = 0;
    goto LABEL_33;
  }
  int v28 = 0;
  unint64_t v29 = 0;
  unint64_t v30 = 0;
  unint64_t v31 = 0;
  unsigned int v32 = *(_DWORD *)(v6 + 72) << 8;
  while (1)
  {
    if (v31 < v30 || v31 < v29 && (*(_DWORD *)(v6 + 68) & ~v26) != 0) {
      goto LABEL_28;
    }
    uint64_t v33 = *(unsigned int *)(v6 + 72);
    unint64_t v40 = v31 + a1[2];
    uint64_t v34 = __ROR8__(__ROR8__(2654435761 * *(void *)&v8[v31], 41) + 2654435761 * *(void *)&v8[v31 + 8], 41);
    unsigned int v35 = v26 >> -*(unsigned char *)(v6 + 64);
    int v41 = HIDWORD(v34) ^ v34;
    unsigned int v42 = v35;
    uint64_t v15 = pc_array_append((uint64_t)v15, &v40, v9, v10, v11, v12, v13, v14);
    if (!v15) {
      break;
    }
    unint64_t v29 = v31 + (2 * v33);
    int v36 = v28 + (v32 >> 8);
    int v37 = v32 + v31;
    unsigned int v32 = v31 + v32 - v36;
    unint64_t v30 = v31 + v33 - ((unint64_t)(v37 - v36) >> 8);
    unint64_t v27 = a1[3];
    int v28 = v31;
LABEL_28:
    unsigned int v26 = -1640531535 * (v26 + v8[v31 + 16]) - *(_DWORD *)(v6 + 76) * v8[v31];
    unint64_t v38 = v31 + 17;
    ++v31;
    if (v38 >= v27) {
      goto LABEL_29;
    }
  }
  __int16 v23 = "pc_array_append";
  __int16 v24 = 361;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", v24, 112, 0, v23, v13, v14, v40);
LABEL_32:
  uint64_t v3 = 0xFFFFFFFFLL;
LABEL_33:
  free(v8);
  pc_array_free((uint64_t)v15);
  return v3;
}

uint64_t fingerprint_consumer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8) {
    return 0;
  }
  unint64_t v9 = *(void *)(v8 - 64);
  if (!v9)
  {
LABEL_13:
    int v12 = 0;
    goto LABEL_16;
  }
  uint64_t v11 = 0;
  int v12 = 1;
  while (1)
  {
    uint64_t v13 = (_DWORD *)(v8 + 16 * v11);
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v15 = v13[3];
    int v16 = *(_DWORD *)(v14 + 4 * v15);
    if (v16 != -1)
    {
      uint64_t v17 = *(unsigned int *)(v14 + 4 * v15);
      while (1)
      {
        uint64_t v18 = *(void *)(a1 + 32) + 16 * v17;
        if (v13[2] == *(_DWORD *)(v18 + 8)) {
          break;
        }
        uint64_t v17 = *(unsigned int *)(v18 + 12);
        if (v17 == -1) {
          goto LABEL_8;
        }
      }
      if (*(void *)v18 < *(void *)v13) {
        *(void *)uint64_t v18 = *(void *)v13;
      }
      goto LABEL_9;
    }
LABEL_8:
    v13[3] = v16;
    uint64_t v19 = *(void *)(a1 + 32);
    *(_DWORD *)(v14 + 4 * v15) = *(void *)(v19 - 64);
    uint64_t v20 = pc_array_append(v19, v13, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 32) = v20;
    if (!v20) {
      break;
    }
LABEL_9:
    int v12 = ++v11 < v9;
    if (v11 == v9) {
      goto LABEL_13;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_consumer", 413, 112, 0, "pc_array_append", a7, a8, v22);
LABEL_16:
  pc_array_free(v8);
  return (v12 << 31 >> 31);
}

size_t pc_log_error(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(__str, 0x400uLL);
  uint64_t v13 = (_WORD *)(((a3 & 0x3FFF) << 10) | (a4 << 24) | a5 & 0x3FF | 0x80000000);
  if (a5 >= 1)
  {
    uint64_t v14 = strerror(a5);
    snprintf(__str, 0x400uLL, "%s: ", v14);
  }
  size_t v15 = strlen(__str);
  vsnprintf(&__str[v15], 1024 - v15, a6, &a9);
  if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
    pc_log_error_cold_1((uint64_t)__str, (int)v13);
  }
  return ParallelCompressionUpdateError(v13, (size_t)__str);
}

uint64_t pc_log_warning(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  bzero(__s, 0x400uLL);
  uint64_t v12 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
  size_t v13 = strlen(__s);
  vsnprintf(&__s[v13], 1024 - v13, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)int buf = 67109378;
    int v16 = v12;
    __int16 v17 = 2080;
    uint64_t v18 = __s;
    _os_log_impl(&dword_214A7B000, MEMORY[0x263EF8438], OS_LOG_TYPE_INFO, "[0x%08x](warning) %s", buf, 0x12u);
  }
  return ParallelCompressionUpdateWarning(v12, __s);
}

void pc_log_info(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(__s, 0x400uLL);
  size_t v12 = strlen(__s);
  vsnprintf(&__s[v12], 1024 - v12, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)int buf = 67109378;
    unsigned int v14 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
    __int16 v15 = 2080;
    int v16 = __s;
    _os_log_impl(&dword_214A7B000, MEMORY[0x263EF8438], OS_LOG_TYPE_INFO, "[0x%08x] %s", buf, 0x12u);
  }
}

void *AAChunkOutputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int DefaultNThreads = a4;
  if (!a4) {
    int DefaultNThreads = getDefaultNThreads();
  }
  uint64_t v8 = calloc(1uLL, 0x68uLL);
  unint64_t v9 = malloc(0x108uLL);
  uint64_t v10 = (uint64_t)v9;
  if (!v9 || (memset_s(v9, 0x108uLL, 0, 0x108uLL), !v8))
  {
    int v19 = *__error();
    char v22 = "malloc";
    __int16 v23 = 425;
    goto LABEL_15;
  }
  *(void *)uint64_t v10 = a1;
  *(void *)(v10 + 8) = a2;
  *(void *)(v10 + 16) = a3;
  *(void *)(v10 + 24) = DefaultNThreads;
  if (!is_mul_ok(DefaultNThreads, 0x98uLL) || (unint64_t)(152 * DefaultNThreads) >= 0x2000000001)
  {
    *__error() = 12;
    *(void *)(v10 + 32) = 0;
    goto LABEL_14;
  }
  uint64_t v11 = calloc(DefaultNThreads, 0x98uLL);
  *(void *)(v10 + 32) = v11;
  if (!v11)
  {
LABEL_14:
    int v19 = *__error();
    char v22 = "malloc";
    __int16 v23 = 433;
    goto LABEL_15;
  }
  if ((pthread_mutex_init((pthread_mutex_t *)(v10 + 176), 0) & 0x80000000) == 0)
  {
    uint64_t v12 = *(void *)(v10 + 24);
    *(_DWORD *)(v10 + 40) = 0;
    *(_DWORD *)(v10 + 44) = v12;
    size_t v13 = calloc(v12, 4uLL);
    *(void *)(v10 + 48) = v13;
    if (v13)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v10 + 56), 0))
      {
        __int16 v17 = "SharedArrayInit: pthread_mutex_init failed\n";
        __int16 v18 = 56;
      }
      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v10 + 120), 0))
        {
          if (!*(void *)(v10 + 24))
          {
LABEL_29:
            *uint64_t v8 = v10;
            v8[1] = streamClose_0;
            v8[7] = streamAbort_0;
            v8[5] = streamPWrite;
            return v8;
          }
          uint64_t v25 = 0;
          unint64_t v26 = 0;
          while (1)
          {
            uint64_t v27 = *(void *)(v10 + 32);
            *(_DWORD *)(v27 + v25 + 32) = 0;
            if (pthread_mutex_init((pthread_mutex_t *)(v27 + v25 + 40), 0)
              || pthread_cond_init((pthread_cond_t *)(v27 + v25 + 104), 0))
            {
              char v22 = "SemInit";
              __int16 v23 = 441;
              goto LABEL_22;
            }
            *(void *)(v27 + v25 + 8) = v10;
            if ((createThread((pthread_t *)(v27 + v25), (uint64_t)writerProc, v27 + v25, 0) & 0x80000000) != 0) {
              break;
            }
            ++v26;
            v25 += 152;
            if (v26 >= *(void *)(v10 + 24)) {
              goto LABEL_29;
            }
          }
          char v22 = "createThread";
          __int16 v23 = 443;
          goto LABEL_22;
        }
        __int16 v17 = "SharedArrayInit: pthread_cond_init failed\n";
        __int16 v18 = 57;
      }
    }
    else
    {
      __int16 v17 = "SharedArrayInit: malloc failed\n";
      __int16 v18 = 55;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v18, 0, v17, v14, v15, v16, v28);
    char v22 = "SharedArrayInit";
    __int16 v23 = 435;
LABEL_22:
    int v19 = 0;
    goto LABEL_15;
  }
  int v19 = *__error();
  char v22 = "pthread_mutex_init";
  __int16 v23 = 434;
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"AAChunkOutputStreamOpen", v23, 59, v19, v22, v20, v21, v28);
  free(v8);
  streamClose_0(v10);
  return 0;
}

uint64_t writerProc(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v37 = 678152731 * ((unint64_t)(a1 - *(void *)(v2 + 32)) >> 3);
  uint64_t v34 = (pthread_cond_t *)(v2 + 120);
  uint64_t v3 = (pthread_mutex_t *)(a1 + 40);
  uint64_t v4 = (pthread_cond_t *)(a1 + 104);
  uint64_t v5 = "/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h";
  uint64_t v6 = "SharedArrayPush";
  int v7 = 1;
  while (1)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 56)))
    {
      uint64_t v11 = (uint64_t)v5;
      uint64_t v12 = (uint64_t)v6;
      __int16 v13 = 117;
      uint64_t v14 = "SharedArrayPush: pthread_mutex_lock failed\n";
    }
    else
    {
      uint64_t v15 = v6;
      uint64_t v16 = v5;
      uint64_t v18 = *(unsigned int *)(v2 + 40);
      unsigned int v17 = *(_DWORD *)(v2 + 44);
      int v19 = v18;
      if (v18 < v17)
      {
        *(_DWORD *)(*(void *)(v2 + 48) + 4 * v18) = v37;
        int v19 = *(_DWORD *)(v2 + 40);
      }
      *(_DWORD *)(v2 + 40) = v19 + 1;
      if (v19 || !pthread_cond_broadcast(v34))
      {
        if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 56)))
        {
          uint64_t v5 = v16;
          uint64_t v11 = (uint64_t)v16;
          uint64_t v6 = v15;
          uint64_t v12 = (uint64_t)v15;
          __int16 v13 = 124;
          uint64_t v14 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        }
        else
        {
          BOOL v32 = v18 >= v17;
          uint64_t v5 = v16;
          uint64_t v6 = v15;
          if (!v32) {
            goto LABEL_12;
          }
          uint64_t v11 = (uint64_t)v5;
          uint64_t v12 = (uint64_t)v15;
          __int16 v13 = 125;
          uint64_t v14 = "SharedArrayPush: stack is full\n";
        }
      }
      else
      {
        uint64_t v5 = v16;
        uint64_t v11 = (uint64_t)v16;
        uint64_t v6 = v15;
        uint64_t v12 = (uint64_t)v15;
        __int16 v13 = 122;
        uint64_t v14 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      }
    }
    pc_log_warning(v11, v12, v13, 0, v14, v8, v9, v10, (char)v34);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"writerProc", 210, 59, 0, v6, v20, v21, v35);
    int v7 = 0;
LABEL_12:
    if (pthread_mutex_lock(v3)) {
      goto LABEL_17;
    }
    while (1)
    {
      int v24 = *(_DWORD *)(a1 + 32);
      if (v24 > 0) {
        break;
      }
      if (pthread_cond_wait(v4, v3)) {
        goto LABEL_17;
      }
    }
    *(_DWORD *)(a1 + 32) = v24 - 1;
    if (pthread_mutex_unlock(v3))
    {
LABEL_17:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"writerProc", 212, 59, 0, "SemAcquire", v22, v23, (char)v34);
      int v7 = 0;
    }
    uint64_t v25 = *(void *)(a1 + 16);
    if (!v25) {
      return a1;
    }
    if (!atomic_load((unsigned int *)(v25 + 48)))
    {
      __int16 v27 = 186;
      char v28 = "Invalid state";
      goto LABEL_27;
    }
    if (*(void *)(v25 + 32))
    {
      __int16 v27 = 187;
      char v28 = "Chunk still has holes";
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkWriteToStream", v27, 59, 0, v28, v22, v23, (char)v34);
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"writerProc", 214, 59, 0, "Write to stream", v29, v30, v36);
LABEL_28:
      int v31 = 0;
      int v7 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v2 + 168), (unsigned int *)&v31, 1u);
      if (!v31)
      {
        AAByteStreamCancel(*(AAByteStream *)v2);
        int v7 = 0;
      }
    }
    else
    {
      if (AAByteStreamPWrite(*(AAByteStream *)v2, *(const void **)v25, *(void *)(v25 + 16), *(void *)(a1 + 24)) != *(void *)(v25 + 16))
      {
        __int16 v27 = 189;
        char v28 = "Chunk write failed";
        goto LABEL_27;
      }
      free(*(void **)v25);
      *(void *)uint64_t v25 = 0;
      *(void *)(v25 + 8) = 0;
      *(void *)(v25 + 16) = 0;
      free(*(void **)(v25 + 40));
      *(void *)(v25 + 24) = 0;
      *(void *)(v25 + 32) = 0;
      *(void *)(v25 + 40) = 0;
      if (!v7) {
        goto LABEL_28;
      }
    }
  }
}

uint64_t streamClose_0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unint64_t v2 = *(void *)(result + 248);
    if (v2)
    {
      unint64_t v3 = 0;
      int v4 = 1;
      do
      {
        int v5 = 0;
        uint64_t v6 = *(void *)(*(void *)(v1 + 256) + 8 * v3);
        uint64_t v7 = *(void *)(v1 + 8);
        atomic_compare_exchange_strong((atomic_uint *volatile)(v6 + 48), (unsigned int *)&v5, 1u);
        if (!v5 && (streamEnqueueWriteChunkToStream(v1, v6, v7 * v3) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 336, 59, 0, "enqueue chunk write", v8, v9, v37);
          int v4 = 0;
        }
        ++v3;
        unint64_t v2 = *(void *)(v1 + 248);
      }
      while (v3 < v2);
    }
    else
    {
      int v4 = 1;
    }
    uint64_t v10 = *(void *)(v1 + 24);
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = *(uint64_t **)(v1 + 32);
      do
      {
        uint64_t v13 = *v12;
        v12 += 19;
        if (v13) {
          ++v11;
        }
        --v10;
      }
      while (v10);
      if (v11)
      {
        uint64_t v14 = 0;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 56)))
          {
            __int16 v18 = 91;
            int v19 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_22:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v18, 0, v19, v15, v16, v17, v37);
            unsigned int v23 = -1;
          }
          else
          {
            while (1)
            {
              int v20 = *(_DWORD *)(v1 + 40);
              if (v20) {
                break;
              }
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 120), (pthread_mutex_t *)(v1 + 56)))
              {
                __int16 v18 = 94;
                int v19 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_22;
              }
            }
            unsigned int v30 = v20 - 1;
            *(_DWORD *)(v1 + 40) = v30;
            unsigned int v23 = *(_DWORD *)(*(void *)(v1 + 48) + 4 * v30);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 56))) {
              goto LABEL_24;
            }
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v31, v32, v33, v37);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 346, 59, 0, "SharedArrayPop", v21, v22, v38);
          int v4 = 0;
LABEL_24:
          uint64_t v24 = *(void *)(v1 + 32);
          uint64_t v25 = v24 + 152 * v23;
          *(void *)(v25 + 16) = 0;
          *(void *)(v25 + 24) = 0;
          if (pthread_mutex_lock((pthread_mutex_t *)(v25 + 40))
            || (uint64_t v28 = v24 + 152 * v23, v29 = *(_DWORD *)(v28 + 32), *(_DWORD *)(v28 + 32) = v29 + 1, !v29)
            && pthread_cond_broadcast((pthread_cond_t *)(v24 + 152 * v23 + 104))
            || pthread_mutex_unlock((pthread_mutex_t *)(v25 + 40)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 350, 59, 0, "SemRelease", v26, v27, v37);
            int v4 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v25) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamClose", 351, 59, 0, "joinThread", v34, v35, v37);
            int v4 = 0;
          }
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v25 + 40))) {
            pthread_cond_destroy((pthread_cond_t *)(v24 + 152 * v23 + 104));
          }
          if (++v14 == v11)
          {
            unint64_t v2 = *(void *)(v1 + 248);
            break;
          }
        }
      }
    }
    if (v2)
    {
      unint64_t v36 = 0;
      do
        chunkDestroy(*(void ***)(*(void *)(v1 + 256) + 8 * v36++));
      while (v36 < *(void *)(v1 + 248));
    }
    free(*(void **)(v1 + 256));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 176));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 56)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 120))) {
      free(*(void **)(v1 + 48));
    }
    free(*(void **)(v1 + 32));
    free((void *)v1);
    if (v4) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

void streamAbort_0(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 168), (unsigned int *)&v1, 1u);
  if (!v1) {
    AAByteStreamCancel(*(AAByteStream *)a1);
  }
}

uint64_t streamPWrite(uint64_t a1, char *a2, uint64_t a3, unint64_t a4)
{
  if (atomic_load((unsigned int *)(a1 + 168))) {
    return -1;
  }
  if (!a3) {
    return 0;
  }
  unint64_t v7 = a4;
  unint64_t v9 = a4 + a3;
  if (a4 + a3 <= a4)
  {
    unint64_t v11 = -1;
    goto LABEL_84;
  }
  unint64_t v100 = (pthread_mutex_t *)(a1 + 176);
  long long v98 = (unint64_t *)(a1 + 240);
  unint64_t v95 = a4 + a3;
  unint64_t v96 = *(void *)(a1 + 8);
  unint64_t v11 = -1;
  do
  {
    unint64_t v12 = v7 / v96;
    unint64_t v13 = v7 / v96 * v96;
    if (v13 <= v7) {
      unint64_t v14 = v7;
    }
    else {
      unint64_t v14 = v7 / v96 * v96;
    }
    if (v9 >= v13 + v96) {
      unint64_t v15 = v13 + v96;
    }
    else {
      unint64_t v15 = v9;
    }
    if (pthread_mutex_lock(v100) < 0)
    {
      int v87 = *__error();
      uint64_t v90 = "pthread_mutex_lock";
      __int16 v91 = 262;
      goto LABEL_97;
    }
    size_t __n = v15 - v14;
    unint64_t v22 = *v98;
    if (*v98 <= v12)
    {
      do
      {
        if (v22) {
          v22 *= 2;
        }
        else {
          unint64_t v22 = 16;
        }
      }
      while (v22 <= v12);
      *(void *)(a1 + 240) = v22;
      if (8 * v22 >= 0x2000000001)
      {
        *__error() = 12;
LABEL_43:
        *(void *)(a1 + 256) = 0;
        uint64_t v45 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", 272, 59, *v45, "malloc", v46, v47, v93);
        char v44 = 0;
        *long long v98 = 0;
        v98[1] = 0;
        goto LABEL_67;
      }
      unsigned int v23 = a2;
      uint64_t v24 = *(void **)(a1 + 256);
      uint64_t v25 = realloc(v24, 8 * v22);
      if (!v25)
      {
        free(v24);
        a2 = v23;
        goto LABEL_43;
      }
      *(void *)(a1 + 256) = v25;
      a2 = v23;
    }
    __srCC_SHA1_CTX c = a2;
    unint64_t v26 = *(void *)(a1 + 248);
    while (1)
    {
      if (v26 > v12)
      {
        unint64_t v38 = v14 - v13;
        uint64_t v39 = *(void *)(*(void *)(a1 + 256) + 8 * v12);
        unint64_t v40 = *(void *)(v39 + 16);
        a2 = __src;
        if (v38 > v40)
        {
          if ((chunkAppendHole(*(void *)(*(void *)(a1 + 256) + 8 * v12), v38 - v40, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
          {
            __int16 v57 = 301;
            __int16 v58 = "Hole append";
LABEL_66:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", v57, 59, 0, v58, v20, v21, v93);
            char v44 = 0;
            goto LABEL_67;
          }
          unint64_t v40 = *(void *)(v39 + 16);
        }
        if (v40 == v38)
        {
          if (v15 != v14)
          {
            if (atomic_load((unsigned int *)(v39 + 48)))
            {
              __int16 v42 = 104;
              uint64_t v43 = "Chunk has already been written";
LABEL_54:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkAppendData", v42, 59, 0, v43, v20, v21, v93);
              __int16 v57 = 308;
              __int16 v58 = "Data append";
              goto LABEL_66;
            }
            uint64_t v59 = *(void *)(v39 + 16);
            if (v59 + __n > *(void *)(v39 + 8))
            {
              __int16 v42 = 105;
              uint64_t v43 = "Invalid data size";
              goto LABEL_54;
            }
            memcpy((void *)(*(void *)v39 + v59), __src, __n);
            *(void *)(v39 + 16) += __n;
          }
LABEL_41:
          char v44 = 1;
          goto LABEL_67;
        }
        if (v15 == v14) {
          goto LABEL_41;
        }
        if (atomic_load((unsigned int *)(v39 + 48)))
        {
          __int16 v49 = 152;
          uint64_t v50 = "Chunk has already been written";
        }
        else
        {
          unint64_t v60 = *(void *)(v39 + 32);
          if (v60)
          {
            uint64_t v61 = 0;
            unint64_t v62 = 0;
            uint64_t v63 = *(void *)(v39 + 40);
            size_t v64 = __n + v38;
            while (1)
            {
              unint64_t v65 = *(void *)(v63 + v61 + 8);
              if (v65 <= v38)
              {
                size_t v66 = *(void *)(v63 + v61) + v65;
                if (v64 <= v66 && (v65 == v38 || v64 == v66)) {
                  break;
                }
              }
              ++v62;
              v61 += 16;
              if (v60 == v62) {
                goto LABEL_64;
              }
            }
            if (v62 < v60)
            {
              memcpy((void *)(*(void *)v39 + v38), __src, __n);
              uint64_t v70 = *(void *)(v39 + 40);
              if (*(void *)(v70 + v61 + 8) == v38) {
                *(void *)(v70 + v61 + 8) = v64;
              }
              size_t v71 = *(void *)(v70 + v61) - __n;
              *(void *)(v70 + v61) = v71;
              if (!v71)
              {
                unint64_t v72 = *(void *)(v39 + 32) - 1;
                *(void *)(v39 + 32) = v72;
                if (v62 < v72)
                {
                  do
                  {
                    ++v62;
                    *(_OWORD *)(*(void *)(v39 + 40) + v61) = *(_OWORD *)(*(void *)(v39 + 40) + v61 + 16);
                    v61 += 16;
                    char v44 = 1;
                  }
                  while (v62 < *(void *)(v39 + 32));
                  goto LABEL_67;
                }
              }
              goto LABEL_41;
            }
          }
LABEL_64:
          __int16 v49 = 163;
          uint64_t v50 = "Invalid data write, no matching hole";
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkWriteData", v49, 59, 0, v50, v20, v21, v93);
        __int16 v57 = 313;
        __int16 v58 = "Hole fill";
        goto LABEL_66;
      }
      size_t v27 = *(void *)(a1 + 8);
      if (v26)
      {
        uint64_t v28 = *(void *)(*(void *)(a1 + 256) + 8 * v26 - 8);
        unint64_t v29 = *(void *)(v28 + 16);
        if (v27 > v29)
        {
          if ((chunkAppendHole(v28, v27 - v29, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
          {
            __int16 v55 = 284;
            uint64_t v56 = "Hole creation";
            goto LABEL_50;
          }
          size_t v27 = *(void *)(a1 + 8);
        }
      }
      uint64_t v32 = (void **)malloc(0x38uLL);
      uint64_t v33 = v32;
      if (!v32)
      {
        __int16 v51 = 89;
        goto LABEL_49;
      }
      memset_s(v32, 0x38uLL, 0, 0x38uLL);
      if (v27 >= 0x2000000001) {
        break;
      }
      uint64_t v34 = malloc(v27);
      if (!v34) {
        goto LABEL_48;
      }
      uint64_t v35 = v34;
      memset_s(v34, v27, 0, v27);
      char *v33 = v35;
      v33[1] = (void *)v27;
      v33[2] = 0;
      uint64_t v37 = *(void *)(a1 + 248);
      uint64_t v36 = *(void *)(a1 + 256);
      unint64_t v26 = v37 + 1;
      *(void *)(a1 + 248) = v37 + 1;
      *(void *)(v36 + 8 * v37) = v33;
    }
    *__error() = 12;
LABEL_48:
    char *v33 = 0;
    __int16 v51 = 91;
LABEL_49:
    int v52 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkCreate", v51, 59, *v52, "malloc", v53, v54, v93);
    chunkDestroy(v33);
    __int16 v55 = 289;
    uint64_t v56 = "Chunk creation";
LABEL_50:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", v55, 59, 0, v56, v30, v31, v93);
    char v44 = 0;
    a2 = __src;
LABEL_67:
    if (pthread_mutex_unlock(v100) < 0)
    {
      int v87 = *__error();
      uint64_t v90 = "pthread_mutex_unlock";
      __int16 v91 = 316;
LABEL_97:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamWriteChunkData", v91, 59, v87, v90, v88, v89, v93);
LABEL_98:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamPWrite", 393, 59, 0, "Writing chunk data failed", v68, v69, v93);
      int v92 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 168), (unsigned int *)&v92, 1u);
      if (!v92) {
        AAByteStreamCancel(*(AAByteStream *)a1);
      }
      return -1;
    }
    if ((v44 & 1) == 0) {
      goto LABEL_98;
    }
    if (v12 < v11) {
      unint64_t v11 = v7 / v96;
    }
    v7 += __n;
    a2 += __n;
    unint64_t v9 = v95;
  }
  while (v7 < v95);
LABEL_84:
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 176)) < 0)
  {
    int v80 = *__error();
    uint64_t v83 = "pthread_mutex_lock";
    __int16 v84 = 239;
LABEL_93:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamCheckAndWriteChunksToStream", v84, 59, v80, v83, v81, v82, v93);
LABEL_94:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamPWrite", 404, 59, 0, "flushing chunks to stream", v85, v86, v93);
    return -1;
  }
  if (v11 + 1 < *(void *)(a1 + 248))
  {
    while (1)
    {
      uint64_t v73 = *(void *)(*(void *)(a1 + 256) + 8 * v11);
      if (!*(void *)(v73 + 40))
      {
        int v74 = 0;
        uint64_t v75 = *(void *)(a1 + 8);
        atomic_compare_exchange_strong((atomic_uint *volatile)(v73 + 48), (unsigned int *)&v74, 1u);
        if (!v74 && (streamEnqueueWriteChunkToStream(a1, v73, v75 * v11) & 0x80000000) != 0) {
          break;
        }
      }
      unint64_t v78 = v11 + 2;
      ++v11;
      if (v78 >= *(void *)(a1 + 248)) {
        goto LABEL_90;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamCheckAndWriteChunksToStream", 249, 59, 0, "enqueue chunk write", v76, v77, v93);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176)) < 0)
    {
LABEL_91:
      int v80 = *__error();
      uint64_t v83 = "pthread_mutex_unlock";
      __int16 v84 = 254;
      goto LABEL_93;
    }
    goto LABEL_94;
  }
LABEL_90:
  int v79 = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176));
  uint64_t v5 = a3;
  if (v79 < 0) {
    goto LABEL_91;
  }
  return v5;
}

uint64_t streamEnqueueWriteChunkToStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    uint64_t v10 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v11 = 91;
LABEL_8:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v11, 0, v10, v7, v8, v9, v25);
    uint64_t v17 = "SharedArrayPop";
    __int16 v18 = 226;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"streamEnqueueWriteChunkToStream", v18, 59, 0, v17, v15, v16, v25);
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    int v12 = *(_DWORD *)(a1 + 40);
    if (v12) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v6))
    {
      uint64_t v10 = "SharedArrayPop: pthread_cond_wait failed\n";
      __int16 v11 = 94;
      goto LABEL_8;
    }
  }
  unsigned int v13 = v12 - 1;
  *(_DWORD *)(a1 + 40) = v13;
  unsigned int v14 = *(_DWORD *)(*(void *)(a1 + 48) + 4 * v13);
  if (pthread_mutex_unlock(v6))
  {
    uint64_t v10 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    __int16 v11 = 98;
    goto LABEL_8;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  uint64_t v21 = v20 + 152 * v14;
  *(void *)(v21 + 16) = a2;
  *(void *)(v21 + 24) = a3;
  unint64_t v22 = (pthread_mutex_t *)(v21 + 40);
  if (pthread_mutex_lock((pthread_mutex_t *)(v21 + 40))
    || (v23 = v20 + 152 * v14, int v24 = *(_DWORD *)(v23 + 32), *(_DWORD *)(v23 + 32) = v24 + 1, !v24)
    && pthread_cond_broadcast((pthread_cond_t *)(v20 + 152 * v14 + 104))
    || (uint64_t result = pthread_mutex_unlock(v22), result))
  {
    uint64_t v17 = "SemRelease";
    __int16 v18 = 230;
    goto LABEL_9;
  }
  return result;
}

void chunkDestroy(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1[5]);
    free(a1);
  }
}

uint64_t chunkAppendHole(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  if (atomic_load((unsigned int *)(a1 + 48)))
  {
    uint64_t v10 = "Chunk has already been written";
    __int16 v11 = 115;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkAppendHole", v11, 59, 0, v10, a7, a8, v33);
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = v14 + a2;
  if ((unint64_t)(v14 + a2) > *(void *)(a1 + 8))
  {
    uint64_t v10 = "Invalid hole size";
    __int16 v11 = 116;
    goto LABEL_7;
  }
  unint64_t v16 = *(void *)(a1 + 32);
  if (!v16
    || (uint64_t v17 = *(void *)(a1 + 40) + 16 * v16,
        uint64_t v19 = *(void *)(v17 - 16),
        uint64_t v20 = *(void *)(v17 - 8),
        __int16 v18 = (void *)(v17 - 16),
        v19 + v20 != v14))
  {
    unint64_t v22 = (void *)(a1 + 24);
    unint64_t v21 = *(void *)(a1 + 24);
    if (v16 < v21)
    {
      uint64_t v23 = *(char **)(a1 + 40);
LABEL_20:
      uint64_t result = 0;
      *(void *)(a1 + 32) = v16 + 1;
      unint64_t v29 = &v23[16 * v16];
      *(void *)unint64_t v29 = a2;
      *((void *)v29 + 1) = v14;
      goto LABEL_21;
    }
    uint64_t v24 = 2 * v21;
    BOOL v25 = v21 == 0;
    uint64_t v26 = 8;
    if (!v25) {
      uint64_t v26 = v24;
    }
    *(void *)(a1 + 24) = v26;
    if ((unint64_t)(16 * v26) < 0x2000000001)
    {
      size_t v27 = *(void **)(a1 + 40);
      uint64_t v28 = (char *)realloc(v27, 16 * v26);
      if (v28)
      {
        uint64_t v23 = v28;
        *(void *)(a1 + 40) = v28;
        unint64_t v16 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(a1 + 16);
        uint64_t v15 = v14 + a2;
        goto LABEL_20;
      }
      free(v27);
    }
    else
    {
      *__error() = 12;
    }
    *(void *)(a1 + 40) = 0;
    uint64_t v30 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAChunkOutputStream.c", (uint64_t)"chunkAppendHole", 135, 59, *v30, "malloc", v31, v32, v33);
    *unint64_t v22 = 0;
    *(void *)(a1 + 32) = 0;
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *__int16 v18 = v19 + a2;
LABEL_21:
  *(void *)(a1 + 16) = v15;
  return result;
}

uint64_t loadAndDecodeHeader_Cpio(uint64_t *a1, unint64_t *a2)
{
  int v4 = (int *)a1[8];
  int v5 = *v4;
  int v6 = *((unsigned __int16 *)v4 + 2);
  BOOL v8 = v5 != 925906736 || v6 != 12592;
  value.tv_seCC_SHA1_CTX c = 0;
  value.tv_nseCC_SHA1_CTX c = 0;
  uint64_t v9 = *a1;
  if (AAHeaderClear((AAHeader)a1[11]) < 0)
  {
    unint64_t v29 = "clear header";
    __int16 v30 = 67;
LABEL_116:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AADecodeArchiveInputStreamCPIO.c", (uint64_t)"loadAndDecodeHeader_Cpio", v30, 113, 0, v29, v14, v15, v193);
    return 0xFFFFFFFFLL;
  }
  if (v8) {
    unint64_t v16 = 76;
  }
  else {
    unint64_t v16 = 110;
  }
  if ((decodeStreamLoadHeader(a1, v16, v10, v11, v12, v13, v14, v15) & 0x80000000) != 0)
  {
    unint64_t v29 = "truncated stream";
    __int16 v30 = 73;
    goto LABEL_116;
  }
  uint64_t v17 = a1[8];
  if (v8)
  {
    unint64_t v18 = 0;
    unint64_t v19 = v17 + 65;
    unint64_t v20 = v17 + 63;
    uint64_t v21 = 4;
    uint64_t v22 = v17 + 59;
    do
    {
      uint64_t v23 = 0;
      unint64_t v24 = 0;
      unint64_t v25 = v20;
      uint64_t v26 = v21;
      do
      {
        unint64_t v27 = *(unsigned char *)(v22 + v23++) & 7 | (8 * v24);
        unint64_t v24 = v27;
      }
      while (v23 != 4);
      unint64_t v18 = v27 + (v18 << 12);
      unint64_t v20 = v25 + 4;
      v21 += 4;
      v22 += 4;
    }
    while (v25 + 4 <= v19);
    if (v25 >= v19)
    {
      size_t v28 = v18;
    }
    else
    {
      do
      {
        size_t v28 = *(unsigned char *)(v17 + 59 + v26++) & 7 | (8 * v18);
        unint64_t v18 = v28;
      }
      while (v26 != 6);
    }
  }
  else
  {
    uint64_t v31 = 0;
    size_t v28 = 0;
    do
    {
      int v32 = *(char *)(v17 + 94 + v31);
      v28 *= 16;
      char v33 = v32 - 48;
      if ((v32 - 48) <= 0x36)
      {
        if (((1 << v33) & 0x3FF) != 0)
        {
          size_t v28 = v28 + *(char *)(v17 + 94 + v31) - 48;
        }
        else if (((1 << v33) & 0x7E0000) != 0)
        {
          size_t v28 = v28 + *(char *)(v17 + 94 + v31) - 55;
        }
        else if (((1 << v33) & 0x7E000000000000) != 0)
        {
          size_t v28 = v28 + *(char *)(v17 + 94 + v31) - 87;
        }
      }
      ++v31;
    }
    while (v31 != 8);
  }
  unint64_t v34 = 0;
  if (v8)
  {
    uint64_t v35 = v17 + 65;
    unint64_t v36 = v17 + 76;
    uint64_t v37 = (char *)(v17 + 73);
    do
    {
      uint64_t v38 = 0;
      unint64_t v39 = 0;
      unint64_t v40 = v37;
      do
      {
        unint64_t v41 = *(unsigned char *)(v35 + v38++) & 7 | (8 * v39);
        unint64_t v39 = v41;
      }
      while (v38 != 8);
      unint64_t v34 = v41 + (v34 << 24);
      uint64_t v37 = v40 + 8;
      v35 += 8;
    }
    while ((unint64_t)(v40 + 8) <= v36);
    __int16 v42 = v40 + 4;
    if ((unint64_t)(v40 + 4) <= v36)
    {
      do
      {
        uint64_t v44 = 0;
        unint64_t v45 = 0;
        do
        {
          unint64_t v46 = v40[v44++] & 7 | (8 * v45);
          unint64_t v45 = v46;
        }
        while (v44 != 4);
        unint64_t v34 = v46 + (v34 << 12);
        uint64_t v43 = v42;
        v40 += 4;
        v42 += 4;
      }
      while ((unint64_t)v42 <= v36);
    }
    else
    {
      uint64_t v43 = v40;
    }
    if ((unint64_t)v43 >= v36)
    {
      uint64_t v49 = v34;
    }
    else
    {
      uint64_t v47 = v17 - (void)v43 + 76;
      do
      {
        char v48 = *v43++;
        uint64_t v49 = v48 & 7 | (8 * v34);
        unint64_t v34 = v49;
        --v47;
      }
      while (v47);
    }
  }
  else
  {
    uint64_t v49 = 0;
    do
    {
      int v50 = *(char *)(v17 + 54 + v34);
      v49 *= 16;
      char v51 = v50 - 48;
      if ((v50 - 48) <= 0x36)
      {
        if (((1 << v51) & 0x3FF) != 0)
        {
          uint64_t v49 = v49 + *(char *)(v17 + 54 + v34) - 48;
        }
        else if (((1 << v51) & 0x7E0000) != 0)
        {
          uint64_t v49 = v49 + *(char *)(v17 + 54 + v34) - 55;
        }
        else if (((1 << v51) & 0x7E000000000000) != 0)
        {
          uint64_t v49 = v49 + *(char *)(v17 + 54 + v34) - 87;
        }
      }
      ++v34;
    }
    while (v34 != 8);
  }
  unint64_t v52 = 0;
  if (v8)
  {
    unint64_t v53 = v17 + 24;
    unint64_t v54 = v17 + 22;
    uint64_t v55 = v17 + 18;
    uint64_t v56 = 4;
    uint64_t v57 = v55;
    do
    {
      uint64_t v58 = 0;
      unint64_t v59 = 0;
      unint64_t v60 = v54;
      uint64_t v61 = v56;
      do
      {
        unint64_t v62 = *(unsigned char *)(v57 + v58++) & 7 | (8 * v59);
        unint64_t v59 = v62;
      }
      while (v58 != 4);
      unint64_t v52 = v62 + (v52 << 12);
      unint64_t v54 = v60 + 4;
      v56 += 4;
      v57 += 4;
    }
    while (v60 + 4 <= v53);
    if (v60 >= v53)
    {
      LOWORD(v63) = v52;
    }
    else
    {
      do
      {
        unint64_t v63 = *(unsigned char *)(v55 + v61++) & 7 | (8 * v52);
        unint64_t v52 = v63;
      }
      while (v61 != 6);
    }
  }
  else
  {
    unint64_t v63 = 0;
    uint64_t v64 = v17 + 14;
    do
    {
      int v65 = *(char *)(v64 + v52);
      v63 *= 16;
      char v66 = v65 - 48;
      if ((v65 - 48) <= 0x36)
      {
        if (((1 << v66) & 0x3FF) != 0)
        {
          unint64_t v63 = v63 + *(char *)(v64 + v52) - 48;
        }
        else if (((1 << v66) & 0x7E0000) != 0)
        {
          unint64_t v63 = v63 + *(char *)(v64 + v52) - 55;
        }
        else if (((1 << v66) & 0x7E000000000000) != 0)
        {
          unint64_t v63 = v63 + *(char *)(v64 + v52) - 87;
        }
      }
      ++v52;
    }
    while (v52 != 8);
  }
  unsigned int v67 = aaEntryTypeFromMode(v63);
  if (v28 >= 0x10000)
  {
    unint64_t v29 = "invalid c_namesize";
    __int16 v30 = 82;
    goto LABEL_116;
  }
  unsigned int v72 = v67;
  if (v8) {
    unint64_t v73 = v28 + v16;
  }
  else {
    unint64_t v73 = (v28 + v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  }
  unint64_t v74 = v73;
  if (v67 == 76)
  {
    if (v49 >= 0x10000)
    {
      unint64_t v29 = "invalid c_filesize";
      __int16 v30 = 89;
      goto LABEL_116;
    }
    if (v8) {
      unint64_t v74 = v49 + v73;
    }
    else {
      unint64_t v74 = (v49 + v73 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
  }
  if ((decodeStreamLoadHeader(a1, v74, v68, v69, v70, v71, v14, v15) & 0x80000000) != 0)
  {
    unint64_t v29 = "truncated stream";
    __int16 v30 = 95;
    goto LABEL_116;
  }
  if (v72) {
    BOOL v75 = 0;
  }
  else {
    BOOL v75 = v49 == 0;
  }
  if (v75 && v28 == 11)
  {
    int v92 = (uint64_t *)(a1[8] + v16);
    uint64_t v93 = *v92;
    uint64_t v94 = *(uint64_t *)((char *)v92 + 3);
    if (v93 == 0x2152454C49415254 && v94 == 0x21212152454C49) {
      return 1;
    }
LABEL_115:
    unint64_t v29 = "invalid cpio header";
    __int16 v30 = 101;
    goto LABEL_116;
  }
  if (!v72) {
    goto LABEL_115;
  }
  uint64_t v193 = a1[8];
  v77.uint64_t ikey = 5265748;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v77, v72) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 106;
    goto LABEL_116;
  }
  v78.uint64_t ikey = 5521744;
  if (AAHeaderSetFieldString((AAHeader)a1[11], 0xFFFFFFFF, v78, (const char *)(a1[8] + v16), v28) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 109;
    goto LABEL_116;
  }
  if (v72 == 76)
  {
    v79.uint64_t ikey = 4935244;
    if (AAHeaderSetFieldString((AAHeader)a1[11], 0xFFFFFFFF, v79, (const char *)(a1[8] + v73), v49) < 0)
    {
      unint64_t v29 = "creating header";
      __int16 v30 = 114;
      goto LABEL_116;
    }
  }
  v80.uint64_t ikey = 4476749;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v80, v63 & 0xFFF) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 118;
    goto LABEL_116;
  }
  if (v8)
  {
    unint64_t v81 = 0;
    unint64_t v82 = v193 + 30;
    unint64_t v83 = v193 + 28;
    uint64_t v84 = 4;
    uint64_t v85 = v193 + 24;
    do
    {
      uint64_t v86 = 0;
      unint64_t v87 = 0;
      unint64_t v88 = v83;
      uint64_t v89 = v84;
      do
      {
        unint64_t v90 = *(unsigned char *)(v85 + v86++) & 7 | (8 * v87);
        unint64_t v87 = v90;
      }
      while (v86 != 4);
      unint64_t v81 = v90 + (v81 << 12);
      unint64_t v83 = v88 + 4;
      v84 += 4;
      v85 += 4;
    }
    while (v88 + 4 <= v82);
    if (v88 >= v82)
    {
      uint64_t v91 = v81;
    }
    else
    {
      do
      {
        uint64_t v91 = *(unsigned char *)(v193 + 24 + v89++) & 7 | (8 * v81);
        unint64_t v81 = v91;
      }
      while (v89 != 6);
    }
  }
  else
  {
    uint64_t v97 = 0;
    uint64_t v91 = 0;
    do
    {
      int v98 = *(char *)(v193 + 22 + v97);
      v91 *= 16;
      char v99 = v98 - 48;
      if ((v98 - 48) <= 0x36)
      {
        if (((1 << v99) & 0x3FF) != 0)
        {
          uint64_t v91 = v91 + *(char *)(v193 + 22 + v97) - 48;
        }
        else if (((1 << v99) & 0x7E0000) != 0)
        {
          uint64_t v91 = v91 + *(char *)(v193 + 22 + v97) - 55;
        }
        else if (((1 << v99) & 0x7E000000000000) != 0)
        {
          uint64_t v91 = v91 + *(char *)(v193 + 22 + v97) - 87;
        }
      }
      ++v97;
    }
    while (v97 != 8);
  }
  v100.uint64_t ikey = 4475221;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v100, v91) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 122;
    goto LABEL_116;
  }
  if (v8)
  {
    unint64_t v101 = 0;
    unint64_t v102 = v193 + 36;
    unint64_t v103 = v193 + 34;
    uint64_t v104 = 4;
    uint64_t v105 = v193 + 30;
    do
    {
      uint64_t v106 = 0;
      unint64_t v107 = 0;
      unint64_t v108 = v103;
      uint64_t v109 = v104;
      do
      {
        unint64_t v110 = *(unsigned char *)(v105 + v106++) & 7 | (8 * v107);
        unint64_t v107 = v110;
      }
      while (v106 != 4);
      unint64_t v101 = v110 + (v101 << 12);
      unint64_t v103 = v108 + 4;
      v104 += 4;
      v105 += 4;
    }
    while (v108 + 4 <= v102);
    if (v108 >= v102)
    {
      uint64_t v111 = v101;
    }
    else
    {
      do
      {
        uint64_t v111 = *(unsigned char *)(v193 + 30 + v109++) & 7 | (8 * v101);
        unint64_t v101 = v111;
      }
      while (v109 != 6);
    }
  }
  else
  {
    uint64_t v112 = 0;
    uint64_t v111 = 0;
    do
    {
      int v113 = *(char *)(v193 + 30 + v112);
      v111 *= 16;
      char v114 = v113 - 48;
      if ((v113 - 48) <= 0x36)
      {
        if (((1 << v114) & 0x3FF) != 0)
        {
          uint64_t v111 = v111 + *(char *)(v193 + 30 + v112) - 48;
        }
        else if (((1 << v114) & 0x7E0000) != 0)
        {
          uint64_t v111 = v111 + *(char *)(v193 + 30 + v112) - 55;
        }
        else if (((1 << v114) & 0x7E000000000000) != 0)
        {
          uint64_t v111 = v111 + *(char *)(v193 + 30 + v112) - 87;
        }
      }
      ++v112;
    }
    while (v112 != 8);
  }
  v115.uint64_t ikey = 4475207;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v115, v111) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 126;
    goto LABEL_116;
  }
  unint64_t v116 = 0;
  if (v8)
  {
    uint64_t v117 = v193 + 48;
    unint64_t v118 = v193 + 59;
    long long v119 = (char *)(v193 + 56);
    do
    {
      uint64_t v120 = 0;
      unint64_t v121 = 0;
      long long v122 = v119;
      do
      {
        unint64_t v123 = *(unsigned char *)(v117 + v120++) & 7 | (8 * v121);
        unint64_t v121 = v123;
      }
      while (v120 != 8);
      unint64_t v116 = v123 + (v116 << 24);
      long long v119 = v122 + 8;
      v117 += 8;
    }
    while ((unint64_t)(v122 + 8) <= v118);
    int v124 = v122 + 4;
    if ((unint64_t)(v122 + 4) <= v118)
    {
      do
      {
        uint64_t v126 = 0;
        unint64_t v127 = 0;
        do
        {
          unint64_t v128 = v122[v126++] & 7 | (8 * v127);
          unint64_t v127 = v128;
        }
        while (v126 != 4);
        unint64_t v116 = v128 + (v116 << 12);
        long long v125 = v124;
        v122 += 4;
        v124 += 4;
      }
      while ((unint64_t)v124 <= v118);
    }
    else
    {
      long long v125 = v122;
    }
    if ((unint64_t)v125 >= v118)
    {
      __darwin_time_t v131 = v116;
    }
    else
    {
      uint64_t v129 = v193 - (void)v125 + 59;
      do
      {
        char v130 = *v125++;
        __darwin_time_t v131 = v130 & 7 | (8 * v116);
        unint64_t v116 = v131;
        --v129;
      }
      while (v129);
    }
  }
  else
  {
    __darwin_time_t v131 = 0;
    do
    {
      int v132 = *(char *)(v193 + 46 + v116);
      v131 *= 16;
      char v133 = v132 - 48;
      if ((v132 - 48) <= 0x36)
      {
        if (((1 << v133) & 0x3FF) != 0)
        {
          __darwin_time_t v131 = v131 + *(char *)(v193 + 46 + v116) - 48;
        }
        else if (((1 << v133) & 0x7E0000) != 0)
        {
          __darwin_time_t v131 = v131 + *(char *)(v193 + 46 + v116) - 55;
        }
        else if (((1 << v133) & 0x7E000000000000) != 0)
        {
          __darwin_time_t v131 = v131 + *(char *)(v193 + 46 + v116) - 87;
        }
      }
      ++v116;
    }
    while (v116 != 8);
  }
  value.tv_seCC_SHA1_CTX c = v131;
  value.tv_nseCC_SHA1_CTX c = 0;
  v134.uint64_t ikey = 5067853;
  if (AAHeaderSetFieldTimespec((AAHeader)a1[11], 0xFFFFFFFF, v134, &value) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 131;
    goto LABEL_116;
  }
  if (v8)
  {
    unint64_t v135 = 0;
    uint64_t v136 = v193;
    unint64_t v137 = v193 + 18;
    unint64_t v138 = v193 + 16;
    uint64_t v139 = 4;
    uint64_t v140 = v193 + 12;
    do
    {
      uint64_t v141 = 0;
      unint64_t v142 = 0;
      unint64_t v143 = v138;
      uint64_t v144 = v139;
      do
      {
        unint64_t v145 = *(unsigned char *)(v140 + v141++) & 7 | (8 * v142);
        unint64_t v142 = v145;
      }
      while (v141 != 4);
      unint64_t v135 = v145 + (v135 << 12);
      unint64_t v138 = v143 + 4;
      v139 += 4;
      v140 += 4;
    }
    while (v143 + 4 <= v137);
    if (v143 >= v137)
    {
      uint64_t v146 = v135;
    }
    else
    {
      do
      {
        uint64_t v146 = *(unsigned char *)(v193 + 12 + v144++) & 7 | (8 * v135);
        unint64_t v135 = v146;
      }
      while (v144 != 6);
    }
  }
  else
  {
    uint64_t v147 = 0;
    uint64_t v146 = 0;
    uint64_t v136 = v193;
    do
    {
      int v148 = *(char *)(v193 + 6 + v147);
      v146 *= 16;
      char v149 = v148 - 48;
      if ((v148 - 48) <= 0x36)
      {
        if (((1 << v149) & 0x3FF) != 0)
        {
          uint64_t v146 = v146 + *(char *)(v193 + 6 + v147) - 48;
        }
        else if (((1 << v149) & 0x7E0000) != 0)
        {
          uint64_t v146 = v146 + *(char *)(v193 + 6 + v147) - 55;
        }
        else if (((1 << v149) & 0x7E000000000000) != 0)
        {
          uint64_t v146 = v146 + *(char *)(v193 + 6 + v147) - 87;
        }
      }
      ++v147;
    }
    while (v147 != 8);
  }
  if (v8)
  {
    unint64_t v150 = 0;
    unint64_t v151 = v136 + 12;
    unint64_t v152 = v136 + 10;
    uint64_t v153 = 4;
    uint64_t v154 = v136 + 6;
    do
    {
      uint64_t v155 = 0;
      unint64_t v156 = 0;
      unint64_t v157 = v152;
      uint64_t v158 = v153;
      do
      {
        unint64_t v159 = *(unsigned char *)(v154 + v155++) & 7 | (8 * v156);
        unint64_t v156 = v159;
      }
      while (v155 != 4);
      unint64_t v150 = v159 + (v150 << 12);
      unint64_t v152 = v157 + 4;
      v153 += 4;
      v154 += 4;
    }
    while (v157 + 4 <= v151);
    if (v157 >= v151)
    {
      unint64_t v160 = v150;
    }
    else
    {
      do
      {
        unint64_t v160 = *(unsigned char *)(v136 + 6 + v158++) & 7 | (8 * v150);
        unint64_t v150 = v160;
      }
      while (v158 != 6);
    }
    v146 |= v160 << 18;
    v166.uint64_t ikey = 5197385;
    if ((AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v166, v146) & 0x80000000) == 0)
    {
      uint64_t v163 = 0;
      unint64_t v167 = v193 + 42;
      unint64_t v168 = v193 + 40;
      uint64_t v169 = 4;
      uint64_t v170 = v193 + 36;
      do
      {
        uint64_t v171 = 0;
        unint64_t v172 = 0;
        unint64_t v173 = v168;
        uint64_t v174 = v169;
        do
        {
          unint64_t v175 = *(unsigned char *)(v170 + v171++) & 7 | (8 * v172);
          unint64_t v172 = v175;
        }
        while (v171 != 4);
        uint64_t v163 = v175 + (v163 << 12);
        unint64_t v168 = v173 + 4;
        v169 += 4;
        v170 += 4;
      }
      while (v173 + 4 <= v167);
      if (v173 < v167)
      {
        do
          uint64_t v163 = *(unsigned char *)(v193 + 36 + v174++) & 7 | (8 * v163);
        while (v174 != 6);
      }
      goto LABEL_229;
    }
LABEL_239:
    unint64_t v29 = "creating header";
    __int16 v30 = 145;
    goto LABEL_116;
  }
  v161.uint64_t ikey = 5197385;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v161, v146) < 0) {
    goto LABEL_239;
  }
  uint64_t v162 = 0;
  uint64_t v163 = 0;
  do
  {
    int v164 = *(char *)(v193 + 38 + v162);
    v163 *= 16;
    char v165 = v164 - 48;
    if ((v164 - 48) <= 0x36)
    {
      if (((1 << v165) & 0x3FF) != 0)
      {
        uint64_t v163 = v163 + *(char *)(v193 + 38 + v162) - 48;
      }
      else if (((1 << v165) & 0x7E0000) != 0)
      {
        uint64_t v163 = v163 + *(char *)(v193 + 38 + v162) - 55;
      }
      else if (((1 << v165) & 0x7E000000000000) != 0)
      {
        uint64_t v163 = v163 + *(char *)(v193 + 38 + v162) - 87;
      }
    }
    ++v162;
  }
  while (v162 != 8);
LABEL_229:
  v176.uint64_t ikey = 4934734;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v176, v163) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 149;
    goto LABEL_116;
  }
  if ((v9 & 0x8000000000000) != 0 || v163 < 2 || v72 != 70)
  {
    BOOL v181 = 0;
    if (v8 || (v72 & 0xFFFFFFFE) != 0x42) {
      goto LABEL_263;
    }
    uint64_t v182 = 0;
    uint64_t v183 = 0;
    do
    {
      int v184 = *(char *)(v193 + 78 + v182);
      v183 *= 16;
      char v185 = v184 - 48;
      if ((v184 - 48) <= 0x36)
      {
        if (((1 << v185) & 0x3FF) != 0)
        {
          uint64_t v183 = v183 + *(char *)(v193 + 78 + v182) - 48;
        }
        else if (((1 << v185) & 0x7E0000) != 0)
        {
          uint64_t v183 = v183 + *(char *)(v193 + 78 + v182) - 55;
        }
        else if (((1 << v185) & 0x7E000000000000) != 0)
        {
          uint64_t v183 = v183 + *(char *)(v193 + 78 + v182) - 87;
        }
      }
      ++v182;
    }
    while (v182 != 8);
    uint64_t v186 = 0;
    uint64_t v187 = 0;
    do
    {
      int v188 = *(char *)(v193 + 86 + v186);
      v187 *= 16;
      char v189 = v188 - 48;
      if ((v188 - 48) <= 0x36)
      {
        if (((1 << v189) & 0x3FF) != 0)
        {
          uint64_t v187 = v187 + *(char *)(v193 + 86 + v186) - 48;
        }
        else if (((1 << v189) & 0x7E0000) != 0)
        {
          uint64_t v187 = v187 + *(char *)(v193 + 86 + v186) - 55;
        }
        else if (((1 << v189) & 0x7E000000000000) != 0)
        {
          uint64_t v187 = v187 + *(char *)(v193 + 86 + v186) - 87;
        }
      }
      ++v186;
    }
    while (v186 != 8);
    v190.uint64_t ikey = 5653828;
    if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v190, v187 + (v183 << 24)) < 0)
    {
      unint64_t v29 = "creating header";
      __int16 v30 = 173;
      goto LABEL_116;
    }
LABEL_262:
    BOOL v181 = 0;
    goto LABEL_263;
  }
  int v194 = 0;
  uint64_t v179 = decodeStreamHLCFromINO(a1, v146, v163, &v194, v177, v178, v14, v15);
  if (v179 == -1)
  {
    unint64_t v29 = "too many hard links or inconsistent nlink/ino data in archive";
    __int16 v30 = 156;
    goto LABEL_116;
  }
  v180.uint64_t ikey = 4410440;
  if (AAHeaderSetFieldUInt((AAHeader)a1[11], 0xFFFFFFFF, v180, v179) < 0)
  {
    unint64_t v29 = "creating header";
    __int16 v30 = 157;
    goto LABEL_116;
  }
  if (v8) {
    goto LABEL_262;
  }
  if (!v194 && v49)
  {
    unint64_t v29 = "invalid newc encoding for hard links";
    __int16 v30 = 162;
    goto LABEL_116;
  }
  BOOL v181 = v194 == 0;
LABEL_263:
  if (v72 != 70 || v181)
  {
    if (v72 != 70)
    {
      uint64_t result = 0;
      *a2 = 0;
      return result;
    }
  }
  else
  {
    v191.uint64_t ikey = 5521732;
    if (AAHeaderSetFieldBlob((AAHeader)a1[11], 0xFFFFFFFF, v191, v49) < 0)
    {
      unint64_t v29 = "creating header";
      __int16 v30 = 179;
      goto LABEL_116;
    }
  }
  uint64_t result = 0;
  unint64_t v192 = (v49 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (v8) {
    unint64_t v192 = v49;
  }
  *a2 = v192;
  return result;
}

uint64_t getBXDiffControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int8x16_t **a5, uint64_t a6, int *a7, uint64_t a8)
{
  uint64_t v8 = 0xFFFFFFFFLL;
  if (!a2 || !a4) {
    return v8;
  }
  uint64_t v10 = (void *)a6;
  if (a2 >= a4) {
    unint64_t v13 = a4;
  }
  else {
    unint64_t v13 = a2;
  }
  if (v13 >= 0x10000)
  {
    unint64_t v14 = a2 - a4;
    if (a2 < a4) {
      unint64_t v14 = a4 - a2;
    }
    uint64_t v15 = (unsigned __int8 *)a1;
    unint64_t v16 = (unsigned __int8 *)a3;
    do
    {
      int v18 = *v15++;
      int v17 = v18;
      int v19 = *v16++;
      if (v17 != v19) {
        ++v14;
      }
      --v13;
    }
    while (v13);
    if (v14 <= a4 / 0x64)
    {
      unint64_t v96 = (int8x16_t *)calloc(1uLL, 0x18uLL);
      if (v96)
      {
        *a5 = v96;
        *uint64_t v10 = 1;
        if (a2 <= a4)
        {
          uint64_t v8 = 0;
          v101.i64[0] = a2;
          v101.i64[1] = a4 - a2;
          *unint64_t v96 = vbslq_s8((int8x16_t)vcltzq_s64(v101), (int8x16_t)vsubq_s64(vdupq_n_s64(0x8000000000000000), v101), (int8x16_t)v101);
          v96[1].i64[0] = 0;
        }
        else
        {
          uint64_t v8 = 0;
          unint64_t v97 = 0x8000000000000000 - a4;
          v96->i64[1] = 0;
          v96[1].i64[0] = 0;
          if ((a4 & 0x8000000000000000) == 0) {
            unint64_t v97 = a4;
          }
          v96->i64[0] = v97;
        }
        return v8;
      }
      int v98 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffFastPathControls", 101, 24, *v98, "calloc", v99, v100, v105);
      uint64_t v94 = "building fast path controls";
      __int16 v95 = 311;
LABEL_121:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", v95, 24, 0, v94, v21, v22, v105);
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v20 = BXDiffMatchesCreate(a1, a2, a3, a4, a7, a6, (uint64_t)a7, a8);
  if (!v20)
  {
    uint64_t v94 = "creating diff match lookup object";
    __int16 v95 = 319;
    goto LABEL_121;
  }
  uint64_t v23 = (void **)v20;
  uint64_t v24 = BXDiffMatchesIBuf(v20);
  uint64_t v25 = BXDiffMatchesISize((uint64_t)v23);
  uint64_t v26 = BXDiffMatchesOBuf((uint64_t)v23);
  uint64_t v27 = BXDiffMatchesOSize((uint64_t)v23);
  size_t v28 = 0;
  uint64_t v117 = 0;
  if (!v25 || !v27) {
    goto LABEL_126;
  }
  if (v27 < 1)
  {
    unint64_t v30 = 0;
    uint64_t v93 = 0;
    goto LABEL_123;
  }
  uint64_t v115 = (uint64_t)v23;
  uint64_t v106 = v10;
  unint64_t v107 = a5;
  __ptr = 0;
  unint64_t v29 = 0;
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v113 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = v27;
  int v108 = 1;
  int64x2_t v109 = vdupq_n_s64(0x8000000000000000);
  uint64_t v116 = v27;
  do
  {
    unint64_t v112 = v30;
    v34 += v33;
    BOOL v111 = v34 < v27;
    unint64_t v114 = v29;
    uint64_t v36 = 0;
    if (v34 >= v27)
    {
LABEL_46:
      if (v33 == v36)
      {
        unint64_t v30 = v112;
        if (v34 != v27) {
          continue;
        }
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v37 = v34;
      do
      {
        uint64_t BestMatch = BXDiffMatchesGetBestMatch(v115, v37, &v117);
        uint64_t v39 = BestMatch + v37;
        if (BestMatch + v37 <= v35) {
          uint64_t v33 = BestMatch;
        }
        else {
          uint64_t v33 = v35 - v37;
        }
        if (v34 >= v33 + v37)
        {
          uint64_t v27 = v116;
        }
        else
        {
          if (v39 >= v35) {
            uint64_t v39 = v35;
          }
          unint64_t v40 = (unsigned __int8 *)(v26 + v34);
          uint64_t v41 = v39 - v34;
          uint64_t v42 = v31 + v34;
          uint64_t v27 = v116;
          do
          {
            if (v42 < v25 && *(unsigned __int8 *)(v24 + v42) == *v40) {
              ++v36;
            }
            ++v40;
            ++v42;
            --v41;
          }
          while (v41);
          uint64_t v34 = v39;
        }
        BOOL v43 = v33 != v36 || v33 == 0;
        if (!v43 || v33 > v36 + 8)
        {
          uint64_t v34 = v37;
          unint64_t v29 = v114;
          goto LABEL_46;
        }
        if (v37 + v31 < v25) {
          v36 -= *(unsigned __int8 *)(v24 + v37 + v31) == *(unsigned __int8 *)(v26 + v37);
        }
        ++v37;
      }
      while (v37 < v27);
      BOOL v111 = 0;
      uint64_t v34 = v27;
    }
    unint64_t v30 = v112;
LABEL_50:
    uint64_t v45 = v34 - v32;
    uint64_t v46 = v25 - v113;
    if (v34 - v32 < v25 - v113) {
      uint64_t v46 = v34 - v32;
    }
    if (v46 < 1)
    {
      uint64_t v51 = 0;
    }
    else
    {
      uint64_t v47 = 0;
      int v48 = 0;
      unsigned __int8 v49 = 0;
      unint64_t v50 = 0;
      uint64_t v51 = 0;
      do
      {
        unint64_t v52 = v49 | (v50 << 8);
        unsigned __int8 v53 = *(unsigned char *)(v24 + v47 + v113) - *(unsigned char *)(v26 + v47 + v32);
        if ((v50 & 0xFF000000FF0000) != 0 || (unsigned __int16)v52 == 0) {
          int v55 = 3;
        }
        else {
          int v55 = 4;
        }
        BOOL v56 = __OFADD__(v55, v48);
        int v57 = v55 + v48;
        if ((v57 < 0) ^ v56 | (v57 == 0)) {
          uint64_t v58 = v51;
        }
        else {
          uint64_t v58 = v47 + 1;
        }
        int v59 = v57 & (v57 >> 31);
        v48 -= 4;
        ++v47;
        if (!v53)
        {
          uint64_t v51 = v58;
          int v48 = v59;
        }
        unint64_t v50 = v52;
        unsigned __int8 v49 = v53;
      }
      while (v47 != v46);
    }
    if (!v111) {
      goto LABEL_86;
    }
    if (v45 >= v117) {
      uint64_t v45 = v117;
    }
    if (v45 >= 1)
    {
      uint64_t v60 = 0;
      int v61 = 0;
      unsigned __int8 v62 = 0;
      unint64_t v63 = 0;
      uint64_t v64 = 0;
      int v65 = (char *)(v26 - 1 + v34);
      char v66 = (char *)(v24 - 1 + v117);
      do
      {
        ++v60;
        unint64_t v67 = v62 | (v63 << 8);
        BOOL v43 = (v63 & 0xFF000000FF0000) == 0;
        char v69 = *v66--;
        char v68 = v69;
        char v70 = *v65--;
        unsigned __int8 v71 = v68 - v70;
        if (!v43 || (unsigned __int16)v67 == 0) {
          int v73 = 3;
        }
        else {
          int v73 = 4;
        }
        BOOL v56 = __OFADD__(v73, v61);
        int v74 = v73 + v61;
        if ((v74 < 0) ^ v56 | (v74 == 0)) {
          uint64_t v75 = v64;
        }
        else {
          uint64_t v75 = v60;
        }
        int v76 = v74 & (v74 >> 31);
        v61 -= 4;
        if (!v71)
        {
          uint64_t v64 = v75;
          int v61 = v76;
        }
        unint64_t v63 = v67;
        unsigned __int8 v62 = v71;
      }
      while (v45 != v60);
    }
    else
    {
LABEL_86:
      uint64_t v64 = 0;
    }
    uint64_t v77 = v51 + v32 - (v34 - v64);
    if (v51 + v32 > v34 - v64)
    {
      if (v77 < 1)
      {
        uint64_t v80 = 0;
      }
      else
      {
        uint64_t v78 = 0;
        uint64_t v79 = 0;
        uint64_t v80 = 0;
        do
        {
          int v81 = *(unsigned __int8 *)(v26 + v79 + v34 - v64);
          v78 -= v81 == *(unsigned __int8 *)(v24 + v117 - v64 + v79);
          int v82 = *(unsigned __int8 *)(v24 + v113 - (v32 - (v34 - v64)) + v79);
          if (v78 >= 0) {
            uint64_t v83 = v79 + 1;
          }
          else {
            uint64_t v83 = v80;
          }
          if (v78 < 0) {
            uint64_t v84 = v78 + 1;
          }
          else {
            uint64_t v84 = 0;
          }
          ++v79;
          if (v81 == v82)
          {
            uint64_t v80 = v83;
            uint64_t v78 = v84;
          }
        }
        while (v79 < v77);
      }
      uint64_t v51 = v34 - v64 - v32 + v80;
      v64 -= v80;
    }
    unint64_t v85 = v114;
    if (v30 >= v114)
    {
      v114 += 0x40000;
      __ptr = (int8x16_t *)reallocf(__ptr, 24 * (v85 + 0x40000));
      if (!__ptr)
      {
        uint64_t v86 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffControlsWithMatches", 255, 24, *v86, "malloc", v87, v88, v105);
        __ptr = 0;
        int v108 = 0;
      }
      uint64_t v27 = v116;
    }
    uint64_t v89 = v51 + v32;
    uint64_t v32 = v34 - v64;
    v90.i64[0] = v51;
    v90.i64[1] = v34 - v64 - v89;
    uint64_t v91 = (int8x16_t *)((char *)__ptr + 24 * v30);
    *uint64_t v91 = vbslq_s8((int8x16_t)vcltzq_s64(v90), (int8x16_t)vsubq_s64(v109, v90), (int8x16_t)v90);
    uint64_t v92 = v117 - (v51 + v113 + v64);
    if (v92 < 0) {
      uint64_t v92 = 0x8000000000000000 - v92;
    }
    v91[1].i64[0] = v92;
    ++v30;
    uint64_t v113 = v117 - v64;
    uint64_t v31 = v117 - v34;
    unint64_t v29 = v114;
  }
  while (v34 < v27);
  uint64_t v10 = v106;
  a5 = v107;
  if (!v108)
  {
    uint64_t v23 = (void **)v115;
    size_t v28 = __ptr;
LABEL_126:
    free(v28);
    *a5 = 0;
    *uint64_t v10 = 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", 324, 24, 0, "building diff controls", v102, v103, v105);
    goto LABEL_127;
  }
  uint64_t v93 = __ptr;
  if (__ptr) {
    uint64_t v93 = (int8x16_t *)reallocToFit(__ptr, 24 * v30);
  }
  uint64_t v23 = (void **)v115;
LABEL_123:
  *a5 = v93;
  *uint64_t v10 = v30;
LABEL_127:
  BXDiffMatchesDestroy(v23);
  if (*a5) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aaEntryYFPBlobInitWithPath(void *a1, char *a2, const char *a3)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  v55[0] = 0;
  v55[1] = 0;
  int v6 = (unsigned __int8 *)malloc(0x40000uLL);
  if (!v6)
  {
    int v26 = *__error();
    uint64_t v27 = "malloc";
    __int16 v28 = 43;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", v28, 124, v26, v27, v7, v8, v52);
    unint64_t v29 = 0;
    int v10 = -1;
LABEL_29:
    uint64_t v30 = 0xFFFFFFFFLL;
    goto LABEL_30;
  }
  if ((concatPath(v56, 0x800uLL, a2, a3) & 0x80000000) != 0)
  {
    char v52 = (char)a2;
    uint64_t v27 = "invalid path %s/%s";
    __int16 v28 = 46;
    int v26 = 0;
    goto LABEL_28;
  }
  int v9 = open(v56, 0x200000);
  int v10 = v9;
  if (v9 < 0)
  {
    uint64_t v32 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 50, 124, *v32, "open: %s", v33, v34, (char)v56);
    unint64_t v29 = 0;
    goto LABEL_29;
  }
  ssize_t v11 = read(v9, v6, 0x40000uLL);
  if (v11 < 0)
  {
    int v17 = 0;
LABEL_35:
    unint64_t v29 = v17;
    uint64_t v35 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 56, 124, *v35, "read: %s", v36, v37, (char)v56);
    goto LABEL_29;
  }
  ssize_t v12 = v11;
  unint64_t v13 = 0;
  size_t v14 = 0;
  unsigned int v15 = 0;
  unint64_t v16 = 0;
  int v17 = 0;
  unint64_t v54 = v6;
  int v53 = v10;
  while (2)
  {
    if (v12)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        uint64_t v19 = v6[i];
        unint64_t v16 = v19 + 0x202000202008008DLL * v16 + 0x516929CF586FB3BFLL * *((unsigned __int8 *)v55 + v15);
        *((unsigned char *)v55 + v15) = v19;
        if (v15 == 15) {
          unsigned int v15 = 0;
        }
        else {
          ++v15;
        }
        if (v16 >> 52) {
          BOOL v20 = 1;
        }
        else {
          BOOL v20 = v16 == 0;
        }
        if (!v20)
        {
          if (v14 >= v13)
          {
            if (v13) {
              v13 *= 2;
            }
            else {
              unint64_t v13 = 256;
            }
            if (4 * v13 >= 0x2000000001)
            {
              *__error() = 12;
LABEL_38:
              uint64_t v38 = __error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 79, 124, *v38, "malloc", v39, v40, v52);
              unint64_t v29 = 0;
              uint64_t v30 = 0xFFFFFFFFLL;
              int v10 = v53;
              goto LABEL_30;
            }
            uint64_t v21 = v17;
            uint64_t v22 = realloc(v17, 4 * v13);
            if (!v22)
            {
              free(v21);
              int v6 = v54;
              goto LABEL_38;
            }
            int v17 = v22;
            int v6 = v54;
          }
          *((_DWORD *)v17 + v14++) = v16;
        }
      }
      int v10 = v53;
      uint64_t v23 = v6;
      uint64_t v24 = v17;
      ssize_t v25 = read(v53, v23, 0x40000uLL);
      int v17 = v24;
      int v6 = v54;
      ssize_t v12 = v25;
      if ((v25 & 0x8000000000000000) == 0) {
        continue;
      }
      goto LABEL_35;
    }
    break;
  }
  uint64_t v41 = v17;
  qsort(v17, v14, 4uLL, (int (__cdecl *)(const void *, const void *))cmp_markers);
  if (v14)
  {
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    unint64_t v29 = v41;
    do
    {
      int v46 = *((_DWORD *)v41 + v44);
      if (!v45 || v46 != *((_DWORD *)v41 + v45 - 1)) {
        *((_DWORD *)v41 + v45++) = v46;
      }
      ++v44;
    }
    while (v14 != v44);
    size_t v14 = 4 * v45;
    *a1 = 0;
    if (4 * v45 < 0)
    {
LABEL_66:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldYFP.c", (uint64_t)"aaEntryYFPBlobInitWithPath", 98, 124, 0, "malloc", v42, v43, v52);
      uint64_t v30 = 0xFFFFFFFFLL;
      goto LABEL_67;
    }
    size_t v47 = a1[1];
    if (v47 < v14)
    {
      do
      {
        while (!v47)
        {
          size_t v47 = 0x4000;
          if (v14 <= 0x4000)
          {
            size_t v47 = 0x4000;
            goto LABEL_62;
          }
        }
        size_t v48 = v47 >> 1;
        if ((v47 & (v47 >> 1)) != 0) {
          size_t v48 = v47 & (v47 >> 1);
        }
        v47 += v48;
      }
      while (v47 < v14);
      if (v47 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_65;
      }
LABEL_62:
      unint64_t v50 = (void *)a1[2];
      uint64_t v51 = realloc(v50, v47);
      if (v51)
      {
        a1[1] = v47;
        a1[2] = v51;
        goto LABEL_55;
      }
      free(v50);
LABEL_65:
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      unint64_t v29 = v41;
      goto LABEL_66;
    }
  }
  else
  {
    *a1 = 0;
LABEL_55:
    unint64_t v29 = v41;
    if (!v41)
    {
      uint64_t v49 = a1[2];
      if (v49) {
        memset_s((void *)(v49 + *a1), v14, 0, v14);
      }
      goto LABEL_57;
    }
  }
  memcpy((void *)(a1[2] + *a1), v29, v14);
LABEL_57:
  uint64_t v30 = 0;
  *a1 += v14;
  unint64_t v29 = v41;
LABEL_67:
  int v6 = v54;
LABEL_30:
  free(v6);
  free(v29);
  if ((v10 & 0x80000000) == 0) {
    close(v10);
  }
  return v30;
}

uint64_t cmp_markers(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

off_t AAByteStreamProcess(AAByteStream istream, AAByteStream ostream)
{
  int v4 = (char *)malloc(0x40000uLL);
  if (v4)
  {
    int v5 = v4;
    ssize_t v6 = AAByteStreamRead(istream, v4, 0x40000uLL);
    if ((v6 & 0x8000000000000000) == 0)
    {
      unint64_t v7 = v6;
      off_t v8 = 0;
      while (2)
      {
        if (!v7)
        {
          free(v5);
          return v8;
        }
        unint64_t v9 = 0;
        v8 += v7;
        do
        {
          ssize_t v10 = AAByteStreamWrite(ostream, &v5[v9], v7 - v9);
          if (v10 < 0)
          {
            AAByteStreamCancel(istream);
            unint64_t v13 = "byte stream write error";
            __int16 v14 = 40;
            goto LABEL_14;
          }
          if (!v10)
          {
            unint64_t v13 = "byte stream truncated write";
            __int16 v14 = 42;
            goto LABEL_14;
          }
          v9 += v10;
        }
        while (v9 < v7);
        unint64_t v7 = AAByteStreamRead(istream, v5, 0x40000uLL);
        if ((v7 & 0x8000000000000000) == 0) {
          continue;
        }
        break;
      }
    }
    AAByteStreamCancel(ostream);
    unint64_t v13 = "byte stream read error";
    __int16 v14 = 26;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStreamProcess.c", (uint64_t)"AAByteStreamProcess", v14, 58, 0, v13, v11, v12, v19);
    free(v5);
  }
  else
  {
    unsigned int v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStreamProcess.c", (uint64_t)"AAByteStreamProcess", 18, 58, *v15, "malloc", v16, v17, v19);
  }
  return -1;
}

void *aaAssetDecryptionStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ssize_t v6 = malloc(0x518uLL);
  unint64_t v7 = v6;
  if (!v6)
  {
    __int16 v10 = 439;
LABEL_6:
    uint64_t v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"aaAssetDecryptionStreamOpen", v10, 108, *v11, "malloc", v12, v13, v15);
    closeProc_2((uint64_t)v7);
    return 0;
  }
  memset_s(v6, 0x518uLL, 0, 0x518uLL);
  void *v7 = a1;
  v7[1] = a2;
  v7[2] = a3;
  off_t v8 = malloc(0x38uLL);
  if (!v8)
  {
    __int16 v10 = 446;
    goto LABEL_6;
  }
  unint64_t v9 = v8;
  memset_s(v8, 0x38uLL, 0, 0x38uLL);
  *unint64_t v9 = v7;
  v9[1] = closeProc_2;
  v9[6] = closeWithStateProc_2;
  v9[3] = writeProc_1;
  v9[2] = cancelProc_2;
  return v9;
}

uint64_t closeProc_2(uint64_t result)
{
  if (result)
  {
    int v1 = (void **)result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 24));
    unint64_t v3 = (void *)(result + 1200);
    free(*(void **)(result + 1216));
    memset_s(v3, 0x18uLL, 0, 0x18uLL);
    free(v1[155]);
    memset_s(v1 + 153, 0x18uLL, 0, 0x18uLL);
    free(v1[158]);
    memset_s(v1 + 156, 0x18uLL, 0, 0x18uLL);
    memset_s(v1, 0x518uLL, 0, 0x518uLL);
    free(v1);
    if (v2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t closeWithStateProc_2(uint64_t result, void *a2, void *a3)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (result)
  {
    uint64_t v5 = result;
    unsigned int v6 = atomic_load((unsigned int *)(result + 24));
    BOOL v7 = v6 == 0;
    memset(v47, 0, sizeof(v47));
    long long v46 = 0u;
    memset(v45, 0, sizeof(v45));
    uint64_t v8 = result + 240;
    aeaMagicInit(v45, (_DWORD *)(result + 240));
    aeaRootHeaderInit((unint64_t)v45 | 0xC, v8, v9, v10, v11, v12, v13, v14);
    *(void *)((char *)&v45[3] + 12) = *(void *)(v5 + 676);
    DWORD1(v45[4]) = *(_DWORD *)(v5 + 940);
    uint64_t v17 = (uint64_t *)(v5 + 1200);
    int v18 = (uint64_t *)(v5 + 1224);
    uint64_t v19 = *(void *)(v5 + 1224);
    *((void *)&v45[4] + 1) = *(void *)(v5 + 1200);
    *(void *)&long long v46 = v19;
    BOOL v20 = (uint64_t *)(v5 + 1248);
    *((void *)&v46 + 1) = *(void *)(v5 + 1248);
    *(void *)&v47[0] = *(void *)(v5 + 1272);
    *(_OWORD *)((char *)v47 + 8) = *(_OWORD *)(v5 + 1280);
    *((void *)&v47[1] + 1) = *(void *)(v5 + 1296);
    if (!a2[3]) {
      goto LABEL_51;
    }
    uint64_t v21 = 0;
    uint64_t v22 = v45;
    uint64_t v23 = 128;
    while (1)
    {
      uint64_t v24 = ((uint64_t (*)(void, _OWORD *, uint64_t))a2[3])(*a2, v22, v23);
      if (v24 < 1) {
        break;
      }
      uint64_t v22 = (_OWORD *)((char *)v22 + v24);
      v21 += v24;
      v23 -= v24;
      if (!v23)
      {
        if (v21 < 0) {
          goto LABEL_51;
        }
        goto LABEL_9;
      }
    }
    if (v24 < 0) {
      goto LABEL_51;
    }
LABEL_9:
    if (!a2[3]) {
      goto LABEL_51;
    }
    uint64_t v25 = *(unsigned int *)(v5 + 680);
    if (v25)
    {
      uint64_t v26 = 0;
      uint64_t v27 = v5 + 684;
      while (1)
      {
        uint64_t v28 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v27, v25);
        if (v28 < 1) {
          break;
        }
        v27 += v28;
        v26 += v28;
        v25 -= v28;
        if (!v25)
        {
          if (v26 < 0) {
            goto LABEL_51;
          }
          goto LABEL_17;
        }
      }
      if (v28 < 0) {
        goto LABEL_51;
      }
LABEL_17:
      if (!a2[3]) {
        goto LABEL_51;
      }
    }
    uint64_t v29 = *(unsigned int *)(v5 + 940);
    if (v29)
    {
      uint64_t v30 = 0;
      uint64_t v31 = v5 + 944;
      while (1)
      {
        uint64_t v32 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v31, v29);
        if (v32 < 1) {
          break;
        }
        v31 += v32;
        v30 += v32;
        v29 -= v32;
        if (!v29)
        {
          if ((v30 & 0x8000000000000000) == 0) {
            goto LABEL_25;
          }
          goto LABEL_51;
        }
      }
      if (v32 < 0) {
        goto LABEL_51;
      }
    }
LABEL_25:
    if (!a2[3]) {
      goto LABEL_51;
    }
    uint64_t v33 = *v17;
    if (*v17)
    {
      uint64_t v34 = 0;
      uint64_t v35 = *(void *)(v5 + 1216);
      while (1)
      {
        uint64_t v36 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v35, v33);
        if (v36 < 1) {
          break;
        }
        v35 += v36;
        v34 += v36;
        v33 -= v36;
        if (!v33) {
          goto LABEL_32;
        }
      }
      uint64_t v34 = v36;
LABEL_32:
      if (v34 < 0 || !a2[3]) {
        goto LABEL_51;
      }
    }
    uint64_t v37 = *v18;
    if (*v18)
    {
      uint64_t v38 = 0;
      uint64_t v39 = *(void *)(v5 + 1240);
      while (1)
      {
        uint64_t v40 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v39, v37);
        if (v40 < 1) {
          break;
        }
        v39 += v40;
        v38 += v40;
        v37 -= v40;
        if (!v37) {
          goto LABEL_40;
        }
      }
      uint64_t v38 = v40;
LABEL_40:
      if (v38 < 0) {
        goto LABEL_51;
      }
    }
    if (!a2[3]) {
      goto LABEL_51;
    }
    uint64_t v41 = *v20;
    if (!*v20) {
      goto LABEL_49;
    }
    uint64_t v42 = 0;
    uint64_t v43 = *(void *)(v5 + 1264);
    while (1)
    {
      uint64_t v44 = ((uint64_t (*)(void, uint64_t, uint64_t))a2[3])(*a2, v43, v41);
      if (v44 < 1) {
        break;
      }
      v43 += v44;
      v42 += v44;
      v41 -= v44;
      if (!v41) {
        goto LABEL_48;
      }
    }
    uint64_t v42 = v44;
LABEL_48:
    if (v42 < 0)
    {
LABEL_51:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"closeWithStateProc", 411, 108, 0, "write state", v15, v16, v45[0]);
      BOOL v7 = 0;
    }
    else
    {
LABEL_49:
      if (a3) {
        *a3 = *(void *)(v5 + 1296);
      }
    }
    free(*(void **)(v5 + 1216));
    memset_s((void *)(v5 + 1200), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v5 + 1240));
    memset_s((void *)(v5 + 1224), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(v5 + 1264));
    memset_s((void *)(v5 + 1248), 0x18uLL, 0, 0x18uLL);
    memset_s((void *)v5, 0x518uLL, 0, 0x518uLL);
    free((void *)v5);
    return (v7 - 1);
  }
  return result;
}

uint64_t writeProc_1(uint64_t a1, char *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v176 = *MEMORY[0x263EF8340];
  if (atomic_load((unsigned int *)(a1 + 24))) {
    return -1;
  }
  int v156 = 0;
  long long v11 = 0uLL;
  memset(v155, 0, sizeof(v155));
  int v154 = 0;
  memset(v153, 0, sizeof(v153));
  int v152 = 0;
  memset(v151, 0, sizeof(v151));
  int v150 = 0;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  *(_OWORD *)size_t __n = 0u;
  long long v135 = 0u;
  int v133 = 0;
  memset(v132, 0, sizeof(v132));
  int v131 = 0;
  memset(v130, 0, sizeof(v130));
  int v12 = *(_DWORD *)(a1 + 676);
  if (v12 == 5)
  {
    uint64_t v13 = 0;
    uint64_t v9 = 0;
    goto LABEL_183;
  }
  size_t v14 = a3;
  uint64_t v9 = 0;
  uint64_t v13 = 0;
  uint64_t v16 = (size_t *)(a1 + 1200);
  uint64_t v17 = (char *)(a1 + 32);
  long long v125 = (_DWORD *)(a1 + 680);
  uint64_t v118 = a1 + 940;
  int v18 = (char *)(a1 + 944);
  unint64_t v121 = (void *)(a1 + 1248);
  unint64_t v128 = (_DWORD *)(a1 + 416);
  uint64_t v129 = (size_t *)(a1 + 1200);
  long long v119 = (size_t *)(a1 + 1224);
  uint64_t v122 = a1 + 312;
  uint64_t v126 = a1 + 240;
  __dst = (char *)(a1 + 944);
  while (2)
  {
    size_t v19 = *v16;
    switch(v12)
    {
      case 0:
        if (v19 <= 0xB)
        {
          size_t v20 = 12 - v19;
          goto LABEL_68;
        }
        DWORD2(v175[0]) = 0;
        *(void *)&v175[0] = 0;
        uint64_t v65 = *(void *)(a1 + 1216);
        int v66 = *(_DWORD *)(v65 + 8);
        *(void *)&v175[0] = *(void *)v65;
        DWORD2(v175[0]) = v66;
        if ((aeaContainerParamsInitWithMagic((int *)v126, v175, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0
          || (aeaCryptoInit(v17, (unsigned int *)v126) & 0x80000000) != 0
          || (aeaContainerOffsetsInit(v122, (unsigned int *)v126, (unsigned int *)v17) & 0x80000000) != 0)
        {
          uint64_t v106 = "invalid AEA stream";
          __int16 v107 = 125;
          goto LABEL_181;
        }
        int v12 = 1;
        *(_DWORD *)(a1 + 676) = 1;
        long long v11 = 0uLL;
LABEL_127:
        if (v12 == 5) {
          goto LABEL_183;
        }
        continue;
      case 1:
        size_t v21 = *(void *)(a1 + 376);
        if (v19 < v21) {
          goto LABEL_63;
        }
        if (v19 != v21)
        {
          uint64_t v106 = "invalid state";
          __int16 v107 = 138;
          goto LABEL_181;
        }
        uint64_t v22 = *(_DWORD **)(a1 + 1216);
        uint64_t v13 = aeaContextCreateWithPrologue(v22, v19);
        if (!v13)
        {
          uint64_t v106 = "invalid AEA prologue";
          __int16 v107 = 140;
          goto LABEL_181;
        }
        uint64_t v23 = *(uint64_t (**)(void, uint64_t))(a1 + 16);
        if (v23 && (v23(*(void *)(a1 + 8), v13) & 0x80000000) != 0)
        {
          uint64_t v106 = "user callback returned an error";
          __int16 v107 = 145;
          goto LABEL_181;
        }
        if ((aeaContextUnlock(v13, v126, v125, v155, 1, 0) & 0x80000000) != 0
          || (aeaCryptoInit(v17, (unsigned int *)v126) & 0x80000000) != 0
          || (aeaContainerOffsetsInit(v122, (unsigned int *)v126, (unsigned int *)v17) & 0x80000000) != 0)
        {
          uint64_t v106 = "unlocking AEA";
          __int16 v107 = 151;
          goto LABEL_181;
        }
        *(_OWORD *)uint64_t v13 = *(_OWORD *)v126;
        long long v24 = *(_OWORD *)(v126 + 16);
        long long v25 = *(_OWORD *)(v126 + 32);
        long long v26 = *(_OWORD *)(v126 + 48);
        *(void *)(v13 + 64) = *(void *)(v126 + 64);
        *(_OWORD *)(v13 + 32) = v25;
        *(_OWORD *)(v13 + 48) = v26;
        *(_OWORD *)(v13 + 16) = v24;
        uint64_t v27 = *(uint64_t (**)(void, uint64_t))(a1 + 16);
        if (v27 && (v27(*(void *)(a1 + 8), v13) & 0x80000000) != 0)
        {
          uint64_t v106 = "user callback returned an error";
          __int16 v107 = 156;
          goto LABEL_181;
        }
        uint64_t v28 = __src;
        uint64_t v29 = *(unsigned int *)(a1 + 44);
        if (v29 >= 0x101) {
          goto LABEL_224;
        }
        memcpy(v18, (char *)v22 + *(void *)(a1 + 368), *(unsigned int *)(a1 + 44));
        *(_DWORD *)(a1 + 940) = v29;
        memset_s(&v18[v29], 256 - v29, 0, 256 - v29);
        *(void *)(a1 + 1288) = (*(void *)(a1 + 272) + (unint64_t)*(unsigned int *)(a1 + 256) - 1)
                               / *(unsigned int *)(a1 + 256);
        *(void *)(a1 + 1280) = 0;
        *(void *)(a1 + 1200) = 0;
        *(_DWORD *)(a1 + 1272) = 0;
        int v12 = 2;
        *(_DWORD *)(a1 + 676) = 2;
        __srCC_SHA1_CTX c = v28;
        goto LABEL_125;
      case 2:
        size_t v21 = *(void *)(a1 + 408);
        if (v19 < v21) {
          goto LABEL_63;
        }
        if (v19 != v21)
        {
          uint64_t v106 = "invalid state";
          __int16 v107 = 177;
          goto LABEL_181;
        }
        unint64_t v123 = __src;
        size_t v30 = v14;
        uint64_t v31 = *(char **)(a1 + 1216);
        uint64_t v32 = *(void *)(a1 + 392);
        int v33 = *(_DWORD *)(a1 + 1272);
        *(_OWORD *)((char *)&v175[15] + 4) = v11;
        *(_OWORD *)((char *)&v175[13] + 8) = v11;
        *(_OWORD *)((char *)&v175[14] + 8) = v11;
        *(_OWORD *)((char *)&v175[11] + 8) = v11;
        *(_OWORD *)((char *)&v175[12] + 8) = v11;
        *(_OWORD *)((char *)&v175[9] + 8) = v11;
        *(_OWORD *)((char *)&v175[10] + 8) = v11;
        *(_OWORD *)((char *)&v175[7] + 8) = v11;
        *(_OWORD *)((char *)&v175[8] + 8) = v11;
        *(_OWORD *)((char *)&v175[5] + 8) = v11;
        *(_OWORD *)((char *)&v175[6] + 8) = v11;
        *(_OWORD *)((char *)&v175[3] + 8) = v11;
        *(_OWORD *)((char *)&v175[4] + 8) = v11;
        *(_OWORD *)((char *)&v175[1] + 8) = v11;
        *(_OWORD *)((char *)&v175[2] + 8) = v11;
        *(_OWORD *)((char *)v175 + 8) = v11;
        LODWORD(v174[16]) = 0;
        v174[15] = v11;
        v174[14] = v11;
        v174[13] = v11;
        v174[12] = v11;
        v174[11] = v11;
        v174[10] = v11;
        v174[9] = v11;
        v174[8] = v11;
        v174[7] = v11;
        v174[6] = v11;
        v174[5] = v11;
        v174[4] = v11;
        v174[3] = v11;
        v174[2] = v11;
        v174[1] = v11;
        v174[0] = v11;
        WORD4(v175[0]) = 19267;
        *(void *)&v175[0] = 0x5F41454100000006;
        memset_s((char *)v175 + 10, 0xFAuLL, 0, 0xFAuLL);
        uint64_t v34 = LODWORD(v175[0]);
        if (LODWORD(v175[0]) >= 0xFD) {
          goto LABEL_224;
        }
        *(_DWORD *)((char *)v175 + LODWORD(v175[0]) + 4) = v33;
        LODWORD(v175[0]) = v34 + 4;
        memset_s((char *)v175 + v34 + 8, 252 - v34, 0, 252 - v34);
        uint64_t v35 = *(uint64_t (**)(_DWORD *, void, _DWORD *, _OWORD *, _OWORD *))(a1 + 104);
        if (!v35 || !*v125)
        {
          uint64_t v102 = v175;
LABEL_174:
          memset_s(v102, 0x104uLL, 0, 0x104uLL);
LABEL_175:
          uint64_t v106 = "decrypting cluster header";
          __int16 v107 = 195;
          goto LABEL_181;
        }
        int v36 = v35(v128, *(unsigned int *)v17, v125, v175, v174);
        memset_s(v175, 0x104uLL, 0, 0x104uLL);
        if (v36 < 0) {
          goto LABEL_175;
        }
        memset((char *)v174 + 12, 0, 248);
        *(void *)((char *)v174 + 4) = 0x4B4548435F414541;
        LODWORD(v174[0]) = 8;
        memset_s((char *)v174 + 12, 0xF8uLL, 0, 0xF8uLL);
        memset(v175, 0, 260);
        uint64_t v37 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, _OWORD *))(a1 + 104);
        if (!v37 || !*v128)
        {
          uint64_t v102 = v174;
          goto LABEL_174;
        }
        int v38 = v37(v153, *(unsigned int *)(a1 + 36), v128, v174, v175);
        memset_s(v174, 0x104uLL, 0, 0x104uLL);
        if (v38 < 0) {
          goto LABEL_175;
        }
        uint64_t v39 = *(uint64_t (**)(char *, uint64_t, uint64_t, _OWORD *, char *, size_t))(a1 + 128);
        if (!v39
          || *(_DWORD *)(a1 + 940) != *(_DWORD *)(a1 + 44)
          || (v39(v31, v32, v118, v153, &v31[v32], v19 - v32) & 0x80000000) != 0)
        {
          goto LABEL_175;
        }
        void *v121 = 0;
        if ((v19 & 0x8000000000000000) != 0) {
          goto LABEL_217;
        }
        unint64_t v40 = *(void *)(a1 + 1256);
        size_t v14 = v30;
        if (v40 >= v19) {
          goto LABEL_119;
        }
        do
        {
          while (!v40)
          {
            unint64_t v40 = 0x4000;
            size_t v42 = 0x4000;
            if (v19 <= 0x4000) {
              goto LABEL_117;
            }
          }
          unint64_t v41 = v40 >> 1;
          if ((v40 & (v40 >> 1)) != 0) {
            unint64_t v41 = v40 & (v40 >> 1);
          }
          v40 += v41;
        }
        while (v40 < v19);
        size_t v42 = v40;
        if (v40 >= 0x2000000001)
        {
          *__error() = 12;
LABEL_216:
          void *v121 = 0;
          v121[1] = 0;
          v121[2] = 0;
LABEL_217:
          uint64_t v106 = "copy cluster header";
          __int16 v107 = 198;
          goto LABEL_181;
        }
LABEL_117:
        uint64_t v79 = *(void **)(a1 + 1264);
        uint64_t v80 = realloc(v79, v42);
        if (!v80)
        {
          free(v79);
          goto LABEL_216;
        }
        *(void *)(a1 + 1264) = v80;
        *(void *)(a1 + 1256) = v42;
LABEL_119:
        uint64_t v81 = *(void *)(a1 + 1264);
        if (v31)
        {
          memcpy((void *)(v81 + *v121), v31, v19);
        }
        else if (v81)
        {
          memset_s((void *)(v81 + *v121), v19, 0, v19);
        }
        *(void *)(a1 + 1248) += v19;
        uint64_t v82 = *(unsigned int *)(a1 + 44);
        if (v82 > 0x100)
        {
LABEL_224:
          __break(1u);
          JUMPOUT(0x214AD9430);
        }
        int v18 = __dst;
        memcpy(__dst, &v31[*(void *)(a1 + 392)], *(unsigned int *)(a1 + 44));
        *(_DWORD *)(a1 + 940) = v82;
        memset_s(&__dst[v82], 256 - v82, 0, 256 - v82);
        *(void *)(a1 + 1200) = 0;
        *(_DWORD *)(a1 + 1276) = 0;
        int v12 = 3;
        *(_DWORD *)(a1 + 676) = 3;
        __srCC_SHA1_CTX c = v123;
LABEL_125:
        long long v11 = 0uLL;
        goto LABEL_126;
      case 3:
        if (*(void *)(a1 + 1248) != *(void *)(a1 + 408))
        {
          uint64_t v106 = "invalid state";
          __int16 v107 = 213;
          goto LABEL_181;
        }
        size_t v120 = v14;
        unsigned int v43 = *(_DWORD *)(a1 + 1276);
        if (v43 >= *(_DWORD *)(a1 + 260) || (unint64_t v44 = *(void *)(a1 + 1280), v45 = *(void *)(a1 + 1288), v44 >= v45))
        {
          uint64_t v106 = "invalid state";
          __int16 v107 = 218;
          goto LABEL_181;
        }
        int v124 = __src;
        uint64_t v46 = *(unsigned int *)(a1 + 288);
        size_t v47 = (unsigned int *)(*(void *)(a1 + 1264) + *(void *)(a1 + 384) + (v46 + 8) * v43);
        unint64_t v48 = *v47;
        size_t v21 = v47[1];
        if (v48) {
          BOOL v49 = v21 > v48;
        }
        else {
          BOOL v49 = 1;
        }
        if (v49
          || v21 < v48 && !*(_DWORD *)(a1 + 264)
          || ((unsigned int v50 = *(_DWORD *)(a1 + 256), v44 + 1 != v45) ? (v51 = v48 != v50) : (v51 = 0),
              v48 <= v50 ? (BOOL v52 = !v51) : (BOOL v52 = 0),
              !v52))
        {
          int v108 = "invalid segment sizes";
          __int16 v109 = 229;
          goto LABEL_160;
        }
        if (v19 < v21)
        {
          int v18 = __dst;
          size_t v14 = v120;
          __srCC_SHA1_CTX c = v124;
LABEL_63:
          size_t v20 = v21 - v19;
          if (v21 == v19)
          {
LABEL_126:
            uint64_t v16 = v129;
            goto LABEL_127;
          }
          uint64_t v16 = v129;
LABEL_68:
          if (!v14) {
            goto LABEL_183;
          }
          if (v20 >= v14) {
            size_t v56 = v14;
          }
          else {
            size_t v56 = v20;
          }
          unint64_t v57 = v19 + v56;
          if (__CFADD__(v19, v56) || (v57 & 0x8000000000000000) != 0) {
            goto LABEL_180;
          }
          unint64_t v58 = *(void *)(a1 + 1208);
          if (v58 < v57)
          {
            int v59 = __src;
            do
            {
              while (!v58)
              {
                unint64_t v58 = 0x4000;
                size_t v61 = 0x4000;
                if (v57 <= 0x4000) {
                  goto LABEL_84;
                }
              }
              unint64_t v60 = v58 >> 1;
              if ((v58 & (v58 >> 1)) != 0) {
                unint64_t v60 = v58 & (v58 >> 1);
              }
              v58 += v60;
            }
            while (v58 < v57);
            size_t v61 = v58;
            if (v58 >= 0x2000000001)
            {
              *__error() = 12;
            }
            else
            {
LABEL_84:
              unsigned __int8 v62 = *(void **)(a1 + 1216);
              unint64_t v63 = realloc(v62, v61);
              if (v63)
              {
                *(void *)(a1 + 1216) = v63;
                *(void *)(a1 + 1208) = v61;
                __srCC_SHA1_CTX c = v59;
                uint64_t v16 = v129;
                goto LABEL_86;
              }
              free(v62);
              uint64_t v16 = v129;
            }
            *uint64_t v16 = 0;
            v16[1] = 0;
            v16[2] = 0;
LABEL_180:
            uint64_t v106 = "malloc";
            __int16 v107 = 356;
            goto LABEL_181;
          }
LABEL_86:
          uint64_t v64 = *(void *)(a1 + 1216);
          if (__src)
          {
            memcpy((void *)(v64 + *v16), __src, v56);
          }
          else if (v64)
          {
            memset_s((void *)(v64 + *v16), v56, 0, v56);
          }
          *v16 += v56;
          long long v11 = 0uLL;
          if ((v56 & 0x8000000000000000) != 0) {
            goto LABEL_180;
          }
          v14 -= v56;
          __src += v56;
          v9 += v56;
          *(void *)(a1 + 1296) += v56;
          int v12 = *(_DWORD *)(a1 + 676);
          goto LABEL_127;
        }
        if (v19 != v21)
        {
          int v108 = "invalid state";
          __int16 v109 = 234;
LABEL_160:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", v109, 108, 0, v108, a7, a8, v116);
          uint64_t v9 = -1;
          goto LABEL_183;
        }
        if (v46 >= 0x101) {
          goto LABEL_224;
        }
        src_buffer = *(uint8_t **)(a1 + 1216);
        __memcpy_chk();
        LODWORD(v151[0]) = v46;
        memset_s((char *)v151 + v46 + 4, 256 - v46, 0, 256 - v46);
        uint64_t v67 = *(unsigned int *)(a1 + 44);
        if (v67 >= 0x101) {
          goto LABEL_224;
        }
        __memcpy_chk();
        LODWORD(v132[0]) = v67;
        memset_s((char *)v132 + v67 + 4, 256 - v67, 0, 256 - v67);
        int v68 = *(_DWORD *)(a1 + 1276);
        memset((char *)v174 + 8, 0, 252);
        WORD4(v174[0]) = 19283;
        *(void *)&v174[0] = 0x5F41454100000006;
        memset_s((char *)v174 + 10, 0xFAuLL, 0, 0xFAuLL);
        uint64_t v69 = LODWORD(v174[0]);
        if (LODWORD(v174[0]) >= 0xFD) {
          goto LABEL_224;
        }
        *(_DWORD *)((char *)v174 + LODWORD(v174[0]) + 4) = v68;
        LODWORD(v174[0]) = v69 + 4;
        memset_s((char *)v174 + v69 + 8, 252 - v69, 0, 252 - v69);
        memset(v175, 0, 260);
        char v70 = *(uint64_t (**)(_OWORD *, void, _DWORD *, _OWORD *, _OWORD *))(a1 + 104);
        size_t v14 = v120;
        if (!v70 || !*v128)
        {
          memset_s(v174, 0x104uLL, 0, 0x104uLL);
LABEL_177:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", 248, 108, 0, "decrypting segment", a7, a8, v116);
          uint64_t v9 = -1;
          goto LABEL_183;
        }
        int v71 = v70(v153, *(unsigned int *)(a1 + 36), v128, v174, v175);
        memset_s(v174, 0x104uLL, 0, 0x104uLL);
        if (v71 < 0) {
          goto LABEL_177;
        }
        unsigned int v72 = *(uint64_t (**)(uint8_t *, size_t, _OWORD *, _OWORD *, void, void))(a1 + 128);
        if (!v72
          || LODWORD(v132[0]) != *(_DWORD *)(a1 + 44)
          || (v72(src_buffer, v19, v132, v153, 0, 0) & 0x80000000) != 0)
        {
          goto LABEL_177;
        }
        uint64_t v75 = v129;
        if (v21 < v48)
        {
          size_t v76 = *(void *)(a1 + 1232);
          if (v76 >= v48)
          {
            uint64_t v83 = *(uint8_t **)(a1 + 1240);
            goto LABEL_133;
          }
          do
          {
            while (!v76)
            {
              size_t v76 = 0x4000;
              size_t v78 = 0x4000;
              if (v48 <= 0x4000) {
                goto LABEL_131;
              }
            }
            size_t v77 = v76 >> 1;
            if ((v76 & (v76 >> 1)) != 0) {
              size_t v77 = v76 & (v76 >> 1);
            }
            v76 += v77;
          }
          while (v76 < v48);
          size_t v78 = v76;
          if (v76 >= 0x2000000001)
          {
            *__error() = 12;
          }
          else
          {
LABEL_131:
            uint64_t v84 = *(void **)(a1 + 1240);
            unint64_t v85 = (uint8_t *)realloc(v84, v78);
            if (v85)
            {
              uint64_t v83 = v85;
              *(void *)(a1 + 1240) = v85;
              *(void *)(a1 + 1232) = v78;
              size_t v76 = v78;
              size_t v14 = v120;
LABEL_133:
              *long long v119 = 0;
              if (v83)
              {
                uint64_t v86 = *(unsigned int *)(a1 + 264);
                if (v86 == 774)
                {
                  int64_t v87 = PCompressLZMADecode(v83, v76, src_buffer, v19);
                  uint64_t v88 = v87 & ~(v87 >> 63);
                }
                else
                {
                  compression_algorithm v89 = aeaEffectiveCompressionAlgorithm(v86);
                  LODWORD(v88) = compression_decode_buffer(v83, v76, src_buffer, v19, 0, v89);
                }
                if (v88)
                {
                  unint64_t v90 = *v119 + v88;
                  if (!__CFADD__(*v119, v88) && v90 <= *(void *)(a1 + 1232)) {
                    *long long v119 = v90;
                  }
                }
                uint64_t v75 = v119;
                if (v48 == v88) {
                  goto LABEL_142;
                }
                uint64_t v106 = "invalid compressed buffer";
                __int16 v107 = 271;
              }
              else
              {
                uint64_t v106 = "invalid buffer";
                __int16 v107 = 258;
              }
LABEL_181:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", v107, 108, 0, v106, a7, a8, v116);
LABEL_182:
              uint64_t v9 = -1;
              goto LABEL_183;
            }
            free(v84);
          }
          *long long v119 = 0;
          v119[1] = 0;
          v119[2] = 0;
          uint64_t v106 = "malloc";
          __int16 v107 = 254;
          goto LABEL_181;
        }
LABEL_142:
        if (*v75 != v48)
        {
          uint64_t v106 = "invalid raw size";
          __int16 v107 = 281;
          goto LABEL_181;
        }
        size_t v91 = v75[2];
        int v92 = *(_DWORD *)(a1 + 252);
        if (v92
          && ((aeaChecksum((uint64_t)__n, v92, (void *)v75[2], v48, v73, v74, a7, a8) & 0x80000000) != 0
           || LODWORD(__n[0]) != LODWORD(v151[0])
           || memcmp((char *)__n + 4, (char *)v151 + 4, LODWORD(__n[0]))))
        {
          uint64_t v106 = "segment checksum verification";
          __int16 v107 = 287;
          goto LABEL_181;
        }
        unint64_t v93 = 0;
        uint64_t v16 = v129;
        int v18 = __dst;
        do
        {
          uint64_t v94 = *(uint64_t (**)(void, size_t, unint64_t))(*(void *)a1 + 24);
          if (!v94 || (v95 = v94(**(void **)a1, v91 + v93, v48 - v93), long long v11 = 0uLL, v95 <= 0))
          {
            uint64_t v106 = "invalid raw stream";
            __int16 v107 = 294;
            goto LABEL_181;
          }
          v93 += v95;
        }
        while (v93 < v48);
        *(void *)(a1 + 1200) = 0;
        *(void *)(a1 + 1224) = 0;
        int v96 = *(_DWORD *)(a1 + 1276) + 1;
        *(_DWORD *)(a1 + 1276) = v96;
        uint64_t v97 = *(void *)(a1 + 1280) + 1;
        *(void *)(a1 + 1280) = v97;
        *(_DWORD *)(a1 + 676) = 3;
        if (v97 != *(void *)(a1 + 1288))
        {
          __srCC_SHA1_CTX c = v124;
          if (v96 == *(_DWORD *)(a1 + 260))
          {
            ++*(_DWORD *)(a1 + 1272);
            int v12 = 2;
LABEL_156:
            *(_DWORD *)(a1 + 676) = v12;
          }
          else
          {
            int v12 = 3;
          }
          goto LABEL_127;
        }
        __srCC_SHA1_CTX c = v124;
        if (*(void *)(a1 + 1296) != *(void *)(a1 + 280))
        {
          int v12 = 4;
          goto LABEL_156;
        }
LABEL_223:
        *(_DWORD *)(a1 + 676) = 5;
LABEL_183:
        memset_s(v155, 0x104uLL, 0, 0x104uLL);
        memset_s(v153, 0x104uLL, 0, 0x104uLL);
        memset_s(v151, 0x104uLL, 0, 0x104uLL);
        memset_s(__n, 0x104uLL, 0, 0x104uLL);
        memset_s(v132, 0x104uLL, 0, 0x104uLL);
        memset_s(v130, 0x104uLL, 0, 0x104uLL);
        AEAContextDestroy((AEAContext)v13);
        if (v9 < 0)
        {
          int v103 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v103, 1u);
          if (!v103)
          {
            uint64_t v104 = *(void (**)(void))(*(void *)a1 + 16);
            if (v104) {
              v104(**(void **)a1);
            }
          }
        }
        return v9;
      case 4:
        unint64_t v53 = *(void *)(a1 + 1296);
        unint64_t v54 = *(void *)(a1 + 280);
        BOOL v55 = v54 >= v53;
        size_t v20 = v54 - v53;
        if (!v55)
        {
          uint64_t v106 = "invalid padding state";
          __int16 v107 = 321;
          goto LABEL_181;
        }
        if (v20) {
          goto LABEL_68;
        }
        uint64_t v98 = *(void *)(a1 + 1216);
        memset(v175, 0, 260);
        memset(v174, 0, 260);
        int v173 = 0;
        long long v172 = 0u;
        long long v171 = 0u;
        long long v170 = 0u;
        long long v169 = 0u;
        long long v168 = 0u;
        long long v167 = 0u;
        long long v166 = 0u;
        long long v165 = 0u;
        long long v164 = 0u;
        long long v163 = 0u;
        long long v162 = 0u;
        long long v161 = 0u;
        long long v160 = 0u;
        long long v159 = 0u;
        long long v158 = 0u;
        long long v157 = 0u;
        if (*(void *)(a1 + 208))
        {
          *(_DWORD *)((char *)v174 + 7) = 1262571615;
          *(void *)&v174[0] = 0x5F41454100000007;
          memset_s((char *)v174 + 11, 0xF9uLL, 0, 0xF9uLL);
          uint64_t v99 = *(uint64_t (**)(_OWORD *, void))(a1 + 104);
          if (v99 && *v125)
          {
            uint64_t v100 = v18;
            if ((v99(v175, *(unsigned int *)v17) & 0x80000000) == 0)
            {
              uint64_t v101 = (*(uint64_t (**)(_OWORD *))(a1 + 208))(v175);
              goto LABEL_193;
            }
          }
          else
          {
            uint64_t v100 = v18;
          }
        }
        else
        {
          uint64_t v100 = v18;
        }
        uint64_t v101 = 0;
LABEL_193:
        memset_s(v175, 0x104uLL, 0, 0x104uLL);
        memset_s(v174, 0x104uLL, 0, 0x104uLL);
        if (v101)
        {
          unint64_t v110 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(a1 + 216);
          BOOL v111 = !v110 || (v110(v101, v98, v19) & 0x80000000) != 0;
          memset(v175, 0, 260);
          unint64_t v112 = *(uint64_t (**)(uint64_t, _OWORD *))(a1 + 224);
          if (!v112) {
            goto LABEL_206;
          }
          if (*(_DWORD *)(a1 + 940) != *(_DWORD *)(a1 + 44)) {
            goto LABEL_206;
          }
          if ((v112(v101, v175) & 0x80000000) != 0) {
            goto LABEL_206;
          }
          if (LODWORD(v175[0]) != *(_DWORD *)(a1 + 44)) {
            goto LABEL_206;
          }
          if (LODWORD(v175[0]) < 8) {
            goto LABEL_221;
          }
          uint64_t v113 = 0;
          uint64_t v114 = 0;
          do
          {
            v114 |= *(void *)((char *)v175 + v113 + 4) ^ *(void *)&v100[v113];
            unint64_t v115 = v113 + 16;
            v113 += 8;
          }
          while (v115 <= LODWORD(v175[0]));
          if (!v114)
          {
LABEL_221:
            memset_s(v175, 0x104uLL, 0, 0x104uLL);
            if (!v111)
            {
              *(void *)(a1 + 1200) = 0;
              goto LABEL_223;
            }
          }
          else
          {
LABEL_206:
            memset_s(v175, 0x104uLL, 0, 0x104uLL);
          }
          uint64_t v106 = "corrupted padding";
          __int16 v107 = 337;
        }
        else
        {
          uint64_t v106 = "creating padding hash state";
          __int16 v107 = 334;
        }
        goto LABEL_181;
      default:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"writeProc", 346, 108, 0, "invalid state %d", a7, a8, v12);
        goto LABEL_182;
    }
  }
}

atomic_uint *cancelProc_2(atomic_uint *result)
{
  int v1 = 0;
  atomic_compare_exchange_strong(result + 6, (unsigned int *)&v1, 1u);
  if (!v1)
  {
    unsigned int v2 = *(uint64_t (**)(void))(*(void *)result + 16);
    if (v2) {
      return (atomic_uint *)v2(**(void **)result);
    }
  }
  return result;
}

void (**aaAssetDecryptionStreamOpenWithState(uint64_t a1, AAByteStream_impl *a2, void *a3))(void)
{
  *(void *)((char *)&__s[32] + 4) = *MEMORY[0x263EF8340];
  uint64_t v5 = (void (**)(void))aaAssetDecryptionStreamOpen(a1, 0, 0);
  uint64_t v8 = v5;
  if (!v5) {
    return v8;
  }
  uint64_t v9 = *v5;
  memset(v81, 0, 32);
  long long v79 = 0u;
  long long v80 = 0u;
  long long v78 = 0u;
  memset(v77, 0, sizeof(v77));
  if (!*((void *)a2 + 2)) {
    goto LABEL_25;
  }
  uint64_t v10 = 0;
  long long v11 = v77;
  uint64_t v12 = 128;
  do
  {
    uint64_t v13 = (*((uint64_t (**)(void, _OWORD *, uint64_t))a2 + 2))(*(void *)a2, v11, v12);
    if (v13 < 0) {
      goto LABEL_25;
    }
    if (!v13) {
      break;
    }
    long long v11 = (_OWORD *)((char *)v11 + v13);
    v10 += v13;
    v12 -= v13;
  }
  while (v12);
  if (v10 != 128)
  {
LABEL_25:
    size_t v30 = "truncated state";
    __int16 v31 = 480;
    goto LABEL_26;
  }
  *((_DWORD *)v9 + 169) = HIDWORD(v78);
  *((void *)v9 + 159) = *(void *)&v81[0];
  *((_OWORD *)v9 + 80) = *(_OWORD *)((char *)v81 + 8);
  *((void *)v9 + 162) = *((void *)&v81[1] + 1);
  if ((aeaContainerParamsInitWithMagic((int *)v9 + 60, v77, v14, v15, v16, v17, v6, v7) & 0x80000000) != 0
    || (aeaContainerParamsInitWithRootHeader((uint64_t)v9 + 240, (unint64_t)v77 | 0xC, v18, v19, v20, v21, v6, v7) & 0x80000000) != 0
    || (uint64_t v22 = (_DWORD *)((char *)v9 + 32), (aeaCryptoInit((char *)v9 + 32, (unsigned int *)v9 + 60) & 0x80000000) != 0)
    || (aeaContainerOffsetsInit((uint64_t)v9 + 312, (unsigned int *)v9 + 60, (unsigned int *)v9 + 8) & 0x80000000) != 0)
  {
    size_t v30 = "invalid state";
    __int16 v31 = 493;
    goto LABEL_26;
  }
  if (*((_DWORD *)v9 + 169) >= 6u)
  {
    size_t v30 = "invalid state";
    __int16 v31 = 505;
    goto LABEL_26;
  }
  unint64_t v23 = *((void *)v9 + 160);
  if (v23 > *((void *)v9 + 161)
    || (v24 = *((unsigned int *)v9 + 319), unsigned int v25 = *((_DWORD *)v9 + 65), v24 > v25)
    || v24 + *((unsigned int *)v9 + 318) * (unint64_t)v25 != v23
    || (uint64_t v26 = v79, v79 > *v22)
    || DWORD1(v79) > *((_DWORD *)v9 + 11)
    || ((unint64_t v27 = *((unsigned int *)v9 + 64), v28 = *((void *)v9 + 51), v28 <= v27)
      ? (unint64_t v29 = *((unsigned int *)v9 + 64))
      : (unint64_t v29 = *((void *)v9 + 51)),
        *((void *)&v79 + 1) > v29 || (unint64_t)v80 > v27 || *((void *)&v80 + 1) > v28))
  {
    size_t v30 = "invalid state";
    __int16 v31 = 515;
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAAssetDecryptionStream.c", (uint64_t)"aaAssetDecryptionStreamOpenWithState", v31, 108, 0, v30, v6, v7, v77[0]);
    if (*v8) {
      v8[1]();
    }
    free(v8);
    return 0;
  }
  if (!*((void *)a2 + 2)) {
    goto LABEL_135;
  }
  if (v79)
  {
    uint64_t v33 = 0;
    uint64_t v34 = (uint64_t)v9 + 684;
    do
    {
      uint64_t v35 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v34, v26);
      if (v35 < 0) {
        goto LABEL_135;
      }
      if (!v35) {
        break;
      }
      v34 += v35;
      v33 += v35;
      v26 -= v35;
    }
    while (v26);
    if (v33 < 0 || !*((void *)a2 + 2)) {
      goto LABEL_135;
    }
  }
  uint64_t v36 = DWORD1(v79);
  if (DWORD1(v79))
  {
    uint64_t v37 = 0;
    uint64_t v38 = (uint64_t)v9 + 944;
    do
    {
      uint64_t v39 = (*((uint64_t (**)(void, uint64_t, uint64_t))a2 + 2))(*(void *)a2, v38, v36);
      if (v39 < 0) {
        goto LABEL_135;
      }
      if (!v39) {
        break;
      }
      v38 += v39;
      v37 += v39;
      v36 -= v39;
    }
    while (v36);
    if (v37 < 0)
    {
LABEL_135:
      size_t v30 = "invalid state";
      __int16 v31 = 523;
      goto LABEL_26;
    }
  }
  size_t v40 = *((void *)&v79 + 1);
  if (!*((void *)&v79 + 1)) {
    goto LABEL_72;
  }
  uint64_t v41 = 0;
  size_t v42 = (unint64_t *)((char *)v9 + 1200);
  unint64_t v43 = *((void *)v9 + 150);
  unint64_t v44 = *((void *)v9 + 151);
  do
  {
    if (v43 == v44)
    {
      unint64_t v45 = v44 + 0x40000;
      if ((uint64_t)(v44 + 0x40000) < 0) {
        goto LABEL_135;
      }
      if (v44 <= 0xFFFFFFFFFFFBFFFFLL)
      {
        do
        {
          while (!v44)
          {
            unint64_t v44 = 0x4000;
            size_t v47 = 0x4000;
            if (v45 <= 0x4000) {
              goto LABEL_61;
            }
          }
          unint64_t v46 = v44 >> 1;
          if ((v44 & (v44 >> 1)) != 0) {
            unint64_t v46 = v44 & (v44 >> 1);
          }
          v44 += v46;
        }
        while (v44 < v45);
        size_t v47 = v44;
        if (v44 >= 0x2000000001)
        {
LABEL_133:
          *__error() = 12;
        }
        else
        {
LABEL_61:
          unint64_t v48 = (void *)*((void *)v9 + 152);
          BOOL v49 = realloc(v48, v47);
          if (v49)
          {
            *((void *)v9 + 152) = v49;
            *((void *)v9 + 151) = v47;
            unint64_t v43 = *((void *)v9 + 150);
            goto LABEL_63;
          }
LABEL_132:
          free(v48);
        }
        unint64_t *v42 = 0;
        v42[1] = 0;
        v42[2] = 0;
        goto LABEL_135;
      }
      unint64_t v43 = v44;
    }
    size_t v47 = v44;
LABEL_63:
    if (v47 - v43 >= v40) {
      size_t v50 = v40;
    }
    else {
      size_t v50 = v47 - v43;
    }
    ssize_t v51 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 152) + v43), v50);
    if (v51 < 0) {
      goto LABEL_135;
    }
    if (!v51) {
      break;
    }
    unint64_t v43 = *v42 + v51;
    if (__CFADD__(*v42, v51)) {
      goto LABEL_135;
    }
    unint64_t v44 = *((void *)v9 + 151);
    if (v43 > v44) {
      goto LABEL_135;
    }
    unint64_t *v42 = v43;
    v41 += v51;
    v40 -= v51;
  }
  while (v40);
  if (v41 < 0) {
    goto LABEL_135;
  }
LABEL_72:
  size_t v52 = v80;
  if (!(void)v80) {
    goto LABEL_98;
  }
  uint64_t v53 = 0;
  size_t v42 = (unint64_t *)((char *)v9 + 1224);
  unint64_t v54 = *((void *)v9 + 153);
  unint64_t v55 = *((void *)v9 + 154);
  while (2)
  {
    if (v54 != v55) {
      goto LABEL_85;
    }
    unint64_t v56 = v55 + 0x40000;
    if ((uint64_t)(v55 + 0x40000) < 0) {
      goto LABEL_135;
    }
    if (v55 > 0xFFFFFFFFFFFBFFFFLL)
    {
      unint64_t v54 = v55;
LABEL_85:
      size_t v58 = v55;
      goto LABEL_89;
    }
    do
    {
      while (!v55)
      {
        unint64_t v55 = 0x4000;
        size_t v58 = 0x4000;
        if (v56 <= 0x4000) {
          goto LABEL_87;
        }
      }
      unint64_t v57 = v55 >> 1;
      if ((v55 & (v55 >> 1)) != 0) {
        unint64_t v57 = v55 & (v55 >> 1);
      }
      v55 += v57;
    }
    while (v55 < v56);
    size_t v58 = v55;
    if (v55 >= 0x2000000001) {
      goto LABEL_133;
    }
LABEL_87:
    unint64_t v48 = (void *)*((void *)v9 + 155);
    int v59 = realloc(v48, v58);
    if (!v59) {
      goto LABEL_132;
    }
    *((void *)v9 + 155) = v59;
    *((void *)v9 + 154) = v58;
    unint64_t v54 = *((void *)v9 + 153);
LABEL_89:
    if (v58 - v54 >= v52) {
      size_t v60 = v52;
    }
    else {
      size_t v60 = v58 - v54;
    }
    ssize_t v61 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 155) + v54), v60);
    if (v61 < 0) {
      goto LABEL_135;
    }
    if (!v61) {
      break;
    }
    unint64_t v54 = *v42 + v61;
    if (__CFADD__(*v42, v61)) {
      goto LABEL_135;
    }
    unint64_t v55 = *((void *)v9 + 154);
    if (v54 > v55) {
      goto LABEL_135;
    }
    unint64_t *v42 = v54;
    v53 += v61;
    v52 -= v61;
    if (v52) {
      continue;
    }
    break;
  }
  if (v53 < 0) {
    goto LABEL_135;
  }
LABEL_98:
  size_t v62 = *((void *)&v80 + 1);
  if (!*((void *)&v80 + 1)) {
    goto LABEL_124;
  }
  uint64_t v63 = 0;
  size_t v42 = (unint64_t *)((char *)v9 + 1248);
  unint64_t v64 = *((void *)v9 + 156);
  unint64_t v65 = *((void *)v9 + 157);
  while (2)
  {
    if (v64 != v65)
    {
LABEL_111:
      size_t v68 = v65;
      goto LABEL_115;
    }
    unint64_t v66 = v65 + 0x40000;
    if ((uint64_t)(v65 + 0x40000) < 0) {
      goto LABEL_135;
    }
    if (v65 > 0xFFFFFFFFFFFBFFFFLL)
    {
      unint64_t v64 = v65;
      goto LABEL_111;
    }
    do
    {
      while (!v65)
      {
        unint64_t v65 = 0x4000;
        size_t v68 = 0x4000;
        if (v66 <= 0x4000) {
          goto LABEL_113;
        }
      }
      unint64_t v67 = v65 >> 1;
      if ((v65 & (v65 >> 1)) != 0) {
        unint64_t v67 = v65 & (v65 >> 1);
      }
      v65 += v67;
    }
    while (v65 < v66);
    size_t v68 = v65;
    if (v65 >= 0x2000000001) {
      goto LABEL_133;
    }
LABEL_113:
    unint64_t v48 = (void *)*((void *)v9 + 158);
    uint64_t v69 = realloc(v48, v68);
    if (!v69) {
      goto LABEL_132;
    }
    *((void *)v9 + 158) = v69;
    *((void *)v9 + 157) = v68;
    unint64_t v64 = *((void *)v9 + 156);
LABEL_115:
    if (v68 - v64 >= v62) {
      size_t v70 = v62;
    }
    else {
      size_t v70 = v68 - v64;
    }
    ssize_t v71 = AAByteStreamRead(a2, (void *)(*((void *)v9 + 158) + v64), v70);
    if (v71 < 0) {
      goto LABEL_135;
    }
    if (v71)
    {
      unint64_t v64 = *v42 + v71;
      if (__CFADD__(*v42, v71)) {
        goto LABEL_135;
      }
      unint64_t v65 = *((void *)v9 + 157);
      if (v64 > v65) {
        goto LABEL_135;
      }
      unint64_t *v42 = v64;
      v63 += v71;
      v62 -= v71;
      if (v62) {
        continue;
      }
    }
    break;
  }
  if (v63 < 0) {
    goto LABEL_135;
  }
LABEL_124:
  int v72 = DWORD1(v79);
  *((_DWORD *)v9 + 170) = v79;
  *((_DWORD *)v9 + 235) = v72;
  int v73 = *((_DWORD *)v9 + 318);
  memset(&__s[1], 0, 252);
  int v82 = 0;
  LOWORD(__s[1]) = 19267;
  __s[0] = 0x5F41454100000006;
  memset(&v81[2], 0, 256);
  uint64_t result = (void (**)(void))memset_s((char *)&__s[1] + 2, 0xFAuLL, 0, 0xFAuLL);
  uint64_t v74 = LODWORD(__s[0]);
  if (LODWORD(__s[0]) >= 0xFD)
  {
    __break(1u);
    return result;
  }
  *(_DWORD *)((char *)__s + LODWORD(__s[0]) + 4) = v73;
  LODWORD(__s[0]) = v74 + 4;
  memset_s((char *)&__s[1] + v74, 252 - v74, 0, 252 - v74);
  uint64_t v75 = (uint64_t (*)(char *, void))*((void *)v9 + 13);
  if (!v75 || !*((_DWORD *)v9 + 170))
  {
    memset_s(__s, 0x104uLL, 0, 0x104uLL);
    goto LABEL_131;
  }
  int v76 = v75((char *)v9 + 416, *v22);
  memset_s(__s, 0x104uLL, 0, 0x104uLL);
  if (v76 < 0)
  {
LABEL_131:
    size_t v30 = "invalid state";
    __int16 v31 = 533;
    goto LABEL_26;
  }
  if (a3) {
    *a3 = *((void *)v9 + 162);
  }
  return v8;
}

uint64_t *AEADecryptAndExtractAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8)
{
  memset(&v34, 0, sizeof(v34));
  if (stat(a1, &v34) || (v34.st_mode & 0xF000) != 0x4000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractAsyncStreamOpen", 804, 115, 0, "Invalid/missing directory: %s", v16, v17, (char)a1);
    uint64_t v21 = 0;
    uint64_t v19 = 0;
  }
  else
  {
    uint64_t v18 = malloc(0x9C8uLL);
    uint64_t v19 = (uint64_t)v18;
    if (v18)
    {
      memset_s(v18, 0x9C8uLL, 0, 0x9C8uLL);
      uint64_t v20 = (uint64_t *)malloc(0x38uLL);
      uint64_t v21 = v20;
      if (v20)
      {
        memset_s(v20, 0x38uLL, 0, 0x38uLL);
        *(void *)uint64_t v19 = a3;
        *(void *)(v19 + 8) = a4;
        *(void *)(v19 + 16) = a6;
        *(void *)(v19 + 24) = a5;
        *(void *)(v19 + 2128) = a7;
        *(_DWORD *)(v19 + 2136) = a8;
        *(_DWORD *)(v19 + 2120) = a7 >> 62;
        if (a2) {
          *(void *)(v19 + 2296) = AAByteRangeClone(a2);
        }
        if (realpath_DARWIN_EXTSN(a1, (char *)(v19 + 72)))
        {
          if ((concatPath((char *)(v19 + 1096), 0x400uLL, (char *)(v19 + 72), ".tmp_decrypt") & 0x80000000) != 0)
          {
            char v33 = v19 + 72;
            unsigned int v25 = "Path too long: %s";
            __int16 v26 = 822;
          }
          else if (stat((const char *)(v19 + 1096), &v34) || (v34.st_mode & 0xF000) == 0x4000)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v19 + 2320), 0))
            {
              int v24 = *__error();
              unsigned int v25 = "pthread_mutex_init";
              __int16 v26 = 824;
LABEL_24:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractAsyncStreamOpen", v26, 115, v24, v25, v22, v23, v33);
              goto LABEL_14;
            }
            if (pthread_mutex_init((pthread_mutex_t *)(v19 + 2408), 0))
            {
              int v24 = *__error();
              unsigned int v25 = "pthread_mutex_init";
              __int16 v26 = 825;
              goto LABEL_24;
            }
            __int16 v31 = AEADecryptAsyncStreamOpen(v19, (uint64_t)setupContext_0, (uint64_t)verifySegment_0, (uint64_t)processSegment_1, a7, a8);
            *(void *)(v19 + 48) = v31;
            if (v31)
            {
              AAArchiveStream v32 = AAExtractArchiveOutputStreamOpen(a1, (void *)v19, (AAEntryMessageProc)entryMessage, a7, a8);
              *(void *)(v19 + 64) = v32;
              if (v32)
              {
                uint64_t *v21 = v19;
                v21[1] = (uint64_t)extractToDirAsyncClose;
                v21[4] = (uint64_t)extractToDirAsyncCancel;
                unint64_t v21[2] = (uint64_t)extractToDirAsyncGetRange;
                v21[3] = (uint64_t)extractToDirAsyncProcess;
                return v21;
              }
              unsigned int v25 = "creating extract stream";
              __int16 v26 = 832;
            }
            else
            {
              unsigned int v25 = "creating decrypt stream";
              __int16 v26 = 830;
            }
          }
          else
          {
            char v33 = v19 + 72;
            unsigned int v25 = "Invalid tmp dir: %s";
            __int16 v26 = 823;
          }
        }
        else
        {
          char v33 = (char)a1;
          unsigned int v25 = "Invalid directory: %s";
          __int16 v26 = 821;
        }
        int v24 = 0;
        goto LABEL_24;
      }
      int v24 = *__error();
      unsigned int v25 = "malloc";
      __int16 v26 = 810;
      goto LABEL_24;
    }
    unint64_t v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractAsyncStreamOpen", 808, 115, *v28, "malloc", v29, v30, v33);
    uint64_t v21 = 0;
  }
LABEL_14:
  extractToDirAsyncClose(v19);
  free(v21);
  return 0;
}

uint64_t setupContext_0(uint64_t a1, AEAContext context)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  memset(&v81, 0, sizeof(v81));
  int v4 = *(uint64_t (**)(void, AEAContext))(a1 + 8);
  if (v4 && (v4(*(void *)a1, context) & 0x80000000) != 0)
  {
    uint64_t v9 = "Client context callback returned an error";
    __int16 v10 = 459;
    goto LABEL_18;
  }
  if (*(_DWORD *)(a1 + 2140))
  {
    *(void *)(a1 + 2144) = AEAContextGetFieldUInt(context, 0xDu);
    uint64_t FieldUInt = AEAContextGetFieldUInt(context, 4u);
    *(void *)(a1 + 2152) = FieldUInt;
    size_t v8 = (FieldUInt + *(void *)(a1 + 2144) - 1) / FieldUInt;
    if (v8 >= 0xFFFFFFFF)
    {
      uint64_t v9 = "Too many segments";
      __int16 v10 = 470;
LABEL_18:
      int v21 = 0;
      goto LABEL_19;
    }
    *(_DWORD *)(a1 + 2384) = v8;
    if (v8)
    {
      uint64_t v13 = calloc(v8, 0x10uLL);
      *(void *)(a1 + 2392) = v13;
      if (!v13)
      {
        int v21 = *__error();
        uint64_t v9 = "malloc";
        __int16 v10 = 476;
LABEL_19:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"setupContext", v10, 115, v21, v9, v5, v6, (char)v77);
        long long v11 = 0;
LABEL_20:
        uint64_t v12 = 0xFFFFFFFFLL;
        goto LABEL_21;
      }
      size_t v14 = (*(_DWORD *)(a1 + 2384) + 1);
      *(_DWORD *)(a1 + 2160) = 0;
      *(_DWORD *)(a1 + 2164) = v14;
      uint64_t v15 = calloc(v14, 4uLL);
      *(void *)(a1 + 2168) = v15;
      if (!v15)
      {
        uint64_t v19 = "SharedArrayInit: malloc failed\n";
        __int16 v20 = 55;
        goto LABEL_17;
      }
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 2176), 0))
      {
        uint64_t v19 = "SharedArrayInit: pthread_mutex_init failed\n";
        __int16 v20 = 56;
LABEL_17:
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v20, 0, v19, v16, v17, v18, (char)v77);
        uint64_t v9 = "SharedArrayInit";
        __int16 v10 = 479;
        goto LABEL_18;
      }
      if (pthread_cond_init((pthread_cond_t *)(a1 + 2240), 0))
      {
        uint64_t v19 = "SharedArrayInit: pthread_cond_init failed\n";
        __int16 v20 = 57;
        goto LABEL_17;
      }
      if (AASharedBufferPipeOpen((AAByteStream *)(a1 + 32), (AAByteStream *)(a1 + 40), *(void *)(a1 + 2152)) < 0)
      {
        uint64_t v9 = "AASharedBufferPipeOpen";
        __int16 v10 = 482;
        goto LABEL_18;
      }
      AAArchiveStream v23 = AADecodeArchiveInputStreamOpen(*(AAByteStream *)(a1 + 40), 0, 0, *(void *)(a1 + 2128) | 0x100, *(_DWORD *)(a1 + 2136));
      *(void *)(a1 + 56) = v23;
      if (!v23)
      {
        uint64_t v9 = "open decoder stream";
        __int16 v10 = 486;
        goto LABEL_18;
      }
      if ((createThread((pthread_t *)(a1 + 2488), (uint64_t)loadThread, a1, 0) & 0x80000000) != 0)
      {
        uint64_t v9 = "createThread";
        __int16 v10 = 489;
        goto LABEL_18;
      }
      if ((createThread((pthread_t *)(a1 + 2496), (uint64_t)extractThread, a1, 0) & 0x80000000) != 0)
      {
        uint64_t v9 = "createThread";
        __int16 v10 = 490;
        goto LABEL_18;
      }
    }
    if (stat((const char *)(a1 + 1096), &v81))
    {
      if (mkdir((const char *)(a1 + 1096), 0x1C0u))
      {
        int v21 = *__error();
        LOBYTE(v77) = a1 + 72;
        uint64_t v9 = "mkdir: %s";
        __int16 v10 = 500;
        goto LABEL_19;
      }
    }
    else if ((v81.st_mode & 0xF000) != 0x4000)
    {
      LOBYTE(v77) = a1 + 72;
      uint64_t v9 = "Not a directory: %s";
      __int16 v10 = 496;
      goto LABEL_18;
    }
    buf_timespec size = 0;
    memset(&buf, 0, 128);
    memset(__s2, 0, sizeof(__s2));
    if (AEAContextGetFieldBlob(context, 0x12u, 0, 0x80uLL, (uint8_t *)&buf, &buf_size) < 0)
    {
      uint64_t v9 = "getting archive identifier";
      __int16 v10 = 511;
      goto LABEL_18;
    }
    if ((concatPath(__str, 0x400uLL, (char *)(a1 + 1096), "archive_id") & 0x80000000) != 0)
    {
      LOBYTE(v77) = a1 + 72;
      uint64_t v9 = "Name too long: %s";
      __int16 v10 = 513;
      goto LABEL_18;
    }
    if (stat(__str, &v81))
    {
      if ((storeFileContents(__str, (uint64_t)&buf, buf_size) & 0x80000000) != 0)
      {
        size_t v77 = __str;
        uint64_t v9 = "storing archive id: %s";
        __int16 v10 = 529;
        goto LABEL_18;
      }
    }
    else
    {
      if ((v81.st_mode & 0xF000) != 0x8000 || v81.st_size != buf_size)
      {
        uint64_t v9 = "Archive identifier size mismatch when resuming";
        __int16 v10 = 517;
        goto LABEL_18;
      }
      int v36 = open(__str, 0);
      if (v36 < 0)
      {
        int v21 = *__error();
        size_t v77 = __str;
        uint64_t v9 = "open: %s";
        __int16 v10 = 519;
        goto LABEL_19;
      }
      int v37 = v36;
      ssize_t v38 = read(v36, __s2, buf_size);
      close(v37);
      if (v38 != buf_size || memcmp(&buf, __s2, v38))
      {
        uint64_t v9 = "Archive identifier value mismatch when resuming";
        __int16 v10 = 523;
        goto LABEL_18;
      }
    }
    uint64_t v24 = *(void *)(a1 + 2296);
    if (!v24)
    {
      uint64_t v39 = AAByteRangeCreate();
      *(void *)(a1 + 2296) = v39;
      if (!v39)
      {
        uint64_t v9 = "AAByteRangeCreate";
        __int16 v10 = 537;
        goto LABEL_18;
      }
      if ((AAByteRangeAdd((uint64_t)v39, 0, *(void *)(a1 + 2144), v40, v41, v42, v5, v6) & 0x80000000) != 0)
      {
        uint64_t v9 = "AAByteRangeAdd";
        __int16 v10 = 538;
        goto LABEL_18;
      }
      uint64_t v24 = *(void *)(a1 + 2296);
    }
    uint64_t v25 = AAByteRangeSizeAtOffset(v24, 0x7FFFFFFFFFFFFFFFLL);
    *(void *)(a1 + 2304) = v25 - AAByteRangeSizeAtOffset(v24, 0x8000000000000000);
    Remainingint Range = loadRemainingRange(a1);
    if (RemainingRange)
    {
      long long v11 = RemainingRange;
      *(void *)__str = 0;
      *(void *)&buf.st_dev = 0;
      uint64_t v27 = AAByteRangeFirst((uint64_t)RemainingRange, 0, __str, &buf);
      if ((v27 & 0x8000000000000000) == 0)
      {
        uint64_t v30 = v27;
        while (1)
        {
          uint64_t v31 = *(void *)__str;
          uint64_t v32 = *(void *)&buf.st_dev;
          if (*(uint64_t *)__str <= *(uint64_t *)&buf.st_dev)
          {
            uint64_t v34 = *(void *)(a1 + 2296);
            uint64_t v35 = AAByteRangeSizeAtOffset(v34, *(uint64_t *)&buf.st_dev);
            uint64_t v33 = v35 - AAByteRangeSizeAtOffset(v34, v31);
            uint64_t v32 = *(void *)&buf.st_dev;
            uint64_t v31 = *(void *)__str;
          }
          else
          {
            uint64_t v33 = -1;
          }
          if (v33 < v32 - v31) {
            break;
          }
          uint64_t v30 = AAByteRangeNext((uint64_t)v11, v30, __str, &buf);
          if (v30 < 0) {
            goto LABEL_43;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"setupContext", 553, 115, 0, "Stored remaining range is not a subset of initial range", v28, v29, (char)v77);
        goto LABEL_20;
      }
LABEL_43:
      AAByteRangeDestroy(*(void ***)(a1 + 2296));
      *(void *)(a1 + 2296) = v11;
    }
    else
    {
      long long v11 = *(void ***)(a1 + 2296);
    }
    unint64_t v43 = AAByteRangeClone((uint64_t)v11);
    *(void *)(a1 + 2472) = v43;
    if (!v43)
    {
      uint64_t v9 = "AAByteRangeClone";
      __int16 v10 = 564;
      goto LABEL_18;
    }
    *(_DWORD *)(a1 + 2400) = -1;
    if (!*(_DWORD *)(a1 + 2384))
    {
      uint64_t v12 = 0;
      if (!*(_DWORD *)(a1 + 2120))
      {
        long long v11 = 0;
        goto LABEL_21;
      }
      uint64_t v62 = 0;
      uint64_t v61 = 0;
      uint64_t v60 = 0;
      int v75 = 0;
      LODWORD(v58) = 0;
      goto LABEL_107;
    }
    uint64_t v47 = 0;
    unint64_t v48 = 0;
    while (1)
    {
      uint64_t v49 = *(void *)(a1 + 2152);
      uint64_t v50 = v49 * v48;
      unint64_t v51 = v49 * v48 + v49;
      uint64_t v52 = v51 >= *(void *)(a1 + 2144) ? *(void *)(a1 + 2144) : v51;
      if (v50 > v52) {
        break;
      }
      uint64_t v54 = *(void *)(a1 + 2296);
      uint64_t v55 = AAByteRangeSizeAtOffset(v54, v52);
      uint64_t v56 = AAByteRangeSizeAtOffset(v54, v50);
      uint64_t v53 = *(void *)(a1 + 2392);
      if (v55 != v56) {
        goto LABEL_71;
      }
      *(_DWORD *)(v53 + v47) = 3;
      unlinkTempSegment(a1, v48, v57, v44, v45, v46, v5, v6);
LABEL_73:
      ++v48;
      unint64_t v58 = *(unsigned int *)(a1 + 2384);
      v47 += 16;
      if (v48 >= v58)
      {
        if (*(_DWORD *)(a1 + 2120))
        {
          if (v58)
          {
            unint64_t v59 = 0;
            uint64_t v60 = 0;
            uint64_t v61 = 0;
            int v79 = 0;
            LODWORD(v12) = 0;
            uint64_t v62 = 0;
            while (1)
            {
              uint64_t v63 = *(void *)(a1 + 2152);
              uint64_t v64 = v63 * v59;
              unint64_t v65 = v63 * v59 + v63;
              uint64_t v66 = v65 >= *(void *)(a1 + 2144) ? *(void *)(a1 + 2144) : v65;
              if (v64 > v66) {
                break;
              }
              uint64_t v78 = v62;
              uint64_t v68 = v61;
              uint64_t v69 = v60;
              uint64_t v70 = *(void *)(a1 + 2296);
              uint64_t v71 = AAByteRangeSizeAtOffset(v70, v66);
              uint64_t v72 = AAByteRangeSizeAtOffset(v70, v64);
              uint64_t v67 = v71 - v72;
              if (v71 != v72)
              {
                uint64_t v60 = v69;
                uint64_t v61 = v68;
                uint64_t v62 = v78;
LABEL_84:
                memset(&buf, 0, sizeof(buf));
                if (getTempSegmentFilename(a1, v59, __str, v44, v45, v46, v5, v6) || stat(__str, &buf))
                {
                  st_timespec size = 0;
                }
                else if ((buf.st_mode & 0xF000) == 0x8000)
                {
                  st_timespec size = buf.st_size;
                }
                else
                {
                  st_timespec size = 0;
                }
                v62 += v67;
                LODWORD(v12) = v12 + 1;
                uint64_t v61 = v61 - v64 + v66;
                if (st_size) {
                  int v74 = v79 + 1;
                }
                else {
                  int v74 = v79;
                }
                int v79 = v74;
                v60 += st_size;
                goto LABEL_91;
              }
              uint64_t v60 = v69;
              uint64_t v61 = v68;
              uint64_t v62 = v78;
LABEL_91:
              ++v59;
              unint64_t v58 = *(unsigned int *)(a1 + 2384);
              if (v59 >= v58)
              {
                int v75 = v79;
                goto LABEL_107;
              }
            }
            uint64_t v67 = -1;
            goto LABEL_84;
          }
          uint64_t v62 = 0;
          LODWORD(v12) = 0;
          int v75 = 0;
          uint64_t v61 = 0;
          uint64_t v60 = 0;
LABEL_107:
          int v76 = (FILE **)MEMORY[0x263EF8348];
          fprintf((FILE *)*MEMORY[0x263EF8348], "%12u segments in archive\n", v58);
          fprintf(*v76, "%12u segments to process\n", v12);
          fprintf(*v76, "%12u segments in cache\n", v75);
          fprintf(*v76, "%12u segments to download\n", v12 - v75);
          fprintf(*v76, "%12llu bytes in archive\n", *(void *)(a1 + 2144));
          fprintf(*v76, "%12llu bytes to process\n", v62);
          fprintf(*v76, "%12llu segment bytes in cache\n", v60);
          fprintf(*v76, "%12llu segment bytes to download\n", v61 - v60);
        }
        long long v11 = 0;
        uint64_t v12 = 0;
        goto LABEL_21;
      }
    }
    uint64_t v53 = *(void *)(a1 + 2392);
LABEL_71:
    *(_DWORD *)(v53 + v47) = 0;
    if (*(_DWORD *)(a1 + 2400) == -1) {
      *(_DWORD *)(a1 + 2400) = v48;
    }
    goto LABEL_73;
  }
  long long v11 = 0;
  uint64_t v12 = 0;
  *(_DWORD *)(a1 + 2140) = 1;
LABEL_21:
  AAByteRangeDestroy(v11);
  return v12;
}

uint64_t verifySegment_0(uint64_t a1, size_t __size, unint64_t a3, int a4, const void *a5, size_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  int v36 = 0;
  memset(v35, 0, sizeof(v35));
  unint64_t v9 = *(void *)(a1 + 2152);
  unint64_t v10 = a3 / v9;
  if (a3 / v9 * v9 != a3 || v10 >= *(unsigned int *)(a1 + 2384))
  {
    char v34 = a3;
    size_t v14 = "Invalid segment offset: %llu, size: %zu";
    __int16 v15 = 639;
    int v16 = 0;
    goto LABEL_9;
  }
  if (*(_DWORD *)(*(void *)(a1 + 2392) + 16 * (a3 / v9)) != 3)
  {
    if (__size < 0x2000000001)
    {
      int v21 = malloc(__size);
      if (v21)
      {
        uint64_t v12 = v21;
        if ((int)loadTempSegment(a1, v10, (uint64_t)v21, __size, v22, v23, v24, v25) < 1
          || aeaChecksum((uint64_t)v35, a4, v12, __size, v28, v29, v30, v31)
          || LODWORD(v35[0]) != a6
          || memcmp((char *)v35 + 4, a5, a6))
        {
          unlinkTempSegment(a1, v10, v26, v27, v28, v29, v30, v31);
          uint64_t v13 = 0;
          goto LABEL_11;
        }
        atomic_fetch_add((atomic_uint *volatile)(a1 + 2288), 1u);
        if (*(_DWORD *)(a1 + 2120) >= 2u) {
          fprintf((FILE *)*MEMORY[0x263EF8348], "Segment %u: cached\n", v10);
        }
        if ((notifySegmentAvailable(a1, v10, __size) & 0x80000000) == 0) {
          goto LABEL_7;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"verifySegment", 664, 115, 0, "pushSegmentData failed", v32, v33, v34);
LABEL_10:
        uint64_t v13 = 0xFFFFFFFFLL;
        goto LABEL_11;
      }
    }
    else
    {
      *__error() = 12;
    }
    int v16 = *__error();
    size_t v14 = "malloc";
    __int16 v15 = 652;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"verifySegment", v15, 115, v16, v14, a7, a8, v34);
    uint64_t v12 = 0;
    goto LABEL_10;
  }
  if (*(_DWORD *)(a1 + 2120) >= 2u) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Segment %u: not needed\n", v10);
  }
  uint64_t v12 = 0;
LABEL_7:
  uint64_t v13 = 1;
LABEL_11:
  free(v12);
  return v13;
}

uint64_t processSegment_1(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  unint64_t v9 = *(void *)(a1 + 2152);
  unint64_t v10 = a3 / v9;
  if (a3 / v9 * v9 == a3 && v10 < *(unsigned int *)(a1 + 2384))
  {
    memset(&v33, 0, sizeof(v33));
    if ((getTempSegmentFilename(a1, v10, __str, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      uint64_t v24 = "getSegmentFile";
      __int16 v25 = 127;
    }
    else
    {
      if (stat(__str, &v33))
      {
        char v32 = 0x80;
        int v15 = open(__str, 1537);
        if ((v15 & 0x80000000) == 0)
        {
          int v16 = v15;
          if (!a2)
          {
LABEL_11:
            close(v16);
            atomic_fetch_add((atomic_uint *volatile)(a1 + 2288), 1u);
            if (*(_DWORD *)(a1 + 2120) >= 2u) {
              fprintf((FILE *)*MEMORY[0x263EF8348], "Segment %u: stored in cache\n", v10);
            }
            if ((notifySegmentAvailable(a1, v10, a2) & 0x80000000) == 0) {
              return 0;
            }
            uint64_t v27 = "pushSegmentData";
            __int16 v28 = 695;
            goto LABEL_21;
          }
          unint64_t v17 = 0;
          while (1)
          {
            ssize_t v18 = write(v16, (const void *)(a4 + v17), a2 - v17);
            if (v18 < 0)
            {
              int v29 = *__error();
              uint64_t v30 = "write";
              __int16 v31 = 135;
              goto LABEL_28;
            }
            if (!v18) {
              break;
            }
            v17 += v18;
            if (v17 >= a2) {
              goto LABEL_11;
            }
          }
          uint64_t v30 = "write returned 0";
          __int16 v31 = 136;
          int v29 = 0;
LABEL_28:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeTempSegment", v31, 115, v29, v30, v19, v20, 128);
          close(v16);
LABEL_20:
          uint64_t v27 = "storeTempSegment";
          __int16 v28 = 690;
LABEL_21:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"processSegment", v28, 115, 0, v27, v21, v22, v32);
          return 0xFFFFFFFFLL;
        }
        int v26 = *__error();
        uint64_t v24 = "tmp";
        __int16 v25 = 130;
LABEL_19:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeTempSegment", v25, 115, v26, v24, v13, v14, v32);
        goto LABEL_20;
      }
      uint64_t v24 = "segment already in cache";
      __int16 v25 = 128;
    }
    int v26 = 0;
    goto LABEL_19;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"processSegment", 686, 115, 0, "Invalid segment offset: %llu, size: %zu", a7, a8, a3);
  return 0xFFFFFFFFLL;
}

uint64_t entryMessage(void *a1, uint64_t a2, uint64_t a3, AAHeader header, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = a3;
  int v10 = a2;
  uint64_t v12 = (uint64_t (*)(void, uint64_t, uint64_t, AAHeader))a1[3];
  if (!v12 || (uint64_t v13 = v12(*a1, a2, a3, header), !v13))
  {
    switch(v10)
    {
      case 20:
        uint64_t v39 = -1;
        uint64_t value = -1;
        uint64_t v38 = -1;
        v15.uint64_t ikey = 5265748;
        uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v15);
        BOOL v19 = 0;
        if ((KeyIndex & 0x80000000) == 0)
        {
          unsigned int FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, &value);
          int v18 = FieldUInt <= 1 ? 1 : FieldUInt;
          if (v18 > 0) {
            BOOL v19 = 1;
          }
        }
        v26.uint64_t ikey = 5784649;
        uint32_t v27 = AAHeaderGetKeyIndex(header, v26);
        if ((v27 & 0x80000000) != 0
          || ((unsigned int v28 = AAHeaderGetFieldUInt(header, v27, &v39), v28 <= 1) ? (v29 = 1) : (v29 = v28), v29 <= 0))
        {
          BOOL v19 = 0;
        }
        v30.uint64_t ikey = 5915721;
        uint32_t v31 = AAHeaderGetKeyIndex(header, v30);
        if ((v31 & 0x80000000) != 0
          || ((unsigned int v32 = AAHeaderGetFieldUInt(header, v31, &v38), v32 <= 1) ? (v33 = 1) : (v33 = v32), !v19 || v33 <= 0))
        {
          uint64_t v24 = "Missing IDX,IDZ from archive decoder";
          __int16 v25 = 419;
        }
        else
        {
          uint64_t v34 = AAByteRangeOffsetAtSize(a1[287], v39);
          uint64_t v35 = AAByteRangeOffsetAtSize(a1[287], v38 + v39);
          if (value != 68 || (retireEntryRange((uint64_t)a1, v34, v35) & 0x80000000) == 0) {
            return 0;
          }
          uint64_t v24 = "retire segment";
          __int16 v25 = 428;
        }
        break;
      case 21:
        if (header)
        {
          uint64_t v20 = *(void *)header;
          uint64_t v21 = *((void *)header + 1);
          uint64_t v22 = AAByteRangeOffsetAtSize(a1[287], *(void *)header);
          uint64_t v23 = AAByteRangeOffsetAtSize(a1[287], v21 + v20);
          if ((retireEntryRange((uint64_t)a1, v22, v23) & 0x80000000) == 0) {
            return 0;
          }
          uint64_t v24 = "retire segment";
          __int16 v25 = 441;
        }
        else
        {
          uint64_t v24 = "data not expected to be NULL";
          __int16 v25 = 432;
        }
        break;
      case 22:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"entryMessage", 407, 115, 0, "Extraction failed: %s", a7, a8, v9);
LABEL_37:
        uint64_t v14 = 0xFFFFFFFFLL;
LABEL_38:
        cancelStreams((uint64_t)a1);
        return v14;
      default:
        return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"entryMessage", v25, 115, 0, v24, a7, a8, v37);
    goto LABEL_37;
  }
  uint64_t v14 = v13;
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_38;
  }
  return v14;
}

uint64_t extractToDirAsyncClose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = atomic_load((unsigned int *)(result + 2292));
    BOOL v3 = v2 == 0;
    if (*(void *)(result + 2488))
    {
      SharedArrayEnqueue((unsigned int *)(result + 2160), -1);
      joinThread(*(_opaque_pthread_t **)(v1 + 2488));
    }
    AAByteStreamClose(*(AAByteStream *)(v1 + 32));
    int v4 = *(_opaque_pthread_t **)(v1 + 2496);
    if (v4) {
      joinThread(v4);
    }
    AAByteStreamClose(*(AAByteStream *)(v1 + 40));
    if (AAArchiveStreamClose(*(AAArchiveStream *)(v1 + 64)) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractToDirAsyncClose", 725, 115, 0, "extract stream reported errors", v5, v6, v11.st_dev);
      BOOL v3 = 0;
    }
    if (AAArchiveStreamClose(*(AAArchiveStream *)(v1 + 56)) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractToDirAsyncClose", 726, 115, 0, "decode stream reported errors", v7, v8, v11.st_dev);
      BOOL v3 = 0;
    }
    if ((AAAsyncByteStreamClose(*(uint64_t (***)(void))(v1 + 48)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractToDirAsyncClose", 727, 115, 0, "decrypt stream reported errors", v9, v10, v11.st_dev);
      BOOL v3 = 0;
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2320));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2408));
    free(*(void **)(v1 + 2392));
    if (*(_DWORD *)(v1 + 2384)
      && !pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2176))
      && !pthread_cond_destroy((pthread_cond_t *)(v1 + 2240)))
    {
      free(*(void **)(v1 + 2168));
    }
    AAByteRangeDestroy(*(void ***)(v1 + 2296));
    AAByteRangeDestroy(*(void ***)(v1 + 2472));
    if (v3)
    {
      memset(&v11, 0, sizeof(v11));
      if (!stat((const char *)(v1 + 1096), &v11) && (v11.st_mode & 0xF000) == 0x4000) {
        removeTree((char *)(v1 + 1096));
      }
    }
    free((void *)v1);
    if (v3) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t extractToDirAsyncGetRange(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = (atomic_uint *)(a1 + 2312);
  if (atomic_load((unsigned int *)(a1 + 2312))) {
    goto LABEL_2;
  }
  uint64_t result = AAAsyncByteStreamGetRange(*(void **)(a1 + 48), a2, a3);
  if ((int)result >= 1)
  {
    if (result == 1 && *a2) {
      return 1;
    }
LABEL_2:
    int v8 = 0;
    uint64_t result = 0;
    atomic_compare_exchange_strong(v6, (unsigned int *)&v8, 1u);
    if (*(_DWORD *)(a1 + 2400) < *(_DWORD *)(a1 + 2384)) {
      return result;
    }
    *a2 = 0;
    *a3 = 0;
    return 1;
  }
  return result;
}

uint64_t extractToDirAsyncProcess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AAAsyncByteStreamProcess(*(uint64_t **)(a1 + 48), a2, a3, a4);
}

uint64_t AEADecryptAndExtractChunkAsyncStreamOpen(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8, unint64_t a9, unsigned int a10)
{
  AsyncStreamOpen = AEADecryptAndExtractAsyncStreamOpen(a1, a2, a3, a4, a5, a6, a9 | 0x200000000000000, a10);
  if (AsyncStreamOpen)
  {
    return aaCompositeChunkAsyncStreamOpen((uint64_t)AsyncStreamOpen, a7, a8, a9, a10);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"AEADecryptAndExtractChunkAsyncStreamOpen", 868, 115, 0, "AEADecryptAndExtractAsyncStreamOpen", v13, v14, v16);
    return 0;
  }
}

uint64_t loadThread(uint64_t a1)
{
  size_t v2 = *(void *)(a1 + 2152);
  if (v2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_7:
    uint64_t v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 331, 115, *v13, "malloc", v14, v15, v41);
    int v4 = 0;
    goto LABEL_8;
  }
  BOOL v3 = (char *)malloc(v2);
  if (!v3) {
    goto LABEL_7;
  }
  int v4 = v3;
  uint64_t v5 = (pthread_mutex_t *)(a1 + 2176);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2176)))
  {
LABEL_5:
    uint64_t v9 = "SharedArrayPop: pthread_mutex_lock failed\n";
    __int16 v10 = 91;
LABEL_6:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/../AppleArchive/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v10, 0, v9, v6, v7, v8, v41);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 336, 115, 0, "SharedArrayDequeue", v11, v12, v42);
  }
  else
  {
    while (1)
    {
      while (1)
      {
        int v17 = *(_DWORD *)(a1 + 2160);
        if (v17) {
          break;
        }
        if (pthread_cond_wait((pthread_cond_t *)(a1 + 2240), v5))
        {
          uint64_t v9 = "SharedArrayPop: pthread_cond_wait failed\n";
          __int16 v10 = 94;
          goto LABEL_6;
        }
      }
      unsigned int v18 = v17 - 1;
      *(_DWORD *)(a1 + 2160) = v18;
      uint64_t v19 = *(unsigned int *)(*(void *)(a1 + 2168) + 4 * v18);
      if (pthread_mutex_unlock(v5))
      {
        uint64_t v9 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        __int16 v10 = 98;
        goto LABEL_6;
      }
      if (v19 == -1) {
        goto LABEL_9;
      }
      if (v19 >= *(_DWORD *)(a1 + 2384))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 338, 115, 0, "Invalid segment index: %u", v7, v8, v19);
        goto LABEL_8;
      }
      if (*(_DWORD *)(a1 + 2120) >= 2u) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Segment %u: dequeue\n", v19);
      }
      unint64_t v21 = *(void *)(*(void *)(a1 + 2392) + 16 * v19 + 8);
      if ((int)loadTempSegment(a1, v19, (uint64_t)v4, v21, v20, v6, v7, v8) <= 0) {
        break;
      }
      unint64_t v24 = *(void *)(a1 + 2152) * v19;
      unint64_t v43 = 0;
      unint64_t v44 = 0;
      uint64_t v25 = AAByteRangeFirst(*(void *)(a1 + 2296), v24, &v44, &v43);
      if (v25 < 0)
      {
        uint64_t v33 = 0;
      }
      else
      {
        uint64_t v32 = v25;
        uint64_t v33 = 0;
        unint64_t v34 = v24 + v21;
        int v35 = 1;
        do
        {
          if (v44 <= v24) {
            unint64_t v36 = v24;
          }
          else {
            unint64_t v36 = v44;
          }
          if (v34 >= v43) {
            unint64_t v37 = v43;
          }
          else {
            unint64_t v37 = v34;
          }
          if (v36 >= v37) {
            break;
          }
          while (1)
          {
            ssize_t v38 = AAByteStreamWrite(*(AAByteStream *)(a1 + 32), &v4[v36 - v24], v37 - v36);
            if (v38 < 0) {
              break;
            }
            v36 += v38;
            v33 += v38;
            if (v36 >= v37) {
              goto LABEL_30;
            }
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 364, 115, 0, "SharedBufferWrite", v39, v40, v41);
          int v35 = 0;
LABEL_30:
          uint64_t v32 = AAByteRangeNext(*(void *)(a1 + 2296), v32, &v44, &v43);
        }
        while ((v32 & 0x8000000000000000) == 0);
        uint64_t v5 = (pthread_mutex_t *)(a1 + 2176);
        if (!v35) {
          goto LABEL_8;
        }
      }
      if (*(_DWORD *)(a1 + 2120) >= 2u) {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Segment %u: %zu B processed\n", v19, v33);
      }
      unlinkTempSegment(a1, v19, v26, v27, v28, v29, v30, v31);
      atomic_fetch_add((atomic_uint *volatile)(a1 + 2288), 0xFFFFFFFF);
      if (pthread_mutex_lock(v5)) {
        goto LABEL_5;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadThread", 344, 115, 0, "loading segment: %u", v22, v23, v19);
  }
LABEL_8:
  cancelStreams(a1);
LABEL_9:
  free(v4);
  return a1;
}

uint64_t extractThread(uint64_t a1)
{
  if (AAArchiveStreamProcess(*(AAArchiveStream *)(a1 + 56), *(AAArchiveStream *)(a1 + 64), 0, 0, *(void *)(a1 + 2128), *(_DWORD *)(a1 + 2136)) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"extractThread", 389, 115, 0, "AAByteStreamProcess reported an error", v2, v3, v5);
    cancelStreams(a1);
  }
  return a1;
}

void **loadRemainingRange(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  bzero(v19, 0x400uLL);
  if ((concatPath(v19, 0x400uLL, (char *)(a1 + 1096), "remaining") & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadRemainingRange", 254, 115, 0, "Name too long", v2, v3, v17);
    goto LABEL_9;
  }
  int v4 = open(v19, 0);
  if (v4 < 0)
  {
LABEL_9:
    uint64_t v8 = 0;
    goto LABEL_17;
  }
  int v5 = v4;
  uint64_t v8 = (void **)AAByteRangeCreate();
  if (v8)
  {
    while (1)
    {
      ssize_t v9 = read(v5, v18, 0x10uLL);
      if (v9 < 0)
      {
        int v15 = *__error();
        uint64_t v13 = "read";
        __int16 v14 = 264;
        goto LABEL_16;
      }
      if (v9 != 16) {
        break;
      }
      if ((AAByteRangeAdd((uint64_t)v8, v18[0], v18[1], v10, v11, v12, v6, v7) & 0x80000000) != 0)
      {
        uint64_t v13 = "AAByteRangeAdd";
        __int16 v14 = 267;
        goto LABEL_15;
      }
    }
    if (!v9)
    {
      close(v5);
      return v8;
    }
    uint64_t v13 = "truncated remaining range file";
    __int16 v14 = 266;
  }
  else
  {
    uint64_t v13 = "AAByteRangeCreate";
    __int16 v14 = 259;
  }
LABEL_15:
  int v15 = 0;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"loadRemainingRange", v14, 115, v15, v13, v6, v7, v17);
  close(v5);
LABEL_17:
  AAByteRangeDestroy(v8);
  return 0;
}

uint64_t unlinkTempSegment(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t result = getTempSegmentFilename(a1, a2, __str, a4, a5, a6, a7, a8);
  if (!result) {
    return unlink(__str);
  }
  return result;
}

uint64_t loadTempSegment(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  memset(&v17, 0, sizeof(v17));
  if ((getTempSegmentFilename(a1, a2, __str, a4, a5, a6, a7, a8) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  int v10 = open(__str, 0, *(_OWORD *)&v17.st_dev, *(_OWORD *)&v17.st_uid, *(_OWORD *)&v17.st_atimespec, *(_OWORD *)&v17.st_mtimespec, *(_OWORD *)&v17.st_ctimespec, *(_OWORD *)&v17.st_birthtimespec);
  if (v10 < 0) {
    return 0;
  }
  int v11 = v10;
  if (fstat(v10, &v17))
  {
    uint64_t v12 = 0;
  }
  else if (v17.st_size == a4)
  {
    LODWORD(v12) = 0;
    unint64_t v13 = 0;
    while (a4 > v13)
    {
      ssize_t v14 = read(v11, (void *)(a3 + v13), a4 - v13);
      if (v14) {
        int v15 = 0;
      }
      else {
        int v15 = 3;
      }
      if (v14 < 0) {
        uint64_t v12 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v12 = v12;
      }
      v13 += v14 & ~(v14 >> 63);
      if (v14 < 0) {
        int v15 = 2;
      }
      if (v15)
      {
        if (v15 == 2) {
          goto LABEL_24;
        }
        break;
      }
    }
    if (v13 == a4) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = 0xFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v12 = 0xFFFFFFFFLL;
  }
LABEL_24:
  close(v11);
  return v12;
}

void cancelStreams(uint64_t a1)
{
  int v1 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 2292), (unsigned int *)&v1, 1u);
  if (!v1)
  {
    uint64_t v3 = *(AAArchiveStream_impl **)(a1 + 56);
    if (v3) {
      AAArchiveStreamCancel(v3);
    }
    int v4 = *(AAArchiveStream_impl **)(a1 + 64);
    if (v4) {
      AAArchiveStreamCancel(v4);
    }
    int v5 = *(void **)(a1 + 48);
    if (v5) {
      AAAsyncByteStreamCancel(v5);
    }
    uint64_t v6 = *(AAByteStream_impl **)(a1 + 32);
    if (v6) {
      AAByteStreamCancel(v6);
    }
    uint64_t v7 = *(AAByteStream_impl **)(a1 + 40);
    if (v7)
    {
      AAByteStreamCancel(v7);
    }
  }
}

uint64_t getTempSegmentFilename(uint64_t a1, unsigned int a2, char *__str, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 2384) <= a2)
  {
    char v11 = a2;
    uint64_t v8 = "Invalid segment index: %u";
    __int16 v9 = 113;
    goto LABEL_5;
  }
  if (snprintf(__str, 0x400uLL, "%s/%08x", (const char *)(a1 + 1096), a2) >= 0x400)
  {
    uint64_t v8 = "Segment file name too long";
    __int16 v9 = 115;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"getTempSegmentFilename", v9, 115, 0, v8, a7, a8, v11);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t notifySegmentAvailable(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 2320);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2320)))
  {
    __int16 v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 88, 115, *v9, "pthread_mutex_lock", v10, v11, v24);
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v13 = *(void *)(a1 + 2392);
    if (*(_DWORD *)(v13 + 16 * a2))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 90, 115, 0, "Invalid segment state", v7, v8, v24);
      int v14 = 0;
      uint64_t v13 = *(void *)(a1 + 2392);
    }
    else
    {
      int v14 = 1;
    }
    uint64_t v15 = v13 + 16 * a2;
    *(_DWORD *)uint64_t v15 = 1;
    *(void *)(v15 + 8) = a3;
    unsigned int v16 = *(_DWORD *)(a1 + 2400);
    if (v16 < *(_DWORD *)(a1 + 2384))
    {
      stat v17 = (FILE **)MEMORY[0x263EF8348];
      do
      {
        int v18 = *(_DWORD *)(*(void *)(a1 + 2392) + 16 * v16);
        if (v18 == 1)
        {
          if (*(_DWORD *)(a1 + 2120) >= 2u)
          {
            fprintf(*v17, "Segment %u: in queue for processing\n", v16);
            unsigned int v16 = *(_DWORD *)(a1 + 2400);
          }
          if ((SharedArrayEnqueue((unsigned int *)(a1 + 2160), v16) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 101, 115, 0, "SharedArrayEnqueue", v19, v20, v24);
            int v14 = 0;
          }
        }
        else if (!v18)
        {
          break;
        }
        unsigned int v16 = *(_DWORD *)(a1 + 2400) + 1;
        *(_DWORD *)(a1 + 2400) = v16;
      }
      while (v16 < *(_DWORD *)(a1 + 2384));
    }
    if (pthread_mutex_unlock(v6))
    {
      unint64_t v21 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"notifySegmentAvailable", 106, 115, *v21, "pthread_mutex_unlock", v22, v23, v24);
      int v14 = 0;
    }
    if (v14) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
}

uint64_t retireEntryRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v6 = (pthread_mutex_t *)(a1 + 2408);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 2408)))
  {
    uint64_t v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 290, 115, *v12, "pthread_mutex_lock", v13, v14, v56);
    return 0xFFFFFFFFLL;
  }
  if ((AAByteRangeSub(*(unint64_t **)(a1 + 2472), a2, a3, v7, v8, v9, v10, v11) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 293, 115, 0, "AAByteRangeSub", v16, v17, v56);
    int v18 = 0;
  }
  else
  {
    int v18 = 1;
  }
  double RealTime = getRealTime();
  if (RealTime <= *(double *)(a1 + 2480) + 1.0) {
    goto LABEL_34;
  }
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  bzero(&__from, 0x400uLL);
  bzero(&__to, 0x400uLL);
  if ((concatPath((char *)&__from, 0x400uLL, (char *)(a1 + 1096), "remaining.tmp") & 0x80000000) != 0)
  {
    __int16 v35 = 203;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", v35, 115, 0, "Name too long", v20, v21, v56);
LABEL_24:
    char v24 = 0;
    goto LABEL_25;
  }
  if ((concatPath((char *)&__to, 0x400uLL, (char *)(a1 + 1096), "remaining") & 0x80000000) != 0)
  {
    __int16 v35 = 204;
    goto LABEL_23;
  }
  char v56 = 0x80;
  int v22 = open((const char *)&__from, 1537);
  if (v22 < 0)
  {
    int v47 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", 207, 115, v47, "open: %s", v48, v49, (char)&__to);
    goto LABEL_24;
  }
  int v23 = v22;
  char v24 = (char *)calloc(0x4000uLL, 8uLL);
  if (!v24)
  {
    int v50 = *__error();
    unint64_t v51 = "malloc";
    __int16 v52 = 210;
LABEL_45:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", v52, 115, v50, v51, v30, v31, 128);
    close(v23);
    goto LABEL_25;
  }
  uint64_t v25 = AAByteRangeFirst(*(void *)(a1 + 2472), 0, &v58, &v57);
  if (v25 < 0) {
    goto LABEL_19;
  }
  uint64_t v26 = v25;
  uint64_t v27 = 0;
  do
  {
    uint64_t v28 = v57;
    uint64_t v29 = &v24[8 * v27];
    v27 += 2;
    *(void *)uint64_t v29 = v58;
    *((void *)v29 + 1) = v28;
    if (v27 == 0x4000)
    {
      if (write(v23, v24, 0x20000uLL) != 0x20000)
      {
        unint64_t v51 = "truncated write";
        __int16 v52 = 220;
LABEL_44:
        int v50 = 0;
        goto LABEL_45;
      }
      uint64_t v27 = 0;
    }
    uint64_t v26 = AAByteRangeNext(*(void *)(a1 + 2472), v26, &v58, &v57);
  }
  while ((v26 & 0x8000000000000000) == 0);
  if (v27 && write(v23, v24, 8 * v27) != 8 * v27)
  {
    unint64_t v51 = "truncated write";
    __int16 v52 = 229;
    goto LABEL_44;
  }
LABEL_19:
  close(v23);
  rename(&__from, &__to, v32);
  if ((v33 & 0x80000000) == 0)
  {
    int v34 = 0;
    goto LABEL_26;
  }
  uint64_t v53 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"storeRemainingRange", 235, 115, *v53, "rename: %s", v54, v55, (char)&__to);
LABEL_25:
  int v34 = 1;
LABEL_26:
  if (__from.__pn_.__r_.__value_.__s.__data_[0]) {
    unlink((const char *)&__from);
  }
  free(v24);
  if (v34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 300, 115, 0, "store remaining range", v36, v37, v56);
    int v18 = 0;
  }
  if (*(void *)(a1 + 16))
  {
    uint64_t v38 = *(void *)(a1 + 2304);
    uint64_t v39 = *(void *)(a1 + 2472);
    uint64_t v40 = AAByteRangeSizeAtOffset(v39, 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v41 = AAByteRangeSizeAtOffset(v39, 0x8000000000000000);
    if (((*(uint64_t (**)(void, float))(a1 + 16))(*(void *)a1, (float)((float)(v38 - v40 + v41) * 100.0) / (float)v38) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 301, 115, 0, "User cancelled operation", v42, v43, v56);
      int v18 = 0;
    }
  }
  *(double *)(a1 + 2480) = RealTime;
LABEL_34:
  if (pthread_mutex_unlock(v6))
  {
    unint64_t v44 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleEncryptedArchive/AEADecryptAndExtractAsyncStream.c", (uint64_t)"retireEntryRange", 305, 115, *v44, "pthread_mutex_unlock", v45, v46, v56);
    int v18 = 0;
  }
  if (v18) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aaEntryHashesInitWithFD(unsigned char *a1, unsigned int a2, int a3)
{
  uint64_t v6 = malloc(0x40000uLL);
  if (a1) {
    memset_s(a1, 0xACuLL, 0, 0xACuLL);
  }
  v20[0] = 0;
  v20[1] = 0;
  memset(&c, 0, sizeof(c));
  memset(&v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  memset(&v16, 0, sizeof(v16));
  __int16 v7 = *a1 & 0xE0 | ((unsigned __int16)a2 >> 11);
  *a1 = *a1 & 0xE0 | ((unsigned __int16)a2 >> 11);
  if ((a2 >> 11))
  {
    CC_CKSUM_Init((uint64_t)v20);
    LOBYTE(v7) = *a1;
    if ((*a1 & 2) == 0)
    {
LABEL_5:
      if ((v7 & 4) == 0) {
        goto LABEL_6;
      }
      goto LABEL_11;
    }
  }
  else if ((v7 & 2) == 0)
  {
    goto LABEL_5;
  }
  CC_SHA1_Deprecated_Init(&c);
  LOBYTE(v7) = *a1;
  if ((*a1 & 4) == 0)
  {
LABEL_6:
    if ((v7 & 8) == 0) {
      goto LABEL_7;
    }
LABEL_12:
    CC_SHA384_Init(&v17);
    if ((*a1 & 0x10) == 0) {
      goto LABEL_26;
    }
    goto LABEL_13;
  }
LABEL_11:
  CC_SHA256_Init(&v18);
  LOBYTE(v7) = *a1;
  if ((*a1 & 8) != 0) {
    goto LABEL_12;
  }
LABEL_7:
  if ((v7 & 0x10) == 0) {
    goto LABEL_26;
  }
LABEL_13:
  CC_SHA512_Init(&v16);
  while (1)
  {
LABEL_26:
    ssize_t v9 = read(a3, v6, 0x40000uLL);
    uint64_t v10 = v9;
    if (v9 < 0)
    {
      uint64_t v11 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryHashesInitWithFD", 36, 102, *v11, "read", v12, v13, v16.count[0]);
      goto LABEL_35;
    }
    if (!v9) {
      break;
    }
    char v8 = *a1;
    if (*a1)
    {
      CC_CKSUM_Update((uint64_t)v20, (unsigned __int8 *)v6, v9);
      char v8 = *a1;
      if ((*a1 & 2) != 0) {
        goto LABEL_22;
      }
LABEL_17:
      if ((v8 & 4) == 0) {
        goto LABEL_18;
      }
LABEL_23:
      CC_SHA256_Update(&v18, v6, v10);
      char v8 = *a1;
      if ((*a1 & 8) == 0) {
        goto LABEL_19;
      }
LABEL_24:
      CC_SHA384_Update(&v17, v6, v10);
      if ((*a1 & 0x10) != 0) {
        goto LABEL_25;
      }
    }
    else
    {
      if ((*a1 & 2) == 0) {
        goto LABEL_17;
      }
LABEL_22:
      CC_SHA1_Deprecated_Update(&c, v6, v10);
      char v8 = *a1;
      if ((*a1 & 4) != 0) {
        goto LABEL_23;
      }
LABEL_18:
      if ((v8 & 8) != 0) {
        goto LABEL_24;
      }
LABEL_19:
      if ((v8 & 0x10) != 0) {
LABEL_25:
      }
        CC_SHA512_Update(&v16, v6, v10);
    }
  }
  char v14 = *a1;
  if ((*a1 & 1) == 0)
  {
    if ((*a1 & 2) == 0) {
      goto LABEL_30;
    }
LABEL_37:
    CC_SHA1_Deprecated_Final(a1 + 8, &c);
    char v14 = *a1;
    if ((*a1 & 4) != 0) {
      goto LABEL_38;
    }
LABEL_31:
    if ((v14 & 8) == 0) {
      goto LABEL_32;
    }
LABEL_39:
    CC_SHA384_Final(a1 + 60, &v17);
    if ((*a1 & 0x10) == 0) {
      goto LABEL_34;
    }
LABEL_33:
    CC_SHA512_Final(a1 + 108, &v16);
    goto LABEL_34;
  }
  CC_CKSUM_Final((unsigned int *)a1 + 1, (uint64_t)v20);
  char v14 = *a1;
  if ((*a1 & 2) != 0) {
    goto LABEL_37;
  }
LABEL_30:
  if ((v14 & 4) == 0) {
    goto LABEL_31;
  }
LABEL_38:
  CC_SHA256_Final(a1 + 28, &v18);
  char v14 = *a1;
  if ((*a1 & 8) != 0) {
    goto LABEL_39;
  }
LABEL_32:
  if ((v14 & 0x10) != 0) {
    goto LABEL_33;
  }
LABEL_34:
  uint64_t v10 = 0;
LABEL_35:
  free(v6);
  return v10 >> 63;
}

uint64_t aaEntryHashesInitWithPath(unsigned char *a1, unsigned int a2, char *a3, const char *a4)
{
  char v4 = (char)a4;
  uint64_t v20 = *MEMORY[0x263EF8340];
  if ((concatPath(v19, 0x400uLL, a3, a4) & 0x80000000) != 0)
  {
    char v14 = "invalid path";
    __int16 v15 = 65;
    int v16 = 0;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryHashesInitWithPath", v15, 102, v16, v14, v7, v8, (char)v18);
    return 0xFFFFFFFFLL;
  }
  int v9 = open(v19, 0);
  if (v9 < 0)
  {
    int v16 = *__error();
    CC_SHA256_CTX v18 = v19;
    char v14 = "%s";
    __int16 v15 = 69;
    goto LABEL_7;
  }
  int v10 = v9;
  if ((aaEntryHashesInitWithFD(a1, a2, v9) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryHashesInitWithPath", 71, 102, 0, "computing hashes: %s", v11, v12, v4);
    uint64_t v13 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v13 = 0;
  }
  close(v10);
  return v13;
}

uint64_t aaEntryTypeFromMode(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6) {
    return 0;
  }
  else {
    return dword_214B13070[v1 >> 12];
  }
}

uint64_t aaEntryAttributesInitWithFD(char *a1, unsigned char *a2, unsigned char *a3, unsigned int a4, int a5)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  memset(&v23, 0, sizeof(v23));
  if ((fstat(a5, &v23) & 0x80000000) == 0)
  {
    if (!a1) {
      goto LABEL_15;
    }
    memset_s(a1, 0x48uLL, 0, 0x48uLL);
    char v10 = *a1 & 0x80 | a4 & 0x7F;
    *a1 = v10;
    if (a4)
    {
      *((_DWORD *)a1 + 1) = v23.st_uid;
      if ((a4 & 2) == 0)
      {
LABEL_5:
        if ((a4 & 8) == 0) {
          goto LABEL_6;
        }
        goto LABEL_35;
      }
    }
    else if ((a4 & 2) == 0)
    {
      goto LABEL_5;
    }
    *((_DWORD *)a1 + 2) = v23.st_gid;
    if ((a4 & 8) == 0)
    {
LABEL_6:
      if ((a4 & 4) == 0)
      {
LABEL_8:
        if ((a4 & 0x30) != 0)
        {
          v22[1] = 0;
          v22[2] = 0;
          memset(v24, 0, sizeof(v24));
          v22[0] = 0x220000000005;
          if (!fgetattrlist(a5, v22, v24, 0x40uLL, 1u) && LODWORD(v24[0]) == 36)
          {
            *(_OWORD *)(a1 + 40) = *(_OWORD *)((char *)v24 + 4);
            *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)&v24[1] + 4);
          }
          char v10 = *a1;
        }
        if ((v10 & 0x40) != 0) {
          *(timespec *)(a1 + 56) = v23.st_mtimespec;
        }
LABEL_15:
        if (!a2)
        {
LABEL_28:
          if (!a3 || (v23.st_mode & 0xF000) != 0x8000 || (aaEntryHashesInitWithFD(a3, a4, a5) & 0x80000000) == 0) {
            return 0;
          }
          CC_SHA256_CTX v18 = "computing file digests";
          __int16 v19 = 282;
          goto LABEL_39;
        }
        memset_s(a2, 0x38uLL, 0, 0x38uLL);
        *a2 = (a4 >> 7) & 0xF | *a2 & 0xF0;
        mode_t st_mode = v23.st_mode;
        int v12 = v23.st_mode & 0xF000;
        if (v12 == 0x8000)
        {
          if (((a4 >> 7) & 2) == 0 && ((char)a4 & 0x80000000) == 0) {
            goto LABEL_23;
          }
          *(void *)&v24[0] = 0;
          int v21 = 0;
          LODWORD(v22[0]) = 0;
          if ((ParallelCompressionAFSCGetMetadataFD(a5, (off_t *)v24, (unsigned int *)v22, &v21) & 0x80000000) != 0)
          {
            CC_SHA256_CTX v18 = "querying AFSC metadata";
            __int16 v19 = 269;
LABEL_39:
            int v17 = 0;
            goto LABEL_40;
          }
          int v15 = v21;
          *((_DWORD *)a2 + 2) = v22[0];
          *((_DWORD *)a2 + 3) = v15;
          mode_t st_mode = v23.st_mode;
          int v12 = v23.st_mode & 0xF000;
        }
        if (v12 != 0x8000 && v12 != 0x4000)
        {
LABEL_25:
          if ((st_mode & 0xF000) == 0x8000 && (*a2 & 8) != 0) {
            *((_DWORD *)a2 + 1) = getFileProtectionClassFD(a5);
          }
          goto LABEL_28;
        }
LABEL_23:
        if ((*a2 & 4) != 0)
        {
          *((void *)a2 + 2) = getFileAPFSInternalFlagsFD();
          mode_t st_mode = v23.st_mode;
        }
        goto LABEL_25;
      }
LABEL_7:
      *((_DWORD *)a1 + 3) = v23.st_flags;
      goto LABEL_8;
    }
LABEL_35:
    *((_DWORD *)a1 + 4) = v23.st_mode & 0xFFF;
    if ((a4 & 4) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  int v17 = *__error();
  CC_SHA256_CTX v18 = "fstat";
  __int16 v19 = 209;
LABEL_40:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithFD", v19, 102, v17, v18, v13, v14, v20);
  return 0xFFFFFFFFLL;
}

uint64_t aaEntryAttributesInitWithPath(char *a1, unsigned char *a2, unsigned char *a3, unsigned int a4, char *__s, const char *a6)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  memset(&v30, 0, sizeof(v30));
  if ((concatPath(v32, 0x800uLL, __s, a6) & 0x80000000) != 0)
  {
    int v21 = "invalid path";
    __int16 v22 = 301;
LABEL_36:
    int v23 = 0;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithPath", v22, 102, v23, v21, v10, v11, (char)v27);
    return 0xFFFFFFFFLL;
  }
  if (lstat(v32, &v30) < 0)
  {
    int v23 = *__error();
    uint64_t v27 = v32;
    int v21 = "lstat: %s";
    __int16 v22 = 302;
    goto LABEL_38;
  }
  if (a1)
  {
    memset_s(a1, 0x48uLL, 0, 0x48uLL);
    char v12 = *a1 & 0x80 | a4 & 0x7F;
    *a1 = v12;
    if (a4)
    {
      *((_DWORD *)a1 + 1) = v30.st_uid;
      if ((a4 & 2) == 0)
      {
LABEL_6:
        if ((a4 & 8) == 0) {
          goto LABEL_7;
        }
        goto LABEL_42;
      }
    }
    else if ((a4 & 2) == 0)
    {
      goto LABEL_6;
    }
    *((_DWORD *)a1 + 2) = v30.st_gid;
    if ((a4 & 8) == 0)
    {
LABEL_7:
      if ((a4 & 4) == 0)
      {
LABEL_9:
        if ((a4 & 0x30) != 0)
        {
          v29[1] = 0;
          v29[2] = 0;
          memset(v31, 0, sizeof(v31));
          v29[0] = 0x220000000005;
          if (!getattrlist(v32, v29, v31, 0x40uLL, 1u) && LODWORD(v31[0]) == 36)
          {
            *(_OWORD *)(a1 + 40) = *(_OWORD *)((char *)v31 + 4);
            *(_OWORD *)(a1 + 24) = *(_OWORD *)((char *)&v31[1] + 4);
          }
          char v12 = *a1;
        }
        if ((v12 & 0x40) != 0) {
          *(timespec *)(a1 + 56) = v30.st_mtimespec;
        }
        goto LABEL_16;
      }
LABEL_8:
      *((_DWORD *)a1 + 3) = v30.st_flags;
      goto LABEL_9;
    }
LABEL_42:
    *((_DWORD *)a1 + 4) = v30.st_mode & 0xFFF;
    if ((a4 & 4) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_16:
  if (!a2) {
    goto LABEL_29;
  }
  memset_s(a2, 0x38uLL, 0, 0x38uLL);
  *a2 = (a4 >> 7) & 0xF | *a2 & 0xF0;
  mode_t st_mode = v30.st_mode;
  int v14 = v30.st_mode & 0xF000;
  if (v14 == 0x8000)
  {
    if (((a4 >> 7) & 2) == 0 && ((char)a4 & 0x80000000) == 0)
    {
LABEL_24:
      if ((*a2 & 4) != 0)
      {
        *((void *)a2 + 2) = getFileAPFSInternalFlagsFD();
        mode_t st_mode = v30.st_mode;
      }
      goto LABEL_26;
    }
    *(void *)&v31[0] = 0;
    int v28 = 0;
    LODWORD(v29[0]) = 0;
    if ((ParallelCompressionAFSCGetMetadata(v32, (off_t *)v31, (unsigned int *)v29, &v28) & 0x80000000) == 0)
    {
      int v15 = v28;
      *((_DWORD *)a2 + 2) = v29[0];
      *((_DWORD *)a2 + 3) = v15;
      mode_t st_mode = v30.st_mode;
      int v14 = v30.st_mode & 0xF000;
      goto LABEL_22;
    }
    uint64_t v27 = v32;
    int v21 = "querying AFSC metadata: %s";
    __int16 v22 = 362;
    goto LABEL_36;
  }
LABEL_22:
  if (v14 == 0x8000 || v14 == 0x4000) {
    goto LABEL_24;
  }
LABEL_26:
  if ((st_mode & 0xF000) == 0x8000 && (*a2 & 8) != 0) {
    *((_DWORD *)a2 + 1) = getFileProtectionClass(v32);
  }
LABEL_29:
  if (!a3 || (v30.st_mode & 0xF000) != 0x8000) {
    return 0;
  }
  int v16 = open(v32, 0);
  if (v16 < 0)
  {
    int v24 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithPath", 376, 102, v24, "open: %s", v25, v26, (char)v32);
  }
  else
  {
    int v17 = v16;
    if ((aaEntryHashesInitWithFD(a3, a4, v16) & 0x80000000) == 0)
    {
      close(v17);
      return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesInitWithPath", 377, 102, 0, "computing file digests: %s", v18, v19, (char)v32);
    close(v17);
  }
  return 0xFFFFFFFFLL;
}

uint64_t aaEntryAttributesApplyToPath(char *a1, char *__s, const char *a3, char a4)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  if ((concatPath(v63, 0x800uLL, __s, a3) & 0x80000000) != 0)
  {
    uint64_t v11 = "invalid path";
    __int16 v12 = 391;
    int v13 = 0;
LABEL_33:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", v12, 102, v13, v11, v6, v7, (char)v59);
    return 0xFFFFFFFFLL;
  }
  v61[1] = 0;
  v61[2] = 0;
  v61[0] = 5;
  memset(v62, 0, sizeof(v62));
  char v8 = *a1;
  if ((*a1 & 0x20) != 0)
  {
    v62[0] = *(_OWORD *)(a1 + 40);
    int v9 = 512;
    HIDWORD(v61[0]) = 512;
    unsigned int v10 = 16;
    if ((v8 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  int v9 = 0;
  unsigned int v10 = 0;
  if ((*a1 & 0x40) != 0)
  {
LABEL_7:
    long long v14 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)((char *)v62 + v10) = v14;
    *(_OWORD *)((char *)&v62[1] + v10) = v14;
    v10 |= 0x20u;
    v9 |= 0x1400u;
    HIDWORD(v61[0]) = v9;
  }
LABEL_8:
  if ((v8 & 0x10) == 0)
  {
    if ((v8 & 1) == 0) {
      goto LABEL_10;
    }
LABEL_13:
    uid_t v15 = *((_DWORD *)a1 + 1);
    if ((v8 & 2) != 0) {
      goto LABEL_11;
    }
    goto LABEL_14;
  }
  *(_OWORD *)((char *)v62 + v10) = *(_OWORD *)(a1 + 24);
  v10 += 16;
  HIDWORD(v61[0]) = v9 | 0x2000;
  if (v8) {
    goto LABEL_13;
  }
LABEL_10:
  uid_t v15 = -1;
  if ((v8 & 2) != 0)
  {
LABEL_11:
    gid_t v16 = *((_DWORD *)a1 + 2);
    goto LABEL_15;
  }
LABEL_14:
  gid_t v16 = -1;
LABEL_15:
  memset(&v60, 0, sizeof(v60));
  if (lstat(v63, &v60) < 0)
  {
    __int16 v22 = __error();
    if ((a4 & 1) != 0 && *v22 == 13) {
      return 0;
    }
    int v13 = *__error();
    unint64_t v59 = v63;
    uint64_t v11 = "%s";
    __int16 v12 = 443;
    goto LABEL_33;
  }
  int v17 = v60.st_mode & 0xF000;
  if (v17 != 0x4000 && v17 != 40960 && v17 != 0x8000)
  {
    if ((*a1 & 1) != 0 && v15 != v60.st_uid || (int v20 = 1, (*a1 & 2) != 0) && v16 != v60.st_gid)
    {
      if (!lchown(v63, v15, v16) || (int v24 = __error(), (a4 & 1) != 0) && *v24 == 1)
      {
        int v20 = 1;
      }
      else
      {
        uint64_t v42 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 494, 102, *v42, "%s", v43, v44, (char)v63);
        int v20 = 0;
      }
    }
    if ((*a1 & 8) != 0)
    {
      int v45 = *((_DWORD *)a1 + 4) & 0xFFF;
      if (v45 != (v60.st_mode & 0xFFF))
      {
        if (lchmod(v63, v45))
        {
          uint64_t v46 = __error();
          if ((a4 & 1) == 0 || *v46 != 1)
          {
            int v47 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 499, 102, *v47, "%s", v48, v49, (char)v63);
            int v20 = 0;
          }
        }
      }
    }
    if (HIDWORD(v61[0]))
    {
      if (setattrlist(v63, v61, v62, v10, 1u))
      {
        int v50 = __error();
        if ((a4 & 1) == 0 || *v50 != 1)
        {
          unint64_t v51 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 512, 102, *v51, "%s", v52, v53, (char)v63);
          int v20 = 0;
        }
      }
    }
    if ((*a1 & 4) != 0)
    {
      __uint32_t v54 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v60.st_flags >> 5) & 1));
      if (v60.st_flags != v54)
      {
        if (lchflags(v63, v54))
        {
          uint64_t v55 = __error();
          if ((a4 & 1) == 0 || *v55 != 1)
          {
            char v56 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 526, 102, *v56, "%s", v57, v58, (char)v63);
            int v20 = 0;
          }
        }
      }
    }
    goto LABEL_61;
  }
  int v18 = open(v63, 0x200000);
  if (v18 < 0)
  {
    int v13 = *__error();
    unint64_t v59 = v63;
    uint64_t v11 = "%s";
    __int16 v12 = 456;
    goto LABEL_33;
  }
  int v19 = v18;
  if ((*a1 & 1) != 0 && v15 != v60.st_uid || (int v20 = 1, (*a1 & 2) != 0) && v16 != v60.st_gid)
  {
    if (!fchown(v18, v15, v16) || (int v21 = __error(), (a4 & 1) != 0) && *v21 == 1)
    {
      int v20 = 1;
    }
    else
    {
      uint64_t v25 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 460, 102, *v25, "%s", v26, v27, (char)v63);
      int v20 = 0;
    }
  }
  if ((*a1 & 8) != 0)
  {
    int v28 = *((_DWORD *)a1 + 4) & 0xFFF;
    if (v28 != (v60.st_mode & 0xFFF))
    {
      if (fchmod(v19, v28))
      {
        uint64_t v29 = __error();
        if ((a4 & 1) == 0 || *v29 != 1)
        {
          stat v30 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 464, 102, *v30, "%s", v31, v32, (char)v63);
          int v20 = 0;
        }
      }
    }
  }
  if (HIDWORD(v61[0]))
  {
    if (fsetattrlist(v19, v61, v62, v10, 1u))
    {
      uint64_t v33 = __error();
      if ((a4 & 1) == 0 || *v33 != 1)
      {
        int v34 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 469, 102, *v34, "%s", v35, v36, (char)v63);
        int v20 = 0;
      }
    }
  }
  if ((*a1 & 4) != 0)
  {
    __uint32_t v37 = *((_DWORD *)a1 + 3) & 0xFFFFFFDF | (32 * ((v60.st_flags >> 5) & 1));
    if (v60.st_flags != v37)
    {
      if (fchflags(v19, v37))
      {
        uint64_t v38 = __error();
        if ((a4 & 1) == 0 || *v38 != 1)
        {
          uint64_t v39 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaEntryAttributesApplyToPath", 483, 102, *v39, "%s", v40, v41, (char)v63);
          int v20 = 0;
        }
      }
    }
  }
  close(v19);
LABEL_61:
  if (v20) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aaEntryAttributesCmp(uint64_t a1, uint64_t a2, char a3)
{
  if (a3 & 1) != 0 && (*(unsigned char *)a1)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4);
    if ((a3 & 2) == 0) {
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v3 = 0;
    if ((a3 & 2) == 0) {
      goto LABEL_9;
    }
  }
  if ((*(unsigned char *)a1 & 2) != 0 && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    v3 |= 2u;
  }
LABEL_9:
  if ((a3 & 8) != 0 && (*(unsigned char *)a1 & 8) != 0 && *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    v3 |= 8u;
  }
  if ((a3 & 4) != 0 && (*(unsigned char *)a1 & 4) != 0 && *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)) {
    v3 |= 4u;
  }
  if ((a3 & 0x40) != 0 && (*(unsigned char *)a1 & 0x40) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 56) - *(void *)(a2 + 56);
    if ((unint64_t)(v4 - 2) < 0xFFFFFFFFFFFFFFFDLL
      || (unint64_t)(*(void *)(a1 + 64) + 1000000000 * v4 - *(void *)(a2 + 64) + 2000) >= 0xFA1)
    {
      v3 |= 0x40u;
    }
  }
  if ((a3 & 0x10) != 0 && (*(unsigned char *)a1 & 0x10) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 24) - *(void *)(a2 + 24);
    if ((unint64_t)(v5 - 2) < 0xFFFFFFFFFFFFFFFDLL
      || (unint64_t)(*(void *)(a1 + 32) + 1000000000 * v5 - *(void *)(a2 + 32) + 2000) >= 0xFA1)
    {
      v3 |= 0x10u;
    }
  }
  if ((a3 & 0x20) != 0 && (*(unsigned char *)a1 & 0x20) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 40) - *(void *)(a2 + 40);
    if ((unint64_t)(v6 - 2) < 0xFFFFFFFFFFFFFFFDLL
      || (unint64_t)(*(void *)(a1 + 48) + 1000000000 * v6 - *(void *)(a2 + 48) + 2000) >= 0xFA1)
    {
      v3 |= 0x20u;
    }
  }
  return v3;
}

uint64_t aaEntryInternalAttributesCmp(uint64_t a1, uint64_t a2, __int16 a3)
{
  if ((a3 & 0x100) != 0 && (*(unsigned char *)a1 & 2) != 0)
  {
    unsigned int v3 = (*(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)) << 8;
    if ((a3 & 0x80) == 0) {
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v3 = 0;
    if ((a3 & 0x80) == 0) {
      goto LABEL_9;
    }
  }
  if ((*(unsigned char *)a1 & 1) != 0 && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    v3 |= 0x80u;
  }
LABEL_9:
  if ((a3 & 0x200) != 0 && (*(unsigned char *)a1 & 4) != 0 && *(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    v3 |= 0x200u;
  }
  if ((a3 & 0x400) != 0 && (*(unsigned char *)a1 & 8) != 0 && *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4)) {
    v3 |= 0x400u;
  }
  return v3;
}

uint64_t aaEntryHashesCmp(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (a3 & 0x800) != 0 && (*(unsigned char *)a1)
  {
    unsigned int v6 = (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4)) << 11;
    if ((a3 & 0x1000) == 0) {
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v6 = 0;
    if ((a3 & 0x1000) == 0) {
      goto LABEL_9;
    }
  }
  if ((*(unsigned char *)a1 & 2) != 0
    && *(void *)(a1 + 8) ^ *(void *)(a2 + 8) | *(void *)(a1 + 16) ^ *(void *)(a2 + 16) | (*(_DWORD *)(a1 + 24) ^ *(_DWORD *)(a2 + 24)))
  {
    v6 |= 0x1000u;
  }
LABEL_9:
  if ((a3 & 0x2000) != 0
    && (*(unsigned char *)a1 & 4) != 0
    && *(void *)(a1 + 28) ^ *(void *)(a2 + 28) | *(void *)(a1 + 36) ^ *(void *)(a2 + 36) | *(void *)(a1 + 44) ^ *(void *)(a2 + 44) | *(void *)(a1 + 52) ^ *(void *)(a2 + 52))
  {
    v6 |= 0x2000u;
  }
  if ((a3 & 0x4000) != 0
    && (*(unsigned char *)a1 & 8) != 0
    && memcmp((const void *)(a1 + 60), (const void *)(a2 + 60), 0x30uLL))
  {
    v6 |= 0x4000u;
  }
  if (a3 < 0 && (*(unsigned char *)a1 & 0x10) != 0 && memcmp((const void *)(a1 + 108), (const void *)(a2 + 108), 0x40uLL)) {
    v6 |= 0x8000u;
  }
  return v6;
}

uint64_t AAThreadErrorContextLeave(unint64_t a1)
{
  return ParallelCompressionLeaveThreadErrorContext(0, 0, HIWORD(a1) & 1);
}

uint64_t aaCheckAndFixWithPath(char *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, unsigned int *a6, char *__s, const char *a8, uint64_t a9)
{
  uint64_t v110 = *MEMORY[0x263EF8340];
  uint64_t v107 = 0;
  memset(v106, 0, sizeof(v106));
  uint64_t v105 = 0;
  memset(v104, 0, sizeof(v104));
  memset(v109, 0, 172);
  if ((concatPath((char *)v108, 0x800uLL, __s, a8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 773, 102, 0, "invalid path: %s", v17, v18, (char)a8);
    unsigned int v25 = 0;
    uint64_t v70 = 0;
    uint64_t v35 = 0;
    uint64_t v73 = 0xFFFFFFFFLL;
    goto LABEL_101;
  }
  size_t v91 = a6;
  uint64_t v98 = (uint64_t)a1;
  char v19 = *a1;
  int v96 = a2;
  unsigned int v20 = *a2;
  unint64_t v93 = a3;
  unsigned int v21 = *a3;
  unsigned int v22 = *a4;
  AAEntryXATBlob v23 = AAEntryXATBlobCreate();
  AAEntryACLBlob v24 = AAEntryACLBlobCreate();
  uint64_t v95 = v23;
  if (!v23 || !v24)
  {
    uint64_t v70 = v24;
    int v74 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 800, 102, *v74, "malloc", v75, v76, v90);
    unsigned int v25 = 0;
    uint64_t v73 = 0xFFFFFFFFLL;
    a6 = v91;
    uint64_t v35 = v95;
    goto LABEL_101;
  }
  acl = v24;
  unsigned int v25 = 0;
  uint32x4_t v26 = vmovl_u16((uint16x4_t)(*(void *)&vshl_u16((uint16x4_t)vdup_n_s16(v21), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01));
  v27.i64[0] = v26.u32[0];
  v27.i64[1] = v26.u32[1];
  v28.i64[0] = 255;
  v28.i64[1] = 255;
  uint64x2_t v29 = (uint64x2_t)vandq_s8(v27, v28);
  v27.i64[0] = v26.u32[2];
  v27.i64[1] = v26.u32[3];
  int8x16_t v30 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)xmmword_214B13060), (int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v27, v28), (uint64x2_t)xmmword_214B13050));
  unint64_t v31 = (*(void *)&vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL)) | ((unint64_t)(v21 & 1) << 11) | ((unint64_t)((v20 >> 2) & 1) << 9) | ((unint64_t)((v20 >> 1) & 1) << 8) | ((unint64_t)(v22 & 1) << 16) | ((unint64_t)((v20 >> 3) & 1) << 10) | ((unint64_t)((v22 >> 2) & 1) << 18) | ((unint64_t)((v22 >> 1) & 1) << 17) | a5 & 0x80000 | v19 & 0x7F | ((unint64_t)(v20 & 1) << 7)) & a5;
  if (v31 >= 0x80000) {
    unsigned int v32 = v31;
  }
  else {
    unsigned int v32 = v31 & 0xFFFE07FF;
  }
  uint64_t flags = a9 | 8;
  int v33 = 1;
  uint64_t v35 = v95;
  uint64_t v34 = (uint64_t)v96;
  uint64_t v36 = (uint64_t)v93;
  if ((v32 & 0x20000) != 0)
  {
LABEL_8:
    if ((aaEntryXATBlobInitWithPath(v35, __s, a8) & 0x80000000) == 0) {
      goto LABEL_9;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 805, 102, 0, "loading file XAT: %s", v37, v38, (char)a8);
    goto LABEL_99;
  }
  while (1)
  {
LABEL_9:
    if ((v32 & 0x40000) != 0 && (aaEntryACLBlobInitWithPath(acl, __s, a8, a9) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 806, 102, 0, "loading file ACL: %s", v39, v40, (char)a8);
      goto LABEL_99;
    }
    if ((aaEntryAttributesInitWithPath(v106, v104, v109, v32, __s, a8) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 807, 102, 0, "loading file attributes: %s", v41, v42, (char)a8);
      goto LABEL_99;
    }
    uint64_t v94 = aaEntryAttributesCmp((uint64_t)v106, v98, v32);
    int v43 = aaEntryInternalAttributesCmp((uint64_t)v104, v34, v32) | v94;
    unsigned int v25 = aaEntryHashesCmp((uint64_t)v109, v36, v32) ? v43 | 0x80000 : v43;
    if ((v32 & 0x20000) != 0)
    {
      if (*((void *)a4 + 4))
      {
        if (AAEntryXATBlobGetEncodedSize(v35) == *((void *)a4 + 4)
          && (EncodedData = AAEntryXATBlobGetEncodedData(v35),
              !memcmp(EncodedData, *((const void **)a4 + 3), *((void *)a4 + 4))))
        {
          int v50 = 0;
        }
        else
        {
          int v50 = 0x20000;
        }
        unsigned int v25 = v50 | v25 & 0xFFFDFFFF;
        if ((v32 & 0x40000) == 0)
        {
LABEL_17:
          if ((v32 & 0x10000) == 0) {
            goto LABEL_37;
          }
          goto LABEL_33;
        }
      }
      else
      {
        unsigned int v25 = v25 & 0xFFFDFFFF | ((AAEntryXATBlobGetEntryCount(v35) != 0) << 17);
        if ((v32 & 0x40000) == 0) {
          goto LABEL_17;
        }
      }
    }
    else if ((v32 & 0x40000) == 0)
    {
      goto LABEL_17;
    }
    if (*((void *)a4 + 6))
    {
      if (AAEntryACLBlobGetEncodedSize(acl) == *((void *)a4 + 6)
        && (unint64_t v51 = AAEntryACLBlobGetEncodedData(acl), !memcmp(v51, *((const void **)a4 + 5), *((void *)a4 + 6))))
      {
        int v52 = 0;
      }
      else
      {
        int v52 = 0x40000;
      }
      unsigned int v25 = v52 | v25 & 0xFFFBFFFF;
      if ((v32 & 0x10000) == 0) {
        goto LABEL_37;
      }
    }
    else
    {
      unsigned int v25 = v25 & 0xFFFBFFFF | ((AAEntryACLBlobGetEntryCount(acl) != 0) << 18);
      if ((v32 & 0x10000) == 0) {
        goto LABEL_37;
      }
    }
LABEL_33:
    memset(&v103, 0, sizeof(v103));
    int v53 = open((const char *)v108, 0);
    if (v53 < 0)
    {
      int v77 = *__error();
      __int16 v80 = 830;
LABEL_90:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", v80, 102, v77, "open: %s", v78, v79, (char)v108);
      goto LABEL_98;
    }
    int v54 = v53;
    if (fstat(v53, &v103) < 0)
    {
      int v81 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 831, 102, v81, "fstat: %s", v82, v83, (char)v108);
      goto LABEL_97;
    }
    int v58 = ParallelArchiveECCVerifyFileSegment(v54, 0, v103.st_size, *((long long **)a4 + 1), *((void *)a4 + 2), v55, v56, v57);
    close(v54);
    if (v58 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 834, 102, 0, "verifying data: %s", v47, v48, (char)v108);
      goto LABEL_98;
    }
    uint64_t v35 = v95;
    if (!v58)
    {
      v25 |= 0x80000u;
      goto LABEL_38;
    }
LABEL_37:
    if (!v25) {
      goto LABEL_81;
    }
LABEL_38:
    BOOL v60 = (a9 & 0x20000000000000) == 0 && v33 == 1;
    if (!v33 || v60)
    {
LABEL_81:
      uint64_t v73 = 0;
      goto LABEL_100;
    }
    uint64_t v34 = (uint64_t)v96;
    if ((v32 & 0x10000) != 0 && (v25 & 0x80000) != 0) {
      break;
    }
LABEL_54:
    if ((v25 & 0x184) != 0)
    {
      if ((*(unsigned char *)v98 & 4) != 0) {
        unsigned int v68 = ((*(_DWORD *)(v98 + 12) >> 5) & 1) - 1;
      }
      else {
        unsigned int v68 = -1;
      }
      if (*(unsigned char *)v34) {
        unsigned int v68 = *(_DWORD *)(v34 + 8);
      }
      if ((*(unsigned char *)v34 & 2) != 0) {
        unsigned int v69 = *(_DWORD *)(v34 + 12);
      }
      else {
        unsigned int v69 = 0;
      }
      ParallelCompressionAFSCFixupMetadata(v108, v68, v69);
    }
    if ((v25 & 0x200) != 0) {
      setFileAPFSInternalFlags((uint64_t)v108, *(void *)(v34 + 16));
    }
    if ((v25 & 0x20000) != 0)
    {
      if ((aaEntryXATBlobInitWithEncodedData((unint64_t *)v35, *((char **)a4 + 3), *((void *)a4 + 4), v44, v45, v46, v47, v48) & 0x80000000) != 0)
      {
        uint64_t v84 = "invalid XAT blob in manifest";
        __int16 v85 = 894;
        goto LABEL_93;
      }
      AAEntryXATBlobApplyToPath(v35, __s, a8, flags);
    }
    if ((v25 & 0x40000) != 0)
    {
      uint64_t v70 = acl;
      if ((aaEntryACLBlobInitWithEncodedData(acl, *((char **)a4 + 5), *((void *)a4 + 6), v44, v45, v46, v47, v48) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 901, 102, 0, "invalid ACL blob in manifest", v71, v72, v90);
        uint64_t v73 = 0xFFFFFFFFLL;
        a6 = v91;
        goto LABEL_101;
      }
      AAEntryACLBlobApplyToPath(acl, __s, a8, flags);
      uint64_t v36 = (uint64_t)v93;
    }
    if (v94) {
      aaEntryAttributesApplyToPath((char *)v98, __s, a8, a9);
    }
    --v33;
    if ((v32 & 0x20000) != 0) {
      goto LABEL_8;
    }
  }
  off_t v102 = 0;
  unsigned int v100 = 0;
  unsigned int v101 = -1;
  if ((ParallelCompressionAFSCGetMetadata((const char *)v108, &v102, &v101, &v100) & 0x80000000) != 0)
  {
    uint64_t v84 = "get AFSC attributes";
    __int16 v85 = 853;
LABEL_93:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", v85, 102, 0, v84, v61, v62, v90);
    goto LABEL_99;
  }
  memset(&v103, 0, sizeof(v103));
  int v63 = open((const char *)v108, 2);
  if (v63 < 0)
  {
    int v77 = *__error();
    __int16 v80 = 858;
    goto LABEL_90;
  }
  int v54 = v63;
  if ((fstat(v63, &v103) & 0x80000000) == 0)
  {
    memset(v99, 0, sizeof(v99));
    int v64 = ParallelArchiveECCFixFileSegment(v54, 0, v103.st_size, *((long long **)a4 + 1), *((void *)a4 + 2), (uint64_t)v99);
    close(v54);
    if (v64 >= 1) {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 863, 102, "Fixed data using ECC: %s", v65, v66, v67, (char)a8);
    }
    ParallelCompressionAFSCFixupMetadata(v108, v101, v100);
    uint64_t v35 = v95;
    uint64_t v34 = (uint64_t)v96;
    goto LABEL_54;
  }
  int v86 = *__error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCheckAndFixWithPath", 859, 102, v86, "fstat: %s", v87, v88, (char)v108);
LABEL_97:
  close(v54);
LABEL_98:
  uint64_t v35 = v95;
LABEL_99:
  uint64_t v73 = 0xFFFFFFFFLL;
LABEL_100:
  a6 = v91;
  uint64_t v70 = acl;
LABEL_101:
  *a6 = v25;
  a6[1] = 0;
  AAEntryXATBlobDestroy(v35);
  AAEntryACLBlobDestroy(v70);
  return v73;
}

uint64_t aaCopyFile(const char *a1, const char *a2, char a3)
{
  uint64_t v69 = 0;
  memset(v68, 0, sizeof(v68));
  uint64_t v67 = 0;
  long long v65 = 0u;
  long long v66 = 0u;
  *(_OWORD *)int v64 = 0u;
  memset(&v63, 0, sizeof(v63));
  int v6 = open(a1, 0);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (fstat(v6, &v63) < 0)
    {
      int v33 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 940, 102, v33, "stat: %s", v34, v35, (char)a1);
    }
    else if ((v63.st_mode & 0xF000) == 0x8000)
    {
      if ((aaEntryAttributesInitWithFD((char *)v68, v64, 0, 0xFFFFFFFF, v7) & 0x80000000) == 0)
      {
        __int16 v12 = AAEntryXATBlobCreate();
        uid_t v15 = v12;
        if (v12 && (aaEntryXATBlobInitWithFD(v12, v7) & 0x80000000) == 0)
        {
          gid_t v16 = AAEntryACLBlobCreate();
          char v19 = (unint64_t *)v16;
          if (!v16 || (aaEntryACLBlobInitWithFD(v16, v7, 0) & 0x80000000) != 0)
          {
            uint64_t v38 = "get ACL";
            __int16 v39 = 946;
            int v40 = 0;
          }
          else if (clonefile(a1, a2, 0))
          {
            if ((v64[0] & 8) != 0
              && v64[1] >= 1
              && (v62 = -92, uint64_t v20 = open_dprotected_np(a2, 1537, v64[1], 0), (v20 & 0x80000000) == 0)
              || (uint64_t v20 = open(a2, 1537, 420), (v20 & 0x80000000) == 0))
            {
              if (v63.st_size)
              {
                unsigned int v21 = malloc(0x40000uLL);
                if (!v21)
                {
                  unsigned int v22 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 972, 102, *v22, "malloc", v23, v24, v62);
                }
                if (statIsCompressed(v63.st_flags))
                {
                  unint64_t v25 = fgetxattr(v7, "com.apple.decmpfs", v21, 0x40000uLL, 0, 32);
                  if ((v25 & 0x8000000000000000) != 0)
                  {
                    int8x16_t v28 = "Missing decmpfs xattr";
                    __int16 v29 = 980;
                    goto LABEL_64;
                  }
                  if (v25 > 0x40000)
                  {
                    int8x16_t v28 = "invalid decmpfs xattr size";
                    __int16 v29 = 981;
LABEL_64:
                    int v55 = 0;
LABEL_65:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", v29, 102, v55, v28, v26, v27, v62);
                    close(v7);
                    close(v20);
LABEL_66:
                    unlink(a2);
                    goto LABEL_29;
                  }
                  if (fsetxattr(v20, "com.apple.decmpfs", v21, v25, 0, 0) < 0)
                  {
                    int v55 = *__error();
                    int8x16_t v28 = "fsetxattr decmpfs";
                    __int16 v29 = 982;
                    goto LABEL_65;
                  }
                  ssize_t v56 = fgetxattr(v7, "com.apple.ResourceFork", 0, 0, 0, 32);
                  if (v56 >= 1)
                  {
                    unint64_t v57 = v56;
                    unint64_t v58 = 0;
                    while (1)
                    {
                      if (v57 - v58 >= 0x40000) {
                        size_t v59 = 0x40000;
                      }
                      else {
                        size_t v59 = v57 - v58;
                      }
                      ssize_t v60 = fgetxattr(v7, "com.apple.ResourceFork", v21, v59, v58, 32);
                      if (v60 < 0)
                      {
                        uint64_t v48 = "read resource fork";
                        __int16 v49 = 992;
                        goto LABEL_46;
                      }
                      if (v60 != v59)
                      {
                        uint64_t v48 = "truncated read resource fork";
                        __int16 v49 = 993;
                        goto LABEL_46;
                      }
                      if (fsetxattr(v20, "com.apple.ResourceFork", v21, v59, v58, 0) < 0) {
                        break;
                      }
                      v58 += v59;
                      if (v58 >= v57) {
                        goto LABEL_77;
                      }
                    }
                    int v50 = *__error();
                    uint64_t v48 = "write resource fork";
                    __int16 v49 = 994;
                    goto LABEL_47;
                  }
LABEL_77:
                  if (fchflags(v20, 0x20u) < 0)
                  {
                    uint64_t v48 = "set UF_COMPRESSED";
                    __int16 v49 = 1000;
                    goto LABEL_46;
                  }
                }
                else
                {
                  st_timespec size = v63.st_size;
                  if (v63.st_size >= 1)
                  {
                    while (1)
                    {
                      if ((unint64_t)st_size >= 0x40000) {
                        size_t v52 = 0x40000;
                      }
                      else {
                        size_t v52 = st_size;
                      }
                      ssize_t v53 = read(v7, v21, v52);
                      if (v53 < 0)
                      {
                        int v50 = *__error();
                        uint64_t v48 = "read";
                        __int16 v49 = 1026;
                        goto LABEL_47;
                      }
                      if (v53 != v52)
                      {
                        uint64_t v48 = "truncated read";
                        __int16 v49 = 1027;
                        goto LABEL_46;
                      }
                      ssize_t v54 = write(v20, v21, v52);
                      if (v54 < 0)
                      {
                        int v50 = *__error();
                        uint64_t v48 = "write";
                        __int16 v49 = 1029;
                        goto LABEL_47;
                      }
                      if (v54 != v52) {
                        break;
                      }
                      st_size -= v52;
                      if (st_size < 1) {
                        goto LABEL_38;
                      }
                    }
                    uint64_t v48 = "truncated write";
                    __int16 v49 = 1030;
                    goto LABEL_46;
                  }
                }
LABEL_38:
                if ((aaEntryAttributesApplyToFD((char *)v68, v20, a3) & 0x80000000) == 0
                  && (aaEntryXATBlobApplyToFD(v15, v20, a3, v42, v43, v44, v45, v46) & 0x80000000) == 0
                  && (aaEntryACLBlobApplyToFD(v19, v20, a3) & 0x80000000) == 0)
                {
                  int v47 = 0;
                  int v36 = 1;
                  if ((v64[0] & 4) != 0 && (void)v65)
                  {
                    if ((setFileAPFSInternalFlags(v20, v65) & 0x80000000) != 0)
                    {
                      uint64_t v48 = "setting internal attributes";
                      __int16 v49 = 1047;
                      goto LABEL_46;
                    }
                    int v47 = 0;
                  }
LABEL_48:
                  close(v7);
                  if ((v20 & 0x80000000) != 0) {
                    goto LABEL_30;
                  }
                  close(v20);
                  if (!v47) {
                    goto LABEL_30;
                  }
                  goto LABEL_66;
                }
                uint64_t v48 = "setting attributes";
                __int16 v49 = 1042;
LABEL_46:
                int v50 = 0;
LABEL_47:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", v49, 102, v50, v48, v45, v46, v62);
                int v36 = 0;
                int v47 = 1;
                goto LABEL_48;
              }
LABEL_37:
              unsigned int v21 = 0;
              goto LABEL_38;
            }
            int v40 = *__error();
            char v61 = (char)a2;
            uint64_t v38 = "open: %s";
            __int16 v39 = 964;
          }
          else
          {
            char v62 = -92;
            uint64_t v41 = open(a2, 0);
            if ((v41 & 0x80000000) == 0)
            {
              uint64_t v20 = v41;
              goto LABEL_37;
            }
            int v40 = *__error();
            char v61 = (char)a2;
            uint64_t v38 = "open: %s";
            __int16 v39 = 953;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", v39, 102, v40, v38, v17, v18, v61);
          goto LABEL_28;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 944, 102, 0, "get XAT", v13, v14, v61);
LABEL_27:
        char v19 = 0;
LABEL_28:
        close(v7);
        unsigned int v21 = 0;
        goto LABEL_29;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 942, 102, 0, "get attributes", v10, v11, v61);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 941, 102, 0, "not a regular file: %s", v8, v9, (char)a1);
    }
    uid_t v15 = 0;
    goto LABEL_27;
  }
  int8x16_t v30 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAUtils.c", (uint64_t)"aaCopyFile", 939, 102, *v30, "open: %s", v31, v32, (char)a1);
  unsigned int v21 = 0;
  char v19 = 0;
  uid_t v15 = 0;
LABEL_29:
  int v36 = 0;
LABEL_30:
  AAEntryXATBlobDestroy(v15);
  AAEntryACLBlobDestroy((AAEntryACLBlob)v19);
  free(v21);
  if (v36) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t AARandomAccessDecodeAndExtract(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, unint64_t a6, int DefaultNThreads)
{
  uint64_t v253 = *MEMORY[0x263EF8340];
  memset(&v252, 0, sizeof(v252));
  uint64_t v14 = malloc(0x520uLL);
  if (!v14)
  {
    __int16 v39 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreate", 812, 120, *v39, "malloc", v40, v41, v247);
    goto LABEL_28;
  }
  uint64_t v15 = (uint64_t)v14;
  memset_s(v14, 0x520uLL, 0, 0x520uLL);
  *(void *)uint64_t v15 = a1;
  *(void *)(v15 + 8) = a2;
  if (!realpath_DARWIN_EXTSN(a3, (char *)(v15 + 16))
    || lstat((const char *)(v15 + 16), &v252) < 0
    || (v252.st_mode & 0xF000) != 0x4000)
  {
    int v34 = *__error();
    char v247 = (char)a3;
    uint64_t v35 = "invalid directory: %s";
    __int16 v36 = 819;
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreate", v36, 120, v34, v35, v22, v23, v247);
    stateDestroy(v15);
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"AARandomAccessDecodeAndExtract", 1352, 120, 0, "creating state", v37, v38, v248);
    uint64_t v15 = 0;
    goto LABEL_29;
  }
  *(void *)(v15 + 1056) = a6;
  *(void *)(v15 + 1040) = a4;
  *(void *)(v15 + 1048) = a5;
  *(_DWORD *)(v15 + 1080) = a6 >> 62;
  if (!DefaultNThreads) {
    int DefaultNThreads = getDefaultNThreads();
  }
  *(_DWORD *)(v15 + 1152) = DefaultNThreads;
  *(_DWORD *)(v15 + 1064) = isDirEmpty((const char *)(v15 + 16)) == 0;
  *(void *)(v15 + 1068) = (a6 >> 54) & 1;
  uint64_t VolumeCapabilities = getVolumeCapabilities((const char *)(v15 + 16));
  uint64_t v17 = VolumeCapabilities & ~(VolumeCapabilities >> 63);
  uint64_t v18 = 268;
  if ((v17 & 8) == 0) {
    uint64_t v18 = 264;
  }
  unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFDFLL | (32 * (v17 & 1));
  if ((a6 & 0x20) == 0 && (v17 & 2) != 0) {
    uint64_t v20 = v19 | 0x40;
  }
  else {
    uint64_t v20 = v19;
  }
  *(void *)(v15 + 1088) = v20;
  unsigned int v21 = StringTableCreate();
  *(void *)(v15 + 1096) = v21;
  if (!v21)
  {
    uint64_t v35 = "string table creation";
    __int16 v36 = 842;
    goto LABEL_49;
  }
  uint64_t v24 = calloc(*(unsigned int *)(v15 + 1152), 8uLL);
  *(void *)(v15 + 1160) = v24;
  if (!v24)
  {
    int v34 = *__error();
    uint64_t v35 = "malloc";
    __int16 v36 = 845;
    goto LABEL_26;
  }
  if (*(_DWORD *)(v15 + 1152))
  {
    unint64_t v25 = 0;
    while (1)
    {
      uint64_t v26 = malloc(0x858uLL);
      uint64_t v27 = (uint64_t)v26;
      if (v26)
      {
        memset_s(v26, 0x858uLL, 0, 0x858uLL);
        *(void *)(v27 + 40) = 0x40000;
        int8x16_t v28 = malloc(0x40000uLL);
        *(void *)(v27 + 32) = v28;
        if (v28)
        {
          *(_DWORD *)(v27 + 2104) = -1;
          goto LABEL_22;
        }
        __int16 v29 = 120;
      }
      else
      {
        __int16 v29 = 116;
      }
      int8x16_t v30 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreate", v29, 120, *v30, "malloc", v31, v32, v247);
      workerDestroy_0(v27);
      uint64_t v27 = 0;
LABEL_22:
      *(void *)(*(void *)(v15 + 1160) + 8 * v25) = v27;
      uint64_t v33 = *(void *)(v15 + 1160);
      if (!*(void *)(v33 + 8 * v25))
      {
        uint64_t v35 = "creating new worker";
        __int16 v36 = 849;
        goto LABEL_49;
      }
      ++v25;
      uint64_t v24 = (void *)*(unsigned int *)(v15 + 1152);
      if (v25 >= (unint64_t)v24) {
        goto LABEL_34;
      }
    }
  }
  uint64_t v33 = (uint64_t)v24;
  LODWORD(v24) = 0;
LABEL_34:
  uint64_t v44 = ThreadPoolCreate(v24, v33, (uint64_t)workerProc_3);
  *(void *)(v15 + 1168) = v44;
  if (!v44)
  {
    uint64_t v35 = "ThreadPoolCreate";
    __int16 v36 = 854;
LABEL_49:
    int v34 = 0;
    goto LABEL_26;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(v15 + 1176), 0) < 0)
  {
    uint64_t v35 = "pthread_mutex_init";
    __int16 v36 = 857;
    goto LABEL_49;
  }
  if (*(_DWORD *)(v15 + 1080))
  {
    uint64_t v45 = (FILE **)MEMORY[0x263EF8348];
    fwrite("DecodeAndExtract\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    fprintf(*v45, "  target directory: %s\n", a3);
    if (a2) {
      uint64_t v46 = "yes";
    }
    else {
      uint64_t v46 = "no";
    }
    fprintf(*v45, "  manifest: %s\n", v46);
    if ((a6 & 0x40000000000000) != 0) {
      int v47 = "no";
    }
    else {
      int v47 = "yes";
    }
    fprintf(*v45, "  path checking: %s\n", v47);
    int v48 = *(_DWORD *)(v15 + 1080);
    if (!*(void *)(v15 + 8))
    {
LABEL_97:
      if (v48) {
        fwrite("Scanning archive\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
      goto LABEL_99;
    }
    *(void *)&v252.st_dev = 0;
    if (v48) {
      fwrite("Scanning manifest\n", 0x12uLL, 1uLL, *v45);
    }
LABEL_52:
    double RealTime = getRealTime();
    uint64_t v250 = 0;
    uint64_t value = 0;
    int Header = AAArchiveStreamReadHeader(*(AAArchiveStream *)(v15 + 8), (AAHeader *)&v252);
    if (Header)
    {
      while (1)
      {
        if (Header < 0)
        {
          uint64_t v84 = "manifest read";
          __int16 v85 = 1041;
          goto LABEL_145;
        }
        ssize_t v53 = *(AAHeader_impl **)&v252.st_dev;
        v54.uint64_t ikey = 5784649;
        uint32_t KeyIndex = AAHeaderGetKeyIndex(*(AAHeader *)&v252.st_dev, v54);
        if ((KeyIndex & 0x80000000) != 0) {
          break;
        }
        unsigned int FieldUInt = AAHeaderGetFieldUInt(v53, KeyIndex, &value);
        int v57 = FieldUInt <= 1 ? 1 : FieldUInt;
        if (v57 <= 0) {
          break;
        }
        unint64_t v58 = *(AAHeader_impl **)&v252.st_dev;
        v59.uint64_t ikey = 5915721;
        uint32_t v60 = AAHeaderGetKeyIndex(*(AAHeader *)&v252.st_dev, v59);
        if ((v60 & 0x80000000) != 0
          || ((unsigned int v61 = AAHeaderGetFieldUInt(v58, v60, &v250), v61 <= 1) ? (v62 = 1) : (v62 = v61), v62 <= 0))
        {
          uint64_t v84 = "missing IDZ field";
          __int16 v85 = 1045;
          goto LABEL_145;
        }
        if ((stateAppendEntry(v15, *(AAHeader *)&v252.st_dev, value, v250, 0) & 0x80000000) != 0)
        {
          uint64_t v84 = "adding entry";
          __int16 v85 = 1048;
          goto LABEL_145;
        }
        uint64_t v250 = 0;
        uint64_t value = 0;
        int Header = AAArchiveStreamReadHeader(*(AAArchiveStream *)(v15 + 8), (AAHeader *)&v252);
        if (!Header) {
          goto LABEL_66;
        }
      }
      uint64_t v84 = "missing IDX field";
      __int16 v85 = 1044;
LABEL_145:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateScanManifest", v85, 120, 0, v84, v51, v52, v247);
      AAHeaderDestroy(*(AAHeader *)&v252.st_dev);
      long long v125 = "scanning manifest";
      __int16 v126 = 1363;
      goto LABEL_277;
    }
LABEL_66:
    AAHeaderDestroy(*(AAHeader *)&v252.st_dev);
    double v65 = getRealTime();
    if (*(_DWORD *)(v15 + 1080)) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%12.2f time (s)\n", v65 - RealTime);
    }
    if (*(void *)(v15 + 8)) {
      goto LABEL_69;
    }
    int v48 = *(_DWORD *)(v15 + 1080);
    goto LABEL_97;
  }
  if (*(void *)(v15 + 8))
  {
    *(void *)&v252.st_dev = 0;
    goto LABEL_52;
  }
LABEL_99:
  double v86 = getRealTime();
  uint64_t v87 = (unsigned __int16 *)malloc(0x10000uLL);
  if (!v87)
  {
    size_t v120 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateScanArchive", 1074, 120, *v120, "malloc", v121, v122, v247);
    char v90 = 0;
    goto LABEL_142;
  }
  char v90 = AAHeaderCreate();
  if (!v90)
  {
    uint64_t v118 = "AAHeaderCreate";
    __int16 v119 = 1076;
    goto LABEL_141;
  }
  size_t v91 = *(void **)v15;
  int v92 = (void *)(*(void *)v15 + 32);
  if (!*v92)
  {
LABEL_138:
    uint64_t v118 = "read";
    __int16 v119 = 1083;
    goto LABEL_141;
  }
  uint64_t v93 = 0;
  while (1)
  {
    unint64_t v94 = 0;
    uint64_t v95 = v87;
    uint64_t v96 = v93;
    uint64_t v97 = 6;
    do
    {
      uint64_t v98 = ((uint64_t (*)(void, unsigned __int16 *, uint64_t, uint64_t))*v92)(*v91, v95, v97, v96);
      if (v98 < 0) {
        goto LABEL_138;
      }
      if (!v98) {
        break;
      }
      uint64_t v95 = (unsigned __int16 *)((char *)v95 + v98);
      v94 += v98;
      v96 += v98;
      v97 -= v98;
    }
    while (v97);
    if (!v94) {
      break;
    }
    if ((v94 & 0x8000000000000000) != 0) {
      goto LABEL_138;
    }
    if (v94 <= 5)
    {
      uint64_t v118 = "truncated archive";
      __int16 v119 = 1084;
      goto LABEL_141;
    }
    if (*(_DWORD *)v87 != 825246017 && *(_DWORD *)v87 != 826360153)
    {
      uint64_t v118 = "invalid header magic";
      __int16 v119 = 1085;
      goto LABEL_141;
    }
    uint64_t v99 = *(void *)v15;
    if (!*(void *)(*(void *)v15 + 32)) {
      goto LABEL_191;
    }
    int64_t v100 = v87[2];
    if (v87[2])
    {
      int64_t v101 = 0;
      off_t v102 = v87;
      uint64_t v103 = v93;
      uint64_t v104 = v87[2];
      do
      {
        uint64_t v105 = (*(uint64_t (**)(void, unsigned __int16 *, uint64_t, uint64_t))(v99 + 32))(*(void *)v99, v102, v104, v103);
        if (v105 < 0) {
          goto LABEL_191;
        }
        if (!v105) {
          break;
        }
        off_t v102 = (unsigned __int16 *)((char *)v102 + v105);
        v101 += v105;
        v103 += v105;
        v104 -= v105;
      }
      while (v104);
      if (v101 < 0)
      {
LABEL_191:
        uint64_t v118 = "read";
        __int16 v119 = 1091;
        goto LABEL_141;
      }
    }
    else
    {
      int64_t v101 = 0;
    }
    if (v101 < v100)
    {
      uint64_t v118 = "truncated archive";
      __int16 v119 = 1092;
      goto LABEL_141;
    }
    if ((aaHeaderInitWithEncodedData((uint64_t)v90, v87, v100) & 0x80000000) != 0)
    {
      uint64_t v118 = "invalid archive";
      __int16 v119 = 1093;
      goto LABEL_141;
    }
    uint64_t PayloadSize = AAHeaderGetPayloadSize(v90);
    if (__CFADD__(v100, PayloadSize))
    {
      uint64_t v118 = "invalid payload size";
      __int16 v119 = 1096;
      goto LABEL_141;
    }
    uint64_t v107 = PayloadSize;
    *(void *)&v252.st_dev = 0;
    if ((stateAppendEntry(v15, v90, v93, v100 + PayloadSize, (char **)&v252) & 0x80000000) != 0)
    {
      uint64_t v118 = "adding entry";
      __int16 v119 = 1100;
      goto LABEL_141;
    }
    if (*(void *)&v252.st_dev && !*(_DWORD *)(v15 + 1072) && *(_DWORD *)(*(void *)&v252.st_dev + 60) == 68)
    {
      if (v107 == -1)
      {
        uint64_t v118 = "invalid payload size";
        __int16 v119 = 1108;
LABEL_141:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateScanArchive", v119, 120, 0, v118, v88, v89, v247);
LABEL_142:
        free(v87);
        AAHeaderDestroy(v90);
        long long v125 = "scanning archive";
        __int16 v126 = 1364;
        goto LABEL_277;
      }
      EntryData = (char *)stateGetEntryData(v15, *(uint64_t *)&v252.st_dev, v108, v109, v110, v111, v88, v89);
      memcpy(EntryData, v87, v100);
      if (v107)
      {
        uint64_t v249 = *(void *)v15;
        if (!*(void *)(*(void *)v15 + 32)) {
          goto LABEL_283;
        }
        uint64_t v113 = 0;
        uint64_t v114 = v93 + v100;
        unint64_t v115 = &EntryData[v100];
        uint64_t v116 = v107;
        do
        {
          uint64_t v117 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t))(v249 + 32))(*(void *)v249, v115, v116, v114);
          if (v117 < 0) {
            goto LABEL_283;
          }
          if (!v117) {
            break;
          }
          v115 += v117;
          v113 += v117;
          v114 += v117;
          v116 -= v117;
        }
        while (v116);
        if (v113 < 0 || v113 != v107)
        {
LABEL_283:
          uint64_t v118 = "loading DIR entry";
          __int16 v119 = 1115;
          goto LABEL_141;
        }
      }
    }
    v93 += v100 + v107;
    size_t v91 = *(void **)v15;
    int v92 = (void *)(*(void *)v15 + 32);
    if (!*v92) {
      goto LABEL_138;
    }
  }
  *(_DWORD *)(v15 + 1072) = 1;
  free(v87);
  AAHeaderDestroy(v90);
  double v201 = getRealTime();
  if (*(_DWORD *)(v15 + 1080)) {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12.2f time (s)\n", v201 - v86);
  }
LABEL_69:
  memset(&v252, 255, 24);
  uint64_t v66 = *(void *)(v15 + 1136);
  if (!v66) {
    goto LABEL_86;
  }
  uint64_t v67 = 0;
  uint64_t v68 = *(void *)(v15 + 1144);
  do
  {
    uint64_t v69 = 0;
    uint64_t v70 = (unint64_t *)(v68 + 72 * v67);
    uint64_t v71 = v70 + 4;
    uint64_t v72 = v70 + 3;
    uint64_t v73 = v70 + 2;
    do
    {
      int v74 = v73;
      if (v69)
      {
        if (v69 == 2)
        {
          int v74 = v71;
        }
        else
        {
          int v74 = v72;
          if (v69 != 1) {
            goto LABEL_84;
          }
        }
      }
      unint64_t v75 = *v74;
      if (v75 != -1)
      {
        unint64_t v76 = *((void *)&v252.st_dev + v69);
        if (v75 <= v76 && v76 != -1) {
          unint64_t v75 = *((void *)&v252.st_dev + v69);
        }
        *((void *)&v252.st_dev + v69) = v75;
      }
LABEL_84:
      ++v69;
    }
    while (v69 != 3);
    ++v67;
  }
  while (v67 != v66);
LABEL_86:
  unint64_t v78 = 0;
  BOOL v79 = 1;
  while (1)
  {
    unint64_t v80 = *((void *)&v252.st_dev + v78);
    if (v80 == -1) {
      goto LABEL_92;
    }
    if (v80 == -2)
    {
      unint64_t v127 = "too many cluster entries";
      __int16 v128 = 1164;
      int v129 = 0;
      goto LABEL_149;
    }
    size_t v81 = v80 + 1;
    unint64_t v82 = v15 + 8 * v78;
    *(void *)(v82 + 1240) = v80 + 1;
    if (v80 >> 34) {
      break;
    }
    uint64_t v83 = calloc(v81, 8uLL);
    *(void *)(v82 + 1264) = v83;
    if (!v83) {
      goto LABEL_148;
    }
    memset(v83, 255, 8 * v81);
LABEL_92:
    BOOL v79 = v78++ < 2;
    if (v78 == 3) {
      goto LABEL_151;
    }
  }
  *__error() = 12;
  *(void *)(v82 + 1264) = 0;
LABEL_148:
  int v129 = *__error();
  unint64_t v127 = "malloc";
  __int16 v128 = 1168;
LABEL_149:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAllocClusters", v128, 120, v129, v127, v63, v64, v247);
  if (v79)
  {
    long long v125 = "allocating clusters";
    __int16 v126 = 1367;
    goto LABEL_277;
  }
LABEL_151:
  if (*(_DWORD *)(v15 + 1080))
  {
    if (*(void *)(v15 + 1136))
    {
      uint64_t v130 = 0;
      uint64_t v131 = 0;
      uint64_t v132 = 0;
      uint64_t v133 = 0;
      uint64_t v134 = 0;
      uint64_t v135 = 0;
      uint64_t v136 = 0;
      uint64_t v137 = 0;
      uint64_t v138 = *(void *)(v15 + 1144) + 32;
      uint64_t v139 = *(void *)(v15 + 1136);
      do
      {
        int v140 = *(_DWORD *)(v138 + 28);
        switch(v140)
        {
          case 'L':
            ++v132;
            break;
          case 'F':
            ++v131;
            if (*(void *)(v138 - 16) != -1) {
              ++v135;
            }
            if (*(void *)(v138 - 8) != -1) {
              ++v134;
            }
            if (*(void *)v138 != -1) {
              ++v133;
            }
            break;
          case 'D':
            ++v130;
            break;
          default:
            ++v137;
            break;
        }
        v136 += *(void *)(v138 - 24);
        v138 += 72;
        --v139;
      }
      while (v139);
    }
    else
    {
      uint64_t v137 = 0;
      uint64_t v136 = 0;
      uint64_t v135 = 0;
      uint64_t v134 = 0;
      uint64_t v133 = 0;
      uint64_t v132 = 0;
      uint64_t v131 = 0;
      uint64_t v130 = 0;
    }
    long long v141 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12zu entries selected\n", *(void *)(v15 + 1136));
    fprintf(*v141, "%12llu archive bytes\n", v136);
    fprintf(*v141, "%12zu regular files\n", v131);
    fprintf(*v141, "%12zu directories\n", v130);
    fprintf(*v141, "%12zu symbolic links\n", v132);
    if (v137) {
      fprintf(*v141, "%12zu other entries\n", v137);
    }
    fprintf(*v141, "%12zu bytes allocated in DIR blob\n", *(void *)(v15 + 1112));
    if (v135) {
      fprintf(*v141, "%12zu regular files in hard link clusters\n", v135);
    }
    if (v134) {
      fprintf(*v141, "%12zu regular files in clone clusters\n", v134);
    }
    if (v133) {
      fprintf(*v141, "%12zu regular files in same content clusters\n", v133);
    }
    if (*(_DWORD *)(v15 + 1080)) {
      fwrite("Creating directories\n", 0x15uLL, 1uLL, *v141);
    }
  }
  double v149 = getRealTime();
  unint64_t v150 = *(void *)(v15 + 1136);
  if (v150 / (4 * *(_DWORD *)(v15 + 1152)) <= 0x64) {
    unint64_t v151 = 100;
  }
  else {
    unint64_t v151 = v150 / (4 * *(_DWORD *)(v15 + 1152));
  }
  if (v150)
  {
    unint64_t v152 = 0;
    while (1)
    {
      uint64_t Worker = ThreadPoolGetWorker(*(void *)(v15 + 1168), v142, v143, v144, v145, v146, v147, v148);
      if (!Worker)
      {
        long long v160 = "ThreadPoolGetWorker";
        __int16 v161 = 1190;
        goto LABEL_193;
      }
      *(_DWORD *)uint64_t Worker = 0;
      *(void *)(Worker + 16) = v152;
      v152 += v151;
      unint64_t v158 = *(void *)(v15 + 1136);
      if (v152 < v158) {
        unint64_t v158 = v152;
      }
      *(void *)(Worker + 24) = v158;
      *(void *)(Worker + 8) = v15;
      if ((ThreadPoolRunWorker(*(void *)(v15 + 1168), Worker, v154, v155, v156, v157, v147, v148) & 0x80000000) != 0) {
        break;
      }
      if (v152 >= *(void *)(v15 + 1136)) {
        goto LABEL_189;
      }
    }
    long long v160 = "ThreadPoolRunWorker";
    __int16 v161 = 1195;
LABEL_193:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateDirs", v161, 120, 0, v160, v147, v148, v247);
    char v159 = 1;
  }
  else
  {
LABEL_189:
    char v159 = 0;
  }
  if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateDirs", 1199, 120, 0, "ThreadPoolSync", v123, v124, v247);
    goto LABEL_215;
  }
  if (v159)
  {
LABEL_215:
    long long v125 = "creating directories";
    __int16 v126 = 1410;
    goto LABEL_277;
  }
  double v162 = getRealTime();
  if (*(_DWORD *)(v15 + 1080))
  {
    long long v163 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12.2f time (s)\n", v162 - v149);
    if (*(_DWORD *)(v15 + 1080)) {
      fprintf(*v163, "Creating files (flags=0x%08x)\n", *(void *)(v15 + 1088));
    }
  }
  double v171 = getRealTime();
  unint64_t v172 = *(void *)(v15 + 1136);
  if (!v172)
  {
LABEL_213:
    char v188 = 0;
    goto LABEL_219;
  }
  unint64_t v173 = 0;
  uint64_t v174 = (uint64_t *)(*(void *)(v15 + 1144) + 8);
  uint64_t v175 = *(void *)(v15 + 1136);
  do
  {
    uint64_t v176 = *v174;
    v174 += 9;
    v173 += v176;
    --v175;
  }
  while (v175);
  unint64_t v177 = 0;
  unint64_t v178 = 0;
  if (v173 / (6 * *(_DWORD *)(v15 + 1152)) >= 0x400) {
    unint64_t v179 = v173 / (6 * *(_DWORD *)(v15 + 1152));
  }
  else {
    unint64_t v179 = v173;
  }
  uint64_t v180 = 8;
  unint64_t v181 = 1;
  while (2)
  {
    if (v181 < v172)
    {
      v177 += *(void *)(*(void *)(v15 + 1144) + v180);
      if (v177 < v179)
      {
LABEL_211:
        v180 += 72;
        if (v181++ >= v172) {
          goto LABEL_213;
        }
        continue;
      }
    }
    break;
  }
  uint64_t v182 = ThreadPoolGetWorker(*(void *)(v15 + 1168), v164, v165, v166, v167, v168, v169, v170);
  if (!v182)
  {
    char v189 = "ThreadPoolGetWorker";
    __int16 v190 = 1308;
    goto LABEL_218;
  }
  *(_DWORD *)uint64_t v182 = 1;
  *(void *)(v182 + 16) = v178;
  *(void *)(v182 + 24) = v181;
  *(void *)(v182 + 8) = v15;
  if ((ThreadPoolRunWorker(*(void *)(v15 + 1168), v182, v183, v184, v185, v186, v169, v170) & 0x80000000) == 0)
  {
    unint64_t v177 = 0;
    unint64_t v172 = *(void *)(v15 + 1136);
    unint64_t v178 = v181;
    goto LABEL_211;
  }
  char v189 = "ThreadPoolRunWorker";
  __int16 v190 = 1313;
LABEL_218:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateEntries", v190, 120, 0, v189, v169, v170, v247);
  char v188 = 1;
LABEL_219:
  if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateEntries", 1321, 120, 0, "ThreadPoolSync", v123, v124, v247);
    *(_DWORD *)(v15 + 1072) = 1;
    goto LABEL_231;
  }
  *(_DWORD *)(v15 + 1072) = 1;
  if (v188)
  {
LABEL_231:
    long long v125 = "creating entries";
    __int16 v126 = 1413;
    goto LABEL_277;
  }
  double v191 = getRealTime();
  if (*(_DWORD *)(v15 + 1080))
  {
    double v192 = v191 - v171;
    unint64_t v193 = atomic_load((unint64_t *)(v15 + 1304));
    int v194 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12llu data bytes written\n", v193);
    fprintf(*v194, "%12.2f MB/s\n", (double)v193 / v192 * 0.000000953674316);
    fprintf(*v194, "%12.2f time (s)\n", v192);
  }
  int v195 = *(_DWORD *)(v15 + 1076);
  if (v195)
  {
    uint64_t v196 = *(void *)(v15 + 1136);
    if (v196)
    {
      unsigned int v197 = 0;
      long long v198 = (unsigned __int16 *)(*(void *)(v15 + 1144) + 68);
      do
      {
        unsigned int v200 = *v198;
        v198 += 36;
        unsigned int v199 = v200;
        if (v200 > v197) {
          unsigned int v197 = v199;
        }
        --v196;
      }
      while (v196);
    }
    else
    {
      unsigned int v197 = 0;
    }
  }
  else
  {
    unsigned int v197 = -1;
  }
  if (*(_DWORD *)(v15 + 1080))
  {
    if (v195) {
      unint64_t v202 = "depth loop";
    }
    else {
      unint64_t v202 = "single pass";
    }
    fprintf((FILE *)*MEMORY[0x263EF8348], "Setting directories attributes (%s)\n", v202);
  }
  double v210 = getRealTime();
  if (*(void *)(v15 + 1136) / (unint64_t)(4 * *(_DWORD *)(v15 + 1152)) <= 0x64) {
    unint64_t v211 = 100;
  }
  else {
    unint64_t v211 = *(void *)(v15 + 1136) / (unint64_t)(4 * *(_DWORD *)(v15 + 1152));
  }
  while (2)
  {
    if (*(void *)(v15 + 1136))
    {
      unint64_t v212 = 0;
      while (1)
      {
        uint64_t v213 = ThreadPoolGetWorker(*(void *)(v15 + 1168), v203, v204, v205, v206, v207, v208, v209);
        if (!v213)
        {
          off_t v243 = "ThreadPoolGetWorker";
          __int16 v244 = 1232;
          goto LABEL_276;
        }
        *(_DWORD *)uint64_t v213 = 3;
        *(void *)(v213 + 16) = v212;
        v212 += v211;
        unint64_t v218 = *(void *)(v15 + 1136);
        if (v212 < v218) {
          unint64_t v218 = v212;
        }
        *(void *)(v213 + 24) = v218;
        *(void *)(v213 + 8) = v15;
        *(_DWORD *)(v213 + 2108) = v197;
        if ((ThreadPoolRunWorker(*(void *)(v15 + 1168), v213, v214, v215, v216, v217, v208, v209) & 0x80000000) != 0) {
          break;
        }
        if (v212 >= *(void *)(v15 + 1136)) {
          goto LABEL_252;
        }
      }
      off_t v243 = "ThreadPoolRunWorker";
      __int16 v244 = 1238;
      goto LABEL_276;
    }
LABEL_252:
    if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
    {
      off_t v243 = "ThreadPoolSync";
      __int16 v244 = 1240;
LABEL_276:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateSetDirsAttributes", v244, 120, 0, v243, v208, v209, v247);
      long long v125 = "setting directories attributes";
      __int16 v126 = 1416;
      goto LABEL_277;
    }
    unsigned int v219 = v197-- + 1;
    if (v219 > 1) {
      continue;
    }
    break;
  }
  double v220 = getRealTime();
  if (*(_DWORD *)(v15 + 1080))
  {
    unint64_t v221 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "%12.2f time (s)\n", v220 - v210);
    if (*(_DWORD *)(v15 + 1080)) {
      fwrite("Creating hard links / clones\n", 0x1DuLL, 1uLL, *v221);
    }
  }
  double v229 = getRealTime();
  unint64_t v230 = *(void *)(v15 + 1136);
  if (v230 / (4 * *(_DWORD *)(v15 + 1152)) <= 0x64) {
    unint64_t v231 = 100;
  }
  else {
    unint64_t v231 = v230 / (4 * *(_DWORD *)(v15 + 1152));
  }
  if (v230)
  {
    unint64_t v232 = 0;
    while (1)
    {
      uint64_t v233 = ThreadPoolGetWorker(*(void *)(v15 + 1168), v222, v223, v224, v225, v226, v227, v228);
      if (!v233)
      {
        uint64_t v245 = "ThreadPoolGetWorker";
        __int16 v246 = 1266;
        goto LABEL_289;
      }
      *(_DWORD *)uint64_t v233 = 2;
      *(void *)(v233 + 16) = v232;
      v232 += v231;
      unint64_t v238 = *(void *)(v15 + 1136);
      if (v232 < v238) {
        unint64_t v238 = v232;
      }
      *(void *)(v233 + 24) = v238;
      *(void *)(v233 + 8) = v15;
      if ((ThreadPoolRunWorker(*(void *)(v15 + 1168), v233, v234, v235, v236, v237, v227, v228) & 0x80000000) != 0) {
        break;
      }
      if (v232 >= *(void *)(v15 + 1136)) {
        goto LABEL_267;
      }
    }
    uint64_t v245 = "ThreadPoolRunWorker";
    __int16 v246 = 1271;
LABEL_289:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateCreateClusters", v246, 120, 0, v245, v227, v228, v247);
    long long v125 = "creating hard links, clones";
    __int16 v126 = 1419;
LABEL_277:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"AARandomAccessDecodeAndExtract", v126, 120, 0, v125, v123, v124, v247);
LABEL_29:
    uint64_t v42 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_267:
    if ((ThreadPoolSync(*(unsigned int **)(v15 + 1168)) & 0x80000000) != 0)
    {
      uint64_t v245 = "ThreadPoolSync";
      __int16 v246 = 1273;
      goto LABEL_289;
    }
    double v239 = getRealTime();
    if (*(_DWORD *)(v15 + 1080)) {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%12.2f time (s)\n", v239 - v229);
    }
    if (atomic_load((unint64_t *)(v15 + 1296)))
    {
      if (*(_DWORD *)(v15 + 1080))
      {
        uint64_t v241 = (FILE *)*MEMORY[0x263EF8348];
        unint64_t v242 = atomic_load((unint64_t *)(v15 + 1296));
        fprintf(v241, "%12llu errors reported\n", v242);
      }
      long long v125 = "errors reported";
      __int16 v126 = 1424;
      goto LABEL_277;
    }
    uint64_t v42 = 0;
  }
  stateDestroy(v15);
  return v42;
}

void stateDestroy(uint64_t a1)
{
  if (a1)
  {
    StringTableDestroy(*(void ***)(a1 + 1096));
    ThreadPoolDestroy(*(void *)(a1 + 1168));
    free(*(void **)(a1 + 1120));
    memset_s((void *)(a1 + 1104), 0x18uLL, 0, 0x18uLL);
    uint64_t v2 = *(void **)(a1 + 1160);
    if (v2)
    {
      if (*(_DWORD *)(a1 + 1152))
      {
        unint64_t v3 = 0;
        do
          workerDestroy_0(*(void *)(*(void *)(a1 + 1160) + 8 * v3++));
        while (v3 < *(unsigned int *)(a1 + 1152));
        uint64_t v2 = *(void **)(a1 + 1160);
      }
      free(v2);
    }
    free(*(void **)(a1 + 1144));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1176));
    free((void *)a1);
  }
}

uint64_t workerProc_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = MEMORY[0x270FA5388](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v347 = *MEMORY[0x263EF8340];
  uint64_t v10 = v9;
  switch(*(_DWORD *)v9)
  {
    case 0:
      uint64_t v11 = v9;
      uint64_t v12 = *(void *)(v9 + 8);
      bzero(__s, 0x800uLL);
      memset(&v345, 0, sizeof(v345));
      unsigned int v13 = atomic_load((unsigned int *)(v12 + 1288));
      if (v13) {
        goto LABEL_18;
      }
      unint64_t v14 = *(void *)(v10 + 16);
      if (v14 >= *(void *)(v10 + 24)) {
        goto LABEL_18;
      }
      uint64_t v15 = 72 * v14;
      do
      {
        uint64_t v16 = *(void *)(v12 + 1144) + v15;
        if (*(_DWORD *)(v16 + 60) != 68) {
          goto LABEL_17;
        }
        uint64_t v17 = (const char *)(*(void *)(*(void *)(v12 + 1096) + 32)
                           + *(void *)(*(void *)(*(void *)(v12 + 1096) + 8) + 16 * *(unsigned int *)(v16 + 64)));
        if ((stateConcatPath(v12, __s, v17) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateDirs", 352, 120, 0, "invalid path", v18, v19, v308);
          goto LABEL_16;
        }
        if (mkdir(__s, 0x1EDu))
        {
          if (!*(_DWORD *)(v12 + 1068)
            || *__error() != 2
            || (size_t v20 = strlen(__s), makePath(__s, v20), mkdir(__s, 0x1EDu)))
          {
            if (*__error() != 17 || lstat(__s, &v345) || (v345.st_mode & 0xF000) != 0x4000)
            {
              int v21 = *__error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateDirs", 366, 120, v21, "creating directory: %s", v22, v23, (char)__s);
LABEL_16:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateDirs", 370, 120, 0, "create dir failed: %s", v24, v25, (char)v17);
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 1296), 1uLL, memory_order_relaxed);
            }
          }
        }
LABEL_17:
        ++v14;
        v15 += 72;
      }
      while (v14 < *(void *)(v11 + 24));
LABEL_18:
      if (v13) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 0;
      }
    case 1:
      uint64_t v27 = *(void *)(v9 + 8);
      bzero(__s, 0x800uLL);
      bzero(&v345, 0x400uLL);
      uint64_t v341 = 0;
      uint64_t length = 0;
      uint64_t v330 = 0;
      uint64_t v331 = 0;
      uint64_t v328 = 0;
      uint64_t v329 = 0;
      uint64_t v327 = 0;
      uint64_t v340 = 0;
      long long v338 = 0u;
      long long v339 = 0u;
      long long v336 = 0u;
      long long v337 = 0u;
      uint64_t v335 = 0;
      long long v333 = 0u;
      long long v334 = 0u;
      *(_OWORD *)data_timespec size = 0u;
      if (atomic_load((unsigned int *)(v27 + 1288))) {
        goto LABEL_402;
      }
      uint64_t v31 = *(unsigned int *)(v27 + 1152);
      if (!v31) {
        goto LABEL_27;
      }
      uint64_t v32 = 0;
      while (*(void *)(*(void *)(v27 + 1160) + 8 * v32) != v10)
      {
        if (v31 == ++v32)
        {
LABEL_27:
          uint64_t v33 = "workerCreateEntries";
          int v34 = "couldn't determine worker_id";
          __int16 v35 = 489;
          goto LABEL_401;
        }
      }
      uint64_t v105 = AAHeaderCreate();
      if (!v105)
      {
        uint64_t v33 = "workerCreateEntries";
        int v34 = "AAHeaderCreate";
        __int16 v35 = 492;
        goto LABEL_401;
      }
      unint64_t v157 = *(void *)(v10 + 16);
      if (v157 >= *(void *)(v10 + 24)) {
        goto LABEL_399;
      }
      v314 = (char *)(v27 + 16);
      uint64_t v315 = v27;
      unint64_t v317 = v105;
      uint64_t v319 = v10;
      while (1)
      {
        uint64_t v158 = *(void *)(v27 + 1144);
        uint64_t v330 = 0;
        uint64_t v328 = 0;
        uint64_t v341 = 0;
        uint64_t v323 = v158 + 72 * v157;
        char v159 = (int *)(v323 + 60);
        if (*(_DWORD *)(v323 + 60) != 68) {
          goto LABEL_195;
        }
        if (!*(_DWORD *)(v27 + 1072))
        {
          uint64_t EntryData = stateGetEntryData(v27, v323, v153, v154, v155, v156, v28, v29);
          if (!EntryData)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 512, 120, 0, "invalid entry data", v28, v29, v308);
LABEL_412:
            uint64_t v26 = 0;
            goto LABEL_415;
          }
          uint64_t v326 = v8;
          __int16 v161 = *(void **)v27;
          uint64_t headera = v157;
          uint64_t v162 = v158 + 72 * v157;
          uint64_t v165 = *(void *)(v162 + 8);
          long long v163 = (void *)(v162 + 8);
          uint64_t v164 = v165;
          if (!v161[4])
          {
            if (v164 != -1) {
              goto LABEL_413;
            }
LABEL_193:
            __int16 v171 = 520;
            int v172 = 0;
            unint64_t v173 = "invalid dir entry";
            goto LABEL_216;
          }
          if (!v164) {
            goto LABEL_193;
          }
          uint64_t v166 = (_DWORD *)EntryData;
          uint64_t v167 = 0;
          uint64_t v168 = *(void *)v323;
          uint64_t v169 = EntryData;
          while (1)
          {
            uint64_t v170 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v161[4])(*v161, v169, v164, v168);
            if (v170 < 0) {
              break;
            }
            if (v170)
            {
              v169 += v170;
              v167 += v170;
              v168 += v170;
              v164 -= v170;
              if (v164) {
                continue;
              }
            }
            goto LABEL_189;
          }
          uint64_t v167 = v170;
LABEL_189:
          if (v167 != *v163)
          {
LABEL_413:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 516, 120, 0, "loading dir entry", v28, v29, v308);
            goto LABEL_414;
          }
          if (v167 < 4 || *v166 != 825246017 && *v166 != 826360153) {
            goto LABEL_193;
          }
          uint64_t v10 = v319;
          unint64_t v157 = headera;
          uint64_t v27 = v315;
          uint64_t v8 = v326;
          if (*v159 != 68)
          {
LABEL_195:
            uint64_t v316 = v158;
            uint64_t v326 = (const char *)(*(void *)(*(void *)(v27 + 1096) + 32)
                                + *(void *)(*(void *)(*(void *)(v27 + 1096) + 8)
                                            + 16 * *(unsigned int *)(v158 + 72 * v157 + 64)));
            if ((stateConcatPath(v27, __s, v326) & 0x80000000) != 0)
            {
              __int16 v190 = 528;
LABEL_213:
              double v191 = "invalid path";
              goto LABEL_214;
            }
            uint64_t v174 = strrchr(__s, 47);
            if (!v174)
            {
              __int16 v190 = 532;
              goto LABEL_213;
            }
            uint64_t v175 = v174;
            char *v174 = 0;
            uint64_t v176 = v174 + 1;
            if ((workerUpdateDir(v10, __s) & 0x80000000) != 0)
            {
              __int16 v190 = 535;
              double v191 = "opening parent directory";
              goto LABEL_214;
            }
            uint64_t headera = v157;
            *uint64_t v175 = 47;
            unint64_t v177 = *(void **)v27;
            if (!v177[4]) {
              goto LABEL_215;
            }
            uint64_t v178 = 0;
            uint64_t v179 = *(void *)v323;
            uint64_t v180 = *(void *)(v319 + 32);
            uint64_t v181 = 6;
            do
            {
              uint64_t v182 = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v177[4])(*v177, v180, v181, v179);
              if (v182 < 0) {
                goto LABEL_215;
              }
              if (!v182) {
                break;
              }
              v180 += v182;
              v178 += v182;
              v179 += v182;
              v181 -= v182;
            }
            while (v181);
            if (v178 != 6)
            {
LABEL_215:
              __int16 v171 = 541;
              int v172 = 0;
              unint64_t v173 = "invalid entry";
              goto LABEL_216;
            }
            uint64_t v27 = v315;
            uint64_t v183 = *(void *)v315;
            if (!*(void *)(*(void *)v315 + 32)) {
              goto LABEL_267;
            }
            uint64_t v184 = *(void *)(v319 + 32);
            unint64_t v185 = *(unsigned __int16 *)(v184 + 4);
            if (*(_WORD *)(v184 + 4))
            {
              uint64_t v186 = 0;
              uint64_t v187 = *(void *)v323;
              uint64_t v188 = *(unsigned __int16 *)(v184 + 4);
              while (1)
              {
                uint64_t v189 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v183 + 32))(*(void *)v183, v184, v188, v187);
                if (v189 < 0) {
                  break;
                }
                if (v189)
                {
                  v184 += v189;
                  v186 += v189;
                  v187 += v189;
                  v188 -= v189;
                  if (v188) {
                    continue;
                  }
                }
                goto LABEL_227;
              }
              uint64_t v186 = v189;
            }
            else
            {
              uint64_t v186 = 0;
            }
LABEL_227:
            BOOL v65 = v186 == v185;
            uint64_t v27 = v315;
            if (!v65)
            {
LABEL_267:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 544, 120, 0, "invalid entry", v28, v29, v308);
              double v192 = 0;
              uint64_t v10 = v319;
              goto LABEL_217;
            }
            uint64_t v10 = v319;
            if ((aaHeaderInitWithEncodedData((uint64_t)v317, *(unsigned __int16 **)(v319 + 32), v185) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 545, 120, 0, "invalid header", v197, v198, v308);
              double v192 = 0;
              goto LABEL_217;
            }
            int v199 = *v159;
            unint64_t v157 = headera;
            if (*v159 != 70) {
              goto LABEL_240;
            }
            v200.uint64_t ikey = 5521732;
            uint32_t KeyIndex = AAHeaderGetKeyIndex(v317, v200);
            uint64_t v8 = v326;
            if ((KeyIndex & 0x80000000) != 0)
            {
              if (*(void *)(v316 + 72 * headera + 16) == -1
                && *(void *)(v316 + 72 * headera + 24) == -1
                && *(void *)(v316 + 72 * headera + 32) == -1)
              {
                __int16 v190 = 553;
                double v191 = "DAT field is required";
                goto LABEL_214;
              }
LABEL_346:
              AAByteStreamClose(0);
              uint64_t v195 = 21;
LABEL_220:
              uint64_t v196 = *(uint64_t (**)(void, uint64_t, const char *, AAHeader_impl *))(v27 + 1048);
              if (v196 && (v196(*(void *)(v27 + 1040), v195, v8, v317) & 0x80000000) != 0)
              {
                int v305 = "Caller cancelled";
                __int16 v306 = 663;
                goto LABEL_410;
              }
              goto LABEL_222;
            }
            if (AAHeaderGetFieldBlob(v317, KeyIndex, &v341, &v331) < 0)
            {
              __int16 v190 = 549;
              double v191 = "getting DAT field";
              goto LABEL_214;
            }
            unint64_t v204 = *(void *)(v316 + 72 * headera + 16);
            if (v204 == -1
              || stateShouldCreateFileInCluster(v315, 0, v204, headera, v202, v203, v28, v29))
            {
              unint64_t v205 = *(void *)(v316 + 72 * headera + 24);
              if (v205 == -1
                || stateShouldCreateFileInCluster(v315, 1u, v205, headera, v202, v203, v28, v29))
              {
                unint64_t v206 = *(void *)(v316 + 72 * headera + 32);
                if (v206 == -1
                  || stateShouldCreateFileInCluster(v315, 2u, v206, headera, v202, v203, v28, v29))
                {
                  int v199 = *v159;
LABEL_240:
                  uint64_t v207 = v317;
                  if (v199 == 76)
                  {
                    v208.uint64_t ikey = 4935244;
                    uint32_t v209 = AAHeaderGetKeyIndex(v317, v208);
                    if ((v209 & 0x80000000) != 0
                      || ((unsigned int FieldString = AAHeaderGetFieldString(v317, v209, 0x400uLL, (char *)&v345, &length),
                           FieldString <= 1)
                        ? (int v211 = 1)
                        : (int v211 = FieldString),
                          uint64_t v207 = v317,
                          v211 <= 0))
                    {
                      __int16 v190 = 563;
                      double v191 = "missing LNK field";
                      goto LABEL_214;
                    }
                  }
                  v212.uint64_t ikey = 5521752;
                  uint32_t v213 = AAHeaderGetKeyIndex(v207, v212);
                  if ((v213 & 0x80000000) != 0
                    || ((unsigned int FieldBlob = AAHeaderGetFieldBlob(v207, v213, &v330, &v329), FieldBlob <= 1)
                      ? (int v215 = 1)
                      : (int v215 = FieldBlob),
                        v215 <= 0))
                  {
                    uint64_t v330 = 0;
                  }
                  v216.uint64_t ikey = 4997953;
                  uint32_t v217 = AAHeaderGetKeyIndex(v207, v216);
                  if ((v217 & 0x80000000) != 0
                    || ((unsigned int v218 = AAHeaderGetFieldBlob(v207, v217, &v328, &v327), v218 <= 1) ? (v219 = 1) : (v219 = v218),
                        v219 <= 0))
                  {
                    uint64_t v328 = 0;
                  }
                  unint64_t v220 = *(void *)v323 + v185;
                  v331 += v220;
                  v329 += v220;
                  v327 += v220;
                  if ((aaEntryAttributesInitWithHeader((char *)&v336, (char *)data_size, 0, v207) & 0x80000000) != 0)
                  {
                    __int16 v190 = 571;
                    double v191 = "setting attributes from header";
                    goto LABEL_214;
                  }
                  if (*(_DWORD *)(v315 + 1064)) {
                    unlinkat(*(_DWORD *)(v319 + 2104), v176, 0);
                  }
                  if (*v159 != 70)
                  {
                    if (*v159 != 76)
                    {
                      __int16 v190 = 584;
                      double v191 = "unsupported entry type";
                      goto LABEL_214;
                    }
                    if ((symlinkat((const char *)&v345, *(_DWORD *)(v319 + 2104), v176) & 0x80000000) == 0)
                    {
                      uint64_t v10 = v319;
                      unint64_t v157 = headera;
                      uint64_t v27 = v315;
                      uint64_t v8 = v326;
                      if (*v159 == 70) {
                        goto LABEL_265;
                      }
                      if ((aaEntryAttributesApplyToPath((char *)&v336, v314, v326, *(void *)(v315 + 1056)) & 0x80000000) == 0) {
                        goto LABEL_346;
                      }
                      __int16 v190 = 591;
                      double v191 = "setting attributes";
LABEL_214:
                      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v190, 120, 0, v191, v28, v29, v308);
                      double v192 = 0;
LABEL_218:
                      AAByteStreamClose(v192);
LABEL_219:
                      uint64_t v8 = v326;
                      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 656, 120, 0, "extract entry failed: %s", v193, v194, (char)v326);
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 1296), 1uLL, memory_order_relaxed);
                      uint64_t v195 = 22;
                      goto LABEL_220;
                    }
                    int v172 = *__error();
                    __int16 v171 = 581;
                    unint64_t v173 = "symlink";
LABEL_216:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v171, 120, v172, v173, v28, v29, v308);
                    double v192 = 0;
                    uint64_t v10 = v319;
                    uint64_t v27 = v315;
                    goto LABEL_217;
                  }
LABEL_265:
                  if ((v336 & 4) != 0)
                  {
                    char v221 = data_size[0];
                    unsigned int v222 = -1;
                    if ((BYTE12(v336) & 0x20) != 0 && v341) {
                      unsigned int v222 = (LOBYTE(data_size[0]) << 31 >> 31) & data_size[1];
                    }
                  }
                  else
                  {
                    char v221 = data_size[0];
                    unsigned int v222 = -1;
                  }
                  if ((v221 & 8) != 0)
                  {
                    if ((*(unsigned char *)(v315 + 1062) & 2) != 0) {
                      int v232 = HIDWORD(data_size[0]);
                    }
                    else {
                      int v232 = -1;
                    }
                  }
                  else
                  {
                    int v232 = -1;
                  }
                  uint64_t v10 = v319;
                  uint64_t v27 = v315;
                  double v192 = (AAByteStream_impl *)aaArchiveFileOutputStreamOpenAt(*(_DWORD *)(v319 + 2104), v176, v341, v222, 0, v232, *(void *)(v315 + 1088));
                  if (!v192)
                  {
                    __int16 v258 = 610;
                    __int16 v259 = "creating file stream";
                    goto LABEL_352;
                  }
                  uint64_t v238 = v341;
                  if (v341)
                  {
                    uint64_t v239 = 0;
                    while (1)
                    {
                      size_t v240 = v238 - v239;
                      if (*(void *)(v319 + 40) >= v240) {
                        size_t v241 = v240;
                      }
                      else {
                        size_t v241 = *(void *)(v319 + 40);
                      }
                      ssize_t v242 = AAByteStreamPRead(*(AAByteStream *)v315, *(void **)(v319 + 32), v241, v331 + v239);
                      if (v242 < 0)
                      {
                        __int16 v258 = 617;
                        __int16 v259 = "read failed";
                        goto LABEL_352;
                      }
                      ssize_t v243 = v242;
                      if (AAByteStreamWrite(v192, *(const void **)(v319 + 32), v242) != v242) {
                        break;
                      }
                      v239 += v243;
                      __int16 v244 = *(uint64_t (**)(void, uint64_t, const char *, uint64_t *))(v315 + 1048);
                      if (v244)
                      {
                        size[0] = v341;
                        size[1] = v239;
                        if ((v244(*(void *)(v315 + 1040), 60, v326, size) & 0x80000000) != 0)
                        {
                          int v305 = "callback cancel";
                          __int16 v306 = 629;
LABEL_410:
                          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v306, 120, 0, v305, v28, v29, v308);
                          int v307 = 0;
                          atomic_compare_exchange_strong((atomic_uint *volatile)(v27 + 1288), (unsigned int *)&v307, 1u);
LABEL_414:
                          uint64_t v26 = 0xFFFFFFFFLL;
LABEL_415:
                          uint64_t v105 = v317;
LABEL_403:
                          AAHeaderDestroy(v105);
                          return v26;
                        }
                      }
                      uint64_t v238 = v341;
                      if (v239 >= v341) {
                        goto LABEL_301;
                      }
                    }
                    __int16 v258 = 619;
                    __int16 v259 = "write failed";
LABEL_352:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v258, 120, 0, v259, v28, v29, v308);
LABEL_217:
                    unint64_t v157 = headera;
                    goto LABEL_218;
                  }
LABEL_301:
                  uint64_t v245 = aaArchiveFileOutputStreamCloseAndReturnFD((uint64_t (**)(uint64_t))v192, v233, v234, v235, v236, v237, v28, v29);
                  if ((v245 & 0x80000000) != 0)
                  {
                    __int16 v171 = 636;
                    int v172 = 0;
                    unint64_t v173 = "invalid fd";
                    goto LABEL_216;
                  }
                  uint64_t v246 = v245;
                  if ((workerApplyAttr(v319, v323, v245, (char *)&v336) & 0x80000000) == 0)
                  {
                    size_t v249 = v330;
                    if (!v330) {
                      goto LABEL_364;
                    }
                    uint64_t v250 = v329;
                    if ((workerReserve(v319, v330) & 0x80000000) != 0)
                    {
                      __int16 v283 = 248;
                      uint64_t v284 = "allocating worker buf";
                    }
                    else
                    {
                      uint64_t v253 = **(void **)(v319 + 8);
                      if (*(void *)(v253 + 32))
                      {
                        uint64_t v254 = 0;
                        uint64_t v255 = *(void *)(v319 + 32);
                        size_t v256 = v249;
                        while (1)
                        {
                          uint64_t v257 = (*(uint64_t (**)(void, uint64_t, size_t, uint64_t))(v253 + 32))(*(void *)v253, v255, v256, v250);
                          if (v257 < 0) {
                            break;
                          }
                          if (v257)
                          {
                            v255 += v257;
                            v254 += v257;
                            v250 += v257;
                            v256 -= v257;
                            if (v256) {
                              continue;
                            }
                          }
                          goto LABEL_362;
                        }
                        uint64_t v254 = v257;
                      }
                      else
                      {
                        uint64_t v254 = -1;
                      }
LABEL_362:
                      if (v254 == v249)
                      {
                        if ((workerDecodeAndApplyXAT(v319, v323, v246, *(uint8_t **)(v319 + 32), v249) & 0x80000000) == 0)
                        {
LABEL_364:
                          size_t v285 = v328;
                          if (!v328)
                          {
LABEL_386:
                            uint64_t v27 = v315;
                            atomic_fetch_add_explicit((atomic_ullong *volatile)(v315 + 1304), v341, memory_order_relaxed);
                            close(v246);
                            AAByteStreamClose(0);
                            uint64_t v195 = 21;
                            uint64_t v10 = v319;
                            unint64_t v157 = headera;
                            uint64_t v8 = v326;
                            goto LABEL_220;
                          }
                          uint64_t v286 = v327;
                          if ((workerReserve(v319, v328) & 0x80000000) != 0)
                          {
                            __int16 v294 = 269;
                            uint64_t v295 = "allocating worker buf";
                          }
                          else
                          {
                            uint64_t v289 = **(void **)(v319 + 8);
                            if (*(void *)(v289 + 32))
                            {
                              uint64_t v290 = 0;
                              uint64_t v291 = *(void *)(v319 + 32);
                              size_t v292 = v285;
                              while (1)
                              {
                                uint64_t v293 = (*(uint64_t (**)(void, uint64_t, size_t, uint64_t))(v289 + 32))(*(void *)v289, v291, v292, v286);
                                if (v293 < 0) {
                                  break;
                                }
                                if (v293)
                                {
                                  v291 += v293;
                                  v290 += v293;
                                  v286 += v293;
                                  v292 -= v293;
                                  if (v292) {
                                    continue;
                                  }
                                }
                                goto LABEL_384;
                              }
                              uint64_t v290 = v293;
                            }
                            else
                            {
                              uint64_t v290 = -1;
                            }
LABEL_384:
                            if (v290 == v285)
                            {
                              if ((workerDecodeAndApplyACL(v319, v323, v246, *(uint8_t **)(v319 + 32), v285) & 0x80000000) == 0) {
                                goto LABEL_386;
                              }
                              __int16 v294 = 276;
                              uint64_t v295 = "applying ACL";
                            }
                            else
                            {
                              __int16 v294 = 273;
                              uint64_t v295 = "loading ACL blob";
                            }
                          }
                          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerLoadAndApplyACL", v294, 120, 0, v295, v287, v288, v308);
                          __int16 v281 = 639;
                          char v282 = "loading and applying ACL";
LABEL_390:
                          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", v281, 120, 0, v282, v247, v248, v308);
                          close(v246);
                          AAByteStreamClose(0);
                          uint64_t v10 = v319;
                          unint64_t v157 = headera;
                          uint64_t v27 = v315;
                          goto LABEL_219;
                        }
                        __int16 v283 = 255;
                        uint64_t v284 = "applying XAT";
                      }
                      else
                      {
                        __int16 v283 = 252;
                        uint64_t v284 = "loading XAT blob";
                      }
                    }
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerLoadAndApplyXAT", v283, 120, 0, v284, v251, v252, v308);
                    __int16 v281 = 638;
                    char v282 = "loading and applying XAT";
                    goto LABEL_390;
                  }
                  __int16 v281 = 637;
                  char v282 = "setting attributes";
                  goto LABEL_390;
                }
              }
            }
            AAByteStreamClose(0);
            v312 = *(void **)(*(void *)(v315 + 1160) + 8 * v32);
            size_t EncodedSize = AAHeaderGetEncodedSize(v317);
            uint64_t v223 = AAHeaderClone(v317);
            v224.uint64_t ikey = 5521732;
            signed int v225 = AAHeaderGetKeyIndex(v223, v224);
            if ((v225 & 0x80000000) == 0 && AAHeaderRemoveField(v223, v225) < 0)
            {
              __int16 v230 = 293;
              unint64_t v231 = "removing DAT field";
              goto LABEL_398;
            }
            size_t v228 = AAHeaderGetEncodedSize(v223);
            uint64_t PayloadSize = AAHeaderGetPayloadSize(v223);
            *(void *)key[0].skey = v228 + PayloadSize;
            if (__CFADD__(v228, PayloadSize))
            {
              __int16 v230 = 298;
              unint64_t v231 = "entry too large to defer";
              goto LABEL_398;
            }
            size_t v260 = v228;
            int v261 = workerReserve((uint64_t)v312, *(size_t *)key[0].skey);
            if (v261 < 0)
            {
              __int16 v230 = 301;
              unint64_t v231 = "allocating worker buf";
              goto LABEL_398;
            }
            int v262 = (void *)v312[4];
            EncodedData = AAHeaderGetEncodedData(v223);
            memcpy(v262, EncodedData, v228);
            uint32_t FieldCount = AAHeaderGetFieldCount(v317);
            if (FieldCount)
            {
              uint32_t v264 = 0;
              do
              {
                int FieldType = AAHeaderGetFieldType(v317, v264);
                uint32_t v266 = v264;
                BOOL v267 = v264 != v225 || v225 <= -1;
                if (v267 && FieldType == 5)
                {
                  uint64_t offset = 0;
                  size[0] = 0;
                  if (AAHeaderGetFieldBlob(v317, v264, size, &offset) < 0)
                  {
                    __int16 v230 = 313;
                    unint64_t v231 = "getting blob field";
                    goto LABEL_398;
                  }
                  uint64_t v268 = size[0];
                  uint64_t v269 = *(void *)v323 + EncodedSize + offset;
                  uint64_t offset = v269;
                  if (size[0] + v260 > v312[5])
                  {
                    __int16 v230 = 315;
                    unint64_t v231 = "invalid blob size";
                    goto LABEL_398;
                  }
                  AAByteStream v270 = *(AAByteStream *)v315;
                  if (!*(void *)(*(void *)v315 + 32)) {
                    goto LABEL_353;
                  }
                  uint64_t v271 = 0;
                  if (size[0])
                  {
                    size_t v272 = v312[4] + v260;
                    do
                    {
                      uint64_t v273 = (*((uint64_t (**)(void, size_t, uint64_t, uint64_t))v270 + 4))(*(void *)v270, v272, v268, v269);
                      if (v273 < 0) {
                        goto LABEL_353;
                      }
                      if (!v273) {
                        break;
                      }
                      v272 += v273;
                      v271 += v273;
                      v269 += v273;
                      v268 -= v273;
                    }
                    while (v268);
                    if (v271 < 0 || v271 != size[0])
                    {
LABEL_353:
                      __int16 v230 = 319;
                      unint64_t v231 = "reading blob";
                      goto LABEL_398;
                    }
                  }
                  v260 += v271;
                }
                uint32_t v264 = v266 + 1;
              }
              while (v266 + 1 != FieldCount);
            }
            if (v260 != *(void *)key[0].skey)
            {
              __int16 v230 = 322;
              unint64_t v231 = "entry size mismatch";
              goto LABEL_398;
            }
            uint64_t v274 = v312[264];
            BOOL v144 = __CFADD__(v274, *(void *)key[0].skey);
            unint64_t v275 = v274 + *(void *)key[0].skey;
            if (v144 || (v275 & 0x8000000000000000) != 0) {
              goto LABEL_397;
            }
            uint64_t v276 = v312 + 264;
            uint64_t v277 = (const void *)v312[4];
            size_t v278 = v312[265];
            if (v278 < v275)
            {
              do
              {
                while (!v278)
                {
                  size_t v278 = 0x4000;
                  if (v275 <= 0x4000)
                  {
                    uint64_t v280 = (void **)(v312 + 266);
                    size_t v278 = 0x4000;
                    goto LABEL_379;
                  }
                }
                size_t v279 = v278 >> 1;
                if ((v278 & (v278 >> 1)) != 0) {
                  size_t v279 = v278 & (v278 >> 1);
                }
                v278 += v279;
              }
              while (v278 < v275);
              uint64_t v280 = (void **)(v312 + 266);
              if (v278 >= 0x2000000001)
              {
                *__error() = 12;
                goto LABEL_396;
              }
LABEL_379:
              unint64_t v296 = *v280;
              unint64_t v297 = realloc(*v280, v278);
              if (!v297)
              {
                free(v296);
LABEL_396:
                void *v280 = 0;
                *uint64_t v276 = 0;
                v312[265] = 0;
LABEL_397:
                __int16 v230 = 325;
                unint64_t v231 = "storing entry in worker blob";
LABEL_398:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerDeferEntry", v230, 120, 0, v231, v226, v227, v308);
                AAHeaderDestroy(v223);
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateEntries", 651, 120, 0, "storing deferred entry", v301, v302, v309);
                uint64_t v10 = v319;
                unint64_t v157 = headera;
                uint64_t v27 = v315;
                goto LABEL_219;
              }
              v312[266] = v297;
              v312[265] = v278;
            }
            uint64_t v298 = v312[266];
            if (v277)
            {
              memcpy((void *)(v298 + *v276), v277, *(size_t *)key[0].skey);
            }
            else if (v298)
            {
              memset_s((void *)(v298 + *v276), *(rsize_t *)key[0].skey, 0, *(rsize_t *)key[0].skey);
            }
            uint64_t v299 = v316 + 72 * headera;
            uint64_t v300 = *v276;
            *(void *)(v299 + 40) = *v276;
            *(void *)(v299 + 48) = *(void *)key[0].skey;
            *uint64_t v276 = v300 + *(void *)key[0].skey;
            if ((*(void *)key[0].skey & 0x8000000000000000) != 0) {
              goto LABEL_397;
            }
            unint64_t v157 = headera;
            *(_DWORD *)(v316 + 72 * headera + 56) = v32;
            AAHeaderDestroy(v223);
            uint64_t v10 = v319;
            uint64_t v27 = v315;
            uint64_t v8 = v326;
          }
        }
LABEL_222:
        if (++v157 >= *(void *)(v10 + 24)) {
          goto LABEL_412;
        }
      }
    case 2:
      uint64_t v36 = *(void *)(v9 + 8);
      bzero(__s, 0x800uLL);
      bzero(&v345, 0x800uLL);
      uint64_t offset = 0;
      size[0] = 0;
      uint64_t v341 = 0;
      uint64_t length = 0;
      uint64_t v340 = 0;
      long long v338 = 0u;
      long long v339 = 0u;
      long long v336 = 0u;
      long long v337 = 0u;
      uint64_t v335 = 0;
      long long v333 = 0u;
      long long v334 = 0u;
      *(_OWORD *)data_timespec size = 0u;
      AAHeader v37 = AAHeaderCreate();
      uint64_t v40 = v37;
      if (!v37)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 689, 120, 0, "AAHeaderCreate", v38, v39, v308);
        goto LABEL_170;
      }
      unint64_t v41 = *(void *)(v10 + 16);
      if (v41 >= *(void *)(v10 + 24))
      {
LABEL_168:
        uint64_t v26 = 0;
        goto LABEL_171;
      }
      uint64_t v318 = v10;
      uint64_t v42 = 72 * v41 + 32;
      int v322 = -1;
      AAHeader header = v37;
      while (1)
      {
        uint64_t v43 = *(void *)(v36 + 1144);
        uint64_t v44 = v43 + v42;
        if (*(_DWORD *)(v43 + v42 + 28) != 70) {
          goto LABEL_75;
        }
        uint64_t v45 = *(void *)(v44 + 16);
        if (*(void *)(v44 - 16) == -1 && *(void *)(v43 + v42 - 8) == -1)
        {
          BOOL v65 = *(void *)(v43 + v42) == -1 || v45 == 0;
          if (v65) {
            goto LABEL_75;
          }
        }
        else if (!v45)
        {
          goto LABEL_75;
        }
        long long v324 = (const char *)(*(void *)(*(void *)(v36 + 1096) + 32)
                            + *(void *)(*(void *)(*(void *)(v36 + 1096) + 8)
                                        + 16 * *(unsigned int *)(v43 + v42 + 32)));
        if ((stateConcatPath(v36, __s, v324) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 704, 120, 0, "invalid path", v50, v51, v308);
          goto LABEL_69;
        }
        uint64_t v52 = v44 - 32;
        ssize_t v53 = (unsigned __int16 *)stateGetEntryData(v36, v44 - 32, v46, v47, v48, v49, v50, v51);
        if (!v53)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 708, 120, 0, "invalid entry data", v54, v55, v308);
          uint64_t v26 = 0;
          uint64_t v40 = header;
          goto LABEL_171;
        }
        unint64_t v56 = *(void *)(v44 + 16);
        if (v56 <= 5)
        {
          __int16 v57 = 710;
          unint64_t v58 = "invalid entry";
          goto LABEL_39;
        }
        unsigned int v61 = v53;
        unint64_t v62 = v53[2];
        if (v56 < v62)
        {
          __int16 v63 = 712;
          uint64_t v64 = "invalid entry";
          goto LABEL_67;
        }
        if ((aaHeaderInitWithEncodedData((uint64_t)header, v53, v62) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 713, 120, 0, "invalid header", v66, v67, v308);
          uint64_t v10 = v318;
          uint64_t v40 = header;
          goto LABEL_69;
        }
        v68.uint64_t ikey = 5521752;
        uint32_t v69 = AAHeaderGetKeyIndex(header, v68);
        if ((v69 & 0x80000000) != 0
          || ((unsigned int v70 = AAHeaderGetFieldBlob(header, v69, size, &offset), v70 <= 1) ? (v71 = 1) : (v71 = v70), v71 <= 0))
        {
          size[0] = 0;
        }
        v72.uint64_t ikey = 4997953;
        uint32_t v73 = AAHeaderGetKeyIndex(header, v72);
        if ((v73 & 0x80000000) != 0
          || ((unsigned int v74 = AAHeaderGetFieldBlob(header, v73, &length, &v341), v74 <= 1) ? (v75 = 1) : (v75 = v74), v75 <= 0))
        {
          uint64_t length = 0;
        }
        uint64_t v76 = offset + v62;
        offset += v62;
        uint64_t v77 = v341 + v62;
        v341 += v62;
        if (size[0] && size[0] + v76 > v45 || length && length + v77 > v45)
        {
          __int16 v63 = 721;
          uint64_t v64 = "invalid blob sizes";
LABEL_67:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", v63, 120, 0, v64, v54, v55, v308);
          uint64_t v10 = v318;
LABEL_68:
          uint64_t v40 = header;
LABEL_69:
          unint64_t v78 = v324;
          goto LABEL_70;
        }
        uint64_t v10 = v318;
        if ((aaEntryAttributesInitWithHeader((char *)&v336, (char *)data_size, 0, header) & 0x80000000) != 0) {
          break;
        }
        unint64_t v84 = *(void *)(v44 - 16);
        unint64_t v85 = *(void *)(v36 + 1240);
        double v86 = (void *)(v36 + 1264);
        unint64_t v87 = v84;
        if (v84 >= v85
          && (v87 = *(void *)(v43 + v42 - 8), double v86 = (void *)(v36 + 1272), v87 >= *(void *)(v36 + 1248))
          && (v87 = *(void *)(v43 + v42), double v86 = (void *)(v36 + 1280), v87 >= *(void *)(v36 + 1256))
          || (uint64_t v88 = *(void *)(*v86 + 8 * v87), v88 == -1))
        {
          __int16 v57 = 730;
          unint64_t v58 = "missing reference entry in cluster";
          goto LABEL_39;
        }
        if ((stateConcatPath(v36, (char *)&v345, (const char *)(*(void *)(*(void *)(v36 + 1096) + 32)+ *(void *)(*(void *)(*(void *)(v36 + 1096) + 8)+ 16 * *(unsigned int *)(*(void *)(v36 + 1144) + 72 * v88 + 64)))) & 0x80000000) != 0)
        {
          __int16 v57 = 733;
          unint64_t v58 = "invalid path";
          goto LABEL_39;
        }
        if (*(_DWORD *)(v36 + 1064)) {
          unlink(__s);
        }
        if (v84 >= v85)
        {
          unint64_t v78 = v324;
          if (!clonefile((const char *)&v345, __s, 0)
            || (copyFileSegment((const char *)&v345, 0, 0xFFFFFFFFFFFFFFFFLL, __s) & 0x80000000) == 0)
          {
LABEL_94:
            uint64_t v94 = open(__s, 0x200000);
            if ((v94 & 0x80000000) != 0)
            {
              int v322 = v94;
              uint64_t v98 = __error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 759, 120, *v98, "open: %s", v99, v100, (char)__s);
              uint64_t v40 = header;
              goto LABEL_72;
            }
            uint64_t v95 = v94;
            if ((workerApplyAttr(v318, v52, v94, (char *)&v336) & 0x80000000) != 0)
            {
              __int16 v101 = 760;
              off_t v102 = "setting attributes";
            }
            else if (size[0] {
                   && (workerDecodeAndApplyXAT(v318, v52, v95, (uint8_t *)v61 + offset, size[0]) & 0x80000000) != 0)
            }
            {
              __int16 v101 = 761;
              off_t v102 = "loading and applying XAT";
            }
            else
            {
              if (!length || (workerDecodeAndApplyACL(v318, v52, v95, (uint8_t *)v61 + v341, length) & 0x80000000) == 0)
              {
                close(v95);
                uint64_t v80 = 21;
                int v322 = -1;
                uint64_t v40 = header;
                goto LABEL_73;
              }
              __int16 v101 = 762;
              off_t v102 = "loading and applying ACL";
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", v101, 120, 0, v102, v96, v97, v308);
            uint64_t v40 = header;
            int v79 = v95;
LABEL_71:
            close(v79);
            int v322 = -1;
            goto LABEL_72;
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 745, 120, 0, "cloning file, falling back to copy, failed: %s", v92, v93, (char)__s);
        }
        else
        {
          unint64_t v78 = v324;
          if ((link((const char *)&v345, __s) & 0x80000000) == 0) {
            goto LABEL_94;
          }
          int v89 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 754, 120, v89, "hard link: %s", v90, v91, (char)__s);
        }
        uint64_t v40 = header;
LABEL_70:
        int v79 = v322;
        if ((v322 & 0x80000000) == 0) {
          goto LABEL_71;
        }
LABEL_72:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 766, 120, 0, "extract cluster entry failed: %s", v59, v60, (char)v78);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v36 + 1296), 1uLL, memory_order_relaxed);
        uint64_t v80 = 22;
LABEL_73:
        size_t v81 = *(uint64_t (**)(void, uint64_t, const char *, AAHeader_impl *))(v36 + 1048);
        if (v81 && (v81(*(void *)(v36 + 1040), v80, v78, v40) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", 773, 120, 0, "Caller cancelled", v82, v83, v308);
          int v304 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)(v36 + 1288), (unsigned int *)&v304, 1u);
LABEL_170:
          uint64_t v26 = 0xFFFFFFFFLL;
LABEL_171:
          uint64_t v105 = v40;
          goto LABEL_403;
        }
LABEL_75:
        ++v41;
        v42 += 72;
        if (v41 >= *(void *)(v10 + 24)) {
          goto LABEL_168;
        }
      }
      __int16 v57 = 722;
      unint64_t v58 = "setting attributes from header";
LABEL_39:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerCreateClusters", v57, 120, 0, v58, v54, v55, v308);
      goto LABEL_68;
    case 3:
      uint64_t v103 = *(void *)(v9 + 8);
      bzero(__s, 0x800uLL);
      data_size[0] = 0;
      uint64_t offset = 0;
      size[0] = 0;
      uint64_t length = 0;
      memset(&v345, 0, 72);
      *(void *)&long long v339 = 0;
      long long v338 = 0u;
      long long v336 = 0u;
      long long v337 = 0u;
      if (atomic_load((unsigned int *)(v103 + 1288))) {
        goto LABEL_402;
      }
      uint64_t v105 = AAHeaderCreate();
      if (!v105)
      {
        uint64_t v33 = "workerSetDirAttributes";
        int v34 = "AAHeaderCreate";
        __int16 v35 = 398;
LABEL_401:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)v33, v35, 120, 0, v34, v28, v29, v308);
LABEL_402:
        uint64_t v105 = 0;
        uint64_t v26 = 0xFFFFFFFFLL;
        goto LABEL_403;
      }
      unint64_t v106 = *(void *)(v10 + 16);
      if (v106 >= *(void *)(v10 + 24))
      {
LABEL_399:
        uint64_t v26 = 0;
        goto LABEL_403;
      }
      long long v325 = v105;
      uint64_t v107 = 72 * v106;
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  while (1)
  {
    uint64_t v108 = *(void *)(v103 + 1144);
    uint64_t v109 = v108 + v107;
    data_size[0] = 0;
    uint64_t offset = 0;
    if (*(_DWORD *)(v108 + v107 + 60) != 68) {
      goto LABEL_130;
    }
    int v110 = *(_DWORD *)(v10 + 2108);
    if (v110 != -1 && v110 != *(unsigned __int16 *)(v108 + v107 + 68)) {
      goto LABEL_130;
    }
    uint64_t v111 = (const char *)(*(void *)(*(void *)(v103 + 1096) + 32)
                        + *(void *)(*(void *)(*(void *)(v103 + 1096) + 8)
                                    + 16 * *(unsigned int *)(v108 + v107 + 64)));
    if ((stateConcatPath(v103, __s, v111) & 0x80000000) != 0) {
      break;
    }
    uint64_t v114 = v10;
    unint64_t v115 = strrchr(__s, 47);
    if (!v115)
    {
      __int16 v125 = 417;
      uint64_t v131 = "invalid path";
      goto LABEL_128;
    }
    uint64_t v116 = v115;
    *unint64_t v115 = 0;
    uint64_t v117 = v115 + 1;
    if ((workerUpdateDir(v114, __s) & 0x80000000) != 0)
    {
      __int16 v125 = 420;
      uint64_t v131 = "opening parent directory";
      goto LABEL_128;
    }
    *uint64_t v116 = 47;
    uint64_t v122 = (unsigned __int16 *)stateGetEntryData(v103, v108 + v107, v118, v119, v120, v121, v112, v113);
    if (!v122)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 426, 120, 0, "invalid entry data", v112, v113, v308);
LABEL_408:
      uint64_t v26 = 0;
      uint64_t v105 = v325;
      goto LABEL_403;
    }
    uint64_t v123 = v108 + v107;
    unint64_t v124 = *(void *)(v123 + 48);
    if (v124 <= 5)
    {
      __int16 v125 = 428;
      goto LABEL_127;
    }
    uint64_t v132 = v122;
    unint64_t v133 = v122[2];
    if (v124 < v133)
    {
      __int16 v125 = 430;
LABEL_127:
      uint64_t v131 = "invalid entry";
LABEL_128:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", v125, 120, 0, v131, v112, v113, v308);
      uint64_t v10 = v114;
      goto LABEL_129;
    }
    if ((aaHeaderInitWithEncodedData((uint64_t)v325, v122, v133) & 0x80000000) != 0)
    {
      __int16 v125 = 431;
      uint64_t v131 = "invalid header";
      goto LABEL_128;
    }
    v134.uint64_t ikey = 5521752;
    uint32_t v135 = AAHeaderGetKeyIndex(v325, v134);
    if ((v135 & 0x80000000) != 0
      || ((unsigned int v136 = AAHeaderGetFieldBlob(v325, v135, data_size, size), v136 <= 1) ? (v137 = 1) : (v137 = v136), v137 <= 0))
    {
      data_size[0] = 0;
    }
    v138.uint64_t ikey = 4997953;
    uint32_t v139 = AAHeaderGetKeyIndex(v325, v138);
    if ((v139 & 0x80000000) != 0
      || ((unsigned int v140 = AAHeaderGetFieldBlob(v325, v139, &offset, &length), v140 <= 1) ? (v141 = 1) : (v141 = v140), v141 <= 0))
    {
      uint64_t offset = 0;
    }
    uint64_t v142 = size[0] + v133;
    size[0] += v133;
    uint64_t v143 = length + v133;
    length += v133;
    if (data_size[0])
    {
      BOOL v144 = __CFADD__(v142, data_size[0]);
      uint64_t v145 = v142 + data_size[0];
      if (v144 || v145 > *(void *)(v123 + 48))
      {
        __int16 v125 = 438;
        uint64_t v131 = "invalid XAT blob size";
        goto LABEL_128;
      }
    }
    uint64_t v10 = v114;
    if (offset)
    {
      BOOL v144 = __CFADD__(v143, offset);
      uint64_t v146 = v143 + offset;
      if (v144 || v146 > *(void *)(v123 + 48))
      {
        __int16 v126 = 441;
        int v127 = 0;
        __int16 v128 = "invalid ACL blob size";
        goto LABEL_122;
      }
    }
    if ((aaEntryAttributesInitWithHeader((char *)&v345, (char *)&v336, 0, v325) & 0x80000000) != 0)
    {
      __int16 v126 = 442;
      int v127 = 0;
      __int16 v128 = "setting attributes from header";
      goto LABEL_122;
    }
    uint64_t v147 = openat(*(_DWORD *)(v114 + 2104), v117, 0);
    if ((v147 & 0x80000000) != 0)
    {
      int v127 = *__error();
      __int16 v126 = 446;
      __int16 v128 = "open";
      goto LABEL_122;
    }
    uint64_t v148 = v147;
    if ((workerApplyAttr(v114, v109, v147, (char *)&v345) & 0x80000000) != 0)
    {
      __int16 v151 = 447;
      unint64_t v152 = "setting attributes";
    }
    else if (data_size[0] {
           && (workerDecodeAndApplyXAT(v114, v109, v148, (uint8_t *)v132 + size[0], data_size[0]) & 0x80000000) != 0)
    }
    {
      __int16 v151 = 449;
      unint64_t v152 = "loading and applying XAT";
    }
    else
    {
      if (!offset || (workerDecodeAndApplyACL(v114, v109, v148, (uint8_t *)v132 + length, offset) & 0x80000000) == 0)
      {
        close(v148);
        goto LABEL_130;
      }
      __int16 v151 = 450;
      unint64_t v152 = "loading and applying ACL";
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", v151, 120, 0, v152, v149, v150, v308);
    close(v148);
LABEL_129:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", 454, 120, 0, "set dir attributes failed: %s", v129, v130, (char)v111);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v103 + 1296), 1uLL, memory_order_relaxed);
LABEL_130:
    ++v106;
    v107 += 72;
    if (v106 >= *(void *)(v10 + 24)) {
      goto LABEL_408;
    }
  }
  __int16 v126 = 413;
  int v127 = 0;
  __int16 v128 = "invalid path";
LABEL_122:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerSetDirAttributes", v126, 120, v127, v128, v112, v113, v308);
  goto LABEL_129;
}

void workerDestroy_0(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 2104);
    if ((v2 & 0x80000000) == 0) {
      close(v2);
    }
    free(*(void **)(a1 + 32));
    free(*(void **)(a1 + 2128));
    memset_s((void *)(a1 + 2112), 0x18uLL, 0, 0x18uLL);
    free((void *)a1);
  }
}

uint64_t stateConcatPath(uint64_t a1, char *a2, const char *a3)
{
  uint64_t v4 = (char *)(a1 + 16);
  if (*(_DWORD *)(a1 + 1068)) {
    return concatPath(a2, 0x800uLL, v4, a3);
  }
  else {
    return concatExtractPath(a2, 0x800uLL, v4, a3);
  }
}

uint64_t stateGetEntryData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a2 + 56);
  if (v8 == -1)
  {
    uint64_t v15 = *(void *)(a2 + 40);
    uint64_t v16 = *(void *)(a2 + 48);
    BOOL v11 = __CFADD__(v15, v16);
    unint64_t v17 = v15 + v16;
    if (!v11 && v17 <= *(void *)(a1 + 1104)) {
      return *(void *)(a1 + 1120) + v15;
    }
  }
  else if (v8 >= *(_DWORD *)(a1 + 1152))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateGetEntryData", 1008, 120, 0, "invalid worker index", a7, a8, vars0);
  }
  else
  {
    uint64_t v9 = *(void *)(a2 + 40);
    uint64_t v10 = *(void *)(a2 + 48);
    BOOL v11 = __CFADD__(v9, v10);
    unint64_t v12 = v9 + v10;
    if (!v11)
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 1160) + 8 * v8);
      if (v12 <= *(void *)(v13 + 2112)) {
        return *(void *)(v13 + 2128) + v9;
      }
    }
  }
  return 0;
}

uint64_t workerUpdateDir(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  size_t v7 = v4;
  int v8 = *(_DWORD *)(a1 + 2104);
  if ((v8 & 0x80000000) == 0)
  {
    if (v4 == *(void *)(a1 + 2096))
    {
      uint64_t result = strcmp(__s, (const char *)(a1 + 48));
      if (!result) {
        return result;
      }
    }
    close(v8);
    *(_DWORD *)(a1 + 2104) = -1;
  }
  if (v7 >= 0x800)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerUpdateDir", 150, 120, 0, "directory path too long", v5, v6, v15);
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 2096) = v7;
  memcpy((void *)(a1 + 48), __s, v7);
  *(unsigned char *)(a1 + 48 + v7) = 0;
  int v10 = open((const char *)(a1 + 48), 0);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 2104) = v10;
  if (v10 < 0)
  {
    makePath((const char *)(a1 + 48), *(void *)(a1 + 2096));
    mkdir((const char *)(a1 + 48), 0x1EDu);
    int v11 = open((const char *)(a1 + 48), 0);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 2104) = v11;
    if (v11 < 0)
    {
      int v12 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerUpdateDir", 164, 120, v12, "open: %s", v13, v14, a1 + 48);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t stateShouldCreateFileInCluster(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 8 * a2 + 1240) <= a3)
  {
    uint64_t v16 = "invalid index in HLC/CLC/SLC cluster";
    __int16 v17 = 1019;
  }
  else
  {
    int v12 = (pthread_mutex_t *)(a1 + 1176);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1176)) < 0)
    {
      uint64_t v16 = "pthread_mutex_lock";
      __int16 v17 = 1020;
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 8 * a2 + 1264);
      uint64_t v14 = *(void *)(v13 + 8 * a3);
      if (v14 == -1) {
        *(void *)(v13 + 8 * a3) = a4;
      }
      if ((pthread_mutex_unlock(v12) & 0x80000000) == 0) {
        return v14 == -1;
      }
      uint64_t v16 = "pthread_mutex_lock";
      __int16 v17 = 1023;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateShouldCreateFileInCluster", v17, 120, 0, v16, a7, a8, v18);
  return 0xFFFFFFFFLL;
}

uint64_t workerApplyAttr(uint64_t a1, uint64_t a2, int a3, char *a4)
{
  uint64_t v6 = *(void **)(a1 + 8);
  size_t v7 = (uint64_t (*)(void, uint64_t, void, char *))v6[131];
  if (v7
    && (v7(v6[130], 23, *(void *)(v6[137] + 32) + *(void *)(*(void *)(v6[137] + 8) + 16 * *(unsigned int *)(a2 + 64)), a4) & 0x80000000) != 0)
  {
    int v11 = "user error";
    __int16 v12 = 178;
  }
  else
  {
    if ((aaEntryAttributesApplyToFD(a4, a3, v6[132]) & 0x80000000) == 0) {
      return 0;
    }
    int v11 = "setting attributes";
    __int16 v12 = 182;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerApplyAttr", v12, 120, 0, v11, v8, v9, v13);
  return 0xFFFFFFFFLL;
}

uint64_t workerReserve(uint64_t a1, size_t a2)
{
  if (*(void *)(a1 + 40) >= a2) {
    return 0;
  }
  *(void *)(a1 + 40) = a2;
  if (a2 < 0x2000000001)
  {
    size_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = realloc(v4, a2);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t result = 0;
      *(void *)(a1 + 32) = v6;
      return result;
    }
    free(v4);
  }
  else
  {
    *__error() = 12;
  }
  *(void *)(a1 + 32) = 0;
  size_t v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerReserve", 137, 120, *v7, "malloc", v8, v9, v10);
  return 0xFFFFFFFFLL;
}

uint64_t workerDecodeAndApplyXAT(uint64_t a1, uint64_t a2, int a3, uint8_t *data, size_t data_size)
{
  size_t v7 = *(void **)(a1 + 8);
  AAEntryXATBlob v13 = AAEntryXATBlobCreateWithEncodedData(data, data_size);
  if (!v13)
  {
    uint64_t v16 = "invalid XAT blob";
    __int16 v17 = 197;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerDecodeAndApplyXAT", v17, 120, 0, v16, v11, v12, v19);
    uint64_t v15 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  uint64_t v14 = (uint64_t (*)(void, uint64_t, void, AAEntryXATBlob))v7[131];
  if (v14
    && (v14(v7[130], 24, *(void *)(v7[137] + 32) + *(void *)(*(void *)(v7[137] + 8) + 16 * *(unsigned int *)(a2 + 64)), v13) & 0x80000000) != 0)
  {
    uint64_t v16 = "user error";
    __int16 v17 = 203;
    goto LABEL_9;
  }
  if ((aaEntryXATBlobApplyToFD(v13, a3, v7[132], v8, v9, v10, v11, v12) & 0x80000000) != 0)
  {
    uint64_t v16 = "applying XAT";
    __int16 v17 = 207;
    goto LABEL_9;
  }
  uint64_t v15 = 0;
LABEL_10:
  AAEntryXATBlobDestroy(v13);
  return v15;
}

uint64_t workerDecodeAndApplyACL(uint64_t a1, uint64_t a2, uint64_t a3, uint8_t *data, size_t data_size)
{
  size_t v7 = *(void **)(a1 + 8);
  uint64_t v10 = (unint64_t *)AAEntryACLBlobCreateWithEncodedData(data, data_size);
  if (!v10)
  {
    AAEntryXATBlob v13 = "invalid ACL blob";
    __int16 v14 = 223;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"workerDecodeAndApplyACL", v14, 120, 0, v13, v8, v9, v16);
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  uint64_t v11 = (uint64_t (*)(void, uint64_t, void, unint64_t *))v7[131];
  if (v11
    && (v11(v7[130], 25, *(void *)(v7[137] + 32) + *(void *)(*(void *)(v7[137] + 8) + 16 * *(unsigned int *)(a2 + 64)), v10) & 0x80000000) != 0)
  {
    AAEntryXATBlob v13 = "user error";
    __int16 v14 = 229;
    goto LABEL_9;
  }
  if ((aaEntryACLBlobApplyToFD(v10, a3, v7[132]) & 0x80000000) != 0)
  {
    AAEntryXATBlob v13 = "applying ACL";
    __int16 v14 = 233;
    goto LABEL_9;
  }
  uint64_t v12 = 0;
LABEL_10:
  AAEntryACLBlobDestroy((AAEntryACLBlob)v10);
  return v12;
}

uint64_t stateAppendEntry(uint64_t a1, AAHeader header, uint64_t a3, rsize_t a4, char **a5)
{
  *(void *)&v80[1023] = *MEMORY[0x263EF8340];
  uint64_t v76 = -1;
  uint64_t value = 0;
  uint64_t v74 = -1;
  uint64_t v75 = -1;
  int v73 = 0;
  size_t length = 0;
  v11.uint64_t ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v11);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, &value), FieldUInt <= 1) ? (int v16 = 1) : (int v16 = FieldUInt),
        v16 <= 0))
  {
    __int16 v17 = "invalid archive stream";
    __int16 v18 = 900;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", v18, 120, 0, v17, v13, v14, v71);
    return 0xFFFFFFFFLL;
  }
  if (value - 66 <= 0x15)
  {
    if (((1 << (value - 66)) & 0x274003) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", 913, 120, 0, "unsupported entry type %c: %s", v13, v14, value);
      return 0xFFFFFFFFLL;
    }
    if (value == 77) {
      goto LABEL_14;
    }
  }
  v21.uint64_t ikey = 5521744;
  uint32_t v22 = AAHeaderGetKeyIndex(header, v21);
  if ((v22 & 0x80000000) != 0
    || ((unsigned int FieldString = AAHeaderGetFieldString(header, v22, 0x400uLL, &v79, &length), FieldString <= 1)
      ? (int v26 = 1)
      : (int v26 = FieldString),
        v26 <= 0))
  {
    __int16 v17 = "missing PAT field";
    __int16 v18 = 920;
    goto LABEL_10;
  }
  uint64_t v27 = *(uint64_t (**)(void, uint64_t, char *, AAHeader))(a1 + 1048);
  if (!v27) {
    goto LABEL_28;
  }
  int v28 = v27(*(void *)(a1 + 1040), 20, &v79, header);
  if (v28 < 0)
  {
    __int16 v49 = 926;
LABEL_64:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", v49, 120, 0, "Caller cancelled", v13, v14, v71);
    int v50 = 0;
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 1288), (unsigned int *)&v50, 1u);
    return 0xFFFFFFFFLL;
  }
  if (v28)
  {
LABEL_14:
    size_t v20 = 0;
    goto LABEL_15;
  }
  LOBYTE(v78[0]) = 0;
  int v29 = (*(uint64_t (**)(void, uint64_t, char *, uint64_t *))(a1 + 1048))(*(void *)(a1 + 1040), 27, &v79, v78);
  if (v29 < 0)
  {
    __int16 v49 = 932;
    goto LABEL_64;
  }
  if (v29) {
    __strlcpy_chk();
  }
LABEL_28:
  uint64_t v30 = value;
  if (value == 70)
  {
    v31.uint64_t ikey = 4410440;
    uint32_t v32 = AAHeaderGetKeyIndex(header, v31);
    if ((v32 & 0x80000000) != 0
      || ((v33 = AAHeaderGetFieldUInt(header, v32, &v76), v33 <= 1) ? (int v34 = 1) : (int v34 = v33), v34 <= 0))
    {
      uint64_t v76 = -1;
    }
    v35.uint64_t ikey = 4410435;
    uint32_t v36 = AAHeaderGetKeyIndex(header, v35);
    if ((v36 & 0x80000000) != 0
      || ((unsigned int v37 = AAHeaderGetFieldUInt(header, v36, &v75), v37 <= 1) ? (v38 = 1) : (v38 = v37), v38 <= 0))
    {
      uint64_t v75 = -1;
    }
    v39.uint64_t ikey = 4410451;
    uint32_t v40 = AAHeaderGetKeyIndex(header, v39);
    if ((v40 & 0x80000000) != 0
      || ((unsigned int v41 = AAHeaderGetFieldUInt(header, v40, &v74), v41 <= 1) ? (v42 = 1) : (v42 = v41), v42 <= 0))
    {
      uint64_t v74 = -1;
    }
    uint64_t v30 = value;
  }
  if (v30 == 68 && !*(_DWORD *)(a1 + 1076))
  {
    v78[0] = 0;
    v56.uint64_t ikey = 5067853;
    if ((AAHeaderGetKeyIndex(header, v56) & 0x80000000) == 0) {
      *(_DWORD *)(a1 + 1076) = 1;
    }
    v57.uint64_t ikey = 4672582;
    uint32_t v58 = AAHeaderGetKeyIndex(header, v57);
    if ((v58 & 0x80000000) == 0)
    {
      unsigned int v59 = AAHeaderGetFieldUInt(header, v58, v78);
      int v60 = v59 <= 1 ? 1 : v59;
      if (v60 >= 1 && (v78[0] & 0x20002) != 0) {
        *(_DWORD *)(a1 + 1076) = 1;
      }
    }
  }
  if ((StringTableAppend(*(unsigned int **)(a1 + 1096), &v79, length, &v73, v24, v25, v13, v14) & 0x80000000) != 0)
  {
    __int16 v17 = "inserting path in table";
    __int16 v18 = 958;
    goto LABEL_10;
  }
  if (value == 68)
  {
    uint64_t v43 = *(void *)(a1 + 1104);
    unint64_t v44 = v43 + a4;
    if (__CFADD__(v43, a4) || (v44 & 0x8000000000000000) != 0) {
      goto LABEL_106;
    }
    uint64_t v45 = (uint64_t *)(a1 + 1104);
    size_t v46 = *(void *)(a1 + 1112);
    if (v46 < v44)
    {
      do
      {
        while (!v46)
        {
          size_t v46 = 0x4000;
          if (v44 <= 0x4000)
          {
            uint64_t v48 = (void **)(a1 + 1120);
            size_t v46 = 0x4000;
            goto LABEL_92;
          }
        }
        size_t v47 = v46 >> 1;
        if ((v46 & (v46 >> 1)) != 0) {
          size_t v47 = v46 & (v46 >> 1);
        }
        v46 += v47;
      }
      while (v46 < v44);
      uint64_t v48 = (void **)(a1 + 1120);
      if (v46 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_105;
      }
LABEL_92:
      uint64_t v67 = *v48;
      __int16 v63 = (char *)realloc(*v48, v46);
      if (v63)
      {
        *(void *)(a1 + 1120) = v63;
        *(void *)(a1 + 1112) = v46;
        uint64_t v43 = *(void *)(a1 + 1104);
        goto LABEL_94;
      }
      free(v67);
LABEL_105:
      *uint64_t v48 = 0;
      *uint64_t v45 = 0;
      *(void *)(a1 + 1112) = 0;
      goto LABEL_106;
    }
    __int16 v63 = *(char **)(a1 + 1120);
    if (v63)
    {
LABEL_94:
      memset_s(&v63[v43], a4, 0, a4);
      uint64_t v43 = *v45;
    }
    *uint64_t v45 = v43 + a4;
    if ((a4 & 0x8000000000000000) != 0)
    {
LABEL_106:
      __int16 v17 = "inserting blob placeholder";
      __int16 v18 = 964;
      goto LABEL_10;
    }
    int v68 = v79;
    if (v79)
    {
      __int16 v52 = 0;
      uint32_t v69 = v80;
      do
      {
        if (v68 == 47) {
          ++v52;
        }
        int v70 = *v69++;
        int v68 = v70;
      }
      while (v70);
    }
    else
    {
      __int16 v52 = 0;
    }
    rsize_t v51 = a4;
  }
  else
  {
    uint64_t v43 = 0;
    rsize_t v51 = 0;
    __int16 v52 = 0;
  }
  unint64_t v53 = *(void *)(a1 + 1136);
  unint64_t v54 = *(void *)(a1 + 1128);
  if (v53 >= v54)
  {
    uint64_t v61 = 2 * v54;
    if (!v54) {
      uint64_t v61 = 256;
    }
    *(void *)(a1 + 1128) = v61;
    if ((unint64_t)(72 * v61) < 0x2000000001)
    {
      unint64_t v62 = *(void **)(a1 + 1144);
      uint64_t v55 = (char *)realloc(v62, 72 * v61);
      if (v55)
      {
        *(void *)(a1 + 1144) = v55;
        unint64_t v53 = *(void *)(a1 + 1136);
        goto LABEL_85;
      }
      free(v62);
    }
    else
    {
      *__error() = 12;
    }
    *(void *)(a1 + 1144) = 0;
    uint64_t v64 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AARandomAccessDecodeAndExtract.c", (uint64_t)"stateAppendEntry", 973, 120, *v64, "malloc", v65, v66, v71);
    *(void *)(a1 + 1128) = 0;
    *(void *)(a1 + 1136) = 0;
    return 0xFFFFFFFFLL;
  }
  uint64_t v55 = *(char **)(a1 + 1144);
LABEL_85:
  *(void *)(a1 + 1136) = v53 + 1;
  size_t v20 = &v55[72 * v53];
  *((_DWORD *)v20 + 15) = value;
  *((_DWORD *)v20 + 16) = v73;
  *(void *)size_t v20 = a3;
  *((void *)v20 + 1) = a4;
  *((void *)v20 + 2) = v76;
  *((void *)v20 + 3) = v75;
  *((void *)v20 + 4) = v74;
  *((void *)v20 + 5) = v43;
  *((void *)v20 + 6) = v51;
  *((_WORD *)v20 + 34) = v52;
  *((_DWORD *)v20 + 14) = -1;
LABEL_15:
  uint64_t result = 0;
  if (a5) {
    *a5 = v20;
  }
  return result;
}

AAFieldKeySet AAFieldKeySetCreate(void)
{
  uint64_t v0 = (AAFieldKeySet_impl *)malloc(0x10uLL);
  unsigned int v1 = v0;
  if (v0)
  {
    memset_s(v0, 0x10uLL, 0, 0x10uLL);
  }
  else
  {
    int v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreate", 63, 103, *v2, "malloc", v3, v4, v6);
  }
  return v1;
}

AAFieldKeySet AAFieldKeySetCreateWithString(const char *s)
{
  AAFieldKeySet v2 = AAFieldKeySetCreate();
  if (!v2) {
    goto LABEL_44;
  }
  size_t v3 = strlen(s);
  size_t v6 = v3 + 1;
  if (((v3 + 1) & 3) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 73, 103, 0, "Invalid KeySet string length: %zu", v4, v5, v3 + 1);
    return 0;
  }
  if (v6 >> 34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 75, 103, 0, "String too long: %zu", v4, v5, v3 + 1);
    return 0;
  }
  size_t v7 = v6 >> 2;
  if (((v6 >> 2) & 0x80000000) != 0)
  {
LABEL_43:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 77, 103, 0, "realloc_keys", v4, v5, v27);
LABEL_44:
    AAFieldKeySetDestroy(v2);
    return 0;
  }
  unsigned int v8 = *((_DWORD *)v2 + 1);
  if (v8 < v7)
  {
    do
    {
      if (v8) {
        v8 += v8 >> 1;
      }
      else {
        unsigned int v8 = 16;
      }
    }
    while (v8 < v7);
    uint64_t v9 = (void *)*((void *)v2 + 1);
    uint64_t v10 = realloc(v9, 4 * v8);
    if (v10)
    {
      AAFieldKey v11 = v10;
      *((void *)v2 + 1) = v10;
      *((_DWORD *)v2 + 1) = v8;
      goto LABEL_15;
    }
    free(v9);
    *((void *)v2 + 1) = 0;
    uint64_t v23 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v23, "malloc", v24, v25, v27);
    *(void *)AAFieldKeySet v2 = 0;
    goto LABEL_43;
  }
  AAFieldKey v11 = (unsigned char *)*((void *)v2 + 1);
LABEL_15:
  memcpy(v11, s, v6);
  if (v6)
  {
    size_t v12 = v6;
    do
    {
      *AAFieldKey v11 = __toupper((char)*v11);
      ++v11;
      --v12;
    }
    while (v12);
    *(_DWORD *)AAFieldKeySet v2 = v7;
    if (v6 >= 4)
    {
      uint64_t v15 = 0;
      if (v7 <= 1) {
        uint64_t v16 = 1;
      }
      else {
        uint64_t v16 = v7;
      }
      uint64_t v17 = MEMORY[0x263EF8318];
      while (1)
      {
        uint64_t v18 = *((void *)v2 + 1) + v15;
        if (*(unsigned char *)(v18 + 3))
        {
          if (*(unsigned char *)(v18 + 3) != 44) {
            break;
          }
        }
        *(unsigned char *)(v18 + 3) = 0;
        unsigned int v19 = *(_DWORD *)(*((void *)v2 + 1) + v15);
        if ((v19 & 0x80) != 0)
        {
          if (!__maskrune((char)v19, 0x500uLL)) {
            goto LABEL_47;
          }
        }
        else if ((*(_DWORD *)(v17 + 4 * (char)v19 + 60) & 0x500) == 0)
        {
          goto LABEL_47;
        }
        unsigned int v20 = (__int16)v19 >> 8;
        if (((v19 << 16) & 0x80000000) != 0)
        {
          if (!__maskrune(v20, 0x500uLL)) {
            goto LABEL_47;
          }
        }
        else if ((*(_DWORD *)(v17 + 4 * v20 + 60) & 0x500) == 0)
        {
          goto LABEL_47;
        }
        unsigned int v21 = (int)(v19 << 8) >> 24;
        if (((v19 << 8) & 0x80000000) != 0) {
          int v22 = __maskrune(v21, 0x500uLL);
        }
        else {
          int v22 = *(_DWORD *)(v17 + 4 * v21 + 60) & 0x500;
        }
        if (HIBYTE(v19) || !v22)
        {
LABEL_47:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 88, 103, 0, "invalid key set: %s", v13, v14, (char)s);
          goto LABEL_44;
        }
        v15 += 4;
        if (!--v16) {
          goto LABEL_41;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetCreateWithString", 86, 103, 0, "invalid key set: %s", v13, v14, (char)s);
      goto LABEL_44;
    }
  }
  else
  {
    *(_DWORD *)AAFieldKeySet v2 = v7;
  }
LABEL_41:
  qsort(*((void **)v2 + 1), v7, 4uLL, (int (__cdecl *)(const void *, const void *))cmp_keys);
  return v2;
}

uint64_t cmp_keys(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

void AAFieldKeySetDestroy(AAFieldKeySet key_set)
{
  if (key_set)
  {
    free(*((void **)key_set + 1));
    free(key_set);
  }
}

AAFieldKeySet AAFieldKeySetClone(AAFieldKeySet key_set)
{
  AAFieldKeySet v2 = AAFieldKeySetCreate();
  AAFieldKeySet v5 = v2;
  if (!v2) {
    goto LABEL_15;
  }
  uint64_t v6 = *(unsigned int *)key_set;
  if (v6)
  {
    if ((v6 & 0x80000000) == 0)
    {
      unsigned int v7 = *((_DWORD *)v2 + 1);
      if (v7 >= v6)
      {
        uint64_t v9 = (void *)*((void *)v2 + 1);
        goto LABEL_12;
      }
      do
      {
        if (v7) {
          v7 += v7 >> 1;
        }
        else {
          unsigned int v7 = 16;
        }
      }
      while (v7 < v6);
      unsigned int v8 = (void *)*((void *)v2 + 1);
      uint64_t v9 = realloc(v8, 4 * v7);
      if (v9)
      {
        *((void *)v5 + 1) = v9;
        *((_DWORD *)v5 + 1) = v7;
LABEL_12:
        *(_DWORD *)AAFieldKeySet v5 = v6;
        memcpy(v9, *((const void **)key_set + 1), 4 * v6);
        return v5;
      }
      free(v8);
      *((void *)v5 + 1) = 0;
      uint64_t v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v10, "malloc", v11, v12, v14);
      *(void *)AAFieldKeySet v5 = 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetClone", 106, 103, 0, "realloc_keys", v3, v4, v14);
LABEL_15:
    AAFieldKeySetDestroy(v5);
    return 0;
  }
  return v5;
}

int AAFieldKeySetClear(AAFieldKeySet key_set)
{
  *(_DWORD *)key_set = 0;
  return 0;
}

int AAFieldKeySetContainsKey(AAFieldKeySet key_set, AAFieldKey key)
{
  uint64_t v3 = 0;
  AAFieldKey v10 = key;
  unsigned int v11 = 0;
  do
  {
    *((unsigned char *)&v11 + v3) = __toupper(v10.skey[v3]);
    ++v3;
  }
  while (v3 != 3);
  int v4 = *(_DWORD *)key_set;
  if (*(_DWORD *)key_set && (AAFieldKeySet v5 = (unsigned int *)*((void *)key_set + 1), *v5 < v11))
  {
    int v6 = v4 - 1;
    unsigned int v7 = v5[v4 - 1];
    if (v7 < v11) {
      return 0;
    }
    if (v4 < 3) {
      return v7 == v11;
    }
    int v8 = 0;
    do
    {
      if (v5[(v8 + v6) >> 1] >= v11) {
        int v6 = (v8 + v6) >> 1;
      }
      else {
        int v8 = (v8 + v6) >> 1;
      }
    }
    while (v6 - v8 > 1);
  }
  else
  {
    int v6 = 0;
  }
  if (v6 < v4)
  {
    unsigned int v7 = *(_DWORD *)(*((void *)key_set + 1) + 4 * v6);
    return v7 == v11;
  }
  return 0;
}

int AAFieldKeySetInsertKey(AAFieldKeySet key_set, AAFieldKey key)
{
  uint64_t v3 = 0;
  AAFieldKey v22 = key;
  unsigned int v23 = 0;
  do
  {
    *((unsigned char *)&v23 + v3) = __toupper(v22.skey[v3]);
    ++v3;
  }
  while (v3 != 3);
  int v6 = *(_DWORD *)key_set;
  int v7 = *(_DWORD *)key_set + 1;
  if (v7 < 0) {
    goto LABEL_21;
  }
  unsigned int v8 = v23;
  unsigned int v9 = *((_DWORD *)key_set + 1);
  if (v9 < v7)
  {
    do
    {
      if (v9) {
        v9 += v9 >> 1;
      }
      else {
        unsigned int v9 = 16;
      }
    }
    while (v9 < v7);
    AAFieldKey v10 = (void *)*((void *)key_set + 1);
    unsigned int v11 = realloc(v10, 4 * v9);
    if (v11)
    {
      *((void *)key_set + 1) = v11;
      *((_DWORD *)key_set + 1) = v9;
      int v6 = *(_DWORD *)key_set;
      goto LABEL_11;
    }
    free(v10);
    *((void *)key_set + 1) = 0;
    uint64_t v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v17, "malloc", v18, v19, v21);
    *(void *)key_set = 0;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetInsertKey", 139, 103, 0, "realloc_keys failed", v4, v5, v21);
    return -1;
  }
LABEL_11:
  if (!v6 || (uint64_t v12 = (unsigned int *)*((void *)key_set + 1), *v12 >= v8))
  {
    int v13 = 0;
    goto LABEL_16;
  }
  int v13 = v6 - 1;
  unsigned int v14 = v12[v6 - 1];
  if (v14 >= v8)
  {
    if (v6 < 3)
    {
      uint64_t v15 = v13;
      goto LABEL_18;
    }
    int v20 = 0;
    do
    {
      if (v12[(v20 + v13) >> 1] >= v8) {
        int v13 = (v20 + v13) >> 1;
      }
      else {
        int v20 = (v20 + v13) >> 1;
      }
    }
    while (v13 - v20 > 1);
LABEL_16:
    if (v13 >= v6) {
      goto LABEL_23;
    }
    uint64_t v12 = (unsigned int *)*((void *)key_set + 1);
    uint64_t v15 = v13;
    unsigned int v14 = v12[v13];
LABEL_18:
    if (v14 == v8) {
      return 0;
    }
    memmove(&v12[v13 + 1], &v12[v15], 4 * (v6 - v13));
    goto LABEL_23;
  }
  int v13 = v6;
LABEL_23:
  int result = 0;
  *(_DWORD *)(*((void *)key_set + 1) + 4 * v13) = v8;
  ++*(_DWORD *)key_set;
  return result;
}

int AAFieldKeySetRemoveKey(AAFieldKeySet key_set, AAFieldKey key)
{
  uint64_t v3 = 0;
  AAFieldKey v14 = key;
  unsigned int v15 = 0;
  do
  {
    *((unsigned char *)&v15 + v3) = __toupper(v14.skey[v3]);
    ++v3;
  }
  while (v3 != 3);
  uint64_t v4 = *(int *)key_set;
  if (!v4 || (uint64_t v5 = (unsigned int *)*((void *)key_set + 1), *v5 >= v15))
  {
    int v6 = 0;
LABEL_14:
    if (v6 == v4) {
      return 0;
    }
    uint64_t v5 = (unsigned int *)*((void *)key_set + 1);
    uint64_t v9 = v6;
    unsigned int v7 = v5[v6];
    goto LABEL_16;
  }
  int v6 = v4 - 1;
  unsigned int v7 = v5[v4 - 1];
  if (v7 < v15) {
    return 0;
  }
  if ((int)v4 >= 3)
  {
    int v8 = 0;
    do
    {
      if (v5[(v8 + v6) >> 1] >= v15) {
        int v6 = (v8 + v6) >> 1;
      }
      else {
        int v8 = (v8 + v6) >> 1;
      }
    }
    while (v6 - v8 > 1);
    goto LABEL_14;
  }
  uint64_t v9 = v4 - 1;
LABEL_16:
  if (v7 == v15)
  {
    int v10 = v4 - 1;
    *(_DWORD *)key_set = v10;
    BOOL v11 = __OFSUB__(v10, v6);
    int v12 = v10 - v6;
    if (!((v12 < 0) ^ v11 | (v12 == 0))) {
      memmove(&v5[v9], &v5[v6 + 1], 4 * v12);
    }
  }
  return 0;
}

int AAFieldKeySetInsertKeySet(AAFieldKeySet key_set, AAFieldKeySet s)
{
  uint64_t v4 = *(unsigned int *)s;
  if (v4)
  {
    uint64_t v6 = *((void *)s + 1);
    uint64_t v7 = *(unsigned int *)key_set;
    int v8 = (_DWORD *)*((void *)key_set + 1);
    *(void *)key_set = 0;
    *((void *)key_set + 1) = 0;
    unsigned int v9 = v7 + v4;
    if ((int)v7 + (int)v4 >= 0)
    {
      if (!v9)
      {
LABEL_11:
        if (v7)
        {
          unsigned int v12 = 0;
          unsigned int v13 = 0;
          unsigned int v14 = 0;
          while (1)
          {
            unsigned int v15 = v8[v14];
            unsigned int v16 = *(_DWORD *)(v6 + 4 * v13);
            if (v15 == v16)
            {
              *(_DWORD *)(*((void *)key_set + 1) + 4 * v12) = v15;
              ++v14;
            }
            else
            {
              uint64_t v17 = *((void *)key_set + 1);
              if (v15 < v16)
              {
                *(_DWORD *)(v17 + 4 * v12) = v15;
                ++v14;
                goto LABEL_19;
              }
              *(_DWORD *)(v17 + 4 * v12) = v16;
            }
            ++v13;
LABEL_19:
            ++v12;
            if (v14 >= v7 || v13 >= v4) {
              goto LABEL_23;
            }
          }
        }
        unsigned int v14 = 0;
        unsigned int v13 = 0;
        unsigned int v12 = 0;
LABEL_23:
        if (v14 >= v7)
        {
          unsigned int v20 = v12;
        }
        else
        {
          uint64_t v18 = &v8[v14];
          uint64_t v19 = v7 - v14;
          do
          {
            unsigned int v20 = v12 + 1;
            int v21 = *v18++;
            *(_DWORD *)(*((void *)key_set + 1) + 4 * v12++) = v21;
            --v19;
          }
          while (v19);
        }
        if (v13 >= v4)
        {
          unsigned int v24 = v20;
        }
        else
        {
          AAFieldKey v22 = (int *)(v6 + 4 * v13);
          uint64_t v23 = v4 - v13;
          do
          {
            unsigned int v24 = v20 + 1;
            int v25 = *v22++;
            *(_DWORD *)(*((void *)key_set + 1) + 4 * v20++) = v25;
            --v23;
          }
          while (v23);
        }
        LODWORD(v4) = 0;
        *(_DWORD *)key_set = v24;
        goto LABEL_36;
      }
      unsigned int v10 = 0;
      do
      {
        if (v10) {
          v10 += v10 >> 1;
        }
        else {
          unsigned int v10 = 16;
        }
      }
      while (v10 < v9);
      BOOL v11 = malloc(4 * v10);
      if (v11)
      {
        *((void *)key_set + 1) = v11;
        *((_DWORD *)key_set + 1) = v10;
        goto LABEL_11;
      }
      *((void *)key_set + 1) = 0;
      int v26 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"realloc_keys", 17, 103, *v26, "malloc", v27, v28, v30);
      *(void *)key_set = 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAFieldKeys.c", (uint64_t)"AAFieldKeySetInsertKeySet", 178, 103, 0, "realloc_keys", v2, v3, v30);
    LODWORD(v4) = -1;
LABEL_36:
    free(v8);
  }
  return v4;
}

int AAFieldKeySetRemoveKeySet(AAFieldKeySet key_set, AAFieldKeySet s)
{
  unint64_t v2 = *(unsigned int *)s;
  if (v2)
  {
    unint64_t v3 = *(unsigned int *)key_set;
    uint64_t v4 = *((void *)key_set + 1);
    if (v3)
    {
      unsigned int v5 = 0;
      unint64_t v6 = 0;
      unint64_t v7 = 0;
      uint64_t v8 = *((void *)s + 1);
      while (1)
      {
        unsigned int v9 = *(_DWORD *)(v4 + 4 * v7);
        unsigned int v10 = *(_DWORD *)(v8 + 4 * v6);
        if (v9 == v10)
        {
          ++v7;
        }
        else if (v9 < v10)
        {
          *(_DWORD *)(*((void *)key_set + 1) + 4 * v5++) = v9;
          ++v7;
          goto LABEL_9;
        }
        ++v6;
LABEL_9:
        if (v7 >= v3 || v6 >= v2) {
          goto LABEL_13;
        }
      }
    }
    unint64_t v7 = 0;
    unsigned int v5 = 0;
LABEL_13:
    if (v7 >= v3)
    {
      unsigned int v13 = v5;
    }
    else
    {
      BOOL v11 = (int *)(v4 + 4 * v7);
      unint64_t v12 = v3 - v7;
      do
      {
        unsigned int v13 = v5 + 1;
        int v14 = *v11++;
        *(_DWORD *)(*((void *)key_set + 1) + 4 * v5++) = v14;
        --v12;
      }
      while (v12);
    }
    *(_DWORD *)key_set = v13;
  }
  return 0;
}

int AAFieldKeySetSelectKeySet(AAFieldKeySet key_set, AAFieldKeySet s)
{
  unint64_t v2 = *(unsigned int *)s;
  if (v2 && (unint64_t v3 = *(unsigned int *)key_set, v3))
  {
    unsigned int v4 = 0;
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = *((void *)s + 1);
    uint64_t v8 = *((void *)key_set + 1);
    do
    {
      unsigned int v9 = *(_DWORD *)(v8 + 4 * v6);
      unsigned int v10 = *(_DWORD *)(v7 + 4 * v5);
      if (v9 == v10)
      {
        *(_DWORD *)(*((void *)key_set + 1) + 4 * v4++) = v9;
        ++v6;
        ++v5;
      }
      else if (v9 >= v10)
      {
        ++v5;
      }
      else
      {
        ++v6;
      }
    }
    while (v6 < v3 && v5 < v2);
  }
  else
  {
    unsigned int v4 = 0;
  }
  *(_DWORD *)key_set = v4;
  return 0;
}

uint32_t AAFieldKeySetGetKeyCount(AAFieldKeySet key_set)
{
  return *(_DWORD *)key_set;
}

AAFieldKey AAFieldKeySetGetKey(AAFieldKeySet key_set, uint32_t i)
{
  return *(AAFieldKey *)(*((void *)key_set + 1) + 4 * i);
}

int AAFieldKeySetSerialize(AAFieldKeySet key_set, size_t capacity, char *s)
{
  uint64_t v3 = *(unsigned int *)key_set;
  if (v3)
  {
    if (capacity >= 4 * v3)
    {
      if ((int)v3 >= 1)
      {
        uint64_t v4 = 0;
        unint64_t v5 = s;
        do
        {
          *(_DWORD *)unint64_t v5 = *(_DWORD *)(*((void *)key_set + 1) + 4 * v4);
          if (v4) {
            *(v5 - 1) = 44;
          }
          ++v4;
          v5 += 4;
        }
        while (v4 < *(int *)key_set);
        LODWORD(v3) = *(_DWORD *)key_set;
      }
      s += (4 * v3 - 1);
      goto LABEL_11;
    }
  }
  else if (capacity)
  {
LABEL_11:
    int result = 0;
    AAByteStream_impl *s = 0;
    return result;
  }
  return -1;
}

uint64_t AAPathListCreate()
{
  uint64_t result = create();
  *(_DWORD *)(*(void *)(result + 8) + 16) = 1;
  return result;
}

uint64_t create()
{
  uint64_t v0 = malloc(0x20uLL);
  uint64_t v1 = (uint64_t)v0;
  if (!v0)
  {
    int v10 = *__error();
    BOOL v11 = "malloc";
    __int16 v12 = 444;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"create", v12, 60, v10, v11, v3, v4, v14);
    AAPathListDestroy((AAPathList)v1);
    return 0;
  }
  memset_s(v0, 0x20uLL, 0, 0x20uLL);
  unint64_t v2 = StringTableCreate();
  *(void *)(v1 + 16) = v2;
  if (!v2)
  {
    BOOL v11 = "StringTableCreate";
    __int16 v12 = 447;
LABEL_10:
    int v10 = 0;
    goto LABEL_11;
  }
  if ((increaseCapacity(v1, 0x100u) & 0x80000000) != 0)
  {
    BOOL v11 = "alloc";
    __int16 v12 = 450;
    goto LABEL_10;
  }
  unsigned int v15 = -1;
  if ((StringTableAppend(*(unsigned int **)(v1 + 16), &unk_214B013C1, 0, &v15, v5, v6, v3, v4) & 0x80000000) != 0)
  {
    BOOL v11 = "String table insert";
    __int16 v12 = 452;
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)(v1 + 8);
  unsigned int v8 = (*(_DWORD *)v1)++;
  uint64_t v9 = v7 + 24 * v8;
  *(_DWORD *)(v9 + 20) = -1;
  *(_DWORD *)(v9 + 8) = -1;
  *(void *)uint64_t v9 = -1;
  *(void *)(v9 + 12) = v15;
  return v1;
}

void AAPathListDestroy(AAPathList path_list)
{
  if (path_list)
  {
    StringTableDestroy(*((void ***)path_list + 2));
    free(*((void **)path_list + 1));
    free(path_list);
  }
}

AAPathList AAPathListCreateWithDirectoryContents(const char *dir, const char *path, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  uint64_t v6 = ((uint64_t (*)(const char *, const char *, void *, AAEntryMessageProc, AAFlagSet, void))MEMORY[0x270FA5388])(dir, path, msg_data, msg_proc, flags, *(void *)&n_threads);
  unsigned int DefaultNThreads = v7;
  unsigned int v10 = v9;
  __int16 v12 = v11;
  uint64_t v14 = v13;
  uint64_t v16 = v15;
  uint64_t v17 = (const char *)v6;
  uint64_t v121 = *MEMORY[0x263EF8340];
  unsigned int v116 = 0;
  bzero(v120, 0x400uLL);
  bzero(v119, 0x400uLL);
  if (!DefaultNThreads) {
    unsigned int DefaultNThreads = getDefaultNThreads();
  }
  if (!realpath_DARWIN_EXTSN(v17, v120))
  {
    int v26 = *__error();
    char v107 = (char)v17;
    unsigned int v24 = "Invalid dir: %s";
    __int16 v25 = 508;
    goto LABEL_47;
  }
  size_t v18 = strlen(v120);
  BOOL v20 = v18 != 1 || v120[0] != 47;
  if (v16)
  {
    size_t v21 = v18;
    __strlcpy_chk();
    if ((normalizePath((uint64_t)v119) & 0x80000000) != 0)
    {
      char v107 = (char)v17;
      unsigned int v24 = "Invalid path (subpath normalization failed): %s/%s";
      __int16 v25 = 517;
LABEL_46:
      int v26 = 0;
      goto LABEL_47;
    }
    if ((concatPath(v118, 0x800uLL, v120, v119) & 0x80000000) != 0)
    {
      int v26 = *__error();
      char v107 = (char)v17;
      unsigned int v24 = "Path too long: %s/%s";
      __int16 v25 = 523;
    }
    else
    {
      if (realpath_DARWIN_EXTSN(v118, __s))
      {
        if (v20 && (strlen(__s) < v21 || memcmp(__s, v120, v21) || __s[v21] && __s[v21] != 47))
        {
          char v107 = (char)v17;
          unsigned int v24 = "Path resolving outside target dir: %s/%s";
          __int16 v25 = 531;
        }
        else
        {
          memset(&v115, 0, sizeof(v115));
          if (!lstat(__s, &v115) && (v115.st_mode & 0xF000) == 0x4000) {
            goto LABEL_26;
          }
          char v107 = (char)v17;
          unsigned int v24 = "Not a directory: %s/%s";
          __int16 v25 = 534;
        }
        goto LABEL_46;
      }
      int v26 = *__error();
      char v107 = (char)v17;
      unsigned int v24 = "Invalid path, doesn't exist: %s/%s";
      __int16 v25 = 524;
    }
LABEL_47:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v25, 60, v26, v24, v22, v23, v107);
    uint64_t v27 = 0;
LABEL_48:
    uint64_t v48 = 0;
    __int16 v49 = 0;
    size_t v47 = 0;
    size_t v46 = 0;
LABEL_49:
    int v50 = 0;
    goto LABEL_50;
  }
LABEL_26:
  uint64_t v27 = (unsigned int *)create();
  if (!v27) {
    return (AAPathList)v27;
  }
  signed int v113 = DefaultNThreads;
  size_t v28 = strlen(v119);
  if (v28)
  {
    size_t v29 = v28;
    size_t v30 = 0;
    size_t v31 = 0;
    uint64_t v32 = *((void *)v27 + 1) + 24 * v27[7];
    *(_DWORD *)(v32 + 16) |= 1u;
    do
    {
      int v33 = v119[v31];
      if (v33 == 47 || v33 == 0)
      {
        *(_DWORD *)uint64_t v118 = -1;
        if ((increaseCapacity((uint64_t)v27, *v27 + 1) & 0x80000000) != 0)
        {
          __int16 v101 = "increase PathList capacity";
          __int16 v102 = 553;
LABEL_113:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v102, 60, 0, v101, v37, v38, v106);
          uint64_t v48 = 0;
          __int16 v49 = 0;
          size_t v47 = 0;
          size_t v46 = 0;
          int v50 = 0;
          unsigned int DefaultNThreads = v113;
          goto LABEL_50;
        }
        if ((StringTableAppend(*((unsigned int **)v27 + 2), &v119[v30], v31 - v30, v118, v35, v36, v37, v38) & 0x80000000) != 0)
        {
          __int16 v101 = "inserting path component in table";
          __int16 v102 = 554;
          goto LABEL_113;
        }
        int v39 = *v27;
        uint32_t v40 = (_DWORD *)(*((void *)v27 + 1) + 24 * *v27);
        *uint32_t v40 = *v27 - 1;
        v40[3] = *(_DWORD *)v118;
        char v40[4] = v33 != 0;
        unsigned int *v27 = v39 + 1;
        if (!v33) {
          break;
        }
        size_t v30 = ++v31;
      }
      ++v31;
    }
    while (v31 <= v29);
  }
  unsigned int DefaultNThreads = v113;
  if (!v12) {
    goto LABEL_43;
  }
  int v41 = v12(v14, 11, v119, 0);
  if (v41 < 0)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 570, 60, "abort from callback", v42, v43, v44, v106);
    goto LABEL_48;
  }
  if (v41)
  {
    uint64_t v45 = *((void *)v27 + 1) + 24 * (*v27 - 1);
    *(_DWORD *)(v45 + 16) |= 1u;
  }
LABEL_43:
  if (v113 < 0)
  {
    *__error() = 12;
    size_t v46 = 0;
    size_t v47 = 0;
    *__error() = 12;
  }
  else
  {
    size_t v46 = (char *)calloc(v113, 0x28uLL);
    size_t v47 = calloc(v113, 0x38uLL);
  }
  if ((unint64_t)(8 * v113) >= 0x2000000001)
  {
    __int16 v49 = 0;
    *__error() = 12;
LABEL_65:
    uint32_t v58 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 578, 60, *v58, "malloc", v59, v60, v106);
    uint64_t v48 = 0;
    goto LABEL_49;
  }
  uint64_t v61 = malloc(8 * v113);
  __int16 v49 = v61;
  if (!v46 || !v47 || !v61) {
    goto LABEL_65;
  }
  if (v113 >= 1)
  {
    unint64_t v62 = v47;
    uint64_t v63 = v113;
    uint64_t v64 = v61;
    do
    {
      v62[2] = v14;
      v62[3] = v12;
      v62[4] = &v116;
      void *v62 = v27;
      v62[1] = v120;
      *((_DWORD *)v62 + 10) = (v10 >> 6) & 1;
      *v64++ = v62;
      v62 += 7;
      --v63;
    }
    while (v63);
  }
  uint64_t v48 = ThreadPoolCreate(v113, (uint64_t)v61, (uint64_t)expandDirThreadProc);
  if (!v48)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 591, 60, 0, "ThreadPoolCreate", v70, v71, v106);
    goto LABEL_49;
  }
  uint64_t v111 = v49;
  uint64_t v109 = v47;
  unsigned int v72 = *v27;
  if (!*v27) {
    goto LABEL_108;
  }
  BOOL v73 = 0;
  unsigned int v74 = v72 - 1;
  unsigned int v108 = v72 - 1;
  do
  {
    if ((DefaultNThreads + v72 + ~v74) / DefaultNThreads <= 0x64) {
      unsigned int v75 = 100;
    }
    else {
      unsigned int v75 = (DefaultNThreads + v72 + ~v74) / DefaultNThreads;
    }
    BOOL v110 = v73;
    int v76 = 0;
    int v114 = !v73;
    int v112 = 1;
    uint64_t v77 = v113;
    unint64_t v78 = (int *)v46;
    do
    {
      unsigned int v79 = v74 + v75 * v76;
      *unint64_t v78 = v114;
      v78[1] = v79;
      unsigned int v80 = v79 + v75;
      v78[2] = v79 + v75;
      if (v79 > v72)
      {
        v78[1] = v72;
        unsigned int v79 = v72;
      }
      if (v80 > v72)
      {
        v78[2] = v72;
        unsigned int v80 = v72;
      }
      if (v79 < v80)
      {
        uint64_t Worker = ThreadPoolGetWorker((uint64_t)v48, v65, v66, v67, v68, v69, v70, v71);
        if (Worker)
        {
          *(void *)(Worker + 48) = v78;
          if ((ThreadPoolRunWorker((uint64_t)v48, Worker, v82, v83, v84, v85, v70, v71) & 0x80000000) == 0) {
            goto LABEL_89;
          }
          __int16 v86 = 618;
          unint64_t v87 = "ThreadPoolRunWorker";
        }
        else
        {
          __int16 v86 = 616;
          unint64_t v87 = "ThreadPoolGetWorker";
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v86, 60, 0, v87, v70, v71, v106);
        int v112 = 0;
      }
LABEL_89:
      ++v76;
      v78 += 10;
      --v77;
    }
    while (v77);
    if ((ThreadPoolSync(v48) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 620, 60, 0, "ThreadPoolSync", v70, v71, v106);
      int v105 = atomic_load(&v116);
      unsigned int DefaultNThreads = v113;
      __int16 v49 = v111;
      if (v105 >= 1)
      {
LABEL_120:
        uint64_t v103 = "Abort";
        __int16 v104 = 621;
LABEL_121:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", v104, 60, 0, v103, v70, v71, v106);
      }
LABEL_122:
      int v50 = 0;
      size_t v47 = v109;
      goto LABEL_50;
    }
    int v88 = atomic_load(&v116);
    unsigned int DefaultNThreads = v113;
    __int16 v49 = v111;
    if (v88 > 0) {
      goto LABEL_120;
    }
    if (!v112) {
      goto LABEL_122;
    }
    if (v113)
    {
      for (uint64_t i = 0; i != v113; ++i)
      {
        if (*(_DWORD *)&v46[40 * i + 4] < *(_DWORD *)&v46[40 * i + 8])
        {
          uint64_t v90 = &v46[40 * i];
          unsigned int v93 = *((_DWORD *)v90 + 4);
          uint64_t v91 = v90 + 16;
          uint64_t v92 = v93;
          if (v93)
          {
            *(_DWORD *)uint64_t v118 = 0;
            if ((increaseCapacity((uint64_t)v27, *v27 + v92) & 0x80000000) != 0)
            {
              uint64_t v103 = "alloc";
              __int16 v104 = 631;
              goto LABEL_121;
            }
            if ((StringTableAppendTable(*((void *)v27 + 2), *(unsigned int **)&v46[40 * i + 32], v118) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 632, 60, 0, "String table append", v70, v71, v106);
              __int16 v49 = v111;
              goto LABEL_122;
            }
            uint64_t v94 = *((void *)v27 + 1);
            unsigned int v95 = *v27;
            uint64_t v96 = (int *)(*(void *)&v46[40 * i + 24] + 8);
            do
            {
              uint64_t v97 = (_DWORD *)(v94 + 24 * v95++);
              unsigned int *v27 = v95;
              *uint64_t v97 = *(v96 - 2);
              v97[3] = *(_DWORD *)v118 + *(v96 - 1);
              int v98 = *v96;
              v96 += 3;
              v97[4] = v98;
              --v92;
            }
            while (v92);
            *uint64_t v91 = 0;
            __int16 v49 = v111;
          }
        }
      }
    }
    if (v110) {
      break;
    }
    BOOL v73 = v72 == *v27;
    unsigned int v74 = v72 == *v27 ? v108 : v72;
    unsigned int v72 = *v27;
  }
  while (v74 < *v27);
LABEL_108:
  size_t v47 = v109;
  if ((normalize(v27) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 656, 60, 0, "Tree normalization", v99, v100, v106);
    int v50 = 0;
  }
  else
  {
    int v50 = 1;
  }
  __int16 v49 = v111;
LABEL_50:
  if ((ThreadPoolDestroy((uint64_t)v48) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 661, 60, 0, "ThreadPoolDestroy", v51, v52, v106);
    int v50 = 0;
  }
  int v53 = atomic_load(&v116);
  if (v53 >= 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithDirectoryContents", 662, 60, 0, "threads reported errors", v51, v52, v106);
    int v50 = 0;
  }
  if (v47)
  {
    if ((int)DefaultNThreads >= 1)
    {
      uint64_t v54 = DefaultNThreads;
      uint64_t v55 = (void ***)(v46 + 32);
      do
      {
        free(*(v55 - 1));
        AAFieldKey v56 = *v55;
        v55 += 5;
        StringTableDestroy(v56);
        --v54;
      }
      while (v54);
    }
    free(v47);
    free(v49);
  }
  free(v46);
  if (!v50)
  {
    AAPathListDestroy((AAPathList)v27);
    return 0;
  }
  return (AAPathList)v27;
}

uint64_t increaseCapacity(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2) {
    return 0;
  }
  do
  {
    if (v2) {
      v2 += v2 >> 1;
    }
    else {
      unsigned int v2 = 256;
    }
  }
  while (v2 < a2);
  *(_DWORD *)(a1 + 4) = v2;
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = realloc(v4, 24 * v2);
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t result = 0;
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    free(v4);
    *(void *)(a1 + 8) = 0;
    unsigned int v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"increaseCapacity", 270, 60, *v8, "malloc", v9, v10, v11);
    *(void *)a1 = 0;
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t expandDirThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = MEMORY[0x270FA5388](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v82 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(int **)(v8 + 48);
  bzero(__src, 0x400uLL);
  bzero(v80, 0x800uLL);
  uint64_t v10 = (void *)*((void *)v9 + 4);
  if (!v10)
  {
    uint64_t v10 = StringTableCreate();
    *((void *)v9 + 4) = v10;
    if (!v10)
    {
      uint64_t v14 = "String table creation";
      __int16 v15 = 79;
      goto LABEL_101;
    }
  }
  StringTableClear((uint64_t)v10);
  v9[4] = 0;
  size_t v13 = strlen(*(const char **)(v8 + 8));
  if (v13 >= 0x800)
  {
    uint64_t v14 = "dir name too long";
    __int16 v15 = 88;
    goto LABEL_101;
  }
  size_t v16 = v13;
  __memcpy_chk();
  uint64_t v17 = &v80[v16];
  v80[v16] = 0;
  unsigned int v18 = v9[1];
  if (v18 >= v9[2]) {
    return 0;
  }
  size_t v19 = v16 + 1;
  __dst = v17 + 1;
  while (1)
  {
    BOOL v20 = *(_DWORD **)v8;
    if (**(_DWORD **)v8 <= v18
      || (v79.size_t d_ino = 0, (getPath((uint64_t)v20, v18, 0x400uLL, __src, &v79.d_ino) & 0x80000000) != 0))
    {
      uint64_t v14 = "get node path";
      __int16 v15 = 96;
      goto LABEL_101;
    }
    size_t d_ino = v79.d_ino;
    if (v79.d_ino >= 0x400)
    {
      uint64_t v14 = "truncated node path";
      __int16 v15 = 97;
      goto LABEL_101;
    }
    if (v79.d_ino) {
      size_t v22 = v19 + v79.d_ino;
    }
    else {
      size_t v22 = v16;
    }
    if (v79.d_ino)
    {
      if (v19 + v79.d_ino >= 0x800)
      {
        uint64_t v14 = "path too long";
        __int16 v15 = 103;
        goto LABEL_101;
      }
      *uint64_t v17 = 47;
      memcpy(__dst, __src, d_ino);
    }
    v80[v22] = 0;
    memset(&v78, 0, sizeof(v78));
    if (lstat(v80, &v78) < 0)
    {
      int v66 = *__error();
      uint64_t v71 = v80;
      uint64_t v14 = "lstat %s";
      __int16 v15 = 111;
      goto LABEL_102;
    }
    if (!statIsDataless(v78.st_flags)) {
      break;
    }
    unsigned int v24 = *(unsigned int (**)(void, uint64_t, unsigned char *, void))(v8 + 24);
    if (v24 && v24(*(void *)(v8 + 16), 12, __src, 0))
    {
      uint64_t v71 = v80;
      uint64_t v14 = "dataless dir error: %s";
      __int16 v15 = 118;
      goto LABEL_101;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 119, 60, "skip dataless dir: %s", v23, v11, v12, (char)v80);
LABEL_21:
    if (++v18 >= v9[2]) {
      return 0;
    }
  }
  __int16 v25 = opendir(v80);
  if (!v25)
  {
    uint64_t v59 = *(unsigned int (**)(void, uint64_t, unsigned char *, void))(v8 + 24);
    size_t v19 = v16 + 1;
    if (v59 && v59(*(void *)(v8 + 16), 12, __src, 0))
    {
      int v66 = *__error();
      uint64_t v71 = v80;
      uint64_t v14 = "opendir failed: %s";
      __int16 v15 = 130;
      goto LABEL_102;
    }
    int v72 = *__error();
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 131, 60, "opendir failed with errno=%d: %s", v60, v61, v62, v72);
    goto LABEL_21;
  }
  int v26 = v25;
  BOOL v73 = v17;
  memset(&v79, 0, 512);
  int v27 = 1;
  uint64_t v77 = 0;
  while (1)
  {
    if (!v27) {
      goto LABEL_99;
    }
    if (readdir_r(v26, &v79, &v77)) {
      break;
    }
    if (!v77) {
      goto LABEL_88;
    }
    size_t d_namlen = v79.d_namlen;
    if (v79.d_namlen == 1 && v79.d_name[0] == 46 || v79.d_namlen == 2 && v79.d_name[0] == 46 && v79.d_name[1] == 46) {
      goto LABEL_36;
    }
    unint64_t v31 = v22 + 1 + v79.d_namlen;
    if (v31 >= 0x800)
    {
      uint64_t v67 = "path too long";
      __int16 v68 = 162;
      int v69 = 0;
      goto LABEL_98;
    }
    v80[v22] = 47;
    memcpy(&v80[v22 + 1], v79.d_name, d_namlen);
    v80[v31] = 0;
    memset(&v76, 0, sizeof(v76));
    if (lstat(v80, &v76))
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 169, 60, "stat failed: %s", v33, v34, v35, (char)v80);
      goto LABEL_36;
    }
    if (v79.d_type == 4)
    {
      int v37 = *v9;
      if (!*v9) {
        goto LABEL_36;
      }
LABEL_51:
      if (v76.st_dev != v78.st_dev && !*(_DWORD *)(v8 + 40)) {
        goto LABEL_36;
      }
      if (v37)
      {
        uint32_t v40 = *(uint64_t (**)(void, uint64_t, void *, void))(v8 + 24);
        if (!v40) {
          goto LABEL_67;
        }
        int v41 = v40(*(void *)(v8 + 16), 10, __dst, 0);
        if (v41 < 0)
        {
          __int16 v55 = 182;
          goto LABEL_79;
        }
        int v27 = 1;
        if (v41)
        {
          int v36 = 26;
          goto LABEL_38;
        }
      }
      else
      {
        int v27 = 1;
      }
      goto LABEL_60;
    }
    if (v79.d_type) {
      BOOL v38 = 0;
    }
    else {
      BOOL v38 = (v76.st_mode & 0xF000) == 0x4000;
    }
    int v39 = v38;
    int v37 = *v9;
    if (((*v9 != 0) ^ v39)) {
      goto LABEL_36;
    }
    if (v39) {
      goto LABEL_51;
    }
    int v27 = 0;
LABEL_60:
    uint64_t v42 = *(uint64_t (**)(void, uint64_t, void *, void))(v8 + 24);
    if (!v42)
    {
LABEL_67:
      BOOL v45 = 1;
      goto LABEL_68;
    }
    int v43 = v42(*(void *)(v8 + 16), 11, __dst, 0);
    if (v43 < 0)
    {
      __int16 v55 = 189;
LABEL_79:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", v55, 60, "abort from callback", v33, v34, v35, (char)v71);
      goto LABEL_80;
    }
    if (v43) {
      int v44 = v27;
    }
    else {
      int v44 = 1;
    }
    if (v44 == 1)
    {
      BOOL v45 = v43 == 0;
LABEL_68:
      int v75 = -1;
      if ((StringTableAppend(*((unsigned int **)v9 + 4), v79.d_name, d_namlen, &v75, v32, v33, v34, v35) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 196, 60, 0, "String insertion failed", v46, v47, (char)v71);
LABEL_80:
        int v27 = 0;
LABEL_81:
        int v36 = 27;
        goto LABEL_38;
      }
      unsigned int v48 = v9[3];
      unsigned int v49 = v9[4];
      int v50 = (char *)*((void *)v9 + 3);
      if (v49 >= v48)
      {
        if (v48) {
          unsigned int v51 = 2 * v48;
        }
        else {
          unsigned int v51 = 256;
        }
        v9[3] = v51;
        uint64_t v52 = (char *)realloc(v50, 12 * v51);
        if (!v52)
        {
          free(v50);
          *((void *)v9 + 3) = 0;
          AAFieldKey v56 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 201, 60, *v56, "malloc", v57, v58, (char)v71);
          int v27 = 0;
          v9[3] = 0;
          v9[4] = 0;
          goto LABEL_81;
        }
        *((void *)v9 + 3) = v52;
        unsigned int v49 = v9[4];
        int v50 = v52;
      }
      int v36 = 0;
      v9[4] = v49 + 1;
      int v53 = (unsigned int *)&v50[12 * v49];
      int v54 = v75;
      *int v53 = v18;
      v53[1] = v54;
      v53[2] = !v45;
      goto LABEL_37;
    }
LABEL_36:
    int v36 = 26;
LABEL_37:
    int v27 = 1;
LABEL_38:
    if (v36 == 27)
    {
      closedir(v26);
      if (v27) {
        goto LABEL_90;
      }
LABEL_100:
      uint64_t v14 = "Directory expansion";
      __int16 v15 = 211;
      goto LABEL_101;
    }
  }
  if (*__error() != 11)
  {
    int v69 = *__error();
    uint64_t v67 = "readdir_r";
    __int16 v68 = 144;
LABEL_98:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", v68, 60, v69, v67, v28, v29, (char)v71);
LABEL_99:
    closedir(v26);
    goto LABEL_100;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", 143, 60, "readdir on dataless directory: %s", v63, v64, v65, (char)v80);
LABEL_88:
  closedir(v26);
LABEL_90:
  if (!**(_DWORD **)(v8 + 32))
  {
    uint64_t v17 = v73;
    size_t v19 = v16 + 1;
    goto LABEL_21;
  }
  uint64_t v14 = "Abort requested";
  __int16 v15 = 212;
LABEL_101:
  int v66 = 0;
LABEL_102:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"expandDirThreadProc", v15, 60, v66, v14, v11, v12, (char)v71);
  atomic_fetch_add(*(atomic_uint *volatile *)(v8 + 32), 1u);
  return 0;
}

uint64_t normalize(_DWORD *a1)
{
  if (*a1)
  {
    unsigned int v2 = StringTableSize(*((unsigned int **)a1 + 2));
    uint64_t v33 = 0;
    size_t v3 = *a1;
    if ((StringTableSort(*((unsigned int **)a1 + 2), &v33) & 0x80000000) != 0)
    {
      int v27 = "String table sorting";
      __int16 v28 = 379;
LABEL_30:
      int v30 = 0;
    }
    else
    {
      if (v3)
      {
        uint64_t v6 = v33;
        unsigned int v7 = (_DWORD *)(*((void *)a1 + 1) + 12);
        size_t v8 = v3;
        do
        {
          uint64_t v9 = *v7;
          if (v9 >= v2)
          {
            int v27 = "Name out of range";
            __int16 v28 = 386;
            goto LABEL_30;
          }
          _DWORD *v7 = v6[v9];
          *((void *)v7 - 1) = -1;
          v7 += 6;
          --v8;
        }
        while (v8);
        uint64_t v10 = 0;
        int v11 = -1;
        a1[7] = -1;
        uint64_t v12 = *((void *)a1 + 1);
        size_t v13 = (_DWORD *)(v12 + 8);
        do
        {
          unsigned int v14 = *(v13 - 2);
          if (v14 == -1)
          {
            if (v11 != -1)
            {
              int v27 = "Multiple root nodes";
              __int16 v28 = 399;
              goto LABEL_30;
            }
            a1[7] = v10;
            int v11 = v10;
          }
          else
          {
            uint64_t v15 = v12 + 24 * v14;
            *size_t v13 = *(_DWORD *)(v15 + 4);
            *(_DWORD *)(v15 + 4) = v10;
          }
          v13 += 6;
          ++v10;
        }
        while (v3 != v10);
        size_t v16 = (char *)calloc(v3, 4uLL);
        if (!v16) {
          goto LABEL_28;
        }
        uint64_t v17 = v16;
        uint64_t v18 = 0;
        unsigned int v19 = 0;
        BOOL v20 = (char *)(*((void *)a1 + 1) + 16);
        do
        {
          char v21 = *v20;
          v20 += 24;
          if ((v21 & 1) == 0) {
            *(_DWORD *)&v16[4 * v19++] = v18;
          }
          ++v18;
        }
        while (v3 != v18);
        qsort_r(v16, v19, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))cmpNodesProc);
        size_t v22 = a1 + 6;
        if (v19)
        {
          uint64_t v23 = 0;
          uint64_t v24 = *((void *)a1 + 1);
          do
          {
            unsigned int v25 = *(_DWORD *)&v17[v23];
            *size_t v22 = v25;
            size_t v22 = (unsigned int *)(v24 + 24 * v25 + 20);
            v23 += 4;
          }
          while (4 * v19 != v23);
        }
        goto LABEL_26;
      }
      a1[7] = -1;
      uint64_t v29 = (char *)calloc(v3, 4uLL);
      if (v29)
      {
        uint64_t v17 = v29;
        qsort_r(v29, 0, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))cmpNodesProc);
        size_t v22 = a1 + 6;
LABEL_26:
        uint64_t v26 = 0;
        *size_t v22 = -1;
LABEL_32:
        free(v33);
        free(v17);
        return v26;
      }
LABEL_28:
      int v30 = *__error();
      int v27 = "malloc";
      __int16 v28 = 410;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"normalize", v28, 60, v30, v27, v4, v5, v32);
    uint64_t v17 = 0;
    uint64_t v26 = 0xFFFFFFFFLL;
    goto LABEL_32;
  }
  return 0;
}

AAPathList AAPathListCreateWithPath(const char *dir, const char *path)
{
  unsigned int v2 = (const char *)((uint64_t (*)(const char *, const char *))MEMORY[0x270FA5388])(dir, path);
  uint64_t v35 = *MEMORY[0x263EF8340];
  bzero(v34, 0x400uLL);
  bzero(v33, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(v2, v34))
  {
    int v10 = *__error();
    char v29 = (char)v2;
    size_t v8 = "Invalid dir: %s";
    __int16 v9 = 693;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithPath", v9, 60, v10, v8, v6, v7, v29);
    int v11 = 0;
    goto LABEL_21;
  }
  size_t v3 = strlen(v34);
  BOOL v5 = v3 != 1 || v34[0] != 47;
  __strlcpy_chk();
  if ((normalizePath((uint64_t)v33) & 0x80000000) != 0)
  {
    char v29 = (char)v2;
    size_t v8 = "Invalid path (subpath normalization failed): %s/%s";
    __int16 v9 = 699;
    goto LABEL_17;
  }
  if ((concatPath(v32, 0x800uLL, v34, v33) & 0x80000000) != 0)
  {
    int v10 = *__error();
    char v29 = (char)v2;
    size_t v8 = "Path too long: %s/%s";
    __int16 v9 = 705;
    goto LABEL_20;
  }
  if (!realpath_DARWIN_EXTSN(v32, __s))
  {
    int v10 = *__error();
    char v29 = (char)v2;
    size_t v8 = "Invalid path, doesn't exist: %s/%s";
    __int16 v9 = 706;
    goto LABEL_20;
  }
  if (v5 && (strlen(__s) < v3 || memcmp(__s, v34, v3) || __s[v3] && __s[v3] != 47))
  {
    char v29 = (char)v2;
    size_t v8 = "Path resolving outside target dir: %s/%s";
    __int16 v9 = 713;
LABEL_17:
    int v10 = 0;
    goto LABEL_20;
  }
  int v11 = (unsigned int *)create();
  if (!v11) {
    goto LABEL_21;
  }
  size_t v13 = strlen(v33);
  if (!v13)
  {
LABEL_38:
    if ((normalize(v11) & 0x80000000) != 0)
    {
      uint64_t v26 = "Tree normalization";
      __int16 v27 = 745;
      goto LABEL_42;
    }
    return (AAPathList)v11;
  }
  size_t v14 = v13;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = *((void *)v11 + 1) + 24 * v11[7];
  *(_DWORD *)(v17 + 16) |= 1u;
  while (1)
  {
    int v18 = v33[v15];
    if (v18 == 47 || v18 == 0) {
      break;
    }
LABEL_37:
    if (++v15 > v14) {
      goto LABEL_38;
    }
  }
  int v30 = -1;
  if ((increaseCapacity((uint64_t)v11, *v11 + 1) & 0x80000000) != 0)
  {
    uint64_t v26 = "increase PathList capacity";
    __int16 v27 = 732;
    goto LABEL_42;
  }
  if ((StringTableAppend(*((unsigned int **)v11 + 2), &v33[v16], v15 - v16, &v30, v20, v21, v22, v23) & 0x80000000) == 0)
  {
    int v24 = *v11;
    unsigned int v25 = (_DWORD *)(*((void *)v11 + 1) + 24 * *v11);
    *unsigned int v25 = *v11 - 1;
    void v25[3] = v30;
    v25[4] = v18 != 0;
    *int v11 = v24 + 1;
    if (!v18) {
      goto LABEL_38;
    }
    uint64_t v16 = ++v15;
    goto LABEL_37;
  }
  uint64_t v26 = "inserting path component in table";
  __int16 v27 = 733;
LABEL_42:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAPathList.c", (uint64_t)"AAPathListCreateWithPath", v27, 60, 0, v26, v22, v23, v28);
LABEL_21:
  AAPathListDestroy((AAPathList)v11);
  return 0;
}

int AAPathListNodeGetPath(AAPathList path_list, uint64_t node, size_t path_capacity, char *path, size_t *path_length)
{
  if (node == -1)
  {
    if (path_capacity) {
      *path = 0;
    }
    int result = 0;
    *size_t path_length = 0;
  }
  else if (*(unsigned int *)path_list <= node)
  {
    return -1;
  }
  else
  {
    size_t v7 = 0;
    int result = getPath((uint64_t)path_list, node, path_capacity, path, &v7);
    if (path_length) {
      *size_t path_length = v7;
    }
  }
  return result;
}

uint64_t getPath(uint64_t a1, unsigned int a2, size_t a3, unsigned char *a4, size_t *a5)
{
  if (a2 == -1)
  {
    size_t v16 = 0;
    if (a3) {
      *a4 = 0;
    }
    goto LABEL_15;
  }
  if ((getPath() & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(v10 + 8) + 16 * *(unsigned int *)(*(void *)(a1 + 8) + 24 * a2 + 12);
  size_t v12 = *(unsigned int *)(v11 + 8);
  if (!v12) {
    return 0;
  }
  size_t v13 = *a5;
  uint64_t v14 = *a5 + 1;
  if (v14 + v12 < a3)
  {
    uint64_t v15 = (const void *)(*(void *)(v10 + 32) + *(void *)v11);
    if (v13) {
      a4[v13] = 47;
    }
    else {
      uint64_t v14 = 0;
    }
    memcpy(&a4[v14], v15, v12);
    size_t v16 = v14 + v12;
    a4[v14 + v12] = 0;
    goto LABEL_15;
  }
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  size_t v16 = v13 + (v12 + 1);
LABEL_15:
  uint64_t result = 0;
  *a5 = v16;
  return result;
}

uint64_t AAPathListGetNode(uint64_t a1, char *__s)
{
  uint64_t v2 = *(unsigned int *)(a1 + 28);
  if (v2 != -1)
  {
    size_t v6 = strlen(__s);
    if (!v6) {
      return v2;
    }
    size_t v7 = 0;
    size_t v17 = v6;
    while (1)
    {
      uint64_t v8 = v6 <= v7 + 1 ? v7 + 1 : v6;
      uint64_t v9 = v7;
      while (1)
      {
        int v10 = __s[v9];
        if (v10 == 47) {
          break;
        }
        if (v8 == ++v9)
        {
          int v10 = __s[v8];
          uint64_t v9 = v8;
          break;
        }
      }
      size_t v11 = v9 - v7;
      if (v9 == v7) {
        break;
      }
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v2 = *(unsigned int *)(v12 + 24 * v2 + 4);
      if (v2 == -1) {
        break;
      }
      int v18 = v10;
      uint64_t v13 = *(void *)(a1 + 16);
      uint64_t v14 = *(void *)(v13 + 8);
      uint64_t v15 = &__s[v7];
      while (1)
      {
        uint64_t v16 = *(unsigned int *)(v12 + 24 * v2 + 12);
        if (v11 == *(_DWORD *)(v14 + 16 * v16 + 8)
          && !strncmp((const char *)(*(void *)(v13 + 32) + *(void *)(v14 + 16 * v16)), v15, v11))
        {
          break;
        }
        uint64_t v2 = *(unsigned int *)(v12 + 24 * v2 + 8);
        if (v2 == -1) {
          return -1;
        }
      }
      if (v18) {
        size_t v7 = v9 + 1;
      }
      else {
        size_t v7 = v9;
      }
      size_t v6 = v17;
      if (v7 >= v17) {
        return v2;
      }
    }
  }
  return -1;
}