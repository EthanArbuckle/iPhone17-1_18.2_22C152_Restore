unint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t **a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unint64_t a11, uint64_t a12)
{
  ChannelDescription *v16;
  uint64_t v17;
  int32x2_t v18;
  int32x2_t v19;
  unsigned int v24;
  ChannelDescription *v25;
  uint64_t v26;
  int32x2_t v27;
  int32x2_t v28;
  ChannelDescription *v29;
  uint64_t v30;
  int32x2_t v31;
  int32x2_t v32;
  uint64_t v33;
  unint64_t v35;
  unint64_t v36;
  int16x8_t v37;
  unint64_t v38;
  unint64_t LocationForTile;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  unint64_t v47;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unint64_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t *v59;
  int8x16_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int16x8_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int16x8_t v85;
  int16x8_t v86;
  int16x8_t v87;
  int16x8_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91;
  int8x16_t v92;
  int16x8_t v93;
  int16x8_t v94;
  int16x8_t v95;
  int16x8_t v96;
  int16x8_t v97;
  int8x16_t v98;
  int8x16_t v99;
  int8x16_t v100;
  int8x16_t v101;
  int16x8_t v102;
  int16x8_t v103;
  int16x8_t v104;
  int16x8_t v105;
  int16x8_t v106;
  int8x16_t v107;
  int8x16_t v108;
  int16x8_t v109;
  int8x16_t v110;
  int8x16_t v111;
  int16x8_t v112;
  int16x8_t v113;
  int16x8_t v114;
  int16x8_t v115;
  int16x8_t v116;
  int16x8_t v117;
  int v118;
  unint64_t v119;
  unint64_t v120;
  int16x8_t v121;
  int8x16_t v122;
  int8x16_t v123;
  int8x16_t v124;
  int v125;
  unsigned int v126;
  int16x8_t v127;
  int8x16_t v128;
  int8x16_t v129;
  int8x16_t v130;
  int v131;
  int16x8_t v132;
  int8x16_t v133;
  unint64_t v134;
  unint64_t v135;
  unsigned __int8 *v136;
  unsigned __int8 *v137;
  unsigned __int8 *v138;
  unsigned __int8 *v139;
  unsigned __int8 *v140;
  unsigned __int8 *v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  unint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int8x16_t *v157;
  int8x16_t v158;
  int8x16_t v159;
  int8x16_t v160;
  int8x16_t v161;
  int16x8_t v162;
  int16x8_t v163;
  int16x8_t v164;
  int16x8_t v165;
  int8x16_t v166;
  int8x16_t v167;
  int8x16_t v168;
  int8x16_t v169;
  int16x8_t v170;
  int16x8_t v171;
  int16x8_t v172;
  int16x8_t v173;
  int16x8_t v174;
  int8x16_t v175;
  int8x16_t v176;
  int8x16_t v177;
  int8x16_t v178;
  int16x8_t v179;
  int16x8_t v180;
  int16x8_t v181;
  int16x8_t v182;
  int16x8_t v183;
  int8x16_t v184;
  int8x16_t v185;
  int8x16_t v186;
  int16x8_t v187;
  int8x16_t v188;
  int16x8_t v189;
  int16x8_t v190;
  int16x8_t v191;
  int16x8_t v192;
  int16x8_t v193;
  int16x8_t v194;
  int16x8_t v195;
  int16x8_t v196;
  int16x8_t v197;
  int16x8_t v198;
  int16x8_t v199;
  int16x8_t v200;
  int16x8_t v201;
  int16x8_t v202;
  int16x8_t v203;
  int16x8_t v204;
  int8x16_t v205;
  int8x16_t v206;
  int8x16_t v207;
  int8x16_t v208;
  int16x8_t v209;
  int16x8_t v210;
  int16x8_t v211;
  int16x8_t v212;
  int8x16_t v213;
  int16x8_t v214;
  int8x16_t v215;
  int8x16_t v216;
  int16x8_t v217;
  int8x16_t v218;
  int8x16_t v219;
  int16x8_t v220;
  int16x8_t v221;
  int16x8_t v222;
  int16x8_t v223;
  int16x8_t v224;
  int16x8_t v225;
  int16x8_t v226;
  int16x8_t v227;
  int16x8_t v228;
  int16x8_t v229;
  int16x8_t v230;
  int16x8_t v231;
  int16x8_t v232;
  int8x16_t v233;
  int8x16_t v234;
  unint64_t v235;
  unint64_t v236;
  void *v237;
  int16x8_t v238;
  int8x16_t v239;
  int16x8_t v240;
  int8x16_t v241;
  int8x16_t v242;
  int16x8_t v243;
  int16x8_t v244;
  int8x16_t v245;
  int16x8_t v246;
  int8x16_t v247;
  int8x16_t v248;
  int16x8_t v249;
  int16x8_t v250;
  int8x16_t v251;
  int16x8_t v252;
  int16x8_t v253;
  __int16 *v254;
  unint64_t v255;
  unint64_t v256;
  unsigned __int8 *v257;
  unsigned __int8 *v258;
  unsigned __int8 *v259;
  unsigned __int8 *v260;
  unsigned __int8 *v261;
  int v262;
  int v263;
  int v264;
  int v265;
  int v266;
  int v267;
  int v268;
  int v269;
  int v270;
  uint64_t v271;
  int v272;
  unsigned int v273;
  ChannelDescription *v274;
  unsigned int v275;
  ChannelDescription *v276;
  unsigned int v277;
  ChannelDescription *v278;
  unint64_t v279;
  unint64_t v280;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  int8x16_t v285;
  int8x16_t v286;
  int8x16x2_t v287;
  int8x16x2_t v288;
  int32x2_t v289;
  int32x2_t v290;
  int32x2_t v291;
  int8x16x2_t v292;
  int8x16x2_t v293;
  int16x8x2_t v294;
  int8x16x2_t v295;
  int8x16x2_t v296;
  int8x16x2_t v297;
  int8x16x2_t v298;
  int8x16x2_t v299;
  int8x16x2_t v300;
  int8x16x2_t v301;
  int8x16x2_t v302;
  int8x16x2_t v303;
  int8x16x2_t v304;
  int8x16x2_t v305;
  int8x16x2_t v306;

  v279 = result;
  if (a9)
  {
    v16 = *(ChannelDescription **)(a4 + 8);
    v291 = a3[3];
    v280 = HIDWORD(*(void *)(a2 + 56));
    v17 = a3[7].u32[1];
    v18 = *(int32x2_t *)((char *)v16 + 48);
    v19 = *(int32x2_t *)(*(void *)(*((void *)v16 + 5) + 8 * v17) + 16);
    v278 = v16;
    v277 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v16, (a3[6].i32[1] + v291.i32[1] * v280), v291.u32[0], v17);
    if (*((unsigned char *)*a5 + 24))
    {
      _D0 = **a5;
      __asm { FCVT            H0, D0 }
      v24 = _D0;
    }
    else
    {
      v24 = 32256;
    }
    v25 = *(ChannelDescription **)(a6 + 8);
    v290 = a3[3];
    v26 = a3[7].u32[1];
    v27 = *(int32x2_t *)((char *)v25 + 48);
    v28 = *(int32x2_t *)(*(void *)(*((void *)v25 + 5) + 8 * v26) + 16);
    v276 = v25;
    v275 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v25, (a3[6].i32[1] + v290.i32[1] * v280), v290.u32[0], v26);
    v29 = *(ChannelDescription **)(a7 + 8);
    v289 = a3[3];
    v30 = a3[7].u32[1];
    v31 = *(int32x2_t *)((char *)v29 + 48);
    v32 = *(int32x2_t *)(*(void *)(*((void *)v29 + 5) + 8 * v30) + 16);
    v274 = v29;
    v273 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v29, (a3[6].i32[1] + v289.i32[1] * v280), v289.u32[0], v30);
    v33 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v33 < v280)
    {
      v284 = vmin_u32((uint32x2_t)vmls_s32(v19, v18, v291), (uint32x2_t)v18).u32[0];
      v283 = vmin_u32((uint32x2_t)vmls_s32(v28, v27, v290), (uint32x2_t)v27).u32[0];
      v282 = vmin_u32((uint32x2_t)vmls_s32(v32, v31, v289), (uint32x2_t)v31).u32[0];
      v272 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      v35 = a3[5].u32[1];
      v36 = v35 + a9;
      v37 = vdupq_n_s16(v24);
      do
      {
        v38 = (v272 + v33);
        LocationForTile = ChannelDescription::GetLocationForTile(v278, v38, v291.u32[0], v277);
        if (HIDWORD(LocationForTile)) {
          v40 = v279 + LocationForTile;
        }
        else {
          v40 = 0;
        }
        v41 = ChannelDescription::GetLocationForTile(v276, v38, v290.u32[0], v275);
        if (HIDWORD(v41)) {
          v42 = v279 + v41;
        }
        else {
          v42 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v274, v38, v289.u32[0], v273);
        v45 = (int8x16_t)xmmword_228F61DE0;
        v46.i64[0] = 0xFFFFFFFF00000000;
        v46.i64[1] = 0xFFFFFFFF00000000;
        v47 = v279 + result;
        if (!HIDWORD(result)) {
          v47 = 0;
        }
        if (v40) {
          _ZF = v42 == 0;
        }
        else {
          _ZF = 1;
        }
        if (!_ZF && v47 != 0)
        {
          if (v35 >= 0x20)
          {
            v61 = 0;
            v52 = 0;
            v51 = 0;
            v50 = 0;
            v62 = v284 + v40;
            v63 = v283 + v42;
            v64 = v282 + v47;
            v54 = (int8x16_t)xmmword_228F41CD0;
            v55 = (int8x16_t)xmmword_228F41C00;
            v57 = (int8x16_t)xmmword_228F41CC0;
            v56 = (int8x16_t)xmmword_228F41BE0;
            v58 = (int8x16_t)xmmword_228F41C30;
            v59 = (int8x16_t *)&loc_228F41000;
            v60 = (int8x16_t *)&loc_228F41000;
            do
            {
              v66 = *(int8x16_t *)(v40 + v61);
              v65 = *(int8x16_t *)(v40 + v61 + 16);
              v68 = *(int8x16_t *)(v62 + v61);
              v67 = *(int8x16_t *)(v62 + v61 + 16);
              v69 = (int16x8_t)vzip1q_s8(v68, v66);
              v70 = (int16x8_t)vzip2q_s8(v68, v66);
              v71 = (int16x8_t)vzip1q_s8(v67, v65);
              v72 = (int16x8_t)vzip2q_s8(v67, v65);
              v73 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v69, 0x10uLL), v69);
              v74 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v70, 0x10uLL), v70);
              v75 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v71, 0x10uLL), v71);
              v76 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v72, 0x10uLL), v72);
              v77 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v76, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v76);
              v78 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v75, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v75);
              v79 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v74, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v74);
              v80 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v73, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v73);
              v82 = *(int8x16_t *)(v42 + v61);
              v81 = *(int8x16_t *)(v42 + v61 + 16);
              v84 = *(int8x16_t *)(v63 + v61);
              v83 = *(int8x16_t *)(v63 + v61 + 16);
              v85 = (int16x8_t)vzip1q_s8(v84, v82);
              v86 = (int16x8_t)vzip2q_s8(v84, v82);
              v87 = (int16x8_t)vzip1q_s8(v83, v81);
              v88 = (int16x8_t)vzip2q_s8(v83, v81);
              v89 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v85, 0x10uLL), v85);
              v90 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v86, 0x10uLL), v86);
              v91 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v87, 0x10uLL), v87);
              v92 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v88, 0x10uLL), v88);
              v93 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v92, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v92);
              v94 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v91, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v91);
              v95 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v90, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v90);
              v96 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v89, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v89);
              v97 = vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v94.i8, 3), v94);
              v99 = *(int8x16_t *)(v47 + v61);
              v98 = *(int8x16_t *)(v47 + v61 + 16);
              v101 = *(int8x16_t *)(v64 + v61);
              v100 = *(int8x16_t *)(v64 + v61 + 16);
              v102 = (int16x8_t)vzip1q_s8(v101, v99);
              v103 = (int16x8_t)vzip2q_s8(v101, v99);
              v104 = (int16x8_t)vzip1q_s8(v100, v98);
              v105 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v80.i8, 3), v80), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v79.i8, 3), v79));
              v106 = (int16x8_t)vzip2q_s8(v100, v98);
              v107 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v102, 0x10uLL), v102);
              v108 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v103, 0x10uLL), v103);
              v109 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v78.i8, 3), v78), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v77.i8, 3), v77));
              v110 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v104, 0x10uLL), v104);
              v111 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v106, 0x10uLL), v106);
              v112 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v96.i8, 3), v96), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v95.i8, 3), v95));
              v113 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v111, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v111);
              v114 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v110, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v110);
              v115 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v108, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v108);
              v116 = vaddq_s16(v109, v105);
              v117 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v107, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v107);
              v118 = v116.u16[7];
              v44 = (int8x16_t)vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v117.i8, 3), v117), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v115.i8, 3), v115));
              v43 = (int8x16_t)vaddq_s16(vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v114.i8, 3), v114), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v113.i8, 3), v113)), (int16x8_t)v44);
              v52 += v118;
              v51 += vaddq_s16(vaddq_s16(v97, vaddq_s16(vdupq_lane_s16(*(int16x4_t *)&v93, 3), v93)), v112).u16[7];
              v50 += v43.u16[7];
              v53 = v61 + 32;
              v119 = v61 + 64;
              v61 += 32;
            }
            while (v119 <= v35);
          }
          else
          {
            v50 = 0;
            v51 = 0;
            v52 = 0;
            v53 = 0;
            v54 = (int8x16_t)xmmword_228F41CD0;
            v55 = (int8x16_t)xmmword_228F41C00;
            v57 = (int8x16_t)xmmword_228F41CC0;
            v56 = (int8x16_t)xmmword_228F41BE0;
            v58 = (int8x16_t)xmmword_228F41C30;
            v59 = (int8x16_t *)&loc_228F41000;
            v60 = (int8x16_t *)&loc_228F41000;
          }
          if ((v53 | 8) <= v35)
          {
            do
            {
              v43.i64[0] = *(void *)(v40 + v53);
              v44.i64[0] = *(void *)(v284 + v40 + v53);
              v121 = (int16x8_t)vzip1q_s8(v44, v43);
              v122 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v121, 0x10uLL), v121);
              v123 = vextq_s8(v122, v122, 0xCuLL);
              v124 = (int8x16_t)vaddq_s16((int16x8_t)v123, (int16x8_t)v122);
              v125 = v124.u16[3];
              v126 = v124.u16[7] + v52;
              v124.i64[0] = *(void *)(v42 + v53);
              v123.i64[0] = *(void *)(v283 + v42 + v53);
              v127 = (int16x8_t)vzip1q_s8(v123, v124);
              v128 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v127, 0x10uLL), v127);
              v129 = vextq_s8(v128, v128, 0xCuLL);
              v130 = (int8x16_t)vaddq_s16((int16x8_t)v129, (int16x8_t)v128);
              v52 = v126 + v125;
              v131 = v130.u16[3];
              v130.i64[0] = *(void *)(v47 + v53);
              v51 += v130.u16[7] + v131;
              v129.i64[0] = *(void *)(v282 + v47 + v53);
              v132 = (int16x8_t)vzip1q_s8(v129, v130);
              v133 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v132, 0x10uLL), v132);
              v44 = vextq_s8(v133, v133, 0xCuLL);
              v43 = (int8x16_t)vaddq_s16((int16x8_t)v44, (int16x8_t)v133);
              v50 += v43.u16[7] + v43.u16[3];
              v120 = v53 + 8;
              v134 = v53 + 16;
              v53 += 8;
            }
            while (v134 <= v35);
          }
          else
          {
            v120 = v53;
          }
          v135 = v35 - v120;
          if (v35 > v120)
          {
            v136 = (unsigned __int8 *)(v284 + v120 + v40);
            v137 = (unsigned __int8 *)(v40 + v120);
            v138 = (unsigned __int8 *)(v283 + v120 + v42);
            v139 = (unsigned __int8 *)(v42 + v120);
            v140 = (unsigned __int8 *)(v282 + v120 + v47);
            v141 = (unsigned __int8 *)(v47 + v120);
            do
            {
              v143 = *v137++;
              v142 = v143;
              v144 = *v136++;
              v145 = v144 | (v142 << 8);
              v147 = *v139++;
              v146 = v147;
              v52 += v145;
              v148 = *v138++;
              v149 = v148 | (v146 << 8);
              v151 = *v141++;
              v150 = v151;
              v51 += v149;
              v152 = *v140++;
              v50 += v152 | (v150 << 8);
              --v135;
            }
            while (v135);
            v120 = v35;
          }
          if (v120 + 32 <= v36)
          {
            v154 = v284 + v40;
            v155 = v283 + v42;
            v156 = v282 + v47;
            v157 = (int8x16_t *)a11;
            do
            {
              v159 = *(int8x16_t *)(v40 + v120);
              v158 = *(int8x16_t *)(v40 + v120 + 16);
              v161 = *(int8x16_t *)(v154 + v120);
              v160 = *(int8x16_t *)(v154 + v120 + 16);
              v162 = (int16x8_t)vzip2q_s8(v161, v159);
              v163 = (int16x8_t)vzip2q_s8(v160, v158);
              v164 = (int16x8_t)vzip1q_s8(v160, v158);
              v165 = (int16x8_t)vzip1q_s8(v161, v159);
              v166 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v162, 0x10uLL), v162);
              v167 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v163, 0x10uLL), v163);
              v168 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v164, 0x10uLL), v164);
              v169 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v165, 0x10uLL), v165);
              v170 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v169, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v169);
              v171 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v168, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v168);
              v172 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v167, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v167);
              v173 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v166, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v166);
              v174 = vdupq_n_s16(v52);
              v176 = *(int8x16_t *)(v42 + v120);
              v175 = *(int8x16_t *)(v42 + v120 + 16);
              v178 = *(int8x16_t *)(v155 + v120);
              v177 = *(int8x16_t *)(v155 + v120 + 16);
              v179 = (int16x8_t)vzip2q_s8(v178, v176);
              v180 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v173.i8, 3), v45), v173);
              v181 = (int16x8_t)vzip2q_s8(v177, v175);
              v182 = (int16x8_t)vzip1q_s8(v177, v175);
              v183 = (int16x8_t)vzip1q_s8(v178, v176);
              v184 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v179, 0x10uLL), v179);
              v185 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v181, 0x10uLL), v181);
              v186 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v182, 0x10uLL), v182);
              v187 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v171.i8, 3), v45), v171);
              v188 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v183, 0x10uLL), v183);
              v189 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v170.i8, 3), v45), v170);
              v190 = vdupq_laneq_s16(v189, 7);
              v191 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v186, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v186);
              v192 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v184, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v184);
              v193 = vdupq_laneq_s16(v187, 7);
              v194 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v185, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v185);
              v195 = vaddq_s16(v187, v174);
              v196 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v188, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v188);
              v292.val[0] = (int8x16_t)vaddq_s16(v189, v174);
              v197 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v196.i8, 3), v45), v196);
              v198 = vdupq_laneq_s16(v197, 7);
              v199 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v191.i8, 3), v45), v191);
              v200 = vdupq_laneq_s16(v199, 7);
              v201 = vdupq_n_s16(v51);
              v202 = vaddq_s16(v193, vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v172.i8, 3), v45), v172));
              v203 = vaddq_s16(v199, v201);
              v292.val[1] = (int8x16_t)vaddq_s16(v197, v201);
              v204 = vaddq_s16(v190, v180);
              v206 = *(int8x16_t *)(v47 + v120);
              v205 = *(int8x16_t *)(v47 + v120 + 16);
              v208 = *(int8x16_t *)(v156 + v120);
              v207 = *(int8x16_t *)(v156 + v120 + 16);
              v209 = (int16x8_t)vzip2q_s8(v208, v206);
              v210 = vaddq_s16(v200, vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v194.i8, 3), v45), v194));
              v211 = (int16x8_t)vzip2q_s8(v207, v205);
              v212 = (int16x8_t)vzip1q_s8(v207, v205);
              v213 = vzip1q_s8(v208, v206);
              v214 = vaddq_s16(v198, vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v192.i8, 3), v45), v192));
              v215 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v209, 0x10uLL), v209);
              v216 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v211, 0x10uLL), v211);
              v217 = vdupq_laneq_s16(v204, 7);
              v218 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v212, 0x10uLL), v212);
              v219 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v213, 0x10uLL), (int16x8_t)v213);
              v220 = vaddq_s16(v202, v174);
              v213.i64[0] = 0xFFFFFFFF00000000;
              v213.i64[1] = 0xFFFFFFFF00000000;
              v301.val[0] = (int8x16_t)vaddq_s16(v204, v174);
              v221 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v218, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v218);
              v222 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v215, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v215);
              v223 = vdupq_laneq_s16(v214, 7);
              v224 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v216, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v216);
              v225 = vaddq_s16(v210, v201);
              v226 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v219, (int8x16_t)xmmword_228F61DD0), v213), (int16x8_t)v219);
              v301.val[1] = (int8x16_t)vaddq_s16(v214, v201);
              v227 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v221.i8, 3), v45), v221);
              v306.val[0] = (int8x16_t)vaddq_s16(v220, v217);
              v228 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v226.i8, 3), v45), v226);
              v296.val[0] = (int8x16_t)vaddq_s16(v195, v217);
              v229 = vaddq_s16(vdupq_laneq_s16(v228, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v222.i8, 3), v45), v222));
              v230 = vdupq_laneq_s16(v229, 7);
              v231 = vdupq_n_s16(v50);
              v296.val[1] = (int8x16_t)vaddq_s16(v203, v223);
              v232 = vaddq_s16(vaddq_s16(vaddq_s16(vdupq_laneq_s16(v227, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v224.i8, 3), v45), v224)), v231), v230);
              v52 = v306.val[0].u16[7];
              v304.val[1] = (int8x16_t)vaddq_s16(vaddq_s16(v227, v231), v230);
              v305.val[1] = (int8x16_t)vaddq_s16(v229, v231);
              v295.val[1] = (int8x16_t)vaddq_s16(v228, v231);
              v233 = v59[194];
              v234 = v60[206];
              v306.val[1] = (int8x16_t)vaddq_s16(v225, v223);
              v305.val[0] = (int8x16_t)v37;
              v288.val[0] = vqtbl2q_s8(v301, v55);
              v288.val[1] = vqtbl2q_s8(v305, v54);
              v303.val[0] = vqtbl2q_s8(v301, v58);
              v287.val[0] = vqtbl2q_s8(v301, v56);
              v287.val[1] = vqtbl2q_s8(v305, v57);
              v303.val[1] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F41CF0);
              v301.val[0] = vqtbl2q_s8(v301, v233);
              v301.val[1] = vqtbl2q_s8(v305, v234);
              v305.val[0] = vqtbl2q_s8(v296, v55);
              v304.val[0] = (int8x16_t)v37;
              v305.val[1] = vqtbl2q_s8(v304, v54);
              v300.val[0] = vqtbl2q_s8(v296, v56);
              v300.val[1] = vqtbl2q_s8(v304, v57);
              v297.val[0] = vqtbl2q_s8(v296, v58);
              v297.val[1] = vqtbl2q_s8(v304, (int8x16_t)xmmword_228F41CF0);
              v296.val[0] = vqtbl2q_s8(v296, v233);
              v296.val[1] = vqtbl2q_s8(v304, v234);
              v304.val[0] = vqtbl2q_s8(v292, (int8x16_t)xmmword_228F41C00);
              v295.val[0] = (int8x16_t)v37;
              v293.val[0] = (int8x16_t)v37;
              v293.val[1] = (int8x16_t)v232;
              v304.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F41CD0);
              v298.val[0] = vqtbl2q_s8(v292, (int8x16_t)xmmword_228F41BE0);
              v299.val[0] = vqtbl2q_s8(v292, v58);
              v298.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F41CC0);
              v299.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F41CF0);
              v292.val[0] = vqtbl2q_s8(v292, v233);
              v292.val[1] = vqtbl2q_s8(v295, v234);
              v295.val[0] = vqtbl2q_s8(v306, v233);
              v295.val[1] = vqtbl2q_s8(v293, v234);
              v286 = vqtbl2q_s8(v296, (int8x16_t)xmmword_228F41B50);
              v285 = vqtbl2q_s8(v297, (int8x16_t)xmmword_228F41B50);
              v296.val[1] = vqtbl2q_s8(v300, (int8x16_t)xmmword_228F41B50);
              v54 = (int8x16_t)xmmword_228F41CD0;
              v305.val[0] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F41B50);
              v45 = (int8x16_t)xmmword_228F61DE0;
              v295.val[0] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F41B50);
              v295.val[1] = vqtbl2q_s8(v303, (int8x16_t)xmmword_228F41B50);
              v302.val[0] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F41C30);
              v302.val[1] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F41CF0);
              v300.val[1] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F41B50);
              v43 = vqtbl2q_s8(v292, (int8x16_t)xmmword_228F41B50);
              v44 = vqtbl2q_s8(v299, (int8x16_t)xmmword_228F41B50);
              v58 = (int8x16_t)xmmword_228F41C30;
              v55 = (int8x16_t)xmmword_228F41C00;
              v57 = (int8x16_t)xmmword_228F41CC0;
              v56 = (int8x16_t)xmmword_228F41BE0;
              v302.val[0] = vqtbl2q_s8(v298, (int8x16_t)xmmword_228F41B50);
              v37 = (int16x8_t)v293.val[0];
              v298.val[1] = v293.val[1];
              v302.val[1] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F41BE0);
              v303.val[0] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F41CC0);
              v51 = v306.val[1].u16[7];
              v293.val[0] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F41C00);
              v293.val[1] = vqtbl2q_s8(*(int8x16x2_t *)v37.i8, (int8x16_t)xmmword_228F41CD0);
              v157[2] = vqtbl2q_s8(v304, (int8x16_t)xmmword_228F41B50);
              v157[3] = v302.val[0];
              *v157 = v44;
              v157[1] = v43;
              v157[6] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F41B50);
              v157[7] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F41B50);
              v157[4] = v295.val[1];
              v157[5] = vqtbl2q_s8(v301, (int8x16_t)xmmword_228F41B50);
              v157[14] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F41B50);
              v157[15] = vqtbl2q_s8(v303, (int8x16_t)xmmword_228F41B50);
              v157[12] = v300.val[1];
              v157[13] = v295.val[0];
              v157[10] = v305.val[0];
              v157[11] = v296.val[1];
              v46.i64[0] = 0xFFFFFFFF00000000;
              v46.i64[1] = 0xFFFFFFFF00000000;
              v43.i64[1] = v286.i64[1];
              v157[8] = v285;
              v157[9] = v286;
              v50 = v298.val[1].u16[7];
              result = (unint64_t)&v157[16];
              v153 = v120 + 32;
              v235 = v120 + 64;
              v120 += 32;
              v157 += 16;
            }
            while (v235 <= v36);
          }
          else
          {
            v153 = v120;
            result = a11;
          }
          if (v153 + 8 <= v36)
          {
            do
            {
              v43.i64[0] = *(void *)(v40 + v153);
              v44.i64[0] = *(void *)(v284 + v40 + v153);
              v238 = (int16x8_t)vzip1q_s8(v44, v43);
              v239 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v238, 0x10uLL), v238);
              v240 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v239, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v239);
              v241 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v240.i8, 3), v45);
              v242 = (int8x16_t)vdupq_n_s16(v52);
              v243 = vaddq_s16(vaddq_s16(v240, (int16x8_t)v242), (int16x8_t)v241);
              v52 = v243.u16[7];
              v241.i64[0] = *(void *)(v42 + v153);
              v242.i64[0] = *(void *)(v283 + v42 + v153);
              v244 = (int16x8_t)vzip1q_s8(v242, v241);
              v245 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v244, 0x10uLL), v244);
              v246 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v245, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v245);
              v247 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v246.i8, 3), v45);
              v248 = (int8x16_t)vdupq_n_s16(v51);
              v249 = vaddq_s16(vaddq_s16(v246, (int16x8_t)v248), (int16x8_t)v247);
              v51 = v249.u16[7];
              v247.i64[0] = *(void *)(v47 + v153);
              v248.i64[0] = *(void *)(v282 + v47 + v153);
              v250 = (int16x8_t)vzip1q_s8(v248, v247);
              v251 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v250, 0x10uLL), v250);
              v252 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v251, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v251);
              v253 = vaddq_s16(vaddq_s16(v252, vdupq_n_s16(v50)), (int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v252.i8, 3), v45));
              v50 = v253.u16[7];
              v294.val[0] = vzip1q_s16(v243, v249);
              v294.val[1] = vzip1q_s16(v37, v253);
              v237 = (void *)(result + 64);
              vst2q_s16((__int16 *)result, v294);
              v254 = (__int16 *)(result + 32);
              v43 = (int8x16_t)vzip2q_s16(v243, v249);
              v44 = (int8x16_t)vzip2q_s16(v37, v253);
              vst2q_s16(v254, *(int16x8x2_t *)v43.i8);
              v236 = v153 + 8;
              v255 = v153 + 16;
              v153 += 8;
              result = (unint64_t)v237;
            }
            while (v255 <= v36);
          }
          else
          {
            v236 = v153;
            v237 = (void *)result;
          }
          if (v236 < v36)
          {
            v256 = v36 - v236;
            v257 = (unsigned __int8 *)(v284 + v236 + v40);
            v258 = (unsigned __int8 *)(v40 + v236);
            v259 = (unsigned __int8 *)(v283 + v236 + v42);
            v260 = (unsigned __int8 *)(v42 + v236);
            result = v282 + v236 + v47;
            v261 = (unsigned __int8 *)(v47 + v236);
            do
            {
              v263 = *v258++;
              v262 = v263;
              v264 = *v257++;
              v52 += v264 | (v262 << 8);
              v266 = *v260++;
              v265 = v266;
              v267 = *v259++;
              v51 += v267 | (v265 << 8);
              v269 = *v261++;
              v268 = v269;
              v270 = *(unsigned __int8 *)result++;
              LOWORD(v271) = v52;
              WORD1(v271) = v24;
              WORD2(v271) = v51;
              v50 += v270 | (v268 << 8);
              HIWORD(v271) = v50;
              *v237++ = v271;
              --v256;
            }
            while (v256);
          }
        }
        a11 += a12;
        v33 += a10;
      }
      while (v33 + (unint64_t)a3[7].u32[0] < v280);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<float,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, double **a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unint64_t a11, uint64_t a12)
{
  unint64_t v273 = result;
  if (a9)
  {
    v16 = *(ChannelDescription **)(a4 + 8);
    int32x2_t v332 = a3[3];
    unint64_t v274 = HIDWORD(*(void *)(a2 + 56));
    uint64_t v17 = a3[7].u32[1];
    int32x2_t v18 = *(int32x2_t *)((char *)v16 + 48);
    int32x2_t v19 = *(int32x2_t *)(*(void *)(*((void *)v16 + 5) + 8 * v17) + 16);
    uint64_t v271 = v332.u32[0];
    v272 = v16;
    unsigned int v270 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v16, (a3[6].i32[1] + v332.i32[1] * v274), v332.u32[0], v17);
    v21 = *a5;
    if (*((unsigned char *)*a5 + 24))
    {
      double v20 = *v21;
      *(float *)&double v20 = *v21;
    }
    else
    {
      LODWORD(v20) = 2143289344;
    }
    int32x2_t v262 = *(int32x2_t *)&v20;
    v22 = *(ChannelDescription **)(a6 + 8);
    int32x2_t v328 = a3[3];
    uint64_t v23 = a3[7].u32[1];
    int32x2_t v24 = *(int32x2_t *)((char *)v22 + 48);
    int32x2_t v25 = *(int32x2_t *)(*(void *)(*((void *)v22 + 5) + 8 * v23) + 16);
    uint64_t v268 = v328.u32[0];
    v269 = v22;
    unsigned int v267 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v22, (a3[6].i32[1] + v328.i32[1] * v274), v328.u32[0], v23);
    v26 = *(ChannelDescription **)(a7 + 8);
    int32x2_t v325 = a3[3];
    uint64_t v27 = a3[7].u32[1];
    int32x2_t v28 = *(int32x2_t *)((char *)v26 + 48);
    int32x2_t v29 = *(int32x2_t *)(*(void *)(*((void *)v26 + 5) + 8 * v27) + 16);
    uint64_t v265 = v325.u32[0];
    v266 = v26;
    unsigned int v264 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v26, (a3[6].i32[1] + v325.i32[1] * v274), v325.u32[0], v27);
    uint64_t v30 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v30 < v274)
    {
      int v263 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v32 = a3[5].u32[1];
      uint64_t v280 = vmin_u32((uint32x2_t)vmls_s32(v25, v24, v328), (uint32x2_t)v24).u32[0];
      uint64_t v281 = vmin_u32((uint32x2_t)vmls_s32(v19, v18, v332), (uint32x2_t)v18).u32[0];
      uint64_t v277 = 2 * v280;
      uint64_t v278 = 2 * v281;
      uint64_t v279 = vmin_u32((uint32x2_t)vmls_s32(v29, v28, v325), (uint32x2_t)v28).u32[0];
      uint64_t v276 = 2 * v279;
      unint64_t v33 = v32 + a9;
      int32x4_t v261 = vdupq_lane_s32(v262, 0);
      do
      {
        uint64_t v282 = v30;
        unint64_t v34 = (v263 + v30);
        unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v272, v34, v271, v270);
        if (HIDWORD(LocationForTile)) {
          unint64_t v36 = v273 + LocationForTile;
        }
        else {
          unint64_t v36 = 0;
        }
        unint64_t v37 = ChannelDescription::GetLocationForTile(v269, v34, v268, v267);
        if (HIDWORD(v37)) {
          unint64_t v38 = v273 + v37;
        }
        else {
          unint64_t v38 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v266, v34, v265, v264);
        unint64_t v45 = v273 + result;
        if (!HIDWORD(result)) {
          unint64_t v45 = 0;
        }
        if (v36) {
          BOOL v46 = v38 == 0;
        }
        else {
          BOOL v46 = 1;
        }
        if (!v46 && v45 != 0)
        {
          if (v32 >= 0x20)
          {
            uint64_t v58 = 0;
            unint64_t v59 = v278 + v36;
            uint64_t v60 = v281 + v36;
            unint64_t v61 = v277 + v38;
            v51.i64[0] = 0;
            uint64_t v62 = v280 + v38;
            v50.i64[0] = 0;
            unint64_t v63 = v276 + v45;
            v49.i64[0] = 0;
            uint64_t v64 = v279 + v45;
            v52 = (int8x16_t *)&unk_228F61000;
            v53 = (int8x16_t *)&unk_228F61000;
            v54 = (int8x16_t *)&unk_228F61000;
            v55 = (int8x16_t *)&unk_228F61000;
            v56 = (int8x16_t *)&unk_228F61000;
            v57 = (int8x16_t *)&unk_228F61000;
            do
            {
              int32x2_t v326 = *(int32x2_t *)v50.i8;
              int32x2_t v329 = *(int32x2_t *)v51.i8;
              int32x2_t v333 = *(int32x2_t *)v49.i8;
              int8x16_t v65 = *(int8x16_t *)(v60 + v58);
              int8x16_t v66 = *(int8x16_t *)(v60 + v58 + 16);
              v339.val[1] = *(int8x16_t *)(v36 + v58);
              v337.val[1] = *(int8x16_t *)(v36 + v58 + 16);
              v339.val[0] = *(int8x16_t *)(v59 + v58);
              v337.val[0] = *(int8x16_t *)(v59 + v58 + 16);
              v321.val[0] = vqtbl1q_s8(v66, (int8x16_t)xmmword_228F61DF0);
              v321.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D50);
              v318.val[0] = vqtbl1q_s8(v66, (int8x16_t)xmmword_228F61E00);
              v318.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D90);
              v315.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61DF0);
              v315.val[1] = vqtbl2q_s8(v339, (int8x16_t)xmmword_228F61D50);
              v312.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61E10);
              v312.val[1] = vqtbl2q_s8(v339, (int8x16_t)xmmword_228F61D70);
              v309.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61E00);
              v309.val[1] = vqtbl2q_s8(v339, (int8x16_t)xmmword_228F61D90);
              v306.val[0] = vqtbl1q_s8(v66, (int8x16_t)xmmword_228F61E10);
              v306.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D70);
              v304.val[0] = vqtbl1q_s8(v66, (int8x16_t)xmmword_228F61E20);
              v304.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61DB0);
              v302.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61E20);
              v302.val[1] = vqtbl2q_s8(v339, (int8x16_t)xmmword_228F61DB0);
              v337.val[1] = *(int8x16_t *)(v38 + v58);
              v335.val[1] = *(int8x16_t *)(v38 + v58 + 16);
              v339.val[0] = *(int8x16_t *)(v62 + v58 + 16);
              v337.val[0] = *(int8x16_t *)(v61 + v58);
              v335.val[0] = *(int8x16_t *)(v61 + v58 + 16);
              v299.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61DF0);
              v299.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61D50);
              v343.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61E00);
              v343.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61D90);
              v296.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61E10);
              v296.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61D70);
              v286.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61E20);
              v286.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61DB0);
              v335.val[0] = *(int8x16_t *)(v62 + v58);
              int8x16_t v292 = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61DF0);
              int8x16_t v294 = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D50);
              v289.val[0] = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61E10);
              v289.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D70);
              v346.val[0] = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61E00);
              v346.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D90);
              v345.val[0] = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61E20);
              v345.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61DB0);
              v337.val[1] = *(int8x16_t *)(v45 + v58);
              v335.val[1] = *(int8x16_t *)(v45 + v58 + 16);
              v337.val[0] = *(int8x16_t *)(v63 + v58);
              v335.val[0] = *(int8x16_t *)(v63 + v58 + 16);
              v339.val[0] = *(int8x16_t *)(v64 + v58 + 16);
              v284.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61DF0);
              v284.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61D50);
              v358.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61E00);
              v358.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61D90);
              v353.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61E10);
              v353.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61D70);
              v356.val[0] = vqtbl1q_s8(v339.val[0], (int8x16_t)xmmword_228F61E20);
              v356.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61DB0);
              v335.val[0] = *(int8x16_t *)(v64 + v58);
              v355.val[0] = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61DF0);
              v355.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D50);
              v350.val[0] = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61E10);
              v350.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D70);
              v348.val[0] = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61E00);
              v348.val[1] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61D90);
              v339.val[1] = vqtbl1q_s8(v335.val[0], (int8x16_t)xmmword_228F61E20);
              int8x16_t v67 = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61DB0);
              v337.val[1] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v68 = (int32x4_t)vqtbl2q_s8(v304, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v69 = (int32x4_t)vqtbl2q_s8(v306, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v70 = (int32x4_t)vqtbl2q_s8(v309, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v71 = (int32x4_t)vqtbl2q_s8(v312, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v72 = (int32x4_t)vqtbl2q_s8(v315, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v73 = (int32x4_t)vqtbl2q_s8(v318, (int8x16_t)xmmword_228F61DC0);
              v335.val[0] = vqtbl2q_s8(v321, (int8x16_t)xmmword_228F61DC0);
              v339.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v337.val[1], 0x20uLL), (int32x4_t)v337.val[1]);
              v337.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v68, 0x20uLL), v68);
              int32x4_t v74 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v69, 0x20uLL), v69);
              int32x4_t v75 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v70, 0x20uLL), v70);
              int32x4_t v76 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v71, 0x20uLL), v71);
              int32x4_t v77 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v72, 0x20uLL), v72);
              int32x4_t v78 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v73, 0x20uLL), v73);
              v335.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v335.val[0], 0x20uLL), (int32x4_t)v335.val[0]);
              v335.val[1] = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v75.i8, 1), v75);
              int32x4_t v79 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v76.i8, 1), v76);
              int32x4_t v80 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v77.i8, 1), v77);
              int32x4_t v81 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v78.i8, 1), v78);
              int32x4_t v82 = (int32x4_t)vqtbl2q_s8(v345, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v83 = (int32x4_t)vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v84 = (int32x4_t)vqtbl2q_s8(v296, (int8x16_t)xmmword_228F61DC0);
              v321.val[0] = (int8x16_t)vaddq_s32(v80, v79);
              int32x4_t v85 = (int32x4_t)vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DC0);
              v345.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v74.i8, 1);
              v345.val[0].i64[0] = 0;
              int32x4_t v86 = vaddq_s32((int32x4_t)v345.val[0], v74);
              v345.val[0] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61DC0);
              v345.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v337.val[1].i8, 1);
              v345.val[1].i64[0] = 0;
              v337.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v345.val[1], (int32x4_t)v337.val[1]);
              v345.val[1] = v292;
              v346.val[0] = v294;
              v345.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DC0);
              v346.val[0] = vqtbl2q_s8(v343, (int8x16_t)xmmword_228F61DC0);
              v346.val[1] = vqtbl2q_s8(v299, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v87 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v82, 0x20uLL), v82);
              int32x4_t v88 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v83, 0x20uLL), v83);
              int32x4_t v89 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v84, 0x20uLL), v84);
              int32x4_t v90 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v85, 0x20uLL), v85);
              int32x4_t v91 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v345.val[0], 0x20uLL), (int32x4_t)v345.val[0]);
              v345.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v345.val[1], 0x20uLL), (int32x4_t)v345.val[1]);
              v345.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[0], 0x20uLL), (int32x4_t)v346.val[0]);
              v346.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[1], 0x20uLL), (int32x4_t)v346.val[1]);
              v346.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v339.val[0].i8, 1);
              v346.val[1].i64[0] = 0;
              v339.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v346.val[1], (int32x4_t)v339.val[0]);
              v346.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v89.i8, 1);
              v346.val[1].i64[0] = 0;
              v335.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v335.val[1], (int32x4_t)v339.val[0]);
              v339.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v88.i8, 1);
              v339.val[0].i64[0] = 0;
              v339.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v339.val[0], v88);
              int32x4_t v92 = vdupq_lane_s32(*(int32x2_t *)v87.i8, 1);
              v92.i64[0] = 0;
              v339.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v339 + 16), (int8x16_t)xmmword_228F61DC0);
              v356.val[0] = vqtbl2q_s8(v356, (int8x16_t)xmmword_228F61DC0);
              v335.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v335.val[0].i8, 1), (int32x4_t)v335.val[0]), 3), v86);
              int32x4_t v93 = (int32x4_t)vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61DC0);
              v348.val[0] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61DC0);
              v348.val[1] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61DC0);
              v350.val[0] = vqtbl2q_s8(v355, (int8x16_t)xmmword_228F61DC0);
              v350.val[1] = vqtbl2q_s8(v358, (int8x16_t)xmmword_228F61DC0);
              v337.val[0] = vqtbl2q_s8(v284, (int8x16_t)xmmword_228F61DC0);
              v356.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v356.val[0], 0x20uLL), (int32x4_t)v356.val[0]);
              v348.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[0], 0x20uLL), (int32x4_t)v348.val[0]);
              int8x16_t v44 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v350.val[0], 0x20uLL), (int32x4_t)v350.val[0]);
              v337.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v337.val[0], 0x20uLL), (int32x4_t)v337.val[0]);
              v335.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v335.val[0], vaddq_s32(vdupq_laneq_s32(v81, 3), (int32x4_t)v337.val[1]));
              v337.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v350.val[1], 0x20uLL), (int32x4_t)v350.val[1]);
              int32x4_t v49 = vdupq_lane_s32(*(int32x2_t *)v44.i8, 1);
              v348.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[1], 0x20uLL), (int32x4_t)v348.val[1]);
              int32x4_t v94 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v93, 0x20uLL), v93);
              v355.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v94.i8, 1);
              v356.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v356.val[0].i8, 1);
              v339.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v339.val[1], 0x20uLL), (int32x4_t)v339.val[1]);
              v358.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v339.val[1].i8, 1);
              v358.val[0].i64[0] = 0;
              v356.val[1].i64[0] = 0;
              v355.val[1].i64[0] = 0;
              v339.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v346.val[0].i8, 1), (int32x4_t)v346.val[0]), 3), vaddq_s32((int32x4_t)v346.val[1], v89)), vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v345.val[1].i8, 1), (int32x4_t)v345.val[1]), 3), (int32x4_t)v339.val[0])), vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v90.i8, 1), v90), vaddq_s32(v92, v87)),
                                           vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v345.val[0].i8, 1), (int32x4_t)v345.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v91.i8, 1), v91))));
              int32x4_t v51 = vaddq_s32((int32x4_t)v356.val[1], (int32x4_t)v356.val[0]);
              int32x4_t v50 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v348.val[1].i8, 1), (int32x4_t)v348.val[1]);
              int8x16_t v42 = (int8x16_t)vaddq_s32((int32x4_t)v339.val[0], vdupq_lane_s32(v326, 0));
              int8x16_t v43 = (int8x16_t)vaddq_s32(vaddq_s32(v49, (int32x4_t)v44), v50);
              v337.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v337.val[1].i8, 1), (int32x4_t)v337.val[1]), 3), v51);
              v51.i32[0] = vaddq_s32(vaddq_s32(*(int32x4_t *)&v335, vaddq_s32(*(int32x4_t *)(&v335 + 16), *(int32x4_t *)&v321)), vdupq_lane_s32(v329, 0)).i32[3];
              v335.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v337.val[0].i8, 1), (int32x4_t)v337.val[0]), 3), vaddq_s32((int32x4_t)v355.val[1], v94)), (int32x4_t)v337.val[1]);
              int8x16_t v40 = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v348.val[0].i8, 1), (int32x4_t)v348.val[0]), vaddq_s32((int32x4_t)v358.val[0], (int32x4_t)v339.val[1])), (int32x4_t)v43);
              int8x16_t v41 = (int8x16_t)vdupq_lane_s32(v333, 0);
              unint64_t v48 = v58 + 32;
              v50.i32[0] = v42.i32[3];
              unint64_t v95 = v58 + 64;
              int8x16_t v39 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v335.val[0], (int32x4_t)v40), (int32x4_t)v41);
              v58 += 32;
              v49.i32[0] = v39.i32[3];
            }
            while (v95 <= v32);
          }
          else
          {
            unint64_t v48 = 0;
            v49.i64[0] = 0;
            v50.i64[0] = 0;
            v51.i64[0] = 0;
            v52 = (int8x16_t *)&unk_228F61000;
            v53 = (int8x16_t *)&unk_228F61000;
            v54 = (int8x16_t *)&unk_228F61000;
            v55 = (int8x16_t *)&unk_228F61000;
            v56 = (int8x16_t *)&unk_228F61000;
            v57 = (int8x16_t *)&unk_228F61000;
          }
          if ((v48 | 8) <= v32)
          {
            int8x16_t v42 = 0uLL;
            do
            {
              v39.i64[0] = *(void *)(v36 + v48);
              v40.i64[0] = *(void *)(v281 + v36 + v48);
              v41.i64[0] = *(void *)(v278 + v36 + v48);
              int8x16_t v97 = vzip1q_s8((int8x16_t)0, v40);
              int8x16_t v98 = vzip1q_s8(v41, v39);
              int32x4_t v99 = (int32x4_t)vzip1q_s8(v97, v98);
              int32x4_t v100 = (int32x4_t)vzip2q_s8(v97, v98);
              int32x4_t v101 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v99, 0x20uLL), v99);
              int32x4_t v102 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v100, 0x20uLL), v100);
              int8x16_t v103 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v102.i8, 1);
              int8x16_t v104 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v101.i8, 1), v101);
              int8x16_t v105 = (int8x16_t)vaddq_s32((int32x4_t)v103, vaddq_s32(v102, vdupq_lane_s32(*(int32x2_t *)v51.i8, 0)));
              v105.i64[0] = *(void *)(v38 + v48);
              v103.i64[0] = *(void *)(v280 + v38 + v48);
              int v106 = v105.i32[3] + v104.i32[3];
              v104.i64[0] = *(void *)(v277 + v38 + v48);
              int8x16_t v107 = vzip1q_s8((int8x16_t)0, v103);
              int8x16_t v108 = vzip1q_s8(v104, v105);
              int32x4_t v109 = (int32x4_t)vzip1q_s8(v107, v108);
              int32x4_t v110 = (int32x4_t)vzip2q_s8(v107, v108);
              int32x4_t v111 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v110, 0x20uLL), v110);
              int8x16_t v112 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v111.i8, 1);
              int32x4_t v113 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v109, 0x20uLL), v109);
              int8x16_t v114 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v113.i8, 1), v113);
              int8x16_t v115 = (int8x16_t)vaddq_s32((int32x4_t)v112, vaddq_s32(v111, vdupq_lane_s32(*(int32x2_t *)v50.i8, 0)));
              v51.i32[0] = v106;
              v115.i64[0] = *(void *)(v45 + v48);
              v112.i64[0] = *(void *)(v279 + v45 + v48);
              v50.i32[0] = v115.i32[3] + v114.i32[3];
              v114.i64[0] = *(void *)(v276 + v45 + v48);
              int8x16_t v116 = vzip1q_s8((int8x16_t)0, v112);
              int8x16_t v117 = vzip1q_s8(v114, v115);
              int32x4_t v118 = (int32x4_t)vzip1q_s8(v116, v117);
              int32x4_t v119 = (int32x4_t)vzip2q_s8(v116, v117);
              int32x4_t v120 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v119, 0x20uLL), v119);
              int8x16_t v40 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v120.i8, 1);
              int32x4_t v121 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v118, 0x20uLL), v118);
              int8x16_t v41 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v121.i8, 1), v121);
              int8x16_t v39 = (int8x16_t)vaddq_s32((int32x4_t)v40, vaddq_s32(v120, vdupq_lane_s32(*(int32x2_t *)v49.i8, 0)));
              v49.i32[0] = v39.i32[3] + v41.i32[3];
              unint64_t v96 = v48 + 8;
              unint64_t v122 = v48 + 16;
              v48 += 8;
            }
            while (v122 <= v32);
          }
          else
          {
            unint64_t v96 = v48;
          }
          if (v96 <= v32) {
            unint64_t v123 = v32;
          }
          else {
            unint64_t v123 = v96;
          }
          if (v123 + 32 <= v33)
          {
            unint64_t v125 = v278 + v36;
            uint64_t v126 = v281 + v36;
            unint64_t v127 = v277 + v38;
            uint64_t v128 = v280 + v38;
            unint64_t v129 = v276 + v45;
            uint64_t v130 = v279 + v45;
            unint64_t v131 = a11;
            do
            {
              int32x2_t v327 = *(int32x2_t *)v50.i8;
              int32x2_t v330 = *(int32x2_t *)v51.i8;
              int32x2_t v334 = *(int32x2_t *)v49.i8;
              v336.val[1] = *(int8x16_t *)(v36 + v123);
              v338.val[1] = *(int8x16_t *)(v36 + v123 + 16);
              int8x16_t v133 = *(int8x16_t *)(v126 + v123);
              int8x16_t v132 = *(int8x16_t *)(v126 + v123 + 16);
              int8x16_t v134 = v52[226];
              v347.val[0] = vqtbl1q_s8(v133, v134);
              v336.val[0] = *(int8x16_t *)(v125 + v123);
              v338.val[0] = *(int8x16_t *)(v125 + v123 + 16);
              int8x16_t v135 = v53[219];
              v347.val[1] = vqtbl2q_s8(v336, v135);
              int8x16_t v136 = v54[225];
              int8x16_t v137 = v55[215];
              int8x16_t v322 = vqtbl1q_s8(v133, v136);
              int8x16_t v324 = vqtbl2q_s8(v336, v137);
              int8x16_t v319 = vqtbl1q_s8(v132, v134);
              int8x16_t v320 = vqtbl2q_s8(v338, v135);
              int8x16_t v316 = vqtbl1q_s8(v132, v136);
              int8x16_t v317 = vqtbl2q_s8(v338, v137);
              int8x16_t v138 = v56[223];
              int8x16_t v139 = v57[213];
              int8x16_t v313 = vqtbl1q_s8(v132, v138);
              int8x16_t v314 = vqtbl2q_s8(v338, v139);
              int8x16_t v310 = vqtbl1q_s8(v132, (int8x16_t)xmmword_228F61E00);
              int8x16_t v311 = vqtbl2q_s8(v338, (int8x16_t)xmmword_228F61D90);
              int8x16_t v307 = vqtbl1q_s8(v133, v138);
              int8x16_t v308 = vqtbl2q_s8(v336, v139);
              v305.val[0] = vqtbl1q_s8(v133, (int8x16_t)xmmword_228F61E00);
              v305.val[1] = vqtbl2q_s8(v336, (int8x16_t)xmmword_228F61D90);
              v336.val[1] = *(int8x16_t *)(v38 + v123);
              v338.val[1] = *(int8x16_t *)(v38 + v123 + 16);
              v336.val[0] = *(int8x16_t *)(v127 + v123);
              v338.val[0] = *(int8x16_t *)(v127 + v123 + 16);
              int8x16_t v141 = *(int8x16_t *)(v128 + v123);
              int8x16_t v140 = *(int8x16_t *)(v128 + v123 + 16);
              v303.val[0] = vqtbl1q_s8(v140, v134);
              v303.val[1] = vqtbl2q_s8(v338, v135);
              int8x16_t v300 = vqtbl1q_s8(v140, v136);
              int8x16_t v301 = vqtbl2q_s8(v338, v137);
              int8x16_t v293 = vqtbl1q_s8(v140, v138);
              int8x16_t v295 = vqtbl2q_s8(v338, v139);
              int8x16_t v287 = vqtbl1q_s8(v140, (int8x16_t)xmmword_228F61E00);
              int8x16_t v288 = vqtbl2q_s8(v338, (int8x16_t)xmmword_228F61D90);
              int8x16_t v297 = vqtbl1q_s8(v141, v134);
              int8x16_t v298 = vqtbl2q_s8(v336, v135);
              int8x16_t v290 = vqtbl1q_s8(v141, v136);
              int8x16_t v291 = vqtbl2q_s8(v336, v137);
              v344.val[0] = vqtbl1q_s8(v141, v138);
              v344.val[1] = vqtbl2q_s8(v336, v139);
              v354.val[0] = vqtbl1q_s8(v141, (int8x16_t)xmmword_228F61E00);
              v354.val[1] = vqtbl2q_s8(v336, (int8x16_t)xmmword_228F61D90);
              v336.val[0] = *(int8x16_t *)(v45 + v123);
              v351.val[1] = *(int8x16_t *)(v45 + v123 + 16);
              long long v142 = *(_OWORD *)(v129 + v123);
              v351.val[0] = *(int8x16_t *)(v129 + v123 + 16);
              int8x16_t v143 = *(int8x16_t *)(v130 + v123);
              v338.val[1] = *(int8x16_t *)(v130 + v123 + 16);
              v285.val[0] = vqtbl1q_s8(v338.val[1], v134);
              v285.val[1] = vqtbl2q_s8(v351, v135);
              v342.val[0] = vqtbl1q_s8(v338.val[1], v136);
              v342.val[1] = vqtbl2q_s8(v351, v137);
              v357.val[0] = vqtbl1q_s8(v338.val[1], v138);
              v357.val[1] = vqtbl2q_s8(v351, v139);
              v352.val[0] = vqtbl1q_s8(v338.val[1], (int8x16_t)xmmword_228F61E00);
              v352.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D90);
              v283.val[0] = vqtbl1q_s8(v143, v134);
              v283.val[1] = vqtbl2q_s8(v336, v135);
              v351.val[0] = vqtbl1q_s8(v143, v136);
              v351.val[1] = vqtbl2q_s8(v336, v137);
              v349.val[0] = vqtbl1q_s8(v143, v138);
              v349.val[1] = vqtbl2q_s8(v336, v139);
              v341.val[0] = vqtbl1q_s8(v143, (int8x16_t)xmmword_228F61E00);
              v341.val[1] = vqtbl2q_s8(v336, (int8x16_t)xmmword_228F61D90);
              v336.val[0] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v307;
              v338.val[0] = v308;
              int32x4_t v144 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v310;
              v338.val[0] = v311;
              int32x4_t v145 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v313;
              v338.val[0] = v314;
              int32x4_t v146 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v316;
              v338.val[0] = v317;
              int32x4_t v147 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v319;
              v338.val[0] = v320;
              int32x4_t v148 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v322;
              v338.val[0] = v324;
              int32x4_t v149 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61DC0);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v336.val[0], 0x20uLL), (int32x4_t)v336.val[0]);
              int32x4_t v150 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v144, 0x20uLL), v144);
              int32x4_t v151 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v145, 0x20uLL), v145);
              int32x4_t v152 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v146, 0x20uLL), v146);
              int32x4_t v153 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v147, 0x20uLL), v147);
              int32x4_t v154 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v148, 0x20uLL), v148);
              v336.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v336.val[1], 0x20uLL), (int32x4_t)v336.val[1]);
              int32x4_t v155 = vdupq_lane_s32(*(int32x2_t *)v336.val[1].i8, 1);
              v155.i64[0] = 0;
              int32x4_t v156 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v149, 0x20uLL), v149);
              int32x4_t v157 = vaddq_s32(v155, (int32x4_t)v336.val[1]);
              int32x4_t v158 = vdupq_lane_s32(*(int32x2_t *)v156.i8, 1);
              v158.i64[0] = 0;
              int32x4_t v323 = vaddq_s32(v158, v156);
              int32x4_t v159 = vdupq_lane_s32(*(int32x2_t *)v154.i8, 1);
              v159.i64[0] = 0;
              int32x4_t v160 = vaddq_s32(v159, v154);
              v354.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61DC0);
              v354.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v153.i8, 1);
              v354.val[1].i64[0] = 0;
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[1], v153);
              int32x4_t v161 = (int32x4_t)vqtbl2q_s8(v344, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v162 = vdupq_lane_s32(*(int32x2_t *)v152.i8, 1);
              v162.i64[0] = 0;
              int32x4_t v163 = vaddq_s32(v162, v152);
              v336.val[1] = v287;
              v338.val[0] = v288;
              int32x4_t v164 = (int32x4_t)vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v344.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v151.i8, 1);
              v344.val[0].i64[0] = 0;
              int32x4_t v165 = vaddq_s32((int32x4_t)v344.val[0], v151);
              v336.val[1] = v293;
              v338.val[0] = v295;
              v344.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v344.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v150.i8, 1);
              v344.val[1].i64[0] = 0;
              int32x4_t v166 = vaddq_s32((int32x4_t)v344.val[1], v150);
              v336.val[1] = v300;
              v338.val[0] = v301;
              v344.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v347.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v336.val[0].i8, 1);
              v347.val[0].i64[0] = 0;
              v347.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v347.val[0], (int32x4_t)v336.val[0]);
              v336.val[0] = vqtbl2q_s8(v303, (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v290;
              v338.val[0] = v291;
              v347.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v336.val[1] = v297;
              v338.val[0] = v298;
              v336.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v336 + 16), (int8x16_t)xmmword_228F61DC0);
              v354.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v354.val[0], 0x20uLL), (int32x4_t)v354.val[0]);
              int32x4_t v167 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v161, 0x20uLL), v161);
              int32x4_t v168 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v164, 0x20uLL), v164);
              int32x4_t v169 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v344.val[0], 0x20uLL), (int32x4_t)v344.val[0]);
              v344.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v344.val[1], 0x20uLL), (int32x4_t)v344.val[1]);
              v338.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v336.val[0], 0x20uLL), (int32x4_t)v336.val[0]);
              v344.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v347.val[1], 0x20uLL), (int32x4_t)v347.val[1]);
              v336.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v336.val[1], 0x20uLL), (int32x4_t)v336.val[1]);
              v347.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v336.val[1].i8, 1);
              v347.val[1].i64[0] = 0;
              v347.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v347.val[1], (int32x4_t)v336.val[1]);
              v336.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v165, 3), v160);
              int32x4_t v170 = vdupq_lane_s32(*(int32x2_t *)v344.val[1].i8, 1);
              v170.i64[0] = 0;
              v336.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v338.val[0].i8, 1);
              v338.val[1] = (int8x16_t)vaddq_s32(v170, (int32x4_t)v344.val[1]);
              v336.val[0].i64[0] = 0;
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v336.val[0], (int32x4_t)v338.val[0]);
              v338.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v344.val[0].i8, 1);
              v338.val[0].i64[0] = 0;
              v338.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v338.val[0], (int32x4_t)v344.val[0]);
              v344.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v169.i8, 1);
              v344.val[0].i64[0] = 0;
              v344.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v168.i8, 1);
              int32x4_t v171 = vaddq_s32((int32x4_t)v344.val[0], v169);
              v344.val[1].i64[0] = 0;
              int32x4_t v172 = vaddq_s32((int32x4_t)v344.val[1], v168);
              v344.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v354.val[0].i8, 1);
              v344.val[0].i64[0] = 0;
              v344.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v167.i8, 1);
              v344.val[1].i64[0] = 0;
              int32x4_t v173 = vaddq_s32((int32x4_t)v344.val[1], v167);
              v354.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v344.val[0], (int32x4_t)v354.val[0]);
              v341.val[0] = vqtbl2q_s8(v341, (int8x16_t)xmmword_228F61DC0);
              v341.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v347.val[0], 3), v157);
              v349.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61DC0);
              v349.val[1] = vqtbl2q_s8(v352, (int8x16_t)xmmword_228F61DC0);
              v352.val[1] = vqtbl2q_s8(v357, (int8x16_t)xmmword_228F61DC0);
              v357.val[0] = vqtbl2q_s8(v342, (int8x16_t)xmmword_228F61DC0);
              v357.val[1] = vqtbl2q_s8(v285, (int8x16_t)xmmword_228F61DC0);
              v342.val[0] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v174 = (int32x4_t)vqtbl2q_s8(v283, (int8x16_t)xmmword_228F61DC0);
              v351.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v341.val[1], 3);
              v342.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v172, 3), (int32x4_t)v336.val[0]);
              v351.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v336.val[1], 3);
              v354.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(v163, 3), (int32x4_t)v354.val[1]), (int32x4_t)v351.val[1]);
              v344.val[0] = (int8x16_t)vdupq_lane_s32(v330, 0);
              v352.val[0] = (int8x16_t)vaddq_s32(v165, (int32x4_t)v344.val[0]);
              int32x4_t v331 = vaddq_s32((int32x4_t)v336.val[1], (int32x4_t)v344.val[0]);
              int32x4_t v175 = vaddq_s32(v163, (int32x4_t)v351.val[1]);
              v338.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v173, 3), (int32x4_t)v338.val[1]);
              int32x4_t v176 = vaddq_s32((int32x4_t)v341.val[1], (int32x4_t)v344.val[0]);
              v336.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v347.val[0], (int32x4_t)v344.val[0]);
              v344.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v354.val[0], 3), (int32x4_t)v347.val[1]);
              int32x4_t v177 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v341.val[0], 0x20uLL), (int32x4_t)v341.val[0]);
              int32x4_t v178 = vaddq_s32(vaddq_s32(vdupq_laneq_s32(v166, 3), v323), (int32x4_t)v351.val[0]);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v349.val[0], 0x20uLL), (int32x4_t)v349.val[0]);
              v341.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v344.val[1], 3);
              v347.val[0] = (int8x16_t)vdupq_lane_s32(v327, 0);
              v347.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(v166, (int32x4_t)v344.val[0]), (int32x4_t)v351.val[0]);
              v349.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v349.val[1], 0x20uLL), (int32x4_t)v349.val[1]);
              int32x4_t v179 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v352.val[1], 0x20uLL), (int32x4_t)v352.val[1]);
              v351.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v342.val[1], 3);
              v352.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(v171, 3), (int32x4_t)v338.val[0]), (int32x4_t)v351.val[0]);
              v351.val[1] = (int8x16_t)vaddq_s32(v172, (int32x4_t)v347.val[0]);
              v341.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v342.val[1], (int32x4_t)v347.val[0]);
              v338.val[0] = (int8x16_t)vaddq_s32(v173, (int32x4_t)v347.val[0]);
              v349.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[0], (int32x4_t)v347.val[0]);
              v351.val[0] = (int8x16_t)vaddq_s32(v171, (int32x4_t)v351.val[0]);
              v354.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v357.val[0], 0x20uLL), (int32x4_t)v357.val[0]);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v357.val[1], 0x20uLL), (int32x4_t)v357.val[1]);
              int32x4_t v180 = vaddq_s32((int32x4_t)v344.val[1], (int32x4_t)v347.val[0]);
              v357.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v342.val[0], 0x20uLL), (int32x4_t)v342.val[0]);
              int32x4_t v181 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v174, 0x20uLL), v174);
              int32x4_t v182 = vdupq_lane_s32(*(int32x2_t *)v181.i8, 1);
              v342.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v338.val[1], (int32x4_t)v341.val[0]);
              v182.i64[0] = 0;
              int32x4_t v183 = vaddq_s32(v182, v181);
              v338.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v357.val[1].i8, 1);
              v344.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v338.val[0], (int32x4_t)v341.val[0]);
              v338.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v357.val[0].i8, 1);
              v338.val[1].i64[0] = 0;
              v357.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v338.val[1], (int32x4_t)v357.val[1]);
              int32x4_t v184 = vaddq_s32((int32x4_t)v354.val[1], (int32x4_t)v344.val[0]);
              v341.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v354.val[0].i8, 1);
              v338.val[0].i64[0] = 0;
              v338.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v338.val[0], (int32x4_t)v357.val[0]);
              int32x4_t v185 = vaddq_s32(v175, (int32x4_t)v344.val[0]);
              v338.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v179.i8, 1);
              v341.val[0].i64[0] = 0;
              v341.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v341.val[0], (int32x4_t)v354.val[0]);
              int32x4_t v186 = vaddq_s32(v178, (int32x4_t)v344.val[0]);
              v354.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v349.val[1].i8, 1);
              v354.val[0].i64[0] = 0;
              v342.val[1] = (int8x16_t)vdupq_laneq_s32(v178, 3);
              v338.val[0].i64[0] = 0;
              int32x4_t v187 = vaddq_s32((int32x4_t)v338.val[0], v179);
              v338.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[0], (int32x4_t)v349.val[1]);
              v354.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v342.val[0], 3);
              v349.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v336.val[0].i8, 1);
              v349.val[1].i64[0] = 0;
              int32x4_t v188 = vaddq_s32((int32x4_t)v349.val[1], (int32x4_t)v336.val[0]);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v352.val[1], (int32x4_t)v347.val[0]);
              v349.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v177.i8, 1);
              v349.val[1].i64[0] = 0;
              v344.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v349.val[1], v177);
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[0], (int32x4_t)v347.val[0]);
              v351.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v188, 3), (int32x4_t)v357.val[1]);
              v357.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v342.val[0], (int32x4_t)v347.val[0]);
              v352.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v344.val[0], 3), v183);
              v342.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v352.val[1], 3);
              v349.val[1] = (int8x16_t)vdupq_lane_s32(v334, 0);
              int8x16_t v39 = (int8x16_t)vaddq_s32(v184, (int32x4_t)v342.val[1]);
              v351.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[0], (int32x4_t)v342.val[0]);
              v342.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(v188, (int32x4_t)v349.val[1]), (int32x4_t)v342.val[0]);
              int32x4_t v189 = vaddq_s32((int32x4_t)v344.val[0], (int32x4_t)v349.val[1]);
              int8x16_t v190 = (int8x16_t)vzip2q_s32(v186, (int32x4_t)v357.val[1]);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v352.val[0], (int32x4_t)v342.val[1]);
              v357.val[1] = (int8x16_t)vzip1q_s32(v186, (int32x4_t)v357.val[1]);
              int8x16_t v191 = (int8x16_t)vzip2q_s32(v176, v180);
              int32x4_t v192 = vzip1q_s32(v176, v180);
              v344.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v347.val[1], (int32x4_t)v344.val[1]);
              v344.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v347.val[1], (int32x4_t)v344.val[1]);
              v352.val[0] = (int8x16_t)vaddq_s32(v331, (int32x4_t)v342.val[1]);
              int32x4_t v193 = vzip2q_s32((int32x4_t)v344.val[1], vuzp2q_s32((int32x4_t)v344.val[1], v261));
              v193.i32[3] = v342.val[0].i32[1];
              v342.val[1] = (int8x16_t)vaddq_s32(v185, (int32x4_t)v342.val[1]);
              int8x16_t v194 = vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v344.val[0]), v344.val[0], 4uLL);
              v194.i32[3] = v342.val[0].i32[3];
              v344.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)vextq_s8(v344.val[0], v344.val[0], 8uLL), v261);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v357.val[0], (int32x4_t)v354.val[0]);
              v344.val[0].i32[3] = v342.val[0].i32[2];
              v344.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v344.val[1], v261);
              v344.val[1].i32[3] = v342.val[0].i32[0];
              v351.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[1], (int32x4_t)v354.val[0]);
              v342.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v336.val[1], (int32x4_t)v349.val[0]);
              int32x4_t v195 = vzip2q_s32((int32x4_t)v342.val[0], vuzp2q_s32((int32x4_t)v342.val[0], v261));
              v195.i32[3] = v189.i32[1];
              v341.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v341.val[1], (int32x4_t)v354.val[0]);
              v336.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v336.val[1], (int32x4_t)v349.val[0]);
              v349.val[0] = vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v336.val[1]), v336.val[1], 4uLL);
              v349.val[0].i32[3] = v189.i32[3];
              int32x4_t v49 = vaddq_s32((int32x4_t)v354.val[1], (int32x4_t)v354.val[0]);
              v336.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)vextq_s8(v336.val[1], v336.val[1], 8uLL), v261);
              v336.val[1].i32[3] = v189.i32[2];
              v354.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v342.val[0], v261);
              v342.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[0], (int32x4_t)v349.val[1]);
              v354.val[1].i32[3] = v189.i32[0];
              int32x4_t v196 = vzip2q_s32((int32x4_t)v357.val[1], vuzp2q_s32((int32x4_t)v357.val[1], v261));
              v196.i32[3] = v342.val[0].i32[1];
              *(int8x16_t *)(v131 + 32) = v336.val[1];
              *(int8x16_t *)(v131 + 48) = v349.val[0];
              v336.val[1] = vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v190), v190, 4uLL);
              v336.val[1].i32[3] = v342.val[0].i32[3];
              int32x4_t v197 = vzip2q_s32((int32x4_t)vextq_s8(v190, v190, 8uLL), v261);
              v357.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v357.val[1], v261);
              v357.val[1].i32[3] = v342.val[0].i32[0];
              v197.i32[3] = v342.val[0].i32[2];
              v352.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v352.val[1], (int32x4_t)v349.val[1]);
              *(int8x16_t *)unint64_t v131 = v354.val[1];
              *(int32x4_t *)(v131 + 16) = v195;
              v354.val[1] = (int8x16_t)vzip2q_s32(v192, vuzp2q_s32(v192, v261));
              v342.val[0] = vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v191), v191, 4uLL);
              v354.val[1].i32[3] = v352.val[1].i32[1];
              v342.val[0].i32[3] = v352.val[1].i32[3];
              int32x4_t v198 = vzip2q_s32((int32x4_t)vextq_s8(v191, v191, 8uLL), v261);
              v198.i32[3] = v352.val[1].i32[2];
              v349.val[0] = (int8x16_t)vzip1q_s32(v192, v261);
              v349.val[0].i32[3] = v352.val[1].i32[0];
              v338.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v338.val[0], 3), (int32x4_t)v338.val[1]);
              *(int32x4_t *)(v131 + 96) = v198;
              *(int8x16_t *)(v131 + 112) = v342.val[0];
              v352.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v338.val[1], 3);
              *(int8x16_t *)(v131 + 64) = v349.val[0];
              *(int8x16_t *)(v131 + 80) = v354.val[1];
              *(int8x16_t *)(v131 + 128) = v344.val[1];
              v349.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v351.val[0], 3);
              int8x16_t v43 = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32(vaddq_s32(vdupq_laneq_s32(v187, 3), (int32x4_t)v341.val[0]), (int32x4_t)v352.val[1]), (int32x4_t)v349.val[1]), (int32x4_t)v349.val[0]);
              int32x4_t v199 = vaddq_s32(vaddq_s32(vaddq_s32(v187, (int32x4_t)v352.val[1]), (int32x4_t)v349.val[1]), (int32x4_t)v349.val[0]);
              v338.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v338.val[1], (int32x4_t)v349.val[1]), (int32x4_t)v349.val[0]);
              v338.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v338.val[0], (int32x4_t)v349.val[1]), (int32x4_t)v349.val[0]);
              v349.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v342.val[1], v49);
              v349.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v342.val[1], v49);
              *(int32x4_t *)(v131 + 224) = v197;
              *(int8x16_t *)(v131 + 240) = v336.val[1];
              *(int8x16_t *)(v131 + 160) = v344.val[0];
              *(int8x16_t *)(v131 + 176) = v194;
              v336.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v352.val[0], (int32x4_t)v341.val[1]);
              v341.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v352.val[0], (int32x4_t)v341.val[1]);
              *(int8x16_t *)(v131 + 192) = v357.val[1];
              *(int32x4_t *)(v131 + 208) = v196;
              v351.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v39, (int32x4_t)v357.val[0]);
              *(int32x4_t *)(v131 + 144) = v193;
              v352.val[0] = vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v351.val[0]), v351.val[0], 4uLL);
              v352.val[0].i32[3] = v43.i32[3];
              v351.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)vextq_s8(v351.val[0], v351.val[0], 8uLL), v261);
              v351.val[0].i32[3] = v43.i32[2];
              *(int8x16_t *)(v131 + 480) = v351.val[0];
              *(int8x16_t *)(v131 + 496) = v352.val[0];
              v351.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v39, (int32x4_t)v357.val[0]);
              v352.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v351.val[0], vuzp2q_s32((int32x4_t)v351.val[0], v261));
              v351.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v351.val[0], v261);
              v352.val[0].i32[3] = v43.i32[1];
              v351.val[0].i32[3] = v43.i32[0];
              *(int8x16_t *)(v131 + 448) = v351.val[0];
              *(int8x16_t *)(v131 + 464) = v352.val[0];
              int8x16_t v44 = vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v349.val[0]), v349.val[0], 4uLL);
              v44.i32[3] = v199.i32[3];
              v349.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)vextq_s8(v349.val[0], v349.val[0], 8uLL), v261);
              v349.val[0].i32[3] = v199.i32[2];
              *(int8x16_t *)(v131 + 416) = v349.val[0];
              *(int8x16_t *)(v131 + 432) = v44;
              v349.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v349.val[1], vuzp2q_s32((int32x4_t)v349.val[1], v261));
              v349.val[0].i32[3] = v199.i32[1];
              v349.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v349.val[1], v261);
              v349.val[1].i32[3] = v199.i32[0];
              int8x16_t v200 = (int8x16_t)vzip2q_s32((int32x4_t)v336.val[0], (int32x4_t)v351.val[1]);
              *(int8x16_t *)(v131 + 384) = v349.val[1];
              *(int8x16_t *)(v131 + 400) = v349.val[0];
              v349.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v341.val[1], vuzp2q_s32((int32x4_t)v341.val[1], v261));
              int32x4_t v50 = (int32x4_t)vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v336.val[1]), v336.val[1], 4uLL);
              v349.val[0].i32[3] = v338.val[1].i32[1];
              v50.i32[3] = v338.val[1].i32[3];
              v336.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)vextq_s8(v336.val[1], v336.val[1], 8uLL), v261);
              v336.val[1].i32[3] = v338.val[1].i32[2];
              v336.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v336.val[0], (int32x4_t)v351.val[1]);
              int32x4_t v51 = vzip1q_s32((int32x4_t)v341.val[1], v261);
              v51.i32[3] = v338.val[1].i32[0];
              *(int8x16_t *)(v131 + 352) = v336.val[1];
              *(int32x4_t *)(v131 + 368) = v50;
              *(int32x4_t *)(v131 + 320) = v51;
              *(int8x16_t *)(v131 + 336) = v349.val[0];
              int8x16_t v41 = (int8x16_t)vzip2q_s32((int32x4_t)v336.val[0], vuzp2q_s32((int32x4_t)v336.val[0], v261));
              v41.i32[3] = v338.val[0].i32[1];
              int8x16_t v42 = vextq_s8((int8x16_t)vzip2q_s32(v261, (int32x4_t)v200), v200, 4uLL);
              int32x4_t v201 = vzip2q_s32((int32x4_t)vextq_s8(v200, v200, 8uLL), v261);
              v42.i32[3] = v338.val[0].i32[3];
              v201.i32[3] = v338.val[0].i32[2];
              int8x16_t v40 = (int8x16_t)vzip1q_s32((int32x4_t)v336.val[0], v261);
              v40.i32[3] = v338.val[0].i32[0];
              *(int32x4_t *)(v131 + 288) = v201;
              *(int8x16_t *)(v131 + 304) = v42;
              *(int8x16_t *)(v131 + 256) = v40;
              *(int8x16_t *)(v131 + 272) = v41;
              result = v131 + 512;
              unint64_t v124 = v123 + 32;
              unint64_t v202 = v123 + 64;
              v51.i32[0] = v39.i32[3];
              v123 += 32;
              v50.i32[0] = v357.val[0].i32[3];
              v131 += 512;
              v49.i32[0] = v43.i32[3];
            }
            while (v202 <= v33);
          }
          else
          {
            unint64_t v124 = v123;
            result = a11;
          }
          if (v124 + 8 <= v33)
          {
            do
            {
              v39.i64[0] = *(void *)(v36 + v124);
              v40.i64[0] = *(void *)(v281 + v36 + v124);
              v41.i64[0] = *(void *)(v278 + v36 + v124);
              int8x16_t v205 = vzip1q_s8((int8x16_t)0, v40);
              int8x16_t v206 = vzip1q_s8(v41, v39);
              int32x4_t v207 = (int32x4_t)vzip1q_s8(v205, v206);
              int32x4_t v208 = (int32x4_t)vzip2q_s8(v205, v206);
              int8x16_t v209 = (int8x16_t)vshlq_n_s64((int64x2_t)v208, 0x20uLL);
              int32x4_t v210 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v207, 0x20uLL), v207);
              int32x4_t v211 = vdupq_lane_s32(*(int32x2_t *)v51.i8, 0);
              int32x4_t v212 = vaddq_s32((int32x4_t)v209, v208);
              v209.i64[0] = *(void *)(v38 + v124);
              v42.i64[0] = *(void *)(v280 + v38 + v124);
              int8x16_t v213 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v212.i8, 1);
              v43.i64[0] = *(void *)(v277 + v38 + v124);
              int8x16_t v214 = vzip1q_s8((int8x16_t)0, v42);
              int8x16_t v215 = vzip1q_s8(v43, v209);
              int8x16_t v216 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v210.i8, 1);
              int32x4_t v217 = (int32x4_t)vzip1q_s8(v214, v215);
              int32x4_t v218 = (int32x4_t)vzip2q_s8(v214, v215);
              v216.i64[0] = 0;
              int32x4_t v219 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v217, 0x20uLL), v217);
              int32x4_t v220 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v218, 0x20uLL), v218);
              int32x4_t v221 = vdupq_lane_s32(*(int32x2_t *)v220.i8, 1);
              v213.i64[0] = 0;
              int32x4_t v222 = vdupq_lane_s32(*(int32x2_t *)v219.i8, 1);
              v222.i64[0] = 0;
              v221.i64[0] = 0;
              int32x4_t v223 = vdupq_lane_s32(*(int32x2_t *)v50.i8, 0);
              v44.i64[0] = *(void *)(v45 + v124);
              int32x4_t v224 = vaddq_s32((int32x4_t)v216, v210);
              int32x4_t v225 = vaddq_s32((int32x4_t)v213, vaddq_s32(v212, v211));
              v213.i64[0] = *(void *)(v279 + v45 + v124);
              v216.i64[0] = *(void *)(v276 + v45 + v124);
              int32x4_t v226 = vaddq_s32(v222, v219);
              int8x16_t v227 = vzip1q_s8((int8x16_t)0, v213);
              int8x16_t v228 = vzip1q_s8(v216, v44);
              int32x4_t v229 = (int32x4_t)vzip1q_s8(v227, v228);
              int8x16_t v44 = (int8x16_t)vdupq_laneq_s32(v224, 3);
              int32x4_t v230 = (int32x4_t)vzip2q_s8(v227, v228);
              int32x4_t v231 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v229, 0x20uLL), v229);
              int32x4_t v232 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v230, 0x20uLL), v230);
              int32x4_t v233 = vaddq_s32(v224, v211);
              int32x4_t v234 = vdupq_lane_s32(*(int32x2_t *)v232.i8, 1);
              int32x4_t v235 = vdupq_lane_s32(*(int32x2_t *)v231.i8, 1);
              int32x4_t v236 = vdupq_laneq_s32(v226, 3);
              int32x4_t v237 = vaddq_s32(v221, vaddq_s32(v220, v223));
              v235.i64[0] = 0;
              v234.i64[0] = 0;
              int32x4_t v238 = vaddq_s32(v226, v223);
              int32x4_t v239 = vaddq_s32(v235, v231);
              int32x4_t v51 = vdupq_laneq_s32(v239, 3);
              int32x4_t v240 = vdupq_lane_s32(*(int32x2_t *)v49.i8, 0);
              int32x4_t v241 = vaddq_s32(v225, (int32x4_t)v44);
              int8x16_t v43 = (int8x16_t)vaddq_s32(v239, v240);
              int32x4_t v242 = vaddq_s32(v234, vaddq_s32(v232, v240));
              int32x4_t v243 = vzip2q_s32(v233, v238);
              v340.val[0] = (float32x4_t)vzip1q_s32(v233, v238);
              int32x4_t v244 = vaddq_s32(v237, v236);
              v340.val[1] = (float32x4_t)vzip1q_s32(v261, (int32x4_t)v43);
              unint64_t v204 = result + 128;
              v245 = (float *)(result + 64);
              v246 = (float *)(result + 96);
              int8x16_t v41 = (int8x16_t)vaddq_s32(v242, v51);
              vst2q_f32((float *)result, v340);
              v247 = (float *)(result + 32);
              v51.i32[0] = v241.i32[3];
              int32x4_t v50 = vzip2q_s32(v261, (int32x4_t)v43);
              vst2q_f32(v247, *(float32x4x2_t *)(&v50 - 1));
              v50.i32[0] = v244.i32[3];
              int32x4_t v248 = vzip1q_s32(v241, v244);
              int8x16_t v42 = (int8x16_t)vzip1q_s32(v261, (int32x4_t)v41);
              vst2q_f32(v245, *(float32x4x2_t *)(&v42 - 1));
              int8x16_t v39 = (int8x16_t)vzip2q_s32(v241, v244);
              int8x16_t v40 = (int8x16_t)vzip2q_s32(v261, (int32x4_t)v41);
              vst2q_f32(v246, *(float32x4x2_t *)v39.i8);
              v49.i32[0] = v41.i32[3];
              unint64_t v203 = v124 + 8;
              unint64_t v249 = v124 + 16;
              v124 += 8;
              result = v204;
            }
            while (v249 <= v33);
          }
          else
          {
            unint64_t v203 = v124;
            unint64_t v204 = result;
          }
          if (v203 < v33)
          {
            uint64_t v250 = 0;
            unint64_t v251 = v278 + v203 + v36;
            unint64_t v252 = v281 + v203 + v36;
            unint64_t v253 = v36 + v203;
            unint64_t v254 = v277 + v203 + v38;
            result = v280 + v203 + v38;
            unint64_t v255 = v38 + v203;
            unint64_t v256 = v276 + v203 + v45;
            unint64_t v257 = v279 + v203 + v45;
            unint64_t v258 = v45 + v203;
            unint64_t v259 = v33 - v203;
            do
            {
              LODWORD(v260) = ((*(unsigned __int8 *)(v253 + v250) << 24) | (*(unsigned __int8 *)(v252 + v250) << 16) | (*(unsigned __int8 *)(v251 + v250) << 8))
                            + v51.i32[0];
              DWORD1(v260) = v262.i32[0];
              DWORD2(v260) = ((*(unsigned __int8 *)(v255 + v250) << 24) | (*(unsigned __int8 *)(result + v250) << 16) | (*(unsigned __int8 *)(v254 + v250) << 8))
                           + v50.i32[0];
              HIDWORD(v260) = ((*(unsigned __int8 *)(v258 + v250) << 24) | (*(unsigned __int8 *)(v257 + v250) << 16) | (*(unsigned __int8 *)(v256 + v250) << 8))
                            + v49.i32[0];
              *(_OWORD *)(v204 + 16 * v250++) = v260;
            }
            while (v259 != v250);
          }
        }
        a11 += a12;
        uint64_t v30 = v282 + a10;
      }
      while (v30 + (unint64_t)a3[7].u32[0] < v274);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v231 = result;
  if (a9)
  {
    unint64_t v232 = HIDWORD(*(void *)(a2 + 56));
    if (*(unsigned char *)(*(void *)a4 + 24)) {
      unsigned int v12 = **(double **)a4;
    }
    v16 = *(ChannelDescription **)(a5 + 8);
    int32x2_t v281 = a3[3];
    uint64_t v17 = a3[7].u32[1];
    int32x2_t v18 = *(int32x2_t *)((char *)v16 + 48);
    int32x2_t v19 = *(int32x2_t *)(*(void *)(*((void *)v16 + 5) + 8 * v17) + 16);
    uint64_t v229 = v281.u32[0];
    int32x4_t v230 = v16;
    unsigned int v228 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v16, (a3[6].i32[1] + v281.i32[1] * v232), v281.u32[0], v17);
    double v20 = *(ChannelDescription **)(a6 + 8);
    *(int32x2_t *)v278.val[0].i8 = a3[3];
    uint64_t v21 = a3[7].u32[1];
    int32x2_t v22 = *(int32x2_t *)((char *)v20 + 48);
    int32x2_t v23 = *(int32x2_t *)(*(void *)(*((void *)v20 + 5) + 8 * v21) + 16);
    uint64_t v226 = v278.val[0].u32[0];
    int8x16_t v227 = v20;
    unsigned int v225 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v20, (a3[6].i32[1] + v278.val[0].i32[1] * v232), v278.val[0].u32[0], v21);
    int32x2_t v24 = *(ChannelDescription **)(a7 + 8);
    *(int32x2_t *)v275.val[0].i8 = a3[3];
    uint64_t v25 = a3[7].u32[1];
    int32x2_t v26 = *(int32x2_t *)((char *)v24 + 48);
    int32x2_t v27 = *(int32x2_t *)(*(void *)(*((void *)v24 + 5) + 8 * v25) + 16);
    uint64_t v223 = v275.val[0].u32[0];
    int32x4_t v224 = v24;
    unsigned int v222 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v24, (a3[6].i32[1] + v275.val[0].i32[1] * v232), v275.val[0].u32[0], v25);
    uint64_t v28 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v28 < v232)
    {
      uint64_t v29 = vmin_u32((uint32x2_t)vmls_s32(v27, v26, *(int32x2_t *)v275.val[0].i8), (uint32x2_t)v26).u32[0];
      int v221 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v30 = a3[5].u32[1];
      uint64_t v238 = vmin_u32((uint32x2_t)vmls_s32(v23, v22, *(int32x2_t *)v278.val[0].i8), (uint32x2_t)v22).u32[0];
      uint64_t v239 = vmin_u32((uint32x2_t)vmls_s32(v19, v18, v281), (uint32x2_t)v18).u32[0];
      uint64_t v235 = 2 * v238;
      uint64_t v236 = 2 * v239;
      uint64_t v219 = 3 * v238;
      uint64_t v220 = 3 * v239;
      uint64_t v234 = 2 * v29;
      uint64_t v237 = v29;
      int32x4_t v243 = vdupq_n_s32(v12);
      uint64_t v218 = 3 * v29;
      do
      {
        uint64_t v240 = v28;
        unint64_t v31 = (v221 + v28);
        unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v230, v31, v229, v228);
        if (HIDWORD(LocationForTile)) {
          unint64_t v33 = v231 + LocationForTile;
        }
        else {
          unint64_t v33 = 0;
        }
        unint64_t v34 = ChannelDescription::GetLocationForTile(v227, v31, v226, v225);
        if (HIDWORD(v34)) {
          unint64_t v35 = v231 + v34;
        }
        else {
          unint64_t v35 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v224, v31, v223, v222);
        unint64_t v45 = v231 + result;
        if (!HIDWORD(result)) {
          unint64_t v45 = 0;
        }
        if (v33) {
          BOOL v46 = v35 == 0;
        }
        else {
          BOOL v46 = 1;
        }
        if (!v46 && v45 != 0)
        {
          if (v30 >= 0x20)
          {
            uint64_t v55 = 0;
            unsigned int v50 = 0;
            unsigned int v49 = 0;
            unsigned int v48 = 0;
            unint64_t v56 = v220 + v33;
            unint64_t v57 = v236 + v33;
            uint64_t v58 = v239 + v33;
            unint64_t v59 = v219 + v35;
            unint64_t v60 = v235 + v35;
            result = v238 + v35;
            unint64_t v61 = v218 + v45;
            unint64_t v62 = v234 + v45;
            uint64_t v63 = v237 + v45;
            v52 = (int8x16_t *)&unk_228F61000;
            v53 = (int8x16_t *)&unk_228F61000;
            v54 = (int8x16_t *)&unk_228F61000;
            do
            {
              v290.val[1] = *(int8x16_t *)(v33 + v55);
              v286.val[1] = *(int8x16_t *)(v33 + v55 + 16);
              v302.val[1] = *(int8x16_t *)(v58 + v55);
              v288.val[1] = *(int8x16_t *)(v58 + v55 + 16);
              v302.val[0] = *(int8x16_t *)(v56 + v55);
              v288.val[0] = *(int8x16_t *)(v56 + v55 + 16);
              v290.val[0] = *(int8x16_t *)(v57 + v55);
              v286.val[0] = *(int8x16_t *)(v57 + v55 + 16);
              v301.val[0] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61D40);
              v301.val[1] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D50);
              int8x16_t v282 = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61D60);
              int8x16_t v285 = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D70);
              v279.val[0] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61D80);
              v279.val[1] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D90);
              v276.val[0] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61DA0);
              v276.val[1] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61DB0);
              v273.val[0] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D80);
              v273.val[1] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D90);
              v271.val[0] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61DA0);
              v271.val[1] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61DB0);
              v269.val[0] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D40);
              v269.val[1] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D50);
              v295.val[0] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D60);
              v288.val[1] = *(int8x16_t *)(v35 + v55);
              v290.val[1] = *(int8x16_t *)(v35 + v55 + 16);
              v295.val[1] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D70);
              v302.val[1] = *(int8x16_t *)(result + v55);
              v286.val[1] = *(int8x16_t *)(result + v55 + 16);
              v288.val[0] = *(int8x16_t *)(v60 + v55);
              v290.val[0] = *(int8x16_t *)(v60 + v55 + 16);
              v302.val[0] = *(int8x16_t *)(v59 + v55);
              v286.val[0] = *(int8x16_t *)(v59 + v55 + 16);
              int8x16_t v266 = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61D40);
              int8x16_t v268 = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D50);
              int8x16_t v263 = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61D60);
              int8x16_t v265 = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D70);
              int8x16_t v260 = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61D80);
              int8x16_t v262 = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D90);
              int8x16_t v257 = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61DA0);
              int8x16_t v259 = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61DB0);
              int8x16_t v254 = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D80);
              int8x16_t v256 = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D90);
              int8x16_t v251 = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61DA0);
              int8x16_t v253 = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61DB0);
              v299.val[0] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D40);
              v299.val[1] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D50);
              v297.val[0] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D60);
              v297.val[1] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D70);
              v288.val[1] = *(int8x16_t *)(v45 + v55);
              v293.val[1] = *(int8x16_t *)(v45 + v55 + 16);
              v288.val[0] = *(int8x16_t *)(v62 + v55);
              v293.val[0] = *(int8x16_t *)(v62 + v55 + 16);
              v286.val[1] = *(int8x16_t *)(v63 + v55);
              v290.val[1] = *(int8x16_t *)(v63 + v55 + 16);
              v286.val[0] = *(int8x16_t *)(v61 + v55);
              v290.val[0] = *(int8x16_t *)(v61 + v55 + 16);
              int8x16_t v248 = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D40);
              int8x16_t v250 = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D50);
              v313.val[0] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D60);
              v313.val[1] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D70);
              v306.val[0] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61D80);
              v306.val[1] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61D90);
              v304.val[0] = vqtbl2q_s8(v286, (int8x16_t)xmmword_228F61DA0);
              v304.val[1] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61DB0);
              v302.val[0] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D80);
              v302.val[1] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F61D90);
              v309.val[0] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61DA0);
              v309.val[1] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F61DB0);
              v312.val[0] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D40);
              v312.val[1] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F61D50);
              v290.val[0] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61D60);
              v290.val[1] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F61D70);
              v293.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v64 = (int32x4_t)vqtbl2q_s8(v269, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v65 = (int32x4_t)vqtbl2q_s8(v271, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v66 = (int32x4_t)vqtbl2q_s8(v273, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v67 = (int32x4_t)vqtbl2q_s8(v276, (int8x16_t)xmmword_228F61DC0);
              v286.val[0] = vqtbl2q_s8(v279, (int8x16_t)xmmword_228F61DC0);
              v286.val[1] = v282;
              v288.val[0] = v285;
              v286.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v286 + 16), (int8x16_t)xmmword_228F61DC0);
              v288.val[0] = vqtbl2q_s8(v301, (int8x16_t)xmmword_228F61DC0);
              v288.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v293.val[1], 0x20uLL), (int32x4_t)v293.val[1]);
              v293.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v64, 0x20uLL), v64);
              int32x4_t v68 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v65, 0x20uLL), v65);
              int32x4_t v69 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v66, 0x20uLL), v66);
              int32x4_t v70 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v67, 0x20uLL), v67);
              v286.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v286.val[0], 0x20uLL), (int32x4_t)v286.val[0]);
              v286.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v286.val[1], 0x20uLL), (int32x4_t)v286.val[1]);
              v288.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v288.val[0], 0x20uLL), (int32x4_t)v288.val[0]);
              v295.val[1] = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v293.val[1].i8, 1), (int32x4_t)v293.val[1]);
              int32x4_t v71 = (int32x4_t)vqtbl2q_s8(v297, (int8x16_t)xmmword_228F61DC0);
              v297.val[0] = vqtbl2q_s8(v299, (int8x16_t)xmmword_228F61DC0);
              v293.val[1] = v251;
              v295.val[0] = v253;
              v297.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v283 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v288.val[0].i8, 1), (int32x4_t)v288.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v286.val[1].i8, 1), (int32x4_t)v286.val[1]));
              v286.val[1] = v254;
              v288.val[0] = v256;
              v288.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v286 + 16), (int8x16_t)xmmword_228F61DC0);
              v293.val[1] = v257;
              v295.val[0] = v259;
              v299.val[0] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F61DC0);
              v293.val[1] = v260;
              v295.val[0] = v262;
              v299.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F61DC0);
              v293.val[1] = v263;
              v295.val[0] = v265;
              v301.val[0] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F61DC0);
              v293.val[1] = v266;
              v295.val[0] = v268;
              v301.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F61DC0);
              v286.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v71, 0x20uLL), v71);
              int32x4_t v72 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v297.val[0], 0x20uLL), (int32x4_t)v297.val[0]);
              v297.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v297.val[1], 0x20uLL), (int32x4_t)v297.val[1]);
              v286.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v286.val[0].i8, 1), (int32x4_t)v286.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v70.i8, 1), v70));
              v288.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v288.val[0], 0x20uLL), (int32x4_t)v288.val[0]);
              int32x4_t v73 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v299.val[0], 0x20uLL), (int32x4_t)v299.val[0]);
              int32x4_t v74 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v69.i8, 1), v69), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v68.i8, 1), v68));
              int32x4_t v75 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v299.val[1], 0x20uLL), (int32x4_t)v299.val[1]);
              v299.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v301.val[0], 0x20uLL), (int32x4_t)v301.val[0]);
              v297.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v301.val[1], 0x20uLL), (int32x4_t)v301.val[1]);
              v290.val[0] = vqtbl2q_s8(v290, (int8x16_t)xmmword_228F61DC0);
              v290.val[1] = vqtbl2q_s8(v312, (int8x16_t)xmmword_228F61DC0);
              v293.val[1] = vqtbl2q_s8(v309, (int8x16_t)xmmword_228F61DC0);
              v302.val[0] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61DC0);
              v302.val[1] = vqtbl2q_s8(v304, (int8x16_t)xmmword_228F61DC0);
              int8x16_t v44 = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v297.val[1].i8, 1), (int32x4_t)v297.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v299.val[0].i8, 1), (int32x4_t)v299.val[0]));
              v304.val[1] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F61DC0);
              v306.val[0] = vqtbl2q_s8(v313, (int8x16_t)xmmword_228F61DC0);
              v306.val[1] = v248;
              v309.val[0] = v250;
              v293.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v306 + 16), (int8x16_t)xmmword_228F61DC0);
              v290.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v290.val[0], 0x20uLL), (int32x4_t)v290.val[0]);
              v293.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v293.val[1], 0x20uLL), (int32x4_t)v293.val[1]);
              v302.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v302.val[1], 0x20uLL), (int32x4_t)v302.val[1]);
              v306.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v306.val[0], 0x20uLL), (int32x4_t)v306.val[0]);
              v293.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v293.val[0], 0x20uLL), (int32x4_t)v293.val[0]);
              v304.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v304.val[1], 0x20uLL), (int32x4_t)v304.val[1]);
              v302.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v302.val[0], 0x20uLL), (int32x4_t)v302.val[0]);
              v286.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v72.i8, 1), v72), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v286.val[1].i8, 1), (int32x4_t)v286.val[1])), vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v288.val[0].i8, 1), (int32x4_t)v288.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v297.val[0].i8, 1), (int32x4_t)v297.val[0])));
              v288.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v290.val[1], 0x20uLL), (int32x4_t)v290.val[1]);
              v286.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v295.val[1], vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v288.val[1].i8, 1), (int32x4_t)v288.val[1])), v74), vaddq_s32((int32x4_t)v286.val[0], v283));
              v290.val[1] = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v293.val[1].i8, 1), (int32x4_t)v293.val[1]);
              int8x16_t v41 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v302.val[0].i8, 1), (int32x4_t)v302.val[0]);
              v288.val[1] = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v302.val[1].i8, 1), (int32x4_t)v302.val[1]);
              int8x16_t v42 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v304.val[1].i8, 1), (int32x4_t)v304.val[1]);
              int8x16_t v43 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v306.val[0].i8, 1), (int32x4_t)v306.val[0]);
              __int32 v76 = v286.val[0].i32[3];
              int8x16_t v39 = (int8x16_t)vaddq_s32((int32x4_t)v42, (int32x4_t)v288.val[1]);
              int8x16_t v40 = (int8x16_t)vaddq_s32((int32x4_t)v41, (int32x4_t)v290.val[1]);
              int8x16_t v38 = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v288.val[0].i8, 1), (int32x4_t)v288.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v290.val[0].i8, 1), (int32x4_t)v290.val[0]));
              __int32 v77 = vaddq_s32(*(int32x4_t *)(&v286 + 16), vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)&v75, 1), v75), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)&v73, 1), v73)), *(int32x4_t *)&v44)).i32[3];
              int8x16_t v37 = (int8x16_t)vaddq_s32((int32x4_t)v38, (int32x4_t)v40);
              int8x16_t v36 = (int8x16_t)vaddq_s32((int32x4_t)v37, vaddq_s32((int32x4_t)v39, vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v293.val[0].i8, 1), (int32x4_t)v293.val[0]), (int32x4_t)v43)));
              v50 += v76;
              v49 += v77;
              v48 += v36.u32[3];
              uint64_t v51 = v55 + 32;
              unint64_t v78 = v55 + 64;
              v55 += 32;
            }
            while (v78 <= v30);
          }
          else
          {
            unsigned int v48 = 0;
            unsigned int v49 = 0;
            unsigned int v50 = 0;
            uint64_t v51 = 0;
            v52 = (int8x16_t *)&unk_228F61000;
            v53 = (int8x16_t *)&unk_228F61000;
            v54 = (int8x16_t *)&unk_228F61000;
          }
          if ((v51 | 8uLL) <= v30)
          {
            result = v238 + v35;
            unint64_t v80 = v30 + a9;
            do
            {
              v36.i64[0] = *(void *)(v33 + v51);
              v37.i64[0] = *(void *)(v239 + v33 + v51);
              v38.i64[0] = *(void *)(v236 + v33 + v51);
              v39.i64[0] = *(void *)(v220 + v33 + v51);
              int8x16_t v81 = vzip1q_s8(v39, v37);
              int8x16_t v82 = vzip1q_s8(v38, v36);
              int32x4_t v83 = (int32x4_t)vzip1q_s8(v81, v82);
              int32x4_t v84 = (int32x4_t)vzip2q_s8(v81, v82);
              int32x4_t v85 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v83, 0x20uLL), v83);
              int32x4_t v86 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v84, 0x20uLL), v84);
              int8x16_t v87 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v86.i8, 1);
              int8x16_t v88 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v85.i8, 1);
              int8x16_t v89 = (int8x16_t)vaddq_s32((int32x4_t)v88, v85);
              int8x16_t v90 = (int8x16_t)vaddq_s32((int32x4_t)v87, v86);
              v50 += v90.i32[3] + v89.i32[3];
              v90.i64[0] = *(void *)(v35 + v51);
              v87.i64[0] = *(void *)(result + v51);
              v89.i64[0] = *(void *)(v235 + v35 + v51);
              v88.i64[0] = *(void *)(v219 + v35 + v51);
              int8x16_t v91 = vzip1q_s8(v88, v87);
              int8x16_t v92 = vzip1q_s8(v89, v90);
              int32x4_t v93 = (int32x4_t)vzip1q_s8(v91, v92);
              int32x4_t v94 = (int32x4_t)vzip2q_s8(v91, v92);
              int32x4_t v95 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v93, 0x20uLL), v93);
              int32x4_t v96 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v94, 0x20uLL), v94);
              int8x16_t v97 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v96.i8, 1);
              int8x16_t v98 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v95.i8, 1);
              int8x16_t v99 = (int8x16_t)vaddq_s32((int32x4_t)v98, v95);
              int8x16_t v100 = (int8x16_t)vaddq_s32((int32x4_t)v97, v96);
              v49 += v100.i32[3] + v99.i32[3];
              v100.i64[0] = *(void *)(v45 + v51);
              v97.i64[0] = *(void *)(v237 + v45 + v51);
              v99.i64[0] = *(void *)(v234 + v45 + v51);
              v98.i64[0] = *(void *)(v218 + v45 + v51);
              int8x16_t v101 = vzip1q_s8(v98, v97);
              int8x16_t v102 = vzip1q_s8(v99, v100);
              int32x4_t v103 = (int32x4_t)vzip1q_s8(v101, v102);
              int32x4_t v104 = (int32x4_t)vzip2q_s8(v101, v102);
              int32x4_t v105 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v103, 0x20uLL), v103);
              int32x4_t v106 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v104, 0x20uLL), v104);
              int8x16_t v37 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v106.i8, 1);
              int8x16_t v39 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v105.i8, 1);
              int8x16_t v38 = (int8x16_t)vaddq_s32((int32x4_t)v39, v105);
              int8x16_t v36 = (int8x16_t)vaddq_s32((int32x4_t)v37, v106);
              v48 += v36.i32[3] + v38.i32[3];
              unint64_t v79 = v51 + 8;
              unint64_t v107 = v51 + 16;
              v51 += 8;
            }
            while (v107 <= v30);
          }
          else
          {
            unint64_t v79 = v51;
            unint64_t v80 = v30 + a9;
          }
          int32x4_t v108 = v243;
          if (v79 < v30)
          {
            result = v237 + v45;
            do
            {
              v50 += (*(unsigned __int8 *)(v33 + v79) << 24) | (*(unsigned __int8 *)(v239 + v33 + v79) << 16) | (*(unsigned __int8 *)(v236 + v33 + v79) << 8) | *(unsigned __int8 *)(v236 + v33 + v79);
              v49 += (*(unsigned __int8 *)(v35 + v79) << 24) | (*(unsigned __int8 *)(v238 + v35 + v79) << 16) | (*(unsigned __int8 *)(v235 + v35 + v79) << 8) | *(unsigned __int8 *)(v235 + v35 + v79);
              v48 += (*(unsigned __int8 *)(v45 + v79) << 24) | (*(unsigned __int8 *)(result + v79) << 16) | (*(unsigned __int8 *)(v234 + v45 + v79) << 8) | *(unsigned __int8 *)(v234 + v45 + v79);
              ++v79;
            }
            while (v30 != v79);
            unint64_t v79 = v30;
          }
          if (v79 + 32 <= v80)
          {
            unint64_t v242 = v220 + v33;
            unint64_t v112 = v236 + v33;
            uint64_t v113 = v239 + v33;
            unint64_t v114 = v219 + v35;
            unint64_t v115 = v235 + v35;
            result = v238 + v35;
            unint64_t v111 = v30 + a9;
            unint64_t v116 = v218 + v45;
            unint64_t v117 = v234 + v45;
            uint64_t v118 = v237 + v45;
            int32x4_t v119 = a11;
            do
            {
              v287.val[1] = *(int8x16_t *)(v33 + v79);
              v289.val[1] = *(int8x16_t *)(v33 + v79 + 16);
              v291.val[1] = *(int8x16_t *)(v113 + v79);
              v294.val[1] = *(int8x16_t *)(v113 + v79 + 16);
              v287.val[0] = *(int8x16_t *)(v112 + v79);
              v289.val[0] = *(int8x16_t *)(v112 + v79 + 16);
              v291.val[0] = *(int8x16_t *)(v242 + v79);
              v294.val[0] = *(int8x16_t *)(v242 + v79 + 16);
              int8x16_t v120 = v52[218];
              int8x16_t v121 = v53[219];
              v296.val[0] = vqtbl2q_s8(v291, v120);
              v296.val[1] = vqtbl2q_s8(v287, v121);
              int8x16_t v122 = v54[214];
              v284.val[0] = vqtbl2q_s8(v291, v122);
              v284.val[1] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D70);
              v280.val[0] = vqtbl2q_s8(v294, v120);
              v280.val[1] = vqtbl2q_s8(v289, v121);
              v277.val[0] = vqtbl2q_s8(v294, v122);
              v277.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D70);
              v274.val[0] = vqtbl2q_s8(v294, (int8x16_t)xmmword_228F61D40);
              v274.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D50);
              v272.val[0] = vqtbl2q_s8(v294, (int8x16_t)xmmword_228F61D80);
              v272.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D90);
              v270.val[0] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61D40);
              v270.val[1] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D50);
              v294.val[0] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61D80);
              v289.val[1] = *(int8x16_t *)(v35 + v79);
              v291.val[1] = *(int8x16_t *)(v35 + v79 + 16);
              v264.val[0] = v294.val[0];
              v264.val[1] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D90);
              v287.val[1] = *(int8x16_t *)(result + v79);
              v294.val[1] = *(int8x16_t *)(result + v79 + 16);
              v289.val[0] = *(int8x16_t *)(v115 + v79);
              v291.val[0] = *(int8x16_t *)(v115 + v79 + 16);
              v287.val[0] = *(int8x16_t *)(v114 + v79);
              v294.val[0] = *(int8x16_t *)(v114 + v79 + 16);
              v267.val[0] = vqtbl2q_s8(v294, v120);
              v267.val[1] = vqtbl2q_s8(v291, v121);
              v261.val[0] = vqtbl2q_s8(v294, v122);
              v261.val[1] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61D70);
              v258.val[0] = vqtbl2q_s8(v294, (int8x16_t)xmmword_228F61D40);
              v258.val[1] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61D50);
              v249.val[0] = vqtbl2q_s8(v294, (int8x16_t)xmmword_228F61D80);
              v249.val[1] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61D90);
              v255.val[0] = vqtbl2q_s8(v287, v120);
              v255.val[1] = vqtbl2q_s8(v289, v121);
              v252.val[0] = vqtbl2q_s8(v287, v122);
              v252.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D70);
              v300.val[0] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D40);
              v300.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D50);
              v298.val[0] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D80);
              v298.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D90);
              v289.val[1] = *(int8x16_t *)(v45 + v79);
              v287.val[1] = *(int8x16_t *)(v45 + v79 + 16);
              v289.val[0] = *(int8x16_t *)(v117 + v79);
              v287.val[0] = *(int8x16_t *)(v117 + v79 + 16);
              v305.val[1] = *(int8x16_t *)(v118 + v79);
              v291.val[1] = *(int8x16_t *)(v118 + v79 + 16);
              v305.val[0] = *(int8x16_t *)(v116 + v79);
              v291.val[0] = *(int8x16_t *)(v116 + v79 + 16);
              int8x16_t v246 = vqtbl2q_s8(v291, v120);
              int8x16_t v247 = vqtbl2q_s8(v287, v121);
              int8x16_t v244 = vqtbl2q_s8(v291, v122);
              int8x16_t v245 = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D70);
              v307.val[0] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61D40);
              v307.val[1] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D50);
              v303.val[0] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61D80);
              v303.val[1] = vqtbl2q_s8(v287, (int8x16_t)xmmword_228F61D90);
              v310.val[0] = vqtbl2q_s8(v305, v120);
              v310.val[1] = vqtbl2q_s8(v289, v121);
              v311.val[0] = vqtbl2q_s8(v305, v122);
              v311.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D70);
              v291.val[1] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F61D40);
              v294.val[0] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D50);
              v314.val[0] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F61D80);
              v314.val[1] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F61D90);
              v289.val[0] = vqtbl2q_s8(v264, (int8x16_t)xmmword_228F61DC0);
              v289.val[1] = vqtbl2q_s8(v270, (int8x16_t)xmmword_228F61DC0);
              v305.val[0] = vqtbl2q_s8(v272, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v123 = (int32x4_t)vqtbl2q_s8(v274, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v124 = (int32x4_t)vqtbl2q_s8(v277, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v125 = (int32x4_t)vqtbl2q_s8(v280, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v126 = (int32x4_t)vqtbl2q_s8(v284, (int8x16_t)xmmword_228F61DC0);
              v287.val[0] = vqtbl2q_s8(v296, (int8x16_t)xmmword_228F61DC0);
              v291.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v289.val[0], 0x20uLL), (int32x4_t)v289.val[0]);
              v289.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v289.val[1], 0x20uLL), (int32x4_t)v289.val[1]);
              v289.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v305.val[0], 0x20uLL), (int32x4_t)v305.val[0]);
              v305.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v123, 0x20uLL), v123);
              int32x4_t v127 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v124, 0x20uLL), v124);
              int32x4_t v128 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v125, 0x20uLL), v125);
              int32x4_t v129 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v126, 0x20uLL), v126);
              v287.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v287.val[0], 0x20uLL), (int32x4_t)v287.val[0]);
              int32x4_t v130 = vdupq_lane_s32(*(int32x2_t *)v287.val[1].i8, 1);
              v130.i64[0] = 0;
              v287.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v129.i8, 1);
              v294.val[1] = (int8x16_t)vaddq_s32(v130, (int32x4_t)v287.val[1]);
              v287.val[0].i64[0] = 0;
              v287.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v287.val[0], v129);
              int32x4_t v131 = vdupq_lane_s32(*(int32x2_t *)v127.i8, 1);
              v131.i64[0] = 0;
              int32x4_t v132 = vdupq_lane_s32(*(int32x2_t *)v128.i8, 1);
              v132.i64[0] = 0;
              int32x4_t v133 = vaddq_s32(v132, v128);
              int32x4_t v134 = vaddq_s32(v131, v127);
              int32x4_t v135 = vdupq_lane_s32(*(int32x2_t *)v305.val[0].i8, 1);
              v135.i64[0] = 0;
              v305.val[0] = (int8x16_t)vaddq_s32(v135, (int32x4_t)v305.val[0]);
              int32x4_t v136 = vdupq_lane_s32(*(int32x2_t *)v289.val[1].i8, 1);
              v136.i64[0] = 0;
              v289.val[1] = (int8x16_t)vaddq_s32(v136, (int32x4_t)v289.val[1]);
              int32x4_t v137 = vdupq_lane_s32(*(int32x2_t *)v289.val[0].i8, 1);
              v137.i64[0] = 0;
              int32x4_t v138 = vdupq_lane_s32(*(int32x2_t *)v291.val[0].i8, 1);
              v289.val[0] = (int8x16_t)vaddq_s32(v137, (int32x4_t)v289.val[0]);
              v138.i64[0] = 0;
              v291.val[0] = (int8x16_t)vaddq_s32(v138, (int32x4_t)v291.val[0]);
              int32x4_t v139 = (int32x4_t)vqtbl2q_s8(v298, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v140 = (int32x4_t)vqtbl2q_s8(v300, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v141 = vaddq_s32(vdupq_laneq_s32((int32x4_t)v289.val[1], 3), v133);
              v298.val[0] = vqtbl2q_s8(v249, (int8x16_t)xmmword_228F61DC0);
              v298.val[1] = vqtbl2q_s8(v258, (int8x16_t)xmmword_228F61DC0);
              v300.val[0] = vqtbl2q_s8(v261, (int8x16_t)xmmword_228F61DC0);
              v287.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v289.val[0], 3), (int32x4_t)v287.val[0]);
              v300.val[1] = vqtbl2q_s8(v267, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v142 = (int32x4_t)vqtbl2q_s8(v252, (int8x16_t)xmmword_228F61DC0);
              v287.val[0] = vqtbl2q_s8(v255, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v143 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v139, 0x20uLL), v139);
              int32x4_t v144 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v140, 0x20uLL), v140);
              v298.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v298.val[0], 0x20uLL), (int32x4_t)v298.val[0]);
              v298.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v298.val[1], 0x20uLL), (int32x4_t)v298.val[1]);
              v300.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v300.val[0], 0x20uLL), (int32x4_t)v300.val[0]);
              int32x4_t v145 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v300.val[1], 0x20uLL), (int32x4_t)v300.val[1]);
              v294.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v291.val[0], 3), (int32x4_t)v294.val[1]);
              v300.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v142, 0x20uLL), v142);
              v287.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v287.val[0], 0x20uLL), (int32x4_t)v287.val[0]);
              int32x4_t v146 = vdupq_lane_s32(*(int32x2_t *)v300.val[1].i8, 1);
              v146.i64[0] = 0;
              v296.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v287.val[0].i8, 1);
              v296.val[0].i64[0] = 0;
              v287.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v296.val[0], (int32x4_t)v287.val[0]);
              v296.val[0] = (int8x16_t)vaddq_s32(v146, (int32x4_t)v300.val[1]);
              v296.val[1] = (int8x16_t)vdupq_laneq_s32(v141, 3);
              int32x4_t v147 = vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v305.val[0], 3), v134), (int32x4_t)v296.val[1]);
              v296.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v305.val[0], (int32x4_t)v296.val[1]);
              v305.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v145.i8, 1);
              v305.val[0].i64[0] = 0;
              v300.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v294.val[1], 3);
              int32x4_t v148 = vaddq_s32((int32x4_t)v287.val[1], (int32x4_t)v300.val[1]);
              v287.val[1] = (int8x16_t)vdupq_n_s32(v50);
              v280.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v289.val[0], (int32x4_t)v287.val[1]), (int32x4_t)v300.val[1]);
              v289.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v300.val[0].i8, 1);
              v289.val[0].i64[0] = 0;
              v300.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v298.val[1].i8, 1);
              v289.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v289.val[0], (int32x4_t)v300.val[0]);
              v300.val[1].i64[0] = 0;
              v298.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v300.val[1], (int32x4_t)v298.val[1]);
              v300.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v144.i8, 1);
              v300.val[0].i64[0] = 0;
              v300.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v298.val[0].i8, 1);
              v300.val[1].i64[0] = 0;
              v298.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v300.val[1], (int32x4_t)v298.val[0]);
              int32x4_t v149 = vaddq_s32((int32x4_t)v300.val[0], v144);
              v300.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v143.i8, 1);
              v300.val[0].i64[0] = 0;
              int32x4_t v150 = vaddq_s32((int32x4_t)v300.val[0], v143);
              v305.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v298.val[0], 3), vaddq_s32((int32x4_t)v305.val[0], v145));
              v287.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v150, 3), (int32x4_t)v287.val[0]);
              v314.val[0] = vqtbl2q_s8(v314, (int8x16_t)xmmword_228F61DC0);
              v291.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v291 + 16), (int8x16_t)xmmword_228F61DC0);
              int32x4_t v151 = vaddq_s32(v141, (int32x4_t)v287.val[1]);
              v300.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v289.val[1], (int32x4_t)v287.val[1]);
              v300.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v294.val[1], (int32x4_t)v287.val[1]);
              v294.val[0] = vqtbl2q_s8(v303, (int8x16_t)xmmword_228F61DC0);
              v294.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v287.val[0], 3);
              v303.val[0] = vqtbl2q_s8(v307, (int8x16_t)xmmword_228F61DC0);
              v303.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v305.val[0], 3);
              v274.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v291.val[0], (int32x4_t)v287.val[1]);
              v289.val[1] = v244;
              v291.val[0] = v245;
              v291.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v289 + 16), (int8x16_t)xmmword_228F61DC0);
              v307.val[0] = (int8x16_t)vdupq_n_s32(v49);
              v298.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v298.val[0], (int32x4_t)v307.val[0]);
              v307.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(v149, 3), (int32x4_t)v296.val[0]), (int32x4_t)v294.val[1]);
              v270.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v305.val[0], (int32x4_t)v307.val[0]);
              v272.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v287.val[0], (int32x4_t)v307.val[0]);
              v314.val[1] = v246;
              int8x16_t v152 = v247;
              v287.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v314 + 16), (int8x16_t)xmmword_228F61DC0);
              v311.val[0] = vqtbl2q_s8(v311, (int8x16_t)xmmword_228F61DC0);
              v305.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v298.val[1], 3), (int32x4_t)v289.val[0]), (int32x4_t)v303.val[1]);
              v305.val[1] = vqtbl2q_s8(v310, (int8x16_t)xmmword_228F61DC0);
              v303.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v298.val[1], (int32x4_t)v303.val[1]);
              v298.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v314.val[0], 0x20uLL), (int32x4_t)v314.val[0]);
              v291.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v291.val[1], 0x20uLL), (int32x4_t)v291.val[1]);
              v296.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(v149, (int32x4_t)v307.val[0]), (int32x4_t)v294.val[1]);
              v294.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v294.val[0], 0x20uLL), (int32x4_t)v294.val[0]);
              v303.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v303.val[0], 0x20uLL), (int32x4_t)v303.val[0]);
              v289.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v291.val[0], 0x20uLL), (int32x4_t)v291.val[0]);
              v291.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v311.val[0], 0x20uLL), (int32x4_t)v311.val[0]);
              v294.val[0] = (int8x16_t)vaddq_s32(v147, (int32x4_t)v287.val[1]);
              v305.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v305.val[1], 0x20uLL), (int32x4_t)v305.val[1]);
              v310.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v305.val[1].i8, 1);
              v310.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v291.val[0].i8, 1);
              v314.val[0] = (int8x16_t)vaddq_s32(v148, (int32x4_t)v287.val[1]);
              v289.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v287.val[0], 0x20uLL), (int32x4_t)v287.val[0]);
              v311.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v289.val[0].i8, 1);
              v311.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v289.val[1].i8, 1);
              v287.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v296.val[1], (int32x4_t)v287.val[1]);
              int32x4_t v153 = vdupq_lane_s32(*(int32x2_t *)v303.val[0].i8, 1);
              v296.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v294.val[1].i8, 1);
              int32x4_t v154 = vdupq_laneq_s32(v148, 3);
              v310.val[0].i64[0] = 0;
              v310.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v310.val[0], (int32x4_t)v305.val[1]);
              v305.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v291.val[1].i8, 1);
              v305.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v305.val[0], (int32x4_t)v307.val[0]);
              v310.val[1].i64[0] = 0;
              v291.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v310.val[1], (int32x4_t)v291.val[0]);
              v310.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v298.val[1].i8, 1);
              v303.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v303.val[1], (int32x4_t)v307.val[0]);
              int32x4_t v155 = vaddq_s32(v150, (int32x4_t)v307.val[0]);
              v310.val[1].i64[0] = 0;
              v305.val[1].i64[0] = 0;
              int32x4_t v156 = vaddq_s32((int32x4_t)v307.val[1], (int32x4_t)v307.val[0]);
              v296.val[1].i64[0] = 0;
              v153.i64[0] = 0;
              v287.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v307.val[1], 3);
              v307.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v294.val[0], v154);
              v311.val[1].i64[0] = 0;
              v311.val[0].i64[0] = 0;
              v294.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v287.val[1], v154);
              v289.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v311.val[0], (int32x4_t)v289.val[0]);
              v303.val[0] = (int8x16_t)vaddq_s32(v153, (int32x4_t)v303.val[0]);
              v311.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v296.val[1], (int32x4_t)v294.val[1]);
              int32x4_t v157 = vaddq_s32((int32x4_t)v305.val[1], (int32x4_t)v291.val[1]);
              v307.val[0] = (int8x16_t)vaddq_s32(v151, v154);
              v310.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v310.val[1], (int32x4_t)v298.val[1]);
              v284.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v300.val[0], v154);
              int32x4_t v108 = v243;
              v305.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v305.val[0], (int32x4_t)v287.val[0]);
              v305.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v311.val[0], 3), (int32x4_t)v289.val[0]);
              v310.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v310.val[1], 3), (int32x4_t)v310.val[0]);
              int32x4_t v158 = vdupq_laneq_s32((int32x4_t)v310.val[0], 3);
              v277.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v298.val[0], (int32x4_t)v287.val[0]);
              v294.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(v157, 3), (int32x4_t)v291.val[0]), v158);
              v291.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v305.val[0], 3);
              v289.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v303.val[0], 3), vaddq_s32((int32x4_t)v311.val[1], (int32x4_t)v289.val[1])), (int32x4_t)v291.val[0]);
              v303.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v303.val[0], (int32x4_t)v291.val[0]);
              v291.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v270.val[0], (int32x4_t)v287.val[0]);
              int32x4_t v159 = vdupq_laneq_s32((int32x4_t)v294.val[1], 3);
              v314.val[1] = (int8x16_t)vdupq_n_s32(v48);
              v291.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v303.val[1], (int32x4_t)v287.val[0]);
              v311.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v289.val[1], (int32x4_t)v314.val[1]), v159);
              v294.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v294.val[1], (int32x4_t)v314.val[1]);
              v287.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v303.val[0], (int32x4_t)v314.val[1]);
              v289.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v305.val[0], (int32x4_t)v314.val[1]);
              v303.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v311.val[0], (int32x4_t)v314.val[1]);
              v303.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v287.val[0], v159);
              v287.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v310.val[0], (int32x4_t)v314.val[1]);
              v311.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(v157, (int32x4_t)v314.val[1]), v158);
              v314.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v310.val[1], (int32x4_t)v314.val[1]);
              int32x4_t v160 = vaddq_s32((int32x4_t)v289.val[1], v159);
              v298.val[0] = (int8x16_t)vuzp2q_s32(v243, v156);
              v298.val[1] = v272.val[0];
              v296.val[1] = (int8x16_t)vuzp2q_s32(v243, (int32x4_t)v272.val[0]);
              v310.val[1] = (int8x16_t)vuzp2q_s32(v243, (int32x4_t)v296.val[0]);
              v310.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v303.val[0], v159);
              int32x4_t v161 = vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v298.val[0], v243)), vuzp2q_s32((int32x4_t)v314.val[0], (int32x4_t)v294.val[1]));
              v289.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v314.val[0], (int32x4_t)v294.val[1]);
              v303.val[0] = vextq_s8(v314.val[0], v289.val[1], 0xCuLL);
              v314.val[0].i32[3] = v294.val[1].i32[1];
              v303.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, v156)), (int32x4_t)v303.val[0]);
              v294.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v310.val[1], v243)), vuzp2q_s32((int32x4_t)v280.val[0], (int32x4_t)v311.val[0]));
              v305.val[0] = v280.val[0];
              v305.val[0].i32[3] = v311.val[0].i32[1];
              v305.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v310.val[1]), (int32x4_t)v305.val[0]);
              v310.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v296.val[1], v243)), vuzp2q_s32((int32x4_t)v300.val[1], (int32x4_t)v287.val[0]));
              v314.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v298.val[0]), (int32x4_t)v314.val[0]);
              int8x16_t v162 = (int8x16_t)vuzp1q_s32((int32x4_t)v300.val[1], (int32x4_t)v287.val[0]);
              v298.val[0] = v300.val[1];
              v298.val[0].i32[3] = v287.val[0].i32[1];
              v298.val[1].i32[0] = v243.i32[2];
              v296.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v296.val[1]), (int32x4_t)v298.val[0]);
              v298.val[0] = (int8x16_t)vuzp2q_s32(v243, v155);
              v287.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, (int32x4_t)v272.val[0])), (int32x4_t)vextq_s8(v300.val[1], v162, 0xCuLL));
              int32x4_t v163 = vtrn2q_s32(vrev64q_s32((int32x4_t)v298.val[1]), (int32x4_t)v162);
              v298.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v298.val[0], v243)), vuzp2q_s32((int32x4_t)v274.val[0], (int32x4_t)v314.val[1]));
              v300.val[1] = v274.val[0];
              v300.val[1].i32[3] = v314.val[1].i32[1];
              v314.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v274.val[0], (int32x4_t)v314.val[1]);
              v156.i32[0] = v243.i32[2];
              unsigned int v50 = v307.val[1].u32[3];
              unsigned int v48 = v311.val[1].u32[3];
              v300.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, v155)), (int32x4_t)vextq_s8(v274.val[0], v314.val[1], 0xCuLL));
              v155.i32[0] = v243.i32[2];
              v289.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32(v156), (int32x4_t)v289.val[1]);
              int32x4_t v164 = vuzp2q_s32((int32x4_t)v307.val[1], (int32x4_t)v311.val[1]);
              v314.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32(v155), (int32x4_t)v314.val[1]);
              int32x4_t v165 = (int32x4_t)v307.val[1];
              v165.i32[3] = v311.val[1].i32[1];
              v311.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v307.val[1], (int32x4_t)v311.val[1]);
              *(int8x16_t *)int32x4_t v119 = v300.val[0];
              *((int32x4_t *)v119 + 1) = vtrn2q_s32(vrev64q_s32((int32x4_t)v298.val[0]), (int32x4_t)v300.val[1]);
              v307.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, (int32x4_t)v305.val[1])), (int32x4_t)vextq_s8(v307.val[1], v311.val[1], 0xCuLL));
              v298.val[0] = (int8x16_t)vuzp2q_s32((int32x4_t)v307.val[0], v160);
              *((_OWORD *)v119 + 2) = v314.val[1];
              *((_OWORD *)v119 + 3) = v298.val[1];
              v314.val[1] = v307.val[0];
              v314.val[1].i32[3] = v160.i32[1];
              int8x16_t v166 = (int8x16_t)vuzp1q_s32((int32x4_t)v307.val[0], v160);
              *((_OWORD *)v119 + 4) = v287.val[0];
              *((_OWORD *)v119 + 5) = v296.val[1];
              v287.val[0] = (int8x16_t)vuzp2q_s32(v243, (int32x4_t)v305.val[1]);
              *((int32x4_t *)v119 + 6) = v163;
              *((_OWORD *)v119 + 7) = v310.val[1];
              v310.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v280.val[0], (int32x4_t)v311.val[0]);
              unsigned int v49 = v305.val[1].u32[3];
              v305.val[1].i32[0] = v243.i32[2];
              *((_OWORD *)v119 + 12) = v303.val[0];
              *((_OWORD *)v119 + 13) = v314.val[0];
              v303.val[0] = v284.val[0];
              v305.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v305.val[1]), (int32x4_t)v311.val[1]);
              int8x16_t v38 = v277.val[0];
              v311.val[1] = (int8x16_t)vuzp2q_s32(v243, (int32x4_t)v277.val[0]);
              v303.val[0].i32[3] = v310.val[0].i32[1];
              int8x16_t v42 = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v311.val[1]), (int32x4_t)v303.val[0]);
              *((int32x4_t *)v119 + 8) = vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, (int32x4_t)v296.val[0])), (int32x4_t)vextq_s8(v280.val[0], v310.val[1], 0xCuLL));
              *((_OWORD *)v119 + 9) = v305.val[0];
              v296.val[0].i32[0] = v243.i32[2];
              int8x16_t v44 = (int8x16_t)vuzp2q_s32(v243, (int32x4_t)v291.val[0]);
              *((_OWORD *)v119 + 14) = v289.val[1];
              *((int32x4_t *)v119 + 15) = v161;
              v289.val[1] = v294.val[0];
              v314.val[0] = (int8x16_t)vuzp2q_s32(v243, (int32x4_t)v291.val[1]);
              v289.val[1].i32[3] = v303.val[1].i32[1];
              *((int32x4_t *)v119 + 10) = vtrn2q_s32(vrev64q_s32((int32x4_t)v296.val[0]), (int32x4_t)v310.val[1]);
              *((_OWORD *)v119 + 11) = v294.val[1];
              *((_OWORD *)v119 + 28) = v307.val[1];
              *((int32x4_t *)v119 + 29) = vtrn2q_s32(vrev64q_s32((int32x4_t)v287.val[0]), v165);
              int8x16_t v41 = (int8x16_t)vuzp2q_s32((int32x4_t)v294.val[0], (int32x4_t)v303.val[1]);
              int8x16_t v43 = (int8x16_t)vuzp1q_s32((int32x4_t)v294.val[0], (int32x4_t)v303.val[1]);
              *((int32x4_t *)v119 + 24) = vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, (int32x4_t)v291.val[1])), (int32x4_t)vextq_s8(v294.val[0], v43, 0xCuLL));
              *((int32x4_t *)v119 + 25) = vtrn2q_s32(vrev64q_s32((int32x4_t)v314.val[0]), (int32x4_t)v289.val[1]);
              *((int32x4_t *)v119 + 20) = vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, (int32x4_t)v291.val[0])), (int32x4_t)vextq_s8(v307.val[0], v166, 0xCuLL));
              *((int32x4_t *)v119 + 21) = vtrn2q_s32(vrev64q_s32((int32x4_t)v44), (int32x4_t)v314.val[1]);
              int8x16_t v39 = (int8x16_t)vuzp1q_s32((int32x4_t)v284.val[0], (int32x4_t)v310.val[0]);
              *((int32x4_t *)v119 + 16) = vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v243, (int32x4_t)v277.val[0])), (int32x4_t)vextq_s8(v284.val[0], v39, 0xCuLL));
              *((int8x16_t *)v119 + 17) = v42;
              *((_OWORD *)v119 + 30) = v305.val[1];
              *((int32x4_t *)v119 + 31) = vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v287.val[0], v243)), v164);
              v291.val[0].i32[0] = v243.i32[2];
              v291.val[1].i32[0] = v243.i32[2];
              int8x16_t v40 = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v291.val[1]), (int32x4_t)v43);
              *((int8x16_t *)v119 + 26) = v40;
              *((int32x4_t *)v119 + 27) = vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v314.val[0], v243)), (int32x4_t)v41);
              *((int32x4_t *)v119 + 22) = vtrn2q_s32(vrev64q_s32((int32x4_t)v291.val[0]), (int32x4_t)v166);
              *((int32x4_t *)v119 + 23) = vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v44, v243)), (int32x4_t)v298.val[0]);
              int8x16_t v36 = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v311.val[1], v243)), vuzp2q_s32((int32x4_t)v284.val[0], (int32x4_t)v310.val[0]));
              v38.i32[0] = v243.i32[2];
              int8x16_t v37 = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v38), (int32x4_t)v39);
              *((int8x16_t *)v119 + 18) = v37;
              *((int8x16_t *)v119 + 19) = v36;
              int32x4_t v110 = v119 + 128;
              unint64_t v109 = v79 + 32;
              unint64_t v167 = v79 + 64;
              v79 += 32;
              v119 += 128;
            }
            while (v167 <= v30 + a9);
          }
          else
          {
            unint64_t v109 = v79;
            int32x4_t v110 = a11;
            unint64_t v111 = v30 + a9;
          }
          unint64_t v168 = v111;
          if (v109 + 8 <= v111)
          {
            result = v218 + v45;
            do
            {
              v36.i64[0] = *(void *)(v33 + v109);
              v37.i64[0] = *(void *)(v239 + v33 + v109);
              v38.i64[0] = *(void *)(v236 + v33 + v109);
              v39.i64[0] = *(void *)(v220 + v33 + v109);
              int8x16_t v171 = vzip1q_s8(v39, v37);
              int8x16_t v172 = vzip1q_s8(v38, v36);
              int32x4_t v173 = (int32x4_t)vzip1q_s8(v171, v172);
              int32x4_t v174 = (int32x4_t)vzip2q_s8(v171, v172);
              int32x4_t v175 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v173, 0x20uLL), v173);
              int8x16_t v176 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v174, 0x20uLL), v174);
              int32x4_t v177 = vdupq_lane_s32(*(int32x2_t *)v176.i8, 1);
              int32x4_t v178 = vdupq_lane_s32(*(int32x2_t *)v175.i8, 1);
              int32x4_t v179 = vdupq_n_s32(v50);
              v40.i64[0] = *(void *)(v35 + v109);
              int8x16_t v180 = (int8x16_t)vaddq_s32((int32x4_t)v176, v179);
              v176.i64[0] = *(void *)(v238 + v35 + v109);
              v41.i64[0] = *(void *)(v235 + v35 + v109);
              v178.i64[0] = 0;
              v42.i64[0] = *(void *)(v219 + v35 + v109);
              int8x16_t v181 = vzip1q_s8(v42, v176);
              int8x16_t v182 = vzip1q_s8(v41, v40);
              v177.i64[0] = 0;
              int32x4_t v183 = (int32x4_t)vzip1q_s8(v181, v182);
              int32x4_t v184 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v183, 0x20uLL), v183);
              int8x16_t v185 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v184.i8, 1);
              int32x4_t v186 = vaddq_s32(v178, v175);
              int32x4_t v187 = (int32x4_t)vzip2q_s8(v181, v182);
              v185.i64[0] = 0;
              int32x4_t v188 = vdupq_n_s32(v49);
              int32x4_t v189 = vaddq_s32(v177, (int32x4_t)v180);
              v180.i64[0] = *(void *)(v45 + v109);
              v43.i64[0] = *(void *)(v237 + v45 + v109);
              int8x16_t v41 = (int8x16_t)vaddq_s32((int32x4_t)v185, v184);
              v185.i64[0] = *(void *)(v234 + v45 + v109);
              v44.i64[0] = *(void *)(result + v109);
              int32x4_t v190 = vdupq_laneq_s32(v186, 3);
              int8x16_t v43 = vzip1q_s8(v44, v43);
              int8x16_t v191 = vzip1q_s8(v185, v180);
              int32x4_t v192 = (int32x4_t)vzip1q_s8(v43, v191);
              int32x4_t v193 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v192, 0x20uLL), v192);
              int8x16_t v38 = (int8x16_t)vaddq_s32(v186, v179);
              int32x4_t v194 = vdupq_lane_s32(*(int32x2_t *)v193.i8, 1);
              v194.i64[0] = 0;
              int32x4_t v195 = vaddq_s32(v194, v193);
              int8x16_t v42 = (int8x16_t)vaddq_s32((int32x4_t)v41, v188);
              int8x16_t v44 = (int8x16_t)vdupq_n_s32(v48);
              int32x4_t v196 = vaddq_s32(v195, (int32x4_t)v44);
              v308.val[0] = (float32x4_t)vzip1q_s32(v108, (int32x4_t)v42);
              int32x4_t v197 = v110 + 16;
              v308.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v38, v196);
              int32x4_t v198 = v110;
              vst2q_f32(v198, v308);
              v198 += 8;
              int32x4_t v199 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v187, 0x20uLL), v187);
              int32x4_t v200 = vdupq_lane_s32(*(int32x2_t *)v199.i8, 1);
              v200.i64[0] = 0;
              int8x16_t v37 = (int8x16_t)vaddq_s32(v189, v190);
              int32x4_t v201 = vaddq_s32(v200, vaddq_s32(v199, v188));
              int32x4_t v202 = (int32x4_t)vzip2q_s8(v43, v191);
              int8x16_t v36 = (int8x16_t)vaddq_s32(v201, vdupq_laneq_s32((int32x4_t)v41, 3));
              int32x4_t v203 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v202, 0x20uLL), v202);
              int32x4_t v204 = vdupq_lane_s32(*(int32x2_t *)v203.i8, 1);
              unsigned int v50 = v37.u32[3];
              v204.i64[0] = 0;
              unsigned int v49 = v36.u32[3];
              int8x16_t v205 = v110 + 24;
              int8x16_t v39 = (int8x16_t)vaddq_s32(vaddq_s32(v204, vaddq_s32(v203, (int32x4_t)v44)), vdupq_laneq_s32(v195, 3));
              unsigned int v48 = v39.u32[3];
              v292.val[0] = (float32x4_t)vzip2q_s32(v108, (int32x4_t)v42);
              v292.val[1] = (float32x4_t)vzip2q_s32((int32x4_t)v38, v196);
              vst2q_f32(v198, v292);
              v292.val[0] = (float32x4_t)vzip1q_s32(v108, (int32x4_t)v36);
              v292.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v37, (int32x4_t)v39);
              vst2q_f32(v197, v292);
              v292.val[0] = (float32x4_t)vzip2q_s32(v108, (int32x4_t)v36);
              int8x16_t v40 = (int8x16_t)vzip2q_s32((int32x4_t)v37, (int32x4_t)v39);
              vst2q_f32(v205, *(float32x4x2_t *)(&v40 - 1));
              int32x4_t v170 = v110 + 32;
              unint64_t v169 = v109 + 8;
              unint64_t v206 = v109 + 16;
              v109 += 8;
              v110 += 32;
            }
            while (v206 <= v111);
          }
          else
          {
            unint64_t v169 = v109;
            int32x4_t v170 = v110;
          }
          if (v169 < v111)
          {
            uint64_t v207 = 0;
            unint64_t v208 = v236 + v169 + v33;
            unint64_t v209 = v239 + v169 + v33;
            unint64_t v210 = v33 + v169;
            unint64_t v211 = v235 + v169 + v35;
            unint64_t v212 = v238 + v169 + v35;
            result = v35 + v169;
            unint64_t v213 = v234 + v169 + v45;
            unint64_t v214 = v237 + v169 + v45;
            unint64_t v215 = v45 + v169;
            unint64_t v216 = v168 - v169;
            do
            {
              v50 += (*(unsigned __int8 *)(v210 + v207) << 24) | (*(unsigned __int8 *)(v209 + v207) << 16) | (*(unsigned __int8 *)(v208 + v207) << 8) | *(unsigned __int8 *)(v208 + v207);
              v49 += (*(unsigned __int8 *)(result + v207) << 24) | (*(unsigned __int8 *)(v212 + v207) << 16) | (*(unsigned __int8 *)(v211 + v207) << 8) | *(unsigned __int8 *)(v211 + v207);
              v48 += (*(unsigned __int8 *)(v215 + v207) << 24) | (*(unsigned __int8 *)(v214 + v207) << 16) | (*(unsigned __int8 *)(v213 + v207) << 8) | *(unsigned __int8 *)(v213 + v207);
              *(void *)&long long v217 = __PAIR64__(v50, v12);
              *((void *)&v217 + 1) = __PAIR64__(v48, v49);
              *(_OWORD *)&v170[4 * v207++] = v217;
            }
            while (v216 != v207);
          }
        }
        a11 = (float *)((char *)a11 + a12);
        uint64_t v28 = v240 + a10;
      }
      while (v28 + (unint64_t)a3[7].u32[0] < v232);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unint64_t a11, uint64_t a12)
{
  unint64_t v283 = result;
  if (a9)
  {
    unint64_t v284 = HIDWORD(*(void *)(a2 + 56));
    if (*((unsigned char *)*a4 + 24))
    {
      _D0 = **a4;
      __asm { FCVT            H0, D0 }
      unsigned int v19 = _D0;
    }
    else
    {
      unsigned int v19 = 32256;
    }
    double v20 = *(ChannelDescription **)(a5 + 8);
    int32x2_t v299 = a3[3];
    uint64_t v21 = a3[7].u32[1];
    int32x2_t v22 = *(int32x2_t *)((char *)v20 + 48);
    int32x2_t v23 = *(int32x2_t *)(*(void *)(*((void *)v20 + 5) + 8 * v21) + 16);
    int8x16_t v282 = v20;
    unsigned int v281 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v20, (a3[6].i32[1] + v299.i32[1] * v284), v299.u32[0], v21);
    int32x2_t v24 = *(ChannelDescription **)(a6 + 8);
    *(int32x2_t *)v297.i8 = a3[3];
    uint64_t v25 = a3[7].u32[1];
    int32x2_t v26 = *(int32x2_t *)((char *)v24 + 48);
    int32x2_t v27 = *(int32x2_t *)(*(void *)(*((void *)v24 + 5) + 8 * v25) + 16);
    uint64_t v279 = v297.u32[0];
    int8x16x2_t v280 = v24;
    unsigned int v278 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v24, (a3[6].i32[1] + v297.i32[1] * v284), v297.u32[0], v25);
    uint64_t v28 = *(ChannelDescription **)(a7 + 8);
    *(int32x2_t *)v295.val[0].i8 = a3[3];
    uint64_t v29 = a3[7].u32[1];
    int32x2_t v30 = *(int32x2_t *)((char *)v28 + 48);
    int32x2_t v31 = *(int32x2_t *)(*(void *)(*((void *)v28 + 5) + 8 * v29) + 16);
    uint64_t v276 = v295.val[0].u32[0];
    int8x16x2_t v277 = v28;
    unsigned int v275 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v28, (a3[6].i32[1] + v295.val[0].i32[1] * v284), v295.val[0].u32[0], v29);
    uint64_t v32 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v32 < v284)
    {
      uint64_t v288 = vmin_u32((uint32x2_t)vmls_s32(v23, v22, v299), (uint32x2_t)v22).u32[0];
      uint64_t v287 = vmin_u32((uint32x2_t)vmls_s32(v27, v26, *(int32x2_t *)v297.i8), (uint32x2_t)v26).u32[0];
      uint64_t v286 = vmin_u32((uint32x2_t)vmls_s32(v31, v30, *(int32x2_t *)v295.val[0].i8), (uint32x2_t)v30).u32[0];
      int v274 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v34 = a3[5].u32[1];
      int16x8_t v35 = vdupq_n_s16(v19);
      unint64_t v36 = v34 + a9;
      do
      {
        unint64_t v37 = (v274 + v32);
        unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v282, v37, v299.u32[0], v281);
        if (HIDWORD(LocationForTile)) {
          unint64_t v39 = v283 + LocationForTile;
        }
        else {
          unint64_t v39 = 0;
        }
        unint64_t v40 = ChannelDescription::GetLocationForTile(v280, v37, v279, v278);
        if (HIDWORD(v40)) {
          unint64_t v41 = v283 + v40;
        }
        else {
          unint64_t v41 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v277, v37, v276, v275);
        int8x16_t v44 = (int8x16_t)xmmword_228F61DE0;
        int8x16_t v45 = (int8x16_t)xmmword_228F61DD0;
        v46.i64[0] = 0xFFFFFFFF00000000;
        v46.i64[1] = 0xFFFFFFFF00000000;
        if (HIDWORD(result)) {
          unint64_t v47 = v283 + result;
        }
        else {
          unint64_t v47 = 0;
        }
        if (v39) {
          _ZF = v41 == 0;
        }
        else {
          _ZF = 1;
        }
        if (!_ZF && v47 != 0)
        {
          if (v34 >= 0x20)
          {
            uint64_t v60 = 0;
            unsigned int v52 = 0;
            unsigned int v51 = 0;
            unsigned int v50 = 0;
            uint64_t v61 = v288 + v39;
            uint64_t v62 = v287 + v41;
            uint64_t v63 = v286 + v47;
            int8x16_t v54 = (int8x16_t)xmmword_228F41C00;
            uint64_t v55 = (int8x16_t *)&loc_228F41000;
            unint64_t v56 = (int8x16_t *)&loc_228F41000;
            unint64_t v57 = (int8x16_t *)&loc_228F41000;
            uint64_t v58 = (int8x16_t *)&loc_228F41000;
            unint64_t v59 = (int8x16_t *)&loc_228F41000;
            do
            {
              int8x16_t v65 = *(int8x16_t *)(v39 + v60);
              int8x16_t v64 = *(int8x16_t *)(v39 + v60 + 16);
              int8x16_t v67 = *(int8x16_t *)(v61 + v60);
              int8x16_t v66 = *(int8x16_t *)(v61 + v60 + 16);
              int16x8_t v68 = (int16x8_t)vzip1q_s8(v67, v65);
              int16x8_t v69 = (int16x8_t)vzip2q_s8(v67, v65);
              int16x8_t v70 = (int16x8_t)vzip1q_s8(v66, v64);
              int16x8_t v71 = (int16x8_t)vzip2q_s8(v66, v64);
              int8x16_t v72 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v68, 0x10uLL), v68);
              int8x16_t v73 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v69, 0x10uLL), v69);
              int8x16_t v74 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v70, 0x10uLL), v70);
              int8x16_t v75 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v71, 0x10uLL), v71);
              int16x8_t v76 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v75, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v75);
              int16x8_t v77 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v74, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v74);
              int16x8_t v78 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v73, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v73);
              int16x8_t v79 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v72, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v72);
              int8x16_t v81 = *(int8x16_t *)(v41 + v60);
              int8x16_t v80 = *(int8x16_t *)(v41 + v60 + 16);
              int8x16_t v83 = *(int8x16_t *)(v62 + v60);
              int8x16_t v82 = *(int8x16_t *)(v62 + v60 + 16);
              int16x8_t v84 = (int16x8_t)vzip1q_s8(v83, v81);
              int16x8_t v85 = (int16x8_t)vzip2q_s8(v83, v81);
              int16x8_t v86 = (int16x8_t)vzip1q_s8(v82, v80);
              int16x8_t v87 = (int16x8_t)vzip2q_s8(v82, v80);
              int8x16_t v88 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v84, 0x10uLL), v84);
              int8x16_t v89 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v85, 0x10uLL), v85);
              int8x16_t v90 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v86, 0x10uLL), v86);
              int8x16_t v91 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v87, 0x10uLL), v87);
              int16x8_t v92 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v91, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v91);
              int16x8_t v93 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v90, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v90);
              int16x8_t v94 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v89, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v89);
              int16x8_t v95 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v88, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v88);
              int16x8_t v96 = vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v93.i8, 3), v93);
              int8x16_t v98 = *(int8x16_t *)(v47 + v60);
              int8x16_t v97 = *(int8x16_t *)(v47 + v60 + 16);
              int8x16_t v100 = *(int8x16_t *)(v63 + v60);
              int8x16_t v99 = *(int8x16_t *)(v63 + v60 + 16);
              int16x8_t v101 = (int16x8_t)vzip1q_s8(v100, v98);
              int16x8_t v102 = (int16x8_t)vzip2q_s8(v100, v98);
              int16x8_t v103 = (int16x8_t)vzip1q_s8(v99, v97);
              int16x8_t v104 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v79.i8, 3), v79), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v78.i8, 3), v78));
              int16x8_t v105 = (int16x8_t)vzip2q_s8(v99, v97);
              int8x16_t v106 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v101, 0x10uLL), v101);
              int8x16_t v107 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v102, 0x10uLL), v102);
              int16x8_t v108 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v77.i8, 3), v77), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v76.i8, 3), v76));
              int8x16_t v109 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v103, 0x10uLL), v103);
              int8x16_t v110 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v105, 0x10uLL), v105);
              int16x8_t v111 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v95.i8, 3), v95), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v94.i8, 3), v94));
              int16x8_t v112 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v110, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v110);
              int16x8_t v113 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v109, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v109);
              int16x8_t v114 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v107, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v107);
              int16x8_t v115 = vaddq_s16(v108, v104);
              int16x8_t v116 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v106, (int8x16_t)xmmword_228F61DD0), v46), (int16x8_t)v106);
              int v117 = v115.u16[7];
              int8x16_t v43 = (int8x16_t)vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v116.i8, 3), v116), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v114.i8, 3), v114));
              int8x16_t v42 = (int8x16_t)vaddq_s16(vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v113.i8, 3), v113), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v112.i8, 3), v112)), (int16x8_t)v43);
              v52 += v117;
              v51 += vaddq_s16(vaddq_s16(v96, vaddq_s16(vdupq_lane_s16(*(int16x4_t *)&v92, 3), v92)), v111).u16[7];
              v50 += v42.u16[7];
              unint64_t v53 = v60 + 32;
              unint64_t v118 = v60 + 64;
              v60 += 32;
            }
            while (v118 <= v34);
          }
          else
          {
            unsigned int v50 = 0;
            unsigned int v51 = 0;
            unsigned int v52 = 0;
            unint64_t v53 = 0;
            int8x16_t v54 = (int8x16_t)xmmword_228F41C00;
            uint64_t v55 = (int8x16_t *)&loc_228F41000;
            unint64_t v56 = (int8x16_t *)&loc_228F41000;
            unint64_t v57 = (int8x16_t *)&loc_228F41000;
            uint64_t v58 = (int8x16_t *)&loc_228F41000;
            unint64_t v59 = (int8x16_t *)&loc_228F41000;
          }
          if ((v53 | 8) <= v34)
          {
            do
            {
              v42.i64[0] = *(void *)(v39 + v53);
              v43.i64[0] = *(void *)(v288 + v39 + v53);
              int16x8_t v120 = (int16x8_t)vzip1q_s8(v43, v42);
              int8x16_t v121 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v120, 0x10uLL), v120);
              int8x16_t v122 = vextq_s8(v121, v121, 0xCuLL);
              int8x16_t v123 = (int8x16_t)vaddq_s16((int16x8_t)v122, (int16x8_t)v121);
              int v124 = v123.u16[3];
              unsigned int v125 = v123.u16[7] + v52;
              v123.i64[0] = *(void *)(v41 + v53);
              v122.i64[0] = *(void *)(v287 + v41 + v53);
              int16x8_t v126 = (int16x8_t)vzip1q_s8(v122, v123);
              int8x16_t v127 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v126, 0x10uLL), v126);
              int8x16_t v128 = vextq_s8(v127, v127, 0xCuLL);
              int8x16_t v129 = (int8x16_t)vaddq_s16((int16x8_t)v128, (int16x8_t)v127);
              unsigned int v52 = v125 + v124;
              int v130 = v129.u16[3];
              v129.i64[0] = *(void *)(v47 + v53);
              v51 += v129.u16[7] + v130;
              v128.i64[0] = *(void *)(v286 + v47 + v53);
              int16x8_t v131 = (int16x8_t)vzip1q_s8(v128, v129);
              int8x16_t v132 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v131, 0x10uLL), v131);
              int8x16_t v43 = vextq_s8(v132, v132, 0xCuLL);
              int8x16_t v42 = (int8x16_t)vaddq_s16((int16x8_t)v43, (int16x8_t)v132);
              v50 += v42.u16[7] + v42.u16[3];
              unint64_t v119 = v53 + 8;
              unint64_t v133 = v53 + 16;
              v53 += 8;
            }
            while (v133 <= v34);
          }
          else
          {
            unint64_t v119 = v53;
          }
          unint64_t v134 = v34 - v119;
          if (v34 > v119)
          {
            int32x4_t v135 = (unsigned __int8 *)(v288 + v119 + v39);
            int32x4_t v136 = (unsigned __int8 *)(v39 + v119);
            int32x4_t v137 = (unsigned __int8 *)(v287 + v119 + v41);
            int32x4_t v138 = (unsigned __int8 *)(v41 + v119);
            int32x4_t v139 = (unsigned __int8 *)(v286 + v119 + v47);
            int32x4_t v140 = (unsigned __int8 *)(v47 + v119);
            do
            {
              int v142 = *v136++;
              int v141 = v142;
              int v143 = *v135++;
              int v144 = v143 | (v141 << 8);
              int v146 = *v138++;
              int v145 = v146;
              v52 += v144;
              int v147 = *v137++;
              int v148 = v147 | (v145 << 8);
              int v150 = *v140++;
              int v149 = v150;
              v51 += v148;
              int v151 = *v139++;
              v50 += v151 | (v149 << 8);
              --v134;
            }
            while (v134);
            unint64_t v119 = v34;
          }
          if (v119 + 32 <= v36)
          {
            uint64_t v153 = v288 + v39;
            uint64_t v154 = v287 + v41;
            uint64_t v155 = v286 + v47;
            int32x4_t v156 = (int8x16_t *)a11;
            do
            {
              int8x16_t v158 = *(int8x16_t *)(v39 + v119);
              int8x16_t v157 = *(int8x16_t *)(v39 + v119 + 16);
              int8x16_t v160 = *(int8x16_t *)(v153 + v119);
              int8x16_t v159 = *(int8x16_t *)(v153 + v119 + 16);
              int16x8_t v161 = (int16x8_t)vzip2q_s8(v160, v158);
              int16x8_t v162 = (int16x8_t)vzip2q_s8(v159, v157);
              int16x8_t v163 = (int16x8_t)vzip1q_s8(v159, v157);
              int16x8_t v164 = (int16x8_t)vzip1q_s8(v160, v158);
              int8x16_t v165 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v161, 0x10uLL), v161);
              int8x16_t v166 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v162, 0x10uLL), v162);
              int8x16_t v167 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v163, 0x10uLL), v163);
              int8x16_t v168 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v164, 0x10uLL), v164);
              int16x8_t v169 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v168, v45), v46), (int16x8_t)v168);
              int16x8_t v170 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v167, v45), v46), (int16x8_t)v167);
              int16x8_t v171 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v166, v45), v46), (int16x8_t)v166);
              int16x8_t v172 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v165, v45), v46), (int16x8_t)v165);
              int16x8_t v173 = vdupq_n_s16(v52);
              int8x16_t v175 = *(int8x16_t *)(v41 + v119);
              int8x16_t v174 = *(int8x16_t *)(v41 + v119 + 16);
              int8x16_t v176 = *(int8x16_t *)(v154 + v119);
              int8x16_t v177 = *(int8x16_t *)(v154 + v119 + 16);
              int16x8_t v178 = (int16x8_t)vzip2q_s8(v176, v175);
              int16x8_t v179 = (int16x8_t)vzip2q_s8(v177, v174);
              int16x8_t v180 = (int16x8_t)vzip1q_s8(v177, v174);
              int16x8_t v181 = (int16x8_t)vzip1q_s8(v176, v175);
              int8x16_t v182 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v178, 0x10uLL), v178);
              int16x8_t v183 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v170.i8, 3), v44), v170);
              int8x16_t v184 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v179, 0x10uLL), v179);
              int8x16_t v185 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v180, 0x10uLL), v180);
              int8x16_t v186 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v181, 0x10uLL), v181);
              int16x8_t v187 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v169.i8, 3), v44), v169);
              int16x8_t v188 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v186, v45), v46), (int16x8_t)v186);
              int16x8_t v189 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v184, v45), v46), (int16x8_t)v184);
              int16x8_t v190 = vdupq_laneq_s16(v183, 7);
              int16x8_t v191 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v182, v45), v46), (int16x8_t)v182);
              int16x8_t v192 = vaddq_s16(v183, v173);
              int16x8_t v193 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v185, v45), v46), (int16x8_t)v185);
              int16x8_t v194 = vaddq_s16(v187, v173);
              int16x8_t v195 = vaddq_s16(v190, vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v171.i8, 3), v44), v171));
              int16x8_t v196 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v193.i8, 3), v44), v193);
              int16x8_t v298 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v188.i8, 3), v44), v188);
              int16x8_t v197 = vaddq_s16(vdupq_laneq_s16(v187, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v172.i8, 3), v44), v172));
              int16x8_t v198 = vdupq_n_s16(v51);
              int16x8_t v199 = vaddq_s16(v196, v198);
              int16x8_t v200 = vaddq_s16(vdupq_laneq_s16(v196, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v189.i8, 3), v44), v189));
              int8x16_t v202 = *(int8x16_t *)(v47 + v119);
              int8x16_t v201 = *(int8x16_t *)(v47 + v119 + 16);
              int16x8_t v203 = vaddq_s16(vdupq_laneq_s16(v298, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v191.i8, 3), v44), v191));
              int8x16_t v204 = *(int8x16_t *)(v155 + v119);
              int8x16_t v205 = *(int8x16_t *)(v155 + v119 + 16);
              int16x8_t v206 = (int16x8_t)vzip2q_s8(v204, v202);
              int16x8_t v207 = (int16x8_t)vzip2q_s8(v205, v201);
              int16x8_t v208 = (int16x8_t)vzip1q_s8(v205, v201);
              int16x8_t v209 = vdupq_laneq_s16(v197, 7);
              int16x8_t v210 = (int16x8_t)vzip1q_s8(v204, v202);
              int16x8_t v211 = vaddq_s16(v195, v173);
              int8x16_t v212 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v206, 0x10uLL), v206);
              int8x16_t v213 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v207, 0x10uLL), v207);
              int8x16_t v214 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v208, 0x10uLL), v208);
              int8x16_t v215 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v210, 0x10uLL), v210);
              v308.val[0] = (int8x16_t)vaddq_s16(v197, v173);
              int16x8_t v216 = vdupq_laneq_s16(v203, 7);
              int16x8_t v217 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v215, v45), v46), (int16x8_t)v215);
              int16x8_t v218 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v213, v45), v46), (int16x8_t)v213);
              int16x8_t v294 = v198;
              int16x8_t v219 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v212, v45), v46), (int16x8_t)v212);
              v312.val[1] = (int8x16_t)vaddq_s16(v203, v198);
              int16x8_t v220 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v214, v45), v46), (int16x8_t)v214);
              v313.val[0] = (int8x16_t)vaddq_s16(v211, v209);
              int16x8_t v221 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v219.i8, 3), v44), v219);
              v309.val[0] = (int8x16_t)vaddq_s16(v192, v209);
              int16x8_t v222 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v218.i8, 3), v44), v218);
              int16x8_t v223 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v220.i8, 3), v44), v220);
              int16x8_t v224 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v217.i8, 3), v44), v217);
              int16x8_t v225 = vaddq_s16(vaddq_s16(v200, v198), v216);
              int16x8_t v226 = vaddq_s16(vdupq_laneq_s16(v224, 7), v221);
              int16x8_t v227 = vdupq_laneq_s16(v226, 7);
              v311.val[1] = (int8x16_t)vaddq_s16(v199, v216);
              int16x8_t v228 = vdupq_n_s16(v50);
              unsigned int v52 = v313.val[0].u16[7];
              v313.val[1] = (int8x16_t)vaddq_s16(vaddq_s16(vaddq_s16(vdupq_laneq_s16(v223, 7), v222), v228), v227);
              v309.val[1] = (int8x16_t)vaddq_s16(vaddq_s16(v223, v228), v227);
              v308.val[1] = (int8x16_t)vaddq_s16(v226, v228);
              unsigned int v50 = v313.val[1].u16[7];
              int16x8_t v229 = vaddq_s16(v224, v228);
              v310.val[0] = (int8x16_t)v194;
              v310.val[1] = (int8x16_t)v229;
              int8x16_t v230 = v55[190];
              int8x16_t v231 = vqtbl2q_s8(*(int8x16x2_t *)v35.i8, v230);
              int8x16_t v232 = v56[204];
              v296.val[0] = vqtbl2q_s8(*(int8x16x2_t *)v35.i8, v54);
              v296.val[1] = vqtbl2q_s8(v313, (int8x16_t)xmmword_228F41CD0);
              v304.val[0] = (int8x16_t)v35;
              v304.val[1] = (int8x16_t)v225;
              int8x16_t v233 = v57[195];
              int8x16_t v234 = v58[207];
              int8x16_t v235 = v59[194];
              int8x16_t v292 = v231;
              int8x16_t v293 = vqtbl2q_s8(v313, v232);
              v312.val[0] = v304.val[0];
              int8x16_t v290 = vqtbl2q_s8(v312, (int8x16_t)xmmword_228F41C00);
              int8x16_t v291 = vqtbl2q_s8(v308, (int8x16_t)xmmword_228F41CD0);
              v306.val[0] = vqtbl2q_s8(v312, v230);
              v306.val[1] = vqtbl2q_s8(v308, v232);
              v289.val[0] = vqtbl2q_s8(v304, v233);
              v289.val[1] = vqtbl2q_s8(v313, v234);
              v307.val[0] = vqtbl2q_s8(v312, v233);
              v307.val[1] = vqtbl2q_s8(v308, v234);
              v312.val[0] = vqtbl2q_s8(v312, v235);
              v312.val[1] = vqtbl2q_s8(v308, (int8x16_t)xmmword_228F41CE0);
              v308.val[0] = vqtbl2q_s8(v304, v235);
              v308.val[1] = vqtbl2q_s8(v313, (int8x16_t)xmmword_228F41CE0);
              v311.val[0] = v304.val[0];
              v313.val[0] = vqtbl2q_s8(v311, (int8x16_t)xmmword_228F41C00);
              v313.val[1] = vqtbl2q_s8(v309, (int8x16_t)xmmword_228F41CD0);
              v303.val[0] = vqtbl2q_s8(v311, v230);
              v303.val[1] = vqtbl2q_s8(v309, v232);
              v301.val[0] = vqtbl2q_s8(v311, v233);
              v301.val[1] = vqtbl2q_s8(v309, v234);
              v311.val[0] = vqtbl2q_s8(v311, v235);
              v311.val[1] = vqtbl2q_s8(v309, (int8x16_t)xmmword_228F41CE0);
              v309.val[1] = (int8x16_t)vaddq_s16(v298, v294);
              v309.val[0] = v304.val[0];
              v300.val[0] = vqtbl2q_s8(v309, v230);
              v300.val[1] = vqtbl2q_s8(v310, v232);
              v314.val[0] = vqtbl2q_s8(v309, v233);
              v314.val[1] = vqtbl2q_s8(v310, v234);
              v305.val[0] = vqtbl2q_s8(v309, v235);
              v305.val[1] = vqtbl2q_s8(v310, (int8x16_t)xmmword_228F41CE0);
              int8x16_t v54 = (int8x16_t)xmmword_228F41C00;
              v309.val[0] = vqtbl2q_s8(v309, (int8x16_t)xmmword_228F41C00);
              v309.val[1] = vqtbl2q_s8(v310, (int8x16_t)xmmword_228F41CD0);
              v308.val[0] = vqtbl2q_s8(v308, (int8x16_t)xmmword_228F41B50);
              v308.val[1] = vqtbl2q_s8(v311, (int8x16_t)xmmword_228F41B50);
              v303.val[0] = vqtbl2q_s8(v303, (int8x16_t)xmmword_228F41B50);
              v303.val[1] = vqtbl2q_s8(v313, (int8x16_t)xmmword_228F41B50);
              v46.i64[0] = 0xFFFFFFFF00000000;
              v46.i64[1] = 0xFFFFFFFF00000000;
              v310.val[0] = vqtbl2q_s8(v312, (int8x16_t)xmmword_228F41B50);
              v311.val[1] = v292;
              int8x16_t v236 = v293;
              v312.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v311 + 16), (int8x16_t)xmmword_228F41B50);
              v311.val[1] = v290;
              int8x16_t v237 = v291;
              int8x16_t v238 = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v311 + 16), (int8x16_t)xmmword_228F41B50);
              v311.val[1] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F41B50);
              int16x8_t v35 = (int16x8_t)v304.val[0];
              int8x16_t v42 = vqtbl2q_s8(v300, (int8x16_t)xmmword_228F41B50);
              int8x16_t v43 = vqtbl2q_s8(v309, (int8x16_t)xmmword_228F41B50);
              int8x16_t v44 = (int8x16_t)xmmword_228F61DE0;
              int8x16_t v45 = (int8x16_t)xmmword_228F61DD0;
              v156[2] = v43;
              v156[3] = v42;
              *int32x4_t v156 = vqtbl2q_s8(v314, (int8x16_t)xmmword_228F41B50);
              v156[1] = v311.val[1];
              v156[6] = v238;
              v156[7] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F41B50);
              v156[4] = vqtbl2q_s8(v307, (int8x16_t)xmmword_228F41B50);
              v156[5] = v310.val[0];
              v156[14] = vqtbl2q_s8(v296, (int8x16_t)xmmword_228F41B50);
              v156[15] = v312.val[0];
              v156[12] = vqtbl2q_s8(v289, (int8x16_t)xmmword_228F41B50);
              v156[13] = v308.val[0];
              v156[10] = v303.val[1];
              v156[11] = v303.val[0];
              v156[8] = vqtbl2q_s8(v301, (int8x16_t)xmmword_228F41B50);
              v156[9] = v308.val[1];
              unsigned int v51 = v304.val[1].u16[7];
              result = (unint64_t)&v156[16];
              unint64_t v152 = v119 + 32;
              unint64_t v239 = v119 + 64;
              v119 += 32;
              v156 += 16;
            }
            while (v239 <= v36);
          }
          else
          {
            unint64_t v152 = v119;
            result = a11;
          }
          if (v152 + 8 <= v36)
          {
            do
            {
              v42.i64[0] = *(void *)(v39 + v152);
              v43.i64[0] = *(void *)(v288 + v39 + v152);
              int16x8_t v242 = (int16x8_t)vzip1q_s8(v43, v42);
              int8x16_t v243 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v242, 0x10uLL), v242);
              int16x8_t v244 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v243, v45), v46), (int16x8_t)v243);
              int8x16_t v245 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v244.i8, 3), v44);
              int8x16_t v246 = (int8x16_t)vdupq_n_s16(v52);
              int8x16_t v42 = (int8x16_t)vaddq_s16(vaddq_s16(v244, (int16x8_t)v246), (int16x8_t)v245);
              unsigned int v52 = v42.u16[7];
              v245.i64[0] = *(void *)(v41 + v152);
              v246.i64[0] = *(void *)(v287 + v41 + v152);
              int16x8_t v247 = (int16x8_t)vzip1q_s8(v246, v245);
              int8x16_t v248 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v247, 0x10uLL), v247);
              int16x8_t v249 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v248, v45), v46), (int16x8_t)v248);
              int8x16_t v250 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v249.i8, 3), v44);
              int8x16_t v251 = (int8x16_t)vdupq_n_s16(v51);
              int8x16_t v43 = (int8x16_t)vaddq_s16(vaddq_s16(v249, (int16x8_t)v251), (int16x8_t)v250);
              unsigned int v51 = v43.u16[7];
              v250.i64[0] = *(void *)(v47 + v152);
              v251.i64[0] = *(void *)(v286 + v47 + v152);
              int16x8_t v252 = (int16x8_t)vzip1q_s8(v251, v250);
              int8x16_t v253 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v252, 0x10uLL), v252);
              int16x8_t v254 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v253, v45), v46), (int16x8_t)v253);
              int16x8_t v255 = vaddq_s16(vaddq_s16(v254, vdupq_n_s16(v50)), (int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v254.i8, 3), v44));
              unsigned int v50 = v255.u16[7];
              v302.val[0] = vzip1q_s16(v35, (int16x8_t)v43);
              v302.val[1] = vzip1q_s16((int16x8_t)v42, v255);
              int32x4_t v241 = (void *)(result + 64);
              vst2q_s16((__int16 *)result, v302);
              int8x16_t v256 = (__int16 *)(result + 32);
              v302.val[0] = vzip2q_s16(v35, (int16x8_t)v43);
              v302.val[1] = vzip2q_s16((int16x8_t)v42, v255);
              vst2q_s16(v256, v302);
              unint64_t v240 = v152 + 8;
              unint64_t v257 = v152 + 16;
              v152 += 8;
              result = (unint64_t)v241;
            }
            while (v257 <= v36);
          }
          else
          {
            unint64_t v240 = v152;
            int32x4_t v241 = (void *)result;
          }
          if (v240 < v36)
          {
            unint64_t v258 = v36 - v240;
            int8x16_t v259 = (unsigned __int8 *)(v288 + v240 + v39);
            int8x16_t v260 = (unsigned __int8 *)(v39 + v240);
            int8x16x2_t v261 = (unsigned __int8 *)(v287 + v240 + v41);
            int8x16_t v262 = (unsigned __int8 *)(v41 + v240);
            result = v286 + v240 + v47;
            int8x16_t v263 = (unsigned __int8 *)(v47 + v240);
            do
            {
              int v265 = *v260++;
              int v264 = v265;
              int v266 = *v259++;
              v52 += v266 | (v264 << 8);
              int v268 = *v262++;
              int v267 = v268;
              int v269 = *v261++;
              v51 += v269 | (v267 << 8);
              int v271 = *v263++;
              int v270 = v271;
              int v272 = *(unsigned __int8 *)result++;
              LOWORD(v273) = v19;
              WORD1(v273) = v52;
              WORD2(v273) = v51;
              v50 += v272 | (v270 << 8);
              HIWORD(v273) = v50;
              *v241++ = v273;
              --v258;
            }
            while (v258);
          }
        }
        a11 += a12;
        v32 += a10;
      }
      while (v32 + (unint64_t)a3[7].u32[0] < v284);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<float,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, double **a4, uint64_t a5, uint64_t a6, uint64_t a7, double a8, uint64_t a9, uint64_t a10, unsigned int a11, unint64_t a12, uint64_t a13)
{
  unint64_t v277 = result;
  if (a10)
  {
    unint64_t v278 = HIDWORD(*(void *)(a2 + 56));
    v16 = *a4;
    if (*((unsigned char *)*a4 + 24))
    {
      a8 = *v16;
      *(float *)&a8 = *v16;
    }
    else
    {
      LODWORD(a8) = 2143289344;
    }
    int32x2_t v266 = *(int32x2_t *)&a8;
    uint64_t v17 = *(ChannelDescription **)(a5 + 8);
    int32x2_t v327 = a3[3];
    uint64_t v18 = a3[7].u32[1];
    int32x2_t v19 = *(int32x2_t *)((char *)v17 + 48);
    int32x2_t v20 = *(int32x2_t *)(*(void *)(*((void *)v17 + 5) + 8 * v18) + 16);
    uint64_t v275 = v327.u32[0];
    uint64_t v276 = v17;
    unsigned int v274 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v17, (a3[6].i32[1] + v327.i32[1] * v278), v327.u32[0], v18);
    uint64_t v21 = *(ChannelDescription **)(a6 + 8);
    int32x2_t v323 = a3[3];
    uint64_t v22 = a3[7].u32[1];
    int32x2_t v23 = *(int32x2_t *)((char *)v21 + 48);
    int32x2_t v24 = *(int32x2_t *)(*(void *)(*((void *)v21 + 5) + 8 * v22) + 16);
    uint64_t v272 = v323.u32[0];
    uint64_t v273 = v21;
    unsigned int v271 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v21, (a3[6].i32[1] + v323.i32[1] * v278), v323.u32[0], v22);
    uint64_t v25 = *(ChannelDescription **)(a7 + 8);
    *(int32x2_t *)v320.val[0].i8 = a3[3];
    uint64_t v26 = a3[7].u32[1];
    int32x2_t v27 = *(int32x2_t *)((char *)v25 + 48);
    int32x2_t v28 = *(int32x2_t *)(*(void *)(*((void *)v25 + 5) + 8 * v26) + 16);
    uint64_t v269 = v320.val[0].u32[0];
    int v270 = v25;
    unsigned int v268 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v25, (a3[6].i32[1] + v320.val[0].i32[1] * v278), v320.val[0].u32[0], v26);
    uint64_t v29 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v29 < v278)
    {
      int v267 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v31 = a3[5].u32[1];
      uint64_t v284 = vmin_u32((uint32x2_t)vmls_s32(v24, v23, v323), (uint32x2_t)v23).u32[0];
      uint64_t v285 = vmin_u32((uint32x2_t)vmls_s32(v20, v19, v327), (uint32x2_t)v19).u32[0];
      uint64_t v281 = 2 * v284;
      uint64_t v282 = 2 * v285;
      uint64_t v283 = vmin_u32((uint32x2_t)vmls_s32(v28, v27, *(int32x2_t *)v320.val[0].i8), (uint32x2_t)v27).u32[0];
      uint64_t v280 = 2 * v283;
      unint64_t v32 = v31 + a10;
      int32x4_t v287 = vdupq_lane_s32(v266, 0);
      do
      {
        uint64_t v286 = v29;
        unint64_t v33 = (v267 + v29);
        unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v276, v33, v275, v274);
        if (HIDWORD(LocationForTile)) {
          unint64_t v35 = v277 + LocationForTile;
        }
        else {
          unint64_t v35 = 0;
        }
        unint64_t v36 = ChannelDescription::GetLocationForTile(v273, v33, v272, v271);
        if (HIDWORD(v36)) {
          unint64_t v37 = v277 + v36;
        }
        else {
          unint64_t v37 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v270, v33, v269, v268);
        unint64_t v44 = v277 + result;
        if (!HIDWORD(result)) {
          unint64_t v44 = 0;
        }
        if (v35) {
          BOOL v45 = v37 == 0;
        }
        else {
          BOOL v45 = 1;
        }
        if (!v45 && v44 != 0)
        {
          if (v31 >= 0x20)
          {
            uint64_t v57 = 0;
            unint64_t v58 = v282 + v35;
            uint64_t v59 = v285 + v35;
            unint64_t v60 = v281 + v37;
            v50.i64[0] = 0;
            uint64_t v61 = v284 + v37;
            v49.i64[0] = 0;
            unint64_t v62 = v280 + v44;
            v48.i64[0] = 0;
            uint64_t v63 = v283 + v44;
            unsigned int v51 = (int8x16_t *)&unk_228F61000;
            unsigned int v52 = (int8x16_t *)&unk_228F61000;
            unint64_t v53 = (int8x16_t *)&unk_228F61000;
            int8x16_t v54 = (int8x16_t *)&unk_228F61000;
            uint64_t v55 = (int8x16_t *)&unk_228F61000;
            unint64_t v56 = (int8x16_t *)&unk_228F61000;
            do
            {
              int32x2_t v324 = *(int32x2_t *)v49.i8;
              int32x2_t v328 = *(int32x2_t *)v48.i8;
              int8x16_t v64 = *(int8x16_t *)(v59 + v57);
              int8x16_t v65 = *(int8x16_t *)(v59 + v57 + 16);
              v334.val[1] = *(int8x16_t *)(v35 + v57);
              v332.val[1] = *(int8x16_t *)(v35 + v57 + 16);
              v334.val[0] = *(int8x16_t *)(v58 + v57);
              v332.val[0] = *(int8x16_t *)(v58 + v57 + 16);
              v321.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61DF0);
              v321.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61D50);
              v318.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61E00);
              v318.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61D90);
              v316.val[0] = vqtbl1q_s8(v64, (int8x16_t)xmmword_228F61DF0);
              v316.val[1] = vqtbl2q_s8(v334, (int8x16_t)xmmword_228F61D50);
              v314.val[0] = vqtbl1q_s8(v64, (int8x16_t)xmmword_228F61E10);
              v314.val[1] = vqtbl2q_s8(v334, (int8x16_t)xmmword_228F61D70);
              v312.val[0] = vqtbl1q_s8(v64, (int8x16_t)xmmword_228F61E00);
              v312.val[1] = vqtbl2q_s8(v334, (int8x16_t)xmmword_228F61D90);
              v310.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61E10);
              v310.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61D70);
              v308.val[0] = vqtbl1q_s8(v65, (int8x16_t)xmmword_228F61E20);
              v308.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61DB0);
              v306.val[0] = vqtbl1q_s8(v64, (int8x16_t)xmmword_228F61E20);
              v306.val[1] = vqtbl2q_s8(v334, (int8x16_t)xmmword_228F61DB0);
              v344.val[1] = *(int8x16_t *)(v37 + v57);
              v330.val[1] = *(int8x16_t *)(v37 + v57 + 16);
              v332.val[0] = *(int8x16_t *)(v61 + v57 + 16);
              v344.val[0] = *(int8x16_t *)(v60 + v57);
              v330.val[0] = *(int8x16_t *)(v60 + v57 + 16);
              v304.val[0] = vqtbl1q_s8(v332.val[0], (int8x16_t)xmmword_228F61DF0);
              v304.val[1] = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61D50);
              int8x16_t v301 = vqtbl1q_s8(v332.val[0], (int8x16_t)xmmword_228F61E00);
              int8x16_t v303 = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61D90);
              int8x16_t v298 = vqtbl1q_s8(v332.val[0], (int8x16_t)xmmword_228F61E10);
              int8x16_t v300 = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61D70);
              v342.val[0] = vqtbl1q_s8(v332.val[0], (int8x16_t)xmmword_228F61E20);
              v342.val[1] = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61DB0);
              v330.val[0] = *(int8x16_t *)(v61 + v57);
              int8x16_t v295 = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61DF0);
              int8x16_t v297 = vqtbl2q_s8(v344, (int8x16_t)xmmword_228F61D50);
              v293.val[0] = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61E10);
              v293.val[1] = vqtbl2q_s8(v344, (int8x16_t)xmmword_228F61D70);
              v339.val[0] = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61E00);
              v339.val[1] = vqtbl2q_s8(v344, (int8x16_t)xmmword_228F61D90);
              v352.val[0] = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61E20);
              v352.val[1] = vqtbl2q_s8(v344, (int8x16_t)xmmword_228F61DB0);
              v332.val[1] = *(int8x16_t *)(v44 + v57);
              v330.val[1] = *(int8x16_t *)(v44 + v57 + 16);
              v332.val[0] = *(int8x16_t *)(v62 + v57);
              v330.val[0] = *(int8x16_t *)(v62 + v57 + 16);
              v334.val[0] = *(int8x16_t *)(v63 + v57 + 16);
              v291.val[0] = vqtbl1q_s8(v334.val[0], (int8x16_t)xmmword_228F61DF0);
              v291.val[1] = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61D50);
              v344.val[1] = vqtbl1q_s8(v334.val[0], (int8x16_t)xmmword_228F61E00);
              int8x16_t v66 = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61D90);
              v345.val[0] = vqtbl1q_s8(v334.val[0], (int8x16_t)xmmword_228F61E10);
              v345.val[1] = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61D70);
              v346.val[0] = vqtbl1q_s8(v334.val[0], (int8x16_t)xmmword_228F61E20);
              v346.val[1] = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61DB0);
              v330.val[0] = *(int8x16_t *)(v63 + v57);
              v349.val[0] = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61DF0);
              v349.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61D50);
              v344.val[0].i64[0] = v50.i64[0];
              v337.val[0] = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61E10);
              v337.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61D70);
              v350.val[0] = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61E00);
              v350.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61D90);
              v334.val[0] = vqtbl1q_s8(v330.val[0], (int8x16_t)xmmword_228F61E20);
              v334.val[1] = vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61DB0);
              v332.val[1] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v67 = (int32x4_t)vqtbl2q_s8(v308, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v68 = (int32x4_t)vqtbl2q_s8(v310, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v69 = (int32x4_t)vqtbl2q_s8(v312, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v70 = (int32x4_t)vqtbl2q_s8(v314, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v71 = (int32x4_t)vqtbl2q_s8(v316, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v72 = (int32x4_t)vqtbl2q_s8(v318, (int8x16_t)xmmword_228F61DC0);
              v330.val[0] = vqtbl2q_s8(v321, (int8x16_t)xmmword_228F61DC0);
              v330.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v332.val[1], 0x20uLL), (int32x4_t)v332.val[1]);
              v332.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v67, 0x20uLL), v67);
              int32x4_t v73 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v68, 0x20uLL), v68);
              int32x4_t v74 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v69, 0x20uLL), v69);
              int32x4_t v75 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v70, 0x20uLL), v70);
              int32x4_t v76 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v71, 0x20uLL), v71);
              int32x4_t v77 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v72, 0x20uLL), v72);
              v330.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v330.val[0], 0x20uLL), (int32x4_t)v330.val[0]);
              v352.val[0] = vqtbl2q_s8(v352, (int8x16_t)xmmword_228F61DC0);
              v352.val[1] = vqtbl2q_s8(v342, (int8x16_t)xmmword_228F61DC0);
              int8x16_t v78 = v298;
              v342.val[0] = v300;
              int32x4_t v79 = (int32x4_t)vqtbl2q_s8(v342, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v80 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v76.i8, 1), v76), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v75.i8, 1), v75));
              int32x4_t v81 = (int32x4_t)vqtbl2q_s8(v339, (int8x16_t)xmmword_228F61DC0);
              v339.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v73.i8, 1);
              v339.val[0].i64[0] = 0;
              int32x4_t v82 = vaddq_s32((int32x4_t)v339.val[0], v73);
              v339.val[0] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F61DC0);
              v339.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v332.val[1].i8, 1);
              v339.val[1].i64[0] = 0;
              v332.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v339.val[1], (int32x4_t)v332.val[1]);
              v339.val[1] = v295;
              int8x16_t v83 = v297;
              v339.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v339 + 16), (int8x16_t)xmmword_228F61DC0);
              int8x16_t v84 = v301;
              v342.val[0] = v303;
              int32x4_t v85 = (int32x4_t)vqtbl2q_s8(v342, (int8x16_t)xmmword_228F61DC0);
              v342.val[0] = vqtbl2q_s8(v304, (int8x16_t)xmmword_228F61DC0);
              v352.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v352.val[0], 0x20uLL), (int32x4_t)v352.val[0]);
              v352.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v352.val[1], 0x20uLL), (int32x4_t)v352.val[1]);
              int32x4_t v86 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v79, 0x20uLL), v79);
              int32x4_t v87 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v81, 0x20uLL), v81);
              v339.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v339.val[0], 0x20uLL), (int32x4_t)v339.val[0]);
              v339.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v339.val[1], 0x20uLL), (int32x4_t)v339.val[1]);
              int32x4_t v88 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v85, 0x20uLL), v85);
              v342.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v342.val[0], 0x20uLL), (int32x4_t)v342.val[0]);
              v342.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v330.val[1].i8, 1);
              v342.val[1].i64[0] = 0;
              v330.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v342.val[1], (int32x4_t)v330.val[1]);
              v342.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v86.i8, 1);
              v342.val[1].i64[0] = 0;
              v330.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v74.i8, 1), v74), (int32x4_t)v330.val[1]);
              int32x4_t v89 = vdupq_lane_s32(*(int32x2_t *)v352.val[1].i8, 1);
              v89.i64[0] = 0;
              int32x4_t v90 = vaddq_s32(v89, (int32x4_t)v352.val[1]);
              v352.val[1] = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v87.i8, 1), v87);
              int32x4_t v91 = vdupq_lane_s32(*(int32x2_t *)v352.val[0].i8, 1);
              v91.i64[0] = 0;
              v334.val[0] = vqtbl2q_s8(v334, (int8x16_t)xmmword_228F61DC0);
              v346.val[0] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DC0);
              v330.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v330.val[0].i8, 1), (int32x4_t)v330.val[0]), 3), v82);
              int32x4_t v92 = (int32x4_t)vqtbl2q_s8(v345, (int8x16_t)xmmword_228F61DC0);
              v345.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61DC0);
              v337.val[0] = vqtbl2q_s8(v337, (int8x16_t)xmmword_228F61DC0);
              v337.val[1] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61DC0);
              v344.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v344 + 16), (int8x16_t)xmmword_228F61DC0);
              int32x4_t v93 = vaddq_s32((int32x4_t)v352.val[1], vaddq_s32(v91, (int32x4_t)v352.val[0]));
              v332.val[0] = vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61DC0);
              v346.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[0], 0x20uLL), (int32x4_t)v346.val[0]);
              v345.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v345.val[0], 0x20uLL), (int32x4_t)v345.val[0]);
              v337.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v337.val[1], 0x20uLL), (int32x4_t)v337.val[1]);
              v332.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v332.val[0], 0x20uLL), (int32x4_t)v332.val[0]);
              v330.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v330.val[0], vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v77.i8, 1), v77), 3), (int32x4_t)v332.val[1]));
              v332.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v344.val[1], 0x20uLL), (int32x4_t)v344.val[1]);
              int32x4_t v48 = vdupq_lane_s32(*(int32x2_t *)v337.val[1].i8, 1);
              v337.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v337.val[0], 0x20uLL), (int32x4_t)v337.val[0]);
              int32x4_t v94 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v92, 0x20uLL), v92);
              v350.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v94.i8, 1);
              v350.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v346.val[0].i8, 1);
              v334.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v334.val[0], 0x20uLL), (int32x4_t)v334.val[0]);
              v352.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v334.val[0].i8, 1);
              v352.val[0].i64[0] = 0;
              v330.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v330.val[0], vaddq_s32((int32x4_t)v330.val[1], v80));
              v350.val[1].i64[0] = 0;
              v350.val[0].i64[0] = 0;
              v330.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v350.val[0], v94);
              int32x4_t v49 = vaddq_s32(vaddq_s32(vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v342.val[0].i8, 1), (int32x4_t)v342.val[0]), 3), vaddq_s32((int32x4_t)v342.val[1], v86)), vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v88.i8, 1), v88), 3), v90)), vaddq_s32(v93, vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v339.val[1].i8, 1), (int32x4_t)v339.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v339.val[0].i8, 1), (int32x4_t)v339.val[0]))));
              int8x16_t v43 = (int8x16_t)vaddq_s32((int32x4_t)v350.val[1], (int32x4_t)v346.val[0]);
              int32x4_t v50 = vaddq_s32(v48, (int32x4_t)v337.val[1]);
              int8x16_t v42 = (int8x16_t)vaddq_s32(v50, vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v337.val[0].i8, 1), (int32x4_t)v337.val[0]));
              int8x16_t v41 = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v345.val[0].i8, 1), (int32x4_t)v345.val[0]), vaddq_s32((int32x4_t)v352.val[0], (int32x4_t)v334.val[0]));
              v50.i32[0] = vaddq_s32(*(int32x4_t *)&v330, vdupq_lane_s32(*(int32x2_t *)&v344, 0)).i32[3];
              v330.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v332.val[0].i8, 1), (int32x4_t)v332.val[0]), 3), (int32x4_t)v330.val[1]), vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v332.val[1].i8, 1), (int32x4_t)v332.val[1]), 3), (int32x4_t)v43));
              int8x16_t v39 = (int8x16_t)vaddq_s32((int32x4_t)v41, (int32x4_t)v42);
              int8x16_t v40 = (int8x16_t)vdupq_lane_s32(v328, 0);
              unint64_t v47 = v57 + 32;
              v49.i32[0] = vaddq_s32(v49, vdupq_lane_s32(v324, 0)).i32[3];
              unint64_t v95 = v57 + 64;
              int8x16_t v38 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v330.val[0], (int32x4_t)v39), (int32x4_t)v40);
              v57 += 32;
              v48.i32[0] = v38.i32[3];
            }
            while (v95 <= v31);
          }
          else
          {
            unint64_t v47 = 0;
            v48.i64[0] = 0;
            v49.i64[0] = 0;
            v50.i64[0] = 0;
            unsigned int v51 = (int8x16_t *)&unk_228F61000;
            unsigned int v52 = (int8x16_t *)&unk_228F61000;
            unint64_t v53 = (int8x16_t *)&unk_228F61000;
            int8x16_t v54 = (int8x16_t *)&unk_228F61000;
            uint64_t v55 = (int8x16_t *)&unk_228F61000;
            unint64_t v56 = (int8x16_t *)&unk_228F61000;
          }
          if ((v47 | 8) <= v31)
          {
            int8x16_t v41 = 0uLL;
            do
            {
              v38.i64[0] = *(void *)(v35 + v47);
              v39.i64[0] = *(void *)(v285 + v35 + v47);
              v40.i64[0] = *(void *)(v282 + v35 + v47);
              int8x16_t v97 = vzip1q_s8((int8x16_t)0, v39);
              int8x16_t v98 = vzip1q_s8(v40, v38);
              int32x4_t v99 = (int32x4_t)vzip1q_s8(v97, v98);
              int32x4_t v100 = (int32x4_t)vzip2q_s8(v97, v98);
              int32x4_t v101 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v99, 0x20uLL), v99);
              int32x4_t v102 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v100, 0x20uLL), v100);
              int8x16_t v103 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v102.i8, 1);
              int8x16_t v104 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v101.i8, 1), v101);
              int8x16_t v105 = (int8x16_t)vaddq_s32((int32x4_t)v103, vaddq_s32(v102, vdupq_lane_s32(*(int32x2_t *)v50.i8, 0)));
              v105.i64[0] = *(void *)(v37 + v47);
              v103.i64[0] = *(void *)(v284 + v37 + v47);
              int v106 = v105.i32[3] + v104.i32[3];
              v104.i64[0] = *(void *)(v281 + v37 + v47);
              int8x16_t v107 = vzip1q_s8((int8x16_t)0, v103);
              int8x16_t v108 = vzip1q_s8(v104, v105);
              int32x4_t v109 = (int32x4_t)vzip1q_s8(v107, v108);
              int32x4_t v110 = (int32x4_t)vzip2q_s8(v107, v108);
              int32x4_t v111 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v110, 0x20uLL), v110);
              int8x16_t v112 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v111.i8, 1);
              int32x4_t v113 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v109, 0x20uLL), v109);
              int8x16_t v114 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v113.i8, 1), v113);
              int8x16_t v115 = (int8x16_t)vaddq_s32((int32x4_t)v112, vaddq_s32(v111, vdupq_lane_s32(*(int32x2_t *)v49.i8, 0)));
              v50.i32[0] = v106;
              v115.i64[0] = *(void *)(v44 + v47);
              v112.i64[0] = *(void *)(v283 + v44 + v47);
              v49.i32[0] = v115.i32[3] + v114.i32[3];
              v114.i64[0] = *(void *)(v280 + v44 + v47);
              int8x16_t v116 = vzip1q_s8((int8x16_t)0, v112);
              int8x16_t v117 = vzip1q_s8(v114, v115);
              int32x4_t v118 = (int32x4_t)vzip1q_s8(v116, v117);
              int32x4_t v119 = (int32x4_t)vzip2q_s8(v116, v117);
              int32x4_t v120 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v119, 0x20uLL), v119);
              int8x16_t v39 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v120.i8, 1);
              int32x4_t v121 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v118, 0x20uLL), v118);
              int8x16_t v40 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v121.i8, 1), v121);
              int8x16_t v38 = (int8x16_t)vaddq_s32((int32x4_t)v39, vaddq_s32(v120, vdupq_lane_s32(*(int32x2_t *)v48.i8, 0)));
              v48.i32[0] = v38.i32[3] + v40.i32[3];
              unint64_t v96 = v47 + 8;
              unint64_t v122 = v47 + 16;
              v47 += 8;
            }
            while (v122 <= v31);
          }
          else
          {
            unint64_t v96 = v47;
          }
          if (v96 <= v31) {
            unint64_t v123 = v31;
          }
          else {
            unint64_t v123 = v96;
          }
          if (v123 + 32 <= v32)
          {
            unint64_t v125 = v282 + v35;
            uint64_t v126 = v285 + v35;
            unint64_t v127 = v281 + v37;
            uint64_t v128 = v284 + v37;
            unint64_t v129 = v280 + v44;
            uint64_t v130 = v283 + v44;
            unint64_t v131 = a12;
            do
            {
              int32x2_t v322 = *(int32x2_t *)v50.i8;
              int32x2_t v325 = *(int32x2_t *)v49.i8;
              int32x2_t v329 = *(int32x2_t *)v48.i8;
              int8x16_t v133 = *(int8x16_t *)(v126 + v123);
              int8x16_t v132 = *(int8x16_t *)(v126 + v123 + 16);
              int8x16_t v134 = v51[226];
              v333.val[1] = *(int8x16_t *)(v35 + v123);
              v336.val[1] = *(int8x16_t *)(v35 + v123 + 16);
              v340.val[0] = vqtbl1q_s8(v133, v134);
              v333.val[0] = *(int8x16_t *)(v125 + v123);
              v336.val[0] = *(int8x16_t *)(v125 + v123 + 16);
              int8x16_t v135 = v52[219];
              v340.val[1] = vqtbl2q_s8(v333, v135);
              int8x16_t v136 = v53[225];
              int8x16_t v137 = v54[215];
              v319.val[0] = vqtbl1q_s8(v133, v136);
              v319.val[1] = vqtbl2q_s8(v333, v137);
              v317.val[0] = vqtbl1q_s8(v132, v134);
              v317.val[1] = vqtbl2q_s8(v336, v135);
              v315.val[0] = vqtbl1q_s8(v132, v136);
              v315.val[1] = vqtbl2q_s8(v336, v137);
              int8x16_t v138 = v55[223];
              int8x16_t v139 = v56[213];
              v313.val[0] = vqtbl1q_s8(v132, v138);
              v313.val[1] = vqtbl2q_s8(v336, v139);
              v311.val[0] = vqtbl1q_s8(v132, (int8x16_t)xmmword_228F61E00);
              v311.val[1] = vqtbl2q_s8(v336, (int8x16_t)xmmword_228F61D90);
              v309.val[0] = vqtbl1q_s8(v133, v138);
              v309.val[1] = vqtbl2q_s8(v333, v139);
              v307.val[0] = vqtbl1q_s8(v133, (int8x16_t)xmmword_228F61E00);
              v307.val[1] = vqtbl2q_s8(v333, (int8x16_t)xmmword_228F61D90);
              v331.val[1] = *(int8x16_t *)(v37 + v123);
              v333.val[1] = *(int8x16_t *)(v37 + v123 + 16);
              v331.val[0] = *(int8x16_t *)(v127 + v123);
              v333.val[0] = *(int8x16_t *)(v127 + v123 + 16);
              v336.val[1] = *(int8x16_t *)(v128 + v123);
              v336.val[0] = *(int8x16_t *)(v128 + v123 + 16);
              v305.val[0] = vqtbl1q_s8(v336.val[0], v134);
              v305.val[1] = vqtbl2q_s8(v333, v135);
              v302.val[0] = vqtbl1q_s8(v336.val[0], v136);
              v302.val[1] = vqtbl2q_s8(v333, v137);
              v299.val[0] = vqtbl1q_s8(v336.val[0], v138);
              v299.val[1] = vqtbl2q_s8(v333, v139);
              v343.val[0] = vqtbl1q_s8(v336.val[0], (int8x16_t)xmmword_228F61E00);
              v343.val[1] = vqtbl2q_s8(v333, (int8x16_t)xmmword_228F61D90);
              v296.val[0] = vqtbl1q_s8(v336.val[1], v134);
              v296.val[1] = vqtbl2q_s8(v331, v135);
              v294.val[0] = vqtbl1q_s8(v336.val[1], v136);
              v294.val[1] = vqtbl2q_s8(v331, v137);
              v341.val[0] = vqtbl1q_s8(v336.val[1], v138);
              v341.val[1] = vqtbl2q_s8(v331, v139);
              v292.val[0] = vqtbl1q_s8(v336.val[1], (int8x16_t)xmmword_228F61E00);
              v292.val[1] = vqtbl2q_s8(v331, (int8x16_t)xmmword_228F61D90);
              v333.val[0] = *(int8x16_t *)(v44 + v123);
              v331.val[1] = *(int8x16_t *)(v44 + v123 + 16);
              long long v140 = *(_OWORD *)(v129 + v123);
              v331.val[0] = *(int8x16_t *)(v129 + v123 + 16);
              int8x16_t v141 = *(int8x16_t *)(v130 + v123);
              v333.val[1] = *(int8x16_t *)(v130 + v123 + 16);
              int8x16_t v289 = vqtbl1q_s8(v333.val[1], v134);
              int8x16_t v290 = vqtbl2q_s8(v331, v135);
              v288.val[0] = vqtbl1q_s8(v333.val[1], v136);
              v288.val[1] = vqtbl2q_s8(v331, v137);
              v353.val[0] = vqtbl1q_s8(v333.val[1], v138);
              v353.val[1] = vqtbl2q_s8(v331, v139);
              v354.val[0] = vqtbl1q_s8(v333.val[1], (int8x16_t)xmmword_228F61E00);
              v354.val[1] = vqtbl2q_s8(v331, (int8x16_t)xmmword_228F61D90);
              v338.val[0] = vqtbl1q_s8(v141, v134);
              v338.val[1] = vqtbl2q_s8(v333, v135);
              v351.val[0] = vqtbl1q_s8(v141, v136);
              v351.val[1] = vqtbl2q_s8(v333, v137);
              v348.val[0] = vqtbl1q_s8(v141, v138);
              v348.val[1] = vqtbl2q_s8(v333, v139);
              v347.val[0] = vqtbl1q_s8(v141, (int8x16_t)xmmword_228F61E00);
              v347.val[1] = vqtbl2q_s8(v333, (int8x16_t)xmmword_228F61D90);
              v333.val[0] = vqtbl2q_s8(v307, (int8x16_t)xmmword_228F61DC0);
              v333.val[1] = vqtbl2q_s8(v309, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v142 = (int32x4_t)vqtbl2q_s8(v311, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v143 = (int32x4_t)vqtbl2q_s8(v313, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v144 = (int32x4_t)vqtbl2q_s8(v315, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v145 = (int32x4_t)vqtbl2q_s8(v317, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v146 = (int32x4_t)vqtbl2q_s8(v319, (int8x16_t)xmmword_228F61DC0);
              v331.val[0] = vqtbl2q_s8(v340, (int8x16_t)xmmword_228F61DC0);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v333.val[0], 0x20uLL), (int32x4_t)v333.val[0]);
              v333.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v333.val[1], 0x20uLL), (int32x4_t)v333.val[1]);
              v333.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v142, 0x20uLL), v142);
              int32x4_t v147 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v143, 0x20uLL), v143);
              int32x4_t v148 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v144, 0x20uLL), v144);
              int32x4_t v149 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v145, 0x20uLL), v145);
              v331.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v331.val[0], 0x20uLL), (int32x4_t)v331.val[0]);
              v331.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v331.val[1].i8, 1);
              v336.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v146, 0x20uLL), v146);
              v331.val[0].i64[0] = 0;
              v340.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v331.val[0], (int32x4_t)v331.val[1]);
              v331.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v149.i8, 1);
              v331.val[1].i64[0] = 0;
              int32x4_t v150 = vdupq_lane_s32(*(int32x2_t *)v336.val[1].i8, 1);
              v150.i64[0] = 0;
              v336.val[1] = (int8x16_t)vaddq_s32(v150, (int32x4_t)v336.val[1]);
              v331.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v331.val[1], v149);
              int32x4_t v151 = vdupq_lane_s32(*(int32x2_t *)v148.i8, 1);
              v151.i64[0] = 0;
              int32x4_t v152 = vaddq_s32(v151, v148);
              int32x4_t v153 = vdupq_lane_s32(*(int32x2_t *)v147.i8, 1);
              v153.i64[0] = 0;
              int32x4_t v154 = vaddq_s32(v153, v147);
              int32x4_t v155 = vdupq_lane_s32(*(int32x2_t *)v333.val[1].i8, 1);
              v155.i64[0] = 0;
              int32x4_t v156 = vdupq_lane_s32(*(int32x2_t *)v333.val[0].i8, 1);
              int32x4_t v157 = vaddq_s32(v155, (int32x4_t)v333.val[1]);
              v156.i64[0] = 0;
              v333.val[1] = (int8x16_t)vaddq_s32(v156, (int32x4_t)v333.val[0]);
              int32x4_t v158 = vdupq_lane_s32(*(int32x2_t *)v336.val[0].i8, 1);
              v158.i64[0] = 0;
              v336.val[0] = (int8x16_t)vaddq_s32(v158, (int32x4_t)v336.val[0]);
              int32x4_t v159 = (int32x4_t)vqtbl2q_s8(v292, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v160 = (int32x4_t)vqtbl2q_s8(v341, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v161 = (int32x4_t)vqtbl2q_s8(v343, (int8x16_t)xmmword_228F61DC0);
              v333.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v157, 3), (int32x4_t)v331.val[1]);
              v341.val[0] = vqtbl2q_s8(v299, (int8x16_t)xmmword_228F61DC0);
              v341.val[1] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61DC0);
              v343.val[0] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F61DC0);
              v343.val[1] = vqtbl2q_s8(v294, (int8x16_t)xmmword_228F61DC0);
              v331.val[0] = vqtbl2q_s8(v296, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v162 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v159, 0x20uLL), v159);
              int32x4_t v163 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v160, 0x20uLL), v160);
              int32x4_t v164 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v161, 0x20uLL), v161);
              v340.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v341.val[0], 0x20uLL), (int32x4_t)v341.val[0]);
              v341.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v341.val[1], 0x20uLL), (int32x4_t)v341.val[1]);
              v341.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v343.val[0], 0x20uLL), (int32x4_t)v343.val[0]);
              v343.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v343.val[1], 0x20uLL), (int32x4_t)v343.val[1]);
              v331.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v331.val[0], 0x20uLL), (int32x4_t)v331.val[0]);
              v343.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v331.val[1].i8, 1);
              v343.val[1].i64[0] = 0;
              v331.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v343.val[0].i8, 1);
              v331.val[0].i64[0] = 0;
              v331.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v331.val[0], (int32x4_t)v343.val[0]);
              int32x4_t v165 = vdupq_lane_s32(*(int32x2_t *)v341.val[1].i8, 1);
              v165.i64[0] = 0;
              int32x4_t v166 = vaddq_s32(v165, (int32x4_t)v341.val[1]);
              v340.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v336.val[0], 3), (int32x4_t)v340.val[0]);
              v341.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v341.val[0].i8, 1);
              v341.val[1].i64[0] = 0;
              v343.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v340.val[1].i8, 1);
              v341.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v341.val[1], (int32x4_t)v341.val[0]);
              v343.val[0].i64[0] = 0;
              v340.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v343.val[0], (int32x4_t)v340.val[1]);
              v341.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v163.i8, 1);
              v341.val[1].i64[0] = 0;
              v343.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v164.i8, 1);
              v343.val[0].i64[0] = 0;
              v343.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v343.val[0], v164);
              int32x4_t v167 = vaddq_s32((int32x4_t)v341.val[1], v163);
              int32x4_t v168 = vdupq_laneq_s32((int32x4_t)v333.val[0], 3);
              v341.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(v154, 3), v152), v168);
              int32x4_t v169 = vaddq_s32(v154, v168);
              int32x4_t v170 = vdupq_lane_s32(*(int32x2_t *)v162.i8, 1);
              v170.i64[0] = 0;
              int32x4_t v171 = vaddq_s32(v170, v162);
              int32x4_t v172 = vaddq_s32(vdupq_laneq_s32((int32x4_t)v343.val[0], 3), v166);
              int32x4_t v173 = vdupq_laneq_s32((int32x4_t)v340.val[0], 3);
              v343.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v171, 3), vaddq_s32((int32x4_t)v343.val[1], (int32x4_t)v331.val[1]));
              v336.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v333.val[1], 3), (int32x4_t)v336.val[1]), v173);
              v331.val[1] = (int8x16_t)vdupq_lane_s32(v322, 0);
              int32x4_t v174 = vaddq_s32(vaddq_s32((int32x4_t)v333.val[1], (int32x4_t)v331.val[1]), v173);
              v333.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61DC0);
              v347.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61DC0);
              v348.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61DC0);
              v348.val[1] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v175 = vaddq_s32(v157, (int32x4_t)v331.val[1]);
              v333.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v333.val[0], (int32x4_t)v331.val[1]);
              v347.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v340.val[0], (int32x4_t)v331.val[1]);
              int32x4_t v176 = vaddq_s32((int32x4_t)v336.val[0], (int32x4_t)v331.val[1]);
              v336.val[0] = vqtbl2q_s8(v288, (int8x16_t)xmmword_228F61DC0);
              v353.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v343.val[1], 3);
              v331.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(v167, 3), (int32x4_t)v331.val[0]), (int32x4_t)v353.val[0]);
              v353.val[1] = v289;
              v354.val[0] = v290;
              v354.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v353 + 16), (int8x16_t)xmmword_228F61DC0);
              v354.val[0] = (int8x16_t)vdupq_laneq_s32(v172, 3);
              v340.val[0] = (int8x16_t)vdupq_lane_s32(v325, 0);
              v341.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v340.val[1], 3), (int32x4_t)v341.val[0]), (int32x4_t)v354.val[0]);
              v343.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v343.val[0], (int32x4_t)v340.val[0]);
              int32x4_t v177 = vaddq_s32(v172, (int32x4_t)v340.val[0]);
              v353.val[1] = (int8x16_t)vaddq_s32(v171, (int32x4_t)v340.val[0]);
              int32x4_t v178 = (int32x4_t)vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61DC0);
              v351.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v340.val[1], (int32x4_t)v354.val[0]);
              int32x4_t v179 = (int32x4_t)vqtbl2q_s8(v338, (int8x16_t)xmmword_228F61DC0);
              v354.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(v167, (int32x4_t)v340.val[0]), (int32x4_t)v353.val[0]);
              v333.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v333.val[1], 0x20uLL), (int32x4_t)v333.val[1]);
              int32x4_t v180 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v347.val[1], 0x20uLL), (int32x4_t)v347.val[1]);
              v347.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v343.val[1], (int32x4_t)v340.val[0]);
              v348.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[0], 0x20uLL), (int32x4_t)v348.val[0]);
              v348.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[1], 0x20uLL), (int32x4_t)v348.val[1]);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v336.val[0], 0x20uLL), (int32x4_t)v336.val[0]);
              int32x4_t v181 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v178, 0x20uLL), v178);
              v353.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v341.val[1], (int32x4_t)v331.val[1]);
              int32x4_t v182 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v179, 0x20uLL), v179);
              v351.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v182.i8, 1);
              v338.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v181.i8, 1);
              int32x4_t v183 = vaddq_s32(v169, (int32x4_t)v331.val[1]);
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v354.val[1], 0x20uLL), (int32x4_t)v354.val[1]);
              v338.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v354.val[1].i8, 1);
              v340.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v336.val[0].i8, 1);
              v341.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v336.val[1], (int32x4_t)v331.val[1]);
              v343.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v348.val[1].i8, 1);
              v351.val[1].i64[0] = 0;
              v336.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v336.val[1], 3);
              v351.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[1], v182);
              int32x4_t v184 = vdupq_lane_s32(*(int32x2_t *)v348.val[0].i8, 1);
              v338.val[0].i64[0] = 0;
              v341.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v341.val[0], (int32x4_t)v340.val[0]);
              v338.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v338.val[0], v181);
              v331.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v180.i8, 1);
              v338.val[1].i64[0] = 0;
              v351.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[0], (int32x4_t)v340.val[0]);
              v338.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v338.val[1], (int32x4_t)v354.val[1]);
              v354.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v333.val[1].i8, 1);
              v354.val[1].i64[0] = 0;
              int32x4_t v185 = vaddq_s32((int32x4_t)v331.val[0], (int32x4_t)v340.val[0]);
              v331.val[1].i64[0] = 0;
              v184.i64[0] = 0;
              v331.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v331.val[0], 3);
              int32x4_t v326 = vaddq_s32((int32x4_t)v353.val[0], (int32x4_t)v336.val[1]);
              v343.val[1].i64[0] = 0;
              v340.val[1].i64[0] = 0;
              v340.val[0] = (int8x16_t)vaddq_s32(v175, (int32x4_t)v336.val[1]);
              int32x4_t v186 = vaddq_s32((int32x4_t)v333.val[0], (int32x4_t)v336.val[1]);
              v333.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v340.val[1], (int32x4_t)v336.val[0]);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v343.val[1], (int32x4_t)v348.val[1]);
              v348.val[0] = (int8x16_t)vaddq_s32(v184, (int32x4_t)v348.val[0]);
              v331.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v331.val[1], v180);
              v340.val[1] = (int8x16_t)vaddq_s32(v183, (int32x4_t)v336.val[1]);
              v336.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[1], (int32x4_t)v333.val[1]);
              int8x16_t v40 = (int8x16_t)vaddq_s32((int32x4_t)v341.val[0], (int32x4_t)v331.val[0]);
              int8x16_t v41 = (int8x16_t)vaddq_s32((int32x4_t)v343.val[0], (int32x4_t)v331.val[0]);
              v353.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v348.val[0], 3), (int32x4_t)v338.val[1]);
              v351.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v336.val[1], 3), (int32x4_t)v351.val[1]);
              v354.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v351.val[1], 3);
              int32x4_t v50 = vaddq_s32(v177, (int32x4_t)v331.val[0]);
              int32x4_t v187 = vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v331.val[1], 3), (int32x4_t)v338.val[0]), (int32x4_t)v354.val[1]);
              int32x4_t v188 = vdupq_laneq_s32((int32x4_t)v353.val[0], 3);
              v333.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v336.val[0], 3), (int32x4_t)v333.val[0]), v188);
              int32x4_t v189 = vaddq_s32((int32x4_t)v336.val[0], v188);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[0], (int32x4_t)v331.val[0]);
              v331.val[0] = (int8x16_t)vdupq_laneq_s32(v187, 3);
              v351.val[0] = (int8x16_t)vdupq_lane_s32(v329, 0);
              v333.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v333.val[0], (int32x4_t)v351.val[0]), (int32x4_t)v331.val[0]);
              v348.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v348.val[0], (int32x4_t)v351.val[0]), (int32x4_t)v331.val[0]);
              int32x4_t v190 = vaddq_s32(v189, (int32x4_t)v351.val[0]);
              int32x4_t v191 = vaddq_s32(v187, (int32x4_t)v351.val[0]);
              v338.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v353.val[0], (int32x4_t)v351.val[0]), (int32x4_t)v331.val[0]);
              v331.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v331.val[1], (int32x4_t)v351.val[0]), (int32x4_t)v354.val[1]);
              v351.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[1], (int32x4_t)v351.val[0]);
              v351.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v336.val[1], (int32x4_t)v351.val[0]);
              v354.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v341.val[1], v191);
              v338.val[1] = (int8x16_t)vaddq_s32(v190, (int32x4_t)v331.val[0]);
              v348.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v341.val[1], v191);
              int32x4_t v192 = vzip1q_s32((int32x4_t)v340.val[1], (int32x4_t)v338.val[1]);
              int32x4_t v193 = vzip1q_s32((int32x4_t)v347.val[0], (int32x4_t)v351.val[1]);
              v336.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v347.val[0], (int32x4_t)v351.val[1]);
              v341.val[0] = (int8x16_t)vzip1q_s32(v174, (int32x4_t)v331.val[1]);
              v331.val[0] = (int8x16_t)vzip1q_s32(v186, (int32x4_t)v338.val[0]);
              v347.val[0] = (int8x16_t)vzip2q_s32(v174, (int32x4_t)v331.val[1]);
              v353.val[0] = (int8x16_t)vzip1q_s32(v176, (int32x4_t)v351.val[0]);
              v351.val[1] = (int8x16_t)vzip2q_s32(v176, (int32x4_t)v351.val[0]);
              v331.val[1] = (int8x16_t)vuzp1q_s32(v287, v185);
              v351.val[0] = (int8x16_t)vuzp2q_s32(v287, v185);
              int32x4_t v194 = vzip2q_s32((int32x4_t)v340.val[1], (int32x4_t)v338.val[1]);
              v338.val[1] = (int8x16_t)vuzp1q_s32(v287, (int32x4_t)v347.val[1]);
              v340.val[1] = (int8x16_t)vuzp2q_s32(v287, (int32x4_t)v347.val[1]);
              v341.val[1] = v347.val[1];
              v341.val[1].i32[0] = v287.i32[2];
              int32x4_t v48 = vzip2q_s32(v186, (int32x4_t)v338.val[0]);
              int32x4_t v195 = vuzp1q_s32(v287, (int32x4_t)v354.val[0]);
              int32x4_t v196 = vuzp2q_s32(v287, (int32x4_t)v354.val[0]);
              v338.val[0] = (int8x16_t)vuzp1q_s32(v287, (int32x4_t)v353.val[1]);
              v343.val[0] = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v351.val[0], (int32x4_t)v351.val[0]), (int32x4_t)v354.val[1]);
              v331.val[1] = (int8x16_t)vzip1q_s32(vuzp1q_s32((int32x4_t)v331.val[1], (int32x4_t)v331.val[1]), (int32x4_t)v354.val[1]);
              v354.val[1] = (int8x16_t)vzip2q_s32(vuzp1q_s32(v196, v196), (int32x4_t)v341.val[0]);
              int32x4_t v197 = vzip1q_s32(vuzp1q_s32(v195, v195), (int32x4_t)v341.val[0]);
              v341.val[0] = (int8x16_t)vtrn2q_s32((int32x4_t)v340.val[1], v287);
              v340.val[1] = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v340.val[1], (int32x4_t)v340.val[1]), v193);
              int32x4_t v198 = vzip1q_s32(vuzp1q_s32((int32x4_t)v338.val[1], (int32x4_t)v338.val[1]), v193);
              v338.val[1] = (int8x16_t)vuzp2q_s32(v287, (int32x4_t)v353.val[1]);
              v341.val[0] = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v341.val[0], (int32x4_t)v341.val[0]), (int32x4_t)v336.val[1]);
              v336.val[1] = (int8x16_t)vzip1q_s32(vuzp1q_s32((int32x4_t)v341.val[1], (int32x4_t)v341.val[1]), (int32x4_t)v336.val[1]);
              v341.val[1] = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v338.val[1], (int32x4_t)v338.val[1]), (int32x4_t)v353.val[0]);
              v353.val[0] = (int8x16_t)vzip1q_s32(vuzp1q_s32((int32x4_t)v338.val[0], (int32x4_t)v338.val[0]), (int32x4_t)v353.val[0]);
              v353.val[1].i32[0] = v287.i32[2];
              v338.val[0] = (int8x16_t)vtrn2q_s32((int32x4_t)v338.val[1], v287);
              *(int8x16_t *)unint64_t v131 = v353.val[0];
              *(int8x16_t *)(v131 + 16) = v341.val[1];
              v353.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v340.val[0], (int32x4_t)v348.val[1]);
              v348.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v340.val[0], (int32x4_t)v348.val[1]);
              *(int32x4_t *)(v131 + 32) = vzip1q_s32(vuzp1q_s32((int32x4_t)v353.val[1], (int32x4_t)v353.val[1]), (int32x4_t)v351.val[1]);
              *(int32x4_t *)(v131 + 48) = vzip2q_s32(vuzp1q_s32((int32x4_t)v338.val[0], (int32x4_t)v338.val[0]), (int32x4_t)v351.val[1]);
              v351.val[1] = (int8x16_t)vzip1q_s32(v326, (int32x4_t)v333.val[0]);
              *(int32x4_t *)(v131 + 64) = v198;
              *(int8x16_t *)(v131 + 80) = v340.val[1];
              int32x4_t v199 = vuzp1q_s32(v287, (int32x4_t)v40);
              v185.i32[0] = v287.i32[2];
              v351.val[0] = (int8x16_t)vtrn2q_s32((int32x4_t)v351.val[0], v287);
              v353.val[1] = (int8x16_t)vuzp2q_s32(v287, (int32x4_t)v40);
              *(int8x16_t *)(v131 + 96) = v336.val[1];
              *(int8x16_t *)(v131 + 112) = v341.val[0];
              v336.val[1] = (int8x16_t)vuzp1q_s32(v287, (int32x4_t)v336.val[0]);
              v351.val[0] = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v351.val[0], (int32x4_t)v351.val[0]), (int32x4_t)v348.val[0]);
              int32x4_t v200 = vzip1q_s32(vuzp1q_s32(v185, v185), (int32x4_t)v348.val[0]);
              v348.val[0] = (int8x16_t)vuzp1q_s32(v287, (int32x4_t)v41);
              v338.val[0] = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v353.val[1], (int32x4_t)v353.val[1]), (int32x4_t)v351.val[1]);
              int32x4_t v201 = vzip1q_s32(vuzp1q_s32(v199, v199), (int32x4_t)v351.val[1]);
              v351.val[1] = (int8x16_t)vuzp2q_s32(v287, (int32x4_t)v41);
              *(int8x16_t *)(v131 + 192) = v331.val[1];
              *(int8x16_t *)(v131 + 208) = v343.val[0];
              v331.val[1] = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v351.val[1], (int32x4_t)v351.val[1]), (int32x4_t)v353.val[0]);
              v348.val[0] = (int8x16_t)vzip1q_s32(vuzp1q_s32((int32x4_t)v348.val[0], (int32x4_t)v348.val[0]), (int32x4_t)v353.val[0]);
              v353.val[0] = (int8x16_t)vuzp2q_s32(v287, (int32x4_t)v336.val[0]);
              *(int32x4_t *)(v131 + 128) = v197;
              *(int8x16_t *)(v131 + 144) = v354.val[1];
              v354.val[0].i32[0] = v287.i32[2];
              int32x4_t v202 = vtrn2q_s32(v196, v287);
              *(int32x4_t *)(v131 + 224) = v200;
              *(int8x16_t *)(v131 + 240) = v351.val[0];
              *(int32x4_t *)(v131 + 160) = vzip1q_s32(vuzp1q_s32((int32x4_t)v354.val[0], (int32x4_t)v354.val[0]), (int32x4_t)v347.val[0]);
              *(int32x4_t *)(v131 + 176) = vzip2q_s32(vuzp1q_s32(v202, v202), (int32x4_t)v347.val[0]);
              int32x4_t v203 = (int32x4_t)v40;
              v203.i32[0] = v287.i32[2];
              *(int32x4_t *)(v131 + 448) = v201;
              *(int8x16_t *)(v131 + 464) = v338.val[0];
              int32x4_t v204 = vzip2q_s32(v326, (int32x4_t)v333.val[0]);
              int32x4_t v205 = vtrn2q_s32((int32x4_t)v353.val[1], v287);
              int32x4_t v206 = vzip2q_s32(vuzp1q_s32(v205, v205), v204);
              int32x4_t v49 = vzip1q_s32(vuzp1q_s32(v203, v203), v204);
              int32x4_t v207 = vuzp1q_s32(v287, v50);
              *(int32x4_t *)(v131 + 384) = vzip1q_s32(vuzp1q_s32((int32x4_t)v336.val[1], (int32x4_t)v336.val[1]), v192);
              *(int32x4_t *)(v131 + 400) = vzip2q_s32(vuzp1q_s32((int32x4_t)v353.val[0], (int32x4_t)v353.val[0]), v192);
              v336.val[1] = (int8x16_t)vuzp2q_s32(v287, v50);
              int8x16_t v43 = (int8x16_t)vuzp1q_s32(v207, v207);
              *(int32x4_t *)(v131 + 320) = vzip1q_s32((int32x4_t)v43, (int32x4_t)v331.val[0]);
              *(int32x4_t *)(v131 + 336) = vzip2q_s32(vuzp1q_s32((int32x4_t)v336.val[1], (int32x4_t)v336.val[1]), (int32x4_t)v331.val[0]);
              v50.i32[0] = v287.i32[2];
              v331.val[0] = (int8x16_t)vtrn2q_s32((int32x4_t)v336.val[1], v287);
              int8x16_t v42 = (int8x16_t)vzip1q_s32(vuzp1q_s32(v50, v50), v48);
              *(int8x16_t *)(v131 + 256) = v348.val[0];
              *(int8x16_t *)(v131 + 272) = v331.val[1];
              *(int32x4_t *)(v131 + 480) = v49;
              *(int32x4_t *)(v131 + 496) = v206;
              v336.val[0].i32[0] = v287.i32[2];
              v331.val[1] = (int8x16_t)vtrn2q_s32((int32x4_t)v353.val[0], v287);
              *(int32x4_t *)(v131 + 416) = vzip1q_s32(vuzp1q_s32((int32x4_t)v336.val[0], (int32x4_t)v336.val[0]), v194);
              *(int32x4_t *)(v131 + 432) = vzip2q_s32(vuzp1q_s32((int32x4_t)v331.val[1], (int32x4_t)v331.val[1]), v194);
              *(int8x16_t *)(v131 + 352) = v42;
              *(int32x4_t *)(v131 + 368) = vzip2q_s32(vuzp1q_s32((int32x4_t)v331.val[0], (int32x4_t)v331.val[0]), v48);
              v41.i32[0] = v287.i32[2];
              v331.val[0] = (int8x16_t)vtrn2q_s32((int32x4_t)v351.val[1], v287);
              int8x16_t v38 = (int8x16_t)vzip2q_s32(vuzp1q_s32((int32x4_t)v331.val[0], (int32x4_t)v331.val[0]), (int32x4_t)v348.val[1]);
              int8x16_t v39 = (int8x16_t)vzip1q_s32(vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), (int32x4_t)v348.val[1]);
              *(int8x16_t *)(v131 + 288) = v39;
              *(int8x16_t *)(v131 + 304) = v38;
              v49.i32[0] = v40.i32[3];
              result = v131 + 512;
              unint64_t v124 = v123 + 32;
              unint64_t v208 = v123 + 64;
              v123 += 32;
              v50.i32[0] = v326.i32[3];
              v131 += 512;
              v48.i32[0] = v333.val[0].i32[3];
            }
            while (v208 <= v32);
          }
          else
          {
            unint64_t v124 = v123;
            result = a12;
          }
          if (v124 + 8 <= v32)
          {
            do
            {
              v38.i64[0] = *(void *)(v35 + v124);
              v39.i64[0] = *(void *)(v285 + v35 + v124);
              v40.i64[0] = *(void *)(v282 + v35 + v124);
              int8x16_t v211 = vzip1q_s8((int8x16_t)0, v39);
              int8x16_t v212 = vzip1q_s8(v40, v38);
              int32x4_t v213 = (int32x4_t)vzip1q_s8(v211, v212);
              int32x4_t v214 = (int32x4_t)vzip2q_s8(v211, v212);
              int8x16_t v215 = (int8x16_t)vshlq_n_s64((int64x2_t)v214, 0x20uLL);
              int32x4_t v216 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v213, 0x20uLL), v213);
              int32x4_t v217 = vdupq_lane_s32(*(int32x2_t *)v50.i8, 0);
              int32x4_t v218 = vaddq_s32((int32x4_t)v215, v214);
              v215.i64[0] = *(void *)(v37 + v124);
              v41.i64[0] = *(void *)(v284 + v37 + v124);
              int8x16_t v219 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v218.i8, 1);
              v42.i64[0] = *(void *)(v281 + v37 + v124);
              int8x16_t v220 = vzip1q_s8((int8x16_t)0, v41);
              int8x16_t v221 = vzip1q_s8(v42, v215);
              int8x16_t v222 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v216.i8, 1);
              int32x4_t v223 = (int32x4_t)vzip1q_s8(v220, v221);
              int32x4_t v224 = (int32x4_t)vzip2q_s8(v220, v221);
              v222.i64[0] = 0;
              int32x4_t v225 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v223, 0x20uLL), v223);
              int32x4_t v226 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v224, 0x20uLL), v224);
              int32x4_t v227 = vdupq_lane_s32(*(int32x2_t *)v226.i8, 1);
              v219.i64[0] = 0;
              int32x4_t v228 = vdupq_lane_s32(*(int32x2_t *)v225.i8, 1);
              v228.i64[0] = 0;
              v227.i64[0] = 0;
              int32x4_t v229 = vdupq_lane_s32(*(int32x2_t *)v49.i8, 0);
              v43.i64[0] = *(void *)(v44 + v124);
              int32x4_t v230 = vaddq_s32((int32x4_t)v222, v216);
              int32x4_t v231 = vaddq_s32((int32x4_t)v219, vaddq_s32(v218, v217));
              v219.i64[0] = *(void *)(v283 + v44 + v124);
              v222.i64[0] = *(void *)(v280 + v44 + v124);
              int32x4_t v232 = vaddq_s32(v228, v225);
              int8x16_t v233 = vzip1q_s8((int8x16_t)0, v219);
              int8x16_t v234 = vzip1q_s8(v222, v43);
              int32x4_t v235 = (int32x4_t)vzip1q_s8(v233, v234);
              int8x16_t v43 = (int8x16_t)vdupq_laneq_s32(v230, 3);
              int32x4_t v236 = (int32x4_t)vzip2q_s8(v233, v234);
              int32x4_t v237 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v235, 0x20uLL), v235);
              int32x4_t v238 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v236, 0x20uLL), v236);
              int32x4_t v239 = vaddq_s32(v230, v217);
              int32x4_t v240 = vdupq_lane_s32(*(int32x2_t *)v238.i8, 1);
              int32x4_t v241 = vdupq_lane_s32(*(int32x2_t *)v237.i8, 1);
              int32x4_t v242 = vdupq_laneq_s32(v232, 3);
              int32x4_t v243 = vaddq_s32(v227, vaddq_s32(v226, v229));
              v241.i64[0] = 0;
              v240.i64[0] = 0;
              int32x4_t v244 = vaddq_s32(v232, v229);
              int32x4_t v245 = vaddq_s32(v241, v237);
              int32x4_t v50 = vdupq_laneq_s32(v245, 3);
              int32x4_t v246 = vdupq_lane_s32(*(int32x2_t *)v48.i8, 0);
              int8x16_t v38 = (int8x16_t)vaddq_s32(v231, (int32x4_t)v43);
              int8x16_t v42 = (int8x16_t)vaddq_s32(v245, v246);
              int32x4_t v247 = vaddq_s32(v240, vaddq_s32(v238, v246));
              int32x4_t v248 = vzip2q_s32(v287, v244);
              v335.val[0] = (float32x4_t)vzip1q_s32(v287, v244);
              int32x4_t v249 = vaddq_s32(v243, v242);
              v335.val[1] = (float32x4_t)vzip1q_s32(v239, (int32x4_t)v42);
              unint64_t v210 = result + 128;
              int8x16_t v250 = (float *)(result + 64);
              int8x16_t v251 = (float *)(result + 96);
              int32x4_t v252 = vaddq_s32(v247, v50);
              vst2q_f32((float *)result, v335);
              int8x16_t v253 = (float *)(result + 32);
              v50.i32[0] = v38.i32[3];
              int32x4_t v49 = vzip2q_s32(v239, (int32x4_t)v42);
              vst2q_f32(v253, *(float32x4x2_t *)(&v49 - 1));
              v49.i32[0] = v249.i32[3];
              int8x16_t v41 = (int8x16_t)vzip1q_s32(v287, v249);
              v335.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v38, v252);
              vst2q_f32(v250, *(float32x4x2_t *)v41.i8);
              int8x16_t v39 = (int8x16_t)vzip2q_s32(v287, v249);
              int8x16_t v40 = (int8x16_t)vzip2q_s32((int32x4_t)v38, v252);
              vst2q_f32(v251, *(float32x4x2_t *)v39.i8);
              v48.i32[0] = v252.i32[3];
              unint64_t v209 = v124 + 8;
              unint64_t v254 = v124 + 16;
              v124 += 8;
              result = v210;
            }
            while (v254 <= v32);
          }
          else
          {
            unint64_t v209 = v124;
            unint64_t v210 = result;
          }
          if (v209 < v32)
          {
            uint64_t v255 = 0;
            unint64_t v256 = v282 + v209 + v35;
            unint64_t v257 = v285 + v209 + v35;
            unint64_t v258 = v35 + v209;
            unint64_t v259 = v281 + v209 + v37;
            result = v284 + v209 + v37;
            unint64_t v260 = v37 + v209;
            unint64_t v261 = v280 + v209 + v44;
            unint64_t v262 = v283 + v209 + v44;
            unint64_t v263 = v44 + v209;
            unint64_t v264 = v32 - v209;
            do
            {
              LODWORD(v265) = v266.i32[0];
              DWORD1(v265) = ((*(unsigned __int8 *)(v258 + v255) << 24) | (*(unsigned __int8 *)(v257 + v255) << 16) | (*(unsigned __int8 *)(v256 + v255) << 8))
                           + v50.i32[0];
              DWORD2(v265) = ((*(unsigned __int8 *)(v260 + v255) << 24) | (*(unsigned __int8 *)(result + v255) << 16) | (*(unsigned __int8 *)(v259 + v255) << 8))
                           + v49.i32[0];
              HIDWORD(v265) = ((*(unsigned __int8 *)(v263 + v255) << 24) | (*(unsigned __int8 *)(v262 + v255) << 16) | (*(unsigned __int8 *)(v261 + v255) << 8))
                            + v48.i32[0];
              *(_OWORD *)(v210 + 16 * v255++) = v265;
            }
            while (v264 != v255);
          }
        }
        a12 += a13;
        uint64_t v29 = v286 + a11;
      }
      while (v29 + (unint64_t)a3[7].u32[0] < v278);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v279 = result;
  if (a9)
  {
    unint64_t v16 = *(void *)(a2 + 56);
    uint64_t v17 = *(ChannelDescription **)(a4 + 8);
    *(int32x2_t *)v343.val[0].i8 = a3[3];
    uint64_t v18 = a3[7].u32[1];
    int32x2_t v19 = *(int32x2_t *)((char *)v17 + 48);
    int32x2_t v20 = *(int32x2_t *)(*(void *)(*((void *)v17 + 5) + 8 * v18) + 16);
    uint64_t v277 = v343.val[0].u32[0];
    unint64_t v278 = v17;
    unsigned int v276 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v17, (a3[6].i32[1] + v343.val[0].i32[1] * HIDWORD(v16)), v343.val[0].u32[0], v18);
    uint64_t v21 = *(ChannelDescription **)(a5 + 8);
    unint64_t v22 = HIDWORD(v16);
    *(int32x2_t *)v340.val[0].i8 = a3[3];
    uint64_t v23 = a3[7].u32[1];
    int32x2_t v24 = *(int32x2_t *)((char *)v21 + 48);
    int32x2_t v25 = *(int32x2_t *)(*(void *)(*((void *)v21 + 5) + 8 * v23) + 16);
    uint64_t v274 = v340.val[0].u32[0];
    uint64_t v275 = v21;
    unsigned int v273 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v21, (a3[6].i32[1] + v340.val[0].i32[1] * HIDWORD(v16)), v340.val[0].u32[0], v23);
    uint64_t v26 = *(ChannelDescription **)(a6 + 8);
    *(int32x2_t *)v337.val[0].i8 = a3[3];
    uint64_t v27 = a3[7].u32[1];
    int32x2_t v28 = *(int32x2_t *)((char *)v26 + 48);
    int32x2_t v29 = *(int32x2_t *)(*(void *)(*((void *)v26 + 5) + 8 * v27) + 16);
    uint64_t v271 = v337.val[0].u32[0];
    uint64_t v272 = v26;
    unsigned int v270 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v26, (a3[6].i32[1] + v337.val[0].i32[1] * HIDWORD(v16)), v337.val[0].u32[0], v27);
    int32x2_t v30 = *(ChannelDescription **)(a7 + 8);
    *(int32x2_t *)v334.val[0].i8 = a3[3];
    uint64_t v31 = a3[7].u32[1];
    int32x2_t v32 = *(int32x2_t *)((char *)v30 + 48);
    int32x2_t v33 = *(int32x2_t *)(*(void *)(*((void *)v30 + 5) + 8 * v31) + 16);
    uint64_t v268 = v334.val[0].u32[0];
    uint64_t v269 = v30;
    unsigned int v267 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v30, (a3[6].i32[1] + v334.val[0].i32[1] * HIDWORD(v16)), v334.val[0].u32[0], v31);
    uint64_t v34 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v34 < HIDWORD(v16))
    {
      uint64_t v35 = vmin_u32((uint32x2_t)vmls_s32(v20, v19, *(int32x2_t *)v343.val[0].i8), (uint32x2_t)v19).u32[0];
      uint64_t v284 = 2 * v35;
      uint64_t v285 = vmin_u32((uint32x2_t)vmls_s32(v33, v32, *(int32x2_t *)v334.val[0].i8), (uint32x2_t)v32).u32[0];
      int v266 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      uint64_t v287 = vmin_u32((uint32x2_t)vmls_s32(v25, v24, *(int32x2_t *)v340.val[0].i8), (uint32x2_t)v24).u32[0];
      uint64_t v288 = v35;
      uint64_t v283 = 2 * v287;
      uint64_t v264 = 3 * v287;
      uint64_t v265 = 3 * v35;
      unint64_t v36 = a3[5].u32[1];
      uint64_t v286 = vmin_u32((uint32x2_t)vmls_s32(v29, v28, *(int32x2_t *)v337.val[0].i8), (uint32x2_t)v28).u32[0];
      uint64_t v281 = 2 * v285;
      uint64_t v282 = 2 * v286;
      uint64_t v262 = 3 * v285;
      uint64_t v263 = 3 * v286;
      unint64_t v37 = (int8x16_t *)&unk_228F61000;
      unint64_t v261 = HIDWORD(v16);
      do
      {
        uint64_t v289 = v34;
        unint64_t v38 = (v266 + v34);
        unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v278, v38, v277, v276);
        if (HIDWORD(LocationForTile)) {
          unint64_t v40 = v279 + LocationForTile;
        }
        else {
          unint64_t v40 = 0;
        }
        unint64_t v41 = ChannelDescription::GetLocationForTile(v275, v38, v274, v273);
        if (HIDWORD(v41)) {
          unint64_t v42 = v279 + v41;
        }
        else {
          unint64_t v42 = 0;
        }
        unint64_t v43 = ChannelDescription::GetLocationForTile(v272, v38, v271, v270);
        if (HIDWORD(v43)) {
          unint64_t v44 = v279 + v43;
        }
        else {
          unint64_t v44 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v269, v38, v268, v267);
        unint64_t v54 = v279 + result;
        if (!HIDWORD(result)) {
          unint64_t v54 = 0;
        }
        if (v40 && v42 && v44 && v54)
        {
          if (v36 >= 0x20)
          {
            uint64_t v61 = 0;
            unsigned int v58 = 0;
            unsigned int v57 = 0;
            unsigned int v56 = 0;
            unsigned int v55 = 0;
            unint64_t v62 = v265 + v40;
            unint64_t v63 = v284 + v40;
            uint64_t v64 = v288 + v40;
            unint64_t v65 = v264 + v42;
            result = v283 + v42;
            uint64_t v66 = v287 + v42;
            unint64_t v67 = v263 + v44;
            unint64_t v68 = v282 + v44;
            uint64_t v69 = v286 + v44;
            unint64_t v70 = v262 + v54;
            unint64_t v71 = v281 + v54;
            uint64_t v72 = v285 + v54;
            unint64_t v60 = (int8x16_t *)&unk_228F61000;
            do
            {
              v348.val[1] = *(int8x16_t *)(v40 + v61);
              v346.val[1] = *(int8x16_t *)(v40 + v61 + 16);
              v350.val[1] = *(int8x16_t *)(v64 + v61);
              v353.val[1] = *(int8x16_t *)(v64 + v61 + 16);
              v348.val[0] = *(int8x16_t *)(v63 + v61);
              v346.val[0] = *(int8x16_t *)(v63 + v61 + 16);
              v350.val[0] = *(int8x16_t *)(v62 + v61);
              v353.val[0] = *(int8x16_t *)(v62 + v61 + 16);
              v373.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D40);
              v373.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D50);
              int8x16_t v73 = v37[214];
              v358.val[0] = vqtbl2q_s8(v350, v73);
              v358.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D70);
              v360.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D80);
              v360.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D90);
              v344.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61DA0);
              v344.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61DB0);
              v341.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D80);
              v341.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D90);
              v338.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61DA0);
              v338.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DB0);
              v335.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D40);
              v335.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D50);
              v323.val[0] = vqtbl2q_s8(v353, v73);
              v323.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D70);
              v346.val[1] = *(int8x16_t *)(v42 + v61);
              v348.val[1] = *(int8x16_t *)(v42 + v61 + 16);
              v350.val[1] = *(int8x16_t *)(v66 + v61);
              v353.val[1] = *(int8x16_t *)(v66 + v61 + 16);
              v346.val[0] = *(int8x16_t *)(result + v61);
              v348.val[0] = *(int8x16_t *)(result + v61 + 16);
              v350.val[0] = *(int8x16_t *)(v65 + v61);
              v353.val[0] = *(int8x16_t *)(v65 + v61 + 16);
              v332.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D40);
              v332.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D50);
              v330.val[0] = vqtbl2q_s8(v350, v73);
              v330.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D70);
              v328.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D80);
              v328.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D90);
              v321.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61DA0);
              v321.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DB0);
              v315.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D80);
              v315.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D90);
              v313.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61DA0);
              v313.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61DB0);
              v311.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D40);
              v311.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D50);
              v309.val[0] = vqtbl2q_s8(v353, v73);
              v309.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D70);
              v346.val[1] = *(int8x16_t *)(v44 + v61);
              v348.val[1] = *(int8x16_t *)(v44 + v61 + 16);
              v346.val[0] = *(int8x16_t *)(v68 + v61);
              v348.val[0] = *(int8x16_t *)(v68 + v61 + 16);
              v350.val[1] = *(int8x16_t *)(v69 + v61);
              v353.val[1] = *(int8x16_t *)(v69 + v61 + 16);
              v350.val[0] = *(int8x16_t *)(v67 + v61);
              v353.val[0] = *(int8x16_t *)(v67 + v61 + 16);
              v307.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D40);
              v307.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D50);
              v305.val[0] = vqtbl2q_s8(v350, v73);
              v305.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D70);
              v303.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D80);
              v303.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D90);
              v301.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61DA0);
              v301.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DB0);
              v299.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D80);
              v299.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D90);
              v297.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61DA0);
              v297.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61DB0);
              v295.val[0] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D40);
              v295.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D50);
              v293.val[0] = vqtbl2q_s8(v353, v73);
              v293.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D70);
              v346.val[1] = *(int8x16_t *)(v54 + v61);
              v353.val[1] = *(int8x16_t *)(v54 + v61 + 16);
              v346.val[0] = *(int8x16_t *)(v71 + v61);
              v353.val[0] = *(int8x16_t *)(v71 + v61 + 16);
              v350.val[1] = *(int8x16_t *)(v72 + v61);
              v348.val[1] = *(int8x16_t *)(v72 + v61 + 16);
              v350.val[0] = *(int8x16_t *)(v70 + v61);
              v348.val[0] = *(int8x16_t *)(v70 + v61 + 16);
              v291.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D40);
              v291.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D50);
              v356.val[0] = vqtbl2q_s8(v350, v73);
              v356.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D70);
              v372.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61D80);
              v372.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61D90);
              v370.val[0] = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61DA0);
              v370.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DB0);
              v362.val[0] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D80);
              v362.val[1] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D90);
              v367.val[0] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61DA0);
              v367.val[1] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61DB0);
              v371.val[0] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61D40);
              v371.val[1] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D50);
              v365.val[0] = vqtbl2q_s8(v348, v73);
              v365.val[1] = vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61D70);
              v348.val[0] = vqtbl2q_s8(v323, (int8x16_t)xmmword_228F61DC0);
              v348.val[1] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61DC0);
              v353.val[0] = vqtbl2q_s8(v338, (int8x16_t)xmmword_228F61DC0);
              v353.val[1] = vqtbl2q_s8(v341, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v74 = (int32x4_t)vqtbl2q_s8(v344, (int8x16_t)xmmword_228F61DC0);
              v346.val[0] = vqtbl2q_s8(v360, (int8x16_t)xmmword_228F61DC0);
              v346.val[1] = vqtbl2q_s8(v358, (int8x16_t)xmmword_228F61DC0);
              v350.val[0] = vqtbl2q_s8(v373, (int8x16_t)xmmword_228F61DC0);
              v348.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[0], 0x20uLL), (int32x4_t)v348.val[0]);
              v348.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[1], 0x20uLL), (int32x4_t)v348.val[1]);
              v350.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[0], 0x20uLL), (int32x4_t)v353.val[0]);
              v353.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[1], 0x20uLL), (int32x4_t)v353.val[1]);
              v353.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v74, 0x20uLL), v74);
              v346.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[0], 0x20uLL), (int32x4_t)v346.val[0]);
              v346.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[1], 0x20uLL), (int32x4_t)v346.val[1]);
              v350.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v350.val[0], 0x20uLL), (int32x4_t)v350.val[0]);
              int32x4_t v75 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v350.val[0].i8, 1), (int32x4_t)v350.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v346.val[1].i8, 1), (int32x4_t)v346.val[1]));
              v373.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v346.val[0].i8, 1), (int32x4_t)v346.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v353.val[1].i8, 1), (int32x4_t)v353.val[1]));
              v350.val[0] = vqtbl2q_s8(v309, (int8x16_t)xmmword_228F61DC0);
              v353.val[1] = vqtbl2q_s8(v311, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v76 = (int32x4_t)vqtbl2q_s8(v313, (int8x16_t)xmmword_228F61DC0);
              v346.val[0] = vqtbl2q_s8(v315, (int8x16_t)xmmword_228F61DC0);
              v373.val[1] = vqtbl2q_s8(v321, (int8x16_t)xmmword_228F61DC0);
              v350.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v353.val[0].i8, 1), (int32x4_t)v353.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v350.val[1].i8, 1), (int32x4_t)v350.val[1]));
              v353.val[0] = vqtbl2q_s8(v328, (int8x16_t)xmmword_228F61DC0);
              v346.val[1] = vqtbl2q_s8(v330, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v77 = (int32x4_t)vqtbl2q_s8(v332, (int8x16_t)xmmword_228F61DC0);
              v350.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v350.val[0], 0x20uLL), (int32x4_t)v350.val[0]);
              v353.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[1], 0x20uLL), (int32x4_t)v353.val[1]);
              int32x4_t v78 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v76, 0x20uLL), v76);
              v346.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[0], 0x20uLL), (int32x4_t)v346.val[0]);
              v373.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v373.val[1], 0x20uLL), (int32x4_t)v373.val[1]);
              v353.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[0], 0x20uLL), (int32x4_t)v353.val[0]);
              v346.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[1], 0x20uLL), (int32x4_t)v346.val[1]);
              v348.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v348.val[1].i8, 1), (int32x4_t)v348.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v348.val[0].i8, 1), (int32x4_t)v348.val[0]));
              v348.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v77, 0x20uLL), v77);
              v346.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v348.val[1].i8, 1), (int32x4_t)v348.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v346.val[1].i8, 1), (int32x4_t)v346.val[1]));
              v348.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v353.val[0].i8, 1), (int32x4_t)v353.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v373.val[1].i8, 1), (int32x4_t)v373.val[1]));
              v346.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v346.val[0].i8, 1), (int32x4_t)v346.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v78.i8, 1), v78));
              v350.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v353.val[1].i8, 1), (int32x4_t)v353.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v350.val[0].i8, 1), (int32x4_t)v350.val[0]));
              v353.val[0] = vqtbl2q_s8(v293, (int8x16_t)xmmword_228F61DC0);
              v353.val[1] = vqtbl2q_s8(v295, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v79 = (int32x4_t)vqtbl2q_s8(v297, (int8x16_t)xmmword_228F61DC0);
              v373.val[1] = vqtbl2q_s8(v299, (int8x16_t)xmmword_228F61DC0);
              v360.val[0] = vqtbl2q_s8(v301, (int8x16_t)xmmword_228F61DC0);
              v348.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v348.val[0], (int32x4_t)v350.val[1]);
              v350.val[1] = vqtbl2q_s8(v303, (int8x16_t)xmmword_228F61DC0);
              v360.val[1] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v80 = (int32x4_t)vqtbl2q_s8(v307, (int8x16_t)xmmword_228F61DC0);
              v353.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[0], 0x20uLL), (int32x4_t)v353.val[0]);
              v353.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[1], 0x20uLL), (int32x4_t)v353.val[1]);
              int32x4_t v81 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v79, 0x20uLL), v79);
              v373.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v373.val[1], 0x20uLL), (int32x4_t)v373.val[1]);
              v358.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v360.val[0], 0x20uLL), (int32x4_t)v360.val[0]);
              v350.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v350.val[1], 0x20uLL), (int32x4_t)v350.val[1]);
              v358.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v360.val[1], 0x20uLL), (int32x4_t)v360.val[1]);
              v373.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v373.val[0], v75);
              int32x4_t v82 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v80, 0x20uLL), v80);
              v346.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v350.val[0], (int32x4_t)v346.val[0]);
              v350.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v353.val[1].i8, 1), (int32x4_t)v353.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v353.val[0].i8, 1), (int32x4_t)v353.val[0]));
              v353.val[0] = vqtbl2q_s8(v365, (int8x16_t)xmmword_228F61DC0);
              v353.val[1] = vqtbl2q_s8(v371, (int8x16_t)xmmword_228F61DC0);
              v365.val[0] = vqtbl2q_s8(v367, (int8x16_t)xmmword_228F61DC0);
              v362.val[0] = vqtbl2q_s8(v362, (int8x16_t)xmmword_228F61DC0);
              v346.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v348.val[1], (int32x4_t)v346.val[1]);
              v348.val[1] = vqtbl2q_s8(v370, (int8x16_t)xmmword_228F61DC0);
              v362.val[1] = vqtbl2q_s8(v372, (int8x16_t)xmmword_228F61DC0);
              v365.val[1] = vqtbl2q_s8(v356, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v83 = (int32x4_t)vqtbl2q_s8(v291, (int8x16_t)xmmword_228F61DC0);
              v350.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v350.val[0], vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v373.val[1].i8, 1), (int32x4_t)v373.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v81.i8, 1), v81)));
              v353.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[1], 0x20uLL), (int32x4_t)v353.val[1]);
              int8x16_t v52 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v365.val[0], 0x20uLL), (int32x4_t)v365.val[0]);
              v362.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v362.val[0], 0x20uLL), (int32x4_t)v362.val[0]);
              v348.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[1], 0x20uLL), (int32x4_t)v348.val[1]);
              v362.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v362.val[1], 0x20uLL), (int32x4_t)v362.val[1]);
              int32x4_t v84 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v83, 0x20uLL), v83);
              v346.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v346.val[0], (int32x4_t)v346.val[1]);
              v346.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v365.val[1], 0x20uLL), (int32x4_t)v365.val[1]);
              int8x16_t v51 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v346.val[1].i8, 1);
              int8x16_t v53 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v362.val[1].i8, 1);
              __int32 v85 = v346.val[0].i32[3];
              v346.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v353.val[0], 0x20uLL), (int32x4_t)v353.val[0]);
              int8x16_t v50 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v353.val[1].i8, 1), (int32x4_t)v353.val[1]);
              v58 += vaddq_s32(*(int32x4_t *)&v348, *(int32x4_t *)&v373).u32[3];
              __int32 v86 = vaddq_s32(*(int32x4_t *)&v350, vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)(&v350 + 16), 1), *(int32x4_t *)(&v350 + 16)), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)&v358, 1), *(int32x4_t *)&v358)), vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)&v82, 1), v82), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)(&v358 + 16), 1), *(int32x4_t *)(&v358 + 16))))).i32[3];
              int8x16_t v49 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v84.i8, 1), v84);
              int8x16_t v48 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v53, (int32x4_t)v362.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v348.val[1].i8, 1), (int32x4_t)v348.val[1]));
              int8x16_t v47 = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v362.val[0].i8, 1), (int32x4_t)v362.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v52.i8, 1), (int32x4_t)v52));
              v57 += v85;
              int8x16_t v46 = (int8x16_t)vaddq_s32((int32x4_t)v48, vaddq_s32((int32x4_t)v49, vaddq_s32((int32x4_t)v51, (int32x4_t)v346.val[1])));
              int8x16_t v45 = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v50, vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v346.val[0].i8, 1), (int32x4_t)v346.val[0])), (int32x4_t)v47), (int32x4_t)v46);
              v56 += v86;
              v55 += v45.u32[3];
              uint64_t v59 = v61 + 32;
              unint64_t v87 = v61 + 64;
              v61 += 32;
            }
            while (v87 <= v36);
          }
          else
          {
            unsigned int v55 = 0;
            unsigned int v56 = 0;
            unsigned int v57 = 0;
            unsigned int v58 = 0;
            uint64_t v59 = 0;
            unint64_t v60 = (int8x16_t *)&unk_228F61000;
          }
          if ((v59 | 8uLL) <= v36)
          {
            result = v283 + v42;
            unint64_t v89 = v36 + a9;
            do
            {
              v45.i64[0] = *(void *)(v40 + v59);
              v46.i64[0] = *(void *)(v288 + v40 + v59);
              v47.i64[0] = *(void *)(v284 + v40 + v59);
              v48.i64[0] = *(void *)(v265 + v40 + v59);
              int8x16_t v90 = vzip1q_s8(v48, v46);
              int8x16_t v91 = vzip1q_s8(v47, v45);
              int32x4_t v92 = (int32x4_t)vzip1q_s8(v90, v91);
              int32x4_t v93 = (int32x4_t)vzip2q_s8(v90, v91);
              int32x4_t v94 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v92, 0x20uLL), v92);
              int32x4_t v95 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v93, 0x20uLL), v93);
              int8x16_t v96 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v95.i8, 1);
              int8x16_t v97 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v94.i8, 1);
              int8x16_t v98 = (int8x16_t)vaddq_s32((int32x4_t)v97, v94);
              int8x16_t v99 = (int8x16_t)vaddq_s32((int32x4_t)v96, v95);
              v58 += v99.i32[3] + v98.i32[3];
              v99.i64[0] = *(void *)(v42 + v59);
              v96.i64[0] = *(void *)(v287 + v42 + v59);
              v98.i64[0] = *(void *)(result + v59);
              v97.i64[0] = *(void *)(v264 + v42 + v59);
              int8x16_t v100 = vzip1q_s8(v97, v96);
              int8x16_t v101 = vzip1q_s8(v98, v99);
              int32x4_t v102 = (int32x4_t)vzip1q_s8(v100, v101);
              int32x4_t v103 = (int32x4_t)vzip2q_s8(v100, v101);
              int32x4_t v104 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v102, 0x20uLL), v102);
              int32x4_t v105 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v103, 0x20uLL), v103);
              int8x16_t v106 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v105.i8, 1);
              int8x16_t v107 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v104.i8, 1);
              int8x16_t v108 = (int8x16_t)vaddq_s32((int32x4_t)v107, v104);
              int8x16_t v109 = (int8x16_t)vaddq_s32((int32x4_t)v106, v105);
              v57 += v109.i32[3] + v108.i32[3];
              v109.i64[0] = *(void *)(v44 + v59);
              v106.i64[0] = *(void *)(v286 + v44 + v59);
              v108.i64[0] = *(void *)(v282 + v44 + v59);
              v107.i64[0] = *(void *)(v263 + v44 + v59);
              int8x16_t v110 = vzip1q_s8(v107, v106);
              int8x16_t v111 = vzip1q_s8(v108, v109);
              int32x4_t v112 = (int32x4_t)vzip1q_s8(v110, v111);
              int32x4_t v113 = (int32x4_t)vzip2q_s8(v110, v111);
              int32x4_t v114 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v112, 0x20uLL), v112);
              int32x4_t v115 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v113, 0x20uLL), v113);
              int8x16_t v116 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v115.i8, 1);
              int8x16_t v117 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v114.i8, 1);
              int8x16_t v118 = (int8x16_t)vaddq_s32((int32x4_t)v117, v114);
              int8x16_t v119 = (int8x16_t)vaddq_s32((int32x4_t)v116, v115);
              v56 += v119.i32[3] + v118.i32[3];
              v119.i64[0] = *(void *)(v54 + v59);
              v116.i64[0] = *(void *)(v285 + v54 + v59);
              v118.i64[0] = *(void *)(v281 + v54 + v59);
              v117.i64[0] = *(void *)(v262 + v54 + v59);
              int8x16_t v120 = vzip1q_s8(v117, v116);
              int8x16_t v121 = vzip1q_s8(v118, v119);
              int32x4_t v122 = (int32x4_t)vzip1q_s8(v120, v121);
              int32x4_t v123 = (int32x4_t)vzip2q_s8(v120, v121);
              int32x4_t v124 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v122, 0x20uLL), v122);
              int32x4_t v125 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v123, 0x20uLL), v123);
              int8x16_t v46 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v125.i8, 1);
              int8x16_t v48 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v124.i8, 1);
              int8x16_t v47 = (int8x16_t)vaddq_s32((int32x4_t)v48, v124);
              int8x16_t v45 = (int8x16_t)vaddq_s32((int32x4_t)v46, v125);
              v55 += v45.i32[3] + v47.i32[3];
              unint64_t v88 = v59 + 8;
              unint64_t v126 = v59 + 16;
              v59 += 8;
            }
            while (v126 <= v36);
          }
          else
          {
            unint64_t v88 = v59;
            unint64_t v89 = v36 + a9;
          }
          if (v88 < v36)
          {
            result = v282 + v44;
            do
            {
              v58 += (*(unsigned __int8 *)(v40 + v88) << 24) | (*(unsigned __int8 *)(v288 + v40 + v88) << 16) | (*(unsigned __int8 *)(v284 + v40 + v88) << 8) | *(unsigned __int8 *)(v284 + v40 + v88);
              v57 += (*(unsigned __int8 *)(v42 + v88) << 24) | (*(unsigned __int8 *)(v287 + v42 + v88) << 16) | (*(unsigned __int8 *)(v283 + v42 + v88) << 8) | *(unsigned __int8 *)(v283 + v42 + v88);
              v56 += (*(unsigned __int8 *)(v44 + v88) << 24) | (*(unsigned __int8 *)(v286 + v44 + v88) << 16) | (*(unsigned __int8 *)(result + v88) << 8) | *(unsigned __int8 *)(result + v88);
              v55 += (*(unsigned __int8 *)(v54 + v88) << 24) | (*(unsigned __int8 *)(v285 + v54 + v88) << 16) | (*(unsigned __int8 *)(v281 + v54 + v88) << 8) | *(unsigned __int8 *)(v281 + v54 + v88);
              ++v88;
            }
            while (v36 != v88);
            unint64_t v88 = v36;
          }
          if (v88 + 32 <= v89)
          {
            unint64_t v129 = v265 + v40;
            unint64_t v130 = v284 + v40;
            uint64_t v131 = v288 + v40;
            unint64_t v132 = v264 + v42;
            result = v283 + v42;
            uint64_t v133 = v287 + v42;
            unint64_t v134 = v263 + v44;
            unint64_t v135 = v282 + v44;
            uint64_t v136 = v286 + v44;
            unint64_t v137 = v262 + v54;
            unint64_t v138 = v281 + v54;
            uint64_t v139 = v285 + v54;
            long long v140 = a11;
            do
            {
              v347.val[1] = *(int8x16_t *)(v40 + v88);
              v351.val[1] = *(int8x16_t *)(v40 + v88 + 16);
              v349.val[1] = *(int8x16_t *)(v131 + v88);
              v354.val[1] = *(int8x16_t *)(v131 + v88 + 16);
              v349.val[0] = *(int8x16_t *)(v129 + v88);
              v354.val[0] = *(int8x16_t *)(v129 + v88 + 16);
              int8x16_t v141 = v60[218];
              v347.val[0] = *(int8x16_t *)(v130 + v88);
              v351.val[0] = *(int8x16_t *)(v130 + v88 + 16);
              v345.val[0] = vqtbl2q_s8(v349, v141);
              v345.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61DB0);
              v357.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D60);
              v357.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D70);
              v359.val[0] = vqtbl2q_s8(v354, v141);
              v359.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61DB0);
              v339.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D60);
              v339.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D70);
              v361.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D40);
              v361.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D50);
              v342.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D80);
              v342.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D90);
              v336.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D40);
              v336.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D50);
              int8x16_t v142 = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D80);
              v349.val[1] = *(int8x16_t *)(v42 + v88);
              v351.val[1] = *(int8x16_t *)(v42 + v88 + 16);
              v333.val[0] = v142;
              v333.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D90);
              v354.val[1] = *(int8x16_t *)(v133 + v88);
              v347.val[1] = *(int8x16_t *)(v133 + v88 + 16);
              v349.val[0] = *(int8x16_t *)(result + v88);
              v351.val[0] = *(int8x16_t *)(result + v88 + 16);
              v354.val[0] = *(int8x16_t *)(v132 + v88);
              v347.val[0] = *(int8x16_t *)(v132 + v88 + 16);
              v331.val[0] = vqtbl2q_s8(v347, v141);
              v331.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61DB0);
              v329.val[0] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D60);
              v329.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D70);
              int8x16_t v324 = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D40);
              int8x16_t v327 = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D50);
              int8x16_t v316 = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D80);
              int8x16_t v320 = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D90);
              v322.val[0] = vqtbl2q_s8(v354, v141);
              v322.val[1] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61DB0);
              v314.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D60);
              v314.val[1] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D70);
              v312.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D40);
              v312.val[1] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D50);
              v310.val[0] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D80);
              v310.val[1] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D90);
              v354.val[1] = *(int8x16_t *)(v44 + v88);
              v347.val[1] = *(int8x16_t *)(v44 + v88 + 16);
              v354.val[0] = *(int8x16_t *)(v135 + v88);
              v347.val[0] = *(int8x16_t *)(v135 + v88 + 16);
              v349.val[1] = *(int8x16_t *)(v136 + v88);
              v351.val[1] = *(int8x16_t *)(v136 + v88 + 16);
              v349.val[0] = *(int8x16_t *)(v134 + v88);
              v351.val[0] = *(int8x16_t *)(v134 + v88 + 16);
              v308.val[0] = vqtbl2q_s8(v351, v141);
              v308.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61DB0);
              v306.val[0] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D60);
              v306.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D70);
              v304.val[0] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D40);
              v304.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D50);
              v300.val[0] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D80);
              v300.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D90);
              v302.val[0] = vqtbl2q_s8(v349, v141);
              v302.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61DB0);
              v298.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D60);
              v298.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D70);
              v296.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D40);
              v296.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D50);
              v294.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D80);
              v294.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D90);
              v354.val[1] = *(int8x16_t *)(v54 + v88);
              v351.val[1] = *(int8x16_t *)(v54 + v88 + 16);
              v354.val[0] = *(int8x16_t *)(v138 + v88);
              v351.val[0] = *(int8x16_t *)(v138 + v88 + 16);
              unint64_t v60 = (int8x16_t *)&unk_228F61000;
              v349.val[1] = *(int8x16_t *)(v139 + v88);
              v347.val[1] = *(int8x16_t *)(v139 + v88 + 16);
              v349.val[0] = *(int8x16_t *)(v137 + v88);
              v347.val[0] = *(int8x16_t *)(v137 + v88 + 16);
              v355.val[0] = vqtbl2q_s8(v347, v141);
              v355.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61DB0);
              v368.val[0] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D60);
              v368.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D70);
              v366.val[0] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D40);
              v366.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D50);
              v363.val[0] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61D80);
              v363.val[1] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61D90);
              v364.val[0] = vqtbl2q_s8(v349, v141);
              v364.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61DB0);
              v351.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D60);
              v351.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D70);
              v347.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D40);
              v347.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D50);
              v349.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61D80);
              v349.val[1] = vqtbl2q_s8(v354, (int8x16_t)xmmword_228F61D90);
              v354.val[1] = vqtbl2q_s8(v333, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v143 = (int32x4_t)vqtbl2q_s8(v336, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v144 = (int32x4_t)vqtbl2q_s8(v342, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v145 = (int32x4_t)vqtbl2q_s8(v361, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v146 = (int32x4_t)vqtbl2q_s8(v339, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v147 = (int32x4_t)vqtbl2q_s8(v359, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v148 = (int32x4_t)vqtbl2q_s8(v357, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v149 = (int32x4_t)vqtbl2q_s8(v345, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v150 = (int32x4_t)vqtbl2q_s8(v310, (int8x16_t)xmmword_228F61DC0);
              v357.val[0] = vqtbl2q_s8(v312, (int8x16_t)xmmword_228F61DC0);
              v357.val[1] = v316;
              v359.val[0] = v320;
              v361.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v357 + 16), (int8x16_t)xmmword_228F61DC0);
              v357.val[1] = v324;
              v359.val[0] = v327;
              v357.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v357 + 16), (int8x16_t)xmmword_228F61DC0);
              v361.val[0] = vqtbl2q_s8(v329, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v292 = (int32x4_t)vqtbl2q_s8(v331, (int8x16_t)xmmword_228F61DC0);
              v329.val[0] = vqtbl2q_s8(v314, (int8x16_t)xmmword_228F61DC0);
              v322.val[0] = vqtbl2q_s8(v322, (int8x16_t)xmmword_228F61DC0);
              v294.val[0] = vqtbl2q_s8(v294, (int8x16_t)xmmword_228F61DC0);
              v296.val[0] = vqtbl2q_s8(v296, (int8x16_t)xmmword_228F61DC0);
              v310.val[0] = vqtbl2q_s8(v300, (int8x16_t)xmmword_228F61DC0);
              v312.val[0] = vqtbl2q_s8(v304, (int8x16_t)xmmword_228F61DC0);
              v314.val[0] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v317 = (int32x4_t)vqtbl2q_s8(v308, (int8x16_t)xmmword_228F61DC0);
              v331.val[0] = vqtbl2q_s8(v298, (int8x16_t)xmmword_228F61DC0);
              v345.val[0] = vqtbl2q_s8(v302, (int8x16_t)xmmword_228F61DC0);
              v349.val[0] = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F61DC0);
              v349.val[1] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F61DC0);
              v363.val[0] = vqtbl2q_s8(v363, (int8x16_t)xmmword_228F61DC0);
              v363.val[1] = vqtbl2q_s8(v366, (int8x16_t)xmmword_228F61DC0);
              v336.val[0] = vqtbl2q_s8(v368, (int8x16_t)xmmword_228F61DC0);
              v342.val[0] = vqtbl2q_s8(v355, (int8x16_t)xmmword_228F61DC0);
              v339.val[0] = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61DC0);
              v351.val[1] = vqtbl2q_s8(v364, (int8x16_t)xmmword_228F61DC0);
              v354.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v354.val[1], 0x20uLL), (int32x4_t)v354.val[1]);
              v364.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v143, 0x20uLL), v143);
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v144, 0x20uLL), v144);
              v364.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v145, 0x20uLL), v145);
              v366.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v146, 0x20uLL), v146);
              v366.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v147, 0x20uLL), v147);
              int32x4_t v151 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v148, 0x20uLL), v148);
              v368.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v149, 0x20uLL), v149);
              v368.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v368.val[0].i8, 1);
              v368.val[1].i64[0] = 0;
              int32x4_t v152 = vdupq_lane_s32(*(int32x2_t *)v151.i8, 1);
              v368.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v368.val[1], (int32x4_t)v368.val[0]);
              v152.i64[0] = 0;
              int32x4_t v153 = vaddq_s32(v152, v151);
              v368.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v366.val[0].i8, 1);
              v368.val[0].i64[0] = 0;
              int32x4_t v154 = vdupq_lane_s32(*(int32x2_t *)v366.val[1].i8, 1);
              v154.i64[0] = 0;
              v366.val[1] = (int8x16_t)vaddq_s32(v154, (int32x4_t)v366.val[1]);
              v366.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v368.val[0], (int32x4_t)v366.val[0]);
              v368.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v364.val[1].i8, 1);
              v368.val[0].i64[0] = 0;
              int32x4_t v155 = vaddq_s32((int32x4_t)v368.val[0], (int32x4_t)v364.val[1]);
              v364.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v354.val[1].i8, 1);
              v364.val[1].i64[0] = 0;
              v333.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v364.val[1], (int32x4_t)v354.val[1]);
              v364.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v364.val[0].i8, 1);
              v364.val[1].i64[0] = 0;
              v368.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v354.val[0].i8, 1);
              int32x4_t v156 = vaddq_s32((int32x4_t)v364.val[1], (int32x4_t)v364.val[0]);
              v368.val[0].i64[0] = 0;
              int32x4_t v325 = vaddq_s32((int32x4_t)v368.val[0], (int32x4_t)v354.val[0]);
              v354.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v155, 3), (int32x4_t)v366.val[0]);
              v368.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v150, 0x20uLL), v150);
              int32x4_t v157 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v357.val[0], 0x20uLL), (int32x4_t)v357.val[0]);
              v364.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v361.val[1], 0x20uLL), (int32x4_t)v361.val[1]);
              int32x4_t v158 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v357.val[1], 0x20uLL), (int32x4_t)v357.val[1]);
              int32x4_t v159 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v361.val[0], 0x20uLL), (int32x4_t)v361.val[0]);
              int32x4_t v160 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v292, 0x20uLL), v292);
              v366.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v322.val[0], 0x20uLL), (int32x4_t)v322.val[0]);
              v355.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v366.val[0].i8, 1);
              int32x4_t v161 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v329.val[0], 0x20uLL), (int32x4_t)v329.val[0]);
              v355.val[0].i64[0] = 0;
              v355.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v355.val[0], (int32x4_t)v366.val[0]);
              v366.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v161.i8, 1);
              v366.val[0].i64[0] = 0;
              v308.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v333.val[0], 3), (int32x4_t)v366.val[1]);
              v366.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v160.i8, 1);
              v366.val[1].i64[0] = 0;
              v355.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v159.i8, 1);
              int32x4_t v162 = vaddq_s32((int32x4_t)v366.val[1], v160);
              v355.val[1].i64[0] = 0;
              int32x4_t v163 = vaddq_s32((int32x4_t)v355.val[1], v159);
              v366.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v158.i8, 1);
              v366.val[1].i64[0] = 0;
              v355.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v366.val[1], v158);
              int32x4_t v164 = vaddq_s32(vdupq_laneq_s32(v156, 3), v153);
              v366.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v364.val[1].i8, 1);
              v366.val[1].i64[0] = 0;
              int32x4_t v165 = vdupq_lane_s32(*(int32x2_t *)v157.i8, 1);
              v329.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v366.val[1], (int32x4_t)v364.val[1]);
              v165.i64[0] = 0;
              int32x4_t v166 = vaddq_s32(v165, v157);
              v366.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v368.val[0].i8, 1);
              v366.val[1].i64[0] = 0;
              v322.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v366.val[1], (int32x4_t)v368.val[0]);
              v351.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v325, 3), (int32x4_t)v368.val[1]);
              int32x4_t v167 = vaddq_s32(vdupq_laneq_s32((int32x4_t)v329.val[0], 3), v162);
              int32x4_t v168 = vaddq_s32(vdupq_laneq_s32(v166, 3), vaddq_s32((int32x4_t)v366.val[0], v161));
              int32x4_t v169 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v294.val[0], 0x20uLL), (int32x4_t)v294.val[0]);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v296.val[0], 0x20uLL), (int32x4_t)v296.val[0]);
              v357.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v310.val[0], 0x20uLL), (int32x4_t)v310.val[0]);
              v359.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v312.val[0], 0x20uLL), (int32x4_t)v312.val[0]);
              v359.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v314.val[0], 0x20uLL), (int32x4_t)v314.val[0]);
              v361.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v317, 0x20uLL), v317);
              v368.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v322.val[0], 3), (int32x4_t)v355.val[0]);
              v355.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v331.val[0], 0x20uLL), (int32x4_t)v331.val[0]);
              v361.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v345.val[0], 0x20uLL), (int32x4_t)v345.val[0]);
              v347.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v355.val[0].i8, 1);
              v347.val[0].i64[0] = 0;
              v354.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v361.val[1].i8, 1);
              v354.val[1].i64[0] = 0;
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[1], (int32x4_t)v361.val[1]);
              v347.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v347.val[0], (int32x4_t)v355.val[0]);
              v355.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v308.val[0], 3);
              v361.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[0], (int32x4_t)v355.val[0]);
              int32x4_t v170 = vaddq_s32(v155, (int32x4_t)v355.val[0]);
              v354.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v361.val[0].i8, 1);
              v354.val[0].i64[0] = 0;
              v355.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v351.val[0], 3);
              v354.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[0], (int32x4_t)v361.val[0]);
              v361.val[0] = (int8x16_t)vaddq_s32(v164, (int32x4_t)v355.val[0]);
              v364.val[1] = (int8x16_t)vdupq_n_s32(v58);
              v345.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(v156, (int32x4_t)v364.val[1]), (int32x4_t)v355.val[0]);
              int32x4_t v171 = vdupq_lane_s32(*(int32x2_t *)v359.val[1].i8, 1);
              v171.i64[0] = 0;
              v355.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v359.val[0].i8, 1);
              int32x4_t v172 = vaddq_s32(v171, (int32x4_t)v359.val[1]);
              v355.val[0].i64[0] = 0;
              v355.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v355.val[0], (int32x4_t)v359.val[0]);
              v359.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v357.val[0].i8, 1);
              v359.val[0].i64[0] = 0;
              v359.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v357.val[1].i8, 1);
              v359.val[1].i64[0] = 0;
              v357.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v359.val[1], (int32x4_t)v357.val[1]);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v359.val[0], (int32x4_t)v357.val[0]);
              v359.val[0] = (int8x16_t)vdupq_laneq_s32(v167, 3);
              int32x4_t v173 = vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v355.val[1], 3), v163), (int32x4_t)v359.val[0]);
              v359.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v355.val[1], (int32x4_t)v359.val[0]);
              v355.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v169.i8, 1);
              v355.val[1].i64[0] = 0;
              int32x4_t v174 = vaddq_s32((int32x4_t)v355.val[1], v169);
              v364.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v357.val[1], 3), (int32x4_t)v354.val[0]);
              v347.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v357.val[0], 3), (int32x4_t)v347.val[1]);
              v366.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v174, 3), (int32x4_t)v354.val[1]);
              v366.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v349.val[0], 0x20uLL), (int32x4_t)v349.val[0]);
              v354.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v349.val[1], 0x20uLL), (int32x4_t)v349.val[1]);
              v349.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v363.val[0], 0x20uLL), (int32x4_t)v363.val[0]);
              v363.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v363.val[1], 0x20uLL), (int32x4_t)v363.val[1]);
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v336.val[0], 0x20uLL), (int32x4_t)v336.val[0]);
              int32x4_t v175 = vdupq_laneq_s32((int32x4_t)v368.val[1], 3);
              v355.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v342.val[0], 0x20uLL), (int32x4_t)v342.val[0]);
              v359.val[1] = (int8x16_t)vaddq_s32(v168, v175);
              int32x4_t v176 = vdupq_n_s32(v57);
              v342.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(v166, v176), v175);
              int32x4_t v177 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v339.val[0], 0x20uLL), (int32x4_t)v339.val[0]);
              int32x4_t v178 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v351.val[1], 0x20uLL), (int32x4_t)v351.val[1]);
              v347.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v177.i8, 1);
              v347.val[1].i64[0] = 0;
              v363.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v178.i8, 1);
              v363.val[0].i64[0] = 0;
              int32x4_t v318 = vaddq_s32((int32x4_t)v363.val[0], v178);
              v368.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v347.val[1], v177);
              int32x4_t v179 = vdupq_laneq_s32((int32x4_t)v364.val[0], 3);
              v351.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v355.val[0], 3), v172), v179);
              int32x4_t v180 = vaddq_s32((int32x4_t)v355.val[0], v179);
              int32x4_t v181 = vdupq_lane_s32(*(int32x2_t *)v355.val[1].i8, 1);
              v181.i64[0] = 0;
              int32x4_t v182 = vdupq_laneq_s32((int32x4_t)v366.val[0], 3);
              v355.val[0] = (int8x16_t)vaddq_s32(v181, (int32x4_t)v355.val[1]);
              v349.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v347.val[0], v182);
              v347.val[0] = (int8x16_t)vdupq_n_s32(v56);
              v331.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v357.val[0], (int32x4_t)v347.val[0]), v182);
              int32x4_t v183 = vdupq_lane_s32(*(int32x2_t *)v354.val[1].i8, 1);
              v183.i64[0] = 0;
              v363.val[0] = (int8x16_t)vaddq_s32(v183, (int32x4_t)v354.val[1]);
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v361.val[1], (int32x4_t)v364.val[1]);
              int32x4_t v184 = vaddq_s32((int32x4_t)v333.val[0], (int32x4_t)v364.val[1]);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v308.val[0], (int32x4_t)v364.val[1]);
              v361.val[1] = (int8x16_t)vaddq_s32(v170, (int32x4_t)v364.val[1]);
              int32x4_t v185 = vaddq_s32((int32x4_t)v351.val[0], (int32x4_t)v364.val[1]);
              int32x4_t v186 = vaddq_s32(v325, (int32x4_t)v364.val[1]);
              v355.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v361.val[0], (int32x4_t)v364.val[1]);
              v364.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v361.val[0], 3);
              v361.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v354.val[1], (int32x4_t)v364.val[1]);
              v339.val[0] = (int8x16_t)vaddq_s32(v184, (int32x4_t)v364.val[1]);
              int32x4_t v187 = vaddq_s32((int32x4_t)v357.val[0], (int32x4_t)v364.val[1]);
              v354.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v361.val[1], (int32x4_t)v364.val[1]);
              v364.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v363.val[1].i8, 1);
              v364.val[1].i64[0] = 0;
              v363.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v364.val[1], (int32x4_t)v363.val[1]);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v359.val[0], v176);
              v359.val[0] = (int8x16_t)vaddq_s32(v167, v176);
              int8x16_t v188 = (int8x16_t)vaddq_s32((int32x4_t)v368.val[1], v176);
              v364.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v322.val[0], v176);
              v351.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v359.val[1], v176);
              v368.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v359.val[1], 3);
              v347.val[1] = (int8x16_t)vaddq_s32(vaddq_s32(v173, v176), (int32x4_t)v368.val[1]);
              int8x16_t v189 = (int8x16_t)vaddq_s32((int32x4_t)v357.val[0], (int32x4_t)v368.val[1]);
              v359.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v359.val[0], (int32x4_t)v368.val[1]);
              v336.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v329.val[0], v176), (int32x4_t)v368.val[1]);
              v357.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v349.val[1].i8, 1);
              v357.val[0].i64[0] = 0;
              v349.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v357.val[0], (int32x4_t)v349.val[1]);
              v359.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[1], (int32x4_t)v347.val[0]);
              v357.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v357.val[1], (int32x4_t)v347.val[0]);
              v364.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v364.val[0], (int32x4_t)v347.val[0]);
              int32x4_t v190 = vaddq_s32(v180, (int32x4_t)v347.val[0]);
              v357.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v366.val[0], (int32x4_t)v347.val[0]);
              v368.val[1] = (int8x16_t)vaddq_s32(v174, (int32x4_t)v347.val[0]);
              v361.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v349.val[0], (int32x4_t)v347.val[0]);
              v347.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v349.val[0], 3);
              int32x4_t v191 = vaddq_s32((int32x4_t)v359.val[0], (int32x4_t)v347.val[0]);
              v333.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v357.val[1], (int32x4_t)v347.val[0]);
              v364.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v364.val[0], (int32x4_t)v347.val[0]);
              int32x4_t v192 = vaddq_s32(v190, (int32x4_t)v347.val[0]);
              v347.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v354.val[0].i8, 1);
              v347.val[0].i64[0] = 0;
              v349.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v366.val[1].i8, 1);
              v347.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v347.val[0], (int32x4_t)v354.val[0]);
              v349.val[0].i64[0] = 0;
              v349.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v349.val[0], (int32x4_t)v366.val[1]);
              v351.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v363.val[1], 3), (int32x4_t)v363.val[0]);
              v354.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v349.val[1], 3), (int32x4_t)v355.val[0]);
              v363.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v347.val[0], 3), (int32x4_t)v368.val[0]);
              v366.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v349.val[0], 3), v318);
              v368.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v354.val[0], 3);
              v351.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[1], (int32x4_t)v368.val[0]);
              v363.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v363.val[1], (int32x4_t)v368.val[0]);
              v355.val[0] = (int8x16_t)vdupq_n_s32(v55);
              v368.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v366.val[0], 3);
              v363.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v363.val[0], (int32x4_t)v368.val[0]);
              v357.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v363.val[0], 3);
              v351.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v351.val[1], (int32x4_t)v355.val[0]), (int32x4_t)v357.val[1]);
              v363.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v363.val[1], (int32x4_t)v355.val[0]), (int32x4_t)v357.val[1]);
              v354.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v354.val[0], (int32x4_t)v355.val[0]), (int32x4_t)v357.val[1]);
              v359.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v349.val[1], (int32x4_t)v355.val[0]), (int32x4_t)v357.val[1]);
              v368.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v347.val[0], (int32x4_t)v355.val[0]), (int32x4_t)v368.val[0]);
              v363.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v363.val[0], (int32x4_t)v355.val[0]);
              v357.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v366.val[0], (int32x4_t)v355.val[0]);
              v355.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v349.val[0], (int32x4_t)v355.val[0]);
              unsigned int v58 = v361.val[0].u32[3];
              unsigned int v57 = v347.val[1].u32[3];
              unsigned int v56 = v191.u32[3];
              v349.val[0] = (int8x16_t)vuzp1q_s32((int32x4_t)v361.val[0], v191);
              v366.val[0] = (int8x16_t)vuzp2q_s32((int32x4_t)v361.val[0], v191);
              v191.i32[0] = v361.val[0].i32[2];
              v329.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v366.val[0], (int32x4_t)v361.val[0])), vuzp2q_s32((int32x4_t)v347.val[1], (int32x4_t)v351.val[1]));
              unsigned int v55 = v351.val[1].u32[3];
              v361.val[0] = v347.val[1];
              v361.val[0].i32[3] = v351.val[1].i32[1];
              v351.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v347.val[1], (int32x4_t)v351.val[1]);
              v349.val[1] = v359.val[1];
              v349.val[1].i32[3] = v354.val[0].i32[1];
              v322.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v349.val[0]), (int32x4_t)vextq_s8(v347.val[1], v351.val[1], 0xCuLL));
              int32x4_t v326 = vuzp2q_s32((int32x4_t)v359.val[1], (int32x4_t)v354.val[0]);
              v347.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v359.val[1], (int32x4_t)v354.val[0]);
              int32x4_t v319 = vtrn2q_s32(vrev64q_s32(vuzp1q_s32(v187, (int32x4_t)v364.val[0])), (int32x4_t)vextq_s8(v359.val[1], v347.val[1], 0xCuLL));
              v354.val[0] = (int8x16_t)vuzp1q_s32((int32x4_t)v355.val[1], (int32x4_t)v361.val[1]);
              v347.val[0] = (int8x16_t)vuzp2q_s32((int32x4_t)v355.val[1], (int32x4_t)v361.val[1]);
              v361.val[1].i32[0] = v355.val[1].i32[2];
              int32x4_t v193 = (int32x4_t)v351.val[0];
              v193.i32[3] = v363.val[0].i32[1];
              int8x16_t v53 = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v347.val[0], (int32x4_t)v355.val[1])), vuzp2q_s32((int32x4_t)v351.val[0], (int32x4_t)v363.val[0]));
              v347.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v347.val[0]), v193);
              v363.val[0] = (int8x16_t)vuzp1q_s32((int32x4_t)v351.val[0], (int32x4_t)v363.val[0]);
              v351.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v354.val[0]), (int32x4_t)vextq_s8(v351.val[0], v363.val[0], 0xCuLL));
              v354.val[0] = (int8x16_t)vuzp1q_s32(v185, (int32x4_t)v357.val[0]);
              int32x4_t v194 = vuzp2q_s32(v185, (int32x4_t)v357.val[0]);
              v357.val[0].i32[0] = v185.i32[2];
              v355.val[1] = v188;
              v355.val[1].i32[3] = v357.val[1].i32[1];
              v349.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32(v194, v185)), vuzp2q_s32((int32x4_t)v188, (int32x4_t)v357.val[1]));
              int32x4_t v195 = vtrn2q_s32(vrev64q_s32(v194), (int32x4_t)v355.val[1]);
              int32x4_t v196 = vuzp1q_s32((int32x4_t)v354.val[1], v192);
              v355.val[1] = (int8x16_t)vuzp2q_s32((int32x4_t)v354.val[1], v192);
              v192.i32[0] = v354.val[1].i32[2];
              v354.val[1] = (int8x16_t)vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v355.val[1], (int32x4_t)v354.val[1])), vuzp2q_s32((int32x4_t)v189, (int32x4_t)v363.val[1]));
              v357.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v188, (int32x4_t)v357.val[1]);
              v354.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v354.val[0]), (int32x4_t)vextq_s8(v188, v357.val[1], 0xCuLL));
              int32x4_t v197 = vtrn2q_s32(vrev64q_s32((int32x4_t)v357.val[0]), (int32x4_t)v357.val[1]);
              v357.val[0] = v368.val[1];
              v357.val[0].i32[0] = v186.i32[2];
              v357.val[1] = (int8x16_t)vuzp1q_s32(v186, (int32x4_t)v368.val[1]);
              v368.val[1] = (int8x16_t)vuzp2q_s32(v186, (int32x4_t)v368.val[1]);
              int32x4_t v198 = vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v368.val[1], v186)), vuzp2q_s32((int32x4_t)v364.val[1], (int32x4_t)v355.val[0]));
              v359.val[1] = v364.val[1];
              v359.val[1].i32[3] = v355.val[0].i32[1];
              v355.val[0] = (int8x16_t)vuzp1q_s32((int32x4_t)v364.val[1], (int32x4_t)v355.val[0]);
              *(int32x4_t *)long long v140 = vtrn2q_s32(vrev64q_s32((int32x4_t)v357.val[1]), (int32x4_t)vextq_s8(v364.val[1], v355.val[0], 0xCuLL));
              *((int32x4_t *)v140 + 1) = vtrn2q_s32(vrev64q_s32((int32x4_t)v368.val[1]), (int32x4_t)v359.val[1]);
              *((int32x4_t *)v140 + 2) = vtrn2q_s32(vrev64q_s32((int32x4_t)v357.val[0]), (int32x4_t)v355.val[0]);
              *((int32x4_t *)v140 + 3) = v198;
              *((_OWORD *)v140 + 4) = v354.val[0];
              *((int32x4_t *)v140 + 5) = v195;
              v354.val[0] = (int8x16_t)vuzp2q_s32(v187, (int32x4_t)v364.val[0]);
              v364.val[0].i32[0] = v187.i32[2];
              int8x16_t v51 = (int8x16_t)vtrn2q_s32((int32x4_t)v354.val[0], v187);
              *((int32x4_t *)v140 + 6) = v197;
              *((_OWORD *)v140 + 7) = v349.val[0];
              int32x4_t v199 = (int32x4_t)v331.val[0];
              v199.i32[0] = v345.val[0].i32[2];
              v368.val[1] = (int8x16_t)vuzp2q_s32((int32x4_t)v345.val[0], (int32x4_t)v331.val[0]);
              v349.val[0] = v342.val[0];
              v349.val[0].i32[3] = v368.val[0].i32[1];
              *((_OWORD *)v140 + 12) = v351.val[0];
              *((_OWORD *)v140 + 13) = v347.val[0];
              v351.val[0] = (int8x16_t)vuzp1q_s32((int32x4_t)v342.val[0], (int32x4_t)v368.val[0]);
              *((int32x4_t *)v140 + 8) = vtrn2q_s32(vrev64q_s32(vuzp1q_s32((int32x4_t)v345.val[0], (int32x4_t)v331.val[0])), (int32x4_t)vextq_s8(v342.val[0], v351.val[0], 0xCuLL));
              *((int32x4_t *)v140 + 9) = vtrn2q_s32(vrev64q_s32((int32x4_t)v368.val[1]), (int32x4_t)v349.val[0]);
              *((int32x4_t *)v140 + 14) = vtrn2q_s32(vrev64q_s32((int32x4_t)v361.val[1]), (int32x4_t)v363.val[0]);
              *((int8x16_t *)v140 + 15) = v53;
              *((int32x4_t *)v140 + 10) = vtrn2q_s32(vrev64q_s32(v199), (int32x4_t)v351.val[0]);
              *((int32x4_t *)v140 + 11) = vtrn2q_s32(vrev64q_s32(vtrn2q_s32((int32x4_t)v368.val[1], (int32x4_t)v345.val[0])), vuzp2q_s32((int32x4_t)v342.val[0], (int32x4_t)v368.val[0]));
              v347.val[0] = v189;
              v347.val[0].i32[3] = v363.val[1].i32[1];
              *((_OWORD *)v140 + 28) = v322.val[0];
              *((int32x4_t *)v140 + 29) = vtrn2q_s32(vrev64q_s32((int32x4_t)v366.val[0]), (int32x4_t)v361.val[0]);
              *((int32x4_t *)v140 + 20) = v319;
              *((int32x4_t *)v140 + 21) = vtrn2q_s32(vrev64q_s32((int32x4_t)v354.val[0]), (int32x4_t)v349.val[1]);
              v349.val[0] = (int8x16_t)vuzp1q_s32((int32x4_t)v189, (int32x4_t)v363.val[1]);
              *((int32x4_t *)v140 + 24) = vtrn2q_s32(vrev64q_s32(v196), (int32x4_t)vextq_s8(v189, v349.val[0], 0xCuLL));
              *((int32x4_t *)v140 + 25) = vtrn2q_s32(vrev64q_s32((int32x4_t)v355.val[1]), (int32x4_t)v347.val[0]);
              int8x16_t v50 = v333.val[0];
              v347.val[0] = (int8x16_t)vuzp2q_s32((int32x4_t)v339.val[0], (int32x4_t)v333.val[0]);
              v50.i32[0] = v339.val[0].i32[2];
              v363.val[0] = (int8x16_t)vtrn2q_s32((int32x4_t)v347.val[0], (int32x4_t)v339.val[0]);
              v349.val[1] = v336.val[0];
              v349.val[1].i32[3] = v359.val[0].i32[1];
              v347.val[0] = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v347.val[0]), (int32x4_t)v349.val[1]);
              int8x16_t v48 = (int8x16_t)vuzp2q_s32((int32x4_t)v336.val[0], (int32x4_t)v359.val[0]);
              v363.val[1] = (int8x16_t)vuzp1q_s32((int32x4_t)v336.val[0], (int32x4_t)v359.val[0]);
              int8x16_t v52 = vextq_s8(v336.val[0], v363.val[1], 0xCuLL);
              int8x16_t v49 = (int8x16_t)vtrn2q_s32(vrev64q_s32(vuzp1q_s32((int32x4_t)v339.val[0], (int32x4_t)v333.val[0])), (int32x4_t)v52);
              *((int8x16_t *)v140 + 16) = v49;
              *((_OWORD *)v140 + 17) = v347.val[0];
              *((int32x4_t *)v140 + 30) = vtrn2q_s32(vrev64q_s32(v191), (int32x4_t)v351.val[1]);
              *((_OWORD *)v140 + 31) = v329.val[0];
              *((int32x4_t *)v140 + 26) = vtrn2q_s32(vrev64q_s32(v192), (int32x4_t)v349.val[0]);
              *((_OWORD *)v140 + 27) = v354.val[1];
              int8x16_t v47 = (int8x16_t)vrev64q_s32((int32x4_t)v364.val[0]);
              *((int32x4_t *)v140 + 22) = vtrn2q_s32((int32x4_t)v47, (int32x4_t)v347.val[1]);
              *((int32x4_t *)v140 + 23) = vtrn2q_s32(vrev64q_s32((int32x4_t)v51), v326);
              int8x16_t v45 = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v363.val[0]), (int32x4_t)v48);
              int8x16_t v46 = (int8x16_t)vtrn2q_s32(vrev64q_s32((int32x4_t)v50), (int32x4_t)v363.val[1]);
              *((int8x16_t *)v140 + 18) = v46;
              *((int8x16_t *)v140 + 19) = v45;
              uint64_t v128 = v140 + 128;
              unint64_t v127 = v88 + 32;
              unint64_t v200 = v88 + 64;
              v88 += 32;
              v140 += 128;
            }
            while (v200 <= v89);
          }
          else
          {
            unint64_t v127 = v88;
            uint64_t v128 = a11;
          }
          unint64_t v201 = v89;
          if (v127 + 8 <= v89)
          {
            result = v287 + v42;
            unint64_t v37 = (int8x16_t *)&unk_228F61000;
            do
            {
              v45.i64[0] = *(void *)(v40 + v127);
              v46.i64[0] = *(void *)(v288 + v40 + v127);
              v47.i64[0] = *(void *)(v284 + v40 + v127);
              v48.i64[0] = *(void *)(v265 + v40 + v127);
              int8x16_t v204 = vzip1q_s8(v48, v46);
              int8x16_t v205 = vzip1q_s8(v47, v45);
              int32x4_t v206 = (int32x4_t)vzip1q_s8(v204, v205);
              int32x4_t v207 = (int32x4_t)vzip2q_s8(v204, v205);
              int8x16_t v208 = (int8x16_t)vshlq_n_s64((int64x2_t)v207, 0x20uLL);
              int32x4_t v209 = vdupq_n_s32(v58);
              v49.i64[0] = *(void *)(v42 + v127);
              int8x16_t v210 = (int8x16_t)vshlq_n_s64((int64x2_t)v206, 0x20uLL);
              int32x4_t v211 = vaddq_s32((int32x4_t)v210, v206);
              v210.i64[0] = *(void *)(result + v127);
              v50.i64[0] = *(void *)(v283 + v42 + v127);
              int8x16_t v212 = (int8x16_t)vaddq_s32((int32x4_t)v208, v207);
              v208.i64[0] = *(void *)(v264 + v42 + v127);
              int8x16_t v213 = vzip1q_s8(v208, v210);
              int8x16_t v214 = vzip1q_s8(v50, v49);
              int32x4_t v215 = vdupq_lane_s32(*(int32x2_t *)v212.i8, 1);
              int32x4_t v216 = (int32x4_t)vzip1q_s8(v213, v214);
              int32x4_t v217 = (int32x4_t)vzip2q_s8(v213, v214);
              int32x4_t v218 = vdupq_lane_s32(*(int32x2_t *)v211.i8, 1);
              int32x4_t v219 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v216, 0x20uLL), v216);
              int32x4_t v220 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v217, 0x20uLL), v217);
              int32x4_t v221 = vdupq_lane_s32(*(int32x2_t *)v220.i8, 1);
              v218.i64[0] = 0;
              int8x16_t v222 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v219.i8, 1);
              int32x4_t v223 = vdupq_n_s32(v57);
              v215.i64[0] = 0;
              int32x4_t v224 = vaddq_s32((int32x4_t)v212, v209);
              v212.i64[0] = *(void *)(v44 + v127);
              v222.i64[0] = 0;
              v51.i64[0] = *(void *)(v286 + v44 + v127);
              v52.i64[0] = *(void *)(v282 + v44 + v127);
              v221.i64[0] = 0;
              v53.i64[0] = *(void *)(v263 + v44 + v127);
              int8x16_t v225 = vzip1q_s8(v53, v51);
              int8x16_t v226 = vzip1q_s8(v52, v212);
              int32x4_t v227 = (int32x4_t)vzip1q_s8(v225, v226);
              int32x4_t v228 = vaddq_s32(v218, v211);
              int32x4_t v229 = (int32x4_t)vzip2q_s8(v225, v226);
              int8x16_t v230 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v227, 0x20uLL), v227);
              int8x16_t v231 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v230.i8, 1);
              int32x4_t v232 = vaddq_s32(v215, v224);
              v231.i64[0] = 0;
              int32x4_t v233 = vdupq_n_s32(v56);
              int32x4_t v234 = vaddq_s32((int32x4_t)v222, v219);
              int32x4_t v235 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v229, 0x20uLL), v229);
              v222.i64[0] = *(void *)(v54 + v127);
              v229.i64[0] = *(void *)(v285 + v54 + v127);
              int32x4_t v236 = vaddq_s32(v221, vaddq_s32(v220, v223));
              int32x4_t v237 = vaddq_s32((int32x4_t)v231, (int32x4_t)v230);
              v230.i64[0] = *(void *)(v281 + v54 + v127);
              v231.i64[0] = *(void *)(v262 + v54 + v127);
              int32x4_t v238 = vaddq_s32(v228, v209);
              int8x16_t v239 = vzip1q_s8(v231, (int8x16_t)v229);
              int8x16_t v240 = vzip1q_s8(v230, v222);
              int32x4_t v241 = (int32x4_t)vzip1q_s8(v239, v240);
              int32x4_t v242 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v241, 0x20uLL), v241);
              int32x4_t v243 = vaddq_s32(v234, v223);
              int32x4_t v244 = vdupq_lane_s32(*(int32x2_t *)v242.i8, 1);
              v244.i64[0] = 0;
              int8x16_t v51 = (int8x16_t)vaddq_s32(v244, v242);
              int8x16_t v52 = (int8x16_t)vaddq_s32(v237, v233);
              int8x16_t v53 = (int8x16_t)vdupq_n_s32(v55);
              int32x4_t v245 = vaddq_s32((int32x4_t)v51, (int32x4_t)v53);
              v369.val[0] = (float32x4_t)vzip1q_s32(v238, (int32x4_t)v52);
              int32x4_t v246 = v128 + 16;
              v369.val[1] = (float32x4_t)vzip1q_s32(v243, v245);
              int32x4_t v247 = v128;
              vst2q_f32(v247, v369);
              v247 += 8;
              int32x4_t v248 = vaddq_s32(v235, v233);
              int32x4_t v249 = vdupq_lane_s32(*(int32x2_t *)v235.i8, 1);
              int32x4_t v250 = vaddq_s32(v232, vdupq_laneq_s32(v228, 3));
              v249.i64[0] = 0;
              int8x16_t v48 = (int8x16_t)vaddq_s32(v236, vdupq_laneq_s32(v234, 3));
              int8x16_t v47 = (int8x16_t)vaddq_s32(vaddq_s32(v249, v248), vdupq_laneq_s32(v237, 3));
              int32x4_t v251 = (int32x4_t)vzip2q_s8(v239, v240);
              unsigned int v58 = v250.u32[3];
              int32x4_t v252 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v251, 0x20uLL), v251);
              int32x4_t v253 = vdupq_lane_s32(*(int32x2_t *)v252.i8, 1);
              unsigned int v57 = v48.u32[3];
              v253.i64[0] = 0;
              unsigned int v56 = v47.u32[3];
              unint64_t v254 = v128 + 24;
              int8x16_t v49 = (int8x16_t)vaddq_s32(vaddq_s32(v253, vaddq_s32(v252, (int32x4_t)v53)), vdupq_laneq_s32((int32x4_t)v51, 3));
              unsigned int v55 = v49.u32[3];
              v352.val[0] = (float32x4_t)vzip2q_s32(v238, (int32x4_t)v52);
              v352.val[1] = (float32x4_t)vzip2q_s32(v243, v245);
              vst2q_f32(v247, v352);
              v352.val[0] = (float32x4_t)vzip1q_s32(v250, (int32x4_t)v47);
              int8x16_t v50 = (int8x16_t)vzip1q_s32((int32x4_t)v48, (int32x4_t)v49);
              vst2q_f32(v246, *(float32x4x2_t *)(&v50 - 1));
              int8x16_t v45 = (int8x16_t)vzip2q_s32(v250, (int32x4_t)v47);
              int8x16_t v46 = (int8x16_t)vzip2q_s32((int32x4_t)v48, (int32x4_t)v49);
              vst2q_f32(v254, *(float32x4x2_t *)v45.i8);
              int32x4_t v203 = v128 + 32;
              unint64_t v202 = v127 + 8;
              unint64_t v255 = v127 + 16;
              v127 += 8;
              v128 += 32;
            }
            while (v255 <= v201);
          }
          else
          {
            unint64_t v202 = v127;
            int32x4_t v203 = v128;
            unint64_t v37 = (int8x16_t *)&unk_228F61000;
          }
          unint64_t v22 = v261;
          if (v202 < v201)
          {
            uint64_t v256 = 0;
            result = v287 + v202 + v42;
            unint64_t v257 = v281 + v202 + v54;
            unint64_t v258 = v285 + v202 + v54;
            unint64_t v259 = v54 + v202;
            do
            {
              v58 += (*(unsigned __int8 *)(v40 + v202 + v256) << 24) | (*(unsigned __int8 *)(v288 + v202 + v40 + v256) << 16) | (*(unsigned __int8 *)(v284 + v202 + v40 + v256) << 8) | *(unsigned __int8 *)(v284 + v202 + v40 + v256);
              v57 += (*(unsigned __int8 *)(v42 + v202 + v256) << 24) | (*(unsigned __int8 *)(result + v256) << 16) | (*(unsigned __int8 *)(v283 + v202 + v42 + v256) << 8) | *(unsigned __int8 *)(v283 + v202 + v42 + v256);
              v56 += (*(unsigned __int8 *)(v44 + v202 + v256) << 24) | (*(unsigned __int8 *)(v286 + v202 + v44 + v256) << 16) | (*(unsigned __int8 *)(v282 + v202 + v44 + v256) << 8) | *(unsigned __int8 *)(v282 + v202 + v44 + v256);
              v55 += (*(unsigned __int8 *)(v259 + v256) << 24) | (*(unsigned __int8 *)(v258 + v256) << 16) | (*(unsigned __int8 *)(v257 + v256) << 8) | *(unsigned __int8 *)(v257 + v256);
              *(void *)&long long v260 = __PAIR64__(v57, v58);
              *((void *)&v260 + 1) = __PAIR64__(v55, v56);
              *(_OWORD *)&v203[4 * v256++] = v260;
            }
            while (v201 - v202 != v256);
          }
        }
        a11 = (float *)((char *)a11 + a12);
        uint64_t v34 = v289 + a10;
      }
      while (v34 + (unint64_t)a3[7].u32[0] < v22);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v322 = result;
  if (a9)
  {
    unint64_t v16 = *(void *)(a2 + 56);
    uint64_t v17 = *(ChannelDescription **)(a4 + 8);
    *(int32x2_t *)v337.val[0].i8 = a3[3];
    uint64_t v18 = a3[7].u32[1];
    int32x2_t v19 = *(int32x2_t *)((char *)v17 + 48);
    int32x2_t v20 = *(int32x2_t *)(*(void *)(*((void *)v17 + 5) + 8 * v18) + 16);
    uint64_t v319 = v337.val[0].u32[0];
    int8x16_t v320 = v17;
    unsigned int v318 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v17, (a3[6].i32[1] + v337.val[0].i32[1] * HIDWORD(v16)), v337.val[0].u32[0], v18);
    uint64_t v21 = *(ChannelDescription **)(a5 + 8);
    int32x2_t v334 = a3[3];
    uint64_t v22 = a3[7].u32[1];
    int32x2_t v23 = *(int32x2_t *)((char *)v21 + 48);
    int32x2_t v24 = *(int32x2_t *)(*(void *)(*((void *)v21 + 5) + 8 * v22) + 16);
    uint64_t v316 = v334.u32[0];
    int32x4_t v317 = v21;
    unsigned int v315 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v21, (a3[6].i32[1] + v334.i32[1] * HIDWORD(v16)), v334.u32[0], v22);
    int32x2_t v25 = *(ChannelDescription **)(a6 + 8);
    *(int32x2_t *)v332.val[0].i8 = a3[3];
    uint64_t v26 = a3[7].u32[1];
    int32x2_t v27 = *(int32x2_t *)((char *)v25 + 48);
    int32x2_t v28 = *(int32x2_t *)(*(void *)(*((void *)v25 + 5) + 8 * v26) + 16);
    uint64_t v313 = v332.val[0].u32[0];
    int8x16x2_t v314 = v25;
    unsigned int v312 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v25, (a3[6].i32[1] + v332.val[0].i32[1] * HIDWORD(v16)), v332.val[0].u32[0], v26);
    int32x2_t v29 = *(ChannelDescription **)(a7 + 8);
    *(int32x2_t *)v330.val[0].i8 = a3[3];
    unint64_t v321 = HIDWORD(v16);
    uint64_t v30 = a3[7].u32[1];
    int32x2_t v31 = *(int32x2_t *)((char *)v29 + 48);
    int32x2_t v32 = *(int32x2_t *)(*(void *)(*((void *)v29 + 5) + 8 * v30) + 16);
    uint64_t v310 = v330.val[0].u32[0];
    int8x16x2_t v311 = v29;
    unsigned int v309 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v29, (a3[6].i32[1] + v330.val[0].i32[1] * HIDWORD(v16)), v330.val[0].u32[0], v30);
    uint64_t v33 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v33 < HIDWORD(v16))
    {
      uint64_t v327 = vmin_u32((uint32x2_t)vmls_s32(v20, v19, *(int32x2_t *)v337.val[0].i8), (uint32x2_t)v19).u32[0];
      uint64_t v326 = vmin_u32((uint32x2_t)vmls_s32(v24, v23, v334), (uint32x2_t)v23).u32[0];
      uint64_t v325 = vmin_u32((uint32x2_t)vmls_s32(v28, v27, *(int32x2_t *)v332.val[0].i8), (uint32x2_t)v27).u32[0];
      uint64_t v324 = vmin_u32((uint32x2_t)vmls_s32(v32, v31, *(int32x2_t *)v330.val[0].i8), (uint32x2_t)v31).u32[0];
      int v308 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v35 = a3[5].u32[1];
      unint64_t v36 = v35 + a9;
      do
      {
        unint64_t v37 = (v308 + v33);
        unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v320, v37, v319, v318);
        if (HIDWORD(LocationForTile)) {
          unint64_t v39 = v322 + LocationForTile;
        }
        else {
          unint64_t v39 = 0;
        }
        unint64_t v40 = ChannelDescription::GetLocationForTile(v317, v37, v316, v315);
        if (HIDWORD(v40)) {
          unint64_t v41 = v322 + v40;
        }
        else {
          unint64_t v41 = 0;
        }
        unint64_t v42 = ChannelDescription::GetLocationForTile(v314, v37, v313, v312);
        if (HIDWORD(v42)) {
          unint64_t v43 = v322 + v42;
        }
        else {
          unint64_t v43 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v311, v37, v310, v309);
        int8x16_t v47 = (int8x16_t)xmmword_228F61DE0;
        int8x16_t v46 = (int8x16_t)xmmword_228F61DD0;
        v48.i64[0] = 0xFFFFFFFF00000000;
        v48.i64[1] = 0xFFFFFFFF00000000;
        unint64_t v49 = v322 + result;
        if (!HIDWORD(result)) {
          unint64_t v49 = 0;
        }
        if (v39 && v41 && v43 && v49)
        {
          if (v35 >= 0x20)
          {
            uint64_t v61 = 0;
            unsigned int v53 = 0;
            unsigned int v52 = 0;
            unsigned int v51 = 0;
            unsigned int v50 = 0;
            uint64_t v62 = v327 + v39;
            uint64_t v63 = v326 + v41;
            uint64_t v64 = v325 + v43;
            uint64_t v65 = v324 + v49;
            unint64_t v54 = (int8x16_t *)&loc_228F41000;
            unsigned int v55 = (int8x16_t *)&loc_228F41000;
            unsigned int v56 = (int8x16_t *)&loc_228F41000;
            unsigned int v57 = (int8x16_t *)&loc_228F41000;
            unsigned int v58 = (int8x16_t *)&loc_228F41000;
            uint64_t v59 = (int8x16_t *)&loc_228F41000;
            unint64_t v60 = (int8x16_t *)&loc_228F41000;
            do
            {
              int8x16_t v67 = *(int8x16_t *)(v39 + v61);
              int8x16_t v66 = *(int8x16_t *)(v39 + v61 + 16);
              int8x16_t v69 = *(int8x16_t *)(v62 + v61);
              int8x16_t v68 = *(int8x16_t *)(v62 + v61 + 16);
              int16x8_t v70 = (int16x8_t)vzip1q_s8(v69, v67);
              int16x8_t v71 = (int16x8_t)vzip2q_s8(v69, v67);
              int16x8_t v72 = (int16x8_t)vzip1q_s8(v68, v66);
              int16x8_t v73 = (int16x8_t)vzip2q_s8(v68, v66);
              int8x16_t v74 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v70, 0x10uLL), v70);
              int8x16_t v75 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v71, 0x10uLL), v71);
              int8x16_t v76 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v72, 0x10uLL), v72);
              int8x16_t v77 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v73, 0x10uLL), v73);
              int16x8_t v78 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v77, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v77);
              int16x8_t v79 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v76, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v76);
              int16x8_t v80 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v75, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v75);
              int8x16_t v82 = *(int8x16_t *)(v41 + v61);
              int8x16_t v81 = *(int8x16_t *)(v41 + v61 + 16);
              int16x8_t v83 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v74, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v74);
              int8x16_t v85 = *(int8x16_t *)(v63 + v61);
              int8x16_t v84 = *(int8x16_t *)(v63 + v61 + 16);
              int16x8_t v86 = (int16x8_t)vzip1q_s8(v85, v82);
              int16x8_t v87 = (int16x8_t)vzip2q_s8(v85, v82);
              int16x8_t v88 = (int16x8_t)vzip1q_s8(v84, v81);
              int16x8_t v89 = (int16x8_t)vzip2q_s8(v84, v81);
              int8x16_t v90 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v86, 0x10uLL), v86);
              int8x16_t v91 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v87, 0x10uLL), v87);
              int8x16_t v92 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v88, 0x10uLL), v88);
              int8x16_t v93 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v89, 0x10uLL), v89);
              int16x8_t v94 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v93, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v93);
              int16x8_t v95 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v92, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v92);
              int16x8_t v96 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v90, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v90);
              int16x8_t v97 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v91, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v91);
              int8x16_t v99 = *(int8x16_t *)(v43 + v61);
              int8x16_t v98 = *(int8x16_t *)(v43 + v61 + 16);
              int8x16_t v100 = *(int8x16_t *)(v64 + v61);
              int8x16_t v101 = *(int8x16_t *)(v64 + v61 + 16);
              int16x8_t v102 = (int16x8_t)vzip1q_s8(v100, v99);
              int16x8_t v103 = (int16x8_t)vzip2q_s8(v100, v99);
              int16x8_t v104 = (int16x8_t)vzip1q_s8(v101, v98);
              int16x8_t v105 = (int16x8_t)vzip2q_s8(v101, v98);
              int8x16_t v106 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v102, 0x10uLL), v102);
              int8x16_t v107 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v103, 0x10uLL), v103);
              int8x16_t v108 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v104, 0x10uLL), v104);
              int8x16_t v109 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v105, 0x10uLL), v105);
              int16x8_t v110 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v109, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v109);
              int16x8_t v111 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v107, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v107);
              int16x8_t v112 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v83.i8, 3), v83), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v80.i8, 3), v80));
              int16x8_t v113 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v106, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v106);
              int16x8_t v114 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v79.i8, 3), v79), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v78.i8, 3), v78));
              int16x8_t v115 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v108, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v108);
              int16x8_t v116 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v96.i8, 3), v96), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v97.i8, 3), v97));
              int16x8_t v117 = vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v110.i8, 3), v110);
              int16x8_t v118 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v95.i8, 3), v95), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v94.i8, 3), v94));
              int8x16_t v120 = *(int8x16_t *)(v49 + v61);
              int8x16_t v119 = *(int8x16_t *)(v49 + v61 + 16);
              int8x16_t v122 = *(int8x16_t *)(v65 + v61);
              int8x16_t v121 = *(int8x16_t *)(v65 + v61 + 16);
              int16x8_t v123 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v113.i8, 3), v113), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v111.i8, 3), v111));
              int16x8_t v124 = (int16x8_t)vzip1q_s8(v122, v120);
              int16x8_t v125 = (int16x8_t)vzip2q_s8(v122, v120);
              int16x8_t v126 = (int16x8_t)vzip1q_s8(v121, v119);
              int16x8_t v127 = (int16x8_t)vzip2q_s8(v121, v119);
              int16x8_t v128 = vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v115.i8, 3), v115), v117);
              int8x16_t v129 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v124, 0x10uLL), v124);
              int8x16_t v130 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v125, 0x10uLL), v125);
              int16x8_t v131 = vaddq_s16(v114, v112);
              int8x16_t v132 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v126, 0x10uLL), v126);
              int8x16_t v133 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v127, 0x10uLL), v127);
              int16x8_t v134 = vaddq_s16(v118, v116);
              int16x8_t v135 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v133, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v133);
              int16x8_t v136 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v132, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v132);
              int16x8_t v137 = vaddq_s16(v128, v123);
              int16x8_t v138 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v130, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v130);
              int16x8_t v139 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v129, (int8x16_t)xmmword_228F61DD0), v48), (int16x8_t)v129);
              v53 += v131.u16[7];
              int8x16_t v45 = (int8x16_t)vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v136.i8, 3), v136), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v135.i8, 3), v135));
              int8x16_t v44 = (int8x16_t)vaddq_s16((int16x8_t)v45, vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v139.i8, 3), v139), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v138.i8, 3), v138)));
              v52 += v134.u16[7];
              v51 += v137.u16[7];
              v50 += v44.u16[7];
              result = v61 + 32;
              unint64_t v140 = v61 + 64;
              v61 += 32;
            }
            while (v140 <= v35);
          }
          else
          {
            unsigned int v50 = 0;
            unsigned int v51 = 0;
            unsigned int v52 = 0;
            unsigned int v53 = 0;
            result = 0;
            unint64_t v54 = (int8x16_t *)&loc_228F41000;
            unsigned int v55 = (int8x16_t *)&loc_228F41000;
            unsigned int v56 = (int8x16_t *)&loc_228F41000;
            unsigned int v57 = (int8x16_t *)&loc_228F41000;
            unsigned int v58 = (int8x16_t *)&loc_228F41000;
            uint64_t v59 = (int8x16_t *)&loc_228F41000;
            unint64_t v60 = (int8x16_t *)&loc_228F41000;
          }
          if ((result | 8) <= v35)
          {
            do
            {
              v44.i64[0] = *(void *)(v39 + result);
              v45.i64[0] = *(void *)(v327 + v39 + result);
              int16x8_t v142 = (int16x8_t)vzip1q_s8(v45, v44);
              int8x16_t v143 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v142, 0x10uLL), v142);
              int8x16_t v144 = vextq_s8(v143, v143, 0xCuLL);
              int8x16_t v145 = (int8x16_t)vaddq_s16((int16x8_t)v144, (int16x8_t)v143);
              int v146 = v145.u16[3];
              v145.i64[0] = *(void *)(v41 + result);
              v53 += v145.u16[7] + v146;
              v144.i64[0] = *(void *)(v326 + v41 + result);
              int16x8_t v147 = (int16x8_t)vzip1q_s8(v144, v145);
              int8x16_t v148 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v147, 0x10uLL), v147);
              int8x16_t v149 = vextq_s8(v148, v148, 0xCuLL);
              int8x16_t v150 = (int8x16_t)vaddq_s16((int16x8_t)v149, (int16x8_t)v148);
              int v151 = v150.u16[3];
              unsigned int v152 = v150.u16[7] + v52;
              v150.i64[0] = *(void *)(v43 + result);
              v149.i64[0] = *(void *)(v325 + v43 + result);
              int16x8_t v153 = (int16x8_t)vzip1q_s8(v149, v150);
              int8x16_t v154 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v153, 0x10uLL), v153);
              int8x16_t v155 = vextq_s8(v154, v154, 0xCuLL);
              int8x16_t v156 = (int8x16_t)vaddq_s16((int16x8_t)v155, (int16x8_t)v154);
              unsigned int v52 = v152 + v151;
              int v157 = v156.u16[3];
              v156.i64[0] = *(void *)(v49 + result);
              v51 += v156.u16[7] + v157;
              v155.i64[0] = *(void *)(v324 + v49 + result);
              int16x8_t v158 = (int16x8_t)vzip1q_s8(v155, v156);
              int8x16_t v159 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v158, 0x10uLL), v158);
              int8x16_t v45 = vextq_s8(v159, v159, 0xCuLL);
              int8x16_t v44 = (int8x16_t)vaddq_s16((int16x8_t)v45, (int16x8_t)v159);
              v50 += v44.u16[7] + v44.u16[3];
              unint64_t v141 = result + 8;
              unint64_t v160 = result + 16;
              result += 8;
            }
            while (v160 <= v35);
          }
          else
          {
            unint64_t v141 = result;
          }
          if (v141 < v35)
          {
            do
            {
              v53 += *(unsigned __int8 *)(v327 + v39 + v141) | (*(unsigned __int8 *)(v39 + v141) << 8);
              v52 += *(unsigned __int8 *)(v326 + v41 + v141) | (*(unsigned __int8 *)(v41 + v141) << 8);
              v51 += *(unsigned __int8 *)(v325 + v43 + v141) | (*(unsigned __int8 *)(v43 + v141) << 8);
              result = *(unsigned __int8 *)(v324 + v49 + v141) | (*(unsigned __int8 *)(v49 + v141) << 8);
              v50 += result;
              ++v141;
            }
            while (v35 != v141);
            unint64_t v141 = v35;
          }
          if (v141 + 32 <= v36)
          {
            uint64_t v163 = v327 + v39;
            uint64_t v164 = v326 + v41;
            uint64_t v165 = v325 + v43;
            uint64_t v166 = v324 + v49;
            result = (unint64_t)a11;
            do
            {
              int8x16_t v168 = *(int8x16_t *)(v39 + v141);
              int8x16_t v167 = *(int8x16_t *)(v39 + v141 + 16);
              int8x16_t v170 = *(int8x16_t *)(v163 + v141);
              int8x16_t v169 = *(int8x16_t *)(v163 + v141 + 16);
              int16x8_t v171 = (int16x8_t)vzip2q_s8(v170, v168);
              int16x8_t v172 = (int16x8_t)vzip2q_s8(v169, v167);
              int16x8_t v173 = (int16x8_t)vzip1q_s8(v169, v167);
              int16x8_t v174 = (int16x8_t)vzip1q_s8(v170, v168);
              int8x16_t v175 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v171, 0x10uLL), v171);
              int8x16_t v176 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v172, 0x10uLL), v172);
              int8x16_t v177 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v173, 0x10uLL), v173);
              int8x16_t v178 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v174, 0x10uLL), v174);
              int16x8_t v179 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v178, v46), v48), (int16x8_t)v178);
              int16x8_t v180 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v177, v46), v48), (int16x8_t)v177);
              int16x8_t v181 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v176, v46), v48), (int16x8_t)v176);
              int16x8_t v182 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v175, v46), v48), (int16x8_t)v175);
              int16x8_t v183 = vdupq_n_s16(v53);
              int8x16_t v185 = *(int8x16_t *)(v41 + v141);
              int8x16_t v184 = *(int8x16_t *)(v41 + v141 + 16);
              int8x16_t v187 = *(int8x16_t *)(v164 + v141);
              int8x16_t v186 = *(int8x16_t *)(v164 + v141 + 16);
              int16x8_t v188 = (int16x8_t)vzip2q_s8(v187, v185);
              int16x8_t v189 = (int16x8_t)vzip2q_s8(v186, v184);
              int16x8_t v190 = (int16x8_t)vzip1q_s8(v186, v184);
              int16x8_t v191 = (int16x8_t)vzip1q_s8(v187, v185);
              int8x16_t v192 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v188, 0x10uLL), v188);
              int8x16_t v193 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v189, 0x10uLL), v189);
              int8x16_t v194 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v190, 0x10uLL), v190);
              int8x16_t v195 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v191, 0x10uLL), v191);
              int16x8_t v196 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v194, v46), v48), (int16x8_t)v194);
              int16x8_t v197 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v192, v46), v48), (int16x8_t)v192);
              int16x8_t v198 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v193, v46), v48), (int16x8_t)v193);
              int16x8_t v199 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v180.i8, 3), v47), v180);
              int16x8_t v200 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v195, v46), v48), (int16x8_t)v195);
              int16x8_t v201 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v179.i8, 3), v47), v179);
              int16x8_t v202 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v198.i8, 3), v47), v198);
              int16x8_t v203 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v196.i8, 3), v47), v196);
              int16x8_t v204 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v200.i8, 3), v47), v200);
              int16x8_t v205 = vdupq_n_s16(v52);
              int16x8_t v206 = vdupq_laneq_s16(v199, 7);
              int8x16_t v208 = *(int8x16_t *)(v43 + v141);
              int8x16_t v207 = *(int8x16_t *)(v43 + v141 + 16);
              int16x8_t v209 = vaddq_s16(v199, v183);
              int8x16_t v210 = *(int8x16_t *)(v165 + v141);
              int8x16_t v211 = *(int8x16_t *)(v165 + v141 + 16);
              int16x8_t v212 = (int16x8_t)vzip2q_s8(v210, v208);
              int16x8_t v213 = (int16x8_t)vzip2q_s8(v211, v207);
              int16x8_t v214 = (int16x8_t)vzip1q_s8(v211, v207);
              int16x8_t v215 = (int16x8_t)vzip1q_s8(v210, v208);
              int8x16_t v216 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v212, 0x10uLL), v212);
              int8x16_t v217 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v213, 0x10uLL), v213);
              int8x16_t v218 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v214, 0x10uLL), v214);
              int8x16_t v219 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v215, 0x10uLL), v215);
              int16x8_t v220 = vdupq_laneq_s16(v203, 7);
              int16x8_t v221 = vaddq_s16(v203, v205);
              int16x8_t v222 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v219, v46), v48), (int16x8_t)v219);
              int16x8_t v223 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v217, v46), v48), (int16x8_t)v217);
              int16x8_t v224 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v216, v46), v48), (int16x8_t)v216);
              int16x8_t v225 = vaddq_s16(vdupq_laneq_s16(v201, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v182.i8, 3), v47), v182));
              int16x8_t v226 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v218, v46), v48), (int16x8_t)v218);
              int16x8_t v227 = vaddq_s16(v220, v202);
              int16x8_t v228 = vaddq_s16(v204, v205);
              int16x8_t v229 = vaddq_s16(vdupq_laneq_s16(v204, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v197.i8, 3), v47), v197));
              int16x8_t v230 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v226.i8, 3), v47), v226);
              int16x8_t v231 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v222.i8, 3), v47), v222);
              int16x8_t v232 = vdupq_laneq_s16(v225, 7);
              int16x8_t v233 = vaddq_s16(vdupq_laneq_s16(v230, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v223.i8, 3), v47), v223));
              int16x8_t v234 = vaddq_s16(vaddq_s16(v206, vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v181.i8, 3), v47), v181)), v183);
              int16x8_t v235 = vaddq_s16(vdupq_laneq_s16(v231, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v224.i8, 3), v47), v224));
              int16x8_t v236 = vdupq_n_s16(v51);
              int16x8_t v237 = vaddq_s16(v230, v236);
              v338.val[0] = (int8x16_t)vaddq_s16(v201, v183);
              v338.val[1] = (int8x16_t)vaddq_s16(v231, v236);
              v339.val[0] = (int8x16_t)vaddq_s16(v225, v183);
              int8x16_t v239 = *(int8x16_t *)(v49 + v141);
              int8x16_t v238 = *(int8x16_t *)(v49 + v141 + 16);
              int16x8_t v240 = vdupq_laneq_s16(v229, 7);
              int8x16_t v242 = *(int8x16_t *)(v166 + v141);
              int8x16_t v241 = *(int8x16_t *)(v166 + v141 + 16);
              int16x8_t v243 = (int16x8_t)vzip2q_s8(v242, v239);
              int16x8_t v244 = (int16x8_t)vzip2q_s8(v241, v238);
              int16x8_t v245 = (int16x8_t)vzip1q_s8(v241, v238);
              int16x8_t v246 = vaddq_s16(v227, v205);
              int16x8_t v247 = (int16x8_t)vzip1q_s8(v242, v239);
              v345.val[0] = (int8x16_t)vaddq_s16(v229, v205);
              int8x16_t v248 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v243, 0x10uLL), v243);
              int8x16_t v249 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v244, 0x10uLL), v244);
              int8x16_t v250 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v245, 0x10uLL), v245);
              int8x16_t v251 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v247, 0x10uLL), v247);
              int16x8_t v252 = vdupq_laneq_s16(v235, 7);
              int8x16_t v253 = vqtbl1q_s8(v251, v46);
              int8x16_t v254 = vqtbl1q_s8(v250, v46);
              int8x16_t v255 = vqtbl1q_s8(v249, v46);
              int16x8_t v256 = (int16x8_t)vandq_s8(vqtbl1q_s8(v248, v46), v48);
              int16x8_t v257 = vaddq_s16(v233, v236);
              int16x8_t v258 = (int16x8_t)vandq_s8(v255, v48);
              int16x8_t v259 = vaddq_s16((int16x8_t)vandq_s8(v253, v48), (int16x8_t)v251);
              int16x8_t v260 = vaddq_s16(v258, (int16x8_t)v249);
              v339.val[1] = (int8x16_t)vaddq_s16(v235, v236);
              int16x8_t v261 = vaddq_s16(v256, (int16x8_t)v248);
              v346.val[0] = (int8x16_t)vaddq_s16(v234, v232);
              int16x8_t v262 = vaddq_s16((int16x8_t)vandq_s8(v254, v48), (int16x8_t)v250);
              v347.val[0] = (int8x16_t)vaddq_s16(v209, v232);
              v342.val[0] = (int8x16_t)vaddq_s16(v246, v240);
              int16x8_t v263 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v262.i8, 3), v47), v262);
              int16x8_t v264 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v259.i8, 3), v47), v259);
              v348.val[0] = (int8x16_t)vaddq_s16(v221, v240);
              int16x8_t v265 = vaddq_s16(vdupq_laneq_s16(v264, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v261.i8, 3), v47), v261));
              int16x8_t v266 = vdupq_laneq_s16(v265, 7);
              v347.val[1] = (int8x16_t)vaddq_s16(v237, v252);
              int16x8_t v267 = vaddq_s16(vdupq_laneq_s16(v263, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v260.i8, 3), v47), v260));
              int16x8_t v268 = vdupq_n_s16(v50);
              int16x8_t v269 = vaddq_s16(v267, v268);
              unsigned int v53 = v346.val[0].u16[7];
              v348.val[1] = (int8x16_t)vaddq_s16(vaddq_s16(v263, v268), v266);
              v345.val[1] = (int8x16_t)vaddq_s16(v265, v268);
              v350.val[0] = (int8x16_t)v228;
              v350.val[1] = (int8x16_t)vaddq_s16(v264, v268);
              unsigned int v52 = v342.val[0].u16[7];
              int8x16_t v270 = v54[205];
              int8x16_t v271 = v55[190];
              int8x16_t v272 = v56[204];
              int8x16_t v273 = v57[195];
              int8x16_t v274 = v58[207];
              v346.val[1] = (int8x16_t)vaddq_s16(v257, v252);
              int8x16_t v275 = v59[194];
              int8x16_t v276 = v60[206];
              int8x16_t v335 = vqtbl2q_s8(v339, (int8x16_t)xmmword_228F41C00);
              int8x16_t v336 = vqtbl2q_s8(v345, v270);
              v342.val[1] = (int8x16_t)vaddq_s16(v269, v266);
              v333.val[0] = vqtbl2q_s8(v339, v271);
              v333.val[1] = vqtbl2q_s8(v345, v272);
              v331.val[0] = vqtbl2q_s8(v339, v273);
              v331.val[1] = vqtbl2q_s8(v345, v274);
              int8x16_t v328 = vqtbl2q_s8(v339, v275);
              int8x16_t v329 = vqtbl2q_s8(v345, v276);
              v351.val[0] = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F41C00);
              v351.val[1] = vqtbl2q_s8(v348, v270);
              v344.val[0] = vqtbl2q_s8(v347, v271);
              v344.val[1] = vqtbl2q_s8(v348, v272);
              v345.val[0] = vqtbl2q_s8(v347, v273);
              v345.val[1] = vqtbl2q_s8(v348, v274);
              v347.val[0] = vqtbl2q_s8(v347, v275);
              v347.val[1] = vqtbl2q_s8(v348, v276);
              v348.val[0] = vqtbl2q_s8(v338, (int8x16_t)xmmword_228F41C00);
              int8x16x2_t v343 = v350;
              v348.val[1] = vqtbl2q_s8(v350, v270);
              v349.val[0] = vqtbl2q_s8(v338, v271);
              v349.val[1] = vqtbl2q_s8(v350, v56[204]);
              v340.val[0] = vqtbl2q_s8(v338, v273);
              v340.val[1] = vqtbl2q_s8(v350, v274);
              v350.val[0] = vqtbl2q_s8(v338, v275);
              v350.val[1] = vqtbl2q_s8(v343, v276);
              v343.val[0] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F41C00);
              v343.val[1] = vqtbl2q_s8(v342, v270);
              v339.val[1] = vqtbl2q_s8(v346, v55[190]);
              int8x16_t v277 = vqtbl2q_s8(v342, v56[204]);
              int8x16_t v278 = vqtbl2q_s8(v346, v273);
              v339.val[0] = vqtbl2q_s8(v342, v274);
              unsigned int v51 = v346.val[1].u16[7];
              v346.val[0] = vqtbl2q_s8(v346, v275);
              v346.val[1] = vqtbl2q_s8(v342, v276);
              unsigned int v50 = v342.val[1].u16[7];
              v342.val[1] = vqtbl2q_s8(v346, (int8x16_t)xmmword_228F41B50);
              int8x16_t v44 = vqtbl2q_s8(v339, (int8x16_t)xmmword_228F41B50);
              int8x16_t v45 = vqtbl2q_s8(v347, (int8x16_t)xmmword_228F41B50);
              v345.val[0] = vqtbl2q_s8(v345, (int8x16_t)xmmword_228F41B50);
              v345.val[1] = vqtbl2q_s8(v344, (int8x16_t)xmmword_228F41B50);
              v346.val[1] = v328;
              v347.val[0] = v329;
              v347.val[1] = v335;
              int8x16_t v279 = v336;
              v340.val[0] = vqtbl2q_s8(v340, (int8x16_t)xmmword_228F41B50);
              v340.val[1] = vqtbl2q_s8(v343, (int8x16_t)xmmword_228F41B50);
              v48.i64[0] = 0xFFFFFFFF00000000;
              v48.i64[1] = 0xFFFFFFFF00000000;
              int8x16_t v47 = (int8x16_t)xmmword_228F61DE0;
              int8x16_t v46 = (int8x16_t)xmmword_228F61DD0;
              *(int8x16_t *)(result + 32) = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 48) = vqtbl2q_s8(v349, (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)result = v340.val[0];
              *(int8x16_t *)(result + 16) = vqtbl2q_s8(v350, (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 96) = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v347 + 16), (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 112) = vqtbl2q_s8(v333, (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 64) = vqtbl2q_s8(v331, (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 80) = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v346 + 16), (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 224) = v340.val[1];
              *(int8x16_t *)(result + 240) = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v339 + 16), (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 160) = vqtbl2q_s8(v351, (int8x16_t)xmmword_228F41B50);
              *(int8x16_t *)(result + 176) = v345.val[1];
              *(int8x16_t *)(result + 128) = v345.val[0];
              *(int8x16_t *)(result + 144) = v45;
              *(int8x16_t *)(result + 192) = v44;
              *(int8x16_t *)(result + 208) = v342.val[1];
              int32x4_t v162 = (__int16 *)(result + 256);
              unint64_t v161 = v141 + 32;
              unint64_t v280 = v141 + 64;
              v141 += 32;
              result += 256;
            }
            while (v280 <= v36);
          }
          else
          {
            unint64_t v161 = v141;
            int32x4_t v162 = a11;
          }
          if (v161 + 8 <= v36)
          {
            do
            {
              v44.i64[0] = *(void *)(v39 + v161);
              v45.i64[0] = *(void *)(v327 + v39 + v161);
              int16x8_t v283 = (int16x8_t)vzip1q_s8(v45, v44);
              int8x16_t v284 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v283, 0x10uLL), v283);
              int16x8_t v285 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v284, v46), v48), (int16x8_t)v284);
              int8x16_t v286 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v285.i8, 3), v47);
              int8x16_t v287 = (int8x16_t)vdupq_n_s16(v53);
              int8x16_t v44 = (int8x16_t)vaddq_s16(vaddq_s16(v285, (int16x8_t)v287), (int16x8_t)v286);
              unsigned int v53 = v44.u16[7];
              v286.i64[0] = *(void *)(v41 + v161);
              v287.i64[0] = *(void *)(v326 + v41 + v161);
              int16x8_t v288 = (int16x8_t)vzip1q_s8(v287, v286);
              int8x16_t v289 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v288, 0x10uLL), v288);
              int16x8_t v290 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v289, v46), v48), (int16x8_t)v289);
              int8x16_t v291 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v290.i8, 3), v47);
              int8x16_t v292 = (int8x16_t)vdupq_n_s16(v52);
              int8x16_t v45 = (int8x16_t)vaddq_s16(vaddq_s16(v290, (int16x8_t)v292), (int16x8_t)v291);
              unsigned int v52 = v45.u16[7];
              v291.i64[0] = *(void *)(v43 + v161);
              v292.i64[0] = *(void *)(v325 + v43 + v161);
              int16x8_t v293 = (int16x8_t)vzip1q_s8(v292, v291);
              int8x16_t v294 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v293, 0x10uLL), v293);
              int16x8_t v295 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v294, v46), v48), (int16x8_t)v294);
              int8x16_t v296 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v295.i8, 3), v47);
              int8x16_t v297 = (int8x16_t)vdupq_n_s16(v51);
              int16x8_t v298 = vaddq_s16(vaddq_s16(v295, (int16x8_t)v297), (int16x8_t)v296);
              unsigned int v51 = v298.u16[7];
              v296.i64[0] = *(void *)(v49 + v161);
              v297.i64[0] = *(void *)(v324 + v49 + v161);
              int16x8_t v299 = (int16x8_t)vzip1q_s8(v297, v296);
              int8x16_t v300 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v299, 0x10uLL), v299);
              int16x8_t v301 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v300, v46), v48), (int16x8_t)v300);
              int16x8_t v302 = vaddq_s16(vaddq_s16(v301, vdupq_n_s16(v50)), (int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v301.i8, 3), v47));
              unsigned int v50 = v302.u16[7];
              v341.val[0] = vzip1q_s16((int16x8_t)v44, v298);
              v341.val[1] = vzip1q_s16((int16x8_t)v45, v302);
              uint64_t v282 = v162 + 32;
              vst2q_s16(v162, v341);
              int8x16x2_t v303 = v162 + 16;
              v341.val[0] = vzip2q_s16((int16x8_t)v44, v298);
              v341.val[1] = vzip2q_s16((int16x8_t)v45, v302);
              vst2q_s16(v303, v341);
              unint64_t v281 = v161 + 8;
              result = v161 + 16;
              v161 += 8;
              int32x4_t v162 = v282;
            }
            while (result <= v36);
          }
          else
          {
            unint64_t v281 = v161;
            uint64_t v282 = v162;
          }
          if (v281 < v36)
          {
            uint64_t v304 = 0;
            result = v326 + v281 + v41;
            unint64_t v305 = v324 + v281 + v49;
            unint64_t v306 = v49 + v281;
            do
            {
              v53 += *(unsigned __int8 *)(v327 + v281 + v39 + v304) | (*(unsigned __int8 *)(v39 + v281 + v304) << 8);
              v52 += *(unsigned __int8 *)(result + v304) | (*(unsigned __int8 *)(v41 + v281 + v304) << 8);
              v51 += *(unsigned __int8 *)(v325 + v281 + v43 + v304) | (*(unsigned __int8 *)(v43 + v281 + v304) << 8);
              v50 += *(unsigned __int8 *)(v305 + v304) | (*(unsigned __int8 *)(v306 + v304) << 8);
              LOWORD(v307) = v53;
              WORD1(v307) = v52;
              WORD2(v307) = v51;
              HIWORD(v307) = v50;
              *(void *)&v282[4 * v304++] = v307;
            }
            while (v36 - v281 != v304);
          }
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v33 += a10;
      }
      while (v33 + (unint64_t)a3[7].u32[0] < v321);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<float,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v288 = result;
  if (a9)
  {
    unint64_t v16 = *(void *)(a2 + 56);
    uint64_t v17 = *(ChannelDescription **)(a4 + 8);
    *(int32x2_t *)v372.i8 = a3[3];
    uint64_t v18 = a3[7].u32[1];
    int32x2_t v19 = *(int32x2_t *)((char *)v17 + 48);
    int32x2_t v20 = *(int32x2_t *)(*(void *)(*((void *)v17 + 5) + 8 * v18) + 16);
    uint64_t v285 = v372.u32[0];
    int8x16_t v286 = v17;
    unsigned int v284 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v17, (a3[6].i32[1] + v372.i32[1] * HIDWORD(v16)), v372.u32[0], v18);
    uint64_t v21 = *(ChannelDescription **)(a5 + 8);
    int32x2_t v368 = a3[3];
    uint64_t v22 = a3[7].u32[1];
    int32x2_t v23 = *(int32x2_t *)((char *)v21 + 48);
    int32x2_t v24 = *(int32x2_t *)(*(void *)(*((void *)v21 + 5) + 8 * v22) + 16);
    uint64_t v282 = v368.u32[0];
    int16x8_t v283 = v21;
    unsigned int v281 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v21, (a3[6].i32[1] + v368.i32[1] * HIDWORD(v16)), v368.u32[0], v22);
    int32x2_t v25 = *(ChannelDescription **)(a6 + 8);
    int32x2_t v363 = a3[3];
    uint64_t v26 = a3[7].u32[1];
    int32x2_t v27 = *(int32x2_t *)((char *)v25 + 48);
    int32x2_t v28 = *(int32x2_t *)(*(void *)(*((void *)v25 + 5) + 8 * v26) + 16);
    uint64_t v279 = v363.u32[0];
    unint64_t v280 = v25;
    unsigned int v278 = a3[7].u32[1];
    ChannelDescription::GetLocationForTile(v25, (a3[6].i32[1] + v363.i32[1] * HIDWORD(v16)), v363.u32[0], v26);
    int32x2_t v29 = *(ChannelDescription **)(a7 + 8);
    int32x2_t v358 = a3[3];
    unint64_t v287 = HIDWORD(v16);
    uint64_t v30 = a3[7].u32[1];
    int32x2_t v31 = *(int32x2_t *)((char *)v29 + 48);
    int32x2_t v32 = *(int32x2_t *)(*(void *)(*((void *)v29 + 5) + 8 * v30) + 16);
    uint64_t v276 = v358.u32[0];
    int8x16_t v277 = v29;
    unsigned int v275 = a3[7].u32[1];
    result = ChannelDescription::GetLocationForTile(v29, (a3[6].i32[1] + v358.i32[1] * HIDWORD(v16)), v358.u32[0], v30);
    uint64_t v33 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v33 < HIDWORD(v16))
    {
      int v274 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v34 = a3[5].u32[1];
      uint64_t v296 = vmin_u32((uint32x2_t)vmls_s32(v24, v23, v368), (uint32x2_t)v23).u32[0];
      uint64_t v297 = vmin_u32((uint32x2_t)vmls_s32(v20, v19, *(int32x2_t *)v372.i8), (uint32x2_t)v19).u32[0];
      uint64_t v292 = 2 * v296;
      uint64_t v293 = 2 * v297;
      uint64_t v294 = vmin_u32((uint32x2_t)vmls_s32(v32, v31, v358), (uint32x2_t)v31).u32[0];
      uint64_t v295 = vmin_u32((uint32x2_t)vmls_s32(v28, v27, v363), (uint32x2_t)v27).u32[0];
      uint64_t v290 = 2 * v294;
      uint64_t v291 = 2 * v295;
      unint64_t v35 = v34 + a9;
      do
      {
        uint64_t v298 = v33;
        unint64_t v36 = (v274 + v33);
        unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v286, v36, v285, v284);
        if (HIDWORD(LocationForTile)) {
          unint64_t v38 = v288 + LocationForTile;
        }
        else {
          unint64_t v38 = 0;
        }
        unint64_t v39 = ChannelDescription::GetLocationForTile(v283, v36, v282, v281);
        if (HIDWORD(v39)) {
          unint64_t v40 = v288 + v39;
        }
        else {
          unint64_t v40 = 0;
        }
        unint64_t v41 = ChannelDescription::GetLocationForTile(v280, v36, v279, v278);
        if (HIDWORD(v41)) {
          unint64_t v42 = v288 + v41;
        }
        else {
          unint64_t v42 = 0;
        }
        result = ChannelDescription::GetLocationForTile(v277, v36, v276, v275);
        unint64_t v51 = v288 + result;
        if (!HIDWORD(result)) {
          unint64_t v51 = 0;
        }
        if (v38 && v40 && v42 && v51)
        {
          if (v34 >= 0x20)
          {
            uint64_t v60 = 0;
            unint64_t v61 = v293 + v38;
            uint64_t v62 = v297 + v38;
            unint64_t v63 = v292 + v40;
            v53.i64[0] = 0;
            uint64_t v64 = v296 + v40;
            unint64_t v65 = v291 + v42;
            v49.i64[0] = 0;
            uint64_t v66 = v295 + v42;
            v50.i64[0] = 0;
            unint64_t v67 = v290 + v51;
            v52.i64[0] = 0;
            uint64_t v68 = v294 + v51;
            unint64_t v54 = (int8x16_t *)&unk_228F61000;
            unsigned int v55 = (int8x16_t *)&unk_228F61000;
            unsigned int v56 = (int8x16_t *)&unk_228F61000;
            unsigned int v57 = (int8x16_t *)&unk_228F61000;
            unsigned int v58 = (int8x16_t *)&unk_228F61000;
            uint64_t v59 = (int8x16_t *)&unk_228F61000;
            do
            {
              int32x2_t v359 = *(int32x2_t *)v53.i8;
              int32x2_t v364 = *(int32x2_t *)v49.i8;
              int32x2_t v369 = *(int32x2_t *)v50.i8;
              int32x2_t v373 = *(int32x2_t *)v52.i8;
              v376.val[1] = *(int8x16_t *)(v38 + v60);
              v378.val[1] = *(int8x16_t *)(v38 + v60 + 16);
              int8x16_t v69 = *(int8x16_t *)(v62 + v60);
              int8x16_t v70 = *(int8x16_t *)(v62 + v60 + 16);
              v376.val[0] = *(int8x16_t *)(v61 + v60);
              v378.val[0] = *(int8x16_t *)(v61 + v60 + 16);
              v382.val[0] = vqtbl1q_s8(v70, (int8x16_t)xmmword_228F61DF0);
              v382.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D50);
              v390.val[0] = vqtbl1q_s8(v70, (int8x16_t)xmmword_228F61E00);
              v390.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D90);
              v316.val[0] = vqtbl1q_s8(v69, (int8x16_t)xmmword_228F61DF0);
              v316.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D50);
              v314.val[0] = vqtbl1q_s8(v69, (int8x16_t)xmmword_228F61E10);
              v314.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D70);
              v388.val[0] = vqtbl1q_s8(v69, (int8x16_t)xmmword_228F61E00);
              v388.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D90);
              int8x16_t v357 = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D70);
              int8x16_t v354 = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61DB0);
              v345.val[0] = vqtbl1q_s8(v69, (int8x16_t)xmmword_228F61E20);
              v345.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61DB0);
              v376.val[1] = *(int8x16_t *)(v40 + v60);
              v378.val[1] = *(int8x16_t *)(v40 + v60 + 16);
              v376.val[0] = *(int8x16_t *)(v63 + v60);
              v378.val[0] = *(int8x16_t *)(v63 + v60 + 16);
              int8x16_t v71 = *(int8x16_t *)(v64 + v60 + 16);
              v350.val[0] = vqtbl1q_s8(v71, (int8x16_t)xmmword_228F61DF0);
              v350.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D50);
              int8x16_t v347 = vqtbl1q_s8(v71, (int8x16_t)xmmword_228F61E00);
              int8x16_t v349 = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D90);
              v340.val[0] = vqtbl1q_s8(v71, (int8x16_t)xmmword_228F61E10);
              v340.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D70);
              v335.val[0] = vqtbl1q_s8(v71, (int8x16_t)xmmword_228F61E20);
              v335.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61DB0);
              v378.val[0] = *(int8x16_t *)(v64 + v60);
              int8x16_t v337 = vqtbl1q_s8(v378.val[0], (int8x16_t)xmmword_228F61DF0);
              int8x16_t v339 = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D50);
              int8x16_t v329 = vqtbl1q_s8(v378.val[0], (int8x16_t)xmmword_228F61E10);
              int8x16_t v333 = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D70);
              v327.val[0] = vqtbl1q_s8(v378.val[0], (int8x16_t)xmmword_228F61E00);
              v327.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D90);
              v325.val[0] = vqtbl1q_s8(v378.val[0], (int8x16_t)xmmword_228F61E20);
              v325.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61DB0);
              v378.val[1] = *(int8x16_t *)(v42 + v60);
              v376.val[1] = *(int8x16_t *)(v42 + v60 + 16);
              v378.val[0] = *(int8x16_t *)(v65 + v60);
              v376.val[0] = *(int8x16_t *)(v65 + v60 + 16);
              int8x16_t v72 = *(int8x16_t *)(v66 + v60 + 16);
              int8x16_t v322 = vqtbl1q_s8(v72, (int8x16_t)xmmword_228F61DF0);
              int8x16_t v324 = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D50);
              v320.val[0] = vqtbl1q_s8(v72, (int8x16_t)xmmword_228F61E00);
              v320.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D90);
              v318.val[0] = vqtbl1q_s8(v72, (int8x16_t)xmmword_228F61E10);
              v318.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D70);
              v310.val[0] = vqtbl1q_s8(v72, (int8x16_t)xmmword_228F61E20);
              v310.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61DB0);
              v376.val[0] = *(int8x16_t *)(v66 + v60);
              v312.val[0] = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61DF0);
              v312.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D50);
              int8x16_t v307 = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61E10);
              int8x16_t v309 = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D70);
              v305.val[0] = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61E00);
              v305.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D90);
              v386.val[0] = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61E20);
              v386.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61DB0);
              v378.val[1] = *(int8x16_t *)(v51 + v60);
              v376.val[1] = *(int8x16_t *)(v51 + v60 + 16);
              v378.val[0] = *(int8x16_t *)(v67 + v60);
              v376.val[0] = *(int8x16_t *)(v67 + v60 + 16);
              int8x16_t v73 = *(int8x16_t *)(v68 + v60 + 16);
              int8x16_t v302 = vqtbl1q_s8(v73, (int8x16_t)xmmword_228F61DF0);
              int8x16_t v304 = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D50);
              int8x16_t v300 = vqtbl1q_s8(v73, (int8x16_t)xmmword_228F61E00);
              int8x16_t v301 = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D90);
              v401.val[0] = vqtbl1q_s8(v73, (int8x16_t)xmmword_228F61E10);
              v401.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61D70);
              v398.val[0] = vqtbl1q_s8(v73, (int8x16_t)xmmword_228F61E20);
              v398.val[1] = vqtbl2q_s8(v376, (int8x16_t)xmmword_228F61DB0);
              v376.val[0] = *(int8x16_t *)(v68 + v60);
              v399.val[0] = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61DF0);
              v399.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D50);
              v395.val[0] = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61E10);
              v395.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D70);
              v393.val[0] = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61E00);
              v393.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61D90);
              v396.val[0] = vqtbl1q_s8(v376.val[0], (int8x16_t)xmmword_228F61E20);
              v396.val[1] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61DB0);
              v376.val[0] = vqtbl2q_s8(v345, (int8x16_t)xmmword_228F61DC0);
              v376.val[1] = vqtbl1q_s8(v70, (int8x16_t)xmmword_228F61E20);
              v378.val[0] = v354;
              v376.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v376 + 16), (int8x16_t)xmmword_228F61DC0);
              v378.val[0] = vqtbl1q_s8(v70, (int8x16_t)xmmword_228F61E10);
              v378.val[1] = v357;
              v378.val[0] = vqtbl2q_s8(v378, (int8x16_t)xmmword_228F61DC0);
              v378.val[1] = vqtbl2q_s8(v388, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v74 = (int32x4_t)vqtbl2q_s8(v314, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v75 = (int32x4_t)vqtbl2q_s8(v316, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v76 = (int32x4_t)vqtbl2q_s8(v390, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v77 = (int32x4_t)vqtbl2q_s8(v382, (int8x16_t)xmmword_228F61DC0);
              v390.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v376.val[0], 0x20uLL), (int32x4_t)v376.val[0]);
              int32x4_t v78 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v376.val[1], 0x20uLL), (int32x4_t)v376.val[1]);
              v378.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v378.val[0], 0x20uLL), (int32x4_t)v378.val[0]);
              v378.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v378.val[1], 0x20uLL), (int32x4_t)v378.val[1]);
              v382.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v74, 0x20uLL), v74);
              int32x4_t v79 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v75, 0x20uLL), v75);
              int32x4_t v80 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v76, 0x20uLL), v76);
              int32x4_t v81 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v77, 0x20uLL), v77);
              int32x4_t v82 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v378.val[1].i8, 1), (int32x4_t)v378.val[1]);
              v345.val[0] = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v80.i8, 1), v80);
              int32x4_t v83 = (int32x4_t)vqtbl2q_s8(v325, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v352 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v81.i8, 1), v81);
              v388.val[0] = vqtbl2q_s8(v335, (int8x16_t)xmmword_228F61DC0);
              v388.val[1] = vqtbl2q_s8(v340, (int8x16_t)xmmword_228F61DC0);
              v376.val[0] = vqtbl2q_s8(v327, (int8x16_t)xmmword_228F61DC0);
              v378.val[1] = v329;
              int8x16_t v84 = v333;
              v382.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v378 + 16), (int8x16_t)xmmword_228F61DC0);
              v378.val[1] = v337;
              int8x16_t v85 = v339;
              v376.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v378 + 16), (int8x16_t)xmmword_228F61DC0);
              int32x4_t v355 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v79.i8, 1), v79), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v382.val[1].i8, 1), (int32x4_t)v382.val[1]));
              v378.val[1] = v347;
              int8x16_t v86 = v349;
              v390.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v378 + 16), (int8x16_t)xmmword_228F61DC0);
              int32x4_t v87 = vdupq_lane_s32(*(int32x2_t *)v378.val[0].i8, 1);
              v87.i64[0] = 0;
              int32x4_t v88 = vaddq_s32(v87, (int32x4_t)v378.val[0]);
              int32x4_t v89 = (int32x4_t)vqtbl2q_s8(v350, (int8x16_t)xmmword_228F61DC0);
              v382.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v83, 0x20uLL), v83);
              int32x4_t v90 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v388.val[0], 0x20uLL), (int32x4_t)v388.val[0]);
              v388.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v388.val[1], 0x20uLL), (int32x4_t)v388.val[1]);
              v376.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v376.val[0], 0x20uLL), (int32x4_t)v376.val[0]);
              v382.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v382.val[0], 0x20uLL), (int32x4_t)v382.val[0]);
              v376.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v376.val[1], 0x20uLL), (int32x4_t)v376.val[1]);
              v388.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v78.i8, 1);
              v388.val[1].i64[0] = 0;
              int32x4_t v91 = vaddq_s32((int32x4_t)v388.val[1], v78);
              v390.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v390.val[1], 0x20uLL), (int32x4_t)v390.val[1]);
              int32x4_t v92 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v89, 0x20uLL), v89);
              int32x4_t v93 = vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v376.val[0].i8, 1), (int32x4_t)v376.val[0]);
              v388.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v390.val[0].i8, 1);
              v388.val[1].i64[0] = 0;
              v390.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v388.val[1], (int32x4_t)v390.val[0]);
              v350.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v376.val[1].i8, 1), (int32x4_t)v376.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v382.val[0].i8, 1), (int32x4_t)v382.val[0]));
              v382.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v388.val[0].i8, 1);
              v382.val[0].i64[0] = 0;
              v382.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v382.val[0], (int32x4_t)v388.val[0]);
              v388.val[0] = vqtbl2q_s8(v386, (int8x16_t)xmmword_228F61DC0);
              v388.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v90.i8, 1);
              v388.val[1].i64[0] = 0;
              int32x4_t v94 = vaddq_s32((int32x4_t)v388.val[1], v90);
              v388.val[1] = vqtbl2q_s8(v310, (int8x16_t)xmmword_228F61DC0);
              v376.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v382.val[1].i8, 1);
              v376.val[1].i64[0] = 0;
              v378.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v376.val[1], (int32x4_t)v382.val[1]);
              v382.val[1] = vqtbl2q_s8(v318, (int8x16_t)xmmword_228F61DC0);
              v376.val[0] = vqtbl2q_s8(v305, (int8x16_t)xmmword_228F61DC0);
              v376.val[1] = v307;
              v378.val[0] = v309;
              v376.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v376 + 16), (int8x16_t)xmmword_228F61DC0);
              int32x4_t v95 = (int32x4_t)vqtbl2q_s8(v312, (int8x16_t)xmmword_228F61DC0);
              v378.val[0] = vqtbl2q_s8(v320, (int8x16_t)xmmword_228F61DC0);
              v390.val[0] = (int8x16_t)vaddq_s32(v82, (int32x4_t)v390.val[0]);
              int8x16_t v96 = v322;
              v386.val[0] = v324;
              int32x4_t v97 = (int32x4_t)vqtbl2q_s8(v386, (int8x16_t)xmmword_228F61DC0);
              v386.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v388.val[0], 0x20uLL), (int32x4_t)v388.val[0]);
              v386.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v388.val[1], 0x20uLL), (int32x4_t)v388.val[1]);
              v382.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v382.val[1], 0x20uLL), (int32x4_t)v382.val[1]);
              v376.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v376.val[0], 0x20uLL), (int32x4_t)v376.val[0]);
              v376.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v376.val[1], 0x20uLL), (int32x4_t)v376.val[1]);
              int32x4_t v98 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v95, 0x20uLL), v95);
              v378.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v378.val[0], 0x20uLL), (int32x4_t)v378.val[0]);
              v388.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v382.val[1].i8, 1);
              int32x4_t v99 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v97, 0x20uLL), v97);
              v388.val[1].i64[0] = 0;
              v388.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v386.val[1].i8, 1);
              v388.val[0].i64[0] = 0;
              v386.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v388.val[0], (int32x4_t)v386.val[1]);
              v388.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v386.val[0].i8, 1);
              v388.val[0].i64[0] = 0;
              v378.val[1] = (int8x16_t)vaddq_s32(v93, (int32x4_t)v378.val[1]);
              v396.val[0] = vqtbl2q_s8(v396, (int8x16_t)xmmword_228F61DC0);
              v396.val[1] = vqtbl2q_s8(v398, (int8x16_t)xmmword_228F61DC0);
              v398.val[0] = vqtbl2q_s8(v401, (int8x16_t)xmmword_228F61DC0);
              v393.val[0] = vqtbl2q_s8(v393, (int8x16_t)xmmword_228F61DC0);
              v393.val[1] = vqtbl2q_s8(v395, (int8x16_t)xmmword_228F61DC0);
              v395.val[0] = vqtbl2q_s8(v399, (int8x16_t)xmmword_228F61DC0);
              v398.val[1] = v300;
              v399.val[0] = v301;
              v395.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v398 + 16), (int8x16_t)xmmword_228F61DC0);
              int32x4_t v100 = vaddq_s32(vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v92.i8, 1), v92), 3), (int32x4_t)v382.val[0]), vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v390.val[1].i8, 1), (int32x4_t)v390.val[1]), 3), v94));
              v398.val[1] = v302;
              v399.val[0] = v304;
              v382.val[0] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v398 + 16), (int8x16_t)xmmword_228F61DC0);
              v396.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v396.val[1], 0x20uLL), (int32x4_t)v396.val[1]);
              v378.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v99.i8, 1), v99), 3), vaddq_s32((int32x4_t)v388.val[1], (int32x4_t)v382.val[1])), vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v378.val[0].i8, 1), (int32x4_t)v378.val[0]), 3), (int32x4_t)v386.val[1]));
              v382.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v393.val[0], 0x20uLL), (int32x4_t)v393.val[0]);
              int8x16_t v49 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v395.val[0], 0x20uLL), (int32x4_t)v395.val[0]);
              v382.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v382.val[0], 0x20uLL), (int32x4_t)v382.val[0]);
              int8x16_t v48 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v382.val[0].i8, 1);
              v376.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v376.val[0].i8, 1), (int32x4_t)v376.val[0]), vaddq_s32((int32x4_t)v388.val[0], (int32x4_t)v386.val[0])), vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v98.i8, 1), v98), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v376.val[1].i8, 1), (int32x4_t)v376.val[1])));
              v376.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v395.val[1], 0x20uLL), (int32x4_t)v395.val[1]);
              int32x4_t v53 = vdupq_lane_s32(*(int32x2_t *)v376.val[1].i8, 1);
              int32x4_t v101 = vaddq_s32(vaddq_s32(vaddq_s32(vdupq_laneq_s32(v352, 3), v88), vaddq_s32(vdupq_laneq_s32((int32x4_t)v345.val[0], 3), v91)), vaddq_s32((int32x4_t)v390.val[0], v355));
              v390.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v393.val[1], 0x20uLL), (int32x4_t)v393.val[1]);
              int8x16_t v50 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v390.val[0].i8, 1);
              v378.val[1] = (int8x16_t)vaddq_s32(v100, vaddq_s32((int32x4_t)v378.val[1], (int32x4_t)v350.val[0]));
              int32x4_t v102 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v398.val[0], 0x20uLL), (int32x4_t)v398.val[0]);
              v398.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v102.i8, 1);
              v399.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v396.val[1].i8, 1);
              v376.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v378.val[0], (int32x4_t)v376.val[0]);
              v378.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v396.val[0], 0x20uLL), (int32x4_t)v396.val[0]);
              int32x4_t v52 = vdupq_lane_s32(*(int32x2_t *)v378.val[0].i8, 1);
              v52.i64[0] = 0;
              v399.val[0].i64[0] = 0;
              v398.val[0].i64[0] = 0;
              v376.val[1] = (int8x16_t)vdupq_laneq_s32(vaddq_s32(v53, (int32x4_t)v376.val[1]), 3);
              v53.i32[0] = vaddq_s32(v101, vdupq_lane_s32(v359, 0)).i32[3];
              int8x16_t v47 = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v49.i8, 1), (int32x4_t)v49), vaddq_s32((int32x4_t)v50, (int32x4_t)v390.val[0]));
              int8x16_t v46 = (int8x16_t)vaddq_s32(vdupq_laneq_s32(vaddq_s32((int32x4_t)v48, (int32x4_t)v382.val[0]), 3), vaddq_s32((int32x4_t)v398.val[0], v102));
              v49.i32[0] = vaddq_s32(*(int32x4_t *)(&v378 + 16), vdupq_lane_s32(v364, 0)).i32[3];
              int8x16_t v44 = (int8x16_t)vaddq_s32((int32x4_t)v46, vaddq_s32((int32x4_t)v376.val[1], vaddq_s32((int32x4_t)v399.val[0], (int32x4_t)v396.val[1])));
              int8x16_t v45 = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v382.val[1].i8, 1), (int32x4_t)v382.val[1]), vaddq_s32(v52, (int32x4_t)v378.val[0])), (int32x4_t)v47);
              result = v60 + 32;
              v50.i32[0] = vaddq_s32(*(int32x4_t *)&v376, vdupq_lane_s32(v369, 0)).i32[3];
              unint64_t v103 = v60 + 64;
              int8x16_t v43 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v44, (int32x4_t)v45), vdupq_lane_s32(v373, 0));
              v60 += 32;
              v52.i32[0] = v43.i32[3];
            }
            while (v103 <= v34);
          }
          else
          {
            result = 0;
            v52.i64[0] = 0;
            v50.i64[0] = 0;
            v49.i64[0] = 0;
            v53.i64[0] = 0;
            unint64_t v54 = (int8x16_t *)&unk_228F61000;
            unsigned int v55 = (int8x16_t *)&unk_228F61000;
            unsigned int v56 = (int8x16_t *)&unk_228F61000;
            unsigned int v57 = (int8x16_t *)&unk_228F61000;
            unsigned int v58 = (int8x16_t *)&unk_228F61000;
            uint64_t v59 = (int8x16_t *)&unk_228F61000;
          }
          if ((result | 8) <= v34)
          {
            int8x16_t v47 = 0uLL;
            do
            {
              v43.i64[0] = *(void *)(v38 + result);
              v44.i64[0] = *(void *)(v297 + v38 + result);
              v45.i64[0] = *(void *)(v293 + v38 + result);
              int8x16_t v105 = vzip1q_s8((int8x16_t)0, v44);
              int8x16_t v106 = vzip1q_s8(v45, v43);
              int32x4_t v107 = (int32x4_t)vzip1q_s8(v105, v106);
              int32x4_t v108 = (int32x4_t)vzip2q_s8(v105, v106);
              int8x16_t v109 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v107, 0x20uLL), v107);
              int32x4_t v110 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v108, 0x20uLL), v108);
              int8x16_t v111 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v110.i8, 1);
              int8x16_t v46 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v53.i8, 0);
              __int32 v112 = vaddq_s32(*(int32x4_t *)&v111, vaddq_s32(v110, *(int32x4_t *)&v46)).i32[3];
              int8x16_t v113 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v109.i8, 1), (int32x4_t)v109);
              v113.i64[0] = *(void *)(v40 + result);
              v53.i32[0] = v112 + v113.i32[3];
              v111.i64[0] = *(void *)(v296 + v40 + result);
              v109.i64[0] = *(void *)(v292 + v40 + result);
              int8x16_t v114 = vzip1q_s8((int8x16_t)0, v111);
              int8x16_t v115 = vzip1q_s8(v109, v113);
              int32x4_t v116 = (int32x4_t)vzip1q_s8(v114, v115);
              int32x4_t v117 = (int32x4_t)vzip2q_s8(v114, v115);
              int32x4_t v118 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v116, 0x20uLL), v116);
              int32x4_t v119 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v117, 0x20uLL), v117);
              int8x16_t v120 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v119.i8, 1);
              int8x16_t v121 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v118.i8, 1), v118);
              int8x16_t v122 = (int8x16_t)vaddq_s32((int32x4_t)v120, vaddq_s32(v119, vdupq_lane_s32(*(int32x2_t *)v49.i8, 0)));
              v122.i64[0] = *(void *)(v42 + result);
              v120.i64[0] = *(void *)(v295 + v42 + result);
              int v123 = v122.i32[3] + v121.i32[3];
              v121.i64[0] = *(void *)(v291 + v42 + result);
              int8x16_t v124 = vzip1q_s8((int8x16_t)0, v120);
              int8x16_t v125 = vzip1q_s8(v121, v122);
              int32x4_t v126 = (int32x4_t)vzip1q_s8(v124, v125);
              int32x4_t v127 = (int32x4_t)vzip2q_s8(v124, v125);
              int32x4_t v128 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v127, 0x20uLL), v127);
              int8x16_t v129 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v128.i8, 1);
              int32x4_t v130 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v126, 0x20uLL), v126);
              int8x16_t v131 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v130.i8, 1), v130);
              int8x16_t v132 = (int8x16_t)vaddq_s32((int32x4_t)v129, vaddq_s32(v128, vdupq_lane_s32(*(int32x2_t *)v50.i8, 0)));
              v49.i32[0] = v123;
              v132.i64[0] = *(void *)(v51 + result);
              v129.i64[0] = *(void *)(v294 + v51 + result);
              v50.i32[0] = v132.i32[3] + v131.i32[3];
              v131.i64[0] = *(void *)(v290 + v51 + result);
              int8x16_t v133 = vzip1q_s8((int8x16_t)0, v129);
              int8x16_t v134 = vzip1q_s8(v131, v132);
              int32x4_t v135 = (int32x4_t)vzip1q_s8(v133, v134);
              int32x4_t v136 = (int32x4_t)vzip2q_s8(v133, v134);
              int32x4_t v137 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v136, 0x20uLL), v136);
              int8x16_t v44 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v137.i8, 1);
              int32x4_t v138 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v135, 0x20uLL), v135);
              int8x16_t v45 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v138.i8, 1), v138);
              int8x16_t v43 = (int8x16_t)vaddq_s32((int32x4_t)v44, vaddq_s32(v137, vdupq_lane_s32(*(int32x2_t *)v52.i8, 0)));
              v52.i32[0] = v43.i32[3] + v45.i32[3];
              unint64_t v104 = result + 8;
              unint64_t v139 = result + 16;
              result += 8;
            }
            while (v139 <= v34);
          }
          else
          {
            unint64_t v104 = result;
          }
          if (v104 <= v34) {
            unint64_t v140 = v34;
          }
          else {
            unint64_t v140 = v104;
          }
          if (v140 + 32 <= v35)
          {
            unint64_t v143 = v293 + v38;
            uint64_t v144 = v297 + v38;
            unint64_t v145 = v292 + v40;
            uint64_t v146 = v296 + v40;
            unint64_t v147 = v291 + v42;
            uint64_t v148 = v295 + v42;
            unint64_t v149 = v290 + v51;
            uint64_t v150 = v294 + v51;
            result = (unint64_t)a11;
            do
            {
              int32x2_t v360 = *(int32x2_t *)v53.i8;
              int32x2_t v365 = *(int32x2_t *)v49.i8;
              int32x2_t v370 = *(int32x2_t *)v50.i8;
              int32x2_t v374 = *(int32x2_t *)v52.i8;
              v377.val[1] = *(int8x16_t *)(v38 + v140);
              v379.val[1] = *(int8x16_t *)(v38 + v140 + 16);
              int8x16_t v152 = *(int8x16_t *)(v144 + v140);
              int8x16_t v151 = *(int8x16_t *)(v144 + v140 + 16);
              int8x16_t v153 = v54[226];
              v377.val[0] = *(int8x16_t *)(v143 + v140);
              v379.val[0] = *(int8x16_t *)(v143 + v140 + 16);
              int8x16_t v154 = v55[219];
              v356.val[0] = vqtbl1q_s8(v152, v153);
              v356.val[1] = vqtbl2q_s8(v377, v154);
              int8x16_t v155 = v56[225];
              v385.val[0] = vqtbl1q_s8(v152, v155);
              int8x16_t v156 = v57[215];
              v385.val[1] = vqtbl2q_s8(v377, v156);
              v387.val[0] = vqtbl1q_s8(v151, v153);
              v387.val[1] = vqtbl2q_s8(v379, v154);
              v400.val[0] = vqtbl1q_s8(v151, v155);
              v400.val[1] = vqtbl2q_s8(v379, v156);
              int8x16_t v157 = v58[223];
              v389.val[0] = vqtbl1q_s8(v151, v157);
              int8x16_t v158 = v59[213];
              v389.val[1] = vqtbl2q_s8(v379, v158);
              v353.val[0] = vqtbl1q_s8(v151, (int8x16_t)xmmword_228F61E00);
              v353.val[1] = vqtbl2q_s8(v379, (int8x16_t)xmmword_228F61D90);
              v351.val[0] = vqtbl1q_s8(v152, v157);
              v351.val[1] = vqtbl2q_s8(v377, v158);
              v348.val[0] = vqtbl1q_s8(v152, (int8x16_t)xmmword_228F61E00);
              v348.val[1] = vqtbl2q_s8(v377, (int8x16_t)xmmword_228F61D90);
              v377.val[1] = *(int8x16_t *)(v40 + v140);
              v379.val[1] = *(int8x16_t *)(v40 + v140 + 16);
              v377.val[0] = *(int8x16_t *)(v145 + v140);
              v379.val[0] = *(int8x16_t *)(v145 + v140 + 16);
              int8x16_t v160 = *(int8x16_t *)(v146 + v140);
              int8x16_t v159 = *(int8x16_t *)(v146 + v140 + 16);
              v346.val[0] = vqtbl1q_s8(v159, v153);
              v346.val[1] = vqtbl2q_s8(v379, v154);
              int8x16_t v341 = vqtbl1q_s8(v159, v155);
              int8x16_t v344 = vqtbl2q_s8(v379, v156);
              v338.val[0] = vqtbl1q_s8(v159, v157);
              v338.val[1] = vqtbl2q_s8(v379, v158);
              int8x16_t v330 = vqtbl1q_s8(v159, (int8x16_t)xmmword_228F61E00);
              int8x16_t v334 = vqtbl2q_s8(v379, (int8x16_t)xmmword_228F61D90);
              v336.val[0] = vqtbl1q_s8(v160, v153);
              v336.val[1] = vqtbl2q_s8(v377, v154);
              v328.val[0] = vqtbl1q_s8(v160, v155);
              v328.val[1] = vqtbl2q_s8(v377, v156);
              v326.val[0] = vqtbl1q_s8(v160, v157);
              v326.val[1] = vqtbl2q_s8(v377, v158);
              v323.val[0] = vqtbl1q_s8(v160, (int8x16_t)xmmword_228F61E00);
              v323.val[1] = vqtbl2q_s8(v377, (int8x16_t)xmmword_228F61D90);
              v379.val[1] = *(int8x16_t *)(v42 + v140);
              v377.val[1] = *(int8x16_t *)(v42 + v140 + 16);
              v379.val[0] = *(int8x16_t *)(v147 + v140);
              v377.val[0] = *(int8x16_t *)(v147 + v140 + 16);
              int8x16_t v162 = *(int8x16_t *)(v148 + v140);
              int8x16_t v161 = *(int8x16_t *)(v148 + v140 + 16);
              v321.val[0] = vqtbl1q_s8(v161, v153);
              v321.val[1] = vqtbl2q_s8(v377, v154);
              v319.val[0] = vqtbl1q_s8(v161, v155);
              v319.val[1] = vqtbl2q_s8(v377, v156);
              v317.val[0] = vqtbl1q_s8(v161, v157);
              v317.val[1] = vqtbl2q_s8(v377, v158);
              v313.val[0] = vqtbl1q_s8(v161, (int8x16_t)xmmword_228F61E00);
              v313.val[1] = vqtbl2q_s8(v377, (int8x16_t)xmmword_228F61D90);
              v315.val[0] = vqtbl1q_s8(v162, v153);
              v315.val[1] = vqtbl2q_s8(v379, v154);
              v311.val[0] = vqtbl1q_s8(v162, v155);
              v311.val[1] = vqtbl2q_s8(v379, v156);
              v308.val[0] = vqtbl1q_s8(v162, v157);
              v308.val[1] = vqtbl2q_s8(v379, v158);
              v306.val[0] = vqtbl1q_s8(v162, (int8x16_t)xmmword_228F61E00);
              v306.val[1] = vqtbl2q_s8(v379, (int8x16_t)xmmword_228F61D90);
              v381.val[1] = *(int8x16_t *)(v51 + v140);
              v379.val[1] = *(int8x16_t *)(v51 + v140 + 16);
              v381.val[0] = *(int8x16_t *)(v149 + v140);
              v379.val[0] = *(int8x16_t *)(v149 + v140 + 16);
              v377.val[1] = *(int8x16_t *)(v150 + v140);
              v377.val[0] = *(int8x16_t *)(v150 + v140 + 16);
              v384.val[0] = vqtbl1q_s8(v377.val[0], v153);
              v384.val[1] = vqtbl2q_s8(v379, v154);
              v397.val[0] = vqtbl1q_s8(v377.val[0], v155);
              v397.val[1] = vqtbl2q_s8(v379, v156);
              v394.val[0] = vqtbl1q_s8(v377.val[0], v157);
              v394.val[1] = vqtbl2q_s8(v379, v158);
              v383.val[0] = vqtbl1q_s8(v377.val[0], (int8x16_t)xmmword_228F61E00);
              v383.val[1] = vqtbl2q_s8(v379, (int8x16_t)xmmword_228F61D90);
              v392.val[0] = vqtbl1q_s8(v377.val[1], v153);
              v392.val[1] = vqtbl2q_s8(v381, v154);
              v391.val[0] = vqtbl1q_s8(v377.val[1], v155);
              v391.val[1] = vqtbl2q_s8(v381, v156);
              v379.val[0] = vqtbl1q_s8(v377.val[1], v157);
              v379.val[1] = vqtbl2q_s8(v381, v158);
              v377.val[0] = vqtbl1q_s8(v377.val[1], (int8x16_t)xmmword_228F61E00);
              v377.val[1] = vqtbl2q_s8(v381, (int8x16_t)xmmword_228F61D90);
              v381.val[1] = vqtbl2q_s8(v348, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v163 = (int32x4_t)vqtbl2q_s8(v351, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v164 = (int32x4_t)vqtbl2q_s8(v353, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v165 = (int32x4_t)vqtbl2q_s8(v389, (int8x16_t)xmmword_228F61DC0);
              v400.val[1] = vqtbl2q_s8(v400, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v166 = (int32x4_t)vqtbl2q_s8(v387, (int8x16_t)xmmword_228F61DC0);
              v400.val[0] = vqtbl2q_s8(v385, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v167 = (int32x4_t)vqtbl2q_s8(v356, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v168 = (int32x4_t)vqtbl2q_s8(v323, (int8x16_t)xmmword_228F61DC0);
              v385.val[0] = vqtbl2q_s8(v326, (int8x16_t)xmmword_228F61DC0);
              v385.val[1] = v330;
              v387.val[0] = v334;
              v385.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v385 + 16), (int8x16_t)xmmword_228F61DC0);
              v387.val[0] = vqtbl2q_s8(v338, (int8x16_t)xmmword_228F61DC0);
              v387.val[1] = v341;
              v389.val[0] = v344;
              v387.val[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v387 + 16), (int8x16_t)xmmword_228F61DC0);
              int32x4_t v303 = (int32x4_t)vqtbl2q_s8(v346, (int8x16_t)xmmword_228F61DC0);
              v328.val[0] = vqtbl2q_s8(v328, (int8x16_t)xmmword_228F61DC0);
              v356.val[0] = vqtbl2q_s8(v336, (int8x16_t)xmmword_228F61DC0);
              v306.val[0] = vqtbl2q_s8(v306, (int8x16_t)xmmword_228F61DC0);
              v323.val[0] = vqtbl2q_s8(v308, (int8x16_t)xmmword_228F61DC0);
              v326.val[0] = vqtbl2q_s8(v313, (int8x16_t)xmmword_228F61DC0);
              v338.val[0] = vqtbl2q_s8(v317, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v342 = (int32x4_t)vqtbl2q_s8(v319, (int8x16_t)xmmword_228F61DC0);
              v346.val[0] = vqtbl2q_s8(v321, (int8x16_t)xmmword_228F61DC0);
              v348.val[0] = vqtbl2q_s8(v311, (int8x16_t)xmmword_228F61DC0);
              v389.val[1] = vqtbl2q_s8(v315, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v331 = (int32x4_t)vqtbl2q_s8(v377, (int8x16_t)xmmword_228F61DC0);
              v379.val[1] = vqtbl2q_s8(v379, (int8x16_t)xmmword_228F61DC0);
              v383.val[0] = vqtbl2q_s8(v383, (int8x16_t)xmmword_228F61DC0);
              v383.val[1] = vqtbl2q_s8(v394, (int8x16_t)xmmword_228F61DC0);
              v397.val[0] = vqtbl2q_s8(v397, (int8x16_t)xmmword_228F61DC0);
              v384.val[0] = vqtbl2q_s8(v384, (int8x16_t)xmmword_228F61DC0);
              v351.val[0] = vqtbl2q_s8(v391, (int8x16_t)xmmword_228F61DC0);
              v336.val[0] = vqtbl2q_s8(v392, (int8x16_t)xmmword_228F61DC0);
              v381.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v381.val[1], 0x20uLL), (int32x4_t)v381.val[1]);
              v381.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v163, 0x20uLL), v163);
              v391.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v164, 0x20uLL), v164);
              v391.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v165, 0x20uLL), v165);
              v392.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v400.val[1], 0x20uLL), (int32x4_t)v400.val[1]);
              v392.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v166, 0x20uLL), v166);
              v394.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v400.val[0], 0x20uLL), (int32x4_t)v400.val[0]);
              v394.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v167, 0x20uLL), v167);
              int32x4_t v169 = vdupq_lane_s32(*(int32x2_t *)v394.val[0].i8, 1);
              v169.i64[0] = 0;
              v397.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v394.val[1].i8, 1);
              v397.val[1].i64[0] = 0;
              v394.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v397.val[1], (int32x4_t)v394.val[1]);
              v394.val[0] = (int8x16_t)vaddq_s32(v169, (int32x4_t)v394.val[0]);
              int32x4_t v170 = vdupq_lane_s32(*(int32x2_t *)v392.val[1].i8, 1);
              v170.i64[0] = 0;
              v392.val[1] = (int8x16_t)vaddq_s32(v170, (int32x4_t)v392.val[1]);
              int32x4_t v171 = vdupq_lane_s32(*(int32x2_t *)v392.val[0].i8, 1);
              v171.i64[0] = 0;
              v392.val[0] = (int8x16_t)vaddq_s32(v171, (int32x4_t)v392.val[0]);
              int32x4_t v172 = vdupq_lane_s32(*(int32x2_t *)v391.val[1].i8, 1);
              v172.i64[0] = 0;
              v397.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v391.val[0].i8, 1);
              v391.val[1] = (int8x16_t)vaddq_s32(v172, (int32x4_t)v391.val[1]);
              v397.val[1].i64[0] = 0;
              int32x4_t v173 = vaddq_s32((int32x4_t)v397.val[1], (int32x4_t)v391.val[0]);
              v391.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v381.val[0].i8, 1);
              v391.val[0].i64[0] = 0;
              int32x4_t v174 = vdupq_lane_s32(*(int32x2_t *)v381.val[1].i8, 1);
              v174.i64[0] = 0;
              v397.val[1] = (int8x16_t)vaddq_s32(v174, (int32x4_t)v381.val[1]);
              v353.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v391.val[0], (int32x4_t)v381.val[0]);
              v381.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v168, 0x20uLL), v168);
              v391.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v385.val[0], 0x20uLL), (int32x4_t)v385.val[0]);
              int32x4_t v175 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v385.val[1], 0x20uLL), (int32x4_t)v385.val[1]);
              int32x4_t v176 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v387.val[0], 0x20uLL), (int32x4_t)v387.val[0]);
              int32x4_t v177 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v387.val[1], 0x20uLL), (int32x4_t)v387.val[1]);
              v400.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v303, 0x20uLL), v303);
              v400.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v328.val[0], 0x20uLL), (int32x4_t)v328.val[0]);
              int32x4_t v178 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v356.val[0], 0x20uLL), (int32x4_t)v356.val[0]);
              v381.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v173, 3), (int32x4_t)v392.val[1]);
              v392.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v178.i8, 1);
              v392.val[1].i64[0] = 0;
              v384.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v400.val[1].i8, 1);
              v392.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v392.val[1], v178);
              v384.val[1].i64[0] = 0;
              v400.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v384.val[1], (int32x4_t)v400.val[1]);
              int32x4_t v179 = vdupq_lane_s32(*(int32x2_t *)v400.val[0].i8, 1);
              v179.i64[0] = 0;
              int32x4_t v180 = vaddq_s32(v179, (int32x4_t)v400.val[0]);
              v385.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v397.val[1], 3), (int32x4_t)v394.val[0]);
              v394.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v177.i8, 1);
              v394.val[0].i64[0] = 0;
              v400.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v176.i8, 1);
              v394.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v394.val[0], v177);
              v400.val[0].i64[0] = 0;
              int32x4_t v181 = vaddq_s32((int32x4_t)v400.val[0], v176);
              int32x4_t v182 = vdupq_lane_s32(*(int32x2_t *)v175.i8, 1);
              v182.i64[0] = 0;
              v356.val[0] = (int8x16_t)vaddq_s32(v182, v175);
              int32x4_t v183 = vaddq_s32(vdupq_laneq_s32((int32x4_t)v353.val[0], 3), (int32x4_t)v394.val[1]);
              v394.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v391.val[0].i8, 1);
              v394.val[1].i64[0] = 0;
              int32x4_t v184 = vdupq_lane_s32(*(int32x2_t *)v381.val[1].i8, 1);
              v385.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v394.val[1], (int32x4_t)v391.val[0]);
              v184.i64[0] = 0;
              v384.val[1] = (int8x16_t)vaddq_s32(v184, (int32x4_t)v381.val[1]);
              int32x4_t v185 = vaddq_s32(vdupq_laneq_s32(v181, 3), (int32x4_t)v394.val[0]);
              v328.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v356.val[0], 3), v180);
              v387.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v385.val[1], 3), (int32x4_t)v400.val[1]);
              v394.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v306.val[0], 0x20uLL), (int32x4_t)v306.val[0]);
              v400.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v323.val[0], 0x20uLL), (int32x4_t)v323.val[0]);
              v391.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v326.val[0], 0x20uLL), (int32x4_t)v326.val[0]);
              int32x4_t v186 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v338.val[0], 0x20uLL), (int32x4_t)v338.val[0]);
              v387.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v342, 0x20uLL), v342);
              v389.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v346.val[0], 0x20uLL), (int32x4_t)v346.val[0]);
              v394.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v389.val[1], 0x20uLL), (int32x4_t)v389.val[1]);
              v377.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v394.val[0].i8, 1);
              v389.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v348.val[0], 0x20uLL), (int32x4_t)v348.val[0]);
              v377.val[0].i64[0] = 0;
              v379.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v377.val[0], (int32x4_t)v394.val[0]);
              v394.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v389.val[1].i8, 1);
              v394.val[0].i64[0] = 0;
              v389.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v394.val[0], (int32x4_t)v389.val[1]);
              v394.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v384.val[1], 3), (int32x4_t)v392.val[1]);
              v392.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v389.val[0].i8, 1);
              v392.val[1].i64[0] = 0;
              v377.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v387.val[1].i8, 1);
              v389.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v392.val[1], (int32x4_t)v389.val[0]);
              v377.val[0].i64[0] = 0;
              v377.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v377.val[0], (int32x4_t)v387.val[1]);
              v392.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v391.val[0].i8, 1);
              v392.val[1].i64[0] = 0;
              v387.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v186.i8, 1);
              v387.val[1].i64[0] = 0;
              v387.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v387.val[1], v186);
              v338.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v392.val[1], (int32x4_t)v391.val[0]);
              v392.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v381.val[0], 3);
              int32x4_t v187 = (int32x4_t)v381.val[0];
              v346.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v391.val[1], 3), (int32x4_t)v392.val[0]), (int32x4_t)v392.val[1]);
              v348.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v391.val[1], (int32x4_t)v392.val[1]);
              v392.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v400.val[1].i8, 1);
              v392.val[1].i64[0] = 0;
              int32x4_t v188 = vdupq_laneq_s32(v183, 3);
              v400.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v392.val[1], (int32x4_t)v400.val[1]);
              int32x4_t v343 = vaddq_s32((int32x4_t)v385.val[0], v188);
              v392.val[1] = (int8x16_t)vdupq_lane_s32(v360, 0);
              v397.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v397.val[1], (int32x4_t)v392.val[1]), v188);
              int32x4_t v189 = vdupq_lane_s32(*(int32x2_t *)v394.val[1].i8, 1);
              v189.i64[0] = 0;
              int32x4_t v190 = vaddq_s32(v189, (int32x4_t)v394.val[1]);
              v391.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v387.val[1], 3), (int32x4_t)v377.val[1]);
              v394.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v338.val[0], 3), (int32x4_t)v389.val[0]);
              v392.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v400.val[1], 3), (int32x4_t)v389.val[1]);
              v381.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32(v190, 3), (int32x4_t)v379.val[0]);
              v389.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v331, 0x20uLL), v331);
              v379.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v379.val[1], 0x20uLL), (int32x4_t)v379.val[1]);
              v383.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v383.val[0], 0x20uLL), (int32x4_t)v383.val[0]);
              v389.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v383.val[1], 0x20uLL), (int32x4_t)v383.val[1]);
              v397.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v397.val[0], 0x20uLL), (int32x4_t)v397.val[0]);
              v384.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v384.val[0], 0x20uLL), (int32x4_t)v384.val[0]);
              v383.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v336.val[0], 0x20uLL), (int32x4_t)v336.val[0]);
              v377.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v383.val[1].i8, 1);
              v377.val[0].i64[0] = 0;
              v391.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v351.val[0], 0x20uLL), (int32x4_t)v351.val[0]);
              v379.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v377.val[0], (int32x4_t)v383.val[1]);
              v383.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v328.val[0], 3);
              v351.val[0] = (int8x16_t)vaddq_s32(v185, (int32x4_t)v383.val[1]);
              int32x4_t v361 = vaddq_s32(v181, (int32x4_t)v383.val[1]);
              v383.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v391.val[1].i8, 1);
              v383.val[1].i64[0] = 0;
              v377.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v394.val[0], 3);
              v391.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v383.val[1], (int32x4_t)v391.val[1]);
              v336.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v387.val[0], (int32x4_t)v377.val[0]);
              v387.val[0] = (int8x16_t)vdupq_lane_s32(v365, 0);
              v381.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v385.val[1], (int32x4_t)v387.val[0]), (int32x4_t)v377.val[0]);
              v385.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v384.val[0].i8, 1);
              v385.val[1].i64[0] = 0;
              v377.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v397.val[0].i8, 1);
              v384.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v385.val[1], (int32x4_t)v384.val[0]);
              v377.val[0].i64[0] = 0;
              v377.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v377.val[0], (int32x4_t)v397.val[0]);
              v397.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v383.val[0].i8, 1);
              v397.val[0].i64[0] = 0;
              v385.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v389.val[1].i8, 1);
              v385.val[1].i64[0] = 0;
              v385.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v385.val[1], (int32x4_t)v389.val[1]);
              v383.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v397.val[0], (int32x4_t)v383.val[0]);
              v397.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v394.val[1], 3);
              v400.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v391.val[0], (int32x4_t)v397.val[0]);
              int32x4_t v366 = vaddq_s32((int32x4_t)v387.val[1], (int32x4_t)v397.val[0]);
              v397.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v379.val[1].i8, 1);
              v397.val[0].i64[0] = 0;
              v389.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v381.val[0], 3);
              v379.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v397.val[0], (int32x4_t)v379.val[1]);
              v397.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v392.val[0], (int32x4_t)v389.val[1]);
              v391.val[0] = (int8x16_t)vdupq_lane_s32(v370, 0);
              v400.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v400.val[1], (int32x4_t)v391.val[0]), (int32x4_t)v389.val[1]);
              v389.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v389.val[0].i8, 1);
              v389.val[1].i64[0] = 0;
              v392.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v389.val[1], (int32x4_t)v389.val[0]);
              v384.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v383.val[1], 3), (int32x4_t)v384.val[0]);
              v389.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v384.val[0], 3);
              v379.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v392.val[0], 3), (int32x4_t)v379.val[0]);
              v385.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v385.val[1], 3), (int32x4_t)v377.val[1]), (int32x4_t)v389.val[0]);
              int32x4_t v332 = vaddq_s32((int32x4_t)v385.val[1], (int32x4_t)v389.val[0]);
              int32x4_t v191 = vaddq_s32(v183, (int32x4_t)v392.val[1]);
              v381.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v381.val[0], (int32x4_t)v391.val[0]);
              v385.val[1] = (int8x16_t)vzip2q_s32(v191, (int32x4_t)v381.val[0]);
              int32x4_t v371 = vzip1q_s32(v191, (int32x4_t)v381.val[0]);
              int32x4_t v192 = vaddq_s32((int32x4_t)v353.val[0], (int32x4_t)v392.val[1]);
              int32x4_t v193 = vaddq_s32(v190, (int32x4_t)v391.val[0]);
              v389.val[0] = (int8x16_t)vzip2q_s32(v192, v193);
              v389.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v379.val[0], 3);
              int32x4_t v194 = vzip1q_s32(v192, v193);
              v383.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v379.val[1], 3), (int32x4_t)v391.val[1]), (int32x4_t)v389.val[1]);
              int32x4_t v195 = vdupq_lane_s32(v374, 0);
              v379.val[1] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v379.val[1], v195), (int32x4_t)v389.val[1]);
              v394.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v394.val[0], (int32x4_t)v387.val[0]);
              v379.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v379.val[0], v195);
              v389.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v394.val[0], (int32x4_t)v379.val[0]);
              v394.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v394.val[0], (int32x4_t)v379.val[0]);
              v387.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v397.val[1], (int32x4_t)v400.val[1]);
              v397.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v397.val[1], (int32x4_t)v400.val[1]);
              v400.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v384.val[1], (int32x4_t)v387.val[0]);
              v392.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v392.val[0], v195);
              v384.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v400.val[1], (int32x4_t)v392.val[0]);
              v392.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v400.val[1], (int32x4_t)v392.val[0]);
              v400.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v381.val[1], (int32x4_t)v379.val[1]);
              v379.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v381.val[1], (int32x4_t)v379.val[1]);
              int32x4_t v196 = vaddq_s32((int32x4_t)v346.val[0], (int32x4_t)v392.val[1]);
              int32x4_t v197 = vaddq_s32(v173, (int32x4_t)v392.val[1]);
              int32x4_t v198 = vaddq_s32(v187, (int32x4_t)v392.val[1]);
              int32x4_t v199 = vaddq_s32((int32x4_t)v348.val[0], (int32x4_t)v392.val[1]);
              v392.val[1] = (int8x16_t)vaddq_s32(v343, (int32x4_t)v392.val[1]);
              v353.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v400.val[0], (int32x4_t)v391.val[0]);
              int32x4_t v375 = vaddq_s32((int32x4_t)v338.val[0], (int32x4_t)v391.val[0]);
              v348.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v394.val[1], (int32x4_t)v391.val[0]);
              int32x4_t v367 = vaddq_s32(v366, (int32x4_t)v391.val[0]);
              v391.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v397.val[0], (int32x4_t)v391.val[0]);
              v400.val[0] = v397.val[0];
              v377.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v392.val[1], (int32x4_t)v391.val[0]);
              v391.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v392.val[1], (int32x4_t)v391.val[0]);
              v392.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v351.val[0], (int32x4_t)v387.val[0]);
              v391.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v356.val[0], (int32x4_t)v387.val[0]);
              v381.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v328.val[0], (int32x4_t)v387.val[0]);
              v394.val[1] = (int8x16_t)vaddq_s32(v361, (int32x4_t)v387.val[0]);
              v387.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v336.val[0], (int32x4_t)v387.val[0]);
              v385.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v385.val[0], v195);
              int32x4_t v362 = vaddq_s32((int32x4_t)v383.val[1], v195);
              v384.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v384.val[0], v195);
              v397.val[0] = (int8x16_t)vaddq_s32(v332, v195);
              int32x4_t v200 = vaddq_s32((int32x4_t)v383.val[0], v195);
              v377.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v387.val[0], v200);
              int32x4_t v201 = vzip1q_s32((int32x4_t)v387.val[0], v200);
              v387.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v385.val[1], (int32x4_t)v389.val[1]);
              v385.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v385.val[1], (int32x4_t)v389.val[1]);
              v389.val[1] = (int8x16_t)vzip2q_s32(v194, (int32x4_t)v392.val[0]);
              v392.val[0] = (int8x16_t)vzip1q_s32(v194, (int32x4_t)v392.val[0]);
              int32x4_t v202 = vzip2q_s32((int32x4_t)v397.val[1], (int32x4_t)v379.val[1]);
              v379.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v397.val[1], (int32x4_t)v379.val[1]);
              *(int32x4_t *)(result + 32) = vzip1q_s32((int32x4_t)v389.val[0], (int32x4_t)v384.val[1]);
              *(int32x4_t *)(result + 48) = vzip2q_s32((int32x4_t)v389.val[0], (int32x4_t)v384.val[1]);
              v397.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v391.val[0], v201);
              v391.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v391.val[0], v201);
              *(int8x16_t *)result = v392.val[0];
              *(int8x16_t *)(result + 16) = v389.val[1];
              *(int8x16_t *)(result + 96) = v385.val[1];
              *(int8x16_t *)(result + 112) = v387.val[0];
              v392.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v377.val[1], (int32x4_t)v377.val[0]);
              v377.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v377.val[1], (int32x4_t)v377.val[0]);
              v377.val[1] = (int8x16_t)vdupq_laneq_s32(v343, 3);
              int32x4_t v203 = vaddq_s32(v196, (int32x4_t)v377.val[1]);
              int32x4_t v204 = vaddq_s32(v197, (int32x4_t)v377.val[1]);
              int32x4_t v205 = vaddq_s32(v198, (int32x4_t)v377.val[1]);
              v377.val[1] = (int8x16_t)vaddq_s32(v199, (int32x4_t)v377.val[1]);
              int32x4_t v206 = vdupq_laneq_s32((int32x4_t)v336.val[0], 3);
              int8x16_t v49 = (int8x16_t)vaddq_s32((int32x4_t)v392.val[1], v206);
              v391.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v391.val[1], v206);
              v381.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v381.val[1], v206);
              v383.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v394.val[1], v206);
              int32x4_t v207 = vdupq_laneq_s32((int32x4_t)v400.val[0], 3);
              int32x4_t v208 = vaddq_s32((int32x4_t)v353.val[0], v207);
              v400.val[0] = (int8x16_t)vaddq_s32(v375, v207);
              v384.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v348.val[0], v207);
              int32x4_t v209 = vaddq_s32(v367, v207);
              v381.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v383.val[0], 3);
              v385.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v385.val[0], (int32x4_t)v381.val[0]);
              v383.val[0] = (int8x16_t)vaddq_s32(v362, (int32x4_t)v381.val[0]);
              v384.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v384.val[0], (int32x4_t)v381.val[0]);
              v381.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v397.val[0], (int32x4_t)v381.val[0]);
              *(int32x4_t *)(result + 64) = vzip1q_s32(v371, (int32x4_t)v394.val[0]);
              *(int32x4_t *)(result + 80) = vzip2q_s32(v371, (int32x4_t)v394.val[0]);
              v379.val[0] = (int8x16_t)vzip2q_s32((int32x4_t)v377.val[1], v209);
              v377.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v377.val[1], v209);
              *(int8x16_t *)(result + 224) = v377.val[0];
              *(int8x16_t *)(result + 240) = v392.val[0];
              v377.val[0] = (int8x16_t)vzip2q_s32(v205, (int32x4_t)v384.val[1]);
              int8x16_t v48 = (int8x16_t)vzip1q_s32(v205, (int32x4_t)v384.val[1]);
              *(int8x16_t *)(result + 192) = v391.val[0];
              *(int8x16_t *)(result + 208) = v397.val[1];
              *(int32x4_t *)(result + 160) = vzip1q_s32((int32x4_t)v387.val[1], (int32x4_t)v400.val[1]);
              *(int32x4_t *)(result + 176) = vzip2q_s32((int32x4_t)v387.val[1], (int32x4_t)v400.val[1]);
              v391.val[0] = (int8x16_t)vzip2q_s32(v204, (int32x4_t)v400.val[0]);
              int8x16_t v50 = (int8x16_t)vzip1q_s32(v204, (int32x4_t)v400.val[0]);
              v394.val[1] = (int8x16_t)vzip2q_s32(v203, v208);
              *(int8x16_t *)(result + 128) = v379.val[1];
              *(int32x4_t *)(result + 144) = v202;
              v379.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v49, (int32x4_t)v385.val[0]);
              int32x4_t v210 = vzip2q_s32((int32x4_t)v383.val[1], (int32x4_t)v381.val[0]);
              int8x16_t v46 = (int8x16_t)vzip1q_s32((int32x4_t)v383.val[1], (int32x4_t)v381.val[0]);
              v383.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v394.val[1], (int32x4_t)v379.val[1]);
              v379.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v394.val[1], (int32x4_t)v379.val[1]);
              int32x4_t v53 = vzip1q_s32(v203, v208);
              *(int8x16_t *)(result + 480) = v379.val[1];
              *(int8x16_t *)(result + 496) = v383.val[1];
              v379.val[1] = (int8x16_t)vzip1q_s32((int32x4_t)v49, (int32x4_t)v385.val[0]);
              v383.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v381.val[1], (int32x4_t)v384.val[0]);
              int8x16_t v47 = (int8x16_t)vzip1q_s32((int32x4_t)v381.val[1], (int32x4_t)v384.val[0]);
              int32x4_t v52 = vzip2q_s32(v53, (int32x4_t)v379.val[1]);
              *(int32x4_t *)(result + 448) = vzip1q_s32(v53, (int32x4_t)v379.val[1]);
              *(int32x4_t *)(result + 464) = v52;
              v379.val[1] = (int8x16_t)vzip2q_s32((int32x4_t)v391.val[1], (int32x4_t)v383.val[0]);
              v383.val[0] = (int8x16_t)vzip1q_s32((int32x4_t)v391.val[1], (int32x4_t)v383.val[0]);
              *(int32x4_t *)(result + 416) = vzip1q_s32((int32x4_t)v379.val[0], v210);
              *(int32x4_t *)(result + 432) = vzip2q_s32((int32x4_t)v379.val[0], v210);
              *(int32x4_t *)(result + 384) = vzip1q_s32((int32x4_t)v377.val[1], (int32x4_t)v46);
              *(int32x4_t *)(result + 400) = vzip2q_s32((int32x4_t)v377.val[1], (int32x4_t)v46);
              *(int32x4_t *)(result + 352) = vzip1q_s32((int32x4_t)v377.val[0], (int32x4_t)v383.val[1]);
              *(int32x4_t *)(result + 368) = vzip2q_s32((int32x4_t)v377.val[0], (int32x4_t)v383.val[1]);
              *(int32x4_t *)(result + 320) = vzip1q_s32((int32x4_t)v48, (int32x4_t)v47);
              *(int32x4_t *)(result + 336) = vzip2q_s32((int32x4_t)v48, (int32x4_t)v47);
              int8x16_t v43 = (int8x16_t)vzip2q_s32((int32x4_t)v50, (int32x4_t)v383.val[0]);
              int8x16_t v44 = (int8x16_t)vzip1q_s32((int32x4_t)v50, (int32x4_t)v383.val[0]);
              int8x16_t v45 = (int8x16_t)vzip2q_s32((int32x4_t)v391.val[0], (int32x4_t)v379.val[1]);
              *(int32x4_t *)(result + 288) = vzip1q_s32((int32x4_t)v391.val[0], (int32x4_t)v379.val[1]);
              *(int8x16_t *)(result + 304) = v45;
              *(int8x16_t *)(result + 256) = v44;
              *(int8x16_t *)(result + 272) = v43;
              int16x8_t v142 = (float *)(result + 512);
              unint64_t v141 = v140 + 32;
              unint64_t v211 = v140 + 64;
              v53.i32[0] = v203.i32[3];
              v49.i32[0] = v49.i32[3];
              v140 += 32;
              v50.i32[0] = v208.i32[3];
              result += 512;
              v52.i32[0] = v385.val[0].i32[3];
            }
            while (v211 <= v35);
          }
          else
          {
            unint64_t v141 = v140;
            int16x8_t v142 = a11;
          }
          if (v141 + 8 <= v35)
          {
            do
            {
              v43.i64[0] = *(void *)(v38 + v141);
              v44.i64[0] = *(void *)(v297 + v38 + v141);
              v45.i64[0] = *(void *)(v293 + v38 + v141);
              int8x16_t v214 = vzip1q_s8((int8x16_t)0, v44);
              int8x16_t v215 = vzip1q_s8(v45, v43);
              int32x4_t v216 = (int32x4_t)vzip1q_s8(v214, v215);
              int32x4_t v217 = (int32x4_t)vzip2q_s8(v214, v215);
              int8x16_t v218 = (int8x16_t)vshlq_n_s64((int64x2_t)v217, 0x20uLL);
              int32x4_t v219 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v216, 0x20uLL), v216);
              int32x4_t v220 = vdupq_lane_s32(*(int32x2_t *)v53.i8, 0);
              v46.i64[0] = *(void *)(v40 + v141);
              int32x4_t v221 = vaddq_s32((int32x4_t)v218, v217);
              v218.i64[0] = *(void *)(v296 + v40 + v141);
              v47.i64[0] = *(void *)(v292 + v40 + v141);
              int32x4_t v222 = vdupq_lane_s32(*(int32x2_t *)v221.i8, 1);
              int8x16_t v223 = vzip1q_s8((int8x16_t)0, v218);
              int8x16_t v224 = vzip1q_s8(v47, v46);
              int32x4_t v225 = (int32x4_t)vzip1q_s8(v223, v224);
              int32x4_t v226 = (int32x4_t)vzip2q_s8(v223, v224);
              int8x16_t v227 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v219.i8, 1);
              int32x4_t v228 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v225, 0x20uLL), v225);
              int32x4_t v229 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v226, 0x20uLL), v226);
              v227.i64[0] = 0;
              int32x4_t v230 = vdupq_lane_s32(*(int32x2_t *)v229.i8, 1);
              int32x4_t v231 = vdupq_lane_s32(*(int32x2_t *)v228.i8, 1);
              v222.i64[0] = 0;
              v231.i64[0] = 0;
              int8x16_t v232 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v49.i8, 0);
              v230.i64[0] = 0;
              v48.i64[0] = *(void *)(v42 + v141);
              v49.i64[0] = *(void *)(v295 + v42 + v141);
              int32x4_t v233 = vaddq_s32((int32x4_t)v227, v219);
              v227.i64[0] = *(void *)(v291 + v42 + v141);
              int8x16_t v234 = vzip1q_s8((int8x16_t)0, v49);
              int8x16_t v235 = vzip1q_s8(v227, v48);
              int32x4_t v236 = (int32x4_t)vzip1q_s8(v234, v235);
              int32x4_t v237 = vaddq_s32(v222, vaddq_s32(v221, v220));
              int32x4_t v238 = (int32x4_t)vzip2q_s8(v234, v235);
              int8x16_t v239 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v236, 0x20uLL), v236);
              int32x4_t v240 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v238, 0x20uLL), v238);
              int32x4_t v241 = vaddq_s32(v231, v228);
              int32x4_t v242 = vdupq_lane_s32(*(int32x2_t *)v240.i8, 1);
              int32x4_t v243 = vdupq_lane_s32(*(int32x2_t *)v239.i8, 1);
              int32x4_t v244 = vdupq_laneq_s32(v233, 3);
              v243.i64[0] = 0;
              v242.i64[0] = 0;
              int32x4_t v245 = vaddq_s32(v233, v220);
              int32x4_t v246 = vaddq_s32(v230, vaddq_s32(v229, (int32x4_t)v232));
              int32x4_t v247 = vaddq_s32(v243, (int32x4_t)v239);
              int32x4_t v248 = vdupq_lane_s32(*(int32x2_t *)v50.i8, 0);
              int32x4_t v249 = vdupq_laneq_s32(v241, 3);
              int32x4_t v250 = vaddq_s32(v240, v248);
              v239.i64[0] = *(void *)(v51 + v141);
              v50.i64[0] = *(void *)(v294 + v51 + v141);
              int8x16_t v47 = (int8x16_t)vaddq_s32(v241, (int32x4_t)v232);
              v232.i64[0] = *(void *)(v290 + v51 + v141);
              int8x16_t v251 = vzip1q_s8((int8x16_t)0, v50);
              int8x16_t v252 = vzip1q_s8(v232, v239);
              int32x4_t v253 = vdupq_laneq_s32(v247, 3);
              int32x4_t v254 = (int32x4_t)vzip1q_s8(v251, v252);
              int32x4_t v255 = (int32x4_t)vzip2q_s8(v251, v252);
              int8x16_t v50 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v254, 0x20uLL), v254);
              int32x4_t v256 = vaddq_s32(v247, v248);
              int32x4_t v257 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v255, 0x20uLL), v255);
              int32x4_t v258 = vdupq_lane_s32(*(int32x2_t *)v257.i8, 1);
              int32x4_t v53 = vdupq_lane_s32(*(int32x2_t *)v50.i8, 1);
              int8x16_t v43 = (int8x16_t)vaddq_s32(v237, v244);
              int32x4_t v259 = vaddq_s32(v242, v250);
              v53.i64[0] = 0;
              v258.i64[0] = 0;
              int8x16_t v44 = (int8x16_t)vaddq_s32(v246, v249);
              int32x4_t v260 = vaddq_s32(v53, (int32x4_t)v50);
              int32x4_t v261 = vdupq_laneq_s32(v260, 3);
              int8x16_t v49 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v52.i8, 0);
              int8x16_t v46 = (int8x16_t)vaddq_s32(v259, v253);
              int32x4_t v262 = vaddq_s32(v260, (int32x4_t)v49);
              int32x4_t v263 = vaddq_s32(v258, vaddq_s32(v257, (int32x4_t)v49));
              int32x4_t v264 = vzip2q_s32(v245, v256);
              v380.val[0] = (float32x4_t)vzip1q_s32(v245, v256);
              int32x4_t v265 = vaddq_s32(v263, v261);
              v380.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v47, v262);
              int16x8_t v213 = v142 + 32;
              int16x8_t v266 = v142 + 16;
              int16x8_t v267 = v142 + 24;
              v53.i32[0] = v43.i32[3];
              vst2q_f32(v142, v380);
              int16x8_t v268 = v142 + 8;
              v49.i32[0] = v44.i32[3];
              int8x16_t v48 = (int8x16_t)vzip2q_s32((int32x4_t)v47, v262);
              vst2q_f32(v268, *(float32x4x2_t *)(&v48 - 1));
              v50.i32[0] = v46.i32[3];
              v380.val[0] = (float32x4_t)vzip1q_s32((int32x4_t)v43, (int32x4_t)v46);
              v380.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v44, v265);
              vst2q_f32(v266, v380);
              int8x16_t v45 = (int8x16_t)vzip2q_s32((int32x4_t)v43, (int32x4_t)v46);
              v380.val[1] = (float32x4_t)vzip2q_s32((int32x4_t)v44, v265);
              vst2q_f32(v267, *(float32x4x2_t *)v45.i8);
              v52.i32[0] = v265.i32[3];
              unint64_t v212 = v141 + 8;
              result = v141 + 16;
              v141 += 8;
              int16x8_t v142 = v213;
            }
            while (result <= v35);
          }
          else
          {
            unint64_t v212 = v141;
            int16x8_t v213 = v142;
          }
          if (v212 < v35)
          {
            uint64_t v269 = 0;
            result = v292 + v212 + v40;
            unint64_t v270 = v290 + v212 + v51;
            unint64_t v271 = v294 + v212 + v51;
            unint64_t v272 = v51 + v212;
            do
            {
              LODWORD(v273) = ((*(unsigned __int8 *)(v38 + v212 + v269) << 24) | (*(unsigned __int8 *)(v297 + v212 + v38 + v269) << 16) | (*(unsigned __int8 *)(v293 + v212 + v38 + v269) << 8))
                            + v53.i32[0];
              DWORD1(v273) = ((*(unsigned __int8 *)(v40 + v212 + v269) << 24) | (*(unsigned __int8 *)(v296 + v212 + v40 + v269) << 16) | (*(unsigned __int8 *)(result + v269) << 8))
                           + v49.i32[0];
              DWORD2(v273) = ((*(unsigned __int8 *)(v42 + v212 + v269) << 24) | (*(unsigned __int8 *)(v295 + v212 + v42 + v269) << 16) | (*(unsigned __int8 *)(v291 + v212 + v42 + v269) << 8))
                           + v50.i32[0];
              HIDWORD(v273) = ((*(unsigned __int8 *)(v272 + v269) << 24) | (*(unsigned __int8 *)(v271 + v269) << 16) | (*(unsigned __int8 *)(v270 + v269) << 8))
                            + v52.i32[0];
              *(_OWORD *)&v213[4 * v269++] = v273;
            }
            while (v35 - v212 != v269);
          }
        }
        a11 = (float *)((char *)a11 + a12);
        uint64_t v33 = v298 + a10;
      }
      while (v33 + (unint64_t)a3[7].u32[0] < v287);
    }
  }
  return result;
}

uint64_t TileDecoder_PXR24::ExtractPlane(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9 = *(void *)(a4 + 8);
  unsigned int v10 = *(_DWORD *)(v9 + 80);
  unsigned int v11 = *(_DWORD *)(v9 + 104);
  v15[0] = 0;
  v15[1] = 0;
  int v17 = 0;
  uint64_t v16 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a1, a5, v10, v11, (unsigned int *)v15);
  if (HIDWORD(v16) && v17)
  {
    uint64_t v13 = *(void *)(a1 + 64);
    if (v13)
    {
      BOOL v14 = *(void *)(v13 + 8) == 0;
      uint64_t v13 = 3;
      if (v14) {
        uint64_t v13 = 0;
      }
    }
    return ((uint64_t (*)(uint64_t, uint64_t, _DWORD *, uint64_t, void))*(&TileDecoder_PXR24::ExtractPlane(void const*,unsigned long,ChannelInfo const&,TileInfo const&,void *,unsigned long,long)const::kFuncTable[v13]
                                                                                 + *(unsigned int *)(*(void *)(a4 + 8) + 72)))(a2, a1, a5, a4, LODWORD(v15[0]));
  }
  return result;
}

void CompressedPlanar<unsigned int,(StreamType)0>(uint64_t a1, uint64_t a2, unsigned int *a3, double **a4, uint64_t a5, uint64_t a6, unsigned int a7, int32x4_t *a8, uint64_t a9)
{
  if (a6)
  {
    unint64_t v9 = *(unsigned int *)(a2 + 60);
    unsigned int v10 = *a4;
    if (*((unsigned char *)*a4 + 24)) {
      LODWORD(v10) = *v10;
    }
    uint64_t v11 = a3[13];
    if ((unint64_t)a3[14] + v11 < v9)
    {
      unint64_t v12 = a3[11];
      unint64_t v13 = v12 + a6;
      int32x4_t v14 = vdupq_n_s32(v10);
      unint64_t v15 = v12 & 0xFFFFFFE0 | 8;
      if (v15 <= v12 + 1) {
        unint64_t v15 = v12 + 1;
      }
      if ((v12 & 0xFFFFFFE0)
         + ((v15 + ~(unint64_t)(v12 & 0xFFFFFFE0)) & 0xFFFFFFFFFFFFFFF8) > v12)
        unint64_t v12 = (v12 & 0xFFFFFFE0)
            + ((v15 + ~(unint64_t)(v12 & 0xFFFFFFE0)) & 0xFFFFFFFFFFFFFFF8);
      do
      {
        unint64_t v16 = v12;
        int v17 = a8;
        if (v12 + 32 <= v13)
        {
          do
          {
            *int v17 = v14;
            v17[1] = v14;
            v17[2] = v14;
            v17[3] = v14;
            v17[4] = v14;
            v17[5] = v14;
            v17[6] = v14;
            v17[7] = v14;
            v17 += 8;
            unint64_t v18 = v16 + 64;
            v16 += 32;
          }
          while (v18 <= v13);
        }
        unint64_t v19 = v16 + 8;
        while (v19 <= v13)
        {
          *int v17 = v14;
          v17[1] = v14;
          v17 += 2;
          unint64_t v19 = v16 + 16;
          v16 += 8;
        }
        if (v16 < v13)
        {
          unint64_t v20 = v13 - v16;
          do
          {
            v17->i32[0] = (int)v10;
            int v17 = (int32x4_t *)((char *)v17 + 4);
            --v20;
          }
          while (v20);
        }
        a8 = (int32x4_t *)((char *)a8 + a9);
        v11 += a7;
      }
      while (v11 + (unint64_t)a3[14] < v9);
    }
  }
}

void CompressedPlanar<unsigned short,(StreamType)0>(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t **a4, uint64_t a5, uint64_t a6, unsigned int a7, int16x8_t *a8, uint64_t a9)
{
  if (a6)
  {
    unint64_t v9 = *(unsigned int *)(a2 + 60);
    if (*((unsigned char *)*a4 + 24))
    {
      _D0 = **a4;
      __asm { FCVT            H0, D0 }
      unsigned int v15 = _D0;
    }
    else
    {
      unsigned int v15 = 32256;
    }
    uint64_t v16 = a3[13];
    if ((unint64_t)a3[14] + v16 < v9)
    {
      unint64_t v17 = a3[11];
      unint64_t v18 = v17 + a6;
      int16x8_t v19 = vdupq_n_s16(v15);
      unint64_t v20 = v17 & 0xFFFFFFE0 | 8;
      if (v20 <= v17 + 1) {
        unint64_t v20 = v17 + 1;
      }
      if ((v17 & 0xFFFFFFE0)
         + ((v20 + ~(unint64_t)(v17 & 0xFFFFFFE0)) & 0xFFFFFFFFFFFFFFF8) > v17)
        unint64_t v17 = (v17 & 0xFFFFFFE0)
            + ((v20 + ~(unint64_t)(v17 & 0xFFFFFFE0)) & 0xFFFFFFFFFFFFFFF8);
      do
      {
        unint64_t v21 = v17;
        uint64_t v22 = a8;
        if (v17 + 32 <= v18)
        {
          do
          {
            int16x8_t *v22 = v19;
            v22[1] = v19;
            v22[2] = v19;
            v22[3] = v19;
            v22 += 4;
            unint64_t v23 = v21 + 64;
            v21 += 32;
          }
          while (v23 <= v18);
        }
        unint64_t v24 = v21 + 8;
        while (v24 <= v18)
        {
          *v22++ = v19;
          unint64_t v24 = v21 + 16;
          v21 += 8;
        }
        if (v21 < v18)
        {
          unint64_t v25 = v18 - v21;
          do
          {
            v22->i16[0] = v15;
            uint64_t v22 = (int16x8_t *)((char *)v22 + 2);
            --v25;
          }
          while (v25);
        }
        a8 = (int16x8_t *)((char *)a8 + a9);
        v16 += a7;
      }
      while (v16 + (unint64_t)a3[14] < v9);
    }
  }
}

void CompressedPlanar<float,(StreamType)0>(double a1, uint64_t a2, uint64_t a3, unsigned int *a4, double **a5, uint64_t a6, uint64_t a7, unsigned int a8, int32x4_t *a9, uint64_t a10)
{
  if (a7)
  {
    unint64_t v10 = *(unsigned int *)(a3 + 60);
    uint64_t v11 = *a5;
    if (*((unsigned char *)*a5 + 24))
    {
      a1 = *v11;
      *(float *)&a1 = *v11;
    }
    else
    {
      LODWORD(a1) = 2143289344;
    }
    uint64_t v12 = a4[13];
    if ((unint64_t)a4[14] + v12 < v10)
    {
      unint64_t v13 = a4[11];
      unint64_t v14 = v13 + a7;
      int32x4_t v15 = vdupq_lane_s32(*(int32x2_t *)&a1, 0);
      unint64_t v16 = v13 & 0xFFFFFFE0 | 8;
      if (v16 <= v13 + 1) {
        unint64_t v16 = v13 + 1;
      }
      if ((v13 & 0xFFFFFFE0)
         + ((v16 + ~(unint64_t)(v13 & 0xFFFFFFE0)) & 0xFFFFFFFFFFFFFFF8) > v13)
        unint64_t v13 = (v13 & 0xFFFFFFE0)
            + ((v16 + ~(unint64_t)(v13 & 0xFFFFFFE0)) & 0xFFFFFFFFFFFFFFF8);
      do
      {
        unint64_t v17 = v13;
        unint64_t v18 = a9;
        if (v13 + 32 <= v14)
        {
          do
          {
            *unint64_t v18 = v15;
            v18[1] = v15;
            v18[2] = v15;
            v18[3] = v15;
            v18[4] = v15;
            v18[5] = v15;
            v18[6] = v15;
            v18[7] = v15;
            v18 += 8;
            unint64_t v19 = v17 + 64;
            v17 += 32;
          }
          while (v19 <= v14);
        }
        unint64_t v20 = v17 + 8;
        while (v20 <= v14)
        {
          *unint64_t v18 = v15;
          v18[1] = v15;
          v18 += 2;
          unint64_t v20 = v17 + 16;
          v17 += 8;
        }
        if (v17 < v14)
        {
          unint64_t v21 = v14 - v17;
          do
          {
            v18->i32[0] = LODWORD(a1);
            unint64_t v18 = (int32x4_t *)((char *)v18 + 4);
            --v21;
          }
          while (v21);
        }
        a9 = (int32x4_t *)((char *)a9 + a10);
        v12 += a8;
      }
      while (v12 + (unint64_t)a4[14] < v10);
    }
  }
}

unint64_t CompressedPlanar<unsigned int,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int8x16_t *a8, uint64_t a9)
{
  unint64_t v98 = result;
  if (a6)
  {
    unint64_t v14 = *(void *)(a2 + 56);
    int32x4_t v15 = *(ChannelDescription **)(a4 + 8);
    int32x2_t v94 = a3[3];
    uint64_t v96 = v94.u32[0];
    unint64_t v97 = HIDWORD(v14);
    uint64_t v16 = a3[7].u32[1];
    int32x2_t v17 = *(int32x2_t *)((char *)v15 + 48);
    int32x2_t v18 = *(int32x2_t *)(*(void *)(*((void *)v15 + 5) + 8 * v16) + 16);
    uint64_t result = ChannelDescription::GetLocationForTile(v15, (a3[6].i32[1] + v94.i32[1] * HIDWORD(v14)), v94.u32[0], a3[7].u32[1]);
    uint64_t v19 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v19 < HIDWORD(v14))
    {
      uint64_t v20 = vmin_u32((uint32x2_t)vmls_s32(v18, v17, v94), (uint32x2_t)v17).u32[0];
      int v95 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v21 = a3[5].u32[1];
      uint64_t v22 = 2 * v20;
      unsigned int v23 = a7;
      uint64_t v24 = 3 * v20;
      unint64_t v25 = v21 + a6;
      uint64_t v93 = v23;
      do
      {
        uint64_t result = ChannelDescription::GetLocationForTile(v15, (v95 + v19), v96, v16);
        unint64_t v30 = v98 + result;
        if (HIDWORD(result)) {
          BOOL v31 = v30 == 0;
        }
        else {
          BOOL v31 = 1;
        }
        if (!v31)
        {
          if (v21 >= 0x20)
          {
            uint64_t v43 = 0;
            unsigned int v32 = 0;
            unint64_t v44 = v24 + v30;
            unint64_t v45 = v22 + v30;
            uint64_t v46 = v20 + v30;
            int8x16_t v35 = (int8x16_t)xmmword_228F61DB0;
            int8x16_t v34 = (int8x16_t)xmmword_228F61DA0;
            int8x16_t v37 = (int8x16_t)xmmword_228F61D70;
            int8x16_t v36 = (int8x16_t)xmmword_228F61D60;
            int8x16_t v39 = (int8x16_t)xmmword_228F61D50;
            int8x16_t v38 = (int8x16_t)xmmword_228F61D40;
            int8x16_t v41 = (int8x16_t)xmmword_228F61D90;
            int8x16_t v40 = (int8x16_t)xmmword_228F61D80;
            int8x16_t v42 = (int8x16_t)xmmword_228F61DC0;
            do
            {
              v99.val[1] = *(int8x16_t *)(v30 + v43);
              v101.val[1] = *(int8x16_t *)(v30 + v43 + 16);
              v103.val[1] = *(int8x16_t *)(v46 + v43);
              v105.val[1] = *(int8x16_t *)(v46 + v43 + 16);
              v99.val[0] = *(int8x16_t *)(v45 + v43);
              v101.val[0] = *(int8x16_t *)(v45 + v43 + 16);
              v103.val[0] = *(int8x16_t *)(v44 + v43);
              v105.val[0] = *(int8x16_t *)(v44 + v43 + 16);
              v107.val[0] = vqtbl2q_s8(v103, (int8x16_t)xmmword_228F61D40);
              v107.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61D50);
              v109.val[0] = vqtbl2q_s8(v103, (int8x16_t)xmmword_228F61D60);
              v109.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61D70);
              v111.val[0] = vqtbl2q_s8(v103, (int8x16_t)xmmword_228F61D80);
              v111.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61D90);
              v103.val[0] = vqtbl2q_s8(v103, (int8x16_t)xmmword_228F61DA0);
              v103.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61DB0);
              v99.val[0] = vqtbl2q_s8(v105, (int8x16_t)xmmword_228F61D80);
              v99.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61D90);
              v113.val[0] = vqtbl2q_s8(v105, (int8x16_t)xmmword_228F61DA0);
              v113.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61DB0);
              v115.val[0] = vqtbl2q_s8(v105, (int8x16_t)xmmword_228F61D40);
              v115.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61D50);
              v105.val[0] = vqtbl2q_s8(v105, (int8x16_t)xmmword_228F61D60);
              v105.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61D70);
              v101.val[0] = vqtbl2q_s8(v105, (int8x16_t)xmmword_228F61DC0);
              v101.val[1] = vqtbl2q_s8(v115, (int8x16_t)xmmword_228F61DC0);
              v105.val[0] = vqtbl2q_s8(v113, (int8x16_t)xmmword_228F61DC0);
              v99.val[0] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61DC0);
              v99.val[1] = vqtbl2q_s8(v103, (int8x16_t)xmmword_228F61DC0);
              v103.val[0] = vqtbl2q_s8(v111, (int8x16_t)xmmword_228F61DC0);
              v103.val[1] = vqtbl2q_s8(v109, (int8x16_t)xmmword_228F61DC0);
              v105.val[1] = vqtbl2q_s8(v107, (int8x16_t)xmmword_228F61DC0);
              v101.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v101.val[0], 0x20uLL), (int32x4_t)v101.val[0]);
              v101.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v101.val[1], 0x20uLL), (int32x4_t)v101.val[1]);
              v105.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v105.val[0], 0x20uLL), (int32x4_t)v105.val[0]);
              v99.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v99.val[0], 0x20uLL), (int32x4_t)v99.val[0]);
              v99.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v99.val[1], 0x20uLL), (int32x4_t)v99.val[1]);
              v103.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v103.val[0], 0x20uLL), (int32x4_t)v103.val[0]);
              v103.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v103.val[1], 0x20uLL), (int32x4_t)v103.val[1]);
              v105.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v105.val[1], 0x20uLL), (int32x4_t)v105.val[1]);
              int8x16_t v29 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v101.val[1].i8, 1), (int32x4_t)v101.val[1]);
              int8x16_t v28 = (int8x16_t)vaddq_s32((int32x4_t)v29, vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v101.val[0].i8, 1), (int32x4_t)v101.val[0]));
              int8x16_t v27 = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v103.val[0].i8, 1), (int32x4_t)v103.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v99.val[1].i8, 1), (int32x4_t)v99.val[1])), vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v105.val[1].i8, 1), (int32x4_t)v105.val[1]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v103.val[1].i8, 1), (int32x4_t)v103.val[1])));
              int8x16_t v26 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v28, vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v99.val[0].i8, 1), (int32x4_t)v99.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v105.val[0].i8, 1), (int32x4_t)v105.val[0]))), (int32x4_t)v27);
              v32 += v26.u32[3];
              unint64_t v33 = v43 + 32;
              unint64_t v47 = v43 + 64;
              v43 += 32;
            }
            while (v47 <= v21);
          }
          else
          {
            unsigned int v32 = 0;
            unint64_t v33 = 0;
            int8x16_t v35 = (int8x16_t)xmmword_228F61DB0;
            int8x16_t v34 = (int8x16_t)xmmword_228F61DA0;
            int8x16_t v37 = (int8x16_t)xmmword_228F61D70;
            int8x16_t v36 = (int8x16_t)xmmword_228F61D60;
            int8x16_t v39 = (int8x16_t)xmmword_228F61D50;
            int8x16_t v38 = (int8x16_t)xmmword_228F61D40;
            int8x16_t v41 = (int8x16_t)xmmword_228F61D90;
            int8x16_t v40 = (int8x16_t)xmmword_228F61D80;
            int8x16_t v42 = (int8x16_t)xmmword_228F61DC0;
          }
          if ((v33 | 8) <= v21)
          {
            do
            {
              v26.i64[0] = *(void *)(v30 + v33);
              v27.i64[0] = *(void *)(v20 + v30 + v33);
              v28.i64[0] = *(void *)(v22 + v30 + v33);
              v29.i64[0] = *(void *)(v24 + v30 + v33);
              int8x16_t v49 = vzip1q_s8(v29, v27);
              int8x16_t v50 = vzip1q_s8(v28, v26);
              int32x4_t v51 = (int32x4_t)vzip1q_s8(v49, v50);
              int32x4_t v52 = (int32x4_t)vzip2q_s8(v49, v50);
              int32x4_t v53 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v51, 0x20uLL), v51);
              int32x4_t v54 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v52, 0x20uLL), v52);
              int8x16_t v27 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v54.i8, 1);
              int8x16_t v29 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v53.i8, 1);
              int8x16_t v28 = (int8x16_t)vaddq_s32((int32x4_t)v29, v53);
              int8x16_t v26 = (int8x16_t)vaddq_s32((int32x4_t)v27, v54);
              v32 += v26.i32[3] + v28.i32[3];
              unint64_t v48 = v33 + 8;
              unint64_t v55 = v33 + 16;
              v33 += 8;
            }
            while (v55 <= v21);
          }
          else
          {
            unint64_t v48 = v33;
          }
          unint64_t v56 = v21 - v48;
          if (v21 > v48)
          {
            unsigned int v57 = (unsigned __int8 *)(v22 + v48 + v30);
            unsigned int v58 = (unsigned __int8 *)(v20 + v48 + v30);
            uint64_t v59 = (unsigned __int8 *)(v30 + v48);
            do
            {
              int v60 = *v59++;
              int v61 = v60 << 24;
              int v62 = *v58++;
              int v63 = v61 | (v62 << 16);
              int v64 = *v57++;
              v32 += v63 | (v64 << 8) | v64;
              --v56;
            }
            while (v56);
            unint64_t v48 = v21;
          }
          if (v48 + 32 <= v25)
          {
            unint64_t v67 = v24 + v30;
            unint64_t v68 = v22 + v30;
            uint64_t v69 = v20 + v30;
            int8x16_t v70 = a8;
            do
            {
              v100.val[1] = *(int8x16_t *)(v30 + v48);
              v102.val[1] = *(int8x16_t *)(v30 + v48 + 16);
              v104.val[1] = *(int8x16_t *)(v69 + v48);
              v106.val[1] = *(int8x16_t *)(v69 + v48 + 16);
              v100.val[0] = *(int8x16_t *)(v68 + v48);
              v102.val[0] = *(int8x16_t *)(v68 + v48 + 16);
              v104.val[0] = *(int8x16_t *)(v67 + v48);
              v106.val[0] = *(int8x16_t *)(v67 + v48 + 16);
              v108.val[0] = vqtbl2q_s8(v104, v34);
              v108.val[1] = vqtbl2q_s8(v100, v35);
              v110.val[0] = vqtbl2q_s8(v104, v36);
              v110.val[1] = vqtbl2q_s8(v100, v37);
              v112.val[0] = vqtbl2q_s8(v106, v34);
              v112.val[1] = vqtbl2q_s8(v102, v35);
              v114.val[0] = vqtbl2q_s8(v106, v36);
              v114.val[1] = vqtbl2q_s8(v102, v37);
              v116.val[0] = vqtbl2q_s8(v106, v38);
              v116.val[1] = vqtbl2q_s8(v102, v39);
              v106.val[0] = vqtbl2q_s8(v106, v40);
              v106.val[1] = vqtbl2q_s8(v102, v41);
              v102.val[0] = vqtbl2q_s8(v104, v38);
              v102.val[1] = vqtbl2q_s8(v100, v39);
              v104.val[0] = vqtbl2q_s8(v104, v40);
              v104.val[1] = vqtbl2q_s8(v100, v41);
              v100.val[0] = vqtbl2q_s8(v104, v42);
              v100.val[1] = vqtbl2q_s8(v102, v42);
              v102.val[0] = vqtbl2q_s8(v106, v42);
              v102.val[1] = vqtbl2q_s8(v116, v42);
              v104.val[0] = vqtbl2q_s8(v114, v42);
              v104.val[1] = vqtbl2q_s8(v112, v42);
              v106.val[0] = vqtbl2q_s8(v110, v42);
              v106.val[1] = vqtbl2q_s8(v108, v42);
              v100.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v100.val[0], 0x20uLL), (int32x4_t)v100.val[0]);
              v100.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v100.val[1], 0x20uLL), (int32x4_t)v100.val[1]);
              v102.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v102.val[0], 0x20uLL), (int32x4_t)v102.val[0]);
              v102.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v102.val[1], 0x20uLL), (int32x4_t)v102.val[1]);
              v104.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v104.val[0], 0x20uLL), (int32x4_t)v104.val[0]);
              v104.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v104.val[1], 0x20uLL), (int32x4_t)v104.val[1]);
              v106.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v106.val[0], 0x20uLL), (int32x4_t)v106.val[0]);
              v106.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v106.val[1], 0x20uLL), (int32x4_t)v106.val[1]);
              v108.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v106.val[1].i8, 1);
              v108.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v106.val[0].i8, 1);
              v110.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v104.val[1].i8, 1);
              v110.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v104.val[0].i8, 1);
              v112.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v102.val[1].i8, 1);
              v112.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v102.val[0].i8, 1);
              v114.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v100.val[1].i8, 1);
              v114.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v100.val[0].i8, 1);
              v114.val[1].i64[0] = 0;
              v114.val[0].i64[0] = 0;
              v112.val[1].i64[0] = 0;
              v112.val[0].i64[0] = 0;
              v110.val[1].i64[0] = 0;
              v110.val[0].i64[0] = 0;
              v108.val[1].i64[0] = 0;
              v108.val[0].i64[0] = 0;
              v102.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v112.val[0], (int32x4_t)v102.val[1]);
              v102.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v112.val[1], (int32x4_t)v102.val[0]);
              v100.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v114.val[0], (int32x4_t)v100.val[1]);
              v100.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v114.val[1], (int32x4_t)v100.val[0]);
              v104.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v102.val[0], 3), vaddq_s32((int32x4_t)v110.val[0], (int32x4_t)v104.val[1]));
              v106.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v100.val[1], 3), vaddq_s32((int32x4_t)v108.val[1], (int32x4_t)v106.val[0]));
              v106.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v100.val[0], 3), vaddq_s32((int32x4_t)v108.val[0], (int32x4_t)v106.val[1]));
              v108.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v106.val[1], 3);
              v108.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v104.val[1], 3);
              v104.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v102.val[1], 3), vaddq_s32((int32x4_t)v110.val[1], (int32x4_t)v104.val[0]));
              v106.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v106.val[0], (int32x4_t)v108.val[0]);
              v110.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v106.val[0], 3);
              v110.val[1] = (int8x16_t)vdupq_n_s32(v32);
              v104.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v104.val[0], (int32x4_t)v108.val[1]), (int32x4_t)v110.val[1]), (int32x4_t)v110.val[0]);
              int8x16_t v28 = (int8x16_t)vaddq_s32((int32x4_t)v102.val[0], (int32x4_t)v110.val[1]);
              int8x16_t v29 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v102.val[1], (int32x4_t)v108.val[1]), (int32x4_t)v110.val[1]);
              unsigned int v32 = v104.val[0].u32[3];
              *(int32x4_t *)int8x16_t v70 = vaddq_s32((int32x4_t)v100.val[0], (int32x4_t)v110.val[1]);
              v70[1] = (int8x16_t)vaddq_s32((int32x4_t)v106.val[1], (int32x4_t)v110.val[1]);
              v70[2] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v100.val[1], (int32x4_t)v110.val[1]), (int32x4_t)v108.val[0]);
              v70[3] = (int8x16_t)vaddq_s32((int32x4_t)v106.val[0], (int32x4_t)v110.val[1]);
              int8x16_t v26 = (int8x16_t)vaddq_s32((int32x4_t)v28, (int32x4_t)v110.val[0]);
              int8x16_t v27 = (int8x16_t)vaddq_s32((int32x4_t)v29, (int32x4_t)v110.val[0]);
              uint64_t v66 = v70 + 8;
              v70[6] = v27;
              v70[7] = v104.val[0];
              v70[4] = v26;
              v70[5] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v104.val[1], (int32x4_t)v110.val[1]), (int32x4_t)v110.val[0]);
              unint64_t v65 = v48 + 32;
              unint64_t v71 = v48 + 64;
              v48 += 32;
              v70 += 8;
            }
            while (v71 <= v25);
          }
          else
          {
            unint64_t v65 = v48;
            uint64_t v66 = a8;
          }
          if (v65 + 8 <= v25)
          {
            do
            {
              v26.i64[0] = *(void *)(v30 + v65);
              v27.i64[0] = *(void *)(v20 + v30 + v65);
              v28.i64[0] = *(void *)(v22 + v30 + v65);
              v29.i64[0] = *(void *)(v24 + v30 + v65);
              int8x16_t v74 = vzip1q_s8(v29, v27);
              int8x16_t v75 = vzip1q_s8(v28, v26);
              int32x4_t v76 = (int32x4_t)vzip1q_s8(v74, v75);
              int32x4_t v77 = (int32x4_t)vzip2q_s8(v74, v75);
              int32x4_t v78 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v76, 0x20uLL), v76);
              int32x4_t v79 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v77, 0x20uLL), v77);
              int8x16_t v27 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v79.i8, 1);
              int32x4_t v80 = vdupq_lane_s32(*(int32x2_t *)v78.i8, 1);
              v80.i64[0] = 0;
              v27.i64[0] = 0;
              int32x4_t v81 = vaddq_s32(v80, v78);
              int8x16_t v29 = (int8x16_t)vdupq_laneq_s32(v81, 3);
              int32x4_t v82 = vdupq_n_s32(v32);
              int8x16_t v28 = (int8x16_t)vaddq_s32(v81, v82);
              int8x16_t v26 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v27, vaddq_s32(v79, v82)), (int32x4_t)v29);
              unsigned int v32 = v26.u32[3];
              int8x16_t v73 = (unsigned int *)&v66[2];
              *uint64_t v66 = v28;
              v66[1] = v26;
              unint64_t v72 = v65 + 8;
              unint64_t v83 = v65 + 16;
              v65 += 8;
              v66 += 2;
            }
            while (v83 <= v25);
          }
          else
          {
            unint64_t v72 = v65;
            int8x16_t v73 = (unsigned int *)v66;
          }
          if (v72 < v25)
          {
            unint64_t v84 = v25 - v72;
            int8x16_t v85 = (unsigned __int8 *)(v22 + v72 + v30);
            int8x16_t v86 = (unsigned __int8 *)(v20 + v72 + v30);
            int32x4_t v87 = (unsigned __int8 *)(v30 + v72);
            do
            {
              int v88 = *v87++;
              int v89 = v88 << 24;
              int v90 = *v86++;
              int v91 = v89 | (v90 << 16);
              int v92 = *v85++;
              v32 += v91 | (v92 << 8) | v92;
              *v73++ = v32;
              --v84;
            }
            while (v84);
          }
        }
        a8 = (int8x16_t *)((char *)a8 + a9);
        v19 += v93;
      }
      while (v19 + (unint64_t)a3[7].u32[0] < v97);
    }
  }
  return result;
}

unint64_t CompressedPlanar<unsigned short,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int8x16_t *a8, uint64_t a9)
{
  unint64_t v104 = result;
  if (a6)
  {
    unint64_t v14 = *(void *)(a2 + 56);
    int32x4_t v15 = *(ChannelDescription **)(a4 + 8);
    int32x2_t v16 = a3[3];
    uint64_t v17 = v16.u32[0];
    int32x2_t v101 = v16;
    unint64_t v103 = HIDWORD(v14);
    uint64_t v18 = a3[7].u32[1];
    int32x2_t v19 = *(int32x2_t *)((char *)v15 + 48);
    int32x2_t v20 = *(int32x2_t *)(*(void *)(*((void *)v15 + 5) + 8 * v18) + 16);
    uint64_t result = ChannelDescription::GetLocationForTile(v15, (a3[6].i32[1] + v16.i32[1] * HIDWORD(v14)), v16.u32[0], v18);
    uint64_t v21 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v21 < HIDWORD(v14))
    {
      uint64_t v22 = vmin_u32((uint32x2_t)vmls_s32(v20, v19, v101), (uint32x2_t)v19).u32[0];
      int v102 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unsigned int v23 = a7;
      unint64_t v24 = a3[5].u32[1];
      unint64_t v25 = v24 + a6;
      uint64_t v26 = v23;
      do
      {
        uint64_t result = ChannelDescription::GetLocationForTile(v15, (v102 + v21), v17, v18);
        v29.i64[0] = 0xFFFFFFFF00000000;
        v29.i64[1] = 0xFFFFFFFF00000000;
        unint64_t v30 = v104 + result;
        if (HIDWORD(result)) {
          BOOL v31 = v30 == 0;
        }
        else {
          BOOL v31 = 1;
        }
        if (!v31)
        {
          if (v24 >= 0x20)
          {
            uint64_t v34 = 0;
            unsigned int v32 = 0;
            uint64_t v35 = v22 + v30;
            do
            {
              int8x16_t v37 = *(int8x16_t *)(v30 + v34);
              int8x16_t v36 = *(int8x16_t *)(v30 + v34 + 16);
              int8x16_t v39 = *(int8x16_t *)(v35 + v34);
              int8x16_t v38 = *(int8x16_t *)(v35 + v34 + 16);
              int16x8_t v40 = (int16x8_t)vzip1q_s8(v39, v37);
              int16x8_t v41 = (int16x8_t)vzip2q_s8(v39, v37);
              int16x8_t v42 = (int16x8_t)vzip1q_s8(v38, v36);
              int16x8_t v43 = (int16x8_t)vzip2q_s8(v38, v36);
              int8x16_t v44 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v40, 0x10uLL), v40);
              int8x16_t v45 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v41, 0x10uLL), v41);
              int8x16_t v46 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v42, 0x10uLL), v42);
              int8x16_t v47 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v43, 0x10uLL), v43);
              int16x8_t v48 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v46, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v46);
              int16x8_t v49 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v45, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v45);
              int16x8_t v50 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v44, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v44);
              int16x8_t v51 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v47, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v47);
              int8x16_t v28 = (int8x16_t)vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v50.i8, 3), v50), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v49.i8, 3), v49));
              int8x16_t v27 = (int8x16_t)vaddq_s16(vaddq_s16(vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v48.i8, 3), v48), vaddq_s16(vdupq_lane_s16(*(int16x4_t *)v51.i8, 3), v51)), (int16x8_t)v28);
              v32 += v27.u16[7];
              unint64_t v33 = v34 + 32;
              unint64_t v52 = v34 + 64;
              v34 += 32;
            }
            while (v52 <= v24);
          }
          else
          {
            unsigned int v32 = 0;
            unint64_t v33 = 0;
          }
          if ((v33 | 8) <= v24)
          {
            do
            {
              v27.i64[0] = *(void *)(v30 + v33);
              v28.i64[0] = *(void *)(v22 + v30 + v33);
              int16x8_t v54 = (int16x8_t)vzip1q_s8(v28, v27);
              int8x16_t v55 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v54, 0x10uLL), v54);
              int8x16_t v28 = vextq_s8(v55, v55, 0xCuLL);
              int8x16_t v27 = (int8x16_t)vaddq_s16((int16x8_t)v28, (int16x8_t)v55);
              v32 += v27.u16[7] + v27.u16[3];
              unint64_t v53 = v33 + 8;
              unint64_t v56 = v33 + 16;
              v33 += 8;
            }
            while (v56 <= v24);
          }
          else
          {
            unint64_t v53 = v33;
          }
          unint64_t v57 = v24 - v53;
          if (v24 > v53)
          {
            unsigned int v58 = (unsigned __int8 *)(v22 + v53 + v30);
            uint64_t v59 = (unsigned __int8 *)(v30 + v53);
            do
            {
              int v61 = *v59++;
              int v60 = v61;
              int v62 = *v58++;
              v32 += v62 | (v60 << 8);
              --v57;
            }
            while (v57);
            unint64_t v53 = v24;
          }
          if (v53 + 32 <= v25)
          {
            uint64_t v65 = v22 + v30;
            uint64_t v66 = a8;
            do
            {
              int8x16_t v68 = *(int8x16_t *)(v30 + v53);
              int8x16_t v67 = *(int8x16_t *)(v30 + v53 + 16);
              int8x16_t v70 = *(int8x16_t *)(v65 + v53);
              int8x16_t v69 = *(int8x16_t *)(v65 + v53 + 16);
              int16x8_t v71 = (int16x8_t)vzip2q_s8(v70, v68);
              int16x8_t v72 = (int16x8_t)vzip2q_s8(v69, v67);
              int16x8_t v73 = (int16x8_t)vzip1q_s8(v69, v67);
              int16x8_t v74 = (int16x8_t)vzip1q_s8(v70, v68);
              int8x16_t v75 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v71, 0x10uLL), v71);
              int8x16_t v76 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v72, 0x10uLL), v72);
              int8x16_t v77 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v73, 0x10uLL), v73);
              int8x16_t v78 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v74, 0x10uLL), v74);
              int16x8_t v79 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v78, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v78);
              int16x8_t v80 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v77, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v77);
              int16x8_t v81 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v76, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v76);
              int16x8_t v82 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v75, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v75);
              int16x8_t v83 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v80.i8, 3), (int8x16_t)xmmword_228F61DE0), v80);
              int16x8_t v84 = vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v79.i8, 3), (int8x16_t)xmmword_228F61DE0), v79);
              int16x8_t v85 = vaddq_s16(vdupq_laneq_s16(v84, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v82.i8, 3), (int8x16_t)xmmword_228F61DE0), v82));
              int16x8_t v86 = vdupq_laneq_s16(v85, 7);
              int16x8_t v87 = vdupq_n_s16(v32);
              int16x8_t v88 = vaddq_s16(vaddq_s16(vaddq_s16(vdupq_laneq_s16(v83, 7), vaddq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v81.i8, 3), (int8x16_t)xmmword_228F61DE0), v81)), v87), v86);
              unsigned int v32 = v88.u16[7];
              int8x16_t v27 = (int8x16_t)vaddq_s16(vaddq_s16(v83, v87), v86);
              int8x16_t v28 = (int8x16_t)vaddq_s16(v84, v87);
              int v64 = v66 + 4;
              *uint64_t v66 = v28;
              v66[1] = (int8x16_t)vaddq_s16(v85, v87);
              v66[2] = v27;
              v66[3] = (int8x16_t)v88;
              unint64_t v63 = v53 + 32;
              unint64_t v89 = v53 + 64;
              v53 += 32;
              v66 += 4;
            }
            while (v89 <= v25);
          }
          else
          {
            unint64_t v63 = v53;
            int v64 = a8;
          }
          if (v63 + 8 <= v25)
          {
            do
            {
              v27.i64[0] = *(void *)(v30 + v63);
              v28.i64[0] = *(void *)(v22 + v30 + v63);
              int16x8_t v91 = (int16x8_t)vzip1q_s8(v28, v27);
              int8x16_t v92 = (int8x16_t)vaddq_s16((int16x8_t)vshlq_n_s32((int32x4_t)v91, 0x10uLL), v91);
              int16x8_t v93 = vaddq_s16((int16x8_t)vandq_s8(vqtbl1q_s8(v92, (int8x16_t)xmmword_228F61DD0), v29), (int16x8_t)v92);
              int8x16_t v28 = vandq_s8((int8x16_t)vdupq_lane_s16(*(int16x4_t *)v93.i8, 3), (int8x16_t)xmmword_228F61DE0);
              int8x16_t v27 = (int8x16_t)vaddq_s16(vaddq_s16(v93, vdupq_n_s16(v32)), (int16x8_t)v28);
              unsigned int v32 = v27.u16[7];
              *v64++ = v27;
              unint64_t v90 = v63 + 8;
              unint64_t v94 = v63 + 16;
              v63 += 8;
            }
            while (v94 <= v25);
          }
          else
          {
            unint64_t v90 = v63;
          }
          if (v90 < v25)
          {
            unint64_t v95 = v25 - v90;
            uint64_t v96 = (unsigned __int8 *)(v22 + v90 + v30);
            unint64_t v97 = (unsigned __int8 *)(v30 + v90);
            do
            {
              int v99 = *v97++;
              int v98 = v99;
              int v100 = *v96++;
              v32 += v100 | (v98 << 8);
              v64->i16[0] = v32;
              int v64 = (int8x16_t *)((char *)v64 + 2);
              --v95;
            }
            while (v95);
          }
        }
        a8 = (int8x16_t *)((char *)a8 + a9);
        v21 += v26;
      }
      while (v21 + (unint64_t)a3[7].u32[0] < v103);
    }
  }
  return result;
}

unint64_t CompressedPlanar<float,(StreamType)1>(unint64_t result, uint64_t a2, int32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int8x16_t *a8, uint64_t a9)
{
  unint64_t v98 = result;
  if (a6)
  {
    unint64_t v14 = *(void *)(a2 + 56);
    int32x4_t v15 = *(ChannelDescription **)(a4 + 8);
    int32x2_t v16 = a3[3];
    uint64_t v17 = v16.u32[0];
    int32x2_t v95 = v16;
    unint64_t v97 = HIDWORD(v14);
    uint64_t v18 = a3[7].u32[1];
    int32x2_t v19 = *(int32x2_t *)((char *)v15 + 48);
    int32x2_t v20 = *(int32x2_t *)(*(void *)(*((void *)v15 + 5) + 8 * v18) + 16);
    uint64_t result = ChannelDescription::GetLocationForTile(v15, (a3[6].i32[1] + v16.i32[1] * HIDWORD(v14)), v16.u32[0], v18);
    uint64_t v21 = a3[6].u32[1];
    if ((unint64_t)a3[7].u32[0] + v21 < HIDWORD(v14))
    {
      uint64_t v22 = vmin_u32((uint32x2_t)vmls_s32(v20, v19, v95), (uint32x2_t)v19).u32[0];
      int v96 = a3[3].i32[1] * *(_DWORD *)(a2 + 60);
      unint64_t v23 = a3[5].u32[1];
      unsigned int v24 = a7;
      uint64_t v25 = 2 * v22;
      unint64_t v26 = v23 + a6;
      uint64_t v94 = v24;
      do
      {
        uint64_t result = ChannelDescription::GetLocationForTile(v15, (v96 + v21), v17, v18);
        unint64_t v30 = v98 + result;
        if (HIDWORD(result)) {
          BOOL v31 = v30 == 0;
        }
        else {
          BOOL v31 = 1;
        }
        if (!v31)
        {
          if (v23 >= 0x20)
          {
            uint64_t v43 = 0;
            unint64_t v44 = v25 + v30;
            uint64_t v45 = v22 + v30;
            v33.i64[0] = 0;
            int8x16_t v35 = (int8x16_t)xmmword_228F61DB0;
            int8x16_t v34 = (int8x16_t)xmmword_228F61E20;
            int8x16_t v36 = (int8x16_t)xmmword_228F61D70;
            int8x16_t v37 = (int8x16_t)xmmword_228F61E10;
            int8x16_t v39 = (int8x16_t)xmmword_228F61D50;
            int8x16_t v38 = (int8x16_t)xmmword_228F61DF0;
            int8x16_t v41 = (int8x16_t)xmmword_228F61D90;
            int8x16_t v40 = (int8x16_t)xmmword_228F61E00;
            int8x16_t v42 = (int8x16_t)xmmword_228F61DC0;
            do
            {
              v101.val[1] = *(int8x16_t *)(v30 + v43);
              v99.val[1] = *(int8x16_t *)(v30 + v43 + 16);
              int8x16_t v46 = *(int8x16_t *)(v45 + v43);
              int8x16_t v47 = *(int8x16_t *)(v45 + v43 + 16);
              v101.val[0] = *(int8x16_t *)(v44 + v43);
              v99.val[0] = *(int8x16_t *)(v44 + v43 + 16);
              v105.val[0] = vqtbl1q_s8(v47, (int8x16_t)xmmword_228F61DF0);
              v105.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61D50);
              v107.val[0] = vqtbl1q_s8(v47, (int8x16_t)xmmword_228F61E00);
              v107.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61D90);
              v109.val[0] = vqtbl1q_s8(v46, (int8x16_t)xmmword_228F61DF0);
              v109.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61D50);
              v111.val[0] = vqtbl1q_s8(v46, (int8x16_t)xmmword_228F61E10);
              v111.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61D70);
              v113.val[0] = vqtbl1q_s8(v46, (int8x16_t)xmmword_228F61E00);
              v113.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61D90);
              v115.val[0] = vqtbl1q_s8(v47, (int8x16_t)xmmword_228F61E10);
              v115.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61D70);
              v104.val[0] = vqtbl1q_s8(v47, (int8x16_t)xmmword_228F61E20);
              v104.val[1] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61DB0);
              v99.val[0] = vqtbl1q_s8(v46, (int8x16_t)xmmword_228F61E20);
              v99.val[1] = vqtbl2q_s8(v101, (int8x16_t)xmmword_228F61DB0);
              v99.val[0] = vqtbl2q_s8(v99, (int8x16_t)xmmword_228F61DC0);
              v99.val[1] = vqtbl2q_s8(v104, (int8x16_t)xmmword_228F61DC0);
              v101.val[0] = vqtbl2q_s8(v115, (int8x16_t)xmmword_228F61DC0);
              v101.val[1] = vqtbl2q_s8(v113, (int8x16_t)xmmword_228F61DC0);
              int32x4_t v48 = (int32x4_t)vqtbl2q_s8(v111, (int8x16_t)xmmword_228F61DC0);
              v104.val[0] = vqtbl2q_s8(v107, (int8x16_t)xmmword_228F61DC0);
              v104.val[1] = vqtbl2q_s8(v105, (int8x16_t)xmmword_228F61DC0);
              v105.val[0] = vqtbl2q_s8(v109, (int8x16_t)xmmword_228F61DC0);
              v99.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v99.val[0], 0x20uLL), (int32x4_t)v99.val[0]);
              v99.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v99.val[1], 0x20uLL), (int32x4_t)v99.val[1]);
              v101.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v101.val[0], 0x20uLL), (int32x4_t)v101.val[0]);
              v101.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v101.val[1], 0x20uLL), (int32x4_t)v101.val[1]);
              int32x4_t v49 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v48, 0x20uLL), v48);
              v105.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v105.val[0], 0x20uLL), (int32x4_t)v105.val[0]);
              v104.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v104.val[0], 0x20uLL), (int32x4_t)v104.val[0]);
              v104.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v104.val[1], 0x20uLL), (int32x4_t)v104.val[1]);
              v111.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v101.val[0].i8, 1);
              v111.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v99.val[1].i8, 1);
              v113.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v99.val[0].i8, 1);
              v113.val[0].i64[0] = 0;
              v111.val[1].i64[0] = 0;
              v111.val[0].i64[0] = 0;
              int8x16_t v29 = (int8x16_t)vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v104.val[1].i8, 1), (int32x4_t)v104.val[1]), 3), vaddq_s32((int32x4_t)v111.val[0], (int32x4_t)v101.val[0]));
              int8x16_t v28 = (int8x16_t)vaddq_s32((int32x4_t)v29, vaddq_s32(vdupq_laneq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v104.val[0].i8, 1), (int32x4_t)v104.val[0]), 3), vaddq_s32((int32x4_t)v111.val[1], (int32x4_t)v99.val[1])));
              int8x16_t v27 = (int8x16_t)vaddq_s32((int32x4_t)v28, vaddq_s32(vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v101.val[1].i8, 1), (int32x4_t)v101.val[1]), vaddq_s32((int32x4_t)v113.val[0], (int32x4_t)v99.val[0])), vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v105.val[0].i8, 1), (int32x4_t)v105.val[0]), vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v49.i8, 1), v49))));
              int32x4_t v33 = vaddq_s32((int32x4_t)v27, vdupq_lane_s32(*(int32x2_t *)v33.i8, 0));
              v33.i32[0] = v33.i32[3];
              unint64_t v32 = v43 + 32;
              unint64_t v50 = v43 + 64;
              v43 += 32;
            }
            while (v50 <= v23);
          }
          else
          {
            unint64_t v32 = 0;
            v33.i64[0] = 0;
            int8x16_t v35 = (int8x16_t)xmmword_228F61DB0;
            int8x16_t v34 = (int8x16_t)xmmword_228F61E20;
            int8x16_t v36 = (int8x16_t)xmmword_228F61D70;
            int8x16_t v37 = (int8x16_t)xmmword_228F61E10;
            int8x16_t v39 = (int8x16_t)xmmword_228F61D50;
            int8x16_t v38 = (int8x16_t)xmmword_228F61DF0;
            int8x16_t v41 = (int8x16_t)xmmword_228F61D90;
            int8x16_t v40 = (int8x16_t)xmmword_228F61E00;
            int8x16_t v42 = (int8x16_t)xmmword_228F61DC0;
          }
          if ((v32 | 8) <= v23)
          {
            do
            {
              v27.i64[0] = *(void *)(v30 + v32);
              v28.i64[0] = *(void *)(v22 + v30 + v32);
              v29.i64[0] = *(void *)(v25 + v30 + v32);
              int8x16_t v52 = vzip1q_s8((int8x16_t)0, v28);
              int8x16_t v53 = vzip1q_s8(v29, v27);
              int32x4_t v54 = (int32x4_t)vzip1q_s8(v52, v53);
              int32x4_t v55 = (int32x4_t)vzip2q_s8(v52, v53);
              int8x16_t v27 = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v55, 0x20uLL), v55);
              int8x16_t v28 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v27.i8, 1);
              int32x4_t v56 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v54, 0x20uLL), v54);
              int8x16_t v29 = (int8x16_t)vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v56.i8, 1), v56);
              int32x4_t v33 = vaddq_s32((int32x4_t)v28, vaddq_s32((int32x4_t)v27, vdupq_lane_s32(*(int32x2_t *)v33.i8, 0)));
              v33.i32[0] = v33.i32[3] + v29.i32[3];
              unint64_t v51 = v32 + 8;
              unint64_t v57 = v32 + 16;
              v32 += 8;
            }
            while (v57 <= v23);
          }
          else
          {
            unint64_t v51 = v32;
          }
          if (v51 <= v23) {
            unint64_t v58 = v23;
          }
          else {
            unint64_t v58 = v51;
          }
          if (v58 + 32 <= v26)
          {
            unint64_t v61 = v25 + v30;
            uint64_t v62 = v22 + v30;
            unint64_t v63 = a8;
            do
            {
              v100.val[1] = *(int8x16_t *)(v30 + v58);
              v102.val[1] = *(int8x16_t *)(v30 + v58 + 16);
              int8x16_t v65 = *(int8x16_t *)(v62 + v58);
              int8x16_t v64 = *(int8x16_t *)(v62 + v58 + 16);
              v100.val[0] = *(int8x16_t *)(v61 + v58);
              v102.val[0] = *(int8x16_t *)(v61 + v58 + 16);
              v106.val[0] = vqtbl1q_s8(v65, v34);
              v106.val[1] = vqtbl2q_s8(v100, v35);
              v108.val[0] = vqtbl1q_s8(v65, v37);
              v108.val[1] = vqtbl2q_s8(v100, v36);
              v110.val[0] = vqtbl1q_s8(v64, v34);
              v110.val[1] = vqtbl2q_s8(v102, v35);
              v112.val[0] = vqtbl1q_s8(v64, v37);
              v112.val[1] = vqtbl2q_s8(v102, v36);
              v114.val[0] = vqtbl1q_s8(v64, v38);
              v114.val[1] = vqtbl2q_s8(v102, v39);
              v116.val[0] = vqtbl1q_s8(v64, v40);
              v116.val[1] = vqtbl2q_s8(v102, v41);
              v102.val[0] = vqtbl1q_s8(v65, v38);
              v102.val[1] = vqtbl2q_s8(v100, v39);
              v103.val[0] = vqtbl1q_s8(v65, v40);
              v103.val[1] = vqtbl2q_s8(v100, v41);
              v100.val[0] = vqtbl2q_s8(v103, v42);
              v100.val[1] = vqtbl2q_s8(v102, v42);
              v102.val[0] = vqtbl2q_s8(v116, v42);
              v102.val[1] = vqtbl2q_s8(v114, v42);
              v103.val[0] = vqtbl2q_s8(v112, v42);
              v103.val[1] = vqtbl2q_s8(v110, v42);
              int32x4_t v66 = (int32x4_t)vqtbl2q_s8(v108, v42);
              v106.val[0] = vqtbl2q_s8(v106, v42);
              v100.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v100.val[0], 0x20uLL), (int32x4_t)v100.val[0]);
              v100.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v100.val[1], 0x20uLL), (int32x4_t)v100.val[1]);
              v102.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v102.val[0], 0x20uLL), (int32x4_t)v102.val[0]);
              v102.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v102.val[1], 0x20uLL), (int32x4_t)v102.val[1]);
              v103.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v103.val[0], 0x20uLL), (int32x4_t)v103.val[0]);
              v103.val[1] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v103.val[1], 0x20uLL), (int32x4_t)v103.val[1]);
              int32x4_t v67 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v66, 0x20uLL), v66);
              v106.val[0] = (int8x16_t)vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v106.val[0], 0x20uLL), (int32x4_t)v106.val[0]);
              v106.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v106.val[0].i8, 1);
              v108.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v67.i8, 1);
              v108.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v103.val[1].i8, 1);
              v110.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v103.val[0].i8, 1);
              v110.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v102.val[1].i8, 1);
              v112.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v102.val[0].i8, 1);
              v112.val[1] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v100.val[1].i8, 1);
              v114.val[0] = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v100.val[0].i8, 1);
              v114.val[0].i64[0] = 0;
              v112.val[1].i64[0] = 0;
              v112.val[0].i64[0] = 0;
              v110.val[1].i64[0] = 0;
              v110.val[0].i64[0] = 0;
              v108.val[1].i64[0] = 0;
              v108.val[0].i64[0] = 0;
              v106.val[1].i64[0] = 0;
              v102.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v110.val[1], (int32x4_t)v102.val[1]);
              v100.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v112.val[1], (int32x4_t)v100.val[1]);
              v100.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v114.val[0], (int32x4_t)v100.val[0]);
              v102.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v112.val[0], (int32x4_t)v102.val[0]);
              v103.val[1] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v102.val[0], 3), vaddq_s32((int32x4_t)v108.val[1], (int32x4_t)v103.val[1]));
              v106.val[0] = (int8x16_t)vaddq_s32(vdupq_laneq_s32((int32x4_t)v100.val[0], 3), vaddq_s32((int32x4_t)v106.val[1], (int32x4_t)v106.val[0]));
              v106.val[1] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v106.val[0], 3);
              int32x4_t v68 = vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v100.val[1], 3), vaddq_s32((int32x4_t)v108.val[0], v67)), (int32x4_t)v106.val[1]);
              v108.val[0] = (int8x16_t)vdupq_laneq_s32((int32x4_t)v103.val[1], 3);
              v103.val[0] = (int8x16_t)vaddq_s32(vaddq_s32(vdupq_laneq_s32((int32x4_t)v102.val[1], 3), vaddq_s32((int32x4_t)v110.val[0], (int32x4_t)v103.val[0])), (int32x4_t)v108.val[0]);
              v102.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v102.val[1], (int32x4_t)v108.val[0]);
              v108.val[0] = (int8x16_t)vdupq_laneq_s32(v68, 3);
              int32x4_t v69 = vdupq_lane_s32(*(int32x2_t *)v33.i8, 0);
              v102.val[0] = (int8x16_t)vaddq_s32((int32x4_t)v102.val[0], v69);
              v103.val[0] = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v103.val[0], v69), (int32x4_t)v108.val[0]);
              v102.val[1] = (int8x16_t)vaddq_s32((int32x4_t)v102.val[1], v69);
              int32x4_t v70 = vaddq_s32(v68, v69);
              *(int32x4_t *)unint64_t v63 = vaddq_s32((int32x4_t)v100.val[0], v69);
              v63[1] = (int8x16_t)vaddq_s32((int32x4_t)v106.val[0], v69);
              int8x16_t v27 = (int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)v103.val[1], v69), (int32x4_t)v108.val[0]);
              int32x4_t v33 = vaddq_s32(vaddq_s32((int32x4_t)v100.val[1], v69), (int32x4_t)v106.val[1]);
              v63[2] = (int8x16_t)v33;
              v63[3] = (int8x16_t)v70;
              int8x16_t v28 = (int8x16_t)vaddq_s32((int32x4_t)v102.val[0], (int32x4_t)v108.val[0]);
              int8x16_t v29 = (int8x16_t)vaddq_s32((int32x4_t)v102.val[1], (int32x4_t)v108.val[0]);
              v33.i32[0] = v103.val[0].i32[3];
              int v60 = v63 + 8;
              v63[6] = v29;
              v63[7] = v103.val[0];
              v63[4] = v28;
              v63[5] = v27;
              unint64_t v59 = v58 + 32;
              unint64_t v71 = v58 + 64;
              v58 += 32;
              v63 += 8;
            }
            while (v71 <= v26);
          }
          else
          {
            unint64_t v59 = v58;
            int v60 = a8;
          }
          if (v59 + 8 <= v26)
          {
            do
            {
              v27.i64[0] = *(void *)(v30 + v59);
              v28.i64[0] = *(void *)(v22 + v30 + v59);
              v29.i64[0] = *(void *)(v25 + v30 + v59);
              int8x16_t v74 = vzip1q_s8((int8x16_t)0, v28);
              int8x16_t v75 = vzip1q_s8(v29, v27);
              int32x4_t v76 = (int32x4_t)vzip1q_s8(v74, v75);
              int32x4_t v77 = (int32x4_t)vzip2q_s8(v74, v75);
              int32x4_t v78 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v76, 0x20uLL), v76);
              int32x4_t v79 = vaddq_s32((int32x4_t)vshlq_n_s64((int64x2_t)v77, 0x20uLL), v77);
              int8x16_t v28 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v79.i8, 1);
              int32x4_t v80 = vdupq_lane_s32(*(int32x2_t *)v78.i8, 1);
              v80.i64[0] = 0;
              v28.i64[0] = 0;
              int32x4_t v81 = vaddq_s32(v80, v78);
              int32x4_t v82 = vdupq_laneq_s32(v81, 3);
              int32x4_t v83 = vdupq_lane_s32(*(int32x2_t *)v33.i8, 0);
              int8x16_t v29 = (int8x16_t)vaddq_s32(v81, v83);
              int32x4_t v33 = vaddq_s32((int32x4_t)v28, vaddq_s32(v79, v83));
              int8x16_t v27 = (int8x16_t)vaddq_s32(v33, v82);
              v33.i32[0] = v27.i32[3];
              int16x8_t v73 = v60 + 2;
              *int v60 = v29;
              v60[1] = v27;
              unint64_t v72 = v59 + 8;
              unint64_t v84 = v59 + 16;
              v59 += 8;
              v60 += 2;
            }
            while (v84 <= v26);
          }
          else
          {
            unint64_t v72 = v59;
            int16x8_t v73 = v60;
          }
          if (v72 < v26)
          {
            unint64_t v85 = v26 - v72;
            int16x8_t v86 = (unsigned __int8 *)(v25 + v72 + v30);
            int16x8_t v87 = (unsigned __int8 *)(v22 + v72 + v30);
            int16x8_t v88 = (unsigned __int8 *)(v30 + v72);
            do
            {
              int v89 = *v88++;
              int v90 = v89 << 24;
              int v92 = *v87++;
              int v91 = v92;
              int v93 = *v86++;
              v73->i32[0] = (v90 | (v91 << 16) | (v93 << 8)) + v33.i32[0];
              int16x8_t v73 = (int8x16_t *)((char *)v73 + 4);
              --v85;
            }
            while (v85);
          }
        }
        a8 = (int8x16_t *)((char *)a8 + a9);
        v21 += v94;
      }
      while (v21 + (unint64_t)a3[7].u32[0] < v97);
    }
  }
  return result;
}

void TileDecoder_PXR24::~TileDecoder_PXR24(void **this)
{
  TileDecoder::~TileDecoder(this);

  JUMPOUT(0x22A6AD870);
}

uint64_t TileDecoder::GetPoolSize(TileDecoder *this, uint64_t a2)
{
  return a2;
}

uint64_t TileDecoder_PXR24::GetCompressionMethod(TileDecoder_PXR24 *this)
{
  return 5;
}

BOOL TileDecoder::IsTileUncompressed(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8) == *(void *)(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 24) + 280)
                                                                  + 8 * *(unsigned int *)(a2 + 60))
                                                      + 8)
                                          + 8 * *(unsigned int *)(a2 + 32));
}

uint64_t TileDecoder_ScanlineCompressed::Interleave(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, unsigned int a5, unsigned int a6)
{
  v13[0] = 0;
  v13[1] = 0;
  int v15 = 0;
  uint64_t v14 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a1, a4, a5, a6, (unsigned int *)v13);
  if (HIDWORD(v14)) {
    BOOL v10 = v15 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    uint64_t v11 = *(void **)(a1 + 64);
    int v12 = *(_DWORD *)(v11[1] + 72);
    if (*(_DWORD *)(a1 + 72) == 2) {
      return (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))((char *)&TileDecoder_ScanlineCompressed::Interleave(void const*,unsigned long,TileInfo const&,unsigned int,unsigned int,void *,unsigned long,long)const::funcTable[2]
    }
                                                                   + ((8 * (v12 != 1)) | (32 * (v11[3] != 0)))))(a2, a1, a4);
    else {
      return (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))((char *)&TileDecoder_ScanlineCompressed::Interleave(void const*,unsigned long,TileInfo const&,unsigned int,unsigned int,void *,unsigned long,long)const::funcTable[2]
    }
                                                                   + ((8 * (v12 != 1)) | (32 * (v11[3] != 0)) | ((unint64_t)(v11[5] != 0) << 6) | ((unint64_t)(v11[7] != 0) << 7))))(a2, a1, a4);
  }
  return result;
}

void CompressedInterleave2<unsigned short,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6, unint64_t a7, unsigned int a8, __int16 *a9, uint64_t a10)
{
  unint64_t v10 = *(void *)(a2 + 56);
  if (v10)
  {
    uint64_t v11 = *a4;
    if (*(unsigned char *)(*a4 + 24)) {
      _D0 = *(double *)v11;
    }
    else {
      _D0 = NAN;
    }
    int v13 = *(_DWORD *)(v11 + 16);
    if (v13 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v13 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v34) = _H0;
      LOWORD(v34) = _H0;
      LODWORD(_D0) = v34;
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    uint64_t v19 = *a5;
    if (*(unsigned char *)(*a5 + 24)) {
      _D1 = *(double *)v19;
    }
    else {
      _D1 = NAN;
    }
    unint64_t v21 = HIDWORD(v10);
    int v22 = *(_DWORD *)(v19 + 16);
    if (v22 == 2)
    {
      float v23 = _D1;
    }
    else if (v22 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v35) = _H1;
      LOWORD(v35) = _H1;
      float v23 = v35;
    }
    else
    {
      LODWORD(v23) = _D1;
      if (v22) {
        float v23 = *(float *)&_D0;
      }
    }
    uint64_t v25 = *(unsigned int *)(a3 + 52);
    if ((unint64_t)*(unsigned int *)(a3 + 56) + v25 < v21)
    {
      *((float *)&_D0 + 1) = v23;
      int16x8_t v26 = vdupq_lane_s16(*(int16x4_t *)&_D0, 0);
      int16x8_t v28 = vdupq_lane_s16(*(int16x4_t *)&_D0, 2);
      do
      {
        if (a7 >= 8)
        {
          uint64_t v31 = 0;
          unint64_t v30 = a9;
          do
          {
            vst2q_s16(v30, *(int16x8x2_t *)v26.i8);
            v30 += 16;
            unint64_t v29 = v31 + 8;
            unint64_t v32 = v31 + 16;
            v31 += 8;
          }
          while (v32 <= a7);
        }
        else
        {
          unint64_t v29 = 0;
          unint64_t v30 = a9;
        }
        uint64_t v33 = a7 - v29;
        if (a7 > v29)
        {
          do
          {
            v30[1] = WORD2(_D0);
            *unint64_t v30 = LOWORD(_D0);
            v30 += 2;
            --v33;
          }
          while (v33);
        }
        a9 = (__int16 *)((char *)a9 + a10);
        v25 += a8;
      }
      while (v25 + (unint64_t)*(unsigned int *)(a3 + 56) < v21);
    }
  }
}

void CompressedInterleave2<unsigned int,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6, unint64_t a7, unsigned int a8, float *a9, uint64_t a10)
{
  unint64_t v10 = *(void *)(a2 + 56);
  if (v10)
  {
    uint64_t v11 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v11 : NAN;
    int v13 = *(_DWORD *)(v11 + 16);
    if (v13 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v13 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v37) = _H0;
      LOWORD(v37) = _H0;
      LODWORD(_D0) = v37;
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    uint64_t v19 = *a5;
    _D1 = *(unsigned char *)(*a5 + 24) ? *(double *)v19 : NAN;
    unint64_t v21 = HIDWORD(v10);
    int v22 = *(_DWORD *)(v19 + 16);
    if (v22 == 2)
    {
      float v24 = _D1;
    }
    else if (v22 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v38) = _H1;
      LOWORD(v38) = _H1;
      float v24 = v38;
    }
    else
    {
      unsigned int v23 = _D1;
      float v24 = v22 ? *(float *)&_D0 : *(float *)&v23;
    }
    uint64_t v26 = *(unsigned int *)(a3 + 52);
    if ((unint64_t)*(unsigned int *)(a3 + 56) + v26 < v21)
    {
      int32x4_t v28 = vdupq_n_s32(LODWORD(_D0));
      int32x4_t v29 = vdupq_n_s32(LODWORD(v24));
      *((float *)&_D0 + 1) = v24;
      do
      {
        if (a7 >= 8)
        {
          uint64_t v32 = 0;
          uint64_t v33 = a9;
          do
          {
            uint64_t v31 = (double *)(v33 + 16);
            vst2q_f32(v33, *(float32x4x2_t *)v28.i8);
            int v34 = v33 + 8;
            vst2q_f32(v34, *(float32x4x2_t *)v28.i8);
            unint64_t v30 = v32 + 8;
            unint64_t v35 = v32 + 16;
            v32 += 8;
            uint64_t v33 = (float *)v31;
          }
          while (v35 <= a7);
        }
        else
        {
          unint64_t v30 = 0;
          uint64_t v31 = (double *)a9;
        }
        uint64_t v36 = a7 - v30;
        if (a7 > v30)
        {
          do
          {
            *v31++ = _D0;
            --v36;
          }
          while (v36);
        }
        a9 = (float *)((char *)a9 + a10);
        v26 += a8;
      }
      while (v26 + (unint64_t)*(unsigned int *)(a3 + 56) < v21);
    }
  }
}

uint64_t CompressedInterleave2<unsigned short,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t a6, unint64_t a7, unsigned int a8, __int16 *a9, uint64_t a10)
{
  unint64_t v11 = *(void *)(a2 + 56);
  if (v11)
  {
    uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v41, result, a2, a4, (uint64_t)a3);
    uint64_t v17 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v17 : NAN;
    unint64_t v19 = HIDWORD(v11);
    int v20 = *(_DWORD *)(v17 + 16);
    if (v20 == 2)
    {
      *(float *)&unsigned int v21 = _D0;
    }
    else if (v20 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v44) = _H0;
      LOWORD(v44) = _H0;
      unsigned int v21 = v44;
    }
    else
    {
      unsigned int v21 = _D0;
    }
    uint64_t v27 = a3[13];
    if ((unint64_t)a3[14] + v27 < v19)
    {
      int v29 = a3[7] * *(_DWORD *)(a2 + 60);
      __int16 v30 = v21;
      int16x8_t v31 = vdupq_n_s16(v21);
      do
      {
        int8x16_t v38 = v16;
        int16x8_t v39 = v31;
        int v42 = v29 + v27;
        uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v41);
        if (a7 >= 8)
        {
          uint64_t v36 = 0;
          unint64_t v35 = a9;
          int16x8_t v31 = v39;
          do
          {
            v32.i64[0] = *(void *)(v36 + v41[0]);
            v33.i64[0] = *(void *)(v36 + v43 + v41[0]);
            int8x16_t v16 = vzip1q_s8(v32, v33);
            vst2q_s16(v35, *(int16x8x2_t *)v16.i8);
            v35 += 16;
            unint64_t v34 = v36 + 8;
            unint64_t v37 = v36 + 16;
            v36 += 8;
          }
          while (v37 <= a7);
        }
        else
        {
          unint64_t v34 = 0;
          unint64_t v35 = a9;
          int8x16_t v16 = v38;
          int16x8_t v31 = v39;
        }
        if (v34 < a7)
        {
          do
          {
            LOBYTE(v40) = *(unsigned char *)(v34 + v41[0]);
            HIBYTE(v40) = *(unsigned char *)(v34 + v43 + v41[0]);
            v35[1] = v30;
            *unint64_t v35 = v40;
            v35 += 2;
            ++v34;
          }
          while (a7 != v34);
        }
        a9 = (__int16 *)((char *)a9 + a10);
        v27 += a8;
      }
      while (v27 + (unint64_t)a3[14] < v19);
    }
  }
  return result;
}

uint64_t CompressedInterleave2<unsigned int,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t a6, unint64_t a7, unsigned int a8, float *a9, uint64_t a10)
{
  unint64_t v11 = *(void *)(a2 + 56);
  if (v11)
  {
    uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v49, result, a2, a4, (uint64_t)a3);
    uint64_t v17 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v17 : NAN;
    unint64_t v19 = HIDWORD(v11);
    int v20 = *(_DWORD *)(v17 + 16);
    if (v20 == 2)
    {
      *(float *)&unsigned int v21 = _D0;
    }
    else if (v20 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v52) = _H0;
      LOWORD(v52) = _H0;
      unsigned int v21 = v52;
    }
    else
    {
      unsigned int v21 = _D0;
    }
    uint64_t v27 = a3[13];
    if ((unint64_t)a3[14] + v27 < v19)
    {
      unsigned int v29 = v21;
      int v30 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v31 = vdupq_n_s32(v21);
      do
      {
        int8x16_t v47 = v16;
        int32x4_t v48 = v31;
        int v50 = v30 + v27;
        uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v49);
        if (a7 >= 8)
        {
          uint64_t v36 = 0;
          unint64_t v37 = (int8x16_t *)v49[0];
          uint64_t v38 = v51;
          int16x8_t v39 = a9;
          int32x4_t v31 = v48;
          do
          {
            int8x16_t v40 = *v37;
            int8x16_t v41 = *(int8x16_t *)((char *)v37 + v38);
            int8x16_t v16 = vzip1q_s8(*v37, v41);
            unint64_t v35 = v39 + 16;
            vst2q_f32(v39, *(float32x4x2_t *)v16.i8);
            int v42 = v39 + 8;
            int16x8_t v32 = (int16x8_t)vzip2q_s8(v40, v41);
            int16x8_t v33 = (int16x8_t)v48;
            vst2q_f32(v42, *(float32x4x2_t *)v32.i8);
            unint64_t v34 = v36 + 8;
            unint64_t v43 = v36 + 16;
            ++v37;
            v36 += 8;
            int16x8_t v39 = v35;
          }
          while (v43 <= a7);
        }
        else
        {
          unint64_t v34 = 0;
          unint64_t v35 = a9;
          int8x16_t v16 = v47;
          int32x4_t v31 = v48;
        }
        uint64_t v44 = a7 - v34;
        if (a7 > v34)
        {
          uint64_t v45 = 2 * v34;
          do
          {
            int8x16_t v46 = (unsigned __int8 *)(v45 + v51 + v49[0]);
            v32.i32[0] = *(unsigned __int8 *)(v45 + v49[0]);
            v32.i8[4] = *(unsigned char *)(v45 + v49[0] + 1);
            v33.i32[0] = *v46;
            v33.i8[4] = v46[1];
            int16x8_t v32 = vtrn1q_s16(v32, v33);
            v32.i32[0] = vmovn_s16(v32).u32[0];
            v32.i32[1] = v29;
            *(void *)unint64_t v35 = v32.i64[0];
            v35 += 2;
            v45 += 2;
            --v44;
          }
          while (v44);
        }
        a9 = (float *)((char *)a9 + a10);
        v27 += a8;
      }
      while (v27 + (unint64_t)a3[14] < v19);
    }
  }
  return result;
}

uint64_t CompressedInterleave2<unsigned short,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, __int16 *a9, uint64_t a10)
{
  unint64_t v11 = *(void *)(a2 + 56);
  if (v11)
  {
    uint64_t v15 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v15 : NAN;
    unint64_t v17 = HIDWORD(v11);
    int v18 = *(_DWORD *)(v15 + 16);
    if (v18 == 2)
    {
      *(float *)&unsigned int v19 = _D0;
    }
    else if (v18 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v40[0]) = _H0;
      LOWORD(v40[0]) = _H0;
      unsigned int v19 = v40[0];
    }
    else
    {
      unsigned int v19 = _D0;
    }
    uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v40, result, a2, a5, (uint64_t)a3);
    uint64_t v26 = a3[13];
    if ((unint64_t)a3[14] + v26 < v17)
    {
      int v28 = a3[7] * *(_DWORD *)(a2 + 60);
      int16x8_t v29 = vdupq_n_s16(v19);
      do
      {
        int16x8_t v37 = v29;
        int8x16_t v38 = v25;
        int v41 = v28 + v26;
        uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v40);
        if (a7 >= 8)
        {
          uint64_t v35 = 0;
          int16x8_t v33 = a9;
          __int16 v34 = v19;
          int16x8_t v29 = v37;
          do
          {
            v30.i64[0] = *(void *)(v35 + v40[0]);
            v31.i64[0] = *(void *)(v35 + v42 + v40[0]);
            int8x16_t v25 = vzip1q_s8(v30, v31);
            vst2q_s16(v33, *(int16x8x2_t *)(&v25 - 1));
            v33 += 16;
            unint64_t v32 = v35 + 8;
            unint64_t v36 = v35 + 16;
            v35 += 8;
          }
          while (v36 <= a7);
        }
        else
        {
          unint64_t v32 = 0;
          int16x8_t v33 = a9;
          __int16 v34 = v19;
          int16x8_t v29 = v37;
          int8x16_t v25 = v38;
        }
        if (v32 < a7)
        {
          do
          {
            LOBYTE(v39) = *(unsigned char *)(v32 + v40[0]);
            HIBYTE(v39) = *(unsigned char *)(v32 + v42 + v40[0]);
            *int16x8_t v33 = v34;
            v33[1] = v39;
            v33 += 2;
            ++v32;
          }
          while (a7 != v32);
        }
        a9 = (__int16 *)((char *)a9 + a10);
        v26 += a8;
      }
      while (v26 + (unint64_t)a3[14] < v17);
    }
  }
  return result;
}

uint64_t CompressedInterleave2<unsigned int,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, __n128 _Q0, uint64_t a7, unint64_t a8, unsigned int a9, float *a10, uint64_t a11)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v16 = *a4;
    _Q0.n128_u64[0] = *(unsigned char *)(*a4 + 24) ? *(void *)v16 : 0x7FF8000000000000;
    unint64_t v17 = HIDWORD(v12);
    int v18 = *(_DWORD *)(v16 + 16);
    if (v18 == 2)
    {
      _Q0.n128_f32[0] = _Q0.n128_f64[0];
    }
    else if (v18 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v46[0]) = _H0;
      LOWORD(v46[0]) = _H0;
      _Q0.n128_u32[0] = v46[0];
    }
    else
    {
      _Q0.n128_u32[0] = _Q0.n128_f64[0];
    }
    __n128 v43 = _Q0;
    uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v46, result, a2, a5, (uint64_t)a3);
    uint64_t v25 = a3[13];
    if ((unint64_t)a3[14] + v25 < v17)
    {
      int v27 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v28 = vdupq_n_s32(v43.n128_u32[0]);
      do
      {
        float32x4_t v44 = (float32x4_t)v28;
        int8x16_t v45 = v24;
        int v47 = v27 + v25;
        uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v46);
        if (a8 >= 8)
        {
          uint64_t v34 = 0;
          uint64_t v35 = (int8x16_t *)v46[0];
          uint64_t v36 = v48;
          int16x8_t v37 = a10;
          __n128 v33 = v43;
          int32x4_t v28 = (int32x4_t)v44;
          do
          {
            int16x8_t v29 = *(int16x8_t *)v35;
            int8x16_t v30 = *(int8x16_t *)((char *)v35 + v36);
            v49.val[1] = (float32x4_t)vzip1q_s8(*v35, v30);
            int8x16_t v24 = vzip2q_s8(*v35, v30);
            unint64_t v32 = v37 + 16;
            v49.val[0] = v44;
            vst2q_f32(v37, v49);
            int8x16_t v38 = v37 + 8;
            vst2q_f32(v38, *(float32x4x2_t *)(&v24 - 1));
            unint64_t v31 = v34 + 8;
            unint64_t v39 = v34 + 16;
            ++v35;
            v34 += 8;
            int16x8_t v37 = v32;
          }
          while (v39 <= a8);
        }
        else
        {
          unint64_t v31 = 0;
          unint64_t v32 = a10;
          __n128 v33 = v43;
          int32x4_t v28 = (int32x4_t)v44;
          int8x16_t v24 = v45;
        }
        uint64_t v40 = a8 - v31;
        if (a8 > v31)
        {
          uint64_t v41 = 2 * v31;
          do
          {
            uint64_t v42 = (unsigned __int8 *)(v41 + v48 + v46[0]);
            v29.i32[0] = *(unsigned __int8 *)(v41 + v46[0]);
            v29.i8[4] = *(unsigned char *)(v41 + v46[0] + 1);
            v30.i32[0] = *v42;
            v30.i8[4] = v42[1];
            int16x8_t v29 = vtrn1q_s16(v29, (int16x8_t)v30);
            *(int8x8_t *)v29.i8 = vmovn_s16(v29);
            int8x16_t v30 = (int8x16_t)v33;
            v30.i32[1] = v29.i32[0];
            *(void *)unint64_t v32 = v30.i64[0];
            v32 += 2;
            v41 += 2;
            --v40;
          }
          while (v40);
        }
        a10 = (float *)((char *)a10 + a11);
        v25 += a9;
      }
      while (v25 + (unint64_t)a3[14] < v17);
    }
  }
  return result;
}

uint64_t CompressedInterleave2<unsigned short,(StreamType)1,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, __int16 *a9, uint64_t a10)
{
  unint64_t v10 = *(void *)(a2 + 56);
  if (v10)
  {
    uint64_t v16 = result;
    unint64_t v17 = HIDWORD(v10);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v34, result, a2, a4, (uint64_t)a3);
    uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v31, v16, a2, a5, (uint64_t)a3);
    uint64_t v18 = a3[13];
    if ((unint64_t)a3[14] + v18 < v17)
    {
      int v20 = a3[7] * *(_DWORD *)(a2 + 60);
      do
      {
        int v35 = v20 + v18;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v34);
        int v32 = v20 + v18;
        uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v31);
        if (a7 >= 8)
        {
          uint64_t v27 = 0;
          uint64_t v26 = a9;
          do
          {
            v21.i64[0] = *(void *)(v27 + v34[0]);
            v22.i64[0] = *(void *)(v27 + v36 + v34[0]);
            int8x16_t v21 = vzip1q_s8(v21, v22);
            v23.i64[0] = *(void *)(v27 + v31[0]);
            v24.i64[0] = *(void *)(v27 + v33 + v31[0]);
            int8x16_t v22 = vzip1q_s8(v23, v24);
            vst2q_s16(v26, *(int16x8x2_t *)v21.i8);
            v26 += 16;
            unint64_t v25 = v27 + 8;
            unint64_t v28 = v27 + 16;
            v27 += 8;
          }
          while (v28 <= a7);
        }
        else
        {
          unint64_t v25 = 0;
          uint64_t v26 = a9;
        }
        if (v25 < a7)
        {
          do
          {
            LOBYTE(v30) = *(unsigned char *)(v25 + v34[0]);
            HIBYTE(v30) = *(unsigned char *)(v25 + v36 + v34[0]);
            LOBYTE(v29) = *(unsigned char *)(v25 + v31[0]);
            HIBYTE(v29) = *(unsigned char *)(v25 + v33 + v31[0]);
            v26[1] = v29;
            __int16 *v26 = v30;
            v26 += 2;
            ++v25;
          }
          while (a7 != v25);
        }
        a9 = (__int16 *)((char *)a9 + a10);
        v18 += a8;
      }
      while (v18 + (unint64_t)a3[14] < v17);
    }
  }
  return result;
}

uint64_t CompressedInterleave2<unsigned int,(StreamType)1,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, float *a9, uint64_t a10)
{
  unint64_t v10 = *(void *)(a2 + 56);
  if (v10)
  {
    uint64_t v16 = result;
    unint64_t v17 = HIDWORD(v10);
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v45, result, a2, a4, (uint64_t)a3);
    uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v42, v16, a2, a5, (uint64_t)a3);
    uint64_t v18 = a3[13];
    if ((unint64_t)a3[14] + v18 < v17)
    {
      int v20 = a3[7] * *(_DWORD *)(a2 + 60);
      do
      {
        int v46 = v20 + v18;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v45);
        int v43 = v20 + v18;
        uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v42);
        if (a7 >= 8)
        {
          uint64_t v26 = 0;
          uint64_t v28 = v44;
          uint64_t v27 = (int8x16_t *)v45[0];
          uint64_t v29 = v47;
          __int16 v30 = a9;
          unint64_t v31 = (int8x16_t *)v42[0];
          do
          {
            int8x16_t v32 = *(int8x16_t *)((char *)v27 + v29);
            int16x8_t v23 = (int16x8_t)vzip2q_s8(*v27, v32);
            int16x8_t v21 = (int16x8_t)vzip1q_s8(*v27, v32);
            int8x16_t v33 = *v31;
            int8x16_t v34 = *(int8x16_t *)((char *)v31 + v28);
            int16x8_t v22 = (int16x8_t)vzip1q_s8(*v31, v34);
            unint64_t v25 = v30 + 16;
            vst2q_f32(v30, *(float32x4x2_t *)v21.i8);
            int v35 = v30 + 8;
            int8x16_t v36 = vzip2q_s8(v33, v34);
            vst2q_f32(v35, *(float32x4x2_t *)v23.i8);
            unint64_t v24 = v26 + 8;
            unint64_t v37 = v26 + 16;
            ++v31;
            ++v27;
            v26 += 8;
            __int16 v30 = v25;
          }
          while (v37 <= a7);
        }
        else
        {
          unint64_t v24 = 0;
          unint64_t v25 = a9;
        }
        uint64_t v38 = a7 - v24;
        if (a7 > v24)
        {
          uint64_t v39 = 2 * v24;
          do
          {
            uint64_t v40 = (unsigned __int8 *)(v39 + v47 + v45[0]);
            v21.i32[0] = *(unsigned __int8 *)(v39 + v45[0]);
            v21.i8[4] = *(unsigned char *)(v39 + v45[0] + 1);
            v22.i32[0] = *v40;
            v22.i8[4] = v40[1];
            int16x8_t v21 = vtrn1q_s16(v21, v22);
            v21.i32[0] = vmovn_s16(v21).u32[0];
            uint64_t v41 = (unsigned __int8 *)(v39 + v44 + v42[0]);
            v22.i32[0] = *(unsigned __int8 *)(v39 + v42[0]);
            v22.i8[4] = *(unsigned char *)(v39 + v42[0] + 1);
            v23.i32[0] = *v41;
            v23.i8[4] = v41[1];
            int16x8_t v22 = vtrn1q_s16(v22, v23);
            *(int8x8_t *)v22.i8 = vmovn_s16(v22);
            v21.i32[1] = v22.i32[0];
            *(void *)unint64_t v25 = v21.i64[0];
            v25 += 2;
            v39 += 2;
            --v38;
          }
          while (v38);
        }
        a9 = (float *)((char *)a9 + a10);
        v18 += a8;
      }
      while (v18 + (unint64_t)a3[14] < v17);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)0>(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, uint64_t *a15, uint64_t a16, unint64_t a17, unsigned int a18, __int16 *a19, uint64_t a20)
{
  unint64_t v21 = *(void *)(a10 + 56);
  if (v21)
  {
    uint64_t v22 = *a12;
    _D0 = *(unsigned char *)(*a12 + 24) ? *(double *)v22 : NAN;
    int v24 = *(_DWORD *)(v22 + 16);
    if (v24 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v24 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v66) = _H0;
      LOWORD(v66) = _H0;
      LODWORD(_D0) = v66;
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    uint64_t v30 = *a13;
    _D1 = *(unsigned char *)(*a13 + 24) ? *(double *)v30 : NAN;
    int v32 = *(_DWORD *)(v30 + 16);
    if (v32 == 2)
    {
      float v34 = _D1;
    }
    else if (v32 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v67) = _H1;
      LOWORD(v67) = _H1;
      float v34 = v67;
    }
    else
    {
      unsigned int v33 = _D1;
      float v34 = v32 ? *(float *)&_D0 : *(float *)&v33;
    }
    uint64_t v36 = *a14;
    _D3 = *(unsigned char *)(*a14 + 24) ? *(double *)v36 : NAN;
    int v38 = *(_DWORD *)(v36 + 16);
    if (v38 == 2)
    {
      *(float *)&a8 = _D3;
    }
    else if (v38 == 1)
    {
      __asm { FCVT            H3, D3 }
      HIWORD(v68) = _H3;
      LOWORD(v68) = _H3;
      LODWORD(a8) = v68;
    }
    else
    {
      LODWORD(v39) = _D3;
      *(float *)&a8 = v38 ? *(float *)&_D0 : v39;
    }
    uint64_t v41 = *a15;
    _D3 = *(unsigned char *)(*a15 + 24) ? *(double *)v41 : NAN;
    unint64_t v43 = HIDWORD(v21);
    int v44 = *(_DWORD *)(v41 + 16);
    if (v44 == 2)
    {
      *(float *)v20.i32 = _D3;
    }
    else if (v44 == 1)
    {
      __asm { FCVT            H3, D3 }
      HIWORD(v69) = _H3;
      LOWORD(v69) = _H3;
      v20.i32[0] = v69;
    }
    else
    {
      LODWORD(v45) = _D3;
      *(float *)v20.i32 = v44 ? *(float *)&_D0 : v45;
    }
    uint64_t v47 = *(unsigned int *)(a11 + 52);
    if ((unint64_t)*(unsigned int *)(a11 + 56) + v47 < v43)
    {
      v70.val[1] = (int8x16_t)vdupq_n_s16(LODWORD(_D0));
      v71.val[1] = (int8x16_t)vdupq_n_s16(LODWORD(v34));
      __int16 v49 = LOWORD(a8);
      v70.val[0] = (int8x16_t)vdupq_lane_s16((int16x4_t)__PAIR64__(v20.u32[0], LODWORD(a8)), 0);
      int8x16_t v50 = vqtbl2q_s8(v70, (int8x16_t)xmmword_228F61E90);
      int8x16_t v51 = vqtbl2q_s8(v70, (int8x16_t)xmmword_228F61EA0);
      v71.val[0] = (int8x16_t)vdupq_lane_s16((int16x4_t)__PAIR64__(v20.u32[0], LODWORD(a8)), 2);
      int8x16_t v52 = vqtbl2q_s8(v71, (int8x16_t)xmmword_228F61E90);
      int32x2_t v53 = vdup_lane_s32(*(int32x2_t *)&a8, 0);
      int8x16_t v54 = vqtbl2q_s8(v71, (int8x16_t)xmmword_228F61EA0);
      v71.val[0].i16[0] = LOWORD(_D0);
      v71.val[0].i16[1] = LOWORD(_D0);
      v71.val[0].i16[2] = v53.i16[0];
      v71.val[0].i16[3] = v53.i16[2];
      int16x4_t v55 = vuzp1_s16(*(int16x4_t *)v71.val[0].i8, vrev32_s16(*(int16x4_t *)v71.val[0].i8));
      int32x2_t v56 = vdup_lane_s32(v20, 0);
      HIWORD(v34) = v56.i16[0];
      LOWORD(v57) = LOWORD(v34);
      HIWORD(v57) = v56.i16[2];
      WORD1(_D0) = LOWORD(v34);
      WORD2(_D0) = v49;
      HIWORD(_D0) = v20.i16[0];
      do
      {
        if (a17 >= 8)
        {
          uint64_t v60 = 0;
          unint64_t v61 = a19;
          do
          {
            unint64_t v59 = v61 + 32;
            vst2q_s16(v61, *(int16x8x2_t *)v51.i8);
            uint64_t v62 = v61 + 16;
            vst2q_s16(v62, *(int16x8x2_t *)v50.i8);
            unint64_t v58 = v60 + 8;
            unint64_t result = v60 + 16;
            v60 += 8;
            unint64_t v61 = v59;
          }
          while (result <= a17);
        }
        else
        {
          unint64_t v58 = 0;
          unint64_t v59 = a19;
        }
        unint64_t v64 = v58 | 2;
        if ((v58 | 2) <= a17)
        {
          do
          {
            vst2_s16(v59, *(int16x4x2_t *)(&v34 - 2));
            v59 += 8;
            v64 += 2;
          }
          while (v64 <= a17);
          unint64_t v58 = v64 - 2;
        }
        _CF = a17 >= v58;
        unint64_t v65 = a17 - v58;
        if (v65 != 0 && _CF)
        {
          do
          {
            *(double *)unint64_t v59 = _D0;
            v59 += 4;
            --v65;
          }
          while (v65);
        }
        a19 = (__int16 *)((char *)a19 + a20);
        v47 += a18;
      }
      while (v47 + (unint64_t)*(unsigned int *)(a11 + 56) < v43);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v13 = *a4;
    if (*(unsigned char *)(*a4 + 24)) {
      *(void *)&_Q0 = *(void *)v13;
    }
    else {
      *(void *)&_Q0 = 0x7FF8000000000000;
    }
    int v15 = *(_DWORD *)(v13 + 16);
    if (v15 == 2)
    {
      *(float *)&_Q0 = *(double *)&_Q0;
    }
    else if (v15 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v54) = _H0;
      LOWORD(v54) = _H0;
      LODWORD(_Q0) = v54;
    }
    else
    {
      LODWORD(_Q0) = *(double *)&_Q0;
    }
    uint64_t v21 = *a5;
    if (*(unsigned char *)(*a5 + 24)) {
      _D1 = *(double *)v21;
    }
    else {
      _D1 = NAN;
    }
    int v23 = *(_DWORD *)(v21 + 16);
    if (v23 == 2)
    {
      float v25 = _D1;
    }
    else if (v23 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v55) = _H1;
      LOWORD(v55) = _H1;
      float v25 = v55;
    }
    else
    {
      unsigned int v24 = _D1;
      if (v23) {
        float v25 = *(float *)&_Q0;
      }
      else {
        float v25 = *(float *)&v24;
      }
    }
    uint64_t v27 = *a6;
    if (*(unsigned char *)(*a6 + 24)) {
      _D3 = *(double *)v27;
    }
    else {
      _D3 = NAN;
    }
    int v29 = *(_DWORD *)(v27 + 16);
    if (v29 == 2)
    {
      float v30 = _D3;
    }
    else if (v29 == 1)
    {
      __asm { FCVT            H3, D3 }
      HIWORD(v56) = _H3;
      LOWORD(v56) = _H3;
      float v30 = v56;
    }
    else
    {
      LODWORD(v30) = _D3;
      if (v29) {
        float v30 = *(float *)&_Q0;
      }
    }
    uint64_t v32 = *a7;
    if (*(unsigned char *)(*a7 + 24)) {
      _D4 = *(double *)v32;
    }
    else {
      _D4 = NAN;
    }
    unint64_t v34 = HIDWORD(v12);
    int v35 = *(_DWORD *)(v32 + 16);
    if (v35 == 2)
    {
      float v37 = _D4;
    }
    else if (v35 == 1)
    {
      __asm { FCVT            H4, D4 }
      HIWORD(v57) = _H4;
      LOWORD(v57) = _H4;
      float v37 = v57;
    }
    else
    {
      unsigned int v36 = _D4;
      if (v35) {
        float v37 = *(float *)&_Q0;
      }
      else {
        float v37 = *(float *)&v36;
      }
    }
    uint64_t v39 = *(unsigned int *)(a3 + 52);
    if ((unint64_t)*(unsigned int *)(a3 + 56) + v39 < v34)
    {
      float v41 = v30;
      *(void *)&long long v42 = __PAIR64__(LODWORD(v30), _Q0);
      *((void *)&v42 + 1) = v42;
      *(void *)&long long v43 = __PAIR64__(LODWORD(v37), LODWORD(v25));
      *((void *)&v43 + 1) = __PAIR64__(LODWORD(v37), LODWORD(v25));
      uint64_t v44 = v42;
      float v45 = v37;
      *((float *)&_Q0 + 1) = v25;
      *((void *)&_Q0 + 1) = __PAIR64__(LODWORD(v37), LODWORD(v41));
      do
      {
        if (a9 >= 4)
        {
          uint64_t v48 = 0;
          __int16 v49 = a11;
          do
          {
            uint64_t v47 = v49 + 16;
            vst2q_f32(v49, *(float32x4x2_t *)&v42);
            int8x16_t v50 = v49 + 8;
            vst2q_f32(v50, *(float32x4x2_t *)&v42);
            unint64_t v46 = v48 + 4;
            unint64_t result = v48 + 8;
            v48 += 4;
            __int16 v49 = v47;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v46 = 0;
          uint64_t v47 = a11;
        }
        unint64_t v52 = v46 | 1;
        if ((v46 | 1) <= a9)
        {
          do
          {
            vst2_f32(v47, *(float32x2x2_t *)(&v25 - 2));
            v47 += 4;
            ++v52;
          }
          while (v52 <= a9);
          unint64_t v46 = v52 - 1;
        }
        _CF = a9 >= v46;
        unint64_t v53 = a9 - v46;
        if (v53 != 0 && _CF)
        {
          do
          {
            *(_OWORD *)uint64_t v47 = _Q0;
            v47 += 4;
            --v53;
          }
          while (v53);
        }
        a11 = (float *)((char *)a11 + a12);
        v39 += a10;
      }
      while (v39 + (unint64_t)*(unsigned int *)(a3 + 56) < v34);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v73, result, a2, a4, (uint64_t)a3);
    uint64_t v21 = *a5;
    if (*(unsigned char *)(*a5 + 24)) {
      _D0 = *(double *)v21;
    }
    else {
      _D0 = NAN;
    }
    int v23 = *(_DWORD *)(v21 + 16);
    if (v23 == 2)
    {
      *(float *)&long long v19 = _D0;
    }
    else if (v23 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v76) = _H0;
      LOWORD(v76) = _H0;
      LODWORD(v19) = v76;
    }
    else
    {
      LODWORD(v19) = _D0;
    }
    uint64_t v29 = *a6;
    if (*(unsigned char *)(*a6 + 24)) {
      _D0 = *(double *)v29;
    }
    else {
      _D0 = NAN;
    }
    int v31 = *(_DWORD *)(v29 + 16);
    if (v31 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v31 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v76) = _H0;
      LOWORD(v76) = _H0;
      LODWORD(_D0) = v76;
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    uint64_t v33 = *a7;
    if (*(unsigned char *)(*a7 + 24)) {
      _D1 = *(double *)v33;
    }
    else {
      _D1 = NAN;
    }
    unint64_t v35 = HIDWORD(v13);
    int v36 = *(_DWORD *)(v33 + 16);
    if (v36 == 2)
    {
      *(float *)&_D1 = _D1;
    }
    else if (v36 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v76) = _H1;
      LOWORD(v76) = _H1;
      LODWORD(_D1) = v76;
    }
    else
    {
      LODWORD(_D1) = _D1;
      if (v36) {
        *(float *)&_D1 = *(float *)&_D0;
      }
    }
    uint64_t v38 = a3[13];
    if ((unint64_t)a3[14] + v38 < v35)
    {
      __int16 v40 = v19;
      int16x8_t v41 = vdupq_n_s16(v19);
      int16x4_t v42 = (int16x4_t)__PAIR64__(LODWORD(_D1), LODWORD(_D0));
      int v43 = a3[7] * *(_DWORD *)(a2 + 60);
      int16x8_t v44 = vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(_D1), LODWORD(_D0)), 2);
      int8x16_t v45 = vqtbl2q_s8(*(int8x16x2_t *)v44.i8, (int8x16_t)xmmword_228F61E90);
      int16x4_t v46 = (int16x4_t)vdup_lane_s32(*(int32x2_t *)&_D0, 0);
      int16x4_t v47 = (int16x4_t)vdup_lane_s32(*(int32x2_t *)&_D1, 0);
      int8x16_t v48 = vqtbl2q_s8(*(int8x16x2_t *)v44.i8, (int8x16_t)xmmword_228F61EA0);
      WORD1(v19) = v47.i16[0];
      WORD2(v19) = v19;
      WORD3(v19) = v47.i16[2];
      int32x2_t v49 = (int32x2_t)vuzp1_s16(v42, v47);
      int16x8_t v65 = vdupq_lane_s16(v42, 0);
      do
      {
        int16x8_t v66 = v44;
        int8x16_t v67 = v48;
        int16x8_t v68 = v20;
        int8x16_t v69 = v45;
        int16x4x2_t v70 = v18;
        long long v71 = v19;
        int v74 = v43 + v38;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v73);
        if (a9 >= 8)
        {
          uint64_t v54 = 0;
          uint64_t v55 = v73[0];
          uint64_t v56 = v75 + v73[0];
          float v57 = a11;
          int16x4x2_t v18 = v70;
          long long v19 = v71;
          int8x16_t v45 = v69;
          int8x16_t v48 = v67;
          do
          {
            v50.i64[0] = *(void *)(v55 + v54);
            v51.i64[0] = *(void *)(v56 + v54);
            int8x16_t v50 = vzip1q_s8(v50, v51);
            int16x8_t v44 = vzip1q_s16((int16x8_t)v50, v65);
            unint64_t v53 = v57 + 32;
            vst2q_s16(v57, *(int16x8x2_t *)v44.i8);
            unint64_t v58 = v57 + 16;
            int16x8_t v20 = vzip2q_s16((int16x8_t)v50, v65);
            vst2q_s16(v58, *(int16x8x2_t *)v20.i8);
            unint64_t v52 = v54 + 8;
            unint64_t v59 = v54 + 16;
            v54 += 8;
            float v57 = v53;
          }
          while (v59 <= a9);
        }
        else
        {
          unint64_t v52 = 0;
          unint64_t v53 = a11;
          int16x4x2_t v18 = v70;
          long long v19 = v71;
          int16x8_t v20 = v68;
          int8x16_t v45 = v69;
          int16x8_t v44 = v66;
          int8x16_t v48 = v67;
        }
        unint64_t v60 = v52 | 2;
        if ((v52 | 2) <= a9)
        {
          do
          {
            unint64_t v61 = (unsigned __int8 *)(v52 + v73[0]);
            uint64_t v62 = (__int8 *)(v61 + 1);
            __int32 v63 = *v61;
            unint64_t v64 = &v61[v75];
            v50.i32[0] = v63;
            v50.i8[4] = *v62;
            v51.i32[0] = *v64;
            v51.i8[4] = v64[1];
            int8x16_t v50 = (int8x16_t)vtrn1q_s16((int16x8_t)v50, (int16x8_t)v51);
            *(int8x8_t *)v50.i8 = vmovn_s16((int16x8_t)v50);
            v50.i16[2] = v50.i16[1];
            v18.val[0] = vtrn1_s16(*(int16x4_t *)v50.i8, v46);
            vst2_s16(v53, v18);
            v53 += 8;
            unint64_t v52 = v60;
            v60 += 2;
          }
          while (v60 <= a9);
          unint64_t v52 = v60 - 2;
        }
        if (v52 < a9)
        {
          do
          {
            LOBYTE(v72) = *(unsigned char *)(v52 + v73[0]);
            HIBYTE(v72) = *(unsigned char *)(v52 + v75 + v73[0]);
            v50.i16[0] = v72;
            v50.i16[1] = v40;
            *(int32x2_t *)v50.i8 = vzip1_s32(*(int32x2_t *)v50.i8, v49);
            *(void *)unint64_t v53 = v50.i64[0];
            v53 += 4;
            ++v52;
          }
          while (a9 != v52);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v38 += a10;
      }
      while (v38 + (unint64_t)a3[14] < v35);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v14 = *(void *)(a2 + 56);
  if (v14)
  {
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v70, result, a2, a4, (uint64_t)a3);
    uint64_t v21 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v21 : NAN;
    int v23 = *(_DWORD *)(v21 + 16);
    if (v23 == 2)
    {
      *(float *)&long long v19 = _D0;
    }
    else if (v23 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v73) = _H0;
      LOWORD(v73) = _H0;
      *(float *)&long long v19 = v73;
    }
    else
    {
      LODWORD(v19) = _D0;
    }
    uint64_t v29 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v29 : NAN;
    int v31 = *(_DWORD *)(v29 + 16);
    if (v31 == 2)
    {
      *(float *)v12.i32 = _D0;
    }
    else if (v31 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v73) = _H0;
      LOWORD(v73) = _H0;
      *(float *)v12.i32 = v73;
    }
    else
    {
      v12.i32[0] = _D0;
    }
    uint64_t v33 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v33 : NAN;
    unint64_t v35 = HIDWORD(v14);
    int v36 = *(_DWORD *)(v33 + 16);
    if (v36 == 2)
    {
      float v37 = _D0;
    }
    else if (v36 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v73) = _H0;
      LOWORD(v73) = _H0;
      float v37 = v73;
    }
    else
    {
      LODWORD(v37) = _D0;
    }
    uint64_t v39 = a3[13];
    if ((unint64_t)a3[14] + v39 < v35)
    {
      __int32 v41 = v19;
      uint64_t v42 = a2;
      float v43 = v37;
      int v44 = a3[7] * *(_DWORD *)(v42 + 60);
      v45.i64[0] = __PAIR64__(LODWORD(v37), v19);
      v45.i64[1] = __PAIR64__(LODWORD(v37), v19);
      *((float *)&v19 + 1) = v37;
      int32x4_t v64 = vdupq_n_s32(v12.u32[0]);
      do
      {
        int32x4_t v66 = v20;
        int8x16_t v67 = v45;
        float32x2x2_t v68 = v18;
        long long v69 = v19;
        int v71 = v44 + v39;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v70);
        if (a9 >= 4)
        {
          uint64_t v51 = 0;
          unint64_t v52 = (uint64_t *)v70[0];
          uint64_t v53 = v72;
          uint64_t v54 = a11;
          int8x16_t v50 = a3;
          float32x2x2_t v18 = v68;
          long long v19 = v69;
          int8x16_t v45 = v67;
          do
          {
            v46.i64[0] = *v52;
            v47.i64[0] = *(uint64_t *)((char *)v52 + v53);
            int32x4_t v55 = (int32x4_t)vzip1q_s8(v46, v47);
            int32x4_t v20 = vzip2q_s32(v55, v64);
            int8x16_t v46 = (int8x16_t)vzip1q_s32(v55, v64);
            int8x16_t v47 = v67;
            int32x2_t v49 = v54 + 16;
            vst2q_f32(v54, *(float32x4x2_t *)v46.i8);
            uint64_t v56 = v54 + 8;
            vst2q_f32(v56, *(float32x4x2_t *)v20.i8);
            unint64_t v48 = v51 + 4;
            unint64_t v57 = v51 + 8;
            ++v52;
            v51 += 4;
            uint64_t v54 = v49;
          }
          while (v57 <= a9);
        }
        else
        {
          unint64_t v48 = 0;
          int32x2_t v49 = a11;
          int8x16_t v50 = a3;
          float32x2x2_t v18 = v68;
          long long v19 = v69;
          int32x4_t v20 = v66;
          int8x16_t v45 = v67;
        }
        unint64_t v58 = v48 | 1;
        if ((v48 | 1) <= a9)
        {
          do
          {
            unint64_t v59 = (__int8 *)(v70[0] + 2 * v48);
            v46.i8[0] = *v59;
            v46.i8[4] = v59[1];
            unint64_t v60 = &v59[v72];
            v46.i8[1] = *v60;
            v46.i8[2] = v46.i8[4];
            v46.i8[3] = v60[1];
            v18.val[0] = (float32x2_t)vzip1_s32(*(int32x2_t *)v46.i8, v12);
            vst2_f32(v49, v18);
            v49 += 4;
            unint64_t v48 = v58++;
          }
          while (v58 <= a9);
          unint64_t v48 = v58 - 1;
        }
        unint64_t v61 = a9 - v48;
        if (a9 > v48)
        {
          uint64_t v62 = 2 * v48;
          do
          {
            __int32 v63 = (unsigned __int8 *)(v62 + v72 + v70[0]);
            v46.i32[0] = *(unsigned __int8 *)(v62 + v70[0]);
            v46.i8[4] = *(unsigned char *)(v62 + v70[0] + 1);
            v47.i32[0] = *v63;
            v47.i8[4] = v63[1];
            v46.i32[0] = vmovn_s16(vtrn1q_s16((int16x8_t)v46, (int16x8_t)v47)).u32[0];
            v46.i32[1] = v41;
            v46.i64[1] = __PAIR64__(LODWORD(v43), v12.u32[0]);
            *(int8x16_t *)int32x2_t v49 = v46;
            v49 += 4;
            v62 += 2;
            --v61;
          }
          while (v61);
        }
        a11 = (float *)((char *)a11 + a12);
        v39 += a10;
      }
      while (v39 + (unint64_t)v50[14] < v35);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    uint64_t v17 = *a4;
    if (*(unsigned char *)(*a4 + 24)) {
      _D0 = *(double *)v17;
    }
    else {
      _D0 = NAN;
    }
    int v19 = *(_DWORD *)(v17 + 16);
    if (v19 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v19 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v72[0]) = _H0;
      LOWORD(v72[0]) = _H0;
      LODWORD(_D0) = v72[0];
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    double v66 = _D0;
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v72, result, a2, a5, (uint64_t)a3);
    uint64_t v27 = *a6;
    if (*(unsigned char *)(*a6 + 24)) {
      _D0 = *(double *)v27;
    }
    else {
      _D0 = NAN;
    }
    int v29 = *(_DWORD *)(v27 + 16);
    if (v29 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v29 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v75) = _H0;
      LOWORD(v75) = _H0;
      LODWORD(_D0) = v75;
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    uint64_t v31 = *a7;
    if (*(unsigned char *)(*a7 + 24)) {
      _D1 = *(double *)v31;
    }
    else {
      _D1 = NAN;
    }
    unint64_t v33 = HIDWORD(v13);
    int v34 = *(_DWORD *)(v31 + 16);
    if (v34 == 2)
    {
      *(float *)&_D1 = _D1;
    }
    else if (v34 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v75) = _H1;
      LOWORD(v75) = _H1;
      LODWORD(_D1) = v75;
    }
    else
    {
      LODWORD(_D1) = _D1;
      if (v34) {
        *(float *)&_D1 = *(float *)&_D0;
      }
    }
    uint64_t v36 = a3[13];
    if ((unint64_t)a3[14] + v36 < v33)
    {
      v76.val[1] = (int8x16_t)vdupq_n_s16(LODWORD(v66));
      int16x4_t v38 = (int16x4_t)__PAIR64__(LODWORD(_D1), LODWORD(_D0));
      int v39 = a3[7] * *(_DWORD *)(a2 + 60);
      v76.val[0] = (int8x16_t)vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(_D1), LODWORD(_D0)), 0);
      int8x16_t v40 = vqtbl2q_s8(v76, (int8x16_t)xmmword_228F61E90);
      int32x2_t v41 = vdup_lane_s32(*(int32x2_t *)&_D0, 0);
      int8x16_t v42 = vqtbl2q_s8(v76, (int8x16_t)xmmword_228F61EA0);
      v76.val[0].i16[0] = LOWORD(v66);
      v76.val[0].i16[1] = LOWORD(v66);
      v76.val[0].i16[2] = v41.i16[0];
      v76.val[0].i16[3] = v41.i16[2];
      int16x4_t v43 = vrev32_s16(*(int16x4_t *)v76.val[0].i8);
      int16x4_t v44 = vuzp1_s16(*(int16x4_t *)v76.val[0].i8, v43);
      int16x4_t v45 = (int16x4_t)vdup_lane_s32(*(int32x2_t *)&_D1, 0);
      int32x2_t v46 = (int32x2_t)vuzp1_s16(v38, v43);
      int16x8_t v65 = vdupq_lane_s16(v38, 2);
      do
      {
        int8x16_t v67 = v42;
        int16x8_t v68 = v26;
        int8x16_t v69 = v40;
        int16x8_t v70 = v25;
        int v73 = v39 + v36;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v72);
        if (a9 >= 8)
        {
          uint64_t v52 = 0;
          uint64_t v53 = v72[0];
          uint64_t v54 = v74 + v72[0];
          int32x4_t v55 = a11;
          int32x2_t v51 = *(int32x2_t *)&v66;
          int8x16_t v40 = v69;
          int8x16_t v42 = v67;
          do
          {
            v47.i64[0] = *(void *)(v53 + v52);
            v48.i64[0] = *(void *)(v54 + v52);
            int8x16_t v47 = vzip1q_s8(v47, v48);
            int16x8_t v26 = vzip1q_s16((int16x8_t)v47, v65);
            int8x16_t v50 = v55 + 32;
            vst2q_s16(v55, *(int16x8x2_t *)(&v26 - 1));
            uint64_t v56 = v55 + 16;
            int16x8_t v25 = vzip2q_s16((int16x8_t)v47, v65);
            vst2q_s16(v56, *(int16x8x2_t *)(&v25 - 1));
            unint64_t v49 = v52 + 8;
            unint64_t v57 = v52 + 16;
            v52 += 8;
            int32x4_t v55 = v50;
          }
          while (v57 <= a9);
        }
        else
        {
          unint64_t v49 = 0;
          int8x16_t v50 = a11;
          int32x2_t v51 = *(int32x2_t *)&v66;
          int8x16_t v40 = v69;
          int16x8_t v25 = v70;
          int8x16_t v42 = v67;
          int16x8_t v26 = v68;
        }
        unint64_t v58 = v49 | 2;
        if ((v49 | 2) <= a9)
        {
          do
          {
            unint64_t v59 = (unsigned __int8 *)(v49 + v72[0]);
            unint64_t v60 = (__int8 *)(v59 + 1);
            __int32 v61 = *v59;
            uint64_t v62 = &v59[v74];
            v47.i32[0] = v61;
            v47.i8[4] = *v60;
            v48.i32[0] = *v62;
            v48.i8[4] = v62[1];
            int8x16_t v47 = (int8x16_t)vtrn1q_s16((int16x8_t)v47, (int16x8_t)v48);
            *(int8x8_t *)v47.i8 = vmovn_s16((int16x8_t)v47);
            v47.i16[2] = v47.i16[1];
            int16x4_t v63 = vtrn1_s16(*(int16x4_t *)v47.i8, v45);
            vst2_s16(v50, *(int16x4x2_t *)v44.i8);
            v50 += 8;
            unint64_t v49 = v58;
            v58 += 2;
          }
          while (v58 <= a9);
          unint64_t v49 = v58 - 2;
        }
        if (v49 < a9)
        {
          do
          {
            LOBYTE(v71) = *(unsigned char *)(v49 + v72[0]);
            HIBYTE(v71) = *(unsigned char *)(v49 + v74 + v72[0]);
            int32x2_t v64 = v51;
            v64.i16[1] = v71;
            *(int32x2_t *)int8x16_t v50 = vzip1_s32(v64, v46);
            v50 += 4;
            ++v49;
          }
          while (a9 != v49);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v36 += a10;
      }
      while (v36 + (unint64_t)a3[14] < v33);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t *a7, __n128 _Q0, uint64_t a9, unint64_t a10, unsigned int a11, float *a12, uint64_t a13)
{
  unint64_t v15 = *(void *)(a2 + 56);
  if (v15)
  {
    uint64_t v19 = *a4;
    _Q0.n128_u64[0] = *(unsigned char *)(*a4 + 24) ? *(void *)v19 : 0x7FF8000000000000;
    int v20 = *(_DWORD *)(v19 + 16);
    if (v20 == 2)
    {
      _Q0.n128_f32[0] = _Q0.n128_f64[0];
    }
    else if (v20 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v69[0]) = _H0;
      LOWORD(v69[0]) = _H0;
      _Q0.n128_u32[0] = v69[0];
    }
    else
    {
      _Q0.n128_u32[0] = _Q0.n128_f64[0];
    }
    __n128 v64 = _Q0;
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v69, result, a2, a5, (uint64_t)a3);
    uint64_t v28 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v28 : NAN;
    int v30 = *(_DWORD *)(v28 + 16);
    if (v30 == 2)
    {
      float v31 = _D0;
    }
    else if (v30 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v72) = _H0;
      LOWORD(v72) = _H0;
      float v31 = v72;
    }
    else
    {
      LODWORD(v31) = _D0;
    }
    uint64_t v33 = *a7;
    _D1 = *(unsigned char *)(*a7 + 24) ? *(double *)v33 : NAN;
    unint64_t v35 = HIDWORD(v15);
    int v36 = *(_DWORD *)(v33 + 16);
    if (v36 == 2)
    {
      *(float *)v13.i32 = _D1;
    }
    else if (v36 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v72) = _H1;
      LOWORD(v72) = _H1;
      *(float *)v13.i32 = v72;
    }
    else
    {
      LODWORD(v37) = _D1;
      *(float *)v13.i32 = v36 ? v31 : v37;
    }
    uint64_t v39 = a3[13];
    if ((unint64_t)a3[14] + v39 < v35)
    {
      float v41 = v31;
      v42.i64[0] = __PAIR64__(LODWORD(v31), v64.n128_u32[0]);
      v42.i64[1] = __PAIR64__(LODWORD(v31), v64.n128_u32[0]);
      int v43 = a3[7] * *(_DWORD *)(a2 + 60);
      __n128 v44 = v64;
      v44.n128_f32[1] = v31;
      int32x4_t v63 = vdupq_n_s32(v13.u32[0]);
      do
      {
        __n128 v65 = v44;
        long long v66 = v27;
        int8x16_t v67 = v42;
        int32x4_t v68 = v26;
        int v70 = v43 + v39;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v69);
        if (a10 >= 4)
        {
          uint64_t v50 = 0;
          int32x2_t v51 = (uint64_t *)v69[0];
          uint64_t v52 = v71;
          uint64_t v53 = a12;
          unsigned __int32 v49 = v64.n128_u32[0];
          int8x16_t v42 = v67;
          __n128 v44 = v65;
          long long v27 = v66;
          do
          {
            v45.i64[0] = *v51;
            v46.i64[0] = *(uint64_t *)((char *)v51 + v52);
            int8x16_t v45 = vzip1q_s8(v45, v46);
            int32x4_t v54 = vzip1q_s32((int32x4_t)v45, v63);
            int32x4_t v26 = vzip2q_s32((int32x4_t)v45, v63);
            int8x16_t v48 = v53 + 16;
            int8x16_t v46 = v67;
            vst2q_f32(v53, *(float32x4x2_t *)v46.i8);
            int32x4_t v55 = v53 + 8;
            vst2q_f32(v55, *(float32x4x2_t *)(&v26 - 1));
            unint64_t v47 = v50 + 4;
            unint64_t v56 = v50 + 8;
            ++v51;
            v50 += 4;
            uint64_t v53 = v48;
          }
          while (v56 <= a10);
        }
        else
        {
          unint64_t v47 = 0;
          int8x16_t v48 = a12;
          unsigned __int32 v49 = v64.n128_u32[0];
          int8x16_t v42 = v67;
          int32x4_t v26 = v68;
          __n128 v44 = v65;
          long long v27 = v66;
        }
        unint64_t v57 = v47 | 1;
        if ((v47 | 1) <= a10)
        {
          do
          {
            unint64_t v58 = (__int8 *)(v69[0] + 2 * v47);
            v45.i8[0] = *v58;
            v45.i8[4] = v58[1];
            unint64_t v59 = &v58[v71];
            v45.i8[1] = *v59;
            v45.i8[2] = v45.i8[4];
            v45.i8[3] = v59[1];
            *(int32x2_t *)&long long v27 = vzip1_s32(*(int32x2_t *)v45.i8, v13);
            vst2_f32(v48, *(float32x2x2_t *)((char *)&v27 - 8));
            v48 += 4;
            unint64_t v47 = v57++;
          }
          while (v57 <= a10);
          unint64_t v47 = v57 - 1;
        }
        unint64_t v60 = a10 - v47;
        if (a10 > v47)
        {
          uint64_t v61 = 2 * v47;
          do
          {
            uint64_t v62 = (unsigned __int8 *)(v61 + v71 + v69[0]);
            v45.i32[0] = *(unsigned __int8 *)(v61 + v69[0]);
            v45.i8[4] = *(unsigned char *)(v61 + v69[0] + 1);
            v46.i32[0] = *v62;
            v46.i8[4] = v62[1];
            int8x16_t v45 = (int8x16_t)vtrn1q_s16((int16x8_t)v45, (int16x8_t)v46);
            *(int8x8_t *)v45.i8 = vmovn_s16((int16x8_t)v45);
            v46.i64[0] = __PAIR64__(v45.u32[0], v49);
            v46.i64[1] = __PAIR64__(v13.u32[0], LODWORD(v41));
            *(int8x16_t *)int8x16_t v48 = v46;
            v48 += 4;
            v61 += 2;
            --v60;
          }
          while (v60);
        }
        a12 = (float *)((char *)a12 + a13);
        v39 += a11;
      }
      while (v39 + (unint64_t)a3[14] < v35);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v65, result, a2, a4, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v62, v18, a2, a5, (uint64_t)a3);
    uint64_t v19 = *a6;
    if (*(unsigned char *)(*a6 + 24)) {
      _D0 = *(double *)v19;
    }
    else {
      _D0 = NAN;
    }
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v68) = _H0;
      LOWORD(v68) = _H0;
      LODWORD(_D0) = v68;
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    uint64_t v27 = *a7;
    if (*(unsigned char *)(*a7 + 24)) {
      _D1 = *(double *)v27;
    }
    else {
      _D1 = NAN;
    }
    unint64_t v59 = HIDWORD(v12);
    int v29 = *(_DWORD *)(v27 + 16);
    if (v29 == 2)
    {
      *(float *)&_D1 = _D1;
    }
    else if (v29 == 1)
    {
      __asm { FCVT            H1, D1 }
      HIWORD(v68) = _H1;
      LOWORD(v68) = _H1;
      LODWORD(_D1) = v68;
    }
    else
    {
      LODWORD(_D1) = _D1;
      if (v29) {
        *(float *)&_D1 = *(float *)&_D0;
      }
    }
    uint64_t v31 = a3[13];
    if ((unint64_t)a3[14] + v31 < v59)
    {
      int v33 = a3[7] * *(_DWORD *)(a2 + 60);
      int16x4_t v34 = (int16x4_t)vdup_lane_s32(*(int32x2_t *)&_D0, 0);
      int16x4_t v35 = (int16x4_t)vdup_lane_s32(*(int32x2_t *)&_D1, 0);
      int32x2_t v36 = (int32x2_t)vuzp1_s16((int16x4_t)__PAIR64__(LODWORD(_D1), LODWORD(_D0)), *(int16x4_t *)&_D0);
      int16x8_t v57 = vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(_D1), LODWORD(_D0)), 2);
      int16x8_t v58 = vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(_D1), LODWORD(_D0)), 0);
      do
      {
        int v66 = v33 + v31;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v65);
        int v63 = v33 + v31;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v62);
        if (a9 >= 8)
        {
          uint64_t v42 = 0;
          uint64_t v43 = v65[0];
          uint64_t v44 = v62[0];
          uint64_t v45 = v67 + v65[0];
          uint64_t v46 = v64 + v62[0];
          unint64_t v47 = a11;
          do
          {
            v37.i64[0] = *(void *)(v43 + v42);
            v38.i64[0] = *(void *)(v45 + v42);
            v39.i64[0] = *(void *)(v44 + v42);
            int8x16_t v37 = vzip1q_s8(v37, v38);
            v38.i64[0] = *(void *)(v46 + v42);
            int8x16_t v38 = vzip1q_s8(v39, v38);
            v69.val[0] = vzip1q_s16((int16x8_t)v37, v58);
            v69.val[1] = vzip1q_s16((int16x8_t)v38, v57);
            float v41 = v47 + 32;
            vst2q_s16(v47, v69);
            int8x16_t v48 = v47 + 16;
            int8x16_t v39 = (int8x16_t)vzip2q_s16((int16x8_t)v37, v58);
            v69.val[1] = vzip2q_s16((int16x8_t)v38, v57);
            vst2q_s16(v48, *(int16x8x2_t *)v39.i8);
            unint64_t v40 = v42 + 8;
            unint64_t v49 = v42 + 16;
            v42 += 8;
            unint64_t v47 = v41;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v40 = 0;
          float v41 = a11;
        }
        unint64_t v50 = v40 | 2;
        if ((v40 | 2) <= a9)
        {
          do
          {
            int32x2_t v51 = (unsigned __int8 *)(v40 + v65[0] + v67);
            v37.i32[0] = *(unsigned __int8 *)(v40 + v65[0]);
            v37.i8[4] = *(unsigned char *)(v40 + v65[0] + 1);
            v38.i32[0] = *v51;
            v38.i8[4] = v51[1];
            int8x16_t v37 = (int8x16_t)vtrn1q_s16((int16x8_t)v37, (int16x8_t)v38);
            *(int8x8_t *)v37.i8 = vmovn_s16((int16x8_t)v37);
            v37.i16[2] = v37.i16[1];
            uint64_t v52 = (unsigned __int8 *)(v40 + v62[0]);
            uint64_t v53 = (__int8 *)(v52 + 1);
            __int32 v54 = *v52;
            int32x4_t v55 = &v52[v64];
            v38.i32[0] = v54;
            v38.i8[4] = *v53;
            v39.i32[0] = *v55;
            v39.i8[4] = v55[1];
            int8x16_t v38 = (int8x16_t)vtrn1q_s16((int16x8_t)v38, (int16x8_t)v39);
            *(int8x8_t *)v38.i8 = vmovn_s16((int16x8_t)v38);
            v38.i16[2] = v38.i16[1];
            *(int16x4_t *)v39.i8 = vtrn1_s16(*(int16x4_t *)v37.i8, v34);
            int16x4_t v56 = vtrn1_s16(*(int16x4_t *)v38.i8, v35);
            vst2_s16(v41, (int16x4x2_t)v39);
            v41 += 8;
            unint64_t v40 = v50;
            v50 += 2;
          }
          while (v50 <= a9);
          unint64_t v40 = v50 - 2;
        }
        if (v40 < a9)
        {
          do
          {
            LOBYTE(v61) = *(unsigned char *)(v40 + v65[0]);
            HIBYTE(v61) = *(unsigned char *)(v40 + v67 + v65[0]);
            LOBYTE(v60) = *(unsigned char *)(v40 + v62[0]);
            HIBYTE(v60) = *(unsigned char *)(v40 + v64 + v62[0]);
            v37.i16[0] = v61;
            v37.i16[1] = v60;
            *(int32x2_t *)v37.i8 = vzip1_s32(*(int32x2_t *)v37.i8, v36);
            *(void *)float v41 = v37.i64[0];
            v41 += 4;
            ++v40;
          }
          while (a9 != v40);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v31 += a10;
      }
      while (v31 + (unint64_t)a3[14] < v59);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v14 = *(void *)(a2 + 56);
  if (v14)
  {
    uint64_t v20 = result;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v67, result, a2, a4, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v64, v20, a2, a5, (uint64_t)a3);
    uint64_t v21 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v21 : NAN;
    int v23 = *(_DWORD *)(v21 + 16);
    if (v23 == 2)
    {
      *(float *)v12.i32 = _D0;
    }
    else if (v23 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v70) = _H0;
      LOWORD(v70) = _H0;
      v12.i32[0] = v70;
    }
    else
    {
      v12.i32[0] = _D0;
    }
    uint64_t v29 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v29 : NAN;
    unint64_t v63 = HIDWORD(v14);
    int v31 = *(_DWORD *)(v29 + 16);
    if (v31 == 2)
    {
      *(float *)v13.i32 = _D0;
    }
    else if (v31 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v70) = _H0;
      LOWORD(v70) = _H0;
      v13.i32[0] = v70;
    }
    else
    {
      v13.i32[0] = _D0;
    }
    uint64_t v33 = a3[13];
    if ((unint64_t)a3[14] + v33 < v63)
    {
      int v35 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v61 = vdupq_n_s32(v13.u32[0]);
      int32x4_t v62 = vdupq_n_s32(v12.u32[0]);
      do
      {
        int v68 = v35 + v33;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v67);
        int v65 = v35 + v33;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v64);
        if (a9 >= 4)
        {
          uint64_t v41 = 0;
          uint64_t v43 = v66;
          uint64_t v42 = (uint64_t *)v67[0];
          uint64_t v44 = v69;
          uint64_t v45 = a11;
          uint64_t v46 = (uint64_t *)v64[0];
          do
          {
            v36.i64[0] = *v42;
            v37.i64[0] = *(uint64_t *)((char *)v42 + v44);
            int8x16_t v36 = vzip1q_s8(v36, v37);
            v37.i64[0] = *v46;
            v38.i64[0] = *(uint64_t *)((char *)v46 + v43);
            int8x16_t v37 = vzip1q_s8(v37, v38);
            int8x16_t v38 = (int8x16_t)vzip2q_s32((int32x4_t)v36, v62);
            v71.val[0] = (float32x4_t)vzip1q_s32((int32x4_t)v36, v62);
            v71.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v37, v61);
            unint64_t v40 = v45 + 16;
            vst2q_f32(v45, v71);
            unint64_t v47 = v45 + 8;
            int32x4_t v48 = vzip2q_s32((int32x4_t)v37, v61);
            vst2q_f32(v47, *(float32x4x2_t *)v38.i8);
            unint64_t v39 = v41 + 4;
            unint64_t v49 = v41 + 8;
            ++v46;
            ++v42;
            v41 += 4;
            uint64_t v45 = v40;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v39 = 0;
          unint64_t v40 = a11;
        }
        unint64_t v50 = v39 | 1;
        if ((v39 | 1) <= a9)
        {
          do
          {
            int32x2_t v51 = (__int8 *)(v67[0] + 2 * v39);
            uint64_t v52 = v51 + 1;
            v36.i8[0] = *v51;
            uint64_t v53 = &v51[v69];
            v36.i8[4] = *v52;
            __int32 v54 = (__int8 *)(v64[0] + 2 * v39);
            v38.i8[0] = *v54;
            v38.i8[4] = v54[1];
            int32x4_t v55 = &v54[v66];
            v36.i8[1] = *v53;
            v38.i8[1] = *v55;
            v36.i8[2] = *v52;
            v38.i8[2] = v38.i8[4];
            v36.i8[3] = v53[1];
            v38.i8[3] = v55[1];
            *(int32x2_t *)v36.i8 = vzip1_s32(*(int32x2_t *)v36.i8, v12);
            *(int32x2_t *)v37.i8 = vzip1_s32(*(int32x2_t *)v38.i8, v13);
            vst2_f32(v40, (float32x2x2_t)v36);
            v40 += 4;
            unint64_t v39 = v50++;
          }
          while (v50 <= a9);
          unint64_t v39 = v50 - 1;
        }
        unint64_t v56 = a9 - v39;
        if (a9 > v39)
        {
          uint64_t v57 = 2 * v39;
          do
          {
            int16x8_t v58 = (unsigned __int8 *)(v57 + v69 + v67[0]);
            v36.i32[0] = *(unsigned __int8 *)(v57 + v67[0]);
            v36.i8[4] = *(unsigned char *)(v57 + v67[0] + 1);
            v37.i32[0] = *v58;
            v37.i8[4] = v58[1];
            unint64_t v59 = (unsigned __int8 *)(v57 + v66 + v64[0]);
            v38.i32[0] = *(unsigned __int8 *)(v57 + v64[0]);
            int16x8_t v60 = vtrn1q_s16((int16x8_t)v36, (int16x8_t)v37);
            v38.i8[4] = *(unsigned char *)(v57 + v64[0] + 1);
            v37.i32[0] = *v59;
            v37.i8[4] = v59[1];
            v36.i32[0] = vmovn_s16(v60).u32[0];
            int8x16_t v37 = (int8x16_t)vtrn1q_s16((int16x8_t)v38, (int16x8_t)v37);
            *(int8x8_t *)v37.i8 = vmovn_s16((int16x8_t)v37);
            v36.i32[1] = v37.i32[0];
            v36.i64[1] = __PAIR64__(v13.u32[0], v12.u32[0]);
            *(int8x16_t *)unint64_t v40 = v36;
            v40 += 4;
            v57 += 2;
            --v56;
          }
          while (v56);
        }
        a11 = (float *)((char *)a11 + a12);
        v33 += a10;
      }
      while (v33 + (unint64_t)a3[14] < v63);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    uint64_t v15 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v15 : NAN;
    int v17 = *(_DWORD *)(v15 + 16);
    if (v17 == 2)
    {
      float v18 = _D0;
    }
    else if (v17 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v73[0]) = _H0;
      LOWORD(v73[0]) = _H0;
      float v18 = *(float *)v73;
    }
    else
    {
      LODWORD(v18) = _D0;
    }
    uint64_t v24 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v24 : NAN;
    int v26 = *(_DWORD *)(v24 + 16);
    unsigned int v66 = LODWORD(v18);
    if (v26 == 2)
    {
      float v27 = _D0;
    }
    else if (v26 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v73[0]) = _H0;
      LOWORD(v73[0]) = _H0;
      float v27 = *(float *)v73;
    }
    else
    {
      LODWORD(v27) = _D0;
    }
    unsigned int v69 = LODWORD(v27);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v73, result, a2, a6, (uint64_t)a3);
    uint64_t v30 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v30 : NAN;
    LOWORD(v32) = v66;
    unint64_t v33 = HIDWORD(v13);
    int v34 = *(_DWORD *)(v30 + 16);
    if (v34 == 2)
    {
      *(float *)&unsigned int v35 = _D0;
    }
    else if (v34 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v76) = _H0;
      LOWORD(v76) = _H0;
      unsigned int v35 = v76;
    }
    else
    {
      unsigned int v35 = _D0;
    }
    uint64_t v37 = a3[13];
    if ((unint64_t)a3[14] + v37 < v33)
    {
      int v39 = *(_DWORD *)(a2 + 60);
      v40.i16[0] = v69;
      __int16 v41 = v35;
      v77.val[1] = (int8x16_t)vdupq_n_s16(v35);
      v77.val[0] = (int8x16_t)vdupq_n_s16(v69);
      int v42 = a3[7] * v39;
      int8x16_t v43 = vqtbl2q_s8(v77, (int8x16_t)xmmword_228F41B50);
      int16x4_t v44 = (int16x4_t)vdup_n_s32(v66);
      v40.i16[1] = v69;
      v40.i16[2] = v41;
      v40.i16[3] = v41;
      int16x4_t v45 = vuzp1_s16(v40, vrev32_s16(v40));
      HIWORD(v32) = v69;
      int16x8_t v65 = vdupq_n_s16(v66);
      int v67 = v32;
      do
      {
        int16x8_t v70 = v29;
        int8x16_t v71 = v43;
        int v74 = v42 + v37;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v73);
        if (a9 >= 8)
        {
          uint64_t v51 = 0;
          uint64_t v52 = v73[0];
          uint64_t v53 = v75 + v73[0];
          __int32 v54 = a11;
          int v50 = v67;
          int8x16_t v43 = v71;
          do
          {
            v46.i64[0] = *(void *)(v52 + v51);
            v47.i64[0] = *(void *)(v53 + v51);
            int16x8_t v55 = (int16x8_t)vzip1q_s8(v46, v47);
            int16x8_t v29 = vzip2q_s16(v65, v55);
            int8x16_t v46 = (int8x16_t)vzip1q_s16(v65, v55);
            int8x16_t v47 = v71;
            unint64_t v49 = v54 + 32;
            vst2q_s16(v54, *(int16x8x2_t *)v46.i8);
            unint64_t v56 = v54 + 16;
            vst2q_s16(v56, *(int16x8x2_t *)v29.i8);
            unint64_t v48 = v51 + 8;
            unint64_t v57 = v51 + 16;
            v51 += 8;
            __int32 v54 = v49;
          }
          while (v57 <= a9);
        }
        else
        {
          unint64_t v48 = 0;
          unint64_t v49 = a11;
          int v50 = v67;
          int16x8_t v29 = v70;
          int8x16_t v43 = v71;
        }
        unint64_t v58 = v48 | 2;
        if ((v48 | 2) <= a9)
        {
          do
          {
            unint64_t v59 = (unsigned __int8 *)(v48 + v73[0]);
            int16x8_t v60 = (__int8 *)(v59 + 1);
            __int32 v61 = *v59;
            int32x4_t v62 = &v59[v75];
            v46.i32[0] = v61;
            v46.i8[4] = *v60;
            v47.i32[0] = *v62;
            v47.i8[4] = v62[1];
            int8x16_t v46 = (int8x16_t)vtrn1q_s16((int16x8_t)v46, (int16x8_t)v47);
            *(int8x8_t *)v46.i8 = vmovn_s16((int16x8_t)v46);
            v46.i16[2] = v46.i16[1];
            int16x4_t v63 = vtrn1_s16(v44, *(int16x4_t *)v46.i8);
            vst2_s16(v49, *(int16x4x2_t *)(&v45 - 1));
            v49 += 8;
            unint64_t v48 = v58;
            v58 += 2;
          }
          while (v58 <= a9);
          unint64_t v48 = v58 - 2;
        }
        if (v48 < a9)
        {
          do
          {
            LOBYTE(v72) = *(unsigned char *)(v48 + v73[0]);
            HIBYTE(v72) = *(unsigned char *)(v48 + v75 + v73[0]);
            LODWORD(v64) = v50;
            WORD2(v64) = v72;
            HIWORD(v64) = v41;
            *(void *)unint64_t v49 = v64;
            v49 += 4;
            ++v48;
          }
          while (a9 != v48);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v37 += a10;
      }
      while (v37 + (unint64_t)a3[14] < v33);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t *a7, __n128 _Q0, __n128 a9, uint64_t a10, unint64_t a11, unsigned int a12, float *a13, uint64_t a14)
{
  unint64_t v15 = *(void *)(a2 + 56);
  if (v15)
  {
    uint64_t v18 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v18 : NAN;
    int v20 = *(_DWORD *)(v18 + 16);
    if (v20 == 2)
    {
      a9.n128_f32[0] = _D0;
    }
    else if (v20 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v70[0]) = _H0;
      LOWORD(v70[0]) = _H0;
      a9.n128_u32[0] = v70[0];
    }
    else
    {
      a9.n128_u32[0] = _D0;
    }
    uint64_t v26 = *a5;
    _Q0.n128_u64[0] = *(unsigned char *)(*a5 + 24) ? *(void *)v26 : 0x7FF8000000000000;
    int v27 = *(_DWORD *)(v26 + 16);
    unint64_t v63 = a9.n128_u64[0];
    if (v27 == 2)
    {
      a9.n128_f32[0] = _Q0.n128_f64[0];
    }
    else if (v27 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v70[0]) = _Q0.n128_u16[0];
      LOWORD(v70[0]) = _Q0.n128_u16[0];
      a9.n128_u32[0] = v70[0];
    }
    else
    {
      _Q0.n128_u32[0] = _Q0.n128_f64[0];
      a9.n128_f32[0] = _Q0.n128_f32[0];
    }
    __n128 v66 = _Q0;
    __n128 v68 = a9;
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v70, result, a2, a6, (uint64_t)a3);
    uint64_t v29 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v29 : NAN;
    float32x2x2_t v31 = (float32x2x2_t)v66;
    __n128 v32 = v68;
    unint64_t v33 = HIDWORD(v15);
    int v34 = *(_DWORD *)(v29 + 16);
    if (v34 == 2)
    {
      float v35 = _D0;
    }
    else if (v34 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v73) = _H0;
      LOWORD(v73) = _H0;
      float v35 = v73;
    }
    else
    {
      LODWORD(v35) = _D0;
    }
    uint64_t v37 = a3[13];
    if ((unint64_t)a3[14] + v37 < v33)
    {
      float v39 = v35;
      v40.i64[0] = __PAIR64__(LODWORD(v35), v68.n128_u32[0]);
      v40.i64[1] = __PAIR64__(LODWORD(v35), v68.n128_u32[0]);
      int v41 = a3[7] * *(_DWORD *)(a2 + 60);
      v32.n128_f32[1] = v35;
      int32x4_t v61 = vdupq_n_s32(v63);
      unint64_t v62 = __PAIR64__(v68.n128_u32[0], v63);
      do
      {
        int32x4_t v64 = v28;
        int8x16_t v65 = v40;
        float32x2x2_t v67 = v31;
        __n128 v69 = v32;
        int v71 = v41 + v37;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v70);
        if (a11 >= 4)
        {
          uint64_t v48 = 0;
          unint64_t v49 = (uint64_t *)v70[0];
          uint64_t v50 = v72;
          uint64_t v51 = a13;
          unint64_t v47 = v62;
          int32x2_t v46 = (int32x2_t)v63;
          float32x2x2_t v31 = v67;
          __n128 v32 = v69;
          int8x16_t v40 = v65;
          do
          {
            v42.i64[0] = *v49;
            v43.i64[0] = *(uint64_t *)((char *)v49 + v50);
            int32x4_t v52 = (int32x4_t)vzip1q_s8(v42, v43);
            int32x4_t v28 = vzip2q_s32(v61, v52);
            int8x16_t v42 = (int8x16_t)vzip1q_s32(v61, v52);
            int8x16_t v43 = v65;
            int16x4_t v45 = v51 + 16;
            vst2q_f32(v51, *(float32x4x2_t *)v42.i8);
            uint64_t v53 = v51 + 8;
            vst2q_f32(v53, *(float32x4x2_t *)v28.i8);
            unint64_t v44 = v48 + 4;
            unint64_t v54 = v48 + 8;
            ++v49;
            v48 += 4;
            uint64_t v51 = v45;
          }
          while (v54 <= a11);
        }
        else
        {
          unint64_t v44 = 0;
          int16x4_t v45 = a13;
          unint64_t v47 = v62;
          int32x2_t v46 = (int32x2_t)v63;
          float32x2x2_t v31 = v67;
          __n128 v32 = v69;
          int32x4_t v28 = v64;
          int8x16_t v40 = v65;
        }
        unint64_t v55 = v44 | 1;
        if ((v44 | 1) <= a11)
        {
          do
          {
            unint64_t v56 = (__int8 *)(v70[0] + 2 * v44);
            v42.i8[0] = *v56;
            v42.i8[4] = v56[1];
            unint64_t v57 = &v56[v72];
            v42.i8[1] = *v57;
            v42.i8[2] = v42.i8[4];
            v42.i8[3] = v57[1];
            v31.val[0] = (float32x2_t)vzip1_s32(v46, *(int32x2_t *)v42.i8);
            vst2_f32(v45, v31);
            v45 += 4;
            unint64_t v44 = v55++;
          }
          while (v55 <= a11);
          unint64_t v44 = v55 - 1;
        }
        unint64_t v58 = a11 - v44;
        if (a11 > v44)
        {
          uint64_t v59 = 2 * v44;
          do
          {
            int16x8_t v60 = (unsigned __int8 *)(v59 + v72 + v70[0]);
            v42.i32[0] = *(unsigned __int8 *)(v59 + v70[0]);
            v42.i8[4] = *(unsigned char *)(v59 + v70[0] + 1);
            v43.i32[0] = *v60;
            v43.i8[4] = v60[1];
            int8x16_t v42 = (int8x16_t)vtrn1q_s16((int16x8_t)v42, (int16x8_t)v43);
            *(int8x8_t *)v42.i8 = vmovn_s16((int16x8_t)v42);
            v43.i64[0] = v47;
            v43.i64[1] = __PAIR64__(LODWORD(v39), v42.u32[0]);
            *(int8x16_t *)int16x4_t v45 = v43;
            v45 += 4;
            v59 += 2;
            --v58;
          }
          while (v58);
        }
        a13 = (float *)((char *)a13 + a14);
        v37 += a12;
      }
      while (v37 + (unint64_t)a3[14] < v33);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v74, result, a2, a4, (uint64_t)a3);
    uint64_t v19 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v19 : NAN;
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      float v22 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      float v22 = *(float *)v71;
    }
    else
    {
      LODWORD(v22) = _D0;
    }
    unsigned int v66 = LODWORD(v22);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v71, v18, a2, a6, (uint64_t)a3);
    uint64_t v29 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v29 : NAN;
    unint64_t v65 = HIDWORD(v12);
    int v31 = *(_DWORD *)(v29 + 16);
    if (v31 == 2)
    {
      *(float *)&unsigned int v32 = _D0;
    }
    else if (v31 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v77) = _H0;
      LOWORD(v77) = _H0;
      unsigned int v32 = v77;
    }
    else
    {
      unsigned int v32 = _D0;
    }
    uint64_t v34 = a3[13];
    if ((unint64_t)a3[14] + v34 < v65)
    {
      int v64 = a3[7] * *(_DWORD *)(a2 + 60);
      v36.i16[0] = v66;
      __int16 v37 = v66;
      __int16 v38 = v32;
      v78.val[1] = (int8x16_t)vdupq_n_s16(v32);
      v78.val[0] = (int8x16_t)vdupq_n_s16(v66);
      v36.i16[1] = v66;
      v36.i16[2] = v38;
      v36.i16[3] = v38;
      int8x16_t v39 = vqtbl2q_s8(v78, (int8x16_t)xmmword_228F41B50);
      int16x4_t v40 = vuzp1_s16(v36, vrev32_s16(v36));
      do
      {
        int16x8_t v67 = v28;
        int8x16_t v68 = v39;
        int v75 = v64 + v34;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v74);
        int v72 = v64 + v34;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v71);
        if (a9 >= 8)
        {
          uint64_t v46 = 0;
          uint64_t v47 = v74[0];
          uint64_t v48 = v71[0];
          uint64_t v49 = v76 + v74[0];
          uint64_t v50 = v73 + v71[0];
          uint64_t v51 = a11;
          int8x16_t v39 = v68;
          do
          {
            v41.i64[0] = *(void *)(v47 + v46);
            v42.i64[0] = *(void *)(v49 + v46);
            int16x8_t v52 = (int16x8_t)vzip1q_s8(v41, v42);
            v42.i64[0] = *(void *)(v48 + v46);
            v43.i64[0] = *(void *)(v50 + v46);
            int16x8_t v53 = (int16x8_t)vzip1q_s8(v42, v43);
            int16x8_t v28 = vzip2q_s16(v52, v53);
            int8x16_t v41 = (int8x16_t)vzip1q_s16(v52, v53);
            int8x16_t v42 = v68;
            int16x4_t v45 = v51 + 32;
            vst2q_s16(v51, *(int16x8x2_t *)v41.i8);
            unint64_t v54 = v51 + 16;
            vst2q_s16(v54, *(int16x8x2_t *)v28.i8);
            unint64_t v44 = v46 + 8;
            unint64_t v55 = v46 + 16;
            v46 += 8;
            uint64_t v51 = v45;
          }
          while (v55 <= a9);
        }
        else
        {
          unint64_t v44 = 0;
          int16x4_t v45 = a11;
          int16x8_t v28 = v67;
          int8x16_t v39 = v68;
        }
        unint64_t v56 = v44 | 2;
        if ((v44 | 2) <= a9)
        {
          do
          {
            unint64_t v57 = (unsigned __int8 *)(v44 + v74[0] + v76);
            v41.i32[0] = *(unsigned __int8 *)(v44 + v74[0]);
            v41.i8[4] = *(unsigned char *)(v44 + v74[0] + 1);
            v42.i32[0] = *v57;
            v42.i8[4] = v57[1];
            int8x16_t v41 = (int8x16_t)vtrn1q_s16((int16x8_t)v41, (int16x8_t)v42);
            *(int8x8_t *)v41.i8 = vmovn_s16((int16x8_t)v41);
            v41.i16[2] = v41.i16[1];
            unint64_t v58 = (unsigned __int8 *)(v44 + v71[0]);
            uint64_t v59 = (__int8 *)(v58 + 1);
            __int32 v60 = *v58;
            int32x4_t v61 = &v58[v73];
            v42.i32[0] = v60;
            v42.i8[4] = *v59;
            v43.i32[0] = *v61;
            v43.i8[4] = v61[1];
            int8x16_t v42 = (int8x16_t)vtrn1q_s16((int16x8_t)v42, (int16x8_t)v43);
            *(int8x8_t *)v42.i8 = vmovn_s16((int16x8_t)v42);
            v42.i16[2] = v42.i16[1];
            int16x4_t v62 = vtrn1_s16(*(int16x4_t *)v41.i8, *(int16x4_t *)v42.i8);
            vst2_s16(v45, *(int16x4x2_t *)(&v40 - 1));
            v45 += 8;
            unint64_t v44 = v56;
            v56 += 2;
          }
          while (v56 <= a9);
          unint64_t v44 = v56 - 2;
        }
        if (v44 < a9)
        {
          do
          {
            LOBYTE(v70) = *(unsigned char *)(v44 + v74[0]);
            HIBYTE(v70) = *(unsigned char *)(v44 + v76 + v74[0]);
            LOBYTE(v69) = *(unsigned char *)(v44 + v71[0]);
            HIBYTE(v69) = *(unsigned char *)(v44 + v73 + v71[0]);
            LOWORD(v63) = v70;
            WORD1(v63) = v37;
            WORD2(v63) = v69;
            HIWORD(v63) = v38;
            *(void *)int16x4_t v45 = v63;
            v45 += 4;
            ++v44;
          }
          while (a9 != v44);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v34 += a10;
      }
      while (v34 + (unint64_t)a3[14] < v65);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v76, result, a2, a4, (uint64_t)a3);
    uint64_t v21 = *a5;
    _Q0.val[0] = *(unsigned char *)(*a5 + 24) ? *(float32x2_t *)v21 : (float32x2_t)0x7FF8000000000000;
    int v22 = *(_DWORD *)(v21 + 16);
    if (v22 == 2)
    {
      *(float *)&long long v20 = *(double *)_Q0.val;
    }
    else if (v22 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v73[0]) = _Q0.val[0].i16[0];
      LOWORD(v73[0]) = _Q0.val[0].i16[0];
      LODWORD(v20) = v73[0];
    }
    else
    {
      _Q0.val[0].i32[0] = *(void *)_Q0.val;
      *(float *)&long long v20 = _Q0.val[0].f32[0];
    }
    float32x2x2_t v69 = _Q0;
    long long v71 = v20;
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v73, v18, a2, a6, (uint64_t)a3);
    uint64_t v28 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v28 : NAN;
    float32x2x2_t v30 = v69;
    long long v31 = v71;
    unint64_t v66 = HIDWORD(v12);
    int v32 = *(_DWORD *)(v28 + 16);
    if (v32 == 2)
    {
      float v33 = _D0;
    }
    else if (v32 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v79) = _H0;
      LOWORD(v79) = _H0;
      float v33 = v79;
    }
    else
    {
      LODWORD(v33) = _D0;
    }
    uint64_t v35 = a3[13];
    if ((unint64_t)a3[14] + v35 < v66)
    {
      __int32 v37 = v71;
      float v38 = v33;
      int v39 = a3[7] * *(_DWORD *)(a2 + 60);
      v40.i64[0] = __PAIR64__(LODWORD(v33), v71);
      v40.i64[1] = __PAIR64__(LODWORD(v33), v71);
      *((float *)&v31 + 1) = v33;
      do
      {
        int32x4_t v67 = v27;
        int8x16_t v68 = v40;
        float32x2x2_t v70 = v30;
        long long v72 = v31;
        int v77 = v39 + v35;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v76);
        int v74 = v39 + v35;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v73);
        if (a9 >= 4)
        {
          uint64_t v46 = 0;
          uint64_t v48 = v75;
          uint64_t v47 = (uint64_t *)v76[0];
          uint64_t v49 = v78;
          uint64_t v50 = a11;
          uint64_t v51 = (uint64_t *)v73[0];
          float32x2x2_t v30 = v70;
          long long v31 = v72;
          int8x16_t v40 = v68;
          do
          {
            v41.i64[0] = *v47;
            v42.i64[0] = *(uint64_t *)((char *)v47 + v49);
            int32x4_t v52 = (int32x4_t)vzip1q_s8(v41, v42);
            v42.i64[0] = *v51;
            v43.i64[0] = *(uint64_t *)((char *)v51 + v48);
            int32x4_t v53 = (int32x4_t)vzip1q_s8(v42, v43);
            int32x4_t v27 = vzip2q_s32(v52, v53);
            int8x16_t v41 = (int8x16_t)vzip1q_s32(v52, v53);
            int8x16_t v42 = v68;
            int16x4_t v45 = v50 + 16;
            vst2q_f32(v50, *(float32x4x2_t *)v41.i8);
            unint64_t v54 = v50 + 8;
            vst2q_f32(v54, *(float32x4x2_t *)v27.i8);
            unint64_t v44 = v46 + 4;
            unint64_t v55 = v46 + 8;
            ++v51;
            ++v47;
            v46 += 4;
            uint64_t v50 = v45;
          }
          while (v55 <= a9);
        }
        else
        {
          unint64_t v44 = 0;
          int16x4_t v45 = a11;
          float32x2x2_t v30 = v70;
          long long v31 = v72;
          int32x4_t v27 = v67;
          int8x16_t v40 = v68;
        }
        unint64_t v56 = v44 | 1;
        if ((v44 | 1) <= a9)
        {
          do
          {
            unint64_t v57 = (__int8 *)(v76[0] + 2 * v44);
            v41.i8[0] = *v57;
            v41.i8[4] = v57[1];
            unint64_t v58 = &v57[v78];
            uint64_t v59 = (__int8 *)(v73[0] + 2 * v44);
            v43.i8[0] = *v59;
            v43.i8[4] = v59[1];
            __int32 v60 = &v59[v75];
            v41.i8[1] = *v58;
            v41.i8[2] = v41.i8[4];
            v43.i8[1] = *v60;
            v43.i8[2] = v43.i8[4];
            v41.i8[3] = v58[1];
            v43.i8[3] = v60[1];
            v30.val[0] = (float32x2_t)vzip1_s32(*(int32x2_t *)v41.i8, *(int32x2_t *)v43.i8);
            vst2_f32(v45, v30);
            v45 += 4;
            unint64_t v44 = v56++;
          }
          while (v56 <= a9);
          unint64_t v44 = v56 - 1;
        }
        unint64_t v61 = a9 - v44;
        if (a9 > v44)
        {
          uint64_t v62 = 2 * v44;
          do
          {
            uint64_t v63 = (unsigned __int8 *)(v62 + v78 + v76[0]);
            v41.i32[0] = *(unsigned __int8 *)(v62 + v76[0]);
            v41.i8[4] = *(unsigned char *)(v62 + v76[0] + 1);
            v42.i32[0] = *v63;
            v42.i8[4] = v63[1];
            int v64 = (unsigned __int8 *)(v62 + v75 + v73[0]);
            v43.i32[0] = *(unsigned __int8 *)(v62 + v73[0]);
            int16x8_t v65 = vtrn1q_s16((int16x8_t)v41, (int16x8_t)v42);
            v43.i8[4] = *(unsigned char *)(v62 + v73[0] + 1);
            v42.i32[0] = *v64;
            v42.i8[4] = v64[1];
            v41.i32[0] = vmovn_s16(v65).u32[0];
            int8x16_t v42 = (int8x16_t)vtrn1q_s16((int16x8_t)v43, (int16x8_t)v42);
            *(int8x8_t *)v42.i8 = vmovn_s16((int16x8_t)v42);
            v41.i32[1] = v37;
            v41.i64[1] = __PAIR64__(LODWORD(v38), v42.u32[0]);
            *(int8x16_t *)int16x4_t v45 = v41;
            v45 += 4;
            v62 += 2;
            --v61;
          }
          while (v61);
        }
        a11 = (float *)((char *)a11 + a12);
        v35 += a10;
      }
      while (v35 + (unint64_t)a3[14] < v66);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v16 = result;
    uint64_t v17 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v17 : NAN;
    int v19 = *(_DWORD *)(v17 + 16);
    if (v19 == 2)
    {
      float v20 = _D0;
    }
    else if (v19 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v69[0]) = _H0;
      LOWORD(v69[0]) = _H0;
      float v20 = *(float *)v69;
    }
    else
    {
      LODWORD(v20) = _D0;
    }
    unsigned int v61 = LODWORD(v20);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v69, result, a2, a5, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v66, v16, a2, a6, (uint64_t)a3);
    uint64_t v26 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v26 : NAN;
    unint64_t v62 = HIDWORD(v12);
    int v28 = *(_DWORD *)(v26 + 16);
    if (v28 == 2)
    {
      *(float *)&unsigned int v29 = _D0;
    }
    else if (v28 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v72) = _H0;
      LOWORD(v72) = _H0;
      unsigned int v29 = v72;
    }
    else
    {
      unsigned int v29 = _D0;
    }
    uint64_t v31 = a3[13];
    if ((unint64_t)a3[14] + v31 < v62)
    {
      int v33 = a3[7] * *(_DWORD *)(a2 + 60);
      __int16 v34 = v29;
      int16x4_t v35 = (int16x4_t)vdup_n_s32(v61);
      int16x4_t v36 = (int16x4_t)vdup_n_s32(v29);
      int16x8_t v59 = vdupq_n_s16(v29);
      int16x8_t v60 = vdupq_n_s16(v61);
      do
      {
        int v70 = v33 + v31;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v69);
        int v67 = v33 + v31;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v66);
        if (a9 >= 8)
        {
          uint64_t v43 = 0;
          uint64_t v44 = v69[0];
          uint64_t v45 = v66[0];
          uint64_t v46 = v71 + v69[0];
          uint64_t v47 = v68 + v66[0];
          uint64_t v48 = a11;
          __int16 v42 = v61;
          do
          {
            v37.i64[0] = *(void *)(v44 + v43);
            v38.i64[0] = *(void *)(v46 + v43);
            v39.i64[0] = *(void *)(v45 + v43);
            int8x16_t v37 = vzip1q_s8(v37, v38);
            v38.i64[0] = *(void *)(v47 + v43);
            int16x8_t v49 = (int16x8_t)vzip1q_s8(v39, v38);
            v73.val[0] = vzip1q_s16(v60, v49);
            v73.val[1] = vzip1q_s16((int16x8_t)v37, v59);
            int8x16_t v41 = v48 + 32;
            vst2q_s16(v48, v73);
            uint64_t v50 = v48 + 16;
            int8x16_t v38 = (int8x16_t)vzip2q_s16(v60, v49);
            int8x16_t v39 = (int8x16_t)vzip2q_s16((int16x8_t)v37, v59);
            vst2q_s16(v50, *(int16x8x2_t *)v38.i8);
            unint64_t v40 = v43 + 8;
            unint64_t v51 = v43 + 16;
            v43 += 8;
            uint64_t v48 = v41;
          }
          while (v51 <= a9);
        }
        else
        {
          unint64_t v40 = 0;
          int8x16_t v41 = a11;
          __int16 v42 = v61;
        }
        unint64_t v52 = v40 | 2;
        if ((v40 | 2) <= a9)
        {
          do
          {
            int32x4_t v53 = (unsigned __int8 *)(v40 + v69[0] + v71);
            v37.i32[0] = *(unsigned __int8 *)(v40 + v69[0]);
            v37.i8[4] = *(unsigned char *)(v40 + v69[0] + 1);
            v38.i32[0] = *v53;
            v38.i8[4] = v53[1];
            int8x16_t v37 = (int8x16_t)vtrn1q_s16((int16x8_t)v37, (int16x8_t)v38);
            *(int8x8_t *)v37.i8 = vmovn_s16((int16x8_t)v37);
            v37.i16[2] = v37.i16[1];
            unint64_t v54 = (unsigned __int8 *)(v40 + v66[0]);
            unint64_t v55 = (__int8 *)(v54 + 1);
            __int32 v56 = *v54;
            unint64_t v57 = &v54[v68];
            v38.i32[0] = v56;
            v38.i8[4] = *v55;
            v39.i32[0] = *v57;
            v39.i8[4] = v57[1];
            int8x16_t v38 = (int8x16_t)vtrn1q_s16((int16x8_t)v38, (int16x8_t)v39);
            *(int8x8_t *)v38.i8 = vmovn_s16((int16x8_t)v38);
            v38.i16[2] = v38.i16[1];
            *(int16x4_t *)v38.i8 = vtrn1_s16(v35, *(int16x4_t *)v38.i8);
            *(int16x4_t *)v39.i8 = vtrn1_s16(*(int16x4_t *)v37.i8, v36);
            vst2_s16(v41, (int16x4x2_t)v38);
            v41 += 8;
            unint64_t v40 = v52;
            v52 += 2;
          }
          while (v52 <= a9);
          unint64_t v40 = v52 - 2;
        }
        if (v40 < a9)
        {
          do
          {
            LOBYTE(v65) = *(unsigned char *)(v40 + v69[0]);
            HIBYTE(v65) = *(unsigned char *)(v40 + v71 + v69[0]);
            LOBYTE(v64) = *(unsigned char *)(v40 + v66[0]);
            HIBYTE(v64) = *(unsigned char *)(v40 + v68 + v66[0]);
            LOWORD(v58) = v42;
            WORD1(v58) = v65;
            WORD2(v58) = v64;
            HIWORD(v58) = v34;
            *(void *)int8x16_t v41 = v58;
            v41 += 4;
            ++v40;
          }
          while (a9 != v40);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v31 += a10;
      }
      while (v31 + (unint64_t)a3[14] < v62);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    uint64_t v18 = result;
    uint64_t v19 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v19 : NAN;
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v66[0]) = _H0;
      LOWORD(v66[0]) = _H0;
      LODWORD(_D0) = v66[0];
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    int32x2_t v62 = *(int32x2_t *)&_D0;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v66, result, a2, a5, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v63, v18, a2, a6, (uint64_t)a3);
    uint64_t v27 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v27 : NAN;
    unint64_t v29 = HIDWORD(v13);
    int v30 = *(_DWORD *)(v27 + 16);
    if (v30 == 2)
    {
      *(float *)v12.i32 = _D0;
    }
    else if (v30 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v69) = _H0;
      LOWORD(v69) = _H0;
      v12.i32[0] = v69;
    }
    else
    {
      v12.i32[0] = _D0;
    }
    uint64_t v32 = a3[13];
    if ((unint64_t)a3[14] + v32 < v29)
    {
      int v34 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v60 = vdupq_n_s32(v12.u32[0]);
      int32x4_t v61 = vdupq_n_s32(v62.u32[0]);
      do
      {
        int v67 = v34 + v32;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v66);
        int v64 = v34 + v32;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v63);
        if (a9 >= 4)
        {
          uint64_t v41 = 0;
          uint64_t v43 = v65;
          __int16 v42 = (uint64_t *)v66[0];
          uint64_t v44 = v68;
          uint64_t v45 = a11;
          uint64_t v46 = (uint64_t *)v63[0];
          int32x2_t v40 = v62;
          do
          {
            v35.i64[0] = *v42;
            v36.i64[0] = *(uint64_t *)((char *)v42 + v44);
            int8x16_t v35 = vzip1q_s8(v35, v36);
            v36.i64[0] = *v46;
            v37.i64[0] = *(uint64_t *)((char *)v46 + v43);
            int8x16_t v36 = vzip1q_s8(v36, v37);
            int8x16_t v37 = (int8x16_t)vzip2q_s32(v61, (int32x4_t)v36);
            v70.val[0] = (float32x4_t)vzip1q_s32(v61, (int32x4_t)v36);
            v70.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v35, v60);
            int8x16_t v39 = v45 + 16;
            vst2q_f32(v45, v70);
            uint64_t v47 = v45 + 8;
            int32x4_t v48 = vzip2q_s32((int32x4_t)v35, v60);
            vst2q_f32(v47, *(float32x4x2_t *)v37.i8);
            unint64_t v38 = v41 + 4;
            unint64_t v49 = v41 + 8;
            ++v46;
            ++v42;
            v41 += 4;
            uint64_t v45 = v39;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v38 = 0;
          int8x16_t v39 = a11;
          int32x2_t v40 = v62;
        }
        unint64_t v50 = v38 | 1;
        if ((v38 | 1) <= a9)
        {
          do
          {
            unint64_t v51 = (__int8 *)(v66[0] + 2 * v38);
            unint64_t v52 = v51 + 1;
            v35.i8[0] = *v51;
            int32x4_t v53 = &v51[v68];
            v35.i8[4] = *v52;
            unint64_t v54 = (__int8 *)(v63[0] + 2 * v38);
            v37.i8[0] = *v54;
            v37.i8[4] = v54[1];
            unint64_t v55 = &v54[v65];
            v35.i8[1] = *v53;
            v37.i8[1] = *v55;
            v35.i8[2] = *v52;
            v37.i8[2] = v37.i8[4];
            v35.i8[3] = v53[1];
            v37.i8[3] = v55[1];
            *(int32x2_t *)v36.i8 = vzip1_s32(v40, *(int32x2_t *)v37.i8);
            *(int32x2_t *)v37.i8 = vzip1_s32(*(int32x2_t *)v35.i8, v12);
            vst2_f32(v39, (float32x2x2_t)v36);
            v39 += 4;
            unint64_t v38 = v50++;
          }
          while (v50 <= a9);
          unint64_t v38 = v50 - 1;
        }
        unint64_t v56 = a9 - v38;
        if (a9 > v38)
        {
          uint64_t v57 = 2 * v38;
          do
          {
            uint64_t v58 = (unsigned __int8 *)(v57 + v68 + v66[0]);
            v35.i32[0] = *(unsigned __int8 *)(v57 + v66[0]);
            v35.i8[4] = *(unsigned char *)(v57 + v66[0] + 1);
            v36.i32[0] = *v58;
            v36.i8[4] = v58[1];
            int8x16_t v35 = (int8x16_t)vtrn1q_s16((int16x8_t)v35, (int16x8_t)v36);
            int16x8_t v59 = (unsigned __int8 *)(v57 + v65 + v63[0]);
            v36.i32[0] = *(unsigned __int8 *)(v57 + v63[0]);
            *(int8x8_t *)v35.i8 = vmovn_s16((int16x8_t)v35);
            v36.i8[4] = *(unsigned char *)(v57 + v63[0] + 1);
            v37.i32[0] = *v59;
            v37.i8[4] = v59[1];
            int8x16_t v36 = (int8x16_t)vtrn1q_s16((int16x8_t)v36, (int16x8_t)v37);
            *(int8x8_t *)v36.i8 = vmovn_s16((int16x8_t)v36);
            v37.i64[0] = __PAIR64__(v35.u32[0], v40.u32[0]);
            v37.i64[1] = __PAIR64__(v12.u32[0], v36.u32[0]);
            *(int8x16_t *)int8x16_t v39 = v37;
            v39 += 4;
            v57 += 2;
            --v56;
          }
          while (v56);
        }
        a11 = (float *)((char *)a11 + a12);
        v32 += a10;
      }
      while (v32 + (unint64_t)a3[14] < v29);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)0>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v71, result, a2, a4, (uint64_t)a3);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v68, v18, a2, a5, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v65, v18, a2, a6, (uint64_t)a3);
    uint64_t v19 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v19 : NAN;
    unint64_t v61 = HIDWORD(v12);
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      *(float *)&unsigned int v22 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v74) = _H0;
      LOWORD(v74) = _H0;
      unsigned int v22 = v74;
    }
    else
    {
      unsigned int v22 = _D0;
    }
    uint64_t v28 = a3[13];
    if ((unint64_t)a3[14] + v28 < v61)
    {
      int v60 = a3[7] * *(_DWORD *)(a2 + 60);
      __int16 v30 = v22;
      int16x4_t v31 = (int16x4_t)vdup_n_s32(v22);
      int16x8_t v59 = vdupq_n_s16(v22);
      do
      {
        uint64_t v32 = v28;
        int v33 = v60 + v28;
        int v72 = v60 + v28;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v71);
        int v69 = v33;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v68);
        int v66 = v33;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v65);
        if (a9 >= 8)
        {
          uint64_t v41 = 0;
          uint64_t v42 = v71[0];
          uint64_t v43 = v68[0];
          uint64_t v44 = v65[0];
          uint64_t v45 = v73 + v71[0];
          uint64_t v46 = v70 + v68[0];
          uint64_t v47 = v67 + v65[0];
          int32x4_t v48 = a11;
          uint64_t v40 = v32;
          do
          {
            v34.i64[0] = *(void *)(v42 + v41);
            v35.i64[0] = *(void *)(v45 + v41);
            int8x16_t v34 = vzip1q_s8(v34, v35);
            v35.i64[0] = *(void *)(v43 + v41);
            v36.i64[0] = *(void *)(v46 + v41);
            v37.i64[0] = *(void *)(v44 + v41);
            int8x16_t v35 = vzip1q_s8(v35, v36);
            v36.i64[0] = *(void *)(v47 + v41);
            int16x8_t v49 = (int16x8_t)vzip1q_s8(v37, v36);
            v75.val[0] = vzip1q_s16((int16x8_t)v34, v49);
            v75.val[1] = vzip1q_s16((int16x8_t)v35, v59);
            int8x16_t v39 = v48 + 32;
            vst2q_s16(v48, v75);
            unint64_t v50 = v48 + 16;
            int8x16_t v36 = (int8x16_t)vzip2q_s16((int16x8_t)v34, v49);
            int8x16_t v37 = (int8x16_t)vzip2q_s16((int16x8_t)v35, v59);
            vst2q_s16(v50, *(int16x8x2_t *)v36.i8);
            unint64_t v38 = v41 + 8;
            unint64_t result = v41 + 16;
            v41 += 8;
            int32x4_t v48 = v39;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v38 = 0;
          int8x16_t v39 = a11;
          uint64_t v40 = v32;
        }
        unint64_t v51 = v38 | 2;
        if ((v38 | 2) <= a9)
        {
          do
          {
            unint64_t v52 = (unsigned __int8 *)(v38 + v71[0] + v73);
            v34.i32[0] = *(unsigned __int8 *)(v38 + v71[0]);
            v34.i8[4] = *(unsigned char *)(v38 + v71[0] + 1);
            v35.i32[0] = *v52;
            v35.i8[4] = v52[1];
            int8x16_t v34 = (int8x16_t)vtrn1q_s16((int16x8_t)v34, (int16x8_t)v35);
            *(int8x8_t *)v34.i8 = vmovn_s16((int16x8_t)v34);
            v34.i16[2] = v34.i16[1];
            int32x4_t v53 = (unsigned __int8 *)(v38 + v68[0] + v70);
            v35.i32[0] = *(unsigned __int8 *)(v38 + v68[0]);
            v35.i8[4] = *(unsigned char *)(v38 + v68[0] + 1);
            v36.i32[0] = *v53;
            v36.i8[4] = v53[1];
            int8x16_t v35 = (int8x16_t)vtrn1q_s16((int16x8_t)v35, (int16x8_t)v36);
            *(int8x8_t *)v35.i8 = vmovn_s16((int16x8_t)v35);
            v35.i16[2] = v35.i16[1];
            unint64_t v54 = (unsigned __int8 *)(v38 + v65[0]);
            unint64_t v55 = (__int8 *)(v54 + 1);
            __int32 v56 = *v54;
            uint64_t v57 = &v54[v67];
            v36.i32[0] = v56;
            v36.i8[4] = *v55;
            v37.i32[0] = *v57;
            v37.i8[4] = v57[1];
            int8x16_t v36 = (int8x16_t)vtrn1q_s16((int16x8_t)v36, (int16x8_t)v37);
            *(int8x8_t *)v36.i8 = vmovn_s16((int16x8_t)v36);
            v36.i16[2] = v36.i16[1];
            *(int16x4_t *)v36.i8 = vtrn1_s16(*(int16x4_t *)v34.i8, *(int16x4_t *)v36.i8);
            *(int16x4_t *)v37.i8 = vtrn1_s16(*(int16x4_t *)v35.i8, v31);
            vst2_s16(v39, (int16x4x2_t)v36);
            v39 += 8;
            unint64_t v38 = v51;
            v51 += 2;
          }
          while (v51 <= a9);
          unint64_t v38 = v51 - 2;
        }
        if (v38 < a9)
        {
          do
          {
            LOBYTE(v64) = *(unsigned char *)(v38 + v71[0]);
            HIBYTE(v64) = *(unsigned char *)(v38 + v73 + v71[0]);
            LOBYTE(v63) = *(unsigned char *)(v38 + v68[0]);
            HIBYTE(v63) = *(unsigned char *)(v38 + v70 + v68[0]);
            LOBYTE(v62) = *(unsigned char *)(v38 + v65[0]);
            HIBYTE(v62) = *(unsigned char *)(v38 + v67 + v65[0]);
            LOWORD(v58) = v64;
            WORD1(v58) = v63;
            WORD2(v58) = v62;
            HIWORD(v58) = v30;
            *(void *)int8x16_t v39 = v58;
            v39 += 4;
            ++v38;
          }
          while (a9 != v38);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        uint64_t v28 = v40 + a10;
      }
      while (v28 + (unint64_t)a3[14] < v61);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)0>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    uint64_t v19 = result;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v73, result, a2, a4, (uint64_t)a3);
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v70, v19, a2, a5, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v67, v19, a2, a6, (uint64_t)a3);
    uint64_t v20 = *a7;
    _D0 = *(unsigned char *)(*a7 + 24) ? *(double *)v20 : NAN;
    unint64_t v66 = HIDWORD(v13);
    int v22 = *(_DWORD *)(v20 + 16);
    if (v22 == 2)
    {
      *(float *)v12.i32 = _D0;
    }
    else if (v22 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v76) = _H0;
      LOWORD(v76) = _H0;
      v12.i32[0] = v76;
    }
    else
    {
      v12.i32[0] = _D0;
    }
    uint64_t v28 = a3[13];
    if ((unint64_t)a3[14] + v28 < v66)
    {
      int v30 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v65 = vdupq_n_s32(v12.u32[0]);
      do
      {
        int v74 = v30 + v28;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v73);
        int v71 = v30 + v28;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v70);
        int v68 = v30 + v28;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v67);
        if (a9 >= 4)
        {
          uint64_t v38 = 0;
          uint64_t v40 = v72;
          int8x16_t v39 = (uint64_t *)v73[0];
          uint64_t v41 = v75;
          uint64_t v43 = v69;
          uint64_t v42 = (uint64_t *)v70[0];
          uint64_t v44 = a11;
          uint64_t v45 = (uint64_t *)v67[0];
          do
          {
            v31.i64[0] = *v39;
            v32.i64[0] = *(uint64_t *)((char *)v39 + v41);
            int8x16_t v31 = vzip1q_s8(v31, v32);
            v32.i64[0] = *v42;
            v33.i64[0] = *(uint64_t *)((char *)v42 + v40);
            int8x16_t v32 = vzip1q_s8(v32, v33);
            v33.i64[0] = *(uint64_t *)((char *)v45 + v43);
            uint64_t v46 = *v45++;
            v34.i64[0] = v46;
            int8x16_t v33 = vzip1q_s8(v34, v33);
            int8x16_t v34 = (int8x16_t)vzip2q_s32((int32x4_t)v31, (int32x4_t)v33);
            int32x4_t v35 = vzip2q_s32((int32x4_t)v32, v65);
            v77.val[0] = (float32x4_t)vzip1q_s32((int32x4_t)v31, (int32x4_t)v33);
            v77.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v32, v65);
            int8x16_t v37 = v44 + 16;
            vst2q_f32(v44, v77);
            uint64_t v47 = v44 + 8;
            vst2q_f32(v47, *(float32x4x2_t *)v34.i8);
            unint64_t v36 = v38 + 4;
            unint64_t result = v38 + 8;
            ++v42;
            ++v39;
            v38 += 4;
            uint64_t v44 = v37;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v36 = 0;
          int8x16_t v37 = a11;
        }
        unint64_t v48 = v36 | 1;
        if ((v36 | 1) <= a9)
        {
          do
          {
            int16x8_t v49 = (__int8 *)(v73[0] + 2 * v36);
            unint64_t v50 = v49 + 1;
            v32.i8[0] = *v49;
            unint64_t v51 = &v49[v75];
            v32.i8[4] = *v50;
            __int8 v52 = *v51;
            __int8 v53 = v51[1];
            unint64_t v54 = (__int8 *)(v70[0] + 2 * v36);
            v33.i8[0] = *v54;
            v33.i8[4] = v54[1];
            unint64_t v55 = &v54[v72];
            v32.i8[1] = v52;
            __int32 v56 = (__int8 *)(v67[0] + 2 * v36);
            v35.i8[0] = *v56;
            v33.i8[1] = *v55;
            v35.i8[4] = v56[1];
            uint64_t v57 = &v56[v69];
            v32.i8[2] = *v50;
            v33.i8[2] = v33.i8[4];
            v35.i8[1] = *v57;
            v32.i8[3] = v53;
            v35.i8[2] = v35.i8[4];
            v33.i8[3] = v55[1];
            v35.i8[3] = v57[1];
            *(int32x2_t *)v34.i8 = vzip1_s32(*(int32x2_t *)v32.i8, *(int32x2_t *)v35.i8);
            *(int32x2_t *)v35.i8 = vzip1_s32(*(int32x2_t *)v33.i8, v12);
            vst2_f32(v37, (float32x2x2_t)v34);
            v37 += 4;
            unint64_t v36 = v48++;
          }
          while (v48 <= a9);
          unint64_t v36 = v48 - 1;
        }
        unint64_t v58 = a9 - v36;
        if (a9 > v36)
        {
          uint64_t v59 = 2 * v36;
          do
          {
            int v60 = (unsigned __int8 *)(v59 + v75 + v73[0]);
            unint64_t v61 = (__int8 *)(v60 + 1);
            v31.i32[0] = *(unsigned __int8 *)(v59 + v73[0]);
            v31.i8[4] = *(unsigned char *)(v59 + v73[0] + 1);
            v32.i32[0] = *v60;
            __int16 v62 = (unsigned __int8 *)(v59 + v72 + v70[0]);
            v33.i32[0] = *(unsigned __int8 *)(v59 + v70[0]);
            v32.i8[4] = *v61;
            v33.i8[4] = *(unsigned char *)(v59 + v70[0] + 1);
            v34.i32[0] = *v62;
            v34.i8[4] = v62[1];
            int16x8_t v63 = vtrn1q_s16((int16x8_t)v31, (int16x8_t)v32);
            int8x16_t v32 = (int8x16_t)vtrn1q_s16((int16x8_t)v33, (int16x8_t)v34);
            __int16 v64 = (unsigned __int8 *)(v59 + v69 + v67[0]);
            v33.i32[0] = *(unsigned __int8 *)(v59 + v67[0]);
            v31.i32[0] = vmovn_s16(v63).u32[0];
            v33.i8[4] = *(unsigned char *)(v59 + v67[0] + 1);
            v34.i32[0] = *v64;
            v34.i8[4] = v64[1];
            *(int8x8_t *)v32.i8 = vmovn_s16((int16x8_t)v32);
            int8x16_t v33 = (int8x16_t)vtrn1q_s16((int16x8_t)v33, (int16x8_t)v34);
            *(int8x8_t *)v33.i8 = vmovn_s16((int16x8_t)v33);
            v31.i32[1] = v32.i32[0];
            v31.i64[1] = __PAIR64__(v12.u32[0], v33.u32[0]);
            *(int8x16_t *)int8x16_t v37 = v31;
            v37 += 4;
            v59 += 2;
            --v58;
          }
          while (v58);
        }
        a11 = (float *)((char *)a11 + a12);
        v28 += a10;
      }
      while (v28 + (unint64_t)a3[14] < v66);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7, double a8, double a9, uint64_t a10, unint64_t a11, unsigned int a12, __int16 *a13, uint64_t a14)
{
  unint64_t v15 = *(void *)(a2 + 56);
  if (v15)
  {
    uint64_t v17 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v17 : NAN;
    int v19 = *(_DWORD *)(v17 + 16);
    if (v19 == 2)
    {
      *(float *)&a9 = _D0;
    }
    else if (v19 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      LODWORD(a9) = v71[0];
    }
    else
    {
      LODWORD(a9) = _D0;
    }
    uint64_t v25 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v25 : NAN;
    int v27 = *(_DWORD *)(v25 + 16);
    if (v27 == 2)
    {
      *(float *)&unsigned int v28 = _D0;
    }
    else if (v27 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      unsigned int v28 = v71[0];
    }
    else
    {
      unsigned int v28 = _D0;
    }
    uint64_t v30 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v30 : NAN;
    unint64_t v32 = HIDWORD(v15);
    int v33 = *(_DWORD *)(v30 + 16);
    double v66 = a9;
    if (v33 == 2)
    {
      *(float *)&unsigned int v34 = _D0;
    }
    else if (v33 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      unsigned int v34 = v71[0];
    }
    else
    {
      unsigned int v34 = _D0;
    }
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v71, result, a2, a7, (uint64_t)a3);
    uint64_t v37 = a3[13];
    if ((unint64_t)a3[14] + v37 < v32)
    {
      int v39 = a3[7] * *(_DWORD *)(a2 + 60);
      double v40 = v66;
      __int16 v41 = v28;
      int16x8_t v42 = vdupq_n_s16(v28);
      v74.val[1] = (int8x16_t)vdupq_n_s16(v34);
      v74.val[0] = (int8x16_t)vdupq_n_s16(LODWORD(v66));
      int8x16_t v43 = vqtbl2q_s8(v74, (int8x16_t)xmmword_228F41B50);
      int16x4_t v44 = (int16x4_t)vdup_n_s32(v28);
      v74.val[0].i16[0] = LOWORD(v66);
      v74.val[0].i16[1] = LOWORD(v66);
      v74.val[0].i16[2] = v34;
      v74.val[0].i16[3] = v34;
      int16x4_t v45 = vuzp1_s16(*(int16x4_t *)v74.val[0].i8, vrev32_s16(*(int16x4_t *)v74.val[0].i8));
      WORD1(v40) = v41;
      WORD2(v40) = v74.val[0].i16[2];
      int16x8_t v65 = v42;
      double v67 = v40;
      do
      {
        int8x16_t v68 = v43;
        int16x8_t v69 = v36;
        int v72 = v39 + v37;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v71);
        if (a11 >= 8)
        {
          uint64_t v51 = 0;
          uint64_t v52 = v71[0];
          uint64_t v53 = v73 + v71[0];
          unint64_t v54 = a13;
          double v50 = v67;
          int8x16_t v43 = v68;
          do
          {
            v46.i64[0] = *(void *)(v52 + v51);
            v47.i64[0] = *(void *)(v53 + v51);
            int8x16_t v46 = vzip1q_s8(v46, v47);
            int16x8_t v55 = vzip1q_s16(v65, (int16x8_t)v46);
            int16x8_t v36 = vzip2q_s16(v65, (int16x8_t)v46);
            int16x8_t v49 = v54 + 32;
            int8x16_t v47 = v68;
            vst2q_s16(v54, *(int16x8x2_t *)v47.i8);
            __int32 v56 = v54 + 16;
            vst2q_s16(v56, *(int16x8x2_t *)(&v36 - 1));
            unint64_t v48 = v51 + 8;
            unint64_t v57 = v51 + 16;
            v51 += 8;
            unint64_t v54 = v49;
          }
          while (v57 <= a11);
        }
        else
        {
          unint64_t v48 = 0;
          int16x8_t v49 = a13;
          double v50 = v67;
          int8x16_t v43 = v68;
          int16x8_t v36 = v69;
        }
        unint64_t v58 = v48 | 2;
        if ((v48 | 2) <= a11)
        {
          do
          {
            uint64_t v59 = (unsigned __int8 *)(v48 + v71[0]);
            int v60 = (__int8 *)(v59 + 1);
            __int32 v61 = *v59;
            __int16 v62 = &v59[v73];
            v46.i32[0] = v61;
            v46.i8[4] = *v60;
            v47.i32[0] = *v62;
            v47.i8[4] = v62[1];
            int8x16_t v46 = (int8x16_t)vtrn1q_s16((int16x8_t)v46, (int16x8_t)v47);
            *(int8x8_t *)v46.i8 = vmovn_s16((int16x8_t)v46);
            v46.i16[2] = v46.i16[1];
            int16x4_t v63 = vtrn1_s16(v44, *(int16x4_t *)v46.i8);
            vst2_s16(v49, *(int16x4x2_t *)v45.i8);
            v49 += 8;
            unint64_t v48 = v58;
            v58 += 2;
          }
          while (v58 <= a11);
          unint64_t v48 = v58 - 2;
        }
        if (v48 < a11)
        {
          do
          {
            LOBYTE(v70) = *(unsigned char *)(v48 + v71[0]);
            HIBYTE(v70) = *(unsigned char *)(v48 + v73 + v71[0]);
            double v64 = v50;
            HIWORD(v64) = v70;
            *(double *)int16x8_t v49 = v64;
            v49 += 4;
            ++v48;
          }
          while (a11 != v48);
        }
        a13 = (__int16 *)((char *)a13 + a14);
        v37 += a12;
      }
      while (v37 + (unint64_t)a3[14] < v32);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7, double a8, __n128 a9, uint64_t a10, unint64_t a11, unsigned int a12, float *a13, uint64_t a14)
{
  unint64_t v16 = *(void *)(a2 + 56);
  if (v16)
  {
    uint64_t v18 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v18 : NAN;
    int v20 = *(_DWORD *)(v18 + 16);
    if (v20 == 2)
    {
      a9.n128_f32[0] = _D0;
    }
    else if (v20 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v70[0]) = _H0;
      LOWORD(v70[0]) = _H0;
      a9.n128_u32[0] = v70[0];
    }
    else
    {
      a9.n128_u32[0] = _D0;
    }
    uint64_t v26 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v26 : NAN;
    int v28 = *(_DWORD *)(v26 + 16);
    if (v28 == 2)
    {
      *(float *)v14.i32 = _D0;
    }
    else if (v28 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v70[0]) = _H0;
      LOWORD(v70[0]) = _H0;
      v14.i32[0] = v70[0];
    }
    else
    {
      v14.i32[0] = _D0;
    }
    uint64_t v30 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v30 : NAN;
    unint64_t v32 = HIDWORD(v16);
    int v33 = *(_DWORD *)(v30 + 16);
    __n128 v63 = a9;
    if (v33 == 2)
    {
      float v34 = _D0;
    }
    else if (v33 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v70[0]) = _H0;
      LOWORD(v70[0]) = _H0;
      float v34 = *(float *)v70;
    }
    else
    {
      LODWORD(v34) = _D0;
    }
    float v67 = v34;
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v70, result, a2, a7, (uint64_t)a3);
    uint64_t v38 = a3[13];
    if ((unint64_t)a3[14] + v38 < v32)
    {
      __n128 v40 = v63;
      v42.i64[0] = __PAIR64__(LODWORD(v67), v63.n128_u32[0]);
      int v41 = a3[7] * *(_DWORD *)(a2 + 60);
      v42.i64[1] = __PAIR64__(LODWORD(v67), v63.n128_u32[0]);
      __n128 v43 = v63;
      v43.n128_f32[1] = v67;
      v40.n128_u32[1] = v14.i32[0];
      v40.n128_f32[2] = v67;
      int32x4_t v62 = vdupq_n_s32(v14.u32[0]);
      __n128 v64 = v40;
      do
      {
        __n128 v65 = v43;
        long long v66 = v37;
        int8x16_t v68 = v42;
        int32x4_t v69 = v36;
        int v71 = v41 + v38;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v70);
        if (a11 >= 4)
        {
          uint64_t v49 = 0;
          double v50 = (uint64_t *)v70[0];
          uint64_t v51 = v72;
          uint64_t v52 = a13;
          int8x16_t v48 = (int8x16_t)v64;
          int8x16_t v42 = v68;
          __n128 v43 = v65;
          long long v37 = v66;
          do
          {
            v44.i64[0] = *v50;
            v45.i64[0] = *(uint64_t *)((char *)v50 + v51);
            int8x16_t v44 = vzip1q_s8(v44, v45);
            int32x4_t v53 = vzip1q_s32(v62, (int32x4_t)v44);
            int32x4_t v36 = vzip2q_s32(v62, (int32x4_t)v44);
            int8x16_t v47 = v52 + 16;
            int8x16_t v45 = v68;
            vst2q_f32(v52, *(float32x4x2_t *)v45.i8);
            unint64_t v54 = v52 + 8;
            vst2q_f32(v54, *(float32x4x2_t *)(&v36 - 1));
            unint64_t v46 = v49 + 4;
            unint64_t v55 = v49 + 8;
            ++v50;
            v49 += 4;
            uint64_t v52 = v47;
          }
          while (v55 <= a11);
        }
        else
        {
          unint64_t v46 = 0;
          int8x16_t v47 = a13;
          int8x16_t v48 = (int8x16_t)v64;
          int8x16_t v42 = v68;
          int32x4_t v36 = v69;
          __n128 v43 = v65;
          long long v37 = v66;
        }
        unint64_t v56 = v46 | 1;
        if ((v46 | 1) <= a11)
        {
          do
          {
            unint64_t v57 = (__int8 *)(v70[0] + 2 * v46);
            v44.i8[0] = *v57;
            v44.i8[4] = v57[1];
            unint64_t v58 = &v57[v72];
            v44.i8[1] = *v58;
            v44.i8[2] = v44.i8[4];
            v44.i8[3] = v58[1];
            *(int32x2_t *)&long long v37 = vzip1_s32(v14, *(int32x2_t *)v44.i8);
            vst2_f32(v47, *(float32x2x2_t *)((char *)&v37 - 8));
            v47 += 4;
            unint64_t v46 = v56++;
          }
          while (v56 <= a11);
          unint64_t v46 = v56 - 1;
        }
        unint64_t v59 = a11 - v46;
        if (a11 > v46)
        {
          uint64_t v60 = 2 * v46;
          do
          {
            __int32 v61 = (unsigned __int8 *)(v60 + v72 + v70[0]);
            v44.i32[0] = *(unsigned __int8 *)(v60 + v70[0]);
            v44.i8[4] = *(unsigned char *)(v60 + v70[0] + 1);
            v45.i32[0] = *v61;
            v45.i8[4] = v61[1];
            int8x16_t v44 = (int8x16_t)vtrn1q_s16((int16x8_t)v44, (int16x8_t)v45);
            *(int8x8_t *)v44.i8 = vmovn_s16((int16x8_t)v44);
            int8x16_t v45 = v48;
            v45.i32[3] = v44.i32[0];
            *(int8x16_t *)int8x16_t v47 = v45;
            v47 += 4;
            v60 += 2;
            --v59;
          }
          while (v59);
        }
        a13 = (float *)((char *)a13 + a14);
        v38 += a12;
      }
      while (v38 + (unint64_t)a3[14] < v32);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v72, result, a2, a4, (uint64_t)a3);
    uint64_t v19 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v19 : NAN;
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      *(float *)&unsigned int v22 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v69[0]) = _H0;
      LOWORD(v69[0]) = _H0;
      unsigned int v22 = v69[0];
    }
    else
    {
      unsigned int v22 = _D0;
    }
    uint64_t v28 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v28 : NAN;
    unint64_t v66 = HIDWORD(v12);
    int v30 = *(_DWORD *)(v28 + 16);
    if (v30 == 2)
    {
      *(float *)&unsigned int v31 = _D0;
    }
    else if (v30 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v69[0]) = _H0;
      LOWORD(v69[0]) = _H0;
      unsigned int v31 = v69[0];
    }
    else
    {
      unsigned int v31 = _D0;
    }
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v69, v18, a2, a7, (uint64_t)a3);
    uint64_t v33 = a3[13];
    if ((unint64_t)a3[14] + v33 < v66)
    {
      __int16 v35 = v22;
      int16x8_t v36 = vdupq_n_s16(v22);
      int v37 = *(_DWORD *)(a2 + 60);
      __int16 v38 = v31;
      int16x8_t v39 = vdupq_n_s16(v31);
      int16x4_t v40 = (int16x4_t)vdup_n_s32(v22);
      int v65 = a3[7] * v37;
      int16x4_t v41 = (int16x4_t)vdup_n_s32(v31);
      int16x8_t v63 = v39;
      int16x8_t v64 = v36;
      do
      {
        int v73 = v65 + v33;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v72);
        int v70 = v65 + v33;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v69);
        if (a9 >= 8)
        {
          uint64_t v47 = 0;
          uint64_t v48 = v72[0];
          uint64_t v49 = v69[0];
          uint64_t v50 = v74 + v72[0];
          uint64_t v51 = v71 + v69[0];
          uint64_t v52 = a11;
          do
          {
            v42.i64[0] = *(void *)(v48 + v47);
            v43.i64[0] = *(void *)(v50 + v47);
            v44.i64[0] = *(void *)(v49 + v47);
            int8x16_t v42 = vzip1q_s8(v42, v43);
            v43.i64[0] = *(void *)(v51 + v47);
            int8x16_t v43 = vzip1q_s8(v44, v43);
            v75.val[0] = vzip1q_s16((int16x8_t)v42, v63);
            v75.val[1] = vzip1q_s16(v64, (int16x8_t)v43);
            unint64_t v46 = v52 + 32;
            vst2q_s16(v52, v75);
            int32x4_t v53 = v52 + 16;
            int8x16_t v44 = (int8x16_t)vzip2q_s16((int16x8_t)v42, v63);
            v75.val[1] = vzip2q_s16(v64, (int16x8_t)v43);
            vst2q_s16(v53, *(int16x8x2_t *)v44.i8);
            unint64_t v45 = v47 + 8;
            unint64_t v54 = v47 + 16;
            v47 += 8;
            uint64_t v52 = v46;
          }
          while (v54 <= a9);
        }
        else
        {
          unint64_t v45 = 0;
          unint64_t v46 = a11;
        }
        unint64_t v55 = v45 | 2;
        if ((v45 | 2) <= a9)
        {
          do
          {
            unint64_t v56 = (unsigned __int8 *)(v45 + v72[0] + v74);
            v42.i32[0] = *(unsigned __int8 *)(v45 + v72[0]);
            v42.i8[4] = *(unsigned char *)(v45 + v72[0] + 1);
            v43.i32[0] = *v56;
            v43.i8[4] = v56[1];
            int8x16_t v42 = (int8x16_t)vtrn1q_s16((int16x8_t)v42, (int16x8_t)v43);
            *(int8x8_t *)v42.i8 = vmovn_s16((int16x8_t)v42);
            v42.i16[2] = v42.i16[1];
            unint64_t v57 = (unsigned __int8 *)(v45 + v69[0]);
            unint64_t v58 = (__int8 *)(v57 + 1);
            __int32 v59 = *v57;
            uint64_t v60 = &v57[v71];
            v43.i32[0] = v59;
            v43.i8[4] = *v58;
            v44.i32[0] = *v60;
            v44.i8[4] = v60[1];
            int8x16_t v43 = (int8x16_t)vtrn1q_s16((int16x8_t)v43, (int16x8_t)v44);
            *(int8x8_t *)v43.i8 = vmovn_s16((int16x8_t)v43);
            v43.i16[2] = v43.i16[1];
            *(int16x4_t *)v44.i8 = vtrn1_s16(*(int16x4_t *)v42.i8, v41);
            int16x4_t v61 = vtrn1_s16(v40, *(int16x4_t *)v43.i8);
            vst2_s16(v46, (int16x4x2_t)v44);
            v46 += 8;
            unint64_t v45 = v55;
            v55 += 2;
          }
          while (v55 <= a9);
          unint64_t v45 = v55 - 2;
        }
        if (v45 < a9)
        {
          do
          {
            LOBYTE(v68) = *(unsigned char *)(v45 + v72[0]);
            HIBYTE(v68) = *(unsigned char *)(v45 + v74 + v72[0]);
            LOBYTE(v67) = *(unsigned char *)(v45 + v69[0]);
            HIBYTE(v67) = *(unsigned char *)(v45 + v71 + v69[0]);
            LOWORD(v62) = v68;
            WORD1(v62) = v35;
            WORD2(v62) = v38;
            HIWORD(v62) = v67;
            *(void *)unint64_t v46 = v62;
            v46 += 4;
            ++v45;
          }
          while (a9 != v45);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v33 += a10;
      }
      while (v33 + (unint64_t)a3[14] < v66);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v14 = *(void *)(a2 + 56);
  if (v14)
  {
    uint64_t v20 = result;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v66, result, a2, a4, (uint64_t)a3);
    uint64_t v21 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v21 : NAN;
    int v23 = *(_DWORD *)(v21 + 16);
    if (v23 == 2)
    {
      *(float *)v12.i32 = _D0;
    }
    else if (v23 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v63[0]) = _H0;
      LOWORD(v63[0]) = _H0;
      v12.i32[0] = v63[0];
    }
    else
    {
      v12.i32[0] = _D0;
    }
    uint64_t v29 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v29 : NAN;
    unint64_t v62 = HIDWORD(v14);
    int v31 = *(_DWORD *)(v29 + 16);
    if (v31 == 2)
    {
      *(float *)v13.i32 = _D0;
    }
    else if (v31 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v63[0]) = _H0;
      LOWORD(v63[0]) = _H0;
      v13.i32[0] = v63[0];
    }
    else
    {
      v13.i32[0] = _D0;
    }
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v63, v20, a2, a7, (uint64_t)a3);
    uint64_t v33 = a3[13];
    if ((unint64_t)a3[14] + v33 < v62)
    {
      int v35 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v60 = vdupq_n_s32(v13.u32[0]);
      int32x4_t v61 = vdupq_n_s32(v12.u32[0]);
      do
      {
        int v67 = v35 + v33;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v66);
        int v64 = v35 + v33;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v63);
        if (a9 >= 4)
        {
          uint64_t v41 = 0;
          uint64_t v43 = v65;
          int8x16_t v42 = (uint64_t *)v66[0];
          uint64_t v44 = v68;
          unint64_t v45 = a11;
          unint64_t v46 = (uint64_t *)v63[0];
          do
          {
            v36.i64[0] = *v42;
            v37.i64[0] = *(uint64_t *)((char *)v42 + v44);
            int8x16_t v36 = vzip1q_s8(v36, v37);
            v37.i64[0] = *v46;
            v38.i64[0] = *(uint64_t *)((char *)v46 + v43);
            int8x16_t v37 = vzip1q_s8(v37, v38);
            int8x16_t v38 = (int8x16_t)vzip2q_s32((int32x4_t)v36, v60);
            v69.val[0] = (float32x4_t)vzip1q_s32((int32x4_t)v36, v60);
            v69.val[1] = (float32x4_t)vzip1q_s32(v61, (int32x4_t)v37);
            int16x4_t v40 = v45 + 16;
            vst2q_f32(v45, v69);
            uint64_t v47 = v45 + 8;
            int32x4_t v48 = vzip2q_s32(v61, (int32x4_t)v37);
            vst2q_f32(v47, *(float32x4x2_t *)v38.i8);
            unint64_t v39 = v41 + 4;
            unint64_t v49 = v41 + 8;
            ++v46;
            ++v42;
            v41 += 4;
            unint64_t v45 = v40;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v39 = 0;
          int16x4_t v40 = a11;
        }
        unint64_t v50 = v39 | 1;
        if ((v39 | 1) <= a9)
        {
          do
          {
            uint64_t v51 = (__int8 *)(v66[0] + 2 * v39);
            uint64_t v52 = v51 + 1;
            v36.i8[0] = *v51;
            int32x4_t v53 = &v51[v68];
            v36.i8[4] = *v52;
            unint64_t v54 = (__int8 *)(v63[0] + 2 * v39);
            v38.i8[0] = *v54;
            v38.i8[4] = v54[1];
            unint64_t v55 = &v54[v65];
            v36.i8[1] = *v53;
            v38.i8[1] = *v55;
            v36.i8[2] = *v52;
            v38.i8[2] = v38.i8[4];
            v36.i8[3] = v53[1];
            v38.i8[3] = v55[1];
            *(int32x2_t *)v36.i8 = vzip1_s32(*(int32x2_t *)v36.i8, v13);
            *(int32x2_t *)v37.i8 = vzip1_s32(v12, *(int32x2_t *)v38.i8);
            vst2_f32(v40, (float32x2x2_t)v36);
            v40 += 4;
            unint64_t v39 = v50++;
          }
          while (v50 <= a9);
          unint64_t v39 = v50 - 1;
        }
        unint64_t v56 = a9 - v39;
        if (a9 > v39)
        {
          uint64_t v57 = 2 * v39;
          do
          {
            unint64_t v58 = (unsigned __int8 *)(v57 + v68 + v66[0]);
            v36.i32[0] = *(unsigned __int8 *)(v57 + v66[0]);
            v36.i8[4] = *(unsigned char *)(v57 + v66[0] + 1);
            v37.i32[0] = *v58;
            v37.i8[4] = v58[1];
            v36.i32[0] = vmovn_s16(vtrn1q_s16((int16x8_t)v36, (int16x8_t)v37)).u32[0];
            __int32 v59 = (unsigned __int8 *)(v57 + v65 + v63[0]);
            v37.i32[0] = *(unsigned __int8 *)(v57 + v63[0]);
            v37.i8[4] = *(unsigned char *)(v57 + v63[0] + 1);
            v38.i32[0] = *v59;
            v38.i8[4] = v59[1];
            int8x16_t v37 = (int8x16_t)vtrn1q_s16((int16x8_t)v37, (int16x8_t)v38);
            v36.i32[1] = v12.i32[0];
            v36.i32[2] = v13.i32[0];
            *(int8x8_t *)v37.i8 = vmovn_s16((int16x8_t)v37);
            v36.i32[3] = v37.i32[0];
            *(int8x16_t *)int16x4_t v40 = v36;
            v40 += 4;
            v57 += 2;
            --v56;
          }
          while (v56);
        }
        a11 = (float *)((char *)a11 + a12);
        v33 += a10;
      }
      while (v33 + (unint64_t)a3[14] < v62);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v16 = result;
    uint64_t v17 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v17 : NAN;
    int v19 = *(_DWORD *)(v17 + 16);
    if (v19 == 2)
    {
      float v20 = _D0;
    }
    else if (v19 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      float v20 = *(float *)v71;
    }
    else
    {
      LODWORD(v20) = _D0;
    }
    unsigned int v61 = LODWORD(v20);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v71, result, a2, a5, (uint64_t)a3);
    uint64_t v26 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v26 : NAN;
    unint64_t v62 = HIDWORD(v12);
    int v28 = *(_DWORD *)(v26 + 16);
    if (v28 == 2)
    {
      *(float *)&unsigned int v29 = _D0;
    }
    else if (v28 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v68[0]) = _H0;
      LOWORD(v68[0]) = _H0;
      unsigned int v29 = v68[0];
    }
    else
    {
      unsigned int v29 = _D0;
    }
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v68, v16, a2, a7, (uint64_t)a3);
    uint64_t v32 = a3[13];
    if ((unint64_t)a3[14] + v32 < v62)
    {
      int v34 = a3[7] * *(_DWORD *)(a2 + 60);
      __int16 v35 = v29;
      v74.val[1] = (int8x16_t)vdupq_n_s16(v29);
      v74.val[0] = (int8x16_t)vdupq_n_s16(v61);
      int8x16_t v36 = vqtbl2q_s8(v74, (int8x16_t)xmmword_228F41B50);
      v74.val[0].i16[0] = v61;
      v74.val[0].i16[1] = v61;
      v74.val[0].i16[2] = v29;
      v74.val[0].i16[3] = v29;
      int16x4_t v37 = vuzp1_s16(*(int16x4_t *)v74.val[0].i8, vrev32_s16(*(int16x4_t *)v74.val[0].i8));
      do
      {
        int8x16_t v64 = v36;
        int16x8_t v65 = v31;
        int v72 = v34 + v32;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v71);
        int v69 = v34 + v32;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v68);
        if (a9 >= 8)
        {
          uint64_t v44 = 0;
          uint64_t v45 = v71[0];
          uint64_t v46 = v68[0];
          uint64_t v47 = v73 + v71[0];
          uint64_t v48 = v70 + v68[0];
          unint64_t v49 = a11;
          __int16 v43 = v61;
          int8x16_t v36 = v64;
          do
          {
            v38.i64[0] = *(void *)(v45 + v44);
            v39.i64[0] = *(void *)(v47 + v44);
            int8x16_t v38 = vzip1q_s8(v38, v39);
            v39.i64[0] = *(void *)(v46 + v44);
            v40.i64[0] = *(void *)(v48 + v44);
            int8x16_t v39 = vzip1q_s8(v39, v40);
            int16x8_t v50 = vzip1q_s16((int16x8_t)v38, (int16x8_t)v39);
            int16x8_t v31 = vzip2q_s16((int16x8_t)v38, (int16x8_t)v39);
            int8x16_t v42 = v49 + 32;
            int8x16_t v40 = v64;
            vst2q_s16(v49, *(int16x8x2_t *)v40.i8);
            uint64_t v51 = v49 + 16;
            vst2q_s16(v51, *(int16x8x2_t *)(&v31 - 1));
            unint64_t v41 = v44 + 8;
            unint64_t v52 = v44 + 16;
            v44 += 8;
            unint64_t v49 = v42;
          }
          while (v52 <= a9);
        }
        else
        {
          unint64_t v41 = 0;
          int8x16_t v42 = a11;
          __int16 v43 = v61;
          int8x16_t v36 = v64;
          int16x8_t v31 = v65;
        }
        unint64_t v53 = v41 | 2;
        if ((v41 | 2) <= a9)
        {
          do
          {
            unint64_t v54 = (unsigned __int8 *)(v41 + v71[0] + v73);
            v38.i32[0] = *(unsigned __int8 *)(v41 + v71[0]);
            v38.i8[4] = *(unsigned char *)(v41 + v71[0] + 1);
            v39.i32[0] = *v54;
            v39.i8[4] = v54[1];
            int8x16_t v38 = (int8x16_t)vtrn1q_s16((int16x8_t)v38, (int16x8_t)v39);
            *(int8x8_t *)v38.i8 = vmovn_s16((int16x8_t)v38);
            v38.i16[2] = v38.i16[1];
            unint64_t v55 = (unsigned __int8 *)(v41 + v68[0]);
            unint64_t v56 = (__int8 *)(v55 + 1);
            __int32 v57 = *v55;
            unint64_t v58 = &v55[v70];
            v39.i32[0] = v57;
            v39.i8[4] = *v56;
            v40.i32[0] = *v58;
            v40.i8[4] = v58[1];
            int8x16_t v39 = (int8x16_t)vtrn1q_s16((int16x8_t)v39, (int16x8_t)v40);
            *(int8x8_t *)v39.i8 = vmovn_s16((int16x8_t)v39);
            v39.i16[2] = v39.i16[1];
            int16x4_t v59 = vtrn1_s16(*(int16x4_t *)v38.i8, *(int16x4_t *)v39.i8);
            vst2_s16(v42, *(int16x4x2_t *)v37.i8);
            v42 += 8;
            unint64_t v41 = v53;
            v53 += 2;
          }
          while (v53 <= a9);
          unint64_t v41 = v53 - 2;
        }
        if (v41 < a9)
        {
          do
          {
            LOBYTE(v67) = *(unsigned char *)(v41 + v71[0]);
            HIBYTE(v67) = *(unsigned char *)(v41 + v73 + v71[0]);
            LOBYTE(v66) = *(unsigned char *)(v41 + v68[0]);
            HIBYTE(v66) = *(unsigned char *)(v41 + v70 + v68[0]);
            LOWORD(v60) = v43;
            WORD1(v60) = v67;
            WORD2(v60) = v35;
            HIWORD(v60) = v66;
            *(void *)int8x16_t v42 = v60;
            v42 += 4;
            ++v41;
          }
          while (a9 != v41);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v32 += a10;
      }
      while (v32 + (unint64_t)a3[14] < v62);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, __n128 _Q0, uint64_t a9, unint64_t a10, unsigned int a11, float *a12, uint64_t a13)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    uint64_t v18 = result;
    uint64_t v19 = *a4;
    _Q0.n128_u64[0] = *(unsigned char *)(*a4 + 24) ? *(void *)v19 : 0x7FF8000000000000;
    int v20 = *(_DWORD *)(v19 + 16);
    if (v20 == 2)
    {
      _Q0.n128_f32[0] = _Q0.n128_f64[0];
    }
    else if (v20 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      _Q0.n128_u32[0] = v71[0];
    }
    else
    {
      _Q0.n128_u32[0] = _Q0.n128_f64[0];
    }
    __n128 v63 = _Q0;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v71, result, a2, a5, (uint64_t)a3);
    uint64_t v26 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v26 : NAN;
    unint64_t v28 = HIDWORD(v13);
    int v29 = *(_DWORD *)(v26 + 16);
    if (v29 == 2)
    {
      float v30 = _D0;
    }
    else if (v29 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v68[0]) = _H0;
      LOWORD(v68[0]) = _H0;
      float v30 = *(float *)v68;
    }
    else
    {
      LODWORD(v30) = _D0;
    }
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v68, v18, a2, a7, (uint64_t)a3);
    uint64_t v34 = a3[13];
    if ((unint64_t)a3[14] + v34 < v28)
    {
      v36.i64[0] = __PAIR64__(LODWORD(v30), v63.n128_u32[0]);
      v36.i64[1] = __PAIR64__(LODWORD(v30), v63.n128_u32[0]);
      int v37 = a3[7] * *(_DWORD *)(a2 + 60);
      __n128 v38 = v63;
      v38.n128_f32[1] = v30;
      do
      {
        __n128 v64 = v38;
        long long v65 = v33;
        int8x16_t v66 = v36;
        int32x4_t v67 = v32;
        int v72 = v37 + v34;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v71);
        int v69 = v37 + v34;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v68);
        if (a10 >= 4)
        {
          uint64_t v45 = 0;
          uint64_t v47 = v70;
          uint64_t v46 = (uint64_t *)v71[0];
          uint64_t v48 = v73;
          unint64_t v49 = a12;
          int16x8_t v50 = (uint64_t *)v68[0];
          __int32 v44 = v63.n128_u32[0];
          int8x16_t v36 = v66;
          __n128 v38 = v64;
          long long v33 = v65;
          do
          {
            v39.i64[0] = *v46;
            v40.i64[0] = *(uint64_t *)((char *)v46 + v48);
            int8x16_t v39 = vzip1q_s8(v39, v40);
            v40.i64[0] = *v50;
            v41.i64[0] = *(uint64_t *)((char *)v50 + v47);
            int8x16_t v40 = vzip1q_s8(v40, v41);
            int32x4_t v51 = vzip1q_s32((int32x4_t)v39, (int32x4_t)v40);
            int32x4_t v32 = vzip2q_s32((int32x4_t)v39, (int32x4_t)v40);
            __int16 v43 = v49 + 16;
            int8x16_t v41 = v66;
            vst2q_f32(v49, *(float32x4x2_t *)v41.i8);
            unint64_t v52 = v49 + 8;
            vst2q_f32(v52, *(float32x4x2_t *)(&v32 - 1));
            unint64_t v42 = v45 + 4;
            unint64_t v53 = v45 + 8;
            ++v50;
            ++v46;
            v45 += 4;
            unint64_t v49 = v43;
          }
          while (v53 <= a10);
        }
        else
        {
          unint64_t v42 = 0;
          __int16 v43 = a12;
          __int32 v44 = v63.n128_u32[0];
          int8x16_t v36 = v66;
          int32x4_t v32 = v67;
          __n128 v38 = v64;
          long long v33 = v65;
        }
        unint64_t v54 = v42 | 1;
        if ((v42 | 1) <= a10)
        {
          do
          {
            unint64_t v55 = (__int8 *)(v71[0] + 2 * v42);
            v39.i8[0] = *v55;
            v39.i8[4] = v55[1];
            unint64_t v56 = &v55[v73];
            __int32 v57 = (__int8 *)(v68[0] + 2 * v42);
            v41.i8[0] = *v57;
            v41.i8[4] = v57[1];
            unint64_t v58 = &v57[v70];
            v39.i8[1] = *v56;
            v39.i8[2] = v39.i8[4];
            v41.i8[1] = *v58;
            v41.i8[2] = v41.i8[4];
            v39.i8[3] = v56[1];
            v41.i8[3] = v58[1];
            *(int32x2_t *)&long long v33 = vzip1_s32(*(int32x2_t *)v39.i8, *(int32x2_t *)v41.i8);
            vst2_f32(v43, *(float32x2x2_t *)((char *)&v33 - 8));
            v43 += 4;
            unint64_t v42 = v54++;
          }
          while (v54 <= a10);
          unint64_t v42 = v54 - 1;
        }
        unint64_t v59 = a10 - v42;
        if (a10 > v42)
        {
          uint64_t v60 = 2 * v42;
          do
          {
            unsigned int v61 = (unsigned __int8 *)(v60 + v73 + v71[0]);
            v39.i32[0] = *(unsigned __int8 *)(v60 + v71[0]);
            v39.i8[4] = *(unsigned char *)(v60 + v71[0] + 1);
            v40.i32[0] = *v61;
            v40.i8[4] = v61[1];
            int8x16_t v39 = (int8x16_t)vtrn1q_s16((int16x8_t)v39, (int16x8_t)v40);
            unint64_t v62 = (unsigned __int8 *)(v60 + v70 + v68[0]);
            v40.i32[0] = *(unsigned __int8 *)(v60 + v68[0]);
            v40.i8[4] = *(unsigned char *)(v60 + v68[0] + 1);
            v41.i32[0] = *v62;
            v41.i8[4] = v62[1];
            int8x16_t v40 = (int8x16_t)vtrn1q_s16((int16x8_t)v40, (int16x8_t)v41);
            v41.i32[0] = v44;
            v41.i32[1] = vmovn_s16((int16x8_t)v39).u32[0];
            *(float *)&v41.i32[2] = v30;
            *(int8x8_t *)v39.i8 = vmovn_s16((int16x8_t)v40);
            v41.i32[3] = v39.i32[0];
            *(int8x16_t *)__int16 v43 = v41;
            v43 += 4;
            v60 += 2;
            --v59;
          }
          while (v59);
        }
        a12 = (float *)((char *)a12 + a13);
        v34 += a11;
      }
      while (v34 + (unint64_t)a3[14] < v28);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)1>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v72, result, a2, a4, (uint64_t)a3);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v69, v18, a2, a5, (uint64_t)a3);
    uint64_t v19 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v19 : NAN;
    unint64_t v62 = HIDWORD(v12);
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      *(float *)&unsigned int v22 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v66[0]) = _H0;
      LOWORD(v66[0]) = _H0;
      unsigned int v22 = v66[0];
    }
    else
    {
      unsigned int v22 = _D0;
    }
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v66, v18, a2, a7, (uint64_t)a3);
    uint64_t v28 = a3[13];
    if ((unint64_t)a3[14] + v28 < v62)
    {
      int v61 = a3[7] * *(_DWORD *)(a2 + 60);
      __int16 v30 = v22;
      int16x8_t v31 = vdupq_n_s16(v22);
      int16x4_t v32 = (int16x4_t)vdup_n_s32(v22);
      int16x8_t v60 = v31;
      do
      {
        uint64_t v33 = v28;
        int v34 = v61 + v28;
        int v73 = v61 + v28;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v72);
        int v70 = v34;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v69);
        int v67 = v34;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v66);
        if (a9 >= 8)
        {
          uint64_t v42 = 0;
          uint64_t v43 = v72[0];
          uint64_t v44 = v69[0];
          uint64_t v45 = v66[0];
          uint64_t v46 = v74 + v72[0];
          uint64_t v47 = v71 + v69[0];
          uint64_t v48 = v68 + v66[0];
          unint64_t v49 = a11;
          uint64_t v41 = v33;
          do
          {
            v35.i64[0] = *(void *)(v43 + v42);
            v36.i64[0] = *(void *)(v46 + v42);
            int8x16_t v35 = vzip1q_s8(v35, v36);
            v36.i64[0] = *(void *)(v44 + v42);
            v37.i64[0] = *(void *)(v47 + v42);
            v38.i64[0] = *(void *)(v45 + v42);
            int8x16_t v36 = vzip1q_s8(v36, v37);
            v37.i64[0] = *(void *)(v48 + v42);
            int8x16_t v37 = vzip1q_s8(v38, v37);
            v75.val[0] = vzip1q_s16((int16x8_t)v35, v60);
            v75.val[1] = vzip1q_s16((int16x8_t)v36, (int16x8_t)v37);
            int8x16_t v40 = v49 + 32;
            vst2q_s16(v49, v75);
            int16x8_t v50 = v49 + 16;
            int8x16_t v38 = (int8x16_t)vzip2q_s16((int16x8_t)v35, v60);
            v75.val[1] = vzip2q_s16((int16x8_t)v36, (int16x8_t)v37);
            vst2q_s16(v50, *(int16x8x2_t *)v38.i8);
            unint64_t v39 = v42 + 8;
            unint64_t result = v42 + 16;
            v42 += 8;
            unint64_t v49 = v40;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v39 = 0;
          int8x16_t v40 = a11;
          uint64_t v41 = v33;
        }
        unint64_t v51 = v39 | 2;
        if ((v39 | 2) <= a9)
        {
          do
          {
            unint64_t v52 = (unsigned __int8 *)(v39 + v72[0] + v74);
            v35.i32[0] = *(unsigned __int8 *)(v39 + v72[0]);
            v35.i8[4] = *(unsigned char *)(v39 + v72[0] + 1);
            v36.i32[0] = *v52;
            v36.i8[4] = v52[1];
            int8x16_t v35 = (int8x16_t)vtrn1q_s16((int16x8_t)v35, (int16x8_t)v36);
            *(int8x8_t *)v35.i8 = vmovn_s16((int16x8_t)v35);
            v35.i16[2] = v35.i16[1];
            unint64_t v53 = (unsigned __int8 *)(v39 + v69[0] + v71);
            v36.i32[0] = *(unsigned __int8 *)(v39 + v69[0]);
            v36.i8[4] = *(unsigned char *)(v39 + v69[0] + 1);
            v37.i32[0] = *v53;
            v37.i8[4] = v53[1];
            int8x16_t v36 = (int8x16_t)vtrn1q_s16((int16x8_t)v36, (int16x8_t)v37);
            *(int8x8_t *)v36.i8 = vmovn_s16((int16x8_t)v36);
            v36.i16[2] = v36.i16[1];
            unint64_t v54 = (unsigned __int8 *)(v39 + v66[0]);
            unint64_t v55 = (__int8 *)(v54 + 1);
            __int32 v56 = *v54;
            __int32 v57 = &v54[v68];
            v37.i32[0] = v56;
            v37.i8[4] = *v55;
            v38.i32[0] = *v57;
            v38.i8[4] = v57[1];
            int8x16_t v37 = (int8x16_t)vtrn1q_s16((int16x8_t)v37, (int16x8_t)v38);
            *(int8x8_t *)v37.i8 = vmovn_s16((int16x8_t)v37);
            v37.i16[2] = v37.i16[1];
            *(int16x4_t *)v38.i8 = vtrn1_s16(*(int16x4_t *)v35.i8, v32);
            int16x4_t v58 = vtrn1_s16(*(int16x4_t *)v36.i8, *(int16x4_t *)v37.i8);
            vst2_s16(v40, (int16x4x2_t)v38);
            v40 += 8;
            unint64_t v39 = v51;
            v51 += 2;
          }
          while (v51 <= a9);
          unint64_t v39 = v51 - 2;
        }
        if (v39 < a9)
        {
          do
          {
            LOBYTE(v65) = *(unsigned char *)(v39 + v72[0]);
            HIBYTE(v65) = *(unsigned char *)(v39 + v74 + v72[0]);
            LOBYTE(v64) = *(unsigned char *)(v39 + v69[0]);
            HIBYTE(v64) = *(unsigned char *)(v39 + v71 + v69[0]);
            LOBYTE(v63) = *(unsigned char *)(v39 + v66[0]);
            HIBYTE(v63) = *(unsigned char *)(v39 + v68 + v66[0]);
            LOWORD(v59) = v65;
            WORD1(v59) = v64;
            WORD2(v59) = v30;
            HIWORD(v59) = v63;
            *(void *)int8x16_t v40 = v59;
            v40 += 4;
            ++v39;
          }
          while (a9 != v39);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        uint64_t v28 = v41 + a10;
      }
      while (v28 + (unint64_t)a3[14] < v62);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)1>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    uint64_t v19 = result;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v72, result, a2, a4, (uint64_t)a3);
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v69, v19, a2, a5, (uint64_t)a3);
    uint64_t v20 = *a6;
    _D0 = *(unsigned char *)(*a6 + 24) ? *(double *)v20 : NAN;
    unint64_t v65 = HIDWORD(v13);
    int v22 = *(_DWORD *)(v20 + 16);
    if (v22 == 2)
    {
      *(float *)v12.i32 = _D0;
    }
    else if (v22 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v66[0]) = _H0;
      LOWORD(v66[0]) = _H0;
      v12.i32[0] = v66[0];
    }
    else
    {
      v12.i32[0] = _D0;
    }
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v66, v19, a2, a7, (uint64_t)a3);
    uint64_t v28 = a3[13];
    if ((unint64_t)a3[14] + v28 < v65)
    {
      int v30 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v64 = vdupq_n_s32(v12.u32[0]);
      do
      {
        int v73 = v30 + v28;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v72);
        int v70 = v30 + v28;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v69);
        int v67 = v30 + v28;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v66);
        if (a9 >= 4)
        {
          uint64_t v38 = 0;
          uint64_t v40 = v71;
          unint64_t v39 = (uint64_t *)v72[0];
          uint64_t v41 = v74;
          uint64_t v43 = v68;
          uint64_t v42 = (uint64_t *)v69[0];
          uint64_t v44 = a11;
          uint64_t v45 = (uint64_t *)v66[0];
          do
          {
            v31.i64[0] = *v39;
            v32.i64[0] = *(uint64_t *)((char *)v39 + v41);
            int8x16_t v31 = vzip1q_s8(v31, v32);
            v32.i64[0] = *v42;
            v33.i64[0] = *(uint64_t *)((char *)v42 + v40);
            int8x16_t v32 = vzip1q_s8(v32, v33);
            v33.i64[0] = *(uint64_t *)((char *)v45 + v43);
            uint64_t v46 = *v45++;
            v34.i64[0] = v46;
            int8x16_t v33 = vzip1q_s8(v34, v33);
            int8x16_t v34 = (int8x16_t)vzip2q_s32((int32x4_t)v31, v64);
            int32x4_t v35 = vzip2q_s32((int32x4_t)v32, (int32x4_t)v33);
            v76.val[0] = (float32x4_t)vzip1q_s32((int32x4_t)v31, v64);
            v76.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v32, (int32x4_t)v33);
            int8x16_t v37 = v44 + 16;
            vst2q_f32(v44, v76);
            uint64_t v47 = v44 + 8;
            vst2q_f32(v47, *(float32x4x2_t *)v34.i8);
            unint64_t v36 = v38 + 4;
            unint64_t result = v38 + 8;
            ++v42;
            ++v39;
            v38 += 4;
            uint64_t v44 = v37;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v36 = 0;
          int8x16_t v37 = a11;
        }
        unint64_t v48 = v36 | 1;
        if ((v36 | 1) <= a9)
        {
          do
          {
            unint64_t v49 = (__int8 *)(v72[0] + 2 * v36);
            int16x8_t v50 = v49 + 1;
            v32.i8[0] = *v49;
            unint64_t v51 = &v49[v74];
            v32.i8[4] = *v50;
            __int8 v52 = *v51;
            __int8 v53 = v51[1];
            unint64_t v54 = (__int8 *)(v69[0] + 2 * v36);
            v33.i8[0] = *v54;
            v33.i8[4] = v54[1];
            unint64_t v55 = &v54[v71];
            v32.i8[1] = v52;
            __int32 v56 = (__int8 *)(v66[0] + 2 * v36);
            v35.i8[0] = *v56;
            v33.i8[1] = *v55;
            v35.i8[4] = v56[1];
            __int32 v57 = &v56[v68];
            v32.i8[2] = *v50;
            v33.i8[2] = v33.i8[4];
            v35.i8[1] = *v57;
            v32.i8[3] = v53;
            v35.i8[2] = v35.i8[4];
            v33.i8[3] = v55[1];
            v35.i8[3] = v57[1];
            v75.val[0] = (float32x2_t)vzip1_s32(*(int32x2_t *)v32.i8, v12);
            v75.val[1] = (float32x2_t)vzip1_s32(*(int32x2_t *)v33.i8, *(int32x2_t *)v35.i8);
            vst2_f32(v37, v75);
            v37 += 4;
            unint64_t v36 = v48++;
          }
          while (v48 <= a9);
          unint64_t v36 = v48 - 1;
        }
        unint64_t v58 = a9 - v36;
        if (a9 > v36)
        {
          uint64_t v59 = 2 * v36;
          do
          {
            int16x8_t v60 = (unsigned __int8 *)(v59 + v74 + v72[0]);
            int v61 = (__int8 *)(v60 + 1);
            v31.i32[0] = *(unsigned __int8 *)(v59 + v72[0]);
            v31.i8[4] = *(unsigned char *)(v59 + v72[0] + 1);
            v32.i32[0] = *v60;
            unint64_t v62 = (unsigned __int8 *)(v59 + v71 + v69[0]);
            v33.i32[0] = *(unsigned __int8 *)(v59 + v69[0]);
            v32.i8[4] = *v61;
            v33.i8[4] = *(unsigned char *)(v59 + v69[0] + 1);
            v34.i32[0] = *v62;
            v34.i8[4] = v62[1];
            v31.i32[0] = vmovn_s16(vtrn1q_s16((int16x8_t)v31, (int16x8_t)v32)).u32[0];
            int8x16_t v32 = (int8x16_t)vtrn1q_s16((int16x8_t)v33, (int16x8_t)v34);
            __int16 v63 = (unsigned __int8 *)(v59 + v68 + v66[0]);
            v33.i32[0] = *(unsigned __int8 *)(v59 + v66[0]);
            v33.i8[4] = *(unsigned char *)(v59 + v66[0] + 1);
            v34.i32[0] = *v63;
            v34.i8[4] = v63[1];
            int8x16_t v33 = (int8x16_t)vtrn1q_s16((int16x8_t)v33, (int16x8_t)v34);
            v31.i32[1] = vmovn_s16((int16x8_t)v32).u32[0];
            v31.i32[2] = v12.i32[0];
            *(int8x8_t *)v32.i8 = vmovn_s16((int16x8_t)v33);
            v31.i32[3] = v32.i32[0];
            *(int8x16_t *)int8x16_t v37 = v31;
            v37 += 4;
            v59 += 2;
            --v58;
          }
          while (v58);
        }
        a11 = (float *)((char *)a11 + a12);
        v28 += a10;
      }
      while (v28 + (unint64_t)a3[14] < v65);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v15 = result;
    uint64_t v16 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v16 : NAN;
    int v18 = *(_DWORD *)(v16 + 16);
    if (v18 == 2)
    {
      float v19 = _D0;
    }
    else if (v18 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v72[0]) = _H0;
      LOWORD(v72[0]) = _H0;
      float v19 = *(float *)v72;
    }
    else
    {
      LODWORD(v19) = _D0;
    }
    uint64_t v25 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v25 : NAN;
    unint64_t v65 = HIDWORD(v12);
    int v27 = *(_DWORD *)(v25 + 16);
    unsigned int v63 = LODWORD(v19);
    if (v27 == 2)
    {
      *(float *)&unsigned int v28 = _D0;
    }
    else if (v27 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v72[0]) = _H0;
      LOWORD(v72[0]) = _H0;
      unsigned int v28 = v72[0];
    }
    else
    {
      unsigned int v28 = _D0;
    }
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v72, result, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v69, v15, a2, a7, (uint64_t)a3);
    uint64_t v30 = a3[13];
    if ((unint64_t)a3[14] + v30 < v65)
    {
      LOWORD(v32) = v63;
      int16x8_t v33 = vdupq_n_s16(v63);
      unsigned int v34 = v28;
      int16x8_t v35 = vdupq_n_s16(v28);
      int16x4_t v36 = (int16x4_t)vdup_n_s32(v63);
      int16x4_t v37 = (int16x4_t)vdup_n_s32(v34);
      HIWORD(v32) = v34;
      int v64 = v32;
      int v38 = a3[7] * *(_DWORD *)(a2 + 60);
      int16x8_t v61 = v35;
      int16x8_t v62 = v33;
      do
      {
        int v73 = v38 + v30;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v72);
        int v70 = v38 + v30;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v69);
        if (a9 >= 8)
        {
          uint64_t v45 = 0;
          uint64_t v46 = v72[0];
          uint64_t v47 = v69[0];
          uint64_t v48 = v74 + v72[0];
          uint64_t v49 = v71 + v69[0];
          int16x8_t v50 = a11;
          int v44 = v64;
          do
          {
            v39.i64[0] = *(void *)(v46 + v45);
            v40.i64[0] = *(void *)(v48 + v45);
            v41.i64[0] = *(void *)(v47 + v45);
            int8x16_t v39 = vzip1q_s8(v39, v40);
            v40.i64[0] = *(void *)(v49 + v45);
            int8x16_t v40 = vzip1q_s8(v41, v40);
            v75.val[0] = vzip1q_s16(v62, (int16x8_t)v39);
            v75.val[1] = vzip1q_s16(v61, (int16x8_t)v40);
            uint64_t v43 = v50 + 32;
            vst2q_s16(v50, v75);
            unint64_t v51 = v50 + 16;
            int8x16_t v41 = (int8x16_t)vzip2q_s16(v62, (int16x8_t)v39);
            v75.val[1] = vzip2q_s16(v61, (int16x8_t)v40);
            vst2q_s16(v51, *(int16x8x2_t *)v41.i8);
            unint64_t v42 = v45 + 8;
            unint64_t v52 = v45 + 16;
            v45 += 8;
            int16x8_t v50 = v43;
          }
          while (v52 <= a9);
        }
        else
        {
          unint64_t v42 = 0;
          uint64_t v43 = a11;
          int v44 = v64;
        }
        unint64_t v53 = v42 | 2;
        if ((v42 | 2) <= a9)
        {
          do
          {
            unint64_t v54 = (unsigned __int8 *)(v42 + v72[0] + v74);
            v39.i32[0] = *(unsigned __int8 *)(v42 + v72[0]);
            v39.i8[4] = *(unsigned char *)(v42 + v72[0] + 1);
            v40.i32[0] = *v54;
            v40.i8[4] = v54[1];
            int8x16_t v39 = (int8x16_t)vtrn1q_s16((int16x8_t)v39, (int16x8_t)v40);
            *(int8x8_t *)v39.i8 = vmovn_s16((int16x8_t)v39);
            v39.i16[2] = v39.i16[1];
            unint64_t v55 = (unsigned __int8 *)(v42 + v69[0]);
            __int32 v56 = (__int8 *)(v55 + 1);
            __int32 v57 = *v55;
            unint64_t v58 = &v55[v71];
            v40.i32[0] = v57;
            v40.i8[4] = *v56;
            v41.i32[0] = *v58;
            v41.i8[4] = v58[1];
            int8x16_t v40 = (int8x16_t)vtrn1q_s16((int16x8_t)v40, (int16x8_t)v41);
            *(int8x8_t *)v40.i8 = vmovn_s16((int16x8_t)v40);
            v40.i16[2] = v40.i16[1];
            *(int16x4_t *)v41.i8 = vtrn1_s16(v36, *(int16x4_t *)v39.i8);
            int16x4_t v59 = vtrn1_s16(v37, *(int16x4_t *)v40.i8);
            vst2_s16(v43, (int16x4x2_t)v41);
            v43 += 8;
            unint64_t v42 = v53;
            v53 += 2;
          }
          while (v53 <= a9);
          unint64_t v42 = v53 - 2;
        }
        if (v42 < a9)
        {
          do
          {
            LOBYTE(v68) = *(unsigned char *)(v42 + v72[0]);
            HIBYTE(v68) = *(unsigned char *)(v42 + v74 + v72[0]);
            LOBYTE(v67) = *(unsigned char *)(v42 + v69[0]);
            HIBYTE(v67) = *(unsigned char *)(v42 + v71 + v69[0]);
            LODWORD(v60) = v44;
            WORD2(v60) = v68;
            HIWORD(v60) = v67;
            *(void *)uint64_t v43 = v60;
            v43 += 4;
            ++v42;
          }
          while (a9 != v42);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        v30 += a10;
      }
      while (v30 + (unint64_t)a3[14] < v65);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, double a8, double a9, uint64_t a10, unint64_t a11, unsigned int a12, float *a13, uint64_t a14)
{
  unint64_t v14 = *(void *)(a2 + 56);
  if (v14)
  {
    uint64_t v18 = result;
    uint64_t v19 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v19 : NAN;
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      *(float *)&a9 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v69[0]) = _H0;
      LOWORD(v69[0]) = _H0;
      LODWORD(a9) = v69[0];
    }
    else
    {
      LODWORD(a9) = _D0;
    }
    uint64_t v27 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v27 : NAN;
    unint64_t v29 = HIDWORD(v14);
    int v30 = *(_DWORD *)(v27 + 16);
    double v65 = a9;
    if (v30 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v30 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v69[0]) = _H0;
      LOWORD(v69[0]) = _H0;
      LODWORD(_D0) = v69[0];
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    int32x2_t v64 = *(int32x2_t *)&_D0;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v69, result, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v66, v18, a2, a7, (uint64_t)a3);
    uint64_t v32 = a3[13];
    if ((unint64_t)a3[14] + v32 < v29)
    {
      int v34 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v62 = vdupq_n_s32(v64.u32[0]);
      int32x4_t v63 = vdupq_n_s32(LODWORD(v65));
      do
      {
        int v70 = v34 + v32;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v69);
        int v67 = v34 + v32;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v66);
        if (a11 >= 4)
        {
          uint64_t v44 = 0;
          uint64_t v45 = (uint64_t *)v69[0];
          uint64_t v46 = v71;
          uint64_t v47 = a13;
          uint64_t v48 = (uint64_t *)v66[0];
          uint64_t v49 = v68;
          int32x2_t v42 = v64;
          int32x2_t v41 = *(int32x2_t *)&v65;
          unint64_t v43 = __PAIR64__(v64.u32[0], LODWORD(v65));
          do
          {
            v35.i64[0] = *v45;
            v36.i64[0] = *(uint64_t *)((char *)v45 + v46);
            int8x16_t v35 = vzip1q_s8(v35, v36);
            v36.i64[0] = *v48;
            v37.i64[0] = *(uint64_t *)((char *)v48 + v49);
            int8x16_t v36 = vzip1q_s8(v36, v37);
            int8x16_t v37 = (int8x16_t)vzip2q_s32(v63, (int32x4_t)v35);
            v72.val[0] = (float32x4_t)vzip1q_s32(v63, (int32x4_t)v35);
            v72.val[1] = (float32x4_t)vzip1q_s32(v62, (int32x4_t)v36);
            int8x16_t v40 = v47 + 16;
            vst2q_f32(v47, v72);
            int16x8_t v50 = v47 + 8;
            int16x8_t v38 = (int16x8_t)vzip2q_s32(v62, (int32x4_t)v36);
            vst2q_f32(v50, *(float32x4x2_t *)v37.i8);
            unint64_t v39 = v44 + 4;
            unint64_t v51 = v44 + 8;
            ++v48;
            ++v45;
            v44 += 4;
            uint64_t v47 = v40;
          }
          while (v51 <= a11);
        }
        else
        {
          unint64_t v39 = 0;
          int8x16_t v40 = a13;
          int32x2_t v42 = v64;
          int32x2_t v41 = *(int32x2_t *)&v65;
          unint64_t v43 = __PAIR64__(v64.u32[0], LODWORD(v65));
        }
        unint64_t v52 = v39 | 1;
        if ((v39 | 1) <= a11)
        {
          do
          {
            unint64_t v53 = (__int8 *)(v69[0] + 2 * v39);
            unint64_t v54 = v53 + 1;
            v35.i8[0] = *v53;
            unint64_t v55 = &v53[v71];
            v35.i8[4] = *v54;
            __int32 v56 = (__int8 *)(v66[0] + 2 * v39);
            v37.i8[0] = *v56;
            v37.i8[4] = v56[1];
            __int32 v57 = &v56[v68];
            v35.i8[1] = *v55;
            v37.i8[1] = *v57;
            v35.i8[2] = *v54;
            v37.i8[2] = v37.i8[4];
            v35.i8[3] = v55[1];
            v37.i8[3] = v57[1];
            *(int32x2_t *)v35.i8 = vzip1_s32(v41, *(int32x2_t *)v35.i8);
            *(int32x2_t *)v36.i8 = vzip1_s32(v42, *(int32x2_t *)v37.i8);
            vst2_f32(v40, (float32x2x2_t)v35);
            v40 += 4;
            unint64_t v39 = v52++;
          }
          while (v52 <= a11);
          unint64_t v39 = v52 - 1;
        }
        unint64_t v58 = a11 - v39;
        if (a11 > v39)
        {
          uint64_t v59 = 2 * v39;
          do
          {
            uint64_t v60 = (unsigned __int8 *)(v59 + v71 + v69[0]);
            v35.i32[0] = *(unsigned __int8 *)(v59 + v69[0]);
            v35.i8[4] = *(unsigned char *)(v59 + v69[0] + 1);
            v36.i32[0] = *v60;
            v36.i8[4] = v60[1];
            int16x8_t v61 = (unsigned __int8 *)(v59 + v68 + v66[0]);
            v37.i32[0] = *(unsigned __int8 *)(v59 + v66[0]);
            v37.i8[4] = *(unsigned char *)(v59 + v66[0] + 1);
            v38.i32[0] = *v61;
            v38.i8[4] = v61[1];
            int8x16_t v35 = (int8x16_t)vtrn1q_s16((int16x8_t)v35, (int16x8_t)v36);
            int8x16_t v36 = (int8x16_t)vtrn1q_s16((int16x8_t)v37, v38);
            v37.i64[0] = v43;
            v37.i32[2] = vmovn_s16((int16x8_t)v35).u32[0];
            *(int8x8_t *)v35.i8 = vmovn_s16((int16x8_t)v36);
            v37.i32[3] = v35.i32[0];
            *(int8x16_t *)int8x16_t v40 = v37;
            v40 += 4;
            v59 += 2;
            --v58;
          }
          while (v58);
        }
        a13 = (float *)((char *)a13 + a14);
        v32 += a12;
      }
      while (v32 + (unint64_t)a3[14] < v29);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v74, result, a2, a4, (uint64_t)a3);
    uint64_t v19 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v19 : NAN;
    unint64_t v64 = HIDWORD(v12);
    int v21 = *(_DWORD *)(v19 + 16);
    if (v21 == 2)
    {
      *(float *)&unsigned int v22 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      unsigned int v22 = v71[0];
    }
    else
    {
      unsigned int v22 = _D0;
    }
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v71, v18, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v68, v18, a2, a7, (uint64_t)a3);
    uint64_t v28 = a3[13];
    if ((unint64_t)a3[14] + v28 < v64)
    {
      int v63 = a3[7] * *(_DWORD *)(a2 + 60);
      __int16 v30 = v22;
      int16x8_t v31 = vdupq_n_s16(v22);
      int16x4_t v32 = (int16x4_t)vdup_n_s32(v22);
      int16x8_t v62 = v31;
      do
      {
        uint64_t v33 = v28;
        int v34 = v63 + v28;
        int v75 = v63 + v28;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v74);
        int v72 = v34;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v71);
        int v69 = v34;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v68);
        if (a9 >= 8)
        {
          uint64_t v42 = 0;
          uint64_t v43 = v74[0];
          uint64_t v44 = v71[0];
          uint64_t v45 = v68[0];
          uint64_t v46 = v76 + v74[0];
          uint64_t v47 = v73 + v71[0];
          uint64_t v48 = v70 + v68[0];
          uint64_t v49 = a11;
          uint64_t v41 = v33;
          do
          {
            v35.i64[0] = *(void *)(v43 + v42);
            v36.i64[0] = *(void *)(v46 + v42);
            int16x8_t v50 = (int16x8_t)vzip1q_s8(v35, v36);
            v36.i64[0] = *(void *)(v44 + v42);
            v37.i64[0] = *(void *)(v47 + v42);
            v38.i64[0] = *(void *)(v45 + v42);
            int16x8_t v51 = (int16x8_t)vzip1q_s8(v36, v37);
            v37.i64[0] = *(void *)(v48 + v42);
            int8x16_t v37 = vzip1q_s8(v38, v37);
            int8x16_t v38 = (int8x16_t)vzip1q_s16(v50, v51);
            int16x8_t v52 = vzip1q_s16(v62, (int16x8_t)v37);
            int8x16_t v40 = v49 + 32;
            vst2q_s16(v49, *(int16x8x2_t *)v38.i8);
            unint64_t v53 = v49 + 16;
            int8x16_t v35 = (int8x16_t)vzip2q_s16(v50, v51);
            int8x16_t v36 = (int8x16_t)vzip2q_s16(v62, (int16x8_t)v37);
            vst2q_s16(v53, *(int16x8x2_t *)v35.i8);
            unint64_t v39 = v42 + 8;
            unint64_t result = v42 + 16;
            v42 += 8;
            uint64_t v49 = v40;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v39 = 0;
          int8x16_t v40 = a11;
          uint64_t v41 = v33;
        }
        unint64_t v54 = v39 | 2;
        if ((v39 | 2) <= a9)
        {
          do
          {
            unint64_t v55 = (unsigned __int8 *)(v39 + v74[0] + v76);
            v35.i32[0] = *(unsigned __int8 *)(v39 + v74[0]);
            v35.i8[4] = *(unsigned char *)(v39 + v74[0] + 1);
            v36.i32[0] = *v55;
            v36.i8[4] = v55[1];
            int8x16_t v35 = (int8x16_t)vtrn1q_s16((int16x8_t)v35, (int16x8_t)v36);
            *(int8x8_t *)v35.i8 = vmovn_s16((int16x8_t)v35);
            v35.i16[2] = v35.i16[1];
            __int32 v56 = (unsigned __int8 *)(v39 + v71[0] + v73);
            v36.i32[0] = *(unsigned __int8 *)(v39 + v71[0]);
            v36.i8[4] = *(unsigned char *)(v39 + v71[0] + 1);
            v37.i32[0] = *v56;
            v37.i8[4] = v56[1];
            int8x16_t v36 = (int8x16_t)vtrn1q_s16((int16x8_t)v36, (int16x8_t)v37);
            *(int8x8_t *)v36.i8 = vmovn_s16((int16x8_t)v36);
            v36.i16[2] = v36.i16[1];
            __int32 v57 = (unsigned __int8 *)(v39 + v68[0]);
            unint64_t v58 = (__int8 *)(v57 + 1);
            __int32 v59 = *v57;
            uint64_t v60 = &v57[v70];
            v37.i32[0] = v59;
            v37.i8[4] = *v58;
            v38.i32[0] = *v60;
            v38.i8[4] = v60[1];
            int8x16_t v37 = (int8x16_t)vtrn1q_s16((int16x8_t)v37, (int16x8_t)v38);
            *(int8x8_t *)v37.i8 = vmovn_s16((int16x8_t)v37);
            v37.i16[2] = v37.i16[1];
            *(int16x4_t *)v35.i8 = vtrn1_s16(*(int16x4_t *)v35.i8, *(int16x4_t *)v36.i8);
            *(int16x4_t *)v36.i8 = vtrn1_s16(v32, *(int16x4_t *)v37.i8);
            vst2_s16(v40, (int16x4x2_t)v35);
            v40 += 8;
            unint64_t v39 = v54;
            v54 += 2;
          }
          while (v54 <= a9);
          unint64_t v39 = v54 - 2;
        }
        if (v39 < a9)
        {
          do
          {
            LOBYTE(v67) = *(unsigned char *)(v39 + v74[0]);
            HIBYTE(v67) = *(unsigned char *)(v39 + v76 + v74[0]);
            LOBYTE(v66) = *(unsigned char *)(v39 + v71[0]);
            HIBYTE(v66) = *(unsigned char *)(v39 + v73 + v71[0]);
            LOBYTE(v65) = *(unsigned char *)(v39 + v68[0]);
            HIBYTE(v65) = *(unsigned char *)(v39 + v70 + v68[0]);
            LOWORD(v61) = v67;
            WORD1(v61) = v30;
            WORD2(v61) = v66;
            HIWORD(v61) = v65;
            *(void *)int8x16_t v40 = v61;
            v40 += 4;
            ++v39;
          }
          while (a9 != v39);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        uint64_t v28 = v41 + a10;
      }
      while (v28 + (unint64_t)a3[14] < v64);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v13 = *(void *)(a2 + 56);
  if (v13)
  {
    uint64_t v19 = result;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v73, result, a2, a4, (uint64_t)a3);
    uint64_t v20 = *a5;
    _D0 = *(unsigned char *)(*a5 + 24) ? *(double *)v20 : NAN;
    unint64_t v66 = HIDWORD(v13);
    int v22 = *(_DWORD *)(v20 + 16);
    if (v22 == 2)
    {
      *(float *)v12.i32 = _D0;
    }
    else if (v22 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v70[0]) = _H0;
      LOWORD(v70[0]) = _H0;
      v12.i32[0] = v70[0];
    }
    else
    {
      v12.i32[0] = _D0;
    }
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v70, v19, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v67, v19, a2, a7, (uint64_t)a3);
    uint64_t v28 = a3[13];
    if ((unint64_t)a3[14] + v28 < v66)
    {
      int v30 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v65 = vdupq_n_s32(v12.u32[0]);
      do
      {
        int v74 = v30 + v28;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v73);
        int v71 = v30 + v28;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v70);
        int v68 = v30 + v28;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v67);
        if (a9 >= 4)
        {
          uint64_t v38 = 0;
          uint64_t v40 = v72;
          unint64_t v39 = (uint64_t *)v73[0];
          uint64_t v41 = v75;
          uint64_t v43 = v69;
          uint64_t v42 = (uint64_t *)v70[0];
          uint64_t v44 = a11;
          uint64_t v45 = (uint64_t *)v67[0];
          do
          {
            v31.i64[0] = *v39;
            v32.i64[0] = *(uint64_t *)((char *)v39 + v41);
            int32x4_t v46 = (int32x4_t)vzip1q_s8(v31, v32);
            v32.i64[0] = *v42;
            v33.i64[0] = *(uint64_t *)((char *)v42 + v40);
            int32x4_t v47 = (int32x4_t)vzip1q_s8(v32, v33);
            v33.i64[0] = *(uint64_t *)((char *)v45 + v43);
            uint64_t v48 = *v45++;
            v34.i64[0] = v48;
            int8x16_t v33 = vzip1q_s8(v34, v33);
            int8x16_t v34 = (int8x16_t)vzip2q_s32(v46, v47);
            int32x4_t v35 = vzip2q_s32(v65, (int32x4_t)v33);
            int8x16_t v31 = (int8x16_t)vzip1q_s32(v46, v47);
            int8x16_t v32 = (int8x16_t)vzip1q_s32(v65, (int32x4_t)v33);
            int8x16_t v37 = v44 + 16;
            vst2q_f32(v44, *(float32x4x2_t *)v31.i8);
            uint64_t v49 = v44 + 8;
            vst2q_f32(v49, *(float32x4x2_t *)v34.i8);
            unint64_t v36 = v38 + 4;
            unint64_t result = v38 + 8;
            ++v42;
            ++v39;
            v38 += 4;
            uint64_t v44 = v37;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v36 = 0;
          int8x16_t v37 = a11;
        }
        unint64_t v50 = v36 | 1;
        if ((v36 | 1) <= a9)
        {
          do
          {
            int16x8_t v51 = (__int8 *)(v73[0] + 2 * v36);
            int16x8_t v52 = v51 + 1;
            v32.i8[0] = *v51;
            unint64_t v53 = &v51[v75];
            v32.i8[4] = *v52;
            __int8 v54 = *v53;
            __int8 v55 = v53[1];
            __int32 v56 = (__int8 *)(v70[0] + 2 * v36);
            v33.i8[0] = *v56;
            v33.i8[4] = v56[1];
            __int32 v57 = &v56[v72];
            v32.i8[1] = v54;
            unint64_t v58 = (__int8 *)(v67[0] + 2 * v36);
            v35.i8[0] = *v58;
            v33.i8[1] = *v57;
            v35.i8[4] = v58[1];
            __int32 v59 = &v58[v69];
            v32.i8[2] = *v52;
            v33.i8[2] = v33.i8[4];
            v35.i8[1] = *v59;
            v32.i8[3] = v55;
            v35.i8[2] = v35.i8[4];
            v33.i8[3] = v57[1];
            v35.i8[3] = v59[1];
            *(int32x2_t *)v32.i8 = vzip1_s32(*(int32x2_t *)v32.i8, *(int32x2_t *)v33.i8);
            *(int32x2_t *)v33.i8 = vzip1_s32(v12, *(int32x2_t *)v35.i8);
            vst2_f32(v37, (float32x2x2_t)v32);
            v37 += 4;
            unint64_t v36 = v50++;
          }
          while (v50 <= a9);
          unint64_t v36 = v50 - 1;
        }
        unint64_t v60 = a9 - v36;
        if (a9 > v36)
        {
          uint64_t v61 = 2 * v36;
          do
          {
            int16x8_t v62 = (unsigned __int8 *)(v61 + v75 + v73[0]);
            v31.i32[0] = *(unsigned __int8 *)(v61 + v73[0]);
            v31.i8[4] = *(unsigned char *)(v61 + v73[0] + 1);
            v32.i32[0] = *v62;
            v32.i8[4] = v62[1];
            int v63 = (unsigned __int8 *)(v61 + v72 + v70[0]);
            v33.i32[0] = *(unsigned __int8 *)(v61 + v70[0]);
            v33.i8[4] = *(unsigned char *)(v61 + v70[0] + 1);
            v34.i32[0] = *v63;
            v34.i8[4] = v63[1];
            v31.i32[0] = vmovn_s16(vtrn1q_s16((int16x8_t)v31, (int16x8_t)v32)).u32[0];
            unint64_t v64 = (unsigned __int8 *)(v61 + v69 + v67[0]);
            v32.i32[0] = *(unsigned __int8 *)(v61 + v67[0]);
            int8x16_t v33 = (int8x16_t)vtrn1q_s16((int16x8_t)v33, (int16x8_t)v34);
            v32.i8[4] = *(unsigned char *)(v61 + v67[0] + 1);
            v34.i32[0] = *v64;
            v34.i8[4] = v64[1];
            *(int8x8_t *)v33.i8 = vmovn_s16((int16x8_t)v33);
            int8x16_t v32 = (int8x16_t)vtrn1q_s16((int16x8_t)v32, (int16x8_t)v34);
            v31.i32[1] = v12.i32[0];
            v31.i32[2] = v33.i32[0];
            *(int8x8_t *)v32.i8 = vmovn_s16((int16x8_t)v32);
            v31.i32[3] = v32.i32[0];
            *(int8x16_t *)int8x16_t v37 = v31;
            v37 += 4;
            v61 += 2;
            --v60;
          }
          while (v60);
        }
        a11 = (float *)((char *)a11 + a12);
        v28 += a10;
      }
      while (v28 + (unint64_t)a3[14] < v66);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned short,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v16 = result;
    uint64_t v17 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v17 : NAN;
    unint64_t v60 = HIDWORD(v12);
    int v19 = *(_DWORD *)(v17 + 16);
    if (v19 == 2)
    {
      float v20 = _D0;
    }
    else if (v19 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      float v20 = *(float *)v71;
    }
    else
    {
      LODWORD(v20) = _D0;
    }
    unsigned int v59 = LODWORD(v20);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v71, result, a2, a5, (uint64_t)a3);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v68, v16, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v65, v16, a2, a7, (uint64_t)a3);
    uint64_t v26 = a3[13];
    if ((unint64_t)a3[14] + v26 < v60)
    {
      int v58 = a3[7] * *(_DWORD *)(a2 + 60);
      int16x4_t v28 = (int16x4_t)vdup_n_s32(v59);
      int16x8_t v57 = vdupq_n_s16(v59);
      do
      {
        uint64_t v29 = v26;
        int v30 = v58 + v26;
        int v72 = v58 + v26;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v71);
        int v69 = v30;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v68);
        int v66 = v30;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v65);
        if (a9 >= 8)
        {
          uint64_t v39 = 0;
          uint64_t v40 = v71[0];
          uint64_t v41 = v68[0];
          uint64_t v42 = v65[0];
          uint64_t v43 = v73 + v71[0];
          uint64_t v44 = v70 + v68[0];
          uint64_t v45 = v67 + v65[0];
          int32x4_t v46 = a11;
          __int16 v37 = v59;
          uint64_t v38 = v29;
          do
          {
            v31.i64[0] = *(void *)(v40 + v39);
            v32.i64[0] = *(void *)(v43 + v39);
            int8x16_t v31 = vzip1q_s8(v31, v32);
            v32.i64[0] = *(void *)(v41 + v39);
            v33.i64[0] = *(void *)(v44 + v39);
            v34.i64[0] = *(void *)(v42 + v39);
            int8x16_t v32 = vzip1q_s8(v32, v33);
            v33.i64[0] = *(void *)(v45 + v39);
            int8x16_t v33 = vzip1q_s8(v34, v33);
            v74.val[0] = vzip1q_s16(v57, (int16x8_t)v32);
            v74.val[1] = vzip1q_s16((int16x8_t)v31, (int16x8_t)v33);
            unint64_t v36 = v46 + 32;
            vst2q_s16(v46, v74);
            int32x4_t v47 = v46 + 16;
            int8x16_t v34 = (int8x16_t)vzip2q_s16(v57, (int16x8_t)v32);
            v74.val[1] = vzip2q_s16((int16x8_t)v31, (int16x8_t)v33);
            vst2q_s16(v47, *(int16x8x2_t *)v34.i8);
            unint64_t v35 = v39 + 8;
            unint64_t result = v39 + 16;
            v39 += 8;
            int32x4_t v46 = v36;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v35 = 0;
          unint64_t v36 = a11;
          __int16 v37 = v59;
          uint64_t v38 = v29;
        }
        unint64_t v48 = v35 | 2;
        if ((v35 | 2) <= a9)
        {
          do
          {
            uint64_t v49 = (unsigned __int8 *)(v35 + v71[0] + v73);
            v31.i32[0] = *(unsigned __int8 *)(v35 + v71[0]);
            v31.i8[4] = *(unsigned char *)(v35 + v71[0] + 1);
            v32.i32[0] = *v49;
            v32.i8[4] = v49[1];
            int8x16_t v31 = (int8x16_t)vtrn1q_s16((int16x8_t)v31, (int16x8_t)v32);
            *(int8x8_t *)v31.i8 = vmovn_s16((int16x8_t)v31);
            v31.i16[2] = v31.i16[1];
            unint64_t v50 = (unsigned __int8 *)(v35 + v68[0] + v70);
            v32.i32[0] = *(unsigned __int8 *)(v35 + v68[0]);
            v32.i8[4] = *(unsigned char *)(v35 + v68[0] + 1);
            v33.i32[0] = *v50;
            v33.i8[4] = v50[1];
            int8x16_t v32 = (int8x16_t)vtrn1q_s16((int16x8_t)v32, (int16x8_t)v33);
            *(int8x8_t *)v32.i8 = vmovn_s16((int16x8_t)v32);
            v32.i16[2] = v32.i16[1];
            int16x8_t v51 = (unsigned __int8 *)(v35 + v65[0]);
            int16x8_t v52 = (__int8 *)(v51 + 1);
            __int32 v53 = *v51;
            __int8 v54 = &v51[v67];
            v33.i32[0] = v53;
            v33.i8[4] = *v52;
            v34.i32[0] = *v54;
            v34.i8[4] = v54[1];
            int8x16_t v33 = (int8x16_t)vtrn1q_s16((int16x8_t)v33, (int16x8_t)v34);
            *(int8x8_t *)v33.i8 = vmovn_s16((int16x8_t)v33);
            v33.i16[2] = v33.i16[1];
            *(int16x4_t *)v34.i8 = vtrn1_s16(v28, *(int16x4_t *)v32.i8);
            int16x4_t v55 = vtrn1_s16(*(int16x4_t *)v31.i8, *(int16x4_t *)v33.i8);
            vst2_s16(v36, (int16x4x2_t)v34);
            v36 += 8;
            unint64_t v35 = v48;
            v48 += 2;
          }
          while (v48 <= a9);
          unint64_t v35 = v48 - 2;
        }
        if (v35 < a9)
        {
          do
          {
            LOBYTE(v64) = *(unsigned char *)(v35 + v71[0]);
            HIBYTE(v64) = *(unsigned char *)(v35 + v73 + v71[0]);
            LOBYTE(v63) = *(unsigned char *)(v35 + v68[0]);
            HIBYTE(v63) = *(unsigned char *)(v35 + v70 + v68[0]);
            LOBYTE(v62) = *(unsigned char *)(v35 + v65[0]);
            HIBYTE(v62) = *(unsigned char *)(v35 + v67 + v65[0]);
            LOWORD(v56) = v37;
            WORD1(v56) = v64;
            WORD2(v56) = v63;
            HIWORD(v56) = v62;
            *(void *)unint64_t v36 = v56;
            v36 += 4;
            ++v35;
          }
          while (a9 != v35);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        uint64_t v26 = v38 + a10;
      }
      while (v26 + (unint64_t)a3[14] < v60);
    }
  }
  return result;
}

unint64_t CompressedInterleave4<unsigned int,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(unint64_t result, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v17 = result;
    uint64_t v18 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v18 : NAN;
    unint64_t v20 = HIDWORD(v12);
    int v21 = *(_DWORD *)(v18 + 16);
    if (v21 == 2)
    {
      *(float *)&_D0 = _D0;
    }
    else if (v21 == 1)
    {
      __asm { FCVT            H0, D0 }
      WORD1(v71[0]) = _H0;
      LOWORD(v71[0]) = _H0;
      LODWORD(_D0) = v71[0];
    }
    else
    {
      LODWORD(_D0) = _D0;
    }
    int32x2_t v64 = *(int32x2_t *)&_D0;
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v71, result, a2, a5, (uint64_t)a3);
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v68, v17, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v65, v17, a2, a7, (uint64_t)a3);
    uint64_t v27 = a3[13];
    if ((unint64_t)a3[14] + v27 < v20)
    {
      int v29 = a3[7] * *(_DWORD *)(a2 + 60);
      int32x4_t v63 = vdupq_n_s32(v64.u32[0]);
      do
      {
        int v72 = v29 + v27;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v71);
        int v69 = v29 + v27;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v68);
        int v66 = v29 + v27;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v65);
        if (a9 >= 4)
        {
          uint64_t v38 = 0;
          uint64_t v39 = (uint64_t *)v71[0];
          uint64_t v40 = v73;
          uint64_t v42 = v67;
          uint64_t v41 = (uint64_t *)v68[0];
          uint64_t v43 = v70;
          uint64_t v44 = a11;
          uint64_t v45 = (uint64_t *)v65[0];
          int32x2_t v37 = v64;
          do
          {
            v30.i64[0] = *v39;
            v31.i64[0] = *(uint64_t *)((char *)v39 + v40);
            int8x16_t v30 = vzip1q_s8(v30, v31);
            v31.i64[0] = *v41;
            v32.i64[0] = *(uint64_t *)((char *)v41 + v43);
            int8x16_t v31 = vzip1q_s8(v31, v32);
            v32.i64[0] = *(uint64_t *)((char *)v45 + v42);
            uint64_t v46 = *v45++;
            v33.i64[0] = v46;
            int8x16_t v32 = vzip1q_s8(v33, v32);
            int8x16_t v33 = (int8x16_t)vzip2q_s32(v63, (int32x4_t)v31);
            int32x4_t v34 = vzip2q_s32((int32x4_t)v30, (int32x4_t)v32);
            v74.val[0] = (float32x4_t)vzip1q_s32(v63, (int32x4_t)v31);
            v74.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v30, (int32x4_t)v32);
            unint64_t v36 = v44 + 16;
            vst2q_f32(v44, v74);
            int32x4_t v47 = v44 + 8;
            vst2q_f32(v47, *(float32x4x2_t *)v33.i8);
            unint64_t v35 = v38 + 4;
            unint64_t result = v38 + 8;
            ++v41;
            ++v39;
            v38 += 4;
            uint64_t v44 = v36;
          }
          while (result <= a9);
        }
        else
        {
          unint64_t v35 = 0;
          unint64_t v36 = a11;
          int32x2_t v37 = v64;
        }
        unint64_t v48 = v35 | 1;
        if ((v35 | 1) <= a9)
        {
          do
          {
            uint64_t v49 = (__int8 *)(v71[0] + 2 * v35);
            unint64_t v50 = v49 + 1;
            v31.i8[0] = *v49;
            int16x8_t v51 = &v49[v73];
            v31.i8[4] = *v50;
            __int8 v52 = *v51;
            __int8 v53 = v51[1];
            __int8 v54 = (__int8 *)(v68[0] + 2 * v35);
            v32.i8[0] = *v54;
            v32.i8[4] = v54[1];
            int16x4_t v55 = &v54[v70];
            v31.i8[1] = v52;
            uint64_t v56 = (__int8 *)(v65[0] + 2 * v35);
            v34.i8[0] = *v56;
            v32.i8[1] = *v55;
            v34.i8[4] = v56[1];
            int16x8_t v57 = &v56[v67];
            v31.i8[2] = *v50;
            v32.i8[2] = v32.i8[4];
            v34.i8[1] = *v57;
            v31.i8[3] = v53;
            v34.i8[2] = v34.i8[4];
            v32.i8[3] = v55[1];
            v34.i8[3] = v57[1];
            *(int32x2_t *)v32.i8 = vzip1_s32(v37, *(int32x2_t *)v32.i8);
            *(int32x2_t *)v33.i8 = vzip1_s32(*(int32x2_t *)v31.i8, *(int32x2_t *)v34.i8);
            vst2_f32(v36, (float32x2x2_t)v32);
            v36 += 4;
            unint64_t v35 = v48++;
          }
          while (v48 <= a9);
          unint64_t v35 = v48 - 1;
        }
        unint64_t v58 = a9 - v35;
        if (a9 > v35)
        {
          uint64_t v59 = 2 * v35;
          do
          {
            unint64_t v60 = (unsigned __int8 *)(v59 + v73 + v71[0]);
            v30.i32[0] = *(unsigned __int8 *)(v59 + v71[0]);
            v30.i8[4] = *(unsigned char *)(v59 + v71[0] + 1);
            v31.i32[0] = *v60;
            v31.i8[4] = v60[1];
            uint64_t v61 = (unsigned __int8 *)(v59 + v70 + v68[0]);
            v32.i32[0] = *(unsigned __int8 *)(v59 + v68[0]);
            v32.i8[4] = *(unsigned char *)(v59 + v68[0] + 1);
            v33.i32[0] = *v61;
            v33.i8[4] = v61[1];
            int8x16_t v30 = (int8x16_t)vtrn1q_s16((int16x8_t)v30, (int16x8_t)v31);
            __int16 v62 = (unsigned __int8 *)(v59 + v67 + v65[0]);
            v31.i32[0] = *(unsigned __int8 *)(v59 + v65[0]);
            v31.i8[4] = *(unsigned char *)(v59 + v65[0] + 1);
            int8x16_t v32 = (int8x16_t)vtrn1q_s16((int16x8_t)v32, (int16x8_t)v33);
            v33.i32[0] = *v62;
            v33.i8[4] = v62[1];
            int8x16_t v31 = (int8x16_t)vtrn1q_s16((int16x8_t)v31, (int16x8_t)v33);
            *(int8x8_t *)v32.i8 = vmovn_s16((int16x8_t)v32);
            v33.i32[0] = v37.i32[0];
            v33.i32[1] = vmovn_s16((int16x8_t)v30).u32[0];
            v33.i32[2] = v32.i32[0];
            *(int8x8_t *)v30.i8 = vmovn_s16((int16x8_t)v31);
            v33.i32[3] = v30.i32[0];
            *(int8x16_t *)unint64_t v36 = v33;
            v36 += 4;
            v59 += 2;
            --v58;
          }
          while (v58);
        }
        a11 = (float *)((char *)a11 + a12);
        v27 += a10;
      }
      while (v27 + (unint64_t)a3[14] < v20);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned short,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, __int16 *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v17 = result;
    unint64_t v18 = HIDWORD(v12);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v65, result, a2, a4, (uint64_t)a3);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v62, v17, a2, a5, (uint64_t)a3);
    AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v59, v17, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v56, v17, a2, a7, (uint64_t)a3);
    uint64_t v19 = a3[13];
    if ((unint64_t)a3[14] + v19 < v18)
    {
      int v50 = a3[7] * *(_DWORD *)(a2 + 60);
      do
      {
        uint64_t v21 = v19;
        int v22 = v50 + v19;
        int v66 = v50 + v19;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v65);
        int v63 = v22;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v62);
        int v60 = v22;
        AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v59);
        int v57 = v22;
        unint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v56);
        if (a9 >= 8)
        {
          uint64_t v32 = 0;
          uint64_t v33 = v65[0];
          uint64_t v34 = v62[0];
          uint64_t v35 = v67 + v65[0];
          uint64_t v36 = v56[0];
          uint64_t v37 = v59[0];
          uint64_t v38 = v64 + v62[0];
          uint64_t v39 = v61 + v59[0];
          unint64_t result = v58 + v56[0];
          uint64_t v40 = a11;
          int8x16_t v30 = a3;
          uint64_t v31 = v21;
          do
          {
            v23.i64[0] = *(void *)(v33 + v32);
            v24.i64[0] = *(void *)(v35 + v32);
            int8x16_t v23 = vzip1q_s8(v23, v24);
            v24.i64[0] = *(void *)(v34 + v32);
            v25.i64[0] = *(void *)(v38 + v32);
            int8x16_t v24 = vzip1q_s8(v24, v25);
            v25.i64[0] = *(void *)(v37 + v32);
            v26.i64[0] = *(void *)(v39 + v32);
            v27.i64[0] = *(void *)(v36 + v32);
            int8x16_t v25 = vzip1q_s8(v25, v26);
            v26.i64[0] = *(void *)(result + v32);
            int8x16_t v26 = vzip1q_s8(v27, v26);
            v68.val[0] = vzip1q_s16((int16x8_t)v23, (int16x8_t)v25);
            v68.val[1] = vzip1q_s16((int16x8_t)v24, (int16x8_t)v26);
            int v29 = v40 + 32;
            vst2q_s16(v40, v68);
            uint64_t v41 = v40 + 16;
            int8x16_t v27 = (int8x16_t)vzip2q_s16((int16x8_t)v23, (int16x8_t)v25);
            v68.val[1] = vzip2q_s16((int16x8_t)v24, (int16x8_t)v26);
            vst2q_s16(v41, *(int16x8x2_t *)v27.i8);
            unint64_t v28 = v32 + 8;
            unint64_t v42 = v32 + 16;
            v32 += 8;
            uint64_t v40 = v29;
          }
          while (v42 <= a9);
        }
        else
        {
          unint64_t v28 = 0;
          int v29 = a11;
          int8x16_t v30 = a3;
          uint64_t v31 = v21;
        }
        unint64_t v43 = v28 | 2;
        while (v43 <= a9)
        {
          uint64_t v44 = (unsigned __int8 *)(v28 + v67 + v65[0]);
          v23.i32[0] = *(unsigned __int8 *)(v28 + v65[0]);
          v23.i8[4] = *(unsigned char *)(v28 + v65[0] + 1);
          v24.i32[0] = *v44;
          v24.i8[4] = v44[1];
          int8x16_t v23 = (int8x16_t)vtrn1q_s16((int16x8_t)v23, (int16x8_t)v24);
          *(int8x8_t *)v23.i8 = vmovn_s16((int16x8_t)v23);
          v23.i16[2] = v23.i16[1];
          uint64_t v45 = (unsigned __int8 *)(v28 + v64 + v62[0]);
          v24.i32[0] = *(unsigned __int8 *)(v28 + v62[0]);
          v24.i8[4] = *(unsigned char *)(v28 + v62[0] + 1);
          v25.i32[0] = *v45;
          v25.i8[4] = v45[1];
          int8x16_t v24 = (int8x16_t)vtrn1q_s16((int16x8_t)v24, (int16x8_t)v25);
          *(int8x8_t *)v24.i8 = vmovn_s16((int16x8_t)v24);
          v24.i16[2] = v24.i16[1];
          uint64_t v46 = (unsigned __int8 *)(v28 + v61 + v59[0]);
          v25.i32[0] = *(unsigned __int8 *)(v28 + v59[0]);
          v25.i8[4] = *(unsigned char *)(v28 + v59[0] + 1);
          v26.i32[0] = *v46;
          v26.i8[4] = v46[1];
          int8x16_t v25 = (int8x16_t)vtrn1q_s16((int16x8_t)v25, (int16x8_t)v26);
          *(int8x8_t *)v25.i8 = vmovn_s16((int16x8_t)v25);
          v25.i16[2] = v25.i16[1];
          int32x4_t v47 = (unsigned __int8 *)(v28 + v58 + v56[0]);
          v26.i32[0] = *(unsigned __int8 *)(v28 + v56[0]);
          v26.i8[4] = *(unsigned char *)(v28 + v56[0] + 1);
          v27.i32[0] = *v47;
          v27.i8[4] = v47[1];
          int8x16_t v26 = (int8x16_t)vtrn1q_s16((int16x8_t)v26, (int16x8_t)v27);
          *(int8x8_t *)v26.i8 = vmovn_s16((int16x8_t)v26);
          v26.i16[2] = v26.i16[1];
          *(int16x4_t *)v27.i8 = vtrn1_s16(*(int16x4_t *)v23.i8, *(int16x4_t *)v25.i8);
          int16x4_t v48 = vtrn1_s16(*(int16x4_t *)v24.i8, *(int16x4_t *)v26.i8);
          vst2_s16(v29, (int16x4x2_t)v27);
          v29 += 8;
          unint64_t v43 = v28 + 4;
          v28 += 2;
        }
        if (v28 < a9)
        {
          do
          {
            LOBYTE(v55) = *(unsigned char *)(v28 + v65[0]);
            HIBYTE(v55) = *(unsigned char *)(v28 + v67 + v65[0]);
            LOBYTE(v54) = *(unsigned char *)(v28 + v62[0]);
            HIBYTE(v54) = *(unsigned char *)(v28 + v64 + v62[0]);
            LOBYTE(v53) = *(unsigned char *)(v28 + v59[0]);
            HIBYTE(v53) = *(unsigned char *)(v28 + v61 + v59[0]);
            LOBYTE(v52) = *(unsigned char *)(v28 + v56[0]);
            HIBYTE(v52) = *(unsigned char *)(v28 + v58 + v56[0]);
            LOWORD(v49) = v55;
            WORD1(v49) = v54;
            WORD2(v49) = v53;
            HIWORD(v49) = v52;
            *(void *)int v29 = v49;
            v29 += 4;
            ++v28;
          }
          while (a9 != v28);
        }
        a11 = (__int16 *)((char *)a11 + a12);
        uint64_t v19 = v31 + a10;
      }
      while (v19 + (unint64_t)v30[14] < v18);
    }
  }
  return result;
}

uint64_t CompressedInterleave4<unsigned int,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, float *a11, uint64_t a12)
{
  unint64_t v12 = *(void *)(a2 + 56);
  if (v12)
  {
    uint64_t v18 = result;
    unint64_t v19 = HIDWORD(v12);
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v72, result, a2, a4, (uint64_t)a3);
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v69, v18, a2, a5, (uint64_t)a3);
    AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v66, v18, a2, a6, (uint64_t)a3);
    unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v63, v18, a2, a7, (uint64_t)a3);
    uint64_t v20 = a3[13];
    if ((unint64_t)a3[14] + v20 < v19)
    {
      int v22 = a3[7] * *(_DWORD *)(a2 + 60);
      do
      {
        int v73 = v22 + v20;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v72);
        int v70 = v22 + v20;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v69);
        int v67 = v22 + v20;
        AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v66);
        int v64 = v22 + v20;
        unint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v63);
        if (a9 >= 4)
        {
          uint64_t v31 = 0;
          uint64_t v32 = 0;
          uint64_t v33 = v72[0];
          uint64_t v34 = v69[0];
          uint64_t v35 = v63[0];
          uint64_t v36 = v66[0];
          uint64_t v37 = v65 + v63[0];
          uint64_t v38 = v68 + v66[0];
          unint64_t result = v71 + v69[0];
          uint64_t v39 = v74 + v72[0];
          uint64_t v40 = a11;
          do
          {
            v23.i64[0] = *(void *)(v33 + v31);
            v24.i64[0] = *(void *)(v39 + v31);
            int8x16_t v23 = vzip1q_s8(v23, v24);
            v24.i64[0] = *(void *)(v34 + v31);
            v25.i64[0] = *(void *)(result + v31);
            int8x16_t v24 = vzip1q_s8(v24, v25);
            v25.i64[0] = *(void *)(v36 + v31);
            v26.i64[0] = *(void *)(v38 + v31);
            v27.i64[0] = *(void *)(v35 + v31);
            int8x16_t v25 = vzip1q_s8(v25, v26);
            v26.i64[0] = *(void *)(v37 + v31);
            int8x16_t v26 = vzip1q_s8(v27, v26);
            v75.val[0] = (float32x4_t)vzip1q_s32((int32x4_t)v23, (int32x4_t)v25);
            v75.val[1] = (float32x4_t)vzip1q_s32((int32x4_t)v24, (int32x4_t)v26);
            int8x16_t v30 = v40 + 16;
            vst2q_f32(v40, v75);
            uint64_t v41 = v40 + 8;
            int8x16_t v27 = (int8x16_t)vzip2q_s32((int32x4_t)v23, (int32x4_t)v25);
            v75.val[1] = (float32x4_t)vzip2q_s32((int32x4_t)v24, (int32x4_t)v26);
            vst2q_f32(v41, *(float32x4x2_t *)v27.i8);
            unint64_t v29 = v32 + 4;
            unint64_t v42 = v32 + 8;
            v31 += 8;
            v32 += 4;
            uint64_t v40 = v30;
          }
          while (v42 <= a9);
        }
        else
        {
          unint64_t v29 = 0;
          int8x16_t v30 = a11;
        }
        unint64_t v43 = v29 | 1;
        if ((v29 | 1) <= a9)
        {
          do
          {
            uint64_t v44 = (__int8 *)(v72[0] + 2 * v29);
            v24.i8[0] = *v44;
            uint64_t v45 = v44 + 1;
            uint64_t v46 = &v44[v74];
            v24.i8[4] = *v45;
            int32x4_t v47 = (__int8 *)(v69[0] + 2 * v29);
            v26.i8[0] = *v47;
            v26.i8[4] = v47[1];
            int16x4_t v48 = &v47[v71];
            __int8 v49 = *v48;
            __int8 v50 = v48[1];
            int16x8_t v51 = (__int8 *)(v66[0] + 2 * v29);
            v27.i8[0] = *v51;
            v27.i8[4] = v51[1];
            __int16 v52 = &v51[v68];
            v24.i8[1] = *v46;
            __int16 v53 = (__int8 *)(v63[0] + 2 * v29);
            v26.i8[1] = v49;
            v28.i8[0] = *v53;
            v28.i8[4] = v53[1];
            v27.i8[1] = *v52;
            v24.i8[2] = *v45;
            __int16 v54 = &v53[v65];
            v26.i8[2] = v26.i8[4];
            v27.i8[2] = v27.i8[4];
            v24.i8[3] = v46[1];
            v28.i8[1] = *v54;
            v26.i8[3] = v50;
            v28.i8[2] = v28.i8[4];
            v27.i8[3] = v52[1];
            v28.i8[3] = v54[1];
            *(int32x2_t *)v24.i8 = vzip1_s32(*(int32x2_t *)v24.i8, *(int32x2_t *)v27.i8);
            *(int32x2_t *)v25.i8 = vzip1_s32(*(int32x2_t *)v26.i8, v28);
            vst2_f32(v30, (float32x2x2_t)v24);
            v30 += 4;
            unint64_t v29 = v43++;
          }
          while (v43 <= a9);
          unint64_t v29 = v43 - 1;
        }
        unint64_t v55 = a9 - v29;
        if (a9 > v29)
        {
          uint64_t v56 = 2 * v29;
          do
          {
            int v57 = (unsigned __int8 *)(v56 + v74 + v72[0]);
            uint64_t v58 = (__int8 *)(v57 + 1);
            v23.i32[0] = *(unsigned __int8 *)(v56 + v72[0]);
            v23.i8[4] = *(unsigned char *)(v56 + v72[0] + 1);
            v24.i32[0] = *v57;
            uint64_t v59 = (unsigned __int8 *)(v56 + v71 + v69[0]);
            v24.i8[4] = *v58;
            v25.i32[0] = *(unsigned __int8 *)(v56 + v69[0]);
            v25.i8[4] = *(unsigned char *)(v56 + v69[0] + 1);
            v26.i32[0] = *v59;
            v26.i8[4] = v59[1];
            int16x8_t v60 = vtrn1q_s16((int16x8_t)v23, (int16x8_t)v24);
            uint64_t v61 = (unsigned __int8 *)(v56 + v68 + v66[0]);
            v24.i32[0] = *(unsigned __int8 *)(v56 + v66[0]);
            int8x16_t v25 = (int8x16_t)vtrn1q_s16((int16x8_t)v25, (int16x8_t)v26);
            v24.i8[4] = *(unsigned char *)(v56 + v66[0] + 1);
            v26.i32[0] = *v61;
            v26.i8[4] = v61[1];
            v23.i32[0] = vmovn_s16(v60).u32[0];
            *(int8x8_t *)v25.i8 = vmovn_s16((int16x8_t)v25);
            __int16 v62 = (unsigned __int8 *)(v56 + v65 + v63[0]);
            v27.i32[0] = *(unsigned __int8 *)(v56 + v63[0]);
            int8x16_t v24 = (int8x16_t)vtrn1q_s16((int16x8_t)v24, (int16x8_t)v26);
            v27.i8[4] = *(unsigned char *)(v56 + v63[0] + 1);
            v26.i32[0] = *v62;
            v26.i8[4] = v62[1];
            int8x16_t v26 = (int8x16_t)vtrn1q_s16((int16x8_t)v27, (int16x8_t)v26);
            v23.i32[1] = v25.i32[0];
            v23.i32[2] = vmovn_s16((int16x8_t)v24).u32[0];
            *(int8x8_t *)v24.i8 = vmovn_s16((int16x8_t)v26);
            v23.i32[3] = v24.i32[0];
            *(int8x16_t *)int8x16_t v30 = v23;
            v30 += 4;
            v56 += 2;
            --v55;
          }
          while (v55);
        }
        a11 = (float *)((char *)a11 + a12);
        v20 += a10;
      }
      while (v20 + (unint64_t)a3[14] < v19);
    }
  }
  return result;
}

uint64_t TileDecoder_ScanlineCompressed::ExtractPlane(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v9 = *(void *)(a4 + 8);
  unsigned int v10 = *(_DWORD *)(v9 + 80);
  unsigned int v11 = *(_DWORD *)(v9 + 104);
  v14[0] = 0;
  v14[1] = 0;
  int v16 = 0;
  uint64_t v15 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a1, a5, v10, v11, (unsigned int *)v14);
  if (HIDWORD(v15) && v16)
  {
    uint64_t v13 = *(void *)(a1 + 64);
    if (v13) {
      uint64_t v13 = 2 * (*(void *)(v13 + 8) != 0);
    }
    return ((uint64_t (*)(uint64_t, uint64_t, _DWORD *, uint64_t, void))TileDecoder_ScanlineCompressed::ExtractPlane(void const*,unsigned long,ChannelInfo const&,TileInfo const&,void *,unsigned long,long)const::kFuncTable[v13 | (*(_DWORD *)(*(void *)(a4 + 8) + 72) != 1)])(a2, a1, a5, a4, LODWORD(v14[0]));
  }
  return result;
}

void CompressedPlanar<unsigned short,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, unint64_t a6, unsigned int a7, int16x8_t *a8, uint64_t a9)
{
  unint64_t v9 = *(void *)(a2 + 56);
  if (v9)
  {
    uint64_t v10 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v10 : NAN;
    unint64_t v12 = HIDWORD(v9);
    int v13 = *(_DWORD *)(v10 + 16);
    if (v13 == 2)
    {
      *(float *)&unsigned int v14 = _D0;
    }
    else if (v13 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v30) = _H0;
      LOWORD(v30) = _H0;
      unsigned int v14 = v30;
    }
    else
    {
      unsigned int v14 = _D0;
    }
    uint64_t v20 = *(unsigned int *)(a3 + 52);
    if ((unint64_t)*(unsigned int *)(a3 + 56) + v20 < v12)
    {
      __int16 v21 = v14;
      int16x8_t v22 = vdupq_n_s16(v14);
      do
      {
        if (a6 >= 0x20)
        {
          uint64_t v25 = 0;
          int8x16_t v26 = a8;
          do
          {
            int8x16_t v24 = v26 + 4;
            int16x8_t *v26 = v22;
            v26[1] = v22;
            v26[2] = v22;
            v26[3] = v22;
            unint64_t v23 = v25 + 32;
            unint64_t v27 = v25 + 64;
            v25 += 32;
            v26 += 4;
          }
          while (v27 <= a6);
        }
        else
        {
          unint64_t v23 = 0;
          int8x16_t v24 = a8;
        }
        unint64_t v28 = v23 | 8;
        if ((v23 | 8) <= a6)
        {
          do
          {
            *v24++ = v22;
            v28 += 8;
          }
          while (v28 <= a6);
          unint64_t v23 = v28 - 8;
        }
        _CF = a6 >= v23;
        unint64_t v29 = a6 - v23;
        if (v29 != 0 && _CF)
        {
          do
          {
            v24->i16[0] = v21;
            int8x16_t v24 = (int16x8_t *)((char *)v24 + 2);
            --v29;
          }
          while (v29);
        }
        a8 = (int16x8_t *)((char *)a8 + a9);
        v20 += a7;
      }
      while (v20 + (unint64_t)*(unsigned int *)(a3 + 56) < v12);
    }
  }
}

void CompressedPlanar<unsigned int,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, unint64_t a6, unsigned int a7, int32x4_t *a8, uint64_t a9)
{
  unint64_t v9 = *(void *)(a2 + 56);
  if (v9)
  {
    uint64_t v10 = *a4;
    _D0 = *(unsigned char *)(*a4 + 24) ? *(double *)v10 : NAN;
    unint64_t v12 = HIDWORD(v9);
    int v13 = *(_DWORD *)(v10 + 16);
    if (v13 == 2)
    {
      float v14 = _D0;
    }
    else if (v13 == 1)
    {
      __asm { FCVT            H0, D0 }
      HIWORD(v29) = _H0;
      LOWORD(v29) = _H0;
      float v14 = v29;
    }
    else
    {
      LODWORD(v14) = _D0;
    }
    uint64_t v20 = *(unsigned int *)(a3 + 52);
    if ((unint64_t)*(unsigned int *)(a3 + 56) + v20 < v12)
    {
      int32x4_t v21 = vdupq_n_s32(LODWORD(v14));
      do
      {
        if (a6 >= 0x20)
        {
          uint64_t v24 = 0;
          uint64_t v25 = a8;
          do
          {
            unint64_t v23 = v25 + 8;
            *uint64_t v25 = v21;
            v25[1] = v21;
            v25[2] = v21;
            v25[3] = v21;
            v25[4] = v21;
            v25[5] = v21;
            unint64_t v22 = v24 + 32;
            unint64_t v26 = v24 + 64;
            v24 += 32;
            v25[6] = v21;
            v25[7] = v21;
            v25 += 8;
          }
          while (v26 <= a6);
        }
        else
        {
          unint64_t v22 = 0;
          unint64_t v23 = a8;
        }
        unint64_t v27 = v22 | 8;
        if ((v22 | 8) <= a6)
        {
          do
          {
            *unint64_t v23 = v21;
            v23[1] = v21;
            v23 += 2;
            v27 += 8;
          }
          while (v27 <= a6);
          unint64_t v22 = v27 - 8;
        }
        _CF = a6 >= v22;
        unint64_t v28 = a6 - v22;
        if (v28 != 0 && _CF)
        {
          do
          {
            *(float *)v23->i32 = v14;
            unint64_t v23 = (int32x4_t *)((char *)v23 + 4);
            --v28;
          }
          while (v28);
        }
        a8 = (int32x4_t *)((char *)a8 + a9);
        v20 += a7;
      }
      while (v20 + (unint64_t)*(unsigned int *)(a3 + 56) < v12);
    }
  }
}

uint64_t CompressedPlanar<unsigned short,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7, char *a8, uint64_t a9)
{
  unint64_t v10 = *(void *)(a2 + 56);
  if (v10)
  {
    unint64_t v15 = HIDWORD(v10);
    uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream((uint64_t)v32, result, a2, a4, (uint64_t)a3);
    uint64_t v16 = a3[13];
    if ((unint64_t)a3[14] + v16 < v15)
    {
      int v17 = a3[7] * *(_DWORD *)(a2 + 60);
      do
      {
        int v33 = v17 + v16;
        uint64_t result = AXRSplitStream<unsigned short,(StreamType)1>::SetDataP((uint64_t)v32);
        if (a6 >= 0x20)
        {
          uint64_t v20 = 0;
          uint64_t v21 = v32[0];
          uint64_t v22 = v34 + v32[0];
          unint64_t v23 = a8;
          do
          {
            v37.val[0] = *(int8x16_t *)(v21 + v20);
            v36.val[0] = *(int8x16_t *)(v21 + v20 + 16);
            v37.val[1] = *(int8x16_t *)(v22 + v20);
            v36.val[1] = *(int8x16_t *)(v22 + v20 + 16);
            unint64_t v19 = v23 + 64;
            vst2q_s8(v23, v37);
            uint64_t v24 = v23 + 32;
            vst2q_s8(v24, v36);
            unint64_t v18 = v20 + 32;
            unint64_t v25 = v20 + 64;
            v20 += 32;
            unint64_t v23 = v19;
          }
          while (v25 <= a6);
        }
        else
        {
          unint64_t v18 = 0;
          unint64_t v19 = a8;
        }
        unint64_t v26 = v18 | 8;
        if ((v18 | 8) <= a6)
        {
          do
          {
            unint64_t v27 = (int8x8_t *)(v18 + v32[0]);
            v35.val[0] = *v27;
            v35.val[1] = *(int8x8_t *)((char *)v27 + v34);
            vst2_s8(v19, v35);
            v19 += 16;
            unint64_t v18 = v26;
            v26 += 8;
          }
          while (v26 <= a6);
          unint64_t v18 = v26 - 8;
        }
        unint64_t v28 = a6 - v18;
        if (a6 > v18)
        {
          uint64_t v29 = v34;
          unsigned int v30 = (char *)(v18 + v32[0]);
          do
          {
            char v31 = *v30;
            v19[1] = v30[v29];
            *unint64_t v19 = v31;
            v19 += 2;
            ++v30;
            --v28;
          }
          while (v28);
        }
        a8 += a9;
        v16 += a7;
      }
      while (v16 + (unint64_t)a3[14] < v15);
    }
  }
  return result;
}

uint64_t CompressedPlanar<unsigned int,(StreamType)1>(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7, int8x16_t *a8, uint64_t a9)
{
  unint64_t v10 = *(void *)(a2 + 56);
  if (v10)
  {
    unint64_t v15 = HIDWORD(v10);
    uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream((uint64_t)v45, result, a2, a4, (uint64_t)a3);
    uint64_t v16 = a3[13];
    if ((unint64_t)a3[14] + v16 < v15)
    {
      int v17 = a3[7] * *(_DWORD *)(a2 + 60);
      do
      {
        int v46 = v17 + v16;
        uint64_t result = AXRSplitStream<unsigned int,(StreamType)1>::SetDataP((uint64_t)v45);
        if (a6 >= 0x20)
        {
          uint64_t v22 = 0;
          unint64_t v23 = (int8x16_t *)v45[0];
          uint64_t v24 = v47;
          unint64_t v25 = a8;
          do
          {
            int8x16_t v27 = v23[2];
            int8x16_t v26 = v23[3];
            int8x16_t v28 = v23[1];
            int8x16_t v30 = *(int8x16_t *)((char *)&v23[2] + v24);
            int8x16_t v29 = *(int8x16_t *)((char *)&v23[3] + v24);
            int8x16_t v32 = *(int8x16_t *)((char *)v23 + v24);
            int8x16_t v31 = *(int8x16_t *)((char *)&v23[1] + v24);
            int8x16_t v33 = vzip2q_s8(*v23, v32);
            int8x16_t v34 = vzip1q_s8(*v23, v32);
            int8x16_t v35 = vzip2q_s8(v28, v31);
            int8x16_t v36 = vzip1q_s8(v28, v31);
            int8x16_t v37 = vzip2q_s8(v27, v30);
            int16x8_t v19 = (int16x8_t)vzip1q_s8(v27, v30);
            int8x16_t v38 = vzip2q_s8(v26, v29);
            int16x8_t v18 = (int16x8_t)vzip1q_s8(v26, v29);
            i8 = v25[8].i8;
            v25[6] = (int8x16_t)v18;
            v25[7] = v38;
            v25[4] = (int8x16_t)v19;
            v25[5] = v37;
            v25[2] = v36;
            v25[3] = v35;
            unint64_t v20 = v22 + 32;
            unint64_t v39 = v22 + 64;
            *unint64_t v25 = v34;
            v25[1] = v33;
            v23 += 4;
            v22 += 32;
            v25 += 8;
          }
          while (v39 <= a6);
        }
        else
        {
          unint64_t v20 = 0;
          i8 = (char *)a8;
        }
        unint64_t v40 = v20 | 8;
        if ((v20 | 8) <= a6)
        {
          do
          {
            uint64_t v41 = (int16x8_t *)(v45[0] + 2 * v20);
            int16x8_t v18 = *v41;
            int16x8_t v19 = *(int16x8_t *)((char *)v41 + v47);
            vst2q_s8(i8, *(int8x16x2_t *)v18.i8);
            i8 += 32;
            unint64_t v20 = v40;
            v40 += 8;
          }
          while (v40 <= a6);
          unint64_t v20 = v40 - 8;
        }
        unint64_t v42 = a6 - v20;
        if (a6 > v20)
        {
          uint64_t v43 = v47;
          uint64_t v44 = (unsigned __int8 *)(v45[0] + 2 * v20);
          do
          {
            v18.i32[0] = v44[v43];
            v18.i8[4] = v44[v43 + 1];
            v19.i32[0] = *v44;
            v19.i8[4] = v44[1];
            int16x8_t v18 = vtrn1q_s16(v19, v18);
            *(int8x8_t *)v18.i8 = vmovn_s16(v18);
            *(_DWORD *)i8 = v18.i32[0];
            i8 += 4;
            v44 += 2;
            --v42;
          }
          while (v42);
        }
        a8 = (int8x16_t *)((char *)a8 + a9);
        v16 += a7;
      }
      while (v16 + (unint64_t)a3[14] < v15);
    }
  }
  return result;
}

void TileDecoder_Zips::Decompress(AXRBufferPool *this@<X1>, TileDecoder *a2@<X0>, uint64_t a3@<X2>, size_t *a4@<X3>, uint8_t **a5@<X8>)
{
  AXRBufferPool::allocate(this, a5);
  if (!*a5)
  {
    *a4 = 0;
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -5;
  }
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(*(void *)(v9 + 280) + 8 * *(unsigned int *)(a3 + 60)) + 8)
                  + 8 * *(unsigned int *)(a3 + 32));
  if (!v10)
  {
    *a4 = 0;
    uint64_t v24 = __cxa_allocate_exception(8uLL);
    *uint64_t v24 = -4;
  }
  BOOL v11 = __CFADD__(v10, 1);
  unint64_t v12 = (unint64_t)(v10 + 1) >> 1;
  uint64_t v13 = 0x80000000;
  if (v11) {
    unint64_t v12 = 0x80000000;
  }
  uint64_t v14 = *(void *)(a3 + 16);
  BOOL v11 = __CFADD__(v14, 1);
  unint64_t v15 = (unint64_t)(v14 + 1) >> 1;
  if (!v11) {
    uint64_t v13 = v15;
  }
  size_t v16 = v13 + v12;
  if (v16 >= *a4) {
    unint64_t v17 = *a4;
  }
  else {
    unint64_t v17 = v16;
  }
  *a4 = v17;
  CompressedDataPtr = (const uint8_t *)AXRChunkHeader::GetCompressedDataPtr(*(void *)a3, *(_DWORD *)(v9 + 208), v17);
  if (!CompressedDataPtr)
  {
    unint64_t v25 = __cxa_allocate_exception(8uLL);
    *unint64_t v25 = -4;
  }
  size_t v19 = compression_decode_buffer(*a5, *a4, CompressedDataPtr, *(void *)(a3 + 8), 0, (compression_algorithm)0x505u);
  unint64_t v20 = v19;
  if (!v19)
  {
    int v21 = uncompress(*a5, a4, CompressedDataPtr, *(void *)(a3 + 8));
    if (v21 == -5 || v21 == 0)
    {
      unint64_t v20 = *a4;
      if (*a4) {
        goto LABEL_19;
      }
      int8x16_t v26 = __cxa_allocate_exception(8uLL);
      uint64_t v27 = -4;
    }
    else
    {
      int8x16_t v26 = __cxa_allocate_exception(8uLL);
      uint64_t v27 = -6;
    }
    void *v26 = v27;
  }
  *a4 = v19;
LABEL_19:
  TileDecoder::RemovePrefixSumPredictor(a2, *a5, v20);
}

void sub_228F141CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0;
  if (v3)
  {
    if (v1[1]) {
      free((void *)(v3 - 64));
    }
  }
  _Unwind_Resume(exception_object);
}

void TileDecoder_RLE::Decompress(AXRBufferPool *this@<X1>, TileDecoder *a2@<X0>, uint64_t a3@<X2>, unint64_t *a4@<X3>, unsigned __int8 **a5@<X8>)
{
  AXRBufferPool::allocate(this, a5);
  if (!*a5)
  {
    *a4 = 0;
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -5;
  }
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(*(void *)(v9 + 280) + 8 * *(unsigned int *)(a3 + 60)) + 8)
                  + 8 * *(unsigned int *)(a3 + 32));
  unint64_t v11 = *(void *)(a3 + 8);
  if (v10) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    unint64_t v13 = *a4;
    goto LABEL_10;
  }
  *a4 = 0;
  if (!v11)
  {
    int8x16_t v33 = __cxa_allocate_exception(8uLL);
    uint64_t v34 = -4;
    goto LABEL_42;
  }
  if (!v10)
  {
    int8x16_t v33 = __cxa_allocate_exception(8uLL);
    uint64_t v34 = -6;
LABEL_42:
    *int8x16_t v33 = v34;
  }
  unint64_t v13 = 0;
LABEL_10:
  BOOL v14 = __CFADD__(v10, 1);
  unint64_t v15 = (unint64_t)(v10 + 1) >> 1;
  uint64_t v16 = 0x80000000;
  if (v14) {
    unint64_t v15 = 0x80000000;
  }
  uint64_t v17 = *(void *)(a3 + 16);
  BOOL v14 = __CFADD__(v17, 1);
  unint64_t v18 = (unint64_t)(v17 + 1) >> 1;
  if (!v14) {
    uint64_t v16 = v18;
  }
  unint64_t v19 = v16 + v15;
  if (v16 + v15 >= v13) {
    unint64_t v20 = v13;
  }
  else {
    unint64_t v20 = v16 + v15;
  }
  *a4 = v20;
  CompressedDataPtr = (unsigned __int8 *)AXRChunkHeader::GetCompressedDataPtr(*(void *)a3, *(_DWORD *)(v9 + 208), v20);
  if (!CompressedDataPtr)
  {
    int8x16_t v31 = __cxa_allocate_exception(8uLL);
    *int8x16_t v31 = -4;
  }
  if (v11 < 2)
  {
    *a4 = 0;
    goto LABEL_39;
  }
  uint64_t v22 = *a5;
  do
  {
    uint64_t v23 = (char)*CompressedDataPtr;
    if (v23 < 0)
    {
      if (-v23 < v19) {
        unint64_t v27 = -v23;
      }
      else {
        unint64_t v27 = v19;
      }
      if (v27 >= v11 - 1) {
        size_t v25 = v11 - 1;
      }
      else {
        size_t v25 = v27;
      }
      uint64_t v26 = v25 + 1;
      v11 -= v25 + 1;
      memcpy(v22, CompressedDataPtr + 1, v25);
    }
    else
    {
      uint64_t v24 = *CompressedDataPtr;
      if (v24 + 1 < v19) {
        size_t v25 = v24 + 1;
      }
      else {
        size_t v25 = v19;
      }
      v11 -= 2;
      memset(v22, CompressedDataPtr[1], v25);
      uint64_t v26 = 2;
    }
    v22 += v25;
    if (v11 < 2) {
      break;
    }
    CompressedDataPtr += v26;
    v19 -= v25;
  }
  while (v19);
  int8x16_t v28 = *a5;
  unint64_t v29 = v22 - *a5;
  BOOL v12 = v22 == *a5;
  *a4 = v29;
  if (v12)
  {
LABEL_39:
    int8x16_t v32 = __cxa_allocate_exception(8uLL);
    *int8x16_t v32 = -4;
  }
  TileDecoder::RemovePrefixSumPredictor(a2, v28, v29);
}

void sub_228F14430(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0;
  if (v3)
  {
    if (v1[1]) {
      free((void *)(v3 - 64));
    }
  }
  _Unwind_Resume(exception_object);
}

void TileDecoder_Zips::~TileDecoder_Zips(void **this)
{
  TileDecoder::~TileDecoder(this);

  JUMPOUT(0x22A6AD870);
}

uint64_t TileDecoder_Zips::GetMinimumTileBytes(TileDecoder_Zips *this)
{
  return 4096;
}

uint64_t TileDecoder_Zips::GetCompressionMethod(TileDecoder_Zips *this)
{
  return 2;
}

void TileDecoder_RLE::~TileDecoder_RLE(void **this)
{
  TileDecoder::~TileDecoder(this);

  JUMPOUT(0x22A6AD870);
}

uint64_t TileDecoder_RLE::GetMinimumTileBytes(TileDecoder_RLE *this)
{
  return 0x4000;
}

uint64_t TileDecoder_RLE::GetCompressionMethod(TileDecoder_RLE *this)
{
  return 1;
}

uint64_t AXRSplitStream<unsigned short,(StreamType)1>::AXRSplitStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = *(_DWORD *)(a3 + 60);
  *(void *)(a1 + 16) = *(void *)(a4 + 8);
  *(_DWORD *)(a1 + 32) = *(void *)(a5 + 24);
  *(void *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a5 + 60);
  int v9 = *(_DWORD *)(a5 + 44);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a5 + 52) + *(_DWORD *)(a5 + 28) * v8;
  *(_DWORD *)(a1 + 28) = v9;
  AXRStream<unsigned short,(StreamType)1>::SetDataP(a1);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(*(void *)(*(void *)(a3 + 24) + 280) + 8 * *(unsigned int *)(a5 + 60))
                              + 8)
                  + 8 * *(unsigned int *)(a5 + 32));
  BOOL v11 = __CFADD__(v10, 1);
  unint64_t v12 = (unint64_t)(v10 + 1) >> 1;
  if (v11) {
    unint64_t v12 = 0x80000000;
  }
  *(void *)(a1 + 40) = v12;
  AXRSplitStream<unsigned short,(StreamType)1>::SetDataP(a1);
  return a1;
}

unint64_t AXRSplitStream<unsigned short,(StreamType)1>::SetDataP(uint64_t a1)
{
  unint64_t result = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(a1 + 16), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 32), *(_DWORD *)(a1 + 36));
  unint64_t v3 = HIDWORD(result);
  if (HIDWORD(result))
  {
    LODWORD(v4) = (result + 1) >> 1;
    if (result == -1) {
      uint64_t v4 = 0x80000000;
    }
    else {
      uint64_t v4 = v4;
    }
    unint64_t v3 = *(void *)(a1 + 8) + *(unsigned int *)(a1 + 28) + v4;
  }
  *(void *)a1 = v3;
  return result;
}

unint64_t AXRStream<unsigned short,(StreamType)1>::SetDataP(uint64_t a1)
{
  unint64_t result = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(a1 + 16), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 32), *(_DWORD *)(a1 + 36));
  uint64_t v3 = HIDWORD(result);
  if (HIDWORD(result)) {
    uint64_t v3 = *(void *)(a1 + 8) + result + 2 * *(unsigned int *)(a1 + 28);
  }
  *(void *)a1 = v3;
  return result;
}

uint64_t AXRSplitStream<unsigned int,(StreamType)1>::AXRSplitStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = *(_DWORD *)(a3 + 60);
  *(void *)(a1 + 16) = *(void *)(a4 + 8);
  *(_DWORD *)(a1 + 32) = *(void *)(a5 + 24);
  *(void *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a5 + 60);
  int v9 = *(_DWORD *)(a5 + 44);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a5 + 52) + *(_DWORD *)(a5 + 28) * v8;
  *(_DWORD *)(a1 + 28) = v9;
  AXRStream<unsigned int,(StreamType)1>::SetDataP(a1);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(*(void *)(*(void *)(a3 + 24) + 280) + 8 * *(unsigned int *)(a5 + 60))
                              + 8)
                  + 8 * *(unsigned int *)(a5 + 32));
  BOOL v11 = __CFADD__(v10, 1);
  unint64_t v12 = (unint64_t)(v10 + 1) >> 1;
  if (v11) {
    unint64_t v12 = 0x80000000;
  }
  *(void *)(a1 + 40) = v12;
  AXRSplitStream<unsigned int,(StreamType)1>::SetDataP(a1);
  return a1;
}

unint64_t AXRSplitStream<unsigned int,(StreamType)1>::SetDataP(uint64_t a1)
{
  unint64_t result = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(a1 + 16), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 32), *(_DWORD *)(a1 + 36));
  uint64_t v3 = HIDWORD(result);
  if (HIDWORD(result))
  {
    LODWORD(v4) = (result + 1) >> 1;
    if (result == -1) {
      uint64_t v4 = 0x80000000;
    }
    else {
      uint64_t v4 = v4;
    }
    uint64_t v3 = *(void *)(a1 + 8) + v4 + 2 * *(unsigned int *)(a1 + 28);
  }
  *(void *)a1 = v3;
  return result;
}

unint64_t AXRStream<unsigned int,(StreamType)1>::SetDataP(uint64_t a1)
{
  unint64_t result = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(a1 + 16), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 32), *(_DWORD *)(a1 + 36));
  uint64_t v3 = HIDWORD(result);
  if (HIDWORD(result)) {
    uint64_t v3 = *(void *)(a1 + 8) + result + 4 * *(unsigned int *)(a1 + 28);
  }
  *(void *)a1 = v3;
  return result;
}

void TileDecoder_PIZ::InitLookupTable(int8x8_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  int v8 = *(_WORD **)a3;
  if (a5 >= 0x2000) {
    uint64_t v9 = 0x2000;
  }
  else {
    uint64_t v9 = a5;
  }
  if (0x2000 - v9 >= a6) {
    unint64_t v10 = a6;
  }
  else {
    unint64_t v10 = 0x2000 - v9;
  }
  if (v10)
  {
    *int v8 = 0;
    uint64_t v11 = v9 != 0;
    unsigned __int8 v12 = *a4 | (v9 == 0);
    a1.i32[0] = v12;
    unsigned __int8 v13 = vaddlv_u8((uint8x8_t)vcnt_s8(a1));
    int16x8_t v14 = vdupq_n_s16(8 * (int)v9);
    unsigned __int8 v15 = v13;
    uint16x8_t v16 = vaddw_u8((uint16x8_t)v14, *(uint8x8_t *)(a7 + 8 * v12));
    unint64_t v17 = v10 - 1;
    if (v17)
    {
      unint64_t v18 = a4 + 1;
      v19.i64[0] = 0x8000800080008;
      v19.i64[1] = 0x8000800080008;
      do
      {
        *(uint16x8_t *)&v8[v11] = v16;
        v11 += v15;
        int16x8_t v14 = vaddq_s16(v14, v19);
        unsigned int v20 = *v18++;
        unsigned __int8 v15 = vaddlv_u8((uint8x8_t)vcnt_s8((int8x8_t)v20));
        uint16x8_t v16 = vaddw_u8((uint16x8_t)v14, *(uint8x8_t *)(a7 + 8 * v20));
        --v17;
      }
      while (v17);
    }
    *(uint16x8_t *)&v8[v11] = v16;
    uint64_t v21 = v11 + v15;
    bzero(&v8[v21], 0x20000 - 2 * v21);
    uint64_t v22 = v21 - 1;
  }
  else
  {
    bzero(v8, 0x4000uLL);
    uint64_t v22 = 0;
  }
  *(void *)(a3 + 48) = v22;
}

void TileDecoder_PIZ::Decompress(uint64_t a1@<X0>, AXRBufferPool *a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  CompressedDataPtr = (unsigned __int16 *)AXRChunkHeader::GetCompressedDataPtr(*(void *)a3, *(_DWORD *)(*(void *)(a1 + 24) + 208), *(void *)(a3 + 8));
  unint64_t v11 = *(void *)(a3 + 8);
  AXRBufferPool::allocate(a2, a5);
  uint64_t v12 = *a5;
  if (!*a5)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -5;
  }
  TileDecoder_PIZ::InitPoolInfo(a1, (void *)*a5, *(void *)(a1 + 48));
  **(_DWORD **)(v12 + 32) = 0;
  int8x8_t v43 = *(int8x8_t *)(a3 + 24);
  int v13 = *(_DWORD *)(a1 + 60);
  uint64_t ImageSize = Part::GetImageSize(*(Part **)(a1 + 24), *(unsigned int *)(a3 + 60), *(void *)(a1 + 8), v14, v15, v16, v17, v18);
  int8x8_t v20 = v43;
  unsigned int v21 = v13 + v13 * v43.i32[1];
  if (v21 >= HIDWORD(ImageSize)) {
    unsigned int v21 = HIDWORD(ImageSize);
  }
  BOOL v22 = v21 != 0;
  unsigned int v23 = v21 - 1;
  if (v22) {
    unint64_t v24 = v23;
  }
  else {
    unint64_t v24 = 0;
  }
  unint64_t v25 = *(unsigned int *)(a1 + 72);
  if (v25)
  {
    unint64_t v42 = v11;
    uint64_t v44 = a4;
    uint64_t v26 = 0;
    unint64_t v27 = 0;
    unint64_t v28 = 0;
    uint64_t v29 = -1;
    do
    {
      uint64_t v30 = *(void *)(a1 + 64);
      int8x16_t v31 = *(unsigned int **)(v30 + v26);
      if (!*((unsigned char *)v31 + 24))
      {
        uint64_t v32 = *v31;
        uint64_t ImageSize = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(v30 + v26 + 8), v24, *(void *)(a3 + 24), *(_DWORD *)(a3 + 60));
        if (v29 <= v32) {
          uint64_t v29 = v32;
        }
        if (v27 <= (HIDWORD(ImageSize) + ImageSize)) {
          unint64_t v27 = (HIDWORD(ImageSize) + ImageSize);
        }
        unint64_t v25 = *(unsigned int *)(a1 + 72);
      }
      ++v28;
      v26 += 16;
    }
    while (v28 < v25);
    if (v29 != -1)
    {
      *uint64_t v44 = v27;
      if (v42 <= 3)
      {
        *uint64_t v44 = 0;
        unint64_t v40 = __cxa_allocate_exception(8uLL);
        *unint64_t v40 = -4;
      }
      unint64_t v33 = *CompressedDataPtr;
      unsigned int v34 = CompressedDataPtr[1];
      unint64_t v35 = v42 - 4;
      BOOL v22 = v34 >= v33;
      unint64_t v36 = v34 - v33 + 1;
      if (v22) {
        unint64_t v37 = v36;
      }
      else {
        unint64_t v37 = 0;
      }
      if (v35 < v37)
      {
        *uint64_t v44 = 0;
        uint64_t v41 = __cxa_allocate_exception(8uLL);
        *uint64_t v41 = -4;
      }
      TileDecoder_PIZ::InitLookupTable(v20, ImageSize, v12, (unsigned char *)CompressedDataPtr + 4, v33, v37, (uint64_t)&TileDecoder_PIZ::kLookupDecodeTable);
      if (v35 - v37 >= 5)
      {
        int v38 = *(_DWORD *)((char *)CompressedDataPtr + v37 + 4);
        uint64_t v45 = v35 - v37 - 4;
        TileDecoder_PIZ::HuffmanDecompress(a1, v12, (unsigned int *)((char *)CompressedDataPtr + v37 + 8), v38, (unint64_t *)&v45, v44);
      }
    }
  }
}

void sub_228F14AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t *a9)
{
  uint64_t v10 = *a9;
  *a9 = 0;
  if (v10)
  {
    if (a9[1]) {
      free((void *)(v10 - 64));
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t TileDecoder_PIZ::InitPoolInfo(uint64_t result, void *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(result + 72);
  if (v3)
  {
    uint64_t v4 = *(void *)(result + 64) + 8;
    uint64_t v5 = *(unsigned int *)(result + 72);
    unint64_t v6 = 2;
    do
    {
      if (!*(unsigned char *)(*(void *)(v4 - 8) + 24) && *(void *)v4)
      {
        unint64_t v7 = *(_DWORD *)(*(void *)v4 + 72) == 1 ? 2 : 4;
        if (v6 <= v7) {
          unint64_t v6 = v7;
        }
      }
      v4 += 16;
      --v5;
    }
    while (v5);
  }
  else
  {
    unint64_t v6 = 2;
  }
  uint64_t v8 = (v3 + 119) & 0x1FFFFFFC0;
  unint64_t v9 = (a3 + 63) & 0xFFFFFFFFFFFFFFC0;
  unint64_t v10 = ((v6 * (*(_DWORD *)(result + 56) * *(_DWORD *)(result + 60)) + 63) & 0xFFFFFFFFFFFFFFC0) + v9;
  if (v10 <= 0x80040) {
    unint64_t v10 = 524352;
  }
  uint64_t v11 = (uint64_t)a2 + v8 + 0x20000;
  *a2 = (char *)a2 + v8;
  a2[1] = v11;
  a2[2] = v11 + v9;
  a2[3] = v11;
  a2[5] = v8 + v10 + 0x20000;
  a2[6] = 0;
  a2[4] = a2 + 7;
  return result;
}

uint64_t Part::GetImageSize(Part *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((unsigned int *)this + 73) * (unint64_t)*((unsigned int *)this + 72) <= a2) {
    Part::GetImageSize((uint64_t)this + 288, (uint64_t)this + 292, a2, a3, a5, a6, a7, a8);
  }
  return *(void *)(*(void *)(*((void *)this + 35) + 8 * a2) + 24);
}

void TileDecoder_PIZ::HuffmanDecompress(uint64_t a1, uint64_t a2, unsigned int *a3, int a4, unint64_t *a5, void *a6)
{
  uint64_t v11 = a3;
  if (a4 < 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -6;
  }
  unint64_t v9 = (void **)TileDecoder_PIZ::HuffmanUnpackDecodingTable(a1, a2, &v11, a5);
  TileDecoder_PIZ::HuffmanDecode((uint64_t)v9, (unint64_t *)v11, (uint64_t *)a5, *(char **)(a2 + 8), (uint64_t)v9, a6);

  DestroyHuffmanDecodeTable(v9);
}

uint64_t TileDecoder_PIZ::HuffmanUnpackDecodingTable(uint64_t a1, uint64_t a2, unsigned int **a3, unint64_t *a4)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  if (*a4 <= 0x13)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v89 = -4;
LABEL_122:
    void *exception = v89;
  }
  unsigned int v4 = 65537;
  uint64_t v5 = (uint64_t)*a3;
  uint64_t v6 = **a3;
  if (v6 > 0x10001 || (unint64_t v7 = *(unsigned int *)(v5 + 4), (v7 & 0x80000000) != 0) || (int)v7 > 0x10000)
  {
LABEL_121:
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v89 = -6;
    goto LABEL_122;
  }
  *a4 -= 20;
  unint64_t v9 = *(char **)(a2 + 24);
  bzero(v9, 0x80008uLL);
  memset(v100, 0, 236);
  uint64_t v12 = (unint64_t *)(v5 + 20);
  unsigned int v95 = v6;
  unint64_t v96 = 0x1000100000000;
  int v97 = v7;
  unint64_t v98 = 0x1000100000000;
  int v99 = v7;
  unint64_t v13 = (unint64_t)(v9 + 524296);
  unint64_t v14 = *a4;
  if (v6 <= v7)
  {
    unint64_t v15 = 0;
    unint64_t v17 = v7 + 1;
    v18.i64[0] = 0x3F003F003F003FLL;
    v18.i64[1] = 0x3F003F003F003FLL;
    v19.i64[0] = 0x3B3B3B3B3B3B3B3BLL;
    v19.i64[1] = 0x3B3B3B3B3B3B3B3BLL;
    uint64_t v20 = v6;
    unint64_t v21 = v6;
    unint64_t v16 = (unint64_t)v9;
    while (1)
    {
      if (v14 < 0xD) {
        goto LABEL_97;
      }
      v10.i64[0] = *v12;
      v11.i64[0] = *(unint64_t *)((char *)v12 + 5);
      int8x16_t v22 = (int8x16_t)vshlq_u64((uint64x2_t)vqtbl2q_s8(*(int8x16x2_t *)v10.i8, (int8x16_t)xmmword_228F61F00), (uint64x2_t)vdupq_n_s64(v15));
      uint16x8_t v11 = (uint16x8_t)vandq_s8((int8x16_t)vshlq_u16((uint16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_228F61F20), (uint16x8_t)xmmword_228F61F30), v18);
      uint8x8_t v23 = vqmovn_u16((uint16x8_t)vandq_s8((int8x16_t)vshlq_u16((uint16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_228F61F10), (uint16x8_t)xmmword_228F61F30), v18));
      uint8x16_t v10 = vqmovn_high_u16(v23, v11);
      uint8x16_t v24 = vcgtq_u8(v19, v10);
      int16x8_t v25 = (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vmovl_s8(*(int8x8_t *)v24.i8), (int8x16_t)xmmword_228F61F50), vandq_s8((int8x16_t)vmovl_high_u8(v24), (int8x16_t)xmmword_228F61F40));
      v25.i16[0] = vaddvq_s16(v25);
      unint64_t v26 = v17 - v21;
      BOOL v27 = v25.i16[0] == -1 && v26 >= 0x10;
      if (v27)
      {
        uint64_t v43 = 0;
        uint64_t v44 = &v9[8 * v20];
        uint16x8_t v45 = vmovl_u8(v23);
        uint32x4_t v46 = vmovl_u16(*(uint16x4_t *)v45.i8);
        *(void *)&long long v47 = v46.u32[0];
        *((void *)&v47 + 1) = v46.u32[1];
        long long v48 = v47;
        *(void *)&long long v47 = v46.u32[2];
        *((void *)&v47 + 1) = v46.u32[3];
        long long v49 = v47;
        uint32x4_t v50 = vmovl_high_u16(v45);
        *(void *)&long long v47 = v50.u32[0];
        *((void *)&v47 + 1) = v50.u32[1];
        long long v51 = v47;
        *(void *)&long long v47 = v50.u32[2];
        *((void *)&v47 + 1) = v50.u32[3];
        *((_OWORD *)v44 + 2) = v51;
        *((_OWORD *)v44 + 3) = v47;
        *(_OWORD *)uint64_t v44 = v48;
        *((_OWORD *)v44 + 1) = v49;
        uint16x8_t v52 = vmovl_u8(vqmovn_u16(v11));
        uint32x4_t v53 = vmovl_u16(*(uint16x4_t *)v52.i8);
        *(void *)&long long v47 = v53.u32[0];
        *((void *)&v47 + 1) = v53.u32[1];
        long long v54 = v47;
        *(void *)&long long v47 = v53.u32[2];
        *((void *)&v47 + 1) = v53.u32[3];
        long long v55 = v47;
        uint16x8_t v11 = (uint16x8_t)vmovl_high_u16(v52);
        *(void *)&long long v47 = v11.u32[0];
        *((void *)&v47 + 1) = v11.u32[1];
        long long v56 = v47;
        *(void *)&long long v47 = v11.u32[2];
        v11.i64[1] = v11.u32[3];
        *((void *)&v47 + 1) = v11.i64[1];
        *((_OWORD *)v44 + 6) = v56;
        *((_OWORD *)v44 + 7) = v47;
        *((_OWORD *)v44 + 4) = v54;
        *((_OWORD *)v44 + 5) = v55;
        uint64_t v32 = v20 + 16;
        unint64_t v14 = *a4 - 12;
        if (*a4 < 0xC) {
          unint64_t v14 = 0;
        }
        *a4 = v14;
        do
        {
          uint8x16_t v91 = v10;
          ++*((_DWORD *)v100 + *(unsigned __int8 *)((unint64_t)&v91 | v43++ & 0xF));
        }
        while (v43 != 16);
        v21 += 16;
        uint64_t v12 = (unint64_t *)((char *)v12 + 12);
        if (v13 >= (unint64_t)v44) {
          int v57 = &v9[8 * v20];
        }
        else {
          int v57 = (char *)v13;
        }
        unint64_t v58 = (unint64_t)&v9[8 * v20 + 120];
        if (v16 > v58) {
          unint64_t v58 = v16;
        }
        if (v20 > 32753)
        {
          unint64_t v13 = (unint64_t)(v9 + 262152);
          unint64_t v58 = (unint64_t)(v9 + 0x40000);
        }
        if (v20 <= 0x8000) {
          unint64_t v16 = v58;
        }
        else {
          unint64_t v13 = (unint64_t)v57;
        }
      }
      else
      {
        unint64_t v28 = 0;
        if (v26 >= 0x10) {
          unint64_t v29 = 16;
        }
        else {
          unint64_t v29 = v17 - v21;
        }
        BOOL v30 = v21 > v7;
        if (v29 && v21 <= v7)
        {
          unint64_t v28 = 0;
          __int32 v31 = v25.i32[0] << 16;
          uint64_t v32 = v20;
          while (1)
          {
            uint8x16_t v94 = v10;
            if (*(unsigned __int8 *)((unint64_t)&v94 | v28 & 0xF) > 0x3Eu) {
              break;
            }
            unsigned int v33 = __clz(~v31);
            if (v33 >= (int)v29 - (int)v28) {
              unsigned int v33 = v29 - v28;
            }
            LODWORD(v34) = v17 - v21;
            if (v33 >= (int)v17 - (int)v21) {
              uint64_t v34 = v34;
            }
            else {
              uint64_t v34 = v33;
            }
            if (v34)
            {
              uint64_t v35 = v34;
              unint64_t v36 = v28;
              unint64_t v37 = &v9[8 * v32];
              uint64_t v38 = v34;
              do
              {
                uint8x16_t v93 = v10;
                uint64_t v39 = *(unsigned __int8 *)((unint64_t)&v93 | v36 & 0xF);
                ++*((_DWORD *)v100 + v39);
                *(void *)unint64_t v37 = v39;
                v37 += 8;
                ++v36;
                --v38;
              }
              while (v38);
              if (v32 <= 0x8000)
              {
                uint64_t v42 = v32 + (v34 - 1);
                if (v16 <= (unint64_t)&v9[8 * v42]) {
                  unint64_t v16 = (unint64_t)&v9[8 * v42];
                }
                if (v42 > 0x8000)
                {
                  unint64_t v13 = (unint64_t)(v9 + 262152);
                  unint64_t v16 = (unint64_t)(v9 + 0x40000);
                }
              }
              else if (v13 >= (unint64_t)&v9[8 * v32])
              {
                unint64_t v13 = (unint64_t)&v9[8 * v32];
              }
              uint64_t v41 = (6 * v34);
              uint64_t v40 = v34;
            }
            else
            {
              uint64_t v35 = *(unsigned __int8 *)((unint64_t)&v94 | v28 & 0xF) - 57;
              uint64_t v40 = 1;
              uint64_t v41 = 6;
              LOBYTE(v34) = 1;
            }
            v28 += v40;
            v15 += v41;
            v21 += v35;
            v32 += v35;
            BOOL v30 = v21 > v7;
            if (v28 < v29)
            {
              v31 <<= v34;
              if (v21 <= v7) {
                continue;
              }
            }
            goto LABEL_56;
          }
          uint64_t v12 = (unint64_t *)((char *)v12 + (v15 >> 3));
          BOOL v27 = v14 >= v15 >> 3;
          v14 -= v15 >> 3;
          v15 &= 7u;
          if (!v27) {
            unint64_t v14 = 0;
          }
          *a4 = v14;
          if (v29 > v28) {
            goto LABEL_64;
          }
        }
        else
        {
          uint64_t v32 = v20;
LABEL_56:
          uint64_t v12 = (unint64_t *)((char *)v12 + (v15 >> 3));
          BOOL v27 = v14 >= v15 >> 3;
          v14 -= v15 >> 3;
          v15 &= 7u;
          if (!v27) {
            unint64_t v14 = 0;
          }
          *a4 = v14;
          if (v28 < v29)
          {
            if (v30) {
              goto LABEL_97;
            }
LABEL_64:
            uint8x16_t v92 = v10;
            if (*(unsigned char *)((unint64_t)&v92 | v28 & 0xF) != 63) {
              goto LABEL_121;
            }
            if (v21 + 1044 <= v17 && v14 >= 8)
            {
              do
              {
                if (bswap64(*v12) << v15 < 0xFFFFFFFFFFFFFF00) {
                  break;
                }
                v32 += 1044;
                v14 -= 7;
                *a4 = v14;
                uint64_t v12 = (unint64_t *)((char *)v12 + 7);
                unint64_t v59 = v21 + 2088;
                v21 += 1044;
                if (v59 > v17) {
                  break;
                }
              }
              while (v14 > 7);
            }
            while (v21 <= v7 && v15 + 14 <= 8 * v14)
            {
              unint64_t v65 = v15 + 6;
              unint64_t v66 = (0xFFu >> v15) & *(unsigned __int8 *)v12;
              if (v14 >= (v15 + 6) >> 3) {
                unint64_t v67 = v14 - ((v15 + 6) >> 3);
              }
              else {
                unint64_t v67 = 0;
              }
              *a4 = v67;
              if (v15 < 3)
              {
                LOBYTE(v69) = v15 + 6;
              }
              else
              {
                uint64_t v68 = (unsigned __int8 *)v12 + 1;
                unint64_t v69 = v15 + 6;
                do
                {
                  unsigned int v70 = *v68++;
                  unint64_t v66 = v70 | (v66 << 8);
                  v69 -= 8;
                }
                while (v69 > 8);
              }
              if (v66 >> (8 - v69) != 63 || v14 <= v65 >> 3)
              {
                *a4 = v14;
                break;
              }
              unint64_t v15 = v65 & 7;
              uint64_t v12 = (unint64_t *)((char *)v12 + (v65 >> 3));
              uint64_t v60 = v65 | 8;
              if ((v65 | 8) <= 8 * v67)
              {
                int v62 = *(unsigned __int8 *)v12;
                uint64_t v12 = (unint64_t *)((char *)v12 + 1);
                unint64_t v63 = (0xFFu >> v15) & v62;
                unint64_t v14 = v67 - 1;
                if (!v67) {
                  unint64_t v14 = 0;
                }
                *a4 = v14;
                if (v60 != 8)
                {
                  unint64_t v63 = *(unsigned __int8 *)v12 | (v63 << 8);
                  LOBYTE(v60) = v65 & 7;
                }
                unint64_t v61 = v63 >> (8 - v60);
              }
              else
              {
                unint64_t v14 = 0;
                unint64_t v61 = 0;
                *a4 = 0;
              }
              unint64_t v64 = v61 + 6;
              if (v61 + 6 >= v17 - v21) {
                unint64_t v64 = v17 - v21;
              }
              v21 += v64;
              v32 += v64;
            }
          }
        }
      }
      uint64_t v20 = v32;
      if (v21 > v7) {
        goto LABEL_97;
      }
    }
  }
  unint64_t v15 = 0;
  unint64_t v16 = (unint64_t)v9;
LABEL_97:
  LODWORD(v72) = 0;
  unsigned int v73 = 0;
  unint64_t v74 = v15 + 7;
  *a3 = (unsigned int *)((char *)v12 + ((v15 + 7) >> 3));
  unint64_t v75 = (v16 - (unint64_t)v9) >> 3;
  unint64_t v76 = (v13 - (unint64_t)v9) >> 3;
  unint64_t v96 = __PAIR64__(v76, v75);
  unint64_t v77 = v14 - (v74 >> 3);
  if (v14 < v74 >> 3) {
    unint64_t v77 = 0;
  }
  *a4 = v77;
  unsigned int v78 = 58;
  do
  {
    if (v72) {
      goto LABEL_121;
    }
    int v79 = *((_DWORD *)v100 + v78);
    *((_DWORD *)v100 + v78) = v72 >> 1;
    unint64_t v72 = v79 + (v72 >> 1);
    if (1 << v78 < v72) {
      goto LABEL_121;
    }
    if (v73 <= v78) {
      unsigned int v80 = v78;
    }
    else {
      unsigned int v80 = v73;
    }
    if (v4 >= v78) {
      unsigned int v81 = v78;
    }
    else {
      unsigned int v81 = v4;
    }
    if (v79)
    {
      unsigned int v4 = v81;
      unsigned int v73 = v80;
    }
    --v78;
  }
  while (v78);
  unint64_t v98 = __PAIR64__(v4, v73);
  if (v6 <= v75)
  {
    do
    {
      uint64_t v82 = *(void *)&v9[8 * v6];
      int v83 = v6;
      if (v82)
      {
        int v84 = *((_DWORD *)v100 + v82);
        *((_DWORD *)v100 + v82) = v84 + 1;
        *(void *)&v9[8 * v6] = v82 | (v84 << 6);
      }
      LODWORD(v6) = v6 + 1;
    }
    while (v83 + 1 <= v75);
  }
  for (; v76 <= v7; LODWORD(v76) = v76 + 1)
  {
    uint64_t v85 = *(void *)&v9[8 * v76];
    if (v85)
    {
      int v86 = *((_DWORD *)v100 + v85);
      *((_DWORD *)v100 + v85) = v86 + 1;
      *(void *)&v9[8 * v76] = v85 | (v86 << 6);
    }
  }
  if (v73 < v4) {
    goto LABEL_121;
  }
  return AllocateHuffmanTable(&v95, (uint64_t)v9);
}

void TileDecoder_PIZ::HuffmanDecode(uint64_t a1, unint64_t *a2, uint64_t *a3, char *a4, uint64_t a5, void *a6)
{
  if (!*a6) {
    return;
  }
  unint64_t v7 = &a4[*a6];
  uint64_t v8 = *a3;
  unint64_t v9 = (unint64_t *)((char *)a2 + *a3);
  unsigned int v10 = *(_DWORD *)(a5 + 36);
  if (v10)
  {
    if (v8 < 8)
    {
      if ((v8 & 0x8000000000000000) == 0)
      {
        unint64_t v11 = 0;
        if (v8)
        {
          uint64_t v14 = 56;
          uint64_t v15 = *a3;
          unint64_t v16 = a2;
          do
          {
            unsigned int v17 = *(unsigned __int8 *)v16;
            unint64_t v16 = (unint64_t *)((char *)v16 + 1);
            v11 |= (unint64_t)v17 << v14;
            v14 -= 8;
            --v15;
          }
          while (v15);
        }
        LODWORD(v12) = (8 * v8) & ~((int)((unint64_t)v8 >> 29) >> 31);
        unint64_t v13 = (unint64_t *)((char *)a2 + *a3);
        goto LABEL_13;
      }
      LODWORD(v12) = 0;
      unint64_t v11 = 0;
    }
    else
    {
      unint64_t v11 = bswap64(*a2);
      LODWORD(v12) = 64;
    }
    unint64_t v13 = a2;
  }
  else
  {
    LODWORD(v12) = 0;
    unint64_t v11 = 0;
    unint64_t v13 = a2 - 1;
  }
LABEL_13:
  if (v7 <= a4) {
    goto LABEL_93;
  }
  unint64_t v67 = a2;
  uint64_t v68 = a3;
  char v18 = 64 - v10;
  unint64_t v69 = a6;
  while (1)
  {
    unint64_t v19 = v11 >> v18;
    unsigned int v20 = *(unsigned __int8 *)(a5 + (v11 >> v18) + 40);
    unsigned int v21 = v10 - (v20 & 0xF);
    if (v12 < v21) {
      unsigned int v21 = v12;
    }
    LODWORD(v12) = v12 - v21;
    v11 <<= v21;
    if ((v20 & 0xF0) == 0x20)
    {
      uint64_t v22 = a5;
      do
      {
        uint64_t v22 = *(void *)(*(void *)v22 + 8 * *(unsigned int *)(*(void *)(v22 + 8) + 4 * v19));
        unsigned int v23 = *(_DWORD *)(v22 + 36);
        if (v12 < v23)
        {
          unint64_t v24 = (64 - v12);
          uint64_t v25 = (64 - (_BYTE)v12) & 7;
          unint64_t v13 = (unint64_t *)((char *)v13 + (v24 >> 3));
          unint64_t v26 = (char *)v9 - (char *)v13;
          if ((char *)v9 - (char *)v13 < 8)
          {
            uint64_t v27 = 8 * v26;
            if ((uint64_t)(8 * v26) >= v12)
            {
              if (v9 == v13)
              {
                uint64_t v28 = 0;
              }
              else
              {
                uint64_t v28 = 0;
                if (v26 <= 1) {
                  unint64_t v26 = 1;
                }
                uint64_t v29 = 56;
                do
                {
                  unsigned int v30 = *(unsigned __int8 *)v13;
                  unint64_t v13 = (unint64_t *)((char *)v13 + 1);
                  v28 |= (unint64_t)v30 << v29;
                  v29 -= 8;
                  --v26;
                }
                while (v26);
              }
              unint64_t v11 = v28 << v25;
              LODWORD(v12) = (v27 - v25) & ~((v27 - v25) >> 63);
              unint64_t v13 = v9;
            }
          }
          else
          {
            unint64_t v11 = bswap64(*v13) << v25;
            LODWORD(v12) = (v24 & 0xFFFFFFF8) + v12;
          }
        }
        unint64_t v19 = v11 >> -(char)v23;
        unsigned int v20 = *(unsigned __int8 *)(v22 + v19 + 40);
        unsigned int v31 = v23 - (v20 & 0xF);
        if (v12 < v31) {
          unsigned int v31 = v12;
        }
        LODWORD(v12) = v12 - v31;
        v11 <<= v31;
      }
      while ((v20 & 0xF0) == 0x20);
    }
    else
    {
      uint64_t v22 = a5;
    }
    unint64_t v32 = v7 - a4;
    if ((v20 & 0x30) != 0x20)
    {
      if ((v20 & 0x20) == 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = -6;
      }
      if (v12 <= 7)
      {
        unint64_t v36 = (64 - v12);
        uint64_t v37 = (64 - (_BYTE)v12) & 7;
        unint64_t v13 = (unint64_t *)((char *)v13 + (v36 >> 3));
        unint64_t v38 = (char *)v9 - (char *)v13;
        if ((char *)v9 - (char *)v13 < 8)
        {
          uint64_t v43 = 8 * v38;
          if ((uint64_t)(8 * v38) >= v12)
          {
            if (v9 == v13)
            {
              uint64_t v44 = 0;
            }
            else
            {
              uint64_t v44 = 0;
              if (v38 <= 1) {
                unint64_t v38 = 1;
              }
              uint64_t v45 = 56;
              do
              {
                unsigned int v46 = *(unsigned __int8 *)v13;
                unint64_t v13 = (unint64_t *)((char *)v13 + 1);
                v44 |= (unint64_t)v46 << v45;
                v45 -= 8;
                --v38;
              }
              while (v38);
            }
            unint64_t v11 = v44 << v37;
            LODWORD(v12) = (v43 - v37) & ~((v43 - v37) >> 63);
            unint64_t v13 = v9;
          }
        }
        else
        {
          unint64_t v11 = bswap64(*v13) << v37;
          LODWORD(v12) = (v36 & 0xFFFFFFF8) + v12;
        }
      }
      if (v12 >= 8) {
        int v48 = 8;
      }
      else {
        int v48 = v12;
      }
      uint64_t v12 = (v12 - v48);
      unint64_t v49 = v11 << v48;
      if (v12 < v10)
      {
        unint64_t v50 = (64 - v12);
        uint64_t v51 = (64 - (_BYTE)v12) & 7;
        unint64_t v13 = (unint64_t *)((char *)v13 + (v50 >> 3));
        unint64_t v52 = (char *)v9 - (char *)v13;
        if ((char *)v9 - (char *)v13 < 8)
        {
          uint64_t v53 = 8 * v52;
          if ((uint64_t)(8 * v52) >= v12)
          {
            if (v9 == v13)
            {
              uint64_t v54 = 0;
            }
            else
            {
              uint64_t v54 = 0;
              if (v52 <= 1) {
                unint64_t v52 = 1;
              }
              uint64_t v55 = 56;
              do
              {
                unsigned int v56 = *(unsigned __int8 *)v13;
                unint64_t v13 = (unint64_t *)((char *)v13 + 1);
                v54 |= (unint64_t)v56 << v55;
                v55 -= 8;
                --v52;
              }
              while (v52);
            }
            unint64_t v49 = v54 << v51;
            LODWORD(v12) = (v53 - v51) & ~((v53 - v51) >> 63);
            unint64_t v13 = v9;
          }
        }
        else
        {
          unint64_t v49 = bswap64(*v13) << v51;
          LODWORD(v12) = (v50 & 0xFFFFFFF8) + v12;
        }
      }
      int v57 = (const __int16 *)(*(void *)(v22 + 8) + 4 * v19);
      if (v20 >= 0x40) {
        unint64_t v58 = a4;
      }
      else {
        unint64_t v58 = a4 - 2;
      }
      if (v20 >= 0x40)
      {
        size_t v59 = v7 - a4;
      }
      else
      {
        int v57 = (const __int16 *)(a4 - 2);
        size_t v59 = v32 + 2;
      }
      int16x8_t __pattern16 = 0u;
      int16x8_t v60 = vld1q_dup_s16(v57);
      int16x8_t __pattern16 = v60;
      unint64_t v61 = ((v11 >> 55) & 0x1FE) + 2;
      if (v61 >= v59) {
        size_t v62 = v59;
      }
      else {
        size_t v62 = v61;
      }
      memset_pattern16(v58, &__pattern16, v62);
      a4 = &v58[v62];
      unint64_t v11 = v49;
      char v18 = 64 - v10;
      goto LABEL_89;
    }
    if (v12 < v10)
    {
      unint64_t v33 = (64 - v12);
      uint64_t v34 = (64 - (_BYTE)v12) & 7;
      unint64_t v13 = (unint64_t *)((char *)v13 + (v33 >> 3));
      unint64_t v35 = (char *)v9 - (char *)v13;
      if ((char *)v9 - (char *)v13 < 8)
      {
        uint64_t v39 = 8 * v35;
        if ((uint64_t)(8 * v35) >= v12)
        {
          if (v9 == v13)
          {
            uint64_t v40 = 0;
          }
          else
          {
            uint64_t v40 = 0;
            if (v35 <= 1) {
              unint64_t v35 = 1;
            }
            uint64_t v41 = 56;
            do
            {
              unsigned int v42 = *(unsigned __int8 *)v13;
              unint64_t v13 = (unint64_t *)((char *)v13 + 1);
              v40 |= (unint64_t)v42 << v41;
              v41 -= 8;
              --v35;
            }
            while (v35);
          }
          unint64_t v11 = v40 << v34;
          LODWORD(v12) = (v39 - v34) & ~((v39 - v34) >> 63);
          unint64_t v13 = v9;
        }
      }
      else
      {
        unint64_t v11 = bswap64(*v13) << v34;
        LODWORD(v12) = (v33 & 0xFFFFFFF8) + v12;
      }
    }
    int v47 = *(_DWORD *)(*(void *)(v22 + 8) + 4 * v19);
    if (v32 < 4) {
      break;
    }
    *(_DWORD *)a4 = v47;
    a4 += 2 * (v20 >> 6);
LABEL_89:
    if (a4 >= v7) {
      goto LABEL_92;
    }
  }
  *(_WORD *)a4 = v47;
  a4 = v7;
LABEL_92:
  a3 = v68;
  a6 = v69;
  uint64_t v8 = *v68;
  a2 = v67;
LABEL_93:
  unint64_t v63 = (char *)v13 + (((unint64_t)(64 - v12) + 7) >> 3) - (char *)a2;
  BOOL v64 = v8 >= v63;
  uint64_t v65 = v8 - v63;
  if (!v64) {
    uint64_t v65 = 0;
  }
  *a3 = v65;
  *a6 += a4 - v7;
}

void DestroyHuffmanDecodeTable(void **a1)
{
  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      if (a1[2])
      {
        unint64_t v3 = 0;
        do
          DestroyHuffmanDecodeTable(*((void *)*a1 + v3++));
        while (v3 < (unint64_t)a1[2]);
        v2 = *a1;
      }
      free(v2);
    }
    free(a1);
  }
}

uint64_t AllocateHuffmanTable(unsigned int *a1, uint64_t a2)
{
  unsigned int v4 = a1[4] << (a2 != 0);
  if (v4 >= 0xE) {
    unint64_t v5 = 14;
  }
  else {
    unint64_t v5 = v4;
  }
  uint64_t v6 = 1 << v5;
  uint64_t v7 = ((1 << v5) + 3) & 0x1FFFC;
  uint64_t v8 = malloc_type_calloc(1uLL, (4 << v5) + v7 + 40, 0x9FE17992uLL);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    unsigned int v10 = (char *)(v8 + 10);
    v8[8] = a1[4];
    v8[9] = v5;
    *(void *)uint64_t v8 = 0;
    *((void *)v8 + 1) = (char *)v8 + v7 + 40;
    *((void *)v8 + 2) = 0;
    *((void *)v8 + 3) = 0;
    memset(v8 + 10, 15, ((1 << v5) + 3) & 0x1FFFC);
    if (a2)
    {
      unint64_t v12 = *a1;
      unint64_t v11 = a1[1];
      if (v12 <= v11)
      {
        do
        {
          if (v12 != a1[6] && (*(void *)(a2 + 8 * v12) & 0x3F) != 0)
          {
            AddHuffmanTableEntry(v9, *(void *)(a2 + 8 * v12) >> 6, *(void *)(a2 + 8 * v12) & 0x3FLL, (unsigned __int16)v12, a1);
            unint64_t v11 = a1[1];
          }
        }
        while (v12++ < v11);
      }
      unint64_t v15 = a1[2];
      unint64_t v14 = a1[3];
      while (v15 < v14)
      {
        if (v15 != a1[6] && (*(void *)(a2 + 8 * v15) & 0x3F) != 0)
        {
          AddHuffmanTableEntry(v9, *(void *)(a2 + 8 * v15) >> 6, *(void *)(a2 + 8 * v15) & 0x3FLL, (unsigned __int16)v15, a1);
          unint64_t v14 = a1[3];
        }
        ++v15;
      }
      unint64_t v16 = *(void *)(a2 + 8 * a1[6]) & 0x3FLL;
      unint64_t v17 = *(void *)(a2 + 8 * a1[6]) >> 6;
      if (v16 <= v5)
      {
        uint64_t v19 = v9;
        LODWORD(v18) = v5;
      }
      else
      {
        unint64_t v18 = v5;
        uint64_t v19 = v9;
        do
        {
          v16 -= v18;
          unint64_t v20 = v17 >> v16;
          v17 &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v16;
          uint64_t v19 = *(void *)(*(void *)v19 + 8 * *(unsigned int *)(*(void *)(v19 + 8) + 4 * v20));
          unint64_t v18 = *(unsigned int *)(v19 + 36);
        }
        while (v16 > v18);
      }
      char v21 = v18 - v16;
      uint64_t v22 = v17 << (v18 - v16);
      memset((void *)(v19 + v22 + 40), (v18 - v16) & 0xF | 0x30, 1 << (v18 - v16));
      int __pattern4 = -559038737;
      memset_pattern4((void *)(*(void *)(v19 + 8) + 4 * v22), &__pattern4, 4 << v21);
      if (v5 >= 2 * a1[5])
      {
        unsigned int v23 = (unsigned __int8 *)malloc_type_malloc(1 << v5, 0x100004077774924uLL);
        if (v23)
        {
          unint64_t v24 = (char *)v23;
          memcpy(v23, (const void *)(v9 + 40), 1 << v5);
        }
        else
        {
          unint64_t v24 = (char *)(v9 + 40);
        }
        uint64_t v25 = 0;
        uint64_t v26 = v9 + 40;
        do
        {
          char v27 = *(unsigned char *)(v26 + v25);
          if ((v27 & 0xC0) == 0x40)
          {
            uint64_t v28 = (v25 << (v5 - (v27 & 0xFu))) & (v6 - 1);
            unsigned int v29 = v24[v28];
            if ((v29 & 0x20) != 0 && v5 <= (v29 & 0xF) + (v27 & 0xF))
            {
              if (v29 > 0x3F)
              {
                *(_WORD *)(*(void *)(v9 + 8) + 4 * v25 + 2) = *(_WORD *)(*(void *)(v9 + 8) + 4 * v28);
                char v30 = v27 & 0x3F | 0x80;
              }
              else
              {
                char v30 = v27 | 0x10;
              }
              *(unsigned char *)(v26 + v25) = v30 & 0xF0 | (v29 - v5 + v30) & 0xF;
            }
          }
          ++v25;
        }
        while (v6 != v25);
        if (v24 != v10) {
          free(v24);
        }
      }
    }
  }
  return v9;
}

void TileDecoder_PIZ::WaveDecode(int8x16_t a1, int16x8_t a2, int8x16_t a3, __n128 a4, __n128 a5, uint64_t a6, uint64_t a7, uint64_t a8, _WORD *a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int a13, uint64_t a14)
{
  if (a1.i32[0] >= (unsigned __int32)a1.i32[1]) {
    unint64_t v14 = a1.u32[1];
  }
  else {
    unint64_t v14 = a1.u32[0];
  }
  unint64_t v15 = 0x8000000000000000 >> __clz(v14);
  if (v14) {
    unint64_t v16 = v15;
  }
  else {
    unint64_t v16 = 0;
  }
  if (v16 >= 2)
  {
    if (a13 >> 14)
    {
      if (a14 == 2) {
        WaveDecodeRecurse<unsigned short,false>(a7, a9, 1uLL, v16, a1.u32[0], a1.u32[1], a8);
      }
      else {
        WaveDecodeRecurse<unsigned int,false>(a7, (uint64_t)a9, 1uLL, v16, a1.u32[0], a1.u32[1], a8, a1, *(double *)a2.i64, a3, a4);
      }
    }
    else if (a14 == 2)
    {
      WaveDecodeRecurse<unsigned short,true>(a7, a9, 1uLL, v16, a1.u32[0], a1.u32[1], a8);
    }
    else
    {
      WaveDecodeRecurse<unsigned int,true>(a7, (uint64_t)a9, 1uLL, v16, a1.u32[0], a1.u32[1], a8, (int16x8_t)a1, a2, (__n128)a3, a4.n128_f64[0], a5);
    }
  }
}

uint64_t WaveDecodeRecurse<unsigned short,true>(uint64_t result, _WORD *a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  unint64_t v9 = a5;
  unint64_t v11 = a2;
  uint64_t v12 = result;
  if (a3 <= a6)
  {
    unint64_t v13 = a7 * a3;
    unint64_t v14 = a3;
    unint64_t v15 = (int16x4x2_t *)result;
    unint64_t v16 = a2;
    do
    {
      if (a5 >= 0x20)
      {
        unint64_t v17 = 0;
        unint64_t v20 = v15;
        do
        {
          char v21 = v20 + 4;
          int16x8x2_t v104 = vld2q_s16((const __int16 *)v20);
          uint64_t v22 = (const __int16 *)&v20[2];
          int16x8x2_t v107 = vld2q_s16(v22);
          unsigned int v23 = (int16x8_t *)((char *)v15 + v17);
          unint64_t v24 = (int16x8_t *)((char *)v16 + v17);
          unint64_t v20 = v21;
          *unsigned int v23 = v104.val[0];
          v23[1] = v107.val[0];
          *unint64_t v24 = v104.val[1];
          v24[1] = v107.val[1];
          unint64_t v25 = v17 + 64;
          v17 += 32;
        }
        while (v25 <= a5);
        uint64_t v19 = (int16x4x2_t *)((char *)v15 + v17);
        unint64_t v18 = (_WORD *)((char *)v16 + v17);
      }
      else
      {
        unint64_t v17 = 0;
        unint64_t v18 = v16;
        uint64_t v19 = v15;
        unint64_t v20 = v15;
      }
      unint64_t v26 = v17 | 8;
      if ((v17 | 8) <= a5)
      {
        do
        {
          int16x4x2_t v100 = vld2_s16((const __int16 *)v20++);
          *uint64_t v19 = v100;
          uint64_t v19 = (int16x4x2_t *)((char *)v19 + 8);
          v18 += 4;
          v26 += 8;
        }
        while (v26 <= a5);
        unint64_t v17 = v26 - 8;
      }
      unint64_t v27 = v17 + 2;
      while (v27 <= a5)
      {
        v19->val[0].i16[0] = v20->val[0].i16[0];
        uint64_t v19 = (int16x4x2_t *)((char *)v19 + 2);
        *v18++ = v20->val[0].i16[1];
        unint64_t v20 = (int16x4x2_t *)((char *)v20 + 4);
        unint64_t v27 = v17 + 4;
        v17 += 2;
      }
      if (v17 < a5) {
        v19->val[0].i16[0] = v20->val[0].i16[0];
      }
      unint64_t v15 = (int16x4x2_t *)((char *)v15 + v13);
      unint64_t v16 = (_WORD *)((char *)v16 + v13);
      v14 += a3;
    }
    while (v14 <= a6);
  }
  unint64_t v28 = a5 >> 1;
  unint64_t v29 = 2 * a3;
  if (2 * a3 < a4) {
    unint64_t result = WaveDecodeRecurse<unsigned short,true>(result, &a2[v28], 2 * a3);
  }
  unint64_t v30 = v9 - (v9 >> 1);
  if (v29 <= a6)
  {
    unint64_t v31 = a7 * a3;
    unint64_t v32 = 2 * a3;
    unint64_t v33 = v29 * a7;
    do
    {
      uint64_t v34 = v12 + 2 * v30;
      unint64_t v35 = v31 + v34;
      unint64_t v36 = (__int16 *)(v12 + 2 * v9);
      uint64_t v37 = (__int16 *)((char *)v36 + v31);
      if (v9)
      {
        int v40 = *(unsigned __int16 *)(v34 - 2);
        v34 -= 2;
        int v39 = v40;
        int v41 = *(__int16 *)(v35 - 2);
        v35 -= 2;
        int v42 = v39 - (v41 >> 1);
        *--unint64_t v36 = v42 + v41;
        *--uint64_t v37 = v42;
        unint64_t v38 = v9 - 1;
      }
      else
      {
        unint64_t v38 = v9;
      }
      unint64_t result = (uint64_t)&v11[v28];
      unint64_t v43 = v31 + result;
      if ((v38 & 7) != 0)
      {
        uint64_t v44 = 0;
        do
        {
          int v45 = *(__int16 *)(v35 + v44 - 2);
          int v46 = *(__int16 *)(v43 + v44 - 2);
          int v47 = *(unsigned __int16 *)(v34 + v44 - 2) - (v45 >> 1);
          int v48 = *(unsigned __int16 *)(result + v44 - 2) - (v46 >> 1);
          LOWORD(v46) = v48 + v46;
          int v49 = v47 + v45 - ((__int16)v46 >> 1);
          int v50 = v47 - ((__int16)v48 >> 1);
          *(v36 - 2) = v49 + v46;
          v36 -= 2;
          v36[1] = v49;
          *(v37 - 2) = v50 + v48;
          v37 -= 2;
          v37[1] = v50;
          LOBYTE(v50) = v38 + v44 - 2;
          v44 -= 2;
        }
        while ((v50 & 7) != 0);
        v38 += v44;
        v34 += v44;
        v43 += v44;
        v35 += v44;
        result += v44;
      }
      if ((v38 & 0x1F) != 0)
      {
        uint64_t v51 = 0;
        do
        {
          int16x4_t v52 = *(int16x4_t *)(v35 + v51 - 8);
          int16x4_t v53 = *(int16x4_t *)(v43 + v51 - 8);
          int16x4_t v54 = vsub_s16(*(int16x4_t *)(v34 + v51 - 8), vshr_n_s16(v52, 1uLL));
          int16x4_t v55 = vsub_s16(*(int16x4_t *)(result + v51 - 8), vshr_n_s16(v53, 1uLL));
          int16x4_t v56 = vadd_s16(v55, v53);
          v103.val[1] = vsub_s16(vadd_s16(v54, v52), vshr_n_s16(v56, 1uLL));
          v103.val[0] = vadd_s16(v103.val[1], v56);
          v101.val[1] = vsub_s16(v54, vshr_n_s16(v55, 1uLL));
          v101.val[0] = vadd_s16(v101.val[1], v55);
          v36 -= 8;
          vst2_s16(v36, v103);
          v37 -= 8;
          vst2_s16(v37, v101);
          char v57 = v38 + v51 - 8;
          v51 -= 8;
        }
        while ((v57 & 0x1F) != 0);
        v38 += v51;
        v43 += v51;
        v35 += v51;
        result += v51;
        v34 += v51;
      }
      if (v38)
      {
        unint64_t v58 = v37 - 32;
        size_t v59 = v36 - 32;
        int16x8_t v60 = (int16x8_t *)(v43 - 32);
        unint64_t v61 = (int16x8_t *)(v35 - 32);
        size_t v62 = (int16x8_t *)(result - 32);
        unint64_t v63 = (int16x8_t *)(v34 - 32);
        do
        {
          int16x8_t v65 = *v63;
          int16x8_t v64 = v63[1];
          v63 -= 2;
          int16x8_t v66 = *v62;
          int16x8_t v67 = v62[1];
          v62 -= 2;
          int16x8_t v68 = *v61;
          int16x8_t v69 = v61[1];
          v61 -= 2;
          int16x8_t v71 = *v60;
          int16x8_t v70 = v60[1];
          v60 -= 2;
          int16x8_t v72 = vsubq_s16(v65, vshrq_n_s16(v68, 1uLL));
          int16x8_t v73 = vsubq_s16(v64, vshrq_n_s16(v69, 1uLL));
          int16x8_t v74 = vsubq_s16(v67, vshrq_n_s16(v70, 1uLL));
          int16x8_t v75 = vsubq_s16(v66, vshrq_n_s16(v71, 1uLL));
          int16x8_t v76 = vaddq_s16(v75, v71);
          int16x8_t v77 = vaddq_s16(v74, v70);
          v110.val[1] = vsubq_s16(vaddq_s16(v72, v68), vshrq_n_s16(v76, 1uLL));
          v108.val[1] = vsubq_s16(vaddq_s16(v73, v69), vshrq_n_s16(v77, 1uLL));
          v108.val[0] = vaddq_s16(v108.val[1], v77);
          v110.val[0] = vaddq_s16(v110.val[1], v76);
          v111.val[1] = vsubq_s16(v72, vshrq_n_s16(v75, 1uLL));
          unint64_t result = (uint64_t)(v59 - 32);
          vst2q_s16(v59, v110);
          unsigned int v78 = v59 + 16;
          v105.val[1] = vsubq_s16(v73, vshrq_n_s16(v74, 1uLL));
          v111.val[0] = vaddq_s16(v111.val[1], v75);
          vst2q_s16(v78, v108);
          int v79 = v58 - 32;
          vst2q_s16(v58, v111);
          unsigned int v80 = v58 + 16;
          v105.val[0] = vaddq_s16(v105.val[1], v74);
          vst2q_s16(v80, v105);
          size_t v59 = (__int16 *)result;
          unint64_t v58 = v79;
          v38 -= 32;
        }
        while (v38);
      }
      v12 += v33;
      unint64_t v11 = (_WORD *)((char *)v11 + v33);
      v32 += v29;
    }
    while (v32 <= a6);
  }
  if ((a6 & a3) != 0)
  {
    uint64_t v81 = v12 + 2 * v30;
    uint64_t v82 = (__int16 *)(v12 + 2 * v9);
    if (v9)
    {
      __int16 v83 = *(_WORD *)(v81 - 2);
      v81 -= 2;
      *--uint64_t v82 = v83;
      --v9;
    }
    int v84 = &v11[v28];
    if ((v9 & 7) != 0)
    {
      unint64_t v85 = 0;
      do
      {
        int v86 = (__int16)v84[v85 / 2 - 1];
        int v87 = *(unsigned __int16 *)(v81 + v85 - 2) - (v86 >> 1);
        *(v82 - 2) = v87 + v86;
        v82 -= 2;
        v82[1] = v87;
        LOBYTE(v87) = v9 + v85 - 2;
        v85 -= 2;
      }
      while ((v87 & 7) != 0);
      v9 += v85;
      int v84 = (_WORD *)((char *)v84 + v85);
      v81 += v85;
    }
    while ((v9 & 0x1F) != 0)
    {
      int16x4_t v88 = *(int16x4_t *)(v81 - 8);
      v81 -= 8;
      int16x4_t v89 = v88;
      int16x4_t v90 = *(int16x4_t *)(v84 - 4);
      v84 -= 4;
      v102.val[1] = vsub_s16(v89, vshr_n_s16(v90, 1uLL));
      v102.val[0] = vadd_s16(v102.val[1], v90);
      v82 -= 8;
      vst2_s16(v82, v102);
      v9 -= 8;
    }
    if (v9)
    {
      uint8x16_t v91 = v82 - 32;
      uint8x16_t v92 = (int16x8_t *)(v84 - 16);
      uint8x16_t v93 = (int16x8_t *)(v81 - 32);
      do
      {
        int16x8_t v95 = *v93;
        int16x8_t v94 = v93[1];
        v93 -= 2;
        int16x8_t v96 = *v92;
        int16x8_t v97 = v92[1];
        v92 -= 2;
        v109.val[1] = vsubq_s16(v95, vshrq_n_s16(v96, 1uLL));
        v109.val[0] = vaddq_s16(v109.val[1], v96);
        unint64_t v98 = v91 - 32;
        vst2q_s16(v91, v109);
        int v99 = v91 + 16;
        v106.val[1] = vsubq_s16(v94, vshrq_n_s16(v97, 1uLL));
        v106.val[0] = vaddq_s16(v106.val[1], v97);
        vst2q_s16(v99, v106);
        uint8x16_t v91 = v98;
        v9 -= 32;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t WaveDecodeRecurse<unsigned int,true>(uint64_t result, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, int16x8_t a8, int16x8_t a9, __n128 a10, double a11, __n128 a12)
{
  unint64_t v14 = a5;
  uint64_t v16 = a2;
  uint64_t v17 = result;
  if (a3 <= a6)
  {
    unint64_t v18 = a7 * a3;
    unint64_t v19 = a3;
    uint64_t v20 = result;
    uint64_t v21 = a2;
    do
    {
      if (a5 >= 0x20)
      {
        uint64_t v26 = 0;
        uint64_t v25 = v20;
        uint64_t v24 = v20;
        uint64_t v23 = v21;
        do
        {
          unint64_t v27 = (const float *)v25;
          *(float32x4x2_t *)a8.i8 = vld2q_f32(v27);
          v27 += 8;
          *(float32x4x2_t *)a10.n128_u64 = vld2q_f32(v27);
          unint64_t v28 = (const float *)(v25 + 64);
          *(float32x4x2_t *)a12.n128_u64 = vld2q_f32(v28);
          unint64_t v29 = (const float *)(v25 + 96);
          float32x4x2_t v128 = vld2q_f32(v29);
          v25 += 128;
          *(__n128 *)(v24 + 32) = a12;
          *(float32x4_t *)(v24 + 48) = v128.val[0];
          *(int16x8_t *)uint64_t v24 = a8;
          *(__n128 *)(v24 + 16) = a10;
          v24 += 64;
          *(_OWORD *)(v23 + 32) = v30;
          *(float32x4_t *)(v23 + 48) = v128.val[1];
          *(int16x8_t *)uint64_t v23 = a9;
          *(_OWORD *)(v23 + 16) = v31;
          v23 += 64;
          unint64_t v22 = v26 + 32;
          unint64_t v32 = v26 + 64;
          v26 += 32;
        }
        while (v32 <= a5);
      }
      else
      {
        unint64_t v22 = 0;
        uint64_t v23 = v21;
        uint64_t v24 = v20;
        uint64_t v25 = v20;
      }
      unint64_t v33 = v22 | 8;
      if ((v22 | 8) <= a5)
      {
        do
        {
          *(float32x4x2_t *)a8.i8 = vld2q_f32((const float *)v25);
          v25 += 32;
          *(int16x8_t *)uint64_t v24 = a8;
          v24 += 16;
          *(int16x8_t *)uint64_t v23 = a9;
          v23 += 16;
          v33 += 8;
        }
        while (v33 <= a5);
        unint64_t v22 = v33 - 8;
      }
      unint64_t v34 = v22 + 2;
      while (v34 <= a5)
      {
        *(_DWORD *)uint64_t v24 = *(_DWORD *)v25;
        v24 += 4;
        *(_DWORD *)uint64_t v23 = *(_DWORD *)(v25 + 4);
        v23 += 4;
        v25 += 8;
        unint64_t v34 = v22 + 4;
        v22 += 2;
      }
      if (v22 < a5) {
        *(_DWORD *)uint64_t v24 = *(_DWORD *)v25;
      }
      v20 += v18;
      v21 += v18;
      v19 += a3;
    }
    while (v19 <= a6);
  }
  unint64_t v35 = a5 >> 1;
  unint64_t v36 = 2 * a3;
  if (2 * a3 < a4) {
    unint64_t result = WaveDecodeRecurse<unsigned int,true>(result, a2 + 4 * v35, 2 * a3);
  }
  unint64_t v37 = v14 - (v14 >> 1);
  if (v36 <= a6)
  {
    unint64_t v38 = a7 * a3;
    unint64_t v39 = 2 * a3;
    unint64_t v40 = v36 * a7;
    do
    {
      uint64_t v41 = v17 + 4 * v37;
      unint64_t v42 = v38 + v41;
      unint64_t v43 = (float *)(v17 + 4 * v14);
      uint64_t v44 = (float *)((char *)v43 + v38);
      if (v14)
      {
        unsigned __int32 v46 = *(unsigned __int16 *)(v41 - 4);
        v41 -= 4;
        a8.i32[0] = v46;
        a8.i16[2] = *(_WORD *)(v41 + 2);
        unsigned __int32 v47 = *(unsigned __int16 *)(v42 - 4);
        v42 -= 4;
        a9.i32[0] = v47;
        a9.i16[2] = *(_WORD *)(v42 + 2);
        a10.n128_u64[0] = (unint64_t)vshr_n_s32(vshr_n_s32(vshl_n_s32(*(int32x2_t *)a9.i8, 0x10uLL), 0x10uLL), 1uLL);
        int16x4_t v48 = (int16x4_t)vsub_s32(*(int32x2_t *)a8.i8, (int32x2_t)a10.n128_u64[0]);
        *(int32x2_t *)a9.i8 = vadd_s32((int32x2_t)v48, *(int32x2_t *)a9.i8);
        int16x4_t v49 = vuzp1_s16(v48, v48);
        __int32 v50 = v49.i32[0];
        *(int16x4_t *)a8.i8 = vuzp1_s16(*(int16x4_t *)a9.i8, v49);
        *--unint64_t v43 = *(float *)a8.i32;
        *((_DWORD *)v44-- - 1) = v50;
        unint64_t v45 = v14 - 1;
      }
      else
      {
        unint64_t v45 = v14;
      }
      unint64_t result = v16 + 4 * v35;
      unint64_t v51 = v38 + result;
      if ((v45 & 7) != 0)
      {
        uint64_t v52 = 0;
        do
        {
          a8.i16[0] = *(_WORD *)(v41 + v52 - 4);
          a9.i16[0] = *(_WORD *)(result + v52 - 4);
          a8.i16[2] = *(_WORD *)(v41 + v52 - 2);
          a10.n128_u16[0] = *(_WORD *)(v42 + v52 - 4);
          a9.i16[2] = *(_WORD *)(result + v52 - 2);
          a10.n128_u16[2] = *(_WORD *)(v42 + v52 - 2);
          a12.n128_u16[0] = *(_WORD *)(v51 + v52 - 4);
          a12.n128_u16[2] = *(_WORD *)(v51 + v52 - 2);
          int16x4_t v53 = (int16x4_t)vsub_s32(*(int32x2_t *)a8.i8, vshr_n_s32(vshr_n_s32(vshl_n_s32((int32x2_t)a10.n128_u64[0], 0x10uLL), 0x10uLL), 1uLL));
          int32x2_t v54 = vsub_s32(*(int32x2_t *)a9.i8, vshr_n_s32(vshr_n_s32(vshl_n_s32((int32x2_t)a12.n128_u64[0], 0x10uLL), 0x10uLL), 1uLL));
          int32x2_t v55 = vadd_s32(v54, (int32x2_t)a12.n128_u64[0]);
          int16x4_t v56 = (int16x4_t)vsub_s32(vadd_s32((int32x2_t)v53, (int32x2_t)a10.n128_u64[0]), vshr_n_s32(vshr_n_s32(vshl_n_s32(v55, 0x10uLL), 0x10uLL), 1uLL));
          a12.n128_u64[0] = (unint64_t)vadd_s32((int32x2_t)v56, v55);
          int32x2_t v57 = (int32x2_t)vuzp1_s16(v56, v53);
          int16x4_t v58 = (int16x4_t)vsub_s32((int32x2_t)v53, vshr_n_s32(vshr_n_s32(vshl_n_s32(v54, 0x10uLL), 0x10uLL), 1uLL));
          int32x2_t v59 = (int32x2_t)vuzp1_s16((int16x4_t)a12.n128_u64[0], v58);
          int16x4_t v60 = (int16x4_t)vadd_s32((int32x2_t)v58, v54);
          int16x4_t v61 = vuzp1_s16(v58, v58);
          *(int16x4_t *)a9.i8 = vuzp1_s16(v60, v61);
          a10.n128_u64[0] = (unint64_t)vzip1_s32(v59, v57);
          *((void *)v43 - 1) = a10.n128_u64[0];
          v43 -= 2;
          *(int32x2_t *)a8.i8 = vzip1_s32(*(int32x2_t *)a9.i8, (int32x2_t)v61);
          *((void *)v44 - 1) = a8.i64[0];
          v44 -= 2;
          v45 -= 2;
          v52 -= 4;
        }
        while ((v45 & 7) != 0);
        v51 += v52;
        v42 += v52;
        result += v52;
        v41 += v52;
      }
      if ((v45 & 0x1F) != 0)
      {
        uint64_t v62 = 0;
        do
        {
          int16x8_t v63 = *(int16x8_t *)(v42 + v62 - 16);
          int16x8_t v64 = *(int16x8_t *)(v51 + v62 - 16);
          a8 = vsubq_s16(*(int16x8_t *)(v41 + v62 - 16), vshrq_n_s16(v63, 1uLL));
          a9 = vsubq_s16(*(int16x8_t *)(result + v62 - 16), vshrq_n_s16(v64, 1uLL));
          int16x8_t v65 = vaddq_s16(a9, v64);
          int16x8_t v66 = vsubq_s16(vaddq_s16(a8, v63), vshrq_n_s16(v65, 1uLL));
          a12 = (__n128)vaddq_s16(v66, v65);
          int16x8_t v67 = vsubq_s16(a8, vshrq_n_s16(a9, 1uLL));
          v43 -= 8;
          vst2q_f32(v43, *(float32x4x2_t *)a12.n128_u64);
          a10 = (__n128)vaddq_s16(v67, a9);
          v44 -= 8;
          vst2q_f32(v44, *(float32x4x2_t *)a10.n128_u64);
          v45 -= 8;
          v62 -= 16;
        }
        while ((v45 & 0x1F) != 0);
        v51 += v62;
        v42 += v62;
        result += v62;
        v41 += v62;
      }
      if (v45)
      {
        int16x8_t v68 = v44 - 32;
        int16x8_t v69 = v43 - 32;
        int16x8_t v70 = (int16x8_t *)(v51 - 64);
        int16x8_t v71 = (int16x8_t *)(v42 - 64);
        result -= 64;
        int16x8_t v72 = (int16x8_t *)(v41 - 64);
        do
        {
          int16x8_t v73 = v71[2];
          int16x8_t v74 = v71[3];
          int16x8_t v75 = *v71;
          int16x8_t v76 = v71[1];
          v71 -= 4;
          int16x8_t v77 = vsubq_s16(*v72, vshrq_n_s16(v75, 1uLL));
          int16x8_t v78 = vsubq_s16(v72[1], vshrq_n_s16(v76, 1uLL));
          int16x8_t v79 = vsubq_s16(v72[2], vshrq_n_s16(v73, 1uLL));
          a8 = vsubq_s16(v72[3], vshrq_n_s16(v74, 1uLL));
          int16x8_t v80 = vaddq_s16(v79, v73);
          int16x8_t v81 = v70[1];
          int16x8_t v83 = v70[2];
          int16x8_t v82 = v70[3];
          a9 = vsubq_s16(*(int16x8_t *)(result + 48), vshrq_n_s16(v82, 1uLL));
          int16x8_t v84 = vsubq_s16(*(int16x8_t *)(result + 32), vshrq_n_s16(v83, 1uLL));
          int16x8_t v85 = *(int16x8_t *)result;
          int16x8_t v86 = *(int16x8_t *)(result + 16);
          result -= 64;
          int16x8_t v87 = vsubq_s16(v86, vshrq_n_s16(v81, 1uLL));
          int16x8_t v88 = vsubq_s16(v85, vshrq_n_s16(*v70, 1uLL));
          int16x8_t v89 = vaddq_s16(v88, *v70);
          int16x8_t v90 = vaddq_s16(v87, v81);
          int16x8_t v91 = vaddq_s16(v84, v83);
          int16x8_t v92 = vaddq_s16(a9, v82);
          v133.val[1] = (float32x4_t)vsubq_s16(vaddq_s16(v77, v75), vshrq_n_s16(v89, 1uLL));
          v127.val[1] = (float32x4_t)vsubq_s16(vaddq_s16(v78, v76), vshrq_n_s16(v90, 1uLL));
          v132.val[1] = (float32x4_t)vsubq_s16(v80, vshrq_n_s16(v91, 1uLL));
          v134.val[1] = (float32x4_t)vsubq_s16(vaddq_s16(a8, v74), vshrq_n_s16(v92, 1uLL));
          v134.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v134.val[1], v92);
          v132.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v132.val[1], v91);
          v127.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v127.val[1], v90);
          v133.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v133.val[1], v89);
          uint8x16_t v93 = v69;
          vst2q_f32(v93, v133);
          v93 += 8;
          v130.val[1] = (float32x4_t)vsubq_s16(v77, vshrq_n_s16(v88, 1uLL));
          vst2q_f32(v93, v127);
          v127.val[1] = (float32x4_t)vsubq_s16(v78, vshrq_n_s16(v87, 1uLL));
          int16x8_t v94 = v69 + 16;
          vst2q_f32(v94, v132);
          v130.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v130.val[1], v88);
          int16x8_t v95 = v69 + 24;
          vst2q_f32(v95, v134);
          int16x8_t v96 = v68;
          vst2q_f32(v96, v130);
          v96 += 8;
          v124.val[1] = (float32x4_t)vsubq_s16(v79, vshrq_n_s16(v84, 1uLL));
          a12 = (__n128)vaddq_s16((int16x8_t)v127.val[1], v87);
          vst2q_f32(v96, *(float32x4x2_t *)a12.n128_u64);
          v124.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v124.val[1], v84);
          int16x8_t v97 = v68 + 16;
          vst2q_f32(v97, v124);
          unint64_t v98 = v68 + 24;
          v68 -= 32;
          v69 -= 32;
          v70 -= 4;
          v72 -= 4;
          v124.val[1] = (float32x4_t)vsubq_s16(a8, vshrq_n_s16(a9, 1uLL));
          a10 = (__n128)vaddq_s16((int16x8_t)v124.val[1], a9);
          vst2q_f32(v98, *(float32x4x2_t *)a10.n128_u64);
          v45 -= 32;
        }
        while (v45);
      }
      v17 += v40;
      v16 += v40;
      v39 += v36;
    }
    while (v39 <= a6);
  }
  if ((a6 & a3) != 0)
  {
    uint64_t v99 = v17 + 4 * v37;
    int16x4x2_t v100 = (float *)(v17 + 4 * v14);
    if (v14)
    {
      int v101 = *(_DWORD *)(v99 - 4);
      v99 -= 4;
      *((_DWORD *)v100-- - 1) = v101;
      --v14;
    }
    uint64_t v102 = v16 + 4 * v35;
    if ((v14 & 7) != 0)
    {
      uint64_t v103 = 0;
      do
      {
        a8.i16[0] = *(_WORD *)(v99 + v103 - 4);
        a8.i16[2] = *(_WORD *)(v99 + v103 - 2);
        a9.i16[0] = *(_WORD *)(v102 + v103 - 4);
        a9.i16[2] = *(_WORD *)(v102 + v103 - 2);
        int16x4_t v104 = (int16x4_t)vsub_s32(*(int32x2_t *)a8.i8, vshr_n_s32(vshr_n_s32(vshl_n_s32(*(int32x2_t *)a9.i8, 0x10uLL), 0x10uLL), 1uLL));
        int16x4_t v105 = (int16x4_t)vadd_s32((int32x2_t)v104, *(int32x2_t *)a9.i8);
        int16x4_t v106 = vuzp1_s16(v104, v104);
        *(int16x4_t *)a9.i8 = vuzp1_s16(v105, v106);
        *(int32x2_t *)a8.i8 = vzip1_s32(*(int32x2_t *)a9.i8, (int32x2_t)v106);
        *((void *)v100 - 1) = a8.i64[0];
        v100 -= 2;
        v14 -= 2;
        v103 -= 4;
      }
      while ((v14 & 7) != 0);
      v102 += v103;
      v99 += v103;
    }
    while ((v14 & 0x1F) != 0)
    {
      int16x8_t v107 = *(int16x8_t *)(v99 - 16);
      v99 -= 16;
      int16x8_t v108 = v107;
      int16x8_t v109 = *(int16x8_t *)(v102 - 16);
      v102 -= 16;
      v125.val[1] = (float32x4_t)vsubq_s16(v108, vshrq_n_s16(v109, 1uLL));
      v125.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v125.val[1], v109);
      v100 -= 8;
      vst2q_f32(v100, v125);
      v14 -= 8;
    }
    if (v14)
    {
      int16x8x2_t v110 = v100 - 32;
      int16x8x2_t v111 = (int16x8_t *)(v102 - 64);
      int8x16x2_t v112 = (int16x8_t *)(v99 - 64);
      do
      {
        int16x8_t v114 = v112[2];
        int16x8_t v113 = v112[3];
        int16x8_t v116 = *v112;
        int16x8_t v115 = v112[1];
        v112 -= 4;
        int16x8_t v117 = v111[1];
        int16x8_t v118 = v111[2];
        int16x8_t v119 = v111[3];
        v131.val[1] = (float32x4_t)vsubq_s16(v116, vshrq_n_s16(*v111, 1uLL));
        v126.val[1] = (float32x4_t)vsubq_s16(v115, vshrq_n_s16(v117, 1uLL));
        v129.val[1] = (float32x4_t)vsubq_s16(v114, vshrq_n_s16(v118, 1uLL));
        v131.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v131.val[1], *v111);
        int8x16_t v120 = v110;
        vst2q_f32(v120, v131);
        v120 += 8;
        v123.val[1] = (float32x4_t)vsubq_s16(v113, vshrq_n_s16(v119, 1uLL));
        v126.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v126.val[1], v117);
        vst2q_f32(v120, v126);
        v129.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v129.val[1], v118);
        int8x16_t v121 = v110 + 16;
        vst2q_f32(v121, v129);
        v123.val[0] = (float32x4_t)vaddq_s16((int16x8_t)v123.val[1], v119);
        int8x16_t v122 = v110 + 24;
        vst2q_f32(v122, v123);
        v110 -= 32;
        v111 -= 4;
        v14 -= 32;
      }
      while (v14);
    }
  }
  return result;
}

uint64_t WaveDecodeRecurse<unsigned short,false>(uint64_t result, _WORD *a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  unint64_t v9 = a5;
  unint64_t v11 = a2;
  uint64_t v12 = result;
  if (a3 <= a6)
  {
    unint64_t v13 = a7 * a3;
    unint64_t v14 = a3;
    unint64_t v15 = (int16x4x2_t *)result;
    uint64_t v16 = a2;
    do
    {
      if (a5 >= 0x20)
      {
        unint64_t v17 = 0;
        uint64_t v20 = v15;
        do
        {
          uint64_t v21 = v20 + 4;
          int16x8x2_t v106 = vld2q_s16((const __int16 *)v20);
          unint64_t v22 = (const __int16 *)&v20[2];
          int16x8x2_t v108 = vld2q_s16(v22);
          uint64_t v23 = (int16x8_t *)((char *)v15 + v17);
          uint64_t v24 = (int16x8_t *)((char *)v16 + v17);
          uint64_t v20 = v21;
          *uint64_t v23 = v106.val[0];
          v23[1] = v108.val[0];
          *uint64_t v24 = v106.val[1];
          v24[1] = v108.val[1];
          unint64_t v25 = v17 + 64;
          v17 += 32;
        }
        while (v25 <= a5);
        unint64_t v19 = (int16x4x2_t *)((char *)v15 + v17);
        unint64_t v18 = (_WORD *)((char *)v16 + v17);
      }
      else
      {
        unint64_t v17 = 0;
        unint64_t v18 = v16;
        unint64_t v19 = v15;
        uint64_t v20 = v15;
      }
      unint64_t v26 = v17 | 8;
      if ((v17 | 8) <= a5)
      {
        do
        {
          int16x4x2_t v102 = vld2_s16((const __int16 *)v20++);
          *unint64_t v19 = v102;
          unint64_t v19 = (int16x4x2_t *)((char *)v19 + 8);
          v18 += 4;
          v26 += 8;
        }
        while (v26 <= a5);
        unint64_t v17 = v26 - 8;
      }
      unint64_t v27 = v17 + 2;
      while (v27 <= a5)
      {
        v19->val[0].i16[0] = v20->val[0].i16[0];
        unint64_t v19 = (int16x4x2_t *)((char *)v19 + 2);
        *v18++ = v20->val[0].i16[1];
        uint64_t v20 = (int16x4x2_t *)((char *)v20 + 4);
        unint64_t v27 = v17 + 4;
        v17 += 2;
      }
      if (v17 < a5) {
        v19->val[0].i16[0] = v20->val[0].i16[0];
      }
      unint64_t v15 = (int16x4x2_t *)((char *)v15 + v13);
      uint64_t v16 = (_WORD *)((char *)v16 + v13);
      v14 += a3;
    }
    while (v14 <= a6);
  }
  unint64_t v28 = a5 >> 1;
  unint64_t v29 = 2 * a3;
  if (2 * a3 < a4) {
    unint64_t result = WaveDecodeRecurse<unsigned short,false>(result, &a2[v28], 2 * a3);
  }
  unint64_t v30 = v9 - (v9 >> 1);
  if (v29 <= a6)
  {
    unint64_t v31 = a7 * a3;
    v32.i64[0] = 0x8000800080008000;
    v32.i64[1] = 0x8000800080008000;
    unint64_t v33 = 2 * a3;
    unint64_t v34 = v29 * a7;
    do
    {
      uint64_t v35 = v12 + 2 * v30;
      unint64_t v36 = v31 + v35;
      unint64_t v37 = (__int16 *)(v12 + 2 * v9);
      unint64_t v38 = (__int16 *)((char *)v37 + v31);
      if (v9)
      {
        int v41 = *(unsigned __int16 *)(v35 - 2);
        v35 -= 2;
        int v40 = v41;
        unsigned int v42 = *(unsigned __int16 *)(v36 - 2);
        v36 -= 2;
        int v43 = v40 - (v42 >> 1);
        *--unint64_t v37 = (v43 + v42) ^ 0x8000;
        *--unint64_t v38 = v43;
        unint64_t v39 = v9 - 1;
      }
      else
      {
        unint64_t v39 = v9;
      }
      unint64_t result = (uint64_t)&v11[v28];
      unint64_t v44 = v31 + result;
      if ((v39 & 7) != 0)
      {
        uint64_t v45 = 0;
        do
        {
          unsigned int v46 = *(unsigned __int16 *)(v36 + v45 - 2);
          unsigned int v47 = *(unsigned __int16 *)(v44 + v45 - 2);
          int v48 = *(unsigned __int16 *)(v35 + v45 - 2) - (v46 >> 1);
          int v49 = *(unsigned __int16 *)(result + v45 - 2) - (v47 >> 1);
          LOWORD(v47) = (v49 + v47) ^ 0x8000;
          unsigned int v50 = ((v48 + v46) ^ 0xFFFF8000) - ((unsigned __int16)(v47 & 0xFFFE) >> 1);
          int v51 = v48 - ((unsigned __int16)(v49 & 0xFFFE) >> 1);
          *(v37 - 2) = (v50 + v47) ^ 0x8000;
          v37 -= 2;
          v37[1] = v50;
          *(v38 - 2) = (v51 + v49) ^ 0x8000;
          v38 -= 2;
          v38[1] = v51;
          LOBYTE(v51) = v39 + v45 - 2;
          v45 -= 2;
        }
        while ((v51 & 7) != 0);
        v39 += v45;
        v35 += v45;
        v44 += v45;
        v36 += v45;
        result += v45;
      }
      if ((v39 & 0x1F) != 0)
      {
        uint64_t v52 = 0;
        do
        {
          int16x4_t v53 = *(int16x4_t *)(v36 + v52 - 8);
          int16x4_t v54 = *(int16x4_t *)(v44 + v52 - 8);
          int16x4_t v55 = vsub_s16(*(int16x4_t *)(v35 + v52 - 8), (int16x4_t)vshr_n_u16((uint16x4_t)v53, 1uLL));
          int16x4_t v56 = vsub_s16(*(int16x4_t *)(result + v52 - 8), (int16x4_t)vshr_n_u16((uint16x4_t)v54, 1uLL));
          int16x4_t v57 = (int16x4_t)veor_s8((int8x8_t)vadd_s16(v56, v54), (int8x8_t)0x8000800080008000);
          v105.val[1] = vsub_s16((int16x4_t)veor_s8((int8x8_t)vadd_s16(v55, v53), (int8x8_t)0x8000800080008000), (int16x4_t)vshr_n_u16((uint16x4_t)v57, 1uLL));
          v105.val[0] = (int16x4_t)veor_s8((int8x8_t)vadd_s16(v105.val[1], v57), (int8x8_t)0x8000800080008000);
          v104.val[1] = vsub_s16(v55, (int16x4_t)vshr_n_u16((uint16x4_t)v56, 1uLL));
          v104.val[0] = (int16x4_t)veor_s8((int8x8_t)vadd_s16(v104.val[1], v56), (int8x8_t)0x8000800080008000);
          v37 -= 8;
          vst2_s16(v37, v105);
          v38 -= 8;
          vst2_s16(v38, v104);
          char v58 = v39 + v52 - 8;
          v52 -= 8;
        }
        while ((v58 & 0x1F) != 0);
        v39 += v52;
        v44 += v52;
        v36 += v52;
        result += v52;
        v35 += v52;
      }
      if (v39)
      {
        int32x2_t v59 = v38 - 32;
        int16x4_t v60 = v37 - 32;
        int16x4_t v61 = (int16x8_t *)(v44 - 32);
        uint64_t v62 = (int16x8_t *)(v36 - 32);
        int16x8_t v63 = (int16x8_t *)(result - 32);
        int16x8_t v64 = (int16x8_t *)(v35 - 32);
        do
        {
          int16x8_t v66 = *v64;
          int16x8_t v65 = v64[1];
          v64 -= 2;
          int16x8_t v67 = *v63;
          int16x8_t v68 = v63[1];
          v63 -= 2;
          int16x8_t v69 = *v62;
          int16x8_t v70 = v62[1];
          v62 -= 2;
          int16x8_t v72 = *v61;
          int16x8_t v71 = v61[1];
          v61 -= 2;
          int16x8_t v73 = vsubq_s16(v66, (int16x8_t)vshrq_n_u16((uint16x8_t)v69, 1uLL));
          int16x8_t v74 = vsubq_s16(v65, (int16x8_t)vshrq_n_u16((uint16x8_t)v70, 1uLL));
          int16x8_t v75 = vsubq_s16(v68, (int16x8_t)vshrq_n_u16((uint16x8_t)v71, 1uLL));
          int16x8_t v76 = vsubq_s16(v67, (int16x8_t)vshrq_n_u16((uint16x8_t)v72, 1uLL));
          int16x8_t v77 = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v75, v71), v32);
          int16x8_t v78 = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v76, v72), v32);
          v113.val[1] = vsubq_s16((int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v74, v70), v32), (int16x8_t)vshrq_n_u16((uint16x8_t)v77, 1uLL));
          v110.val[1] = vsubq_s16((int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v73, v69), v32), (int16x8_t)vshrq_n_u16((uint16x8_t)v78, 1uLL));
          v113.val[0] = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v113.val[1], v77), v32);
          v110.val[0] = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v110.val[1], v78), v32);
          v112.val[1] = vsubq_s16(v74, (int16x8_t)vshrq_n_u16((uint16x8_t)v75, 1uLL));
          v109.val[1] = vsubq_s16(v73, (int16x8_t)vshrq_n_u16((uint16x8_t)v76, 1uLL));
          unint64_t result = (uint64_t)(v60 - 32);
          vst2q_s16(v60, v110);
          int16x8_t v79 = v60 + 16;
          v109.val[0] = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v109.val[1], v76), v32);
          vst2q_s16(v79, v113);
          int16x8_t v80 = v59 - 32;
          vst2q_s16(v59, v109);
          int16x8_t v81 = v59 + 16;
          v112.val[0] = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v112.val[1], v75), v32);
          vst2q_s16(v81, v112);
          int16x4_t v60 = (__int16 *)result;
          int32x2_t v59 = v80;
          v39 -= 32;
        }
        while (v39);
      }
      v12 += v34;
      unint64_t v11 = (_WORD *)((char *)v11 + v34);
      v33 += v29;
    }
    while (v33 <= a6);
  }
  if ((a6 & a3) != 0)
  {
    uint64_t v82 = v12 + 2 * v30;
    int16x8_t v83 = (__int16 *)(v12 + 2 * v9);
    if (v9)
    {
      __int16 v84 = *(_WORD *)(v82 - 2);
      v82 -= 2;
      *--int16x8_t v83 = v84;
      --v9;
    }
    int16x8_t v85 = &v11[v28];
    if ((v9 & 7) != 0)
    {
      unint64_t v86 = 0;
      do
      {
        unsigned int v87 = (unsigned __int16)v85[v86 / 2 - 1];
        int v88 = *(unsigned __int16 *)(v82 + v86 - 2) - (v87 >> 1);
        *(v83 - 2) = (v88 + v87) ^ 0x8000;
        v83 -= 2;
        v83[1] = v88;
        LOBYTE(v88) = v9 + v86 - 2;
        v86 -= 2;
      }
      while ((v88 & 7) != 0);
      v9 += v86;
      int16x8_t v85 = (_WORD *)((char *)v85 + v86);
      v82 += v86;
    }
    for (; (v9 & 0x1F) != 0; v9 -= 8)
    {
      int16x4_t v89 = *(int16x4_t *)(v82 - 8);
      v82 -= 8;
      int16x4_t v90 = v89;
      int16x4_t v91 = *(int16x4_t *)(v85 - 4);
      v85 -= 4;
      v103.val[1] = vsub_s16(v90, (int16x4_t)vshr_n_u16((uint16x4_t)v91, 1uLL));
      v103.val[0] = (int16x4_t)veor_s8((int8x8_t)vadd_s16(v103.val[1], v91), (int8x8_t)0x8000800080008000);
      v83 -= 8;
      vst2_s16(v83, v103);
    }
    if (v9)
    {
      int16x8_t v92 = v83 - 32;
      uint8x16_t v93 = (int16x8_t *)(v85 - 16);
      int16x8_t v94 = (int16x8_t *)(v82 - 32);
      v95.i64[0] = 0x8000800080008000;
      v95.i64[1] = 0x8000800080008000;
      do
      {
        int16x8_t v96 = *v94;
        int16x8_t v97 = v94[1];
        v94 -= 2;
        int16x8_t v99 = *v93;
        int16x8_t v98 = v93[1];
        v93 -= 2;
        v111.val[1] = vsubq_s16(v97, (int16x8_t)vshrq_n_u16((uint16x8_t)v98, 1uLL));
        v107.val[1] = vsubq_s16(v96, (int16x8_t)vshrq_n_u16((uint16x8_t)v99, 1uLL));
        v107.val[0] = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v107.val[1], v99), v95);
        int16x4x2_t v100 = v92 - 32;
        vst2q_s16(v92, v107);
        int v101 = v92 + 16;
        v111.val[0] = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v111.val[1], v98), v95);
        vst2q_s16(v101, v111);
        int16x8_t v92 = v100;
        v9 -= 32;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t WaveDecodeRecurse<unsigned int,false>(uint64_t result, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, int8x16_t a8, double a9, int8x16_t a10, __n128 a11)
{
  unint64_t v13 = a5;
  uint64_t v15 = a2;
  uint64_t v16 = result;
  if (a3 <= a6)
  {
    unint64_t v17 = a7 * a3;
    unint64_t v18 = a3;
    uint64_t v19 = result;
    uint64_t v20 = a2;
    do
    {
      if (a5 >= 0x20)
      {
        uint64_t v25 = 0;
        uint64_t v24 = v19;
        uint64_t v23 = v19;
        uint64_t v22 = v20;
        do
        {
          unint64_t v26 = (const float *)v24;
          *(float32x4x2_t *)a8.i8 = vld2q_f32(v26);
          v26 += 8;
          *(float32x4x2_t *)a10.i8 = vld2q_f32(v26);
          unint64_t v27 = (const float *)(v24 + 64);
          float32x4x2_t v128 = vld2q_f32(v27);
          unint64_t v28 = (const float *)(v24 + 96);
          float32x4x2_t v130 = vld2q_f32(v28);
          v24 += 128;
          *(float32x4_t *)(v23 + 32) = v128.val[0];
          *(float32x4_t *)(v23 + 48) = v130.val[0];
          *(int8x16_t *)uint64_t v23 = a8;
          *(int8x16_t *)(v23 + 16) = a10;
          v23 += 64;
          *(float32x4_t *)(v22 + 32) = v128.val[1];
          *(float32x4_t *)(v22 + 48) = v130.val[1];
          *(_OWORD *)uint64_t v22 = v29;
          *(__n128 *)(v22 + 16) = a11;
          v22 += 64;
          unint64_t v21 = v25 + 32;
          unint64_t v30 = v25 + 64;
          v25 += 32;
        }
        while (v30 <= a5);
      }
      else
      {
        unint64_t v21 = 0;
        uint64_t v22 = v20;
        uint64_t v23 = v19;
        uint64_t v24 = v19;
      }
      unint64_t v31 = v21 | 8;
      if ((v21 | 8) <= a5)
      {
        do
        {
          *(float32x4x2_t *)a8.i8 = vld2q_f32((const float *)v24);
          v24 += 32;
          *(int8x16_t *)uint64_t v23 = a8;
          v23 += 16;
          *(_OWORD *)uint64_t v22 = v32;
          v22 += 16;
          v31 += 8;
        }
        while (v31 <= a5);
        unint64_t v21 = v31 - 8;
      }
      unint64_t v33 = v21 + 2;
      while (v33 <= a5)
      {
        *(_DWORD *)uint64_t v23 = *(_DWORD *)v24;
        v23 += 4;
        *(_DWORD *)uint64_t v22 = *(_DWORD *)(v24 + 4);
        v22 += 4;
        v24 += 8;
        unint64_t v33 = v21 + 4;
        v21 += 2;
      }
      if (v21 < a5) {
        *(_DWORD *)uint64_t v23 = *(_DWORD *)v24;
      }
      v19 += v17;
      v20 += v17;
      v18 += a3;
    }
    while (v18 <= a6);
  }
  unint64_t v34 = a5 >> 1;
  unint64_t v35 = 2 * a3;
  if (2 * a3 < a4) {
    unint64_t result = WaveDecodeRecurse<unsigned int,false>(result, a2 + 4 * v34, 2 * a3);
  }
  unint64_t v36 = v13 - (v13 >> 1);
  if (v35 <= a6)
  {
    unint64_t v37 = a7 * a3;
    a8.i32[0] = -2147450880;
    a8.i16[2] = 0x8000;
    a8.i16[3] = 0x8000;
    a8.i16[4] = 0x8000;
    a8.i16[5] = 0x8000;
    a8.i16[6] = 0x8000;
    a8.i16[7] = 0x8000;
    unint64_t v38 = 2 * a3;
    unint64_t v39 = v35 * a7;
    do
    {
      uint64_t v40 = v16 + 4 * v36;
      unint64_t v41 = v37 + v40;
      unint64_t v42 = v16 + 4 * v13;
      unint64_t result = v37 + v42;
      if (v13)
      {
        unsigned __int32 v44 = *(unsigned __int16 *)(v40 - 4);
        v40 -= 4;
        a10.i32[0] = v44;
        a10.i16[2] = *(_WORD *)(v40 + 2);
        __int32 v45 = *(unsigned __int16 *)(v41 - 4);
        v41 -= 4;
        v46.i32[0] = v45;
        v46.i32[1] = *(unsigned __int16 *)(v41 + 2);
        int16x4_t v47 = (int16x4_t)vsub_s32(*(int32x2_t *)a10.i8, (int32x2_t)vshr_n_u32(v46, 1uLL));
        a11.n128_u64[0] = (unint64_t)vadd_s32((int32x2_t)v47, (int32x2_t)v46);
        unsigned __int32 v48 = vuzp1_s16(v47, *(int16x4_t *)a8.i8).u32[0];
        *(int16x4_t *)a10.i8 = vuzp1_s16((int16x4_t)a11.n128_u64[0], *(int16x4_t *)a8.i8);
        *(_DWORD *)(v42 - 4) = a10.i32[0] ^ 0x80008000;
        v42 -= 4;
        *(_DWORD *)(result - 4) = v48;
        result -= 4;
        unint64_t v43 = v13 - 1;
      }
      else
      {
        unint64_t v43 = v13;
      }
      uint64_t v49 = v15 + 4 * v34;
      uint64_t v50 = v37 + v49;
      if ((v43 & 7) != 0)
      {
        uint64_t v51 = 0;
        do
        {
          a10.i16[0] = *(_WORD *)(v40 + v51 - 4);
          a11.n128_u16[0] = *(_WORD *)(v49 + v51 - 4);
          a11.n128_u16[2] = *(_WORD *)(v49 + v51 - 2);
          v52.i32[0] = *(unsigned __int16 *)(v41 + v51 - 4);
          v53.i32[0] = *(unsigned __int16 *)(v50 + v51 - 4);
          v52.i32[1] = *(unsigned __int16 *)(v41 + v51 - 2);
          v53.i32[1] = *(unsigned __int16 *)(v50 + v51 - 2);
          a10.i16[2] = *(_WORD *)(v40 + v51 - 2);
          int32x2_t v54 = (int32x2_t)vshr_n_u32(v52, 1uLL);
          int32x2_t v55 = vsub_s32(*(int32x2_t *)a10.i8, v54);
          int32x2_t v56 = vsub_s32((int32x2_t)a11.n128_u64[0], (int32x2_t)vshr_n_u32(v53, 1uLL));
          uint16x4_t v57 = (uint16x4_t)vuzp1_s16((int16x4_t)vadd_s32(v56, (int32x2_t)v53), *(int16x4_t *)a8.i8);
          unsigned __int32 v58 = v57.i32[0] ^ 0x80008000;
          v57.i32[0] = vuzp1_s16((int16x4_t)vadd_s32(v55, (int32x2_t)v52), *(int16x4_t *)a8.i8).u32[0] ^ 0x80008000;
          v54.i32[0] = v58;
          uint32x4_t v59 = vmovl_u16(v57);
          *(int32x2_t *)v59.i8 = vsub_s32(*(int32x2_t *)v59.i8, (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)*(_OWORD *)&vmovl_u16((uint16x4_t)v54), (int8x8_t)0xFFFF0000FFFFLL), 1uLL));
          int16x4_t v60 = (int16x4_t)vsub_s32(v55, (int32x2_t)vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)v56, (int8x8_t)0xFFFF0000FFFFLL), 1uLL));
          int16x4_t v61 = (int16x4_t)vadd_s32((int32x2_t)v60, v56);
          *(int16x4_t *)a10.i8 = vuzp1_s16(v60, *(int16x4_t *)a8.i8);
          a11.n128_u64[0] = (unint64_t)vuzp1_s16(v61, *(int16x4_t *)a8.i8);
          *(_DWORD *)(v42 - 8) = vuzp1_s16((int16x4_t)*(_OWORD *)&vaddw_u16(v59, (uint16x4_t)v54), *(int16x4_t *)a8.i8).u32[0] ^ 0x80008000;
          v42 -= 8;
          *(_DWORD *)(v42 + 4) = vuzp1_s16(*(int16x4_t *)v59.i8, *(int16x4_t *)a8.i8).u32[0];
          *(_DWORD *)(result - 8) = a11.n128_u32[0] ^ 0x80008000;
          result -= 8;
          *(_DWORD *)(result + 4) = a10.i32[0];
          v43 -= 2;
          v51 -= 4;
        }
        while ((v43 & 7) != 0);
        v40 += v51;
        v50 += v51;
        v41 += v51;
        v49 += v51;
      }
      if ((v43 & 0x1F) != 0)
      {
        uint64_t v62 = 0;
        do
        {
          int16x8_t v63 = *(int16x8_t *)(v41 + v62 - 16);
          int16x8_t v64 = *(int16x8_t *)(v50 + v62 - 16);
          int16x8_t v65 = vsubq_s16(*(int16x8_t *)(v40 + v62 - 16), (int16x8_t)vshrq_n_u16((uint16x8_t)v63, 1uLL));
          a11 = (__n128)vsubq_s16(*(int16x8_t *)(v49 + v62 - 16), (int16x8_t)vshrq_n_u16((uint16x8_t)v64, 1uLL));
          int16x8_t v66 = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)a11, v64), a8);
          v131.val[1] = (float32x4_t)vsubq_s16((int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v65, v63), a8), (int16x8_t)vshrq_n_u16((uint16x8_t)v66, 1uLL));
          v131.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v131.val[1], v66), a8);
          v129.val[1] = (float32x4_t)vsubq_s16(v65, (int16x8_t)vshrq_n_u16((uint16x8_t)a11, 1uLL));
          a10 = (int8x16_t)vaddq_s16((int16x8_t)v129.val[1], (int16x8_t)a11);
          v42 -= 32;
          vst2q_f32((float *)v42, v131);
          v129.val[0] = (float32x4_t)veorq_s8(a10, a8);
          result -= 32;
          vst2q_f32((float *)result, v129);
          v43 -= 8;
          v62 -= 16;
        }
        while ((v43 & 0x1F) != 0);
        v50 += v62;
        v41 += v62;
        v49 += v62;
        v40 += v62;
      }
      if (v43)
      {
        result -= 128;
        int16x8_t v67 = (float *)(v42 - 128);
        uint64_t v68 = v50 - 64;
        int16x8_t v69 = (int16x8_t *)(v41 - 64);
        int16x8_t v70 = (int16x8_t *)(v49 - 64);
        int16x8_t v71 = (int16x8_t *)(v40 - 64);
        do
        {
          int16x8_t v72 = v69[2];
          int16x8_t v73 = v69[3];
          int16x8_t v74 = *v69;
          int16x8_t v75 = v69[1];
          v69 -= 4;
          int16x8_t v76 = vsubq_s16(*v71, (int16x8_t)vshrq_n_u16((uint16x8_t)v74, 1uLL));
          int16x8_t v77 = vsubq_s16(v71[1], (int16x8_t)vshrq_n_u16((uint16x8_t)v75, 1uLL));
          int16x8_t v78 = vsubq_s16(v71[2], (int16x8_t)vshrq_n_u16((uint16x8_t)v72, 1uLL));
          int16x8_t v79 = vsubq_s16(v71[3], (int16x8_t)vshrq_n_u16((uint16x8_t)v73, 1uLL));
          int8x16_t v80 = (int8x16_t)vaddq_s16(v79, v73);
          int8x16_t v81 = (int8x16_t)vaddq_s16(v78, v72);
          int16x8_t v82 = *(int16x8_t *)(v68 + 16);
          int16x8_t v84 = *(int16x8_t *)(v68 + 32);
          int16x8_t v83 = *(int16x8_t *)(v68 + 48);
          int16x8_t v85 = vsubq_s16(v70[3], (int16x8_t)vshrq_n_u16((uint16x8_t)v83, 1uLL));
          int16x8_t v86 = vsubq_s16(v70[2], (int16x8_t)vshrq_n_u16((uint16x8_t)v84, 1uLL));
          int16x8_t v87 = *v70;
          int16x8_t v88 = v70[1];
          v70 -= 4;
          int16x8_t v89 = vsubq_s16(v88, (int16x8_t)vshrq_n_u16((uint16x8_t)v82, 1uLL));
          int16x8_t v90 = vsubq_s16(v87, (int16x8_t)vshrq_n_u16(*(uint16x8_t *)v68, 1uLL));
          int16x8_t v91 = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v85, v83), a8);
          int16x8_t v92 = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v86, v84), a8);
          int16x8_t v93 = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v89, v82), a8);
          int16x8_t v94 = (int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v90, *(int16x8_t *)v68), a8);
          v139.val[1] = (float32x4_t)vsubq_s16((int16x8_t)veorq_s8(v80, a8), (int16x8_t)vshrq_n_u16((uint16x8_t)v91, 1uLL));
          v134.val[1] = (float32x4_t)vsubq_s16((int16x8_t)veorq_s8(v81, a8), (int16x8_t)vshrq_n_u16((uint16x8_t)v92, 1uLL));
          v138.val[1] = (float32x4_t)vsubq_s16((int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v77, v75), a8), (int16x8_t)vshrq_n_u16((uint16x8_t)v93, 1uLL));
          v132.val[1] = (float32x4_t)vsubq_s16((int16x8_t)veorq_s8((int8x16_t)vaddq_s16(v76, v74), a8), (int16x8_t)vshrq_n_u16((uint16x8_t)v94, 1uLL));
          v139.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v139.val[1], v91), a8);
          v134.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v134.val[1], v92), a8);
          v138.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v138.val[1], v93), a8);
          v132.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v132.val[1], v94), a8);
          v137.val[1] = (float32x4_t)vsubq_s16(v77, (int16x8_t)vshrq_n_u16((uint16x8_t)v89, 1uLL));
          v133.val[1] = (float32x4_t)vsubq_s16(v76, (int16x8_t)vshrq_n_u16((uint16x8_t)v90, 1uLL));
          int8x16_t v95 = v67;
          vst2q_f32(v95, v132);
          v95 += 8;
          vst2q_f32(v95, v138);
          v137.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v137.val[1], v89), a8);
          int16x8_t v96 = v67 + 16;
          vst2q_f32(v96, v134);
          v133.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v133.val[1], v90), a8);
          int16x8_t v97 = v67 + 24;
          vst2q_f32(v97, v139);
          int16x8_t v98 = (float *)result;
          vst2q_f32(v98, v133);
          v98 += 8;
          vst2q_f32(v98, v137);
          int16x8_t v99 = (float *)(result + 64);
          v132.val[1] = (float32x4_t)vsubq_s16(v78, (int16x8_t)vshrq_n_u16((uint16x8_t)v86, 1uLL));
          v132.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v132.val[1], v86), a8);
          vst2q_f32(v99, v132);
          int16x4x2_t v100 = (float *)(result + 96);
          result -= 128;
          int16x8_t v101 = vsubq_s16(v79, (int16x8_t)vshrq_n_u16((uint16x8_t)v85, 1uLL));
          v67 -= 32;
          v68 -= 64;
          v71 -= 4;
          a10 = (int8x16_t)vaddq_s16(v101, v85);
          a11 = (__n128)veorq_s8(a10, a8);
          vst2q_f32(v100, *(float32x4x2_t *)a11.n128_u64);
          v43 -= 32;
        }
        while (v43);
      }
      v16 += v39;
      v15 += v39;
      v38 += v35;
    }
    while (v38 <= a6);
  }
  if ((a6 & a3) != 0)
  {
    uint64_t v102 = v16 + 4 * v36;
    unint64_t v103 = v16 + 4 * v13;
    if (v13)
    {
      int v104 = *(_DWORD *)(v102 - 4);
      v102 -= 4;
      *(_DWORD *)(v103 - 4) = v104;
      v103 -= 4;
      --v13;
    }
    uint64_t v105 = v15 + 4 * v34;
    if ((v13 & 7) != 0)
    {
      uint64_t v106 = 0;
      do
      {
        a8.i16[0] = *(_WORD *)(v102 + v106 - 4);
        a8.i16[2] = *(_WORD *)(v102 + v106 - 2);
        v107.i32[0] = *(unsigned __int16 *)(v105 + v106 - 4);
        v107.i32[1] = *(unsigned __int16 *)(v105 + v106 - 2);
        int16x4_t v108 = (int16x4_t)vsub_s32(*(int32x2_t *)a8.i8, (int32x2_t)vshr_n_u32(v107, 1uLL));
        int16x4_t v109 = (int16x4_t)vadd_s32((int32x2_t)v108, (int32x2_t)v107);
        *(int16x4_t *)a8.i8 = vuzp1_s16(v108, v108);
        *(_DWORD *)(v103 - 8) = vuzp1_s16(v109, *(int16x4_t *)a8.i8).u32[0] ^ 0x80008000;
        v103 -= 8;
        *(_DWORD *)(v103 + 4) = a8.i32[0];
        v13 -= 2;
        v106 -= 4;
      }
      while ((v13 & 7) != 0);
      v105 += v106;
      v102 += v106;
    }
    if ((v13 & 0x1F) != 0)
    {
      v110.i64[0] = 0x8000800080008000;
      v110.i64[1] = 0x8000800080008000;
      do
      {
        int16x8_t v111 = *(int16x8_t *)(v102 - 16);
        v102 -= 16;
        int16x8_t v112 = v111;
        int16x8_t v113 = *(int16x8_t *)(v105 - 16);
        v105 -= 16;
        v126.val[1] = (float32x4_t)vsubq_s16(v112, (int16x8_t)vshrq_n_u16((uint16x8_t)v113, 1uLL));
        v126.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v126.val[1], v113), v110);
        v103 -= 32;
        vst2q_f32((float *)v103, v126);
        v13 -= 8;
      }
      while ((v13 & 0x1F) != 0);
    }
    if (v13)
    {
      int16x8_t v114 = (float *)(v103 - 128);
      int16x8_t v115 = (int16x8_t *)(v105 - 64);
      int16x8_t v116 = (int16x8_t *)(v102 - 64);
      v117.i64[0] = 0x8000800080008000;
      v117.i64[1] = 0x8000800080008000;
      do
      {
        int16x8_t v119 = v115[2];
        int16x8_t v118 = v115[3];
        int16x8_t v121 = *v115;
        int16x8_t v120 = v115[1];
        v115 -= 4;
        v136.val[1] = (float32x4_t)vsubq_s16(v116[3], (int16x8_t)vshrq_n_u16((uint16x8_t)v118, 1uLL));
        v127.val[1] = (float32x4_t)vsubq_s16(v116[2], (int16x8_t)vshrq_n_u16((uint16x8_t)v119, 1uLL));
        v135.val[1] = (float32x4_t)vsubq_s16(v116[1], (int16x8_t)vshrq_n_u16((uint16x8_t)v120, 1uLL));
        v125.val[1] = (float32x4_t)vsubq_s16(*v116, (int16x8_t)vshrq_n_u16((uint16x8_t)v121, 1uLL));
        v125.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v125.val[1], v121), v117);
        int8x16_t v122 = v114;
        vst2q_f32(v122, v125);
        v122 += 8;
        v135.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v135.val[1], v120), v117);
        vst2q_f32(v122, v135);
        v127.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v127.val[1], v119), v117);
        float32x4x2_t v123 = v114 + 16;
        vst2q_f32(v123, v127);
        v136.val[0] = (float32x4_t)veorq_s8((int8x16_t)vaddq_s16((int16x8_t)v136.val[1], v118), v117);
        float32x4x2_t v124 = v114 + 24;
        vst2q_f32(v124, v136);
        v114 -= 32;
        v116 -= 4;
        v13 -= 32;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t TileDecoder_PIZ::Interleave(uint64_t a1, uint64_t a2, uint64_t a3, int32x2_t *a4, unsigned int a5, unsigned int a6)
{
  v33[0] = 0;
  v33[1] = 0;
  int v35 = 0;
  uint64_t v34 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a1, a4, a5, a6, (unsigned int *)v33);
  if (HIDWORD(v34)) {
    BOOL v10 = v35 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    int v11 = *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 72);
    if (v11 == 1) {
      uint64_t v12 = 2;
    }
    else {
      uint64_t v12 = 4;
    }
    if (!*(_DWORD *)(a1 + 72)) {
      goto LABEL_23;
    }
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    char v15 = v11 == 1 ? 1 : 2;
    do
    {
      uint64_t v16 = *(void *)(a1 + 64);
      if (!*(unsigned char *)(*(void *)(v16 + 16 * v14) + 24))
      {
        if (v14)
        {
          uint64_t v17 = 0;
          while (!ChannelInfo::operator==((uint64_t *)(*(void *)(a1 + 64) + v17), (uint64_t *)(*(void *)(a1 + 64) + 16 * v14)))
          {
            v17 += 16;
            if (v13 == v17)
            {
              uint64_t v16 = *(void *)(a1 + 64);
              goto LABEL_18;
            }
          }
        }
        else
        {
LABEL_18:
          uint64_t LocationForTile = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(v16 + 16 * v14 + 8), (HIDWORD(*(void *)&a4[3]) * *(_DWORD *)(a1 + 60)), *(void *)&a4[3], a4[7].u32[1]);
          uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 16 * v14 + 8);
          v20.i64[0] = *(void *)(v19 + 48);
          *(int32x2_t *)v21.i8 = vmls_s32(*(int32x2_t *)(*(void *)(*(void *)(v19 + 40) + 8 * a4[7].u32[1]) + 16), *(int32x2_t *)v20.i8, a4[3]);
          *(uint32x2_t *)v22.i8 = vmin_u32(*(uint32x2_t *)v21.i8, *(uint32x2_t *)v20.i8);
          TileDecoder_PIZ::WaveDecode(v22, v20, v21, v26, v27, LocationForTile, *(void *)(a2 + 8) + LocationForTile, (unint64_t)v22.u32[0] << v15, *(_WORD **)(a2 + 16), v23, v24, v25, *(_DWORD *)(a2 + 48), v12);
        }
      }
      ++v14;
      unint64_t v28 = *(unsigned int *)(a1 + 72);
      v13 += 16;
    }
    while (v14 < v28);
    if (v28 == 2)
    {
      uint64_t v29 = *(void *)(a1 + 64);
      if (v29) {
        uint64_t v30 = 2 * (*(void *)(v29 + 8) != 0);
      }
      else {
        uint64_t v30 = 0;
      }
      return (*(uint64_t (**)(void, uint64_t, int32x2_t *))((char *)TileDecoder_PIZ::Interleave(void const*,unsigned long,TileInfo const&,unsigned int,unsigned int,void *,unsigned long,long)const::funcTable
                                                                     + ((8 * (v30 | (v11 != 1))) | (32
                                                                                                  * (*(void *)(v29 + 24) != 0)))))(*(void *)(a2 + 8), a1, a4);
    }
    else
    {
LABEL_23:
      unint64_t v31 = *(void **)(a1 + 64);
      if (v31) {
        uint64_t v32 = 2 * (v31[1] != 0);
      }
      else {
        uint64_t v32 = 0;
      }
      return (*(uint64_t (**)(void, uint64_t, int32x2_t *))((char *)TileDecoder_PIZ::Interleave(void const*,unsigned long,TileInfo const&,unsigned int,unsigned int,void *,unsigned long,long)const::funcTable
                                                                     + ((8 * (v32 | (v11 != 1))) | (32
                                                                                                  * (v31[3] != 0)) | ((unint64_t)(v31[5] != 0) << 6) | ((unint64_t)(v31[7] != 0) << 7))))(*(void *)(a2 + 8), a1, a4);
    }
  }
  return result;
}

BOOL ChannelInfo::operator==(uint64_t *a1, uint64_t *a2)
{
  BOOL result = ReadChannel::operator==(*a1, *a2);
  if (result)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = a2[1];
    BOOL result = (v5 | v6) == 0;
    if (v5) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7) {
      return **(void **)(**(void **)(v5 + 40) + 24) == **(void **)(**(void **)(v6 + 40) + 24);
    }
  }
  return result;
}

void Read2_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t a6, unint64_t a7, unsigned int a8, int8x16_t *a9, uint64_t a10)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v15 = _D0;
  }
  else
  {
    unsigned int v15 = 32256;
  }
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v17 = _D0;
  }
  else
  {
    unsigned int v17 = 32256;
  }
  uint64_t v18 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v18 < *(unsigned int *)(a2 + 60))
  {
    v29.val[0] = (int8x16_t)vdupq_n_s16(v15);
    v29.val[1] = (int8x16_t)vdupq_n_s16(v17);
    int8x16_t v20 = vqtbl2q_s8(v29, (int8x16_t)xmmword_228F41B50);
    int8x16_t v21 = vqtbl2q_s8(v29, (int8x16_t)xmmword_228F41C10);
    do
    {
      if (a7 >= 0x10)
      {
        uint64_t v24 = 0;
        uint64_t v25 = a9;
        do
        {
          uint64_t v23 = v25 + 4;
          *uint64_t v25 = v20;
          v25[1] = v20;
          v25[2] = v20;
          v25[3] = v20;
          unint64_t v22 = v24 + 16;
          unint64_t v26 = v24 + 32;
          v24 += 16;
          v25 += 4;
        }
        while (v26 <= a7);
      }
      else
      {
        unint64_t v22 = 0;
        uint64_t v23 = a9;
      }
      unint64_t v27 = v22 | 4;
      if ((v22 | 4) <= a7)
      {
        do
        {
          *v23++ = v21;
          v27 += 4;
        }
        while (v27 <= a7);
        unint64_t v22 = v27 - 4;
      }
      _CF = a7 >= v22;
      unint64_t v28 = a7 - v22;
      if (v28 != 0 && _CF)
      {
        do
        {
          v23->i16[1] = v17;
          v23->i16[0] = v15;
          uint64_t v23 = (int8x16_t *)((char *)v23 + 4);
          --v28;
        }
        while (v28);
      }
      a9 = (int8x16_t *)((char *)a9 + a10);
      v18 += a8;
    }
    while (v18 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
}

void Read2_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, _OWORD *a9, uint64_t a10)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    float v10 = **(double **)a4;
    float v11 = v10;
  }
  else
  {
    float v11 = NAN;
  }
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    float v12 = **(double **)a5;
    float v13 = v12;
  }
  else
  {
    float v13 = NAN;
  }
  uint64_t v14 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v14 < *(unsigned int *)(a2 + 60))
  {
    *(void *)&long long v16 = __PAIR64__(LODWORD(v13), LODWORD(v11));
    *((void *)&v16 + 1) = __PAIR64__(LODWORD(v13), LODWORD(v11));
    unint64_t v17 = __PAIR64__(LODWORD(v13), LODWORD(v11));
    do
    {
      if (a7 >= 0x10)
      {
        uint64_t v20 = 0;
        int8x16_t v21 = a9;
        do
        {
          uint64_t v19 = v21 + 8;
          _OWORD *v21 = v16;
          v21[1] = v16;
          v21[2] = v16;
          v21[3] = v16;
          v21[4] = v16;
          v21[5] = v16;
          unint64_t v18 = v20 + 16;
          unint64_t v22 = v20 + 32;
          v20 += 16;
          v21[6] = v16;
          v21[7] = v16;
          v21 += 8;
        }
        while (v22 <= a7);
      }
      else
      {
        unint64_t v18 = 0;
        uint64_t v19 = a9;
      }
      unint64_t v23 = v18 | 4;
      if ((v18 | 4) <= a7)
      {
        do
        {
          *uint64_t v19 = v16;
          v19[1] = v16;
          v19 += 2;
          v23 += 4;
        }
        while (v23 <= a7);
        unint64_t v18 = v23 - 4;
      }
      BOOL v24 = a7 >= v18;
      unint64_t v25 = a7 - v18;
      if (v25 != 0 && v24)
      {
        do
        {
          *(void *)uint64_t v19 = v17;
          uint64_t v19 = (_OWORD *)((char *)v19 + 8);
          --v25;
        }
        while (v25);
      }
      a9 = (_OWORD *)((char *)a9 + a10);
      v14 += a8;
    }
    while (v14 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
}

unint64_t Read2_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t a6, unint64_t a7, unsigned int a8, int8x16_t *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v15 = *(void *)(a3 + 24);
  uint64_t v65 = *(unsigned int *)(a3 + 44);
  uint64_t v67 = v15;
  uint64_t v68 = *(ChannelDescription **)(a4 + 8);
  unsigned int v66 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v68, (*(_DWORD *)(a3 + 52) + HIDWORD(v15) * *(_DWORD *)(a2 + 60)), v15, v66);
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v22 = _D0;
  }
  else
  {
    unsigned int v22 = 32256;
  }
  unint64_t v23 = *(void *)(a2 + 56);
  uint64_t v24 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v24 < HIDWORD(v23))
  {
    int v26 = *(_DWORD *)(a3 + 28) * HIDWORD(v23);
    int16x8_t v27 = vdupq_n_s16(v22);
    do
    {
      long long v71 = v17;
      int16x8_t v72 = v27;
      unint64_t result = ChannelDescription::GetLocationForTile(v68, (v26 + v24), v67, v66);
      long long v17 = v71;
      int16x8_t v27 = v72;
      uint64_t v31 = a1 + result;
      if (HIDWORD(result)) {
        _ZF = v31 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        if (a7 >= 0x10)
        {
          uint64_t v35 = 0;
          unint64_t v36 = (unsigned __int16 *)(v31 + 2 * v65 + 30);
          unint64_t v37 = a9;
          do
          {
            uint64_t v38 = *(v36 - 15);
            unint64_t v39 = (_WORD *)(a11 + 2 * *(v36 - 14));
            uint64_t v40 = (_WORD *)(a11 + 2 * *(v36 - 13));
            unint64_t v41 = (_WORD *)(a11 + 2 * *(v36 - 12));
            uint64_t v42 = *(v36 - 11);
            unint64_t v43 = (__int16 *)(a11 + 2 * *(v36 - 10));
            unint64_t result = a11 + 2 * *(v36 - 9);
            unsigned __int32 v44 = (__int16 *)(a11 + 2 * *(v36 - 8));
            uint64_t v45 = *(v36 - 7);
            uint32x2_t v46 = (__int16 *)(a11 + 2 * *(v36 - 6));
            int16x4_t v47 = (__int16 *)(a11 + 2 * *(v36 - 5));
            unsigned __int32 v48 = (__int16 *)(a11 + 2 * *(v36 - 4));
            uint64_t v49 = *(v36 - 3);
            uint64_t v50 = (__int16 *)(a11 + 2 * *(v36 - 2));
            uint64_t v51 = (__int16 *)(a11 + 2 * *(v36 - 1));
            unsigned int v52 = *v36;
            v36 += 16;
            v28.i16[0] = *(_WORD *)(a11 + 2 * v49);
            v28.i16[2] = *v50;
            v28.i16[4] = *v51;
            v28.i16[6] = *(_WORD *)(a11 + 2 * v52);
            v29.i16[0] = *(_WORD *)(a11 + 2 * v45);
            v29.i16[2] = *v46;
            v29.i16[4] = *v47;
            v29.i16[6] = *v48;
            v30.i16[0] = *(_WORD *)(a11 + 2 * v42);
            v30.i16[2] = *v43;
            v30.i16[4] = *(_WORD *)result;
            v30.i16[6] = *v44;
            LOWORD(v17) = *(_WORD *)(a11 + 2 * v38);
            WORD2(v17) = *v39;
            WORD4(v17) = *v40;
            WORD6(v17) = *v41;
            int16x8_t v53 = v72;
            int8x16_t v30 = vqtbl2q_s8(*(int8x16x2_t *)v30.i8, (int8x16_t)xmmword_228F41BF0);
            int16x8_t v54 = v72;
            int8x16_t v29 = vqtbl2q_s8(*(int8x16x2_t *)v29.i8, (int8x16_t)xmmword_228F41C10);
            int16x8_t v55 = v72;
            int8x16_t v28 = vqtbl2q_s8(*(int8x16x2_t *)v28.i8, (int8x16_t)xmmword_228F41BF0);
            uint64_t v34 = v37 + 4;
            v37[2] = v29;
            v37[3] = v28;
            unint64_t v33 = v35 + 16;
            unint64_t v56 = v35 + 32;
            *unint64_t v37 = vqtbl2q_s8(*(int8x16x2_t *)&v17, (int8x16_t)xmmword_228F41C10);
            v37[1] = v30;
            v35 += 16;
            v37 += 4;
          }
          while (v56 <= a7);
        }
        else
        {
          unint64_t v33 = 0;
          uint64_t v34 = a9;
        }
        if ((v33 | 4) <= a7)
        {
          uint64_t v58 = v31 + 2 * v65;
          do
          {
            v28.i16[0] = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v58 + 2 * v33));
            v28.i16[2] = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v58 + ((2 * v33) | 2)));
            v28.i16[4] = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v58 + ((2 * v33) | 4)));
            v28.i16[6] = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v58 + ((2 * v33) | 6)));
            int16x8_t v59 = v72;
            int8x16_t v28 = vqtbl2q_s8(*(int8x16x2_t *)v28.i8, (int8x16_t)xmmword_228F41C10);
            *v34++ = v28;
            unint64_t v57 = v33 + 4;
            unint64_t v60 = v33 + 8;
            v33 += 4;
          }
          while (v60 <= a7);
        }
        else
        {
          unint64_t v57 = v33;
        }
        uint64_t v61 = a7 - v57;
        if (a7 > v57)
        {
          uint64_t v62 = (unsigned __int16 *)(v31 + 2 * v65 + 2 * v57);
          do
          {
            unsigned int v63 = *v62++;
            __int16 v64 = *(_WORD *)(a11 + 2 * v63);
            v34->i16[1] = v22;
            v34->i16[0] = v64;
            uint64_t v34 = (int8x16_t *)((char *)v34 + 4);
            --v61;
          }
          while (v61);
        }
      }
      a9 = (int8x16_t *)((char *)a9 + a10);
      v24 += a8;
    }
    while (v24 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

void Read2_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, int32x4_t *a9, uint64_t a10, uint64_t a11)
{
  int v16 = *(_DWORD *)(a2 + 60);
  long long v17 = *(ChannelDescription **)(a4 + 8);
  uint64_t v18 = *(void *)(a3 + 24);
  LODWORD(v56) = v18;
  uint64_t v52 = a1;
  int16x8_t v53 = v17;
  unint64_t v19 = (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * v16);
  unsigned int v55 = *(_DWORD *)(a3 + 44);
  uint64_t v57 = a11;
  unsigned int v58 = *(_DWORD *)(a3 + 60);
  unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v17, v19, v18, v58);
  uint64_t v21 = a1 + LocationForTile + 4 * v55;
  if (!HIDWORD(LocationForTile)) {
    uint64_t v21 = 0;
  }
  uint64_t v51 = v21;
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    *(float *)&unsigned int v22 = **(double **)a5;
    unsigned int v23 = v22;
  }
  else
  {
    unsigned int v23 = 2143289344;
  }
  unint64_t v24 = *(void *)(a2 + 56);
  uint64_t v25 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v25 < HIDWORD(v24))
  {
    int v27 = *(_DWORD *)(a3 + 28) * HIDWORD(v24);
    uint64_t v28 = a8;
    int32x4_t v46 = vdupq_n_s32(v23);
    do
    {
      int v54 = v27 + v25;
      unint64_t v29 = ChannelDescription::GetLocationForTile(v53, (v27 + v25), v56, v58);
      if (HIDWORD(v29))
      {
        uint64_t v51 = v52 + v29 + 4 * v55;
        int32x4_t v32 = v46;
        if (v52 + v29)
        {
          if (a7 >= 0x10)
          {
            uint64_t v35 = 0;
            unint64_t v36 = a9;
            do
            {
              AXRLUTStream<unsigned int,(StreamType)1>::load16(&v51, v35, (uint64_t)&v47);
              int32x4_t v32 = v46;
              int32x4_t v37 = vzip1q_s32(v50, v46);
              int32x4_t v38 = vzip2q_s32(v50, v46);
              int32x4_t v39 = vzip1q_s32(v47, v46);
              int32x4_t v31 = vzip2q_s32(v47, v46);
              int32x4_t v40 = vzip1q_s32(v48, v46);
              int32x4_t v30 = vzip2q_s32(v48, v46);
              int32x4_t v41 = vzip2q_s32(v49, v46);
              uint64_t v34 = v36 + 8;
              v36[4] = vzip1q_s32(v49, v46);
              v36[5] = v41;
              v36[2] = v40;
              v36[3] = v30;
              *unint64_t v36 = v39;
              v36[1] = v31;
              v36[6] = v37;
              v36[7] = v38;
              unint64_t v33 = v35 + 16;
              unint64_t v42 = v35 + 32;
              v35 += 16;
              v36 += 8;
            }
            while (v42 <= a7);
          }
          else
          {
            unint64_t v33 = 0;
            uint64_t v34 = a9;
          }
          unint64_t v43 = v33 | 4;
          if ((v33 | 4) <= a7)
          {
            do
            {
              v30.i32[0] = *(unsigned __int16 *)(v57 + 2 * (unsigned __int16)*(_DWORD *)(v51 + 4 * v33)) | (*(unsigned __int16 *)(v57 + (((unint64_t)*(unsigned int *)(v51 + 4 * v33) >> 15) & 0x1FFFE)) << 16);
              v30.i32[2] = *(unsigned __int16 *)(v57 + 2 * (unsigned __int16)*(_DWORD *)(v51 + ((4 * v33) | 4))) | (*(unsigned __int16 *)(v57 + (((unint64_t)*(unsigned int *)(v51 + ((4 * v33) | 4)) >> 15) & 0x1FFFE)) << 16);
              v31.i32[0] = *(unsigned __int16 *)(v57 + 2 * (unsigned __int16)*(_DWORD *)(v51 + ((4 * v33) | 8))) | (*(unsigned __int16 *)(v57 + (((unint64_t)*(unsigned int *)(v51 + ((4 * v33) | 8)) >> 15) & 0x1FFFE)) << 16);
              v31.i32[2] = *(unsigned __int16 *)(v57 + 2 * (unsigned __int16)*(_DWORD *)(v51 + ((4 * v33) | 0xC))) | (*(unsigned __int16 *)(v57 + (((unint64_t)*(unsigned int *)(v51 + ((4 * v33) | 0xC)) >> 15) & 0x1FFFE)) << 16);
              int32x4_t v31 = vzip2q_s32(vuzp1q_s32(v31, v31), v32);
              int32x4_t v30 = vzip1q_s32(vuzp1q_s32(v30, v30), v32);
              *uint64_t v34 = v30;
              v34[1] = v31;
              v34 += 2;
              unint64_t v33 = v43;
              v43 += 4;
            }
            while (v43 <= a7);
            unint64_t v33 = v43 - 4;
          }
          if (v33 < a7)
          {
            do
            {
              LODWORD(v44) = *(unsigned __int16 *)(v57 + 2 * (unsigned __int16)*(_DWORD *)(v51 + 4 * v33)) | (*(unsigned __int16 *)(v57 + (((unint64_t)*(unsigned int *)(v51 + 4 * v33) >> 15) & 0x1FFFE)) << 16);
              HIDWORD(v44) = v23;
              v34->i64[0] = v44;
              uint64_t v34 = (int32x4_t *)((char *)v34 + 8);
              ++v33;
            }
            while (a7 != v33);
          }
        }
      }
      else
      {
        uint64_t v51 = 0;
      }
      a9 = (int32x4_t *)((char *)a9 + a10);
      v25 += v28;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
}

unint64_t Read2_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, int8x16_t *a9, uint64_t a10, uint64_t a11)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v18 = _D0;
  }
  else
  {
    unsigned int v18 = 32256;
  }
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v20 = v19;
  uint64_t v70 = *(unsigned int *)(a3 + 44);
  unsigned int v21 = *(_DWORD *)(a3 + 60);
  int16x8_t v72 = *(ChannelDescription **)(a5 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v21);
  unint64_t v25 = *(void *)(a2 + 56);
  uint64_t v26 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v26 < HIDWORD(v25))
  {
    int v28 = *(_DWORD *)(a3 + 28) * HIDWORD(v25);
    v23.i32[0] = v18;
    int16x8_t v29 = vdupq_n_s16(v18);
    unsigned __int16 v71 = vmovl_u16(v23).u16[0];
    do
    {
      int16x8_t v75 = v29;
      long long v76 = v24;
      unint64_t result = ChannelDescription::GetLocationForTile(v72, (v28 + v26), v20, v21);
      int16x8_t v29 = v75;
      long long v24 = v76;
      uint64_t v31 = a1 + result;
      if (HIDWORD(result)) {
        _ZF = v31 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        if (a7 >= 0x10)
        {
          uint64_t v35 = 0;
          unint64_t v36 = (unsigned __int16 *)(v31 + 2 * v70 + 30);
          int32x4_t v37 = a9;
          do
          {
            uint64_t v38 = *(v36 - 15);
            int32x4_t v39 = (_WORD *)(a11 + 2 * *(v36 - 14));
            int32x4_t v40 = (_WORD *)(a11 + 2 * *(v36 - 13));
            int32x4_t v41 = (_WORD *)(a11 + 2 * *(v36 - 12));
            unint64_t v42 = (_WORD *)(a11 + 2 * *(v36 - 11));
            unint64_t v43 = (_WORD *)(a11 + 2 * *(v36 - 10));
            unint64_t result = a11 + 2 * *(v36 - 9);
            uint64_t v44 = (_WORD *)(a11 + 2 * *(v36 - 8));
            uint64_t v45 = *(v36 - 7);
            int32x4_t v46 = (__int16 *)(a11 + 2 * *(v36 - 6));
            int32x4_t v47 = (__int16 *)(a11 + 2 * *(v36 - 5));
            int32x4_t v48 = (__int16 *)(a11 + 2 * *(v36 - 4));
            int32x4_t v49 = (_WORD *)(a11 + 2 * *(v36 - 3));
            int32x4_t v50 = (_WORD *)(a11 + 2 * *(v36 - 2));
            uint64_t v51 = (_WORD *)(a11 + 2 * *(v36 - 1));
            unsigned int v52 = *v36;
            v36 += 16;
            __int16 v53 = *(_WORD *)(a11 + 2 * v45);
            __int16 v54 = *v46;
            __int16 v55 = *v47;
            __int16 v56 = *v48;
            LOWORD(v30) = *v49;
            WORD1(v30) = *v50;
            WORD2(v30) = *v51;
            HIWORD(v30) = *(_WORD *)(a11 + 2 * v52);
            LOWORD(v24) = *(_WORD *)(a11 + 2 * v38);
            WORD1(v24) = *v39;
            WORD2(v24) = *v40;
            WORD3(v24) = *v41;
            WORD4(v24) = *v42;
            WORD5(v24) = *v43;
            WORD6(v24) = *(_WORD *)result;
            HIWORD(v24) = *v44;
            int16x8_t v57 = v75;
            uint64_t v34 = v37 + 4;
            v37[2] = vqtbl2q_s8(*(int8x16x2_t *)(&v30 - 3), (int8x16_t)xmmword_228F41C10);
            v37[3] = vqtbl2q_s8(*(int8x16x2_t *)(&v30 - 3), (int8x16_t)xmmword_228F41BF0);
            unint64_t v33 = v35 + 16;
            unint64_t v58 = v35 + 32;
            *int32x4_t v37 = vqtbl2q_s8(*(int8x16x2_t *)(&v24 - 1), (int8x16_t)xmmword_228F41C10);
            v37[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v24 - 1), (int8x16_t)xmmword_228F41BF0);
            v35 += 16;
            v37 += 4;
          }
          while (v58 <= a7);
        }
        else
        {
          unint64_t v33 = 0;
          uint64_t v34 = a9;
        }
        if ((v33 | 4) <= a7)
        {
          uint64_t v60 = v31 + 2 * v70;
          do
          {
            __int16 v61 = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v60 + 2 * v33));
            __int16 v62 = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v60 + ((2 * v33) | 2)));
            __int16 v63 = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v60 + ((2 * v33) | 4)));
            __int16 v64 = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v60 + ((2 * v33) | 6)));
            int16x8_t v65 = v75;
            *v34++ = vqtbl2q_s8(*(int8x16x2_t *)(&v30 - 3), (int8x16_t)xmmword_228F41C10);
            unint64_t v59 = v33 + 4;
            unint64_t v66 = v33 + 8;
            v33 += 4;
          }
          while (v66 <= a7);
        }
        else
        {
          unint64_t v59 = v33;
        }
        uint64_t v67 = a7 - v59;
        if (a7 > v59)
        {
          uint64_t v68 = (unsigned __int16 *)(v31 + 2 * v70 + 2 * v59);
          do
          {
            unsigned int v69 = *v68++;
            v34->i16[1] = *(_WORD *)(a11 + 2 * v69);
            v34->i16[0] = v71;
            uint64_t v34 = (int8x16_t *)((char *)v34 + 4);
            --v67;
          }
          while (v67);
        }
      }
      a9 = (int8x16_t *)((char *)a9 + a10);
      v26 += a8;
    }
    while (v26 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

void Read2_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, int32x4_t *a9, uint64_t a10, uint64_t a11)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    *(float *)&unsigned int v16 = **(double **)a4;
    unsigned int v17 = v16;
  }
  else
  {
    unsigned int v17 = 2143289344;
  }
  int v18 = *(_DWORD *)(a2 + 60);
  uint64_t v19 = *(ChannelDescription **)(a5 + 8);
  uint64_t v20 = *(void *)(a3 + 24);
  LODWORD(v59) = v20;
  uint64_t v55 = a1;
  __int16 v56 = v19;
  unint64_t v21 = (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * v18);
  unsigned int v58 = *(_DWORD *)(a3 + 44);
  uint64_t v60 = a11;
  unsigned int v61 = *(_DWORD *)(a3 + 60);
  unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v19, v21, v20, v61);
  uint64_t v23 = a1 + LocationForTile + 4 * v58;
  if (!HIDWORD(LocationForTile)) {
    uint64_t v23 = 0;
  }
  uint64_t v54 = v23;
  unint64_t v24 = *(void *)(a2 + 56);
  uint64_t v25 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v25 < HIDWORD(v24))
  {
    int v27 = *(_DWORD *)(a3 + 28) * HIDWORD(v24);
    int32x4_t v28 = vdupq_n_s32(v17);
    unsigned int v29 = v17;
    uint64_t v30 = a8;
    unsigned int v48 = v29;
    int32x4_t v49 = vuzp1q_s32(v28, v28);
    do
    {
      int v57 = v27 + v25;
      unint64_t v31 = ChannelDescription::GetLocationForTile(v56, (v27 + v25), v59, v61);
      if (HIDWORD(v31))
      {
        uint64_t v54 = v55 + v31 + 4 * v58;
        int32x4_t v32 = v49;
        if (v55 + v31)
        {
          if (a7 >= 0x10)
          {
            uint64_t v35 = 0;
            unint64_t v36 = a9;
            do
            {
              AXRLUTStream<unsigned int,(StreamType)1>::load16(&v54, v35, (uint64_t)&v50);
              int32x4_t v32 = v49;
              int32x4_t v37 = vzip2q_s32(v49, v53);
              int32x4_t v38 = vzip1q_s32(v49, v53);
              int32x4_t v39 = vzip2q_s32(v49, v52);
              int32x4_t v40 = vzip1q_s32(v49, v52);
              int32x4_t v41 = vzip2q_s32(v49, v51);
              int32x4_t v42 = vzip1q_s32(v49, v51);
              int32x4_t v43 = vzip2q_s32(v49, v50);
              uint64_t v34 = v36 + 8;
              *unint64_t v36 = vzip1q_s32(v49, v50);
              v36[1] = v43;
              v36[2] = v42;
              v36[3] = v41;
              v36[4] = v40;
              v36[5] = v39;
              v36[6] = v38;
              v36[7] = v37;
              unint64_t v33 = v35 + 16;
              unint64_t v44 = v35 + 32;
              v35 += 16;
              v36 += 8;
            }
            while (v44 <= a7);
          }
          else
          {
            unint64_t v33 = 0;
            uint64_t v34 = a9;
          }
          unint64_t v45 = v33 | 4;
          if ((v33 | 4) <= a7)
          {
            do
            {
              v46.i16[0] = *(_WORD *)(v60 + 2 * (unsigned __int16)*(_DWORD *)(v54 + 4 * v33));
              v46.i16[1] = *(_WORD *)(v60 + (((unint64_t)*(unsigned int *)(v54 + 4 * v33) >> 15) & 0x1FFFE));
              v46.i16[2] = *(_WORD *)(v60 + 2 * (unsigned __int16)*(_DWORD *)(v54 + ((4 * v33) | 4)));
              v46.i16[3] = *(_WORD *)(v60
                                    + (((unint64_t)*(unsigned int *)(v54 + ((4 * v33) | 4)) >> 15) & 0x1FFFE));
              v46.i16[4] = *(_WORD *)(v60 + 2 * (unsigned __int16)*(_DWORD *)(v54 + ((4 * v33) | 8)));
              v46.i16[5] = *(_WORD *)(v60
                                    + (((unint64_t)*(unsigned int *)(v54 + ((4 * v33) | 8)) >> 15) & 0x1FFFE));
              v46.i16[6] = *(_WORD *)(v60 + 2 * (unsigned __int16)*(_DWORD *)(v54 + ((4 * v33) | 0xC)));
              v46.i16[7] = *(_WORD *)(v60
                                    + (((unint64_t)*(unsigned int *)(v54 + ((4 * v33) | 0xC)) >> 15) & 0x1FFFE));
              *uint64_t v34 = vzip1q_s32(v32, v46);
              v34[1] = vzip2q_s32(v32, v46);
              v34 += 2;
              unint64_t v33 = v45;
              v45 += 4;
            }
            while (v45 <= a7);
            unint64_t v33 = v45 - 4;
          }
          if (v33 < a7)
          {
            do
            {
              LODWORD(v47) = v48;
              HIDWORD(v47) = *(unsigned __int16 *)(v60 + 2 * (unsigned __int16)*(_DWORD *)(v54 + 4 * v33)) | (*(unsigned __int16 *)(v60 + (((unint64_t)*(unsigned int *)(v54 + 4 * v33) >> 15) & 0x1FFFE)) << 16);
              v34->i64[0] = v47;
              uint64_t v34 = (int32x4_t *)((char *)v34 + 8);
              ++v33;
            }
            while (a7 != v33);
          }
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      a9 = (int32x4_t *)((char *)a9 + a10);
      v25 += v30;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
}

unint64_t Read2_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, _OWORD *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v17 = *(void *)(a3 + 24);
  uint64_t v56 = *(unsigned int *)(a3 + 44);
  uint64_t v62 = v17;
  __int16 v63 = *(ChannelDescription **)(a4 + 8);
  unsigned int v61 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v63, (*(_DWORD *)(a3 + 52) + HIDWORD(v17) * *(_DWORD *)(a2 + 60)), v17, v61);
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v55 = *(unsigned int *)(a3 + 44);
  unsigned int v19 = *(_DWORD *)(a3 + 60);
  uint64_t v59 = v18;
  uint64_t v60 = *(ChannelDescription **)(a5 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v60, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v19);
  unint64_t v21 = *(void *)(a2 + 56);
  uint64_t v22 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v22 < HIDWORD(v21))
  {
    uint64_t v58 = a8;
    int v57 = *(_DWORD *)(a3 + 28) * HIDWORD(v21);
    do
    {
      unint64_t v24 = (v57 + v22);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v63, v24, v62, v61);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v26 = LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v60, v24, v59, v19);
        if (HIDWORD(result))
        {
          uint64_t v27 = a1 + v26;
          uint64_t v28 = a1 + result;
          if (v27 && v28 != 0)
          {
            uint64_t v30 = v27 + 2 * v56;
            uint64_t v31 = v28 + 2 * v55;
            if (a7 >= 0x10)
            {
              uint64_t v34 = 0;
              uint64_t v35 = 16;
              unint64_t v36 = a9;
              do
              {
                LOWORD(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 - 16));
                WORD1(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 - 16));
                WORD2(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 - 14));
                WORD3(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 - 14));
                WORD4(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 - 12));
                WORD5(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 - 12));
                WORD6(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 - 10));
                HIWORD(v37) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 - 10));
                LOWORD(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + 2 * v34 + 8));
                WORD1(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + 2 * v34 + 8));
                WORD2(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 - 6));
                WORD3(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 - 6));
                WORD4(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 - 4));
                WORD5(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 - 4));
                WORD6(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 - 2));
                HIWORD(v38) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 - 2));
                LOWORD(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35));
                WORD1(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35));
                WORD2(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 + 2));
                WORD3(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 + 2));
                WORD4(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 + 4));
                WORD5(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 + 4));
                WORD6(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 + 6));
                HIWORD(v39) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 + 6));
                LOWORD(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 + 8));
                WORD1(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 + 8));
                WORD2(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 + 10));
                WORD3(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 + 10));
                WORD4(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 + 12));
                WORD5(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 + 12));
                WORD6(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v35 + 14));
                HIWORD(v40) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v35 + 14));
                unint64_t v33 = v36 + 4;
                unint64_t v32 = v34 + 16;
                v36[2] = v39;
                v36[3] = v40;
                unint64_t v41 = v34 + 32;
                v35 += 32;
                v34 += 16;
                *unint64_t v36 = v37;
                v36[1] = v38;
                v36 += 4;
              }
              while (v41 <= a7);
            }
            else
            {
              unint64_t v32 = 0;
              unint64_t v33 = a9;
            }
            if ((v32 | 4) <= a7)
            {
              do
              {
                uint64_t v43 = (2 * v32) | 2;
                uint64_t v44 = (2 * v32) | 4;
                uint64_t v45 = (2 * v32) | 6;
                int32x4_t v46 = (_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v44));
                unint64_t result = a11 + 2 * *(unsigned __int16 *)(v31 + v44);
                LOWORD(v47) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + 2 * v32));
                WORD1(v47) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + 2 * v32));
                WORD2(v47) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v43));
                WORD3(v47) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v43));
                WORD4(v47) = *v46;
                WORD5(v47) = *(_WORD *)result;
                WORD6(v47) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v30 + v45));
                HIWORD(v47) = *(_WORD *)(a11 + 2 * *(unsigned __int16 *)(v31 + v45));
                *v33++ = v47;
                unint64_t v42 = v32 + 4;
                unint64_t v48 = v32 + 8;
                v32 += 4;
              }
              while (v48 <= a7);
            }
            else
            {
              unint64_t v42 = v32;
            }
            uint64_t v49 = a7 - v42;
            if (a7 > v42)
            {
              int32x4_t v50 = (unsigned __int16 *)(v27 + 2 * v56 + 2 * v42);
              int32x4_t v51 = (unsigned __int16 *)(v28 + 2 * v55 + 2 * v42);
              do
              {
                unsigned int v52 = *v50++;
                __int16 v53 = *(_WORD *)(a11 + 2 * v52);
                unsigned int v54 = *v51++;
                *((_WORD *)v33 + 1) = *(_WORD *)(a11 + 2 * v54);
                *(_WORD *)unint64_t v33 = v53;
                unint64_t v33 = (_OWORD *)((char *)v33 + 4);
                --v49;
              }
              while (v49);
            }
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v60, v24, v59, v19);
      }
      a9 = (_OWORD *)((char *)a9 + a10);
      v22 += v58;
    }
    while (v22 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

void Read2_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, int32x4_t *a9, uint64_t a10, uint64_t a11)
{
  int v17 = *(_DWORD *)(a2 + 60);
  uint64_t v18 = *(ChannelDescription **)(a4 + 8);
  uint64_t v19 = *(void *)(a3 + 24);
  unsigned int v79 = v19;
  uint64_t v75 = a1;
  long long v76 = v18;
  unint64_t v20 = (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * v17);
  unsigned int v78 = *(_DWORD *)(a3 + 44);
  uint64_t v80 = a11;
  unsigned int v81 = *(_DWORD *)(a3 + 60);
  unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v18, v20, v19, v81);
  uint64_t v22 = a1 + LocationForTile + 4 * v78;
  if (!HIDWORD(LocationForTile)) {
    uint64_t v22 = 0;
  }
  uint64_t v74 = v22;
  int v23 = *(_DWORD *)(a2 + 60);
  unint64_t v24 = *(ChannelDescription **)(a5 + 8);
  uint64_t v25 = *(void *)(a3 + 24);
  LODWORD(v71) = v25;
  uint64_t v67 = a1;
  uint64_t v68 = v24;
  uint64_t v26 = *(unsigned int *)(a3 + 44);
  unsigned int v69 = *(_DWORD *)(a3 + 52) + HIDWORD(v25) * v23;
  unsigned int v70 = v26;
  uint64_t v72 = a11;
  unsigned int v73 = *(_DWORD *)(a3 + 60);
  unint64_t v27 = ChannelDescription::GetLocationForTile(v24, v69, v25, v73);
  uint64_t v28 = a1 + v27 + 4 * v26;
  if (!HIDWORD(v27)) {
    uint64_t v28 = 0;
  }
  uint64_t v66 = v28;
  unint64_t v29 = *(void *)(a2 + 56);
  uint64_t v30 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v30 < HIDWORD(v29))
  {
    int v32 = *(_DWORD *)(a3 + 28) * HIDWORD(v29);
    uint64_t v33 = a8;
    do
    {
      int v77 = v32 + v30;
      unint64_t v34 = ChannelDescription::GetLocationForTile(v76, (v32 + v30), v79, v81);
      uint64_t v35 = v75 + v34 + 4 * v78;
      if (!HIDWORD(v34)) {
        uint64_t v35 = 0;
      }
      uint64_t v74 = v35;
      unsigned int v69 = v32 + v30;
      unint64_t v36 = ChannelDescription::GetLocationForTile(v68, (v32 + v30), v71, v73);
      if (HIDWORD(v36))
      {
        uint64_t v37 = v67 + v36;
        uint64_t v66 = v37 + 4 * v70;
        if (v74 && v37)
        {
          if (a7 >= 0x10)
          {
            uint64_t v40 = 0;
            unint64_t v41 = a9;
            do
            {
              AXRLUTStream<unsigned int,(StreamType)1>::load16(&v74, v40, (uint64_t)v65);
              int32x4_t v59 = (int32x4_t)v65[2];
              int32x4_t v60 = (int32x4_t)v65[3];
              int32x4_t v57 = (int32x4_t)v65[0];
              int32x4_t v58 = (int32x4_t)v65[1];
              AXRLUTStream<unsigned int,(StreamType)1>::load16(&v66, v40, (uint64_t)&v61);
              int32x4_t v42 = vzip1q_s32(v57, v61);
              int32x4_t v43 = vzip2q_s32(v57, v61);
              int32x4_t v44 = vzip1q_s32(v58, v62);
              int32x4_t v45 = vzip2q_s32(v58, v62);
              int32x4_t v46 = vzip1q_s32(v59, v63);
              int32x4_t v47 = vzip2q_s32(v59, v63);
              int32x4_t v48 = vzip2q_s32(v60, v64);
              long long v39 = v41 + 8;
              v41[6] = vzip1q_s32(v60, v64);
              v41[7] = v48;
              v41[4] = v46;
              v41[5] = v47;
              v41[2] = v44;
              void v41[3] = v45;
              *unint64_t v41 = v42;
              v41[1] = v43;
              unint64_t v38 = v40 + 16;
              unint64_t v49 = v40 + 32;
              v40 += 16;
              v41 += 8;
            }
            while (v49 <= a7);
          }
          else
          {
            unint64_t v38 = 0;
            long long v39 = a9;
          }
          unint64_t v50 = v38 | 4;
          while (v50 <= a7)
          {
            uint64_t v51 = (4 * v38) | 4;
            uint64_t v52 = (4 * v38) | 8;
            uint64_t v53 = (4 * v38) | 0xC;
            v54.i32[0] = *(unsigned __int16 *)(v80 + 2 * (unsigned __int16)*(_DWORD *)(v74 + v52)) | (*(unsigned __int16 *)(v80 + (((unint64_t)*(unsigned int *)(v74 + v52) >> 15) & 0x1FFFE)) << 16);
            v54.i32[1] = *(unsigned __int16 *)(v72 + 2 * (unsigned __int16)*(_DWORD *)(v66 + v52)) | (*(unsigned __int16 *)(v72 + (((unint64_t)*(unsigned int *)(v66 + v52) >> 15) & 0x1FFFE)) << 16);
            v54.i32[2] = *(unsigned __int16 *)(v80 + 2 * (unsigned __int16)*(_DWORD *)(v74 + v53)) | (*(unsigned __int16 *)(v80 + (((unint64_t)*(unsigned int *)(v74 + v53) >> 15) & 0x1FFFE)) << 16);
            v55.i32[0] = *(unsigned __int16 *)(v80 + 2 * (unsigned __int16)*(_DWORD *)(v74 + 4 * v38)) | (*(unsigned __int16 *)(v80 + (((unint64_t)*(unsigned int *)(v74 + 4 * v38) >> 15) & 0x1FFFE)) << 16);
            v55.i32[1] = *(unsigned __int16 *)(v72 + 2 * (unsigned __int16)*(_DWORD *)(v66 + 4 * v38)) | (*(unsigned __int16 *)(v72 + (((unint64_t)*(unsigned int *)(v66 + 4 * v38) >> 15) & 0x1FFFE)) << 16);
            v54.i32[3] = *(unsigned __int16 *)(v72 + 2 * (unsigned __int16)*(_DWORD *)(v66 + v53)) | (*(unsigned __int16 *)(v72 + (((unint64_t)*(unsigned int *)(v66 + v53) >> 15) & 0x1FFFE)) << 16);
            v55.i64[1] = __PAIR64__(*(unsigned __int16 *)(v72 + 2 * (unsigned __int16)*(_DWORD *)(v66 + v51)) | (*(unsigned __int16 *)(v72 + (((unint64_t)*(unsigned int *)(v66 + v51) >> 15) & 0x1FFFE)) << 16), *(unsigned __int16 *)(v80 + 2 * (unsigned __int16)*(_DWORD *)(v74 + v51)) | (*(unsigned __int16 *)(v80 + (((unint64_t)*(unsigned int *)(v74 + v51) >> 15) & 0x1FFFE)) << 16));
            *long long v39 = v55;
            v39[1] = v54;
            v39 += 2;
            unint64_t v50 = v38 + 8;
            v38 += 4;
          }
          if (v38 < a7)
          {
            do
            {
              LODWORD(v56) = *(unsigned __int16 *)(v80 + 2 * (unsigned __int16)*(_DWORD *)(v74 + 4 * v38)) | (*(unsigned __int16 *)(v80 + (((unint64_t)*(unsigned int *)(v74 + 4 * v38) >> 15) & 0x1FFFE)) << 16);
              HIDWORD(v56) = *(unsigned __int16 *)(v72 + 2 * (unsigned __int16)*(_DWORD *)(v66 + 4 * v38)) | (*(unsigned __int16 *)(v72 + (((unint64_t)*(unsigned int *)(v66 + 4 * v38) >> 15) & 0x1FFFE)) << 16);
              v39->i64[0] = v56;
              long long v39 = (int32x4_t *)((char *)v39 + 8);
              ++v38;
            }
            while (a7 != v38);
          }
        }
      }
      else
      {
        uint64_t v66 = 0;
      }
      a9 = (int32x4_t *)((char *)a9 + a10);
      v30 += v33;
    }
    while (v30 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
}

void Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t **a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v17 = _D0;
  }
  else
  {
    unsigned int v17 = 32256;
  }
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v19 = _D0;
  }
  else
  {
    unsigned int v19 = 32256;
  }
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v21 = _D0;
  }
  else
  {
    unsigned int v21 = 32256;
  }
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v23 = _D0;
  }
  else
  {
    unsigned int v23 = 32256;
  }
  uint64_t v24 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v24 < *(unsigned int *)(a2 + 60))
  {
    v36.val[0] = (int8x16_t)vdupq_n_s16(v17);
    int16x8_t v26 = vdupq_n_s16(v19);
    v36.val[1] = (int8x16_t)vdupq_n_s16(v21);
    v36.val[1] = vqtbl2q_s8(v36, (int8x16_t)xmmword_228F41C10);
    v37.val[1] = (int8x16_t)vdupq_n_s16(v23);
    v37.val[0] = (int8x16_t)vzip2q_s16((int16x8_t)v36.val[1], v26);
    int8x16_t v27 = vqtbl2q_s8(v37, (int8x16_t)xmmword_228F41C50);
    v37.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v36.val[1], v26);
    int8x16_t v28 = vqtbl2q_s8(v37, (int8x16_t)xmmword_228F41C70);
    LOWORD(v29) = v17;
    WORD1(v29) = v19;
    WORD2(v29) = v21;
    HIWORD(v29) = v23;
    do
    {
      if (a9 >= 4)
      {
        uint64_t v32 = 0;
        uint64_t v33 = a11;
        do
        {
          uint64_t v31 = v33 + 2;
          *uint64_t v33 = v28;
          v33[1] = v27;
          unint64_t v30 = v32 + 4;
          unint64_t v34 = v32 + 8;
          v32 += 4;
          v33 += 2;
        }
        while (v34 <= a9);
      }
      else
      {
        unint64_t v30 = 0;
        uint64_t v31 = a11;
      }
      _CF = a9 >= v30;
      unint64_t v35 = a9 - v30;
      if (v35 != 0 && _CF)
      {
        do
        {
          v31->i64[0] = v29;
          uint64_t v31 = (int8x16_t *)((char *)v31 + 8);
          --v35;
        }
        while (v35);
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v24 += a10;
    }
    while (v24 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
}

void Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, _OWORD *a11, uint64_t a12)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    float v12 = **(double **)a4;
    float v13 = v12;
  }
  else
  {
    float v13 = NAN;
  }
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    float v14 = **(double **)a5;
    float v15 = v14;
  }
  else
  {
    float v15 = NAN;
  }
  if (*(unsigned char *)(*(void *)a6 + 24))
  {
    float v16 = **(double **)a6;
    float v17 = v16;
  }
  else
  {
    float v17 = NAN;
  }
  if (*(unsigned char *)(*(void *)a7 + 24))
  {
    float v18 = **(double **)a7;
    float v19 = v18;
  }
  else
  {
    float v19 = NAN;
  }
  uint64_t v20 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v20 < *(unsigned int *)(a2 + 60))
  {
    *(void *)&long long v22 = __PAIR64__(LODWORD(v15), LODWORD(v13));
    *((void *)&v22 + 1) = __PAIR64__(LODWORD(v19), LODWORD(v17));
    do
    {
      if (a9 >= 4)
      {
        uint64_t v25 = 0;
        int16x8_t v26 = a11;
        do
        {
          uint64_t v24 = v26 + 4;
          _OWORD *v26 = v22;
          v26[1] = v22;
          v26[2] = v22;
          v26[3] = v22;
          unint64_t v23 = v25 + 4;
          unint64_t v27 = v25 + 8;
          v25 += 4;
          v26 += 4;
        }
        while (v27 <= a9);
      }
      else
      {
        unint64_t v23 = 0;
        uint64_t v24 = a11;
      }
      BOOL v28 = a9 >= v23;
      unint64_t v29 = a9 - v23;
      if (v29 != 0 && v28)
      {
        do
        {
          *v24++ = v22;
          --v29;
        }
        while (v29);
      }
      a11 = (_OWORD *)((char *)a11 + a12);
      v20 += a10;
    }
    while (v20 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t **a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int16x8_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = *(unsigned int *)(a3 + 44);
  uint64_t v54 = v18;
  int32x4_t v55 = *(ChannelDescription **)(a4 + 8);
  unsigned int v53 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v55, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v53);
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v27 = _D0;
  }
  else
  {
    unsigned int v27 = 32256;
  }
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v29 = _D0;
  }
  else
  {
    unsigned int v29 = 32256;
  }
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v31 = _D0;
  }
  else
  {
    unsigned int v31 = 32256;
  }
  unint64_t v32 = *(void *)(a2 + 56);
  uint64_t v33 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v33 < HIDWORD(v32))
  {
    int v35 = *(_DWORD *)(a3 + 28) * HIDWORD(v32);
    v59.val[0] = (int8x16_t)vdupq_n_s16(v27);
    int16x8_t v36 = vdupq_n_s16(v29);
    v59.val[1] = (int8x16_t)vdupq_n_s16(v31);
    v22.i16[0] = v27;
    v22.i16[1] = v31;
    int16x8_t v52 = (int16x8_t)vqtbl2q_s8(v59, (int8x16_t)xmmword_228F41C10);
    int16x4_t v51 = v22;
    do
    {
      long long v57 = v21;
      int16x8_t v58 = v36;
      unint64_t result = ChannelDescription::GetLocationForTile(v55, (v35 + v33), v54, v53);
      long long v21 = v57;
      int16x8_t v36 = v58;
      uint64_t v38 = a1 + result;
      if (HIDWORD(result)) {
        _ZF = v38 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        if (a9 >= 4)
        {
          uint64_t v42 = 0;
          int32x4_t v43 = (unsigned __int16 *)(v38 + 2 * v19 + 4);
          int32x4_t v44 = a11;
          do
          {
            LOWORD(v21) = *(_WORD *)(a13 + 2 * *(v43 - 2));
            WORD2(v21) = *(_WORD *)(a13 + 2 * *(v43 - 1));
            WORD4(v21) = *(_WORD *)(a13 + 2 * *v43);
            WORD6(v21) = *(_WORD *)(a13 + 2 * v43[1]);
            int16x8_t v45 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v21, (int8x16_t)xmmword_228F41C10);
            int16x8_t v46 = vzip1q_s16(v45, v52);
            int16x8_t v37 = vzip2q_s16(v45, v52);
            unint64_t v41 = v44 + 2;
            unint64_t v40 = v42 + 4;
            unint64_t v47 = v42 + 8;
            *int32x4_t v44 = v46;
            v44[1] = v37;
            v43 += 4;
            v42 += 4;
            v44 += 2;
          }
          while (v47 <= a9);
        }
        else
        {
          unint64_t v40 = 0;
          unint64_t v41 = a11;
        }
        uint64_t v48 = a9 - v40;
        if (a9 > v40)
        {
          unint64_t v49 = (unsigned __int16 *)(v38 + 2 * v19 + 2 * v40);
          do
          {
            unsigned int v50 = *v49++;
            v37.i16[0] = *(_WORD *)(a13 + 2 * v50);
            v37.i16[2] = v29;
            *(int16x4_t *)v37.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v37.i8, *(int16x4_t *)v37.i8), v51);
            v41->i64[0] = v37.i64[0];
            unint64_t v41 = (int16x8_t *)((char *)v41 + 8);
            --v48;
          }
          while (v48);
        }
      }
      a11 = (int16x8_t *)((char *)a11 + a12);
      v33 += a10;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = *(unsigned int *)(a3 + 44);
  uint64_t v58 = v18;
  int8x16x2_t v59 = *(ChannelDescription **)(a4 + 8);
  unsigned int v57 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v59, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v57);
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    float v22 = **(double **)a5;
    float v23 = v22;
  }
  else
  {
    float v23 = NAN;
  }
  if (*(unsigned char *)(*(void *)a6 + 24))
  {
    *(float *)&unsigned int v24 = **(double **)a6;
    unsigned int v25 = v24;
  }
  else
  {
    unsigned int v25 = 2143289344;
  }
  if (*(unsigned char *)(*(void *)a7 + 24))
  {
    float v26 = **(double **)a7;
    float v27 = v26;
  }
  else
  {
    float v27 = NAN;
  }
  unint64_t v28 = *(void *)(a2 + 56);
  uint64_t v29 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v29 < HIDWORD(v28))
  {
    int v31 = *(_DWORD *)(a3 + 28) * HIDWORD(v28);
    v21.i64[0] = __PAIR64__(LODWORD(v27), LODWORD(v23));
    v32.i64[0] = __PAIR64__(LODWORD(v27), LODWORD(v23));
    v32.i64[1] = __PAIR64__(LODWORD(v27), LODWORD(v23));
    int32x4_t v55 = v21;
    int32x4_t v56 = vdupq_n_s32(v25);
    int32x4_t v54 = v32;
    do
    {
      unint64_t result = ChannelDescription::GetLocationForTile(v59, (v31 + v29), v58, v57);
      uint64_t v35 = a1 + result;
      if (HIDWORD(result)) {
        BOOL v36 = v35 == 0;
      }
      else {
        BOOL v36 = 1;
      }
      if (!v36)
      {
        if (a9 >= 4)
        {
          uint64_t v39 = 0;
          unint64_t v40 = (unsigned int *)(v35 + 4 * v19 + 8);
          unint64_t v41 = a11;
          do
          {
            int v42 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 2) >> 15) & 0x1FFFE)) << 16);
            int v43 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 1)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 1) >> 15) & 0x1FFFE)) << 16);
            unint64_t v44 = *v40;
            unint64_t v45 = v40[1];
            v40 += 4;
            v33.i32[0] = v42;
            v33.i32[2] = v43;
            v34.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v44) | (*(unsigned __int16 *)(a13 + ((v44 >> 15) & 0x1FFFE)) << 16);
            v34.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v45) | (*(unsigned __int16 *)(a13 + ((v45 >> 15) & 0x1FFFE)) << 16);
            int32x4_t v46 = vzip2q_s32(vuzp1q_s32(v34, v34), v56);
            int32x4_t v47 = vzip1q_s32(vuzp1q_s32(v33, v33), v56);
            int32x4_t v48 = vzip1q_s32(v47, v54);
            int32x4_t v33 = vzip2q_s32(v47, v54);
            int32x4_t v49 = vzip1q_s32(v46, v54);
            int32x4_t v34 = vzip2q_s32(v46, v54);
            uint64_t v38 = v41 + 4;
            v41[2] = v49;
            void v41[3] = v34;
            unint64_t v37 = v39 + 4;
            unint64_t v50 = v39 + 8;
            *unint64_t v41 = v48;
            v41[1] = v33;
            v39 += 4;
            v41 += 4;
          }
          while (v50 <= a9);
        }
        else
        {
          unint64_t v37 = 0;
          uint64_t v38 = a11;
        }
        uint64_t v51 = a9 - v37;
        if (a9 > v37)
        {
          int16x8_t v52 = (unsigned int *)(v35 + 4 * v19 + 4 * v37);
          do
          {
            unsigned int v53 = *v52++;
            v33.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v53) | (*(unsigned __int16 *)(a13 + (((unint64_t)v53 >> 15) & 0x1FFFE)) << 16);
            v33.i32[2] = v25;
            int32x4_t v33 = vzip1q_s32(vuzp1q_s32(v33, v33), v55);
            *v38++ = v33;
            --v51;
          }
          while (v51);
        }
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v29 += a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t a5, uint64_t **a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12, uint64_t a13)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v20 = _D0;
  }
  else
  {
    unsigned int v20 = 32256;
  }
  uint64_t v21 = *(void *)(a3 + 24);
  uint64_t v22 = *(unsigned int *)(a3 + 44);
  unsigned int v23 = *(_DWORD *)(a3 + 60);
  uint64_t v53 = v21;
  int32x4_t v54 = *(ChannelDescription **)(a5 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v54, (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60)), v21, v23);
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v29 = _D0;
  }
  else
  {
    unsigned int v29 = 32256;
  }
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v31 = _D0;
  }
  else
  {
    unsigned int v31 = 32256;
  }
  unint64_t v32 = *(void *)(a2 + 56);
  uint64_t v33 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v33 < HIDWORD(v32))
  {
    v63.val[0] = (int8x16_t)vdupq_n_s16(v20);
    __int32 v35 = v20;
    int v36 = *(_DWORD *)(a3 + 28) * HIDWORD(v32);
    v63.val[1] = (int8x16_t)vdupq_n_s16(v29);
    v63.val[0] = vqtbl2q_s8(v63, (int8x16_t)xmmword_228F41C10);
    int16x8_t v37 = vdupq_n_s16(v31);
    int16x8_t v38 = vzip2q_s16((int16x8_t)v63.val[0], (int16x8_t)v63.val[0]);
    v63.val[1].i32[0] = v35;
    v63.val[1].i16[2] = v29;
    int16x8_t v39 = vzip1q_s16((int16x8_t)v63.val[0], (int16x8_t)v63.val[0]);
    int16x4_t v40 = vuzp1_s16(*(int16x4_t *)v63.val[1].i8, *(int16x4_t *)v63.val[1].i8);
    do
    {
      int16x8_t v57 = v39;
      int8x16_t v58 = v27;
      int16x8_t v59 = v38;
      int8x16_t v60 = v26;
      long long v61 = v25;
      int16x8_t v62 = v37;
      unint64_t result = ChannelDescription::GetLocationForTile(v54, (v36 + v33), v53, v23);
      int16x8_t v39 = v57;
      int8x16_t v27 = v58;
      int16x8_t v38 = v59;
      int8x16_t v26 = v60;
      long long v25 = v61;
      int16x8_t v37 = v62;
      uint64_t v42 = a1 + result;
      if (HIDWORD(result)) {
        _ZF = v42 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        if (a9 >= 4)
        {
          uint64_t v46 = 0;
          int32x4_t v47 = (unsigned __int16 *)(v42 + 2 * v22 + 4);
          int32x4_t v48 = a11;
          do
          {
            LOWORD(v25) = *(_WORD *)(a13 + 2 * *(v47 - 2));
            WORD2(v25) = *(_WORD *)(a13 + 2 * *(v47 - 1));
            WORD4(v25) = *(_WORD *)(a13 + 2 * *v47);
            WORD6(v25) = *(_WORD *)(a13 + 2 * v47[1]);
            int8x16_t v27 = vqtbl2q_s8(*(int8x16x2_t *)&v25, (int8x16_t)xmmword_228F41C10);
            int8x16_t v41 = vqtbl2q_s8(*(int8x16x2_t *)(&v27 - 1), (int8x16_t)xmmword_228F41C10);
            int8x16_t v26 = v27;
            unint64_t v45 = v48 + 2;
            unint64_t v44 = v46 + 4;
            unint64_t v49 = v46 + 8;
            *int32x4_t v48 = v41;
            v48[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v26 - 1), (int8x16_t)xmmword_228F41BF0);
            v47 += 4;
            v46 += 4;
            v48 += 2;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v44 = 0;
          unint64_t v45 = a11;
        }
        uint64_t v50 = a9 - v44;
        if (a9 > v44)
        {
          uint64_t v51 = (unsigned __int16 *)(v42 + 2 * v22 + 2 * v44);
          do
          {
            unsigned int v52 = *v51++;
            v41.i16[0] = *(_WORD *)(a13 + 2 * v52);
            v41.i16[1] = v31;
            *(int16x4_t *)v41.i8 = vzip1_s16(v40, *(int16x4_t *)v41.i8);
            v45->i64[0] = v41.i64[0];
            unint64_t v45 = (int8x16_t *)((char *)v45 + 8);
            --v50;
          }
          while (v50);
        }
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v33 += a10;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    float v16 = **(double **)a4;
    float v17 = v16;
  }
  else
  {
    float v17 = NAN;
  }
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = *(unsigned int *)(a3 + 44);
  unsigned int v20 = *(_DWORD *)(a3 + 60);
  uint64_t v54 = v18;
  int32x4_t v55 = *(ChannelDescription **)(a5 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v55, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v20);
  unsigned int v23 = *a6;
  if (*((unsigned char *)*a6 + 24))
  {
    v22.i64[0] = *v23;
    *(float *)v22.i32 = *(double *)v23;
    int v24 = v22.i32[0];
  }
  else
  {
    int v24 = 2143289344;
  }
  long long v25 = *a7;
  if (*((unsigned char *)*a7 + 24))
  {
    v22.i64[0] = *v25;
    *(float *)v22.i32 = *(double *)v25;
    unsigned int v26 = v22.i32[0];
  }
  else
  {
    unsigned int v26 = 2143289344;
  }
  unint64_t v27 = *(void *)(a2 + 56);
  uint64_t v28 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v28 < HIDWORD(v27))
  {
    int v30 = *(_DWORD *)(a3 + 28) * HIDWORD(v27);
    *(float *)v22.i32 = v17;
    v22.i32[2] = v24;
    int32x4_t v52 = vuzp1q_s32(v22, v22);
    int32x4_t v53 = vdupq_n_s32(v26);
    do
    {
      unint64_t result = ChannelDescription::GetLocationForTile(v55, (v30 + v28), v54, v20);
      uint64_t v33 = a1 + result;
      if (HIDWORD(result)) {
        BOOL v34 = v33 == 0;
      }
      else {
        BOOL v34 = 1;
      }
      if (!v34)
      {
        if (a9 >= 4)
        {
          uint64_t v37 = 0;
          int16x8_t v38 = (unsigned int *)(v33 + 4 * v19 + 8);
          int16x8_t v39 = a11;
          do
          {
            int v40 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v38 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v38 - 2) >> 15) & 0x1FFFE)) << 16);
            int v41 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v38 - 1)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v38 - 1) >> 15) & 0x1FFFE)) << 16);
            unint64_t v42 = *v38;
            unint64_t v43 = v38[1];
            v38 += 4;
            v31.i32[0] = v40;
            v31.i32[2] = v41;
            v32.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v42) | (*(unsigned __int16 *)(a13 + ((v42 >> 15) & 0x1FFFE)) << 16);
            v32.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v43) | (*(unsigned __int16 *)(a13 + ((v43 >> 15) & 0x1FFFE)) << 16);
            int32x4_t v44 = vzip2q_s32(vuzp1q_s32(v32, v32), v53);
            int32x4_t v45 = vzip1q_s32(vuzp1q_s32(v31, v31), v53);
            int32x4_t v46 = vzip1q_s32(v52, v45);
            int32x4_t v31 = vzip2q_s32(v52, v45);
            int32x4_t v47 = vzip1q_s32(v52, v44);
            int32x4_t v32 = vzip2q_s32(v52, v44);
            int v36 = v39 + 4;
            v39[2] = v47;
            v39[3] = v32;
            unint64_t v35 = v37 + 4;
            unint64_t v48 = v37 + 8;
            *int16x8_t v39 = v46;
            v39[1] = v31;
            v37 += 4;
            v39 += 4;
          }
          while (v48 <= a9);
        }
        else
        {
          unint64_t v35 = 0;
          int v36 = a11;
        }
        uint64_t v49 = a9 - v35;
        if (a9 > v35)
        {
          uint64_t v50 = (unsigned int *)(v33 + 4 * v19 + 4 * v35);
          do
          {
            unsigned int v51 = *v50++;
            v31.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v51) | (*(unsigned __int16 *)(a13 + (((unint64_t)v51 >> 15) & 0x1FFFE)) << 16);
            v31.i32[1] = v26;
            int32x4_t v31 = vzip1q_s32(v52, v31);
            *v36++ = v31;
            --v49;
          }
          while (v49);
        }
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v28 += a10;
    }
    while (v28 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int16x8_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v20 = *(unsigned int *)(a3 + 44);
  uint64_t v71 = v19;
  uint64_t v72 = *(ChannelDescription **)(a4 + 8);
  unsigned int v70 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v70);
  uint64_t v73 = a2;
  uint64_t v21 = *(void *)(a3 + 24);
  unint64_t v22 = (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60));
  uint64_t v23 = *(unsigned int *)(a3 + 44);
  uint64_t v68 = v21;
  unsigned int v69 = *(ChannelDescription **)(a5 + 8);
  unsigned int v67 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v69, v22, v21, v67);
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v31 = _D0;
  }
  else
  {
    unsigned int v31 = 32256;
  }
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v33 = _D0;
  }
  else
  {
    unsigned int v33 = 32256;
  }
  unint64_t v34 = *(void *)(v73 + 56);
  uint64_t v35 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v35 < HIDWORD(v34))
  {
    uint64_t v36 = v20;
    int v66 = *(_DWORD *)(a3 + 28) * HIDWORD(v34);
    int16x8_t v38 = vdupq_n_s16(v31);
    int16x8_t v39 = vdupq_n_s16(v33);
    uint64_t v65 = 2 * v23;
    uint64_t v63 = 2 * v36;
    uint64_t v64 = 2 * v23 + 4;
    uint64_t v62 = 2 * v36 + 4;
    do
    {
      int16x8_t v74 = v26;
      int8x16_t v75 = (int8x16_t)v39;
      long long v76 = v25;
      int16x8_t v77 = v38;
      unint64_t v40 = (v66 + v35);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v72, v40, v71, v70);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v42 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v69, v40, v68, v67);
        uint64_t v44 = a1 + result;
        if (HIDWORD(result)) {
          _ZF = v42 == 0;
        }
        else {
          _ZF = 1;
        }
        BOOL v46 = _ZF || v44 == 0;
        long long v25 = v76;
        int16x8_t v38 = v77;
        int16x8_t v26 = v74;
        int16x8_t v39 = (int16x8_t)v75;
        if (!v46)
        {
          if (a9 >= 4)
          {
            uint64_t v49 = 0;
            uint64_t v50 = (unsigned __int16 *)(v44 + v64);
            unsigned int v51 = (unsigned __int16 *)(v42 + v62);
            int32x4_t v52 = a11;
            do
            {
              LOWORD(v25) = *(_WORD *)(a13 + 2 * *(v51 - 2));
              WORD2(v25) = *(_WORD *)(a13 + 2 * *(v51 - 1));
              WORD4(v25) = *(_WORD *)(a13 + 2 * *v51);
              WORD6(v25) = *(_WORD *)(a13 + 2 * v51[1]);
              v43.i16[0] = *(_WORD *)(a13 + 2 * *(v50 - 2));
              v43.i16[2] = *(_WORD *)(a13 + 2 * *(v50 - 1));
              v43.i16[4] = *(_WORD *)(a13 + 2 * *v50);
              v43.i16[6] = *(_WORD *)(a13 + 2 * v50[1]);
              int16x8_t v53 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v25, (int8x16_t)xmmword_228F41C10);
              int16x8_t v26 = vzip1q_s16(v53, v43);
              v78.val[0] = (int8x16_t)vzip2q_s16(v53, v43);
              v78.val[1] = v75;
              int16x8_t v43 = (int16x8_t)vqtbl2q_s8(v78, (int8x16_t)xmmword_228F41C50);
              unint64_t v48 = v52 + 2;
              unint64_t v47 = v49 + 4;
              unint64_t v54 = v49 + 8;
              v50 += 4;
              *(int8x16_t *)int32x4_t v52 = vqtbl2q_s8(*(int8x16x2_t *)v26.i8, (int8x16_t)xmmword_228F41C70);
              v52[1] = v43;
              v51 += 4;
              v49 += 4;
              v52 += 2;
            }
            while (v54 <= a9);
          }
          else
          {
            unint64_t v47 = 0;
            unint64_t v48 = a11;
          }
          uint64_t v55 = a9 - v47;
          if (a9 > v47)
          {
            int32x4_t v56 = (unsigned __int16 *)(v42 + v63 + 2 * v47);
            int16x8_t v57 = (unsigned __int16 *)(v44 + v65 + 2 * v47);
            do
            {
              unsigned int v59 = *v56++;
              uint64_t v58 = v59;
              unsigned int v60 = *v57++;
              LOWORD(v61) = *(_WORD *)(a13 + 2 * v58);
              WORD1(v61) = *(_WORD *)(a13 + 2 * v60);
              WORD2(v61) = v31;
              HIWORD(v61) = v33;
              v48->i64[0] = v61;
              unint64_t v48 = (int16x8_t *)((char *)v48 + 8);
              --v55;
            }
            while (v55);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v69, v40, v68, v67);
        long long v25 = v76;
        int16x8_t v38 = v77;
        int16x8_t v26 = v74;
        int16x8_t v39 = (int16x8_t)v75;
      }
      a11 = (int16x8_t *)((char *)a11 + a12);
      v35 += a10;
    }
    while (v35 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(v73 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v20 = *(unsigned int *)(a3 + 44);
  uint64_t v84 = v19;
  int16x8_t v85 = *(ChannelDescription **)(a4 + 8);
  unsigned int v83 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v85, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v83);
  uint64_t v86 = a2;
  uint64_t v21 = *(void *)(a3 + 24);
  unint64_t v22 = (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60));
  uint64_t v23 = *(unsigned int *)(a3 + 44);
  uint64_t v81 = v21;
  int16x8_t v82 = *(ChannelDescription **)(a5 + 8);
  unsigned int v80 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v82, v22, v21, v80);
  if (*(unsigned char *)(*(void *)a6 + 24))
  {
    *(float *)&unsigned int v25 = **(double **)a6;
    unsigned int v26 = v25;
  }
  else
  {
    unsigned int v26 = 2143289344;
  }
  if (*(unsigned char *)(*(void *)a7 + 24))
  {
    *(float *)&unsigned int v27 = **(double **)a7;
    unsigned int v28 = v27;
  }
  else
  {
    unsigned int v28 = 2143289344;
  }
  unint64_t v29 = *(void *)(v86 + 56);
  uint64_t v30 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v30 < HIDWORD(v29))
  {
    uint64_t v31 = v20;
    int v79 = *(_DWORD *)(a3 + 28) * HIDWORD(v29);
    uint64_t v76 = 4 * v23;
    uint64_t v74 = 4 * v31;
    uint64_t v75 = 4 * v23 + 8;
    uint64_t v73 = 4 * v31 + 8;
    int32x4_t v77 = vdupq_n_s32(v28);
    int32x4_t v78 = vdupq_n_s32(v26);
    do
    {
      unint64_t v33 = (v79 + v30);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v85, v33, v84, v83);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v35 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v82, v33, v81, v80);
        uint64_t v40 = a1 + result;
        if (HIDWORD(result)) {
          BOOL v41 = v35 == 0;
        }
        else {
          BOOL v41 = 1;
        }
        if (!v41 && v40 != 0)
        {
          if (a9 >= 4)
          {
            uint64_t v45 = 0;
            BOOL v46 = (unsigned int *)(v40 + v75);
            unint64_t v47 = (unsigned int *)(v35 + v73);
            unint64_t v48 = a11;
            do
            {
              int v49 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v47 - 2));
              unint64_t v50 = ((unint64_t)*(v47 - 2) >> 15) & 0x1FFFE;
              int v51 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v47 - 1));
              unint64_t v52 = ((unint64_t)*(v47 - 1) >> 15) & 0x1FFFE;
              unint64_t v54 = *v47;
              unint64_t v53 = v47[1];
              v47 += 4;
              int v55 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v46 - 2));
              LODWORD(v50) = v49 | (*(unsigned __int16 *)(a13 + v50) << 16);
              int v56 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v46 - 2) >> 15) & 0x1FFFE));
              int v57 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v46 - 1));
              LODWORD(v52) = v51 | (*(unsigned __int16 *)(a13 + v52) << 16);
              int v58 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v54) | (*(unsigned __int16 *)(a13 + ((v54 >> 15) & 0x1FFFE)) << 16);
              LODWORD(v54) = *(unsigned __int16 *)(a13 + (((unint64_t)*(v46 - 1) >> 15) & 0x1FFFE));
              unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v53) | (*(unsigned __int16 *)(a13 + ((v53 >> 15) & 0x1FFFE)) << 16);
              unint64_t v59 = *v46;
              unint64_t v60 = v46[1];
              v46 += 4;
              v36.i32[0] = v50;
              v36.i32[2] = v52;
              v37.i32[0] = v58;
              v37.i32[2] = result;
              v38.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v59) | (*(unsigned __int16 *)(a13 + ((v59 >> 15) & 0x1FFFE)) << 16);
              v39.i32[0] = v55 | (v56 << 16);
              v38.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v60) | (*(unsigned __int16 *)(a13 + ((v60 >> 15) & 0x1FFFE)) << 16);
              v39.i32[2] = v57 | (v54 << 16);
              int32x4_t v61 = vzip2q_s32(vuzp1q_s32(v37, v37), v78);
              int32x4_t v62 = vzip1q_s32(vuzp1q_s32(v36, v36), v78);
              int32x4_t v63 = vzip1q_s32(v62, v39);
              v63.i32[3] = v77.i32[0];
              int32x4_t v36 = vzip2q_s32(v62, v39);
              v36.i32[3] = v77.i32[1];
              int32x4_t v39 = vzip1q_s32(v61, v38);
              v39.i32[3] = v77.i32[2];
              int32x4_t v37 = vzip2q_s32(v61, v38);
              v37.i32[3] = v77.i32[3];
              uint64_t v44 = v48 + 4;
              unint64_t v43 = v45 + 4;
              unint64_t v64 = v45 + 8;
              v48[2] = v39;
              v48[3] = v37;
              *unint64_t v48 = v63;
              v48[1] = v36;
              v45 += 4;
              v48 += 4;
            }
            while (v64 <= a9);
          }
          else
          {
            unint64_t v43 = 0;
            uint64_t v44 = a11;
          }
          uint64_t v65 = a9 - v43;
          if (a9 > v43)
          {
            int v66 = (unsigned int *)(v35 + v74 + 4 * v43);
            unsigned int v67 = (unsigned int *)(v40 + v76 + 4 * v43);
            do
            {
              unsigned int v68 = *v66++;
              uint64_t v69 = (unsigned __int16)v68;
              unint64_t v70 = (unint64_t)v68 >> 15;
              unsigned int v71 = *v67++;
              v72.i32[0] = *(unsigned __int16 *)(a13 + 2 * v69) | (*(unsigned __int16 *)(a13 + (v70 & 0x1FFFE)) << 16);
              v72.i32[1] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v71) | (*(unsigned __int16 *)(a13 + (((unint64_t)v71 >> 15) & 0x1FFFE)) << 16);
              v72.i64[1] = __PAIR64__(v28, v26);
              *v44++ = v72;
              --v65;
            }
            while (v65);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v82, v33, v81, v80);
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v30 += a10;
    }
    while (v30 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(v86 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int16x8_t *a11, uint64_t a12, uint64_t a13)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v19 = _D0;
  }
  else
  {
    unsigned int v19 = 32256;
  }
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v21 = _D0;
  }
  else
  {
    unsigned int v21 = 32256;
  }
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v23 = v22;
  uint64_t v24 = *(unsigned int *)(a3 + 44);
  unsigned int v25 = *(_DWORD *)(a3 + 60);
  int v56 = *(ChannelDescription **)(a6 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v56, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v25);
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v31 = _D0;
  }
  else
  {
    unsigned int v31 = 32256;
  }
  unint64_t v32 = *(void *)(a2 + 56);
  uint64_t v33 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v33 < HIDWORD(v32))
  {
    uint64_t v35 = v24;
    int v36 = *(_DWORD *)(a3 + 28) * HIDWORD(v32);
    v27.i32[0] = v19;
    int16x8_t v37 = vdupq_n_s16(v19);
    v61.val[0] = (int8x16_t)vdupq_n_s16(v21);
    v61.val[1] = (int8x16_t)vdupq_n_s16(v31);
    v29.i16[0] = v21;
    v29.i16[1] = v31;
    uint64_t v52 = 2 * v35;
    uint64_t v51 = 2 * v35 + 4;
    int16x4_t v55 = v27;
    int16x4_t v53 = v29;
    int16x8_t v54 = (int16x8_t)vqtbl2q_s8(v61, (int8x16_t)xmmword_228F41C10);
    do
    {
      int16x8_t v59 = v37;
      long long v60 = v28;
      unint64_t result = ChannelDescription::GetLocationForTile(v56, (v36 + v33), v23, v25);
      int16x8_t v37 = v59;
      long long v28 = v60;
      uint64_t v38 = a1 + result;
      if (HIDWORD(result)) {
        _ZF = v38 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        if (a9 >= 4)
        {
          uint64_t v42 = 0;
          unint64_t v43 = (unsigned __int16 *)(v38 + v51);
          uint64_t v44 = a11;
          do
          {
            LOWORD(v28) = *(_WORD *)(a13 + 2 * *(v43 - 2));
            WORD1(v28) = *(_WORD *)(a13 + 2 * *(v43 - 1));
            WORD2(v28) = *(_WORD *)(a13 + 2 * *v43);
            WORD3(v28) = *(_WORD *)(a13 + 2 * v43[1]);
            int16x8_t v45 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v28 - 1), (int8x16_t)xmmword_228F41C10);
            BOOL v41 = (int16x4_t *)&v44[2];
            unint64_t v40 = v42 + 4;
            unint64_t v46 = v42 + 8;
            *uint64_t v44 = vzip1q_s16(v45, v54);
            v44[1] = vzip2q_s16(v45, v54);
            v43 += 4;
            v42 += 4;
            v44 += 2;
          }
          while (v46 <= a9);
        }
        else
        {
          unint64_t v40 = 0;
          BOOL v41 = (int16x4_t *)a11;
        }
        uint64_t v47 = a9 - v40;
        if (a9 > v40)
        {
          unint64_t v48 = (unsigned __int16 *)(v38 + v52 + 2 * v40);
          do
          {
            unsigned int v49 = *v48++;
            int16x4_t v50 = v55;
            v50.i16[2] = *(_WORD *)(a13 + 2 * v49);
            *v41++ = vzip1_s16(vuzp1_s16(v50, v50), v53);
            --v47;
          }
          while (v47);
        }
      }
      a11 = (int16x8_t *)((char *)a11 + a12);
      v33 += a10;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    *(float *)&unsigned int v15 = **(double **)a4;
    unsigned int v16 = v15;
  }
  else
  {
    unsigned int v16 = 2143289344;
  }
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    float v17 = **(double **)a5;
    float v18 = v17;
  }
  else
  {
    float v18 = NAN;
  }
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v20 = v19;
  uint64_t v21 = *(unsigned int *)(a3 + 44);
  unsigned int v22 = *(_DWORD *)(a3 + 60);
  long long v60 = *(ChannelDescription **)(a6 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v60, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v22);
  if (*(unsigned char *)(*(void *)a7 + 24))
  {
    float v26 = **(double **)a7;
    float v27 = v26;
  }
  else
  {
    float v27 = NAN;
  }
  unint64_t v28 = *(void *)(a2 + 56);
  uint64_t v29 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v29 < HIDWORD(v28))
  {
    uint64_t v31 = v21;
    int v32 = *(_DWORD *)(a3 + 28) * HIDWORD(v28);
    int32x4_t v33 = vdupq_n_s32(v16);
    v24.i64[0] = __PAIR64__(LODWORD(v27), LODWORD(v18));
    v34.i64[0] = __PAIR64__(LODWORD(v27), LODWORD(v18));
    v34.i64[1] = __PAIR64__(LODWORD(v27), LODWORD(v18));
    v25.i32[0] = v16;
    uint64_t v55 = 4 * v31;
    uint64_t v54 = 4 * v31 + 8;
    int32x4_t v58 = v34;
    int32x4_t v59 = v24;
    int32x4_t v56 = vuzp1q_s32(v33, v33);
    int32x4_t v57 = v25;
    do
    {
      unint64_t result = ChannelDescription::GetLocationForTile(v60, (v32 + v29), v20, v22);
      uint64_t v35 = a1 + result;
      if (HIDWORD(result)) {
        BOOL v36 = v35 == 0;
      }
      else {
        BOOL v36 = 1;
      }
      if (!v36)
      {
        if (a9 >= 4)
        {
          uint64_t v39 = 0;
          unint64_t v40 = (unsigned int *)(v35 + v54);
          BOOL v41 = a11;
          do
          {
            int v42 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 2) >> 15) & 0x1FFFE)) << 16);
            int v43 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 1)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 1) >> 15) & 0x1FFFE)) << 16);
            unint64_t v44 = *v40;
            unint64_t v45 = v40[1];
            v40 += 4;
            v46.i64[0] = __PAIR64__(v43, v42);
            v46.i16[4] = *(_WORD *)(a13 + 2 * (unsigned __int16)v44);
            v46.i16[5] = *(_WORD *)(a13 + ((v44 >> 15) & 0x1FFFE));
            v46.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v45);
            v46.i16[7] = *(_WORD *)(a13 + ((v45 >> 15) & 0x1FFFE));
            int32x4_t v47 = vzip2q_s32(v56, v46);
            int32x4_t v48 = vzip1q_s32(v56, v46);
            uint64_t v38 = v41 + 4;
            unint64_t v37 = v39 + 4;
            unint64_t v49 = v39 + 8;
            v41[2] = vzip1q_s32(v47, v58);
            void v41[3] = vzip2q_s32(v47, v58);
            *BOOL v41 = vzip1q_s32(v48, v58);
            v41[1] = vzip2q_s32(v48, v58);
            v39 += 4;
            v41 += 4;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v37 = 0;
          uint64_t v38 = a11;
        }
        uint64_t v50 = a9 - v37;
        if (a9 > v37)
        {
          uint64_t v51 = (unsigned int *)(v35 + v55 + 4 * v37);
          do
          {
            unsigned int v52 = *v51++;
            int32x4_t v53 = v57;
            v53.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v52) | (*(unsigned __int16 *)(a13 + (((unint64_t)v52 >> 15) & 0x1FFFE)) << 16);
            *v38++ = vzip1q_s32(vuzp1q_s32(v53, v53), v59);
            --v50;
          }
          while (v50);
        }
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v29 += a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = *(unsigned int *)(a3 + 44);
  uint64_t v65 = v18;
  int v66 = *(ChannelDescription **)(a4 + 8);
  unsigned int v64 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v66, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v64);
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v24 = _D0;
  }
  else
  {
    unsigned int v24 = 32256;
  }
  uint64_t v25 = *(void *)(a3 + 24);
  uint64_t v26 = *(unsigned int *)(a3 + 44);
  uint64_t v62 = v25;
  int32x4_t v63 = *(ChannelDescription **)(a6 + 8);
  unsigned int v61 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v63, (*(_DWORD *)(a3 + 52) + HIDWORD(v25) * *(_DWORD *)(a2 + 60)), v25, v61);
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v31 = _D0;
  }
  else
  {
    unsigned int v31 = 32256;
  }
  unint64_t v32 = *(void *)(a2 + 56);
  uint64_t v33 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v33 < HIDWORD(v32))
  {
    uint64_t v34 = v26;
    int v36 = *(_DWORD *)(a3 + 28) * HIDWORD(v32);
    v70.val[0] = (int8x16_t)vdupq_n_s16(v24);
    v70.val[1] = (int8x16_t)vdupq_n_s16(v31);
    int8x16_t v37 = vqtbl2q_s8(v70, (int8x16_t)xmmword_228F41C10);
    v29.i16[0] = v24;
    v29.i16[1] = v31;
    uint64_t v59 = 2 * v34;
    uint64_t v58 = 2 * v34 + 4;
    int16x4_t v60 = v29;
    do
    {
      long long v68 = v28;
      int8x16_t v69 = v37;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v66, (v36 + v33), v65, v64);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v39 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v63, (v36 + v33), v62, v61);
        uint64_t v41 = a1 + result;
        if (HIDWORD(result)) {
          _ZF = v39 == 0;
        }
        else {
          _ZF = 1;
        }
        BOOL v43 = _ZF || v41 == 0;
        long long v28 = v68;
        int8x16_t v37 = v69;
        if (!v43)
        {
          if (a9 >= 4)
          {
            uint64_t v46 = 0;
            int32x4_t v47 = (unsigned __int16 *)(v41 + v58);
            int32x4_t v48 = (unsigned __int16 *)(v39 + 2 * v19 + 4);
            unint64_t v49 = a11;
            do
            {
              unint64_t result = *(v47 - 1);
              v40.i16[0] = *(_WORD *)(a13 + 2 * *v48);
              v40.i16[2] = *(_WORD *)(a13 + 2 * *v47);
              v40.i16[4] = *(_WORD *)(a13 + 2 * v48[1]);
              v40.i16[6] = *(_WORD *)(a13 + 2 * v47[1]);
              LOWORD(v28) = *(_WORD *)(a13 + 2 * *(v48 - 2));
              WORD2(v28) = *(_WORD *)(a13 + 2 * *(v47 - 2));
              WORD4(v28) = *(_WORD *)(a13 + 2 * *(v48 - 1));
              WORD6(v28) = *(_WORD *)(a13 + 2 * result);
              int8x16_t v50 = v69;
              int8x16_t v40 = vqtbl2q_s8(*(int8x16x2_t *)v40.i8, (int8x16_t)xmmword_228F41BF0);
              unint64_t v45 = v49 + 2;
              unint64_t v44 = v46 + 4;
              unint64_t v51 = v46 + 8;
              v47 += 4;
              *unint64_t v49 = vqtbl2q_s8(*(int8x16x2_t *)&v28, (int8x16_t)xmmword_228F41C10);
              v49[1] = v40;
              v48 += 4;
              v46 += 4;
              v49 += 2;
            }
            while (v51 <= a9);
          }
          else
          {
            unint64_t v44 = 0;
            unint64_t v45 = a11;
          }
          uint64_t v52 = a9 - v44;
          if (a9 > v44)
          {
            int32x4_t v53 = (unsigned __int16 *)(v39 + 2 * v19 + 2 * v44);
            uint64_t v54 = (unsigned __int16 *)(v41 + v59 + 2 * v44);
            do
            {
              unsigned int v56 = *v53++;
              uint64_t v55 = v56;
              unsigned int v57 = *v54++;
              v40.i16[0] = *(_WORD *)(a13 + 2 * v55);
              v40.i16[2] = *(_WORD *)(a13 + 2 * v57);
              *(int16x4_t *)v40.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v40.i8, *(int16x4_t *)v40.i8), v60);
              v45->i64[0] = v40.i64[0];
              unint64_t v45 = (int8x16_t *)((char *)v45 + 8);
              --v52;
            }
            while (v52);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v63, (v36 + v33), v62, v61);
        long long v28 = v68;
        int8x16_t v37 = v69;
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v33 += a10;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = *(unsigned int *)(a3 + 44);
  int32x4_t v78 = *(ChannelDescription **)(a4 + 8);
  unint64_t v77 = v18;
  unsigned int v76 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v78, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v76);
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    float v20 = **(double **)a5;
    float v21 = v20;
  }
  else
  {
    float v21 = NAN;
  }
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v23 = *(unsigned int *)(a3 + 44);
  uint64_t v74 = v22;
  uint64_t v75 = *(ChannelDescription **)(a6 + 8);
  unsigned int v73 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v73);
  if (*(unsigned char *)(*(void *)a7 + 24))
  {
    float v26 = **(double **)a7;
    float v27 = v26;
  }
  else
  {
    float v27 = NAN;
  }
  unint64_t v28 = *(void *)(a2 + 56);
  uint64_t v29 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v29 < HIDWORD(v28))
  {
    uint64_t v30 = v23;
    int v32 = *(_DWORD *)(a3 + 28) * HIDWORD(v28);
    v25.i64[0] = __PAIR64__(LODWORD(v27), LODWORD(v21));
    v33.i64[0] = __PAIR64__(LODWORD(v27), LODWORD(v21));
    v33.i64[1] = __PAIR64__(LODWORD(v27), LODWORD(v21));
    uint64_t v70 = 4 * v30;
    uint64_t v69 = 4 * v30 + 8;
    int32x4_t v71 = v33;
    int32x4_t v72 = v25;
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v78, (v32 + v29), v77, v76);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v35 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v75, (v32 + v29), v74, v73);
        uint64_t v37 = a1 + result;
        if (HIDWORD(result)) {
          BOOL v38 = v35 == 0;
        }
        else {
          BOOL v38 = 1;
        }
        if (!v38 && v37 != 0)
        {
          if (a9 >= 4)
          {
            uint64_t v42 = 0;
            BOOL v43 = (unsigned int *)(v37 + v69);
            unint64_t v44 = (unsigned int *)(v35 + 4 * v19 + 8);
            unint64_t v45 = a11;
            do
            {
              int v46 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v44 - 2));
              unint64_t v47 = ((unint64_t)*(v44 - 2) >> 15) & 0x1FFFE;
              int v48 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v44 - 1));
              unint64_t v49 = (unint64_t)*(v44 - 1) >> 15;
              unint64_t v51 = *v44;
              unint64_t v50 = v44[1];
              v44 += 4;
              int v52 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2));
              int v53 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE));
              LODWORD(v47) = v46 | (*(unsigned __int16 *)(a13 + v47) << 16);
              LODWORD(v49) = v48 | (*(unsigned __int16 *)(a13 + (v49 & 0x1FFFE)) << 16);
              int v54 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1));
              int v55 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v43 - 1) >> 15) & 0x1FFFE));
              unint64_t v56 = *v43;
              unint64_t v57 = v43[1];
              v43 += 4;
              unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v50) | (*(unsigned __int16 *)(a13 + ((v50 >> 15) & 0x1FFFE)) << 16);
              v58.i16[0] = *(_WORD *)(a13 + 2 * (unsigned __int16)v51);
              v58.i16[1] = *(_WORD *)(a13 + ((v51 >> 15) & 0x1FFFE));
              v58.i16[2] = *(_WORD *)(a13 + 2 * (unsigned __int16)v56);
              v58.i16[3] = *(_WORD *)(a13 + ((v56 >> 15) & 0x1FFFE));
              v59.i32[0] = v47;
              v58.i32[2] = result;
              v59.i32[1] = v52 | (v53 << 16);
              v59.i64[1] = __PAIR64__(v54 | (v55 << 16), v49);
              v58.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v57);
              v58.i16[7] = *(_WORD *)(a13 + ((v57 >> 15) & 0x1FFFE));
              int32x4_t v60 = vzip1q_s32(v58, v71);
              int32x4_t v36 = vzip2q_s32(v58, v71);
              uint64_t v41 = v45 + 4;
              unint64_t v40 = v42 + 4;
              unint64_t v61 = v42 + 8;
              v45[2] = v60;
              void v45[3] = v36;
              *unint64_t v45 = vzip1q_s32(v59, v71);
              v45[1] = vzip2q_s32(v59, v71);
              v42 += 4;
              v45 += 4;
            }
            while (v61 <= a9);
          }
          else
          {
            unint64_t v40 = 0;
            uint64_t v41 = a11;
          }
          uint64_t v62 = a9 - v40;
          if (a9 > v40)
          {
            int32x4_t v63 = (unsigned int *)(v35 + 4 * v19 + 4 * v40);
            unsigned int v64 = (unsigned int *)(v37 + v70 + 4 * v40);
            do
            {
              unsigned int v65 = *v63++;
              int v66 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v65);
              int v67 = *(unsigned __int16 *)(a13 + (((unint64_t)v65 >> 15) & 0x1FFFE));
              unsigned int v68 = *v64++;
              v36.i32[0] = v66 | (v67 << 16);
              v36.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v68) | (*(unsigned __int16 *)(a13 + (((unint64_t)v68 >> 15) & 0x1FFFE)) << 16);
              int32x4_t v36 = vzip1q_s32(vuzp1q_s32(v36, v36), v72);
              *v41++ = v36;
              --v62;
            }
            while (v62);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v75, (v32 + v29), v74, v73);
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v29 += a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t a5, uint64_t a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int16x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v21 = _D0;
  }
  else
  {
    unsigned int v21 = 32256;
  }
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v23 = *(unsigned int *)(a3 + 44);
  uint64_t v68 = v22;
  uint64_t v69 = *(ChannelDescription **)(a5 + 8);
  unsigned int v67 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v69, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v67);
  uint64_t v24 = *(void *)(a3 + 24);
  uint64_t v25 = *(unsigned int *)(a3 + 44);
  uint64_t v65 = v24;
  int v66 = *(ChannelDescription **)(a6 + 8);
  unsigned int v64 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v66, (*(_DWORD *)(a3 + 52) + HIDWORD(v24) * *(_DWORD *)(a2 + 60)), v24, v64);
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v31 = _D0;
  }
  else
  {
    unsigned int v31 = 32256;
  }
  unint64_t v32 = *(void *)(a2 + 56);
  uint64_t v33 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v33 < HIDWORD(v32))
  {
    int v35 = *(_DWORD *)(a3 + 28) * HIDWORD(v32);
    v27.i32[0] = v21;
    int16x8_t v36 = vdupq_n_s16(v21);
    int16x8_t v37 = vdupq_n_s16(v31);
    uint64_t v62 = 2 * v25;
    uint64_t v61 = 2 * v25 + 4;
    int16x4_t v63 = v27;
    do
    {
      int16x8_t v71 = v29;
      int16x8_t v72 = v37;
      int16x8_t v73 = v36;
      long long v74 = v28;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v69, (v35 + v33), v68, v67);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v39 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v66, (v35 + v33), v65, v64);
        uint64_t v42 = a1 + result;
        if (HIDWORD(result)) {
          _ZF = v39 == 0;
        }
        else {
          _ZF = 1;
        }
        BOOL v44 = _ZF || v42 == 0;
        int16x8_t v36 = v73;
        long long v28 = v74;
        int16x8_t v29 = v71;
        int16x8_t v37 = v72;
        if (!v44)
        {
          if (a9 >= 4)
          {
            uint64_t v47 = 0;
            int v48 = (unsigned __int16 *)(v42 + v61);
            unint64_t v49 = (unsigned __int16 *)(v39 + 2 * v23 + 4);
            unint64_t v50 = a11;
            do
            {
              v40.i16[0] = *(_WORD *)(a13 + 2 * *(v49 - 2));
              v40.i16[2] = *(_WORD *)(a13 + 2 * *(v49 - 1));
              v40.i16[4] = *(_WORD *)(a13 + 2 * *v49);
              v40.i16[6] = *(_WORD *)(a13 + 2 * v49[1]);
              LOWORD(v28) = *(_WORD *)(a13 + 2 * *(v48 - 2));
              WORD1(v28) = *(_WORD *)(a13 + 2 * *(v48 - 1));
              WORD2(v28) = *(_WORD *)(a13 + 2 * *v48);
              WORD3(v28) = *(_WORD *)(a13 + 2 * v48[1]);
              int16x8_t v51 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v28 - 1), (int8x16_t)xmmword_228F41C10);
              int16x8_t v29 = vzip1q_s16(v51, v40);
              int16x8_t v52 = vzip2q_s16(v51, v40);
              int16x8_t v41 = v72;
              int16x8_t v40 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v41 - 1), (int8x16_t)xmmword_228F41C50);
              int v46 = v50 + 4;
              unint64_t v45 = v47 + 4;
              unint64_t v53 = v47 + 8;
              v48 += 4;
              *(int8x16_t *)v50->i8 = vqtbl2q_s8(*(int8x16x2_t *)v29.i8, (int8x16_t)xmmword_228F41C70);
              *(int16x8_t *)v50[2].i8 = v40;
              v49 += 4;
              v47 += 4;
              v50 += 4;
            }
            while (v53 <= a9);
          }
          else
          {
            unint64_t v45 = 0;
            int v46 = a11;
          }
          uint64_t v54 = a9 - v45;
          if (a9 > v45)
          {
            int v55 = (unsigned __int16 *)(v39 + 2 * v23 + 2 * v45);
            unint64_t v56 = (unsigned __int16 *)(v42 + v62 + 2 * v45);
            do
            {
              unsigned int v58 = *v55++;
              uint64_t v57 = v58;
              unsigned int v59 = *v56++;
              int16x4_t v60 = v63;
              v60.i16[2] = *(_WORD *)(a13 + 2 * v59);
              v41.i16[0] = *(_WORD *)(a13 + 2 * v57);
              v41.i16[1] = v31;
              *v46++ = vzip1_s16(vuzp1_s16(v60, v60), *(int16x4_t *)v41.i8);
              --v54;
            }
            while (v54);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v66, (v35 + v33), v65, v64);
        int16x8_t v36 = v73;
        long long v28 = v74;
        int16x8_t v29 = v71;
        int16x8_t v37 = v72;
      }
      a11 = (int16x4_t *)((char *)a11 + a12);
      v33 += a10;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    *(float *)&unsigned int v17 = **(double **)a4;
    unsigned int v18 = v17;
  }
  else
  {
    unsigned int v18 = 2143289344;
  }
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v20 = *(unsigned int *)(a3 + 44);
  uint64_t v81 = v19;
  int16x8_t v82 = *(ChannelDescription **)(a5 + 8);
  unsigned int v80 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v82, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v80);
  uint64_t v21 = *(void *)(a3 + 24);
  uint64_t v22 = *(unsigned int *)(a3 + 44);
  uint64_t v78 = v21;
  int v79 = *(ChannelDescription **)(a6 + 8);
  unsigned int v77 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60)), v21, v77);
  if (*(unsigned char *)(*(void *)a7 + 24))
  {
    *(float *)&unsigned int v25 = **(double **)a7;
    unsigned int v26 = v25;
  }
  else
  {
    unsigned int v26 = 2143289344;
  }
  unint64_t v27 = *(void *)(a2 + 56);
  uint64_t v28 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v28 < HIDWORD(v27))
  {
    int v30 = *(_DWORD *)(a3 + 28) * HIDWORD(v27);
    int32x4_t v31 = vdupq_n_s32(v18);
    v24.i32[0] = v18;
    uint64_t v73 = 4 * v22;
    uint64_t v72 = 4 * v22 + 8;
    int32x4_t v75 = v24;
    int32x4_t v76 = vdupq_n_s32(v26);
    int32x4_t v74 = vuzp1q_s32(v31, v31);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v82, (v30 + v28), v81, v80);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v33 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v79, (v30 + v28), v78, v77);
        uint64_t v36 = a1 + result;
        if (HIDWORD(result)) {
          BOOL v37 = v33 == 0;
        }
        else {
          BOOL v37 = 1;
        }
        if (!v37 && v36 != 0)
        {
          if (a9 >= 4)
          {
            uint64_t v41 = 0;
            uint64_t v42 = (unsigned int *)(v36 + v72);
            BOOL v43 = (unsigned int *)(v33 + 4 * v20 + 8);
            BOOL v44 = a11;
            do
            {
              int v45 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2));
              int v46 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1));
              unint64_t v47 = ((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE;
              unint64_t v48 = (unint64_t)*(v43 - 1) >> 15;
              unint64_t v50 = *v43;
              unint64_t v49 = v43[1];
              v43 += 4;
              int v51 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 2));
              int v52 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE));
              int v53 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 1));
              LODWORD(v47) = v45 | (*(unsigned __int16 *)(a13 + v47) << 16);
              LODWORD(v48) = v46 | (*(unsigned __int16 *)(a13 + (v48 & 0x1FFFE)) << 16);
              int v54 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 1) >> 15) & 0x1FFFE));
              int v55 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v50) | (*(unsigned __int16 *)(a13 + ((v50 >> 15) & 0x1FFFE)) << 16);
              unint64_t v57 = *v42;
              unint64_t v56 = v42[1];
              v42 += 4;
              unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v49) | (*(unsigned __int16 *)(a13 + ((v49 >> 15) & 0x1FFFE)) << 16);
              v34.i32[0] = v55;
              v35.i32[0] = v47;
              v34.i32[2] = result;
              v58.i32[0] = v51 | (v52 << 16);
              v58.i32[1] = v53 | (v54 << 16);
              v35.i32[2] = v48;
              v58.i16[4] = *(_WORD *)(a13 + 2 * (unsigned __int16)v57);
              v58.i16[5] = *(_WORD *)(a13 + ((v57 >> 15) & 0x1FFFE));
              v58.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v56);
              v58.i16[7] = *(_WORD *)(a13 + ((v56 >> 15) & 0x1FFFE));
              int32x4_t v59 = vzip2q_s32(v74, v58);
              int32x4_t v60 = vzip1q_s32(v74, v58);
              int32x4_t v61 = vzip1q_s32(v60, v35);
              v61.i32[3] = v76.i32[0];
              int32x4_t v35 = vzip2q_s32(v60, v35);
              v35.i32[3] = v76.i32[1];
              int32x4_t v62 = vzip1q_s32(v59, v34);
              v62.i32[3] = v76.i32[2];
              int32x4_t v34 = vzip2q_s32(v59, v34);
              v34.i32[3] = v76.i32[3];
              int16x8_t v40 = v44 + 4;
              unint64_t v39 = v41 + 4;
              unint64_t v63 = v41 + 8;
              v44[2] = v62;
              v44[3] = v34;
              *BOOL v44 = v61;
              v44[1] = v35;
              v41 += 4;
              v44 += 4;
            }
            while (v63 <= a9);
          }
          else
          {
            unint64_t v39 = 0;
            int16x8_t v40 = a11;
          }
          uint64_t v64 = a9 - v39;
          if (a9 > v39)
          {
            uint64_t v65 = (unsigned int *)(v33 + 4 * v20 + 4 * v39);
            int v66 = (unsigned int *)(v36 + v73 + 4 * v39);
            do
            {
              unsigned int v67 = *v65++;
              int v68 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v67);
              int v69 = *(unsigned __int16 *)(a13 + (((unint64_t)v67 >> 15) & 0x1FFFE));
              unsigned int v70 = *v66++;
              int32x4_t v71 = v75;
              v71.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v70) | (*(unsigned __int16 *)(a13 + (((unint64_t)v70 >> 15) & 0x1FFFE)) << 16);
              v35.i32[0] = v68 | (v69 << 16);
              v35.i32[1] = v26;
              *v40++ = vzip1q_s32(vuzp1q_s32(v71, v71), v35);
              --v64;
            }
            while (v64);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v79, (v30 + v28), v78, v77);
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v28 += a10;
    }
    while (v28 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t **a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v80 = *(unsigned int *)(a3 + 44);
  uint64_t v81 = v19;
  int16x8_t v82 = *(ChannelDescription **)(a4 + 8);
  unsigned int v79 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v82, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v79);
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v76 = *(unsigned int *)(a3 + 44);
  uint64_t v77 = v20;
  uint64_t v78 = *(ChannelDescription **)(a5 + 8);
  unsigned int v75 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v78, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v75);
  uint64_t v21 = *(void *)(a3 + 24);
  uint64_t v72 = *(unsigned int *)(a3 + 44);
  uint64_t v73 = v21;
  int32x4_t v74 = *(ChannelDescription **)(a6 + 8);
  unsigned int v71 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v74, (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60)), v21, v71);
  if (*((unsigned char *)*a7 + 24))
  {
    _D0 = **a7;
    __asm { FCVT            H0, D0 }
    unsigned int v28 = _D0;
  }
  else
  {
    unsigned int v28 = 32256;
  }
  unint64_t v29 = *(void *)(a2 + 56);
  uint64_t v30 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v30 < HIDWORD(v29))
  {
    int v70 = *(_DWORD *)(a3 + 28) * HIDWORD(v29);
    int16x8_t v32 = vdupq_n_s16(v28);
    do
    {
      long long v83 = v23;
      int16x8_t v84 = v32;
      unint64_t v33 = (v70 + v30);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v82, v33, v81, v79);
      if (HIDWORD(LocationForTile)) {
        uint64_t v35 = a1 + LocationForTile + 2 * v80;
      }
      else {
        uint64_t v35 = 0;
      }
      unint64_t v36 = ChannelDescription::GetLocationForTile(v78, v33, v77, v75);
      if (HIDWORD(v36)) {
        uint64_t v37 = a1 + v36 + 2 * v76;
      }
      else {
        uint64_t v37 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v74, v33, v73, v71);
      long long v23 = v83;
      int16x8_t v32 = v84;
      uint64_t v43 = a1 + result + 2 * v72;
      if (!HIDWORD(result)) {
        uint64_t v43 = 0;
      }
      if (v35) {
        _ZF = v37 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v43 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v48 = 0;
          uint64_t v49 = 0;
          uint64_t v50 = v35 + 4;
          int v51 = a11;
          do
          {
            LOWORD(v23) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v48));
            WORD2(v23) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v48 + 2));
            WORD4(v23) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v48 + 4));
            WORD6(v23) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v48 + 6));
            unint64_t result = a13 + 2 * *(unsigned __int16 *)(v43 + v48);
            int8x16_t v52 = vqtbl2q_s8(*(int8x16x2_t *)&v23, (int8x16_t)xmmword_228F41C10);
            __int16 v53 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v50 + v48));
            __int16 v54 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v43 + v48 + 4));
            __int16 v55 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v50 + v48 + 2));
            __int16 v56 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v43 + v48 + 6));
            v38.i16[0] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v35 + v48));
            v38.i16[2] = *(_WORD *)result;
            v38.i16[4] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v50 + v48 - 2));
            v38.i16[6] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v43 + v48 + 2));
            int8x16_t v57 = vqtbl2q_s8(*(int8x16x2_t *)v38.i8, (int8x16_t)xmmword_228F41C10);
            int8x16_t v58 = v52;
            int8x16_t v38 = vqtbl2q_s8(*(int8x16x2_t *)(&v39 - 1), (int8x16_t)xmmword_228F41BF0);
            unint64_t v47 = v51 + 2;
            unint64_t v46 = v49 + 4;
            unint64_t v59 = v49 + 8;
            *int v51 = v57;
            v51[1] = v38;
            v48 += 8;
            v49 += 4;
            v51 += 2;
          }
          while (v59 <= a9);
        }
        else
        {
          unint64_t v46 = 0;
          unint64_t v47 = a11;
        }
        uint64_t v60 = a9 - v46;
        if (a9 > v46)
        {
          int32x4_t v61 = (unsigned __int16 *)(v35 + 2 * v46);
          int32x4_t v62 = (unsigned __int16 *)(v37 + 2 * v46);
          unint64_t v63 = (unsigned __int16 *)(v43 + 2 * v46);
          do
          {
            unsigned int v65 = *v61++;
            uint64_t v64 = v65;
            unsigned int v66 = *v62++;
            unsigned int v67 = (_WORD *)(a13 + 2 * v66);
            unsigned int v68 = *v63++;
            LOWORD(v69) = *(_WORD *)(a13 + 2 * v64);
            WORD1(v69) = *v67;
            WORD2(v69) = *(_WORD *)(a13 + 2 * v68);
            HIWORD(v69) = v28;
            v47->i64[0] = v69;
            unint64_t v47 = (int8x16_t *)((char *)v47 + 8);
            --v60;
          }
          while (v60);
        }
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v30 += a10;
    }
    while (v30 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, _OWORD *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v16 = a3;
  uint64_t v17 = a2;
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v93 = *(unsigned int *)(a3 + 44);
  int8x16_t v95 = *(ChannelDescription **)(a4 + 8);
  unint64_t v94 = v18;
  unsigned int v92 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v95, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v92);
  uint64_t v19 = *(void *)(v16 + 24);
  uint64_t v89 = *(unsigned int *)(v16 + 44);
  uint64_t v90 = v19;
  int16x8_t v91 = *(ChannelDescription **)(a5 + 8);
  unsigned int v88 = *(_DWORD *)(v16 + 60);
  ChannelDescription::GetLocationForTile(v91, (*(_DWORD *)(v16 + 52) + HIDWORD(v19) * *(_DWORD *)(v17 + 60)), v19, v88);
  uint64_t v20 = *(void *)(v16 + 24);
  uint64_t v85 = *(unsigned int *)(v16 + 44);
  uint64_t v86 = v20;
  int16x8_t v87 = *(ChannelDescription **)(a6 + 8);
  unsigned int v84 = *(_DWORD *)(v16 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v87, (*(_DWORD *)(v16 + 52) + HIDWORD(v20) * *(_DWORD *)(v17 + 60)), v20, v84);
  if (*(unsigned char *)(*(void *)a7 + 24))
  {
    *(float *)&unsigned int v22 = **(double **)a7;
    unsigned int v23 = v22;
  }
  else
  {
    unsigned int v23 = 2143289344;
  }
  unint64_t v24 = *(void *)(v17 + 56);
  uint64_t v25 = *(unsigned int *)(v16 + 52);
  if ((unint64_t)*(unsigned int *)(v16 + 56) + v25 < HIDWORD(v24))
  {
    int v83 = *(_DWORD *)(v16 + 28) * HIDWORD(v24);
    uint64_t v80 = v17;
    uint64_t v81 = v16;
    int32x4_t v82 = vdupq_n_s32(v23);
    do
    {
      uint64_t v99 = v25;
      unint64_t v27 = (v83 + v25);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v95, v27, v94, v92);
      uint64_t v29 = v17;
      if (HIDWORD(LocationForTile)) {
        uint64_t v30 = a1 + LocationForTile + 4 * v93;
      }
      else {
        uint64_t v30 = 0;
      }
      unint64_t v31 = ChannelDescription::GetLocationForTile(v91, v27, v90, v88);
      uint64_t v32 = v16;
      if (HIDWORD(v31)) {
        uint64_t v33 = a1 + v31 + 4 * v89;
      }
      else {
        uint64_t v33 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v87, v27, v86, v84);
      uint64_t v34 = a1 + result + 4 * v85;
      if (!HIDWORD(result)) {
        uint64_t v34 = 0;
      }
      uint64_t v97 = v33;
      uint64_t v98 = v30;
      BOOL v35 = v30 == 0;
      uint64_t v17 = v29;
      BOOL v35 = v35 || v33 == 0;
      uint64_t v16 = v32;
      if (!v35 && v34 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v39 = 0;
          int16x8_t v40 = (unsigned int *)(v34 + 8);
          uint64_t v41 = (unsigned int *)(v97 + 8);
          uint64_t v42 = (unsigned int *)(v98 + 8);
          uint64_t v43 = a11;
          do
          {
            int v44 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 2));
            unint64_t v45 = ((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE;
            int v46 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 1));
            unint64_t v47 = ((unint64_t)*(v42 - 1) >> 15) & 0x1FFFE;
            unint64_t v48 = *v42;
            unint64_t v49 = v42[1];
            v42 += 4;
            int v50 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v41 - 2));
            unint64_t v51 = ((unint64_t)*(v41 - 2) >> 15) & 0x1FFFE;
            int v52 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v41 - 1));
            unint64_t v53 = ((unint64_t)*(v41 - 1) >> 15) & 0x1FFFE;
            unint64_t v54 = *v41;
            unint64_t v55 = v41[1];
            v41 += 4;
            int v56 = v44 | (*(unsigned __int16 *)(a13 + v45) << 16);
            unsigned int v57 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 2));
            int v58 = v46 | (*(unsigned __int16 *)(a13 + v47) << 16);
            LODWORD(v47) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v48) | (*(unsigned __int16 *)(a13 + ((v48 >> 15) & 0x1FFFE)) << 16);
            LODWORD(v45) = *(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 2) >> 15) & 0x1FFFE));
            unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v49) | (*(unsigned __int16 *)(a13 + ((v49 >> 15) & 0x1FFFE)) << 16);
            LODWORD(v49) = v50 | (*(unsigned __int16 *)(a13 + v51) << 16);
            int v59 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 1));
            LODWORD(v51) = v52 | (*(unsigned __int16 *)(a13 + v53) << 16);
            int v60 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 1) >> 15) & 0x1FFFE));
            unint64_t v61 = *v40;
            unint64_t v62 = v40[1];
            v40 += 4;
            *(void *)&long long v63 = __PAIR64__(v49, v56);
            *(void *)&long long v64 = __PAIR64__(v51, v58);
            *((void *)&v63 + 1) = __PAIR64__(v82.u32[0], v57 | (v45 << 16));
            DWORD2(v64) = v59 | (v60 << 16);
            LODWORD(v65) = v47;
            DWORD1(v65) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v54) | (*(unsigned __int16 *)(a13 + ((v54 >> 15) & 0x1FFFE)) << 16);
            DWORD2(v65) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v61) | (*(unsigned __int16 *)(a13 + ((v61 >> 15) & 0x1FFFE)) << 16);
            HIDWORD(v64) = v82.i32[1];
            LODWORD(v66) = result;
            DWORD1(v66) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v55) | (*(unsigned __int16 *)(a13 + ((v55 >> 15) & 0x1FFFE)) << 16);
            HIDWORD(v65) = v82.i32[2];
            DWORD2(v66) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v62) | (*(unsigned __int16 *)(a13 + ((v62 >> 15) & 0x1FFFE)) << 16);
            HIDWORD(v66) = v82.i32[3];
            int8x16_t v38 = v43 + 4;
            unint64_t v37 = v39 + 4;
            unint64_t v67 = v39 + 8;
            v43[2] = v65;
            v43[3] = v66;
            *uint64_t v43 = v63;
            v43[1] = v64;
            v39 += 4;
            v43 += 4;
          }
          while (v67 <= a9);
        }
        else
        {
          unint64_t v37 = 0;
          int8x16_t v38 = a11;
        }
        uint64_t v68 = a9 - v37;
        uint64_t v17 = v80;
        uint64_t v16 = v81;
        if (a9 > v37)
        {
          uint64_t v69 = (unsigned int *)(v98 + 4 * v37);
          int v70 = (unsigned int *)(v97 + 4 * v37);
          unsigned int v71 = (unsigned int *)(v34 + 4 * v37);
          do
          {
            unsigned int v72 = *v69++;
            int v73 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v72);
            unint64_t v74 = ((unint64_t)v72 >> 15) & 0x1FFFE;
            unsigned int v75 = *v70++;
            int v76 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v75);
            LODWORD(v74) = v73 | (*(unsigned __int16 *)(a13 + v74) << 16);
            int v77 = *(unsigned __int16 *)(a13 + (((unint64_t)v75 >> 15) & 0x1FFFE));
            unsigned int v78 = *v71++;
            LODWORD(v79) = v74;
            DWORD1(v79) = v76 | (v77 << 16);
            DWORD2(v79) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v78) | (*(unsigned __int16 *)(a13 + (((unint64_t)v78 >> 15) & 0x1FFFE)) << 16);
            HIDWORD(v79) = v23;
            *v38++ = v79;
            --v68;
          }
          while (v68);
        }
      }
      a11 = (_OWORD *)((char *)a11 + a12);
      uint64_t v25 = v99 + a10;
    }
    while (v25 + (unint64_t)*(unsigned int *)(v16 + 56) < *(unsigned int *)(v17 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t **a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12, uint64_t a13)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v18 = _D0;
  }
  else
  {
    unsigned int v18 = 32256;
  }
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    int v20 = _D0;
  }
  else
  {
    int v20 = 32256;
  }
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v22 = _D0;
  }
  else
  {
    unsigned int v22 = 32256;
  }
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v24 = v23;
  uint64_t v25 = *(unsigned int *)(a3 + 44);
  unsigned int v26 = *(_DWORD *)(a3 + 60);
  unsigned int v57 = *(ChannelDescription **)(a7 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v57, (*(_DWORD *)(a3 + 52) + HIDWORD(v23) * *(_DWORD *)(a2 + 60)), v23, v26);
  unint64_t v32 = *(void *)(a2 + 56);
  uint64_t v33 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v33 < HIDWORD(v32))
  {
    uint64_t v34 = v25;
    unsigned int v36 = v20;
    int v37 = *(_DWORD *)(a3 + 28) * HIDWORD(v32);
    v66.val[0] = (int8x16_t)vdupq_n_s16(v18);
    v28.i32[0] = v36;
    int16x8_t v38 = vdupq_n_s16(v36);
    v66.val[1] = (int8x16_t)vdupq_n_s16(v22);
    v66.val[0] = vqtbl2q_s8(v66, (int8x16_t)xmmword_228F41C10);
    int16x8_t v39 = vzip2q_s16((int16x8_t)v66.val[0], (int16x8_t)v66.val[0]);
    v66.val[1].i32[0] = v18;
    v66.val[1].i16[2] = v22;
    int16x8_t v40 = vzip1q_s16((int16x8_t)v66.val[0], (int16x8_t)v66.val[0]);
    uint64_t v55 = 2 * v34;
    uint64_t v54 = 2 * v34 + 4;
    int16x4_t v41 = vuzp1_s16(*(int16x4_t *)v66.val[1].i8, *(int16x4_t *)v66.val[1].i8);
    int16x4_t v56 = v28;
    do
    {
      int16x8_t v60 = v40;
      int8x16_t v61 = v31;
      int16x8_t v62 = v39;
      int8x16_t v63 = v30;
      int16x8_t v64 = v38;
      long long v65 = v29;
      unint64_t result = ChannelDescription::GetLocationForTile(v57, (v37 + v33), v24, v26);
      int16x8_t v40 = v60;
      int8x16_t v31 = v61;
      int16x8_t v39 = v62;
      int8x16_t v30 = v63;
      int16x8_t v38 = v64;
      long long v29 = v65;
      uint64_t v42 = a1 + result;
      if (HIDWORD(result)) {
        _ZF = v42 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        if (a9 >= 4)
        {
          uint64_t v46 = 0;
          unint64_t v47 = (unsigned __int16 *)(v42 + v54);
          unint64_t v48 = a11;
          do
          {
            LOWORD(v29) = *(_WORD *)(a13 + 2 * *(v47 - 2));
            WORD1(v29) = *(_WORD *)(a13 + 2 * *(v47 - 1));
            WORD2(v29) = *(_WORD *)(a13 + 2 * *v47);
            WORD3(v29) = *(_WORD *)(a13 + 2 * v47[1]);
            int8x16_t v31 = vqtbl2q_s8(*(int8x16x2_t *)(&v29 - 1), (int8x16_t)xmmword_228F41C10);
            int8x16_t v30 = v31;
            unint64_t v45 = (int16x4_t *)&v48[2];
            unint64_t v44 = v46 + 4;
            unint64_t v49 = v46 + 8;
            *unint64_t v48 = vqtbl2q_s8(*(int8x16x2_t *)(&v31 - 1), (int8x16_t)xmmword_228F41C10);
            v48[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v30 - 1), (int8x16_t)xmmword_228F41BF0);
            v47 += 4;
            v46 += 4;
            v48 += 2;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v44 = 0;
          unint64_t v45 = (int16x4_t *)a11;
        }
        uint64_t v50 = a9 - v44;
        if (a9 > v44)
        {
          unint64_t v51 = (unsigned __int16 *)(v42 + v55 + 2 * v44);
          do
          {
            unsigned int v52 = *v51++;
            int16x4_t v53 = v56;
            v53.i16[1] = *(_WORD *)(a13 + 2 * v52);
            *v45++ = vzip1_s16(v41, v53);
            --v50;
          }
          while (v50);
        }
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v33 += a10;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    float v14 = **(double **)a4;
    float v15 = v14;
  }
  else
  {
    float v15 = NAN;
  }
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    float v16 = **(double **)a5;
    float v17 = v16;
  }
  else
  {
    float v17 = NAN;
  }
  if (*(unsigned char *)(*(void *)a6 + 24))
  {
    float v18 = **(double **)a6;
    float v19 = v18;
  }
  else
  {
    float v19 = NAN;
  }
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v21 = v20;
  uint64_t v22 = *(unsigned int *)(a3 + 44);
  unsigned int v23 = *(_DWORD *)(a3 + 60);
  int v58 = *(ChannelDescription **)(a7 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v58, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v23);
  unint64_t v27 = *(void *)(a2 + 56);
  uint64_t v28 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v28 < HIDWORD(v27))
  {
    uint64_t v29 = v22;
    unsigned int v31 = LODWORD(v17);
    int v32 = *(_DWORD *)(a3 + 28) * HIDWORD(v27);
    v26.i32[0] = v31;
    int32x4_t v33 = vdupq_n_s32(v31);
    *(float *)v25.i32 = v15;
    *(float *)&v25.i32[2] = v19;
    uint64_t v54 = 4 * v29;
    uint64_t v53 = 4 * v29 + 8;
    int32x4_t v56 = vuzp1q_s32(v25, v25);
    int32x4_t v57 = v26;
    int32x4_t v55 = vuzp1q_s32(v33, v33);
    do
    {
      unint64_t result = ChannelDescription::GetLocationForTile(v58, (v32 + v28), v21, v23);
      uint64_t v34 = a1 + result;
      if (HIDWORD(result)) {
        BOOL v35 = v34 == 0;
      }
      else {
        BOOL v35 = 1;
      }
      if (!v35)
      {
        if (a9 >= 4)
        {
          uint64_t v38 = 0;
          int16x8_t v39 = (unsigned int *)(v34 + v53);
          int16x8_t v40 = a11;
          do
          {
            int v41 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v39 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v39 - 2) >> 15) & 0x1FFFE)) << 16);
            int v42 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v39 - 1)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v39 - 1) >> 15) & 0x1FFFE)) << 16);
            unint64_t v43 = *v39;
            unint64_t v44 = v39[1];
            v39 += 4;
            v45.i64[0] = __PAIR64__(v42, v41);
            v45.i16[4] = *(_WORD *)(a13 + 2 * (unsigned __int16)v43);
            v45.i16[5] = *(_WORD *)(a13 + ((v43 >> 15) & 0x1FFFE));
            v45.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v44);
            v45.i16[7] = *(_WORD *)(a13 + ((v44 >> 15) & 0x1FFFE));
            int32x4_t v46 = vzip2q_s32(v55, v45);
            int32x4_t v47 = vzip1q_s32(v55, v45);
            int v37 = v40 + 4;
            unint64_t v36 = v38 + 4;
            unint64_t v48 = v38 + 8;
            v40[2] = vzip1q_s32(v56, v46);
            void v40[3] = vzip2q_s32(v56, v46);
            *int16x8_t v40 = vzip1q_s32(v56, v47);
            v40[1] = vzip2q_s32(v56, v47);
            v38 += 4;
            v40 += 4;
          }
          while (v48 <= a9);
        }
        else
        {
          unint64_t v36 = 0;
          int v37 = a11;
        }
        uint64_t v49 = a9 - v36;
        if (a9 > v36)
        {
          uint64_t v50 = (unsigned int *)(v34 + v54 + 4 * v36);
          do
          {
            unsigned int v51 = *v50++;
            int32x4_t v52 = v57;
            v52.i32[1] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v51) | (*(unsigned __int16 *)(a13 + (((unint64_t)v51 >> 15) & 0x1FFFE)) << 16);
            *v37++ = vzip1q_s32(v56, v52);
            --v49;
          }
          while (v49);
        }
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v28 += a10;
    }
    while (v28 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t **a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = *(unsigned int *)(a3 + 44);
  uint64_t v71 = v18;
  unsigned int v72 = *(ChannelDescription **)(a4 + 8);
  unsigned int v70 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v70);
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v24 = _D0;
  }
  else
  {
    unsigned int v24 = 32256;
  }
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v26 = _D0;
  }
  else
  {
    unsigned int v26 = 32256;
  }
  uint64_t v27 = *(void *)(a3 + 24);
  uint64_t v28 = *(unsigned int *)(a3 + 44);
  uint64_t v68 = v27;
  uint64_t v69 = *(ChannelDescription **)(a7 + 8);
  unsigned int v67 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v69, (*(_DWORD *)(a3 + 52) + HIDWORD(v27) * *(_DWORD *)(a2 + 60)), v27, v67);
  unint64_t v32 = *(void *)(a2 + 56);
  uint64_t v33 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v33 < HIDWORD(v32))
  {
    int v35 = *(_DWORD *)(a3 + 28) * HIDWORD(v32);
    v30.i32[0] = v24;
    int16x8_t v36 = vdupq_n_s16(v26);
    int16x8_t v65 = vdupq_n_s16(v24);
    int16x4_t v66 = v30;
    do
    {
      long long v74 = v31;
      int16x8_t v75 = v36;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v72, (v35 + v33), v71, v70);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v38 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v69, (v35 + v33), v68, v67);
        uint64_t v41 = a1 + result;
        if (HIDWORD(result)) {
          _ZF = v38 == 0;
        }
        else {
          _ZF = 1;
        }
        BOOL v43 = _ZF || v41 == 0;
        long long v31 = v74;
        int16x8_t v36 = v75;
        if (!v43)
        {
          if (a9 >= 4)
          {
            uint64_t v46 = 0;
            int32x4_t v47 = (unsigned __int16 *)(v41 + 2 * v28 + 4);
            unint64_t v48 = (unsigned __int16 *)(v38 + 2 * v19 + 4);
            uint64_t v49 = a11;
            do
            {
              LOWORD(v31) = *(_WORD *)(a13 + 2 * *(v48 - 2));
              WORD2(v31) = *(_WORD *)(a13 + 2 * *(v48 - 1));
              WORD4(v31) = *(_WORD *)(a13 + 2 * *v48);
              WORD6(v31) = *(_WORD *)(a13 + 2 * v48[1]);
              int16x8_t v50 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v31, (int8x16_t)xmmword_228F41C10);
              __int16 v51 = *(_WORD *)(a13 + 2 * *(v47 - 2));
              __int16 v52 = *(_WORD *)(a13 + 2 * *(v47 - 1));
              __int16 v53 = *(_WORD *)(a13 + 2 * *v47);
              __int16 v54 = *(_WORD *)(a13 + 2 * v47[1]);
              int16x8_t v55 = vzip1q_s16(v50, v65);
              int8x16_t v56 = vqtbl2q_s8(*(int8x16x2_t *)(&v40 - 3), (int8x16_t)xmmword_228F41C70);
              int16x8_t v57 = vzip2q_s16(v50, v65);
              int8x16_t v39 = vqtbl2q_s8(*(int8x16x2_t *)(&v40 - 3), (int8x16_t)xmmword_228F41C50);
              int32x4_t v45 = v49 + 2;
              unint64_t v44 = v46 + 4;
              unint64_t v58 = v46 + 8;
              v47 += 4;
              *uint64_t v49 = v56;
              v49[1] = v39;
              v48 += 4;
              v46 += 4;
              v49 += 2;
            }
            while (v58 <= a9);
          }
          else
          {
            unint64_t v44 = 0;
            int32x4_t v45 = a11;
          }
          uint64_t v59 = a9 - v44;
          if (a9 > v44)
          {
            int16x8_t v60 = (unsigned __int16 *)(v38 + 2 * v19 + 2 * v44);
            int8x16_t v61 = (unsigned __int16 *)(v41 + 2 * v28 + 2 * v44);
            do
            {
              unsigned int v62 = *v60++;
              v39.i16[0] = *(_WORD *)(a13 + 2 * v62);
              v39.i16[2] = v26;
              unsigned int v63 = *v61++;
              int16x4_t v64 = v66;
              v64.i16[1] = *(_WORD *)(a13 + 2 * v63);
              *(int16x4_t *)v39.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v39.i8, *(int16x4_t *)v39.i8), v64);
              v45->i64[0] = v39.i64[0];
              int32x4_t v45 = (int8x16_t *)((char *)v45 + 8);
              --v59;
            }
            while (v59);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v69, (v35 + v33), v68, v67);
        long long v31 = v74;
        int16x8_t v36 = v75;
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v33 += a10;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v19 = *(unsigned int *)(a3 + 44);
  uint64_t v74 = v18;
  int16x8_t v75 = *(ChannelDescription **)(a4 + 8);
  unsigned int v73 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v73);
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    *(float *)&unsigned int v20 = **(double **)a5;
    unsigned int v21 = v20;
  }
  else
  {
    unsigned int v21 = 2143289344;
  }
  if (*(unsigned char *)(*(void *)a6 + 24))
  {
    *(float *)&unsigned int v22 = **(double **)a6;
    unsigned int v23 = v22;
  }
  else
  {
    unsigned int v23 = 2143289344;
  }
  uint64_t v24 = *(void *)(a3 + 24);
  uint64_t v25 = *(unsigned int *)(a3 + 44);
  uint64_t v71 = v24;
  unsigned int v72 = *(ChannelDescription **)(a7 + 8);
  unsigned int v70 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a3 + 52) + HIDWORD(v24) * *(_DWORD *)(a2 + 60)), v24, v70);
  unint64_t v28 = *(void *)(a2 + 56);
  uint64_t v29 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v29 < HIDWORD(v28))
  {
    int v31 = *(_DWORD *)(a3 + 28) * HIDWORD(v28);
    v27.i32[0] = v21;
    int32x4_t v68 = vdupq_n_s32(v21);
    int32x4_t v69 = v27;
    int32x4_t v67 = vdupq_n_s32(v23);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v75, (v31 + v29), v74, v73);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v33 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v72, (v31 + v29), v71, v70);
        uint64_t v36 = a1 + result;
        if (HIDWORD(result)) {
          BOOL v37 = v33 == 0;
        }
        else {
          BOOL v37 = 1;
        }
        if (!v37 && v36 != 0)
        {
          if (a9 >= 4)
          {
            uint64_t v41 = 0;
            int v42 = (unsigned int *)(v36 + 4 * v25 + 8);
            BOOL v43 = (unsigned int *)(v33 + 4 * v19 + 8);
            unint64_t v44 = a11;
            do
            {
              int v45 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2));
              unint64_t v46 = ((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE;
              int v47 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1));
              unint64_t v48 = ((unint64_t)*(v43 - 1) >> 15) & 0x1FFFE;
              unint64_t v50 = *v43;
              unint64_t v49 = v43[1];
              v43 += 4;
              unint64_t v51 = *(v42 - 1);
              int v52 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 2));
              LODWORD(v48) = v47 | (*(unsigned __int16 *)(a13 + v48) << 16);
              int v53 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE));
              v34.i32[0] = v45 | (*(unsigned __int16 *)(a13 + v46) << 16);
              v35.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v50) | (*(unsigned __int16 *)(a13 + ((v50 >> 15) & 0x1FFFE)) << 16);
              LODWORD(v46) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 1));
              v34.i32[2] = v48;
              v35.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v49) | (*(unsigned __int16 *)(a13 + ((v49 >> 15) & 0x1FFFE)) << 16);
              unint64_t v54 = *v42;
              unint64_t v55 = v42[1];
              v42 += 4;
              unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v54);
              int32x4_t v56 = vzip2q_s32(vuzp1q_s32(v35, v35), v67);
              int32x4_t v57 = vzip1q_s32(vuzp1q_s32(v34, v34), v67);
              int32x4_t v58 = vzip1q_s32(v57, v68);
              v58.i32[3] = v52 | (v53 << 16);
              int32x4_t v34 = vzip2q_s32(v57, v68);
              v34.i32[3] = v46 | (*(unsigned __int16 *)(a13 + ((v51 >> 15) & 0x1FFFE)) << 16);
              int32x4_t v59 = vzip1q_s32(v56, v68);
              v59.i32[3] = result | (*(unsigned __int16 *)(a13 + ((v54 >> 15) & 0x1FFFE)) << 16);
              int32x4_t v35 = vzip2q_s32(v56, v68);
              v35.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v55) | (*(unsigned __int16 *)(a13 + ((v55 >> 15) & 0x1FFFE)) << 16);
              uint64_t v40 = v44 + 4;
              unint64_t v39 = v41 + 4;
              unint64_t v60 = v41 + 8;
              v44[2] = v59;
              v44[3] = v35;
              *unint64_t v44 = v58;
              v44[1] = v34;
              v41 += 4;
              v44 += 4;
            }
            while (v60 <= a9);
          }
          else
          {
            unint64_t v39 = 0;
            uint64_t v40 = a11;
          }
          uint64_t v61 = a9 - v39;
          if (a9 > v39)
          {
            unsigned int v62 = (unsigned int *)(v33 + 4 * v19 + 4 * v39);
            unsigned int v63 = (unsigned int *)(v36 + 4 * v25 + 4 * v39);
            do
            {
              unsigned int v64 = *v62++;
              v34.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v64) | (*(unsigned __int16 *)(a13 + (((unint64_t)v64 >> 15) & 0x1FFFE)) << 16);
              v34.i32[2] = v23;
              unsigned int v65 = *v63++;
              int32x4_t v66 = v69;
              v66.i32[1] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v65) | (*(unsigned __int16 *)(a13 + (((unint64_t)v65 >> 15) & 0x1FFFE)) << 16);
              int32x4_t v34 = vzip1q_s32(vuzp1q_s32(v34, v34), v66);
              *v40++ = v34;
              --v61;
            }
            while (v61);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v72, (v31 + v29), v71, v70);
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v29 += a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t a5, uint64_t **a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12, uint64_t a13)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v21 = _D0;
  }
  else
  {
    unsigned int v21 = 32256;
  }
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v23 = *(unsigned int *)(a3 + 44);
  uint64_t v67 = v22;
  int32x4_t v68 = *(ChannelDescription **)(a5 + 8);
  unsigned int v66 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v68, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v66);
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v25 = _D0;
  }
  else
  {
    unsigned int v25 = 32256;
  }
  unsigned int v26 = *(ChannelDescription **)(a7 + 8);
  uint64_t v27 = *(void *)(a3 + 24);
  uint64_t v28 = *(unsigned int *)(a3 + 44);
  unsigned int v29 = *(_DWORD *)(a3 + 60);
  uint64_t v64 = v27;
  unsigned int v65 = v26;
  unint64_t result = ChannelDescription::GetLocationForTile(v26, (*(_DWORD *)(a3 + 52) + HIDWORD(v27) * *(_DWORD *)(a2 + 60)), v27, v29);
  unint64_t v33 = *(void *)(a2 + 56);
  uint64_t v34 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v34 < HIDWORD(v33))
  {
    uint64_t v35 = v23;
    v74.val[0] = (int8x16_t)vdupq_n_s16(v21);
    int v37 = *(_DWORD *)(a3 + 28) * HIDWORD(v33);
    v74.val[1] = (int8x16_t)vdupq_n_s16(v25);
    v74.val[0] = vqtbl2q_s8(v74, (int8x16_t)xmmword_228F41C10);
    int16x8_t v38 = vzip2q_s16((int16x8_t)v74.val[0], (int16x8_t)v74.val[0]);
    int16x8_t v39 = vzip1q_s16((int16x8_t)v74.val[0], (int16x8_t)v74.val[0]);
    v74.val[0].i32[0] = v21;
    v74.val[0].i16[2] = v25;
    uint64_t v63 = 2 * v28;
    uint64_t v61 = 2 * v35;
    uint64_t v62 = 2 * v28 + 4;
    uint64_t v60 = 2 * v35 + 4;
    int16x4_t v40 = vuzp1_s16(*(int16x4_t *)v74.val[0].i8, *(int16x4_t *)v74.val[0].i8);
    do
    {
      int16x8_t v70 = v39;
      long long v71 = v32;
      int16x8_t v72 = v38;
      long long v73 = v31;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v68, (v37 + v34), v67, v66);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v42 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v65, (v37 + v34), v64, v29);
        uint64_t v44 = a1 + result;
        if (HIDWORD(result)) {
          _ZF = v42 == 0;
        }
        else {
          _ZF = 1;
        }
        BOOL v46 = _ZF || v44 == 0;
        int16x8_t v38 = v72;
        long long v31 = v73;
        int16x8_t v39 = v70;
        long long v32 = v71;
        if (!v46)
        {
          if (a9 >= 4)
          {
            uint64_t v49 = 0;
            unint64_t v50 = (unsigned __int16 *)(v44 + v62);
            unint64_t v51 = (unsigned __int16 *)(v42 + v60);
            int v52 = a11;
            do
            {
              unint64_t result = a13 + 2 * *(v50 - 1);
              LOWORD(v32) = *(_WORD *)(a13 + 2 * *(v51 - 2));
              WORD1(v32) = *(_WORD *)(a13 + 2 * *(v50 - 2));
              WORD2(v32) = *(_WORD *)(a13 + 2 * *(v51 - 1));
              WORD3(v32) = *(_WORD *)result;
              WORD4(v32) = *(_WORD *)(a13 + 2 * *v51);
              WORD5(v32) = *(_WORD *)(a13 + 2 * *v50);
              WORD6(v32) = *(_WORD *)(a13 + 2 * v51[1]);
              HIWORD(v32) = *(_WORD *)(a13 + 2 * v50[1]);
              int8x16_t v43 = vqtbl2q_s8(*(int8x16x2_t *)(&v32 - 1), (int8x16_t)xmmword_228F41C10);
              long long v31 = v32;
              unint64_t v48 = v52 + 2;
              unint64_t v47 = v49 + 4;
              unint64_t v53 = v49 + 8;
              v50 += 4;
              int8x16_t *v52 = v43;
              v52[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v31 - 1), (int8x16_t)xmmword_228F41BF0);
              v51 += 4;
              v49 += 4;
              v52 += 2;
            }
            while (v53 <= a9);
          }
          else
          {
            unint64_t v47 = 0;
            unint64_t v48 = a11;
          }
          uint64_t v54 = a9 - v47;
          if (a9 > v47)
          {
            unint64_t v55 = (unsigned __int16 *)(v42 + v61 + 2 * v47);
            int32x4_t v56 = (unsigned __int16 *)(v44 + v63 + 2 * v47);
            do
            {
              unsigned int v58 = *v55++;
              uint64_t v57 = v58;
              unsigned int v59 = *v56++;
              v43.i16[0] = *(_WORD *)(a13 + 2 * v57);
              v43.i16[1] = *(_WORD *)(a13 + 2 * v59);
              *(int16x4_t *)v43.i8 = vzip1_s16(v40, *(int16x4_t *)v43.i8);
              v48->i64[0] = v43.i64[0];
              unint64_t v48 = (int8x16_t *)((char *)v48 + 8);
              --v54;
            }
            while (v54);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v65, (v37 + v34), v64, v29);
        int16x8_t v38 = v72;
        long long v31 = v73;
        int16x8_t v39 = v70;
        long long v32 = v71;
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v34 += a10;
    }
    while (v34 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    float v17 = **(double **)a4;
    float v18 = v17;
  }
  else
  {
    float v18 = NAN;
  }
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v20 = *(unsigned int *)(a3 + 44);
  uint64_t v73 = v19;
  int8x16x2_t v74 = *(ChannelDescription **)(a5 + 8);
  unsigned int v72 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v74, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v72);
  if (*(unsigned char *)(*(void *)a6 + 24))
  {
    float v21 = **(double **)a6;
    float v22 = v21;
  }
  else
  {
    float v22 = NAN;
  }
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v24 = *(unsigned int *)(a3 + 44);
  unsigned int v25 = *(_DWORD *)(a3 + 60);
  uint64_t v70 = v23;
  long long v71 = *(ChannelDescription **)(a7 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v71, (*(_DWORD *)(a3 + 52) + HIDWORD(v23) * *(_DWORD *)(a2 + 60)), v23, v25);
  unint64_t v28 = *(void *)(a2 + 56);
  uint64_t v29 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v29 < HIDWORD(v28))
  {
    uint64_t v30 = v20;
    *(float *)v27.i32 = v18;
    *(float *)&v27.i32[2] = v22;
    int v32 = *(_DWORD *)(a3 + 28) * HIDWORD(v28);
    uint64_t v68 = 4 * v30;
    uint64_t v67 = 4 * v30 + 8;
    int32x4_t v69 = vuzp1q_s32(v27, v27);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v74, (v32 + v29), v73, v72);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v34 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v71, (v32 + v29), v70, v25);
        uint64_t v36 = a1 + result;
        if (HIDWORD(result)) {
          BOOL v37 = v34 == 0;
        }
        else {
          BOOL v37 = 1;
        }
        if (!v37 && v36 != 0)
        {
          if (a9 >= 4)
          {
            uint64_t v41 = 0;
            uint64_t v42 = (unsigned int *)(v36 + 4 * v24 + 8);
            int8x16_t v43 = (unsigned int *)(v34 + v67);
            uint64_t v44 = a11;
            do
            {
              int v45 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2));
              unint64_t v46 = ((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE;
              int v47 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1));
              unint64_t v48 = (unint64_t)*(v43 - 1) >> 15;
              unint64_t v50 = *v43;
              unint64_t v49 = v43[1];
              v43 += 4;
              int v51 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 2));
              int v52 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE));
              LODWORD(v46) = v45 | (*(unsigned __int16 *)(a13 + v46) << 16);
              LODWORD(v48) = v47 | (*(unsigned __int16 *)(a13 + (v48 & 0x1FFFE)) << 16);
              int v53 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 1));
              int v54 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 1) >> 15) & 0x1FFFE));
              unint64_t v55 = *v42;
              unint64_t v56 = v42[1];
              v42 += 4;
              unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v49) | (*(unsigned __int16 *)(a13 + ((v49 >> 15) & 0x1FFFE)) << 16);
              v57.i16[0] = *(_WORD *)(a13 + 2 * (unsigned __int16)v50);
              v57.i16[1] = *(_WORD *)(a13 + ((v50 >> 15) & 0x1FFFE));
              v57.i16[2] = *(_WORD *)(a13 + 2 * (unsigned __int16)v55);
              v57.i16[3] = *(_WORD *)(a13 + ((v55 >> 15) & 0x1FFFE));
              v58.i32[0] = v46;
              v57.i32[2] = result;
              v58.i32[1] = v51 | (v52 << 16);
              v58.i64[1] = __PAIR64__(v53 | (v54 << 16), v48);
              v57.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v56);
              v57.i16[7] = *(_WORD *)(a13 + ((v56 >> 15) & 0x1FFFE));
              int32x4_t v59 = vzip1q_s32(v69, v57);
              int32x4_t v35 = vzip2q_s32(v69, v57);
              int16x4_t v40 = v44 + 4;
              unint64_t v39 = v41 + 4;
              unint64_t v60 = v41 + 8;
              v44[2] = v59;
              v44[3] = v35;
              *uint64_t v44 = vzip1q_s32(v69, v58);
              v44[1] = vzip2q_s32(v69, v58);
              v41 += 4;
              v44 += 4;
            }
            while (v60 <= a9);
          }
          else
          {
            unint64_t v39 = 0;
            int16x4_t v40 = a11;
          }
          uint64_t v61 = a9 - v39;
          if (a9 > v39)
          {
            uint64_t v62 = (unsigned int *)(v34 + v68 + 4 * v39);
            uint64_t v63 = (unsigned int *)(v36 + 4 * v24 + 4 * v39);
            do
            {
              unsigned int v64 = *v62++;
              int v65 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v64) | (*(unsigned __int16 *)(a13 + (((unint64_t)v64 >> 15) & 0x1FFFE)) << 16);
              unsigned int v66 = *v63++;
              v35.i32[0] = v65;
              v35.i32[1] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v66) | (*(unsigned __int16 *)(a13 + (((unint64_t)v66 >> 15) & 0x1FFFE)) << 16);
              int32x4_t v35 = vzip1q_s32(v69, v35);
              *v40++ = v35;
              --v61;
            }
            while (v61);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v71, (v32 + v29), v70, v25);
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v29 += a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int16x8_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v70 = *(unsigned int *)(a3 + 44);
  uint64_t v71 = v19;
  unsigned int v72 = *(ChannelDescription **)(a4 + 8);
  unsigned int v69 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v69);
  uint64_t v73 = a2;
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v66 = *(unsigned int *)(a3 + 44);
  uint64_t v67 = v20;
  uint64_t v68 = *(ChannelDescription **)(a5 + 8);
  unsigned int v65 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v68, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v65);
  if (*((unsigned char *)*a6 + 24))
  {
    _D0 = **a6;
    __asm { FCVT            H0, D0 }
    unsigned int v25 = _D0;
  }
  else
  {
    unsigned int v25 = 32256;
  }
  uint64_t v26 = *(void *)(a3 + 24);
  uint64_t v62 = *(unsigned int *)(a3 + 44);
  uint64_t v63 = v26;
  unsigned int v64 = *(ChannelDescription **)(a7 + 8);
  unsigned int v61 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v64, (*(_DWORD *)(a3 + 52) + HIDWORD(v26) * *(_DWORD *)(a2 + 60)), v26, v61);
  unint64_t v29 = *(void *)(a2 + 56);
  uint64_t v30 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v30 < HIDWORD(v29))
  {
    int v60 = *(_DWORD *)(a3 + 28) * HIDWORD(v29);
    int16x8_t v32 = vdupq_n_s16(v25);
    do
    {
      long long v74 = v28;
      int16x8_t v75 = v32;
      unint64_t v33 = (v60 + v30);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v72, v33, v71, v69);
      if (HIDWORD(LocationForTile)) {
        uint64_t v35 = a1 + LocationForTile + 2 * v70;
      }
      else {
        uint64_t v35 = 0;
      }
      unint64_t v36 = ChannelDescription::GetLocationForTile(v68, v33, v67, v65);
      if (HIDWORD(v36)) {
        uint64_t v37 = a1 + v36 + 2 * v66;
      }
      else {
        uint64_t v37 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v64, v33, v63, v61);
      long long v28 = v74;
      int16x8_t v32 = v75;
      uint64_t v38 = a1 + result + 2 * v62;
      if (!HIDWORD(result)) {
        uint64_t v38 = 0;
      }
      if (v35) {
        _ZF = v37 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v38 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v43 = 0;
          uint64_t v44 = 0;
          uint64_t v45 = v35 + 4;
          unint64_t v46 = a11;
          do
          {
            LOWORD(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v35 + v43));
            WORD2(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v45 + v43 - 2));
            WORD4(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v45 + v43));
            WORD6(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v45 + v43 + 2));
            unint64_t result = a13 + 2 * *(unsigned __int16 *)(v38 + v43);
            v47.i16[0] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v43));
            v47.i16[1] = *(_WORD *)result;
            v47.i16[2] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v43 + 2));
            v47.i16[3] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v38 + v43 + 2));
            v47.i16[4] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v43 + 4));
            v47.i16[5] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v38 + v43 + 4));
            v47.i16[6] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v43 + 6));
            v47.i16[7] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v38 + v43 + 6));
            int16x8_t v48 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v28, (int8x16_t)xmmword_228F41C10);
            uint64_t v42 = v46 + 2;
            unint64_t v41 = v44 + 4;
            unint64_t v49 = v44 + 8;
            *unint64_t v46 = vzip1q_s16(v48, v47);
            v46[1] = vzip2q_s16(v48, v47);
            v43 += 8;
            v44 += 4;
            v46 += 2;
          }
          while (v49 <= a9);
        }
        else
        {
          unint64_t v41 = 0;
          uint64_t v42 = a11;
        }
        uint64_t v50 = a9 - v41;
        if (a9 > v41)
        {
          int v51 = (unsigned __int16 *)(v35 + 2 * v41);
          int v52 = (unsigned __int16 *)(v37 + 2 * v41);
          int v53 = (unsigned __int16 *)(v38 + 2 * v41);
          do
          {
            unsigned int v55 = *v51++;
            uint64_t v54 = v55;
            unsigned int v56 = *v52++;
            int32x4_t v57 = (_WORD *)(a13 + 2 * v56);
            unsigned int v58 = *v53++;
            LOWORD(v59) = *(_WORD *)(a13 + 2 * v54);
            WORD1(v59) = *v57;
            WORD2(v59) = v25;
            HIWORD(v59) = *(_WORD *)(a13 + 2 * v58);
            v42->i64[0] = v59;
            uint64_t v42 = (int16x8_t *)((char *)v42 + 8);
            --v50;
          }
          while (v50);
        }
      }
      a11 = (int16x8_t *)((char *)a11 + a12);
      v30 += a10;
    }
    while (v30 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(v73 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v88 = *(unsigned int *)(a3 + 44);
  uint64_t v89 = v19;
  uint64_t v90 = *(ChannelDescription **)(a4 + 8);
  unsigned int v87 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v90, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v87);
  uint64_t v91 = a2;
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v84 = *(unsigned int *)(a3 + 44);
  uint64_t v85 = v20;
  uint64_t v86 = *(ChannelDescription **)(a5 + 8);
  unsigned int v83 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v86, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v83);
  if (*(unsigned char *)(*(void *)a6 + 24))
  {
    *(float *)&unsigned int v21 = **(double **)a6;
    unsigned int v22 = v21;
  }
  else
  {
    unsigned int v22 = 2143289344;
  }
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v80 = *(unsigned int *)(a3 + 44);
  uint64_t v81 = v23;
  int32x4_t v82 = *(ChannelDescription **)(a7 + 8);
  unsigned int v79 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v82, (*(_DWORD *)(a3 + 52) + HIDWORD(v23) * *(_DWORD *)(a2 + 60)), v23, v79);
  unint64_t v25 = *(void *)(a2 + 56);
  uint64_t v26 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v26 < HIDWORD(v25))
  {
    int v78 = *(_DWORD *)(a3 + 28) * HIDWORD(v25);
    int32x4_t v77 = vdupq_n_s32(v22);
    do
    {
      unint64_t v28 = (v78 + v26);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v90, v28, v89, v87);
      if (HIDWORD(LocationForTile)) {
        uint64_t v30 = a1 + LocationForTile + 4 * v88;
      }
      else {
        uint64_t v30 = 0;
      }
      unint64_t v31 = ChannelDescription::GetLocationForTile(v86, v28, v85, v83);
      if (HIDWORD(v31)) {
        uint64_t v32 = a1 + v31 + 4 * v84;
      }
      else {
        uint64_t v32 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v82, v28, v81, v79);
      uint64_t v37 = a1 + result + 4 * v80;
      if (!HIDWORD(result)) {
        uint64_t v37 = 0;
      }
      if (v30) {
        BOOL v38 = v32 == 0;
      }
      else {
        BOOL v38 = 1;
      }
      if (!v38 && v37 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v42 = 0;
          uint64_t v43 = (unsigned int *)(v37 + 8);
          uint64_t v44 = (unsigned int *)(v32 + 8);
          uint64_t v45 = (unsigned int *)(v30 + 8);
          unint64_t v46 = a11;
          do
          {
            int v47 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v45 - 2));
            unint64_t v48 = ((unint64_t)*(v45 - 2) >> 15) & 0x1FFFE;
            int v49 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v45 - 1));
            unint64_t v50 = ((unint64_t)*(v45 - 1) >> 15) & 0x1FFFE;
            unint64_t v51 = *v45;
            unint64_t v52 = v45[1];
            v45 += 4;
            LODWORD(v48) = v47 | (*(unsigned __int16 *)(a13 + v48) << 16);
            LODWORD(v50) = v49 | (*(unsigned __int16 *)(a13 + v50) << 16);
            int v53 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v44 - 1));
            int v54 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v44 - 1) >> 15) & 0x1FFFE));
            int v55 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v44 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v44 - 2) >> 15) & 0x1FFFE)) << 16);
            unint64_t v57 = *v44;
            unint64_t v56 = v44[1];
            v44 += 4;
            v33.i32[0] = v48;
            v34.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v51) | (*(unsigned __int16 *)(a13 + ((v51 >> 15) & 0x1FFFE)) << 16);
            v35.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v57) | (*(unsigned __int16 *)(a13 + ((v57 >> 15) & 0x1FFFE)) << 16);
            v36.i32[0] = v55;
            int v58 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE)) << 16);
            v33.i32[2] = v50;
            v34.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v52) | (*(unsigned __int16 *)(a13 + ((v52 >> 15) & 0x1FFFE)) << 16);
            LODWORD(v50) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v43 - 1) >> 15) & 0x1FFFE)) << 16);
            v35.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v56) | (*(unsigned __int16 *)(a13 + ((v56 >> 15) & 0x1FFFE)) << 16);
            unint64_t v60 = *v43;
            unint64_t v59 = v43[1];
            v43 += 4;
            v36.i32[2] = v53 | (v54 << 16);
            int32x4_t v61 = vzip2q_s32(vuzp1q_s32(v34, v34), v77);
            unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v59);
            int32x4_t v62 = vzip1q_s32(vuzp1q_s32(v33, v33), v77);
            int32x4_t v63 = vzip1q_s32(v62, v36);
            v63.i32[3] = v58;
            int32x4_t v33 = vzip2q_s32(v62, v36);
            int32x4_t v36 = vzip1q_s32(v61, v35);
            v33.i32[3] = v50;
            v36.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v60) | (*(unsigned __int16 *)(a13 + ((v60 >> 15) & 0x1FFFE)) << 16);
            int32x4_t v34 = vzip2q_s32(v61, v35);
            v34.i32[3] = result | (*(unsigned __int16 *)(a13 + ((v59 >> 15) & 0x1FFFE)) << 16);
            unint64_t v41 = v46 + 4;
            unint64_t v40 = v42 + 4;
            unint64_t v64 = v42 + 8;
            v46[2] = v36;
            void v46[3] = v34;
            *unint64_t v46 = v63;
            v46[1] = v33;
            v42 += 4;
            v46 += 4;
          }
          while (v64 <= a9);
        }
        else
        {
          unint64_t v40 = 0;
          unint64_t v41 = a11;
        }
        uint64_t v65 = a9 - v40;
        if (a9 > v40)
        {
          uint64_t v66 = (unsigned int *)(v30 + 4 * v40);
          uint64_t v67 = (unsigned int *)(v32 + 4 * v40);
          uint64_t v68 = (unsigned int *)(v37 + 4 * v40);
          do
          {
            unsigned int v69 = *v66++;
            int v70 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v69);
            unint64_t v71 = ((unint64_t)v69 >> 15) & 0x1FFFE;
            unsigned int v72 = *v67++;
            int v73 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v72);
            LODWORD(v71) = v70 | (*(unsigned __int16 *)(a13 + v71) << 16);
            int v74 = *(unsigned __int16 *)(a13 + (((unint64_t)v72 >> 15) & 0x1FFFE));
            unsigned int v75 = *v68++;
            v76.i32[0] = v71;
            v76.i32[1] = v73 | (v74 << 16);
            v76.i32[2] = v22;
            v76.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v75) | (*(unsigned __int16 *)(a13 + (((unint64_t)v75 >> 15) & 0x1FFFE)) << 16);
            *v41++ = v76;
            --v65;
          }
          while (v65);
        }
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v26 += a10;
    }
    while (v26 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(v91 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int16x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v20 = _D0;
  }
  else
  {
    unsigned int v20 = 32256;
  }
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v22 = _D0;
  }
  else
  {
    unsigned int v22 = 32256;
  }
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v24 = *(unsigned int *)(a3 + 44);
  uint64_t v77 = v23;
  int v78 = *(ChannelDescription **)(a6 + 8);
  unsigned int v76 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v78, (*(_DWORD *)(a3 + 52) + HIDWORD(v23) * *(_DWORD *)(a2 + 60)), v23, v76);
  unint64_t v25 = *(ChannelDescription **)(a7 + 8);
  uint64_t v26 = *(void *)(a3 + 24);
  uint64_t v27 = *(unsigned int *)(a3 + 44);
  unsigned int v28 = *(_DWORD *)(a3 + 60);
  uint64_t v74 = v26;
  unsigned int v75 = v25;
  unint64_t result = ChannelDescription::GetLocationForTile(v25, (*(_DWORD *)(a3 + 52) + HIDWORD(v26) * *(_DWORD *)(a2 + 60)), v26, v28);
  unint64_t v33 = *(void *)(a2 + 56);
  uint64_t v34 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v34 < HIDWORD(v33))
  {
    uint64_t v35 = v24;
    int v37 = *(_DWORD *)(a3 + 28) * HIDWORD(v33);
    v30.i32[0] = v20;
    int16x8_t v38 = vdupq_n_s16(v20);
    v32.i32[0] = v22;
    uint64_t v70 = 2 * v27;
    uint64_t v68 = 2 * v35;
    uint64_t v69 = 2 * v27 + 4;
    uint64_t v67 = 2 * v35 + 4;
    int16x4_t v72 = v32;
    int16x4_t v73 = v30;
    int16x8_t v71 = vdupq_n_s16(v22);
    do
    {
      int16x8_t v80 = v38;
      long long v81 = v31;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v78, (v37 + v34), v77, v76);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v40 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v75, (v37 + v34), v74, v28);
        uint64_t v42 = a1 + result;
        if (HIDWORD(result)) {
          _ZF = v40 == 0;
        }
        else {
          _ZF = 1;
        }
        BOOL v44 = _ZF || v42 == 0;
        int16x8_t v38 = v80;
        long long v31 = v81;
        if (!v44)
        {
          if (a9 >= 4)
          {
            uint64_t v47 = 0;
            unint64_t v48 = (unsigned __int16 *)(v42 + v69);
            int v49 = (unsigned __int16 *)(v40 + v67);
            unint64_t v50 = a11;
            do
            {
              LOWORD(v31) = *(_WORD *)(a13 + 2 * *(v49 - 2));
              WORD1(v31) = *(_WORD *)(a13 + 2 * *(v49 - 1));
              WORD2(v31) = *(_WORD *)(a13 + 2 * *v49);
              WORD3(v31) = *(_WORD *)(a13 + 2 * v49[1]);
              int16x8_t v51 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v31 - 1), (int8x16_t)xmmword_228F41C10);
              __int16 v52 = *(_WORD *)(a13 + 2 * *(v48 - 2));
              __int16 v53 = *(_WORD *)(a13 + 2 * *(v48 - 1));
              __int16 v54 = *(_WORD *)(a13 + 2 * *v48);
              __int16 v55 = *(_WORD *)(a13 + 2 * v48[1]);
              int16x8_t v56 = vzip1q_s16(v51, v71);
              int8x16_t v57 = vqtbl2q_s8(*(int8x16x2_t *)(&v41 - 3), (int8x16_t)xmmword_228F41C70);
              int16x8_t v58 = vzip2q_s16(v51, v71);
              unint64_t v46 = v50 + 4;
              unint64_t v45 = v47 + 4;
              unint64_t v59 = v47 + 8;
              v48 += 4;
              *(int8x16_t *)v50->i8 = v57;
              *(int8x16_t *)v50[2].i8 = vqtbl2q_s8(*(int8x16x2_t *)(&v41 - 3), (int8x16_t)xmmword_228F41C50);
              v49 += 4;
              v47 += 4;
              v50 += 4;
            }
            while (v59 <= a9);
          }
          else
          {
            unint64_t v45 = 0;
            unint64_t v46 = a11;
          }
          uint64_t v60 = a9 - v45;
          if (a9 > v45)
          {
            int32x4_t v61 = (unsigned __int16 *)(v40 + v68 + 2 * v45);
            int32x4_t v62 = (unsigned __int16 *)(v42 + v70 + 2 * v45);
            do
            {
              unsigned int v63 = *v61++;
              int16x4_t v64 = v73;
              v64.i16[2] = *(_WORD *)(a13 + 2 * v63);
              unsigned int v65 = *v62++;
              int16x4_t v66 = v72;
              v66.i16[1] = *(_WORD *)(a13 + 2 * v65);
              *v46++ = vzip1_s16(vuzp1_s16(v64, v64), v66);
              --v60;
            }
            while (v60);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v75, (v37 + v34), v74, v28);
        int16x8_t v38 = v80;
        long long v31 = v81;
      }
      a11 = (int16x4_t *)((char *)a11 + a12);
      v34 += a10;
    }
    while (v34 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    float v16 = **(double **)a4;
    float v17 = v16;
  }
  else
  {
    float v17 = NAN;
  }
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    *(float *)&unsigned int v18 = **(double **)a5;
    unsigned int v19 = v18;
  }
  else
  {
    unsigned int v19 = 2143289344;
  }
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v21 = *(unsigned int *)(a3 + 44);
  uint64_t v78 = v20;
  unsigned int v79 = *(ChannelDescription **)(a6 + 8);
  unsigned int v77 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v77);
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v23 = *(unsigned int *)(a3 + 44);
  unsigned int v24 = *(_DWORD *)(a3 + 60);
  uint64_t v75 = v22;
  unsigned int v76 = *(ChannelDescription **)(a7 + 8);
  unint64_t result = ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v24);
  unint64_t v28 = *(void *)(a2 + 56);
  uint64_t v29 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v29 < HIDWORD(v28))
  {
    unsigned int v30 = LODWORD(v17);
    int v32 = *(_DWORD *)(a3 + 28) * HIDWORD(v28);
    v26.i32[0] = v30;
    int32x4_t v33 = vdupq_n_s32(v30);
    v27.i32[0] = v19;
    uint64_t v70 = 4 * v23;
    uint64_t v69 = 4 * v23 + 8;
    int32x4_t v73 = vdupq_n_s32(v19);
    int32x4_t v74 = v26;
    int32x4_t v71 = vuzp1q_s32(v33, v33);
    int32x4_t v72 = v27;
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v79, (v32 + v29), v78, v77);
      if (HIDWORD(LocationForTile))
      {
        uint64_t v35 = a1 + LocationForTile;
        unint64_t result = ChannelDescription::GetLocationForTile(v76, (v32 + v29), v75, v24);
        uint64_t v36 = a1 + result;
        if (HIDWORD(result)) {
          BOOL v37 = v35 == 0;
        }
        else {
          BOOL v37 = 1;
        }
        if (!v37 && v36 != 0)
        {
          if (a9 >= 4)
          {
            uint64_t v41 = 0;
            uint64_t v42 = (unsigned int *)(v36 + v69);
            uint64_t v43 = (unsigned int *)(v35 + 4 * v21 + 8);
            BOOL v44 = a11;
            do
            {
              int v45 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1));
              int v46 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v43 - 1) >> 15) & 0x1FFFE));
              int v47 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE)) << 16);
              unint64_t v48 = *v43;
              unint64_t v49 = v43[1];
              v43 += 4;
              v50.i32[0] = v47;
              v50.i32[1] = v45 | (v46 << 16);
              v50.i16[4] = *(_WORD *)(a13 + 2 * (unsigned __int16)v48);
              v50.i16[5] = *(_WORD *)(a13 + ((v48 >> 15) & 0x1FFFE));
              LODWORD(v48) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 2));
              unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 1));
              int v51 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE));
              unint64_t v52 = ((unint64_t)*(v42 - 1) >> 15) & 0x1FFFE;
              v50.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v49);
              v50.i16[7] = *(_WORD *)(a13 + ((v49 >> 15) & 0x1FFFE));
              unint64_t v54 = *v42;
              unint64_t v53 = v42[1];
              v42 += 4;
              int32x4_t v55 = vzip2q_s32(v71, v50);
              int32x4_t v56 = vzip1q_s32(v71, v50);
              int32x4_t v57 = vzip1q_s32(v56, v73);
              v57.i32[3] = v48 | (v51 << 16);
              int32x4_t v58 = vzip2q_s32(v56, v73);
              v58.i32[3] = result | (*(unsigned __int16 *)(a13 + v52) << 16);
              int32x4_t v59 = vzip1q_s32(v55, v73);
              v59.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v54) | (*(unsigned __int16 *)(a13 + ((v54 >> 15) & 0x1FFFE)) << 16);
              int32x4_t v60 = vzip2q_s32(v55, v73);
              v60.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v53) | (*(unsigned __int16 *)(a13 + ((v53 >> 15) & 0x1FFFE)) << 16);
              uint64_t v40 = v44 + 4;
              unint64_t v39 = v41 + 4;
              unint64_t v61 = v41 + 8;
              v44[2] = v59;
              v44[3] = v60;
              *BOOL v44 = v57;
              v44[1] = v58;
              v41 += 4;
              v44 += 4;
            }
            while (v61 <= a9);
          }
          else
          {
            unint64_t v39 = 0;
            uint64_t v40 = a11;
          }
          uint64_t v62 = a9 - v39;
          if (a9 > v39)
          {
            unsigned int v63 = (unsigned int *)(v35 + 4 * v21 + 4 * v39);
            int16x4_t v64 = (unsigned int *)(v36 + v70 + 4 * v39);
            do
            {
              unsigned int v65 = *v63++;
              int32x4_t v66 = v74;
              v66.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v65) | (*(unsigned __int16 *)(a13 + (((unint64_t)v65 >> 15) & 0x1FFFE)) << 16);
              unsigned int v67 = *v64++;
              int32x4_t v68 = v72;
              v68.i32[1] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v67) | (*(unsigned __int16 *)(a13 + (((unint64_t)v67 >> 15) & 0x1FFFE)) << 16);
              *v40++ = vzip1q_s32(vuzp1q_s32(v66, v66), v68);
              --v62;
            }
            while (v62);
          }
        }
      }
      else
      {
        unint64_t result = ChannelDescription::GetLocationForTile(v76, (v32 + v29), v75, v24);
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v29 += a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int8x16_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v79 = *(unsigned int *)(a3 + 44);
  long long v81 = *(ChannelDescription **)(a4 + 8);
  unint64_t v80 = v18;
  unsigned int v78 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v81, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v78);
  if (*((unsigned char *)*a5 + 24))
  {
    _D0 = **a5;
    __asm { FCVT            H0, D0 }
    unsigned int v23 = _D0;
  }
  else
  {
    unsigned int v23 = 32256;
  }
  uint64_t v24 = *(void *)(a3 + 24);
  uint64_t v75 = *(unsigned int *)(a3 + 44);
  uint64_t v76 = v24;
  unsigned int v77 = *(ChannelDescription **)(a6 + 8);
  unsigned int v74 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v77, (*(_DWORD *)(a3 + 52) + HIDWORD(v24) * *(_DWORD *)(a2 + 60)), v24, v74);
  uint64_t v25 = *(void *)(a3 + 24);
  uint64_t v71 = *(unsigned int *)(a3 + 44);
  uint64_t v72 = v25;
  int32x4_t v73 = *(ChannelDescription **)(a7 + 8);
  unsigned int v70 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v73, (*(_DWORD *)(a3 + 52) + HIDWORD(v25) * *(_DWORD *)(a2 + 60)), v25, v70);
  unint64_t v29 = *(void *)(a2 + 56);
  uint64_t v30 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v30 < HIDWORD(v29))
  {
    int v32 = *(_DWORD *)(a3 + 28) * HIDWORD(v29);
    v27.i32[0] = v23;
    int16x8_t v33 = vdupq_n_s16(v23);
    int16x4_t v69 = v27;
    do
    {
      int16x8_t v83 = v33;
      long long v84 = v28;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v81, (v32 + v30), v80, v78);
      if (HIDWORD(LocationForTile)) {
        uint64_t v35 = a1 + LocationForTile + 2 * v79;
      }
      else {
        uint64_t v35 = 0;
      }
      unint64_t v36 = ChannelDescription::GetLocationForTile(v77, (v32 + v30), v76, v74);
      if (HIDWORD(v36)) {
        uint64_t v37 = a1 + v36 + 2 * v75;
      }
      else {
        uint64_t v37 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v73, (v32 + v30), v72, v70);
      int16x8_t v33 = v83;
      long long v28 = v84;
      uint64_t v43 = a1 + result + 2 * v71;
      if (!HIDWORD(result)) {
        uint64_t v43 = 0;
      }
      if (v35) {
        _ZF = v37 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v43 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v48 = 0;
          uint64_t v49 = 0;
          uint64_t v50 = v35 + 4;
          int v51 = a11;
          do
          {
            unint64_t result = a13 + 2 * *(unsigned __int16 *)(v37 + v48);
            LOWORD(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v43 + v48));
            WORD1(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v43 + v48 + 2));
            WORD2(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v43 + v48 + 4));
            WORD3(v28) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v43 + v48 + 6));
            int8x16_t v52 = vqtbl2q_s8(*(int8x16x2_t *)(&v28 - 1), (int8x16_t)xmmword_228F41C10);
            __int16 v53 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v50 + v48));
            __int16 v54 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v48 + 4));
            __int16 v55 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v50 + v48 + 2));
            __int16 v56 = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v48 + 6));
            v38.i16[0] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v35 + v48));
            v38.i16[2] = *(_WORD *)result;
            v38.i16[4] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v50 + v48 - 2));
            v38.i16[6] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v37 + v48 + 2));
            int8x16_t v57 = vqtbl2q_s8(*(int8x16x2_t *)v38.i8, (int8x16_t)xmmword_228F41C10);
            int8x16_t v58 = v52;
            int8x16_t v38 = vqtbl2q_s8(*(int8x16x2_t *)(&v39 - 1), (int8x16_t)xmmword_228F41BF0);
            int v47 = v51 + 2;
            unint64_t v46 = v49 + 4;
            unint64_t v59 = v49 + 8;
            *int v51 = v57;
            v51[1] = v38;
            v48 += 8;
            v49 += 4;
            v51 += 2;
          }
          while (v59 <= a9);
        }
        else
        {
          unint64_t v46 = 0;
          int v47 = a11;
        }
        uint64_t v60 = a9 - v46;
        if (a9 > v46)
        {
          unint64_t v61 = (unsigned __int16 *)(v35 + 2 * v46);
          uint64_t v62 = (unsigned __int16 *)(v37 + 2 * v46);
          unsigned int v63 = (unsigned __int16 *)(v43 + 2 * v46);
          do
          {
            unsigned int v65 = *v61++;
            uint64_t v64 = v65;
            unsigned int v66 = *v62++;
            v38.i16[0] = *(_WORD *)(a13 + 2 * v64);
            v38.i16[2] = *(_WORD *)(a13 + 2 * v66);
            unsigned int v67 = *v63++;
            int16x4_t v68 = v69;
            v68.i16[1] = *(_WORD *)(a13 + 2 * v67);
            *(int16x4_t *)v38.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v38.i8, *(int16x4_t *)v38.i8), v68);
            v47->i64[0] = v38.i64[0];
            int v47 = (int8x16_t *)((char *)v47 + 8);
            --v60;
          }
          while (v60);
        }
      }
      a11 = (int8x16_t *)((char *)a11 + a12);
      v30 += a10;
    }
    while (v30 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v18 = *(void *)(a3 + 24);
  uint64_t v84 = *(unsigned int *)(a3 + 44);
  uint64_t v85 = v18;
  uint64_t v86 = *(ChannelDescription **)(a4 + 8);
  unsigned int v83 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v86, (*(_DWORD *)(a3 + 52) + HIDWORD(v18) * *(_DWORD *)(a2 + 60)), v18, v83);
  if (*(unsigned char *)(*(void *)a5 + 24))
  {
    *(float *)&unsigned int v19 = **(double **)a5;
    unsigned int v20 = v19;
  }
  else
  {
    unsigned int v20 = 2143289344;
  }
  uint64_t v21 = *(void *)(a3 + 24);
  uint64_t v80 = *(unsigned int *)(a3 + 44);
  uint64_t v81 = v21;
  int32x4_t v82 = *(ChannelDescription **)(a6 + 8);
  unsigned int v79 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v82, (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60)), v21, v79);
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v76 = *(unsigned int *)(a3 + 44);
  uint64_t v77 = v22;
  unsigned int v78 = *(ChannelDescription **)(a7 + 8);
  unsigned int v75 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v78, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v75);
  unint64_t v25 = *(void *)(a2 + 56);
  uint64_t v26 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v26 < HIDWORD(v25))
  {
    int v28 = *(_DWORD *)(a3 + 28) * HIDWORD(v25);
    v24.i32[0] = v20;
    int32x4_t v73 = vdupq_n_s32(v20);
    int32x4_t v74 = v24;
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v86, (v28 + v26), v85, v83);
      if (HIDWORD(LocationForTile)) {
        uint64_t v30 = a1 + LocationForTile + 4 * v84;
      }
      else {
        uint64_t v30 = 0;
      }
      unint64_t v31 = ChannelDescription::GetLocationForTile(v82, (v28 + v26), v81, v79);
      if (HIDWORD(v31)) {
        uint64_t v32 = a1 + v31 + 4 * v80;
      }
      else {
        uint64_t v32 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v78, (v28 + v26), v77, v75);
      uint64_t v34 = a1 + result + 4 * v76;
      if (!HIDWORD(result)) {
        uint64_t v34 = 0;
      }
      if (v30) {
        BOOL v35 = v32 == 0;
      }
      else {
        BOOL v35 = 1;
      }
      if (!v35 && v34 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v39 = 0;
          uint64_t v40 = (unsigned int *)(v34 + 8);
          uint64_t v41 = (unsigned int *)(v32 + 8);
          uint64_t v42 = (unsigned int *)(v30 + 8);
          uint64_t v43 = a11;
          do
          {
            int v44 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 2));
            int v45 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 1));
            unint64_t v46 = ((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE;
            unint64_t v47 = (unint64_t)*(v42 - 1) >> 15;
            unint64_t v48 = *v42;
            unint64_t v49 = v42[1];
            v42 += 4;
            unint64_t v50 = *(v41 - 1);
            int v51 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v41 - 2));
            int v52 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v41 - 2) >> 15) & 0x1FFFE));
            int v53 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v41 - 1));
            LODWORD(v46) = v44 | (*(unsigned __int16 *)(a13 + v46) << 16);
            unint64_t v54 = *v41;
            unint64_t v55 = v41[1];
            v41 += 4;
            v56.i16[0] = *(_WORD *)(a13 + 2 * (unsigned __int16)v48);
            v56.i16[1] = *(_WORD *)(a13 + ((v48 >> 15) & 0x1FFFE));
            v56.i16[2] = *(_WORD *)(a13 + 2 * (unsigned __int16)v54);
            v56.i16[3] = *(_WORD *)(a13 + ((v54 >> 15) & 0x1FFFE));
            v56.i16[4] = *(_WORD *)(a13 + 2 * (unsigned __int16)v49);
            v56.i16[5] = *(_WORD *)(a13 + ((v49 >> 15) & 0x1FFFE));
            v57.i32[0] = v46;
            v57.i32[1] = v51 | (v52 << 16);
            v57.i32[2] = v45 | (*(unsigned __int16 *)(a13 + (v47 & 0x1FFFE)) << 16);
            LODWORD(v48) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 1));
            LODWORD(v47) = *(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 1) >> 15) & 0x1FFFE));
            LODWORD(v46) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v40 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v40 - 2) >> 15) & 0x1FFFE)) << 16);
            unint64_t v59 = *v40;
            unint64_t v58 = v40[1];
            v40 += 4;
            LODWORD(v47) = v48 | (v47 << 16);
            v56.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v55);
            v56.i16[7] = *(_WORD *)(a13 + ((v55 >> 15) & 0x1FFFE));
            v57.i32[3] = v53 | (*(unsigned __int16 *)(a13 + ((v50 >> 15) & 0x1FFFE)) << 16);
            unint64_t result = *(unsigned __int16 *)(a13 + ((v58 >> 15) & 0x1FFFE));
            int32x4_t v60 = vzip1q_s32(v57, v73);
            v60.i32[3] = v46;
            int32x4_t v61 = vzip2q_s32(v57, v73);
            int32x4_t v62 = vzip1q_s32(v56, v73);
            v61.i32[3] = v47;
            v62.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v59) | (*(unsigned __int16 *)(a13 + ((v59 >> 15) & 0x1FFFE)) << 16);
            int32x4_t v33 = vzip2q_s32(v56, v73);
            v33.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v58) | (result << 16);
            int8x16_t v38 = v43 + 4;
            unint64_t v37 = v39 + 4;
            unint64_t v63 = v39 + 8;
            v43[2] = v62;
            v43[3] = v33;
            *uint64_t v43 = v60;
            v43[1] = v61;
            v39 += 4;
            v43 += 4;
          }
          while (v63 <= a9);
        }
        else
        {
          unint64_t v37 = 0;
          int8x16_t v38 = a11;
        }
        uint64_t v64 = a9 - v37;
        if (a9 > v37)
        {
          unsigned int v65 = (unsigned int *)(v30 + 4 * v37);
          unsigned int v66 = (unsigned int *)(v32 + 4 * v37);
          unsigned int v67 = (unsigned int *)(v34 + 4 * v37);
          do
          {
            unsigned int v68 = *v65++;
            int v69 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v68) | (*(unsigned __int16 *)(a13
                                                                                                  + (((unint64_t)v68 >> 15) & 0x1FFFE)) << 16);
            unsigned int v70 = *v66++;
            v33.i32[0] = v69;
            v33.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v70) | (*(unsigned __int16 *)(a13 + (((unint64_t)v70 >> 15) & 0x1FFFE)) << 16);
            unsigned int v71 = *v67++;
            int32x4_t v72 = v74;
            v72.i32[1] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v71) | (*(unsigned __int16 *)(a13 + (((unint64_t)v71 >> 15) & 0x1FFFE)) << 16);
            int32x4_t v33 = vzip1q_s32(vuzp1q_s32(v33, v33), v72);
            *v38++ = v33;
            --v64;
          }
          while (v64);
        }
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v26 += a10;
    }
    while (v26 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int16x8_t *a11, uint64_t a12, uint64_t a13)
{
  if (*((unsigned char *)*a4 + 24))
  {
    _D0 = **a4;
    __asm { FCVT            H0, D0 }
    unsigned int v21 = _D0;
  }
  else
  {
    unsigned int v21 = 32256;
  }
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v68 = *(unsigned int *)(a3 + 44);
  uint64_t v69 = v22;
  unsigned int v70 = *(ChannelDescription **)(a5 + 8);
  unsigned int v67 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v70, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v67);
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v64 = *(unsigned int *)(a3 + 44);
  uint64_t v65 = v23;
  unsigned int v66 = *(ChannelDescription **)(a6 + 8);
  unsigned int v63 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v66, (*(_DWORD *)(a3 + 52) + HIDWORD(v23) * *(_DWORD *)(a2 + 60)), v23, v63);
  uint64_t v24 = *(void *)(a3 + 24);
  uint64_t v60 = *(unsigned int *)(a3 + 44);
  uint64_t v61 = v24;
  int32x4_t v62 = *(ChannelDescription **)(a7 + 8);
  unsigned int v59 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v62, (*(_DWORD *)(a3 + 52) + HIDWORD(v24) * *(_DWORD *)(a2 + 60)), v24, v59);
  unint64_t v28 = *(void *)(a2 + 56);
  uint64_t v29 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v29 < HIDWORD(v28))
  {
    int v31 = *(_DWORD *)(a3 + 28) * HIDWORD(v28);
    v26.i32[0] = v21;
    int16x8_t v32 = vdupq_n_s16(v21);
    int16x4_t v58 = v26;
    do
    {
      int16x8_t v72 = v32;
      long long v73 = v27;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v70, (v31 + v29), v69, v67);
      if (HIDWORD(LocationForTile)) {
        uint64_t v34 = a1 + LocationForTile + 2 * v68;
      }
      else {
        uint64_t v34 = 0;
      }
      unint64_t v35 = ChannelDescription::GetLocationForTile(v66, (v31 + v29), v65, v63);
      if (HIDWORD(v35)) {
        uint64_t v36 = a1 + v35 + 2 * v64;
      }
      else {
        uint64_t v36 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v62, (v31 + v29), v61, v59);
      int16x8_t v32 = v72;
      long long v27 = v73;
      uint64_t v38 = a1 + result + 2 * v60;
      if (!HIDWORD(result)) {
        uint64_t v38 = 0;
      }
      if (v34) {
        _ZF = v36 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v38 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v43 = 0;
          uint64_t v44 = 0;
          uint64_t v45 = v34 + 4;
          unint64_t v46 = a11;
          do
          {
            LOWORD(v27) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v36 + v43));
            WORD1(v27) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v36 + v43 + 2));
            WORD2(v27) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v36 + v43 + 4));
            WORD3(v27) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v36 + v43 + 6));
            unint64_t result = a13 + 2 * *(unsigned __int16 *)(v38 + v43);
            v47.i16[0] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v34 + v43));
            v47.i16[1] = *(_WORD *)result;
            v47.i16[2] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v45 + v43 - 2));
            v47.i16[3] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v38 + v43 + 2));
            v47.i16[4] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v45 + v43));
            v47.i16[5] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v38 + v43 + 4));
            v47.i16[6] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v45 + v43 + 2));
            v47.i16[7] = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v38 + v43 + 6));
            int16x8_t v37 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v27 - 1), (int8x16_t)xmmword_228F41C10);
            uint64_t v42 = (int16x4_t *)&v46[2];
            unint64_t v41 = v44 + 4;
            unint64_t v48 = v44 + 8;
            *unint64_t v46 = vzip1q_s16(v37, v47);
            v46[1] = vzip2q_s16(v37, v47);
            v43 += 8;
            v44 += 4;
            v46 += 2;
          }
          while (v48 <= a9);
        }
        else
        {
          unint64_t v41 = 0;
          uint64_t v42 = (int16x4_t *)a11;
        }
        uint64_t v49 = a9 - v41;
        if (a9 > v41)
        {
          unint64_t v50 = (unsigned __int16 *)(v34 + 2 * v41);
          int v51 = (unsigned __int16 *)(v36 + 2 * v41);
          int v52 = (unsigned __int16 *)(v38 + 2 * v41);
          do
          {
            unsigned int v54 = *v50++;
            uint64_t v53 = v54;
            unsigned int v55 = *v51++;
            int16x4_t v56 = v58;
            v56.i16[2] = *(_WORD *)(a13 + 2 * v55);
            unsigned int v57 = *v52++;
            v37.i16[0] = *(_WORD *)(a13 + 2 * v53);
            v37.i16[1] = *(_WORD *)(a13 + 2 * v57);
            *v42++ = vzip1_s16(vuzp1_s16(v56, v56), *(int16x4_t *)v37.i8);
            --v49;
          }
          while (v49);
        }
      }
      a11 = (int16x8_t *)((char *)a11 + a12);
      v29 += a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, int32x4_t *a11, uint64_t a12, uint64_t a13)
{
  if (*(unsigned char *)(*(void *)a4 + 24))
  {
    *(float *)&unsigned int v17 = **(double **)a4;
    unsigned int v18 = v17;
  }
  else
  {
    unsigned int v18 = 2143289344;
  }
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v87 = *(unsigned int *)(a3 + 44);
  uint64_t v88 = v19;
  uint64_t v89 = *(ChannelDescription **)(a5 + 8);
  unsigned int v86 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v89, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v86);
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v83 = *(unsigned int *)(a3 + 44);
  uint64_t v84 = v20;
  uint64_t v85 = *(ChannelDescription **)(a6 + 8);
  unsigned int v82 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v85, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v82);
  uint64_t v21 = *(void *)(a3 + 24);
  uint64_t v79 = *(unsigned int *)(a3 + 44);
  uint64_t v80 = v21;
  uint64_t v81 = *(ChannelDescription **)(a7 + 8);
  unsigned int v78 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v81, (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60)), v21, v78);
  unint64_t v24 = *(void *)(a2 + 56);
  uint64_t v25 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v25 < HIDWORD(v24))
  {
    int v27 = *(_DWORD *)(a3 + 28) * HIDWORD(v24);
    v23.i32[0] = v18;
    int32x4_t v28 = vdupq_n_s32(v18);
    int32x4_t v76 = vuzp1q_s32(v28, v28);
    int32x4_t v77 = v23;
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v89, (v27 + v25), v88, v86);
      if (HIDWORD(LocationForTile)) {
        uint64_t v30 = a1 + LocationForTile + 4 * v87;
      }
      else {
        uint64_t v30 = 0;
      }
      unint64_t v31 = ChannelDescription::GetLocationForTile(v85, (v27 + v25), v84, v82);
      if (HIDWORD(v31)) {
        uint64_t v32 = a1 + v31 + 4 * v83;
      }
      else {
        uint64_t v32 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v81, (v27 + v25), v80, v78);
      uint64_t v35 = a1 + result + 4 * v79;
      if (!HIDWORD(result)) {
        uint64_t v35 = 0;
      }
      if (v30) {
        BOOL v36 = v32 == 0;
      }
      else {
        BOOL v36 = 1;
      }
      if (!v36 && v35 != 0)
      {
        if (a9 >= 4)
        {
          uint64_t v40 = 0;
          unint64_t v41 = (unsigned int *)(v35 + 8);
          uint64_t v42 = (unsigned int *)(v32 + 8);
          uint64_t v43 = (unsigned int *)(v30 + 8);
          uint64_t v44 = a11;
          do
          {
            int v45 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2));
            unint64_t v46 = ((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE;
            int v47 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1));
            unint64_t v48 = ((unint64_t)*(v43 - 1) >> 15) & 0x1FFFE;
            unint64_t v49 = *v43;
            unint64_t v50 = v43[1];
            v43 += 4;
            int v51 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 1));
            int v52 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v42 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE)) << 16);
            int v53 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v42 - 1) >> 15) & 0x1FFFE));
            unint64_t v54 = *v42;
            unint64_t v55 = v42[1];
            v42 += 4;
            LODWORD(v46) = v45 | (*(unsigned __int16 *)(a13 + v46) << 16);
            LODWORD(v48) = v47 | (*(unsigned __int16 *)(a13 + v48) << 16);
            v56.i32[0] = v52;
            v56.i32[1] = v51 | (v53 << 16);
            v56.i16[4] = *(_WORD *)(a13 + 2 * (unsigned __int16)v54);
            v56.i16[5] = *(_WORD *)(a13 + ((v54 >> 15) & 0x1FFFE));
            int v57 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v50) | (*(unsigned __int16 *)(a13
                                                                                                  + ((v50 >> 15) & 0x1FFFE)) << 16);
            int v58 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v41 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v41 - 2) >> 15) & 0x1FFFE)) << 16);
            v33.i32[0] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v49) | (*(unsigned __int16 *)(a13 + ((v49 >> 15) & 0x1FFFE)) << 16);
            v34.i32[0] = v46;
            LODWORD(v46) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v41 - 1)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v41 - 1) >> 15) & 0x1FFFE)) << 16);
            unint64_t v59 = *v41;
            unint64_t v60 = v41[1];
            v41 += 4;
            v56.i16[6] = *(_WORD *)(a13 + 2 * (unsigned __int16)v55);
            v56.i16[7] = *(_WORD *)(a13 + ((v55 >> 15) & 0x1FFFE));
            v33.i32[2] = v57;
            v34.i32[2] = v48;
            int32x4_t v61 = vzip2q_s32(v76, v56);
            LODWORD(v48) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v59) | (*(unsigned __int16 *)(a13 + ((v59 >> 15) & 0x1FFFE)) << 16);
            int32x4_t v62 = vzip1q_s32(v76, v56);
            unint64_t result = *(unsigned __int16 *)(a13 + ((v60 >> 15) & 0x1FFFE));
            int32x4_t v63 = vzip1q_s32(v62, v34);
            v63.i32[3] = v58;
            int32x4_t v64 = vzip2q_s32(v62, v34);
            int32x4_t v34 = vzip1q_s32(v61, v33);
            v64.i32[3] = v46;
            v34.i32[3] = v48;
            int32x4_t v33 = vzip2q_s32(v61, v33);
            v33.i32[3] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v60) | (result << 16);
            uint64_t v39 = v44 + 4;
            unint64_t v38 = v40 + 4;
            unint64_t v65 = v40 + 8;
            v44[2] = v34;
            v44[3] = v33;
            *uint64_t v44 = v63;
            v44[1] = v64;
            v40 += 4;
            v44 += 4;
          }
          while (v65 <= a9);
        }
        else
        {
          unint64_t v38 = 0;
          uint64_t v39 = a11;
        }
        uint64_t v66 = a9 - v38;
        if (a9 > v38)
        {
          unsigned int v67 = (unsigned int *)(v30 + 4 * v38);
          uint64_t v68 = (unsigned int *)(v32 + 4 * v38);
          uint64_t v69 = (unsigned int *)(v35 + 4 * v38);
          do
          {
            unsigned int v70 = *v67++;
            int v71 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v70);
            int v72 = *(unsigned __int16 *)(a13 + (((unint64_t)v70 >> 15) & 0x1FFFE));
            unsigned int v73 = *v68++;
            int32x4_t v74 = v77;
            v74.i32[2] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v73) | (*(unsigned __int16 *)(a13 + (((unint64_t)v73 >> 15) & 0x1FFFE)) << 16);
            unsigned int v75 = *v69++;
            v33.i32[0] = v71 | (v72 << 16);
            v33.i32[1] = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v75) | (*(unsigned __int16 *)(a13 + (((unint64_t)v75 >> 15) & 0x1FFFE)) << 16);
            *v39++ = vzip1q_s32(vuzp1q_s32(v74, v74), v33);
            --v66;
          }
          while (v66);
        }
      }
      a11 = (int32x4_t *)((char *)a11 + a12);
      v25 += a10;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(a2 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned short,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, _OWORD *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a3 + 24);
  uint64_t v70 = *(unsigned int *)(a3 + 44);
  uint64_t v71 = v19;
  int v72 = *(ChannelDescription **)(a4 + 8);
  unsigned int v69 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a3 + 52) + HIDWORD(v19) * *(_DWORD *)(a2 + 60)), v19, v69);
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v66 = *(unsigned int *)(a3 + 44);
  uint64_t v67 = v20;
  uint64_t v68 = *(ChannelDescription **)(a5 + 8);
  unsigned int v65 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v68, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v65);
  uint64_t v21 = *(void *)(a3 + 24);
  uint64_t v62 = *(unsigned int *)(a3 + 44);
  uint64_t v63 = v21;
  int32x4_t v64 = *(ChannelDescription **)(a6 + 8);
  unsigned int v61 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v64, (*(_DWORD *)(a3 + 52) + HIDWORD(v21) * *(_DWORD *)(a2 + 60)), v21, v61);
  uint64_t v22 = *(void *)(a3 + 24);
  uint64_t v58 = *(unsigned int *)(a3 + 44);
  uint64_t v59 = v22;
  unint64_t v60 = *(ChannelDescription **)(a7 + 8);
  unsigned int v57 = *(_DWORD *)(a3 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v60, (*(_DWORD *)(a3 + 52) + HIDWORD(v22) * *(_DWORD *)(a2 + 60)), v22, v57);
  uint64_t v73 = a2;
  unint64_t v24 = *(void *)(a2 + 56);
  uint64_t v25 = *(unsigned int *)(a3 + 52);
  if ((unint64_t)*(unsigned int *)(a3 + 56) + v25 < HIDWORD(v24))
  {
    int v56 = *(_DWORD *)(a3 + 28) * HIDWORD(v24);
    do
    {
      unint64_t v27 = (v56 + v25);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v72, v27, v71, v69);
      if (HIDWORD(LocationForTile)) {
        uint64_t v29 = a1 + LocationForTile + 2 * v70;
      }
      else {
        uint64_t v29 = 0;
      }
      unint64_t v30 = ChannelDescription::GetLocationForTile(v68, v27, v67, v65);
      if (HIDWORD(v30)) {
        uint64_t v31 = a1 + v30 + 2 * v66;
      }
      else {
        uint64_t v31 = 0;
      }
      unint64_t v32 = ChannelDescription::GetLocationForTile(v64, v27, v63, v61);
      if (HIDWORD(v32)) {
        uint64_t v33 = a1 + v32 + 2 * v62;
      }
      else {
        uint64_t v33 = 0;
      }
      unint64_t result = ChannelDescription::GetLocationForTile(v60, v27, v59, v57);
      uint64_t v34 = a1 + result + 2 * v58;
      if (!HIDWORD(result)) {
        uint64_t v34 = 0;
      }
      if (v29 && v31 && v33 && v34)
      {
        if (a9 >= 4)
        {
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          uint64_t v39 = a11;
          do
          {
            unint64_t result = a13 + 2 * *(unsigned __int16 *)(v31 + v37 + 2);
            LOWORD(v40) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v29 + v37));
            WORD1(v40) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v31 + v37));
            WORD2(v40) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v33 + v37));
            WORD3(v40) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v34 + v37));
            WORD4(v40) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v29 + v37 + 2));
            WORD5(v40) = *(_WORD *)result;
            WORD6(v40) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v33 + v37 + 2));
            HIWORD(v40) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v34 + v37 + 2));
            LOWORD(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v29 + v37 + 4));
            WORD1(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v31 + v37 + 4));
            WORD2(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v33 + v37 + 4));
            WORD3(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v34 + v37 + 4));
            WORD4(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v29 + v37 + 6));
            WORD5(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v31 + v37 + 6));
            WORD6(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v33 + v37 + 6));
            HIWORD(v41) = *(_WORD *)(a13 + 2 * *(unsigned __int16 *)(v34 + v37 + 6));
            BOOL v36 = v39 + 2;
            unint64_t v35 = v38 + 4;
            unint64_t v42 = v38 + 8;
            *uint64_t v39 = v40;
            v39[1] = v41;
            v37 += 8;
            v38 += 4;
            v39 += 2;
          }
          while (v42 <= a9);
        }
        else
        {
          unint64_t v35 = 0;
          BOOL v36 = a11;
        }
        uint64_t v43 = a9 - v35;
        if (a9 > v35)
        {
          uint64_t v44 = (unsigned __int16 *)(v29 + 2 * v35);
          int v45 = (unsigned __int16 *)(v31 + 2 * v35);
          unint64_t v46 = (unsigned __int16 *)(v33 + 2 * v35);
          int v47 = (unsigned __int16 *)(v34 + 2 * v35);
          do
          {
            unsigned int v49 = *v44++;
            uint64_t v48 = v49;
            unsigned int v50 = *v45++;
            int v51 = (_WORD *)(a13 + 2 * v50);
            unsigned int v52 = *v46++;
            int v53 = (_WORD *)(a13 + 2 * v52);
            unsigned int v54 = *v47++;
            LOWORD(v55) = *(_WORD *)(a13 + 2 * v48);
            WORD1(v55) = *v51;
            WORD2(v55) = *v53;
            HIWORD(v55) = *(_WORD *)(a13 + 2 * v54);
            *v36++ = v55;
            --v43;
          }
          while (v43);
        }
      }
      a11 = (_OWORD *)((char *)a11 + a12);
      v25 += a10;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a3 + 56) < *(unsigned int *)(v73 + 60));
  }
  return result;
}

unint64_t Read4_NoCompressionLUT<unsigned int,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int a10, _OWORD *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v16 = a3;
  uint64_t v17 = a2;
  uint64_t v19 = *(ChannelDescription **)(a4 + 8);
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v21 = v20;
  uint64_t v108 = *(unsigned int *)(a3 + 44);
  unsigned int v107 = *(_DWORD *)(a3 + 60);
  ChannelDescription::GetLocationForTile(v19, (*(_DWORD *)(a3 + 52) + HIDWORD(v20) * *(_DWORD *)(a2 + 60)), v20, v107);
  uint64_t v22 = *(ChannelDescription **)(a5 + 8);
  uint64_t v23 = *(void *)(v16 + 24);
  uint64_t v105 = *(unsigned int *)(v16 + 44);
  unint64_t v106 = v23;
  unsigned int v104 = *(_DWORD *)(v16 + 60);
  ChannelDescription::GetLocationForTile(v22, (*(_DWORD *)(v16 + 52) + HIDWORD(v23) * *(_DWORD *)(v17 + 60)), v23, v104);
  uint64_t v24 = *(void *)(v16 + 24);
  uint64_t v101 = *(unsigned int *)(v16 + 44);
  uint64_t v102 = v24;
  unint64_t v103 = *(ChannelDescription **)(a6 + 8);
  unsigned int v100 = *(_DWORD *)(v16 + 60);
  ChannelDescription::GetLocationForTile(v103, (*(_DWORD *)(v16 + 52) + HIDWORD(v24) * *(_DWORD *)(v17 + 60)), v24, v100);
  uint64_t v25 = *(ChannelDescription **)(a7 + 8);
  uint64_t v26 = *(void *)(v16 + 24);
  uint64_t v98 = *(unsigned int *)(v16 + 44);
  unint64_t v99 = v26;
  unsigned int v97 = *(_DWORD *)(v16 + 60);
  unint64_t result = ChannelDescription::GetLocationForTile(v25, (*(_DWORD *)(v16 + 52) + HIDWORD(v26) * *(_DWORD *)(v17 + 60)), v26, v97);
  unint64_t v28 = *(void *)(v17 + 56);
  uint64_t v29 = *(unsigned int *)(v16 + 52);
  if ((unint64_t)*(unsigned int *)(v16 + 56) + v29 < HIDWORD(v28))
  {
    int v96 = *(_DWORD *)(v16 + 28) * HIDWORD(v28);
    uint64_t v93 = v17;
    uint64_t v94 = v16;
    uint64_t v91 = v19;
    uint64_t v92 = a1;
    uint64_t v89 = v22;
    uint64_t v90 = v21;
    uint64_t v88 = v25;
    do
    {
      uint64_t v110 = v29;
      unint64_t v30 = (v96 + v29);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v19, v30, v21, v107);
      if (HIDWORD(LocationForTile)) {
        uint64_t v32 = a1 + LocationForTile + 4 * v108;
      }
      else {
        uint64_t v32 = 0;
      }
      unint64_t v33 = ChannelDescription::GetLocationForTile(v22, v30, v106, v104);
      uint64_t v34 = a1 + v33 + 4 * v105;
      if (!HIDWORD(v33)) {
        uint64_t v34 = 0;
      }
      uint64_t v112 = v34;
      unint64_t v35 = ChannelDescription::GetLocationForTile(v103, v30, v102, v100);
      uint64_t v36 = a1 + v35 + 4 * v101;
      if (!HIDWORD(v35)) {
        uint64_t v36 = 0;
      }
      uint64_t v111 = v36;
      unint64_t result = ChannelDescription::GetLocationForTile(v25, v30, v99, v97);
      if (HIDWORD(result)) {
        uint64_t v37 = a1 + result + 4 * v98;
      }
      else {
        uint64_t v37 = 0;
      }
      uint64_t v109 = v32;
      if (v32 && v112 && v111 && v37)
      {
        unint64_t v38 = a9;
        uint64_t v95 = v37;
        if (a9 >= 4)
        {
          uint64_t v41 = 0;
          unint64_t v42 = (unsigned int *)(v37 + 8);
          uint64_t v43 = (unsigned int *)(v111 + 8);
          uint64_t v44 = a11;
          int v45 = (unsigned int *)(v112 + 8);
          unint64_t v46 = (unsigned int *)(v32 + 8);
          do
          {
            unint64_t v47 = *(v45 - 1);
            int v48 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v45 - 2));
            unint64_t v49 = (unint64_t)*(v45 - 2) >> 15;
            int v50 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v45 - 1));
            unint64_t v52 = *v45;
            unint64_t v51 = v45[1];
            v45 += 4;
            int v53 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 2));
            int v54 = *(unsigned __int16 *)(a13 + (((unint64_t)*(v43 - 2) >> 15) & 0x1FFFE));
            int v55 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v43 - 1));
            unint64_t v56 = ((unint64_t)*(v43 - 1) >> 15) & 0x1FFFE;
            unint64_t v57 = *v43;
            unint64_t v58 = v43[1];
            v43 += 4;
            int v59 = v48 | (*(unsigned __int16 *)(a13 + (v49 & 0x1FFFE)) << 16);
            LODWORD(v47) = v50 | (*(unsigned __int16 *)(a13 + ((v47 >> 15) & 0x1FFFE)) << 16);
            uint64_t v60 = (unsigned __int16)*(v42 - 2);
            int v61 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v52) | (*(unsigned __int16 *)(a13
                                                                                                  + ((v52 >> 15) & 0x1FFFE)) << 16);
            unint64_t v62 = ((unint64_t)*(v42 - 2) >> 15) & 0x1FFFE;
            uint64_t v63 = (unsigned __int16)*(v42 - 1);
            unint64_t v64 = ((unint64_t)*(v42 - 1) >> 15) & 0x1FFFE;
            int v65 = v53 | (v54 << 16);
            unint64_t v66 = *v42;
            unint64_t v67 = v42[1];
            v42 += 4;
            LODWORD(v68) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v46 - 2)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v46 - 2) >> 15) & 0x1FFFE)) << 16);
            LODWORD(v69) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*(v46 - 1)) | (*(unsigned __int16 *)(a13 + (((unint64_t)*(v46 - 1) >> 15) & 0x1FFFE)) << 16);
            DWORD1(v68) = v59;
            DWORD2(v68) = v65;
            unint64_t result = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v66);
            DWORD1(v69) = v47;
            DWORD2(v69) = v55 | (*(unsigned __int16 *)(a13 + v56) << 16);
            LODWORD(v70) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)*v46) | (*(unsigned __int16 *)(a13 + (((unint64_t)*v46 >> 15) & 0x1FFFE)) << 16);
            DWORD1(v70) = v61;
            DWORD2(v70) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v57) | (*(unsigned __int16 *)(a13 + ((v57 >> 15) & 0x1FFFE)) << 16);
            LODWORD(v71) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v46[1]) | (*(unsigned __int16 *)(a13 + (((unint64_t)v46[1] >> 15) & 0x1FFFE)) << 16);
            DWORD1(v71) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v51) | (*(unsigned __int16 *)(a13 + ((v51 >> 15) & 0x1FFFE)) << 16);
            DWORD2(v71) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v58) | (*(unsigned __int16 *)(a13 + ((v58 >> 15) & 0x1FFFE)) << 16);
            HIDWORD(v68) = *(unsigned __int16 *)(a13 + 2 * v60) | (*(unsigned __int16 *)(a13 + v62) << 16);
            HIDWORD(v69) = *(unsigned __int16 *)(a13 + 2 * v63) | (*(unsigned __int16 *)(a13 + v64) << 16);
            HIDWORD(v70) = result | (*(unsigned __int16 *)(a13 + ((v66 >> 15) & 0x1FFFE)) << 16);
            HIDWORD(v71) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v67) | (*(unsigned __int16 *)(a13 + ((v67 >> 15) & 0x1FFFE)) << 16);
            long long v40 = v44 + 4;
            unint64_t v39 = v41 + 4;
            unint64_t v72 = v41 + 8;
            v44[2] = v70;
            v44[3] = v71;
            *uint64_t v44 = v68;
            v44[1] = v69;
            v46 += 4;
            v41 += 4;
            v44 += 4;
            BOOL v73 = v72 > a9;
            unint64_t v38 = a9;
          }
          while (!v73);
        }
        else
        {
          unint64_t v39 = 0;
          long long v40 = a11;
        }
        uint64_t v74 = v38 - v39;
        uint64_t v17 = v93;
        uint64_t v16 = v94;
        uint64_t v19 = v91;
        a1 = v92;
        uint64_t v22 = v89;
        uint64_t v21 = v90;
        uint64_t v25 = v88;
        if (v38 > v39)
        {
          unsigned int v75 = (unsigned int *)(v109 + 4 * v39);
          int32x4_t v76 = (unsigned int *)(v112 + 4 * v39);
          int32x4_t v77 = (unsigned int *)(v111 + 4 * v39);
          unsigned int v78 = (unsigned int *)(v95 + 4 * v39);
          do
          {
            unsigned int v79 = *v75++;
            uint64_t v80 = (unsigned __int16)v79;
            unint64_t v81 = (unint64_t)v79 >> 15;
            unsigned int v82 = *v76++;
            LODWORD(v81) = *(unsigned __int16 *)(a13 + 2 * v80) | (*(unsigned __int16 *)(a13 + (v81 & 0x1FFFE)) << 16);
            LODWORD(v80) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v82) | (*(unsigned __int16 *)(a13 + (((unint64_t)v82 >> 15) & 0x1FFFE)) << 16);
            unsigned int v83 = *v77++;
            int v84 = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v83);
            unint64_t v85 = ((unint64_t)v83 >> 15) & 0x1FFFE;
            unsigned int v86 = *v78++;
            unint64_t result = *(unsigned __int16 *)(a13 + (((unint64_t)v86 >> 15) & 0x1FFFE));
            *(void *)&long long v87 = __PAIR64__(v80, v81);
            DWORD2(v87) = v84 | (*(unsigned __int16 *)(a13 + v85) << 16);
            HIDWORD(v87) = *(unsigned __int16 *)(a13 + 2 * (unsigned __int16)v86) | (result << 16);
            *v40++ = v87;
            --v74;
          }
          while (v74);
        }
      }
      a11 = (_OWORD *)((char *)a11 + a12);
      uint64_t v29 = v110 + a10;
    }
    while (v29 + (unint64_t)*(unsigned int *)(v16 + 56) < *(unsigned int *)(v17 + 60));
  }
  return result;
}

unint64_t TileDecoder_PIZ::ExtractPlane(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int32x2_t *a5, _OWORD *a6, uint64_t a7, uint64_t a8)
{
  v81[0] = 0;
  uint64_t v13 = *(void *)(a4 + 8);
  unsigned int v14 = *(_DWORD *)(v13 + 80);
  uint64_t v15 = *(unsigned int *)(v13 + 104);
  v81[1] = 0;
  uint64_t v82 = 0;
  int v83 = 0;
  uint64_t v79 = v15;
  TileDecoder::GetChannelTileInfo(a1, a5, v14, v15, (unsigned int *)v81);
  unint64_t result = *(void *)(a4 + 8);
  int v17 = *(_DWORD *)(result + 72);
  if (v17 == 1) {
    uint64_t v18 = 2;
  }
  else {
    uint64_t v18 = 4;
  }
  if (!HIDWORD(v82) || !v83) {
    return result;
  }
  unsigned int LocationForTile = ChannelDescription::GetLocationForTile((ChannelDescription *)result, (HIDWORD(*(void *)&a5[3]) * *(_DWORD *)(a1 + 60)), *(void *)&a5[3], a5[7].u32[1]);
  unint64_t v20 = *(unsigned int *)(a1 + 72);
  if (!v20) {
    goto LABEL_12;
  }
  unsigned int v21 = LocationForTile;
  uint64_t v22 = 0;
  unint64_t v23 = 0;
  while (1)
  {
    uint64_t v24 = *(void *)(a1 + 64);
    if (!*(unsigned char *)(*(void *)(v24 + v22) + 24)) {
      break;
    }
LABEL_11:
    ++v23;
    v22 += 16;
    if (v23 >= v20) {
      goto LABEL_12;
    }
  }
  uint64_t v25 = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(v24 + v22 + 8), (HIDWORD(*(void *)&a5[3]) * *(_DWORD *)(a1 + 60)), *(void *)&a5[3], a5[7].u32[1]);
  if (v25 != v21)
  {
    unint64_t v20 = *(unsigned int *)(a1 + 72);
    goto LABEL_11;
  }
  if (!*(unsigned char *)(a2[4] + v23))
  {
    uint64_t v74 = *(void *)(a4 + 8);
    v30.i64[0] = *(void *)(v74 + 48);
    *(int32x2_t *)v31.i8 = vmls_s32(*(int32x2_t *)(*(void *)(*(void *)(v74 + 40) + 8 * a5[7].u32[1]) + 16), *(int32x2_t *)v30.i8, a5[3]);
    *(uint32x2_t *)v29.i8 = vmin_u32(*(uint32x2_t *)v31.i8, *(uint32x2_t *)v30.i8);
    if (v17 == 1) {
      char v75 = 1;
    }
    else {
      char v75 = 2;
    }
    TileDecoder_PIZ::WaveDecode(v29, v30, v31, v32, v33, v25, a2[1] + v21, (unint64_t)v29.u32[0] << v75, (_WORD *)a2[2], v26, v27, v28, *((_DWORD *)a2 + 12), v18);
    *(unsigned char *)(a2[4] + v23) = 1;
  }
LABEL_12:
  unint64_t v34 = HIDWORD(v82);
  uint64_t v36 = *a2;
  uint64_t v35 = a2[1];
  int32x2_t v37 = a5[3];
  uint64_t v38 = v37.u32[0];
  uint64_t v76 = a5[5].u32[1];
  unsigned int v39 = a5[7].u32[1];
  int32x4_t v77 = *(ChannelDescription **)(a4 + 8);
  uint64_t v78 = v35;
  unint64_t result = ChannelDescription::GetLocationForTile(v77, (a5[6].i32[1] + v37.i32[1] * *(_DWORD *)(a1 + 60)), v37.u32[0], v39);
  unint64_t v40 = *(void *)(a1 + 56);
  uint64_t v41 = a5[6].u32[1];
  if ((unint64_t)a5[7].u32[0] + v41 < HIDWORD(v40))
  {
    int v42 = a5[3].i32[1] * HIDWORD(v40);
    do
    {
      unint64_t result = ChannelDescription::GetLocationForTile(v77, (v42 + v41), v38, v39);
      uint64_t v43 = v78 + result;
      if (HIDWORD(result)) {
        BOOL v44 = v43 == 0;
      }
      else {
        BOOL v44 = 1;
      }
      if (!v44)
      {
        if (v34 >= 0x10)
        {
          uint64_t v47 = 0;
          int v48 = (unsigned __int16 *)(v43 + 2 * v76 + 30);
          unint64_t v49 = a6;
          do
          {
            uint64_t v50 = *(v48 - 15);
            unint64_t v51 = (_WORD *)(v36 + 2 * *(v48 - 14));
            unint64_t v52 = (_WORD *)(v36 + 2 * *(v48 - 13));
            int v53 = (_WORD *)(v36 + 2 * *(v48 - 12));
            int v54 = (_WORD *)(v36 + 2 * *(v48 - 11));
            int v55 = (_WORD *)(v36 + 2 * *(v48 - 10));
            unint64_t result = v36 + 2 * *(v48 - 9);
            unint64_t v56 = (_WORD *)(v36 + 2 * *(v48 - 8));
            uint64_t v57 = *(v48 - 7);
            unint64_t v58 = (_WORD *)(v36 + 2 * *(v48 - 6));
            int v59 = (_WORD *)(v36 + 2 * *(v48 - 5));
            uint64_t v60 = (_WORD *)(v36 + 2 * *(v48 - 4));
            int v61 = (_WORD *)(v36 + 2 * *(v48 - 3));
            unint64_t v62 = (_WORD *)(v36 + 2 * *(v48 - 2));
            uint64_t v63 = (_WORD *)(v36 + 2 * *(v48 - 1));
            unsigned int v64 = *v48;
            v48 += 16;
            LOWORD(v65) = *(_WORD *)(v36 + 2 * v50);
            WORD1(v65) = *v51;
            WORD2(v65) = *v52;
            WORD3(v65) = *v53;
            WORD4(v65) = *v54;
            WORD5(v65) = *v55;
            WORD6(v65) = *(_WORD *)result;
            HIWORD(v65) = *v56;
            LOWORD(v66) = *(_WORD *)(v36 + 2 * v57);
            WORD1(v66) = *v58;
            WORD2(v66) = *v59;
            WORD3(v66) = *v60;
            WORD4(v66) = *v61;
            WORD5(v66) = *v62;
            WORD6(v66) = *v63;
            HIWORD(v66) = *(_WORD *)(v36 + 2 * v64);
            unint64_t v46 = v49 + 2;
            unint64_t v45 = v47 + 16;
            unint64_t v67 = v47 + 32;
            *unint64_t v49 = v65;
            v49[1] = v66;
            v47 += 16;
            v49 += 2;
          }
          while (v67 <= v34);
        }
        else
        {
          unint64_t v45 = 0;
          unint64_t v46 = a6;
        }
        unint64_t v68 = v45 | 4;
        if ((v45 | 4) <= v34)
        {
          uint64_t v69 = v43 + 2 * v76;
          do
          {
            LOWORD(v70) = *(_WORD *)(v36 + 2 * *(unsigned __int16 *)(v69 + 2 * v45));
            WORD1(v70) = *(_WORD *)(v36 + 2 * *(unsigned __int16 *)(v69 + ((2 * v45) | 2)));
            WORD2(v70) = *(_WORD *)(v36 + 2 * *(unsigned __int16 *)(v69 + ((2 * v45) | 4)));
            HIWORD(v70) = *(_WORD *)(v36 + 2 * *(unsigned __int16 *)(v69 + ((2 * v45) | 6)));
            *v46++ = v70;
            unint64_t v45 = v68;
            v68 += 4;
          }
          while (v68 <= v34);
          unint64_t v45 = v68 - 4;
        }
        unint64_t v71 = v34 - v45;
        if (v34 > v45)
        {
          unint64_t v72 = (unsigned __int16 *)(v43 + 2 * v76 + 2 * v45);
          do
          {
            unsigned int v73 = *v72++;
            *(_WORD *)unint64_t v46 = *(_WORD *)(v36 + 2 * v73);
            unint64_t v46 = (void *)((char *)v46 + 2);
            --v71;
          }
          while (v71);
        }
      }
      a6 = (_OWORD *)((char *)a6 + a8);
      v41 += v79;
    }
    while (v41 + (unint64_t)a5[7].u32[0] < *(unsigned int *)(a1 + 60));
  }
  return result;
}

void TileDecoder_PIZ::~TileDecoder_PIZ(void **this)
{
  TileDecoder::~TileDecoder(this);

  JUMPOUT(0x22A6AD870);
}

uint64_t TileDecoder_PIZ::GetMinimumTileBytes(TileDecoder_PIZ *this)
{
  return 1024;
}

uint64_t TileDecoder_PIZ::GetPoolSize(TileDecoder_PIZ *this, uint64_t a2)
{
  TileDecoder_PIZ::InitPoolInfo((uint64_t)this, v3, a2);
  return v3[5];
}

uint64_t TileDecoder_PIZ::GetCompressionMethod(TileDecoder_PIZ *this)
{
  return 4;
}

uint64_t AddHuffmanTableEntry(uint64_t a1, unint64_t a2, unint64_t a3, int a4, _OWORD *a5)
{
  while (1)
  {
    unint64_t v10 = *(unsigned int *)(a1 + 36);
    char v11 = v10 - a3;
    if (v10 >= a3)
    {
      uint64_t v23 = a2 << v11;
      int v24 = 1 << v11;
      memset((void *)(a1 + v23 + 40), v11 & 0xF | 0x60, 1 << v11);
      *(_DWORD *)int __pattern4 = a4 | (a4 << 16);
      memset_pattern4((void *)(*(void *)(a1 + 8) + 4 * v23), __pattern4, 4 * v24);
      return 0;
    }
    unint64_t v12 = a3 - v10;
    unint64_t v13 = a2 >> (a3 - v10);
    unsigned int v14 = (unsigned char *)(a1 + v13 + 40);
    if (*v14 != 15)
    {
      uint64_t v22 = *(void **)a1;
      goto LABEL_13;
    }
    unint64_t v15 = *(void *)(a1 + 24);
    if (v15 < *(void *)(a1 + 16) + 1) {
      break;
    }
LABEL_8:
    *unsigned int v14 = 32;
    unint64_t v18 = v13;
    *(_DWORD *)(*(void *)(a1 + 8) + 4 * v13) = *(void *)(a1 + 16);
    *(_OWORD *)&__pattern4[12] = *(_OWORD *)((char *)a5 + 12);
    *(_OWORD *)int __pattern4 = *a5;
    int v19 = *(_DWORD *)&__pattern4[20] - v10;
    if (*(_DWORD *)&__pattern4[20] <= v10) {
      int v19 = 1;
    }
    *(_DWORD *)&__pattern4[16] -= v10;
    *(_DWORD *)&__pattern4[20] = v19;
    uint64_t HuffmanTable = AllocateHuffmanTable(__pattern4, 0);
    uint64_t v21 = *(void *)(a1 + 16);
    *(void *)(*(void *)a1 + 8 * v21) = HuffmanTable;
    uint64_t v22 = *(void **)a1;
    if (!*(void *)(*(void *)a1 + 8 * v21)) {
      return -5;
    }
    *(void *)(a1 + 16) = v21 + 1;
    unint64_t v12 = a3 - v10;
    unint64_t v13 = v18;
LABEL_13:
    a2 &= (unint64_t)~(-1 << a3) >> v10;
    a1 = v22[*(unsigned int *)(*(void *)(a1 + 8) + 4 * v13)];
    a3 = v12;
  }
  unint64_t v16 = 2 * v15;
  if (v16 <= 4) {
    unint64_t v16 = 4;
  }
  unint64_t v26 = v16;
  int v17 = reallocf(*(void **)a1, 8 * v16);
  *(void *)a1 = v17;
  if (v17)
  {
    unint64_t v13 = a2 >> (a3 - v10);
    *(void *)(a1 + 24) = v26;
    goto LABEL_8;
  }
  return -5;
}

BOOL ReadChannel::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) && *(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (!*(unsigned char *)(a1 + 24)) {
      return *(_DWORD *)a1 == *(_DWORD *)a2;
    }
    if (*(double *)a1 == *(double *)a2) {
      return 1;
    }
  }
  return 0;
}

__n128 AXRLUTStream<unsigned int,(StreamType)1>::load16@<Q0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = (unsigned int *)(*a1 + 4 * a2);
  uint64_t v4 = a1[5];
  result.n128_u32[0] = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)*v3) | (*(unsigned __int16 *)(v4 + (((unint64_t)*v3 >> 15) & 0x1FFFE)) << 16);
  result.n128_u32[1] = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[1]) | (*(unsigned __int16 *)(v4 + (((unint64_t)v3[1] >> 15) & 0x1FFFE)) << 16);
  result.n128_u64[1] = __PAIR64__(*(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[3]) | (*(unsigned __int16 *)(v4 + (((unint64_t)v3[3] >> 15) & 0x1FFFE)) << 16), *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[2]) | (*(unsigned __int16 *)(v4 + (((unint64_t)v3[2] >> 15) & 0x1FFFE)) << 16));
  LODWORD(v6) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[4]) | (*(unsigned __int16 *)(v4
                                                                                                 + (((unint64_t)v3[4] >> 15) & 0x1FFFE)) << 16);
  DWORD1(v6) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[5]) | (*(unsigned __int16 *)(v4
                                                                                                + (((unint64_t)v3[5] >> 15) & 0x1FFFE)) << 16);
  *((void *)&v6 + 1) = __PAIR64__(*(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[7]) | (*(unsigned __int16 *)(v4 + (((unint64_t)v3[7] >> 15) & 0x1FFFE)) << 16), *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[6]) | (*(unsigned __int16 *)(v4 + (((unint64_t)v3[6] >> 15) & 0x1FFFE)) << 16));
  LODWORD(v7) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[8]) | (*(unsigned __int16 *)(v4
                                                                                                 + (((unint64_t)v3[8] >> 15) & 0x1FFFE)) << 16);
  DWORD1(v7) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[9]) | (*(unsigned __int16 *)(v4
                                                                                                + (((unint64_t)v3[9] >> 15) & 0x1FFFE)) << 16);
  *((void *)&v7 + 1) = __PAIR64__(*(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[11]) | (*(unsigned __int16 *)(v4 + (((unint64_t)v3[11] >> 15) & 0x1FFFE)) << 16), *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[10]) | (*(unsigned __int16 *)(v4 + (((unint64_t)v3[10] >> 15) & 0x1FFFE)) << 16));
  LODWORD(v8) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[12]) | (*(unsigned __int16 *)(v4
                                                                                                  + (((unint64_t)v3[12] >> 15) & 0x1FFFE)) << 16);
  DWORD1(v8) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[13]) | (*(unsigned __int16 *)(v4
                                                                                                 + (((unint64_t)v3[13] >> 15) & 0x1FFFE)) << 16);
  DWORD2(v8) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[14]) | (*(unsigned __int16 *)(v4
                                                                                                 + (((unint64_t)v3[14] >> 15) & 0x1FFFE)) << 16);
  HIDWORD(v8) = *(unsigned __int16 *)(v4 + 2 * (unsigned __int16)v3[15]) | (*(unsigned __int16 *)(v4
                                                                                                  + (((unint64_t)v3[15] >> 15) & 0x1FFFE)) << 16);
  *(_OWORD *)(a3 + 32) = v7;
  *(_OWORD *)(a3 + 48) = v8;
  *(__n128 *)a3 = result;
  *(_OWORD *)(a3 + 16) = v6;
  return result;
}

const char *__cdecl axr_error_get_name(axr_error_t error)
{
  if ((unint64_t)-(uint64_t)error <= 0xE) {
    return axr_error_get_name_kErrorNames[-error];
  }
  else {
    return "<Unknown axr_error_t>";
  }
}

size_t axr_flags_get_name(char *buf, size_t len, axr_flags_t flags)
{
  if (flags == axr_flags_default) {
    return snprintf(buf, len, "%s", "axr_flags_default");
  }
  size_t v6 = 0;
  uint64_t v7 = 1;
  uint64_t v8 = 1u;
  while (1)
  {
    if ((v7 & flags) != 0)
    {
      if (v6) {
        v6 += snprintf(&buf[v6], len - v6, " | %s", axr_flags_get_name_kFlagNames[v8]);
      }
      else {
        size_t v6 = snprintf(buf, len, "%s", axr_flags_get_name_kFlagNames[v8]);
      }
      if (v6 >= len) {
        break;
      }
    }
    v7 *= 2;
    if (++v8 == 4)
    {
      if ((flags & 0xFFFFFFFFFFFFFFF0) != 0) {
        v6 += snprintf(&buf[v6], len - v6, "  Error: <Unknown axr_flags_t> 0x%llx", flags & 0xFFFFFFFFFFFFFFF0);
      }
      return v6;
    }
  }
  return v6;
}

const char *__cdecl axr_compression_get_name(axr_compression_t compressionType)
{
  if (compressionType <= axr_compression_b44a) {
    return axr_compression_get_name_kCompressionMethodNames[compressionType];
  }
  else {
    return "<Invalid compression style>";
  }
}

const char *__cdecl axr_type_get_name(axr_type_t type)
{
  if (type <= axr_type_float) {
    return kSampleTypeNames[type];
  }
  else {
    return "<invalid axr_type_t>";
  }
}

const char *__cdecl axr_property_flags_get_name(axr_property_flags_t flags)
{
  if (flags <= axr_property_flags_part_info_v1 && (flags & 0xFF00) <= 0x100) {
    return kPropertiesFlagsNames[flags | ((unint64_t)((unsigned __int16)flags & 0xFF00) >> 7)];
  }
  else {
    return "<invalid axr_property_flags_t>";
  }
}

size_t axr_type_get_size(axr_type_t a1)
{
  size_t v1 = 4;
  if (a1 == axr_type_half) {
    size_t v1 = 2;
  }
  if (a1 <= axr_type_float) {
    return v1;
  }
  else {
    return 0;
  }
}

const char *__cdecl axr_level_mode_get_name(axr_level_mode_t mode)
{
  unsigned __int32 v1 = mode & 0xF;
  if (v1 >= 3) {
    unsigned __int32 v1 = 3;
  }
  return axr_level_mode_get_name_kLevelMode[v1];
}

uint32_t axr_get_version(void)
{
  uint32_t result = axr_get_version_version;
  if (axr_get_version_version) {
    return result;
  }
  memset(&v14, 0, sizeof(v14));
  uint32_t result = dladdr(axr_data_create, &v14);
  if (!result) {
    return result;
  }
  dli_fbase = (char *)v14.dli_fbase;
  if (!v14.dli_fbase) {
    return 0;
  }
  if (*(_DWORD *)v14.dli_fbase != -889275714 && *(_DWORD *)v14.dli_fbase != -1095041334) {
    goto LABEL_16;
  }
  unsigned int v3 = *((_DWORD *)v14.dli_fbase + 1);
  if (!v3) {
    return 0;
  }
  unsigned int v4 = bswap32(v3);
  for (i = (unsigned int *)((char *)v14.dli_fbase + 16); *(i - 2) != 16777228; i += 5)
  {
    if (!--v4) {
      return 0;
    }
  }
  uint64_t v6 = *i;
  if (!v6) {
    return 0;
  }
  dli_fbase = (char *)v14.dli_fbase + v6;
LABEL_16:
  int v8 = *((_DWORD *)dli_fbase + 8);
  uint64_t v7 = dli_fbase + 32;
  unsigned int v9 = *(v7 - 3);
  BOOL v10 = v8 != 13;
  BOOL v11 = v8 != 13 && v9 >= 9;
  if (v11)
  {
    do
    {
      uint64_t v12 = v7[1];
      BOOL v11 = v9 >= v12;
      v9 -= v12;
      if (!v11) {
        unsigned int v9 = 0;
      }
      uint64_t v7 = (_DWORD *)((char *)v7 + v12);
      BOOL v10 = *v7 != 13;
    }
    while (*v7 != 13 && v9 > 8);
  }
  uint32_t result = 0;
  if (v9 >= 8 && !v10)
  {
    uint32_t result = v7[4];
    axr_get_version_version = result;
  }
  return result;
}

uint64_t ChunkLayout_Print(char *a1, size_t a2, unsigned int a3)
{
  if (a3 > 3) {
    return snprintf(a1, a2, "<unknown layout: %x>");
  }
  else {
    return snprintf(a1, a2, "%s");
  }
}

const char *__cdecl axr_channel_type_get_name(axr_channel_type_t type)
{
  if (type <= axr_channel_type_v) {
    return off_2648577F8[type];
  }
  else {
    return "<invalid channel type>";
  }
}

const char *__cdecl axr_line_order_get_name(axr_line_order_t line_orderType)
{
  if (line_orderType >= (axr_line_order_random_y|axr_line_order_decreasing_y)) {
    axr_line_order_t v1 = axr_line_order_random_y|axr_line_order_decreasing_y;
  }
  else {
    axr_line_order_t v1 = line_orderType;
  }
  return axr_line_order_get_name_kLineOrderNames[v1];
}

void *AXRLogicalImageList::AXRLogicalImageList(void *a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v141 = *MEMORY[0x263EF8340];
  a1[1] = 0;
  uint64_t v90 = a1 + 1;
  *a1 = 0;
  a1[2] = 0;
  if (!a2) {
    return a1;
  }
  int v8 = a2;
  Class isa = a2[12].isa;
  if (!isa) {
    return a1;
  }
  BOOL v111 = 0;
  unint64_t v106 = (AXRData *)&a2[2];
  AXRLogicalImageList::LoadDefaultGroups((AXRLogicalImageList *)a1, (const AXRData *)&a2[2], &v111, a4, a5, a6, a7, a8);
  unint64_t v9 = 0;
  __dst = v109;
  unint64_t v108 = 32;
  uint64_t v91 = v8;
  do
  {
    unint64_t layer_count = axr_data_get_layer_count(v8, v9);
    memset(&v107, 0, sizeof(v107));
    axr_data_get_part_info(&v107, v8, v9, axr_part_info_current);
    if (!layer_count) {
      goto LABEL_148;
    }
    unint64_t v15 = 0;
    do
    {
      __src[1] = 0;
      __src[0] = 0;
      *(void *)&long long v124 = 0;
      AXRData::GetLayerInfo(v106, v9, v15, v10, v11, v12, v13, v14, __src);
      unint64_t v95 = v15;
      unint64_t v16 = v124;
      if (!(void)v124) {
        goto LABEL_139;
      }
      if (v108 < (unint64_t)v124)
      {
        uint64_t v79 = __dst;
        if (__dst == v109)
        {
          uint64_t v79 = 0;
          __dst = 0;
        }
        int v17 = (unsigned int *)reallocf(v79, 4 * v124);
        __dst = v17;
        unint64_t v108 = v16;
        if (!v17) {
          goto LABEL_139;
        }
      }
      else
      {
        int v17 = (unsigned int *)__dst;
        if (!__dst) {
          goto LABEL_139;
        }
      }
      uint64_t v101 = v17;
      memcpy(v17, __src[1], 4 * v124);
      unint64_t v18 = (const char *)__src[0];
      __s1[0] = 0;
      if (!(void)v124) {
        goto LABEL_139;
      }
      unint64_t v19 = v124;
      BOOL v20 = v111;
      if (v111)
      {
        uint64_t v21 = strrchr((char *)__src[0], 46);
        uint64_t v22 = v18;
        if (v21)
        {
          int v24 = *v21;
          uint64_t v23 = v21 + 1;
          if (v24) {
            uint64_t v22 = v23;
          }
          else {
            uint64_t v22 = v18;
          }
        }
        strncpy(__s1, v22, 0x100uLL);
        __s1[255] = 0;
        if (!__s1[0])
        {
          uint64_t v25 = (void *)*v90;
          if (!*v90) {
            goto LABEL_32;
          }
          goto LABEL_30;
        }
      }
      else if (v107.view)
      {
        strncpy(__s1, v107.view, 0x100uLL);
      }
      unint64_t v26 = (void *)*v90;
      if (!*v90)
      {
        if (v20)
        {
LABEL_32:
          uint64_t v27 = 0;
LABEL_33:
          uint64_t v28 = (char *)&unk_228F63AF7;
        }
        else
        {
          uint64_t v27 = 0;
LABEL_36:
          uint64_t v28 = __s1;
        }
        int8x16_t v29 = malloc_type_malloc(0x120uLL, 0x102004010D29A0BuLL);
        uint64_t v25 = v29;
        if (!v29) {
          goto LABEL_139;
        }
        *(_OWORD *)int8x16_t v29 = 0u;
        *((_OWORD *)v29 + 1) = 0u;
        strlcpy((char *)v29 + 32, v28, 0x100uLL);
        int16x8_t v30 = v90;
        if (v27) {
          int16x8_t v30 = v27;
        }
        *int16x8_t v30 = v25;
        ++*a1;
LABEL_41:
        strncpy(__s, v18, 0x100uLL);
        char v119 = 0;
        if (!v20) {
          goto LABEL_51;
        }
        goto LABEL_42;
      }
      uint64_t v25 = 0;
      do
      {
        uint64_t v27 = v26;
        if (!v25)
        {
          if (*((unsigned char *)v26 + 32)) {
            uint64_t v25 = 0;
          }
          else {
            uint64_t v25 = v26;
          }
        }
        if (!strcmp(__s1, (const char *)v26 + 32))
        {
          uint64_t v25 = v27;
          goto LABEL_41;
        }
        unint64_t v26 = (void *)*v27;
      }
      while (*v27);
      if (!v20) {
        goto LABEL_36;
      }
      if (!v25) {
        goto LABEL_33;
      }
LABEL_30:
      strncpy(__s, v18, 0x100uLL);
      char v119 = 0;
LABEL_42:
      if (*((unsigned char *)v25 + 32))
      {
        int8x16_t v31 = strrchr(__s, 46);
        __n128 v32 = v31;
        __n128 v33 = v31 ? v31 + 1 : __s;
        if (!strcmp(v33, (const char *)v25 + 32))
        {
          if (v32) {
            unint64_t v34 = v32;
          }
          else {
            unint64_t v34 = __s;
          }
          *unint64_t v34 = 0;
        }
      }
LABEL_51:
      if (!__s[0] && v107.name && *v107.name)
      {
        strncpy(__s, v107.name, 0x100uLL);
        char v119 = 0;
      }
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      if (v19 <= 1) {
        uint64_t v37 = 1;
      }
      else {
        uint64_t v37 = v19;
      }
      do
      {
        uint64_t v140 = 0;
        long long v139 = 0u;
        long long v138 = 0u;
        long long v137 = 0u;
        long long v136 = 0u;
        long long v135 = 0u;
        long long v134 = 0u;
        long long v133 = 0u;
        long long v132 = 0u;
        long long v131 = 0u;
        long long v130 = 0u;
        long long v129 = 0u;
        long long v128 = 0u;
        long long v127 = 0u;
        long long v126 = 0u;
        long long v125 = 0u;
        long long v124 = 0u;
        *(_OWORD *)__src = 0u;
        AXRData::GetChannelInfo(v106, v9, v101[v35], v10, v11, v12, v13, v14, (uint64_t)__src);
        v36 |= 1 << SBYTE4(__src[0]);
        ++v35;
      }
      while (v37 != v35);
      uint64_t v93 = v25;
      uint64_t v94 = v25 + 3;
      do
      {
        uint64_t v39 = 0;
        unint64_t v40 = &kColorModelInfo;
        while ((*v40 & ~v36) != 0)
        {
          ++v39;
          v40 += 2;
          if (v39 == 12) {
            goto LABEL_63;
          }
        }
        if (v39 < 0xC)
        {
          uint64_t v41 = *v40;
          goto LABEL_64;
        }
LABEL_63:
        uint64_t v41 = 0;
        unint64_t v40 = 0;
LABEL_64:
        uint64_t v117 = 0;
        long long v115 = 0u;
        long long v116 = 0u;
        float32x4_t v113 = 0u;
        float32x4_t v114 = 0u;
        memset(v112, 0, sizeof(v112));
        unint64_t v42 = v9;
        AXRData::GetImageInfo(v106, v9, v38, v10, v11, v12, v13, v14, (uint64_t)v112);
        if (SDWORD1(v112[0]) >= SLODWORD(v112[0])) {
          int v43 = DWORD1(v112[0]) - LODWORD(v112[0]) + 1;
        }
        else {
          int v43 = 0;
        }
        if (SHIDWORD(v112[0]) >= SDWORD2(v112[0])) {
          int v44 = HIDWORD(v112[0]) - DWORD2(v112[0]) + 1;
        }
        else {
          int v44 = 0;
        }
        int v96 = v44;
        int v97 = v43;
        if (!v40)
        {
          uint64_t v140 = 0;
          long long v139 = 0u;
          long long v138 = 0u;
          long long v137 = 0u;
          long long v136 = 0u;
          long long v135 = 0u;
          long long v134 = 0u;
          long long v133 = 0u;
          long long v132 = 0u;
          long long v131 = 0u;
          long long v130 = 0u;
          long long v129 = 0u;
          long long v128 = 0u;
          long long v127 = 0u;
          long long v126 = 0u;
          long long v125 = 0u;
          long long v124 = 0u;
          *(_OWORD *)__src = 0u;
          AXRData::GetChannelInfo(v106, v9, *v101, v10, v11, v12, v13, v14, (uint64_t)__src);
          char v61 = BYTE4(__src[0]);
          int v62 = (int)__src[0];
          int v63 = *v101;
          unint64_t v105 = v19 - 1;
          memmove(v101, v101 + 1, 4 * (v19 - 1));
          unsigned int v64 = strrchr((char *)&v124 + 8, 46);
          if (v64) {
            long long v65 = v64 + 1;
          }
          else {
            long long v65 = (char *)&v124 + 8;
          }
          if (*v65)
          {
            if (__s[0])
            {
              snprintf(__str, 0x100uLL, "%s.%s", __s, v65);
              goto LABEL_126;
            }
          }
          else
          {
            long long v65 = __s;
          }
          strncpy(__str, v65, 0x100uLL);
LABEL_126:
          char v122 = 0;
          size_t v72 = strlen(__str);
          if (v72 + 1 >= 2) {
            size_t v73 = v72 + 1;
          }
          else {
            size_t v73 = 256;
          }
          uint64_t v74 = (char *)malloc_type_malloc(v73 + 80, 0x51D21381uLL);
          unint64_t v71 = v74;
          uint64_t v58 = 1 << v61;
          if (v74)
          {
            *(void *)uint64_t v74 = 0;
            *((void *)v74 + 1) = v58;
            *((_DWORD *)v74 + 4) = v97;
            *((_DWORD *)v74 + 5) = v96;
            *((_DWORD *)v74 + 6) = v62;
            *((_DWORD *)v74 + 7) = v9;
            *((_DWORD *)v74 + 8) = v95;
            *(_OWORD *)(v74 + 36) = xmmword_228F627D0;
            *((_DWORD *)v74 + 13) = v63;
            *((void *)v74 + 7) = 0;
            *((void *)v74 + 8) = 0;
            *((_DWORD *)v74 + 18) = v39;
            strlcpy(v74 + 76, __str, v73);
          }
          goto LABEL_131;
        }
        uint64_t v99 = 0;
        int v45 = 0;
        int v46 = 0;
        int v98 = 0;
        unint64_t v47 = 0;
        memset(__str, 255, sizeof(__str));
        int v100 = -1;
        unint64_t v48 = v19;
        while (v47 < v48)
        {
          int v102 = v46;
          int v104 = v45;
          unint64_t v49 = &v101[v47];
          size_t v50 = 4 * (~v47 + v48);
          while (1)
          {
            uint64_t v140 = 0;
            long long v139 = 0u;
            long long v138 = 0u;
            long long v137 = 0u;
            long long v136 = 0u;
            long long v135 = 0u;
            long long v134 = 0u;
            long long v133 = 0u;
            long long v132 = 0u;
            long long v131 = 0u;
            long long v130 = 0u;
            long long v129 = 0u;
            long long v128 = 0u;
            long long v127 = 0u;
            long long v126 = 0u;
            long long v125 = 0u;
            long long v124 = 0u;
            *(_OWORD *)__src = 0u;
            AXRData::GetChannelInfo(v106, v42, *v49, v10, v11, v12, v13, v14, (uint64_t)__src);
            unint64_t v51 = v48;
            uint64_t v52 = 1 << SBYTE4(__src[0]);
            if (((1 << SBYTE4(__src[0])) & v41) != 0) {
              break;
            }
            ++v47;
            ++v49;
            v50 -= 4;
            unint64_t v48 = v51;
            if (v51 == v47)
            {
              int v45 = v104;
              int v46 = v102;
              goto LABEL_100;
            }
          }
          uint64_t v53 = 0;
          int v45 = v104;
          int v54 = v100;
          while (1)
          {
            int v55 = *((char *)v40 + v53 + 12);
            if (v55 != -1 && HIDWORD(__src[0]) == v55) {
              break;
            }
            if (++v53 == 4) {
              goto LABEL_99;
            }
          }
          if (v100 == -1)
          {
            int v54 = (int)__src[0];
          }
          else if (v100 != LODWORD(__src[0]))
          {
            goto LABEL_96;
          }
          int v100 = v54;
          if ((v52 & 0x200) == 0) {
            goto LABEL_98;
          }
          if (v104)
          {
            if (v104 != HIDWORD(__src[1])) {
              goto LABEL_96;
            }
          }
          else
          {
            int v45 = HIDWORD(__src[1]);
          }
          if (!v102)
          {
            int v104 = v45;
            int v102 = v124;
            goto LABEL_98;
          }
          if (v102 == v124)
          {
            int v104 = v45;
LABEL_98:
            *(_DWORD *)&__str[4 * v53] = *v49;
            memmove(v49, v49 + 1, v50);
            v101[--v51] = -1;
            v41 &= ~v52;
            v99 |= v52;
            ++v98;
            int v45 = v104;
            goto LABEL_99;
          }
LABEL_96:
          ++v47;
LABEL_99:
          unint64_t v48 = v51;
          int v46 = v102;
          if (!v41) {
            break;
          }
        }
LABEL_100:
        int v57 = *((_DWORD *)v40 + 2);
        uint64_t v58 = v99;
        if (v99 != v36)
        {
          uint64_t v59 = 0;
          uint64_t v60 = &dword_228F627E8;
          while ((*((void *)v60 - 1) & ~v99) != 0)
          {
            ++v59;
            v60 += 4;
            if (v59 == 12) {
              goto LABEL_113;
            }
          }
          if (v59 <= 0xB) {
            int v57 = *v60;
          }
        }
LABEL_113:
        if (v57 == 1)
        {
          if ((vminvq_u32((uint32x4_t)vandq_s8((int8x16_t)vcgeq_f32((float32x4_t)xmmword_228F627B0, vabsq_f32(vmlaq_f32((float32x4_t)xmmword_228F627A0, (float32x4_t)xmmword_228F62790, v113))), (int8x16_t)vcgeq_f32((float32x4_t)xmmword_228F627B0, vabsq_f32(vmlaq_f32((float32x4_t)xmmword_228F627C0, (float32x4_t)xmmword_228F62790, v114))))) & 0x80000000) == 0)int v57 = 1; {
          else
          }
            int v57 = 7;
        }
        unint64_t v105 = v48;
        if (v98)
        {
          int v66 = v46;
          int v67 = v45;
          long long v103 = *(_OWORD *)__str;
          size_t v68 = strlen(__s);
          if (v68 + 1 >= 2) {
            size_t v69 = v68 + 1;
          }
          else {
            size_t v69 = 256;
          }
          uint64_t v70 = (char *)malloc_type_malloc(v69 + 80, 0x51D21381uLL);
          unint64_t v71 = v70;
          if (v70)
          {
            *(void *)uint64_t v70 = 0;
            *((void *)v70 + 1) = v99;
            *((_DWORD *)v70 + 4) = v97;
            *((_DWORD *)v70 + 5) = v96;
            *((_DWORD *)v70 + 6) = v100;
            *((_DWORD *)v70 + 7) = v42;
            *((_DWORD *)v70 + 8) = v95;
            *((_DWORD *)v70 + 9) = v57;
            *((_DWORD *)v70 + 10) = v67;
            *((_DWORD *)v70 + 11) = v66;
            *((_DWORD *)v70 + 12) = v98;
            *(_OWORD *)(v70 + 52) = v103;
            *((_DWORD *)v70 + 17) = 0;
            *((_DWORD *)v70 + 18) = v39;
            strlcpy(v70 + 76, __s, v69);
          }
        }
        else
        {
          unint64_t v71 = 0;
        }
LABEL_131:
        unint64_t v19 = v105;
        unint64_t v9 = v42;
        if (!v71) {
          break;
        }
        *(void *)unint64_t v71 = 0;
        char v75 = v94;
        uint64_t v76 = (uint64_t *)*v94;
        if (*v94)
        {
          unsigned int v77 = *((_DWORD *)v71 + 18);
          uint64_t v78 = v93;
          if (v77 >= *((_DWORD *)v76 + 18))
          {
            do
            {
              char v75 = v76;
              uint64_t v76 = (uint64_t *)*v76;
            }
            while (v76 && v77 >= *((_DWORD *)v76 + 18));
          }
        }
        else
        {
          uint64_t v78 = v93;
        }
        v36 &= ~v58;
        *(void *)unint64_t v71 = v76;
        *char v75 = v71;
        ++v78[1];
      }
      while (v105);
LABEL_139:
      unint64_t v15 = v95 + 1;
      int v8 = v91;
    }
    while (v95 + 1 != layer_count);
LABEL_148:
    ++v9;
  }
  while ((Class)v9 != isa);
  if (v111)
  {
    uint64_t v80 = (uint64_t *)*v90;
    if (*v90)
    {
      int v81 = 0;
      int v82 = 0;
      int v83 = (const char *)*v90;
      do
      {
        if (v83[32])
        {
          if (!strncmp(v83 + 32, "left", 0x100uLL)) {
            int v81 = 1;
          }
          else {
            v82 |= strncmp(v83 + 32, "right", 0x100uLL) == 0;
          }
        }
        int v83 = *(const char **)v83;
      }
      while (v83);
      if ((v82 ^ v81))
      {
        int v85 = *((unsigned __int8 *)v80 + 32);
        int v84 = (char *)(v80 + 4);
        if (!v85)
        {
          if (v82) {
            unsigned int v86 = "right";
          }
          else {
            unsigned int v86 = "left";
          }
          strncpy(v84, v86, 0x100uLL);
        }
      }
    }
  }
  if (__dst != v109) {
    free(__dst);
  }
  return a1;
}

void sub_228F20F2C(_Unwind_Exception *a1)
{
}

uint64_t AXRLogicalImageList::LoadDefaultGroups(AXRLogicalImageList *this, const AXRData *a2, BOOL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = this;
  uint64_t v78 = *MEMORY[0x263EF8340];
  BOOL v10 = *((void *)a2 + 10) == 1;
  *a3 = v10;
  if (!v10)
  {
LABEL_11:
    if (!*(void *)v9)
    {
      int HasLongNames = AXRData::HasLongNames(a2, 0, (uint64_t)a3, a4, a5, a6, a7, a8);
      uint64_t ImagePropertyCount = AXRData::GetImagePropertyCount(a2, 0, v27, v28, v29, v30, v31, v32);
      if (ImagePropertyCount)
      {
        uint64_t v39 = ImagePropertyCount;
        unint64_t v40 = 0;
        if (HasLongNames) {
          size_t v41 = 255;
        }
        else {
          size_t v41 = 31;
        }
        while (1)
        {
          AXRData::GetImageProperty(a2, 0, v40, v34, v35, v36, v37, v38, (char **)&__dst);
          unint64_t v42 = (const char *)*((void *)&__dst + 1);
          long long v43 = v63;
          if (!strncmp((const char *)__dst, "view", v41) && !strncmp(v42, "string", v41)) {
            break;
          }
          if (v39 == ++v40) {
            return 1;
          }
        }
        if ((void)v43)
        {
          long long v76 = 0u;
          long long v77 = 0u;
          long long v74 = 0u;
          long long v75 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v70 = 0u;
          long long v71 = 0u;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v64 = 0u;
          long long v65 = 0u;
          long long __dst = 0u;
          long long v63 = 0u;
          if ((unint64_t)v43 <= 0xFF)
          {
            memcpy(&__dst, *((const void **)&v43 + 1), v43);
            *((unsigned char *)&__dst + v43) = 0;
          }
          int v54 = v9;
          unint64_t v56 = (char **)((char *)v9 + 8);
          int v55 = (char *)*((void *)v9 + 1);
          if (v55)
          {
            while (1)
            {
              int v57 = (char **)v55;
              if (!strcmp((const char *)&__dst, v55 + 32)) {
                break;
              }
              int v55 = *v57;
              if (!*v57) {
                goto LABEL_49;
              }
            }
          }
          else
          {
            int v57 = 0;
LABEL_49:
            uint64_t v58 = (char *)malloc_type_malloc(0x120uLL, 0x102004010D29A0BuLL);
            if (v58)
            {
              uint64_t v59 = v58;
              *(_OWORD *)uint64_t v58 = 0u;
              *((_OWORD *)v58 + 1) = 0u;
              strlcpy(v58 + 32, (const char *)&__dst, 0x100uLL);
              if (v57) {
                uint64_t v60 = v57;
              }
              else {
                uint64_t v60 = v56;
              }
              *uint64_t v60 = v59;
              ++*(void *)v54;
            }
          }
        }
      }
    }
    return 1;
  }
  int v12 = AXRData::HasLongNames(a2, 0, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = AXRData::GetImagePropertyCount(a2, 0, v13, v14, v15, v16, v17, v18);
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v20 = v19;
  unint64_t v21 = 0;
  size_t v22 = v12 ? 255 : 31;
  while (1)
  {
    AXRData::GetImageProperty(a2, 0, v21, a4, a5, a6, a7, a8, (char **)&__dst);
    uint64_t v23 = (const char *)*((void *)&__dst + 1);
    uint64_t v25 = (unsigned int *)*((void *)&v63 + 1);
    unint64_t v24 = v63;
    if (!strncmp((const char *)__dst, "multiView", v22) && !strncmp(v23, "stringvector", v22)) {
      break;
    }
    if (v20 == ++v21) {
      goto LABEL_10;
    }
  }
  if (!v24)
  {
LABEL_10:
    *a3 = 0;
    unint64_t v9 = this;
    goto LABEL_11;
  }
  if (v24 >= 4)
  {
    int v45 = (uint64_t *)((char *)this + 8);
    do
    {
      unint64_t v46 = *v25;
      unint64_t v47 = v24 - 4;
      if (v46 > 0xFE || v47 < v46) {
        break;
      }
      memcpy(&__dst, v25 + 1, *v25);
      *((unsigned char *)&__dst + v46) = 0;
      unint64_t v49 = (char *)*v45;
      if (*v45)
      {
        while (1)
        {
          size_t v50 = (char **)v49;
          if (!strcmp((const char *)&__dst, v49 + 32)) {
            break;
          }
          unint64_t v49 = *v50;
          if (!*v50) {
            goto LABEL_33;
          }
        }
      }
      else
      {
        size_t v50 = 0;
LABEL_33:
        unint64_t v51 = (char *)malloc_type_malloc(0x120uLL, 0x102004010D29A0BuLL);
        if (v51)
        {
          uint64_t v52 = v51;
          *(_OWORD *)unint64_t v51 = 0u;
          *((_OWORD *)v51 + 1) = 0u;
          strlcpy(v51 + 32, (const char *)&__dst, 0x100uLL);
          if (v50) {
            uint64_t v53 = v50;
          }
          else {
            uint64_t v53 = (char **)((char *)this + 8);
          }
          _WORD *v53 = v52;
          ++*(void *)this;
        }
      }
      uint64_t v25 = (unsigned int *)((char *)v25 + v46 + 4);
      unint64_t v24 = v47 - v46;
    }
    while (v47 - v46 > 3);
  }
  unint64_t v9 = this;
  if (!*a3) {
    goto LABEL_11;
  }
  return 1;
}

BOOL AXRLogicalImageList::IsEqual(AXRLogicalImageList *this, const AXRLogicalImageList *a2)
{
  if (*(void *)this != *(void *)a2) {
    return 0;
  }
  v2 = (const AXRLogicalImageList *)((char *)a2 + 8);
  unsigned int v3 = (AXRLogicalImageList *)((char *)this + 8);
  while (1)
  {
    unsigned int v3 = *(AXRImageGroup **)v3;
    v2 = *(const AXRImageGroup **)v2;
    if (!v2 || v3 == 0) {
      break;
    }
    if (!AXRImageGroup::IsEqual(v3, v2)) {
      return 0;
    }
  }
  return v3 == v2;
}

BOOL AXRImageGroup::IsEqual(AXRImageGroup *this, const AXRImageGroup *a2)
{
  if (!a2) {
    return 0;
  }
  if (*(_OWORD *)((char *)this + 8) != *(_OWORD *)((char *)a2 + 8)) {
    return 0;
  }
  if (a2 == this) {
    return 1;
  }
  v2 = (AXRImageLayer *)*((void *)this + 3);
  if (*((void *)this + 1))
  {
    unsigned int v3 = (const AXRImageLayer *)*((void *)a2 + 3);
    if (v2) {
      goto LABEL_6;
    }
    return v3 == 0;
  }
  unsigned int v3 = 0;
  if (!v2) {
    return v3 == 0;
  }
LABEL_6:
  while (1)
  {
    BOOL result = AXRImageLayer::IsEqual(v2, v3);
    if (!result) {
      break;
    }
    v2 = *(AXRImageLayer **)v2;
    unsigned int v3 = *(const AXRImageLayer **)v3;
    if (!v2) {
      return v3 == 0;
    }
  }
  return result;
}

size_t AXRImageGroup::GetSerializedSize(AXRImageGroup *this)
{
  size_t v2 = strlen((const char *)this + 32) + 13;
  for (i = (const char *)*((void *)this + 3); i; i = *(const char **)i)
    v2 += strlen(i + 76) + 4 * *((unsigned int *)i + 12) + 49;
  return v2;
}

void AXRLogicalImageList::AXRLogicalImageList(AXRLogicalImageList *this, const void **a2, const void **a3, axr_error_t *a4, uint64_t a5, axr_error_t *a6, uint64_t a7, uint64_t a8)
{
  *((void *)this + 1) = 0;
  BOOL v10 = (AXRLogicalImageList *)((char *)this + 8);
  *(void *)this = 0;
  uint64_t v11 = *a2;
  if (!*a2)
  {
    if (!a4) {
      return;
    }
    uint64_t v19 = -7;
LABEL_13:
    *a4 = v19;
    return;
  }
  uint64_t v13 = (char *)*a3;
  if ((unint64_t)*a3 <= 3 || (int v15 = *v11, *a2 = v11 + 1, *a3 = v13 - 4, v15 != 1920496243))
  {
    if (!a4) {
      return;
    }
    uint64_t v19 = -2;
    goto LABEL_13;
  }
  if ((unint64_t)(v13 - 4) <= 3)
  {
    char v17 = 0;
    char v18 = 0;
    if (!a4)
    {
LABEL_7:
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | a5) & 2) != 0) {
        AXRLogError((uint64_t)"Serialized axr_logical_image_list version (%u) too new", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8, v18);
      }
      return;
    }
LABEL_6:
    *a4 = axr_error_unknown_file_type;
    char v18 = v17;
    goto LABEL_7;
  }
  unsigned int v20 = v11[1];
  *a2 = v11 + 2;
  *a3 = v13 - 8;
  if (v20 != 0x1000000)
  {
    char v17 = bswap32(v20);
    char v18 = v17;
    if (!a4) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if ((unint64_t)(v13 - 8) <= 7)
  {
    if (!a4) {
      return;
    }
    uint64_t v19 = -4;
    goto LABEL_13;
  }
  unint64_t v21 = *((void *)v11 + 1);
  *a2 = v11 + 4;
  *a3 = v13 - 16;
  if (v21)
  {
    size_t v22 = 0;
    unint64_t v23 = bswap64(v21);
    do
    {
      unint64_t v24 = AXRImageGroup::Deserialize(a2, a3, (unint64_t *)1, a5, a4, a6);
      if (!v24) {
        break;
      }
      uint64_t v25 = (AXRImageGroup **)(v22 ? v22 : v10);
      *uint64_t v25 = v24;
      ++*(void *)this;
      size_t v22 = v24;
      --v23;
    }
    while (v23);
  }
}

AXRImageGroup *AXRImageGroup::Deserialize(const void **this, const void **a2, unint64_t *a3, uint64_t a4, axr_error_t *a5, axr_error_t *a6)
{
  uint64_t v7 = (char *)*a2;
  if ((unint64_t)*a2 <= 3)
  {
    if (a5)
    {
      int v8 = 0;
      axr_error_t v9 = axr_error_data_truncated;
LABEL_4:
      *a5 = v9;
      return v8;
    }
    return 0;
  }
  int v12 = (unsigned __int8 *)*this + 4;
  int v13 = *(_DWORD *)*this;
  *this = v12;
  uint64_t v14 = v7 - 4;
  *a2 = v14;
  if (v13 != 1735946849)
  {
    if (a5 && *a5 == axr_error_success)
    {
      int v8 = 0;
      axr_error_t v9 = axr_error_data_corrupted;
      goto LABEL_4;
    }
    return 0;
  }
  if (v14) {
    size_t v17 = *v12 + 291;
  }
  else {
    size_t v17 = 291;
  }
  char v18 = (AXRImageGroup *)malloc_type_malloc(v17, 0x7BF1BFDEuLL);
  if (!v18)
  {
    if (a5)
    {
      int v8 = 0;
      axr_error_t v9 = axr_error_insufficient_memory;
      goto LABEL_4;
    }
    return 0;
  }
  int v8 = v18;
  axr_error_t v23 = axr_error_success;
  AXRImageGroup::AXRImageGroup(v18, this, a2, a3, a4, &v23, v19, v20);
  if (v23)
  {
    while (1)
    {
      unint64_t v21 = (void *)*((void *)v8 + 3);
      if (!v21) {
        break;
      }
      *((void *)v8 + 3) = *v21;
      MEMORY[0x22A6AD870]();
    }
    free(v8);
    int v8 = 0;
    if (a5)
    {
      axr_error_t v9 = v23;
      goto LABEL_4;
    }
  }
  return v8;
}

BOOL AXRImageGroup::Serialize(AXRImageGroup *this, void **a2, unint64_t *a3)
{
  unint64_t v3 = *a3 - 4;
  if (*a3 < 4) {
    return 0;
  }
  uint64_t v7 = *a2;
  *uint64_t v7 = 1735946849;
  int v8 = v7 + 1;
  *a2 = v8;
  *a3 = v3;
  axr_error_t v9 = (char *)this + 32;
  size_t v10 = strlen((const char *)this + 32);
  size_t v11 = v10 >= 0xFF ? 255 : v10;
  if (v3 <= v11) {
    return 0;
  }
  size_t v12 = v11 + 1;
  *int v8 = v11;
  memcpy(v8 + 1, v9, v11);
  int v13 = (char *)*a2 + v12;
  *a2 = v13;
  unint64_t v14 = *a3 - v12;
  *a3 = v14;
  BOOL v15 = v14 >= 8;
  unint64_t v16 = v14 - 8;
  if (!v15) {
    return 0;
  }
  *int v13 = bswap64(*((void *)this + 1));
  *a2 = v13 + 1;
  *a3 = v16;
  size_t v17 = (AXRImageGroup *)((char *)this + 24);
  do
  {
    size_t v17 = *(AXRImageLayer **)v17;
    BOOL v18 = v17 == 0;
  }
  while (v17 && AXRImageLayer::Serialize(v17, a2, a3));
  return v18;
}

BOOL SerializeString(const char *a1, void **a2, unint64_t *a3)
{
  if (a1) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = (const char *)&unk_228F63AF7;
  }
  size_t v6 = strlen(v5);
  if (v6 >= 0xFF) {
    size_t v7 = 255;
  }
  else {
    size_t v7 = v6;
  }
  size_t v8 = *a3;
  if (*a3 > v7)
  {
    axr_error_t v9 = *a2;
    *axr_error_t v9 = v7;
    memcpy(v9 + 1, v5, v7);
    *a2 = (char *)*a2 + v7 + 1;
    *a3 -= v7 + 1;
  }
  return v8 > v7;
}

BOOL AXRImageLayer::Serialize(AXRImageLayer *this, void **a2, unint64_t *a3)
{
  unint64_t v3 = *a3;
  unint64_t v4 = *a3 - 4;
  if (*a3 >= 4)
  {
    uint64_t v5 = *a2;
    size_t v6 = *a2;
    *size_t v6 = 1819441249;
    *a2 = v6 + 1;
    *a3 = v4;
    if (v4 >= 8)
    {
      *(void *)(v5 + 1) = bswap64(*((void *)this + 1));
      *a2 = v5 + 3;
      *a3 = v3 - 12;
      if (v3 - 12 >= 4)
      {
        v5[3] = bswap32(*((_DWORD *)this + 4));
        *a2 = v5 + 4;
        *a3 = v3 - 16;
        if (v3 - 16 >= 4)
        {
          v5[4] = bswap32(*((_DWORD *)this + 5));
          *a2 = v5 + 5;
          *a3 = v3 - 20;
          if (v3 - 20 >= 4)
          {
            v5[5] = bswap32(*((_DWORD *)this + 6));
            *a2 = v5 + 6;
            *a3 = v3 - 24;
            if (v3 - 24 >= 4)
            {
              v5[6] = bswap32(*((_DWORD *)this + 7));
              *a2 = v5 + 7;
              *a3 = v3 - 28;
              if (v3 - 28 >= 4)
              {
                v5[7] = bswap32(*((_DWORD *)this + 8));
                *a2 = v5 + 8;
                *a3 = v3 - 32;
                if (v3 - 32 >= 4)
                {
                  v5[8] = bswap32(*((_DWORD *)this + 9));
                  *a2 = v5 + 9;
                  *a3 = v3 - 36;
                  if (v3 - 36 >= 4)
                  {
                    v5[9] = bswap32(*((_DWORD *)this + 10));
                    *a2 = v5 + 10;
                    *a3 = v3 - 40;
                    if (v3 - 40 >= 4)
                    {
                      v5[10] = bswap32(*((_DWORD *)this + 11));
                      *a2 = v5 + 11;
                      *a3 = v3 - 44;
                      if (v3 - 44 >= 4)
                      {
                        v5[11] = bswap32(*((_DWORD *)this + 12));
                        size_t v7 = v5 + 12;
                        *a2 = v7;
                        *a3 = v3 - 48;
                        if (!*((_DWORD *)this + 12)) {
                          return SerializeString((const char *)this + 76, a2, a3);
                        }
                        unint64_t v8 = 0;
                        unint64_t v9 = (v3 - 48) >> 2;
                        unint64_t v10 = v3 - 52;
                        while (v9 != v8)
                        {
                          *v7++ = bswap32(*((_DWORD *)this + v8 + 13));
                          *a2 = v7;
                          *a3 = v10;
                          ++v8;
                          v10 -= 4;
                          if (v8 >= *((unsigned int *)this + 12)) {
                            return SerializeString((const char *)this + 76, a2, a3);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

void AXRImageGroup::AXRImageGroup(AXRImageGroup *this, const void **a2, const void **a3, unint64_t *a4, uint64_t a5, axr_error_t *a6, uint64_t a7, uint64_t a8)
{
  *((unsigned char *)this + 32) = 0;
  unint64_t v10 = (char *)this + 32;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  size_t v11 = *a3;
  if (!*a3) {
    goto LABEL_9;
  }
  unint64_t v16 = (unint64_t *)*a2;
  unsigned int v19 = *(unsigned __int8 *)v16;
  size_t v17 = (char *)v16 + 1;
  unint64_t v18 = v19;
  *a2 = v17;
  unint64_t v20 = (unint64_t)v11 - 1;
  *a3 = (const void *)v20;
  if (v19)
  {
    size_t v21 = v20 >= v18 ? v18 : v20;
    memcpy((char *)this + 32, v17, v21);
    v10[v21] = 0;
    *a2 = (char *)*a2 + v21;
    unint64_t v22 = (unint64_t)*a3 - v21;
    *a3 = (const void *)v22;
  }
  else
  {
    *unint64_t v10 = 0;
    unint64_t v22 = (unint64_t)*a3;
  }
  if (v22 > 7)
  {
    unint64_t v23 = *(void *)*a2;
    *a2 = (char *)*a2 + 8;
    *a3 = (const void *)(v22 - 8);
    if (v23)
    {
      unint64_t v24 = 0;
      unint64_t v25 = bswap64(v23);
      unsigned int v26 = 1;
      do
      {
        uint64_t v27 = AXRImageLayer::Deserialize((int **)a2, a3, a4, a5, (uint64_t *)a6, a6, a7, a8);
        if (!v27) {
          break;
        }
        uint64_t v28 = v24 ? (AXRImageGroup *)v24 : (AXRImageGroup *)((char *)this + 24);
        *(void *)uint64_t v28 = v27;
        ++*((void *)this + 1);
        BOOL v29 = v25 > v26++;
        unint64_t v24 = v27;
      }
      while (v29);
    }
  }
  else
  {
LABEL_9:
    if (a6) {
      *a6 = axr_error_data_truncated;
    }
  }
}

char *AXRImageLayer::Deserialize(int **this, const void **a2, unint64_t *a3, uint64_t a4, uint64_t *a5, axr_error_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (a3 != 1)
  {
    int v12 = a4;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v12) & 2) != 0) {
      AXRLogError((uint64_t)"%s: error unhandled version (%d)", (uint64_t)a2, (uint64_t)a3, a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (char)"Deserialize");
    }
    if (a5)
    {
      BOOL result = 0;
      uint64_t v11 = -3;
      goto LABEL_44;
    }
    return 0;
  }
  unint64_t v9 = (unint64_t)*a2;
  if ((unint64_t)*a2 <= 3) {
    goto LABEL_3;
  }
  int v13 = *this;
  int v14 = *(*this)++;
  *a2 = (const void *)(v9 - 4);
  if (v14 != 1819441249) {
    goto LABEL_42;
  }
  if (v9 - 4 <= 7) {
    goto LABEL_3;
  }
  unint64_t v15 = bswap64(*(void *)(v13 + 1));
  *this = v13 + 3;
  *a2 = (const void *)(v9 - 12);
  *(void *)&long long v49 = v15;
  if (v9 - 12 <= 3) {
    goto LABEL_3;
  }
  unsigned int v16 = bswap32(v13[3]);
  *this = v13 + 4;
  *a2 = (const void *)(v9 - 16);
  DWORD2(v49) = v16;
  if (v9 - 16 <= 3) {
    goto LABEL_3;
  }
  unsigned int v17 = bswap32(v13[4]);
  *this = v13 + 5;
  *a2 = (const void *)(v9 - 20);
  HIDWORD(v49) = v17;
  if (v9 - 20 <= 3) {
    goto LABEL_3;
  }
  unsigned int v18 = bswap32(v13[5]);
  *this = v13 + 6;
  *a2 = (const void *)(v9 - 24);
  LODWORD(v50) = v18;
  if (v9 - 24 <= 3) {
    goto LABEL_3;
  }
  unsigned int v19 = bswap32(v13[6]);
  *this = v13 + 7;
  *a2 = (const void *)(v9 - 28);
  DWORD1(v50) = v19;
  if (v9 - 28 <= 3) {
    goto LABEL_3;
  }
  unsigned int v20 = bswap32(v13[7]);
  *this = v13 + 8;
  *a2 = (const void *)(v9 - 32);
  DWORD2(v50) = v20;
  if (v9 - 32 <= 3) {
    goto LABEL_3;
  }
  int v21 = bswap32(v13[8]);
  *this = v13 + 9;
  *a2 = (const void *)(v9 - 36);
  HIDWORD(v50) = v21;
  if (v9 - 36 <= 3) {
    goto LABEL_3;
  }
  unsigned int v22 = bswap32(v13[9]);
  *this = v13 + 10;
  *a2 = (const void *)(v9 - 40);
  LODWORD(v51[0]) = v22;
  if (v9 - 40 <= 3) {
    goto LABEL_3;
  }
  unsigned int v23 = bswap32(v13[10]);
  *this = v13 + 11;
  *a2 = (const void *)(v9 - 44);
  DWORD1(v51[0]) = v23;
  if (v9 - 44 <= 3) {
    goto LABEL_3;
  }
  unint64_t v48 = v15;
  unsigned int v24 = v13[11];
  unsigned int v25 = bswap32(v24);
  unsigned int v26 = (unsigned int *)(v13 + 12);
  *this = (int *)v26;
  uint64_t v27 = (char *)(v9 - 48);
  *a2 = (const void *)(v9 - 48);
  DWORD2(v51[0]) = v25;
  if (v18 > 2 || v21 < -1 || v21 > 7 || v22 > v16 || v23 > v17 || v25 > 4)
  {
LABEL_42:
    if (a5)
    {
      BOOL result = 0;
      uint64_t v11 = -6;
      goto LABEL_44;
    }
    return 0;
  }
  if (v24)
  {
    if (v25 <= 1) {
      uint64_t v30 = 1;
    }
    else {
      uint64_t v30 = v25;
    }
    uint64_t v31 = (_DWORD *)v51 + 3;
    uint64_t v32 = (char *)(v9 - 52);
    while ((unint64_t)v32 < 0xFFFFFFFFFFFFFFFCLL)
    {
      unsigned int v33 = *v26++;
      *this = (int *)v26;
      *a2 = v32;
      *v31++ = bswap32(v33);
      v32 -= 4;
      if (!--v30)
      {
        uint64_t v27 = v32 + 4;
        goto LABEL_36;
      }
    }
LABEL_3:
    if (a5)
    {
      BOOL result = 0;
      uint64_t v11 = -4;
LABEL_44:
      *a5 = v11;
      return result;
    }
    return 0;
  }
LABEL_36:
  if (!v27)
  {
    if (a5)
    {
      size_t v41 = 0;
      uint64_t v47 = -4;
      goto LABEL_54;
    }
    return 0;
  }
  unsigned int v36 = *(unsigned __int8 *)v26;
  uint64_t v34 = (char *)v26 + 1;
  size_t v35 = v36;
  *this = (int *)v34;
  uint64_t v37 = v27 - 1;
  *a2 = v27 - 1;
  if (v36)
  {
    uint64_t v38 = v34;
    if ((unint64_t)v37 >= v35) {
      size_t v39 = v35;
    }
    else {
      size_t v39 = (size_t)(v27 - 1);
    }
    memcpy(__dst, v34, v39);
    __dst[v39] = 0;
    *this = (int *)&v38[v39];
    *a2 = &v37[-v39];
  }
  else
  {
    __dst[0] = 0;
  }
  unint64_t v40 = (char *)malloc_type_malloc(v35 + 81, 0x6E8A8E50uLL);
  if (v40)
  {
    size_t v41 = v40;
    uint64_t v42 = 0;
    long long v43 = &kColorModelInfo;
    do
    {
      uint64_t v44 = *v43;
      v43 += 2;
      if ((v44 & ~v48) == 0) {
        break;
      }
      ++v42;
    }
    while (v42 != 12);
    *(void *)unint64_t v40 = 0;
    long long v45 = v50;
    *(_OWORD *)(v40 + 8) = v49;
    *(_OWORD *)(v40 + 24) = v45;
    long long v46 = v51[1];
    *(_OWORD *)(v40 + 40) = v51[0];
    *(_OWORD *)(v40 + 56) = v46;
    *((_DWORD *)v40 + 18) = v42;
    strlcpy(v40 + 76, __dst, v35 + 1);
    return v41;
  }
  if (!a5) {
    return 0;
  }
  size_t v41 = 0;
  uint64_t v47 = -5;
LABEL_54:
  *a5 = v47;
  return v41;
}

void *AXRImageGroup::GetDebugDescription(AXRImageGroup *this, const char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  unint64_t v4 = [NSString stringWithFormat:@"%sview: %p \"%s\"\n", a2, this, (char *)this + 32];
  snprintf(__str, 0x20uLL, "%s\t", a2);
  for (i = (AXRImageLayer *)*((void *)this + 3); i; i = *(AXRImageLayer **)i)
    unint64_t v4 = [v4 stringByAppendingString:AXRImageLayer::GetDebugDescription(i, __str)];
  return v4;
}

uint64_t AXRImageLayer::GetDebugDescription(AXRImageLayer *this, const char *a2)
{
  size_t v2 = a2;
  uint64_t v30 = *MEMORY[0x263EF8340];
  unint64_t v4 = *((void *)this + 1);
  if (!v4)
  {
    size_t v6 = __str;
    size_t v7 = 1023;
LABEL_16:
    snprintf(v6, v7, "<none>");
    goto LABEL_17;
  }
  uint64_t v23 = *((void *)this + 1);
  uint64_t v5 = "{%s";
  size_t v6 = __str;
  size_t v7 = 1023;
  do
  {
    int v8 = __clz(v4);
    char v9 = v8 ^ 0x3F;
    name = (char *)axr_channel_type_get_name((axr_channel_type_t)(v8 ^ 0x3F));
    if (name)
    {
      uint64_t v11 = name;
      int v12 = strstr(name, "axr_channel_type_");
      uint64_t v13 = 17;
      if (v11 != v12) {
        uint64_t v13 = 0;
      }
      int v14 = &v11[v13];
    }
    else
    {
      int v14 = 0;
    }
    int v15 = snprintf(v6, v7, v5, v14);
    if (v15 >= (int)v7) {
      int v16 = v7;
    }
    else {
      int v16 = v15;
    }
    uint64_t v17 = v16 & ~(v16 >> 31);
    v7 -= v17;
    v6 += v17;
    uint64_t v5 = " | %s";
    v4 ^= 1 << v9;
  }
  while (v4);
  if (!v23)
  {
    size_t v2 = a2;
    goto LABEL_16;
  }
  snprintf(v6, v7, "}");
  size_t v2 = a2;
LABEL_17:
  unint64_t v18 = 0;
  int v19 = *((_DWORD *)this + 9);
  unsigned int v20 = v25;
  do
  {
    if (v18 >= *((unsigned int *)this + 12))
    {
      *unsigned int v20 = 0;
    }
    else if (v18)
    {
      snprintf(v20, 6uLL, ", %u");
    }
    else
    {
      snprintf(v25, 6uLL, "%u");
    }
    ++v18;
    v20 += 6;
  }
  while (v18 != 4);
  if ((v19 - 8) >= 0xFFFFFFF7) {
    int v21 = v19 + 1;
  }
  else {
    int v21 = 0;
  }
  return objc_msgSend(NSString, "stringWithFormat:", @"%simage %p \"%s\"\n%s\tchannel types: %s\n%s\tsize:          {w: %u, h: %u}\n%s\ttype:          %s\n%s\tpart index:    %u\n%s\tlayer index:   %u\n%s\tcolorspace:    %s\n%s\txChromaSampl:  %u\n%s\tyChromaSsmpl:  %u\n%s\tchannel count: %u\n%s\tchannels:      {%s%s%s%s}\n", v2, this, (char *)this + 76, v2, __str, v2, *((unsigned int *)this + 4), *((unsigned int *)this + 5), v2, axr_type_get_name((axr_type_t)*((_DWORD *)this + 6)), v2, *((unsigned int *)this + 7), v2, *((unsigned int *)this + 8), v2, off_2648578A8[v21],
           v2,
           *((unsigned int *)this + 10),
           v2,
           *((unsigned int *)this + 11),
           v2,
           *((unsigned int *)this + 12),
           v2,
           v25,
           &v26,
           &v27,
           v28);
}

BOOL AXRImageLayer::IsEqual(AXRImageLayer *this, const AXRImageLayer *a2)
{
  if (!a2) {
    return 0;
  }
  long long v2 = *(_OWORD *)((char *)a2 + 24);
  v7[0] = *(_OWORD *)((char *)a2 + 8);
  v7[1] = v2;
  long long v3 = *(_OWORD *)((char *)a2 + 56);
  v7[2] = *(_OWORD *)((char *)a2 + 40);
  v7[3] = v3;
  unint64_t v4 = (char *)this + 8;
  uint64_t v5 = *((unsigned int *)this + 12);
  if (v5 <= 3) {
    memcpy((char *)&v7[2] + 4 * v5 + 12, (char *)this + 4 * v5 + 52, 4 * (3 - v5) + 4);
  }
  return memcmp(v4, v7, 0x30uLL) == 0;
}

NSObject *AXRImageLayer::CreateDecoder(uint64_t a1, axr_data_t fileData, int a3, unint64_t levelIndex, axr_flags_t flags, double a6)
{
  char v6 = flags;
  uint64_t v17 = axr_decoder_create(fileData, *(unsigned int *)(a1 + 28), levelIndex, flags);
  if (!v17) {
    return v17;
  }
  unint64_t v18 = *(unsigned int *)(a1 + 48);
  if ((v6 & 2) != 0)
  {
    if (v18 <= 3 && (*(unsigned char *)(a1 + 8) & 0x10) != 0) {
      AXRLogDebug((uint64_t)"axr_logical_image_info_create_decoder: channel list already has an alpha channel but alpha parameter is numeric, indicating to add another one.", v10, v11, v12, v13, v14, v15, v16, v24);
    }
    if ((v18 - 2) >= 2)
    {
      if (v18 == 4)
      {
        int v19 = "axr_logical_image_info_create_decoder: channel count = 4. Attempt to add a fifth channel (constant alpha) ignored.";
        goto LABEL_14;
      }
      if (v18 != 1)
      {
        int v19 = "axr_logical_image_info_create_decoder: channel count = lu unsupported by axr_decoder_read_pixels.";
        goto LABEL_14;
      }
      if (a6 == 1.0 && *(void *)(a1 + 8) == 1024)
      {
        int v19 = "axr_logical_image_info_create_decoder memory waste: Adding constant opaque alpha channel to monochrome data";
LABEL_14:
        AXRLogDebug((uint64_t)v19, v10, v11, v12, v13, v14, v15, v16, v24);
      }
    }
  }
  if (!((v18 > 3) | (a3 ^ 1) & 1)
    && axr_decoder_append_constant_value_channel(v17, a6, (axr_type_t)*(_DWORD *)(a1 + 24), axr_channel_type_alpha, axr_flags_default))
  {
    goto LABEL_28;
  }
  if (v18)
  {
    unsigned int v20 = (uint32_t *)(a1 + 52);
    unint64_t v21 = v18;
    while (1)
    {
      uint32_t v22 = *v20++;
      if (axr_decoder_append_channel(v17, v22, axr_flags_default)) {
        goto LABEL_28;
      }
      if (!--v21)
      {
        if (v18 > 3) {
          return v17;
        }
        if (v18 == 2
          && axr_decoder_append_constant_value_channel(v17, 0.0, (axr_type_t)*(_DWORD *)(a1 + 24), axr_channel_type_blue, axr_flags_default))
        {
          goto LABEL_28;
        }
        if ((a3 & 1) == 0) {
          goto LABEL_27;
        }
        return v17;
      }
    }
  }
  if (!((v18 > 3) | a3 & 1))
  {
LABEL_27:
    if (axr_decoder_append_constant_value_channel(v17, a6, (axr_type_t)*(_DWORD *)(a1 + 24), axr_channel_type_alpha, axr_flags_default))
    {
LABEL_28:

      return 0;
    }
  }
  return v17;
}

axr_logical_image_list_t axr_data_create_logical_image_list(axr_data_t data)
{
  if (!data) {
    return 0;
  }
  objc_opt_class();
  uint64_t v2 = _os_object_alloc();
  char v9 = v2;
  if (v2) {
    AXRLogicalImageList::AXRLogicalImageList((void *)(v2 + 16), data, v3, v4, v5, v6, v7, v8);
  }
  return v9;
}

unint64_t axr_logical_image_list_get_view_count(unint64_t list)
{
  if (list) {
    return *(void *)(list + 16);
  }
  return list;
}

uint64_t axr_logical_image_list_get_default_view_index(axr_logical_image_list_t list)
{
  if (!list)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogError((uint64_t)"%s: NULL list provided", v1, v2, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_default_view_index");
  }
  return 0;
}

const char *__cdecl axr_logical_image_list_get_view_name(axr_logical_image_list_t list, unint64_t viewIndex)
{
  if (list)
  {
    if (list[2].isa > (Class)viewIndex)
    {
      axr_logical_image_list_t v8 = list + 3;
      unint64_t v9 = viewIndex + 1;
      do
      {
        axr_logical_image_list_t v8 = (axr_logical_image_list_t)v8->isa;
        --v9;
      }
      while (v9);
      if (v8) {
        return (const char *)&v8[4];
      }
    }
    Class isa = list[4].isa;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | isa) & 2) != 0) {
      AXRLogError((uint64_t)"%s: view index out of bounds", viewIndex, v2, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_view_name");
    }
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogError((uint64_t)"%s: NULL list provided", viewIndex, v2, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_view_name");
  }
  return (const char *)&unk_228F63AF7;
}

unint64_t axr_logical_image_list_get_image_count(axr_logical_image_list_t list, unint64_t viewIndex)
{
  if (list)
  {
    if (list[2].isa > (Class)viewIndex)
    {
      axr_logical_image_list_t v8 = list + 3;
      unint64_t v9 = viewIndex + 1;
      do
      {
        axr_logical_image_list_t v8 = (axr_logical_image_list_t)v8->isa;
        --v9;
      }
      while (v9);
      if (v8) {
        return (unint64_t)v8[1].isa;
      }
    }
    Class isa = list[4].isa;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | isa) & 2) != 0) {
      AXRLogError((uint64_t)"%s: view index out of bounds", viewIndex, v2, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_image_count");
    }
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogError((uint64_t)"%s: NULL list provided", viewIndex, v2, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_image_count");
  }
  return 0;
}

unint64_t axr_logical_image_list_get_default_image_index(axr_logical_image_list_t list, unint64_t viewIndex)
{
  if (list)
  {
    if (list[2].isa > (Class)viewIndex)
    {
      axr_logical_image_list_t v8 = list + 3;
      unint64_t v9 = viewIndex + 1;
      do
      {
        axr_logical_image_list_t v8 = (axr_logical_image_list_t)v8->isa;
        --v9;
      }
      while (v9);
      if (v8) {
        return (unint64_t)v8[2].isa;
      }
    }
    Class isa = list[4].isa;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | isa) & 2) != 0) {
      AXRLogError((uint64_t)"%s: view index out of bounds", viewIndex, v2, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_default_image_index");
    }
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogError((uint64_t)"%s: NULL list provided", viewIndex, v2, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_default_image_index");
  }
  return 0;
}

const char *__cdecl axr_logical_image_list_get_image_name(axr_logical_image_list_t list, unint64_t viewIndex, unint64_t imageIndex)
{
  if (list)
  {
    if (list[2].isa <= (Class)viewIndex) {
      goto LABEL_11;
    }
    axr_logical_image_list_t v8 = list + 3;
    unint64_t v9 = viewIndex + 1;
    do
    {
      axr_logical_image_list_t v8 = (axr_logical_image_list_t)v8->isa;
      --v9;
    }
    while (v9);
    if (v8)
    {
      if (v8[1].isa > (Class)imageIndex)
      {
        axr_logical_image_list_t v10 = v8 + 3;
        unint64_t v11 = imageIndex + 1;
        do
        {
          axr_logical_image_list_t v10 = (axr_logical_image_list_t)v10->isa;
          --v11;
        }
        while (v11);
        if (v10) {
          return (char *)&v10[9].isa + 4;
        }
      }
      Class isa = list[4].isa;
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | isa) & 2) != 0) {
        AXRLogError((uint64_t)"%s: image index out of bounds", viewIndex, imageIndex, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_image_name");
      }
    }
    else
    {
LABEL_11:
      Class v13 = list[4].isa;
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v13) & 2) != 0) {
        AXRLogError((uint64_t)"%s: view index out of bounds", viewIndex, imageIndex, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_image_name");
      }
    }
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogError((uint64_t)"%s: NULL list provided", viewIndex, imageIndex, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_get_image_name");
  }
  return (const char *)&unk_228F63AF7;
}

axr_logical_image_info_t *__cdecl axr_logical_image_list_get_image_info(axr_logical_image_info_t *__return_ptr retstr, axr_logical_image_info_t *list, unint64_t viewIndex, unint64_t imageIndex, axr_logical_image_info_struct_version_t version)
{
  if (list)
  {
    if (*(void *)&list->type <= viewIndex) {
      goto LABEL_11;
    }
    p_layerIndex = &list->layerIndex;
    unint64_t v11 = viewIndex + 1;
    do
    {
      p_layerIndex = *(uint32_t **)p_layerIndex;
      --v11;
    }
    while (v11);
    if (p_layerIndex)
    {
      if (*((void *)p_layerIndex + 1) > imageIndex)
      {
        uint64_t v12 = p_layerIndex + 6;
        unint64_t v13 = imageIndex + 1;
        do
        {
          uint64_t v12 = *(uint32_t **)v12;
          --v13;
        }
        while (v13);
        if (v12)
        {
          long long v14 = *(_OWORD *)(v12 + 6);
          *(_OWORD *)&retstr->channelMask = *(_OWORD *)(v12 + 2);
          *(_OWORD *)&retstr->type = v14;
          long long v15 = *(_OWORD *)(v12 + 14);
          *(_OWORD *)&retstr->xChromaSampling = *(_OWORD *)(v12 + 10);
          *(_OWORD *)&retstr->channels[1] = v15;
          return list;
        }
      }
      uint64_t v17 = *(void *)&list->xChromaSampling;
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v17) & 2) != 0) {
        AXRLogError((uint64_t)"%s: image index out of bounds", viewIndex, imageIndex, *(uint64_t *)&version, v5, v6, v7, v8, (char)"axr_logical_image_list_get_image_info");
      }
    }
    else
    {
LABEL_11:
      uint64_t v16 = *(void *)&list->xChromaSampling;
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v16) & 2) != 0) {
        AXRLogError((uint64_t)"%s: view index out of bounds", viewIndex, imageIndex, *(uint64_t *)&version, v5, v6, v7, v8, (char)"axr_logical_image_list_get_image_info");
      }
    }
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogError((uint64_t)"%s: NULL list provided", viewIndex, imageIndex, *(uint64_t *)&version, v5, v6, v7, v8, (char)"axr_logical_image_list_get_image_info");
  }
  *(_OWORD *)&retstr->xChromaSampling = 0u;
  *(_OWORD *)&retstr->channels[1] = 0u;
  *(_OWORD *)&retstr->channelMask = 0u;
  *(_OWORD *)&retstr->type = 0u;
  return list;
}

axr_decoder_t axr_logical_image_list_create_decoder(axr_logical_image_list_t list, axr_data_t data, unint64_t viewIndex, unint64_t imageIndex, double alpha, BOOL isAlphaFirst, unint64_t levelIndex, axr_flags_t flags)
{
  int v9 = flags;
  if (!list)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v9) & 2) != 0) {
      AXRLogError((uint64_t)"%s: NULL list provided", (uint64_t)data, viewIndex, imageIndex, isAlphaFirst, levelIndex, flags, v8, (char)"axr_logical_image_list_create_decoder");
    }
    return 0;
  }
  if (list[2].isa <= (Class)viewIndex) {
    goto LABEL_13;
  }
  axr_logical_image_list_t v10 = list + 3;
  unint64_t v11 = viewIndex + 1;
  do
  {
    axr_logical_image_list_t v10 = (axr_logical_image_list_t)v10->isa;
    --v11;
  }
  while (v11);
  if (!v10)
  {
LABEL_13:
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v9) & 2) != 0) {
      AXRLogError((uint64_t)"%s: view index out of bounds", (uint64_t)data, viewIndex, imageIndex, isAlphaFirst, levelIndex, flags, v8, (char)"axr_logical_image_list_create_decoder");
    }
    return 0;
  }
  if (v10[1].isa <= (Class)imageIndex) {
    goto LABEL_17;
  }
  uint64_t v12 = v10 + 3;
  unint64_t v13 = imageIndex + 1;
  do
  {
    uint64_t v12 = v12->isa;
    --v13;
  }
  while (v13);
  if (!v12)
  {
LABEL_17:
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v9) & 2) != 0) {
      AXRLogError((uint64_t)"%s: image index out of bounds", (uint64_t)data, viewIndex, imageIndex, isAlphaFirst, levelIndex, flags, v8, (char)"axr_logical_image_list_create_decoder");
    }
    return 0;
  }

  return AXRImageLayer::CreateDecoder((uint64_t)v12, data, isAlphaFirst, levelIndex, flags, alpha);
}

BOOL axr_logical_image_list_is_equal(axr_logical_image_list_t list, axr_logical_image_list_t list2)
{
  return list
      && list2
      && AXRLogicalImageList::IsEqual((AXRLogicalImageList *)&list[2], (const AXRLogicalImageList *)&list2[2]);
}

size_t axr_logical_image_list_get_serialized_size(axr_logical_image_list_t list)
{
  if (!list) {
    return 0;
  }
  Class isa = list[3].isa;
  if (!isa) {
    return 16;
  }
  size_t v2 = 16;
  do
  {
    v2 += AXRImageGroup::GetSerializedSize(isa);
    Class isa = *(AXRImageGroup **)isa;
  }
  while (isa);
  return v2;
}

size_t axr_logical_image_list_serialize(axr_logical_image_list_t list, void *where, size_t size)
{
  if (!list) {
    return size;
  }
  if (!where)
  {
    Class isa = list[4].isa;
    if (GetFlagsOnceToken != -1)
    {
      Class v16 = list[4].isa;
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      LODWORD(isa) = v16;
    }
    if (((kDefaultAXRLogFlags | isa) & 2) != 0) {
      AXRLogError((uint64_t)"%s: error where = NULL", (uint64_t)where, size, v3, v4, v5, v6, v7, (char)"axr_logical_image_list_serialize");
    }
    return size;
  }
  size_t v9 = size - 4;
  if (size < 4) {
    return size;
  }
  *(_DWORD *)where = 1920496243;
  if (v9 >= 4)
  {
    *((_DWORD *)where + 1) = 0x1000000;
    size_t v9 = size - 8;
    if (size - 8 >= 8)
    {
      Class v11 = list[2].isa;
      Class v10 = list[3].isa;
      *((void *)where + 1) = bswap64((unint64_t)v11);
      unint64_t v17 = size - 16;
      unint64_t v18 = (char *)where + 16;
      do
      {
        if (!v10) {
          break;
        }
        uint64_t v12 = *(objc_class **)v10;
        BOOL v13 = AXRImageGroup::Serialize(v10, &v18, &v17);
        Class v10 = v12;
      }
      while (v13);
      return v17;
    }
  }
  return v9;
}

axr_logical_image_list_t axr_logical_image_list_deserialize(const void **where, size_t *size, axr_error_t *outErr, axr_flags_t flags)
{
  if (!where || !*where)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
      AXRLogError((uint64_t)"%s: error NULL data pointer", (uint64_t)size, (uint64_t)outErr, flags, v4, v5, v6, v7, (char)"axr_logical_image_list_deserialize");
    }
    return 0;
  }
  if (!size)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
      AXRLogError((uint64_t)"%s: error NULL size", (uint64_t)size, (uint64_t)outErr, flags, v4, v5, v6, v7, (char)"axr_logical_image_list_deserialize");
    }
    return 0;
  }
  objc_opt_class();
  uint64_t v12 = _os_object_alloc();
  Class v16 = v12;
  if (v12)
  {
    axr_error_t v18 = axr_error_success;
    AXRLogicalImageList::AXRLogicalImageList((AXRLogicalImageList *)(v12 + 16), where, (const void **)size, &v18, flags, v13, v14, v15);
    if (v18)
    {

      Class v16 = 0;
      if (outErr) {
        *outErr = v18;
      }
    }
  }
  return v16;
}

uint64_t AXRData::GetLayerInfo@<X0>(AXRData *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, void *a9@<X8>)
{
  uint64_t v9 = *((void *)this + 9);
  if (a2 && v9)
  {
    unint64_t v10 = 1;
    do
    {
      uint64_t v9 = *(void *)(v9 + 8);
      if (v10 >= a2) {
        break;
      }
      ++v10;
    }
    while (v9);
  }
  if (!v9) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }

  return Part::GetLayerInfo(v9, a3, a9);
}

char *AXRData::GetChannelInfo@<X0>(AXRData *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v9 = (Part *)*((void *)this + 9);
  if (a2 && v9)
  {
    unint64_t v10 = 1;
    do
    {
      uint64_t v9 = (Part *)*((void *)v9 + 1);
      if (v10 >= a2) {
        break;
      }
      ++v10;
    }
    while (v9);
  }
  if (!v9) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  Class v11 = (const char *)*((void *)this + 1);
  uint64_t v12 = *((void *)this + 3);

  return Part::GetChannelInfo(v9, v11, v12, a3, a5, a6, a7, a8, a9);
}

float AXRData::GetImageInfo@<S0>(AXRData *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v9 = (Part *)*((void *)this + 9);
  if (a2 && v9)
  {
    unint64_t v10 = 1;
    do
    {
      uint64_t v9 = (Part *)*((void *)v9 + 1);
      if (v10 >= a2) {
        break;
      }
      ++v10;
    }
    while (v9);
  }
  if (!v9) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  Class v11 = (char *)*((void *)this + 1);

  return Part::GetImageInfo(v9, v11, a9);
}

uint64_t AXRData::HasLongNames(AXRData *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *((void *)this + 9);
  if (a2 && v8)
  {
    unint64_t v9 = 1;
    do
    {
      uint64_t v8 = *(void *)(v8 + 8);
      if (v9 >= a2) {
        break;
      }
      ++v9;
    }
    while (v8);
  }
  if (!v8) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(unsigned __int8 *)(v8 + 301);
}

uint64_t *AXRData::GetImageProperty@<X0>(AXRData *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, char **a9@<X8>)
{
  unint64_t v9 = (Part *)*((void *)this + 9);
  if (a2 && v9)
  {
    unint64_t v10 = 1;
    do
    {
      unint64_t v9 = (Part *)*((void *)v9 + 1);
      if (v10 >= a2) {
        break;
      }
      ++v10;
    }
    while (v9);
  }
  if (!v9) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  Class v11 = (char *)*((void *)this + 1);
  uint64_t v12 = *((void *)this + 3);

  return Part::GetImageProperty(v9, v11, v12, a3, a5, a6, a7, a8, a9);
}

void AXRLogicalImageList::~AXRLogicalImageList(AXRLogicalImageList *this)
{
  uint64_t v1 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  if (v1)
  {
    do
    {
      size_t v2 = (void *)*v1;
      while (1)
      {
        uint64_t v3 = (void *)v1[3];
        if (!v3) {
          break;
        }
        v1[3] = *v3;
        MEMORY[0x22A6AD870]();
      }
      free(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t ChannelDescription::Print(ChannelDescription *this, char *a2, size_t a3, char *a4, axr_flags_t a5)
{
  uint64_t v8 = &a4[*(void *)this];
  name = axr_channel_type_get_name((axr_channel_type_t)*((_DWORD *)this + 32));
  unint64_t v10 = axr_type_get_name((axr_type_t)*((_DWORD *)this + 18));
  if (*((unsigned char *)this + 132)) {
    Class v11 = "YES";
  }
  else {
    Class v11 = "NO";
  }
  int v12 = 32;
  if (*((_DWORD *)this + 18) == 1) {
    int v12 = 16;
  }
  return snprintf(a2, a3, "\t\tname:         \"%s\"\n\t\tchannel type: %s\n\t\tpixel type:   %s\n\t\tchannel bits: %u\n\t\tx sampling:   %d\n\t\ty sampling:   %d\n\t\tis linear:    %s\n", v8, name, v10, v12, *((_DWORD *)this + 20), *((_DWORD *)this + 26), v11);
}

uint64_t ChannelDescription::ConfigureChannelType(uint64_t a1, char *__s1, size_t a3, void *a4)
{
  size_t v5 = a3;
  size_t v8 = a3 + 1;
  uint64_t v9 = 1;
  unint64_t v10 = __s1;
  uint64_t v11 = 1;
  while (a3 != v9)
  {
    --v11;
    int v12 = v10[a3 - 1];
    --v8;
    --v10;
    ++v9;
    if (v12 == 46)
    {
      BOOL v13 = &v10[a3 + 1];
      size_t v14 = v11 - (v8 != 0) + a3;
      size_t v5 = v9 - 2;
      goto LABEL_6;
    }
  }
  size_t v14 = 0;
  BOOL v13 = __s1;
LABEL_6:
  uint64_t v15 = (void *)*a4;
  if (*a4)
  {
    while (v15[2] != v14 || strncmp(__s1, (const char *)v15[1], v14))
    {
      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    Class v16 = malloc_type_calloc(1uLL, v14 + 41, 0xEDB7643DuLL);
    uint64_t v15 = v16;
    if (v16)
    {
      v16[1] = v16 + 5;
      v16[2] = v14;
      memcpy(v16 + 5, __s1, v14);
    }
    *uint64_t v15 = *a4;
    *a4 = v15;
  }
  uint64_t v17 = 0;
  uint64_t v18 = v15[4];
  *(void *)(a1 + 16) = v15[3];
  v15[3] = a1;
  v15[4] = v18 + 1;
  while (1)
  {
    uint64_t result = strncasecmp(v13, (&ChannelDescription::ConfigureChannelType(char const*,unsigned long,Layer *&)::kColorList)[v17], v5);
    if (!result) {
      break;
    }
    v17 += 2;
    if (v17 == 54) {
      return result;
    }
  }
  *(_DWORD *)(a1 + 128) = (&ChannelDescription::ConfigureChannelType(char const*,unsigned long,Layer *&)::kColorList)[v17 + 1];
  return result;
}

uint64_t ChannelDescription::IdentifyChannels(uint64_t a1, uint64_t a2)
{
  *(int32x2_t *)v2.f32 = vrev64_s32(*(int32x2_t *)a2);
  v2.i32[2] = *(_DWORD *)(a2 + 8);
  v2.i32[3] = *(_DWORD *)(a2 + 16);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v2, (float32x4_t)xmmword_228F628A0)))) & 1) == 0
    && *(float *)(a2 + 20) == 1.0
    && *(float *)(a2 + 24) == 0.0
    && fabsf((float)(*(float *)(a2 + 12) * 3.0) + -1.0) <= 0.001
    && fabsf((float)(*(float *)(a2 + 28) * 3.0) + -1.0) <= 0.001)
  {
    int v3 = *(_DWORD *)(a1 + 128) - 1;
    if (v3 <= 2) {
      *(_DWORD *)(a1 + 128) = dword_228F628B4[v3];
    }
  }
  return 0;
}

void ChannelDescription::ParseChList(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, _DWORD *a8, uint64_t *a9)
{
  unint64_t v10 = a7;
  unint64_t v13 = a3;
  Class v16 = a9;
  *a9 = 0;
  uint64_t v17 = *a7;
  if (*a7)
  {
    do
    {
      uint64_t v18 = v17;
      uint64_t v17 = *(void *)(v17 + 8);
    }
    while (v17);
  }
  else
  {
    uint64_t v18 = 0;
  }
  if (a3 >= 2)
  {
    while (1)
    {
      int v19 = (char *)(a2 + a1);
      size_t v20 = strnlen((const char *)(a2 + a1), v13 - 1);
      if (!v20) {
        return;
      }
      uint64_t v28 = 0;
      size_t v29 = v20 + 1;
      do
      {
        if (v19[v28] < 32) {
          return;
        }
        ++v28;
      }
      while (v20 != v28);
      BOOL v30 = v13 - v29 >= 0x10;
      unint64_t v13 = v13 - v29 - 16;
      if (!v30) {
        break;
      }
      long long v50 = a6;
      unint64_t v51 = v10;
      uint64_t v52 = a8;
      size_t v31 = v29 + a2;
      uint64_t v49 = a1;
      size_t v32 = v29 + a2 + a1;
      unsigned int v33 = *(_DWORD *)v32;
      unsigned int v34 = *(_DWORD *)(v32 + 8);
      unsigned int v35 = *(_DWORD *)(v32 + 12);
      if (*(_DWORD *)v32 > 2u || v34 == 0 || v35 == 0)
      {
        if (v33 < 3)
        {
          if (v34)
          {
            if (!v35)
            {
              if (GetFlagsOnceToken != -1) {
                dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
              }
              if (((kDefaultAXRLogFlags | a4) & 2) != 0)
              {
                uint64_t v44 = "Error: y sampling rate for channel must be at least 1";
                goto LABEL_40;
              }
            }
          }
          else
          {
            if (GetFlagsOnceToken != -1) {
              dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
            }
            if (((kDefaultAXRLogFlags | a4) & 2) != 0)
            {
              uint64_t v44 = "Error: x sampling rate for channel must be at least 1";
              goto LABEL_40;
            }
          }
        }
        else
        {
          if (GetFlagsOnceToken != -1) {
            dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
          }
          if (((kDefaultAXRLogFlags | a4) & 2) != 0)
          {
            uint64_t v44 = "Error: channel has unknown data type";
            goto LABEL_40;
          }
        }
LABEL_41:
        uint64_t v43 = -6;
LABEL_43:
        uint64_t *v16 = v43;
        return;
      }
      if (v34 >= 0xD0A7)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | a4) & 2) != 0) {
          AXRLogDebug((uint64_t)"Error: x sampling rate for channel is ridiculously large at %d", v21, v22, v23, v24, v25, v26, v27, v34);
        }
        goto LABEL_41;
      }
      if (v35 >= 0xD0A7)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | a4) & 2) == 0) {
          goto LABEL_41;
        }
        char v45 = v35;
        uint64_t v44 = "Error: y sampling rate for channel is ridiculously large at %d";
LABEL_40:
        AXRLogDebug((uint64_t)v44, v21, v22, v23, v24, v25, v26, v27, v45);
        goto LABEL_41;
      }
      size_t v46 = v20 + 1;
      uint64_t v47 = a4;
      unint64_t v48 = v16;
      int v38 = *(unsigned __int8 *)(v32 + 4);
      size_t v39 = ChannelDescription::operator new(0x88uLL);
      if (!v39)
      {
        uint64_t v43 = -5;
        goto LABEL_43;
      }
      uint64_t v40 = (uint64_t)v39;
      int v41 = *v52;
      *(void *)size_t v39 = a2;
      v39[6] = v41;
      v39[18] = v33;
      SamplingRate::SamplingRate((SamplingRate *)(v39 + 20), v34);
      SamplingRate::SamplingRate((SamplingRate *)(v40 + 104), v35);
      a2 = v31 + 16;
      *(unsigned char *)(v40 + 132) = v38 != 0;
      a6 = v50;
      ChannelDescription::ConfigureChannelType(v40, v19, v46, v50);
      unint64_t v10 = v51;
      a8 = v52;
      if (*v51) {
        uint64_t v42 = (uint64_t *)(v18 + 8);
      }
      else {
        uint64_t v42 = v51;
      }
      *uint64_t v42 = v40;
      ++*v52;
      uint64_t v18 = v40;
      a4 = v47;
      Class v16 = v48;
      a1 = v49;
      if (v13 <= 1) {
        return;
      }
    }
    uint64_t v43 = -4;
    goto LABEL_43;
  }
}

void sub_228F23F08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *ChannelDescription::operator new(size_t size)
{
  return malloc_type_calloc(1uLL, size, 0xF1296FFDuLL);
}

char *ChannelDescription::GetChannelInfo@<X0>(ChannelDescription *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *((_DWORD *)this + 18);
  int v5 = *((_DWORD *)this + 32);
  *(_DWORD *)a3 = v4;
  *(_DWORD *)(a3 + 4) = v5;
  if (v4 == 1) {
    int v6 = 16;
  }
  else {
    int v6 = 32;
  }
  int v7 = *((_DWORD *)this + 20);
  *(_DWORD *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 12) = v7;
  *(_DWORD *)(a3 + 16) = *((_DWORD *)this + 26);
  *(_DWORD *)(a3 + 20) = 0;
  *(unsigned char *)(a3 + 20) = *((unsigned char *)this + 132);
  uint64_t result = strncpy((char *)(a3 + 24), &a2[*(void *)this], 0x100uLL);
  *(unsigned char *)(a3 + 279) = 0;
  return result;
}

uint64_t ChannelDescription::CreateMipLevels(ChannelDescription *this, const void *a2, const Part *a3, unint64_t a4, axr_level_mode_t a5)
{
  if (*((void *)this + 5)) {
    return 0;
  }
  unsigned __int8 v6 = a5;
  uint32_t v7 = a4;
  unint64_t v9 = *(void *)((char *)a3 + 156);
  unint64_t v10 = HIDWORD(v9);
  LODWORD(v11) = (*((void *)this + 12) + v9 * (unint64_t)*((unsigned int *)this + 21)) >> *((_DWORD *)this + 22);
  HIDWORD(v11) = (*((void *)this + 15) + HIDWORD(v9) * (unint64_t)*((unsigned int *)this + 27)) >> *((_DWORD *)this + 28);
  *((void *)this + 6) = v11;
  uint32_t v12 = HIDWORD(a4);
  unsigned __int32 v45 = a5 & 0xF;
  if ((a5 & 0xF) != 0)
  {
    unsigned __int32 v32 = a5 & 0xF0;
    unint64_t v33 = 63 - __clz(a4);
    if (!a4) {
      LODWORD(v33) = 0;
    }
    unint64_t v34 = 63 - __clz(HIDWORD(a4));
    if (!HIDWORD(a4)) {
      LODWORD(v34) = 0;
    }
    unint64_t v35 = 64 - __clz(a4 - 1);
    if (a4 <= 1uLL) {
      int v36 = 0;
    }
    else {
      int v36 = v35;
    }
    unint64_t v37 = 64 - __clz(HIDWORD(a4) - 1);
    if (a4 >> 33) {
      int v38 = v37;
    }
    else {
      int v38 = 0;
    }
    BOOL v39 = v32 == 16;
    if (v32 == 16) {
      int v40 = v36;
    }
    else {
      int v40 = v33;
    }
    if (v39) {
      int v41 = v38;
    }
    else {
      int v41 = v34;
    }
    if (v40 + 1 <= (v41 + 1)) {
      unsigned int v42 = v41 + 1;
    }
    else {
      unsigned int v42 = v40 + 1;
    }
    if (v45 == 1) {
      uint64_t v43 = v42;
    }
    else {
      uint64_t v43 = (v40 + 1);
    }
    if (v45 == 1) {
      uint64_t v44 = 1;
    }
    else {
      uint64_t v44 = (v41 + 1);
    }
    uint64_t v13 = v43 | (v44 << 32);
  }
  else
  {
    uint64_t v13 = 0x100000001;
  }
  *(void *)((char *)this + 28) = v13;
  uint64_t result = (uint64_t)malloc_type_calloc((v13 * HIDWORD(v13)), 8uLL, 0x2004093837F09uLL);
  *((void *)this + 5) = result;
  if (result)
  {
    unsigned int v14 = *((_DWORD *)this + 8);
    if (!v14) {
      return 0;
    }
    int v15 = 0;
    int v16 = v6 >> 4;
    uint32_t v17 = v7 - v16;
    uint32_t v18 = v12 - v16;
    if (v9 <= 1) {
      LODWORD(v9) = 1;
    }
    int v19 = v9 - 1;
    if (v10 <= 1) {
      LODWORD(v10) = 1;
    }
    int v20 = v10 - 1;
    unsigned int v21 = *((_DWORD *)this + 7);
    while (!v21)
    {
LABEL_32:
      uint64_t result = 0;
      if (++v15 >= v14) {
        return result;
      }
    }
    int v22 = 0;
    while (1)
    {
      char v23 = v45 == 2 ? v15 : v22;
      unsigned int v24 = (v17 + (v16 << v22)) >> v22;
      uint64_t v25 = v24 <= 1 ? 1 : v24;
      LODWORD(v26) = (v18 + (v16 << v23)) >> v23;
      uint64_t v26 = v26 <= 1 ? 1 : v26;
      unsigned int v27 = v19 + v25;
      unsigned int v28 = __CFADD__(v19, v25)
          ? (v27 - 0xFFFFFFFF / v9 * v9) / v9 + 0xFFFFFFFF / v9
          : v27 / v9;
      unsigned int v29 = v20 + v26;
      uint64_t v30 = v20 + (int)v26 < v26
          ? (v29 - 0xFFFFFFFF / v10 * v10) / v10 + 0xFFFFFFFF / v10
          : v29 / v10;
      uint64_t result = (uint64_t)DecompressedLocations::CreateDecompressedLocations(result, v28 | (unint64_t)(v30 << 32), v25 | (v26 << 32), ((*((void *)this + 12)+ *((unsigned int *)this + 21) * (unint64_t)v25) >> *((_DWORD *)this + 22)) | ((unint64_t)((*((void *)this + 15) + *((unsigned int *)this + 27) * (unint64_t)v26) >> *((_DWORD *)this + 28)) << 32));
      unsigned int v21 = *((_DWORD *)this + 7);
      unsigned int v31 = v22 + v15 * v21;
      *(void *)(*((void *)this + 5) + 8 * v31) = result;
      if (!*(void *)(*((void *)this + 5) + 8 * v31)) {
        break;
      }
      if (++v22 >= v21)
      {
        unsigned int v14 = *((_DWORD *)this + 8);
        goto LABEL_32;
      }
    }
  }
  return -5;
}

void *DecompressedLocations::CreateDecompressedLocations(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = a2;
  uint64_t v8 = (a3 >> 29) & 0x7FFFFFFF8;
  uint64_t v9 = 8 * a2 + 24;
  uint64_t result = malloc_type_malloc(v9 + v8 * a2, 0x37A62826uLL);
  if (result)
  {
    result[1] = a3;
    result[2] = a4;
    *uint64_t result = a2;
    if (v7)
    {
      uint64_t v11 = (char *)result + v9;
      uint32_t v12 = result + 3;
      do
      {
        *v12++ = v11;
        v11 += v8;
        --v7;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t ChannelDescription::CopyName(void *a1, uint64_t a2, char *__str, size_t __size)
{
  return snprintf(__str, __size, "%s", (const char *)(*a1 + *(void *)(a2 + 8)));
}

void __clang_call_terminate(void *a1)
{
}

void SamplingRate::SamplingRate(SamplingRate *this, unsigned int a2)
{
  unint64_t v2 = a2 - 1;
  unint64_t v3 = 64 - __clz(v2);
  if (a2 <= 1) {
    LODWORD(v3) = 0;
  }
  int v4 = v3 + 31;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = (v2 + (1 << v4)) / a2;
  *((_DWORD *)this + 2) = v4;
  *((void *)this + 2) = ~(-1 << v4);
}

void AXRData::~AXRData(AXRData *this)
{
  *(void *)this = &unk_26DD4C1A8;
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    (*(void (**)(uint64_t, void, void))(v2 + 16))(v2, *((void *)this + 1), *((void *)this + 2));
    _Block_release(*((const void **)this + 4));
    *((void *)this + 4) = 0;
  }
  unint64_t v3 = (Part *)*((void *)this + 9);
  if (v3)
  {
    do
    {
      int v4 = (Part *)*((void *)v3 + 1);
      Part::~Part(v3);
      free(v5);
      unint64_t v3 = v4;
    }
    while (v4);
  }
}

{
  uint64_t vars8;

  AXRData::~AXRData(this);

  JUMPOUT(0x22A6AD870);
}

void Part::Destroy(Part *this)
{
  Part::~Part(this);

  free(v1);
}

size_t AXRData::DebugDescription(AXRData *this, char *a2)
{
  uint64_t v2 = MEMORY[0x270FA5388](this, a2);
  size_t v4 = v3;
  unsigned __int8 v6 = v5;
  uint64_t v7 = v2;
  uint64_t v19 = *MEMORY[0x263EF8340];
  axr_flags_get_name(buf, 0x2000uLL, *(axr_flags_t *)(v2 + 24));
  uint64_t v8 = *(_DWORD **)(v7 + 8);
  int v9 = v8[1];
  unint64_t v10 = "YES";
  if ((v9 & 0x400) != 0) {
    uint64_t v11 = "YES";
  }
  else {
    uint64_t v11 = "NO";
  }
  if ((v9 & 0x800) != 0) {
    uint32_t v12 = "YES";
  }
  else {
    uint32_t v12 = "NO";
  }
  if ((v9 & 0x1000) == 0) {
    unint64_t v10 = "NO";
  }
  size_t v13 = snprintf(v6, v4, "fileData:        %p\nfile size:       %lu bytes\ncreation flags:  %s\ndata destructor: %p\nfile version:    %u\nlong names:      %s\nnon-image parts: %s\nmultipart file:  %s\nreserved bits:   0x%8.8x  (should be 0)\npart count:      %lu\n", v8, *(void *)(v7 + 16), buf, *(const void **)(v7 + 32), v8[1], v11, v12,
          v10,
          v9 & 0xFFFFE100,
          *(void *)(v7 + 80));
  if (v13 < v4)
  {
    if (*(void *)(v7 + 80))
    {
      uint64_t v14 = 0;
      int v15 = (Part **)(v7 + 72);
      while (v4 > v13)
      {
        int v16 = *v15;
        if (!*v15) {
          break;
        }
        v13 += snprintf(&v6[v13], v4 - v13, "\nPart %lu:\n", v14);
        if (v4 <= v13) {
          break;
        }
        v13 += Part::Print(v16, &v6[v13], v4 - v13, *(char **)(v7 + 8), 2uLL);
        int v15 = (Part **)((char *)v16 + 8);
        if ((unint64_t)++v14 >= *(void *)(v7 + 80)) {
          goto LABEL_16;
        }
      }
    }
    else
    {
LABEL_16:
      if (v4 > v13) {
        v13 += snprintf(&v6[v13], v4 - v13, "\n");
      }
    }
  }
  return v13;
}

BOOL AXRData::IsEqual(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 8) == *(void *)(a2 + 8);
}

double AXRData::GetHash(AXRData *this)
{
  int64x2_t v1 = (int64x2_t)veorq_s8(*(int8x16_t *)((char *)this + 56), *(int8x16_t *)((char *)this + 40));
  *(void *)&double result = veorq_s8((int8x16_t)vdupq_laneq_s64(v1, 1), (int8x16_t)v1).u64[0];
  return result;
}

void *AXRData::AXRData(void *a1, char *a2, unint64_t a3, unint64_t a4, void *aBlock)
{
  *a1 = &unk_26DD4C1A8;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = 0;
  if (aBlock) {
    a1[4] = _Block_copy(aBlock);
  }
  int v9 = 0;
  unint64_t v20 = 8;
  unint64_t v10 = (Part **)(a1 + 9);
  while (1)
  {
    if (v20 >= a3) {
      goto LABEL_14;
    }
    if ((a2[5] & 0x10) != 0 && !*(unsigned char *)(v20 + a1[1])) {
      break;
    }
    uint64_t v11 = (Part *)Part::operator new(0x130uLL);
    if (!v11) {
      goto LABEL_14;
    }
    uint32_t v12 = v11;
    uint64_t v13 = Part::Init(v11, a2, a3, &v20, (axr_flags_t)a4);
    if (v13)
    {
      uint64_t v18 = v13;
      Part::Destroy(v12);
      goto LABEL_20;
    }
    uint64_t v14 = (Part **)((char *)v9 + 8);
    if (!v9) {
      uint64_t v14 = (Part **)(a1 + 9);
    }
    *uint64_t v14 = v12;
    ++a1[10];
    int v9 = v12;
    if ((a2[5] & 0x10) == 0) {
      goto LABEL_14;
    }
  }
  ++v20;
LABEL_14:
  int v15 = *v10;
  if (*v10)
  {
    while (1)
    {
      uint64_t inited = Part::InitOffsets(v15, (unsigned int *)a2, a3, &v20, a4);
      if (inited) {
        break;
      }
      int v15 = (Part *)*((void *)v15 + 1);
      if (!v15) {
        return a1;
      }
    }
    uint64_t v18 = inited;
LABEL_20:
    exception = __cxa_allocate_exception(8uLL);
    void *exception = v18;
  }
  return a1;
}

void *Part::operator new(size_t size)
{
  return malloc_type_calloc(1uLL, size, 0x57DCBC97uLL);
}

axr_error_t AXRData::ReadPixels(AXRData *this, axr_decoder *a2, unsigned char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *((unsigned int *)a2 + 10);
  int v9 = (Part *)*((void *)this + 9);
  if (v8) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    unint64_t v11 = 1;
    do
    {
      int v9 = (Part *)*((void *)v9 + 1);
      if (v11 >= v8) {
        break;
      }
      ++v11;
    }
    while (v9);
  }
  if (!v9) {
    AXRData::GetChannelCount((uint64_t)this, *((unsigned int *)a2 + 10), (uint64_t)a3, a4, a5, a6, a7, a8);
  }

  return Part::ReadPixels(v9, a2, a3, a4, a5, a6, a7, a8);
}

void AXRData::GetReadPixelsInfo(AXRData *this@<X0>, axr_decoder *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  unint64_t v9 = *((unsigned int *)a2 + 10);
  uint64_t v10 = *((void *)this + 9);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    unint64_t v12 = 1;
    do
    {
      uint64_t v10 = *(void *)(v10 + 8);
      if (v12 >= v9) {
        break;
      }
      ++v12;
    }
    while (v10);
  }
  if (!v10) {
    AXRData::GetChannelCount((uint64_t)this, *((unsigned int *)a2 + 10), a3, a4, a5, a6, a7, a8);
  }

  Part::GetReadPixelsInfo(a2, a9);
}

uint64_t AXRData::ReadRGBAPixels(AXRData *this, axr_decoder *a2, void *a3, unint64_t a4, double a5, unint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v9 = *((unsigned int *)a2 + 10);
  uint64_t v10 = (Part *)*((void *)this + 9);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    unint64_t v12 = 1;
    do
    {
      uint64_t v10 = (Part *)*((void *)v10 + 1);
      if (v12 >= v9) {
        break;
      }
      ++v12;
    }
    while (v10);
  }
  if (!v10) {
    AXRData::GetChannelCount((uint64_t)this, *((unsigned int *)a2 + 10), (uint64_t)a3, a4, a6, a7, a8, a9);
  }

  return Part::ReadRGBAPixels(v10, a2, a3, a4, a5, (axr_flags_t)a6);
}

void AXRData::GetReadRGBAPixelsInfo(AXRData *this@<X0>, axr_decoder *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  unint64_t v10 = *((unsigned int *)a2 + 10);
  uint64_t v11 = *((void *)this + 9);
  if (v10) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    unint64_t v13 = 1;
    do
    {
      uint64_t v11 = *(void *)(v11 + 8);
      if (v13 >= v10) {
        break;
      }
      ++v13;
    }
    while (v11);
  }
  if (!v11) {
    AXRData::GetChannelCount((uint64_t)this, *((unsigned int *)a2 + 10), a3, a4, a5, a6, a7, a8);
  }

  Part::GetReadRGBAPixelsInfo(a2, a9);
}

unint64_t AXRData::ReadPlanes(AXRData *this, axr_decoder *a2, axr_pixel_data_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, axr_error_t a12, void (**a13)(void), uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  unint64_t v40 = *((unsigned int *)a2 + 10);
  int v41 = (Part *)*((void *)this + 9);
  if (v40) {
    BOOL v42 = v41 == 0;
  }
  else {
    BOOL v42 = 1;
  }
  if (!v42)
  {
    unint64_t v43 = 1;
    do
    {
      int v41 = (Part *)*((void *)v41 + 1);
      if (v43 >= v40) {
        break;
      }
      ++v43;
    }
    while (v41);
  }
  if (!v41) {
    AXRData::GetChannelCount((uint64_t)this, *((unsigned int *)a2 + 10), (uint64_t)a3, a4, a5, a6, a7, a8);
  }

  return Part::ReadPlanes(v41, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40);
}

void AXRData::GetReadPlanesInfo(AXRData *this@<X0>, axr_decoder *a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X2>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  unint64_t v9 = *((unsigned int *)a2 + 10);
  uint64_t v10 = *((void *)this + 9);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    unint64_t v12 = 1;
    do
    {
      uint64_t v10 = *(void *)(v10 + 8);
      if (v12 >= v9) {
        break;
      }
      ++v12;
    }
    while (v10);
  }
  if (!v10) {
    AXRData::GetChannelCount((uint64_t)this, *((unsigned int *)a2 + 10), a4, a3, a5, a6, a7, a8);
  }

  Part::GetReadPlanesInfo(a2, a4, a9);
}

unint64_t axr_data_get_part_count(unint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

unint64_t axr_data_get_channel_count(unint64_t fileData, unint64_t partIndex)
{
  if (fileData) {
    return AXRData::GetChannelCount((AXRData *)(fileData + 16), partIndex, v2, v3, v4, v5, v6, v7);
  }
  return fileData;
}

axr_channel_info_t *__cdecl axr_data_get_channel_info(axr_channel_info_t *__return_ptr retstr, axr_channel_info_t *fileData, unint64_t partIndex, unint64_t channelIndex, axr_channel_info_struct_version_t version)
{
  if ((int)version >= 2) {
    axr_data_get_channel_info_cold_1((uint64_t)fileData, partIndex, channelIndex, *(uint64_t *)&version, v5, v6, v7, v8);
  }
  if (fileData)
  {
    p_ySampling = &fileData->ySampling;
    return (axr_channel_info_t *)AXRData::GetChannelInfo((AXRData *)p_ySampling, partIndex, channelIndex, *(uint64_t *)&version, v5, v6, v7, v8, (uint64_t)retstr);
  }
  else
  {
    *(_DWORD *)&retstr->name[252] = 0;
    *(_OWORD *)&retstr->name[220] = 0u;
    *(_OWORD *)&retstr->name[204] = 0u;
    *(_OWORD *)&retstr->name[188] = 0u;
    *(_OWORD *)&retstr->name[172] = 0u;
    *(_OWORD *)&retstr->name[156] = 0u;
    *(_OWORD *)&retstr->name[140] = 0u;
    *(_OWORD *)&retstr->name[124] = 0u;
    *(_OWORD *)&retstr->name[108] = 0u;
    *(_OWORD *)&retstr->name[92] = 0u;
    *(_OWORD *)&retstr->name[76] = 0u;
    *(_OWORD *)&retstr->name[60] = 0u;
    *(_OWORD *)&retstr->name[44] = 0u;
    *(_OWORD *)&retstr->name[28] = 0u;
    *(_OWORD *)&retstr->name[12] = 0u;
    *(_OWORD *)&retstr->pLinear = 0u;
    *(_OWORD *)&retstr->channelType = 0u;
    *(_OWORD *)&retstr->name[236] = 0u;
    retstr->sampleType = -1;
  }
  return fileData;
}

axr_part_info_t *__cdecl axr_data_get_part_info(axr_part_info_t *__return_ptr retstr, axr_part_info_t *fileData, unint64_t partIndex, axr_part_info_struct_version_t version)
{
  if ((int)version >= 2) {
    axr_data_get_part_info_cold_1((uint64_t)fileData, partIndex, *(uint64_t *)&version, v4, v5, v6, v7, v8);
  }
  if (fileData)
  {
    p_displayWindow = &fileData->displayWindow;
    AXRData::GetImageInfo((AXRData *)p_displayWindow, partIndex, *(uint64_t *)&version, v4, v5, v6, v7, v8, (uint64_t)retstr);
  }
  else
  {
    *(void *)&retstr->levelMode = 0;
    retstr->preview = 0u;
    *(_OWORD *)&retstr->name = 0u;
    retstr->chromaticities.x = 0u;
    retstr->chromaticities.y = 0u;
    *(_OWORD *)&retstr->tileSize.width = 0u;
    *(_OWORD *)&retstr->pixelAspectRatio = 0u;
    retstr->dataWindow = 0u;
    retstr->displayWindow = 0u;
  }
  return fileData;
}

unint64_t axr_data_get_property_count(unint64_t fileData, unint64_t partIndex)
{
  if (fileData) {
    return AXRData::GetImagePropertyCount((AXRData *)(fileData + 16), partIndex, v2, v3, v4, v5, v6, v7);
  }
  return fileData;
}

axr_property_t *__cdecl axr_data_get_property(axr_property_t *__return_ptr retstr, axr_property_t *fileData, unint64_t partIndex, unint64_t propertyIndex, axr_property_struct_version_t version)
{
  if ((int)version >= 2) {
    axr_data_get_property_cold_1((uint64_t)fileData, partIndex, propertyIndex, *(uint64_t *)&version, v5, v6, v7, v8);
  }
  if (fileData)
  {
    p_size = &fileData->size;
    return (axr_property_t *)AXRData::GetImageProperty((AXRData *)p_size, partIndex, propertyIndex, *(uint64_t *)&version, v5, v6, v7, v8, (char **)retstr);
  }
  else
  {
    retstr->flags = axr_property_flags_unhandled;
    *(_OWORD *)&retstr->name = 0u;
    *(_OWORD *)&retstr->size = 0u;
  }
  return fileData;
}

unint64_t axr_data_get_layer_count(unint64_t fileData, unint64_t partIndex)
{
  if (fileData) {
    return AXRData::GetLayerCount((AXRData *)(fileData + 16), partIndex, v2, v3, v4, v5, v6, v7);
  }
  return fileData;
}

axr_layer_info_t *__cdecl axr_data_get_layer_info(axr_layer_info_t *__return_ptr retstr, axr_layer_info_t *fileData, unint64_t partIndex, unint64_t layerIndex, axr_layer_info_struct_version_t version)
{
  if ((int)version >= 2) {
    axr_data_get_layer_info_cold_1((uint64_t)fileData, partIndex, layerIndex, *(uint64_t *)&version, v5, v6, v7, v8);
  }
  if (fileData)
  {
    p_channelCount = &fileData->channelCount;
    return (axr_layer_info_t *)AXRData::GetLayerInfo((AXRData *)p_channelCount, partIndex, layerIndex, *(uint64_t *)&version, v5, v6, v7, v8, retstr);
  }
  else
  {
    retstr->name = 0;
    retstr->channels = 0;
    retstr->channelCount = 0;
  }
  return fileData;
}

unint64_t axr_data_get_level_count(unint64_t fileData, unint64_t partIndex)
{
  if (fileData) {
    return AXRData::GetLevelCount((AXRData *)(fileData + 16), partIndex, v2, v3, v4, v5, v6, v7);
  }
  return fileData;
}

uint64_t AXRData::GetLevelCount(AXRData *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *((void *)this + 9);
  if (a2 && v8)
  {
    unint64_t v9 = 1;
    do
    {
      uint64_t v8 = *(void *)(v8 + 8);
      if (v9 >= a2) {
        break;
      }
      ++v9;
    }
    while (v8);
  }
  if (!v8) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  return (*(_DWORD *)(v8 + 288) * *(_DWORD *)(v8 + 292));
}

axr_size_t axr_data_get_level_size(axr_data_t fileData, unint64_t partIndex, unint64_t levelIndex)
{
  if (fileData) {
    return (axr_size_t)AXRData::GetImageSize((AXRData *)&fileData[2], partIndex, levelIndex, v3, v4, v5, v6, v7);
  }
  return (axr_size_t)fileData;
}

uint64_t AXRData::GetImageSize(AXRData *this, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (Part *)*((void *)this + 9);
  if (a2 && v8)
  {
    unint64_t v9 = 1;
    do
    {
      uint64_t v8 = (Part *)*((void *)v8 + 1);
      if (v9 >= a2) {
        break;
      }
      ++v9;
    }
    while (v8);
  }
  if (!v8) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v10 = *((void *)this + 3);

  return Part::GetImageSize(v8, a3, v10, a4, a5, a6, a7, a8);
}

axr_error_t axr_decoder_read_pixels(axr_decoder_t decoder, void *destination, unint64_t destinationRowBytes, axr_flags_t flags)
{
  int v8 = flags;
  int isa = (int)decoder[4].isa;
  if ((isa - 1) < 2 || isa == 4)
  {
    unint64_t v12 = (Class)((char *)decoder[2].isa + 16);
    return AXRData::ReadPixels(v12, (axr_decoder *)decoder, destination, destinationRowBytes, flags, v5, v6, v7);
  }
  else
  {
    if (isa)
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
        AXRLogError((uint64_t)"decoder %p must request either 1, 2 or 4 channels to be decoded for axr_decoder_read_pixels.", (uint64_t)destination, destinationRowBytes, flags, v4, v5, v6, v7, (char)decoder);
      }
    }
    else
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
        AXRLogError((uint64_t)"decoder %p requests 0 channels to be decoded", (uint64_t)destination, destinationRowBytes, flags, v4, v5, v6, v7, (char)decoder);
      }
    }
    return -1;
  }
}

axr_decoder_read_info_t *__cdecl axr_decoder_get_read_pixels_info(axr_decoder_read_info_t *__return_ptr retstr, axr_decoder_read_info_t *decoder, axr_flags_t flags, axr_decoder_read_info_struct_version_t version)
{
  if (version == axr_decoder_read_info_current)
  {
    BOOL v11 = (axr_decoder *)decoder;
    unint64_t v12 = (AXRData *)(*(void *)&decoder->bitsPerChannel + 16);
    AXRData::GetReadPixelsInfo(v12, v11, flags, v4, v5, v6, v7, v8, (uint64_t)retstr);
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
      AXRLogError((uint64_t)"%s: struct version (%d) invalid", flags, *(uint64_t *)&version, v4, v5, v6, v7, v8, (char)"axr_decoder_get_read_pixels_info");
    }
    *(_OWORD *)&retstr->size.width = 0u;
    *(_OWORD *)&retstr->bitsPerChannel = 0u;
  }
  return decoder;
}

axr_error_t axr_decoder_read_rgba_pixels(axr_decoder_t decoder, void *destination, unint64_t destinationRowBytes, double alphaVal, axr_flags_t flags)
{
  int v9 = flags;
  unsigned int isa = decoder[4].isa;
  if (!isa)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v9) & 2) != 0) {
      AXRLogError((uint64_t)"decoder %p requests 0 channels to be decoded", (uint64_t)destination, destinationRowBytes, flags, v5, v6, v7, v8, (char)decoder);
    }
    return -1;
  }
  if (isa >= 5)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v9) & 2) != 0) {
      AXRLogError((uint64_t)"decoder %p must request 1-4 channels to be used for axr_decoder_read_rgba_pixels.", (uint64_t)destination, destinationRowBytes, flags, v5, v6, v7, v8, (char)decoder);
    }
    return -1;
  }
  unint64_t v13 = (Class)((char *)decoder[2].isa + 16);

  return AXRData::ReadRGBAPixels(v13, (axr_decoder *)decoder, destination, destinationRowBytes, alphaVal, flags, v6, v7, v8);
}

axr_decoder_read_info_t *__cdecl axr_decoder_get_read_rgba_pixels_info(axr_decoder_read_info_t *__return_ptr retstr, axr_decoder_read_info_t *decoder, double alphaVal, axr_flags_t flags, axr_decoder_read_info_struct_version_t version)
{
  if (version == axr_decoder_read_info_current)
  {
    unint64_t v12 = (axr_decoder *)decoder;
    unint64_t v13 = (AXRData *)(*(void *)&decoder->bitsPerChannel + 16);
    AXRData::GetReadRGBAPixelsInfo(v13, v12, flags, v5, v6, v7, v8, v9, (uint64_t)retstr);
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
      AXRLogError((uint64_t)"%s: struct version (%d) invalid", flags, *(uint64_t *)&version, v5, v6, v7, v8, v9, (char)"axr_decoder_get_read_rgba_pixels_info");
    }
    *(_OWORD *)&retstr->size.width = 0u;
    *(_OWORD *)&retstr->bitsPerChannel = 0u;
  }
  return decoder;
}

axr_error_t axr_decoder_read_planes(axr_decoder_t decoder, axr_pixel_data_t *destinationPlaneList, axr_flags_t flags, axr_pixel_data_struct_version_t structVersion)
{
  if (structVersion)
  {
    char v9 = structVersion;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
      AXRLogError((uint64_t)"struct version (%d) invalid", (uint64_t)destinationPlaneList, flags, *(uint64_t *)&structVersion, v4, v5, v6, v7, v9);
    }
    return -1;
  }
  else
  {
    unint64_t v13 = (Class)((char *)decoder[2].isa + 16);
    return AXRData::ReadPlanes(v13, (axr_decoder *)decoder, destinationPlaneList, flags, v4, v5, v6, v7, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,
             v26,
             v27,
             v28,
             v29,
             v30,
             v31,
             v32,
             v33,
             v34,
             v35,
             v36,
             v37,
             v38,
             v39,
             v40,
             v41,
             v42,
             v43,
             v44,
             v45,
             v46);
  }
}

axr_decoder_read_info_t *__cdecl axr_decoder_get_read_planes_info(axr_decoder_read_info_t *__return_ptr retstr, axr_decoder_read_info_t *decoder, unint64_t planeIndex, axr_flags_t flags, axr_decoder_read_info_struct_version_t version)
{
  if (version == axr_decoder_read_info_current)
  {
    unint64_t v12 = (axr_decoder *)decoder;
    unint64_t v13 = (AXRData *)(*(void *)&decoder->bitsPerChannel + 16);
    AXRData::GetReadPlanesInfo(v13, v12, flags, planeIndex, v5, v6, v7, v8, (uint64_t)retstr);
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
      AXRLogError((uint64_t)"%s: struct version (%d) invalid", planeIndex, flags, *(uint64_t *)&version, v5, v6, v7, v8, (char)"axr_decoder_get_read_planes_info");
    }
    *(_OWORD *)&retstr->size.width = 0u;
    *(_OWORD *)&retstr->bitsPerChannel = 0u;
  }
  return decoder;
}

axr_size_t axr_part_get_rip_level_counts(axr_part_t part)
{
  axr_part_t v1 = part + 2;
  if (!part) {
    axr_part_t v1 = 0;
  }
  return *(axr_size_t *)((char *)&v1[27].isa + 4);
}

void axr_part_set_chromaticities(axr_part_t part, int32_t cgColorSpaceModel, float whiteLuminance, float *x, float *y)
{
  if (part) {
    axr_part_t v13 = part + 2;
  }
  else {
    axr_part_t v13 = 0;
  }
  uint64_t isa = (uint64_t)v13[1].isa;
  if (whiteLuminance >= 0.0)
  {
    float v15 = whiteLuminance;
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    float v15 = 1.0;
    if (((kDefaultAXRLogFlags | isa) & 2) != 0)
    {
      double v19 = whiteLuminance;
      AXRLogError((uint64_t)"axr_part_set_chromaticities: invalid white luminance: %f", *(uint64_t *)&cgColorSpaceModel, (uint64_t)x, (uint64_t)y, v5, v6, v7, v8, SLOBYTE(v19));
    }
  }
  long long v16 = xmmword_228F628D0;
  if (!cgColorSpaceModel)
  {
    long long v17 = xmmword_228F628E0;
    goto LABEL_20;
  }
  if (cgColorSpaceModel == 7)
  {
    long long v16 = xmmword_228F628F0;
    long long v17 = xmmword_228F62900;
    goto LABEL_20;
  }
  if (cgColorSpaceModel != 1) {
    axr_part_set_chromaticities_cold_1(cgColorSpaceModel, isa, (uint64_t)x, (uint64_t)y, v5, v6, v7, v8);
  }
  if (!x)
  {
    long long v17 = xmmword_228F628E0;
    if (!y) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  long long v17 = *(_OWORD *)x;
  if (y) {
LABEL_19:
  }
    long long v16 = *(_OWORD *)y;
LABEL_20:
  *(_OWORD *)&v13[14].uint64_t isa = v17;
  *(_OWORD *)&v13[16].uint64_t isa = v16;
  HIDWORD(v13[18].isa) = cgColorSpaceModel;
  *(float *)&v13[18].uint64_t isa = v15;
  for (i = v13[26].isa; i; i = *(EncoderLayer **)i)
    EncoderLayer::SetColorSpaceModel(i, SHIDWORD(v13[18].isa));
}

void axr_part_set_preview(axr_part_t part, const uint8_t *data, uint32_t width, uint32_t height, size_t rowBytes, uintptr_t userData, axr_user_data_destructor_t dataDestructor)
{
  if (part) {
    axr_part_t v13 = part + 2;
  }
  else {
    axr_part_t v13 = 0;
  }
  uint64_t isa = (void (*)(Class, Class))v13[22].isa;
  if (isa) {
    isa(v13[19].isa, v13[21].isa);
  }
  v13[19].uint64_t isa = (Class)data;
  v13[20].uint64_t isa = (Class)rowBytes;
  v13[21].uint64_t isa = (Class)userData;
  v13[22].uint64_t isa = (Class)dataDestructor;
  LODWORD(v13[23].isa) = width;
  HIDWORD(v13[23].isa) = height;
}

axr_error_t axr_part_append_attribute(axr_part_t part, const char *attributeName, const char *attributeType, size_t attributeSize, const uint8_t *attributeBytes, uintptr_t userData, axr_user_data_destructor_t dataDestructor)
{
  if (part) {
    uint64_t v7 = (EncoderPart *)&part[2];
  }
  else {
    uint64_t v7 = 0;
  }
  return EncoderPart::AppendAttribute(v7, (char *)attributeName, attributeType, (const char *)attributeSize, attributeBytes, (const unsigned __int8 *)userData, (void (*)(const void *, unint64_t))dataDestructor);
}

uint64_t EncoderPart::AppendAttribute(EncoderPart *this, char *__s, const char *a3, const char *a4, const unsigned __int8 *a5, const unsigned __int8 *a6, void (*a7)(const void *, unint64_t))
{
  size_t v14 = strlen(__s);
  size_t v15 = strlen(a3);
  size_t v23 = v15;
  uint64_t v24 = *((void *)this + 1);
  if ((v24 & 1) == 0)
  {
    if (v14 >= 0x100)
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v24) & 2) != 0) {
        AXRLogError((uint64_t)"axr_part_append_attribute error:  The name \"%s\" must be less than 255 characters.", v16, v17, v18, v19, v20, (uint64_t)v21, v22, (char)__s);
      }
      return -5;
    }
    if (v14)
    {
      if (v15 >= 0x100)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | v24) & 2) != 0) {
          AXRLogError((uint64_t)"axr_part_append_attribute error:  The type \"%s\" must be less than 255 characters.", v16, v17, v18, v19, v20, (uint64_t)v21, v22, (char)a3);
        }
        return -5;
      }
      if (v15)
      {
        uint64_t v40 = *((void *)this + 1);
        for (uint64_t i = 0; i != 16; ++i)
        {
          if (!strcmp(__s, off_264857AA0[i]))
          {
            if (GetFlagsOnceToken != -1) {
              dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
            }
            if (((kDefaultAXRLogFlags | v40) & 2) != 0) {
              AXRLogError((uint64_t)"axr_part_append_attribute error:  The name \"%s\" is already set as a standard part of axr_encoder_append_part() and may not be used again.", v27, v28, v29, v30, v31, v32, v33, (char)__s);
            }
            return -9;
          }
        }
        if (!strcmp(a3, "chromaticities") || !strcmp(__s, "whiteLuminance"))
        {
          if (GetFlagsOnceToken != -1) {
            dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
          }
          if (((kDefaultAXRLogFlags | v40) & 2) != 0)
          {
            uint64_t v25 = "axr_part_append_attribute error:  Use axr_part_set_chromaticities() to set chromaticities and luminance.";
            goto LABEL_44;
          }
        }
        else
        {
          if (strcmp(a3, "preview")) {
            goto LABEL_24;
          }
          if (GetFlagsOnceToken != -1) {
            dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
          }
          if (((kDefaultAXRLogFlags | v40) & 2) != 0)
          {
            uint64_t v25 = "axr_part_append_attribute error:  Use axr_part_set_preview() to add a preview image.";
            goto LABEL_44;
          }
        }
        return -9;
      }
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v24) & 2) == 0) {
        return -9;
      }
      uint64_t v25 = "axr_part_append_attribute error:  The attribute must have a type name.";
    }
    else
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v24) & 2) == 0) {
        return -9;
      }
      uint64_t v25 = "axr_part_append_attribute error:  The attribute must have a name.";
    }
LABEL_44:
    AXRLogError((uint64_t)v25, v16, v17, v18, v19, v20, (uint64_t)v21, v22, v39);
    return -9;
  }
LABEL_24:
  AttributeListNode = AttributeListNode::CreateAttributeListNode((AttributeListNode *)__s, a3, a4, (uint64_t)a5, a6, (uint64_t)a7, v21);
  if (!AttributeListNode) {
    return -5;
  }
  uint64_t v35 = AttributeListNode;
  uint64_t result = 0;
  if (v14 <= v23) {
    size_t v37 = v23;
  }
  else {
    size_t v37 = v14;
  }
  size_t v38 = *((void *)this + 25);
  *(void *)uint64_t v35 = *((void *)this + 24);
  if (v38 > v37) {
    size_t v37 = v38;
  }
  *((void *)this + 24) = v35;
  *((void *)this + 25) = v37;
  return result;
}

void *__cdecl axr_part_create_colorspace(axr_part_t part, axr_flags_t flags, void *options)
{
  if (part) {
    uint64_t v6 = (EncoderPart *)&part[2];
  }
  else {
    uint64_t v6 = 0;
  }
  return (void *)EncoderPart::CreateColorSpace(v6, flags, (const __CFDictionary *)options, 0, v3, v4, v5);
}

uint64_t EncoderPart::CreateColorSpace(EncoderPart *this, axr_flags_t a2, const __CFDictionary *a3, int a4, double a5, double a6, __n128 a7)
{
  uint64_t v7 = *((unsigned int *)this + 37);
  if (v7 > 7 || (unint64_t)(v7 - 2) < 5) {
    return 0;
  }
  int8x16_t v9 = *((int8x16_t *)this + 7);
  __n128 v10 = *((__n128 *)this + 8);
  a7.n128_u32[0] = *((_DWORD *)this + 36);
  float32x4_t v11 = (float32x4_t)vandq_s8((int8x16_t)vceqq_f32((float32x4_t)v10, (float32x4_t)xmmword_228F628D0), (int8x16_t)vceqq_f32((float32x4_t)v9, (float32x4_t)xmmword_228F628E0));
  v11.i32[0] = vminvq_u32((uint32x4_t)v11);
  return AXRCreateColorSpace(v9, v10, a7, v11, (unsigned __int32)v11.i32[0] >> 31, EncoderPart::CreateColorSpace(axr_flags_t,__CFDictionary const*,BOOL)::kChannelTypeMask[v7], (uint64_t)a3, a2, a4);
}

void axr_part_append_channels(axr_part_t part, const char *layerName, axr_type_t channelType, uint32_t xSampling, uint32_t ySampling, BOOL perceptuallyLinear, const axr_channel_type_t *channelList, const char **channelNames, unint64_t channelCount, axr_data_provider_read_t readFunc, axr_data_provider_release_t releaseFunc, uintptr_t userInfo)
{
  if (part) {
    unint64_t v12 = (EncoderPart *)&part[2];
  }
  else {
    unint64_t v12 = 0;
  }
  EncoderPart::AppendChannels(v12, (EncoderLayer *)layerName, *(const char **)&channelType, xSampling, *(uint64_t *)&ySampling, perceptuallyLinear, channelList, (axr_channel_type_t *)channelNames, (char **)channelCount, *(long long *)&readFunc, userInfo);
}

void EncoderPart::AppendChannels(EncoderPart *this, EncoderLayer *a2, const char *a3, unsigned int a4, uint64_t a5, uint64_t a6, const axr_channel_type_t *a7, axr_channel_type_t *a8, char **a9, long long a10, unint64_t a11)
{
  axr_part_t v13 = (void (*)(unint64_t))*((void *)&a10 + 1);
  size_t v14 = a9;
  if (a2) {
    size_t v15 = a2;
  }
  else {
    size_t v15 = (EncoderLayer *)&unk_228F63AF7;
  }
  if (!a9) {
    goto LABEL_44;
  }
  unint64_t v16 = *((void *)this + 1);
  if (a4 <= 1) {
    int v17 = 1;
  }
  else {
    int v17 = a4;
  }
  if (a5 <= 1) {
    uint64_t v18 = 1;
  }
  else {
    uint64_t v18 = a5;
  }
  if ((v16 & 1) == 0)
  {
    if (a3 >= 3)
    {
      if (GetFlagsOnceToken != -1)
      {
        uint64_t v24 = a3;
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        axr_part_t v13 = (void (*)(unint64_t))*((void *)&a10 + 1);
        a3 = v24;
      }
      if (((kDefaultAXRLogFlags | v16) & 2) == 0) {
        goto LABEL_44;
      }
      char v25 = (char)a3;
      uint64_t v19 = "axr_part_append_channels error: channel type %u out of bounds. Operation ignored.";
      goto LABEL_42;
    }
    if ((unint64_t)a9 > 4
      || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)a9), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] >= 2uLL))
    {
      if (GetFlagsOnceToken != -1)
      {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        axr_part_t v13 = (void (*)(unint64_t))*((void *)&a10 + 1);
        size_t v14 = a9;
      }
      if (((kDefaultAXRLogFlags | v16) & 2) == 0) {
        goto LABEL_44;
      }
      char v25 = (char)v14;
      uint64_t v19 = "axr_part_append_channels error: channels (%lu) must be 1, 2 or 4. Operation ignored.";
    }
    else if (a7)
    {
      if ((void)a10) {
        goto LABEL_21;
      }
      if (GetFlagsOnceToken != -1)
      {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        axr_part_t v13 = (void (*)(unint64_t))*((void *)&a10 + 1);
      }
      if (((kDefaultAXRLogFlags | v16) & 2) == 0) {
        goto LABEL_44;
      }
      uint64_t v19 = "axr_part_append_channels error: readFunc may not be NULL. Operation ignored.";
    }
    else
    {
      if (GetFlagsOnceToken != -1)
      {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        axr_part_t v13 = (void (*)(unint64_t))*((void *)&a10 + 1);
      }
      if (((kDefaultAXRLogFlags | v16) & 2) == 0) {
        goto LABEL_44;
      }
      uint64_t v19 = "axr_part_append_channels error: channel list may not be NULL. Operation ignored.";
    }
LABEL_42:
    axr_flags_t v27 = (axr_flags_t)v13;
    goto LABEL_43;
  }
LABEL_21:
  LODWORD(v26) = *((_DWORD *)this + 37);
  EncoderLayer::CreateEncoderLayer(v15, a3, v17, v18, a6, a7, a8, (unint64_t)a9, a10, v26, a11, v16, *((axr_flags_t *)&a10 + 1));
  if (v21)
  {
    uint64_t v22 = (void *)*((void *)this + 26);
    if (v22)
    {
      do
      {
        size_t v23 = v22;
        uint64_t v22 = (void *)*v22;
      }
      while (v22);
      *size_t v23 = v21;
    }
    else
    {
      *((void *)this + 26) = v21;
    }
    return;
  }
  if (GetFlagsOnceToken != -1) {
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
  axr_part_t v13 = (void (*)(unint64_t))v27;
  if (((kDefaultAXRLogFlags | v16) & 2) != 0)
  {
    uint64_t v19 = "axr_part_append_channels error: Layer operation failed to allocate. Memory low. Operation ignored.";
LABEL_43:
    AXRLogError((uint64_t)v19, (uint64_t)a2, (uint64_t)a3, v18, a5, a6, (uint64_t)a7, (uint64_t)v14, v25);
    axr_part_t v13 = (void (*)(unint64_t))v27;
  }
LABEL_44:
  if (v13)
  {
    v13(a11);
  }
}

axr_size_t axr_part_get_tile_size(axr_part_t part)
{
  axr_part_t v1 = (axr_size_t *)&part[2];
  if (!part) {
    axr_part_t v1 = 0;
  }
  return v1[11];
}

char *AttributeListNode::CreateAttributeListNode(AttributeListNode *this, const char *a2, const char *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, void (*a7)(const void *, unint64_t))
{
  size_t v13 = strlen((const char *)this);
  size_t v14 = strlen(a2);
  size_t v15 = (char *)malloc_type_malloc((v13 + v14 + 81) & 0xFFFFFFFFFFFFFFF0, 0xD8597607uLL);
  unint64_t v16 = v15;
  if (v15)
  {
    *((void *)v15 + 4) = a3;
    *((void *)v15 + 5) = a4;
    *((void *)v15 + 6) = a5;
    *((void *)v15 + 7) = a6;
    int v17 = v15 + 64;
    *(void *)size_t v15 = 0;
    *((void *)v15 + 1) = v15 + 64;
    uint64_t v18 = stpcpy(v15 + 64, (const char *)this) + 1;
    *((void *)v16 + 2) = v18;
    *((void *)v16 + 3) = stpcpy(v18, a2) - v17;
  }
  return v16;
}

uint64_t EncoderPart::CreateEncoderPart(EncoderPart *this, const char *a2, const char *a3, uint64_t a4, axr_box2i a5, axr_box2i a6, float a7, float a8, float a9, float a10, float a11, axr_line_order_t a12, unsigned int a13, unsigned int a14, axr_level_mode_t a15, axr_flags_t a16)
{
  char yMin = a6.yMin;
  char v17 = a4;
  unsigned int v18 = a3;
  unsigned int v24 = a13;
  if (SHIDWORD(a4) >= (int)a4) {
    unint64_t v26 = (HIDWORD(a4) - a4 + 1);
  }
  else {
    unint64_t v26 = 0;
  }
  if (a2) {
    axr_flags_t v27 = a2;
  }
  else {
    axr_flags_t v27 = (const char *)&unk_228F63AF7;
  }
  if (a3 <= 7 && ((1 << (char)a3) & 0xF6) != 0)
  {
    if (a13 <= 0x10) {
      unsigned int v24 = 16;
    }
    if ((a14 & 0xF) == 0)
    {
      unsigned int v24 = 16;
      a12 = v26;
    }
    unsigned int v18 = 3;
    goto LABEL_14;
  }
  if (a3 <= 7)
  {
LABEL_14:
    int v28 = 0;
    unint64_t v29 = GetDefaultCompressionMethodTileSize(axr_compression_t)::kCompressionMethodTileSizes[v18];
    goto LABEL_15;
  }
  unint64_t v29 = 0;
  int v28 = 1;
LABEL_15:
  unsigned int v30 = a14 & 0xF0;
  if (v29 == -1) {
    axr_line_order_t v31 = v26;
  }
  else {
    axr_line_order_t v31 = v29;
  }
  unint64_t v32 = HIDWORD(v29);
  if (a12) {
    axr_line_order_t v31 = a12;
  }
  if (v24) {
    unsigned int v33 = v24;
  }
  else {
    unsigned int v33 = v32;
  }
  BOOL v35 = (a14 & 0xF) != 0 || v33 != v32;
  if (a16) {
    goto LABEL_78;
  }
  if (!this)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a16) & 2) == 0) {
      return 0;
    }
    uint64_t v36 = "axr_encoder_append_part: partName may not be NULL";
    goto LABEL_56;
  }
  if (v28)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a16) & 2) != 0) {
      AXRLogError((uint64_t)"axr_encoder_append_part: compression mode %u invalid", (uint64_t)a2, (uint64_t)a3, a4, *(uint64_t *)&a5.xMin, *(uint64_t *)&a5.yMin, *(uint64_t *)&a6.xMin, *(uint64_t *)&a6.yMin, v18);
    }
    return 0;
  }
  if (SHIDWORD(a4) < (int)a4 || a5.xMax < a5.xMin)
  {
    if (GetFlagsOnceToken == -1) {
      goto LABEL_54;
    }
    goto LABEL_96;
  }
  if (a5.yMin > a5.yMax || a6.xMin > a6.xMax)
  {
    if (GetFlagsOnceToken == -1)
    {
LABEL_54:
      if (((kDefaultAXRLogFlags | a16) & 2) == 0) {
        return 0;
      }
      char v58 = v17;
      uint64_t v36 = "axr_encoder_append_part: dataWindow {x:[%d,%d],y:[%d,%d]} invalid";
LABEL_56:
      AXRLogError((uint64_t)v36, (uint64_t)a2, (uint64_t)a3, a4, *(uint64_t *)&a5.xMin, *(uint64_t *)&a5.yMin, *(uint64_t *)&a6.xMin, *(uint64_t *)&a6.yMin, v58);
      return 0;
    }
LABEL_96:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    goto LABEL_54;
  }
  if (a6.yMin >= 3u)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a16) & 2) != 0) {
      AXRLogError((uint64_t)"axr_encoder_append_part: lineOrder %u invalid", (uint64_t)a2, (uint64_t)a3, a4, *(uint64_t *)&a5.xMin, *(uint64_t *)&a5.yMin, *(uint64_t *)&a6.xMin, *(uint64_t *)&a6.yMin, yMin);
    }
    return 0;
  }
  if (a7 < 0.0)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a16) & 2) != 0)
    {
      double v59 = a7;
      AXRLogError((uint64_t)"axr_encoder_append_part: pixel aspect ratio %f invalid", (uint64_t)a2, (uint64_t)a3, a4, *(uint64_t *)&a5.xMin, *(uint64_t *)&a5.yMin, *(uint64_t *)&a6.xMin, *(uint64_t *)&a6.yMin, SLOBYTE(v59));
    }
    return 0;
  }
  if ((a14 & 0xFFFFFF00) != 0)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a16) & 2) != 0) {
      AXRLogError((uint64_t)"axr_encoder_append_part: level mode contains unhandled bits %x", (uint64_t)a2, (uint64_t)a3, a4, *(uint64_t *)&a5.xMin, *(uint64_t *)&a5.yMin, *(uint64_t *)&a6.xMin, *(uint64_t *)&a6.yMin, 0);
    }
    return 0;
  }
  if ((a14 & 0xF) >= 3)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a16) & 2) != 0) {
      AXRLogError((uint64_t)"axr_encoder_append_part: illegal level format %8.8x", (uint64_t)a2, (uint64_t)a3, a4, *(uint64_t *)&a5.xMin, *(uint64_t *)&a5.yMin, *(uint64_t *)&a6.xMin, *(uint64_t *)&a6.yMin, a14 & 0xF);
    }
    return 0;
  }
  if (v30 >= 0x11)
  {
    if (GetFlagsOnceToken != -1)
    {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      LOBYTE(v30) = a14 & 0xF0;
    }
    if (((kDefaultAXRLogFlags | a16) & 2) != 0) {
      AXRLogError((uint64_t)"axr_encoder_append_part: illegal level rounding mode %8.8x", (uint64_t)a2, (uint64_t)a3, a4, *(uint64_t *)&a5.xMin, *(uint64_t *)&a5.yMin, *(uint64_t *)&a6.xMin, *(uint64_t *)&a6.yMin, v30);
    }
    return 0;
  }
LABEL_78:
  axr_line_order_t v61 = v31;
  unint64_t v60 = v26;
  uint64_t v63 = *(void *)&a5.yMin;
  uint64_t v64 = *(void *)&a6.xMin;
  BOOL v65 = v35;
  int32_t v66 = a6.yMin;
  int32_t xMax = a5.xMax;
  uint64_t v39 = *(void *)&a5.xMin;
  uint64_t v41 = v27;
  size_t v42 = strnlen((const char *)this, 0xFFuLL) + 1;
  size_t v43 = strnlen(v41, 0xFFuLL);
  objc_opt_class();
  uint64_t v44 = _os_object_alloc();
  uint64_t v37 = v44;
  if (v44)
  {
    size_t v45 = v43 + 1;
    *(void *)(v44 + 24) = a16;
    *(void *)(v44 + 32) = v44 + 272;
    strncpy((char *)(v44 + 272), v41, v45);
    uint64_t v46 = (char *)(v45 + *(void *)(v37 + 32));
    *(void *)(v37 + 40) = v46;
    strncpy(v46, (const char *)this, v42);
    *(_DWORD *)(v37 + 48) = v18;
    *(void *)(v37 + 52) = a4;
    *(void *)(v37 + 60) = v39;
    *(void *)(v37 + 68) = v63;
    *(void *)(v37 + 76) = v64;
    *(_DWORD *)(v37 + 84) = v66;
    *(float *)(v37 + 88) = a7;
    *(float *)(v37 + 92) = a8;
    *(float *)(v37 + 96) = a9;
    *(float *)(v37 + 100) = a10;
    *(_DWORD *)(v37 + 104) = v61;
    *(_DWORD *)(v37 + 108) = v33;
    *(_DWORD *)(v37 + 112) = a14;
    *(float *)(v37 + 116) = a11;
    *(_OWORD *)(v37 + 128) = xmmword_228F628E0;
    *(_OWORD *)(v37 + 144) = xmmword_228F628D0;
    *(void *)(v37 + 160) = 0x13F800000;
    *(void *)(v37 + 168) = 0;
    if (xMax >= (int)v39) {
      unint64_t v47 = (xMax - v39 + 1);
    }
    else {
      unint64_t v47 = 0;
    }
    *(_OWORD *)(v37 + 200) = 0u;
    *(_OWORD *)(v37 + 184) = 0u;
    unsigned int v48 = a14 & 0xF;
    if ((a14 & 0xF) != 0)
    {
      unint64_t v52 = v60 | (v47 << 32);
      if ((a14 & 0xF0) == 0x10)
      {
        if (v60 > 1) {
          unint64_t v53 = 64 - __clz(v60 - 1);
        }
        else {
          LODWORD(v53) = 0;
        }
        unint64_t v54 = 64 - __clz(v47 - 1);
        if (!(v52 >> 33)) {
          LODWORD(v54) = 0;
        }
        unsigned int v48 = a14 & 0xF;
      }
      else
      {
        unint64_t v53 = 63 - __clz(v60);
        if (!v60) {
          LODWORD(v53) = 0;
        }
        unint64_t v54 = 63 - __clz(v47);
        if (!HIDWORD(v52)) {
          LODWORD(v54) = 0;
        }
      }
      if ((int)v53 + 1 <= (v54 + 1)) {
        unsigned int v55 = v54 + 1;
      }
      else {
        unsigned int v55 = v53 + 1;
      }
      if (v48 == 1) {
        uint64_t v56 = v55;
      }
      else {
        uint64_t v56 = (v53 + 1);
      }
      if (v48 == 1) {
        uint64_t v57 = 1;
      }
      else {
        uint64_t v57 = (v54 + 1);
      }
      uint64_t v49 = v56 | (v57 << 32);
    }
    else
    {
      uint64_t v49 = 0x100000001;
    }
    *(void *)(v37 + 236) = v49;
    *(_DWORD *)(v37 + 232) = HIDWORD(v49) * v49;
    long long v50 = "tiledimage";
    if (!v65) {
      long long v50 = "scanlineimage";
    }
    *(void *)(v37 + 248) = v50;
  }
  return v37;
}

unint64_t EncoderPart::Print(EncoderPart *this, char *__str, size_t __size)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  int v6 = snprintf(__str, __size, "\tpart name:            \"%s\"\n", *((const char **)this + 3));
  unint64_t v7 = v6;
  if (__size > v6)
  {
    unint64_t v7 = v6 + (uint64_t)snprintf(&__str[v6], __size - v6, "\tview name:            \"%s\"\n", *((const char **)this + 2));
    if (__size > v7)
    {
      name = axr_compression_get_name((axr_compression_t)*((_DWORD *)this + 8));
      v7 += snprintf(&__str[v7], __size - v7, "\tcompression:          %s\n", name);
      if (__size > v7)
      {
        v7 += snprintf(&__str[v7], __size - v7, "\ttype:                 %s\n", *((const char **)this + 29));
        if (__size > v7)
        {
          v7 += snprintf(&__str[v7], __size - v7, "\tdata window:          x:[%d, %d], y:[%d, %d]\n", *((_DWORD *)this + 9), *((_DWORD *)this + 10), *((_DWORD *)this + 11), *((_DWORD *)this + 12));
          if (__size > v7)
          {
            v7 += snprintf(&__str[v7], __size - v7, "\tdisplay window:       x:[%d, %d], y:[%d, %d]\n", *((_DWORD *)this + 13), *((_DWORD *)this + 14), *((_DWORD *)this + 15), *((_DWORD *)this + 16));
            if (__size > v7)
            {
              int8x16_t v9 = axr_line_order_get_name((axr_line_order_t)*((_DWORD *)this + 17));
              v7 += snprintf(&__str[v7], __size - v7, "\tline order:           %s\n", v9);
              if (__size > v7)
              {
                v7 += snprintf(&__str[v7], __size - v7, "\tpixel aspect ratio:   %f\n", *((float *)this + 18));
                if (__size > v7)
                {
                  v7 += snprintf(&__str[v7], __size - v7, "\tscreen window center: {%f, %f}\n", *((float *)this + 19), *((float *)this + 20));
                  if (__size > v7)
                  {
                    v7 += snprintf(&__str[v7], __size - v7, "\tscreen window width:  {%f, %f}\n", *((float *)this + 19), *((float *)this + 20));
                    if (__size > v7)
                    {
                      v7 += snprintf(&__str[v7], __size - v7, "\ttile size:            {w:%u, h:%u}\n", *((_DWORD *)this + 22), *((_DWORD *)this + 23));
                      if (__size > v7)
                      {
                        __n128 v10 = axr_level_mode_get_name((axr_level_mode_t)*((_DWORD *)this + 24));
                        v7 += snprintf(&__str[v7], __size - v7, "\tlevel mode:           %s\n", v10);
                        if (__size > v7)
                        {
                          int v11 = *((_DWORD *)this + 24);
                          if ((v11 & 0xF) != 0)
                          {
                            v7 += snprintf(&__str[v7], __size - v7, "\tlevel count:          %u\n", *((_DWORD *)this + 54));
                            if (v7 >= __size) {
                              return v7;
                            }
                            int v11 = *((_DWORD *)this + 24);
                          }
                          if ((v11 & 0xF) != 2
                            || (v7 += snprintf(&__str[v7], __size - v7, "\trip levels:           x: %u, y: %u\n", *((_DWORD *)this + 55), *((_DWORD *)this + 56)), v7 < __size))
                          {
                            unint64_t v12 = (EncoderLayer *)*((void *)this + 26);
                            if (v12)
                            {
                              uint64_t v13 = 0;
                              do
                              {
                                size_t v14 = EncoderLayer::PrintChannels(v12, &v17[v13], 2048 - v13, *((_DWORD *)this + 37));
                                unint64_t v15 = v14 + v13;
                                if (v14 + v13 >= 0x800) {
                                  uint64_t v13 = 2048;
                                }
                                else {
                                  v13 += v14;
                                }
                                unint64_t v12 = *(EncoderLayer **)v12;
                              }
                              while (v12 && v15 < 0x800);
                            }
                            else
                            {
                              strcpy(v17, "<no channels>");
                            }
                            v7 += snprintf(&__str[v7], __size - v7, "\tchannels:               %s\n", v17);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v7;
}

uint64_t EncoderPart::EncodeChannelList(EncoderPart *this, EncoderStream *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  int8x16_t v9 = (int *)*((void *)this + 26);
  if (v9)
  {
    uint64_t v11 = 1;
    do
    {
      uint64_t v12 = *((void *)v9 + 2);
      if (v12)
      {
        for (unint64_t i = 0; i != v12; ++i)
        {
          size_t v14 = (const char *)*((void *)v9 + 3);
          EncodedNameForChannel = EncoderLayer::GetEncodedNameForChannel((EncoderLayer *)v9, i, v9[17]);
          snprintf(__str, 0x100uLL, "%s%s", v14, EncodedNameForChannel);
          v11 += strlen(__str) + 17;
        }
      }
      int8x16_t v9 = *(int **)v9;
    }
    while (v9);
    unint64_t v16 = EncoderStream::GetBytes<char>(a2, v11 + 20);
    if (v16)
    {
      char v17 = stpcpy(v16, "channels");
      uint64_t v18 = stpcpy(v17 + 1, "chlist");
      *(_DWORD *)(v18 + 1) = v11;
      uint64_t v19 = v18 + 5;
      for (j = (uint64_t *)*((void *)this + 26); j; j = (uint64_t *)*j)
      {
        uint64_t v21 = j[2];
        if (v21)
        {
          for (uint64_t k = 0; k != v21; ++k)
          {
            unint64_t v23 = 0;
            unsigned int v24 = (int *)(j[1] + 12);
            while (1)
            {
              int v25 = *v24;
              v24 += 4;
              if (k == v25) {
                break;
              }
              if (v21 == ++v23) {
                return -13;
              }
            }
            unint64_t v26 = (const char *)j[3];
            axr_flags_t v27 = EncoderLayer::GetEncodedNameForChannel((EncoderLayer *)j, v23, *((_DWORD *)j + 17));
            snprintf(__str, 0x100uLL, "%s%s", v26, v27);
            int v28 = stpcpy(v19, __str);
            uint64_t v29 = *(uint64_t *)((char *)j + 60);
            *(void *)(v28 + 1) = *((unsigned int *)j + 14) | ((unint64_t)*((unsigned __int8 *)j + 72) << 32);
            *(void *)(v28 + 9) = v29;
            uint64_t v19 = v28 + 17;
          }
        }
      }
      uint64_t result = 0;
      *uint64_t v19 = 0;
    }
    else
    {
      return -5;
    }
  }
  else
  {
    int v30 = a3;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v30) & 2) != 0) {
      AXRLogError((uint64_t)"axr_encoder_compress:  part %p has no channels", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)this);
    }
    return -11;
  }
  return result;
}

char *EncoderStream::GetBytes<char>(void *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v4 = a1[9];
  if (v4
    && (v6 = *(void *)(v4 + 24), uint64_t v5 = *(void *)(v4 + 32), v7 = v5 + a2, v5 + a2 <= v6)
    && (v8 = v5 + v4, *(void *)(v4 + 32) = v7, int8x16_t v9 = (char *)(v8 - v6), v8 != v6))
  {
    a1[8] += a2;
  }
  else
  {
    if (a1[7] > a2) {
      a2 = a1[7];
    }
    EncoderBuffer::GetEncoderBuffer((uint64_t)a1, a2);
    if (v10
      && (uint64_t v11 = a1[8],
          v10[2] = a1[9],
          a1[8] = v11 + v2,
          a1[9] = v10,
          unint64_t v13 = v10[3],
          uint64_t v12 = v10[4],
          uint64_t v14 = v12 + v2,
          v12 + v2 <= v13))
    {
      int8x16_t v9 = (char *)v10 + v12 - v13;
      v10[4] = v14;
    }
    else
    {
      return 0;
    }
  }
  return v9;
}

uint64_t EncoderPart::EncodeTileDesc(EncoderPart *this, EncoderStream *a2, axr_flags_t a3)
{
  uint64_t v3 = *((void *)this + 11);
  int v4 = *((_DWORD *)this + 24);
  uint64_t v5 = EncoderStream::GetBytes<char>(a2, 0x1FuLL);
  if (!v5) {
    return -5;
  }
  unint64_t v6 = stpcpy(v5, "tiles");
  uint64_t v7 = stpcpy(v6 + 1, "tiledesc");
  uint64_t result = 0;
  *(_DWORD *)(v7 + 1) = 12;
  *(void *)(v7 + 5) = v3;
  v7[13] = v4;
  return result;
}

uint64_t EncodeAttribute(EncoderStream *a1, const char *__s, const char *a3, size_t a4, const void *a5)
{
  size_t v10 = strlen(__s);
  size_t v11 = strlen(a3);
  uint64_t v12 = EncoderStream::GetBytes<char>(a1, a4 + v10 + v11 + 6);
  if (!v12) {
    return -5;
  }
  unint64_t v13 = stpcpy(v12, __s);
  uint64_t v14 = stpcpy(v13 + 1, a3);
  *(_DWORD *)(v14 + 1) = a4;
  memcpy(v14 + 5, a5, a4);
  return 0;
}

uint64_t EncoderPart::EncodePreview(EncoderPart *this, EncoderStream *a2, axr_flags_t a3)
{
  if (!*((void *)this + 19)) {
    return 0;
  }
  size_t v4 = 4 * *((unsigned int *)this + 46);
  uint64_t v5 = EncoderStream::GetBytes<char>(a2, v4 * *((unsigned int *)this + 47) + 28);
  if (!v5) {
    return -5;
  }
  unint64_t v6 = stpcpy(v5, "preview");
  uint64_t v7 = stpcpy(v6 + 1, "preview");
  *(_DWORD *)(v7 + 1) = 20;
  *(_DWORD *)(v7 + 5) = *((_DWORD *)this + 46);
  *(_DWORD *)(v7 + 9) = *((_DWORD *)this + 47);
  if (*((_DWORD *)this + 47))
  {
    unint64_t v8 = 0;
    int8x16_t v9 = (char *)*((void *)this + 19);
    size_t v10 = v7 + 13;
    do
    {
      memcpy(v10, v9, v4);
      v9 += *((void *)this + 20);
      v10 += v4;
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 47));
  }
  size_t v11 = (void (*)(void, void))*((void *)this + 22);
  if (v11) {
    v11(*((void *)this + 19), *((void *)this + 21));
  }
  uint64_t result = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 19) = 0;
  return result;
}

uint64_t EncoderPart::EncodeHeader(uint64_t a1, EncoderStream *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  int v12 = *(_DWORD *)(a1 + 32);
  char v54 = *(_DWORD *)(a1 + 68);
  unint64_t v13 = *(AttributeListNode **)(a1 + 192);
  uint64_t v14 = EncoderPart::EncodeChannelList((EncoderPart *)a1, a2, a4, a4, a5, a6, a7, a8);
  if (!v14)
  {
    unint64_t v15 = EncoderStream::GetBytes<char>(a2, 0x1DuLL);
    if (!v15) {
      return -5;
    }
    unint64_t v16 = stpcpy(v15, "compression");
    char v17 = stpcpy(v16 + 1, "compression");
    *(_DWORD *)(v17 + 1) = 1;
    v17[5] = v12;
    int v18 = *(_DWORD *)(a1 + 36);
    int32x2_t v19 = *(int32x2_t *)(a1 + 40);
    int v20 = *(_DWORD *)(a1 + 48);
    uint64_t v21 = EncoderStream::GetBytes<char>(a2, 0x25uLL);
    if (!v21) {
      return -5;
    }
    uint64_t v22 = stpcpy(v21, "dataWindow");
    unint64_t v23 = stpcpy(v22 + 1, "box2i");
    *(_DWORD *)(v23 + 1) = 16;
    *(_DWORD *)(v23 + 5) = v18;
    *(int32x2_t *)(v23 + 9) = vrev64_s32(v19);
    *(_DWORD *)(v23 + 17) = v20;
    int v24 = *(_DWORD *)(a1 + 52);
    int32x2_t v25 = *(int32x2_t *)(a1 + 56);
    int v26 = *(_DWORD *)(a1 + 64);
    axr_flags_t v27 = EncoderStream::GetBytes<char>(a2, 0x28uLL);
    if (!v27) {
      return -5;
    }
    int v28 = stpcpy(v27, "displayWindow");
    uint64_t v29 = stpcpy(v28 + 1, "box2i");
    *(_DWORD *)(v29 + 1) = 16;
    *(_DWORD *)(v29 + 5) = v24;
    *(int32x2_t *)(v29 + 9) = vrev64_s32(v25);
    *(_DWORD *)(v29 + 17) = v26;
    uint64_t v14 = EncodeAttribute(a2, "lineOrder", "lineOrder", 1uLL, &v54);
    if (!v14)
    {
      uint64_t v14 = EncodeFloat(a2, "pixelAspectRatio", *(float *)(a1 + 72), v30);
      if (!v14)
      {
        uint64_t v14 = Encode_v2f(a2, v31, *(float *)(a1 + 76), *(float *)(a1 + 80), v32);
        if (!v14)
        {
          uint64_t v14 = EncodeFloat(a2, "screenWindowWidth", *(float *)(a1 + 84), v33);
          if (!v14)
          {
            uint64_t v14 = EncodeFloat(a2, "xDensity", *(float *)(a1 + 100), v34);
            if (!v14)
            {
              int v37 = *(_DWORD *)(a3 + 4);
              LOWORD(v38) = v37;
              if ((v37 & 0x200) != 0)
              {
                uint64_t v14 = EncoderPart::EncodeTileDesc((EncoderPart *)a1, a2, (axr_flags_t)v35);
                if (v14) {
                  return v14;
                }
                int v38 = *(_DWORD *)(a3 + 4);
              }
              if ((v38 & 0x1000) != 0)
              {
                BOOL v35 = *(const char **)(a1 + 16);
                if (*v35)
                {
                  uint64_t v14 = EncodeString(a2, "view", v35, v36);
                  if (v14) {
                    return v14;
                  }
                  int v38 = *(_DWORD *)(a3 + 4);
                }
              }
              if ((v38 & 0x1800) == 0
                || (uint64_t v14 = EncodeString(a2, "name", *(const char **)(a1 + 24), v36)) == 0
                && (uint64_t v14 = EncodeString(a2, "type", *(const char **)(a1 + 232), v39)) == 0
                && (int ChunkCount = EncoderPart::GetChunkCount((EncoderPart *)a1),
                    (uint64_t v14 = EncodeInt(a2, "chunkCount", ChunkCount, v41)) == 0)
                && ((v37 & 0x200) != 0
                 || (*(_DWORD *)(a1 + 240) & 2) == 0
                 || (uint64_t v14 = EncoderPart::EncodeTileDesc((EncoderPart *)a1, a2, (axr_flags_t)v35)) == 0))
              {
                if ((*(unsigned char *)(a3 + 5) & 8) != 0)
                {
                  uint64_t v14 = EncodeInt(a2, "version", 1, v36);
                  if (v14) {
                    return v14;
                  }
                  if (GetFlagsOnceToken != -1) {
                    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
                  }
                  if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
                    AXRLogError((uint64_t)"axr_encoder_compress error:  AppleEXR doesn't support deep scanline or deep tile formats currently", v43, (uint64_t)v35, v44, v45, v46, v47, v48, v53);
                  }
                  uint64_t v14 = -3;
                }
                else
                {
                  uint64_t v14 = 0;
                }
                float v49 = *(float *)(a1 + 144);
                if (v49 == 1.0 || (uint64_t v14 = EncodeFloat(a2, "whiteLuminance", v49, (axr_flags_t)v35)) == 0)
                {
                  float32x4_t v50 = *(float32x4_t *)(a1 + 112);
                  float32x4_t v51 = *(float32x4_t *)(a1 + 128);
                  if (((vminvq_u32((uint32x4_t)vandq_s8((int8x16_t)vceqq_f32(v51, (float32x4_t)xmmword_228F628D0), (int8x16_t)vceqq_f32(v50, (float32x4_t)xmmword_228F628E0))) & 0x80000000) != 0|| (uint64_t v14 = EncodeChromaticities(a2, v50, v51)) == 0)&& (!*(void *)(a1 + 152)|| (uint64_t v14 = EncoderPart::EncodePreview((EncoderPart *)a1, a2, (axr_flags_t)v35)) == 0))
                  {
                    *(void *)(a1 + 192) = 0;
                    while (v13)
                    {
                      unint64_t v52 = v13;
                      unint64_t v13 = *(AttributeListNode **)v13;
                      uint64_t v14 = AttributeListNode::Encode(v52, a2);
                      AttributeListNode::Destroy(v52);
                      if (v14)
                      {
                        *(void *)(a1 + 192) = v13;
                        return v14;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v14;
}

uint64_t EncodeFloat(EncoderStream *a1, const char *__s, float a3, axr_flags_t a4)
{
  size_t v7 = strlen(__s);
  int v8 = EncoderStream::GetBytes<char>(a1, v7 + 15);
  if (!v8) {
    return -5;
  }
  int8x16_t v9 = stpcpy(v8, __s);
  size_t v10 = stpcpy(v9 + 1, "float");
  uint64_t result = 0;
  *(_DWORD *)(v10 + 1) = 4;
  *(float *)(v10 + 5) = a3;
  return result;
}

uint64_t Encode_v2f(EncoderStream *a1, const char *a2, float a3, float a4, axr_flags_t a5)
{
  size_t v7 = EncoderStream::GetBytes<char>(a1, 0x23uLL);
  if (!v7) {
    return -5;
  }
  int v8 = stpcpy(v7, "screenWindowCenter");
  int8x16_t v9 = stpcpy(v8 + 1, "v2f");
  uint64_t result = 0;
  *(_DWORD *)(v9 + 1) = 8;
  *(float *)(v9 + 5) = a3;
  *(float *)(v9 + 9) = a4;
  return result;
}

uint64_t EncodeString(EncoderStream *a1, const char *a2, const char *__s, axr_flags_t a4)
{
  size_t v7 = strlen(__s);
  size_t v8 = strlen(a2);
  int8x16_t v9 = EncoderStream::GetBytes<char>(a1, v7 + v8 + 12);
  if (!v9) {
    return -5;
  }
  size_t v10 = stpcpy(v9, a2);
  size_t v11 = stpcpy(v10 + 1, "string");
  *(_DWORD *)(v11 + 1) = v7;
  memcpy(v11 + 5, __s, v7);
  return 0;
}

uint64_t EncodeInt(EncoderStream *a1, const char *__s, int a3, axr_flags_t a4)
{
  size_t v7 = strlen(__s);
  size_t v8 = EncoderStream::GetBytes<char>(a1, v7 + 13);
  if (!v8) {
    return -5;
  }
  int8x16_t v9 = stpcpy(v8, __s);
  size_t v10 = stpcpy(v9 + 1, "int");
  uint64_t result = 0;
  *(_DWORD *)(v10 + 1) = 4;
  *(_DWORD *)(v10 + 5) = a3;
  return result;
}

uint64_t EncoderPart::GetChunkCount(EncoderPart *this)
{
  int v2 = *((_DWORD *)this + 9);
  int v1 = *((_DWORD *)this + 10);
  BOOL v3 = __OFSUB__(v1, v2);
  int v4 = v1 - v2;
  if (v4 < 0 != v3) {
    unsigned int v5 = 0;
  }
  else {
    unsigned int v5 = v4 + 1;
  }
  int v7 = *((_DWORD *)this + 11);
  int v6 = *((_DWORD *)this + 12);
  BOOL v3 = __OFSUB__(v6, v7);
  int v8 = v6 - v7;
  if (v8 < 0 != v3) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = v8 + 1;
  }
  unsigned int v10 = *((_DWORD *)this + 22);
  if (v10 <= 1) {
    unsigned int v10 = 1;
  }
  unsigned int v11 = v5 + v10 - 1;
  if (v11 < v5) {
    int v12 = (v11 - 0xFFFFFFFF / v10 * v10) / v10 + 0xFFFFFFFF / v10;
  }
  else {
    int v12 = v11 / v10;
  }
  unsigned int v13 = *((_DWORD *)this + 23);
  if (v13 <= 1) {
    unsigned int v13 = 1;
  }
  unsigned int v14 = v9 + v13 - 1;
  if (v14 < v9) {
    int v15 = (v14 - 0xFFFFFFFF / v13 * v13) / v13 + 0xFFFFFFFF / v13;
  }
  else {
    int v15 = v14 / v13;
  }
  return (v15 * v12);
}

uint64_t EncodeChromaticities(void *a1, float32x4_t a2, float32x4_t a3)
{
  v7.val[0] = a2;
  v7.val[1] = a3;
  BOOL v3 = EncoderStream::GetBytes<char>(a1, 0x42uLL);
  if (!v3) {
    return -5;
  }
  int v4 = stpcpy(v3, "chromaticities");
  unsigned int v5 = stpcpy(v4 + 1, "chromaticities");
  uint64_t result = 0;
  *(_DWORD *)(v5 + 1) = 32;
  v5 += 5;
  float32x4x2_t v8 = v7;
  vst2q_f32((float *)v5, v8);
  return result;
}

uint64_t AttributeListNode::Encode(AttributeListNode *this, EncoderStream *a2)
{
  BOOL v3 = EncoderStream::GetBytes<char>(a2, *((void *)this + 3) + *((void *)this + 4) + 4);
  if (!v3) {
    return -5;
  }
  int v4 = v3;
  memcpy(v3, (char *)this + 64, *((void *)this + 3));
  uint64_t v6 = *((void *)this + 3);
  size_t v5 = *((void *)this + 4);
  *(_DWORD *)&v4[v6] = v5;
  memcpy(&v4[v6 + 4], *((const void **)this + 5), v5);
  return 0;
}

void AttributeListNode::Destroy(AttributeListNode *this)
{
  int v2 = (void (*)(void, void))*((void *)this + 7);
  if (v2) {
    v2(*((void *)this + 5), *((void *)this + 6));
  }

  free(this);
}

uint64_t EncoderPart::ReserveOffsets(EncoderPart *this, EncoderStream *a2)
{
  int v4 = *((_DWORD *)this + 9);
  int v3 = *((_DWORD *)this + 10);
  BOOL v5 = __OFSUB__(v3, v4);
  int v6 = v3 - v4;
  if (v6 < 0 != v5) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = v6 + 1;
  }
  int v9 = *((_DWORD *)this + 11);
  int v8 = *((_DWORD *)this + 12);
  BOOL v5 = __OFSUB__(v8, v9);
  int v10 = v8 - v9;
  if (v10 < 0 != v5) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = v10 + 1;
  }
  unsigned int v12 = *((_DWORD *)this + 22);
  if (v12 <= 1) {
    unsigned int v12 = 1;
  }
  unsigned int v13 = v7 + v12 - 1;
  if (v13 < v7) {
    int v14 = (v13 - 0xFFFFFFFF / v12 * v12) / v12 + 0xFFFFFFFF / v12;
  }
  else {
    int v14 = v13 / v12;
  }
  unsigned int v15 = *((_DWORD *)this + 23);
  if (v15 <= 1) {
    unsigned int v15 = 1;
  }
  unsigned int v16 = v11 + v15 - 1;
  if (v16 < v11) {
    int v17 = (v16 - 0xFFFFFFFF / v15 * v15) / v15 + 0xFFFFFFFF / v15;
  }
  else {
    int v17 = v16 / v15;
  }
  int v18 = EncoderStream::GetBytes<char>(a2, 8 * (v17 * v14));
  *((void *)this + 31) = v18;
  if (v18) {
    return 0;
  }
  else {
    return -5;
  }
}

uint64_t EncoderPart::EncodeChunks(uint64_t a1, uint64_t a2, int a3, unint64_t *a4, uint64_t a5)
{
  int v10 = *(uint64_t **)(a1 + 208);
  if (v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = v10[2];
      v12 += v13;
      v11 += axr_type_get_size((axr_type_t)*((_DWORD *)v10 + 14)) * v13;
      int v10 = (uint64_t *)*v10;
    }
    while (v10);
    uint64_t v14 = *(void *)(a1 + 208);
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  int v15 = *(_DWORD *)(a1 + 40);
  int v16 = *(_DWORD *)(a1 + 44);
  int v17 = *(_DWORD *)(a1 + 32);
  int v18 = *(_DWORD *)(a1 + 36);
  BOOL v19 = __OFSUB__(v15, v18);
  int v20 = v15 - v18;
  if (v20 < 0 != v19) {
    int v21 = 0;
  }
  else {
    int v21 = v20 + 1;
  }
  int v22 = *(_DWORD *)(a1 + 48);
  BOOL v19 = __OFSUB__(v22, v16);
  int v23 = v22 - v16;
  if (v23 < 0 != v19) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = v23 + 1;
  }
  unint64_t v62 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  uint64_t v67 = 0;
  uint64_t v68 = v11;
  unsigned int v25 = *(_DWORD *)(a1 + 92);
  int v63 = *(_DWORD *)(a1 + 88);
  unsigned int v64 = v25;
  uint64_t v65 = 0;
  unint64_t v66 = 0;
  uint64_t v69 = v12;
  uint64_t v70 = v14;
  uint64_t v71 = a5;
  int v26 = *(_DWORD *)(a1 + 240);
  unint64_t v27 = *a4;
  unint64_t v73 = *a4;
  int v72 = v26;
  int v74 = a3;
  uint64_t v28 = *(void *)(a1 + 248);
  uint64_t v75 = *(void *)(a2 + 64);
  uint64_t v76 = v28;
  uint64_t v29 = 20;
  if (v26 != 1) {
    uint64_t v29 = 0;
  }
  BOOL v30 = v26 == 0;
  uint64_t v31 = 8;
  if (!v30) {
    uint64_t v31 = v29;
  }
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v79 = v31 + ((v27 >> 42) & 4);
  long long v81 = 0uLL;
  long long v82 = 0uLL;
  long long v80 = 0uLL;
  if (!v17)
  {
    uint64_t v57 = a2;
    uint64_t v58 = a1;
    axr_flags_t v32 = &unk_26DD4BE70;
    goto LABEL_20;
  }
  if (v17 == 3)
  {
    uint64_t v57 = a2;
    uint64_t v58 = a1;
    axr_flags_t v32 = &unk_26DD4BE20;
LABEL_20:
    uint64_t v56 = v32;
    double v59 = &v56;
  }
  HIDWORD(v66) = 0;
  unsigned int v33 = *(_DWORD *)(a1 + 224);
  if (!v33)
  {
LABEL_56:
    uint64_t v53 = 0;
    goto LABEL_57;
  }
  unsigned int v34 = 0;
  uint64_t v35 = 0;
  unsigned int v36 = *(_DWORD *)(a1 + 220);
  unsigned int v37 = v36;
  while (1)
  {
    LODWORD(v66) = 0;
    if (v37) {
      break;
    }
LABEL_55:
    HIDWORD(v66) = ++v34;
    if (v34 >= v33) {
      goto LABEL_56;
    }
  }
  while (1)
  {
    unsigned int v38 = *(_DWORD *)(a1 + 88);
    unint64_t v62 = __PAIR64__(v25, v38);
    DWORD1(v61) = 0;
    int v39 = v66;
    int v40 = *(_DWORD *)(a1 + 96);
    unint64_t v41 = HIDWORD(v66);
    if ((v40 & 0xF) != 2) {
      LOBYTE(v41) = v66;
    }
    int v42 = v40 >> 4;
    LODWORD(v43) = (v21 - v42 + (v42 << v66)) >> v66;
    if (v43 <= 1) {
      uint64_t v43 = 1;
    }
    else {
      uint64_t v43 = v43;
    }
    LODWORD(v44) = (v24 - v42 + (v42 << v41)) >> v41;
    if (v44 <= 1) {
      uint64_t v44 = 1;
    }
    else {
      uint64_t v44 = v44;
    }
    *((void *)&v61 + 1) = v43 | (v44 << 32);
    if (v38 <= 1) {
      unsigned int v38 = 1;
    }
    unsigned int v45 = v38 - 1 + v43;
    unsigned int v46 = __CFADD__(v38 - 1, v43) ? (v45 - 0xFFFFFFFF / v38 * v38) / v38 + 0xFFFFFFFF / v38 : v45 / v38;
    unsigned int v47 = v25 <= 1 ? 1 : v25;
    BOOL v48 = __CFADD__(v47 - 1, v44);
    unsigned int v49 = v47 - 1 + v44;
    if (v48) {
      break;
    }
    int v50 = v49 / v47;
    if (v49 / v47) {
      goto LABEL_41;
    }
LABEL_50:
    LODWORD(v66) = v39 + 1;
    if (v39 + 1 >= v36)
    {
      unsigned int v34 = HIDWORD(v66);
      unsigned int v33 = *(_DWORD *)(a1 + 224);
      unsigned int v37 = v36;
      goto LABEL_55;
    }
  }
  int v50 = (v49 - 0xFFFFFFFF / v47 * v47) / v47 + 0xFFFFFFFF / v47;
  if (!v50) {
    goto LABEL_50;
  }
LABEL_41:
  int v51 = 0;
  while (1)
  {
    *(void *)&long long v60 = v35;
    *((void *)&v60 + 1) = __PAIR64__(v50, v46);
    HIDWORD(v65) = v51;
    uint64_t v77 = 0;
    *(void *)&long long v82 = 0;
    long long v80 = 0u;
    long long v81 = 0u;
    unsigned int v52 = HIDWORD(v61) - v25 * v51;
    if (HIDWORD(v62) < v52) {
      unsigned int v52 = HIDWORD(v62);
    }
    LODWORD(v61) = 0;
    HIDWORD(v62) = v52;
    uint64_t v53 = (*((uint64_t (**)(void **, long long *))*v59 + 3))(v59, &v60);
    if (v53) {
      break;
    }
    uint64_t v53 = (*((uint64_t (**)(void **, long long *))*v59 + 4))(v59, &v60);
    if (v53) {
      break;
    }
    (*((void (**)(void **, long long *))*v59 + 5))(v59, &v60);
    unsigned int v25 = *(_DWORD *)(a1 + 92);
    unsigned int v54 = DWORD1(v61) + v25;
    DWORD1(v61) = v54;
    if (v54 + v25 > v24) {
      HIDWORD(v62) = v24 - v54;
    }
    v35 += v46;
    if (v50 == ++v51)
    {
      int v39 = v66;
      unsigned int v36 = *(_DWORD *)(a1 + 220);
      goto LABEL_50;
    }
  }
LABEL_57:
  (*((void (**)(void **))*v59 + 2))(v59);
  return v53;
}

void sub_228F27A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void EncoderLayer::SetColorSpaceModel(EncoderLayer *this, CGColorSpaceModel a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)this + 17) != a2)
  {
    size_t v4 = *((void *)this + 2);
    if (v4 >= 0x80) {
      operator new[]();
    }
    if (v4)
    {
      for (uint64_t i = 0; i != v4; ++i)
        v10[i] = i;
    }
    qsort_r(v10, v4, 4uLL, this, (int (__cdecl *)(void *, const void *, const void *))EncoderLayer::CompareNames);
    uint64_t v6 = *((void *)this + 2);
    if (v6)
    {
      unsigned int v7 = (_DWORD *)(*((void *)this + 1) + 12);
      int v8 = v10;
      do
      {
        int v9 = *v8++;
        *unsigned int v7 = v9;
        v7 += 4;
        --v6;
      }
      while (v6);
    }
    *((_DWORD *)this + 17) = a2;
  }
}

uint64_t EncoderLayer::CompareNames(EncoderLayer *this, unsigned int *a2, unsigned int *a3, const void *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = (const char *)*((void *)this + 3);
  EncodedNameForChannel = EncoderLayer::GetEncodedNameForChannel(this, *a2, *((_DWORD *)this + 17));
  snprintf(__str, 0x100uLL, "%s%s", v6, EncodedNameForChannel);
  unint64_t v8 = *a3;
  int v9 = (const char *)*((void *)this + 3);
  int v10 = EncoderLayer::GetEncodedNameForChannel(this, v8, *((_DWORD *)this + 17));
  snprintf(__s2, 0x100uLL, "%s%s", v9, v10);
  return strcmp(__str, __s2);
}

void EncoderPart::~EncoderPart(EncoderPart *this)
{
  int v2 = (AttributeListNode *)*((void *)this + 24);
  *((void *)this + 24) = 0;
  while (v2)
  {
    int v3 = *(AttributeListNode **)v2;
    AttributeListNode::Destroy(v2);
    int v2 = v3;
  }
  size_t v4 = (EncoderLayer *)*((void *)this + 26);
  *((void *)this + 26) = 0;
  while (v4)
  {
    BOOL v5 = *(EncoderLayer **)v4;
    EncoderLayer::Destroy(v4);
    size_t v4 = v5;
  }
  uint64_t v6 = (void (*)(void, void))*((void *)this + 22);
  if (v6)
  {
    v6(*((void *)this + 19), *((void *)this + 21));
    *((void *)this + 22) = 0;
  }
  *((void *)this + 23) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 19) = 0;
}

void EncoderLayer::Destroy(EncoderLayer *this)
{
  int v2 = (void (*)(void))*((void *)this + 5);
  if (v2) {
    v2(*((void *)this + 6));
  }

  free(this);
}

uint64_t AXRCreateColorSpace(int8x16_t a1, __n128 a2, __n128 a3, float32x4_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9)
{
  float v13 = a3.n128_f32[0];
  v94[1] = *MEMORY[0x263EF8340];
  int8x16_t v80 = (int8x16_t)a2;
  float32x4_t v81 = (float32x4_t)a1;
  if (AXRCreateColorSpace::CGFunctionsInitialized == -1)
  {
    __n128 v14 = (__n128)a1;
    if (!a7) {
      goto LABEL_4;
    }
  }
  else
  {
    dispatch_once_f(&AXRCreateColorSpace::CGFunctionsInitialized, 0, (dispatch_function_t)InitCGFunctions);
    a2 = (__n128)v80;
    __n128 v14 = (__n128)v81;
    if (!a7) {
      goto LABEL_4;
    }
  }
  uint64_t TypeID = cfGetTypeID(a7, (__n128)a1, a2, a3, (__n128)a4, v14);
  uint64_t v16 = cfDictionaryGetTypeID();
  a2 = (__n128)v80;
  __n128 v14 = (__n128)v81;
  if (TypeID != v16) {
    AXRCreateColorSpace_cold_1(a8, v17, v18, v19, v20, v21, v22, v23);
  }
LABEL_4:
  unint64_t v24 = a6 & 0xFFFFFFFFFFFFFF0FLL;
  if (a9)
  {
    uint64_t v25 = 14;
    if (v24 <= 8 && ((1 << v24) & 0x114) != 0 || v24 == 1024) {
      goto LABEL_15;
    }
    if (v24 && (a6 & 0xFFFFFFFFFFFFFF01) == 0)
    {
      uint64_t v25 = 14;
      goto LABEL_15;
    }
  }
  if (v24 == 1792)
  {
    uint64_t v25 = a6;
  }
  else
  {
    uint64_t v25 = a6;
    if (v24 != 14) {
      goto LABEL_16;
    }
  }
LABEL_15:
  a3 = (__n128)xmmword_228F627B0;
  a4 = vmlaq_f32((float32x4_t)xmmword_228F627C0, (float32x4_t)xmmword_228F62790, (float32x4_t)a2);
  a1 = vandq_s8((int8x16_t)vcgeq_f32((float32x4_t)xmmword_228F627B0, vabsq_f32(a4)), (int8x16_t)vcgeq_f32((float32x4_t)xmmword_228F627B0, vabsq_f32(vmlaq_f32((float32x4_t)xmmword_228F627A0, (float32x4_t)xmmword_228F62790, (float32x4_t)v14))));
  a1.i32[0] = vminvq_u32((uint32x4_t)a1);
  a6 = v25;
  if (a1.i32[0] < 0) {
    goto LABEL_56;
  }
LABEL_16:
  uint64_t v26 = 0;
  int64_t v27 = a6 & 0xFFFFFFFFFFFFFF0FLL;
  if ((uint64_t)(a6 & 0xFFFFFFFFFFFFFF0FLL) <= 13)
  {
    if (v27 != 2 && v27 != 4 && v27 != 8) {
      return v26;
    }
    goto LABEL_24;
  }
  if (v27 <= 1791)
  {
    if (v27 != 14)
    {
      if (v27 != 1024) {
        return v26;
      }
LABEL_24:
      float v83 = v13;
      uint64_t Mutable = cfDictionaryCreateMutable(0, 0, kcfDictionaryKeyCallBacks, kcfDictionaryValueCallBacks, (__n128)a1, a2, a3, (__n128)a4, v14);
      if (Mutable)
      {
        uint64_t v63 = Mutable;
        cfDictionaryAddValue(Mutable, @"profileVersion", @"4.3.0");
        cfDictionaryAddValue(v63, @"profileType", @"calGray");
        cfDictionaryAddValue(v63, @"description", @"AppleEXR grayscale linear extended");
        int v82 = 1065353216;
        uint64_t v64 = cfNumberCreate(0, 12, &v82);
        if (v64)
        {
          uint64_t v65 = v64;
          cfDictionaryAddValue(v63, @"kGamma", v64);
          cfRelease(v65);
        }
        uint64_t v66 = cfNumberCreate(0, 12, &v83);
        if (v66)
        {
          uint64_t v67 = v66;
          cfDictionaryAddValue(v63, @"luminance", v66);
          cfRelease(v67);
        }
        *(float *)&uint64_t v91 = v81.f32[3] / *(float *)&v80.i32[3];
        HIDWORD(v91) = 1065353216;
        *(float *)&uint64_t v92 = (float)(1.0 - (float)(v81.f32[3] + *(float *)&v80.i32[3])) / *(float *)&v80.i32[3];
        uint64_t v68 = cfNumberCreate(0, 12, &v91);
        uint64_t v84 = v68;
        uint64_t v69 = cfNumberCreate(0, 12, (char *)&v91 + 4);
        float32x2_t v85 = (float32x2_t)v69;
        uint64_t v70 = cfNumberCreate(0, 12, &v92);
        uint64_t v71 = 0;
        uint64_t v86 = v70;
        if (v68 && v69 && v70)
        {
          uint64_t v71 = cfArrayCreate(0, &v84, 3, kcfTypeArrayCallBacks);
          uint64_t v68 = v84;
        }
        if (v68) {
          cfRelease(v68);
        }
        if (v85) {
          cfRelease(*(void *)&v85);
        }
        if (v86) {
          cfRelease(v86);
        }
        if (v71)
        {
          cfDictionaryAddValue(v63, @"wtpt", v71);
          cfRelease(v71);
        }
        uint64_t Profile = colorsyncMakeProfile(v63);
        cfRelease(v63);
        if (Profile)
        {
          if (a7)
          {
            int v72 = (uint64_t (*)(void, uint64_t, uint64_t))cfDictionaryCreateMutableCopy;
            uint64_t Count = cfDictionaryGetCount(a7);
            uint64_t v57 = v72(0, Count + 1, a7);
            uint64_t v58 = v57;
            if (v57) {
LABEL_55:
            }
              cfDictionaryAddValue(v57, @"kCGColorSpaceExtendedRange", kcfBooleanTrue);
          }
          else
          {
            uint64_t v84 = @"kCGColorSpaceExtendedRange";
            v94[0] = kcfBooleanTrue;
            uint64_t v58 = cfDictionaryCreate(0, &v84, v94, 1, kcfDictionaryKeyCallBacks, kcfDictionaryValueCallBacks);
          }
          goto LABEL_91;
        }
      }
      return 0;
    }
    goto LABEL_27;
  }
  if (v27 == 7168)
  {
LABEL_56:
    uint64_t v59 = colorsyncProfileCreateWithName(kcolorsyncGenericXYZProfile);
    uint64_t MutableCopy = colorsyncProfileCreateMutableCopy();
    cfRelease(v59);
    uint64_t v84 = 542792024;
    v85.i32[0] = 0;
    if (v13 >= 65536.0)
    {
      unsigned int v61 = 0x7FFFFFFF;
    }
    else if (v13 >= -65536.0)
    {
      unsigned int v61 = (int)rintf(v13 * 65536.0);
    }
    else
    {
      unsigned int v61 = -1;
    }
    v85.i32[1] = bswap32(v61);
    LODWORD(v86) = 0;
    uint64_t v74 = cfDataCreate(0, &v84, 20);
    colorsyncProfileSetTag(MutableCopy, @"lumi", v74);
    cfRelease(v74);
    colorsyncProfileRemoveTag(MutableCopy, @"dscm");
    colorsyncProfileSetDescriptionTag(MutableCopy, @"AppleEXR XYZ linear extended", 0);
    if (a7)
    {
      uint64_t v75 = (uint64_t (*)(void, uint64_t, uint64_t))cfDictionaryCreateMutableCopy;
      uint64_t v76 = cfDictionaryGetCount(a7);
      uint64_t v77 = v75(0, v76 + 1, a7);
      uint64_t v78 = v77;
      if (v77) {
        cfDictionaryAddValue(v77, @"kCGColorSpaceExtendedRange", kcfBooleanTrue);
      }
    }
    else
    {
      uint64_t v84 = @"kCGColorSpaceExtendedRange";
      uint64_t v91 = (__CFString *)kcfBooleanTrue;
      uint64_t v78 = cfDictionaryCreate(0, &v84, &v91, 1, kcfDictionaryKeyCallBacks, kcfDictionaryValueCallBacks);
    }
    uint64_t v26 = cgColorSpaceCreateWithColorSyncProfile(MutableCopy, v78);
    cfRelease(v78);
    cfRelease(MutableCopy);
    return v26;
  }
  if (v27 != 1792) {
    return v26;
  }
LABEL_27:
  float v83 = v13;
  uint64_t v28 = cfDictionaryCreateMutable(0, 0, kcfDictionaryKeyCallBacks, kcfDictionaryValueCallBacks, (__n128)a1, a2, a3, (__n128)a4, v14);
  if (!v28) {
    return 0;
  }
  uint64_t v29 = v28;
  cfDictionaryAddValue(v28, @"profileVersion", @"4.3.0");
  cfDictionaryAddValue(v29, @"profileType", @"calRGB");
  cfDictionaryAddValue(v29, @"description", @"AppleEXR RGB linear");
  int v82 = 1065353216;
  uint64_t v30 = cfNumberCreate(0, 12, &v82);
  if (v30)
  {
    uint64_t v31 = v30;
    cfDictionaryAddValue(v29, @"rGamma", v30);
    cfDictionaryAddValue(v29, @"gGamma", v31);
    cfDictionaryAddValue(v29, @"bGamma", v31);
    cfRelease(v31);
  }
  uint64_t v32 = cfNumberCreate(0, 12, &v83);
  if (v32)
  {
    uint64_t v33 = v32;
    cfDictionaryAddValue(v29, @"luminance", v32);
    cfRelease(v33);
  }
  uint64_t v34 = 0;
  int8x16_t v35 = (int8x16_t)v81;
  int32x2_t v36 = (int32x2_t)vextq_s8(v35, v35, 8uLL).u64[0];
  float32x2_t v37 = (float32x2_t)vrev64_s32(*(int32x2_t *)v80.i8);
  float32x2_t v38 = (float32x2_t)vextq_s8(v80, v80, 8uLL).u64[0];
  int32x2_t v39 = (int32x2_t)vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 4uLL), (float32x2_t)__PAIR64__(v81.u32[0], v36.u32[0]));
  float32x2_t v40 = vmul_f32(*(float32x2_t *)v80.i8, vmla_laneq_f32(vmla_f32(vmul_laneq_f32(vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 0xCuLL), (float32x2_t)vzip2_s32(*(int32x2_t *)v81.f32, v36)), (float32x4_t)v80, 2), v37, vsub_f32((float32x2_t)v36, (float32x2_t)vrev64_s32(v36))), (float32x2_t)v39, (float32x4_t)v80, 3));
  float32x2_t v41 = (float32x2_t)vdup_lane_s32(v39, 0);
  *(float *)v39.i32 = v81.f32[0] - v81.f32[1];
  v41.f32[0] = v81.f32[3] - v81.f32[0];
  int32x2_t v42 = (int32x2_t)vmul_f32((float32x2_t)__PAIR64__(v80.u32[1], v38.u32[0]), (float32x2_t)v39);
  float32x2_t v43 = (float32x2_t)vdup_lane_s32(v42, 0);
  *(float *)v42.i32 = (float)(v81.f32[1] - v81.f32[3]) * *(float *)v80.i32;
  v43.i32[0] = vmuls_lane_f32(v81.f32[0] - v81.f32[1], (float32x4_t)v80, 3);
  int32x2_t v44 = (int32x2_t)vmul_f32(v38, vadd_f32(v43, vmla_f32((float32x2_t)v42, v37, v41)));
  float32x2_t v45 = (float32x2_t)vdup_lane_s32(v44, 1);
  float32x2_t v46 = vdiv_f32(v40, v45);
  *(float *)v44.i32 = vdiv_f32((float32x2_t)v44, v45).f32[0];
  *(float *)&uint64_t v84 = vmuls_n_f32(v81.f32[0], v46.f32[0]) / *(float *)v80.i32;
  HIDWORD(v84) = v46.i32[0];
  v45.i32[1] = v81.i32[1];
  v45.f32[0] = 1.0 - vaddq_f32(v81, (float32x4_t)v80).f32[0];
  float32x2_t v85 = vdiv_f32(vmul_f32(v45, v46), *(float32x2_t *)v80.i8);
  LODWORD(v86) = v46.i32[1];
  *((float *)&v86 + 1) = vmuls_lane_f32(1.0 - (float)(v81.f32[1] + *(float *)&v80.i32[1]), v46, 1)
                       / *(float *)&v80.i32[1];
  unint64_t v87 = __PAIR64__(v44.u32[0], vmuls_lane_f32(*(float *)v44.i32, v81, 2) / *(float *)&v80.i32[2]);
  *(float *)v36.i32 = (float)(1.0 - (float)(v81.f32[2] + *(float *)&v80.i32[2])) * *(float *)v44.i32;
  float32x2_t v88 = vdiv_f32((float32x2_t)v36, v38);
  int v89 = 1065353216;
  float v90 = (float)(1.0 - (float)(v81.f32[3] + *(float *)&v80.i32[3])) / *(float *)&v80.i32[3];
  unsigned int v47 = _ZZL19CreateRGBColorSpaceDv4_fS_fPK14__CFDictionary11axr_flags_tE10colorNames;
  do
  {
    uint64_t v48 = cfNumberCreate(0, 12, (char *)&v84 + v34);
    uint64_t v91 = (__CFString *)v48;
    uint64_t v49 = cfNumberCreate(0, 12, (char *)&v84 + v34 + 4);
    uint64_t v92 = v49;
    uint64_t v50 = cfNumberCreate(0, 12, (char *)&v84 + v34 + 8);
    uint64_t v93 = v50;
    if (v48) {
      BOOL v51 = v49 == 0;
    }
    else {
      BOOL v51 = 1;
    }
    if (!v51 && v50 != 0)
    {
      uint64_t v53 = cfArrayCreate(0, &v91, 3, kcfTypeArrayCallBacks);
      uint64_t v48 = (uint64_t)v91;
      if (!v91) {
        goto LABEL_45;
      }
LABEL_44:
      cfRelease(v48);
      goto LABEL_45;
    }
    uint64_t v53 = 0;
    if (v48) {
      goto LABEL_44;
    }
LABEL_45:
    if (v92) {
      cfRelease(v92);
    }
    if (v93) {
      cfRelease(v93);
    }
    if (v53)
    {
      cfDictionaryAddValue(v29, *v47, v53);
      cfRelease(v53);
    }
    v34 += 12;
    ++v47;
  }
  while (v34 != 48);
  uint64_t Profile = colorsyncMakeProfile(v29);
  cfRelease(v29);
  if (!Profile) {
    return 0;
  }
  if (a7)
  {
    unsigned int v55 = (uint64_t (*)(void, uint64_t, uint64_t))cfDictionaryCreateMutableCopy;
    uint64_t v56 = cfDictionaryGetCount(a7);
    uint64_t v57 = v55(0, v56 + 1, a7);
    uint64_t v58 = v57;
    if (v57) {
      goto LABEL_55;
    }
  }
  else
  {
    uint64_t v91 = @"kCGColorSpaceExtendedRange";
    v94[0] = kcfBooleanTrue;
    uint64_t v58 = cfDictionaryCreate(0, &v91, v94, 1, kcfDictionaryKeyCallBacks, kcfDictionaryValueCallBacks);
  }
LABEL_91:
  uint64_t v26 = cgColorSpaceCreateWithColorSyncProfile(Profile, v58);
  cfRelease(v58);
  cfRelease(Profile);
  return v26;
}

void InitCGFunctions(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = dlopen("/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation", 261);
  if (v9)
  {
    uint64_t v17 = v9;
    cfGetuint64_t TypeID = dlsym(v9, "CFGetTypeID");
    cfDictionaryGetuint64_t TypeID = dlsym(v17, "CFDictionaryGetTypeID");
    cfRelease = dlsym(v17, "CFRelease");
    cfDictionaryCreateuint64_t Mutable = dlsym(v17, "CFDictionaryCreateMutable");
    cfDictionaryAddValue = dlsym(v17, "CFDictionaryAddValue");
    cfNumberCreate = dlsym(v17, "CFNumberCreate");
    cfArrayCreate = dlsym(v17, "CFArrayCreate");
    cfDataCreate = dlsym(v17, "CFDataCreate");
    cfDictionaryCreate = dlsym(v17, "CFDictionaryCreate");
    cfDictionaryCreateuint64_t MutableCopy = dlsym(v17, "CFDictionaryCreateMutableCopy");
    cfDictionaryGetuint64_t Count = dlsym(v17, "CFDictionaryGetCount");
    kcfDictionaryKeyCallBacks = (uint64_t)dlsym(v17, "kCFTypeDictionaryKeyCallBacks");
    kcfDictionaryValueCallBacks = (uint64_t)dlsym(v17, "kCFTypeDictionaryValueCallBacks");
    kcfTypeArrayCallBacks = (uint64_t)dlsym(v17, "kCFTypeArrayCallBacks");
    uint64_t v18 = (uint64_t *)dlsym(v17, "kCFBooleanTrue");
    if (v18) {
      uint64_t v19 = *v18;
    }
    else {
      uint64_t v19 = 0;
    }
    kcfBooleanTrue = v19;
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogDebug((uint64_t)"AppleEXR: internal error -- failed to locate CoreFoundation", v10, v11, v12, v13, v14, v15, v16, v46);
  }
  uint64_t v20 = dlopen("/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics", 261);
  if (v20)
  {
    uint64_t v28 = v20;
    cgColorSpaceCreateWithName = dlsym(v20, "CGColorSpaceCreateWithName");
    cgColorSpaceCreateWithColorSyncuint64_t Profile = dlsym(v28, "CGColorSpaceCreateWithColorSyncProfile");
    uint64_t v29 = (uint64_t *)dlsym(v28, "kCGColorSpaceExtendedLinearSRGB");
    if (v29) {
      uint64_t v30 = *v29;
    }
    else {
      uint64_t v30 = 0;
    }
    kcgColorSpaceExtendedLinearSRGB = v30;
    uint64_t v31 = (uint64_t *)dlsym(v28, "kCGColorSpaceGenericXYZ");
    if (v31) {
      uint64_t v32 = *v31;
    }
    else {
      uint64_t v32 = 0;
    }
    kcgColorSpaceGenericXYZ = v32;
    uint64_t v33 = (uint64_t *)dlsym(v28, "kCGColorSpaceExtendedLinearGray");
    if (v33) {
      uint64_t v34 = *v33;
    }
    else {
      uint64_t v34 = 0;
    }
    kcgColorSpaceExtendedLinearGray = v34;
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogDebug((uint64_t)"AppleEXR: internal error -- failed to locate CoreGraphics", v21, v22, v23, v24, v25, v26, v27, v46);
  }
  int8x16_t v35 = dlopen("/System/Library/PrivateFrameworks/ColorSync.framework/ColorSync", 261);
  if (v35)
  {
    float32x2_t v43 = v35;
    colorsyncMakeuint64_t Profile = dlsym(v35, "ColorSyncMakeProfile");
    colorsyncProfileCreateWithName = dlsym(v43, "ColorSyncProfileCreateWithName");
    colorsyncProfileCreateuint64_t MutableCopy = dlsym(v43, "ColorSyncProfileCreateMutableCopy");
    colorsyncProfileSetTag = dlsym(v43, "ColorSyncProfileSetTag");
    colorsyncProfileRemoveTag = dlsym(v43, "ColorSyncProfileRemoveTag");
    colorsyncProfileSetDescriptionTag = dlsym(v43, "ColorSyncProfileSetDescriptionTag");
    int32x2_t v44 = (uint64_t *)dlsym(v43, "kColorSyncGenericXYZProfile");
    if (v44) {
      uint64_t v45 = *v44;
    }
    else {
      uint64_t v45 = 0;
    }
    kcolorsyncGenericXYZuint64_t Profile = v45;
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    AXRLogDebug((uint64_t)"AppleEXR: internal error -- failed to locate ColorSync", v36, v37, v38, v39, v40, v41, v42, a9);
  }
}

const char *GetEXRNameForChannelType(unsigned int a1, int a2)
{
  if (a1 > 0xF) {
    return (const char *)&unk_228F63AF7;
  }
  if (a1 == 10 && a2 == 7) {
    return "G";
  }
  return (const char *)*(&GetEXRNameForChannelType::kDefaultChannelNames + a1);
}

void AXRLogDebug(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = (const char *)MEMORY[0x270FA5388](a1, a2);
  uint64_t v14 = *MEMORY[0x263EF8340];
  vsnprintf(__str, 0x1000uLL, v9, &a9);
  if (AXRGetLog_onceToken != -1) {
    dispatch_once_f(&AXRGetLog_onceToken, &AXRGetLog_log, (dispatch_function_t)GetOSLog);
  }
  uint64_t v10 = AXRGetLog_log;
  if (os_log_type_enabled((os_log_t)AXRGetLog_log, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v12 = __str;
    _os_log_impl(&dword_228EA2000, v10, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
  }
}

void AXRLogError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = (const char *)MEMORY[0x270FA5388]();
  uint64_t v14 = *MEMORY[0x263EF8340];
  vsnprintf(__str, 0x1000uLL, v9, &a9);
  if (AXRGetLog_onceToken != -1) {
    dispatch_once_f(&AXRGetLog_onceToken, &AXRGetLog_log, (dispatch_function_t)GetOSLog);
  }
  uint64_t v10 = AXRGetLog_log;
  if (os_log_type_enabled((os_log_t)AXRGetLog_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v12 = __str;
    _os_log_impl(&dword_228EA2000, v10, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
  }
}

char *InitializeDefaultFlags(void *a1)
{
  uint64_t result = getenv("AXR_PRINT_DEBUG_INFO");
  if (result)
  {
    int v3 = result;
    __endptr = result;
    uint64_t result = (char *)strtoull(result, &__endptr, 0);
    if (__endptr != v3 && result != 0) {
      *a1 |= 2uLL;
    }
  }
  return result;
}

os_log_t GetOSLog(os_log_t *a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  bzero(category, 0x800uLL);
  size_t v3 = 2047;
  if (sysctlbyname("kern.procname", category, &v3, 0, 0)) {
    category[0] = 0;
  }
  os_log_t result = os_log_create("com.apple.AppleEXR", category);
  *a1 = result;
  return result;
}

axr_encoder_t axr_encoder_create(axr_flags_t flags)
{
  objc_opt_class();
  axr_encoder_t result = (axr_encoder_t)_os_object_alloc();
  if (result)
  {
    result[2].uint64_t isa = (Class)flags;
    result[3].uint64_t isa = 0;
  }
  return result;
}

axr_part_t axr_encoder_append_part(axr_encoder_t encoder, const char *partName, const char *viewName, axr_compression_t compression, axr_box2i_t dataWindow, axr_box2i_t displayWindow, axr_line_order_t lineOrder, float pixelAspectRatio, float screenWindowCenterX, float screenWindowCenterY, float screenWindowWidth, float xDensity, uint32_t tileWidth, uint32_t tileHeight, axr_level_mode_t levelMode)
{
  if (!encoder) {
    axr_encoder_append_part_cold_1(0, (uint64_t)partName, (uint64_t)viewName, *(uint64_t *)&compression, *(uint64_t *)&dataWindow.xMin, *(uint64_t *)&dataWindow.yMin, *(uint64_t *)&displayWindow.xMin, *(uint64_t *)&displayWindow.yMin);
  }
  Class isa = encoder[2].isa;
  uint64_t v18 = *(const char **)&compression;
  uint64_t v19 = *(void *)&dataWindow.xMin;
  *(void *)&v26.xMin = *(void *)&dataWindow.yMin;
  *(void *)&v26.char yMin = *(void *)&displayWindow.xMin;
  *(void *)&v27.xMin = *(void *)&displayWindow.yMin;
  *(void *)&v27.char yMin = lineOrder;
  axr_part_t result = (axr_part_t)EncoderPart::CreateEncoderPart((EncoderPart *)partName, viewName, v18, v19, v26, v27, pixelAspectRatio, screenWindowCenterX, screenWindowCenterY, screenWindowWidth, xDensity, (axr_line_order_t)tileWidth, tileHeight, levelMode, v24, (axr_flags_t)isa);
  if (result)
  {
    uint64_t v21 = (objc_class *)&result[2];
    Class v22 = encoder[3].isa;
    if (v22)
    {
      do
      {
        uint64_t v23 = v22;
        Class v22 = *(Class *)v22;
      }
      while (v22);
      *uint64_t v23 = v21;
    }
    else
    {
      encoder[3].Class isa = v21;
    }
  }
  return result;
}

axr_error_t axr_encoder_compress(axr_encoder_t encoder, axr_encoder_storage_t storage, axr_encoder_write_proc_t writeProc, axr_encoder_seek_proc_t seekProc, axr_encoder_storage_destroy_proc_t destroyProc, axr_flags_t flags)
{
  int v8 = flags;
  if (encoder)
  {
    if (storage)
    {
      if (writeProc)
      {
        Class isa = encoder[3].isa;
        if (isa)
        {
          int v10 = 0;
          int v11 = 0;
          uint64_t v12 = 0;
          do
          {
            v11 |= *((void *)isa + 25) > 0x1FuLL;
            int v10 = (v10 | (*((_DWORD *)isa + 60) >> 1)) & 1;
            ++v12;
            Class isa = *(Class *)isa;
          }
          while (isa);
          operator new();
        }
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
          AXRLogError((uint64_t)"axr_encoder_compress: no parts. Did you forget to call axr_encoder_append_part?", (uint64_t)storage, (uint64_t)writeProc, (uint64_t)seekProc, (uint64_t)destroyProc, flags, v6, v7, v16);
        }
        return -11;
      }
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v8) & 2) == 0) {
        return -1;
      }
      uint64_t v14 = "axr_encoder_compress: writeProc may not be NULL";
    }
    else
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v8) & 2) == 0) {
        return -1;
      }
      uint64_t v14 = "axr_encoder_compress: storage may not be NULL";
    }
    AXRLogError((uint64_t)v14, (uint64_t)storage, (uint64_t)writeProc, (uint64_t)seekProc, (uint64_t)destroyProc, flags, v6, v7, v16);
    return -1;
  }
  if (GetFlagsOnceToken != -1) {
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
  if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
    AXRLogDebug((uint64_t)"axr_encoder_compress:warning: called with NULL encoder.  Ignored.", (uint64_t)storage, (uint64_t)writeProc, (uint64_t)seekProc, (uint64_t)destroyProc, flags, v6, v7, v16);
  }
  return 0;
}

void axr_encoder::~axr_encoder(axr_encoder *this)
{
  for (uint64_t i = (void *)*((void *)this + 3); i; uint64_t i = v2)
  {
    int v2 = (void *)*i;
  }
}

void EncoderStream::~EncoderStream(EncoderStream *this)
{
  EncoderStream::~EncoderStream(this);

  JUMPOUT(0x22A6AD870);
}

{
  void (*v2)(void);
  uint64_t v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_26DD4BDF8;
  int v2 = (void (*)(void))*((void *)this + 6);
  if (v2) {
    v2(*((void *)this + 3));
  }
  size_t v3 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v3)
  {
    do
    {
      size_t v4 = *(void *)(v3 + 16);
      if (atomic_fetch_add((atomic_ullong *volatile)(v3 + 8), 0xFFFFFFFFFFFFFFFFLL) == 1) {
        (**(void (***)(uint64_t))v3)(v3);
      }
      size_t v3 = v4;
    }
    while (v4);
  }

  EncoderBufferCache::~EncoderBufferCache(this);
}

float Part::GetImageInfo@<S0>(Part *this@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *((unsigned __int8 *)this + 164);
  float32x2x2_t v4 = *(float32x2x2_t *)((char *)this + 40);
  unint64_t v5 = vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u64[0];
  uint64_t v6 = (float *)a3;
  vst2_f32(v6, v4);
  v6 += 4;
  float32x2x2_t v7 = *(float32x2x2_t *)((char *)this + 56);
  unint64_t v8 = vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL).u64[0];
  vst2_f32(v6, v7);
  *(void *)(a3 + 32) = *(void *)((char *)this + 156);
  LODWORD(v8) = *((_DWORD *)this + 23);
  *(_DWORD *)(a3 + 48) = *((_DWORD *)this + 22);
  *(void *)(a3 + 52) = *((void *)this + 10);
  v7.val[0].i32[0] = *((_DWORD *)this + 26);
  int v9 = *((_DWORD *)this + 27);
  *(_DWORD *)(a3 + 60) = v8;
  *(_DWORD *)(a3 + 64) = v7.val[0].i32[0];
  LODWORD(v8) = *((_DWORD *)this + 29);
  int v10 = *((_DWORD *)this + 30);
  int v11 = *((_DWORD *)this + 31);
  *(_DWORD *)(a3 + 68) = *((_DWORD *)this + 28);
  *(_DWORD *)(a3 + 72) = v10;
  int v12 = *((_DWORD *)this + 33);
  *(_DWORD *)(a3 + 76) = *((_DWORD *)this + 32);
  *(_DWORD *)(a3 + 80) = v9;
  int v13 = *((_DWORD *)this + 18);
  *(_DWORD *)(a3 + 40) = *((_DWORD *)this + 9);
  *(_DWORD *)(a3 + 44) = v13;
  *(_DWORD *)(a3 + 84) = v8;
  *(_DWORD *)(a3 + 88) = v11;
  *(_DWORD *)(a3 + 92) = v12;
  LODWORD(v6) = *((_DWORD *)this + 66);
  int v14 = *((_DWORD *)this + 67);
  *(_DWORD *)(a3 + 96) = v6;
  *(_DWORD *)(a3 + 100) = v14;
  if (v14 * v6) {
    uint64_t v15 = &a2[*((void *)this + 34)];
  }
  else {
    uint64_t v15 = 0;
  }
  *(void *)(a3 + 104) = v15;
  *(int8x16_t *)(a3 + 112) = vextq_s8(*(int8x16_t *)((char *)this + 184), *(int8x16_t *)((char *)this + 184), 8uLL);
  *(_DWORD *)(a3 + 128) = v3;
  float result = *((float *)this + 24) * *((float *)this + 25);
  *(float *)(a3 + 132) = result;
  return result;
}

char *Part::GetChannelInfo@<X0>(Part *this@<X0>, const char *a2@<X1>, uint64_t a3@<X3>, unint64_t a4@<X2>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  Channel = (ChannelDescription *)Part::GetChannel(this, a4, a3, a3, a5, a6, a7, a8);

  return ChannelDescription::GetChannelInfo(Channel, a2, a9);
}

uint64_t Part::GetChannel(Part *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((unsigned int *)this + 8) <= a2 || (uint64_t v8 = *((void *)this + 3)) == 0)
  {
    if (GetFlagsOnceToken != -1)
    {
      unint64_t v12 = a2;
      uint64_t v11 = a3;
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      a3 = v11;
      a2 = v12;
    }
    if (((kDefaultAXRLogFlags | a3) & 2) != 0) {
      AXRLogError((uint64_t)"Error: channel index (%lu) is out of bounds.", a2, a3, a4, a5, a6, a7, a8, a2);
    }
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x263F8C258], 0);
  }
  return *(void *)(v8 + 8 * a2);
}

uint64_t *Part::GetImageProperty@<X0>(Part *this@<X0>, char *a2@<X1>, uint64_t a3@<X3>, unint64_t a4@<X2>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, char **a9@<X8>)
{
  float result = (uint64_t *)Part::GetProperty(this, a4, a3, a3, a5, a6, a7, a8);
  uint64_t v12 = *result;
  uint64_t v13 = result[3];
  int v14 = &a2[*result];
  BOOL v15 = *result == v13;
  if (*result == v13) {
    int v14 = 0;
  }
  *a9 = v14;
  if (v15) {
    char v16 = 0;
  }
  else {
    char v16 = &a2[result[1]];
  }
  uint64_t v17 = (char *)result[2];
  a9[1] = v16;
  a9[2] = v17;
  if (v12 == v13) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = &a2[v13];
  }
  uint64_t v19 = (char *)result[4];
  a9[3] = v18;
  a9[4] = v19;
  return result;
}

uint64_t Part::GetProperty(Part *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *((void *)this + 30);
  if (result) {
    BOOL v9 = a2 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    unint64_t v10 = 1;
    do
    {
      uint64_t result = *(void *)(result + 40);
      if (result) {
        BOOL v11 = v10 >= a2;
      }
      else {
        BOOL v11 = 1;
      }
      ++v10;
    }
    while (!v11);
  }
  if (!result) {
    Part::GetProperty(a2, a3, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t Part::GetLayerInfo@<X0>(uint64_t this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(unsigned int *)(this + 152) <= a2)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    uint64_t v3 = *(void *)(this + 144) + 24 * a2;
    *(_OWORD *)a3 = *(_OWORD *)v3;
    a3[2] = *(void *)(v3 + 16);
  }
  return this;
}

unsigned char *AppleEXRDestinationNotWritable(unsigned char *result)
{
  *uint64_t result = 0;
  return result;
}

uint64_t AppleEXRDestinationNotBigEnough(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    if (a4) {
      *(unsigned char *)(result + (a3 - 1) * a2 + a5 * a4 - 1) = 0;
    }
  }
  return result;
}

axr_error_t Part::ReadPixels(Part *this, axr_decoder *a2, unsigned char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *((_DWORD *)a2 + 14);
  if (!v8) {
    return 0;
  }
  unsigned int v10 = *((_DWORD *)a2 + 15);
  if (!v10 || !*((void *)a2 + 3)) {
    return 0;
  }
  int v14 = *((_DWORD *)this + 12);
  int v13 = *((_DWORD *)this + 13);
  int v16 = *((_DWORD *)this + 10);
  int v15 = *((_DWORD *)this + 11);
  BOOL v17 = __OFSUB__(v14, v16);
  int v18 = v14 - v16;
  if (v18 < 0 != v17) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = v18 + 1;
  }
  if (v13 >= v15) {
    unsigned int v20 = v13 - v15 + 1;
  }
  else {
    unsigned int v20 = 0;
  }
  if (v8 > v19 || v10 > v20)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a5) & 2) != 0) {
      AXRLogError((uint64_t)"region extent {%d, %d} lies outside the data window (size = {%d, %d})\n", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, *((_DWORD *)a2 + 14));
    }
    return -1;
  }
  AppleEXRDestinationNotWritable(a3);
  uint64_t v29 = *((void *)a2 + 3);
  if (v29)
  {
    while (*(unsigned char *)(v29 + 24))
    {
      uint64_t v29 = *(void *)(v29 + 8);
      if (!v29) {
        goto LABEL_17;
      }
    }
    if (*(_DWORD *)(v29 + 16) == 1) {
      unsigned int v30 = 2;
    }
    else {
      unsigned int v30 = 4;
    }
  }
  else
  {
LABEL_17:
    unsigned int v30 = 0;
  }
  uint64_t v31 = v30 * (unint64_t)*((unsigned int *)a2 + 8);
  uint64_t v32 = *((unsigned int *)a2 + 14);
  if (v31 * v32 > a4)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | a5) & 2) != 0) {
      AXRLogError((uint64_t)"%s error: expected rowBytes for channel size (%lu) x channel count (%u) x width (%u) = %lu bytes\n\tThe provided destination row bytes is only %lu and the data will not fit.\n\tSkipping operation.", v24, v25, v32, v31, v26, v27, v28, (char)"ReadPixels");
    }
    return -1;
  }
  AppleEXRDestinationNotBigEnough((uint64_t)a3, a4, *((unsigned int *)a2 + 15), v32, v31);
  axr_error_t v45 = axr_error_success;
  TileDecoder_storage::Init((TileDecoder_storage *)&vars0, *((axr_compression_t *)this + 9), a2, this, a5, &v45, v34, v35);
  axr_error_t IsInterleavedValid = v45;
  if (v45 == axr_error_success)
  {
    uint64_t v42 = v36;
    *(void *)int32x2_t v44 = 0;
    axr_error_t IsInterleavedValid = TileDecoder::IsInterleavedValid(v36, &v44[1], v44, v37, v38, v39, v40, v41);
    axr_error_t v45 = IsInterleavedValid;
    if (IsInterleavedValid == axr_error_success) {
      axr_error_t IsInterleavedValid = TileDecoder::ReadPixels(v42, v44[1], v44[0], (uint64_t)a3, a4);
    }
  }
  (*vars0)(&vars0);
  return IsInterleavedValid;
}

void sub_228F29EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void (**a17)(void))
{
}

void Part::GetReadPixelsInfo(axr_decoder *a1@<X1>, uint64_t a2@<X8>)
{
  if (a1)
  {
    uint64_t v4 = *((void *)a1 + 7);
    uint64_t v5 = *((void *)a1 + 3);
    if (v5)
    {
      while (*(unsigned char *)(v5 + 24))
      {
        uint64_t v5 = *(void *)(v5 + 8);
        if (!v5) {
          goto LABEL_5;
        }
      }
      int v7 = *(_DWORD *)(v5 + 16);
      if (v7 == 1) {
        int v6 = 16;
      }
      else {
        int v6 = 32;
      }
    }
    else
    {
LABEL_5:
      int v6 = 0;
      int v7 = 1;
    }
    unsigned int v8 = *((_DWORD *)a1 + 8) * v6;
    *(void *)a2 = v4;
    *(void *)(a2 + 8) = (v8 * (unint64_t)v4) >> 3;
    *(_DWORD *)(a2 + 16) = v6;
    *(_DWORD *)(a2 + 20) = v8;
    *(_DWORD *)(a2 + 24) = v7;
  }
  else
  {
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
}

#error "228F2A93C: call analysis failed (funcsize=1043)"

void sub_228F2B23C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void (**a25)(void))
{
}

uint64_t AXRDecoderExtractChannel(axr_decoder *a1, axr_channel_type_t a2)
{
  uint64_t v4 = (void *)((char *)a1 + 24);
  uint64_t result = *((void *)a1 + 3);
  if (result)
  {
    if (*(_DWORD *)(result + 20) == a2)
    {
      uint64_t v5 = 0;
LABEL_6:
      if (v5) {
        uint64_t v4 = (void *)(v5 + 8);
      }
      *uint64_t v4 = *(void *)(result + 8);
      *(void *)(result + 8) = 0;
      --*((_DWORD *)a1 + 8);
    }
    else
    {
      while (1)
      {
        uint64_t v5 = result;
        uint64_t result = *(void *)(result + 8);
        if (!result) {
          break;
        }
        if (*(_DWORD *)(result + 20) == a2) {
          goto LABEL_6;
        }
      }
    }
  }
  return result;
}

void Part::GetReadRGBAPixelsInfo(axr_decoder *a1@<X1>, uint64_t a2@<X8>)
{
  if (a1)
  {
    uint64_t v5 = *((void *)a1 + 7);
    uint64_t v6 = *((void *)a1 + 3);
    if (v6)
    {
      while (*(unsigned char *)(v6 + 24))
      {
        uint64_t v6 = *(void *)(v6 + 8);
        if (!v6) {
          goto LABEL_5;
        }
      }
      int v8 = *(_DWORD *)(v6 + 16);
      if (v8 == 1) {
        int v7 = 16;
      }
      else {
        int v7 = 32;
      }
    }
    else
    {
LABEL_5:
      int v7 = 0;
      int v8 = 1;
    }
    *(void *)a2 = v5;
    *(void *)(a2 + 8) = ((4 * v7) * (unint64_t)v5) >> 3;
    *(_DWORD *)(a2 + 16) = v7;
    *(_DWORD *)(a2 + 20) = 4 * v7;
    *(_DWORD *)(a2 + 24) = v8;
  }
  else
  {
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
}

unint64_t Part::ReadPlanes(Part *this, axr_decoder *a2, axr_pixel_data_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, axr_error_t a12, void (**a13)(void), uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  a40 = *MEMORY[0x263EF8340];
  int v40 = *((_DWORD *)a2 + 14);
  if (!v40) {
    return 0;
  }
  if (!*((_DWORD *)a2 + 15)) {
    return 0;
  }
  uint64_t v42 = (unsigned int *)*((void *)a2 + 3);
  if (!v42) {
    return 0;
  }
  axr_flags_t v43 = a4;
  int32x2_t v44 = a3;
  axr_error_t v45 = this;
  if (*((_DWORD *)a2 + 8))
  {
    unint64_t v46 = 0;
    p_rowBytes = &a3->rowBytes;
    while (*(p_rowBytes - 1))
    {
      unsigned int v48 = v42[4];
      if (v48 == 1) {
        uint64_t v49 = 2;
      }
      else {
        uint64_t v49 = 4;
      }
      unint64_t v50 = *((unsigned int *)a2 + 14);
      unint64_t v51 = *((unsigned int *)a2 + 15);
      if (!*((unsigned char *)v42 + 24))
      {
        uint64_t Channel = Part::GetChannel(v45, *v42, v43, a4, a5, a6, a7, a8);
        unint64_t v54 = *(unsigned int *)(Channel + 80);
        if (v54 >= 2)
        {
          unint64_t v55 = *(unsigned int *)(Channel + 104);
          if (*((_DWORD *)a2 + 13) % v55)
          {
            if (GetFlagsOnceToken != -1) {
              dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
            }
            if (((kDefaultAXRLogFlags | a4) & 2) != 0) {
              AXRLogError((uint64_t)"axr_decoder_read_planes error: the y origin of the region of interest (%u) is\n\tnot aligned with the sampling rate for the channel %lu, (%u)\tSkipping operation.", v53, (uint64_t)a3, a4, a5, a6, a7, a8, *((_DWORD *)a2 + 13));
            }
            return -1;
          }
          if (*((_DWORD *)a2 + 12) % v54)
          {
            if (GetFlagsOnceToken != -1) {
              dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
            }
            if (((kDefaultAXRLogFlags | a4) & 2) != 0) {
              AXRLogError((uint64_t)"axr_decoder_read_planes error: the x origin of the region of interest (%u) is\n\tnot aligned with the sampling rate for the channel %lu, (%u)\tSkipping operation.", v53, (uint64_t)a3, a4, a5, a6, a7, a8, *((_DWORD *)a2 + 12));
            }
            return -1;
          }
          unint64_t v51 = (v51 + v55 - 1) / v55;
          unint64_t v50 = (v50 + v54 - 1) / v54;
          axr_flags_t v43 = a4;
        }
        axr_error_t v45 = this;
      }
      char v56 = 1;
      if (v48 != 1) {
        char v56 = 2;
      }
      uint64_t v57 = *p_rowBytes;
      if (v50 << v56 > *p_rowBytes)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | v43) & 2) != 0) {
          AXRLogError((uint64_t)"axr_decoder_read_planes error: expected rowBytes for channel size (%lu) x width (%u) = %lu bytes\n\tThe provided destination row bytes for plane %lu is only %lu and the data will not fit.\n\tSkipping operation.", v57, (uint64_t)a3, a4, a5, a6, a7, a8, v49);
        }
        return -1;
      }
      AppleEXRDestinationNotBigEnough(*(p_rowBytes - 1), v57, v51, v50, v49);
      uint64_t v42 = (unsigned int *)*((void *)v42 + 1);
      ++v46;
      p_rowBytes += 2;
      if (v46 >= *((unsigned int *)a2 + 8))
      {
        int v40 = *((_DWORD *)a2 + 14);
        int32x2_t v44 = a3;
        goto LABEL_21;
      }
    }
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v43) & 2) != 0) {
      AXRLogError((uint64_t)"axr_decoder_read_planes error: destinationPlaneList[%lu].data = NULL", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v46);
    }
    return -7;
  }
  else
  {
LABEL_21:
    unsigned int v58 = v40 + *((_DWORD *)a2 + 12);
    int v59 = *((_DWORD *)v45 + 12);
    int v60 = *((_DWORD *)v45 + 10);
    BOOL v61 = __OFSUB__(v59, v60);
    int v62 = v59 - v60;
    if (v62 < 0 != v61) {
      unsigned int v63 = 0;
    }
    else {
      unsigned int v63 = v62 + 1;
    }
    if (v58 > v63
      || ((int v64 = *((_DWORD *)v45 + 13),
           int v65 = *((_DWORD *)v45 + 11),
           BOOL v61 = __OFSUB__(v64, v65),
           int v66 = v64 - v65,
           v66 < 0 == v61)
        ? (unsigned int v67 = v66 + 1)
        : (unsigned int v67 = 0),
          *((_DWORD *)a2 + 15) + *((_DWORD *)a2 + 13) > v67))
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v43) & 2) != 0) {
        AXRLogError((uint64_t)"region extent {%d, %d} lies outside the data window (size = {%d, %d})\n", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, *((_DWORD *)a2 + 14));
      }
      return -1;
    }
    else
    {
      a12 = axr_error_success;
      TileDecoder_storage::Init((TileDecoder_storage *)&a13, *((axr_compression_t *)v45 + 9), a2, v45, v43, &a12, a7, a8);
      unint64_t Planes = a12;
      if (a12 == axr_error_success) {
        unint64_t Planes = TileDecoder::ReadPlanes(v68, v44, v69, v70, v71, v72, v73, v74);
      }
      (*a13)(&a13);
    }
  }
  return Planes;
}

void sub_228F2B7CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void (**a25)(void))
{
}

void Part::GetReadPlanesInfo(axr_decoder *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a1)
  {
    uint64_t v5 = *((void *)a1 + 7);
    uint64_t v6 = *((void *)a1 + 3);
    if (!v6) {
      goto LABEL_9;
    }
    uint64_t v7 = a2 + 1;
    while (--v7)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6) {
        goto LABEL_9;
      }
    }
    if (!*(unsigned char *)(v6 + 24))
    {
      int v9 = *(_DWORD *)(v6 + 16);
      if (v9 == 1) {
        unsigned int v8 = 16;
      }
      else {
        unsigned int v8 = 32;
      }
    }
    else
    {
LABEL_9:
      unsigned int v8 = 0;
      int v9 = 1;
    }
    *(void *)a3 = v5;
    *(void *)(a3 + 8) = (v8 * (unint64_t)v5) >> 3;
    *(_DWORD *)(a3 + 16) = v8;
    *(_DWORD *)(a3 + 20) = v8;
    *(_DWORD *)(a3 + 24) = v9;
  }
  else
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
}

uint64_t Part::Init(Part *this, char *a2, unint64_t a3, unint64_t *a4, axr_flags_t a5)
{
  *((void *)this + 16) = 0x3EA872B03EA01A37;
  *((_DWORD *)this + 53) = 1;
  *(void *)this = a3;
  *((_DWORD *)this + 34) = 1120403456;
  *((_OWORD *)this + 6) = xmmword_228F629E0;
  *((_OWORD *)this + 7) = xmmword_228F629D0;
  int v9 = *((_DWORD *)a2 + 1);
  if ((v9 & 0x200) != 0 && (v9 & 0x1800) != 0) {
    return -6;
  }
  uint64_t v142 = 0;
  long long v140 = 0u;
  long long v141 = 0u;
  unint64_t v139 = 0;
  unint64_t v11 = Attribute::Init((Attribute *)&v140, a2, a3, *a4);
  *a4 = v11;
  if ((void)v140 != *((void *)&v141 + 1))
  {
    uint64_t v134 = 0;
    uint64_t v135 = 0;
    uint64_t v133 = 0;
    uint64_t v136 = 0;
    while (1)
    {
      uint64_t result = Part::AbsorbAttribute(this, a2, (Attribute *)&v140, &v139, a5);
      if (result) {
        return result;
      }
      unint64_t v23 = *((void *)&v141 + 1);
      long long v24 = v140;
      if ((void)v140 == *((void *)&v141 + 1)) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = &a2[v140];
      }
      if (*((void *)&v140 + 1) >= (unint64_t)v140) {
        size_t v26 = *((void *)&v140 + 1) - v140;
      }
      else {
        size_t v26 = 0;
      }
      if (!strncmp(v25, "compression", v26)
        && ((void)v24 != v23 ? (uint64_t v27 = &a2[*((void *)&v24 + 1)]) : (uint64_t v27 = 0),
            v23 >= *((void *)&v24 + 1) ? (size_t v28 = v23 - *((void *)&v24 + 1)) : (size_t v28 = 0),
            !strncmp(v27, "compression", v28)))
      {
        ++v135;
      }
      else if (!strncmp(v25, "channels", v26) {
             && ((void)v24 != v23 ? (uint64_t v29 = &a2[*((void *)&v24 + 1)]) : (uint64_t v29 = 0),
      }
                 v23 >= *((void *)&v24 + 1) ? (size_t v30 = v23 - *((void *)&v24 + 1)) : (size_t v30 = 0),
                 !strncmp(v29, "chlist", v30)))
      {
        ++v134;
      }
      else if (!strncmp(v25, "dataWindow", v26) {
             && ((void)v24 != v23 ? (uint64_t v31 = &a2[*((void *)&v24 + 1)]) : (uint64_t v31 = 0),
      }
                 v23 >= *((void *)&v24 + 1) ? (size_t v32 = v23 - *((void *)&v24 + 1)) : (size_t v32 = 0),
                 !strncmp(v31, "box2i", v32)))
      {
        ++v133;
      }
      else if (!strncmp(v25, "displayWindow", v26))
      {
        if ((void)v24 == v23) {
          uint64_t v33 = 0;
        }
        else {
          uint64_t v33 = &a2[*((void *)&v24 + 1)];
        }
        if (v23 >= *((void *)&v24 + 1)) {
          size_t v34 = v23 - *((void *)&v24 + 1);
        }
        else {
          size_t v34 = 0;
        }
        int v35 = strncmp(v33, "box2i", v34);
        uint64_t v36 = v136;
        if (!v35) {
          uint64_t v36 = v136 + 1;
        }
        uint64_t v136 = v36;
      }
      unint64_t v11 = Attribute::Init((Attribute *)&v140, a2, a3, *a4);
      *a4 = v11;
      if ((void)v140 == *((void *)&v141 + 1))
      {
        uint64_t v22 = v135;
        uint64_t v19 = v136;
        uint64_t v20 = v133;
        uint64_t v21 = v134;
        goto LABEL_54;
      }
    }
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
LABEL_54:
  *a4 = v11 + 1;
  uint64_t result = -6;
  if (!v22 || !v21 || !v20 || !v19) {
    return result;
  }
  uint64_t v37 = *((void *)this + 30);
  if (v37)
  {
    uint64_t v38 = 0;
    do
    {
      uint64_t v39 = v37;
      uint64_t v37 = *(void *)(v37 + 40);
      *(void *)(v39 + 40) = v38;
      uint64_t v38 = v39;
    }
    while (v37);
  }
  else
  {
    uint64_t v39 = 0;
  }
  int v40 = *((_DWORD *)this + 27);
  int v41 = *((_DWORD *)this + 28);
  int v42 = *((_DWORD *)this + 29);
  v138[0] = *((_DWORD *)this + 26);
  v138[1] = v41;
  int v43 = *((_DWORD *)this + 31);
  int v44 = *((_DWORD *)this + 32);
  int v45 = *((_DWORD *)this + 33);
  v138[2] = *((_DWORD *)this + 30);
  v138[3] = v44;
  v138[4] = v40;
  v138[5] = v42;
  *((void *)this + 30) = v39;
  v138[6] = v43;
  v138[7] = v45;
  for (uint64_t i = *((void *)this + 2); i; uint64_t i = *(void *)(i + 8))
  {
    uint64_t result = ChannelDescription::IdentifyChannels(i, (uint64_t)v138);
    if (result) {
      return result;
    }
  }
  *((_DWORD *)this + 38) = 0;
  unsigned int v47 = (void *)*((void *)this + 18);
  if (v47)
  {
    int v48 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    do
    {
      unsigned int v52 = v47;
      v51 += v47[2] + 1;
      v50 += v47[4];
      unsigned int v47 = (void *)*v47;
      void *v52 = v49;
      --v48;
      uint64_t v49 = v52;
    }
    while (v47);
    *((_DWORD *)this + 38) = -v48;
    if (v48)
    {
      uint64_t v53 = (char *)malloc_type_malloc(v51 + 4 * v50 + 24 * -v48, 0x245AE8F9uLL);
      if (!v53)
      {
        do
        {
          uint64_t v75 = (void *)*v52;
          free(v52);
          unsigned int v52 = v75;
        }
        while (v75);
        return -5;
      }
      unint64_t v54 = v53;
      uint64_t v55 = 0;
      char v56 = &v53[24 * *((unsigned int *)this + 38)];
      uint64_t v57 = &v56[4 * v50];
      do
      {
        unsigned int v58 = (void *)*v52;
        memcpy(v57, (const void *)v52[1], v52[2]);
        v57[v52[2]] = 0;
        int v59 = &v54[24 * v55];
        *(void *)int v59 = v57;
        uint64_t v60 = v52[2];
        *((void *)v59 + 1) = v56;
        *((void *)v59 + 2) = 0;
        BOOL v61 = v59 + 16;
        uint64_t v63 = v52[3];
        uint64_t v62 = v52[4];
        if (v63)
        {
          uint64_t v64 = 0;
          int v65 = &v56[4 * v62 - 4];
          do
          {
            *(_DWORD *)int v65 = *(_DWORD *)(v63 + 24);
            v65 -= 4;
            ++v64;
            uint64_t v63 = *(void *)(v63 + 16);
          }
          while (v63);
          *BOOL v61 = v64;
        }
        v57 += v60 + 1;
        v56 += 4 * v62;
        free(v52);
        ++v55;
        unsigned int v52 = v58;
      }
      while (v58);
      *((void *)this + 18) = v54;
    }
  }
  *((unsigned char *)this + 300) = (*((_DWORD *)a2 + 1) & 0x1000) != 0;
  *((unsigned char *)this + 301) = (*((_DWORD *)a2 + 1) & 0x400) != 0;
  unsigned int v66 = *((_DWORD *)a2 + 1);
  uint64_t v67 = 255;
  if ((v66 & 0x1800) != 0) {
    uint64_t v67 = 2047;
  }
  int v68 = *((_DWORD *)this + 52);
  if ((v68 & 2) != 0) {
    uint64_t v67 = 6143;
  }
  if (*((_DWORD *)a2 + 1) & 0x200 | *((_DWORD *)this + 52) & 1) {
    unint64_t v69 = v67 | 0x2000;
  }
  else {
    unint64_t v69 = v67;
  }
  uint64_t v70 = *((void *)this + 29);
  unint64_t v71 = v69 & ~v70;
  if (v71)
  {
    uint64_t v72 = &kExpectedAttributes;
    uint64_t v73 = 1;
    unint64_t v74 = 1;
    do
    {
      if ((v74 & v71) != 0)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | a5) & 2) != 0) {
          AXRLogError((uint64_t)"EXR file missing required header field: %s", v12, v13, v14, v15, v16, v17, v18, (char)*v72);
        }
      }
      unint64_t v74 = 1 << v73;
      v72 += 2;
      ++v73;
    }
    while (v74 <= v69);
    return -4;
  }
  if ((v70 & 0x200) == 0)
  {
    int v68 = (v66 >> 9) & 1;
    *((_DWORD *)this + 52) = v68;
  }
  int v76 = *((_DWORD *)this + 12);
  int v77 = *((_DWORD *)this + 10);
  if (v76 + 1 == v77) {
    return -6;
  }
  int v78 = *((_DWORD *)this + 13);
  int v79 = *((_DWORD *)this + 11);
  if (v78 + 1 == v79) {
    return -6;
  }
  if (v76 >= v77) {
    uint64_t v80 = (v76 + 1 - v77);
  }
  else {
    uint64_t v80 = 0;
  }
  if (v78 >= v79) {
    uint64_t v81 = (v78 + 1 - v79);
  }
  else {
    uint64_t v81 = 0;
  }
  if (*((_DWORD *)this + 39) >= v80) {
    unsigned int v82 = v80;
  }
  else {
    unsigned int v82 = *((_DWORD *)this + 39);
  }
  if (*((_DWORD *)this + 40) >= v81) {
    unsigned int v83 = v81;
  }
  else {
    unsigned int v83 = *((_DWORD *)this + 40);
  }
  *((_DWORD *)this + 39) = v82;
  *((_DWORD *)this + 40) = v83;
  if ((v70 & 0x2000) == 0)
  {
    uint64_t v84 = *((unsigned int *)this + 9);
    if (v84 > 7
      || (uint64_t v91 = (unsigned int *)((char *)&GetDefaultCompressionMethodTileSize(axr_compression_t)::kCompressionMethodTileSizes
                               + 8 * v84),
          (unsigned int v92 = *v91) == 0)
      || (unsigned int v93 = v91[1]) == 0)
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | a5) & 2) != 0) {
        AXRLogDebug((uint64_t)"Compression method %u out of bounds", v12, v13, v14, v15, v16, v17, v18, *((_DWORD *)this + 9));
      }
      return -3;
    }
    if (v92 == -1 || (v68 | 2) == 2) {
      unsigned int v92 = v80;
    }
    *((_DWORD *)this + 39) = v92;
    *((_DWORD *)this + 40) = v93;
    *((unsigned char *)this + 164) = 0;
    if (v92 <= 1) {
      unsigned int v94 = 1;
    }
    else {
      unsigned int v94 = v92;
    }
    unsigned int v95 = v80 + v94 - 1;
    if (v95 < v80) {
      int v96 = (v95 - 0xFFFFFFFF / v94 * v94) / v94 + 0xFFFFFFFF / v94;
    }
    else {
      int v96 = v95 / v94;
    }
    *((_DWORD *)this + 42) = v96;
    unsigned int v97 = v81 + v93 - 1;
    if (v97 >= v81)
    {
      int v90 = v97 / v93;
      goto LABEL_141;
    }
    unsigned int v130 = 0xFFFFFFFF / v93;
    unsigned int v131 = (v97 - 0xFFFFFFFF / v93 * v93) / v93;
LABEL_186:
    int v90 = v131 + v130;
    goto LABEL_141;
  }
  if (v82 <= 1) {
    unsigned int v85 = 1;
  }
  else {
    unsigned int v85 = v82;
  }
  unsigned int v86 = v80 + v85 - 1;
  if (v86 < v80) {
    int v87 = (v86 - 0xFFFFFFFF / v85 * v85) / v85 + 0xFFFFFFFF / v85;
  }
  else {
    int v87 = v86 / v85;
  }
  *((_DWORD *)this + 42) = v87;
  if (v83 <= 1) {
    unsigned int v88 = 1;
  }
  else {
    unsigned int v88 = v83;
  }
  unsigned int v89 = v81 + v88 - 1;
  if (v89 < v81)
  {
    unsigned int v130 = 0xFFFFFFFF / v88;
    unsigned int v131 = (v89 - 0xFFFFFFFF / v88 * v88) / v88;
    goto LABEL_186;
  }
  int v90 = v89 / v88;
LABEL_141:
  *((_DWORD *)this + 43) = v90;
  *((void *)this + 28) = 0;
  int v98 = malloc_type_malloc(8 * *((unsigned int *)this + 8), 0x2004093837F09uLL);
  *((void *)this + 3) = v98;
  if (!v98) {
    return -5;
  }
  axr_level_mode_t v99 = *((unsigned __int8 *)this + 164);
  RipLeveluint64_t Count = GetRipLevelCount(v80 | (v81 << 32), v99);
  *((void *)this + 36) = RipLevelCount;
  uint64_t v101 = malloc_type_calloc((RipLevelCount * HIDWORD(RipLevelCount)), 8uLL, 0x2004093837F09uLL);
  *((void *)this + 35) = v101;
  if (!v101) {
    return -5;
  }
  unsigned int v109 = *((_DWORD *)this + 73);
  if (v109)
  {
    int v110 = 0;
    unsigned int v111 = 0;
    int v112 = v99 & 0xF;
    axr_level_mode_t v113 = v99 >> 4;
    unsigned int v114 = *((_DWORD *)this + 72);
    int v115 = v80 - (v99 >> 4);
    int v116 = v81 - (v99 >> 4);
    while (!v114)
    {
LABEL_169:
      if (++v110 >= v109) {
        goto LABEL_172;
      }
    }
    int v117 = 0;
    while (1)
    {
      if (v112 == 2) {
        char v118 = v110;
      }
      else {
        char v118 = v117;
      }
      LODWORD(v119) = (v115 + (v113 << v117)) >> v117;
      if (v119 <= 1) {
        uint64_t v119 = 1;
      }
      else {
        uint64_t v119 = v119;
      }
      LODWORD(v120) = (v116 + (v113 << v118)) >> v118;
      if (v120 <= 1) {
        uint64_t v120 = 1;
      }
      else {
        uint64_t v120 = v120;
      }
      unsigned int v121 = *((_DWORD *)this + 39);
      if (v121 <= 1) {
        unsigned int v121 = 1;
      }
      unsigned int v122 = v119 + v121 - 1;
      if (v122 < v119) {
        uint32_t v123 = (v122 - 0xFFFFFFFF / v121 * v121) / v121 + 0xFFFFFFFF / v121;
      }
      else {
        uint32_t v123 = v122 / v121;
      }
      unsigned int v124 = *((_DWORD *)this + 40);
      if (v124 <= 1) {
        unsigned int v124 = 1;
      }
      unsigned int v125 = v120 + v124 - 1;
      uint32_t v126 = v125 < v120 ? (v125 - 0xFFFFFFFF / v124 * v124) / v124 + 0xFFFFFFFF / v124 : v125 / v124;
      v143.width = v123;
      v143.height = v126;
      MipTileInfo = MipTileInfo::CreateMipTileInfo((MipTileInfo *)(v119 | (v120 << 32)), v143, v103);
      unsigned int v114 = *((_DWORD *)this + 72);
      unsigned int v128 = v117 + v110 * v114;
      *(void *)(*((void *)this + 35) + 8 * v128) = MipTileInfo;
      long long v129 = *(_DWORD **)(*((void *)this + 35) + 8 * v128);
      if (!v129) {
        return -5;
      }
      v111 += *v129;
      if (++v117 >= v114)
      {
        unsigned int v109 = *((_DWORD *)this + 73);
        goto LABEL_169;
      }
    }
  }
  unsigned int v111 = 0;
LABEL_172:
  if ((*((unsigned char *)this + 233) & 4) != 0)
  {
    if (v111 > *((_DWORD *)this + 44))
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | a5) & 2) != 0) {
        AXRLogError((uint64_t)"axr_decoder_create: EXR file corruption: declared chunks < expected chunks", v102, *(void *)&v103, v104, v105, v106, v107, v108, v132);
      }
      return -6;
    }
  }
  else
  {
    *((_DWORD *)this + 44) = v111;
  }
  if ((a2[5] & 8) != 0) {
    return -3;
  }
  else {
    return 0;
  }
}

unint64_t Attribute::Init(Attribute *this, const char *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4;
  *(void *)this = a4;
  *((void *)this + 1) = a4;
  *((void *)this + 3) = a4;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  unint64_t v5 = a3 - a4;
  if (a3 > a4)
  {
    size_t v9 = strnlen(&a2[a4], a3 - a4);
    uint64_t v10 = v9 + 1 < v5 ? v9 + 1 : v5;
    unint64_t v11 = v10 + v4;
    if (v10 != 1 && v11 <= a3)
    {
      unint64_t v13 = v5 - v10;
      size_t v14 = strnlen(&a2[v11], v5 - v10);
      if (v14 + 1 < v13) {
        unint64_t v15 = v14 + 1;
      }
      else {
        unint64_t v15 = v13;
      }
      unint64_t v4 = v15 + v11;
      if (v15 + v11 > a3)
      {
        return v11;
      }
      else
      {
        *((void *)this + 1) = v11;
        unint64_t v16 = v4 + 4;
        if (v4 + 4 <= a3)
        {
          uint64_t v17 = *(unsigned int *)&a2[v4];
          if ((v17 & 0x80000000) == 0 && v16 + v17 <= a3)
          {
            *((void *)this + 2) = v17;
            *((void *)this + 3) = v16;
            return v16 + v17;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t Part::AbsorbAttribute(Part *this, char *a2, Attribute *a3, unint64_t *a4, axr_flags_t a5)
{
  uint64_t v6 = *a4;
  unint64_t v7 = *(void *)a3;
  if (*a4 >= 0x12)
  {
    unint64_t v18 = *((void *)a3 + 3);
    unint64_t v12 = *((void *)a3 + 1);
    size_t v9 = &a2[v7];
    if (v12 >= v7) {
      size_t v14 = v12 - v7;
    }
    else {
      size_t v14 = 0;
    }
  }
  else
  {
    unsigned int v8 = (&kExpectedAttributes)[2 * v6];
    size_t v9 = &a2[v7];
    unint64_t v10 = *((void *)a3 + 3);
    if (v7 == v10) {
      unint64_t v11 = 0;
    }
    else {
      unint64_t v11 = &a2[v7];
    }
    unint64_t v12 = *((void *)a3 + 1);
    size_t v13 = strlen((&kExpectedAttributes)[2 * v6]);
    if (v12 >= v7) {
      size_t v14 = v12 - v7;
    }
    else {
      size_t v14 = 0;
    }
    BOOL v15 = v12 <= v7 || v13 > v14;
    if (!v15 && *v8 == *v11 && (size_t v16 = v13, strlen(v11) == v13))
    {
      size_t v17 = v16 - 1;
      if (v16 == 1 || (unint64_t v18 = v10, !strncmp(v11 + 1, v8 + 1, v17)))
      {
        uint64_t result = ((uint64_t (*)(char *, Part *, Attribute *, axr_flags_t))(&kExpectedAttributes)[2 * v6 + 1])(a2, this, a3, a5);
        uint64_t v20 = *a4;
        *((void *)this + 29) |= (unint64_t)(result == 0) << *a4;
        *a4 = v20 + 1;
        if (!result) {
          goto LABEL_61;
        }
        return result;
      }
    }
    else
    {
      unint64_t v18 = v10;
    }
  }
  unint64_t v72 = v18;
  uint64_t v73 = this;
  uint64_t v21 = 0;
  if (v7 == v18) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = v9;
  }
  unint64_t v23 = &off_26DD4BA98;
  do
  {
    if (v6 != v21)
    {
      long long v24 = (const char *)*(v23 - 1);
      size_t v25 = strlen(v24);
      if (v12 > v7)
      {
        size_t v26 = v25;
        if (v25 <= v14
          && *(unsigned __int8 *)v24 == *(unsigned __int8 *)v22
          && strlen(v22) == v25
          && (v26 == 1 || !strncmp(v22 + 1, v24 + 1, v26 - 1)))
        {
          uint64_t result = (*v23)(a2, v73, a3, a5);
          *((void *)v73 + 29) |= (unint64_t)(result == 0) << v21;
          *a4 = v21 + 1;
          if (!result) {
            goto LABEL_61;
          }
          return result;
        }
      }
    }
    ++v21;
    v23 += 2;
  }
  while (v21 != 18);
  if (v7 == v72) {
    uint64_t v27 = 0;
  }
  else {
    uint64_t v27 = &a2[v12];
  }
  if (v72 >= v12) {
    unint64_t v28 = v72 - v12;
  }
  else {
    unint64_t v28 = 0;
  }
  if (v72 <= v12 || v28 < 0xE || *v27 != 99 || strlen(v27) != 14 || strncmp(v27 + 1, "hromaticities", 0xDuLL))
  {
    uint64_t v36 = v73;
    if (v72 > v12 && v28 >= 7 && *v27 == 112 && strlen(v27) == 7 && !strncmp(v27 + 1, "review", 6uLL))
    {
      unint64_t v37 = *((void *)a3 + 2);
      unint64_t v38 = v37 - 8;
      if (v37 >= 8)
      {
        uint64_t v39 = &a2[v72];
        if (v7 == v72) {
          uint64_t v39 = 0;
        }
        uint64_t v40 = *(unsigned int *)v39;
        *((_DWORD *)v73 + 66) = v40;
        uint64_t v41 = *((unsigned int *)v39 + 1);
        *((_DWORD *)v73 + 67) = v41;
        *((void *)v73 + 34) = 0;
        if (4 * v40 * v41 > v38)
        {
          unint64_t v42 = v38 / (4 * v40);
          *((_DWORD *)v73 + 67) = v42;
          LODWORD(v41) = v42;
          if (!v42)
          {
            LODWORD(v41) = 1;
            *((_DWORD *)v73 + 67) = 1;
            unint64_t v43 = (v37 + 0x3FFFFFFF8) >> 2;
            *((_DWORD *)v73 + 66) = v43;
            LODWORD(v40) = v43;
            if (!v43)
            {
              LODWORD(v41) = 0;
              *((_DWORD *)v73 + 67) = 0;
            }
          }
        }
        *((void *)a3 + 4) = 1;
        uint64_t result = 0;
        if (v40 * v41) {
          *((void *)v73 + 34) = v72 + 8;
        }
        uint64_t v44 = 0x20000;
        goto LABEL_98;
      }
LABEL_64:
      uint64_t v44 = 0;
      uint64_t result = -4;
      goto LABEL_98;
    }
LABEL_61:
    operator new();
  }
  uint64_t v36 = v73;
  if (*((void *)a3 + 2) < 0x20uLL) {
    goto LABEL_64;
  }
  if (v7 == v72) {
    int v45 = 0;
  }
  else {
    int v45 = (float *)&a2[v72];
  }
  float v46 = *v45;
  float v47 = *v45;
  float v48 = v45[2];
  float v49 = v45[4];
  int v50 = *((_DWORD *)v45 + 6);
  float v51 = fabsf(*v45);
  float v52 = fabsf(v48);
  BOOL v54 = fabsf(v49) < 8388600.0 && v52 < 8388600.0 && v51 < 8388600.0;
  float v55 = fabsf(v45[6]);
  if (!v54 && v55 < 8388600.0)
  {
    if (GetFlagsOnceToken != -1)
    {
      float v75 = *v45;
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      float v47 = v75;
    }
    if (((kDefaultAXRLogFlags | a5) & 2) != 0)
    {
      double v68 = v47;
      AXRLogDebug((uint64_t)"x Chromaticity too large. {%f, %f, %f, %f} Float can't represent less than integer precision above 2^23. chromaticity tag ignored.", v29, v30, v31, v32, v33, v34, v35, SLOBYTE(v68));
    }
  }
  else
  {
    float v57 = v45[1];
    float v58 = v57;
    float v59 = v45[3];
    float v60 = v45[5];
    float v61 = v45[7];
    float v62 = fabsf(v57);
    float v63 = fabsf(v59);
    BOOL v65 = fabsf(v60) < 8388600.0 && v63 < 8388600.0 && v62 < 8388600.0;
    float v66 = fabsf(v61);
    if (v65 || v66 >= 8388600.0)
    {
      uint64_t result = 0;
      *((float *)v73 + 26) = v46;
      *((float *)v73 + 27) = v57;
      *((float *)v73 + 28) = v48;
      *((float *)v73 + 29) = v59;
      *((float *)v73 + 30) = v49;
      *((float *)v73 + 31) = v60;
      *((_DWORD *)v73 + 32) = v50;
      *((float *)v73 + 33) = v61;
      uint64_t v44 = 0x10000;
      *((void *)a3 + 4) = 1;
      goto LABEL_98;
    }
    if (GetFlagsOnceToken != -1)
    {
      float v76 = v57;
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      float v58 = v76;
    }
    if (((kDefaultAXRLogFlags | a5) & 2) != 0)
    {
      double v69 = v58;
      AXRLogDebug((uint64_t)"y Chromaticity too large. {%f, %f, %f, %f} Float can't represent less than integer precision above 2^23. chromaticity tag ignored.", v29, v30, v31, v32, v33, v34, v35, SLOBYTE(v69));
    }
  }
  uint64_t result = 0;
  uint64_t v44 = 0x10000;
LABEL_98:
  *((void *)v36 + 29) |= v44;
  if (!result) {
    goto LABEL_61;
  }
  return result;
}

uint64_t GetRipLevelCount(unint64_t a1, axr_level_mode_t a2)
{
  unsigned __int32 v2 = a2 & 0xF;
  if ((a2 & 0xF) == 0) {
    return 0x100000001;
  }
  unsigned __int32 v4 = a2 & 0xF0;
  unint64_t v5 = 63 - __clz(a1);
  if (!a1) {
    LODWORD(v5) = 0;
  }
  unint64_t v6 = 63 - __clz(HIDWORD(a1));
  if (!HIDWORD(a1)) {
    LODWORD(v6) = 0;
  }
  unint64_t v7 = 64 - __clz(a1 - 1);
  if (a1 <= 1uLL) {
    int v8 = 0;
  }
  else {
    int v8 = v7;
  }
  unint64_t v9 = 64 - __clz(HIDWORD(a1) - 1);
  int v10 = 0;
  if (a1 >> 33) {
    int v10 = v9;
  }
  BOOL v11 = v4 == 16;
  if (v4 == 16) {
    int v12 = v8;
  }
  else {
    int v12 = v5;
  }
  if (!v11) {
    int v10 = v6;
  }
  if (v12 + 1 <= (v10 + 1)) {
    unsigned int v13 = v10 + 1;
  }
  else {
    unsigned int v13 = v12 + 1;
  }
  BOOL v14 = v2 == 1;
  if (v2 == 1) {
    uint64_t v15 = v13;
  }
  else {
    uint64_t v15 = (v12 + 1);
  }
  if (v14) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = (v10 + 1);
  }
  return v15 | (v16 << 32);
}

void *MipTileInfo::CreateMipTileInfo(MipTileInfo *this, axr_size_t a2, axr_size_t a3)
{
  unint64_t v3 = a2.width * (unint64_t)a2.height;
  if (v3 >> 61) {
    return 0;
  }
  uint64_t v4 = 8 * v3;
  uint64_t v5 = 8 * v3 + 40;
  if (8 * v3 >= 0xFFFFFFFFFFFFFFD8 || __CFADD__(v5, v4)) {
    return 0;
  }
  uint64_t result = malloc_type_calloc(1uLL, v5 + v4, 0xFCB9DC70uLL);
  if (result)
  {
    result[3] = this;
    result[4] = a2;
    *uint64_t result = v3;
    result[1] = result + 5;
    result[2] = &result[(unint64_t)v4 / 8 + 5];
  }
  return result;
}

uint64_t Part::InitOffsets(Part *this, unsigned int *a2, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  *((void *)this + 28) = *a4;
  if (a3 < 8) {
    return -6;
  }
  uint64_t v5 = a2;
  if (*a2 != 20000630) {
    return -6;
  }
  int v6 = a5;
  unsigned int v9 = *((_DWORD *)this + 39);
  unsigned int v195 = *((_DWORD *)this + 40);
  uint64_t v10 = *((void *)this + 2);
  int v11 = *((_DWORD *)this + 12);
  int v12 = *((_DWORD *)this + 13);
  int v13 = *((_DWORD *)this + 10);
  int v14 = *((_DWORD *)this + 11);
  BOOL v15 = __OFSUB__(v11, v13);
  int v16 = v11 - v13;
  if (v16 < 0 != v15) {
    unint64_t v17 = 0;
  }
  else {
    unint64_t v17 = (v16 + 1);
  }
  if (v12 >= v14) {
    unint64_t v18 = (v12 - v14 + 1);
  }
  else {
    unint64_t v18 = 0;
  }
  *((_DWORD *)this + 74) = 0;
  unint64_t v19 = v17 | (v18 << 32);
  if (*((_DWORD *)this + 8))
  {
    unint64_t v20 = 0;
    do
    {
      uint64_t result = ChannelDescription::CreateMipLevels((ChannelDescription *)v10, v5, this, v17 | (v18 << 32), (axr_level_mode_t)*((unsigned __int8 *)this + 164));
      if (result) {
        return result;
      }
      *(void *)(*((void *)this + 3) + 8 * v20) = v10;
      *((_DWORD *)this + 74) += axr_type_get_size((axr_type_t)*(_DWORD *)(v10 + 72));
      uint64_t v10 = *(void *)(v10 + 8);
      ++v20;
    }
    while (v20 < *((unsigned int *)this + 8));
  }
  int32x4_t v184 = a4;
  uint64_t v22 = *((unsigned int *)this + 9);
  unint64_t v23 = (uint64_t (*)(uint64_t, uint64_t, char, int))Part::InitOffsets(void const*,unsigned long,unsigned long &,axr_flags_t)::kRowSizeProcs[v22];
  unint64_t v24 = 0;
  long long v206 = 0u;
  long long v202 = 0u;
  uint64_t v25 = v195;
  unsigned int v203 = v9;
  unsigned int v204 = v195;
  uint64_t v205 = 0;
  *(void *)&long long v206 = 0;
  int32x4_t v197 = v23;
  int32x4_t v207 = v23;
  uint64_t v26 = *((unsigned __int8 *)this + 164);
  int v27 = v26 & 0xF;
  axr_flags_t v28 = a3;
  int32x4_t v194 = v5;
  if ((v26 & 0xF) != 0)
  {
    if ((v26 & 0xF0) == 0x10)
    {
      unint64_t v147 = 64 - __clz(v17 - 1);
      if (v17 <= 1) {
        LODWORD(v147) = 0;
      }
      unint64_t v148 = 64 - __clz(v18 - 1);
      int v149 = 0;
      if (v19 >> 33) {
        int v149 = v148;
      }
    }
    else
    {
      unint64_t v147 = 63 - __clz(v17);
      if (!v17) {
        LODWORD(v147) = 0;
      }
      unint64_t v150 = 63 - __clz(v18);
      if (HIDWORD(v19)) {
        int v149 = v150;
      }
      else {
        int v149 = 0;
      }
    }
    if ((int)v147 + 1 <= (v149 + 1)) {
      unsigned int v151 = v149 + 1;
    }
    else {
      unsigned int v151 = v147 + 1;
    }
    if (v27 == 1) {
      uint64_t v152 = v151;
    }
    else {
      uint64_t v152 = (v147 + 1);
    }
    if (v27 == 1) {
      uint64_t v153 = 1;
    }
    else {
      uint64_t v153 = (v149 + 1);
    }
    unint64_t v29 = v152 | (v153 << 32);
    axr_flags_t v28 = a3;
    uint64_t v25 = v195;
  }
  else
  {
    unint64_t v29 = 0x100000001;
  }
  BOOL v30 = v22 < 6;
  uint64_t v31 = *((void *)this + 28);
  unint64_t v32 = *((unsigned int *)this + 44);
  if (v31 + 8 * v32 >= v28) {
    return -4;
  }
  uint64_t v33 = (char *)v5 + v31;
  unint64_t v34 = (v28 - v31) >> 3;
  if (v34 >= v32) {
    unint64_t v35 = *((unsigned int *)this + 44);
  }
  else {
    unint64_t v35 = v34;
  }
  unint64_t v36 = ((unint64_t)v5[1] >> 10) & 4;
  int v37 = *((_DWORD *)this + 52);
  uint64_t result = -6;
  uint64_t v38 = 20;
  uint64_t v39 = 8;
  switch(v37)
  {
    case 0:
      goto LABEL_21;
    case 1:
      goto LABEL_53;
    case 2:
      uint64_t v39 = 20;
LABEL_21:
      BOOL v183 = v27 == 2;
      goto LABEL_24;
    case 3:
      uint64_t v38 = 32;
LABEL_53:
      BOOL v183 = v27 == 2;
      goto LABEL_54;
    case 4:
      return result;
    default:
      if (v37 == 0x80000000) {
        return result;
      }
      BOOL v183 = v27 == 2;
      uint64_t v38 = v28;
      uint64_t v39 = v28;
      if ((v37 & 1) == 0)
      {
LABEL_24:
        uint64_t v40 = (*((_DWORD *)this + 72) * *((_DWORD *)this + 73));
        if (v40)
        {
          uint64_t v41 = 0;
          unint64_t v42 = 0;
          uint64_t v43 = *((void *)this + 35);
          do
          {
            uint64_t v44 = *(void *)(v43 + 8 * v41);
            unint64_t v45 = *(void *)v44;
            if (*(void *)v44) {
              BOOL v46 = v42 >= v35;
            }
            else {
              BOOL v46 = 1;
            }
            if (!v46)
            {
              unsigned int v191 = *(_DWORD *)(v44 + 24);
              unsigned int v200 = *(_DWORD *)(v44 + 28);
              uint64_t v47 = 8 * v42;
              unint64_t v48 = 1;
              while (1)
              {
                if (v47 + *((void *)this + 28) + 8 > v28) {
                  return -4;
                }
                a5 = *(void *)&v33[v47] + v36;
                if (a5 >= v28) {
                  return -6;
                }
                if (a5 + v39 >= v28) {
                  return -4;
                }
                if (*((_DWORD *)this + 18) == 2)
                {
                  unint64_t v49 = v36;
                  int v50 = (int *)((char *)v194 + a5);
                  uint64_t v51 = 0;
                  switch(v37)
                  {
                    case 0:
                    case 2:
                      goto LABEL_39;
                    case 1:
                    case 3:
                      int v52 = *v50++;
                      LODWORD(v51) = v52;
LABEL_39:
                      HIDWORD(v51) = *v50;
                      goto LABEL_40;
                    case 4:
                      goto LABEL_261;
                    default:
                      if (v37 == 0x80000000) {
                        goto LABEL_261;
                      }
LABEL_40:
                      if (HIDWORD(v51) >= v200 || v51 >= v191)
                      {
                        if ((v6 & 2) != 0)
                        {
                          if (GetFlagsOnceToken != -1)
                          {
                            char v199 = v51;
                            dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
                            LOBYTE(v51) = v199;
                          }
                          if (((kDefaultAXRLogFlags | v6) & 2) != 0)
                          {
                            char v146 = v51;
LABEL_217:
                            AXRLogError((uint64_t)"EXR File corrupted: tile reports position %u,%u outside of valid region %u,%u", v48, v28, (uint64_t)v50, a5, v25, v29, v26, v146);
                          }
                        }
                        return -6;
                      }
                      unint64_t v53 = v51 / v9 + *(_DWORD *)(v44 + 32) * (HIDWORD(v51) / v25);
                      unint64_t v36 = v49;
                      break;
                  }
                }
                else
                {
                  unint64_t v53 = v48 - 1;
                }
                if (v53 >= v45)
                {
                  if ((v6 & 2) != 0)
                  {
                    if (GetFlagsOnceToken != -1) {
                      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
                    }
                    if (((kDefaultAXRLogFlags | v6) & 2) != 0) {
                      AXRLogError((uint64_t)"EXR File corrupted: tile reports index %lu larger than expected number of tiles %lu", v48, v28, v36, a5, v25, v29, v26, v53);
                    }
                  }
                  return -6;
                }
                uint64_t v54 = *(void *)(v44 + 16);
                if (*(void *)(v54 + 8 * v53))
                {
                  if ((v6 & 2) != 0)
                  {
                    if (GetFlagsOnceToken != -1) {
                      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
                    }
                    if (((kDefaultAXRLogFlags | v6) & 2) != 0) {
                      AXRLogError((uint64_t)"EXR File corrupted: tile at %lu appears more than once", v48, v28, v36, a5, v25, v29, v26, v53);
                    }
                  }
                  return -6;
                }
                *(void *)(v54 + 8 * v53) = a5;
                unint64_t v55 = v48 + 1;
                if (v48 < v45)
                {
                  unint64_t v56 = v42 + v48;
                  v47 += 8;
                  ++v48;
                  if (v56 < v35) {
                    continue;
                  }
                }
                unint64_t v42 = v42 + v55 - 1;
                break;
              }
            }
            ++v41;
            uint64_t v5 = v194;
          }
          while (v41 != v40);
        }
        else
        {
          unint64_t v42 = 0;
        }
        uint64_t v72 = 8 * v42;
        goto LABEL_78;
      }
LABEL_54:
      int v201 = v6;
      if (!v35)
      {
LABEL_75:
        uint64_t v72 = v36 | (8 * v35);
LABEL_78:
        uint64_t v169 = v72;
        unint64_t v170 = HIDWORD(v29);
        if (HIDWORD(v29))
        {
          int v73 = 0;
          unsigned int v180 = v30 & (0x2Fu >> v22);
          unsigned int v74 = v26 >> 4;
          if (v9 <= 1) {
            unsigned int v75 = 1;
          }
          else {
            unsigned int v75 = v9;
          }
          unsigned int v76 = v75 - 1;
          if (v25 <= 1) {
            unsigned int v77 = 1;
          }
          else {
            unsigned int v77 = v25;
          }
          unsigned int v78 = v77 - 1;
          BOOL v79 = v197 == CalculateB44RowSize || (char *)v197 == (char *)CalculateB44aRowSize;
          int v80 = v79;
          uint64_t v158 = v29;
          int v81 = v17 - (v26 >> 4);
          int v82 = v18 - (v26 >> 4);
          unsigned int v155 = 0xFFFFFFFF / v75;
          int v156 = v82;
          int v164 = v29;
          unsigned int v162 = v75;
          unsigned int v163 = v26 >> 4;
          unsigned int v160 = v77;
          unsigned int v161 = v75 - 1;
          unsigned int v159 = v77 - 1;
          int v157 = v81;
          do
          {
            if (v29)
            {
              uint64_t v83 = 0;
              int v84 = v73 * v29;
              int v165 = v73 * v29;
              int v166 = v73;
              do
              {
                DWORD2(v206) = v84 + v83;
                if (v183) {
                  char v85 = v73;
                }
                else {
                  char v85 = v83;
                }
                if ((v81 + (v74 << v83)) >> v83 <= 1) {
                  unsigned int v86 = 1;
                }
                else {
                  unsigned int v86 = (v81 + (v74 << v83)) >> v83;
                }
                unsigned int v87 = (v82 + (v74 << v85)) >> v85;
                if (v87 <= 1) {
                  unsigned int v88 = 1;
                }
                else {
                  unsigned int v88 = v87;
                }
                unsigned int v89 = v76 + v86;
                if (__CFADD__(v76, v86)) {
                  int v90 = (v89 - v155 * v75) / v75 + v155;
                }
                else {
                  int v90 = v89 / v75;
                }
                int v186 = v90;
                unsigned int v91 = v78 + v88;
                uint64_t v171 = v83;
                if (__CFADD__(v78, v88)) {
                  unsigned int v92 = (v91 - 0xFFFFFFFF / v77 * v77) / v77 + 0xFFFFFFFF / v77;
                }
                else {
                  unsigned int v92 = v91 / v77;
                }
                if (v186)
                {
                  int v93 = 0;
                  uint64_t v176 = v92;
                  uint64_t v178 = *(void *)(*((void *)this + 35) + 8 * (v84 + v83));
                  unsigned int v174 = v88;
                  unsigned int v167 = v92;
                  unsigned int v168 = v86;
                  do
                  {
                    unsigned int v94 = v203;
                    if (v203 >= v86 - v203 * v93) {
                      unsigned int v94 = v86 - v203 * v93;
                    }
                    DWORD1(v206) = v93;
                    LODWORD(v205) = v94;
                    if (v92)
                    {
                      uint64_t v95 = 0;
                      unint64_t v96 = 0;
                      unsigned int v97 = v25;
                      int v182 = v93;
                      do
                      {
                        unsigned int v193 = v97;
                        if (v88 >= v97) {
                          unint64_t v98 = v97;
                        }
                        else {
                          unint64_t v98 = v88;
                        }
                        unsigned int v99 = v88 - v204 * v95;
                        uint64_t v100 = (v93 + v186 * v95);
                        uint64_t v188 = v100;
                        uint64_t v190 = v95 + 1;
                        unsigned int v101 = (v95 + 1) * v25;
                        if (v101 >= v88) {
                          unint64_t v102 = v88;
                        }
                        else {
                          unint64_t v102 = v101;
                        }
                        if (v204 >= v99) {
                          unsigned int v103 = v99;
                        }
                        else {
                          unsigned int v103 = v204;
                        }
                        HIDWORD(v205) = v103;
                        Chunuint64_t k = Part::GetChunk(this, (char *)v5, v28, DWORD2(v206), v100, (unint64_t *)&v202 + 1);
                        if (!Chunk) {
                          return -4;
                        }
                        uint64_t v105 = Chunk;
                        *(void *)&long long v202 = AXRChunkHeader::GetCompressedDataPtr((uint64_t)Chunk, *((_DWORD *)this + 52), *((unint64_t *)&v202 + 1));
                        if (!(void)v202) {
                          return -4;
                        }
                        int CompressedDataSize = AXRChunkHeader::GetCompressedDataSize(v105, *((_DWORD *)this + 52), 0xFFFFFFFFFFFFFFFFLL);
                        if (!CompressedDataSize) {
                          return -6;
                        }
                        BOOL v107 = CompressedDataSize == HIDWORD(v205) * v205 * *((_DWORD *)this + 74);
                        uint64_t v108 = v197;
                        if (CompressedDataSize == HIDWORD(v205) * v205 * *((_DWORD *)this + 74)) {
                          uint64_t v108 = 0;
                        }
                        int32x4_t v207 = v108;
                        char v109 = v180;
                        if (v107) {
                          char v109 = 1;
                        }
                        if (v109)
                        {
                          if (v96 >= v102)
                          {
                            LODWORD(v110) = 0;
                            unint64_t v102 = v96;
                          }
                          else
                          {
                            uint64_t v110 = 0;
                            char v111 = 0;
                            unint64_t v112 = *((unsigned int *)this + 8);
                            unint64_t v113 = v112;
                            do
                            {
                              LODWORD(v206) = v96;
                              if (v113)
                              {
                                unint64_t v114 = 0;
                                do
                                {
                                  uint64_t v115 = *((void *)this + 3);
                                  if (v80)
                                  {
                                    if (*(_DWORD *)(*(void *)(v115 + 8 * v114) + 72) == 1) {
                                      int v116 = v197;
                                    }
                                    else {
                                      int v116 = 0;
                                    }
                                    int32x4_t v207 = v116;
                                  }
                                  uint64_t v117 = *(void *)(v115 + 8 * v114);
                                  unint64_t v118 = v206;
                                  unsigned int v119 = *(_DWORD *)(v117 + 104);
                                  if (v119 < 2
                                    || (unint64_t v118 = (*(unsigned int *)(v117 + 108) * (unint64_t)v206) >> *(_DWORD *)(v117 + 112),
                                        v206 == v119 * v118))
                                  {
                                    unint64_t v120 = v205;
                                    if (*(_DWORD *)(v117 + 80) >= 2u) {
                                      unint64_t v120 = (*(void *)(v117 + 96)
                                    }
                                            + *(unsigned int *)(v117 + 84) * (unint64_t)v205) >> *(_DWORD *)(v117 + 88);
                                    uint64_t v121 = *(void *)(*(void *)(v117 + 40) + 8 * DWORD2(v206));
                                    uint64_t v122 = *(unsigned int *)(v117 + 72);
                                    if (v207)
                                    {
                                      uint64_t v123 = ((uint64_t (*)(long long *, uint64_t, unint64_t, unint64_t, uint64_t))v207)(&v202, v110, v118, v120, v122);
                                    }
                                    else
                                    {
                                      if (v122 == 1) {
                                        unsigned int v124 = 2;
                                      }
                                      else {
                                        unsigned int v124 = 4;
                                      }
                                      unint64_t v125 = v120 * (unint64_t)v124;
                                      uint64_t v126 = 0x100000000;
                                      if ((v125 & 0xFFFFFFFF00000000) == 0) {
                                        uint64_t v126 = 0;
                                      }
                                      uint64_t v123 = v126 | v125 & 0xFFFFFFFE;
                                    }
                                    long long v127 = (_DWORD *)(*(void *)(v121 + 8 * DWORD1(v206) + 24)
                                                    + 8 * v118);
                                    *long long v127 = v110;
                                    v127[1] = v123;
                                    BOOL v46 = __CFADD__(v110, v123);
                                    uint64_t v110 = (v110 + v123);
                                    char v128 = v46;
                                    v111 |= BYTE4(v123) | v128;
                                    unint64_t v112 = *((unsigned int *)this + 8);
                                  }
                                  ++v114;
                                  unint64_t v113 = v112;
                                }
                                while (v114 < v112);
                              }
                              LODWORD(v96) = v96 + 1;
                            }
                            while (v96 != v98);
                            unint64_t v102 = v98;
LABEL_187:
                            BOOL v79 = v111 == 0;
                            uint64_t v5 = v194;
                            unsigned int v88 = v174;
                            if (!v79) {
                              return -14;
                            }
                          }
                        }
                        else
                        {
                          unint64_t v129 = *((unsigned int *)this + 8);
                          if (v129)
                          {
                            uint64_t v130 = 0;
                            uint64_t v110 = 0;
                            char v111 = 0;
                            while (1)
                            {
                              if (v80)
                              {
                                unsigned int v131 = v197;
                                if (*(_DWORD *)(*(void *)(*((void *)this + 3) + 8 * v130) + 72) != 1) {
                                  unsigned int v131 = 0;
                                }
                                int32x4_t v207 = v131;
                              }
                              unint64_t v132 = v96;
                              if (v96 < v102) {
                                break;
                              }
LABEL_186:
                              if (++v130 >= v129) {
                                goto LABEL_187;
                              }
                            }
                            while (2)
                            {
                              LODWORD(v206) = v132;
                              uint64_t v133 = *(void *)(*((void *)this + 3) + 8 * v130);
                              unsigned int v134 = *(_DWORD *)(v133 + 104);
                              if (v134 <= 1)
                              {
                                unint64_t v135 = v132;
                              }
                              else
                              {
                                unint64_t v135 = (v132 * *(unsigned int *)(v133 + 108)) >> *(_DWORD *)(v133 + 112);
                                if (v132 != v134 * v135) {
                                  goto LABEL_184;
                                }
                              }
                              unint64_t v136 = v205;
                              if (*(_DWORD *)(v133 + 80) >= 2u) {
                                unint64_t v136 = (*(void *)(v133 + 96)
                              }
                                      + *(unsigned int *)(v133 + 84) * (unint64_t)v205) >> *(_DWORD *)(v133 + 88);
                              uint64_t v137 = *(void *)(*(void *)(v133 + 40) + 8 * DWORD2(v206));
                              uint64_t v138 = *(unsigned int *)(v133 + 72);
                              if (v207)
                              {
                                uint64_t v139 = ((uint64_t (*)(long long *, uint64_t, unint64_t, unint64_t, uint64_t))v207)(&v202, v110, v135, v136, v138);
                              }
                              else
                              {
                                if (v138 == 1) {
                                  unsigned int v140 = 2;
                                }
                                else {
                                  unsigned int v140 = 4;
                                }
                                unint64_t v141 = v136 * (unint64_t)v140;
                                uint64_t v142 = 0x100000000;
                                if ((v141 & 0xFFFFFFFF00000000) == 0) {
                                  uint64_t v142 = 0;
                                }
                                uint64_t v139 = v142 | v141 & 0xFFFFFFFE;
                              }
                              axr_size_t v143 = (_DWORD *)(*(void *)(v137 + 8 * DWORD1(v206) + 24) + 8 * v135);
                              *axr_size_t v143 = v110;
                              v143[1] = v139;
                              BOOL v46 = __CFADD__(v110, v139);
                              uint64_t v110 = (v110 + v139);
                              char v144 = v46;
                              v111 |= BYTE4(v139) | v144;
LABEL_184:
                              if (++v132 >= v102)
                              {
                                unint64_t v129 = *((unsigned int *)this + 8);
                                goto LABEL_186;
                              }
                              continue;
                            }
                          }
                          LODWORD(v110) = 0;
                        }
                        unint64_t v145 = *((void *)this + 32);
                        if (v145 <= v110) {
                          unint64_t v145 = v110;
                        }
                        *((void *)this + 32) = v145;
                        *(void *)(*(void *)(v178 + 8) + 8 * v188) = v110;
                        LODWORD(v25) = v195;
                        unsigned int v97 = v193 + v195;
                        unint64_t v96 = v102;
                        uint64_t v95 = v190;
                        axr_flags_t v28 = a3;
                        int v93 = v182;
                      }
                      while (v190 != v176);
                    }
                    ++v93;
                    unsigned int v92 = v167;
                    unsigned int v86 = v168;
                  }
                  while (v93 != v186);
                }
                uint64_t v83 = v171 + 1;
                LODWORD(v29) = v164;
                int v84 = v165;
                int v73 = v166;
                unsigned int v75 = v162;
                unsigned int v74 = v163;
                unsigned int v77 = v160;
                unsigned int v76 = v161;
                unsigned int v78 = v159;
                int v82 = v156;
                int v81 = v157;
              }
              while (v171 + 1 != v158);
            }
            ++v73;
          }
          while (v73 != v170);
        }
        uint64_t result = 0;
        *v184 += v169;
        return result;
      }
      uint64_t v57 = 0;
      uint64_t v172 = 8 * v35;
      uint64_t v173 = v38;
      int v189 = v18;
      int v192 = v17;
      unsigned int v187 = *((unsigned __int8 *)this + 164);
      char v185 = v22;
      BOOL v181 = v22 < 6;
      int32x4_t v179 = v33;
      unsigned int v177 = v9;
      unint64_t v175 = ((unint64_t)v5[1] >> 10) & 4;
      break;
  }
  while (2)
  {
    if (v57 + *((void *)this + 28) + 8 > v28) {
      return -4;
    }
    unint64_t v58 = v35;
    axr_flags_t v59 = *(void *)&v33[v57] + v36;
    if (v59 >= v28) {
      return -6;
    }
    if (v59 + v38 >= v28) {
      return -4;
    }
    float v60 = (char *)v5 + v59;
    uint64_t v61 = *((unsigned int *)this + 52);
    int v62 = v201;
    switch((int)v61)
    {
      case 0:
      case 2:
      case 4:
        goto LABEL_261;
      case 1:
      case 3:
        unint64_t v24 = *((void *)v60 + 1);
        goto LABEL_62;
      default:
        int v62 = v201;
        if (v61 == 0x80000000)
        {
LABEL_261:
          __break(1u);
          JUMPOUT(0x228F2D80CLL);
        }
LABEL_62:
        unint64_t v63 = v24;
        if (v183)
        {
          unsigned int v64 = *((_DWORD *)this + 72);
          if (v24 >= v64 || HIDWORD(v24) >= *((_DWORD *)this + 73)) {
            goto LABEL_207;
          }
          unint64_t v18 = v29;
          unint64_t v63 = v64 * HIDWORD(v24) + (unint64_t)v24;
        }
        else
        {
          if (v24 != HIDWORD(v24))
          {
            if ((v62 & 2) != 0)
            {
              if (GetFlagsOnceToken != -1) {
                dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
              }
              if (((kDefaultAXRLogFlags | v62) & 2) != 0) {
                AXRLogError((uint64_t)"EXR File corrupted: tile reports different x&y mip levels though not a ripmap", v61, v28, v36, a5, v25, v29, v26, v154);
              }
            }
            return -6;
          }
          if (v24 >= *((_DWORD *)this + 72))
          {
LABEL_207:
            if ((v62 & 2) != 0)
            {
              if (GetFlagsOnceToken != -1) {
                dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
              }
              if (((kDefaultAXRLogFlags | v62) & 2) != 0) {
                AXRLogError((uint64_t)"EXR File corrupted: tile reports mip level %u,%u outside of expected range %u,%u", v61, v28, v36, a5, v25, v29, v26, v63);
              }
            }
            return -6;
          }
          unint64_t v18 = v29;
        }
        uint64_t v65 = *(void *)(*((void *)this + 35) + 8 * v63);
        unsigned int v67 = *(_DWORD *)(v65 + 32);
        unsigned int v66 = *(_DWORD *)(v65 + 36);
        unint64_t v24 = AXRChunkHeader::GetTilePosition((unsigned __int32 *)v60, v61).n64_u64[0];
        char v68 = v24;
        if (HIDWORD(v24) < v66 && v24 < v67)
        {
          uint64_t v70 = v24 + HIDWORD(v24) * v67;
          uint64_t v71 = *(void *)(v65 + 16);
          if (*(void *)(v71 + 8 * v70))
          {
            if ((v201 & 2) != 0)
            {
              if (GetFlagsOnceToken != -1) {
                dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
              }
              if (((kDefaultAXRLogFlags | v201) & 2) != 0) {
                AXRLogError((uint64_t)"EXR File corrupted: tile at %u,%u appears more than once", v48, v28, (uint64_t)v50, a5, v25, v29, v26, v68);
              }
            }
            return -6;
          }
          *(void *)(v71 + 8 * v70) = v59;
          v57 += 8;
          uint64_t v38 = v173;
          axr_flags_t v28 = a3;
          uint64_t v5 = v194;
          uint64_t v25 = v195;
          unint64_t v29 = v18;
          LODWORD(v18) = v189;
          LODWORD(v17) = v192;
          unsigned int v9 = v177;
          uint64_t v26 = v187;
          LOBYTE(v22) = v185;
          BOOL v30 = v181;
          uint64_t v33 = v179;
          unint64_t v35 = v58;
          unint64_t v36 = v175;
          if (v172 == v57) {
            goto LABEL_75;
          }
          continue;
        }
        if ((v201 & 2) != 0)
        {
          if (GetFlagsOnceToken != -1)
          {
            char v198 = v24;
            dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
            LOBYTE(v24) = v198;
          }
          if (((kDefaultAXRLogFlags | v201) & 2) != 0)
          {
            char v146 = v24;
            goto LABEL_217;
          }
        }
        return -6;
    }
  }
}

unint64_t CalculatePXR24RowSize(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  if (((CalculatePXR24RowSize(ChannelDescription::ChannelDescriptionLocationInfo const&,unsigned int,unsigned int,unsigned int,axr_type_t)::kTypeSize[a5]
       * (unint64_t)a4) & 0xFFFFFFFF00000000) != 0)
    uint64_t v5 = 0x100000000;
  else {
    uint64_t v5 = 0;
  }
  return v5 & 0xFFFFFFFF00000000 | (CalculatePXR24RowSize(ChannelDescription::ChannelDescriptionLocationInfo const&,unsigned int,unsigned int,unsigned int,axr_type_t)::kTypeSize[a5]
                                    * a4);
}

uint64_t CalculateB44RowSize(uint64_t a1, uint64_t a2, char a3, int a4)
{
  if ((a3 & 3) != 0) {
    return 0;
  }
  uint64_t v5 = 0x100000000;
  if (((14 * ((a4 + 3) >> 2)) & 0xFFFFFFFF00000000) == 0) {
    uint64_t v5 = 0;
  }
  return v5 | (14 * ((a4 + 3) >> 2));
}

unint64_t CalculateB44aRowSize(void *a1, unsigned int a2, char a3, unsigned int a4)
{
  if ((a3 & 3) != 0) {
    goto LABEL_19;
  }
  unint64_t v4 = a1[1];
  if (v4 < a2) {
    goto LABEL_19;
  }
  unint64_t v5 = v4 - a2;
  if (a4 < 0xFFFFFFFD)
  {
    if (v5 >= 0xFFFFFFFF) {
      unint64_t v5 = 0xFFFFFFFFLL;
    }
    if (a4)
    {
      uint64_t v6 = (a4 + 3) >> 2;
      goto LABEL_8;
    }
LABEL_19:
    unint64_t v5 = 0;
    goto LABEL_20;
  }
  if (v5 >= 0xFFFFFFFF) {
    unint64_t v5 = 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0x40000000;
LABEL_8:
  LODWORD(v7) = 0;
  unsigned __int8 v8 = 0;
  while (v7 < 0xFFFFFFFD && (int)v7 + 3 < v5)
  {
    if (*(unsigned __int8 *)(*a1 + a2 + v7 + 2) == 252) {
      int v9 = 3;
    }
    else {
      int v9 = 14;
    }
    BOOL v10 = __CFADD__(v7, v9);
    unint64_t v7 = (v7 + v9);
    char v11 = v10;
    v8 |= v11;
    if (!--v6)
    {
      unint64_t v12 = (unint64_t)v8 << 32;
      unint64_t v5 = v7;
      return v12 | v5;
    }
  }
LABEL_20:
  unint64_t v12 = 0;
  return v12 | v5;
}

__n64 AXRChunkHeader::GetTilePosition(unsigned __int32 *a1, int a2)
{
  result.n64_u64[0] = 0;
  switch(a2)
  {
    case 0:
    case 2:
      goto LABEL_3;
    case 1:
    case 3:
      unsigned __int32 v3 = *a1++;
      result.n64_u32[0] = v3;
LABEL_3:
      result.n64_u32[1] = *a1;
      return result;
    case 4:
      goto LABEL_6;
    default:
      if (a2 == 0x80000000)
      {
LABEL_6:
        __break(1u);
        JUMPOUT(0x228F2D9ACLL);
      }
      return result;
  }
}

char *Part::GetChunk(Part *this, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  unint64_t v7 = *(void *)(*(void *)(*(void *)(*((void *)this + 35) + 8 * a4) + 16) + 8 * a5);
  if (v7 < *((void *)this + 28) + (unint64_t)*((unsigned int *)this + 44))
  {
    unint64_t v10 = 0;
    __n64 result = 0;
  }
  else
  {
    unsigned __int8 v8 = &a2[v7];
    unsigned int CompressedDataSize = AXRChunkHeader::GetCompressedDataSize(&a2[v7], *((_DWORD *)this + 52), *(void *)this - v7);
    unint64_t v10 = CompressedDataSize;
    if (CompressedDataSize) {
      __n64 result = v8;
    }
    else {
      __n64 result = 0;
    }
  }
  *a6 = v10;
  return result;
}

void Part::~Part(Part *this)
{
  *((void *)this + 1) = 0;
  unsigned __int32 v2 = (ChannelDescription *)*((void *)this + 2);
  if (v2)
  {
    do
    {
      unsigned __int32 v3 = (ChannelDescription *)*((void *)v2 + 1);
      ChannelDescription::~ChannelDescription(v2);
      MEMORY[0x22A6AD870]();
      unsigned __int32 v2 = v3;
    }
    while (v3);
  }
  free(*((void **)this + 3));
  unint64_t v4 = (void *)*((void *)this + 24);
  if (v4)
  {
    free(v4);
    *((void *)this + 24) = 0;
  }
  unint64_t v5 = (void *)*((void *)this + 25);
  if (v5)
  {
    free(v5);
    *((void *)this + 25) = 0;
  }
  uint64_t v6 = (void *)*((void *)this + 23);
  if (v6)
  {
    free(v6);
    *((void *)this + 23) = 0;
  }
  unint64_t v7 = (void *)*((void *)this + 35);
  if (v7)
  {
    uint64_t v8 = (*((_DWORD *)this + 73) * *((_DWORD *)this + 72));
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8 * v8;
      do
      {
        char v11 = *(void **)(*((void *)this + 35) + v9);
        if (v11) {
          free(v11);
        }
        v9 += 8;
      }
      while (v10 != v9);
      unint64_t v7 = (void *)*((void *)this + 35);
    }
    free(v7);
  }
  while (1)
  {
    uint64_t v12 = *((void *)this + 30);
    if (!v12) {
      break;
    }
    *((void *)this + 30) = *(void *)(v12 + 40);
    MEMORY[0x22A6AD870]();
  }
  free(*((void **)this + 18));
  *((void *)this + 18) = 0;
}

unint64_t Part::Print(Part *this, char *a2, size_t a3, char *a4, unint64_t a5)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  ChunkLayout_Print(v71, 0x100uLL, *((_DWORD *)this + 52));
  unsigned int v66 = a2;
  if ((*((unsigned char *)this + 164) & 0xF) == 2) {
    snprintf(__str, 0x100uLL, "{x: %u, y: %u}");
  }
  else {
    snprintf(__str, 0x100uLL, "%u");
  }
  name = axr_compression_get_name((axr_compression_t)*((_DWORD *)this + 9));
  int v8 = *((_DWORD *)this + 17);
  int v64 = *((_DWORD *)this + 10);
  int v63 = *((_DWORD *)this + 11);
  int v62 = *((_DWORD *)this + 12);
  int v61 = *((_DWORD *)this + 13);
  int v60 = *((_DWORD *)this + 14);
  int v58 = *((_DWORD *)this + 15);
  int v59 = *((_DWORD *)this + 16);
  int v9 = *((_DWORD *)this + 39);
  int v10 = *((_DWORD *)this + 40);
  char v11 = axr_line_order_get_name((axr_line_order_t)*((_DWORD *)this + 18));
  double v56 = COERCE_FLOAT(HIDWORD(*((void *)this + 10)));
  double v57 = COERCE_FLOAT(*((void *)this + 10));
  double v54 = (float)(*((float *)this + 24) * *((float *)this + 25));
  double v55 = *((float *)this + 22);
  double v53 = *((float *)this + 23);
  double v12 = *((float *)this + 26);
  double v13 = *((float *)this + 27);
  double v14 = *((float *)this + 28);
  double v15 = *((float *)this + 29);
  double v16 = *((float *)this + 30);
  double v17 = *((float *)this + 31);
  double v18 = *((float *)this + 32);
  double v19 = *((float *)this + 33);
  unsigned int v67 = a4;
  unint64_t v20 = &a4[*((void *)this + 34)];
  int v21 = *((_DWORD *)this + 66);
  int v22 = *((_DWORD *)this + 67);
  int v23 = *((_DWORD *)this + 8);
  int v24 = *((_DWORD *)this + 38);
  uint64_t v25 = axr_level_mode_get_name((axr_level_mode_t)*((unsigned __int8 *)this + 164));
  int v52 = v23;
  size_t v26 = a3;
  int v27 = snprintf(v66, a3, "\tcompression method:    %s\n\tdata window:           {X: [%d, %d], Y: [%d, %d]}\n\tdisplay window:        {X: [%d, %d], Y: [%d, %d]}\n\tlayout:                %s\n\ttile size:             { w: %u, h: %u }\n\tline order:            %s\n\tscreen window center:  {%f, %f}\n\tpixel aspect ratio:    %f\n\txDensity:              %f pixels per inch\n\tscreen window width:   %f\n\tchromaticities:        r: {%f, %f}     (x, y)\n\t                       g: {%f, %f}\n\t                       b: {%f, %f}\n\t                       w: {%f, %f}\n\tpreview:               {%u x %u} @ %p\n\tchannel count:         %u\n\tlayer count:           %u\n"
          "\tlevel mode:            %s\n"
          "\tmip levels:            %s\n",
          name,
          v64,
          v62,
          v63,
          v61,
          v60,
          v59,
          v58,
          v8,
          v71,
          v9,
          v10,
          v11,
          v57,
          v56,
          v55,
          v54,
          v53,
          v12,
          v13,
          v14,
          v15,
          v16,
          v17,
          v18,
          v19,
          v21,
          v22,
          v20,
          v52,
          v24,
          v25,
          __str);
  unint64_t v28 = v27;
  if (*((void *)this + 23)) {
    unint64_t v28 = v27 + (uint64_t)snprintf(&v66[v27], a3 - v27, "\tview:                  %s\n", *((const char **)this + 23));
  }
  if (a3 > v28)
  {
    if (*((void *)this + 24)) {
      v28 += snprintf(&v66[v28], a3 - v28, "\tname:                  %s\n", *((const char **)this + 24));
    }
    if (a3 > v28)
    {
      if (*((void *)this + 25)) {
        v28 += snprintf(&v66[v28], a3 - v28, "\ttype:                  %s\n", *((const char **)this + 25));
      }
      if (v28 < a3)
      {
        if (*((_DWORD *)this + 38))
        {
          unint64_t v29 = 0;
          while (1)
          {
            v28 += snprintf(&v66[v28], v26 - v28, "\n\tLayer %lu:\n", v29);
            if (v26 <= v28) {
              break;
            }
            v28 += snprintf(&v66[v28], v26 - v28, "\t\tname:    \"%s\"\n", *(const char **)(*((void *)this + 18) + 24 * v29));
            if (v26 <= v28) {
              break;
            }
            v28 += snprintf(&v66[v28], v26 - v28, "\t\tchannels: ");
            if (v26 <= v28) {
              break;
            }
            uint64_t v35 = *((void *)this + 18);
            unint64_t v36 = *(void *)(v35 + 24 * v29 + 16);
            if (v36)
            {
              uint64_t Channel = (void *)Part::GetChannel(this, **(unsigned int **)(v35 + 24 * v29 + 8), a5, v30, v31, v32, v33, v34);
              v28 += snprintf(&v66[v28], v26 - v28, "\"%s\"", &v67[*Channel]);
              if (v28 >= a3) {
                return v28;
              }
              if (v36 >= 2)
              {
                uint64_t v43 = 1;
                do
                {
                  uint64_t v44 = (void *)Part::GetChannel(this, *(unsigned int *)(*(void *)(*((void *)this + 18) + 24 * v29 + 8) + 4 * v43), a5, v38, v39, v40, v41, v42);
                  v28 += snprintf(&v66[v28], a3 - v28, ", \"%s\"", &v67[*v44]);
                  if (v28 >= a3) {
                    return v28;
                  }
                }
                while (v36 != ++v43);
              }
              v28 += snprintf(&v66[v28], a3 - v28, "\n");
              if (v28 >= a3) {
                return v28;
              }
            }
            ++v29;
            size_t v26 = a3;
            if (v29 >= *((unsigned int *)this + 38)) {
              goto LABEL_26;
            }
          }
        }
        else
        {
LABEL_26:
          if (*((_DWORD *)this + 8))
          {
            uint64_t v45 = 0;
            while (1)
            {
              v28 += snprintf(&v66[v28], v26 - v28, "\n\tChannel %lu:\n", v45);
              if (v26 <= v28) {
                break;
              }
              v28 += ChannelDescription::Print(*(ChannelDescription **)(*((void *)this + 3) + 8 * v45), &v66[v28], v26 - v28, v67, (axr_flags_t)a5);
              if (v28 >= v26) {
                break;
              }
              if (++v45 >= (unint64_t)*((unsigned int *)this + 8)) {
                goto LABEL_31;
              }
            }
          }
          else
          {
LABEL_31:
            v28 += snprintf(&v66[v28], v26 - v28, "\n\tEXR attributes found:\n");
            if (v26 > v28)
            {
              if (*((void *)this + 31))
              {
                for (uint64_t i = (void *)*((void *)this + 30); i; uint64_t i = (void *)i[5])
                {
                  uint64_t v47 = i[3];
                  unint64_t v48 = &v67[*i];
                  if (*i == v47)
                  {
                    unint64_t v48 = 0;
                    int v50 = 0;
                  }
                  else
                  {
                    int v50 = &v67[i[1]];
                  }
                  if (*i == v47) {
                    unint64_t v49 = 0;
                  }
                  else {
                    unint64_t v49 = &v67[v47];
                  }
                  v28 += snprintf(&v66[v28], a3 - v28, "\t\t\"%s\" \"%s\"  %lu bytes @ %p\n", v48, v50, i[2], v49);
                  if (v28 >= a3) {
                    break;
                  }
                }
              }
              else
              {
                v28 += snprintf(&v66[v28], v26 - v28, "\t\t<None>\n");
              }
            }
          }
        }
      }
    }
  }
  return v28;
}

uint64_t Part::CreateColorSpace(Part *this, const axr_decoder *a2, uint64_t a3, axr_flags_t a4, int a5, double a6, double a7, __n128 a8)
{
  int v8 = a4;
  uint64_t v9 = *((void *)a2 + 3);
  if (v9)
  {
    uint64_t v10 = 0;
    while (1)
    {
      axr_channel_type_t v11 = *(_DWORD *)(v9 + 20);
      if ((v10 & (1 << v11) & 0xFFFFFFFFFFFFFF0FLL) != 0) {
        break;
      }
      v10 |= 1 << v11;
      uint64_t v9 = *(void *)(v9 + 8);
      if (!v9) {
        goto LABEL_7;
      }
    }
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v8) & 2) != 0)
    {
      char name = axr_channel_type_get_name(v11);
      AXRLogDebug((uint64_t)"Colorspace determination failed because the decoder contained channels with duplicate channel types (%s)", v17, v18, v19, v20, v21, v22, v23, name);
    }
    return 0;
  }
  else
  {
    uint64_t v10 = 0;
LABEL_7:
    if ((*((void *)this + 29) & 0x8000) != 0) {
      a8.n128_u32[0] = *((_DWORD *)this + 34);
    }
    else {
      a8.n128_f32[0] = NAN;
    }
    v12.i32[0] = *((_DWORD *)this + 26);
    v13.n128_u32[0] = *((_DWORD *)this + 27);
    v12.i32[1] = *((_DWORD *)this + 28);
    v12.i32[2] = *((_DWORD *)this + 30);
    v12.i32[3] = *((_DWORD *)this + 32);
    v13.n128_u32[1] = *((_DWORD *)this + 29);
    v13.n128_u32[2] = *((_DWORD *)this + 31);
    v13.n128_u32[3] = *((_DWORD *)this + 33);
    float32x4_t v14 = (float32x4_t)vandq_s8((int8x16_t)vceqq_f32((float32x4_t)v13, (float32x4_t)xmmword_228F628D0), (int8x16_t)vceqq_f32((float32x4_t)v12, (float32x4_t)xmmword_228F628E0));
    v14.i32[0] = vminvq_u32((uint32x4_t)v14);
    return AXRCreateColorSpace(v12, v13, a8, v14, (unsigned __int32)v14.i32[0] >> 31, v10, a3, a4, a5);
  }
}

uint64_t ReadChannels(uint64_t a1, Part *a2, Attribute *a3, uint64_t a4)
{
  unint64_t v7 = (char *)a3 + 16;
  unint64_t v5 = *((void *)a3 + 2);
  uint64_t v6 = *((void *)v7 + 1);
  uint64_t v8 = *((unsigned __int8 *)a2 + 164);
  uint64_t v10 = 0;
  ChannelDescription::ParseChList(a1, v6, v5, a4, v8, (void *)a2 + 18, (void *)a2 + 2, (_DWORD *)a2 + 8, &v10);
  uint64_t result = v10;
  if (!v10) {
    *((void *)a3 + 4) = 256;
  }
  return result;
}

uint64_t ReadCompression(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (!*((void *)a3 + 2)) {
    return -4;
  }
  int v4 = a4;
  uint64_t v8 = *((void *)a3 + 3);
  if (*(void *)a3 == v8) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = &a1[*(void *)a3];
  }
  if (*(void *)a3 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = &a1[*((void *)a3 + 1)];
  }
  size_t v11 = strlen(v9);
  if (strncmp(v9, v10, v11)) {
    return -6;
  }
  unsigned int v20 = a1[v8];
  if (v20 < 8)
  {
    uint64_t result = 0;
    *((_DWORD *)a2 + 9) = v20;
    *((void *)a3 + 4) = 1;
  }
  else
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v4) & 2) != 0) {
      AXRLogError((uint64_t)"compression method too new: %u", v12, v13, v14, v15, v16, v17, v18, v20);
    }
    return -3;
  }
  return result;
}

uint64_t ReadDataWindow(char *a1, Part *a2, Attribute *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((void *)a3 + 2) < 0x10uLL) {
    return -4;
  }
  uint64_t v9 = *((void *)a3 + 3);
  if (*(void *)a3 == v9) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = &a1[v9];
  }
  int v11 = *(_DWORD *)v10;
  int v12 = *((_DWORD *)v10 + 1);
  int v13 = *((_DWORD *)v10 + 2);
  int v14 = *((_DWORD *)v10 + 3);
  if (v11 <= v13 && v12 <= v14)
  {
    uint64_t result = 0;
    *((_DWORD *)a2 + 10) = v11;
    *((_DWORD *)a2 + 11) = v12;
    *((_DWORD *)a2 + 12) = v13;
    *((_DWORD *)a2 + 13) = v14;
    *((void *)a3 + 4) = 1;
  }
  else
  {
    if (GetFlagsOnceToken != -1)
    {
      uint64_t v17 = a4;
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      a4 = v17;
    }
    if (((kDefaultAXRLogFlags | a4) & 2) != 0) {
      AXRLogError((uint64_t)"data window xMin > xMax or yMin > yMax", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v16);
    }
    return -6;
  }
  return result;
}

uint64_t ReadDisplayWindow(char *a1, Part *a2, Attribute *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((void *)a3 + 2) < 0x10uLL) {
    return -4;
  }
  uint64_t v9 = *((void *)a3 + 3);
  if (*(void *)a3 == v9) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = &a1[v9];
  }
  int v11 = *(_DWORD *)v10;
  int v12 = *((_DWORD *)v10 + 1);
  int v13 = *((_DWORD *)v10 + 2);
  int v14 = *((_DWORD *)v10 + 3);
  if (v11 <= v13 && v12 <= v14)
  {
    uint64_t result = 0;
    *((_DWORD *)a2 + 14) = v11;
    *((_DWORD *)a2 + 15) = v12;
    *((_DWORD *)a2 + 16) = v13;
    *((_DWORD *)a2 + 17) = v14;
    *((void *)a3 + 4) = 1;
  }
  else
  {
    if (GetFlagsOnceToken != -1)
    {
      uint64_t v17 = a4;
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      a4 = v17;
    }
    if (((kDefaultAXRLogFlags | a4) & 2) != 0) {
      AXRLogError((uint64_t)"display window xMin > xMax or yMin > yMax", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v16);
    }
    return -6;
  }
  return result;
}

uint64_t ReadLineOrder(unsigned __int8 *a1, Part *a2, Attribute *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*((void *)a3 + 2)) {
    return -4;
  }
  unsigned int v8 = a1[*((void *)a3 + 3)];
  if (v8 < 3)
  {
    uint64_t result = 0;
    *((_DWORD *)a2 + 18) = v8;
    *((void *)a3 + 4) = 1;
  }
  else
  {
    int v9 = a4;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v9) & 2) != 0) {
      AXRLogError((uint64_t)"line order > RANDOM_Y", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v11);
    }
    return -6;
  }
  return result;
}

uint64_t ReadPixelAspectRatio(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 4uLL) {
    return -4;
  }
  int v5 = *(_DWORD *)&a1[*((void *)a3 + 3)];
  uint64_t result = 0;
  *((_DWORD *)a2 + 22) = v5;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadScreenWindowCenter(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 8uLL) {
    return -4;
  }
  uint64_t v5 = *(void *)&a1[*((void *)a3 + 3)];
  uint64_t result = 0;
  *((void *)a2 + 10) = v5;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadScreenWindowWidth(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 4uLL) {
    return -4;
  }
  int v5 = *(_DWORD *)&a1[*((void *)a3 + 3)];
  uint64_t result = 0;
  *((_DWORD *)a2 + 23) = v5;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadViewName(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  size_t v7 = *((void *)a3 + 2);
  unsigned int v8 = malloc_type_malloc(v7 + 1, 0xAC8A26ACuLL);
  if (!v8) {
    return -5;
  }
  int v9 = v8;
  uint64_t v10 = *((void *)a3 + 3);
  if (*(void *)a3 == v10) {
    char v11 = 0;
  }
  else {
    char v11 = &a1[v10];
  }
  memcpy(v8, v11, v7);
  v9[v7] = 0;
  int v12 = (void *)*((void *)a2 + 24);
  if (v12) {
    free(v12);
  }
  uint64_t result = 0;
  *((void *)a2 + 24) = v9;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadViewType(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  size_t v7 = *((void *)a3 + 2);
  unsigned int v8 = (char *)malloc_type_malloc(v7 + 1, 0xAB68A545uLL);
  if (!v8) {
    return -5;
  }
  int v9 = v8;
  uint64_t v10 = *((void *)a3 + 3);
  if (*(void *)a3 == v10) {
    char v11 = 0;
  }
  else {
    char v11 = &a1[v10];
  }
  memcpy(v8, v11, v7);
  v9[v7] = 0;
  size_t v12 = *((void *)a3 + 2);
  if (!strncmp(v9, "scanlineimage", v12))
  {
    *((_DWORD *)a2 + 52) = 0;
  }
  else
  {
    if (!strncmp(v9, "tiledimage", v12))
    {
      unsigned int v13 = 1;
    }
    else if (!strncmp(v9, "deepscanline", v12))
    {
      unsigned int v13 = 2;
    }
    else if (!strncmp(v9, "deeptile", v12))
    {
      unsigned int v13 = 3;
    }
    else
    {
      unsigned int v13 = 0x80000000;
    }
    *((_DWORD *)a2 + 52) = v13;
  }
  uint64_t v15 = (void *)*((void *)a2 + 25);
  if (v15) {
    free(v15);
  }
  uint64_t result = 0;
  *((void *)a2 + 25) = v9;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadChunkCount(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 4uLL) {
    return -4;
  }
  int v5 = *(_DWORD *)&a1[*((void *)a3 + 3)];
  if (v5 < 1) {
    return -6;
  }
  uint64_t result = 0;
  *((_DWORD *)a2 + 44) = v5;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadMaxSamplesPerPixel(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 4uLL) {
    return -4;
  }
  int v5 = *(_DWORD *)&a1[*((void *)a3 + 3)];
  if (v5 < 1) {
    return -6;
  }
  uint64_t result = 0;
  *((_DWORD *)a2 + 54) = v5;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadViewVersion(char *a1, Part *a2, Attribute *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((void *)a3 + 2) < 4uLL) {
    return -4;
  }
  if (*(_DWORD *)&a1[*((void *)a3 + 3)] == 1)
  {
    uint64_t result = 0;
    *((_DWORD *)a2 + 53) = 1;
    *((void *)a3 + 4) = 1;
  }
  else
  {
    if (GetFlagsOnceToken != -1)
    {
      uint64_t v10 = a4;
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      a4 = v10;
    }
    if (((kDefaultAXRLogFlags | a4) & 2) != 0) {
      AXRLogDebug((uint64_t)"EXR view type > 1 not supported", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v9);
    }
    return -3;
  }
  return result;
}

uint64_t ReadTiles(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 9uLL) {
    return -4;
  }
  uint64_t v5 = *((void *)a3 + 3);
  uint64_t v6 = &a1[v5];
  if (*(void *)a3 == v5) {
    uint64_t v6 = 0;
  }
  int v7 = *(_DWORD *)v6;
  int v8 = *((_DWORD *)v6 + 1);
  if (*(_DWORD *)v6) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    return -6;
  }
  char v10 = v6[8];
  if ((v10 & 0xE4) != 0 || (v10 & 3) == 3) {
    return -6;
  }
  uint64_t result = 0;
  *((_DWORD *)a2 + 39) = v7;
  *((_DWORD *)a2 + 40) = v8;
  *((unsigned char *)a2 + 164) = v10 & 0x13;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadView(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  size_t v7 = *((void *)a3 + 2);
  int v8 = malloc_type_malloc(v7 + 1, 0x55680FA0uLL);
  if (!v8) {
    return -5;
  }
  BOOL v9 = v8;
  uint64_t v10 = *((void *)a3 + 3);
  if (*(void *)a3 == v10) {
    char v11 = 0;
  }
  else {
    char v11 = &a1[v10];
  }
  memcpy(v8, v11, v7);
  v9[v7] = 0;
  size_t v12 = (void *)*((void *)a2 + 23);
  if (v12) {
    free(v12);
  }
  uint64_t result = 0;
  *((void *)a2 + 23) = v9;
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadWhiteLuminance(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 4uLL) {
    return -4;
  }
  uint64_t result = 0;
  *((_DWORD *)a2 + 34) = *(_DWORD *)&a1[*((void *)a3 + 3)];
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadXDensity(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  if (*((void *)a3 + 2) < 4uLL) {
    return -4;
  }
  uint64_t result = 0;
  *((_DWORD *)a2 + 24) = *(_DWORD *)&a1[*((void *)a3 + 3)];
  *((void *)a3 + 4) = 1;
  return result;
}

uint64_t ReadResolution(char *a1, Part *a2, Attribute *a3, axr_flags_t a4)
{
  size_t v4 = *((void *)a3 + 2);
  if (v4 < 2) {
    return -4;
  }
  int v6 = a4;
  uint64_t v9 = *((void *)a3 + 3);
  if (*(void *)a3 == v9) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = &a1[v9];
  }
  if (!strncasecmp(v10, "in", *((void *)a3 + 2)) || !strncasecmp(v10, "inch", v4))
  {
    uint64_t result = 0;
    int v18 = 1065353216;
LABEL_15:
    *((_DWORD *)a2 + 25) = v18;
    *((void *)a3 + 4) = 1;
    return result;
  }
  if (!strncasecmp(v10, "cm", v4))
  {
    uint64_t result = 0;
    int v18 = 1053397798;
    goto LABEL_15;
  }
  if (GetFlagsOnceToken != -1) {
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
  if (((kDefaultAXRLogFlags | v6) & 2) != 0) {
    AXRLogDebug((uint64_t)"Unhandled ResolutionUnit attribute \"%s\"", v11, v12, v13, v14, v15, v16, v17, (char)v10);
  }
  return 0;
}

void ChannelDescription::~ChannelDescription(ChannelDescription *this)
{
  unsigned __int32 v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    int v3 = *((_DWORD *)this + 7);
    int v4 = *((_DWORD *)this + 8);
    if (v4 * v3)
    {
      unint64_t v5 = 0;
      do
      {
        int v6 = *(void **)(*((void *)this + 5) + 8 * v5);
        if (v6)
        {
          free(v6);
          int v3 = *((_DWORD *)this + 7);
          int v4 = *((_DWORD *)this + 8);
        }
        ++v5;
      }
      while (v5 < (v4 * v3));
      unsigned __int32 v2 = (void *)*((void *)this + 5);
    }
    free(v2);
  }
}

uint64_t PrintChannel(char *a1, ReadChannel *a2, ReadChannel *a3, int *a4, const AXRData *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v13 = *((void *)a2 + 1);
  if (v13) {
    uint64_t v14 = PrintChannel(a1, v13, a3, a4, a5, a6);
  }
  else {
    uint64_t v14 = 0;
  }
  ++*(_DWORD *)a3;
  uint64_t v15 = ReadChannel::Print(a2, &a1[v14], 4096 - v14, (int)a4, (const AXRData *)a4, (unint64_t)a5, a7, a8);
  if ((unint64_t)(v15 + v14) >= 0x1000) {
    return 4096;
  }
  else {
    return v15 + v14;
  }
}

axr_decoder_t axr_decoder_copy(axr_decoder_t decoder)
{
  if (!decoder) {
    return 0;
  }
  axr_decoder_t v2 = axr_decoder_create((axr_data_t)decoder[2].isa, LODWORD(decoder[5].isa), HIDWORD(decoder[5].isa), axr_flags_default);
  int v3 = v2;
  if (v2)
  {
    v2[4].Class isa = decoder[4].isa;
    *(_OWORD *)((char *)&v2[5].isa + 4) = *(_OWORD *)((char *)&decoder[5].isa + 4);
    HIDWORD(v2[7].isa) = HIDWORD(decoder[7].isa);
    *(_OWORD *)&v2[8].Class isa = *(_OWORD *)&decoder[8].isa;
    v2[10].Class isa = decoder[10].isa;
    Class isa = decoder[3].isa;
    if (isa) {
      ReadChannel::CreateCopy(isa);
    }
  }
  return v3;
}

axr_decoder_t axr_decoder_create(axr_data_t fileData, unint64_t partIndex, unint64_t levelIndex, axr_flags_t flags)
{
  if (!fileData) {
    return 0;
  }
  Class isa = fileData[12].isa;
  axr_data_t v11 = fileData + 12;
  if ((unint64_t)isa <= partIndex) {
    axr_decoder_create_cold_2((uint64_t)v11, partIndex, flags, flags, v4, v5, v6, v7);
  }
  unint64_t level_count = axr_data_get_level_count(fileData, partIndex);
  if (level_count <= levelIndex) {
    axr_decoder_create_cold_1(level_count, levelIndex, flags, v15, v16, v17, v18, v19);
  }
  objc_opt_class();
  uint64_t v20 = _os_object_alloc();
  if (v20)
  {
    uint64_t v21 = fileData;
    *(_DWORD *)(v20 + 40) = partIndex;
    *(_DWORD *)(v20 + 44) = levelIndex;
    *(_DWORD *)(v20 + 32) = 0;
    *(void *)(v20 + 16) = v21;
    *(void *)(v20 + 24) = 0;
    *(void *)(v20 + 80) = flags;
    memset(&v25, 0, sizeof(v25));
    axr_data_get_part_info(&v25, fileData, partIndex, axr_part_info_current);
    *(void *)(v20 + 48) = 0;
    if (levelIndex)
    {
      unint64_t level_size = (unint64_t)axr_data_get_level_size(fileData, partIndex, levelIndex);
      unint64_t v23 = HIDWORD(level_size);
    }
    else
    {
      if (v25.dataWindow.xMax >= v25.dataWindow.xMin) {
        LODWORD(level_size) = v25.dataWindow.xMax - v25.dataWindow.xMin + 1;
      }
      else {
        LODWORD(level_size) = 0;
      }
      if (v25.dataWindow.yMax >= v25.dataWindow.yMin) {
        LODWORD(v23) = v25.dataWindow.yMax - v25.dataWindow.yMin + 1;
      }
      else {
        LODWORD(v23) = 0;
      }
    }
    *(_DWORD *)(v20 + 56) = level_size;
    *(_DWORD *)(v20 + 60) = v23;
    *(axr_box2i_t *)(v20 + 64) = v25.dataWindow;
    *(_DWORD *)(v20 + 36) = axr_data_get_channel_count(fileData, partIndex);
  }
  return (axr_decoder_t)v20;
}

axr_decoder_t axr_decoder_create_rgba(axr_data_t fileData, const char *layerName, unint64_t partIndex, unint64_t levelIndex, axr_flags_t flags)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  if (layerName)
  {
    uint64_t v9 = layerName;
    unint64_t channel_count = 0;
    axr_data_t v11 = 0;
    uint64_t v12 = 0;
  }
  else
  {
    unint64_t layer_count = axr_data_get_layer_count(fileData, partIndex);
    if (!layer_count) {
      goto LABEL_54;
    }
    unint64_t v48 = layer_count;
    unint64_t v49 = 0;
    while (1)
    {
      memset(&v89, 0, 24);
      axr_data_get_layer_info((axr_layer_info_t *)&v89, fileData, partIndex, v49, axr_layer_info_current);
      uint64_t v12 = *(const char **)&v89.sampleType;
      if (!*(void *)&v89.sampleType || !**(unsigned char **)&v89.sampleType) {
        break;
      }
      if (v48 == ++v49) {
        goto LABEL_52;
      }
    }
    axr_data_t v11 = *(uint32_t **)&v89.sampleBits;
    unint64_t channel_count = *(void *)&v89.ySampling;
    if (*(void *)&v89.sampleBits) {
      goto LABEL_53;
    }
LABEL_52:
    axr_data_get_layer_info((axr_layer_info_t *)&v89, fileData, partIndex, 0, axr_layer_info_current);
    uint64_t v12 = *(const char **)&v89.sampleType;
    axr_data_t v11 = *(uint32_t **)&v89.sampleBits;
    unint64_t channel_count = *(void *)&v89.ySampling;
LABEL_53:
    uint64_t v9 = v12;
    if (!v12)
    {
LABEL_54:
      unint64_t channel_count = axr_data_get_channel_count(fileData, partIndex);
      uint64_t v51 = malloc_type_malloc(4 * channel_count, 0x100004052888210uLL);
      if (!v51)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
          AXRLogDebug((uint64_t)"axr_decoder_create_rgba: out of memory\n", v14, v15, v16, v17, v18, v19, v20, v79);
        }
        return 0;
      }
      int v24 = v51;
      if (channel_count)
      {
        uint64_t v52 = 0;
        do
        {
          v51[v52] = v52;
          ++v52;
        }
        while (channel_count > v52);
        axr_data_t v11 = v51;
        goto LABEL_14;
      }
LABEL_73:
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | flags) & 2) == 0) {
        goto LABEL_78;
      }
      char v79 = partIndex;
      int v50 = "axr_decoder_create_rgba: no channels found for part %lu, layerName: %s\n";
      goto LABEL_77;
    }
  }
  unint64_t v13 = axr_data_get_layer_count(fileData, partIndex);
  if (v13)
  {
    unint64_t v21 = 0;
    unint64_t v22 = v13 - 1;
    do
    {
      axr_data_get_layer_info((axr_layer_info_t *)&v89, fileData, partIndex, v21, axr_layer_info_current);
      uint64_t v12 = *(const char **)&v89.sampleType;
      axr_data_t v11 = *(uint32_t **)&v89.sampleBits;
      unint64_t channel_count = *(void *)&v89.ySampling;
    }
    while (strcmp(*(const char **)&v89.sampleType, v9) && v22 != v21++);
  }
  if (!v12 && !*v9)
  {
    axr_data_get_layer_info((axr_layer_info_t *)&v89, fileData, partIndex, 0, axr_layer_info_current);
    axr_data_t v11 = *(uint32_t **)&v89.sampleBits;
    unint64_t channel_count = *(void *)&v89.ySampling;
  }
  int v24 = 0;
  if (!channel_count) {
    goto LABEL_73;
  }
LABEL_14:
  unint64_t levelIndexa = levelIndex;
  uint64_t v25 = 0;
  size_t v26 = v11;
  unint64_t v27 = channel_count;
  do
  {
    unsigned int v28 = *v26++;
    axr_data_get_channel_info(&v89, fileData, partIndex, v28, axr_channel_info_current);
    v25 |= 1 << SLOBYTE(v89.channelType);
    --v27;
  }
  while (v27);
  decoder = axr_decoder_create(fileData, partIndex, levelIndexa, flags);
  if (!decoder)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) == 0) {
      goto LABEL_78;
    }
    int v50 = "axr_decoder_create_rgba:  failed to create decoder\n";
LABEL_77:
    AXRLogDebug((uint64_t)v50, v14, v15, v16, v17, v18, v19, v20, v79);
LABEL_78:
    BOOL v46 = v24;
    goto LABEL_79;
  }
  uint64_t v83 = v11;
  unint64_t v84 = channel_count;
  int v80 = v24;
  unint64_t v29 = 0;
  uint64_t v30 = v25;
  while (2)
  {
    if ((axr_decoder_create_rgba::kColorModels[3 * v29] & ~v30) != 0) {
      goto LABEL_35;
    }
    axr_decoder_clear_channel_list(decoder);
    unint64_t v31 = 0;
    uint64_t v82 = 0;
    uint64_t v32 = 3;
    if (v29 >= 3) {
      uint64_t v32 = 1;
    }
    unint64_t v85 = v29;
    uint64_t v86 = v32;
    axr_type_t sampleType = -1;
    do
    {
      unint64_t levelIndexb = v31;
      uint64_t v34 = (_DWORD *)&axr_decoder_create_rgba::kColorModels[3 * v29 + 1] + v31;
      unint64_t v35 = v84;
      while (1)
      {
        uint32_t v37 = *v11++;
        uint32_t v36 = v37;
        memset(&v89, 0, sizeof(v89));
        axr_data_get_channel_info(&v89, fileData, partIndex, v37, axr_channel_info_current);
        if (*v34 == v89.channelType) {
          break;
        }
LABEL_30:
        if (!--v35) {
          goto LABEL_33;
        }
      }
      if (sampleType != -1 && v89.sampleType != sampleType)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | flags) & 2) != 0)
        {
          char name = axr_channel_type_get_name(v89.channelType);
          axr_type_get_name(v89.sampleType);
          axr_type_get_name(sampleType);
          AXRLogDebug((uint64_t)"axr_decoder_create_rgba: type of %s channel %s doesn't match other channels %s. Skipping...\n", v39, v40, v41, v42, v43, v44, v45, name);
        }
        goto LABEL_30;
      }
      axr_decoder_append_channel(decoder, v36, flags);
      axr_type_t sampleType = v89.sampleType;
      ++v82;
LABEL_33:
      unint64_t v31 = levelIndexb + 1;
      axr_data_t v11 = v83;
      unint64_t v29 = v85;
    }
    while (levelIndexb + 1 != v86);
    uint64_t v30 = v25;
    if (v82 != v86)
    {
LABEL_35:
      if (++v29 == 4)
      {
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
          AXRLogDebug((uint64_t)"axr_decoder_create_rgba: no channels found for part %lu, layerName: %s matching recognized colorModels\n", v14, v15, v16, v17, v18, v19, v20, partIndex);
        }
        BOOL v46 = v80;
LABEL_79:
        free(v46);
        return 0;
      }
      continue;
    }
    break;
  }
  if ((v25 & 0xF0) == 0) {
    goto LABEL_96;
  }
  double v53 = v83;
  unint64_t v54 = v84;
  do
  {
    uint32_t v56 = *v53++;
    uint32_t v55 = v56;
    memset(&v89, 0, sizeof(v89));
    axr_data_get_channel_info(&v89, fileData, partIndex, v56, axr_channel_info_current);
    if (v89.channelType == axr_channel_type_alpha)
    {
      if (sampleType == v89.sampleType)
      {
        unsigned int v77 = decoder;
        uint32_t v78 = v55;
        goto LABEL_95;
      }
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | flags) & 2) != 0)
      {
        char v57 = axr_channel_type_get_name(v89.channelType);
        AXRLogDebug((uint64_t)"axr_decoder_create_rgba: Skipping %s channel. Non-matching data type\n", v58, v59, v60, v61, v62, v63, v64, v57);
      }
    }
    --v54;
  }
  while (v54);
  if (v84 <= 1) {
    uint64_t v66 = 1;
  }
  else {
    uint64_t v66 = v84;
  }
  while (2)
  {
    uint32_t v68 = *v11++;
    uint32_t v67 = v68;
    memset(&v89, 0, sizeof(v89));
    axr_data_get_channel_info(&v89, fileData, partIndex, v68, axr_channel_info_current);
    if ((v89.channelType & 0xF0) == 0)
    {
LABEL_91:
      if (!--v66) {
        goto LABEL_96;
      }
      continue;
    }
    break;
  }
  if (sampleType != v89.sampleType)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | flags) & 2) != 0)
    {
      char v69 = axr_channel_type_get_name(v89.channelType);
      AXRLogDebug((uint64_t)"axr_decoder_create_rgba: Skipping %s channel. Non-matching data type\n", v70, v71, v72, v73, v74, v75, v76, v69);
    }
    goto LABEL_91;
  }
  unsigned int v77 = decoder;
  uint32_t v78 = v67;
LABEL_95:
  axr_decoder_append_channel(v77, v78, flags);
LABEL_96:
  free(v80);
  return decoder;
}

axr_error_t axr_decoder_clear_channel_list(axr_decoder_t decoder)
{
  for (Class i = decoder[3].isa; i; Class i = decoder[3].isa)
  {
    decoder[3].Class isa = *(Class *)((char *)i + 8);
    MEMORY[0x22A6AD870]();
  }
  LODWORD(decoder[4].isa) = 0;
  return 0;
}

axr_error_t axr_decoder_append_channel(axr_decoder_t decoder, uint32_t channelIndex, axr_flags_t flags)
{
  uint64_t v10 = (Class)((char *)decoder[2].isa + 16);
  AXRData::GetSampleType(v10, LODWORD(decoder[5].isa), channelIndex, flags, v3, v4, v5, v6);
  AXRData::GetChannelType(v10, LODWORD(decoder[5].isa), channelIndex, flags, v11, v12, v13, v14);
  operator new();
}

void ReadChannel::CreateCopy(ReadChannel *this)
{
}

axr_error_t axr_decoder_set_subregion(axr_decoder_t d, uint32_t xOrigin, uint32_t yOrigin, uint32_t xSize, uint32_t ySize, axr_flags_t flags)
{
  int v8 = flags;
  uint64_t ImageSize = AXRData::GetImageSize((AXRData *)((char *)d[2].isa + 16), LODWORD(d[5].isa), HIDWORD(d[5].isa), *(uint64_t *)&xSize, *(uint64_t *)&ySize, flags, v6, v7);
  if (xSize + xOrigin > ImageSize)
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"ROI x:[%d, %d] extends off right edge of data window. (width = %u)", v15, v16, v17, v18, v19, v20, v21, LODWORD(d[8].isa) + xOrigin);
    }
    return -1;
  }
  if (ySize + yOrigin > HIDWORD(ImageSize))
  {
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"ROI y:[%d, %d] extends off bottom edge of data window. (height = %u)", v15, v16, v17, v18, v19, v20, v21, LODWORD(d[9].isa) + yOrigin);
    }
    return -1;
  }
  axr_error_t result = axr_error_success;
  LODWORD(d[6].isa) = xOrigin;
  HIDWORD(d[6].isa) = yOrigin;
  LODWORD(d[7].isa) = xSize;
  HIDWORD(d[7].isa) = ySize;
  return result;
}

uint64_t AXRData::GetSampleType(AXRData *this, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (Part *)*((void *)this + 9);
  if (a2 && v8)
  {
    unint64_t v9 = 1;
    do
    {
      int v8 = (Part *)*((void *)v8 + 1);
      if (v9 >= a2) {
        break;
      }
      ++v9;
    }
    while (v8);
  }
  if (!v8) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(unsigned int *)(Part::GetChannel(v8, a3, a4, a4, a5, a6, a7, a8) + 72);
}

uint64_t AXRData::GetChannelType(AXRData *this, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (Part *)*((void *)this + 9);
  if (a2 && v8)
  {
    unint64_t v9 = 1;
    do
    {
      int v8 = (Part *)*((void *)v8 + 1);
      if (v9 >= a2) {
        break;
      }
      ++v9;
    }
    while (v8);
  }
  if (!v8) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(unsigned int *)(Part::GetChannel(v8, a3, a4, a4, a5, a6, a7, a8) + 128);
}

axr_error_t axr_decoder_append_constant_value_channel(axr_decoder_t decoder, double value, axr_type_t sampleType, axr_channel_type_t channelType, axr_flags_t flags)
{
}

uint32_t axr_decoder_get_channel_count(axr_decoder_t decoder)
{
  if (decoder) {
    LODWORD(decoder) = decoder[4].isa;
  }
  return decoder;
}

void *__cdecl axr_decoder_create_colorspace(void *decoder, axr_flags_t flags, void *options)
{
  if (decoder)
  {
    uint64_t v13 = (axr_decoder *)decoder;
    if (!*((_DWORD *)decoder + 8))
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
        AXRLogDebug((uint64_t)"axr_decoder_create_colorspace: no channels have been appended", flags, (uint64_t)options, v3, v4, v5, v6, v7, v15);
      }
    }
    uint64_t v14 = (AXRData *)(*((void *)v13 + 2) + 16);
    return (void *)AXRData::CreateColorSpaceForImage(v14, v13, (uint64_t)options, flags, 0, v5, v6, v7, v8, v9, v10);
  }
  return decoder;
}

uint64_t AXRData::CreateColorSpaceForImage(AXRData *this, axr_decoder *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, __n128 a11)
{
  unint64_t v11 = *((unsigned int *)a2 + 10);
  uint64_t v12 = (Part *)*((void *)this + 9);
  if (v11) {
    BOOL v13 = v12 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    unint64_t v14 = 1;
    do
    {
      uint64_t v12 = (Part *)*((void *)v12 + 1);
      if (v14 >= v11) {
        break;
      }
      ++v14;
    }
    while (v12);
  }
  if (!v12) {
    AXRData::GetChannelCount((uint64_t)this, *((unsigned int *)a2 + 10), a3, a4, a5, a6, a7, a8);
  }

  return Part::CreateColorSpace(v12, a2, a3, (axr_flags_t)a4, a5, a9, a10, a11);
}

void *__cdecl axr_decoder_create_rgba_colorspace(void *decoder, axr_flags_t flags, void *options)
{
  if (decoder)
  {
    BOOL v13 = (axr_decoder *)decoder;
    if (!*((_DWORD *)decoder + 8))
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | flags) & 2) != 0) {
        AXRLogDebug((uint64_t)"axr_decoder_create_colorspace: no channels have been appended", flags, (uint64_t)options, v3, v4, v5, v6, v7, v15);
      }
    }
    unint64_t v14 = (AXRData *)(*((void *)v13 + 2) + 16);
    return (void *)AXRData::CreateColorSpaceForImage(v14, v13, (uint64_t)options, flags, 1, v5, v6, v7, v8, v9, v10);
  }
  return decoder;
}

void axr_decoder::~axr_decoder(NSObject *this)
{
}

uint64_t axr_decoder_translate_channel_index(axr_decoder_t decoder, unint64_t channelIndex)
{
  if (!decoder) {
    return -1;
  }
  Class isa = decoder[3].isa;
  if (!isa) {
    return -1;
  }
  for (unint64_t i = (LODWORD(decoder[4].isa) - 1); i < channelIndex; --i)
  {
    Class isa = (Class)*((void *)isa + 1);
    if (!isa) {
      return -1;
    }
  }
  if (*((unsigned char *)isa + 24)) {
    return -1;
  }
  else {
    return i;
  }
}

axr_decoder_info_t *__cdecl axr_decoder_get_info(axr_decoder_info_t *__return_ptr retstr, axr_decoder_info_t *decoder, axr_decoder_info_struct_version_t version)
{
  if (!decoder)
  {
LABEL_7:
    *(_OWORD *)&retstr->levelIndex = 0u;
    *(axr_decoder_info_t::$A147FA619674AD8F0C1DA22DD7FB259D *)((char *)&retstr->subregion + 4) = 0u;
    *(_OWORD *)&retstr->data = 0u;
    return decoder;
  }
  __n128 v10 = decoder;
  if ((int)version >= 2)
  {
    uint64_t v11 = *(void *)&decoder[1].subregion.origin.y;
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v11) & 2) != 0) {
      AXRLogError((uint64_t)"Error: axr_decoder_get_info: You must pass axr_decoder_info_current here.", *(uint64_t *)&version, v3, v4, v5, v6, v7, v8, v17);
    }
    goto LABEL_7;
  }
  uint64_t v12 = *(void *)&decoder->levelIndex;
  retstr->data = (axr_data *)v12;
  unint64_t height = decoder->subregion.size.height;
  retstr->partIndex = height;
  axr_level_mode_t LevelMode = AXRData::GetLevelMode((AXRData *)(v12 + 16), height, v3, v4, v5, v6, v7, v8);
  unint64_t v15 = v10->subregion.size.height;
  unint64_t v16 = *((unsigned int *)&v10->subregion + 4);
  retstr->levelMode = LevelMode;
  retstr->levelIndex = v16;
  decoder = (axr_decoder_info_t *)axr_data_get_level_size(*(axr_data_t *)&v10->levelIndex, v15, v16);
  retstr->levelSize = (axr_size_t)decoder;
  retstr->subregion = *(axr_decoder_info_t::$A147FA619674AD8F0C1DA22DD7FB259D *)&v10[1].data;
  return decoder;
}

uint64_t AXRData::GetLevelMode(AXRData *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *((void *)this + 9);
  if (a2 && v8)
  {
    unint64_t v9 = 1;
    do
    {
      uint64_t v8 = *(void *)(v8 + 8);
      if (v9 >= a2) {
        break;
      }
      ++v9;
    }
    while (v8);
  }
  if (!v8) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(unsigned __int8 *)(v8 + 164);
}

axr_channel_info_t *__cdecl axr_decoder_get_channel_info(axr_channel_info_t *__return_ptr retstr, axr_channel_info_t *decoder, unint64_t channelIndex, axr_channel_info_struct_version_t version)
{
  if (!decoder) {
    goto LABEL_18;
  }
  __n128 v10 = decoder;
  unsigned int v12 = *(_DWORD *)&decoder->name[8];
  decoder = (axr_channel_info_t *)((char *)decoder + 32);
  unsigned int v11 = v12;
  uint64_t v13 = *(void *)&decoder->name[24];
  if (v12 <= channelIndex) {
    axr_decoder_get_channel_info_cold_2((uint64_t)decoder, channelIndex, *(void *)&decoder->name[24], v4, v5, v6, v7, v8);
  }
  if (version != axr_channel_info_current) {
    axr_decoder_get_channel_info_cold_1(v13, channelIndex, *(uint64_t *)&version, v4, v5, v6, v7, v8);
  }
  unint64_t v14 = v11 - 1;
  unint64_t v15 = *(unsigned int **)v10->name;
  if (v14 > channelIndex && v15 != 0)
  {
    unint64_t v17 = v14 - 1;
    do
    {
      unint64_t v15 = (unsigned int *)*((void *)v15 + 1);
      if (v17 <= channelIndex) {
        break;
      }
      --v17;
    }
    while (v15);
  }
  if (v15)
  {
    if (*((unsigned char *)v15 + 24))
    {
      *(_OWORD *)&retstr->name[224] = 0u;
      *(_OWORD *)&retstr->name[208] = 0u;
      *(_OWORD *)&retstr->name[192] = 0u;
      *(_OWORD *)&retstr->name[176] = 0u;
      *(_OWORD *)&retstr->name[160] = 0u;
      *(_OWORD *)&retstr->name[144] = 0u;
      *(_OWORD *)&retstr->name[128] = 0u;
      *(_OWORD *)&retstr->name[112] = 0u;
      *(_OWORD *)&retstr->name[96] = 0u;
      *(_OWORD *)&retstr->name[80] = 0u;
      *(_OWORD *)&retstr->name[64] = 0u;
      *(_OWORD *)&retstr->name[48] = 0u;
      *(_OWORD *)&retstr->name[32] = 0u;
      *(_OWORD *)&retstr->name[16] = 0u;
      *(_OWORD *)&retstr->sampleBits = 0u;
      *(_OWORD *)&retstr->name[240] = 0u;
      *(_OWORD *)retstr->char name = 0u;
      uint64_t v18 = *((void *)v15 + 2);
      *(void *)&retstr->axr_type_t sampleType = v18;
      retstr->sampleBits = axr_type_get_size((axr_type_t)v18);
      *(void *)&retstr->xSampling = 0x100000001;
      char name = axr_channel_type_get_name(retstr->channelType);
      decoder = (axr_channel_info_t *)strncpy(retstr->name, name, 0x100uLL);
      int v24 = *(unsigned int **)v10->name;
      if (v24)
      {
        uint64_t v25 = *(void *)v10->name;
        while (*((unsigned char *)v15 + 24))
        {
          uint64_t v25 = *(void *)(v25 + 8);
          if (!v25) {
            return decoder;
          }
        }
        if (*((unsigned char *)v24 + 24)) {
          unint64_t v29 = -1;
        }
        else {
          unint64_t v29 = *v24;
        }
        decoder = (axr_channel_info_t *)AXRData::GetChannel((AXRData *)(*(void *)&v10->ySampling + 16), *(unsigned int *)&v10->name[16], v29, v13, v20, v21, v22, v23);
        uint32_t v30 = *(_DWORD *)&decoder->name[80];
        retstr->xSampling = *(_DWORD *)&decoder->name[56];
        retstr->ySampling = v30;
      }
    }
    else
    {
      unint64_t v26 = *v15;
      unint64_t v27 = *(NSObject **)&v10->ySampling;
      unint64_t v28 = *(unsigned int *)&v10->name[16];
      return axr_data_get_channel_info(retstr, v27, v28, v26, axr_channel_info_current);
    }
  }
  else
  {
LABEL_18:
    *(void *)&retstr->name[248] = 0;
    *(_OWORD *)&retstr->name[216] = 0u;
    *(_OWORD *)&retstr->name[232] = 0u;
    *(_OWORD *)&retstr->name[184] = 0u;
    *(_OWORD *)&retstr->name[200] = 0u;
    *(_OWORD *)&retstr->name[152] = 0u;
    *(_OWORD *)&retstr->name[168] = 0u;
    *(_OWORD *)&retstr->name[120] = 0u;
    *(_OWORD *)&retstr->name[136] = 0u;
    *(_OWORD *)&retstr->name[88] = 0u;
    *(_OWORD *)&retstr->name[104] = 0u;
    *(_OWORD *)&retstr->name[56] = 0u;
    *(_OWORD *)&retstr->name[72] = 0u;
    *(_OWORD *)&retstr->name[24] = 0u;
    *(_OWORD *)&retstr->name[40] = 0u;
    *(_OWORD *)&retstr->ySampling = 0u;
    *(_OWORD *)&retstr->name[8] = 0u;
    *(_OWORD *)&retstr->axr_type_t sampleType = 0u;
  }
  return decoder;
}

uint64_t AXRData::GetChannel(AXRData *this, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (Part *)*((void *)this + 9);
  if (a2 && v8)
  {
    unint64_t v9 = 1;
    do
    {
      uint64_t v8 = (Part *)*((void *)v8 + 1);
      if (v9 >= a2) {
        break;
      }
      ++v9;
    }
    while (v8);
  }
  if (!v8) {
    AXRData::GetChannelCount((uint64_t)this, a2, a3, a4, a5, a6, a7, a8);
  }

  return Part::GetChannel(v8, a3, a4, a4, a5, a6, a7, a8);
}

axr_data_t axr_decoder_get_data(axr_data_t data)
{
  if (data) {
    return (axr_data_t)data[2].isa;
  }
  return data;
}

uint64_t ReadChannel::Print(ReadChannel *this, char *a2, size_t a3, int a4, const AXRData *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 24))
  {
    axr_channel_type_get_name(*((axr_channel_type_t *)this + 5));
    axr_type_get_name(*((axr_type_t *)this + 4));
    LODWORD(result) = snprintf(a2, a3, "\tRead Channel %p\n\t\tvalue:     %f\t(%s)\n\t\ttype:      %s\n");
  }
  else
  {
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    *(_OWORD *)__str = 0u;
    long long v15 = 0u;
    uint64_t Channel = (void *)AXRData::GetChannel(a5, a6, *(unsigned int *)this, 0, (uint64_t)a5, a6, a7, a8);
    ChannelDescription::CopyName(Channel, (uint64_t)a5, __str, 0x100uLL);
    axr_channel_type_get_name(*((axr_channel_type_t *)this + 5));
    axr_type_get_name(*((axr_type_t *)this + 4));
    LODWORD(result) = snprintf(a2, a3, "\tRead Channel %p\n\t\tchannel:   %u\t(%s, \"%s\")\n\t\ttype:      %s\n");
  }
  return (int)result;
}

uint64_t RowCompressor::ReadData(void *a1, uint64_t a2)
{
  if (!*(void *)(a2 + 88)) {
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 72) * *(unsigned int *)(a2 + 36);
  unint64_t v6 = (v5 * *(unsigned int *)(a2 + 24) + 63) & 0xFFFFFFFFFFFFFFC0;
  *(void *)(a2 + 176) = v6;
  *(void *)(a2 + 192) = v6;
  *(void *)(a2 + 200) = v5 * v4;
  (*(void (**)(void *))(*a1 + 56))(a1);
  uint64_t v7 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 48))(a1, a2);
  unint64_t v8 = (v7 + 63) & 0xFFFFFFFFFFFFFFC0;
  *(void *)(a2 + 144) = v8;
  *(void *)(a2 + 160) = -1;
  LODWORD(v9) = *(_DWORD *)(a2 + 12) >> 3;
  if (v9 <= 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = v9;
  }
  unint64_t v10 = *(void *)(a2 + 192);
  if (v10 <= v8) {
    unint64_t v10 = (v7 + 63) & 0xFFFFFFFFFFFFFFC0;
  }
  if (v10 <= *(void *)(a2 + 176)) {
    unint64_t v10 = *(void *)(a2 + 176);
  }
  unsigned int v11 = (void *)a1[1];
  v11[7] = v10 * v9;
  *(void *)(a2 + 136) = EncoderStream::GetBytes<char>(v11, v8);
  unsigned int v12 = EncoderStream::GetBytes<char>((void *)a1[1], *(void *)(a2 + 192));
  *(void *)(a2 + 184) = v12;
  unint64_t v13 = *(void *)(a2 + 176);
  if (v13)
  {
    unint64_t v14 = EncoderStream::GetBytes<char>((void *)a1[1], v13);
    uint64_t v15 = *(void *)(a2 + 184);
  }
  else
  {
    uint64_t v15 = (uint64_t)v12;
    unint64_t v14 = 0;
  }
  *(void *)(a2 + 168) = v14;
  uint64_t v16 = *(void *)(a2 + 88);
  if (!v16) {
    return 0;
  }
  while (1)
  {
    uint64_t v17 = *(void *)(v16 + 16);
    size_t size = axr_type_get_size((axr_type_t)*(_DWORD *)(v16 + 56));
    char v19 = size;
    size_t v20 = size * v17;
    unint64_t v21 = size * v17 * (*(_DWORD *)(a2 + 24) * *(_DWORD *)(a2 + 36));
    uint64_t result = EncoderLayer::CompressTileRow(v16, v15, v21, a2);
    if (result <= 0) {
      break;
    }
    if (v21 > result) {
      bzero((void *)(result + v15), v21 - result);
    }
    if (v14)
    {
      long long v23 = (void (*)(uint64_t *, char **, void, size_t, uint64_t, uint64_t))*(&RowCompressor::ReadData(CompressionInfo &)const::FuncList[(v19 & 4) - 1]
                                                                                       + v17);
      uint64_t v26 = v15;
      long long v27 = v14;
      uint64_t v24 = (*(void *)(a2 + 72) >> 1) * *(unsigned int *)(a2 + 32);
      if (*(_DWORD *)(a2 + 8))
      {
        unint64_t v25 = 0;
        do
        {
          v23(&v26, &v27, *(void *)(a2 + 32), v20 * *(unsigned int *)(a2 + 24), v24, v16);
          ++v25;
        }
        while (v25 < *(unsigned int *)(a2 + 8));
      }
      v14 += v24;
    }
    v15 += v21;
    uint64_t v16 = *(void *)v16;
    if (!v16) {
      return 0;
    }
  }
  if (!result) {
    return -10;
  }
  return result;
}

uint64_t *Deinterleave<unsigned short,1>(uint64_t *result, __n128 **a2, unint64_t a3, uint64_t a4, uint64_t a5, int8x16_t a6)
{
  uint64_t v6 = *result;
  if (HIDWORD(a3))
  {
    int v7 = 0;
    unint64_t v8 = HIDWORD(a3) * a5;
    uint64_t v9 = *a2;
    do
    {
      unint64_t v10 = v9;
      uint64_t v11 = v6;
      unsigned int v12 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v12 = a3;
        uint64_t v11 = v6;
        unint64_t v10 = v9;
        do
        {
          *(int8x16x2_t *)a6.i8 = vld2q_s8((const char *)v11);
          v11 += 32;
          *unint64_t v10 = (__n128)a6;
          *(__n128 *)((char *)v10++ + v8) = v13;
          v12 -= 16;
        }
        while (v12 > 0xF);
      }
      if (v12 >= 4)
      {
        do
        {
          unint64_t v14 = *(void *)v11;
          v11 += 8;
          a6.i64[0] = v14;
          v10->n128_u32[0] = vmovn_s16((int16x8_t)a6).u32[0];
          a6 = vrev16q_s8(a6);
          *(unsigned __int32 *)((char *)v10->n128_u32 + v8) = vmovn_s16((int16x8_t)a6).u32[0];
          unint64_t v10 = (__n128 *)((char *)v10 + 4);
          v12 -= 4;
        }
        while (v12 > 3);
      }
      for (; v12; --v12)
      {
        char v15 = *(unsigned char *)v11;
        unsigned __int8 v16 = *(unsigned char *)(v11 + 1);
        v11 += 2;
        v10->n128_u8[0] = v15;
        v10->n128_u8[v8] = v16;
        unint64_t v10 = (__n128 *)((char *)v10 + 1);
      }
      v6 += a4;
      uint64_t v9 = (__n128 *)((char *)v9 + a5);
      ++v7;
    }
    while (v7 != HIDWORD(a3));
    uint64_t v6 = *result;
  }
  unint64_t v17 = 2 * a3;
  *uint64_t result = v17 + v6;
  *a2 = (__n128 *)((char *)*a2 + (v17 >> 1));
  return result;
}

const __int16 **Deinterleave<unsigned short,2>(const __int16 **result, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __n128 a7, int8x16_t a8)
{
  v25[2] = *MEMORY[0x263EF8340];
  unint64_t v8 = *result;
  uint64_t v9 = *a2;
  uint64_t v10 = *(void *)(a6 + 8);
  v25[*(unsigned int *)(v10 + 12)] = 0;
  v25[*(unsigned int *)(v10 + 28)] = a3;
  if (HIDWORD(a3))
  {
    int v11 = 0;
    unint64_t v12 = HIDWORD(a3) * a5;
    uint64_t v13 = v25[0];
    uint64_t v14 = v25[1];
    do
    {
      uint64_t v15 = v9;
      unsigned __int8 v16 = v8;
      unsigned int v17 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v17 = a3;
        long long v18 = v8;
        uint64_t v15 = v9;
        do
        {
          unsigned __int8 v16 = v18 + 32;
          *(int16x8x2_t *)(&a8 - 1) = vld2q_s16(v18);
          char v19 = v18 + 16;
          int16x8x2_t v26 = vld2q_s16(v19);
          size_t v20 = (int8x16_t *)(v13 + v15);
          unint64_t v21 = (int8x16_t *)(v14 + v15);
          *size_t v20 = vuzp1q_s8(v22, (int8x16_t)v26.val[0]);
          int8x16_t *v21 = vuzp1q_s8(a8, (int8x16_t)v26.val[1]);
          *(int8x16_t *)((char *)v20 + v12) = vuzp2q_s8(v22, (int8x16_t)v26.val[0]);
          a7 = (__n128)vuzp2q_s8(a8, (int8x16_t)v26.val[1]);
          *(__n128 *)((char *)v21 + v12) = a7;
          v15 += 16;
          v17 -= 16;
          long long v18 = v16;
        }
        while (v17 > 0xF);
      }
      if (v17 >= 4)
      {
        do
        {
          a7 = (__n128)vld2_s16(v16);
          v16 += 8;
          long long v23 = (_DWORD *)(v13 + v15);
          uint64_t v24 = (_DWORD *)(v14 + v15);
          *long long v23 = vmovn_s16((int16x8_t)a7).u32[0];
          *uint64_t v24 = vmovn_s16((int16x8_t)a8).u32[0];
          *(_DWORD *)((char *)v23 + v12) = vmovn_s16((int16x8_t)vrev16q_s8((int8x16_t)a7)).u32[0];
          a7 = (__n128)vrev16q_s8(a8);
          a7.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)a7);
          *(_DWORD *)((char *)v24 + v12) = a7.n128_u32[0];
          v15 += 4;
          v17 -= 4;
        }
        while (v17 > 3);
      }
      for (; v17; --v17)
      {
        a7.n128_u16[0] = *v16;
        a7.n128_u16[2] = v16[1];
        a8.i32[0] = a7.n128_i32[1];
        *(unsigned char *)(v13 + v15) = vmovn_s16((int16x8_t)a7).u8[0];
        *(unsigned char *)(v14 + v15) = vmovn_s16((int16x8_t)a8).u8[0];
        *(unsigned char *)(v13 + v15 + v12) = a7.n128_u8[1];
        v16 += 2;
        *(unsigned char *)(v14 + v15++ + v12) = a7.n128_u8[5];
      }
      unint64_t v8 = (const __int16 *)((char *)v8 + a4);
      v9 += a5;
      ++v11;
    }
    while (v11 != HIDWORD(a3));
    unint64_t v8 = *result;
  }
  *uint64_t result = &v8[2 * a3];
  *a2 += 2 * a3;
  return result;
}

const __int16 **Deinterleave<unsigned short,3>(const __int16 **result, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __n128 a7, int8x16_t a8, int8x16_t a9)
{
  uint64_t v9 = 0;
  void v40[3] = *MEMORY[0x263EF8340];
  uint64_t v10 = *result;
  uint64_t v11 = *a2;
  uint64_t v12 = *(void *)(a6 + 8);
  for (uint64_t i = 12; i != 60; i += 16)
  {
    v40[*(unsigned int *)(v12 + i)] = v9;
    v9 += a3;
  }
  if (HIDWORD(a3))
  {
    int v14 = 0;
    unint64_t v15 = HIDWORD(a3) * a5;
    uint64_t v16 = v40[0];
    uint64_t v17 = v40[1];
    uint64_t v18 = v40[2];
    do
    {
      uint64_t v19 = v11;
      size_t v20 = v10;
      unsigned int v21 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v21 = a3;
        int8x16_t v22 = v10;
        uint64_t v19 = v11;
        do
        {
          size_t v20 = v22 + 48;
          *(int16x8x3_t *)(&a8 - 1) = vld3q_s16(v22);
          long long v23 = v22 + 24;
          int16x8x3_t v41 = vld3q_s16(v23);
          uint64_t v24 = (int8x16_t *)(v16 + v19);
          unint64_t v25 = (int8x16_t *)(v17 + v19);
          int16x8x2_t v26 = (int8x16_t *)(v18 + v19);
          *uint64_t v24 = vuzp1q_s8(v27, (int8x16_t)v41.val[0]);
          *(int8x16_t *)((char *)v24 + v15) = vuzp2q_s8(v27, (int8x16_t)v41.val[0]);
          *unint64_t v25 = vuzp1q_s8(a8, (int8x16_t)v41.val[1]);
          *(int8x16_t *)((char *)v25 + v15) = vuzp2q_s8(a8, (int8x16_t)v41.val[1]);
          int8x16_t *v26 = vuzp1q_s8(a9, (int8x16_t)v41.val[2]);
          a7 = (__n128)vuzp2q_s8(a9, (int8x16_t)v41.val[2]);
          *(__n128 *)((char *)v26 + v15) = a7;
          v19 += 16;
          v21 -= 16;
          int8x16_t v22 = v20;
        }
        while (v21 > 0xF);
      }
      if (v21 >= 4)
      {
        do
        {
          *(int16x4x3_t *)a7.n128_u64 = vld3_s16(v20);
          v20 += 12;
          long long v28 = (_DWORD *)(v16 + v19);
          long long v29 = (_DWORD *)(v17 + v19);
          uint64_t v30 = (_DWORD *)(v18 + v19);
          *long long v28 = vmovn_s16((int16x8_t)a7).u32[0];
          *(_DWORD *)((char *)v28 + v15) = vmovn_s16((int16x8_t)vrev16q_s8((int8x16_t)a7)).u32[0];
          *long long v29 = vmovn_s16((int16x8_t)a8).u32[0];
          *(_DWORD *)((char *)v29 + v15) = vmovn_s16((int16x8_t)vrev16q_s8(a8)).u32[0];
          *uint64_t v30 = vmovn_s16((int16x8_t)a9).u32[0];
          a7 = (__n128)vrev16q_s8(a9);
          *(_DWORD *)((char *)v30 + v15) = vmovn_s16((int16x8_t)a7).u32[0];
          v19 += 4;
          v21 -= 4;
        }
        while (v21 > 3);
      }
      for (; v21; --v21)
      {
        char v31 = *(unsigned char *)v20;
        char v32 = *((unsigned char *)v20 + 1);
        char v33 = *((unsigned char *)v20 + 2);
        char v34 = *((unsigned char *)v20 + 3);
        char v35 = *((unsigned char *)v20 + 4);
        char v36 = *((unsigned char *)v20 + 5);
        v20 += 3;
        uint32_t v37 = (unsigned char *)(v16 + v19);
        uint64_t v38 = (unsigned char *)(v17 + v19);
        *uint32_t v37 = v31;
        uint64_t v39 = (unsigned char *)(v18 + v19);
        v37[v15] = v32;
        *uint64_t v38 = v33;
        v38[v15] = v34;
        *uint64_t v39 = v35;
        v39[v15] = v36;
        ++v19;
      }
      uint64_t v10 = (const __int16 *)((char *)v10 + a4);
      v11 += a5;
      ++v14;
    }
    while (v14 != HIDWORD(a3));
    uint64_t v10 = *result;
  }
  *uint64_t result = &v10[3 * a3];
  *a2 += 3 * a3;
  return result;
}

const __int16 **Deinterleave<unsigned short,4>(const __int16 **result, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __n128 a7, int16x8_t a8, int16x8_t a9, int16x8_t a10, int16x8_t a11, int16x8_t a12, int16x8_t a13)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  v49[4] = *MEMORY[0x263EF8340];
  unint64_t v15 = *result;
  uint64_t v16 = *a2;
  uint64_t v17 = *(void *)(a6 + 8) + 12;
  do
  {
    v49[*(unsigned int *)(v17 + v14)] = v13;
    v14 += 16;
    v13 += a3;
  }
  while (v14 != 64);
  if (HIDWORD(a3))
  {
    int v18 = 0;
    unint64_t v19 = HIDWORD(a3) * a5;
    uint64_t v20 = v49[0];
    uint64_t v21 = v49[1];
    uint64_t v22 = v49[2];
    uint64_t v23 = v49[3];
    while (1)
    {
      uint64_t v24 = v16;
      unint64_t v25 = v15;
      unsigned int v26 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v26 = a3;
        unint64_t v25 = v15;
        uint64_t v24 = v16;
        do
        {
          int8x16_t v27 = v25;
          int16x8x2_t v50 = vld2q_s16(v27);
          v27 += 16;
          *(int16x8x2_t *)a9.i8 = vld2q_s16(v27);
          long long v28 = v25 + 32;
          *(int16x8x2_t *)(&a12 - 1) = vld2q_s16(v28);
          long long v29 = v25 + 48;
          *(int16x8x2_t *)a13.i8 = vld2q_s16(v29);
          v25 += 64;
          int8x16_t v31 = (int8x16_t)vuzp1q_s16(v30, a13);
          int8x16_t v32 = (int8x16_t)vuzp1q_s16(v50.val[0], a9);
          int8x16_t v34 = (int8x16_t)vuzp1q_s16(a12, v33);
          int8x16_t v35 = (int8x16_t)vuzp1q_s16(v50.val[1], a10);
          int8x16_t v36 = (int8x16_t)vuzp2q_s16(v30, a13);
          int8x16_t v37 = (int8x16_t)vuzp2q_s16(v50.val[0], a9);
          a11 = vuzp2q_s16(a12, v33);
          v50.val[0] = vuzp2q_s16(v50.val[1], a10);
          uint64_t v38 = (int8x16_t *)(v20 + v24);
          uint64_t v39 = (int8x16_t *)(v21 + v24);
          uint64_t v40 = (int8x16_t *)(v22 + v24);
          int16x8x3_t v41 = (__n128 *)(v23 + v24);
          *uint64_t v38 = vuzp1q_s8(v32, v31);
          *(int8x16_t *)((char *)v38 + v19) = vuzp2q_s8(v32, v31);
          *uint64_t v39 = vuzp1q_s8(v35, v34);
          *(int8x16_t *)((char *)v39 + v19) = vuzp2q_s8(v35, v34);
          *uint64_t v40 = vuzp1q_s8(v37, v36);
          *(int8x16_t *)((char *)v40 + v19) = vuzp2q_s8(v37, v36);
          a8 = (int16x8_t)vuzp1q_s8((int8x16_t)v50.val[0], (int8x16_t)a11);
          *int16x8x3_t v41 = (__n128)a8;
          a7 = (__n128)vuzp2q_s8((int8x16_t)v50.val[0], (int8x16_t)a11);
          *(__n128 *)((char *)v41 + v19) = a7;
          v24 += 16;
          v26 -= 16;
        }
        while (v26 > 0xF);
      }
      if (v26 >= 4) {
        break;
      }
      uint64_t v42 = (unsigned __int16 *)v25;
      if (v26) {
        goto LABEL_11;
      }
LABEL_12:
      unint64_t v15 = (const __int16 *)((char *)v15 + a4);
      v16 += a5;
      if (++v18 == HIDWORD(a3))
      {
        unint64_t v15 = *result;
        goto LABEL_16;
      }
    }
    do
    {
      uint64_t v42 = (unsigned __int16 *)(v25 + 16);
      a7 = (__n128)vld2_s16(v25);
      uint64_t v43 = v25 + 8;
      a9 = (int16x8_t)vld2_s16(v43);
      *(int16x4_t *)a11.i8 = vuzp1_s16((int16x4_t)a7.n128_u64[0], *(int16x4_t *)a9.i8);
      *(int16x4_t *)a12.i8 = vuzp1_s16(v44, *(int16x4_t *)a10.i8);
      *(int16x4_t *)a13.i8 = vuzp2_s16((int16x4_t)a7.n128_u64[0], *(int16x4_t *)a9.i8);
      a7.n128_u64[0] = (unint64_t)vuzp2_s16(v44, *(int16x4_t *)a10.i8);
      uint64_t v45 = (_DWORD *)(v20 + v24);
      BOOL v46 = (_DWORD *)(v21 + v24);
      uint64_t v47 = (_DWORD *)(v22 + v24);
      unint64_t v48 = (_DWORD *)(v23 + v24);
      *uint64_t v45 = vmovn_s16(a11).u32[0];
      *(_DWORD *)((char *)v45 + v19) = vmovn_s16((int16x8_t)vrev16q_s8((int8x16_t)a11)).u32[0];
      *BOOL v46 = vmovn_s16(a12).u32[0];
      *(_DWORD *)((char *)v46 + v19) = vmovn_s16((int16x8_t)vrev16q_s8((int8x16_t)a12)).u32[0];
      *uint64_t v47 = vmovn_s16(a13).u32[0];
      a8 = (int16x8_t)vrev16q_s8((int8x16_t)a13);
      *(_DWORD *)((char *)v47 + v19) = vmovn_s16(a8).u32[0];
      *(int8x8_t *)a8.i8 = vmovn_s16((int16x8_t)a7);
      *unint64_t v48 = a8.i32[0];
      a7 = (__n128)vrev16q_s8((int8x16_t)a7);
      a7.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)a7);
      *(_DWORD *)((char *)v48 + v19) = a7.n128_u32[0];
      v24 += 4;
      v26 -= 4;
      unint64_t v25 = (const __int16 *)v42;
    }
    while (v26 > 3);
    if (!v26) {
      goto LABEL_12;
    }
    do
    {
LABEL_11:
      a7.n128_u16[0] = *v42;
      a7.n128_u16[2] = v42[1];
      a8.i16[0] = v42[2];
      a8.i16[2] = v42[3];
      a9.i32[0] = a7.n128_i32[1];
      a10.i32[0] = a8.i32[1];
      *(unsigned char *)(v20 + v24) = vmovn_s16((int16x8_t)a7).u8[0];
      *(unsigned char *)(v20 + v24 + v19) = a7.n128_u8[1];
      *(unsigned char *)(v21 + v24) = vmovn_s16(a9).u8[0];
      *(unsigned char *)(v21 + v24 + v19) = a7.n128_u8[5];
      *(unsigned char *)(v22 + v24) = vmovn_s16(a8).u8[0];
      *(unsigned char *)(v22 + v24 + v19) = a8.i8[1];
      a7.n128_u64[0] = (unint64_t)vmovn_s16(a10);
      *(unsigned char *)(v23 + v24) = a7.n128_u8[0];
      v42 += 4;
      *(unsigned char *)(v23 + v24++ + v19) = a8.i8[5];
      --v26;
    }
    while (v26);
    goto LABEL_12;
  }
LABEL_16:
  *uint64_t result = &v15[4 * a3];
  *a2 += 4 * a3;
  return result;
}

const char **Deinterleave<unsigned int,1>(const char **result, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 a6)
{
  uint64_t v6 = *result;
  if (HIDWORD(a3))
  {
    int v7 = 0;
    unint64_t v8 = HIDWORD(a3) * a5;
    uint64_t v9 = *a2;
    do
    {
      uint64_t v10 = v9;
      uint64_t v11 = v6;
      unsigned int v12 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v12 = a3;
        uint64_t v13 = v6;
        uint64_t v10 = v9;
        do
        {
          uint64_t v11 = v13 + 64;
          *(int8x16x2_t *)a6.n128_u64 = vld2q_s8(v13);
          uint64_t v14 = v13 + 32;
          int8x16x2_t v21 = vld2q_s8(v14);
          *(__n128 *)uint64_t v10 = a6;
          *(int8x16_t *)(v10 + 16) = v21.val[0];
          uint64_t v15 = v10 + v8;
          *(_OWORD *)uint64_t v15 = v16;
          *(int8x16_t *)(v15 + 16) = v21.val[1];
          v10 += 32;
          v12 -= 16;
          uint64_t v13 = v11;
        }
        while (v12 > 0xF);
      }
      if (v12 >= 4)
      {
        do
        {
          a6 = (__n128)vld2_s8(v11);
          v11 += 16;
          *(void *)uint64_t v10 = a6.n128_u64[0];
          *(void *)(v10 + v8) = v17;
          v10 += 8;
          v12 -= 4;
        }
        while (v12 > 3);
      }
      for (; v12; --v12)
      {
        unsigned __int32 v18 = *(_DWORD *)v11;
        v11 += 4;
        a6.n128_u32[0] = v18;
        a6.n128_u64[0] = vmovl_u8((uint8x8_t)a6.n128_u64[0]).u64[0];
        *(unsigned char *)(v10 + 1) = a6.n128_u8[4];
        *(unsigned char *)uint64_t v10 = a6.n128_u8[0];
        unint64_t v19 = (unsigned char *)(v10 + v8);
        v19[1] = a6.n128_u8[6];
        *unint64_t v19 = a6.n128_u8[2];
        v10 += 2;
      }
      v6 += a4;
      v9 += a5;
      ++v7;
    }
    while (v7 != HIDWORD(a3));
    uint64_t v6 = *result;
  }
  unint64_t v20 = 4 * a3;
  *uint64_t result = &v6[v20];
  *a2 += v20 >> 1;
  return result;
}

const float **Deinterleave<unsigned int,2>(const float **result, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v31[2] = *MEMORY[0x263EF8340];
  uint64_t v6 = *result;
  uint64_t v7 = *a2;
  uint64_t v8 = *(void *)(a6 + 8);
  v31[*(unsigned int *)(v8 + 12)] = 0;
  v31[*(unsigned int *)(v8 + 28)] = 2 * a3;
  if (HIDWORD(a3))
  {
    int v9 = 0;
    unint64_t v10 = HIDWORD(a3) * a5;
    uint64_t v11 = v31[0];
    uint64_t v12 = v31[1];
    do
    {
      uint64_t v13 = v7;
      uint64_t v14 = v6;
      unsigned int v15 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v15 = a3;
        uint64_t v14 = v6;
        uint64_t v13 = v7;
        do
        {
          long long v16 = v14;
          float32x4x2_t v32 = vld2q_f32(v16);
          v16 += 8;
          float32x4x2_t v34 = vld2q_f32(v16);
          uint64_t v17 = v14 + 16;
          float32x4x2_t v35 = vld2q_f32(v17);
          unsigned __int32 v18 = v14 + 24;
          float32x4x2_t v36 = vld2q_f32(v18);
          v14 += 32;
          unint64_t v19 = (int8x16_t *)(v11 + v13);
          unint64_t v20 = (int8x16_t *)(v12 + v13);
          *unint64_t v19 = vuzp1q_s8((int8x16_t)v32.val[0], (int8x16_t)v34.val[0]);
          v19[1] = vuzp1q_s8((int8x16_t)v35.val[0], (int8x16_t)v36.val[0]);
          *unint64_t v20 = vuzp1q_s8((int8x16_t)v32.val[1], (int8x16_t)v34.val[1]);
          v20[1] = vuzp1q_s8((int8x16_t)v35.val[1], (int8x16_t)v36.val[1]);
          int8x16x2_t v21 = (int8x16_t *)(v11 + v13 + v10);
          int8x16_t *v21 = vuzp2q_s8((int8x16_t)v32.val[0], (int8x16_t)v34.val[0]);
          v21[1] = vuzp2q_s8((int8x16_t)v35.val[0], (int8x16_t)v36.val[0]);
          uint64_t v22 = (int8x16_t *)(v12 + v13 + v10);
          int8x16_t *v22 = vuzp2q_s8((int8x16_t)v32.val[1], (int8x16_t)v34.val[1]);
          v22[1] = vuzp2q_s8((int8x16_t)v35.val[1], (int8x16_t)v36.val[1]);
          v13 += 32;
          v15 -= 16;
        }
        while (v15 > 0xF);
      }
      if (v15 >= 4)
      {
        do
        {
          float32x4x2_t v33 = vld2q_f32(v14);
          v14 += 8;
          uint64_t v23 = (int8x8_t *)(v11 + v13);
          uint64_t v24 = (int8x8_t *)(v12 + v13);
          int8x8_t v25 = (int8x8_t)vextq_s8((int8x16_t)v33.val[0], (int8x16_t)v33.val[0], 8uLL).u64[0];
          *uint64_t v23 = vuzp1_s8(*(int8x8_t *)v33.val[0].f32, v25);
          int8x8_t v26 = (int8x8_t)vextq_s8((int8x16_t)v33.val[1], (int8x16_t)v33.val[1], 8uLL).u64[0];
          *uint64_t v24 = vuzp1_s8(*(int8x8_t *)v33.val[1].f32, v26);
          *(int8x8_t *)((char *)v23 + v10) = vuzp2_s8(*(int8x8_t *)v33.val[0].f32, v25);
          *(int8x8_t *)((char *)v24 + v10) = vuzp2_s8(*(int8x8_t *)v33.val[1].f32, v26);
          v13 += 8;
          v15 -= 4;
        }
        while (v15 > 3);
      }
      for (; v15; --v15)
      {
        int32x2_t v27 = *(int32x2_t *)v14;
        v14 += 2;
        unsigned __int32 v28 = vdup_lane_s32(v27, 1).u32[0];
        *(unsigned char *)(v11 + v13 + 1) = v27.i8[2];
        *(unsigned char *)(v11 + v13) = v27.i8[0];
        *(unsigned char *)(v12 + v13 + 1) = BYTE2(v28);
        *(unsigned char *)(v12 + v13) = v28;
        long long v29 = (unsigned char *)(v11 + v13 + v10);
        v29[1] = v27.i8[3];
        *long long v29 = v27.i8[1];
        int16x8_t v30 = (unsigned char *)(v12 + v13 + v10);
        v30[1] = HIBYTE(v28);
        *int16x8_t v30 = BYTE1(v28);
        v13 += 2;
      }
      uint64_t v6 = (const float *)((char *)v6 + a4);
      v7 += a5;
      ++v9;
    }
    while (v9 != HIDWORD(a3));
    uint64_t v6 = *result;
  }
  *uint64_t result = &v6[2 * a3];
  *a2 += 4 * a3;
  return result;
}

uint64_t *Deinterleave<unsigned int,3>(uint64_t *result, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  uint64_t v9 = 0;
  void v45[3] = *MEMORY[0x263EF8340];
  uint64_t v10 = *result;
  uint64_t v11 = *a2;
  uint64_t v12 = *(void *)(a6 + 8);
  for (uint64_t i = 12; i != 60; i += 16)
  {
    v45[*(unsigned int *)(v12 + i)] = v9;
    v9 += 2 * a3;
  }
  if (HIDWORD(a3))
  {
    int v14 = 0;
    unint64_t v15 = HIDWORD(a3) * a5;
    uint64_t v16 = v45[0];
    uint64_t v17 = v45[1];
    uint64_t v18 = v45[2];
    do
    {
      uint64_t v19 = v11;
      uint64_t v20 = v10;
      unsigned int v21 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v21 = a3;
        uint64_t v20 = v10;
        uint64_t v19 = v11;
        do
        {
          uint64_t v22 = (const float *)v20;
          *(float32x4x3_t *)(&a9 - 2) = vld3q_f32(v22);
          v22 += 12;
          float32x4x3_t v46 = vld3q_f32(v22);
          uint64_t v23 = (const float *)(v20 + 96);
          float32x4x3_t v47 = vld3q_f32(v23);
          uint64_t v24 = (const float *)(v20 + 144);
          float32x4x3_t v48 = vld3q_f32(v24);
          v20 += 192;
          int8x8_t v25 = (int8x16_t *)(v16 + v19);
          int8x8_t v26 = (int8x16_t *)(v17 + v19);
          int32x2_t v27 = (int8x16_t *)(v18 + v19);
          *int8x8_t v25 = vuzp1q_s8(v28, (int8x16_t)v46.val[0]);
          v25[1] = vuzp1q_s8((int8x16_t)v47.val[0], (int8x16_t)v48.val[0]);
          long long v29 = (int8x16_t *)(v16 + v19 + v15);
          *long long v29 = vuzp2q_s8(v28, (int8x16_t)v46.val[0]);
          v29[1] = vuzp2q_s8((int8x16_t)v47.val[0], (int8x16_t)v48.val[0]);
          int8x16_t *v26 = vuzp1q_s8(v30, (int8x16_t)v46.val[1]);
          v26[1] = vuzp1q_s8((int8x16_t)v47.val[1], (int8x16_t)v48.val[1]);
          int8x16_t v31 = (int8x16_t *)(v17 + v19 + v15);
          *int8x16_t v31 = vuzp2q_s8(v30, (int8x16_t)v46.val[1]);
          v31[1] = vuzp2q_s8((int8x16_t)v47.val[1], (int8x16_t)v48.val[1]);
          *int32x2_t v27 = vuzp1q_s8(a9, (int8x16_t)v46.val[2]);
          v27[1] = vuzp1q_s8((int8x16_t)v47.val[2], (int8x16_t)v48.val[2]);
          a7 = vuzp2q_s8(a9, (int8x16_t)v46.val[2]);
          a8 = vuzp2q_s8((int8x16_t)v47.val[2], (int8x16_t)v48.val[2]);
          float32x4x2_t v32 = (__n128 *)(v18 + v19 + v15);
          *float32x4x2_t v32 = (__n128)a7;
          v32[1] = (__n128)a8;
          v19 += 32;
          v21 -= 16;
        }
        while (v21 > 0xF);
      }
      if (v21 >= 4)
      {
        do
        {
          *(float32x4x3_t *)a7.i8 = vld3q_f32((const float *)v20);
          v20 += 48;
          float32x4x2_t v33 = (int8x8_t *)(v16 + v19);
          float32x4x2_t v34 = (int8x8_t *)(v17 + v19);
          float32x4x2_t v35 = (int8x8_t *)(v18 + v19);
          int8x8_t v36 = (int8x8_t)vextq_s8(a7, a7, 8uLL).u64[0];
          *float32x4x2_t v33 = vuzp1_s8(*(int8x8_t *)a7.i8, v36);
          *(int8x8_t *)((char *)v33 + v15) = vuzp2_s8(*(int8x8_t *)a7.i8, v36);
          int8x8_t v37 = (int8x8_t)vextq_s8(a8, a8, 8uLL).u64[0];
          *float32x4x2_t v34 = vuzp1_s8(*(int8x8_t *)a8.i8, v37);
          *(int8x8_t *)((char *)v34 + v15) = vuzp2_s8(*(int8x8_t *)a8.i8, v37);
          int8x8_t v38 = (int8x8_t)vextq_s8(a9, a9, 8uLL).u64[0];
          *float32x4x2_t v35 = vuzp1_s8(*(int8x8_t *)a9.i8, v38);
          *(int8x8_t *)a7.i8 = vuzp2_s8(*(int8x8_t *)a9.i8, v38);
          *(int8x8_t *)((char *)v35 + v15) = *(int8x8_t *)a7.i8;
          v19 += 8;
          v21 -= 4;
        }
        while (v21 > 3);
      }
      for (; v21; --v21)
      {
        a7.i32[0] = *(_DWORD *)v20;
        a8.i32[0] = *(_DWORD *)(v20 + 4);
        a7.i64[0] = vmovl_u8(*(uint8x8_t *)a7.i8).u64[0];
        a8 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a8.i8);
        a9.i32[0] = *(_DWORD *)(v20 + 8);
        a9 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a9.i8);
        v20 += 12;
        uint64_t v39 = (unsigned char *)(v16 + v19);
        uint64_t v40 = (unsigned char *)(v17 + v19);
        int16x8x3_t v41 = (unsigned char *)(v18 + v19);
        v39[1] = a7.i8[4];
        *uint64_t v39 = a7.i8[0];
        uint64_t v42 = (unsigned char *)(v16 + v19 + v15);
        v42[1] = a7.i8[6];
        *uint64_t v42 = a7.i8[2];
        v40[1] = a8.i8[4];
        *uint64_t v40 = a8.i8[0];
        uint64_t v43 = (unsigned char *)(v17 + v19 + v15);
        v43[1] = a8.i8[6];
        *uint64_t v43 = a8.i8[2];
        v41[1] = a9.i8[4];
        *int16x8x3_t v41 = a9.i8[0];
        int16x4_t v44 = (unsigned char *)(v18 + v19 + v15);
        v44[1] = a9.i8[6];
        v19 += 2;
        *int16x4_t v44 = a9.i8[2];
      }
      v10 += a4;
      v11 += a5;
      ++v14;
    }
    while (v14 != HIDWORD(a3));
    uint64_t v10 = *result;
  }
  *uint64_t result = v10 + 12 * a3;
  *a2 += 6 * a3;
  return result;
}

const float **Deinterleave<unsigned int,4>(const float **result, uint64_t *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  v64[4] = *MEMORY[0x263EF8340];
  uint64_t v8 = *result;
  uint64_t v9 = *a2;
  uint64_t v10 = *(void *)(a6 + 8) + 12;
  do
  {
    v64[*(unsigned int *)(v10 + v7)] = v6;
    v7 += 16;
    v6 += 2 * a3;
  }
  while (v7 != 64);
  if (HIDWORD(a3))
  {
    int v11 = 0;
    unint64_t v12 = HIDWORD(a3) * a5;
    uint64_t v13 = v64[0];
    uint64_t v14 = v64[1];
    uint64_t v15 = v64[2];
    uint64_t v16 = v64[3];
    while (1)
    {
      uint64_t v17 = v9;
      uint64_t v18 = v8;
      unsigned int v19 = a3;
      if (a3 >= 0x10)
      {
        unsigned int v19 = a3;
        uint64_t v18 = v8;
        uint64_t v17 = v9;
        do
        {
          uint64_t v20 = v18;
          float32x4x2_t v65 = vld2q_f32(v20);
          v20 += 8;
          float32x4x2_t v67 = vld2q_f32(v20);
          unsigned int v21 = v18 + 16;
          float32x4x2_t v69 = vld2q_f32(v21);
          uint64_t v22 = v18 + 24;
          float32x4x2_t v70 = vld2q_f32(v22);
          uint64_t v23 = v18 + 32;
          float32x4x2_t v71 = vld2q_f32(v23);
          uint64_t v24 = v18 + 40;
          float32x4x2_t v72 = vld2q_f32(v24);
          int8x8_t v25 = v18 + 48;
          float32x4x2_t v73 = vld2q_f32(v25);
          int8x8_t v26 = v18 + 56;
          float32x4x2_t v74 = vld2q_f32(v26);
          int8x16_t v27 = (int8x16_t)vuzp1q_s32((int32x4_t)v73.val[0], (int32x4_t)v74.val[0]);
          int8x16_t v28 = (int8x16_t)vuzp1q_s32((int32x4_t)v71.val[0], (int32x4_t)v72.val[0]);
          v18 += 64;
          int8x16_t v29 = (int8x16_t)vuzp1q_s32((int32x4_t)v69.val[0], (int32x4_t)v70.val[0]);
          int8x16_t v30 = (int8x16_t)vuzp1q_s32((int32x4_t)v65.val[0], (int32x4_t)v67.val[0]);
          int8x16_t v31 = (int8x16_t)vuzp1q_s32((int32x4_t)v73.val[1], (int32x4_t)v74.val[1]);
          int8x16_t v32 = (int8x16_t)vuzp1q_s32((int32x4_t)v71.val[1], (int32x4_t)v72.val[1]);
          int8x16_t v33 = (int8x16_t)vuzp1q_s32((int32x4_t)v69.val[1], (int32x4_t)v70.val[1]);
          int8x16_t v34 = (int8x16_t)vuzp1q_s32((int32x4_t)v65.val[1], (int32x4_t)v67.val[1]);
          int8x16_t v35 = (int8x16_t)vuzp2q_s32((int32x4_t)v73.val[0], (int32x4_t)v74.val[0]);
          int8x16_t v36 = (int8x16_t)vuzp2q_s32((int32x4_t)v71.val[0], (int32x4_t)v72.val[0]);
          int8x16_t v37 = (int8x16_t)vuzp2q_s32((int32x4_t)v69.val[0], (int32x4_t)v70.val[0]);
          int8x8_t v38 = (int8x16_t *)(v13 + v17);
          *int8x8_t v38 = vuzp1q_s8(v30, v29);
          v38[1] = vuzp1q_s8(v28, v27);
          int8x16_t v39 = (int8x16_t)vuzp2q_s32((int32x4_t)v65.val[0], (int32x4_t)v67.val[0]);
          v73.val[0] = (float32x4_t)vuzp2q_s32((int32x4_t)v73.val[1], (int32x4_t)v74.val[1]);
          uint64_t v40 = (int8x16_t *)(v13 + v17 + v12);
          *uint64_t v40 = vuzp2q_s8(v30, v29);
          v40[1] = vuzp2q_s8(v28, v27);
          v71.val[0] = (float32x4_t)vuzp2q_s32((int32x4_t)v71.val[1], (int32x4_t)v72.val[1]);
          int16x8x3_t v41 = (int8x16_t *)(v14 + v17);
          *int16x8x3_t v41 = vuzp1q_s8(v34, v33);
          v41[1] = vuzp1q_s8(v32, v31);
          v69.val[0] = (float32x4_t)vuzp2q_s32((int32x4_t)v69.val[1], (int32x4_t)v70.val[1]);
          uint64_t v42 = (int8x16_t *)(v14 + v17 + v12);
          *uint64_t v42 = vuzp2q_s8(v34, v33);
          v42[1] = vuzp2q_s8(v32, v31);
          v65.val[0] = (float32x4_t)vuzp2q_s32((int32x4_t)v65.val[1], (int32x4_t)v67.val[1]);
          uint64_t v43 = (int8x16_t *)(v15 + v17);
          *uint64_t v43 = vuzp1q_s8(v39, v37);
          v43[1] = vuzp1q_s8(v36, v35);
          int16x4_t v44 = (int8x16_t *)(v16 + v17);
          uint64_t v45 = (int8x16_t *)(v15 + v17 + v12);
          *uint64_t v45 = vuzp2q_s8(v39, v37);
          v45[1] = vuzp2q_s8(v36, v35);
          *int16x4_t v44 = vuzp1q_s8((int8x16_t)v65.val[0], (int8x16_t)v69.val[0]);
          v44[1] = vuzp1q_s8((int8x16_t)v71.val[0], (int8x16_t)v73.val[0]);
          float32x4x3_t v46 = (int8x16_t *)(v16 + v17 + v12);
          *float32x4x3_t v46 = vuzp2q_s8((int8x16_t)v65.val[0], (int8x16_t)v69.val[0]);
          v46[1] = vuzp2q_s8((int8x16_t)v71.val[0], (int8x16_t)v73.val[0]);
          v17 += 32;
          v19 -= 16;
        }
        while (v19 > 0xF);
      }
      if (v19 >= 4) {
        break;
      }
      float32x4x3_t v47 = v18;
      if (v19) {
        goto LABEL_11;
      }
LABEL_12:
      uint64_t v8 = (const float *)((char *)v8 + a4);
      v9 += a5;
      if (++v11 == HIDWORD(a3))
      {
        uint64_t v8 = *result;
        goto LABEL_16;
      }
    }
    do
    {
      float32x4x3_t v47 = v18 + 16;
      float32x4x2_t v66 = vld2q_f32(v18);
      float32x4x3_t v48 = v18 + 8;
      float32x4x2_t v68 = vld2q_f32(v48);
      int8x16_t v49 = (int8x16_t)vuzp1q_s32((int32x4_t)v66.val[0], (int32x4_t)v68.val[0]);
      int8x16_t v50 = (int8x16_t)vuzp1q_s32((int32x4_t)v66.val[1], (int32x4_t)v68.val[1]);
      int8x16_t v51 = (int8x16_t)vuzp2q_s32((int32x4_t)v66.val[0], (int32x4_t)v68.val[0]);
      v66.val[0] = (float32x4_t)vuzp2q_s32((int32x4_t)v66.val[1], (int32x4_t)v68.val[1]);
      uint64_t v52 = (int8x8_t *)(v13 + v17);
      double v53 = (int8x8_t *)(v14 + v17);
      unint64_t v54 = (int8x8_t *)(v15 + v17);
      uint32_t v55 = (int8x8_t *)(v16 + v17);
      v66.val[1].i64[0] = vextq_s8(v49, v49, 8uLL).u64[0];
      int8x8_t *v52 = vuzp1_s8(*(int8x8_t *)v49.i8, *(int8x8_t *)v66.val[1].f32);
      *(int8x8_t *)((char *)v52 + v12) = vuzp2_s8(*(int8x8_t *)v49.i8, *(int8x8_t *)v66.val[1].f32);
      v66.val[1].i64[0] = vextq_s8(v50, v50, 8uLL).u64[0];
      int8x8_t *v53 = vuzp1_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v66.val[1].f32);
      *(int8x8_t *)((char *)v53 + v12) = vuzp2_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)v66.val[1].f32);
      v66.val[1].i64[0] = vextq_s8(v51, v51, 8uLL).u64[0];
      int8x8_t *v54 = vuzp1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v66.val[1].f32);
      *(int8x8_t *)((char *)v54 + v12) = vuzp2_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)v66.val[1].f32);
      v66.val[1].i64[0] = vextq_s8((int8x16_t)v66.val[0], (int8x16_t)v66.val[0], 8uLL).u64[0];
      int8x8_t *v55 = vuzp1_s8(*(int8x8_t *)v66.val[0].f32, *(int8x8_t *)v66.val[1].f32);
      *(int8x8_t *)((char *)v55 + v12) = vuzp2_s8(*(int8x8_t *)v66.val[0].f32, *(int8x8_t *)v66.val[1].f32);
      v17 += 8;
      v19 -= 4;
      uint64_t v18 = v47;
    }
    while (v19 > 3);
    if (!v19) {
      goto LABEL_12;
    }
    do
    {
LABEL_11:
      int32x2_t v56 = *(int32x2_t *)v47;
      int32x2_t v57 = *(int32x2_t *)(v47 + 2);
      v47 += 4;
      unsigned __int32 v58 = vdup_lane_s32(v56, 1).u32[0];
      unsigned __int32 v59 = vdup_lane_s32(v57, 1).u32[0];
      *(unsigned char *)(v13 + v17 + 1) = v56.i8[2];
      *(unsigned char *)(v13 + v17) = v56.i8[0];
      uint64_t v60 = (unsigned char *)(v13 + v17 + v12);
      v60[1] = v56.i8[3];
      *uint64_t v60 = v56.i8[1];
      *(unsigned char *)(v14 + v17 + 1) = BYTE2(v58);
      *(unsigned char *)(v14 + v17) = v58;
      uint64_t v61 = (unsigned char *)(v14 + v17 + v12);
      v61[1] = HIBYTE(v58);
      *uint64_t v61 = BYTE1(v58);
      *(unsigned char *)(v15 + v17 + 1) = v57.i8[2];
      *(unsigned char *)(v15 + v17) = v57.i8[0];
      uint64_t v62 = (unsigned char *)(v15 + v17 + v12);
      v62[1] = v57.i8[3];
      *uint64_t v62 = v57.i8[1];
      *(unsigned char *)(v16 + v17 + 1) = BYTE2(v59);
      *(unsigned char *)(v16 + v17) = v59;
      uint64_t v63 = (unsigned char *)(v16 + v17 + v12);
      v63[1] = HIBYTE(v59);
      *uint64_t v63 = BYTE1(v59);
      v17 += 2;
      --v19;
    }
    while (v19);
    goto LABEL_12;
  }
LABEL_16:
  *uint64_t result = &v8[4 * a3];
  *a2 += 8 * a3;
  return result;
}

uint64_t RowCompressor::WalkBackStream(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = a2[22] + a2[24] + a2[18] - a2[20];
  uint64_t result = *(void *)(v2 + 72);
  *(void *)(v2 + 64) -= v3;
  unint64_t v5 = *(void *)(result + 32);
  if (v5 >= v3) {
    unint64_t v6 = v3;
  }
  else {
    unint64_t v6 = *(void *)(result + 32);
  }
  *(void *)(result + 32) = v5 - v6;
  unint64_t v7 = v3 - v6;
  if (v3 != v6)
  {
    do
    {
      *(void *)(v2 + 72) = *(void *)(result + 16);
      if (atomic_fetch_add((atomic_ullong *volatile)(result + 8), 0xFFFFFFFFFFFFFFFFLL) == 1) {
        (**(void (***)(uint64_t))result)(result);
      }
      uint64_t result = *(void *)(v2 + 72);
      unint64_t v8 = *(void *)(result + 32);
      if (v8 >= v7) {
        unint64_t v9 = v7;
      }
      else {
        unint64_t v9 = *(void *)(result + 32);
      }
      *(void *)(result + 32) = v8 - v9;
      v7 -= v9;
    }
    while (v7);
  }
  return result;
}

void RowCompressor::DoDifferencing(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 200);
  if (v2)
  {
    uint64_t v3 = *(void *)(a2 + 168);
    if (v2 < 0x21)
    {
      __int8 v19 = *(unsigned char *)v3;
    }
    else
    {
      int8x16_t v4 = *(int8x16_t *)v3;
      int8x16_t v5 = *(int8x16_t *)(v3 + 16);
      if (v2 >= 0x60)
      {
        v6.i64[0] = 0x8080808080808080;
        v6.i64[1] = 0x8080808080808080;
        do
        {
          int8x16_t v7 = v4;
          int8x16_t v8 = *(int8x16_t *)(v3 + 64);
          v3 += 64;
          int8x16_t v4 = v8;
          int8x16_t v9 = veorq_s8(vsubq_s8(*(int8x16_t *)(v3 - 47), v5), v6);
          int8x16_t v10 = veorq_s8(vsubq_s8(*(int8x16_t *)(v3 - 15), *(int8x16_t *)(v3 - 16)), v6);
          int8x16_t v11 = veorq_s8(vsubq_s8(*(int8x16_t *)(v3 - 31), *(int8x16_t *)(v3 - 32)), v6);
          int8x16_t v5 = *(int8x16_t *)(v3 + 16);
          *(int8x16_t *)(v3 - 63) = veorq_s8(vsubq_s8(*(int8x16_t *)(v3 - 63), v7), v6);
          *(int8x16_t *)(v3 - 47) = v9;
          *(int8x16_t *)(v3 - 31) = v11;
          *(int8x16_t *)(v3 - 15) = v10;
          v2 -= 64;
        }
        while (v2 > 0x5F);
        if (v2 < 0x21)
        {
          __int8 v19 = v4.i8[0];
          uint64_t v21 = 31;
LABEL_15:
          uint64_t v22 = (__int8 *)(v3 + 1);
          do
          {
            __int8 v23 = *v22;
            __int8 *v22 = (*v22 - v19) ^ 0x80;
            ++v22;
            __int8 v19 = v23;
            --v21;
          }
          while (v21);
          return;
        }
      }
      unint64_t v12 = (int8x16_t *)(v3 + 1);
      int8x16_t v13 = vsubq_s8(*(int8x16_t *)(v3 + 17), v5);
      v14.i64[0] = 0x8080808080808080;
      v14.i64[1] = 0x8080808080808080;
      int8x16_t v15 = veorq_s8(vsubq_s8(*(int8x16_t *)(v3 + 1), v4), v14);
      int8x16_t v16 = veorq_s8(v13, v14);
      if (v2 >= 0x41)
      {
        do
        {
          int8x16_t v17 = *(int8x16_t *)(v3 + 32);
          int8x16_t v18 = *(int8x16_t *)(v3 + 48);
          v3 += 32;
          *(int8x16_t *)(v3 - 31) = v15;
          *(int8x16_t *)(v3 - 15) = v16;
          v2 -= 32;
          int8x16_t v16 = veorq_s8(vsubq_s8(*(int8x16_t *)(v3 + 17), v18), v14);
          int8x16_t v15 = veorq_s8(vsubq_s8(*(int8x16_t *)(v3 + 1), v17), v14);
        }
        while (v2 > 0x40);
        unint64_t v12 = (int8x16_t *)(v3 + 1);
      }
      __int8 v20 = *(unsigned char *)(v3 + 32);
      v3 += 32;
      __int8 v19 = v20;
      v2 -= 32;
      *unint64_t v12 = v15;
      v12[1] = v16;
    }
    uint64_t v21 = v2 - 1;
    if (!v21) {
      return;
    }
    goto LABEL_15;
  }
}

uint64_t ZipCompressor::CompressData(uint64_t a1, uint64_t a2)
{
  RowCompressor::DoDifferencing(a1, a2);
  uint64_t v3 = *(char **)(a2 + 136);
  unint64_t v4 = *(void *)(a2 + 144);
  int8x16_t v5 = *(const uint8_t **)(a2 + 168);
  *(void *)(a2 + 160) = 0;
  int v6 = *(_DWORD *)(a2 + 8);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 8 * (v6 * *(_DWORD *)(a2 + 52));
    do
    {
      int8x16_t v9 = v3;
      if ((*(unsigned char *)(a2 + 113) & 0x10) != 0)
      {
        *(_DWORD *)uint64_t v3 = *(_DWORD *)(a2 + 116);
        v3 += 4;
      }
      CompressedDataPtr = (uint8_t *)AXRChunkHeader::GetCompressedDataPtr((uint64_t)v3, *(_DWORD *)(a2 + 104), v4);
      uint64_t v11 = (uint64_t)CompressedDataPtr;
      size_t v12 = v9 - (char *)CompressedDataPtr + v4;
      size_t v13 = *(void *)(a2 + 200);
      if (v12 >= v13) {
        size_t v14 = *(void *)(a2 + 200);
      }
      else {
        size_t v14 = v9 - (char *)CompressedDataPtr + v4;
      }
      size_t v15 = compression_encode_buffer(CompressedDataPtr, v14, v5, v13, 0, (compression_algorithm)0x505u);
      size_t v16 = v15;
      size_t v17 = *(void *)(a2 + 200);
      if (v15) {
        BOOL v18 = v15 >= v14;
      }
      else {
        BOOL v18 = 1;
      }
      if (v18 || v15 >= v17)
      {
        DeinterleaveChannels(v11, *(void *)(a2 + 184), a2);
        size_t v16 = v17;
      }
      __int8 v20 = (char *)(v16 + v11);
      unint64_t v4 = v12 - v16;
      AXRChunkHeader::Init(v3, *(_DWORD *)(a2 + 104), v7, *(_DWORD *)(a2 + 52), *(_DWORD *)(a2 + 56), *(_DWORD *)(a2 + 60), *(_DWORD *)(a2 + 44), v16);
      *(void *)(*(void *)(a2 + 128) + v8 + 8 * v7) = *(void *)(a2 + 120);
      *(void *)(a2 + 120) += v20 - v9;
      ++v7;
      uint64_t v3 = v20;
    }
    while (v7 < *(_DWORD *)(a2 + 8));
    uint64_t v3 = *(char **)(a2 + 136);
  }
  else
  {
    __int8 v20 = v3;
  }
  *(void *)(a2 + 160) = v20 - v3;
  return 0;
}

uint64_t DeinterleaveChannels(uint64_t result, uint64_t a2, uint64_t a3)
{
  v17[4] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(uint64_t **)(a3 + 88);
  if (v3)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    uint64_t v8 = (unsigned int *)(a3 + 32);
    do
    {
      uint64_t v9 = v3[2];
      if ((unint64_t)(v9 - 1) > 3) {
        break;
      }
      size_t size = axr_type_get_size((axr_type_t)*((_DWORD *)v3 + 14));
      size_t v11 = size;
      size_t v12 = (int *)(v3[1] + 16 * v7 + 12);
      size_t v13 = size * *v8;
      size_t v14 = v13 * v7;
      uint64_t v15 = v9;
      do
      {
        int v16 = *v12;
        v12 += 4;
        v17[v16] = v14;
        v14 += v13;
        --v15;
      }
      while (v15);
      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, unsigned int *, void *))*(&DeinterleaveChannels(void *,void const*,unsigned long,CompressionInfo const&)::kDeinterleaveFunctions[4 * (size >> 2) - 1]
                                                                                    + v9))(v6, a2, v8, v17);
      v7 += v9;
      a2 += v11 * v9 * (*(_DWORD *)(a3 + 32) * *(_DWORD *)(a3 + 36));
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  return result;
}

_DWORD *AXRChunkHeader::Init(_DWORD *result, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  if (a2 <= 0)
  {
    if (a2) {
      goto LABEL_9;
    }
    *result++ = a7 * a4;
    goto LABEL_6;
  }
  if (a2 == 1)
  {
    *uint64_t result = a3;
    result[1] = a4;
    result[2] = a5;
    result[3] = a6;
    result += 4;
LABEL_6:
    *uint64_t result = a8;
    return result;
  }
  if ((a2 - 2) < 3)
  {
    do
    {
      __break(1u);
LABEL_9:
      ;
    }
    while (a2 == 0x80000000);
  }
  return result;
}

uLong ZipCompressor::GetCompressedMaxSize(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 152) + compressBound(*(void *)(a2 + 200));
}

uint64_t NoneCompressor::CompressData(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(char **)(a2 + 136);
  unint64_t v3 = *(void *)(a2 + 144);
  *(void *)(a2 + 160) = 0;
  int v5 = *(_DWORD *)(a2 + 8);
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 8 * (v5 * *(_DWORD *)(a2 + 52));
    do
    {
      uint64_t v8 = v4;
      if ((*(unsigned char *)(a2 + 113) & 0x10) != 0)
      {
        *(_DWORD *)unint64_t v4 = *(_DWORD *)(a2 + 116);
        v4 += 4;
      }
      uint64_t CompressedDataPtr = AXRChunkHeader::GetCompressedDataPtr((uint64_t)v4, *(_DWORD *)(a2 + 104), v3);
      uint64_t v10 = *(void *)(a2 + 200);
      DeinterleaveChannels(CompressedDataPtr, *(void *)(a2 + 184), a2);
      size_t v11 = (char *)(v10 + CompressedDataPtr);
      unint64_t v3 = &v8[v3] - v11;
      AXRChunkHeader::Init(v4, *(_DWORD *)(a2 + 104), v6, *(_DWORD *)(a2 + 52), *(_DWORD *)(a2 + 56), *(_DWORD *)(a2 + 60), *(_DWORD *)(a2 + 44), v10);
      *(void *)(*(void *)(a2 + 128) + v7 + 8 * v6) = *(void *)(a2 + 120);
      *(void *)(a2 + 120) += v11 - v8;
      ++v6;
      unint64_t v4 = v11;
    }
    while (v6 < *(_DWORD *)(a2 + 8));
    unint64_t v4 = *(char **)(a2 + 136);
  }
  else
  {
    size_t v11 = v4;
  }
  *(void *)(a2 + 160) = v11 - v4;
  return 0;
}

uint64_t NoneCompressor::GetCompressedMaxSize(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 152) + *(void *)(a2 + 200);
}

void ZipCompressor::~ZipCompressor(ZipCompressor *this)
{
}

uint64_t ZipCompressor::Destroy(ZipCompressor *this)
{
  return (**(uint64_t (***)(ZipCompressor *))this)(this);
}

void NoneCompressor::~NoneCompressor(NoneCompressor *this)
{
}

uint64_t NoneCompressor::Destroy(NoneCompressor *this)
{
  return (**(uint64_t (***)(NoneCompressor *))this)(this);
}

void NoneCompressor::ConfigureScratchBuffer(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
}

void *ConvertToPlanar<unsigned short,1>::Do(uint64_t a1, const void *a2, unsigned int *a3, void *a4)
{
  return memcpy((void *)(*a4 + a1), a2, 2 * *a3 * (unint64_t)a3[1]);
}

uint64_t ConvertToPlanar<unsigned short,2>::Do(uint64_t result, __int16 *a2, unsigned int *a3, long long *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  long long v13 = *a4;
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      if (v5)
      {
        uint64_t v7 = 0;
        uint64_t v8 = result;
        do
        {
          uint64_t v9 = 0;
          char v10 = 1;
          do
          {
            char v11 = v10;
            __int16 v12 = *a2++;
            *(_WORD *)(*((void *)&v13 + v9) + v8) = v12;
            uint64_t v9 = 1;
            char v10 = 0;
          }
          while ((v11 & 1) != 0);
          v8 += 2;
          ++v7;
        }
        while (v7 != v5);
      }
      result += 4 * v5;
    }
  }
  return result;
}

uint64_t ConvertToPlanar<unsigned short,3>::Do(uint64_t result, __int16 *a2, unsigned int *a3, long long *a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  long long v11 = *a4;
  uint64_t v12 = *((void *)a4 + 2);
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      if (v5)
      {
        uint64_t v7 = 0;
        uint64_t v8 = result;
        do
        {
          for (uint64_t j = 0; j != 24; j += 8)
          {
            __int16 v10 = *a2++;
            *(_WORD *)(*(void *)((char *)&v11 + j) + v8) = v10;
          }
          v8 += 2;
          ++v7;
        }
        while (v7 != v5);
      }
      result += 6 * v5;
    }
  }
  return result;
}

uint64_t ConvertToPlanar<unsigned short,4>::Do(uint64_t result, __int16 *a2, unsigned int *a3, _OWORD *a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  long long v6 = a4[1];
  v12[0] = *a4;
  v12[1] = v6;
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      if (v5)
      {
        uint64_t v8 = 0;
        uint64_t v9 = result;
        do
        {
          for (uint64_t j = 0; j != 32; j += 8)
          {
            __int16 v11 = *a2++;
            *(_WORD *)(*(void *)((char *)v12 + j) + v9) = v11;
          }
          v9 += 2;
          ++v8;
        }
        while (v8 != v5);
      }
      result += 8 * v5;
    }
  }
  return result;
}

void *ConvertToPlanar<unsigned int,1>::Do(uint64_t a1, const void *a2, unsigned int *a3, void *a4)
{
  return memcpy((void *)(*a4 + a1), a2, 4 * *a3 * (unint64_t)a3[1]);
}

uint64_t ConvertToPlanar<unsigned int,2>::Do(uint64_t result, int *a2, unsigned int *a3, long long *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  long long v13 = *a4;
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      if (v5)
      {
        uint64_t v7 = 0;
        uint64_t v8 = result;
        do
        {
          uint64_t v9 = 0;
          char v10 = 1;
          do
          {
            char v11 = v10;
            int v12 = *a2++;
            *(_DWORD *)(*((void *)&v13 + v9) + v8) = v12;
            uint64_t v9 = 1;
            char v10 = 0;
          }
          while ((v11 & 1) != 0);
          v8 += 4;
          ++v7;
        }
        while (v7 != v5);
      }
      result += 8 * v5;
    }
  }
  return result;
}

uint64_t ConvertToPlanar<unsigned int,3>::Do(uint64_t result, int *a2, unsigned int *a3, long long *a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  long long v11 = *a4;
  uint64_t v12 = *((void *)a4 + 2);
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      if (v5)
      {
        uint64_t v7 = 0;
        uint64_t v8 = result;
        do
        {
          for (uint64_t j = 0; j != 24; j += 8)
          {
            int v10 = *a2++;
            *(_DWORD *)(*(void *)((char *)&v11 + j) + v8) = v10;
          }
          v8 += 4;
          ++v7;
        }
        while (v7 != v5);
      }
      result += 12 * v5;
    }
  }
  return result;
}

uint64_t ConvertToPlanar<unsigned int,4>::Do(uint64_t result, int *a2, unsigned int *a3, _OWORD *a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  long long v6 = a4[1];
  v12[0] = *a4;
  v12[1] = v6;
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      if (v5)
      {
        uint64_t v8 = 0;
        uint64_t v9 = result;
        do
        {
          for (uint64_t j = 0; j != 32; j += 8)
          {
            int v11 = *a2++;
            *(_DWORD *)(*(void *)((char *)v12 + j) + v9) = v11;
          }
          v9 += 4;
          ++v8;
        }
        while (v8 != v5);
      }
      result += 16 * v5;
    }
  }
  return result;
}

const char *EncoderLayer::GetEncodedNameForChannel(EncoderLayer *this, unint64_t a2, int a3)
{
  if (*((void *)this + 2) <= a2) {
    return "<invalid channel index>";
  }
  uint64_t v3 = *((void *)this + 1);
  uint64_t result = *(const char **)(v3 + 16 * a2);
  if (!result || !*result) {
    return GetEXRNameForChannelType(*(_DWORD *)(v3 + 16 * a2 + 8), a3);
  }
  return result;
}

size_t EncoderLayer::PrintChannels(EncoderLayer *this, char *a2, size_t a3, int a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (!*((void *)this + 2)) {
    return 0;
  }
  if (*((void *)this + 3)) {
    snprintf(__str, 0x100uLL, "%s.", *((const char **)this + 3));
  }
  else {
    __str[0] = 0;
  }
  EncodedNameForuint64_t Channel = EncoderLayer::GetEncodedNameForChannel(this, 0, a4);
  if (*((void *)this + 2) == 1) {
    return snprintf(a2, a3, "\"%s%s\"", __str, EncodedNameForChannel);
  }
  size_t v8 = snprintf(a2, a3, "{ \"%s%s\"", __str, EncodedNameForChannel);
  if (v8 < a3)
  {
    if (*((void *)this + 2) < 2uLL)
    {
LABEL_13:
      v8 += snprintf(&a2[v8], a3 - v8, " } ");
      if (*((void *)this + 2) >= 2uLL)
      {
        v8 += snprintf(&a2[v8], a3 - v8, "\torder: { %d", *(_DWORD *)(*((void *)this + 1) + 12));
        if (v8 < a3)
        {
          if (*((void *)this + 2) < 2uLL)
          {
LABEL_19:
            v8 += snprintf(&a2[v8], a3 - v8, "}");
          }
          else
          {
            unint64_t v12 = 1;
            uint64_t v13 = 28;
            while (1)
            {
              v8 += snprintf(&a2[v8], a3 - v8, ", %d", *(_DWORD *)(*((void *)this + 1) + v13));
              if (v8 >= a3) {
                break;
              }
              ++v12;
              v13 += 16;
              if (v12 >= *((void *)this + 2)) {
                goto LABEL_19;
              }
            }
          }
        }
      }
    }
    else
    {
      unint64_t v10 = 1;
      while (1)
      {
        int v11 = EncoderLayer::GetEncodedNameForChannel(this, v10, a4);
        v8 += snprintf(&a2[v8], a3 - v8, ", \"%s%s\"", __str, v11);
        if (v8 >= a3) {
          break;
        }
        if (++v10 >= *((void *)this + 2)) {
          goto LABEL_13;
        }
      }
    }
  }
  return v8;
}

void EncoderLayer::CreateEncoderLayer(EncoderLayer *this, const char *a2, int a3, int a4, char a5, const axr_channel_type_t *a6, axr_channel_type_t *a7, unint64_t a8, long long a9, void (*a10)(unint64_t), unint64_t a11, unint64_t a12, axr_flags_t a13)
{
  if (a8)
  {
    axr_type_t v18 = a2;
    size_t v20 = strlen((const char *)this);
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    do
    {
      if (a7)
      {
        __int8 v23 = *(const char **)&a7[2 * (void)v21];
        if (v23) {
          __int8 v23 = (const char *)strlen(v23);
        }
      }
      else
      {
        __int8 v23 = 0;
      }
      v22 += (uint64_t)(v23 + 1);
      uint64_t v21 = (const char **)((char *)v21 + 1);
    }
    while ((const char **)a8 != v21);
    uint64_t v24 = (EncoderLayer *)malloc_type_malloc(v20 + 16 * a8 + v22 + 81, 0x5D63E92CuLL);
    if (v24)
    {
      EncoderLayer::EncoderLayer(v24, (const char *)this, v18, a3, a4, a5, a6, (const char **)a7, a8, a9, (CGColorSpaceModel)a10, a11);
    }
    else
    {
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | a12) & 2) != 0) {
        AXRLogDebug((uint64_t)"axr_part_append_layer error: out of memory", v25, v26, v27, v28, v29, v30, v31, v32);
      }
    }
  }
}

uint64_t EncoderLayer::CompressTileRow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a1 + 32))(a2, v5, *(void *)(a4 + 64), *(void *)(a4 + 24), *(void *)(a1 + 48));
    if (v9 <= 0) {
      break;
    }
    a2 += v9;
    v8 += v9;
    v5 -= v9;
    if (!v5) {
      return v8;
    }
  }
  if (!v8) {
    return v9;
  }
  return v8;
}

void EncoderLayer::EncoderLayer(EncoderLayer *this, const char *a2, axr_type_t a3, int a4, int a5, char a6, const axr_channel_type_t *a7, const char **a8, unint64_t a9, long long a10, CGColorSpaceModel a11, unint64_t a12)
{
  *((void *)this + 2) = a9;
  *((_OWORD *)this + 2) = a10;
  *((void *)this + 6) = a12;
  *((_DWORD *)this + 14) = a3;
  *((_DWORD *)this + 15) = a4;
  *((_DWORD *)this + 16) = a5;
  *((unsigned char *)this + 72) = a6;
  uint64_t v16 = (char *)this + 80;
  *(void *)this = 0;
  *((void *)this + 1) = v16;
  bzero(v16, 16 * a9);
  size_t v17 = (char *)(*((void *)this + 1) + 16 * *((void *)this + 2));
  *((void *)this + 3) = v17;
  axr_type_t v18 = stpcpy(v17, a2);
  if (*((void *)this + 2))
  {
    uint64_t v19 = 0;
    unint64_t v20 = 0;
    do
    {
      ++v18;
      uint64_t v21 = *((void *)this + 1) + v19;
      *(void *)uint64_t v21 = v18;
      *(axr_channel_type_t *)(v21 + 8) = a7[v20];
      *(_DWORD *)(v21 + 12) = v20;
      if (a8 && (uint64_t v22 = a8[v20]) != 0) {
        axr_type_t v18 = stpcpy(v18, v22);
      }
      else {
        *axr_type_t v18 = 0;
      }
      ++v20;
      v19 += 16;
    }
    while (v20 < *((void *)this + 2));
  }
  *((_DWORD *)this + 17) = -1;
  EncoderLayer::SetColorSpaceModel(this, a11);
}

void TileDecoder::TileDecoder(TileDecoder *this, axr_decoder *a2, const Part *a3, uint64_t a4, axr_error_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)this = &unk_26DD4BD78;
  *((void *)this + 1) = a4;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a3;
  uint64_t v11 = *((void *)a2 + 2);
  *a5 = axr_error_success;
  uint64_t v13 = *(void *)(v11 + 24);
  uint64_t v12 = *(void *)(v11 + 32);
  *((void *)this + 4) = v13;
  *((void *)this + 5) = v12;
  unsigned int ImageSize = Part::GetImageSize(a3, *((unsigned int *)a2 + 11), a4, a4, (uint64_t)a5, a6, a7, a8);
  unint64_t v15 = *(void *)(*((void *)this + 3) + 156);
  *((void *)this + 7) = v15;
  if (v15 <= 1) {
    unsigned int v16 = 1;
  }
  else {
    unsigned int v16 = v15;
  }
  unsigned int v17 = ImageSize + v16 - 1;
  unint64_t v18 = HIDWORD(v15);
  if (v17 < ImageSize) {
    int v19 = (v17 - 0xFFFFFFFF / v16 * v16) / v16 + 0xFFFFFFFF / v16;
  }
  else {
    int v19 = v17 / v16;
  }
  unint64_t v20 = (unsigned int *)*((void *)this + 2);
  unsigned int v21 = v20[12];
  unsigned int v22 = v20[13];
  unsigned int v23 = v20[15];
  int v24 = v21 / v16;
  unsigned int v25 = (v20[14] + v21 - (v20[14] != 0)) / v16;
  *((_DWORD *)this + 25) = v19;
  *((_DWORD *)this + 26) = v25 - v21 / v16 + 1;
  if (v18 <= 1) {
    unsigned int v26 = 1;
  }
  else {
    unsigned int v26 = v18;
  }
  int v27 = v22 / v26;
  *((_DWORD *)this + 28) = v24;
  *((_DWORD *)this + 29) = v22 / v26;
  unsigned int v28 = (v23 + v22 - (v23 != 0)) / v26;
  *((_DWORD *)this + 27) = v28 - v22 / v26 + 1;
  uint64_t v29 = malloc_type_calloc(v20[8], 0x10uLL, 0x20040A4A59CD2uLL);
  *((void *)this + 8) = v29;
  if (v29)
  {
    unsigned int v55 = v25;
    int32x2_t v56 = a5;
    *((_DWORD *)this + 18) = 0;
    uint64_t v35 = *((void *)this + 2);
    int8x16_t v36 = *(unsigned int **)(v35 + 24);
    if (v36)
    {
      int v37 = 0;
      int64_t v38 = 0x8000000000000000;
      uint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        uint64_t v40 = (*(_DWORD *)(*((void *)this + 2) + 32) + ~v37);
        v29[2 * v40] = v36;
        if (!*((unsigned char *)v36 + 24))
        {
          int64_t v41 = *v36;
          if ((v41 & 0x80000000) == 0)
          {
            uint64_t Channel = Part::GetChannel(*((Part **)this + 3), *v36, *((void *)this + 1), v30, v31, v32, v33, v34);
            uint64_t v29 = (void *)*((void *)this + 8);
            v29[2 * v40 + 1] = Channel;
            if (v39 >= v41) {
              uint64_t v39 = v41;
            }
            if (v38 <= v41) {
              int64_t v38 = v41;
            }
            int v37 = *((_DWORD *)this + 18);
          }
        }
        *((_DWORD *)this + 18) = ++v37;
        int8x16_t v36 = (unsigned int *)*((void *)v36 + 1);
      }
      while (v36);
      uint64_t v35 = *((void *)this + 2);
    }
    else
    {
      int v37 = 0;
      LODWORD(v39) = -1;
      LODWORD(v38) = 0;
    }
    if (v37 == *(_DWORD *)(v35 + 32))
    {
      *((_DWORD *)this + 19) = v39;
      *((_DWORD *)this + 20) = v38;
      int v43 = *((_DWORD *)this + 14);
      int v44 = *((_DWORD *)this + 15);
      uint64_t v45 = *(unsigned int *)(v35 + 44);
      int v46 = *(_DWORD *)(v35 + 48);
      int v47 = v46 - v43 * v24;
      int v48 = *((_DWORD *)a2 + 15);
      int v49 = v43 + v43 * v55 - (v46 + *((_DWORD *)a2 + 14));
      int v50 = *(_DWORD *)(v35 + 52);
      *((_DWORD *)this + 21) = v50 - v44 * v27;
      *((_DWORD *)this + 22) = v47;
      *((_DWORD *)this + 23) = v49;
      *((_DWORD *)this + 24) = v44 + v44 * v28 - (v50 + v48);
      uint64_t v51 = *((void *)this + 3);
      *((void *)this + 6) = *(void *)(v51 + 256);
      *((_DWORD *)this + 30) = 0;
      if (v45)
      {
        int v52 = 0;
        double v53 = *(_DWORD ***)(v51 + 280);
        do
        {
          unint64_t v54 = *v53++;
          v52 += *v54;
          --v45;
        }
        while (v45);
        *((_DWORD *)this + 30) = v52;
      }
    }
    else
    {
      axr_error_t *v56 = axr_error_data_corrupted;
    }
  }
  else
  {
    *a5 = axr_error_insufficient_memory;
  }
}

void TileDecoder::~TileDecoder(void **this)
{
  *this = &unk_26DD4BD78;
  free(this[8]);
}

void TileDecoder::ReadPixelsBlock(TileDecoder *this, unint64_t a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  TileDecoder::GetThreadTileInfo((TileDecoder *)v3, a2, (uint64_t)&v25);
  if (*((void *)&v25 + 1)) {
    BOOL v4 = (void)v25 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v5 = *((unsigned int *)this + 13);
    uint64_t v6 = *((unsigned int *)this + 14);
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    int v24 = 0;
    uint64_t v23 = 0;
    TileDecoder::GetChannelTileInfo(v3, &v25, v5, v6, (unsigned int *)&v21);
    if ((v28 + HIDWORD(v27)) < *(_DWORD *)(v3 + 56)
      && (DWORD2(v28) + DWORD1(v28)) < *(_DWORD *)(v3 + 60))
    {
      int v8 = *(_DWORD *)(v3 + 72);
      if (v8)
      {
        uint64_t v9 = (int32x2_t **)(*(void *)(v3 + 64) + 8);
        uint64_t v10 = *(unsigned int *)(v3 + 72);
        while (!*v9)
        {
          v9 += 2;
          if (!--v10) {
            goto LABEL_11;
          }
        }
        v7.n128_u64[0] = (unint64_t)vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)(*(void *)&(*v9)[5]+ 8 * HIDWORD(v28))+ 16), (*v9)[6], *(int32x2_t *)((char *)&v26 + 8)), (uint32x2_t)(*v9)[6]);
      }
      else
      {
LABEL_11:
        __n128 v7 = 0uLL;
      }
      uint64_t v11 = *((void *)this + 3);
      uint64_t v12 = *((void *)this + 4);
      int v13 = *((_DWORD *)this + 12);
      uint64_t v20 = *(void *)(v12 + 16) - 64;
      uint64_t v14 = (char *)(*((void *)this + 2) + (v13 * v8 * HIDWORD(v22)) + v11 * v23);
      if (*((unsigned char *)this + 60)
        || !(*(unsigned int (**)(uint64_t, long long *, __n128))(*(void *)v3 + 64))(v3, &v25, v7))
      {
        (*(void (**)(void *__return_ptr, uint64_t, uint64_t, long long *, uint64_t *, __n128))(*(void *)v3 + 24))(v19, v3, v12, &v25, &v20, v7);
        if (*(_DWORD *)(v3 + 72) == 1) {
          (*(void (**)(uint64_t, void, uint64_t, void, long long *, char *, void, void))(*(void *)v3 + 48))(v3, v19[0], v20, *(void *)(v3 + 64), &v25, v14, 0, *((void *)this + 3));
        }
        else {
          (*(void (**)(uint64_t, void, uint64_t, long long *, uint64_t, uint64_t, char *, void, void))(*(void *)v3 + 40))(v3, v19[0], v20, &v25, v5, v6, v14, 0, *((void *)this + 3));
        }
        uint64_t v17 = v19[0];
        v19[0] = 0;
        if (v17 && v19[1]) {
          free((void *)(v17 - 64));
        }
      }
      else
      {
        uint64_t CompressedDataPtr = AXRChunkHeader::GetCompressedDataPtr(v25, *(_DWORD *)(*(void *)(v3 + 24) + 208), *((unint64_t *)&v25 + 1));
        if (!CompressedDataPtr)
        {
          exception = __cxa_allocate_exception(8uLL);
          void *exception = -4;
        }
        if (*(_DWORD *)(v3 + 72) == 1) {
          TileDecoder::ExtractPlane_Uncompressed(v3, CompressedDataPtr, *((unint64_t *)&v25 + 1), *(void *)(v3 + 64), (uint64_t)&v25, v14, v16, *((void *)this + 3));
        }
        else {
          TileDecoder::Interleave_Uncompressed(v3, CompressedDataPtr, *((unint64_t *)&v25 + 1), (uint64_t)&v25, v5, v6);
        }
      }
    }
  }
}

#error "228F32E54: call analysis failed (funcsize=35)"

uint64_t TileDecoder::GetThreadTileInfo@<X0>(TileDecoder *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *((unsigned int *)this + 25);
  unint64_t v7 = *((unsigned int *)this + 26);
  unint64_t v8 = a2 / v7;
  unint64_t v37 = a2 / v7 * v7;
  unint64_t v38 = 0;
  uint64_t v9 = a2 % v7;
  unint64_t v10 = a2 / v7 + *((unsigned int *)this + 29);
  unint64_t v34 = a2 % v7 + *((unsigned int *)this + 28);
  uint64_t v36 = v34 + v10 * v6;
  Chunuint64_t k = Part::GetChunk(*((Part **)this + 3), *((char **)this + 4), *((void *)this + 5), *(unsigned int *)(*((void *)this + 2) + 44), v36, &v38);
  if (v7 <= a2) {
    int v31 = 0;
  }
  else {
    int v31 = *((_DWORD *)this + 21);
  }
  if (v8 + 1 == *((_DWORD *)this + 27)) {
    int v16 = *((_DWORD *)this + 24);
  }
  else {
    int v16 = 0;
  }
  unint64_t v17 = *((unsigned int *)this + 18);
  int v32 = v16;
  unsigned int v35 = v10;
  unint64_t v18 = 0;
  if (v17)
  {
    unint64_t v19 = 0;
    unint64_t v20 = (*((_DWORD *)this + 15) + *((_DWORD *)this + 15) * v10 + ~v16);
    uint64_t v21 = 8;
    do
    {
      uint64_t v22 = *(ChannelDescription **)(*((void *)this + 8) + v21);
      if (v22)
      {
        uint64_t LocationForTile = ChannelDescription::GetLocationForTile(v22, v20, v9, *(_DWORD *)(*((void *)this + 2) + 44));
        if (v18 <= (HIDWORD(LocationForTile) + LocationForTile)) {
          unint64_t v18 = (HIDWORD(LocationForTile) + LocationForTile);
        }
        unint64_t v17 = *((unsigned int *)this + 18);
      }
      ++v19;
      v21 += 16;
    }
    while (v19 < v17);
  }
  uint64_t result = Part::GetImageSize(*((Part **)this + 3), *(unsigned int *)(*((void *)this + 2) + 44), *((void *)this + 1), v11, v12, v13, v14, v15);
  unint64_t v25 = v38;
  *(void *)a3 = Chunk;
  *(void *)(a3 + 8) = v25;
  *(void *)(a3 + 16) = v18;
  *(void *)(a3 + 24) = __PAIR64__(v35, v34);
  *(_DWORD *)(a3 + 32) = v36;
  if (a2 == v37) {
    int v26 = 0;
  }
  else {
    int v26 = *((_DWORD *)this + 14) * v9 - *((_DWORD *)this + 22);
  }
  *(_DWORD *)(a3 + 36) = v26;
  if (v7 <= a2) {
    int v27 = *((_DWORD *)this + 15) * v8 - *((_DWORD *)this + 21);
  }
  else {
    int v27 = 0;
  }
  *(_DWORD *)(a3 + 40) = v27;
  if (a2 == v37) {
    int v28 = *((_DWORD *)this + 22);
  }
  else {
    int v28 = 0;
  }
  *(_DWORD *)(a3 + 44) = v28;
  if (v9 + 1 == *((_DWORD *)this + 26)) {
    int v29 = *((_DWORD *)this + 23);
  }
  else {
    int v29 = 0;
  }
  *(_DWORD *)(a3 + 48) = v29;
  *(_DWORD *)(a3 + 52) = v31;
  int v30 = *(_DWORD *)(*((void *)this + 2) + 44);
  *(_DWORD *)(a3 + 56) = v32;
  *(_DWORD *)(a3 + 60) = v30;
  *(void *)(a3 + 64) = result;
  return result;
}

unint64_t TileDecoder::ExtractPlane_Uncompressed(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *(void *)(a1 + 56);
  uint64_t v14 = *(_DWORD **)(a4 + 8);
  int v15 = v14[18];
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  int v38 = 0;
  uint64_t v37 = 0;
  unint64_t result = TileDecoder::GetChannelTileInfo(a1, (_DWORD *)a5, v14[20], v14[26], (unsigned int *)&v35);
  if (v15 == 1) {
    char v17 = 1;
  }
  else {
    char v17 = 2;
  }
  unint64_t v18 = (unint64_t)HIDWORD(v37) << v17;
  uint64_t v19 = (v36 + 1);
  unint64_t v20 = v19 << v17;
  unint64_t v21 = v19 - a3;
  BOOL v22 = v18 >= v21;
  unint64_t v23 = v18 - v21;
  if (!v22) {
    unint64_t v23 = 0;
  }
  if (v20 <= a3) {
    unint64_t v24 = (unint64_t)HIDWORD(v37) << v17;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24)
  {
    unint64_t v25 = *(void *)(a1 + 56);
    uint64_t v26 = *(unsigned int *)(a5 + 52);
    if ((unint64_t)*(unsigned int *)(a5 + 56) + v26 < HIDWORD(v25))
    {
      uint64_t v27 = (*(_DWORD *)(a5 + 28) * HIDWORD(v13));
      unint64_t v28 = HIDWORD(v25);
      uint64_t v29 = *(unsigned int *)(*(void *)(a4 + 8) + 104);
      unint64_t v30 = v26 + v27;
      do
      {
        unint64_t result = ChannelDescription::GetLocationForTile(*(ChannelDescription **)(a4 + 8), v30, *(void *)(a5 + 24), *(_DWORD *)(a5 + 60));
        if (HIDWORD(result))
        {
          unint64_t v31 = ((unint64_t)v35 << v17) + result;
          if (a3 >= v31)
          {
            if (v24 >= a3 - v31) {
              size_t v32 = a3 - v31;
            }
            else {
              size_t v32 = v24;
            }
            unint64_t result = (unint64_t)memcpy(a6, (const void *)(v31 + a2), v32);
            a6 += a8;
          }
        }
        v26 += v29;
        v30 += v29;
      }
      while (v26 + (unint64_t)*(unsigned int *)(a5 + 56) < v28);
    }
  }
  return result;
}

ChannelDescription *TileDecoder::Interleave_Uncompressed(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  int v31 = 0;
  uint64_t v30 = 0;
  unint64_t result = (ChannelDescription *)TileDecoder::GetChannelTileInfo(a1, (_DWORD *)a4, a5, a6, (unsigned int *)&v28);
  int v10 = *(_DWORD *)(**(void **)(a1 + 64) + 16);
  unint64_t v11 = HIDWORD(v30);
  uint64_t v12 = (v29 + 1);
  unint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13)
  {
    unsigned int v14 = 0;
    unint64_t v15 = 0;
    uint64_t v16 = 8;
    do
    {
      unint64_t result = *(ChannelDescription **)(*(void *)(a1 + 64) + v16);
      if (result)
      {
        unint64_t result = (ChannelDescription *)ChannelDescription::GetLocationForTile(result, (*(_DWORD *)(a4 + 52)+ HIDWORD(*(void *)(a4 + 24)) * *(_DWORD *)(a1 + 60)), *(void *)(a4 + 24), *(_DWORD *)(a4 + 60));
        if (v14 <= result) {
          unsigned int v14 = result;
        }
        unint64_t v13 = *(unsigned int *)(a1 + 72);
      }
      ++v15;
      v16 += 16;
    }
    while (v15 < v13);
  }
  else
  {
    unsigned int v14 = 0;
    unint64_t v13 = 0;
  }
  char v17 = 1;
  if (v10 != 1) {
    char v17 = 2;
  }
  unint64_t v18 = (v12 << v17) + v14;
  unint64_t v19 = (v18 - a3) >> v17;
  BOOL v20 = v11 >= v19;
  unint64_t v21 = v11 - v19;
  if (!v20) {
    unint64_t v21 = 0;
  }
  if (v18 <= a3) {
    unint64_t v22 = v11;
  }
  else {
    unint64_t v22 = v21;
  }
  if (v22)
  {
    if (v13 == 4)
    {
      unint64_t v25 = *(void **)(a1 + 64);
      if (v25) {
        uint64_t v26 = 2 * (v25[1] != 0);
      }
      else {
        uint64_t v26 = 0;
      }
      return (ChannelDescription *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))((char *)&TileDecoder::Interleave_Uncompressed(void const*,unsigned long,TileInfo const&,unsigned int,unsigned int,void *,unsigned long,long)const::Read4 + ((8 * (v26 | (v10 != 1))) | (32 * (v25[3] != 0)) | ((unint64_t)(v25[5] != 0) << 6) | ((unint64_t)(v25[7] != 0) << 7))))(a2, a3, a1, a4);
    }
    else if (v13 == 2)
    {
      uint64_t v23 = *(void *)(a1 + 64);
      if (v23) {
        uint64_t v24 = 2 * (*(void *)(v23 + 8) != 0);
      }
      else {
        uint64_t v24 = 0;
      }
      return (ChannelDescription *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))((char *)TileDecoder::Interleave_Uncompressed(void const*,unsigned long,TileInfo const&,unsigned int,unsigned int,void *,unsigned long,long)const::Read2 + ((8 * (v24 | (v10 != 1))) | (32 * (*(void *)(v23 + 24) != 0)))))(a2, a3, a1, a4);
    }
  }
  return result;
}

void TileDecoder::ReadPixelsBlockGrayToRGBA(TileDecoder *this, unint64_t a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  memset(v26, 0, sizeof(v26));
  TileDecoder::GetThreadTileInfo((TileDecoder *)v3, a2, (uint64_t)v26);
  if (*((void *)&v26[0] + 1)) {
    BOOL v4 = *(void *)&v26[0] == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v5 = *((unsigned int *)this + 13);
    uint64_t v6 = *((unsigned int *)this + 14);
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    int v25 = 0;
    uint64_t v24 = 0;
    TileDecoder::GetChannelTileInfo(v3, v26, v5, v6, (unsigned int *)&v22);
    if ((v28 + HIDWORD(v27)) < *(_DWORD *)(v3 + 56)
      && (DWORD2(v28) + DWORD1(v28)) < *(_DWORD *)(v3 + 60))
    {
      int v7 = *((_DWORD *)this + 12);
      int v9 = HIDWORD(v23);
      uint64_t v8 = v24;
      double v10 = *((double *)this + 5);
      uint64_t v21 = *(void *)(*((void *)this + 4) + 16) - 64;
      if (*((unsigned char *)this + 60))
      {
        uint64_t v19 = 0;
        uint64_t v20 = 0;
      }
      else
      {
        (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v3 + 24))(&v19, v3);
      }
      int v11 = *(_DWORD *)(v3 + 72);
      uint64_t v12 = *((void *)this + 2) + *((void *)this + 3) * v8 + (v9 * v7 * v11);
      if (v11 == 1)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, _OWORD *, uint64_t, void))(*(void *)v3 + 48))(v3, v19, v21, *(void *)(v3 + 64), v26, v12, 0);
        uint64_t v13 = *((void *)this + 3);
        unsigned int v14 = *(int32x2_t **)(*(void *)(v3 + 64) + 8);
        if (v7 == 2) {
          convertYtoYYYA<unsigned short>(v12, v13, (int32x2_t *)v26, v3, v14, v10);
        }
        else {
          convertYtoYYYA<unsigned int>(v12, v13, (int32x2_t *)v26, v3, v14, v10);
        }
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, void, void))(*(void *)v3 + 40))(v3, v19, v21, v26, v5, v6, v12, 0, *((void *)this + 3));
        uint64_t v16 = *((void *)this + 3);
        char v17 = *(int32x2_t **)(*(void *)(v3 + 64) + 8);
        if (v7 == 2)
        {
          convertYAtoYYYA<unsigned short>(v12, v16, (int32x2_t *)v26, v3, v17);
        }
        else
        {
          v15.n128_f64[0] = v10;
          convertYAtoYYYA<unsigned int>(v12, v16, (int32x2_t *)v26, v3, v17, v15);
        }
      }
      uint64_t v18 = v19;
      uint64_t v19 = 0;
      if (v18)
      {
        if (v20) {
          free((void *)(v18 - 64));
        }
      }
    }
  }
}

#error "228F33758: call analysis failed (funcsize=35)"

uint64_t convertYtoYYYA<unsigned short>(uint64_t a1, uint64_t a2, int32x2_t *a3, uint64_t a4, int32x2_t *a5, double a6)
{
  _D8 = a6;
  uint32x2_t v36 = vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)(*(void *)&a5[5] + 8 * a3[7].u32[1]) + 16), a5[6], a3[3]), (uint32x2_t)a5[6]);
  v37[0] = 0;
  v37[1] = 0;
  int v39 = 0;
  uint64_t v38 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a4, a3, a5[10].u32[0], a5[13].u32[0], (unsigned int *)v37);
  if (a2 >= 0) {
    unint64_t v13 = a2;
  }
  else {
    unint64_t v13 = -a2;
  }
  unint64_t v14 = v13 >> 3;
  if (v14 >= HIDWORD(v38)) {
    unint64_t v14 = HIDWORD(v38);
  }
  _D0 = (int16x4_t)v36;
  uint64_t v16 = (a3[3].i32[1] * v36.i32[1]);
  unint64_t v17 = v16 + v36.u32[1];
  unint64_t v18 = a3[7].u32[0];
  _CF = v17 >= v18;
  unint64_t v20 = v17 - v18;
  if (!_CF)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -6;
  }
  unint64_t v21 = a3[6].u32[1] + v16;
  if (v21 < v20)
  {
    __asm { FCVT            H0, D8 }
    int16x8_t v25 = vdupq_n_s16(_D0.u32[0]);
    do
    {
      uint64_t v26 = a1 + 2 * v14;
      uint64_t v27 = a1 + 8 * v14;
      unint64_t v28 = v14;
      if (v14 >= 8)
      {
        do
        {
          long long v29 = *(_OWORD *)(v26 - 16);
          v26 -= 16;
          long long v30 = v29;
          *(int8x16_t *)(v27 - 64) = vqtbl2q_s8(*(int8x16x2_t *)(&v25 - 1), (int8x16_t)xmmword_228F62AE0);
          v27 -= 64;
          v28 -= 8;
          int16x8_t v11 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v25 - 1), (int8x16_t)xmmword_228F62AF0);
          int16x8_t v12 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v25 - 1), (int8x16_t)xmmword_228F62B10);
          *(int8x16_t *)(v27 + 32) = vqtbl2q_s8(*(int8x16x2_t *)(&v25 - 1), (int8x16_t)xmmword_228F62B00);
          *(int16x8_t *)(v27 + 48) = v12;
          *(int16x8_t *)(v27 + 16) = v11;
        }
        while (v28 > 7);
      }
      if (v28 >= 2)
      {
        do
        {
          __int32 v31 = *(unsigned __int16 *)(v26 - 4);
          v26 -= 4;
          v11.i32[0] = v31;
          v11.i16[2] = *(_WORD *)(v26 + 2);
          *(int16x4_t *)v11.i8 = vuzp1_s16(*(int16x4_t *)v11.i8, _D0);
          int16x4_t v32 = vzip1_s16(*(int16x4_t *)v11.i8, 0);
          int16x4_t v33 = vuzp1_s16(v32, v32);
          *(int16x4_t *)v12.i8 = vzip1_s16(v33, *(int16x4_t *)v25.i8);
          *(int16x4_t *)v11.i8 = vzip1_s16(v33, *(int16x4_t *)v11.i8);
          int16x8_t v11 = vzip1q_s16(v11, v12);
          *(int16x8_t *)(v27 - 16) = v11;
          v27 -= 16;
          v28 -= 2;
        }
        while (v28 > 1);
      }
      if (v28)
      {
        __int16 v34 = *(_WORD *)(v26 - 2);
        *(_WORD *)(v27 - 8) = v34;
        *(_WORD *)(v27 - 6) = v34;
        *(_WORD *)(v27 - 4) = v34;
        *(_WORD *)(v27 - 2) = _D0.i16[0];
      }
      a1 += a2;
      ++v21;
    }
    while (v21 != v20);
  }
  return result;
}

uint64_t convertYtoYYYA<unsigned int>(uint64_t a1, uint64_t a2, int32x2_t *a3, uint64_t a4, int32x2_t *a5, double a6)
{
  unsigned __int32 v38 = vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)((void)a5[40] + 8 * a3[60]) + 16), a5[48], a3[24]), (uint32x2_t)a5[48]).u32[1];
  v39[0] = 0;
  v39[1] = 0;
  int v41 = 0;
  uint64_t v40 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a4, a3, a5[10].u32[0], a5[13].u32[0], (unsigned int *)v39);
  if (a2 >= 0) {
    unint64_t v12 = a2;
  }
  else {
    unint64_t v12 = -a2;
  }
  unint64_t v13 = v12 >> 4;
  if (v13 >= HIDWORD(v40)) {
    unint64_t v13 = HIDWORD(v40);
  }
  uint64_t v14 = a3[3].i32[1] * v38;
  unint64_t v15 = v14 + v38;
  unint64_t v16 = a3[7].u32[0];
  BOOL v17 = v15 >= v16;
  unint64_t v18 = v15 - v16;
  if (!v17)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -6;
  }
  unint64_t v19 = a3[6].u32[1] + v14;
  if (v19 < v18)
  {
    float v20 = a6;
    int8x16_t v21 = (int8x16_t)vdupq_n_s32(LODWORD(v20));
    do
    {
      uint64_t v22 = a1 + 4 * v13;
      uint64_t v23 = (_OWORD *)(a1 + 16 * v13);
      unint64_t v24 = v13;
      if (v13 >= 8)
      {
        do
        {
          int32x4_t v25 = *(int32x4_t *)(v22 - 32);
          int32x4_t v26 = *(int32x4_t *)(v22 - 16);
          v22 -= 32;
          *(v23 - 8) = vextq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v25.i8, 0), v21, 4uLL);
          v23 -= 8;
          int32x4_t v27 = vdupq_lane_s32(*(int32x2_t *)v25.i8, 1);
          v27.i32[3] = v21.i32[1];
          int32x4_t v28 = vdupq_laneq_s32(v25, 2);
          v28.i32[3] = v21.i32[2];
          int32x4_t v11 = vdupq_laneq_s32(v25, 3);
          v11.i32[3] = v21.i32[3];
          v24 -= 8;
          int8x16_t v29 = vextq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v26.i8, 0), v21, 4uLL);
          int32x4_t v30 = vdupq_lane_s32(*(int32x2_t *)v26.i8, 1);
          v30.i32[3] = v21.i32[1];
          int32x4_t v31 = vdupq_laneq_s32(v26, 2);
          v31.i32[3] = v21.i32[2];
          int32x4_t v32 = vdupq_laneq_s32(v26, 3);
          v32.i32[3] = v21.i32[3];
          v23[6] = v31;
          v23[7] = v32;
          v23[4] = v29;
          v23[5] = v30;
          v23[2] = v28;
          v23[3] = v11;
          v23[1] = v27;
        }
        while (v24 > 7);
      }
      if (v24 >= 2)
      {
        do
        {
          uint64_t v33 = *(void *)(v22 - 8);
          v22 -= 8;
          v11.i64[0] = v33;
          int32x4_t v34 = vzip1q_s32(v11, (int32x4_t)0);
          int32x4_t v35 = vtrn1q_s32(vuzp1q_s32(v34, v11), v34);
          v35.i32[3] = v21.i32[0];
          v24 -= 2;
          int32x4_t v11 = vuzp2q_s32(vuzp1q_s32(v34, v34), v11);
          v11.i32[3] = v21.i32[1];
          *(v23 - 2) = v35;
          *(v23 - 1) = v11;
          v23 -= 2;
        }
        while (v24 > 1);
      }
      if (v24)
      {
        int v36 = *(_DWORD *)(v22 - 4);
        *((_DWORD *)v23 - 4) = v36;
        *((_DWORD *)v23 - 3) = v36;
        *((_DWORD *)v23 - 2) = v36;
        *((float *)v23 - 1) = v20;
      }
      a1 += a2;
      ++v19;
    }
    while (v19 != v18);
  }
  return result;
}

uint64_t convertYAtoYYYA<unsigned short>(uint64_t a1, uint64_t a2, int32x2_t *a3, uint64_t a4, int32x2_t *a5)
{
  unsigned __int32 v28 = vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)((void)a5[40] + 8 * a3[60]) + 16), a5[48], a3[24]), (uint32x2_t)a5[48]).u32[1];
  v29[0] = 0;
  v29[1] = 0;
  int v31 = 0;
  uint64_t v30 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a4, a3, a5[10].u32[0], a5[13].u32[0], (unsigned int *)v29);
  if (a2 >= 0) {
    unint64_t v11 = a2;
  }
  else {
    unint64_t v11 = -a2;
  }
  unint64_t v12 = v11 >> 3;
  if (v12 >= HIDWORD(v30)) {
    unint64_t v12 = HIDWORD(v30);
  }
  uint64_t v13 = a3[3].i32[1] * v28;
  unint64_t v14 = v13 + v28;
  unint64_t v15 = a3[7].u32[0];
  BOOL v16 = v14 >= v15;
  unint64_t v17 = v14 - v15;
  if (!v16)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -6;
  }
  unint64_t v18 = a3[6].u32[1] + v13;
  if (v18 < v17)
  {
    do
    {
      uint64_t v19 = a1 + 4 * v12;
      uint64_t v20 = a1 + 8 * v12;
      unint64_t v21 = v12;
      if (v12 >= 8)
      {
        do
        {
          int8x16_t v22 = *(int8x16_t *)(v19 - 32);
          int8x16_t v23 = *(int8x16_t *)(v19 - 16);
          v19 -= 32;
          *(int8x16_t *)(v20 - 64) = vqtbl1q_s8(v22, (int8x16_t)xmmword_228F62B20);
          v20 -= 64;
          v21 -= 8;
          int16x8_t v9 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_228F62B30);
          int16x8_t v10 = (int16x8_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_228F62B20);
          *(int16x8_t *)(v20 + 32) = v10;
          *(int8x16_t *)(v20 + 48) = vqtbl1q_s8(v23, (int8x16_t)xmmword_228F62B30);
          *(int16x8_t *)(v20 + 16) = v9;
        }
        while (v21 > 7);
      }
      if (v21 >= 2)
      {
        do
        {
          uint64_t v24 = *(void *)(v19 - 8);
          v19 -= 8;
          v9.i64[0] = v24;
          *(int16x4_t *)v10.i8 = vtrn1_s16(*(int16x4_t *)v9.i8, *(int16x4_t *)v9.i8);
          int16x8_t v9 = vzip1q_s16(v10, v9);
          *(int16x8_t *)(v20 - 16) = v9;
          v20 -= 16;
          v21 -= 2;
        }
        while (v21 > 1);
      }
      if (v21)
      {
        __int16 v25 = *(_WORD *)(v19 - 4);
        __int16 v26 = *(_WORD *)(v19 - 2);
        *(_WORD *)(v20 - 8) = v25;
        *(_WORD *)(v20 - 6) = v25;
        *(_WORD *)(v20 - 4) = v25;
        *(_WORD *)(v20 - 2) = v26;
      }
      a1 += a2;
      ++v18;
    }
    while (v18 != v17);
  }
  return result;
}

uint64_t convertYAtoYYYA<unsigned int>(uint64_t a1, uint64_t a2, int32x2_t *a3, uint64_t a4, int32x2_t *a5, __n128 a6)
{
  a6.n128_u64[0] = (unint64_t)vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)(*(void *)&a5[5] + 8 * a3[7].u32[1])+ 16), a5[6], a3[3]), (uint32x2_t)a5[6]);
  __n128 v37 = a6;
  v38[0] = 0;
  v38[1] = 0;
  int v40 = 0;
  uint64_t v39 = 0;
  uint64_t result = TileDecoder::GetChannelTileInfo(a4, a3, a5[10].u32[0], a5[13].u32[0], (unsigned int *)v38);
  if (a2 >= 0) {
    unint64_t v10 = a2;
  }
  else {
    unint64_t v10 = -a2;
  }
  unint64_t v11 = v10 >> 4;
  if (v11 >= HIDWORD(v39)) {
    unint64_t v11 = HIDWORD(v39);
  }
  v12.i64[1] = v37.n128_i64[1];
  uint64_t v13 = a3[3].i32[1] * v37.n128_u32[1];
  unint64_t v14 = v13 + v37.n128_u32[1];
  unint64_t v15 = a3[7].u32[0];
  BOOL v16 = v14 >= v15;
  unint64_t v17 = v14 - v15;
  if (!v16)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -6;
  }
  unint64_t v18 = a3[6].u32[1] + v13;
  if (v18 < v17)
  {
    do
    {
      uint64_t v19 = (int32x4_t *)(a1 + 8 * v11);
      uint64_t v20 = (int32x4_t *)(a1 + 16 * v11);
      unint64_t v21 = v11;
      if (v11 >= 8)
      {
        do
        {
          int32x4_t v22 = v19[-4];
          v19 -= 4;
          int32x4_t v23 = v22;
          int32x4_t v25 = v19[2];
          int32x4_t v24 = v19[3];
          int32x4_t v26 = v19[1];
          int32x4_t v27 = vzip1q_s32(v23, v23);
          v27.i32[2] = v22.i32[0];
          v20[-8] = v27;
          v20 -= 8;
          v21 -= 8;
          int32x4_t v12 = vzip2q_s32(vtrn1q_s32(v23, v23), v22);
          int32x4_t v28 = vzip2q_s32(vtrn1q_s32(v26, v26), v26);
          int32x4_t v29 = vzip1q_s32(v26, v26);
          v29.i32[2] = v26.i32[0];
          int32x4_t v30 = vzip1q_s32(v25, v25);
          v30.i32[2] = v25.i32[0];
          int32x4_t v31 = vzip1q_s32(v24, v24);
          v31.i32[2] = v24.i32[0];
          v20[6] = v31;
          v20[7] = vzip2q_s32(vtrn1q_s32(v24, v24), v24);
          v20[4] = v30;
          v20[5] = vzip2q_s32(vtrn1q_s32(v25, v25), v25);
          v20[2] = v29;
          v20[3] = v28;
          v20[1] = v12;
        }
        while (v21 > 7);
      }
      if (v21 >= 2)
      {
        do
        {
          int32x4_t v32 = v19[-1];
          --v19;
          int32x4_t v33 = v32;
          int32x4_t v34 = vzip1q_s32(v33, v33);
          v34.i32[2] = v32.i32[0];
          v20[-2] = v34;
          v20 -= 2;
          v21 -= 2;
          int32x4_t v12 = vzip2q_s32(vtrn1q_s32(v33, v33), v32);
          v20[1] = v12;
        }
        while (v21 > 1);
      }
      if (v21)
      {
        v12.i64[0] = v19[-1].i64[1];
        int32x4_t v35 = vzip1q_s32(v12, v12);
        v35.i32[2] = v12.i32[0];
        v20[-1] = v35;
      }
      a1 += a2;
      ++v18;
    }
    while (v18 != v17);
  }
  return result;
}

unint64_t TileDecoder::ReadPixels(TileDecoder *this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = (*(uint64_t (**)(TileDecoder *, void))(*(void *)this + 32))(this, *((void *)this + 6));
  v14._os_unfair_lock_opaque = 0;
  uint64_t v15 = 0;
  uint64_t v16 = v8 + 64;
  v13[1] = 0;
  unint64_t PixelsArgs = TileDecoder::MakeReadPixelsArgs((uint64_t)this, a4, a5, (uint64_t)&v14, 0, (uint64_t)v13, v9, v10, 0.0);
  if (!PixelsArgs) {
    unint64_t PixelsArgs = LaunchBlocks<ReadPixelsArgs>((void (__cdecl *)(void *, size_t))TileDecoder::ReadPixelsBlock, v13, (*((_DWORD *)this + 26) * *((_DWORD *)this + 27)), *((void *)this + 1));
  }
  AXRBufferPool::FreeBuffers(&v14);
  return PixelsArgs;
}

void sub_228F33F80(_Unwind_Exception *a1)
{
  AXRBufferPool::FreeBuffers((os_unfair_lock_s *)(v1 - 56));
  _Unwind_Resume(a1);
}

uint64_t TileDecoder::MakeReadPixelsArgs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v9 = *(unsigned int *)(a1 + 72);
  if (v9)
  {
    uint64_t v10 = *(void *)(a1 + 64);
    uint64_t v11 = v10 + 8;
    uint64_t v12 = *(unsigned int *)(a1 + 72);
    while (!*(void *)v11)
    {
      v11 += 16;
      if (!--v12) {
        goto LABEL_5;
      }
    }
    unsigned int v16 = 0;
    uint64_t v17 = 0;
    int v18 = *(_DWORD *)(*(void *)v11 + 72);
    uint64_t v20 = *(void *)(v10 + 8);
    uint64_t v19 = (void *)(v10 + 8);
    BOOL v21 = v20 == 0;
    while (1)
    {
      int32x4_t v22 = (_DWORD *)*v19;
      if (*v19) {
        break;
      }
LABEL_34:
      v19 += 2;
      if (!--v9)
      {
        if (*(_DWORD *)(*(void *)(a1 + 24) + 72) == 1 && (*(unsigned char *)(a1 + 8) & 8) == 0)
        {
          a2 += (*(_DWORD *)(*(void *)(a1 + 16) + 60) - 1) * a3;
          a3 = -a3;
        }
        uint64_t v15 = 0;
        *(void *)a6 = a1;
        atomic_store(0, (unint64_t *)(a6 + 8));
        *(void *)(a6 + 16) = a2;
        *(void *)(a6 + 24) = a3;
        *(void *)(a6 + 32) = a4;
        *(double *)(a6 + 40) = a9;
        if (v18 == 1) {
          int v25 = 2;
        }
        else {
          int v25 = 4;
        }
        *(_DWORD *)(a6 + 48) = v25;
        *(_DWORD *)(a6 + 52) = v17;
        *(_DWORD *)(a6 + 56) = v16;
        *(unsigned char *)(a6 + 60) = v21;
        return v15;
      }
    }
    if (v22[18] != v18)
    {
      uint64_t v27 = *(void *)(a1 + 8);
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v27) & 2) != 0)
      {
        os_unfair_lock_s v14 = "All channels in the pixel must be of the same type.";
        goto LABEL_9;
      }
      return -1;
    }
    uint64_t v23 = v22[20];
    if (v17)
    {
      if (a5)
      {
        if (v17 >= v23) {
          uint64_t v17 = v23;
        }
        else {
          uint64_t v17 = v17;
        }
        unsigned int v24 = v22[26];
        if (!v16) {
          goto LABEL_31;
        }
        uint64_t v23 = v17;
LABEL_23:
        BOOL v21 = 0;
        if (v16 >= v24) {
          unsigned int v16 = v24;
        }
LABEL_30:
        uint64_t v17 = v23;
        goto LABEL_34;
      }
      if (v23 != v17)
      {
        uint64_t v28 = *(void *)(a1 + 8);
        if (GetFlagsOnceToken != -1) {
          dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
        }
        if (((kDefaultAXRLogFlags | v28) & 2) != 0)
        {
          os_unfair_lock_s v14 = "All channels in the pixel must have the same X sampling rate.";
          goto LABEL_9;
        }
        return -1;
      }
      unsigned int v24 = v22[26];
      if (!v16)
      {
LABEL_31:
        BOOL v21 = 0;
LABEL_33:
        unsigned int v16 = v24;
        goto LABEL_34;
      }
      uint64_t v23 = v17;
    }
    else
    {
      unsigned int v24 = v22[26];
      if (!v16)
      {
        BOOL v21 = 0;
        uint64_t v17 = v23;
        goto LABEL_33;
      }
      if (a5) {
        goto LABEL_23;
      }
    }
    if (v24 != v16)
    {
      uint64_t v29 = *(void *)(a1 + 8);
      if (GetFlagsOnceToken != -1) {
        dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
      }
      if (((kDefaultAXRLogFlags | v29) & 2) != 0)
      {
        os_unfair_lock_s v14 = "All channels in the pixel must have the same Y sampling rate.";
        goto LABEL_9;
      }
      return -1;
    }
    BOOL v21 = 0;
    goto LABEL_30;
  }
LABEL_5:
  uint64_t v13 = *(void *)(a1 + 8);
  if (GetFlagsOnceToken != -1) {
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
  if (((kDefaultAXRLogFlags | v13) & 2) != 0)
  {
    os_unfair_lock_s v14 = "All channels are constant. In this case, AppleEXR doesn't have a sample type to use to create the pixel.";
LABEL_9:
    AXRLogError((uint64_t)v14, a2, a3, a4, a5, a6, a7, a8, v30);
  }
  return -1;
}

unint64_t LaunchBlocks<ReadPixelsArgs>(void (__cdecl *a1)(void *, size_t), unint64_t *a2, unint64_t a3, char a4)
{
  if ((a4 & 4) != 0) {
    goto LABEL_18;
  }
  uint64_t v8 = (unsigned int *)*a2;
  uint64_t v9 = *(void *)(*a2 + 64);
  if (v9)
  {
    BOOL v30 = *(_DWORD *)(*(void *)v9 + 16) == 1;
    unsigned int v10 = 4;
    if (v30) {
      unsigned int v10 = 2;
    }
  }
  else
  {
    unsigned int v10 = 2;
  }
  unint64_t v11 = v10 * (unint64_t)v8[14] * v8[15] * v8[18];
  unsigned int v12 = v8[26];
  unsigned int v13 = v8[27];
  unint64_t v14 = (*(uint64_t (**)(unsigned int *))(*(void *)v8 + 16))(v8);
  if (v11 <= 1) {
    unint64_t v15 = 1;
  }
  else {
    unint64_t v15 = v11;
  }
  unint64_t v16 = v14 + v15 - 1;
  if (v16 < v14) {
    unint64_t v17 = (v14 + v15 - 0xFFFFFFFF / v15 * v15 + 0xFFFFFFFF) / v15 + 0xFFFFFFFF / v15;
  }
  else {
    unint64_t v17 = v16 / v15;
  }
  if (v17 >= v13 * (unint64_t)v12) {
    unint64_t v17 = v13 * (unint64_t)v12;
  }
  unint64_t v18 = v17 <= 1 ? 1 : v17;
  if (v17 <= 1)
  {
LABEL_18:
    qos_class_t v19 = qos_class_self();
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(v19, 0);
    if ((a4 & 4) == 0 && a3 >= 2)
    {
      BOOL v21 = global_queue;
      if (global_queue)
      {
        size_t v22 = a3;
        uint64_t v23 = a2;
        unsigned int v24 = a1;
LABEL_45:
        dispatch_apply_f(v22, v21, v23, v24);
        return atomic_load(a2 + 1);
      }
    }
    if (a3)
    {
      uint64_t v25 = 0;
      do
        ((void (*)(unint64_t *, uint64_t))a1)(a2, v25++);
      while (a3 != v25);
    }
  }
  else
  {
    v38[0] = a1;
    v38[1] = a2;
    void v38[2] = v18;
    v38[3] = a3;
    unint64_t v26 = v18 + a3 - 1;
    if (v26 < a3) {
      unint64_t v27 = (v18 + a3 - 0xFFFFFFFF / v18 * v18 + 0xFFFFFFFF) / v18 + 0xFFFFFFFF / v18;
    }
    else {
      unint64_t v27 = v26 / v18;
    }
    qos_class_t v28 = qos_class_self();
    dispatch_queue_global_t v29 = dispatch_get_global_queue(v28, 0);
    BOOL v21 = v29;
    BOOL v30 = v27 < 2 || v29 == 0;
    if (!v30)
    {
      unsigned int v24 = (void (__cdecl *)(void *, size_t))DoAggregateBlock<ReadPixelsArgs>;
      uint64_t v23 = v38;
      size_t v22 = v27;
      goto LABEL_45;
    }
    if (v27)
    {
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      unint64_t v33 = a3;
      do
      {
        if (v18 >= v33) {
          unint64_t v34 = v33;
        }
        else {
          unint64_t v34 = v18;
        }
        unint64_t v35 = a3 - v18 * v32;
        if (v18 < v35) {
          unint64_t v35 = v18;
        }
        if (v35)
        {
          uint64_t v36 = v31;
          do
          {
            ((void (*)(unint64_t *, uint64_t))a1)(a2, v36++);
            --v34;
          }
          while (v34);
        }
        ++v32;
        v33 -= v18;
        v31 += v18;
      }
      while (v32 != v27);
    }
  }
  return atomic_load(a2 + 1);
}

unint64_t TileDecoder::ReadGrayscaleRGBAPixels(TileDecoder *this, double a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(TileDecoder *, void))(*(void *)this + 32))(this, *((void *)this + 6));
  v14._os_unfair_lock_opaque = 0;
  uint64_t v15 = 0;
  uint64_t v16 = v8 + 64;
  v13[1] = 0;
  unint64_t PixelsArgs = TileDecoder::MakeReadPixelsArgs((uint64_t)this, a3, a4, (uint64_t)&v14, 0, (uint64_t)v13, v9, v10, a2);
  if (!PixelsArgs) {
    unint64_t PixelsArgs = LaunchBlocks<ReadPixelsArgs>((void (__cdecl *)(void *, size_t))TileDecoder::ReadPixelsBlockGrayToRGBA, v13, (*((_DWORD *)this + 26) * *((_DWORD *)this + 27)), *((void *)this + 1));
  }
  AXRBufferPool::FreeBuffers(&v14);
  return PixelsArgs;
}

void sub_228F345AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  AXRBufferPool::FreeBuffers((os_unfair_lock_s *)va);
  _Unwind_Resume(a1);
}

void TileDecoder::ReadYccBlock(TileDecoder *this, unint64_t a2)
{
  if (!this) {
    return;
  }
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *(void *)(*(void *)this + 8);
  uint64_t v74 = 0;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  TileDecoder::GetThreadTileInfo((TileDecoder *)v3, a2, (uint64_t)&v70);
  if (!*((void *)&v70 + 1) || !(void)v70 || (v73 + HIDWORD(v72)) >= *(_DWORD *)(v3 + 56)) {
    return;
  }
  unsigned int v13 = DWORD2(v73) + DWORD1(v73);
  unsigned int v14 = *(_DWORD *)(v3 + 60);
  int v15 = DWORD2(v73) + DWORD1(v73) >= v14 ? 0 : DWORD1(v72);
  uint64_t v16 = v13 >= v14 ? 0 : DWORD2(v72);
  if (v13 >= v14) {
    return;
  }
  unint64_t v17 = (_DWORD *)*((void *)this + 24);
  unint64_t v18 = (_DWORD *)*((void *)this + 25);
  uint64_t v19 = v17[18];
  if (v19)
  {
    uint64_t v20 = 0;
    uint64_t v21 = 16 * v19;
    while (!*(void *)(*(void *)(v3 + 64) + 8 + v20))
    {
      v20 += 16;
      if (v21 == v20) {
        goto LABEL_16;
      }
    }
    size_t v22 = *(int32x2_t **)(*((void *)v17 + 8) + v20 + 8);
    v12.n128_u64[0] = (unint64_t)vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)(*(void *)&v22[5]+ 8 * HIDWORD(v73))+ 16), v22[6], *(int32x2_t *)((char *)&v71 + 8)), (uint32x2_t)v22[6]);
  }
  else
  {
LABEL_16:
    __n128 v12 = 0uLL;
  }
  uint64_t v23 = v18[18];
  if (!v23) {
    goto LABEL_28;
  }
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  unint64_t v26 = (uint64_t *)(*((void *)v18 + 8) + 8);
  do
  {
    uint64_t v27 = *v26;
    if (!*v26) {
      goto LABEL_23;
    }
    if (v25)
    {
      if (v24) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v25 = *(unsigned int *)(v27 + 80);
      if (v24) {
        goto LABEL_23;
      }
    }
    uint64_t v24 = *(unsigned int *)(v27 + 104);
LABEL_23:
    v26 += 2;
    --v23;
  }
  while (v23);
  if ((v25 - 3) < 0xFFFFFFFE)
  {
LABEL_28:
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v4) & 2) != 0) {
      AXRLogDebug((uint64_t)"Error: chroma x sampling rate must be 1 or 2", v5, v6, v7, v8, v9, v10, v11, v54);
    }
    return;
  }
  __n128 v60 = v12;
  int v59 = *((_DWORD *)this + 12);
  uint64_t v55 = *((void *)this + 31) - 64;
  uint64_t v56 = *((void *)this + 28);
  AXRBufferPool::allocate((TileDecoder *)((char *)this + 208), v69);
  AXRBufferPool::allocate((TileDecoder *)((char *)this + 232), v68);
  v65[0] = 0;
  v65[1] = 0;
  int v67 = 0;
  uint64_t v66 = 0;
  TileDecoder::GetChannelTileInfo((uint64_t)v18, &v70, v25, v24, (unsigned int *)v65);
  unsigned int v28 = 0;
  int v29 = 0;
  unsigned int v30 = v17[14];
  if ((int)v73 + HIDWORD(v72) < v30)
  {
    unsigned int v31 = v17[15];
    if (DWORD2(v73) + DWORD1(v73) < v31) {
      unsigned int v28 = ~v73 - HIDWORD(v72) + v30 + 1;
    }
    else {
      unsigned int v28 = 0;
    }
    if (DWORD2(v73) + DWORD1(v73) < v31) {
      int v29 = ~DWORD2(v73) - DWORD1(v73) + v31 + 1;
    }
    else {
      int v29 = 0;
    }
  }
  unint64_t v32 = v17[18] * (unint64_t)v28;
  __n128 v33 = v60;
  if ((v32 & 0xFFFFFFFF00000000) != 0
    || (unsigned int v34 = *((_DWORD *)this + 12), v35 = v34 * (unint64_t)v32, (v35 & 0xFFFFFFFF00000000) != 0))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -6;
  }
  int v57 = v29;
  unsigned int v58 = v28;
  unint64_t v36 = HIDWORD(v66) * (unint64_t)v18[18];
  if ((v36 & 0xFFFFFFFF00000000) != 0
    || (unint64_t v37 = v36 * (unint64_t)v34, (v37 & 0xFFFFFFFF00000000) != 0))
  {
    int v52 = __cxa_allocate_exception(8uLL);
    void *v52 = -6;
  }
  uint64_t v61 = v37;
  if ((*(unsigned int (**)(_DWORD *, long long *, __n128))(*(void *)v17 + 64))(v17, &v70, v33))
  {
    uint64_t CompressedDataPtr = AXRChunkHeader::GetCompressedDataPtr(v70, *(_DWORD *)(*((void *)v17 + 3) + 208), *((unint64_t *)&v70 + 1));
    if (!CompressedDataPtr)
    {
      double v53 = __cxa_allocate_exception(8uLL);
      void *v53 = -4;
    }
    if (*(_DWORD *)(v3 + 72) == 1) {
      TileDecoder::ExtractPlane_Uncompressed((uint64_t)v17, CompressedDataPtr, *((unint64_t *)&v70 + 1), *(void *)(v3 + 64), (uint64_t)&v70, v69[0], v41, v35);
    }
    else {
      TileDecoder::Interleave_Uncompressed((uint64_t)v17, CompressedDataPtr, *((unint64_t *)&v70 + 1), (uint64_t)&v70, 1u, 1u);
    }
    TileDecoder::Interleave_Uncompressed((uint64_t)v18, CompressedDataPtr, *((unint64_t *)&v70 + 1), (uint64_t)&v70, v25, v24);
  }
  else
  {
    uint64_t v64 = *(void *)(*((void *)this + 4) + 16) - 64;
    if (*((unsigned char *)this + 60))
    {
      uint64_t v62 = 0;
      uint64_t v63 = 0;
    }
    else
    {
      (*(void (**)(uint64_t *__return_ptr))(**(void **)this + 24))(&v62);
    }
    if (v69[0])
    {
      if (v17[18] == 1) {
        (*(void (**)(_DWORD *, uint64_t, uint64_t, void, long long *, char *, uint64_t, void))(*(void *)v17 + 48))(v17, v62, v64, *((void *)v17 + 8), &v70, v69[0], v56 - 64, v35);
      }
      else {
        (*(void (**)(_DWORD *, uint64_t, uint64_t, long long *, uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v62, v64, &v70, 1, 1);
      }
    }
    if (v68[0])
    {
      if (v18[18] == 1) {
        (*(void (**)(_DWORD *, uint64_t, uint64_t, void, long long *, int32x4_t *, uint64_t, void))(*(void *)v18 + 48))(v18, v62, v64, *((void *)v18 + 8), &v70, v68[0], v55, v37);
      }
      else {
        (*(void (**)(_DWORD *, uint64_t, uint64_t, long long *, uint64_t, uint64_t))(*(void *)v18 + 40))(v18, v62, v64, &v70, v25, v24);
      }
    }
    uint64_t v43 = v62;
    uint64_t v62 = 0;
    if (v43 && v63) {
      free((void *)(v43 - 64));
    }
  }
  if (v69[0])
  {
    if (v68[0])
    {
      uint64_t v44 = *((void *)this + 3);
      uint64_t v45 = (int8x16_t *)(*((void *)this + 2) + v44 * v16 + (v59 * v15 * *(_DWORD *)(v3 + 72)));
      int v46 = *((_DWORD *)this + 12);
      double v47 = *((double *)this + 13);
      uint64_t v48 = *((void *)this + 33);
      if (v17[18] == 2)
      {
        if (v46 == 2)
        {
          if (v25 == 1) {
            YCCAtoRGBA<half,1u>((const __int16 *)v69[0], v35, v68[0]->i16, v61, v45, v44, v48, v58, v47, v57, v24);
          }
          else {
            YCCAtoRGBA<half,2u>((const __int16 *)v69[0], v35, v68[0], v61, v45, v44, v48, v58, v47, v38, v39, v57, v24);
          }
        }
        else if (v25 == 1)
        {
          YCCAtoRGBA<float,1u>(v69[0], v35, (uint64_t)v68[0]->i64, v61, (int32x4_t *)v45, v44, v48, v58, v57, v24);
        }
        else
        {
          YCCAtoRGBA<float,2u>(v69[0], v35, (int64x2_t *)v68[0], v61, (int32x4_t *)v45, v44, v48, v58, v57, v24);
        }
      }
      else if (v46 == 2)
      {
        if (v25 == 1) {
          YCCtoRGBA<half,1u>((float16x8_t *)v69[0], v35, v68[0]->i16, v61, v45->i8, v44, v48, v58, v47, v57, v24);
        }
        else {
          YCCtoRGBA<half,2u>((float16x8_t *)v69[0], v35, v68[0], v61, v45, v44, v48, v58, v47, v38, *(double *)v39.i64, v40, v57, v24);
        }
      }
      else if (v25 == 1)
      {
        YCCtoRGBA<float,1u>((float32x4_t *)v69[0], v35, (const float *)v68[0]->i32, v61, (int32x4_t *)v45, v44, v48, v58, v47, v57, v24);
      }
      else
      {
        YCCtoRGBA<float,2u>((float32x4_t *)v69[0], v35, (int64x2_t *)v68[0], v61, (int32x4_t *)v45, v44, v48, v58, v47, v57, v24);
      }
      goto LABEL_80;
    }
  }
  else
  {
LABEL_80:
    int v49 = v68[0];
    v68[0] = 0;
    if (v49 && v68[1]) {
      free(&v49[-4]);
    }
  }
  int v50 = v69[0];
  v69[0] = 0;
  if (v50 && v69[1]) {
    free(v50 - 64);
  }
}

void sub_228F34CD4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (a25 && a26) {
    free((void *)(a25 - 64));
  }
  if (a27 && a28) {
    free((void *)(a27 - 64));
  }
  if (a2 == 2)
  {
    unsigned int v31 = (unint64_t *)__cxa_begin_catch(a1);
    uint64_t v32 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(v28 + 8), (unint64_t *)&v32, *v31);
    __cxa_end_catch();
    JUMPOUT(0x228F34C20);
  }
  __clang_call_terminate(a1);
}

void YCCAtoRGBA<half,1u>(const __int16 *a1, uint64_t a2, const __int16 *a3, uint64_t a4, int8x16_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, double _D0, int a10, unsigned int a11)
{
  __asm { FCVT            H0, D0 }
  __int16 v48 = _H0;
  if (a10)
  {
    uint64_t v21 = 0;
    int v22 = 0;
    do
    {
      int v46 = a3;
      double v47 = a1;
      uint64_t v23 = a5;
      uint64_t v24 = a3;
      uint64_t v25 = a1;
      unsigned int v26 = a8;
      uint64_t v45 = a5;
      if (a8 >= 0x10)
      {
        do
        {
          _YCCAtoRGBA<half,1u,16>(&v47, &v46, &v45, a7);
          v26 -= 16;
        }
        while (v26 > 0xF);
        uint64_t v24 = v46;
        uint64_t v25 = v47;
        uint64_t v23 = v45;
      }
      if (v26 >= 4)
      {
        do
        {
          int16x4x2_t v49 = vld2_s16(v25);
          v25 += 8;
          float32x4_t v27 = vcvtq_f32_f16((float16x4_t)v49.val[0]);
          float32x4_t v52 = (float32x4_t)vld2_s16(v24);
          v24 += 8;
          float32x4_t v28 = vmlaq_f32(v27, vcvtq_f32_f16(*(float16x4_t *)&v52.u32[2]), v27);
          float32x4_t v52 = vmlaq_f32(v27, vcvtq_f32_f16(*(float16x4_t *)v52.f32), v27);
          v52.i64[1] = *(void *)a7;
          v52.i32[2] = *(_DWORD *)(a7 + 8);
          float32x4_t v29 = vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v27, v28, *(float32x2_t *)a7, 0), v52, *(float32x2_t *)&v52.u32[2], 0), COERCE_FLOAT(*(void *)(a7 + 4)));
          *(float16x4_t *)v28.f32 = vcvt_f16_f32(v28);
          *(float16x4_t *)v29.f32 = vcvt_f16_f32(v29);
          *(float16x4_t *)v52.f32 = vcvt_f16_f32(v52);
          *(int16x4_t *)&v52.u32[2] = vzip2_s16(*(int16x4_t *)v28.f32, *(int16x4_t *)v52.f32);
          *(int16x4_t *)v28.f32 = vzip1_s16(*(int16x4_t *)v28.f32, *(int16x4_t *)v52.f32);
          *(int16x4_t *)&v28.u32[2] = vzip1_s16(*(int16x4_t *)v29.f32, v49.val[1]);
          int16x4_t v30 = vzip2_s16(*(int16x4_t *)v29.f32, v49.val[1]);
          *uint64_t v23 = vqtbl1q_s8((int8x16_t)v28, (int8x16_t)xmmword_228F62B40);
          v23[1] = vqtbl1q_s8(*(int8x16_t *)((char *)&v52 + 8), (int8x16_t)xmmword_228F62B40);
          v23 += 2;
          v26 -= 4;
        }
        while (v26 > 3);
        int v46 = v24;
        double v47 = v25;
        uint64_t v45 = v23;
      }
      if (v26)
      {
        long long v43 = 0u;
        long long __dst = 0u;
        int8x16_t __src = 0u;
        int8x16_t v42 = 0u;
        memcpy(&__dst, v25, 2 * v26);
        memcpy(&v43, v24, 4 * v26);
        p_dst = (const __int16 *)&__dst;
        int16x4x2_t v50 = vld2_s16(p_dst);
        uint64_t v32 = (const __int16 *)&v43;
        float32x4_t v51 = (float32x4_t)vld2_s16(v32);
        float32x4_t v33 = vcvtq_f32_f16((float16x4_t)v50.val[0]);
        *(float32x4_t *)((char *)&v51 + 8) = vmlaq_f32(v33, vcvtq_f32_f16(*(float16x4_t *)&v51.u32[2]), v33);
        float32x4_t v51 = vmlaq_f32(v33, vcvtq_f32_f16(*(float16x4_t *)v51.f32), v33);
        float32x2_t v34 = *(float32x2_t *)a7;
        v34.i32[0] = *(_DWORD *)(a7 + 8);
        float32x4_t v35 = vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v33, *(float32x4_t *)((char *)&v51 + 8), *(float32x2_t *)a7, 0), v51, v34, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
        *(float16x4_t *)&v51.u32[2] = vcvt_f16_f32(*(float32x4_t *)((char *)&v51 + 8));
        *(float16x4_t *)v35.f32 = vcvt_f16_f32(v35);
        *(float16x4_t *)v51.f32 = vcvt_f16_f32(v51);
        *(int16x4_t *)v36.i8 = vzip2_s16(*(int16x4_t *)&v51.u32[2], *(int16x4_t *)v51.f32);
        *(int16x4_t *)v51.f32 = vzip1_s16(*(int16x4_t *)&v51.u32[2], *(int16x4_t *)v51.f32);
        int16x4_t v37 = vzip1_s16(*(int16x4_t *)v35.f32, v50.val[1]);
        v36.u64[1] = (unint64_t)vzip2_s16(*(int16x4_t *)v35.f32, v50.val[1]);
        int8x16_t __src = vqtbl1q_s8((int8x16_t)v51, (int8x16_t)xmmword_228F62B40);
        int8x16_t v42 = vqtbl1q_s8(v36, (int8x16_t)xmmword_228F62B40);
        memcpy(v23, &__src, 8 * v26);
      }
      a5 = (int8x16_t *)((char *)a5 + a6);
      a1 = (const __int16 *)((char *)a1 + a2);
      if (v22 + 1 < a11)
      {
        ++v22;
      }
      else
      {
        a3 = (const __int16 *)((char *)a3 + a4);
        int v22 = 0;
      }
      ++v21;
    }
    while (v21 != a10);
  }
}

void YCCAtoRGBA<half,2u>(const __int16 *a1, uint64_t a2, int32x4_t *a3, uint64_t a4, int8x16_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, double _D0, double a10, int32x4_t a11, int a12, unsigned int a13)
{
  __asm { FCVT            H0, D0 }
  __int16 v58 = _H0;
  if (a12)
  {
    uint64_t v23 = 0;
    int v24 = 0;
    do
    {
      uint64_t v56 = a3;
      int v57 = a1;
      uint64_t v25 = a5;
      unsigned int v26 = a3;
      float32x4_t v27 = a1;
      unsigned int v28 = a8;
      uint64_t v55 = a5;
      if (a8 >= 0x10)
      {
        do
        {
          _YCCAtoRGBA<half,2u,16>(&v57, &v56, &v55, a7);
          v28 -= 16;
        }
        while (v28 > 0xF);
        unsigned int v26 = v56;
        float32x4_t v27 = v57;
        uint64_t v25 = v55;
      }
      if (v28 >= 4)
      {
        do
        {
          int16x4x2_t v59 = vld2_s16(v27);
          v27 += 8;
          int v57 = v27;
          unint64_t v29 = v26->i64[0];
          unsigned int v26 = (int32x4_t *)((char *)v26 + 8);
          a11.i64[0] = v29;
          int8x16_t v30 = (int8x16_t)vzip1q_s32(a11, a11);
          uint64_t v56 = v26;
          float32x4_t v31 = vcvtq_f32_f16((float16x4_t)v59.val[0]);
          int16x4_t v32 = (int16x4_t)vextq_s8(v30, v30, 8uLL).u64[0];
          float16x4_t v33 = (float16x4_t)vuzp1_s16(*(int16x4_t *)v30.i8, v32);
          float32x4_t v34 = vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v30.i8, v32));
          float32x4_t v35 = vcvtq_f32_f16(v33);
          float32x4_t v36 = vmlaq_f32(v31, v34, v31);
          float32x4_t v37 = vmlaq_f32(v31, v35, v31);
          v35.i64[0] = *(void *)a7;
          v35.i32[0] = *(_DWORD *)(a7 + 8);
          float32x4_t v38 = vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v31, v36, *(float32x2_t *)a7, 0), v37, *(float32x2_t *)v35.f32, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
          *(float16x4_t *)v35.f32 = vcvt_f16_f32(v36);
          *(float16x4_t *)v38.f32 = vcvt_f16_f32(v38);
          *(float16x4_t *)v37.f32 = vcvt_f16_f32(v37);
          *(int16x4_t *)v36.f32 = vzip2_s16(*(int16x4_t *)v35.f32, *(int16x4_t *)v37.f32);
          *(int16x4_t *)a11.i8 = vzip1_s16(*(int16x4_t *)v35.f32, *(int16x4_t *)v37.f32);
          a11.u64[1] = (unint64_t)vzip1_s16(*(int16x4_t *)v38.f32, v59.val[1]);
          *(int16x4_t *)&v36.u32[2] = vzip2_s16(*(int16x4_t *)v38.f32, v59.val[1]);
          *uint64_t v25 = vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_228F62B40);
          v25[1] = vqtbl1q_s8((int8x16_t)v36, (int8x16_t)xmmword_228F62B40);
          v25 += 2;
          uint64_t v55 = v25;
          v28 -= 4;
        }
        while (v28 > 3);
      }
      if (v28)
      {
        long long __dst = 0u;
        uint64_t v53 = 0;
        int8x16_t __src = 0u;
        int8x16_t v52 = 0u;
        memcpy(&__dst, v27, 2 * v28);
        memcpy(&v53, v26, (2 * (_BYTE)v28 + 2) & 0xC);
        p_dst = (const __int16 *)&__dst;
        int16x4x2_t v60 = vld2_s16(p_dst);
        v40.i64[0] = v53;
        int8x16_t v41 = (int8x16_t)vzip1q_s32(v40, v40);
        float32x4_t v42 = vcvtq_f32_f16((float16x4_t)v60.val[0]);
        int16x4_t v43 = (int16x4_t)vextq_s8(v41, v41, 8uLL).u64[0];
        float32x4_t v44 = vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v41.i8, v43));
        float32x4_t v45 = vmlaq_f32(v42, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v41.i8, v43)), v42);
        float32x4_t v46 = vmlaq_f32(v42, v44, v42);
        v44.i64[0] = *(void *)a7;
        v44.i32[0] = *(_DWORD *)(a7 + 8);
        float32x4_t v47 = vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v42, v45, *(float32x2_t *)a7, 0), v46, *(float32x2_t *)v44.f32, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
        *(float16x4_t *)v45.f32 = vcvt_f16_f32(v45);
        *(float16x4_t *)v47.f32 = vcvt_f16_f32(v47);
        *(float16x4_t *)v46.f32 = vcvt_f16_f32(v46);
        *(int16x4_t *)v44.f32 = vzip2_s16(*(int16x4_t *)v45.f32, *(int16x4_t *)v46.f32);
        *(int16x4_t *)v46.f32 = vzip1_s16(*(int16x4_t *)v45.f32, *(int16x4_t *)v46.f32);
        *(int16x4_t *)&v46.u32[2] = vzip1_s16(*(int16x4_t *)v47.f32, v60.val[1]);
        *(int16x4_t *)&v44.u32[2] = vzip2_s16(*(int16x4_t *)v47.f32, v60.val[1]);
        int8x16_t __src = vqtbl1q_s8((int8x16_t)v46, (int8x16_t)xmmword_228F62B40);
        int8x16_t v52 = vqtbl1q_s8((int8x16_t)v44, (int8x16_t)xmmword_228F62B40);
        memcpy(v25, &__src, 8 * v28);
      }
      a5 = (int8x16_t *)((char *)a5 + a6);
      a1 = (const __int16 *)((char *)a1 + a2);
      if (v24 + 1 < a13)
      {
        ++v24;
      }
      else
      {
        a3 = (int32x4_t *)((char *)a3 + a4);
        int v24 = 0;
      }
      ++v23;
    }
    while (v23 != a12);
  }
}

char *YCCAtoRGBA<float,1u>(char *result, uint64_t a2, uint64_t a3, uint64_t a4, int32x4_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, int a9, unsigned int a10)
{
  if (a9)
  {
    unsigned int v14 = (float32x4_t *)result;
    uint64_t v15 = 0;
    int v16 = 0;
    do
    {
      unint64_t v17 = a5;
      uint64_t v18 = a3;
      uint64_t v19 = v14;
      unsigned int v20 = a8;
      if (a8 >= 0x10)
      {
        do
        {
          float32x4_t v21 = v19[1];
          float32x4_t v22 = v19[2];
          float32x4_t v23 = v19[3];
          float32x4_t v24 = v19[4];
          float32x4_t v25 = v19[5];
          float32x4_t v26 = v19[6];
          float32x4_t v27 = v19[7];
          float32x4_t v29 = *(float32x4_t *)(v18 + 32);
          float32x4_t v28 = *(float32x4_t *)(v18 + 48);
          float32x4_t v31 = *(float32x4_t *)(v18 + 64);
          float32x4_t v30 = *(float32x4_t *)(v18 + 80);
          float32x4_t v33 = *(float32x4_t *)(v18 + 96);
          float32x4_t v32 = *(float32x4_t *)(v18 + 112);
          float32x4_t v34 = (float32x4_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v27);
          float32x4_t v35 = (float32x4_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v25);
          float32x4_t v36 = (float32x4_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v23);
          float32x4_t v37 = (float32x4_t)vuzp1q_s32(*(int32x4_t *)v19, (int32x4_t)v21);
          float32x4_t v38 = *(float32x4_t *)(v18 + 16);
          float32x4_t v39 = vmlaq_f32(v37, (float32x4_t)vuzp2q_s32(*(int32x4_t *)v18, (int32x4_t)v38), v37);
          float32x4_t v40 = vmlaq_f32(v36, (float32x4_t)vuzp2q_s32((int32x4_t)v29, (int32x4_t)v28), v36);
          float32x4_t v41 = vmlaq_f32(v35, (float32x4_t)vuzp2q_s32((int32x4_t)v31, (int32x4_t)v30), v35);
          float32x4_t v42 = vmlaq_f32(v34, (float32x4_t)vuzp2q_s32((int32x4_t)v33, (int32x4_t)v32), v34);
          int32x4_t v43 = (int32x4_t)vmlaq_f32(v21, v38, v21);
          int32x4_t v44 = (int32x4_t)vmlaq_f32(*v19, *(float32x4_t *)v18, *v19);
          int32x4_t v45 = (int32x4_t)vmlaq_f32(v23, v28, v23);
          int32x4_t v46 = (int32x4_t)vmlaq_f32(v22, v29, v22);
          int32x4_t v47 = (int32x4_t)vmlaq_f32(v25, v30, v25);
          int32x4_t v48 = (int32x4_t)vmlaq_f32(v24, v31, v24);
          int32x4_t v49 = (int32x4_t)vmlaq_f32(v27, v32, v27);
          int32x4_t v50 = (int32x4_t)vmlaq_f32(v26, v33, v26);
          float32x2_t v51 = *(float32x2_t *)a7;
          v51.i32[0] = *(_DWORD *)(a7 + 8);
          v33.i64[0] = *(void *)(a7 + 4);
          int32x4_t v52 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v34, v42, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v50, v49), v51, 0), v33.f32[0]);
          int32x4_t v53 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v35, v41, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v48, v47), v51, 0), v33.f32[0]);
          int32x4_t v54 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v36, v40, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v46, v45), v51, 0), v33.f32[0]);
          int32x4_t v55 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v37, v39, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v44, v43), v51, 0), v33.f32[0]);
          int8x16_t v56 = (int8x16_t)vzip2q_s32((int32x4_t)v42, vuzp1q_s32((int32x4_t)v42, v49));
          int8x16_t v57 = (int8x16_t)vzip2q_s32((int32x4_t)v41, vuzp1q_s32((int32x4_t)v41, v47));
          int8x16_t v58 = (int8x16_t)vzip2q_s32((int32x4_t)v40, vuzp1q_s32((int32x4_t)v40, v45));
          int8x16_t v59 = (int8x16_t)vzip2q_s32((int32x4_t)v39, vuzp1q_s32((int32x4_t)v39, v43));
          int32x4_t v60 = vtrn1q_s32(vzip1q_s32((int32x4_t)v42, v50), v50);
          int32x4_t v61 = vtrn1q_s32(vzip1q_s32((int32x4_t)v41, v48), v48);
          int32x4_t v62 = vtrn1q_s32(vzip1q_s32((int32x4_t)v40, v46), v46);
          int8x16_t v63 = vextq_s8((int8x16_t)vzip2q_s32(v55, (int32x4_t)v59), v59, 4uLL);
          v63.i32[3] = v21.i32[3];
          int8x16_t v64 = vextq_s8((int8x16_t)vzip2q_s32(v54, (int32x4_t)v58), v58, 4uLL);
          v64.i32[3] = v23.i32[3];
          int8x16_t v65 = vextq_s8((int8x16_t)vzip2q_s32(v53, (int32x4_t)v57), v57, 4uLL);
          v65.i32[3] = v25.i32[3];
          int8x16_t v66 = vextq_s8((int8x16_t)vzip2q_s32(v52, (int32x4_t)v56), v56, 4uLL);
          v66.i32[3] = v27.i32[3];
          int32x4_t v67 = vzip2q_s32((int32x4_t)vextq_s8(v59, v59, 8uLL), v55);
          v67.i32[3] = HIDWORD(v19[1].i64[0]);
          int32x4_t v68 = vzip2q_s32((int32x4_t)vextq_s8(v58, v58, 8uLL), v54);
          v68.i32[3] = HIDWORD(v19[3].i64[0]);
          int32x4_t v69 = vzip2q_s32((int32x4_t)vextq_s8(v57, v57, 8uLL), v53);
          v69.i32[3] = HIDWORD(v19[5].i64[0]);
          int32x4_t v70 = vzip2q_s32((int32x4_t)vextq_s8(v56, v56, 8uLL), v52);
          v70.i32[3] = HIDWORD(v19[7].i64[0]);
          int32x4_t v71 = vtrn1q_s32(vzip1q_s32((int32x4_t)v39, v44), v44);
          int32x4_t v72 = vzip2q_s32(v71, vuzp2q_s32(v71, v55));
          v72.i32[3] = HIDWORD(*(unsigned long long *)v19);
          int32x4_t v73 = vzip2q_s32(v62, vuzp2q_s32(v62, v54));
          v73.i32[3] = v22.i32[3];
          int32x4_t v74 = vzip2q_s32(v61, vuzp2q_s32(v61, v53));
          v74.i32[3] = v24.i32[3];
          int32x4_t v75 = vzip2q_s32(v60, vuzp2q_s32(v60, v52));
          v75.i32[3] = v26.i32[3];
          int32x4_t v76 = vzip1q_s32(v71, v55);
          v76.i32[3] = HIDWORD(v19->i64[0]);
          int32x4_t v77 = vzip1q_s32(v62, v54);
          v77.i32[3] = HIDWORD(v19[2].i64[0]);
          int32x4_t v78 = vzip1q_s32(v61, v53);
          v78.i32[3] = HIDWORD(v19[4].i64[0]);
          int32x4_t v79 = vzip1q_s32(v60, v52);
          v79.i32[3] = HIDWORD(v19[6].i64[0]);
          v17[14] = v70;
          v17[15] = (int32x4_t)v66;
          v17[12] = v79;
          v17[13] = v75;
          v17[10] = v69;
          v17[11] = (int32x4_t)v65;
          v17[8] = v78;
          v17[9] = v74;
          v17[6] = v68;
          v17[7] = (int32x4_t)v64;
          v17[4] = v77;
          void v17[5] = v73;
          v19 += 8;
          v18 += 128;
          v17[2] = v67;
          v17[3] = (int32x4_t)v63;
          *unint64_t v17 = v76;
          v17[1] = v72;
          v17 += 16;
          v20 -= 16;
        }
        while (v20 > 0xF);
      }
      if (v20 >= 4)
      {
        do
        {
          float32x4_t v81 = *v19;
          float32x4_t v80 = v19[1];
          v19 += 2;
          float32x4_t v83 = *(float32x4_t *)v18;
          float32x4_t v82 = *(float32x4_t *)(v18 + 16);
          v18 += 32;
          float32x4_t v84 = (float32x4_t)vuzp1q_s32((int32x4_t)v81, (int32x4_t)v80);
          float32x4_t v85 = vmlaq_f32(v84, (float32x4_t)vuzp2q_s32((int32x4_t)v83, (int32x4_t)v82), v84);
          int32x4_t v86 = (int32x4_t)vmlaq_f32(v80, v82, v80);
          int32x4_t v87 = (int32x4_t)vmlaq_f32(v81, v83, v81);
          float32x2_t v88 = *(float32x2_t *)a7;
          v88.i32[0] = *(_DWORD *)(a7 + 8);
          int32x4_t v89 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v84, v85, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v87, v86), v88, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
          int8x16_t v90 = (int8x16_t)vzip2q_s32((int32x4_t)v85, vuzp1q_s32((int32x4_t)v85, v86));
          int32x4_t v91 = vzip1q_s32((int32x4_t)v85, v87);
          int8x16_t v92 = vextq_s8((int8x16_t)vzip2q_s32(v89, (int32x4_t)v90), v90, 4uLL);
          v92.i32[3] = v80.i32[3];
          int32x4_t v93 = vtrn1q_s32(v91, v87);
          int32x4_t v94 = vzip2q_s32((int32x4_t)vextq_s8(v90, v90, 8uLL), v89);
          v94.i32[3] = v80.i32[1];
          int32x4_t v95 = vzip2q_s32(v93, vuzp2q_s32(v93, v89));
          v95.i32[3] = v81.i32[3];
          int32x4_t v96 = vzip1q_s32(v93, v89);
          v96.i32[3] = v81.i32[1];
          v17[2] = v94;
          v17[3] = (int32x4_t)v92;
          *unint64_t v17 = v96;
          v17[1] = v95;
          v17 += 4;
          v20 -= 4;
        }
        while (v20 > 3);
      }
      if (v20)
      {
        int32x4_t __dst = 0u;
        int32x4_t v120 = 0u;
        int32x4_t v117 = 0u;
        int32x4_t v118 = 0u;
        int32x4_t v115 = 0u;
        int8x16_t v116 = 0u;
        int32x4_t __src = 0u;
        int32x4_t v114 = 0u;
        memcpy(&__dst, v19, 4 * v20);
        memcpy(&v117, (const void *)v18, 8 * v20);
        float32x4_t v97 = (float32x4_t)vuzp1q_s32(__dst, v120);
        float32x4_t v98 = vmlaq_f32(v97, (float32x4_t)vuzp2q_s32(v117, v118), v97);
        int32x4_t v99 = (int32x4_t)vmlaq_f32((float32x4_t)v120, (float32x4_t)v118, (float32x4_t)v120);
        int32x4_t v100 = (int32x4_t)vmlaq_f32((float32x4_t)__dst, (float32x4_t)v117, (float32x4_t)__dst);
        float32x2_t v101 = *(float32x2_t *)a7;
        v101.i32[0] = *(_DWORD *)(a7 + 8);
        int32x4_t v102 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v97, v98, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v100, v99), v101, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
        int8x16_t v103 = (int8x16_t)vzip2q_s32((int32x4_t)v98, vuzp1q_s32((int32x4_t)v98, v99));
        int32x4_t v104 = vzip1q_s32((int32x4_t)v98, v100);
        int8x16_t v105 = vextq_s8((int8x16_t)vzip2q_s32(v102, (int32x4_t)v103), v103, 4uLL);
        v105.i32[3] = v120.i32[3];
        int32x4_t v106 = vtrn1q_s32(v104, v100);
        int32x4_t v107 = vzip2q_s32((int32x4_t)vextq_s8(v103, v103, 8uLL), v102);
        v107.i32[3] = v120.i32[1];
        int32x4_t v108 = vzip2q_s32(v106, vuzp2q_s32(v106, v102));
        v108.i32[3] = __dst.i32[3];
        int32x4_t v109 = vzip1q_s32(v106, v102);
        v109.i32[3] = __dst.i32[1];
        int32x4_t v115 = v107;
        int8x16_t v116 = v105;
        int32x4_t __src = v109;
        int32x4_t v114 = v108;
        uint64_t result = (char *)memcpy(v17, &__src, 16 * v20);
      }
      a5 = (int32x4_t *)((char *)a5 + a6);
      unsigned int v14 = (float32x4_t *)((char *)v14 + a2);
      if (v16 + 1 < a10)
      {
        ++v16;
      }
      else
      {
        a3 += a4;
        int v16 = 0;
      }
      ++v15;
    }
    while (v15 != a9);
  }
  return result;
}

char *YCCAtoRGBA<float,2u>(char *result, uint64_t a2, int64x2_t *a3, uint64_t a4, int32x4_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, int a9, unsigned int a10)
{
  if (a9)
  {
    unsigned int v14 = (float32x4_t *)result;
    uint64_t v15 = 0;
    int v16 = 0;
    do
    {
      unint64_t v17 = a5;
      uint64_t v18 = a3;
      uint64_t v19 = v14;
      unsigned int v20 = a8;
      if (a8 >= 0x10)
      {
        do
        {
          float32x4_t v21 = v19[2];
          float32x4_t v22 = v19[3];
          int64x2_t v23 = v18[1];
          float32x4_t v24 = (float32x4_t)vdupq_laneq_s64(*v18, 1);
          float32x4_t v25 = (float32x4_t)vdupq_lane_s64(v18->i64[0], 0);
          float32x4_t v26 = v19[4];
          float32x4_t v27 = v19[5];
          float32x4_t v28 = (float32x4_t)vdupq_laneq_s64(v23, 1);
          float32x4_t v29 = (float32x4_t)vdupq_lane_s64(v23.i64[0], 0);
          int64x2_t v30 = v18[2];
          int64x2_t v31 = v18[3];
          float32x4_t v32 = (float32x4_t)vdupq_laneq_s64(v30, 1);
          float32x4_t v33 = (float32x4_t)vdupq_lane_s64(v30.i64[0], 0);
          float32x4_t v34 = v19[6];
          float32x4_t v35 = v19[7];
          float32x4_t v36 = (float32x4_t)vdupq_laneq_s64(v31, 1);
          float32x4_t v37 = (float32x4_t)vdupq_lane_s64(v31.i64[0], 0);
          float32x4_t v38 = (float32x4_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v35);
          float32x4_t v39 = (float32x4_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v27);
          float32x4_t v40 = (float32x4_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v22);
          float32x4_t v41 = v19[1];
          float32x4_t v42 = (float32x4_t)vuzp1q_s32(*(int32x4_t *)v19, (int32x4_t)v41);
          float32x4_t v43 = vmlaq_f32(v42, (float32x4_t)vuzp2q_s32((int32x4_t)v25, (int32x4_t)v24), v42);
          int32x4_t v44 = (int32x4_t)vmlaq_f32(v41, v24, v41);
          int32x4_t v45 = (int32x4_t)vmlaq_f32(*v19, v25, *v19);
          float32x4_t v46 = vmlaq_f32(v40, (float32x4_t)vuzp2q_s32((int32x4_t)v29, (int32x4_t)v28), v40);
          int32x4_t v47 = (int32x4_t)vmlaq_f32(v22, v28, v22);
          int32x4_t v48 = (int32x4_t)vmlaq_f32(v21, v29, v21);
          float32x4_t v49 = vmlaq_f32(v39, (float32x4_t)vuzp2q_s32((int32x4_t)v33, (int32x4_t)v32), v39);
          int32x4_t v50 = (int32x4_t)vmlaq_f32(v27, v32, v27);
          int32x4_t v51 = (int32x4_t)vmlaq_f32(v26, v33, v26);
          float32x4_t v52 = vmlaq_f32(v38, (float32x4_t)vuzp2q_s32((int32x4_t)v37, (int32x4_t)v36), v38);
          int32x4_t v53 = (int32x4_t)vmlaq_f32(v35, v36, v35);
          int32x4_t v54 = (int32x4_t)vmlaq_f32(v34, v37, v34);
          float32x2_t v55 = *(float32x2_t *)a7;
          v55.i32[0] = *(_DWORD *)(a7 + 8);
          v37.i64[0] = *(void *)(a7 + 4);
          int32x4_t v56 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v38, v52, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v54, v53), v55, 0), v37.f32[0]);
          int8x16_t v57 = (int8x16_t)vzip2q_s32((int32x4_t)v52, vuzp1q_s32((int32x4_t)v52, v53));
          int8x16_t v58 = (int8x16_t)vzip2q_s32((int32x4_t)v49, vuzp1q_s32((int32x4_t)v49, v50));
          int32x4_t v59 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v39, v49, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v51, v50), v55, 0), v37.f32[0]);
          int8x16_t v60 = (int8x16_t)vzip2q_s32((int32x4_t)v46, vuzp1q_s32((int32x4_t)v46, v47));
          int8x16_t v61 = (int8x16_t)vzip2q_s32((int32x4_t)v43, vuzp1q_s32((int32x4_t)v43, v44));
          int32x4_t v62 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v40, v46, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v48, v47), v55, 0), v37.f32[0]);
          int32x4_t v63 = vtrn1q_s32(vzip1q_s32((int32x4_t)v52, v54), v54);
          int32x4_t v64 = vtrn1q_s32(vzip1q_s32((int32x4_t)v49, v51), v51);
          int32x4_t v65 = vtrn1q_s32(vzip1q_s32((int32x4_t)v46, v48), v48);
          int32x4_t v66 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v42, v43, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v45, v44), v55, 0), v37.f32[0]);
          int8x16_t v67 = vextq_s8((int8x16_t)vzip2q_s32(v66, (int32x4_t)v61), v61, 4uLL);
          int32x4_t v68 = vzip2q_s32((int32x4_t)vextq_s8(v61, v61, 8uLL), v66);
          int8x16_t v69 = vextq_s8((int8x16_t)vzip2q_s32(v62, (int32x4_t)v60), v60, 4uLL);
          v68.i32[3] = HIDWORD(v19[1].i64[0]);
          int32x4_t v70 = vzip2q_s32((int32x4_t)vextq_s8(v60, v60, 8uLL), v62);
          v70.i32[3] = HIDWORD(v19[3].i64[0]);
          int32x4_t v71 = vzip2q_s32((int32x4_t)vextq_s8(v58, v58, 8uLL), v59);
          v71.i32[3] = HIDWORD(v19[5].i64[0]);
          v67.i32[3] = v41.i32[3];
          int32x4_t v72 = vzip2q_s32((int32x4_t)vextq_s8(v57, v57, 8uLL), v56);
          v72.i32[3] = HIDWORD(v19[7].i64[0]);
          v69.i32[3] = v22.i32[3];
          int32x4_t v73 = vtrn1q_s32(vzip1q_s32((int32x4_t)v43, v45), v45);
          int8x16_t v74 = vextq_s8((int8x16_t)vzip2q_s32(v59, (int32x4_t)v58), v58, 4uLL);
          v74.i32[3] = v27.i32[3];
          int8x16_t v75 = vextq_s8((int8x16_t)vzip2q_s32(v56, (int32x4_t)v57), v57, 4uLL);
          int32x4_t v76 = vzip2q_s32(v73, vuzp2q_s32(v73, v66));
          v75.i32[3] = v35.i32[3];
          int32x4_t v77 = vzip2q_s32(v65, vuzp2q_s32(v65, v62));
          int32x4_t v78 = vzip2q_s32(v64, vuzp2q_s32(v64, v59));
          v76.i32[3] = HIDWORD(*(unsigned long long *)v19);
          int32x4_t v79 = vzip1q_s32(v73, v66);
          v79.i32[3] = HIDWORD(v19->i64[0]);
          int32x4_t v80 = vzip1q_s32(v65, v62);
          v77.i32[3] = v21.i32[3];
          v80.i32[3] = HIDWORD(v19[2].i64[0]);
          int32x4_t v81 = vzip2q_s32(v63, vuzp2q_s32(v63, v56));
          v78.i32[3] = v26.i32[3];
          int32x4_t v82 = vzip1q_s32(v64, v59);
          v82.i32[3] = HIDWORD(v19[4].i64[0]);
          int32x4_t v83 = vzip1q_s32(v63, v56);
          v81.i32[3] = v34.i32[3];
          v83.i32[3] = HIDWORD(v19[6].i64[0]);
          v17[14] = v72;
          v17[15] = (int32x4_t)v75;
          v17[12] = v83;
          v17[13] = v81;
          v17[10] = v71;
          v17[11] = (int32x4_t)v74;
          v17[8] = v82;
          v17[9] = v78;
          v17[6] = v70;
          v17[7] = (int32x4_t)v69;
          v17[4] = v80;
          void v17[5] = v77;
          v19 += 8;
          v18 += 4;
          v17[2] = v68;
          v17[3] = (int32x4_t)v67;
          *unint64_t v17 = v79;
          v17[1] = v76;
          v17 += 16;
          v20 -= 16;
        }
        while (v20 > 0xF);
      }
      if (v20 >= 4)
      {
        do
        {
          int64x2_t v84 = *v18++;
          float32x4_t v86 = *v19;
          float32x4_t v85 = v19[1];
          v19 += 2;
          float32x4_t v87 = (float32x4_t)vdupq_laneq_s64(v84, 1);
          float32x4_t v88 = (float32x4_t)vdupq_lane_s64(v84.i64[0], 0);
          float32x4_t v89 = (float32x4_t)vuzp1q_s32((int32x4_t)v86, (int32x4_t)v85);
          int32x4_t v90 = (int32x4_t)vmlaq_f32(v85, v87, v85);
          float32x4_t v91 = vmlaq_f32(v89, (float32x4_t)vuzp2q_s32((int32x4_t)v88, (int32x4_t)v87), v89);
          int32x4_t v92 = (int32x4_t)vmlaq_f32(v86, v88, v86);
          float32x2_t v93 = *(float32x2_t *)a7;
          v93.i32[0] = *(_DWORD *)(a7 + 8);
          float32x4_t v94 = vmlsq_lane_f32(vmlsq_lane_f32(v89, v91, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v92, v90), v93, 0);
          int8x16_t v95 = (int8x16_t)vzip2q_s32((int32x4_t)v91, vuzp1q_s32((int32x4_t)v91, v90));
          int32x4_t v96 = vtrn1q_s32(vzip1q_s32((int32x4_t)v91, v92), v92);
          int32x4_t v97 = (int32x4_t)vmulq_n_f32(v94, COERCE_FLOAT(*(void *)(a7 + 4)));
          int8x16_t v98 = vextq_s8((int8x16_t)vzip2q_s32(v97, (int32x4_t)v95), v95, 4uLL);
          int32x4_t v99 = vzip2q_s32((int32x4_t)vextq_s8(v95, v95, 8uLL), v97);
          v98.i32[3] = v85.i32[3];
          v99.i32[3] = v85.i32[1];
          int32x4_t v100 = vzip2q_s32(v96, vuzp2q_s32(v96, v97));
          v100.i32[3] = v86.i32[3];
          int32x4_t v101 = vzip1q_s32(v96, v97);
          v101.i32[3] = v86.i32[1];
          v17[2] = v99;
          v17[3] = (int32x4_t)v98;
          *unint64_t v17 = v101;
          v17[1] = v100;
          v17 += 4;
          v20 -= 4;
        }
        while (v20 > 3);
      }
      if (v20)
      {
        int32x4_t __dst = 0u;
        int32x4_t v126 = 0u;
        int64x2_t v124 = 0uLL;
        int32x4_t v122 = 0u;
        int8x16_t v123 = 0u;
        int32x4_t __src = 0u;
        int32x4_t v121 = 0u;
        memcpy(&__dst, v19, 4 * v20);
        memcpy(&v124, v18, (4 * (_BYTE)v20 + 4) & 0x18);
        float32x4_t v102 = (float32x4_t)vdupq_laneq_s64(v124, 1);
        float32x4_t v103 = (float32x4_t)vdupq_lane_s64(v124.i64[0], 0);
        float32x4_t v104 = (float32x4_t)vuzp1q_s32(__dst, v126);
        float32x4_t v105 = vmlaq_f32(v104, (float32x4_t)vuzp2q_s32((int32x4_t)v103, (int32x4_t)v102), v104);
        int32x4_t v106 = (int32x4_t)vmlaq_f32((float32x4_t)v126, v102, (float32x4_t)v126);
        int32x4_t v107 = (int32x4_t)vmlaq_f32((float32x4_t)__dst, v103, (float32x4_t)__dst);
        float32x2_t v108 = *(float32x2_t *)a7;
        v108.i32[0] = *(_DWORD *)(a7 + 8);
        int32x4_t v109 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v104, v105, *(float32x2_t *)a7, 0), (float32x4_t)vuzp1q_s32(v107, v106), v108, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
        int8x16_t v110 = (int8x16_t)vzip2q_s32((int32x4_t)v105, vuzp1q_s32((int32x4_t)v105, v106));
        int32x4_t v111 = vzip1q_s32((int32x4_t)v105, v107);
        int8x16_t v112 = vextq_s8((int8x16_t)vzip2q_s32(v109, (int32x4_t)v110), v110, 4uLL);
        v112.i32[3] = v126.i32[3];
        int32x4_t v113 = vtrn1q_s32(v111, v107);
        int32x4_t v114 = vzip2q_s32((int32x4_t)vextq_s8(v110, v110, 8uLL), v109);
        v114.i32[3] = v126.i32[1];
        int32x4_t v115 = vzip2q_s32(v113, vuzp2q_s32(v113, v109));
        v115.i32[3] = __dst.i32[3];
        int32x4_t v116 = vzip1q_s32(v113, v109);
        v116.i32[3] = __dst.i32[1];
        int32x4_t v122 = v114;
        int8x16_t v123 = v112;
        int32x4_t __src = v116;
        int32x4_t v121 = v115;
        uint64_t result = (char *)memcpy(v17, &__src, 16 * v20);
      }
      a5 = (int32x4_t *)((char *)a5 + a6);
      unsigned int v14 = (float32x4_t *)((char *)v14 + a2);
      if (v16 + 1 < a10)
      {
        ++v16;
      }
      else
      {
        a3 = (int64x2_t *)((char *)a3 + a4);
        int v16 = 0;
      }
      ++v15;
    }
    while (v15 != a9);
  }
  return result;
}

void YCCtoRGBA<half,1u>(float16x8_t *a1, uint64_t a2, const __int16 *a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, unsigned int a8, double _D0, int a10, unsigned int a11)
{
  __asm { FCVT            H0, D0 }
  v49[0] = _H0;
  if (a10)
  {
    uint64_t v21 = 0;
    int v22 = 0;
    v23.i64[0] = 0x706050415140100;
    do
    {
      int32x4_t v47 = a3;
      int32x4_t v48 = a1;
      unsigned int v24 = a8;
      float32x4_t v46 = a5;
      if (a8 >= 0x10)
      {
        do
        {
          v23.i64[0] = _YCCtoRGBA<half,1u,16>(&v48, &v47, (uint64_t *)&v46, a7, v49).u64[0];
          v24 -= 16;
        }
        while (v24 > 0xF);
      }
      if (v24 >= 4)
      {
        float32x4_t v25 = v49;
        int16x4x2_t v26 = (int16x4x2_t)vld1q_dup_s16(v25);
        float32x4_t v27 = (float16x8_t *)&v48->u64[1];
        float32x4_t v28 = v47 + 8;
        float32x4_t v29 = (int8x16_t *)(v46 + 32);
        do
        {
          int64x2_t v30 = v28 - 8;
          int32x4_t v48 = v27;
          float32x4_t v51 = (float32x4_t)vld2_s16(v30);
          float32x4_t v31 = vcvtq_f32_f16((float16x4_t)v27[-1].u64[1]);
          *(float32x4_t *)((char *)&v51 + 8) = vmlaq_f32(v31, vcvtq_f32_f16(*(float16x4_t *)&v51.u32[2]), v31);
          float32x4_t v51 = vmlaq_f32(v31, vcvtq_f32_f16(*(float16x4_t *)v51.f32), v31);
          float32x2_t v32 = *(float32x2_t *)a7;
          v32.i32[0] = *(_DWORD *)(a7 + 8);
          *(float16x4_t *)v53.val[1].i8 = vcvt_f16_f32(vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v31, *(float32x4_t *)((char *)&v51 + 8), *(float32x2_t *)a7, 0), v51, v32, 0), COERCE_FLOAT(*(void *)(a7 + 4))));
          *(float16x4_t *)v31.f32 = vcvt_f16_f32(v51);
          v31.i64[1] = v23.i64[0];
          v53.val[1].i64[1] = v23.i64[0];
          *(float16x4_t *)v51.f32 = vcvt_f16_f32(*(float32x4_t *)((char *)&v51 + 8));
          uint64_t v33 = v23.i64[0];
          v53.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v51, (int16x8_t)v31);
          int8x16_t v23 = vqtbl2q_s8(v53, (int8x16_t)xmmword_228F41C60);
          float32x4_t v46 = (char *)v29;
          int32x4_t v47 = v28;
          float32x4_t v51 = (float32x4_t)vqtbl2q_s8(v53, (int8x16_t)xmmword_228F41C40);
          *(int16x4x2_t *)((char *)&v51 + 8) = v26;
          v24 -= 4;
          v29[-2] = vqtbl2q_s8(*(int8x16x2_t *)v23.i8, (int8x16_t)xmmword_228F41C70);
          v29[-1] = vqtbl2q_s8(*(int8x16x2_t *)v51.f32, (int8x16_t)xmmword_228F41C50);
          float32x4_t v27 = (float16x8_t *)((char *)v27 + 8);
          v28 += 8;
          v29 += 2;
        }
        while (v24 > 3);
      }
      if (v24)
      {
        float16x4_t __dst = 0;
        long long v44 = 0u;
        memcpy(&__dst, v48, 2 * v24);
        memcpy(&v44, v47, 4 * v24);
        float32x4_t v34 = (const __int16 *)&v44;
        float32x4_t v50 = (float32x4_t)vld2_s16(v34);
        float32x4_t v35 = vcvtq_f32_f16(__dst);
        *(float32x4_t *)((char *)&v50 + 8) = vmlaq_f32(v35, vcvtq_f32_f16(*(float16x4_t *)&v50.u32[2]), v35);
        float32x4_t v50 = vmlaq_f32(v35, vcvtq_f32_f16(*(float16x4_t *)v50.f32), v35);
        float32x2_t v36 = *(float32x2_t *)a7;
        v36.i32[0] = *(_DWORD *)(a7 + 8);
        *(float16x4_t *)v52.val[1].i8 = vcvt_f16_f32(vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v35, *(float32x4_t *)((char *)&v50 + 8), *(float32x2_t *)a7, 0), v50, v36, 0), COERCE_FLOAT(*(void *)(a7 + 4))));
        *(float16x4_t *)v35.f32 = vcvt_f16_f32(v50);
        v52.val[1].i64[1] = v35.i64[0];
        float32x4_t v37 = v49;
        v54.val[1] = (int8x16_t)vld1q_dup_s16(v37);
        v35.i64[1] = v35.i64[0];
        *(float16x4_t *)v50.f32 = vcvt_f16_f32(*(float32x4_t *)((char *)&v50 + 8));
        uint64_t v38 = v35.i64[0];
        v54.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v50, (int16x8_t)v35);
        v52.val[0] = vqtbl2q_s8(v54, (int8x16_t)xmmword_228F62B50);
        int8x16_t v39 = vqtbl2q_s8(v52, (int8x16_t)xmmword_228F62B60);
        v52.val[0] = vqtbl2q_s8(v54, (int8x16_t)xmmword_228F62B70);
        __src[0] = v39;
        __src[1] = vqtbl2q_s8(v52, (int8x16_t)xmmword_228F62B80);
        memcpy(v46, __src, 8 * v24);
      }
      a5 += a6;
      a1 = (float16x8_t *)((char *)a1 + a2);
      if (v22 + 1 < a11)
      {
        ++v22;
      }
      else
      {
        a3 = (const __int16 *)((char *)a3 + a4);
        int v22 = 0;
      }
      ++v21;
    }
    while (v21 != a10);
  }
}

void YCCtoRGBA<half,2u>(float16x8_t *a1, uint64_t a2, int32x4_t *a3, uint64_t a4, int8x16_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, double _D0, double a10, double a11, int32x4_t a12, int a13, unsigned int a14)
{
  __asm { FCVT            H0, D0 }
  v59[0] = _H0;
  if (a13)
  {
    uint64_t v24 = 0;
    int v25 = 0;
    v26.i64[0] = 0x706050415140100;
    do
    {
      int8x16_t v57 = a3;
      int8x16_t v58 = a1;
      unsigned int v27 = a8;
      int32x4_t v56 = a5;
      if (a8 >= 0x10)
      {
        do
        {
          v26.i64[0] = _YCCtoRGBA<half,2u,16>(&v58, &v57, &v56, a7, v59).u64[0];
          v27 -= 16;
        }
        while (v27 > 0xF);
      }
      if (v27 >= 4)
      {
        float32x4_t v28 = v57;
        float32x4_t v29 = v59;
        int16x8_t v30 = vld1q_dup_s16(v29);
        float32x4_t v31 = (float16x8_t *)&v58->u64[1];
        float32x2_t v32 = v56 + 2;
        do
        {
          int8x16_t v58 = v31;
          unint64_t v33 = v28->i64[0];
          float32x4_t v28 = (int32x4_t *)((char *)v28 + 8);
          a12.i64[0] = v33;
          int8x16_t v34 = (int8x16_t)vzip1q_s32(a12, a12);
          float32x4_t v35 = vcvtq_f32_f16((float16x4_t)v31[-1].u64[1]);
          int16x4_t v36 = (int16x4_t)vextq_s8(v34, v34, 8uLL).u64[0];
          v61.val[1] = (int8x16_t)vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v34.i8, v36));
          float32x4_t v37 = vmlaq_f32(v35, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v34.i8, v36)), v35);
          float32x4_t v38 = vmlaq_f32(v35, (float32x4_t)v61.val[1], v35);
          v34.i64[0] = *(void *)a7;
          v34.i32[0] = *(_DWORD *)(a7 + 8);
          float32x4_t v39 = vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v35, v37, *(float32x2_t *)a7, 0), v38, *(float32x2_t *)v34.i8, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
          *(float16x4_t *)v34.i8 = vcvt_f16_f32(v37);
          *(float16x4_t *)v61.val[1].i8 = vcvt_f16_f32(v39);
          *(float16x4_t *)v39.f32 = vcvt_f16_f32(v38);
          v61.val[1].i64[1] = v26.i64[0];
          v39.i64[1] = v26.i64[0];
          v34.i64[1] = v26.i64[0];
          v61.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v34, (int16x8_t)v39);
          int32x4_t v56 = v32;
          int8x16_t v57 = v28;
          int8x16_t v26 = vqtbl2q_s8(v61, (int8x16_t)xmmword_228F41C60);
          int8x16_t v40 = vqtbl2q_s8(v61, (int8x16_t)xmmword_228F41C40);
          v61.val[0] = (int8x16_t)v30;
          a12 = (int32x4_t)vqtbl2q_s8(v61, (int8x16_t)xmmword_228F41C50);
          v32[-2] = vqtbl2q_s8(*(int8x16x2_t *)v26.i8, (int8x16_t)xmmword_228F41C70);
          v32[-1] = (int8x16_t)a12;
          v27 -= 4;
          float32x4_t v31 = (float16x8_t *)((char *)v31 + 8);
          v32 += 2;
        }
        while (v27 > 3);
      }
      if (v27)
      {
        uint64_t v54 = 0;
        float16x4_t __dst = 0;
        memcpy(&__dst, v58, 2 * v27);
        memcpy(&v54, v57, (2 * (_BYTE)v27 + 2) & 0xC);
        v41.i64[0] = v54;
        int8x16_t v42 = (int8x16_t)vzip1q_s32(v41, v41);
        float32x4_t v43 = vcvtq_f32_f16(__dst);
        int16x4_t v44 = (int16x4_t)vextq_s8(v42, v42, 8uLL).u64[0];
        float32x4_t v45 = vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v42.i8, v44));
        float32x4_t v46 = vmlaq_f32(v43, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v42.i8, v44)), v43);
        float32x4_t v47 = vmlaq_f32(v43, v45, v43);
        v45.i64[0] = *(void *)a7;
        v45.i32[0] = *(_DWORD *)(a7 + 8);
        *(float16x4_t *)v60.val[1].i8 = vcvt_f16_f32(vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v43, v46, *(float32x2_t *)a7, 0), v47, *(float32x2_t *)v45.f32, 0), COERCE_FLOAT(*(void *)(a7 + 4))));
        *(float16x4_t *)v43.f32 = vcvt_f16_f32(v47);
        v60.val[1].i64[1] = v43.i64[0];
        int32x4_t v48 = v59;
        v62.val[1] = (int8x16_t)vld1q_dup_s16(v48);
        v43.i64[1] = v43.i64[0];
        *(float16x4_t *)v47.f32 = vcvt_f16_f32(v46);
        v47.i64[1] = v43.i64[0];
        v62.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v47, (int16x8_t)v43);
        v60.val[0] = vqtbl2q_s8(v62, (int8x16_t)xmmword_228F62B50);
        int8x16_t v49 = vqtbl2q_s8(v60, (int8x16_t)xmmword_228F62B60);
        v60.val[0] = vqtbl2q_s8(v62, (int8x16_t)xmmword_228F62B70);
        __src[0] = v49;
        __src[1] = vqtbl2q_s8(v60, (int8x16_t)xmmword_228F62B80);
        memcpy(v56, __src, 8 * v27);
      }
      a5 = (int8x16_t *)((char *)a5 + a6);
      a1 = (float16x8_t *)((char *)a1 + a2);
      if (v25 + 1 < a14)
      {
        ++v25;
      }
      else
      {
        a3 = (int32x4_t *)((char *)a3 + a4);
        int v25 = 0;
      }
      ++v24;
    }
    while (v24 != a13);
  }
}

float32x4_t *YCCtoRGBA<float,1u>(float32x4_t *result, uint64_t a2, const float *a3, uint64_t a4, int32x4_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, double a9, int a10, unsigned int a11)
{
  if (a10)
  {
    int v16 = result;
    uint64_t v17 = 0;
    int v18 = 0;
    *(float *)&a9 = a9;
    int32x4_t v19 = vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    int32x4_t v67 = v19;
    do
    {
      unsigned int v20 = a5;
      uint64_t v21 = a3;
      int v22 = v16;
      unsigned int v23 = a8;
      if (a8 >= 0x10)
      {
        do
        {
          float32x4_t v24 = v22[2];
          float32x4_t v25 = v22[3];
          float32x4_t v27 = *v22;
          float32x4_t v26 = v22[1];
          v22 += 4;
          float32x4_t v28 = v21;
          float32x4x2_t v75 = vld2q_f32(v28);
          v28 += 8;
          float32x4_t v29 = v21 + 16;
          float32x4x2_t v76 = vld2q_f32(v29);
          int16x8_t v30 = v21 + 24;
          float32x4x2_t v77 = vld2q_f32(v30);
          float32x4x2_t v78 = vld2q_f32(v28);
          v21 += 32;
          float32x4_t v31 = vmlaq_f32(v24, v76.val[1], v24);
          float32x4_t v32 = vmlaq_f32(v26, v78.val[1], v26);
          float32x4_t v33 = vmlaq_f32(v25, v77.val[1], v25);
          float32x4_t v34 = vmlaq_f32(v27, v75.val[1], v27);
          float32x4_t v35 = vmlaq_f32(v27, v75.val[0], v27);
          float32x4_t v36 = vmlaq_f32(v25, v77.val[0], v25);
          v77.val[1] = vmlaq_f32(v24, v76.val[0], v24);
          v76.val[1] = vmlaq_f32(v26, v78.val[0], v26);
          v11.i32[0] = *(_DWORD *)(a7 + 8);
          uint64_t v37 = *(void *)(a7 + 4);
          int32x4_t v38 = vuzp2q_s32((int32x4_t)v34, (int32x4_t)v35);
          v75.val[0].i64[1] = __PAIR64__(v19.u32[2], v35.u32[2]);
          v75.val[0].i32[0] = v34.i32[2];
          v75.val[1] = (float32x4_t)vuzp2q_s32((int32x4_t)v33, (int32x4_t)v36);
          int32x4_t v39 = vuzp1q_s32((int32x4_t)v33, (int32x4_t)v36);
          v76.val[0].i64[1] = __PAIR64__(v19.u32[2], v36.u32[2]);
          v76.val[0].i32[0] = v33.i32[2];
          v78.val[1] = vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v27, v34, *(float32x2_t *)a7, 0), v35, *(float32x2_t *)v11.i8, 0), *(float *)&v37);
          int32x4_t v40 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v25, v33, *(float32x2_t *)a7, 0), v36, *(float32x2_t *)v11.i8, 0), *(float *)&v37);
          v78.val[0] = (float32x4_t)vtrn2q_s32((int32x4_t)v75.val[1], (int32x4_t)v33);
          int32x4_t v41 = vuzp2q_s32((int32x4_t)v31, (int32x4_t)v77.val[1]);
          int32x4_t v42 = vuzp1q_s32((int32x4_t)v31, (int32x4_t)v77.val[1]);
          int32x4_t v43 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v24, v31, *(float32x2_t *)a7, 0), v77.val[1], *(float32x2_t *)v11.i8, 0), *(float *)&v37);
          v77.val[1].i64[0] = __PAIR64__(v43.u32[2], v31.u32[2]);
          v77.val[0] = (float32x4_t)vtrn2q_s32(v41, (int32x4_t)v31);
          int32x4_t v44 = vuzp2q_s32((int32x4_t)v32, (int32x4_t)v76.val[1]);
          float32x4_t v45 = vmlsq_lane_f32(vmlsq_lane_f32(v26, v32, *(float32x2_t *)a7, 0), v76.val[1], *(float32x2_t *)v11.i8, 0);
          int32x4_t v46 = vuzp1q_s32((int32x4_t)v32, (int32x4_t)v76.val[1]);
          v27.i64[1] = __PAIR64__(v19.u32[2], v76.val[1].u32[2]);
          v27.i32[0] = v32.i32[2];
          v76.val[1] = (float32x4_t)vtrn2q_s32(v44, (int32x4_t)v32);
          int32x4_t v47 = (int32x4_t)vmulq_n_f32(v45, *(float *)&v37);
          v44.i32[1] = v47.i32[1];
          v41.i32[1] = v43.i32[1];
          v76.val[1].i32[1] = v47.i32[3];
          int32x4_t v48 = vtrn1q_s32(v46, v47);
          int32x4_t v49 = vtrn1q_s32(v42, v43);
          v41.i32[3] = v19.i32[1];
          v49.i32[3] = v19.i32[0];
          v77.val[0].i32[1] = v43.i32[3];
          v77.val[0].i32[3] = v19.i32[3];
          v75.val[1].i32[1] = v40.i32[1];
          v75.val[1].i32[3] = v19.i32[1];
          v48.i32[3] = v19.i32[0];
          int32x4_t v50 = vtrn2q_s32(v38, (int32x4_t)v34);
          int32x4_t v11 = vtrn1q_s32(v39, v40);
          v11.i32[3] = v19.i32[0];
          v27.i32[1] = v47.i32[2];
          v78.val[0].i32[1] = v40.i32[3];
          v78.val[0].i32[3] = v19.i32[3];
          v77.val[1].i32[3] = v19.i32[2];
          v76.val[0].i32[1] = v40.i32[2];
          v38.i32[1] = v78.val[1].i32[1];
          v38.i32[3] = v19.i32[1];
          int32x4_t v51 = vtrn1q_s32(vuzp1q_s32((int32x4_t)v34, (int32x4_t)v35), (int32x4_t)v78.val[1]);
          v44.i32[3] = v19.i32[1];
          v51.i32[3] = v19.i32[0];
          v50.i32[1] = v78.val[1].i32[3];
          v76.val[1].i32[3] = v19.i32[3];
          v50.i32[3] = v19.i32[3];
          v75.val[0].i32[1] = v78.val[1].i32[2];
          *unsigned int v20 = v51;
          v20[1] = v38;
          v20[2] = (int32x4_t)v75.val[0];
          v20[3] = v50;
          v20[14] = (int32x4_t)v76.val[0];
          v20[15] = (int32x4_t)v78.val[0];
          v20[12] = v11;
          v20[13] = (int32x4_t)v75.val[1];
          v20[10] = (int32x4_t)v77.val[1];
          v20[11] = (int32x4_t)v77.val[0];
          v20[8] = v49;
          v20[9] = v41;
          v20[4] = v48;
          v20[5] = v44;
          v20[6] = (int32x4_t)v27;
          v20[7] = (int32x4_t)v76.val[1];
          v20 += 16;
          v23 -= 16;
        }
        while (v23 > 0xF);
      }
      if (v23 >= 4)
      {
        do
        {
          float32x4_t v52 = *v22++;
          float32x4x2_t v73 = vld2q_f32(v21);
          v21 += 8;
          float32x4_t v53 = vmlaq_f32(v52, v73.val[1], v52);
          float32x4_t v54 = vmlaq_f32(v52, v73.val[0], v52);
          v73.val[0].i64[0] = *(void *)a7;
          v73.val[0].i32[0] = *(_DWORD *)(a7 + 8);
          float32x4_t v55 = vmlsq_lane_f32(vmlsq_lane_f32(v52, v53, *(float32x2_t *)a7, 0), v54, *(float32x2_t *)v73.val[0].f32, 0);
          v73.val[0] = (float32x4_t)vuzp2q_s32((int32x4_t)v53, (int32x4_t)v54);
          int32x4_t v56 = vuzp1q_s32((int32x4_t)v53, (int32x4_t)v54);
          v54.i32[0] = v53.i32[2];
          int32x4_t v57 = (int32x4_t)vmulq_n_f32(v55, COERCE_FLOAT(*(void *)(a7 + 4)));
          v73.val[1] = (float32x4_t)vtrn2q_s32((int32x4_t)v73.val[0], (int32x4_t)v53);
          int32x4_t v58 = vtrn1q_s32(v56, v57);
          v73.val[0].i32[1] = v57.i32[1];
          v73.val[0].i32[3] = v19.i32[1];
          v58.i32[3] = v19.i32[0];
          v54.i32[1] = v57.i32[2];
          v54.i32[3] = v19.i32[2];
          v73.val[1].i32[1] = v57.i32[3];
          v73.val[1].i32[3] = v19.i32[3];
          v20[2] = (int32x4_t)v54;
          v20[3] = (int32x4_t)v73.val[1];
          *unsigned int v20 = v58;
          v20[1] = (int32x4_t)v73.val[0];
          v20 += 4;
          v23 -= 4;
        }
        while (v23 > 3);
      }
      if (v23)
      {
        __dst[0] = 0uLL;
        memset(v71, 0, sizeof(v71));
        float32x4_t v69 = 0u;
        int32x4_t v70 = 0u;
        memset(&__src, 0, sizeof(__src));
        memcpy(__dst, v22, 4 * v23);
        memcpy(v71, v21, 8 * v23);
        int32x4_t v59 = (const float *)v71;
        float32x4x2_t v74 = vld2q_f32(v59);
        float32x4_t v60 = vmlaq_f32(__dst[0], v74.val[1], __dst[0]);
        float32x4_t v61 = vmlaq_f32(__dst[0], v74.val[0], __dst[0]);
        v74.val[0].i64[0] = *(void *)a7;
        v74.val[0].i32[0] = *(_DWORD *)(a7 + 8);
        int32x4_t v62 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(__dst[0], v60, *(float32x2_t *)a7, 0), v61, *(float32x2_t *)v74.val[0].f32, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
        v74.val[0] = (float32x4_t)vtrn1q_s32(vuzp1q_s32((int32x4_t)v60, (int32x4_t)v61), v62);
        v74.val[0].i32[3] = v67.i32[0];
        v74.val[1] = (float32x4_t)vuzp2q_s32((int32x4_t)v60, (int32x4_t)v61);
        int32x4_t v63 = vtrn2q_s32((int32x4_t)v74.val[1], (int32x4_t)v60);
        v74.val[1].i32[1] = v62.i32[1];
        v74.val[1].i32[3] = v67.i32[1];
        v61.i64[0] = __PAIR64__(v62.u32[2], v60.u32[2]);
        v61.i32[3] = v67.i32[2];
        v63.i32[1] = v62.i32[3];
        v63.i32[3] = v67.i32[3];
        float32x4_t v69 = v61;
        int32x4_t v70 = v63;
        float32x4x2_t __src = v74;
        uint64_t result = (float32x4_t *)memcpy(v20, &__src, 16 * v23);
        int32x4_t v19 = v67;
      }
      a5 = (int32x4_t *)((char *)a5 + a6);
      int v16 = (float32x4_t *)((char *)v16 + a2);
      if (v18 + 1 < a11)
      {
        ++v18;
      }
      else
      {
        a3 = (const float *)((char *)a3 + a4);
        int v18 = 0;
      }
      ++v17;
    }
    while (v17 != a10);
  }
  return result;
}

float32x4_t *YCCtoRGBA<float,2u>(float32x4_t *result, uint64_t a2, int64x2_t *a3, uint64_t a4, int32x4_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, double a9, int a10, unsigned int a11)
{
  if (a10)
  {
    uint64_t v15 = result;
    uint64_t v16 = 0;
    int v17 = 0;
    *(float *)&a9 = a9;
    int32x4_t v18 = vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    int32x4_t v99 = v18;
    do
    {
      int32x4_t v19 = a5;
      unsigned int v20 = a3;
      uint64_t v21 = v15;
      unsigned int v22 = a8;
      if (a8 >= 0x10)
      {
        do
        {
          int64x2_t v23 = v20[2];
          int64x2_t v24 = v20[3];
          int32x4_t v25 = (int32x4_t)vdupq_laneq_s64(v24, 1);
          float32x4_t v27 = v21[2];
          float32x4_t v26 = v21[3];
          int32x4_t v28 = (int32x4_t)vdupq_lane_s64(v24.i64[0], 0);
          int32x4_t v29 = (int32x4_t)vdupq_laneq_s64(v23, 1);
          int64x2_t v30 = *v20;
          int64x2_t v31 = v20[1];
          v20 += 4;
          int32x4_t v32 = (int32x4_t)vdupq_lane_s64(v23.i64[0], 0);
          int32x4_t v33 = (int32x4_t)vdupq_laneq_s64(v31, 1);
          float32x4_t v35 = *v21;
          float32x4_t v34 = v21[1];
          v21 += 4;
          int32x4_t v36 = (int32x4_t)vdupq_lane_s64(v31.i64[0], 0);
          int32x4_t v37 = (int32x4_t)vdupq_laneq_s64(v30, 1);
          int32x4_t v38 = (int32x4_t)vdupq_lane_s64(v30.i64[0], 0);
          float32x4_t v39 = (float32x4_t)vuzp1q_s32(v38, v37);
          float32x4_t v40 = (float32x4_t)vuzp1q_s32(v36, v33);
          float32x4_t v41 = (float32x4_t)vuzp1q_s32(v32, v29);
          float32x4_t v42 = (float32x4_t)vuzp1q_s32(v28, v25);
          float32x4_t v43 = (float32x4_t)vuzp2q_s32(v28, v25);
          int32x4_t v44 = (int32x4_t)vmlaq_f32(v35, (float32x4_t)vuzp2q_s32(v38, v37), v35);
          int32x4_t v45 = (int32x4_t)vmlaq_f32(v34, (float32x4_t)vuzp2q_s32(v36, v33), v34);
          int32x4_t v46 = (int32x4_t)vmlaq_f32(v27, (float32x4_t)vuzp2q_s32(v32, v29), v27);
          int32x4_t v47 = (int32x4_t)vmlaq_f32(v26, v43, v26);
          int32x4_t v48 = (int32x4_t)vmlaq_f32(v26, v42, v26);
          int32x4_t v49 = (int32x4_t)vmlaq_f32(v27, v41, v27);
          int32x4_t v50 = (int32x4_t)vmlaq_f32(v34, v40, v34);
          int32x4_t v51 = (int32x4_t)vmlaq_f32(v35, v39, v35);
          v39.i32[0] = *(_DWORD *)(a7 + 8);
          v42.i64[0] = *(void *)(a7 + 4);
          float32x4_t v52 = vmlsq_lane_f32(vmlsq_lane_f32(v35, (float32x4_t)v44, *(float32x2_t *)a7, 0), (float32x4_t)v51, *(float32x2_t *)v39.f32, 0);
          int32x4_t v53 = vuzp2q_s32(v47, v48);
          v38.i64[1] = __PAIR64__(v18.u32[2], v48.u32[2]);
          v38.i32[0] = v47.i32[2];
          float32x4_t v54 = vmlsq_lane_f32(vmlsq_lane_f32(v27, (float32x4_t)v46, *(float32x2_t *)a7, 0), (float32x4_t)v49, *(float32x2_t *)v39.f32, 0);
          int32x4_t v55 = vuzp2q_s32(v46, v49);
          int32x4_t v56 = vuzp1q_s32(v46, v49);
          v49.i32[0] = v46.i32[2];
          int32x4_t v57 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v26, (float32x4_t)v47, *(float32x2_t *)a7, 0), (float32x4_t)v48, *(float32x2_t *)v39.f32, 0), v42.f32[0]);
          int32x4_t v58 = (int32x4_t)vmulq_n_f32(v54, v42.f32[0]);
          int32x4_t v59 = vuzp2q_s32(v45, v50);
          int32x4_t v60 = vuzp1q_s32(v45, v50);
          int32x4_t v61 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(v34, (float32x4_t)v45, *(float32x2_t *)a7, 0), (float32x4_t)v50, *(float32x2_t *)v39.f32, 0), v42.f32[0]);
          v34.i64[1] = __PAIR64__(v18.u32[2], v50.u32[2]);
          v34.i64[0] = __PAIR64__(v61.u32[2], v45.u32[2]);
          int32x4_t v62 = vuzp2q_s32(v44, v51);
          int32x4_t v63 = vuzp1q_s32(v44, v51);
          int32x4_t v64 = (int32x4_t)vmulq_n_f32(v52, v42.f32[0]);
          v50.i64[1] = __PAIR64__(v18.u32[2], v51.u32[2]);
          v50.i64[0] = __PAIR64__(v64.u32[2], v44.u32[2]);
          int32x4_t v65 = vtrn2q_s32(v62, v44);
          v62.i32[1] = v64.i32[1];
          int32x4_t v66 = vtrn2q_s32(v59, v45);
          int32x4_t v67 = vtrn1q_s32(v63, v64);
          v65.i32[1] = v64.i32[3];
          v67.i32[3] = v18.i32[0];
          v59.i32[1] = v61.i32[1];
          v62.i32[3] = v18.i32[1];
          int32x4_t v68 = vtrn2q_s32(v53, v47);
          int32x4_t v69 = vtrn1q_s32(v60, v61);
          v69.i32[3] = v18.i32[0];
          v65.i32[3] = v18.i32[3];
          v66.i32[1] = v61.i32[3];
          v59.i32[3] = v18.i32[1];
          int32x4_t v70 = vtrn2q_s32(v55, v46);
          v55.i32[1] = v58.i32[1];
          int32x4_t v71 = vtrn1q_s32(v56, v58);
          v66.i32[3] = v18.i32[3];
          v71.i32[3] = v18.i32[0];
          v70.i32[1] = v58.i32[3];
          v55.i32[3] = v18.i32[1];
          v49.i32[1] = v58.i32[2];
          v53.i32[1] = v57.i32[1];
          v70.i32[3] = v18.i32[3];
          v53.i32[3] = v18.i32[1];
          int32x4_t v72 = vtrn1q_s32(vuzp1q_s32(v47, v48), v57);
          v72.i32[3] = v18.i32[0];
          v68.i32[1] = v57.i32[3];
          v68.i32[3] = v18.i32[3];
          v38.i32[1] = v57.i32[2];
          v49.i32[3] = v18.i32[2];
          v19[12] = v72;
          v19[13] = v53;
          v19[14] = v38;
          v19[15] = v68;
          v19[8] = v71;
          v19[9] = v55;
          v19[10] = v49;
          v19[11] = v70;
          v19[6] = (int32x4_t)v34;
          v19[7] = v66;
          v19[4] = v69;
          v19[5] = v59;
          void v19[2] = v50;
          v19[3] = v65;
          *int32x4_t v19 = v67;
          v19[1] = v62;
          v19 += 16;
          v22 -= 16;
        }
        while (v22 > 0xF);
      }
      if (v22 >= 4)
      {
        do
        {
          int64x2_t v73 = *v20++;
          int32x4_t v74 = (int32x4_t)vdupq_laneq_s64(v73, 1);
          int32x4_t v75 = (int32x4_t)vdupq_lane_s64(v73.i64[0], 0);
          float32x4_t v76 = *v21++;
          float32x4_t v77 = (float32x4_t)vuzp1q_s32(v75, v74);
          int32x4_t v78 = (int32x4_t)vmlaq_f32(v76, (float32x4_t)vuzp2q_s32(v75, v74), v76);
          int32x4_t v79 = (int32x4_t)vmlaq_f32(v76, v77, v76);
          v77.i64[0] = *(void *)a7;
          v77.i32[0] = *(_DWORD *)(a7 + 8);
          float32x4_t v80 = vmlsq_lane_f32(vmlsq_lane_f32(v76, (float32x4_t)v78, *(float32x2_t *)a7, 0), (float32x4_t)v79, *(float32x2_t *)v77.f32, 0);
          int32x4_t v81 = vuzp2q_s32(v78, v79);
          int32x4_t v82 = vuzp1q_s32(v78, v79);
          v79.i32[0] = v78.i32[2];
          int32x4_t v83 = (int32x4_t)vmulq_n_f32(v80, COERCE_FLOAT(*(void *)(a7 + 4)));
          int32x4_t v84 = vtrn2q_s32(v81, v78);
          int32x4_t v85 = vtrn1q_s32(v82, v83);
          v81.i32[1] = v83.i32[1];
          v81.i32[3] = v18.i32[1];
          v85.i32[3] = v18.i32[0];
          v79.i32[1] = v83.i32[2];
          v79.i32[3] = v18.i32[2];
          v84.i32[1] = v83.i32[3];
          v84.i32[3] = v18.i32[3];
          void v19[2] = v79;
          v19[3] = v84;
          *int32x4_t v19 = v85;
          v19[1] = v81;
          v19 += 4;
          v22 -= 4;
        }
        while (v22 > 3);
      }
      if (v22)
      {
        __dst[0] = 0u;
        int32x4_t v103 = 0u;
        int64x2_t v104 = 0u;
        int32x4_t v101 = 0u;
        int32x4_t v102 = 0u;
        int32x4_t __src = 0u;
        memcpy(__dst, v21, 4 * v22);
        memcpy(&v104, v20, (4 * (_BYTE)v22 + 4) & 0x18);
        int32x4_t v86 = (int32x4_t)vdupq_laneq_s64(v104, 1);
        int32x4_t v87 = (int32x4_t)vdupq_lane_s64(v104.i64[0], 0);
        float32x4_t v88 = (float32x4_t)vuzp1q_s32(v87, v86);
        int32x4_t v89 = (int32x4_t)vmlaq_f32(__dst[0], (float32x4_t)vuzp2q_s32(v87, v86), __dst[0]);
        int32x4_t v90 = (int32x4_t)vmlaq_f32(__dst[0], v88, __dst[0]);
        v88.i64[0] = *(void *)a7;
        v88.i32[0] = *(_DWORD *)(a7 + 8);
        int32x4_t v91 = (int32x4_t)vmulq_n_f32(vmlsq_lane_f32(vmlsq_lane_f32(__dst[0], (float32x4_t)v89, *(float32x2_t *)a7, 0), (float32x4_t)v90, *(float32x2_t *)v88.f32, 0), COERCE_FLOAT(*(void *)(a7 + 4)));
        int32x4_t v92 = vuzp2q_s32(v89, v90);
        int32x4_t v93 = vtrn2q_s32(v92, v89);
        int32x4_t v94 = vuzp1q_s32(v89, v90);
        v90.i64[0] = __PAIR64__(v91.u32[2], v89.u32[2]);
        int32x4_t v95 = vtrn1q_s32(v94, v91);
        v95.i32[3] = v99.i32[0];
        v92.i32[1] = v91.i32[1];
        v90.i32[3] = v99.i32[2];
        v92.i32[3] = v99.i32[1];
        v93.i32[1] = v91.i32[3];
        v93.i32[3] = v99.i32[3];
        int32x4_t v102 = v90;
        int32x4_t v103 = v93;
        int32x4_t __src = v95;
        int32x4_t v101 = v92;
        uint64_t result = (float32x4_t *)memcpy(v19, &__src, 16 * v22);
        int32x4_t v18 = v99;
      }
      a5 = (int32x4_t *)((char *)a5 + a6);
      uint64_t v15 = (float32x4_t *)((char *)v15 + a2);
      if (v17 + 1 < a11)
      {
        ++v17;
      }
      else
      {
        a3 = (int64x2_t *)((char *)a3 + a4);
        int v17 = 0;
      }
      ++v16;
    }
    while (v16 != a10);
  }
  return result;
}

uint64_t TileDecoder::ReadYccRGBAPixels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, AXRBufferPool *a11, uint64_t a12, void *objecta, unint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40,uint64_t a41,uint64_t a42,int a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,int a48,uint64_t a49,uint64_t a50,axr_error_t a51,uint64_t a52)
{
  STACK[0x698] = *MEMORY[0x263EF8340];
  axr_decoder_t v57 = axr_decoder_copy(*(axr_decoder_t *)(a1 + 16));
  if (!v57) {
    return -5;
  }
  axr_decoder_t v58 = v57;
  axr_decoder_t v59 = axr_decoder_copy(*(axr_decoder_t *)(a1 + 16));
  if (!v59)
  {
    os_release(v58);
    return -5;
  }
  axr_decoder_t v60 = v59;
  a51 = axr_error_success;
  int32x4_t v61 = v58 + 3;
  Class isa = v58[3].isa;
  if (isa)
  {
    if (*((_DWORD *)isa + 5) == 9)
    {
      Class v63 = 0;
      Class v64 = v58[3].isa;
LABEL_12:
      if (v63) {
        int32x4_t v66 = ((char *)v63 + 8);
      }
      else {
        int32x4_t v66 = v58 + 3;
      }
      v66->Class isa = *(Class *)((char *)v64 + 8);
      *((void *)v64 + 1) = 0;
      --LODWORD(v58[4].isa);
      Class isa = v58[3].isa;
    }
    else
    {
      Class v64 = v58[3].isa;
      while (1)
      {
        Class v63 = v64;
        Class v64 = (Class)*((void *)v64 + 1);
        if (!v64) {
          break;
        }
        if (*((_DWORD *)v64 + 5) == 9) {
          goto LABEL_12;
        }
      }
    }
    if (isa)
    {
      if (*((_DWORD *)isa + 5) == 8)
      {
        Class v67 = 0;
LABEL_21:
        if (v67) {
          int32x4_t v61 = ((char *)v67 + 8);
        }
        v61->Class isa = *(Class *)((char *)isa + 8);
        *((void *)isa + 1) = 0;
        --LODWORD(v58[4].isa);
      }
      else
      {
        while (1)
        {
          Class v67 = isa;
          Class isa = (Class)*((void *)isa + 1);
          if (!isa) {
            break;
          }
          if (*((_DWORD *)isa + 5) == 8) {
            goto LABEL_21;
          }
        }
      }
    }
  }
  else
  {
    Class v64 = 0;
  }
  int32x4_t v68 = v59 + 3;
  Class v69 = v59[3].isa;
  uint64_t v163 = a3;
  if (v69)
  {
    if (*((_DWORD *)v69 + 5) == 10)
    {
      Class v70 = 0;
      Class v71 = v59[3].isa;
LABEL_31:
      if (v70) {
        int32x4_t v72 = ((char *)v70 + 8);
      }
      else {
        int32x4_t v72 = v59 + 3;
      }
      v72->Class isa = *(Class *)((char *)v71 + 8);
      *((void *)v71 + 1) = 0;
      --LODWORD(v59[4].isa);
      Class v69 = v59[3].isa;
    }
    else
    {
      Class v71 = v59[3].isa;
      while (1)
      {
        Class v70 = v71;
        Class v71 = (Class)*((void *)v71 + 1);
        if (!v71) {
          break;
        }
        if (*((_DWORD *)v71 + 5) == 10) {
          goto LABEL_31;
        }
      }
    }
    if (v69)
    {
      int v73 = *((_DWORD *)v69 + 5);
      if (v73 == 4) {
        goto LABEL_53;
      }
      Class v74 = v69;
      while (1)
      {
        int32x4_t v75 = v74;
        Class v74 = (Class)*((void *)v74 + 1);
        if (!v74) {
          break;
        }
        if (*((_DWORD *)v74 + 5) == 4) {
          goto LABEL_54;
        }
      }
      if (v73 == 5) {
        goto LABEL_53;
      }
      Class v74 = v69;
      while (1)
      {
        int32x4_t v75 = v74;
        Class v74 = (Class)*((void *)v74 + 1);
        if (!v74) {
          break;
        }
        if (*((_DWORD *)v74 + 5) == 5) {
          goto LABEL_54;
        }
      }
      if (v73 == 6) {
        goto LABEL_53;
      }
      Class v74 = v69;
      while (1)
      {
        int32x4_t v75 = v74;
        Class v74 = (Class)*((void *)v74 + 1);
        if (!v74) {
          break;
        }
        if (*((_DWORD *)v74 + 5) == 6) {
          goto LABEL_54;
        }
      }
      if (v73 == 7)
      {
LABEL_53:
        int32x4_t v75 = 0;
        Class v74 = v69;
LABEL_54:
        if (v75) {
          int32x4_t v68 = v75 + 1;
        }
        v68->Class isa = *(Class *)((char *)v74 + 8);
        *((void *)v74 + 1) = 0;
        --LODWORD(v59[4].isa);
      }
      else
      {
        Class v74 = v69;
        while (1)
        {
          int32x4_t v75 = v74;
          Class v74 = (Class)*((void *)v74 + 1);
          if (!v74) {
            break;
          }
          if (*((_DWORD *)v74 + 5) == 7) {
            goto LABEL_54;
          }
        }
      }
      goto LABEL_57;
    }
  }
  else
  {
    Class v71 = 0;
  }
  Class v74 = 0;
LABEL_57:
  a51 = axr_error_success;
  uint64_t v76 = *(unsigned int *)(a1 + 72);
  if (v76)
  {
    unint64_t v77 = 0;
    unsigned int v78 = *(_DWORD *)(a1 + 60);
    uint64_t v79 = *(void *)(a1 + 24);
    int v80 = *(_DWORD *)(v79 + 52);
    LODWORD(v79) = *(_DWORD *)(v79 + 44);
    BOOL v81 = __OFSUB__(v80, v79);
    int v82 = v80 - v79;
    if (v82 < 0 != v81) {
      unsigned int v83 = 0;
    }
    else {
      unsigned int v83 = v82 + 1;
    }
    if (v78 >= v83) {
      unsigned int v78 = v83;
    }
    unint64_t v84 = v78 - 1;
    int32x4_t v85 = (uint64_t *)(*(void *)(a1 + 64) + 8);
    do
    {
      uint64_t v86 = *v85;
      if (*v85)
      {
        uint64_t v87 = *(void *)(*(void *)(v86 + 40) + 8 * *(unsigned int *)(*(void *)(a1 + 16) + 44));
        unint64_t v88 = *(unsigned int *)(v87 + 12) - 1;
        if (v88 >= v84) {
          unint64_t v88 = v84;
        }
        if (*(_DWORD *)(v86 + 104) == 1)
        {
          int32x4_t v89 = (_DWORD *)(*(void *)(v87 + 24) + 8 * v88);
        }
        else
        {
          unint64_t v90 = (v88 * *(unsigned int *)(v86 + 108)) >> *(_DWORD *)(v86 + 112);
          if (v90 >= *(_DWORD *)(v87 + 20) - 1) {
            LODWORD(v90) = *(_DWORD *)(v87 + 20) - 1;
          }
          int32x4_t v89 = (_DWORD *)(*(void *)(v87 + 24) + 8 * v90);
        }
        unint64_t v91 = (v89[1] + *v89);
        if (v77 <= v91) {
          unint64_t v77 = v91;
        }
      }
      v85 += 2;
      --v76;
    }
    while (v76);
  }
  else
  {
    unint64_t v77 = 0;
  }
  a48 = 0;
  a49 = 0;
  a50 = v77 + 64;
  a15 = 0;
  a23 = 0;
  a31 = 0;
  a40 = 0;
  a41 = 0;
  a42 = 64;
  a43 = 0;
  a44 = 0;
  a45 = 64;
  a47 = a2;
  uint64_t v94 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 32))(a1, *(void *)(a1 + 48));
  if (a50 - 64 != v94)
  {
    AXRBufferPool::FreeBuffers((os_unfair_lock_s *)&a48);
    a50 = v94 + 64;
  }
  object = (axr_decoder *)v60;
  int v96 = *(_DWORD *)(a1 + 104);
  int v95 = *(_DWORD *)(a1 + 108);
  uint64_t v162 = a4;
  axr_error_t PixelsArgs = TileDecoder::MakeReadPixelsArgs(a1, v163, a4, (uint64_t)&a48, 1, (uint64_t)&a14, v92, v93, a5);
  a51 = PixelsArgs;
  if (PixelsArgs) {
    goto LABEL_131;
  }
  axr_compression_t v97 = (*(unsigned int (**)(uint64_t))(*(void *)a1 + 56))(a1);
  TileDecoder_storage::Init((TileDecoder_storage *)&STACK[0x5D0], v97, (axr_decoder *)v58, *(const Part **)(a1 + 24), *(void *)(a1 + 8), &a51, v98, v99);
  a38 = v100;
  axr_error_t PixelsArgs = a51;
  if (a51) {
    goto LABEL_131;
  }
  axr_compression_t v101 = (*(unsigned int (**)(uint64_t))(*(void *)a1 + 56))(a1);
  TileDecoder_storage::Init((TileDecoder_storage *)&a52, v101, object, *(const Part **)(a1 + 24), *(void *)(a1 + 8), &a51, v102, v103);
  a39 = v106;
  axr_error_t PixelsArgs = a51;
  if (a51) {
    goto LABEL_131;
  }
  unint64_t isa_low = LODWORD(v58[4].isa);
  if (!isa_low) {
    goto LABEL_130;
  }
  unint64_t v108 = 0;
  axr_decoder_t v157 = v58;
  uint64_t v158 = 0;
  axr_error_t PixelsArgs = axr_error_success;
  unint64_t v155 = (v96 * v95);
  axr_type_t vars0_4 = axr_type_half;
  uint64_t vars8 = 0x100000001;
  uint64_t v109 = 8;
  do
  {
    int8x16_t v110 = *(_DWORD **)(*(void *)(a38 + 64) + v109);
    if (v110)
    {
      unsigned int v111 = v110[20];
      int v112 = *(_DWORD *)(a1 + 56);
      HIDWORD(vars8) = v111;
      if (v111 <= 1) {
        unsigned int v111 = 1;
      }
      BOOL v113 = __CFADD__(v111 - 1, v112);
      unsigned int v114 = v111 - 1 + v112;
      if (v113) {
        unsigned int v115 = (v114 - 0xFFFFFFFF / v111 * v111) / v111 + 0xFFFFFFFF / v111;
      }
      else {
        unsigned int v115 = v114 / v111;
      }
      axr_error_t v116 = PixelsArgs;
      unsigned int v117 = v110[26];
      int v118 = *(_DWORD *)(a1 + 60);
      LODWORD(vars8) = v117;
      if (v117 <= 1) {
        unsigned int v117 = 1;
      }
      BOOL v113 = __CFADD__(v117 - 1, v118);
      unsigned int v119 = v117 - 1 + v118;
      if (v113) {
        unsigned int v120 = (v119 - 0xFFFFFFFF / v117 * v117) / v117 + 0xFFFFFFFF / v117;
      }
      else {
        unsigned int v120 = v119 / v117;
      }
      axr_type_t vars0_4 = v110[18];
      axr_error_t PixelsArgs = v116 + v120 * (unint64_t)v115 * axr_type_get_size(vars0_4);
      axr_decoder_t v58 = v157;
      unint64_t isa_low = LODWORD(v157[4].isa);
    }
    else
    {
      ++v158;
    }
    ++v108;
    v109 += 16;
  }
  while (v108 < isa_low);
  if (v158)
  {
    int v121 = *(_DWORD *)(a1 + 56);
    unsigned int v122 = HIDWORD(vars8);
    if (HIDWORD(vars8) <= 1) {
      unsigned int v122 = 1;
    }
    BOOL v113 = __CFADD__(v122 - 1, v121);
    unsigned int v123 = v122 - 1 + v121;
    if (v113) {
      unsigned int v124 = (v123 - 0xFFFFFFFF / v122 * v122) / v122 + 0xFFFFFFFF / v122;
    }
    else {
      unsigned int v124 = v123 / v122;
    }
    int v125 = *(_DWORD *)(a1 + 60);
    unsigned int v126 = vars8;
    if (vars8 <= 1) {
      unsigned int v126 = 1;
    }
    BOOL v113 = __CFADD__(v126 - 1, v125);
    unsigned int v127 = v126 - 1 + v125;
    if (v113) {
      unsigned int v128 = (v127 - 0xFFFFFFFF / v126 * v126) / v126 + 0xFFFFFFFF / v126;
    }
    else {
      unsigned int v128 = v127 / v126;
    }
    PixelsArgs += v158 * v124 * v128 * axr_type_get_size(vars0_4);
    unint64_t v129 = object;
  }
  else
  {
    unint64_t v129 = object;
  }
  if (PixelsArgs == axr_error_success) {
    goto LABEL_131;
  }
  if (a42 - 64 != PixelsArgs)
  {
    AXRBufferPool::FreeBuffers((os_unfair_lock_s *)&a40);
    a42 = PixelsArgs + 64;
    unint64_t v129 = object;
  }
  unint64_t v130 = *((unsigned int *)v129 + 8);
  uint64_t v131 = v162;
  if (v130)
  {
    unint64_t v132 = 0;
    uint64_t v156 = 0;
    axr_error_t PixelsArgs = axr_error_success;
    uint64_t v133 = 8;
    do
    {
      unsigned int v134 = *(_DWORD **)(*(void *)(a39 + 64) + v133);
      if (v134)
      {
        unsigned int v135 = v134[20];
        unsigned int v136 = *(_DWORD *)(a1 + 56);
        HIDWORD(vars8) = v135;
        if (v135 <= 1) {
          unsigned int v135 = 1;
        }
        unsigned int v137 = v136 + v135 - 1;
        if (v137 < v136) {
          int v138 = (v137 - 0xFFFFFFFF / v135 * v135) / v135 + 0xFFFFFFFF / v135;
        }
        else {
          int v138 = v137 / v135;
        }
        unsigned int v159 = v138;
        axr_error_t v139 = PixelsArgs;
        unsigned int v140 = v134[26];
        int v141 = *(_DWORD *)(a1 + 60);
        LODWORD(vars8) = v140;
        if (v140 <= 1) {
          unsigned int v140 = 1;
        }
        BOOL v113 = __CFADD__(v140 - 1, v141);
        unsigned int v142 = v140 - 1 + v141;
        if (v113) {
          unsigned int v143 = (v142 - 0xFFFFFFFF / v140 * v140) / v140 + 0xFFFFFFFF / v140;
        }
        else {
          unsigned int v143 = v142 / v140;
        }
        axr_type_t vars0_4 = v134[18];
        axr_error_t PixelsArgs = v139 + v143 * (unint64_t)v159 * axr_type_get_size(vars0_4);
        unint64_t v130 = *((unsigned int *)object + 8);
        uint64_t v131 = v162;
      }
      else
      {
        ++v156;
      }
      ++v132;
      v133 += 16;
    }
    while (v132 < v130);
    if (v156)
    {
      int v145 = *(_DWORD *)(a1 + 56);
      unsigned int v146 = HIDWORD(vars8);
      if (HIDWORD(vars8) <= 1) {
        unsigned int v146 = 1;
      }
      BOOL v113 = __CFADD__(v146 - 1, v145);
      unsigned int v147 = v146 - 1 + v145;
      if (v113) {
        unsigned int v148 = (v147 - 0xFFFFFFFF / v146 * v146) / v146 + 0xFFFFFFFF / v146;
      }
      else {
        unsigned int v148 = v147 / v146;
      }
      int v149 = *(_DWORD *)(a1 + 60);
      unsigned int v150 = vars8;
      if (vars8 <= 1) {
        unsigned int v150 = 1;
      }
      BOOL v113 = __CFADD__(v150 - 1, v149);
      unsigned int v151 = v150 - 1 + v149;
      if (v113) {
        unsigned int v152 = (v151 - 0xFFFFFFFF / v150 * v150) / v150 + 0xFFFFFFFF / v150;
      }
      else {
        unsigned int v152 = v151 / v150;
      }
      PixelsArgs += v156 * v148 * v152 * axr_type_get_size(vars0_4);
      uint64_t v131 = v162;
    }
    if (PixelsArgs)
    {
      if (a45 - 64 != PixelsArgs)
      {
        AXRBufferPool::FreeBuffers((os_unfair_lock_s *)&a43);
        a45 = PixelsArgs + 64;
        uint64_t v131 = v162;
      }
      axr_error_t PixelsArgs = TileDecoder::MakeReadPixelsArgs(a38, v163, v131, (uint64_t)&a40, 0, (uint64_t)&a22, v104, v105, a5);
      a51 = PixelsArgs;
      if (PixelsArgs == axr_error_success)
      {
        axr_error_t PixelsArgs = TileDecoder::MakeReadPixelsArgs(a39, v163, v162, (uint64_t)&a43, 0, (uint64_t)&a30, v153, v154, a5);
        a51 = PixelsArgs;
        if (PixelsArgs == axr_error_success)
        {
          axr_error_t PixelsArgs = LaunchBlocks<ReadPixelsArgs>((void (__cdecl *)(void *, size_t))TileDecoder::ReadYccBlock, &a14, v155, *(void *)(a1 + 8));
          a51 = PixelsArgs;
        }
      }
    }
  }
  else
  {
LABEL_130:
    axr_error_t PixelsArgs = axr_error_success;
  }
LABEL_131:
  if (v74)
  {
    *((void *)v74 + 1) = *((void *)object + 3);
    *((void *)object + 3) = v74;
    ++*((_DWORD *)object + 8);
  }
  if (v71)
  {
    *((void *)v71 + 1) = *((void *)object + 3);
    *((void *)object + 3) = v71;
    ++*((_DWORD *)object + 8);
  }
  if (v64)
  {
    *(v64 + 1) = v58[3];
    v58[3].Class isa = v64;
    ++LODWORD(v58[4].isa);
  }
  if (isa)
  {
    *(isa + 1) = v58[3];
    v58[3].Class isa = isa;
    ++LODWORD(v58[4].isa);
  }
  os_release(v58);
  os_release(object);
  AXRBufferPool::FreeBuffers((os_unfair_lock_s *)&a43);
  AXRBufferPool::FreeBuffers((os_unfair_lock_s *)&a40);
  AXRBufferPool::FreeBuffers((os_unfair_lock_s *)&a48);
  (*(void (**)(uint64_t *))a52)(&a52);
  (*(void (**)(unint64_t *))STACK[0x5D0])(&STACK[0x5D0]);
  return PixelsArgs;
}

void sub_228F372F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,os_unfair_lock_s a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,os_unfair_lock_s a61,uint64_t a62,uint64_t a63)
{
  ReadYccArgs::~ReadYccArgs(&a27);
  AXRBufferPool::FreeBuffers(&a61);
  (*a65)(&a65);
  (*(void (**)(unint64_t *))STACK[0x280])(&STACK[0x280]);
  _Unwind_Resume(a1);
}

void TileDecoder_storage::Init(TileDecoder_storage *this, axr_compression_t a2, axr_decoder *a3, const Part *a4, uint64_t a5, axr_error_t *a6, uint64_t a7, uint64_t a8)
{
  switch(a2)
  {
    case axr_compression_none:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        uint64_t v9 = &unk_26DD4C150;
        goto LABEL_19;
      }
      break;
    case axr_compression_rle:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        uint64_t v9 = &unk_26DD4BF70;
        goto LABEL_19;
      }
      break;
    case axr_compression_zips:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        uint64_t v9 = &unk_26DD4C078;
        goto LABEL_19;
      }
      break;
    case axr_compression_zip:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        uint64_t v9 = &unk_26DD4BFC8;
        goto LABEL_19;
      }
      break;
    case axr_compression_piz:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        uint64_t v9 = &unk_26DD4BF18;
        goto LABEL_19;
      }
      break;
    case axr_compression_pxr24:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        uint64_t v9 = &unk_26DD4C0D0;
        goto LABEL_19;
      }
      break;
    case axr_compression_b44:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        *uint64_t v10 = &unk_26DD4BEC0;
        v10[16] = -1;
      }
      break;
    case axr_compression_b44a:
      if (this)
      {
        TileDecoder::TileDecoder(this, a3, a4, a5, a6, (uint64_t)a6, a7, a8);
        v8[16] = -1;
        uint64_t v9 = &unk_26DD4C020;
LABEL_19:
        *uint64_t v8 = v9;
      }
      break;
    default:
      *a6 = axr_error_unknown_file_type;
      break;
  }
}

void ReadYccArgs::~ReadYccArgs(os_unfair_lock_s *this)
{
}

void TileDecoder::ReadPlanesBlock(TileDecoder *this, unint64_t a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *((void *)this + 2);
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  TileDecoder::GetThreadTileInfo((TileDecoder *)v3, a2, (uint64_t)&v29);
  if ((DWORD1(v32) + DWORD2(v32)) < *(_DWORD *)(v3 + 60)
    && (v32 + HIDWORD(v31)) < *(_DWORD *)(v3 + 56))
  {
    unint64_t v28 = *(void *)(v4 + 16) - 64;
    int v5 = *(_DWORD *)(v3 + 72);
    if (v5)
    {
      unint64_t v6 = 0;
      unint64_t v7 = 0;
      uint64_t v8 = 8;
      do
      {
        v6 += (*(unsigned int (**)(uint64_t, long long *, double))(*(void *)v3 + 64))(v3, &v29, COERCE_DOUBLE(vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)(*(void *)(*(void *)(*(void *)(v3 + 64) + v8) + 40)+ 8 * HIDWORD(v32))+ 16), *(int32x2_t *)(*(void *)(*(void *)(v3 + 64) + v8) + 48), *(int32x2_t *)((char *)&v30 + 8)), *(uint32x2_t *)(*(void *)(*(void *)(v3 + 64) + v8) + 48))));
        ++v7;
        unint64_t v9 = *(unsigned int *)(v3 + 72);
        v8 += 16;
      }
      while (v7 < v9);
      int v5 = *(_DWORD *)(v3 + 72);
    }
    else
    {
      unint64_t v6 = 0;
      unint64_t v9 = 0;
    }
    if (v6 >= v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
    }
    else
    {
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t, long long *, unint64_t *))(*(void *)v3 + 24))(v27, v3, v4, &v29, &v28);
      uint64_t v10 = v27[0];
      uint64_t v11 = v27[1];
      int v5 = *(_DWORD *)(v3 + 72);
    }
    uint64_t v12 = v28;
    if (v28 >= *(void *)(v4 + 16) - 64) {
      uint64_t v12 = *(void *)(v4 + 16) - 64;
    }
    unint64_t v28 = v12;
    if (v5)
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      do
      {
        uint64_t v15 = *(int32x2_t **)(*(void *)(v3 + 64) + v13 + 8);
        unsigned int v16 = DWORD1(v31);
        if (DWORD1(v31))
        {
          unsigned int v25 = v15[10].u32[0];
          if (v25 <= 1) {
            unsigned int v25 = 1;
          }
          unsigned int v16 = DWORD1(v31) / v25;
        }
        unsigned int v17 = v15[13].u32[0];
        if (v17 <= 1) {
          unsigned int v17 = 1;
        }
        uint64_t v18 = DWORD2(v31) / v17;
        int32x4_t v19 = (void *)(*((void *)this + 3) + v13);
        uint64_t v20 = v19[1];
        if (v15[9].i32[0] == 1) {
          char v21 = 1;
        }
        else {
          char v21 = 2;
        }
        unsigned int v22 = (char *)(((unint64_t)v16 << v21) + *v19 + v20 * v18);
        if (*(_DWORD *)(*(void *)(v3 + 24) + 72) == 1 && (*(unsigned char *)(v3 + 8) & 8) == 0)
        {
          v22 += v20 * (*(_DWORD *)(*(void *)(v3 + 16) + 60) - 1);
          uint64_t v20 = -v20;
        }
        if ((*(unsigned int (**)(uint64_t, long long *, double))(*(void *)v3 + 64))(v3, &v29, COERCE_DOUBLE(vmin_u32((uint32x2_t)vmls_s32(*(int32x2_t *)(*(void *)(*(void *)&v15[5] + 8 * HIDWORD(v32)) + 16), v15[6], *(int32x2_t *)((char *)&v30 + 8)), (uint32x2_t)v15[6]))))
        {
          uint64_t CompressedDataPtr = AXRChunkHeader::GetCompressedDataPtr(v29, *(_DWORD *)(*(void *)(v3 + 24) + 208), *((unint64_t *)&v29 + 1));
          if (!CompressedDataPtr)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = -4;
          }
          TileDecoder::ExtractPlane_Uncompressed(v3, CompressedDataPtr, *((unint64_t *)&v29 + 1), *(void *)(v3 + 64) + v13, (uint64_t)&v29, v22, v24, v20);
        }
        else
        {
          (*(void (**)(uint64_t, uint64_t, unint64_t, uint64_t, long long *, char *, void, uint64_t))(*(void *)v3 + 48))(v3, v10, v28, *(void *)(v3 + 64) + v13, &v29, v22, 0, v20);
        }
        ++v14;
        v13 += 16;
      }
      while (v14 < *(unsigned int *)(v3 + 72));
    }
    if (v10)
    {
      if (v11) {
        free((void *)(v10 - 64));
      }
    }
  }
}

#error "228F379D4: call analysis failed (funcsize=36)"

unint64_t TileDecoder::ReadPlanes(TileDecoder *this, axr_pixel_data_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *((unsigned int *)this + 18);
  if (v10)
  {
    uint64_t v11 = (void *)(*((void *)this + 8) + 8);
    while (*v11)
    {
      v11 += 2;
      if (!--v10) {
        goto LABEL_5;
      }
    }
    uint64_t v14 = *((void *)this + 1);
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v14) & 2) != 0) {
      AXRLogError((uint64_t)"AppleEXR does not support generation of planar data to hold a constant.\n(e.g. using axr_decoder_append_constant_value_channel())\nWhile in general, allocation of entire plane to hold a constant should\nbe considered wasteful, this may be done with memset_pattern4()\nwhen it can not be otherwise avoided.\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v16);
    }
    return -1;
  }
  else
  {
LABEL_5:
    uint64_t v12 = (*(uint64_t (**)(TileDecoder *, void))(*(void *)this + 32))(this, *((void *)this + 6));
    v18._os_unfair_lock_opaque = 0;
    uint64_t v19 = 0;
    uint64_t v20 = v12 + 64;
    v17[0] = (unint64_t)this;
    v17[1] = 0;
    v17[2] = (unint64_t)&v18;
    v17[3] = (unint64_t)a2;
    unint64_t Planes = LaunchBlocks<ReadPlanesArgs>((void (__cdecl *)(void *, size_t))TileDecoder::ReadPlanesBlock, v17, (*((_DWORD *)this + 27) * *((_DWORD *)this + 26)), *((void *)this + 1));
    AXRBufferPool::FreeBuffers(&v18);
  }
  return Planes;
}

void sub_228F37B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  AXRBufferPool::FreeBuffers((os_unfair_lock_s *)va);
  _Unwind_Resume(a1);
}

unint64_t LaunchBlocks<ReadPlanesArgs>(void (__cdecl *a1)(void *, size_t), unint64_t *a2, unint64_t a3, char a4)
{
  if ((a4 & 4) != 0) {
    goto LABEL_18;
  }
  uint64_t v8 = (unsigned int *)*a2;
  uint64_t v9 = *(void *)(*a2 + 64);
  if (v9)
  {
    BOOL v30 = *(_DWORD *)(*(void *)v9 + 16) == 1;
    unsigned int v10 = 4;
    if (v30) {
      unsigned int v10 = 2;
    }
  }
  else
  {
    unsigned int v10 = 2;
  }
  unint64_t v11 = v10 * (unint64_t)v8[14] * v8[15] * v8[18];
  unsigned int v12 = v8[26];
  unsigned int v13 = v8[27];
  unint64_t v14 = (*(uint64_t (**)(unsigned int *))(*(void *)v8 + 16))(v8);
  if (v11 <= 1) {
    unint64_t v15 = 1;
  }
  else {
    unint64_t v15 = v11;
  }
  unint64_t v16 = v14 + v15 - 1;
  if (v16 < v14) {
    unint64_t v17 = (v14 + v15 - 0xFFFFFFFF / v15 * v15 + 0xFFFFFFFF) / v15 + 0xFFFFFFFF / v15;
  }
  else {
    unint64_t v17 = v16 / v15;
  }
  if (v17 >= v13 * (unint64_t)v12) {
    unint64_t v17 = v13 * (unint64_t)v12;
  }
  unint64_t v18 = v17 <= 1 ? 1 : v17;
  if (v17 <= 1)
  {
LABEL_18:
    qos_class_t v19 = qos_class_self();
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(v19, 0);
    if ((a4 & 4) == 0 && a3 >= 2)
    {
      char v21 = global_queue;
      if (global_queue)
      {
        size_t v22 = a3;
        int64x2_t v23 = a2;
        uint64_t v24 = a1;
LABEL_45:
        dispatch_apply_f(v22, v21, v23, v24);
        return atomic_load(a2 + 1);
      }
    }
    if (a3)
    {
      uint64_t v25 = 0;
      do
        ((void (*)(unint64_t *, uint64_t))a1)(a2, v25++);
      while (a3 != v25);
    }
  }
  else
  {
    v38[0] = a1;
    v38[1] = a2;
    void v38[2] = v18;
    v38[3] = a3;
    unint64_t v26 = v18 + a3 - 1;
    if (v26 < a3) {
      unint64_t v27 = (v18 + a3 - 0xFFFFFFFF / v18 * v18 + 0xFFFFFFFF) / v18 + 0xFFFFFFFF / v18;
    }
    else {
      unint64_t v27 = v26 / v18;
    }
    qos_class_t v28 = qos_class_self();
    dispatch_queue_global_t v29 = dispatch_get_global_queue(v28, 0);
    char v21 = v29;
    BOOL v30 = v27 < 2 || v29 == 0;
    if (!v30)
    {
      uint64_t v24 = (void (__cdecl *)(void *, size_t))DoAggregateBlock<ReadPlanesArgs>;
      int64x2_t v23 = v38;
      size_t v22 = v27;
      goto LABEL_45;
    }
    if (v27)
    {
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      unint64_t v33 = a3;
      do
      {
        if (v18 >= v33) {
          unint64_t v34 = v33;
        }
        else {
          unint64_t v34 = v18;
        }
        unint64_t v35 = a3 - v18 * v32;
        if (v18 < v35) {
          unint64_t v35 = v18;
        }
        if (v35)
        {
          uint64_t v36 = v31;
          do
          {
            ((void (*)(unint64_t *, uint64_t))a1)(a2, v36++);
            --v34;
          }
          while (v34);
        }
        ++v32;
        v33 -= v18;
        v31 += v18;
      }
      while (v32 != v27);
    }
  }
  return atomic_load(a2 + 1);
}

uint64_t TileDecoder::IsInterleavedValid(TileDecoder *this, unsigned int *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *((_DWORD *)this + 18);
  if (v9 > 4 || v9 == 3)
  {
    uint64_t v11 = *((void *)this + 1);
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v11) & 2) != 0)
    {
      unsigned int v12 = "Error: axr_decoder_read_pixels is limited to 1, 2 or 4 channel result images";
LABEL_32:
      AXRLogError((uint64_t)v12, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, name);
    }
  }
  else
  {
    unsigned int v13 = (void *)*((void *)this + 8);
    uint64_t v14 = v13[1];
    int v15 = *(_DWORD *)(*v13 + 16);
    if (v14)
    {
      *a2 = *(_DWORD *)(v14 + 80);
      LODWORD(v14) = *(_DWORD *)(v14 + 104);
    }
    else
    {
      *a2 = 0;
    }
    *a3 = v14;
    unint64_t v16 = *((unsigned int *)this + 18);
    if (v16 < 2) {
      return 0;
    }
    uint64_t v17 = 0;
    unint64_t v18 = 1;
    while ((v15 == 1) != (*(_DWORD *)(v13[v17 + 2] + 16) != 1))
    {
      uint64_t v19 = v13[v17 + 3];
      if (v19)
      {
        unsigned int v20 = *(_DWORD *)(v19 + 80);
        if (*a2)
        {
          if (*a2 != v20)
          {
            uint64_t v24 = *((void *)this + 1);
            if (GetFlagsOnceToken != -1)
            {
              unint64_t v26 = a2;
              dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
              a2 = v26;
            }
            if (((kDefaultAXRLogFlags | v24) & 2) != 0) {
              AXRLogError((uint64_t)"Error: axr_decoder_read_pixels requires that all channels have the same x sampling rate.\n\t%d vs %d", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a2);
            }
            return -1;
          }
        }
        else
        {
          *a2 = v20;
        }
        unsigned int v21 = *(_DWORD *)(v19 + 104);
        if (*a3)
        {
          if (*a3 != v21)
          {
            uint64_t v25 = *((void *)this + 1);
            if (GetFlagsOnceToken != -1)
            {
              unint64_t v27 = a3;
              dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
              a3 = v27;
            }
            if (((kDefaultAXRLogFlags | v25) & 2) != 0) {
              AXRLogError((uint64_t)"Error: axr_decoder_read_pixels requires that all channels have the same y sampling rate.\n\t%d vs %d", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
            }
            return -1;
          }
        }
        else
        {
          *a3 = v21;
        }
        unint64_t v16 = *((unsigned int *)this + 18);
      }
      ++v18;
      v17 += 2;
      if (v18 >= v16) {
        return 0;
      }
    }
    uint64_t v23 = *((void *)this + 1);
    if (GetFlagsOnceToken != -1) {
      dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
    }
    if (((kDefaultAXRLogFlags | v23) & 2) != 0)
    {
      char name = axr_type_get_name((axr_type_t)*(_DWORD *)(**((void **)this + 8) + 16));
      axr_type_get_name(*(axr_type_t *)(*(void *)(*((void *)this + 8) + v17 * 8 + 16) + 16));
      unsigned int v12 = "Error: axr_decoder_read_pixels requires that all channels have the same data size.\n\t%s vs %s";
      goto LABEL_32;
    }
  }
  return -1;
}

void TileDecoder::RemovePrefixSumPredictor(TileDecoder *this, unsigned __int8 *a2, unint64_t a3)
{
  int8x16_t v3 = 0uLL;
  if (a3 >= 0x20)
  {
    uint64_t v4 = 0;
    v5.i64[0] = 0xFFFF0000FFFF0000;
    v5.i64[1] = 0xFFFF0000FFFF0000;
    v6.i64[0] = 0xFFFFFFFF00000000;
    v6.i64[1] = 0xFFFFFFFF00000000;
    v7.i64[0] = 0x8000800080008000;
    v7.i64[1] = 0x8000800080008000;
    do
    {
      uint64_t v8 = (int8x16_t *)&a2[v4];
      int8x16_t v9 = vaddq_s8((int8x16_t)(*(_OWORD *)&vrev16q_s8(*(int8x16_t *)&a2[v4]) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00)), *(int8x16_t *)&a2[v4]);
      int8x16_t v10 = vaddq_s8((int8x16_t)(*(_OWORD *)&vrev16q_s8(*(int8x16_t *)&a2[v4 + 16]) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00)), *(int8x16_t *)&a2[v4 + 16]);
      int8x16_t v11 = vaddq_s8(vandq_s8(vqtbl1q_s8(v10, (int8x16_t)xmmword_228F62B90), v5), v10);
      int8x16_t v12 = vaddq_s8(vandq_s8(vqtbl1q_s8(v9, (int8x16_t)xmmword_228F62B90), v5), v9);
      int8x16_t v13 = vaddq_s8(vandq_s8(vqtbl1q_s8(v12, (int8x16_t)xmmword_228F62BA0), v6), v12);
      int8x16_t v14 = vaddq_s8(vandq_s8(vqtbl1q_s8(v11, (int8x16_t)xmmword_228F62BA0), v6), v11);
      int8x16_t v15 = vaddq_s8(vandq_s8(vdupq_lane_s8(*(int8x8_t *)v13.i8, 7), (int8x16_t)xmmword_228F61DE0), v13);
      int8x16_t v16 = vdupq_laneq_s8(v15, 15);
      int8x16_t v17 = vaddq_s8(v15, v3);
      int8x16_t v18 = vaddq_s8(vaddq_s8(vandq_s8(vdupq_lane_s8(*(int8x8_t *)v14.i8, 7), (int8x16_t)xmmword_228F61DE0), vaddq_s8(v14, v3)), v16);
      int8x16_t v3 = vdupq_laneq_s8(v18, 15);
      *uint64_t v8 = veorq_s8(v17, v7);
      v8[1] = veorq_s8(v18, v7);
      uint64_t v19 = v4 + 32;
      unint64_t v20 = v4 + 64;
      v4 += 32;
    }
    while (v20 <= a3);
    a2 += v19;
  }
  unint64_t v21 = a3 & 0x1F;
  if ((a3 & 0x1F) != 0)
  {
    unsigned int v22 = v3.u8[0] ^ 0xFFFFFF80;
    do
    {
      unsigned int v22 = v22 + *a2 - 128;
      *a2++ = v22;
      --v21;
    }
    while (v21);
  }
}

void TileDecoder_NoCompression::Decompress(uint64_t *a1@<X2>, uint64_t *a2@<X3>, void *a3@<X8>)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a1;
  if (*a2 >= (unint64_t)a1[1]) {
    uint64_t v3 = a1[1];
  }
  *a2 = v3;
  *a3 = v4 + 8;
  a3[1] = 0;
}

ChannelDescription *TileDecoder_NoCompression::Interleave(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  return TileDecoder::Interleave_Uncompressed(a1, a2, a3, a4, a5, a6);
}

void Read2_NoCompression<unsigned short,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, unint64_t a8, unsigned int a9, int8x16_t *a10, uint64_t a11)
{
  uint64_t v11 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v11;
  }
  else {
    _D0 = NAN;
  }
  int v13 = *(_DWORD *)(v11 + 16);
  if (v13 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v13 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v34) = _H0;
    LOWORD(v34) = _H0;
    LODWORD(_D0) = v34;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  uint64_t v19 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D1 = *(double *)v19;
  }
  else {
    _D1 = NAN;
  }
  int v21 = *(_DWORD *)(v19 + 16);
  if (v21 == 2)
  {
    float v22 = _D1;
  }
  else if (v21 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v35) = _H1;
    LOWORD(v35) = _H1;
    float v22 = v35;
  }
  else
  {
    LODWORD(v22) = _D1;
    if (v21) {
      float v22 = *(float *)&_D0;
    }
  }
  uint64_t v24 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v24 < *(unsigned int *)(a3 + 60))
  {
    uint64_t v25 = a10;
    unint64_t v26 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    *((float *)&_D0 + 1) = v22;
    v36.val[1] = (int8x16_t)vdupq_lane_s16(*(int16x4_t *)&_D0, 0);
    v36.val[0] = (int8x16_t)vdupq_lane_s16(*(int16x4_t *)&_D0, 2);
    int8x16_t v27 = vqtbl2q_s8(v36, (int8x16_t)xmmword_228F62BB0);
    while (a8 < 4)
    {
      unint64_t v28 = 0;
      dispatch_queue_global_t v29 = v25;
LABEL_27:
      uint64_t v31 = a8 - v28;
      if (a8 > v28)
      {
        unint64_t v32 = 2 * v28;
        do
        {
          v32 += 2;
          if (v32 > v26) {
            goto LABEL_33;
          }
          v29->i16[1] = WORD2(_D0);
          v29->i16[0] = LOWORD(_D0);
          dispatch_queue_global_t v29 = (int8x16_t *)((char *)v29 + 4);
        }
        while (--v31);
      }
      uint64_t v25 = (int8x16_t *)((char *)v25 + a11);
      v24 += a9;
      if (v24 + (unint64_t)*(unsigned int *)(a4 + 56) >= *(unsigned int *)(a3 + 60)) {
        return;
      }
    }
    unint64_t v30 = 0;
    unint64_t v28 = 0;
    dispatch_queue_global_t v29 = v25;
    while (1)
    {
      v30 += 8;
      if (v30 > v26) {
        break;
      }
      if (v29 <= (int8x16_t *)&a10->i8[a11])
      {
        v28 += 4;
        *v29++ = v27;
        if (v28 + 4 <= a8) {
          continue;
        }
      }
      goto LABEL_27;
    }
LABEL_33:
    exception = __cxa_allocate_exception(8uLL);
    void *exception = -6;
  }
}

void Read2_NoCompression<unsigned int,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, unint64_t a8, unsigned int a9, _OWORD *a10, uint64_t a11)
{
  uint64_t v11 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v11;
  }
  else {
    _D0 = NAN;
  }
  int v13 = *(_DWORD *)(v11 + 16);
  if (v13 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v13 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v36) = _H0;
    LOWORD(v36) = _H0;
    LODWORD(_D0) = v36;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  uint64_t v19 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D1 = *(double *)v19;
  }
  else {
    _D1 = NAN;
  }
  int v21 = *(_DWORD *)(v19 + 16);
  if (v21 == 2)
  {
    float v23 = _D1;
  }
  else if (v21 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v37) = _H1;
    LOWORD(v37) = _H1;
    float v23 = v37;
  }
  else
  {
    unsigned int v22 = _D1;
    if (v21) {
      float v23 = *(float *)&_D0;
    }
    else {
      float v23 = *(float *)&v22;
    }
  }
  uint64_t v25 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v25 < *(unsigned int *)(a3 + 60))
  {
    unint64_t v26 = a10;
    unint64_t v27 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    *(void *)&long long v28 = __PAIR64__(LODWORD(v23), LODWORD(_D0));
    *((void *)&v28 + 1) = __PAIR64__(LODWORD(v23), LODWORD(_D0));
    *((float *)&_D0 + 1) = v23;
    do
    {
      if (a8 >= 4)
      {
        unint64_t v31 = 0;
        unint64_t v29 = 0;
        unint64_t v32 = v26;
        while (1)
        {
          v31 += 16;
          if (v31 > v27) {
            goto LABEL_35;
          }
          if (v32 > (_OWORD *)((char *)a10 + a11)) {
            break;
          }
          v29 += 4;
          unint64_t v30 = v32 + 2;
          *unint64_t v32 = v28;
          v32[1] = v28;
          v32 += 2;
          if (v29 + 4 > a8) {
            goto LABEL_29;
          }
        }
        unint64_t v30 = v32;
      }
      else
      {
        unint64_t v29 = 0;
        unint64_t v30 = v26;
      }
LABEL_29:
      uint64_t v33 = a8 - v29;
      if (a8 > v29)
      {
        unint64_t v34 = 4 * v29;
        while (1)
        {
          v34 += 4;
          if (v34 > v27) {
            break;
          }
          *v30++ = *(void *)&_D0;
          if (!--v33) {
            goto LABEL_33;
          }
        }
LABEL_35:
        exception = __cxa_allocate_exception(8uLL);
        void *exception = -6;
      }
LABEL_33:
      unint64_t v26 = (_OWORD *)((char *)v26 + a11);
      v25 += a9;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read2_NoCompression<unsigned short,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unint64_t a8, unsigned int a9, int16x8_t *a10, uint64_t a11)
{
  uint64_t v15 = *(void *)(a4 + 24);
  uint64_t v51 = *(unsigned int *)(a4 + 44);
  uint64_t v54 = v15;
  int32x4_t v55 = *(ChannelDescription **)(a5 + 8);
  unsigned int v53 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v55, (*(_DWORD *)(a4 + 52) + HIDWORD(v15) * *(_DWORD *)(a3 + 60)), v15, v53);
  uint64_t v16 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v16;
  }
  else {
    _D0 = NAN;
  }
  int v18 = *(_DWORD *)(v16 + 16);
  if (v18 == 2)
  {
    *(float *)&unsigned int v19 = _D0;
  }
  else if (v18 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    LOWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    unsigned int v19 = v58;
  }
  else
  {
    unsigned int v19 = _D0;
  }
  unint64_t v24 = *(void *)(a3 + 56);
  uint64_t v25 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v25 < HIDWORD(v24))
  {
    unint64_t v26 = a10;
    int v27 = *(_DWORD *)(a4 + 28) * HIDWORD(v24);
    unint64_t v50 = a1 + a2;
    unint64_t v28 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    __int16 v29 = v19;
    int16x8_t v52 = vdupq_n_s16(v19);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v55, (v27 + v25), v54, v53);
      uint64_t v32 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v32 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v34 = 0;
        unint64_t v35 = v32 + 2 * v51;
        _CF = v50 >= v35;
        unint64_t v37 = v50 - v35;
        BOOL v36 = v37 != 0 && _CF;
        unint64_t v38 = v37 >> 1;
        if (!v36) {
          unint64_t v38 = 0;
        }
        if (v38 >= a8) {
          unint64_t v38 = a8;
        }
        float32x4_t v39 = v26;
        if (v38 >= 4)
        {
          unint64_t v40 = 0;
          unint64_t v41 = v32 + 2 * v51 + 8;
          unint64_t v42 = 8;
          float32x4_t v39 = v26;
          while (1)
          {
            if (v41 > v28 || v42 > v28)
            {
LABEL_37:
              exception = __cxa_allocate_exception(8uLL);
              void *exception = -6;
            }
            if (v39 > (int16x8_t *)&a10->i8[a11]) {
              break;
            }
            v31.i64[0] = *(void *)(v41 - 8);
            int16x8_t v31 = vzip1q_s16(v31, v52);
            *v39++ = v31;
            unint64_t v34 = v40 + 4;
            v41 += 8;
            unint64_t v43 = v40 + 8;
            v42 += 8;
            v40 += 4;
            if (v43 > v38) {
              goto LABEL_27;
            }
          }
          unint64_t v34 = v40;
        }
LABEL_27:
        unint64_t v44 = v38 - v34;
        if (v38 > v34)
        {
          unint64_t v45 = v32 + 2 * v51 + 2 + 2 * v34;
          unint64_t v46 = 2 * v34 + 2;
          do
          {
            if (v45 > v28 || v46 > v28) {
              goto LABEL_37;
            }
            __int16 v47 = *(_WORD *)(v45 - 2);
            int32x4_t v48 = (int16x8_t *)((char *)v39->i64 + 4);
            v39->i16[1] = v29;
            v39->i16[0] = v47;
            v45 += 2;
            v46 += 2;
            float32x4_t v39 = (int16x8_t *)((char *)v39 + 4);
            --v44;
          }
          while (v44);
          unint64_t v34 = v38;
          float32x4_t v39 = v48;
        }
        if (a8 > v34) {
          bzero(v39, 4 * (a8 - v34));
        }
      }
      unint64_t v26 = (int16x8_t *)((char *)v26 + a11);
      v25 += a9;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read2_NoCompression<unsigned int,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unint64_t a8, unsigned int a9, int32x4_t *a10, uint64_t a11)
{
  uint64_t v15 = *(void *)(a4 + 24);
  uint64_t v51 = *(unsigned int *)(a4 + 44);
  uint64_t v54 = v15;
  int32x4_t v55 = *(ChannelDescription **)(a5 + 8);
  unsigned int v53 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v55, (*(_DWORD *)(a4 + 52) + HIDWORD(v15) * *(_DWORD *)(a3 + 60)), v15, v53);
  uint64_t v16 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v16;
  }
  else {
    _D0 = NAN;
  }
  int v18 = *(_DWORD *)(v16 + 16);
  if (v18 == 2)
  {
    *(float *)&unsigned int v19 = _D0;
  }
  else if (v18 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    LOWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    unsigned int v19 = v58;
  }
  else
  {
    unsigned int v19 = _D0;
  }
  unint64_t v24 = *(void *)(a3 + 56);
  uint64_t v25 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v25 < HIDWORD(v24))
  {
    unint64_t v26 = a10;
    unsigned int v27 = v19;
    int v28 = *(_DWORD *)(a4 + 28) * HIDWORD(v24);
    unint64_t v50 = a1 + a2;
    unint64_t v29 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    int32x4_t v52 = vdupq_n_s32(v19);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v55, (v28 + v25), v54, v53);
      uint64_t v31 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v31 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v33 = 0;
        unint64_t v34 = v31 + 4 * v51;
        _CF = v50 >= v34;
        unint64_t v36 = v50 - v34;
        BOOL v35 = v36 != 0 && _CF;
        unint64_t v37 = v36 >> 2;
        if (!v35) {
          unint64_t v37 = 0;
        }
        if (v37 >= a8) {
          unint64_t v37 = a8;
        }
        unint64_t v38 = v26;
        if (v37 >= 4)
        {
          unint64_t v39 = 0;
          unint64_t v40 = v31 + 4 * v51 + 16;
          unint64_t v41 = 16;
          unint64_t v42 = v26;
          while (1)
          {
            if (v40 > v29 || v41 > v29)
            {
LABEL_37:
              exception = __cxa_allocate_exception(8uLL);
              void *exception = -6;
            }
            if (v42 > (int32x4_t *)&a10->i8[a11]) {
              break;
            }
            int32x4_t v43 = *(int32x4_t *)(v40 - 16);
            unint64_t v38 = v42 + 2;
            unint64_t v33 = v39 + 4;
            v40 += 16;
            unint64_t v44 = v39 + 8;
            *unint64_t v42 = vzip1q_s32(v43, v52);
            v42[1] = vzip2q_s32(v43, v52);
            v41 += 16;
            v39 += 4;
            v42 += 2;
            if (v44 > v37) {
              goto LABEL_27;
            }
          }
          unint64_t v33 = v39;
          unint64_t v38 = v42;
        }
LABEL_27:
        unint64_t v45 = v37 - v33;
        if (v37 > v33)
        {
          unint64_t v46 = v31 + 4 * v51 + 4 + 4 * v33;
          unint64_t v47 = 4 * v33 + 4;
          do
          {
            if (v46 > v29 || v47 > v29) {
              goto LABEL_37;
            }
            LODWORD(v48) = *(_DWORD *)(v46 - 4);
            HIDWORD(v48) = v27;
            v38->i64[0] = v48;
            unint64_t v38 = (int32x4_t *)((char *)v38 + 8);
            v46 += 4;
            v47 += 4;
            --v45;
          }
          while (v45);
          unint64_t v33 = v37;
        }
        if (a8 > v33) {
          bzero(v38, 8 * (a8 - v33));
        }
      }
      unint64_t v26 = (int32x4_t *)((char *)v26 + a11);
      v25 += a9;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read2_NoCompression<unsigned short,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int a9, int8x16_t *a10, uint64_t a11)
{
  uint64_t v14 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v14;
  }
  else {
    _D0 = NAN;
  }
  int v16 = *(_DWORD *)(v14 + 16);
  if (v16 == 2)
  {
    *(float *)&unsigned int v17 = _D0;
  }
  else if (v16 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    LOWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    unsigned int v17 = v58;
  }
  else
  {
    unsigned int v17 = _D0;
  }
  uint64_t v22 = *(void *)(a4 + 24);
  unsigned int v23 = *(_DWORD *)(a4 + 60);
  uint64_t v50 = *(unsigned int *)(a4 + 44);
  uint64_t v51 = v22;
  int32x4_t v52 = *(ChannelDescription **)(a6 + 8);
  ChannelDescription::GetLocationForTile(v52, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v23);
  unint64_t v25 = *(void *)(a3 + 56);
  uint64_t v26 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v26 < HIDWORD(v25))
  {
    unsigned int v27 = a10;
    int v28 = *(_DWORD *)(a4 + 28) * HIDWORD(v25);
    unint64_t v49 = a1 + a2;
    unint64_t v29 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    int16x8_t v30 = vdupq_n_s16(v17);
    do
    {
      int16x8_t v55 = v30;
      long long v56 = v24;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v52, (v28 + v26), v51, v23);
      int16x8_t v30 = v55;
      long long v24 = v56;
      uint64_t v32 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v32 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v34 = 0;
        unint64_t v35 = v32 + 2 * v50;
        _CF = v49 >= v35;
        unint64_t v37 = v49 - v35;
        BOOL v36 = v37 != 0 && _CF;
        unint64_t v38 = v37 >> 1;
        if (!v36) {
          unint64_t v38 = 0;
        }
        if (a8 < v38) {
          unint64_t v38 = a8;
        }
        unint64_t v39 = v27;
        if (v38 >= 4)
        {
          unint64_t v40 = 0;
          unint64_t v41 = v32 + 2 * v50 + 8;
          unint64_t v42 = 8;
          unint64_t v39 = v27;
          while (1)
          {
            if (v42 > v29 || v41 > v29)
            {
LABEL_37:
              exception = __cxa_allocate_exception(8uLL);
              void *exception = -6;
            }
            if (v39 > (int8x16_t *)&a10->i8[a11]) {
              break;
            }
            *(void *)&long long v24 = *(void *)(v41 - 8);
            *v39++ = vqtbl2q_s8(*(int8x16x2_t *)(&v24 - 1), (int8x16_t)xmmword_228F41C10);
            unint64_t v34 = v40 + 4;
            v41 += 8;
            unint64_t v43 = v40 + 8;
            v42 += 8;
            v40 += 4;
            if (v43 > v38) {
              goto LABEL_27;
            }
          }
          unint64_t v34 = v40;
        }
LABEL_27:
        unint64_t v44 = v38 - v34;
        if (v38 > v34)
        {
          unint64_t v45 = 2 * v34 + 2;
          unint64_t v46 = v32 + 2 * v50 + 2 + 2 * v34;
          do
          {
            if (v45 > v29 || v46 > v29) {
              goto LABEL_37;
            }
            unint64_t v47 = (int8x16_t *)((char *)v39->i64 + 4);
            v39->i16[1] = *(_WORD *)(v46 - 2);
            v39->i16[0] = v17;
            v45 += 2;
            v46 += 2;
            unint64_t v39 = (int8x16_t *)((char *)v39 + 4);
            --v44;
          }
          while (v44);
          unint64_t v34 = v38;
          unint64_t v39 = v47;
        }
        if (a8 > v34)
        {
          long long v57 = v24;
          bzero(v39, 4 * (a8 - v34));
          int16x8_t v30 = v55;
          long long v24 = v57;
        }
      }
      unsigned int v27 = (int8x16_t *)((char *)v27 + a11);
      v26 += a9;
    }
    while (v26 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read2_NoCompression<unsigned int,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int a9, int32x4_t *a10, uint64_t a11)
{
  uint64_t v14 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v14;
  }
  else {
    _D0 = NAN;
  }
  int v16 = *(_DWORD *)(v14 + 16);
  if (v16 == 2)
  {
    float v17 = _D0;
  }
  else if (v16 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    LOWORD(vAXRBufferPool::FreeBuffers(this + 58) = _H0;
    float v17 = v58;
  }
  else
  {
    LODWORD(v17) = _D0;
  }
  unsigned int v51 = LODWORD(v17);
  uint64_t v22 = *(void *)(a4 + 24);
  unsigned int v23 = *(_DWORD *)(a4 + 60);
  uint64_t v52 = *(unsigned int *)(a4 + 44);
  uint64_t v54 = v22;
  int16x8_t v55 = *(ChannelDescription **)(a6 + 8);
  ChannelDescription::GetLocationForTile(v55, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v23);
  unint64_t v24 = *(void *)(a3 + 56);
  uint64_t v25 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v25 < HIDWORD(v24))
  {
    uint64_t v26 = a10;
    int v27 = *(_DWORD *)(a4 + 28) * HIDWORD(v24);
    unint64_t v50 = a1 + a2;
    unint64_t v28 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    int32x4_t v29 = vdupq_n_s32(v51);
    int32x4_t v53 = vuzp1q_s32(v29, v29);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v55, (v27 + v25), v54, v23);
      uint64_t v31 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v31 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v33 = 0;
        unint64_t v34 = v31 + 4 * v52;
        _CF = v50 >= v34;
        unint64_t v36 = v50 - v34;
        BOOL v35 = v36 != 0 && _CF;
        unint64_t v37 = v36 >> 2;
        if (!v35) {
          unint64_t v37 = 0;
        }
        if (a8 < v37) {
          unint64_t v37 = a8;
        }
        unint64_t v38 = v26;
        if (v37 >= 4)
        {
          unint64_t v39 = 0;
          unint64_t v40 = v31 + 4 * v52 + 16;
          unint64_t v41 = 16;
          unint64_t v42 = v26;
          while (1)
          {
            if (v41 > v28 || v40 > v28)
            {
LABEL_37:
              exception = __cxa_allocate_exception(8uLL);
              void *exception = -6;
            }
            if (v42 > (int32x4_t *)&a10->i8[a11]) {
              break;
            }
            int32x4_t v43 = *(int32x4_t *)(v40 - 16);
            unint64_t v38 = v42 + 2;
            unint64_t v33 = v39 + 4;
            v40 += 16;
            unint64_t v44 = v39 + 8;
            *unint64_t v42 = vzip1q_s32(v53, v43);
            v42[1] = vzip2q_s32(v53, v43);
            v41 += 16;
            v39 += 4;
            v42 += 2;
            if (v44 > v37) {
              goto LABEL_27;
            }
          }
          unint64_t v33 = v39;
          unint64_t v38 = v42;
        }
LABEL_27:
        unint64_t v45 = v37 - v33;
        if (v37 > v33)
        {
          unint64_t v46 = 4 * v33 + 4;
          unint64_t v47 = v31 + 4 * v52 + 4 + 4 * v33;
          do
          {
            if (v46 > v28 || v47 > v28) {
              goto LABEL_37;
            }
            LODWORD(v48) = v51;
            HIDWORD(v48) = *(_DWORD *)(v47 - 4);
            v38->i64[0] = v48;
            unint64_t v38 = (int32x4_t *)((char *)v38 + 8);
            v46 += 4;
            v47 += 4;
            --v45;
          }
          while (v45);
          unint64_t v33 = v37;
        }
        if (a8 > v33) {
          bzero(v38, 8 * (a8 - v33));
        }
      }
      uint64_t v26 = (int32x4_t *)((char *)v26 + a11);
      v25 += a9;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read2_NoCompression<unsigned short,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int a9, int16x8_t *a10, uint64_t a11)
{
  uint64_t v17 = *(void *)(a4 + 24);
  uint64_t v49 = *(unsigned int *)(a4 + 44);
  uint64_t v55 = v17;
  long long v56 = *(ChannelDescription **)(a5 + 8);
  unsigned int v54 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v56, (*(_DWORD *)(a4 + 52) + HIDWORD(v17) * *(_DWORD *)(a3 + 60)), v17, v54);
  uint64_t v18 = *(void *)(a4 + 24);
  uint64_t v48 = *(unsigned int *)(a4 + 44);
  uint64_t v52 = v18;
  int32x4_t v53 = *(ChannelDescription **)(a6 + 8);
  unsigned int v51 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v53, (*(_DWORD *)(a4 + 52) + HIDWORD(v18) * *(_DWORD *)(a3 + 60)), v18, v51);
  unint64_t v19 = *(void *)(a3 + 56);
  uint64_t v20 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v20 < HIDWORD(v19))
  {
    int v21 = a10;
    int v50 = *(_DWORD *)(a4 + 28) * HIDWORD(v19);
    unint64_t v47 = a1 + a2;
    unint64_t v22 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    do
    {
      unint64_t v23 = (v50 + v20);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v56, v23, v55, v54);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v25 = LocationForTile;
        unint64_t v26 = ChannelDescription::GetLocationForTile(v53, v23, v52, v51);
        if (HIDWORD(v26))
        {
          uint64_t v29 = a1 + v25;
          uint64_t v30 = a1 + v26;
          if (v29 && v30 != 0)
          {
            unint64_t v32 = 0;
            unint64_t v33 = v29 + 2 * v49;
            unint64_t v34 = v30 + 2 * v48;
            unint64_t v35 = (v47 - v33) >> 1;
            if (v47 <= v33) {
              unint64_t v35 = 0;
            }
            if (v35 >= a8) {
              unint64_t v35 = a8;
            }
            unint64_t v36 = (v47 - v34) >> 1;
            if (v47 <= v34) {
              unint64_t v36 = 0;
            }
            if (v35 >= v36) {
              unint64_t v35 = v36;
            }
            unint64_t v37 = v21;
            if (v35 >= 4)
            {
              unint64_t v38 = 0;
              unint64_t v39 = v29 + 2 * v49 + 8;
              unint64_t v40 = v30 + 2 * v48 + 8;
              unint64_t v37 = v21;
              while (1)
              {
                if (v39 > v22 || v40 > v22)
                {
LABEL_37:
                  exception = __cxa_allocate_exception(8uLL);
                  void *exception = -6;
                }
                if (v37 > (int16x8_t *)&a10->i8[a11]) {
                  break;
                }
                v27.i64[0] = *(void *)(v39 - 8);
                v28.i64[0] = *(void *)(v40 - 8);
                int16x8_t v27 = vzip1q_s16(v27, v28);
                *v37++ = v27;
                unint64_t v32 = v38 + 4;
                v39 += 8;
                v40 += 8;
                unint64_t v41 = v38 + 8;
                v38 += 4;
                if (v41 > v35) {
                  goto LABEL_25;
                }
              }
              unint64_t v32 = v38;
            }
LABEL_25:
            unint64_t v42 = v35 - v32;
            if (v35 > v32)
            {
              uint64_t v43 = 2 * v32;
              do
              {
                if (v33 + v43 + 2 > v22 || v34 + v43 + 2 > v22) {
                  goto LABEL_37;
                }
                __int16 v44 = *(_WORD *)(v33 + v43);
                unint64_t v45 = (int16x8_t *)((char *)v37->i64 + 4);
                v37->i16[1] = *(_WORD *)(v34 + v43);
                v37->i16[0] = v44;
                v33 += 2;
                v34 += 2;
                unint64_t v37 = (int16x8_t *)((char *)v37 + 4);
                --v42;
              }
              while (v42);
              unint64_t v32 = v35;
              unint64_t v37 = v45;
            }
            if (a8 > v32) {
              bzero(v37, 4 * (a8 - v32));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v53, v23, v52, v51);
      }
      int v21 = (int16x8_t *)((char *)v21 + a11);
      v20 += a9;
    }
    while (v20 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read2_NoCompression<unsigned int,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int a9, int32x4_t *a10, uint64_t a11)
{
  uint64_t v17 = *(void *)(a4 + 24);
  uint64_t v49 = *(unsigned int *)(a4 + 44);
  uint64_t v55 = v17;
  long long v56 = *(ChannelDescription **)(a5 + 8);
  unsigned int v54 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v56, (*(_DWORD *)(a4 + 52) + HIDWORD(v17) * *(_DWORD *)(a3 + 60)), v17, v54);
  uint64_t v18 = *(void *)(a4 + 24);
  uint64_t v48 = *(unsigned int *)(a4 + 44);
  uint64_t v52 = v18;
  int32x4_t v53 = *(ChannelDescription **)(a6 + 8);
  unsigned int v51 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v53, (*(_DWORD *)(a4 + 52) + HIDWORD(v18) * *(_DWORD *)(a3 + 60)), v18, v51);
  unint64_t v19 = *(void *)(a3 + 56);
  uint64_t v20 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v20 < HIDWORD(v19))
  {
    int v21 = a10;
    int v50 = *(_DWORD *)(a4 + 28) * HIDWORD(v19);
    unint64_t v47 = a1 + a2;
    unint64_t v22 = *(void *)(a3 + 32) + *(void *)(a3 + 40);
    do
    {
      unint64_t v23 = (v50 + v20);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v56, v23, v55, v54);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v25 = LocationForTile;
        unint64_t v26 = ChannelDescription::GetLocationForTile(v53, v23, v52, v51);
        if (HIDWORD(v26))
        {
          uint64_t v27 = a1 + v25;
          uint64_t v28 = a1 + v26;
          if (v27 && v28 != 0)
          {
            unint64_t v30 = 0;
            unint64_t v31 = v27 + 4 * v49;
            unint64_t v32 = v28 + 4 * v48;
            unint64_t v33 = (v47 - v31) >> 2;
            if (v47 <= v31) {
              unint64_t v33 = 0;
            }
            if (v33 >= a8) {
              unint64_t v33 = a8;
            }
            unint64_t v34 = (v47 - v32) >> 2;
            if (v47 <= v32) {
              unint64_t v34 = 0;
            }
            if (v33 >= v34) {
              unint64_t v33 = v34;
            }
            unint64_t v35 = v21;
            if (v33 >= 4)
            {
              unint64_t v36 = 0;
              unint64_t v37 = v27 + 4 * v49 + 16;
              unint64_t v38 = v28 + 4 * v48 + 16;
              unint64_t v39 = v21;
              while (1)
              {
                if (v37 > v22 || v38 > v22)
                {
LABEL_37:
                  exception = __cxa_allocate_exception(8uLL);
                  void *exception = -6;
                }
                if (v39 > (int32x4_t *)&a10->i8[a11]) {
                  break;
                }
                int32x4_t v40 = *(int32x4_t *)(v37 - 16);
                int32x4_t v41 = *(int32x4_t *)(v38 - 16);
                unint64_t v35 = v39 + 2;
                *unint64_t v39 = vzip1q_s32(v40, v41);
                v39[1] = vzip2q_s32(v40, v41);
                unint64_t v30 = v36 + 4;
                v37 += 16;
                v38 += 16;
                unint64_t v42 = v36 + 8;
                v36 += 4;
                v39 += 2;
                if (v42 > v33) {
                  goto LABEL_25;
                }
              }
              unint64_t v30 = v36;
              unint64_t v35 = v39;
            }
LABEL_25:
            unint64_t v43 = v33 - v30;
            if (v33 > v30)
            {
              uint64_t v44 = 4 * v30;
              do
              {
                if (v31 + v44 + 4 > v22 || v32 + v44 + 4 > v22) {
                  goto LABEL_37;
                }
                LODWORD(v45) = *(_DWORD *)(v31 + v44);
                HIDWORD(v45) = *(_DWORD *)(v32 + v44);
                v35->i64[0] = v45;
                unint64_t v35 = (int32x4_t *)((char *)v35 + 8);
                v31 += 4;
                v32 += 4;
                --v43;
              }
              while (v43);
              unint64_t v30 = v33;
            }
            if (a8 > v30) {
              bzero(v35, 8 * (a8 - v30));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v53, v23, v52, v51);
      }
      int v21 = (int32x4_t *)((char *)v21 + a11);
      v20 += a9;
    }
    while (v20 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int8x16_t *a12, uint64_t a13)
{
  uint64_t v13 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v13;
  }
  else {
    _D0 = NAN;
  }
  int v15 = *(_DWORD *)(v13 + 16);
  if (v15 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v15 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v49) = _H0;
    LOWORD(v49) = _H0;
    LODWORD(_D0) = v49;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  uint64_t v21 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D1 = *(double *)v21;
  }
  else {
    _D1 = NAN;
  }
  int v23 = *(_DWORD *)(v21 + 16);
  if (v23 == 2)
  {
    *(float *)&_D1 = _D1;
  }
  else if (v23 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v50) = _H1;
    LOWORD(v50) = _H1;
    LODWORD(_D1) = v50;
  }
  else
  {
    LODWORD(_D1) = _D1;
    if (v23) {
      *(float *)&_D1 = *(float *)&_D0;
    }
  }
  uint64_t v25 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D2 = *(double *)v25;
  }
  else {
    _D2 = NAN;
  }
  int v27 = *(_DWORD *)(v25 + 16);
  if (v27 == 2)
  {
    *(float *)&unsigned int v28 = _D2;
  }
  else if (v27 == 1)
  {
    __asm { FCVT            H2, D2 }
    HIWORD(v51) = _H2;
    LOWORD(v51) = _H2;
    unsigned int v28 = v51;
  }
  else
  {
    unsigned int v28 = _D2;
    if (v27) {
      unsigned int v28 = LODWORD(_D0);
    }
  }
  uint64_t v30 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D3 = *(double *)v30;
  }
  else {
    _D3 = NAN;
  }
  int v32 = *(_DWORD *)(v30 + 16);
  if (v32 == 2)
  {
    float v33 = _D3;
  }
  else if (v32 == 1)
  {
    __asm { FCVT            H3, D3 }
    HIWORD(vAXRBufferPool::FreeBuffers(this + 52) = _H3;
    LOWORD(vAXRBufferPool::FreeBuffers(this + 52) = _H3;
    float v33 = v52;
  }
  else
  {
    LODWORD(v33) = _D3;
    if (v32) {
      float v33 = *(float *)&_D0;
    }
  }
  uint64_t v35 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v35 < *(unsigned int *)(a3 + 60))
  {
    v53.val[0] = (int8x16_t)vdupq_n_s16(LODWORD(_D0));
    *((float *)&_D1 + 1) = v33;
    __int16 v37 = v28;
    v53.val[1] = (int8x16_t)vdupq_n_s16(v28);
    int8x16_t v38 = vqtbl2q_s8(v53, (int8x16_t)xmmword_228F41C10);
    v53.val[0] = (int8x16_t)vdupq_lane_s16(*(int16x4_t *)&_D1, 2);
    v53.val[1] = (int8x16_t)vdupq_lane_s16(*(int16x4_t *)&_D1, 0);
    int8x16_t v39 = v53.val[0];
    int8x16_t v40 = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v53 + 16), (int8x16_t)xmmword_228F41B50);
    v53.val[1] = vqtbl2q_s8(v53, (int8x16_t)xmmword_228F62B70);
    int8x16_t v41 = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v53 + 16), (int8x16_t)xmmword_228F62BC0);
    v53.val[1] = vqtbl2q_s8(v53, (int8x16_t)xmmword_228F62B50);
    int8x16_t v42 = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v53 + 16), (int8x16_t)xmmword_228F62BD0);
    WORD1(_D0) = LOWORD(_D1);
    WORD2(_D0) = v37;
    HIWORD(_D0) = WORD2(_D1);
    do
    {
      if (a10 >= 4)
      {
        uint64_t v45 = 0;
        unint64_t v46 = a12;
        do
        {
          i64 = (double *)v46[2].i64;
          *unint64_t v46 = v42;
          v46[1] = v41;
          unint64_t v43 = v45 + 4;
          unint64_t v47 = v45 + 8;
          v45 += 4;
          v46 += 2;
        }
        while (v47 <= a10);
      }
      else
      {
        unint64_t v43 = 0;
        i64 = (double *)a12;
      }
      _CF = a10 >= v43;
      unint64_t v48 = a10 - v43;
      if (v48 != 0 && _CF)
      {
        do
        {
          *i64++ = _D0;
          --v48;
        }
        while (v48);
      }
      a12 = (int8x16_t *)((char *)a12 + a13);
      v35 += a11;
    }
    while (v35 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, _OWORD *a12, uint64_t a13)
{
  uint64_t v13 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    *(void *)&_Q0 = *(void *)v13;
  }
  else {
    *(void *)&_Q0 = 0x7FF8000000000000;
  }
  int v15 = *(_DWORD *)(v13 + 16);
  if (v15 == 2)
  {
    *(float *)&_Q0 = *(double *)&_Q0;
  }
  else if (v15 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v44) = _H0;
    LOWORD(v44) = _H0;
    LODWORD(_Q0) = v44;
  }
  else
  {
    LODWORD(_Q0) = *(double *)&_Q0;
  }
  uint64_t v21 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D1 = *(double *)v21;
  }
  else {
    _D1 = NAN;
  }
  int v23 = *(_DWORD *)(v21 + 16);
  if (v23 == 2)
  {
    float v24 = _D1;
  }
  else if (v23 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v45) = _H1;
    LOWORD(v45) = _H1;
    float v24 = v45;
  }
  else
  {
    LODWORD(v24) = _D1;
    if (v23) {
      float v24 = *(float *)&_Q0;
    }
  }
  uint64_t v26 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D2 = *(double *)v26;
  }
  else {
    _D2 = NAN;
  }
  int v28 = *(_DWORD *)(v26 + 16);
  if (v28 == 2)
  {
    float v29 = _D2;
  }
  else if (v28 == 1)
  {
    __asm { FCVT            H2, D2 }
    HIWORD(v46) = _H2;
    LOWORD(v46) = _H2;
    float v29 = v46;
  }
  else
  {
    LODWORD(v29) = _D2;
    if (v28) {
      float v29 = *(float *)&_Q0;
    }
  }
  uint64_t v31 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D3 = *(double *)v31;
  }
  else {
    _D3 = NAN;
  }
  int v33 = *(_DWORD *)(v31 + 16);
  if (v33 == 2)
  {
    float v34 = _D3;
  }
  else if (v33 == 1)
  {
    __asm { FCVT            H3, D3 }
    HIWORD(v47) = _H3;
    LOWORD(v47) = _H3;
    float v34 = v47;
  }
  else
  {
    LODWORD(v34) = _D3;
    if (v33) {
      float v34 = *(float *)&_Q0;
    }
  }
  uint64_t v36 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v36 < *(unsigned int *)(a3 + 60))
  {
    *((float *)&_Q0 + 1) = v24;
    *((void *)&_Q0 + 1) = __PAIR64__(LODWORD(v34), LODWORD(v29));
    do
    {
      if (a10 >= 4)
      {
        uint64_t v40 = 0;
        int8x16_t v41 = a12;
        do
        {
          int8x16_t v39 = v41 + 4;
          *int8x16_t v41 = _Q0;
          v41[1] = _Q0;
          v41[2] = _Q0;
          void v41[3] = _Q0;
          unint64_t v38 = v40 + 4;
          unint64_t v42 = v40 + 8;
          v40 += 4;
          v41 += 4;
        }
        while (v42 <= a10);
      }
      else
      {
        unint64_t v38 = 0;
        int8x16_t v39 = a12;
      }
      _CF = a10 >= v38;
      unint64_t v43 = a10 - v38;
      if (v43 != 0 && _CF)
      {
        do
        {
          *v39++ = _Q0;
          --v43;
        }
        while (v43);
      }
      a12 = (_OWORD *)((char *)a12 + a13);
      v36 += a11;
    }
    while (v36 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int16x8_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v62 = *(unsigned int *)(a4 + 44);
  uint64_t v65 = v19;
  int32x4_t v66 = *(ChannelDescription **)(a5 + 8);
  unsigned int v64 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v66, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v64);
  uint64_t v20 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v20;
  }
  else {
    _D0 = NAN;
  }
  int v22 = *(_DWORD *)(v20 + 16);
  if (v22 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v22 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v68) = _H0;
    LOWORD(v68) = _H0;
    LODWORD(_D0) = v68;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  uint64_t v27 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D1 = *(double *)v27;
  }
  else {
    _D1 = NAN;
  }
  int v29 = *(_DWORD *)(v27 + 16);
  if (v29 == 2)
  {
    *(float *)&unsigned int v30 = _D1;
  }
  else if (v29 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v69) = _H1;
    LOWORD(v69) = _H1;
    unsigned int v30 = v69;
  }
  else
  {
    unsigned int v30 = _D1;
    if (v29) {
      unsigned int v30 = LODWORD(_D0);
    }
  }
  uint64_t v32 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D2 = *(double *)v32;
  }
  else {
    _D2 = NAN;
  }
  int v34 = *(_DWORD *)(v32 + 16);
  if (v34 == 2)
  {
    float v35 = _D2;
  }
  else if (v34 == 1)
  {
    __asm { FCVT            H2, D2 }
    HIWORD(v70) = _H2;
    LOWORD(v70) = _H2;
    float v35 = v70;
  }
  else
  {
    LODWORD(v35) = _D2;
    if (v34) {
      float v35 = *(float *)&_D0;
    }
  }
  unint64_t v37 = *(void *)(a3 + 56);
  uint64_t v38 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v38 < HIDWORD(v37))
  {
    int v40 = *(_DWORD *)(a4 + 28) * HIDWORD(v37);
    unint64_t v41 = a1 + a2;
    *((float *)&_D0 + 1) = v35;
    __int16 v42 = v30;
    int16x8_t v61 = vdupq_n_s16(v30);
    int16x4_t v43 = vuzp1_s16(*(int16x4_t *)&_D0, *(int16x4_t *)&_D0);
    v71.val[1] = (int8x16_t)vdupq_lane_s16(*(int16x4_t *)&_D0, 0);
    v71.val[0] = (int8x16_t)vdupq_lane_s16(*(int16x4_t *)&_D0, 2);
    int16x8_t v63 = (int16x8_t)vqtbl2q_s8(v71, (int8x16_t)xmmword_228F62BB0);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v66, (v40 + v38), v65, v64);
      uint64_t v46 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v46 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v48 = 0;
        int v49 = (uint64_t *)(v46 + 2 * v62);
        unint64_t v50 = (v41 - (unint64_t)v49) >> 1;
        if (v41 <= (unint64_t)v49) {
          unint64_t v50 = 0;
        }
        if (v50 >= a10) {
          unint64_t v50 = a10;
        }
        unsigned int v51 = a12;
        if (v50 >= 4)
        {
          uint64_t v52 = 0;
          int8x16x2_t v53 = a12;
          do
          {
            uint64_t v54 = *v49++;
            v45.i64[0] = v54;
            int16x8_t v55 = vzip1q_s16(v45, v61);
            int16x8_t v56 = vzip1q_s16(v55, v63);
            int16x8_t v45 = vzip2q_s16(v55, v63);
            unsigned int v51 = v53 + 2;
            int16x8_t *v53 = v56;
            v53[1] = v45;
            unint64_t v48 = v52 + 4;
            unint64_t v57 = v52 + 8;
            v52 += 4;
            v53 += 2;
          }
          while (v57 <= v50);
        }
        unint64_t v58 = v50 - v48;
        if (v50 > v48)
        {
          axr_decoder_t v59 = (unsigned __int16 *)(v46 + 2 * v62 + 2 * v48);
          do
          {
            __int32 v60 = *v59++;
            v45.i32[0] = v60;
            v45.i16[2] = v42;
            *(int16x4_t *)v45.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v45.i8, *(int16x4_t *)v45.i8), v43);
            v51->i64[0] = v45.i64[0];
            unsigned int v51 = (int16x8_t *)((char *)v51 + 8);
            --v58;
          }
          while (v58);
          unint64_t v48 = v50;
        }
        if (a10 > v48) {
          bzero(v51, 8 * (a10 - v48));
        }
      }
      a12 = (int16x8_t *)((char *)a12 + a13);
      v38 += a11;
    }
    while (v38 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v66 = *(unsigned int *)(a4 + 44);
  uint64_t v70 = v19;
  int8x16x2_t v71 = *(ChannelDescription **)(a5 + 8);
  unsigned int v69 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v71, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v69);
  uint64_t v21 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v21;
  }
  else {
    _D0 = NAN;
  }
  int v23 = *(_DWORD *)(v21 + 16);
  if (v23 == 2)
  {
    *(float *)v20.i32 = _D0;
  }
  else if (v23 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v73) = _H0;
    LOWORD(v73) = _H0;
    v20.i32[0] = v73;
  }
  else
  {
    v20.i32[0] = _D0;
  }
  uint64_t v28 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v28;
  }
  else {
    _D0 = NAN;
  }
  int v30 = *(_DWORD *)(v28 + 16);
  if (v30 == 2)
  {
    *(float *)&unsigned int v31 = _D0;
  }
  else if (v30 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v74) = _H0;
    LOWORD(v74) = _H0;
    unsigned int v31 = v74;
  }
  else
  {
    unsigned int v31 = _D0;
  }
  uint64_t v33 = *a8;
  int32x4_t v34 = v20;
  if (*(unsigned char *)(*a8 + 24)) {
    _D1 = *(double *)v33;
  }
  else {
    _D1 = NAN;
  }
  int v36 = *(_DWORD *)(v33 + 16);
  if (v36 == 2)
  {
    float v37 = _D1;
  }
  else if (v36 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v75) = _H1;
    LOWORD(v75) = _H1;
    float v37 = v75;
  }
  else
  {
    LODWORD(v37) = _D1;
    if (v36) {
      float v37 = *(float *)&v31;
    }
  }
  unint64_t v39 = *(void *)(a3 + 56);
  uint64_t v40 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v40 < HIDWORD(v39))
  {
    unsigned int v42 = v31;
    int v43 = *(_DWORD *)(a4 + 28) * HIDWORD(v39);
    unint64_t v44 = a1 + a2;
    *(float *)&v34.i32[1] = v37;
    int32x4_t v65 = v34;
    v45.i64[0] = v34.i64[0];
    v45.i64[1] = __PAIR64__(LODWORD(v37), v34.u32[0]);
    int32x4_t v67 = v45;
    int32x4_t v68 = vdupq_n_s32(v31);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v71, (v43 + v40), v70, v69);
      uint64_t v48 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v48 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v50 = 0;
        unsigned int v51 = (int32x4_t *)(v48 + 4 * v66);
        unint64_t v52 = (v44 - (unint64_t)v51) >> 2;
        if (v44 <= (unint64_t)v51) {
          unint64_t v52 = 0;
        }
        if (v52 >= a10) {
          unint64_t v52 = a10;
        }
        int8x16x2_t v53 = a12;
        if (v52 >= 4)
        {
          uint64_t v54 = 0;
          int16x8_t v55 = a12;
          do
          {
            int32x4_t v56 = *v51++;
            int32x4_t v57 = v68;
            v57.i32[0] = v56.i32[2];
            int32x4_t v58 = vuzp1q_s32(v56, v68);
            int32x4_t v59 = vuzp2q_s32(v56, v68);
            int32x4_t v60 = vtrn2q_s32(v59, v56);
            int32x4_t v47 = vzip2q_s32(vuzp1q_s32(v60, v60), v67);
            int8x16x2_t v53 = v55 + 4;
            int32x4_t *v55 = vzip1q_s32(vuzp1q_s32(v58, v58), v67);
            v55[1] = vzip2q_s32(vuzp1q_s32(v59, v59), v67);
            v55[2] = vzip1q_s32(vuzp1q_s32(v57, v57), v67);
            v55[3] = v47;
            unint64_t v50 = v54 + 4;
            unint64_t v61 = v54 + 8;
            v54 += 4;
            v55 += 4;
          }
          while (v61 <= v52);
        }
        unint64_t v62 = v52 - v50;
        if (v52 > v50)
        {
          int16x8_t v63 = (__int32 *)(v48 + 4 * v66 + 4 * v50);
          do
          {
            __int32 v64 = *v63++;
            v47.i32[0] = v64;
            v47.i32[2] = v42;
            int32x4_t v47 = vzip1q_s32(vuzp1q_s32(v47, v47), v65);
            *v53++ = v47;
            --v62;
          }
          while (v62);
          unint64_t v50 = v52;
        }
        if (a10 > v50) {
          bzero(v53, 16 * (a10 - v50));
        }
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v40 += a11;
    }
    while (v40 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int8x16_t *a12, uint64_t a13)
{
  uint64_t v17 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v17;
  }
  else {
    _D0 = NAN;
  }
  int v19 = *(_DWORD *)(v17 + 16);
  if (v19 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v19 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v78) = _H0;
    LOWORD(v78) = _H0;
    LODWORD(_D0) = v78;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  int16x4_t v74 = *(int16x4_t *)&_D0;
  uint64_t v24 = *(void *)(a4 + 24);
  uint64_t v25 = v24;
  unsigned int v26 = *(_DWORD *)(a4 + 60);
  uint64_t v66 = *(unsigned int *)(a4 + 44);
  int32x4_t v68 = *(ChannelDescription **)(a6 + 8);
  ChannelDescription::GetLocationForTile(v68, (*(_DWORD *)(a4 + 52) + HIDWORD(v24) * *(_DWORD *)(a3 + 60)), v24, v26);
  uint64_t v29 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v29;
  }
  else {
    _D0 = NAN;
  }
  int v31 = *(_DWORD *)(v29 + 16);
  if (v31 == 2)
  {
    *(float *)&unsigned int v32 = _D0;
  }
  else if (v31 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v79) = _H0;
    LOWORD(v79) = _H0;
    unsigned int v32 = v79;
  }
  else
  {
    unsigned int v32 = _D0;
  }
  uint64_t v34 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D1 = *(double *)v34;
  }
  else {
    _D1 = NAN;
  }
  int v36 = *(_DWORD *)(v34 + 16);
  if (v36 == 2)
  {
    *(float *)&unsigned int v37 = _D1;
  }
  else if (v36 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v80) = _H1;
    LOWORD(v80) = _H1;
    unsigned int v37 = v80;
  }
  else
  {
    unsigned int v37 = _D1;
    if (v36) {
      unsigned int v37 = v32;
    }
  }
  unint64_t v39 = *(void *)(a3 + 56);
  uint64_t v40 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v40 < HIDWORD(v39))
  {
    int v42 = *(_DWORD *)(a4 + 28) * HIDWORD(v39);
    int16x4_t v43 = v74;
    v81.val[0] = (int8x16_t)vdupq_n_s16(v74.u32[0]);
    unint64_t v65 = a1 + a2;
    __int16 v44 = v32;
    v81.val[1] = (int8x16_t)vdupq_n_s16(v32);
    int16x8_t v45 = (int16x8_t)vqtbl2q_s8(v81, (int8x16_t)xmmword_228F41C10);
    __int16 v46 = v37;
    int16x8_t v47 = vzip2q_s16(v45, v45);
    int16x8_t v48 = vzip1q_s16(v45, v45);
    v43.i16[2] = v44;
    int16x4_t v49 = vuzp1_s16(v43, v43);
    int16x8_t v67 = vdupq_n_s16(v37);
    do
    {
      int16x8_t v71 = v48;
      int16x8_t v72 = v28;
      int16x8_t v75 = v47;
      int16x8_t v76 = v27;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v68, (v42 + v40), v25, v26);
      int16x8_t v48 = v71;
      int16x8_t v28 = v72;
      int16x8_t v47 = v75;
      int16x8_t v27 = v76;
      uint64_t v52 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v52 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v54 = 0;
        int16x8_t v55 = (uint64_t *)(v52 + 2 * v66);
        unint64_t v56 = (v65 - (unint64_t)v55) >> 1;
        if (v65 <= (unint64_t)v55) {
          unint64_t v56 = 0;
        }
        if (a10 < v56) {
          unint64_t v56 = a10;
        }
        int32x4_t v57 = a12;
        if (v56 >= 4)
        {
          uint64_t v58 = 0;
          int32x4_t v59 = a12;
          do
          {
            uint64_t v60 = *v55++;
            v51.i64[0] = v60;
            int16x8_t v28 = vzip1q_s16(v51, v67);
            int16x8_t v51 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v28 - 1), (int8x16_t)xmmword_228F41C10);
            int16x8_t v27 = v28;
            int32x4_t v57 = v59 + 2;
            *int32x4_t v59 = (int8x16_t)v51;
            v59[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v27 - 1), (int8x16_t)xmmword_228F41BF0);
            unint64_t v54 = v58 + 4;
            unint64_t v61 = v58 + 8;
            v58 += 4;
            v59 += 2;
          }
          while (v61 <= v56);
        }
        unint64_t v62 = v56 - v54;
        if (v56 > v54)
        {
          int16x8_t v63 = (__int16 *)(v52 + 2 * v66 + 2 * v54);
          do
          {
            __int16 v64 = *v63++;
            v51.i16[0] = v64;
            v51.i16[1] = v46;
            *(int16x4_t *)v51.i8 = vzip1_s16(v49, *(int16x4_t *)v51.i8);
            v57->i64[0] = v51.i64[0];
            int32x4_t v57 = (int8x16_t *)((char *)v57 + 8);
            --v62;
          }
          while (v62);
          unint64_t v54 = v56;
        }
        if (a10 > v54)
        {
          int16x8_t v77 = v27;
          int16x8_t v73 = v28;
          bzero(v57, 8 * (a10 - v54));
          int16x8_t v48 = v71;
          int16x8_t v28 = v73;
          int16x8_t v47 = v75;
          int16x8_t v27 = v77;
        }
      }
      a12 = (int8x16_t *)((char *)a12 + a13);
      v40 += a11;
    }
    while (v40 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t *a8, __n128 _Q0, uint64_t a10, unint64_t a11, unsigned int a12, int32x4_t *a13, uint64_t a14)
{
  uint64_t v18 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _Q0.n128_u64[0] = *(void *)v18;
  }
  else {
    _Q0.n128_u64[0] = 0x7FF8000000000000;
  }
  int v19 = *(_DWORD *)(v18 + 16);
  if (v19 == 2)
  {
    _Q0.n128_f32[0] = _Q0.n128_f64[0];
  }
  else if (v19 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v72) = _H0;
    LOWORD(v72) = _H0;
    _Q0.n128_u32[0] = v72;
  }
  else
  {
    _Q0.n128_u32[0] = _Q0.n128_f64[0];
  }
  __n128 v69 = _Q0;
  uint64_t v24 = *(void *)(a4 + 24);
  uint64_t v25 = v24;
  unsigned int v26 = *(_DWORD *)(a4 + 60);
  uint64_t v65 = *(unsigned int *)(a4 + 44);
  int16x8_t v67 = *(ChannelDescription **)(a6 + 8);
  ChannelDescription::GetLocationForTile(v67, (*(_DWORD *)(a4 + 52) + HIDWORD(v24) * *(_DWORD *)(a3 + 60)), v24, v26);
  uint64_t v27 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v27;
  }
  else {
    _D0 = NAN;
  }
  int32x4_t v29 = (int32x4_t)v69;
  int v30 = *(_DWORD *)(v27 + 16);
  if (v30 == 2)
  {
    float v31 = _D0;
  }
  else if (v30 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v73) = _H0;
    LOWORD(v73) = _H0;
    float v31 = v73;
  }
  else
  {
    LODWORD(v31) = _D0;
  }
  uint64_t v33 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D1 = *(double *)v33;
  }
  else {
    _D1 = NAN;
  }
  int v35 = *(_DWORD *)(v33 + 16);
  if (v35 == 2)
  {
    *(float *)&unsigned int v36 = _D1;
  }
  else if (v35 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v74) = _H1;
    LOWORD(v74) = _H1;
    unsigned int v36 = v74;
  }
  else
  {
    unsigned int v36 = _D1;
    if (v35) {
      *(float *)&unsigned int v36 = v31;
    }
  }
  unint64_t v38 = *(void *)(a3 + 56);
  uint64_t v39 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v39 < HIDWORD(v38))
  {
    uint64_t v41 = a2;
    unsigned int v42 = v36;
    int v43 = *(_DWORD *)(a4 + 28) * HIDWORD(v38);
    unint64_t v64 = a1 + v41;
    *(float *)&v29.i32[2] = v31;
    int32x4_t v63 = vuzp1q_s32(v29, v29);
    int32x4_t v70 = v29;
    int32x4_t v66 = vdupq_n_s32(v36);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v67, (v43 + v39), v25, v26);
      uint64_t v46 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v46 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v48 = 0;
        int16x4_t v49 = (int32x4_t *)(v46 + 4 * v65);
        unint64_t v50 = (v64 - (unint64_t)v49) >> 2;
        if (v64 <= (unint64_t)v49) {
          unint64_t v50 = 0;
        }
        if (a11 < v50) {
          unint64_t v50 = a11;
        }
        int16x8_t v51 = a13;
        if (v50 >= 4)
        {
          uint64_t v52 = 0;
          int8x16x2_t v53 = a13;
          do
          {
            int32x4_t v54 = *v49++;
            v45.i64[1] = v54.i64[1];
            int32x4_t v55 = v70;
            v55.i32[1] = v54.i32[3];
            v55.i32[3] = v66.i32[3];
            int32x4_t v56 = v70;
            v56.i32[1] = v54.i32[2];
            v56.i32[3] = v66.i32[2];
            int32x4_t v57 = vtrn1q_s32(v70, v54);
            v57.i32[3] = v66.i32[0];
            int32x4_t v58 = v70;
            v58.i32[1] = v54.i32[1];
            v58.i32[3] = v66.i32[1];
            int16x8_t v51 = v53 + 4;
            int32x4_t *v53 = v57;
            v53[1] = v58;
            v53[2] = v56;
            v53[3] = v55;
            unint64_t v48 = v52 + 4;
            unint64_t v59 = v52 + 8;
            v52 += 4;
            v53 += 4;
          }
          while (v59 <= v50);
        }
        unint64_t v60 = v50 - v48;
        if (v50 > v48)
        {
          unint64_t v61 = (unsigned int *)(v46 + 4 * v65 + 4 * v48);
          do
          {
            unsigned int v62 = *v61++;
            v45.i64[0] = __PAIR64__(v42, v62);
            int32x4_t v45 = vzip1q_s32(v63, v45);
            *v51++ = v45;
            --v60;
          }
          while (v60);
          unint64_t v48 = v50;
        }
        if (a11 > v48) {
          bzero(v51, 16 * (a11 - v48));
        }
      }
      a13 = (int32x4_t *)((char *)a13 + a14);
      v39 += a12;
    }
    while (v39 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int8x16_t *a12, uint64_t a13)
{
  uint64_t v20 = *(void *)(a4 + 24);
  uint64_t v71 = *(unsigned int *)(a4 + 44);
  uint64_t v78 = v20;
  unsigned int v79 = *(ChannelDescription **)(a5 + 8);
  unsigned int v77 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a4 + 52) + HIDWORD(v20) * *(_DWORD *)(a3 + 60)), v20, v77);
  uint64_t v80 = a3;
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = v21;
  int16x8_t v76 = *(ChannelDescription **)(a6 + 8);
  unsigned int v74 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v74);
  uint64_t v23 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v23;
  }
  else {
    _D0 = NAN;
  }
  int v25 = *(_DWORD *)(v23 + 16);
  if (v25 == 2)
  {
    *(float *)&unsigned int v26 = _D0;
  }
  else if (v25 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v83) = _H0;
    LOWORD(v83) = _H0;
    unsigned int v26 = v83;
  }
  else
  {
    unsigned int v26 = _D0;
  }
  uint64_t v31 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D1 = *(double *)v31;
  }
  else {
    _D1 = NAN;
  }
  int v33 = *(_DWORD *)(v31 + 16);
  if (v33 == 2)
  {
    *(float *)&unsigned int v34 = _D1;
  }
  else if (v33 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v84) = _H1;
    LOWORD(v84) = _H1;
    unsigned int v34 = v84;
  }
  else
  {
    unsigned int v34 = _D1;
    if (v33) {
      unsigned int v34 = v26;
    }
  }
  unint64_t v36 = *(void *)(a3 + 56);
  uint64_t v37 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v37 < HIDWORD(v36))
  {
    int v73 = *(_DWORD *)(a4 + 28) * HIDWORD(v36);
    unint64_t v39 = a1 + a2;
    __int16 v40 = v26;
    __int16 v41 = v34;
    int16x8_t v42 = vdupq_n_s16(v34);
    int16x8_t v72 = vdupq_n_s16(v26);
    do
    {
      int8x16_t v81 = v22;
      int16x8_t v82 = v42;
      unint64_t v43 = (v73 + v37);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v79, v43, v78, v77);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v45 = LocationForTile;
        unint64_t v46 = ChannelDescription::GetLocationForTile(v76, v43, v75, v74);
        int8x16_t v22 = v81;
        int16x8_t v42 = v82;
        if (!HIDWORD(v46)) {
          goto LABEL_45;
        }
        uint64_t v49 = a1 + v45;
        uint64_t v50 = a1 + v46;
        if (!v49 || v50 == 0) {
          goto LABEL_45;
        }
        unint64_t v52 = 0;
        int8x16x2_t v53 = (uint64_t *)(v49 + 2 * v71);
        int32x4_t v54 = (uint64_t *)(v50 + 2 * v70);
        unint64_t v55 = (v39 - (unint64_t)v53) >> 1;
        if (v39 <= (unint64_t)v53) {
          unint64_t v55 = 0;
        }
        if (v55 >= a10) {
          unint64_t v55 = a10;
        }
        unint64_t v56 = (v39 - (unint64_t)v54) >> 1;
        if (v39 <= (unint64_t)v54) {
          unint64_t v56 = 0;
        }
        if (v55 >= v56) {
          unint64_t v55 = v56;
        }
        int32x4_t v57 = a12;
        if (v55 >= 4)
        {
          uint64_t v58 = 0;
          unint64_t v59 = a12;
          do
          {
            uint64_t v60 = *v53++;
            v47.i64[0] = v60;
            uint64_t v61 = *v54++;
            v48.i64[0] = v61;
            int16x8_t v62 = vzip1q_s16(v47, v72);
            int8x16_t v22 = vqtbl2q_s8(*(int8x16x2_t *)(&v48 - 1), (int8x16_t)xmmword_228F41C60);
            int16x8_t v47 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)v22.i8, (int8x16_t)xmmword_228F41C70);
            int8x16_t v63 = vqtbl2q_s8(*(int8x16x2_t *)(&v48 - 1), (int8x16_t)xmmword_228F41C40);
            int16x8_t v48 = v82;
            int32x4_t v57 = v59 + 2;
            *unint64_t v59 = (int8x16_t)v47;
            v59[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v48 - 1), (int8x16_t)xmmword_228F41C50);
            unint64_t v52 = v58 + 4;
            unint64_t v64 = v58 + 8;
            v58 += 4;
            v59 += 2;
          }
          while (v64 <= v55);
        }
        unint64_t v65 = v55 - v52;
        if (v55 > v52)
        {
          int32x4_t v66 = (__int16 *)(v49 + 2 * v71 + 2 * v52);
          int16x8_t v67 = (_WORD *)(v50 + 2 * v70 + 2 * v52);
          do
          {
            __int16 v68 = *v66++;
            LOWORD(v69) = v68;
            WORD1(v69) = *v67++;
            WORD2(v69) = v40;
            HIWORD(v69) = v41;
            v57->i64[0] = v69;
            int32x4_t v57 = (int8x16_t *)((char *)v57 + 8);
            --v65;
          }
          while (v65);
          unint64_t v52 = v55;
        }
        if (a10 <= v52) {
          goto LABEL_45;
        }
        int8x16_t v81 = v22;
        bzero(v57, 8 * (a10 - v52));
      }
      else
      {
        ChannelDescription::GetLocationForTile(v76, v43, v75, v74);
      }
      int8x16_t v22 = v81;
      int16x8_t v42 = v82;
LABEL_45:
      a12 = (int8x16_t *)((char *)a12 + a13);
      v37 += a11;
    }
    while (v37 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(v80 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v20 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  unsigned int v79 = *(ChannelDescription **)(a5 + 8);
  unint64_t v78 = v20;
  unsigned int v77 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a4 + 52) + HIDWORD(v20) * *(_DWORD *)(a3 + 60)), v20, v77);
  uint64_t v80 = a3;
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v69 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = v21;
  int16x8_t v76 = *(ChannelDescription **)(a6 + 8);
  unsigned int v74 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v74);
  uint64_t v22 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v22;
  }
  else {
    _D0 = NAN;
  }
  int v24 = *(_DWORD *)(v22 + 16);
  if (v24 == 2)
  {
    *(float *)&unsigned int v25 = _D0;
  }
  else if (v24 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v81) = _H0;
    LOWORD(v81) = _H0;
    unsigned int v25 = v81;
  }
  else
  {
    unsigned int v25 = _D0;
  }
  uint64_t v30 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D1 = *(double *)v30;
  }
  else {
    _D1 = NAN;
  }
  int v32 = *(_DWORD *)(v30 + 16);
  if (v32 == 2)
  {
    *(float *)&unsigned int v33 = _D1;
  }
  else if (v32 == 1)
  {
    __asm { FCVT            H1, D1 }
    HIWORD(v82) = _H1;
    LOWORD(v82) = _H1;
    unsigned int v33 = v82;
  }
  else
  {
    unsigned int v33 = _D1;
    if (v32) {
      unsigned int v33 = v25;
    }
  }
  unint64_t v35 = *(void *)(a3 + 56);
  uint64_t v36 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v36 < HIDWORD(v35))
  {
    unsigned int v38 = v25;
    unsigned int v39 = v33;
    int v73 = *(_DWORD *)(a4 + 28) * HIDWORD(v35);
    unint64_t v40 = a1 + a2;
    int32x4_t v71 = vdupq_n_s32(v33);
    int32x4_t v72 = vdupq_n_s32(v25);
    do
    {
      unint64_t v41 = (v73 + v36);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v79, v41, v78, v77);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v43 = LocationForTile;
        unint64_t v44 = ChannelDescription::GetLocationForTile(v76, v41, v75, v74);
        if (HIDWORD(v44))
        {
          uint64_t v45 = a1 + v43;
          uint64_t v46 = a1 + v44;
          if (v45 && v46 != 0)
          {
            unint64_t v48 = 0;
            uint64_t v49 = (int32x4_t *)(v45 + 4 * v70);
            uint64_t v50 = (int32x4_t *)(v46 + 4 * v69);
            unint64_t v51 = (v40 - (unint64_t)v49) >> 2;
            if (v40 <= (unint64_t)v49) {
              unint64_t v51 = 0;
            }
            if (v51 >= a10) {
              unint64_t v51 = a10;
            }
            unint64_t v52 = (v40 - (unint64_t)v50) >> 2;
            if (v40 <= (unint64_t)v50) {
              unint64_t v52 = 0;
            }
            if (v51 >= v52) {
              unint64_t v51 = v52;
            }
            int8x16x2_t v53 = a12;
            if (v51 >= 4)
            {
              uint64_t v54 = 0;
              unint64_t v55 = a12;
              do
              {
                int32x4_t v56 = *v49++;
                int32x4_t v57 = v56;
                int32x4_t v58 = *v50++;
                v59.i64[1] = __PAIR64__(v71.u32[2], v72.u32[2]);
                v59.i64[0] = __PAIR64__(v58.u32[2], v57.u32[2]);
                int32x4_t v60 = vuzp2q_s32(v57, v72);
                int32x4_t v61 = vtrn2q_s32(v60, v57);
                v61.i32[1] = v58.i32[3];
                v61.i32[3] = v71.i32[3];
                int32x4_t v62 = vtrn1q_s32(vuzp1q_s32(v57, v72), v58);
                v62.i32[3] = v71.i32[0];
                v60.i32[1] = v58.i32[1];
                v60.i32[3] = v71.i32[1];
                int8x16x2_t v53 = v55 + 4;
                int32x4_t *v55 = v62;
                v55[1] = v60;
                v55[2] = v59;
                v55[3] = v61;
                unint64_t v48 = v54 + 4;
                unint64_t v63 = v54 + 8;
                v54 += 4;
                v55 += 4;
              }
              while (v63 <= v51);
            }
            unint64_t v64 = v51 - v48;
            if (v51 > v48)
            {
              unint64_t v65 = (int *)(v45 + 4 * v70 + 4 * v48);
              int32x4_t v66 = (__int32 *)(v46 + 4 * v69 + 4 * v48);
              do
              {
                int v67 = *v65++;
                v68.i32[0] = v67;
                v68.i32[1] = *v66++;
                v68.i64[1] = __PAIR64__(v39, v38);
                *v53++ = v68;
                --v64;
              }
              while (v64);
              unint64_t v48 = v51;
            }
            if (a10 > v48) {
              bzero(v53, 16 * (a10 - v48));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v76, v41, v75, v74);
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v36 += a11;
    }
    while (v36 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(v80 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t *a8, double a9, double a10, uint64_t a11, unint64_t a12, unsigned int a13, int16x4_t *a14, uint64_t a15)
{
  uint64_t v18 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v18;
  }
  else {
    _D0 = NAN;
  }
  int v20 = *(_DWORD *)(v18 + 16);
  if (v20 == 2)
  {
    *(float *)&a10 = _D0;
  }
  else if (v20 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v71) = _H0;
    LOWORD(v71) = _H0;
    LODWORD(a10) = v71;
  }
  else
  {
    LODWORD(a10) = _D0;
  }
  uint64_t v25 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v25;
  }
  else {
    _D0 = NAN;
  }
  int v27 = *(_DWORD *)(v25 + 16);
  double v62 = a10;
  if (v27 == 2)
  {
    float v28 = _D0;
  }
  else if (v27 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v72) = _H0;
    LOWORD(v72) = _H0;
    float v28 = v72;
  }
  else
  {
    LODWORD(v28) = _D0;
  }
  float v65 = v28;
  uint64_t v30 = *(ChannelDescription **)(a7 + 8);
  uint64_t v31 = *(void *)(a4 + 24);
  uint64_t v32 = v31;
  unsigned int v33 = *(_DWORD *)(a4 + 60);
  uint64_t v64 = *(unsigned int *)(a4 + 44);
  ChannelDescription::GetLocationForTile(v30, (*(_DWORD *)(a4 + 52) + HIDWORD(v31) * *(_DWORD *)(a3 + 60)), v31, v33);
  uint64_t v35 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D0 = *(double *)v35;
  }
  else {
    _D0 = NAN;
  }
  int v37 = *(_DWORD *)(v35 + 16);
  if (v37 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v37 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v73) = _H0;
    LOWORD(v73) = _H0;
    LODWORD(_D0) = v73;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  unint64_t v39 = *(void *)(a3 + 56);
  uint64_t v40 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v40 < HIDWORD(v39))
  {
    uint64_t v42 = a2;
    int v43 = *(_DWORD *)(a4 + 28) * HIDWORD(v39);
    int16x8_t v69 = vdupq_n_s16(LODWORD(v62));
    long long v70 = v34;
    unint64_t v63 = a1 + v42;
    int16x4_t v44 = vuzp1_s16((int16x4_t)__PAIR64__(LODWORD(_D0), LODWORD(v65)), *(int16x4_t *)&_D0);
    v74.val[1] = (int8x16_t)vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(_D0), LODWORD(v65)), 0);
    v74.val[0] = (int8x16_t)vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(_D0), LODWORD(v65)), 2);
    int16x8_t v66 = (int16x8_t)vqtbl2q_s8(v74, (int8x16_t)xmmword_228F62BB0);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v30, (v43 + v40), v32, v33);
      uint64_t v46 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v46 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v48 = 0;
        uint64_t v49 = (uint64_t *)(v46 + 2 * v64);
        unint64_t v50 = (v63 - (unint64_t)v49) >> 1;
        if (v63 <= (unint64_t)v49) {
          unint64_t v50 = 0;
        }
        if (a12 < v50) {
          unint64_t v50 = a12;
        }
        unint64_t v51 = a14;
        int16x8_t v52 = v69;
        long long v53 = v70;
        if (v50 >= 4)
        {
          uint64_t v54 = 0;
          unint64_t v55 = (int16x8_t *)a14;
          do
          {
            uint64_t v56 = *v49++;
            *(void *)&long long v53 = v56;
            int16x8_t v57 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)v52.i8, (int8x16_t)xmmword_228F41C10);
            unint64_t v51 = (int16x4_t *)&v55[2];
            int16x8_t *v55 = vzip1q_s16(v57, v66);
            v55[1] = vzip2q_s16(v57, v66);
            unint64_t v48 = v54 + 4;
            unint64_t v58 = v54 + 8;
            v54 += 4;
            v55 += 2;
          }
          while (v58 <= v50);
        }
        unint64_t v59 = v50 - v48;
        long long v70 = v53;
        if (v50 > v48)
        {
          int32x4_t v60 = (__int16 *)(v46 + 2 * v64 + 2 * v48);
          do
          {
            int16x4_t v61 = *(int16x4_t *)&v62;
            v61.i16[2] = *v60++;
            *v51++ = vzip1_s16(vuzp1_s16(v61, v61), v44);
            --v59;
          }
          while (v59);
          unint64_t v48 = v50;
        }
        if (a12 > v48) {
          bzero(v51, 8 * (a12 - v48));
        }
      }
      a14 = (int16x4_t *)((char *)a14 + a15);
      v40 += a13;
    }
    while (v40 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t *a8, __n128 _Q0, __n128 a10, uint64_t a11, unint64_t a12, unsigned int a13, int32x4_t *a14, uint64_t a15)
{
  uint64_t v18 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v18;
  }
  else {
    _D0 = NAN;
  }
  int v20 = *(_DWORD *)(v18 + 16);
  if (v20 == 2)
  {
    a10.n128_f32[0] = _D0;
  }
  else if (v20 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v71) = _H0;
    LOWORD(v71) = _H0;
    a10.n128_u32[0] = v71;
  }
  else
  {
    a10.n128_u32[0] = _D0;
  }
  uint64_t v25 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _Q0.n128_u64[0] = *(void *)v25;
  }
  else {
    _Q0.n128_u64[0] = 0x7FF8000000000000;
  }
  int v26 = *(_DWORD *)(v25 + 16);
  __n128 v62 = a10;
  if (v26 == 2)
  {
    _Q0.n128_f32[0] = _Q0.n128_f64[0];
  }
  else if (v26 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v72) = _H0;
    LOWORD(v72) = _H0;
    _Q0.n128_u32[0] = v72;
  }
  else
  {
    _Q0.n128_u32[0] = _Q0.n128_f64[0];
  }
  __n128 v63 = _Q0;
  float v28 = *(ChannelDescription **)(a7 + 8);
  uint64_t v29 = *(void *)(a4 + 24);
  uint64_t v30 = v29;
  unsigned int v31 = *(_DWORD *)(a4 + 60);
  uint64_t v66 = *(unsigned int *)(a4 + 44);
  ChannelDescription::GetLocationForTile(v28, (*(_DWORD *)(a4 + 52) + HIDWORD(v29) * *(_DWORD *)(a3 + 60)), v29, v31);
  uint64_t v32 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D0 = *(double *)v32;
  }
  else {
    _D0 = NAN;
  }
  int v34 = *(_DWORD *)(v32 + 16);
  if (v34 == 2)
  {
    float v35 = _D0;
  }
  else if (v34 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v73) = _H0;
    LOWORD(v73) = _H0;
    float v35 = v73;
  }
  else
  {
    LODWORD(v35) = _D0;
  }
  unint64_t v37 = *(void *)(a3 + 56);
  uint64_t v38 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v38 < HIDWORD(v37))
  {
    __n128 v40 = v63;
    unsigned __int32 v41 = v63.n128_u32[0];
    uint64_t v42 = a2;
    int v43 = *(_DWORD *)(a4 + 28) * HIDWORD(v37);
    unint64_t v65 = a1 + v42;
    int32x4_t v44 = vdupq_n_s32(v62.n128_u32[0]);
    v40.n128_f32[1] = v35;
    int32x4_t v64 = (int32x4_t)v40;
    v45.i64[0] = v40.n128_u64[0];
    v45.i64[1] = __PAIR64__(LODWORD(v35), v41);
    int32x4_t v67 = vuzp1q_s32(v44, v44);
    int32x4_t v68 = v45;
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v28, (v43 + v38), v30, v31);
      uint64_t v47 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v47 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v49 = 0;
        unint64_t v50 = (int32x4_t *)(v47 + 4 * v66);
        unint64_t v51 = (v65 - (unint64_t)v50) >> 2;
        if (v65 <= (unint64_t)v50) {
          unint64_t v51 = 0;
        }
        if (a12 < v51) {
          unint64_t v51 = a12;
        }
        int16x8_t v52 = a14;
        if (v51 >= 4)
        {
          uint64_t v53 = 0;
          uint64_t v54 = a14;
          do
          {
            int32x4_t v55 = *v50++;
            int32x4_t v56 = vzip1q_s32(v67, v55);
            int32x4_t v57 = vzip2q_s32(v67, v55);
            int16x8_t v52 = v54 + 4;
            int32x4_t *v54 = vzip1q_s32(v56, v68);
            v54[1] = vzip2q_s32(v56, v68);
            v54[2] = vzip1q_s32(v57, v68);
            v54[3] = vzip2q_s32(v57, v68);
            unint64_t v49 = v53 + 4;
            unint64_t v58 = v53 + 8;
            v53 += 4;
            v54 += 4;
          }
          while (v58 <= v51);
        }
        unint64_t v59 = v51 - v49;
        if (v51 > v49)
        {
          int32x4_t v60 = (__int32 *)(v47 + 4 * v66 + 4 * v49);
          do
          {
            int32x4_t v61 = (int32x4_t)v62;
            v61.i32[2] = *v60++;
            *v52++ = vzip1q_s32(vuzp1q_s32(v61, v61), v64);
            --v59;
          }
          while (v59);
          unint64_t v49 = v51;
        }
        if (a12 > v49) {
          bzero(v52, 16 * (a12 - v49));
        }
      }
      a14 = (int32x4_t *)((char *)a14 + a15);
      v38 += a13;
    }
    while (v38 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int16x8_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v66 = *(unsigned int *)(a4 + 44);
  uint64_t v73 = v19;
  int8x16x2_t v74 = *(ChannelDescription **)(a5 + 8);
  unsigned int v72 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v74, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v72);
  uint64_t v20 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v20;
  }
  else {
    _D0 = NAN;
  }
  int v22 = *(_DWORD *)(v20 + 16);
  if (v22 == 2)
  {
    float v23 = _D0;
  }
  else if (v22 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v76) = _H0;
    LOWORD(v76) = _H0;
    float v23 = v76;
  }
  else
  {
    LODWORD(v23) = _D0;
  }
  float v67 = v23;
  uint64_t v28 = *(void *)(a4 + 24);
  uint64_t v65 = *(unsigned int *)(a4 + 44);
  uint64_t v70 = v28;
  unsigned __int32 v71 = *(ChannelDescription **)(a7 + 8);
  unsigned int v69 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v71, (*(_DWORD *)(a4 + 52) + HIDWORD(v28) * *(_DWORD *)(a3 + 60)), v28, v69);
  uint64_t v29 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D0 = *(double *)v29;
  }
  else {
    _D0 = NAN;
  }
  int v31 = *(_DWORD *)(v29 + 16);
  if (v31 == 2)
  {
    float v32 = _D0;
  }
  else if (v31 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v77) = _H0;
    LOWORD(v77) = _H0;
    float v32 = v77;
  }
  else
  {
    LODWORD(v32) = _D0;
  }
  unint64_t v34 = *(void *)(a3 + 56);
  uint64_t v35 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v35 < HIDWORD(v34))
  {
    int v37 = *(_DWORD *)(a4 + 28) * HIDWORD(v34);
    unint64_t v38 = a1 + a2;
    int16x4_t v39 = (int16x4_t)__PAIR64__(LODWORD(v32), LODWORD(v67));
    v78.val[1] = (int8x16_t)vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(v32), LODWORD(v67)), 0);
    v78.val[0] = (int8x16_t)vdupq_lane_s16((int16x4_t)__PAIR64__(LODWORD(v32), LODWORD(v67)), 2);
    int16x4_t v40 = vuzp1_s16(v39, *(int16x4_t *)v78.val[0].i8);
    int16x8_t v68 = (int16x8_t)vqtbl2q_s8(v78, (int8x16_t)xmmword_228F62BB0);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v74, (v37 + v35), v73, v72);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v42 = LocationForTile;
        unint64_t v43 = ChannelDescription::GetLocationForTile(v71, (v37 + v35), v70, v69);
        if (HIDWORD(v43))
        {
          uint64_t v46 = a1 + v42;
          uint64_t v47 = a1 + v43;
          if (v46 && v47 != 0)
          {
            unint64_t v49 = 0;
            unint64_t v50 = (uint64_t *)(v46 + 2 * v66);
            unint64_t v51 = (uint64_t *)(v47 + 2 * v65);
            unint64_t v52 = (v38 - (unint64_t)v50) >> 1;
            if (v38 <= (unint64_t)v50) {
              unint64_t v52 = 0;
            }
            if (v52 >= a10) {
              unint64_t v52 = a10;
            }
            unint64_t v53 = (v38 - (unint64_t)v51) >> 1;
            if (v38 <= (unint64_t)v51) {
              unint64_t v53 = 0;
            }
            if (v52 >= v53) {
              unint64_t v52 = v53;
            }
            uint64_t v54 = a12;
            if (v52 >= 4)
            {
              uint64_t v55 = 0;
              int32x4_t v56 = a12;
              do
              {
                uint64_t v57 = *v50++;
                v44.i64[0] = v57;
                uint64_t v58 = *v51++;
                v45.i64[0] = v58;
                int16x8_t v59 = vzip1q_s16(v44, v45);
                int16x8_t v45 = vzip1q_s16(v59, v68);
                int16x8_t v44 = vzip2q_s16(v59, v68);
                uint64_t v54 = v56 + 2;
                int16x8_t *v56 = v45;
                v56[1] = v44;
                unint64_t v49 = v55 + 4;
                unint64_t v60 = v55 + 8;
                v55 += 4;
                v56 += 2;
              }
              while (v60 <= v52);
            }
            unint64_t v61 = v52 - v49;
            if (v52 > v49)
            {
              __n128 v62 = (unsigned __int16 *)(v46 + 2 * v66 + 2 * v49);
              __n128 v63 = (__int16 *)(v47 + 2 * v65 + 2 * v49);
              do
              {
                __int32 v64 = *v62++;
                v44.i32[0] = v64;
                v44.i16[2] = *v63++;
                *(int16x4_t *)v44.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v44.i8, *(int16x4_t *)v44.i8), v40);
                v54->i64[0] = v44.i64[0];
                uint64_t v54 = (int16x8_t *)((char *)v54 + 8);
                --v61;
              }
              while (v61);
              unint64_t v49 = v52;
            }
            if (a10 > v49) {
              bzero(v54, 8 * (a10 - v49));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v71, (v37 + v35), v70, v69);
      }
      a12 = (int16x8_t *)((char *)a12 + a13);
      v35 += a11;
    }
    while (v35 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v71 = *(unsigned int *)(a4 + 44);
  uint64_t v77 = v19;
  int8x16x2_t v78 = *(ChannelDescription **)(a5 + 8);
  unsigned int v76 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v78, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v76);
  uint64_t v21 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _Q0.i64[0] = *(void *)v21;
  }
  else {
    _Q0.i64[0] = 0x7FF8000000000000;
  }
  int v22 = *(_DWORD *)(v21 + 16);
  if (v22 == 2)
  {
    *(float *)_Q0.i32 = *(double *)_Q0.i64;
  }
  else if (v22 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v80) = _H0;
    LOWORD(v80) = _H0;
    _Q0.i32[0] = v80;
  }
  else
  {
    _Q0.i32[0] = *(double *)_Q0.i64;
  }
  int32x4_t v68 = _Q0;
  uint64_t v27 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v74 = v27;
  uint64_t v75 = *(ChannelDescription **)(a7 + 8);
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v27) * *(_DWORD *)(a3 + 60)), v27, v73);
  uint64_t v28 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D0 = *(double *)v28;
  }
  else {
    _D0 = NAN;
  }
  int v30 = *(_DWORD *)(v28 + 16);
  if (v30 == 2)
  {
    float v31 = _D0;
  }
  else if (v30 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v81) = _H0;
    LOWORD(v81) = _H0;
    float v31 = v81;
  }
  else
  {
    LODWORD(v31) = _D0;
  }
  unint64_t v33 = *(void *)(a3 + 56);
  uint64_t v34 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v34 < HIDWORD(v33))
  {
    int32x4_t v36 = v68;
    unsigned int v37 = v68.i32[0];
    int v38 = *(_DWORD *)(a4 + 28) * HIDWORD(v33);
    unint64_t v39 = a1 + a2;
    *(float *)&v36.i32[1] = v31;
    int32x4_t v69 = v36;
    v40.i64[0] = v36.i64[0];
    v40.i64[1] = __PAIR64__(LODWORD(v31), v37);
    int32x4_t v72 = v40;
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v78, (v38 + v34), v77, v76);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v42 = LocationForTile;
        unint64_t v43 = ChannelDescription::GetLocationForTile(v75, (v38 + v34), v74, v73);
        if (HIDWORD(v43))
        {
          uint64_t v45 = a1 + v42;
          uint64_t v46 = a1 + v43;
          if (v45 && v46 != 0)
          {
            unint64_t v48 = 0;
            unint64_t v49 = (int32x4_t *)(v45 + 4 * v71);
            unint64_t v50 = (int32x4_t *)(v46 + 4 * v70);
            unint64_t v51 = (v39 - (unint64_t)v49) >> 2;
            if (v39 <= (unint64_t)v49) {
              unint64_t v51 = 0;
            }
            if (v51 >= a10) {
              unint64_t v51 = a10;
            }
            unint64_t v52 = (v39 - (unint64_t)v50) >> 2;
            if (v39 <= (unint64_t)v50) {
              unint64_t v52 = 0;
            }
            if (v51 >= v52) {
              unint64_t v51 = v52;
            }
            unint64_t v53 = a12;
            if (v51 >= 4)
            {
              uint64_t v54 = 0;
              uint64_t v55 = a12;
              do
              {
                int32x4_t v56 = *v49++;
                int32x4_t v57 = v56;
                int32x4_t v58 = *v50++;
                int32x4_t v59 = v58;
                int32x4_t v60 = vuzp1q_s32(v57, v58);
                int32x4_t v61 = vuzp2q_s32(v57, v58);
                v59.i32[0] = v57.i32[2];
                int32x4_t v62 = vtrn2q_s32(v61, v57);
                int32x4_t v44 = vzip2q_s32(vuzp1q_s32(v62, v62), v72);
                unint64_t v53 = v55 + 4;
                int32x4_t *v55 = vzip1q_s32(vuzp1q_s32(v60, v60), v72);
                v55[1] = vzip2q_s32(vuzp1q_s32(v61, v61), v72);
                v55[2] = vzip1q_s32(vuzp1q_s32(v59, v59), v72);
                v55[3] = v44;
                unint64_t v48 = v54 + 4;
                unint64_t v63 = v54 + 8;
                v54 += 4;
                v55 += 4;
              }
              while (v63 <= v51);
            }
            unint64_t v64 = v51 - v48;
            if (v51 > v48)
            {
              uint64_t v65 = (__int32 *)(v45 + 4 * v71 + 4 * v48);
              uint64_t v66 = (__int32 *)(v46 + 4 * v70 + 4 * v48);
              do
              {
                __int32 v67 = *v65++;
                v44.i32[0] = v67;
                v44.i32[2] = *v66++;
                int32x4_t v44 = vzip1q_s32(vuzp1q_s32(v44, v44), v69);
                *v53++ = v44;
                --v64;
              }
              while (v64);
              unint64_t v48 = v51;
            }
            if (a10 > v48) {
              bzero(v53, 16 * (a10 - v48));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v75, (v38 + v34), v74, v73);
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v34 += a11;
    }
    while (v34 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int16x4_t *a12, uint64_t a13)
{
  uint64_t v18 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v18;
  }
  else {
    _D0 = NAN;
  }
  int v20 = *(_DWORD *)(v18 + 16);
  if (v20 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v20 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v83) = _H0;
    LOWORD(v83) = _H0;
    LODWORD(_D0) = v83;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  int16x4_t v67 = *(int16x4_t *)&_D0;
  uint64_t v25 = *(void *)(a4 + 24);
  uint64_t v69 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = *(ChannelDescription **)(a6 + 8);
  unint64_t v74 = v25;
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v25) * *(_DWORD *)(a3 + 60)), v25, v73);
  uint64_t v26 = *(void *)(a4 + 24);
  uint64_t v68 = *(unsigned int *)(a4 + 44);
  uint64_t v71 = v26;
  int32x4_t v72 = *(ChannelDescription **)(a7 + 8);
  unsigned int v70 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a4 + 52) + HIDWORD(v26) * *(_DWORD *)(a3 + 60)), v26, v70);
  uint64_t v29 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D0 = *(double *)v29;
  }
  else {
    _D0 = NAN;
  }
  int v31 = *(_DWORD *)(v29 + 16);
  if (v31 == 2)
  {
    *(float *)&unsigned int v32 = _D0;
  }
  else if (v31 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v84) = _H0;
    LOWORD(v84) = _H0;
    unsigned int v32 = v84;
  }
  else
  {
    unsigned int v32 = _D0;
  }
  unint64_t v34 = *(void *)(a3 + 56);
  uint64_t v35 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v35 < HIDWORD(v34))
  {
    int v37 = *(_DWORD *)(a4 + 28) * HIDWORD(v34);
    unint64_t v38 = a1 + a2;
    int16x8_t v39 = vdupq_n_s16(v67.u32[0]);
    __int16 v40 = v32;
    int16x8_t v41 = vdupq_n_s16(v32);
    do
    {
      int8x16_t v77 = v28;
      int16x8_t v79 = v41;
      int16x8_t v80 = v39;
      long long v81 = v27;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v75, (v37 + v35), v74, v73);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v43 = LocationForTile;
        unint64_t v44 = ChannelDescription::GetLocationForTile(v72, (v37 + v35), v71, v70);
        int16x8_t v39 = v80;
        long long v27 = v81;
        int8x16_t v28 = v77;
        int16x8_t v41 = v79;
        if (HIDWORD(v44))
        {
          uint64_t v46 = a1 + v43;
          uint64_t v47 = a1 + v44;
          if (v46 && v47 != 0)
          {
            unint64_t v49 = 0;
            unint64_t v50 = (uint64_t *)(v46 + 2 * v69);
            unint64_t v51 = (uint64_t *)(v47 + 2 * v68);
            unint64_t v52 = (v38 - (unint64_t)v50) >> 1;
            if (v38 <= (unint64_t)v50) {
              unint64_t v52 = 0;
            }
            if (a10 < v52) {
              unint64_t v52 = a10;
            }
            unint64_t v53 = (v38 - (unint64_t)v51) >> 1;
            if (v38 <= (unint64_t)v51) {
              unint64_t v53 = 0;
            }
            if (v52 >= v53) {
              unint64_t v52 = v53;
            }
            uint64_t v54 = a12;
            if (v52 >= 4)
            {
              uint64_t v55 = 0;
              int32x4_t v56 = (int8x16_t *)a12;
              do
              {
                uint64_t v57 = *v50++;
                v45.i64[0] = v57;
                uint64_t v58 = *v51++;
                *(void *)&long long v27 = v58;
                int8x16_t v59 = vqtbl2q_s8(*(int8x16x2_t *)(&v27 - 1), (int8x16_t)xmmword_228F41C10);
                int8x16_t v28 = vqtbl2q_s8(*(int8x16x2_t *)(&v45 - 1), (int8x16_t)xmmword_228F41C60);
                int8x16_t v60 = vqtbl2q_s8(*(int8x16x2_t *)(&v45 - 1), (int8x16_t)xmmword_228F41C40);
                int16x8_t v45 = v79;
                uint64_t v54 = (int16x4_t *)&v56[2];
                int8x16_t *v56 = vqtbl2q_s8(*(int8x16x2_t *)v28.i8, (int8x16_t)xmmword_228F41C70);
                v56[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v45 - 1), (int8x16_t)xmmword_228F41C50);
                unint64_t v49 = v55 + 4;
                unint64_t v61 = v55 + 8;
                v55 += 4;
                v56 += 2;
              }
              while (v61 <= v52);
            }
            unint64_t v62 = v52 - v49;
            if (v52 > v49)
            {
              unint64_t v63 = (__int16 *)(v46 + 2 * v69 + 2 * v49);
              unint64_t v64 = (__int16 *)(v47 + 2 * v68 + 2 * v49);
              do
              {
                __int16 v65 = *v63++;
                int16x4_t v66 = v67;
                v66.i16[2] = *v64++;
                v45.i16[0] = v65;
                v45.i16[1] = v40;
                *v54++ = vzip1_s16(vuzp1_s16(v66, v66), *(int16x4_t *)v45.i8);
                --v62;
              }
              while (v62);
              unint64_t v49 = v52;
            }
            if (a10 > v49)
            {
              long long v82 = v27;
              int8x16_t v78 = v28;
              bzero(v54, 8 * (a10 - v49));
              int8x16_t v28 = v78;
              int16x8_t v41 = v79;
              int16x8_t v39 = v80;
              long long v27 = v82;
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v72, (v37 + v35), v71, v70);
        int16x8_t v39 = v80;
        long long v27 = v81;
        int8x16_t v28 = v77;
        int16x8_t v41 = v79;
      }
      a12 = (int16x4_t *)((char *)a12 + a13);
      v35 += a11;
    }
    while (v35 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8, __n128 _Q0, uint64_t a10, unint64_t a11, unsigned int a12, int32x4_t *a13, uint64_t a14)
{
  uint64_t v19 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _Q0.n128_u64[0] = *(void *)v19;
  }
  else {
    _Q0.n128_u64[0] = 0x7FF8000000000000;
  }
  int v20 = *(_DWORD *)(v19 + 16);
  if (v20 == 2)
  {
    _Q0.n128_f32[0] = _Q0.n128_f64[0];
  }
  else if (v20 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v81) = _H0;
    LOWORD(v81) = _H0;
    _Q0.n128_u32[0] = v81;
  }
  else
  {
    _Q0.n128_u32[0] = _Q0.n128_f64[0];
  }
  __n128 v69 = _Q0;
  uint64_t v25 = *(void *)(a4 + 24);
  uint64_t v71 = *(unsigned int *)(a4 + 44);
  uint64_t v78 = v25;
  int16x8_t v79 = *(ChannelDescription **)(a6 + 8);
  unsigned int v77 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a4 + 52) + HIDWORD(v25) * *(_DWORD *)(a3 + 60)), v25, v77);
  uint64_t v26 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = v26;
  unsigned int v76 = *(ChannelDescription **)(a7 + 8);
  unsigned int v74 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a4 + 52) + HIDWORD(v26) * *(_DWORD *)(a3 + 60)), v26, v74);
  uint64_t v27 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D0 = *(double *)v27;
  }
  else {
    _D0 = NAN;
  }
  int v29 = *(_DWORD *)(v27 + 16);
  if (v29 == 2)
  {
    float v30 = _D0;
  }
  else if (v29 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v82) = _H0;
    LOWORD(v82) = _H0;
    float v30 = v82;
  }
  else
  {
    LODWORD(v30) = _D0;
  }
  unint64_t v32 = *(void *)(a3 + 56);
  uint64_t v33 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v33 < HIDWORD(v32))
  {
    uint64_t v34 = a2;
    unsigned int v36 = LODWORD(v30);
    int v37 = *(_DWORD *)(a4 + 28) * HIDWORD(v32);
    int32x4_t v38 = vdupq_n_s32(v69.n128_u32[0]);
    unint64_t v39 = a1 + v34;
    int32x4_t v72 = vuzp1q_s32(v38, v38);
    int32x4_t v73 = vdupq_n_s32(v36);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v79, (v37 + v33), v78, v77);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v41 = LocationForTile;
        unint64_t v42 = ChannelDescription::GetLocationForTile(v76, (v37 + v33), v75, v74);
        if (HIDWORD(v42))
        {
          uint64_t v44 = a1 + v41;
          uint64_t v45 = a1 + v42;
          if (v44 && v45 != 0)
          {
            unint64_t v47 = 0;
            unint64_t v48 = (int32x4_t *)(v44 + 4 * v71);
            unint64_t v49 = (int32x4_t *)(v45 + 4 * v70);
            unint64_t v50 = (v39 - (unint64_t)v48) >> 2;
            if (v39 <= (unint64_t)v48) {
              unint64_t v50 = 0;
            }
            if (a11 < v50) {
              unint64_t v50 = a11;
            }
            unint64_t v51 = (v39 - (unint64_t)v49) >> 2;
            if (v39 <= (unint64_t)v49) {
              unint64_t v51 = 0;
            }
            if (v50 >= v51) {
              unint64_t v50 = v51;
            }
            unint64_t v52 = a13;
            if (v50 >= 4)
            {
              uint64_t v53 = 0;
              uint64_t v54 = a13;
              do
              {
                int32x4_t v55 = *v48++;
                int32x4_t v56 = v55;
                int32x4_t v57 = *v49++;
                int32x4_t v58 = vzip1q_s32(v72, v57);
                int8x16_t v59 = (int8x16_t)vzip2q_s32(v72, v57);
                int8x16_t v60 = vextq_s8((int8x16_t)vzip2q_s32(v56, (int32x4_t)v59), v59, 4uLL);
                v60.i32[3] = v73.i32[3];
                int32x4_t v61 = vzip2q_s32(v58, vuzp2q_s32(v58, v56));
                v61.i32[3] = v73.i32[1];
                int32x4_t v43 = vzip2q_s32((int32x4_t)vextq_s8(v59, v59, 8uLL), v56);
                v43.i32[3] = v73.i32[2];
                int32x4_t v62 = vzip1q_s32(v58, v56);
                v62.i32[3] = v73.i32[0];
                unint64_t v52 = v54 + 4;
                int32x4_t *v54 = v62;
                v54[1] = v61;
                v54[2] = v43;
                v54[3] = (int32x4_t)v60;
                unint64_t v47 = v53 + 4;
                unint64_t v63 = v53 + 8;
                v53 += 4;
                v54 += 4;
              }
              while (v63 <= v50);
            }
            unint64_t v64 = v50 - v47;
            if (v50 > v47)
            {
              __int16 v65 = (unsigned int *)(v44 + 4 * v71 + 4 * v47);
              int16x4_t v66 = (__int32 *)(v45 + 4 * v70 + 4 * v47);
              do
              {
                unsigned int v67 = *v65++;
                int32x4_t v68 = (int32x4_t)v69;
                v68.i32[2] = *v66++;
                v43.i64[0] = __PAIR64__(v36, v67);
                *v52++ = vzip1q_s32(vuzp1q_s32(v68, v68), v43);
                --v64;
              }
              while (v64);
              unint64_t v47 = v50;
            }
            if (a11 > v47) {
              bzero(v52, 16 * (a11 - v47));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v76, (v37 + v33), v75, v74);
      }
      a13 = (int32x4_t *)((char *)a13 + a14);
      v33 += a12;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int8x16_t *a12, uint64_t a13)
{
  uint64_t v20 = *(void *)(a4 + 24);
  uint64_t v81 = *(unsigned int *)(a4 + 44);
  uint64_t v83 = v20;
  unsigned int v84 = *(ChannelDescription **)(a5 + 8);
  unsigned int v82 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v84, (*(_DWORD *)(a4 + 52) + HIDWORD(v20) * *(_DWORD *)(a3 + 60)), v20, v82);
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v77 = *(unsigned int *)(a4 + 44);
  uint64_t v79 = v21;
  int16x8_t v80 = *(ChannelDescription **)(a6 + 8);
  unsigned int v78 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v80, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v78);
  uint64_t v85 = a3;
  uint64_t v22 = *(void *)(a4 + 24);
  uint64_t v73 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = v22;
  unsigned int v76 = *(ChannelDescription **)(a7 + 8);
  unsigned int v74 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v74);
  uint64_t v25 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D1 = *(double *)v25;
  }
  else {
    _D1 = NAN;
  }
  int v27 = *(_DWORD *)(v25 + 16);
  switch(v27)
  {
    case 2:
      *(float *)&unsigned int v23 = _D1;
      break;
    case 1:
      __asm { FCVT            H0, D1 }
      HIWORD(v89) = _H0;
      LOWORD(v89) = _H0;
      unsigned int v23 = v89;
      break;
    case 0:
      unsigned int v23 = _D1;
      break;
  }
  unint64_t v32 = *(void *)(a3 + 56);
  uint64_t v33 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v33 < HIDWORD(v32))
  {
    int v72 = *(_DWORD *)(a4 + 28) * HIDWORD(v32);
    unint64_t v35 = a1 + a2;
    __int16 v36 = v23;
    int16x8_t v37 = vdupq_n_s16(v23);
    do
    {
      int8x16_t v86 = v24;
      int16x8_t v88 = v37;
      unint64_t v38 = (v72 + v33);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v84, v38, v83, v82);
      if (HIDWORD(LocationForTile)) {
        unint64_t v40 = a1 + LocationForTile + 2 * v81;
      }
      else {
        unint64_t v40 = 0;
      }
      unint64_t v41 = ChannelDescription::GetLocationForTile(v80, v38, v79, v78);
      if (HIDWORD(v41)) {
        unint64_t v42 = a1 + v41 + 2 * v77;
      }
      else {
        unint64_t v42 = 0;
      }
      unint64_t v43 = ChannelDescription::GetLocationForTile(v76, v38, v75, v74);
      int8x16_t v24 = v86;
      int16x8_t v37 = v88;
      if (HIDWORD(v43)) {
        unint64_t v47 = a1 + v43 + 2 * v73;
      }
      else {
        unint64_t v47 = 0;
      }
      if (v40) {
        _ZF = v42 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v47 != 0)
      {
        unint64_t v50 = 0;
        unint64_t v51 = (v35 - v40) >> 1;
        if (v35 <= v40) {
          unint64_t v51 = 0;
        }
        if (v51 >= a10) {
          unint64_t v51 = a10;
        }
        unint64_t v52 = (v35 - v42) >> 1;
        if (v35 <= v42) {
          unint64_t v52 = 0;
        }
        if (v51 >= v52) {
          unint64_t v51 = v52;
        }
        unint64_t v53 = (v35 - v47) >> 1;
        if (v35 <= v47) {
          unint64_t v53 = 0;
        }
        if (v51 >= v53) {
          unint64_t v51 = v53;
        }
        uint64_t v54 = a12;
        if (v51 >= 4)
        {
          uint64_t v55 = 0;
          int32x4_t v56 = (uint64_t *)v47;
          int32x4_t v57 = (uint64_t *)v42;
          int32x4_t v58 = (uint64_t *)v40;
          int8x16_t v59 = a12;
          do
          {
            uint64_t v60 = *v58++;
            v44.i64[0] = v60;
            uint64_t v61 = *v57++;
            v45.i64[0] = v61;
            uint64_t v62 = *v56++;
            v46.i64[0] = v62;
            int16x8_t v63 = vzip1q_s16(v44, v46);
            int8x16_t v24 = vqtbl2q_s8(*(int8x16x2_t *)(&v45 - 1), (int8x16_t)xmmword_228F41C60);
            int16x8_t v44 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)v24.i8, (int8x16_t)xmmword_228F41C70);
            int8x16_t v64 = vqtbl2q_s8(*(int8x16x2_t *)(&v45 - 1), (int8x16_t)xmmword_228F41C40);
            int16x8_t v45 = v88;
            uint64_t v54 = v59 + 2;
            *int8x16_t v59 = (int8x16_t)v44;
            v59[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v45 - 1), (int8x16_t)xmmword_228F41C50);
            unint64_t v50 = v55 + 4;
            unint64_t v65 = v55 + 8;
            v55 += 4;
            v59 += 2;
          }
          while (v65 <= v51);
        }
        unint64_t v66 = v51 - v50;
        if (v51 > v50)
        {
          unsigned int v67 = (__int16 *)(v40 + 2 * v50);
          int32x4_t v68 = (_WORD *)(v42 + 2 * v50);
          __n128 v69 = (_WORD *)(v47 + 2 * v50);
          do
          {
            __int16 v70 = *v67++;
            LOWORD(v71) = v70;
            WORD1(v71) = *v68++;
            WORD2(v71) = *v69++;
            HIWORD(v71) = v36;
            v54->i64[0] = v71;
            uint64_t v54 = (int8x16_t *)((char *)v54 + 8);
            --v66;
          }
          while (v66);
          unint64_t v50 = v51;
        }
        if (a10 > v50)
        {
          int8x16_t v87 = v24;
          bzero(v54, 8 * (a10 - v50));
          int8x16_t v24 = v87;
          int16x8_t v37 = v88;
        }
      }
      a12 = (int8x16_t *)((char *)a12 + a13);
      v33 += a11;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(v85 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v20 = *(void *)(a4 + 24);
  uint64_t v81 = *(unsigned int *)(a4 + 44);
  unsigned int v84 = *(ChannelDescription **)(a5 + 8);
  unint64_t v83 = v20;
  unsigned int v82 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v84, (*(_DWORD *)(a4 + 52) + HIDWORD(v20) * *(_DWORD *)(a3 + 60)), v20, v82);
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v77 = *(unsigned int *)(a4 + 44);
  uint64_t v79 = v21;
  int16x8_t v80 = *(ChannelDescription **)(a6 + 8);
  unsigned int v78 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v80, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v78);
  uint64_t v85 = a3;
  uint64_t v22 = *(void *)(a4 + 24);
  uint64_t v73 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = v22;
  unsigned int v76 = *(ChannelDescription **)(a7 + 8);
  unsigned int v74 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v74);
  uint64_t v24 = *a8;
  if (*(unsigned char *)(*a8 + 24)) {
    _D1 = *(double *)v24;
  }
  else {
    _D1 = NAN;
  }
  int v26 = *(_DWORD *)(v24 + 16);
  switch(v26)
  {
    case 2:
      *(float *)&unsigned int v23 = _D1;
      break;
    case 1:
      __asm { FCVT            H0, D1 }
      HIWORD(v86) = _H0;
      LOWORD(v86) = _H0;
      unsigned int v23 = v86;
      break;
    case 0:
      unsigned int v23 = _D1;
      break;
  }
  unint64_t v31 = *(void *)(a3 + 56);
  uint64_t v32 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v32 < HIDWORD(v31))
  {
    unsigned int v34 = v23;
    int v72 = *(_DWORD *)(a4 + 28) * HIDWORD(v31);
    unint64_t v35 = a1 + a2;
    int32x4_t v71 = vdupq_n_s32(v23);
    do
    {
      unint64_t v36 = (v72 + v32);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v84, v36, v83, v82);
      if (HIDWORD(LocationForTile)) {
        unint64_t v38 = a1 + LocationForTile + 4 * v81;
      }
      else {
        unint64_t v38 = 0;
      }
      unint64_t v39 = ChannelDescription::GetLocationForTile(v80, v36, v79, v78);
      if (HIDWORD(v39)) {
        unint64_t v40 = a1 + v39 + 4 * v77;
      }
      else {
        unint64_t v40 = 0;
      }
      unint64_t v41 = ChannelDescription::GetLocationForTile(v76, v36, v75, v74);
      if (HIDWORD(v41)) {
        unint64_t v42 = a1 + v41 + 4 * v73;
      }
      else {
        unint64_t v42 = 0;
      }
      if (v38) {
        _ZF = v40 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v42 != 0)
      {
        unint64_t v45 = 0;
        unint64_t v46 = (v35 - v38) >> 2;
        if (v35 <= v38) {
          unint64_t v46 = 0;
        }
        if (v46 >= a10) {
          unint64_t v46 = a10;
        }
        unint64_t v47 = (v35 - v40) >> 2;
        if (v35 <= v40) {
          unint64_t v47 = 0;
        }
        if (v46 >= v47) {
          unint64_t v46 = v47;
        }
        unint64_t v48 = (v35 - v42) >> 2;
        if (v35 <= v42) {
          unint64_t v48 = 0;
        }
        if (v46 >= v48) {
          unint64_t v46 = v48;
        }
        unint64_t v49 = a12;
        if (v46 >= 4)
        {
          uint64_t v50 = 0;
          unint64_t v51 = (int32x4_t *)v42;
          unint64_t v52 = (int32x4_t *)v40;
          unint64_t v53 = (int32x4_t *)v38;
          uint64_t v54 = a12;
          do
          {
            int32x4_t v55 = *v53++;
            int32x4_t v56 = v55;
            int32x4_t v57 = *v52++;
            int32x4_t v58 = v57;
            int32x4_t v59 = *v51++;
            int32x4_t v60 = vuzp2q_s32(v56, v59);
            v61.i64[1] = __PAIR64__(v71.u32[2], v59.u32[2]);
            v61.i64[0] = __PAIR64__(v58.u32[2], v56.u32[2]);
            int32x4_t v62 = vtrn2q_s32(v60, v56);
            v62.i32[1] = v58.i32[3];
            v62.i32[3] = v71.i32[3];
            int32x4_t v63 = vtrn1q_s32(vuzp1q_s32(v56, v59), v58);
            v63.i32[3] = v71.i32[0];
            v60.i32[1] = v58.i32[1];
            v60.i32[3] = v71.i32[1];
            unint64_t v49 = v54 + 4;
            int32x4_t *v54 = v63;
            v54[1] = v60;
            v54[2] = v61;
            v54[3] = v62;
            unint64_t v45 = v50 + 4;
            unint64_t v64 = v50 + 8;
            v50 += 4;
            v54 += 4;
          }
          while (v64 <= v46);
        }
        unint64_t v65 = v46 - v45;
        if (v46 > v45)
        {
          unint64_t v66 = (int *)(v38 + 4 * v45);
          unsigned int v67 = (__int32 *)(v40 + 4 * v45);
          int32x4_t v68 = (__int32 *)(v42 + 4 * v45);
          do
          {
            int v69 = *v66++;
            v70.i32[0] = v69;
            v70.i32[1] = *v67++;
            v70.i32[2] = *v68++;
            v70.i32[3] = v34;
            *v49++ = v70;
            --v65;
          }
          while (v65);
          unint64_t v45 = v46;
        }
        if (a10 > v45) {
          bzero(v49, 16 * (a10 - v45));
        }
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v32 += a11;
    }
    while (v32 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(v85 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8, double a9, double a10, uint64_t a11, unint64_t a12, unsigned int a13, int16x4_t *a14, uint64_t a15)
{
  uint64_t v17 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v17;
  }
  else {
    _D0 = NAN;
  }
  int v19 = *(_DWORD *)(v17 + 16);
  if (v19 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v19 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v78) = _H0;
    LOWORD(v78) = _H0;
    LODWORD(_D0) = v78;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  int16x4_t v74 = *(int16x4_t *)&_D0;
  uint64_t v24 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v24;
  }
  else {
    _D0 = NAN;
  }
  int v26 = *(_DWORD *)(v24 + 16);
  if (v26 == 2)
  {
    *(float *)&a10 = _D0;
  }
  else if (v26 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v79) = _H0;
    LOWORD(v79) = _H0;
    LODWORD(a10) = v79;
  }
  else
  {
    LODWORD(a10) = _D0;
  }
  uint64_t v28 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v28;
  }
  else {
    _D0 = NAN;
  }
  int v30 = *(_DWORD *)(v28 + 16);
  double v63 = a10;
  if (v30 == 2)
  {
    *(float *)&unsigned int v31 = _D0;
  }
  else if (v30 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v80) = _H0;
    LOWORD(v80) = _H0;
    unsigned int v31 = v80;
  }
  else
  {
    unsigned int v31 = _D0;
  }
  uint64_t v33 = *(ChannelDescription **)(a8 + 8);
  uint64_t v34 = *(void *)(a4 + 24);
  uint64_t v35 = v34;
  unsigned int v36 = *(_DWORD *)(a4 + 60);
  uint64_t v65 = *(unsigned int *)(a4 + 44);
  ChannelDescription::GetLocationForTile(v33, (*(_DWORD *)(a4 + 52) + HIDWORD(v34) * *(_DWORD *)(a3 + 60)), v34, v36);
  unint64_t v40 = *(void *)(a3 + 56);
  uint64_t v41 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v41 < HIDWORD(v40))
  {
    int v43 = *(_DWORD *)(a4 + 28) * HIDWORD(v40);
    int16x4_t v44 = v74;
    v81.val[0] = (int8x16_t)vdupq_n_s16(v74.u32[0]);
    int16x8_t v45 = vdupq_n_s16(LODWORD(v63));
    v81.val[1] = (int8x16_t)vdupq_n_s16(v31);
    unint64_t v64 = a1 + a2;
    v81.val[0] = vqtbl2q_s8(v81, (int8x16_t)xmmword_228F41C10);
    int16x8_t v46 = vzip2q_s16((int16x8_t)v81.val[0], (int16x8_t)v81.val[0]);
    int16x8_t v47 = vzip1q_s16((int16x8_t)v81.val[0], (int16x8_t)v81.val[0]);
    v44.i16[2] = v31;
    int16x4_t v48 = vuzp1_s16(v44, v44);
    do
    {
      int16x8_t v68 = v47;
      int8x16_t v69 = v39;
      int16x8_t v71 = v46;
      int8x16_t v72 = v38;
      int16x8_t v75 = v45;
      long long v76 = v37;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v33, (v43 + v41), v35, v36);
      int16x8_t v47 = v68;
      int8x16_t v39 = v69;
      int16x8_t v46 = v71;
      int8x16_t v38 = v72;
      int16x8_t v45 = v75;
      long long v37 = v76;
      uint64_t v50 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v50 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v52 = 0;
        unint64_t v53 = (uint64_t *)(v50 + 2 * v65);
        unint64_t v54 = (v64 - (unint64_t)v53) >> 1;
        if (v64 <= (unint64_t)v53) {
          unint64_t v54 = 0;
        }
        if (a12 < v54) {
          unint64_t v54 = a12;
        }
        int32x4_t v55 = a14;
        if (v54 >= 4)
        {
          uint64_t v56 = 0;
          int32x4_t v57 = (int8x16_t *)a14;
          do
          {
            uint64_t v58 = *v53++;
            *(void *)&long long v37 = v58;
            int8x16_t v39 = vqtbl2q_s8(*(int8x16x2_t *)(&v37 - 1), (int8x16_t)xmmword_228F41C10);
            int8x16_t v38 = v39;
            int32x4_t v55 = (int16x4_t *)&v57[2];
            int8x16_t *v57 = vqtbl2q_s8(*(int8x16x2_t *)(&v39 - 1), (int8x16_t)xmmword_228F41C10);
            v57[1] = vqtbl2q_s8(*(int8x16x2_t *)(&v38 - 1), (int8x16_t)xmmword_228F41BF0);
            unint64_t v52 = v56 + 4;
            unint64_t v59 = v56 + 8;
            v56 += 4;
            v57 += 2;
          }
          while (v59 <= v54);
        }
        unint64_t v60 = v54 - v52;
        if (v54 > v52)
        {
          int32x4_t v61 = (__int16 *)(v50 + 2 * v65 + 2 * v52);
          do
          {
            int16x4_t v62 = *(int16x4_t *)&v63;
            v62.i16[1] = *v61++;
            *v55++ = vzip1_s16(v48, v62);
            --v60;
          }
          while (v60);
          unint64_t v52 = v54;
        }
        if (a12 > v52)
        {
          long long v77 = v37;
          int8x16_t v73 = v38;
          int8x16_t v70 = v39;
          bzero(v55, 8 * (a12 - v52));
          int16x8_t v47 = v68;
          int8x16_t v39 = v70;
          int16x8_t v46 = v71;
          int8x16_t v38 = v73;
          int16x8_t v45 = v75;
          long long v37 = v77;
        }
      }
      a14 = (int16x4_t *)((char *)a14 + a15);
      v41 += a13;
    }
    while (v41 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8, __n128 _Q0, __n128 a10, uint64_t a11, unint64_t a12, unsigned int a13, int32x4_t *a14, uint64_t a15)
{
  uint64_t v17 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _Q0.n128_u64[0] = *(void *)v17;
  }
  else {
    _Q0.n128_u64[0] = 0x7FF8000000000000;
  }
  int v18 = *(_DWORD *)(v17 + 16);
  if (v18 == 2)
  {
    _Q0.n128_f32[0] = _Q0.n128_f64[0];
  }
  else if (v18 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v67) = _H0;
    LOWORD(v67) = _H0;
    _Q0.n128_u32[0] = v67;
  }
  else
  {
    _Q0.n128_u32[0] = _Q0.n128_f64[0];
  }
  uint64_t v23 = *a6;
  __n128 v63 = _Q0;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v23;
  }
  else {
    _D0 = NAN;
  }
  int v25 = *(_DWORD *)(v23 + 16);
  if (v25 == 2)
  {
    a10.n128_f32[0] = _D0;
  }
  else if (v25 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v68) = _H0;
    LOWORD(v68) = _H0;
    a10.n128_u32[0] = v68;
  }
  else
  {
    a10.n128_u32[0] = _D0;
  }
  uint64_t v27 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v27;
  }
  else {
    _D0 = NAN;
  }
  int v29 = *(_DWORD *)(v27 + 16);
  __n128 v58 = a10;
  if (v29 == 2)
  {
    float v30 = _D0;
  }
  else if (v29 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v69) = _H0;
    LOWORD(v69) = _H0;
    float v30 = v69;
  }
  else
  {
    LODWORD(v30) = _D0;
  }
  float v61 = v30;
  uint64_t v32 = *(ChannelDescription **)(a8 + 8);
  uint64_t v33 = *(void *)(a4 + 24);
  uint64_t v34 = v33;
  unsigned int v35 = *(_DWORD *)(a4 + 60);
  uint64_t v60 = *(unsigned int *)(a4 + 44);
  ChannelDescription::GetLocationForTile(v32, (*(_DWORD *)(a4 + 52) + HIDWORD(v33) * *(_DWORD *)(a3 + 60)), v33, v35);
  unint64_t v36 = *(void *)(a3 + 56);
  uint64_t v37 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v37 < HIDWORD(v36))
  {
    int v39 = *(_DWORD *)(a4 + 28) * HIDWORD(v36);
    int32x4_t v40 = vdupq_n_s32(v58.n128_u32[0]);
    unint64_t v59 = a1 + a2;
    int32x4_t v41 = (int32x4_t)v63;
    *(float *)&v41.i32[2] = v61;
    int32x4_t v62 = vuzp1q_s32(v40, v40);
    int32x4_t v64 = vuzp1q_s32(v41, v41);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v32, (v39 + v37), v34, v35);
      uint64_t v43 = a1 + LocationForTile;
      if (HIDWORD(LocationForTile)) {
        _ZF = v43 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF)
      {
        unint64_t v45 = 0;
        int16x8_t v46 = (int32x4_t *)(v43 + 4 * v60);
        unint64_t v47 = (v59 - (unint64_t)v46) >> 2;
        if (v59 <= (unint64_t)v46) {
          unint64_t v47 = 0;
        }
        if (a12 < v47) {
          unint64_t v47 = a12;
        }
        int16x4_t v48 = a14;
        if (v47 >= 4)
        {
          uint64_t v49 = 0;
          uint64_t v50 = a14;
          do
          {
            int32x4_t v51 = *v46++;
            int32x4_t v52 = vzip1q_s32(v62, v51);
            int32x4_t v53 = vzip2q_s32(v62, v51);
            int16x4_t v48 = v50 + 4;
            *uint64_t v50 = vzip1q_s32(v64, v52);
            v50[1] = vzip2q_s32(v64, v52);
            v50[2] = vzip1q_s32(v64, v53);
            v50[3] = vzip2q_s32(v64, v53);
            unint64_t v45 = v49 + 4;
            unint64_t v54 = v49 + 8;
            v49 += 4;
            v50 += 4;
          }
          while (v54 <= v47);
        }
        unint64_t v55 = v47 - v45;
        if (v47 > v45)
        {
          uint64_t v56 = (__int32 *)(v43 + 4 * v60 + 4 * v45);
          do
          {
            int32x4_t v57 = (int32x4_t)v58;
            v57.i32[1] = *v56++;
            *v48++ = vzip1q_s32(v64, v57);
            --v55;
          }
          while (v55);
          unint64_t v45 = v47;
        }
        if (a12 > v45) {
          bzero(v48, 16 * (a12 - v45));
        }
      }
      a14 = (int32x4_t *)((char *)a14 + a15);
      v37 += a13;
    }
    while (v37 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int8x16_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v71 = *(unsigned int *)(a4 + 44);
  uint64_t v77 = v19;
  int v78 = *(ChannelDescription **)(a5 + 8);
  unsigned int v76 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v78, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v76);
  uint64_t v21 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v21;
  }
  else {
    _D0 = NAN;
  }
  int v23 = *(_DWORD *)(v21 + 16);
  if (v23 == 2)
  {
    *(float *)v20.i32 = _D0;
  }
  else if (v23 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v80) = _H0;
    LOWORD(v80) = _H0;
    v20.i32[0] = v80;
  }
  else
  {
    v20.i32[0] = _D0;
  }
  uint64_t v28 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v28;
  }
  else {
    _D0 = NAN;
  }
  int v30 = *(_DWORD *)(v28 + 16);
  int16x4_t v68 = v20;
  if (v30 == 2)
  {
    *(float *)&unsigned int v31 = _D0;
  }
  else if (v30 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v81) = _H0;
    LOWORD(v81) = _H0;
    unsigned int v31 = v81;
  }
  else
  {
    unsigned int v31 = _D0;
  }
  uint64_t v33 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v74 = v33;
  int16x8_t v75 = *(ChannelDescription **)(a8 + 8);
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v33) * *(_DWORD *)(a3 + 60)), v33, v73);
  unint64_t v34 = *(void *)(a3 + 56);
  uint64_t v35 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v35 < HIDWORD(v34))
  {
    int v37 = *(_DWORD *)(a4 + 28) * HIDWORD(v34);
    unint64_t v38 = a1 + a2;
    int16x8_t v69 = vdupq_n_s16(v68.u32[0]);
    int16x8_t v72 = vdupq_n_s16(v31);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v78, (v37 + v35), v77, v76);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v40 = LocationForTile;
        unint64_t v41 = ChannelDescription::GetLocationForTile(v75, (v37 + v35), v74, v73);
        if (HIDWORD(v41))
        {
          uint64_t v44 = a1 + v40;
          uint64_t v45 = a1 + v41;
          if (v44 && v45 != 0)
          {
            unint64_t v47 = 0;
            int16x4_t v48 = (uint64_t *)(v44 + 2 * v71);
            uint64_t v49 = (uint64_t *)(v45 + 2 * v70);
            unint64_t v50 = (v38 - (unint64_t)v48) >> 1;
            if (v38 <= (unint64_t)v48) {
              unint64_t v50 = 0;
            }
            if (v50 >= a10) {
              unint64_t v50 = a10;
            }
            unint64_t v51 = (v38 - (unint64_t)v49) >> 1;
            if (v38 <= (unint64_t)v49) {
              unint64_t v51 = 0;
            }
            if (v50 >= v51) {
              unint64_t v50 = v51;
            }
            int32x4_t v52 = a12;
            if (v50 >= 4)
            {
              uint64_t v53 = 0;
              unint64_t v54 = a12;
              do
              {
                uint64_t v55 = *v48++;
                v42.i64[0] = v55;
                int16x8_t v56 = vzip1q_s16(v42, v72);
                uint64_t v57 = *v49++;
                uint64_t v58 = v57;
                int16x8_t v59 = vzip1q_s16(v56, v69);
                int8x16_t v60 = vqtbl2q_s8(*(int8x16x2_t *)(&v43 - 3), (int8x16_t)xmmword_228F41C70);
                int16x8_t v61 = vzip2q_s16(v56, v69);
                int16x8_t v42 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v43 - 3), (int8x16_t)xmmword_228F41C50);
                int32x4_t v52 = v54 + 2;
                int8x16_t *v54 = v60;
                v54[1] = (int8x16_t)v42;
                unint64_t v47 = v53 + 4;
                unint64_t v62 = v53 + 8;
                v53 += 4;
                v54 += 2;
              }
              while (v62 <= v50);
            }
            unint64_t v63 = v50 - v47;
            if (v50 > v47)
            {
              int32x4_t v64 = (unsigned __int16 *)(v44 + 2 * v71 + 2 * v47);
              uint64_t v65 = (__int16 *)(v45 + 2 * v70 + 2 * v47);
              do
              {
                __int32 v66 = *v64++;
                v42.i32[0] = v66;
                v42.i16[2] = v31;
                int16x4_t v67 = v68;
                v67.i16[1] = *v65++;
                *(int16x4_t *)v42.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v42.i8, *(int16x4_t *)v42.i8), v67);
                v52->i64[0] = v42.i64[0];
                int32x4_t v52 = (int8x16_t *)((char *)v52 + 8);
                --v63;
              }
              while (v63);
              unint64_t v47 = v50;
            }
            if (a10 > v47) {
              bzero(v52, 8 * (a10 - v47));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v75, (v37 + v35), v74, v73);
      }
      a12 = (int8x16_t *)((char *)a12 + a13);
      v35 += a11;
    }
    while (v35 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)0,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v69 = *(unsigned int *)(a4 + 44);
  uint64_t v77 = *(ChannelDescription **)(a5 + 8);
  unint64_t v76 = v19;
  unsigned int v75 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v77, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v75);
  uint64_t v21 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v21;
  }
  else {
    _D0 = NAN;
  }
  int v23 = *(_DWORD *)(v21 + 16);
  if (v23 == 2)
  {
    *(float *)v20.i32 = _D0;
  }
  else if (v23 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v79) = _H0;
    LOWORD(v79) = _H0;
    v20.i32[0] = v79;
  }
  else
  {
    v20.i32[0] = _D0;
  }
  uint64_t v28 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v28;
  }
  else {
    _D0 = NAN;
  }
  int v30 = *(_DWORD *)(v28 + 16);
  int32x4_t v67 = v20;
  if (v30 == 2)
  {
    *(float *)&unsigned int v31 = _D0;
  }
  else if (v30 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v80) = _H0;
    LOWORD(v80) = _H0;
    unsigned int v31 = v80;
  }
  else
  {
    unsigned int v31 = _D0;
  }
  uint64_t v33 = *(void *)(a4 + 24);
  uint64_t v68 = *(unsigned int *)(a4 + 44);
  uint64_t v73 = v33;
  uint64_t v74 = *(ChannelDescription **)(a8 + 8);
  unsigned int v72 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v74, (*(_DWORD *)(a4 + 52) + HIDWORD(v33) * *(_DWORD *)(a3 + 60)), v33, v72);
  unint64_t v34 = *(void *)(a3 + 56);
  uint64_t v35 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v35 < HIDWORD(v34))
  {
    int v37 = *(_DWORD *)(a4 + 28) * HIDWORD(v34);
    unint64_t v38 = a1 + a2;
    int32x4_t v70 = vdupq_n_s32(v31);
    int32x4_t v71 = vdupq_n_s32(v67.u32[0]);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v77, (v37 + v35), v76, v75);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v40 = LocationForTile;
        unint64_t v41 = ChannelDescription::GetLocationForTile(v74, (v37 + v35), v73, v72);
        if (HIDWORD(v41))
        {
          uint64_t v43 = a1 + v40;
          uint64_t v44 = a1 + v41;
          if (v43 && v44 != 0)
          {
            unint64_t v46 = 0;
            unint64_t v47 = (int32x4_t *)(v43 + 4 * v69);
            int16x4_t v48 = (long long *)(v44 + 4 * v68);
            unint64_t v49 = (v38 - (unint64_t)v47) >> 2;
            if (v38 <= (unint64_t)v47) {
              unint64_t v49 = 0;
            }
            if (v49 >= a10) {
              unint64_t v49 = a10;
            }
            unint64_t v50 = (v38 - (unint64_t)v48) >> 2;
            if (v38 <= (unint64_t)v48) {
              unint64_t v50 = 0;
            }
            if (v49 >= v50) {
              unint64_t v49 = v50;
            }
            unint64_t v51 = a12;
            if (v49 >= 4)
            {
              uint64_t v52 = 0;
              uint64_t v53 = a12;
              do
              {
                int32x4_t v54 = *v47++;
                int32x4_t v55 = v54;
                long long v56 = *v48++;
                int32x4_t v57 = v70;
                v57.i32[0] = v55.i32[2];
                int32x4_t v58 = vuzp2q_s32(v55, v70);
                int32x4_t v59 = vtrn2q_s32(v58, v55);
                v59.i32[1] = v71.i32[2];
                v59.i32[3] = HIDWORD(v56);
                int32x4_t v42 = vtrn1q_s32(vuzp1q_s32(v55, v70), v71);
                v42.i32[3] = v56;
                v58.i32[1] = v71.i32[2];
                v58.i32[3] = DWORD1(v56);
                int32x4_t v60 = vtrn1q_s32(v57, v71);
                v60.i32[3] = DWORD2(v56);
                unint64_t v51 = v53 + 4;
                int32x4_t *v53 = v42;
                v53[1] = v58;
                v53[2] = v60;
                v53[3] = v59;
                unint64_t v46 = v52 + 4;
                unint64_t v61 = v52 + 8;
                v52 += 4;
                v53 += 4;
              }
              while (v61 <= v49);
            }
            unint64_t v62 = v49 - v46;
            if (v49 > v46)
            {
              unint64_t v63 = (__int32 *)(v43 + 4 * v69 + 4 * v46);
              int32x4_t v64 = (__int32 *)(v44 + 4 * v68 + 4 * v46);
              do
              {
                __int32 v65 = *v63++;
                v42.i32[0] = v65;
                v42.i32[2] = v31;
                int32x4_t v66 = v67;
                v66.i32[1] = *v64++;
                int32x4_t v42 = vzip1q_s32(vuzp1q_s32(v42, v42), v66);
                *v51++ = v42;
                --v62;
              }
              while (v62);
              unint64_t v46 = v49;
            }
            if (a10 > v46) {
              bzero(v51, 16 * (a10 - v46));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v74, (v37 + v35), v73, v72);
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v35 += a11;
    }
    while (v35 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int16x8_t *a12, uint64_t a13)
{
  uint64_t v18 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v18;
  }
  else {
    _D0 = NAN;
  }
  int v20 = *(_DWORD *)(v18 + 16);
  if (v20 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v20 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v82) = _H0;
    LOWORD(v82) = _H0;
    LODWORD(_D0) = v82;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  int16x4_t v78 = *(int16x4_t *)&_D0;
  uint64_t v25 = *(void *)(a4 + 24);
  uint64_t v67 = *(unsigned int *)(a4 + 44);
  uint64_t v72 = v25;
  uint64_t v73 = *(ChannelDescription **)(a6 + 8);
  unsigned int v71 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v73, (*(_DWORD *)(a4 + 52) + HIDWORD(v25) * *(_DWORD *)(a3 + 60)), v25, v71);
  uint64_t v26 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v26;
  }
  else {
    _D0 = NAN;
  }
  int v28 = *(_DWORD *)(v26 + 16);
  if (v28 == 2)
  {
    *(float *)&unsigned int v29 = _D0;
  }
  else if (v28 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v83) = _H0;
    LOWORD(v83) = _H0;
    unsigned int v29 = v83;
  }
  else
  {
    unsigned int v29 = _D0;
  }
  uint64_t v31 = *(void *)(a4 + 24);
  uint64_t v66 = *(unsigned int *)(a4 + 44);
  uint64_t v69 = v31;
  int32x4_t v70 = *(ChannelDescription **)(a8 + 8);
  unsigned int v68 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v70, (*(_DWORD *)(a4 + 52) + HIDWORD(v31) * *(_DWORD *)(a3 + 60)), v31, v68);
  unint64_t v34 = *(void *)(a3 + 56);
  uint64_t v35 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v35 < HIDWORD(v34))
  {
    int v37 = *(_DWORD *)(a4 + 28) * HIDWORD(v34);
    unint64_t v38 = a1 + a2;
    int16x4_t v39 = v78;
    v84.val[0] = (int8x16_t)vdupq_n_s16(v78.u32[0]);
    v84.val[1] = (int8x16_t)vdupq_n_s16(v29);
    v84.val[0] = vqtbl2q_s8(v84, (int8x16_t)xmmword_228F41C10);
    int16x8_t v40 = vzip2q_s16((int16x8_t)v84.val[0], (int16x8_t)v84.val[0]);
    v39.i16[2] = v29;
    int16x8_t v41 = vzip1q_s16((int16x8_t)v84.val[0], (int16x8_t)v84.val[0]);
    int16x4_t v42 = vuzp1_s16(v39, v39);
    do
    {
      int16x8_t v75 = v41;
      int16x8_t v76 = v33;
      int16x8_t v79 = v40;
      int16x8_t v80 = v32;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v73, (v37 + v35), v72, v71);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v44 = LocationForTile;
        unint64_t v45 = ChannelDescription::GetLocationForTile(v70, (v37 + v35), v69, v68);
        int16x8_t v40 = v79;
        int16x8_t v32 = v80;
        int16x8_t v41 = v75;
        int16x8_t v33 = v76;
        if (HIDWORD(v45))
        {
          uint64_t v48 = a1 + v44;
          uint64_t v49 = a1 + v45;
          if (v48 && v49 != 0)
          {
            unint64_t v51 = 0;
            uint64_t v52 = (uint64_t *)(v48 + 2 * v67);
            uint64_t v53 = (uint64_t *)(v49 + 2 * v66);
            unint64_t v54 = (v38 - (unint64_t)v52) >> 1;
            if (v38 <= (unint64_t)v52) {
              unint64_t v54 = 0;
            }
            if (a10 < v54) {
              unint64_t v54 = a10;
            }
            unint64_t v55 = (v38 - (unint64_t)v53) >> 1;
            if (v38 <= (unint64_t)v53) {
              unint64_t v55 = 0;
            }
            if (v54 >= v55) {
              unint64_t v54 = v55;
            }
            long long v56 = a12;
            if (v54 >= 4)
            {
              uint64_t v57 = 0;
              int32x4_t v58 = a12;
              do
              {
                uint64_t v59 = *v52++;
                v46.i64[0] = v59;
                uint64_t v60 = *v53++;
                v47.i64[0] = v60;
                int16x8_t v33 = vzip1q_s16(v46, v47);
                int16x8_t v46 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v33 - 1), (int8x16_t)xmmword_228F41C10);
                int16x8_t v32 = v33;
                int16x8_t v47 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v32 - 1), (int8x16_t)xmmword_228F41BF0);
                long long v56 = v58 + 2;
                *int32x4_t v58 = v46;
                v58[1] = v47;
                unint64_t v51 = v57 + 4;
                unint64_t v61 = v57 + 8;
                v57 += 4;
                v58 += 2;
              }
              while (v61 <= v54);
            }
            unint64_t v62 = v54 - v51;
            if (v54 > v51)
            {
              unint64_t v63 = (__int16 *)(v48 + 2 * v67 + 2 * v51);
              int32x4_t v64 = (__int16 *)(v49 + 2 * v66 + 2 * v51);
              do
              {
                __int16 v65 = *v63++;
                v46.i16[0] = v65;
                v46.i16[1] = *v64++;
                *(int16x4_t *)v46.i8 = vzip1_s16(v42, *(int16x4_t *)v46.i8);
                v56->i64[0] = v46.i64[0];
                long long v56 = (int16x8_t *)((char *)v56 + 8);
                --v62;
              }
              while (v62);
              unint64_t v51 = v54;
            }
            if (a10 > v51)
            {
              int16x8_t v81 = v32;
              int16x8_t v77 = v33;
              bzero(v56, 8 * (a10 - v51));
              int16x8_t v41 = v75;
              int16x8_t v33 = v77;
              int16x8_t v40 = v79;
              int16x8_t v32 = v81;
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v70, (v37 + v35), v69, v68);
        int16x8_t v40 = v79;
        int16x8_t v32 = v80;
        int16x8_t v41 = v75;
        int16x8_t v33 = v76;
      }
      a12 = (int16x8_t *)((char *)a12 + a13);
      v35 += a11;
    }
    while (v35 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, __n128 _Q0, uint64_t a10, unint64_t a11, unsigned int a12, int32x4_t *a13, uint64_t a14)
{
  uint64_t v19 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _Q0.n128_u64[0] = *(void *)v19;
  }
  else {
    _Q0.n128_u64[0] = 0x7FF8000000000000;
  }
  int v20 = *(_DWORD *)(v19 + 16);
  if (v20 == 2)
  {
    _Q0.n128_f32[0] = _Q0.n128_f64[0];
  }
  else if (v20 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v77) = _H0;
    LOWORD(v77) = _H0;
    _Q0.n128_u32[0] = v77;
  }
  else
  {
    _Q0.n128_u32[0] = _Q0.n128_f64[0];
  }
  __n128 v68 = _Q0;
  uint64_t v25 = *(void *)(a4 + 24);
  uint64_t v67 = *(unsigned int *)(a4 + 44);
  int16x8_t v75 = *(ChannelDescription **)(a6 + 8);
  unint64_t v74 = v25;
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v25) * *(_DWORD *)(a3 + 60)), v25, v73);
  uint64_t v26 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v26;
  }
  else {
    _D0 = NAN;
  }
  int v28 = *(_DWORD *)(v26 + 16);
  if (v28 == 2)
  {
    float v29 = _D0;
  }
  else if (v28 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v78) = _H0;
    LOWORD(v78) = _H0;
    float v29 = v78;
  }
  else
  {
    LODWORD(v29) = _D0;
  }
  float v65 = v29;
  uint64_t v31 = *(void *)(a4 + 24);
  uint64_t v66 = *(unsigned int *)(a4 + 44);
  uint64_t v71 = v31;
  uint64_t v72 = *(ChannelDescription **)(a8 + 8);
  unsigned int v70 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a4 + 52) + HIDWORD(v31) * *(_DWORD *)(a3 + 60)), v31, v70);
  unint64_t v32 = *(void *)(a3 + 56);
  uint64_t v33 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v33 < HIDWORD(v32))
  {
    int v35 = *(_DWORD *)(a4 + 28) * HIDWORD(v32);
    unint64_t v36 = a1 + a2;
    int32x4_t v37 = (int32x4_t)v68;
    *(float *)&v37.i32[2] = v65;
    int32x4_t v69 = v37;
    int32x4_t v64 = vuzp1q_s32(v37, v37);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v75, (v35 + v33), v74, v73);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v39 = LocationForTile;
        unint64_t v40 = ChannelDescription::GetLocationForTile(v72, (v35 + v33), v71, v70);
        if (HIDWORD(v40))
        {
          uint64_t v42 = a1 + v39;
          uint64_t v43 = a1 + v40;
          if (v42 && v43 != 0)
          {
            unint64_t v45 = 0;
            int16x8_t v46 = (int32x4_t *)(v42 + 4 * v67);
            int16x8_t v47 = (long long *)(v43 + 4 * v66);
            unint64_t v48 = (v36 - (unint64_t)v46) >> 2;
            if (v36 <= (unint64_t)v46) {
              unint64_t v48 = 0;
            }
            if (a11 < v48) {
              unint64_t v48 = a11;
            }
            unint64_t v49 = (v36 - (unint64_t)v47) >> 2;
            if (v36 <= (unint64_t)v47) {
              unint64_t v49 = 0;
            }
            if (v48 >= v49) {
              unint64_t v48 = v49;
            }
            unint64_t v50 = a13;
            if (v48 >= 4)
            {
              uint64_t v51 = 0;
              uint64_t v52 = a13;
              do
              {
                int32x4_t v53 = *v46++;
                int32x4_t v41 = v53;
                long long v54 = *v47++;
                int32x4_t v55 = v69;
                v55.i32[1] = v41.i32[3];
                v55.i32[3] = HIDWORD(v54);
                int32x4_t v56 = v69;
                v56.i32[1] = v41.i32[2];
                v56.i32[3] = DWORD2(v54);
                int32x4_t v57 = vtrn1q_s32(v69, v41);
                v57.i32[3] = v54;
                int32x4_t v58 = v69;
                v58.i32[1] = v41.i32[1];
                v58.i32[3] = DWORD1(v54);
                unint64_t v50 = v52 + 4;
                int32x4_t *v52 = v57;
                v52[1] = v58;
                v52[2] = v56;
                v52[3] = v55;
                unint64_t v45 = v51 + 4;
                unint64_t v59 = v51 + 8;
                v51 += 4;
                v52 += 4;
              }
              while (v59 <= v48);
            }
            unint64_t v60 = v48 - v45;
            if (v48 > v45)
            {
              unint64_t v61 = (__int32 *)(v42 + 4 * v67 + 4 * v45);
              unint64_t v62 = (__int32 *)(v43 + 4 * v66 + 4 * v45);
              do
              {
                __int32 v63 = *v61++;
                v41.i32[0] = v63;
                v41.i32[1] = *v62++;
                int32x4_t v41 = vzip1q_s32(v64, v41);
                *v50++ = v41;
                --v60;
              }
              while (v60);
              unint64_t v45 = v48;
            }
            if (a11 > v45) {
              bzero(v50, 16 * (a11 - v45));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v72, (v35 + v33), v71, v70);
      }
      a13 = (int32x4_t *)((char *)a13 + a14);
      v33 += a12;
    }
    while (v33 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int16x8_t *a12, uint64_t a13)
{
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v78 = *(unsigned int *)(a4 + 44);
  uint64_t v80 = v21;
  int16x8_t v81 = *(ChannelDescription **)(a5 + 8);
  unsigned int v79 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v81, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v79);
  uint64_t v82 = a3;
  uint64_t v22 = *(void *)(a4 + 24);
  uint64_t v74 = *(unsigned int *)(a4 + 44);
  uint64_t v76 = v22;
  unsigned __int32 v77 = *(ChannelDescription **)(a6 + 8);
  unsigned int v75 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v77, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v75);
  uint64_t v23 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v23;
  }
  else {
    _D0 = NAN;
  }
  int v25 = *(_DWORD *)(v23 + 16);
  switch(v25)
  {
    case 2:
      *(float *)&unsigned int v13 = _D0;
      break;
    case 1:
      __asm { FCVT            H0, D0 }
      HIWORD(v83) = _H0;
      LOWORD(v83) = _H0;
      unsigned int v13 = v83;
      break;
    case 0:
      unsigned int v13 = _D0;
      break;
  }
  uint64_t v30 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v72 = v30;
  unsigned int v73 = *(ChannelDescription **)(a8 + 8);
  unsigned int v71 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v73, (*(_DWORD *)(a4 + 52) + HIDWORD(v30) * *(_DWORD *)(a3 + 60)), v30, v71);
  unint64_t v31 = *(void *)(a3 + 56);
  uint64_t v32 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v32 < HIDWORD(v31))
  {
    int v69 = *(_DWORD *)(a4 + 28) * HIDWORD(v31);
    unint64_t v34 = a1 + a2;
    int16x8_t v68 = vdupq_n_s16(v13);
    do
    {
      unint64_t v35 = (v69 + v32);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v81, v35, v80, v79);
      if (HIDWORD(LocationForTile)) {
        unint64_t v37 = a1 + LocationForTile + 2 * v78;
      }
      else {
        unint64_t v37 = 0;
      }
      unint64_t v38 = ChannelDescription::GetLocationForTile(v77, v35, v76, v75);
      if (HIDWORD(v38)) {
        unint64_t v39 = a1 + v38 + 2 * v74;
      }
      else {
        unint64_t v39 = 0;
      }
      unint64_t v40 = ChannelDescription::GetLocationForTile(v73, v35, v72, v71);
      if (HIDWORD(v40)) {
        unint64_t v44 = a1 + v40 + 2 * v70;
      }
      else {
        unint64_t v44 = 0;
      }
      if (v37) {
        _ZF = v39 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v44 != 0)
      {
        unint64_t v47 = 0;
        unint64_t v48 = (v34 - v37) >> 1;
        if (v34 <= v37) {
          unint64_t v48 = 0;
        }
        if (v48 >= a10) {
          unint64_t v48 = a10;
        }
        unint64_t v49 = (v34 - v39) >> 1;
        if (v34 <= v39) {
          unint64_t v49 = 0;
        }
        if (v48 >= v49) {
          unint64_t v48 = v49;
        }
        unint64_t v50 = (v34 - v44) >> 1;
        if (v34 <= v44) {
          unint64_t v50 = 0;
        }
        if (v48 >= v50) {
          unint64_t v48 = v50;
        }
        uint64_t v51 = a12;
        if (v48 >= 4)
        {
          uint64_t v52 = 0;
          int32x4_t v53 = (uint64_t *)v44;
          long long v54 = (uint64_t *)v39;
          int32x4_t v55 = (uint64_t *)v37;
          int32x4_t v56 = a12;
          do
          {
            uint64_t v57 = *v55++;
            v41.i64[0] = v57;
            uint64_t v58 = *v54++;
            v42.i64[0] = v58;
            uint64_t v59 = *v53++;
            v43.i64[0] = v59;
            int16x8_t v60 = vzip1q_s16(v41, v68);
            int16x8_t v42 = vzip1q_s16(v42, v43);
            int16x8_t v43 = vzip1q_s16(v60, v42);
            int16x8_t v41 = vzip2q_s16(v60, v42);
            uint64_t v51 = v56 + 2;
            int16x8_t *v56 = v43;
            v56[1] = v41;
            unint64_t v47 = v52 + 4;
            unint64_t v61 = v52 + 8;
            v52 += 4;
            v56 += 2;
          }
          while (v61 <= v48);
        }
        unint64_t v62 = v48 - v47;
        if (v48 > v47)
        {
          __int32 v63 = (__int16 *)(v37 + 2 * v47);
          int32x4_t v64 = (_WORD *)(v39 + 2 * v47);
          float v65 = (_WORD *)(v44 + 2 * v47);
          do
          {
            __int16 v66 = *v63++;
            LOWORD(v67) = v66;
            WORD1(v67) = *v64++;
            WORD2(v67) = v13;
            HIWORD(v67) = *v65++;
            v51->i64[0] = v67;
            uint64_t v51 = (int16x8_t *)((char *)v51 + 8);
            --v62;
          }
          while (v62);
          unint64_t v47 = v48;
        }
        if (a10 > v47) {
          bzero(v51, 8 * (a10 - v47));
        }
      }
      a12 = (int16x8_t *)((char *)a12 + a13);
      v32 += a11;
    }
    while (v32 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(v82 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)1,(StreamType)0,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v80 = *(unsigned int *)(a4 + 44);
  uint64_t v82 = v21;
  unsigned int v83 = *(ChannelDescription **)(a5 + 8);
  unsigned int v81 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v83, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v81);
  uint64_t v22 = *(void *)(a4 + 24);
  uint64_t v76 = *(unsigned int *)(a4 + 44);
  uint64_t v78 = v22;
  unsigned int v79 = *(ChannelDescription **)(a6 + 8);
  unsigned int v77 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v77);
  uint64_t v23 = *a7;
  if (*(unsigned char *)(*a7 + 24)) {
    _D0 = *(double *)v23;
  }
  else {
    _D0 = NAN;
  }
  int v25 = *(_DWORD *)(v23 + 16);
  switch(v25)
  {
    case 2:
      *(float *)&unsigned int v13 = _D0;
      break;
    case 1:
      __asm { FCVT            H0, D0 }
      HIWORD(v84) = _H0;
      LOWORD(v84) = _H0;
      unsigned int v13 = v84;
      break;
    case 0:
      unsigned int v13 = _D0;
      break;
  }
  uint64_t v30 = *(void *)(a4 + 24);
  uint64_t v72 = *(unsigned int *)(a4 + 44);
  uint64_t v74 = v30;
  unsigned int v75 = *(ChannelDescription **)(a8 + 8);
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v30) * *(_DWORD *)(a3 + 60)), v30, v73);
  unint64_t v31 = *(void *)(a3 + 56);
  uint64_t v32 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v32 < HIDWORD(v31))
  {
    int v71 = *(_DWORD *)(a4 + 28) * HIDWORD(v31);
    unint64_t v34 = a1 + a2;
    int32x4_t v70 = vdupq_n_s32(v13);
    do
    {
      unint64_t v35 = (v71 + v32);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v83, v35, v82, v81);
      if (HIDWORD(LocationForTile)) {
        unint64_t v37 = a1 + LocationForTile + 4 * v80;
      }
      else {
        unint64_t v37 = 0;
      }
      unint64_t v38 = ChannelDescription::GetLocationForTile(v79, v35, v78, v77);
      if (HIDWORD(v38)) {
        unint64_t v39 = a1 + v38 + 4 * v76;
      }
      else {
        unint64_t v39 = 0;
      }
      unint64_t v40 = ChannelDescription::GetLocationForTile(v75, v35, v74, v73);
      if (HIDWORD(v40)) {
        unint64_t v41 = a1 + v40 + 4 * v72;
      }
      else {
        unint64_t v41 = 0;
      }
      if (v37) {
        _ZF = v39 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v41 != 0)
      {
        unint64_t v44 = 0;
        unint64_t v45 = (v34 - v37) >> 2;
        if (v34 <= v37) {
          unint64_t v45 = 0;
        }
        if (v45 >= a10) {
          unint64_t v45 = a10;
        }
        unint64_t v46 = (v34 - v39) >> 2;
        if (v34 <= v39) {
          unint64_t v46 = 0;
        }
        if (v45 >= v46) {
          unint64_t v45 = v46;
        }
        unint64_t v47 = (v34 - v41) >> 2;
        if (v34 <= v41) {
          unint64_t v47 = 0;
        }
        if (v45 >= v47) {
          unint64_t v45 = v47;
        }
        unint64_t v48 = a12;
        if (v45 >= 4)
        {
          uint64_t v49 = 0;
          unint64_t v50 = (long long *)v41;
          uint64_t v51 = (int32x4_t *)v39;
          uint64_t v52 = (int32x4_t *)v37;
          int32x4_t v53 = a12;
          do
          {
            int32x4_t v54 = *v52++;
            int32x4_t v55 = v54;
            int32x4_t v56 = *v51++;
            int32x4_t v57 = v56;
            long long v58 = *v50++;
            v59.i64[1] = __PAIR64__(DWORD2(v58), v70.u32[2]);
            v59.i64[0] = __PAIR64__(v57.u32[2], v55.u32[2]);
            int32x4_t v60 = vuzp2q_s32(v55, v70);
            int32x4_t v61 = vtrn2q_s32(v60, v55);
            v61.i32[1] = v57.i32[3];
            v61.i32[3] = HIDWORD(v58);
            int32x4_t v62 = vtrn1q_s32(vuzp1q_s32(v55, v70), v57);
            v62.i32[3] = v58;
            v60.i32[1] = v57.i32[1];
            v60.i32[3] = DWORD1(v58);
            unint64_t v48 = v53 + 4;
            int32x4_t *v53 = v62;
            v53[1] = v60;
            v53[2] = v59;
            v53[3] = v61;
            unint64_t v44 = v49 + 4;
            unint64_t v63 = v49 + 8;
            v49 += 4;
            v53 += 4;
          }
          while (v63 <= v45);
        }
        unint64_t v64 = v45 - v44;
        if (v45 > v44)
        {
          float v65 = (int *)(v37 + 4 * v44);
          __int16 v66 = (__int32 *)(v39 + 4 * v44);
          uint64_t v67 = (__int32 *)(v41 + 4 * v44);
          do
          {
            int v68 = *v65++;
            v69.i32[0] = v68;
            v69.i32[1] = *v66++;
            v69.i32[2] = v13;
            v69.i32[3] = *v67++;
            *v48++ = v69;
            --v64;
          }
          while (v64);
          unint64_t v44 = v45;
        }
        if (a10 > v44) {
          bzero(v48, 16 * (a10 - v44));
        }
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v32 += a11;
    }
    while (v32 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, unint64_t a12, unsigned int a13, int16x4_t *a14, uint64_t a15)
{
  uint64_t v19 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v19;
  }
  else {
    _D0 = NAN;
  }
  int v21 = *(_DWORD *)(v19 + 16);
  if (v21 == 2)
  {
    *(float *)&a10 = _D0;
  }
  else if (v21 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v81) = _H0;
    LOWORD(v81) = _H0;
    LODWORD(a10) = v81;
  }
  else
  {
    LODWORD(a10) = _D0;
  }
  uint64_t v26 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v26;
  }
  else {
    _D0 = NAN;
  }
  int v28 = *(_DWORD *)(v26 + 16);
  double v68 = a10;
  if (v28 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v28 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v82) = _H0;
    LOWORD(v82) = _H0;
    LODWORD(_D0) = v82;
  }
  else
  {
    LODWORD(_D0) = _D0;
  }
  int16x4_t v67 = *(int16x4_t *)&_D0;
  uint64_t v30 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v76 = v30;
  unsigned int v77 = *(ChannelDescription **)(a7 + 8);
  unsigned int v75 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v77, (*(_DWORD *)(a4 + 52) + HIDWORD(v30) * *(_DWORD *)(a3 + 60)), v30, v75);
  uint64_t v31 = *(void *)(a4 + 24);
  uint64_t v69 = *(unsigned int *)(a4 + 44);
  uint64_t v73 = v31;
  uint64_t v74 = *(ChannelDescription **)(a8 + 8);
  unsigned int v72 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v74, (*(_DWORD *)(a4 + 52) + HIDWORD(v31) * *(_DWORD *)(a3 + 60)), v31, v72);
  unint64_t v33 = *(void *)(a3 + 56);
  uint64_t v34 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v34 < HIDWORD(v33))
  {
    int v36 = *(_DWORD *)(a4 + 28) * HIDWORD(v33);
    int16x8_t v37 = vdupq_n_s16(LODWORD(v68));
    unint64_t v38 = a1 + a2;
    int16x8_t v71 = vdupq_n_s16(v67.u32[0]);
    do
    {
      int16x8_t v79 = v37;
      long long v80 = v32;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v77, (v36 + v34), v76, v75);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v40 = LocationForTile;
        unint64_t v41 = ChannelDescription::GetLocationForTile(v74, (v36 + v34), v73, v72);
        int16x8_t v37 = v79;
        long long v32 = v80;
        if (!HIDWORD(v41)) {
          goto LABEL_43;
        }
        uint64_t v43 = a1 + v40;
        uint64_t v44 = a1 + v41;
        if (!v43 || v44 == 0) {
          goto LABEL_43;
        }
        unint64_t v46 = 0;
        unint64_t v47 = (uint64_t *)(v43 + 2 * v70);
        unint64_t v48 = (uint64_t *)(v44 + 2 * v69);
        unint64_t v49 = (v38 - (unint64_t)v47) >> 1;
        if (v38 <= (unint64_t)v47) {
          unint64_t v49 = 0;
        }
        if (a12 < v49) {
          unint64_t v49 = a12;
        }
        unint64_t v50 = (v38 - (unint64_t)v48) >> 1;
        if (v38 <= (unint64_t)v48) {
          unint64_t v50 = 0;
        }
        if (v49 >= v50) {
          unint64_t v49 = v50;
        }
        uint64_t v51 = a14;
        if (v49 >= 4)
        {
          uint64_t v52 = 0;
          int32x4_t v53 = a14;
          do
          {
            uint64_t v54 = *v47++;
            *(void *)&long long v32 = v54;
            int16x8_t v55 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v32 - 1), (int8x16_t)xmmword_228F41C10);
            uint64_t v56 = *v48++;
            uint64_t v57 = v56;
            int16x8_t v58 = vzip1q_s16(v55, v71);
            int8x16_t v59 = vqtbl2q_s8(*(int8x16x2_t *)(&v42 - 3), (int8x16_t)xmmword_228F41C70);
            int16x8_t v60 = vzip2q_s16(v55, v71);
            uint64_t v51 = v53 + 4;
            *(int8x16_t *)v53->i8 = v59;
            *(int8x16_t *)v53[2].i8 = vqtbl2q_s8(*(int8x16x2_t *)(&v42 - 3), (int8x16_t)xmmword_228F41C50);
            unint64_t v46 = v52 + 4;
            unint64_t v61 = v52 + 8;
            v52 += 4;
            v53 += 4;
          }
          while (v61 <= v49);
        }
        unint64_t v62 = v49 - v46;
        if (v49 > v46)
        {
          unint64_t v63 = (__int16 *)(v43 + 2 * v70 + 2 * v46);
          unint64_t v64 = (__int16 *)(v44 + 2 * v69 + 2 * v46);
          do
          {
            int16x4_t v65 = *(int16x4_t *)&v68;
            v65.i16[2] = *v63++;
            int16x4_t v66 = v67;
            v66.i16[1] = *v64++;
            *v51++ = vzip1_s16(vuzp1_s16(v65, v65), v66);
            --v62;
          }
          while (v62);
          unint64_t v46 = v49;
        }
        if (a12 <= v46) {
          goto LABEL_43;
        }
        long long v80 = v32;
        bzero(v51, 8 * (a12 - v46));
      }
      else
      {
        ChannelDescription::GetLocationForTile(v74, (v36 + v34), v73, v72);
      }
      int16x8_t v37 = v79;
      long long v32 = v80;
LABEL_43:
      a14 = (int16x4_t *)((char *)a14 + a15);
      v34 += a13;
    }
    while (v34 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8, __n128 _Q0, __n128 a10, uint64_t a11, unint64_t a12, unsigned int a13, int32x4_t *a14, uint64_t a15)
{
  uint64_t v19 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v19;
  }
  else {
    _D0 = NAN;
  }
  int v21 = *(_DWORD *)(v19 + 16);
  if (v21 == 2)
  {
    a10.n128_f32[0] = _D0;
  }
  else if (v21 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v78) = _H0;
    LOWORD(v78) = _H0;
    a10.n128_u32[0] = v78;
  }
  else
  {
    a10.n128_u32[0] = _D0;
  }
  uint64_t v26 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _Q0.n128_u64[0] = *(void *)v26;
  }
  else {
    _Q0.n128_u64[0] = 0x7FF8000000000000;
  }
  int v27 = *(_DWORD *)(v26 + 16);
  __n128 v66 = a10;
  if (v27 == 2)
  {
    _Q0.n128_f32[0] = _Q0.n128_f64[0];
  }
  else if (v27 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v79) = _H0;
    LOWORD(v79) = _H0;
    _Q0.n128_u32[0] = v79;
  }
  else
  {
    _Q0.n128_u32[0] = _Q0.n128_f64[0];
  }
  __n128 v65 = _Q0;
  uint64_t v29 = *(void *)(a4 + 24);
  uint64_t v68 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = v29;
  uint64_t v76 = *(ChannelDescription **)(a7 + 8);
  unsigned int v74 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a4 + 52) + HIDWORD(v29) * *(_DWORD *)(a3 + 60)), v29, v74);
  uint64_t v30 = *(void *)(a4 + 24);
  uint64_t v67 = *(unsigned int *)(a4 + 44);
  uint64_t v72 = v30;
  uint64_t v73 = *(ChannelDescription **)(a8 + 8);
  unsigned int v71 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v73, (*(_DWORD *)(a4 + 52) + HIDWORD(v30) * *(_DWORD *)(a3 + 60)), v30, v71);
  unint64_t v31 = *(void *)(a3 + 56);
  uint64_t v32 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v32 < HIDWORD(v31))
  {
    int v34 = *(_DWORD *)(a4 + 28) * HIDWORD(v31);
    unint64_t v35 = a1 + a2;
    int32x4_t v36 = vdupq_n_s32(v66.n128_u32[0]);
    int32x4_t v69 = vuzp1q_s32(v36, v36);
    int32x4_t v70 = vdupq_n_s32(v65.n128_u32[0]);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v76, (v34 + v32), v75, v74);
      if (HIDWORD(LocationForTile))
      {
        unsigned int v38 = LocationForTile;
        unint64_t v39 = ChannelDescription::GetLocationForTile(v73, (v34 + v32), v72, v71);
        if (HIDWORD(v39))
        {
          uint64_t v40 = a1 + v38;
          uint64_t v41 = a1 + v39;
          if (v40 && v41 != 0)
          {
            unint64_t v43 = 0;
            uint64_t v44 = (int32x4_t *)(v40 + 4 * v68);
            unint64_t v45 = (long long *)(v41 + 4 * v67);
            unint64_t v46 = (v35 - (unint64_t)v44) >> 2;
            if (v35 <= (unint64_t)v44) {
              unint64_t v46 = 0;
            }
            if (a12 < v46) {
              unint64_t v46 = a12;
            }
            unint64_t v47 = (v35 - (unint64_t)v45) >> 2;
            if (v35 <= (unint64_t)v45) {
              unint64_t v47 = 0;
            }
            if (v46 >= v47) {
              unint64_t v46 = v47;
            }
            unint64_t v48 = a14;
            if (v46 >= 4)
            {
              uint64_t v49 = 0;
              unint64_t v50 = a14;
              do
              {
                int32x4_t v51 = *v44++;
                int32x4_t v52 = vzip1q_s32(v69, v51);
                int32x4_t v53 = vzip2q_s32(v69, v51);
                long long v54 = *v45++;
                int32x4_t v55 = vzip1q_s32(v53, v70);
                v55.i32[3] = DWORD2(v54);
                int32x4_t v56 = vzip2q_s32(v53, v70);
                v56.i32[3] = HIDWORD(v54);
                int32x4_t v57 = vzip1q_s32(v52, v70);
                v57.i32[3] = v54;
                int32x4_t v58 = vzip2q_s32(v52, v70);
                v58.i32[3] = DWORD1(v54);
                unint64_t v48 = v50 + 4;
                *unint64_t v50 = v57;
                v50[1] = v58;
                v50[2] = v55;
                v50[3] = v56;
                unint64_t v43 = v49 + 4;
                unint64_t v59 = v49 + 8;
                v49 += 4;
                v50 += 4;
              }
              while (v59 <= v46);
            }
            unint64_t v60 = v46 - v43;
            if (v46 > v43)
            {
              unint64_t v61 = (__int32 *)(v40 + 4 * v68 + 4 * v43);
              unint64_t v62 = (__int32 *)(v41 + 4 * v67 + 4 * v43);
              do
              {
                int32x4_t v63 = (int32x4_t)v66;
                v63.i32[2] = *v61++;
                int32x4_t v64 = (int32x4_t)v65;
                v64.i32[1] = *v62++;
                *v48++ = vzip1q_s32(vuzp1q_s32(v63, v63), v64);
                --v60;
              }
              while (v60);
              unint64_t v43 = v46;
            }
            if (a12 > v43) {
              bzero(v48, 16 * (a12 - v43));
            }
          }
        }
      }
      else
      {
        ChannelDescription::GetLocationForTile(v73, (v34 + v32), v72, v71);
      }
      a14 = (int32x4_t *)((char *)a14 + a15);
      v32 += a13;
    }
    while (v32 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int16x8_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v80 = *(unsigned int *)(a4 + 44);
  uint64_t v82 = v19;
  unsigned int v83 = *(ChannelDescription **)(a5 + 8);
  unsigned int v81 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v83, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v81);
  uint64_t v21 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _D0 = *(double *)v21;
  }
  else {
    _D0 = NAN;
  }
  int v23 = *(_DWORD *)(v21 + 16);
  if (v23 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v23 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v85) = _H0;
    LOWORD(v85) = _H0;
    LODWORD(_D0) = v85;
  }
  else
  {
    int16x4_t v70 = v20;
    if (v23) {
      goto LABEL_11;
    }
    LODWORD(_D0) = _D0;
  }
  int16x4_t v70 = *(int16x4_t *)&_D0;
LABEL_11:
  uint64_t v28 = *(void *)(a4 + 24);
  uint64_t v76 = *(unsigned int *)(a4 + 44);
  uint64_t v78 = v28;
  unsigned __int32 v79 = *(ChannelDescription **)(a7 + 8);
  unsigned int v77 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a4 + 52) + HIDWORD(v28) * *(_DWORD *)(a3 + 60)), v28, v77);
  uint64_t v29 = *(void *)(a4 + 24);
  uint64_t v72 = *(unsigned int *)(a4 + 44);
  uint64_t v74 = v29;
  uint64_t v75 = *(ChannelDescription **)(a8 + 8);
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v29) * *(_DWORD *)(a3 + 60)), v29, v73);
  unint64_t v30 = *(void *)(a3 + 56);
  uint64_t v31 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v31 < HIDWORD(v30))
  {
    int v33 = *(_DWORD *)(a4 + 28) * HIDWORD(v30);
    unint64_t v34 = a1 + a2;
    int16x8_t v71 = vdupq_n_s16(v70.u32[0]);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v83, (v33 + v31), v82, v81);
      if (HIDWORD(LocationForTile)) {
        unint64_t v36 = a1 + LocationForTile + 2 * v80;
      }
      else {
        unint64_t v36 = 0;
      }
      unint64_t v37 = ChannelDescription::GetLocationForTile(v79, (v33 + v31), v78, v77);
      if (HIDWORD(v37)) {
        unint64_t v38 = a1 + v37 + 2 * v76;
      }
      else {
        unint64_t v38 = 0;
      }
      unint64_t v39 = ChannelDescription::GetLocationForTile(v75, (v33 + v31), v74, v73);
      if (HIDWORD(v39)) {
        unint64_t v43 = a1 + v39 + 2 * v72;
      }
      else {
        unint64_t v43 = 0;
      }
      if (v36) {
        _ZF = v38 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v43 != 0)
      {
        unint64_t v46 = 0;
        unint64_t v47 = (v34 - v36) >> 1;
        if (v34 <= v36) {
          unint64_t v47 = 0;
        }
        if (v47 >= a10) {
          unint64_t v47 = a10;
        }
        unint64_t v48 = (v34 - v38) >> 1;
        if (v34 <= v38) {
          unint64_t v48 = 0;
        }
        if (v47 >= v48) {
          unint64_t v47 = v48;
        }
        unint64_t v49 = (v34 - v43) >> 1;
        if (v34 <= v43) {
          unint64_t v49 = 0;
        }
        if (v47 >= v49) {
          unint64_t v47 = v49;
        }
        unint64_t v50 = a12;
        if (v47 >= 4)
        {
          uint64_t v51 = 0;
          int32x4_t v52 = (uint64_t *)v43;
          int32x4_t v53 = (uint64_t *)v38;
          long long v54 = (uint64_t *)v36;
          int32x4_t v55 = a12;
          do
          {
            uint64_t v56 = *v54++;
            v40.i64[0] = v56;
            uint64_t v57 = *v53++;
            v41.i64[0] = v57;
            uint64_t v58 = *v52++;
            uint64_t v59 = v58;
            int16x8_t v60 = vzip1q_s16(v40, v41);
            int16x8_t v61 = vzip1q_s16(v60, v71);
            int16x8_t v41 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v42 - 3), (int8x16_t)xmmword_228F41C70);
            int16x8_t v62 = vzip2q_s16(v60, v71);
            int16x8_t v40 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v42 - 3), (int8x16_t)xmmword_228F41C50);
            unint64_t v50 = v55 + 2;
            int16x8_t *v55 = v41;
            v55[1] = v40;
            unint64_t v46 = v51 + 4;
            unint64_t v63 = v51 + 8;
            v51 += 4;
            v55 += 2;
          }
          while (v63 <= v47);
        }
        unint64_t v64 = v47 - v46;
        if (v47 > v46)
        {
          __n128 v65 = (unsigned __int16 *)(v36 + 2 * v46);
          __n128 v66 = (__int16 *)(v38 + 2 * v46);
          uint64_t v67 = (__int16 *)(v43 + 2 * v46);
          do
          {
            __int32 v68 = *v65++;
            v40.i32[0] = v68;
            v40.i16[2] = *v66++;
            int16x4_t v69 = v70;
            v69.i16[1] = *v67++;
            *(int16x4_t *)v40.i8 = vzip1_s16(vuzp1_s16(*(int16x4_t *)v40.i8, *(int16x4_t *)v40.i8), v69);
            v50->i64[0] = v40.i64[0];
            unint64_t v50 = (int16x8_t *)((char *)v50 + 8);
            --v64;
          }
          while (v64);
          unint64_t v46 = v47;
        }
        if (a10 > v46) {
          bzero(v50, 8 * (a10 - v46));
        }
      }
      a12 = (int16x8_t *)((char *)a12 + a13);
      v31 += a11;
    }
    while (v31 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)0,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v19 = *(void *)(a4 + 24);
  uint64_t v80 = *(unsigned int *)(a4 + 44);
  uint64_t v82 = v19;
  unsigned int v83 = *(ChannelDescription **)(a5 + 8);
  unsigned int v81 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v83, (*(_DWORD *)(a4 + 52) + HIDWORD(v19) * *(_DWORD *)(a3 + 60)), v19, v81);
  uint64_t v22 = *a6;
  if (*(unsigned char *)(*a6 + 24)) {
    _Q0.i64[0] = *(void *)v22;
  }
  else {
    _Q0.i64[0] = 0x7FF8000000000000;
  }
  int v23 = *(_DWORD *)(v22 + 16);
  if (v23 == 2)
  {
    *(float *)_Q0.i32 = *(double *)_Q0.i64;
  }
  else if (v23 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v85) = _H0;
    LOWORD(v85) = _H0;
    _Q0.i32[0] = v85;
  }
  else
  {
    int32x4_t v70 = v21;
    if (v23) {
      goto LABEL_11;
    }
    _Q0.i32[0] = *(double *)_Q0.i64;
  }
  int32x4_t v70 = _Q0;
LABEL_11:
  uint64_t v28 = *(void *)(a4 + 24);
  uint64_t v76 = *(unsigned int *)(a4 + 44);
  uint64_t v78 = v28;
  unsigned __int32 v79 = *(ChannelDescription **)(a7 + 8);
  unsigned int v77 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a4 + 52) + HIDWORD(v28) * *(_DWORD *)(a3 + 60)), v28, v77);
  uint64_t v29 = *(void *)(a4 + 24);
  uint64_t v72 = *(unsigned int *)(a4 + 44);
  uint64_t v74 = v29;
  uint64_t v75 = *(ChannelDescription **)(a8 + 8);
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v29) * *(_DWORD *)(a3 + 60)), v29, v73);
  unint64_t v30 = *(void *)(a3 + 56);
  uint64_t v31 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v31 < HIDWORD(v30))
  {
    int v33 = *(_DWORD *)(a4 + 28) * HIDWORD(v30);
    unint64_t v34 = a1 + a2;
    int32x4_t v71 = vdupq_n_s32(v70.u32[0]);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v83, (v33 + v31), v82, v81);
      if (HIDWORD(LocationForTile)) {
        unint64_t v36 = a1 + LocationForTile + 4 * v80;
      }
      else {
        unint64_t v36 = 0;
      }
      unint64_t v37 = ChannelDescription::GetLocationForTile(v79, (v33 + v31), v78, v77);
      if (HIDWORD(v37)) {
        unint64_t v38 = a1 + v37 + 4 * v76;
      }
      else {
        unint64_t v38 = 0;
      }
      unint64_t v39 = ChannelDescription::GetLocationForTile(v75, (v33 + v31), v74, v73);
      if (HIDWORD(v39)) {
        unint64_t v41 = a1 + v39 + 4 * v72;
      }
      else {
        unint64_t v41 = 0;
      }
      if (v36) {
        _ZF = v38 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v41 != 0)
      {
        unint64_t v44 = 0;
        unint64_t v45 = (v34 - v36) >> 2;
        if (v34 <= v36) {
          unint64_t v45 = 0;
        }
        if (v45 >= a10) {
          unint64_t v45 = a10;
        }
        unint64_t v46 = (v34 - v38) >> 2;
        if (v34 <= v38) {
          unint64_t v46 = 0;
        }
        if (v45 >= v46) {
          unint64_t v45 = v46;
        }
        unint64_t v47 = (v34 - v41) >> 2;
        if (v34 <= v41) {
          unint64_t v47 = 0;
        }
        if (v45 >= v47) {
          unint64_t v45 = v47;
        }
        unint64_t v48 = a12;
        if (v45 >= 4)
        {
          uint64_t v49 = 0;
          unint64_t v50 = (long long *)v41;
          uint64_t v51 = (int32x4_t *)v38;
          int32x4_t v52 = (int32x4_t *)v36;
          int32x4_t v53 = a12;
          do
          {
            int32x4_t v54 = *v52++;
            int32x4_t v55 = v54;
            int32x4_t v56 = *v51++;
            int32x4_t v57 = v56;
            long long v58 = *v50++;
            int32x4_t v59 = vuzp2q_s32(v55, v57);
            int32x4_t v60 = v57;
            v60.i32[0] = v55.i32[2];
            int32x4_t v61 = vtrn2q_s32(v59, v55);
            v61.i32[1] = v71.i32[2];
            v61.i32[3] = HIDWORD(v58);
            int32x4_t v40 = vtrn1q_s32(vuzp1q_s32(v55, v57), v71);
            v40.i32[3] = v58;
            v59.i32[1] = v71.i32[2];
            v59.i32[3] = DWORD1(v58);
            int32x4_t v62 = vtrn1q_s32(v60, v71);
            v62.i32[3] = DWORD2(v58);
            unint64_t v48 = v53 + 4;
            int32x4_t *v53 = v40;
            v53[1] = v59;
            v53[2] = v62;
            v53[3] = v61;
            unint64_t v44 = v49 + 4;
            unint64_t v63 = v49 + 8;
            v49 += 4;
            v53 += 4;
          }
          while (v63 <= v45);
        }
        unint64_t v64 = v45 - v44;
        if (v45 > v44)
        {
          __n128 v65 = (__int32 *)(v36 + 4 * v44);
          __n128 v66 = (__int32 *)(v38 + 4 * v44);
          uint64_t v67 = (__int32 *)(v41 + 4 * v44);
          do
          {
            __int32 v68 = *v65++;
            v40.i32[0] = v68;
            v40.i32[2] = *v66++;
            int32x4_t v69 = v70;
            v69.i32[1] = *v67++;
            int32x4_t v40 = vzip1q_s32(vuzp1q_s32(v40, v40), v69);
            *v48++ = v40;
            --v64;
          }
          while (v64);
          unint64_t v44 = v45;
        }
        if (a10 > v44) {
          bzero(v48, 16 * (a10 - v44));
        }
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v31 += a11;
    }
    while (v31 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, int16x4_t a10, uint64_t a11, unint64_t a12, unsigned int a13, int16x4_t *a14, uint64_t a15)
{
  uint64_t v20 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _D0 = *(double *)v20;
  }
  else {
    _D0 = NAN;
  }
  int v22 = *(_DWORD *)(v20 + 16);
  if (v22 == 2)
  {
    *(float *)&_D0 = _D0;
  }
  else if (v22 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v86) = _H0;
    LOWORD(v86) = _H0;
    LODWORD(_D0) = v86;
  }
  else
  {
    if (v22) {
      goto LABEL_11;
    }
    LODWORD(_D0) = _D0;
  }
  *(double *)&a10 = _D0;
LABEL_11:
  uint64_t v27 = *(void *)(a4 + 24);
  uint64_t v78 = *(unsigned int *)(a4 + 44);
  uint64_t v80 = v27;
  unsigned int v81 = *(ChannelDescription **)(a6 + 8);
  unsigned int v79 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v81, (*(_DWORD *)(a4 + 52) + HIDWORD(v27) * *(_DWORD *)(a3 + 60)), v27, v79);
  uint64_t v28 = *(void *)(a4 + 24);
  uint64_t v74 = *(unsigned int *)(a4 + 44);
  uint64_t v76 = v28;
  unsigned int v77 = *(ChannelDescription **)(a7 + 8);
  unsigned int v75 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v77, (*(_DWORD *)(a4 + 52) + HIDWORD(v28) * *(_DWORD *)(a3 + 60)), v28, v75);
  uint64_t v29 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v72 = v29;
  unsigned int v73 = *(ChannelDescription **)(a8 + 8);
  unsigned int v71 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v73, (*(_DWORD *)(a4 + 52) + HIDWORD(v29) * *(_DWORD *)(a3 + 60)), v29, v71);
  unint64_t v31 = *(void *)(a3 + 56);
  uint64_t v32 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v32 < HIDWORD(v31))
  {
    int v34 = *(_DWORD *)(a4 + 28) * HIDWORD(v31);
    unint64_t v35 = a1 + a2;
    int16x8_t v36 = vdupq_n_s16(a10.u32[0]);
    do
    {
      int16x8_t v83 = v36;
      long long v84 = v30;
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v81, (v34 + v32), v80, v79);
      if (HIDWORD(LocationForTile)) {
        unint64_t v38 = a1 + LocationForTile + 2 * v78;
      }
      else {
        unint64_t v38 = 0;
      }
      unint64_t v39 = ChannelDescription::GetLocationForTile(v77, (v34 + v32), v76, v75);
      if (HIDWORD(v39)) {
        unint64_t v40 = a1 + v39 + 2 * v74;
      }
      else {
        unint64_t v40 = 0;
      }
      unint64_t v41 = ChannelDescription::GetLocationForTile(v73, (v34 + v32), v72, v71);
      int16x8_t v36 = v83;
      long long v30 = v84;
      if (HIDWORD(v41)) {
        unint64_t v44 = a1 + v41 + 2 * v70;
      }
      else {
        unint64_t v44 = 0;
      }
      if (v38) {
        _ZF = v40 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v44 != 0)
      {
        unint64_t v47 = 0;
        unint64_t v48 = (v35 - v38) >> 1;
        if (v35 <= v38) {
          unint64_t v48 = 0;
        }
        if (a12 < v48) {
          unint64_t v48 = a12;
        }
        unint64_t v49 = (v35 - v40) >> 1;
        if (v35 <= v40) {
          unint64_t v49 = 0;
        }
        if (v48 >= v49) {
          unint64_t v48 = v49;
        }
        unint64_t v50 = (v35 - v44) >> 1;
        if (v35 <= v44) {
          unint64_t v50 = 0;
        }
        if (v48 >= v50) {
          unint64_t v48 = v50;
        }
        uint64_t v51 = a14;
        if (v48 >= 4)
        {
          uint64_t v52 = 0;
          int32x4_t v53 = (uint64_t *)v44;
          int32x4_t v54 = (uint64_t *)v40;
          int32x4_t v55 = (uint64_t *)v38;
          int32x4_t v56 = (int16x8_t *)a14;
          do
          {
            uint64_t v57 = *v55++;
            v42.i64[0] = v57;
            uint64_t v58 = *v54++;
            *(void *)&long long v30 = v58;
            uint64_t v59 = *v53++;
            v43.i64[0] = v59;
            int16x8_t v60 = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)(&v30 - 1), (int8x16_t)xmmword_228F41C10);
            int16x8_t v61 = vzip1q_s16(v42, v43);
            int16x8_t v43 = vzip1q_s16(v60, v61);
            int16x8_t v42 = vzip2q_s16(v60, v61);
            uint64_t v51 = (int16x4_t *)&v56[2];
            int16x8_t *v56 = v43;
            v56[1] = v42;
            unint64_t v47 = v52 + 4;
            unint64_t v62 = v52 + 8;
            v52 += 4;
            v56 += 2;
          }
          while (v62 <= v48);
        }
        unint64_t v63 = v48 - v47;
        if (v48 > v47)
        {
          unint64_t v64 = (__int16 *)(v38 + 2 * v47);
          __n128 v65 = (__int16 *)(v40 + 2 * v47);
          __n128 v66 = (__int16 *)(v44 + 2 * v47);
          do
          {
            __int16 v67 = *v64++;
            int16x4_t v68 = a10;
            v68.i16[2] = *v65++;
            v43.i16[0] = v67;
            v43.i16[1] = *v66++;
            *v51++ = vzip1_s16(vuzp1_s16(v68, v68), *(int16x4_t *)v43.i8);
            --v63;
          }
          while (v63);
          unint64_t v47 = v48;
        }
        if (a12 > v47)
        {
          long long v85 = v30;
          bzero(v51, 8 * (a12 - v47));
          int16x8_t v36 = v83;
          long long v30 = v85;
        }
      }
      a14 = (int16x4_t *)((char *)a14 + a15);
      v32 += a13;
    }
    while (v32 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)0,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t _Q0, int32x4_t a10, uint64_t a11, unint64_t a12, unsigned int a13, int32x4_t *a14, uint64_t a15)
{
  uint64_t v20 = *a5;
  if (*(unsigned char *)(*a5 + 24)) {
    _Q0.i64[0] = *(void *)v20;
  }
  else {
    _Q0.i64[0] = 0x7FF8000000000000;
  }
  int v21 = *(_DWORD *)(v20 + 16);
  if (v21 == 2)
  {
    *(float *)_Q0.i32 = *(double *)_Q0.i64;
  }
  else if (v21 == 1)
  {
    __asm { FCVT            H0, D0 }
    HIWORD(v85) = _H0;
    LOWORD(v85) = _H0;
    _Q0.i32[0] = v85;
  }
  else
  {
    if (v21) {
      goto LABEL_11;
    }
    _Q0.i32[0] = *(double *)_Q0.i64;
  }
  a10 = _Q0;
LABEL_11:
  uint64_t v26 = *(void *)(a4 + 24);
  uint64_t v80 = *(unsigned int *)(a4 + 44);
  uint64_t v82 = v26;
  int16x8_t v83 = *(ChannelDescription **)(a6 + 8);
  unsigned int v81 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v83, (*(_DWORD *)(a4 + 52) + HIDWORD(v26) * *(_DWORD *)(a3 + 60)), v26, v81);
  uint64_t v27 = *(void *)(a4 + 24);
  uint64_t v76 = *(unsigned int *)(a4 + 44);
  uint64_t v78 = v27;
  unsigned int v79 = *(ChannelDescription **)(a7 + 8);
  unsigned int v77 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v79, (*(_DWORD *)(a4 + 52) + HIDWORD(v27) * *(_DWORD *)(a3 + 60)), v27, v77);
  uint64_t v28 = *(void *)(a4 + 24);
  uint64_t v72 = *(unsigned int *)(a4 + 44);
  uint64_t v74 = v28;
  unsigned int v75 = *(ChannelDescription **)(a8 + 8);
  unsigned int v73 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v75, (*(_DWORD *)(a4 + 52) + HIDWORD(v28) * *(_DWORD *)(a3 + 60)), v28, v73);
  unint64_t v29 = *(void *)(a3 + 56);
  uint64_t v30 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v30 < HIDWORD(v29))
  {
    int v32 = *(_DWORD *)(a4 + 28) * HIDWORD(v29);
    unint64_t v33 = a1 + a2;
    int32x4_t v34 = vdupq_n_s32(a10.u32[0]);
    int32x4_t v71 = vuzp1q_s32(v34, v34);
    do
    {
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v83, (v32 + v30), v82, v81);
      if (HIDWORD(LocationForTile)) {
        unint64_t v36 = a1 + LocationForTile + 4 * v80;
      }
      else {
        unint64_t v36 = 0;
      }
      unint64_t v37 = ChannelDescription::GetLocationForTile(v79, (v32 + v30), v78, v77);
      if (HIDWORD(v37)) {
        unint64_t v38 = a1 + v37 + 4 * v76;
      }
      else {
        unint64_t v38 = 0;
      }
      unint64_t v39 = ChannelDescription::GetLocationForTile(v75, (v32 + v30), v74, v73);
      if (HIDWORD(v39)) {
        unint64_t v41 = a1 + v39 + 4 * v72;
      }
      else {
        unint64_t v41 = 0;
      }
      if (v36) {
        _ZF = v38 == 0;
      }
      else {
        _ZF = 1;
      }
      if (!_ZF && v41 != 0)
      {
        unint64_t v44 = 0;
        unint64_t v45 = (v33 - v36) >> 2;
        if (v33 <= v36) {
          unint64_t v45 = 0;
        }
        if (a12 < v45) {
          unint64_t v45 = a12;
        }
        unint64_t v46 = (v33 - v38) >> 2;
        if (v33 <= v38) {
          unint64_t v46 = 0;
        }
        if (v45 >= v46) {
          unint64_t v45 = v46;
        }
        unint64_t v47 = (v33 - v41) >> 2;
        if (v33 <= v41) {
          unint64_t v47 = 0;
        }
        if (v45 >= v47) {
          unint64_t v45 = v47;
        }
        unint64_t v48 = a14;
        if (v45 >= 4)
        {
          uint64_t v49 = 0;
          unint64_t v50 = (long long *)v41;
          uint64_t v51 = (int32x4_t *)v38;
          uint64_t v52 = (int32x4_t *)v36;
          int32x4_t v53 = a14;
          do
          {
            int32x4_t v54 = *v52++;
            int32x4_t v55 = v54;
            int32x4_t v56 = *v51++;
            int32x4_t v57 = vzip1q_s32(v71, v56);
            int8x16_t v58 = (int8x16_t)vzip2q_s32(v71, v56);
            long long v59 = *v50++;
            int8x16_t v60 = vextq_s8((int8x16_t)vzip2q_s32(v55, (int32x4_t)v58), v58, 4uLL);
            v60.i32[3] = HIDWORD(v59);
            int32x4_t v61 = vzip2q_s32(v57, vuzp2q_s32(v57, v55));
            v61.i32[3] = DWORD1(v59);
            int32x4_t v40 = vzip2q_s32((int32x4_t)vextq_s8(v58, v58, 8uLL), v55);
            v40.i32[3] = DWORD2(v59);
            int32x4_t v62 = vzip1q_s32(v57, v55);
            v62.i32[3] = v59;
            unint64_t v48 = v53 + 4;
            int32x4_t *v53 = v62;
            v53[1] = v61;
            v53[2] = v40;
            v53[3] = (int32x4_t)v60;
            unint64_t v44 = v49 + 4;
            unint64_t v63 = v49 + 8;
            v49 += 4;
            v53 += 4;
          }
          while (v63 <= v45);
        }
        unint64_t v64 = v45 - v44;
        if (v45 > v44)
        {
          __n128 v65 = (__int32 *)(v36 + 4 * v44);
          __n128 v66 = (__int32 *)(v38 + 4 * v44);
          __int16 v67 = (__int32 *)(v41 + 4 * v44);
          do
          {
            __int32 v68 = *v65++;
            int32x4_t v69 = a10;
            v69.i32[2] = *v66++;
            v40.i32[0] = v68;
            v40.i32[1] = *v67++;
            *v48++ = vzip1q_s32(vuzp1q_s32(v69, v69), v40);
            --v64;
          }
          while (v64);
          unint64_t v44 = v45;
        }
        if (a12 > v44) {
          bzero(v48, 16 * (a12 - v44));
        }
      }
      a14 = (int32x4_t *)((char *)a14 + a15);
      v30 += a13;
    }
    while (v30 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(a3 + 60));
  }
}

void Read4_NoCompression<unsigned short,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int8x16_t *a12, uint64_t a13)
{
  uint64_t v20 = *(void *)(a4 + 24);
  uint64_t v78 = *(unsigned int *)(a4 + 44);
  uint64_t v80 = v20;
  unsigned int v81 = *(ChannelDescription **)(a5 + 8);
  unsigned int v79 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v81, (*(_DWORD *)(a4 + 52) + HIDWORD(v20) * *(_DWORD *)(a3 + 60)), v20, v79);
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v74 = *(unsigned int *)(a4 + 44);
  uint64_t v76 = v21;
  unsigned int v77 = *(ChannelDescription **)(a6 + 8);
  unsigned int v75 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v77, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v75);
  uint64_t v22 = *(void *)(a4 + 24);
  uint64_t v70 = *(unsigned int *)(a4 + 44);
  uint64_t v72 = v22;
  unsigned int v73 = *(ChannelDescription **)(a7 + 8);
  unsigned int v71 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v73, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v71);
  uint64_t v23 = *(void *)(a4 + 24);
  uint64_t v66 = *(unsigned int *)(a4 + 44);
  uint64_t v68 = v23;
  int32x4_t v69 = *(ChannelDescription **)(a8 + 8);
  unsigned int v67 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v69, (*(_DWORD *)(a4 + 52) + HIDWORD(v23) * *(_DWORD *)(a3 + 60)), v23, v67);
  uint64_t v82 = a3;
  unint64_t v24 = *(void *)(a3 + 56);
  uint64_t v25 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v25 < HIDWORD(v24))
  {
    int v65 = *(_DWORD *)(a4 + 28) * HIDWORD(v24);
    unint64_t v27 = a1 + a2;
    do
    {
      unint64_t v28 = (v65 + v25);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v81, v28, v80, v79);
      if (HIDWORD(LocationForTile)) {
        unint64_t v30 = a1 + LocationForTile + 2 * v78;
      }
      else {
        unint64_t v30 = 0;
      }
      unint64_t v31 = ChannelDescription::GetLocationForTile(v77, v28, v76, v75);
      if (HIDWORD(v31)) {
        unint64_t v32 = a1 + v31 + 2 * v74;
      }
      else {
        unint64_t v32 = 0;
      }
      unint64_t v33 = ChannelDescription::GetLocationForTile(v73, v28, v72, v71);
      if (HIDWORD(v33)) {
        unint64_t v34 = a1 + v33 + 2 * v70;
      }
      else {
        unint64_t v34 = 0;
      }
      unint64_t v35 = ChannelDescription::GetLocationForTile(v69, v28, v68, v67);
      if (HIDWORD(v35)) {
        unint64_t v36 = a1 + v35 + 2 * v66;
      }
      else {
        unint64_t v36 = 0;
      }
      if (v30 && v32 && v34 && v36)
      {
        unint64_t v37 = 0;
        unint64_t v38 = (v27 - v30) >> 1;
        if (v27 <= v30) {
          unint64_t v38 = 0;
        }
        if (v38 >= a10) {
          unint64_t v38 = a10;
        }
        unint64_t v39 = (v27 - v32) >> 1;
        if (v27 <= v32) {
          unint64_t v39 = 0;
        }
        if (v38 >= v39) {
          unint64_t v38 = v39;
        }
        unint64_t v40 = (v27 - v34) >> 1;
        if (v27 <= v34) {
          unint64_t v40 = 0;
        }
        if (v38 >= v40) {
          unint64_t v38 = v40;
        }
        unint64_t v41 = (v27 - v36) >> 1;
        if (v27 <= v36) {
          unint64_t v41 = 0;
        }
        if (v38 >= v41) {
          unint64_t v38 = v41;
        }
        int16x8_t v42 = a12;
        if (v38 >= 4)
        {
          uint64_t v43 = 0;
          unint64_t v44 = (int16x4_t *)v36;
          unint64_t v45 = (int16x4_t *)v34;
          unint64_t v46 = (int16x4_t *)v32;
          unint64_t v47 = (int16x4_t *)v30;
          unint64_t v48 = a12;
          do
          {
            int16x4_t v49 = *v47++;
            int16x4_t v50 = v49;
            int16x4_t v51 = *v46++;
            int16x4_t v52 = v51;
            int16x4_t v53 = *v45++;
            *(int16x4_t *)v54.i8 = vzip2_s16(v50, v53);
            *(int16x4_t *)v55.i8 = vzip1_s16(v50, v53);
            int16x4_t v56 = *v44++;
            v55.u64[1] = (unint64_t)vzip1_s16(v52, v56);
            v54.u64[1] = (unint64_t)vzip2_s16(v52, v56);
            int16x8_t v42 = v48 + 2;
            *unint64_t v48 = vqtbl1q_s8(v55, (int8x16_t)xmmword_228F62B40);
            v48[1] = vqtbl1q_s8(v54, (int8x16_t)xmmword_228F62B40);
            unint64_t v37 = v43 + 4;
            unint64_t v57 = v43 + 8;
            v43 += 4;
            v48 += 2;
          }
          while (v57 <= v38);
        }
        unint64_t v58 = v38 - v37;
        if (v38 > v37)
        {
          long long v59 = (__int16 *)(v30 + 2 * v37);
          int8x16_t v60 = (_WORD *)(v32 + 2 * v37);
          int32x4_t v61 = (_WORD *)(v34 + 2 * v37);
          int32x4_t v62 = (_WORD *)(v36 + 2 * v37);
          do
          {
            __int16 v63 = *v59++;
            LOWORD(v64) = v63;
            WORD1(v64) = *v60++;
            WORD2(v64) = *v61++;
            HIWORD(v64) = *v62++;
            v42->i64[0] = v64;
            int16x8_t v42 = (int8x16_t *)((char *)v42 + 8);
            --v58;
          }
          while (v58);
          unint64_t v37 = v38;
        }
        if (a10 > v37) {
          bzero(v42, 8 * (a10 - v37));
        }
      }
      a12 = (int8x16_t *)((char *)a12 + a13);
      v25 += a11;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(v82 + 60));
  }
}

void Read4_NoCompression<unsigned int,(StreamType)1,(StreamType)1,(StreamType)1,(StreamType)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int a11, int32x4_t *a12, uint64_t a13)
{
  uint64_t v20 = *(void *)(a4 + 24);
  uint64_t v81 = *(unsigned int *)(a4 + 44);
  uint64_t v83 = v20;
  long long v84 = *(ChannelDescription **)(a5 + 8);
  unsigned int v82 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v84, (*(_DWORD *)(a4 + 52) + HIDWORD(v20) * *(_DWORD *)(a3 + 60)), v20, v82);
  uint64_t v21 = *(void *)(a4 + 24);
  uint64_t v77 = *(unsigned int *)(a4 + 44);
  uint64_t v79 = v21;
  uint64_t v80 = *(ChannelDescription **)(a6 + 8);
  unsigned int v78 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v80, (*(_DWORD *)(a4 + 52) + HIDWORD(v21) * *(_DWORD *)(a3 + 60)), v21, v78);
  uint64_t v22 = *(void *)(a4 + 24);
  uint64_t v73 = *(unsigned int *)(a4 + 44);
  uint64_t v75 = v22;
  uint64_t v76 = *(ChannelDescription **)(a7 + 8);
  unsigned int v74 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v76, (*(_DWORD *)(a4 + 52) + HIDWORD(v22) * *(_DWORD *)(a3 + 60)), v22, v74);
  uint64_t v23 = *(void *)(a4 + 24);
  uint64_t v69 = *(unsigned int *)(a4 + 44);
  uint64_t v71 = v23;
  uint64_t v72 = *(ChannelDescription **)(a8 + 8);
  unsigned int v70 = *(_DWORD *)(a4 + 60);
  ChannelDescription::GetLocationForTile(v72, (*(_DWORD *)(a4 + 52) + HIDWORD(v23) * *(_DWORD *)(a3 + 60)), v23, v70);
  uint64_t v85 = a3;
  unint64_t v24 = *(void *)(a3 + 56);
  uint64_t v25 = *(unsigned int *)(a4 + 52);
  if ((unint64_t)*(unsigned int *)(a4 + 56) + v25 < HIDWORD(v24))
  {
    int v68 = *(_DWORD *)(a4 + 28) * HIDWORD(v24);
    unint64_t v27 = a1 + a2;
    do
    {
      unint64_t v28 = (v68 + v25);
      unint64_t LocationForTile = ChannelDescription::GetLocationForTile(v84, v28, v83, v82);
      if (HIDWORD(LocationForTile)) {
        unint64_t v30 = a1 + LocationForTile + 4 * v81;
      }
      else {
        unint64_t v30 = 0;
      }
      unint64_t v31 = ChannelDescription::GetLocationForTile(v80, v28, v79, v78);
      if (HIDWORD(v31)) {
        unint64_t v32 = a1 + v31 + 4 * v77;
      }
      else {
        unint64_t v32 = 0;
      }
      unint64_t v33 = ChannelDescription::GetLocationForTile(v76, v28, v75, v74);
      if (HIDWORD(v33)) {
        unint64_t v34 = a1 + v33 + 4 * v73;
      }
      else {
        unint64_t v34 = 0;
      }
      unint64_t v35 = ChannelDescription::GetLocationForTile(v72, v28, v71, v70);
      if (HIDWORD(v35)) {
        unint64_t v36 = a1 + v35 + 4 * v69;
      }
      else {
        unint64_t v36 = 0;
      }
      if (v30 && v32 && v34 && v36)
      {
        unint64_t v37 = 0;
        unint64_t v38 = (v27 - v30) >> 2;
        if (v27 <= v30) {
          unint64_t v38 = 0;
        }
        if (v38 >= a10) {
          unint64_t v38 = a10;
        }
        unint64_t v39 = (v27 - v32) >> 2;
        if (v27 <= v32) {
          unint64_t v39 = 0;
        }
        if (v38 >= v39) {
          unint64_t v38 = v39;
        }
        unint64_t v40 = (v27 - v34) >> 2;
        if (v27 <= v34) {
          unint64_t v40 = 0;
        }
        if (v38 >= v40) {
          unint64_t v38 = v40;
        }
        unint64_t v41 = (v27 - v36) >> 2;
        if (v27 <= v36) {
          unint64_t v41 = 0;
        }
        if (v38 >= v41) {
          unint64_t v38 = v41;
        }
        int16x8_t v42 = a12;
        if (v38 >= 4)
        {
          uint64_t v43 = 0;
          unint64_t v44 = (long long *)v36;
          unint64_t v45 = (int32x4_t *)v34;
          unint64_t v46 = (int32x4_t *)v32;
          unint64_t v47 = (int32x4_t *)v30;
          unint64_t v48 = a12;
          do
          {
            int32x4_t v49 = *v47++;
            int32x4_t v50 = v49;
            int32x4_t v51 = *v46++;
            int32x4_t v52 = v51;
            int32x4_t v53 = *v45++;
            int32x4_t v54 = v53;
            long long v55 = *v44++;
            int32x4_t v56 = vuzp2q_s32(v50, v54);
            v57.i64[1] = __PAIR64__(DWORD2(v55), v54.u32[2]);
            v57.i64[0] = __PAIR64__(v52.u32[2], v50.u32[2]);
            int32x4_t v58 = vtrn2q_s32(v56, v50);
            v58.i32[1] = v52.i32[3];
            v58.i32[3] = HIDWORD(v55);
            int32x4_t v59 = vtrn1q_s32(vuzp1q_s32(v50, v54), v52);
            v59.i32[3] = v55;
            v56.i32[1] = v52.i32[1];
            v56.i32[3] = DWORD1(v55);
            int16x8_t v42 = v48 + 4;
            *unint64_t v48 = v59;
            v48[1] = v56;
            v48[2] = v57;
            v48[3] = v58;
            unint64_t v37 = v43 + 4;
            unint64_t v60 = v43 + 8;
            v43 += 4;
            v48 += 4;
          }
          while (v60 <= v38);
        }
        unint64_t v61 = v38 - v37;
        if (v38 > v37)
        {
          int32x4_t v62 = (int *)(v30 + 4 * v37);
          __int16 v63 = (__int32 *)(v32 + 4 * v37);
          uint64_t v64 = (__int32 *)(v34 + 4 * v37);
          int v65 = (__int32 *)(v36 + 4 * v37);
          do
          {
            int v66 = *v62++;
            v67.i32[0] = v66;
            v67.i32[1] = *v63++;
            v67.i32[2] = *v64++;
            v67.i32[3] = *v65++;
            *v42++ = v67;
            --v61;
          }
          while (v61);
          unint64_t v37 = v38;
        }
        if (a10 > v37) {
          bzero(v42, 16 * (a10 - v37));
        }
      }
      a12 = (int32x4_t *)((char *)a12 + a13);
      v25 += a11;
    }
    while (v25 + (unint64_t)*(unsigned int *)(a4 + 56) < *(unsigned int *)(v85 + 60));
  }
}

float MakeYccMatrix(float *a1)
{
  double v1 = a1[3];
  float v2 = a1[6];
  double v3 = a1[7];
  double v4 = v1 / v3;
  double v5 = (1.0 - v1 - v3) / v3;
  double v6 = *a1;
  float v7 = a1[4];
  double v8 = a1[5];
  double v9 = v2 - v8;
  double v10 = a1[2];
  double v11 = v8 - v7;
  double v12 = a1[1];
  double v13 = v11 * v10 + v9 * v6 + (v7 - v2) * v12;
  double v14 = v4 + v5;
  double v15 = v2 + -1.0 + v14 * v2;
  double v16 = v8 + -1.0 + v14 * v8;
  double v17 = (v16 * v10 - (v15 * v12 - v4 * v9)) / v13;
  double v18 = v7 + -1.0 + v14 * v7;
  return v17
       * v7
       / ((v18 * v12 - (v16 * v6 - v4 * v11)) / v13 * v2
        + v17 * v7
        + (v4 * (float)(v7 - v2) + v15 * v6 - v18 * v10) / v13 * v8);
}

void TileDecoder_NoCompression::~TileDecoder_NoCompression(void **this)
{
  *this = &unk_26DD4BD78;
  free(this[8]);
}

{
  uint64_t vars8;

  *this = &unk_26DD4BD78;
  free(this[8]);

  JUMPOUT(0x22A6AD870);
}

uint64_t TileDecoder_NoCompression::GetCompressionMethod(TileDecoder_NoCompression *this)
{
  return 0;
}

void AXRBufferPool::FreeBuffers(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  float v2 = *(void **)&this[2]._os_unfair_lock_opaque;
  *(void *)&this[2]._os_unfair_lock_opaque = 0;
  os_unfair_lock_unlock(this);
  if (v2)
  {
    do
    {
      double v3 = (void *)*v2;
      free(v2);
      float v2 = v3;
    }
    while (v3);
  }
}

void TileDecoder_Zip::~TileDecoder_Zip(void **this)
{
  *this = &unk_26DD4BD78;
  free(this[8]);
}

{
  uint64_t vars8;

  *this = &unk_26DD4BD78;
  free(this[8]);

  JUMPOUT(0x22A6AD870);
}

uint64_t TileDecoder_Zip::GetMinimumTileBytes(TileDecoder_Zip *this)
{
  return 0x8000;
}

uint64_t TileDecoder_Zip::GetCompressionMethod(TileDecoder_Zip *this)
{
  return 3;
}

uint64_t DoAggregateBlock<ReadPixelsArgs>(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16);
  uint64_t v3 = v2 * a2;
  if (v2 >= *(void *)(result + 24) - v2 * a2) {
    uint64_t v4 = *(void *)(result + 24) - v2 * a2;
  }
  else {
    uint64_t v4 = *(void *)(result + 16);
  }
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t))v5)(*(void *)(v5 + 8), v3++);
      --v4;
    }
    while (v4);
  }
  return result;
}

int8x16_t _YCCAtoRGBA<half,1u,16>(const __int16 **a1, const __int16 **a2, int8x16_t **a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  *a1 += 32;
  int8x16x2_t v25 = (int8x16x2_t)vld2q_s16(v4);
  v4 += 16;
  int8x16x2_t v26 = (int8x16x2_t)vld2q_s16(v4);
  uint64_t v5 = *a2;
  *a2 += 32;
  int8x16x2_t v28 = (int8x16x2_t)vld2q_s16(v5);
  v5 += 16;
  int8x16x2_t v29 = (int8x16x2_t)vld2q_s16(v5);
  float32x4_t v6 = vcvtq_f32_f16(*(float16x4_t *)v25.val[0].i8);
  float32x4_t v7 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v25.val[0], v25.val[0], 8uLL));
  float32x4_t v8 = vcvtq_f32_f16(*(float16x4_t *)v26.val[0].i8);
  float32x4_t v9 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v26.val[0], v26.val[0], 8uLL));
  float32x4_t v10 = vcvtq_f32_f16(*(float16x4_t *)v28.val[0].i8);
  float32x4_t v11 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v28.val[0], v28.val[0], 8uLL));
  float32x4_t v12 = vcvtq_f32_f16(*(float16x4_t *)v29.val[0].i8);
  float32x4_t v13 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v29.val[0], v29.val[0], 8uLL));
  float32x4_t v14 = vcvtq_f32_f16(*(float16x4_t *)v28.val[1].i8);
  v28.val[0] = (int8x16_t)vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v28.val[1], v28.val[1], 8uLL));
  v28.val[1] = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v29.val[1].i8);
  v29.val[0] = (int8x16_t)vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v29.val[1], v29.val[1], 8uLL));
  v29.val[1] = (int8x16_t)vmlaq_f32(v6, v14, v6);
  float32x4_t v15 = vmlaq_f32(v7, (float32x4_t)v28.val[0], v7);
  v28.val[0] = (int8x16_t)vmlaq_f32(v8, (float32x4_t)v28.val[1], v8);
  v28.val[1] = (int8x16_t)vmlaq_f32(v9, (float32x4_t)v29.val[0], v9);
  v29.val[0] = (int8x16_t)vmlaq_f32(v9, v13, v9);
  float32x4_t v16 = vmlaq_f32(v8, v12, v8);
  float32x4_t v17 = vmlaq_f32(v7, v11, v7);
  float32x4_t v18 = vmlaq_f32(v6, v10, v6);
  v10.i64[0] = *(void *)a4;
  v10.i32[0] = *(_DWORD *)(a4 + 8);
  float32x4_t v19 = vmlsq_lane_f32(vmlsq_lane_f32(v6, (float32x4_t)v29.val[1], *(float32x2_t *)a4, 0), v18, *(float32x2_t *)v10.f32, 0);
  float32x4_t v20 = vmlsq_lane_f32(vmlsq_lane_f32(v7, v15, *(float32x2_t *)a4, 0), v17, *(float32x2_t *)v10.f32, 0);
  float32x4_t v21 = vmlsq_lane_f32(vmlsq_lane_f32(v8, (float32x4_t)v28.val[0], *(float32x2_t *)a4, 0), v16, *(float32x2_t *)v10.f32, 0);
  float32x4_t v22 = vmlsq_lane_f32(vmlsq_lane_f32(v9, (float32x4_t)v28.val[1], *(float32x2_t *)a4, 0), (float32x4_t)v29.val[0], *(float32x2_t *)v10.f32, 0);
  v10.i64[0] = *(void *)(a4 + 4);
  v33.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32((float32x4_t)v29.val[1]), v15);
  v34.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32((float32x4_t)v28.val[0]), (float32x4_t)v28.val[1]);
  v27.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v19, v10.f32[0])), vmulq_n_f32(v20, v10.f32[0]));
  v28.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v21, v10.f32[0])), vmulq_n_f32(v22, v10.f32[0]));
  v33.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v18), v17);
  v34.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v16), (float32x4_t)v29.val[0]);
  v27.val[0] = vqtbl2q_s8(v33, (int8x16_t)xmmword_228F41BE0);
  v29.val[0] = vqtbl2q_s8(v33, (int8x16_t)xmmword_228F41C00);
  v29.val[1] = v27.val[1];
  v31.val[0] = vqtbl2q_s8(v33, (int8x16_t)xmmword_228F41C20);
  v31.val[1] = v27.val[1];
  v32.val[0] = vqtbl2q_s8(v33, (int8x16_t)xmmword_228F41C30);
  v32.val[1] = v27.val[1];
  v28.val[0] = vqtbl2q_s8(v34, (int8x16_t)xmmword_228F41BE0);
  v30.val[0] = vqtbl2q_s8(v34, (int8x16_t)xmmword_228F41C00);
  v30.val[1] = v28.val[1];
  v33.val[0] = vqtbl2q_s8(v34, (int8x16_t)xmmword_228F41C20);
  v33.val[1] = v28.val[1];
  v34.val[0] = vqtbl2q_s8(v34, (int8x16_t)xmmword_228F41C30);
  v34.val[1] = v28.val[1];
  v26.val[0] = vqtbl2q_s8(v34, (int8x16_t)xmmword_228F61E40);
  v34.val[0] = vqtbl2q_s8(v26, (int8x16_t)xmmword_228F41C70);
  v26.val[0] = vqtbl2q_s8(v33, (int8x16_t)xmmword_228F61E30);
  v33.val[1] = vqtbl2q_s8(v26, (int8x16_t)xmmword_228F41C50);
  v26.val[0] = vqtbl2q_s8(v30, (int8x16_t)xmmword_228F61E60);
  v30.val[1] = vqtbl2q_s8(v26, (int8x16_t)xmmword_228F41CB0);
  v26.val[0] = vqtbl2q_s8(v28, (int8x16_t)xmmword_228F61E50);
  v26.val[0] = vqtbl2q_s8(v26, (int8x16_t)xmmword_228F41C90);
  v25.val[0] = vqtbl2q_s8(v32, (int8x16_t)xmmword_228F61E40);
  v26.val[1] = vqtbl2q_s8(v25, (int8x16_t)xmmword_228F41C70);
  v25.val[0] = vqtbl2q_s8(v31, (int8x16_t)xmmword_228F61E30);
  v28.val[1] = vqtbl2q_s8(v25, (int8x16_t)xmmword_228F41C50);
  v25.val[0] = vqtbl2q_s8(v29, (int8x16_t)xmmword_228F61E60);
  v29.val[0] = vqtbl2q_s8(v25, (int8x16_t)xmmword_228F41CB0);
  v25.val[0] = vqtbl2q_s8(v27, (int8x16_t)xmmword_228F61E50);
  int8x16_t result = vqtbl2q_s8(v25, (int8x16_t)xmmword_228F41C90);
  unint64_t v24 = *a3;
  v24[2] = v29.val[0];
  v24[3] = result;
  *unint64_t v24 = v26.val[1];
  v24[1] = v28.val[1];
  v24[6] = v30.val[1];
  v24[7] = v26.val[0];
  v24[4] = v34.val[0];
  v24[5] = v33.val[1];
  *a3 += 8;
  return result;
}

int8x16_t _YCCAtoRGBA<half,2u,16>(const __int16 **a1, int32x4_t **a2, int8x16_t **a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  *a1 += 32;
  int8x16x2_t v37 = (int8x16x2_t)vld2q_s16(v4);
  v4 += 16;
  int8x16x2_t v36 = (int8x16x2_t)vld2q_s16(v4);
  int32x4_t v5 = **a2;
  int32x4_t v6 = (*a2)[1];
  *a2 += 2;
  int8x16_t v7 = (int8x16_t)vzip2q_s32(v6, v6);
  int8x16_t v8 = (int8x16_t)vzip1q_s32(v6, v6);
  int16x8_t v9 = (int16x8_t)vzip2q_s32(v5, v5);
  int8x16_t v10 = (int8x16_t)vzip1q_s32(v5, v5);
  float32x4_t v11 = vcvtq_f32_f16(*(float16x4_t *)v37.val[0].i8);
  float32x4_t v12 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v37.val[0], v37.val[0], 8uLL));
  float32x4_t v13 = vcvtq_f32_f16(*(float16x4_t *)v36.val[0].i8);
  float32x4_t v14 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v36.val[0], v36.val[0], 8uLL));
  int16x4_t v15 = (int16x4_t)vextq_s8(v10, v10, 8uLL).u64[0];
  float32x4_t v16 = vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v10.i8, v15));
  float32x4_t v17 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vuzp1q_s16(v9, (int16x8_t)v36.val[0]));
  int16x4_t v18 = (int16x4_t)vextq_s8(v8, v8, 8uLL).u64[0];
  float32x4_t v19 = vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v8.i8, v18));
  int16x4_t v20 = (int16x4_t)vextq_s8(v7, v7, 8uLL).u64[0];
  float32x4_t v21 = vmlaq_f32(v11, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v10.i8, v15)), v11);
  float32x4_t v22 = vmlaq_f32(v12, vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vuzp2q_s16(v9, (int16x8_t)v36.val[0])), v12);
  float32x4_t v23 = vmlaq_f32(v13, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v8.i8, v18)), v13);
  float32x4_t v24 = vmlaq_f32(v14, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v7.i8, v20)), v14);
  float32x4_t v25 = vmlaq_f32(v14, vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v7.i8, v20)), v14);
  float32x4_t v26 = vmlaq_f32(v13, v19, v13);
  float32x4_t v27 = vmlaq_f32(v12, v17, v12);
  float32x4_t v28 = vmlaq_f32(v11, v16, v11);
  v16.i64[0] = *(void *)a4;
  v16.i32[0] = *(_DWORD *)(a4 + 8);
  float32x4_t v29 = vmlsq_lane_f32(vmlsq_lane_f32(v11, v21, *(float32x2_t *)a4, 0), v28, *(float32x2_t *)v16.f32, 0);
  float32x4_t v30 = vmlsq_lane_f32(vmlsq_lane_f32(v12, v22, *(float32x2_t *)a4, 0), v27, *(float32x2_t *)v16.f32, 0);
  float32x4_t v31 = vmlsq_lane_f32(vmlsq_lane_f32(v13, v23, *(float32x2_t *)a4, 0), v26, *(float32x2_t *)v16.f32, 0);
  float32x4_t v32 = vmlsq_lane_f32(vmlsq_lane_f32(v14, v24, *(float32x2_t *)a4, 0), v25, *(float32x2_t *)v16.f32, 0);
  v16.i64[0] = *(void *)(a4 + 4);
  float32x4_t v33 = vmulq_n_f32(v32, v16.f32[0]);
  v42.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v21), v22);
  v41.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v23), v24);
  v39.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v29, v16.f32[0])), vmulq_n_f32(v30, v16.f32[0]));
  v38.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v31, v16.f32[0])), v33);
  v42.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v28), v27);
  v41.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v26), v25);
  v38.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41BE0);
  v40.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C00);
  v40.val[1] = v38.val[1];
  v44.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C20);
  v44.val[1] = v38.val[1];
  v41.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C30);
  v41.val[1] = v38.val[1];
  v39.val[0] = vqtbl2q_s8(v42, (int8x16_t)xmmword_228F41BE0);
  v43.val[0] = vqtbl2q_s8(v42, (int8x16_t)xmmword_228F41C00);
  v43.val[1] = v39.val[1];
  v45.val[0] = vqtbl2q_s8(v42, (int8x16_t)xmmword_228F41C20);
  v45.val[1] = v39.val[1];
  v42.val[0] = vqtbl2q_s8(v42, (int8x16_t)xmmword_228F41C30);
  v42.val[1] = v39.val[1];
  v37.val[0] = vqtbl2q_s8(v42, (int8x16_t)xmmword_228F61E40);
  v42.val[1] = vqtbl2q_s8(v37, (int8x16_t)xmmword_228F41C70);
  v37.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F61E30);
  v45.val[1] = vqtbl2q_s8(v37, (int8x16_t)xmmword_228F41C50);
  v37.val[0] = vqtbl2q_s8(v43, (int8x16_t)xmmword_228F61E60);
  v43.val[1] = vqtbl2q_s8(v37, (int8x16_t)xmmword_228F41CB0);
  v37.val[0] = vqtbl2q_s8(v39, (int8x16_t)xmmword_228F61E50);
  v37.val[0] = vqtbl2q_s8(v37, (int8x16_t)xmmword_228F41C90);
  v36.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F61E40);
  v37.val[1] = vqtbl2q_s8(v36, (int8x16_t)xmmword_228F41C70);
  v36.val[0] = vqtbl2q_s8(v44, (int8x16_t)xmmword_228F61E30);
  v39.val[1] = vqtbl2q_s8(v36, (int8x16_t)xmmword_228F41C50);
  v36.val[0] = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F61E60);
  v40.val[0] = vqtbl2q_s8(v36, (int8x16_t)xmmword_228F41CB0);
  v36.val[0] = vqtbl2q_s8(v38, (int8x16_t)xmmword_228F61E50);
  int8x16_t result = vqtbl2q_s8(v36, (int8x16_t)xmmword_228F41C90);
  unint64_t v35 = *a3;
  v35[6] = v40.val[0];
  v35[7] = result;
  v35[4] = v37.val[1];
  v35[5] = v39.val[1];
  v35[2] = v43.val[1];
  v35[3] = v37.val[0];
  *unint64_t v35 = v42.val[1];
  v35[1] = v45.val[1];
  *a3 += 8;
  return result;
}

int8x16_t _YCCtoRGBA<half,1u,16>(float16x8_t **a1, const __int16 **a2, uint64_t *a3, uint64_t a4, const __int16 *a5)
{
  int32x4_t v5 = *a1;
  *a1 += 2;
  float16x8_t v7 = *v5;
  float16x8_t v6 = v5[1];
  int8x16_t v8 = *a2;
  *a2 += 32;
  int8x16x2_t v41 = (int8x16x2_t)vld2q_s16(v8);
  v8 += 16;
  int16x8x2_t v42 = vld2q_s16(v8);
  float32x4_t v9 = vcvtq_f32_f16(*(float16x4_t *)v7.i8);
  float32x4_t v10 = vcvt_hight_f32_f16(v7);
  float32x4_t v11 = vcvtq_f32_f16(*(float16x4_t *)v6.i8);
  float32x4_t v12 = vcvt_hight_f32_f16(v6);
  float32x4_t v13 = vcvtq_f32_f16(*(float16x4_t *)v41.val[0].i8);
  float32x4_t v14 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v41.val[0], v41.val[0], 8uLL));
  float32x4_t v15 = vcvtq_f32_f16(*(float16x4_t *)v42.val[0].i8);
  float32x4_t v16 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v42.val[0], (int8x16_t)v42.val[0], 8uLL));
  float32x4_t v17 = vcvtq_f32_f16(*(float16x4_t *)v41.val[1].i8);
  v41.val[0] = (int8x16_t)vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v41.val[1], v41.val[1], 8uLL));
  v41.val[1] = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v42.val[1].i8);
  v42.val[0] = (int16x8_t)vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v42.val[1], (int8x16_t)v42.val[1], 8uLL));
  v42.val[1] = (int16x8_t)vmlaq_f32(v9, v17, v9);
  float32x4_t v18 = vmlaq_f32(v10, (float32x4_t)v41.val[0], v10);
  v41.val[0] = (int8x16_t)vmlaq_f32(v11, (float32x4_t)v41.val[1], v11);
  v41.val[1] = (int8x16_t)vmlaq_f32(v12, (float32x4_t)v42.val[0], v12);
  float32x4_t v19 = vmlaq_f32(v12, v16, v12);
  float32x4_t v20 = vmlaq_f32(v11, v15, v11);
  float32x4_t v21 = vmlaq_f32(v10, v14, v10);
  float32x4_t v22 = vmlaq_f32(v9, v13, v9);
  v42.val[0].i64[0] = *(void *)a4;
  v42.val[0].i32[0] = *(_DWORD *)(a4 + 8);
  float32x4_t v23 = vmlsq_lane_f32(vmlsq_lane_f32(v9, (float32x4_t)v42.val[1], *(float32x2_t *)a4, 0), v22, *(float32x2_t *)v42.val[0].i8, 0);
  float32x4_t v24 = vmlsq_lane_f32(vmlsq_lane_f32(v10, v18, *(float32x2_t *)a4, 0), v21, *(float32x2_t *)v42.val[0].i8, 0);
  float32x4_t v25 = vmlsq_lane_f32(vmlsq_lane_f32(v11, (float32x4_t)v41.val[0], *(float32x2_t *)a4, 0), v20, *(float32x2_t *)v42.val[0].i8, 0);
  float32x4_t v26 = vmlsq_lane_f32(vmlsq_lane_f32(v12, (float32x4_t)v41.val[1], *(float32x2_t *)a4, 0), v19, *(float32x2_t *)v42.val[0].i8, 0);
  v42.val[0].i64[0] = *(void *)(a4 + 4);
  float32x4_t v27 = vmulq_n_f32(v26, *(float *)v42.val[0].i32);
  v45.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32((float32x4_t)v42.val[1]), v18);
  v46.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32((float32x4_t)v41.val[0]), (float32x4_t)v41.val[1]);
  v40.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v23, *(float *)v42.val[0].i32)), vmulq_n_f32(v24, *(float *)v42.val[0].i32));
  v42.val[0] = (int16x8_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v25, *(float *)v42.val[0].i32)), v27);
  v45.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v22), v21);
  v46.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v20), v19);
  v41.val[0] = (int8x16_t)vld1q_dup_s16(a5);
  v40.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41BE0);
  v42.val[1] = (int16x8_t)vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41C00);
  int8x16_t v28 = v40.val[1];
  v44.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41C20);
  v44.val[1] = v40.val[1];
  v45.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41C30);
  v45.val[1] = v40.val[1];
  v41.val[1] = vqtbl2q_s8(v46, (int8x16_t)xmmword_228F41BE0);
  v43.val[0] = vqtbl2q_s8(v46, (int8x16_t)xmmword_228F41C00);
  v43.val[1] = (int8x16_t)v42.val[0];
  v47.val[0] = vqtbl2q_s8(v46, (int8x16_t)xmmword_228F41C20);
  v47.val[1] = (int8x16_t)v42.val[0];
  v46.val[0] = vqtbl2q_s8(v46, (int8x16_t)xmmword_228F41C30);
  v46.val[1] = (int8x16_t)v42.val[0];
  int8x16_t v29 = vqtbl2q_s8(v46, (int8x16_t)xmmword_228F61E40);
  v46.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C70);
  int8x16_t v30 = vqtbl2q_s8(v47, (int8x16_t)xmmword_228F61E30);
  v47.val[1] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C50);
  int8x16_t v31 = vqtbl2q_s8(v43, (int8x16_t)xmmword_228F61E60);
  v43.val[1] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41CB0);
  int8x16_t v32 = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v41 + 16), (int8x16_t)xmmword_228F61E50);
  v42.val[0] = (int16x8_t)vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C90);
  int8x16_t v33 = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F61E40);
  int8x16_t v34 = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C70);
  int8x16_t v35 = vqtbl2q_s8(v44, (int8x16_t)xmmword_228F61E30);
  v44.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C50);
  int8x16_t v36 = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v42 + 16), (int8x16_t)xmmword_228F61E60);
  v42.val[1] = (int16x8_t)vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41CB0);
  int8x16_t v37 = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F61E50);
  int8x16_t result = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F41C90);
  uint64_t v39 = *a3;
  *(int16x8_t *)(v39 + 32) = v42.val[1];
  *(int8x16_t *)(v39 + 48) = result;
  *(int8x16_t *)uint64_t v39 = v34;
  *(int8x16_t *)(v39 + 16) = v44.val[0];
  *(int8x16_t *)(v39 + 96) = v43.val[1];
  *(int16x8_t *)(v39 + 112) = v42.val[0];
  *(int8x16_t *)(v39 + 64) = v46.val[0];
  *(int8x16_t *)(v39 + 80) = v47.val[1];
  *a3 += 128;
  return result;
}

int8x16_t _YCCtoRGBA<half,2u,16>(float16x8_t **a1, int32x4_t **a2, int8x16_t **a3, uint64_t a4, const __int16 *a5)
{
  int32x4_t v5 = *a1;
  *a1 += 2;
  float16x8_t v6 = *v5;
  float16x8_t v7 = v5[1];
  int32x4_t v8 = **a2;
  int32x4_t v9 = (*a2)[1];
  *a2 += 2;
  int8x16_t v10 = (int8x16_t)vzip2q_s32(v9, v9);
  int8x16_t v11 = (int8x16_t)vzip1q_s32(v9, v9);
  int16x8_t v12 = (int16x8_t)vzip2q_s32(v8, v8);
  int8x16_t v13 = (int8x16_t)vzip1q_s32(v8, v8);
  float32x4_t v14 = vcvtq_f32_f16(*(float16x4_t *)v6.i8);
  float32x4_t v15 = vcvt_hight_f32_f16(v6);
  float32x4_t v16 = vcvtq_f32_f16(*(float16x4_t *)v7.i8);
  float32x4_t v17 = vcvt_hight_f32_f16(v7);
  int16x4_t v18 = (int16x4_t)vextq_s8(v13, v13, 8uLL).u64[0];
  float32x4_t v19 = vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v13.i8, v18));
  float32x4_t v20 = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vuzp1q_s16(v12, (int16x8_t)v14));
  int16x4_t v21 = (int16x4_t)vextq_s8(v11, v11, 8uLL).u64[0];
  float32x4_t v22 = vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v11.i8, v21));
  int16x4_t v23 = (int16x4_t)vextq_s8(v10, v10, 8uLL).u64[0];
  float32x4_t v24 = vmlaq_f32(v14, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v13.i8, v18)), v14);
  float32x4_t v25 = vmlaq_f32(v15, vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vuzp2q_s16(v12, (int16x8_t)v14)), v15);
  float32x4_t v26 = vmlaq_f32(v16, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v11.i8, v21)), v16);
  float32x4_t v27 = vmlaq_f32(v17, vcvtq_f32_f16((float16x4_t)vuzp2_s16(*(int16x4_t *)v10.i8, v23)), v17);
  float32x4_t v28 = vmlaq_f32(v17, vcvtq_f32_f16((float16x4_t)vuzp1_s16(*(int16x4_t *)v10.i8, v23)), v17);
  float32x4_t v29 = vmlaq_f32(v16, v22, v16);
  float32x4_t v30 = vmlaq_f32(v15, v20, v15);
  float32x4_t v31 = vmlaq_f32(v14, v19, v14);
  v10.i64[0] = *(void *)a4;
  v10.i32[0] = *(_DWORD *)(a4 + 8);
  float32x4_t v32 = vmlsq_lane_f32(vmlsq_lane_f32(v14, v24, *(float32x2_t *)a4, 0), v31, *(float32x2_t *)v10.i8, 0);
  float32x4_t v33 = vmlsq_lane_f32(vmlsq_lane_f32(v15, v25, *(float32x2_t *)a4, 0), v30, *(float32x2_t *)v10.i8, 0);
  float32x4_t v34 = vmlsq_lane_f32(vmlsq_lane_f32(v16, v26, *(float32x2_t *)a4, 0), v29, *(float32x2_t *)v10.i8, 0);
  float32x4_t v35 = vmlsq_lane_f32(vmlsq_lane_f32(v17, v27, *(float32x2_t *)a4, 0), v28, *(float32x2_t *)v10.i8, 0);
  v10.i64[0] = *(void *)(a4 + 4);
  v43.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v24), v25);
  v45.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v26), v27);
  v41.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v32, *(float *)v10.i32)), vmulq_n_f32(v33, *(float *)v10.i32));
  v39.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_n_f32(v34, *(float *)v10.i32)), vmulq_n_f32(v35, *(float *)v10.i32));
  v43.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v31), v30);
  v45.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v29), v28);
  v40.val[1] = (int8x16_t)vld1q_dup_s16(a5);
  v39.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41BE0);
  v42.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41C00);
  v42.val[1] = v39.val[1];
  v46.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41C20);
  v46.val[1] = v39.val[1];
  v45.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F41C30);
  v45.val[1] = v39.val[1];
  v41.val[0] = vqtbl2q_s8(v43, (int8x16_t)xmmword_228F41BE0);
  v44.val[0] = vqtbl2q_s8(v43, (int8x16_t)xmmword_228F41C00);
  v44.val[1] = v41.val[1];
  v47.val[0] = vqtbl2q_s8(v43, (int8x16_t)xmmword_228F41C20);
  v47.val[1] = v41.val[1];
  v43.val[0] = vqtbl2q_s8(v43, (int8x16_t)xmmword_228F41C30);
  v43.val[1] = v41.val[1];
  v40.val[0] = vqtbl2q_s8(v43, (int8x16_t)xmmword_228F61E40);
  v43.val[1] = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41C70);
  v40.val[0] = vqtbl2q_s8(v47, (int8x16_t)xmmword_228F61E30);
  v47.val[1] = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41C50);
  v40.val[0] = vqtbl2q_s8(v44, (int8x16_t)xmmword_228F61E60);
  v44.val[1] = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41CB0);
  v40.val[0] = vqtbl2q_s8(v41, (int8x16_t)xmmword_228F61E50);
  v41.val[1] = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41C90);
  v40.val[0] = vqtbl2q_s8(v45, (int8x16_t)xmmword_228F61E40);
  v43.val[0] = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41C70);
  v40.val[0] = vqtbl2q_s8(v46, (int8x16_t)xmmword_228F61E30);
  int8x16_t v36 = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41C50);
  v40.val[0] = vqtbl2q_s8(v42, (int8x16_t)xmmword_228F61E60);
  v42.val[0] = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41CB0);
  v40.val[0] = vqtbl2q_s8(v39, (int8x16_t)xmmword_228F61E50);
  int8x16_t result = vqtbl2q_s8(v40, (int8x16_t)xmmword_228F41C90);
  int8x16x2_t v38 = *a3;
  v38[6] = v42.val[0];
  v38[7] = result;
  void v38[4] = v43.val[0];
  v38[5] = v36;
  void v38[2] = v44.val[1];
  v38[3] = v41.val[1];
  *int8x16x2_t v38 = v43.val[1];
  v38[1] = v47.val[1];
  *a3 += 8;
  return result;
}

uint64_t DoAggregateBlock<ReadPlanesArgs>(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16);
  uint64_t v3 = v2 * a2;
  if (v2 >= *(void *)(result + 24) - v2 * a2) {
    uint64_t v4 = *(void *)(result + 24) - v2 * a2;
  }
  else {
    uint64_t v4 = *(void *)(result + 16);
  }
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      int8x16_t result = (*(uint64_t (**)(void, uint64_t))v5)(*(void *)(v5 + 8), v3++);
      --v4;
    }
    while (v4);
  }
  return result;
}

void AXRData::GetChannelCount(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_3;
  }
  while (1)
  {
    AXRLogError((uint64_t)"Error: image index %lu out of range [0,%lu]", a2, a3, a4, a5, a6, a7, a8, v8);
    __break(1u);
LABEL_3:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void Part::GetImageSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  char v9 = a3;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"Error: mip level index %lu to large [0, %u]", a2, a3, a4, a5, a6, a7, a8, v9);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_data_get_channel_info_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (GetFlagsOnceToken != -1) {
    goto LABEL_3;
  }
  while (1)
  {
    AXRLogError((uint64_t)"Error: version must be axr_channel_info_current", a2, a3, a4, a5, a6, a7, a8, vars0);
    __break(1u);
LABEL_3:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_data_get_part_info_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (GetFlagsOnceToken != -1) {
    goto LABEL_3;
  }
  while (1)
  {
    AXRLogError((uint64_t)"Error: version must be axr_part_info_current", a2, a3, a4, a5, a6, a7, a8, vars0);
    __break(1u);
LABEL_3:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_data_get_property_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (GetFlagsOnceToken != -1) {
    goto LABEL_3;
  }
  while (1)
  {
    AXRLogError((uint64_t)"Error: version must be axr_property_current", a2, a3, a4, a5, a6, a7, a8, vars0);
    __break(1u);
LABEL_3:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_data_get_layer_info_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (GetFlagsOnceToken != -1) {
    goto LABEL_3;
  }
  while (1)
  {
    AXRLogError((uint64_t)"Error: version must be axr_layer_info_current", a2, a3, a4, a5, a6, a7, a8, vars0);
    __break(1u);
LABEL_3:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_part_set_chromaticities_cold_1(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"axr_part_set_chromaticities: invalid colorspace model %d", a2, a3, a4, a5, a6, a7, a8, a1);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void AXRCreateColorSpace_cold_1(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | a1) & 2) != 0) {
      AXRLogError((uint64_t)"Error: options dictionary pointer is not a CFDictionary", a2, a3, a4, a5, a6, a7, a8, v9);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_encoder_append_part_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = kDefaultAXRLogFlags;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"axr_encoder_append_part:  encoder may not be NULL", a2, a3, a4, a5, a6, a7, a8, v9);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void Part::GetProperty(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"Error: property index (%lu) is out of bounds.", a2, a3, a4, a5, a6, a7, a8, a1);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_decoder_create_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  char v9 = a2;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"axr_decoder_create: the level index %lu is out of bounds. [0, %lu]", a2, a3, a4, a5, a6, a7, a8, v9);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_decoder_create_cold_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  char v9 = a2;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"axr_decoder_create: image index %lu out of bounds [0, %lu]", a2, a3, a4, a5, a6, a7, a8, v9);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_decoder_get_channel_info_cold_1(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | a1) & 2) != 0) {
      AXRLogError((uint64_t)"axr_decoder_get_channel_info: version must be set to axr_channel_info_current", a2, a3, a4, a5, a6, a7, a8, v9);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void axr_decoder_get_channel_info_cold_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  char v9 = a2;
  if (GetFlagsOnceToken != -1) {
    goto LABEL_5;
  }
  while (1)
  {
    if (((kDefaultAXRLogFlags | v8) & 2) != 0) {
      AXRLogError((uint64_t)"axr_decoder_get_channel_info: channelIndex %lu out of bounds [0, %u]", a2, a3, a4, a5, a6, a7, a8, v9);
    }
    __break(1u);
LABEL_5:
    dispatch_once_f(&GetFlagsOnceToken, &kDefaultAXRLogFlags, (dispatch_function_t)InitializeDefaultFlags);
  }
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x270ED7CD8](aBlock);
}

void _Block_release(const void *aBlock)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_object_alloc()
{
  return MEMORY[0x270ED80E0]();
}

uint64_t _os_object_dealloc()
{
  return MEMORY[0x270ED80E8]();
}

void bzero(void *a1, size_t a2)
{
}

uLong compressBound(uLong sourceLen)
{
  return MEMORY[0x270F9C688](sourceLen);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F48](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(void *)&algorithm);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F58](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(void *)&algorithm);
}

void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *context, void (__cdecl *work)(void *, size_t))
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x270ED9610](a1, a2);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x270ED9628](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x270ED9648](__handle, __symbol);
}

void free(void *a1)
{
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x270ED9BE8](a1);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x270EDA398](memptr, alignment, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
{
}

{
  MEMORY[0x270F9A570](context);
}

{
  return (void *)MEMORY[0x270F9A588]();
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

void os_release(void *object)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x270EDB0B0]();
}

void qsort_r(void *__base, size_t __nel, size_t __width, void *a4, int (__cdecl *__compar)(void *, const void *, const void *))
{
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x270EDB158](__ptr, __size);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

char *__cdecl stpcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x270EDB580](__dst, __src);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x270EDB600](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x270EDB620](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x270EDB648](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x270EDB658](__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB680](__s, *(void *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x270EDB6A0](__s1, __s2);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB718](__str, __endptr, *(void *)&__base);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x270EDB7D8](a1, a2, a3, a4, a5);
}

int uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
{
  return MEMORY[0x270F9C770](dest, destLen, source, sourceLen);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x270EDBB18](__str, __size, __format, a4);
}