double IR::IRCoordinates::IRCoordinates(IR::IRCoordinates *this)
{
  double result;

  *((_DWORD *)this + 8) = 0;
  result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((_DWORD *)this + 8) = 0;
  result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

double IR::IRCoordinates::reset(IR::IRCoordinates *this)
{
  *((_DWORD *)this + 8) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void *IR::IRCoordinates::getParameterString@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 8) {
    v2 = "";
  }
  else {
    v2 = off_2643A9830[a1];
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v2);
}

double IR::IRCoordinates::getAllCoordinates@<D0>(uint64_t a1@<X8>)
{
  *(_DWORD *)(a1 + 32) = 8;
  *(void *)&double result = 0x100000000;
  *(_OWORD *)a1 = xmmword_21B550F80;
  *(_OWORD *)(a1 + 16) = unk_21B550F90;
  return result;
}

uint64_t IR::IRCoordinates::set(uint64_t result, unsigned int a2, float a3)
{
  *(float *)(result + 4 * a2) = a3;
  return result;
}

float IR::IRCoordinates::get(uint64_t a1, unsigned int a2)
{
  return *(float *)(a1 + 4 * a2);
}

BOOL IR::IRCoordinates::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  do
  {
    float v3 = *(float *)(a1 + v2);
    float v4 = *(float *)(a2 + v2);
    if (v3 != v4) {
      break;
    }
    BOOL v5 = v2 == 32;
    v2 += 4;
  }
  while (!v5);
  return v3 == v4;
}

BOOL IR::IRCoordinates::operator!=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  do
  {
    float v3 = *(float *)(a1 + v2);
    float v4 = *(float *)(a2 + v2);
    if (v3 != v4) {
      break;
    }
    BOOL v5 = v2 == 32;
    v2 += 4;
  }
  while (!v5);
  return v3 != v4;
}

BOOL IR::IRCoordinates::equalWithAccuracy(IR::IRCoordinates *this, const IR::IRCoordinates *a2, const IR::IRCoordinates *a3, float a4)
{
  if (vabds_f32(*(float *)this, *(float *)a2) > a4) {
    return 0;
  }
  unint64_t v5 = 0;
  do
  {
    unint64_t v6 = v5;
    if (v5 == 8) {
      break;
    }
    float v7 = vabds_f32(*((float *)this + v5 + 1), *((float *)a2 + v5 + 1));
    ++v5;
  }
  while (v7 <= a4);
  return v6 > 7;
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    unint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    unint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_21B4DE420(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void applesauce::CF::construct_error(applesauce::CF *this)
{
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x263F8C3B0] + 16;
}

void applesauce::CF::ArrayRef::~ArrayRef(const void **this)
{
  v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void applesauce::CF::DictionaryRef::~DictionaryRef(const void **this)
{
  v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

const void *applesauce::CF::details::at_key<std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  float v3 = a2;
  CFIndex v5 = a2[23];
  if ((v5 & 0x80u) != 0) {
    a2 = *(const UInt8 **)a2;
  }
  if (!a2)
  {
    CFStringRef v8 = 0;
    if (a1) {
      goto LABEL_9;
    }
LABEL_12:
    if (!v8) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  CFIndex v6 = *((void *)v3 + 1);
  if ((v5 & 0x80u) == 0) {
    CFIndex v7 = v5;
  }
  else {
    CFIndex v7 = v6;
  }
  CFStringRef v8 = CFStringCreateWithBytes(0, a2, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (!a1) {
    goto LABEL_12;
  }
LABEL_9:
  Value = CFDictionaryGetValue(a1, v8);
  if (v8) {
LABEL_13:
  }
    CFRelease(v8);
LABEL_14:
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4DE624(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void __clang_call_terminate(void *a1)
{
}

void applesauce::CF::StringRef::~StringRef(const void **this)
{
  v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

applesauce::CF::DictionaryRef *applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>@<X0>(const __CFArray *a1@<X0>, unint64_t a2@<X1>, applesauce::CF::DictionaryRef *a3@<X8>)
{
  if (!a1 || CFArrayGetCount(a1) <= a2 || (ValueAtIndex = CFArrayGetValueAtIndex(a1, a2), (CFIndex v7 = ValueAtIndex) == 0))
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  CFRetain(ValueAtIndex);
  return applesauce::CF::DictionaryRef::DictionaryRef(a3, v7);
}

void sub_21B4DE770()
{
}

void sub_21B4DE79C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::not_found(applesauce::CF *this)
{
}

applesauce::CF::DictionaryRef *applesauce::CF::DictionaryRef::DictionaryRef(applesauce::CF::DictionaryRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFDictionaryGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
  }
  return this;
}

void sub_21B4DE848(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

uint64_t applesauce::CF::convert_to<unsigned int,0>(const __CFNumber *a1)
{
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(a1);
  if ((result & 0xFF00000000) == 0)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::convert_error(exception);
  }
  return result;
}

void sub_21B4DE8E8()
{
}

void sub_21B4DE908(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::convert_as<unsigned int,0>(const __CFNumber *a1)
{
  if (a1)
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(a1)) {
      return applesauce::CF::details::number_convert_as<unsigned int>(a1);
    }
  }

  return applesauce::CF::details::treat_as_BOOL_for_convert_as<unsigned int>(a1);
}

void applesauce::CF::convert_error(applesauce::CF *this)
{
}

uint64_t applesauce::CF::details::treat_as_BOOL_for_convert_as<unsigned int>(const __CFBoolean *a1)
{
  if (a1 && (CFTypeID TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(a1)))
  {
    uint64_t Value = CFBooleanGetValue(a1);
    uint64_t v4 = 0x100000000;
  }
  else
  {
    uint64_t Value = 0;
    uint64_t v4 = 0;
  }
  return v4 | Value;
}

uint64_t applesauce::CF::details::number_convert_as<unsigned int>(const __CFNumber *a1)
{
  switch(CFNumberGetType(a1))
  {
    case kCFNumberSInt8Type:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberSInt8Type;
      goto LABEL_10;
    case kCFNumberSInt16Type:
      LOWORD(valuePtr) = 0;
      CFNumberRef v7 = a1;
      CFNumberType v8 = kCFNumberSInt16Type;
      goto LABEL_17;
    case kCFNumberSInt32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberSInt32Type;
      goto LABEL_28;
    case kCFNumberSInt64Type:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberSInt64Type;
      goto LABEL_28;
    case kCFNumberFloat32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberFloat32Type;
      goto LABEL_24;
    case kCFNumberFloat64Type:
      double valuePtr = 0.0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberFloat64Type;
      goto LABEL_30;
    case kCFNumberCharType:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberCharType;
LABEL_10:
      int Value = CFNumberGetValue(v2, v3, &valuePtr);
      uint64_t v16 = Value != 0;
      if (Value) {
        unsigned __int8 v17 = LOBYTE(valuePtr);
      }
      else {
        unsigned __int8 v17 = 0;
      }
      int v18 = -256;
      if ((v16 & (SLOBYTE(valuePtr) < 0)) == 0) {
        int v18 = 0;
      }
      uint64_t v5 = v16 << 32;
      LODWORD(v6) = v18 & 0xFFFFFF00 | v17;
      int v4 = v6 & 0xFFFFFF00;
      return v5 | v4 & 0xFFFFFF00 | v6;
    case kCFNumberShortType:
      LOWORD(valuePtr) = 0;
      CFNumberRef v7 = a1;
      CFNumberType v8 = kCFNumberShortType;
LABEL_17:
      if (CFNumberGetValue(v7, v8, &valuePtr)) {
        uint64_t v6 = SLOWORD(valuePtr) & 0xFFFFFFFFLL | 0x100000000;
      }
      else {
        uint64_t v6 = 0;
      }
      goto LABEL_33;
    case kCFNumberIntType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberIntType;
      goto LABEL_28;
    case kCFNumberLongType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberLongType;
      goto LABEL_28;
    case kCFNumberLongLongType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberLongLongType;
      goto LABEL_28;
    case kCFNumberFloatType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberFloatType;
LABEL_24:
      int v19 = CFNumberGetValue(v11, v12, &valuePtr);
      uint64_t v20 = *(float *)&valuePtr;
      goto LABEL_31;
    case kCFNumberDoubleType:
      double valuePtr = 0.0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberDoubleType;
      goto LABEL_30;
    case kCFNumberCFIndexType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberCFIndexType;
      goto LABEL_28;
    case kCFNumberNSIntegerType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberNSIntegerType;
LABEL_28:
      int v19 = CFNumberGetValue(v9, v10, &valuePtr);
      uint64_t v20 = LODWORD(valuePtr);
      goto LABEL_31;
    case kCFNumberCGFloatType:
      double valuePtr = 0.0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberCGFloatType;
LABEL_30:
      int v19 = CFNumberGetValue(v13, v14, &valuePtr);
      uint64_t v20 = valuePtr;
LABEL_31:
      uint64_t v6 = v20 | 0x100000000;
      if (!v19) {
        uint64_t v6 = 0;
      }
LABEL_33:
      int v4 = v6 & 0xFFFFFF00;
      uint64_t v5 = v6 & 0x100000000;
      break;
    default:
      int v4 = 0;
      uint64_t v5 = 0;
      LOBYTE(v6) = 0;
      break;
  }
  return v5 | v4 & 0xFFFFFF00 | v6;
}

uint64_t applesauce::CF::convert_as<float,0>(const __CFNumber *a1)
{
  if (a1)
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(a1)) {
      return applesauce::CF::details::number_convert_as<float>(a1);
    }
  }

  return applesauce::CF::details::treat_as_BOOL_for_convert_as<float>(a1);
}

uint64_t applesauce::CF::details::treat_as_BOOL_for_convert_as<float>(const __CFBoolean *a1)
{
  if (a1 && (CFTypeID TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(a1)))
  {
    uint64_t v3 = COERCE_UNSIGNED_INT((float)CFBooleanGetValue(a1));
    uint64_t v4 = 0x100000000;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0;
  }
  return v3 | v4;
}

uint64_t applesauce::CF::details::number_convert_as<float>(const __CFNumber *a1)
{
  switch(CFNumberGetType(a1))
  {
    case kCFNumberSInt8Type:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberSInt8Type;
      goto LABEL_10;
    case kCFNumberSInt16Type:
      LOWORD(valuePtr) = 0;
      CFNumberRef v7 = a1;
      CFNumberType v8 = kCFNumberSInt16Type;
      goto LABEL_12;
    case kCFNumberSInt32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberSInt32Type;
      goto LABEL_15;
    case kCFNumberSInt64Type:
      double valuePtr = 0.0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberSInt64Type;
      goto LABEL_23;
    case kCFNumberFloat32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberFloat32Type;
      goto LABEL_19;
    case kCFNumberFloat64Type:
      double valuePtr = 0.0;
      CFNumberRef v15 = a1;
      CFNumberType v16 = kCFNumberFloat64Type;
      goto LABEL_25;
    case kCFNumberCharType:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberCharType;
LABEL_10:
      int Value = CFNumberGetValue(v2, v3, &valuePtr);
      int v18 = SLOBYTE(valuePtr);
      goto LABEL_13;
    case kCFNumberShortType:
      LOWORD(valuePtr) = 0;
      CFNumberRef v7 = a1;
      CFNumberType v8 = kCFNumberShortType;
LABEL_12:
      int Value = CFNumberGetValue(v7, v8, &valuePtr);
      int v18 = SLOWORD(valuePtr);
LABEL_13:
      float v19 = (float)v18;
      goto LABEL_26;
    case kCFNumberIntType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberIntType;
LABEL_15:
      int Value = CFNumberGetValue(v9, v10, &valuePtr);
      float v19 = (float)SLODWORD(valuePtr);
      goto LABEL_26;
    case kCFNumberLongType:
      double valuePtr = 0.0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberLongType;
      goto LABEL_23;
    case kCFNumberLongLongType:
      double valuePtr = 0.0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberLongLongType;
      goto LABEL_23;
    case kCFNumberFloatType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberFloatType;
LABEL_19:
      int Value = CFNumberGetValue(v13, v14, &valuePtr);
      uint64_t v20 = LODWORD(valuePtr);
      goto LABEL_27;
    case kCFNumberDoubleType:
      double valuePtr = 0.0;
      CFNumberRef v15 = a1;
      CFNumberType v16 = kCFNumberDoubleType;
      goto LABEL_25;
    case kCFNumberCFIndexType:
      double valuePtr = 0.0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberCFIndexType;
      goto LABEL_23;
    case kCFNumberNSIntegerType:
      double valuePtr = 0.0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberNSIntegerType;
LABEL_23:
      int Value = CFNumberGetValue(v11, v12, &valuePtr);
      float v19 = (float)*(uint64_t *)&valuePtr;
      goto LABEL_26;
    case kCFNumberCGFloatType:
      double valuePtr = 0.0;
      CFNumberRef v15 = a1;
      CFNumberType v16 = kCFNumberCGFloatType;
LABEL_25:
      int Value = CFNumberGetValue(v15, v16, &valuePtr);
      float v19 = valuePtr;
LABEL_26:
      uint64_t v20 = LODWORD(v19);
LABEL_27:
      uint64_t v6 = v20 | 0x100000000;
      if (!Value) {
        uint64_t v6 = 0;
      }
      int v4 = v6 & 0xFFFFFF00;
      uint64_t v5 = v6 & 0x100000000;
      break;
    default:
      int v4 = 0;
      uint64_t v5 = 0;
      LOBYTE(v6) = 0;
      break;
  }
  return v5 | v4 & 0xFFFFFF00 | v6;
}

void *applesauce::CF::details::CFString_get_value<true>@<X0>(const __CFString *a1@<X0>, uint64_t a2@<X8>)
{
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    return std::string::basic_string[abi:ne180100]<0>((void *)a2, CStringPtr);
  }
  else
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex maxBufLen = 0;
    v10.location = 0;
    v10.length = Length;
    CFStringGetBytes(a1, v10, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
    std::string::basic_string[abi:ne180100]((void *)a2, maxBufLen, 0);
    if (*(char *)(a2 + 23) >= 0) {
      CFNumberRef v7 = (UInt8 *)a2;
    }
    else {
      CFNumberRef v7 = *(UInt8 **)a2;
    }
    v11.location = 0;
    v11.length = Length;
    return (void *)CFStringGetBytes(a1, v11, 0x8000100u, 0, 0, v7, maxBufLen, &maxBufLen);
  }
}

void sub_21B4DF078(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::basic_string[abi:ne180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

const void *applesauce::CF::details::at_key<char const* const&>(const __CFDictionary *a1, const char **a2)
{
  int v4 = (const UInt8 *)*a2;
  CFIndex v5 = strlen(*a2);
  if (!v4)
  {
    if (a1) {
      goto LABEL_4;
    }
LABEL_7:
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  int v4 = (const UInt8 *)CFStringCreateWithBytes(0, v4, v5, 0x8000100u, 0);
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (!a1) {
    goto LABEL_7;
  }
LABEL_4:
  int Value = CFDictionaryGetValue(a1, v4);
  if (v4) {
LABEL_8:
  }
    CFRelease(v4);
LABEL_9:
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4DF220(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t IR::FFTFilterTranspose::Implementation::initialize(IR::FFTFilterTranspose::Implementation *this, int a2, int a3, unsigned int a4, int a5, int a6, int a7, char a8, BOOL a9, BOOL a10)
{
  if (*((unsigned char *)this + 45)) {
    (*(void (**)(IR::FFTFilterTranspose::Implementation *))(*(void *)this + 32))(this);
  }
  if (!a2)
  {
    (*(void (**)(IR::FFTFilterTranspose::Implementation *))(*(void *)this + 40))(this);
    return 4294967246;
  }
  *((_DWORD *)this + 6) = a4;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((_DWORD *)this + 8) = a7;
  uint64_t v18 = a4;
  *((unsigned char *)this + 46) = a8;
  std::vector<std::vector<float>>::resize((uint64_t *)this + 64, a4);
  std::vector<std::vector<float>>::resize((uint64_t *)this + 67, (2 * *((_DWORD *)this + 6)));
  unsigned int v19 = *((_DWORD *)this + 3);
  if (!v19)
  {
    unsigned int v20 = *((_DWORD *)this + 2);
LABEL_16:
    *((_DWORD *)this + 4) = 0;
    *((_DWORD *)this + 5) = v20;
    *((_DWORD *)this + 3) = 0;
    uint64_t v28 = *((void *)this + 64);
    if (*((void *)this + 65) != v28)
    {
      uint64_t v29 = 0;
      unsigned int v30 = 1;
      do
      {
        std::vector<float>::resize(v28 + 24 * v29, (*((_DWORD *)this + 5) + a6));
        uint64_t v29 = v30;
        uint64_t v28 = *((void *)this + 64);
        BOOL v27 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 65) - v28) >> 3) > v30++;
      }
      while (v27);
    }
    uint64_t v31 = *((void *)this + 67);
    if (*((void *)this + 68) != v31)
    {
      uint64_t v32 = 0;
      unsigned int v33 = 1;
      do
      {
        std::vector<float>::resize(v31 + 24 * v32, (*((_DWORD *)this + 5) + a6));
        uint64_t v32 = v33;
        uint64_t v31 = *((void *)this + 67);
        BOOL v27 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 68) - v31) >> 3) > v33++;
      }
      while (v27);
    }
    std::vector<float>::resize((uint64_t)this + 560, (*((_DWORD *)this + 5) + a6));
    goto LABEL_31;
  }
  if (a5)
  {
    unsigned int v20 = *((_DWORD *)this + 2);
    if (v20 <= v19) {
      goto LABEL_16;
    }
  }
  int v21 = MultiRadixRealFFT::Size((IR::FFTFilterTranspose::Implementation *)((char *)this + 168));
  int v22 = *((_DWORD *)this + 3);
  if (v21 != 2 * v22)
  {
    uint64_t result = MultiRadixRealFFT::Initialize((IR::FFTFilterTranspose::Implementation *)((char *)this + 168), 2 * v22);
    if (result) {
      return result;
    }
  }
  if (a5)
  {
    *((_DWORD *)this + 5) = *((_DWORD *)this + 3);
    uint64_t v24 = *((void *)this + 64);
    if (*((void *)this + 65) != v24)
    {
      uint64_t v25 = 0;
      unsigned int v26 = 1;
      do
      {
        std::vector<float>::resize(v24 + 24 * v25, (*((_DWORD *)this + 5) + a6));
        uint64_t v25 = v26;
        uint64_t v24 = *((void *)this + 64);
        BOOL v27 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 65) - v24) >> 3) > v26++;
      }
      while (v27);
    }
  }
  else
  {
    *((_DWORD *)this + 5) = 0;
    uint64_t v34 = *((void *)this + 64);
    if (*((void *)this + 65) != v34)
    {
      uint64_t v35 = 0;
      unsigned int v36 = 1;
      do
      {
        std::vector<float>::resize(v34 + 24 * v35, 0);
        uint64_t v35 = v36;
        uint64_t v34 = *((void *)this + 64);
        BOOL v27 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 65) - v34) >> 3) > v36++;
      }
      while (v27);
    }
  }
  uint64_t v37 = *((void *)this + 67);
  if (*((void *)this + 68) != v37)
  {
    uint64_t v38 = 0;
    unsigned int v39 = 1;
    do
    {
      std::vector<float>::resize(v37 + 24 * v38, (a6 + 2 * *((_DWORD *)this + 3)));
      uint64_t v38 = v39;
      uint64_t v37 = *((void *)this + 67);
      BOOL v27 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 68) - v37) >> 3) > v39++;
    }
    while (v27);
  }
  std::vector<float>::resize((uint64_t)this + 560, (a6 + 2 * *((_DWORD *)this + 3)));
  unsigned int v40 = *((_DWORD *)this + 3);
  unsigned int v41 = *((_DWORD *)this + 2) - *((_DWORD *)this + 5);
  *((_DWORD *)this + 4) = v41 / v40;
  if (v41 / v40 * v40 < v41) {
    *((_DWORD *)this + 4) = v41 / v40 + 1;
  }
LABEL_31:
  if (*((unsigned char *)this + 46))
  {
    int v42 = *((_DWORD *)this + 3);
    if (v42) {
      *((_DWORD *)this + 8) = v42;
    }
    else {
      *((unsigned char *)this + 46) = 0;
    }
  }
  std::vector<std::vector<float>>::resize((uint64_t *)this + 61, *((unsigned int *)this + 6));
  std::vector<std::vector<float>>::resize((uint64_t *)this + 58, (2 * *((_DWORD *)this + 6)));
  if (*((_DWORD *)this + 6))
  {
    uint64_t v43 = 0;
    unint64_t v44 = 0;
    unsigned int v45 = 1;
    do
    {
      std::vector<float>::resize(*((void *)this + 61) + v43, (a6 + 2 * *((_DWORD *)this + 3)));
      std::vector<float>::resize(*((void *)this + 58) + 24 * (v45 - 1), (a6 + 2 * *((_DWORD *)this + 3)));
      std::vector<float>::resize(*((void *)this + 58) + 24 * v45, (a6 + 2 * *((_DWORD *)this + 3)));
      ++v44;
      unint64_t v46 = *((unsigned int *)this + 6);
      v43 += 24;
      v45 += 2;
    }
    while (v44 < v46);
    unint64_t v47 = (2 * v46);
  }
  else
  {
    unint64_t v47 = 0;
  }
  v48 = (uint64_t *)((char *)this + 208);
  if (*((_DWORD *)this + 3))
  {
    std::vector<std::vector<DSPSplitComplex>>::resize(v48, v47);
    unint64_t v49 = (4 * *((_DWORD *)this + 6) * *((_DWORD *)this + 3));
    int v71 = 0;
    std::vector<float>::resize((uint64_t)this + 184, v49, &v71);
    uint64_t v50 = *((void *)this + 26);
    if (*((void *)this + 27) != v50)
    {
      uint64_t v51 = 0;
      unsigned int v52 = 0;
      unsigned int v53 = 1;
      do
      {
        uint64_t v54 = 3 * v51;
        std::vector<DSPSplitComplex>::resize(v50 + 24 * v51, 1uLL);
        uint64_t v55 = *((void *)this + 23);
        uint64_t v50 = *((void *)this + 26);
        uint64_t v56 = *((void *)this + 27);
        v57 = *(void **)(v50 + 8 * v54);
        int v58 = *((_DWORD *)this + 3);
        void *v57 = v55 + 4 * v52;
        v57[1] = v55 + 4 * (v58 + v52);
        v52 += v58 + v58;
        uint64_t v51 = v53;
        BOOL v27 = 0xAAAAAAAAAAAAAAABLL * ((v56 - v50) >> 3) > v53++;
      }
      while (v27);
    }
  }
  else
  {
    std::vector<std::vector<DSPSplitComplex>>::resize(v48, 0);
    std::vector<float>::resize((uint64_t)this + 184, 0);
  }
  if (*((unsigned char *)this + 46))
  {
    unint64_t v59 = (4 * *((_DWORD *)this + 3));
    int v70 = 0;
    std::vector<float>::resize((uint64_t)this + 240, v59, &v70);
    uint64_t v60 = *((void *)this + 30);
    uint64_t v61 = *((unsigned int *)this + 3);
    *((void *)this + 35) = v60;
    *((void *)this + 36) = v60 + 4 * v61;
    *((void *)this + 37) = v60 + 4 * (2 * v61);
    *((void *)this + 38) = v60 + 4 * (3 * v61);
  }
  *((unsigned char *)this + 47) = a9;
  if (a9)
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      v63 = (char *)this + 32 * i;
      v64 = (uint64_t *)(v63 + 48);
      v65 = (caulk::pooled_semaphore_mutex *)(v63 + 72);
      caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v63 + 72));
      std::vector<IR::FFTFilterKernel>::resize(v64, a4);
      if (a4)
      {
        uint64_t v66 = 0;
        do
        {
          IR::FFTFilterKernel::initialize((IR::FFTFilterKernel *)(*v64 + v66), *((_DWORD *)this + 2), *((_DWORD *)this + 3), a5);
          IR::FFTFilterKernel::reset((IR::FFTFilterKernel *)(*v64 + v66));
          v66 += 40;
        }
        while (40 * a4 != v66);
      }
      caulk::pooled_semaphore_mutex::_unlock(v65);
    }
  }
  else
  {
    caulk::pooled_semaphore_mutex::_lock((IR::FFTFilterTranspose::Implementation *)((char *)this + 72));
    std::vector<IR::FFTFilterKernel>::resize((uint64_t *)this + 6, a4);
    if (a4)
    {
      uint64_t v67 = 0;
      uint64_t v68 = 40 * v18;
      do
      {
        IR::FFTFilterKernel::initialize((IR::FFTFilterKernel *)(*((void *)this + 6) + v67), *((_DWORD *)this + 2), *((_DWORD *)this + 3), a5);
        IR::FFTFilterKernel::reset((IR::FFTFilterKernel *)(*((void *)this + 6) + v67));
        v67 += 40;
      }
      while (v68 != v67);
    }
    caulk::pooled_semaphore_mutex::_unlock((IR::FFTFilterTranspose::Implementation *)((char *)this + 72));
  }
  *((void *)this + 19) = (char *)this + 48;
  *((void *)this + 20) = (char *)this + 48;
  if (*((unsigned char *)this + 47)) {
    v69 = (char *)this + 80;
  }
  else {
    v69 = (char *)this + 48;
  }
  *((void *)this + 18) = v69;
  (*(void (**)(IR::FFTFilterTranspose::Implementation *))(*(void *)this + 40))(this);
  uint64_t result = 0;
  *((unsigned char *)this + 45) = 1;
  return result;
}

void std::vector<std::vector<float>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<float>>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = a1[1];
      do
      {
        CFRange v10 = *(void **)(v8 - 24);
        v8 -= 24;
        CFNumberRef v9 = v10;
        if (v10)
        {
          *(void *)(v3 - 16) = v9;
          operator delete(v9);
        }
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<std::vector<DSPSplitComplex>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<DSPSplitComplex>>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = a1[1];
      do
      {
        CFRange v10 = *(void **)(v8 - 24);
        v8 -= 24;
        CFNumberRef v9 = v10;
        if (v10)
        {
          *(void *)(v3 - 16) = v9;
          operator delete(v9);
        }
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((void **)a1, a2 - v3, a3);
  }
}

void std::vector<DSPSplitComplex>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    std::vector<DSPSplitComplex>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<IR::FFTFilterKernel>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<IR::FFTFilterKernel>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 40 * a2;
    while (v3 != v7)
      IR::FFTFilterKernel::~FFTFilterKernel((IR::FFTFilterKernel *)(v3 - 40));
    a1[1] = v7;
  }
}

void IR::FFTFilterTranspose::Implementation::uninitialize(IR::FFTFilterTranspose::Implementation *this)
{
  *((_DWORD *)this + 114) = 0;
  *((_WORD *)this + 230) = 256;
  *((_DWORD *)this + 146) = 0;
  *((void *)this + 31) = *((void *)this + 30);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 64);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 61);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 58);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 67);
  *((void *)this + 71) = *((void *)this + 70);
}

void IR::FFTFilterTranspose::Implementation::reset(float **this)
{
  IR::FFTFilter::Implementation::reset(this);
  vDSP_vclr(this[30], 1, this[31] - this[30]);
  unint64_t v2 = this[61];
  if (this[62] != v2)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      vDSP_vclr(*(float **)&v2[6 * v3], 1, (uint64_t)(*(void *)&v2[6 * v3 + 2] - *(void *)&v2[6 * v3]) >> 2);
      uint64_t v3 = v4;
      unint64_t v2 = this[61];
      BOOL v5 = 0xAAAAAAAAAAAAAAABLL * (((char *)this[62] - (char *)v2) >> 3) > v4++;
    }
    while (v5);
  }
  unint64_t v6 = this[58];
  if (this[59] != v6)
  {
    uint64_t v7 = 0;
    unsigned int v8 = 1;
    do
    {
      vDSP_vclr(*(float **)&v6[6 * v7], 1, (uint64_t)(*(void *)&v6[6 * v7 + 2] - *(void *)&v6[6 * v7]) >> 2);
      uint64_t v7 = v8;
      unint64_t v6 = this[58];
      BOOL v5 = 0xAAAAAAAAAAAAAAABLL * (((char *)this[59] - (char *)v6) >> 3) > v8++;
    }
    while (v5);
  }
  CFNumberRef v9 = this[64];
  if (this[65] != v9)
  {
    uint64_t v10 = 0;
    unsigned int v11 = 1;
    do
    {
      vDSP_vclr(*(float **)&v9[6 * v10], 1, (uint64_t)(*(void *)&v9[6 * v10 + 2] - *(void *)&v9[6 * v10]) >> 2);
      uint64_t v10 = v11;
      CFNumberRef v9 = this[64];
      BOOL v5 = 0xAAAAAAAAAAAAAAABLL * (((char *)this[65] - (char *)v9) >> 3) > v11++;
    }
    while (v5);
  }
  *((_WORD *)this + 230) = 256;
  *((_DWORD *)this + 146) = 0;
  *((_DWORD *)this + 114) = 0;
}

uint64_t IR::FFTFilterTranspose::Implementation::forwardTransform(IR::FFTFilterTranspose::Implementation *this, DSPSplitComplex *__Z, DSPComplex *__C)
{
  vDSP_Length v5 = (unint64_t)*((unsigned int *)this + 3) >> 1;
  unint64_t v6 = &__Z->realp[v5];
  uint64_t v7 = &__Z->imagp[v5];
  vDSP_ctoz(__C, 2, __Z, 1, v5);
  vDSP_vclr(v6, 1, (unint64_t)*((unsigned int *)this + 3) >> 1);
  vDSP_vclr(v7, 1, (unint64_t)*((unsigned int *)this + 3) >> 1);

  return MultiRadixRealFFT::RealInPlaceTransform((IR::FFTFilterTranspose::Implementation *)((char *)this + 168), __Z, 1, 1.0);
}

void IR::FFTFilterTranspose::Implementation::fftBlockConvolution(uint64_t a1, const DSPSplitComplex *a2, IR::FFTFilterKernel *this, uint64_t *a4, unsigned int a5)
{
  FFTSubFilters = (const DSPSplitComplex *)IR::FFTFilterKernel::getFFTSubFilters(this);
  unsigned int NumActiveFFTSubFilters = IR::FFTFilterKernel::getNumActiveFFTSubFilters(this);
  unint64_t v12 = (unint64_t)(a4[1] - *a4) >> 4;
  if (NumActiveFFTSubFilters >= v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = NumActiveFFTSubFilters;
  }
  uint64_t ComplexMultiplicationLengths = IR::FFTFilterKernel::getComplexMultiplicationLengths(this);
  if (v13)
  {
    CFNumberRef v15 = (unsigned int *)ComplexMultiplicationLengths;
    uint64_t v16 = *a4;
    do
    {
      unsigned __int8 v17 = (const DSPSplitComplex *)(v16 + 16 * a5);
      float v18 = *v17->realp;
      float v19 = *v17->imagp;
      vDSP_zvma(a2, 1, FFTSubFilters, 1, v17, 1, v17, 1, *v15);
      *v17->realp = v18 + (float)(*a2->realp * *FFTSubFilters->realp);
      int v20 = *v15++;
      if (v20 == *(_DWORD *)(a1 + 12)) {
        *v17->imagp = v19 + (float)(*a2->imagp * *FFTSubFilters->imagp);
      }
      uint64_t v16 = *a4;
      if (a5 + 1 == ((unint64_t)(a4[1] - *a4) >> 4)) {
        a5 = 0;
      }
      else {
        ++a5;
      }
      ++FFTSubFilters;
      --v13;
    }
    while (v13);
  }
}

_DWORD *IR::FFTFilterTranspose::Implementation::dualFFTBlockConvolution(uint64_t a1, const DSPSplitComplex *a2, const DSPSplitComplex *a3, IR::FFTFilterKernel *this, IR::FFTFilterKernel *a5, uint64_t *a6, unsigned int a7)
{
  FFTSubFilters = (const DSPSplitComplex *)IR::FFTFilterKernel::getFFTSubFilters(this);
  unint64_t v12 = (const DSPSplitComplex *)IR::FFTFilterKernel::getFFTSubFilters(a5);
  unsigned int NumActiveFFTSubFilters = IR::FFTFilterKernel::getNumActiveFFTSubFilters(this);
  unint64_t v14 = (unint64_t)(a6[1] - *a6) >> 4;
  if (NumActiveFFTSubFilters >= v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = NumActiveFFTSubFilters;
  }
  uint64_t result = (_DWORD *)IR::FFTFilterKernel::getNumActiveFFTSubFilters(a5);
  unsigned int v26 = a6;
  unint64_t v17 = (unint64_t)(a6[1] - *a6) >> 4;
  if (result < v17) {
    LODWORD(v17) = result;
  }
  if (v15 == v17)
  {
    uint64_t ComplexMultiplicationLengths = (_DWORD *)IR::FFTFilterKernel::getComplexMultiplicationLengths(this);
    uint64_t result = (_DWORD *)IR::FFTFilterKernel::getComplexMultiplicationLengths(a5);
    if (v15)
    {
      uint64_t v19 = *v26;
      do
      {
        int v20 = (float **)(v19 + 16 * a7);
        uint64_t v29 = result + 1;
        unsigned int v30 = ComplexMultiplicationLengths + 1;
        if (*ComplexMultiplicationLengths <= *result) {
          vDSP_Length v21 = *result;
        }
        else {
          vDSP_Length v21 = *ComplexMultiplicationLengths;
        }
        float v22 = **v20;
        v23 = v20 + 1;
        float v24 = *v20[1];
        vDSP_zvmmaa(a2, 1, FFTSubFilters, 1, a3, 1, v12, 1, (const DSPSplitComplex *)(v19 + 16 * a7), 1, (const DSPSplitComplex *)(v19 + 16 * a7), 1, v21);
        **(float **)(v19 + 16 * a7) = v22
                                      + (float)((float)(*a3->realp * *v12->realp)
                                              + (float)(*a2->realp * *FFTSubFilters->realp));
        if (v21 == *(_DWORD *)(a1 + 12)) {
          float **v23 = v24 + (float)((float)(*a3->imagp * *v12->imagp) + (float)(*a2->imagp * *FFTSubFilters->imagp));
        }
        uint64_t v19 = *v26;
        if (a7 + 1 == ((unint64_t)(v26[1] - *v26) >> 4)) {
          a7 = 0;
        }
        else {
          ++a7;
        }
        ++FFTSubFilters;
        ++v12;
        --v15;
        uint64_t result = v29;
        uint64_t ComplexMultiplicationLengths = v30;
      }
      while (v15);
    }
  }
  return result;
}

void IR::FFTFilterTranspose::Implementation::timeDomainTransposeDualFIR(IR::FFTFilterTranspose::Implementation *this, const float *__B, const float *a3, float *__C, const float *__A, const float *a6, vDSP_Length __N, unsigned int a8)
{
  if (a8)
  {
    vDSP_Length v13 = __N;
    uint64_t v14 = a8;
    do
    {
      vDSP_vsma(__A, 1, __B, __C, 1, __C, 1, v13);
      vDSP_vsma(a6, 1, a3, __C, 1, __C, 1, v13);
      ++__B;
      ++__C;
      ++a3;
      --v14;
    }
    while (v14);
  }
}

void IR::FFTFilterTranspose::Implementation::firFilterSingleInput(IR::FFTFilterTranspose::Implementation *this, float *const *a2, unsigned int a3, unsigned int a4)
{
  int v8 = *((unsigned __int8 *)this + 460);
  if (*((unsigned char *)this + 462))
  {
    vDSP_Length v9 = a3;
    size_t v10 = 4 * a3;
    memcpy((void *)(*(void *)(*((void *)this + 67) + 24 * *((unsigned int *)this + 146))+ 4 * *((unsigned int *)this + 5)- 4), (const void *)(**((void **)this + 58) + 4 * *((unsigned int *)this + 9)), v10);
    if (v8)
    {
      if (a4)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 24;
        do
        {
          vDSP_Length v13 = (unsigned int *)(**((void **)this + 19) + v12);
          unsigned int v14 = *((_DWORD *)this + 5);
          if (*v13 >= v14) {
            vDSP_Length v15 = v14;
          }
          else {
            vDSP_Length v15 = *v13;
          }
          vDSP_conv((const float *)(*(void *)(*((void *)this + 67) + 24 * *((unsigned int *)this + 146))+ 4 * (v14 - v15)), 1, (const float *)(*((void *)v13 - 3) + 4 * v15 - 4), -1, *(float **)(*((void *)this + 64) + v11), 1, a3, v15);
          v12 += 40;
          v11 += 24;
        }
        while (24 * a4 != v11);
      }
      uint64_t v16 = *(char **)(*((void *)this + 67) + 24 * *((unsigned int *)this + 146));
      memmove(v16, &v16[4 * a3], 4 * (*((_DWORD *)this + 5) - 1));
      memcpy((void *)(*(void *)(*((void *)this + 67) + 24 * (*((_DWORD *)this + 146) ^ 1u))+ 4 * (*((_DWORD *)this + 5) - 1)), (const void *)(*(void *)(*((void *)this + 58) + 24) + 4 * *((unsigned int *)this + 9)), 4 * a3);
      if (a4)
      {
        uint64_t v17 = 0;
        uint64_t v18 = 24;
        do
        {
          uint64_t v19 = (unsigned int *)(**((void **)this + 18) + v18);
          unsigned int v20 = *((_DWORD *)this + 5);
          if (*v19 >= v20) {
            vDSP_Length v21 = v20;
          }
          else {
            vDSP_Length v21 = *v19;
          }
          vDSP_conv((const float *)(*(void *)(*((void *)this + 67) + 24 * (*((_DWORD *)this + 146) ^ 1u))+ 4 * (v20 - v21)), 1, (const float *)(*((void *)v19 - 3) + 4 * v21 - 4), -1, *((float **)this + 70), 1, a3, v21);
          vDSP_vadd(*((const float **)this + 70), 1, *(const float **)(*((void *)this + 64) + v17), 1, *(float **)(*((void *)this + 64) + v17), 1, a3);
          v18 += 40;
          v17 += 24;
        }
        while (24 * a4 != v17);
      }
      float v22 = *(char **)(*((void *)this + 67) + 24 * (*((_DWORD *)this + 146) ^ 1u));
      memmove(v22, &v22[4 * a3], 4 * (*((_DWORD *)this + 5) - 1));
      if (!*((_DWORD *)this + 10)) {
        *((_DWORD *)this + 114) -= a3;
      }
    }
    else
    {
      memcpy((void *)(*(void *)(*((void *)this + 67) + 24 * (*((_DWORD *)this + 146) ^ 1u))+ 4 * *((unsigned int *)this + 5)- 4), (const void *)(*(void *)(*((void *)this + 58) + 24) + 4 * *((unsigned int *)this + 9)), v10);
      if (a4)
      {
        uint64_t v29 = 0;
        uint64_t v30 = 24;
        do
        {
          uint64_t v31 = (unsigned int *)(**((void **)this + 19) + v30);
          unsigned int v32 = *((_DWORD *)this + 5);
          if (*v31 >= v32) {
            vDSP_Length v33 = v32;
          }
          else {
            vDSP_Length v33 = *v31;
          }
          vDSP_conv((const float *)(*(void *)(*((void *)this + 67) + 24 * *((unsigned int *)this + 146))+ 4 * (v32 - v33)), 1, (const float *)(*((void *)v31 - 3) + 4 * v33 - 4), -1, *(float **)(*((void *)this + 64) + v29), 1, v9, v33);
          v30 += 40;
          v29 += 24;
        }
        while (24 * a4 != v29);
      }
      uint64_t v34 = *(char **)(*((void *)this + 67) + 24 * *((unsigned int *)this + 146));
      memmove(v34, &v34[4 * v9], 4 * (*((_DWORD *)this + 5) - 1));
      uint64_t v35 = *(char **)(*((void *)this + 67) + 24 * (*((_DWORD *)this + 146) ^ 1u));
      memmove(v35, &v35[4 * v9], 4 * (*((_DWORD *)this + 5) - 1));
    }
    if (a4)
    {
      uint64_t v36 = 0;
      do
      {
        uint64_t v37 = *a2++;
        memcpy(v37, *(const void **)(*((void *)this + 64) + v36), v10);
        v36 += 24;
      }
      while (24 * a4 != v36);
    }
  }
  else
  {
    if (*((unsigned char *)this + 460))
    {
      if (a4)
      {
        uint64_t v23 = 0;
        uint64_t v24 = 24;
        uint64_t v25 = 24 * a4;
        do
        {
          unsigned int v26 = (const float **)(**((void **)this + 19) + v24);
          unsigned int v27 = *((_DWORD *)this + 5);
          if (*(_DWORD *)v26 >= v27) {
            vDSP_Length v28 = v27;
          }
          else {
            vDSP_Length v28 = *(unsigned int *)v26;
          }
          IR::FFTFilterTranspose::Implementation::timeDomainTransposeDualFIR(this, (const float *)(**((void **)this + 58) + 4 * *((unsigned int *)this + 9)), (const float *)(*(void *)(*((void *)this + 58) + 24) + 4 * *((unsigned int *)this + 9)), *(float **)(*((void *)this + 64) + v23), *(v26 - 3), *(const float **)(**((void **)this + 18) + v24 - 24), v28, a3);
          v24 += 40;
          v23 += 24;
        }
        while (v25 != v23);
      }
      unsigned int v54 = a4;
      if (!*((_DWORD *)this + 10)) {
        *((_DWORD *)this + 114) -= a3;
      }
    }
    else
    {
      if (!a4) {
        return;
      }
      uint64_t v38 = 0;
      uint64_t v55 = a3;
      unsigned int v54 = a4;
      do
      {
        if (a3)
        {
          uint64_t v40 = **((void **)this + 19);
          unsigned int v41 = (const float *)(**((void **)this + 58) + 4 * *((unsigned int *)this + 9));
          int v42 = *(float **)(*((void *)this + 64) + 24 * v38);
          uint64_t v43 = *(const float **)(v40 + 40 * v38);
          unsigned int v44 = *(_DWORD *)(v40 + 40 * v38 + 24);
          unsigned int v45 = *((_DWORD *)this + 5);
          if (v44 >= v45) {
            vDSP_Length v46 = v45;
          }
          else {
            vDSP_Length v46 = v44;
          }
          uint64_t v47 = v55;
          do
          {
            vDSP_vsma(v43, 1, v41, v42, 1, v42, 1, v46);
            ++v42;
            ++v41;
            --v47;
          }
          while (v47);
        }
        ++v38;
      }
      while (v38 != a4);
    }
    if (v54)
    {
      uint64_t v48 = 0;
      vDSP_Length v49 = a3;
      size_t v50 = 4 * a3;
      uint64_t v51 = 24;
      do
      {
        unsigned int v52 = *a2++;
        memcpy(v52, *(const void **)(*((void *)this + 64) + v48), v50);
        if (*(_DWORD *)(**((void **)this + 19) + v51) >= *((_DWORD *)this + 5)) {
          unsigned int v53 = *((_DWORD *)this + 5);
        }
        else {
          unsigned int v53 = *(_DWORD *)(**((void **)this + 19) + v51);
        }
        memmove(*(void **)(*((void *)this + 64) + v48), (const void *)(*(void *)(*((void *)this + 64) + v48) + 4 * v49), 4 * v53);
        vDSP_vclr((float *)(*(void *)(*((void *)this + 64) + v48) + 4 * v53), 1, v49);
        v48 += 24;
        v51 += 40;
      }
      while (24 * v54 != v48);
    }
  }
}

void IR::FFTFilterTranspose::Implementation::firFilterMultipleInput(IR::FFTFilterTranspose::Implementation *this, float *const *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = a4;
  unsigned int v5 = a3;
  if (*((unsigned char *)this + 462))
  {
    if (*((unsigned char *)this + 460))
    {
      if (a4)
      {
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        size_t v11 = 4 * a3;
        uint64_t v12 = 2 * a4;
        do
        {
          memcpy((void *)(*(void *)(*((void *)this + 67) + 24 * (v8 + *((_DWORD *)this + 146)))+ 4 * (*((_DWORD *)this + 5) - 1)), (const void *)(*(void *)(*((void *)this + 58) + 24 * v8)+ 4 * *((unsigned int *)this + 9)), v11);
          uint64_t v13 = **((void **)this + 19) + v10;
          unsigned int v14 = *(_DWORD *)(v13 + 24);
          unsigned int v15 = *((_DWORD *)this + 5);
          if (v14 >= v15) {
            vDSP_Length v16 = v15;
          }
          else {
            vDSP_Length v16 = v14;
          }
          vDSP_conv((const float *)(*(void *)(*((void *)this + 67) + 24 * (v8 + *((_DWORD *)this + 146)))+ 4 * (v15 - v16)), 1, (const float *)(*(void *)v13 + 4 * v16 - 4), -1, *(float **)(*((void *)this + 64) + v9), 1, a3, v16);
          uint64_t v17 = *(char **)(*((void *)this + 67) + 24 * (v8 + *((_DWORD *)this + 146)));
          memmove(v17, &v17[4 * a3], 4 * (*((_DWORD *)this + 5) - 1));
          memcpy((void *)(*(void *)(*((void *)this + 67) + 24 * (v8 + (*((_DWORD *)this + 146) ^ 1)))+ 4 * (*((_DWORD *)this + 5) - 1)), (const void *)(*(void *)(*((void *)this + 58) + 24 * (v8 + 1))+ 4 * *((unsigned int *)this + 9)), v11);
          uint64_t v18 = **((void **)this + 18) + v10;
          unsigned int v19 = *(_DWORD *)(v18 + 24);
          unsigned int v20 = *((_DWORD *)this + 5);
          if (v19 >= v20) {
            vDSP_Length v21 = v20;
          }
          else {
            vDSP_Length v21 = v19;
          }
          vDSP_conv((const float *)(*(void *)(*((void *)this + 67)+ 24 * (v8 + (*((_DWORD *)this + 146) ^ 1)))+ 4 * (v20 - v21)), 1, (const float *)(*(void *)v18 + 4 * v16 - 4), -1, *((float **)this + 70), 1, a3, v21);
          vDSP_vadd(*((const float **)this + 70), 1, *(const float **)(*((void *)this + 64) + v9), 1, *(float **)(*((void *)this + 64) + v9), 1, a3);
          float v22 = *(char **)(*((void *)this + 67) + 24 * (v8 + (*((_DWORD *)this + 146) ^ 1)));
          memmove(v22, &v22[4 * a3], 4 * (*((_DWORD *)this + 5) - 1));
          v10 += 40;
          v9 += 24;
          v8 += 2;
        }
        while (v12 != v8);
      }
      unsigned int v4 = a4;
      if (!*((_DWORD *)this + 10)) {
        *((_DWORD *)this + 114) -= a3;
      }
    }
    else
    {
      if (!a4) {
        return;
      }
      unsigned int v30 = 0;
      uint64_t v31 = 0;
      size_t v32 = 4 * a3;
      uint64_t v33 = 24 * a4;
      uint64_t v34 = 24;
      vDSP_Length v35 = a3;
      do
      {
        memcpy((void *)(*(void *)(*((void *)this + 67) + 24 * (v30 + *((_DWORD *)this + 146)))+ 4 * (*((_DWORD *)this + 5) - 1)), (const void *)(*(void *)(*((void *)this + 58) + 24 * v30) + 4 * *((unsigned int *)this + 9)), v32);
        memcpy((void *)(*(void *)(*((void *)this + 67) + 24 * (v30 + (*((_DWORD *)this + 146) ^ 1)))+ 4 * (*((_DWORD *)this + 5) - 1)), (const void *)(*(void *)(*((void *)this + 58) + 24 * (v30 + 1)) + 4 * *((unsigned int *)this + 9)), v32);
        uint64_t v36 = (unsigned int *)(**((void **)this + 19) + v34);
        unsigned int v37 = *((_DWORD *)this + 5);
        if (*v36 >= v37) {
          vDSP_Length v38 = v37;
        }
        else {
          vDSP_Length v38 = *v36;
        }
        vDSP_conv((const float *)(*(void *)(*((void *)this + 67) + 24 * (v30 + *((_DWORD *)this + 146)))+ 4 * (v37 - v38)), 1, (const float *)(*((void *)v36 - 3) + 4 * v38 - 4), -1, *(float **)(*((void *)this + 64) + v31), 1, v35, v38);
        unsigned int v39 = *(char **)(*((void *)this + 67) + 24 * (v30 + *((_DWORD *)this + 146)));
        memmove(v39, &v39[4 * v35], 4 * (*((_DWORD *)this + 5) - 1));
        uint64_t v40 = *(char **)(*((void *)this + 67) + 24 * (v30 + (*((_DWORD *)this + 146) ^ 1)));
        memmove(v40, &v40[4 * v35], 4 * (*((_DWORD *)this + 5) - 1));
        v34 += 40;
        v31 += 24;
        v30 += 2;
      }
      while (v33 != v31);
    }
    if (v4)
    {
      uint64_t v41 = 0;
      do
      {
        int v42 = *a2++;
        memcpy(v42, *(const void **)(*((void *)this + 64) + v41), 4 * a3);
        v41 += 24;
      }
      while (24 * v4 != v41);
    }
  }
  else
  {
    if (*((unsigned char *)this + 460))
    {
      if (a4)
      {
        uint64_t v23 = 0;
        uint64_t v24 = 24 * a4;
        unsigned int v25 = 1;
        uint64_t v26 = 24;
        do
        {
          unsigned int v27 = (const float **)(**((void **)this + 19) + v26);
          unsigned int v28 = *((_DWORD *)this + 5);
          if (*(_DWORD *)v27 >= v28) {
            vDSP_Length v29 = v28;
          }
          else {
            vDSP_Length v29 = *(unsigned int *)v27;
          }
          IR::FFTFilterTranspose::Implementation::timeDomainTransposeDualFIR(this, (const float *)(*(void *)(*((void *)this + 58) + 24 * (v25 - 1)) + 4 * *((unsigned int *)this + 9)), (const float *)(*(void *)(*((void *)this + 58) + 24 * v25) + 4 * *((unsigned int *)this + 9)), *(float **)(*((void *)this + 64) + v23), *(v27 - 3), *(const float **)(**((void **)this + 18) + v26 - 24), v29, v5);
          v26 += 40;
          v23 += 24;
          v25 += 2;
        }
        while (v24 != v23);
      }
      unsigned int v61 = v4;
      if (!*((_DWORD *)this + 10)) {
        *((_DWORD *)this + 114) -= v5;
      }
    }
    else
    {
      if (!a4) {
        return;
      }
      uint64_t v43 = 0;
      uint64_t v44 = a3;
      unsigned int v61 = a4;
      uint64_t v45 = a4;
      do
      {
        if (v5)
        {
          uint64_t v46 = **((void **)this + 19);
          uint64_t v47 = (const float *)(*(void *)(*((void *)this + 58) + 24 * (2 * v43))
                              + 4 * *((unsigned int *)this + 9));
          uint64_t v48 = *(float **)(*((void *)this + 64) + 24 * v43);
          vDSP_Length v49 = *(const float **)(v46 + 40 * v43);
          unsigned int v50 = *(_DWORD *)(v46 + 40 * v43 + 24);
          unsigned int v51 = *((_DWORD *)this + 5);
          if (v50 >= v51) {
            vDSP_Length v52 = v51;
          }
          else {
            vDSP_Length v52 = v50;
          }
          uint64_t v53 = v44;
          do
          {
            vDSP_vsma(v49, 1, v47, v48, 1, v48, 1, v52);
            ++v48;
            ++v47;
            --v53;
          }
          while (v53);
        }
        ++v43;
        unsigned int v5 = a3;
      }
      while (v43 != v45);
    }
    if (v61)
    {
      uint64_t v54 = 0;
      vDSP_Length v55 = v5;
      size_t v56 = 4 * v5;
      uint64_t v57 = 24;
      do
      {
        int v58 = *a2++;
        memcpy(v58, *(const void **)(*((void *)this + 64) + v54), v56);
        if (*(_DWORD *)(**((void **)this + 19) + v57) >= *((_DWORD *)this + 5)) {
          unsigned int v59 = *((_DWORD *)this + 5);
        }
        else {
          unsigned int v59 = *(_DWORD *)(**((void **)this + 19) + v57);
        }
        memmove(*(void **)(*((void *)this + 64) + v54), (const void *)(*(void *)(*((void *)this + 64) + v54) + 4 * v55), 4 * v59);
        vDSP_vclr((float *)(*(void *)(*((void *)this + 64) + v54) + 4 * v59), 1, v55);
        v54 += 24;
        v57 += 40;
      }
      while (24 * v61 != v54);
    }
  }
}

uint64_t IR::FFTFilterTranspose::Implementation::processMultipleInputs(IR::FFTFilterTranspose::Implementation *this, float *const *a2, float *const *a3, uint64_t a4, unsigned int a5, unsigned int a6, IR::ComplexDataCircBuffer::Implementation **a7)
{
  uint64_t v108 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 45)) {
    return 4294956429;
  }
  uint64_t v7 = a4;
  if (a4)
  {
    if (!a6) {
      return 4294967246;
    }
    uint64_t v9 = this;
    if (*((_DWORD *)this + 6) != a6 || a6 > a5) {
      return 4294967246;
    }
    if (*((_DWORD *)this + 2))
    {
      if (*((unsigned char *)this + 44))
      {
        if (caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(*((void *)this + 20) + 24))) {
          *((void *)v9 + 19) = *((void *)v9 + 20);
        }
        uint64_t v106 = 0;
        char v107 = 0;
        *((unsigned char *)v9 + 44) = 0;
        this = (IR::FFTFilterTranspose::Implementation *)std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v106);
      }
      int v14 = *((_DWORD *)v9 + 4);
      uint64_t v99 = v7;
      unsigned int v94 = a6;
      if (v14)
      {
        uint64_t v93 = (uint64_t)&v93;
        MEMORY[0x270FA5388](this);
        vDSP_Length v16 = (char *)&v93 - ((v15 + 15) & 0xFFFFFFFF0);
        if (v15 >= 0x200) {
          size_t v17 = 512;
        }
        else {
          size_t v17 = v15;
        }
        bzero((char *)&v93 - ((v15 + 15) & 0xFFFFFFFF0), v17);
        uint64_t v18 = *((unsigned int *)v9 + 6);
        uint64_t v19 = 8 * v18;
        MEMORY[0x270FA5388](v20);
        if ((unint64_t)(8 * v18) >= 0x200) {
          size_t v21 = 512;
        }
        else {
          size_t v21 = 8 * v18;
        }
        bzero((char *)&v93 - ((v19 + 15) & 0xFFFFFFFF0), v21);
        if (v18)
        {
          memcpy(v16, a2, 8 * v18);
          memcpy((char *)&v93 - ((v19 + 15) & 0xFFFFFFFF0), a3, 8 * v18);
        }
        unint64_t v102 = (unint64_t)&v93 - ((v19 + 15) & 0xFFFFFFFF0);
        v103 = v16;
        if (!a7) {
          return 4294967246;
        }
        v100 = a7;
        if (IR::ComplexDataCircBuffer::getNumOutputChannels((IR::ComplexDataCircBuffer *)a7) != *((_DWORD *)v9 + 6)
          || IR::ComplexDataCircBuffer::getNumFFTBuffers((IR::ComplexDataCircBuffer *)v100) < *((_DWORD *)v9 + 4))
        {
          return 4294967246;
        }
        unsigned int CircularIndex = IR::ComplexDataCircBuffer::getCircularIndex((IR::ComplexDataCircBuffer *)v100);
        *((_DWORD *)v9 + 9) = IR::ComplexDataCircBuffer::getFFTProcPos((IR::ComplexDataCircBuffer *)v100);
        v95 = (const DSPSplitComplex *)((char *)v9 + 296);
        v96 = (const DSPSplitComplex *)((char *)v9 + 280);
        uint64_t v28 = v99;
        size_t v29 = (size_t)v103;
        while (1)
        {
          unsigned int v30 = *((_DWORD *)v9 + 3) - *((_DWORD *)v9 + 9);
          uint64_t v99 = v28;
          if (v30 >= v28) {
            vDSP_Length v31 = v28;
          }
          else {
            vDSP_Length v31 = v30;
          }
          if (*((unsigned char *)v9 + 46) && *((_DWORD *)v9 + 6))
          {
            uint64_t v32 = 0;
            unint64_t v33 = 0;
            do
            {
              memcpy((void *)(*(void *)(*((void *)v9 + 61) + v32) + 4 * *((unsigned int *)v9 + 9)), *(const void **)(v29 + 8 * v33++), 4 * v31);
              v32 += 24;
            }
            while (v33 < *((unsigned int *)v9 + 6));
          }
          if (*((unsigned char *)v9 + 47))
          {
            uint64_t v34 = *((void *)v9 + 20);
            if (v34 != *((void *)v9 + 19) && !*((unsigned char *)v9 + 460) && !*((_DWORD *)v9 + 9))
            {
              uint64_t v106 = v34 + 24;
              int v35 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v34 + 24));
              char v107 = v35;
              size_t v29 = (size_t)v103;
              if (v35)
              {
                uint64_t v36 = *((void *)v9 + 19);
                uint64_t v37 = *((void *)v9 + 20);
                if (v37 != v36)
                {
                  *((void *)v9 + 18) = v36;
                  *((void *)v9 + 19) = v37;
                  uint64_t v106 = 0;
                  char v107 = 0;
                  int v38 = *((_DWORD *)v9 + 8);
                  if (v38)
                  {
                    *((_DWORD *)v9 + 10) = v38;
                    *((_DWORD *)v9 + 146) ^= 1u;
                  }
                  else
                  {
                    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v36 + 24));
                  }
                }
              }
              std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v106);
            }
          }
          unsigned int v39 = *((_DWORD *)v9 + 10);
          if (v39)
          {
            if (v31 >= v39) {
              vDSP_Length v40 = v39;
            }
            else {
              vDSP_Length v40 = v31;
            }
            if (*((_DWORD *)v9 + 5) || !*((unsigned char *)v9 + 46))
            {
              float v41 = (float)*((unsigned int *)v9 + 8);
              *(float *)&uint64_t v106 = -1.0 / v41;
              float __Step = -(float)(-1.0 / v41);
              if (*((_DWORD *)v9 + 6))
              {
                unint64_t v42 = 0;
                float v43 = (float)v39 / v41;
                vDSP_Length v97 = (v31 - v40);
                size_t v98 = 4 * v97;
                unsigned int v44 = 1;
                do
                {
                  float __Start = 1.0 - v43;
                  uint64_t v45 = *(const float **)(v29 + 8 * v42);
                  vDSP_vrampmul(v45, 1, &__Start, &__Step, (float *)(*(void *)(*((void *)v9 + 58) + 24 * (v44 - 1)) + 4 * *((unsigned int *)v9 + 9)), 1, v40);
                  if (v31 > v39) {
                    memcpy((void *)(*(void *)(*((void *)v9 + 58) + 24 * (v44 - 1))+ 4 * *((unsigned int *)v9 + 9)+ 4 * v40), &v45[v40], v98);
                  }
                  float __Start = v43;
                  vDSP_vrampmul(v45, 1, &__Start, (const float *)&v106, (float *)(*(void *)(*((void *)v9 + 58) + 24 * v44) + 4 * *((unsigned int *)v9 + 9)), 1, v40);
                  if (v31 > v39) {
                    vDSP_vclr((float *)(*(void *)(*((void *)v9 + 58) + 24 * v44)+ 4 * *((unsigned int *)v9 + 9)+ 4 * v40), 1, v97);
                  }
                  ++v42;
                  v44 += 2;
                  size_t v29 = (size_t)v103;
                }
                while (v42 < *((unsigned int *)v9 + 6));
                unsigned int v39 = *((_DWORD *)v9 + 10);
              }
            }
            *((_DWORD *)v9 + 10) = v39 - v40;
            if (v39 == v40)
            {
              int v48 = v31;
              if (*((unsigned char *)v9 + 462))
              {
                unsigned int v49 = *((_DWORD *)v9 + 5);
                if (v49 >= *((_DWORD *)v9 + 3)) {
                  unsigned int v49 = *((_DWORD *)v9 + 3);
                }
                int v48 = v49 + v40;
              }
              *((_DWORD *)v9 + 114) = v48;
              *((unsigned char *)v9 + 461) = 0;
            }
            *((unsigned char *)v9 + 460) = 1;
          }
          else
          {
            if (!*((_DWORD *)v9 + 5) && *((unsigned char *)v9 + 46)) {
              goto LABEL_81;
            }
            if (*((_DWORD *)v9 + 6))
            {
              unint64_t v46 = 0;
              unsigned int v47 = 1;
              do
              {
                memcpy((void *)(*(void *)(*((void *)v9 + 58) + 24 * (v47 - 1)) + 4 * *((unsigned int *)v9 + 9)), *(const void **)(v29 + 8 * v46), 4 * v31);
                vDSP_vclr((float *)(*(void *)(*((void *)v9 + 58) + 24 * v47) + 4 * *((unsigned int *)v9 + 9)), 1, v31);
                ++v46;
                v47 += 2;
                size_t v29 = (size_t)v103;
              }
              while (v46 < *((unsigned int *)v9 + 6));
            }
          }
          if (*((_DWORD *)v9 + 5))
          {
            IR::FFTFilterTranspose::Implementation::firFilterMultipleInput(v9, (float *const *)v102, v31, v94);
            unint64_t v50 = *((unsigned int *)v9 + 6);
            goto LABEL_86;
          }
LABEL_81:
          if (!*((_DWORD *)v9 + 6))
          {
            LOBYTE(v50) = 1;
            goto LABEL_92;
          }
          unint64_t v51 = 0;
          do
          {
            vDSP_Length v52 = *(float **)(v102 + 8 * v51);
            vDSP_vclr(v52, 1, v31);
            if (v31) {
              *vDSP_Length v52 = 0.00000011921;
            }
            ++v51;
            unint64_t v50 = *((unsigned int *)v9 + 6);
          }
          while (v51 < v50);
LABEL_86:
          if (v50)
          {
            uint64_t v53 = (void *)v102;
            size_t v29 = (size_t)v103;
            uint64_t v54 = v103;
            do
            {
              *v54++ += 4 * v31;
              *v53++ += 4 * v31;
              --v50;
            }
            while (v50);
          }
          else
          {
            LOBYTE(v50) = 1;
            size_t v29 = (size_t)v103;
          }
LABEL_92:
          unsigned int v55 = *((_DWORD *)v9 + 9) + v31;
          *((_DWORD *)v9 + 9) = v55;
          if (v55 >= *((_DWORD *)v9 + 3))
          {
            if (*((unsigned char *)v9 + 46))
            {
              if (*((unsigned char *)v9 + 460) && !*((unsigned char *)v9 + 461))
              {
                if ((v50 & 1) == 0)
                {
                  uint64_t v70 = 0;
                  uint64_t v71 = 0;
                  unint64_t v72 = 0;
                  do
                  {
                    IR::FFTFilterTranspose::Implementation::forwardTransform(v9, *(DSPSplitComplex **)(*((void *)v9 + 26) + v71), *(DSPComplex **)(*((void *)v9 + 61) + v71));
                    (*(void (**)(IR::FFTFilterTranspose::Implementation *, void, const DSPSplitComplex *, void, float))(*(void *)v9 + 112))(v9, *(void *)(*((void *)v9 + 26) + v71), v96, *((unsigned int *)v9 + 3), 0.5);
                    (*(void (**)(IR::FFTFilterTranspose::Implementation *, void, const DSPSplitComplex *, void, float))(*(void *)v9 + 112))(v9, *(void *)(*((void *)v9 + 26) + v71), v95, *((unsigned int *)v9 + 3), -0.5);
                    uint64_t v73 = **((void **)v9 + 18);
                    uint64_t v74 = **((void **)v9 + 19);
                    FFTBufferVec = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec(v100, v72);
                    IR::FFTFilterTranspose::Implementation::dualFFTBlockConvolution((uint64_t)v9, v96, v95, (IR::FFTFilterKernel *)(v73 + v70), (IR::FFTFilterKernel *)(v74 + v70), FFTBufferVec, CircularIndex);
                    ++v72;
                    v71 += 24;
                    v70 += 40;
                  }
                  while (v72 < *((unsigned int *)v9 + 6));
                }
                if (!*((_DWORD *)v9 + 10) && !*((_DWORD *)v9 + 5)) {
                  *((_DWORD *)v9 + 114) -= *((_DWORD *)v9 + 3);
                }
                *((unsigned char *)v9 + 461) = 1;
              }
              else if ((v50 & 1) == 0)
              {
                uint64_t v56 = 0;
                uint64_t v57 = 0;
                unint64_t v58 = 0;
                do
                {
                  IR::FFTFilterTranspose::Implementation::forwardTransform(v9, *(DSPSplitComplex **)(*((void *)v9 + 26) + v57), *(DSPComplex **)(*((void *)v9 + 61) + v57));
                  unsigned int v59 = *(const DSPSplitComplex **)(*((void *)v9 + 26) + v57);
                  uint64_t v60 = **((void **)v9 + 19);
                  unsigned int v61 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec(v100, v58);
                  IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v9, v59, (IR::FFTFilterKernel *)(v60 + v56), v61, CircularIndex);
                  ++v58;
                  v57 += 24;
                  v56 += 40;
                }
                while (v58 < *((unsigned int *)v9 + 6));
              }
            }
            else if (*((unsigned char *)v9 + 460))
            {
              if ((v50 & 1) == 0)
              {
                uint64_t v62 = 0;
                unint64_t v63 = 0;
                unsigned int v64 = 1;
                do
                {
                  IR::FFTFilterTranspose::Implementation::forwardTransform(v9, *(DSPSplitComplex **)(*((void *)v9 + 26) + 24 * (v64 - 1)), *(DSPComplex **)(*((void *)v9 + 58) + 24 * (v64 - 1)));
                  IR::FFTFilterTranspose::Implementation::forwardTransform(v9, *(DSPSplitComplex **)(*((void *)v9 + 26) + 24 * v64), *(DSPComplex **)(*((void *)v9 + 58) + 24 * v64));
                  v65 = *(const DSPSplitComplex **)(*((void *)v9 + 26) + 24 * v64);
                  uint64_t v66 = *(const DSPSplitComplex **)(*((void *)v9 + 26) + 24 * (v64 - 1));
                  uint64_t v67 = **((void **)v9 + 18);
                  uint64_t v68 = **((void **)v9 + 19);
                  v69 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec(v100, v63);
                  IR::FFTFilterTranspose::Implementation::dualFFTBlockConvolution((uint64_t)v9, v65, v66, (IR::FFTFilterKernel *)(v67 + v62), (IR::FFTFilterKernel *)(v68 + v62), v69, CircularIndex);
                  ++v63;
                  v62 += 40;
                  v64 += 2;
                }
                while (v63 < *((unsigned int *)v9 + 6));
              }
              if (!*((_DWORD *)v9 + 10) && !*((_DWORD *)v9 + 5)) {
                *((_DWORD *)v9 + 114) -= *((_DWORD *)v9 + 3);
              }
            }
            else if ((v50 & 1) == 0)
            {
              uint64_t v76 = 0;
              int v77 = 0;
              unint64_t v78 = 0;
              do
              {
                IR::FFTFilterTranspose::Implementation::forwardTransform(v9, *(DSPSplitComplex **)(*((void *)v9 + 26) + 24 * (v77 & 0xFFFFFFFE)), *(DSPComplex **)(*((void *)v9 + 58) + 24 * (v77 & 0xFFFFFFFE)));
                v79 = *(const DSPSplitComplex **)(*((void *)v9 + 26) + 24 * (v77 & 0xFFFFFFFE));
                uint64_t v80 = **((void **)v9 + 19);
                v81 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec(v100, v78);
                IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v9, v79, (IR::FFTFilterKernel *)(v80 + v76), v81, CircularIndex);
                ++v78;
                v77 += 2;
                v76 += 40;
              }
              while (v78 < *((unsigned int *)v9 + 6));
            }
            int NumFFTBuffers = IR::ComplexDataCircBuffer::getNumFFTBuffers((IR::ComplexDataCircBuffer *)v100);
            unsigned int v83 = CircularIndex + 1;
            if (CircularIndex + 1 == NumFFTBuffers) {
              unsigned int v83 = 0;
            }
            unsigned int CircularIndex = v83;
            *((_DWORD *)v9 + 9) = 0;
            if (*((unsigned char *)v9 + 460))
            {
              size_t v29 = (size_t)v103;
              if (*((_DWORD *)v9 + 10) || *((int *)v9 + 114) > 0) {
                goto LABEL_124;
              }
              *((unsigned char *)v9 + 460) = 0;
              caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(*((void *)v9 + 18) + 24));
            }
            size_t v29 = (size_t)v103;
          }
LABEL_124:
          uint64_t v28 = (v99 - v31);
          if (!v28) {
            return 0;
          }
        }
      }
      if (*((unsigned char *)v9 + 47))
      {
        uint64_t v23 = *((void *)v9 + 20);
        if (v23 != *((void *)v9 + 19) && !*((unsigned char *)v9 + 460))
        {
          uint64_t v106 = v23 + 24;
          int v24 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v23 + 24));
          char v107 = v24;
          LODWORD(v7) = v99;
          if (v24)
          {
            uint64_t v25 = *((void *)v9 + 19);
            uint64_t v26 = *((void *)v9 + 20);
            if (v26 != v25)
            {
              *((void *)v9 + 18) = v25;
              *((void *)v9 + 19) = v26;
              uint64_t v106 = 0;
              char v107 = 0;
              int v27 = *((_DWORD *)v9 + 8);
              if (v27)
              {
                *((_DWORD *)v9 + 10) = v27;
                *((_DWORD *)v9 + 146) ^= 1u;
              }
              else
              {
                caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v25 + 24));
              }
            }
          }
          std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v106);
        }
      }
      unsigned int v84 = *((_DWORD *)v9 + 10);
      if (v84)
      {
        float v85 = (float)*((unsigned int *)v9 + 8);
        *(float *)&uint64_t v106 = -1.0 / v85;
        float __Step = -(float)(-1.0 / v85);
        if (v84 >= v7) {
          vDSP_Length v86 = v7;
        }
        else {
          vDSP_Length v86 = v84;
        }
        if (*((_DWORD *)v9 + 6))
        {
          unint64_t v87 = 0;
          float v88 = (float)v84 / v85;
          unint64_t v102 = (v7 - v86);
          v103 = (void *)(4 * v102);
          unsigned int v89 = 1;
          do
          {
            v90 = a2[v87];
            float __Start = 1.0 - v88;
            vDSP_vrampmul(v90, 1, &__Start, &__Step, *(float **)(*((void *)v9 + 58) + 24 * (v89 - 1)), 1, v86);
            if (v84 < v99) {
              memcpy((void *)(*(void *)(*((void *)v9 + 58) + 24 * (v89 - 1)) + 4 * v86), &a2[v87][v86], (size_t)v103);
            }
            float __Start = v88;
            vDSP_vrampmul(a2[v87], 1, &__Start, (const float *)&v106, *(float **)(*((void *)v9 + 58) + 24 * v89), 1, v86);
            if (v84 < v99) {
              vDSP_vclr((float *)(*(void *)(*((void *)v9 + 58) + 24 * v89) + 4 * v86), 1, v102);
            }
            ++v87;
            v89 += 2;
          }
          while (v87 < *((unsigned int *)v9 + 6));
          unsigned int v84 = *((_DWORD *)v9 + 10);
        }
        *((_DWORD *)v9 + 10) = v84 - v86;
        if (v84 == v86)
        {
          if (*((unsigned char *)v9 + 462)) {
            LODWORD(v86) = *((_DWORD *)v9 + 5) + v86;
          }
          *((_DWORD *)v9 + 114) = v86;
        }
        *((unsigned char *)v9 + 460) = 1;
      }
      else if (*((_DWORD *)v9 + 6))
      {
        unint64_t v91 = 0;
        unsigned int v92 = 1;
        do
        {
          memcpy(*(void **)(*((void *)v9 + 58) + 24 * (v92 - 1)), a2[v91], 4 * v99);
          vDSP_vclr(*(float **)(*((void *)v9 + 58) + 24 * v92), 1, v99);
          ++v91;
          v92 += 2;
        }
        while (v91 < *((unsigned int *)v9 + 6));
      }
      IR::FFTFilterTranspose::Implementation::firFilterMultipleInput(v9, a3, v99, v94);
      if (*((unsigned char *)v9 + 460) && !*((_DWORD *)v9 + 10) && *((int *)v9 + 114) <= 0)
      {
        *((unsigned char *)v9 + 460) = 0;
        caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(*((void *)v9 + 18) + 24));
      }
      return 0;
    }
    return 4294956429;
  }
  return 0;
}

void sub_21B4E1908(_Unwind_Exception *a1)
{
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100](v1 - 144);
  _Unwind_Resume(a1);
}

uint64_t IR::FFTFilterTranspose::Implementation::process(IR::FFTFilterTranspose::Implementation *this, const float *__I, float *const *a3, unsigned int a4, unsigned int a5, IR::ComplexDataCircBuffer *a6)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 45)) {
    return 4294956429;
  }
  unsigned int v6 = a4;
  if (a4)
  {
    if (!a5) {
      return 4294967246;
    }
    uint64_t v8 = this;
    if (*((_DWORD *)this + 6) != a5) {
      return 4294967246;
    }
    if (*((_DWORD *)this + 2))
    {
      if (*((unsigned char *)this + 44))
      {
        if (caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(*((void *)this + 20) + 24))) {
          *((void *)v8 + 19) = *((void *)v8 + 20);
        }
        uint64_t v87 = 0;
        char v88 = 0;
        *((unsigned char *)v8 + 44) = 0;
        this = (IR::FFTFilterTranspose::Implementation *)std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v87);
      }
      if (*((_DWORD *)v8 + 4))
      {
        unsigned int v80 = a5;
        uint64_t v79 = (uint64_t)&v79;
        MEMORY[0x270FA5388](this);
        uint64_t v13 = (char *)&v79 - ((v12 + 15) & 0xFFFFFFFF0);
        if (v12 >= 0x200) {
          size_t v14 = 512;
        }
        else {
          size_t v14 = v12;
        }
        bzero((char *)&v79 - ((v12 + 15) & 0xFFFFFFFF0), v14);
        uint64_t v15 = *((unsigned int *)v8 + 6);
        if (v15) {
          memcpy(v13, a3, 8 * v15);
        }
        unsigned int v84 = (float *const *)v13;
        if (!a6
          || IR::ComplexDataCircBuffer::getNumOutputChannels(a6) != *((_DWORD *)v8 + 6)
          || IR::ComplexDataCircBuffer::getNumFFTBuffers(a6) < *((_DWORD *)v8 + 4))
        {
          return 4294967246;
        }
        unsigned int CircularIndex = IR::ComplexDataCircBuffer::getCircularIndex(a6);
        *((_DWORD *)v8 + 9) = IR::ComplexDataCircBuffer::getFFTProcPos(a6);
        v81 = (const DSPSplitComplex *)((char *)v8 + 296);
        v82 = (const DSPSplitComplex *)((char *)v8 + 280);
        while (1)
        {
          uint64_t v23 = *((unsigned int *)v8 + 9);
          unsigned int v24 = *((_DWORD *)v8 + 3) - v23;
          if (v24 >= v6) {
            vDSP_Length v25 = v6;
          }
          else {
            vDSP_Length v25 = v24;
          }
          if (*((unsigned char *)v8 + 46)) {
            memcpy((void *)(**((void **)v8 + 61) + 4 * v23), __I, 4 * v25);
          }
          int v26 = *((unsigned __int8 *)v8 + 47);
          unsigned int v83 = __I;
          if (v26)
          {
            uint64_t v27 = *((void *)v8 + 20);
            if (v27 != *((void *)v8 + 19) && !*((unsigned char *)v8 + 460) && !*((_DWORD *)v8 + 9))
            {
              uint64_t v87 = v27 + 24;
              int v28 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v27 + 24));
              char v88 = v28;
              __I = v83;
              if (v28)
              {
                uint64_t v29 = *((void *)v8 + 19);
                uint64_t v30 = *((void *)v8 + 20);
                if (v30 != v29)
                {
                  *((void *)v8 + 18) = v29;
                  *((void *)v8 + 19) = v30;
                  uint64_t v87 = 0;
                  char v88 = 0;
                  int v31 = *((_DWORD *)v8 + 8);
                  if (v31)
                  {
                    *((_DWORD *)v8 + 10) = v31;
                    *((_DWORD *)v8 + 146) ^= 1u;
                  }
                  else
                  {
                    caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v29 + 24));
                  }
                }
              }
              std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v87);
            }
          }
          unsigned int v32 = *((_DWORD *)v8 + 10);
          if (v32)
          {
            if (v25 >= v32) {
              vDSP_Length v33 = v32;
            }
            else {
              vDSP_Length v33 = v25;
            }
            if (*((_DWORD *)v8 + 5) || !*((unsigned char *)v8 + 46))
            {
              float v34 = (float)*((unsigned int *)v8 + 8);
              float v35 = (float)v32 / v34;
              float __Step = -(float)(-1.0 / v34);
              *(float *)&uint64_t v87 = -1.0 / v34;
              float __Start = 1.0 - v35;
              vDSP_vrampmul(__I, 1, &__Start, &__Step, (float *)(**((void **)v8 + 58) + 4 * *((unsigned int *)v8 + 9)), 1, v33);
              if (v25 <= v32)
              {
                float __Start = v35;
                vDSP_vrampmul(v83, 1, &__Start, (const float *)&v87, (float *)(*(void *)(*((void *)v8 + 58) + 24) + 4 * *((unsigned int *)v8 + 9)), 1, v33);
              }
              else
              {
                uint64_t v36 = v83;
                memcpy((void *)(**((void **)v8 + 58) + 4 * *((unsigned int *)v8 + 9) + 4 * v33), &v83[v33], 4 * (v25 - v33));
                float __Start = v35;
                vDSP_vrampmul(v36, 1, &__Start, (const float *)&v87, (float *)(*(void *)(*((void *)v8 + 58) + 24) + 4 * *((unsigned int *)v8 + 9)), 1, v33);
                vDSP_vclr((float *)(*(void *)(*((void *)v8 + 58) + 24) + 4 * *((unsigned int *)v8 + 9) + 4 * v33), 1, (v25 - v33));
              }
              unsigned int v32 = *((_DWORD *)v8 + 10);
              __I = v83;
            }
            *((_DWORD *)v8 + 10) = v32 - v33;
            if (v32 == v33)
            {
              int v37 = v25;
              if (*((unsigned char *)v8 + 462))
              {
                unsigned int v38 = *((_DWORD *)v8 + 3);
                if (v38 >= *((_DWORD *)v8 + 5)) {
                  unsigned int v38 = *((_DWORD *)v8 + 5);
                }
                int v37 = v38 + v33;
              }
              *((_DWORD *)v8 + 114) = v37;
              *((unsigned char *)v8 + 461) = 0;
            }
            *((unsigned char *)v8 + 460) = 1;
          }
          else
          {
            if (!*((_DWORD *)v8 + 5) && *((unsigned char *)v8 + 46)) {
              goto LABEL_66;
            }
            memcpy((void *)(**((void **)v8 + 58) + 4 * *((unsigned int *)v8 + 9)), __I, 4 * v25);
            vDSP_vclr((float *)(*(void *)(*((void *)v8 + 58) + 24) + 4 * *((unsigned int *)v8 + 9)), 1, v25);
            __I = v83;
          }
          if (*((_DWORD *)v8 + 5))
          {
            IR::FFTFilterTranspose::Implementation::firFilterSingleInput(v8, v84, v25, v80);
            unint64_t v39 = *((unsigned int *)v8 + 6);
            goto LABEL_69;
          }
LABEL_66:
          if (*((_DWORD *)v8 + 6))
          {
            unint64_t v40 = 0;
            do
            {
              vDSP_vclr(v84[v40++], 1, v25);
              unint64_t v39 = *((unsigned int *)v8 + 6);
            }
            while (v40 < v39);
LABEL_69:
            __I = &v83[v25];
            if (v39)
            {
              float v41 = v84;
              do
              {
                *v41++ += v25;
                --v39;
              }
              while (v39);
            }
            goto LABEL_74;
          }
          __I += v25;
LABEL_74:
          unsigned int v42 = *((_DWORD *)v8 + 9) + v25;
          *((_DWORD *)v8 + 9) = v42;
          if (v42 >= *((_DWORD *)v8 + 3))
          {
            if (*((unsigned char *)v8 + 46))
            {
              if (*((unsigned char *)v8 + 460) && !*((unsigned char *)v8 + 461))
              {
                IR::FFTFilterTranspose::Implementation::forwardTransform(v8, **((DSPSplitComplex ***)v8 + 26), **((DSPComplex ***)v8 + 61));
                (*(void (**)(IR::FFTFilterTranspose::Implementation *, void, const DSPSplitComplex *, void, float))(*(void *)v8 + 112))(v8, **((void **)v8 + 26), v82, *((unsigned int *)v8 + 3), 0.5);
                if (*((_DWORD *)v8 + 6))
                {
                  uint64_t v59 = 0;
                  unint64_t v60 = 0;
                  do
                  {
                    uint64_t v61 = **((void **)v8 + 18);
                    FFTBufferVec = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec((IR::ComplexDataCircBuffer::Implementation **)a6, v60);
                    IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v8, v82, (IR::FFTFilterKernel *)(v61 + v59), FFTBufferVec, CircularIndex);
                    ++v60;
                    v59 += 40;
                  }
                  while (v60 < *((unsigned int *)v8 + 6));
                }
                (*(void (**)(IR::FFTFilterTranspose::Implementation *, void, const DSPSplitComplex *, void, float))(*(void *)v8 + 112))(v8, **((void **)v8 + 26), v81, *((unsigned int *)v8 + 3), -0.5);
                if (*((_DWORD *)v8 + 6))
                {
                  uint64_t v63 = 0;
                  unint64_t v64 = 0;
                  do
                  {
                    uint64_t v65 = **((void **)v8 + 19);
                    uint64_t v66 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec((IR::ComplexDataCircBuffer::Implementation **)a6, v64);
                    IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v8, v81, (IR::FFTFilterKernel *)(v65 + v63), v66, CircularIndex);
                    ++v64;
                    v63 += 40;
                  }
                  while (v64 < *((unsigned int *)v8 + 6));
                }
                if (!*((_DWORD *)v8 + 10) && !*((_DWORD *)v8 + 5)) {
                  *((_DWORD *)v8 + 114) -= *((_DWORD *)v8 + 3);
                }
                *((unsigned char *)v8 + 461) = 1;
              }
              else
              {
                IR::FFTFilterTranspose::Implementation::forwardTransform(v8, **((DSPSplitComplex ***)v8 + 26), **((DSPComplex ***)v8 + 61));
                if (*((_DWORD *)v8 + 6))
                {
                  uint64_t v43 = 0;
                  unint64_t v44 = 0;
                  do
                  {
                    uint64_t v45 = (const DSPSplitComplex *)**((void **)v8 + 26);
                    uint64_t v46 = **((void **)v8 + 19);
                    unsigned int v47 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec((IR::ComplexDataCircBuffer::Implementation **)a6, v44);
                    IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v8, v45, (IR::FFTFilterKernel *)(v46 + v43), v47, CircularIndex);
                    ++v44;
                    v43 += 40;
                  }
                  while (v44 < *((unsigned int *)v8 + 6));
                }
              }
            }
            else
            {
              int v48 = (DSPSplitComplex **)*((void *)v8 + 26);
              if (*((unsigned char *)v8 + 460))
              {
                IR::FFTFilterTranspose::Implementation::forwardTransform(v8, v48[3], *(DSPComplex **)(*((void *)v8 + 58) + 24));
                if (*((_DWORD *)v8 + 6))
                {
                  uint64_t v49 = 0;
                  unint64_t v50 = 0;
                  do
                  {
                    unint64_t v51 = *(const DSPSplitComplex **)(*((void *)v8 + 26) + 24);
                    uint64_t v52 = **((void **)v8 + 18);
                    uint64_t v53 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec((IR::ComplexDataCircBuffer::Implementation **)a6, v50);
                    IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v8, v51, (IR::FFTFilterKernel *)(v52 + v49), v53, CircularIndex);
                    ++v50;
                    v49 += 40;
                  }
                  while (v50 < *((unsigned int *)v8 + 6));
                }
                IR::FFTFilterTranspose::Implementation::forwardTransform(v8, **((DSPSplitComplex ***)v8 + 26), **((DSPComplex ***)v8 + 58));
                if (*((_DWORD *)v8 + 6))
                {
                  uint64_t v54 = 0;
                  unint64_t v55 = 0;
                  do
                  {
                    uint64_t v56 = (const DSPSplitComplex *)**((void **)v8 + 26);
                    uint64_t v57 = **((void **)v8 + 19);
                    unint64_t v58 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec((IR::ComplexDataCircBuffer::Implementation **)a6, v55);
                    IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v8, v56, (IR::FFTFilterKernel *)(v57 + v54), v58, CircularIndex);
                    ++v55;
                    v54 += 40;
                  }
                  while (v55 < *((unsigned int *)v8 + 6));
                }
                if (!*((_DWORD *)v8 + 10) && !*((_DWORD *)v8 + 5)) {
                  *((_DWORD *)v8 + 114) -= *((_DWORD *)v8 + 3);
                }
              }
              else
              {
                IR::FFTFilterTranspose::Implementation::forwardTransform(v8, *v48, **((DSPComplex ***)v8 + 58));
                if (*((_DWORD *)v8 + 6))
                {
                  uint64_t v67 = 0;
                  unint64_t v68 = 0;
                  do
                  {
                    v69 = (const DSPSplitComplex *)**((void **)v8 + 26);
                    uint64_t v70 = **((void **)v8 + 19);
                    uint64_t v71 = (uint64_t *)IR::ComplexDataCircBuffer::getFFTBufferVec((IR::ComplexDataCircBuffer::Implementation **)a6, v68);
                    IR::FFTFilterTranspose::Implementation::fftBlockConvolution((uint64_t)v8, v69, (IR::FFTFilterKernel *)(v70 + v67), v71, CircularIndex);
                    ++v68;
                    v67 += 40;
                  }
                  while (v68 < *((unsigned int *)v8 + 6));
                }
              }
            }
            if (CircularIndex + 1 == IR::ComplexDataCircBuffer::getNumFFTBuffers(a6)) {
              unsigned int CircularIndex = 0;
            }
            else {
              ++CircularIndex;
            }
            *((_DWORD *)v8 + 9) = 0;
            if (*((unsigned char *)v8 + 460) && !*((_DWORD *)v8 + 10) && *((int *)v8 + 114) <= 0)
            {
              *((unsigned char *)v8 + 460) = 0;
              caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(*((void *)v8 + 18) + 24));
            }
          }
          v6 -= v25;
          if (!v6) {
            return 0;
          }
        }
      }
      if (*((unsigned char *)v8 + 47))
      {
        uint64_t v17 = *((void *)v8 + 20);
        if (v17 != *((void *)v8 + 19) && !*((unsigned char *)v8 + 460))
        {
          uint64_t v87 = v17 + 24;
          int v18 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v17 + 24));
          char v88 = v18;
          if (v18)
          {
            uint64_t v19 = *((void *)v8 + 19);
            uint64_t v20 = *((void *)v8 + 20);
            if (v20 != v19)
            {
              *((void *)v8 + 18) = v19;
              *((void *)v8 + 19) = v20;
              uint64_t v87 = 0;
              char v88 = 0;
              int v21 = *((_DWORD *)v8 + 8);
              if (v21)
              {
                *((_DWORD *)v8 + 10) = v21;
                *((_DWORD *)v8 + 146) ^= 1u;
              }
              else
              {
                caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v19 + 24));
              }
            }
          }
          std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v87);
        }
      }
      unsigned int v72 = a5;
      unsigned int v73 = *((_DWORD *)v8 + 10);
      if (v73)
      {
        float v74 = (float)*((unsigned int *)v8 + 8);
        float v75 = (float)v73 / v74;
        float __Step = -(float)(-1.0 / v74);
        *(float *)&uint64_t v87 = -1.0 / v74;
        if (v73 >= v6) {
          vDSP_Length v76 = v6;
        }
        else {
          vDSP_Length v76 = v73;
        }
        float __Start = 1.0 - v75;
        vDSP_vrampmul(__I, 1, &__Start, &__Step, **((float ***)v8 + 58), 1, v76);
        if (v73 >= v6)
        {
          float __Start = v75;
          vDSP_vrampmul(__I, 1, &__Start, (const float *)&v87, *(float **)(*((void *)v8 + 58) + 24), 1, v76);
        }
        else
        {
          memcpy((void *)(**((void **)v8 + 58) + 4 * v76), &__I[v76], 4 * (v6 - v76));
          float __Start = v75;
          vDSP_vrampmul(__I, 1, &__Start, (const float *)&v87, *(float **)(*((void *)v8 + 58) + 24), 1, v76);
          vDSP_vclr((float *)(*(void *)(*((void *)v8 + 58) + 24) + 4 * v76), 1, v6 - v76);
        }
        int v78 = *((_DWORD *)v8 + 10) - v76;
        *((_DWORD *)v8 + 10) = v78;
        unsigned int v77 = v72;
        if (!v78)
        {
          if (*((unsigned char *)v8 + 462)) {
            LODWORD(v76) = *((_DWORD *)v8 + 5) + v76;
          }
          *((_DWORD *)v8 + 114) = v76;
        }
        *((unsigned char *)v8 + 460) = 1;
      }
      else
      {
        memcpy(**((void ***)v8 + 58), __I, 4 * v6);
        vDSP_vclr(*(float **)(*((void *)v8 + 58) + 24), 1, v6);
        unsigned int v77 = v72;
      }
      IR::FFTFilterTranspose::Implementation::firFilterSingleInput(v8, a3, v6, v77);
      if (*((unsigned char *)v8 + 460) && !*((_DWORD *)v8 + 10) && *((int *)v8 + 114) <= 0)
      {
        *((unsigned char *)v8 + 460) = 0;
        caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(*((void *)v8 + 18) + 24));
      }
      return 0;
    }
    return 4294956429;
  }
  return 0;
}

void sub_21B4E23E0(_Unwind_Exception *a1)
{
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100](v1 - 136);
  _Unwind_Resume(a1);
}

void IR::FFTFilterTranspose::FFTFilterTranspose(IR::FFTFilterTranspose *this)
{
}

void sub_21B4E24C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = a10;
  a10 = 0;
  if (v11) {
    IR::FFTFilterTranspose::FFTFilterTranspose(v11);
  }
  IR::FFTFilterTranspose::FFTFilterTranspose(&a9);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<IR::FFTFilterTranspose::Implementation>()
{
}

void sub_21B4E262C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v12 + 48);
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (; v11; v11 -= 32)
  {
    a10 = (void **)(v10 + 16 + v11);
    std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a10);
  }
  MEMORY[0x21D48F780](v10, 0x10A1C403E12D718);
  _Unwind_Resume(a1);
}

void IR::FFTFilterTranspose::~FFTFilterTranspose(IR::FFTFilterTranspose *this)
{
  IR::FFTFilter::~FFTFilter(this);

  JUMPOUT(0x21D48F780);
}

void IR::FFTFilterTranspose::Implementation::~Implementation(IR::FFTFilterTranspose::Implementation *this)
{
  IR::FFTFilterTranspose::Implementation::~Implementation(this);

  JUMPOUT(0x21D48F780);
}

{
  void *v2;
  void **v3;

  *(void *)this = &unk_26CB56F38;
  unint64_t v2 = (void *)*((void *)this + 70);
  if (v2)
  {
    *((void *)this + 71) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)((char *)this + 536);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 512);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 488);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 464);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  IR::FFTFilter::Implementation::~Implementation(this);
}

__n128 IR::FFTFilter::Implementation::getConfigParams@<Q0>(IR::FFTFilter::Implementation *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = *(_OWORD *)((char *)this + 8);
  __n128 result = *(__n128 *)((char *)this + 20);
  *(__n128 *)(a2 + 12) = result;
  return result;
}

void std::vector<std::vector<float>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    vDSP_Length v16 = &v12[24 * v8];
    int v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_21B4E2868(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<float>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<float>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    long long v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      long long v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      long long v14 = 0;
    }
    uint64_t v15 = &v14[4 * v11];
    vDSP_Length v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    uint64_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

void std::vector<std::vector<DSPSplitComplex>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    vDSP_Length v16 = &v12[24 * v8];
    int v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    std::vector<std::vector<DSPSplitComplex>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_21B4E2DB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<DSPSplitComplex>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<DSPSplitComplex>>,std::reverse_iterator<std::vector<DSPSplitComplex>*>,std::reverse_iterator<std::vector<DSPSplitComplex>*>,std::reverse_iterator<std::vector<DSPSplitComplex>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<DSPSplitComplex>>,std::reverse_iterator<std::vector<DSPSplitComplex>*>,std::reverse_iterator<std::vector<DSPSplitComplex>*>,std::reverse_iterator<std::vector<DSPSplitComplex>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<DSPSplitComplex>>,std::reverse_iterator<std::vector<DSPSplitComplex>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<DSPSplitComplex>>,std::reverse_iterator<std::vector<DSPSplitComplex>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::vector<float>::__append(void **a1, unint64_t a2, _DWORD *a3)
{
  long long v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 2)
  {
    if (a2)
    {
      uint64_t v16 = 4 * a2;
      uint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4;
      }
      while (v16);
      uint64_t v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 2);
    if (v11 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v10 >> 2;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 1 > v11) {
      unint64_t v11 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v6, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    int v18 = &v15[4 * v12];
    uint64_t v19 = &v18[4 * a2];
    uint64_t v20 = 4 * a2;
    int v21 = v18;
    do
    {
      *(_DWORD *)int v21 = *a3;
      v21 += 4;
      v20 -= 4;
    }
    while (v20);
    float v22 = &v15[4 * v14];
    uint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 4)
    {
      int v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void std::vector<DSPSplitComplex>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DSPSplitComplex>>(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[16 * v10];
    uint64_t v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    int v18 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<DSPSplitComplex>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

uint64_t std::vector<IR::FFTFilterKernel>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 40 * a2;
      uint64_t v14 = 40 * a2;
      do
      {
        uint64_t result = IR::FFTFilterKernel::FFTFilterKernel(v7);
        v7 += 40;
        v14 -= 40;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v22 = result;
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FFTFilterKernel>>(result, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v15 = (uint64_t)&v12[40 * v8];
    v19[0] = v12;
    v19[1] = v15;
    uint64_t v20 = v15;
    int v21 = &v12[40 * v11];
    uint64_t v16 = 5 * a2;
    unint64_t v17 = v15 + 40 * a2;
    uint64_t v18 = 8 * v16;
    do
    {
      IR::FFTFilterKernel::FFTFilterKernel(v15);
      v15 += 40;
      v18 -= 40;
    }
    while (v18);
    uint64_t v20 = v17;
    std::vector<IR::FFTFilterKernel>::__swap_out_circular_buffer(a1, v19);
    return std::__split_buffer<IR::FFTFilterKernel>::~__split_buffer((uint64_t)v19);
  }
  return result;
}

void sub_21B4E32E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<IR::FFTFilterKernel>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<IR::FFTFilterKernel>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IR::FFTFilterKernel>,std::reverse_iterator<IR::FFTFilterKernel*>,std::reverse_iterator<IR::FFTFilterKernel*>,std::reverse_iterator<IR::FFTFilterKernel*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FFTFilterKernel>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IR::FFTFilterKernel>,std::reverse_iterator<IR::FFTFilterKernel*>,std::reverse_iterator<IR::FFTFilterKernel*>,std::reverse_iterator<IR::FFTFilterKernel*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 40;
  while (a3 + v10 != a5)
  {
    unint64_t v12 = (IR::FFTFilterKernel *)(v11 + v10);
    v10 -= 40;
    IR::FFTFilterKernel::FFTFilterKernel(v12, (const IR::FFTFilterKernel *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<IR::FFTFilterKernel>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    IR::FFTFilterKernel::~FFTFilterKernel((IR::FFTFilterKernel *)(i - 40));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::vector<float>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void IR::FFTFilter::Implementation::~Implementation(IR::FFTFilter::Implementation *this)
{
  *(void *)this = &unk_26CB56FE8;
  uint64_t v2 = (void *)*((void *)this + 54);
  if (v2)
  {
    *((void *)this + 55) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 51);
  if (v3)
  {
    *((void *)this + 52) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 48);
  if (v4)
  {
    *((void *)this + 49) = v4;
    operator delete(v4);
  }
  unint64_t v9 = (void **)((char *)this + 360);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
  unint64_t v9 = (void **)((char *)this + 336);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
  unint64_t v9 = (void **)((char *)this + 312);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
  uint64_t v5 = (void *)*((void *)this + 30);
  if (v5)
  {
    *((void *)this + 31) = v5;
    operator delete(v5);
  }
  unint64_t v9 = (void **)((char *)this + 208);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
  uint64_t v6 = (void *)*((void *)this + 23);
  if (v6)
  {
    *((void *)this + 24) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  for (uint64_t i = 112; i != 16; i -= 32)
  {
    unint64_t v9 = (void **)((char *)this + i);
    std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&v9);
  }
}

{
  uint64_t vars8;

  IR::FFTFilter::Implementation::~Implementation(this);

  JUMPOUT(0x21D48F780);
}

void std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        IR::FFTFilterKernel::~FFTFilterKernel((IR::FFTFilterKernel *)(v4 - 40));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    caulk::pooled_semaphore_mutex::_unlock(*(caulk::pooled_semaphore_mutex **)a1);
  }
  return a1;
}

uint64_t IR::getIRDataLog(IR *this)
{
  if (IR::getIRDataLog(void)::onceToken != -1) {
    dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
  }
  return IR::getIRDataLog(void)::gLog;
}

os_log_t ___ZN2IR12getIRDataLogEv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreaudio", "IRData");
  IR::getIRDataLog(void)::gLog = (uint64_t)result;
  return result;
}

uint64_t IR::IRData::Implementation::getFileByteSize(FILE **a1)
{
  uint64_t v2 = MEMORY[0x21D48FAE0](*a1);
  fseek(*a1, 0, 2);
  uint64_t v3 = MEMORY[0x21D48FAE0](*a1);
  fseek(*a1, v2, 0);
  return v3;
}

void IR::IRData::Implementation::readIRPlist(FILE **a1@<X0>, _DWORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t FileByteSize = IR::IRData::Implementation::getFileByteSize(a1);
  CFTypeRef v26 = 0;
  *a2 = 0;
  unsigned int __ptr = 0;
  if (fread(&__ptr, 4uLL, 1uLL, *a1) != 1)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v8 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::readIRPlist(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    goto LABEL_11;
  }
  size_t v7 = __ptr;
  if (FileByteSize - 4 < (unint64_t)__ptr)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::readIRPlist();
    }
LABEL_11:
    *a3 = 0;
    return;
  }
  std::vector<unsigned char>::vector(bytes, __ptr);
  size_t v16 = fread(bytes[0], 1uLL, v7, *a1);
  if (v16 == v7)
  {
    CFDataRef v17 = CFDataCreate(0, bytes[0], v7);
    if (!v17)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v22, v17);
    applesauce::CF::make_DictionaryRef(&v22, (applesauce::CF::DictionaryRef *)&v23);
    uint64_t v18 = v23;
    CFTypeRef v26 = v23;
    uint64_t v23 = 0;
    if (v22) {
      CFRelease(v22);
    }
    *a3 = v18;
  }
  else
  {
    int v19 = v16;
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v20 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::readIRPlist(v19, v7, v20);
    }
    *a3 = 0;
  }
  CFTypeRef v26 = 0;
  if (bytes[0])
  {
    bytes[1] = bytes[0];
    operator delete(bytes[0]);
  }
  if (v26) {
    CFRelease(v26);
  }
}

void sub_21B4E3B4C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v11);
  __cxa_begin_catch(a1);
  if (IR::getIRDataLog(void)::onceToken != -1) {
    dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
  }
  uint64_t v13 = IR::getIRDataLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
    IR::IRData::Implementation::readIRPlist(v13, v14, v15, v16, v17, v18, v19, v20);
  }
  *uint64_t v10 = 0;
  __cxa_end_catch();
  JUMPOUT(0x21B4E3A88);
}

void sub_21B4E3BEC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x21B4E3B78);
}

applesauce::CF::DictionaryRef *applesauce::CF::make_DictionaryRef@<X0>(CFDataRef *a1@<X0>, applesauce::CF::DictionaryRef *a2@<X8>)
{
  if (!*a1) {
    goto LABEL_9;
  }
  CFPropertyListRef v3 = CFPropertyListCreateWithData(0, *a1, 0, 0, 0);
  uint64_t v4 = v3;
  if (!v3)
  {
    if (!CFDictionaryGetTypeID()) {
      goto LABEL_6;
    }
LABEL_9:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  CFTypeID v5 = CFGetTypeID(v3);
  if (v5 != CFDictionaryGetTypeID())
  {
    CFRelease(v4);
    goto LABEL_9;
  }
LABEL_6:

  return applesauce::CF::DictionaryRef::DictionaryRef(a2, v4);
}

void sub_21B4E3CA8()
{
}

void sub_21B4E3CD0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void applesauce::CF::DataRef::~DataRef(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void IR::IRData::Implementation::extractIRDataTypePlist(const __CFDictionary **a1@<X0>, int a2@<W1>, _DWORD *a3@<X2>, applesauce::CF::DictionaryRef *a4@<X8>)
{
  CFDictionaryRef v6 = *a1;
  if (!a2 || !v6)
  {
    *(void *)a4 = v6;
    *a1 = 0;
    return;
  }
  CFTypeRef cf = 0;
  uint64_t v20 = @"ImpulseResponses";
  applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>(v6, (const void **)&v20, &cf, &theArray);
  if (cf) {
    CFRelease(cf);
  }
  CFArrayRef v9 = theArray;
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    CFIndex v11 = Count;
    CFArrayRef v12 = theArray;
    if (theArray)
    {
      CFIndex v13 = CFArrayGetCount(theArray);
      if (!v11) {
        goto LABEL_20;
      }
    }
    else
    {
      CFIndex v13 = 0;
      if (!Count) {
        goto LABEL_20;
      }
    }
    unint64_t v14 = 0;
    while (v9 != v12 || v13 != v14)
    {
      applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>(v9, v14, a4);
      CFDictionaryRef v15 = *(const __CFDictionary **)a4;
      if (!*(void *)a4)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](exception, "Could not construct");
      }
      uint64_t v20 = @"Type";
      LODWORD(cf) = 0;
      if (applesauce::CF::at_or<unsigned int,__CFString const*>(v15, (const void **)&v20, (unsigned int *)&cf) == a2)goto LABEL_21; {
      CFDictionaryRef v16 = *(const __CFDictionary **)a4;
      }
      if (!*(void *)a4)
      {
        uint64_t v18 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](v18, "Could not construct");
      }
      uint64_t v20 = @"DataLengthBytes";
      LODWORD(cf) = 0;
      *a3 += applesauce::CF::at_or<unsigned int,__CFString const*>(v16, (const void **)&v20, (unsigned int *)&cf);
      if (*(void *)a4) {
        CFRelease(*(CFTypeRef *)a4);
      }
      if (v11 == ++v14) {
        break;
      }
    }
  }
LABEL_20:
  *(void *)a4 = 0;
LABEL_21:
  if (theArray) {
    CFRelease(theArray);
  }
}

void sub_21B4E3F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  applesauce::CF::DictionaryRef::~DictionaryRef(v12);
  applesauce::CF::ArrayRef::~ArrayRef(&a12);
  _Unwind_Resume(a1);
}

void *applesauce::CF::DictionaryRef::operator->(void *result)
{
  if (!*result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_21B4E3F8C()
{
}

void sub_21B4E3FAC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::readIRPlist(CFTypeRef *a1@<X0>, _DWORD *a2@<X1>, int a3@<W2>, CFTypeRef *a4@<X8>)
{
  CFTypeRef v7 = *a1;
  if (*a1) {
    CFRetain(*a1);
  }
  CFTypeRef cf = v7;
  IR::getFilePtr((const __CFURL **)&cf, 1, v13);
  if (cf) {
    CFRelease(cf);
  }
  if (v13[0])
  {
    IR::IRData::Implementation::readIRPlist(v13, a2, a4);
    CFTypeRef v8 = *a4;
    if (*a4) {
      CFRetain(*a4);
    }
    CFTypeRef v10 = v8;
    IR::IRData::Implementation::extractIRDataTypePlist((const __CFDictionary **)&v10, a3, a2, (applesauce::CF::DictionaryRef *)&v11);
    *a4 = v11;
    CFTypeRef v11 = v8;
    if (v8) {
      CFRelease(v8);
    }
    if (v10) {
      CFRelease(v10);
    }
    CFArrayRef v9 = v13[0];
    v13[0] = 0;
    if (v9) {
      ((void (*)(void))v13[1])();
    }
  }
  else
  {
    *a4 = 0;
  }
}

void sub_21B4E40B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void (*a14)(void))
{
  applesauce::CF::DictionaryRef::~DictionaryRef(&a10);
  applesauce::CF::DictionaryRef::~DictionaryRef(v14);
  uint64_t v16 = a13;
  a13 = 0;
  if (v16) {
    a14();
  }
  _Unwind_Resume(a1);
}

void applesauce::CF::URLRef::~URLRef(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void IR::IRData::Implementation::readIRPlist(IR::IRData::Implementation *this@<X0>, CFTypeRef *a2@<X8>)
{
  int v7 = 0;
  CFTypeRef v5 = *(CFTypeRef *)this;
  if (*(void *)this) {
    CFRetain(*(CFTypeRef *)this);
  }
  CFTypeRef v6 = v5;
  IR::IRData::Implementation::readIRPlist(&v6, &v7, *((_DWORD *)this + 10), a2);
  if (v5) {
    CFRelease(v5);
  }
}

void sub_21B4E41B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void IR::IRData::~IRData(IR::IRData::Implementation **this)
{
}

{
  std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0);
}

uint64_t IR::IRData::Implementation::Implementation(uint64_t a1, int a2, int a3, char a4, int a5, int a6, int a7, uint64_t a8, float a9, float a10, uint64_t a11, uint64_t a12, int a13, const void **a14, const void **a15)
{
  *(float *)a1 = a9;
  *(float *)(a1 + 4) = a9;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = a3;
  *(float *)(a1 + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = a10;
  *(unsigned char *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = a5;
  *(_DWORD *)(a1 + 32) = a6;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = a7;
  *(_DWORD *)(a1 + 76) = a7;
  *(void *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>((void *)(a1 + 80), *(const void **)a8, *(void *)(a8 + 8), (uint64_t)(*(void *)(a8 + 8) - *(void *)a8) >> 2);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)(a1 + 128), *(const void **)a11, *(void *)(a11 + 8), (uint64_t)(*(void *)(a11 + 8) - *(void *)a11) >> 2);
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 20std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>((void *)(a1 + 200), *(const void **)a12, *(void *)(a12 + 8), (uint64_t)(*(void *)(a12 + 8) - *(void *)a12) >> 2);
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)(a1 + 224));
  uint64_t v19 = (const void **)(a1 + 288);
  uint64_t v20 = (const void **)(a1 + 296);
  *(unsigned char *)(a1 + 328) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  IR::IRDataAttributes::IRDataAttributes(a1 + 336, &stru_26CB57E20, a3, a4, a13, a9);
  *(unsigned char *)(a1 + 488) = a13 == 1;
  *(void *)(a1 + 492) = 0;
  *(void *)(a1 + 52std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  int v21 = *a14;
  if (*a14)
  {
    CFDataRef v22 = *v19;
    *uint64_t v19 = v21;
    CFRetain(v21);
    if (v22) {
      CFRelease(v22);
    }
  }
  uint64_t v23 = *a15;
  if (*a15)
  {
    unsigned int v24 = *v20;
    *uint64_t v20 = v23;
    CFRetain(v23);
    if (v24) {
      CFRelease(v24);
    }
  }
  IR::IRData::Implementation::createEmptyIRObject((IR::IRData::Implementation *)a1);
  return a1;
}

void sub_21B4E4400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, void **a11, void **a12)
{
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100](&a12);
  IR::IRDataAttributes::~IRDataAttributes(v18);
  a12 = (void **)(v12 + 304);
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a12);
  applesauce::CF::DictionaryRef::~DictionaryRef(v17);
  applesauce::CF::DictionaryRef::~DictionaryRef(v16);
  applesauce::CF::StringRef::~StringRef((const void **)(v12 + 280));
  uint64_t v20 = *(std::__shared_weak_count **)(v12 + 272);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  int v21 = *v13;
  if (*v13)
  {
    *(void *)(v12 + 208) = v21;
    operator delete(v21);
  }
  CFDataRef v22 = *(void **)(v12 + 176);
  if (v22)
  {
    *(void *)(v12 + 184) = v22;
    operator delete(v22);
  }
  uint64_t v23 = *v15;
  if (*v15)
  {
    *(void *)(v12 + 16std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v23;
    operator delete(v23);
  }
  unsigned int v24 = *a10;
  if (*a10)
  {
    *(void *)(v12 + 136) = v24;
    operator delete(v24);
  }
  int v25 = *v14;
  if (*v14)
  {
    *(void *)(v12 + 112) = v25;
    operator delete(v25);
  }
  CFTypeRef v26 = *a11;
  if (*a11)
  {
    *(void *)(v12 + 88) = v26;
    operator delete(v26);
  }
  uint64_t v27 = *(void **)(v12 + 40);
  if (v27)
  {
    *(void *)(v12 + 48) = v27;
    operator delete(v27);
  }
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, const __CFString *a2, int a3, char a4, int a5, float a6)
{
  CFTypeRef cf = CFURLCreateWithString(0, a2, 0);
  if (!cf)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  IR::IRDataAttributes::IRDataAttributes(a1, (CFURLRef *)&cf, a3, a4, 0, 0, a5, a6);
  if (cf) {
    CFRelease(cf);
  }
  return a1;
}

void sub_21B4E45C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::createEmptyIRObject(IR::IRData::Implementation *this)
{
  uint64_t v2 = operator new(0x30uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = &unk_26CB574D8;
  v2[4] = 0;
  v2[5] = 0;
  CFPropertyListRef v3 = (std::__shared_weak_count *)*((void *)this + 34);
  *((void *)this + 34) = v2;
  v2[3] = 0;
  *((void *)this + 33) = v2 + 3;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  IR::IRData::Implementation::getEmptyIRDataNode((IR::IRData::Implementation *)v3);
  IR::IRCoordinates::reset((IR::IRData::Implementation *)((char *)this + 224));
  if (!*((unsigned char *)this + 488)) {
    goto LABEL_15;
  }
  uint64_t v4 = (_DWORD *)*((void *)this + 10);
  CFTypeRef v5 = (_DWORD *)*((void *)this + 11);
  if (v4 == v5)
  {
LABEL_8:
    *((unsigned char *)this + 488) = 0;
    char v7 = 1;
  }
  else
  {
    CFTypeRef v6 = (_DWORD *)*((void *)this + 10);
    while (*v6)
    {
      if (++v6 == v5) {
        goto LABEL_8;
      }
    }
    char v7 = 0;
  }
  if (v4 == v5)
  {
LABEL_14:
    *((unsigned char *)this + 488) = 0;
LABEL_15:
    std::vector<int>::resize((std::vector<unsigned int> *)((char *)this + 104), *((unsigned int *)this + 7));
    CFArrayRef v9 = (_DWORD *)*((void *)this + 13);
    CFTypeRef v10 = (_DWORD *)*((void *)this + 14);
    if (v9 != v10)
    {
      int v11 = 0;
      do
        *v9++ = v11++;
      while (v9 != v10);
    }
    goto LABEL_18;
  }
  CFTypeRef v8 = v4;
  while (*v8 != 1)
  {
    if (++v8 == v5) {
      goto LABEL_14;
    }
  }
  if (v7) {
    goto LABEL_15;
  }
  unint64_t v15 = 0;
  uint64_t v17 = (void **)((char *)this + 104);
  uint64_t v16 = (char *)*((void *)this + 13);
  *((void *)this + 14) = v16;
  uint64_t v18 = (void *)((char *)this + 120);
  do
  {
    int v19 = v4[v15];
    if (v19)
    {
      if (v19 == 1)
      {
        *((_DWORD *)this + 124) = v15;
      }
      else
      {
        if ((unint64_t)v16 >= *v18)
        {
          int v21 = (char *)*v17;
          uint64_t v22 = (v16 - (unsigned char *)*v17) >> 2;
          unint64_t v23 = v22 + 1;
          if ((unint64_t)(v22 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v24 = *v18 - (void)v21;
          if (v24 >> 1 > v23) {
            unint64_t v23 = v24 >> 1;
          }
          if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v25 = v23;
          }
          if (v25)
          {
            CFTypeRef v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 120, v25);
            int v21 = (char *)*((void *)this + 13);
            uint64_t v16 = (char *)*((void *)this + 14);
          }
          else
          {
            CFTypeRef v26 = 0;
          }
          uint64_t v27 = &v26[4 * v22];
          *(_DWORD *)uint64_t v27 = v15;
          uint64_t v20 = v27 + 4;
          while (v16 != v21)
          {
            int v28 = *((_DWORD *)v16 - 1);
            v16 -= 4;
            *((_DWORD *)v27 - 1) = v28;
            v27 -= 4;
          }
          *((void *)this + 13) = v27;
          *((void *)this + 14) = v20;
          *((void *)this + 15) = &v26[4 * v25];
          if (v21) {
            operator delete(v21);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v16 = v15;
          uint64_t v20 = v16 + 4;
        }
        *((void *)this + 14) = v20;
        uint64_t v16 = v20;
        uint64_t v4 = (_DWORD *)*((void *)this + 10);
        CFTypeRef v5 = (_DWORD *)*((void *)this + 11);
      }
    }
    else
    {
      *((_DWORD *)this + 123) = v15;
    }
    ++v15;
  }
  while (v15 < v5 - v4);
LABEL_18:
  std::vector<int>::resize((std::vector<unsigned int> *)((char *)this + 40), *((unsigned int *)this + 8));
  uint64_t v12 = (_DWORD *)*((void *)this + 5);
  CFIndex v13 = (_DWORD *)*((void *)this + 6);
  if (v12 != v13)
  {
    int v14 = 0;
    do
      *v12++ = v14++;
    while (v12 != v13);
  }
}

int *IR::IRData::Implementation::getEmptyIRDataNode(IR::IRData::Implementation *this)
{
  {
    IR::IRData::Implementation::getEmptyIRDataNode(void)::emptyIRDataNode = 0;
    unk_26AD08FC0 = 0u;
    unk_26AD08FD0 = 0u;
    unk_26AD08FE0 = 0u;
    unk_26AD08FF0 = 0u;
    unk_26AD09000 = 0u;
    qword_26AD09010 = 0;
    __cxa_atexit((void (*)(void *))IR::IRDataNode::~IRDataNode, &IR::IRData::Implementation::getEmptyIRDataNode(void)::emptyIRDataNode, &dword_21B4DD000);
  }
  return &IR::IRData::Implementation::getEmptyIRDataNode(void)::emptyIRDataNode;
}

void std::vector<int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  std::vector<unsigned int>::size_type v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

unint64_t IR::IRData::Implementation::Implementation(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, float a9, const void **a10, uint64_t a11, unsigned int a12, char a13, int a14, int a15, uint64_t *a16)
{
  *(float *)a1 = a9;
  *(float *)(a1 + 4) = a9;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a12;
  *(unsigned char *)(a1 + 24) = a13;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = a6;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = a14;
  *(_DWORD *)(a1 + 76) = a14;
  *(void *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  uint64_t v102 = a1 + 80;
  std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>((void *)(a1 + 80), *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)(a1 + 128), *(const void **)a7, *(void *)(a7 + 8), (uint64_t)(*(void *)(a7 + 8) - *(void *)a7) >> 2);
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 20std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>((void *)(a1 + 200), *(const void **)a8, *(void *)(a8 + 8), (uint64_t)(*(void *)(a8 + 8) - *(void *)a8) >> 2);
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)(a1 + 224));
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  uint64_t v22 = (CFStringRef *)(a1 + 280);
  char v23 = *(unsigned char *)(a11 + 23);
  if (v23 >= 0) {
    uint64_t v24 = (const UInt8 *)a11;
  }
  else {
    uint64_t v24 = *(const UInt8 **)a11;
  }
  if (v24)
  {
    if (v23 >= 0) {
      CFIndex v25 = *(unsigned __int8 *)(a11 + 23);
    }
    else {
      CFIndex v25 = *(void *)(a11 + 8);
    }
    CFStringRef v26 = CFStringCreateWithBytes(0, v24, v25, 0x8000100u, 0);
    *uint64_t v22 = v26;
    if (!v26)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
  }
  else
  {
    *uint64_t v22 = 0;
  }
  v104 = (const void **)(a1 + 296);
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 313) = 0u;
  IR::IRDataAttributes::IRDataAttributes(a1 + 336, &stru_26CB57E20, a12, a13, a15, a9);
  *(unsigned char *)(a1 + 488) = a15 == 1;
  *(void *)(a1 + 492) = 0;
  *(void *)(a1 + 52std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  int v28 = *a10;
  if (*a10)
  {
    uint64_t v29 = *v104;
    *v104 = v28;
    CFRetain(v28);
    if (v29) {
      CFRelease(v29);
    }
  }
  uint64_t v30 = *(void **)a2;
  uint64_t v31 = *(void *)(a2 + 8);
  if (*(void *)a2 == v31) {
    goto LABEL_25;
  }
  unsigned int v32 = *(void **)a3;
  uint64_t v33 = *(void *)(a3 + 8);
  if (*(void *)a3 == v33
    || !a6
    || (v35 = *(const void **)a4, uint64_t v34 = *(void *)(a4 + 8), *(void *)a4 == v34)
    || (uint64_t v36 = *(const void **)a7, v37 = *(void *)(a7 + 8), *(void *)a7 == v37)
    || (unsigned int v38 = *(const void **)a8, v39 = *(void *)(a8 + 8), *(void *)a8 == v39))
  {
LABEL_25:
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v49 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v49, v50, v51, v52, v53, v54, v55, v56);
    }
  }
  else
  {
    unint64_t v40 = (uint64_t)(v30[1] - *v30) >> 2;
    if (v40 % a6)
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      float v41 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation(v41, v42, v43, v44, v45, v46, v47, v48);
      }
      return a1;
    }
    unint64_t v58 = 0xAAAAAAAAAAAAAAABLL * ((v31 - (uint64_t)v30) >> 3);
    *(_DWORD *)(a1 + 64) = v58;
    if (0xAAAAAAAAAAAAAAABLL * ((v33 - (uint64_t)v32) >> 3) == v58
      && (vDSP_Length v59 = (uint64_t)(v32[1] - *v32) >> 2, v59 == ((unint64_t)(v34 - (void)v35) >> 2))
      && v59 == (v37 - (uint64_t)v36) >> 2
      && v59 == (v39 - (uint64_t)v38) >> 2)
    {
      unint64_t v60 = *(void ***)a5;
      uint64_t v61 = *(void *)(a5 + 8);
      if (*(void *)a5 == v61)
      {
        unint64_t v100 = a6;
        unint64_t v101 = (unint64_t)(v34 - (void)v35) >> 2;
        float v63 = 0.0;
LABEL_51:
        *(_DWORD *)(a1 + 8) = v40 / a6;
        *(float *)(a1 + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v63;
        *(_DWORD *)(a1 + 28) = v101;
        if (!*(_DWORD *)(a1 + 16)) {
          *(_DWORD *)(a1 + 16) = v40 / a6;
        }
        BOOL SizeDimension = IR::IRData::Implementation::canCreateSizeDimension(a1, a16);
        if (SizeDimension)
        {
          LODWORD(__C[0]) = 8;
          std::vector<IR::IRCoordinateType>::push_back[abi:ne180100](v102, __C);
          LODWORD(__C[0]) = 1;
          std::vector<IR::IRCoordinateType>::push_back[abi:ne180100](a1 + 200, __C);
          LODWORD(__C[0]) = 0;
          std::vector<float>::push_back[abi:ne180100](a1 + 128, __C);
          if (*(unsigned char *)(a1 + 488))
          {
            LODWORD(__C[0]) = *(_DWORD *)(a1 + 28);
            std::vector<IR::IRCoordinateType>::push_back[abi:ne180100](a1 + 104, __C);
          }
          else
          {
            v82.__i_ = *(std::__wrap_iter<const int *>::iterator_type *)(a1 + 104);
            LODWORD(__C[0]) = *(_DWORD *)(a1 + 28);
            std::vector<int>::insert((std::vector<int> *)(a1 + 104), v82, 1uLL, (std::vector<int>::const_reference)__C);
          }
          ++*(_DWORD *)(a1 + 28);
        }
        if (*a10)
        {
          __C[0] = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(a10);
          applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(__C, "DiffuseFieldPowerRMS");
        }
        IR::IRData::Implementation::createEmptyIRObject((IR::IRData::Implementation *)a1);
        if (*(void *)(a3 + 8) != *(void *)a3)
        {
          IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)__C);
          unsigned int v83 = *(_DWORD **)a4;
          if (*(void *)(a4 + 8) != *(void *)a4)
          {
            unint64_t v84 = 0;
            unsigned int v85 = 1;
            do
            {
              IR::IRCoordinates::set((uint64_t)__C, v83[v84], *(float *)(**(void **)a3 + 4 * v84));
              unint64_t v84 = v85;
              unsigned int v83 = *(_DWORD **)a4;
              ++v85;
            }
            while (v84 < (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
          }
          std::vector<std::unique_ptr<IR::FFTFilterKernel>>::vector(v110, v100);
          LODWORD(v108) = 0;
          std::vector<float>::vector(&__p, v100, &v108);
          vDSP_Length v86 = *(void ***)a5;
          if (*(void *)(a5 + 8) - *(void *)a5 == *(void *)(a3 + 8) - *(void *)a3)
          {
            uint64_t v87 = (uint64_t)v86[1];
            if (&__p != v86 && (v87 - (uint64_t)*v86) >> 2 == v100) {
              std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)&__p, (char *)*v86, v87, v100);
            }
          }
          operator new();
        }
        if (a15 != 1
          || (memset(__C, 0, 24),
              memset(v110, 0, sizeof(v110)),
              BOOL inited = IR::IRData::Implementation::initVBAPTriangulation(a1, (uint64_t *)__C, v110, 0),
              __p = v110,
              std::vector<std::vector<std::list<int>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p),
              v110[0] = (void **)__C,
              std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v110),
              inited))
        {
          if (SizeDimension
            && (char v107 = 0,
                char v90 = IR::IRData::Implementation::createSizeDimension(a1, a16, (CFArrayRef *)&v107, 0),
                applesauce::CF::ArrayRef::~ArrayRef(&v107),
                (v90 & 1) == 0))
          {
            if (IR::getIRDataLog(void)::onceToken != -1) {
              dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
            }
            unint64_t v91 = IR::getIRDataLog(void)::gLog;
            if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
              IR::IRData::Implementation::Implementation(v91, v92, v93, v94, v95, v96, v97, v98);
            }
          }
          else
          {
            IR::IRData::Implementation::findDimensionsWithMoreThanOneNode((IR::IRData::Implementation *)a1);
          }
        }
        return a1;
      }
      if (0xAAAAAAAAAAAAAAABLL * ((v61 - (uint64_t)v60) >> 3) == v58 && a6 == ((unsigned char *)v60[1] - (unsigned char *)*v60) >> 2)
      {
        unint64_t v100 = a6;
        unint64_t v101 = (unint64_t)(v34 - (void)v35) >> 2;
        uint64_t v62 = 0;
        float v63 = 0.0;
        unsigned int v64 = 1;
        do
        {
          LODWORD(__C[0]) = 0;
          vDSP_maxv(*(const float **)(*(void *)a5 + 24 * v62), 1, (float *)__C, v59);
          if (*(float *)__C > v63) {
            float v63 = *(float *)__C;
          }
          uint64_t v62 = v64;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3) > v64++);
        goto LABEL_51;
      }
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      float v74 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation(v74, v75, v76, v77, v78, v79, v80, v81);
      }
    }
    else
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      uint64_t v66 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation(v66, v67, v68, v69, v70, v71, v72, v73);
      }
    }
  }
  return a1;
}

void sub_21B4E51C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, IR::IRDataAttributes *a14, const void **a15, const void **a16, void **a17, void **a18, void **a19, uint64_t a20,const void **a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  *(void *)(v33 - 144) = v30 + 63;
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v33 - 144));
  IR::IRDataAttributes::~IRDataAttributes(a14);
  *(void *)(v33 - 144) = v30 + 38;
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100]((void ***)(v33 - 144));
  applesauce::CF::DictionaryRef::~DictionaryRef(a21);
  applesauce::CF::DictionaryRef::~DictionaryRef(a15);
  applesauce::CF::StringRef::~StringRef(a16);
  float v35 = (std::__shared_weak_count *)v30[34];
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v35);
  }
  uint64_t v36 = *a17;
  if (*a17)
  {
    v30[26] = v36;
    operator delete(v36);
  }
  uint64_t v37 = (void *)v30[22];
  if (v37)
  {
    v30[23] = v37;
    operator delete(v37);
  }
  unsigned int v38 = *v32;
  if (*v32)
  {
    v30[20] = v38;
    operator delete(v38);
  }
  uint64_t v39 = *a18;
  if (*a18)
  {
    v30[17] = v39;
    operator delete(v39);
  }
  unint64_t v40 = *v31;
  if (*v31)
  {
    v30[14] = v40;
    operator delete(v40);
  }
  float v41 = *a19;
  if (*a19)
  {
    v30[11] = v41;
    operator delete(v41);
  }
  uint64_t v42 = (void *)v30[5];
  if (v42)
  {
    v30[6] = v42;
    operator delete(v42);
  }
  _Unwind_Resume(a1);
}

BOOL IR::IRData::Implementation::canCreateSizeDimension(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0;
  }
  uint64_t v4 = *(_DWORD **)(a1 + 80);
  CFTypeRef v5 = *(_DWORD **)(a1 + 88);
  if (v4 == v5)
  {
LABEL_9:
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    CFTypeRef v8 = IR::getIRDataLog(void)::gLog;
    BOOL result = os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    IR::IRData::Implementation::canCreateSizeDimension(v8, v10, v11, v12, v13, v14, v15, v16);
    return 0;
  }
  CFTypeRef v6 = *(_DWORD **)(a1 + 80);
  do
  {
    if (*v6 == 8)
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      uint64_t v22 = IR::getIRDataLog(void)::gLog;
      BOOL result = os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR);
      if (result)
      {
        IR::IRData::Implementation::canCreateSizeDimension(v22, v23, v24, v25, v26, v27, v28, v29);
        return 0;
      }
      return result;
    }
    ++v6;
  }
  while (v6 != v5);
  char v7 = *(_DWORD **)(a1 + 80);
  while (*v7)
  {
    if (++v7 == v5) {
      goto LABEL_9;
    }
  }
  while (*v4 != 1)
  {
    if (++v4 == v5) {
      goto LABEL_9;
    }
  }
  uint64_t v17 = 0;
  unint64_t v18 = (v3 - v2) >> 2;
  unsigned int v19 = 1;
  BOOL result = 1;
  while (1)
  {
    float v20 = *(float *)(v2 + 4 * v17);
    BOOL v21 = v20 >= 0.0 && v20 <= 1.0;
    if (!v21) {
      break;
    }
    uint64_t v17 = v19;
    BOOL v21 = v18 > v19++;
    if (!v21) {
      return result;
    }
  }
  if (IR::getIRDataLog(void)::onceToken != -1) {
    dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
  }
  uint64_t v30 = IR::getIRDataLog(void)::gLog;
  BOOL result = os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR);
  if (result)
  {
    IR::IRData::Implementation::canCreateSizeDimension(v30, v31, v32, v33, v34, v35, v36, v37);
    return 0;
  }
  return result;
}

void std::vector<IR::IRCoordinateType>::push_back[abi:ne180100](uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = a1 + 16;
  unint64_t v5 = *(void *)(a1 + 16);
  CFTypeRef v6 = *(_DWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    CFTypeRef v8 = *(_DWORD **)a1;
    uint64_t v9 = ((uint64_t)v6 - *(void *)a1) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
      CFTypeRef v8 = *(_DWORD **)a1;
      CFTypeRef v6 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    uint64_t v15 = &v13[4 * v12];
    *(_DWORD *)uint64_t v14 = *a2;
    char v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *CFTypeRef v6 = *a2;
    char v7 = v6 + 1;
  }
  *(void *)(a1 + 8) = v7;
}

void std::vector<float>::push_back[abi:ne180100](uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = a1 + 16;
  unint64_t v5 = *(void *)(a1 + 16);
  CFTypeRef v6 = *(_DWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    CFTypeRef v8 = *(_DWORD **)a1;
    uint64_t v9 = ((uint64_t)v6 - *(void *)a1) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
      CFTypeRef v8 = *(_DWORD **)a1;
      CFTypeRef v6 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    uint64_t v15 = &v13[4 * v12];
    *(_DWORD *)uint64_t v14 = *a2;
    char v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *CFTypeRef v6 = *a2;
    char v7 = v6 + 1;
  }
  *(void *)(a1 + 8) = v7;
}

std::vector<int>::iterator std::vector<int>::insert(std::vector<int> *this, std::vector<int>::const_iterator __position, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  uint64_t i = (unsigned int *)__position.__i_;
  if (__n)
  {
    unint64_t v5 = (int *)__x;
    value = this->__end_cap_.__value_;
    p_end_cap = &this->__end_cap_;
    uint64_t v9 = value;
    uint64_t v11 = p_end_cap[-1].__value_;
    if (__n <= value - v11)
    {
      uint64_t v18 = (char *)v11 - (char *)__position.__i_;
      if (__n <= v11 - __position.__i_)
      {
        BOOL v21 = p_end_cap[-1].__value_;
        std::vector<int>::size_type v20 = __n;
      }
      else
      {
        unint64_t v19 = 0;
        std::vector<int>::size_type v20 = v18 >> 2;
        BOOL v21 = (int *)&v11[__n - (v18 >> 2)];
        do
        {
          v11[v19 / 4] = *__x;
          v19 += 4;
        }
        while (4 * __n - 4 * v20 != v19);
        this->__end_ = v21;
        if (v11 == __position.__i_) {
          return (std::vector<int>::iterator)i;
        }
      }
      uint64_t v22 = &__position.__i_[__n];
      uint64_t v23 = &v21[-__n];
      uint64_t v24 = v21;
      if (v23 < v11)
      {
        uint64_t v24 = v21;
        do
        {
          int v25 = *v23++;
          *v24++ = v25;
        }
        while (v23 < v11);
      }
      this->__end_ = v24;
      if (v21 != v22) {
        memmove(&v21[-(v21 - v22)], __position.__i_, (char *)v21 - (char *)v22);
      }
      if (i <= (unsigned int *)v5)
      {
        if (this->__end_ <= v5) {
          std::vector<int>::size_type v26 = 0;
        }
        else {
          std::vector<int>::size_type v26 = __n;
        }
        v5 += v26;
      }
      uint64_t v27 = (int *)i;
      do
      {
        *v27++ = *v5;
        --v20;
      }
      while (v20);
    }
    else
    {
      std::vector<int>::pointer begin = this->__begin_;
      unint64_t v13 = __n + v11 - this->__begin_;
      if (v13 >> 62) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v14 = __position.__i_ - begin;
      uint64_t v15 = (char *)v9 - (char *)begin;
      if (v15 >> 1 > v13) {
        unint64_t v13 = v15 >> 1;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v13;
      }
      __v.__end_cap_.__value_ = (std::allocator<unsigned int> *)p_end_cap;
      if (v16) {
        uint64_t v17 = (unsigned int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v28 = &v17[v14];
      __v.__first_ = v17;
      __v.__begin_ = v28;
      __v.__end_cap_.__value_ = &v17[v16];
      std::vector<int>::size_type v29 = 4 * __n;
      uint64_t v30 = &v28[__n];
      do
      {
        *v28++ = *v5;
        v29 -= 4;
      }
      while (v29);
      __v.__end_ = v30;
      uint64_t i = std::vector<int>::__swap_out_circular_buffer((std::vector<unsigned int> *)this, &__v, i);
      if (__v.__end_ != __v.__begin_) {
        __v.__end_ = (std::__split_buffer<unsigned int>::pointer)((char *)__v.__end_
      }
                                                                + (((char *)__v.__begin_ - (char *)__v.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
      if (__v.__first_) {
        operator delete(__v.__first_);
      }
    }
  }
  return (std::vector<int>::iterator)i;
}

void sub_21B4E5908(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>(const __CFDictionary ***a1, char *a2)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[21]>(**a1, a2);
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

void IR::IRData::Implementation::insertIRDataInTree(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4, unsigned int a5, void *a6)
{
}

uint64_t IR::IRData::Implementation::createSizeDimension(unint64_t a1, uint64_t *a2, CFArrayRef *a3, int a4)
{
  uint64_t v102 = *MEMORY[0x263EF8340];
  std::chrono::system_clock::now();
  uint64_t v72 = a3;
  if (*a3) {
    BOOL v9 = CFArrayGetCount(*a3) == (a2[1] - *a2) >> 2;
  }
  else {
    BOOL v9 = 0;
  }
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  uint64_t v95 = 0;
  std::vector<IR::IRCoordinates>::reserve(&v93, *(unsigned int *)(a1 + 64));
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)v92);
  if (*(unsigned char *)(a1 + 488))
  {
    uint64_t v99 = 0;
    unint64_t v10 = operator new(0x20uLL);
    *unint64_t v10 = &unk_26CB576F8;
    v10[1] = a1;
    v10[2] = v92;
    v10[3] = &v93;
    uint64_t v99 = v10;
    uint64_t v11 = v98;
    IR::IRData::Implementation::forEachNode(a1, (uint64_t)v98, 0, 0);
  }
  else
  {
    unint64_t v101 = 0;
    unint64_t v12 = operator new(0x20uLL);
    *unint64_t v12 = &unk_26CB576B0;
    v12[1] = v92;
    v12[2] = a1;
    v12[3] = &v93;
    unint64_t v101 = v12;
    uint64_t v11 = v100;
    IR::IRData::Implementation::forEachNode(a1, (uint64_t)v100, 0, 0);
  }
  std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v11);
  uint64_t v76 = v93;
  uint64_t v77 = v94;
  std::vector<IR::FFTFilterKernel>::vector(v91, *(unsigned int *)(a1 + 32));
  LODWORD(v13) = *(_DWORD *)(a1 + 32);
  if (v13)
  {
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    do
    {
      IR::FFTFilterKernel::initialize((IR::FFTFilterKernel *)(v91[0] + v14), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 16), *(unsigned __int8 *)(a1 + 24));
      ++v15;
      unint64_t v13 = *(unsigned int *)(a1 + 32);
      v14 += 40;
    }
    while (v15 < v13);
  }
  *(_DWORD *)buf = 0;
  std::vector<float>::vector(&v89, v13, buf);
  uint64_t v16 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v17 = 0;
    unsigned int v18 = 0;
    int v73 = a4 & v9;
    int v71 = v9 & ~a4;
    unint64_t v19 = 0x8E38E38E38E38E39 * ((v77 - v76) >> 2);
    while (1)
    {
      float v20 = *(float *)(v16 + 4 * v17);
      if (v20 != 0.0) {
        break;
      }
LABEL_95:
      uint64_t v16 = *a2;
      unint64_t v17 = ++v18;
      if (v18 >= (unint64_t)((a2[1] - *a2) >> 2)) {
        goto LABEL_101;
      }
    }
    __p &= 0xFFFFFFFFFFFFFF00;
    unsigned int v75 = v18;
    if (v73 && *(unsigned char *)(a1 + 488))
    {
      if (!*v72)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](exception, "Could not construct");
      }
      unint64_t v21 = applesauce::CF::details::at_as<unsigned int>(*v72, v17);
      float v23 = 1.0;
      if ((v21 & 0xFF00000000) != 0)
      {
        if (v21 <= 1) {
          uint64_t v24 = 1;
        }
        else {
          uint64_t v24 = v21;
        }
        unsigned int TDesign = HOA::getTDesign((HOA *)v24, 0, 0, 0, v22);
        int v97 = 0;
        unint64_t v26 = TDesign;
        memset(buf, 0, sizeof(buf));
        LODWORD(v86) = 0;
        std::vector<float>::resize((uint64_t)buf, TDesign, &v86);
        LODWORD(v86) = 0;
        std::vector<float>::resize((uint64_t)&buf[24], TDesign, &v86);
        uint64_t v4 = *(void **)&buf[24];
        unint64_t __p = *(void *)buf;
        HOA::getTDesign((HOA *)v24, *(_OWORD **)buf, *(float **)&buf[24], 0, v27);
        char v74 = 0;
        float v28 = (float)TDesign;
        int v81 = 1;
LABEL_41:
        if (IR::getIRDataLog(void)::onceToken != -1) {
          dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
        }
        uint64_t v32 = IR::getIRDataLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_DEBUG))
        {
          double v56 = *(float *)(*a2 + 4 * v17);
          uint64_t v57 = "uniform";
          if (v81) {
            uint64_t v57 = "t-grid";
          }
          *(_DWORD *)buf = 136315906;
          *(void *)&buf[4] = "createSizeDimension";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          *(_WORD *)&buf[18] = 2048;
          *(double *)&buf[20] = v56;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = v57;
          _os_log_debug_impl(&dword_21B4DD000, v32, OS_LOG_TYPE_DEBUG, "IRData::%s: Using %u points to calculate size = %.2f based on %s sampling.", buf, 0x26u);
          if (!v26) {
            goto LABEL_88;
          }
        }
        else if (!v26)
        {
LABEL_88:
          if (v74)
          {
            unsigned int v18 = v75;
          }
          else
          {
            unsigned int v18 = v75;
            if (v4) {
              operator delete(v4);
            }
            if (__p) {
              operator delete((void *)__p);
            }
            else {
              unint64_t __p = 0;
            }
          }
          goto LABEL_95;
        }
        float v33 = 0.0;
        unint64_t v78 = v17;
        uint64_t v79 = v4;
        do
        {
          unint64_t v34 = llroundf(v33);
          if (v34 > v19) {
            break;
          }
          if (v81)
          {
            float v35 = *(float *)(__p + 4 * v34);
            float v36 = *((float *)v4 + v34);
          }
          else
          {
            float v35 = IR::IRCoordinates::get((uint64_t)v93 + 36 * v34, 0);
            float v36 = IR::IRCoordinates::get((uint64_t)v93 + 36 * v34, 1u);
          }
          float v37 = *(float *)(*a2 + 4 * v17);
          for (float i = v35 + (float)(v37 * 180.0); i >= 360.0; float i = i + -360.0)
            ;
          for (float j = v35 - (float)(v37 * 180.0); j < 0.0; float j = j + 360.0)
            ;
          LODWORD(v86) = 0;
          *((float *)&v86 + 1) = v36 - (float)(v37 * 180.0);
          *(float *)&uint64_t v87 = v36 + (float)(v37 * 180.0);
          *((float *)&v87 + 1) = j;
          *(float *)&uint64_t v88 = i;
          unint64_t v40 = *(unsigned int *)(a1 + 32);
          *(_DWORD *)buf = 0;
          std::vector<float>::vector(&__C, v40, buf);
          std::vector<std::unique_ptr<IR::FFTFilterKernel>>::vector(v84, *(unsigned int *)(a1 + 32));
          if (*(_DWORD *)(a1 + 32)) {
            operator new();
          }
          if (v77 == v76)
          {
            float v48 = 0.0;
            unint64_t v17 = v78;
            uint64_t v4 = v79;
          }
          else
          {
            uint64_t v41 = 0;
            unsigned int v42 = 0;
            unsigned int v43 = 0;
            unint64_t v17 = v78;
            do
            {
              if (*(float *)(*a2 + 4 * v78) == 1.0
                || (float v44 = IR::IRCoordinates::get((uint64_t)v93 + 36 * v41, 0),
                    float v45 = IR::IRCoordinates::get((uint64_t)v93 + 36 * v41, 1u),
                    AUSM::ExclusionZone::isInExclusionZone((AUSM::ExclusionZone *)&v86, v44, v45, 1.0, 0.000001, (BOOL)&qword_21B551000)))
              {
                IR::IRData::Implementation::getInterpolatedCoeffs(a1, (uint64_t)v93 + 36 * v41, v91[0], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v91[1] - v91[0]) >> 3), (unint64_t)v89, (v90 - (unsigned char *)v89) >> 2, 3u);
                if (*(_DWORD *)(a1 + 32))
                {
                  uint64_t v46 = 0;
                  unint64_t v47 = 0;
                  do
                  {
                    IR::FFTFilterKernel::accumulate(*(IR::FFTFilterKernel **)(v84[0] + 8 * v47), (const IR::FFTFilterKernel *)(v91[0] + v46), 1.0);
                    *(float *)(__C.n128_u64[0] + 4 * v47) = *((float *)v89 + v47)
                                                          + *(float *)(__C.n128_u64[0] + 4 * v47);
                    ++v47;
                    v46 += 40;
                  }
                  while (v47 < *(unsigned int *)(a1 + 32));
                }
                ++v43;
              }
              uint64_t v41 = ++v42;
            }
            while (v19 > v42);
            float v48 = v43 ? 1.0 / (float)v43 : 0.0;
            uint64_t v4 = v79;
          }
          float __B = v48;
          vDSP_vsmul((const float *)__C.n128_u64[0], 1, &__B, (float *)__C.n128_u64[0], 1, *(unsigned int *)(a1 + 32));
          if (*(_DWORD *)(a1 + 32))
          {
            unint64_t v49 = 0;
            do
              IR::FFTFilterKernel::scale(*(IR::FFTFilterKernel **)(v84[0] + 8 * v49++), __B);
            while (v49 < *(unsigned int *)(a1 + 32));
          }
          IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)buf);
          IR::IRCoordinates::set((uint64_t)buf, 8u, *(float *)(*a2 + 4 * v17));
          if (*(unsigned char *)(a1 + 488))
          {
            if (v81)
            {
              IR::IRCoordinates::set((uint64_t)buf, 1u, *((float *)v4 + v34));
              IR::IRCoordinates::set((uint64_t)buf, 0, *(float *)(__p + 4 * v34));
            }
            else if (*(_DWORD *)(a1 + 28) != 1)
            {
              unint64_t v53 = 0;
              do
              {
                unsigned int v54 = *(_DWORD *)(*(void *)(a1 + 80) + 4 * v53);
                float v55 = IR::IRCoordinates::get((uint64_t)v93 + 36 * v34, v54);
                IR::IRCoordinates::set((uint64_t)buf, v54, v55);
                ++v53;
              }
              while (v53 < (*(_DWORD *)(a1 + 28) - 1));
            }
          }
          else if (*(_DWORD *)(a1 + 28) >= 2u)
          {
            unint64_t v50 = 1;
            do
            {
              unsigned int v51 = *(_DWORD *)(*(void *)(a1 + 80) + 4 * *(int *)(*(void *)(a1 + 104) + 4 * v50));
              float v52 = IR::IRCoordinates::get((uint64_t)v93 + 36 * v34, v51);
              IR::IRCoordinates::set((uint64_t)buf, v51, v52);
              ++v50;
            }
            while (v50 < *(unsigned int *)(a1 + 28));
          }
          memset(v82, 0, sizeof(v82));
          IR::IRData::Implementation::insertIRDataInTree(a1, *(uint64_t **)(a1 + 264), (uint64_t)buf, (uint64_t)v84, &__C, 0xFFFFFFFF, v82);
          *(void *)buf = v84;
          std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
          if (__C.n128_u64[0])
          {
            __C.n128_u64[1] = __C.n128_u64[0];
            operator delete((void *)__C.n128_u64[0]);
          }
          float v33 = v23 + v33;
        }
        while (v33 < v28);
        goto LABEL_88;
      }
      int v81 = 0;
LABEL_40:
      char v74 = 1;
      float v28 = (float)v19;
      unint64_t v26 = 0x8E38E38E38E38E39 * ((v77 - v76) >> 2);
      goto LABEL_41;
    }
    if (v20 == 1.0)
    {
      int v81 = 0;
      if (*(unsigned char *)(a1 + 488)) {
        float v23 = (float)v19 * 0.5;
      }
      else {
        float v23 = (float)v19;
      }
      goto LABEL_40;
    }
    if (v71)
    {
      if (!*v72)
      {
        uint64_t v70 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](v70, "Could not construct");
      }
      unint64_t v29 = applesauce::CF::details::at_as<float>(*v72, v17);
      if ((v29 & 0xFF00000000) != 0)
      {
        float v30 = *(float *)&v29;
        if (*(float *)&v29 < 1.0) {
          float v30 = 1.0;
        }
        goto LABEL_34;
      }
      float v20 = *(float *)(*a2 + 4 * v17);
    }
    float v30 = 1.0 / (float)(1.0 - v20);
LABEL_34:
    int v81 = 0;
    if (v30 <= (float)((float)v19 * 0.5) || *(unsigned char *)(a1 + 488) == 0) {
      float v23 = v30;
    }
    else {
      float v23 = (float)v19 * 0.5;
    }
    goto LABEL_40;
  }
LABEL_101:
  if (!*(unsigned char *)(a1 + 488)) {
    goto LABEL_107;
  }
  std::chrono::system_clock::now();
  memset(buf, 0, 24);
  vDSP_Length v86 = 0;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  BOOL inited = IR::IRData::Implementation::initVBAPTriangulation(a1, (uint64_t *)buf, &v86, 1u);
  __C.n128_u64[0] = (unint64_t)&v86;
  std::vector<std::vector<std::list<int>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__C);
  vDSP_Length v86 = buf;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v86);
  if (inited)
  {
    std::chrono::system_clock::now();
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_DEBUG)) {
      IR::IRData::Implementation::createSizeDimension();
    }
LABEL_107:
    std::chrono::system_clock::now();
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_DEBUG)) {
      IR::IRData::Implementation::createSizeDimension();
    }
    uint64_t v59 = 1;
    goto LABEL_117;
  }
  if (IR::getIRDataLog(void)::onceToken != -1) {
    dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
  }
  unint64_t v60 = IR::getIRDataLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
    IR::IRData::Implementation::createSizeDimension(v60, v61, v62, v63, v64, v65, v66, v67);
  }
  uint64_t v59 = 0;
LABEL_117:
  if (v89)
  {
    char v90 = v89;
    operator delete(v89);
  }
  *(void *)buf = v91;
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  if (v93)
  {
    uint64_t v94 = v93;
    operator delete(v93);
  }
  return v59;
}

void sub_21B4E6500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,int a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56)
{
  std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100]((void *)(v56 - 200));
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(IR::IRData::Implementation *this)
{
  v31[4] = *MEMORY[0x263EF8340];
  uint64_t v1 = (void **)((char *)this + 152);
  *((void *)this + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = *((void *)this + 19);
  if (**((void **)this + 33) != *(void *)(*((void *)this + 33) + 8))
  {
    std::vector<unsigned int>::size_type v3 = *((unsigned int *)this + 7);
    if (v3)
    {
      uint64_t v4 = (void *)((char *)this + 176);
      std::vector<unsigned int>::value_type __u = 0;
      std::vector<IR::IRInterpolationMethod>::assign((std::vector<unsigned int> *)((char *)this + 176), v3, &__u);
      if (*((unsigned char *)this + 488))
      {
        unint64_t v5 = (int *)*((void *)this + 13);
        if (v5 != *((int **)this + 14))
        {
          *(_DWORD *)(*((void *)this + 22) + 4 * *v5) = -1431655765
                                                          * ((*(void *)(*((void *)this + 33) + 8)
                                                            - **((void **)this + 33)) >> 5);
          v31[0] = &unk_26CB57740;
          v31[1] = this;
          v31[3] = v31;
          IR::IRData::Implementation::forEachNode((uint64_t)this, (uint64_t)v31, 0, 0);
          std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v31);
        }
        CFTypeRef v6 = (uint64_t *)*((void *)this + 63);
        char v7 = (uint64_t *)*((void *)this + 64);
        if (v6 == v7)
        {
          unsigned int v8 = 0;
        }
        else
        {
          unsigned int v8 = 0;
          do
          {
            uint64_t v9 = *v6;
            v6 += 2;
            unint64_t v10 = (uint64_t)(*(void *)(v9 + 48) - *(void *)(v9 + 40)) >> 2;
            if (v10 > v8) {
              unsigned int v8 = v10;
            }
          }
          while (v6 != v7);
        }
        uint64_t v11 = (char *)*((void *)this + 10);
        unint64_t v12 = (char *)*((void *)this + 11);
        unint64_t v13 = v11;
        if (v11 != v12)
        {
          while (*(_DWORD *)v13)
          {
            v13 += 4;
            if (v13 == v12)
            {
              unint64_t v13 = (char *)*((void *)this + 11);
              break;
            }
          }
        }
        if (v13 != v12) {
          *(_DWORD *)(*v4 + ((v13 - v11) & 0x3FFFFFFFCLL)) = v8;
        }
        uint64_t v14 = v11;
        if (v11 != v12)
        {
          while (*(_DWORD *)v14 != 1)
          {
            v14 += 4;
            if (v14 == v12)
            {
              uint64_t v14 = v12;
              break;
            }
          }
        }
        if (v14 != v12) {
          *(_DWORD *)(*v4 + ((v14 - v11) & 0x3FFFFFFFCLL)) = v8;
        }
      }
      else
      {
        **((_DWORD **)this + 22) = -1431655765
                                 * ((*(void *)(*((void *)this + 33) + 8) - **((void **)this + 33)) >> 5);
        v30[0] = &unk_26CB57788;
        v30[1] = this;
        v30[3] = v30;
        IR::IRData::Implementation::forEachNode((uint64_t)this, (uint64_t)v30, 0, 0);
        std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v30);
      }
      unint64_t v15 = *((unsigned int *)this + 7);
      if (v15)
      {
        for (unint64_t i = 0; i < v15; ++i)
        {
          if (*(_DWORD *)(*v4 + 4 * i) >= 2u)
          {
            uint64_t v17 = *((void *)this + 10);
            unint64_t v19 = (char *)*((void *)this + 20);
            unint64_t v18 = *((void *)this + 21);
            if ((unint64_t)v19 >= v18)
            {
              unint64_t v21 = (char *)*v1;
              uint64_t v22 = (v19 - (unsigned char *)*v1) >> 2;
              unint64_t v23 = v22 + 1;
              if ((unint64_t)(v22 + 1) >> 62) {
                std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v24 = v18 - (void)v21;
              if (v24 >> 1 > v23) {
                unint64_t v23 = v24 >> 1;
              }
              if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v25 = v23;
              }
              if (v25)
              {
                unint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 168, v25);
                unint64_t v21 = (char *)*((void *)this + 19);
                unint64_t v19 = (char *)*((void *)this + 20);
              }
              else
              {
                unint64_t v26 = 0;
              }
              uint64_t v27 = &v26[4 * v22];
              *(_DWORD *)uint64_t v27 = *(_DWORD *)(v17 + 4 * i);
              float v20 = v27 + 4;
              while (v19 != v21)
              {
                int v28 = *((_DWORD *)v19 - 1);
                v19 -= 4;
                *((_DWORD *)v27 - 1) = v28;
                v27 -= 4;
              }
              *((void *)this + 19) = v27;
              *((void *)this + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v20;
              *((void *)this + 21) = &v26[4 * v25];
              if (v21) {
                operator delete(v21);
              }
            }
            else
            {
              *(_DWORD *)unint64_t v19 = *(_DWORD *)(v17 + 4 * i);
              float v20 = v19 + 4;
            }
            *((void *)this + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v20;
            unint64_t v15 = *((unsigned int *)this + 7);
          }
        }
      }
    }
  }
}

void sub_21B4E69F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

unint64_t IR::IRData::Implementation::Implementation(unint64_t a1, uint64_t a2, CFDataRef *a3, uint64_t *a4)
{
  uint64_t v465 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 8) = 0;
  v413 = (_DWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  unsigned int v8 = (unsigned int *)(a1 + 16);
  *(_OWORD *)(a1 + 28) = 0u;
  v405 = (int *)(a1 + 28);
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  v390 = (std::vector<unsigned int> *)(a1 + 40);
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0xFFFF0000FFFF0000;
  *(_OWORD *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  v412 = (void **)(a1 + 80);
  v393 = (std::vector<unsigned int> *)(a1 + 104);
  *(_OWORD *)(a1 + 128) = 0u;
  v402 = (char **)(a1 + 128);
  v401 = (std::vector<unsigned int> *)(a1 + 200);
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  v409 = (IR::IRCoordinates *)(a1 + 224);
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)(a1 + 224));
  *(unsigned char *)(a1 + 328) = 0;
  v396 = (const void **)(a1 + 296);
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)(a1 + 336), (const IR::IRDataAttributes *)a2);
  *(unsigned char *)(a1 + 488) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 492) = 0;
  *(void *)(a1 + 52std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  uint64_t v9 = (IR::IRData::Implementation *)operator new(0x30uLL);
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = 0;
  *(void *)uint64_t v9 = &unk_26CB574D8;
  *((void *)v9 + 4) = 0;
  *((void *)v9 + 5) = 0;
  *((void *)v9 + 3) = 0;
  unint64_t v10 = *(std::__shared_weak_count **)(a1 + 272);
  *(void *)(a1 + 264) = (char *)v9 + 24;
  *(void *)(a1 + 272) = v9;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  IR::IRData::Implementation::getEmptyIRDataNode(v9);
  IR::IRCoordinates::reset(v409);
  *(unsigned char *)(a1 + 488) = *(_DWORD *)(a2 + 20) == 1;
  if (!*a3)
  {
    IR::getFilePtr((CFTypeRef *)a2, (const IR::IRDataAttributes *)1, &v459);
    if (v459) {
      goto LABEL_6;
    }
LABEL_25:
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    unint64_t v21 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v21, v22, v23, v24, v25, v26, v27, v28);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unable to load IR file");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr(*a3);
  if (!*a3)
  {
    v369 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v369, "Could not construct");
  }
  CFIndex Length = CFDataGetLength(*a3);
  v459 = fmemopen(BytePtr, Length, "r");
  v460 = (void (*)(FILE *, uint64_t))MEMORY[0x263EF88A8];
  if (!v459) {
    goto LABEL_25;
  }
LABEL_6:
  uint64_t FileByteSize = IR::IRData::Implementation::getFileByteSize(&v459);
  unsigned int v458 = 0;
  IR::IRData::Implementation::readIRPlist(&v459, &v458, &v457);
  uint64_t v14 = *(const void **)(a1 + 288);
  CFDictionaryRef v15 = v457;
  *(void *)(a1 + 288) = v457;
  if (v15) {
    CFRetain(v15);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (!v15)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v282 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v282, v283, v284, v285, v286, v287, v288, v289);
    }
    v290 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v290, "Unable to load IR file header");
    v290->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  if (*(_DWORD *)(a2 + 40))
  {
    CFRetain(v15);
    CFDictionaryRef v456 = v15;
    IR::IRData::Implementation::extractIRDataTypePlist(&v456, *(_DWORD *)(a2 + 40), &v458, (applesauce::CF::DictionaryRef *)buf);
    CFDictionaryRef v16 = *(const __CFDictionary **)buf;
    CFDictionaryRef v457 = *(const __CFDictionary **)buf;
    *(void *)buf = v15;
    CFRelease(v15);
    if (v456) {
      CFRelease(v456);
    }
    CFDictionaryRef v15 = v16;
    if (!v16)
    {
      v370 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v370, "Could not construct");
    }
  }
  *(_DWORD *)buf = 0;
  float v17 = applesauce::CF::at_or<float,char const(&)[11]>(v15, "SampleRate", (uint64_t)buf);
  if (fabsf(v17) < 0.1)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v291 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v291, v292, v293, v294, v295, v296, v297, v298);
    }
    v299 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v299, "IR file's native sample rate is zero.");
    v299->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  *(float *)(a1 + 4) = v17;
  *(_DWORD *)buf = 0;
  unsigned int v395 = applesauce::CF::at_or<unsigned int,char const(&)[13]>(v15, "FilterLength", (unsigned int *)buf);
  if (!v395)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v300 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v300, v301, v302, v303, v304, v305, v306, v307);
    }
    v308 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v308, "Invalid filter length.");
    v308->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  theString.__r_.__value_.__r.__words[0] = (std::string::size_type)@"UserData";
  CFTypeRef cf = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(v15, (const void **)&theString.__r_.__value_.__l.__data_, &cf, buf);
  unint64_t v18 = *v396;
  *v396 = *(const void **)buf;
  *(void *)buf = v18;
  if (v18) {
    CFRelease(v18);
  }
  v403 = a4;
  if (cf) {
    CFRelease(cf);
  }
  float __B = 0.0;
  *(_DWORD *)buf = 1065353216;
  float __B = applesauce::CF::at_or<float,char const(&)[18]>(v15, "FilterScaleFactor", (uint64_t)buf);
  float v19 = *(float *)(a2 + 8);
  uint64_t v407 = a2;
  if (v19 == 0.0)
  {
    *(float *)a1 = v17;
    unsigned int v20 = v395;
  }
  else
  {
    *(float *)a1 = v19;
    if (vabds_f32(v17, v19) >= 0.1)
    {
      if (*a3) {
        BOOL v30 = *(_DWORD *)(a2 + 48) == 0;
      }
      else {
        BOOL v30 = 1;
      }
      BOOL v31 = v30 && v395 >= 0x101;
      int v32 = !v31;
      if (*v396)
      {
        *(void *)buf = v396;
        CFDictionaryRef v33 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,__CFString const*&>((const __CFDictionary ***)buf, (const void **)IR::kIRDataResamplerTypeKey);
        if (((unint64_t)v33 & 0xFF00000000) != 0 && v33 < 3) {
          int v32 = (int)v33;
        }
      }
      CFTypeRef cf = 0;
      if (v32 != 2)
      {
        if (v32 != 1) {
          operator new();
        }
        operator new();
      }
      operator new();
    }
    unsigned int v20 = v395;
    float v17 = v19;
  }
  unsigned int v34 = *(_DWORD *)(a2 + 24);
  if (v20 <= v34)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v309 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v309, v310, v311, v312, v313, v314, v315, v316);
    }
    v317 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v317, "Window start sample beyond end of filter");
    v317->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  unsigned int v35 = *(_DWORD *)(a2 + 32);
  unsigned int v36 = *(_DWORD *)(a2 + 36);
  unsigned int v37 = *(_DWORD *)(a2 + 28);
  unsigned int v38 = v35 + v34;
  if (v35) {
    BOOL v39 = v38 > v20;
  }
  else {
    BOOL v39 = 1;
  }
  int v40 = v39;
  uint64_t v414 = *(unsigned int *)(a2 + 24);
  unsigned int v41 = v20 - v34;
  if (v40)
  {
    unsigned int v35 = v41;
    unint64_t v42 = v20;
  }
  else
  {
    unint64_t v42 = v38;
  }
  if (v36 + v37 <= v35)
  {
    unsigned int v43 = *(_DWORD *)(a2 + 28);
  }
  else
  {
    do
    {
      unsigned int v43 = v37 >> 1;
      v36 >>= 1;
      unsigned int v44 = v36 + (v37 >> 1);
      v37 >>= 1;
    }
    while (v44 > v35);
  }
  v453 = 0;
  CFTypeRef v452 = 0;
  uint64_t v454 = 0;
  if ((int)v42 >= 1 && *(float *)(a2 + 116) > 0.00000011921)
  {
    *(_DWORD *)buf = 0;
    std::vector<float>::assign((char **)&v452, v42, buf);
    float v45 = (char *)v452;
    *(_DWORD *)CFTypeRef v452 = 1065353216;
    float v46 = expf((float)-*(float *)(a2 + 116) / *(float *)a1);
    if (v42 >= 2)
    {
      unint64_t v47 = (float *)(v45 + 4);
      unint64_t v48 = v42 - 1;
      float v49 = 1.0;
      do
      {
        float v49 = v46 * v49;
        *v47++ = v49;
        --v48;
      }
      while (v48);
    }
  }
  if (v42 < v36)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v318 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v318, v319, v320, v321, v322, v323, v324, v325);
    }
    v326 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v326, "Length of fadeout is greater than filter");
LABEL_596:
    v326->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  signed int v399 = v42 - v36;
  if (v42 - v36 < v43 + v414)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v327 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v327, v328, v329, v330, v331, v332, v333, v334);
    }
    v326 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v326, "Start of fadeout is before window fadein");
    goto LABEL_596;
  }
  if (v42 <= v414)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v335 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v335, v336, v337, v338, v339, v340, v341, v342);
    }
    v326 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v326, "Start of fadeout is beyond end of filter");
    goto LABEL_596;
  }
  unsigned int v391 = v42 - v414;
  _DWORD *v413 = v42 - v414;
  unsigned int v394 = v42;
  if (!v15)
  {
    v343 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v343, "Could not construct");
  }
  *(void *)buf = @"AudioChannelLayoutTag";
  if (applesauce::CF::details::has_key<__CFString const*>(v15, (const void **)buf))
  {
    if (!v457)
    {
      v377 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v377, "Could not construct");
    }
    int v50 = applesauce::CF::details::find_at_key<unsigned int,char const(&)[22]>(v457, "AudioChannelLayoutTag");
    *(_DWORD *)(a1 + 72) = v50;
    *(_DWORD *)(a1 + 76) = v50;
  }
  unsigned int v51 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = v51;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 16);
  if (v51)
  {
    if (v51 <= 2) {
      unsigned int v51 = 2;
    }
    *unsigned int v8 = v51;
  }
  CFDictionaryRef v52 = v457;
  if (!v457)
  {
    v344 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v344, "Could not construct");
  }
  *(_DWORD *)buf = 0;
  unint64_t v53 = (IR::IRDataLoader *)applesauce::CF::at_or<unsigned int,char const(&)[12]>(v457, "NumChannels", (unsigned int *)buf);
  *(_DWORD *)(a1 + 68) = v53;
  if (!v53)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v345 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v345, v346, v347, v348, v349, v350, v351, v352);
    }
    v353 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v353, "NumChannels was either not specified or read as 0");
    v353->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  unsigned int v54 = *(_DWORD *)(a2 + 100);
  if ((v54 | 0x10000) == 0x10000)
  {
    float v55 = (_DWORD *)a1;
    *(_DWORD *)(a1 + 32) = 0;
LABEL_83:
    v55[8] = v53;
    goto LABEL_84;
  }
  v118 = (IR::IRDataLoader::Implementation **)IR::IRDataLoader::instance(v53);
  IR::IRDataLoader::getCustomLayoutFromTag(v118, v54, (uint64_t)buf);
  if (BYTE8(v463))
  {
    v119 = *(void **)buf;
    if (**(_DWORD **)buf == 0x10000)
    {
      uint8x8_t v231 = (uint8x8_t)vcnt_s8((int8x8_t)*(unsigned int *)(*(void *)buf + 4));
      v231.i16[0] = vaddlv_u8(v231);
      __int32 v120 = v231.i32[0];
    }
    else if (**(_DWORD **)buf)
    {
      __int32 v120 = (unsigned __int16)**(_DWORD **)buf;
    }
    else
    {
      __int32 v120 = *(_DWORD *)(*(void *)buf + 8);
    }
    float v55 = (_DWORD *)a1;
    *(_DWORD *)(a1 + 32) = v120;
    *(void *)&buf[8] = v119;
    operator delete(v119);
    int v192 = *(_DWORD *)(a1 + 32);
  }
  else
  {
    int v192 = (unsigned __int16)v54;
    float v55 = (_DWORD *)a1;
    *(_DWORD *)(a1 + 32) = (unsigned __int16)v54;
  }
  LODWORD(v53) = v55[17];
  if (v192 - 1 >= v53) {
    goto LABEL_83;
  }
LABEL_84:
  *(_DWORD *)buf = 0;
  v55[16] = applesauce::CF::at_or<unsigned int,char const(&)[20]>(v52, "TotalNumCoordinates", (unsigned int *)buf);
  memset(buf, 0, sizeof(buf));
  *(void *)&long long v463 = 0;
  applesauce::CF::at_or<std::string,char const(&)[18]>(v52, "CoefficientFormat", (uint64_t)buf, &v451);
  if (SBYTE7(v463) < 0) {
    operator delete(*(void **)buf);
  }
  if ((v451.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v451.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v451.__r_.__value_.__l.__size_;
  }
  if (size == 5)
  {
    unint64_t v58 = &v451;
    if ((v451.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unint64_t v58 = (std::string *)v451.__r_.__value_.__r.__words[0];
    }
    int data = (int)v58->__r_.__value_.__l.__data_;
    int v60 = v58->__r_.__value_.__s.__data_[4];
    if (data == 829714025 && v60 == 54)
    {
      int v411 = 1;
      goto LABEL_104;
    }
    goto LABEL_609;
  }
  if (size != 7)
  {
    if (!size)
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      v354 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation(v354, v355, v356, v357, v358, v359, v360, v361);
      }
      goto LABEL_613;
    }
LABEL_609:
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation();
    }
LABEL_613:
    v281 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v281, "Uunsupported coefficient format");
    goto LABEL_614;
  }
  if ((v451.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v57 = &v451;
  }
  else {
    uint64_t v57 = (std::string *)v451.__r_.__value_.__r.__words[0];
  }
  if (memcmp(v57, "float32", 7uLL)) {
    goto LABEL_609;
  }
  int v411 = 0;
LABEL_104:
  memset(&theString, 0, sizeof(theString));
  applesauce::CF::at_or<std::string,char const(&)[12]>(v52, "DelayFormat", (uint64_t)&theString, (std::string *)buf);
  if (SHIBYTE(v451.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v451.__r_.__value_.__l.__data_);
  }
  *(_OWORD *)&v451.__r_.__value_.__l.__data_ = *(_OWORD *)buf;
  v451.__r_.__value_.__r.__words[2] = v463;
  BYTE7(v463) = 0;
  buf[0] = 0;
  if (SHIBYTE(theString.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(theString.__r_.__value_.__l.__data_);
  }
  std::string::size_type v62 = HIBYTE(v451.__r_.__value_.__r.__words[2]);
  if ((v451.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v62 = v451.__r_.__value_.__l.__size_;
  }
  if (v62 != 7) {
    goto LABEL_556;
  }
  uint64_t v63 = &v451;
  if ((v451.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v63 = (std::string *)v451.__r_.__value_.__r.__words[0];
  }
  int v64 = (int)v63->__r_.__value_.__l.__data_;
  int v65 = *(_DWORD *)((char *)v63->__r_.__value_.__r.__words + 3);
  if (v64 != 1634692198 || v65 != 842232929)
  {
LABEL_556:
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation();
    }
    v281 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v281, "Unsupported delay format");
LABEL_614:
    v281->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  *(void *)buf = @"Dimensions";
  theString.__r_.__value_.__r.__words[0] = 0;
  applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>(v52, (const void **)buf, &theString, &theArray);
  if (theString.__r_.__value_.__r.__words[0]) {
    CFRelease(theString.__r_.__value_.__l.__data_);
  }
  if (!theArray)
  {
    v362 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v362, "Could not construct");
  }
  unsigned int Count = CFArrayGetCount(theArray);
  int *v405 = Count;
  if (Count >= 0xA)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    v363 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation(v405, v363, v364);
    }
    v365 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v365, "size of Dimensions array goes beyond scope");
    v365->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  unint64_t v68 = FileByteSize - MEMORY[0x21D48FAE0](v459);
  uint64_t v69 = v458;
  unsigned int v406 = v42;
  if (v458)
  {
    if (v68 < v458)
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation();
      }
      v371 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v371, "Not enough bytes to skip");
      v371->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    }
    fseek(v459, v458, 1);
    v68 -= v69;
  }
  std::vector<unsigned int>::size_type v70 = *(unsigned int *)(a1 + 32);
  char v71 = 1;
  if (!v411) {
    char v71 = 2;
  }
  char v389 = v71;
  if (v68 < ((((unint64_t)v42 << v71) + 4) * v70 + 4 * *(unsigned int *)(a1 + 28))
           * *(unsigned int *)(a1 + 64))
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::Implementation();
    }
    v366 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v366, "Not enough bytes to read");
    v366->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  std::vector<int>::resize(v390, v70);
  uint64_t v72 = *(_DWORD **)(a1 + 40);
  int v73 = *(_DWORD **)(a1 + 48);
  if (v72 != v73)
  {
    int v74 = 0;
    do
      *v72++ = v74++;
    while (v72 != v73);
  }
  *(void *)(a1 + 88) = *(void *)(a1 + 80);
  unint64_t v75 = *(unsigned int *)(a1 + 28);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v402, v75, buf);
  std::vector<unsigned int>::size_type v76 = *v405;
  *(_DWORD *)buf = 1;
  std::vector<IR::IRInterpolationMethod>::assign(v401, v76, (std::vector<unsigned int>::const_reference)buf);
  v397 = a3;
  int v464 = 0;
  *(_OWORD *)buf = 0u;
  long long v463 = 0u;
  IR::IRCoordinates::getAllCoordinates((uint64_t)buf);
  if (!*v405) {
    goto LABEL_218;
  }
  unint64_t v77 = 0;
  unint64_t v78 = (void *)(a1 + 96);
  do
  {
    if (!theArray)
    {
      v275 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v275, "Could not construct");
    }
    theString.__r_.__value_.__r.__words[0] = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef>(theArray, v77, &theString, &__ptr);
    if (theString.__r_.__value_.__r.__words[0]) {
      CFRelease(theString.__r_.__value_.__l.__data_);
    }
    if (!__ptr)
    {
      v276 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v276, "Could not construct");
    }
    CFTypeRef cf = 0;
    v435 = 0;
    uint64_t v436 = 0;
    applesauce::CF::at_or<std::string,char const(&)[5]>((const __CFDictionary *)__ptr, "Name", (uint64_t)&cf, &theString);
    if (SHIBYTE(v436) < 0) {
      operator delete((void *)cf);
    }
    uint64_t v79 = 0;
    while (1)
    {
      unsigned int v80 = *(_DWORD *)&buf[4 * v79];
      IR::IRCoordinates::getParameterString(v80, &cf);
      if ((theString.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v81 = HIBYTE(theString.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v81 = theString.__r_.__value_.__l.__size_;
      }
      std::vector<int>::const_iterator v82 = (void *)HIBYTE(v436);
      int v83 = SHIBYTE(v436);
      if (v436 < 0) {
        std::vector<int>::const_iterator v82 = v435;
      }
      if ((void *)v81 == v82)
      {
        unint64_t v84 = v436 >= 0 ? &cf : (CFTypeRef *)cf;
        if ((*((unsigned char *)&theString.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          BOOL v92 = memcmp(theString.__r_.__value_.__l.__data_, v84, theString.__r_.__value_.__l.__size_) == 0;
          if ((v83 & 0x80000000) == 0) {
            goto LABEL_158;
          }
        }
        else if (*((unsigned char *)&theString.__r_.__value_.__s + 23))
        {
          uint64_t v85 = HIBYTE(theString.__r_.__value_.__r.__words[2]) - 1;
          p_std::string theString = &theString;
          do
          {
            int v88 = p_theString->__r_.__value_.__s.__data_[0];
            p_std::string theString = (std::string *)((char *)p_theString + 1);
            int v87 = v88;
            int v90 = *(unsigned __int8 *)v84;
            unint64_t v84 = (CFTypeRef *)((char *)v84 + 1);
            int v89 = v90;
            BOOL v31 = v85-- != 0;
            char v91 = v31;
            BOOL v92 = v87 == v89;
          }
          while (v87 == v89 && (v91 & 1) != 0);
          if ((SHIBYTE(v436) & 0x80000000) == 0)
          {
LABEL_158:
            if (v92) {
              break;
            }
            goto LABEL_162;
          }
        }
        else
        {
          BOOL v92 = 1;
          if ((SHIBYTE(v436) & 0x80000000) == 0) {
            goto LABEL_158;
          }
        }
      }
      else
      {
        BOOL v92 = 0;
        if ((SHIBYTE(v436) & 0x80000000) == 0) {
          goto LABEL_158;
        }
      }
      operator delete((void *)cf);
      if (v92) {
        break;
      }
LABEL_162:
      ++v79;
      a2 = v407;
      if (v79 == 9)
      {
        uint64_t v98 = *(char **)(a1 + 88);
        unint64_t v97 = *(void *)(a1 + 96);
        if ((unint64_t)v98 < v97)
        {
          *(_DWORD *)uint64_t v98 = 6;
          uint64_t v96 = v98 + 4;
          goto LABEL_178;
        }
        uint64_t v93 = (unsigned int *)*v412;
        uint64_t v105 = (v98 - (unsigned char *)*v412) >> 2;
        unint64_t v106 = v105 + 1;
        if ((unint64_t)(v105 + 1) >> 62) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v107 = v97 - (void)v93;
        if (v107 >> 1 > v106) {
          unint64_t v106 = v107 >> 1;
        }
        if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v103 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v103 = v106;
        }
        if (v103)
        {
          v104 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v78, v103);
          uint64_t v93 = *(unsigned int **)(a1 + 80);
          uint64_t v98 = *(char **)(a1 + 88);
        }
        else
        {
          v104 = 0;
        }
        uint64_t v108 = (unsigned int *)&v104[4 * v105];
        *uint64_t v108 = 6;
        uint64_t v99 = v108 + 1;
        while (v98 != (char *)v93)
        {
          unsigned int v110 = *((_DWORD *)v98 - 1);
          v98 -= 4;
          *--uint64_t v108 = v110;
        }
        goto LABEL_203;
      }
    }
    uint64_t v93 = *(unsigned int **)(a1 + 80);
    uint64_t v94 = *(unsigned int **)(a1 + 88);
    a2 = v407;
    uint64_t v95 = v93;
    if (v93 != v94)
    {
      while (*v95 != v80)
      {
        if (++v95 == v94)
        {
          uint64_t v95 = *(unsigned int **)(a1 + 88);
          break;
        }
      }
    }
    if (v80 != 6 && v95 != v94)
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation();
      }
      v280 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v280, "Duplicate coordinate");
      v280->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    }
    if ((unint64_t)v94 < *v78)
    {
      *uint64_t v94 = v80;
      uint64_t v96 = v94 + 1;
LABEL_178:
      uint64_t v99 = v96;
      goto LABEL_205;
    }
    uint64_t v100 = v94 - v93;
    unint64_t v101 = v100 + 1;
    if ((unint64_t)(v100 + 1) >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v102 = *v78 - (void)v93;
    if (v102 >> 1 > v101) {
      unint64_t v101 = v102 >> 1;
    }
    if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v103 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v103 = v101;
    }
    if (v103)
    {
      v104 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v78, v103);
      uint64_t v93 = *(unsigned int **)(a1 + 80);
      uint64_t v94 = *(unsigned int **)(a1 + 88);
    }
    else
    {
      v104 = 0;
    }
    uint64_t v108 = (unsigned int *)&v104[4 * v100];
    *uint64_t v108 = v80;
    uint64_t v99 = v108 + 1;
    while (v94 != v93)
    {
      unsigned int v109 = *--v94;
      *--uint64_t v108 = v109;
    }
LABEL_203:
    *(void *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v108;
    *(void *)(a1 + 88) = v99;
    *(void *)(a1 + 96) = &v104[4 * v103];
    if (v93) {
      operator delete(v93);
    }
LABEL_205:
    *(void *)(a1 + 88) = v99;
    if (!__ptr)
    {
      v277 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v277, "Could not construct");
    }
    unsigned int v111 = *((_DWORD *)*v412 + v77);
    LODWORD(cf) = 0;
    float v112 = applesauce::CF::at_or<float,char const(&)[13]>((const __CFDictionary *)__ptr, "DefaultValue", (uint64_t)&cf);
    IR::IRCoordinates::set((uint64_t)v409, v111, v112);
    if (!__ptr)
    {
      v278 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v278, "Could not construct");
    }
    LODWORD(cf) = 0;
    *(float *)&(*v402)[4 * v77] = applesauce::CF::at_or<float,char const(&)[12]>((const __CFDictionary *)__ptr, "Periodicity", (uint64_t)&cf);
    if (!__ptr)
    {
      v279 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v279, "Could not construct");
    }
    LODWORD(cf) = 0;
    int v113 = applesauce::CF::at_or<unsigned int,char const(&)[14]>((const __CFDictionary *)__ptr, "Interpolation", (unsigned int *)&cf);
    if (v113 == 2) {
      int v114 = 2;
    }
    else {
      int v114 = 1;
    }
    if (!v113) {
      int v114 = 0;
    }
    v401->__begin_[v77] = v114;
    if (SHIBYTE(theString.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(theString.__r_.__value_.__l.__data_);
    }
    if (__ptr) {
      CFRelease(__ptr);
    }
    ++v77;
  }
  while (v77 < *v405);
LABEL_218:
  CFTypeRef cf = @"Description";
  unsigned int __ptr = (void **)CFStringCreateWithBytes(0, (const UInt8 *)"", 0, 0x8000100u, 0);
  if (!__ptr)
  {
    v367 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v367, "Could not construct");
  }
  CFDictionaryRef v115 = v457;
  applesauce::CF::at_or<applesauce::CF::StringRef,__CFString const*>(v457, &cf, &__ptr, &theString);
  v116 = *(const void **)(a1 + 280);
  *(void *)(a1 + 28std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = theString.__r_.__value_.__r.__words[0];
  theString.__r_.__value_.__r.__words[0] = (std::string::size_type)v116;
  if (v116) {
    CFRelease(v116);
  }
  unsigned int v117 = v406;
  if (__ptr) {
    CFRelease(__ptr);
  }
  if (!v115)
  {
    v368 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v368, "Could not construct");
  }
  theString.__r_.__value_.__r.__words[0] = (std::string::size_type)@"TriangulationData";
  CFTypeRef cf = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(v115, (const void **)&theString.__r_.__value_.__l.__data_, &cf, &theDict);
  if (cf) {
    CFRelease(cf);
  }
  memset(&v448, 0, sizeof(v448));
  uint64_t v446 = 0;
  uint64_t v445 = 0;
  uint64_t v447 = 0;
  uint64_t v442 = 0;
  std::string::size_type v443 = 0;
  uint64_t v444 = 0;
  if (theDict)
  {
    if (CFDictionaryGetCount(theDict) >= 1 && *(_DWORD *)(a2 + 20))
    {
      if (IR::IRData::Implementation::loadTriangulationData(a1, *(_DWORD *)(a1 + 64), &theDict, &v448, &v445, &v442))
      {
        *(unsigned char *)(a1 + 488) = 1;
      }
      else
      {
        uint64_t v129 = v445;
        uint64_t v130 = v446;
        if (v446 != v445)
        {
          uint64_t v131 = v446;
          do
          {
            v133 = *(void **)(v131 - 24);
            v131 -= 24;
            v132 = v133;
            if (v133)
            {
              *(void *)(v130 - 16) = v132;
              operator delete(v132);
            }
            uint64_t v130 = v131;
          }
          while (v131 != v129);
        }
        uint64_t v446 = v129;
        uint64_t v134 = v442;
        std::string::size_type v135 = v443;
        while (v135 != v134)
        {
          v135 -= 24;
          theString.__r_.__value_.__r.__words[0] = v135;
          std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&theString);
        }
        std::string::size_type v443 = v134;
        v448.__end_ = v448.__begin_;
        if (IR::getIRDataLog(void)::onceToken != -1) {
          dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
        }
        v136 = IR::getIRDataLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          IR::IRData::Implementation::Implementation(v136, v137, v138, v139, v140, v141, v142, v143);
        }
      }
    }
    else if (theDict && !CFDictionaryGetCount(theDict))
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      v121 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation(v121, v122, v123, v124, v125, v126, v127, v128);
      }
    }
  }
  std::vector<float>::vector(v441, v43);
  if (v43)
  {
    IR::calculateFadeInWindow(v43, v441);
    unsigned int v144 = v391;
    if (v43 + v414 <= v406) {
      unsigned int v144 = v43;
    }
    unsigned int v410 = v144;
  }
  else
  {
    unsigned int v410 = 0;
  }
  if (v399 >= (int)v406) {
    unint64_t v145 = 0;
  }
  else {
    unint64_t v145 = v36;
  }
  std::vector<float>::vector(&v439, v145);
  if (v145)
  {
    IR::calculateFadeInWindow(v145, (float **)&v439);
    if ((int)v145 + v399 <= v406) {
      unsigned int v146 = v145;
    }
    else {
      unsigned int v146 = v36;
    }
    unsigned int v408 = v146;
  }
  else
  {
    unsigned int v408 = 0;
  }
  if (!*(unsigned char *)(a1 + 488))
  {
LABEL_279:
    std::vector<int>::resize(v393, *v405);
    v152 = *(_DWORD **)(a1 + 104);
    v153 = *(_DWORD **)(a1 + 112);
    if (v152 != v153)
    {
      int v154 = 0;
      do
        *v152++ = v154++;
      while (v152 != v153);
    }
    goto LABEL_282;
  }
  v147 = *(_DWORD **)(a1 + 80);
  v148 = *(_DWORD **)(a1 + 88);
  if (v147 == v148)
  {
LABEL_272:
    *(unsigned char *)(a1 + 488) = 0;
    char v150 = 1;
  }
  else
  {
    v149 = *(_DWORD **)(a1 + 80);
    while (*v149)
    {
      if (++v149 == v148) {
        goto LABEL_272;
      }
    }
    char v150 = 0;
  }
  if (v147 == v148)
  {
LABEL_278:
    *(unsigned char *)(a1 + 488) = 0;
    goto LABEL_279;
  }
  v151 = v147;
  while (*v151 != 1)
  {
    if (++v151 == v148) {
      goto LABEL_278;
    }
  }
  if (v150) {
    goto LABEL_279;
  }
  unint64_t v179 = 0;
  v180 = *(_DWORD **)(a1 + 104);
  *(void *)(a1 + 112) = v180;
  v181 = (void *)(a1 + 120);
  do
  {
    int v182 = v147[v179];
    if (v182)
    {
      if (v182 == 1)
      {
        *(_DWORD *)(a1 + 496) = v179;
      }
      else
      {
        if ((unint64_t)v180 >= *v181)
        {
          std::vector<unsigned int>::pointer begin = v393->__begin_;
          uint64_t v185 = v180 - v393->__begin_;
          unint64_t v186 = v185 + 1;
          if ((unint64_t)(v185 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v187 = *v181 - (void)begin;
          if (v187 >> 1 > v186) {
            unint64_t v186 = v187 >> 1;
          }
          if ((unint64_t)v187 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v188 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v188 = v186;
          }
          if (v188)
          {
            v189 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v181, v188);
            std::vector<unsigned int>::pointer begin = *(std::vector<unsigned int>::pointer *)(a1 + 104);
            v180 = *(_DWORD **)(a1 + 112);
          }
          else
          {
            v189 = 0;
          }
          v190 = &v189[4 * v185];
          *(_DWORD *)v190 = v179;
          v183 = v190 + 4;
          while (v180 != begin)
          {
            int v191 = *--v180;
            *((_DWORD *)v190 - 1) = v191;
            v190 -= 4;
          }
          *(void *)(a1 + 104) = v190;
          *(void *)(a1 + 112) = v183;
          *(void *)(a1 + 12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = &v189[4 * v188];
          if (begin) {
            operator delete(begin);
          }
        }
        else
        {
          _DWORD *v180 = v179;
          v183 = v180 + 1;
        }
        *(void *)(a1 + 112) = v183;
        v180 = v183;
        v147 = *(_DWORD **)(a1 + 80);
        v148 = *(_DWORD **)(a1 + 88);
        unsigned int v117 = v406;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 492) = v179;
    }
    ++v179;
  }
  while (v179 < v148 - v147);
LABEL_282:
  uint64_t v155 = v407;
  if (*v396)
  {
    theString.__r_.__value_.__r.__words[0] = (std::string::size_type)v396;
    CFNumberRef v156 = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>((const __CFDictionary ***)&theString, "DiffuseFieldPowerRMS");
    if (((unint64_t)v156 & 0xFF00000000) != 0 && fabsf(*(float *)&v156) > 0.00000011921) {
      float __B = __B / *(float *)&v156;
    }
    if (!*v396)
    {
      v372 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v372, "Could not construct");
    }
    theString.__r_.__value_.__r.__words[0] = (std::string::size_type)v396;
    CFNumberRef v157 = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[14]>((const __CFDictionary ***)&theString, "ModelingDelay");
    if (((unint64_t)v157 & 0xFF00000000) != 0)
    {
      float v158 = *(float *)&v157;
      goto LABEL_295;
    }
  }
  if (*v397) {
    BOOL v159 = *(_DWORD *)(v407 + 48) == 1;
  }
  else {
    BOOL v159 = 0;
  }
  if (v159)
  {
    float v158 = 48.0;
LABEL_295:
    *(_DWORD *)(a1 + 36) = vcvtas_u32_f32((float)(*(float *)a1 * v158) / v17);
  }
  v160 = *(const void **)(v407 + 128);
  if (!v160)
  {
    CFTypeRef v438 = 0;
    LOBYTE(cf) = 0;
    char v437 = 0;
    goto LABEL_301;
  }
  CFRetain(*(CFTypeRef *)(v407 + 128));
  CFTypeRef v438 = v160;
  applesauce::CF::details::find_at_key_or_optional<std::vector<float>,__CFString const*&>((const __CFDictionary *)v160, (const void **)IR::kDynamicSizeDimensionValuesKey, &cf);
  if (!v438)
  {
LABEL_301:
    LOBYTE(v432) = 0;
    unsigned __int8 v433 = 0;
    goto LABEL_302;
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>((const __CFDictionary *)v438, (const void **)IR::kDynamicSizeDimensionTGridOrdersKey, &v432);
  if (v438)
  {
    applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>((const __CFDictionary *)v438, (const void **)IR::kDynamicSizeDimensionSamplingFactorsKey, &v430);
    goto LABEL_303;
  }
LABEL_302:
  LOBYTE(v43std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  char v431 = 0;
LABEL_303:
  if (!v437) {
    goto LABEL_317;
  }
  if (v435 == cf)
  {
    if (v435) {
      operator delete(v435);
    }
    char v437 = 0;
LABEL_317:
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::reset[abi:ne180100]((uint64_t)&v432);
    goto LABEL_318;
  }
  if (!v433) {
    goto LABEL_313;
  }
  if (!v432)
  {
    v386 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v386, "Could not construct");
  }
  int64_t v161 = (unsigned char *)v435 - (unsigned char *)cf;
  if (v161 >> 2 != CFArrayGetCount(v432))
  {
LABEL_313:
    v166 = &v432;
LABEL_319:
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::reset[abi:ne180100]((uint64_t)v166);
    goto LABEL_320;
  }
  if (!v431) {
    goto LABEL_318;
  }
  if (!v437) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  if (!v430)
  {
    v387 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v387, "Could not construct");
  }
  v163 = cf;
  v162 = v435;
  CFIndex v164 = CFArrayGetCount(v430);
  uint64_t v165 = (v162 - v163) >> 2;
  uint64_t v155 = v407;
  if (v165 != v164)
  {
LABEL_318:
    v166 = &v430;
    goto LABEL_319;
  }
LABEL_320:
  if (v437) {
    BOOL v167 = *v403 == v403[1];
  }
  else {
    BOOL v167 = 0;
  }
  if (v167) {
    p_CFTypeRef cf = (uint64_t *)&cf;
  }
  else {
    p_CFTypeRef cf = v403;
  }
  v388 = p_cf;
  BOOL SizeDimension = IR::IRData::Implementation::canCreateSizeDimension(a1, p_cf);
  if (SizeDimension)
  {
    unint64_t v170 = *(void *)(a1 + 96);
    v171 = *(char **)(a1 + 88);
    if ((unint64_t)v171 >= v170)
    {
      v173 = (char *)*v412;
      uint64_t v174 = (v171 - (unsigned char *)*v412) >> 2;
      unint64_t v175 = v174 + 1;
      if ((unint64_t)(v174 + 1) >> 62) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v176 = v170 - (void)v173;
      if (v176 >> 1 > v175) {
        unint64_t v175 = v176 >> 1;
      }
      if ((unint64_t)v176 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v177 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v177 = v175;
      }
      if (v177)
      {
        v178 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1 + 96, v177);
        v173 = *(char **)(a1 + 80);
        v171 = *(char **)(a1 + 88);
      }
      else
      {
        v178 = 0;
      }
      v193 = &v178[4 * v174];
      v194 = &v178[4 * v177];
      *(_DWORD *)v193 = 8;
      v172 = v193 + 4;
      while (v171 != v173)
      {
        int v195 = *((_DWORD *)v171 - 1);
        v171 -= 4;
        *((_DWORD *)v193 - 1) = v195;
        v193 -= 4;
      }
      *(void *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v193;
      *(void *)(a1 + 88) = v172;
      *(void *)(a1 + 96) = v194;
      if (v173) {
        operator delete(v173);
      }
    }
    else
    {
      *(_DWORD *)v171 = 8;
      v172 = v171 + 4;
    }
    unint64_t v196 = *(void *)(a1 + 216);
    *(void *)(a1 + 88) = v172;
    v197 = *(_DWORD **)(a1 + 208);
    if ((unint64_t)v197 >= v196)
    {
      std::vector<unsigned int>::pointer v199 = v401->__begin_;
      uint64_t v200 = v197 - v401->__begin_;
      unint64_t v201 = v200 + 1;
      if ((unint64_t)(v200 + 1) >> 62) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v202 = v196 - (void)v199;
      if (v202 >> 1 > v201) {
        unint64_t v201 = v202 >> 1;
      }
      if ((unint64_t)v202 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v203 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v203 = v201;
      }
      if (v203)
      {
        v204 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1 + 216, v203);
        std::vector<unsigned int>::pointer v199 = *(std::vector<unsigned int>::pointer *)(a1 + 200);
        v197 = *(_DWORD **)(a1 + 208);
      }
      else
      {
        v204 = 0;
      }
      v205 = &v204[4 * v200];
      v206 = &v204[4 * v203];
      *(_DWORD *)v205 = 1;
      v198 = v205 + 4;
      while (v197 != v199)
      {
        int v207 = *--v197;
        *((_DWORD *)v205 - 1) = v207;
        v205 -= 4;
      }
      *(void *)(a1 + 20std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v205;
      *(void *)(a1 + 208) = v198;
      *(void *)(a1 + 216) = v206;
      if (v199) {
        operator delete(v199);
      }
    }
    else
    {
      _DWORD *v197 = 1;
      v198 = v197 + 1;
    }
    unint64_t v208 = *(void *)(a1 + 144);
    *(void *)(a1 + 208) = v198;
    v209 = *(char **)(a1 + 136);
    if ((unint64_t)v209 >= v208)
    {
      v211 = *v402;
      uint64_t v212 = (v209 - *v402) >> 2;
      unint64_t v213 = v212 + 1;
      if ((unint64_t)(v212 + 1) >> 62) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v214 = v208 - (void)v211;
      if (v214 >> 1 > v213) {
        unint64_t v213 = v214 >> 1;
      }
      if ((unint64_t)v214 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v215 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v215 = v213;
      }
      if (v215)
      {
        v216 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1 + 144, v215);
        v211 = *(char **)(a1 + 128);
        v209 = *(char **)(a1 + 136);
      }
      else
      {
        v216 = 0;
      }
      v217 = &v216[4 * v212];
      v218 = &v216[4 * v215];
      *(_DWORD *)v217 = 0;
      v210 = v217 + 4;
      while (v209 != v211)
      {
        int v219 = *((_DWORD *)v209 - 1);
        v209 -= 4;
        *((_DWORD *)v217 - 1) = v219;
        v217 -= 4;
      }
      *(void *)(a1 + 128) = v217;
      *(void *)(a1 + 136) = v210;
      *(void *)(a1 + 144) = v218;
      if (v211) {
        operator delete(v211);
      }
    }
    else
    {
      *(_DWORD *)v209 = 0;
      v210 = v209 + 4;
    }
    *(void *)(a1 + 136) = v210;
    if (*(unsigned char *)(a1 + 488))
    {
      unint64_t v220 = *(void *)(a1 + 120);
      int v221 = *(_DWORD *)(a1 + 28);
      v222 = *(_DWORD **)(a1 + 112);
      if ((unint64_t)v222 >= v220)
      {
        std::vector<unsigned int>::pointer v225 = v393->__begin_;
        uint64_t v226 = v222 - v393->__begin_;
        unint64_t v227 = v226 + 1;
        if ((unint64_t)(v226 + 1) >> 62) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v228 = v220 - (void)v225;
        if (v228 >> 1 > v227) {
          unint64_t v227 = v228 >> 1;
        }
        if ((unint64_t)v228 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v229 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v229 = v227;
        }
        if (v229)
        {
          v230 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1 + 120, v229);
          std::vector<unsigned int>::pointer v225 = *(std::vector<unsigned int>::pointer *)(a1 + 104);
          v222 = *(_DWORD **)(a1 + 112);
        }
        else
        {
          v230 = 0;
        }
        v232 = &v230[4 * v226];
        v233 = &v230[4 * v229];
        *(_DWORD *)v232 = v221;
        v223 = v232 + 4;
        while (v222 != v225)
        {
          int v234 = *--v222;
          *((_DWORD *)v232 - 1) = v234;
          v232 -= 4;
        }
        *(void *)(a1 + 104) = v232;
        *(void *)(a1 + 112) = v223;
        *(void *)(a1 + 12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v233;
        if (v225) {
          operator delete(v225);
        }
      }
      else
      {
        _DWORD *v222 = v221;
        v223 = v222 + 1;
      }
      *(void *)(a1 + 112) = v223;
      uint64_t v155 = v407;
    }
    else
    {
      v224.__i_ = (std::__wrap_iter<const int *>::iterator_type)v393->__begin_;
      LODWORD(theString.__r_.__value_.__l.__data_) = *v405;
      std::vector<int>::insert((std::vector<int> *)v393, v224, 1uLL, (std::vector<int>::const_reference)&theString);
    }
    ++*v405;
  }
  __n128 __C = 0;
  v428 = 0;
  uint64_t v429 = 0;
  v424 = 0;
  v425 = 0;
  uint64_t v426 = 0;
  __A = 0;
  v422 = 0;
  unsigned int v235 = v394;
  if (v394 <= v117) {
    unsigned int v235 = v117;
  }
  if (v395 <= v235) {
    unint64_t v236 = v235;
  }
  else {
    unint64_t v236 = v395;
  }
  uint64_t v423 = 0;
  std::vector<float>::resize((uint64_t)&__C, v236);
  if (v411) {
    std::vector<short>::resize((uint64_t)&__A, v428 - __C);
  }
  v237 = __C;
  v420 = 0;
  if (*(unsigned char *)(v155 + 17)) {
    operator new();
  }
  int v392 = SizeDimension;
  if (*(_DWORD *)(a1 + 64))
  {
    unsigned int v238 = 0;
    uint64_t v239 = v399;
    int v400 = v392 << 31 >> 31;
    unint64_t v398 = (((unint64_t)v395 << v389) + 4) * (*(_DWORD *)(a1 + 68) - *(_DWORD *)(a1 + 32));
    while (1)
    {
      IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)&theString);
      if (*v405 + v400)
      {
        uint64_t v240 = 0;
        uint64_t v241 = 4 * (*v405 + v400);
        do
        {
          LODWORD(__ptr) = 0;
          if (fread(&__ptr, 4uLL, 1uLL, v459) != 1)
          {
            if (IR::getIRDataLog(void)::onceToken != -1) {
              dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
            }
            v257 = IR::getIRDataLog(void)::gLog;
            if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
              IR::IRData::Implementation::Implementation(v257, v258, v259, v260, v261, v262, v263, v264);
            }
            v265 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(v265, "Failed to read float dimensionVal from file");
            v265->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          }
          IR::IRCoordinates::set((uint64_t)&theString, *(_DWORD *)((char *)*v412 + v240), *(float *)&__ptr);
          v240 += 4;
        }
        while (v241 != v240);
      }
      std::vector<std::unique_ptr<IR::FFTFilterKernel>>::vector(v418, *(unsigned int *)(a1 + 32));
      std::vector<float>::vector(&__p, *(unsigned int *)(a1 + 32));
      unsigned int v404 = v238;
      if (*(_DWORD *)(a1 + 32))
      {
        float v242 = *(float *)a1 / v17;
        if (v411)
        {
          if (fread(__A, 2uLL, v395, v459) == v395)
          {
            vDSP_vflt16(__A, 1, __C, 1, v394);
            goto LABEL_446;
          }
          if (IR::getIRDataLog(void)::onceToken != -1) {
            dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
          }
          if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
            IR::IRData::Implementation::Implementation();
          }
          bzero(__A, 2 * v395);
          v274 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v274, "Failed to read int16 values from file");
        }
        else if (fread(__C, 4uLL, v395, v459) == v395)
        {
LABEL_446:
          if (fread((void *)__p.n128_u64[0], 4uLL, 1uLL, v459) == 1)
          {
            *(float *)__p.n128_u64[0] = v242 * *(float *)__p.n128_u64[0];
            vDSP_vsmul(__C, 1, &__B, v237, 1, v394);
            float v243 = *(float *)__p.n128_u64[0];
            if (v420)
            {
              IR::DelayLine::setDelay(v420, v243);
              IR::DelayLine::process(v420, v237, v237, (unint64_t)((char *)v428 - (char *)__C) >> 2);
              IR::DelayLine::reset(v420);
              *(_DWORD *)__p.n128_u64[0] = 0;
              float v243 = 0.0;
            }
            if (v243 > *(float *)(a1 + 20)) {
              *(float *)(a1 + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v243;
            }
            if (v410) {
              vDSP_vmul(&__C[v414], 1, v441[0], 1, &__C[v414], 1, v410);
            }
            if (v408) {
              vDSP_vmul(&__C[v239], 1, v440 - 1, -1, &__C[v239], 1, v408);
            }
            vDSP_Length v244 = *v413;
            if ((v244 + v414) <= (unint64_t)((v453 - (unsigned char *)v452) >> 2)) {
              vDSP_vmul(&__C[v414], 1, (const float *)v452 + v414, 1, &__C[v414], 1, v244);
            }
            operator new();
          }
          if (IR::getIRDataLog(void)::onceToken != -1) {
            dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
          }
          v266 = IR::getIRDataLog(void)::gLog;
          if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
            IR::IRData::Implementation::Implementation(v266, v267, v268, v269, v270, v271, v272, v273);
          }
          *(_DWORD *)__p.n128_u64[0] = 0;
          v274 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v274, "Failed to read float value from file");
        }
        else
        {
          if (IR::getIRDataLog(void)::onceToken != -1) {
            dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
          }
          if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
            IR::IRData::Implementation::Implementation();
          }
          vDSP_vclr(__C, 1, v395);
          v274 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v274, "Failed to read float values from file");
        }
        v274->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      }
      if (v398) {
        fseek(v459, v398, 1);
      }
      uint64_t v155 = v407;
      if (v418[0] == v418[1]) {
        goto LABEL_463;
      }
      v245 = (void *)__p.n128_u64[0];
      if (__p.n128_u64[0] != __p.n128_u64[1]) {
        break;
      }
LABEL_464:
      if (v245)
      {
        __p.n128_u64[1] = (unint64_t)v245;
        operator delete(v245);
      }
      unsigned int __ptr = (void **)v418;
      std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](&__ptr);
      ++v238;
      if (v404 + 1 >= *(_DWORD *)(a1 + 64)) {
        goto LABEL_467;
      }
    }
    IR::IRData::Implementation::insertIRDataInTree(a1, *(uint64_t **)(a1 + 264), (uint64_t)&theString, (uint64_t)v418, &__p, v238, &v448);
LABEL_463:
    v245 = (void *)__p.n128_u64[0];
    goto LABEL_464;
  }
LABEL_467:
  if (*(unsigned char *)(a1 + 488) && !IR::IRData::Implementation::initVBAPTriangulation(a1, &v445, &v442, 0))
  {
    *(void *)(a1 + 16std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = *(void *)(a1 + 152);
    v373 = *(uint64_t **)(a1 + 264);
    uint64_t v375 = *v373;
    for (uint64_t i = v373[1]; i != v375; std::__destroy_at[abi:ne180100]<IR::IRDataNode,0>(i))
      i -= 96;
    v373[1] = v375;
    int *v405 = 0;
    v376 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v376, "VBAP Triangulation failed");
    goto LABEL_647;
  }
  if (*(unsigned char *)(v155 + 120)) {
    IR::IRData::Implementation::computeAverageIR((IR::IRData::Implementation *)a1);
  }
  if (v392)
  {
    int v246 = v433;
    if (v433)
    {
      CFArrayRef v247 = v432;
      if (v432) {
        CFRetain(v432);
      }
      int v248 = 0;
      int v249 = 0;
      CFTypeRef v416 = v247;
    }
    else if (v431)
    {
      CFArrayRef v250 = v430;
      if (v430) {
        CFRetain(v430);
      }
      int v249 = 0;
      CFTypeRef v416 = v250;
      int v248 = 1;
    }
    else
    {
      int v248 = 0;
      CFTypeRef v416 = 0;
      int v249 = 1;
    }
    char v251 = IR::IRData::Implementation::createSizeDimension(a1, v388, (CFArrayRef *)&v416, v433);
    if (v249 && v416) {
      CFRelease(v416);
    }
    if (v248 && v416) {
      CFRelease(v416);
    }
    if (v246 && v416) {
      CFRelease(v416);
    }
    if ((v251 & 1) == 0)
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      v378 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::Implementation(v378, v379, v380, v381, v382, v383, v384, v385);
      }
      v376 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v376, "Unable to create user-defined size dimension");
LABEL_647:
      v376->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    }
  }
  IR::IRData::Implementation::findDimensionsWithMoreThanOneNode((IR::IRData::Implementation *)a1);
  v252 = v420;
  v420 = 0;
  if (v252)
  {
    IR::DelayLine::~DelayLine(v252);
    MEMORY[0x21D48F780](v253, 0x10B0C4057A31370);
  }
  if (__A)
  {
    v422 = __A;
    operator delete(__A);
  }
  if (v424)
  {
    v425 = v424;
    operator delete(v424);
  }
  if (__C)
  {
    v428 = __C;
    operator delete(__C);
  }
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v430);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v432);
  if (v437 && cf)
  {
    v435 = (void *)cf;
    operator delete((void *)cf);
  }
  if (v438) {
    CFRelease(v438);
  }
  if (v439)
  {
    v440 = (const float *)v439;
    operator delete(v439);
  }
  if (v441[0])
  {
    v441[1] = v441[0];
    operator delete(v441[0]);
  }
  theString.__r_.__value_.__r.__words[0] = (std::string::size_type)&v442;
  std::vector<std::vector<std::list<int>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&theString);
  theString.__r_.__value_.__r.__words[0] = (std::string::size_type)&v445;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&theString);
  if (v448.__begin_)
  {
    v448.__end_ = v448.__begin_;
    operator delete(v448.__begin_);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (theArray) {
    CFRelease(theArray);
  }
  if (SHIBYTE(v451.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v451.__r_.__value_.__l.__data_);
  }
  if (v452)
  {
    v453 = v452;
    operator delete((void *)v452);
  }
  if (v457) {
    CFRelease(v457);
  }
  v255 = v459;
  v459 = 0;
  if (v255) {
    v460(v255, v254);
  }
  return a1;
}

void sub_21B4EA06C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, IR::IRDataAttributes *a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, void **a15, uint64_t a16, CFTypeRef *a17, uint64_t a18, uint64_t a19, void **a20,void **a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void **a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,char a59,uint64_t a60,void *__p,uint64_t a62,uint64_t a63)
{
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a57);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a59);
  if (a64 && __p)
  {
    a62 = (uint64_t)__p;
    operator delete(__p);
  }
  applesauce::CF::DictionaryRef::~DictionaryRef(&a65);
  if (a66)
  {
    a67 = (uint64_t)a66;
    operator delete(a66);
  }
  if (a69)
  {
    a70 = (uint64_t)a69;
    operator delete(a69);
  }
  a42 = &a72;
  std::vector<std::vector<std::list<int>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a42);
  a42 = &STACK[0x210];
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a42);
  int v74 = (void *)STACK[0x228];
  if (STACK[0x228])
  {
    STACK[0x230] = (unint64_t)v74;
    operator delete(v74);
  }
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&STACK[0x240]);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)&STACK[0x248]);
  if (SLOBYTE(STACK[0x267]) < 0) {
    operator delete((void *)STACK[0x250]);
  }
  unint64_t v75 = (void *)STACK[0x270];
  if (STACK[0x270])
  {
    STACK[0x278] = (unint64_t)v75;
    operator delete(v75);
  }
  if (a30) {
    (*(void (**)(uint64_t))(*(void *)a30 + 8))(a30);
  }
  std::vector<unsigned int>::size_type v76 = *(const void **)(v72 - 240);
  if (v76) {
    CFRelease(v76);
  }
  uint64_t v77 = *(void *)(v72 - 224);
  *(void *)(v72 - 224) = 0;
  if (v77) {
    (*(void (**)(void))(v72 - 216))();
  }
  *(void *)(v72 - 176) = a34 + 63;
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v72 - 176));
  IR::IRDataAttributes::~IRDataAttributes(a10);
  *(void *)(v72 - 176) = a34 + 38;
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100]((void ***)(v72 - 176));
  if (*a17) {
    CFRelease(*a17);
  }
  unint64_t v78 = (const void *)a34[36];
  if (v78) {
    CFRelease(v78);
  }
  uint64_t v79 = (const void *)a34[35];
  if (v79) {
    CFRelease(v79);
  }
  unsigned int v80 = (std::__shared_weak_count *)a34[34];
  if (v80) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v80);
  }
  std::string::size_type v81 = *a20;
  if (*a20)
  {
    a34[26] = v81;
    operator delete(v81);
  }
  std::vector<int>::const_iterator v82 = (void *)a34[22];
  if (v82)
  {
    a34[23] = v82;
    operator delete(v82);
  }
  int v83 = (void *)a34[19];
  if (v83)
  {
    a34[20] = v83;
    operator delete(v83);
  }
  unint64_t v84 = *a21;
  if (*a21)
  {
    a34[17] = v84;
    operator delete(v84);
  }
  uint64_t v85 = *a15;
  if (*a15)
  {
    a34[14] = v85;
    operator delete(v85);
  }
  vDSP_Length v86 = *a29;
  if (*a29)
  {
    a34[11] = v86;
    operator delete(v86);
  }
  int v87 = *a13;
  if (*a13)
  {
    a34[6] = v87;
    operator delete(v87);
  }
  _Unwind_Resume(a1);
}

const __CFDictionary *applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,__CFString const*&>(const __CFDictionary ***a1, const void **a2)
{
  CFDictionaryRef result = applesauce::CF::details::at_key<__CFString const*&>(**a1, a2);
  if (result)
  {
    return (const __CFDictionary *)applesauce::CF::convert_as<unsigned int,0>(result);
  }
  return result;
}

void applesauce::CF::TypeRefPair::~TypeRefPair(applesauce::CF::TypeRefPair *this)
{
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
}

void *applesauce::CF::URLRef::operator->(void *result)
{
  if (!*result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_21B4EA984()
{
}

void sub_21B4EA9A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::StringRef *applesauce::CF::URLRef_proxy::get_filesystem_path@<X0>(CFURLRef **this@<X0>, applesauce::CF::StringRef *a2@<X8>)
{
  CFStringRef v3 = CFURLCopyFileSystemPath(**this, kCFURLPOSIXPathStyle);

  return applesauce::CF::StringRef::StringRef(a2, v3);
}

char *std::vector<float>::assign(char **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  CFDictionaryRef result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 2)
  {
    unint64_t v13 = a1[1];
    unint64_t v14 = (v13 - result) >> 2;
    if (v14 >= a2) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = (v13 - result) >> 2;
    }
    if (v15)
    {
      CFDictionaryRef v16 = result;
      do
      {
        *(_DWORD *)CFDictionaryRef v16 = *a3;
        v16 += 4;
        --v15;
      }
      while (v15);
    }
    if (a2 <= v14)
    {
      a1[1] = &result[4 * a2];
    }
    else
    {
      float v17 = &v13[4 * (a2 - v14)];
      uint64_t v18 = 4 * a2 - 4 * v14;
      do
      {
        *(_DWORD *)unint64_t v13 = *a3;
        v13 += 4;
        v18 -= 4;
      }
      while (v18);
      a1[1] = v17;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = v6 >> 1;
    if (v6 >> 1 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    CFDictionaryRef result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](a1, v9);
    unint64_t v10 = a1[1];
    uint64_t v11 = &v10[4 * a2];
    uint64_t v12 = 4 * a2;
    do
    {
      *(_DWORD *)unint64_t v10 = *a3;
      v10 += 4;
      v12 -= 4;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

void std::vector<IR::IRInterpolationMethod>::assign(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, std::vector<unsigned int>::const_reference __u)
{
  uint64_t value = (uint64_t)this->__end_cap_.__value_;
  std::vector<unsigned int>::pointer begin = this->__begin_;
  if (__n <= (value - (uint64_t)begin) >> 2)
  {
    std::vector<unsigned int>::pointer end = this->__end_;
    std::vector<unsigned int>::size_type v14 = end - begin;
    if (v14 >= __n) {
      std::vector<unsigned int>::size_type v15 = __n;
    }
    else {
      std::vector<unsigned int>::size_type v15 = end - begin;
    }
    if (v15)
    {
      CFDictionaryRef v16 = begin;
      do
      {
        *v16++ = *__u;
        --v15;
      }
      while (v15);
    }
    if (__n <= v14)
    {
      this->__end_ = &begin[__n];
    }
    else
    {
      float v17 = &end[__n - v14];
      std::vector<unsigned int>::size_type v18 = 4 * __n - 4 * v14;
      do
      {
        *end++ = *__u;
        v18 -= 4;
      }
      while (v18);
      this->__end_ = v17;
    }
  }
  else
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      uint64_t value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    std::vector<unsigned int>::size_type v8 = value >> 1;
    if (value >> 1 <= __n) {
      std::vector<unsigned int>::size_type v8 = __n;
    }
    if ((unint64_t)value >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](this, v9);
    std::vector<unsigned int>::pointer v10 = this->__end_;
    uint64_t v11 = &v10[__n];
    std::vector<unsigned int>::size_type v12 = 4 * __n;
    do
    {
      *v10++ = *__u;
      v12 -= 4;
    }
    while (v12);
    this->__end_ = v11;
  }
}

void IR::calculateFadeInWindow(unsigned int a1, float **a2)
{
  uint64_t v4 = a1;
  if (a1 != a2[1] - *a2) {
    std::vector<float>::resize((uint64_t)a2, a1);
  }
  if (a1)
  {
    unint64_t v5 = *a2;
    double v6 = 3.14159265 / (double)(a1 + 1);
    do
    {
      float v7 = cos(v6) * -0.5 + 0.5;
      *v5++ = v7;
      double v6 = 3.14159265 / (double)(a1 + 1) + v6;
      --v4;
    }
    while (v4);
  }
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[14]>(const __CFDictionary ***a1, char *a2)
{
  CFNumberRef result = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[14]>(**a1, a2);
  if (result)
  {
    return (const __CFNumber *)applesauce::CF::convert_as<float,0>(result);
  }
  return result;
}

void std::vector<short>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 2 * a2;
    }
  }
  else
  {
    std::vector<short>::__append((char **)a1, a2 - v2);
  }
}

uint64_t IR::IRData::Implementation::computeAverageIR(IR::IRData::Implementation *this)
{
  v22[4] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 328)) {
    return 1;
  }
  unsigned int v3 = *((_DWORD *)this + 16);
  unsigned int v4 = *((_DWORD *)this + 8);
  if (!(v4 * v3)) {
    return 0;
  }
  float v5 = 1.0 / (float)v3;
  float v21 = v5;
  double v6 = (void *)((char *)this + 304);
  uint64_t v8 = *((void *)this + 38);
  uint64_t v7 = *((void *)this + 39);
  if (v7 != v8)
  {
    do
      IR::FFTFilterKernel::~FFTFilterKernel((IR::FFTFilterKernel *)(v7 - 40));
    while (v7 != v8);
    unsigned int v4 = *((_DWORD *)this + 8);
  }
  *((void *)this + 39) = v8;
  std::vector<IR::FFTFilterKernel>::resize((uint64_t *)this + 38, v4);
  if (*((_DWORD *)this + 8))
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      IR::FFTFilterKernel::initialize((IR::FFTFilterKernel *)(*((void *)this + 38) + v9), *((_DWORD *)this + 2), *((_DWORD *)this + 4), *((unsigned __int8 *)this + 24));
      ++v10;
      v9 += 40;
    }
    while (v10 < *((unsigned int *)this + 8));
  }
  if (*((unsigned char *)this + 488))
  {
    uint64_t v11 = (uint64_t *)*((void *)this + 63);
    for (uint64_t i = (uint64_t *)*((void *)this + 64); v11 != i; v11 += 2)
    {
      uint64_t v12 = *v11;
      uint64_t v13 = *(void *)(*v11 + 88);
      if (*(void *)(*v11 + 96) != v13)
      {
        uint64_t v14 = 0;
        unsigned int v15 = 0;
        do
        {
          uint64_t v16 = (*(void *)(v13 + 24 * v14 + 8) - *(void *)(v13 + 24 * v14)) >> 3;
          unsigned int v17 = *((_DWORD *)this + 8);
          if (v17 >= v16) {
            uint64_t v18 = v16;
          }
          else {
            uint64_t v18 = v17;
          }
          if (v18)
          {
            for (uint64_t j = 0; j != v18; ++j)
              IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*v6 + 40 * j), *(const IR::FFTFilterKernel **)(*(void *)(*(void *)(*v11 + 88) + 24 * v14) + 8 * j), v5);
            uint64_t v12 = *v11;
          }
          uint64_t v13 = *(void *)(v12 + 88);
          uint64_t v14 = ++v15;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v12 + 96) - v13) >> 3) > v15);
      }
    }
  }
  else
  {
    v22[0] = &unk_26CB57818;
    v22[1] = this;
    v22[2] = &v21;
    v22[3] = v22;
    IR::IRData::Implementation::forEachNode((uint64_t)this, (uint64_t)v22, 0, 0);
    std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v22);
  }
  uint64_t result = 1;
  *((unsigned char *)this + 328) = 1;
  return result;
}

void sub_21B4EAF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::Implementation::getNumSpatialPoints(IR::IRData::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRData::Implementation::readIRPlist(this, &cf);
  if (!cf) {
    return 0;
  }
  unsigned int v4 = 0;
  uint64_t v2 = applesauce::CF::at_or<unsigned int,char const(&)[20]>((const __CFDictionary *)cf, "TotalNumCoordinates", &v4);
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

uint64_t IR::IRData::Implementation::getNumFiltersPerSpatialPoint(IR::IRData::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRData::Implementation::readIRPlist(this, &cf);
  if (!cf) {
    return 0;
  }
  unsigned int v4 = 0;
  uint64_t v2 = applesauce::CF::at_or<unsigned int,char const(&)[12]>((const __CFDictionary *)cf, "NumChannels", &v4);
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

uint64_t IR::IRData::Implementation::getFilterLength(IR::IRData::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRData::Implementation::readIRPlist(this, &cf);
  if (!cf) {
    return 0;
  }
  int v3 = *((_DWORD *)this + 8);
  int v4 = *((_DWORD *)this + 6);
  unsigned int v15 = 0;
  unsigned int v5 = applesauce::CF::at_or<unsigned int,char const(&)[13]>((const __CFDictionary *)cf, "FilterLength", &v15);
  if (!cf)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  unsigned int v15 = 0;
  float v6 = applesauce::CF::at_or<float,char const(&)[11]>((const __CFDictionary *)cf, "SampleRate", (uint64_t)&v15);
  float v7 = *((float *)this + 2);
  if (v7 != 0.0) {
    unsigned int v5 = (float)((float)(v7 / v6) * (float)v5);
  }
  if (v4 + v3 > v5 || v3 == 0) {
    unsigned int v9 = v5;
  }
  else {
    unsigned int v9 = v4 + v3;
  }
  BOOL v10 = __OFSUB__(v9, v4);
  int v11 = v9 - v4;
  if ((v11 < 0) ^ v10 | (v11 == 0)) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v11;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v12;
}

void sub_21B4EB164(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::Implementation::getModelingDelay(IR::IRData::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRData::Implementation::readIRPlist(this, &cf);
  if (!cf) {
    return 0;
  }
  float v6 = @"UserData";
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,__CFString const*>((const __CFDictionary *)cf, (const void **)&v6, &v7);
  int v3 = v8;
  if (v8)
  {
    if (!v7)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    LODWORD(v6) = 0;
    uint64_t v2 = applesauce::CF::at_or<unsigned int,char const(&)[14]>(v7, "ModelingDelay", (unsigned int *)&v6);
    std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v7);
  }
  else
  {
    std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v7);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (!v3) {
    return 0;
  }
  return v2;
}

void sub_21B4EB268(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va1);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::getUserData(IR::IRData::Implementation *this@<X0>, void *a2@<X8>)
{
  IR::IRData::Implementation::readIRPlist(this, &v6);
  if (v6)
  {
    CFTypeRef cf = 0;
    uint64_t v5 = @"UserData";
    applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>((const __CFDictionary *)v6, (const void **)&v5, &cf, a2);
    if (cf) {
      CFRelease(cf);
    }
    if (v6) {
      CFRelease(v6);
    }
  }
  else
  {
    *a2 = 0;
  }
}

void IR::IRData::Implementation::getIRDataTypes(CFTypeRef *this@<X0>, std::vector<unsigned int> *a2@<X8>)
{
  int v34 = 0;
  CFTypeRef v4 = *this;
  if (*this) {
    CFRetain(*this);
  }
  CFTypeRef v32 = v4;
  IR::IRData::Implementation::readIRPlist(&v32, &v34, 0, &v33);
  if (v4) {
    CFRelease(v4);
  }
  if (!v33) {
    goto LABEL_15;
  }
  CFArrayRef theArray = (CFArrayRef)@"ImpulseResponses";
  if (!applesauce::CF::details::has_key<__CFString const*>((const __CFDictionary *)v33, (const void **)&theArray))goto LABEL_15; {
  if (!v33)
  }
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  CFTypeRef cf = 0;
  CFTypeRef v30 = @"ImpulseResponses";
  applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>((const __CFDictionary *)v33, &v30, &cf, &theArray);
  if (cf) {
    CFRelease(cf);
  }
  CFArrayRef v5 = theArray;
  if (!theArray)
  {
LABEL_15:
    a2->__begin_ = 0;
    a2->__end_ = 0;
    a2->__end_cap_.__value_ = 0;
    goto LABEL_16;
  }
  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::size_type Count = CFArrayGetCount(v5);
  std::vector<IR::IRDataType>::reserve(a2, Count);
  CFArrayRef v7 = theArray;
  if (!theArray) {
    goto LABEL_16;
  }
  CFIndex v8 = CFArrayGetCount(theArray);
  CFIndex v9 = v8;
  CFArrayRef v10 = theArray;
  if (!theArray)
  {
    CFIndex v11 = 0;
    if (!v8) {
      goto LABEL_45;
    }
LABEL_20:
    unint64_t v12 = 0;
    do
    {
      if (v7 == v10 && v12 == v11) {
        break;
      }
      applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>(v7, v12, (applesauce::CF::DictionaryRef *)&v30);
      if (!v30)
      {
        uint64_t v26 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](v26, "Could not construct");
      }
      uint64_t v28 = @"Type";
      CFTypeRef cf = &v30;
      CFDictionaryRef v13 = applesauce::CF::DictionaryRef_proxy::at_as<IR::IRDataType,__CFString const*>((const __CFDictionary ***)&cf, (const void **)&v28);
      if (((unint64_t)v13 & 0xFF00000000) != 0)
      {
        unsigned int v14 = v13;
        std::vector<unsigned int>::pointer end = a2->__end_;
        uint64_t value = a2->__end_cap_.__value_;
        if (end >= value)
        {
          std::vector<unsigned int>::pointer begin = a2->__begin_;
          uint64_t v19 = end - a2->__begin_;
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v21 = (char *)value - (char *)begin;
          if (v21 >> 1 > v20) {
            unint64_t v20 = v21 >> 1;
          }
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v20;
          }
          if (v22)
          {
            uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&a2->__end_cap_, v22);
            std::vector<unsigned int>::pointer begin = a2->__begin_;
            std::vector<unsigned int>::pointer end = a2->__end_;
          }
          else
          {
            uint64_t v23 = 0;
          }
          uint64_t v24 = (unsigned int *)&v23[4 * v19];
          *uint64_t v24 = v14;
          unsigned int v17 = v24 + 1;
          while (end != begin)
          {
            unsigned int v25 = *--end;
            *--uint64_t v24 = v25;
          }
          a2->__begin_ = v24;
          a2->__end_ = v17;
          a2->__end_cap_.__value_ = (unsigned int *)&v23[4 * v22];
          if (begin) {
            operator delete(begin);
          }
        }
        else
        {
          *std::vector<unsigned int>::pointer end = v13;
          unsigned int v17 = end + 1;
        }
        a2->__end_ = v17;
      }
      if (v30) {
        CFRelease(v30);
      }
      ++v12;
    }
    while (v12 != v9);
    goto LABEL_45;
  }
  CFIndex v11 = CFArrayGetCount(theArray);
  if (v9) {
    goto LABEL_20;
  }
LABEL_45:
  if (theArray) {
    CFRelease(theArray);
  }
LABEL_16:
  if (v33) {
    CFRelease(v33);
  }
}

void sub_21B4EB600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  _Unwind_Resume(a1);
}

void std::vector<IR::IRDataType>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  uint64_t value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (char *)this->__end_ - (char *)this->__begin_;
    CFTypeRef v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, __n);
    CFArrayRef v7 = (unsigned int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    CFIndex v9 = (unsigned int *)&v6[4 * v8];
    std::vector<unsigned int>::pointer begin = this->__begin_;
    std::vector<unsigned int>::pointer end = this->__end_;
    unint64_t v12 = v7;
    if (end != this->__begin_)
    {
      unint64_t v12 = v7;
      do
      {
        unsigned int v13 = *--end;
        *--unint64_t v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

const __CFDictionary *applesauce::CF::DictionaryRef_proxy::at_as<IR::IRDataType,__CFString const*>(const __CFDictionary ***a1, const void **a2)
{
  CFDictionaryRef result = applesauce::CF::details::at_key<__CFString const*>(**a1, a2);
  if (result)
  {
    return (const __CFDictionary *)applesauce::CF::convert_as<IR::IRDataType,0>(result);
  }
  return result;
}

void IR::IRData::Implementation::getGlobalUserData(CFTypeRef *this@<X0>, void *a2@<X8>)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  int v10 = 0;
  CFTypeRef v4 = *this;
  if (*this) {
    CFRetain(*this);
  }
  CFTypeRef v8 = v4;
  IR::IRData::Implementation::readIRPlist(&v8, &v10, 0, &v9);
  if (v4) {
    CFRelease(v4);
  }
  if (v9
    && (*(void *)buf = @"ImpulseResponses",
        (applesauce::CF::details::has_key<__CFString const*>((const __CFDictionary *)v9, (const void **)buf) & 1) != 0))
  {
    if (!v9)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    *(void *)buf = @"UserData";
    CFTypeRef cf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>((const __CFDictionary *)v9, (const void **)buf, &cf, a2);
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    int64_t v5 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = "getGlobalUserData";
      _os_log_impl(&dword_21B4DD000, v5, OS_LOG_TYPE_DEFAULT, "IRData::%s: Not a consolidated IR file, use IRData::getUserData() instead.", buf, 0xCu);
    }
    *a2 = 0;
  }
  if (v9) {
    CFRelease(v9);
  }
}

void sub_21B4EB928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  _Unwind_Resume(a1);
}

float IR::IRData::Implementation::getOriginalSampleRate(IR::IRData::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRData::Implementation::readIRPlist(this, &cf);
  if (!cf)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  int v5 = 0;
  float v2 = applesauce::CF::at_or<float,char const(&)[11]>((const __CFDictionary *)cf, "SampleRate", (uint64_t)&v5);
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

void sub_21B4EBA18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::Implementation::getAudioChannelLayoutTag(IR::IRData::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRData::Implementation::readIRPlist(this, &cf);
  if (!cf) {
    return 0;
  }
  unsigned int v4 = 0;
  uint64_t v2 = applesauce::CF::at_or<unsigned int,char const(&)[22]>((const __CFDictionary *)cf, "AudioChannelLayoutTag", &v4);
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

const __CFDictionary *IR::IRData::Implementation::isConsolidatedIR(IR::IRData::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)v6, this);
  int v7 = 0;
  IR::IRData::Implementation::readIRPlist((IR::IRData::Implementation *)v6, &cf);
  if (cf)
  {
    unsigned int v4 = @"ImpulseResponses";
    CFDictionaryRef v2 = applesauce::CF::details::has_key<__CFString const*>((const __CFDictionary *)cf, (const void **)&v4);
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    CFDictionaryRef v2 = 0;
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v6[0]) {
    CFRelease(v6[0]);
  }
  return v2;
}

void sub_21B4EBB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::Implementation::hasType(IR::IRDataAttributes *a1, int a2)
{
  IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)v19, a1);
  int v20 = 0;
  IR::IRData::Implementation::readIRPlist((IR::IRData::Implementation *)v19, &v18);
  if (!v18)
  {
    uint64_t v8 = 0;
    goto LABEL_25;
  }
  CFArrayRef theArray = (CFArrayRef)@"ImpulseResponses";
  if (applesauce::CF::details::has_key<__CFString const*>((const __CFDictionary *)v18, (const void **)&theArray))
  {
    if (!v18)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    CFTypeRef cf = 0;
    CFTypeRef v16 = @"ImpulseResponses";
    applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>((const __CFDictionary *)v18, &v16, &cf, &theArray);
    if (cf) {
      CFRelease(cf);
    }
    CFArrayRef v3 = theArray;
    if (theArray)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      CFIndex v5 = Count;
      CFArrayRef v6 = theArray;
      if (theArray)
      {
        CFIndex v7 = CFArrayGetCount(theArray);
        if (!v5)
        {
LABEL_20:
          if (theArray) {
            CFRelease(theArray);
          }
          goto LABEL_22;
        }
      }
      else
      {
        CFIndex v7 = 0;
        if (!Count) {
          goto LABEL_20;
        }
      }
      unint64_t v9 = 0;
      while (v3 != v6 || v7 != v9)
      {
        applesauce::CF::details::at_to<applesauce::CF::DictionaryRef>(v3, v9, (applesauce::CF::DictionaryRef *)&v16);
        if (!v16)
        {
          uint64_t v12 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x21D48F410](v12, "Could not construct");
        }
        CFTypeRef cf = @"Type";
        unsigned int v14 = 0;
        int v10 = applesauce::CF::at_or<unsigned int,__CFString const*>((const __CFDictionary *)v16, &cf, &v14);
        if (v16) {
          CFRelease(v16);
        }
        if (v10 == a2)
        {
          if (theArray) {
            CFRelease(theArray);
          }
          uint64_t v8 = 1;
          goto LABEL_23;
        }
        if (v5 == ++v9) {
          goto LABEL_20;
        }
      }
      goto LABEL_20;
    }
  }
LABEL_22:
  uint64_t v8 = 0;
LABEL_23:
  if (v18) {
    CFRelease(v18);
  }
LABEL_25:
  if (v23) {
    CFRelease(v23);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v19[0]) {
    CFRelease(v19[0]);
  }
  return v8;
}

void sub_21B4EBDB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  CFArrayRef v6 = va_arg(va1, const void *);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va1);
  _Unwind_Resume(a1);
}

CFDataRef IR::IRData::Implementation::createSoundProfilePack(CFTypeRef *this, CFTypeRef *a2, CFTypeRef cf, const void *a4, const __CFString *a5)
{
  v47[2] = *MEMORY[0x263EF8340];
  CFTypeID v9 = CFGetTypeID(cf);
  if (v9 == CFDictionaryGetTypeID())
  {
    int v10 = (__CFString *)MGCopyAnswer();
    if (!v10)
    {
      int v10 = &stru_26CB57E20;
      CFRetain(&stru_26CB57E20);
    }
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v42, v10);
    CFTypeRef v40 = CFStringCreateWithBytes(0, (const UInt8 *)"HRIR_ITDMod", 11, 0x8000100u, 0);
    if (!v40)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    SerializedIRCFDataRef Data = (const void *)IR::IRData::Implementation::createSerializedIRData(this, 1, 0);
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v39, SerializedIRData);
    applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::DataRef>(v43, &v40, &v39);
    CFTypeRef v38 = CFStringCreateWithBytes(0, (const UInt8 *)"HRIR_DFEQ", 9, 0x8000100u, 0);
    if (!v38)
    {
      uint64_t v28 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v28, "Could not construct");
    }
    uint64_t v12 = (const void *)IR::IRData::Implementation::createSerializedIRData(a2, 1, 0);
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v37, v12);
    applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::DataRef>(&v44, &v38, &v37);
    CFTypeRef v36 = CFStringCreateWithBytes(0, (const UInt8 *)"EQ", 2, 0x8000100u, 0);
    if (!v36)
    {
      unint64_t v29 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v29, "Could not construct");
    }
    if (cf) {
      CFRetain(cf);
    }
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v35, cf);
    applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::DictionaryRef>(&v45, &v36, &v35);
    CFTypeRef v34 = CFStringCreateWithBytes(0, (const UInt8 *)"version", 7, 0x8000100u, 0);
    if (!v34)
    {
      CFTypeRef v30 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v30, "Could not construct");
    }
    if (a4) {
      CFRetain(a4);
    }
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v33, a4);
    applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::StringRef>(&v46, &v34, &v33);
    CFTypeRef cfa = CFStringCreateWithBytes(0, (const UInt8 *)"device", 6, 0x8000100u, 0);
    if (!cfa)
    {
      BOOL v31 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v31, "Could not construct");
    }
    applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::StringRef&>(v47, &cfa, &v42);
    v41[0] = v43;
    v41[1] = 5;
    CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v41);
    uint64_t v14 = 0;
    v41[2] = CFDictionaryRef;
    do
    {
      unsigned int v15 = (const void *)v47[v14 + 1];
      if (v15) {
        CFRelease(v15);
      }
      CFTypeRef v16 = (const void *)v47[v14];
      if (v16) {
        CFRelease(v16);
      }
      v14 -= 2;
    }
    while (v14 != -10);
    if (cfa) {
      CFRelease(cfa);
    }
    if (v33) {
      CFRelease(v33);
    }
    if (v34) {
      CFRelease(v34);
    }
    if (v35) {
      CFRelease(v35);
    }
    if (v36) {
      CFRelease(v36);
    }
    if (v37) {
      CFRelease(v37);
    }
    if (v38) {
      CFRelease(v38);
    }
    if (v39) {
      CFRelease(v39);
    }
    if (v40) {
      CFRelease(v40);
    }
    CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x263EFFB08], CFDictionaryRef, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (CFDictionaryRef) {
      CFRelease(CFDictionaryRef);
    }
    if (v42) {
      CFRelease(v42);
    }
  }
  else
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    CFTypeRef v18 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createSoundProfilePack(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    return 0;
  }
  return Data;
}

void sub_21B4EC308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, char a10, CFTypeRef a11, char a12, CFTypeRef a13, char a14, CFTypeRef a15, char a16, CFTypeRef a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t IR::IRData::Implementation::createSerializedIRData(CFTypeRef *a1, int a2, int a3)
{
  uint64_t v110 = *MEMORY[0x263EF8340];
  CFArrayRef v3 = *a1;
  if (*((unsigned char *)*a1 + 24))
  {
    __N[0] = v3[2];
    unint64_t v7 = v3[7];
    int v94 = v3[8];
    uint64_t v91 = 0;
    uint64_t v92 = 0;
    uint64_t v93 = 0;
    memset(v90, 0, sizeof(v90));
    uint64_t v87 = 0;
    uint64_t v88 = 0;
    uint64_t v89 = 0;
    std::vector<float>::vector(v86, (v94 * __N[0]));
    std::vector<float>::vector(v85, v7);
    uint64_t v8 = (uint64_t)*a1;
    if (*((unsigned char *)*a1 + 488))
    {
      uint64_t v107 = 0;
      CFTypeID v9 = operator new(0x48uLL);
      *CFTypeID v9 = &unk_26CB57668;
      v9[1] = a1;
      v9[2] = v85;
      v9[3] = &v91;
      v9[4] = &v94;
      v9[5] = __N;
      v9[6] = v86;
      v9[7] = &v87;
      v9[8] = v90;
      int v10 = v106;
      uint64_t v107 = v9;
      IR::IRData::Implementation::forEachNode(v8, (uint64_t)v106, 0, 0);
    }
    else
    {
      unsigned int v109 = 0;
      uint64_t v19 = operator new(0x40uLL);
      *uint64_t v19 = &unk_26CB57620;
      v19[1] = v85;
      void v19[2] = &v94;
      v19[3] = __N;
      v19[4] = v86;
      CFTypeRef v19[5] = &v87;
      v19[6] = v90;
      v19[7] = &v91;
      int v10 = v108;
      unsigned int v109 = v19;
      IR::IRData::Implementation::forEachNode(v8, (uint64_t)v108, 0, 0);
    }
    std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v10);
    IR::IRData::Implementation::getUserData(*a1, &v84);
    if (v84)
    {
      *(void *)&__N[1] = &v84;
      CFNumberRef v20 = applesauce::CF::DictionaryRef_proxy::at_as<float,char const(&)[21]>((const __CFDictionary ***)&__N[1], "DiffuseFieldPowerRMS");
      if (fabsf(*(float *)&v20) <= 0.00000011921 || ((unint64_t)v20 & 0xFF00000000) == 0) {
        float v22 = 1.0;
      }
      else {
        float v22 = *(float *)&v20;
      }
    }
    else
    {
      float v22 = 1.0;
    }
    unint64_t v83 = 0xAAAAAAAAAAAAAAABLL * ((v92 - v91) >> 3);
    float __B = 0.0;
    if (a3)
    {
      float __B = 1.0;
    }
    else
    {
      __N[1] = 0;
      uint64_t v23 = v87;
      if (v88 == v87)
      {
        float v25 = 0.0;
      }
      else
      {
        uint64_t v24 = 0;
        float v25 = 0.0;
        unsigned int v26 = 1;
        do
        {
          vDSP_maxmgv(*(const float **)(v23 + 24 * v24), 1, (float *)&__N[1], (uint64_t)(*(void *)(v23 + 24 * v24 + 8) - *(void *)(v23 + 24 * v24)) >> 2);
          if (*(float *)&__N[1] > v25) {
            float v25 = *(float *)&__N[1];
          }
          uint64_t v24 = v26;
          uint64_t v23 = v87;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((v88 - v87) >> 3) > v26++);
      }
      float __B = (float)(v22 * v25) * 0.000030518;
    }
    CFTypeRef cf = 0;
    memset(v80, 0, sizeof(v80));
    CFTypeRef v28 = *a1;
    unint64_t v78 = 0;
    uint64_t v79 = 0;
    uint64_t v77 = 0;
    std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>(&v77, *((const void **)v28 + 25), *((void *)v28 + 26), (uint64_t)(*((void *)v28 + 26) - *((void *)v28 + 25)) >> 2);
    CFTypeRef v29 = *a1;
    unint64_t v75 = 0;
    uint64_t v76 = 0;
    int v74 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v74, *((const void **)v29 + 16), *((void *)v29 + 17), (uint64_t)(*((void *)v29 + 17) - *((void *)v29 + 16)) >> 2);
    CFTypeRef v30 = *a1;
    long long v31 = *((_OWORD *)*a1 + 15);
    v72[0] = *((_OWORD *)*a1 + 14);
    v72[1] = v31;
    int v73 = *((_DWORD *)v30 + 64);
    uint64_t v69 = 0;
    std::vector<unsigned int>::size_type v70 = 0;
    uint64_t v71 = 0;
    std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>(&v69, *((const void **)v30 + 10), *((void *)v30 + 11), (uint64_t)(*((void *)v30 + 11) - *((void *)v30 + 10)) >> 2);
    if (v7)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        IR::IRCoordinates::getParameterString(*((_DWORD *)v69 + i), &__p);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[5],std::string>((applesauce::CF::TypeRef *)&__N[1], "Name", (uint64_t)&__p);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>((applesauce::CF::TypeRef *)v96, "Periodicity", (int *)v74 + i);
        LODWORD(v59[0]) = *((_DWORD *)v77 + i);
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[14],int>((applesauce::CF::TypeRef *)v97, "Interpolation", (int *)v59);
        LODWORD(v55[0]) = IR::IRCoordinates::get((uint64_t)v72, *((_DWORD *)v69 + i));
        applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float>((applesauce::CF::TypeRef *)v98, "DefaultValue", (int *)v55);
        __n128 __C = &__N[1];
        uint64_t v68 = 4;
        CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&__C);
        CFTypeRef v34 = cf;
        CFTypeRef cf = CFDictionaryRef;
        if (v34) {
          CFRelease(v34);
        }
        for (uint64_t j = 0; j != -64; j -= 16)
        {
          CFTypeRef v36 = *(const void **)&v98[j + 8];
          if (v36) {
            CFRelease(v36);
          }
          CFTypeRef v37 = *(const void **)&v98[j];
          if (v37) {
            CFRelease(v37);
          }
        }
        if (v66 < 0) {
          operator delete(__p);
        }
        std::vector<applesauce::CF::DictionaryRef>::push_back[abi:ne180100](v80, &cf);
      }
    }
    CFTypeRef v64 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)v80);
    IR::IRData::getTriangulationData((IR::IRData::Implementation **)a1, (CFDictionaryRef *)&v63);
    if (a3) {
      CFTypeRef v38 = "float32";
    }
    else {
      CFTypeRef v38 = "int16";
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, v38);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],std::string>((applesauce::CF::TypeRef *)&__N[1], "CoefficientFormat", (uint64_t)&__p);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],unsigned int &>((applesauce::CF::TypeRef *)v96, "FilterLength", __N);
    int v61 = *(_DWORD *)*a1;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>((applesauce::CF::TypeRef *)v97, "SampleRate", &v61);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],char const(&)[8]>((applesauce::CF::TypeRef *)v98, "DelayFormat", "float32");
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[20],unsigned long &>((applesauce::CF::TypeRef *)&v99, "TotalNumCoordinates", (uint64_t *)&v83);
    CFTypeRef v39 = v84;
    if (v84)
    {
      CFRetain(v84);
    }
    else
    {
      v59[0] = 0;
      v59[1] = 0;
      CFTypeRef v39 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v59);
    }
    CFTypeRef v60 = v39;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],applesauce::CF::DictionaryRef>((applesauce::CF::TypeRef *)&v100, "UserData", &v60);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],applesauce::CF::ArrayRef &>((applesauce::CF::TypeRef *)&v101, "Dimensions", &v64);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>((applesauce::CF::TypeRef *)&v102, "FilterScaleFactor", (int *)&__B);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],unsigned int &>((applesauce::CF::TypeRef *)&v103, "NumChannels", &v94);
    IR::IRData::Implementation::getDescription(*a1, &v57);
    if (v57) {
      IR::IRData::Implementation::getDescription(*a1, &v58);
    }
    else {
      applesauce::CF::make_StringRef(&stru_26CB57E20, (applesauce::CF::StringRef *)&v58);
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],applesauce::CF::StringRef>((applesauce::CF::TypeRef *)&v104, "Description", &v58);
    CFTypeRef v40 = v63;
    if (v63 && a2)
    {
      CFRetain(v63);
    }
    else
    {
      v55[0] = 0;
      v55[1] = 0;
      CFTypeRef v40 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v55);
    }
    CFTypeRef v56 = v40;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],applesauce::CF::DictionaryRef>((applesauce::CF::TypeRef *)v105, "TriangulationData", &v56);
    __n128 __C = &__N[1];
    uint64_t v68 = 11;
    CFDictionaryRef v41 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&__C);
    uint64_t v42 = 0;
    CFDictionaryRef v62 = v41;
    do
    {
      unsigned int v43 = *(const void **)&v105[v42 + 8];
      if (v43) {
        CFRelease(v43);
      }
      uint64_t v44 = *(const void **)&v105[v42];
      if (v44) {
        CFRelease(v44);
      }
      v42 -= 16;
    }
    while (v42 != -176);
    if (v56) {
      CFRelease(v56);
    }
    if (v58) {
      CFRelease(v58);
    }
    if (v57) {
      CFRelease(v57);
    }
    if (v60) {
      CFRelease(v60);
    }
    if (v66 < 0) {
      operator delete(__p);
    }
    CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x263EFFB08], v41, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      CFDataGetLength(Data);
      operator new[]();
    }
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v46 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createSerializedIRData(v46, v47, v48, v49, v50, v51, v52, v53);
    }
    if (v41) {
      CFRelease(v41);
    }
    if (v63) {
      CFRelease(v63);
    }
    if (v64) {
      CFRelease(v64);
    }
    if (v69)
    {
      std::vector<unsigned int>::size_type v70 = v69;
      operator delete(v69);
    }
    if (v74)
    {
      unint64_t v75 = v74;
      operator delete(v74);
    }
    if (v77)
    {
      unint64_t v78 = v77;
      operator delete(v77);
    }
    *(void *)&__N[1] = v80;
    std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&__N[1]);
    if (cf) {
      CFRelease(cf);
    }
    if (v84) {
      CFRelease(v84);
    }
    if (v85[0])
    {
      v85[1] = v85[0];
      operator delete(v85[0]);
    }
    if (v86[0])
    {
      v86[1] = v86[0];
      operator delete(v86[0]);
    }
    *(void *)&__N[1] = &v87;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__N[1]);
    *(void *)&__N[1] = v90;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__N[1]);
    *(void *)&__N[1] = &v91;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__N[1]);
  }
  else
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    CFIndex v11 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createSerializedIRData(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  return 0;
}

void sub_21B4ED01C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,uint64_t a21,uint64_t a22,const void *a23,const void *a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,const void *a50,uint64_t a51,uint64_t a52,const void *a53,void *a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,char a63)
{
  applesauce::CF::StringRef::~StringRef(&a16);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a20);
  if (a30 < 0) {
    operator delete(__p);
  }
  while (v70 != (applesauce::CF::TypeRefPair *)&a70)
  {
    std::vector<unsigned int>::size_type v70 = (applesauce::CF::TypeRefPair *)((char *)v70 - 16);
    applesauce::CF::TypeRefPair::~TypeRefPair(v70);
  }
  applesauce::CF::DictionaryRef::~DictionaryRef(&a23);
  applesauce::CF::ArrayRef::~ArrayRef(&a24);
  if (a33)
  {
    a34 = (uint64_t)a33;
    operator delete(a33);
  }
  if (a41)
  {
    a42 = (uint64_t)a41;
    operator delete(a41);
  }
  if (a44)
  {
    a45 = (uint64_t)a44;
    operator delete(a44);
  }
  a70 = &a47;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&a70);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a50);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a53);
  if (a54)
  {
    a55 = (uint64_t)a54;
    operator delete(a54);
  }
  if (a57)
  {
    a58 = (uint64_t)a57;
    operator delete(a57);
  }
  a70 = &a60;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a70);
  a70 = &a63;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a70);
  a70 = &a66;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a70);
  _Unwind_Resume(a1);
}

CFDictionaryRef IR::IRData::Implementation::createSoundProfileMetaDataDictionary(IR::IRData::Implementation *this, const __CFData *a2)
{
  v35[2] = *MEMORY[0x263EF8340];
  if (!CFDataGetLength(this))
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v8 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createSoundProfileMetaDataDictionary(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    return 0;
  }
  CFPropertyListRef v3 = CFPropertyListCreateWithData(0, this, 1uLL, 0, 0);
  if (!v3)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v16 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createSoundProfileMetaDataDictionary(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    return 0;
  }
  applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v33, v3);
  if (!v33) {
    return 0;
  }
  CFTypeRef v30 = CFStringCreateWithBytes(0, (const UInt8 *)"", 0, 0x8000100u, 0);
  if (!v30)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  applesauce::CF::at_or<applesauce::CF::StringRef,char const* const&>((const __CFDictionary *)v33, (const char **)IR::kCloudIRDataKey_Version, &v30, &v31);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::StringRef>((applesauce::CF::TypeRef *)v34, IR::kCloudIRDataKey_Version, &v31);
  if (!v33)
  {
    unsigned int v26 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v26, "Could not construct");
  }
  CFTypeRef v28 = CFStringCreateWithBytes(0, (const UInt8 *)"", 0, 0x8000100u, 0);
  if (!v28)
  {
    uint64_t v27 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v27, "Could not construct");
  }
  applesauce::CF::at_or<applesauce::CF::StringRef,char const* const&>((const __CFDictionary *)v33, (const char **)&IR::kCloudIRDataKey_DeviceName, &v28, &cf);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::StringRef>((applesauce::CF::TypeRef *)v35, &IR::kCloudIRDataKey_DeviceName, &cf);
  v32[0] = v34;
  v32[1] = 2;
  CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v32);
  for (uint64_t i = 0; i != -4; i -= 2)
  {
    CFArrayRef v6 = (const void *)v35[i + 1];
    if (v6) {
      CFRelease(v6);
    }
    unint64_t v7 = *(const void **)&v34[i * 8 + 16];
    if (v7) {
      CFRelease(v7);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v28) {
    CFRelease(v28);
  }
  if (v31) {
    CFRelease(v31);
  }
  if (v30) {
    CFRelease(v30);
  }
  if (v33) {
    CFRelease(v33);
  }
  return CFDictionaryRef;
}

void sub_21B4ED65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, char a10, CFTypeRef a11, const void *a12, uint64_t a13, uint64_t a14, const void *a15, __int16 a16, char a17, char a18)
{
  if (cf) {
    CFRelease(cf);
  }
  applesauce::CF::StringRef::~StringRef(&a12);
  applesauce::CF::StringRef::~StringRef(&a11);
  while (v18 != (applesauce::CF::TypeRefPair *)&a16)
  {
    uint64_t v18 = (applesauce::CF::TypeRefPair *)((char *)v18 - 16);
    applesauce::CF::TypeRefPair::~TypeRefPair(v18);
  }
  applesauce::CF::DictionaryRef::~DictionaryRef(&a15);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::getSoundProfileVersion(IR::IRData::Implementation *this@<X0>, std::string *a2@<X8>)
{
  if (!CFDataGetLength(this))
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    CFArrayRef v6 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::getSoundProfileVersion(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    goto LABEL_16;
  }
  CFPropertyListRef v5 = CFPropertyListCreateWithData(0, this, 1uLL, 0, 0);
  if (!v5)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v14 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::getSoundProfileVersion(v14, v15, v16, v17, v18, v19, v20, v21);
    }
    goto LABEL_16;
  }
  applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, v5);
  if (!cf)
  {
LABEL_16:
    a2->__r_.__value_.__r.__words[0] = 0;
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    return;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v23 = 0;
  applesauce::CF::at_or<std::string,char const* const&>((const __CFDictionary *)cf, (const char **)IR::kCloudIRDataKey_Version, (uint64_t)__p, a2);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  if (cf) {
    CFRelease(cf);
  }
}

CFDictionaryRef IR::IRData::Implementation::createDictionaryIRData(unsigned int **this, const IR::IRData *a2)
{
  int v2 = (int)a2;
  uint64_t v73 = *MEMORY[0x263EF8340];
  unsigned int v4 = *this;
  if (*((unsigned char *)*this + 24) || !v4[4])
  {
    unint64_t v5 = v4[2];
    unint64_t v6 = v4[7];
    unint64_t v7 = v4[8];
    memset(v61, 0, sizeof(v61));
    memset(v60, 0, sizeof(v60));
    memset(v59, 0, sizeof(v59));
    std::vector<float>::vector(v62, v5);
    std::vector<std::vector<float>>::vector(v58, v7, (uint64_t)v62);
    if (v62[0])
    {
      v62[1] = v62[0];
      operator delete(v62[0]);
    }
    std::vector<float>::vector(v57, v6);
    IR::IRData::Implementation::vectorizeIRData<std::vector<float>>((uint64_t)*this, v61, v60, (uint64_t *)v59);
    uint64_t v8 = (uint64_t)*this;
    float v55 = 0;
    uint64_t v56 = 0;
    unsigned int v54 = 0;
    std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>(&v54, *(const void **)(v8 + 200), *(void *)(v8 + 208), (uint64_t)(*(void *)(v8 + 208) - *(void *)(v8 + 200)) >> 2);
    uint64_t v9 = (uint64_t)*this;
    long long v10 = *((_OWORD *)*this + 15);
    v52[0] = *((_OWORD *)*this + 14);
    v52[1] = v10;
    int v53 = *(_DWORD *)(v9 + 256);
    int v51 = 0;
    memset(v50, 0, sizeof(v50));
    IR::IRCoordinates::getAllCoordinates((uint64_t)v50);
    uint64_t v11 = (uint64_t)*this;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    uint64_t v47 = 0;
    std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>(&v47, *(const void **)(v11 + 80), *(void *)(v11 + 88), (uint64_t)(*(void *)(v11 + 88) - *(void *)(v11 + 80)) >> 2);
    std::vector<unsigned int>::vector(&v46, v6);
    std::vector<unsigned int>::vector(&v45, v6);
    std::vector<float>::vector(__p, 9uLL);
    for (uint64_t i = 0; i != 36; i += 4)
    {
      float v13 = IR::IRCoordinates::get((uint64_t)v52, *(_DWORD *)&v50[i]);
      *(float *)((char *)__p[0] + i) = v13;
    }
    if (v6)
    {
      uint64_t v14 = (unsigned int *)v47;
      std::vector<unsigned int>::pointer begin = v46.__begin_;
      uint64_t v16 = (unsigned int *)v54;
      std::vector<unsigned int>::pointer v17 = v45.__begin_;
      do
      {
        unsigned int v18 = *v14++;
        *begin++ = v18;
        unsigned int v19 = *v16++;
        *v17++ = v19;
        --v6;
      }
      while (v6);
    }
    IR::IRData::getTriangulationData((IR::IRData::Implementation **)this, (CFDictionaryRef *)&cf);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],std::vector<std::vector<std::vector<float>>> &>((applesauce::CF::TypeRef *)v62, "coefficients", v59);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],std::vector<std::vector<float>> &>((applesauce::CF::TypeRef *)&v63, "coordinates", v61);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[7],std::vector<std::vector<float>> &>((applesauce::CF::TypeRef *)&v64, "delays", v60);
    unsigned int v41 = **this;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>((applesauce::CF::TypeRef *)&v65, "sampleRate", (int *)&v41);
    IR::IRData::Implementation::getDescription(*this, &v39);
    if (v39) {
      IR::IRData::Implementation::getDescription(*this, &v40);
    }
    else {
      applesauce::CF::make_StringRef(&stru_26CB57E20, (applesauce::CF::StringRef *)&v40);
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],applesauce::CF::StringRef>((applesauce::CF::TypeRef *)&v66, "description", &v40);
    IR::IRData::Implementation::getUserData(*this, &v37);
    if (v37)
    {
      IR::IRData::Implementation::getUserData(*this, &CFDictionaryRef);
    }
    else
    {
      v36[0] = 0;
      v36[1] = 0;
      CFTypeRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v36);
    }
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],applesauce::CF::DictionaryRef>((applesauce::CF::TypeRef *)&v67, "userData", &CFDictionaryRef);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[21],std::vector<unsigned int> &>((applesauce::CF::TypeRef *)&v68, "interpolationMethods", &v45);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],std::vector<unsigned int> &>((applesauce::CF::TypeRef *)&v69, "dimensions", &v46);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[19],std::vector<float> &>((applesauce::CF::TypeRef *)&v70, "defaultCoordinates", __p);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[29],std::vector<float> const&>((applesauce::CF::TypeRef *)&v71, "periodsForCyclicalDimensions", (void *)*this + 16);
    CFTypeRef v29 = cf;
    if (cf && v2)
    {
      CFRetain(cf);
    }
    else
    {
      v34[0] = 0;
      v34[1] = 0;
      CFTypeRef v29 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v34);
    }
    CFTypeRef v35 = v29;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],applesauce::CF::DictionaryRef>((applesauce::CF::TypeRef *)v72, "triangulationData", &v35);
    v42[0] = v62;
    v42[1] = 11;
    CFDictionaryRef v28 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v42);
    for (uint64_t j = 0; j != -176; j -= 16)
    {
      CFTypeRef v31 = *(const void **)&v72[j + 8];
      if (v31) {
        CFRelease(v31);
      }
      CFTypeRef v32 = *(const void **)&v72[j];
      if (v32) {
        CFRelease(v32);
      }
    }
    if (v35) {
      CFRelease(v35);
    }
    if (CFDictionaryRef) {
      CFRelease(CFDictionaryRef);
    }
    if (v37) {
      CFRelease(v37);
    }
    if (v40) {
      CFRelease(v40);
    }
    if (v39) {
      CFRelease(v39);
    }
    if (cf) {
      CFRelease(cf);
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v45.__begin_)
    {
      v45.__end_ = v45.__begin_;
      operator delete(v45.__begin_);
    }
    if (v46.__begin_)
    {
      v46.__end_ = v46.__begin_;
      operator delete(v46.__begin_);
    }
    if (v47)
    {
      uint64_t v48 = v47;
      operator delete(v47);
    }
    if (v54)
    {
      float v55 = v54;
      operator delete(v54);
    }
    if (v57[0])
    {
      v57[1] = v57[0];
      operator delete(v57[0]);
    }
    v62[0] = (void **)v58;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v62);
    v62[0] = (void **)v59;
    std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](v62);
    v62[0] = (void **)v60;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v62);
    v62[0] = (void **)v61;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v62);
  }
  else
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v20 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createDictionaryIRData(v20, v21, v22, v23, v24, v25, v26, v27);
    }
    return 0;
  }
  return v28;
}

void sub_21B4EDDF4(_Unwind_Exception *a1)
{
}

uint64_t IR::IRData::getMixedTimeFrequencyDomain(IR::IRData *this)
{
  return *(unsigned __int8 *)(*(void *)this + 24);
}

uint64_t IR::IRData::getPartitionLength(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 16);
}

uint64_t IR::IRData::getNumDimensions(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 28);
}

uint64_t IR::IRData::getFilterLength(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 8);
}

uint64_t IR::IRData::getNumFiltersPerSpatialPoint(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 32);
}

void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  std::vector<std::vector<float>>::resize(a2, 0);
  std::vector<std::vector<float>>::resize(a3, 0);
  std::vector<std::vector<std::vector<float>>>::resize(a4, 0);
  unint64_t v8 = *(unsigned int *)(a1 + 28);
  int v12 = 0;
  std::vector<float>::vector(__p, v8, &v12);
  if (*(unsigned char *)(a1 + 488))
  {
    uint64_t v15 = 0;
    uint64_t v9 = operator new(0x30uLL);
    *uint64_t v9 = &unk_26CB57308;
    v9[1] = a1;
    v9[2] = __p;
    v9[3] = a2;
    v9[4] = a4;
    v9[5] = a3;
    long long v10 = v14;
    uint64_t v15 = v9;
    IR::IRData::Implementation::forEachNode(a1, (uint64_t)v14, 0, 0);
  }
  else
  {
    std::vector<unsigned int>::pointer v17 = 0;
    uint64_t v11 = operator new(0x30uLL);
    *uint64_t v11 = &unk_26CB57350;
    v11[1] = __p;
    v11[2] = a3;
    void v11[3] = a2;
    v11[4] = a1;
    v11[5] = a4;
    long long v10 = v16;
    std::vector<unsigned int>::pointer v17 = v11;
    IR::IRData::Implementation::forEachNode(a1, (uint64_t)v16, 0, 0);
  }
  std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v10);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_21B4EE1A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::getInterpolationMethod(IR::IRData *this)
{
  return *(void *)this + 200;
}

__n128 IR::IRData::getDefaultCoordinates@<Q0>(__n128 **this@<X0>, __n128 *a2@<X8>)
{
  int v2 = *this;
  __n128 result = (*this)[14];
  __n128 v4 = (*this)[15];
  *a2 = result;
  a2[1] = v4;
  a2[2].n128_u32[0] = v2[16].n128_u32[0];
  return result;
}

uint64_t IR::IRData::getDataLayout(IR::IRData *this)
{
  return *(void *)this + 80;
}

float IR::IRData::getSampleRate(IR::IRData *this)
{
  return **(float **)this;
}

CFTypeRef IR::IRData::getDescription@<X0>(CFTypeRef *this@<X0>, void *a2@<X8>)
{
  return IR::IRData::Implementation::getDescription(*this, a2);
}

applesauce::CF::StringRef *applesauce::CF::make_StringRef@<X0>(CFStringRef format@<X0>, applesauce::CF::StringRef *a2@<X8>, ...)
{
  va_start(va, a2);
  CFStringRef v4 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  if (!v4)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return applesauce::CF::StringRef::StringRef(a2, v4);
}

void sub_21B4EE290()
{
}

void sub_21B4EE2B0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

CFTypeRef IR::IRData::getUserData@<X0>(CFTypeRef *this@<X0>, void *a2@<X8>)
{
  return IR::IRData::Implementation::getUserData(*this, a2);
}

uint64_t IR::IRData::getPeriodForCyclicalDimensions(IR::IRData *this)
{
  return *(void *)this + 128;
}

uint64_t IR::IRData::Implementation::createSerializedIRData(CFTypeRef **a1, int a2, int a3)
{
  CFPropertyListRef v3 = *a1;
  if (v3)
  {
    return IR::IRData::Implementation::createSerializedIRData(v3, a2, a3);
  }
  else
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    unint64_t v5 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createSerializedIRData(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    return 0;
  }
}

uint64_t IR::IRData::usesVBAP(IR::IRData *this)
{
  return *(unsigned __int8 *)(*(void *)this + 488);
}

uint64_t IR::IRData::Implementation::forEachNode(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = result;
  v15[4] = *MEMORY[0x263EF8340];
  if (a3)
  {
    __n128 result = std::function<void ()(IR::IRDataNode &,unsigned int)>::operator()(a2, a3, a4);
    uint64_t v8 = *(void *)(a3 + 72);
    uint64_t v9 = *(void *)(a3 + 80);
    if (v8 != v9)
    {
      uint64_t v10 = (a4 + 1);
      do
      {
        std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v14, a2);
        IR::IRData::Implementation::forEachNode(v5, v14, v8, v10);
        __n128 result = (uint64_t)std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v14);
        v8 += 96;
      }
      while (v8 != v9);
    }
  }
  else
  {
    uint64_t v11 = *(uint64_t **)(result + 264);
    uint64_t v12 = *v11;
    uint64_t v13 = v11[1];
    while (v12 != v13)
    {
      std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v15, a2);
      IR::IRData::Implementation::forEachNode(v5, v15, v12, 0);
      __n128 result = (uint64_t)std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v15);
      v12 += 96;
    }
  }
  return result;
}

{
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  void v14[4];
  void v15[5];

  uint64_t v5 = result;
  v15[4] = *MEMORY[0x263EF8340];
  if (a3)
  {
    __n128 result = std::function<void ()(IR::IRDataNode const&,unsigned int)>::operator()(a2, a3, a4);
    uint64_t v8 = *(void *)(a3 + 72);
    uint64_t v9 = *(void *)(a3 + 80);
    if (v8 != v9)
    {
      uint64_t v10 = (a4 + 1);
      do
      {
        std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v14, a2);
        IR::IRData::Implementation::forEachNode(v5, v14, v8, v10);
        __n128 result = (uint64_t)std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::~__value_func[abi:ne180100](v14);
        v8 += 96;
      }
      while (v8 != v9);
    }
  }
  else
  {
    uint64_t v11 = *(uint64_t **)(result + 264);
    uint64_t v12 = *v11;
    uint64_t v13 = v11[1];
    while (v12 != v13)
    {
      std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v15, a2);
      IR::IRData::Implementation::forEachNode(v5, v15, v12, 0);
      __n128 result = (uint64_t)std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::~__value_func[abi:ne180100](v15);
      v12 += 96;
    }
  }
  return result;
}

void sub_21B4EE47C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<applesauce::CF::DictionaryRef>::push_back[abi:ne180100](char **a1, CFTypeRef *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - (void)*a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)*a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v25 = v4;
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(v4, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v10];
    uint64_t v16 = &v14[8 * v13];
    uint64_t v24 = v16;
    std::construct_at[abi:ne180100]<applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef const&,applesauce::CF::DictionaryRef*>(v15, a2);
    uint64_t v9 = v15 + 8;
    v23.i64[1] = (uint64_t)(v15 + 8);
    uint64_t v18 = *a1;
    std::vector<unsigned int>::pointer v17 = a1[1];
    if (v17 == *a1)
    {
      int64x2_t v20 = vdupq_n_s64((unint64_t)v17);
    }
    else
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v15 - 1) = v19;
        v15 -= 8;
        *(void *)std::vector<unsigned int>::pointer v17 = 0;
      }
      while (v17 != v18);
      int64x2_t v20 = *(int64x2_t *)a1;
      uint64_t v9 = (char *)v23.i64[1];
      uint64_t v16 = v24;
    }
    *a1 = v15;
    a1[1] = v9;
    int64x2_t v23 = v20;
    uint64_t v21 = a1[2];
    a1[2] = v16;
    uint64_t v24 = v21;
    uint64_t v22 = v20.i64[0];
    uint64_t result = std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    uint64_t result = (uint64_t)std::construct_at[abi:ne180100]<applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef const&,applesauce::CF::DictionaryRef*>(*(void **)(v4 - 8), a2);
    uint64_t v9 = (char *)(v7 + 8);
  }
  a1[1] = v9;
  return result;
}

__CFData *IR::IRData::Implementation::createSerializedIRDataWithNoise(IR::IRData::Implementation *this, const __CFData *a2)
{
  uint64_t v123 = *MEMORY[0x263EF8340];
  BytePtr = (UInt8 *)CFDataGetBytePtr(this);
  CFIndex Length = CFDataGetLength(this);
  unint64_t v5 = fmemopen(BytePtr, Length, "r");
  v118[0] = v5;
  v118[1] = (FILE *)MEMORY[0x263EF88A8];
  if (v5)
  {
    unint64_t v6 = v5;
    uint64_t FileByteSize = IR::IRData::Implementation::getFileByteSize(v118);
    int v117 = 0;
    IR::IRData::Implementation::readIRPlist(v118, &v117, &v116);
    CFDictionaryRef v8 = v116;
    if (!v116)
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      CFTypeRef v30 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::createSerializedIRDataWithNoise(v30, v31, v32, v33, v34, v35, v36, v37);
      }
      MutableCopy = 0;
      goto LABEL_45;
    }
    __p.__x_[0] = 0;
    unsigned int v9 = applesauce::CF::at_or<unsigned int,char const(&)[13]>(v116, "FilterLength", __p.__x_);
    if (v9)
    {
      unsigned int v10 = v9;
      __p.__x_[0] = 0;
      unsigned int v11 = applesauce::CF::at_or<unsigned int,char const(&)[20]>(v8, "TotalNumCoordinates", __p.__x_);
      if (v11)
      {
        unsigned int v12 = v11;
        __p.__x_[0] = 0;
        unsigned int v13 = applesauce::CF::at_or<unsigned int,char const(&)[12]>(v8, "NumChannels", __p.__x_);
        if (v13)
        {
          unsigned int v14 = v13;
          memset(&__p, 0, 24);
          applesauce::CF::at_or<std::string,char const(&)[18]>(v8, "CoefficientFormat", (uint64_t)&__p, &v115);
          if (SHIBYTE(__p.__x_[5]) < 0) {
            operator delete(*(void **)__p.__x_);
          }
          if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(v115.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = v115.__r_.__value_.__l.__size_;
          }
          if (size == 7)
          {
            if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v63 = &v115;
            }
            else {
              uint64_t v63 = (std::string *)v115.__r_.__value_.__r.__words[0];
            }
            if (memcmp(v63, "float32", 7uLL))
            {
LABEL_51:
              if (IR::getIRDataLog(void)::onceToken != -1) {
                dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
              }
              if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
                IR::IRData::Implementation::createSerializedIRDataWithNoise();
              }
LABEL_73:
              MutableCopy = 0;
LABEL_74:
              if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v115.__r_.__value_.__l.__data_);
              }
              goto LABEL_44;
            }
            int v97 = 0;
            char v20 = 2;
          }
          else
          {
            if (size != 5) {
              goto LABEL_51;
            }
            uint64_t v16 = &v115;
            if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v16 = (std::string *)v115.__r_.__value_.__r.__words[0];
            }
            int data = (int)v16->__r_.__value_.__l.__data_;
            int v18 = v16->__r_.__value_.__s.__data_[4];
            if (data != 829714025 || v18 != 54) {
              goto LABEL_51;
            }
            char v20 = 1;
            int v97 = 1;
          }
          int v113 = 0;
          float v112 = 0;
          uint64_t v114 = 0;
          applesauce::CF::at_or<std::string,char const(&)[12]>(v8, "DelayFormat", (uint64_t)&v112, (std::string *)&__p);
          if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v115.__r_.__value_.__l.__data_);
          }
          *(_OWORD *)&v115.__r_.__value_.__l.__data_ = *(_OWORD *)__p.__x_;
          v115.__r_.__value_.__r.__words[2] = *(void *)&__p.__x_[4];
          HIBYTE(__p.__x_[5]) = 0;
          LOBYTE(__p.__x_[0]) = 0;
          if (SHIBYTE(v114) < 0) {
            operator delete(v112);
          }
          std::string::size_type v64 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
          if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v64 = v115.__r_.__value_.__l.__size_;
          }
          if (v64 != 7) {
            goto LABEL_69;
          }
          uint64_t v65 = &v115;
          if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v65 = (std::string *)v115.__r_.__value_.__r.__words[0];
          }
          int v66 = (int)v65->__r_.__value_.__l.__data_;
          int v67 = *(_DWORD *)((char *)v65->__r_.__value_.__r.__words + 3);
          if (v66 != 1634692198 || v67 != 842232929)
          {
LABEL_69:
            if (IR::getIRDataLog(void)::onceToken != -1) {
              dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
            }
            if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
              IR::IRData::Implementation::createSerializedIRDataWithNoise();
            }
            goto LABEL_73;
          }
          *(void *)__p.__x_ = @"Dimensions";
          float v112 = 0;
          applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>(v8, (const void **)&__p, &v112, &v111);
          if (v112) {
            CFRelease(v112);
          }
          if (!v111)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            MEMORY[0x21D48F410](exception, "Could not construct");
          }
          unsigned int Count = CFArrayGetCount(v111);
          if (Count < 0xA)
          {
            uint64_t v70 = MEMORY[0x21D48FAE0](v6);
            char v71 = 1;
            if (!v97) {
              char v71 = 2;
            }
            if (FileByteSize - v70 >= (((unint64_t)(v14 * v10) << v71) + 4 * v14 + 4 * Count) * v12)
            {
              int v113 = 0;
              float v112 = 0;
              uint64_t v114 = 0;
              unsigned int v109 = 0;
              uint64_t v108 = 0;
              uint64_t v110 = 0;
              unint64_t v106 = 0;
              uint64_t v105 = 0;
              uint64_t v107 = 0;
              if (v97)
              {
                uint64_t v72 = (void **)&v105;
                std::vector<short>::resize((uint64_t)&v105, v10);
              }
              else
              {
                std::vector<float>::resize((uint64_t)&v112, v10);
                std::vector<float>::resize((uint64_t)&v108, v10);
                uint64_t v72 = &v112;
              }
              uint64_t v100 = (const UInt8 *)*v72;
              std::random_device::random_device[abi:ne180100](&v104);
              std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v73 = MEMORY[0x21D48F570](&v104);
              CFDictionaryRef v92 = v8;
              CFIndex v99 = (unint64_t)v10 << v20;
              __p.__x_[0] = v73;
              for (uint64_t i = 1; i != 624; ++i)
              {
                std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v73 = i + 1812433253 * (v73 ^ (v73 >> 30));
                __p.__x_[i] = v73;
              }
              __p.__i_ = 0;
              uint64_t v102 = 0x100000000;
              uint64_t v96 = v105;
              int v75 = v97;
              MutableCopy = CFDataCreateMutableCopy(0, 0, this);
              int v76 = 0;
              if (v10 <= 1) {
                uint64_t v77 = 1;
              }
              else {
                uint64_t v77 = v10;
              }
              uint64_t v95 = v77;
              if (v14 <= 1) {
                int v78 = 1;
              }
              else {
                int v78 = v14;
              }
              int v98 = v78;
              if (v12 <= 1) {
                int v79 = 1;
              }
              else {
                int v79 = v12;
              }
              int v93 = v79;
              do
              {
                int v94 = v76;
                fseek(v6, 4 * Count, 1);
                for (int j = 0; j != v98; ++j)
                {
                  CFIndex v81 = MEMORY[0x21D48FAE0](v6);
                  if (v75)
                  {
                    uint64_t v82 = v95;
                    unint64_t v83 = v96;
                    if (fread(v105, 2uLL, v10, v6) == v10)
                    {
                      do
                      {
                        *unint64_t v83 = *v83 & 0xFFFE | (std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>((int)&v102, &__p, &v102) != 0);
                        ++v83;
                        --v82;
                      }
                      while (v82);
                      CFIndex v84 = 2 * v10;
                      int v75 = v97;
                    }
                    else
                    {
                      if (IR::getIRDataLog(void)::onceToken != -1) {
                        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
                      }
                      int v75 = v97;
                      uint64_t v89 = IR::getIRDataLog(void)::gLog;
                      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR))
                      {
                        float __C = 4.8151e-34;
                        __int32 v120 = "createSerializedIRDataWithNoise";
                        __int16 v121 = 1024;
                        unsigned int v122 = v10;
                        _os_log_error_impl(&dword_21B4DD000, v89, OS_LOG_TYPE_ERROR, "IRData::%s: failed to read %d int16 values from input data", (uint8_t *)&__C, 0x12u);
                      }
                      bzero(v105, 2 * v10);
                      CFIndex v84 = 2 * v10;
                    }
                  }
                  else if (fread(v112, 4uLL, v10, v6) == v10)
                  {
                    uint64_t v85 = v108;
                    unsigned int v86 = v10;
                    do
                    {
                      std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v87 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&__p);
                      float v88 = ((double)v87
                           + (double)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&__p)
                           * 4294967300.0)
                          * 5.42101086e-20
                          + 0.0;
                      *v85++ = v88;
                      --v86;
                    }
                    while (v86);
                    float __C = 0.0;
                    vDSP_svesq(v108, 1, &__C, v10);
                    float __B = sqrtf((float)((float)v10 * 1.0e-10) / __C);
                    vDSP_vsmul(v108, 1, &__B, v108, 1, v10);
                    int v75 = v97;
                    vDSP_vadd((const float *)v112, 1, v108, 1, (float *)v112, 1, v10);
                    CFIndex v84 = 4 * v10;
                  }
                  else
                  {
                    if (IR::getIRDataLog(void)::onceToken != -1) {
                      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
                    }
                    int v90 = IR::getIRDataLog(void)::gLog;
                    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR))
                    {
                      float __C = 4.8151e-34;
                      __int32 v120 = "createSerializedIRDataWithNoise";
                      __int16 v121 = 1024;
                      unsigned int v122 = v10;
                      _os_log_error_impl(&dword_21B4DD000, v90, OS_LOG_TYPE_ERROR, "IRData::%s: failed to read %d float values from input data", (uint8_t *)&__C, 0x12u);
                    }
                    vDSP_vclr((float *)v112, 1, v10);
                    CFIndex v84 = 4 * v10;
                  }
                  v124.location = v81;
                  v124.length = v99;
                  CFDataReplaceBytes(MutableCopy, v124, v100, v84);
                  fseek(v6, 4, 1);
                }
                int v76 = v94 + 1;
              }
              while (v94 + 1 != v93);
              std::random_device::~random_device(&v104);
              if (v105)
              {
                unint64_t v106 = v105;
                operator delete(v105);
              }
              CFDictionaryRef v8 = v92;
              if (v108)
              {
                unsigned int v109 = v108;
                operator delete(v108);
              }
              if (v112)
              {
                int v113 = v112;
                operator delete(v112);
              }
              goto LABEL_92;
            }
            if (IR::getIRDataLog(void)::onceToken != -1) {
              dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
            }
            if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
              IR::IRData::Implementation::createSerializedIRDataWithNoise();
            }
          }
          else
          {
            if (IR::getIRDataLog(void)::onceToken != -1) {
              dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
            }
            if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
              IR::IRData::Implementation::createSerializedIRDataWithNoise();
            }
          }
          MutableCopy = 0;
LABEL_92:
          if (v111) {
            CFRelease(v111);
          }
          goto LABEL_74;
        }
        if (IR::getIRDataLog(void)::onceToken != -1) {
          dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
        }
        unsigned int v54 = IR::getIRDataLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          IR::IRData::Implementation::createSerializedIRDataWithNoise(v54, v55, v56, v57, v58, v59, v60, v61);
        }
      }
      else
      {
        if (IR::getIRDataLog(void)::onceToken != -1) {
          dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
        }
        std::vector<unsigned int> v46 = IR::getIRDataLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          IR::IRData::Implementation::createSerializedIRDataWithNoise(v46, v47, v48, v49, v50, v51, v52, v53);
        }
      }
    }
    else
    {
      if (IR::getIRDataLog(void)::onceToken != -1) {
        dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
      }
      CFTypeRef v38 = IR::getIRDataLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::createSerializedIRDataWithNoise(v38, v39, v40, v41, v42, v43, v44, v45);
      }
    }
    MutableCopy = 0;
LABEL_44:
    CFRelease(v8);
LABEL_45:
    v118[0] = 0;
    fclose(v6);
    return MutableCopy;
  }
  if (IR::getIRDataLog(void)::onceToken != -1) {
    dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
  }
  uint64_t v21 = IR::getIRDataLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
    IR::IRData::Implementation::createSerializedIRDataWithNoise(v21, v22, v23, v24, v25, v26, v27, v28);
  }
  return 0;
}

void sub_21B4EF0D4(_Unwind_Exception *a1)
{
  std::random_device::~random_device((std::random_device *)&STACK[0xA4C]);
  uint64_t v4 = (void *)STACK[0xA50];
  if (STACK[0xA50])
  {
    STACK[0xA58] = (unint64_t)v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)STACK[0xA68];
  if (STACK[0xA68])
  {
    STACK[0xA70] = (unint64_t)v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)STACK[0xA88];
  if (STACK[0xA88])
  {
    STACK[0xA90] = (unint64_t)v6;
    operator delete(v6);
  }
  applesauce::CF::ArrayRef::~ArrayRef((const void **)(v2 - 240));
  if (*(char *)(v2 - 185) < 0) {
    operator delete((void *)STACK[0xAA0]);
  }
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v2 - 176));
  STACK[0xAD0] = 0;
  fclose(v1);
  _Unwind_Resume(a1);
}

std::random_device *std::random_device::random_device[abi:ne180100](std::random_device *a1)
{
  std::string::basic_string[abi:ne180100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(a1, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__token.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_21B4EF224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFDataRef IR::IRData::Implementation::createNoisySoundProfilePack(IR::IRData::Implementation *this, const __CFData *a2)
{
  if (!CFDataGetLength(this))
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v15 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createNoisySoundProfilePack(v15, v16, v17, v18, v19, v20, v21, v22);
    }
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)CFPropertyListCreateWithData(0, this, 1uLL, 0, 0);
  if (!v3)
  {
    if (IR::getIRDataLog(void)::onceToken != -1) {
      dispatch_once(&IR::getIRDataLog(void)::onceToken, &__block_literal_global);
    }
    uint64_t v23 = IR::getIRDataLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getIRDataLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::createNoisySoundProfilePack(v23, v24, v25, v26, v27, v28, v29, v30);
    }
    return 0;
  }
  CFDictionaryRef v4 = v3;
  CFStringRef v5 = CFStringCreateWithCString(0, "HRIR_ITDMod", 0x8000100u);
  if (CFDictionaryContainsKey(v4, v5))
  {
    int Value = (IR::IRData::Implementation *)CFDictionaryGetValue(v4, v5);
    SerializedIRDataWithNoise = IR::IRData::Implementation::createSerializedIRDataWithNoise(Value, v7);
    CFDictionaryReplaceValue(v4, v5, SerializedIRDataWithNoise);
    CFRelease(SerializedIRDataWithNoise);
  }
  CFRelease(v5);
  CFStringRef v9 = CFStringCreateWithCString(0, "HRIR_DFEQ", 0x8000100u);
  if (CFDictionaryContainsKey(v4, v9))
  {
    unsigned int v10 = (IR::IRData::Implementation *)CFDictionaryGetValue(v4, v9);
    unsigned int v12 = IR::IRData::Implementation::createSerializedIRDataWithNoise(v10, v11);
    CFDictionaryReplaceValue(v4, v9, v12);
    CFRelease(v12);
  }
  CFRelease(v9);
  CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x263EFFB08], v4, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  CFRelease(v4);
  return Data;
}

void IR::IRData::Implementation::insertIRDataInTree(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, __n128 *a5, unsigned int a6, void *a7)
{
  CFDataRef v7 = a7;
  unsigned int v8 = a6;
  uint64_t v12 = *(void *)(a1 + 104);
  uint64_t v13 = *(void *)(a1 + 112);
  if (v13 == v12)
  {
    uint64_t v19 = 0;
    uint64_t v12 = *(void *)(a1 + 112);
  }
  else
  {
    unint64_t v14 = 0;
    do
    {
      float v15 = IR::IRCoordinates::get(a3, *(_DWORD *)(*(void *)(a1 + 80) + 4 * *(int *)(v12 + 4 * v14)));
      uint64_t v16 = *(int *)(*(void *)(a1 + 104) + 4 * v14);
      float v17 = *(float *)(*(void *)(a1 + 128) + 4 * v16);
      if (v17 != 0.0)
      {
        float v15 = fmodf(v15, *(float *)(*(void *)(a1 + 128) + 4 * v16));
        if (v15 < 0.0) {
          float v15 = v17 + v15;
        }
      }
      uint64_t v19 = *a2;
      uint64_t v18 = a2[1];
      if (*a2 == v18) {
        goto LABEL_19;
      }
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((v18 - v19) >> 5);
      do
      {
        unint64_t v21 = v20 >> 1;
        uint64_t v22 = (float *)(v19 + 96 * (v20 >> 1));
        float v24 = *v22;
        uint64_t v23 = v22 + 24;
        v20 += ~(v20 >> 1);
        if (v24 < v15) {
          uint64_t v19 = (uint64_t)v23;
        }
        else {
          unint64_t v20 = v21;
        }
      }
      while (v20);
      if (v19 == v18)
      {
LABEL_19:
        *(float *)int v67 = v15;
        *(_OWORD *)&v67[8] = 0u;
        long long v68 = 0u;
        *(_OWORD *)std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        uint64_t v72 = 0;
        std::vector<IR::IRDataNode>::push_back[abi:ne180100](a2, (uint64_t)v67);
        v73[0] = (void **)&v71;
        std::vector<IR::IRDataNode>::__destroy_vector::operator()[abi:ne180100](v73);
        if (__p[1])
        {
          *(void **)&long long v70 = __p[1];
          operator delete(__p[1]);
        }
        if (__p[0]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[0]);
        }
        v73[0] = (void **)&v67[8];
        std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](v73);
        uint64_t v19 = a2[1] - 96;
      }
      else if (*(float *)v19 != v15)
      {
        *(float *)int v67 = v15;
        *(_OWORD *)&v67[8] = 0u;
        long long v68 = 0u;
        *(_OWORD *)std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        uint64_t v72 = 0;
        uint64_t v19 = (uint64_t)std::vector<IR::IRDataNode>::insert(a2, v19, (uint64_t)v67);
        v73[0] = (void **)&v71;
        std::vector<IR::IRDataNode>::__destroy_vector::operator()[abi:ne180100](v73);
        if (__p[1])
        {
          *(void **)&long long v70 = __p[1];
          operator delete(__p[1]);
        }
        if (__p[0]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[0]);
        }
        v73[0] = (void **)&v67[8];
        std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](v73);
      }
      a2 = (uint64_t *)(v19 + 72);
      ++v14;
      uint64_t v12 = *(void *)(a1 + 104);
      uint64_t v13 = *(void *)(a1 + 112);
    }
    while (v14 < (v13 - v12) >> 2);
    unsigned int v8 = a6;
    CFDataRef v7 = a7;
    if (v19) {
      goto LABEL_36;
    }
  }
  if (v12 != v13)
  {
LABEL_36:
    if (!v19) {
      IR::IRData::Implementation::insertIRDataInTree();
    }
    goto LABEL_37;
  }
  uint64_t v25 = a2[1];
  if (*a2 == v25)
  {
    *(_DWORD *)int v67 = 0;
    *(_OWORD *)&v67[8] = 0u;
    long long v68 = 0u;
    *(_OWORD *)std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    uint64_t v72 = 0;
    std::vector<IR::IRDataNode>::push_back[abi:ne180100](a2, (uint64_t)v67);
    v73[0] = (void **)&v71;
    std::vector<IR::IRDataNode>::__destroy_vector::operator()[abi:ne180100](v73);
    if (__p[1])
    {
      *(void **)&long long v70 = __p[1];
      operator delete(__p[1]);
    }
    if (__p[0]) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[0]);
    }
    v73[0] = (void **)&v67[8];
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](v73);
    uint64_t v25 = a2[1];
  }
  uint64_t v19 = v25 - 96;
LABEL_37:
  if (!*(unsigned char *)(a1 + 488))
  {
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vdeallocate((IR::FFTFilterKernel ***)(v19 + 8));
    *(_OWORD *)(v19 + 8) = *(_OWORD *)a4;
    *(void *)(v19 + 24) = *(void *)(a4 + 16);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    std::vector<float>::__move_assign(v19 + 48, a5);
    return;
  }
  uint64_t v26 = *(void **)(v19 + 32);
  if (!v26)
  {
    _ZNSt3__115allocate_sharedB8ne180100IN2IR23VBAPTriangulationKernelENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(v67);
    long long v27 = *(_OWORD *)v67;
    *(_OWORD *)int v67 = 0uLL;
    uint64_t v28 = *(std::__shared_weak_count **)(v19 + 40);
    *(_OWORD *)(v19 + 32) = v27;
    if (v28)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v28);
      if (*(void *)&v67[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v67[8]);
      }
    }
    uint64_t v29 = *(void *)(v19 + 32);
    long long v30 = *(_OWORD *)a3;
    long long v31 = *(_OWORD *)(a3 + 16);
    *(_DWORD *)(v29 + 176) = *(_DWORD *)(a3 + 32);
    *(_OWORD *)(v29 + 144) = v30;
    *(_OWORD *)(v29 + 16std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v31;
    uint64_t v26 = *(void **)(v19 + 32);
  }
  float v32 = IR::IRCoordinates::get(a3, 0);
  float v33 = v32;
  unint64_t v34 = v26[7];
  uint64_t v35 = (float *)v26[6];
  if ((unint64_t)v35 >= v34)
  {
    uint64_t v37 = (float *)v26[5];
    uint64_t v38 = v35 - v37;
    if ((unint64_t)(v38 + 1) >> 62) {
      goto LABEL_83;
    }
    unint64_t v39 = v34 - (void)v37;
    unint64_t v40 = (uint64_t)(v34 - (void)v37) >> 1;
    if (v40 <= v38 + 1) {
      unint64_t v40 = v38 + 1;
    }
    if (v39 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v41 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v41 = v40;
    }
    if (v41)
    {
      uint64_t v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v26 + 7), v41);
      uint64_t v37 = (float *)v26[5];
      uint64_t v35 = (float *)v26[6];
    }
    else
    {
      uint64_t v42 = 0;
    }
    uint64_t v43 = (float *)&v42[4 * v38];
    uint64_t v44 = &v42[4 * v41];
    *uint64_t v43 = v33;
    uint64_t v36 = v43 + 1;
    while (v35 != v37)
    {
      int v45 = *((_DWORD *)v35-- - 1);
      *((_DWORD *)v43-- - 1) = v45;
    }
    v26[5] = v43;
    v26[6] = v36;
    v26[7] = v44;
    if (v37) {
      operator delete(v37);
    }
  }
  else
  {
    *uint64_t v35 = v32;
    uint64_t v36 = v35 + 1;
  }
  v26[6] = v36;
  std::vector<unsigned int> v46 = *(void **)(v19 + 32);
  float v47 = IR::IRCoordinates::get(a3, 1u);
  float v48 = v47;
  uint64_t v49 = (float *)v46[9];
  unint64_t v50 = v46[10];
  if ((unint64_t)v49 >= v50)
  {
    uint64_t v52 = (float *)v46[8];
    uint64_t v53 = v49 - v52;
    if (!((unint64_t)(v53 + 1) >> 62))
    {
      unint64_t v54 = v50 - (void)v52;
      unint64_t v55 = (uint64_t)(v50 - (void)v52) >> 1;
      if (v55 <= v53 + 1) {
        unint64_t v55 = v53 + 1;
      }
      if (v54 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v56 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v56 = v55;
      }
      if (v56)
      {
        uint64_t v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v46 + 10), v56);
        uint64_t v52 = (float *)v46[8];
        uint64_t v49 = (float *)v46[9];
      }
      else
      {
        uint64_t v57 = 0;
      }
      uint64_t v58 = (float *)&v57[4 * v53];
      uint64_t v59 = &v57[4 * v56];
      *uint64_t v58 = v48;
      uint64_t v51 = v58 + 1;
      while (v49 != v52)
      {
        int v60 = *((_DWORD *)v49-- - 1);
        *((_DWORD *)v58-- - 1) = v60;
      }
      v46[8] = v58;
      v46[9] = v51;
      v46[10] = v59;
      if (v52) {
        operator delete(v52);
      }
      goto LABEL_76;
    }
LABEL_83:
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  *uint64_t v49 = v47;
  uint64_t v51 = v49 + 1;
LABEL_76:
  v46[9] = v51;
  std::vector<std::vector<float>>::push_back[abi:ne180100]((uint64_t *)(*(void *)(v19 + 32) + 112), (uint64_t)a5);
  std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::push_back[abi:ne180100]((uint64_t *)(*(void *)(v19 + 32) + 88), a4);
  if ((v8 & 0x80000000) == 0 && v8 < (unint64_t)((uint64_t)(v7[1] - *v7) >> 2))
  {
    int v61 = *(_DWORD *)(*v7 + 4 * v8);
    uint64_t v62 = *(void *)(v19 + 32);
    if (*(_DWORD *)(v62 + 136) == v61)
    {
      ++*(_DWORD *)(v62 + 140);
    }
    else
    {
      *(_DWORD *)(v62 + 136) = v61;
      *(_DWORD *)(v62 + 14std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 1;
    }
  }
}

void sub_21B4EF974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IR::IRDataNode::~IRDataNode((IR::IRDataNode *)va);
  _Unwind_Resume(a1);
}

void std::vector<IR::IRDataNode>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 5);
    if (v9 + 1 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 5);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x155555555555555) {
      unint64_t v12 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRDataNode>>(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = v13;
    float v15 = &v13[96 * v9];
    float v17 = &v13[96 * v12];
    std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>((uint64_t)v15, a2);
    uint64_t v16 = v15 + 96;
    std::vector<IR::IRDataNode>::__swap_out_circular_buffer(a1, &v14);
    uint64_t v8 = a1[1];
    std::__split_buffer<IR::IRDataNode>::~__split_buffer((uint64_t)&v14);
  }
  else
  {
    std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(*(void *)(v4 - 8), a2);
    uint64_t v8 = v7 + 96;
    a1[1] = v7 + 96;
  }
  a1[1] = v8;
}

void sub_21B4EFAA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<IR::IRDataNode>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void IR::IRDataNode::~IRDataNode(IR::IRDataNode *this)
{
  uint64_t v4 = (void **)((char *)this + 72);
  std::vector<IR::IRDataNode>::__destroy_vector::operator()[abi:ne180100](&v4);
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  CFDictionaryRef v3 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](&v4);
}

_DWORD *std::vector<IR::IRDataNode>::insert(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (_DWORD *)a2;
  uint64_t v7 = *a1;
  unint64_t v6 = a1[1];
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a2 - *a1) >> 5);
  unint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = v11;
  if (v6 >= v11)
  {
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v7) >> 5) + 1;
    if (v16 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v7) >> 5);
    if (2 * v17 > v16) {
      unint64_t v16 = 2 * v17;
    }
    if (v17 >= 0x155555555555555) {
      unint64_t v18 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v18 = v16;
    }
    uint64_t v25 = v9;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRDataNode>>(v9, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    unint64_t v21 = v19;
    uint64_t v22 = &v19[96 * v8];
    uint64_t v23 = v22;
    float v24 = &v19[96 * v18];
    std::__split_buffer<IR::IRDataNode>::push_back(&v21, a3);
    uint64_t v4 = (_DWORD *)std::vector<IR::IRDataNode>::__swap_out_circular_buffer(a1, &v21, (uint64_t)v4);
    std::__split_buffer<IR::IRDataNode>::~__split_buffer((uint64_t)&v21);
  }
  else if (a2 == v6)
  {
    std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(a2, a3);
    a1[1] = (uint64_t)(v4 + 24);
  }
  else
  {
    std::vector<IR::IRDataNode>::__move_range((uint64_t)a1, a2, v6, a2 + 96);
    *uint64_t v4 = *(_DWORD *)a3;
    unint64_t v12 = v7 + 96 * v8;
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vdeallocate((IR::FFTFilterKernel ***)(v12 + 8));
    *(_OWORD *)(v12 + 8) = *(_OWORD *)(a3 + 8);
    *(void *)(v12 + 24) = *(void *)(a3 + 24);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    long long v13 = *(_OWORD *)(a3 + 32);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
    unint64_t v14 = *(std::__shared_weak_count **)(v12 + 40);
    *(_OWORD *)(v12 + 32) = v13;
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
    unint64_t v15 = v7 + 96 * v8;
    std::vector<float>::__move_assign(v15 + 48, (__n128 *)(a3 + 48));
    std::vector<IR::IRDataNode>::__vdeallocate((void **)(v15 + 72));
    *(_OWORD *)(v15 + 72) = *(_OWORD *)(a3 + 72);
    *(void *)(v15 + 88) = *(void *)(a3 + 88);
    *(void *)(a3 + 72) = 0;
    *(void *)(a3 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
    *(void *)(a3 + 88) = 0;
  }
  return v4;
}

void sub_21B4EFCE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<IR::IRDataNode>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    long long v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v12);
    unint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unint64_t v14 = 0;
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    unint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    unint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_21B4EFE20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void **std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    long long v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)result, v12);
    unint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unint64_t v14 = 0;
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::__swap_out_circular_buffer(a1, v16);
    unint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::~__split_buffer(v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    unint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_21B4EFF60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::getCoordinateTree(IR::IRData::Implementation *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = 6;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  if (*((unsigned char *)this + 488))
  {
    uint64_t v4 = (uint64_t *)*((void *)this + 63);
    for (uint64_t i = (uint64_t *)*((void *)this + 64); v4 != i; v4 += 2)
    {
      uint64_t v7 = *v4;
      unint64_t v6 = (std::__shared_weak_count *)v4[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      long long v8 = *(_OWORD *)(v7 + 160);
      v13[0] = *(_OWORD *)(v7 + 144);
      v13[1] = v8;
      int v14 = *(_DWORD *)(v7 + 176);
      uint64_t v9 = *(void *)(v7 + 40);
      if (*(void *)(v7 + 48) != v9)
      {
        unint64_t v10 = 0;
        unsigned int v11 = 1;
        do
        {
          IR::IRCoordinates::set((uint64_t)v13, 0, *(float *)(v9 + 4 * v10));
          IR::IRCoordinates::set((uint64_t)v13, 1u, *(float *)(*(void *)(v7 + 64) + 4 * v10));
          IR::IRData::Implementation::insertInCoordinateTree(this, (const IR::IRCoordinates *)v13, (IR::IRCoordinateTree *)a2);
          unint64_t v10 = v11;
          uint64_t v9 = *(void *)(v7 + 40);
          ++v11;
        }
        while (v10 < (*(void *)(v7 + 48) - v9) >> 2);
      }
      if (v6) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v6);
      }
    }
  }
  else
  {
    unint64_t v12 = (uint64_t *)*((void *)this + 33);
    if (*v12 != v12[1])
    {
      *(_DWORD *)a2 = **((_DWORD **)this + 10);
      IR::IRData::Implementation::recursiveGetCoordinateTree((uint64_t)this, v12, 0, (void *)a2);
    }
  }
}

void sub_21B4F00B8(_Unwind_Exception *a1)
{
  IR::IRCoordinateTree::~IRCoordinateTree(v1);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::recursiveGetCoordinateTree(uint64_t a1, uint64_t *a2, int a3, void *a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    long long v8 = (void **)(a4 + 1);
    uint64_t v24 = (uint64_t)(a4 + 3);
    uint64_t v25 = a4 + 4;
    uint64_t v9 = (a3 + 1);
    do
    {
      unsigned int v11 = (char *)a4[2];
      unint64_t v10 = a4[3];
      if ((unint64_t)v11 >= v10)
      {
        long long v13 = (char *)*v8;
        uint64_t v14 = (v11 - (unsigned char *)*v8) >> 2;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 62) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v10 - (void)v13;
        if (v16 >> 1 > v15) {
          unint64_t v15 = v16 >> 1;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          unint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v24, v17);
          long long v13 = (char *)a4[1];
          unsigned int v11 = (char *)a4[2];
        }
        else
        {
          unint64_t v18 = 0;
        }
        uint64_t v19 = &v18[4 * v14];
        *(_DWORD *)uint64_t v19 = *(_DWORD *)v4;
        unint64_t v12 = v19 + 4;
        while (v11 != v13)
        {
          int v20 = *((_DWORD *)v11 - 1);
          v11 -= 4;
          *((_DWORD *)v19 - 1) = v20;
          v19 -= 4;
        }
        a4[1] = v19;
        a4[2] = v12;
        a4[3] = &v18[4 * v17];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *(_DWORD *)unsigned int v11 = *(_DWORD *)v4;
        unint64_t v12 = v11 + 4;
      }
      a4[2] = v12;
      if (*(void *)(v4 + 72) != *(void *)(v4 + 80))
      {
        uint64_t v26 = 6;
        *(_OWORD *)std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0u;
        memset(v28, 0, sizeof(v28));
        unint64_t v21 = a4[5];
        if (v21 >= a4[6])
        {
          uint64_t v22 = std::vector<IR::IRCoordinateTree>::__push_back_slow_path<IR::IRCoordinateTree>(v25, (uint64_t)&v26);
        }
        else
        {
          *(_DWORD *)unint64_t v21 = 6;
          *(void *)(v21 + 8) = 0;
          *(void *)(v21 + 16) = 0;
          *(void *)(v21 + 24) = 0;
          *(void *)(v21 + 32) = 0;
          *(_OWORD *)(v21 + 8) = *(_OWORD *)__p;
          *(void *)(v21 + 24) = v28[0];
          __p[0] = 0;
          __p[1] = 0;
          v28[0] = 0;
          *(void *)(v21 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
          *(void *)(v21 + 48) = 0;
          *(_OWORD *)(v21 + 32) = *(_OWORD *)&v28[1];
          *(void *)(v21 + 48) = v28[3];
          memset(&v28[1], 0, 24);
          uint64_t v22 = v21 + 56;
        }
        a4[5] = v22;
        uint64_t v29 = (void **)&v28[1];
        std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v29);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        uint64_t v23 = a4[5];
        *(_DWORD *)(v23 - 56) = *(_DWORD *)(*(void *)(a1 + 80) + 4 * v9);
        IR::IRData::Implementation::recursiveGetCoordinateTree(a1, v4 + 72, v9, v23 - 56);
      }
      v4 += 96;
    }
    while (v4 != v5);
  }
}

void sub_21B4F02E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IR::IRCoordinateTree::~IRCoordinateTree((IR::IRCoordinateTree *)va);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::insertInCoordinateTree(IR::IRData::Implementation *this, const IR::IRCoordinates *a2, IR::IRCoordinateTree *a3)
{
  uint64_t v3 = *((void *)this + 10);
  if (*((void *)this + 11) != v3)
  {
    unint64_t v7 = 0;
    do
    {
      float v39 = 0.0;
      float v8 = IR::IRCoordinates::get((uint64_t)a2, *(_DWORD *)(v3 + 4 * v7));
      float v39 = v8;
      uint64_t v9 = *((void *)this + 10);
      *(_DWORD *)a3 = *(_DWORD *)(v9 + 4 * v7);
      uint64_t v10 = *((void *)this + 16);
      float v11 = *(float *)(v10 + 4 * v7);
      if (v11 != 0.0)
      {
        float v8 = fmodf(v8, v11);
        float v39 = v8;
        if (v8 < 0.0)
        {
          float v8 = v8 + *(float *)(v10 + 4 * v7);
          float v39 = v8;
        }
      }
      unint64_t v12 = (float *)*((void *)a3 + 1);
      long long v13 = (float *)*((void *)a3 + 2);
      uint64_t v14 = (char *)v13 - (char *)v12;
      if (v13 == v12)
      {
        uint64_t v16 = (char *)*((void *)a3 + 2);
      }
      else
      {
        unint64_t v15 = v14 >> 2;
        uint64_t v16 = (char *)*((void *)a3 + 1);
        do
        {
          unint64_t v17 = v15 >> 1;
          unint64_t v18 = (float *)&v16[4 * (v15 >> 1)];
          float v20 = *v18;
          uint64_t v19 = (char *)(v18 + 1);
          v15 += ~(v15 >> 1);
          if (v20 < v8) {
            uint64_t v16 = v19;
          }
          else {
            unint64_t v15 = v17;
          }
        }
        while (v15);
      }
      if (v13 == (float *)v16)
      {
        unint64_t v21 = *((void *)a3 + 3);
        if ((unint64_t)v13 >= v21)
        {
          uint64_t v26 = v14 >> 2;
          unint64_t v27 = (v14 >> 2) + 1;
          if (v27 >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v28 = v21 - (void)v12;
          unint64_t v29 = (uint64_t)(v21 - (void)v12) >> 1;
          if (v29 > v27) {
            unint64_t v27 = v29;
          }
          if (v28 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v27;
          }
          if (v30)
          {
            long long v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)a3 + 24, v30);
            unint64_t v12 = (float *)*((void *)a3 + 1);
            long long v13 = (float *)*((void *)a3 + 2);
            float v8 = v39;
          }
          else
          {
            long long v31 = 0;
          }
          float v32 = (float *)&v31[4 * v26];
          *float v32 = v8;
          uint64_t v22 = v32 + 1;
          while (v13 != v12)
          {
            int v33 = *((_DWORD *)v13-- - 1);
            *((_DWORD *)v32-- - 1) = v33;
          }
          *((void *)a3 + 1) = v32;
          *((void *)a3 + 2) = v22;
          *((void *)a3 + 3) = &v31[4 * v30];
          if (v12) {
            operator delete(v12);
          }
        }
        else
        {
          *long long v13 = v8;
          uint64_t v22 = v13 + 1;
        }
        *((void *)a3 + 2) = v22;
        if (((uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 2) - 1 > v7)
        {
          uint64_t v36 = 6;
          memset(v38, 0, sizeof(v38));
          *(_OWORD *)std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0u;
          unint64_t v34 = *((void *)a3 + 5);
          if (v34 >= *((void *)a3 + 6))
          {
            uint64_t v35 = std::vector<IR::IRCoordinateTree>::__push_back_slow_path<IR::IRCoordinateTree>((uint64_t *)a3 + 4, (uint64_t)&v36);
          }
          else
          {
            *(_DWORD *)unint64_t v34 = 6;
            *(void *)(v34 + 8) = 0;
            *(void *)(v34 + 16) = 0;
            *(void *)(v34 + 24) = 0;
            *(void *)(v34 + 32) = 0;
            *(_OWORD *)(v34 + 8) = *(_OWORD *)__p;
            *(void *)(v34 + 24) = v38[0];
            __p[0] = 0;
            __p[1] = 0;
            v38[0] = 0;
            *(void *)(v34 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
            *(void *)(v34 + 48) = 0;
            *(_OWORD *)(v34 + 32) = *(_OWORD *)&v38[1];
            *(void *)(v34 + 48) = v38[3];
            memset(&v38[1], 0, 24);
            uint64_t v35 = v34 + 56;
          }
          *((void *)a3 + 5) = v35;
          unint64_t v40 = (void **)&v38[1];
          std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v40);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          a3 = (IR::IRCoordinateTree *)(*((void *)a3 + 5) - 56);
        }
      }
      else if (*(float *)v16 == v8)
      {
        if (((*((void *)this + 11) - v9) >> 2) - 1 > v7) {
          a3 = (IR::IRCoordinateTree *)(*((void *)a3 + 4) + 56 * ((v16 - (char *)v12) >> 2));
        }
      }
      else
      {
        std::vector<float>::insert((uint64_t)a3 + 8, v16, (char *)&v39);
        if (((uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 2) - 1 > v7)
        {
          uint64_t v24 = *((void *)a3 + 4);
          uint64_t v23 = (uint64_t *)((char *)a3 + 32);
          uint64_t v25 = (_DWORD *)(v24 + 56 * ((uint64_t)&v16[-*(v23 - 3)] >> 2));
          uint64_t v36 = 6;
          *(_OWORD *)std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0u;
          memset(v38, 0, sizeof(v38));
          a3 = (IR::IRCoordinateTree *)std::vector<IR::IRCoordinateTree>::insert(v23, v25, (uint64_t)&v36);
          unint64_t v40 = (void **)&v38[1];
          std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v40);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }
      }
      ++v7;
      uint64_t v3 = *((void *)this + 10);
    }
    while (v7 < (*((void *)this + 11) - v3) >> 2);
  }
}

void sub_21B4F0634(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRCoordinateTree::~IRCoordinateTree((IR::IRCoordinateTree *)va);
  _Unwind_Resume(a1);
}

void IR::IRCoordinateTree::~IRCoordinateTree(IR::IRCoordinateTree *this)
{
  uint64_t v3 = (void **)((char *)this + 32);
  std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

char *std::vector<float>::insert(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  unint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    long long v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 2) + 1;
    if (v14 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 2;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 1 > v14) {
      unint64_t v14 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1 + 16, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    float v20 = &v19[4 * v16];
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = v19;
    unint64_t v27 = v20;
    unint64_t v28 = v20;
    unint64_t v29 = &v19[4 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 1;
        }
        uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v8, v22);
        float v20 = &v23[v22 & 0xFFFFFFFFFFFFFFFCLL];
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = v23;
        unint64_t v27 = v20;
        unint64_t v29 = &v23[4 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 4 * (v21 >> 1);
        unint64_t v27 = v20;
      }
    }
    *(_DWORD *)float v20 = *(_DWORD *)v3;
    unint64_t v28 = v20 + 4;
    uint64_t v4 = std::vector<float>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(_DWORD *)__src = *(_DWORD *)a3;
    *(void *)(a1 + 8) = __src + 4;
  }
  else
  {
    uint64_t v9 = __src + 4;
    uint64_t v10 = v6 - 4;
    float v11 = *(_DWORD **)(a1 + 8);
    while (v10 < v6)
    {
      int v12 = *(_DWORD *)v10;
      v10 += 4;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-4 * ((v6 - v9) >> 2)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 4 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(_DWORD *)uint64_t v4 = *(_DWORD *)v3;
  }
  return v4;
}

void sub_21B4F08A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *std::vector<IR::IRCoordinateTree>::insert(uint64_t *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v7 = *a1;
  unint64_t v6 = a1[1];
  uint64_t v8 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)a2 - *a1) >> 3);
  unint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = v11;
  if (v6 >= v11)
  {
    unint64_t v14 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v6 - v7) >> 3) + 1;
    if (v14 > 0x492492492492492) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v15 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v10 - v7) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x249249249249249) {
      unint64_t v16 = 0x492492492492492;
    }
    else {
      unint64_t v16 = v14;
    }
    uint64_t v24 = v9;
    if (v16) {
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinateTree>>(v9, v16);
    }
    else {
      uint64_t v17 = 0;
    }
    float v20 = v17;
    unint64_t v21 = &v17[56 * v8];
    unint64_t v22 = v21;
    uint64_t v23 = &v17[56 * v16];
    std::__split_buffer<IR::IRCoordinateTree>::push_back(&v20, a3);
    uint64_t v4 = (_DWORD *)std::vector<IR::IRCoordinateTree>::__swap_out_circular_buffer(a1, &v20, (uint64_t)v4);
    std::__split_buffer<IR::IRCoordinateTree>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    int v12 = (void *)(v7 + 56 * v8 + 48);
    if (a2 == (_DWORD *)v6)
    {
      *a2 = *(_DWORD *)a3;
      unint64_t v18 = (void *)(v7 + 56 * v8);
      v18[2] = 0;
      v18[3] = 0;
      v18[1] = 0;
      *(_OWORD *)(v18 + 1) = *(_OWORD *)(a3 + 8);
      v18[3] = *(void *)(a3 + 24);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      v18[4] = 0;
      v18[5] = 0;
      v18[6] = 0;
      *((_OWORD *)v18 + 2) = *(_OWORD *)(a3 + 32);
      *int v12 = *(void *)(a3 + 48);
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(a3 + 48) = 0;
      a1[1] = (uint64_t)(a2 + 14);
    }
    else
    {
      std::vector<IR::IRCoordinateTree>::__move_range((uint64_t)a1, (uint64_t)a2, v6, (uint64_t)(a2 + 14));
      *uint64_t v4 = *(_DWORD *)a3;
      uint64_t v13 = v7 + 56 * v8;
      std::vector<float>::__move_assign(v13 + 8, (__n128 *)(a3 + 8));
      std::vector<IR::IRCoordinateTree>::__vdeallocate(v13 + 32);
      *(_OWORD *)(v13 + 32) = *(_OWORD *)(a3 + 32);
      *int v12 = *(void *)(a3 + 48);
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(a3 + 48) = 0;
    }
  }
  return v4;
}

void sub_21B4F0ACC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<IR::IRCoordinateTree>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<IR::IRCoordinates>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x8E38E38E38E38E39 * ((v4 - (unsigned char *)*a1) >> 2) < a2)
  {
    if (a2 >= 0x71C71C71C71C71DLL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 36;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinates>>(v3, a2);
    uint64_t v7 = &v6[36 * v5];
    uint64_t v9 = &v6[36 * v8];
    unint64_t v11 = (char *)*a1;
    unint64_t v10 = (char *)a1[1];
    int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *(_OWORD *)(v10 - 36);
        long long v14 = *(_OWORD *)(v10 - 20);
        *((_DWORD *)v12 - 1) = *((_DWORD *)v10 - 1);
        *(_OWORD *)(v12 - 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v14;
        *(_OWORD *)(v12 - 36) = v13;
        v12 -= 36;
        v10 -= 36;
      }
      while (v10 != v11);
      unint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

BOOL AUSM::ExclusionZone::isInExclusionZone@<W0>(AUSM::ExclusionZone *this@<X0>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>, BOOL a6@<W8>)
{
  if (*(_DWORD *)this == 1)
  {
    __float2 v19 = __sincosf_stret(a2 * 0.017453);
    __float2 v20 = __sincosf_stret(a3 * 0.017453);
    float v21 = v19.__sinval * (float)(v20.__cosval * a4);
    float v22 = v19.__cosval * (float)(v20.__cosval * a4);
    float v23 = v20.__sinval * a4;
    float v24 = *((float *)this + 1);
    float v25 = *((float *)this + 2);
    BOOL v26 = v21 >= (float)(v24 - a5);
    if (v21 <= (float)(v25 + a5)) {
      BOOL v26 = 1;
    }
    BOOL v27 = v21 >= (float)(v24 - a5);
    if (v21 > (float)(v25 + a5)) {
      BOOL v27 = 0;
    }
    if (v24 <= v25) {
      BOOL v28 = v27;
    }
    else {
      BOOL v28 = v26;
    }
    float v29 = *((float *)this + 3);
    float v30 = *((float *)this + 4);
    BOOL v12 = v22 >= (float)(v29 - a5);
    if (v22 <= (float)(v30 + a5)) {
      BOOL v12 = 1;
    }
    BOOL v31 = v22 >= (float)(v29 - a5);
    if (v22 > (float)(v30 + a5)) {
      BOOL v31 = 0;
    }
    if (v29 <= v30) {
      BOOL v12 = v31;
    }
    float v32 = *((float *)this + 5);
    float v33 = *((float *)this + 6);
    BOOL v16 = v23 >= (float)(v32 - a5);
    if (v23 <= (float)(v33 + a5)) {
      BOOL v16 = 1;
    }
    BOOL v34 = v23 >= (float)(v32 - a5);
    if (v23 > (float)(v33 + a5)) {
      BOOL v34 = 0;
    }
    if (v32 <= v33) {
      BOOL v16 = v34;
    }
    if (!v28) {
      return 0;
    }
    return v12 && v16;
  }
  if (!*(_DWORD *)this)
  {
    float v9 = *((float *)this + 3);
    float v10 = *((float *)this + 4);
    float v11 = v9 - a5;
    BOOL v12 = (float)(v9 - a5) <= a2;
    if ((float)(v10 + a5) >= a2) {
      BOOL v12 = 1;
    }
    BOOL v13 = v11 <= a2;
    if ((float)(v10 + a5) < a2) {
      BOOL v13 = 0;
    }
    if (v9 <= v10) {
      BOOL v12 = v13;
    }
    float v14 = *((float *)this + 1);
    float v15 = *((float *)this + 2);
    BOOL v16 = (float)(v14 - a5) <= a3;
    if ((float)(v15 + a5) >= a3) {
      BOOL v16 = 1;
    }
    BOOL v17 = (float)(v14 - a5) <= a3;
    if ((float)(v15 + a5) < a3) {
      BOOL v17 = 0;
    }
    if (v14 <= v15) {
      BOOL v16 = v17;
    }
    return v12 && v16;
  }
  return a6;
}

float IR::IRData::Implementation::estimateAverageDelay(IR::IRData::Implementation *this)
{
  v17[4] = *MEMORY[0x263EF8340];
  uint64_t v16 = 0;
  if (*((unsigned char *)this + 488))
  {
    uint64_t v1 = *((void *)this + 63);
    uint64_t v2 = *((void *)this + 64);
    if (v1 == v2)
    {
      int v3 = 0;
      float v4 = 0.0;
    }
    else
    {
      int v3 = 0;
      float v4 = 0.0;
      do
      {
        uint64_t v5 = *(void *)(*(void *)v1 + 112);
        uint64_t v6 = *(void *)(*(void *)v1 + 120);
        uint64_t v7 = v6 - v5;
        if (v6 != v5)
        {
          uint64_t v8 = 0;
          unint64_t v9 = v7 / 24;
          if (v9 <= 1) {
            unint64_t v9 = 1;
          }
          do
          {
            float v10 = *(float **)(v5 + 24 * v8);
            uint64_t v11 = *(void *)(v5 + 24 * v8 + 8) - (void)v10;
            if (v11)
            {
              unint64_t v12 = v11 >> 2;
              if (v12 <= 1) {
                unint64_t v12 = 1;
              }
              unint64_t v13 = v12;
              do
              {
                float v14 = *v10++;
                float v4 = v14 + v4;
                --v13;
              }
              while (v13);
              v3 += v12;
            }
            ++v8;
          }
          while (v8 != v9);
        }
        v1 += 16;
      }
      while (v1 != v2);
    }
  }
  else
  {
    v17[0] = &unk_26CB577D0;
    v17[1] = (char *)&v16 + 4;
    v17[2] = &v16;
    v17[3] = v17;
    IR::IRData::Implementation::forEachNode((uint64_t)this, (uint64_t)v17, 0, 0);
    std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::~__value_func[abi:ne180100](v17);
    float v4 = *((float *)&v16 + 1);
    int v3 = v16;
  }
  return v4 / (float)v3;
}

void sub_21B4F0EE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_21B4F0FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::Implementation::getBooleanFromDictionary(const __CFDictionary **a1, const UInt8 *a2, int a3)
{
  float v4 = a1;
  CFDictionaryRef v5 = *a1;
  if (!v5)
  {
LABEL_19:
    LOBYTE(v4) = a3;
    return v4 & 1;
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::BooleanRef,std::string const&>(v5, a2, &v21);
  if (v22)
  {
    CFBooleanRef v7 = v21;
    if (!v21)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    CFTypeID TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(v7))
    {
      LOBYTE(a3) = CFBooleanGetValue(v7) != 0;
    }
    else
    {
      CFTypeID v13 = CFNumberGetTypeID();
      if (v13 == CFGetTypeID(v7))
      {
        unsigned __int16 v14 = applesauce::CF::details::number_convert_as<BOOL>(v7);
        if (v14 >= 0x100u) {
          LOBYTE(a3) = v14 != 0;
        }
      }
    }
    std::__optional_destruct_base<applesauce::CF::BooleanRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v21);
    goto LABEL_19;
  }
  if (!*v4)
  {
    BOOL v17 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v17, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::NumberRef,std::string const&>(*v4, a2, &v19);
  int v9 = v20;
  if (v20)
  {
    if (!v19)
    {
      unint64_t v18 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v18, "Could not construct");
    }
    if (a3) {
      float v10 = 1.0;
    }
    else {
      float v10 = 0.0;
    }
    uint64_t v11 = applesauce::CF::convert_as<float,0>(v19);
    float v12 = *(float *)&v11;
    if ((v11 & 0xFF00000000) == 0) {
      float v12 = v10;
    }
    LOBYTE(v4) = v12 > 0.5;
  }
  std::__optional_destruct_base<applesauce::CF::NumberRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v19);
  std::__optional_destruct_base<applesauce::CF::BooleanRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v21);
  if (!v9) {
    goto LABEL_19;
  }
  return v4 & 1;
}

void sub_21B4F1214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t std::function<void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t a1, uint64_t a2, int a3)
{
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)v3 + 48))(v3, a2, &v5);
}

uint64_t std::function<void ()(IR::IRDataNode const&,unsigned int)>::operator()(uint64_t a1, uint64_t a2, int a3)
{
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)v3 + 48))(v3, a2, &v5);
}

void *IR::IRData::Implementation::printNodes(IR::IRData::Implementation *this)
{
  v6[4] = *MEMORY[0x263EF8340];
  if (**((void **)this + 33) == *(void *)(*((void *)this + 33) + 8))
  {
    uint64_t v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Empty!", 6);
    std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
    uint64_t v3 = std::locale::use_facet(&v5, MEMORY[0x263F8C108]);
    ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
    std::locale::~locale(&v5);
    std::ostream::put();
    std::ostream::flush();
  }
  v6[0] = &unk_26CB57860;
  v6[3] = v6;
  IR::IRData::Implementation::forEachNode((uint64_t)this, (uint64_t)v6, 0, 0);
  return std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](v6);
}

void sub_21B4F144C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void IR::IRData::Implementation::generatePanningIRData(IR::IRData::Implementation *this@<X0>, float a2@<S0>, IR::IRData::Implementation *a3@<X1>, IR *a4@<X2>, uint64_t a5@<X3>, float *a6@<X4>, void *a7@<X8>)
{
  if (this == 6619138) {
    IR::IRData::Implementation::generateStereoPanningIRData(a3, a2, (BOOL)a3, (uint64_t)a4, a5, a6);
  }
  IR::IRData::Implementation::generateMultiChannelPanningIRData(this, a2, (int)a3, a4, a5, a7);
}

void IR::IRData::Implementation::generateStereoPanningIRData(IR::IRData::Implementation *this, float a2, BOOL a3, uint64_t a4, uint64_t a5, float *a6)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  IR::generateGrid((IR *)2, (int)this, a6, (uint64_t)v8);
  uint64_t v6 = operator new(8uLL);
  v8[0] = v6;
  *uint64_t v6 = 1;
  v8[1] = v6 + 1;
  v8[2] = v6 + 1;
  *(void *)operator new(8uLL) = 0x43B4000000000000;
  *(void *)operator new(8uLL) = 0x100000001;
  uint64_t v9 = 0;
  CFBooleanRef v7 = operator new(0x20uLL);
  v7[1] = 0;
  v7[2] = 0;
  *CFBooleanRef v7 = &unk_26CB57468;
  uint64_t v9 = 0;
  IR::IRData::IRData(v7 + 3);
}

void sub_21B4F1A60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, void *a19, void *a20,CFTypeRef cf,uint64_t a22,uint64_t a23,CFTypeRef a24,uint64_t a25,uint64_t a26,char a27,void *a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  if (__p)
  {
    a32 = (uint64_t)__p;
    operator delete(__p);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  if (a19) {
    operator delete(a19);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::generateMultiChannelPanningIRData(IR::IRData::Implementation *this@<X0>, float a2@<S0>, int a3@<W1>, IR *a4@<X2>, int a5@<W3>, void *a6@<X8>)
{
  unsigned int v9 = this;
  AudioChannelLayoutTag v67 = this;
  float v66 = a2;
  uint64_t v11 = (IR::IRDataLoader::Implementation **)IR::IRDataLoader::instance(this);
  IR::IRDataLoader::getCustomLayoutFromTag(v11, v9, (uint64_t)v64);
  if (v65) {
    GetChannelLayoutSphericalCoordinates((const AudioChannelLayout *)v64[0], &v58);
  }
  else {
    GetChannelLayoutSphericalCoordinates(v9, &v58);
  }
  if (v65) {
    GetChannelLayoutChannelLabels((const AudioChannelLayout *)v64[0], &v57);
  }
  else {
    GetChannelLayoutChannelLabels(v67, &v57);
  }
  unint64_t v55 = 0;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
  unint64_t v56 = 0;
  int64_t v12 = (char *)v57.__end_ - (char *)v57.__begin_;
  if ((int)((unint64_t)((char *)v57.__end_ - (char *)v57.__begin_) >> 2) >= 1)
  {
    int v40 = a5;
    CFTypeID v13 = a4;
    int v14 = a3;
    float v15 = a6;
    uint64_t v16 = (int)(v12 >> 2);
    do
    {
      uint64_t v17 = v16 - 1;
      if ((IsLFEChannelLabel(v57.__begin_[v16 - 1]) & 1) != 0 || v62[v17] == 0.0)
      {
        unint64_t v18 = v55;
        if (v55 >= v56)
        {
          unsigned __int8 v20 = (char *)__p;
          uint64_t v21 = (v55 - (unsigned char *)__p) >> 2;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v23 = v56 - (unsigned char *)__p;
          if ((v56 - (unsigned char *)__p) >> 1 > v22) {
            unint64_t v22 = v23 >> 1;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            float v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v56, v24);
            unint64_t v18 = v55;
            unsigned __int8 v20 = (char *)__p;
          }
          else
          {
            float v25 = 0;
          }
          BOOL v26 = &v25[4 * v21];
          *(_DWORD *)BOOL v26 = v17;
          CFNumberRef v19 = v26 + 4;
          while (v18 != v20)
          {
            int v27 = *((_DWORD *)v18 - 1);
            v18 -= 4;
            *((_DWORD *)v26 - 1) = v27;
            v26 -= 4;
          }
          std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = v26;
          unint64_t v55 = v19;
          unint64_t v56 = &v25[4 * v24];
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          *(_DWORD *)unint64_t v55 = v17;
          CFNumberRef v19 = v18 + 4;
        }
        unint64_t v55 = v19;
        BOOL v28 = &v58[4 * v17];
        float v29 = &v58[4 * v16];
        int64_t v30 = v59 - v29;
        if (v59 != v29) {
          memmove(&v58[4 * v17], v29, v59 - v29);
        }
        uint64_t v59 = &v28[v30];
        BOOL v31 = &v60[4 * v17];
        float v32 = &v60[4 * v16];
        int64_t v33 = v61 - v32;
        if (v61 != v32) {
          memmove(&v60[4 * v17], v32, v61 - v32);
        }
        int v61 = &v31[v33];
      }
    }
    while (v16-- > 1);
    int64_t v12 = (char *)v57.__end_ - (char *)v57.__begin_;
    a6 = v15;
    a3 = v14;
    a4 = v13;
    a5 = v40;
  }
  if (((unint64_t)v12 >> 2))
  {
    HOA::HOA((int *)v53, a4, a5, 0);
    HOA::createDecoder(v53, (uint64_t)&v58, (uint64_t)&v60, 0, 0);
    IR::generateGrid(a4, a3, v35, (uint64_t)v51);
    int v36 = v52;
    LODWORD(v41) = 1;
    uint64_t v50 = 0;
    char v49 = 0;
    int v47 = (unint64_t)v12 >> 2;
    int v48 = 2;
    uint64_t v37 = operator new(8uLL);
    v51[0] = v37;
    *uint64_t v37 = 1;
    v51[1] = v37 + 1;
    v51[2] = v37 + 1;
    uint64_t v38 = (float *)operator new(8uLL);
    __C[0] = v38;
    *(void *)uint64_t v38 = 0x43B4000000000000;
    __C[1] = v38 + 2;
    __C[2] = v38 + 2;
    float v39 = (float *)operator new(8uLL);
    __A[0] = v39;
    *(void *)float v39 = 0x100000001;
    __A[1] = v39 + 2;
    __A[2] = v39 + 2;
    int v44 = v36;
    CFTypeRef v43 = 0;
    CFTypeRef cf = 0;
    std::allocate_shared[abi:ne180100]<IR::IRData const,std::allocator<IR::IRData const>,float &,int,int,float,BOOL,unsigned int,unsigned int,unsigned int &,std::vector<IR::IRCoordinateType>,std::vector<float>,std::vector<IR::IRInterpolationMethod>,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,void>((uint64_t)v68, (uint64_t)&v66, (uint64_t)&v41, (uint64_t)&v50 + 4, (uint64_t)&v50, (uint64_t)&v49, (uint64_t)&v48, (uint64_t)&v47, (uint64_t)&v67, (uint64_t)v51, (uint64_t)__C, (uint64_t)__A, (uint64_t)&v44, &v43, &cf);
  }
  *a6 = 0;
  a6[1] = 0;
  if (__p)
  {
    unint64_t v55 = (char *)__p;
    operator delete(__p);
  }
  if (v57.__begin_)
  {
    v57.__end_ = v57.__begin_;
    operator delete(v57.__begin_);
  }
  if (v62)
  {
    uint64_t v63 = v62;
    operator delete(v62);
  }
  if (v60)
  {
    int v61 = v60;
    operator delete(v60);
  }
  if (v58)
  {
    uint64_t v59 = v58;
    operator delete(v58);
  }
  if (v65)
  {
    if (v64[0])
    {
      v64[1] = v64[0];
      operator delete(v64[0]);
    }
  }
}

void sub_21B4F254C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  std::vector<std::vector<std::list<int>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a26);
  if (__p)
  {
    a31 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a33)
  {
    a34 = (uint64_t)a33;
    operator delete(a33);
  }
  if (a40) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)a40);
  }
  if (a19) {
    operator delete(a19);
  }
  if (v48) {
    operator delete(v48);
  }
  HOA::~HOA((HOA *)&a48);
  uint64_t v51 = (void *)STACK[0x2C0];
  if (STACK[0x2C0])
  {
    STACK[0x2C8] = (unint64_t)v51;
    operator delete(v51);
  }
  unsigned __int8 v52 = *(void **)(v49 - 248);
  if (v52)
  {
    *(void *)(v49 - 24std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v52;
    operator delete(v52);
  }
  std::tuple<std::vector<float>,std::vector<float>,std::vector<float>>::~tuple(v49 - 224);
  if (*(unsigned char *)(v49 - 128))
  {
    uint64_t v53 = *(void **)(v49 - 152);
    if (v53)
    {
      *(void *)(v49 - 144) = v53;
      operator delete(v53);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t std::tuple<std::vector<float>,std::vector<float>,std::vector<float>>::~tuple(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  float v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

void IR::IRData::IRData(void *a1)
{
  *a1 = 0;
  operator new();
}

{
  *a1 = 0;
  std::make_unique[abi:ne180100]<IR::IRData::Implementation,float &,unsigned int &,unsigned int &,float &,BOOL &,unsigned int &,unsigned int &,unsigned int &,std::vector<IR::IRCoordinateType> const&,std::vector<float> const&,std::vector<IR::IRInterpolationMethod> const&,IR::IRSphericalInterpolation &,applesauce::CF::DictionaryRef &,applesauce::CF::DictionaryRef &>();
}

{
  IR::IRData::IRData(a1);
}

{
  *a1 = 0;
  operator new();
}

{
  IR::IRData::IRData(a1);
}

void sub_21B4F2870(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DataRef::~DataRef((const void **)va);
  MEMORY[0x21D48F780](v3, 0x10F0C407D891152);
  std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](v2, 0);
  _Unwind_Resume(a1);
}

void sub_21B4F2970(_Unwind_Exception *a1)
{
  std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<IR::IRData::Implementation,float &,unsigned int &,unsigned int &,float &,BOOL &,unsigned int &,unsigned int &,unsigned int &,std::vector<IR::IRCoordinateType> const&,std::vector<float> const&,std::vector<IR::IRInterpolationMethod> const&,IR::IRSphericalInterpolation &,applesauce::CF::DictionaryRef &,applesauce::CF::DictionaryRef &>()
{
}

void sub_21B4F2AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, const void *);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va1);
  MEMORY[0x21D48F780](v9, 0x10F0C407D891152);
  _Unwind_Resume(a1);
}

void sub_21B4F2C24(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v2, 0x10F0C407D891152);
  std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void IR::IRData::IRData(IR::IRData *this, const IR::IRData *a2)
{
  *(void *)this = 0;
  operator new();
}

void sub_21B4F2CEC(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v2, 0x10F0C407D891152);
  std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

float IR::IRData::getOriginalSampleRate(IR::IRData *this)
{
  return *(float *)(*(void *)this + 4);
}

uint64_t IR::IRData::getProcessingDelay(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 12);
}

uint64_t IR::IRData::getTimeDomainFilterLength(IR::IRData *this)
{
  return IR::FFTFilterKernel::calculateFIRFilterLength(*(unsigned int *)(*(void *)this + 8), *(_DWORD *)(*(void *)this + 16), *(unsigned __int8 *)(*(void *)this + 24));
}

float IR::IRData::getMaxDelay(IR::IRData *this)
{
  return *(float *)(*(void *)this + 20);
}

uint64_t IR::IRData::getNumSpatialPoints(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 64);
}

void IR::IRData::extractIRDataTypePlist(CFTypeRef *a1@<X0>, int a2@<W1>, _DWORD *a3@<X2>, applesauce::CF::DictionaryRef *a4@<X8>)
{
  CFTypeRef v7 = *a1;
  if (*a1) {
    CFRetain(*a1);
  }
  CFTypeRef cf = v7;
  IR::IRData::Implementation::extractIRDataTypePlist((const __CFDictionary **)&cf, a2, a3, a4);
  if (cf) {
    CFRelease(cf);
  }
}

void sub_21B4F2DE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::getOriginalNumFiltersPerSpatialPoint(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 68);
}

uint64_t IR::IRData::getModelingDelay(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 36);
}

uint64_t IR::IRData::getAudioChannelLayoutTag(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 72);
}

uint64_t IR::IRData::getOriginalAudioChannelLayoutTag(IR::IRData *this)
{
  return *(unsigned int *)(*(void *)this + 76);
}

CFTypeRef IR::IRData::Implementation::getDescription@<X0>(CFTypeRef this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 35);
  if (v3) {
    this = CFRetain(*((CFTypeRef *)this + 35));
  }
  *a2 = v3;
  return this;
}

CFTypeRef IR::IRData::getFilePlistDict@<X0>(CFTypeRef *this@<X0>, void *a2@<X8>)
{
  return IR::IRData::Implementation::getFilePlistDict(*this, a2);
}

CFTypeRef IR::IRData::Implementation::getFilePlistDict@<X0>(CFTypeRef this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 36);
  if (v3) {
    this = CFRetain(*((CFTypeRef *)this + 36));
  }
  *a2 = v3;
  return this;
}

CFTypeRef IR::IRData::Implementation::getUserData@<X0>(CFTypeRef this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 37);
  if (v3) {
    this = CFRetain(*((CFTypeRef *)this + 37));
  }
  *a2 = v3;
  return this;
}

void IR::IRData::getCoordinateTree(IR::IRData::Implementation **this@<X0>, uint64_t a2@<X8>)
{
}

{
  IR::IRData::Implementation::getCoordinateTree(*this, a2);
}

float IR::IRData::estimateAverageDelay(IR::IRData::Implementation **this)
{
  return IR::IRData::Implementation::estimateAverageDelay(*this);
}

uint64_t IR::IRData::isAverageIRComputed(IR::IRData *this)
{
  return *(unsigned __int8 *)(*(void *)this + 328);
}

uint64_t IR::IRData::getAverageIR(IR::IRData *this)
{
  return *(void *)this + 304;
}

uint64_t IR::IRData::getIRDataAttributes(IR::IRData *this)
{
  return *(void *)this + 336;
}

uint64_t IR::IRData::getBooleanFromDictionary(CFTypeRef *a1, const UInt8 *a2, int a3)
{
  CFDictionaryRef v5 = (const __CFDictionary *)*a1;
  if (*a1) {
    CFRetain(*a1);
  }
  CFDictionaryRef v8 = v5;
  uint64_t BooleanFromDictionary = IR::IRData::Implementation::getBooleanFromDictionary(&v8, a2, a3);
  if (v5) {
    CFRelease(v5);
  }
  return BooleanFromDictionary;
}

void sub_21B4F2FB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::createSerializedIRData(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  v6[0] = *(CFTypeRef **)a1;
  v6[1] = (CFTypeRef *)&v3->__vftable;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  SerializedIRCFDataRef Data = IR::IRData::Implementation::createSerializedIRData(v6, a2, a3);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return SerializedIRData;
}

void sub_21B4F301C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void IR::IRData::loadSerializedIRData(IR::IRData *this@<X0>, const applesauce::CF::DataRef *a2@<X1>, _OWORD *a3@<X8>)
{
  CFTypeRef v7 = (uint64_t *)IR::IRDataLoader::instance(this);
  std::string::basic_string[abi:ne180100]<0>(v13, "");
  CFDictionaryRef v8 = *(const void **)this;
  if (v8) {
    CFRetain(v8);
  }
  uint64_t v11 = 0;
  CFTypeRef cf = v8;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
  uint64_t v10 = 0;
  IR::IRDataLoader::load(v7, (uint64_t)v13, (uint64_t)a2, &cf, (uint64_t)&__p, (uint64_t *)&v15);
  *a3 = v15;
  long long v15 = 0uLL;
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v14 < 0) {
    operator delete(v13[0]);
  }
}

void sub_21B4F3104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, const void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  applesauce::CF::DataRef::~DataRef(&a13);
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(a1);
}

void IR::IRData::loadSerializedIRData(IR::IRData *this@<X0>, const __CFData *const *a2@<X1>, _OWORD *a3@<X8>)
{
  CFTypeRef v7 = (uint64_t *)IR::IRDataLoader::instance(this);
  std::string::basic_string[abi:ne180100]<0>(v13, "");
  CFDictionaryRef v8 = *(const void **)this;
  if (v8) {
    CFRetain(v8);
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, v8);
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  IR::IRDataLoader::load(v7, (uint64_t)v13, (uint64_t)a2, &cf, (uint64_t)&__p, (uint64_t *)&v15);
  *a3 = v15;
  long long v15 = 0uLL;
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v14 < 0) {
    operator delete(v13[0]);
  }
}

void sub_21B4F3208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, const void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  applesauce::CF::DataRef::~DataRef(&a13);
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(a1);
}

CFDataRef IR::IRData::packSerializedIRData(CFTypeRef *this, CFTypeRef *a2, const IR::IRData *a3, const void *a4, const __CFString *a5)
{
  return IR::IRData::Implementation::createSoundProfilePack(this, a2, a3, &stru_26CB57E20, a5);
}

CFDictionaryRef IR::IRData::createDictionaryIRData(unsigned int ***a1, const IR::IRData *a2)
{
  return IR::IRData::Implementation::createDictionaryIRData(*a1, a2);
}

void *IR::IRData::printNodes(IR::IRData::Implementation **this)
{
  return IR::IRData::Implementation::printNodes(*this);
}

void *std::vector<unsigned char>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    float v4 = (char *)a1[1];
    CFDictionaryRef v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_21B4F32CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void *std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B4F338C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B4F344C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B4F34C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, CFURLRef *a2, int a3, char a4, uint64_t a5, uint64_t a6, int a7, float a8)
{
  *(void *)a1 = 0;
  *(float *)(a1 + 8) = a8;
  *(_DWORD *)(a1 + 12) = a3;
  *(unsigned char *)(a1 + 16) = a4;
  *(unsigned char *)(a1 + 17) = 0;
  *(_DWORD *)(a1 + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = a7;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  *(_OWORD *)(a1 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = xmmword_21B551040;
  *(unsigned char *)(a1 + 56) = 1;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_OWORD *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_DWORD *)(a1 + 108) = 200;
  *(unsigned char *)(a1 + 112) = 1;
  *(_DWORD *)(a1 + 116) = 0;
  *(unsigned char *)(a1 + 12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  if (*a2)
  {
    CFURLRef v9 = CFURLCopyAbsoluteURL(*a2);
    applesauce::CF::URLRef::URLRef((applesauce::CF::URLRef *)&v12, v9);
    uint64_t v10 = *(const void **)a1;
    *(void *)a1 = v12;
    int64_t v12 = v10;
    if (v10) {
      CFRelease(v10);
    }
  }
  return a1;
}

void sub_21B4F35BC(_Unwind_Exception *a1)
{
  applesauce::CF::DictionaryRef::~DictionaryRef(v3);
  applesauce::CF::URLRef::~URLRef(v1 + 11);
  applesauce::CF::URLRef::~URLRef(v2);
  applesauce::CF::URLRef::~URLRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::URLRef *applesauce::CF::URLRef::URLRef(applesauce::CF::URLRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFURLGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
  }
  return this;
}

void sub_21B4F3674(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

void std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__clear[abi:ne180100]((uint64_t *)v2);
    CFTypeID v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

void IR::IRDataAttributes::~IRDataAttributes(IR::IRDataAttributes *this)
{
  uint64_t v2 = (const void *)*((void *)this + 16);
  if (v2) {
    CFRelease(v2);
  }
  CFTypeID v3 = (const void *)*((void *)this + 11);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 8);
  if (v4) {
    CFRelease(v4);
  }
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
}

void std::vector<int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  uint64_t value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  CFDictionaryRef v5 = value;
  std::vector<unsigned int>::pointer end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<unsigned int>::pointer begin = this->__begin_;
    uint64_t v9 = (char *)end - (char *)this->__begin_;
    unint64_t v10 = __n + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      char v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v13);
      std::vector<unsigned int>::pointer begin = this->__begin_;
      std::vector<unsigned int>::pointer end = this->__end_;
    }
    else
    {
      char v14 = 0;
    }
    long long v15 = &v14[4 * v11];
    uint64_t v16 = (unsigned int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    uint64_t v17 = (unsigned int *)&v15[4 * __n];
    while (end != begin)
    {
      int v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<unsigned int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

std::vector<unsigned int>::pointer std::vector<int>::__swap_out_circular_buffer(std::vector<unsigned int> *this, std::__split_buffer<unsigned int> *__v, std::vector<unsigned int>::pointer __p)
{
  std::vector<unsigned int>::pointer begin = __v->__begin_;
  std::vector<unsigned int>::pointer v6 = this->__begin_;
  uint64_t v7 = begin;
  if (this->__begin_ != __p)
  {
    std::vector<unsigned int>::pointer v8 = __p;
    uint64_t v7 = __v->__begin_;
    do
    {
      unsigned int v9 = *--v8;
      *--uint64_t v7 = v9;
    }
    while (v8 != v6);
  }
  __v->__begin_ = v7;
  std::vector<unsigned int>::pointer end = this->__end_;
  std::__split_buffer<unsigned int>::pointer v11 = __v->__end_;
  int64_t v12 = (char *)end - (char *)__p;
  if (end != __p)
  {
    memmove(__v->__end_, __p, (char *)end - (char *)__p);
    uint64_t v7 = __v->__begin_;
  }
  __v->__end_ = (std::__split_buffer<unsigned int>::pointer)((char *)v11 + v12);
  unint64_t v13 = this->__begin_;
  this->__begin_ = v7;
  __v->__begin_ = v13;
  char v14 = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = v14;
  uint64_t value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
  return begin;
}

void *std::vector<std::unique_ptr<IR::FFTFilterKernel>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_21B4F39F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

void std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (IR::FFTFilterKernel **)**a1;
  if (v2)
  {
    uint64_t v4 = (IR::FFTFilterKernel **)v1[1];
    CFDictionaryRef v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<IR::FFTFilterKernel>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      CFDictionaryRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::vector<float>::vector(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](a1, a2);
    std::vector<unsigned int>::pointer v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_21B4F3B78(_Unwind_Exception *exception_object)
{
  CFTypeID v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unsigned int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](v7, v11);
    unint64_t v13 = (char *)v7[1];
    int64_t v12 = (void **)(v7 + 1);
    unsigned int v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      int v18 = v9;
      CFNumberRef v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  int64_t v12 = (void **)(result + 8);
  char v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unsigned int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    int v18 = v9;
    CFNumberRef v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *int64_t v12 = &v9[v17];
  return result;
}

void std::vector<std::vector<std::list<int>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    CFDictionaryRef v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        std::vector<unsigned int>::pointer v6 = v4;
        std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      CFDictionaryRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    CFDictionaryRef v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        std::__list_imp<int>::clear(v4);
      }
      while (v4 != v2);
      CFDictionaryRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__list_imp<int>::clear(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

IR::IRDataAttributes *IR::IRDataAttributes::IRDataAttributes(IR::IRDataAttributes *this, const IR::IRDataAttributes *a2)
{
  CFTypeRef v4 = *(CFTypeRef *)a2;
  if (*(void *)a2) {
    CFRetain(*(CFTypeRef *)a2);
  }
  *(void *)this = v4;
  long long v5 = *(_OWORD *)((char *)a2 + 8);
  long long v6 = *(_OWORD *)((char *)a2 + 24);
  long long v7 = *(_OWORD *)((char *)a2 + 40);
  *((unsigned char *)this + 56) = *((unsigned char *)a2 + 56);
  *(_OWORD *)((char *)this + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v7;
  *(_OWORD *)((char *)this + 24) = v6;
  *(_OWORD *)((char *)this + 8) = v5;
  uint64_t v8 = *((void *)a2 + 8);
  if (v8) {
    CFRetain(*((CFTypeRef *)a2 + 8));
  }
  *((void *)this + 8) = v8;
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  uint64_t v9 = *((void *)a2 + 11);
  if (v9) {
    CFRetain(*((CFTypeRef *)a2 + 11));
  }
  *((void *)this + 11) = v9;
  long long v10 = *((_OWORD *)a2 + 6);
  *(_OWORD *)((char *)this + 105) = *(_OWORD *)((char *)a2 + 105);
  *((_OWORD *)this + 6) = v10;
  uint64_t v11 = *((void *)a2 + 16);
  if (v11) {
    CFRetain(*((CFTypeRef *)a2 + 16));
  }
  *((void *)this + 16) = v11;
  uint64_t v12 = *((void *)a2 + 17);
  *((_DWORD *)this + 36) = *((_DWORD *)a2 + 36);
  *((void *)this + 17) = v12;
  return this;
}

CFDictionaryRef applesauce::CF::details::make_CFDictionaryRef(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 8);
  keys = 0;
  uint64_t v35 = 0;
  int v36 = 0;
  std::vector<void const*>::reserve((void **)&keys, v2);
  values = 0;
  float v32 = 0;
  int64_t v33 = 0;
  std::vector<void const*>::reserve((void **)&values, v2);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    CFTypeRef v4 = *(void ***)a1;
    uint64_t v5 = *(void *)a1 + 16 * v3;
    do
    {
      long long v6 = *v4;
      long long v7 = v35;
      if (v35 >= v36)
      {
        uint64_t v9 = v35 - keys;
        if ((unint64_t)(v9 + 1) >> 61) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v10 = ((char *)v36 - (char *)keys) >> 2;
        if (v10 <= v9 + 1) {
          unint64_t v10 = v9 + 1;
        }
        if ((unint64_t)((char *)v36 - (char *)keys) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11) {
          uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>((uint64_t)&v36, v11);
        }
        else {
          uint64_t v12 = 0;
        }
        unint64_t v13 = (void **)&v12[8 * v9];
        *unint64_t v13 = v6;
        uint64_t v8 = v13 + 1;
        unint64_t v15 = keys;
        char v14 = v35;
        if (v35 != keys)
        {
          do
          {
            uint64_t v16 = *--v14;
            *--unint64_t v13 = v16;
          }
          while (v14 != v15);
          char v14 = keys;
        }
        keys = v13;
        uint64_t v35 = v8;
        int v36 = (void **)&v12[8 * v11];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *uint64_t v35 = v6;
        uint64_t v8 = v7 + 1;
      }
      uint64_t v35 = v8;
      size_t v17 = v4[1];
      int v18 = v32;
      if (v32 >= v33)
      {
        uint64_t v20 = v32 - values;
        if ((unint64_t)(v20 + 1) >> 61) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v21 = ((char *)v33 - (char *)values) >> 2;
        if (v21 <= v20 + 1) {
          unint64_t v21 = v20 + 1;
        }
        if ((unint64_t)((char *)v33 - (char *)values) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v21;
        }
        if (v22) {
          uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>((uint64_t)&v33, v22);
        }
        else {
          uint64_t v23 = 0;
        }
        unint64_t v24 = (void **)&v23[8 * v20];
        *unint64_t v24 = v17;
        CFNumberRef v19 = v24 + 1;
        BOOL v26 = values;
        float v25 = v32;
        if (v32 != values)
        {
          do
          {
            int v27 = *--v25;
            *--unint64_t v24 = v27;
          }
          while (v25 != v26);
          float v25 = values;
        }
        values = v24;
        float v32 = v19;
        int64_t v33 = (void **)&v23[8 * v22];
        if (v25) {
          operator delete(v25);
        }
      }
      else
      {
        *float v32 = v17;
        CFNumberRef v19 = v18 + 1;
      }
      float v32 = v19;
      v4 += 2;
    }
    while (v4 != (void **)v5);
  }
  CFDictionaryRef v28 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!v28)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (values)
  {
    float v32 = values;
    operator delete(values);
  }
  if (keys)
  {
    uint64_t v35 = keys;
    operator delete(keys);
  }
  return v28;
}

void sub_21B4F4168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  __cxa_free_exception(v13);
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void std::vector<void const*>::reserve(void **a1, unint64_t a2)
{
  CFTypeRef v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    long long v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(v3, a2);
    long long v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    unint64_t v11 = (char *)*a1;
    unint64_t v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      unint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

applesauce::CF::StringRef *applesauce::CF::StringRef::StringRef(applesauce::CF::StringRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFStringGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
  }
  return this;
}

void sub_21B4F42F0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

void applesauce::CF::TypeRef::~TypeRef(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void *std::vector<float>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](a1, a2);
    CFTypeRef v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_21B4F43B0(_Unwind_Exception *exception_object)
{
  CFTypeID v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v2 = *(const void **)a1;
    if (v2) {
      CFRelease(v2);
    }
    *(unsigned char *)(a1 + 8) = 0;
  }
}

void std::vector<short>::__append(char **a1, unint64_t a2)
{
  long long v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int64_t v5 = v6;
  long long v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    uint64_t v10 = a2 + (v9 >> 1);
    if (v10 < 0) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 1;
    unint64_t v12 = v5 - v8;
    if (v12 > v10) {
      uint64_t v10 = v12;
    }
    if (v12 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v13 = v10;
    }
    if (v13)
    {
      char v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>(v4, v13);
      uint64_t v8 = *a1;
      long long v7 = a1[1];
    }
    else
    {
      char v14 = 0;
    }
    unint64_t v15 = &v14[2 * v11];
    uint64_t v16 = &v14[2 * v13];
    bzero(v15, 2 * a2);
    size_t v17 = &v15[2 * a2];
    while (v7 != v8)
    {
      __int16 v18 = *((_WORD *)v7 - 1);
      v7 -= 2;
      *((_WORD *)v15 - 1) = v18;
      v15 -= 2;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(2 * a2);
}

void std::__destroy_at[abi:ne180100]<IR::IRDataNode,0>(uint64_t a1)
{
  uint64_t v4 = (void **)(a1 + 72);
  std::vector<IR::IRDataNode>::__destroy_vector::operator()[abi:ne180100](&v4);
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  CFTypeID v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (void **)(a1 + 8);
  std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](&v4);
}

uint64_t std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

applesauce::CF::DataRef *applesauce::CF::DataRef::DataRef(applesauce::CF::DataRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFDataGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
  }
  return this;
}

void sub_21B4F4678(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<float>>::vector(void *a1, unint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    long long v6 = (void *)a1[1];
    uint64_t v7 = 3 * a2;
    uint64_t v8 = &v6[3 * a2];
    uint64_t v9 = 8 * v7;
    do
    {
      *long long v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v6, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_21B4F4744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<std::vector<float>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_21B4F4814(_Unwind_Exception *exception_object)
{
  CFTypeID v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    int64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        long long v6 = v4;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      int64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::construct_at[abi:ne180100]<applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef const&,applesauce::CF::DictionaryRef*>(void *a1, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *a1 = v3;
  return a1;
}

void std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>(const void **a1)
{
  uint64_t v1 = *a1;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>((const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<short>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<short>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_21B4F49B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__vallocate[abi:ne180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    int64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>(--v4);
      while (v4 != v2);
      int64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i = this->__i_;
  size_t v2 = (i + 1) % 0x270;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return (i << 15) & 0xEFC60000 ^ i ^ (((i << 15) & 0xEFC60000 ^ i) >> 18);
}

__n128 std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 88) = 0;
  __n128 result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a1 + 72) = result;
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a2 + 88) = 0;
  return result;
}

void std::vector<IR::IRDataNode>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 96;
    v4 -= 96;
    std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRDataNode>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(96 * a2);
}

uint64_t std::__split_buffer<IR::IRDataNode>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 96;
    std::__destroy_at[abi:ne180100]<IR::IRDataNode,0>(i - 96);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<IR::IRDataNode>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  size_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 96;
        std::__destroy_at[abi:ne180100]<IR::IRDataNode,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<IR::IRDataNode>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v10 = a2 + v6 - a4;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(v8, v10);
      v10 += 96;
      v8 += 96;
    }
    while (v10 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRDataNode *,IR::IRDataNode *,IR::IRDataNode *>((uint64_t)&v12, a2, v7, v6);
}

void std::__split_buffer<IR::IRDataNode>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  if (v4 == a1[3])
  {
    unint64_t v5 = a1[1];
    if (v5 <= *a1)
    {
      if (v4 == *a1) {
        unint64_t v10 = 1;
      }
      else {
        unint64_t v10 = 0x5555555555555556 * ((v4 - *a1) >> 5);
      }
      unint64_t v11 = v10 >> 2;
      uint64_t v12 = a1[4];
      uint64_t v28 = a1[4];
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRDataNode>>(v12, v10);
      char v14 = &v13[96 * v11];
      uint64_t v16 = &v13[96 * v15];
      unint64_t v17 = a1[1];
      int64_t v18 = a1[2] - v17;
      if (v18)
      {
        uint64_t v19 = v18 / 96;
        uint64_t v20 = &v14[96 * v19];
        uint64_t v21 = 96 * v19;
        uint64_t v22 = (uint64_t)v14;
        do
        {
          std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(v22, v17);
          v22 += 96;
          v17 += 96;
          v21 -= 96;
        }
        while (v21);
        int64x2_t v23 = *(int64x2_t *)(a1 + 1);
      }
      else
      {
        int64x2_t v23 = vdupq_n_s64(v17);
        uint64_t v20 = v14;
      }
      uint64_t v25 = *a1;
      *a1 = v13;
      a1[1] = v14;
      int64x2_t v26 = v23;
      uint64_t v24 = a1[3];
      a1[2] = v20;
      a1[3] = v16;
      uint64_t v27 = v24;
      std::__split_buffer<IR::IRDataNode>::~__split_buffer((uint64_t)&v25);
      uint64_t v4 = a1[2];
    }
    else
    {
      int64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 5);
      if (v6 >= -1) {
        uint64_t v7 = v6 + 1;
      }
      else {
        uint64_t v7 = v6 + 2;
      }
      uint64_t v8 = -3 * (v7 >> 1);
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRDataNode *,IR::IRDataNode *,IR::IRDataNode *>((uint64_t)&v25, v5, v4, v5 - 96 * (v7 >> 1));
      uint64_t v4 = v9;
      a1[1] += 32 * v8;
      a1[2] = v9;
    }
  }
  std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(v4, a2);
  a1[2] += 96;
}

uint64_t std::vector<IR::IRDataNode>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = a2[1];
  uint64_t v7 = *a1;
  uint64_t v8 = v6;
  if (*a1 != a3)
  {
    uint64_t v9 = a3;
    uint64_t v8 = a2[1];
    do
    {
      v8 -= 96;
      v9 -= 96;
      std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(v8, v9);
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  uint64_t v10 = a1[1];
  uint64_t v11 = a2[2];
  if (v10 != v3)
  {
    do
    {
      std::construct_at[abi:ne180100]<IR::IRDataNode,IR::IRDataNode,IR::IRDataNode*>(v11, v3);
      v3 += 96;
      v11 += 96;
    }
    while (v3 != v10);
    uint64_t v8 = a2[1];
  }
  a2[2] = v11;
  uint64_t v12 = *a1;
  *a1 = v8;
  a2[1] = v12;
  uint64_t v13 = a1[1];
  a1[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = a1[2];
  a1[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRDataNode *,IR::IRDataNode *,IR::IRDataNode *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      *(_DWORD *)(a4 + v7 - 96) = *(_DWORD *)(a3 + v7 - 96);
      std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vdeallocate((IR::FFTFilterKernel ***)(a4 + v7 - 88));
      *(_OWORD *)(v9 - 88) = *(_OWORD *)(a3 + v7 - 88);
      *(void *)(v9 - 72) = *(void *)(a3 + v7 - 72);
      *(void *)(v8 - 88) = 0;
      *(void *)(v8 - 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      long long v10 = *(_OWORD *)(a3 + v7 - 64);
      *(void *)(v8 - 72) = 0;
      *(void *)(v8 - 64) = 0;
      *(void *)(v8 - 56) = 0;
      uint64_t v11 = *(std::__shared_weak_count **)(a4 + v7 - 56);
      *(_OWORD *)(v9 - 64) = v10;
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }
      std::vector<float>::__move_assign(v9 - 48, (__n128 *)(v8 - 48));
      std::vector<IR::IRDataNode>::__vdeallocate((void **)(v9 - 24));
      *(_OWORD *)(v9 - 24) = *(_OWORD *)(v8 - 24);
      *(void *)(v9 - 8) = *(void *)(v8 - 8);
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 16) = 0;
      *(void *)(v8 - 8) = 0;
      v7 -= 96;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

void std::vector<IR::IRDataNode>::__vdeallocate(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 96;
        std::__destroy_at[abi:ne180100]<IR::IRDataNode,0>(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRDataNode *,IR::IRDataNode *,IR::IRDataNode *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v5 = a3;
  do
  {
    uint64_t v6 = a4;
    *(_DWORD *)a4 = *(_DWORD *)v4;
    uint64_t v7 = a4 + 8;
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vdeallocate((IR::FFTFilterKernel ***)(a4 + 8));
    *(_OWORD *)(v6 + 8) = *(_OWORD *)(v4 + 8);
    *(void *)(v6 + 24) = *(void *)(v4 + 24);
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
    long long v8 = *(_OWORD *)(v4 + 32);
    *(void *)(v4 + 24) = 0;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
    uint64_t v9 = *(std::__shared_weak_count **)(v6 + 40);
    *(_OWORD *)(v6 + 32) = v8;
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    std::vector<float>::__move_assign(v7 + 40, (__n128 *)(v4 + 48));
    std::vector<IR::IRDataNode>::__vdeallocate((void **)(v7 + 64));
    *(_OWORD *)(v6 + 72) = *(_OWORD *)(v4 + 72);
    *(void *)(v6 + 88) = *(void *)(v4 + 88);
    *(void *)(v4 + 72) = 0;
    *(void *)(v4 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
    *(void *)(v4 + 88) = 0;
    v4 += 96;
    a4 = v7 + 88;
  }
  while (v4 != v5);
  return v5;
}

uint64_t std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>,std::reverse_iterator<std::vector<std::unique_ptr<IR::FFTFilterKernel>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  size_t v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 3;
  }
}

void **std::__split_buffer<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
}

void std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vdeallocate(IR::FFTFilterKernel ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
        std::unique_ptr<IR::FFTFilterKernel>::reset[abi:ne180100](--v3, 0);
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__n128 std::vector<float>::__move_assign(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (uint64_t)v4 - 24;
      do
      {
        uint64_t v9 = v6;
        std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v9);
        uint64_t v7 = *(void **)(v6 - 24);
        if (v7)
        {
          *(void *)(v6 - 16) = v7;
          operator delete(v7);
        }
        long long v8 = (void *)(v6 - 32);
        v6 -= 56;
      }
      while (v8 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<IR::IRCoordinateTree>::__base_destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v4 = *(void ***)(a1 + 8);
  if (v4 != a2)
  {
    uint64_t v5 = v4 - 3;
    do
    {
      long long v8 = v5;
      std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v8);
      uint64_t v6 = *(v5 - 3);
      if (v6)
      {
        *(v5 - 2) = v6;
        operator delete(v6);
      }
      uint64_t v7 = v5 - 4;
      v5 -= 7;
    }
    while (v7 != a2);
  }
  *(void *)(a1 + 8) = a2;
}

void std::allocator_traits<std::allocator<IR::IRCoordinateTree>>::destroy[abi:ne180100]<IR::IRCoordinateTree,void,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void **)(a2 + 32);
  std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100](&v4);
  uint64_t v3 = *(void **)(a2 + 8);
  if (v3)
  {
    *(void *)(a2 + 16) = v3;
    operator delete(v3);
  }
}

uint64_t std::vector<IR::IRCoordinateTree>::__push_back_slow_path<IR::IRCoordinateTree>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249) {
    unint64_t v9 = 0x492492492492492;
  }
  else {
    unint64_t v9 = v5;
  }
  v15[4] = a1 + 2;
  long long v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinateTree>>(v7, v9);
  uint64_t v11 = &v10[56 * v4];
  v15[0] = v10;
  v15[1] = v11;
  v15[3] = &v10[56 * v12];
  *(_DWORD *)uint64_t v11 = *(_DWORD *)a2;
  *((void *)v11 + 2) = 0;
  *((void *)v11 + 3) = 0;
  *((void *)v11 + 1) = 0;
  *(_OWORD *)(v11 + 8) = *(_OWORD *)(a2 + 8);
  *((void *)v11 + 3) = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *((void *)v11 + 4) = 0;
  *((void *)v11 + 5) = 0;
  *((void *)v11 + 6) = 0;
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v11 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a2 + 48) = 0;
  v15[2] = v11 + 56;
  std::vector<IR::IRCoordinateTree>::__swap_out_circular_buffer(a1, v15);
  uint64_t v13 = a1[1];
  std::__split_buffer<IR::IRCoordinateTree>::~__split_buffer((uint64_t)v15);
  return v13;
}

void sub_21B4F57D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<IR::IRCoordinateTree>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<IR::IRCoordinateTree>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IR::IRCoordinateTree>,std::reverse_iterator<IR::IRCoordinateTree*>,std::reverse_iterator<IR::IRCoordinateTree*>,std::reverse_iterator<IR::IRCoordinateTree*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinateTree>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(56 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IR::IRCoordinateTree>,std::reverse_iterator<IR::IRCoordinateTree*>,std::reverse_iterator<IR::IRCoordinateTree*>,std::reverse_iterator<IR::IRCoordinateTree*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      int v8 = *(_DWORD *)(a3 - 56);
      a3 -= 56;
      *(_DWORD *)(v7 - 56) = v8;
      *(void *)(v7 - 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(v7 - 32) = 0;
      *(void *)(v7 - 48) = 0;
      *(_OWORD *)(v7 - 48) = *(_OWORD *)(a3 + 8);
      *(void *)(v7 - 32) = *(void *)(a3 + 24);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 32);
      *(void *)(v7 - 8) = *(void *)(a3 + 48);
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(a3 + 48) = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 56;
      *((void *)&v14 + 1) -= 56;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,std::reverse_iterator<IR::IRCoordinateTree*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,std::reverse_iterator<IR::IRCoordinateTree*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,std::reverse_iterator<IR::IRCoordinateTree*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,std::reverse_iterator<IR::IRCoordinateTree*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator_traits<std::allocator<IR::IRCoordinateTree>>::destroy[abi:ne180100]<IR::IRCoordinateTree,void,void>(v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

uint64_t std::__split_buffer<IR::IRCoordinateTree>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<IR::IRCoordinateTree>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  while (1)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4 == a2) {
      break;
    }
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 16) = v4 - 56;
    std::allocator_traits<std::allocator<IR::IRCoordinateTree>>::destroy[abi:ne180100]<IR::IRCoordinateTree,void,void>(v5, v4 - 56);
  }
}

char *std::vector<float>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    int v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      int v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  long long v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  long long v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  long long v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

uint64_t std::vector<IR::IRCoordinateTree>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v9 = v7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      *(_DWORD *)uint64_t v8 = *(_DWORD *)v9;
      *(void *)(v8 + 16) = 0;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 8) = 0;
      *(_OWORD *)(v8 + 8) = *(_OWORD *)(v9 + 8);
      *(void *)(v8 + 24) = *(void *)(v9 + 24);
      *(void *)(v9 + 8) = 0;
      *(void *)(v9 + 16) = 0;
      *(void *)(v9 + 24) = 0;
      *(void *)(v8 + 32) = 0;
      *(void *)(v8 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(v8 + 48) = 0;
      *(_OWORD *)(v8 + 32) = *(_OWORD *)(v9 + 32);
      *(void *)(v8 + 48) = *(void *)(v9 + 48);
      *(void *)(v9 + 32) = 0;
      *(void *)(v9 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(v9 + 48) = 0;
      v8 += 56;
      v9 += 56;
    }
    while (v9 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRCoordinateTree *,IR::IRCoordinateTree *,IR::IRCoordinateTree *>((uint64_t)&v11, a2, v7, v6);
}

__n128 std::__split_buffer<IR::IRCoordinateTree>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  if (v4 == a1[3])
  {
    unint64_t v5 = a1[1];
    if (v5 <= *a1)
    {
      if (v4 == *a1) {
        unint64_t v10 = 1;
      }
      else {
        unint64_t v10 = 0xDB6DB6DB6DB6DB6ELL * ((v4 - *a1) >> 3);
      }
      unint64_t v11 = v10 >> 2;
      uint64_t v12 = a1[4];
      uint64_t v20 = a1[4];
      *(void *)&long long v18 = std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinateTree>>(v12, v10);
      *((void *)&v18 + 1) = v18 + 56 * v11;
      *(void *)&long long v19 = *((void *)&v18 + 1);
      *((void *)&v19 + 1) = v18 + 56 * v13;
      std::__split_buffer<IR::IRCoordinateTree>::__construct_at_end_with_size<std::move_iterator<IR::IRCoordinateTree*>>((uint64_t)&v18, a1[1], 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[2] - a1[1]) >> 3));
      long long v14 = v19;
      long long v15 = *(_OWORD *)a1;
      long long v16 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v18;
      *((_OWORD *)a1 + 1) = v14;
      long long v18 = v15;
      long long v19 = v16;
      std::__split_buffer<IR::IRCoordinateTree>::~__split_buffer((uint64_t)&v18);
      uint64_t v4 = a1[2];
    }
    else
    {
      uint64_t v6 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 3);
      if (v6 >= -1) {
        uint64_t v7 = v6 + 1;
      }
      else {
        uint64_t v7 = v6 + 2;
      }
      uint64_t v8 = -56 * (v7 >> 1);
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRCoordinateTree *,IR::IRCoordinateTree *,IR::IRCoordinateTree *>((uint64_t)&v18, v5, v4, v5 - 56 * (v7 >> 1));
      uint64_t v4 = v9;
      a1[1] += v8;
      a1[2] = v9;
    }
  }
  *(_DWORD *)uint64_t v4 = *(_DWORD *)a2;
  *(void *)(v4 + 16) = 0;
  *(void *)(v4 + 24) = 0;
  *(void *)(v4 + 8) = 0;
  *(_OWORD *)(v4 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(v4 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(v4 + 32) = 0;
  *(void *)(v4 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(v4 + 48) = 0;
  __n128 result = *(__n128 *)(a2 + 32);
  *(__n128 *)(v4 + 32) = result;
  *(void *)(v4 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a2 + 48) = 0;
  a1[2] += 56;
  return result;
}

void sub_21B4F5D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::vector<IR::IRCoordinateTree>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IR::IRCoordinateTree>,std::reverse_iterator<IR::IRCoordinateTree*>,std::reverse_iterator<IR::IRCoordinateTree*>,std::reverse_iterator<IR::IRCoordinateTree*>>((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IR::IRCoordinateTree>,IR::IRCoordinateTree*,IR::IRCoordinateTree*,IR::IRCoordinateTree*>(v7, a3, a1[1], a2[2]);
  uint64_t v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRCoordinateTree *,IR::IRCoordinateTree *,IR::IRCoordinateTree *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      *(_DWORD *)(a4 + v7 - 56) = *(_DWORD *)(a3 + v7 - 56);
      std::vector<float>::__move_assign(a4 + v7 - 48, (__n128 *)(a3 + v7 - 48));
      std::vector<IR::IRCoordinateTree>::__vdeallocate(a4 + v7 - 24);
      *(_OWORD *)(v9 - 24) = *(_OWORD *)(a3 + v7 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 + v7 - 8);
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 16) = 0;
      *(void *)(v8 - 8) = 0;
      v7 -= 56;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

void std::vector<IR::IRCoordinateTree>::__vdeallocate(uint64_t a1)
{
  if (*(void *)a1)
  {
    std::vector<IR::IRCoordinateTree>::__base_destruct_at_end[abi:ne180100](a1, *(void ***)a1);
    operator delete(*(void **)a1);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<IR::IRCoordinateTree *,IR::IRCoordinateTree *,IR::IRCoordinateTree *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    *(_DWORD *)a4 = *(_DWORD *)v5;
    std::vector<float>::__move_assign(a4 + 8, (__n128 *)(v5 + 8));
    std::vector<IR::IRCoordinateTree>::__vdeallocate(a4 + 32);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(v5 + 32);
    *(void *)(a4 + 48) = *(void *)(v5 + 48);
    *(void *)(v5 + 32) = 0;
    *(void *)(v5 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
    *(void *)(v5 + 48) = 0;
    a4 += 56;
    v5 += 56;
  }
  while (v5 != v6);
  return v6;
}

uint64_t std::__split_buffer<IR::IRCoordinateTree>::__construct_at_end_with_size<std::move_iterator<IR::IRCoordinateTree*>>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 16);
  if (a3)
  {
    uint64_t v4 = v3 + 56 * a3;
    do
    {
      *(_DWORD *)uint64_t v3 = *(_DWORD *)a2;
      *(void *)(v3 + 16) = 0;
      *(void *)(v3 + 24) = 0;
      *(void *)(v3 + 8) = 0;
      *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)(v3 + 24) = *(void *)(a2 + 24);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(v3 + 32) = 0;
      *(void *)(v3 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(v3 + 48) = 0;
      *(_OWORD *)(v3 + 32) = *(_OWORD *)(a2 + 32);
      *(void *)(v3 + 48) = *(void *)(a2 + 48);
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(a2 + 48) = 0;
      v3 += 56;
      a2 += 56;
    }
    while (v3 != v4);
    uint64_t v3 = v4;
  }
  *(void *)(result + 16) = v3;
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IR::IRCoordinateTree>,IR::IRCoordinateTree*,IR::IRCoordinateTree*,IR::IRCoordinateTree*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = a4;
  uint64_t v8 = a4;
  v6[0] = a1;
  v6[1] = &v8;
  v6[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      *(_DWORD *)uint64_t v4 = *(_DWORD *)a2;
      *(void *)(v4 + 16) = 0;
      *(void *)(v4 + 24) = 0;
      *(void *)(v4 + 8) = 0;
      *(_OWORD *)(v4 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)(v4 + 24) = *(void *)(a2 + 24);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(v4 + 32) = 0;
      *(void *)(v4 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(v4 + 48) = 0;
      *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
      *(void *)(v4 + 48) = *(void *)(a2 + 48);
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      *(void *)(a2 + 48) = 0;
      v4 += 56;
      a2 += 56;
    }
    while (a2 != a3);
    uint64_t v9 = v4;
  }
  char v7 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,IR::IRCoordinateTree*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v6);
  return v4;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,IR::IRCoordinateTree*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,IR::IRCoordinateTree*>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<IR::IRCoordinateTree>,IR::IRCoordinateTree*>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 56;
      std::allocator_traits<std::allocator<IR::IRCoordinateTree>>::destroy[abi:ne180100]<IR::IRCoordinateTree,void,void>(v5, v3);
    }
    while (v3 != v4);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinates>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x71C71C71C71C71DLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(36 * a2);
}

void *std::vector<IR::FFTFilterKernel>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<IR::FFTFilterKernel>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = a1[1];
    uint64_t v5 = 5 * a2;
    unint64_t v6 = v4 + 40 * a2;
    uint64_t v7 = 8 * v5;
    do
    {
      IR::FFTFilterKernel::FFTFilterKernel(v4);
      v4 += 40;
      v7 -= 40;
    }
    while (v7);
    a1[1] = v6;
  }
  return a1;
}

void sub_21B4F6214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<IR::FFTFilterKernel>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::FFTFilterKernel>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[40 * v4];
  return result;
}

uint64_t applesauce::CF::details::number_convert_as<BOOL>(const __CFNumber *a1)
{
  switch(CFNumberGetType(a1))
  {
    case kCFNumberSInt8Type:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberSInt8Type;
      goto LABEL_10;
    case kCFNumberSInt16Type:
      LOWORD(valuePtr) = 0;
      CFNumberRef v5 = a1;
      CFNumberType v6 = kCFNumberSInt16Type;
      goto LABEL_12;
    case kCFNumberSInt32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v7 = a1;
      CFNumberType v8 = kCFNumberSInt32Type;
      goto LABEL_14;
    case kCFNumberSInt64Type:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberSInt64Type;
      goto LABEL_25;
    case kCFNumberFloat32Type:
      LODWORD(valuePtr) = 0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberFloat32Type;
      goto LABEL_21;
    case kCFNumberFloat64Type:
      double valuePtr = 0.0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberFloat64Type;
      goto LABEL_29;
    case kCFNumberCharType:
      LOBYTE(valuePtr) = 0;
      CFNumberRef v2 = a1;
      CFNumberType v3 = kCFNumberCharType;
LABEL_10:
      int Value = CFNumberGetValue(v2, v3, &valuePtr);
      BOOL v16 = Value == 0;
      int v17 = LOBYTE(valuePtr);
      goto LABEL_15;
    case kCFNumberShortType:
      LOWORD(valuePtr) = 0;
      CFNumberRef v5 = a1;
      CFNumberType v6 = kCFNumberShortType;
LABEL_12:
      int Value = CFNumberGetValue(v5, v6, &valuePtr);
      BOOL v16 = Value == 0;
      int v17 = LOWORD(valuePtr);
      goto LABEL_15;
    case kCFNumberIntType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v7 = a1;
      CFNumberType v8 = kCFNumberIntType;
LABEL_14:
      int Value = CFNumberGetValue(v7, v8, &valuePtr);
      BOOL v16 = Value == 0;
      int v17 = LODWORD(valuePtr);
LABEL_15:
      BOOL v18 = v16 || v17 == 0;
      goto LABEL_33;
    case kCFNumberLongType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberLongType;
      goto LABEL_25;
    case kCFNumberLongLongType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberLongLongType;
      goto LABEL_25;
    case kCFNumberFloatType:
      LODWORD(valuePtr) = 0;
      CFNumberRef v11 = a1;
      CFNumberType v12 = kCFNumberFloatType;
LABEL_21:
      int Value = CFNumberGetValue(v11, v12, &valuePtr);
      BOOL v19 = *(float *)&valuePtr == 0.0;
      goto LABEL_30;
    case kCFNumberDoubleType:
      double valuePtr = 0.0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberDoubleType;
      goto LABEL_29;
    case kCFNumberCFIndexType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberCFIndexType;
      goto LABEL_25;
    case kCFNumberNSIntegerType:
      double valuePtr = 0.0;
      CFNumberRef v9 = a1;
      CFNumberType v10 = kCFNumberNSIntegerType;
LABEL_25:
      int Value = CFNumberGetValue(v9, v10, &valuePtr);
      if (Value) {
        BOOL v18 = *(void *)&valuePtr == 0;
      }
      else {
        BOOL v18 = 1;
      }
      goto LABEL_33;
    case kCFNumberCGFloatType:
      double valuePtr = 0.0;
      CFNumberRef v13 = a1;
      CFNumberType v14 = kCFNumberCGFloatType;
LABEL_29:
      int Value = CFNumberGetValue(v13, v14, &valuePtr);
      BOOL v19 = valuePtr == 0.0;
LABEL_30:
      BOOL v18 = v19 || Value == 0;
LABEL_33:
      int v4 = !v18;
      if (!Value) {
        goto LABEL_38;
      }
      int v20 = 256;
      break;
    default:
      int v4 = 0;
LABEL_38:
      int v20 = 0;
      break;
  }
  return v20 | v4;
}

uint64_t std::__optional_destruct_base<applesauce::CF::NumberRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    CFNumberRef v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

uint64_t std::__optional_destruct_base<applesauce::CF::BooleanRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    CFNumberRef v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

IR::FFTFilterKernel *std::unique_ptr<IR::FFTFilterKernel>::reset[abi:ne180100](IR::FFTFilterKernel **a1, IR::FFTFilterKernel *a2)
{
  __n128 result = *a1;
  *a1 = a2;
  if (result)
  {
    IR::FFTFilterKernel::~FFTFilterKernel(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>(uint64_t **a1)
{
  std::vector<void const*>::vector(__p, a1[1] - *a1);
  CFNumberRef v2 = *a1;
  CFNumberType v3 = a1[1];
  if (*a1 != v3)
  {
    int v4 = __p[0];
    do
    {
      uint64_t v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_21B4F6614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<void const*>(uint64_t a1)
{
  CFArrayRef result = CFArrayCreate(0, *(const void ***)a1, (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3, MEMORY[0x263EFFF70]);
  if (!result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_21B4F6680()
{
}

void sub_21B4F66A0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<void const*>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vallocate[abi:ne180100](a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_21B4F6710(_Unwind_Exception *exception_object)
{
  CFNumberType v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t applesauce::CF::at_or<applesauce::CF::DictionaryRef>@<X0>(const __CFArray *a1@<X0>, unint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  applesauce::CF::details::at_as<applesauce::CF::DictionaryRef>(a1, a2, &cf);
  if (v9)
  {
    CFTypeRef v6 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *a4 = v6;
  }
  else
  {
    *a4 = *a3;
    *a3 = 0;
  }
  return std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
}

void applesauce::CF::details::at_as<applesauce::CF::DictionaryRef>(const __CFArray *a1@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (!a1) {
    goto LABEL_7;
  }
  if (CFArrayGetCount(a1) <= a2) {
    goto LABEL_7;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(a1, a2);
  CFNumberRef v7 = ValueAtIndex;
  if (!ValueAtIndex) {
    goto LABEL_7;
  }
  CFRetain(ValueAtIndex);
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFDictionaryGetTypeID())
  {
    CFRelease(v7);
LABEL_7:
    char v9 = 0;
    *a3 = 0;
    goto LABEL_8;
  }
  *(void *)a3 = v7;
  char v9 = 1;
LABEL_8:
  a3[8] = v9;
}

float applesauce::CF::at_or<float,char const(&)[13]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[13]>(a1, a2);
  if (!v4) {
    return *(float *)a3;
  }
  uint64_t v5 = applesauce::CF::convert_as<float,0>(v4);
  float result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0) {
    return *(float *)a3;
  }
  return result;
}

const void *applesauce::CF::details::at_key<char const(&)[13]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F6954(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

float applesauce::CF::at_or<float,char const(&)[11]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[11]>(a1, a2);
  if (!v4) {
    return *(float *)a3;
  }
  uint64_t v5 = applesauce::CF::convert_as<float,0>(v4);
  float result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0) {
    return *(float *)a3;
  }
  return result;
}

const void *applesauce::CF::details::at_key<char const(&)[11]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F6AA4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const*>@<X0>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*>(a1, a2, &cf);
  if (v9)
  {
    CFTypeRef v6 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *a4 = v6;
  }
  else
  {
    *a4 = *a3;
    *a3 = 0;
  }
  return std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, unsigned char *a3@<X8>)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFDictionaryRef v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFArrayGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

const __CFDictionary *applesauce::CF::details::at_key<__CFString const*>(const __CFDictionary *result, const void **a2)
{
  if (result)
  {
    CFNumberRef v2 = *a2;
    if (v2) {
      return (const __CFDictionary *)CFDictionaryGetValue(result, v2);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t applesauce::CF::at_or<unsigned int,__CFString const*>(const __CFDictionary *a1, const void **a2, unsigned int *a3)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*>(a1, a2);
  if (!v4) {
    return *a3;
  }
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

IR::IRData::Implementation *std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](IR::IRData::Implementation **a1, IR::IRData::Implementation *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    IR::IRData::Implementation::~Implementation(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

void IR::IRData::Implementation::~Implementation(IR::IRData::Implementation *this)
{
  CFNumberRef v13 = (void **)((char *)this + 504);
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100](&v13);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRData::Implementation *)((char *)this + 336));
  CFNumberRef v13 = (void **)((char *)this + 304);
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&v13);
  CFNumberRef v2 = (const void *)*((void *)this + 37);
  if (v2) {
    CFRelease(v2);
  }
  CFNumberType v3 = (const void *)*((void *)this + 36);
  if (v3) {
    CFRelease(v3);
  }
  CFDictionaryRef v4 = (const void *)*((void *)this + 35);
  if (v4) {
    CFRelease(v4);
  }
  CFDictionaryRef v5 = (std::__shared_weak_count *)*((void *)this + 34);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  CFTypeID v6 = (void *)*((void *)this + 25);
  if (v6)
  {
    *((void *)this + 26) = v6;
    operator delete(v6);
  }
  char v7 = (void *)*((void *)this + 22);
  if (v7)
  {
    *((void *)this + 23) = v7;
    operator delete(v7);
  }
  CFTypeID v8 = (void *)*((void *)this + 19);
  if (v8)
  {
    *((void *)this + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v8;
    operator delete(v8);
  }
  char v9 = (void *)*((void *)this + 16);
  if (v9)
  {
    *((void *)this + 17) = v9;
    operator delete(v9);
  }
  CFNumberType v10 = (void *)*((void *)this + 13);
  if (v10)
  {
    *((void *)this + 14) = v10;
    operator delete(v10);
  }
  CFNumberRef v11 = (void *)*((void *)this + 10);
  if (v11)
  {
    *((void *)this + 11) = v11;
    operator delete(v11);
  }
  CFNumberType v12 = (void *)*((void *)this + 5);
  if (v12)
  {
    *((void *)this + 6) = v12;
    operator delete(v12);
  }
}

void std::__shared_ptr_emplace<std::vector<IR::IRDataNode>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB574D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<IR::IRDataNode>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB574D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

void std::__shared_ptr_emplace<std::vector<IR::IRDataNode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  std::vector<IR::IRDataNode>::__destroy_vector::operator()[abi:ne180100](&v1);
}

const void *applesauce::CF::details::at_key<char const(&)[21]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F6F00(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t applesauce::CF::at_or<unsigned int,char const(&)[13]>(const __CFDictionary *a1, char *a2, unsigned int *a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[13]>(a1, a2);
  if (!v4) {
    return *a3;
  }
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

uint64_t applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>@<X0>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,__CFString const*>(a1, a2, &cf);
  if (v9)
  {
    CFTypeRef v6 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *a4 = v6;
  }
  else
  {
    *a4 = *a3;
    *a3 = 0;
  }
  return std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,__CFString const*>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, unsigned char *a3@<X8>)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFDictionaryRef v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFDictionaryGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

float applesauce::CF::at_or<float,char const(&)[18]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[18]>(a1, a2);
  if (!v4) {
    return *(float *)a3;
  }
  uint64_t v5 = applesauce::CF::convert_as<float,0>(v4);
  float result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0) {
    return *(float *)a3;
  }
  return result;
}

const void *applesauce::CF::details::at_key<char const(&)[18]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F717C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

const __CFDictionary *applesauce::CF::details::at_key<__CFString const*&>(const __CFDictionary *result, const void **a2)
{
  if (result)
  {
    CFNumberRef v2 = *a2;
    if (v2) {
      return (const __CFDictionary *)CFDictionaryGetValue(result, v2);
    }
    else {
      return 0;
    }
  }
  return result;
}

float applesauce::CF::at_or<float,__CFString const*&>(const __CFDictionary *a1, const void **a2, uint64_t a3)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (!v4) {
    return *(float *)a3;
  }
  uint64_t v5 = applesauce::CF::convert_as<float,0>(v4);
  float result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0) {
    return *(float *)a3;
  }
  return result;
}

uint64_t applesauce::CF::at_or<unsigned int,__CFString const*&>(const __CFDictionary *a1, const void **a2, unsigned int *a3)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (!v4) {
    return *a3;
  }
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

void *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,float &>(void *a1, CFTypeRef *a2, int *a3)
{
  CFTypeRef v5 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *a1 = v5;
  int valuePtr = *a3;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  a1[1] = v6;
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4F7318(_Unwind_Exception *a1)
{
  CFNumberType v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

void *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int &>(void *a1, CFTypeRef *a2, int *a3)
{
  CFTypeRef v5 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *a1 = v5;
  int valuePtr = *a3;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  a1[1] = v6;
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4F7400(_Unwind_Exception *a1)
{
  CFNumberType v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

const __CFDictionary *applesauce::CF::details::has_key<__CFString const*>(const __CFDictionary *result, const void **a2)
{
  if (result)
  {
    CFNumberRef v2 = *a2;
    if (v2) {
      return (const __CFDictionary *)(CFDictionaryContainsKey(result, v2) != 0);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t applesauce::CF::details::find_at_key<unsigned int,char const(&)[22]>(const __CFDictionary *a1, char *a2)
{
  CFNumberRef v2 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[22]>(a1, a2);
  if (!v2)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }

  return applesauce::CF::convert_to<unsigned int,0>(v2);
}

void sub_21B4F74C0()
{
}

void sub_21B4F74E0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const void *applesauce::CF::details::at_key<char const(&)[22]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F75C0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t applesauce::CF::at_or<unsigned int,char const(&)[12]>(const __CFDictionary *a1, char *a2, unsigned int *a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[12]>(a1, a2);
  if (!v4) {
    return *a3;
  }
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

const void *applesauce::CF::details::at_key<char const(&)[12]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F770C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t applesauce::CF::at_or<unsigned int,char const(&)[20]>(const __CFDictionary *a1, char *a2, unsigned int *a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[20]>(a1, a2);
  if (!v4) {
    return *a3;
  }
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

const void *applesauce::CF::details::at_key<char const(&)[20]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F7858(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void applesauce::CF::at_or<std::string,char const(&)[18]>(const __CFDictionary *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<std::string,char const(&)[18]>(a1, a2, __p);
  if (v8)
  {
    if (SHIBYTE(v7) < 0)
    {
      std::string::__init_copy_ctor_external(a4, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      if (v8)
      {
        if (SHIBYTE(v7) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
      a4->__r_.__value_.__r.__words[2] = v7;
    }
  }
  else
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    a4->__r_.__value_.__r.__words[2] = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
  }
}

const void *applesauce::CF::details::find_at_key_or_optional<std::string,char const(&)[18]>@<X0>(const __CFDictionary *a1@<X0>, char *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = applesauce::CF::details::at_key<char const(&)[18]>(a1, a2);
  if (result)
  {
    return (const void *)applesauce::CF::convert_as<std::string,0>((CFTypeID)result, (uint64_t)a3);
  }
  else
  {
    *a3 = 0;
    a3[24] = 0;
  }
  return result;
}

CFTypeID applesauce::CF::convert_as<std::string,0>@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  if (result
    && (v3 = (const __CFString *)result, TypeID = CFStringGetTypeID(), uint64_t result = CFGetTypeID(v3), TypeID == result))
  {
    uint64_t result = (CFTypeID)applesauce::CF::details::CFString_get_value<false>(v3, (uint64_t)&v5);
    *(_OWORD *)a2 = v5;
    *(void *)(a2 + 16) = v6;
    *(unsigned char *)(a2 + 24) = 1;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
  return result;
}

void *applesauce::CF::details::CFString_get_value<false>@<X0>(const __CFString *a1@<X0>, uint64_t a2@<X8>)
{
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr) {
    return std::string::basic_string[abi:ne180100]<0>((void *)a2, CStringPtr);
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex maxBufLen = 0;
  v9.location = 0;
  v9.length = Length;
  CFStringGetBytes(a1, v9, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  std::string::basic_string[abi:ne180100]((void *)a2, maxBufLen, 0);
  if (*(char *)(a2 + 23) >= 0) {
    std::string::size_type v7 = (UInt8 *)a2;
  }
  else {
    std::string::size_type v7 = *(UInt8 **)a2;
  }
  v10.location = 0;
  v10.length = Length;
  return (void *)CFStringGetBytes(a1, v10, 0x8000100u, 0, 0, v7, maxBufLen, &maxBufLen);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  long long v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    char v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    long long v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void applesauce::CF::at_or<std::string,char const(&)[12]>(const __CFDictionary *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<std::string,char const(&)[12]>(a1, a2, __p);
  if (v8)
  {
    if (SHIBYTE(v7) < 0)
    {
      std::string::__init_copy_ctor_external(a4, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      if (v8)
      {
        if (SHIBYTE(v7) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
      a4->__r_.__value_.__r.__words[2] = v7;
    }
  }
  else
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    a4->__r_.__value_.__r.__words[2] = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
  }
}

const void *applesauce::CF::details::find_at_key_or_optional<std::string,char const(&)[12]>@<X0>(const __CFDictionary *a1@<X0>, char *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = applesauce::CF::details::at_key<char const(&)[12]>(a1, a2);
  if (result)
  {
    return (const void *)applesauce::CF::convert_as<std::string,0>((CFTypeID)result, (uint64_t)a3);
  }
  else
  {
    *a3 = 0;
    a3[24] = 0;
  }
  return result;
}

void applesauce::CF::at_or<std::string,char const(&)[5]>(const __CFDictionary *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<std::string,char const(&)[5]>(a1, a2, __p);
  if (v8)
  {
    if (SHIBYTE(v7) < 0)
    {
      std::string::__init_copy_ctor_external(a4, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      if (v8)
      {
        if (SHIBYTE(v7) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
      a4->__r_.__value_.__r.__words[2] = v7;
    }
  }
  else
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    a4->__r_.__value_.__r.__words[2] = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
  }
}

const void *applesauce::CF::details::find_at_key_or_optional<std::string,char const(&)[5]>@<X0>(const __CFDictionary *a1@<X0>, char *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = applesauce::CF::details::at_key<char const(&)[5]>(a1, a2);
  if (result)
  {
    return (const void *)applesauce::CF::convert_as<std::string,0>((CFTypeID)result, (uint64_t)a3);
  }
  else
  {
    *a3 = 0;
    a3[24] = 0;
  }
  return result;
}

const void *applesauce::CF::details::at_key<char const(&)[5]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F7E2C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

float applesauce::CF::at_or<float,char const(&)[12]>(const __CFDictionary *a1, char *a2, uint64_t a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[12]>(a1, a2);
  if (!v4) {
    return *(float *)a3;
  }
  uint64_t v5 = applesauce::CF::convert_as<float,0>(v4);
  float result = *(float *)&v5;
  if ((v5 & 0xFF00000000) == 0) {
    return *(float *)a3;
  }
  return result;
}

uint64_t applesauce::CF::at_or<unsigned int,char const(&)[14]>(const __CFDictionary *a1, char *a2, unsigned int *a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[14]>(a1, a2);
  if (!v4) {
    return *a3;
  }
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

const void *applesauce::CF::details::at_key<char const(&)[14]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B4F7FBC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t applesauce::CF::at_or<applesauce::CF::StringRef,__CFString const*>@<X0>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::StringRef,__CFString const*>(a1, a2, &cf);
  if (v9)
  {
    CFTypeRef v6 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *a4 = v6;
  }
  else
  {
    *a4 = *a3;
    *a3 = 0;
  }
  return std::__optional_destruct_base<applesauce::CF::StringRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::StringRef,__CFString const*>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, unsigned char *a3@<X8>)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFDictionaryRef v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFStringGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

uint64_t std::__optional_destruct_base<applesauce::CF::StringRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    CFNumberRef v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

void applesauce::CF::details::find_at_key_or_optional<std::vector<float>,__CFString const*&>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, unsigned char *a3@<X8>)
{
  CFArrayRef v4 = applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (v4)
  {
    applesauce::CF::convert_as<std::vector<float>,0>(v4, a3);
  }
  else
  {
    *a3 = 0;
    a3[24] = 0;
  }
}

void applesauce::CF::convert_as<std::vector<float>,0>(const __CFArray *a1@<X0>, unsigned char *a2@<X8>)
{
  if (a1 && (CFTypeID TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(a1)))
  {
    applesauce::CF::details::CFArray_get_value_as<std::vector<float>>(a1, (uint64_t)a2);
  }
  else
  {
    *a2 = 0;
    a2[24] = 0;
  }
}

void applesauce::CF::details::CFArray_get_value_as<std::vector<float>>(const __CFArray *a1@<X0>, uint64_t a2@<X8>)
{
  int Count = CFArrayGetCount(a1);
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
  uint64_t v22 = 0;
  int64x2_t v23 = 0;
  std::vector<float>::reserve(&__p, Count);
  if (Count <= 0)
  {
    CFNumberRef v11 = v22;
LABEL_23:
    int v20 = v23;
    *(void *)a2 = __p;
    *(void *)(a2 + 8) = v11;
    *(void *)(a2 + 16) = v20;
    *(unsigned char *)(a2 + 24) = 1;
  }
  else
  {
    CFIndex v5 = 0;
    uint64_t v6 = Count;
    while (1)
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, v5);
      uint64_t v8 = applesauce::CF::convert_as<float,0>(ValueAtIndex);
      if ((v8 & 0xFF00000000) == 0) {
        break;
      }
      int v9 = v8;
      CFRange v10 = v22;
      if (v22 >= v23)
      {
        CFNumberType v12 = (char *)__p;
        uint64_t v13 = (v22 - (unsigned char *)__p) >> 2;
        unint64_t v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 62) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v23 - (unsigned char *)__p;
        if ((v23 - (unsigned char *)__p) >> 1 > v14) {
          unint64_t v14 = v15 >> 1;
        }
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16)
        {
          int v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v23, v16);
          CFNumberType v12 = (char *)__p;
          CFRange v10 = v22;
        }
        else
        {
          int v17 = 0;
        }
        BOOL v18 = &v17[4 * v13];
        *(_DWORD *)BOOL v18 = v9;
        CFNumberRef v11 = v18 + 4;
        while (v10 != v12)
        {
          int v19 = *((_DWORD *)v10 - 1);
          v10 -= 4;
          *((_DWORD *)v18 - 1) = v19;
          v18 -= 4;
        }
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = v18;
        uint64_t v22 = v11;
        int64x2_t v23 = &v17[4 * v16];
        if (v12) {
          operator delete(v12);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v22 = v8;
        CFNumberRef v11 = v10 + 4;
      }
      uint64_t v22 = v11;
      if (++v5 == v6) {
        goto LABEL_23;
      }
    }
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    if (__p)
    {
      uint64_t v22 = (char *)__p;
      operator delete(__p);
    }
  }
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  CFArrayRef v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v3, a2);
    char v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    int v9 = &v6[4 * v8];
    CFRange v10 = (char *)*a1;
    CFNumberRef v11 = (char *)a1[1];
    CFNumberType v12 = v7;
    if (v11 != *a1)
    {
      CFNumberType v12 = v7;
      do
      {
        int v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*&>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, unsigned char *a3@<X8>)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFDictionaryRef v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFArrayGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

IR::DelayLine *std::unique_ptr<IR::DelayLine>::reset[abi:ne180100](IR::DelayLine **a1, IR::DelayLine *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    IR::DelayLine::~DelayLine(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

unint64_t applesauce::CF::convert_as<IR::IRDataType,0>(const __CFNumber *a1)
{
  if (a1 && (CFTypeID TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(a1)))
  {
    int valuePtr = 0;
    int Value = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
    unsigned int v4 = valuePtr & 0xFFFFFF00;
    int v5 = valuePtr;
    if (!Value)
    {
      unsigned int v4 = 0;
      int v5 = 0;
    }
    unint64_t v6 = (unint64_t)(Value != 0) << 32;
  }
  else
  {
    int v5 = 0;
    unint64_t v6 = 0;
    unsigned int v4 = 0;
  }
  return v6 | v4 | v5;
}

uint64_t applesauce::CF::at_or<unsigned int,char const(&)[22]>(const __CFDictionary *a1, char *a2, unsigned int *a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[22]>(a1, a2);
  if (!v4) {
    return *a3;
  }
  uint64_t result = applesauce::CF::convert_as<unsigned int,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

void *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::DataRef>(void *a1, CFTypeRef *a2, const void **a3)
{
  CFTypeRef v5 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *a1 = v5;
  unint64_t v6 = *a3;
  if (v6) {
    CFRetain(v6);
  }
  a1[1] = v6;
  return a1;
}

void *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::DictionaryRef>(void *a1, CFTypeRef *a2, const void **a3)
{
  CFTypeRef v5 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *a1 = v5;
  unint64_t v6 = *a3;
  if (v6) {
    CFRetain(v6);
  }
  a1[1] = v6;
  return a1;
}

void *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::StringRef>(void *a1, CFTypeRef *a2, const void **a3)
{
  CFTypeRef v5 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *a1 = v5;
  unint64_t v6 = *a3;
  if (v6) {
    CFRetain(v6);
  }
  a1[1] = v6;
  return a1;
}

void *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,applesauce::CF::StringRef&>(void *a1, CFTypeRef *a2, const void **a3)
{
  CFTypeRef v5 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *a1 = v5;
  unint64_t v6 = *a3;
  if (v6) {
    CFRetain(v6);
  }
  a1[1] = v6;
  return a1;
}

uint64_t applesauce::CF::at_or<applesauce::CF::StringRef,char const* const&>@<X0>(const __CFDictionary *a1@<X0>, const char **a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::StringRef,char const* const&>(a1, a2, &cf);
  if (v9)
  {
    CFTypeRef v6 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *a4 = v6;
  }
  else
  {
    *a4 = *a3;
    *a3 = 0;
  }
  return std::__optional_destruct_base<applesauce::CF::StringRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::StringRef,char const* const&>(const __CFDictionary *a1@<X0>, const char **a2@<X1>, unsigned char *a3@<X8>)
{
  CFNumberRef v4 = applesauce::CF::details::at_key<char const* const&>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFTypeRef v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFStringGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::StringRef>(applesauce::CF::TypeRef *a1, char **a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, *a2);
  CFTypeRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRef::TypeRef(applesauce::CF::TypeRef *this, char *a2)
{
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  if ((v9 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v9 & 0x80u) == 0) {
    CFIndex v4 = v9;
  }
  else {
    CFIndex v4 = (CFIndex)__p[1];
  }
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)v3, v4, 0x8000100u, 0);
  *(void *)this = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if ((char)v9 < 0) {
    operator delete(__p[0]);
  }
  return this;
}

void sub_21B4F894C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*v15) {
    CFRelease(*v15);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void applesauce::CF::at_or<std::string,char const* const&>(const __CFDictionary *a1@<X0>, const char **a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<std::string,char const* const&>(a1, a2, __p);
  if (v8)
  {
    if (SHIBYTE(v7) < 0)
    {
      std::string::__init_copy_ctor_external(a4, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      if (v8)
      {
        if (SHIBYTE(v7) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
      a4->__r_.__value_.__r.__words[2] = v7;
    }
  }
  else
  {
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    a4->__r_.__value_.__r.__words[2] = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
  }
}

const void *applesauce::CF::details::find_at_key_or_optional<std::string,char const* const&>@<X0>(const __CFDictionary *a1@<X0>, const char **a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = applesauce::CF::details::at_key<char const* const&>(a1, a2);
  if (result)
  {
    return (const void *)applesauce::CF::convert_as<std::string,0>((CFTypeID)result, (uint64_t)a3);
  }
  else
  {
    *a3 = 0;
    a3[24] = 0;
  }
  return result;
}

void std::vector<std::vector<std::vector<float>>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = (void **)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<std::vector<float>>>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      char v8 = v3;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v8);
    }
    a1[1] = v7;
  }
}

void std::vector<std::vector<std::vector<float>>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      CFNumberType v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v4, v11);
    }
    else {
      CFNumberType v12 = 0;
    }
    uint64_t v15 = v12;
    unint64_t v16 = &v12[24 * v8];
    BOOL v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    int v17 = &v16[v14];
    std::vector<std::vector<std::vector<float>>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(&v15);
  }
}

void sub_21B4F8C78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<std::vector<float>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  CFNumberRef v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 3;
  }
}

void **std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<std::vector<float>>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
}

void std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1}>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1}>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_26CB57350;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1}>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB57350;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1}>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
}

void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#1}::operator()(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(_DWORD *)(**(void **)a1 + 4 * a3) = *(_DWORD *)a2;
  if (*(void *)(a2 + 16) != *(void *)(a2 + 8))
  {
    uint64_t v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = a2 + 48;
    unint64_t v8 = v6[1];
    if (v8 >= v6[2])
    {
      uint64_t v9 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v6, v7);
    }
    else
    {
      std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v6, v7);
      uint64_t v9 = v8 + 24;
    }
    v6[1] = v9;
    unint64_t v10 = *(uint64_t **)(a1 + 16);
    unint64_t v11 = *(void **)a1;
    unint64_t v12 = v10[1];
    if (v12 >= v10[2])
    {
      uint64_t v13 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v10, (uint64_t)v11);
    }
    else
    {
      std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v10, (uint64_t)v11);
      uint64_t v13 = v12 + 24;
    }
    v10[1] = v13;
    std::vector<std::vector<float>>::vector(v18, *(unsigned int *)(v3 + 32));
    if (*(_DWORD *)(v3 + 32))
    {
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      do
      {
        unint64_t v16 = **(const void ***)(*(void *)(a2 + 8) + 8 * v15);
        std::vector<float>::resize(v18[0] + v14, *(unsigned int *)(v3 + 8));
        uint64_t v17 = *(unsigned int *)(v3 + 8);
        if (v17) {
          memmove(*(void **)(v18[0] + v14), v16, 4 * v17);
        }
        ++v15;
        v14 += 24;
      }
      while (v15 < *(unsigned int *)(v3 + 32));
    }
    std::vector<std::vector<std::vector<float>>>::push_back[abi:ne180100](*(uint64_t **)(a1 + 32), (uint64_t)v18);
    uint64_t v19 = (void **)v18;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v19);
  }
}

void sub_21B4F90AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void **std::vector<std::vector<std::vector<float>>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  __n128 result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)result, v12);
    uint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)uint64_t v14 = 0;
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<std::vector<float>>>::__swap_out_circular_buffer(a1, v16);
    unint64_t v8 = (void *)a1[1];
    __n128 result = std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    unint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_21B4F91F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  __n128 result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v3, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  *(void *)(a1 + 8) = v3 + 3;
  return result;
}

void sub_21B4F9258(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  unint64_t v16 = &v10[24 * v9];
  *(void *)unint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v11, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  v15 += 24;
  std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_21B4F9364(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<float>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_21B4F9408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2}>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2}>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_26CB57308;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2}>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB57308;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 *std::__function::__func<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2},std::allocator<void IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2}>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2}::operator()((__n128 *)(a1 + 8), a2, *a3);
}

__n128 *IR::IRData::Implementation::vectorizeIRData<std::vector<float>>(std::vector<std::vector<float>> &,std::vector<std::vector<float>> &,std::vector<std::vector<std::vector<float>>> &)::{lambda(IR::IRDataNode &,unsigned int)#2}::operator()(__n128 *result, uint64_t a2, unsigned int a3)
{
  unint64_t v4 = result;
  size_t v5 = (unsigned int *)result->n128_u64[0];
  uint64_t v6 = *(void *)(result->n128_u64[0] + 104);
  if (a3 < (unint64_t)((*(void *)(result->n128_u64[0] + 112) - v6) >> 2)) {
    *(_DWORD *)(*(void *)result->n128_u64[1] + 4 * *(int *)(v6 + 4 * a3)) = *(_DWORD *)a2;
  }
  uint64_t v7 = *(void **)(a2 + 32);
  if (v7)
  {
    uint64_t v8 = v7[5];
    if (v7[6] != v8)
    {
      uint64_t v9 = 0;
      unsigned int v10 = 0;
      do
      {
        unint64_t v11 = (uint64_t *)v4->n128_u64[1];
        uint64_t v12 = *v11;
        *(_DWORD *)(*v11 + 4 * v5[124]) = *(_DWORD *)(v7[8] + 4 * v9);
        *(_DWORD *)(v12 + 4 * v5[123]) = *(_DWORD *)(v8 + 4 * v9);
        uint64_t v13 = (uint64_t *)v4[1].n128_u64[0];
        unint64_t v14 = v13[1];
        if (v14 >= v13[2])
        {
          uint64_t v15 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v13, (uint64_t)v11);
        }
        else
        {
          std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v13, (uint64_t)v11);
          uint64_t v15 = v14 + 24;
        }
        v13[1] = v15;
        std::vector<std::vector<float>>::vector(v20, v5[8]);
        if (v5[8])
        {
          uint64_t v16 = 0;
          unint64_t v17 = 0;
          do
          {
            BOOL v18 = **(const void ***)(*(void *)(*(void *)(*(void *)(a2 + 32) + 88) + 24 * v9) + 8 * v17);
            std::vector<float>::resize(v20[0] + v16, v5[2]);
            uint64_t v19 = v5[2];
            if (v19) {
              memmove(*(void **)(v20[0] + v16), v18, 4 * v19);
            }
            ++v17;
            v16 += 24;
          }
          while (v17 < v5[8]);
        }
        std::vector<std::vector<std::vector<float>>>::push_back[abi:ne180100]((uint64_t *)v4[1].n128_u64[1], (uint64_t)v20);
        uint64_t v21 = (void **)v20;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v21);
        uint64_t v7 = *(void **)(a2 + 32);
        uint64_t v8 = v7[5];
        uint64_t v9 = ++v10;
      }
      while (v10 < (unint64_t)((v7[6] - v8) >> 2));
    }
    return std::vector<std::vector<float>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::vector<float>*>,std::__wrap_iter<std::vector<float>*>>((uint64_t *)v4[2].n128_u64[0], *(__n128 **)(v4[2].n128_u64[0] + 8), v7[14], v7[15], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7[15] - v7[14]) >> 3));
  }
  return result;
}

void sub_21B4F9690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

__n128 *std::vector<std::vector<float>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::vector<float>*>,std::__wrap_iter<std::vector<float>*>>(uint64_t *a1, __n128 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v12) >> 3)) >= a5)
    {
      uint64_t v20 = v12 - (void)a2;
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (void)a2) >> 3)) >= a5)
      {
        uint64_t v21 = a3 + 24 * a5;
      }
      else
      {
        uint64_t v21 = a3 + 8 * ((uint64_t)(v12 - (void)a2) >> 3);
        a1[1] = (uint64_t)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v9, v21, a4, *(void **)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }
      std::vector<std::vector<float>>::__move_range((uint64_t)a1, v5, v12, (uint64_t)v5 + 24 * a5);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>((int)&v23, a3, v21, (char *)v5);
    }
    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x5555555555555555 * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - v13) >> 3);
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v13) >> 3);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = v14;
      }
      if (v16 >= 0x555555555555555) {
        unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v27 = v9;
      if (v18) {
        uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v9, v18);
      }
      else {
        uint64_t v19 = 0;
      }
      int64x2_t v23 = v19;
      uint64_t v24 = &v19[24 * v15];
      uint64_t v25 = v24;
      int64x2_t v26 = &v19[24 * v18];
      std::__split_buffer<std::vector<float>>::__construct_at_end_with_size<std::__wrap_iter<std::vector<float>*>>(&v23, a3, a5);
      size_t v5 = (__n128 *)std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, &v23, v5);
      std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)&v23);
    }
  }
  return v5;
}

void sub_21B4F9858(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

__n128 *std::vector<std::vector<float>>::__move_range(uint64_t a1, __n128 *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (__n128 *)((char *)a2 + v6 - a4);
  uint64_t v8 = (__n128 *)v6;
  if ((unint64_t)v7 < a3)
  {
    uint64_t v9 = v7;
    uint64_t v8 = *(__n128 **)(a1 + 8);
    do
    {
      v8->n128_u64[0] = 0;
      v8->n128_u64[1] = 0;
      v8[1].n128_u64[0] = 0;
      *uint64_t v8 = *v9;
      v8[1].n128_u64[0] = v9[1].n128_u64[0];
      v9->n128_u64[0] = 0;
      v9->n128_u64[1] = 0;
      v9[1].n128_u64[0] = 0;
      uint64_t v8 = (__n128 *)((char *)v8 + 24);
      uint64_t v9 = (__n128 *)((char *)v9 + 24);
    }
    while ((unint64_t)v9 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,std::vector<float> *,std::vector<float> *,std::vector<float> *,0>(a2, v7, v6);
}

void *std::__split_buffer<std::vector<float>>::__construct_at_end_with_size<std::__wrap_iter<std::vector<float>*>>(void *result, uint64_t a2, uint64_t a3)
{
  long long v3 = result;
  unint64_t v4 = (void *)result[2];
  if (a3)
  {
    uint64_t v6 = &v4[3 * a3];
    uint64_t v7 = 24 * a3;
    do
    {
      *unint64_t v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      __n128 result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
      v4 += 3;
      a2 += 24;
      v7 -= 24;
    }
    while (v7);
    unint64_t v4 = v6;
  }
  v3[2] = v4;
  return result;
}

void sub_21B4F995C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::__swap_out_circular_buffer(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>((uint64_t)(a1 + 2), (uint64_t)a3, a3, *a1, (void *)*a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v7, (uint64_t)a3, a1[1], (void *)a2[2]);
  uint64_t v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *unint64_t v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      unint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_21B4F9AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      size_t v5 = *(void **)(v3 - 24);
      v3 -= 24;
      unint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 16) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

__n128 *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,std::vector<float> *,std::vector<float> *,std::vector<float> *,0>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v6 = a2;
    do
    {
      uint64_t v6 = (__n128 *)((char *)v6 - 24);
      a3 -= 24;
      std::vector<float>::__move_assign(a3, v6);
    }
    while (v6 != a1);
  }
  return a2;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if ((char *)v5 != a4) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 2);
      }
      v5 += 24;
      a4 += 24;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v4 = a4;
  char v9 = a4;
  uint64_t v8 = a4;
  v6[0] = a1;
  v6[1] = &v8;
  v6[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      *unint64_t v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      *(_OWORD *)unint64_t v4 = *(_OWORD *)a2;
      v4[2] = *(void *)(a2 + 16);
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      v4 += 3;
      a2 += 24;
    }
    while (a2 != a3);
    char v9 = v4;
  }
  char v7 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v6);
  return v4;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],std::vector<std::vector<std::vector<float>>> &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t **a3)
{
  *((void *)a1 + 1) = applesauce::CF::details::make_CFArrayRef<std::vector<std::vector<float>>>(a3);
  return a1;
}

void sub_21B4F9CEC(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<std::vector<std::vector<float>>>(uint64_t **a1)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  std::vector<applesauce::CF::ArrayRef>::reserve((char **)&v10, v2);
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  if (*a1 != v4)
  {
    do
    {
      memset(v9, 0, sizeof(v9));
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v9, *v3, v3[1], 0xAAAAAAAAAAAAAAABLL * ((v3[1] - *v3) >> 3));
      uint64_t v5 = v11;
      if ((unint64_t)v11 >= v12)
      {
        uint64_t v6 = std::vector<applesauce::CF::ArrayRef>::__emplace_back_slow_path<std::vector<std::vector<float>>>((uint64_t *)&v10, (uint64_t *)v9);
      }
      else
      {
        *uint64_t v5 = applesauce::CF::details::make_CFArrayRef<std::vector<float>>((uint64_t *)v9);
        uint64_t v6 = (uint64_t)(v5 + 1);
      }
      uint64_t v11 = (CFArrayRef *)v6;
      uint64_t v13 = v9;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v13);
      v3 += 3;
    }
    while (v3 != v4);
  }
  CFArrayRef v7 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::ArrayRef>(&v10);
  v9[0] = (void **)&v10;
  std::vector<applesauce::CF::ArrayRef>::__destroy_vector::operator()[abi:ne180100](v9);
  return v7;
}

void sub_21B4F9E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  a10 = (void **)&a13;
  std::vector<applesauce::CF::ArrayRef>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<applesauce::CF::ArrayRef>::reserve(char **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v17 = result;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(result, a2);
    char v9 = *a1;
    uint64_t v8 = a1[1];
    if (v8 == *a1)
    {
      int64x2_t v12 = vdupq_n_s64((unint64_t)v8);
      uint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      uint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
        *(void *)uint64_t v8 = 0;
      }
      while (v8 != v9);
      int64x2_t v12 = *(int64x2_t *)a1;
    }
    *a1 = v10;
    a1[1] = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    int64x2_t v15 = v12;
    uint64_t v13 = a1[2];
    a1[2] = &v6[8 * v7];
    unint64_t v16 = v13;
    uint64_t v14 = v12.i64[0];
    return std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer((uint64_t)&v14);
  }
  return result;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::ArrayRef>(uint64_t **a1)
{
  std::vector<void const*>::vector(__p, a1[1] - *a1);
  unint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    unint64_t v4 = __p[0];
    do
    {
      uint64_t v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_21B4F9F80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__destroy_at[abi:ne180100]<applesauce::CF::ArrayRef,0>(const void **a1)
{
  uint64_t v1 = *a1;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::ArrayRef,0>((const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_21B4FA078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<applesauce::CF::ArrayRef>::__emplace_back_slow_path<std::vector<std::vector<float>>>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = (void *)*a1;
  uint64_t v4 = (a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - (void)v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v19 = v10;
  v20.i64[0] = (uint64_t)&v10[8 * v4];
  v20.i64[1] = v20.i64[0];
  uint64_t v21 = &v10[8 * v9];
  *(void *)v20.i64[0] = applesauce::CF::details::make_CFArrayRef<std::vector<float>>(a2);
  uint64_t v11 = v20.i64[0];
  uint64_t v12 = v20.i64[1] + 8;
  v20.i64[1] += 8;
  uint64_t v14 = (void *)*a1;
  uint64_t v13 = (void *)a1[1];
  if (v13 == (void *)*a1)
  {
    int64x2_t v16 = vdupq_n_s64((unint64_t)v13);
  }
  else
  {
    do
    {
      uint64_t v15 = *--v13;
      *(void *)(v11 - 8) = v15;
      v11 -= 8;
      *uint64_t v13 = 0;
    }
    while (v13 != v14);
    int64x2_t v16 = *(int64x2_t *)a1;
    uint64_t v12 = v20.i64[1];
  }
  *a1 = v11;
  a1[1] = v12;
  int64x2_t v20 = v16;
  uint64_t v17 = (char *)a1[2];
  a1[2] = (uint64_t)v21;
  uint64_t v21 = v17;
  uint64_t v19 = (char *)v16.i64[0];
  std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer((uint64_t)&v19);
  return v12;
}

void sub_21B4FA1A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<std::vector<float>>(uint64_t *a1)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  std::vector<applesauce::CF::ArrayRef>::reserve((char **)&v12, v2);
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  while (v3 != v4)
  {
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)v3, *(void *)(v3 + 8), (uint64_t)(*(void *)(v3 + 8) - *(void *)v3) >> 2);
    unint64_t v5 = v13;
    if ((unint64_t)v13 >= v14)
    {
      uint64_t v6 = std::vector<applesauce::CF::ArrayRef>::__emplace_back_slow_path<std::vector<float>>((uint64_t *)&v12, &__p);
    }
    else
    {
      *unint64_t v5 = applesauce::CF::details::make_CFArrayRef<float>(&__p);
      uint64_t v6 = (uint64_t)(v5 + 1);
    }
    uint64_t v13 = (CFArrayRef *)v6;
    if (__p)
    {
      uint64_t v10 = __p;
      operator delete(__p);
    }
    v3 += 24;
  }
  CFArrayRef v7 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::ArrayRef>(&v12);
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = &v12;
  std::vector<applesauce::CF::ArrayRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  return v7;
}

void sub_21B4FA2A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13)
{
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = &a12;
  std::vector<applesauce::CF::ArrayRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t std::vector<applesauce::CF::ArrayRef>::__emplace_back_slow_path<std::vector<float>>(uint64_t *a1, void *a2)
{
  uint64_t v3 = (void *)*a1;
  uint64_t v4 = (a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - (void)v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v19 = v10;
  v20.i64[0] = (uint64_t)&v10[8 * v4];
  v20.i64[1] = v20.i64[0];
  uint64_t v21 = &v10[8 * v9];
  *(void *)v20.i64[0] = applesauce::CF::details::make_CFArrayRef<float>(a2);
  uint64_t v11 = v20.i64[0];
  uint64_t v12 = v20.i64[1] + 8;
  v20.i64[1] += 8;
  unint64_t v14 = (void *)*a1;
  uint64_t v13 = (void *)a1[1];
  if (v13 == (void *)*a1)
  {
    int64x2_t v16 = vdupq_n_s64((unint64_t)v13);
  }
  else
  {
    do
    {
      uint64_t v15 = *--v13;
      *(void *)(v11 - 8) = v15;
      v11 -= 8;
      *uint64_t v13 = 0;
    }
    while (v13 != v14);
    int64x2_t v16 = *(int64x2_t *)a1;
    uint64_t v12 = v20.i64[1];
  }
  *a1 = v11;
  a1[1] = v12;
  int64x2_t v20 = v16;
  uint64_t v17 = (char *)a1[2];
  a1[2] = (uint64_t)v21;
  uint64_t v21 = v17;
  uint64_t v19 = (char *)v16.i64[0];
  std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer((uint64_t)&v19);
  return v12;
}

void sub_21B4FA3FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<applesauce::CF::ArrayRef>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<float>(void *a1)
{
  unint64_t v2 = (uint64_t)(a1[1] - *a1) >> 2;
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  std::vector<applesauce::CF::NumberRef>::reserve((char **)&v8, v2);
  uint64_t v3 = (_DWORD *)*a1;
  uint64_t v4 = (_DWORD *)a1[1];
  if ((_DWORD *)*a1 != v4)
  {
    unint64_t v5 = v9;
    do
    {
      LODWORD(v11) = *v3;
      if ((unint64_t)v5 >= v10) {
        unint64_t v5 = (CFNumberRef *)std::vector<applesauce::CF::NumberRef>::__emplace_back_slow_path<float>((uint64_t *)&v8, (int *)&v11);
      }
      else {
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,float,applesauce::CF::NumberRef*>(v5++, (int *)&v11);
      }
      unint64_t v9 = v5;
      ++v3;
    }
    while (v3 != v4);
  }
  CFArrayRef v6 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>(&v8);
  uint64_t v11 = (void **)&v8;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&v11);
  return v6;
}

void sub_21B4FA4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t std::vector<applesauce::CF::NumberRef>::reserve(char **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v17 = result;
    CFArrayRef v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(result, a2);
    unint64_t v9 = *a1;
    uint64_t v8 = a1[1];
    if (v8 == *a1)
    {
      int64x2_t v12 = vdupq_n_s64((unint64_t)v8);
      unint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      unint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
        *(void *)uint64_t v8 = 0;
      }
      while (v8 != v9);
      int64x2_t v12 = *(int64x2_t *)a1;
    }
    *a1 = v10;
    a1[1] = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    int64x2_t v15 = v12;
    uint64_t v13 = a1[2];
    a1[2] = &v6[8 * v7];
    int64x2_t v16 = v13;
    uint64_t v14 = v12.i64[0];
    return std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v14);
  }
  return result;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>(uint64_t **a1)
{
  std::vector<void const*>::vector(__p, a1[1] - *a1);
  unint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    uint64_t v4 = __p[0];
    do
    {
      uint64_t v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_21B4FA638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__destroy_at[abi:ne180100]<applesauce::CF::NumberRef,0>(const void **a1)
{
  uint64_t v1 = *a1;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::NumberRef,0>((const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<applesauce::CF::NumberRef>::__emplace_back_slow_path<float>(uint64_t *a1, int *a2)
{
  uint64_t v3 = (void *)*a1;
  uint64_t v4 = (a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - (void)v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v19 = v10;
  v20.i64[0] = (uint64_t)&v10[8 * v4];
  uint64_t v21 = &v10[8 * v9];
  std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,float,applesauce::CF::NumberRef*>((CFNumberRef *)v20.i64[0], a2);
  uint64_t v11 = v20.i64[0];
  uint64_t v12 = v20.i64[0] + 8;
  v20.i64[1] = v20.i64[0] + 8;
  uint64_t v14 = (void *)*a1;
  uint64_t v13 = (void *)a1[1];
  if (v13 == (void *)*a1)
  {
    int64x2_t v16 = vdupq_n_s64((unint64_t)v13);
  }
  else
  {
    do
    {
      uint64_t v15 = *--v13;
      *(void *)(v11 - 8) = v15;
      v11 -= 8;
      *uint64_t v13 = 0;
    }
    while (v13 != v14);
    int64x2_t v16 = *(int64x2_t *)a1;
    uint64_t v12 = v20.i64[1];
  }
  *a1 = v11;
  a1[1] = v12;
  int64x2_t v20 = v16;
  uint64_t v17 = (char *)a1[2];
  a1[2] = (uint64_t)v21;
  uint64_t v21 = v17;
  uint64_t v19 = (char *)v16.i64[0];
  std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v19);
  return v12;
}

void sub_21B4FA7D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

CFNumberRef *std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,float,applesauce::CF::NumberRef*>(CFNumberRef *a1, int *a2)
{
  int valuePtr = *a2;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FA87C(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::NumberRef,0>(--v4);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<applesauce::CF::ArrayRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::ArrayRef,0>(--v4);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],std::vector<std::vector<float>> &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  *((void *)a1 + 1) = applesauce::CF::details::make_CFArrayRef<std::vector<float>>(a3);
  return a1;
}

void sub_21B4FA9E8(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[7],std::vector<std::vector<float>> &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  *((void *)a1 + 1) = applesauce::CF::details::make_CFArrayRef<std::vector<float>>(a3);
  return a1;
}

void sub_21B4FAA34(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FAAE0(_Unwind_Exception *a1)
{
  CFNumberRef v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],applesauce::CF::StringRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],applesauce::CF::DictionaryRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[21],std::vector<unsigned int> &>(applesauce::CF::TypeRef *a1, char *a2, void *a3)
{
  *((void *)a1 + 1) = applesauce::CF::details::make_CFArrayRef<unsigned int>(a3);
  return a1;
}

void sub_21B4FABDC(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<unsigned int>(void *a1)
{
  unint64_t v2 = (uint64_t)(a1[1] - *a1) >> 2;
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  std::vector<applesauce::CF::NumberRef>::reserve((char **)&v8, v2);
  CFNumberRef v3 = (_DWORD *)*a1;
  uint64_t v4 = (_DWORD *)a1[1];
  if ((_DWORD *)*a1 != v4)
  {
    CFNumberRef v5 = v9;
    do
    {
      LODWORD(v11) = *v3;
      if ((unint64_t)v5 >= v10) {
        CFNumberRef v5 = (CFNumberRef *)std::vector<applesauce::CF::NumberRef>::__emplace_back_slow_path<unsigned int>((uint64_t *)&v8, (int *)&v11);
      }
      else {
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int,applesauce::CF::NumberRef*>(v5++, (int *)&v11);
      }
      unint64_t v9 = v5;
      ++v3;
    }
    while (v3 != v4);
  }
  CFArrayRef v6 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>(&v8);
  uint64_t v11 = (void **)&v8;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&v11);
  return v6;
}

void sub_21B4FACB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t std::vector<applesauce::CF::NumberRef>::__emplace_back_slow_path<unsigned int>(uint64_t *a1, int *a2)
{
  CFNumberRef v3 = (void *)*a1;
  uint64_t v4 = (a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - (void)v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v19 = v10;
  v20.i64[0] = (uint64_t)&v10[8 * v4];
  uint64_t v21 = &v10[8 * v9];
  std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int,applesauce::CF::NumberRef*>((CFNumberRef *)v20.i64[0], a2);
  uint64_t v11 = v20.i64[0];
  uint64_t v12 = v20.i64[0] + 8;
  v20.i64[1] = v20.i64[0] + 8;
  uint64_t v14 = (void *)*a1;
  uint64_t v13 = (void *)a1[1];
  if (v13 == (void *)*a1)
  {
    int64x2_t v16 = vdupq_n_s64((unint64_t)v13);
  }
  else
  {
    do
    {
      uint64_t v15 = *--v13;
      *(void *)(v11 - 8) = v15;
      v11 -= 8;
      *uint64_t v13 = 0;
    }
    while (v13 != v14);
    int64x2_t v16 = *(int64x2_t *)a1;
    uint64_t v12 = v20.i64[1];
  }
  *a1 = v11;
  a1[1] = v12;
  int64x2_t v20 = v16;
  uint64_t v17 = (char *)a1[2];
  a1[2] = (uint64_t)v21;
  uint64_t v21 = v17;
  uint64_t v19 = (char *)v16.i64[0];
  std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v19);
  return v12;
}

void sub_21B4FADF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

CFNumberRef *std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned int,applesauce::CF::NumberRef*>(CFNumberRef *a1, int *a2)
{
  int valuePtr = *a2;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FAE94(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],std::vector<unsigned int> &>(applesauce::CF::TypeRef *a1, char *a2, void *a3)
{
  *((void *)a1 + 1) = applesauce::CF::details::make_CFArrayRef<unsigned int>(a3);
  return a1;
}

void sub_21B4FAEF8(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[19],std::vector<float> &>(applesauce::CF::TypeRef *a1, char *a2, void *a3)
{
  *((void *)a1 + 1) = applesauce::CF::details::make_CFArrayRef<float>(a3);
  return a1;
}

void sub_21B4FAF44(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[29],std::vector<float> const&>(applesauce::CF::TypeRef *a1, char *a2, void *a3)
{
  *((void *)a1 + 1) = applesauce::CF::details::make_CFArrayRef<float>(a3);
  return a1;
}

void sub_21B4FAF90(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],applesauce::CF::DictionaryRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  unint64_t v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

void std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)unint64_t v2 = &unk_26CB57620;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB57620;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t result, uint64_t a2, unsigned int *a3)
{
  *(_DWORD *)(**(void **)(result + 8) + 4 * *a3) = *(_DWORD *)a2;
  if (*(void *)(a2 + 16) != *(void *)(a2 + 8))
  {
    uint64_t v4 = result;
    unint64_t v5 = **(unsigned int **)(result + 16);
    if (v5)
    {
      for (unint64_t i = 0; i < v5; ++i)
      {
        uint64_t v7 = **(unsigned int **)(v4 + 24);
        if (v7)
        {
          memmove((void *)(**(void **)(v4 + 32) + 4 * (v7 * i)), **(const void ***)(*(void *)(a2 + 8) + 8 * i), 4 * v7);
          unint64_t v5 = **(unsigned int **)(v4 + 16);
        }
      }
    }
    uint64_t v8 = *(void *)(v4 + 32);
    unint64_t v9 = *(uint64_t **)(v4 + 40);
    unint64_t v10 = v9[1];
    if (v10 >= v9[2])
    {
      uint64_t v11 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v9, v8);
    }
    else
    {
      std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v9, v8);
      uint64_t v11 = v10 + 24;
    }
    v9[1] = v11;
    uint64_t v12 = *(uint64_t **)(v4 + 48);
    uint64_t v13 = a2 + 48;
    unint64_t v14 = v12[1];
    if (v14 >= v12[2])
    {
      uint64_t v15 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v12, v13);
    }
    else
    {
      std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v12, v13);
      uint64_t v15 = v14 + 24;
    }
    v12[1] = v15;
    int64x2_t v16 = *(uint64_t **)(v4 + 56);
    uint64_t v17 = *(void *)(v4 + 8);
    unint64_t v18 = v16[1];
    if (v18 >= v16[2])
    {
      __n128 result = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v16, v17);
    }
    else
    {
      std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v16, v17);
      __n128 result = v18 + 24;
    }
    v16[1] = result;
  }
  return result;
}

void *std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x48uLL);
  *(void *)unint64_t v2 = &unk_26CB57668;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

__n128 std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB57668;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1,std::allocator<IR::IRData::Implementation::createSerializedIRData(IR::IRData const&,BOOL,IR::IRCoeffFormat)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v5 = *a3;
  uint64_t v6 = *(void *)(**(void **)(a1 + 8) + 104);
  if (v5 < (*(void *)(**(void **)(a1 + 8) + 112) - v6) >> 2) {
    *(_DWORD *)(**(void **)(a1 + 16) + 4 * *(int *)(v6 + 4 * v5)) = *(_DWORD *)a2;
  }
  uint64_t v7 = *(void **)(a2 + 32);
  if (v7)
  {
    uint64_t v8 = v7[5];
    if (v7[6] != v8)
    {
      uint64_t v9 = 0;
      unsigned int v10 = 0;
      do
      {
        int v11 = *(_DWORD *)(v7[8] + 4 * v9);
        uint64_t v12 = *(uint64_t **)(a1 + 16);
        uint64_t v13 = **(void **)(a1 + 8);
        uint64_t v14 = *v12;
        *(_DWORD *)(*v12 + 4 * *(unsigned int *)(v13 + 496)) = v11;
        *(_DWORD *)(v14 + 4 * *(unsigned int *)(v13 + 492)) = *(_DWORD *)(v8 + 4 * v9);
        uint64_t v15 = *(uint64_t **)(a1 + 24);
        unint64_t v16 = v15[1];
        if (v16 >= v15[2])
        {
          uint64_t v17 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v15, (uint64_t)v12);
        }
        else
        {
          std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v15, (uint64_t)v12);
          uint64_t v17 = v16 + 24;
        }
        v15[1] = v17;
        unint64_t v18 = **(unsigned int **)(a1 + 32);
        if (v18)
        {
          for (unint64_t i = 0; i < v18; ++i)
          {
            uint64_t v20 = **(unsigned int **)(a1 + 40);
            if (v20)
            {
              memmove((void *)(**(void **)(a1 + 48) + 4 * (v20 * i)), **(const void ***)(*(void *)(*(void *)(*(void *)(a2 + 32) + 88) + 24 * v9) + 8 * i), 4 * v20);
              unint64_t v18 = **(unsigned int **)(a1 + 32);
            }
          }
        }
        uint64_t v21 = *(void *)(a1 + 48);
        uint64_t v22 = *(uint64_t **)(a1 + 56);
        unint64_t v23 = v22[1];
        if (v23 >= v22[2])
        {
          uint64_t v24 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v22, v21);
        }
        else
        {
          std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v22, v21);
          uint64_t v24 = v23 + 24;
        }
        v22[1] = v24;
        uint64_t v7 = *(void **)(a2 + 32);
        uint64_t v8 = v7[5];
        uint64_t v9 = ++v10;
      }
      while (v10 < (unint64_t)((v7[6] - v8) >> 2));
    }
    std::vector<std::vector<float>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::vector<float>*>,std::__wrap_iter<std::vector<float>*>>(*(uint64_t **)(a1 + 64), *(__n128 **)(*(void *)(a1 + 64) + 8), v7[14], v7[15], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7[15] - v7[14]) >> 3));
    uint64_t v25 = **(void **)(a2 + 32);
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)(v25 + 80), *(void *)(v25 + 88), (uint64_t)(*(void *)(v25 + 88) - *(void *)(v25 + 80)) >> 2);
    int64x2_t v26 = __p;
    uint64_t v27 = (((v51 - (unsigned char *)__p) >> 2) / 3uLL);
    if ((((v51 - (unsigned char *)__p) >> 2) / 3uLL))
    {
      uint64_t v28 = *(void **)(a2 + 32);
      uint64_t v29 = (uint64_t)(v28[6] - v28[5]) >> 2;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28[12] - v28[11]) >> 3) >= v29
                                                                       + (((v51 - (unsigned char *)__p) >> 2)
                                                                                      / 3uLL))
      {
        uint64_t v30 = 0;
        do
        {
          float v31 = *((float *)__p + (3 * v30));
          float v32 = *((float *)__p + (3 * v30 + 1));
          float v33 = *((float *)__p + (3 * v30 + 2));
          float v34 = atan2f(v32, v31) * 57.296;
          float v35 = hypotf(v31, v32);
          float v36 = atan2f(-v33, v35);
          uint64_t v37 = *(uint64_t **)(a1 + 16);
          uint64_t v38 = **(void **)(a1 + 8);
          uint64_t v39 = *v37;
          *(float *)(*v37 + 4 * *(unsigned int *)(v38 + 496)) = v36 * -57.296;
          *(float *)(v39 + 4 * *(unsigned int *)(v38 + 492)) = v34;
          uint64_t v40 = *(void *)(a1 + 24);
          unint64_t v41 = *(void *)(v40 + 8);
          if (v41 >= *(void *)(v40 + 16))
          {
            uint64_t v42 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(*(uint64_t **)(a1 + 24), (uint64_t)v37);
          }
          else
          {
            std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>(*(void *)(a1 + 24), (uint64_t)v37);
            uint64_t v42 = v41 + 24;
          }
          *(void *)(v40 + 8) = v42;
          unint64_t v43 = **(unsigned int **)(a1 + 32);
          if (v43)
          {
            for (unint64_t j = 0; j < v43; ++j)
            {
              uint64_t v45 = **(unsigned int **)(a1 + 40);
              if (v45)
              {
                memmove((void *)(**(void **)(a1 + 48) + 4 * (v45 * j)), **(const void ***)(*(void *)(*(void *)(*(void *)(a2 + 32) + 88)+ 24 * (v30 + v29))+ 8 * j), 4 * v45);
                unint64_t v43 = **(unsigned int **)(a1 + 32);
              }
            }
          }
          uint64_t v46 = *(void *)(a1 + 48);
          uint64_t v47 = *(void *)(a1 + 56);
          unint64_t v48 = *(void *)(v47 + 8);
          if (v48 >= *(void *)(v47 + 16))
          {
            uint64_t v49 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(*(uint64_t **)(a1 + 56), v46);
          }
          else
          {
            std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>(*(void *)(a1 + 56), v46);
            uint64_t v49 = v48 + 24;
          }
          *(void *)(v47 + 8) = v49;
          ++v30;
        }
        while (v30 != v27);
        int64x2_t v26 = __p;
      }
    }
    if (v26)
    {
      uint64_t v51 = v26;
      operator delete(v26);
    }
  }
}

void sub_21B4FB69C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[5],std::string>(applesauce::CF::TypeRef *a1, char *a2, uint64_t a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int v5 = *(char *)(a3 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (const UInt8 *)a3;
  }
  else {
    uint64_t v6 = *(const UInt8 **)a3;
  }
  if (v5 >= 0) {
    CFIndex v7 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    CFIndex v7 = *(void *)(a3 + 8);
  }
  CFStringRef v8 = CFStringCreateWithBytes(0, v6, v7, 0x8000100u, 0);
  *((void *)a1 + 1) = v8;
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FB75C(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FB830(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[14],int>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FB904(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FB9D8(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],std::string>(applesauce::CF::TypeRef *a1, char *a2, uint64_t a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int v5 = *(char *)(a3 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (const UInt8 *)a3;
  }
  else {
    uint64_t v6 = *(const UInt8 **)a3;
  }
  if (v5 >= 0) {
    CFIndex v7 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    CFIndex v7 = *(void *)(a3 + 8);
  }
  CFStringRef v8 = CFStringCreateWithBytes(0, v6, v7, 0x8000100u, 0);
  *((void *)a1 + 1) = v8;
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FBAB8(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],unsigned int &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FBB8C(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],char const(&)[8]>(applesauce::CF::TypeRef *a1, char *a2, char *a3)
{
  CFNumberRef v5 = applesauce::CF::TypeRef::TypeRef(a1, a2);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)((char *)v5 + 8), a3);
  return a1;
}

void sub_21B4FBC00(_Unwind_Exception *a1)
{
  applesauce::CF::TypeRef::~TypeRef(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[20],unsigned long &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  uint64_t valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FBCAC(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],applesauce::CF::ArrayRef &>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FBDC4(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],unsigned int &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B4FBE98(_Unwind_Exception *a1)
{
  long long v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

uint64_t std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(int a1, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this, _DWORD *a3)
{
  uint64_t result = a3[1];
  int v4 = result - *a3;
  if (result != *a3)
  {
    unsigned int v6 = v4 + 1;
    if (v4 == -1)
    {
      return std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this);
    }
    else
    {
      uint64_t v8 = __clz(v6);
      uint64_t v9 = 31;
      if (((v6 << v8) & 0x7FFFFFFF) != 0) {
        uint64_t v9 = 32;
      }
      unint64_t v10 = v9 - v8;
      unint64_t v11 = v10 >> 5;
      if ((v10 & 0x1F) != 0) {
        ++v11;
      }
      if (v11 <= v10) {
        unsigned int v12 = 0xFFFFFFFF >> -(v10 / v11);
      }
      else {
        unsigned int v12 = 0;
      }
      do
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v13 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this) & v12;
      while (v13 >= v6);
      return *a3 + v13;
    }
  }
  return result;
}

void *_ZNSt3__115allocate_sharedB8ne180100IN2IR23VBAPTriangulationKernelENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  unint64_t v2 = operator new(0xD0uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceIN2IR23VBAPTriangulationKernelENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_21B4FBFD0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *_ZNSt3__120__shared_ptr_emplaceIN2IR23VBAPTriangulationKernelENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB57430;
  IR::VBAPTriangulationKernel::VBAPTriangulationKernel((IR::VBAPTriangulationKernel *)(a1 + 3));
  return a1;
}

void sub_21B4FC02C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<IR::VBAPTriangulationKernel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB57430;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IR::VBAPTriangulationKernel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB57430;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

void std::__shared_ptr_emplace<IR::VBAPTriangulationKernel>::__on_zero_shared(uint64_t a1)
{
}

IR::VBAPTriangulationKernel *IR::VBAPTriangulationKernel::VBAPTriangulationKernel(IR::VBAPTriangulationKernel *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 16) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((void *)this + 17) = 0xFFFFFFFFLL;
  IR::IRCoordinates::IRCoordinates((IR::VBAPTriangulationKernel *)((char *)this + 144));
  return this;
}

void sub_21B4FC12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 + 112);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a10);
  a10 = (void **)(v10 + 88);
  std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::__destroy_vector::operator()[abi:ne180100](&a10);
  uint64_t v14 = *(void **)(v10 + 64);
  if (v14)
  {
    *(void *)(v10 + 72) = v14;
    operator delete(v14);
  }
  IR::VBAPTriangulationKernel::VBAPTriangulationKernel(v12, v11, (void *)v10);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    int v4 = (void **)v1[1];
    CFNumberRef v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        unsigned int v6 = v4;
        std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      CFNumberRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<IR::VBAPTriangulationKernel,0>(uint64_t a1)
{
  unsigned int v6 = (void **)(a1 + 112);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
  unsigned int v6 = (void **)(a1 + 88);
  std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::__destroy_vector::operator()[abi:ne180100](&v6);
  unint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  long long v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(void *)(a1 + 48) = v3;
    operator delete(v3);
  }
  int v4 = *(void **)(a1 + 16);
  if (v4)
  {
    *(void *)(a1 + 24) = v4;
    operator delete(v4);
  }
  CFNumberRef v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_26CB576B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB576B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t *a1, uint64_t a2, unsigned int *a3)
{
  IR::IRCoordinates::set(a1[1], *(_DWORD *)(*(void *)(a1[2] + 80) + 4 * *a3), *(float *)a2);
  if (*(void *)(a2 + 16) != *(void *)(a2 + 8))
  {
    CFNumberRef v5 = (void **)a1[3];
    uint64_t v6 = a1[1];
    CFIndex v7 = (char *)v5[1];
    uint64_t v8 = (char *)v5[2];
    if (v7 >= v8)
    {
      unint64_t v12 = 0x8E38E38E38E38E39 * ((v7 - (unsigned char *)*v5) >> 2);
      unint64_t v13 = v12 + 1;
      if (v12 + 1 > 0x71C71C71C71C71CLL) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v14 = 0x8E38E38E38E38E39 * ((v8 - (unsigned char *)*v5) >> 2);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0x38E38E38E38E38ELL) {
        unint64_t v15 = 0x71C71C71C71C71CLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15) {
        unint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinates>>((uint64_t)(v5 + 2), v15);
      }
      else {
        unint64_t v16 = 0;
      }
      uint64_t v17 = &v16[36 * v12];
      unint64_t v18 = &v16[36 * v15];
      long long v19 = *(_OWORD *)v6;
      long long v20 = *(_OWORD *)(v6 + 16);
      *((_DWORD *)v17 + 8) = *(_DWORD *)(v6 + 32);
      *(_OWORD *)uint64_t v17 = v19;
      *((_OWORD *)v17 + 1) = v20;
      unint64_t v11 = v17 + 36;
      uint64_t v22 = (char *)*v5;
      uint64_t v21 = (char *)v5[1];
      if (v21 != *v5)
      {
        do
        {
          long long v23 = *(_OWORD *)(v21 - 36);
          long long v24 = *(_OWORD *)(v21 - 20);
          *((_DWORD *)v17 - 1) = *((_DWORD *)v21 - 1);
          *(_OWORD *)(v17 - 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v24;
          *(_OWORD *)(v17 - 36) = v23;
          v17 -= 36;
          v21 -= 36;
        }
        while (v21 != v22);
        uint64_t v21 = (char *)*v5;
      }
      *CFNumberRef v5 = v17;
      v5[1] = v11;
      v5[2] = v18;
      if (v21) {
        operator delete(v21);
      }
    }
    else
    {
      long long v9 = *(_OWORD *)v6;
      long long v10 = *(_OWORD *)(v6 + 16);
      *((_DWORD *)v7 + 8) = *(_DWORD *)(v6 + 32);
      *(_OWORD *)CFIndex v7 = v9;
      *((_OWORD *)v7 + 1) = v10;
      unint64_t v11 = v7 + 36;
    }
    v5[1] = v11;
  }
}

void std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_26CB576F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB576F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1,std::allocator<IR::IRData::Implementation::createSizeDimension(std::vector<float> const&,applesauce::CF::ArrayRef,BOOL)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::operator()(void *a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v5 = *a3;
  uint64_t v6 = a1[1];
  uint64_t v7 = *(void *)(v6 + 104);
  if (v5 < (*(void *)(v6 + 112) - v7) >> 2) {
    IR::IRCoordinates::set(a1[2], *(_DWORD *)(*(void *)(v6 + 80) + 4 * *(int *)(v7 + 4 * v5)), *(float *)a2);
  }
  uint64_t v8 = *(void **)(a2 + 32);
  if (v8 && v8[6] != v8[5])
  {
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    do
    {
      IR::IRCoordinates::set(a1[2], *(_DWORD *)(*(void *)(v6 + 80) + 4 * *(unsigned int *)(v6 + 496)), *(float *)(v8[8] + 4 * v9));
      IR::IRCoordinates::set(a1[2], *(_DWORD *)(*(void *)(v6 + 80) + 4 * *(unsigned int *)(v6 + 492)), *(float *)(*(void *)(*(void *)(a2 + 32) + 40) + 4 * v9));
      unint64_t v12 = (long long *)a1[2];
      unint64_t v11 = (void **)a1[3];
      unint64_t v13 = (char *)v11[1];
      unint64_t v14 = (char *)v11[2];
      if (v13 >= v14)
      {
        unint64_t v18 = 0x8E38E38E38E38E39 * ((v13 - (unsigned char *)*v11) >> 2);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0x71C71C71C71C71CLL) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v20 = 0x8E38E38E38E38E39 * ((v14 - (unsigned char *)*v11) >> 2);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0x38E38E38E38E38ELL) {
          unint64_t v21 = 0x71C71C71C71C71CLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21) {
          uint64_t v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinates>>((uint64_t)(v11 + 2), v21);
        }
        else {
          uint64_t v22 = 0;
        }
        long long v23 = &v22[36 * v18];
        long long v24 = *v12;
        long long v25 = v12[1];
        *((_DWORD *)v23 + 8) = *((_DWORD *)v12 + 8);
        *(_OWORD *)long long v23 = v24;
        *((_OWORD *)v23 + 1) = v25;
        uint64_t v27 = (char *)*v11;
        int64x2_t v26 = (char *)v11[1];
        uint64_t v28 = v23;
        if (v26 != *v11)
        {
          do
          {
            long long v29 = *(_OWORD *)(v26 - 36);
            long long v30 = *(_OWORD *)(v26 - 20);
            *((_DWORD *)v28 - 1) = *((_DWORD *)v26 - 1);
            *(_OWORD *)(v28 - 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v30;
            *(_OWORD *)(v28 - 36) = v29;
            v28 -= 36;
            v26 -= 36;
          }
          while (v26 != v27);
          int64x2_t v26 = (char *)*v11;
        }
        uint64_t v17 = v23 + 36;
        *unint64_t v11 = v28;
        v11[1] = v23 + 36;
        v11[2] = &v22[36 * v21];
        if (v26) {
          operator delete(v26);
        }
      }
      else
      {
        long long v15 = *v12;
        long long v16 = v12[1];
        *((_DWORD *)v13 + 8) = *((_DWORD *)v12 + 8);
        *(_OWORD *)unint64_t v13 = v15;
        *((_OWORD *)v13 + 1) = v16;
        uint64_t v17 = v13 + 36;
      }
      v11[1] = v17;
      uint64_t v8 = *(void **)(a2 + 32);
      uint64_t v9 = ++v10;
    }
    while (v10 < (unint64_t)((uint64_t)(v8[6] - v8[5]) >> 2));
  }
}

unint64_t applesauce::CF::details::at_as<unsigned int>(const __CFArray *a1, unint64_t a2)
{
  if (a1 && CFArrayGetCount(a1) > a2 && (CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, a2)) != 0)
  {
    uint64_t v5 = applesauce::CF::convert_as<unsigned int,0>(ValueAtIndex);
    unint64_t v6 = v5 & 0xFFFFFF0000000000;
    uint64_t v7 = v5 & 0xFF00000000;
    uint64_t v8 = v5 & 0xFFFFFF00;
    uint64_t v9 = v5;
  }
  else
  {
    uint64_t v8 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v9 = 0;
  }
  return v6 | v8 | v7 | v9;
}

unint64_t applesauce::CF::details::at_as<float>(const __CFArray *a1, unint64_t a2)
{
  if (a1 && CFArrayGetCount(a1) > a2 && (CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, a2)) != 0)
  {
    uint64_t v5 = applesauce::CF::convert_as<float,0>(ValueAtIndex);
    unint64_t v6 = v5 & 0xFFFFFF0000000000;
    uint64_t v7 = v5 & 0xFF00000000;
    uint64_t v8 = v5 & 0xFFFFFF00;
    uint64_t v9 = v5;
  }
  else
  {
    uint64_t v8 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v9 = 0;
  }
  return v6 | v8 | v7 | v9;
}

void std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

void *std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26CB57740;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26CB57740;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = *(void *)(a2 + 72);
  uint64_t v4 = *(void *)(a2 + 80);
  if (v3 != v4)
  {
    unint64_t v5 = *a3;
    unint64_t v6 = *(void **)(result + 8);
    uint64_t v7 = v6[13];
    if (((v6[14] - v7) >> 2) - 1 > v5)
    {
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v3) >> 5);
      uint64_t v9 = *(int *)(v7 + 4 * (v5 + 1));
      uint64_t v10 = v6[22];
      if (v8 > *(unsigned int *)(v10 + 4 * v9)) {
        *(_DWORD *)(v10 + 4 * v9) = v8;
      }
    }
  }
  return result;
}

void std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

void *std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26CB57788;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26CB57788;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1,std::allocator<IR::IRData::Implementation::findDimensionsWithMoreThanOneNode(void)::$_1>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = *(void *)(a2 + 72);
  uint64_t v4 = *(void *)(a2 + 80);
  if (v3 != v4)
  {
    unint64_t v5 = *a3;
    uint64_t v6 = *(void *)(*(void *)(result + 8) + 176);
    if (((*(void *)(*(void *)(result + 8) + 184) - v6) >> 2) - 1 > v5)
    {
      unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v3) >> 5);
      uint64_t v8 = (v5 + 1);
      if (v7 > *(unsigned int *)(v6 + 4 * v8)) {
        *(_DWORD *)(v6 + 4 * v8) = v7;
      }
    }
  }
  return result;
}

void std::__function::__func<IR::IRData::Implementation::estimateAverageDelay(void)::$_0,std::allocator<IR::IRData::Implementation::estimateAverageDelay(void)::$_0>,void ()(IR::IRDataNode const&,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<IR::IRData::Implementation::estimateAverageDelay(void)::$_0,std::allocator<IR::IRData::Implementation::estimateAverageDelay(void)::$_0>,void ()(IR::IRDataNode const&,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26CB577D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<IR::IRData::Implementation::estimateAverageDelay(void)::$_0,std::allocator<IR::IRData::Implementation::estimateAverageDelay(void)::$_0>,void ()(IR::IRDataNode const&,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB577D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<IR::IRData::Implementation::estimateAverageDelay(void)::$_0,std::allocator<IR::IRData::Implementation::estimateAverageDelay(void)::$_0>,void ()(IR::IRDataNode const&,unsigned int)>::operator()(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(float **)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 56) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    uint64_t v6 = *(float **)(result + 8);
    unint64_t v5 = *(int **)(result + 16);
    float v7 = *v6;
    int v8 = *v5;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    unint64_t v9 = v4;
    do
    {
      float v10 = *v2++;
      float v7 = v7 + v10;
      *uint64_t v6 = v7;
      --v9;
    }
    while (v9);
    *unint64_t v5 = v8 + v4;
  }
  return result;
}

void *std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<IR::IRData::Implementation::computeAverageIR(void)::$_0,std::allocator<IR::IRData::Implementation::computeAverageIR(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<IR::IRData::Implementation::computeAverageIR(void)::$_0,std::allocator<IR::IRData::Implementation::computeAverageIR(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26CB57818;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<IR::IRData::Implementation::computeAverageIR(void)::$_0,std::allocator<IR::IRData::Implementation::computeAverageIR(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB57818;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<IR::IRData::Implementation::computeAverageIR(void)::$_0,std::allocator<IR::IRData::Implementation::computeAverageIR(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = (*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3;
  unsigned int v4 = *(_DWORD *)(v2 + 32);
  if (v4 >= v3) {
    uint64_t v3 = v3;
  }
  else {
    uint64_t v3 = v4;
  }
  if (v3)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 40 * v3;
    do
    {
      __n128 result = IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)(v2 + 304) + v8), *(const IR::FFTFilterKernel **)(*(void *)(a2 + 8) + v7), **(float **)(v6 + 16));
      v8 += 40;
      v7 += 8;
    }
    while (v9 != v8);
  }
  return result;
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::BooleanRef,std::string const&>(const __CFDictionary *a1@<X0>, const UInt8 *a2@<X1>, unsigned char *a3@<X8>)
{
  unsigned int v4 = applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  unint64_t v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFBooleanGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::NumberRef,std::string const&>(const __CFDictionary *a1@<X0>, const UInt8 *a2@<X1>, unsigned char *a3@<X8>)
{
  unsigned int v4 = applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  unint64_t v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFNumberGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

uint64_t std::__function::__value_func<void ()(IR::IRDataNode &,unsigned int)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x21D48F780);
}

uint64_t std::__function::__value_func<void ()(IR::IRDataNode const&,unsigned int)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x21D48F500](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      float v10 = std::locale::use_facet(&v14, MEMORY[0x263F8C108]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x21D48F510](v13);
  return a1;
}

void sub_21B4FD08C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x21D48F510](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x21B4FD06CLL);
}

void sub_21B4FD0E0(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      unint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_21B4FD260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<IR::IRData::Implementation::printNodes(void)::$_0,std::allocator<IR::IRData::Implementation::printNodes(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::~__func()
{
}

void *std::__function::__func<IR::IRData::Implementation::printNodes(void)::$_0,std::allocator<IR::IRData::Implementation::printNodes(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26CB57860;
  return result;
}

void std::__function::__func<IR::IRData::Implementation::printNodes(void)::$_0,std::allocator<IR::IRData::Implementation::printNodes(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26CB57860;
}

uint64_t std::__function::__func<IR::IRData::Implementation::printNodes(void)::$_0,std::allocator<IR::IRData::Implementation::printNodes(void)::$_0>,void ()(IR::IRDataNode &,unsigned int)>::operator()(uint64_t a1, uint64_t a2, int *a3)
{
  int v3 = *a3;
  if (*a3)
  {
    unsigned int v4 = (void *)MEMORY[0x263F8C100];
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\t", 1);
      --v3;
    }
    while (v3);
  }
  unint64_t v5 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
  uint64_t v6 = std::locale::use_facet(&v8, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(&v8);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_21B4FD3E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void std::__shared_ptr_emplace<IR::IRData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB57468;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IR::IRData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB57468;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

IR::IRData::Implementation *std::__shared_ptr_emplace<IR::IRData>::__on_zero_shared(uint64_t a1)
{
  return std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100]((IR::IRData::Implementation **)(a1 + 24), 0);
}

void std::allocate_shared[abi:ne180100]<IR::IRData const,std::allocator<IR::IRData const>,float &,int,int,float,BOOL,unsigned int,unsigned int,unsigned int &,std::vector<IR::IRCoordinateType>,std::vector<float>,std::vector<IR::IRInterpolationMethod>,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,void>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  uint64_t v22 = operator new(0x20uLL);
  std::__shared_ptr_emplace<IR::IRData const>::__shared_ptr_emplace[abi:ne180100]<float &,int,int,float,BOOL,unsigned int,unsigned int,unsigned int &,std::vector<IR::IRCoordinateType>,std::vector<float>,std::vector<IR::IRInterpolationMethod>,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,std::allocator<IR::IRData const>,0>(v22, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

void sub_21B4FD544(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<IR::IRData const>::__shared_ptr_emplace[abi:ne180100]<float &,int,int,float,BOOL,unsigned int,unsigned int,unsigned int &,std::vector<IR::IRCoordinateType>,std::vector<float>,std::vector<IR::IRInterpolationMethod>,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,std::allocator<IR::IRData const>,0>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB573F8;
  std::construct_at[abi:ne180100]<IR::IRData const,float &,int,int,float,BOOL,unsigned int,unsigned int,unsigned int &,std::vector<IR::IRCoordinateType>,std::vector<float>,std::vector<IR::IRInterpolationMethod>,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,IR::IRData const*>(a1 + 3, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

void sub_21B4FD5C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<IR::IRData const>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB573F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IR::IRData const>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB573F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

IR::IRData::Implementation *std::__shared_ptr_emplace<IR::IRData const>::__on_zero_shared(uint64_t a1)
{
  return std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100]((IR::IRData::Implementation **)(a1 + 24), 0);
}

void std::construct_at[abi:ne180100]<IR::IRData const,float &,int,int,float,BOOL,unsigned int,unsigned int,unsigned int &,std::vector<IR::IRCoordinateType>,std::vector<float>,std::vector<IR::IRInterpolationMethod>,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,IR::IRData const*>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  *a14 = 0;
  *a15 = 0;
  IR::IRData::IRData(a1);
}

void sub_21B4FD708(_Unwind_Exception *a1)
{
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v1 - 32));
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v1 - 24));
  _Unwind_Resume(a1);
}

IR::IRData::Implementation *IR::IRData::Implementation::Implementation(IR::IRData::Implementation *this, const IR::IRData::Implementation *a2)
{
  long long v4 = *(_OWORD *)a2;
  long long v5 = *((_OWORD *)a2 + 1);
  *((void *)this + 4) = *((void *)a2 + 4);
  *(_OWORD *)this = v4;
  *((_OWORD *)this + 1) = v5;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((void *)this + 5, *((const void **)a2 + 5), *((void *)a2 + 6), (uint64_t)(*((void *)a2 + 6) - *((void *)a2 + 5)) >> 2);
  long long v6 = *((_OWORD *)a2 + 4);
  *((void *)this + 1std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *((_OWORD *)this + 4) = v6;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>((void *)this + 10, *((const void **)a2 + 10), *((void *)a2 + 11), (uint64_t)(*((void *)a2 + 11) - *((void *)a2 + 10)) >> 2);
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)this + 13, *((const void **)a2 + 13), *((void *)a2 + 14), (uint64_t)(*((void *)a2 + 14) - *((void *)a2 + 13)) >> 2);
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)this + 16, *((const void **)a2 + 16), *((void *)a2 + 17), (uint64_t)(*((void *)a2 + 17) - *((void *)a2 + 16)) >> 2);
  *((void *)this + 19) = 0;
  *((void *)this + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *((void *)this + 21) = 0;
  std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>((void *)this + 19, *((const void **)a2 + 19), *((void *)a2 + 20), (uint64_t)(*((void *)a2 + 20) - *((void *)a2 + 19)) >> 2);
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((void *)this + 22, *((const void **)a2 + 22), *((void *)a2 + 23), (uint64_t)(*((void *)a2 + 23) - *((void *)a2 + 22)) >> 2);
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>((void *)this + 25, *((const void **)a2 + 25), *((void *)a2 + 26), (uint64_t)(*((void *)a2 + 26) - *((void *)a2 + 25)) >> 2);
  long long v7 = *((_OWORD *)a2 + 14);
  long long v8 = *((_OWORD *)a2 + 15);
  *((_DWORD *)this + 64) = *((_DWORD *)a2 + 64);
  *((_OWORD *)this + 14) = v7;
  *((_OWORD *)this + 15) = v8;
  uint64_t v9 = *((void *)a2 + 34);
  *((void *)this + 33) = *((void *)a2 + 33);
  *((void *)this + 34) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *((void *)a2 + 35);
  if (v10) {
    CFRetain(*((CFTypeRef *)a2 + 35));
  }
  *((void *)this + 35) = v10;
  uint64_t v11 = *((void *)a2 + 36);
  if (v11) {
    CFRetain(*((CFTypeRef *)a2 + 36));
  }
  *((void *)this + 36) = v11;
  uint64_t v12 = *((void *)a2 + 37);
  if (v12) {
    CFRetain(*((CFTypeRef *)a2 + 37));
  }
  *((void *)this + 37) = v12;
  *((void *)this + 38) = 0;
  *((void *)this + 39) = 0;
  *((void *)this + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  std::vector<IR::FFTFilterKernel>::__init_with_size[abi:ne180100]<IR::FFTFilterKernel*,IR::FFTFilterKernel*>((void *)this + 38, *((void *)a2 + 38), *((void *)a2 + 39), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 39) - *((void *)a2 + 38)) >> 3));
  *((unsigned char *)this + 328) = *((unsigned char *)a2 + 328);
  IR::IRDataAttributes::IRDataAttributes((IR::IRData::Implementation *)((char *)this + 336), (const IR::IRData::Implementation *)((char *)a2 + 336));
  uint64_t v13 = *((void *)a2 + 61);
  *((_DWORD *)this + 124) = *((_DWORD *)a2 + 124);
  *((void *)this + 61) = v13;
  *((void *)this + 65) = 0;
  *((void *)this + 63) = 0;
  *((void *)this + 64) = 0;
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__init_with_size[abi:ne180100]<std::shared_ptr<IR::VBAPTriangulationKernel>*,std::shared_ptr<IR::VBAPTriangulationKernel>*>((void *)this + 63, *((void **)a2 + 63), *((void **)a2 + 64), (uint64_t)(*((void *)a2 + 64) - *((void *)a2 + 63)) >> 4);
  return this;
}

void sub_21B4FD950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, uint64_t a10)
{
  IR::IRDataAttributes::~IRDataAttributes(v11);
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v10 + 296));
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v10 + 288));
  applesauce::CF::StringRef::~StringRef((const void **)(v10 + 280));
  unint64_t v19 = *(std::__shared_weak_count **)(v10 + 272);
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
  unint64_t v20 = *v17;
  if (*v17)
  {
    *(void *)(v10 + 208) = v20;
    operator delete(v20);
  }
  unint64_t v21 = *v16;
  if (*v16)
  {
    *(void *)(v10 + 184) = v21;
    operator delete(v21);
  }
  uint64_t v22 = *v15;
  if (*v15)
  {
    *(void *)(v10 + 16std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v22;
    operator delete(v22);
  }
  long long v23 = *v14;
  if (*v14)
  {
    *(void *)(v10 + 136) = v23;
    operator delete(v23);
  }
  long long v24 = *v13;
  if (*v13)
  {
    *(void *)(v10 + 112) = v24;
    operator delete(v24);
  }
  long long v25 = *v12;
  if (*v12)
  {
    *(void *)(v10 + 88) = v25;
    operator delete(v25);
  }
  int64x2_t v26 = *a9;
  if (*a9)
  {
    *(void *)(v10 + 48) = v26;
    operator delete(v26);
  }
  _Unwind_Resume(a1);
}

void *std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    __n128 result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B4FDAA8(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    __n128 result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B4FDB24(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<IR::FFTFilterKernel>::__init_with_size[abi:ne180100]<IR::FFTFilterKernel*,IR::FFTFilterKernel*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    std::vector<IR::FFTFilterKernel>::__vallocate[abi:ne180100](result, a4);
    __n128 result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<IR::FFTFilterKernel>,IR::FFTFilterKernel*,IR::FFTFilterKernel*,IR::FFTFilterKernel*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_21B4FDBA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<IR::FFTFilterKernel>,IR::FFTFilterKernel*,IR::FFTFilterKernel*,IR::FFTFilterKernel*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      IR::FFTFilterKernel::FFTFilterKernel((IR::FFTFilterKernel *)(a4 + v7), (const IR::FFTFilterKernel *)(a2 + v7));
      v7 += 40;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_21B4FDC28(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 40;
    do
    {
      IR::FFTFilterKernel::~FFTFilterKernel((IR::FFTFilterKernel *)(v4 + v2));
      v2 -= 40;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__init_with_size[abi:ne180100]<std::shared_ptr<IR::VBAPTriangulationKernel>*,std::shared_ptr<IR::VBAPTriangulationKernel>*>(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__vallocate[abi:ne180100](result, a4);
    __n128 result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::shared_ptr<IR::VBAPTriangulationKernel>*,std::shared_ptr<IR::VBAPTriangulationKernel>*,std::shared_ptr<IR::VBAPTriangulationKernel>*>((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_21B4FDCB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DSPSplitComplex>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::shared_ptr<IR::VBAPTriangulationKernel>*,std::shared_ptr<IR::VBAPTriangulationKernel>*,std::shared_ptr<IR::VBAPTriangulationKernel>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v9;
  v7[2] = &v10;
  if (a2 != a3)
  {
    do
    {
      *uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v10 = v4;
  }
  char v8 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::shared_ptr<IR::VBAPTriangulationKernel>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v7);
  return v4;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::shared_ptr<IR::VBAPTriangulationKernel>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::shared_ptr<IR::VBAPTriangulationKernel>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::shared_ptr<IR::VBAPTriangulationKernel>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    int v3 = *(std::__shared_weak_count **)(v1 - 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 -= 16;
  }
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_1(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_2(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void OUTLINED_FUNCTION_8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x18u);
}

void OUTLINED_FUNCTION_9(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x1Cu);
}

void OUTLINED_FUNCTION_10(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x20u);
}

uint64_t IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(unint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, unsigned int a9)
{
  v44[4] = *MEMORY[0x263EF8340];
  int v15 = *(unsigned __int8 *)(a1 + 488);
  if (*(unsigned char *)(a1 + 488))
  {
    if (*(void *)(a1 + 504) == *(void *)(a1 + 512)) {
      IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
    }
  }
  else if (*(void *)(*(void *)(a1 + 264) + 8) == **(void **)(a1 + 264))
  {
    IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  if (a6 != a8) {
    IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  if (a6 < a4) {
    IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  uint64_t result = 1667786857;
  unint64_t v17 = *(unsigned int *)(a1 + 32);
  if (a4 <= v17)
  {
    if (a4)
    {
      uint64_t v18 = 0;
      while (*(_DWORD *)(a3 + 4 * v18) < v17)
      {
        if (++v18 >= a4)
        {
          unsigned int v19 = a4;
          goto LABEL_14;
        }
      }
    }
    else
    {
      unsigned int v19 = 0;
LABEL_14:
      if (a6 >= v19) {
        int v20 = v19;
      }
      else {
        int v20 = a6;
      }
      if (v20)
      {
        if (*(unsigned char *)(a1 + 24) || !*(_DWORD *)(a1 + 16))
        {
          if (a6)
          {
            uint64_t v21 = 0;
            uint64_t v22 = (void *)(a5 + 8);
            do
            {
              long long v23 = (void *)*(v22 - 1);
              uint64_t v24 = *v22 - (void)v23;
              if (v24 >= 1) {
                bzero(v23, 4 * (((unint64_t)v24 >> 2) - ((unint64_t)v24 > 3)) + 4);
              }
              *(_DWORD *)(a7 + 4 * v21++) = 0;
              v22 += 3;
            }
            while (a6 > v21);
          }
          unsigned int v42 = 0;
          if (v15)
          {
            long long v25 = *(_OWORD *)(a2 + 16);
            long long v37 = *(_OWORD *)a2;
            unint64_t v29 = a1;
            unint64_t v30 = a5;
            unint64_t v31 = a6;
            unint64_t v32 = a7;
            unint64_t v33 = a6;
            unint64_t v34 = a3;
            unint64_t v35 = a4;
            unsigned int v36 = a9;
            long long v38 = v25;
            int v39 = *(_DWORD *)(a2 + 32);
            int v40 = v20;
            unint64_t v41 = &v42;
            int64x2_t v26 = *(float ***)(a1 + 264);
            v44[0] = &unk_26CB57938;
            v44[1] = &v29;
            v44[3] = v44;
            IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights((IR::IRData::Implementation *)a1, a2, 0, v26, a9, (uint64_t)v44, 1.0);
            std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v44);
            return v42;
          }
          else
          {
            unint64_t v29 = a5;
            unint64_t v30 = a6;
            unint64_t v31 = a7;
            unint64_t v32 = a6;
            unint64_t v33 = a3;
            unint64_t v34 = a4;
            LODWORD(v35) = v20;
            uint64_t v27 = *(float ***)(a1 + 264);
            v43[0] = &unk_26CB57980;
            v43[1] = &v29;
            v43[3] = v43;
            IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights((IR::IRData::Implementation *)a1, a2, 0, v27, a9, (uint64_t)v43, 1.0);
            std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v43);
            return 0;
          }
        }
        else
        {
          return 1852793702;
        }
      }
      else if (v17)
      {
        return 1701671028;
      }
      else
      {
        return 1852793972;
      }
    }
  }
  return result;
}

void sub_21B4FE208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights(IR::IRData::Implementation *a1, uint64_t a2, unsigned int a3, float **a4, uint64_t a5, uint64_t a6, float a7)
{
  v58[4] = *MEMORY[0x263EF8340];
  uint64_t v7 = *a4;
  if (*a4 == a4[1]) {
    return;
  }
  uint64_t v11 = *((void *)a1 + 13);
  if (v11 == *((void *)a1 + 14))
  {
    EmptyIRDataNode = IR::IRData::Implementation::getEmptyIRDataNode(a1);
    float v31 = 0.0;
    uint64_t v32 = a6;
    unint64_t v33 = (int *)v7;
    float v34 = a7;
    goto LABEL_59;
  }
  float v17 = IR::IRCoordinates::get(a2, *(_DWORD *)(*((void *)a1 + 10) + 4 * *(int *)(v11 + 4 * a3)));
  uint64_t v18 = *((void *)a1 + 13);
  uint64_t v19 = *(int *)(v18 + 4 * a3);
  uint64_t v20 = *((void *)a1 + 16);
  float v21 = *(float *)(v20 + 4 * v19);
  if (v21 != 0.0)
  {
    float v17 = fmodf(v17, *(float *)(v20 + 4 * v19));
    if (v17 < 0.0) {
      float v17 = v21 + v17;
    }
  }
  long long v23 = *a4;
  uint64_t v22 = a4[1];
  if (v22 == *a4)
  {
    long long v25 = a4[1];
    uint64_t v22 = *a4;
  }
  else
  {
    unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v22 - (char *)*a4) >> 5);
    long long v25 = *a4;
    do
    {
      unint64_t v26 = v24 >> 1;
      uint64_t v27 = &v25[24 * (v24 >> 1)];
      float v29 = *v27;
      uint64_t v28 = v27 + 24;
      v24 += ~(v24 >> 1);
      if (v29 < v17) {
        long long v25 = v28;
      }
      else {
        unint64_t v24 = v26;
      }
    }
    while (v24);
  }
  if (v22 == v25)
  {
    unsigned int v36 = -1431655765 * ((unint64_t)((char *)v22 - (char *)v23) >> 5) - 1;
    if (v21 == 0.0) {
      goto LABEL_27;
    }
    LODWORD(v37) = 0;
    float v38 = v23[24 * v36];
    float v39 = v17 - v38;
    float v40 = v21 + *v23;
    goto LABEL_22;
  }
  float v35 = *v25;
  if (*v25 == v17)
  {
    unsigned int v36 = -1431655765 * ((unint64_t)((char *)v25 - (char *)v23) >> 5);
LABEL_27:
    LODWORD(v37) = -1;
    float v42 = 1.0;
    float v43 = 1.0;
    goto LABEL_28;
  }
  if (v23 != v25)
  {
    unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * (((char *)v25 - (char *)v23) >> 5);
    unsigned int v36 = v37 - 1;
    float v38 = v23[24 * (v37 - 1)];
    float v39 = v17 - v38;
    float v40 = v23[24 * v37];
LABEL_22:
    float v41 = v40 - v38;
    goto LABEL_23;
  }
  if (v21 == 0.0)
  {
    unsigned int v36 = 0;
    goto LABEL_27;
  }
  LODWORD(v37) = 0;
  unsigned int v36 = -1431655765 * ((unint64_t)((char *)v22 - (char *)v23) >> 5) - 1;
  float v44 = v23[24 * v36];
  float v39 = v21 + (float)(v17 - v44);
  float v41 = (float)(v21 + v35) - v44;
LABEL_23:
  float v42 = v39 / v41;
  float v43 = 1.0 - v42;
LABEL_28:
  int v45 = a5;
  if (a5 == 3) {
    int v45 = *(_DWORD *)(*((void *)a1 + 25) + 4 * v19);
  }
  float v46 = sqrtf(v43);
  float v47 = sqrtf(v42);
  if (v42 <= v43) {
    unsigned int v48 = v36;
  }
  else {
    unsigned int v48 = v37;
  }
  float v49 = 1.0;
  float v50 = 0.0;
  if (v37 == -1)
  {
    float v50 = v42;
    float v49 = v43;
    unsigned int v48 = v36;
  }
  if (v45)
  {
    unsigned int v51 = v37;
  }
  else
  {
    float v42 = v50;
    float v43 = v49;
    unsigned int v51 = -1;
  }
  if (v45) {
    unsigned int v48 = v36;
  }
  if (v45 == 2)
  {
    float v42 = v47;
    float v43 = v46;
    unint64_t v52 = v37;
  }
  else
  {
    unint64_t v52 = v51;
  }
  if (v45 == 2) {
    unint64_t v53 = v36;
  }
  else {
    unint64_t v53 = v48;
  }
  float v54 = v43 * a7;
  float v55 = v42 * a7;
  unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * (((char *)v22 - (char *)v23) >> 5);
  if (((*((void *)a1 + 14) - v18) >> 2) - 1 > (unint64_t)a3)
  {
    if (v56 > v53)
    {
      std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__value_func[abi:ne180100]((uint64_t)v58, a6);
      IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights(a1, a2, a3 + 1, &v23[24 * v53 + 18], a5, v58, v54);
      std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v58);
      long long v23 = *a4;
      unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 5);
    }
    if (v56 > v52)
    {
      std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__value_func[abi:ne180100]((uint64_t)v57, a6);
      IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights(a1, a2, a3 + 1, &v23[24 * v52 + 18], a5, v57, v55);
      std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v57);
    }
    return;
  }
  if (v56 <= v53)
  {
    if (v56 <= v52) {
      return;
    }
    unint64_t v33 = IR::IRData::Implementation::getEmptyIRDataNode(v16);
    EmptyIRDataNode = (int *)&(*a4)[24 * v52];
    float v34 = 0.0;
    uint64_t v32 = a6;
  }
  else
  {
    if (v56 <= v52)
    {
      EmptyIRDataNode = IR::IRData::Implementation::getEmptyIRDataNode(v16);
      float v31 = 0.0;
      uint64_t v32 = a6;
      unint64_t v33 = (int *)&v23[24 * v53];
      float v34 = v54;
      goto LABEL_59;
    }
    EmptyIRDataNode = (int *)&v23[24 * v52];
    uint64_t v32 = a6;
    unint64_t v33 = (int *)&v23[24 * v53];
    float v34 = v54;
  }
  float v31 = v55;
LABEL_59:

  std::function<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(v32, (uint64_t)v33, (uint64_t)EmptyIRDataNode, v34, v31);
}

void sub_21B4FE6F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, unsigned int a9)
{
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(*a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, unsigned int a9)
{
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(*a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(unint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, unsigned int a9)
{
  v45[4] = *MEMORY[0x263EF8340];
  int v15 = *(unsigned __int8 *)(a1 + 488);
  if (*(unsigned char *)(a1 + 488))
  {
    if (*(void *)(a1 + 504) == *(void *)(a1 + 512)) {
      IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
    }
  }
  else if (*(void *)(*(void *)(a1 + 264) + 8) == **(void **)(a1 + 264))
  {
    IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  if (a6 != a8) {
    IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  if (a6 < a4) {
    IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  uint64_t result = 1667786857;
  unint64_t v17 = *(unsigned int *)(a1 + 32);
  if (a4 <= v17)
  {
    if (a4)
    {
      uint64_t v18 = 0;
      while (*(_DWORD *)(a3 + 4 * v18) < v17)
      {
        if (++v18 >= a4)
        {
          unsigned int v19 = a4;
          goto LABEL_14;
        }
      }
    }
    else
    {
      unsigned int v19 = 0;
LABEL_14:
      if (a6 >= v19) {
        int v20 = v19;
      }
      else {
        int v20 = a6;
      }
      if (v20)
      {
        if (*(unsigned char *)(a1 + 24) || !*(_DWORD *)(a1 + 16))
        {
          if (a6)
          {
            uint64_t v21 = 0;
            uint64_t v22 = (uint64_t *)(a5 + 8);
            long long v23 = (uint64_t *)(a5 + 8);
            do
            {
              uint64_t v25 = *v23;
              v23 += 2;
              uint64_t v24 = v25;
              if (v25 >= 1) {
                bzero((void *)*(v22 - 1), 4 * (v24 - ((v24 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
              }
              *(_DWORD *)(a7 + 4 * v21++) = 0;
              uint64_t v22 = v23;
            }
            while (a6 > v21);
          }
          unsigned int v43 = 0;
          if (v15)
          {
            long long v26 = *(_OWORD *)(a2 + 16);
            long long v38 = *(_OWORD *)a2;
            unint64_t v30 = a1;
            unint64_t v31 = a5;
            unint64_t v32 = a6;
            unint64_t v33 = a7;
            unint64_t v34 = a6;
            unint64_t v35 = a3;
            unint64_t v36 = a4;
            unsigned int v37 = a9;
            long long v39 = v26;
            int v40 = *(_DWORD *)(a2 + 32);
            int v41 = v20;
            float v42 = &v43;
            uint64_t v27 = *(float ***)(a1 + 264);
            v45[0] = &unk_26CB579C8;
            v45[1] = &v30;
            v45[3] = v45;
            IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights((IR::IRData::Implementation *)a1, a2, 0, v27, a9, (uint64_t)v45, 1.0);
            std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v45);
            return v43;
          }
          else
          {
            unint64_t v30 = a5;
            unint64_t v31 = a6;
            unint64_t v32 = a7;
            unint64_t v33 = a6;
            unint64_t v34 = a3;
            unint64_t v35 = a4;
            LODWORD(v36) = v20;
            uint64_t v28 = *(float ***)(a1 + 264);
            v44[0] = &unk_26CB57A10;
            v44[1] = &v30;
            v44[3] = v44;
            IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights((IR::IRData::Implementation *)a1, a2, 0, v28, a9, (uint64_t)v44, 1.0);
            std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v44);
            return 0;
          }
        }
        else
        {
          return 1852793702;
        }
      }
      else if (v17)
      {
        return 1701671028;
      }
      else
      {
        return 1852793972;
      }
    }
  }
  return result;
}

void sub_21B4FE9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, unsigned int a7)
{
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(*a1, a2, *(void *)(*a1 + 40), (uint64_t)(*(void *)(*a1 + 48) - *(void *)(*a1 + 40)) >> 2, a3, a4, a5, a6, a7);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, unsigned int a7)
{
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(*a1, a2, *(void *)(*a1 + 40), (uint64_t)(*(void *)(*a1 + 48) - *(void *)(*a1 + 40)) >> 2, a3, a4, a5, a6, a7);
}

uint64_t IR::IRData::Implementation::getInterpolatedCoeffs(unint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, unsigned int a9)
{
  void v43[4] = *MEMORY[0x263EF8340];
  int v15 = *(unsigned __int8 *)(a1 + 488);
  if (*(unsigned char *)(a1 + 488))
  {
    if (*(void *)(a1 + 504) == *(void *)(a1 + 512)) {
      IR::IRData::Implementation::getInterpolatedCoeffs();
    }
  }
  else if (*(void *)(*(void *)(a1 + 264) + 8) == **(void **)(a1 + 264))
  {
    IR::IRData::Implementation::getInterpolatedCoeffs();
  }
  if (a6 != a8) {
    IR::IRData::Implementation::getInterpolatedCoeffs();
  }
  if (a6 < a4) {
    IR::IRData::Implementation::getInterpolatedCoeffs();
  }
  uint64_t result = 1667786857;
  unint64_t v17 = *(unsigned int *)(a1 + 32);
  if (a4 <= v17)
  {
    if (a4)
    {
      uint64_t v18 = 0;
      while (*(_DWORD *)(a3 + 4 * v18) < v17)
      {
        if (++v18 >= a4)
        {
          unsigned int v19 = a4;
          goto LABEL_14;
        }
      }
    }
    else
    {
      unsigned int v19 = 0;
LABEL_14:
      if (a6 >= v19) {
        int v20 = v19;
      }
      else {
        int v20 = a6;
      }
      if (v20)
      {
        if (a6)
        {
          uint64_t v27 = a2;
          uint64_t v21 = 0;
          unsigned int v22 = 1;
          do
          {
            IR::FFTFilterKernel::reset((IR::FFTFilterKernel *)(a5 + 40 * v21));
            *(_DWORD *)(a7 + 4 * v21) = 0;
            uint64_t v21 = v22;
          }
          while (a6 > v22++);
          int v15 = *(unsigned __int8 *)(a1 + 488);
          a2 = v27;
        }
        unsigned int v41 = 0;
        if (v15)
        {
          long long v24 = *(_OWORD *)(a2 + 16);
          long long v35 = *(_OWORD *)a2;
          long long v36 = v24;
          unint64_t v28 = a1;
          unint64_t v29 = a5;
          unint64_t v30 = a6;
          unint64_t v31 = a3;
          unint64_t v32 = a4;
          unint64_t v33 = a7;
          unint64_t v34 = a6;
          int v37 = *(_DWORD *)(a2 + 32);
          unsigned int v38 = a9;
          int v39 = v20;
          int v40 = &v41;
          uint64_t v25 = *(float ***)(a1 + 264);
          v43[0] = &unk_26CB578A8;
          v43[1] = &v28;
          v43[3] = v43;
          IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights((IR::IRData::Implementation *)a1, a2, 0, v25, a9, (uint64_t)v43, 1.0);
          std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v43);
          return v41;
        }
        else
        {
          unint64_t v28 = a5;
          unint64_t v29 = a6;
          unint64_t v30 = a7;
          unint64_t v31 = a6;
          unint64_t v32 = a3;
          unint64_t v33 = a4;
          LODWORD(v34) = v20;
          long long v26 = *(float ***)(a1 + 264);
          v42[0] = &unk_26CB578F0;
          v42[1] = &v28;
          v42[3] = v42;
          IR::IRData::Implementation::getNearbyNodesAndInterpolationWeights((IR::IRData::Implementation *)a1, a2, 0, v26, a9, (uint64_t)v42, 1.0);
          std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](v42);
          return 0;
        }
      }
      else if (v17)
      {
        return 1701671028;
      }
      else
      {
        return 1852793972;
      }
    }
  }
  return result;
}

void sub_21B4FECF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::Implementation::getInterpolatedCoeffs(unint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, unsigned int a7)
{
  return IR::IRData::Implementation::getInterpolatedCoeffs(a1, a2, *(void *)(a1 + 40), (uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 2, a3, a4, a5, a6, a7);
}

uint64_t std::function<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  float v8 = a4;
  float v7 = a5;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, float *, float *))(*(void *)v5 + 48))(v5, a2, a3, &v8, &v7);
}

uint64_t IR::IRData::getInterpolatedCoeffs(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, unsigned int a6)
{
  return IR::IRData::Implementation::getInterpolatedCoeffs(*a1, a2, *a3, (uint64_t)(a3[1] - *a3) >> 2, *a4, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a4[1] - *a4) >> 3), *a5, (uint64_t)(a5[1] - *a5) >> 2, a6);
}

uint64_t IR::IRData::getInterpolatedCoeffs(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, unsigned int a9)
{
  return IR::IRData::Implementation::getInterpolatedCoeffs(*a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t IR::IRData::getInterpolatedCoeffs(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t *a4, unsigned int a5)
{
  return IR::IRData::Implementation::getInterpolatedCoeffs(*a1, a2, *(void *)(*a1 + 40), (uint64_t)(*(void *)(*a1 + 48) - *(void *)(*a1 + 40)) >> 2, *a3, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a3[1] - *a3) >> 3), *a4, (uint64_t)(a4[1] - *a4) >> 2, a5);
}

uint64_t IR::IRData::getInterpolatedCoeffs(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, unsigned int a7)
{
  return IR::IRData::Implementation::getInterpolatedCoeffs(*a1, a2, *(void *)(*a1 + 40), (uint64_t)(*(void *)(*a1 + 48) - *(void *)(*a1 + 40)) >> 2, a3, a4, a5, a6, a7);
}

uint64_t IR::IRData::getInterpolatedCoeffs(unint64_t *a1, uint64_t a2, int a3, unint64_t a4, unint64_t a5, unsigned int a6)
{
  unint64_t v6 = *a1;
  int v8 = a3;
  return IR::IRData::Implementation::getInterpolatedCoeffs(v6, a2, (unint64_t)&v8, 1uLL, a4, 1uLL, a5, 1, a6);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, unsigned int a6)
{
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(*a1, a2, *a3, (uint64_t)(a3[1] - *a3) >> 2, *a4, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 3), *a5, (uint64_t)(a5[1] - *a5) >> 2, a6);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs(unint64_t *a1, uint64_t a2, unint64_t *a3, unint64_t *a4, unsigned int a5)
{
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(*a1, a2, *(void *)(*a1 + 40), (uint64_t)(*(void *)(*a1 + 48) - *(void *)(*a1 + 40)) >> 2, *a3, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 3), *a4, (uint64_t)(a4[1] - *a4) >> 2, a5);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs(unint64_t *a1, uint64_t a2, int a3, void *a4, unint64_t a5, unsigned int a6)
{
  unint64_t v6 = *a1;
  uint64_t v7 = (uint64_t)(a4[1] - *a4) >> 2;
  v10[0] = *a4;
  v10[1] = v7;
  int v9 = a3;
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(v6, a2, (unint64_t)&v9, 1uLL, (unint64_t)v10, 1uLL, a5, 1, a6);
}

uint64_t IR::IRData::getInterpolatedTimeDomainCoeffs(unint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7)
{
  unint64_t v7 = *a1;
  v10[0] = a4;
  v10[1] = a5;
  int v9 = a3;
  return IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(v7, a2, (unint64_t)&v9, 1uLL, (unint64_t)v10, 1uLL, a6, 1, a7);
}

BOOL IR::IRData::canInterpolateInDimension(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD **)(*(void *)a1 + 152);
  int v3 = *(_DWORD **)(*(void *)a1 + 160);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = *(_DWORD **)(*(void *)a1 + 160);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

void std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__func()
{
}

void *std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CB578A8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_26CB578A8;
  a2[1] = *(void *)(result + 8);
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_0>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(uint64_t result, uint64_t a2, uint64_t a3, float *a4, float *a5)
{
  uint64_t v7 = *(void *)(result + 8);
  float v8 = *a4;
  float v9 = *a5;
  uint64_t v10 = *(void *)v7;
  if (*a4 != 0.0)
  {
    uint64_t v11 = (uint64_t *)(a2 + 32);
    if (*(void *)(a2 + 32))
    {
      long long v12 = *(_OWORD *)(v7 + 72);
      v41[0] = *(_OWORD *)(v7 + 56);
      v41[1] = v12;
      unsigned int v13 = *(_DWORD *)(v7 + 92);
      int v42 = *(_DWORD *)(v7 + 88);
      uint64_t result = IR::IRData::Implementation::getTriangleIndicesAndCoordinates(v10, (uint64_t)v41, v13, &v49, (uint64_t)&v46, (uint64_t)&v43, *(_DWORD *)(v10 + 492), (VBAP ***)(a2 + 32));
      **(_DWORD **)(v7 + 104) = result;
      if (result) {
        return result;
      }
      if (*(_DWORD *)(v7 + 96))
      {
        uint64_t v14 = 0;
        unint64_t v15 = 0;
        uint64_t v16 = *v11;
        int v17 = v49;
        uint64_t v18 = *(void *)(v7 + 24);
        do
        {
          IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)(v7 + 8) + v14), *(const IR::FFTFilterKernel **)(*(void *)(*(void *)(v16 + 88) + 24 * v17)+ 8 * *(unsigned int *)(v18 + 4 * v15)), v8 * v46);
          IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)(v7 + 8) + v14), *(const IR::FFTFilterKernel **)(*(void *)(*(void *)(*v11 + 88) + 24 * v50)+ 8 * *(unsigned int *)(*(void *)(v7 + 24) + 4 * v15)), v8 * v47);
          uint64_t result = IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)(v7 + 8) + v14), *(const IR::FFTFilterKernel **)(*(void *)(*(void *)(*v11 + 88) + 24 * v51)+ 8 * *(unsigned int *)(*(void *)(v7 + 24) + 4 * v15)), v8 * v48);
          uint64_t v16 = *v11;
          int v17 = v49;
          uint64_t v19 = *(void *)(*v11 + 112);
          uint64_t v18 = *(void *)(v7 + 24);
          uint64_t v20 = *(unsigned int *)(v18 + 4 * v15);
          uint64_t v21 = *(void *)(v7 + 40);
          float v22 = *(float *)(v21 + 4 * v15)
              + (float)((float)(v8 * v43) * *(float *)(*(void *)(v19 + 24 * v49) + 4 * v20));
          *(float *)(v21 + 4 * v15) = v22;
          float v23 = v22 + (float)((float)(v8 * v44) * *(float *)(*(void *)(v19 + 24 * v50) + 4 * v20));
          *(float *)(v21 + 4 * v15) = v23;
          *(float *)(v21 + 4 * v15++) = v23
                                      + (float)((float)(v8 * v45) * *(float *)(*(void *)(v19 + 24 * v51) + 4 * v20));
          v14 += 40;
        }
        while (v15 < *(unsigned int *)(v7 + 96));
      }
    }
  }
  if (v9 != 0.0)
  {
    long long v26 = *(void **)(a3 + 32);
    uint64_t v25 = (VBAP ***)(a3 + 32);
    long long v24 = v26;
    if (v26)
    {
      if (*v24 == **(void **)(a2 + 32)
        || (long long v27 = *(_OWORD *)(v7 + 72),
            v39[0] = *(_OWORD *)(v7 + 56),
            v39[1] = v27,
            unsigned int v28 = *(_DWORD *)(v7 + 92),
            int v40 = *(_DWORD *)(v7 + 88),
            uint64_t result = IR::IRData::Implementation::getTriangleIndicesAndCoordinates(v10, (uint64_t)v39, v28, &v49, (uint64_t)&v46, (uint64_t)&v43, *(_DWORD *)(v10 + 492), v25), (**(_DWORD **)(v7 + 104) = result) == 0))
      {
        if (*(_DWORD *)(v7 + 96))
        {
          uint64_t v29 = 0;
          unint64_t v30 = 0;
          unint64_t v31 = *v25;
          int v32 = v49;
          uint64_t v33 = *(void *)(v7 + 24);
          do
          {
            IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)(v7 + 8) + v29), *(const IR::FFTFilterKernel **)(*((void *)v31[11] + 3 * v32) + 8 * *(unsigned int *)(v33 + 4 * v30)), v9 * v46);
            IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)(v7 + 8) + v29), *(const IR::FFTFilterKernel **)(*((void *)(*v25)[11] + 3 * v50)+ 8 * *(unsigned int *)(*(void *)(v7 + 24) + 4 * v30)), v9 * v47);
            uint64_t result = IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)(v7 + 8) + v29), *(const IR::FFTFilterKernel **)(*((void *)(*v25)[11] + 3 * v51)+ 8 * *(unsigned int *)(*(void *)(v7 + 24) + 4 * v30)), v9 * v48);
            unint64_t v31 = *v25;
            int v32 = v49;
            unint64_t v34 = (*v25)[14];
            uint64_t v33 = *(void *)(v7 + 24);
            uint64_t v35 = *(unsigned int *)(v33 + 4 * v30);
            uint64_t v36 = *(void *)(v7 + 40);
            float v37 = *(float *)(v36 + 4 * v30)
                + (float)((float)(v9 * v43) * *(float *)(*((void *)v34 + 3 * v49) + 4 * v35));
            *(float *)(v36 + 4 * v3std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v37;
            float v38 = v37 + (float)((float)(v9 * v44) * *(float *)(*((void *)v34 + 3 * v50) + 4 * v35));
            *(float *)(v36 + 4 * v3std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v38;
            *(float *)(v36 + 4 * v30++) = v38
                                        + (float)((float)(v9 * v45) * *(float *)(*((void *)v34 + 3 * v51) + 4 * v35));
            v29 += 40;
          }
          while (v30 < *(unsigned int *)(v7 + 96));
        }
      }
    }
  }
  return result;
}

void *std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__func()
{
}

void *std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CB578F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_26CB578F0;
  a2[1] = *(void *)(result + 8);
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>,std::allocator<std::reference_wrapper<IR::IRData::Implementation::getInterpolatedCoeffs(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<IR::FFTFilterKernel,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::$_1>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(uint64_t result, uint64_t a2, uint64_t a3, float *a4, float *a5)
{
  uint64_t v5 = *(void *)(result + 8);
  if (*(_DWORD *)(v5 + 48))
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    float v10 = *a4;
    float v11 = *a5;
    do
    {
      if (v10 != 0.0)
      {
        uint64_t result = IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)v5 + v8), *(const IR::FFTFilterKernel **)(*(void *)(a2 + 8)+ 8 * *(unsigned int *)(*(void *)(v5 + 32) + 4 * v9)), v10);
        *(float *)(*(void *)(v5 + 16) + 4 * v9) = *(float *)(*(void *)(v5 + 16) + 4 * v9)
                                                  + (float)(*(float *)(*(void *)(a2 + 48)
                                                                     + 4
                                                                     * *(unsigned int *)(*(void *)(v5 + 32) + 4 * v9))
                                                          * v10);
      }
      if (v11 != 0.0)
      {
        uint64_t result = IR::FFTFilterKernel::accumulate((IR::FFTFilterKernel *)(*(void *)v5 + v8), *(const IR::FFTFilterKernel **)(*(void *)(a3 + 8)+ 8 * *(unsigned int *)(*(void *)(v5 + 32) + 4 * v9)), v11);
        *(float *)(*(void *)(v5 + 16) + 4 * v9) = *(float *)(*(void *)(v5 + 16) + 4 * v9)
                                                  + (float)(*(float *)(*(void *)(a3 + 48)
                                                                     + 4
                                                                     * *(unsigned int *)(*(void *)(v5 + 32) + 4 * v9))
                                                          * v11);
      }
      ++v9;
      v8 += 40;
    }
    while (v9 < *(unsigned int *)(v5 + 48));
  }
  return result;
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__func()
{
}

void *std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CB57938;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_26CB57938;
  a2[1] = *(void *)(result + 8);
  return result;
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5)
{
}

void IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)const::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  uint64_t v9 = *(void *)a1;
  if (a4 != 0.0)
  {
    float v10 = (uint64_t *)(a2 + 32);
    if (*(void *)(a2 + 32))
    {
      long long v12 = *(_OWORD *)(a1 + 76);
      v54[0] = *(_OWORD *)(a1 + 60);
      v54[1] = v12;
      int v55 = *(_DWORD *)(a1 + 92);
      int TriangleIndicesAndCoordinates = IR::IRData::Implementation::getTriangleIndicesAndCoordinates(v9, (uint64_t)v54, *(_DWORD *)(a1 + 56), &v62, (uint64_t)&v59, (uint64_t)&v56, *(_DWORD *)(v9 + 492), (VBAP ***)(a2 + 32));
      **(_DWORD **)(a1 + 104) = TriangleIndicesAndCoordinates;
      if (TriangleIndicesAndCoordinates) {
        return;
      }
      if (*(_DWORD *)(a1 + 96))
      {
        uint64_t v14 = 0;
        unint64_t v15 = 0;
        uint64_t v16 = *v10;
        int v17 = v62;
        uint64_t v18 = *(void *)(a1 + 40);
        do
        {
          uint64_t v19 = *(void *)(a1 + 8) + v14;
          uint64_t v20 = *(float **)v19;
          uint64_t v21 = (*(void *)(v19 + 8) - *(void *)v19) >> 2;
          uint64_t v22 = *(void *)(*(void *)(v16 + 88) + 24 * v17);
          uint64_t v23 = (*(void *)(*(void *)(v22 + 8 * *(unsigned int *)(v18 + 4 * v15)) + 8)
               - **(void **)(v22 + 8 * *(unsigned int *)(v18 + 4 * v15))) >> 2;
          if (v23 >= v21) {
            vDSP_Length v24 = v21;
          }
          else {
            vDSP_Length v24 = v23;
          }
          float __B = v59 * a4;
          vDSP_vsma(**(const float ***)(v22 + 8 * *(unsigned int *)(v18 + 4 * v15)), 1, &__B, v20, 1, v20, 1, v24);
          float __B = v60 * a4;
          vDSP_vsma(**(const float ***)(*(void *)(*(void *)(*v10 + 88) + 24 * v63)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v15)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v14), 1, *(float **)(*(void *)(a1 + 8) + v14), 1, v24);
          float __B = v61 * a4;
          vDSP_vsma(**(const float ***)(*(void *)(*(void *)(*v10 + 88) + 24 * v64)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v15)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v14), 1, *(float **)(*(void *)(a1 + 8) + v14), 1, v24);
          uint64_t v16 = *v10;
          int v17 = v62;
          uint64_t v25 = *(void *)(*v10 + 112);
          uint64_t v18 = *(void *)(a1 + 40);
          uint64_t v26 = *(unsigned int *)(v18 + 4 * v15);
          uint64_t v27 = *(void *)(a1 + 24);
          float v28 = *(float *)(v27 + 4 * v15)
              + (float)((float)(*(float *)(*(void *)(v25 + 24 * v62) + 4 * v26) * v56) * a4);
          *(float *)(v27 + 4 * v15) = v28;
          float v29 = v28 + (float)((float)(*(float *)(*(void *)(v25 + 24 * v63) + 4 * v26) * v57) * a4);
          *(float *)(v27 + 4 * v15) = v29;
          *(float *)(v27 + 4 * v15++) = v29
                                      + (float)((float)(*(float *)(*(void *)(v25 + 24 * v64) + 4 * v26) * v58) * a4);
          v14 += 24;
        }
        while (v15 < *(unsigned int *)(a1 + 96));
      }
    }
  }
  if (a5 != 0.0)
  {
    int v32 = *(void **)(a3 + 32);
    unint64_t v31 = (VBAP ***)(a3 + 32);
    unint64_t v30 = v32;
    if (v32)
    {
      if (*v30 == **(void **)(a2 + 32)
        || (long long v33 = *(_OWORD *)(a1 + 76),
            v51[0] = *(_OWORD *)(a1 + 60),
            v51[1] = v33,
            int v52 = *(_DWORD *)(a1 + 92),
            int v34 = IR::IRData::Implementation::getTriangleIndicesAndCoordinates(v9, (uint64_t)v51, *(_DWORD *)(a1 + 56), &v62, (uint64_t)&v59, (uint64_t)&v56, *(_DWORD *)(v9 + 492), v31), (**(_DWORD **)(a1 + 104) = v34) == 0))
      {
        if (*(_DWORD *)(a1 + 96))
        {
          uint64_t v35 = 0;
          unint64_t v36 = 0;
          float v37 = *v31;
          int v38 = v62;
          uint64_t v39 = *(void *)(a1 + 40);
          do
          {
            uint64_t v40 = *(void *)(a1 + 8) + v35;
            unsigned int v41 = *(float **)v40;
            uint64_t v42 = (*(void *)(v40 + 8) - *(void *)v40) >> 2;
            uint64_t v43 = *((void *)v37[11] + 3 * v38);
            uint64_t v44 = (*(void *)(*(void *)(v43 + 8 * *(unsigned int *)(v39 + 4 * v36)) + 8)
                 - **(void **)(v43 + 8 * *(unsigned int *)(v39 + 4 * v36))) >> 2;
            if (v44 >= v42) {
              vDSP_Length v45 = v42;
            }
            else {
              vDSP_Length v45 = v44;
            }
            float __B = v59 * a5;
            vDSP_vsma(**(const float ***)(v43 + 8 * *(unsigned int *)(v39 + 4 * v36)), 1, &__B, v41, 1, v41, 1, v45);
            float __B = v60 * a5;
            vDSP_vsma(**(const float ***)(*((void *)(*v31)[11] + 3 * v63)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v36)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v35), 1, *(float **)(*(void *)(a1 + 8) + v35), 1, v45);
            float __B = v61 * a5;
            vDSP_vsma(**(const float ***)(*((void *)(*v31)[11] + 3 * v64)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v36)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v35), 1, *(float **)(*(void *)(a1 + 8) + v35), 1, v45);
            float v37 = *v31;
            int v38 = v62;
            float v46 = (*v31)[14];
            uint64_t v39 = *(void *)(a1 + 40);
            uint64_t v47 = *(unsigned int *)(v39 + 4 * v36);
            uint64_t v48 = *(void *)(a1 + 24);
            float v49 = *(float *)(v48 + 4 * v36)
                + (float)((float)(*(float *)(*((void *)v46 + 3 * v62) + 4 * v47) * v56) * a5);
            *(float *)(v48 + 4 * v36) = v49;
            float v50 = v49 + (float)((float)(*(float *)(*((void *)v46 + 3 * v63) + 4 * v47) * v57) * a5);
            *(float *)(v48 + 4 * v36) = v50;
            *(float *)(v48 + 4 * v36++) = v50
                                        + (float)((float)(*(float *)(*((void *)v46 + 3 * v64) + 4 * v47) * v58) * a5);
            v35 += 24;
          }
          while (v36 < *(unsigned int *)(a1 + 96));
        }
      }
    }
  }
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__func()
{
}

void *std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CB57980;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_26CB57980;
  a2[1] = *(void *)(result + 8);
  return result;
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5)
{
}

void IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::vector<float>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)const::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  float v24 = a5;
  float __B = a4;
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      if (__B != 0.0)
      {
        uint64_t v10 = *(void *)a1 + v8;
        float v11 = *(float **)v10;
        uint64_t v12 = (*(void *)(v10 + 8) - *(void *)v10) >> 2;
        uint64_t v13 = *(void *)(*(void *)(a2 + 8) + 8 * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9));
        uint64_t v14 = *(const float **)v13;
        uint64_t v15 = (*(void *)(v13 + 8) - *(void *)v13) >> 2;
        if (v15 >= v12) {
          vDSP_Length v16 = v12;
        }
        else {
          vDSP_Length v16 = v15;
        }
        vDSP_vsma(v14, 1, &__B, v11, 1, v11, 1, v16);
        *(float *)(*(void *)(a1 + 16) + 4 * v9) = *(float *)(*(void *)(a1 + 16) + 4 * v9)
                                                  + (float)(*(float *)(*(void *)(a2 + 48)
                                                                     + 4
                                                                     * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9))
                                                          * __B);
      }
      if (v24 != 0.0)
      {
        uint64_t v17 = *(void *)a1 + v8;
        uint64_t v18 = *(float **)v17;
        uint64_t v19 = (*(void *)(v17 + 8) - *(void *)v17) >> 2;
        uint64_t v20 = *(void *)(*(void *)(a3 + 8) + 8 * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9));
        uint64_t v21 = *(const float **)v20;
        uint64_t v22 = (*(void *)(v20 + 8) - *(void *)v20) >> 2;
        if (v22 >= v19) {
          vDSP_Length v23 = v19;
        }
        else {
          vDSP_Length v23 = v22;
        }
        vDSP_vsma(v21, 1, &v24, v18, 1, v18, 1, v23);
        *(float *)(*(void *)(a1 + 16) + 4 * v9) = *(float *)(*(void *)(a1 + 16) + 4 * v9)
                                                  + (float)(*(float *)(*(void *)(a3 + 48)
                                                                     + 4
                                                                     * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9))
                                                          * v24);
      }
      ++v9;
      v8 += 24;
    }
    while (v9 < *(unsigned int *)(a1 + 48));
  }
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__func()
{
}

void *std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CB579C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_26CB579C8;
  a2[1] = *(void *)(result + 8);
  return result;
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5)
{
}

void IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)const::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  uint64_t v9 = *(void *)a1;
  if (a4 != 0.0)
  {
    uint64_t v10 = (uint64_t *)(a2 + 32);
    if (*(void *)(a2 + 32))
    {
      long long v12 = *(_OWORD *)(a1 + 76);
      v52[0] = *(_OWORD *)(a1 + 60);
      v52[1] = v12;
      int v53 = *(_DWORD *)(a1 + 92);
      int TriangleIndicesAndCoordinates = IR::IRData::Implementation::getTriangleIndicesAndCoordinates(v9, (uint64_t)v52, *(_DWORD *)(a1 + 56), &v60, (uint64_t)&v57, (uint64_t)&v54, *(_DWORD *)(v9 + 492), (VBAP ***)(a2 + 32));
      **(_DWORD **)(a1 + 104) = TriangleIndicesAndCoordinates;
      if (TriangleIndicesAndCoordinates) {
        return;
      }
      if (*(_DWORD *)(a1 + 96))
      {
        uint64_t v14 = 0;
        unint64_t v15 = 0;
        uint64_t v16 = *v10;
        int v17 = v60;
        uint64_t v18 = *(void *)(a1 + 40);
        do
        {
          uint64_t v19 = *(void *)(a1 + 8) + v14;
          uint64_t v20 = *(void *)(*(void *)(v16 + 88) + 24 * v17);
          unsigned int v21 = *(_DWORD *)(v19 + 8);
          uint64_t v22 = (*(void *)(*(void *)(v20 + 8 * *(unsigned int *)(v18 + 4 * v15)) + 8)
               - **(void **)(v20 + 8 * *(unsigned int *)(v18 + 4 * v15))) >> 2;
          if (v22 >= v21) {
            vDSP_Length v23 = v21;
          }
          else {
            vDSP_Length v23 = v22;
          }
          float __B = v57 * a4;
          vDSP_vsma(**(const float ***)(v20 + 8 * *(unsigned int *)(v18 + 4 * v15)), 1, &__B, *(const float **)v19, 1, *(float **)v19, 1, v23);
          float __B = v58 * a4;
          vDSP_vsma(**(const float ***)(*(void *)(*(void *)(*v10 + 88) + 24 * v61)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v15)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v14), 1, *(float **)(*(void *)(a1 + 8) + v14), 1, v23);
          float __B = v59 * a4;
          vDSP_vsma(**(const float ***)(*(void *)(*(void *)(*v10 + 88) + 24 * v62)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v15)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v14), 1, *(float **)(*(void *)(a1 + 8) + v14), 1, v23);
          uint64_t v16 = *v10;
          int v17 = v60;
          uint64_t v24 = *(void *)(*v10 + 112);
          uint64_t v18 = *(void *)(a1 + 40);
          uint64_t v25 = *(unsigned int *)(v18 + 4 * v15);
          uint64_t v26 = *(void *)(a1 + 24);
          float v27 = *(float *)(v26 + 4 * v15)
              + (float)((float)(*(float *)(*(void *)(v24 + 24 * v60) + 4 * v25) * v54) * a4);
          *(float *)(v26 + 4 * v15) = v27;
          float v28 = v27 + (float)((float)(*(float *)(*(void *)(v24 + 24 * v61) + 4 * v25) * v55) * a4);
          *(float *)(v26 + 4 * v15) = v28;
          *(float *)(v26 + 4 * v15++) = v28
                                      + (float)((float)(*(float *)(*(void *)(v24 + 24 * v62) + 4 * v25) * v56) * a4);
          v14 += 16;
        }
        while (v15 < *(unsigned int *)(a1 + 96));
      }
    }
  }
  if (a5 != 0.0)
  {
    unint64_t v31 = *(void **)(a3 + 32);
    unint64_t v30 = (VBAP ***)(a3 + 32);
    float v29 = v31;
    if (v31)
    {
      if (*v29 == **(void **)(a2 + 32)
        || (long long v32 = *(_OWORD *)(a1 + 76),
            v49[0] = *(_OWORD *)(a1 + 60),
            v49[1] = v32,
            int v50 = *(_DWORD *)(a1 + 92),
            int v33 = IR::IRData::Implementation::getTriangleIndicesAndCoordinates(v9, (uint64_t)v49, *(_DWORD *)(a1 + 56), &v60, (uint64_t)&v57, (uint64_t)&v54, *(_DWORD *)(v9 + 492), v30), (**(_DWORD **)(a1 + 104) = v33) == 0))
      {
        if (*(_DWORD *)(a1 + 96))
        {
          uint64_t v34 = 0;
          unint64_t v35 = 0;
          unint64_t v36 = *v30;
          int v37 = v60;
          uint64_t v38 = *(void *)(a1 + 40);
          do
          {
            uint64_t v39 = *(void *)(a1 + 8) + v34;
            uint64_t v40 = *((void *)v36[11] + 3 * v37);
            unsigned int v41 = *(_DWORD *)(v39 + 8);
            uint64_t v42 = (*(void *)(*(void *)(v40 + 8 * *(unsigned int *)(v38 + 4 * v35)) + 8)
                 - **(void **)(v40 + 8 * *(unsigned int *)(v38 + 4 * v35))) >> 2;
            if (v42 >= v41) {
              vDSP_Length v43 = v41;
            }
            else {
              vDSP_Length v43 = v42;
            }
            float __B = v57 * a5;
            vDSP_vsma(**(const float ***)(v40 + 8 * *(unsigned int *)(v38 + 4 * v35)), 1, &__B, *(const float **)v39, 1, *(float **)v39, 1, v43);
            float __B = v58 * a5;
            vDSP_vsma(**(const float ***)(*((void *)(*v30)[11] + 3 * v61)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v35)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v34), 1, *(float **)(*(void *)(a1 + 8) + v34), 1, v43);
            float __B = v59 * a5;
            vDSP_vsma(**(const float ***)(*((void *)(*v30)[11] + 3 * v62)+ 8 * *(unsigned int *)(*(void *)(a1 + 40) + 4 * v35)), 1, &__B, *(const float **)(*(void *)(a1 + 8) + v34), 1, *(float **)(*(void *)(a1 + 8) + v34), 1, v43);
            unint64_t v36 = *v30;
            int v37 = v60;
            uint64_t v44 = (*v30)[14];
            uint64_t v38 = *(void *)(a1 + 40);
            uint64_t v45 = *(unsigned int *)(v38 + 4 * v35);
            uint64_t v46 = *(void *)(a1 + 24);
            float v47 = *(float *)(v46 + 4 * v35)
                + (float)((float)(*(float *)(*((void *)v44 + 3 * v60) + 4 * v45) * v54) * a5);
            *(float *)(v46 + 4 * v35) = v47;
            float v48 = v47 + (float)((float)(*(float *)(*((void *)v44 + 3 * v61) + 4 * v45) * v55) * a5);
            *(float *)(v46 + 4 * v35) = v48;
            *(float *)(v46 + 4 * v35++) = v48
                                        + (float)((float)(*(float *)(*((void *)v44 + 3 * v62) + 4 * v45) * v56) * a5);
            v34 += 16;
          }
          while (v35 < *(unsigned int *)(a1 + 96));
        }
      }
    }
  }
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::~__func()
{
}

void *std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CB57A10;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_26CB57A10;
  a2[1] = *(void *)(result + 8);
  return result;
}

void std::__function::__func<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>,std::allocator<std::reference_wrapper<int IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}>>,void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5)
{
}

void IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::span<float,18446744073709551615ul>>(IR::IRCoordinates const&,std::span<unsigned int const,18446744073709551615ul>,std::span<std::span<float,18446744073709551615ul>,18446744073709551615ul>,std::span<float,18446744073709551615ul>,IR::IRInterpolationMethod)const::{lambda(IR::IRDataNode const&,IR::IRDataNode const&,float,float)#2}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  float v22 = a5;
  float __B = a4;
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      if (__B != 0.0)
      {
        uint64_t v10 = *(void *)a1 + v8;
        unsigned int v11 = *(_DWORD *)(v10 + 8);
        uint64_t v12 = *(void *)(*(void *)(a2 + 8) + 8 * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9));
        uint64_t v13 = *(const float **)v12;
        uint64_t v14 = (*(void *)(v12 + 8) - *(void *)v12) >> 2;
        if (v14 >= v11) {
          vDSP_Length v15 = v11;
        }
        else {
          vDSP_Length v15 = v14;
        }
        vDSP_vsma(v13, 1, &__B, *(const float **)v10, 1, *(float **)v10, 1, v15);
        *(float *)(*(void *)(a1 + 16) + 4 * v9) = *(float *)(*(void *)(a1 + 16) + 4 * v9)
                                                  + (float)(*(float *)(*(void *)(a2 + 48)
                                                                     + 4
                                                                     * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9))
                                                          * __B);
      }
      if (v22 != 0.0)
      {
        uint64_t v16 = *(void *)a1 + v8;
        unsigned int v17 = *(_DWORD *)(v16 + 8);
        uint64_t v18 = *(void *)(*(void *)(a3 + 8) + 8 * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9));
        uint64_t v19 = *(const float **)v18;
        uint64_t v20 = (*(void *)(v18 + 8) - *(void *)v18) >> 2;
        if (v20 >= v17) {
          vDSP_Length v21 = v17;
        }
        else {
          vDSP_Length v21 = v20;
        }
        vDSP_vsma(v19, 1, &v22, *(const float **)v16, 1, *(float **)v16, 1, v21);
        *(float *)(*(void *)(a1 + 16) + 4 * v9) = *(float *)(*(void *)(a1 + 16) + 4 * v9)
                                                  + (float)(*(float *)(*(void *)(a3 + 48)
                                                                     + 4
                                                                     * *(unsigned int *)(*(void *)(a1 + 32) + 4 * v9))
                                                          * v22);
      }
      ++v9;
      v8 += 16;
    }
    while (v9 < *(unsigned int *)(a1 + 48));
  }
}

uint64_t std::__function::__value_func<void ()(IR::IRDataNode const&,IR::IRDataNode const&,float,float)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_21B5007C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25)
{
  applesauce::CF::DataRef::~DataRef((const void **)(v26 - 40));

  _Unwind_Resume(a1);
}

void applesauce::CF::DataRef::from_ns_noexcept(applesauce::CF::DataRef *this@<X0>, applesauce::CF::DataRef **a2@<X8>)
{
  uint64_t v4 = this;
  if (!v4 || (cf = v4, CFRetain(v4), v5 = CFGetTypeID(cf), v6 = v5 == CFDataGetTypeID(), uint64_t v4 = cf, v6))
  {
    *a2 = v4;
  }
  else
  {
    *a2 = 0;
    CFRelease(cf);
    uint64_t v4 = cf;
  }
}

uint64_t IR::IRDataAttributes::IRDataAttributes(uint64_t a1, CFTypeRef *a2, int a3, char a4, int a5, float a6)
{
  CFTypeRef v11 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  CFTypeRef cf = v11;
  IR::IRDataAttributes::IRDataAttributes(a1, (CFURLRef *)&cf, a3, a4, 0, 0, a5, a6);
  if (cf) {
    CFRelease(cf);
  }
  return a1;
}

void sub_21B50099C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::URLRef::~URLRef((const void **)va);
  _Unwind_Resume(a1);
}

os_log_t ___ZN2IR28getHOA2BinauralIRRendererLogEv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreaudio", "HOA2BinauralIRRenderer");
  IR::getHOA2BinauralIRRendererLog(void)::gLog = (uint64_t)result;
  return result;
}

HOA *std::unique_ptr<HOA>::reset[abi:ne180100](HOA **a1, HOA *a2)
{
  os_log_t result = *a1;
  *a1 = a2;
  if (result)
  {
    HOA::~HOA(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

uint64_t IR::HOA2BinauralIRRenderer::setEnvironment(IR::HOA2BinauralIRRenderer *this, unsigned int a2, BOOL a3, unsigned int a4)
{
  float v6 = (float)a2;
  *((float *)this + 32) = (float)a2;
  uint64_t v7 = (char *)this + 120;
  *((_DWORD *)this + 33) = 0;
  *((unsigned char *)this + 136) = 0;
  uint64_t v8 = IR::IRDataLoader::instance(this);
  std::string::basic_string[abi:ne180100]<0>(&__p, "HOA2BinauralIRRenderer|");
  CFTypeRef v155 = 0;
  v152 = 0;
  v153 = 0;
  uint64_t v154 = 0;
  IR::IRDataLoader::load(&v156, v8, &__p, v7, &v155, &v152);
  if (v152)
  {
    v153 = v152;
    operator delete(v152);
  }
  if (v155) {
    CFRelease(v155);
  }
  if (SHIBYTE(v142) < 0) {
    operator delete(__p);
  }
  if (!v156)
  {
    if (IR::getHOA2BinauralIRRendererLog(void)::onceToken != -1) {
      dispatch_once(&IR::getHOA2BinauralIRRendererLog(void)::onceToken, &__block_literal_global_0);
    }
    unsigned int v17 = IR::getHOA2BinauralIRRendererLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getHOA2BinauralIRRendererLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::HOA2BinauralIRRenderer::setEnvironment(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    goto LABEL_17;
  }
  if (IR::IRData::getNumFiltersPerSpatialPoint((IR::IRData *)v156) < *((_DWORD *)this + 113))
  {
    if (IR::getHOA2BinauralIRRendererLog(void)::onceToken != -1) {
      dispatch_once(&IR::getHOA2BinauralIRRendererLog(void)::onceToken, &__block_literal_global_0);
    }
    unint64_t v9 = IR::getHOA2BinauralIRRendererLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getHOA2BinauralIRRendererLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::HOA2BinauralIRRenderer::setEnvironment(v9, v10, v11, v12, v13, v14, v15, v16);
    }
LABEL_17:
    uint64_t v25 = 4294956425;
    goto LABEL_139;
  }
  FilterCFIndex Length = IR::IRData::getFilterLength((IR::IRData *)v156);
  if (FilterLength >= a4) {
    unsigned int v27 = a4;
  }
  else {
    unsigned int v27 = FilterLength;
  }
  if (!a4) {
    unsigned int v27 = FilterLength;
  }
  *((_DWORD *)this + 111) = v27;
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)&v152);
  unint64_t v28 = *((unsigned int *)this + 113);
  std::vector<float>::vector(&__p, *((unsigned int *)this + 111));
  std::vector<std::vector<float>>::vector(v151, v28, (uint64_t)&__p);
  if (__p)
  {
    uint64_t v141 = __p;
    operator delete(__p);
  }
  std::vector<float>::vector(v150, *((unsigned int *)this + 113));
  float v29 = (void **)((char *)this + 48);
  *((void *)this + 7) = *((void *)this + 6);
  uint64_t v128 = (void **)((char *)this + 72);
  *((void *)this + 1std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = *((void *)this + 9);
  uint64_t v127 = (void **)((char *)this + 96);
  *((void *)this + 13) = *((void *)this + 12);
  uint64_t PeriodForCyclicalDimensions = IR::IRData::getPeriodForCyclicalDimensions((IR::IRData *)v156);
  v147 = 0;
  v148 = 0;
  uint64_t v149 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v147, *(const void **)PeriodForCyclicalDimensions, *(void *)(PeriodForCyclicalDimensions + 8), (uint64_t)(*(void *)(PeriodForCyclicalDimensions + 8) - *(void *)PeriodForCyclicalDimensions) >> 2);
  uint64_t InterpolationMethod = IR::IRData::getInterpolationMethod((IR::IRData *)v156);
  unsigned int v144 = 0;
  unint64_t v145 = 0;
  uint64_t v146 = 0;
  std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>(&v144, *(const void **)InterpolationMethod, *(void *)(InterpolationMethod + 8), (uint64_t)(*(void *)(InterpolationMethod + 8) - *(void *)InterpolationMethod) >> 2);
  DataLayout = (int **)IR::IRData::getDataLayout((IR::IRData *)v156);
  uint64_t v34 = *DataLayout;
  int v33 = DataLayout[1];
  if (*DataLayout != v33)
  {
    int v35 = 0;
    do
    {
      int v36 = *v34;
      uint64_t v38 = (_DWORD *)*((void *)this + 3);
      int v37 = (_DWORD *)*((void *)this + 4);
      if (v38 != v37)
      {
        while (*v38 != v36)
        {
          if (++v38 == v37)
          {
            uint64_t v38 = (_DWORD *)*((void *)this + 4);
            break;
          }
        }
      }
      if (v38 != v37)
      {
        uint64_t v40 = (char *)*((void *)this + 7);
        unint64_t v39 = *((void *)this + 8);
        if ((unint64_t)v40 >= v39)
        {
          uint64_t v42 = (char *)*v29;
          uint64_t v43 = (v40 - (unsigned char *)*v29) >> 2;
          unint64_t v44 = v43 + 1;
          if ((unint64_t)(v43 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v45 = v39 - (void)v42;
          if (v45 >> 1 > v44) {
            unint64_t v44 = v45 >> 1;
          }
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v46 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v46 = v44;
          }
          if (v46)
          {
            float v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 64, v46);
            uint64_t v42 = (char *)*((void *)this + 6);
            uint64_t v40 = (char *)*((void *)this + 7);
          }
          else
          {
            float v47 = 0;
          }
          float v48 = &v47[4 * v43];
          *(_DWORD *)float v48 = v36;
          unsigned int v41 = v48 + 4;
          while (v40 != v42)
          {
            int v49 = *((_DWORD *)v40 - 1);
            v40 -= 4;
            *((_DWORD *)v48 - 1) = v49;
            v48 -= 4;
          }
          *((void *)this + 6) = v48;
          *((void *)this + 7) = v41;
          *((void *)this + 8) = &v47[4 * v46];
          if (v42) {
            operator delete(v42);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v40 = v36;
          unsigned int v41 = v40 + 4;
        }
        *((void *)this + 7) = v41;
        int v50 = v147;
        int v52 = (char *)*((void *)this + 10);
        unint64_t v51 = *((void *)this + 11);
        if ((unint64_t)v52 >= v51)
        {
          float v54 = (char *)*v128;
          uint64_t v55 = (v52 - (unsigned char *)*v128) >> 2;
          unint64_t v56 = v55 + 1;
          if ((unint64_t)(v55 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v57 = v51 - (void)v54;
          if (v57 >> 1 > v56) {
            unint64_t v56 = v57 >> 1;
          }
          if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v58 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v58 = v56;
          }
          if (v58)
          {
            float v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 88, v58);
            float v54 = (char *)*((void *)this + 9);
            int v52 = (char *)*((void *)this + 10);
          }
          else
          {
            float v59 = 0;
          }
          int v60 = &v59[4 * v55];
          *(_DWORD *)int v60 = v50[v35];
          int v53 = v60 + 4;
          while (v52 != v54)
          {
            int v61 = *((_DWORD *)v52 - 1);
            v52 -= 4;
            *((_DWORD *)v60 - 1) = v61;
            v60 -= 4;
          }
          *((void *)this + 9) = v60;
          *((void *)this + 1std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v53;
          *((void *)this + 11) = &v59[4 * v58];
          if (v54) {
            operator delete(v54);
          }
        }
        else
        {
          *(_DWORD *)int v52 = v147[v35];
          int v53 = v52 + 4;
        }
        *((void *)this + 1std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v53;
        int v62 = v144;
        int v64 = (char *)*((void *)this + 13);
        unint64_t v63 = *((void *)this + 14);
        if ((unint64_t)v64 >= v63)
        {
          float v66 = (char *)*v127;
          uint64_t v67 = (v64 - (unsigned char *)*v127) >> 2;
          unint64_t v68 = v67 + 1;
          if ((unint64_t)(v67 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v69 = v63 - (void)v66;
          if (v69 >> 1 > v68) {
            unint64_t v68 = v69 >> 1;
          }
          if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v70 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v70 = v68;
          }
          if (v70)
          {
            long long v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 112, v70);
            float v66 = (char *)*((void *)this + 12);
            int v64 = (char *)*((void *)this + 13);
          }
          else
          {
            long long v71 = 0;
          }
          uint64_t v72 = &v71[4 * v67];
          *(_DWORD *)uint64_t v72 = v62[v35];
          char v65 = v72 + 4;
          while (v64 != v66)
          {
            int v73 = *((_DWORD *)v64 - 1);
            v64 -= 4;
            *((_DWORD *)v72 - 1) = v73;
            v72 -= 4;
          }
          *((void *)this + 12) = v72;
          *((void *)this + 13) = v65;
          *((void *)this + 14) = &v71[4 * v70];
          if (v66) {
            operator delete(v66);
          }
        }
        else
        {
          *(_DWORD *)int v64 = v144[v35];
          char v65 = v64 + 4;
        }
        *((void *)this + 13) = v65;
      }
      ++v35;
      ++v34;
    }
    while (v34 != v33);
  }
  IR::IRData::getCoordinateTree(v156, (uint64_t)&__p);
  IR::HOA2BinauralIRRenderer::flattenIRCoordinateTree(this, (const IR::IRCoordinateTree *)&__p, (unint64_t *)&__A);
  int v74 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v74;
    operator delete(v74);
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
  }
  int v75 = __A;
  *(void *)this = __A;
  uint64_t v129 = v139;
  *(_OWORD *)((char *)this + 8) = v139;
  unint64_t v76 = (*((_DWORD *)this + 113) * *((_DWORD *)this + 111));
  LODWORD(v132) = 0;
  std::vector<float>::vector(&__A, v76, &v132);
  std::vector<std::vector<float>>::assign((uint64_t *)this + 58, 0x8E38E38E38E38E39 * ((v129 - (uint64_t)v75) >> 2), (uint64_t)&__A);
  if (__A)
  {
    *(void *)&long long v139 = __A;
    operator delete(__A);
  }
  if (*((void *)this + 1) != *(void *)this) {
    IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
  }
  HOA::createSphericalGridDecoder(*((unsigned int **)this + 54), 0);
  int v77 = *(_DWORD *)(*((void *)this + 54) + 24);
  *((_DWORD *)this + 114) = v77;
  unint64_t v78 = (*((_DWORD *)this + 113) * v77);
  LODWORD(__A) = 0;
  std::vector<float>::resize((uint64_t)this + 488, v78, &__A);
  uint64_t v79 = *((void *)this + 54);
  long long v139 = 0uLL;
  __A = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__A, *(const void **)(v79 + 56), *(void *)(v79 + 64), (uint64_t)(*(void *)(v79 + 64) - *(void *)(v79 + 56)) >> 2);
  vDSP_mtrans(__A, 1, *((float **)this + 61), 1, *((unsigned int *)this + 114), *((unsigned int *)this + 113));
  if (__A)
  {
    *(void *)&long long v139 = __A;
    operator delete(__A);
  }
  unint64_t v80 = (*((_DWORD *)this + 113) * *((_DWORD *)this + 113));
  LODWORD(__A) = 0;
  std::vector<float>::resize((uint64_t)this + 520, v80, &__A);
  uint64_t v130 = *((void *)this + 54);
  *((float *)this + 7std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v6;
  uint64_t v82 = IR::IRDataLoader::instance(v81);
  std::string::basic_string[abi:ne180100]<0>(&__A, "HOA2BinauralIRRenderer|");
  uint64_t v134 = 0;
  CFTypeRef cf = 0;
  v132 = 0;
  v133 = 0;
  IR::IRDataLoader::load(&v136, v82, &__A, (char *)this + 272, &cf, &v132);
  if (v132)
  {
    v133 = v132;
    operator delete(v132);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (SHIBYTE(v139) < 0) {
    operator delete(__A);
  }
  if (v136)
  {
    int v83 = IR::IRData::getFilterLength(v136);
    IR::IRData::getMaxDelay(v136);
    unsigned int v84 = *((_DWORD *)this + 111) + v83;
    unsigned int v85 = v84 - 1;
    *((_DWORD *)this + 112) = v84 - 1;
    if (v83 == 1)
    {
      *((unsigned char *)this + 46std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
      unint64_t v86 = *((unsigned int *)this + 110);
      unint64_t v87 = *((unsigned int *)this + 114);
      LODWORD(v132) = 0;
      std::vector<float>::vector(&__A, v87, &v132);
      std::vector<std::vector<float>>::assign((uint64_t *)this + 98, v86, (uint64_t)&__A);
      if (__A)
      {
        *(void *)&long long v139 = __A;
        operator delete(__A);
      }
      unsigned int v88 = *((_DWORD *)this + 110);
      unsigned int v89 = 1;
    }
    else
    {
      *((unsigned char *)this + 46std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 1;
      if (v85)
      {
        *((_DWORD *)this + 112) = v84;
        unsigned int v85 = v84;
      }
      char v98 = vcvtps_u32_f32(log2f((float)v85));
      *((_DWORD *)this + 142) = 1 << v98;
      *((_DWORD *)this + 143) = (1 << v98) >> 1;
      float v99 = 1.0 / (double)(4 << v98);
      *((float *)this + 144) = v99;
      vDSP_DFT_DestroySetup(*((vDSP_DFT_Setup *)this + 73));
      *((void *)this + 73) = vDSP_DFT_zrop_CreateSetup(0, *((unsigned int *)this + 142), vDSP_DFT_FORWARD);
      vDSP_DFT_DestroySetup(*((vDSP_DFT_Setup *)this + 74));
      *((void *)this + 74) = vDSP_DFT_zrop_CreateSetup(*((vDSP_DFT_Setup *)this + 73), *((unsigned int *)this + 142), vDSP_DFT_INVERSE);
      unint64_t v100 = *((unsigned int *)this + 110);
      unint64_t v101 = *((unsigned int *)this + 114);
      unint64_t v102 = *((unsigned int *)this + 143);
      int v131 = 0;
      std::vector<float>::vector(&v132, v102, &v131);
      std::vector<std::vector<float>>::vector(&__A, v101, (uint64_t)&v132);
      std::vector<std::vector<std::vector<float>>>::assign((uint64_t)this + 600, v100, (uint64_t *)&__A);
      v158[0] = (void **)&__A;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v158);
      if (v132)
      {
        v133 = v132;
        operator delete(v132);
      }
      unint64_t v103 = *((unsigned int *)this + 110);
      unint64_t v104 = *((unsigned int *)this + 114);
      unint64_t v105 = *((unsigned int *)this + 143);
      int v131 = 0;
      std::vector<float>::vector(&v132, v105, &v131);
      std::vector<std::vector<float>>::vector(&__A, v104, (uint64_t)&v132);
      std::vector<std::vector<std::vector<float>>>::assign((uint64_t)this + 624, v103, (uint64_t *)&__A);
      v158[0] = (void **)&__A;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v158);
      if (v132)
      {
        v133 = v132;
        operator delete(v132);
      }
      unint64_t v106 = *((unsigned int *)this + 110);
      std::vector<DSPSplitComplex>::vector(&__A, *((unsigned int *)this + 114));
      std::vector<std::vector<DSPSplitComplex>>::resize((uint64_t *)this + 81, v106, (uint64_t)&__A);
      if (__A)
      {
        *(void *)&long long v139 = __A;
        operator delete(__A);
      }
      unint64_t v107 = *((unsigned int *)this + 110);
      unint64_t v108 = *((unsigned int *)this + 114);
      LODWORD(v132) = 0;
      std::vector<float>::vector(&__A, v108, &v132);
      std::vector<std::vector<float>>::assign((uint64_t *)this + 84, v107, (uint64_t)&__A);
      if (__A)
      {
        *(void *)&long long v139 = __A;
        operator delete(__A);
      }
      unint64_t v109 = *((unsigned int *)this + 143);
      LODWORD(__A) = 0;
      std::vector<float>::assign((char **)this + 90, v109, &__A);
      unint64_t v110 = *((unsigned int *)this + 143);
      LODWORD(__A) = 0;
      std::vector<float>::assign((char **)this + 93, v110, &__A);
      *((void *)this + 96) = *((void *)this + 90);
      *((void *)this + 97) = *((void *)this + 93);
      unint64_t v111 = *((unsigned int *)this + 110);
      unint64_t v112 = *((unsigned int *)this + 143);
      LODWORD(v132) = 0;
      std::vector<float>::vector(&__A, v112, &v132);
      std::vector<std::vector<float>>::assign((uint64_t *)this + 98, v111, (uint64_t)&__A);
      if (__A)
      {
        *(void *)&long long v139 = __A;
        operator delete(__A);
      }
      unint64_t v113 = *((unsigned int *)this + 110);
      unint64_t v114 = *((unsigned int *)this + 143);
      LODWORD(v132) = 0;
      std::vector<float>::vector(&__A, v114, &v132);
      std::vector<std::vector<float>>::assign((uint64_t *)this + 101, v113, (uint64_t)&__A);
      if (__A)
      {
        *(void *)&long long v139 = __A;
        operator delete(__A);
      }
      std::vector<DSPSplitComplex>::resize((uint64_t)this + 832, *((unsigned int *)this + 110));
      unsigned int v89 = (v83 & 1) + v83;
      unsigned int v88 = *((_DWORD *)this + 110);
      if (v88)
      {
        std::string v115 = (uint64_t *)*((void *)this + 98);
        CFDictionaryRef v116 = (uint64_t *)*((void *)this + 101);
        int v117 = (void *)(*((void *)this + 104) + 8);
        uint64_t v118 = *((unsigned int *)this + 110);
        do
        {
          uint64_t v119 = *v115;
          v115 += 3;
          *(v117 - 1) = v119;
          uint64_t v120 = *v116;
          v116 += 3;
          *int v117 = v120;
          v117 += 2;
          --v118;
        }
        while (v118);
      }
    }
    LODWORD(__A) = 0;
    std::vector<float>::assign(v150, v88, &__A);
    unint64_t v121 = *((unsigned int *)this + 110);
    LODWORD(v132) = 0;
    std::vector<float>::vector(&__A, v89, &v132);
    std::vector<std::vector<float>>::assign(v151, v121, (uint64_t)&__A);
    if (__A)
    {
      *(void *)&long long v139 = __A;
      operator delete(__A);
    }
    if (*((_DWORD *)this + 114))
    {
      float v122 = (float)(**(float **)(v130 + 128) * 180.0) / 3.14159265;
      float v123 = **(float **)(v130 + 152);
      IR::IRCoordinates::set((uint64_t)&v152, 0, v122);
      float v124 = (float)(v123 * 180.0) / 3.14159265;
      IR::IRCoordinates::set((uint64_t)&v152, 1u, v124);
      IR::IRCoordinates::set((uint64_t)&v152, 2u, 1.0);
      IR::IRCoordinates::set((uint64_t)&v152, 5u, (float)*((unsigned int *)this + 106));
      IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>();
    }
    LODWORD(__A) = 0;
    std::vector<float>::assign((char **)this + 87, 0, &__A);
    unint64_t v125 = (*((_DWORD *)this + 113) * *((_DWORD *)this + 114));
    LODWORD(__A) = 0;
    std::vector<float>::assign((char **)this + 68, v125, &__A);
    uint64_t v25 = 0;
  }
  else
  {
    if (IR::getHOA2BinauralIRRendererLog(void)::onceToken != -1) {
      dispatch_once(&IR::getHOA2BinauralIRRendererLog(void)::onceToken, &__block_literal_global_0);
    }
    int v90 = IR::getHOA2BinauralIRRendererLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getHOA2BinauralIRRendererLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::HOA2BinauralIRRenderer::setEnvironment(v90, v91, v92, v93, v94, v95, v96, v97);
    }
    uint64_t v25 = 4294956425;
  }
  if (v137) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v137);
  }
  __A = (float *)&v143;
  std::vector<IR::IRCoordinateTree>::__destroy_vector::operator()[abi:ne180100]((void ***)&__A);
  if (v141)
  {
    uint64_t v142 = v141;
    operator delete(v141);
  }
  if (v144)
  {
    unint64_t v145 = v144;
    operator delete(v144);
  }
  if (v147)
  {
    v148 = v147;
    operator delete(v147);
  }
  if (v150[0])
  {
    v150[1] = v150[0];
    operator delete(v150[0]);
  }
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = v151;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
LABEL_139:
  if (v157) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v157);
  }
  return v25;
}

void sub_21B501840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,std::__shared_weak_count *a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (__p) {
    operator delete(__p);
  }
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a24);
  }
  IR::IRCoordinateTree::~IRCoordinateTree((IR::IRCoordinateTree *)&a31);
  unint64_t v39 = *(void **)v36;
  if (*(void *)v36)
  {
    *(void *)(v36 + 8) = v39;
    operator delete(v39);
  }
  uint64_t v40 = *(void **)(v36 + 24);
  if (v40)
  {
    *(void *)(v36 + 32) = v40;
    operator delete(v40);
  }
  unsigned int v41 = *(void **)(v36 + 48);
  if (v41)
  {
    *(void *)(v36 + 56) = v41;
    operator delete(v41);
  }
  a31 = (void *)(v37 - 200);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a31);
  uint64_t v42 = *(std::__shared_weak_count **)(v36 + 152);
  if (v42) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v42);
  }
  _Unwind_Resume(a1);
}

void IR::HOA2BinauralIRRenderer::initialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  *(_DWORD *)(a1 + 424) = a7;
  operator new();
}

void sub_21B501B40(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v1, 0x10A0C40B42DDE52);
  _Unwind_Resume(a1);
}

void IR::HOA2BinauralIRRenderer::flattenIRCoordinateTree(IR::HOA2BinauralIRRenderer *this@<X0>, const IR::IRCoordinateTree *a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  IR::IRCoordinates::IRCoordinates((IR::IRCoordinates *)v8);
  v6[0] = v8[0];
  v6[1] = v8[1];
  int v7 = v9;
  IR::HOA2BinauralIRRenderer::extractSubNodesFromIRTree((uint64_t)this, a3, (uint64_t)a2, (uint64_t)v6, 1);
}

void sub_21B501BEC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::vector<float>>::assign(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  float v6 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a2)
  {
    unint64_t v13 = (a1[1] - (uint64_t)v6) / 24;
    if (v13 >= a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (a1[1] - (uint64_t)v6) / 24;
    }
    for (; v14; --v14)
    {
      if (v6 != (char *)a3) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v6, *(char **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      }
      v6 += 24;
    }
    if (a2 <= v13)
    {
      uint64_t v18 = a1[1];
      uint64_t v19 = *a1 + 24 * a2;
      if (v18 != v19)
      {
        uint64_t v20 = a1[1];
        do
        {
          uint64_t v22 = *(void **)(v20 - 24);
          v20 -= 24;
          uint64_t v21 = v22;
          if (v22)
          {
            *(void *)(v18 - 16) = v21;
            operator delete(v21);
          }
          uint64_t v18 = v20;
        }
        while (v20 != v19);
      }
      a1[1] = v19;
    }
    else
    {
      uint64_t v15 = (void *)a1[1];
      uint64_t v16 = &v15[3 * (a2 - v13)];
      uint64_t v17 = -24 * v13 + 24 * a2;
      do
      {
        *uint64_t v15 = 0;
        v15[1] = 0;
        v15[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
        v15 += 3;
        v17 -= 24;
      }
      while (v17);
      a1[1] = (uint64_t)v16;
    }
  }
  else
  {
    std::vector<std::vector<float>>::__vdeallocate(a1);
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v7 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v7 <= a2) {
      unint64_t v7 = a2;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
      unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v8 = v7;
    }
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, v8);
    int v9 = (void *)a1[1];
    uint64_t v10 = 3 * a2;
    uint64_t v11 = &v9[3 * a2];
    uint64_t v12 = 8 * v10;
    do
    {
      *int v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v9, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      v9 += 3;
      v12 -= 24;
    }
    while (v12);
    a1[1] = (uint64_t)v11;
  }
}

void sub_21B501DE0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<std::vector<float>>>::assign(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  float v6 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= a2)
  {
    unint64_t v13 = (*(void *)(a1 + 8) - (void)v6) / 24;
    if (v13 >= a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (*(void *)(a1 + 8) - (void)v6) / 24;
    }
    for (; v14; --v14)
    {
      if (v6 != (void **)a3) {
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((uint64_t)v6, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
      }
      v6 += 3;
    }
    if (a2 <= v13)
    {
      uint64_t v18 = *(void ***)(a1 + 8);
      uint64_t v19 = *(void *)a1 + 24 * a2;
      while (v18 != (void **)v19)
      {
        v18 -= 3;
        uint64_t v20 = v18;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v20);
      }
      *(void *)(a1 + 8) = v19;
    }
    else
    {
      uint64_t v15 = *(void **)(a1 + 8);
      uint64_t v16 = &v15[3 * (a2 - v13)];
      uint64_t v17 = -24 * v13 + 24 * a2;
      do
      {
        *uint64_t v15 = 0;
        v15[1] = 0;
        v15[2] = 0;
        std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v15, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
        v15 += 3;
        v17 -= 24;
      }
      while (v17);
      *(void *)(a1 + 8) = v16;
    }
  }
  else
  {
    std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a1);
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v7 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v7 <= a2) {
      unint64_t v7 = a2;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555) {
      unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v8 = v7;
    }
    std::vector<std::vector<float>>::__vallocate[abi:ne180100]((void *)a1, v8);
    int v9 = *(void **)(a1 + 8);
    uint64_t v10 = 3 * a2;
    uint64_t v11 = &v9[3 * a2];
    uint64_t v12 = 8 * v10;
    do
    {
      *int v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v9, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
      v9 += 3;
      v12 -= 24;
    }
    while (v12);
    *(void *)(a1 + 8) = v11;
  }
}

void sub_21B501FE4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<DSPSplitComplex>>::resize(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  BOOL v6 = a2 >= v5;
  unint64_t v7 = a2 - v5;
  if (v7 != 0 && v6)
  {
    std::vector<std::vector<DSPSplitComplex>>::__append(a1, v7, a3);
  }
  else if (!v6)
  {
    uint64_t v8 = *a1 + 24 * a2;
    if (v4 != v8)
    {
      uint64_t v9 = a1[1];
      do
      {
        uint64_t v11 = *(void **)(v9 - 24);
        v9 -= 24;
        uint64_t v10 = v11;
        if (v11)
        {
          *(void *)(v4 - 16) = v10;
          operator delete(v10);
        }
        uint64_t v4 = v9;
      }
      while (v9 != v8);
    }
    a1[1] = v8;
  }
}

void IR::HOA2BinauralIRRenderer::process(uint64_t a1, void **a2, int a3, unsigned int a4, uint64_t a5, float a6, float a7, float a8)
{
  LODWORD(v12) = a3;
  uint64_t v15 = *(void *)a1;
  uint64_t v16 = *(void *)(a1 + 8);
  if (*(void *)a1 != v16)
  {
    while (!IR::IRCoordinates::operator==(v15, a5))
    {
      v15 += 36;
      if (v15 == v16)
      {
        uint64_t v15 = v16;
        break;
      }
    }
  }
  if (*(_DWORD *)(a1 + 440) == v12 && *(_DWORD *)(a1 + 448) == a4 && v15 != *(void *)(a1 + 8))
  {
    unsigned int v18 = 954437177 * ((unint64_t)(v15 - *(void *)a1) >> 2);
    HOA::RotationMatrix::setRotationMatrixYPR(*(float ***)(a1 + 512), a6, a7, a8);
    HOA::RotationMatrix::toRegularMatrix(*(void *)(a1 + 512), *(char **)(a1 + 520), (uint64_t)(*(void *)(a1 + 528) - *(void *)(a1 + 520)) >> 2, 0);
    vDSP_mmul(*(const float **)(a1 + 488), 1, *(const float **)(a1 + 520), 1, *(float **)(a1 + 544), 1, *(unsigned int *)(a1 + 456), *(unsigned int *)(a1 + 452), *(unsigned int *)(a1 + 452));
    vDSP_mmul(*(const float **)(a1 + 544), 1, *(const float **)(*(void *)(a1 + 464) + 24 * v18), 1, *(float **)(a1 + 696), 1, *(unsigned int *)(a1 + 456), *(unsigned int *)(a1 + 444), *(unsigned int *)(a1 + 452));
    LODWORD(v19) = *(_DWORD *)(a1 + 440);
    if (*(unsigned char *)(a1 + 460))
    {
      if (v19)
      {
        uint64_t v20 = 0;
        unint64_t v21 = 0;
        do
        {
          bzero(*(void **)(*(void *)(a1 + 784) + v20), 4 * *(unsigned int *)(a1 + 572));
          bzero(*(void **)(*(void *)(a1 + 808) + v20), 4 * *(unsigned int *)(a1 + 572));
          ++v21;
          uint64_t v19 = (float *)*(unsigned int *)(a1 + 440);
          v20 += 24;
        }
        while (v21 < (unint64_t)v19);
      }
      if (*(_DWORD *)(a1 + 456))
      {
        unint64_t v22 = 0;
        do
        {
          bzero(*(void **)(a1 + 720), 4 * *(unsigned int *)(a1 + 572));
          bzero(*(void **)(a1 + 744), 4 * *(unsigned int *)(a1 + 572));
          vDSP_ctoz((const DSPComplex *)(*(void *)(a1 + 696) + 4 * (*(_DWORD *)(a1 + 444) * v22)), 2, (const DSPSplitComplex *)(a1 + 768), 1, (unint64_t)*(unsigned int *)(a1 + 444) >> 1);
          vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 584), *(const float **)(a1 + 720), *(const float **)(a1 + 744), *(float **)(a1 + 720), *(float **)(a1 + 744));
          uint64_t v19 = *(float **)(a1 + 744);
          float v23 = *v19;
          *uint64_t v19 = 0.0;
          LODWORD(v19) = *(_DWORD *)(a1 + 440);
          if (v19)
          {
            uint64_t v24 = 0;
            uint64_t v25 = 0;
            unint64_t v26 = 0;
            do
            {
              vDSP_zvma((const DSPSplitComplex *)(a1 + 768), 1, (const DSPSplitComplex *)(*(void *)(*(void *)(a1 + 648) + v25) + 16 * v22), 1, (const DSPSplitComplex *)(*(void *)(a1 + 832) + v24), 1, (const DSPSplitComplex *)(*(void *)(a1 + 832) + v24), 1, *(unsigned int *)(a1 + 572));
              **(float **)(*(void *)(a1 + 808) + v25) = **(float **)(*(void *)(a1 + 808) + v25)
                                                        + (float)(v23
                                                                * *(float *)(*(void *)(*(void *)(a1 + 672) + v25)
                                                                           + 4 * v22));
              ++v26;
              uint64_t v19 = (float *)*(unsigned int *)(a1 + 440);
              v25 += 24;
              v24 += 16;
            }
            while (v26 < (unint64_t)v19);
          }
          ++v22;
        }
        while (v22 < *(unsigned int *)(a1 + 456));
      }
      if (v19)
      {
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        unint64_t v29 = 0;
        do
        {
          vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 592), *(const float **)(*(void *)(a1 + 784) + v28), *(const float **)(*(void *)(a1 + 808) + v28), *(float **)(*(void *)(a1 + 784) + v28), *(float **)(*(void *)(a1 + 808) + v28));
          vDSP_ztoc((const DSPSplitComplex *)(*(void *)(a1 + 832) + v27), 1, (DSPComplex *)a2[v29], 2, (unint64_t)*(unsigned int *)(a1 + 448) >> 1);
          vDSP_vsmul((const float *)a2[v29], 1, (const float *)(a1 + 576), (float *)a2[v29], 1, *(unsigned int *)(a1 + 448));
          ++v29;
          v28 += 24;
          v27 += 16;
        }
        while (v29 < *(unsigned int *)(a1 + 440));
      }
    }
    else if (v19)
    {
      uint64_t v31 = 0;
      unint64_t v32 = 0;
      do
      {
        vDSP_mmul(*(const float **)(*(void *)(a1 + 784) + v31), 1, *(const float **)(a1 + 696), 1, (float *)a2[v32++], 1, 1uLL, *(unsigned int *)(a1 + 444), *(unsigned int *)(a1 + 456));
        v31 += 24;
      }
      while (v32 < *(unsigned int *)(a1 + 440));
    }
  }
  else if (v12)
  {
    uint64_t v12 = v12;
    do
    {
      unint64_t v30 = *a2++;
      bzero(v30, 4 * a4);
      --v12;
    }
    while (v12);
  }
}

void IR::HOA2BinauralIRRenderer::extractSubNodesFromIRTree(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  if (*(void *)(a3 + 16) != *(void *)(a3 + 8))
  {
    uint64_t v10 = 0;
    unsigned int v11 = 0;
    uint64_t v12 = a2 + 2;
    do
    {
      if (a5) {
        IR::IRCoordinates::reset((IR::IRCoordinates *)a4);
      }
      uint64_t v14 = *(_DWORD **)(a1 + 24);
      unint64_t v13 = *(_DWORD **)(a1 + 32);
      if (v14 != v13)
      {
        while (*v14 != *(_DWORD *)a3)
        {
          if (++v14 == v13)
          {
            uint64_t v14 = *(_DWORD **)(a1 + 32);
            break;
          }
        }
      }
      if (v14 != v13) {
        IR::IRCoordinates::set(a4, *(_DWORD *)a3, *(float *)(*(void *)(a3 + 8) + 4 * v10));
      }
      uint64_t v15 = *(void *)(a3 + 32);
      if (v15 == *(void *)(a3 + 40))
      {
        unint64_t v17 = *a2;
        unint64_t v18 = a2[1];
        if (*a2 == v18)
        {
          unint64_t v19 = *a2;
          unint64_t v20 = *a2;
        }
        else
        {
          while (!IR::IRCoordinates::operator==(v17, a4))
          {
            v17 += 36;
            if (v17 == v18)
            {
              unint64_t v17 = v18;
              break;
            }
          }
          unint64_t v19 = a2[1];
          unint64_t v20 = v17;
          unint64_t v17 = v19;
        }
        if (v20 == v17)
        {
          if (v17 >= *v12)
          {
            unint64_t v24 = 0x8E38E38E38E38E39 * ((uint64_t)(v19 - *a2) >> 2);
            unint64_t v25 = v24 + 1;
            if (v24 + 1 > 0x71C71C71C71C71CLL) {
              std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
            }
            if (0x1C71C71C71C71C72 * ((uint64_t)(*v12 - *a2) >> 2) > v25) {
              unint64_t v25 = 0x1C71C71C71C71C72 * ((uint64_t)(*v12 - *a2) >> 2);
            }
            if (0x8E38E38E38E38E39 * ((uint64_t)(*v12 - *a2) >> 2) >= 0x38E38E38E38E38ELL) {
              unint64_t v26 = 0x71C71C71C71C71CLL;
            }
            else {
              unint64_t v26 = v25;
            }
            if (v26) {
              uint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinates>>((uint64_t)v12, v26);
            }
            else {
              uint64_t v27 = 0;
            }
            uint64_t v28 = &v27[36 * v24];
            long long v29 = *(_OWORD *)a4;
            long long v30 = *(_OWORD *)(a4 + 16);
            *((_DWORD *)v28 + 8) = *(_DWORD *)(a4 + 32);
            *(_OWORD *)uint64_t v28 = v29;
            *((_OWORD *)v28 + 1) = v30;
            unint64_t v32 = (char *)*a2;
            uint64_t v31 = (char *)a2[1];
            unint64_t v33 = (unint64_t)v28;
            if (v31 != (char *)*a2)
            {
              do
              {
                long long v34 = *(_OWORD *)(v31 - 36);
                long long v35 = *(_OWORD *)(v31 - 20);
                *(_DWORD *)(v33 - 4) = *((_DWORD *)v31 - 1);
                *(_OWORD *)(v33 - 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v35;
                *(_OWORD *)(v33 - 36) = v34;
                v33 -= 36;
                v31 -= 36;
              }
              while (v31 != v32);
              uint64_t v31 = (char *)*a2;
            }
            unint64_t v23 = (unint64_t)(v28 + 36);
            *a2 = v33;
            a2[1] = (unint64_t)(v28 + 36);
            a2[2] = (unint64_t)&v27[36 * v26];
            if (v31) {
              operator delete(v31);
            }
          }
          else
          {
            long long v21 = *(_OWORD *)a4;
            long long v22 = *(_OWORD *)(a4 + 16);
            *(_DWORD *)(v17 + 32) = *(_DWORD *)(a4 + 32);
            *(_OWORD *)unint64_t v17 = v21;
            *(_OWORD *)(v17 + 16) = v22;
            unint64_t v23 = v17 + 36;
          }
          a2[1] = v23;
        }
      }
      else
      {
        long long v16 = *(_OWORD *)(a4 + 16);
        v36[0] = *(_OWORD *)a4;
        v36[1] = v16;
        int v37 = *(_DWORD *)(a4 + 32);
        IR::HOA2BinauralIRRenderer::extractSubNodesFromIRTree(a1, a2, v15 + 56 * v10, v36, 0);
      }
      uint64_t v10 = ++v11;
    }
    while (v11 < (unint64_t)((uint64_t)(*(void *)(a3 + 16) - *(void *)(a3 + 8)) >> 2));
  }
}

uint64_t IR::HOA2BinauralIRRenderer::getOutputLength(IR::HOA2BinauralIRRenderer *this)
{
  return *((unsigned int *)this + 112);
}

void *IR::HOA2BinauralIRRenderer::getRefHOAIRCoordinates@<X0>(IR::HOA2BinauralIRRenderer *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<IR::IRCoordinates>::__init_with_size[abi:ne180100]<IR::IRCoordinates*,IR::IRCoordinates*>(a2, *(const void **)this, *((void *)this + 1), 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 2));
}

void *IR::HOA2BinauralIRRenderer::getVariableDimensionsInRefHOAIR@<X0>(IR::HOA2BinauralIRRenderer *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<IR::IRCoordinateType>::__init_with_size[abi:ne180100]<IR::IRCoordinateType*,IR::IRCoordinateType*>(a2, *((const void **)this + 6), *((void *)this + 7), (uint64_t)(*((void *)this + 7) - *((void *)this + 6)) >> 2);
}

void *IR::HOA2BinauralIRRenderer::getInterpolationMethodForVariableDimensionsInRefHOAIR@<X0>(IR::HOA2BinauralIRRenderer *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<IR::IRInterpolationMethod>::__init_with_size[abi:ne180100]<IR::IRInterpolationMethod*,IR::IRInterpolationMethod*>(a2, *((const void **)this + 12), *((void *)this + 13), (uint64_t)(*((void *)this + 13) - *((void *)this + 12)) >> 2);
}

void *IR::HOA2BinauralIRRenderer::getPeriodForVariableDimensionsInRefHOAIR@<X0>(IR::HOA2BinauralIRRenderer *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a2, *((const void **)this + 9), *((void *)this + 10), (uint64_t)(*((void *)this + 10) - *((void *)this + 9)) >> 2);
}

void std::vector<std::vector<float>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<std::vector<float>>>::__vdeallocate(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        unint64_t v5 = v3;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(char **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    std::vector<std::vector<float>>::__vdeallocate((uint64_t *)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::vector<float>>::__vallocate[abi:ne180100]((void *)a1, v11);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v8, a2, a3, *(void **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    uint64_t v13 = a2 + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>((int)&v20, a2, v13, v9);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v8, v13, a3, *(void **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>((int)&v21, a2, a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    uint64_t v17 = *(void *)(a1 + 8);
    do
    {
      unint64_t v19 = *(void **)(v17 - 24);
      v17 -= 24;
      unint64_t v18 = v19;
      if (v19)
      {
        *(void *)(v16 - 16) = v18;
        operator delete(v18);
      }
      uint64_t v16 = v17;
    }
    while (v17 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_21B5029A0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_21B5029A8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<DSPSplitComplex>>::__append(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v8 = a1[2];
  os_log_t result = a1 + 2;
  uint64_t v7 = v8;
  uint64_t v9 = (void *)*(result - 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)v9) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v15 = &v9[3 * a2];
      uint64_t v16 = 24 * a2;
      do
      {
        *uint64_t v9 = 0;
        v9[1] = 0;
        v9[2] = 0;
        os_log_t result = std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(v9, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
        v9 += 3;
        v16 -= 24;
      }
      while (v16);
      uint64_t v9 = v15;
    }
    a1[1] = (uint64_t)v9;
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - *a1) >> 3);
    unint64_t v11 = v10 + a2;
    if (v10 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    char v21 = result;
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)result, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v17 = v14;
    unint64_t v18 = &v14[24 * v10];
    unint64_t v19 = v18;
    char v20 = &v14[24 * v13];
    std::__split_buffer<std::vector<DSPSplitComplex>>::__construct_at_end(&v17, a2, a3);
    std::vector<std::vector<DSPSplitComplex>>::__swap_out_circular_buffer(a1, &v17);
    return (void *)std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)&v17);
  }
  return result;
}

void sub_21B502B04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__split_buffer<std::vector<DSPSplitComplex>>::__construct_at_end(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = (void *)result[2];
  if (a2)
  {
    BOOL v6 = &v4[3 * a2];
    uint64_t v7 = 24 * a2;
    do
    {
      *uint64_t v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      os_log_t result = std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(v4, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
      v4 += 3;
      v7 -= 24;
    }
    while (v7);
    uint64_t v4 = v6;
  }
  v3[2] = v4;
  return result;
}

void sub_21B502BA0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

void *std::vector<DSPSplitComplex>::__init_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    os_log_t result = std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      os_log_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B502C08(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<DSPSplitComplex>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 16 * a2);
    a1[1] = &v4[16 * a2];
  }
  return a1;
}

void sub_21B502C80(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<IR::IRCoordinates>::__init_with_size[abi:ne180100]<IR::IRCoordinates*,IR::IRCoordinates*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    os_log_t result = std::vector<IR::IRCoordinates>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      os_log_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B502CFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<IR::IRCoordinates>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x71C71C71C71C71DLL) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  os_log_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IR::IRCoordinates>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[36 * v4];
  return result;
}

void std::default_delete<HOA::RotationMatrix>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void **)(a2 + 24);
    if (v3)
    {
      *(void *)(a2 + 32) = v3;
      operator delete(v3);
    }
    uint64_t v4 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v4;
      operator delete(v4);
    }
    JUMPOUT(0x21D48F780);
  }
}

void IR::IRData::getTriangulationData(IR::IRData::Implementation **this@<X0>, CFDictionaryRef *a2@<X8>)
{
}

void IR::IRData::Implementation::getTriangulationData(IR::IRData::Implementation *this@<X0>, CFDictionaryRef *a2@<X8>)
{
  uint64_t v135 = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 63);
  if (v3 == *((void *)this + 64))
  {
    v130.__begin_ = 0;
    v130.__end_ = 0;
    *a2 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v130);
  }
  else
  {
    uint64_t v4 = this;
    unint64_t v104 = a2;
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    uint64_t v127 = 0;
    uint64_t v128 = 0;
    uint64_t v129 = 0;
    long long v125 = 0uLL;
    v126[0] = 0;
    long long v123 = 0uLL;
    v124[0] = 0;
    long long v121 = 0uLL;
    v122[0] = 0;
    memset(&v120, 0, sizeof(v120));
    do
    {
      uint64_t v7 = v127;
      uint64_t v107 = 16 * v5;
      uint64_t v8 = *(void *)(v3 + 16 * v5);
      if (v127 != v128)
      {
        while (*v7 != *(void *)v8)
        {
          v7 += 2;
          if (v7 == v128)
          {
            uint64_t v7 = v128;
            break;
          }
        }
      }
      if (v7 == v128)
      {
        std::vector<std::shared_ptr<VBAP>>::push_back[abi:ne180100]((uint64_t *)&v127, (long long *)v8);
        uint64_t v9 = **(void **)(*((void *)v4 + 63) + v107);
        uint64_t v118 = 0;
        uint64_t v119 = 0;
        *(void *)__x = 0;
        std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(__x, *(const void **)(v9 + 224), *(void *)(v9 + 232), (uint64_t)(*(void *)(v9 + 232) - *(void *)(v9 + 224)) >> 2);
        memset(&v116, 0, sizeof(v116));
        std::vector<IR::IRDataType>::reserve(&v116, (v118 - *(void *)__x) >> 2);
        unint64_t v10 = *(_DWORD **)__x;
        std::vector<unsigned int>::pointer end = v116.__end_;
        if (v118 == *(void *)__x)
        {
          uint64_t v15 = v116.__end_;
        }
        else
        {
          uint64_t v12 = 0;
          unsigned int v13 = 0;
          do
          {
            unsigned int v14 = bswap32(v10[v12]);
            if (end >= v116.__end_cap_.__value_)
            {
              std::vector<unsigned int>::pointer begin = v116.__begin_;
              uint64_t v17 = end - v116.__begin_;
              unint64_t v18 = v17 + 1;
              if ((unint64_t)(v17 + 1) >> 62) {
                std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
              }
              int64_t v19 = (char *)v116.__end_cap_.__value_ - (char *)v116.__begin_;
              if (((char *)v116.__end_cap_.__value_ - (char *)v116.__begin_) >> 1 > v18) {
                unint64_t v18 = v19 >> 1;
              }
              if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v20 = v18;
              }
              if (v20)
              {
                char v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v116.__end_cap_, v20);
                std::vector<unsigned int>::pointer begin = v116.__begin_;
                std::vector<unsigned int>::pointer end = v116.__end_;
              }
              else
              {
                char v21 = 0;
              }
              long long v22 = (unsigned int *)&v21[4 * v17];
              *long long v22 = v14;
              uint64_t v15 = v22 + 1;
              while (end != begin)
              {
                unsigned int v23 = *--end;
                *--long long v22 = v23;
              }
              v116.__begin_ = v22;
              v116.__end_ = v15;
              v116.__end_cap_.__value_ = (unsigned int *)&v21[4 * v20];
              if (begin) {
                operator delete(begin);
              }
            }
            else
            {
              *std::vector<unsigned int>::pointer end = v14;
              uint64_t v15 = end + 1;
            }
            v116.__end_ = v15;
            unint64_t v10 = *(_DWORD **)__x;
            std::vector<unsigned int>::pointer end = v15;
            uint64_t v12 = ++v13;
          }
          while (v13 < (unint64_t)((v118 - *(void *)__x) >> 2));
        }
        CFDataRef v24 = CFDataCreate(0, (const UInt8 *)v116.__begin_, (char *)v15 - (char *)v116.__begin_);
        if (!v24)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x21D48F410](exception, "Could not construct");
        }
        applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, v24);
        unint64_t v25 = (void *)*((void *)&v125 + 1);
        unsigned int v106 = v6;
        if (*((void *)&v125 + 1) >= v126[0])
        {
          unint64_t v26 = (void *)v125;
          uint64_t v27 = (uint64_t)(*((void *)&v125 + 1) - v125) >> 3;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 61) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v29 = v126[0] - v125;
          if ((uint64_t)(v126[0] - v125) >> 2 > v28) {
            unint64_t v28 = v29 >> 2;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v28;
          }
          v132 = v126;
          if (v30)
          {
            uint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>((uint64_t)v126, v30);
            unint64_t v25 = (void *)*((void *)&v125 + 1);
            unint64_t v26 = (void *)v125;
          }
          else
          {
            uint64_t v31 = 0;
          }
          unint64_t v32 = &v31[8 * v27];
          unint64_t v33 = &v31[8 * v30];
          int v131 = v33;
          *(void *)unint64_t v32 = cf;
          uint64_t value = (unsigned int *)(v32 + 8);
          CFTypeRef cf = 0;
          v130.__end_cap_.__value_ = (unsigned int *)(v32 + 8);
          if (v25 != v26)
          {
            do
            {
              uint64_t v35 = *--v25;
              *((void *)v32 - 1) = v35;
              v32 -= 8;
              *unint64_t v25 = 0;
            }
            while (v25 != v26);
            uint64_t value = v130.__end_cap_.__value_;
            unint64_t v33 = v131;
          }
          long long v36 = v125;
          *(void *)&long long v125 = v32;
          *((void *)&v125 + 1) = value;
          *(_OWORD *)&v130.__end_ = v36;
          int v37 = (char *)v126[0];
          v126[0] = v33;
          int v131 = v37;
          v130.__begin_ = (std::vector<unsigned int>::pointer)v36;
          std::__split_buffer<applesauce::CF::DataRef>::~__split_buffer((uint64_t)&v130);
          *((void *)&v125 + 1) = value;
          if (cf) {
            CFRelease(cf);
          }
        }
        else
        {
          **((void **)&v125 + 1) = cf;
          *((void *)&v125 + 1) = v25 + 1;
        }
        uint64_t v38 = **(void **)(*((void *)this + 63) + v107);
        unint64_t v114 = 0;
        uint64_t v115 = 0;
        CFTypeRef cf = 0;
        std::vector<std::list<int>>::__init_with_size[abi:ne180100]<std::list<int>*,std::list<int>*>(&cf, *(void *)(v38 + 272), *(void *)(v38 + 280), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v38 + 280) - *(void *)(v38 + 272)) >> 3));
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
        unint64_t v111 = 0;
        unint64_t v112 = 0;
        memset(&v109, 0, sizeof(v109));
        std::vector<IR::IRDataType>::reserve(&v109, 0xAAAAAAAAAAAAAAABLL * ((v114 - (unsigned char *)cf) >> 3));
        unint64_t v39 = cf;
        if (v114 != cf)
        {
          uint64_t v40 = 0;
          unsigned int v41 = 0;
          do
          {
            uint64_t v42 = (char *)&v39[6 * v40];
            uint64_t v43 = *((void *)v42 + 1);
            if ((char *)v43 != v42)
            {
              unint64_t v44 = v111;
              do
              {
                unsigned int v45 = bswap32(*(_DWORD *)(v43 + 16));
                if (v44 >= v112)
                {
                  float v47 = (unsigned int *)__p;
                  uint64_t v48 = ((char *)v44 - (unsigned char *)__p) >> 2;
                  unint64_t v49 = v48 + 1;
                  if ((unint64_t)(v48 + 1) >> 62) {
                    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v50 = (char *)v112 - (unsigned char *)__p;
                  if (((char *)v112 - (unsigned char *)__p) >> 1 > v49) {
                    unint64_t v49 = v50 >> 1;
                  }
                  if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFFCLL) {
                    unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v51 = v49;
                  }
                  if (v51)
                  {
                    int v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v112, v51);
                    float v47 = (unsigned int *)__p;
                    unint64_t v44 = v111;
                  }
                  else
                  {
                    int v52 = 0;
                  }
                  int v53 = (unsigned int *)&v52[4 * v48];
                  *int v53 = v45;
                  unint64_t v46 = v53 + 1;
                  while (v44 != v47)
                  {
                    unsigned int v54 = *--v44;
                    *--int v53 = v54;
                  }
                  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = v53;
                  unint64_t v111 = v46;
                  unint64_t v112 = (unsigned int *)&v52[4 * v51];
                  if (v47) {
                    operator delete(v47);
                  }
                }
                else
                {
                  *unint64_t v44 = v45;
                  unint64_t v46 = v44 + 1;
                }
                unint64_t v111 = v46;
                uint64_t v43 = *(void *)(v43 + 8);
                unint64_t v44 = v46;
              }
              while ((char *)v43 != v42);
              unint64_t v39 = cf;
            }
            unsigned int v55 = bswap32(v39[6 * v40 + 4]);
            std::vector<unsigned int>::pointer v56 = v109.__end_;
            if (v109.__end_ >= v109.__end_cap_.__value_)
            {
              std::vector<unsigned int>::pointer v58 = v109.__begin_;
              int64_t v59 = v109.__end_ - v109.__begin_;
              unint64_t v60 = v59 + 1;
              if ((unint64_t)(v59 + 1) >> 62) {
                std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
              }
              int64_t v61 = (char *)v109.__end_cap_.__value_ - (char *)v109.__begin_;
              if (((char *)v109.__end_cap_.__value_ - (char *)v109.__begin_) >> 1 > v60) {
                unint64_t v60 = v61 >> 1;
              }
              if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v62 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v62 = v60;
              }
              if (v62)
              {
                unint64_t v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v109.__end_cap_, v62);
                std::vector<unsigned int>::pointer v58 = v109.__begin_;
                std::vector<unsigned int>::pointer v56 = v109.__end_;
              }
              else
              {
                unint64_t v63 = 0;
              }
              int v64 = (unsigned int *)&v63[4 * v59];
              unsigned int *v64 = v55;
              uint64_t v57 = v64 + 1;
              while (v56 != v58)
              {
                unsigned int v65 = *--v56;
                *--int v64 = v65;
              }
              v109.__begin_ = v64;
              v109.__end_ = v57;
              v109.__end_cap_.__value_ = (unsigned int *)&v63[4 * v62];
              if (v58) {
                operator delete(v58);
              }
            }
            else
            {
              *v109.__end_ = v55;
              uint64_t v57 = v56 + 1;
            }
            v109.__end_ = v57;
            unint64_t v39 = cf;
            uint64_t v40 = ++v41;
          }
          while (0xAAAAAAAAAAAAAAABLL * ((v114 - (unsigned char *)cf) >> 3) > v41);
        }
        CFDataRef v66 = CFDataCreate(0, (const UInt8 *)__p, (char *)v111 - (unsigned char *)__p);
        unsigned int v6 = v106;
        if (!v66)
        {
          unint64_t v101 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x21D48F410](v101, "Could not construct");
        }
        applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v108, v66);
        uint64_t v67 = (void *)*((void *)&v123 + 1);
        if (*((void *)&v123 + 1) >= v124[0])
        {
          unint64_t v68 = (void *)v123;
          uint64_t v69 = (uint64_t)(*((void *)&v123 + 1) - v123) >> 3;
          unint64_t v70 = v69 + 1;
          if ((unint64_t)(v69 + 1) >> 61) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v71 = v124[0] - v123;
          if ((uint64_t)(v124[0] - v123) >> 2 > v70) {
            unint64_t v70 = v71 >> 2;
          }
          if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v72 = v70;
          }
          v132 = v124;
          uint64_t v4 = this;
          if (v72)
          {
            int v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>((uint64_t)v124, v72);
            uint64_t v67 = (void *)*((void *)&v123 + 1);
            unint64_t v68 = (void *)v123;
          }
          else
          {
            int v73 = 0;
          }
          int v74 = &v73[8 * v69];
          int v75 = &v73[8 * v72];
          int v131 = v75;
          *(void *)int v74 = v108;
          unint64_t v76 = (unsigned int *)(v74 + 8);
          CFTypeRef v108 = 0;
          v130.__end_cap_.__value_ = (unsigned int *)(v74 + 8);
          if (v67 != v68)
          {
            do
            {
              uint64_t v77 = *--v67;
              *((void *)v74 - 1) = v77;
              v74 -= 8;
              *uint64_t v67 = 0;
            }
            while (v67 != v68);
            unint64_t v76 = v130.__end_cap_.__value_;
            int v75 = v131;
          }
          long long v78 = v123;
          *(void *)&long long v123 = v74;
          *((void *)&v123 + 1) = v76;
          *(_OWORD *)&v130.__end_ = v78;
          uint64_t v79 = (char *)v124[0];
          v124[0] = v75;
          int v131 = v79;
          v130.__begin_ = (std::vector<unsigned int>::pointer)v78;
          std::__split_buffer<applesauce::CF::DataRef>::~__split_buffer((uint64_t)&v130);
          *((void *)&v123 + 1) = v76;
          unsigned int v6 = v106;
          if (v108) {
            CFRelease(v108);
          }
        }
        else
        {
          **((void **)&v123 + 1) = v108;
          *((void *)&v123 + 1) = v67 + 1;
          uint64_t v4 = this;
        }
        CFDataRef v80 = CFDataCreate(0, (const UInt8 *)v109.__begin_, (char *)v109.__end_ - (char *)v109.__begin_);
        if (!v80)
        {
          unint64_t v102 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x21D48F410](v102, "Could not construct");
        }
        applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v108, v80);
        CFIndex v81 = (void *)*((void *)&v121 + 1);
        if (*((void *)&v121 + 1) >= v122[0])
        {
          uint64_t v82 = (void *)v121;
          uint64_t v83 = (uint64_t)(*((void *)&v121 + 1) - v121) >> 3;
          unint64_t v84 = v83 + 1;
          if ((unint64_t)(v83 + 1) >> 61) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v85 = v122[0] - v121;
          if ((uint64_t)(v122[0] - v121) >> 2 > v84) {
            unint64_t v84 = v85 >> 2;
          }
          if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v86 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v86 = v84;
          }
          v132 = v122;
          if (v86)
          {
            unint64_t v87 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>((uint64_t)v122, v86);
            CFIndex v81 = (void *)*((void *)&v121 + 1);
            uint64_t v82 = (void *)v121;
          }
          else
          {
            unint64_t v87 = 0;
          }
          unsigned int v88 = &v87[8 * v83];
          unsigned int v89 = &v87[8 * v86];
          int v131 = v89;
          *(void *)unsigned int v88 = v108;
          int v90 = (unsigned int *)(v88 + 8);
          CFTypeRef v108 = 0;
          v130.__end_cap_.__value_ = (unsigned int *)(v88 + 8);
          if (v81 != v82)
          {
            do
            {
              uint64_t v91 = *--v81;
              *((void *)v88 - 1) = v91;
              v88 -= 8;
              void *v81 = 0;
            }
            while (v81 != v82);
            int v90 = v130.__end_cap_.__value_;
            unsigned int v89 = v131;
          }
          long long v92 = v121;
          *(void *)&long long v121 = v88;
          *((void *)&v121 + 1) = v90;
          *(_OWORD *)&v130.__end_ = v92;
          uint64_t v93 = (char *)v122[0];
          v122[0] = v89;
          int v131 = v93;
          v130.__begin_ = (std::vector<unsigned int>::pointer)v92;
          std::__split_buffer<applesauce::CF::DataRef>::~__split_buffer((uint64_t)&v130);
          *((void *)&v121 + 1) = v90;
          unsigned int v6 = v106;
          if (v108) {
            CFRelease(v108);
          }
        }
        else
        {
          **((void **)&v121 + 1) = v108;
          *((void *)&v121 + 1) = v81 + 1;
        }
        if (v109.__begin_)
        {
          v109.__end_ = v109.__begin_;
          operator delete(v109.__begin_);
        }
        if (__p)
        {
          unint64_t v111 = (unsigned int *)__p;
          operator delete(__p);
        }
        v130.__begin_ = (std::vector<unsigned int>::pointer)&cf;
        std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v130);
        if (v116.__begin_)
        {
          v116.__end_ = v116.__begin_;
          operator delete(v116.__begin_);
        }
        if (*(void *)__x)
        {
          uint64_t v118 = *(void *)__x;
          operator delete(*(void **)__x);
        }
        uint64_t v8 = *(void *)(*((void *)v4 + 63) + v107);
      }
      unsigned int v94 = bswap32(*(_DWORD *)(v8 + 136));
      std::vector<unsigned int>::size_type v95 = ((((uint64_t)(*(void *)(*(void *)v8 + 232) - *(void *)(*(void *)v8 + 224)) >> 2)
                          / 3uLL)
           + 4) >> 1;
      __x[0] = v94;
      std::vector<unsigned int>::vector(&v130, v95, __x);
      std::vector<unsigned int>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(&v120, (uint64_t)v120.__end_, (char *)v130.__begin_, (char *)v130.__end_, v130.__end_ - v130.__begin_);
      if (v130.__begin_)
      {
        v130.__end_ = v130.__begin_;
        operator delete(v130.__begin_);
      }
      uint64_t v3 = *((void *)v4 + 63);
      uint64_t v5 = ++v6;
    }
    while (v6 < (unint64_t)((*((void *)v4 + 64) - v3) >> 4));
    LODWORD(v108) = (unint64_t)((char *)v128 - (char *)v127) >> 4;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],unsigned int>((applesauce::CF::TypeRef *)&v130, "NumTriangulations", (int *)&v108);
    CFDataRef v96 = CFDataCreate(0, (const UInt8 *)v120.__begin_, (char *)v120.__end_ - (char *)v120.__begin_);
    if (!v96)
    {
      unint64_t v103 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v103, "Could not construct");
    }
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v116, v96);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[14],applesauce::CF::DataRef>((applesauce::CF::TypeRef *)&v130.__end_cap_, "TriAssignment", (const void **)&v116.__begin_);
    CFTypeRef cf = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DataRef>((uint64_t **)&v125);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],applesauce::CF::ArrayRef>((applesauce::CF::TypeRef *)&v132, "TriVertices", &cf);
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DataRef>((uint64_t **)&v123);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::ArrayRef>((applesauce::CF::TypeRef *)&v133, "TriBinSerial", (const void **)&__p);
    v109.__begin_ = (std::vector<unsigned int>::pointer)applesauce::CF::details::make_CFArrayRef<applesauce::CF::DataRef>((uint64_t **)&v121);
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[14],applesauce::CF::ArrayRef>((applesauce::CF::TypeRef *)v134, "TriBinLengths", (const void **)&v109.__begin_);
    *(void *)__x = &v130;
    uint64_t v118 = 5;
    uint64_t v97 = 0;
    CFDictionaryRef *v104 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)__x);
    do
    {
      char v98 = *(const void **)&v134[v97 + 8];
      if (v98) {
        CFRelease(v98);
      }
      float v99 = *(const void **)&v134[v97];
      if (v99) {
        CFRelease(v99);
      }
      v97 -= 16;
    }
    while (v97 != -80);
    if (v109.__begin_) {
      CFRelease(v109.__begin_);
    }
    if (__p) {
      CFRelease(__p);
    }
    if (cf) {
      CFRelease(cf);
    }
    if (v116.__begin_) {
      CFRelease(v116.__begin_);
    }
    if (v120.__begin_)
    {
      v120.__end_ = v120.__begin_;
      operator delete(v120.__begin_);
    }
    v130.__begin_ = (std::vector<unsigned int>::pointer)&v121;
    std::vector<applesauce::CF::DataRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v130);
    v130.__begin_ = (std::vector<unsigned int>::pointer)&v123;
    std::vector<applesauce::CF::DataRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v130);
    v130.__begin_ = (std::vector<unsigned int>::pointer)&v125;
    std::vector<applesauce::CF::DataRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v130);
    v130.__begin_ = (std::vector<unsigned int>::pointer)&v127;
    std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v130);
  }
}

void sub_21B503960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t **__p,uint64_t **a35,uint64_t a36,uint64_t *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  __cxa_free_exception(v42);
  if ((applesauce::CF::TypeRefPair *)(v43 - 184) != v41)
  {
    do
    {
      unsigned int v41 = (applesauce::CF::TypeRefPair *)((char *)v41 - 16);
      applesauce::CF::TypeRefPair::~TypeRefPair(v41);
    }
    while (v41 != (applesauce::CF::TypeRefPair *)(v43 - 184));
  }
  if (__p)
  {
    a35 = __p;
    operator delete(__p);
  }
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = &a37;
  std::vector<applesauce::CF::DataRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  a37 = &a41;
  std::vector<applesauce::CF::DataRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  a41 = v43 - 240;
  std::vector<applesauce::CF::DataRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&a41);
  *(void *)(v43 - 24std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v43 - 208;
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v43 - 240));
  _Unwind_Resume(a1);
}

void **IR::IRData::Implementation::flattenVBAPTree(void **result, uint64_t *a2, int a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *a2;
  uint64_t v5 = (void *)a2[1];
  if ((((unsigned char *)result[14] - (unsigned char *)result[13]) >> 2) - 1 == a3)
  {
    if ((void *)v4 != v5)
    {
      unsigned int v6 = (uint64_t *)(result + 63);
      do
      {
        os_log_t result = std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::push_back[abi:ne180100](v6, (long long *)(v4 + 32));
        v4 += 96;
      }
      while ((void *)v4 != v5);
    }
  }
  else if ((void *)v4 != v5)
  {
    uint64_t v7 = (a3 + 1);
    uint64_t v8 = (void *)(v4 + 72);
    do
    {
      if (*v8 != v8[1]) {
        os_log_t result = (void **)IR::IRData::Implementation::flattenVBAPTree(v3, v8, v7);
      }
      uint64_t v9 = v8 + 3;
      v8 += 12;
    }
    while (v9 != v5);
  }
  return result;
}

void **std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  os_log_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    unsigned int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DSPSplitComplex>>((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    void v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    os_log_t result = std::__split_buffer<std::shared_ptr<IR::VBAPTriangulationKernel>>::~__split_buffer(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_21B503D74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<IR::VBAPTriangulationKernel>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRData::Implementation::normalizeTriangleCoeffs(uint64_t a1, float *a2, int a3, int a4)
{
  if (a3 == 3) {
    a3 = *(_DWORD *)(*(void *)(a1 + 200) + 4 * a4);
  }
  if (a3)
  {
    if (a3 == 2)
    {
      float v4 = sqrtf((float)((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) + (float)(a2[2] * a2[2]));
      if (v4 > 0.0)
      {
        uint64_t v5 = 0;
        float v6 = 1.0 / v4;
        do
        {
          a2[v5] = v6 * a2[v5];
          ++v5;
        }
        while (v5 != 3);
      }
    }
    else
    {
      uint64_t v9 = 0;
      float v10 = 0.0;
      do
        float v10 = v10 + fabsf(a2[v9++]);
      while (v9 != 3);
      if (v10 > 0.0)
      {
        uint64_t v11 = 0;
        float v12 = 1.0 / v10;
        do
        {
          a2[v11] = v12 * a2[v11];
          ++v11;
        }
        while (v11 != 3);
      }
    }
  }
  else
  {
    float v7 = *a2;
    uint64_t v8 = a2 + 1;
    if (*a2 >= a2[1]) {
      uint64_t v8 = a2;
    }
    else {
      float v7 = a2[1];
    }
    if (v7 < a2[2]) {
      uint64_t v8 = a2 + 2;
    }
    *(void *)a2 = 0;
    a2[2] = 0.0;
    *uint64_t v8 = 1.0;
  }
  return 0;
}

uint64_t IR::IRData::Implementation::getTriangleIndicesAndCoordinates(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, uint64_t a5, uint64_t a6, int a7, VBAP ***a8)
{
  *(void *)&v29[3] = *MEMORY[0x263EF8340];
  uint64_t result = 1852793972;
  if (*a8)
  {
    if (**a8)
    {
      float v17 = IR::IRCoordinates::get(a2, 0);
      float v18 = IR::IRCoordinates::get(a2, 1u);
      VBAP::convertSphericalDegreesToCartesian((VBAP *)v29, v17, v18, v19);
      int v28 = 0;
      uint64_t result = VBAP::triangleLookup(**a8, (float32x2_t *)v29, &v28, (float *)a5);
      if (!result)
      {
        IR::IRData::Implementation::normalizeTriangleCoeffs(a1, (float *)a5, a3, a7);
        int v20 = *(_DWORD *)(a5 + 8);
        *(void *)a6 = *(void *)a5;
        *(_DWORD *)(a6 + 8) = v20;
        if (a3 >= 2 && (a3 != 3 || *(_DWORD *)(*(void *)(a1 + 200) + 4 * a7) >= 2u))
        {
          uint64_t v21 = 0;
          float v22 = 0.0;
          do
          {
            float v22 = v22 + fabsf(*(float *)(a6 + v21));
            v21 += 4;
          }
          while (v21 != 12);
          if (v22 > 0.0)
          {
            uint64_t v23 = 0;
            float v24 = 1.0 / v22;
            do
            {
              *(float *)(a6 + v23) = v24 * *(float *)(a6 + v23);
              v23 += 4;
            }
            while (v23 != 12);
          }
        }
        uint64_t result = 0;
        int v25 = 3 * v28;
        unint64_t v26 = (*a8)[2];
        *a4 = *((_DWORD *)v26 + 3 * v28);
        uint64_t v27 = (char *)v26 + 4 * v25;
        a4[1] = *((_DWORD *)v27 + 1);
        a4[2] = *((_DWORD *)v27 + 2);
      }
    }
  }
  return result;
}

void **std::vector<std::shared_ptr<VBAP>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  float v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    unsigned int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<DSPSplitComplex>>((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    void v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<VBAP>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::shared_ptr<IR::VBAPTriangulationKernel>>::~__split_buffer(v18);
  }
  else
  {
    *float v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_21B504138(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<IR::VBAPTriangulationKernel>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

BOOL IR::IRData::Implementation::loadTriangulationData(uint64_t a1, unsigned int a2, const __CFDictionary **a3, std::vector<unsigned int> *a4, uint64_t *a5, uint64_t *a6)
{
  CFDictionaryRef v6 = *a3;
  if (!*a3)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  float v242 = @"NumTriangulations";
  uint64_t v12 = applesauce::CF::details::has_key<__CFString const*>(v6, (const void **)&v242);
  if (!v12)
  {
    IRDataLog = IR::getIRDataLog(v12);
    BOOL result = os_log_type_enabled(IRDataLog, OS_LOG_TYPE_ERROR);
    if (result)
    {
      IR::IRData::Implementation::loadTriangulationData(IRDataLog, v45, v46, v47, v48, v49, v50, v51);
      return 0;
    }
    return result;
  }
  if (!*a3)
  {
    uint64_t v214 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v214);
  }
  uint64_t v239 = @"NumTriangulations";
  LODWORD(valuePtr) = 0;
  vDSP_Length v244 = (const UInt8 **)CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v244)
  {
    unint64_t v215 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v215, "Could not construct");
  }
  applesauce::CF::at_or<applesauce::CF::NumberRef,__CFString const*>(*a3, (const void **)&v239, &v244, &v242);
  if (!v242)
  {
    v216 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v216, "Could not construct");
  }
  unsigned int v13 = applesauce::CF::convert_to<unsigned int,0>((const __CFNumber *)v242);
  if (v242) {
    CFRelease(v242);
  }
  unsigned int v14 = (IR *)v244;
  if (v244) {
    CFRelease(v244);
  }
  if (!v13)
  {
    int v52 = IR::getIRDataLog(v14);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v52, v53, v54, v55, v56, v57, v58, v59);
    }
    goto LABEL_123;
  }
  unint64_t v234 = v13;
  std::vector<std::vector<int>>::resize(a5, v13);
  CFDictionaryRef v15 = *a3;
  if (!*a3)
  {
    v217 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v217);
  }
  float v242 = @"TriVertices";
  uint64_t v16 = applesauce::CF::details::has_key<__CFString const*>(v15, (const void **)&v242);
  if (!v16)
  {
    unint64_t v60 = IR::getIRDataLog(v16);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v60, v61, v62, v63, v64, v65, v66, v67);
    }
    goto LABEL_123;
  }
  CFDictionaryRef v17 = *a3;
  if (!*a3)
  {
    v218 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v218);
  }
  uint64_t v239 = @"TriVertices";
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*>(v17, (const void **)&v239, &v242);
  if (!v243)
  {
    unint64_t v68 = IR::getIRDataLog(v18);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v68, v69, v70, v71, v72, v73, v74, v75);
    }
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v242);
    goto LABEL_123;
  }
  int64_t v19 = v242;
  if (!v242)
  {
    uint64_t v239 = 0;
    int v219 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v219, "Could not construct");
  }
  CFRetain(v242);
  uint64_t v239 = v19;
  int Count = (IR *)CFArrayGetCount((CFArrayRef)v19);
  unint64_t v229 = a6;
  v230 = a4;
  unsigned int v222 = v13;
  unsigned int __n = a2;
  std::vector<unsigned int>::pointer v225 = a3;
  unint64_t v227 = Count;
  if (Count == (IR *)v13)
  {
    unint64_t v21 = 0;
    v232 = v19;
    do
    {
      int valuePtr = 0;
      applesauce::CF::at_or<applesauce::CF::DataRef>((const __CFArray *)v19, v21, &valuePtr, &v244);
      if (valuePtr) {
        CFRelease(valuePtr);
      }
      if (!v244)
      {
        v211 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](v211, "Could not construct");
      }
      unsigned int Length = CFDataGetLength((CFDataRef)v244);
      uint64_t v23 = (std::vector<unsigned int> *)(*a5 + 24 * v21);
      v23->__end_ = v23->__begin_;
      std::vector<IR::IRDataType>::reserve(v23, Length >> 2);
      if (!v244)
      {
        uint64_t v212 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](v212, "Could not construct");
      }
      BytePtr = CFDataGetBytePtr((CFDataRef)v244);
      if (Length >= 4)
      {
        int v25 = (unsigned int *)BytePtr;
        int v26 = 0;
        if (Length >> 2 <= 1) {
          int v27 = 1;
        }
        else {
          int v27 = Length >> 2;
        }
        do
        {
          uint64_t v28 = *a5 + 24 * v21;
          unsigned int v29 = bswap32(*v25);
          uint64_t v31 = (unsigned int **)(v28 + 8);
          unint64_t v30 = *(unsigned int **)(v28 + 8);
          unint64_t v33 = (void *)(v28 + 16);
          unint64_t v32 = *(void *)(v28 + 16);
          if ((unint64_t)v30 >= v32)
          {
            uint64_t v35 = *(unsigned int **)v28;
            uint64_t v36 = ((uint64_t)v30 - *(void *)v28) >> 2;
            unint64_t v37 = v36 + 1;
            if ((unint64_t)(v36 + 1) >> 62) {
              std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v38 = v32 - (void)v35;
            if (v38 >> 1 > v37) {
              unint64_t v37 = v38 >> 1;
            }
            if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v39 = v37;
            }
            if (v39)
            {
              uint64_t v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v33, v39);
              unint64_t v30 = *v31;
              uint64_t v35 = *(unsigned int **)v28;
            }
            else
            {
              uint64_t v40 = 0;
            }
            unsigned int v41 = (unsigned int *)&v40[4 * v36];
            *unsigned int v41 = v29;
            long long v34 = v41 + 1;
            while (v30 != v35)
            {
              unsigned int v42 = *--v30;
              *--unsigned int v41 = v42;
            }
            *(void *)uint64_t v28 = v41;
            *uint64_t v31 = v34;
            *unint64_t v33 = &v40[4 * v39];
            if (v35) {
              operator delete(v35);
            }
          }
          else
          {
            *unint64_t v30 = v29;
            long long v34 = v30 + 1;
          }
          *uint64_t v31 = v34;
          ++v25;
          ++v26;
        }
        while (v26 != v27);
      }
      if (v244) {
        CFRelease(v244);
      }
      ++v21;
      int64_t v19 = v232;
    }
    while (v21 != v234);
  }
  else
  {
    unint64_t v76 = IR::getIRDataLog(Count);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v76, v77, v78, v79, v80, v81, v82, v83);
    }
  }
  CFRelease(v19);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v242);
  if (v227 != (IR *)v234) {
    goto LABEL_123;
  }
  CFDictionaryRef v84 = *v225;
  if (!*v225)
  {
    unint64_t v220 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v220);
  }
  float v242 = @"TriAssignment";
  uint64_t v85 = applesauce::CF::details::has_key<__CFString const*>(v84, (const void **)&v242);
  if (!v85)
  {
    unint64_t v105 = IR::getIRDataLog(v85);
    if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v105, v106, v107, v108, v109, v110, v111, v112);
    }
    goto LABEL_123;
  }
  CFDictionaryRef v86 = *v225;
  if (!*v225)
  {
    int v221 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v221);
  }
  uint64_t v239 = @"TriAssignment";
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DataRef,__CFString const*>(v86, (const void **)&v239, &v242);
  if (!v243)
  {
    unint64_t v113 = IR::getIRDataLog(v87);
    if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v113, v114, v115, v116, v117, v118, v119, v120);
    }
    std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v242);
    goto LABEL_123;
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v239, (CFTypeRef *)&v242);
  vDSP_Length v244 = (const UInt8 **)applesauce::CF::DataRef::operator->(&v239);
  unsigned int byte_length = applesauce::CF::DataRef_proxy::get_byte_length((const __CFData ***)&v244);
  v230->__end_ = v230->__begin_;
  if (byte_length >> 2 == __n)
  {
    std::vector<IR::IRDataType>::reserve(v230, __n);
    vDSP_Length v244 = (const UInt8 **)applesauce::CF::DataRef::operator->(&v239);
    raw_int data = applesauce::CF::DataRef_proxy::get_raw_data(&v244);
    if (byte_length >= 4)
    {
      int v90 = (unsigned int *)raw_data;
      int v91 = 0;
      p_end_cap = &v230->__end_cap_;
      if (__n <= 1) {
        int v93 = 1;
      }
      else {
        int v93 = __n;
      }
      std::vector<unsigned int>::pointer end = v230->__end_;
      do
      {
        unsigned int v95 = bswap32(*v90);
        if (end >= p_end_cap->__value_)
        {
          std::vector<unsigned int>::pointer begin = v230->__begin_;
          uint64_t v98 = end - v230->__begin_;
          unint64_t v99 = v98 + 1;
          if ((unint64_t)(v98 + 1) >> 62) {
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v100 = (char *)p_end_cap->__value_ - (char *)begin;
          if (v100 >> 1 > v99) {
            unint64_t v99 = v100 >> 1;
          }
          if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v101 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v101 = v99;
          }
          if (v101)
          {
            unint64_t v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v101);
            std::vector<unsigned int>::pointer begin = v230->__begin_;
            std::vector<unsigned int>::pointer end = v230->__end_;
          }
          else
          {
            unint64_t v102 = 0;
          }
          unint64_t v103 = (unsigned int *)&v102[4 * v98];
          unsigned int *v103 = v95;
          CFDataRef v96 = v103 + 1;
          while (end != begin)
          {
            unsigned int v104 = *--end;
            *--unint64_t v103 = v104;
          }
          v230->__begin_ = v103;
          v230->__end_ = v96;
          v230->__end_cap_.__value_ = (unsigned int *)&v102[4 * v101];
          if (begin) {
            operator delete(begin);
          }
        }
        else
        {
          *std::vector<unsigned int>::pointer end = v95;
          CFDataRef v96 = end + 1;
        }
        v230->__end_ = v96;
        ++v90;
        ++v91;
        std::vector<unsigned int>::pointer end = v96;
      }
      while (v91 != v93);
    }
  }
  else
  {
    long long v121 = IR::getIRDataLog((IR *)v230);
    if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v121, v122, v123, v124, v125, v126, v127, v128);
    }
  }
  applesauce::CF::DataRef::~DataRef((const void **)&v239);
  std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v242);
  if (byte_length >> 2 != __n)
  {
LABEL_123:
    int v162 = 1;
    return v162 == 0;
  }
  uint64_t v129 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(v225);
  float v242 = @"TriBinLengths";
  std::vector<unsigned int> v130 = applesauce::CF::details::has_key<__CFString const*>(*v129, (const void **)&v242);
  if (!v130
    || (int v131 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(v225),
        uint64_t v239 = @"TriBinSerial",
        std::vector<unsigned int> v130 = applesauce::CF::details::has_key<__CFString const*>(*v131, (const void **)&v239),
        !v130))
  {
    v163 = IR::getIRDataLog(v130);
    if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v163, v164, v165, v166, v167, v168, v169, v170);
    }
    goto LABEL_123;
  }
  v132 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(v225);
  uint64_t v239 = @"TriBinLengths";
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*>(*v132, (const void **)&v239, &v242);
  uint64_t v133 = (const __CFDictionary **)applesauce::CF::DictionaryRef::operator->(v225);
  vDSP_Length v244 = (const UInt8 **)@"TriBinSerial";
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const*>(*v133, (const void **)&v244, &v239);
  if (!v243 || !v240)
  {
    v171 = IR::getIRDataLog(v134);
    if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v171, v172, v173, v174, v175, v176, v177, v178);
    }
    int v162 = 1;
    goto LABEL_136;
  }
  applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&v244, (CFTypeRef *)&v242);
  applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&valuePtr, (CFTypeRef *)&v239);
  std::vector<std::vector<std::list<int>>>::resize(v229, v234);
  unsigned int v238 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&v244);
  std::string::size_type size = applesauce::CF::ArrayRef_proxy::get_size(&v238);
  if (size != (IR *)v234
    || (v237 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&valuePtr),
        std::string::size_type size = applesauce::CF::ArrayRef_proxy::get_size(&v237),
        size != (IR *)v234))
  {
    unint64_t v179 = IR::getIRDataLog(size);
    if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR)) {
      IR::IRData::Implementation::loadTriangulationData(v179, v180, v181, v182, v183, v184, v185, v186);
    }
    goto LABEL_134;
  }
  unint64_t v136 = 0;
  if (v222 <= 1) {
    uint64_t v137 = 1;
  }
  else {
    uint64_t v137 = v222;
  }
  std::vector<unsigned int>::size_type __na = v137;
  while (1)
  {
    uint64_t v138 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&v244);
    v237 = 0;
    applesauce::CF::at_or<applesauce::CF::DataRef>(*v138, v136, &v237, &v238);
    applesauce::CF::DataRef::~DataRef((const void **)&v237);
    long long v139 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&valuePtr);
    unint64_t v236 = 0;
    applesauce::CF::at_or<applesauce::CF::DataRef>(*v139, v136, &v236, &v237);
    applesauce::CF::DataRef::~DataRef((const void **)&v236);
    unint64_t v236 = (const UInt8 **)applesauce::CF::DataRef::operator->(&v238);
    unsigned int v140 = applesauce::CF::DataRef_proxy::get_byte_length((const __CFData ***)&v236);
    unsigned int v141 = v140 >> 2;
    unint64_t v236 = (const UInt8 **)applesauce::CF::DataRef::operator->(&v237);
    uint64_t v142 = applesauce::CF::DataRef_proxy::get_byte_length((const __CFData ***)&v236);
    unsigned int v143 = v142 >> 2;
    if (v142 >> 2 < v140 >> 2)
    {
      int v195 = IR::getIRDataLog(v142);
      if (os_log_type_enabled(v195, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::loadTriangulationData(v195, v196, v197, v198, v199, v200, v201, v202);
      }
      goto LABEL_133;
    }
    unsigned int v144 = v142;
    unint64_t v231 = v141;
    std::vector<std::list<int>>::resize((uint64_t *)(*v229 + 24 * v136), v141);
    unint64_t v236 = (const UInt8 **)applesauce::CF::DataRef::operator->(&v238);
    unint64_t v145 = (unsigned int *)applesauce::CF::DataRef_proxy::get_raw_data(&v236);
    unint64_t v236 = (const UInt8 **)applesauce::CF::DataRef::operator->(&v237);
    uint64_t v146 = (IR *)applesauce::CF::DataRef_proxy::get_raw_data(&v236);
    int v147 = 0;
    if (v140 < 4)
    {
      LODWORD(v148) = 0;
      goto LABEL_117;
    }
    LODWORD(v148) = 0;
    if (v144 >= 4) {
      break;
    }
LABEL_117:
    if (v148 != v141 || v147 != v143)
    {
      unint64_t v203 = IR::getIRDataLog(v146);
      if (os_log_type_enabled(v203, OS_LOG_TYPE_ERROR)) {
        IR::IRData::Implementation::loadTriangulationData(v203, v204, v205, v206, v207, v208, v209, v210);
      }
      goto LABEL_133;
    }
    applesauce::CF::DataRef::~DataRef((const void **)&v237);
    applesauce::CF::DataRef::~DataRef((const void **)&v238);
    int v162 = 0;
    if (++v136 == v137) {
      goto LABEL_135;
    }
  }
  uint64_t v149 = (unsigned int *)v146;
  unsigned int v226 = v141;
  unint64_t v228 = v136;
  unint64_t v148 = 0;
  int v147 = 0;
  uint64_t v150 = *v229;
  while (1)
  {
    unsigned int v235 = v145 + 1;
    int v151 = bswap32(*v145);
    v152 = (IR *)std::__list_imp<int>::clear((void *)(*(void *)(v150 + 24 * v136) + 24 * v148));
    if (v151 < 1) {
      break;
    }
    uint64_t v233 = *v229;
    v153 = (uint64_t *)(*v229 + 24 * v136);
    int v154 = 1;
    do
    {
      uint64_t v155 = *v153;
      unsigned int v156 = *v149;
      uint64_t v146 = (IR *)operator new(0x18uLL);
      ++v149;
      CFNumberRef v157 = (IR **)(v155 + 24 * v148);
      *((_DWORD *)v146 + 4) = bswap32(v156);
      *((void *)v146 + 1) = v157;
      float v158 = *v157;
      *(void *)uint64_t v146 = *v157;
      *((void *)v158 + 1) = v146;
      *CFNumberRef v157 = v146;
      v157[2] = (IR *)((char *)v157[2] + 1);
      unsigned int v159 = v147 + v154;
      int v160 = v154 + 1;
      if (v147 + v154 >= v143) {
        break;
      }
    }
    while (v154++ < v151);
    ++v148;
    int v147 = v147 + v160 - 1;
    unint64_t v136 = v228;
    uint64_t v150 = v233;
    unint64_t v145 = v235;
    if (v148 >= v231 || v159 >= v143)
    {
      uint64_t v137 = __na;
      unsigned int v141 = v226;
      goto LABEL_117;
    }
  }
  uint64_t v187 = IR::getIRDataLog(v152);
  if (os_log_type_enabled(v187, OS_LOG_TYPE_ERROR)) {
    IR::IRData::Implementation::loadTriangulationData(v187, v188, v189, v190, v191, v192, v193, v194);
  }
LABEL_133:
  applesauce::CF::DataRef::~DataRef((const void **)&v237);
  applesauce::CF::DataRef::~DataRef((const void **)&v238);
LABEL_134:
  int v162 = 1;
LABEL_135:
  applesauce::CF::ArrayRef::~ArrayRef(&valuePtr);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)&v244);
LABEL_136:
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v239);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v242);
  return v162 == 0;
}

void sub_21B504D34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va3, a11);
  va_start(va2, a11);
  va_start(va1, a11);
  va_start(va, a11);
  unsigned int v13 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFDictionaryRef v15 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v17 = va_arg(va3, void);
  uint64_t v19 = va_arg(va3, void);
  applesauce::CF::DataRef::~DataRef((const void **)va);
  applesauce::CF::DataRef::~DataRef((const void **)va1);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)va3);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)(v11 - 88));
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va2);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100](v11 - 104);
  _Unwind_Resume(a1);
}

void applesauce::CF::NumberRef::~NumberRef(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void std::vector<std::vector<int>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<int>>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      uint64_t v8 = a1[1];
      do
      {
        uint64_t v10 = *(void **)(v8 - 24);
        v8 -= 24;
        uint64_t v9 = v10;
        if (v10)
        {
          *(void *)(v3 - 16) = v9;
          operator delete(v9);
        }
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

applesauce::CF::ArrayRef *applesauce::CF::ArrayRef::ArrayRef(applesauce::CF::ArrayRef *this, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *(void *)this = v3;
  return this;
}

void *applesauce::CF::ArrayRef::operator->(void *result)
{
  if (!*result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_21B505038()
{
}

void sub_21B505058(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const __CFArray *applesauce::CF::ArrayRef_proxy::get_size(const __CFArray ***this)
{
  CFArrayRef result = **this;
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

void *applesauce::CF::DataRef::operator->(void *result)
{
  if (!*result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_21B5050CC()
{
}

void sub_21B5050EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const __CFData *applesauce::CF::DataRef_proxy::get_byte_length(const __CFData ***this)
{
  CFDataRef result = **this;
  if (result) {
    return (const __CFData *)CFDataGetLength(result);
  }
  return result;
}

const UInt8 *applesauce::CF::DataRef_proxy::get_raw_data(const UInt8 ***this)
{
  CFDataRef result = **this;
  if (result) {
    return CFDataGetBytePtr((CFDataRef)result);
  }
  return result;
}

applesauce::CF::DataRef *applesauce::CF::DataRef::DataRef(applesauce::CF::DataRef *this, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *(void *)this = v3;
  return this;
}

void std::vector<std::vector<std::list<int>>>::resize(uint64_t *a1, unint64_t a2)
{
  CFTypeRef v3 = (void **)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<std::list<int>>>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      uint64_t v8 = v3;
      std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v8);
    }
    a1[1] = v7;
  }
}

uint64_t *std::vector<std::list<int>>::resize(uint64_t *result, unint64_t a2)
{
  uint64_t v2 = result;
  CFTypeRef v3 = (void *)result[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *result) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    return (uint64_t *)std::vector<std::list<int>>::__append(result, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *result + 24 * a2;
    while (v3 != (void *)v7)
    {
      v3 -= 3;
      CFDataRef result = std::__list_imp<int>::clear(v3);
    }
    v2[1] = v7;
  }
  return result;
}

BOOL IR::IRData::Implementation::initVBAPTriangulation(uint64_t a1, uint64_t *a2, void *a3, unsigned int a4)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  uint64_t v7 = (uint64_t *)(a1 + 504);
  std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__clear[abi:ne180100]((uint64_t *)(a1 + 504));
  uint64_t v9 = *(uint64_t **)(a1 + 264);
  if (*(void *)(a1 + 104) != *(void *)(a1 + 112))
  {
    uint64_t v10 = (IR *)IR::IRData::Implementation::flattenVBAPTree((void **)a1, v9, 0);
    goto LABEL_5;
  }
  if (*v9 != v9[1])
  {
    uint64_t v10 = (IR *)std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::push_back[abi:ne180100](v7, (long long *)(*v9 + 32));
LABEL_5:
    unint64_t v11 = a4;
    uint64_t v12 = *(void *)(a1 + 504);
    if (a4 < (unint64_t)((*(void *)(a1 + 512) - v12) >> 4))
    {
      int v90 = a3;
      int v93 = 0;
      uint64_t v94 = a1;
      while (1)
      {
        uint64_t v13 = 16 * v11;
        if (v11)
        {
          uint64_t v14 = 0;
          uint64_t v15 = v12 + 16 * v11;
          while (1)
          {
            uint64_t v16 = 16 * v14;
            uint64_t v17 = *(uint64_t **)(v12 + 16 * v14);
            uint64_t v18 = *v17;
            if (*v17)
            {
              uint64_t v19 = *(void **)v15;
              unint64_t v21 = (float *)v17[5];
              int v20 = (float *)v17[6];
              float v22 = *(float **)(*(void *)v15 + 40);
              uint64_t v10 = (IR *)(*(void *)(*(void *)v15 + 48) - (void)v22);
              if ((IR *)((char *)v20 - (char *)v21) == v10)
              {
                while (v21 != v20)
                {
                  if (*v21 != *v22) {
                    goto LABEL_18;
                  }
                  ++v21;
                  ++v22;
                }
                float v24 = (float *)v17[8];
                uint64_t v23 = (float *)v17[9];
                int v25 = (float *)v19[8];
                uint64_t v10 = (IR *)(v19[9] - (void)v25);
                if ((IR *)((char *)v23 - (char *)v24) == v10) {
                  break;
                }
              }
            }
LABEL_18:
            if (++v14 == v11) {
              goto LABEL_19;
            }
          }
          while (v24 != v23)
          {
            if (*v24 != *v25) {
              goto LABEL_18;
            }
            ++v24;
            ++v25;
          }
          uint64_t v45 = v17[1];
          if (v45) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v46 = (std::__shared_weak_count *)v19[1];
          *uint64_t v19 = v18;
          v19[1] = v45;
          if (v46) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v46);
          }
          unint64_t v37 = *(uint64_t **)(*v7 + 16 * v11);
          *((_DWORD *)v37 + 34) = *(_DWORD *)(*(void *)(*v7 + v16) + 136);
        }
        else
        {
LABEL_19:
          uint64_t v26 = *a2;
          uint64_t v27 = a2[1];
          if (*a2 == v27
            || (uint64_t v28 = *(void *)(v12 + 16 * v11), v29 = *(unsigned int *)(v28 + 136), (v29 & 0x80000000) != 0)
            || 0xAAAAAAAAAAAAAAABLL * ((v27 - v26) >> 3) <= v29
            || (unint64_t v30 = (uint64_t)(*(void *)(v26 + 24 * v29 + 8)
                              - *(void *)(v26 + 24 * v29)) >> 2,
                uint64_t v31 = *(void *)(v28 + 48) - *(void *)(v28 + 40),
                (v31 >> 1) - 4 != v30 / 3)
            || *(_DWORD *)(v28 + 140) != v31 >> 2)
          {
            IRDataLog = IR::getIRDataLog(v10);
            if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v40 = (uint64_t)(*(void *)(*(void *)(*v7 + 16 * v11) + 48)
                            - *(void *)(*(void *)(*v7 + 16 * v11) + 40)) >> 2;
              *(_DWORD *)buf = 136315394;
              *(void *)&buf[4] = "initVBAPTriangulation";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v40;
              _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "IRData::%s: creating new VBAP instance with %lu vertices, no precomputed triangulation", buf, 0x16u);
            }
            uint64_t v41 = *(void *)(*v7 + 16 * v11);
            LODWORD(__p) = 0;
            std::allocate_shared[abi:ne180100]<VBAP,std::allocator<VBAP>,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,void>(v41 + 40, v41 + 64, (int *)&__p, buf);
            uint64_t v42 = *(void *)(*v7 + 16 * v11);
            long long v43 = *(_OWORD *)buf;
            *(void *)buf = 0;
            *(void *)&buf[8] = 0;
            unint64_t v44 = *(std::__shared_weak_count **)(v42 + 8);
            *(_OWORD *)uint64_t v42 = v43;
            if (v44) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v44);
            }
            if (*(void *)&buf[8]) {
              std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
            }
            unint64_t v37 = *(uint64_t **)(*v7 + 16 * v11);
            int v38 = v93;
            *((_DWORD *)v37 + 34) = v93;
          }
          else
          {
            unint64_t v32 = IR::getIRDataLog(v10);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v80 = (uint64_t)(*(void *)(*(void *)(*v7 + 16 * v11) + 48)
                            - *(void *)(*(void *)(*v7 + 16 * v11) + 40)) >> 2;
              *(_DWORD *)buf = 136315394;
              *(void *)&buf[4] = "initVBAPTriangulation";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v80;
              _os_log_debug_impl(&dword_21B4DD000, v32, OS_LOG_TYPE_DEBUG, "IRData::%s: creating new VBAP instance with %lu vertices and precomputed triangulation", buf, 0x16u);
            }
            uint64_t v33 = *(void *)(*v7 + 16 * v11);
            LODWORD(__p) = 0;
            std::allocate_shared[abi:ne180100]<VBAP,std::allocator<VBAP>,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::vector<int> const&,std::vector<std::list<int>> const&,void>(v33 + 40, v33 + 64, (int *)&__p, (char **)(*a2 + 24 * v29), (uint64_t *)(*v90 + 24 * v29), buf);
            uint64_t v34 = *(void *)(*v7 + 16 * v11);
            long long v35 = *(_OWORD *)buf;
            *(void *)buf = 0;
            *(void *)&buf[8] = 0;
            uint64_t v36 = *(std::__shared_weak_count **)(v34 + 8);
            *(_OWORD *)uint64_t v34 = v35;
            if (v36) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v36);
            }
            if (*(void *)&buf[8]) {
              std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
            }
            unint64_t v37 = *(uint64_t **)(*v7 + 16 * v11);
            int v38 = v93;
          }
          int v93 = v38 + 1;
        }
        uint64_t v47 = *v37;
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
        unint64_t v105 = 0;
        uint64_t v106 = 0;
        uint64_t v48 = (IR *)std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)(v47 + 80), *(void *)(v47 + 88), (uint64_t)(*(void *)(v47 + 88) - *(void *)(v47 + 80)) >> 2);
        unint64_t v49 = (unint64_t)(v105 - (unsigned char *)__p) >> 2;
        uint64_t v50 = *(void **)(*v7 + 16 * v11);
        uint64_t v51 = (v50[6] - v50[5]) >> 2;
        int v97 = (int)v49 / 3;
        unint64_t v52 = ((uint64_t)(*(void *)(*v50 + 232) - *(void *)(*v50 + 224)) >> 2) / 3uLL;
        BOOL v92 = 2 * ((int)v49 / 3 + v51) - 4 == v52;
        if (2 * ((int)v49 / 3 + v51) - 4 != v52)
        {
          uint64_t v73 = IR::getIRDataLog(v48);
          if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
          {
            uint64_t v79 = (uint64_t)(*(void *)(*(void *)(*v7 + 16 * v11) + 48)
                          - *(void *)(*(void *)(*v7 + 16 * v11) + 40)) >> 2;
            *(_DWORD *)buf = 136315394;
            *(void *)&buf[4] = "initVBAPTriangulation";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v79;
            _os_log_error_impl(&dword_21B4DD000, v73, OS_LOG_TYPE_ERROR, "IRData::%s: failed to initialize VBAP triangulation with %lu vertices", buf, 0x16u);
          }
          uint64_t v75 = *(void **)(*v7 + 16 * v11);
          v75[3] = v75[2];
          v75[6] = v75[5];
          v75[9] = v75[8];
          std::vector<std::vector<float>>::__clear[abi:ne180100](v75 + 14);
          uint64_t v76 = *(void *)(*v7 + 16 * v11);
          uint64_t v77 = *(void *)(v76 + 88);
          uint64_t v78 = *(void *)(v76 + 96);
          while (v78 != v77)
          {
            v78 -= 24;
            *(void *)buf = v78;
            std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
          }
          *(void *)(v76 + 96) = v77;
          *(unsigned char *)(v94 + 488) = 0;
          goto LABEL_88;
        }
        std::vector<int>::resize((std::vector<unsigned int> *)(v50 + 2), 3 * (int)v52);
        uint64_t v53 = (IR *)memcpy(*(void **)(*(void *)(*v7 + 16 * v11) + 16), *(const void **)(**(void **)(*v7 + 16 * v11) + 224), *(void *)(**(void **)(*v7 + 16 * v11) + 232)- *(void *)(**(void **)(*v7 + 16 * v11) + 224));
        if ((int)v49 < 3) {
          goto LABEL_80;
        }
        int v98 = 0;
        int v95 = v52;
        unint64_t v96 = v11;
        do
        {
          uint64_t v54 = *(void *)(*(void *)(*v7 + v13) + 16);
          unint64_t v102 = 0;
          uint64_t v103 = 0;
          unint64_t v101 = (uint64_t *)&v102;
          if ((int)v52 < 1) {
LABEL_96:
          }
            __assert_rtn("initVBAPTriangulation", "IRDataTriangulation.cpp", 395, "!realSpeakersConnected.empty()");
          int v55 = v98 + v51;
          uint64_t v56 = (int *)(v54 + 4);
          do
          {
            uint64_t v57 = v56 - 1;
            int v58 = *(v56 - 1);
            int v59 = *v56;
            if (v58 == v55)
            {
              if (v59 < (int)v51) {
                std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v101, v56, v56);
              }
LABEL_56:
              if (v56[1] >= (int)v51) {
                goto LABEL_63;
              }
              unint64_t v60 = (int *)(v54 + 8);
LABEL_58:
              std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v101, v60, v60);
              goto LABEL_63;
            }
            if (v59 == v55)
            {
              if (v58 < (int)v51) {
                std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v101, v57, v56 - 1);
              }
              goto LABEL_56;
            }
            if (v56[1] == v55)
            {
              if (v58 < (int)v51)
              {
                std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v101, v57, v56 - 1);
                int v59 = *v56;
              }
              unint64_t v60 = v56;
              if (v59 < (int)v51) {
                goto LABEL_58;
              }
            }
LABEL_63:
            v54 += 12;
            v56 += 3;
            LODWORD(v52) = v52 - 1;
          }
          while (v52);
          if (!v103) {
            goto LABEL_96;
          }
          long long v99 = 0uLL;
          uint64_t v100 = 0;
          unint64_t v61 = *(void *)(*(void *)(*(void *)(*v7 + v13) + 88) + 8)
              - **(void **)(*(void *)(*v7 + v13) + 88);
          std::vector<std::unique_ptr<IR::FFTFilterKernel>>::reserve((char **)&v99, (v61 >> 3));
          if ((v61 & 0x7FFFFFFF8) != 0) {
            operator new();
          }
          unint64_t v62 = (uint64_t)(*(void *)(*(void *)(*(void *)(*v7 + v13) + 112) + 8)
                        - **(void **)(*(void *)(*v7 + v13) + 112)) >> 2;
          LODWORD(v107) = 0;
          std::vector<float>::vector(buf, v62, &v107);
          uint64_t v63 = v101;
          if (v101 != (uint64_t *)&v102)
          {
            do
            {
              uint64_t v64 = (uint64_t *)v63[1];
              if (v64)
              {
                do
                {
                  uint64_t v65 = v64;
                  uint64_t v64 = (uint64_t *)*v64;
                }
                while (v64);
              }
              else
              {
                do
                {
                  uint64_t v65 = (uint64_t *)v63[2];
                  BOOL v66 = *v65 == (void)v63;
                  uint64_t v63 = v65;
                }
                while (!v66);
              }
              uint64_t v63 = v65;
            }
            while (v65 != (uint64_t *)&v102);
          }
          uint64_t v67 = *(uint64_t **)(*v7 + v13);
          unint64_t v68 = v67 + 14;
          unint64_t v69 = v67[15];
          LODWORD(v52) = v95;
          if (v69 >= v67[16])
          {
            uint64_t v70 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(v68, (uint64_t)buf);
            unint64_t v11 = v96;
          }
          else
          {
            std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)v68, (uint64_t)buf);
            unint64_t v11 = v96;
            uint64_t v70 = v69 + 24;
          }
          v67[15] = v70;
          std::vector<std::vector<std::unique_ptr<IR::FFTFilterKernel>>>::push_back[abi:ne180100]((uint64_t *)(*(void *)(*v7 + v13) + 88), (uint64_t)&v99);
          if (*(void *)buf)
          {
            *(void *)&buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          *(void *)buf = &v99;
          std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
          std::__tree<int>::destroy((uint64_t)&v101, v102);
          ++v98;
        }
        while (v98 != v97);
LABEL_80:
        uint64_t v71 = IR::getIRDataLog(v53);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v72 = (uint64_t)(*(void *)(*(void *)(*v7 + v13) + 48) - *(void *)(*(void *)(*v7 + v13) + 40)) >> 2;
          *(_DWORD *)buf = 136315650;
          *(void *)&buf[4] = "initVBAPTriangulation";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v72;
          __int16 v109 = 1024;
          LODWORD(v11std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v97;
          _os_log_debug_impl(&dword_21B4DD000, v71, OS_LOG_TYPE_DEBUG, "IRData::%s: initialized VBAP triangulation with %lu vertices and %d virtual speakers", buf, 0x1Cu);
        }
LABEL_88:
        uint64_t v10 = (IR *)__p;
        if (__p)
        {
          unint64_t v105 = __p;
          operator delete(__p);
        }
        ++v11;
        uint64_t v12 = *(void *)(v94 + 504);
        if (v11 >= (*(void *)(v94 + 512) - v12) >> 4) {
          return v92;
        }
      }
    }
    return 0;
  }
  uint64_t v82 = IR::getIRDataLog(v8);
  BOOL result = os_log_type_enabled(v82, OS_LOG_TYPE_ERROR);
  if (!result) {
    return result;
  }
  IR::IRData::Implementation::initVBAPTriangulation(v82, v83, v84, v85, v86, v87, v88, v89);
  return 0;
}

void sub_21B505D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::unique_ptr<IR::FFTFilterKernel>>::reserve(char **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v17 = result;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(result, a2);
    uint64_t v9 = *a1;
    uint64_t v8 = a1[1];
    if (v8 == *a1)
    {
      int64x2_t v12 = vdupq_n_s64((unint64_t)v8);
      uint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      uint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *(void *)uint64_t v8 = 0;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v8 != v9);
      int64x2_t v12 = *(int64x2_t *)a1;
    }
    *a1 = v10;
    a1[1] = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    int64x2_t v15 = v12;
    uint64_t v13 = a1[2];
    a1[2] = &v6[8 * v7];
    uint64_t v16 = v13;
    uint64_t v14 = v12.i64[0];
    return std::__split_buffer<std::unique_ptr<IR::FFTFilterKernel>>::~__split_buffer((uint64_t)&v14);
  }
  return result;
}

uint64_t std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    CFTypeRef v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 16;
  }
}

void **std::__split_buffer<std::shared_ptr<IR::VBAPTriangulationKernel>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::shared_ptr<IR::VBAPTriangulationKernel>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    unint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t std::vector<std::shared_ptr<VBAP>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<VBAP>>,std::reverse_iterator<std::shared_ptr<VBAP>*>,std::reverse_iterator<std::shared_ptr<VBAP>*>,std::reverse_iterator<std::shared_ptr<VBAP>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<VBAP>>,std::reverse_iterator<std::shared_ptr<VBAP>*>,std::reverse_iterator<std::shared_ptr<VBAP>*>,std::reverse_iterator<std::shared_ptr<VBAP>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<VBAP>>,std::reverse_iterator<std::shared_ptr<VBAP>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<VBAP>>,std::reverse_iterator<std::shared_ptr<VBAP>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<IR::VBAPTriangulationKernel>>,std::reverse_iterator<std::shared_ptr<IR::VBAPTriangulationKernel>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::__destroy_at[abi:ne180100]<applesauce::CF::DataRef,0>(const void **a1)
{
  uint64_t v1 = *a1;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__split_buffer<applesauce::CF::DataRef>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::DataRef,0>((const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<std::list<int>>::__init_with_size[abi:ne180100]<std::list<int>*,std::list<int>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::list<int>>,std::list<int>*,std::list<int>*,std::list<int>*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_21B50632C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::list<int>>,std::list<int>*,std::list<int>*,std::list<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::list<int>::list((void *)(a4 + v7), a2 + v7);
      v7 += 24;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_21B5063AC(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 24;
    do
    {
      std::__list_imp<int>::clear((void *)(v4 + v2));
      v2 -= 24;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *std::list<int>::list(void *a1, uint64_t a2)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != a2)
  {
    uint64_t v5 = 1;
    uint64_t v6 = a1;
    do
    {
      uint64_t v7 = operator new(0x18uLL);
      v7[4] = *(_DWORD *)(v3 + 16);
      *(void *)uint64_t v7 = v6;
      *((void *)v7 + 1) = a1;
      *((void *)v6 + 1) = v7;
      *a1 = v7;
      a1[2] = v5;
      uint64_t v3 = *(void *)(v3 + 8);
      ++v5;
      uint64_t v6 = v7;
    }
    while (v3 != a2);
  }
  return a1;
}

void sub_21B506458(_Unwind_Exception *a1)
{
  std::__list_imp<int>::clear(v1);
  _Unwind_Resume(a1);
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, const std::vector<unsigned int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    uint64_t v7 = &end[__n];
    std::vector<unsigned int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_21B5064D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned int *std::vector<unsigned int>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(std::vector<unsigned int> *a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (unsigned int *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = (unsigned int *)__src;
  uint64_t value = a1->__end_cap_.__value_;
  p_end_cap = (std::allocator<unsigned int> *)&a1->__end_cap_;
  uint64_t v10 = value;
  unint64_t v12 = *((void *)p_end_cap - 1);
  if (a5 > (uint64_t)((uint64_t)value - v12) >> 2)
  {
    std::vector<unsigned int>::pointer begin = a1->__begin_;
    unint64_t v14 = a5 + ((uint64_t)(v12 - (unint64_t)a1->__begin_) >> 2);
    if (v14 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)begin) >> 2;
    uint64_t v16 = (char *)v10 - (char *)begin;
    if (v16 >> 1 > v14) {
      unint64_t v14 = v16 >> 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    __v.__end_cap_.__value_ = p_end_cap;
    if (v17) {
      uint64_t v18 = (unsigned int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v17);
    }
    else {
      uint64_t v18 = 0;
    }
    uint64_t v28 = &v18[v15];
    __v.__first_ = v18;
    __v.__begin_ = v28;
    __v.__end_cap_.__value_ = &v18[v17];
    uint64_t v29 = 4 * a5;
    unint64_t v30 = &v28[a5];
    do
    {
      unsigned int v31 = *v7++;
      *v28++ = v31;
      v29 -= 4;
    }
    while (v29);
    __v.__end_ = v30;
    uint64_t v5 = std::vector<int>::__swap_out_circular_buffer(a1, &__v, v5);
    if (__v.__end_ != __v.__begin_) {
      __v.__end_ = (std::__split_buffer<unsigned int>::pointer)((char *)__v.__end_
    }
                                                              + (((char *)__v.__begin_ - (char *)__v.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
    if (__v.__first_) {
      operator delete(__v.__first_);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    unint64_t v21 = &__src[4 * a5];
    uint64_t v23 = (unsigned int *)*((void *)p_end_cap - 1);
LABEL_17:
    float v24 = &v5[a5];
    int v25 = &v23[-a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        unsigned int v27 = *v25++;
        *v26++ = v27;
      }
      while ((unint64_t)v25 < v12);
    }
    a1->__end_ = v26;
    if (v23 != v24) {
      memmove(&v23[-(v23 - v24)], v5, (char *)v23 - (char *)v24);
    }
    if (v21 != (char *)v7) {
      memmove(v5, v7, v21 - (char *)v7);
    }
    return v5;
  }
  unint64_t v21 = &__src[4 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*((void **)p_end_cap - 1), &__src[4 * v20], a4 - v21);
  }
  uint64_t v23 = (unsigned int *)(v12 + v22);
  a1->__end_ = (std::vector<unsigned int>::pointer)(v12 + v22);
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_21B5066C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<applesauce::CF::DataRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::__destroy_at[abi:ne180100]<applesauce::CF::DataRef,0>(--v4);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<int>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    uint64_t v16 = &v12[24 * v8];
    uint64_t v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    unint64_t v17 = &v16[v14];
    std::vector<std::vector<int>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_21B5068D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<int>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

uint64_t std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

void std::vector<std::vector<std::list<int>>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      char v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v4, v11);
    }
    else {
      char v12 = 0;
    }
    uint64_t v15 = v12;
    uint64_t v16 = &v12[24 * v8];
    uint64_t v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    unint64_t v17 = &v16[v14];
    std::vector<std::vector<std::list<int>>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::vector<std::list<int>>>::~__split_buffer(&v15);
  }
}

void sub_21B506BD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<std::list<int>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<std::list<int>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::list<int>>>,std::reverse_iterator<std::vector<std::list<int>>*>,std::reverse_iterator<std::vector<std::list<int>>*>,std::reverse_iterator<std::vector<std::list<int>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::list<int>>>,std::reverse_iterator<std::vector<std::list<int>>*>,std::reverse_iterator<std::vector<std::list<int>>*>,std::reverse_iterator<std::vector<std::list<int>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::list<int>>>,std::reverse_iterator<std::vector<std::list<int>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::list<int>>>,std::reverse_iterator<std::vector<std::list<int>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::list<int>>>,std::reverse_iterator<std::vector<std::list<int>>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::list<int>>>,std::reverse_iterator<std::vector<std::list<int>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 3;
  }
}

void **std::__split_buffer<std::vector<std::list<int>>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<std::list<int>>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
}

uint64_t std::vector<std::list<int>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v7) >> 3) >= a2)
  {
    if (a2)
    {
      long long v13 = &v7[3 * a2];
      do
      {
        *uint64_t v7 = v7;
        v7[1] = v7;
        v7[2] = 0;
        v7 += 3;
      }
      while (v7 != v13);
      uint64_t v7 = v13;
    }
    a1[1] = (uint64_t)v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    v16[4] = result;
    if (v11) {
      char v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v11);
    }
    else {
      char v12 = 0;
    }
    long long v14 = &v12[24 * v8];
    v16[0] = v12;
    v16[1] = v14;
    v16[3] = &v12[24 * v11];
    uint64_t v15 = &v14[24 * a2];
    do
    {
      *(void *)long long v14 = v14;
      *((void *)v14 + 1) = v14;
      *((void *)v14 + 2) = 0;
      v14 += 24;
    }
    while (v14 != v15);
    v16[2] = v15;
    std::vector<std::list<int>>::__swap_out_circular_buffer(a1, v16);
    return std::__split_buffer<std::list<int>>::~__split_buffer((uint64_t)v16);
  }
  return result;
}

void sub_21B506F3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::list<int>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::list<int>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = (void *)*result;
  uint64_t v4 = (void *)result[1];
  uint64_t v6 = (uint64_t *)a2[1];
  while (v4 != v5)
  {
    v6 -= 3;
    v4 -= 3;
    uint64_t result = std::construct_at[abi:ne180100]<std::list<int>,std::list<int>,std::list<int>*>(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *v3;
  *uint64_t v3 = (uint64_t)v6;
  a2[1] = v7;
  uint64_t v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t *std::construct_at[abi:ne180100]<std::list<int>,std::list<int>,std::list<int>*>(uint64_t *a1, void *a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  std::list<int>::splice((uint64_t)a1, a1, a2);
  return a1;
}

uint64_t std::list<int>::splice(uint64_t result, uint64_t *a2, void *a3)
{
  uint64_t v3 = a3[2];
  if (v3)
  {
    uint64_t v5 = *a3;
    uint64_t v4 = (uint64_t *)a3[1];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(*a3 + 8);
    **(void **)(v5 + 8) = v6;
    uint64_t v7 = *a2;
    *(void *)(v7 + 8) = v4;
    *uint64_t v4 = v7;
    *a2 = v5;
    *(void *)(v5 + 8) = a2;
    *(void *)(result + 16) += v3;
    a3[2] = 0;
  }
  return result;
}

uint64_t std::__split_buffer<std::list<int>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    std::__list_imp<int>::clear((void *)(i - 24));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<IR::FFTFilterKernel>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::unique_ptr<IR::FFTFilterKernel>::reset[abi:ne180100]((IR::FFTFilterKernel **)(i - 8), 0);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::DataRef>(uint64_t **a1)
{
  std::vector<void const*>::vector(__p, a1[1] - *a1);
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    uint64_t v4 = __p[0];
    do
    {
      uint64_t v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return CFArray;
}

void sub_21B507188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],unsigned int>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B50723C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[14],applesauce::CF::DataRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],applesauce::CF::ArrayRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],applesauce::CF::ArrayRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[14],applesauce::CF::ArrayRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

uint64_t applesauce::CF::at_or<applesauce::CF::NumberRef,__CFString const*>@<X0>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::NumberRef,__CFString const*>(a1, a2, &cf);
  if (v9)
  {
    CFTypeRef v6 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *a4 = v6;
  }
  else
  {
    *a4 = *a3;
    *a3 = 0;
  }
  return std::__optional_destruct_base<applesauce::CF::NumberRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::NumberRef,__CFString const*>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, unsigned char *a3@<X8>)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFDictionaryRef v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFNumberGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

uint64_t applesauce::CF::at_or<applesauce::CF::DataRef>@<X0>(const __CFArray *a1@<X0>, unint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  applesauce::CF::details::at_as<applesauce::CF::DataRef>(a1, a2, &cf);
  if (v9)
  {
    CFTypeRef v6 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *a4 = v6;
  }
  else
  {
    *a4 = *a3;
    *a3 = 0;
  }
  return std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
}

void applesauce::CF::details::at_as<applesauce::CF::DataRef>(const __CFArray *a1@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (!a1) {
    goto LABEL_7;
  }
  if (CFArrayGetCount(a1) <= a2) {
    goto LABEL_7;
  }
  CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(a1, a2);
  char v7 = ValueAtIndex;
  if (!ValueAtIndex) {
    goto LABEL_7;
  }
  CFRetain(ValueAtIndex);
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFDataGetTypeID())
  {
    CFRelease(v7);
LABEL_7:
    char v9 = 0;
    *a3 = 0;
    goto LABEL_8;
  }
  *(void *)a3 = v7;
  char v9 = 1;
LABEL_8:
  a3[8] = v9;
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DataRef,__CFString const*>(const __CFDictionary *a1@<X0>, const void **a2@<X1>, unsigned char *a3@<X8>)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFDictionaryRef v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFDataGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

void *std::allocate_shared[abi:ne180100]<VBAP,std::allocator<VBAP>,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::vector<int> const&,std::vector<std::list<int>> const&,void>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, int *a3@<X3>, char **a4@<X4>, uint64_t *a5@<X5>, void *a6@<X8>)
{
  char v12 = operator new(0x158uLL);
  uint64_t result = std::__shared_ptr_emplace<VBAP>::__shared_ptr_emplace[abi:ne180100]<std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::vector<int> const&,std::vector<std::list<int>> const&,std::allocator<VBAP>,0>(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;
  return result;
}

void sub_21B507684(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<VBAP>::__shared_ptr_emplace[abi:ne180100]<std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::vector<int> const&,std::vector<std::list<int>> const&,std::allocator<VBAP>,0>(void *a1, uint64_t a2, uint64_t a3, int *a4, char **a5, uint64_t *a6)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB573C0;
  std::construct_at[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::vector<int> const&,std::vector<std::list<int>> const&,VBAP*>((uint64_t)(a1 + 3), a2, a3, a4, a5, a6);
  return a1;
}

void sub_21B5076E0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<VBAP>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB573C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<VBAP>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB573C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

void std::__shared_ptr_emplace<VBAP>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::construct_at[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::vector<int> const&,std::vector<std::list<int>> const&,VBAP*>(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, char **a5, uint64_t *a6)
{
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v15, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
  long long v13 = 0;
  uint64_t v14 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  VBAP::VBAP(a1, (uint64_t *)&v15, (uint64_t *)&__p, *a4, a5, a6);
  if (__p)
  {
    long long v13 = __p;
    operator delete(__p);
  }
  if (v15)
  {
    uint64_t v16 = v15;
    operator delete(v15);
  }
  return a1;
}

void sub_21B507838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<VBAP,std::allocator<VBAP>,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,void>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, int *a3@<X3>, void *a4@<X8>)
{
  CFTypeID v8 = operator new(0x158uLL);
  uint64_t result = std::__shared_ptr_emplace<VBAP>::__shared_ptr_emplace[abi:ne180100]<std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::allocator<VBAP>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_21B5078CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<VBAP>::__shared_ptr_emplace[abi:ne180100]<std::vector<float> &,std::vector<float> &,VBAP::Algorithm,std::allocator<VBAP>,0>(void *a1, uint64_t a2, uint64_t a3, int *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB573C0;
  std::construct_at[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,VBAP*>((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_21B507928(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<VBAP,std::vector<float> &,std::vector<float> &,VBAP::Algorithm,VBAP*>(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v16, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  long long v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v13, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  int v7 = *a4;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  memset(v9, 0, sizeof(v9));
  VBAP::VBAP(a1, (uint64_t *)&v16, (uint64_t *)&v13, v7, (char **)&__p, v9);
  uint64_t v19 = (void **)v9;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100](&v19);
  if (__p)
  {
    unint64_t v11 = __p;
    operator delete(__p);
  }
  if (v13)
  {
    uint64_t v14 = v13;
    operator delete(v13);
  }
  if (v16)
  {
    uint64_t v17 = v16;
    operator delete(v16);
  }
  return a1;
}

void sub_21B507A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  *(void *)(v18 - 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v17;
  std::vector<std::list<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v18 - 40));
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  uint64_t v20 = *(void **)(v18 - 64);
  if (v20)
  {
    *(void *)(v18 - 56) = v20;
    operator delete(v20);
  }
  _Unwind_Resume(a1);
}

void std::__tree<int>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<int>::destroy(a1, *a2);
    std::__tree<int>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t **std::__tree<int>::__emplace_unique_key_args<int,int const&>(uint64_t **a1, int *a2, _DWORD *a3)
{
  CFTypeID v6 = a1 + 1;
  CFDictionaryRef v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        CFTypeID v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        CFDictionaryRef v5 = *v8;
        CFTypeID v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      CFDictionaryRef v5 = v8[1];
      if (!v5)
      {
        CFTypeID v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    CFTypeID v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<int>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<int>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  CFDictionaryRef v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      CFDictionaryRef v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), CFDictionaryRef v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            int v9 = (uint64_t **)a2[2];
          }
          else
          {
            int v9 = (uint64_t **)v2[1];
            unint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              void v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *int v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), CFDictionaryRef v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *CFDictionaryRef v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

id AudioDSP::Core::getADCHeadTrackerLog(AudioDSP::Core *this)
{
  if (AudioDSP::Core::getADCHeadTrackerLog(void)::onceToken != -1) {
    dispatch_once(&AudioDSP::Core::getADCHeadTrackerLog(void)::onceToken, &__block_literal_global_1);
  }
  uint64_t v1 = (void *)AudioDSP::Core::getADCHeadTrackerLog(void)::gLog;

  return v1;
}

uint64_t ___ZN8AudioDSP4Core20getADCHeadTrackerLogEv_block_invoke()
{
  AudioDSP::Core::getADCHeadTrackerLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "ADCHeadTracker");

  return MEMORY[0x270F9A758]();
}

uint64_t AudioDSP::Core::HeadTracker::Implementation::Initialize(AudioDSP::Core::HeadTracker::Implementation *this)
{
  uint64_t v15 = (char *)this + 56;
  char v16 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 56);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)this + 41);
  if ((v2 & 1) != 0 && !*((void *)this + 9))
  {
    uint64_t v3 = (caulk::concurrent::messenger *)std::string::basic_string[abi:ne180100]<0>(&__p, "adc_headtracker_messenger_for_bt_llm_update");
    uint64_t v4 = caulk::concurrent::messenger::shared_high_priority(v3);
    if (*(unsigned char *)(v4 + 52))
    {
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v8, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string v8 = __p;
      }
      char v9 = 1;
      int v5 = *(_DWORD *)(v4 + 48);
      long long v10 = *(_OWORD *)(v4 + 32);
      int v11 = v5;
      char v12 = 1;
      char v13 = 0;
      char v14 = 0;
      operator new();
    }
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v15);
}

void sub_21B507F34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  MEMORY[0x21D48F780](v22, 0x20C40A4A59CD2);
  if (a22 && a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100](v23 - 32);
  _Unwind_Resume(a1);
}

uint64_t AudioDSP::Core::HeadTracker::Implementation::ConnectRM(id *a1, unsigned int a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  BOOL v4 = getRMMediaSessionClass()
    && [getRMMediaSessionClass() isAvailable]
    && getRMMediaSessionOptionsClass() != 0;
  float v24 = a1 + 7;
  LOBYTE(v25) = 1;
  int v5 = (AudioDSP::Core *)caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)(a1 + 7));
  *((_DWORD *)a1 + 11) = 0;
  if (a2 && v4)
  {
    if (*((_DWORD *)a1 + 12) == a2 && *((unsigned char *)a1 + 42))
    {
      int v6 = AudioDSP::Core::getADCHeadTrackerLog(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *a1;
        if (*((char *)*a1 + 23) < 0) {
          uint64_t v7 = (void *)*v7;
        }
        *(_DWORD *)buf = 136315394;
        unsigned int v27 = v7;
        __int16 v28 = 2080;
        uint64_t v29 = "ConnectRM";
        _os_log_impl(&dword_21B4DD000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] RelativeMotion MediaSession is already connected.", buf, 0x16u);
      }
LABEL_25:
      uint64_t v8 = 0;
LABEL_44:

      goto LABEL_45;
    }
    char v9 = (caulk::concurrent::messenger *)a1[9];
    if (v9) {
      caulk::concurrent::messenger::drain(v9);
    }
    int v6 = objc_alloc_init((Class)getRMMediaSessionOptionsClass());
    long long v10 = (AudioDSP::Core *)-[NSObject setPredictionIntervalMicroseconds:](v6, "setPredictionIntervalMicroseconds:", 100000, v24, v25);
    if (a2 >= 6)
    {
      uint64_t v17 = AudioDSP::Core::getADCHeadTrackerLog(v10);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *a1;
        if (*((char *)*a1 + 23) < 0) {
          uint64_t v18 = (void *)*v18;
        }
        *(_DWORD *)buf = 136315394;
        unsigned int v27 = v18;
        __int16 v28 = 2080;
        uint64_t v29 = "ConnectRM";
        _os_log_impl(&dword_21B4DD000, v17, OS_LOG_TYPE_DEFAULT, "[%s|%s] Invalid head tracking mode.", buf, 0x16u);
      }
      uint64_t v8 = 103;
    }
    else
    {
      [v6 setClientMode:qword_21B5510E0[a2 - 1]];
      uint64_t v11 = [objc_alloc((Class)getRMMediaSessionClass()) _initWithOptions:v6];
      id v12 = a1[4];
      a1[4] = (id)v11;

      if ([a1[4] _start])
      {
        [getRMMediaSessionClass() defaultFaceToDevicePitchAngle];
        *(float *)&double v13 = v13;
        *((_DWORD *)a1 + 11) = LODWORD(v13);
        *((unsigned char *)a1 + 42) = 1;
        *((_DWORD *)a1 + 12) = a2;
        *((unsigned char *)a1 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
        AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode((AudioDSP::Core::HeadTracker::Implementation *)a1, 1);
        uint64_t v15 = AudioDSP::Core::getADCHeadTrackerLog(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          char v16 = *a1;
          if (*((char *)*a1 + 23) < 0) {
            char v16 = (void *)*v16;
          }
          *(_DWORD *)buf = 136315394;
          unsigned int v27 = v16;
          __int16 v28 = 2080;
          uint64_t v29 = "ConnectRM";
          _os_log_impl(&dword_21B4DD000, v15, OS_LOG_TYPE_DEFAULT, "[%s|%s] RelativeMotion MediaSession has started.", buf, 0x16u);
        }

        goto LABEL_25;
      }
      id v20 = a1[4];
      a1[4] = 0;

      uint64_t v17 = AudioDSP::Core::getADCHeadTrackerLog(v21);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = *a1;
        if (*((char *)*a1 + 23) < 0) {
          uint64_t v22 = (void *)*v22;
        }
        *(_DWORD *)buf = 136315394;
        unsigned int v27 = v22;
        __int16 v28 = 2080;
        uint64_t v29 = "ConnectRM";
        _os_log_impl(&dword_21B4DD000, v17, OS_LOG_TYPE_DEFAULT, "[%s|%s] Could not initialize RelativeMotion MediaSession.", buf, 0x16u);
      }
      uint64_t v8 = 104;
    }

    goto LABEL_44;
  }
  if (!a2)
  {
    uint64_t v8 = 4294900553;
    int v6 = AudioDSP::Core::getADCHeadTrackerLog(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      AudioDSP::Core::HeadTracker::Implementation::ConnectRM();
    }
    goto LABEL_44;
  }
  if (!v4)
  {
    int v6 = AudioDSP::Core::getADCHeadTrackerLog(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *a1;
      if (*((char *)*a1 + 23) < 0) {
        uint64_t v19 = (void *)*v19;
      }
      *(_DWORD *)buf = 136315394;
      unsigned int v27 = v19;
      __int16 v28 = 2080;
      uint64_t v29 = "ConnectRM";
      _os_log_impl(&dword_21B4DD000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] RelativeMotion is not available.", buf, 0x16u);
    }
    uint64_t v8 = 105;
    goto LABEL_44;
  }
  uint64_t v8 = 0;
LABEL_45:
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v24);
  return v8;
}

void sub_21B5083A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id getRMMediaSessionClass(void)
{
  uint64_t v4 = 0;
  int v5 = &v4;
  uint64_t v6 = 0x2050000000;
  v0 = (void *)getRMMediaSessionClass(void)::softClass;
  uint64_t v7 = getRMMediaSessionClass(void)::softClass;
  if (!getRMMediaSessionClass(void)::softClass)
  {
    v3[0] = MEMORY[0x263EF8330];
    v3[1] = 3221225472;
    v3[2] = ___ZL22getRMMediaSessionClassv_block_invoke;
    v3[3] = &unk_2643A9910;
    v3[4] = &v4;
    ___ZL22getRMMediaSessionClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_21B5084A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getRMMediaSessionOptionsClass(void)
{
  uint64_t v4 = 0;
  int v5 = &v4;
  uint64_t v6 = 0x2050000000;
  v0 = (void *)getRMMediaSessionOptionsClass(void)::softClass;
  uint64_t v7 = getRMMediaSessionOptionsClass(void)::softClass;
  if (!getRMMediaSessionOptionsClass(void)::softClass)
  {
    v3[0] = MEMORY[0x263EF8330];
    v3[1] = 3221225472;
    v3[2] = ___ZL29getRMMediaSessionOptionsClassv_block_invoke;
    v3[3] = &unk_2643A9910;
    v3[4] = &v4;
    ___ZL29getRMMediaSessionOptionsClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_21B508584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(AudioDSP::Core::HeadTracker::Implementation *this, int a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)this + 41);
  if (v3)
  {
    uint64_t v5 = *((void *)this + 9);
    if (v5)
    {
      uint64_t v7 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v7 = (void *)*v7;
      }
      uint64_t v8 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*MEMORY[0x263F88690] + 16))(*MEMORY[0x263F88690], 40, 8);
      *(void *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 16) = 0;
      int v9 = *((_DWORD *)this + 12);
      *(_DWORD *)(v8 + 24) = a2;
      *(_DWORD *)(v8 + 28) = v9;
      *(void *)(v8 + 32) = v7;
      *(void *)uint64_t v8 = &unk_26CB57A58;
      MEMORY[0x270F87AB8](v5, v8);
    }
    else
    {
      long long v10 = AudioDSP::Core::getADCHeadTrackerLog(this);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void **)this;
        if (*(char *)(*(void *)this + 23) < 0) {
          uint64_t v11 = (void *)*v11;
        }
        int v12 = 136315394;
        double v13 = v11;
        __int16 v14 = 2080;
        uint64_t v15 = "SetBluetoothLowLatencyMode";
        _os_log_impl(&dword_21B4DD000, v10, OS_LOG_TYPE_DEFAULT, "[%s|%s] Messenger was not initialized. Bluetooth latency mode could not be updated.", (uint8_t *)&v12, 0x16u);
      }
    }
  }
  else
  {
    uint64_t v4 = AudioDSP::Core::getADCHeadTrackerLog(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode();
    }
  }
}

uint64_t AudioDSP::Core::HeadTracker::Implementation::DisconnectRM(AudioDSP::Core::HeadTracker::Implementation *this)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v8 = (char *)this + 56;
  LOBYTE(v9) = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 56);
  if (*((unsigned char *)this + 42))
  {
    *((unsigned char *)this + 42) = 0;
    *((_DWORD *)this + 11) = 0;
    unsigned __int8 v2 = (caulk::concurrent::messenger *)*((void *)this + 9);
    if (v2) {
      caulk::concurrent::messenger::drain(v2);
    }
    [*((id *)this + 4) _stop:v8, v9];
    unsigned __int8 v3 = (void *)*((void *)this + 4);
    *((void *)this + 4) = 0;

    AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(this, 0);
    uint64_t v5 = AudioDSP::Core::getADCHeadTrackerLog(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v11 = v6;
      __int16 v12 = 2080;
      double v13 = "DisconnectRM";
      _os_log_impl(&dword_21B4DD000, v5, OS_LOG_TYPE_DEFAULT, "[%s|%s] RelativeMotion MediaSession has stopped.", buf, 0x16u);
    }
  }
  return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v8);
}

void sub_21B508890(_Unwind_Exception *exception_object)
{
}

unint64_t AudioDSP::Core::HeadTracker::Implementation::GetCurrentHeadPose(AudioDSP::Core::HeadTracker::Implementation *this, float32x4_t *a2, BOOL *a3)
{
  *a2 = (float32x4_t)xmmword_21B5510A0;
  uint64_t v14 = (char *)this + 56;
  int v6 = caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock((uint64_t)this + 56);
  char v15 = v6;
  if (!v6)
  {
    unint64_t v8 = 102;
    goto LABEL_23;
  }
  if (!*((unsigned char *)this + 42))
  {
    unint64_t v8 = 107;
    goto LABEL_23;
  }
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)this + 12);
  if ((v7 & 1) == 0)
  {
    *a3 = 1;
    if (!*((unsigned char *)this + 40))
    {
      *((unsigned char *)this + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 1;
      AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(this, 0);
    }
    unint64_t v8 = 109;
    goto LABEL_23;
  }
  double v12 = 0.0;
  uint64_t v9 = [*((id *)this + 4) _currentAudioListenerPose:v13 timestamp:&v12];
  if (v12 > 0.0)
  {
    unint64_t v8 = v9;
    if (v9 == 4)
    {
      if (*((unsigned char *)this + 40)) {
        goto LABEL_22;
      }
      int v10 = 0;
    }
    else
    {
      if (!*((unsigned char *)this + 40) || v9)
      {
LABEL_20:
        if (v8 > 4 || ((1 << v8) & 0x15) == 0) {
          goto LABEL_23;
        }
LABEL_22:
        unint64_t v8 = 0;
        *a2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v13[0]), v13[1]);
        *a3 = *((unsigned char *)this + 40);
        goto LABEL_23;
      }
      int v10 = 1;
    }
    *((unsigned char *)this + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v10 ^ 1;
    AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(this, v10);
    goto LABEL_20;
  }
  *a3 = 1;
  if (!*((unsigned char *)this + 40))
  {
    *((unsigned char *)this + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 1;
    AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(this, 0);
  }
  unint64_t v8 = 106;
LABEL_23:
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v14);
  return v8;
}

void sub_21B508A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AudioDSP::Core::HeadTracker::Implementation::SetCanAccessHALAPIs(AudioDSP::Core::HeadTracker::Implementation *this, int a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v11 = (char *)this + 56;
  char v12 = 1;
  uint64_t v4 = (AudioDSP::Core *)caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock((uint64_t)this + 56);
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)this + 41);
  if ((v5 & 1) != a2)
  {
    atomic_store(a2, (unsigned __int8 *)this + 41);
    int v6 = AudioDSP::Core::getADCHeadTrackerLog(v4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v7 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        unsigned __int8 v7 = (void *)*v7;
      }
      unint64_t v8 = "false";
      *(_DWORD *)buf = 136315650;
      uint64_t v14 = v7;
      __int16 v15 = 2080;
      uint64_t v16 = "SetCanAccessHALAPIs";
      if (a2) {
        unint64_t v8 = "true";
      }
      __int16 v17 = 2080;
      uint64_t v18 = v8;
      _os_log_impl(&dword_21B4DD000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] CanAccessHALAPIs = %s", buf, 0x20u);
    }

    unsigned __int8 v9 = atomic_load((unsigned __int8 *)this + 41);
    if (v9) {
      AudioDSP::Core::HeadTracker::Implementation::Initialize(this);
    }
    else {
      std::unique_ptr<caulk::concurrent::messenger>::reset[abi:ne180100]((uint64_t *)this + 9, 0);
    }
  }
  return std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v11);
}

void sub_21B508B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t AudioDSP::Core::HeadTracker::CanAccessHALAPIs(AudioDSP::Core::HeadTracker *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(*((void *)this + 3) + 41));
  return v1 & 1;
}

AudioDSP::Core *AudioDSP::Core::HeadTracker::Implementation::GetUserChoice(AudioDSP::Core::HeadTracker::Implementation *this, AudioObjectID a2, unsigned int *a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  outCFDataRef Data = 0x100000000;
  int v6 = [MEMORY[0x263F086E0] mainBundle];
  uint64_t v7 = [v6 bundleIdentifier];

  inQualifierCFDataRef Data = v7;
  *(void *)&inAddress.mSelector = 0x676C6F6273706366;
  inAddress.mElement = 0;
  UInt32 ioDataSize = 8;
  PropertyCFDataRef Data = (AudioDSP::Core *)AudioObjectGetPropertyData(a2, &inAddress, 8u, &inQualifierData, &ioDataSize, &outData);
  unsigned __int8 v9 = AudioDSP::Core::getADCHeadTrackerLog(PropertyData);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(void **)this;
    if (*(char *)(*(void *)this + 23) < 0) {
      int v10 = (void *)*v10;
    }
    int v11 = BYTE4(outData);
    char v12 = [MEMORY[0x263F086E0] mainBundle];
    id v13 = [v12 bundleIdentifier];
    uint64_t v14 = [v13 UTF8String];
    inAddress.mSelector = 136315906;
    *(void *)&inAddress.mScope = v10;
    __int16 v23 = 2080;
    float v24 = "GetUserChoice";
    __int16 v25 = 1024;
    int v26 = v11;
    __int16 v27 = 2080;
    uint64_t v28 = v14;
    _os_log_impl(&dword_21B4DD000, v9, OS_LOG_TYPE_DEFAULT, "[%s|%s] Accessibility option for head tracking = %u, client BundleID = %s", (uint8_t *)&inAddress, 0x26u);
  }
  if (PropertyData)
  {
    uint64_t v16 = AudioDSP::Core::getADCHeadTrackerLog(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v17 = *(void **)this;
      if (*(char *)(*(void *)this + 23) < 0) {
        __int16 v17 = (void *)*v17;
      }
      inAddress.mSelector = 136315650;
      *(void *)&inAddress.mScope = v17;
      __int16 v23 = 2080;
      float v24 = "GetUserChoice";
      __int16 v25 = 1024;
      int v26 = (int)PropertyData;
      _os_log_impl(&dword_21B4DD000, v16, OS_LOG_TYPE_DEFAULT, "[%s|%s] Accessibility option for head tracking is unavailable. Error: %d", (uint8_t *)&inAddress, 0x1Cu);
    }
  }
  else
  {
    *a3 = BYTE4(outData);
  }
  return PropertyData;
}

void sub_21B508DCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void AudioDSP::Core::HeadTracker::HeadTracker(std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v3 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  operator new();
}

void sub_21B508F2C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  uint64_t *v2 = 0;
  if (v4) {
    std::default_delete<AudioDSP::Core::HeadTracker::Implementation>::operator()[abi:ne180100]((uint64_t)v2, v4);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *___ZN8AudioDSP4Core11HeadTrackerC2ERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, BOOL *a4)
{
  return CASmartPreferences::Read((CASmartPreferences *)@"disable_head_tracking", @"com.apple.coreaudio", (const __CFString *)(*(void *)(*(void *)(a1 + 32) + 24) + 13), a4);
}

void *CASmartPreferences::Read(CASmartPreferences *this, const __CFString *a2, const __CFString *a3, BOOL *a4)
{
  v5[4] = *MEMORY[0x263EF8340];
  v5[0] = &unk_26CB572C0;
  v5[1] = a3;
  v5[3] = v5;
  CASmartPreferences::AddHandler<BOOL>(this, a2, (uint64_t)CASmartPreferences::InterpretBoolean, (uint64_t)v5);
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v5);
}

void sub_21B509034(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void AudioDSP::Core::HeadTracker::HeadTracker(std::string *this, const void *a2)
{
  caulk::make_string((caulk *)"%p", (uint64_t)&__p, a2);
  AudioDSP::Core::HeadTracker::HeadTracker(this, &__p);
}

{
  long long __p;

  caulk::make_string((caulk *)"%p", (uint64_t)&__p, a2);
  AudioDSP::Core::HeadTracker::HeadTracker(this, &__p);
}

void sub_21B5090B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void caulk::make_string(caulk *this@<X0>, uint64_t a2@<X8>, ...)
{
  va_start(va, a2);
  int v5 = vsnprintf(0, 0, (const char *)this, va);
  if (v5 <= 0)
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    std::string::resize((std::string *)a2, (v5 + 1), 0);
    int v6 = *(char *)(a2 + 23);
    if (v6 >= 0) {
      uint64_t v7 = (char *)a2;
    }
    else {
      uint64_t v7 = *(char **)a2;
    }
    if (v6 >= 0) {
      size_t v8 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      size_t v8 = *(void *)(a2 + 8);
    }
    int v9 = vsnprintf(v7, v8, (const char *)this, va);
    std::string::resize((std::string *)a2, v9, 0);
  }
}

void sub_21B5091DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void AudioDSP::Core::HeadTracker::~HeadTracker(AudioDSP::Core::HeadTracker::Implementation **this)
{
  unsigned __int8 v2 = (uint64_t *)(this + 3);
  AudioDSP::Core::HeadTracker::Implementation::DisconnectRM(this[3]);
  AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener((AudioDSP::Core::HeadTracker *)this);
  uint64_t v3 = *v2;
  uint64_t *v2 = 0;
  if (v3) {
    std::default_delete<AudioDSP::Core::HeadTracker::Implementation>::operator()[abi:ne180100]((uint64_t)v2, v3);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*this);
  }
}

uint64_t AudioDSP::Core::HeadTracker::DisconnectRM(AudioDSP::Core::HeadTracker::Implementation **this)
{
  return AudioDSP::Core::HeadTracker::Implementation::DisconnectRM(this[3]);
}

void AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener(AudioDSP::Core::HeadTracker *this)
{
  uint64_t v1 = this;
  uint64_t v28 = *MEMORY[0x263EF8340];
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(*((void *)this + 3) + 41));
  if (v2)
  {
    atomic_store(1u, (unsigned __int8 *)(*((void *)this + 3) + 12));
    uint64_t v18 = *((void *)this + 3) + 16;
    char v19 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v18);
    uint64_t v4 = (AudioDSP::Core *)*(unsigned int *)(*((void *)v1 + 3) + 8);
    if (!v4)
    {
      uint64_t v14 = AudioDSP::Core::getADCHeadTrackerLog(v4);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener();
      }

      goto LABEL_22;
    }
    *(void *)&v17.mSelector = 0x676C6F6273706366;
    v17.mElement = 0;
    int v5 = (AudioDSP::Core *)AudioObjectRemovePropertyListener((AudioObjectID)v4, &v17, (AudioObjectPropertyListenerProc)AudioDSP::Core::HeadTracker::CallbackFunction, v1);
    int v6 = (int)v5;
    uint64_t v7 = AudioDSP::Core::getADCHeadTrackerLog(v5);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v8)
      {
        int v9 = v1;
        if (*((char *)v1 + 23) < 0) {
          int v9 = *(AudioDSP::Core::HeadTracker **)v1;
        }
        int v10 = *(_DWORD *)(*((void *)v1 + 3) + 8);
        *(_DWORD *)buf = 136315906;
        unint64_t v21 = v9;
        __int16 v22 = 2080;
        __int16 v23 = "UnregisterUserChoiceListener";
        __int16 v24 = 1024;
        int v25 = v10;
        __int16 v26 = 1024;
        int v27 = v6;
        int v11 = "[%s|%s] Failed to unregister SpatialConfig listener. Device ID: %u. Error: %d";
        char v12 = v7;
        uint32_t v13 = 34;
LABEL_20:
        _os_log_impl(&dword_21B4DD000, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
      }
    }
    else if (v8)
    {
      __int16 v15 = v1;
      if (*((char *)v1 + 23) < 0) {
        __int16 v15 = *(AudioDSP::Core::HeadTracker **)v1;
      }
      int v16 = *(_DWORD *)(*((void *)v1 + 3) + 8);
      *(_DWORD *)buf = 136315650;
      unint64_t v21 = v15;
      __int16 v22 = 2080;
      __int16 v23 = "UnregisterUserChoiceListener";
      __int16 v24 = 1024;
      int v25 = v16;
      int v11 = "[%s|%s] SpatialConfig listener is unregistered for device ID: %u";
      char v12 = v7;
      uint32_t v13 = 28;
      goto LABEL_20;
    }

    *(_DWORD *)(*((void *)v1 + 3) + 8) = 0;
LABEL_22:
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v18);
    return;
  }
  uint64_t v3 = AudioDSP::Core::getADCHeadTrackerLog(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)v1 + 23) < 0) {
      uint64_t v1 = *(AudioDSP::Core::HeadTracker **)v1;
    }
    *(_DWORD *)buf = 136315394;
    unint64_t v21 = v1;
    __int16 v22 = 2080;
    __int16 v23 = "UnregisterUserChoiceListener";
    _os_log_impl(&dword_21B4DD000, v3, OS_LOG_TYPE_DEFAULT, "[%s|%s] Host disallowed HAL API access. Control center listener is not available.", buf, 0x16u);
  }
}

void sub_21B5094E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AudioDSP::Core::HeadTracker::Initialize(uint64_t a1, __int16 a2)
{
  if ((a2 & 0xFF00) != 0) {
    AudioDSP::Core::HeadTracker::Implementation::SetCanAccessHALAPIs(*(AudioDSP::Core::HeadTracker::Implementation **)(a1 + 24), a2 != 0);
  }
  uint64_t v3 = *(AudioDSP::Core::HeadTracker::Implementation **)(a1 + 24);

  return AudioDSP::Core::HeadTracker::Implementation::Initialize(v3);
}

uint64_t AudioDSP::Core::HeadTracker::SetCanAccessHALAPIs(AudioDSP::Core::HeadTracker::Implementation **this, int a2)
{
  return AudioDSP::Core::HeadTracker::Implementation::SetCanAccessHALAPIs(this[3], a2);
}

uint64_t AudioDSP::Core::HeadTracker::ConnectRM(uint64_t a1, unsigned int a2)
{
  unsigned __int8 v2 = *(AudioDSP::Core **)(a1 + 24);
  if (*((unsigned char *)v2 + 13))
  {
    uint64_t v3 = AudioDSP::Core::getADCHeadTrackerLog(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      AudioDSP::Core::HeadTracker::ConnectRM();
    }
LABEL_7:

    return 108;
  }
  if (*((unsigned char *)v2 + 14))
  {
    uint64_t v3 = AudioDSP::Core::getADCHeadTrackerLog(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      AudioDSP::Core::HeadTracker::ConnectRM();
    }
    goto LABEL_7;
  }

  return AudioDSP::Core::HeadTracker::Implementation::ConnectRM((id *)v2, a2);
}

uint64_t AudioDSP::Core::HeadTracker::HasActiveRMConnection(AudioDSP::Core::HeadTracker *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v4 = v1 + 56;
  char v5 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v1 + 56);
  uint64_t v2 = *(unsigned __int8 *)(v1 + 42);
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v4);
  return v2;
}

unint64_t AudioDSP::Core::HeadTracker::GetCurrentHeadPose(AudioDSP::Core::HeadTracker::Implementation **this, float32x4_t *a2)
{
  return AudioDSP::Core::HeadTracker::Implementation::GetCurrentHeadPose(this[3], a2, &v3);
}

unint64_t AudioDSP::Core::HeadTracker::GetCurrentHeadPose(AudioDSP::Core::HeadTracker::Implementation **this, float32x4_t *a2, BOOL *a3)
{
  return AudioDSP::Core::HeadTracker::Implementation::GetCurrentHeadPose(this[3], a2, a3);
}

uint64_t AudioDSP::Core::HeadTracker::IsEnable(AudioDSP::Core::HeadTracker *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(*((void *)this + 3) + 12));
  return v1 & 1;
}

float AudioDSP::Core::HeadTracker::GetAppliedFaceToDevicePitchAngleOffset(AudioDSP::Core::HeadTracker *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v4 = v1 + 56;
  char v5 = 1;
  caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v1 + 56);
  float v2 = *(float *)(v1 + 44);
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v4);
  return v2;
}

float AudioDSP::Core::HeadTracker::GetDefaultFaceToDevicePitchAngleOffset(AudioDSP::Core::HeadTracker *this)
{
  [getRMMediaSessionClass() defaultFaceToDevicePitchAngle];
  return v1;
}

BOOL AudioDSP::Core::HeadTracker::HardwareSupportsHeadTracking(AudioDSP::Core::HeadTracker *this, unsigned int *a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  DeviceOrPortID = (AudioDSP::Core *)AudioDSPCoreUtility::GetDeviceOrPortID(this, a2);
  int v4 = (int)DeviceOrPortID;
  if (DeviceOrPortID || (DeviceOrPortID = (AudioDSP::Core *)*(unsigned int *)this, !DeviceOrPortID))
  {
    int v11 = AudioDSP::Core::getADCHeadTrackerLog(DeviceOrPortID);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      ioDataSize.mSelector = 136315394;
      *(void *)&ioDataSize.mScope = "HardwareSupportsHeadTracking";
      __int16 v29 = 1024;
      int v30 = v4;
      _os_log_impl(&dword_21B4DD000, v11, OS_LOG_TYPE_DEFAULT, "%s: Could not extract device ID. Error %d", (uint8_t *)&ioDataSize, 0x12u);
    }

    goto LABEL_15;
  }
  *(void *)&inAddress.mSelector = 0x676C6F6262747366;
  inAddress.mElement = 0;
  HasProperty = (AudioDSP::Core *)AudioObjectHasProperty((AudioObjectID)DeviceOrPortID, &inAddress);
  if (!HasProperty)
  {
    char v12 = AudioDSP::Core::getADCHeadTrackerLog(HasProperty);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)this;
      ioDataSize.mSelector = 136315394;
      *(void *)&ioDataSize.mScope = "HardwareSupportsHeadTracking";
      __int16 v29 = 1024;
      int v30 = v13;
      _os_log_impl(&dword_21B4DD000, v12, OS_LOG_TYPE_DEFAULT, "%s: Head-tracking is not supported, feature dictionary not available. Device ID: %d", (uint8_t *)&ioDataSize, 0x12u);
    }

    goto LABEL_15;
  }
  outCFDataRef Data = 0;
  AudioObjectID v6 = *(_DWORD *)this;
  ioDataSize.mSelector = 8;
  PropertyCFDataRef Data = (AudioDSP::Core *)AudioObjectGetPropertyData(v6, &inAddress, 0, 0, &ioDataSize.mSelector, &outData);
  int v8 = (int)PropertyData;
  if (PropertyData)
  {
    int v9 = AudioDSP::Core::getADCHeadTrackerLog(PropertyData);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)this;
      ioDataSize.mSelector = 136315650;
      *(void *)&ioDataSize.mScope = "HardwareSupportsHeadTracking";
      __int16 v29 = 1024;
      int v30 = v8;
      __int16 v31 = 1024;
      int v32 = v10;
      _os_log_impl(&dword_21B4DD000, v9, OS_LOG_TYPE_DEFAULT, "%s: Head-tracking is not supported, Error %d, Device ID: %d", (uint8_t *)&ioDataSize, 0x18u);
    }

    if (outData) {
      CFRelease(outData);
    }
LABEL_15:
    BOOL v14 = 0;
LABEL_16:
    *(_DWORD *)this = 0;
    return v14;
  }
  applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, outData);
  if (!cf)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  int v16 = (AudioDSP::Core *)applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[52]>((const __CFDictionary *)cf, "kBluetoothAudioDeviceFeatureHeadTrackedSpatialAudio");
  if ((unsigned __int16)v16 <= 0x100u) {
    char v17 = 0;
  }
  else {
    char v17 = (char)v16;
  }
  if (!v17)
  {
    uint64_t v18 = AudioDSP::Core::getADCHeadTrackerLog(v16);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *(_DWORD *)this;
      ioDataSize.mSelector = 136315394;
      *(void *)&ioDataSize.mScope = "HardwareSupportsHeadTracking";
      __int16 v29 = 1024;
      int v30 = v19;
      _os_log_impl(&dword_21B4DD000, v18, OS_LOG_TYPE_DEFAULT, "%s: Head-tracking is not supported, HeadTrackedSpatialAudio = false. Device ID: %d", (uint8_t *)&ioDataSize, 0x12u);
    }

    *(_DWORD *)this = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  if (!v17) {
    return 0;
  }
  LODWORD(cf) = 0;
  AudioObjectID v20 = *(_DWORD *)this;
  *(void *)&ioDataSize.mSelector = 0x676C6F6273706873;
  ioDataSize.mElement = 0;
  LODWORD(outData) = 4;
  unint64_t v21 = (AudioDSP::Core *)AudioObjectGetPropertyData(v20, &ioDataSize, 0, 0, (UInt32 *)&outData, &cf);
  if (v21)
  {
    __int16 v22 = AudioDSP::Core::getADCHeadTrackerLog(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      ioDataSize.mSelector = 136315138;
      *(void *)&ioDataSize.mScope = "HardwareSupportsHeadTracking";
      _os_log_impl(&dword_21B4DD000, v22, OS_LOG_TYPE_DEFAULT, "%s: Error getting HAL property.", (uint8_t *)&ioDataSize, 0xCu);
    }
  }
  BOOL v14 = cf != 0;
  if (!cf)
  {
    __int16 v23 = AudioDSP::Core::getADCHeadTrackerLog(v21);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      ioDataSize.mSelector = 136315138;
      *(void *)&ioDataSize.mScope = "HardwareSupportsHeadTracking";
      _os_log_impl(&dword_21B4DD000, v23, OS_LOG_TYPE_DEFAULT, "%s: Head-tracking is disabled by the user.", (uint8_t *)&ioDataSize, 0xCu);
    }

    goto LABEL_16;
  }
  return v14;
}

void sub_21B509B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void AudioDSP::Core::HeadTracker::RegisterUserChoiceListener(AudioDSP::Core::HeadTracker *this, unsigned int *a2)
{
  float v2 = this;
  uint64_t v35 = *MEMORY[0x263EF8340];
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(*((void *)this + 3) + 41));
  if (v3)
  {
    AudioObjectID inObjectID = 0;
    BOOL v5 = AudioDSP::Core::HeadTracker::HardwareSupportsHeadTracking((AudioDSP::Core::HeadTracker *)&inObjectID, a2);
    uint64_t v24 = *((void *)v2 + 3) + 16;
    char v25 = 1;
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(v24);
    AudioObjectID v6 = inObjectID;
    if (inObjectID) {
      BOOL v7 = v5;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      int v8 = *(_DWORD *)(*((void *)v2 + 3) + 8);
      if (inObjectID == v8)
      {
        int v9 = AudioDSP::Core::getADCHeadTrackerLog((AudioDSP::Core *)inObjectID);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = v2;
          if (*((char *)v2 + 23) < 0) {
            int v10 = *(AudioDSP::Core::HeadTracker **)v2;
          }
          *(_DWORD *)buf = 136315650;
          uint64_t v28 = v10;
          __int16 v29 = 2080;
          int v30 = "RegisterUserChoiceListener";
          __int16 v31 = 1024;
          AudioObjectID v32 = inObjectID;
          _os_log_impl(&dword_21B4DD000, v9, OS_LOG_TYPE_DEFAULT, "[%s|%s] SpatialConfig listener is already registered for device ID: %u", buf, 0x1Cu);
        }
      }
      else
      {
        if (v8)
        {
          AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener(v2);
          AudioObjectID v6 = inObjectID;
        }
        *(void *)&inAddress.mSelector = 0x676C6F6273706366;
        inAddress.mElement = 0;
        char v12 = (AudioDSP::Core *)AudioObjectAddPropertyListener(v6, &inAddress, (AudioObjectPropertyListenerProc)AudioDSP::Core::HeadTracker::CallbackFunction, v2);
        int v13 = (int)v12;
        BOOL v14 = AudioDSP::Core::getADCHeadTrackerLog(v12);
        __int16 v15 = v14;
        if (v13)
        {
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            unint64_t v21 = v2;
            if (*((char *)v2 + 23) < 0) {
              unint64_t v21 = *(AudioDSP::Core::HeadTracker **)v2;
            }
            *(_DWORD *)buf = 136315906;
            uint64_t v28 = v21;
            __int16 v29 = 2080;
            int v30 = "RegisterUserChoiceListener";
            __int16 v31 = 1024;
            AudioObjectID v32 = inObjectID;
            __int16 v33 = 1024;
            int v34 = v13;
            _os_log_error_impl(&dword_21B4DD000, v15, OS_LOG_TYPE_ERROR, "[%s|%s] Failed to register SpatialConfig listener for device ID: %u. Error: %d", buf, 0x22u);
          }
        }
        else
        {
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = v2;
            if (*((char *)v2 + 23) < 0) {
              int v16 = *(AudioDSP::Core::HeadTracker **)v2;
            }
            *(_DWORD *)buf = 136315650;
            uint64_t v28 = v16;
            __int16 v29 = 2080;
            int v30 = "RegisterUserChoiceListener";
            __int16 v31 = 1024;
            AudioObjectID v32 = inObjectID;
            _os_log_impl(&dword_21B4DD000, v15, OS_LOG_TYPE_DEFAULT, "[%s|%s] SpatialConfig listener is registered for device ID: %u.", buf, 0x1Cu);
          }

          unsigned int v22 = 0;
          UserChoice = AudioDSP::Core::HeadTracker::Implementation::GetUserChoice(*((AudioDSP::Core::HeadTracker::Implementation **)v2 + 3), inObjectID, &v22);
          if (!UserChoice)
          {
            uint64_t v18 = AudioDSP::Core::getADCHeadTrackerLog(UserChoice);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              int v19 = v2;
              if (*((char *)v2 + 23) < 0) {
                int v19 = *(AudioDSP::Core::HeadTracker **)v2;
              }
              unsigned int v20 = v22;
              *(_DWORD *)buf = 136315650;
              uint64_t v28 = v19;
              __int16 v29 = 2080;
              int v30 = "RegisterUserChoiceListener";
              __int16 v31 = 1024;
              AudioObjectID v32 = v22;
              _os_log_impl(&dword_21B4DD000, v18, OS_LOG_TYPE_DEFAULT, "[%s|%s] Setting mIsEnabled = %u.", buf, 0x1Cu);
            }
            else
            {
              unsigned int v20 = v22;
            }

            atomic_store(v20 != 0, (unsigned __int8 *)(*((void *)v2 + 3) + 12));
          }
        }
      }
    }
    else
    {
      int v11 = AudioDSP::Core::getADCHeadTrackerLog((AudioDSP::Core *)inObjectID);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        AudioDSP::Core::HeadTracker::RegisterUserChoiceListener();
      }

      if (*(_DWORD *)(*((void *)v2 + 3) + 8)) {
        AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener(v2);
      }
    }
    *(_DWORD *)(*((void *)v2 + 3) + 8) = inObjectID;
    std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)&v24);
  }
  else
  {
    int v4 = AudioDSP::Core::getADCHeadTrackerLog(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v2 + 23) < 0) {
        float v2 = *(AudioDSP::Core::HeadTracker **)v2;
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v28 = v2;
      __int16 v29 = 2080;
      int v30 = "RegisterUserChoiceListener";
      _os_log_impl(&dword_21B4DD000, v4, OS_LOG_TYPE_DEFAULT, "[%s|%s] Host disallowed HAL API access. Control center listener is not available.", buf, 0x16u);
    }
  }
}

void sub_21B509F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

AudioDSP::Core *AudioDSP::Core::HeadTracker::CallbackFunction(AudioDSP::Core::HeadTracker *this, unsigned int a2, unsigned int a3, const AudioObjectPropertyAddress *a4, void *a5)
{
  BOOL v5 = a4;
  uint64_t v19 = *MEMORY[0x263EF8340];
  unsigned int v12 = 0;
  UserChoice = AudioDSP::Core::HeadTracker::Implementation::GetUserChoice(*(AudioDSP::Core::HeadTracker::Implementation **)&a4[2].mSelector, (AudioObjectID)this, &v12);
  BOOL v7 = UserChoice;
  if (!UserChoice)
  {
    unsigned int v8 = v12;
    atomic_store(v12 != 0, (unsigned __int8 *)(*(void *)&v5[2].mSelector + 12));
    int v9 = AudioDSP::Core::getADCHeadTrackerLog(UserChoice);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (SHIBYTE(v5[1].mElement) < 0) {
        BOOL v5 = *(const AudioObjectPropertyAddress **)&v5->mSelector;
      }
      int v10 = "enabled";
      *(_DWORD *)buf = 136315650;
      BOOL v14 = v5;
      __int16 v15 = 2080;
      int v16 = "CallbackFunction";
      if (!v8) {
        int v10 = "disabled";
      }
      __int16 v17 = 2080;
      uint64_t v18 = v10;
      _os_log_impl(&dword_21B4DD000, v9, OS_LOG_TYPE_DEFAULT, "[%s|%s] User has %s head-tracking.", buf, 0x20u);
    }
  }
  return v7;
}

Class ___ZL22getRMMediaSessionClassv_block_invoke(uint64_t a1)
{
  RelativeMotionLibrary();
  Class result = objc_getClass("RMMediaSession");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    ___ZL22getRMMediaSessionClassv_block_invoke_cold_1();
  }
  getRMMediaSessionClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void RelativeMotionLibrary(void)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  v1[0] = 0;
  if (!RelativeMotionLibraryCore(char **)::frameworkLibrary)
  {
    v1[1] = MEMORY[0x263EF8330];
    v1[2] = 3221225472;
    v1[3] = ___ZL25RelativeMotionLibraryCorePPc_block_invoke;
    v1[4] = &__block_descriptor_40_e5_v8__0l;
    v1[5] = v1;
    long long v2 = xmmword_2643A9930;
    uint64_t v3 = 0;
    RelativeMotionLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  v0 = (void *)v1[0];
  if (!RelativeMotionLibraryCore(char **)::frameworkLibrary)
  {
    v0 = (void *)abort_report_np();
    goto LABEL_7;
  }
  if (v1[0]) {
LABEL_7:
  }
    free(v0);
}

uint64_t ___ZL25RelativeMotionLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  RelativeMotionLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

Class ___ZL29getRMMediaSessionOptionsClassv_block_invoke(uint64_t a1)
{
  RelativeMotionLibrary();
  Class result = objc_getClass("RMMediaSessionOptions");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    ___ZL29getRMMediaSessionOptionsClassv_block_invoke_cold_1();
  }
  getRMMediaSessionOptionsClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *CASmartPreferences::AddHandler<BOOL>(CASmartPreferences *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unsigned int v8 = CASmartPreferences::instance(a1);
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)v11, a4);
  int v13 = 0;
  int v9 = operator new(0x30uLL);
  *int v9 = &unk_26CB57278;
  v9[1] = a3;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)(v9 + 2), (uint64_t)v11);
  int v13 = v9;
  CASmartPreferences::_RegisterFirstHandler((uint64_t)v8, a1, a2, (uint64_t)v12);
  std::__function::__value_func<BOOL ()(void const*)>::~__value_func[abi:ne180100](v12);
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v11);
}

void sub_21B50A3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<BOOL ()(void const*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](v6);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

{
  void *v3;
  uint64_t v4;

  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::~__func(void *a1)
{
  *a1 = &unk_26CB57278;
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::~__func(void *a1)
{
  *a1 = &unk_26CB57278;
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x21D48F780);
}

void *std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::__clone(uint64_t a1)
{
  long long v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26CB57278;
  v2[1] = v3;
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_21B50A57C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26CB57278;
  a2[1] = v2;
  return std::__function::__value_func<void ()(BOOL)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

BOOL std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  return std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1} &,void const*>((uint64_t (**)(uint64_t, char *))(a1 + 8), a2);
}

BOOL std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1} &,void const*>(uint64_t (**a1)(uint64_t, char *), uint64_t *a2)
{
  uint64_t v3 = *a2;
  char v6 = 0;
  char v4 = (*a1)(v3, &v6);
  if (!v6) {
    return 0;
  }
  std::function<void ()(BOOL)>::operator()((uint64_t)(a1 + 1), v4);
  return v6 != 0;
}

uint64_t std::function<void ()(BOOL)>::operator()(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

void *std::__function::__value_func<BOOL ()(void const*)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1},std::allocator<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1}>,void ()(BOOL)>::~__func()
{
}

void *std::__function::__func<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1},std::allocator<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t a1)
{
  Class result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *Class result = &unk_26CB572C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1},std::allocator<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26CB572C0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1},std::allocator<CASmartPreferences::Read(__CFString const*,__CFString const*,BOOL &)::{lambda(BOOL)#1}>,void ()(BOOL)>::operator()(uint64_t result, unsigned char *a2)
{
  **(unsigned char **)(result + 8) = *a2;
  return result;
}

void *std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::unique_ptr<caulk::concurrent::messenger>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    MEMORY[0x21D48F330]();
    JUMPOUT(0x21D48F780);
  }
  return result;
}

pthread_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::lock(uint64_t a1)
{
  pthread_t result = pthread_self();
  unint64_t v3 = (unint64_t)result;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (result)
  {
    if (explicit) {
      BOOL v5 = result == (pthread_t)explicit;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      goto LABEL_9;
    }
  }
  else if (explicit)
  {
LABEL_9:
    pthread_t result = (pthread_t)caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(a1 + 12));
    atomic_store(v3, (unint64_t *)a1);
    int v6 = 1;
    goto LABEL_10;
  }
  int v6 = *(_DWORD *)(a1 + 8) + 1;
LABEL_10:
  *(_DWORD *)(a1 + 8) = v6;
  return result;
}

uint64_t std::unique_lock<caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>>::~unique_lock[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(*(void *)a1);
  }
  return a1;
}

pthread_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock(uint64_t a1)
{
  pthread_t result = pthread_self();
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (result)
  {
    if (explicit) {
      BOOL v4 = result == (pthread_t)explicit;
    }
    else {
      BOOL v4 = 0;
    }
    if (!v4) {
LABEL_11:
    }
      caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock();
  }
  else if (explicit)
  {
    goto LABEL_11;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (v5 <= 0) {
    caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock();
  }
  int v6 = v5 - 1;
  *(_DWORD *)(a1 + 8) = v6;
  if (!v6)
  {
    atomic_store(0, (unint64_t *)a1);
    return (pthread_t)caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(a1 + 12));
  }
  return result;
}

void caulk::concurrent::details::rt_message_call<AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(unsigned int)::$_0,unsigned int &,HeadTrackingMode &,char const*>::~rt_message_call(caulk::concurrent::message *a1)
{
  caulk::concurrent::message::~message(a1);

  JUMPOUT(0x21D48F780);
}

caulk::concurrent::message **caulk::concurrent::details::rt_message_call<AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(unsigned int)::$_0,unsigned int &,HeadTrackingMode &,char const*>::perform(caulk::concurrent::message *a1, unsigned int *a2)
{
  unint64_t v3 = a1;
  caulk::concurrent::details::message_call<AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode::$_0,unsigned int &,HeadTrackingMode &,char const*>::perform((uint64_t)a1, a2);
  return caulk::concurrent::details::rt_message_call<AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode::$_0,unsigned int &,HeadTrackingMode &,char const*>::rt_cleanup::~rt_cleanup(&v3);
}

void sub_21B50AAC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  caulk::concurrent::details::rt_message_call<AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode::$_0,unsigned int &,HeadTrackingMode &,char const*>::rt_cleanup::~rt_cleanup((caulk::concurrent::message **)va);
  _Unwind_Resume(a1);
}

void caulk::concurrent::details::message_call<AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(unsigned int)::$_0,unsigned int &,HeadTrackingMode &,char const*>::perform(uint64_t a1, unsigned int *a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 24);
  int v2 = *(_DWORD *)(a1 + 28);
  uint64_t v4 = *(void *)(a1 + 32);
  AudioObjectID inObjectID = 0;
  DeviceOrPortID = (AudioDSP::Core *)AudioDSPCoreUtility::GetDeviceOrPortID((AudioDSPCoreUtility *)&inObjectID, a2);
  if (DeviceOrPortID || (DeviceOrPortID = (AudioDSP::Core *)inObjectID, !inObjectID))
  {
    unsigned int v8 = AudioDSP::Core::getADCHeadTrackerLog(DeviceOrPortID);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      inAddress.mSelector = 136315394;
      *(void *)&inAddress.mScope = v4;
      __int16 v25 = 2080;
      __int16 v26 = "operator()";
      int v9 = "[%s|%s] Could not update bluetooth low latency mode. Unknown port ID.";
      int v10 = v8;
      uint32_t v11 = 22;
LABEL_32:
      _os_log_impl(&dword_21B4DD000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&inAddress, v11);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  outCFDataRef Data = 0;
  *(void *)&inAddress.mSelector = 0x676C6F627370656ELL;
  inAddress.mElement = 0;
  UInt32 ioDataSize = 4;
  PropertyCFDataRef Data = (AudioDSP::Core *)AudioObjectGetPropertyData(inObjectID, &inAddress, 0, 0, &ioDataSize, &outData);
  if (PropertyData)
  {
    int v7 = (int)PropertyData;
    unsigned int v8 = AudioDSP::Core::getADCHeadTrackerLog(PropertyData);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      inAddress.mSelector = 136315650;
      *(void *)&inAddress.mScope = v4;
      __int16 v25 = 2080;
      __int16 v26 = "operator()";
      __int16 v27 = 1024;
      LODWORD(v28) = v7;
      int v9 = "[%s|%s] Could not get current bluetooth low latency mode. Error %d";
LABEL_31:
      int v10 = v8;
      uint32_t v11 = 28;
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (v3)
  {
    if (v2 == 1)
    {
      int v12 = 1;
    }
    else
    {
      if (v2 == 4 || v2 == 2) {
        int v14 = 1;
      }
      else {
        int v14 = 2;
      }
      int v12 = outData | v14;
    }
  }
  else
  {
    if (v2 == 1)
    {
      outCFDataRef Data = 0;
      goto LABEL_28;
    }
    if (v2 == 4 || v2 == 2) {
      int v16 = -2;
    }
    else {
      int v16 = -3;
    }
    int v12 = outData & v16;
  }
  outCFDataRef Data = v12;
LABEL_28:
  *(void *)&inAddress.mSelector = 0x676C6F627370656ELL;
  inAddress.mElement = 0;
  __int16 v17 = (AudioDSP::Core *)AudioObjectSetPropertyData(inObjectID, &inAddress, 0, 0, 4u, &outData);
  int v18 = (int)v17;
  unsigned int v8 = AudioDSP::Core::getADCHeadTrackerLog(v17);
  BOOL v19 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (!v18)
  {
    if (!v19) {
      goto LABEL_33;
    }
    unsigned int v20 = "enabled";
    inAddress.mSelector = 136315650;
    *(void *)&inAddress.mScope = v4;
    __int16 v25 = 2080;
    __int16 v26 = "operator()";
    if (!v3) {
      unsigned int v20 = "disabled";
    }
    __int16 v27 = 2080;
    uint64_t v28 = v20;
    int v9 = "[%s|%s] Bluetooth low latency mode %s";
    int v10 = v8;
    uint32_t v11 = 32;
    goto LABEL_32;
  }
  if (v19)
  {
    inAddress.mSelector = 136315650;
    *(void *)&inAddress.mScope = v4;
    __int16 v25 = 2080;
    __int16 v26 = "operator()";
    __int16 v27 = 1024;
    LODWORD(v28) = v18;
    int v9 = "[%s|%s] Setting bluetooth low latency mode failed with error %d";
    goto LABEL_31;
  }
LABEL_33:
}

caulk::concurrent::message **caulk::concurrent::details::rt_message_call<AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode(unsigned int)::$_0,unsigned int &,HeadTrackingMode &,char const*>::rt_cleanup::~rt_cleanup(caulk::concurrent::message **a1)
{
  int v2 = *a1;
  caulk::concurrent::message::~message(*a1);
  (*(void (**)(void, caulk::concurrent::message *, uint64_t, uint64_t))(*(void *)*MEMORY[0x263F88690] + 24))(*MEMORY[0x263F88690], v2, 40, 8);
  return a1;
}

uint64_t caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::try_lock(uint64_t a1)
{
  pthread_t v2 = pthread_self();
  unint64_t v3 = (unint64_t)v2;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (v2)
  {
    if (explicit) {
      BOOL v5 = v2 == (pthread_t)explicit;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      goto LABEL_9;
    }
LABEL_7:
    ++*(_DWORD *)(a1 + 8);
    return 1;
  }
  if (!explicit) {
    goto LABEL_7;
  }
LABEL_9:
  uint64_t result = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(a1 + 12));
  if (result)
  {
    atomic_store(v3, (unint64_t *)a1);
    uint64_t result = 1;
    *(_DWORD *)(a1 + 8) = 1;
  }
  return result;
}

void std::default_delete<AudioDSP::Core::HeadTracker::Implementation>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::unique_ptr<caulk::concurrent::messenger>::reset[abi:ne180100]((uint64_t *)(a2 + 72), 0);

    JUMPOUT(0x21D48F780);
  }
}

uint64_t AudioDSP::Core::HeadTracker::Implementation::Implementation(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 12) = 1;
  *(unsigned char *)(a1 + 14) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 28));
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(unsigned char *)(a1 + 41) = a3;
  *(unsigned char *)(a1 + 42) = 0;
  *(void *)(a1 + 44) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((caulk::pooled_semaphore_mutex *)(a1 + 68));
  *(void *)(a1 + 72) = 0;
  return a1;
}

void sub_21B50AF68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,char const(&)[52]>(const __CFDictionary *a1, char *a2)
{
  CFNumberRef v2 = (const __CFNumber *)applesauce::CF::details::at_key<char const(&)[52]>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<BOOL,0>(v2);
    int v3 = BYTE1(v2);
  }
  else
  {
    int v3 = 0;
  }
  return v2 | (v3 << 8);
}

const void *applesauce::CF::details::at_key<char const(&)[52]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B50B07C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t applesauce::CF::convert_as<BOOL,0>(const __CFNumber *a1)
{
  if (!a1) {
    goto LABEL_7;
  }
  CFNumberRef v1 = a1;
  CFTypeID TypeID = CFBooleanGetTypeID();
  if (TypeID != CFGetTypeID(v1))
  {
    CFTypeID v4 = CFNumberGetTypeID();
    if (v4 == CFGetTypeID(v1))
    {
      LOWORD(a1) = applesauce::CF::details::number_convert_as<BOOL>(v1);
      int v3 = BYTE1(a1);
      return a1 | (v3 << 8);
    }
    LOBYTE(a1) = 0;
LABEL_7:
    int v3 = 0;
    return a1 | (v3 << 8);
  }
  LOBYTE(a1) = CFBooleanGetValue(v1) != 0;
  int v3 = 1;
  return a1 | (v3 << 8);
}

void OUTLINED_FUNCTION_1_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void OUTLINED_FUNCTION_2_0(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

double IR::DataResampler<float>::DataResampler(uint64_t a1, int a2, float a3, float a4)
{
  *(void *)a1 = &unk_26CB57A80;
  *(_DWORD *)(a1 + 8) = a2;
  *(float *)(a1 + 12) = a3;
  *(float *)(a1 + 16) = a4;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  double v4 = a3;
  double result = 0.1;
  if (v4 < 0.1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Invalid input sample rate, must be > 0.1)");
    goto LABEL_8;
  }
  if (a4 < 0.1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Invalid output sample rate, must be > 0.1)");
    goto LABEL_8;
  }
  if (!a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Invalid input length, must be > 0)");
LABEL_8:
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  return result;
}

void sub_21B50B2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  std::__optional_destruct_base<CA::AudioSampleRateConverter,false>::~__optional_destruct_base[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

std::logic_error *std::invalid_argument::invalid_argument[abi:ne180100](std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  return result;
}

void *IR::DataResampler<float>::~DataResampler(void *a1)
{
  *a1 = &unk_26CB57A80;
  std::__optional_destruct_base<CA::AudioSampleRateConverter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

{
  *a1 = &unk_26CB57A80;
  std::__optional_destruct_base<CA::AudioSampleRateConverter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(a1 + 3));
  return a1;
}

void IR::DataResampler<float>::~DataResampler(void *a1)
{
  *a1 = &unk_26CB57A80;
  std::__optional_destruct_base<CA::AudioSampleRateConverter,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(a1 + 3));

  JUMPOUT(0x21D48F780);
}

unint64_t IR::DataResampler<float>::Initialize(uint64_t a1, const __CFDictionary **a2)
{
  CFDictionaryRef v3 = *a2;
  unsigned int v4 = 64;
  if (v3)
  {
    unsigned int v6 = 64;
    unsigned int v4 = applesauce::CF::at_or<unsigned int,__CFString const*&>(v3, (const void **)&IR::kIRDataResamplerConfigQualityKey, &v6);
  }
  return IR::DataResampler<float>::Initialize(a1, v4);
}

unint64_t IR::DataResampler<float>::Initialize(uint64_t a1, unsigned int a2)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  *(unsigned char *)(a1 + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  if (a2 < 0x80)
  {
    CA::AudioSampleRateConverterBuilder::AudioSampleRateConverterBuilder((uint64_t)v19, 1);
    CA::AudioSampleRateConverterBuilder::SetAttribute<double>((uint64_t)v19, (const void *)*MEMORY[0x263F28DF8], *(float *)(a1 + 12));
    CA::AudioSampleRateConverterBuilder::SetAttribute<double>((uint64_t)v19, (const void *)*MEMORY[0x263F28E10], *(float *)(a1 + 16));
    CA::AudioSampleRateConverterBuilder::SetAttribute<unsigned int>((uint64_t)v19, (const void *)*MEMORY[0x263F28E08], 1);
    CA::AudioSampleRateConverterBuilder::SetAttribute<unsigned int>((uint64_t)v19, (const void *)*MEMORY[0x263F28E18], a2);
    CA::AudioSampleRateConverterBuilder::Build((uint64_t)&v17);
    if (v18)
    {
      int v7 = (void *)caulk::expected<CA::AudioSampleRateConverter,int>::value((uint64_t)&v17);
      unsigned int v8 = v7;
      if (*(unsigned char *)(a1 + 32))
      {
        uint64_t v9 = *(void *)(a1 + 24);
        *(void *)(a1 + 24) = *v7;
        *int v7 = v9;
      }
      else
      {
        uint64_t v11 = *v7;
        *unsigned int v8 = 0;
        *(void *)(a1 + 24) = v11;
        *(unsigned char *)(a1 + 32) = 1;
      }
      *(_DWORD *)buf = 0;
      unsigned int ExpectedNumberOfOutputFrames = AudioSampleRateConverterGetExpectedNumberOfOutputFrames();
      if (*(_DWORD *)buf)
      {
        unsigned int v4 = ExpectedNumberOfOutputFrames;
        uint64_t v5 = 0;
        *(unsigned char *)(a1 + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 1;
      }
      else
      {
        if (IR::getDataResamplerLog(void)::onceToken != -1) {
          dispatch_once(&IR::getDataResamplerLog(void)::onceToken, &__block_literal_global_2);
        }
        int v13 = IR::getDataResamplerLog(void)::gLog;
        if (os_log_type_enabled((os_log_t)IR::getDataResamplerLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
          IR::DataResampler<float>::Initialize(v13);
        }
        unsigned int v4 = 0;
        uint64_t v5 = 101;
      }
    }
    else
    {
      uint64_t v5 = v17;
      if (IR::getDataResamplerLog(void)::onceToken != -1) {
        dispatch_once(&IR::getDataResamplerLog(void)::onceToken, &__block_literal_global_2);
      }
      int v10 = IR::getDataResamplerLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)IR::getDataResamplerLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        double v15 = *(float *)(a1 + 12);
        double v16 = *(float *)(a1 + 16);
        *(_DWORD *)buf = 136315906;
        unint64_t v21 = "Initialize";
        __int16 v22 = 1024;
        int v23 = v5;
        __int16 v24 = 2048;
        double v25 = v15;
        __int16 v26 = 2048;
        double v27 = v16;
        _os_log_error_impl(&dword_21B4DD000, v10, OS_LOG_TYPE_ERROR, "IRDataResampler::%s: SRC builder returned error: %d. Native IR SampleRate: %.2f, target SampleRate: %.2f", buf, 0x26u);
      }
      unsigned int v4 = 0;
    }
    caulk::__expected_detail::base<CA::AudioSampleRateConverter,int>::~base((uint64_t)&v17);
    CA::AudioSampleRateConverterBuilder::~AudioSampleRateConverterBuilder((CA::AudioSampleRateConverterBuilder *)v19);
  }
  else
  {
    if (IR::getDataResamplerLog(void)::onceToken != -1) {
      dispatch_once(&IR::getDataResamplerLog(void)::onceToken, &__block_literal_global_2);
    }
    CFDictionaryRef v3 = IR::getDataResamplerLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)IR::getDataResamplerLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      IR::DataResampler<float>::Initialize(a2, v3);
    }
    unsigned int v4 = 0;
    uint64_t v5 = 102;
  }
  return v4 | (unint64_t)(v5 << 32);
}

void sub_21B50B730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t CA::AudioSampleRateConverterBuilder::Build@<X0>(uint64_t a1@<X8>)
{
  uint64_t v6 = 0;
  uint64_t result = AudioSampleRateConverterCreate();
  if (result)
  {
    *(_DWORD *)a1 = result;
    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    CA::AudioSampleRateConverter::AudioSampleRateConverter(&v5, v6);
    uint64_t v4 = v5;
    uint64_t v5 = 0;
    *(void *)a1 = v4;
    *(unsigned char *)(a1 + 8) = 1;
    return AudioSampleRateConverterDispose();
  }
  return result;
}

uint64_t caulk::expected<CA::AudioSampleRateConverter,int>::value(uint64_t result)
{
  if (!*(unsigned char *)(result + 8))
  {
    uint64_t v1 = (int *)result;
    exception = __cxa_allocate_exception(0x10uLL);
    int v3 = *v1;
    *(void *)exception = &unk_26CB57AF0;
    exception[2] = v3;
  }
  return result;
}

uint64_t IR::DataResampler<float>::CleanUp(uint64_t result)
{
  *(unsigned char *)(result + 2std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0;
  return result;
}

uint64_t IR::DataResampler<float>::GetRequiredNumberOfInputFrames(uint64_t a1)
{
  LODWORD(result) = AudioSampleRateConverterGetRequiredNumberOfInputFrames();
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= result) {
    return result;
  }
  else {
    return v3;
  }
}

os_log_t ___ZN2IR19getDataResamplerLogEv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreaudio", "DataResampler");
  IR::getDataResamplerLog(void)::gLog = (uint64_t)result;
  return result;
}

uint64_t IR::DataResampler<float>::Process(uint64_t a1, float *a2, unsigned int a3, float *a4, vDSP_Length a5)
{
  v14[1] = *(float **)MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 20)) {
    return 103;
  }
  uint64_t v9 = (CA::AudioSampleRateConverter *)(a1 + 24);
  AudioSampleRateConverterReset();
  unsigned int RequiredNumberOfInputFrames = AudioSampleRateConverterGetRequiredNumberOfInputFrames();
  if (RequiredNumberOfInputFrames <= a3)
  {
    int v13 = a4;
    v14[0] = a2;
    uint64_t v11 = CA::AudioSampleRateConverter::Process(v9, (const float *const *)v14, 1, RequiredNumberOfInputFrames, &v13);
    if (v11) {
      vDSP_vclr(a4, 1, a5);
    }
  }
  else
  {
    vDSP_vclr(a4, 1, a5);
    return 4294956422;
  }
  return v11;
}

void sub_21B50B9BC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t CA::AudioSampleRateConverter::Process(CA::AudioSampleRateConverter *this, const float *const *a2, int a3, unsigned int a4, float *const *a5)
{
  return AudioSampleRateConverterProcess();
}

uint64_t std::__optional_destruct_base<CA::AudioSampleRateConverter,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    AudioSampleRateConverterDispose();
  }
  return a1;
}

uint64_t CA::AudioSampleRateConverterBuilder::AudioSampleRateConverterBuilder(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = a2;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!Mutable)
  {
    _os_assert_log();
    uint64_t v5 = _os_crash();
    CA::AudioSampleRateConverterBuilder::AudioSampleRateConverterBuilder(v5);
  }
  *(void *)(a1 + 8) = Mutable;
  return a1;
}

void CA::AudioSampleRateConverterBuilder::SetAttribute<double>(uint64_t a1, const void *a2, double a3)
{
  uint64_t v4 = *(__CFDictionary **)(a1 + 8);
  double valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  CFDictionarySetValue(v4, a2, v5);
  CFRelease(v5);
}

void sub_21B50BB44(void *a1)
{
}

void CA::AudioSampleRateConverterBuilder::SetAttribute<unsigned int>(uint64_t a1, const void *a2, int a3)
{
  uint64_t v4 = *(__CFDictionary **)(a1 + 8);
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  CFDictionarySetValue(v4, a2, v5);
  CFRelease(v5);
}

void sub_21B50BC0C(void *a1)
{
}

void *CA::AudioSampleRateConverter::AudioSampleRateConverter(void *result, uint64_t a2)
{
  *os_log_t result = a2;
  if (!a2)
  {
    _os_assert_log();
    uint64_t v2 = _os_crash();
    CA::AudioSampleRateConverterBuilder::AudioSampleRateConverterBuilder(v2);
  }
  return result;
}

void caulk::bad_expected_access<int>::~bad_expected_access(std::exception *a1)
{
  std::exception::~exception(a1);

  JUMPOUT(0x21D48F780);
}

uint64_t caulk::__expected_detail::base<CA::AudioSampleRateConverter,int>::~base(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    AudioSampleRateConverterDispose();
  }
  return a1;
}

void CA::AudioSampleRateConverterBuilder::~AudioSampleRateConverterBuilder(CA::AudioSampleRateConverterBuilder *this)
{
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t AudioDSPCoreUtility::GetDeviceOrPortID(AudioDSPCoreUtility *this, unsigned int *a2)
{
  int v13 = @"VirtualAudioDevice_Default";
  AudioObjectID v12 = 0;
  outData[0] = &v13;
  outData[1] = 8;
  outData[2] = &v12;
  outData[3] = 4;
  *(void *)&inAddress.mSelector = 0x676C6F6264756964;
  inAddress.mElement = 0;
  ioDataSize[0] = 32;
  PropertyCFDataRef Data = AudioObjectGetPropertyData(1u, &inAddress, 0, 0, ioDataSize, outData);
  if (PropertyData
    || (*(void *)UInt32 ioDataSize = 0,
        *(void *)&inAddress.mSelector = 0x6F75747064616370,
        inAddress.mElement = 0,
        LODWORD(cf) = 8,
        PropertyCFDataRef Data = AudioObjectGetPropertyData(v12, &inAddress, 0, 0, (UInt32 *)&cf, ioDataSize),
        PropertyData))
  {
    uint64_t v4 = PropertyData;
    *(_DWORD *)this = 0;
  }
  else
  {
    applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&inAddress, *(CFTypeRef *)ioDataSize);
    if (!*(void *)&inAddress.mSelector)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    if (CFArrayGetCount(*(CFArrayRef *)&inAddress.mSelector) == 1)
    {
      CFArrayRef v6 = *(const __CFArray **)&inAddress.mSelector;
      if (*(void *)&inAddress.mSelector) {
        CFArrayGetCount(*(CFArrayRef *)&inAddress.mSelector);
      }
      applesauce::CF::details::at_to<applesauce::CF::TypeRef>(v6, 0, &cf);
      *(_DWORD *)this = applesauce::CF::convert_to<unsigned int,0>((const __CFNumber *)cf);
      if (cf) {
        CFRelease(cf);
      }
      uint64_t v4 = 0;
    }
    else
    {
      *(_DWORD *)this = 0;
      uint64_t v4 = 0xFFFFFFFFLL;
    }
    if (*(void *)&inAddress.mSelector) {
      CFRelease(*(CFTypeRef *)&inAddress.mSelector);
    }
  }
  return v4;
}

void sub_21B50BEA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11)
{
}

applesauce::CF::ArrayRef *applesauce::CF::ArrayRef::ArrayRef(applesauce::CF::ArrayRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFArrayGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
  }
  return this;
}

void sub_21B50BF6C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

CFTypeRef applesauce::CF::details::at_to<applesauce::CF::TypeRef>@<X0>(const __CFArray *a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (!a1 || CFArrayGetCount(a1) <= a2 || (ValueAtIndex = CFArrayGetValueAtIndex(a1, a2), (int v7 = ValueAtIndex) == 0))
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  CFTypeRef result = CFRetain(ValueAtIndex);
  *a3 = v7;
  return result;
}

void sub_21B50C010()
{
}

void sub_21B50C03C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void SincKernelFactorySingleton::SincKernelFactorySingleton(SincKernelFactorySingleton *this)
{
  *(void *)this = 0;
  caulk::pooled_semaphore_mutex::pooled_semaphore_mutex((SincKernelFactorySingleton *)((char *)this + 8));
  operator new();
}

void sub_21B50C0B0(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x21D48F780](v3, 0x80C40D6874129);
  uint64_t v5 = *v1;
  uint64_t *v1 = 0;
  if (v5) {
    std::default_delete<SincKernelFactory>::operator()[abi:ne180100]((uint64_t)v1, v5);
  }
  _Unwind_Resume(a1);
}

void *SincKernelFactorySingleton::instance(SincKernelFactorySingleton *this)
{
  {
    SincKernelFactorySingleton::SincKernelFactorySingleton((SincKernelFactorySingleton *)&SincKernelFactorySingleton::instance(void)::gSincKernelFactorySingleton);
  }
  return &SincKernelFactorySingleton::instance(void)::gSincKernelFactorySingleton;
}

void sub_21B50C158(_Unwind_Exception *a1)
{
}

uint64_t SincKernelFactorySingleton::ReferenceSincKernel(SincKernelFactory **this, int a2, int a3, double a4, double a5)
{
  AudioObjectID v12 = (char *)(this + 1);
  char v13 = 1;
  caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(this + 1));
  uint64_t v10 = SincKernelFactory::ReferenceSincKernel(*this, a2, a3, a4, a5);
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v12);
  return v10;
}

void sub_21B50C1F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t SincKernelFactorySingleton::ReleaseSincKernel(void **a1, uint64_t a2)
{
  uint64_t v5 = a1 + 1;
  char v6 = 1;
  caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(a1 + 1));
  SincKernelFactory::ReleaseSincKernel(*a1, a2);
  return std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v5);
}

void sub_21B50C25C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void IR::DelayLine::processPolyphaseQ22_10(IR::DelayLine *this, int a2, int a3, float *__C, vDSP_Length __N)
{
  int v5 = *((_DWORD *)this + 32);
  int v6 = a3 + (1 << (9 - v5)) - 512;
  unsigned int v7 = (unsigned __int16)(v6 & 0x3FF) >> (10 - v5);
  if (v7 >= *((_DWORD *)this + 30)) {
    IR::DelayLine::processPolyphaseQ22_10();
  }
  unsigned int v8 = __N;
  vDSP_Length v11 = *((unsigned int *)this + 33);
  uint64_t v12 = (v11 - 1);
  uint64_t v13 = *((void *)this + 2);
  unint64_t v14 = (*((void *)this + 3) - v13) >> 2;
  unsigned int v15 = (a2 - (v11 + (v6 >> 10)) + v14 + 1) & *((_DWORD *)this + 10);
  double v16 = (const float *)(*((void *)this + 13) + 4 * v7 * v11);
  if (__N == 1)
  {
    vDSP_dotpr((const float *)(v13 + 4 * v15 + 4 * v12), -1, v16, 1, __C, v11);
  }
  else
  {
    if (v14 >= v12 + __N + v15)
    {
      unsigned int v20 = (const float *)(v13 + 4 * v15);
      __int16 v22 = &v16[v12];
      vDSP_Length v19 = __N;
      unint64_t v21 = __C;
    }
    else
    {
      if (v14 < (v12 + __N)) {
        IR::DelayLine::processPolyphaseQ22_10();
      }
      vDSP_Length v17 = v14 - (v12 + v15);
      char v18 = &v16[v12];
      vDSP_conv((const float *)(v13 + 4 * v15), 1, v18, -1, __C, 1, v17, v11);
      vDSP_Length v19 = v8 - v17;
      unsigned int v20 = (const float *)*((void *)this + 2);
      unint64_t v21 = &__C[v17];
      vDSP_Length v11 = *((unsigned int *)this + 33);
      __int16 v22 = v18;
    }
    vDSP_conv(v20, 1, v22, -1, v21, 1, v19, v11);
  }
}

uint64_t IR::DelayLine::DelayLine(uint64_t a1, int a2, int a3, std::vector<unsigned int>::size_type __n, unsigned int a5, int a6)
{
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = __n;
  *(unsigned char *)(a1 + 12) = 1;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v7 = a1 + 16;
  *(_OWORD *)(a1 + 48) = 0u;
  unsigned int v8 = (char **)(a1 + 48);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_DWORD *)(a1 + 96) = 1065347625;
  *(_OWORD *)(a1 + 136) = 0u;
  uint64_t v9 = (std::vector<unsigned int> *)(a1 + 136);
  *(_OWORD *)(a1 + 184) = 0u;
  uint64_t v10 = (const float **)(a1 + 184);
  uint64_t v34 = a1 + 208;
  *(_OWORD *)(a1 + 232) = 0u;
  uint64_t v11 = a1 + 232;
  uint64_t v36 = (char **)(a1 + 256);
  unint64_t v37 = (char **)(a1 + 72);
  uint64_t v35 = (float **)(a1 + 160);
  *(_OWORD *)(a1 + 12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 20std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  if (!__n) {
    __assert_rtn("DelayLine", "DelayLine.cpp", 236, "inNumTaps > 0");
  }
  switch(a3)
  {
    case 1:
    case 3:
      *(float *)&std::vector<unsigned int>::value_type __u = 2.0;
      std::vector<float>::assign((char **)(a1 + 48), __n, &__u);
      unint64_t v14 = *(unsigned int *)(a1 + 8);
      *(float *)&std::vector<unsigned int>::value_type __u = 2.0;
      std::vector<float>::assign(v37, v14, &__u);
      unsigned int v15 = 0;
      unsigned int v16 = a2 + 4;
      break;
    case 2:
    case 4:
      *(float *)&std::vector<unsigned int>::value_type __u = 3.0;
      std::vector<float>::assign((char **)(a1 + 48), __n, &__u);
      unint64_t v17 = *(unsigned int *)(a1 + 8);
      *(float *)&std::vector<unsigned int>::value_type __u = 3.0;
      std::vector<float>::assign(v37, v17, &__u);
      unsigned int v15 = 0;
      unsigned int v16 = a2 + 6;
      break;
    case 5:
    case 7:
      goto LABEL_7;
    case 6:
      *(float *)&std::vector<unsigned int>::value_type __u = 0.0;
      std::vector<IR::IRInterpolationMethod>::assign((std::vector<unsigned int> *)(a1 + 280), __n, &__u);
      std::vector<float>::resize((uint64_t)v35, a5);
      std::vector<float>::resize((uint64_t)v10, a5);
      std::vector<float>::resize(v34, a5);
      std::vector<float>::resize(v11, a5);
      *(float *)&std::vector<unsigned int>::value_type __u = 0.0;
      float __B = 1.0 / (float)a5;
      vDSP_vramp((const float *)&__u, &__B, *(float **)(a1 + 184), 1, (uint64_t)(*(void *)(a1 + 192) - *(void *)(a1 + 184)) >> 2);
      float v38 = -1.0;
      float __C = 1.0;
      vDSP_vsmsa(*v10, 1, &v38, &__C, *v35, 1, a5);
LABEL_7:
      SincKernelFactorySingleton::instance((SincKernelFactorySingleton *)a1);
      uint64_t v20 = SincKernelFactorySingleton::ReferenceSincKernel((SincKernelFactory **)&SincKernelFactorySingleton::instance(void)::gSincKernelFactorySingleton, 11, 128, 80.0, 0.9);
      *(void *)(a1 + 112) = v20;
      int8x8_t v21 = (int8x8_t)*(unsigned int *)(v20 + 16);
      *(_DWORD *)(a1 + 12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v21.i32[0];
      uint8x8_t v22 = (uint8x8_t)vcnt_s8(v21);
      v22.i16[0] = vaddlv_u8(v22);
      if (v22.i32[0] != 1) {
        __assert_rtn("DelayLine", "DelayLine.cpp", 285, "isPowerOfTwo(mFractionalPhases)");
      }
      *(_DWORD *)(a1 + 124) = v21.i32[0] - 1;
      if (v21.i32[0] >= 2u)
      {
        int v23 = 0;
        do
        {
          ++v23;
          BOOL v24 = v21.i32[0] > 3u;
          v21.i32[0] = (unsigned __int32)v21.i32[0] >> 1;
        }
        while (v24);
      }
      else
      {
        int v23 = 0;
      }
      *(_DWORD *)(a1 + 128) = v23;
      unsigned int v25 = *(_DWORD *)(v20 + 12);
      *(_DWORD *)(a1 + 132) = v25;
      *(void *)(a1 + 104) = *(void *)v20;
      unint64_t v26 = *(unsigned int *)(a1 + 8);
      *(float *)&std::vector<unsigned int>::value_type __u = (float)v25;
      std::vector<float>::assign(v8, v26, &__u);
      unint64_t v27 = *(unsigned int *)(a1 + 8);
      *(float *)&std::vector<unsigned int>::value_type __u = (float)*(unsigned int *)(a1 + 132);
      std::vector<float>::assign(v36, v27, &__u);
      std::vector<unsigned int>::size_type v28 = *(unsigned int *)(a1 + 8);
      float v29 = (float)*(unsigned int *)(a1 + 132) * 1024.0;
      float v30 = -1.0;
      if (v29 >= 0.0) {
        float v30 = 1.0;
      }
      std::vector<unsigned int>::value_type __u = (uint64_t)(float)(v29 + (float)(v30 * 0.5));
      std::vector<IR::IRInterpolationMethod>::assign(v9, v28, &__u);
      unint64_t v31 = *(unsigned int *)(a1 + 8);
      *(float *)&std::vector<unsigned int>::value_type __u = (float)*(unsigned int *)(a1 + 132);
      std::vector<float>::assign(v37, v31, &__u);
      unsigned int v16 = a6 + a2 + v25;
      unsigned int v15 = v25 - 1;
      break;
    default:
      *(float *)&std::vector<unsigned int>::value_type __u = 0.0;
      std::vector<float>::assign((char **)(a1 + 48), __n, &__u);
      unint64_t v18 = *(unsigned int *)(a1 + 8);
      *(float *)&std::vector<unsigned int>::value_type __u = 0.0;
      std::vector<float>::assign(v37, v18, &__u);
      unsigned int v15 = 0;
      unsigned int v16 = a2 + 1;
      break;
  }
  int v32 = 1 << -(char)__clz(v16 - 1);
  *(float *)&std::vector<unsigned int>::value_type __u = 0.0;
  std::vector<float>::resize(v7, v32 + v15, &__u);
  *(_DWORD *)(a1 + 4std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v32 - 1;
  IR::DelayLine::reset((IR::DelayLine *)a1);
  return a1;
}

void sub_21B50C814(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void **a11, void **a12, void **a13, void **a14)
{
  int8x8_t v21 = *a11;
  if (*a11)
  {
    v14[36] = v21;
    operator delete(v21);
  }
  uint8x8_t v22 = *a13;
  if (*a13)
  {
    v14[33] = v22;
    operator delete(v22);
  }
  int v23 = *v19;
  if (*v19)
  {
    v14[30] = v23;
    operator delete(v23);
  }
  BOOL v24 = *a10;
  if (*a10)
  {
    v14[27] = v24;
    operator delete(v24);
  }
  unsigned int v25 = *v18;
  if (*v18)
  {
    unsigned char v14[24] = v25;
    operator delete(v25);
  }
  unint64_t v26 = *a12;
  if (*a12)
  {
    v14[21] = v26;
    operator delete(v26);
  }
  unint64_t v27 = *v17;
  if (*v17)
  {
    v14[18] = v27;
    operator delete(v27);
  }
  std::vector<unsigned int>::size_type v28 = *a14;
  if (*a14)
  {
    v14[10] = v28;
    operator delete(v28);
  }
  float v29 = *v16;
  if (*v16)
  {
    v14[7] = v29;
    operator delete(v29);
  }
  float v30 = *v15;
  if (*v15)
  {
    v14[3] = v30;
    operator delete(v30);
  }
  _Unwind_Resume(exception_object);
}

void IR::DelayLine::reset(IR::DelayLine *this)
{
  int v2 = *((_DWORD *)this + 1);
  if (v2 == 5 || v2 == 7)
  {
LABEL_12:
    uint64_t v10 = (void *)*((void *)this + 2);
    uint64_t v11 = *((void *)this + 3) - (void)v10;
    if (v11 >= 1) {
      bzero(v10, 4 * (((unint64_t)v11 >> 2) - ((unint64_t)v11 > 3)) + 4);
    }
    *((_DWORD *)this + 11) = *((_DWORD *)this + 33) - 1;
    goto LABEL_15;
  }
  if (v2 == 6)
  {
    uint64_t v4 = (void *)*((void *)this + 29);
    uint64_t v5 = *((void *)this + 30) - (void)v4;
    if (v5 >= 1) {
      bzero(v4, 4 * (((unint64_t)v5 >> 2) - ((unint64_t)v5 > 3)) + 4);
    }
    int v6 = (void *)*((void *)this + 26);
    uint64_t v7 = *((void *)this + 27) - (void)v6;
    if (v7 >= 1) {
      bzero(v6, 4 * (((unint64_t)v7 >> 2) - ((unint64_t)v7 > 3)) + 4);
    }
    unsigned int v8 = (void *)*((void *)this + 35);
    uint64_t v9 = *((void *)this + 36) - (void)v8;
    if (v9 >= 1) {
      bzero(v8, 4 * (((unint64_t)v9 >> 2) - ((unint64_t)v9 > 3)) + 4);
    }
    goto LABEL_12;
  }
  uint64_t v12 = (void *)*((void *)this + 2);
  uint64_t v13 = *((void *)this + 3) - (void)v12;
  if (v13 >= 1) {
    bzero(v12, 4 * (((unint64_t)v13 >> 2) - ((unint64_t)v13 > 3)) + 4);
  }
LABEL_15:
  *((unsigned char *)this + 12) = 1;
}

void IR::DelayLine::~DelayLine(IR::DelayLine *this)
{
  if ((*((_DWORD *)this + 1) - 5) <= 2)
  {
    SincKernelFactorySingleton::instance(this);
    SincKernelFactorySingleton::ReleaseSincKernel((void **)&SincKernelFactorySingleton::instance(void)::gSincKernelFactorySingleton, *((void *)this + 14));
  }
  int v2 = (void *)*((void *)this + 35);
  if (v2)
  {
    *((void *)this + 36) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 32);
  if (v3)
  {
    *((void *)this + 33) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 29);
  if (v4)
  {
    *((void *)this + 3std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 26);
  if (v5)
  {
    *((void *)this + 27) = v5;
    operator delete(v5);
  }
  int v6 = (void *)*((void *)this + 23);
  if (v6)
  {
    *((void *)this + 24) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 20);
  if (v7)
  {
    *((void *)this + 21) = v7;
    operator delete(v7);
  }
  unsigned int v8 = (void *)*((void *)this + 17);
  if (v8)
  {
    *((void *)this + 18) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 9);
  if (v9)
  {
    *((void *)this + 1std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v9;
    operator delete(v9);
  }
  uint64_t v10 = (void *)*((void *)this + 6);
  if (v10)
  {
    *((void *)this + 7) = v10;
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 2);
  if (v11)
  {
    *((void *)this + 3) = v11;
    operator delete(v11);
  }
}

uint64_t IR::DelayLine::setDelay(uint64_t this, float a2, unsigned int a3)
{
  if (*(_DWORD *)(this + 8) <= a3) {
    IR::DelayLine::setDelay();
  }
  if ((float)*(unsigned int *)this < a2) {
    a2 = (float)*(unsigned int *)this;
  }
  unsigned int v3 = *(_DWORD *)(this + 4);
  if (v3 <= 7)
  {
    int v4 = 1 << v3;
    if ((v4 & 0xE0) != 0)
    {
      a2 = a2 + (float)*(unsigned int *)(this + 132);
    }
    else
    {
      float v5 = a2 + 2.0;
      if ((v4 & 0x14) != 0) {
        a2 = a2 + 3.0;
      }
      if ((v4 & 0xA) != 0) {
        a2 = v5;
      }
    }
  }
  *(float *)(*(void *)(this + 48) + 4 * a3) = a2;
  return this;
}

uint64_t IR::DelayLine::setDelay(IR::DelayLine *this, float a2)
{
  return IR::DelayLine::setDelay((uint64_t)this, a2, 0);
}

uint64_t IR::DelayLine::getLatencyFrames(int a1)
{
  if ((a1 - 1) > 6) {
    return 0;
  }
  else {
    return dword_21B5511BC[a1 - 1];
  }
}

void IR::DelayLine::process(IR::DelayLine *this, const float *__src, float **a3, unsigned int a4, vDSP_Length a5)
{
  float v5 = this;
  uint64_t v198 = *MEMORY[0x263EF8340];
  float v6 = *((float *)this + 24);
  if (a5)
  {
    uint64_t v7 = __src;
    if (!__src) {
      IR::DelayLine::process();
    }
    vDSP_Length v194 = a5;
    unsigned int v9 = *((_DWORD *)this + 2);
    if (v9 >= a4) {
      uint64_t v10 = a4;
    }
    else {
      uint64_t v10 = v9;
    }
    uint64_t v11 = (*((void *)this + 3) - *((void *)this + 2)) >> 2;
    if (*((unsigned char *)this + 12))
    {
      this = (IR::DelayLine *)IR::DelayLine::swapDelays(this);
      *((unsigned char *)v5 + 12) = 0;
    }
    switch(*((_DWORD *)v5 + 1))
    {
      case 1:
        uint64_t v99 = 0;
        uint64_t v100 = *((void *)v5 + 2);
        int v101 = v194;
        unsigned int v102 = *((_DWORD *)v5 + 10);
        unsigned int v48 = *((_DWORD *)v5 + 11);
        do
        {
          *(float *)(v100 + 4 * v48) = v7[v99];
          if (v10)
          {
            uint64_t v103 = 0;
            uint64_t v104 = *((void *)v5 + 9);
            do
            {
              if (v6 == 2.7183)
              {
                float v105 = *(float *)(v104 + 4 * v103)
                     + (float)((float)(*(float *)(*((void *)v5 + 6) + 4 * v103) - *(float *)(v104 + 4 * v103))
                             / (float)(v101 - v99));
              }
              else
              {
                float v106 = *(float *)(*((void *)v5 + 6) + 4 * v103);
                float v105 = v106 + (float)(*((float *)v5 + 24) * (float)(*(float *)(v104 + 4 * v103) - v106));
              }
              *(float *)(v104 + 4 * v103) = v105;
              float v107 = (float)v48 - v105;
              if (v107 >= 0.0) {
                float v108 = -0.0;
              }
              else {
                float v108 = (float)v11;
              }
              float v109 = v107 + v108;
              float v110 = *(float *)(v100 + 4 * (v102 & (int)v109));
              float v111 = *(float *)(v100 + 4 * (((int)v109 + 1) & v102));
              float v112 = *(float *)(v100 + 4 * (((int)v109 + 2) & v102));
              float v113 = *(float *)(v100 + 4 * (((int)v109 - 1) & v102));
              float v114 = v113 + v110 * -2.5 + (float)(v111 + v111) + v112 * -0.5;
              float v115 = (float)(v110 - v111) * 1.5 + (float)(v112 - v113) * 0.5;
              a3[v103++][v99] = v110
                              + (float)((float)((float)((float)(v111 - v113) * 0.5)
                                              + (float)((float)(v114 + (float)(v115 * (float)(v109 - (float)(int)v109)))
                                                      * (float)(v109 - (float)(int)v109)))
                                      * (float)(v109 - (float)(int)v109));
            }
            while (v10 != v103);
          }
          unsigned int v48 = v102 & (v48 + 1);
          ++v99;
        }
        while (v99 != v101);
        goto LABEL_100;
      case 2:
        uint64_t v116 = 0;
        uint64_t v117 = *((void *)v5 + 2);
        int v118 = v194;
        unsigned int v119 = *((_DWORD *)v5 + 10);
        unsigned int v48 = *((_DWORD *)v5 + 11);
        do
        {
          *(float *)(v117 + 4 * v48) = v7[v116];
          if (v10)
          {
            uint64_t v120 = 0;
            uint64_t v121 = *((void *)v5 + 9);
            do
            {
              if (v6 == 2.7183)
              {
                float v122 = *(float *)(v121 + 4 * v120)
                     + (float)((float)(*(float *)(*((void *)v5 + 6) + 4 * v120) - *(float *)(v121 + 4 * v120))
                             / (float)(v118 - v116));
              }
              else
              {
                float v123 = *(float *)(*((void *)v5 + 6) + 4 * v120);
                float v122 = v123 + (float)(*((float *)v5 + 24) * (float)(*(float *)(v121 + 4 * v120) - v123));
              }
              *(float *)(v121 + 4 * v12std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v122;
              float v124 = (float)v48 - v122;
              if (v124 >= 0.0) {
                float v125 = -0.0;
              }
              else {
                float v125 = (float)v11;
              }
              float v126 = v124 + v125;
              float v127 = *(float *)(v117 + 4 * (v119 & (int)v126));
              float v128 = *(float *)(v117 + 4 * (((int)v126 + 1) & v119));
              float v129 = *(float *)(v117 + 4 * (((int)v126 + 2) & v119));
              float v130 = *(float *)(v117 + 4 * (((int)v126 + 3) & v119));
              float v131 = *(float *)(v117 + 4 * (((int)v126 - 1) & v119));
              float v132 = *(float *)(v117 + 4 * (((int)v126 - 2) & v119));
              float v133 = (float)(v127 * -2.3333)
                   + v131 * 1.25
                   + (float)(v128 * 1.6667)
                   + v129 * -0.5
                   + (float)(v130 * 0.083333)
                   + (float)(v132 * -0.16667);
              a3[v120++][v116] = v127
                               + (float)((float)((float)((float)((float)(v128 - v131) * 0.66667)
                                                       + (float)((float)(v132 - v129) * 0.083333))
                                               + (float)((float)(v133
                                                               + (float)((float)((float)((float)((float)(v129 - v131)
                                                                                               * 0.58333)
                                                                                       + (float)((float)(v132 - v130)
                                                                                               * 0.083333))
                                                                               + (float)((float)(v127 - v128) * 1.3333))
                                                                       * (float)(v126 - (float)(int)v126)))
                                                       * (float)(v126 - (float)(int)v126)))
                                       * (float)(v126 - (float)(int)v126));
            }
            while (v10 != v120);
          }
          unsigned int v48 = v119 & (v48 + 1);
          ++v116;
        }
        while (v116 != v118);
        goto LABEL_100;
      case 3:
        uint64_t v44 = 0;
        uint64_t v45 = *((void *)v5 + 2);
        int v46 = v194;
        unsigned int v47 = *((_DWORD *)v5 + 10);
        unsigned int v48 = *((_DWORD *)v5 + 11);
        do
        {
          *(float *)(v45 + 4 * v48) = v7[v44];
          if (v10)
          {
            uint64_t v49 = 0;
            uint64_t v50 = *((void *)v5 + 9);
            do
            {
              if (v6 == 2.7183)
              {
                float v51 = *(float *)(v50 + 4 * v49)
                    + (float)((float)(*(float *)(*((void *)v5 + 6) + 4 * v49) - *(float *)(v50 + 4 * v49))
                            / (float)(v46 - v44));
              }
              else
              {
                float v52 = *(float *)(*((void *)v5 + 6) + 4 * v49);
                float v51 = v52 + (float)(*((float *)v5 + 24) * (float)(*(float *)(v50 + 4 * v49) - v52));
              }
              *(float *)(v50 + 4 * v49) = v51;
              float v53 = (float)v48 - v51;
              if (v53 >= 0.0) {
                float v54 = -0.0;
              }
              else {
                float v54 = (float)v11;
              }
              float v55 = v53 + v54;
              float v56 = *(float *)(v45 + 4 * (v47 & (int)v55));
              float v57 = *(float *)(v45 + 4 * (((int)v55 + 1) & v47));
              float v58 = *(float *)(v45 + 4 * (((int)v55 - 1) & v47));
              float v59 = (float)(v57 + (float)(v58 * -0.33333)) + v56 * -0.5 - (float)(v57 * 0.16667);
              float v60 = -(v56 - (float)(v57 + v58) * 0.5);
              float v61 = (float)((float)(v57 - v58) * 0.16667) + (float)(v56 - v57) * 0.5;
              a3[v49++][v44] = v56
                             + (float)((float)(v59
                                             + (float)((float)(v60 + (float)(v61 * (float)(v55 - (float)(int)v55)))
                                                     * (float)(v55 - (float)(int)v55)))
                                     * (float)(v55 - (float)(int)v55));
            }
            while (v10 != v49);
          }
          unsigned int v48 = v47 & (v48 + 1);
          ++v44;
        }
        while (v44 != v46);
        goto LABEL_100;
      case 4:
        uint64_t v75 = 0;
        uint64_t v76 = *((void *)v5 + 2);
        int v77 = v194;
        unsigned int v78 = *((_DWORD *)v5 + 10);
        unsigned int v48 = *((_DWORD *)v5 + 11);
        do
        {
          *(float *)(v76 + 4 * v48) = v7[v75];
          if (v10)
          {
            uint64_t v79 = 0;
            uint64_t v80 = *((void *)v5 + 9);
            do
            {
              if (v6 == 2.7183)
              {
                float v81 = *(float *)(v80 + 4 * v79)
                    + (float)((float)(*(float *)(*((void *)v5 + 6) + 4 * v79) - *(float *)(v80 + 4 * v79))
                            / (float)(v77 - v75));
              }
              else
              {
                float v82 = *(float *)(*((void *)v5 + 6) + 4 * v79);
                float v81 = v82 + (float)(*((float *)v5 + 24) * (float)(*(float *)(v80 + 4 * v79) - v82));
              }
              *(float *)(v80 + 4 * v79) = v81;
              float v83 = (float)v48 - v81;
              if (v83 >= 0.0) {
                float v84 = -0.0;
              }
              else {
                float v84 = (float)v11;
              }
              float v85 = v83 + v84;
              float v86 = *(float *)(v76 + 4 * (v78 & (int)v85));
              float v87 = *(float *)(v76 + 4 * (((int)v85 + 1) & v78));
              float v88 = *(float *)(v76 + 4 * (((int)v85 + 2) & v78));
              float v89 = *(float *)(v76 + 4 * (((int)v85 + 3) & v78));
              float v90 = *(float *)(v76 + 4 * (((int)v85 - 1) & v78));
              float v91 = *(float *)(v76 + 4 * (((int)v85 - 2) & v78));
              float v92 = v85 - (float)(int)v85;
              double v93 = (float)((float)(v88 + v91) * 0.041667);
              float v94 = (float)((float)(v87 + v90) * -0.16667) + v86 * 0.25 + v93;
              float v95 = (float)((float)((float)((float)(v87 * -0.58333) + (float)(v86 * 0.41667)) + (float)(v88 * 0.29167))
                          + (float)((float)(v89 + (float)(v90 + v91)) * -0.041667))
                  + (float)((float)(v94
                                  + (float)((float)((float)((float)((float)(v90 - v88) * 0.041667)
                                                          + (float)((float)(v89 - v91) * 0.0083333))
                                                  + (float)((float)(v87 - v86) * 0.083333))
                                          * v92))
                          * v92);
              float v96 = (float)((float)(v87 + v90) * 0.66667) + v86 * -1.25 - v93;
              float v97 = v96 + (float)(v95 * v92);
              float v98 = v90 * -0.5 + v91 * 0.05 + (float)(v86 * -0.33333) + v87 + v88 * -0.25 + (float)(v89 * 0.033333);
              a3[v79++][v75] = v86 + (float)((float)(v98 + (float)(v97 * v92)) * v92);
            }
            while (v10 != v79);
          }
          unsigned int v48 = v78 & (v48 + 1);
          ++v75;
        }
        while (v75 != v77);
LABEL_100:
        *((_DWORD *)v5 + 11) = v48;
        return;
      case 5:
      case 7:
        uint64_t v193 = a3;
        unsigned int v12 = *((_DWORD *)v5 + 33);
        if (v12) {
          uint64_t v13 = v12 - 1;
        }
        else {
          uint64_t v13 = 0;
        }
        int v192 = *((_DWORD *)v5 + 11);
        MEMORY[0x270FA5388](this);
        uint64_t v197 = (char *)&v190 - v15;
        if (v10)
        {
          unsigned int v16 = (float *)*((void *)v5 + 6);
          uint64_t v17 = v10;
          unint64_t v18 = v197;
          do
          {
            float v19 = *v16++;
            float v20 = v19 * 1024.0;
            if ((float)(v19 * 1024.0) < 0.0) {
              float v21 = -1.0;
            }
            else {
              float v21 = 1.0;
            }
            *v18++ = (uint64_t)(float)(v20 + (float)(v21 * 0.5));
            --v17;
          }
          while (v17);
        }
        unsigned int v191 = v11 - v13;
        vDSP_Length v22 = v194;
        int v23 = v194 - v11;
        uint64_t v190 = v14;
        if (v194 <= v11)
        {
          uint64_t v42 = *((unsigned int *)v5 + 11);
          if ((int)v42 + (int)v194 >= v11)
          {
            uint64_t v136 = (v11 - v42);
            if (v42 != v11) {
              memmove((void *)(*((void *)v5 + 2) + 4 * v42), v7, 4 * v136);
            }
            vDSP_Length v43 = v194;
            if (v136 != v194) {
              memmove((void *)(*((void *)v5 + 2) + 4 * v13), &v7[v136], 4 * v194 - 4 * v136);
            }
            *((_DWORD *)v5 + 11) += v23 + v13;
            if (v191 < v43) {
              IR::DelayLine::process();
            }
          }
          else
          {
            memmove((void *)(*((void *)v5 + 2) + 4 * v42), v7, 4 * v194);
            *((_DWORD *)v5 + 11) += v22;
            vDSP_Length v43 = v22;
          }
          uint64_t v137 = v193;
          if (v12 >= 2) {
            memmove(*((void **)v5 + 2), (const void *)(*((void *)v5 + 3) - 4 * v13), 4 * v13);
          }
          if (v10)
          {
            uint64_t v138 = 0;
            uint64_t v139 = *((void *)v5 + 9);
            do
            {
              float v140 = *(float *)(*((void *)v5 + 6) + 4 * v138);
              int v141 = *(_DWORD *)&v197[4 * v138];
              uint64_t v142 = v137[v138];
              float v143 = *(float *)(v139 + 4 * v138);
              if ((float)(v143 * 1024.0) < 0.0) {
                float v144 = -1.0;
              }
              else {
                float v144 = 1.0;
              }
              if ((int)((uint64_t)(float)((float)(v143 * 1024.0) + (float)(v144 * 0.5)) - v141) >= 0) {
                unsigned int v145 = (uint64_t)(float)((float)(v143 * 1024.0) + (float)(v144 * 0.5)) - v141;
              }
              else {
                unsigned int v145 = v141 - (uint64_t)(float)((float)(v143 * 1024.0) + (float)(v144 * 0.5));
              }
              int v146 = *((_DWORD *)v5 + 1);
              if (v146 == 7) {
                vDSP_Length v147 = 8;
              }
              else {
                vDSP_Length v147 = 1;
              }
              float v148 = powf(*((float *)v5 + 24), (float)(int)v147);
              BOOL v149 = v145 > 0x20;
              BOOL v150 = v145 >= 0x21 && (int)v147 <= (int)v43;
              if (v150)
              {
                float v153 = v148;
                uint64_t v154 = *((void *)v5 + 17);
                uint64_t v196 = v138;
                int v155 = *(_DWORD *)(v154 + 4 * v138);
                if (v146 == 7) {
                  int v156 = 3;
                }
                else {
                  int v156 = 0;
                }
                LODWORD(v195) = v156;
                int v152 = v192;
                unsigned int v157 = v43;
                do
                {
                  if (v6 == 2.7183)
                  {
                    if (!(v157 >> (char)v195)) {
                      IR::DelayLine::process();
                    }
                    uint64_t v158 = *((void *)v5 + 17);
                    LODWORD(v159) = (v141 - *(_DWORD *)(v158 + 4 * v196)) / (int)(v157 >> (char)v195)
                                  + *(_DWORD *)(v158 + 4 * v196);
                    *(_DWORD *)(v158 + 4 * v196) = v159;
                  }
                  else
                  {
                    float v143 = v140 + (float)(v153 * (float)(v143 - v140));
                    if ((float)(v143 * 1024.0) < 0.0) {
                      float v160 = -1.0;
                    }
                    else {
                      float v160 = 1.0;
                    }
                    uint64_t v159 = (uint64_t)(float)((float)(v143 * 1024.0) + (float)(v160 * 0.5));
                    int v155 = v159;
                  }
                  IR::DelayLine::processPolyphaseQ22_10(v5, v152, v159, v142, v147);
                  if (v155 - v141 >= 0) {
                    unsigned int v161 = v155 - v141;
                  }
                  else {
                    unsigned int v161 = v141 - v155;
                  }
                  int v152 = *((_DWORD *)v5 + 10) & (v152 + v147);
                  vDSP_Length v151 = v157 - v147;
                  BOOL v149 = v161 > 0x20;
                  v142 += v147;
                  BOOL v162 = v161 < 0x21 || (int)(v157 - v147) < (int)v147;
                  v157 -= v147;
                }
                while (!v162);
                vDSP_Length v43 = v194;
                uint64_t v138 = v196;
              }
              else
              {
                vDSP_Length v151 = v43;
                int v152 = v192;
              }
              uint64_t v137 = v193;
              if ((int)v151 >= 1)
              {
                if (v6 == 2.7183)
                {
                  LODWORD(v163) = *(_DWORD *)(*((void *)v5 + 17) + 4 * v138);
                }
                else
                {
                  if (!v149) {
                    float v143 = v140;
                  }
                  if ((float)(v143 * 1024.0) < 0.0) {
                    float v164 = -1.0;
                  }
                  else {
                    float v164 = 1.0;
                  }
                  uint64_t v163 = (uint64_t)(float)((float)(v143 * 1024.0) + (float)(v164 * 0.5));
                }
                IR::DelayLine::processPolyphaseQ22_10(v5, v152, v163, v142, v151);
              }
              uint64_t v139 = *((void *)v5 + 9);
              *(float *)(v139 + 4 * v138++) = v143;
            }
            while (v138 != v10);
          }
        }
        else
        {
          uint64_t v24 = 0;
          uint64_t v196 = v194;
          unsigned int v25 = *((_DWORD *)v5 + 11);
          unint64_t v26 = v193;
          int v195 = v7;
          do
          {
            float v27 = v7[v24];
            uint64_t v28 = *((void *)v5 + 2);
            *(float *)(v28 + 4 * v25) = v27;
            if (v25 < v13) {
              *(float *)(v28 + 4 * (v25 + v191)) = v27;
            }
            if (v10)
            {
              uint64_t v29 = 0;
              int v30 = v22 - v24;
              do
              {
                if (v6 == 2.7183)
                {
                  uint64_t v31 = *((void *)v5 + 17);
                  LODWORD(v32) = (*(_DWORD *)&v197[4 * v29] - *(_DWORD *)(v31 + 4 * v29)) / v30
                               + *(_DWORD *)(v31 + 4 * v29);
                }
                else
                {
                  float v33 = *(float *)(*((void *)v5 + 6) + 4 * v29);
                  uint64_t v34 = *((void *)v5 + 9);
                  float v35 = v33 + (float)(*((float *)v5 + 24) * (float)(*(float *)(v34 + 4 * v29) - v33));
                  *(float *)(v34 + 4 * v29) = v35;
                  float v36 = v35 * 1024.0;
                  if (v36 < 0.0) {
                    float v37 = -1.0;
                  }
                  else {
                    float v37 = 1.0;
                  }
                  uint64_t v32 = (uint64_t)(float)(v36 + (float)(v37 * 0.5));
                  uint64_t v31 = *((void *)v5 + 17);
                }
                *(_DWORD *)(v31 + 4 * v29) = v32;
                char v38 = *((_DWORD *)v5 + 32);
                char v39 = 10 - v38;
                int v40 = v32 + (1 << (9 - v38)) - 512;
                unsigned int v41 = (unsigned __int16)(v40 & 0x3FF) >> v39;
                if (*((_DWORD *)v5 + 30) <= v41) {
                  IR::DelayLine::process();
                }
                vDSP_dotpr((const float *)(*((void *)v5 + 2)+ 4* ((v11 - (v13 + (v40 >> 10)) + *((_DWORD *)v5 + 11)) & *((_DWORD *)v5 + 10))+ 4 * v13), -1, (const float *)(*((void *)v5 + 13) + 4 * *((_DWORD *)v5 + 33) * v41), 1, &v26[v29++][v24], *((unsigned int *)v5 + 33));
              }
              while (v10 != v29);
              unsigned int v25 = *((_DWORD *)v5 + 11);
              LODWORD(v22) = v194;
              uint64_t v7 = v195;
            }
            unsigned int v25 = *((_DWORD *)v5 + 10) & (v25 + 1);
            *((_DWORD *)v5 + 11) = v25;
            ++v24;
          }
          while (v24 != v196);
        }
        return;
      case 6:
        unint64_t v134 = *((unsigned int *)v5 + 11);
        unsigned int v135 = *((_DWORD *)v5 + 33) - 1;
        if ((int)v134 + (int)v194 >= v11)
        {
          uint64_t v165 = a3;
          uint64_t v166 = (v11 - v134);
          if (v11 != v134) {
            memmove((void *)(*((void *)v5 + 2) + 4 * v134), v7, 4 * v166);
          }
          uint64_t v167 = (char *)v134;
          unsigned int v168 = v194;
          if (v166 != v194) {
            memmove((void *)(*((void *)v5 + 2) + 4 * v135), &v7[v166], 4 * v194 - 4 * v166);
          }
          *((_DWORD *)v5 + 11) += v194 - v11 + v135;
          BOOL v150 = v11 - v135 > v168;
          a3 = v165;
          unint64_t v134 = (unint64_t)v167;
          if (!v150) {
            IR::DelayLine::process();
          }
        }
        else
        {
          memmove((void *)(*((void *)v5 + 2) + 4 * v134), v7, 4 * v194);
          *((_DWORD *)v5 + 11) += v194;
        }
        unsigned int v169 = v11;
        if (v135) {
          memmove(*((void **)v5 + 2), (const void *)(*((void *)v5 + 3) - 4 * v135), 4 * v135);
        }
        if (!v10) {
          return;
        }
        uint64_t v170 = 0;
        int v171 = v135 - v11;
        uint64_t v197 = (char *)v134;
        break;
      default:
        uint64_t v62 = 0;
        uint64_t v63 = *((void *)v5 + 2);
        int v64 = *((_DWORD *)v5 + 10);
        unsigned int v65 = *((_DWORD *)v5 + 11);
        int v66 = v194;
        do
        {
          *(float *)(v63 + 4 * v65) = v7[v62];
          if (v10)
          {
            uint64_t v67 = 0;
            uint64_t v68 = *((void *)v5 + 9);
            do
            {
              if (v6 == 2.7183)
              {
                float v69 = *(float *)(v68 + 4 * v67)
                    + (float)((float)(*(float *)(*((void *)v5 + 6) + 4 * v67) - *(float *)(v68 + 4 * v67))
                            / (float)(v66 - v62));
              }
              else
              {
                float v70 = *(float *)(*((void *)v5 + 6) + 4 * v67);
                float v69 = v70 + (float)(*((float *)v5 + 24) * (float)(*(float *)(v68 + 4 * v67) - v70));
              }
              *(float *)(v68 + 4 * v67) = v69;
              float v71 = (float)v65 - v69;
              if (v71 >= 0.0) {
                float v72 = -0.0;
              }
              else {
                float v72 = (float)v11;
              }
              float v73 = v71 + v72;
              float v74 = *(float *)(v63 + 4 * (v64 & (int)v73));
              a3[v67++][v62] = v74
                             + (float)((float)(v73 - (float)(int)v73)
                                     * (float)(*(float *)(v63 + 4 * (((int)v73 + 1) & v64)) - v74));
            }
            while (v10 != v67);
          }
          unsigned int v65 = v64 & (v65 + 1);
          ++v62;
        }
        while (v62 != v66);
        *((_DWORD *)v5 + 11) = v65;
        return;
    }
    do
    {
      __E = a3[v170];
      int v173 = v134;
      vDSP_Length v174 = v194;
      while (1)
      {
        while (1)
        {
          uint64_t v175 = *((void *)v5 + 35);
          unsigned int v176 = *(_DWORD *)(v175 + 4 * v170);
          if (!v176) {
            break;
          }
          if (v174 >= v176) {
            vDSP_Length v177 = v176;
          }
          else {
            vDSP_Length v177 = v174;
          }
          float v178 = *(float *)(*((void *)v5 + 9) + 4 * v170) * 1024.0;
          if (v178 < 0.0) {
            float v179 = -1.0;
          }
          else {
            float v179 = 1.0;
          }
          IR::DelayLine::processPolyphaseQ22_10(v5, v173, (uint64_t)(float)(v178 + (float)(v179 * 0.5)), *((float **)v5 + 29), v177);
          float v180 = *(float *)(*((void *)v5 + 32) + 4 * v170) * 1024.0;
          if (v180 < 0.0) {
            float v181 = -1.0;
          }
          else {
            float v181 = 1.0;
          }
          IR::DelayLine::processPolyphaseQ22_10(v5, v173, (uint64_t)(float)(v180 + (float)(v181 * 0.5)), *((float **)v5 + 26), v177);
          uint64_t v182 = *((void *)v5 + 20);
          unint64_t v183 = ((unint64_t)(*((void *)v5 + 21) - v182) >> 2)
               - *(unsigned int *)(*((void *)v5 + 35) + 4 * v170);
          vDSP_vmma((const float *)(v182 + 4 * v183), 1, *((const float **)v5 + 26), 1, (const float *)(*((void *)v5 + 23) + 4 * v183), 1, *((const float **)v5 + 29), 1, __E, 1, v177);
          *(_DWORD *)(*((void *)v5 + 35) + 4 * v170) -= v177;
          vDSP_Length v174 = (v174 - v177);
          if ((int)v177 + v173 >= v169) {
            int v184 = v171;
          }
          else {
            int v184 = 0;
          }
          v173 += v177 + v184;
          __E += v177;
          if (!v174) {
            goto LABEL_192;
          }
        }
        uint64_t v185 = *((void *)v5 + 6);
        uint64_t v186 = *((void *)v5 + 9);
        float v187 = *(float *)(v186 + 4 * v170);
        if (*(float *)(v185 + 4 * v170) == v187) {
          break;
        }
        *(_DWORD *)(v175 + 4 * v17std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = (*((void *)v5 + 21) - *((void *)v5 + 20)) >> 2;
        *(float *)(*((void *)v5 + 32) + 4 * v17std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = v187;
        *(_DWORD *)(v186 + 4 * v17std::unique_ptr<IR::IRData::Implementation>::reset[abi:ne180100](this, 0) = *(_DWORD *)(v185 + 4 * v170);
        if (!v174) {
          goto LABEL_192;
        }
      }
      float v188 = v187 * 1024.0;
      if (v188 < 0.0) {
        float v189 = -1.0;
      }
      else {
        float v189 = 1.0;
      }
      IR::DelayLine::processPolyphaseQ22_10(v5, v173, (uint64_t)(float)(v188 + (float)(v189 * 0.5)), __E, v174);
LABEL_192:
      ++v170;
      LODWORD(v134) = v197;
    }
    while (v170 != v10);
  }
  else if (v6 == 2.7183)
  {
    IR::DelayLine::swapDelays(this);
  }
}

void *IR::DelayLine::swapDelays(IR::DelayLine *this)
{
  int v2 = (const void *)*((void *)this + 6);
  unint64_t v3 = (uint64_t)(*((void *)this + 7) - (void)v2) >> 2;
  float v5 = (char *)this + 72;
  CFTypeRef result = (void *)*((void *)this + 9);
  unint64_t v6 = (uint64_t)(*((void *)v5 + 1) - (void)result) >> 2;
  if (v6 >= v3) {
    unint64_t v7 = v3;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7) {
    CFTypeRef result = memmove(result, v2, 4 * v7);
  }
  if ((*((_DWORD *)this + 1) | 2) == 7)
  {
    unsigned int v8 = (_DWORD *)*((void *)this + 17);
    uint64_t v9 = *((void *)this + 18) - (void)v8;
    uint64_t v10 = (float *)*((void *)this + 6);
    uint64_t v11 = (uint64_t)(*((void *)this + 7) - (void)v10) >> 2 >= (unint64_t)(v9 >> 2)
        ? v9 >> 2
        : (uint64_t)(*((void *)this + 7) - (void)v10) >> 2;
    uint64_t v11 = v11;
    if (v11)
    {
      do
      {
        float v12 = *v10++;
        float v13 = v12 * 1024.0;
        if ((float)(v12 * 1024.0) < 0.0) {
          float v14 = -1.0;
        }
        else {
          float v14 = 1.0;
        }
        *v8++ = (uint64_t)(float)(v13 + (float)(v14 * 0.5));
        --v11;
      }
      while (v11);
    }
  }
  return result;
}

void IR::DelayLine::process(IR::DelayLine *this, const float *a2, float *a3, vDSP_Length a4)
{
  v4[1] = *(float **)MEMORY[0x263EF8340];
  v4[0] = a3;
  IR::DelayLine::process(this, a2, v4, 1u, a4);
}

void std::default_delete<SincKernelFactory>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v2 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x21D48F780);
  }
}

void SincKernelFactory::SincKernelFactory(SincKernelFactory *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  std::vector<void const*>::reserve((void **)this, 0x20uLL);
}

void sub_21B50DE94(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void AudioDSP::Core::VBAP::VBAP(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_21B50DF2C(void *a1)
{
  MEMORY[0x21D48F780](v2, 0x10B0C403CF8D957);
  __cxa_begin_catch(a1);
  std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100](v1, 0);
  __cxa_rethrow();
}

void sub_21B50DF6C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *CFTypeRef result = a2;
  if (v2)
  {
    VBAP::~VBAP((VBAP *)(v2 + 8));
    JUMPOUT(0x21D48F780);
  }
  return result;
}

void AudioDSP::Core::VBAP::~VBAP(AudioDSP::Core::VBAP *this)
{
}

{
  std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100]((uint64_t *)this, 0);
}

uint64_t AudioDSP::Core::VBAP::calculateVBAPGains(uint64_t a1, float32x2_t *a2, float **a3)
{
  if (*(void *)a1) {
    return VBAP::calculateVBAPGains((VBAP *)(*(void *)a1 + 8), a2, *a3);
  }
  else {
    return 4294956429;
  }
}

uint64_t AudioDSP::Core::VBAP::triangleLookup(uint64_t a1, float32x2_t *a2, int *a3, float *a4)
{
  if (*(void *)a1) {
    return VBAP::triangleLookup((VBAP *)(*(void *)a1 + 8), a2, a3, a4);
  }
  else {
    return 4294956429;
  }
}

uint64_t AudioDSP::Core::VBAP::changeSpeakerLocations(void *a1, uint64_t *a2, uint64_t *a3)
{
  if (*a1) {
    return VBAP::changeSpeakerLocations(*a1 + 8, a2, a3);
  }
  else {
    return 4294956429;
  }
}

uint64_t AudioDSP::Core::VBAP::Implementation::Implementation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = *(const void **)a2;
  uint64_t v8 = *(void *)(a2 + 8);
  unint64_t v10 = (v8 - (uint64_t)v7) >> 2;
  *(void *)a1 = v10;
  uint64_t v11 = a1 + 8;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v17, v7, v8, v10);
  long long __p = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  VBAP::VBAP(v11, (uint64_t *)&v17, (uint64_t *)&__p, *(_DWORD *)a4, (char **)(a4 + 8), (uint64_t *)(a4 + 32));
  if (__p)
  {
    uint64_t v15 = __p;
    operator delete(__p);
  }
  if (v17)
  {
    unint64_t v18 = v17;
    operator delete(v17);
  }
  if (!*(unsigned char *)(a1 + 323))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Failed to initialize VBAP with the arguments provided.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  return a1;
}

void sub_21B50E1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  VBAP::~VBAP(v13);
  _Unwind_Resume(a1);
}

void IR::getFilePtr(const __CFURL **a1@<X0>, int a2@<W1>, FILE **a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  CFURLRef v5 = *a1;
  unint64_t v6 = (FILE *)MEMORY[0x263EF88A8];
  *a3 = 0;
  a3[1] = v6;
  if (v5)
  {
    unint64_t v7 = (IR *)CFURLGetFileSystemRepresentation(v5, 1u, buffer, 1024);
    if (v7)
    {
      uint64_t v8 = (IR *)stat((const char *)buffer, &v31);
      int v9 = (int)v8;
      if (v8)
      {
        if (a2)
        {
          IRDataLog = IR::getIRDataLog(v8);
          if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_ERROR)) {
            IR::getFilePtr(v9, IRDataLog);
          }
        }
      }
      else if ((v31.st_mode & 0xF000) == 0x4000)
      {
        if (a2)
        {
          float v27 = IR::getIRDataLog(v8);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            IR::getFilePtr();
          }
        }
      }
      else
      {
        uint64_t v28 = fopen((const char *)buffer, "r");
        uint64_t v29 = (FILE *)MEMORY[0x263EF88A8];
        *a3 = v28;
        a3[1] = v29;
        if (!v28)
        {
          if (a2)
          {
            int v30 = IR::getIRDataLog(0);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              IR::getFilePtr();
            }
          }
        }
      }
    }
    else if (a2)
    {
      uint64_t v19 = IR::getIRDataLog(v7);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        IR::getFilePtr(v19, v20, v21, v22, v23, v24, v25, v26);
      }
    }
  }
  else if (a2)
  {
    uint64_t v11 = IR::getIRDataLog(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      IR::getFilePtr(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
}

void sub_21B50E390(_Unwind_Exception *a1)
{
  void *v1 = 0;
  _Unwind_Resume(a1);
}

void IR::getFilePtr(CFTypeRef *this@<X0>, const IR::IRDataAttributes *a2@<X1>, FILE **a3@<X8>)
{
  int v3 = (int)a2;
  CFURLRef v5 = (const __CFURL *)*this;
  if (*this) {
    CFRetain(*this);
  }
  CFURLRef v6 = v5;
  IR::getFilePtr(&v6, v3, a3);
  if (v5) {
    CFRelease(v5);
  }
}

void sub_21B50E424(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::URLRef::~URLRef((const void **)va);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::~Implementation(IR::IRDataLoader::Implementation *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t v2 = (IR::IRDataLoader::Implementation *)((char *)this + 160);
  IR::PersonalizedIRData::UnregisterObservers((IR::PersonalizedIRData::Implementation **)this + 20);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 88));
  std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::clear((uint64_t)this + 168);
  IRDataLog = IR::getIRDataLog(v3);
  if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)CFURLRef v5 = 136315138;
    *(void *)&v5[4] = "~Implementation";
    _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "%s: Personalized HRTF listener is unregistered, all callbacks are cleared.", v5, 0xCu);
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)((char *)this + 88));
  std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::destroy((uint64_t)this + 208, *((void **)this + 27));
  std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::~__hash_table((uint64_t)this + 168);
  IR::PersonalizedIRData::~PersonalizedIRData(v2);
  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)((char *)this + 88));
  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)((char *)this + 24));
  *(void *)CFURLRef v5 = this;
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__destroy_vector::operator()[abi:ne180100]((void ***)v5);
}

void sub_21B50E554(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void IR::IRDataLoader::Implementation::load(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t *a6@<X8>, float a7@<S0>)
{
  IR::getPresetDataAttributes(a3, (uint64_t)&v14);
  float v15 = a7;
  int v16 = a4;
  uint64_t v13 = 0;
  IR::IRDataLoader::Implementation::load(a1, a2, (uint64_t)&v14, &v13, a5, a6);
  if (cf) {
    CFRelease(cf);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v14) {
    CFRelease(v14);
  }
}

void sub_21B50E628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void IR::IRDataLoader::Implementation::load(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const void **a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v12 = (std::recursive_mutex *)(a1 + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 24));
  uint64_t v13 = *a4;
  if (v13) {
    CFRetain(v13);
  }
  CFTypeRef cf = v13;
  IR::IRDataLoader::Implementation::loadPrivate((unsigned __int8 *)a1, a2, a3, &cf, a5, a6);
  if (cf) {
    CFRelease(cf);
  }
  float v15 = *(uint64_t **)a1;
  CFTypeRef v14 = *(uint64_t **)(a1 + 8);
  if (*(uint64_t **)a1 == v14)
  {
    CFTypeRef v14 = *(uint64_t **)a1;
  }
  else
  {
    int v16 = v15 + 21;
    while (1)
    {
      uint64_t v17 = *(v16 - 1);
      if (!v17 || *(void *)(v17 + 8) == -1) {
        break;
      }
      BOOL v18 = v16 == v14;
      v16 += 21;
      if (v18)
      {
        float v15 = *(uint64_t **)(a1 + 8);
        goto LABEL_20;
      }
    }
    float v15 = v16 - 21;
    if (v16 - 21 != v14 && v16 != v14)
    {
      do
      {
        uint64_t v19 = v16[20];
        if (v19 && *(void *)(v19 + 8) != -1)
        {
          std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>::operator=[abi:ne180100](v15, v16);
          v15 += 21;
        }
        v16 += 21;
      }
      while (v16 != v14);
      CFTypeRef v14 = *(uint64_t **)(a1 + 8);
    }
  }
LABEL_20:
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::erase(a1, v15, v14);
  std::recursive_mutex::unlock(v12);
}

void sub_21B50E78C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v13 = *(std::__shared_weak_count **)(v11 + 8);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  std::recursive_mutex::unlock(v10);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::create(float a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, unsigned __int8 a15, int a16, int a17)
{
  int v17 = a17;
  int v18 = a14;
  int v19 = a15;
  float v25 = a1;
  int v24 = a9;
  unsigned __int8 v23 = a15;
  CFTypeRef v20 = *a5;
  if (*a5)
  {
    CFRetain(*a5);
    a1 = v25;
    int v18 = a14;
    int v19 = v23;
    int v17 = a17;
  }
  CFTypeRef cf = v20;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)v22, &cf, v18, v19 != 0, v17, a1);
  if (cf) {
    CFRelease(cf);
  }
  std::allocate_shared[abi:ne180100]<IR::IRData,std::allocator<IR::IRData>,std::vector<std::vector<float>> const&,std::vector<std::vector<float>> const&,std::vector<IR::IRCoordinateType> const&,std::vector<std::vector<float>> const&,float &,unsigned int &,std::vector<float> const&,std::vector<IR::IRInterpolationMethod> const&,applesauce::CF::DictionaryRef const&,std::string const&,unsigned int &,BOOL &,unsigned int &,IR::IRSphericalInterpolation &,std::vector<float> const&,void>();
}

void sub_21B50E968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::swapLoadedIR(uint64_t a1, float *a2, uint64_t *a3)
{
  uint64_t v6 = (std::recursive_mutex *)(a1 + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 24));
  uint64_t v8 = *a3;
  unint64_t v7 = (std::__shared_weak_count *)a3[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v9 = *(void *)a1;
  unint64_t v10 = *(void *)(a1 + 8);
  if (*(void *)a1 != v10)
  {
    while ((IR::IRDataAttributes::operator==(v9, (uint64_t)a2) & 1) == 0)
    {
      if (a2[2] == 0.0)
      {
        if (IR::IRDataAttributes::equalsExceptSampleRate((IR::IRDataAttributes *)a2, (const IR::IRDataAttributes *)v9))
        {
          uint64_t v11 = *(std::__shared_weak_count **)(v9 + 160);
          if (v11)
          {
            uint64_t v12 = std::__shared_weak_count::lock(v11);
            if (v12)
            {
              uint64_t v13 = v12;
              CFTypeRef v14 = *(IR::IRData **)(v9 + 152);
              if (v14)
              {
                float OriginalSampleRate = IR::IRData::getOriginalSampleRate(*(IR::IRData **)(v9 + 152));
                if (OriginalSampleRate == IR::IRData::getSampleRate(v14))
                {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v13);
                  break;
                }
              }
              std::__shared_weak_count::__release_shared[abi:ne180100](v13);
            }
          }
        }
      }
      v9 += 168;
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  if (v9 == *(void *)(a1 + 8))
  {
    if (v9 >= *(void *)(a1 + 16))
    {
      uint64_t v19 = std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__emplace_back_slow_path<IR::IRDataAttributes const&,std::shared_ptr<IR::IRData const> const&>((uint64_t *)a1, (const IR::IRDataAttributes *)a2, a3);
    }
    else
    {
      IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)v9, (const IR::IRDataAttributes *)a2);
      uint64_t v18 = a3[1];
      *(void *)(v9 + 152) = *a3;
      *(void *)(v9 + 16std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100]((uint64_t *)this, 0) = v18;
      if (v18) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 16), 1uLL, memory_order_relaxed);
      }
      uint64_t v19 = v9 + 168;
    }
    *(void *)(a1 + 8) = v19;
    if (v7) {
      goto LABEL_16;
    }
  }
  else
  {
    int v16 = *(std::__shared_weak_count **)(v9 + 160);
    *(void *)(v9 + 152) = v8;
    *(void *)(v9 + 16std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100]((uint64_t *)this, 0) = v7;
    unint64_t v7 = v16;
    if (v16) {
LABEL_16:
    }
      std::__shared_weak_count::__release_weak(v7);
  }
  std::recursive_mutex::unlock(v6);
  return 1;
}

void sub_21B50EB58(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::loadPrivate(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v102 = *MEMORY[0x263EF8340];
  v89[0] = 0;
  v89[1] = 0;
  if (*a4) {
    goto LABEL_15;
  }
  if ((*(_DWORD *)(a3 + 48) - 1) > 1) {
    goto LABEL_15;
  }
  unsigned __int8 v12 = atomic_load(a1 + 152);
  if (v12) {
    goto LABEL_15;
  }
  int IsPersonalizedHRIRAllowed = IR::PersonalizedIRData::IsPersonalizedHRIRAllowed((IR::PersonalizedIRData *)(a1 + 160));
  uint64_t PersonalizedHRTF = IR::IRDataLoader::Implementation::hasFailedToFetchPersonalizedHRTF((IR::IRDataLoader::Implementation *)a1);
  int v15 = PersonalizedHRTF;
  uint64_t v16 = *(unsigned int *)(a3 + 48);
  if ((PersonalizedHRTF | IsPersonalizedHRIRAllowed ^ 1))
  {
LABEL_5:
    IRDataLog = IR::getIRDataLog((IR *)PersonalizedHRTF);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
    {
      int v85 = v16;
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v18 = a2;
      }
      else {
        uint64_t v18 = *(void *)a2;
      }
      if (v15) {
        uint64_t v19 = "unavailable";
      }
      else {
        uint64_t v19 = "disabled";
      }
      if (!*(void *)a3)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](exception, "Could not construct");
      }
      CFStringRef v20 = CFURLCopyFileSystemPath(*(CFURLRef *)a3, kCFURLPOSIXPathStyle);
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)theString, v20);
      CStringPtr = CFStringGetCStringPtr(theString[0], 0x8000100u);
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "loadPrivate";
      __int16 v93 = 1024;
      *(_DWORD *)float v94 = v85;
      *(_WORD *)&v94[4] = 2080;
      *(void *)&v94[6] = v19;
      __int16 v95 = 2080;
      float v96 = CStringPtr;
      _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "%s%s: Personalized HRIR type %u is %s. Reverting back to generic HRIR: %s.", buf, 0x30u);
      if (theString[0]) {
        CFRelease(theString[0]);
      }
    }
LABEL_15:
    IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)a1, (const IR::IRDataAttributes *)a3, 0x100000000, a6);
    if (*a6)
    {
      unsigned __int8 v23 = IR::getIRDataLog(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        if (*(char *)(a2 + 23) < 0) {
          a2 = *(void *)a2;
        }
        if (!*(void *)a3)
        {
          float v81 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x21D48F410](v81, "Could not construct");
        }
        CFStringRef v24 = CFURLCopyFileSystemPath(*(CFURLRef *)a3, kCFURLPOSIXPathStyle);
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)theString, v24);
        float v25 = CFStringGetCStringPtr(theString[0], 0x8000100u);
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "loadPrivate";
        __int16 v93 = 2080;
        *(void *)float v94 = v25;
        _os_log_debug_impl(&dword_21B4DD000, v23, OS_LOG_TYPE_DEBUG, "%s%s: Fetched IR from cache: %s", buf, 0x20u);
        if (theString[0]) {
          CFRelease(theString[0]);
        }
      }
      goto LABEL_107;
    }
    uint64_t v26 = (std::__shared_weak_count *)a6[1];
    if (v26) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v26);
    }
    IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)buf, (const IR::IRDataAttributes *)a3);
    int v97 = 0;
    if (*(_DWORD *)(a3 + 48))
    {
      IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)a1, (const IR::IRDataAttributes *)buf, 0, a6);
      if (*a6)
      {
        IR::IRDataLoader::Implementation::addIRDataToCache((uint64_t)a1, (uint64_t *)a2, (IR::IRDataAttributes *)a3, (IR::IRData **)a6);
        uint64_t v28 = IR::getIRDataLog(v27);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          if (*(char *)(a2 + 23) < 0) {
            a2 = *(void *)a2;
          }
          float v88 = (CFURLRef *)applesauce::CF::URLRef::operator->(buf);
          applesauce::CF::URLRef_proxy::get_filesystem_path(&v88, (applesauce::CF::StringRef *)&v87);
          uint64_t v29 = CFStringGetCStringPtr((CFStringRef)v87.__r_.__value_.__l.__data_, 0x8000100u);
          LODWORD(theString[0]) = 136315650;
          *(CFStringRef *)((char *)theString + 4) = (CFStringRef)a2;
          WORD2(theString[1]) = 2080;
          *(CFStringRef *)((char *)&theString[1] + 6) = (CFStringRef)"loadPrivate";
          HIWORD(theString[2]) = 2080;
          float v91 = (std::string *)v29;
          _os_log_debug_impl(&dword_21B4DD000, v28, OS_LOG_TYPE_DEBUG, "%s%s: Fetched IR from cache: %s", (uint8_t *)theString, 0x20u);
          applesauce::CF::StringRef::~StringRef((const void **)&v87.__r_.__value_.__l.__data_);
        }
LABEL_99:
        if (v101) {
          CFRelease(v101);
        }
        if (cf) {
          CFRelease(cf);
        }
        if (v98) {
          CFRelease(v98);
        }
        if (*(void *)buf) {
          CFRelease(*(CFTypeRef *)buf);
        }
        goto LABEL_107;
      }
      int v30 = (std::__shared_weak_count *)a6[1];
      if (v30) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v30);
      }
    }
    if (!cf && (!v100 || ChannelLayoutTagIsHOAWithAnyNumberOfChannels(v100)))
    {
      std::allocate_shared[abi:ne180100]<IR::IRData,std::allocator<IR::IRData>,IR::IRDataAttributes &,applesauce::CF::DataRef &,std::vector<float> const&,void>((uint64_t)buf, a4, a5, theString);
      long long v45 = *(_OWORD *)theString;
      theString[0] = 0;
      theString[1] = 0;
      int v46 = (std::__shared_weak_count *)v89[1];
      *(_OWORD *)float v89 = v45;
      if (v46)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v46);
        if (theString[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)theString[1]);
        }
      }
      Filterunsigned int Length = v89[0];
      if (v89[0])
      {
        Filterunsigned int Length = (IR *)IR::IRData::getFilterLength(v89[0]);
        if (!FilterLength)
        {
          Filterunsigned int Length = v89[1];
          v89[0] = 0;
          v89[1] = 0;
          if (!FilterLength) {
            goto LABEL_89;
          }
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)FilterLength);
        }
        if (v89[0])
        {
          unsigned int v48 = IR::getIRDataLog(FilterLength);
          std::string::size_type v49 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
          if (v49)
          {
            if (*(char *)(a2 + 23) >= 0) {
              CFStringRef v50 = (const __CFString *)a2;
            }
            else {
              CFStringRef v50 = *(const __CFString **)a2;
            }
            if (!*(void *)buf)
            {
              float v84 = __cxa_allocate_exception(0x10uLL);
              MEMORY[0x21D48F410](v84, "Could not construct");
            }
            CFStringRef v51 = CFURLCopyFileSystemPath(*(CFURLRef *)buf, kCFURLPOSIXPathStyle);
            applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v87, v51);
            float v52 = CFStringGetCStringPtr((CFStringRef)v87.__r_.__value_.__l.__data_, 0x8000100u);
            LODWORD(theString[0]) = 136315650;
            *(CFStringRef *)((char *)theString + 4) = v50;
            WORD2(theString[1]) = 2080;
            *(CFStringRef *)((char *)&theString[1] + 6) = (CFStringRef)"loadPrivate";
            HIWORD(theString[2]) = 2080;
            float v91 = (std::string *)v52;
            _os_log_impl(&dword_21B4DD000, v48, OS_LOG_TYPE_DEFAULT, "%s%s: IR loaded: %s", (uint8_t *)theString, 0x20u);
            std::string::size_type v49 = v87.__r_.__value_.__r.__words[0];
            if (v87.__r_.__value_.__r.__words[0]) {
              CFRelease(v87.__r_.__value_.__l.__data_);
            }
          }
          int v40 = IR::getIRDataLog((IR *)v49);
          if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_96;
          }
          int v53 = *(char *)(a2 + 23);
          uint64_t v54 = *(void *)a2;
          IR::IRDataAttributes::description((IR::IRDataAttributes *)buf, 0, &v87);
          if (v53 >= 0) {
            CFStringRef v43 = (const __CFString *)a2;
          }
          else {
            CFStringRef v43 = (const __CFString *)v54;
          }
          if ((v87.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v44 = &v87;
          }
          else {
            uint64_t v44 = (std::string *)v87.__r_.__value_.__r.__words[0];
          }
          goto LABEL_76;
        }
      }
LABEL_89:
      float v59 = IR::getIRDataLog(FilterLength);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0) {
          CFStringRef v60 = (const __CFString *)a2;
        }
        else {
          CFStringRef v60 = *(const __CFString **)a2;
        }
        float v88 = (CFURLRef *)applesauce::CF::URLRef::operator->(buf);
        applesauce::CF::URLRef_proxy::get_filesystem_path(&v88, (applesauce::CF::StringRef *)&v87);
        float v61 = CFStringGetCStringPtr((CFStringRef)v87.__r_.__value_.__l.__data_, 0x8000100u);
        LODWORD(theString[0]) = 136315650;
        *(CFStringRef *)((char *)theString + 4) = v60;
        WORD2(theString[1]) = 2080;
        *(CFStringRef *)((char *)&theString[1] + 6) = (CFStringRef)"loadPrivate";
        HIWORD(theString[2]) = 2080;
        float v91 = (std::string *)v61;
        uint64_t v62 = "%s%s: Failed to load IR: %s";
LABEL_143:
        _os_log_error_impl(&dword_21B4DD000, v59, OS_LOG_TYPE_ERROR, v62, (uint8_t *)theString, 0x20u);
        applesauce::CF::StringRef::~StringRef((const void **)&v87.__r_.__value_.__l.__data_);
        goto LABEL_96;
      }
      goto LABEL_96;
    }
    int AudioChannelLayoutTagPrivate = IR::IRDataLoader::Implementation::getAudioChannelLayoutTagPrivate((IR::IRDataLoader::Implementation *)a1, (const IR::IRDataAttributes *)buf, 0);
    BOOL IsSupportedHOA = ChannelLayoutTagIsSupportedHOA(AudioChannelLayoutTagPrivate);
    if (!IsSupportedHOA)
    {
      float v55 = IR::getIRDataLog((IR *)IsSupportedHOA);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        if (*(char *)(a2 + 23) >= 0) {
          CFStringRef v74 = (const __CFString *)a2;
        }
        else {
          CFStringRef v74 = *(const __CFString **)a2;
        }
        float v88 = (CFURLRef *)applesauce::CF::URLRef::operator->(buf);
        applesauce::CF::URLRef_proxy::get_filesystem_path(&v88, (applesauce::CF::StringRef *)&v87);
        uint64_t v75 = CFStringGetCStringPtr((CFStringRef)v87.__r_.__value_.__l.__data_, 0x8000100u);
        LODWORD(theString[0]) = 136315650;
        *(CFStringRef *)((char *)theString + 4) = v74;
        WORD2(theString[1]) = 2080;
        *(CFStringRef *)((char *)&theString[1] + 6) = (CFStringRef)"loadPrivate";
        HIWORD(theString[2]) = 2080;
        float v91 = (std::string *)v75;
        _os_log_debug_impl(&dword_21B4DD000, v55, OS_LOG_TYPE_DEBUG, "%s%s: HOA decoder attributes set, but IR is not HOA; loading without decoding: %s",
          (uint8_t *)theString,
          0x20u);
        applesauce::CF::StringRef::~StringRef((const void **)&v87.__r_.__value_.__l.__data_);
      }
      CFTypeRef v56 = cf;
      CFTypeRef cf = 0;
      if (v56) {
        CFRelease(v56);
      }
      unsigned int v100 = 0;
      CFTypeRef v86 = 0;
      memset(theString, 0, sizeof(theString));
      IR::IRDataLoader::Implementation::loadPrivate(a1, a2, buf, &v86, theString);
      if (theString[0])
      {
        theString[1] = theString[0];
        operator delete((void *)theString[0]);
      }
      if (v86) {
        CFRelease(v86);
      }
      goto LABEL_99;
    }
    IR::IRDataLoader::Implementation::loadAndDecode((IR::IRDataAttributes *)buf, (IR::IRDataLoader::Implementation *)a1, (char *)a2, theString);
    long long v33 = *(_OWORD *)theString;
    theString[0] = 0;
    theString[1] = 0;
    uint64_t v34 = (std::__shared_weak_count *)v89[1];
    *(_OWORD *)float v89 = v33;
    if (v34)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v34);
      uint64_t v34 = (std::__shared_weak_count *)theString[1];
      if (theString[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)theString[1]);
      }
      if (v89[0]) {
        goto LABEL_38;
      }
    }
    else if ((void)v33)
    {
LABEL_38:
      float v35 = IR::getIRDataLog((IR *)v34);
      std::string::size_type v36 = os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT);
      if (v36)
      {
        if (*(char *)(a2 + 23) >= 0) {
          CFStringRef v37 = (const __CFString *)a2;
        }
        else {
          CFStringRef v37 = *(const __CFString **)a2;
        }
        if (!*(void *)buf)
        {
          float v83 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x21D48F410](v83, "Could not construct");
        }
        CFStringRef v38 = CFURLCopyFileSystemPath(*(CFURLRef *)buf, kCFURLPOSIXPathStyle);
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v87, v38);
        char v39 = CFStringGetCStringPtr((CFStringRef)v87.__r_.__value_.__l.__data_, 0x8000100u);
        LODWORD(theString[0]) = 136315650;
        *(CFStringRef *)((char *)theString + 4) = v37;
        WORD2(theString[1]) = 2080;
        *(CFStringRef *)((char *)&theString[1] + 6) = (CFStringRef)"loadPrivate";
        HIWORD(theString[2]) = 2080;
        float v91 = (std::string *)v39;
        _os_log_impl(&dword_21B4DD000, v35, OS_LOG_TYPE_DEFAULT, "%s%s: Decoded HOA IR: %s", (uint8_t *)theString, 0x20u);
        std::string::size_type v36 = v87.__r_.__value_.__r.__words[0];
        if (v87.__r_.__value_.__r.__words[0]) {
          CFRelease(v87.__r_.__value_.__l.__data_);
        }
      }
      int v40 = IR::getIRDataLog((IR *)v36);
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_96;
      }
      int v41 = *(char *)(a2 + 23);
      uint64_t v42 = *(void *)a2;
      IR::IRDataAttributes::description((IR::IRDataAttributes *)buf, 0, &v87);
      if (v41 >= 0) {
        CFStringRef v43 = (const __CFString *)a2;
      }
      else {
        CFStringRef v43 = (const __CFString *)v42;
      }
      if ((v87.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v44 = &v87;
      }
      else {
        uint64_t v44 = (std::string *)v87.__r_.__value_.__r.__words[0];
      }
LABEL_76:
      LODWORD(theString[0]) = 136315650;
      *(CFStringRef *)((char *)theString + 4) = v43;
      WORD2(theString[1]) = 2080;
      *(CFStringRef *)((char *)&theString[1] + 6) = (CFStringRef)"loadPrivate";
      HIWORD(theString[2]) = 2080;
      float v91 = v44;
      _os_log_debug_impl(&dword_21B4DD000, v40, OS_LOG_TYPE_DEBUG, "%s%s: IR attributes: %s", (uint8_t *)theString, 0x20u);
      if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v87.__r_.__value_.__l.__data_);
      }
      goto LABEL_96;
    }
    float v59 = IR::getIRDataLog((IR *)v34);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        CFStringRef v76 = (const __CFString *)a2;
      }
      else {
        CFStringRef v76 = *(const __CFString **)a2;
      }
      float v88 = (CFURLRef *)applesauce::CF::URLRef::operator->(buf);
      applesauce::CF::URLRef_proxy::get_filesystem_path(&v88, (applesauce::CF::StringRef *)&v87);
      int v77 = CFStringGetCStringPtr((CFStringRef)v87.__r_.__value_.__l.__data_, 0x8000100u);
      LODWORD(theString[0]) = 136315650;
      *(CFStringRef *)((char *)theString + 4) = v76;
      WORD2(theString[1]) = 2080;
      *(CFStringRef *)((char *)&theString[1] + 6) = (CFStringRef)"loadPrivate";
      HIWORD(theString[2]) = 2080;
      float v91 = (std::string *)v77;
      uint64_t v62 = "%s%s: Failed to decode HOA IR: %s";
      goto LABEL_143;
    }
LABEL_96:
    uint64_t v63 = v89[0];
    if (v89[0])
    {
      IR::IRDataLoader::Implementation::addIRDataToCache((uint64_t)a1, (uint64_t *)a2, (IR::IRDataAttributes *)a3, v89);
      uint64_t v63 = v89[0];
    }
    int v64 = v89[1];
    *a6 = (uint64_t)v63;
    a6[1] = (uint64_t)v64;
    v89[0] = 0;
    v89[1] = 0;
    goto LABEL_99;
  }
  IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)a1, (const IR::IRDataAttributes *)a3, v16 | 0x100000000, (uint64_t *)buf);
  float v57 = v89[1];
  *(_OWORD *)float v89 = *(_OWORD *)buf;
  if (*(void *)buf)
  {
    float v58 = IR::getIRDataLog(v57);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG)) {
      IR::IRDataLoader::Implementation::loadPrivate();
    }
    *(_OWORD *)a6 = *(_OWORD *)v89;
    v89[0] = 0;
    v89[1] = 0;
  }
  else
  {
    unsigned int v65 = IR::getIRDataLog(v57);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v66 = a2;
      }
      else {
        uint64_t v66 = *(void *)a2;
      }
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v66;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "loadPrivate";
      __int16 v93 = 1024;
      *(_DWORD *)float v94 = v16;
      _os_log_impl(&dword_21B4DD000, v65, OS_LOG_TYPE_DEFAULT, "%s%s: Could not find personalized HRIR type %u in IRDataLoader cache. Searching CFData cache.", buf, 0x1Cu);
    }
    IR::PersonalizedIRData::GetCFData((uint64_t *)a1 + 20, v16, 1, 0x5DCu, (uint64_t)buf);
    uint64_t PersonalizedHRTF = 0;
    uint64_t v67 = *(void *)&buf[8];
    theString[0] = *(CFStringRef *)&buf[8];
    *(void *)&buf[8] = 0;
    if (!v67)
    {
      uint64_t PersonalizedHRTF = IR::PersonalizedIRData::GetStatus((IR::PersonalizedIRData *)(a1 + 160));
      if ((PersonalizedHRTF & 1) == 0)
      {
        if (*(unsigned char *)(a3 + 56))
        {
          if (IR::PersonalizedIRData::GetDataSource((IR::PersonalizedIRData *)(a1 + 160)) == 1)
          {
            IR::IRDataLoader::Implementation::rebuildPersonalizedHRTFCache((IR::IRDataLoader::Implementation *)a1);
          }
          else
          {
            DataSource = (IR *)IR::PersonalizedIRData::GetDataSource((IR::PersonalizedIRData *)(a1 + 160));
            if (DataSource == 2)
            {
              *(void *)float v94 = 0;
              IR::PersonalizedIRData::RebuildCFDataCache((IR::DataCache ***)a1 + 20, (uint64_t)buf);
              std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](buf);
              IR::PersonalizedIRData::GetCFData((uint64_t *)a1 + 20, v16, 1, 0x5DCu, (uint64_t)buf);
              CFStringRef v79 = theString[0];
              theString[0] = *(CFStringRef *)&buf[8];
              *(void *)&buf[8] = v79;
              uint64_t PersonalizedHRTF = std::pair<BOOL,applesauce::CF::DataRef>::~pair((uint64_t)buf);
            }
            else
            {
              uint64_t v80 = IR::getIRDataLog(DataSource);
              uint64_t PersonalizedHRTF = os_log_type_enabled(v80, OS_LOG_TYPE_ERROR);
              if (PersonalizedHRTF) {
                IR::IRDataLoader::Implementation::loadPrivate();
              }
            }
          }
        }
      }
    }
    if (!theString[0]) {
      goto LABEL_130;
    }
    std::allocate_shared[abi:ne180100]<IR::IRData,std::allocator<IR::IRData>,IR::IRDataAttributes const&,applesauce::CF::DataRef &,std::vector<float> const&,void>(a3, (CFTypeRef *)theString, a5, buf);
    long long v68 = *(_OWORD *)buf;
    *(void *)buf = 0;
    *(void *)&buf[8] = 0;
    float v69 = (std::__shared_weak_count *)v89[1];
    *(_OWORD *)float v89 = v68;
    if (v69)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      if (*(void *)&buf[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
      }
    }
    float v70 = v89[0];
    if (v89[0])
    {
      IR::IRDataLoader::Implementation::addIRDataToCache((uint64_t)a1, (uint64_t *)a2, (IR::IRDataAttributes *)a3, v89);
      float v72 = IR::getIRDataLog(v71);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v73 = a2;
        }
        else {
          uint64_t v73 = *(void *)a2;
        }
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = v73;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "loadPrivate";
        __int16 v93 = 1024;
        *(_DWORD *)float v94 = v16;
        _os_log_impl(&dword_21B4DD000, v72, OS_LOG_TYPE_DEFAULT, "%s%s: Personalized HRIR type %u is stored in IRDataLoader cache.", buf, 0x1Cu);
      }
      IR::PersonalizedIRData::ClearCache((IR::DataCache ***)a1 + 20);
      *(_OWORD *)a6 = *(_OWORD *)v89;
      v89[0] = 0;
      v89[1] = 0;
    }
    uint64_t PersonalizedHRTF = (uint64_t)theString[0];
    if (theString[0]) {
      CFRelease(theString[0]);
    }
    if (!v70)
    {
LABEL_130:
      int v15 = 1;
      goto LABEL_5;
    }
  }
LABEL_107:
  if (v89[1]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v89[1]);
  }
}

void sub_21B50F8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(__p, a13);
  applesauce::CF::DataRef::~DataRef((const void **)__p);
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::erase(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,0>(a3, *(uint64_t **)(a1 + 8), a2);
    uint64_t v6 = v5;
    unint64_t v7 = *(IR::IRDataAttributes **)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        unint64_t v7 = (IR::IRDataAttributes *)((char *)v7 - 168);
        std::__destroy_at[abi:ne180100]<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>,0>(v7);
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

void IR::IRDataLoader::Implementation::getLoadedIR(const IR::IRDataAttributes **this@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  int v4 = *this;
  CFURLRef v5 = this[1];
  if (*this == v5) {
    goto LABEL_26;
  }
  while (1)
  {
    IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)cf1, v4);
    uint64_t v18 = *((void *)v4 + 19);
    uint64_t v8 = (std::__shared_weak_count *)*((void *)v4 + 20);
    uint64_t v19 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = *a2;
    BOOL v10 = ((unint64_t)cf1[0] | (unint64_t)*a2) == 0;
    if (cf1[0]) {
      BOOL v11 = v9 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11) {
      BOOL v10 = CFEqual(cf1[0], v9) != 0;
    }
    if (v19) {
      std::__shared_weak_count::__release_weak(v19);
    }
    if (cf) {
      CFRelease(cf);
    }
    if (v16) {
      CFRelease(v16);
    }
    if (v15) {
      CFRelease(v15);
    }
    if (cf1[0]) {
      CFRelease(cf1[0]);
    }
    if (v10) {
      break;
    }
    int v4 = (const IR::IRDataAttributes *)((char *)v4 + 168);
    if (v4 == v5)
    {
      int v4 = v5;
      break;
    }
  }
  if (v4 == this[1])
  {
LABEL_26:
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    unsigned __int8 v12 = (std::__shared_weak_count *)*((void *)v4 + 20);
    if (v12)
    {
      uint64_t v13 = std::__shared_weak_count::lock(v12);
      a3[1] = v13;
      if (v13) {
        *a3 = *((void *)v4 + 19);
      }
    }
  }
}

void IR::IRDataLoader::Implementation::getLoadedIR(uint64_t *a1@<X0>, const IR::IRDataAttributes *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v24 = a3;
  IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)v19, a2);
  unint64_t v7 = (uint64_t *)std::find_if[abi:ne180100]<std::__wrap_iter<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *>,IR::IRDataLoader::Implementation::getLoadedIR(IR::IRDataAttributes const&,std::optional<PersonalizedHRIRType const>)::$_0>(*a1, a1[1], (float *)v19, (int *)&v24);
  uint64_t v8 = a1[1];
  if ((uint64_t *)v8 != v7) {
    goto LABEL_2;
  }
  if (!*((unsigned char *)a2 + 120))
  {
    char v22 = 1;
    unint64_t v7 = (uint64_t *)std::find_if[abi:ne180100]<std::__wrap_iter<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *>,IR::IRDataLoader::Implementation::getLoadedIR(IR::IRDataAttributes const&,std::optional<PersonalizedHRIRType const>)::$_0>(*a1, v8, (float *)v19, (int *)&v24);
LABEL_2:
    unint64_t v9 = 0;
    goto LABEL_3;
  }
  char v22 = 0;
  uint64_t v16 = std::find_if[abi:ne180100]<std::__wrap_iter<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *>,IR::IRDataLoader::Implementation::getLoadedIR(IR::IRDataAttributes const&,std::optional<PersonalizedHRIRType const>)::$_0>(*a1, v8, (float *)v19, (int *)&v24);
  unint64_t v7 = (uint64_t *)v16;
  if (a1[1] == v16) {
    goto LABEL_2;
  }
  int v17 = *(std::__shared_weak_count **)(v16 + 160);
  if (!v17) {
    goto LABEL_2;
  }
  uint64_t v18 = std::__shared_weak_count::lock(v17);
  if (!v18) {
    goto LABEL_2;
  }
  if (v7[19]) {
    operator new();
  }
  unint64_t v9 = v18;
LABEL_3:
  if (v7 == (uint64_t *)a1[1])
  {
    uint64_t v12 = 0;
    BOOL v11 = v9;
    goto LABEL_22;
  }
  BOOL v10 = (std::__shared_weak_count *)v7[20];
  if (!v10)
  {
    uint64_t v12 = 0;
    BOOL v11 = 0;
    if (!v9) {
      goto LABEL_8;
    }
LABEL_7:
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    goto LABEL_8;
  }
  BOOL v11 = std::__shared_weak_count::lock(v10);
  if (v11)
  {
    uint64_t v12 = v7[19];
    if (!v9) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  uint64_t v12 = 0;
  if (v9) {
    goto LABEL_7;
  }
LABEL_8:
  if (!v12)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,0>(v7 + 21, (uint64_t *)a1[1], v7);
    CFTypeRef v14 = v13;
    for (uint64_t i = (IR::IRDataAttributes *)a1[1];
          i != v14;
          std::__destroy_at[abi:ne180100]<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>,0>(i))
    {
      uint64_t i = (IR::IRDataAttributes *)((char *)i - 168);
    }
    uint64_t v12 = 0;
    a1[1] = (uint64_t)v14;
  }
LABEL_22:
  *a4 = v12;
  a4[1] = (uint64_t)v11;
  if (cf) {
    CFRelease(cf);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v19[0]) {
    CFRelease(v19[0]);
  }
}

void sub_21B510038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, char a20)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
  }
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)&a20);
  std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  _Unwind_Resume(a1);
}

uint64_t std::find_if[abi:ne180100]<std::__wrap_iter<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *>,IR::IRDataLoader::Implementation::getLoadedIR(IR::IRDataAttributes const&,std::optional<PersonalizedHRIRType const>)::$_0>(uint64_t a1, uint64_t a2, float *a3, int *a4)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    while (1)
    {
      if (IR::IRDataAttributes::operator==((uint64_t)a3, v4))
      {
        if (!*((unsigned char *)a4 + 4)) {
          return v4;
        }
        uint64_t v8 = *(std::__shared_weak_count **)(v4 + 160);
        if (!v8) {
          goto LABEL_19;
        }
        unint64_t v9 = std::__shared_weak_count::lock(v8);
        if (!v9) {
          goto LABEL_19;
        }
        BOOL v10 = v9;
        BOOL v11 = *(IR::IRData **)(v4 + 152);
        if (v11)
        {
          if (!*((unsigned char *)a4 + 4)) {
            std::__throw_bad_optional_access[abi:ne180100]();
          }
          int v12 = *a4;
          int v13 = *(_DWORD *)(IR::IRData::getIRDataAttributes(v11) + 48);
          std::__shared_weak_count::__release_shared[abi:ne180100](v10);
          if (v12 == v13) {
            return v4;
          }
          goto LABEL_19;
        }
      }
      else
      {
        if (a3[2] != 0.0) {
          goto LABEL_19;
        }
        if (!IR::IRDataAttributes::equalsExceptSampleRate((IR::IRDataAttributes *)a3, (const IR::IRDataAttributes *)v4))goto LABEL_19; {
        CFTypeRef v14 = *(std::__shared_weak_count **)(v4 + 160);
        }
        if (!v14) {
          goto LABEL_19;
        }
        CFTypeRef v15 = std::__shared_weak_count::lock(v14);
        if (!v15) {
          goto LABEL_19;
        }
        BOOL v10 = v15;
        uint64_t v16 = *(IR::IRData **)(v4 + 152);
        if (v16)
        {
          float OriginalSampleRate = IR::IRData::getOriginalSampleRate(*(IR::IRData **)(v4 + 152));
          if (OriginalSampleRate == IR::IRData::getSampleRate(v16))
          {
            if (!*((unsigned char *)a4 + 4) || (int v18 = *a4, v18 == *(_DWORD *)(IR::IRData::getIRDataAttributes(v16) + 48)))
            {
              std::__shared_weak_count::__release_shared[abi:ne180100](v10);
              return v4;
            }
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
LABEL_19:
      v4 += 168;
      if (v4 == a2) {
        return a2;
      }
    }
  }
  return v4;
}

void sub_21B510240(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::addIRDataToCache(uint64_t a1, uint64_t *a2, IR::IRDataAttributes *a3, IR::IRData **a4)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)&v23, a3);
  unint64_t v7 = *a4;
  if (!*a4) {
    goto LABEL_23;
  }
  float v8 = SampleRate;
  if (SampleRate == 0.0)
  {
    float SampleRate = IR::IRData::getSampleRate(v7);
    IRDataLog = IR::getIRDataLog(v9);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)a2 + 23) < 0) {
        a2 = (uint64_t *)*a2;
      }
      CFTypeRef v21 = (CFURLRef *)applesauce::CF::URLRef::operator->(&v23);
      applesauce::CF::URLRef_proxy::get_filesystem_path(&v21, (applesauce::CF::StringRef *)&theString);
      CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
      *(_DWORD *)buf = 136315650;
      uint64_t v29 = a2;
      __int16 v30 = 2080;
      stat v31 = "addIRDataToCache";
      __int16 v32 = 2080;
      long long v33 = CStringPtr;
      _os_log_debug_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEBUG, "%s%s: Added to cache: %s", buf, 0x20u);
      applesauce::CF::StringRef::~StringRef((const void **)&theString);
    }
  }
  else if (v8 != IR::IRData::getSampleRate(v7))
  {
    CFTypeRef v14 = IR::getIRDataLog(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::Implementation::addIRDataToCache();
    }
    goto LABEL_23;
  }
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 24));
  BOOL v11 = *(uint64_t **)a1;
  int v12 = *(uint64_t **)(a1 + 8);
  if (*(uint64_t **)a1 != v12)
  {
    while ((IR::IRDataAttributes::operator==((uint64_t)v11, (uint64_t)&v23) & 1) == 0)
    {
      v11 += 21;
      if (v11 == v12)
      {
        BOOL v11 = v12;
        goto LABEL_17;
      }
    }
    if (v11 != v12)
    {
      for (uint64_t i = v11 + 21; i != v12; i += 21)
      {
        if ((IR::IRDataAttributes::operator==((uint64_t)i, (uint64_t)&v23) & 1) == 0)
        {
          std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>::operator=[abi:ne180100](v11, i);
          v11 += 21;
        }
      }
    }
  }
LABEL_17:
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::erase(a1, v11, *(uint64_t **)(a1 + 8));
  uint64_t v16 = *(IR::IRDataAttributes **)(a1 + 8);
  if ((unint64_t)v16 >= *(void *)(a1 + 16))
  {
    uint64_t v19 = std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__emplace_back_slow_path<IR::IRDataAttributes&,std::shared_ptr<IR::IRData const> const&>((uint64_t *)a1, (const IR::IRDataAttributes *)&v23, a4);
  }
  else
  {
    int v17 = IR::IRDataAttributes::IRDataAttributes(v16, (const IR::IRDataAttributes *)&v23);
    *((void *)v17 + 19) = *a4;
    int v18 = a4[1];
    *((void *)v17 + 2std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100]((uint64_t *)this, 0) = v18;
    if (v18) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v18 + 2, 1uLL, memory_order_relaxed);
    }
    uint64_t v19 = (uint64_t)v17 + 168;
  }
  *(void *)(a1 + 8) = v19;
  std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 24));
LABEL_23:
  if (cf) {
    CFRelease(cf);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v23) {
    CFRelease(v23);
  }
}

void sub_21B5104EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15)
{
}

void IR::IRDataLoader::Implementation::rebuildPersonalizedHRTFCache(IR::IRDataLoader::Implementation *this)
{
  char v1 = 0;
  uint64_t v12 = *MEMORY[0x263EF8340];
  atomic_compare_exchange_strong((atomic_uchar *volatile)this + 152, (unsigned __int8 *)&v1, 1u);
  if (v1)
  {
    IRDataLog = IR::getIRDataLog(this);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      BOOL v10 = "rebuildPersonalizedHRTFCache";
      _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "%s: Personalized HRTF cache rebuilding is already in progress.", (uint8_t *)&v9, 0xCu);
    }
  }
  else
  {
    int v3 = (std::recursive_mutex *)((char *)this + 24);
    std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
    uint64_t v4 = *(void *)this;
    CFURLRef v5 = (uint64_t *)*((void *)this + 1);
    if (*(uint64_t **)this == v5)
    {
      CFURLRef v5 = *(uint64_t **)this;
    }
    else
    {
      while (!*(_DWORD *)(v4 + 48))
      {
        v4 += 168;
        if ((uint64_t *)v4 == v5)
        {
          uint64_t v4 = *((void *)this + 1);
          goto LABEL_15;
        }
      }
      if ((uint64_t *)v4 != v5)
      {
        uint64_t v7 = v4 + 168;
        if ((uint64_t *)(v4 + 168) != v5)
        {
          do
          {
            if (!*(_DWORD *)(v7 + 48))
            {
              std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>::operator=[abi:ne180100]((uint64_t *)v4, (uint64_t *)v7);
              v4 += 168;
            }
            v7 += 168;
          }
          while ((uint64_t *)v7 != v5);
          CFURLRef v5 = (uint64_t *)*((void *)this + 1);
        }
      }
    }
LABEL_15:
    std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::erase((uint64_t)this, (uint64_t *)v4, v5);
    std::recursive_mutex::unlock(v3);
    float v8 = operator new(0x28uLL);
    *float v8 = &unk_26CB57B18;
    v8[1] = IR::IRDataLoader::Implementation::executePersonalizedHRTFCallbacks;
    _OWORD v8[2] = 0;
    void v8[3] = this;
    *((_DWORD *)v8 + 8) = 0;
    BOOL v11 = v8;
    IR::PersonalizedIRData::RebuildCFDataCache((IR::DataCache ***)this + 20, (uint64_t)&v9);
    std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](&v9);
  }
}

void sub_21B51071C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void IR::IRDataLoader::Implementation::executePersonalizedHRTFCallbacks(uint64_t a1, unsigned int *a2, int a3)
{
  int v3 = a3;
  int v4 = (int)a2;
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (!a3) {
    int v3 = IR::PersonalizedIRData::CheckIfPersonalizedHRIRIsAllowed((IR::PersonalizedIRData::Implementation **)(a1 + 160), a2) ^ 1;
  }
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 88));
  if (!v4) {
    atomic_store(0, (unsigned __int8 *)(a1 + 152));
  }
  uint64_t v7 = *(uint64_t **)(a1 + 184);
  if (v7)
  {
    if (v4) {
      float v8 = "Unchanged";
    }
    else {
      float v8 = "Modified";
    }
    if (v3) {
      int v9 = "Invalid";
    }
    else {
      int v9 = "Valid";
    }
    do
    {
      if ((v4 != 1 || *((_DWORD *)v7 + 10) != 1) && v7[9])
      {
        IRDataLog = IR::getIRDataLog(v6);
        if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v11 = v7 + 2;
          if (*((char *)v7 + 39) < 0) {
            BOOL v11 = (void *)*v11;
          }
          *(_DWORD *)buf = 136315906;
          int v13 = "executePersonalizedHRTFCallbacks";
          __int16 v14 = 2080;
          CFTypeRef v15 = v8;
          __int16 v16 = 2080;
          int v17 = v9;
          __int16 v18 = 2080;
          uint64_t v19 = v11;
          _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "%s: Executing client callback with (DataStatus, DataValidity) = (%s, %s) for clientID = %s.", buf, 0x2Au);
        }
        uint64_t v6 = (IR *)std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator()((uint64_t)(v7 + 6), v4, v3);
      }
      uint64_t v7 = (uint64_t *)*v7;
    }
    while (v7);
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 88));
}

void sub_21B5108E4(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::checkIfPersonalizedHRTFIsAllowed(IR::PersonalizedIRData::Implementation **this)
{
  uint64_t v2 = (std::recursive_mutex *)(this + 3);
  std::recursive_mutex::lock((std::recursive_mutex *)(this + 3));
  uint64_t v4 = IR::PersonalizedIRData::CheckIfPersonalizedHRIRIsAllowed(this + 20, v3);
  std::recursive_mutex::unlock(v2);
  return v4;
}

void sub_21B510940(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

BOOL IR::IRDataLoader::Implementation::hasFailedToFetchPersonalizedHRTF(IR::IRDataLoader::Implementation *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  unint64_t Status = IR::PersonalizedIRData::GetStatus((IR::IRDataLoader::Implementation *)((char *)this + 160));
  unint64_t v4 = Status & 0xFFFFFFFF00000001;
  if ((Status & 0xFFFFFFFF00000001) == 0x100000001)
  {
    IRDataLog = IR::getIRDataLog((IR *)Status);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      float v8 = "hasFailedToFetchPersonalizedHRTF";
      _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "%s: Personalized HRTF is invalid/not enrolled.", (uint8_t *)&v7, 0xCu);
    }
  }
  std::recursive_mutex::unlock(v2);
  return v4 == 0x100000001;
}

void sub_21B510A38(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator()(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(uint64_t a1, char *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  BOOL v10 = (std::recursive_mutex *)(a1 + 88);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 88));
  if (std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::find<std::string>((void *)(a1 + 168), (unsigned __int8 *)a2)&& (*(void *)buf = a2, BOOL v11 = std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 168, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, (long long **)buf), *((_DWORD *)v11 + 10) == a4))
  {
    IRDataLog = IR::getIRDataLog((IR *)v11);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
    {
      if (a2[23] < 0) {
        a2 = *(char **)a2;
      }
      int v13 = "OnDataOrAccessiblityChange";
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "addToPersonalizedHRTFCallbackPool";
      __int16 v23 = 2080;
      uint64_t v24 = a2;
      if (a4 == 1) {
        int v13 = "OnDataChangeOnly";
      }
      __int16 v25 = 2080;
      CFTypeRef v26 = v13;
      _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "%s: ID %s already exists in personalized HRTF callback pool (%s).", buf, 0x20u);
    }
  }
  else
  {
    *(_DWORD *)buf = a4;
    std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::__value_func[abi:ne180100]((uint64_t)&buf[8], a3);
    CFTypeRef v21 = a2;
    __int16 v14 = std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 168, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, (long long **)&v21);
    std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>::operator=[abi:ne180100]((uint64_t)(v14 + 40), buf);
    CFTypeRef v15 = (IR *)std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](&buf[8]);
    __int16 v16 = IR::getIRDataLog(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = "OnDataOrAccessiblityChange";
      if (a4 == 1) {
        int v17 = "OnDataChangeOnly";
      }
      if (a2[23] < 0) {
        a2 = *(char **)a2;
      }
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "addToPersonalizedHRTFCallbackPool";
      __int16 v23 = 2080;
      uint64_t v24 = v17;
      __int16 v25 = 2080;
      CFTypeRef v26 = a2;
      _os_log_impl(&dword_21B4DD000, v16, OS_LOG_TYPE_DEFAULT, "%s: Callback is added in the personalized HRTF callback pool (%s) with caller ID %s.", buf, 0x20u);
    }
    if (a5)
    {
      unsigned __int8 v18 = atomic_load(IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::sCalledOnce);
      if (v18)
      {
        if (*(void *)(a3 + 24))
        {
          uint64_t Status = IR::PersonalizedIRData::GetStatus((IR::PersonalizedIRData *)(a1 + 160));
          std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator()(a3, 0, SHIDWORD(Status));
        }
      }
    }
    *(void *)buf = a1;
    buf[8] = a5;
    if (atomic_load_explicit((atomic_ullong *volatile)&IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::sOnceflag, memory_order_acquire) != -1)
    {
      CFTypeRef v21 = buf;
      uint64_t v20 = (long long **)&v21;
      std::__call_once(&IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::sOnceflag, &v20, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0 &&>>);
    }
  }
  std::recursive_mutex::unlock(v10);
}

void sub_21B510D5C(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>::operator=[abi:ne180100](uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)a1 = *a2;
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator=[abi:ne180100]((void *)(a1 + 8), (uint64_t)(a2 + 2));
  return a1;
}

void IR::IRDataLoader::Implementation::removeFromPersonalizedHRTFCallbackPool(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  unint64_t v4 = (std::recursive_mutex *)(a1 + 88);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 88));
  int v5 = (void *)(a1 + 168);
  if (std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::find<std::string>(v5, a2))
  {
    int v6 = std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__erase_unique<std::string>(v5, a2);
    IRDataLog = IR::getIRDataLog((IR *)v6);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEFAULT))
    {
      if ((char)a2[23] < 0) {
        a2 = *(unsigned __int8 **)a2;
      }
      int v8 = 136315394;
      uint64_t v9 = "removeFromPersonalizedHRTFCallbackPool";
      __int16 v10 = 2080;
      BOOL v11 = a2;
      _os_log_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_DEFAULT, "%s: Callback for caller ID %s is removed from Personalized HRTF callback pool.", (uint8_t *)&v8, 0x16u);
    }
  }
  std::recursive_mutex::unlock(v4);
}

void sub_21B510EC4(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getPersonalizedHRTFCacheStatus(IR::IRDataLoader::Implementation *this)
{
  uint64_t v2 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  uint64_t Status = IR::PersonalizedIRData::GetStatus((IR::IRDataLoader::Implementation *)((char *)this + 160));
  std::recursive_mutex::unlock(v2);
  return Status;
}

void sub_21B510F30(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::clearPersonalizedIRDataCache(IR::IRDataLoader::Implementation *this)
{
  uint64_t v2 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  uint64_t v3 = *(void *)this;
  unint64_t v4 = (uint64_t *)*((void *)this + 1);
  if (*(uint64_t **)this == v4)
  {
    unint64_t v4 = *(uint64_t **)this;
  }
  else
  {
    while (!*(_DWORD *)(v3 + 48))
    {
      v3 += 168;
      if ((uint64_t *)v3 == v4)
      {
        uint64_t v3 = *((void *)this + 1);
        goto LABEL_12;
      }
    }
    if ((uint64_t *)v3 != v4)
    {
      uint64_t v5 = v3 + 168;
      if ((uint64_t *)(v3 + 168) != v4)
      {
        do
        {
          if (!*(_DWORD *)(v5 + 48))
          {
            std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>::operator=[abi:ne180100]((uint64_t *)v3, (uint64_t *)v5);
            v3 += 168;
          }
          v5 += 168;
        }
        while ((uint64_t *)v5 != v4);
        unint64_t v4 = (uint64_t *)*((void *)this + 1);
      }
    }
  }
LABEL_12:
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::erase((uint64_t)this, (uint64_t *)v3, v4);
  IR::PersonalizedIRData::ClearCache((IR::DataCache ***)this + 20);

  std::recursive_mutex::unlock(v2);
}

void sub_21B511018(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void *IR::IRDataLoader::Implementation::getCustomLayoutFromTag@<X0>(IR::IRDataLoader::Implementation *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *((void *)this + 27);
  CFTypeRef result = (void *)((char *)this + 216);
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  int v7 = result;
  do
  {
    unsigned int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      __int16 v10 = (uint64_t *)v5;
    }
    else {
      __int16 v10 = (uint64_t *)(v5 + 8);
    }
    if (v9) {
      int v7 = (void *)v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 != result && *((_DWORD *)v7 + 8) <= a2)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    CFTypeRef result = std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>((void *)a3, (const void *)v7[5], v7[6], v7[6] - v7[5]);
    char v11 = 1;
  }
  else
  {
LABEL_12:
    char v11 = 0;
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 24) = v11;
  return result;
}

uint64_t IR::IRDataLoader::Implementation::registerCustomLayoutIfNecessary(IR::IRDataLoader::Implementation *this, const AudioChannelLayout *a2)
{
  uint64_t mChannelLayoutTag = a2->mChannelLayoutTag;
  if ((mChannelLayoutTag & 0xFFFEFFFF) != 0) {
    return mChannelLayoutTag;
  }
  uint64_t v5 = (uint64_t **)((char *)this + 208);
  if (!*((void *)this + 28))
  {
    unsigned int v39 = -268435456;
    UInt32 mNumberChannelDescriptions = a2->mNumberChannelDescriptions;
    if (mNumberChannelDescriptions <= 1) {
      UInt32 mNumberChannelDescriptions = 1;
    }
    std::vector<char>::vector((std::vector<char> *)v38, 20 * mNumberChannelDescriptions + 12);
    memcpy(*(void **)v38, a2, 20 * a2->mNumberChannelDescriptions + 12);
    __dst.__begin_ = (std::vector<char>::pointer)&v39;
    float v35 = std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v5, &v39, (uint64_t)&std::piecewise_construct, &__dst);
    std::string::size_type v36 = (void *)v35[5];
    if (v36)
    {
      v35[6] = (uint64_t)v36;
      operator delete(v36);
      v35[5] = 0;
      v35[6] = 0;
      v35[7] = 0;
    }
    *(_OWORD *)(v35 + 5) = *(_OWORD *)v38;
    v35[7] = *(void *)&v38[16];
    return v39;
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 26);
  int v7 = (uint64_t *)((char *)this + 216);
  if (v6 == (uint64_t *)((char *)this + 216))
  {
LABEL_33:
    uint64_t v31 = *v7;
    if (*v7)
    {
      do
      {
        uint64_t v32 = v31;
        uint64_t v31 = *(void *)(v31 + 8);
      }
      while (v31);
    }
    else
    {
      do
      {
        uint64_t v32 = v7[2];
        BOOL v25 = *(void *)v32 == (void)v7;
        int v7 = (uint64_t *)v32;
      }
      while (v25);
    }
    uint64_t mChannelLayoutTag = (*(_DWORD *)(v32 + 32) + 1);
    UInt32 v33 = a2->mNumberChannelDescriptions;
    if (v33 <= 1) {
      UInt32 v33 = 1;
    }
    std::vector<char>::vector(&__dst, 20 * v33 + 12);
    memcpy(__dst.__begin_, a2, 20 * a2->mNumberChannelDescriptions + 12);
    *(_DWORD *)CFStringRef v38 = mChannelLayoutTag;
    *(std::vector<char> *)&v38[8] = __dst;
    memset(&__dst, 0, sizeof(__dst));
    std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,CA::ChannelLayout>>(v5, (unsigned int *)v38, (uint64_t)v38);
    if (*(void *)&v38[8])
    {
      *(void *)&v38[16] = *(void *)&v38[8];
      operator delete(*(void **)&v38[8]);
    }
    if (__dst.__begin_)
    {
      __dst.__end_ = __dst.__begin_;
      operator delete(__dst.__begin_);
    }
    return mChannelLayoutTag;
  }
  while (1)
  {
    UInt32 v8 = a2->mNumberChannelDescriptions;
    if (v8 <= 1) {
      UInt32 v8 = 1;
    }
    std::vector<char>::vector((std::vector<char> *)v38, 20 * v8 + 12);
    memcpy(*(void **)v38, a2, 20 * a2->mNumberChannelDescriptions + 12);
    BOOL v9 = (int *)v6[5];
    int v10 = *v9;
    if (*v9 != **(_DWORD **)v38) {
      goto LABEL_25;
    }
    if (v10 != 0x10000) {
      break;
    }
    int v27 = v9[1];
    int v28 = *(_DWORD *)(*(void *)v38 + 4);
    *(void *)&v38[8] = *(void *)v38;
    operator delete(*(void **)v38);
    if (v27 == v28) {
      return *((unsigned int *)v6 + 8);
    }
LABEL_27:
    uint64_t v29 = (uint64_t *)v6[1];
    if (v29)
    {
      do
      {
        __int16 v30 = v29;
        uint64_t v29 = (uint64_t *)*v29;
      }
      while (v29);
    }
    else
    {
      do
      {
        __int16 v30 = (uint64_t *)v6[2];
        BOOL v25 = *v30 == (void)v6;
        uint64_t v6 = v30;
      }
      while (!v25);
    }
    uint64_t v6 = v30;
    if (v30 == v7) {
      goto LABEL_33;
    }
  }
  if (v10) {
    goto LABEL_48;
  }
  uint64_t v11 = v9[2];
  if (v11 != *(_DWORD *)(*(void *)v38 + 8))
  {
LABEL_25:
    *(void *)&v38[8] = *(void *)v38;
    operator delete(*(void **)v38);
    goto LABEL_27;
  }
  if (v11)
  {
    unint64_t v12 = 0;
    uint64_t v13 = 20 * v11;
    uint64_t v14 = *(void *)v38 + 12;
    CFTypeRef v15 = v9 + 3;
    do
    {
      __int16 v16 = &v15[v12 / 4];
      int v17 = (uint64_t *)(v14 + v12);
      int v18 = v15[v12 / 4];
      if (v18 != *(_DWORD *)(v14 + v12)) {
        goto LABEL_25;
      }
      if (v18 == 100)
      {
        uint64_t v19 = *(void *)v16;
        uint64_t v20 = *((void *)v16 + 1);
        uint64_t v21 = *v17;
        uint64_t v22 = v17[1];
        uint64_t v23 = v16[4];
        uint64_t v24 = *((unsigned int *)v17 + 4);
        BOOL v25 = v19 == v21 && v20 == v22;
        if (!v25 || v23 != v24) {
          goto LABEL_25;
        }
      }
      v12 += 20;
    }
    while (v13 != v12);
  }
LABEL_48:
  *(void *)&v38[8] = *(void *)v38;
  operator delete(*(void **)v38);
  return *((unsigned int *)v6 + 8);
}

void sub_21B5113BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataLoader::Implementation::getFilterLength(IR::IRDataLoader::Implementation *a1, int a2, float a3)
{
  IR::getPresetDataAttributes(a2, (uint64_t)&v7);
  float v8 = a3;
  Filterunsigned int Length = IR::IRDataLoader::Implementation::getFilterLength(a1, (const IR::IRDataAttributes *)&v7);
  if (cf) {
    CFRelease(cf);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v7) {
    CFRelease(v7);
  }
  return FilterLength;
}

void sub_21B511494(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getFilterLength(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2)
{
  unint64_t v4 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  uint64_t FilterLengthPrivate = IR::IRDataLoader::Implementation::getFilterLengthPrivate(this, a2);
  std::recursive_mutex::unlock(v4);
  return FilterLengthPrivate;
}

void sub_21B5114FC(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getFilterLengthPrivate(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2)
{
  IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)this, a2, 0, (uint64_t *)&v8);
  if (v8)
  {
    Filterunsigned int Length = IR::IRData::getFilterLength(v8);
  }
  else
  {
    IR::IRDataLoader::Implementation::cacheMiss((IR::IRDataLoader::Implementation *)"getFilterLengthPrivate", v3);
    Filterunsigned int Length = IR::IRData::getFilterLength(a2, v5);
  }
  uint64_t v6 = FilterLength;
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  return v6;
}

void sub_21B51157C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void IR::IRDataLoader::Implementation::cacheMiss(IR::IRDataLoader::Implementation *this, const char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (_os_feature_enabled_impl())
  {
    atomic_fetch_add(IR::IRDataLoader::Implementation::cacheMiss(char const*)::sCacheMisses, 1u);
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_INFO))
    {
      unsigned int v3 = atomic_load((unsigned int *)IR::IRDataLoader::Implementation::cacheMiss(char const*)::sCacheMisses);
      int v4 = 136315394;
      uint64_t v5 = this;
      __int16 v6 = 1024;
      unsigned int v7 = v3;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_INFO, "IRDataLoader: cache miss in %s, total = %u", (uint8_t *)&v4, 0x12u);
    }
  }
}

uint64_t IR::IRDataLoader::Implementation::getNumSpatialPoints(IR::IRDataLoader::Implementation *a1, int a2, float a3)
{
  IR::getPresetDataAttributes(a2, (uint64_t)&v7);
  float v8 = a3;
  uint64_t NumSpatialPoints = IR::IRDataLoader::Implementation::getNumSpatialPoints(a1, (const IR::IRDataAttributes *)&v7);
  if (cf) {
    CFRelease(cf);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v7) {
    CFRelease(v7);
  }
  return NumSpatialPoints;
}

void sub_21B511704(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getNumSpatialPoints(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2)
{
  int v4 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)this, a2, 0, (uint64_t *)&v10);
  if (v10)
  {
    uint64_t NumSpatialPoints = IR::IRData::getNumSpatialPoints(v10);
  }
  else
  {
    IR::IRDataLoader::Implementation::cacheMiss((IR::IRDataLoader::Implementation *)"getNumSpatialPoints", v5);
    uint64_t NumSpatialPoints = IR::IRData::getNumSpatialPoints(a2, v7);
  }
  uint64_t v8 = NumSpatialPoints;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  std::recursive_mutex::unlock(v4);
  return v8;
}

void sub_21B5117AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::recursive_mutex::unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getNumFiltersPerSpatialPoint(IR::IRDataLoader::Implementation *a1, int a2, float a3)
{
  IR::getPresetDataAttributes(a2, (uint64_t)&v7);
  float v8 = a3;
  uint64_t NumFiltersPerSpatialPoint = IR::IRDataLoader::Implementation::getNumFiltersPerSpatialPoint(a1, (const IR::IRDataAttributes *)&v7);
  if (cf) {
    CFRelease(cf);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v7) {
    CFRelease(v7);
  }
  return NumFiltersPerSpatialPoint;
}

void sub_21B51186C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getNumFiltersPerSpatialPoint(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2)
{
  int v4 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)this, a2, 0, (uint64_t *)&v10);
  if (v10)
  {
    uint64_t NumFiltersPerSpatialPoint = IR::IRData::getNumFiltersPerSpatialPoint(v10);
  }
  else
  {
    IR::IRDataLoader::Implementation::cacheMiss((IR::IRDataLoader::Implementation *)"getNumFiltersPerSpatialPoint", v5);
    uint64_t NumFiltersPerSpatialPoint = IR::IRData::getNumFiltersPerSpatialPoint(a2, v7);
  }
  uint64_t v8 = NumFiltersPerSpatialPoint;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  std::recursive_mutex::unlock(v4);
  return v8;
}

void sub_21B511914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::recursive_mutex::unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getModelingDelay(IR::IRDataLoader::Implementation *a1, int a2, float a3)
{
  IR::getPresetDataAttributes(a2, (uint64_t)&v7);
  float v8 = a3;
  uint64_t ModelingDelay = IR::IRDataLoader::Implementation::getModelingDelay(a1, (const IR::IRDataAttributes *)&v7);
  if (cf) {
    CFRelease(cf);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v7) {
    CFRelease(v7);
  }
  return ModelingDelay;
}

void sub_21B5119D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getModelingDelay(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2)
{
  int v4 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)this, a2, 0, (uint64_t *)&v10);
  if (v10)
  {
    uint64_t ModelingDelay = IR::IRData::getModelingDelay(v10);
  }
  else
  {
    IR::IRDataLoader::Implementation::cacheMiss((IR::IRDataLoader::Implementation *)"getModelingDelay", v5);
    uint64_t ModelingDelay = IR::IRData::getModelingDelay(a2, v7);
  }
  uint64_t v8 = ModelingDelay;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  std::recursive_mutex::unlock(v4);
  return v8;
}

void sub_21B511A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::recursive_mutex::unlock(v10);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::getUserData(const IR::IRDataAttributes **a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  IR::getPresetDataAttributes(a2, (uint64_t)v5);
  IR::IRDataLoader::Implementation::getUserData(a1, (const IR::IRDataAttributes *)v5, a3);
  if (cf) {
    CFRelease(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v5[0]) {
    CFRelease(v5[0]);
  }
}

void sub_21B511B2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::getUserData(const IR::IRDataAttributes **this@<X0>, const IR::IRDataAttributes *a2@<X1>, void *a3@<X8>)
{
  CFTypeRef v6 = (std::recursive_mutex *)(this + 3);
  std::recursive_mutex::lock((std::recursive_mutex *)(this + 3));
  IR::IRDataLoader::Implementation::getLoadedIR(this, (const void **)a2, &v16);
  if (!v16)
  {
LABEL_15:
    IR::IRDataLoader::Implementation::cacheMiss((IR::IRDataLoader::Implementation *)"getUserData", v7);
    IR::IRData::getUserData(a2, v9);
    goto LABEL_16;
  }
  IR::IRData::getFilePlistDict((CFTypeRef *)v16, &cf);
  int v14 = 0;
  CFTypeRef v8 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef v12 = v8;
  IR::IRData::extractIRDataTypePlist(&v12, *((_DWORD *)a2 + 10), &v14, (applesauce::CF::DictionaryRef *)&v13);
  if (v12) {
    CFRelease(v12);
  }
  if (!v13)
  {
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_15;
  }
  CFTypeRef v10 = 0;
  uint64_t v11 = @"UserData";
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>((const __CFDictionary *)v13, (const void **)&v11, &v10, a3);
  if (v10) {
    CFRelease(v10);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_16:
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  std::recursive_mutex::unlock(v6);
}

void sub_21B511C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, const void *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  applesauce::CF::DictionaryRef::~DictionaryRef(&a11);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a14);
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  std::recursive_mutex::unlock(v16);
  _Unwind_Resume(a1);
}

applesauce::CF::DictionaryRef *applesauce::CF::DictionaryRef::DictionaryRef(applesauce::CF::DictionaryRef *this, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *(void *)this = v3;
  return this;
}

void IR::IRDataLoader::Implementation::getGlobalUserData(IR::IRDataLoader::Implementation *a1, int a2)
{
  IR::getPresetDataAttributes(a2, (uint64_t)v3);
  IR::IRDataLoader::Implementation::getGlobalUserData(a1, (const IR::IRDataAttributes *)v3);
  if (cf) {
    CFRelease(cf);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v3[0]) {
    CFRelease(v3[0]);
  }
}

void sub_21B511D78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::getGlobalUserData(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2)
{
  CFTypeRef v3 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  IR::IRData::getGlobalUserData(a2, v4);

  std::recursive_mutex::unlock(v3);
}

void sub_21B511DE4(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::getIRDataTypes(IR::IRDataLoader::Implementation *a1, int a2)
{
  IR::getPresetDataAttributes(a2, (uint64_t)v3);
  IR::IRDataLoader::Implementation::getIRDataTypes(a1, (const IR::IRDataAttributes *)v3);
  if (cf) {
    CFRelease(cf);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v3[0]) {
    CFRelease(v3[0]);
  }
}

void sub_21B511E80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::Implementation::getIRDataTypes(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2)
{
  CFTypeRef v3 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  IR::IRData::getIRDataTypes(a2, v4);

  std::recursive_mutex::unlock(v3);
}

void sub_21B511EEC(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getAudioChannelLayoutTag(IR::IRDataLoader::Implementation *a1, int a2)
{
  IR::getPresetDataAttributes(a2, (uint64_t)v5);
  uint64_t AudioChannelLayoutTag = IR::IRDataLoader::Implementation::getAudioChannelLayoutTag(a1, (const IR::IRDataAttributes *)v5, 0);
  if (cf) {
    CFRelease(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v5[0]) {
    CFRelease(v5[0]);
  }
  return AudioChannelLayoutTag;
}

void sub_21B511F8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getAudioChannelLayoutTag(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2, int a3)
{
  CFTypeRef v6 = (std::recursive_mutex *)((char *)this + 24);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 24));
  uint64_t AudioChannelLayoutTagPrivate = IR::IRDataLoader::Implementation::getAudioChannelLayoutTagPrivate(this, a2, a3);
  std::recursive_mutex::unlock(v6);
  return AudioChannelLayoutTagPrivate;
}

void sub_21B511FFC(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::getAudioChannelLayoutTagPrivate(IR::IRDataLoader::Implementation *this, const IR::IRDataAttributes *a2, int a3)
{
  IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)this, a2, 0, (uint64_t *)&v10);
  if (v10)
  {
    if (a3) {
      Originaluint64_t AudioChannelLayoutTag = IR::IRData::getOriginalAudioChannelLayoutTag(v10);
    }
    else {
      Originaluint64_t AudioChannelLayoutTag = IR::IRData::getAudioChannelLayoutTag(v10);
    }
  }
  else
  {
    IR::IRDataLoader::Implementation::cacheMiss((IR::IRDataLoader::Implementation *)"getAudioChannelLayoutTagPrivate", v5);
    Originaluint64_t AudioChannelLayoutTag = IR::IRData::getAudioChannelLayoutTag(a2, v7);
  }
  uint64_t v8 = OriginalAudioChannelLayoutTag;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  return v8;
}

void sub_21B51208C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataLoader::Implementation::getAudioChannelLayoutTag(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef v2 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  CFTypeRef v6 = v2;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)v7, &v6, 0, 0, 2, 0.0);
  uint64_t AudioChannelLayoutTag = IR::IRData::getAudioChannelLayoutTag((IR::IRData *)v7, v3);
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v7[0]) {
    CFRelease(v7[0]);
  }
  if (v6) {
    CFRelease(v6);
  }
  return AudioChannelLayoutTag;
}

void sub_21B51215C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, char a10)
{
}

uint64_t IR::IRDataLoader::Implementation::isConsolidatedIR(uint64_t a1, int a2)
{
  IR::getPresetDataAttributes(a2, (uint64_t)v5);
  uint64_t isConsolidatedIR = IR::IRData::isConsolidatedIR((IR::IRData *)v5, v2);
  if (cf) {
    CFRelease(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v5[0]) {
    CFRelease(v5[0]);
  }
  return isConsolidatedIR;
}

void sub_21B512200(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::Implementation::hasType(uint64_t a1, int a2, uint64_t a3)
{
  IR::getPresetDataAttributes(a2, (uint64_t)v6);
  uint64_t hasType = IR::IRData::hasType(v6, a3);
  if (cf) {
    CFRelease(cf);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6[0]) {
    CFRelease(v6[0]);
  }
  return hasType;
}

void sub_21B51229C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

BOOL IR::IRDataLoader::Implementation::fileExists(uint64_t a1, int a2)
{
  IR::getPresetDataAttributes(a2, (uint64_t)v5);
  BOOL v3 = IR::IRDataLoader::Implementation::fileExists(v2, v5);
  if (cf) {
    CFRelease(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v5[0]) {
    CFRelease(v5[0]);
  }
  return v3;
}

void sub_21B512330(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

BOOL IR::IRDataLoader::Implementation::fileExists(IR::IRDataLoader::Implementation *this, CFTypeRef *a2)
{
  IR::getFilePtr(a2, 0, v4);
  CFTypeRef v2 = v4[0];
  if (v4[0]) {
    ((void (*)(FILE *))v4[1])(v4[0]);
  }
  return v2 != 0;
}

BOOL IR::IRDataLoader::Implementation::fileExists(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef v2 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  CFTypeRef v6 = v2;
  BOOL v3 = (IR::IRDataLoader::Implementation *)IR::IRDataAttributes::IRDataAttributes((uint64_t)v7, &v6, 0, 0, 2, 0.0);
  BOOL v4 = IR::IRDataLoader::Implementation::fileExists(v3, v7);
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v7[0]) {
    CFRelease(v7[0]);
  }
  if (v6) {
    CFRelease(v6);
  }
  return v4;
}

void sub_21B512450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, char a10)
{
}

uint64_t std::pair<BOOL,applesauce::CF::DataRef>::~pair(uint64_t a1)
{
  CFTypeRef v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void IR::IRDataLoader::Implementation::loadAndDecode(IR::IRDataAttributes *a1@<X2>, IR::IRDataLoader::Implementation *a2@<X0>, char *a3@<X1>, void *a4@<X8>)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)&v73, a1);
  CFTypeRef v8 = cf;
  CFTypeRef cf = 0;
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v77 = 0;
  uint64_t v76 = 0;
  CFTypeRef v9 = v78;
  CFTypeRef v78 = 0;
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v79 = 0;
  int v80 = 0;
  std::string::basic_string[abi:ne180100]<0>(v82, "");
  uint64_t v70 = 0;
  memset(__p, 0, 24);
  IR::IRDataLoader::Implementation::load(&v71, a2, v82, &v73, &v70, __p);
  if (__p[0].__r_.__value_.__r.__words[0])
  {
    __p[0].__r_.__value_.__l.__size_ = __p[0].__r_.__value_.__r.__words[0];
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v82[2]) < 0) {
    operator delete((void *)v82[0]);
  }
  uint64_t AudioChannelLayoutTagPrivate = (HOA *)IR::IRDataLoader::Implementation::getAudioChannelLayoutTagPrivate(a2, (const IR::IRDataAttributes *)&v73, 0);
  BOOL IsSupportedHOA = ChannelLayoutTagIsSupportedHOA((int)AudioChannelLayoutTagPrivate);
  if (!IsSupportedHOA)
  {
    IRDataLog = IR::getIRDataLog((IR *)IsSupportedHOA);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_ERROR))
    {
      if (a3[23] >= 0) {
        uint64_t v31 = a3;
      }
      else {
        uint64_t v31 = *(char **)a3;
      }
      if (!*(void *)a1)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](exception, "Could not construct");
      }
      CFStringRef v32 = CFURLCopyFileSystemPath(*(CFURLRef *)a1, kCFURLPOSIXPathStyle);
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)__p, v32);
      CStringPtr = CFStringGetCStringPtr((CFStringRef)__p[0].__r_.__value_.__l.__data_, 0x8000100u);
      LODWORD(v82[0]) = 136315650;
      *(CFTypeRef *)((char *)v82 + 4) = v31;
      WORD2(v82[1]) = 2080;
      *(CFTypeRef *)((char *)&v82[1] + 6) = "loadAndDecode";
      HIWORD(v82[2]) = 2080;
      void v82[3] = CStringPtr;
      _os_log_error_impl(&dword_21B4DD000, IRDataLog, OS_LOG_TYPE_ERROR, "%s%s: Not HOA IR: %s, ", (uint8_t *)v82, 0x20u);
      if (__p[0].__r_.__value_.__r.__words[0]) {
        CFRelease(__p[0].__r_.__value_.__l.__data_);
      }
    }
    CFTypeRef v69 = 0;
    memset(v82, 0, 24);
    IR::IRDataLoader::Implementation::loadPrivate(a2, a3, &v73, &v69, v82);
    if (v82[0])
    {
      v82[1] = v82[0];
      operator delete((void *)v82[0]);
    }
    if (v69) {
      CFRelease(v69);
    }
    goto LABEL_114;
  }
  AudioChannelLayoutTagAmbisonicOrder = (IR *)GetAudioChannelLayoutTagAmbisonicOrder((int)AudioChannelLayoutTagPrivate);
  uint64_t Normalization = HOA::getNormalization(AudioChannelLayoutTagPrivate);
  v68[1] = 0;
  v68[0] = 0;
  int v14 = (const void *)*((void *)a1 + 11);
  if (v14) {
    CFRetain(*((CFTypeRef *)a1 + 11));
  }
  CFTypeRef v59 = v14;
  IR::IRDataAttributes::IRDataAttributes((uint64_t)v60, &v59, 128, 1, *((_DWORD *)a1 + 5), *((float *)a1 + 2));
  CFTypeRef v15 = (IR *)v59;
  if (v59) {
    CFRelease(v59);
  }
  if (v60[0])
  {
    __int16 v16 = (const void *)*((void *)a1 + 8);
    if (v16)
    {
      CFRetain(*((CFTypeRef *)a1 + 8));
      CFTypeRef v58 = v16;
      IR::IRDataAttributes::IRDataAttributes((uint64_t)v82, &v58, 128, 1, *((_DWORD *)a1 + 5), *((float *)a1 + 2));
      if (v58) {
        CFRelease(v58);
      }
      int v17 = IR::IRDataLoader::Implementation::getAudioChannelLayoutTagPrivate(a2, (const IR::IRDataAttributes *)v82, 1);
      if (ChannelLayoutTagIsSupportedHOA(v17))
      {
        long long v61 = *(_OWORD *)((char *)a1 + 72);
        CFTypeRef v18 = v60[0];
        uint64_t v19 = (const void *)*((void *)a1 + 8);
        v60[0] = v19;
        if (v19) {
          CFRetain(v19);
        }
        if (v18) {
          CFRelease(v18);
        }
        CFTypeRef v20 = v66;
        uint64_t v21 = (const void *)*((void *)a1 + 11);
        CFTypeRef v66 = v21;
        if (v21) {
          CFRetain(v21);
        }
        if (v20) {
          CFRelease(v20);
        }
      }
      if (v85) {
        CFRelease(v85);
      }
      if (v84) {
        CFRelease(v84);
      }
      if (v83) {
        CFRelease(v83);
      }
      if (v82[0]) {
        CFRelease(v82[0]);
      }
    }
    else
    {
      int v62 = *((_DWORD *)a1 + 24);
    }
    int v63 = *((_DWORD *)a1 + 26);
    char v64 = *((unsigned char *)a1 + 112);
    CFTypeRef v57 = 0;
    memset(v82, 0, 24);
    IR::IRDataLoader::Implementation::loadPrivate(a2, a3, v60, &v57, v82);
    long long v26 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
    *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = 0uLL;
    int v27 = (std::__shared_weak_count *)v68[1];
    *(_OWORD *)long long v68 = v26;
    if (v27)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v27);
      if (__p[0].__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_);
      }
    }
    if (v82[0])
    {
      v82[1] = v82[0];
      operator delete((void *)v82[0]);
    }
    if (v57) {
      CFRelease(v57);
    }
    int v28 = v68[0];
    if (!v68[0])
    {
      uint64_t v29 = IR::getIRDataLog(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        IR::IRDataLoader::Implementation::loadAndDecode();
      }
LABEL_60:
      *a4 = 0;
      a4[1] = 0;
      goto LABEL_104;
    }
LABEL_102:
    int NumFiltersPerSpatialPoint = IR::IRData::getNumFiltersPerSpatialPoint(v28);
    IR::HOA2BinauralIRRenderer::HOA2BinauralIRRenderer((IR::HOA2BinauralIRRenderer *)__p, (const IR::IRDataAttributes *)v60, (const IR::IRDataAttributes *)&v73, NumFiltersPerSpatialPoint);
    float SampleRate = IR::IRData::getSampleRate(v68[0]);
    uint64_t FilterLengthPrivate = IR::IRDataLoader::Implementation::getFilterLengthPrivate(a2, (const IR::IRDataAttributes *)&v73);
    IR::HOA2BinauralIRRenderer::initialize((uint64_t)__p, (uint64_t)AudioChannelLayoutTagAmbisonicOrder, SampleRate, 1, Normalization, FilterLengthPrivate, *((_DWORD *)a1 + 11));
  }
  uint64_t v23 = (IR::IRData::Implementation *)*((unsigned int *)a1 + 25);
  if (!v23)
  {
    __int16 v30 = IR::getIRDataLog(v15);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::Implementation::loadAndDecode();
    }
    goto LABEL_60;
  }
  uint64_t v24 = (uint64_t *)*((void *)a2 + 27);
  if (!v24)
  {
LABEL_46:
    GetStringFromAudioChannelLayoutTag(*((_DWORD *)a1 + 25), __p);
    goto LABEL_69;
  }
  while (1)
  {
    unsigned int v25 = *((_DWORD *)v24 + 8);
    if (v23 >= v25) {
      break;
    }
LABEL_45:
    uint64_t v24 = (uint64_t *)*v24;
    if (!v24) {
      goto LABEL_46;
    }
  }
  if (v25 < v23)
  {
    ++v24;
    goto LABEL_45;
  }
  std::to_string(__p, *((_DWORD *)a1 + 25));
LABEL_69:
  uint64_t v34 = std::string::insert(__p, 0, "/", 1uLL);
  long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  v82[2] = (CFTypeRef)v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)float v82 = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v82[2]) >= 0) {
    std::string::size_type v36 = v82;
  }
  else {
    std::string::size_type v36 = (CFTypeRef *)v82[0];
  }
  if (SHIBYTE(v82[2]) >= 0) {
    CFIndex v37 = HIBYTE(v82[2]);
  }
  else {
    CFIndex v37 = (CFIndex)v82[1];
  }
  CFURLRef v38 = CFURLCreateWithBytes(0, (const UInt8 *)v36, v37, 0, 0);
  if (!v38)
  {
    float v55 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](v55, "Could not construct");
  }
  CFTypeRef v39 = v60[0];
  v60[0] = v38;
  if (v39) {
    CFRelease(v39);
  }
  IR::IRDataLoader::Implementation::getLoadedIR((uint64_t *)a2, (const IR::IRDataAttributes *)v60, 0, (uint64_t *)__p);
  int v41 = (std::__shared_weak_count *)v68[1];
  *(_OWORD *)long long v68 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
  if (v41)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v41);
    if (v68[0]) {
      goto LABEL_98;
    }
LABEL_84:
    IR::IRData::Implementation::generatePanningIRData(v23, v74, (IR::IRData::Implementation *)1, AudioChannelLayoutTagAmbisonicOrder, Normalization, v40, __p);
    long long v42 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
    *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = 0uLL;
    std::string::size_type size = (std::__shared_weak_count *)v68[1];
    *(_OWORD *)long long v68 = v42;
    if (size)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](size);
      std::string::size_type size = (std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_;
      if (__p[0].__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_);
      }
      if (v68[0])
      {
LABEL_88:
        uint64_t v44 = (IR::IRDataAttributes *)*((void *)a2 + 1);
        if ((unint64_t)v44 >= *((void *)a2 + 2))
        {
          uint64_t v47 = std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__emplace_back_slow_path<IR::IRDataAttributes&,std::shared_ptr<IR::IRData const> &>((uint64_t *)a2, (const IR::IRDataAttributes *)v60, v68);
        }
        else
        {
          long long v45 = IR::IRDataAttributes::IRDataAttributes(v44, (const IR::IRDataAttributes *)v60);
          int v46 = v68[1];
          *((IR **)v45 + 19) = v68[0];
          *((void *)v45 + 2std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100]((uint64_t *)this, 0) = v46;
          if (v46) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)v46 + 2, 1uLL, memory_order_relaxed);
          }
          uint64_t v47 = (uint64_t)v45 + 168;
        }
        *((void *)a2 + 1) = v47;
        goto LABEL_98;
      }
    }
    else if ((void)v42)
    {
      goto LABEL_88;
    }
    unsigned int v48 = IR::getIRDataLog((IR *)size);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::Implementation::loadAndDecode();
    }
    std::string::size_type v49 = a4;
    int v50 = 0;
    *std::string::size_type v49 = 0;
    v49[1] = 0;
  }
  else
  {
    if (!__p[0].__r_.__value_.__r.__words[0]) {
      goto LABEL_84;
    }
LABEL_98:
    int v50 = 1;
  }
  if (SHIBYTE(v82[2]) < 0)
  {
    operator delete((void *)v82[0]);
    if (!v50) {
      goto LABEL_104;
    }
LABEL_101:
    int v28 = v68[0];
    goto LABEL_102;
  }
  if (v50) {
    goto LABEL_101;
  }
LABEL_104:
  if (v67) {
    CFRelease(v67);
  }
  if (v66) {
    CFRelease(v66);
  }
  if (v65) {
    CFRelease(v65);
  }
  if (v60[0]) {
    CFRelease(v60[0]);
  }
  if (v68[1]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v68[1]);
  }
LABEL_114:
  if (v72) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v72);
  }
  if (v81) {
    CFRelease(v81);
  }
  if (v78) {
    CFRelease(v78);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v73) {
    CFRelease(v73);
  }
}

void sub_21B5134CC(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x6F7]) < 0) {
    operator delete((void *)STACK[0x6E0]);
  }
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)&STACK[0x578]);
  if (STACK[0x618]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x618]);
  }
  if (STACK[0x638]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x638]);
  }
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)&STACK[0x640]);
  _Unwind_Resume(a1);
}

void IR::IRDataAttributes::description(IR::IRDataAttributes *this@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  v228[4] = *MEMORY[0x263EF8340];
  if (a2)
  {
    LODWORD(v222.__r_.__value_.__l.__data_) = 0;
    std::string::basic_string[abi:ne180100]<0>(&v222.__r_.__value_.__l.__size_, "Bilinear");
    int v223 = 1;
    std::string::basic_string[abi:ne180100]<0>(v224, "VBAP");
    int v225 = 2;
    std::string::basic_string[abi:ne180100]<0>(v226, "Auto");
    std::map<IR::IRSphericalInterpolation,std::string>::map[abi:ne180100]((uint64_t)&v221, (int *)&v222, 3);
    for (uint64_t i = 0; i != -12; i -= 4)
    {
      if (SHIBYTE(v226[i + 2]) < 0) {
        operator delete((void *)v226[i]);
      }
    }
    LODWORD(v222.__r_.__value_.__l.__data_) = 0;
    std::string::basic_string[abi:ne180100]<0>(&v222.__r_.__value_.__l.__size_, "Unknown");
    int v223 = 1;
    std::string::basic_string[abi:ne180100]<0>(v224, "DirectIR");
    int v225 = 2;
    std::string::basic_string[abi:ne180100]<0>(v226, "RoomIR");
    int v227 = 3;
    std::string::basic_string[abi:ne180100]<0>(v228, "EarlyRoomIR");
    std::map<IR::IRDataType,std::string>::map[abi:ne180100]((uint64_t)&v220, (int *)&v222, 4);
    for (uint64_t j = 0; j != -16; j -= 4)
    {
      if (SHIBYTE(v228[j + 2]) < 0) {
        operator delete((void *)v228[j]);
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v181, "URL: ");
    CFStringRef v7 = CFCopyDescription(*(CFTypeRef *)this);
    applesauce::CF::details::CFString_get_value<true>(v7, (uint64_t)v179);
    if (v7) {
      CFRelease(v7);
    }
    if ((v180 & 0x80u) == 0) {
      CFTypeRef v8 = v179;
    }
    else {
      CFTypeRef v8 = (void **)v179[0];
    }
    if ((v180 & 0x80u) == 0) {
      std::string::size_type v9 = v180;
    }
    else {
      std::string::size_type v9 = (std::string::size_type)v179[1];
    }
    CFTypeRef v10 = std::string::append(&v181, (const std::string::value_type *)v8, v9);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v182.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v182.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    CFTypeRef v12 = std::string::append(&v182, ", Sample rate: ", 0xFuLL);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v183.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v183.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v178, *((float *)this + 2));
    if ((v178.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v14 = &v178;
    }
    else {
      int v14 = (std::string *)v178.__r_.__value_.__r.__words[0];
    }
    if ((v178.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v178.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v178.__r_.__value_.__l.__size_;
    }
    __int16 v16 = std::string::append(&v183, (const std::string::value_type *)v14, size);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v184.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v184.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    CFTypeRef v18 = std::string::append(&v184, ", fftBlockSize: ", 0x10uLL);
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v185.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v185.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v177, *((_DWORD *)this + 3));
    if ((v177.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeRef v20 = &v177;
    }
    else {
      CFTypeRef v20 = (std::string *)v177.__r_.__value_.__r.__words[0];
    }
    if ((v177.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v21 = HIBYTE(v177.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v21 = v177.__r_.__value_.__l.__size_;
    }
    uint64_t v22 = std::string::append(&v185, (const std::string::value_type *)v20, v21);
    long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v186.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v186.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    uint64_t v24 = std::string::append(&v186, ", Mixed TF: ", 0xCuLL);
    long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v187.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v187.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v176, *((unsigned __int8 *)this + 16));
    if ((v176.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v26 = &v176;
    }
    else {
      long long v26 = (std::string *)v176.__r_.__value_.__r.__words[0];
    }
    if ((v176.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v27 = HIBYTE(v176.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v27 = v176.__r_.__value_.__l.__size_;
    }
    int v28 = std::string::append(&v187, (const std::string::value_type *)v26, v27);
    long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v188.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v188.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    __int16 v30 = std::string::append(&v188, ", sphereInterp: ", 0x10uLL);
    long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v189.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v189.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    CFStringRef v32 = std::map<IR::IRSphericalInterpolation,std::string>::at((uint64_t)&v221, (int *)this + 5);
    int v33 = *((char *)v32 + 23);
    if (v33 >= 0) {
      uint64_t v34 = (const std::string::value_type *)v32;
    }
    else {
      uint64_t v34 = (const std::string::value_type *)*v32;
    }
    if (v33 >= 0) {
      std::string::size_type v35 = *((unsigned __int8 *)v32 + 23);
    }
    else {
      std::string::size_type v35 = v32[1];
    }
    std::string::size_type v36 = std::string::append(&v189, v34, v35);
    long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    v190.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v190.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    CFURLRef v38 = std::string::append(&v190, ", Window: (", 0xBuLL);
    long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v191.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v191.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    IR::IRDataWindow::description((IR::IRDataAttributes *)((char *)this + 24), &v175);
    if ((v175.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v40 = &v175;
    }
    else {
      int v40 = (std::string *)v175.__r_.__value_.__r.__words[0];
    }
    if ((v175.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v41 = HIBYTE(v175.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v41 = v175.__r_.__value_.__l.__size_;
    }
    long long v42 = std::string::append(&v191, (const std::string::value_type *)v40, v41);
    long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    v192.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v192.__r_.__value_.__l.__data_ = v43;
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    uint64_t v44 = std::string::append(&v192, ")", 1uLL);
    long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v193.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v193.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    int v46 = std::string::append(&v193, ", irType: ", 0xAuLL);
    long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    v194.__r_.__value_.__r.__words[2] = v46->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v194.__r_.__value_.__l.__data_ = v47;
    v46->__r_.__value_.__l.__size_ = 0;
    v46->__r_.__value_.__r.__words[2] = 0;
    v46->__r_.__value_.__r.__words[0] = 0;
    unsigned int v48 = std::map<IR::IRSphericalInterpolation,std::string>::at((uint64_t)&v220, (int *)this + 10);
    int v49 = *((char *)v48 + 23);
    if (v49 >= 0) {
      int v50 = (const std::string::value_type *)v48;
    }
    else {
      int v50 = (const std::string::value_type *)*v48;
    }
    if (v49 >= 0) {
      std::string::size_type v51 = *((unsigned __int8 *)v48 + 23);
    }
    else {
      std::string::size_type v51 = v48[1];
    }
    float v52 = std::string::append(&v194, v50, v51);
    long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v195.__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v195.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0;
    v52->__r_.__value_.__r.__words[2] = 0;
    v52->__r_.__value_.__r.__words[0] = 0;
    uint64_t v54 = std::string::append(&v195, ", orientation: ", 0xFuLL);
    long long v55 = *(_OWORD *)&v54->__r_.__value_.__l.__data_;
    v196.__r_.__value_.__r.__words[2] = v54->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v196.__r_.__value_.__l.__data_ = v55;
    v54->__r_.__value_.__l.__size_ = 0;
    v54->__r_.__value_.__r.__words[2] = 0;
    v54->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v174, *((_DWORD *)this + 11));
    if ((v174.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeRef v56 = &v174;
    }
    else {
      CFTypeRef v56 = (std::string *)v174.__r_.__value_.__r.__words[0];
    }
    if ((v174.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v57 = HIBYTE(v174.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v57 = v174.__r_.__value_.__l.__size_;
    }
    CFTypeRef v58 = std::string::append(&v196, (const std::string::value_type *)v56, v57);
    long long v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v197.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v197.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    CFStringRef v60 = std::string::append(&v197, ", personalizedHRIR: (", 0x15uLL);
    long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    v198.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v198.__r_.__value_.__l.__data_ = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    IR::PersonalizedHRIRFetchingParams::description((IR::IRDataAttributes *)((char *)this + 48), &v173);
    if ((v173.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v62 = &v173;
    }
    else {
      int v62 = (std::string *)v173.__r_.__value_.__r.__words[0];
    }
    if ((v173.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v63 = HIBYTE(v173.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v63 = v173.__r_.__value_.__l.__size_;
    }
    char v64 = std::string::append(&v198, (const std::string::value_type *)v62, v63);
    long long v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v199.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v199.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0;
    v64->__r_.__value_.__r.__words[2] = 0;
    v64->__r_.__value_.__r.__words[0] = 0;
    CFTypeRef v66 = std::string::append(&v199, ")", 1uLL);
    long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
    v200.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v200.__r_.__value_.__l.__data_ = v67;
    v66->__r_.__value_.__l.__size_ = 0;
    v66->__r_.__value_.__r.__words[2] = 0;
    v66->__r_.__value_.__r.__words[0] = 0;
    long long v68 = std::string::append(&v200, ", hoaHOADecoderURL: ", 0x14uLL);
    long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
    v201.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v201.__r_.__value_.__l.__data_ = v69;
    v68->__r_.__value_.__l.__size_ = 0;
    v68->__r_.__value_.__r.__words[2] = 0;
    v68->__r_.__value_.__r.__words[0] = 0;
    uint64_t v70 = (const void *)*((void *)this + 8);
    if (v70)
    {
      CFStringRef v71 = CFCopyDescription(v70);
      applesauce::CF::details::CFString_get_value<true>(v71, (uint64_t)v171);
      if (v71) {
        CFRelease(v71);
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(v171, "nullptr");
    }
    if ((v172 & 0x80u) == 0) {
      uint64_t v103 = v171;
    }
    else {
      uint64_t v103 = (void **)v171[0];
    }
    if ((v172 & 0x80u) == 0) {
      std::string::size_type v104 = v172;
    }
    else {
      std::string::size_type v104 = (std::string::size_type)v171[1];
    }
    float v105 = std::string::append(&v201, (const std::string::value_type *)v103, v104);
    long long v106 = *(_OWORD *)&v105->__r_.__value_.__l.__data_;
    v202.__r_.__value_.__r.__words[2] = v105->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v202.__r_.__value_.__l.__data_ = v106;
    v105->__r_.__value_.__l.__size_ = 0;
    v105->__r_.__value_.__r.__words[2] = 0;
    v105->__r_.__value_.__r.__words[0] = 0;
    float v107 = std::string::append(&v202, ", hoaHOADecoderIRWindow: (", 0x1AuLL);
    long long v108 = *(_OWORD *)&v107->__r_.__value_.__l.__data_;
    v203.__r_.__value_.__r.__words[2] = v107->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v203.__r_.__value_.__l.__data_ = v108;
    v107->__r_.__value_.__l.__size_ = 0;
    v107->__r_.__value_.__r.__words[2] = 0;
    v107->__r_.__value_.__r.__words[0] = 0;
    IR::IRDataWindow::description((IR::IRDataAttributes *)((char *)this + 72), &v170);
    if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v109 = &v170;
    }
    else {
      float v109 = (std::string *)v170.__r_.__value_.__r.__words[0];
    }
    if ((v170.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v110 = HIBYTE(v170.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v110 = v170.__r_.__value_.__l.__size_;
    }
    float v111 = std::string::append(&v203, (const std::string::value_type *)v109, v110);
    long long v112 = *(_OWORD *)&v111->__r_.__value_.__l.__data_;
    v204.__r_.__value_.__r.__words[2] = v111->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v204.__r_.__value_.__l.__data_ = v112;
    v111->__r_.__value_.__l.__size_ = 0;
    v111->__r_.__value_.__r.__words[2] = 0;
    v111->__r_.__value_.__r.__words[0] = 0;
    float v113 = std::string::append(&v204, ")", 1uLL);
    long long v114 = *(_OWORD *)&v113->__r_.__value_.__l.__data_;
    v205.__r_.__value_.__r.__words[2] = v113->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v205.__r_.__value_.__l.__data_ = v114;
    v113->__r_.__value_.__l.__size_ = 0;
    v113->__r_.__value_.__r.__words[2] = 0;
    v113->__r_.__value_.__r.__words[0] = 0;
    float v115 = std::string::append(&v205, ", hoaDecoderURL: ", 0x11uLL);
    long long v116 = *(_OWORD *)&v115->__r_.__value_.__l.__data_;
    v206.__r_.__value_.__r.__words[2] = v115->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v206.__r_.__value_.__l.__data_ = v116;
    v115->__r_.__value_.__l.__size_ = 0;
    v115->__r_.__value_.__r.__words[2] = 0;
    v115->__r_.__value_.__r.__words[0] = 0;
    uint64_t v117 = (const void *)*((void *)this + 11);
    if (v117)
    {
      CFStringRef v118 = CFCopyDescription(v117);
      applesauce::CF::details::CFString_get_value<true>(v118, (uint64_t)v168);
      if (v118) {
        CFRelease(v118);
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(v168, "nullptr");
    }
    if ((v169 & 0x80u) == 0) {
      unsigned int v119 = v168;
    }
    else {
      unsigned int v119 = (void **)v168[0];
    }
    if ((v169 & 0x80u) == 0) {
      std::string::size_type v120 = v169;
    }
    else {
      std::string::size_type v120 = (std::string::size_type)v168[1];
    }
    uint64_t v121 = std::string::append(&v206, (const std::string::value_type *)v119, v120);
    long long v122 = *(_OWORD *)&v121->__r_.__value_.__l.__data_;
    v207.__r_.__value_.__r.__words[2] = v121->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v207.__r_.__value_.__l.__data_ = v122;
    v121->__r_.__value_.__l.__size_ = 0;
    v121->__r_.__value_.__r.__words[2] = 0;
    v121->__r_.__value_.__r.__words[0] = 0;
    float v123 = std::string::append(&v207, ", hoaDecoderACLTag: ", 0x14uLL);
    long long v124 = *(_OWORD *)&v123->__r_.__value_.__l.__data_;
    v208.__r_.__value_.__r.__words[2] = v123->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v208.__r_.__value_.__l.__data_ = v124;
    v123->__r_.__value_.__l.__size_ = 0;
    v123->__r_.__value_.__r.__words[2] = 0;
    v123->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v167, *((_DWORD *)this + 25));
    if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v125 = &v167;
    }
    else {
      float v125 = (std::string *)v167.__r_.__value_.__r.__words[0];
    }
    if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v126 = HIBYTE(v167.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v126 = v167.__r_.__value_.__l.__size_;
    }
    float v127 = std::string::append(&v208, (const std::string::value_type *)v125, v126);
    long long v128 = *(_OWORD *)&v127->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v127->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v128;
    v127->__r_.__value_.__l.__size_ = 0;
    v127->__r_.__value_.__r.__words[2] = 0;
    v127->__r_.__value_.__r.__words[0] = 0;
    float v129 = std::string::append(&__p, ", hoaDecoderPersonalizedHRIR: (", 0x1FuLL);
    long long v130 = *(_OWORD *)&v129->__r_.__value_.__l.__data_;
    v210.__r_.__value_.__r.__words[2] = v129->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v210.__r_.__value_.__l.__data_ = v130;
    v129->__r_.__value_.__l.__size_ = 0;
    v129->__r_.__value_.__r.__words[2] = 0;
    v129->__r_.__value_.__r.__words[0] = 0;
    IR::PersonalizedHRIRFetchingParams::description((IR::IRDataAttributes *)((char *)this + 104), &v166);
    if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v131 = &v166;
    }
    else {
      float v131 = (std::string *)v166.__r_.__value_.__r.__words[0];
    }
    if ((v166.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v132 = HIBYTE(v166.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v132 = v166.__r_.__value_.__l.__size_;
    }
    float v133 = std::string::append(&v210, (const std::string::value_type *)v131, v132);
    long long v134 = *(_OWORD *)&v133->__r_.__value_.__l.__data_;
    v211.__r_.__value_.__r.__words[2] = v133->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v211.__r_.__value_.__l.__data_ = v134;
    v133->__r_.__value_.__l.__size_ = 0;
    v133->__r_.__value_.__r.__words[2] = 0;
    v133->__r_.__value_.__r.__words[0] = 0;
    unsigned int v135 = std::string::append(&v211, ")", 1uLL);
    long long v136 = *(_OWORD *)&v135->__r_.__value_.__l.__data_;
    v212.__r_.__value_.__r.__words[2] = v135->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v212.__r_.__value_.__l.__data_ = v136;
    v135->__r_.__value_.__l.__size_ = 0;
    v135->__r_.__value_.__r.__words[2] = 0;
    v135->__r_.__value_.__r.__words[0] = 0;
    uint64_t v137 = std::string::append(&v212, ", expDecayCoeff: ", 0x11uLL);
    long long v138 = *(_OWORD *)&v137->__r_.__value_.__l.__data_;
    v213.__r_.__value_.__r.__words[2] = v137->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v213.__r_.__value_.__l.__data_ = v138;
    v137->__r_.__value_.__l.__size_ = 0;
    v137->__r_.__value_.__r.__words[2] = 0;
    v137->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v165, *((float *)this + 29));
    if ((v165.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v139 = &v165;
    }
    else {
      uint64_t v139 = (std::string *)v165.__r_.__value_.__r.__words[0];
    }
    if ((v165.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v140 = HIBYTE(v165.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v140 = v165.__r_.__value_.__l.__size_;
    }
    int v141 = std::string::append(&v213, (const std::string::value_type *)v139, v140);
    long long v142 = *(_OWORD *)&v141->__r_.__value_.__l.__data_;
    v214.__r_.__value_.__r.__words[2] = v141->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v214.__r_.__value_.__l.__data_ = v142;
    v141->__r_.__value_.__l.__size_ = 0;
    v141->__r_.__value_.__r.__words[2] = 0;
    v141->__r_.__value_.__r.__words[0] = 0;
    float v143 = std::string::append(&v214, ", computeAverageIR: ", 0x14uLL);
    long long v144 = *(_OWORD *)&v143->__r_.__value_.__l.__data_;
    v215.__r_.__value_.__r.__words[2] = v143->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v215.__r_.__value_.__l.__data_ = v144;
    v143->__r_.__value_.__l.__size_ = 0;
    v143->__r_.__value_.__r.__words[2] = 0;
    v143->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v164, *((unsigned __int8 *)this + 120));
    if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v145 = &v164;
    }
    else {
      unsigned int v145 = (std::string *)v164.__r_.__value_.__r.__words[0];
    }
    if ((v164.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v146 = HIBYTE(v164.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v146 = v164.__r_.__value_.__l.__size_;
    }
    vDSP_Length v147 = std::string::append(&v215, (const std::string::value_type *)v145, v146);
    long long v148 = *(_OWORD *)&v147->__r_.__value_.__l.__data_;
    v216.__r_.__value_.__r.__words[2] = v147->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v216.__r_.__value_.__l.__data_ = v148;
    v147->__r_.__value_.__l.__size_ = 0;
    v147->__r_.__value_.__r.__words[2] = 0;
    v147->__r_.__value_.__r.__words[0] = 0;
    BOOL v149 = std::string::append(&v216, ", Bake Delays: ", 0xFuLL);
    long long v150 = *(_OWORD *)&v149->__r_.__value_.__l.__data_;
    v217.__r_.__value_.__r.__words[2] = v149->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v217.__r_.__value_.__l.__data_ = v150;
    v149->__r_.__value_.__l.__size_ = 0;
    v149->__r_.__value_.__r.__words[2] = 0;
    v149->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v163, *((unsigned __int8 *)this + 17));
    if ((v163.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      vDSP_Length v151 = &v163;
    }
    else {
      vDSP_Length v151 = (std::string *)v163.__r_.__value_.__r.__words[0];
    }
    if ((v163.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v152 = HIBYTE(v163.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v152 = v163.__r_.__value_.__l.__size_;
    }
    float v153 = std::string::append(&v217, (const std::string::value_type *)v151, v152);
    long long v154 = *(_OWORD *)&v153->__r_.__value_.__l.__data_;
    v218.__r_.__value_.__r.__words[2] = v153->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v218.__r_.__value_.__l.__data_ = v154;
    v153->__r_.__value_.__l.__size_ = 0;
    v153->__r_.__value_.__r.__words[2] = 0;
    v153->__r_.__value_.__r.__words[0] = 0;
    int v155 = std::string::append(&v218, ", convolutionOptimizationParameters: (", 0x26uLL);
    long long v156 = *(_OWORD *)&v155->__r_.__value_.__l.__data_;
    v219.__r_.__value_.__r.__words[2] = v155->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v219.__r_.__value_.__l.__data_ = v156;
    v155->__r_.__value_.__l.__size_ = 0;
    v155->__r_.__value_.__r.__words[2] = 0;
    v155->__r_.__value_.__r.__words[0] = 0;
    IR::FFTFilterOptimizationParameters::description((IR::IRDataAttributes *)((char *)this + 136), &v162);
    if ((v162.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v157 = &v162;
    }
    else {
      unsigned int v157 = (std::string *)v162.__r_.__value_.__r.__words[0];
    }
    if ((v162.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v158 = HIBYTE(v162.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v158 = v162.__r_.__value_.__l.__size_;
    }
    uint64_t v159 = std::string::append(&v219, (const std::string::value_type *)v157, v158);
    long long v160 = *(_OWORD *)&v159->__r_.__value_.__l.__data_;
    v222.__r_.__value_.__r.__words[2] = v159->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v222.__r_.__value_.__l.__data_ = v160;
    v159->__r_.__value_.__l.__size_ = 0;
    v159->__r_.__value_.__r.__words[2] = 0;
    v159->__r_.__value_.__r.__words[0] = 0;
    unsigned int v161 = std::string::append(&v222, ")", 1uLL);
    *a3 = *v161;
    v161->__r_.__value_.__l.__size_ = 0;
    v161->__r_.__value_.__r.__words[2] = 0;
    v161->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v222.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v222.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v162.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v162.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v219.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v219.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v218.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v218.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v163.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v163.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v217.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v217.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v216.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v216.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v164.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v215.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v214.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v165.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v213.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v213.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v212.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v211.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v166.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v166.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v210.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v167.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v208.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v208.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v207.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v207.__r_.__value_.__l.__data_);
    }
    if ((char)v169 < 0) {
      operator delete(v168[0]);
    }
    if (SHIBYTE(v206.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v206.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v205.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v205.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v204.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v204.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v170.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v203.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v203.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v202.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v202.__r_.__value_.__l.__data_);
    }
    if ((char)v172 < 0) {
      operator delete(v171[0]);
    }
    if (SHIBYTE(v201.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v201.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v200.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v200.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v199.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v199.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v173.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v173.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v198.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v198.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v197.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v197.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v174.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v174.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v196.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v196.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v195.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v194.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v193.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v193.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v192.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v192.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v175.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v175.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v191.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v191.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v190.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v190.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v189.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v189.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v188.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v188.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v176.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v176.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v187.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v187.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v186.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v186.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v177.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v177.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v185.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v185.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v184.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v184.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v178.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v178.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v183.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v183.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v182.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v182.__r_.__value_.__l.__data_);
    }
    if ((char)v180 < 0) {
      operator delete(v179[0]);
    }
    if (SHIBYTE(v181.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v181.__r_.__value_.__l.__data_);
    }
    std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy((uint64_t)&v220, (char *)v220.__r_.__value_.__l.__size_);
    std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy((uint64_t)&v221, (char *)v221.__r_.__value_.__l.__size_);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&v213, "Sample rate: ");
    std::to_string(&v212, *((float *)this + 2));
    if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      float v72 = &v212;
    }
    else {
      float v72 = (std::string *)v212.__r_.__value_.__r.__words[0];
    }
    if ((v212.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v73 = HIBYTE(v212.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v73 = v212.__r_.__value_.__l.__size_;
    }
    float v74 = std::string::append(&v213, (const std::string::value_type *)v72, v73);
    long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
    v214.__r_.__value_.__r.__words[2] = v74->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v214.__r_.__value_.__l.__data_ = v75;
    v74->__r_.__value_.__l.__size_ = 0;
    v74->__r_.__value_.__r.__words[2] = 0;
    v74->__r_.__value_.__r.__words[0] = 0;
    uint64_t v76 = std::string::append(&v214, ", Partition length: ", 0x14uLL);
    long long v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
    v215.__r_.__value_.__r.__words[2] = v76->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v215.__r_.__value_.__l.__data_ = v77;
    v76->__r_.__value_.__l.__size_ = 0;
    v76->__r_.__value_.__r.__words[2] = 0;
    v76->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v211, *((_DWORD *)this + 3));
    if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeRef v78 = &v211;
    }
    else {
      CFTypeRef v78 = (std::string *)v211.__r_.__value_.__r.__words[0];
    }
    if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v79 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v79 = v211.__r_.__value_.__l.__size_;
    }
    int v80 = std::string::append(&v215, (const std::string::value_type *)v78, v79);
    long long v81 = *(_OWORD *)&v80->__r_.__value_.__l.__data_;
    v216.__r_.__value_.__r.__words[2] = v80->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v216.__r_.__value_.__l.__data_ = v81;
    v80->__r_.__value_.__l.__size_ = 0;
    v80->__r_.__value_.__r.__words[2] = 0;
    v80->__r_.__value_.__r.__words[0] = 0;
    float v82 = std::string::append(&v216, ", Mixed TF: ", 0xCuLL);
    long long v83 = *(_OWORD *)&v82->__r_.__value_.__l.__data_;
    v217.__r_.__value_.__r.__words[2] = v82->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v217.__r_.__value_.__l.__data_ = v83;
    v82->__r_.__value_.__l.__size_ = 0;
    v82->__r_.__value_.__r.__words[2] = 0;
    v82->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v210, *((unsigned __int8 *)this + 16));
    if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeRef v84 = &v210;
    }
    else {
      CFTypeRef v84 = (std::string *)v210.__r_.__value_.__r.__words[0];
    }
    if ((v210.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v85 = HIBYTE(v210.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v85 = v210.__r_.__value_.__l.__size_;
    }
    uint64_t v86 = std::string::append(&v217, (const std::string::value_type *)v84, v85);
    long long v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
    v218.__r_.__value_.__r.__words[2] = v86->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v218.__r_.__value_.__l.__data_ = v87;
    v86->__r_.__value_.__l.__size_ = 0;
    v86->__r_.__value_.__r.__words[2] = 0;
    v86->__r_.__value_.__r.__words[0] = 0;
    float v88 = std::string::append(&v218, ", Window: (", 0xBuLL);
    long long v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v219.__r_.__value_.__r.__words[2] = v88->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v219.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0;
    v88->__r_.__value_.__r.__words[2] = 0;
    v88->__r_.__value_.__r.__words[0] = 0;
    IR::IRDataWindow::description((IR::IRDataAttributes *)((char *)this + 24), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v91 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v91 = __p.__r_.__value_.__l.__size_;
    }
    float v92 = std::string::append(&v219, (const std::string::value_type *)p_p, v91);
    long long v93 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
    v220.__r_.__value_.__r.__words[2] = v92->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v220.__r_.__value_.__l.__data_ = v93;
    v92->__r_.__value_.__l.__size_ = 0;
    v92->__r_.__value_.__r.__words[2] = 0;
    v92->__r_.__value_.__r.__words[0] = 0;
    float v94 = std::string::append(&v220, ")", 1uLL);
    long long v95 = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
    v221.__r_.__value_.__r.__words[2] = v94->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v221.__r_.__value_.__l.__data_ = v95;
    v94->__r_.__value_.__l.__size_ = 0;
    v94->__r_.__value_.__r.__words[2] = 0;
    v94->__r_.__value_.__r.__words[0] = 0;
    float v96 = std::string::append(&v221, ", Sphere interpolation: ", 0x18uLL);
    long long v97 = *(_OWORD *)&v96->__r_.__value_.__l.__data_;
    v222.__r_.__value_.__r.__words[2] = v96->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v222.__r_.__value_.__l.__data_ = v97;
    v96->__r_.__value_.__l.__size_ = 0;
    v96->__r_.__value_.__r.__words[2] = 0;
    v96->__r_.__value_.__r.__words[0] = 0;
    CFTypeRef v98 = "Auto";
    int v99 = *((_DWORD *)this + 5);
    if (v99 == 1) {
      CFTypeRef v98 = "VBAP";
    }
    if (v99) {
      unsigned int v100 = v98;
    }
    else {
      unsigned int v100 = "Bilinear";
    }
    if (v99) {
      std::string::size_type v101 = 4;
    }
    else {
      std::string::size_type v101 = 8;
    }
    uint64_t v102 = std::string::append(&v222, v100, v101);
    *a3 = *v102;
    v102->__r_.__value_.__l.__size_ = 0;
    v102->__r_.__value_.__r.__words[2] = 0;
    v102->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v222.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v222.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v221.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v221.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v220.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v220.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v219.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v219.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v218.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v218.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v210.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v217.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v217.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v216.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v216.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v211.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v215.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v214.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v214.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v212.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v213.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v213.__r_.__value_.__l.__data_);
    }
  }
}

void sub_21B514AF0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_21B5151E8()
{
}

void sub_21B5151F0()
{
}

void sub_21B5151F8()
{
  uint64_t v1 = 0;
  while (1)
  {
    if (*(char *)(v0 + v1 + 127) < 0) {
      operator delete(*(void **)(v0 + v1 + 104));
    }
    v1 -= 32;
    if (v1 == -128) {
      JUMPOUT(0x21B514EFCLL);
    }
  }
}

void sub_21B515224()
{
  while (1)
  {
    if (*(char *)(v0 - 1) < 0) {
      operator delete(*(void **)(v0 - 24));
    }
    v0 -= 32;
    if (v0 == v1 - 192) {
      JUMPOUT(0x21B514EFCLL);
    }
  }
}

void sub_21B515254()
{
}

void sub_21B51525C()
{
  uint64_t v1 = 0;
  while (1)
  {
    if (*(char *)(v0 + v1 + 95) < 0) {
      operator delete(*(void **)(v0 + v1 + 72));
    }
    v1 -= 32;
    if (v1 == -96) {
      JUMPOUT(0x21B514F08);
    }
  }
}

void sub_21B515288()
{
  while (1)
  {
    if (*(char *)(v0 - 1) < 0) {
      operator delete(*(void **)(v0 - 24));
    }
    v0 -= 32;
    if (v0 == v1 - 192) {
      JUMPOUT(0x21B514F08);
    }
  }
}

void sub_21B5152BC()
{
}

void sub_21B5152C4()
{
}

void IR::generateGrid(IR *this@<X0>, int a2@<W1>, float *a3@<X4>, uint64_t a4@<X8>)
{
  if (!a2)
  {
    std::string::size_type v9 = operator new(4uLL);
    uint64_t v24 = v9;
    *std::string::size_type v9 = 0;
    long long v25 = v9 + 1;
    long long v26 = v9 + 1;
    CFTypeRef v10 = (float *)operator new(4uLL);
    std::string::size_type v21 = v10;
    *CFTypeRef v10 = 0.0;
    uint64_t v22 = v10 + 1;
    long long v23 = v10 + 1;
    LOBYTE(v18) = 0;
    _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorIfNS_9allocatorIfEEEES6_bEEC2B8ne180100IJLm0ELm1ELm2EEJS6_S6_bEJEJEJRKS6_SA_RKbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSE_IJDpT2_EEEDpOT3_(a4, (uint64_t)&v24, (uint64_t)&v21, &v18);
    goto LABEL_5;
  }
  uint64_t v24 = 0;
  long long v25 = 0;
  long long v26 = 0;
  std::string::size_type v21 = 0;
  uint64_t v22 = 0;
  long long v23 = 0;
  int TDesign = HOA::getTDesign(this, 0, 0, 0, a3);
  if (TDesign >= 2)
  {
    unint64_t v7 = TDesign;
    std::vector<float>::resize((uint64_t)&v24, TDesign);
    std::vector<float>::resize((uint64_t)&v21, v7);
    HOA::getTDesign(this, v24, v21, 0, v8);
    LOBYTE(v18) = 1;
    _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorIfNS_9allocatorIfEEEES6_bEEC2B8ne180100IJLm0ELm1ELm2EEJS6_S6_bEJEJEJRS6_S9_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSB_IJDpT2_EEEDpOT3_(a4, (uint64_t)&v24, (uint64_t)&v21, &v18);
LABEL_5:
    long long v11 = v21;
    if (!v21) {
      goto LABEL_12;
    }
    uint64_t v22 = v21;
    goto LABEL_11;
  }
  CFTypeRef v12 = operator new(4uLL);
  CFTypeRef v18 = v12;
  *CFTypeRef v12 = 0;
  long long v19 = v12 + 1;
  CFTypeRef v20 = v12 + 1;
  long long v13 = operator new(4uLL);
  std::string __p = v13;
  *long long v13 = 0;
  __int16 v16 = v13 + 1;
  long long v17 = v13 + 1;
  char v14 = 0;
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorIfNS_9allocatorIfEEEES6_bEEC2B8ne180100IJLm0ELm1ELm2EEJS6_S6_bEJEJEJRKS6_SA_RKbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSE_IJDpT2_EEEDpOT3_(a4, (uint64_t)&v18, (uint64_t)&__p, &v14);
  if (__p)
  {
    __int16 v16 = __p;
    operator delete(__p);
  }
  long long v11 = v18;
  if (v18)
  {
    long long v19 = v18;
LABEL_11:
    operator delete(v11);
  }
LABEL_12:
  if (v24)
  {
    long long v25 = v24;
    operator delete(v24);
  }
}

void sub_21B51543C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  CFTypeRef v20 = *(void **)(v18 - 56);
  if (v20)
  {
    *(void *)(v18 - 48) = v20;
    operator delete(v20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataLoader::writeIRFile(uint64_t *a1, CFURLRef *a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = (std::__shared_weak_count *)a1[1];
  uint64_t v7 = *a1;
  CFTypeRef v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = IR::IRDataLoader::writeIRFile((uint64_t)&v7, a2, a3, a4);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  return v5;
}

void sub_21B515504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataLoader::writeIRFile(uint64_t a1, CFURLRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  CFURLGetFileSystemRepresentation(*a2, 1u, buffer, 1024);
  SerializedIRCFDataRef Data = (const __CFData *)IR::IRData::createSerializedIRData(a1, a3, a4);
  if (!SerializedIRData) {
    return 4294956425;
  }
  std::string::size_type v9 = fopen((const char *)buffer, "wb");
  BytePtr = CFDataGetBytePtr(SerializedIRData);
  CFIndex Length = CFDataGetLength(SerializedIRData);
  fwrite(BytePtr, Length, 1uLL, v9);
  CFRelease(SerializedIRData);
  if (v9) {
    fclose(v9);
  }
  IsReachable = (IR *)CFURLResourceIsReachable(*a2, 0);
  BOOL v13 = IsReachable == 0;
  IRDataLog = IR::getIRDataLog(IsReachable);
  CFTypeRef v15 = IRDataLog;
  if (v13)
  {
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::writeIRFile(v15, v17, v18, v19, v20, v21, v22, v23);
    }
    return 4294956425;
  }
  uint64_t result = os_log_type_enabled(IRDataLog, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    IR::IRDataLoader::writeIRFile();
    return 0;
  }
  return result;
}

void sub_21B515660(_Unwind_Exception *exception_object)
{
  if (v1) {
    fclose(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataLoader::writeIRFile(uint64_t a1, CFURLRef *a2, uint64_t a3, uint64_t *a4, uint64_t a5, unsigned int a6, uint64_t *a7, uint64_t *a8, float a9, uint64_t *a10, CFTypeRef *a11, _DWORD *a12, uint64_t a13, uint64_t a14, CFTypeRef *a15)
{
  uint64_t v161 = *MEMORY[0x263EF8340];
  float v145 = a9;
  unsigned int v144 = a6;
  CFTypeRef v15 = *(void **)a1;
  uint64_t v16 = *(void *)(a1 + 8);
  if (*(void *)a1 == v16) {
    goto LABEL_11;
  }
  uint64_t v18 = *(void **)a3;
  uint64_t v19 = *(void *)(a3 + 8);
  if (*(void *)a3 == v19) {
    goto LABEL_11;
  }
  if (!a6) {
    goto LABEL_11;
  }
  uint64_t v22 = a1;
  a1 = *a4;
  uint64_t v23 = a4[1];
  if (*a4 == v23
    || (uint64_t v25 = *a7, v26 = a7[1], *a7 == v26)
    || (uint64_t v28 = *a8, v29 = a8[1], *a8 == v29)
    || (uint64_t v30 = *a10, v31 = a10[1], *a10 == v31))
  {
LABEL_11:
    IRDataLog = IR::getIRDataLog((IR *)a1);
    if (os_log_type_enabled(IRDataLog, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::writeIRFile(IRDataLog, v43, v44, v45, v46, v47, v48, v49);
    }
    return 4294956425;
  }
  unint64_t v33 = (uint64_t)(v15[1] - *v15) >> 2;
  if (v33 % a6)
  {
    uint64_t v34 = IR::getIRDataLog((IR *)a1);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::writeIRFile(v34, v35, v36, v37, v38, v39, v40, v41);
    }
    return 4294956425;
  }
  unint64_t v52 = 0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v15) >> 3);
  uint64_t v143 = v52;
  if (0xAAAAAAAAAAAAAAABLL * ((v19 - (uint64_t)v18) >> 3) != v52
    || (a1 = v23 - a1, uint64_t v53 = a1 >> 2, a1 >> 2 != (uint64_t)(v18[1] - *v18) >> 2)
    || v53 != (v26 - v25) >> 2
    || v53 != (v29 - v28) >> 2
    || v53 != (v31 - v30) >> 2)
  {
    CFTypeRef v56 = IR::getIRDataLog((IR *)a1);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::writeIRFile(v56, v57, v58, v59, v60, v61, v62, v63);
    }
    return 4294956425;
  }
  uint64_t v54 = *(void **)a5;
  uint64_t v55 = *(void *)(a5 + 8);
  if (*(void *)a5 != v55
    && (0xAAAAAAAAAAAAAAABLL * ((v55 - (uint64_t)v54) >> 3) != v52 || a6 != (uint64_t)(v54[1] - *v54) >> 2))
  {
    char v64 = IR::getIRDataLog((IR *)a1);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
      IR::IRDataLoader::writeIRFile(v64, v65, v66, v67, v68, v69, v70, v71);
    }
    return 4294956425;
  }
  uint64_t v121 = a1;
  unint64_t v142 = v33 / a6;
  float __B = 0.0;
  uint64_t v120 = a1 >> 2;
  if (*a12)
  {
    float __B = 1.0;
  }
  else
  {
    uint64_t v72 = 0;
    __C[0] = 0.0;
    float v73 = 0.0;
    unsigned int v74 = 1;
    do
    {
      vDSP_maxmgv((const float *)v15[3 * v72], 1, __C, (uint64_t)(v15[3 * v72 + 1] - v15[3 * v72]) >> 2);
      if (__C[0] > v73) {
        float v73 = __C[0];
      }
      uint64_t v72 = v74;
      CFTypeRef v15 = *(void **)v22;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v22 + 8) - *(void *)v22) >> 3) > v74++);
    float __B = v73 * 0.000030518;
  }
  CFURLGetFileSystemRepresentation(*a2, 1u, (UInt8 *)__C, 1024);
  uint64_t v76 = fopen((const char *)__C, "wb");
  memset(v139, 0, sizeof(v139));
  CFDictionaryRef v140 = 0;
  __stream = v76;
  uint64_t v77 = v120;
  if (v121 >= 1)
  {
    uint64_t v78 = 0;
    if (v120 <= 1) {
      uint64_t v77 = 1;
    }
    uint64_t v122 = v77;
    do
    {
      IR::IRCoordinates::getParameterString(*(_DWORD *)(*a4 + 4 * v78), __p);
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[5],std::string>((applesauce::CF::TypeRef *)&v148, "Name", (uint64_t)__p);
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float const&>((applesauce::CF::TypeRef *)v150, "Periodicity", (int *)(*a7 + 4 * v78));
      LODWORD(v129[0]) = *(_DWORD *)(*a8 + 4 * v78);
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[14],int>((applesauce::CF::TypeRef *)v151, "Interpolation", (int *)v129);
      applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float const&>((applesauce::CF::TypeRef *)v152, "DefaultValue", (int *)(*a10 + 4 * v78));
      uint64_t v123 = v78;
      __D = (float *)&v148;
      uint64_t v132 = 4;
      CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&__D);
      CFDictionaryRef v80 = v140;
      CFDictionaryRef v140 = CFDictionaryRef;
      __ptr[0] = v80;
      applesauce::CF::DictionaryRef::~DictionaryRef(__ptr);
      for (uint64_t i = 0; i != -64; i -= 16)
      {
        float v82 = *(const void **)&v152[i + 8];
        if (v82) {
          CFRelease(v82);
        }
        long long v83 = *(const void **)&v152[i];
        if (v83) {
          CFRelease(v83);
        }
      }
      if (v138 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v76 = __stream;
      std::vector<applesauce::CF::DictionaryRef>::push_back[abi:ne180100](v139, (CFTypeRef *)&v140);
      ++v78;
    }
    while (v123 + 1 != v122);
  }
  CFArrayRef v136 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)v139);
  if (*a12) {
    CFTypeRef v84 = "float32";
  }
  else {
    CFTypeRef v84 = "int16";
  }
  std::string::basic_string[abi:ne180100]<0>(__p, v84);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],std::string>((applesauce::CF::TypeRef *)&v148, "CoefficientFormat", (uint64_t)__p);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],long &>((applesauce::CF::TypeRef *)v150, "FilterLength", (uint64_t *)&v142);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float &>((applesauce::CF::TypeRef *)v151, "SampleRate", (int *)&v145);
  std::string::basic_string[abi:ne180100]<0>(&__D, "float32");
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],std::string>((applesauce::CF::TypeRef *)v152, "DelayFormat", (uint64_t)&__D);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[20],long &>((applesauce::CF::TypeRef *)&v153, "TotalNumCoordinates", &v143);
  CFTypeRef v85 = *a11;
  if (*a11)
  {
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v130, a11);
  }
  else
  {
    int v128 = 0;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[1],int>((applesauce::CF::TypeRef *)v147, "", &v128);
    v129[0] = v147;
    v129[1] = 1;
    CFDictionaryRef v130 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v129);
    uint64_t v76 = __stream;
  }
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],applesauce::CF::DictionaryRef const>((applesauce::CF::TypeRef *)&v154, "UserData", (const void **)&v130);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],applesauce::CF::ArrayRef &>((applesauce::CF::TypeRef *)&v155, "Dimensions", (const void **)&v136);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],float &>((applesauce::CF::TypeRef *)&v156, "FilterScaleFactor", (int *)&__B);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],unsigned int &>((applesauce::CF::TypeRef *)&v157, "NumChannels", (int *)&v144);
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],std::string const&>((applesauce::CF::TypeRef *)&v158, "Description", a14);
  CFTypeRef v86 = *a15;
  if (*a15)
  {
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v127, a15);
  }
  else
  {
    int v125 = 0;
    applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[1],int>((applesauce::CF::TypeRef *)v146, "", &v125);
    v126[0] = v146;
    v126[1] = 1;
    CFDictionaryRef v127 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v126);
    uint64_t v76 = __stream;
  }
  applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],applesauce::CF::DictionaryRef const>((applesauce::CF::TypeRef *)&v159, "TriangulationData", (const void **)&v127);
  __ptr[0] = &v148;
  __ptr[1] = (const void *)11;
  CFPropertyListRef propertyList = applesauce::CF::details::make_CFDictionaryRef((uint64_t)__ptr);
  for (uint64_t j = 20; j != -2; j -= 2)
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)&(&v148)[j]);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v127);
  if (!v86) {
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)v146);
  }
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v130);
  if (!v85) {
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)v147);
  }
  if (v133 < 0) {
    operator delete(__D);
  }
  if (v138 < 0) {
    operator delete(__p[0]);
  }
  CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x263EFFB08], propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  CFDataRef v89 = Data;
  if (Data)
  {
    CFIndex Length = CFDataGetLength(Data);
    std::vector<unsigned char>::vector(&v148, Length);
    v162.length = CFDataGetLength(v89);
    v162.location = 0;
    CFDataGetBytes(v89, v162, v148);
    __ptr[0] = (const void *)((char *)v149 - (char *)v148);
    fwrite(__ptr, 4uLL, 1uLL, v76);
    fwrite(v148, 1uLL, (size_t)__ptr[0], v76);
    std::vector<short>::vector(__p, v142);
    std::vector<float>::vector(&__D, v142);
    LODWORD(v129[0]) = 1191181824;
    LODWORD(v126[0]) = -956301312;
    float v91 = 0.0;
    if (__B != 0.0) {
      float v91 = 1.0 / __B;
    }
    float __B = v91;
    if (v143 >= 1)
    {
      uint64_t v92 = 0;
      uint64_t v93 = v120;
      if (v120 <= 1) {
        uint64_t v93 = 1;
      }
      uint64_t v94 = 4 * v93;
      do
      {
        if (v121 >= 1)
        {
          uint64_t v95 = 0;
          do
          {
            fwrite((const void *)(*(void *)(*(void *)a3 + 24 * v92) + v95), 4uLL, 1uLL, v76);
            v95 += 4;
          }
          while (v94 != v95);
        }
        if (v144)
        {
          uint64_t v96 = 0;
          for (unint64_t k = 0; k < v144; ++k)
          {
            size_t v98 = v142;
            int v99 = (const float *)(*(void *)(*(void *)v22 + 24 * v92) + 4 * v142 * k);
            if (*a12)
            {
              size_t v100 = 4;
            }
            else
            {
              vDSP_vsmul(v99, 1, &__B, __D, 1, v142);
              vDSP_vclip(__D, 1, (const float *)v126, (const float *)v129, __D, 1, v142);
              vDSP_vfix16(__D, 1, (__int16 *)__p[0], 1, v142);
              int v99 = (const float *)__p[0];
              size_t v98 = v142;
              size_t v100 = 2;
            }
            fwrite(v99, v100, v98, __stream);
            if (*(void *)a5 == *(void *)(a5 + 8))
            {
              LODWORD(v13std::unique_ptr<AudioDSP::Core::VBAP::Implementation>::reset[abi:ne180100]((uint64_t *)this, 0) = 0;
              fwrite(&v130, 4uLL, 1uLL, __stream);
            }
            else
            {
              fwrite((const void *)(*(void *)(*(void *)a5 + 24 * v92) + v96), 4uLL, 1uLL, __stream);
            }
            v96 += 4;
          }
        }
        ++v92;
        uint64_t v76 = __stream;
      }
      while (v92 < v143);
    }
    CFRelease(v89);
    IsReachable = (IR *)CFURLResourceIsReachable(*a2, 0);
    if (IsReachable)
    {
      uint64_t v102 = IR::getIRDataLog(IsReachable);
      if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
      {
        IR::IRDataLoader::writeIRFile();
        uint64_t v103 = __stream;
        uint64_t v50 = 0;
LABEL_97:
        if (__D)
        {
          uint64_t v132 = (uint64_t)__D;
          operator delete(__D);
        }
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if (v148)
        {
          BOOL v149 = (void **)v148;
          operator delete(v148);
        }
        goto LABEL_103;
      }
      uint64_t v50 = 0;
    }
    else
    {
      long long v112 = IR::getIRDataLog(IsReachable);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
      {
        IR::IRDataLoader::writeIRFile(v112, v113, v114, v115, v116, v117, v118, v119);
        uint64_t v103 = __stream;
        uint64_t v50 = 4294956425;
        goto LABEL_97;
      }
      uint64_t v50 = 4294956425;
    }
    uint64_t v103 = __stream;
    goto LABEL_97;
  }
  std::string::size_type v104 = IR::getIRDataLog(0);
  if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
  {
    IR::IRDataLoader::writeIRFile(v104, v105, v106, v107, v108, v109, v110, v111);
    uint64_t v103 = __stream;
    uint64_t v50 = 4294956418;
  }
  else
  {
    uint64_t v50 = 4294956418;
    uint64_t v103 = __stream;
  }
LABEL_103:
  applesauce::CF::DictionaryRef::~DictionaryRef(&propertyList);
  applesauce::CF::ArrayRef::~ArrayRef((const void **)&v136);
  long long v148 = (UInt8 *)v139;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v148);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&v140);
  if (v103) {
    fclose(v103);
  }
  return v50;
}

void sub_21B5160CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, FILE *a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,const void *a35,const void *a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,uint64_t a44,uint64_t a45,const void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,char a53,uint64_t a54,void **a55,void **a56)
{
  if (__p) {
    operator delete(__p);
  }
  if (a37)
  {
    a38 = (uint64_t)a37;
    operator delete(a37);
  }
  if (a55)
  {
    a56 = a55;
    operator delete(a55);
  }
  applesauce::CF::DictionaryRef::~DictionaryRef(&a35);
  applesauce::CF::ArrayRef::~ArrayRef(&a36);
  a55 = (void **)&a43;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](&a55);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a46);
  if (a18) {
    fclose(a18);
  }
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::IRDataLoader(IR::IRDataLoader *this)
{
  *(void *)this = 0;
  operator new();
}

void sub_21B5163A0(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v2, 0x10A0C40E6A02A0DLL);
  std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::~IRDataLoader(IR::IRDataLoader::Implementation **this)
{
}

{
  std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0);
}

void *IR::IRDataLoader::instance(IR::IRDataLoader *this)
{
  {
    IR::IRDataLoader::IRDataLoader((IR::IRDataLoader *)&IR::IRDataLoader::instance(void)::global);
  }
  return &IR::IRDataLoader::instance(void)::global;
}

void sub_21B516494(_Unwind_Exception *a1)
{
}

void IR::IRDataLoader::load(uint64_t *a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X3>, _OWORD *a5@<X8>, float a6@<S0>)
{
  uint64_t v11 = *a1;
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  IR::IRDataLoader::Implementation::load(v11, (uint64_t)__p, a2, a3, a4, (uint64_t *)&v14, a6);
  *a5 = v14;
  long long v14 = 0uLL;
  if (v13 < 0) {
    operator delete(__p[0]);
  }
}

void sub_21B51654C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void IR::IRDataLoader::load(uint64_t *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t *a6@<X8>, float a7@<S0>)
{
}

void IR::IRDataLoader::load(uint64_t *a1@<X0>, uint64_t a2@<X1>, const void **a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v9 = *a1;
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  CFTypeRef v10 = *a3;
  if (v10) {
    CFRetain(v10);
  }
  uint64_t v11 = v10;
  IR::IRDataLoader::Implementation::load(v9, (uint64_t)__p, a2, &v11, a4, (uint64_t *)&v14);
  *a5 = v14;
  long long v14 = 0uLL;
  if (v10) {
    CFRelease(v10);
  }
  if (v13 < 0) {
    operator delete(__p[0]);
  }
}

void sub_21B516628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::load(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v10 = *a1;
  CFTypeRef v11 = *a4;
  if (*a4) {
    CFRetain(*a4);
  }
  CFTypeRef v12 = v11;
  IR::IRDataLoader::Implementation::load(v10, a2, a3, &v12, a5, a6);
  if (v11) {
    CFRelease(v11);
  }
}

void sub_21B5166D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DataRef::~DataRef((const void **)va);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::getLoadedIR(uint64_t **this@<X0>, const IR::IRDataAttributes *a2@<X1>, uint64_t *a3@<X8>)
{
}

void IR::IRDataLoader::create(uint64_t *a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, float a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, unsigned __int8 a14, int a15, int a16)
{
  uint64_t v20 = *a1;
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  IR::IRDataLoader::Implementation::create(a9, v20, (uint64_t)__p, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14, a15, a16);
}

void sub_21B5167F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void IR::IRDataLoader::create(uint64_t *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, float a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, unsigned __int8 a15, int a16, int a17)
{
}

uint64_t IR::IRDataLoader::getFilterLength(IR::IRDataLoader::Implementation **a1, int a2, float a3)
{
  return IR::IRDataLoader::Implementation::getFilterLength(*a1, a2, a3);
}

uint64_t IR::IRDataLoader::getFilterLength(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
  return IR::IRDataLoader::Implementation::getFilterLength(*this, a2);
}

uint64_t IR::IRDataLoader::getNumSpatialPoints(IR::IRDataLoader::Implementation **a1, int a2, float a3)
{
  return IR::IRDataLoader::Implementation::getNumSpatialPoints(*a1, a2, a3);
}

uint64_t IR::IRDataLoader::getNumSpatialPoints(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
  return IR::IRDataLoader::Implementation::getNumSpatialPoints(*this, a2);
}

uint64_t IR::IRDataLoader::getNumFiltersPerSpatialPoint(IR::IRDataLoader::Implementation **a1, int a2, float a3)
{
  return IR::IRDataLoader::Implementation::getNumFiltersPerSpatialPoint(*a1, a2, a3);
}

uint64_t IR::IRDataLoader::getNumFiltersPerSpatialPoint(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
  return IR::IRDataLoader::Implementation::getNumFiltersPerSpatialPoint(*this, a2);
}

uint64_t IR::IRDataLoader::getModelingDelay(IR::IRDataLoader::Implementation **a1, int a2, float a3)
{
  return IR::IRDataLoader::Implementation::getModelingDelay(*a1, a2, a3);
}

uint64_t IR::IRDataLoader::getModelingDelay(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
  return IR::IRDataLoader::Implementation::getModelingDelay(*this, a2);
}

void IR::IRDataLoader::getUserData(const IR::IRDataAttributes ***a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

void IR::IRDataLoader::getUserData(const IR::IRDataAttributes ***this@<X0>, const IR::IRDataAttributes *a2@<X1>, void *a3@<X8>)
{
}

void IR::IRDataLoader::getGlobalUserData(IR::IRDataLoader::Implementation **a1, int a2)
{
}

void IR::IRDataLoader::getGlobalUserData(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
}

void IR::IRDataLoader::getIRDataTypes(IR::IRDataLoader::Implementation **a1, int a2)
{
}

void IR::IRDataLoader::getIRDataTypes(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
}

uint64_t IR::IRDataLoader::getAudioChannelLayoutTag(IR::IRDataLoader::Implementation **a1, int a2)
{
  return IR::IRDataLoader::Implementation::getAudioChannelLayoutTag(*a1, a2);
}

uint64_t IR::IRDataLoader::getAudioChannelLayoutTag(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
  return IR::IRDataLoader::Implementation::getAudioChannelLayoutTag(*this, a2, 0);
}

uint64_t IR::IRDataLoader::getAudioChannelLayoutTag(CFTypeRef a1, CFTypeRef *a2)
{
  CFTypeRef v2 = *a2;
  if (*a2) {
    a1 = CFRetain(*a2);
  }
  CFTypeRef v5 = v2;
  uint64_t AudioChannelLayoutTag = IR::IRDataLoader::Implementation::getAudioChannelLayoutTag((uint64_t)a1, &v5);
  if (v2) {
    CFRelease(v2);
  }
  return AudioChannelLayoutTag;
}

void sub_21B516930(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::URLRef::~URLRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t IR::IRDataLoader::getOriginalAudioChannelLayoutTag(IR::IRDataLoader::Implementation **this, const IR::IRDataAttributes *a2)
{
  return IR::IRDataLoader::Implementation::getAudioChannelLayoutTag(*this, a2, 1);
}

uint64_t IR::IRDataLoader::isConsolidatedIR(IR::IRDataLoader *this, const IR::IRDataAttributes *a2)
{
  return IR::IRData::isConsolidatedIR(a2, a2);
}

uint64_t IR::IRDataLoader::hasType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IR::IRData::hasType(a2, a3);
}

BOOL IR::IRDataLoader::fileExists(uint64_t *a1, int a2)
{
  return IR::IRDataLoader::Implementation::fileExists(*a1, a2);
}

BOOL IR::IRDataLoader::fileExists(CFTypeRef a1, CFTypeRef *a2)
{
  CFTypeRef v2 = *a2;
  if (*a2) {
    a1 = CFRetain(*a2);
  }
  CFTypeRef v5 = v2;
  BOOL v3 = IR::IRDataLoader::Implementation::fileExists((uint64_t)a1, &v5);
  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

void sub_21B5169D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::URLRef::~URLRef((const void **)va);
  _Unwind_Resume(a1);
}

void IR::IRDataLoader::rebuildPersonalizedHRTFCache(IR::IRDataLoader::Implementation **this)
{
}

BOOL IR::IRDataLoader::hasFailedToFetchPersonalizedHRTF(IR::IRDataLoader::Implementation **this)
{
  return IR::IRDataLoader::Implementation::hasFailedToFetchPersonalizedHRTF(*this);
}

uint64_t IR::IRDataLoader::checkIfPersonalizedHRTFIsAllowed(IR::PersonalizedIRData::Implementation ***this)
{
  return IR::IRDataLoader::Implementation::checkIfPersonalizedHRTFIsAllowed(*this);
}

void IR::IRDataLoader::addToPersonalizedHRTFCallbackPool(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  v8[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = *a1;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::__value_func[abi:ne180100]((uint64_t)v8, a3);
  IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(v6, (char *)&__p, (uint64_t)v8, a4, 0);
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_21B516ACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void IR::IRDataLoader::addPersonalizedHRTFListenerCallback(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v4 = *a1;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  std::__function::__value_func<void ()(BOOL,BOOL)>::__value_func[abi:ne180100]((uint64_t)v7, a3);
  uint64_t v9 = 0;
  CFTypeRef v5 = operator new(0x28uLL);
  *CFTypeRef v5 = &unk_26CB57BA8;
  std::__function::__value_func<void ()(BOOL,BOOL)>::__value_func[abi:ne180100]((uint64_t)(v5 + 1), (uint64_t)v7);
  uint64_t v9 = v5;
  IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(v4, (char *)&__p, (uint64_t)v8, 0, 1);
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100](v7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_21B516C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void IR::IRDataLoader::removeFromPersonalizedHRTFCallbackPool(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  IR::IRDataLoader::Implementation::removeFromPersonalizedHRTFCallbackPool(v2, (unsigned __int8 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_21B516CB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void IR::IRDataLoader::removePersonalizedHRTFListenerCallback(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  IR::IRDataLoader::Implementation::removeFromPersonalizedHRTFCallbackPool(v2, (unsigned __int8 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_21B516D40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::IRDataLoader::getPersonalizedHRTFCacheStatus(IR::IRDataLoader::Implementation **this)
{
  return IR::IRDataLoader::Implementation::getPersonalizedHRTFCacheStatus(*this);
}

unint64_t IR::IRDataLoader::getPersonalizedHRTFStatus(IR::IRDataLoader::Implementation **this)
{
  PersonalizedHRTFCacheuint64_t Status = IR::IRDataLoader::Implementation::getPersonalizedHRTFCacheStatus(*this);
  return PersonalizedHRTFCacheStatus & 1 | ((unint64_t)(HIDWORD(PersonalizedHRTFCacheStatus) == 0) << 8);
}

void IR::IRDataLoader::clearPersonalizedIRDataCache(IR::IRDataLoader::Implementation **this)
{
}

void IR::IRDataLoader::addIRDataToCache(uint64_t *a1, IR::IRDataAttributes *a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  uint64_t v6 = *(std::__shared_weak_count **)(a3 + 8);
  uint64_t v7 = *(IR::IRData **)a3;
  CFTypeRef v8 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  IR::IRDataLoader::Implementation::addIRDataToCache(v5, (uint64_t *)__p, a2, &v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_21B516E2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void IR::IRDataLoader::addIRDataToCache(uint64_t *a1, uint64_t *a2, IR::IRDataAttributes *a3, IR::IRData **a4)
{
}

void *IR::IRDataLoader::getCustomLayoutFromTag@<X0>(IR::IRDataLoader::Implementation **this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  return IR::IRDataLoader::Implementation::getCustomLayoutFromTag(*this, a2, a3);
}

uint64_t IR::IRDataLoader::registerCustomLayoutIfNecessary(IR::IRDataLoader::Implementation **this, const AudioChannelLayout *a2)
{
  return IR::IRDataLoader::Implementation::registerCustomLayoutIfNecessary(*this, a2);
}

void std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (IR::IRDataAttributes *)**a1;
  if (v2)
  {
    uint64_t v4 = (IR::IRDataAttributes *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v4 = (IR::IRDataAttributes *)((char *)v4 - 168);
        std::__destroy_at[abi:ne180100]<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>,0>(v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>,0>(IR::IRDataAttributes *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  IR::IRDataAttributes::~IRDataAttributes(this);
}

uint64_t *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>::operator=[abi:ne180100](a3, v4);
      v4 += 21;
      a3 += 21;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t *std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  long long v4 = *(_OWORD *)(a2 + 1);
  long long v5 = *(_OWORD *)(a2 + 3);
  long long v6 = *(_OWORD *)(a2 + 5);
  *((unsigned char *)a1 + 56) = *((unsigned char *)a2 + 56);
  *(_OWORD *)(a1 + 5) = v6;
  *(_OWORD *)(a1 + 3) = v5;
  *(_OWORD *)(a1 + 1) = v4;
  uint64_t v7 = a1[8];
  a1[8] = a2[8];
  a2[8] = v7;
  *(_OWORD *)(a1 + 9) = *(_OWORD *)(a2 + 9);
  uint64_t v8 = a1[11];
  a1[11] = a2[11];
  a2[11] = v8;
  long long v9 = *((_OWORD *)a2 + 6);
  *(_OWORD *)((char *)a1 + 105) = *(_OWORD *)((char *)a2 + 105);
  *((_OWORD *)a1 + 6) = v9;
  uint64_t v10 = a1[16];
  a1[16] = a2[16];
  a2[16] = v10;
  uint64_t v11 = a2[17];
  *((_DWORD *)a1 + 36) = *((_DWORD *)a2 + 36);
  a1[17] = v11;
  long long v12 = *(_OWORD *)(a2 + 19);
  a2[19] = 0;
  a2[20] = 0;
  char v13 = (std::__shared_weak_count *)a1[20];
  *(_OWORD *)(a1 + 19) = v12;
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  return a1;
}

BOOL applesauce::CF::operator==(const void **a1, const void **a2)
{
  unint64_t v2 = (unint64_t)*a1;
  unint64_t v3 = (unint64_t)*a2;
  BOOL v4 = (v2 | v3) == 0;
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    return CFEqual((CFTypeRef)v2, (CFTypeRef)v3) != 0;
  }
  return v4;
}

uint64_t IR::IRDataAttributes::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(const void **)a1;
  if (!(*(void *)a1 | *(void *)a2)) {
    return 1;
  }
  if (*(float *)(a1 + 8) != *(float *)(a2 + 8)
    || *(unsigned __int8 *)(a1 + 16) != *(unsigned __int8 *)(a2 + 16)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)
    || *(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28)
    || *(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32)
    || *(_DWORD *)(a1 + 36) != *(_DWORD *)(a2 + 36))
  {
    return 0;
  }
  uint64_t result = 0;
  if (v2)
  {
    if (*(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20))
    {
      if (*(void *)a2)
      {
        uint64_t result = applesauce::CF::operator==((const void **)a1, (const void **)a2);
        if (result)
        {
          uint64_t v6 = *(void *)(a2 + 64);
          if (*(void *)(a1 + 64))
          {
            if (!v6) {
              return 0;
            }
            uint64_t result = applesauce::CF::operator==((const void **)(a1 + 64), (const void **)(a2 + 64));
            if (!result) {
              return result;
            }
          }
          else if (v6)
          {
            return 0;
          }
          if (*(_DWORD *)(a1 + 72) == *(_DWORD *)(a2 + 72)
            && *(_DWORD *)(a1 + 76) == *(_DWORD *)(a2 + 76)
            && *(_DWORD *)(a1 + 80) == *(_DWORD *)(a2 + 80)
            && *(_DWORD *)(a1 + 84) == *(_DWORD *)(a2 + 84))
          {
            uint64_t v7 = *(void *)(a2 + 88);
            if (*(void *)(a1 + 88))
            {
              if (v7)
              {
                uint64_t result = applesauce::CF::operator==((const void **)(a1 + 88), (const void **)(a2 + 88));
                if (!result) {
                  return result;
                }
                goto LABEL_28;
              }
            }
            else if (!v7)
            {
LABEL_28:
              if (*(_DWORD *)(a1 + 100) == *(_DWORD *)(a2 + 100)
                && *(_DWORD *)(a1 + 104) == *(_DWORD *)(a2 + 104)
                && *(_DWORD *)(a1 + 44) == *(_DWORD *)(a2 + 44)
                && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a2 + 48)
                && *(float *)(a1 + 116) == *(float *)(a2 + 116)
                && *(_DWORD *)(a1 + 40) == *(_DWORD *)(a2 + 40)
                && *(float *)(a1 + 136) == *(float *)(a2 + 136)
                && *(float *)(a1 + 140) == *(float *)(a2 + 140)
                && *(_DWORD *)(a1 + 144) == *(_DWORD *)(a2 + 144)
                && *(unsigned __int8 *)(a1 + 17) == *(unsigned __int8 *)(a2 + 17))
              {
                return *(unsigned __int8 *)(a1 + 120) == *(unsigned __int8 *)(a2 + 120);
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t IR::IRDataAttributes::equalsExceptSampleRate(IR::IRDataAttributes *this, const IR::IRDataAttributes *a2)
{
  IR::IRDataAttributes::IRDataAttributes((IR::IRDataAttributes *)&v5, this);
  int v6 = *((_DWORD *)a2 + 2);
  uint64_t v3 = IR::IRDataAttributes::operator==((uint64_t)&v5, (uint64_t)a2);
  if (cf) {
    CFRelease(cf);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v5) {
    CFRelease(v5);
  }
  return v3;
}

void sub_21B51734C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator=[abi:ne180100](void *a1, uint64_t a2)
{
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator=[abi:ne180100](a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator=[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__emplace_back_slow_path<IR::IRDataAttributes&,std::shared_ptr<IR::IRData const> const&>(uint64_t *a1, const IR::IRDataAttributes *a2, void *a3)
{
  uint64_t v4 = *a1;
  unint64_t v5 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x186186186186186) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0xC30C30C30C30C3) {
    unint64_t v11 = 0x186186186186186;
  }
  else {
    unint64_t v11 = v6;
  }
  uint64_t v21 = a1 + 2;
  if (v11) {
    long long v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>>(v9, v11);
  }
  else {
    long long v12 = 0;
  }
  uint64_t v17 = v12;
  uint64_t v18 = (IR::IRDataAttributes *)&v12[168 * v5];
  uint64_t v20 = &v12[168 * v11];
  char v13 = IR::IRDataAttributes::IRDataAttributes(v18, a2);
  *((void *)v13 + 19) = *a3;
  uint64_t v14 = a3[1];
  *((void *)v13 + 2std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = (char *)v13 + 168;
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__swap_out_circular_buffer(a1, &v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::~__split_buffer((uint64_t)&v17);
  return v15;
}

void sub_21B517598(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>,std::reverse_iterator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>*>,std::reverse_iterator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>*>,std::reverse_iterator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(168 * a2);
}

__n128 std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>,std::reverse_iterator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>*>,std::reverse_iterator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>*>,std::reverse_iterator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v8 = a7 - 80;
    do
    {
      uint64_t v9 = *(void *)(a3 - 168);
      a3 -= 168;
      *(void *)(v8 - 88) = v9;
      *(void *)a3 = 0;
      long long v10 = *(_OWORD *)(a3 + 8);
      long long v11 = *(_OWORD *)(a3 + 24);
      long long v12 = *(_OWORD *)(a3 + 40);
      *(unsigned char *)(v8 - 32) = *(unsigned char *)(a3 + 56);
      *(_OWORD *)(v8 - 64) = v11;
      *(_OWORD *)(v8 - 48) = v12;
      *(_OWORD *)(v8 - 8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v10;
      *(void *)(v8 - 24) = *(void *)(a3 + 64);
      *(void *)(a3 + 64) = 0;
      *(_OWORD *)(v8 - 16) = *(_OWORD *)(a3 + 72);
      *(void *)uint64_t v8 = *(void *)(a3 + 88);
      *(void *)(a3 + 88) = 0;
      long long v13 = *(_OWORD *)(a3 + 96);
      *(_OWORD *)(v8 + 17) = *(_OWORD *)(a3 + 105);
      *(_OWORD *)(v8 + 8) = v13;
      *(void *)(v8 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = *(void *)(a3 + 128);
      *(void *)(a3 + 128) = 0;
      uint64_t v14 = *(void *)(a3 + 136);
      *(_DWORD *)(v8 + 56) = *(_DWORD *)(a3 + 144);
      *(void *)(v8 + 48) = v14;
      __n128 result = *(__n128 *)(a3 + 152);
      *(__n128 *)(v8 + 64) = result;
      *(void *)(a3 + 152) = 0;
      *(void *)(a3 + 16std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
      v8 -= 168;
      v7 -= 168;
    }
    while (a3 != a5);
  }
  return result;
}

uint64_t std::__split_buffer<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 168;
    std::__destroy_at[abi:ne180100]<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>,0>((IR::IRDataAttributes *)(i - 168));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__emplace_back_slow_path<IR::IRDataAttributes const&,std::shared_ptr<IR::IRData const> const&>(uint64_t *a1, const IR::IRDataAttributes *a2, void *a3)
{
  uint64_t v4 = *a1;
  unint64_t v5 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x186186186186186) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0xC30C30C30C30C3) {
    unint64_t v11 = 0x186186186186186;
  }
  else {
    unint64_t v11 = v6;
  }
  uint64_t v21 = a1 + 2;
  if (v11) {
    long long v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>>(v9, v11);
  }
  else {
    long long v12 = 0;
  }
  uint64_t v17 = v12;
  uint64_t v18 = (IR::IRDataAttributes *)&v12[168 * v5];
  uint64_t v20 = &v12[168 * v11];
  long long v13 = IR::IRDataAttributes::IRDataAttributes(v18, a2);
  *((void *)v13 + 19) = *a3;
  uint64_t v14 = a3[1];
  *((void *)v13 + 2std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = (char *)v13 + 168;
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__swap_out_circular_buffer(a1, &v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::~__split_buffer((uint64_t)&v17);
  return v15;
}

void sub_21B517894(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<char>::__init_with_size[abi:ne180100]<char *,char *>(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    unint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21B517908(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](this, __n);
    std::vector<char>::pointer end = this->__end_;
    unint64_t v5 = &end[__n];
    bzero(end, __n);
    this->__end_ = v5;
  }
  return this;
}

void sub_21B51797C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::map<IR::IRSphericalInterpolation,std::string>::at(uint64_t a1, int *a2)
{
  unint64_t v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 8);
      if (v3 >= v4) {
        break;
      }
      unint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 5;
    }
    unint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

void IR::IRDataWindow::description(IR::IRDataWindow *this@<X0>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v29, "start: ");
  std::to_string(&v28, *(_DWORD *)this);
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v4 = &v28;
  }
  else {
    int v4 = (std::string *)v28.__r_.__value_.__r.__words[0];
  }
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v28.__r_.__value_.__l.__size_;
  }
  unint64_t v6 = std::string::append(&v29, (const std::string::value_type *)v4, size);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  size_t v8 = std::string::append(&v30, ", fade-in: ", 0xBuLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v31.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v27, *((_DWORD *)this + 1));
  if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v10 = &v27;
  }
  else {
    unint64_t v10 = (std::string *)v27.__r_.__value_.__r.__words[0];
  }
  if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v11 = HIBYTE(v27.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v11 = v27.__r_.__value_.__l.__size_;
  }
  long long v12 = std::string::append(&v31, (const std::string::value_type *)v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v32.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  uint64_t v14 = std::string::append(&v32, ", length: ", 0xAuLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v26, *((_DWORD *)this + 2));
  if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v16 = &v26;
  }
  else {
    uint64_t v16 = (std::string *)v26.__r_.__value_.__r.__words[0];
  }
  if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = v26.__r_.__value_.__l.__size_;
  }
  uint64_t v18 = std::string::append(&v33, (const std::string::value_type *)v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  uint64_t v20 = std::string::append(&v34, ", fade-out: ", 0xCuLL);
  long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v25, *((_DWORD *)this + 3));
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v22 = &v25;
  }
  else {
    uint64_t v22 = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v23 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v23 = v25.__r_.__value_.__l.__size_;
  }
  uint64_t v24 = std::string::append(&v35, (const std::string::value_type *)v22, v23);
  *a2 = *v24;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
}

void sub_21B517C94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v52 - 57) < 0) {
    operator delete(*(void **)(v52 - 80));
  }
  if (*(char *)(v52 - 89) < 0) {
    operator delete(*(void **)(v52 - 112));
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v52 - 121) < 0) {
    operator delete(*(void **)(v52 - 144));
  }
  if (*(char *)(v52 - 153) < 0) {
    operator delete(*(void **)(v52 - 176));
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  _Unwind_Resume(exception_object);
}

void sub_21B517D90()
{
}

void sub_21B517D98()
{
}

void IR::PersonalizedHRIRFetchingParams::description(IR::PersonalizedHRIRFetchingParams *this@<X0>, std::string *a2@<X8>)
{
  v36[4] = *MEMORY[0x263EF8340];
  LODWORD(v30.__r_.__value_.__l.__data_) = 0;
  std::string::basic_string[abi:ne180100]<0>(&v30.__r_.__value_.__l.__size_, "kPersonalizedHRIRType_NoPersonalization");
  int v31 = 1;
  std::string::basic_string[abi:ne180100]<0>(v32, "kPersonalizedHRIRType_General");
  int v33 = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "kPersonalizedHRIRType_Movie");
  int v35 = 3;
  std::string::basic_string[abi:ne180100]<0>(v36, "kPersonalizedHRIRType_NumTypes");
  std::map<PersonalizedHRIRType,std::string>::map[abi:ne180100]((uint64_t)v28, (int *)&v30, 4);
  for (uint64_t i = 0; i != -16; i -= 4)
  {
    if (SHIBYTE(v36[i + 2]) < 0) {
      operator delete((void *)v36[i]);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&v24, "type: ");
  unint64_t v5 = std::map<IR::IRSphericalInterpolation,std::string>::at((uint64_t)v28, (int *)this);
  int v6 = *((char *)v5 + 23);
  if (v6 >= 0) {
    long long v7 = (const std::string::value_type *)v5;
  }
  else {
    long long v7 = (const std::string::value_type *)*v5;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *((unsigned __int8 *)v5 + 23);
  }
  else {
    std::string::size_type v8 = v5[1];
  }
  long long v9 = std::string::append(&v24, v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  std::string::size_type v11 = std::string::append(&v25, ", timeoutMS: ", 0xDuLL);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v23, *((_DWORD *)this + 1));
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v13 = &v23;
  }
  else {
    long long v13 = (std::string *)v23.__r_.__value_.__r.__words[0];
  }
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v23.__r_.__value_.__l.__size_;
  }
  long long v15 = std::string::append(&v26, (const std::string::value_type *)v13, size);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v27.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  std::string::size_type v17 = std::string::append(&v27, ", allowExternalAPIAccess: ", 0x1AuLL);
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v22, *((unsigned __int8 *)this + 8));
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v19 = &v22;
  }
  else {
    long long v19 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v20 = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v20 = v22.__r_.__value_.__l.__size_;
  }
  long long v21 = std::string::append(&v30, (const std::string::value_type *)v19, v20);
  *a2 = *v21;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy((uint64_t)v28, v29);
}

void sub_21B518070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,char a48,char *a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy((uint64_t)&a48, a49);
  _Unwind_Resume(a1);
}

void IR::FFTFilterOptimizationParameters::description(IR::FFTFilterOptimizationParameters *this@<X0>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v22, "absoluteThreshold: ");
  std::to_string(&v21, *(float *)this);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v4 = &v21;
  }
  else {
    int v4 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v21.__r_.__value_.__l.__size_;
  }
  int v6 = std::string::append(&v22, (const std::string::value_type *)v4, size);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::string::size_type v8 = std::string::append(&v23, ", relativeThreshold: ", 0x15uLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v20, *((float *)this + 1));
  if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v10 = &v20;
  }
  else {
    long long v10 = (std::string *)v20.__r_.__value_.__r.__words[0];
  }
  if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v11 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v11 = v20.__r_.__value_.__l.__size_;
  }
  long long v12 = std::string::append(&v24, (const std::string::value_type *)v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  uint64_t v14 = std::string::append(&v25, ", maxNumBins: ", 0xEuLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *((_DWORD *)this + 2));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = __p.__r_.__value_.__l.__size_;
  }
  long long v18 = std::string::append(&v26, (const std::string::value_type *)p_p, v17);
  *a2 = *v18;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
}

void sub_21B518388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v45 - 41) < 0) {
    operator delete(*(void **)(v45 - 64));
  }
  if (*(char *)(v45 - 73) < 0) {
    operator delete(*(void **)(v45 - 96));
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::map<IR::IRSphericalInterpolation,std::string>::map[abi:ne180100](uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  int v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__emplace_hint_unique_key_args<IR::IRSphericalInterpolation,std::pair<IR::IRSphericalInterpolation const,std::string> const&>((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_21B5184B4(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__emplace_hint_unique_key_args<IR::IRSphericalInterpolation,std::pair<IR::IRSphericalInterpolation const,std::string> const&>(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__find_equal<IR::IRSphericalInterpolation>(a1, a2, &v10, &v9, a3);
  __n128 result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__construct_node<std::pair<IR::IRSphericalInterpolation const,std::string> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<int>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__find_equal<IR::IRSphericalInterpolation>(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  unint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (int v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    std::string::size_type v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      long long v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        long long v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      long long v13 = a2;
      do
      {
        long long v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        long long v13 = v10;
      }
      while (v14);
    }
    int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          std::string::size_type v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          unint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        unint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      std::string::size_type v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    long long v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      long long v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    long long v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      long long v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          std::string v21 = (uint64_t *)v20;
          int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          unint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        unint64_t v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      std::string v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__construct_node<std::pair<IR::IRSphericalInterpolation const,std::string> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = (char *)operator new(0x40uLL);
  *(void *)(a3 + 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = *(_DWORD *)a2;
  int v7 = (std::string *)(v6 + 40);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 8);
    v7->__r_.__value_.__r.__words[2] = *(void *)(a2 + 24);
  }
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_21B518788(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<IR::IRSphericalInterpolation,std::string>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<IR::IRSphericalInterpolation,std::string>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 63) < 0) {
      operator delete(__p[5]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[63] < 0) {
      operator delete(*((void **)a2 + 5));
    }
    operator delete(a2);
  }
}

uint64_t std::map<IR::IRDataType,std::string>::map[abi:ne180100](uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  int v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      std::__tree<std::__value_type<IR::IRDataType,std::string>,std::__map_value_compare<IR::IRDataType,std::__value_type<IR::IRDataType,std::string>,std::less<IR::IRDataType>,true>,std::allocator<std::__value_type<IR::IRDataType,std::string>>>::__emplace_hint_unique_key_args<IR::IRDataType,std::pair<IR::IRDataType const,std::string> const&>((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_21B5188D0(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<IR::IRDataType,std::string>,std::__map_value_compare<IR::IRDataType,std::__value_type<IR::IRDataType,std::string>,std::less<IR::IRDataType>,true>,std::allocator<std::__value_type<IR::IRDataType,std::string>>>::__emplace_hint_unique_key_args<IR::IRDataType,std::pair<IR::IRDataType const,std::string> const&>(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__find_equal<IR::IRSphericalInterpolation>(a1, a2, &v10, &v9, a3);
  __n128 result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<IR::IRDataType,std::string>,std::__map_value_compare<IR::IRDataType,std::__value_type<IR::IRDataType,std::string>,std::less<IR::IRDataType>,true>,std::allocator<std::__value_type<IR::IRDataType,std::string>>>::__construct_node<std::pair<IR::IRDataType const,std::string> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<int>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::__value_type<IR::IRDataType,std::string>,std::__map_value_compare<IR::IRDataType,std::__value_type<IR::IRDataType,std::string>,std::less<IR::IRDataType>,true>,std::allocator<std::__value_type<IR::IRDataType,std::string>>>::__construct_node<std::pair<IR::IRDataType const,std::string> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)(a3 + 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = *(_DWORD *)a2;
  int v7 = (std::string *)(v6 + 40);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 8);
    v7->__r_.__value_.__r.__words[2] = *(void *)(a2 + 24);
  }
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_21B5189FC(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<IR::IRSphericalInterpolation,std::string>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
}

void sub_21B518A60(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  __n128 result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C390] + 16);
  return result;
}

uint64_t std::map<PersonalizedHRIRType,std::string>::map[abi:ne180100](uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  int v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      std::__tree<std::__value_type<PersonalizedHRIRType,std::string>,std::__map_value_compare<PersonalizedHRIRType,std::__value_type<PersonalizedHRIRType,std::string>,std::less<PersonalizedHRIRType>,true>,std::allocator<std::__value_type<PersonalizedHRIRType,std::string>>>::__emplace_hint_unique_key_args<PersonalizedHRIRType,std::pair<PersonalizedHRIRType const,std::string> const&>((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_21B518B10(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<PersonalizedHRIRType,std::string>,std::__map_value_compare<PersonalizedHRIRType,std::__value_type<PersonalizedHRIRType,std::string>,std::less<PersonalizedHRIRType>,true>,std::allocator<std::__value_type<PersonalizedHRIRType,std::string>>>::__emplace_hint_unique_key_args<PersonalizedHRIRType,std::pair<PersonalizedHRIRType const,std::string> const&>(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<std::__value_type<IR::IRSphericalInterpolation,std::string>,std::__map_value_compare<IR::IRSphericalInterpolation,std::__value_type<IR::IRSphericalInterpolation,std::string>,std::less<IR::IRSphericalInterpolation>,true>,std::allocator<std::__value_type<IR::IRSphericalInterpolation,std::string>>>::__find_equal<IR::IRSphericalInterpolation>(a1, a2, &v10, &v9, a3);
  __n128 result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<PersonalizedHRIRType,std::string>,std::__map_value_compare<PersonalizedHRIRType,std::__value_type<PersonalizedHRIRType,std::string>,std::less<PersonalizedHRIRType>,true>,std::allocator<std::__value_type<PersonalizedHRIRType,std::string>>>::__construct_node<std::pair<PersonalizedHRIRType const,std::string> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<int>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

void std::__tree<std::__value_type<PersonalizedHRIRType,std::string>,std::__map_value_compare<PersonalizedHRIRType,std::__value_type<PersonalizedHRIRType,std::string>,std::less<PersonalizedHRIRType>,true>,std::allocator<std::__value_type<PersonalizedHRIRType,std::string>>>::__construct_node<std::pair<PersonalizedHRIRType const,std::string> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)(a3 + 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = *(_DWORD *)a2;
  int v7 = (std::string *)(v6 + 40);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 8);
    v7->__r_.__value_.__r.__words[2] = *(void *)(a2 + 24);
  }
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_21B518C3C(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<IR::IRSphericalInterpolation,std::string>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorIfNS_9allocatorIfEEEES6_bEEC2B8ne180100IJLm0ELm1ELm2EEJS6_S6_bEJEJEJRS6_S9_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSB_IJDpT2_EEEDpOT3_(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)(a1 + 24), *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  *(unsigned char *)(a1 + 48) = *a4;
  return a1;
}

void sub_21B518CCC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorIfNS_9allocatorIfEEEES6_bEEC2B8ne180100IJLm0ELm1ELm2EEJS6_S6_bEJEJEJRKS6_SA_RKbEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSE_IJDpT2_EEEDpOT3_(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)(a1 + 24), *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  *(unsigned char *)(a1 + 48) = *a4;
  return a1;
}

void sub_21B518D5C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__emplace_back_slow_path<IR::IRDataAttributes&,std::shared_ptr<IR::IRData const> &>(uint64_t *a1, const IR::IRDataAttributes *a2, void *a3)
{
  uint64_t v4 = *a1;
  unint64_t v5 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x186186186186186) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0xC30C30C30C30C3) {
    unint64_t v11 = 0x186186186186186;
  }
  else {
    unint64_t v11 = v6;
  }
  std::string v21 = a1 + 2;
  if (v11) {
    long long v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>>(v9, v11);
  }
  else {
    long long v12 = 0;
  }
  std::string::size_type v17 = v12;
  int v18 = (IR::IRDataAttributes *)&v12[168 * v5];
  uint64_t v20 = &v12[168 * v11];
  long long v13 = IR::IRDataAttributes::IRDataAttributes(v18, a2);
  *((void *)v13 + 19) = *a3;
  uint64_t v14 = a3[1];
  *((void *)v13 + 2std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
  }
  long long v19 = (char *)v13 + 168;
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__swap_out_circular_buffer(a1, &v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::~__split_buffer((uint64_t)&v17);
  return v15;
}

void sub_21B518EA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

IR::HOA2BinauralIRRenderer *IR::HOA2BinauralIRRenderer::HOA2BinauralIRRenderer(IR::HOA2BinauralIRRenderer *this, const IR::IRDataAttributes *a2, const IR::IRDataAttributes *a3, int a4)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  std::string::size_type v8 = operator new(4uLL);
  *((void *)this + 3) = v8;
  *v8++ = 2;
  *((void *)this + 4) = v8;
  *((void *)this + 5) = v8;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  IR::IRDataAttributes::IRDataAttributes((IR::HOA2BinauralIRRenderer *)((char *)this + 120), a3);
  IR::IRDataAttributes::IRDataAttributes((IR::HOA2BinauralIRRenderer *)((char *)this + 272), a2);
  *((void *)this + 54) = 0;
  *((_DWORD *)this + 11std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = a4;
  *((unsigned char *)this + 46std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 1;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 3std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *((void *)this + 7std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 60std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 68std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  *(_OWORD *)((char *)this + 744) = 0u;
  *((void *)this + 95) = 0;
  *((void *)this + 106) = 0;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *((_OWORD *)this + 49) = 0u;
  *((_OWORD *)this + 5std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  return this;
}

unsigned int *std::vector<IR::IRCoordinateType>::__insert_with_size[abi:ne180100]<std::__wrap_iter<IR::IRCoordinateType*>,std::__wrap_iter<IR::IRCoordinateType*>>(std::vector<unsigned int> *a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = (unsigned int *)__dst;
  if (a5 < 1) {
    return v5;
  }
  int v7 = (unsigned int *)__src;
  uint64_t value = a1->__end_cap_.__value_;
  p_end_cap = (std::allocator<unsigned int> *)&a1->__end_cap_;
  unint64_t v10 = value;
  unint64_t v12 = *((void *)p_end_cap - 1);
  if (a5 > (uint64_t)((uint64_t)value - v12) >> 2)
  {
    std::vector<unsigned int>::pointer begin = a1->__begin_;
    unint64_t v14 = a5 + ((uint64_t)(v12 - (unint64_t)a1->__begin_) >> 2);
    if (v14 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)begin) >> 2;
    uint64_t v16 = (char *)v10 - (char *)begin;
    if (v16 >> 1 > v14) {
      unint64_t v14 = v16 >> 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    __v.__end_cap_.__value_ = p_end_cap;
    if (v17) {
      int v18 = (unsigned int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v17);
    }
    else {
      int v18 = 0;
    }
    std::string v28 = &v18[v15];
    __v.__first_ = v18;
    __v.__begin_ = v28;
    __v.__end_cap_.__value_ = &v18[v17];
    uint64_t v29 = 4 * a5;
    std::string v30 = &v28[a5];
    do
    {
      unsigned int v31 = *v7++;
      *v28++ = v31;
      v29 -= 4;
    }
    while (v29);
    __v.__end_ = v30;
    unint64_t v5 = std::vector<int>::__swap_out_circular_buffer(a1, &__v, v5);
    if (__v.__end_ != __v.__begin_) {
      __v.__end_ = (std::__split_buffer<unsigned int>::pointer)((char *)__v.__end_
    }
                                                              + (((char *)__v.__begin_ - (char *)__v.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
    if (__v.__first_) {
      operator delete(__v.__first_);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    std::string v21 = &__src[4 * a5];
    std::string v23 = (unsigned int *)*((void *)p_end_cap - 1);
LABEL_17:
    std::string v24 = &v5[a5];
    std::string v25 = &v23[-a5];
    std::string v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      std::string v26 = v23;
      do
      {
        unsigned int v27 = *v25++;
        *v26++ = v27;
      }
      while ((unint64_t)v25 < v12);
    }
    a1->__end_ = v26;
    if (v23 != v24) {
      memmove(&v23[-(v23 - v24)], v5, (char *)v23 - (char *)v24);
    }
    if (v21 != (char *)v7) {
      memmove(v5, v7, v21 - (char *)v7);
    }
    return v5;
  }
  std::string v21 = &__src[4 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*((void **)p_end_cap - 1), &__src[4 * v20], a4 - v21);
  }
  std::string v23 = (unsigned int *)(v12 + v22);
  a1->__end_ = (std::vector<unsigned int>::pointer)(v12 + v22);
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_21B519164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned int *std::vector<IR::IRInterpolationMethod>::__insert_with_size[abi:ne180100]<std::__wrap_iter<IR::IRInterpolationMethod*>,std::__wrap_iter<IR::IRInterpolationMethod*>>(std::vector<unsigned int> *a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = (unsigned int *)__dst;
  if (a5 < 1) {
    return v5;
  }
  int v7 = (unsigned int *)__src;
  uint64_t value = a1->__end_cap_.__value_;
  p_end_cap = (std::allocator<unsigned int> *)&a1->__end_cap_;
  unint64_t v10 = value;
  unint64_t v12 = *((void *)p_end_cap - 1);
  if (a5 > (uint64_t)((uint64_t)value - v12) >> 2)
  {
    std::vector<unsigned int>::pointer begin = a1->__begin_;
    unint64_t v14 = a5 + ((uint64_t)(v12 - (unint64_t)a1->__begin_) >> 2);
    if (v14 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)begin) >> 2;
    uint64_t v16 = (char *)v10 - (char *)begin;
    if (v16 >> 1 > v14) {
      unint64_t v14 = v16 >> 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    __v.__end_cap_.__value_ = p_end_cap;
    if (v17) {
      int v18 = (unsigned int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v17);
    }
    else {
      int v18 = 0;
    }
    std::string v28 = &v18[v15];
    __v.__first_ = v18;
    __v.__begin_ = v28;
    __v.__end_cap_.__value_ = &v18[v17];
    uint64_t v29 = 4 * a5;
    std::string v30 = &v28[a5];
    do
    {
      unsigned int v31 = *v7++;
      *v28++ = v31;
      v29 -= 4;
    }
    while (v29);
    __v.__end_ = v30;
    unint64_t v5 = std::vector<int>::__swap_out_circular_buffer(a1, &__v, v5);
    if (__v.__end_ != __v.__begin_) {
      __v.__end_ = (std::__split_buffer<unsigned int>::pointer)((char *)__v.__end_
    }
                                                              + (((char *)__v.__begin_ - (char *)__v.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
    if (__v.__first_) {
      operator delete(__v.__first_);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    std::string v21 = &__src[4 * a5];
    std::string v23 = (unsigned int *)*((void *)p_end_cap - 1);
LABEL_17:
    std::string v24 = &v5[a5];
    std::string v25 = &v23[-a5];
    std::string v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      std::string v26 = v23;
      do
      {
        unsigned int v27 = *v25++;
        *v26++ = v27;
      }
      while ((unint64_t)v25 < v12);
    }
    a1->__end_ = v26;
    if (v23 != v24) {
      memmove(&v23[-(v23 - v24)], v5, (char *)v23 - (char *)v24);
    }
    if (v21 != (char *)v7) {
      memmove(v5, v7, v21 - (char *)v7);
    }
    return v5;
  }
  std::string v21 = &__src[4 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*((void **)p_end_cap - 1), &__src[4 * v20], a4 - v21);
  }
  std::string v23 = (unsigned int *)(v12 + v22);
  a1->__end_ = (std::vector<unsigned int>::pointer)(v12 + v22);
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_21B519374(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  int v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 2)
  {
    long long v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 2);
    if (v14 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 2;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 1 > v14) {
      unint64_t v14 = v16 >> 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      int v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v9, v17);
    }
    else {
      int v18 = 0;
    }
    std::string v28 = &v18[4 * v15];
    std::string __p = v18;
    std::string v34 = v28;
    uint64_t v36 = &v18[4 * v17];
    uint64_t v29 = 4 * a5;
    std::string v30 = &v28[4 * a5];
    do
    {
      int v31 = *(_DWORD *)v7;
      v7 += 4;
      *(_DWORD *)std::string v28 = v31;
      v28 += 4;
      v29 -= 4;
    }
    while (v29);
    int v35 = v30;
    unint64_t v5 = std::vector<float>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    std::string v21 = &__src[4 * a5];
    std::string v23 = *(char **)(v9 - 8);
LABEL_17:
    std::string v24 = &v5[4 * a5];
    std::string v25 = &v23[-4 * a5];
    std::string v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      std::string v26 = v23;
      do
      {
        int v27 = *(_DWORD *)v25;
        v25 += 4;
        *(_DWORD *)std::string v26 = v27;
        v26 += 4;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-4 * ((v23 - v24) >> 2)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  std::string v21 = &__src[4 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[4 * v20], a4 - v21);
  }
  std::string v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_21B519584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<float *>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v6 = (void *)a1[1];
    int v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_21B519624(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void IR::HOA2BinauralIRRenderer::~HOA2BinauralIRRenderer(vDSP_DFT_Setup *this)
{
  vDSP_DFT_DestroySetup(this[73]);
  vDSP_DFT_DestroySetup(this[74]);
  unint64_t v2 = this[104];
  if (v2)
  {
    this[105] = v2;
    operator delete(v2);
  }
  uint64_t v15 = (void **)(this + 101);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v15);
  uint64_t v15 = (void **)(this + 98);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v15);
  uint64_t v3 = this[93];
  if (v3)
  {
    this[94] = v3;
    operator delete(v3);
  }
  uint64_t v4 = this[90];
  if (v4)
  {
    this[91] = v4;
    operator delete(v4);
  }
  unint64_t v5 = this[87];
  if (v5)
  {
    this[88] = v5;
    operator delete(v5);
  }
  uint64_t v15 = (void **)(this + 84);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v15);
  uint64_t v15 = (void **)(this + 81);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v15);
  uint64_t v15 = (void **)(this + 78);
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](&v15);
  uint64_t v15 = (void **)(this + 75);
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](&v15);
  unint64_t v6 = this[68];
  if (v6)
  {
    this[69] = v6;
    operator delete(v6);
  }
  int v7 = this[65];
  if (v7)
  {
    this[66] = v7;
    operator delete(v7);
  }
  uint64_t v8 = (uint64_t)this[64];
  this[64] = 0;
  if (v8) {
    std::default_delete<HOA::RotationMatrix>::operator()[abi:ne180100]((uint64_t)(this + 64), v8);
  }
  uint64_t v9 = this[61];
  if (v9)
  {
    this[62] = v9;
    operator delete(v9);
  }
  uint64_t v15 = (void **)(this + 58);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v15);
  std::unique_ptr<HOA>::reset[abi:ne180100](this + 54, 0);
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)(this + 34));
  IR::IRDataAttributes::~IRDataAttributes((IR::IRDataAttributes *)(this + 15));
  uint64_t v10 = this[12];
  if (v10)
  {
    this[13] = v10;
    operator delete(v10);
  }
  uint64_t v11 = this[9];
  if (v11)
  {
    this[10] = v11;
    operator delete(v11);
  }
  unint64_t v12 = this[6];
  if (v12)
  {
    this[7] = v12;
    operator delete(v12);
  }
  long long v13 = this[3];
  if (v13)
  {
    this[4] = v13;
    operator delete(v13);
  }
  vDSP_DFT_Setup v14 = *this;
  if (*this)
  {
    this[1] = v14;
    operator delete(v14);
  }
}

void *std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,0>(uint64_t a1)
{
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::destroy(a1, a2[1]);
    uint64_t v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

void std::allocate_shared[abi:ne180100]<IR::IRData,std::allocator<IR::IRData>,std::vector<std::vector<float>> const&,std::vector<std::vector<float>> const&,std::vector<IR::IRCoordinateType> const&,std::vector<std::vector<float>> const&,float &,unsigned int &,std::vector<float> const&,std::vector<IR::IRInterpolationMethod> const&,applesauce::CF::DictionaryRef const&,std::string const&,unsigned int &,BOOL &,unsigned int &,IR::IRSphericalInterpolation &,std::vector<float> const&,void>()
{
  uint64_t v0 = operator new(0x20uLL);
  std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<std::vector<std::vector<float>> const&,std::vector<std::vector<float>> const&,std::vector<IR::IRCoordinateType> const&,std::vector<std::vector<float>> const&,float &,unsigned int &,std::vector<float> const&,std::vector<IR::IRInterpolationMethod> const&,applesauce::CF::DictionaryRef const&,std::string const&,unsigned int &,BOOL &,unsigned int &,IR::IRSphericalInterpolation &,std::vector<float> const&,std::allocator<IR::IRData>,0>(v0);
}

void sub_21B519ABC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<std::vector<std::vector<float>> const&,std::vector<std::vector<float>> const&,std::vector<IR::IRCoordinateType> const&,std::vector<std::vector<float>> const&,float &,unsigned int &,std::vector<float> const&,std::vector<IR::IRInterpolationMethod> const&,applesauce::CF::DictionaryRef const&,std::string const&,unsigned int &,BOOL &,unsigned int &,IR::IRSphericalInterpolation &,std::vector<float> const&,std::allocator<IR::IRData>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB57468;
  IR::IRData::IRData(a1 + 3);
}

void sub_21B519B64(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<IR::IRData>::shared_ptr[abi:ne180100]<IR::IRData,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_21B519BEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<IR::IRData>::reset[abi:ne180100]((IR::IRData::Implementation ***)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<IR::IRData *,std::shared_ptr<IR::IRData>::__shared_ptr_default_delete<IR::IRData,IR::IRData>,std::allocator<IR::IRData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

IR::IRData::Implementation **std::__shared_ptr_pointer<IR::IRData *,std::shared_ptr<IR::IRData>::__shared_ptr_default_delete<IR::IRData,IR::IRData>,std::allocator<IR::IRData>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(IR::IRData::Implementation ***)(a1 + 24);
  if (result)
  {
    IR::IRData::~IRData(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

IR::IRData::Implementation **std::unique_ptr<IR::IRData>::reset[abi:ne180100](IR::IRData::Implementation ***a1, IR::IRData::Implementation **a2)
{
  __n128 result = *a1;
  *a1 = a2;
  if (result)
  {
    IR::IRData::~IRData(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

void std::__function::__func<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>>,void ()(IR::PersonalizedIRData::DataValidity)>::~__func()
{
}

__n128 std::__function::__func<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>>,void ()(IR::PersonalizedIRData::DataValidity)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_26CB57B18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>>,void ()(IR::PersonalizedIRData::DataValidity)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26CB57B18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (IR::IRDataLoader::Implementation::*)(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity),IR::IRDataLoader::Implementation*,IR::PersonalizedIRData::DataStatus,std::placeholders::__ph<1> const&>>,void ()(IR::PersonalizedIRData::DataValidity)>::operator()(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(uint64_t (**)(void *, void, void))(a1 + 8);
  uint64_t v4 = (void *)(*(void *)(a1 + 24) + (v2 >> 1));
  if (v2) {
    uint64_t v3 = *(uint64_t (**)(void *, void, void))(*v4 + v3);
  }
  return v3(v4, *(unsigned int *)(a1 + 32), *a2);
}

void *std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::find<std::string>(void *a1, unsigned __int8 *a2)
{
  unint64_t v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  uint64_t v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = *((void *)v11 + 1);
      if (v6 == v13)
      {
        if (std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }
        else
        {
          v13 &= *(void *)&v5 - 1;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      uint64_t v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  unint64_t v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  uint64_t v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = *((void *)v11 + 1);
      if (v13 == v6)
      {
        if (std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }
        else
        {
          v13 &= *(void *)&v5 - 1;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      uint64_t v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

unint64_t std::__string_hash<char>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v3 = v2;
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v5, (uint64_t *)a2, v3);
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      uint64_t v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      uint64_t v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      uint64_t v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      uint64_t v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      uint64_t v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      unint64_t v11 = v7 + v9;
      unint64_t v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      unint64_t v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      unint64_t v14 = v8 + a3 + v7 + v4;
      uint64_t v15 = v14 + v5;
      unint64_t v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      uint64_t v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v18 = v17 + v6 + v9;
      uint64_t v19 = __ROR8__(v18, 44);
      uint64_t v20 = v18 + v10;
      uint64_t v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      uint64_t v23 = *a2;
      int64_t v22 = a2 + 4;
      unint64_t v24 = v23 - 0x4B6D499041670D8DLL * v5;
      uint64_t v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v26 = *(v22 - 3);
        uint64_t v27 = v24 + v15 + v11 + v26;
        uint64_t v28 = v22[2];
        uint64_t v29 = v22[3];
        uint64_t v30 = v22[1];
        unint64_t v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        uint64_t v31 = v13 + v20;
        uint64_t v32 = *(v22 - 2);
        uint64_t v33 = *(v22 - 1);
        uint64_t v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        uint64_t v35 = v34 + v20 + v33;
        uint64_t v36 = v34 + v26 + v32;
        uint64_t v15 = v36 + v33;
        uint64_t v37 = __ROR8__(v36, 44) + v34;
        unint64_t v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        unint64_t v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        unint64_t v16 = v37 + __ROR8__(v35 + v38, 21);
        unint64_t v39 = v24 + v21 + *v22;
        uint64_t v20 = v39 + v30 + v28 + v29;
        uint64_t v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        unint64_t v13 = v38;
        v25 += 64;
      }
      while (v25);
      unint64_t v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      unint64_t v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](_DWORD *a1, unint64_t a2)
{
  if (a2 < 9)
  {
    if (a2 < 4)
    {
      unint64_t result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        unint64_t v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      uint64_t v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    uint64_t v3 = *(void *)((char *)a1 + a2 - 8);
    uint64_t v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = 0xB492B66FBE98F273 * *a1;
  uint64_t v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  unint64_t v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8);
  unint64_t v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v4 - 0x3C5A37A36834CED9 * *(void *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)((char *)a1 + a2 - 16);
  uint64_t v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  uint64_t v5 = a1[2];
  uint64_t v4 = a1[3];
  uint64_t v6 = __ROR8__(v3 + v4, 52);
  uint64_t v7 = v3 + a1[1];
  uint64_t v8 = __ROR8__(v7, 7);
  uint64_t v9 = v7 + v5;
  uint64_t v10 = *(void *)((char *)a1 + a2 - 32) + v5;
  uint64_t v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  uint64_t v12 = *(void *)((char *)a1 + a2 - 24) + v10 + v2;
  unint64_t v13 = 0xC3A5C85C97CB3127 * (v12 + *(void *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(void *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(void *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

uint64_t std::equal_to<std::string>::operator()[abi:ne180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a2[23];
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a2[23];
  }
  else {
    uint64_t v5 = *((void *)a2 + 1);
  }
  uint64_t v6 = a3[23];
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a3 + 1);
  }
  if (v5 != v6) {
    return 0;
  }
  if (v7 < 0) {
    uint64_t v3 = *(unsigned __int8 **)a3;
  }
  if ((v4 & 0x80) != 0) {
    return memcmp(*(const void **)a2, v3, *((void *)a2 + 1)) == 0;
  }
  if (!a2[23]) {
    return 1;
  }
  uint64_t v8 = v4 - 1;
  do
  {
    int v10 = *a2++;
    int v9 = v10;
    int v12 = *v3++;
    int v11 = v12;
    BOOL v14 = v8-- != 0;
    uint64_t result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    BOOL v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *uint64_t v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_21B51A718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = (char *)operator new(0x50uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = a2;
  unint64_t v9 = (std::string *)(v8 + 16);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    *((void *)v8 + 4) = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  *((_DWORD *)v8 + 1std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *((void *)v8 + 9) = 0;
  *(unsigned char *)(a4 + 16) = 1;
}

void sub_21B51A7BC(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      long long v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *long long v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            long long v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          long long v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

uint64_t std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__call_once_proxy[abi:ne180100]<std::tuple<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0 &&>>(unsigned __int8 ***a1)
{
  v5[4] = *MEMORY[0x263EF8340];
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (uint64_t *)(*(void *)v1 + 160);
  v5[0] = &unk_26CB57B60;
  v5[1] = v2;
  v5[3] = v5;
  IR::PersonalizedIRData::RegisterObservers(v3, (uint64_t)v5, v1[8]);
  return std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::~__value_func[abi:ne180100](v5);
}

void sub_21B51AC2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1},std::allocator<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1}>,void ()(IR::PersonalizedIRData::DataStatus)>::~__func()
{
}

void *std::__function::__func<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1},std::allocator<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1}>,void ()(IR::PersonalizedIRData::DataStatus)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CB57B60;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1},std::allocator<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1}>,void ()(IR::PersonalizedIRData::DataStatus)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26CB57B60;
  a2[1] = v2;
  return result;
}

void std::__function::__func<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1},std::allocator<IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::$_0::operator() const(void)::{lambda(IR::PersonalizedIRData::DataStatus)#1}>,void ()(IR::PersonalizedIRData::DataStatus)>::operator()(uint64_t a1, int *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(IR::IRDataLoader::Implementation **)(a1 + 8);
  atomic_store(1u, IR::IRDataLoader::Implementation::addToPersonalizedHRTFCallbackPool(std::string,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>,IR::PersonalizedHRIRCallbackType,BOOL)::sCalledOnce);
  if (v2) {
    IR::IRDataLoader::Implementation::executePersonalizedHRTFCallbacks((uint64_t)v3, (unsigned int *)1, 0);
  }
  else {
    IR::IRDataLoader::Implementation::rebuildPersonalizedHRTFCache(v3);
  }
}

void *std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::~__value_func[abi:ne180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::__erase_unique<std::string>(void *a1, unsigned __int8 *a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::find<std::string>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::remove(a1, result, (uint64_t)v4);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v4, 0);
    return (unsigned __int8 *)1;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::pair<IR::PersonalizedHRIRCallbackType,std::function<void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>>>>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *uint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v6 = (uint64_t **)(a1 + 8);
  uint8x8_t v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        uint8x8_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint8x8_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a1, a4, (uint64_t)&v11);
    std::__tree<int>::__insert_node_at((uint64_t **)a1, (uint64_t)v8, v6, v11);
    return v11;
  }
  return (uint64_t *)v8;
}

std::vector<char> *std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, _DWORD **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = **a2;
  std::vector<char>::value_type __x = 0;
  uint64_t result = std::vector<char>::vector((std::vector<char> *)(v6 + 40), 0x20uLL, &__x);
  std::vector<char>::pointer begin = result->__begin_;
  *(void *)std::vector<char>::pointer begin = 0;
  *((_DWORD *)begin + 2) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_21B51B150(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,CA::ChannelLayout>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n, const std::vector<char>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<char>::size_type v5 = __n;
    std::vector<unsigned char>::__vallocate[abi:ne180100](this, __n);
    std::vector<char>::pointer end = this->__end_;
    unsigned int v7 = &end[v5];
    do
    {
      *end++ = *__x;
      --v5;
    }
    while (v5);
    this->__end_ = v7;
  }
  return this;
}

void sub_21B51B1D0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,CA::ChannelLayout>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (void *)__p[5];
    if (v3)
    {
      __p[6] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t **std::__tree<std::__value_type<unsigned int,CA::ChannelLayout>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,CA::ChannelLayout>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,CA::ChannelLayout>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,CA::ChannelLayout>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  std::vector<char>::size_type v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        std::vector<char>::size_type v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      std::vector<char>::size_type v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (char *)operator new(0x40uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = *(_OWORD *)(a3 + 8);
    *((void *)v10 + 7) = *(void *)(a3 + 24);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    std::__tree<int>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void *std::allocate_shared[abi:ne180100]<IR::IRData,std::allocator<IR::IRData>,IR::IRDataAttributes const&,applesauce::CF::DataRef &,std::vector<float> const&,void>@<X0>(uint64_t a1@<X1>, CFTypeRef *a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  unint64_t v8 = operator new(0x20uLL);
  uint64_t result = std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<IR::IRDataAttributes const&,applesauce::CF::DataRef &,std::vector<float> const&,std::allocator<IR::IRData>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_21B51B380(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<IR::IRDataAttributes const&,applesauce::CF::DataRef &,std::vector<float> const&,std::allocator<IR::IRData>,0>(void *a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB57468;
  std::construct_at[abi:ne180100]<IR::IRData,IR::IRDataAttributes const&,applesauce::CF::DataRef &,std::vector<float> const&,IR::IRData*>((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_21B51B3DC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<IR::IRData,IR::IRDataAttributes const&,applesauce::CF::DataRef &,std::vector<float> const&,IR::IRData*>(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  CFTypeRef v7 = *a3;
  if (*a3) {
    CFRetain(*a3);
  }
  CFTypeRef cf = v7;
  IR::IRData::IRData(a1, a2, &cf, a4);
  if (cf) {
    CFRelease(cf);
  }
  return a1;
}

void sub_21B51B468(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DataRef::~DataRef((const void **)va);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<IR::IRData,std::allocator<IR::IRData>,IR::IRDataAttributes &,applesauce::CF::DataRef &,std::vector<float> const&,void>@<X0>(uint64_t a1@<X1>, CFTypeRef *a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  unint64_t v8 = operator new(0x20uLL);
  uint64_t result = std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<IR::IRDataAttributes &,applesauce::CF::DataRef &,std::vector<float> const&,std::allocator<IR::IRData>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_21B51B4DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<IR::IRDataAttributes &,applesauce::CF::DataRef &,std::vector<float> const&,std::allocator<IR::IRData>,0>(void *a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB57468;
  std::construct_at[abi:ne180100]<IR::IRData,IR::IRDataAttributes &,applesauce::CF::DataRef &,std::vector<float> const&,IR::IRData*>((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_21B51B538(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<IR::IRData,IR::IRDataAttributes &,applesauce::CF::DataRef &,std::vector<float> const&,IR::IRData*>(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  CFTypeRef v7 = *a3;
  if (*a3) {
    CFRetain(*a3);
  }
  CFTypeRef cf = v7;
  IR::IRData::IRData(a1, a2, &cf, a4);
  if (cf) {
    CFRelease(cf);
  }
  return a1;
}

void sub_21B51B5C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::DataRef::~DataRef((const void **)va);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<IR::IRData,std::allocator<IR::IRData>,float,unsigned int,unsigned int &,float,BOOL &,unsigned int,unsigned int,unsigned int,std::vector<IR::IRCoordinateType> &,std::vector<float> &,std::vector<IR::IRInterpolationMethod> &,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,void>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  size_t v22 = operator new(0x20uLL);
  std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<float,unsigned int,unsigned int &,float,BOOL &,unsigned int,unsigned int,unsigned int,std::vector<IR::IRCoordinateType> &,std::vector<float> &,std::vector<IR::IRInterpolationMethod> &,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,std::allocator<IR::IRData>,0>(v22, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

void sub_21B51B6A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<IR::IRData>::__shared_ptr_emplace[abi:ne180100]<float,unsigned int,unsigned int &,float,BOOL &,unsigned int,unsigned int,unsigned int,std::vector<IR::IRCoordinateType> &,std::vector<float> &,std::vector<IR::IRInterpolationMethod> &,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,std::allocator<IR::IRData>,0>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26CB57468;
  std::construct_at[abi:ne180100]<IR::IRData,float,unsigned int,unsigned int &,float,BOOL &,unsigned int,unsigned int,unsigned int,std::vector<IR::IRCoordinateType> &,std::vector<float> &,std::vector<IR::IRInterpolationMethod> &,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,IR::IRData*>(a1 + 3, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

void sub_21B51B720(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::construct_at[abi:ne180100]<IR::IRData,float,unsigned int,unsigned int &,float,BOOL &,unsigned int,unsigned int,unsigned int,std::vector<IR::IRCoordinateType> &,std::vector<float> &,std::vector<IR::IRInterpolationMethod> &,IR::IRSphericalInterpolation,applesauce::CF::DictionaryRef,applesauce::CF::DictionaryRef,IR::IRData*>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  *a14 = 0;
  *a15 = 0;
  IR::IRData::IRData(a1);
}

void sub_21B51B7E4(_Unwind_Exception *a1)
{
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v1 - 32));
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)(v1 - 24));
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],float const&>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51B898(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],float const&>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51B96C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[1],int>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51BA40(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[13],long &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  uint64_t valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51BB14(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[11],float &>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51BBE8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],std::string>(applesauce::CF::TypeRef *a1, char *a2, uint64_t a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int v5 = *(char *)(a3 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (const UInt8 *)a3;
  }
  else {
    uint64_t v6 = *(const UInt8 **)a3;
  }
  if (v5 >= 0) {
    CFIndex v7 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    CFIndex v7 = *(void *)(a3 + 8);
  }
  CFStringRef v8 = CFStringCreateWithBytes(0, v6, v7, 0x8000100u, 0);
  *((void *)a1 + 1) = v8;
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51BCC8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[20],long &>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  uint64_t valuePtr = *a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  *((void *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51BD9C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[9],applesauce::CF::DictionaryRef const>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  CFNumberRef v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[12],std::string const&>(applesauce::CF::TypeRef *a1, char *a2, uint64_t a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int v5 = *(char *)(a3 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (const UInt8 *)a3;
  }
  else {
    uint64_t v6 = *(const UInt8 **)a3;
  }
  if (v5 >= 0) {
    CFIndex v7 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    CFIndex v7 = *(void *)(a3 + 8);
  }
  CFStringRef v8 = CFStringCreateWithBytes(0, v6, v7, 0x8000100u, 0);
  *((void *)a1 + 1) = v8;
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51BEC0(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const(&)[18],applesauce::CF::DictionaryRef const>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  applesauce::CF::TypeRef::TypeRef(a1, a2);
  int v5 = *a3;
  if (v5) {
    CFRetain(v5);
  }
  *((void *)a1 + 1) = v5;
  return a1;
}

IR::IRDataLoader::Implementation *std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](IR::IRDataLoader::Implementation **a1, IR::IRDataLoader::Implementation *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    IR::IRDataLoader::Implementation::~Implementation(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

IR::IRDataLoader::Implementation *IR::IRDataLoader::Implementation::Implementation(IR::IRDataLoader::Implementation *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  MEMORY[0x21D48F5D0]((char *)this + 24);
  MEMORY[0x21D48F5D0]((char *)this + 88);
  *((unsigned char *)this + 152) = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, "IRDataLoader");
  IR::PersonalizedIRData::PersonalizedIRData((char *)this + 160, __p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((_DWORD *)this + 5std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 1065353216;
  *((void *)this + 28) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 26) = (char *)this + 216;
  return this;
}

void sub_21B51C038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::recursive_mutex::~recursive_mutex(v16);
  std::recursive_mutex::~recursive_mutex(v15);
  std::vector<std::pair<IR::IRDataAttributes,std::weak_ptr<IR::IRData const>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(BOOL,BOOL)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

{
  void *v3;
  uint64_t v4;

  uint64_t v3 = (void *)(a2 + 24);
  char v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *std::__function::__func<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0,std::allocator<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0>,void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__func(void *a1)
{
  *a1 = &unk_26CB57BA8;
  std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0,std::allocator<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0>,void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::~__func(void *a1)
{
  *a1 = &unk_26CB57BA8;
  std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100](a1 + 1);

  JUMPOUT(0x21D48F780);
}

void *std::__function::__func<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0,std::allocator<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0>,void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x28uLL);
  void *v2 = &unk_26CB57BA8;
  std::__function::__value_func<void ()(BOOL,BOOL)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_21B51C21C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0,std::allocator<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0>,void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26CB57BA8;
  return std::__function::__value_func<void ()(BOOL,BOOL)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0,std::allocator<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0>,void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

void std::__function::__func<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0,std::allocator<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0>,void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(BOOL,BOOL)>::~__value_func[abi:ne180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0,std::allocator<IR::IRDataLoader::addPersonalizedHRTFListenerCallback(std::string,std::function<void ()(BOOL,BOOL)>)::$_0>,void ()(IR::PersonalizedIRData::DataStatus,IR::PersonalizedIRData::DataValidity)>::operator()(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return std::function<void ()(BOOL,BOOL)>::operator()(a1 + 8, *a2 == 0, *a3 == 0);
}

uint64_t std::function<void ()(BOOL,BOOL)>::operator()(uint64_t a1, char a2, char a3)
{
  char v6 = a2;
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void OUTLINED_FUNCTION_0_1(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

uint64_t IR::MatrixResampler<float>::MatrixResampler(uint64_t a1, unsigned int a2, float a3, float a4)
{
  IR::DataResampler<float>::DataResampler(a1, a2, a3, a4);
  *(void *)uint64_t v6 = &unk_26CB57BF0;
  *(void *)(v6 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(v6 + 48) = 0;
  *(void *)(v6 + 56) = 0;
  *(_DWORD *)(v6 + 64) = 0;
  *(void *)(v6 + 68) = 0x1400000005;
  if (a2 <= 2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Invalid input length, must be > 2)");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  }
  return a1;
}

void sub_21B51C4B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  unint64_t v12 = *a10;
  if (*a10)
  {
    v10[6] = v12;
    operator delete(v12);
  }
  IR::DataResampler<float>::~DataResampler(v10);
  _Unwind_Resume(a1);
}

uint64_t IR::MatrixResampler<float>::Initialize(uint64_t a1, unsigned int a2, int a3, long double a4)
{
  float v4 = *(float *)&a4;
  uint64_t v5 = 0;
  CFIndex v7 = (_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  float v8 = *(float *)(a1 + 16) / *(float *)(a1 + 12);
  unsigned int v9 = a3 + a2 + vcvtps_u32_f32(v8 * (float)v6);
  *(_DWORD *)(a1 + 64) = v9;
  *(_DWORD *)(a1 + 68) = a2;
  uint64_t v10 = (unsigned int *)(a1 + 64);
  *(_DWORD *)(a1 + 72) = a3;
  LODWORD(__P) = 15728640;
  do
  {
    unsigned int v12 = __P;
    LODWORD(a4) = dword_21B551200[v5];
    double v13 = (double)*(unint64_t *)&a4;
    unsigned int v14 = 4;
    do
    {
      a4 = exp2((double)v14) * v13;
      unsigned int v15 = a4;
    }
    while (v9 + 256 > a4 && v14++ < 0x14);
    if (v15 >= v12) {
      vDSP_Length __P = v12;
    }
    else {
      vDSP_Length __P = v15;
    }
    ++v5;
  }
  while (v5 != 4);
  if (__P <= 0xF) {
    IR::MatrixResampler<float>::Initialize();
  }
  unsigned int v17 = __P >> 1;
  if (v6 >= v9) {
    float v18 = v7;
  }
  else {
    float v18 = v10;
  }
  unint64_t v19 = (*v18 * __P);
  LODWORD(v91) = 0;
  std::vector<float>::vector(&v93, v19, &v91);
  LODWORD(__A) = 0;
  std::vector<float>::vector(&v91, __P >> 1, &__A);
  float v20 = (float)__P;
  LODWORD(__A) = 0;
  *(float *)float __B = v8 / (float)__P;
  vDSP_vramp((const float *)&__A, (const float *)__B, v91, 1, v92 - v91);
  unint64_t v21 = *v7;
  LODWORD(__B[0]) = 0;
  std::vector<float>::vector(&__A, v21, __B);
  LODWORD(__B[0]) = 0;
  LODWORD(v87[0]) = -1060565029;
  vDSP_vramp((const float *)__B, (const float *)v87, __A, 1, v90 - __A);
  vDSP_mmul(v91, 1, __A, 1, v93, 1, __P >> 1, *v7, 1uLL);
  if (v8 > 1.0)
  {
    if (v92 == v91)
    {
      uint64_t v23 = v92;
    }
    else
    {
      unint64_t v22 = v92 - v91;
      uint64_t v23 = v91;
      do
      {
        unint64_t v24 = v22 >> 1;
        uint64_t v25 = &v23[v22 >> 1];
        float v27 = *v25;
        uint64_t v26 = v25 + 1;
        v22 += ~(v22 >> 1);
        if (v27 > 0.5) {
          unint64_t v22 = v24;
        }
        else {
          uint64_t v23 = v26;
        }
      }
      while (v22);
    }
    if (v92 == v23)
    {
      uint64_t v64 = 0;
      goto LABEL_66;
    }
    uint64_t v28 = *v7 * ((unint64_t)((char *)v23 - (char *)v91) >> 2);
    vDSP_vclr(&v93[v28], 1, v94 - v93 - v28);
  }
  int v29 = *v7 * v17;
  LODWORD(v87[0]) = 0;
  std::vector<float>::vector(__B, (2 * v29), v87);
  LODWORD(__C[0]) = 0;
  std::vector<float>::vector(v87, (2 * v29), __C);
  LODWORD(__C[0]) = v29;
  vvsincosf((float *)v87[0], (float *)__B[0], v93, (const int *)__C);
  unsigned int v30 = *v7;
  vDSP_Length __N = __P >> 1;
  vDSP_Length v70 = v17 + 1;
  vDSP_Length v31 = v17 - 1;
  if (v17 != 1)
  {
    unsigned int v32 = v30 * (v17 + 1);
    unsigned int v33 = v17 - 1;
    unsigned int v34 = v30 * v31;
    do
    {
      memcpy((char *)__B[0] + 4 * v32, (char *)__B[0] + 4 * v34, 4 * v30);
      vDSP_Length v35 = *v7;
      LODWORD(__C[0]) = -1082130432;
      vDSP_vsmul((const float *)v87[0] + v34, 1, (const float *)__C, (float *)v87[0] + v32, 1, v35);
      unsigned int v30 = *v7;
      v34 -= *v7;
      v32 += *v7;
      --v33;
    }
    while (v33);
  }
  v86.realp = (float *)__B[0];
  v86.imagp = (float *)v87[0];
  if (v30 < 3) {
    __assert_rtn("Initialize", "MatrixResampler.cpp", 123, "mNumInputFrames > 2");
  }
  uint64_t v36 = (DSPComplex *)v93;
  LODWORD(__C[0]) = 1065353216;
  vDSP_vfill((const float *)__C, v93, 1, __N);
  if (v8 <= 1.0)
  {
    float v41 = (float)__N * v4;
    float v42 = ceilf(v41);
    unsigned int v43 = (float)((float)__N - v42);
    if (v43)
    {
      unsigned int v44 = v42;
      do
      {
        *(&v36->real + v44) = fmaxf(1.0- (float)((float)((float)v44 - v41)* (float)(1.0 / (float)((float)__N - v41))), 0.0001);
        ++v44;
        --v43;
      }
      while (v43);
    }
  }
  else
  {
    float v37 = (float)(v4 / v8) * (float)__N;
    float v38 = (float)__N / v8;
    unsigned int v39 = (float)(floorf(v38) - ceilf(v37));
    for (unsigned int i = vcvtps_u32_f32(v37); v39; --v39)
    {
      *(&v36->real + i) = fmaxf(1.0 - (float)((float)((float)i - v37) * (float)(1.0 / (float)(v38 - v37))), 0.0001);
      ++i;
    }
    if (i < __N)
    {
      LODWORD(__C[0]) = 953267991;
      vDSP_vfill((const float *)__C, (float *)v36 + i, 1, __N - i);
    }
  }
  *((_DWORD *)&v36->real + __N) = 953267991;
  Setup = vDSP_DFT_zrop_CreateSetup(0, __P, vDSP_DFT_FORWARD);
  __Setup = vDSP_DFT_zrop_CreateSetup(Setup, __P, vDSP_DFT_INVERSE);
  LODWORD(__Oi[0]) = 0;
  std::vector<float>::vector(__C, __P, __Oi);
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  std::vector<float>::vector(__Oi, __P, &v80);
  __Z.realp = __C[0];
  __Z.imagp = __Oi[0];
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v70;
  vvlogf(__C[0], (const float *)v36, (const int *)&v80);
  *(float *)&CFDictionaryRef v80 = 1.0 / v20;
  vDSP_vsmul(__C[0], 1, (const float *)&v80, __C[0], 1, v70);
  uint64_t v46 = __C[0];
  uint64_t v47 = __Oi[0];
  *__Oi[0] = __C[0][__N];
  vDSP_DFT_Execute(__Setup, v46, v47, v46, v47);
  vDSP_ztoc(&__Z, 1, v36, 2, __N);
  uint64_t v48 = (float *)v36 + __P;
  vDSP_vclr(v48, 1, __P);
  float *v48 = 1.0;
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0x40000000;
  vDSP_vfill((const float *)&v80, v48 + 1, 1, v31);
  v48[__N] = 1.0;
  vDSP_vmul((const float *)v36, 1, v48, 1, (float *)v36, 1, __P);
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 1056964608;
  vDSP_vsmul((const float *)v36, 1, (const float *)&v80, (float *)v36, 1, __P);
  vDSP_ctoz(v36, 2, &__Z, 1, __N);
  vDSP_DFT_Execute(Setup, __C[0], __Oi[0], __C[0], __Oi[0]);
  uint64_t v49 = __Oi[0];
  __C[0][__N] = *__Oi[0];
  v49[__N] = 0.0;
  *uint64_t v49 = 0.0;
  vDSP_DFT_DestroySetup(Setup);
  vDSP_DFT_DestroySetup(__Setup);
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v70;
  vvexpf((float *)v36, __C[0], (const int *)&v80);
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v70;
  vvsincosf(v48, __C[0], __Oi[0], (const int *)&v80);
  vDSP_vmul((const float *)v36, 1, __C[0], 1, __C[0], 1, v70);
  vDSP_vmul((const float *)v36, 1, v48, 1, __Oi[0], 1, v70);
  if (v70 < __P)
  {
    uint64_t v50 = __C[0];
    std::string::size_type v51 = __Oi[0];
    uint64_t v52 = &__C[0][(__P >> 1) + 1];
    uint64_t v53 = &__Oi[0][(__P >> 1) + 1];
    if (v12 >= v15) {
      unsigned int v54 = v15;
    }
    else {
      unsigned int v54 = v12;
    }
    unsigned int v55 = ~(__P >> 1) + v54;
    do
    {
      *v52++ = v50[v31];
      *v53++ = -v51[v31];
      LODWORD(v31) = v31 - 1;
      --v55;
    }
    while (v55);
  }
  float v56 = (double)a2 * -6.28318531 / (double)__P;
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(float *)&uint64_t v78 = v56;
  vDSP_vramp((const float *)&v80, (const float *)&v78, (float *)v36, 1, __P);
  LODWORD(v8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = __P;
  vvsincosf((float *)v36 + (2 * __P), (float *)v36 + __P, (const float *)v36, (const int *)&v80);
  v82.realp = (float *)v36 + __P;
  v82.imagp = (float *)v36 + (2 * __P);
  vDSP_zvmul(&__Z, 1, &v82, 1, &__Z, 1, __P, 1);
  LODWORD(v78) = 0;
  std::vector<float>::vector(&v80, __P, &v78);
  LODWORD(v78) = 0;
  *(float *)&uint64_t v76 = 1.0 / v20;
  vDSP_vramp((const float *)&v78, (const float *)&v76, v80, 1, v81 - v80);
  unint64_t v57 = *v10;
  LODWORD(v76) = 0;
  std::vector<float>::vector(&v78, v57, &v76);
  LODWORD(v76) = 0;
  LODWORD(v74) = 1086918619;
  vDSP_vramp((const float *)&v76, (const float *)&v74, v78, 1, v79 - v78);
  int v58 = *v10;
  vDSP_mmul(v78, 1, v80, 1, v93, 1, *v10, __P, 1uLL);
  unint64_t v59 = (v58 * __P);
  LODWORD(v74) = 0;
  std::vector<float>::vector(&v76, v59, &v74);
  LODWORD(v73.realp) = 0;
  std::vector<float>::vector(&v74, v59, &v73);
  LODWORD(v73.realp) = v59;
  vvsincosf(v74, v76, v93, (const int *)&v73);
  *(float *)&v73.realp = 1.0 / v20;
  vDSP_vsmul(v76, 1, (const float *)&v73, v76, 1, v77 - v76);
  *(float *)&v73.realp = 1.0 / v20;
  vDSP_vsmul(v74, 1, (const float *)&v73, v74, 1, v75 - v74);
  v73.realp = v76;
  v73.imagp = v74;
  LODWORD(v6std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = *v10;
  if (*v10)
  {
    int v61 = 0;
    unint64_t v62 = 0;
    if (v12 >= v15) {
      unsigned int v12 = v15;
    }
    do
    {
      v72.realp = &v76[v61];
      v72.imagp = &v74[v61];
      vDSP_zvmul(&v72, 1, &__Z, 1, &v72, 1, __P, 1);
      ++v62;
      unint64_t v60 = *v10;
      v61 += v12;
    }
    while (v62 < v60);
  }
  unint64_t v63 = (*(_DWORD *)(a1 + 8) * v60);
  LODWORD(v71.realp) = 0;
  std::vector<float>::resize(a1 + 40, v63, &v71);
  v71.realp = *(float **)(a1 + 40);
  v71.imagp = v93;
  vDSP_zmmul(&v73, 1, &v86, 1, &v71, 1, *v10, *v7, __P);
  uint64_t v64 = *v10;
  if (v74)
  {
    long long v75 = v74;
    operator delete(v74);
  }
  if (v76)
  {
    uint64_t v77 = v76;
    operator delete(v76);
  }
  if (v78)
  {
    std::string::size_type v79 = v78;
    operator delete(v78);
  }
  if (v80)
  {
    long long v81 = v80;
    operator delete(v80);
  }
  if (__Oi[0])
  {
    __Oi[1] = __Oi[0];
    operator delete(__Oi[0]);
  }
  if (__C[0])
  {
    __C[1] = __C[0];
    operator delete(__C[0]);
  }
  if (v87[0])
  {
    v87[1] = v87[0];
    operator delete(v87[0]);
  }
  if (__B[0])
  {
    __B[1] = __B[0];
    operator delete(__B[0]);
  }
LABEL_66:
  if (__A)
  {
    float v90 = __A;
    operator delete(__A);
  }
  if (v91)
  {
    uint64_t v92 = v91;
    operator delete(v91);
  }
  if (v93)
  {
    uint64_t v94 = v93;
    operator delete(v93);
  }
  return v64;
}

void sub_21B51CEFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41)
{
  unsigned int v43 = *(void **)(v41 - 240);
  if (v43)
  {
    *(void *)(v41 - 232) = v43;
    operator delete(v43);
  }
  unsigned int v44 = *(void **)(v41 - 216);
  if (v44)
  {
    *(void *)(v41 - 208) = v44;
    operator delete(v44);
  }
  uint64_t v45 = *(void **)(v41 - 192);
  if (v45)
  {
    *(void *)(v41 - 184) = v45;
    operator delete(v45);
  }
  uint64_t v46 = *(void **)(v41 - 168);
  if (v46)
  {
    *(void *)(v41 - 16std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = v46;
    operator delete(v46);
  }
  uint64_t v47 = *(void **)(v41 - 144);
  if (v47)
  {
    *(void *)(v41 - 136) = v47;
    operator delete(v47);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::MatrixResampler<float>::Process(uint64_t a1, const float *__B, unsigned int a3, float *__C, unsigned int a5, vDSP_Length __N)
{
  uint64_t v8 = a1 + 40;
  CFIndex v7 = *(const float **)(a1 + 40);
  vDSP_Length v9 = a5 / __N;
  if (v9 * (a3 / __N) > (unint64_t)((uint64_t)(*(void *)(v8 + 8) - (void)v7) >> 2)
    || a3 / __N != *(_DWORD *)(a1 + 8)
    || v9 > *(_DWORD *)(a1 + 64))
  {
    return 104;
  }
  vDSP_mmul(v7, 1, __B, 1, __C, 1, v9, __N, a3 / __N);
  return 0;
}

uint64_t IR::MatrixResampler<float>::Initialize(uint64_t a1, const __CFDictionary **a2, long double a3)
{
  *(unsigned char *)(a1 + 2std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  CFDictionaryRef v4 = *a2;
  if (*a2)
  {
    int v17 = 1064011039;
    float v6 = applesauce::CF::at_or<float,__CFString const*&>(v4, (const void **)IR::kIRDataResamplerConfigQualityKey, (uint64_t)&v17);
    if (v6 > 1.0 || v6 < 0.0)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid Quality index");
    }
    CFDictionaryRef v7 = *a2;
    if (!*a2)
    {
      double v13 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v13);
    }
    unsigned int v16 = 5;
    unsigned int v8 = applesauce::CF::at_or<unsigned int,__CFString const*&>(v7, (const void **)IR::kMatrixResamplerConfigLatencySamplesKey, &v16);
    CFDictionaryRef v9 = *a2;
    if (!*a2)
    {
      unsigned int v14 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v14);
    }
    unsigned int v15 = 20;
    int v10 = applesauce::CF::at_or<unsigned int,__CFString const*&>(v9, (const void **)IR::kMatrixResamplerConfigPostRingSamplesKey, &v15);
  }
  else
  {
    int v10 = 20;
    unsigned int v8 = 5;
    float v6 = 0.92;
  }
  *(float *)&a3 = v6;
  LODWORD(result) = IR::MatrixResampler<float>::Initialize(a1, v8, v10, a3);
  *(unsigned char *)(a1 + 2std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 1;
  return result;
}

void sub_21B51D248(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t IR::MatrixResampler<float>::Process(uint64_t a1, const float *a2, unsigned int a3, float *a4, unsigned int a5)
{
  return IR::MatrixResampler<float>::Process(a1, a2, a3, a4, a5, 1uLL);
}

uint64_t IR::MatrixResampler<float>::CleanUp(uint64_t result)
{
  *(unsigned char *)(result + 2std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(result + 48) = *(void *)(result + 40);
  return result;
}

uint64_t IR::MatrixResampler<float>::GetRequiredNumberOfInputFrames(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

void *IR::MatrixResampler<float>::~MatrixResampler(void *a1)
{
  *a1 = &unk_26CB57BF0;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }

  return IR::DataResampler<float>::~DataResampler(a1);
}

void IR::MatrixResampler<float>::~MatrixResampler(void *a1)
{
  *a1 = &unk_26CB57BF0;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  IR::DataResampler<float>::~DataResampler(a1);

  JUMPOUT(0x21D48F780);
}

CFURLRef IR::copyHRTFBinURL(IR *this)
{
  std::string::basic_string[abi:ne180100]<0>(&v7, "/System/Library/Audio/Tunings/IRs");
  uint64_t v1 = std::string::append(&v7, "/HRTF.bin", 9uLL);
  long long v2 = *(_OWORD *)&v1->__r_.__value_.__l.__data_;
  int64_t v9 = v1->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v2;
  v1->__r_.__value_.__l.__size_ = 0;
  v1->__r_.__value_.__r.__words[2] = 0;
  v1->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  if (v9 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if (v9 >= 0) {
    CFIndex v4 = HIBYTE(v9);
  }
  else {
    CFIndex v4 = (CFIndex)__p[1];
  }
  CFURLRef v5 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)v3, v4, 1u);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_21B51D410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>@<Q0>(char *__s@<X1>, std::string *a2@<X0>, std::string *a3@<X8>)
{
  size_t v6 = strlen(__s);
  std::string v7 = (__n128 *)std::string::append(a2, __s, v6);
  __n128 result = *v7;
  *a3 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

void *IR::getGenericIRBasePath@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "/System/Library/Audio/Tunings/IRs");
}

void IR::getProductTypeXTCIRFullPath(void *a1@<X8>)
{
  unint64_t v3 = applesauce::gestalt::query_as<unsigned int,0>();
  if ((v3 & 0xFF00000000) == 0 || v3 == 0)
  {
    ProductType = (PlatformUtilities *)PlatformUtilities_iOS::GetProductType((PlatformUtilities_iOS *)v3);
    if (ProductType)
    {
      CFMutableStringRef v6 = PlatformUtilities::CopyHardwareModelShortName(ProductType);
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v32, v6);
      std::string::basic_string[abi:ne180100]<0>(&v29, "/System/Library/Audio/Tunings/IRs");
      std::string v7 = std::string::append(&v29, "/", 1uLL);
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v30.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      if (!v32)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x21D48F410](exception, "Could not construct");
      }
      applesauce::CF::convert_to<std::string,0>(v32, (uint64_t)&__p);
      if ((v28 & 0x80u) == 0) {
        p_p = (const std::string::value_type *)&__p;
      }
      else {
        p_p = (const std::string::value_type *)__p;
      }
      if ((v28 & 0x80u) == 0) {
        std::string::size_type v10 = v28;
      }
      else {
        std::string::size_type v10 = v27;
      }
      unint64_t v11 = std::string::append(&v30, p_p, v10);
      long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      double v13 = std::string::append(&v31, "/", 1uLL);
      long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      a1[2] = *((void *)&v13->__r_.__value_.__l + 2);
      *(_OWORD *)a1 = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      if ((char)v28 < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
      if (v32) {
        CFRelease(v32);
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(a1, "");
    }
  }
  else
  {
    CFStringRef v15 = PlatformUtilities_iOS::CopyAcousticIDFilePrefix((PlatformUtilities_iOS *)v3);
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v32, v15);
    std::string::basic_string[abi:ne180100]<0>(&v29, "/System/Library/Audio/Tunings/IRs");
    unsigned int v16 = std::string::append(&v29, "/", 1uLL);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if (!v32)
    {
      unint64_t v24 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](v24, "Could not construct");
    }
    applesauce::CF::convert_to<std::string,0>(v32, (uint64_t)&__p);
    if ((v28 & 0x80u) == 0) {
      float v18 = (const std::string::value_type *)&__p;
    }
    else {
      float v18 = (const std::string::value_type *)__p;
    }
    if ((v28 & 0x80u) == 0) {
      std::string::size_type v19 = v28;
    }
    else {
      std::string::size_type v19 = v27;
    }
    float v20 = std::string::append(&v30, v18, v19);
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    unint64_t v22 = std::string::append(&v31, "/", 1uLL);
    long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    a1[2] = *((void *)&v22->__r_.__value_.__l + 2);
    *(_OWORD *)a1 = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if ((char)v28 < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    if (v32) {
      CFRelease(v32);
    }
  }
}

void sub_21B51D7C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  __cxa_free_exception(v26);
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  applesauce::CF::StringRef::~StringRef((const void **)(v27 - 24));
  _Unwind_Resume(a1);
}

void IR::getProductTypeXTCIRFilePrefix(void *a1@<X8>)
{
  unint64_t v3 = applesauce::gestalt::query_as<unsigned int,0>();
  BOOL v4 = (v3 & 0xFF00000000) == 0 || v3 == 0;
  if (v4 && (int ProductType = PlatformUtilities_iOS::GetProductType((PlatformUtilities_iOS *)v3)) != 0)
  {
    CFStringRef v6 = PlatformUtilities_iOS::CopyProductTypeFilePrefix(ProductType);
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v6);
    if (!cf)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)&__p);
    std::string v7 = std::string::append(&__p, "_", 1uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    a1[2] = *((void *)&v7->__r_.__value_.__l + 2);
    *(_OWORD *)a1 = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a1, "");
  }
}

void sub_21B51D98C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15)
{
  __cxa_free_exception(v15);
  applesauce::CF::StringRef::~StringRef(&a15);
  _Unwind_Resume(a1);
}

void IR::getPresetDataAttributes(int a1@<W0>, uint64_t a2@<X8>)
{
  BOOL v4 = (const void *)MEMORY[0x21D48F200](0, "/System/Library/Audio/Tunings/IRs", 33, 1, 0);
  v74[1] = v4;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  CFURLRef v5 = v4;
  switch(a1)
  {
    case 1:
      applesauce::CF::URLRef::URLRef((uint64_t *)&v73);
      IR::IRDataAttributes::IRDataAttributes(a2, &v73, 128, 1, 2, 0.0);
      CFStringRef v6 = &v73;
      goto LABEL_63;
    case 2:
      __break(1u);
      return;
    case 3:
      IR::getProductTypeXTCIRFullPath(&v72);
      if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)&v72.__r_.__value_.__l.__data_, ""))
      {
        CFTypeRef v68 = 0;
        IR::IRDataAttributes::IRDataAttributes(a2, &v68, 0, 0, 2, 0.0);
        std::string v7 = (std::string *)&v68;
      }
      else
      {
        IR::getProductTypeXTCIRFilePrefix(&v70);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("XTCIR_default.ir", &v70, &v71);
        if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v8 = &v71;
        }
        else {
          long long v8 = (std::string *)v71.__r_.__value_.__r.__words[0];
        }
        if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v71.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v71.__r_.__value_.__l.__size_;
        }
        std::string::append(&v72, (const std::string::value_type *)v8, size);
        if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v71.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v70.__r_.__value_.__l.__data_);
        }
        if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v10 = &v72;
        }
        else {
          std::string::size_type v10 = (std::string *)v72.__r_.__value_.__r.__words[0];
        }
        if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          CFIndex v11 = HIBYTE(v72.__r_.__value_.__r.__words[2]);
        }
        else {
          CFIndex v11 = v72.__r_.__value_.__l.__size_;
        }
        applesauce::CF::URLRef::URLRef((CFURLRef *)&v71, (const UInt8 *)v10, v11, 0);
        applesauce::CF::URLRef::URLRef((applesauce::CF::URLRef *)&v69, (CFTypeRef *)&v71.__r_.__value_.__l.__data_);
        IR::IRDataAttributes::IRDataAttributes(a2, &v69, 128, 1, 2, 0.0);
        applesauce::CF::URLRef::~URLRef(&v69);
        std::string v7 = &v71;
      }
      applesauce::CF::URLRef::~URLRef((const void **)&v7->__r_.__value_.__l.__data_);
      if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v72.__r_.__value_.__l.__data_);
      }
      goto LABEL_64;
    case 4:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v67, (const UInt8 *)"Reverb_00_SmallRoom.ir", 22, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v67, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v67;
      goto LABEL_63;
    case 5:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v66, (const UInt8 *)"Reverb_01_MediumRoom.ir", 23, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v66, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v66;
      goto LABEL_63;
    case 6:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v65, (const UInt8 *)"Reverb_02_LargeRoom.ir", 22, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v65, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v65;
      goto LABEL_63;
    case 7:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v64, (const UInt8 *)"Reverb_03_MediumHall.ir", 23, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v64, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v64;
      goto LABEL_63;
    case 8:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v63, (const UInt8 *)"Reverb_04_LargeHall.ir", 22, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v63, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v63;
      goto LABEL_63;
    case 9:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v62, (const UInt8 *)"Reverb_05_Plate.ir", 18, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v62, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v62;
      goto LABEL_63;
    case 10:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v61, (const UInt8 *)"Reverb_06_MediumChamber.ir", 26, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v61, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v61;
      goto LABEL_63;
    case 11:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v60, (const UInt8 *)"Reverb_07_LargeChamber.ir", 25, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v60, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v60;
      goto LABEL_63;
    case 12:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v59, (const UInt8 *)"Reverb_08_Cathedral.ir", 22, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v59, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v59;
      goto LABEL_63;
    case 13:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v58, (const UInt8 *)"Reverb_09_LargeRoom2.ir", 23, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v58, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v58;
      goto LABEL_63;
    case 14:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v57, (const UInt8 *)"Reverb_10_MediumHall2.ir", 24, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v57, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v57;
      goto LABEL_63;
    case 15:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v56, (const UInt8 *)"Reverb_11_MediumHall3.ir", 24, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v56, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v56;
      goto LABEL_63;
    case 16:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v55, (const UInt8 *)"Reverb_12_LargeHall2.ir", 23, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v55, 1024, 1, 2, 0.0);
      CFStringRef v6 = &v55;
      goto LABEL_63;
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
      CFTypeRef v54 = 0;
      IR::IRDataAttributes::IRDataAttributes(a2, &v54, 1024, 1, 2, 0.0);
      if (v54) {
        CFRelease(v54);
      }
      goto LABEL_64;
    case 28:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v53, (const UInt8 *)"HOAReverb_00_SmallRoom.ir", 25, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v53, 0, 1, 2, 0.0);
      CFStringRef v6 = &v53;
      goto LABEL_63;
    case 29:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v52, (const UInt8 *)"HOAReverb_01_MediumRoom.ir", 26, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v52, 0, 1, 2, 0.0);
      CFStringRef v6 = &v52;
      goto LABEL_63;
    case 30:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v51, (const UInt8 *)"HOAReverb_02_LargeRoom.ir", 25, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v51, 0, 1, 2, 0.0);
      CFStringRef v6 = &v51;
      goto LABEL_63;
    case 31:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v50, (const UInt8 *)"HOAReverb_03_MediumHall.ir", 26, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v50, 0, 1, 2, 0.0);
      CFStringRef v6 = &v50;
      goto LABEL_63;
    case 32:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v49, (const UInt8 *)"HOAReverb_04_LargeHall.ir", 25, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v49, 0, 1, 2, 0.0);
      CFStringRef v6 = &v49;
      goto LABEL_63;
    case 33:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v48, (const UInt8 *)"", 0, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v48, 0, 1, 2, 0.0);
      CFStringRef v6 = &v48;
      goto LABEL_63;
    case 34:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v47, (const UInt8 *)"HOAReverb_06_MediumChamber.ir", 29, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v47, 0, 1, 2, 0.0);
      CFStringRef v6 = &v47;
      goto LABEL_63;
    case 35:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v46, (const UInt8 *)"HOAReverb_07_LargeChamber.ir", 28, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v46, 0, 1, 2, 0.0);
      CFStringRef v6 = &v46;
      goto LABEL_63;
    case 36:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v45, (const UInt8 *)"HOAReverb_08_Cathedral.ir", 25, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v45, 0, 1, 2, 0.0);
      CFStringRef v6 = &v45;
      goto LABEL_63;
    case 37:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v44, (const UInt8 *)"HOAReverb_09_LargeRoom2.ir", 26, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v44, 0, 1, 2, 0.0);
      CFStringRef v6 = &v44;
      goto LABEL_63;
    case 38:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v43, (const UInt8 *)"HOAReverb_10_MediumHall2.ir", 27, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v43, 0, 1, 2, 0.0);
      CFStringRef v6 = &v43;
      goto LABEL_63;
    case 39:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v42, (const UInt8 *)"HOAReverb_11_MediumHall3.ir", 27, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v42, 0, 1, 2, 0.0);
      CFStringRef v6 = &v42;
      goto LABEL_63;
    case 40:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v41, (const UInt8 *)"HOAReverb_12_LargeHall2.ir", 26, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v41, 0, 1, 2, 0.0);
      CFStringRef v6 = &v41;
      goto LABEL_63;
    case 41:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v40, (const UInt8 *)"HOAReverb_13_Outside.ir", 23, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v40, 0, 1, 2, 0.0);
      CFStringRef v6 = &v40;
      goto LABEL_63;
    case 42:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v39, (const UInt8 *)"HOAReverb_14_OutsidePark.ir", 27, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v39, 0, 1, 2, 0.0);
      CFStringRef v6 = &v39;
      goto LABEL_63;
    case 43:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v38, (const UInt8 *)"HOAReverb_15_Office_50m3.ir", 27, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v38, 0, 1, 2, 0.0);
      CFStringRef v6 = &v38;
      goto LABEL_63;
    case 44:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v37, (const UInt8 *)"HOAReverb_16_TreatedRoom_133m3.ir", 33, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v37, 0, 1, 2, 0.0);
      CFStringRef v6 = &v37;
      goto LABEL_63;
    case 45:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v36, (const UInt8 *)"HOAReverb_17_Studio_200m3.ir", 28, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v36, 0, 1, 2, 0.0);
      CFStringRef v6 = &v36;
      goto LABEL_63;
    case 46:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v35, (const UInt8 *)"HOAReverb_18_TreatedRoom_500m3.ir", 33, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v35, 0, 1, 2, 0.0);
      CFStringRef v6 = &v35;
      goto LABEL_63;
    case 47:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v34, (const UInt8 *)"HOAReverb_19_LargeRoom_800m3.ir", 31, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v34, 0, 1, 2, 0.0);
      CFStringRef v6 = &v34;
      goto LABEL_63;
    case 48:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v33, (const UInt8 *)"HOAReverb_20_EmptyRoom.ir", 25, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v33, 0, 1, 2, 0.0);
      CFStringRef v6 = &v33;
      goto LABEL_63;
    case 49:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v32, (const UInt8 *)"HOAReverb_21_OfficeHallway.ir", 29, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v32, 0, 1, 2, 0.0);
      CFStringRef v6 = &v32;
      goto LABEL_63;
    case 50:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v31, (const UInt8 *)"HOAReverb_22_SmallTiledRoom.ir", 30, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v31, 0, 1, 2, 0.0);
      CFStringRef v6 = &v31;
      goto LABEL_63;
    case 51:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v30, (const UInt8 *)"HOAReverb_23_MediumTiledRoom.ir", 31, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v30, 0, 1, 2, 0.0);
      CFStringRef v6 = &v30;
      goto LABEL_63;
    case 52:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v25, (const UInt8 *)"ReverbBaseLibrary/ReverbBase_Small.ir", 37, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v25, 0, 1, 2, 0.0);
      CFStringRef v6 = &v25;
      goto LABEL_63;
    case 53:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v24, (const UInt8 *)"ReverbBaseLibrary/ReverbBase_Medium.ir", 38, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v24, 0, 1, 2, 0.0);
      CFStringRef v6 = &v24;
      goto LABEL_63;
    case 54:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v23, (const UInt8 *)"ReverbBaseLibrary/ReverbBase_Large.ir", 37, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v23, 0, 1, 2, 0.0);
      CFStringRef v6 = &v23;
      goto LABEL_63;
    case 55:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v29, (const UInt8 *)"HOA_Source_Extent.ir", 20, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v29, 0, 1, 2, 0.0);
      CFStringRef v6 = &v29;
      goto LABEL_63;
    case 56:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v27, (const UInt8 *)"Binaural_Source_Extent.ir", 25, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v27, 0, 1, 2, 0.0);
      CFStringRef v6 = &v27;
      goto LABEL_63;
    case 57:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v26, (const UInt8 *)"XTC_Source_Extent.ir", 20, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v26, 0, 1, 2, 0.0);
      CFStringRef v6 = &v26;
      goto LABEL_63;
    case 58:
      CFTypeRef v22 = 0;
      IR::IRDataAttributes::IRDataAttributes(a2, &v22, 0, 1, 2, 0.0);
      CFStringRef v6 = &v22;
      goto LABEL_63;
    case 59:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v21, (const UInt8 *)"SourceDirectivity_01_Person.ir", 30, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v21, 0, 1, 2, 0.0);
      CFStringRef v6 = &v21;
      goto LABEL_63;
    case 60:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v20, (const UInt8 *)"SourceDirectivity_02_Singer.ir", 30, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v20, 0, 1, 2, 0.0);
      CFStringRef v6 = &v20;
      goto LABEL_63;
    case 61:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v19, (const UInt8 *)"SourceDirectivity_03_Studio_Monitor_2_Way.ir", 44, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v19, 0, 1, 2, 0.0);
      CFStringRef v6 = &v19;
      goto LABEL_63;
    case 62:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v18, (const UInt8 *)"SourceDirectivity_04_Cardioid_Speaker_Array.ir", 46, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v18, 0, 1, 2, 0.0);
      CFStringRef v6 = &v18;
      goto LABEL_63;
    case 63:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v17, (const UInt8 *)"SourceDirectivity_05_Hyper_Cardioid.ir", 38, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v17, 0, 1, 2, 0.0);
      CFStringRef v6 = &v17;
      goto LABEL_63;
    case 64:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v16, (const UInt8 *)"SourceDirectivity_06_Acoustic_Guitar.ir", 39, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v16, 0, 1, 2, 0.0);
      CFStringRef v6 = &v16;
      goto LABEL_63;
    case 65:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v15, (const UInt8 *)"SourceDirectivity_07_Violin.ir", 30, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v15, 0, 1, 2, 0.0);
      CFStringRef v6 = &v15;
      goto LABEL_63;
    case 66:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v14, (const UInt8 *)"SourceDirectivity_08_Cello.ir", 29, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v14, 0, 1, 2, 0.0);
      CFStringRef v6 = &v14;
      goto LABEL_63;
    case 67:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v13, (const UInt8 *)"SourceDirectivity_09_Clarinet.ir", 32, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v13, 0, 1, 2, 0.0);
      CFStringRef v6 = &v13;
      goto LABEL_63;
    case 68:
      applesauce::CF::URLRef::URLRef((CFURLRef *)&v28, (const UInt8 *)"HOA_Near_Field_Compensation.ir", 30, (CFURLRef)v4);
      IR::IRDataAttributes::IRDataAttributes(a2, &v28, 128, 1, 2, 0.0);
      CFStringRef v6 = &v28;
      goto LABEL_63;
    default:
      applesauce::CF::URLRef::URLRef((uint64_t *)v74);
      IR::IRDataAttributes::IRDataAttributes(a2, v74, 128, 1, 2, 0.0);
      CFStringRef v6 = v74;
LABEL_63:
      applesauce::CF::URLRef::~URLRef(v6);
LABEL_64:
      CFRelease(v5);
      return;
  }
}

void sub_21B51E8EC(_Unwind_Exception *a1)
{
  applesauce::CF::URLRef::~URLRef((const void **)(v1 - 136));
  applesauce::CF::URLRef::~URLRef((const void **)(v1 - 104));
  if (*(char *)(v1 - 57) < 0) {
    operator delete(*(void **)(v1 - 80));
  }
  applesauce::CF::URLRef::~URLRef((const void **)(v1 - 40));
  _Unwind_Resume(a1);
}

uint64_t *applesauce::CF::URLRef::URLRef(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x21D48F200](0);
  *a1 = v2;
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51EDC8(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(const void **a1, char *__s)
{
  int v4 = *((char *)a1 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (v5 != strlen(__s)) {
    return 0;
  }
  if (v4 >= 0) {
    CFStringRef v6 = a1;
  }
  else {
    CFStringRef v6 = *a1;
  }
  return memcmp(v6, __s, v5) == 0;
}

CFURLRef *applesauce::CF::URLRef::URLRef(CFURLRef *a1, const UInt8 *a2, CFIndex a3, CFURLRef baseURL)
{
  CFURLRef v5 = CFURLCreateWithBytes(0, a2, a3, 0, baseURL);
  *a1 = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  return a1;
}

void sub_21B51EEEC(_Unwind_Exception *exception_object)
{
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(exception_object);
}

applesauce::CF::URLRef *applesauce::CF::URLRef::URLRef(applesauce::CF::URLRef *this, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  *(void *)this = v3;
  return this;
}

unint64_t applesauce::gestalt::query_as<unsigned int,0>()
{
  CFNumberRef v0 = (const __CFNumber *)MGCopyAnswerWithError();
  CFNumberRef v1 = v0;
  if (v0)
  {
    uint64_t v2 = applesauce::CF::convert_as<unsigned int,0>(v0);
    unsigned __int8 v3 = v2;
    int v4 = v2 & 0xFFFFFF00;
    unint64_t v5 = v2 & 0xFFFFFFFF00000000;
    unint64_t v6 = v2 & 0xFFFFFF0000000000;
    CFRelease(v1);
  }
  else
  {
    int v4 = 0;
    unsigned __int8 v3 = 0;
    unint64_t v5 = 0;
    unint64_t v6 = 0;
  }
  return v6 & 0xFFFFFF0000000000 | v5 & 0xFF00000000 | v4 & 0xFFFFFF00 | v3;
}

void *applesauce::CF::convert_to<std::string,0>@<X0>(const __CFString *a1@<X0>, uint64_t a2@<X8>)
{
  if (!a1 || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(a1)))
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::convert_error(exception);
  }

  return applesauce::CF::details::CFString_get_value<true>(a1, a2);
}

void sub_21B51F080()
{
}

void sub_21B51F0A0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

IR::FFTSubFilterData *IR::FFTSubFilterData::FFTSubFilterData(IR::FFTSubFilterData *this, unsigned int a2, unsigned int a3)
{
  *(_OWORD *)((char *)this + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0u;
  int v4 = (char *)this + 40;
  unint64_t v5 = (std::vector<unsigned int> *)((char *)this + 64);
  if (a2 <= 1) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = a2;
  }
  *(_OWORD *)((char *)this + 8) = 0uLL;
  *(_OWORD *)((char *)this + 72) = 0uLL;
  *(_OWORD *)((char *)this + 56) = 0uLL;
  *(_OWORD *)((char *)this + 24) = 0uLL;
  int v7 = a3 / v6;
  if (a3 / v6 * v6 < a3) {
    ++v7;
  }
  *(_DWORD *)this = v6;
  *((_DWORD *)this + 1) = v7;
  int v8 = v7 * v6;
  *((_DWORD *)this + 3) = v8;
  std::vector<float>::resize((uint64_t)this + 16, (2 * v8));
  std::vector<DSPSplitComplex>::resize((uint64_t)v4, *((unsigned int *)this + 1));
  std::vector<int>::resize(v5, *((unsigned int *)this + 1));
  int64_t v9 = (void *)*((void *)this + 5);
  std::string::size_type v10 = (void *)*((void *)this + 6);
  if (v9 != v10)
  {
    unsigned int v11 = 0;
    uint64_t v12 = *((void *)this + 2);
    int v13 = *(_DWORD *)this;
    int v14 = 2 * *(_DWORD *)this;
    do
    {
      *int64_t v9 = v12 + 4 * v11;
      v9[1] = v12 + 4 * (v13 + v11);
      v9 += 2;
      v11 += v14;
    }
    while (v9 != v10);
  }
  return this;
}

void sub_21B51F18C(_Unwind_Exception *a1)
{
  unsigned int v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 72) = v6;
    operator delete(v6);
  }
  IR::FFTSubFilterData::FFTSubFilterData(v3, v2, v1);
  _Unwind_Resume(a1);
}

IR::FFTSubFilterData *IR::FFTSubFilterData::FFTSubFilterData(IR::FFTSubFilterData *this, const IR::FFTSubFilterData *a2)
{
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 1std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  IR::FFTSubFilterData::operator=((char *)this, (uint64_t)a2);
  return this;
}

void sub_21B51F20C(_Unwind_Exception *a1)
{
  unint64_t v5 = *(void **)(v1 + 64);
  if (v5)
  {
    *(void *)(v1 + 72) = v5;
    operator delete(v5);
  }
  IR::FFTSubFilterData::FFTSubFilterData(v3, v2, v1);
  _Unwind_Resume(a1);
}

char *IR::FFTSubFilterData::operator=(char *a1, uint64_t a2)
{
  if ((char *)a2 != a1)
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a1 + 64, *(char **)(a2 + 64), *(void *)(a2 + 72), (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a1 + 16, *(char **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 2);
    std::vector<DSPSplitComplex>::__assign_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(a1 + 40, *(char **)(a2 + 40), *(void *)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 4);
    int v4 = (void *)*((void *)a1 + 5);
    unint64_t v5 = (void *)*((void *)a1 + 6);
    if (v4 != v5)
    {
      unsigned int v6 = 0;
      uint64_t v7 = *((void *)a1 + 2);
      int v8 = *(_DWORD *)a1;
      int v9 = 2 * *(_DWORD *)a1;
      do
      {
        *int v4 = v7 + 4 * v6;
        v4[1] = v7 + 4 * (v8 + v6);
        v4 += 2;
        v6 += v9;
      }
      while (v4 != v5);
    }
  }
  return a1;
}

__n128 IR::FFTSubFilterData::FFTSubFilterData(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a1 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 4std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  __n128 result = *(__n128 *)(a2 + 64);
  *(__n128 *)(a1 + 64) = result;
  *(void *)(a1 + 8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = *(void *)(a2 + 80);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  return result;
}

_OWORD *IR::FFTSubFilterData::operator=(_OWORD *a1, uint64_t a2)
{
  *a1 = *(_OWORD *)a2;
  std::vector<float>::__move_assign((uint64_t)(a1 + 1), (__n128 *)(a2 + 16));
  std::vector<float>::__move_assign((uint64_t)a1 + 40, (__n128 *)(a2 + 40));
  std::vector<float>::__move_assign((uint64_t)(a1 + 4), (__n128 *)(a2 + 64));
  return a1;
}

uint64_t IR::FFTSubFilterData::SetFilter(IR::FFTSubFilterData *this, const float *a2, unsigned int a3, float a4, MultiRadixRealFFT *a5)
{
  return IR::FFTSubFilterData::setFilter((unsigned int *)this, (uint64_t)a2, a3, a5, 0, 0, a4);
}

uint64_t IR::FFTSubFilterData::setFilter(unsigned int *a1, uint64_t a2, unsigned int a3, MultiRadixRealFFT *this, uint64_t a5, unsigned int a6, float a7)
{
  uint64_t v40 = a2;
  v42[1] = *MEMORY[0x263EF8340];
  if (a1[3] < a3) {
    return 4294967246;
  }
  unsigned int v13 = a3 % *a1;
  if (v13) {
    int v14 = a3 / *a1 + 1;
  }
  else {
    int v14 = a3 / *a1;
  }
  a1[2] = v14;
  v42[0] = 0;
  if (!this || MultiRadixRealFFT::Size(this) != 2 * *a1) {
    operator new();
  }
  unsigned int v15 = MultiRadixRealFFT::Size(this);
  LODWORD(v16) = a1[2];
  if (v16)
  {
    unint64_t v17 = 0;
    unsigned int v18 = 0;
    uint64_t v19 = a5;
    float v20 = a7 / (float)v15;
    uint64_t v21 = v13 >> 1;
    BOOL v22 = *(float *)&v19 != 0.0;
    if (*((float *)&v19 + 1) != 0.0) {
      BOOL v22 = 1;
    }
    if (a6) {
      BOOL v22 = 1;
    }
    unsigned int v38 = v13 - 1;
    BOOL v39 = v22;
    do
    {
      CFTypeRef v23 = (const DSPComplex *)(v40 + 4 * v18);
      CFTypeRef v24 = (const DSPSplitComplex *)(*((void *)a1 + 5) + 16 * v17);
      if (v13 && v17 == v16 - 1)
      {
        vDSP_ctoz(v23, 2, v24, 1, v13 >> 1);
        bzero((void *)(*(void *)(*((void *)a1 + 5) + 16 * v17) + 4 * v21), 4 * (*a1 - v21));
        bzero((void *)(*(void *)(*((void *)a1 + 5) + 16 * v17 + 8) + 4 * v21), 4 * (*a1 - v21));
        uint64_t v25 = *((void *)a1 + 5);
        if (v13) {
          *(_DWORD *)(*(void *)(v25 + 16 * v17) + 4 * v21) = *(_DWORD *)(v40 + 4 * (v38 + v18));
        }
      }
      else
      {
        vDSP_ctoz(v23, 2, v24, 1, (unint64_t)*a1 >> 1);
        bzero((void *)(*(void *)(*((void *)a1 + 5) + 16 * v17) + ((2 * *a1) & 0x1FFFFFFFCLL)), 2 * *a1);
        bzero((void *)(*(void *)(*((void *)a1 + 5) + 16 * v17 + 8) + ((2 * *a1) & 0x1FFFFFFFCLL)), 2 * *a1);
        uint64_t v25 = *((void *)a1 + 5);
      }
      uint64_t v26 = MultiRadixRealFFT::RealInPlaceTransform(this, (DSPSplitComplex *)(v25 + 16 * v17), 1, v20);
      int v27 = *a1;
      if (v39)
      {
        MEMORY[0x270FA5388](v26);
        CFTypeRef v29 = (char *)&v37 - ((v28 + 15) & 0x7FFFFFFF0);
        vDSP_zvmags((const DSPSplitComplex *)(*((void *)a1 + 5) + 16 * v17), 1, (float *)v29, 1, *a1);
        float v30 = 0.0;
        if (*((float *)&v19 + 1) > 0.0)
        {
          __C[0] = 0.0;
          vDSP_maxv((const float *)v29 + 1, 1, __C, *a1 - 1);
          float v30 = (float)(*((float *)&v19 + 1) * *((float *)&v19 + 1)) * __C[0];
        }
        LODWORD(v31) = *a1;
        if (*a1 <= a6 || a6 == 0) {
          uint64_t v31 = v31;
        }
        else {
          uint64_t v31 = a6;
        }
        if (v31)
        {
          while (1)
          {
            float v33 = *(float *)&v29[4 * v31];
            if (v33 > (float)(v20 * (float)((float)(*(float *)&v19 * *(float *)&v19) * v20)) && v33 > v30) {
              break;
            }
            if (!--v31) {
              goto LABEL_40;
            }
          }
          if (v31 < 2) {
            LODWORD(v31) = 0;
          }
        }
LABEL_40:
        *(_DWORD *)(*((void *)a1 + 8) + 4 * v17) = v31;
      }
      else
      {
        *(_DWORD *)(*((void *)a1 + 8) + 4 * v17) = v27;
      }
      v18 += v27;
      ++v17;
      unint64_t v16 = a1[2];
    }
    while (v17 < v16);
  }
  uint64_t v7 = 0;
  uint64_t v35 = v42[0];
  v42[0] = 0;
  if (v35) {
    std::default_delete<MultiRadixRealFFT>::operator()[abi:ne180100]((uint64_t)v42, v35);
  }
  return v7;
}

void sub_21B51F75C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 128);
  *(void *)(v1 - 128) = 0;
  if (v3) {
    std::default_delete<MultiRadixRealFFT>::operator()[abi:ne180100](v1 - 128, v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::FFTSubFilterData::accumulate(uint64_t a1, uint64_t a2, float a3)
{
  float __B = a3;
  if (*(_DWORD *)a2 == *(_DWORD *)a1)
  {
    if (*(_DWORD *)(a2 + 8) >= *(_DWORD *)(a1 + 4)) {
      unsigned int v5 = *(_DWORD *)(a1 + 4);
    }
    else {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
    }
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = *(void *)(a2 + 64);
      uint64_t v8 = 8;
      do
      {
        vDSP_vsma(*(const float **)(*(void *)(a2 + 40) + v8 - 8), 1, &__B, *(const float **)(*(void *)(a1 + 40) + v8 - 8), 1, *(float **)(*(void *)(a1 + 40) + v8 - 8), 1, *(unsigned int *)(v7 + v6));
        vDSP_vsma(*(const float **)(*(void *)(a2 + 40) + v8), 1, &__B, *(const float **)(*(void *)(a1 + 40) + v8), 1, *(float **)(*(void *)(a1 + 40) + v8), 1, *(unsigned int *)(*(void *)(a2 + 64) + v6));
        uint64_t v9 = *(void *)(a1 + 64);
        uint64_t v7 = *(void *)(a2 + 64);
        unsigned int v10 = *(_DWORD *)(v9 + v6);
        if (v10 <= *(_DWORD *)(v7 + v6)) {
          unsigned int v10 = *(_DWORD *)(v7 + v6);
        }
        *(_DWORD *)(v9 + v6) = v10;
        v8 += 16;
        v6 += 4;
      }
      while (4 * v5 != v6);
    }
    uint64_t result = 0;
    if (v5 > *(_DWORD *)(a1 + 8)) {
      *(_DWORD *)(a1 + 8) = v5;
    }
  }
  else
  {
    bzero(*(void **)(a1 + 16), *(void *)(a1 + 24) - *(void *)(a1 + 16));
    *(_DWORD *)(a1 + 8) = 0;
    return 4294967246;
  }
  return result;
}

void IR::FFTSubFilterData::reset(void **this)
{
  *((_DWORD *)this + 2) = 0;
}

uint64_t IR::FFTSubFilterData::overwrite(IR::FFTSubFilterData *this, const IR::FFTSubFilterData *a2, float a3)
{
  float __B = a3;
  if (*(_DWORD *)a2 == *(_DWORD *)this)
  {
    unsigned int v5 = *((_DWORD *)a2 + 2);
    unsigned int v6 = *((_DWORD *)this + 1);
    if (v5 >= v6) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = v5;
    }
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8;
      do
      {
        vDSP_vsmul(*(const float **)(*((void *)a2 + 5) + v9 - 8), 1, &__B, *(float **)(*((void *)this + 5) + v9 - 8), 1, *(unsigned int *)this);
        vDSP_vsmul(*(const float **)(*((void *)a2 + 5) + v9), 1, &__B, *(float **)(*((void *)this + 5) + v9), 1, *(unsigned int *)this);
        *(_DWORD *)(*((void *)this + 8) + v8) = *(_DWORD *)(*((void *)a2 + 8) + v8);
        v9 += 16;
        v8 += 4;
      }
      while (4 * v7 != v8);
      unsigned int v6 = *((_DWORD *)this + 1);
    }
    if (v7 < v6)
    {
      uint64_t v10 = 16 * v7;
      unint64_t v11 = v7;
      do
      {
        bzero(*(void **)(*((void *)this + 5) + v10), 4 * (2 * *(_DWORD *)this));
        ++v11;
        v10 += 16;
      }
      while (v11 < *((unsigned int *)this + 1));
    }
    uint64_t result = 0;
  }
  else
  {
    bzero(*((void **)this + 2), *((void *)this + 3) - *((void *)this + 2));
    LODWORD(v7) = 0;
    uint64_t result = 4294967246;
  }
  *((_DWORD *)this + 2) = v7;
  return result;
}

uint64_t IR::FFTSubFilterData::scale(IR::FFTSubFilterData *this, float a2)
{
  float __B = a2;
  if (*((_DWORD *)this + 1))
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      vDSP_vsmul(*(const float **)(*((void *)this + 5) + v3), 1, &__B, *(float **)(*((void *)this + 5) + v3), 1, *(unsigned int *)this);
      unsigned int v5 = *(float **)(*((void *)this + 5) + v3 + 8);
      vDSP_vsmul(v5, 1, &__B, v5, 1, *(unsigned int *)this);
      ++v4;
      v3 += 16;
    }
    while (v4 < *((unsigned int *)this + 1));
  }
  return 0;
}

char *std::vector<DSPSplitComplex>::__assign_with_size[abi:ne180100]<DSPSplitComplex*,DSPSplitComplex*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<std::shared_ptr<IR::VBAPTriangulationKernel>>::__vallocate[abi:ne180100](v7, v11);
    unsigned int v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unsigned int v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  int v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unsigned int v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void std::default_delete<MultiRadixRealFFT>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a2 + 8);
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    }
    JUMPOUT(0x21D48F780);
  }
}

BOOL ChannelLayoutTagIsSupportedHOA(int a1)
{
  if (a1 == 7012356) {
    return 1;
  }
  if ((a1 & 0xFFFE0000 | 0x10000) != 0xBF0000 || (unsigned __int16)a1 - 65026 < 0xFFFF01FF) {
    return 0;
  }
  double v2 = sqrt((double)(unsigned __int16)a1);
  return vabdd_f64(v2, round(v2)) <= 0.000000999999997;
}

BOOL ChannelLayoutTagIsHOAWithAnyNumberOfChannels(int a1)
{
  BOOL v1 = (a1 & 0xFFFF0000) == 12517376;
  if ((a1 & 0xFFFF0000) == 0xBE0000) {
    BOOL v1 = 1;
  }
  return (a1 & 0xFFFF0000) == 0x6B0000 || v1;
}

uint64_t GetAudioChannelLayoutTagAmbisonicOrder(int a1)
{
  if (a1 == 7012356) {
    return 1;
  }
  if ((a1 & 0xFFFE0000 | 0x10000) != 0xBF0000) {
    return 0;
  }
  int v2 = llroundf(sqrtf((float)(unsigned __int16)a1));
  BOOL v3 = v2 * v2 == (unsigned __int16)a1;
  BOOL v4 = v2 != 0;
  unsigned int v5 = v2 - 1;
  int v6 = v4;
  if ((v6 & v3) != 0) {
    return v5;
  }
  else {
    return 0;
  }
}

void GetStringFromAudioChannelLayoutTag(int a1@<W0>, void *a2@<X8>)
{
  unsigned __int16 v2 = a1;
  unsigned int v4 = a1 & 0xFFFF0000;
  if ((a1 & 0xFFFF0000) == 0x930000)
  {
    std::string::basic_string[abi:ne180100]<0>(&v21, "DiscreteInOrder");
    unint64_t v11 = std::string::append(&v21, " ", 1uLL);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
  }
  else if (v4 == 12517376)
  {
    int v13 = llroundf(sqrtf((float)(unsigned __int16)a1));
    if (v13) {
      BOOL v14 = v13 * v13 == (unsigned __int16)a1;
    }
    else {
      BOOL v14 = 0;
    }
    if (!v14) {
      goto LABEL_25;
    }
    std::string::basic_string[abi:ne180100]<0>(&v21, "HOA_ACN_N3D");
    unint64_t v16 = std::string::append(&v21, " ", 1uLL);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v13 - 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
  }
  else
  {
    if (v4 != 12451840)
    {
      if (a1 <= 10027011)
      {
        if (a1 > 8126469)
        {
          if (a1 <= 9043972)
          {
            if (a1 > 8585218)
            {
              if (a1 <= 8781827)
              {
                switch(a1)
                {
                  case 8585219:
                    unint64_t v15 = "ITU_2_1";
                    goto LABEL_26;
                  case 8650756:
                    unint64_t v15 = "ITU_2_2";
                    goto LABEL_26;
                  case 8716291:
                    unint64_t v15 = "DVD_4";
                    goto LABEL_26;
                }
              }
              else if (a1 > 8912899)
              {
                if (a1 == 8912900)
                {
                  unint64_t v15 = "DVD_10";
                  goto LABEL_26;
                }
                if (a1 == 8978437)
                {
                  unint64_t v15 = "DVD_11";
                  goto LABEL_26;
                }
              }
              else
              {
                if (a1 == 8781828)
                {
                  unint64_t v15 = "DVD_5";
                  goto LABEL_26;
                }
                if (a1 == 8847365)
                {
                  unint64_t v15 = "DVD_6";
                  goto LABEL_26;
                }
              }
            }
            else if (a1 <= 8323079)
            {
              switch(a1)
              {
                case 8126470:
                  unint64_t v15 = "MPEG_5_1_D";
                  goto LABEL_26;
                case 8192007:
                  unint64_t v15 = "MPEG_6_1_A";
                  goto LABEL_26;
                case 8257544:
                  unint64_t v15 = "MPEG_7_1_A";
                  goto LABEL_26;
              }
            }
            else if (a1 > 8454151)
            {
              if (a1 == 8454152)
              {
                unint64_t v15 = "Emagic_Default_7_1";
                goto LABEL_26;
              }
              if (a1 == 8519688)
              {
                unint64_t v15 = "SMPTE_DTV";
                goto LABEL_26;
              }
            }
            else
            {
              if (a1 == 8323080)
              {
                unint64_t v15 = "MPEG_7_1_B";
                goto LABEL_26;
              }
              if (a1 == 8388616)
              {
                unint64_t v15 = "MPEG_7_1_C";
                goto LABEL_26;
              }
            }
          }
          else if (a1 <= 9502735)
          {
            if (a1 <= 9240581)
            {
              switch(a1)
              {
                case 9043973:
                  unint64_t v15 = "DVD_18";
                  goto LABEL_26;
                case 9109510:
                  unint64_t v15 = "AudioUnit_6_0";
                  goto LABEL_26;
                case 9175047:
                  unint64_t v15 = "AudioUnit_7_0";
                  goto LABEL_26;
              }
            }
            else if (a1 > 9371654)
            {
              if (a1 == 9371655)
              {
                unint64_t v15 = "AAC_7_0";
                goto LABEL_26;
              }
              if (a1 == 9437192)
              {
                unint64_t v15 = "AAC_Octagonal";
                goto LABEL_26;
              }
            }
            else
            {
              if (a1 == 9240582)
              {
                unint64_t v15 = "AAC_6_0";
                goto LABEL_26;
              }
              if (a1 == 9306119)
              {
                unint64_t v15 = "AAC_6_1";
                goto LABEL_26;
              }
            }
          }
          else if (a1 > 9764865)
          {
            if (a1 > 9895939)
            {
              if (a1 == 9895940)
              {
                unint64_t v15 = "AC3_3_1";
                goto LABEL_26;
              }
              if (a1 == 9961476)
              {
                unint64_t v15 = "AC3_3_0_1";
                goto LABEL_26;
              }
            }
            else
            {
              if (a1 == 9764866)
              {
                unint64_t v15 = "AC3_1_0_1";
                goto LABEL_26;
              }
              if (a1 == 9830403)
              {
                unint64_t v15 = "AC3_3_0";
                goto LABEL_26;
              }
            }
          }
          else if (a1 >= 9633792)
          {
            if (a1 == 9633792)
            {
              unint64_t v15 = "DiscreteInOrder";
              goto LABEL_26;
            }
            if (a1 == 9699335)
            {
              unint64_t v15 = "AudioUnit_7_0_Front";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 9502736)
            {
              unint64_t v15 = "TMH_10_2_std";
              goto LABEL_26;
            }
            if (a1 == 9568277)
            {
              unint64_t v15 = "TMH_10_2_full";
              goto LABEL_26;
            }
          }
        }
        else if (a1 <= 7143428)
        {
          if (a1 > 6684673)
          {
            if (a1 <= 6881281)
            {
              switch(a1)
              {
                case 6684674:
                  unint64_t v15 = "StereoHeadphones";
                  goto LABEL_26;
                case 6750210:
                  unint64_t v15 = "MatrixStereo";
                  goto LABEL_26;
                case 6815746:
                  unint64_t v15 = "MidSide";
                  goto LABEL_26;
              }
            }
            else if (a1 > 7012355)
            {
              if (a1 == 7012356)
              {
                unint64_t v15 = "Ambisonic_B_Format";
                goto LABEL_26;
              }
              if (a1 == 7077892)
              {
                unint64_t v15 = "Quadraphonic";
                goto LABEL_26;
              }
            }
            else
            {
              if (a1 == 6881282)
              {
                unint64_t v15 = "XY";
                goto LABEL_26;
              }
              if (a1 == 6946818)
              {
                unint64_t v15 = "Binaural";
                goto LABEL_26;
              }
            }
          }
          else if (a1 < 0)
          {
            if (a1 == -268435456)
            {
              unint64_t v15 = "BeginReserved";
              goto LABEL_26;
            }
            if (a1 == -65537)
            {
              unint64_t v15 = "EndReserved";
              goto LABEL_26;
            }
          }
          else if (a1 > 6553600)
          {
            if (a1 == 6553601)
            {
              unint64_t v15 = "Mono";
              goto LABEL_26;
            }
            if (a1 == 6619138)
            {
              unint64_t v15 = "Stereo";
              goto LABEL_26;
            }
          }
          else
          {
            if (!a1)
            {
              unint64_t v15 = "UseChannelDescriptions";
              goto LABEL_26;
            }
            if (a1 == 0x10000)
            {
              unint64_t v15 = "UseChannelBitmap";
              goto LABEL_26;
            }
          }
        }
        else if (a1 <= 7602179)
        {
          if (a1 <= 7340039)
          {
            switch(a1)
            {
              case 7143429:
                unint64_t v15 = "Pentagonal";
                goto LABEL_26;
              case 7208966:
                unint64_t v15 = "Hexagonal";
                goto LABEL_26;
              case 7274504:
                unint64_t v15 = "Octagonal";
                goto LABEL_26;
            }
          }
          else if (a1 > 7471106)
          {
            if (a1 == 7471107)
            {
              unint64_t v15 = "MPEG_3_0_B";
              goto LABEL_26;
            }
            if (a1 == 7536644)
            {
              unint64_t v15 = "MPEG_4_0_A";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 7340040)
            {
              unint64_t v15 = "Cube";
              goto LABEL_26;
            }
            if (a1 == 7405571)
            {
              unint64_t v15 = "MPEG_3_0_A";
              goto LABEL_26;
            }
          }
        }
        else if (a1 > 7864324)
        {
          if (a1 > 7995397)
          {
            if (a1 == 7995398)
            {
              unint64_t v15 = "MPEG_5_1_B";
              goto LABEL_26;
            }
            if (a1 == 8060934)
            {
              unint64_t v15 = "MPEG_5_1_C";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 7864325)
            {
              unint64_t v15 = "MPEG_5_0_D";
              goto LABEL_26;
            }
            if (a1 == 7929862)
            {
              unint64_t v15 = "MPEG_5_1_A";
              goto LABEL_26;
            }
          }
        }
        else if (a1 > 7733252)
        {
          if (a1 == 7733253)
          {
            unint64_t v15 = "MPEG_5_0_B";
            goto LABEL_26;
          }
          if (a1 == 7798789)
          {
            unint64_t v15 = "MPEG_5_0_C";
            goto LABEL_26;
          }
        }
        else
        {
          if (a1 == 7602180)
          {
            unint64_t v15 = "MPEG_4_0_B";
            goto LABEL_26;
          }
          if (a1 == 7667717)
          {
            unint64_t v15 = "MPEG_5_0_A";
            goto LABEL_26;
          }
        }
      }
      else if (a1 <= 11927558)
      {
        if (a1 <= 10944519)
        {
          if (a1 > 10485767)
          {
            if (a1 <= 10682375)
            {
              switch(a1)
              {
                case 10485768:
                  unint64_t v15 = "EAC3_7_1_A";
                  goto LABEL_26;
                case 10551304:
                  unint64_t v15 = "EAC3_7_1_B";
                  goto LABEL_26;
                case 10616840:
                  unint64_t v15 = "EAC3_7_1_C";
                  goto LABEL_26;
              }
            }
            else if (a1 > 10813447)
            {
              if (a1 == 10813448)
              {
                unint64_t v15 = "EAC3_7_1_F";
                goto LABEL_26;
              }
              if (a1 == 10878984)
              {
                unint64_t v15 = "EAC3_7_1_G";
                goto LABEL_26;
              }
            }
            else
            {
              if (a1 == 10682376)
              {
                unint64_t v15 = "EAC3_7_1_D";
                goto LABEL_26;
              }
              if (a1 == 10747912)
              {
                unint64_t v15 = "EAC3_7_1_E";
                goto LABEL_26;
              }
            }
          }
          else if (a1 <= 10223622)
          {
            switch(a1)
            {
              case 10027012:
                unint64_t v15 = "AC3_2_1_1";
                goto LABEL_26;
              case 10092549:
                unint64_t v15 = "AC3_3_1_1";
                goto LABEL_26;
              case 10158086:
                unint64_t v15 = "EAC_6_0_A";
                goto LABEL_26;
            }
          }
          else if (a1 > 10354694)
          {
            if (a1 == 10354695)
            {
              unint64_t v15 = "EAC3_6_1_B";
              goto LABEL_26;
            }
            if (a1 == 10420231)
            {
              unint64_t v15 = "EAC3_6_1_C";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 10223623)
            {
              unint64_t v15 = "EAC_7_0_A";
              goto LABEL_26;
            }
            if (a1 == 10289159)
            {
              unint64_t v15 = "EAC3_6_1_A";
              goto LABEL_26;
            }
          }
        }
        else if (a1 <= 11403270)
        {
          if (a1 <= 11141125)
          {
            switch(a1)
            {
              case 10944520:
                unint64_t v15 = "EAC3_7_1_H";
                goto LABEL_26;
              case 11010052:
                unint64_t v15 = "DTS_3_1";
                goto LABEL_26;
              case 11075589:
                unint64_t v15 = "DTS_4_1";
                goto LABEL_26;
            }
          }
          else if (a1 > 11272197)
          {
            if (a1 == 11272198)
            {
              unint64_t v15 = "DTS_6_0_C";
              goto LABEL_26;
            }
            if (a1 == 11337735)
            {
              unint64_t v15 = "DTS_6_1_A";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 11141126)
            {
              unint64_t v15 = "DTS_6_0_A";
              goto LABEL_26;
            }
            if (a1 == 11206662)
            {
              unint64_t v15 = "DTS_6_0_B";
              goto LABEL_26;
            }
          }
        }
        else if (a1 > 11665415)
        {
          if (a1 > 11796488)
          {
            if (a1 == 11796489)
            {
              unint64_t v15 = "DTS_8_1_A";
              goto LABEL_26;
            }
            if (a1 == 11862025)
            {
              unint64_t v15 = "DTS_8_1_B";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 11665416)
            {
              unint64_t v15 = "DTS_8_0_A";
              goto LABEL_26;
            }
            if (a1 == 11730952)
            {
              unint64_t v15 = "DTS_8_0_B";
              goto LABEL_26;
            }
          }
        }
        else if (a1 > 11534342)
        {
          if (a1 == 11534343)
          {
            unint64_t v15 = "DTS_7_0";
            goto LABEL_26;
          }
          if (a1 == 11599880)
          {
            unint64_t v15 = "DTS_7_1";
            goto LABEL_26;
          }
        }
        else
        {
          if (a1 == 11403271)
          {
            unint64_t v15 = "DTS_6_1_B";
            goto LABEL_26;
          }
          if (a1 == 11468807)
          {
            unint64_t v15 = "DTS_6_1_C";
            goto LABEL_26;
          }
        }
      }
      else if (a1 > 12910595)
      {
        if (a1 <= 13369367)
        {
          if (a1 <= 13107206)
          {
            switch(a1)
            {
              case 12910596:
                unint64_t v15 = "Logic_4_0_C";
                goto LABEL_26;
              case 12976134:
                unint64_t v15 = "Logic_6_0_B";
                goto LABEL_26;
              case 13041671:
                unint64_t v15 = "Logic_6_1_B";
                goto LABEL_26;
            }
          }
          else if (a1 > 13238283)
          {
            if (a1 == 13238284)
            {
              unint64_t v15 = "Logic_Atmos_7_1_4_B";
              goto LABEL_26;
            }
            if (a1 == 13303822)
            {
              unint64_t v15 = "Logic_Atmos_7_1_6";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 13107207)
            {
              unint64_t v15 = "Logic_6_1_D";
              goto LABEL_26;
            }
            if (a1 == 13172744)
            {
              unint64_t v15 = "Logic_7_1_B";
              goto LABEL_26;
            }
          }
        }
        else if (a1 > 13631499)
        {
          if (a1 > 13762571)
          {
            if (a1 == 13762572)
            {
              unint64_t v15 = "CICP_19";
              goto LABEL_26;
            }
            if (a1 == 13828110)
            {
              unint64_t v15 = "CICP_20";
              goto LABEL_26;
            }
          }
          else
          {
            if (a1 == 13631500)
            {
              unint64_t v15 = "CICP_17";
              goto LABEL_26;
            }
            if (a1 == 13697038)
            {
              unint64_t v15 = "CICP_18";
              goto LABEL_26;
            }
          }
        }
        else if (a1 > 13500427)
        {
          if (a1 == 13500428)
          {
            unint64_t v15 = "CICP_15";
            goto LABEL_26;
          }
          if (a1 == 13565962)
          {
            unint64_t v15 = "CICP_16";
            goto LABEL_26;
          }
        }
        else
        {
          if (a1 == 13369368)
          {
            unint64_t v15 = "CICP_13";
            goto LABEL_26;
          }
          if (a1 == 13434888)
          {
            unint64_t v15 = "CICP_14";
            goto LABEL_26;
          }
        }
      }
      else if (a1 <= 12386311)
      {
        if (a1 <= 12124163)
        {
          switch(a1)
          {
            case 11927559:
              unint64_t v15 = "DTS_6_1_D";
              goto LABEL_26;
            case 11993096:
              unint64_t v15 = "AAC_7_1_B";
              goto LABEL_26;
            case 12058632:
              unint64_t v15 = "AAC_7_1_C";
              goto LABEL_26;
          }
        }
        else if (a1 > 12255237)
        {
          if (a1 == 12255238)
          {
            unint64_t v15 = "WAVE_5_1_B";
            goto LABEL_26;
          }
          if (a1 == 12320775)
          {
            unint64_t v15 = "WAVE_6_1";
            goto LABEL_26;
          }
        }
        else
        {
          if (a1 == 12124164)
          {
            unint64_t v15 = "WAVE_4_0_B";
            goto LABEL_26;
          }
          if (a1 == 12189701)
          {
            unint64_t v15 = "WAVE_5_0_B";
            goto LABEL_26;
          }
        }
      }
      else if (a1 > 12648463)
      {
        if (a1 > 12779529)
        {
          if (a1 == 12779530)
          {
            unint64_t v15 = "Atmos_5_1_4";
            goto LABEL_26;
          }
          if (a1 == 12845066)
          {
            unint64_t v15 = "Atmos_7_1_2";
            goto LABEL_26;
          }
        }
        else
        {
          if (a1 == 12648464)
          {
            unint64_t v15 = "Atmos_9_1_6";
            goto LABEL_26;
          }
          if (a1 == 12713992)
          {
            unint64_t v15 = "Atmos_5_1_2";
            goto LABEL_26;
          }
        }
      }
      else if (a1 >= 12517376)
      {
        if (a1 == 12517376)
        {
          unint64_t v15 = "HOA_ACN_N3D";
          goto LABEL_26;
        }
        if (a1 == 12582924)
        {
          unint64_t v15 = "Atmos_7_1_4";
          goto LABEL_26;
        }
      }
      else
      {
        if (a1 == 12386312)
        {
          unint64_t v15 = "WAVE_7_1";
          goto LABEL_26;
        }
        if (a1 == 12451840)
        {
          unint64_t v15 = "HOA_ACN_SN3D";
          goto LABEL_26;
        }
      }
LABEL_25:
      unint64_t v15 = "Unknown";
LABEL_26:
      std::string::basic_string[abi:ne180100]<0>(a2, v15);
      return;
    }
    int v5 = llroundf(sqrtf((float)(unsigned __int16)a1));
    if (v5) {
      BOOL v6 = v5 * v5 == (unsigned __int16)a1;
    }
    else {
      BOOL v6 = 0;
    }
    if (!v6) {
      goto LABEL_25;
    }
    std::string::basic_string[abi:ne180100]<0>(&v21, "HOA_ACN_SN3D");
    unint64_t v7 = std::string::append(&v21, " ", 1uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, v5 - 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
  }
  unsigned int v18 = std::string::append(&v22, (const std::string::value_type *)p_p, size);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  a2[2] = *((void *)&v18->__r_.__value_.__l + 2);
  *(_OWORD *)a2 = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
}

void sub_21B520F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutSphericalCoordinates(const AudioChannelLayout *a1@<X0>, void *a2@<X8>)
{
  std::string __p = 0;
  std::string v72 = 0;
  CFTypeRef v73 = 0;
  CFTypeRef v68 = 0;
  uint64_t v69 = 0;
  std::string v70 = 0;
  CFTypeRef v65 = 0;
  CFTypeRef v66 = 0;
  CFTypeRef v67 = 0;
  if (a1->mChannelLayoutTag == 0x10000)
  {
    uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)a1->mChannelBitmap);
    v17.i16[0] = vaddlv_u8(v17);
    unsigned int v18 = v17.i32[0];
LABEL_24:
    LOBYTE(inSpecifier) = 0;
    std::vector<char>::vector(&outPropertyData, 0x20uLL, (const std::vector<char>::value_type *)&inSpecifier);
    std::vector<char>::pointer begin = outPropertyData.__begin_;
    *(void *)outPropertyData.__begin_ = 0;
    *((_DWORD *)begin + 2) = 0;
    if (v18 <= 1) {
      int v20 = 1;
    }
    else {
      int v20 = v18;
    }
    unint64_t v21 = (20 * v20 + 12);
    LOBYTE(inSpecifier) = 0;
    int end = (int)outPropertyData.__end_;
    if (v21 <= outPropertyData.__end_ - begin)
    {
      if (v21 < outPropertyData.__end_ - begin)
      {
        int end = begin + v21;
        outPropertyData.__end_ = &begin[v21];
      }
    }
    else
    {
      std::vector<char>::__append(&outPropertyData, v21 - (outPropertyData.__end_ - begin), (std::vector<char>::const_reference)&inSpecifier);
      std::vector<char>::pointer begin = outPropertyData.__begin_;
      int end = (int)outPropertyData.__end_;
    }
    *((_DWORD *)begin + 2) = v18;
    AudioChannelLayoutTag mChannelLayoutTag = a1->mChannelLayoutTag;
    UInt32 inSpecifier = end - begin;
    if (mChannelLayoutTag == 0x10000) {
      AudioFormatPropertyID v24 = 1668116578;
    }
    else {
      AudioFormatPropertyID v24 = 1668116588;
    }
    if (mChannelLayoutTag == 0x10000) {
      p_mChannelBitmap = (const AudioChannelLayout *)&a1->mChannelBitmap;
    }
    else {
      p_mChannelBitmap = a1;
    }
    AudioFormatGetProperty(v24, 4u, p_mChannelBitmap, &inSpecifier, begin);
    uint64_t v26 = outPropertyData.__begin_;
    unint64_t v27 = *((unsigned int *)outPropertyData.__begin_ + 2);
    if (v27 > (outPropertyData.__end_ - outPropertyData.__begin_ - 12) / 0x14uLL) {
LABEL_89:
    }
      __assert_rtn("GetNumberChannelDescriptions", "CoreAudioBaseTypes.hpp", 2237, "GetAudioChannelLayout().mNumberChannelDescriptions <= (mStorage.size() - kHeaderSize) / sizeof(AudioChannelDescription)");
    unint64_t v28 = 0;
    while (v28 < v27)
    {
      CFTypeRef v29 = &v26[20 * v28 + 20];
      float v30 = v72;
      if (v72 >= v73)
      {
        CFTypeRef v32 = (char *)__p;
        uint64_t v33 = (v72 - (unsigned char *)__p) >> 2;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 62) {
          goto LABEL_98;
        }
        uint64_t v35 = v73 - (unsigned char *)__p;
        if ((v73 - (unsigned char *)__p) >> 1 > v34) {
          unint64_t v34 = v35 >> 1;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v36 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36)
        {
          uint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v73, v36);
          CFTypeRef v32 = (char *)__p;
          float v30 = v72;
        }
        else
        {
          uint64_t v37 = 0;
        }
        unsigned int v38 = &v37[4 * v33];
        *(_DWORD *)unsigned int v38 = *(_DWORD *)v29;
        uint64_t v31 = v38 + 4;
        while (v30 != v32)
        {
          int v39 = *((_DWORD *)v30 - 1);
          v30 -= 4;
          *((_DWORD *)v38 - 1) = v39;
          v38 -= 4;
        }
        std::string __p = v38;
        std::string v72 = v31;
        CFTypeRef v73 = &v37[4 * v36];
        if (v32) {
          operator delete(v32);
        }
      }
      else
      {
        *(_DWORD *)std::string v72 = *(_DWORD *)v29;
        uint64_t v31 = v30 + 4;
      }
      std::string v72 = v31;
      uint64_t v40 = &outPropertyData.__begin_[20 * v28 + 24];
      CFTypeRef v41 = v69;
      if (v69 >= v70)
      {
        CFTypeRef v43 = (char *)v68;
        uint64_t v44 = (v69 - (unsigned char *)v68) >> 2;
        unint64_t v45 = v44 + 1;
        if ((unint64_t)(v44 + 1) >> 62) {
          goto LABEL_98;
        }
        uint64_t v46 = v70 - (unsigned char *)v68;
        if ((v70 - (unsigned char *)v68) >> 1 > v45) {
          unint64_t v45 = v46 >> 1;
        }
        if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v47 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v47 = v45;
        }
        if (v47)
        {
          CFTypeRef v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v70, v47);
          CFTypeRef v43 = (char *)v68;
          CFTypeRef v41 = v69;
        }
        else
        {
          CFTypeRef v48 = 0;
        }
        CFTypeRef v49 = &v48[4 * v44];
        *(_DWORD *)CFTypeRef v49 = *(_DWORD *)v40;
        CFTypeRef v42 = v49 + 4;
        while (v41 != v43)
        {
          int v50 = *((_DWORD *)v41 - 1);
          v41 -= 4;
          *((_DWORD *)v49 - 1) = v50;
          v49 -= 4;
        }
        CFTypeRef v68 = v49;
        uint64_t v69 = v42;
        std::string v70 = &v48[4 * v47];
        if (v43) {
          operator delete(v43);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v69 = *(_DWORD *)v40;
        CFTypeRef v42 = v41 + 4;
      }
      uint64_t v69 = v42;
      CFTypeRef v51 = &outPropertyData.__begin_[20 * v28 + 28];
      CFTypeRef v52 = v66;
      if (v66 >= v67)
      {
        CFTypeRef v54 = (char *)v65;
        uint64_t v55 = (v66 - (unsigned char *)v65) >> 2;
        unint64_t v56 = v55 + 1;
        if ((unint64_t)(v55 + 1) >> 62) {
LABEL_98:
        }
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        uint64_t v57 = v67 - (unsigned char *)v65;
        if ((v67 - (unsigned char *)v65) >> 1 > v56) {
          unint64_t v56 = v57 >> 1;
        }
        if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v58 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v58 = v56;
        }
        if (v58)
        {
          CFTypeRef v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v67, v58);
          CFTypeRef v54 = (char *)v65;
          CFTypeRef v52 = v66;
        }
        else
        {
          CFTypeRef v59 = 0;
        }
        CFTypeRef v60 = &v59[4 * v55];
        *(_DWORD *)CFTypeRef v60 = *(_DWORD *)v51;
        CFTypeRef v53 = v60 + 4;
        while (v52 != v54)
        {
          int v61 = *((_DWORD *)v52 - 1);
          v52 -= 4;
          *((_DWORD *)v60 - 1) = v61;
          v60 -= 4;
        }
        CFTypeRef v65 = v60;
        CFTypeRef v66 = v53;
        CFTypeRef v67 = &v59[4 * v58];
        if (v54) {
          operator delete(v54);
        }
      }
      else
      {
        *(_DWORD *)CFTypeRef v66 = *(_DWORD *)v51;
        CFTypeRef v53 = v52 + 4;
      }
      CFTypeRef v66 = v53;
      ++v28;
      uint64_t v26 = outPropertyData.__begin_;
      unint64_t v27 = *((unsigned int *)outPropertyData.__begin_ + 2);
      if (v27 > (outPropertyData.__end_ - outPropertyData.__begin_ - 12) / 0x14uLL) {
        goto LABEL_89;
      }
    }
    outPropertyData.__end_ = v26;
    operator delete(v26);
    goto LABEL_91;
  }
  if (a1->mChannelLayoutTag)
  {
    unsigned int v18 = (unsigned __int16)a1->mChannelLayoutTag;
    goto LABEL_24;
  }
  unint64_t mNumberChannelDescriptions = a1->mNumberChannelDescriptions;
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&__p, mNumberChannelDescriptions, &outPropertyData);
  unint64_t v5 = a1->mNumberChannelDescriptions;
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&v68, v5, &outPropertyData);
  unint64_t v6 = a1->mNumberChannelDescriptions;
  LODWORD(outPropertyData.__begin_) = 0;
  std::vector<float>::resize((uint64_t)&v65, v6, &outPropertyData);
  unint64_t v7 = a1->mNumberChannelDescriptions;
  if (v7)
  {
    unint64_t v8 = 0;
    uint64_t v9 = &a1->mChannelDescriptions[0].mCoordinates[2];
    do
    {
      if ((*(_DWORD *)(v9 - 3) & 3) == 1)
      {
        float v12 = *(v9 - 2);
        float v13 = *(v9 - 1);
        float v14 = *v9;
        unint64_t v15 = (float *)v65;
        *((float *)v65 + v8) = sqrtf((float)((float)(v13 * v13) + (float)(v12 * v12)) + (float)(*v9 * *v9));
        if (fabsf(v12) < 0.000001 && fabsf(v13) < 0.000001)
        {
          *((_DWORD *)__p + v8) = 0;
          if (v14 <= 0.0)
          {
            if (v14 < 0.0) {
              *((_DWORD *)v68 + v8) = -1028390912;
            }
            else {
              *((_DWORD *)v68 + v8) = 0;
            }
          }
          else
          {
            *((_DWORD *)v68 + v8) = 1119092736;
          }
          goto LABEL_17;
        }
        *((float *)__p + v8) = atan2f(v12, v13) * 57.296;
        float v10 = asinf(v14 / v15[v8]) * 57.296;
        unint64_t v11 = (float *)v68;
      }
      else
      {
        if ((*(_DWORD *)(v9 - 3) & 3) != 2)
        {
          UInt32 v16 = *((_DWORD *)v9 - 4);
          UInt32 ioPropertyDataSize = 20;
          UInt32 inSpecifier = v16;
          if (!AudioFormatGetProperty(0x6473636Cu, 4u, &inSpecifier, &ioPropertyDataSize, &outPropertyData))
          {
            *((_DWORD *)__p + v8) = outPropertyData.__end_;
            *((_DWORD *)v68 + v8) = HIDWORD(outPropertyData.__end_);
            *((_DWORD *)v65 + v8) = outPropertyData.__end_cap_.__value_;
          }
          unint64_t v7 = a1->mNumberChannelDescriptions;
          goto LABEL_17;
        }
        *((float *)__p + v8) = *(v9 - 2);
        *((float *)v68 + v8) = *(v9 - 1);
        float v10 = *v9;
        unint64_t v11 = (float *)v65;
      }
      v11[v8] = v10;
LABEL_17:
      v9 += 5;
      ++v8;
    }
    while (v8 < v7);
  }
LABEL_91:
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorIfNS_9allocatorIfEEEES6_S6_EEC2B8ne180100IJLm0ELm1ELm2EEJS6_S6_S6_EJEJEJRS6_S9_S9_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSB_IJDpT2_EEEDpOT3_(a2, (uint64_t)&__p, (uint64_t)&v68, (uint64_t)&v65);
  if (v65)
  {
    CFTypeRef v66 = (char *)v65;
    operator delete(v65);
  }
  if (v68)
  {
    uint64_t v69 = (char *)v68;
    operator delete(v68);
  }
  if (__p)
  {
    std::string v72 = (char *)__p;
    operator delete(__p);
  }
}

void sub_21B521560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  if (a17) {
    operator delete(a17);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutSphericalCoordinates(AudioChannelLayoutTag a1@<W0>, void *a2@<X8>)
{
  std::vector<char>::value_type __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  std::vector<char>::pointer begin = (AudioChannelLayout *)__p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  begin->unint64_t mNumberChannelDescriptions = 0;
  begin->AudioChannelLayoutTag mChannelLayoutTag = a1;
  GetChannelLayoutSphericalCoordinates(begin, a2);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_21B52163C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutChannelLabels(AudioChannelLayoutTag a1@<W0>, std::vector<unsigned int> *a2@<X8>)
{
  std::vector<char>::value_type __x = 0;
  std::vector<char>::vector(&__p, 0x20uLL, &__x);
  std::vector<char>::pointer begin = (AudioChannelLayout *)__p.__begin_;
  *((_DWORD *)__p.__begin_ + 1) = 0;
  begin->unint64_t mNumberChannelDescriptions = 0;
  begin->AudioChannelLayoutTag mChannelLayoutTag = a1;
  GetChannelLayoutChannelLabels(begin, a2);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_21B5216BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void GetChannelLayoutChannelLabels(const AudioChannelLayout *a1@<X0>, std::vector<unsigned int> *a2@<X8>)
{
  if (a1->mChannelLayoutTag == 0x10000)
  {
    uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)a1->mChannelBitmap);
    v5.i16[0] = vaddlv_u8(v5);
    UInt32 mChannelLayoutTag = v5.i32[0];
  }
  else if (a1->mChannelLayoutTag)
  {
    UInt32 mChannelLayoutTag = (unsigned __int16)a1->mChannelLayoutTag;
  }
  else
  {
    UInt32 mChannelLayoutTag = a1->mNumberChannelDescriptions;
  }
  uint64_t v6 = mChannelLayoutTag;
  LODWORD(__x.__begin_) = -1;
  std::vector<unsigned int>::vector(a2, mChannelLayoutTag, (const std::vector<unsigned int>::value_type *)&__x);
  if (a1->mChannelLayoutTag)
  {
    v21[0] = 0;
    std::vector<char>::vector(&__x, 0x20uLL, v21);
    std::vector<char>::pointer begin = __x.__begin_;
    *(void *)__x.__begin_ = 0;
    *((_DWORD *)begin + 2) = 0;
    if (mChannelLayoutTag <= 1) {
      unsigned int v8 = 1;
    }
    else {
      unsigned int v8 = mChannelLayoutTag;
    }
    uint64_t v9 = (char *)(20 * v8 + 12);
    v21[0] = 0;
    int end = (int)__x.__end_;
    if (v9 <= (std::vector<char>::pointer)(__x.__end_ - begin))
    {
      if (v9 < (std::vector<char>::pointer)(__x.__end_ - begin))
      {
        int end = begin + v9;
        __x.__end_ = &v9[(void)begin];
      }
    }
    else
    {
      std::vector<char>::__append(&__x, (std::vector<char>::size_type)&v9[-(__x.__end_ - begin)], v21);
      std::vector<char>::pointer begin = __x.__begin_;
      int end = (int)__x.__end_;
    }
    *((_DWORD *)begin + 2) = mChannelLayoutTag;
    AudioChannelLayoutTag v14 = a1->mChannelLayoutTag;
    *(_DWORD *)unint64_t v21 = end - begin;
    if (v14 == 0x10000) {
      AudioFormatPropertyID v15 = 1668116578;
    }
    else {
      AudioFormatPropertyID v15 = 1668116588;
    }
    if (v14 == 0x10000) {
      p_mChannelBitmap = (const AudioChannelLayout *)&a1->mChannelBitmap;
    }
    else {
      p_mChannelBitmap = a1;
    }
    AudioFormatGetProperty(v15, 4u, p_mChannelBitmap, (UInt32 *)v21, begin);
    uint8x8_t v17 = __x.__begin_;
    if (mChannelLayoutTag)
    {
      std::vector<char>::pointer v18 = __x.__begin_ + 12;
      std::vector<unsigned int>::pointer v19 = a2->__begin_;
      do
      {
        unsigned int v20 = *(_DWORD *)v18;
        v18 += 20;
        *v19++ = v20;
        --v6;
      }
      while (v6);
    }
    else if (!__x.__begin_)
    {
      return;
    }
    __x.__end_ = v17;
    operator delete(v17);
  }
  else if (mChannelLayoutTag)
  {
    std::vector<unsigned int>::pointer v11 = a2->__begin_;
    mChannelDescriptions = a1->mChannelDescriptions;
    do
    {
      AudioChannelLabel mChannelLabel = mChannelDescriptions->mChannelLabel;
      ++mChannelDescriptions;
      *v11++ = mChannelLabel;
      --v6;
    }
    while (v6);
  }
}

void sub_21B521854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  float v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IsLFEChannelLabel(unsigned int a1)
{
  return (a1 < 0x3F) & (0x4000002000000010uLL >> a1);
}

uint64_t GetNumChannelsForAudioChannelLayoutTag(uint64_t result)
{
  return (unsigned __int16)result;
}

void std::vector<char>::__append(std::vector<char> *this, std::vector<char>::size_type __n, std::vector<char>::const_reference __x)
{
  std::vector<char>::size_type v4 = __n;
  int end = this->__end_;
  uint64_t value = this->__end_cap_.__value_;
  if (value - end >= __n)
  {
    if (__n)
    {
      float v13 = &end[__n];
      do
      {
        *end++ = *__x;
        --v4;
      }
      while (v4);
      int end = v13;
    }
    this->__end_ = end;
  }
  else
  {
    int64_t v8 = end - this->__begin_;
    unint64_t v9 = v8 + __n;
    if ((uint64_t)(v8 + __n) < 0) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = value - this->__begin_;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      float v12 = (char *)operator new(v11);
    }
    else {
      float v12 = 0;
    }
    AudioChannelLayoutTag v14 = &v12[v8];
    AudioFormatPropertyID v15 = &v12[v8 + v4];
    UInt32 v16 = &v12[v8];
    do
    {
      *v16++ = *__x;
      --v4;
    }
    while (v4);
    std::vector<char>::pointer begin = this->__begin_;
    if (end != this->__begin_)
    {
      do
      {
        char v18 = *--end;
        *--AudioChannelLayoutTag v14 = v18;
      }
      while (end != begin);
      int end = this->__begin_;
    }
    this->__begin_ = v14;
    this->__end_ = v15;
    this->__end_cap_.__value_ = &v12[v11];
    if (end)
    {
      operator delete(end);
    }
  }
}

void *_ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorIfNS_9allocatorIfEEEES6_S6_EEC2B8ne180100IJLm0ELm1ELm2EEJS6_S6_S6_EJEJEJRS6_S9_S9_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSB_IJDpT2_EEEDpOT3_(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 3, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 6, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
  return a1;
}

void sub_21B521A6C(_Unwind_Exception *exception_object)
{
  std::vector<char>::size_type v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  uint8x8_t v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

id getPersonalizedIRDataLog(void)
{
  if (getPersonalizedIRDataLog(void)::onceToken != -1) {
    dispatch_once(&getPersonalizedIRDataLog(void)::onceToken, &__block_literal_global_3);
  }
  CFNumberRef v0 = (void *)getPersonalizedIRDataLog(void)::gLog;

  return v0;
}

uint64_t ___Z24getPersonalizedIRDataLogv_block_invoke()
{
  getPersonalizedIRDataLog(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "PersonalizedIRData");

  return MEMORY[0x270F9A758]();
}

void IR::PersonalizedIRData::Implementation::Implementation(uint64_t a1, long long *a2, char a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = a3;
  *(unsigned char *)(a1 + 17) = 1;
  *(void *)(a1 + 48) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 56), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(a1 + 72) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 56) = v4;
  }
  *(_DWORD *)(a1 + 8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = -1;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  IR::DataCache::create();
}

void sub_21B521C0C(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::~__value_func[abi:ne180100]((void *)(v1 + 24));
  BOOL v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(a1);
}

void IR::DataCache::create()
{
}

void sub_21B521CB4(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v1, 0x1072C40CE36446BLL);
  _Unwind_Resume(a1);
}

void IR::PersonalizedIRData::Implementation::~Implementation(id *this)
{
  unsigned __int16 v2 = *this;
  BOOL v3 = (std::mutex *)((char *)*this + 80);
  std::mutex::lock(v3);
  v2[200] = 1;
  std::mutex::unlock(v3);

  if (*((char *)this + 79) < 0) {
    operator delete(this[7]);
  }
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::~__value_func[abi:ne180100](this + 3);
  long long v4 = (std::__shared_weak_count *)this[1];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void *IR::PersonalizedIRData::Implementation::UnregisterObservers(IR::PersonalizedIRData::Implementation *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unsigned __int16 v2 = getPersonalizedIRDataLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v3 = (void *)((char *)this + 56);
    if (*((char *)this + 79) < 0) {
      BOOL v3 = (void *)*v3;
    }
    *(_DWORD *)uint8x8_t v5 = 136315394;
    *(void *)&v5[4] = v3;
    __int16 v6 = 2080;
    unint64_t v7 = "UnregisterObservers";
    _os_log_impl(&dword_21B4DD000, v2, OS_LOG_TYPE_DEFAULT, "[%s|%s] Unregistering observers.", v5, 0x16u);
  }

  if (*((unsigned char *)this + 16)) {
    IR::PersonalizedIRData::Implementation::UnregisterPersonalizedHRTFAllowedListener(this);
  }
  else {
    IR::PersonalizedIRData::Implementation::UnregisterBTCServicesAndMAObservers(this);
  }
  *(void *)uint8x8_t v5 = &unk_26CB57C80;
  int64_t v8 = v5;
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::swap[abi:ne180100](v5, (void *)this + 3);
  return std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::~__value_func[abi:ne180100](v5);
}

uint64_t IR::DataCache::clearCFDataCache(IR::DataCache *this)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unsigned __int16 v2 = (std::recursive_mutex *)((char *)this + 16);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 16));
  BOOL v3 = getPersonalizedIRDataLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (void *)((char *)this + 144);
    if (*((char *)this + 167) < 0) {
      long long v4 = (void *)*v4;
    }
    int v9 = 136315394;
    unint64_t v10 = v4;
    __int16 v11 = 2080;
    float v12 = "clearCFDataCache";
    _os_log_impl(&dword_21B4DD000, v3, OS_LOG_TYPE_DEFAULT, "[%s|%s] Clearing personalized HRTF cache.", (uint8_t *)&v9, 0x16u);
  }

  uint64_t v5 = 0;
  __int16 v6 = (char *)this + 184;
  do
  {
    unint64_t v7 = *(const void **)&v6[v5];
    *(void *)&v6[v5] = 0;
    if (v7) {
      CFRelease(v7);
    }
    v5 += 8;
  }
  while (v5 != 16);
  *((_DWORD *)this + 43) = 1;
  *((unsigned char *)this + 168) = 0;
  *((void *)this + 22) = 0;
  std::recursive_mutex::unlock(v2);
  return 0;
}

void sub_21B521F94(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void IR::PersonalizedIRData::Implementation::RegisterObservers(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  __int16 v6 = getPersonalizedIRDataLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v7 = (void *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      unint64_t v7 = (void *)*v7;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v25 = v7;
    __int16 v26 = 2080;
    unint64_t v27 = "RegisterObservers";
    _os_log_impl(&dword_21B4DD000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] Registering observers.", buf, 0x16u);
  }

  std::function<void ()(IR::PersonalizedIRData::DataStatus)>::operator=((void *)(a1 + 24), a2);
  if (*(unsigned char *)(a1 + 16))
  {
    AudioObjectID inObjectID = 0;
    if (AudioDSPCoreUtility::GetDeviceOrPortID((AudioDSPCoreUtility *)&inObjectID, v8) || !inObjectID)
    {
      char v18 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        IR::PersonalizedIRData::Implementation::RegisterObservers();
      }

      IR::PersonalizedIRData::Implementation::UnregisterPersonalizedHRTFAllowedListener((IR::PersonalizedIRData::Implementation *)a1);
    }
    else if (inObjectID != *(_DWORD *)(a1 + 96))
    {
      IR::PersonalizedIRData::Implementation::UnregisterPersonalizedHRTFAllowedListener((IR::PersonalizedIRData::Implementation *)a1);
      *(void *)&inAddress.mSelector = *(void *)"afrhbolg";
      inAddress.mElement = 0;
      OSStatus v10 = AudioObjectAddPropertyListener(inObjectID, &inAddress, (AudioObjectPropertyListenerProc)IR::PersonalizedIRData::HALListenerCallbackFunction, (void *)a1);
      __int16 v11 = getPersonalizedIRDataLog();
      float v12 = v11;
      if (v10)
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          uint64_t v13 = (void *)(a1 + 56);
          if (*(char *)(a1 + 79) < 0) {
            uint64_t v13 = (void *)*v13;
          }
          *(_DWORD *)buf = 136315906;
          uint64_t v25 = v13;
          __int16 v26 = 2080;
          unint64_t v27 = "RegisterObservers";
          __int16 v28 = 1024;
          AudioObjectID v29 = inObjectID;
          __int16 v30 = 1024;
          OSStatus v31 = v10;
          _os_log_error_impl(&dword_21B4DD000, v12, OS_LOG_TYPE_ERROR, "[%s|%s] Failed to register personalizedHRTFAllowed listener for device ID: %u. Error: %d", buf, 0x22u);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        IR::PersonalizedIRData::Implementation::RegisterObservers();
      }
    }
    *(_DWORD *)(a1 + 96) = inObjectID;
    IR::PersonalizedIRData::Implementation::CheckIfPersonalizedHRIRIsAllowed((IR::PersonalizedIRData::Implementation *)a1, v9);
    if (!a3) {
      return;
    }
LABEL_31:
    if (*(void *)(a1 + 48))
    {
      std::vector<unsigned int>::pointer v19 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v20 = (void *)(a1 + 56);
        if (*(char *)(a1 + 79) < 0) {
          unsigned int v20 = (void *)*v20;
        }
        *(_DWORD *)buf = 136315394;
        uint64_t v25 = v20;
        __int16 v26 = 2080;
        unint64_t v27 = "RegisterObservers";
        _os_log_impl(&dword_21B4DD000, v19, OS_LOG_TYPE_DEFAULT, "[%s|%s] Executing callback with valid int data = true", buf, 0x16u);
      }

      std::function<void ()(IR::PersonalizedIRData::DataStatus)>::operator()(a1 + 24, 0);
    }
    return;
  }
  if (*(_DWORD *)(a1 + 80) == -1)
  {
    AudioChannelLayoutTag v14 = *(NSObject **)(a1 + 88);
    handler[0] = MEMORY[0x263EF8330];
    handler[1] = 3221225472;
    handler[2] = ___ZN2IR18PersonalizedIRData14Implementation17RegisterObserversERKNSt3__18functionIFvNS0_10DataStatusEEEEb_block_invoke;
    handler[3] = &__block_descriptor_40_e8_v12__0i8l;
    handler[4] = a1;
    uint32_t v15 = notify_register_dispatch("BTCloudServicesSoundProfileChangedNotification", (int *)(a1 + 80), v14, handler);
    UInt32 v16 = getPersonalizedIRDataLog();
    uint8x8_t v17 = v16;
    if (v15)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        IR::PersonalizedIRData::Implementation::RegisterObservers();
      }

      *(_DWORD *)(a1 + 8std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = -1;
    }
    else
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
        IR::PersonalizedIRData::Implementation::RegisterObservers();
      }
    }
  }
  atomic_store(1u, (unsigned __int8 *)(a1 + 17));
  if (a3) {
    goto LABEL_31;
  }
}

void *std::function<void ()(IR::PersonalizedIRData::DataStatus)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::~__value_func[abi:ne180100](v4);
  return a1;
}

uint64_t ___ZN2IR18PersonalizedIRData14Implementation17RegisterObserversERKNSt3__18functionIFvNS0_10DataStatusEEEEb_block_invoke(uint64_t result)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(result + 32);
  if (*(void *)(v1 + 48))
  {
    unsigned __int16 v2 = getPersonalizedIRDataLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v3 = (void *)(v1 + 56);
      if (*(char *)(v1 + 79) < 0) {
        BOOL v3 = (void *)*v3;
      }
      int v4 = 136315394;
      uint64_t v5 = v3;
      __int16 v6 = 2080;
      unint64_t v7 = "RegisterObservers_block_invoke";
      _os_log_impl(&dword_21B4DD000, v2, OS_LOG_TYPE_DEFAULT, "[%s|%s] SoundProfile data has changed.", (uint8_t *)&v4, 0x16u);
    }

    return std::function<void ()(IR::PersonalizedIRData::DataStatus)>::operator()(v1 + 24, 0);
  }
  return result;
}

uint64_t std::function<void ()(IR::PersonalizedIRData::DataStatus)>::operator()(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

void IR::PersonalizedIRData::Implementation::UnregisterPersonalizedHRTFAllowedListener(IR::PersonalizedIRData::Implementation *this)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  BOOL v3 = (int *)((char *)this + 96);
  AudioObjectID v2 = *((_DWORD *)this + 24);
  if (v2)
  {
    v9.mElement = 0;
    *(void *)&v9.mSelector = *(void *)"afrhbolg";
    OSStatus v4 = AudioObjectRemovePropertyListener(v2, &v9, (AudioObjectPropertyListenerProc)IR::PersonalizedIRData::HALListenerCallbackFunction, this);
    uint64_t v5 = getPersonalizedIRDataLog();
    __int16 v6 = v5;
    if (v4)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v7 = (void *)((char *)this + 56);
        if (*((char *)this + 79) < 0) {
          unint64_t v7 = (void *)*v7;
        }
        int v8 = *v3;
        *(_DWORD *)buf = 136315906;
        __int16 v11 = v7;
        __int16 v12 = 2080;
        uint64_t v13 = "UnregisterPersonalizedHRTFAllowedListener";
        __int16 v14 = 1024;
        int v15 = v8;
        __int16 v16 = 1024;
        OSStatus v17 = v4;
        _os_log_impl(&dword_21B4DD000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] Failed to unregister personalizedHRTFAllowed listener. Device ID: %u. Error: %d", buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      IR::PersonalizedIRData::Implementation::UnregisterPersonalizedHRTFAllowedListener();
    }

    *BOOL v3 = 0;
  }
}

uint64_t IR::PersonalizedIRData::HALListenerCallbackFunction(IR::PersonalizedIRData *this, unsigned int a2, unsigned int a3, AudioObjectPropertyAddress *a4, void *a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  __int16 v6 = getPersonalizedIRDataLog();
  unint64_t v7 = v6;
  if (a4)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      p_mElement = &a4[4].mElement;
      if (SHIBYTE(a4[6].mScope) < 0) {
        p_mElement = *(AudioObjectPropertyElement **)p_mElement;
      }
      int v11 = 136315394;
      __int16 v12 = p_mElement;
      __int16 v13 = 2080;
      __int16 v14 = "HALListenerCallbackFunction";
      _os_log_impl(&dword_21B4DD000, v7, OS_LOG_TYPE_DEFAULT, "[%s|%s] Personalized HRIR configuration has changed, reloading HRIR.", (uint8_t *)&v11, 0x16u);
    }

    IR::PersonalizedIRData::Implementation::CheckIfPersonalizedHRIRIsAllowed((IR::PersonalizedIRData::Implementation *)a4, v9);
    std::function<void ()(IR::PersonalizedIRData::DataStatus)>::operator()((uint64_t)&a4[2], 0);
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      IR::PersonalizedIRData::HALListenerCallbackFunction(v7);
    }
  }
  return 0;
}

uint64_t IR::PersonalizedIRData::Implementation::CheckIfPersonalizedHRIRIsAllowed(IR::PersonalizedIRData::Implementation *this, unsigned int *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 16))
  {
    outCFDataRef Data = 0;
    int DeviceOrPortID = AudioDSPCoreUtility::GetDeviceOrPortID((AudioDSPCoreUtility *)&outData, a2);
    if (DeviceOrPortID || !outData)
    {
      AudioObjectPropertyAddress v9 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        OSStatus v10 = (void *)((char *)this + 56);
        if (*((char *)this + 79) < 0) {
          OSStatus v10 = (void *)*v10;
        }
        *(_DWORD *)buf = 136315906;
        OSStatus v17 = v10;
        __int16 v18 = 2080;
        std::vector<unsigned int>::pointer v19 = "CheckIfPersonalizedHRIRIsAllowed";
        __int16 v20 = 1024;
        int v21 = 0;
        __int16 v22 = 1024;
        int v23 = DeviceOrPortID;
        _os_log_impl(&dword_21B4DD000, v9, OS_LOG_TYPE_DEFAULT, "[%s|%s] Unknown device ID, setting personalizedHRTFAllowed = %u. Error: %d", buf, 0x22u);
      }

      unsigned __int8 v8 = 0;
    }
    else
    {
      inAddress.mElement = 0;
      UInt32 ioDataSize = 4;
      *(void *)&inAddress.mSelector = *(void *)"afrhbolg";
      PropertyCFDataRef Data = AudioObjectGetPropertyData(outData, &inAddress, 0, 0, &ioDataSize, (char *)&outData + 4);
      if (PropertyData)
      {
        OSStatus v5 = PropertyData;
        __int16 v6 = getPersonalizedIRDataLog();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v7 = (void *)((char *)this + 56);
          if (*((char *)this + 79) < 0) {
            unint64_t v7 = (void *)*v7;
          }
          *(_DWORD *)buf = 136316162;
          OSStatus v17 = v7;
          __int16 v18 = 2080;
          std::vector<unsigned int>::pointer v19 = "CheckIfPersonalizedHRIRIsAllowed";
          __int16 v20 = 1024;
          int v21 = HIDWORD(outData);
          __int16 v22 = 1024;
          int v23 = outData;
          __int16 v24 = 1024;
          OSStatus v25 = v5;
          _os_log_impl(&dword_21B4DD000, v6, OS_LOG_TYPE_DEFAULT, "[%s|%s] Could not read soundProfileAllowed property, setting personalizedHRTFAllowed = %u. Device ID %u. Error: %d", buf, 0x28u);
        }
      }
      unsigned __int8 v8 = HIDWORD(outData) != 0;
    }
    atomic_store(v8, (unsigned __int8 *)this + 17);
  }
  else
  {
    atomic_store(1u, (unsigned __int8 *)this + 17);
  }
  unsigned __int8 v11 = atomic_load((unsigned __int8 *)this + 17);
  return v11 & 1;
}

void IR::PersonalizedIRData::Implementation::UnregisterBTCServicesAndMAObservers(IR::PersonalizedIRData::Implementation *this)
{
  int v2 = *((_DWORD *)this + 20);
  if (v2 != -1)
  {
    notify_cancel(v2);
    *((_DWORD *)this + 2std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = -1;
    BOOL v3 = getPersonalizedIRDataLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      IR::PersonalizedIRData::Implementation::UnregisterBTCServicesAndMAObservers();
    }
  }
}

void IR::PersonalizedIRData::Implementation::GetCFData(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  IR::DataCache::getFromCFDataCache(*(void *)a1, a2, &v30);
  CFTypeRef v10 = v30;
  unsigned __int8 v11 = getPersonalizedIRDataLog();
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v10 || (a3 & 1) != 0)
  {
    if (v12)
    {
      uint64_t v15 = (void *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        uint64_t v15 = (void *)*v15;
      }
      *(_DWORD *)buf = 136315906;
      if (v30) {
        __int16 v16 = "found";
      }
      else {
        __int16 v16 = "unavailable";
      }
      *(void *)&uint8_t buf[4] = v15;
      __int16 v32 = 2080;
      uint64_t v33 = "GetCFData";
      __int16 v34 = 1024;
      int v35 = a2;
      __int16 v36 = 2080;
      uint64_t v37 = v16;
      _os_log_impl(&dword_21B4DD000, v11, OS_LOG_TYPE_DEFAULT, "[%s|%s] Personalized HRIR type %u is %s in CFData cache.", buf, 0x26u);
    }

    buf[0] = 0;
    std::pair<BOOL,applesauce::CF::DataRef>::pair[abi:ne180100]<BOOL,applesauce::CF::DataRef&,0>(a5, buf, &v30);
    goto LABEL_57;
  }
  if (v12)
  {
    __int16 v13 = (void *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      __int16 v13 = (void *)*v13;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v13;
    __int16 v32 = 2080;
    uint64_t v33 = "GetCFData";
    __int16 v34 = 1024;
    int v35 = a2;
    _os_log_impl(&dword_21B4DD000, v11, OS_LOG_TYPE_DEFAULT, "[%s|%s] Could not find Personalized HRTF type %u in local cache, trying to fetch.", buf, 0x1Cu);
  }

  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v14 = *(void *)a1;
    v38[0] = &unk_26CB57D48;
    v38[3] = v38;
    IR::DataCache::DownloadAndCacheCFData(v14, (uint64_t)v38, 0);
    std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](v38);
    IR::DataCache::getFromCFDataCache(*(void *)a1, a2, buf);
    *(unsigned char *)a5 = 0;
    *(void *)(a5 + 8) = *(void *)buf;
    goto LABEL_57;
  }
  OSStatus v17 = (char *)operator new(0x90uLL);
  *((void *)v17 + 1) = 0;
  *((void *)v17 + 2) = 0;
  *((void *)v17 + 3) = 850045863;
  *(void *)OSStatus v17 = &unk_26CB57CC8;
  *((void *)v17 + 17) = 0;
  *((_OWORD *)v17 + 2) = 0u;
  *((_OWORD *)v17 + 3) = 0u;
  *((_OWORD *)v17 + 4) = 0u;
  *((void *)v17 + 1std::unique_ptr<IR::IRDataLoader::Implementation>::reset[abi:ne180100](this, 0) = 0;
  *((void *)v17 + 11) = 1018212795;
  *((_OWORD *)v17 + 6) = 0u;
  *((_OWORD *)v17 + 7) = 0u;
  *(_OWORD *)(v17 + 122) = 0u;
  uint64_t v18 = *(void *)a1;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v17 + 1, 1uLL, memory_order_relaxed);
  CFTypeRef v42 = 0;
  std::vector<unsigned int>::pointer v19 = operator new(0x20uLL);
  *std::vector<unsigned int>::pointer v19 = &unk_26CB57D00;
  v19[1] = v17 + 24;
  void v19[2] = v17;
  v19[3] = a1;
  CFTypeRef v42 = v19;
  IR::DataCache::DownloadAndCacheCFData(v18, (uint64_t)v41, 1);
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](v41);
  *(void *)buf = v17 + 24;
  buf[8] = 1;
  std::mutex::lock((std::mutex *)(v17 + 24));
  v20.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ + 1000000 * a4;
  do
  {
    if (!buf[8]) {
      goto LABEL_60;
    }
    if (v17[137])
    {
      v17[136] = 0;
      goto LABEL_41;
    }
    if (v20.__d_.__rep_ <= std::chrono::steady_clock::now().__d_.__rep_) {
      break;
    }
    v21.__d_.__rep_ = v20.__d_.__rep_ - std::chrono::steady_clock::now().__d_.__rep_;
    if (v21.__d_.__rep_ >= 1)
    {
      std::chrono::steady_clock::now();
      v22.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      if (v22.__d_.__rep_)
      {
        if (v22.__d_.__rep_ < 1)
        {
          if ((unint64_t)v22.__d_.__rep_ < 0xFFDF3B645A1CAC09)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v23 = 0x8000000000000000;
            goto LABEL_32;
          }
        }
        else if ((unint64_t)v22.__d_.__rep_ > 0x20C49BA5E353F7)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v23 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_30;
        }
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v23 = 1000 * v22.__d_.__rep_;
      }
      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v23 = 0;
      }
LABEL_30:
      if (v23 > (v21.__d_.__rep_ ^ 0x7FFFFFFFFFFFFFFFLL))
      {
        v24.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
LABEL_33:
        std::condition_variable::__do_timed_wait((std::condition_variable *)(v17 + 88), (std::unique_lock<std::mutex> *)buf, v24);
        std::chrono::steady_clock::now();
        continue;
      }
LABEL_32:
      v24.__d_.__rep_ = v23 + v21.__d_.__rep_;
      goto LABEL_33;
    }
  }
  while (std::chrono::steady_clock::now().__d_.__rep_ < v20.__d_.__rep_);
  if (!buf[8]) {
LABEL_60:
  }
    __assert_rtn("operator()", "PersonalizedIRData.mm", 633, "cvLock.owns_lock()");
  int v25 = v17[137];
  v17[136] = v25 ^ 1;
  if (!v25)
  {
    uint64_t v26 = getPersonalizedIRDataLog();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      IR::PersonalizedIRData::Implementation::GetCFData();
    }
  }
LABEL_41:
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v39, "personalized_hrtf_timeout");
  if (v17[136]) {
    unint64_t v27 = (CFTypeRef *)MEMORY[0x263EFFB40];
  }
  else {
    unint64_t v27 = (CFTypeRef *)MEMORY[0x263EFFB38];
  }
  CFTypeRef cf = *v27;
  v29[0] = &v39;
  v29[1] = 1;
  CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v29);
  v29[2] = CFDictionaryRef;
  if (cf) {
    CFRelease(cf);
  }
  if (v39) {
    CFRelease(v39);
  }
  if (AudioStatisticsLibraryLoader(void)::once != -1) {
    dispatch_once(&AudioStatisticsLibraryLoader(void)::once, &__block_literal_global_33);
  }
  if (off_267C57C48) {
    off_267C57C48(CFDictionaryRef, 268435457, 5);
  }
  IR::DataCache::getFromCFDataCache(*(void *)a1, a2, v29);
  *(unsigned char *)a5 = v17[136];
  *(void *)(a5 + 8) = v29[0];
  if (CFDictionaryRef) {
    CFRelease(CFDictionaryRef);
  }
  if (buf[8]) {
    std::mutex::unlock(*(std::mutex **)buf);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v17);
LABEL_57:
  if (v30) {
    CFRelease(v30);
  }
}

void sub_21B522F28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, std::mutex *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,char a28)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void IR::DataCache::getFromCFDataCache(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  __int16 v6 = (std::recursive_mutex *)(a1 + 16);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 16));
  if (a2 == 2)
  {
    uint64_t v7 = *(void *)(a1 + 192);
    if (v7) {
      CFRetain(*(CFTypeRef *)(a1 + 192));
    }
  }
  else if (a2 == 1)
  {
    uint64_t v7 = *(void *)(a1 + 184);
    if (v7) {
      CFRetain(*(CFTypeRef *)(a1 + 184));
    }
  }
  else
  {
    unsigned __int8 v8 = getPersonalizedIRDataLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      AudioObjectPropertyAddress v9 = (void *)(a1 + 144);
      if (*(char *)(a1 + 167) < 0) {
        AudioObjectPropertyAddress v9 = (void *)*v9;
      }
      int v10 = 136315650;
      unsigned __int8 v11 = v9;
      __int16 v12 = 2080;
      __int16 v13 = "getFromCFDataCache";
      __int16 v14 = 1024;
      int v15 = a2;
      _os_log_impl(&dword_21B4DD000, v8, OS_LOG_TYPE_DEFAULT, "[%s|%s] Returning null dictionary for personalized HRTF type %u.", (uint8_t *)&v10, 0x1Cu);
    }

    uint64_t v7 = 0;
  }
  *a3 = v7;
  std::recursive_mutex::unlock(v6);
}

void sub_21B523124(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void IR::DataCache::DownloadAndCacheCFData(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (a3)
  {
    if (*(unsigned char *)(a1 + 201))
    {
      uint64_t v6 = *(void *)a1;
      OSStatus v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        unsigned __int8 v8 = (void *)(a1 + 144);
        if (*(char *)(a1 + 167) < 0) {
          unsigned __int8 v8 = (void *)*v8;
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v8;
        __int16 v54 = 2080;
        *(void *)uint64_t v55 = "DownloadAndCacheCFData";
        _os_log_impl(&dword_21B4DD000, v7, OS_LOG_TYPE_DEFAULT, "[%s|%s] Searching for enrolled SoundProfile.", buf, 0x16u);
      }

      uint64_t v9 = mach_absolute_time();
      id v10 = objc_alloc_init(MEMORY[0x263F78A78]);
      unsigned __int8 v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
      dispatch_queue_t v12 = dispatch_queue_create("com.apple.coreaudio.pHRTF", v11);
      [v10 setDispatchQueue:v12];

      v43[0] = MEMORY[0x263EF8330];
      v43[1] = 3321888768;
      void v43[2] = ___ZN2IR9DataCache22DownloadAndCacheCFDataENSt3__18functionIFvNS_18PersonalizedIRData12DataValidityEEEEb_block_invoke;
      v43[3] = &__block_descriptor_96_ea8_40c38_ZTSNSt3__18weak_ptrIN2IR9DataCacheEEE64c66_ZTSKNSt3__18functionIFvN2IR18PersonalizedIRData12DataValidityEEEE_e47_v24__0__SpatialSoundProfileRecord_8__NSError_16l;
      void v43[4] = a1;
      v43[5] = v6;
      uint64_t v44 = v5;
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v45 = v9;
      std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::__value_func[abi:ne180100]((uint64_t)v46, a2);
      [v10 fetchSpatialSoundProfileRecordWithCompletion:v43];
      std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](v46);
      if (v44) {
        std::__shared_weak_count::__release_weak(v44);
      }

      if (v5) {
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    return;
  }
  uint64_t inAddress = *(void *)"ibipbolg";
  uint64_t inAddress_8 = 0;
  *(void *)buf = &kBTHALPluginBundleID;
  *(_DWORD *)&buf[8] = 8;
  *(void *)&void v55[2] = (char *)&inAddress_8 + 4;
  LODWORD(v56) = 4;
  UInt32 ioDataSize = 32;
  PropertyCFDataRef Data = AudioObjectGetPropertyData(1u, (const AudioObjectPropertyAddress *)&inAddress, 0, 0, &ioDataSize, buf);
  if (!PropertyData)
  {
    v39.mElement = 0;
    outCFDataRef Data = 0;
    *(void *)&v39.mSelector = *(void *)"frhcbolg";
    UInt32 v37 = 8;
    OSStatus v16 = AudioObjectGetPropertyData(HIDWORD(inAddress_8), &v39, 0, 0, &v37, &outData);
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, outData);
    if (v16 || v37 != 8)
    {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v23 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t v47 = 136315650;
        CFTypeRef v48 = "GetEnrolledSoundProfileFromBTHAL";
        __int16 v49 = 1024;
        OSStatus v50 = v16;
        __int16 v51 = 1024;
        UInt32 v52 = v37;
        _os_log_impl(&dword_21B4DD000, v23, OS_LOG_TYPE_DEFAULT, "%s: Could not pull SoundProfile. Error: %d. Property size: %u", v47, 0x18u);
      }
    }
    else
    {
      if (cf)
      {
        applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DataRef,char const(&)[32]>((const __CFDictionary *)cf, "kBTAudioMsgPropertySoundProfile", &theData);
        if (v35)
        {
          if (!theData)
          {
            exception = __cxa_allocate_exception(0x10uLL);
            MEMORY[0x21D48F410](exception, "Could not construct");
          }
          OSStatus Length = CFDataGetLength(theData);
          uint64_t v18 = getPersonalizedIRDataLog();
          BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
          if (Length)
          {
            if (v19)
            {
              *(_DWORD *)unint64_t v47 = 136315394;
              CFTypeRef v48 = "GetEnrolledSoundProfileFromBTHAL";
              __int16 v49 = 1024;
              OSStatus v50 = Length;
              _os_log_impl(&dword_21B4DD000, v18, OS_LOG_TYPE_DEFAULT, "%s: Successfully pulled SoundProfile pack. Data size: %u", v47, 0x12u);
            }

            unsigned int v20 = mach_absolute_time();
            if (!v35) {
              std::__throw_bad_optional_access[abi:ne180100]();
            }
            unsigned int v21 = v20;
            char v31 = 1;
            unsigned int v32 = v20;
            CFDataRef v22 = theData;
            if (theData) {
              CFRetain(theData);
            }
            CFDataRef v33 = v22;
            std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&theData);
            if (cf) {
              CFRelease(cf);
            }
            char v15 = 1;
            goto LABEL_49;
          }
          if (!v19) {
            goto LABEL_45;
          }
          *(_DWORD *)unint64_t v47 = 136315138;
          CFTypeRef v48 = "GetEnrolledSoundProfileFromBTHAL";
          int v25 = "%s: Invalid SoundProfile pack: size = 0.";
        }
        else
        {
          uint64_t v18 = getPersonalizedIRDataLog();
          if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
LABEL_45:

            std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&theData);
            char v15 = 1;
LABEL_46:
            if (cf) {
              CFRelease(cf);
            }
            goto LABEL_48;
          }
          *(_DWORD *)unint64_t v47 = 136315138;
          CFTypeRef v48 = "GetEnrolledSoundProfileFromBTHAL";
          int v25 = "%s: Invalid SoundProfile pack.";
        }
        _os_log_impl(&dword_21B4DD000, v18, OS_LOG_TYPE_DEFAULT, v25, v47, 0xCu);
        goto LABEL_45;
      }
      std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v24 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        IR::DataCache::DownloadAndCacheCFData(v24);
      }
    }
    char v15 = 0;
    goto LABEL_46;
  }
  __int16 v14 = getPersonalizedIRDataLog();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
    IR::DataCache::DownloadAndCacheCFData(PropertyData, v14);
  }

  char v15 = 0;
LABEL_48:
  unsigned int v21 = mach_absolute_time();
  CFDataRef v22 = 0;
  char v31 = v15;
  unsigned int v32 = v21;
  CFDataRef v33 = 0;
LABEL_49:
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 16));
  *(unsigned char *)(a1 + 168) = v15;
  *(void *)(a1 + 176) = v21;
  *(_DWORD *)(a1 + 172) = 1;
  std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 16));
  if (v22)
  {
    CFRetain(v22);
    CFTypeRef v30 = v22;
    IR::DataCache::parseSoundProfileAndAddToCache(a1, (CFDataRef *)&v30);
    if (v30) {
      CFRelease(v30);
    }
  }
  if (*(void *)(a2 + 24))
  {
    uint64_t v26 = getPersonalizedIRDataLog();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v27 = (void *)(a1 + 144);
      if (*(char *)(a1 + 167) < 0) {
        unint64_t v27 = (void *)*v27;
      }
      __int16 v28 = "Invalid";
      if (!*(_DWORD *)(a1 + 172)) {
        __int16 v28 = "Valid";
      }
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v27;
      __int16 v54 = 2080;
      *(void *)uint64_t v55 = "DownloadAndCacheCFData";
      *(_WORD *)&v55[8] = 2080;
      unint64_t v56 = v28;
      _os_log_impl(&dword_21B4DD000, v26, OS_LOG_TYPE_DEFAULT, "[%s|%s] Executing callback with DataValidity = %s.", buf, 0x20u);
    }

    std::function<void ()(IR::PersonalizedIRData::DataValidity)>::operator()(a2, *(_DWORD *)(a1 + 172));
  }
  if (v22) {
    CFRelease(v22);
  }
}

void sub_21B5237C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void IR::PersonalizedIRData::PersonalizedIRData(IR::PersonalizedIRData *this)
{
}

{
  IR::PersonalizedIRData::PersonalizedIRData(this);
}

void IR::PersonalizedIRData::PersonalizedIRData(void *a1)
{
  *a1 = 0;
  uint64_t v1 = [MEMORY[0x263F086E0] mainBundle];
  int v2 = [v1 bundleIdentifier];

  [v2 isEqualToString:@"com.apple.audiomxd"];
  operator new();
}

void sub_21B52396C(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v3, 0x10B2C4051ED0559);

  std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void IR::PersonalizedIRData::PersonalizedIRData(IR::PersonalizedIRData *this, const void *a2)
{
  caulk::make_string((caulk *)"%p", (uint64_t)&__p, a2);
  IR::PersonalizedIRData::PersonalizedIRData(this);
}

{
  void *__p;

  caulk::make_string((caulk *)"%p", (uint64_t)&__p, a2);
  IR::PersonalizedIRData::PersonalizedIRData(this);
}

void sub_21B523A4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_21B523AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void IR::PersonalizedIRData::~PersonalizedIRData(IR::PersonalizedIRData::Implementation **this)
{
}

void *IR::PersonalizedIRData::UnregisterObservers(IR::PersonalizedIRData::Implementation **this)
{
  return IR::PersonalizedIRData::Implementation::UnregisterObservers(*this);
}

uint64_t IR::PersonalizedIRData::CleanUp(IR::PersonalizedIRData::Implementation **this)
{
  uint64_t v1 = *this;
  IR::PersonalizedIRData::Implementation::UnregisterObservers(*this);
  int v2 = *(IR::DataCache **)v1;

  return IR::DataCache::clearCFDataCache(v2);
}

void IR::PersonalizedIRData::RegisterObservers(uint64_t *a1, uint64_t a2, int a3)
{
}

void *IR::PersonalizedIRData::RebuildCFDataCache(IR::DataCache ***a1, uint64_t a2)
{
  v6[4] = *MEMORY[0x263EF8340];
  IR::DataCache::clearCFDataCache(**a1);
  uint64_t v4 = (uint64_t)**a1;
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
  IR::DataCache::DownloadAndCacheCFData(v4, (uint64_t)v6, *((unsigned char *)*a1 + 16) == 0);
  return std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100](v6);
}

void sub_21B523C10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void IR::PersonalizedIRData::GetCFData(uint64_t *a1@<X0>, int a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
}

uint64_t IR::PersonalizedIRData::GetStatus(IR::PersonalizedIRData *this)
{
  uint64_t v1 = **(void **)this;
  std::recursive_mutex::lock((std::recursive_mutex *)(v1 + 16));
  uint64_t v2 = *(void *)(v1 + 168);
  std::recursive_mutex::unlock((std::recursive_mutex *)(v1 + 16));
  return v2;
}

uint64_t IR::PersonalizedIRData::GetDataSource(IR::PersonalizedIRData *this)
{
  if (*(unsigned char *)(*(void *)this + 16)) {
    return 2;
  }
  else {
    return 1;
  }
}

uint64_t IR::PersonalizedIRData::ClearCache(IR::DataCache ***this)
{
  return IR::DataCache::clearCFDataCache(**this);
}

uint64_t IR::PersonalizedIRData::CheckIfPersonalizedHRIRIsAllowed(IR::PersonalizedIRData::Implementation **this, unsigned int *a2)
{
  return IR::PersonalizedIRData::Implementation::CheckIfPersonalizedHRIRIsAllowed(*this, a2);
}

uint64_t IR::PersonalizedIRData::IsPersonalizedHRIRAllowed(IR::PersonalizedIRData *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(*(void *)this + 17));
  return v1 & 1;
}

uint64_t IR::DataCache::DataCache(uint64_t a1, long long *a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  MEMORY[0x21D48F5D0](a1 + 16);
  *(void *)(a1 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 850045863;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  *(void *)(a1 + 136) = 0;
  uint64_t v4 = (std::string *)(a1 + 144);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *(void *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = *((void *)a2 + 2);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }
  *(unsigned char *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 172) = 1;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = 0;
  *(_WORD *)(a1 + 20std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 256;
  return a1;
}

void sub_21B523D68(_Unwind_Exception *a1)
{
  std::mutex::~mutex(v3);
  std::recursive_mutex::~recursive_mutex(v2);
  long long v5 = *(std::__shared_weak_count **)(v1 + 8);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

void std::shared_ptr<IR::DataCache>::shared_ptr[abi:ne180100]<IR::DataCache,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_21B523E18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    std::default_delete<IR::DataCache>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void std::shared_ptr<IR::DataCache>::__enable_weak_this[abi:ne180100]<IR::DataCache,IR::DataCache,void>(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      long long v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v5);
      }
    }
  }
}

void std::__shared_ptr_pointer<IR::DataCache *,std::shared_ptr<IR::DataCache>::__shared_ptr_default_delete<IR::DataCache,IR::DataCache>,std::allocator<IR::DataCache>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

void std::__shared_ptr_pointer<IR::DataCache *,std::shared_ptr<IR::DataCache>::__shared_ptr_default_delete<IR::DataCache,IR::DataCache>,std::allocator<IR::DataCache>>::__on_zero_shared(uint64_t a1)
{
}

void std::default_delete<IR::DataCache>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = 192;
    while (1)
    {
      uint64_t v4 = *(const void **)(a2 + v3);
      if (v4) {
        CFRelease(v4);
      }
      v3 -= 8;
      if (v3 == 176)
      {
        if (*(char *)(a2 + 167) < 0) {
          operator delete(*(void **)(a2 + 144));
        }
        std::mutex::~mutex((std::mutex *)(a2 + 80));
        std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(a2 + 16));
        long long v5 = *(std::__shared_weak_count **)(a2 + 8);
        if (v5) {
          std::__shared_weak_count::__release_weak(v5);
        }
        JUMPOUT(0x21D48F780);
      }
    }
  }
}

void ___ZN2IR9DataCache22DownloadAndCacheCFDataENSt3__18functionIFvNS_18PersonalizedIRData12DataValidityEEEEb_block_invoke(void *a1, void *a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = (std::__shared_weak_count *)a1[6];
  if (v7)
  {
    uint64_t v8 = a1[4];
    uint64_t v9 = std::__shared_weak_count::lock(v7);
    if (v9 && a1[5])
    {
      BOOL v10 = std::mutex::try_lock((std::mutex *)(v8 + 80));
      if (v10 && !*(unsigned char *)(v8 + 200))
      {
        uint64_t v13 = mach_absolute_time();
        std::recursive_mutex::lock((std::recursive_mutex *)(v8 + 16));
        *(unsigned char *)(v8 + 168) = 1;
        *(void *)(v8 + 176) = v13;
        *(_DWORD *)(v8 + 172) = 1;
        std::recursive_mutex::unlock((std::recursive_mutex *)(v8 + 16));
        if (!v5 || v6)
        {
          __int16 v14 = getPersonalizedIRDataLog();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v23 = (void *)(v8 + 144);
            if (*(char *)(v8 + 167) < 0) {
              std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v23 = (void *)*v23;
            }
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = v23;
            __int16 v32 = 2080;
            CFDataRef v33 = "DownloadAndCacheCFData_block_invoke";
            __int16 v34 = 2112;
            double v35 = *(double *)&v6;
            _os_log_impl(&dword_21B4DD000, v14, OS_LOG_TYPE_DEFAULT, "[%s|%s] Could not pull SoundProfile. Error: %@", buf, 0x20u);
          }
        }
        else
        {
          __int16 v14 = [v5 soundProfileData];
          int v15 = [v14 length];
          if (v15)
          {
            AudioObjectID v29 = v14;
            uint64_t v16 = a1[7];
            OSStatus v17 = getPersonalizedIRDataLog();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              float v18 = (double)(uint64_t)(v13 - v16) * 0.0000000416666667;
              float v19 = v18 * 1000.0;
              unsigned int v20 = (void *)(v8 + 144);
              if (*(char *)(v8 + 167) < 0) {
                unsigned int v20 = (void *)*v20;
              }
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = v20;
              __int16 v32 = 2080;
              CFDataRef v33 = "DownloadAndCacheCFData_block_invoke";
              __int16 v34 = 2048;
              double v35 = v19;
              __int16 v36 = 1024;
              int v37 = v15;
              _os_log_impl(&dword_21B4DD000, v17, OS_LOG_TYPE_DEFAULT, "[%s|%s] Successfully pulled SoundProfile pack in %.1fms. Size: %u", buf, 0x26u);
            }

            unsigned int v21 = v29;
            __int16 v14 = v21;
            if (v21) {
              CFRetain(v21);
            }
            applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)buf, v14);

            CFDataRef v22 = *(const void **)buf;
            if (*(void *)buf) {
              CFRetain(*(CFTypeRef *)buf);
            }
            CFTypeRef cf = v22;
            IR::DataCache::parseSoundProfileAndAddToCache(v8, (CFDataRef *)&cf);
            if (cf) {
              CFRelease(cf);
            }
            if (*(void *)buf) {
              CFRelease(*(CFTypeRef *)buf);
            }
          }
          else
          {
            std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v24 = getPersonalizedIRDataLog();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              int v25 = (void *)(v8 + 144);
              if (*(char *)(v8 + 167) < 0) {
                int v25 = (void *)*v25;
              }
              *(_DWORD *)buf = 136315650;
              *(void *)&uint8_t buf[4] = v25;
              __int16 v32 = 2080;
              CFDataRef v33 = "DownloadAndCacheCFData_block_invoke";
              __int16 v34 = 1024;
              LODWORD(v35) = 0;
              _os_log_impl(&dword_21B4DD000, v24, OS_LOG_TYPE_DEFAULT, "[%s|%s] Invalid SoundProfile pack. Length: %u", buf, 0x1Cu);
            }
          }
        }

        if (a1[11])
        {
          uint64_t v26 = getPersonalizedIRDataLog();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v27 = (void *)(v8 + 144);
            if (*(char *)(v8 + 167) < 0) {
              unint64_t v27 = (void *)*v27;
            }
            __int16 v28 = "Invalid";
            if (!*(_DWORD *)(v8 + 172)) {
              __int16 v28 = "Valid";
            }
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = v27;
            __int16 v32 = 2080;
            CFDataRef v33 = "DownloadAndCacheCFData_block_invoke";
            __int16 v34 = 2080;
            double v35 = *(double *)&v28;
            _os_log_impl(&dword_21B4DD000, v26, OS_LOG_TYPE_DEFAULT, "[%s|%s] Executing callback with DataValidity = %s.", buf, 0x20u);
          }

          std::function<void ()(IR::PersonalizedIRData::DataValidity)>::operator()((uint64_t)(a1 + 8), *(_DWORD *)(v8 + 172));
        }
      }
      else
      {
        unsigned __int8 v11 = getPersonalizedIRDataLog();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = "DownloadAndCacheCFData_block_invoke";
          _os_log_impl(&dword_21B4DD000, v11, OS_LOG_TYPE_DEFAULT, "%s: Aborting because DataCache is being destroyed.", buf, 0xCu);
        }

        if (!v10) {
          goto LABEL_48;
        }
      }
      std::mutex::unlock((std::mutex *)(v8 + 80));
LABEL_48:
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      goto LABEL_49;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  dispatch_queue_t v12 = getPersonalizedIRDataLog();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "DownloadAndCacheCFData_block_invoke";
    _os_log_impl(&dword_21B4DD000, v12, OS_LOG_TYPE_DEFAULT, "%s: Failed to save personalized HRIR type. The caller no longer exists.", buf, 0xCu);
  }

  if (v9) {
    goto LABEL_48;
  }
LABEL_49:
}

void sub_21B524468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IR::DataCache::parseSoundProfileAndAddToCache(uint64_t a1, CFDataRef *a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  applesauce::CF::make_DictionaryRef(a2, (applesauce::CF::DictionaryRef *)&v21);
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v20 = 0x200000001;
  uint64_t v16 = (uint64_t *)(a1 + 144);
  do
  {
    if (!v21)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x21D48F410](exception, "Could not construct");
    }
    int v5 = *(_DWORD *)((char *)&v20 + v3);
    if (v5 == 1) {
      id v6 = "HRIR_ITDMod";
    }
    else {
      id v6 = "HRIR_DFEQ";
    }
    *(void *)buf = v6;
    applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DataRef,char const*>((const __CFDictionary *)v21, (const char **)buf, &cf);
    if (v19)
    {
      std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 16));
      if (!v19) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      CFTypeRef v7 = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFTypeRef v17 = v7;
      IR::DataCache::addToCFDataCachePrivate(a1, v5, &v17);
      if (v17) {
        CFRelease(v17);
      }
      uint64_t v8 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = a1 + 144;
        if (*(char *)(a1 + 167) < 0) {
          uint64_t v9 = *v16;
        }
        if (!v19) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        if (!cf)
        {
          int v15 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x21D48F410](v15, "Could not construct");
        }
        int Length = CFDataGetLength((CFDataRef)cf);
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v9;
        __int16 v23 = 2080;
        std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v24 = "parseSoundProfileAndAddToCache";
        __int16 v25 = 1024;
        int v26 = v5;
        __int16 v27 = 1024;
        int v28 = Length;
        _os_log_impl(&dword_21B4DD000, v8, OS_LOG_TYPE_DEFAULT, "[%s|%s] Personalized HRIR type %u was found and stored in local CF cache. Length: %u.", buf, 0x22u);
      }

      std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 16));
    }
    else
    {
      unsigned __int8 v11 = getPersonalizedIRDataLog();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = a1 + 144;
        if (*(char *)(a1 + 167) < 0) {
          uint64_t v12 = *v16;
        }
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = v12;
        __int16 v23 = 2080;
        std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v24 = "parseSoundProfileAndAddToCache";
        __int16 v25 = 1024;
        int v26 = v5;
        _os_log_error_impl(&dword_21B4DD000, v11, OS_LOG_TYPE_ERROR, "[%s|%s] Invalid SoundProfile pack, could not find personalized HRIR type %u.", buf, 0x1Cu);
      }

      uint64_t v4 = 0xFFFFFFFFLL;
    }
    std::__optional_destruct_base<applesauce::CF::DataRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&cf);
    v3 += 4;
  }
  while (v3 != 8);
  if (v21) {
    CFRelease(v21);
  }
  if (!v4)
  {
    std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 16));
    *(_DWORD *)(a1 + 172) = 0;
    std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 16));
    return 0;
  }
  return v4;
}

void sub_21B524828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<void ()(IR::PersonalizedIRData::DataValidity)>::operator()(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t __copy_helper_block_ea8_40c38_ZTSNSt3__18weak_ptrIN2IR9DataCacheEEE64c66_ZTSKNSt3__18functionIFvN2IR18PersonalizedIRData12DataValidityEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::__value_func[abi:ne180100](a1 + 64, a2 + 64);
}

void sub_21B5249A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_ea8_40c38_ZTSNSt3__18weak_ptrIN2IR9DataCacheEEE64c66_ZTSKNSt3__18functionIFvN2IR18PersonalizedIRData12DataValidityEEEE(uint64_t a1)
{
  std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::~__value_func[abi:ne180100]((void *)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t std::tuple<BOOL,unsigned int,applesauce::CF::DataRef>::~tuple(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void IR::DataCache::addToCFDataCachePrivate(uint64_t a1, int a2, const void **a3)
{
  if (a2 == 2)
  {
    int v4 = *(const void **)(a1 + 192);
    id v6 = *a3;
    *(void *)(a1 + 192) = *a3;
    if (v6) {
      CFRetain(v6);
    }
    if (v4) {
      goto LABEL_6;
    }
  }
  else if (a2 == 1)
  {
    int v4 = *(const void **)(a1 + 184);
    int v5 = *a3;
    *(void *)(a1 + 184) = *a3;
    if (v5) {
      CFRetain(v5);
    }
    if (v4) {
LABEL_6:
    }
      CFRelease(v4);
  }
  else
  {
    CFTypeRef v7 = getPersonalizedIRDataLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      IR::DataCache::addToCFDataCachePrivate();
    }
  }
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DataRef,char const*>(const __CFDictionary *a1@<X0>, const char **a2@<X1>, unsigned char *a3@<X8>)
{
  int v4 = applesauce::CF::details::at_key<char const*>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  int v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFDataGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

const void *applesauce::CF::details::at_key<char const*>(const __CFDictionary *a1, const char **a2)
{
  int v4 = (const UInt8 *)*a2;
  CFIndex v5 = strlen(*a2);
  if (!v4)
  {
    if (a1) {
      goto LABEL_4;
    }
LABEL_7:
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  int v4 = (const UInt8 *)CFStringCreateWithBytes(0, v4, v5, 0x8000100u, 0);
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (!a1) {
    goto LABEL_7;
  }
LABEL_4:
  int Value = CFDictionaryGetValue(a1, v4);
  if (v4) {
LABEL_8:
  }
    CFRelease(v4);
LABEL_9:
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B524C4C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DataRef,char const(&)[32]>(const __CFDictionary *a1@<X0>, char *a2@<X1>, unsigned char *a3@<X8>)
{
  int v4 = applesauce::CF::details::at_key<char const(&)[32]>(a1, a2);
  if (!v4) {
    goto LABEL_5;
  }
  CFIndex v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFDataGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  *(void *)a3 = v5;
  char v7 = 1;
LABEL_6:
  a3[8] = v7;
}

const void *applesauce::CF::details::at_key<char const(&)[32]>(const __CFDictionary *a1, char *__s)
{
  CFIndex v5 = strlen(__s);
  CFStringRef v6 = CFStringCreateWithBytes(0, (const UInt8 *)__s, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x21D48F410](exception, "Could not construct");
  }
  if (a1) {
    int Value = CFDictionaryGetValue(a1, v6);
  }
  CFRelease(v6);
  if (!a1) {
    return 0;
  }
  return Value;
}

void sub_21B524DD8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void *___Z28AudioStatisticsLibraryLoaderv_block_invoke()
{
  uint64_t result = dlopen("/usr/lib/libAudioStatistics.dylib", 1);
  if (result)
  {
    uint64_t v1 = result;
    AudioStatisticsLibraryLoader(void)::libSym = (uint64_t)dlsym(result, "CreateSharedCAReportingClient");
    qword_267C57BF8 = (uint64_t)dlsym(v1, "CAReportingClientCreateReporterID");
    qword_267C57C00 = (uint64_t)dlsym(v1, "CAReportingClientCreateReporterIDFromSessionID");
    qword_267C57C08 = (uint64_t)dlsym(v1, "CAReportingClientCreatePerformanceReporterID");
    qword_267C57C10 = (uint64_t)dlsym(v1, "CAReportingClientStartReporter");
    qword_267C57C18 = (uint64_t)dlsym(v1, "CAReportingClientStopReporter");
    qword_267C57C20 = (uint64_t)dlsym(v1, "CAReportingClientSetAudioServiceType");
    qword_267C57C28 = (uint64_t)dlsym(v1, "CAReportingClientGetAudioServiceType");
    qword_267C57C30 = (uint64_t)dlsym(v1, "CAReportingClientSetConfiguration");
    qword_267C57C38 = (uint64_t)dlsym(v1, "CAReportingClientCopyConfiguration");
    qword_267C57C40 = (uint64_t)dlsym(v1, "CAReportingClientSendMessage");
    off_267C57C48 = (uint64_t (*)(void, void, void))dlsym(v1, "CAReportingClientSendSingleMessage");
    qword_267C57C50 = (uint64_t)dlsym(v1, "CAReportingClientDestroyReporterID");
    uint64_t result = dlsym(v1, "CAReportingClientRequestMessage");
    qword_267C57C58 = (uint64_t)result;
  }
  return result;
}

uint64_t std::pair<BOOL,applesauce::CF::DataRef>::pair[abi:ne180100]<BOOL,applesauce::CF::DataRef&,0>(uint64_t a1, unsigned char *a2, CFTypeRef *a3)
{
  *(unsigned char *)a1 = *a2;
  CFTypeRef v4 = *a3;
  if (*a3) {
    CFRetain(*a3);
  }
  *(void *)(a1 + 8) = v4;
  return a1;
}

uint64_t std::__function::__value_func<void ()(IR::PersonalizedIRData::DataValidity)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(IR::PersonalizedIRData::DataStatus)>::swap[abi:ne180100](void *result, void *a2)
{
  void v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    CFTypeRef v4 = (void *)result[3];
    CFIndex v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_21B52533C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::UnregisterObservers(void)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::UnregisterObservers(void)::$_0>,void ()(IR::PersonalizedIRData::DataStatus)>::~__func()
{
}

void *std::__function::__func<IR::PersonalizedIRData::Implementation::UnregisterObservers(void)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::UnregisterObservers(void)::$_0>,void ()(IR::PersonalizedIRData::DataStatus)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26CB57C80;
  return result;
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::UnregisterObservers(void)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::UnregisterObservers(void)::$_0>,void ()(IR::PersonalizedIRData::DataStatus)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26CB57C80;
}

void std::__shared_ptr_emplace<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::SyncUtils,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::SyncUtils>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB57CC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::SyncUtils,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::SyncUtils>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB57CC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

void std::__shared_ptr_emplace<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::SyncUtils,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::SyncUtils>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = (std::mutex *)(a1 + 24);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));

  std::mutex::~mutex(v1);
}

void *std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0>,void ()(IR::PersonalizedIRData::DataValidity)>::~__func(void *a1)
{
  *a1 = &unk_26CB57D00;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0>,void ()(IR::PersonalizedIRData::DataValidity)>::~__func(void *a1)
{
  *a1 = &unk_26CB57D00;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  JUMPOUT(0x21D48F780);
}

void *std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0>,void ()(IR::PersonalizedIRData::DataValidity)>::__clone(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = &unk_26CB57D00;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0>,void ()(IR::PersonalizedIRData::DataValidity)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_26CB57D00;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0>,void ()(IR::PersonalizedIRData::DataValidity)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0>,void ()(IR::PersonalizedIRData::DataValidity)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  operator delete(__p);
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_0>,void ()(IR::PersonalizedIRData::DataValidity)>::operator()(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 24);
  m = *(std::unique_lock<std::mutex>::mutex_type **)(a1 + 8);
  v7.__m_ = m;
  v7.__owns_ = 1;
  std::mutex::lock(m);
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v4 + 112))
  {
    CFIndex v5 = getPersonalizedIRDataLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v6 = (void *)(v2 + 56);
      if (*(char *)(v2 + 79) < 0) {
        CFStringRef v6 = (void *)*v6;
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v9 = v6;
      __int16 v10 = 2080;
      unsigned __int8 v11 = "operator()";
      _os_log_impl(&dword_21B4DD000, v5, OS_LOG_TYPE_DEFAULT, "[%s|%s] Already timed out.", buf, 0x16u);
    }
  }
  else
  {
    *(unsigned char *)(v4 + 113) = 1;
    std::unique_lock<std::mutex>::unlock(&v7);
    std::condition_variable::notify_all((std::condition_variable *)(*(void *)(a1 + 8) + 64));
    if (!v7.__owns_) {
      return;
    }
    m = v7.__m_;
  }
  std::mutex::unlock(m);
}

void sub_21B52574C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, char a10)
{
  if (a10) {
    std::mutex::unlock(a9);
  }
  _Unwind_Resume(exception_object);
}

void std::unique_lock<std::mutex>::unlock(std::unique_lock<std::mutex> *this)
{
  if (!this->__owns_)
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    JUMPOUT(0x21B5257B4);
  }
  std::mutex::unlock(this->__m_);
  this->__owns_ = 0;
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_2,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_2>,void ()(IR::PersonalizedIRData::DataValidity)>::~__func()
{
}

void *std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_2,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_2>,void ()(IR::PersonalizedIRData::DataValidity)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26CB57D48;
  return result;
}

void std::__function::__func<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_2,std::allocator<IR::PersonalizedIRData::Implementation::GetCFData(PersonalizedHRIRType,BOOL,unsigned int)::$_2>,void ()(IR::PersonalizedIRData::DataValidity)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26CB57D48;
}

id *std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100](id **a1, id *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    IR::PersonalizedIRData::Implementation::~Implementation(result);
    JUMPOUT(0x21D48F780);
  }
  return result;
}

void OUTLINED_FUNCTION_1_1(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_4_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x1Cu);
}

uint64_t IR::FFTFilter::Implementation::initialize(IR::FFTFilter::Implementation *this, int a2, int a3, unsigned int a4, int a5, unsigned int a6, int a7, int a8, BOOL a9, BOOL a10)
{
  if (*((unsigned char *)this + 45)) {
    (*(void (**)(IR::FFTFilter::Implementation *))(*(void *)this + 32))(this);
  }
  if (!a2)
  {
    (*(void (**)(IR::FFTFilter::Implementation *))(*(void *)this + 40))(this);
    return 4294967246;
  }
  if (a10) {
    unint64_t v18 = a4;
  }
  else {
    unint64_t v18 = 1;
  }
  *((_DWORD *)this + 6) = a4;
  *((_DWORD *)this + 7) = v18;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((_DWORD *)this + 8) = a7;
  *((unsigned char *)this + 46) = a8;
  if (a8) {
    *((_DWORD *)this + 8) = a3;
  }
  std::vector<std::vector<float>>::resize((uint64_t *)this + 42, v18);
  unsigned int v19 = *((_DWORD *)this + 3);
  if (!v19)
  {
    unsigned int v20 = *((_DWORD *)this + 2);
LABEL_21:
    *((_DWORD *)this + 4) = 0;
    *((_DWORD *)this + 5) = v20;
    *((_DWORD *)this + 3) = 0;
    if (*((_DWORD *)this + 7))
    {
      uint64_t v26 = 0;
      unint64_t v27 = 0;
      do
      {
        std::vector<float>::resize(*((void *)this + 42) + v26, a6 - 1 + *((_DWORD *)this + 2));
        ++v27;
        v26 += 24;
      }
      while (v27 < *((unsigned int *)this + 7));
    }
    std::vector<float>::resize((uint64_t)this + 384, a6);
    goto LABEL_46;
  }
  if (a5)
  {
    unsigned int v20 = *((_DWORD *)this + 2);
    if (v20 <= v19) {
      goto LABEL_21;
    }
  }
  int v21 = MultiRadixRealFFT::Size((IR::FFTFilter::Implementation *)((char *)this + 168));
  int v22 = *((_DWORD *)this + 3);
  if (v21 != 2 * v22)
  {
    uint64_t result = MultiRadixRealFFT::Initialize((IR::FFTFilter::Implementation *)((char *)this + 168), 2 * v22);
    if (result) {
      return result;
    }
  }
  if (a5)
  {
    *((_DWORD *)this + 5) = *((_DWORD *)this + 3);
    if (*((_DWORD *)this + 7))
    {
      uint64_t v24 = 0;
      unint64_t v25 = 0;
      do
      {
        std::vector<float>::resize(*((void *)this + 42) + v24, (2 * *((_DWORD *)this + 3) - 1));
        ++v25;
        v24 += 24;
      }
      while (v25 < *((unsigned int *)this + 7));
    }
  }
  else
  {
    *((_DWORD *)this + 5) = 0;
  }
  std::vector<float>::resize((uint64_t)this + 384, *((unsigned int *)this + 3));
  unsigned int v28 = *((_DWORD *)this + 3);
  unsigned int v29 = *((_DWORD *)this + 2) - *((_DWORD *)this + 5);
  if (v29 / v28 * v28 >= v29) {
    int v30 = v29 / v28;
  }
  else {
    int v30 = v29 / v28 + 1;
  }
  *((_DWORD *)this + 4) = v30;
  std::vector<std::vector<float>>::resize((uint64_t *)this + 39, *((unsigned int *)this + 7));
  if (*((_DWORD *)this + 7))
  {
    uint64_t v31 = 0;
    unint64_t v32 = 0;
    do
    {
      std::vector<float>::resize(*((void *)this + 39) + v31, *((unsigned int *)this + 3));
      ++v32;
      v31 += 24;
    }
    while (v32 < *((unsigned int *)this + 7));
  }
  std::vector<std::vector<float>>::resize((uint64_t *)this + 45, *((unsigned int *)this + 6));
  if (*((_DWORD *)this + 6))
  {
    uint64_t v33 = 0;
    unint64_t v34 = 0;
    do
    {
      std::vector<float>::resize(*((void *)this + 45) + v33, *((unsigned int *)this + 3));
      ++v34;
      v33 += 24;
    }
    while (v34 < *((unsigned int *)this + 6));
  }
  std::vector<float>::resize((uint64_t)this + 184, (2 * *((_DWORD *)this + 4) * *((_DWORD *)this + 3) * *((_DWORD *)this + 7)));
  std::vector<std::vector<DSPSplitComplex>>::resize((uint64_t *)this + 26, *((unsigned int *)this + 7));
  if (*((_DWORD *)this + 7))
  {
    unint64_t v35 = 0;
    unsigned int v36 = 0;
    uint64_t v37 = *((void *)this + 26);
    do
    {
      std::vector<DSPSplitComplex>::resize(v37 + 24 * v35, *((unsigned int *)this + 4));
      uint64_t v37 = *((void *)this + 26);
      uint64_t v38 = v37 + 24 * v35;
      AudioObjectPropertyAddress v39 = *(void **)v38;
      uint64_t v40 = *(void **)(v38 + 8);
      if (v39 != v40)
      {
        uint64_t v41 = *((void *)this + 23);
        int v42 = *((_DWORD *)this + 3);
        do
        {
          *AudioObjectPropertyAddress v39 = v41 + 4 * v36;
          v39[1] = v41 + 4 * (v42 + v36);
          v39 += 2;
          v36 += 2 * v42;
        }
        while (v39 != v40);
      }
      ++v35;
    }
    while (v35 < *((unsigned int *)this + 7));
  }
  int v43 = *((_DWORD *)this + 3);
  unsigned int v44 = 2 * v43;
  unsigned int v45 = 6 * v43;
  if (*((unsigned char *)this + 46)) {
    unint64_t v46 = v45;
  }
  else {
    unint64_t v46 = v44;
  }
  std::vector<float>::resize((uint64_t)this + 240, v46);
  uint64_t v47 = *((void *)this + 30);
  uint64_t v48 = *((unsigned int *)this + 3);
  *((void *)this + 33) = v47;
  *((void *)this + 34) = v47 + 4 * v48;
  if (*((unsigned char *)this + 46))
  {
    *((void *)this + 35) = v47 + 4 * (2 * v48);
    *((void *)this + 36) = v47 + 4 * (3 * v48);
    *((void *)this + 37) = v47 + 4 * (4 * v48);
    *((void *)this + 38) = v47 + 4 * (5 * v48);
  }
LABEL_46:
  *((unsigned char *)this + 47) = a9;
  if (a9)
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      OSStatus v50 = (char *)this + 32 * i;
      __int16 v51 = (uint64_t *)(v50 + 48);
      UInt32 v52 = (caulk::pooled_semaphore_mutex *)(v50 + 72);
      caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(v50 + 72));
      std::vector<IR::FFTFilterKernel>::resize(v51, a4);
      if (a4)
      {
        uint64_t v53 = 0;
        do
        {
          IR::FFTFilterKernel::initialize((IR::FFTFilterKernel *)(*v51 + v53), *((_DWORD *)this + 2), *((_DWORD *)this + 3), a5);
          IR::FFTFilterKernel::reset((IR::FFTFilterKernel *)(*v51 + v53));
          v53 += 40;
        }
        while (40 * a4 != v53);
      }
      caulk::pooled_semaphore_mutex::_unlock(v52);
    }
  }
  else
  {
    caulk::pooled_semaphore_mutex::_lock((IR::FFTFilter::Implementation *)((char *)this + 72));
    std::vector<IR::FFTFilterKernel>::resize((uint64_t *)this + 6, a4);
    if (a4)
    {
      uint64_t v54 = 0;
      do
      {
        IR::FFTFilterKernel::initialize((IR::FFTFilterKernel *)(*((void *)this + 6) + v54), *((_DWORD *)this + 2), *((_DWORD *)this + 3), a5);
        IR::FFTFilterKernel::reset((IR::FFTFilterKernel *)(*((void *)this + 6) + v54));
        v54 += 40;
      }
      while (40 * a4 != v54);
    }
    caulk::pooled_semaphore_mutex::_unlock((IR::FFTFilter::Implementation *)((char *)this + 72));
  }
  *((void *)this + 19) = (char *)this + 48;
  *((void *)this + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = (char *)this + 48;
  if (*((unsigned char *)this + 47)) {
    uint64_t v55 = (char *)this + 80;
  }
  else {
    uint64_t v55 = (char *)this + 48;
  }
  *((void *)this + 18) = v55;
  uint64_t v57 = 0;
  std::vector<float *>::assign((char **)this + 51, a4, &v57);
  unint64_t v56 = *((unsigned int *)this + 7);
  uint64_t v57 = 0;
  std::vector<float *>::assign((char **)this + 54, v56, &v57);
  (*(void (**)(IR::FFTFilter::Implementation *))(*(void *)this + 40))(this);
  uint64_t result = 0;
  *((unsigned char *)this + 45) = 1;
  return result;
}

char *std::vector<float *>::assign(char **a1, unint64_t a2, void *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 3)
  {
    unint64_t v13 = (a1[1] - result) >> 3;
    if (v13 >= a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (a1[1] - result) >> 3;
    }
    for (; v14; --v14)
    {
      *(void *)uint64_t result = *a3;
      result += 8;
    }
    if (a2 <= v13)
    {
      a1[1] = &(*a1)[8 * a2];
    }
    else
    {
      int v15 = a1[1];
      uint64_t v16 = &v15[8 * (a2 - v13)];
      uint64_t v17 = 8 * a2 - 8 * v13;
      do
      {
        *(void *)int v15 = *a3;
        v15 += 8;
        v17 -= 8;
      }
      while (v17);
      a1[1] = v16;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = v6 >> 2;
    if (v6 >> 2 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    uint64_t result = std::vector<std::unique_ptr<IR::FFTFilterKernel>>::__vallocate[abi:ne180100](a1, v9);
    __int16 v10 = a1[1];
    unsigned __int8 v11 = &v10[8 * a2];
    uint64_t v12 = 8 * a2;
    do
    {
      *(void *)__int16 v10 = *a3;
      v10 += 8;
      v12 -= 8;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

void IR::FFTFilter::Implementation::uninitialize(IR::FFTFilter::Implementation *this)
{
  uint64_t v2 = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_WORD *)this + 22) = 1;
  do
  {
    uint64_t v3 = (char *)this + 32 * v2;
    uint64_t v6 = *((void *)v3 + 6);
    uint64_t v4 = *((void *)v3 + 7);
    CFIndex v5 = v3 + 48;
    while (v4 != v6)
      IR::FFTFilterKernel::~FFTFilterKernel((IR::FFTFilterKernel *)(v4 - 40));
    *((void *)v5 + 1) = v6;
    caulk::pooled_semaphore_mutex::try_lock((IR::FFTFilter::Implementation *)((char *)this + 32 * v2 + 72));
    caulk::pooled_semaphore_mutex::_unlock((IR::FFTFilter::Implementation *)((char *)this + 32 * v2++ + 72));
  }
  while (v2 != 3);
  *((void *)this + 24) = *((void *)this + 23);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 26);
  *((_DWORD *)this + 58) = 0;
  *((void *)this + 31) = *((void *)this + 30);
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 39);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 42);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 45);
  *((void *)this + 49) = *((void *)this + 48);
  *((void *)this + 52) = *((void *)this + 51);
}

char *IR::FFTFilter::Implementation::getAndLockNextKernels(IR::FFTFilter::Implementation *this)
{
  uint64_t v6 = (caulk::pooled_semaphore_mutex *)(*((void *)this + 18) + 24);
  int v2 = caulk::pooled_semaphore_mutex::try_lock(v6);
  char v7 = v2;
  if (v2)
  {
    uint64_t v6 = 0;
    char v7 = 0;
    uint64_t v3 = (char *)*((void *)this + 18);
LABEL_10:
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v6);
    return v3;
  }
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v6);
  if (*((unsigned char *)this + 47))
  {
    uint64_t v4 = -96;
    while (1)
    {
      uint64_t v6 = (IR::FFTFilter::Implementation *)((char *)this + v4 + 168);
      char v7 = caulk::pooled_semaphore_mutex::try_lock(v6);
      if (v7) {
        break;
      }
      std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v6);
      v4 += 32;
      if (!v4)
      {
        caulk::pooled_semaphore_mutex::_lock((caulk::pooled_semaphore_mutex *)(*((void *)this + 18) + 24));
        return (char *)*((void *)this + 18);
      }
    }
    uint64_t v3 = (char *)this + v4 + 144;
    uint64_t v6 = 0;
    char v7 = 0;
    goto LABEL_10;
  }
  return (char *)*((void *)this + 18);
}

uint64_t IR::FFTFilter::Implementation::setFilterKernels(IR::FFTFilter::Implementation *this, IR::FFTFilterKernel **a2)
{
  if (!*((unsigned char *)this + 45)) {
    return 4294956429;
  }
  uint64_t v4 = -96;
  do
  {
    if ((IR::FFTFilterKernel **)((char *)this + v4 + 144) == a2)
    {
      uint64_t v12 = 0;
      *((void *)this + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = a2;
      unint64_t v13 = (IR::FFTFilter::Implementation *)((char *)this + v4 + 168);
      goto LABEL_20;
    }
    v4 += 32;
  }
  while (v4);
  Kernels = IR::FFTFilter::Implementation::getAndLockNextKernels(this);
  uint64_t v6 = *(void *)Kernels;
  uint64_t v7 = *((void *)Kernels + 1);
  if (a2[1] - *a2 == v7 - *(void *)Kernels)
  {
    if (!IR::FFTFilterKernel::getNumActiveFFTSubFilters(*a2)
      || IR::FFTFilterKernel::getPartitionLength(*a2) == *((_DWORD *)this + 3))
    {
      uint64_t v8 = *(void *)Kernels;
      if (*((void *)Kernels + 1) != *(void *)Kernels)
      {
        uint64_t v9 = 0;
        unsigned int v10 = 1;
        do
        {
          IR::FFTFilterKernel::operator=(v8 + 40 * v9, (uint64_t)*a2 + 40 * v9);
          uint64_t v9 = v10;
          uint64_t v8 = *(void *)Kernels;
          BOOL v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)Kernels + 1) - *(void *)Kernels) >> 3) > v10++;
        }
        while (v11);
      }
      uint64_t v12 = 0;
      goto LABEL_19;
    }
    uint64_t v6 = *(void *)Kernels;
    uint64_t v7 = *((void *)Kernels + 1);
  }
  if (v7 != v6)
  {
    uint64_t v14 = 0;
    unsigned int v15 = 1;
    do
    {
      IR::FFTFilterKernel::reset((IR::FFTFilterKernel *)(v6 + 40 * v14));
      uint64_t v14 = v15;
      uint64_t v6 = *(void *)Kernels;
      BOOL v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)Kernels + 1) - *(void *)Kernels) >> 3) > v15++;
    }
    while (v11);
  }
  uint64_t v12 = 4294956418;
LABEL_19:
  *((void *)this + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = Kernels;
  unint64_t v13 = (caulk::pooled_semaphore_mutex *)(Kernels + 24);
LABEL_20:
  caulk::pooled_semaphore_mutex::_unlock(v13);
  return v12;
}

unsigned int *IR::FFTFilter::Implementation::setFilterCoeffs(IR::FFTFilter::Implementation *this, const float *const *a2, int a3, unsigned int a4)
{
  if (!*((unsigned char *)this + 45)) {
    return (unsigned int *)4294956429;
  }
  Kernels = IR::FFTFilter::Implementation::getAndLockNextKernels(this);
  if (a3)
  {
    unint64_t v9 = 0;
    while (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)Kernels + 1) - *(void *)Kernels) >> 3) > v9)
    {
      unsigned int v10 = IR::FFTFilterKernel::storeCoeffs((IR::FFTFilterKernel *)(*(void *)Kernels + 40 * v9), a2[v9], a4, 0);
      if (v10)
      {
        BOOL v11 = v10;
        goto LABEL_10;
      }
      if (++v9 == a3) {
        break;
      }
    }
  }
  BOOL v11 = 0;
  *((void *)this + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = Kernels;
LABEL_10:
  caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(Kernels + 24));
  return v11;
}

uint64_t IR::FFTFilter::Implementation::initializeAndSetFilterKernels(IR::FFTFilter::Implementation *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, char a7)
{
  if (*(void *)(a2 + 8) == *(void *)a2) {
    return 4294956418;
  }
  MaxFilterint Length = IR::FFTFilterKernel::getMaxFilterLength(*(IR::FFTFilterKernel **)a2);
  Partitionint Length = IR::FFTFilterKernel::getPartitionLength(*(IR::FFTFilterKernel **)a2);
  HIBYTE(v17) = a7;
  LOBYTE(v17) = a6;
  uint64_t result = (*(uint64_t (**)(IR::FFTFilter::Implementation *, uint64_t, uint64_t, void, BOOL, uint64_t, uint64_t, uint64_t, __int16))(*(void *)a1 + 16))(a1, MaxFilterLength, PartitionLength, -858993459 * ((*(void *)(a2 + 8) - *(void *)a2) >> 3), ((*(void *)(*(void *)a2 + 8) - **(void **)a2) & 0x3FFFFFFFCLL) != 0, a3, a4, a5, v17);
  if (!result)
  {
    return IR::FFTFilter::Implementation::setFilterKernels(a1, (IR::FFTFilterKernel **)a2);
  }
  return result;
}

uint64_t IR::FFTFilter::Implementation::reset(float **this)
{
  vDSP_vclr(this[23], 1, this[24] - this[23]);
  vDSP_vclr(this[30], 1, this[31] - this[30]);
  *((_DWORD *)this + 58) = 0;
  if (*((_DWORD *)this + 7))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = this[39];
      if (0xAAAAAAAAAAAAAAABLL * (((char *)this[40] - (char *)v4) >> 3) > v3) {
        vDSP_vclr(*(float **)&v4[v2], 1, (uint64_t)(*(void *)&v4[v2 + 2] - *(void *)&v4[v2]) >> 2);
      }
      vDSP_vclr(*(float **)&this[42][v2], 1, (uint64_t)(*(void *)&this[42][v2 + 2] - *(void *)&this[42][v2]) >> 2);
      ++v3;
      v2 += 6;
    }
    while (v3 < *((unsigned int *)this + 7));
  }
  CFIndex v5 = this[45];
  uint64_t v6 = this[46];
  while (v5 != v6)
  {
    uint64_t v7 = *(float **)v5;
    uint64_t v8 = *((void *)v5 + 1);
    v5 += 6;
    vDSP_vclr(v7, 1, (v8 - (uint64_t)v7) >> 2);
  }
  uint64_t v9 = 0;
  unsigned int v10 = (char *)(this + 9);
  do
  {
    caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)&v10[v9]);
    uint64_t result = caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)&v10[v9]);
    v9 += 32;
  }
  while (v9 != 96);
  this[19] = this[20];
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
  *((unsigned char *)this + 44) = 1;
  return result;
}

float IR::FFTFilter::Implementation::threePointConv(IR::FFTFilter::Implementation *this, DSPSplitComplex *a2, DSPSplitComplex *a3, int a4, float a5)
{
  float __D = 0.5;
  float __B = a5 * 0.5;
  int v9 = a4 - 1;
  vDSP_vsmsma(a2->realp, 1, &__B, (const float *)a2->realp + 1, 1, &__D, a3->realp + 1, 1, (a4 - 1));
  unsigned int v10 = a2->realp + 1;
  realp = a3->realp;
  float *realp = (float)(__B * *v10) + (float)(*a2->realp * 0.5);
  vDSP_vsma(v10, 1, &__B, realp, 1, realp, 1, (a4 - 1));
  imagp = a2->imagp;
  unint64_t v13 = a3->imagp;
  a3->realp[v9] = a3->realp[v9] + (float)(__B * *imagp);
  vDSP_Length __N = (a4 - 2);
  vDSP_vsmsma(imagp + 1, 1, &__B, imagp + 2, 1, &__D, v13 + 2, 1, __N);
  unsigned int v15 = a2->imagp;
  uint64_t v16 = a3->imagp;
  v16[1] = v15[1] * 0.5;
  vDSP_vsma(v15 + 2, 1, &__B, v16 + 1, 1, v16 + 1, 1, __N);
  float result = (float)(a2->realp[v9] * a5) + (float)(*a2->imagp * 0.5);
  *a3->imagp = result;
  return result;
}

uint64_t IR::FFTFilter::Implementation::forwardTransform(IR::FFTFilter::Implementation *this, unsigned int a2, DSPComplex *__C)
{
  uint64_t v4 = (DSPSplitComplex *)(*(void *)(*((void *)this + 26) + 24 * a2) + 16 * *((unsigned int *)this + 58));
  vDSP_Length v5 = (unint64_t)*((unsigned int *)this + 3) >> 1;
  v7.realp = &v4->realp[v5];
  v7.imagp = &v4->imagp[v5];
  vDSP_ctoz(__C, 2, &v7, 1, v5);
  return MultiRadixRealFFT::RealInPlaceTransform((IR::FFTFilter::Implementation *)((char *)this + 168), v4, 1, 1.0);
}

void IR::FFTFilter::Implementation::fftBlockConvolution(IR::FFTFilter::Implementation *this, unsigned int a2, IR::FFTFilterKernel *a3)
{
  FFTSubFilters = (const DSPSplitComplex *)IR::FFTFilterKernel::getFFTSubFilters(a3);
  unsigned int NumActiveFFTSubFilters = IR::FFTFilterKernel::getNumActiveFFTSubFilters(a3);
  if (*((_DWORD *)this + 4) >= NumActiveFFTSubFilters) {
    unsigned int v8 = NumActiveFFTSubFilters;
  }
  else {
    unsigned int v8 = *((_DWORD *)this + 4);
  }
  if (v8)
  {
    uint64_t ComplexMultiplicationLengths = (_DWORD *)IR::FFTFilterKernel::getComplexMultiplicationLengths(a3);
    uint64_t v10 = *((unsigned int *)this + 58);
    BOOL v11 = (const DSPSplitComplex *)(*(void *)(*((void *)this + 26) + 24 * a2) + 16 * v10);
    unsigned int v39 = a2;
    __E = (DSPSplitComplex *)((char *)this + 264);
    vDSP_zvmul(v11, 1, FFTSubFilters, 1, (const DSPSplitComplex *)((char *)this + 264), 1, *ComplexMultiplicationLengths, 1);
    uint64_t v12 = (float *)*((void *)this + 33);
    *uint64_t v12 = *v11->realp * *FFTSubFilters->realp;
    uint64_t v13 = *ComplexMultiplicationLengths;
    int v14 = *((_DWORD *)this + 3);
    if (v14 == v13)
    {
      **((float **)this + 34) = *v11->imagp * *FFTSubFilters->imagp;
    }
    else
    {
      **((_DWORD **)this + 34) = 0;
      vDSP_vclr(&v12[v13], 1, (v14 - v13));
      vDSP_vclr((float *)(*((void *)this + 34) + 4 * *ComplexMultiplicationLengths), 1, (*((_DWORD *)this + 3) - *ComplexMultiplicationLengths));
    }
    unsigned int v15 = this;
    if (v10 + 1 == *((_DWORD *)this + 4)) {
      unsigned int v16 = 0;
    }
    else {
      unsigned int v16 = v10 + 1;
    }
    unsigned int v36 = ComplexMultiplicationLengths;
    unsigned int v37 = v8;
    if (v8 < 3)
    {
      unsigned int v30 = v16;
    }
    else
    {
      unint64_t v38 = v8 - 1;
      p_imagp = &FFTSubFilters[2].imagp;
      unint64_t v18 = (float *)*((void *)this + 33);
      unsigned int v19 = ComplexMultiplicationLengths + 2;
      unint64_t v20 = 1;
      do
      {
        uint64_t v21 = *(void *)(*((void *)v15 + 26) + 24 * v39);
        int v22 = v15;
        int v23 = *((_DWORD *)v15 + 4);
        if (v16 + 1 == v23) {
          uint64_t v24 = 0;
        }
        else {
          uint64_t v24 = v16 + 1;
        }
        if (v24 + 1 == v23) {
          unsigned int v25 = 0;
        }
        else {
          unsigned int v25 = v24 + 1;
        }
        unsigned int v41 = v25;
        float v26 = *v18;
        float v27 = **((float **)v15 + 34);
        unsigned int v28 = *(v19 - 1);
        if (v28 <= *v19) {
          vDSP_Length v29 = *v19;
        }
        else {
          vDSP_Length v29 = v28;
        }
        vDSP_zvmmaa((const DSPSplitComplex *)(v21 + 16 * v16), 1, (const DSPSplitComplex *)(p_imagp - 3), 1, (const DSPSplitComplex *)(v21 + 16 * v24), 1, (const DSPSplitComplex *)(p_imagp - 1), 1, __E, 1, __E, 1, v29);
        unsigned int v15 = v22;
        unint64_t v18 = (float *)*((void *)v22 + 33);
        *unint64_t v18 = v26
             + (float)((float)(**(float **)(v21 + 16 * v24) * **(p_imagp - 1))
                     + (float)(**(float **)(v21 + 16 * v16) * **(p_imagp - 3)));
        if (v29 == *((_DWORD *)v22 + 3)) {
          **((float **)v22 + 34) = v27
        }
                                 + (float)((float)(**(float **)(v21 + 16 * v24 + 8) * **p_imagp)
                                         + (float)(**(float **)(v21 + 16 * v16 + 8) * **(p_imagp - 2)));
        v19 += 2;
        v20 += 2;
        p_imagp += 4;
        unsigned int v30 = v41;
        unsigned int v16 = v41;
      }
      while (v20 < v38);
    }
    if ((v37 & 1) == 0)
    {
      uint64_t v31 = *(void *)(*((void *)v15 + 26) + 24 * v39);
      unint64_t v32 = v15;
      float v33 = **((float **)v15 + 33);
      float v34 = **((float **)v15 + 34);
      uint64_t v35 = v37 - 1;
      vDSP_zvma((const DSPSplitComplex *)(v31 + 16 * v30), 1, &FFTSubFilters[v35], 1, __E, 1, __E, 1, v36[v35]);
      **((float **)v32 + 33) = v33 + (float)(**(float **)(v31 + 16 * v30) * *FFTSubFilters[v35].realp);
      if (v36[v35] == *((_DWORD *)v32 + 3)) {
        **((float **)v32 + 34) = v34 + (float)(**(float **)(v31 + 16 * v30 + 8) * *FFTSubFilters[v35].imagp);
      }
    }
  }
}

void IR::FFTFilter::Implementation::inverseTransform(IR::FFTFilter::Implementation *this, DSPComplex *a2)
{
  MultiRadixRealFFT::RealInPlaceTransform((IR::FFTFilter::Implementation *)((char *)this + 168), (DSPSplitComplex *)((char *)this + 264), -1, 1.0);
  vDSP_Length v4 = (unint64_t)*((unsigned int *)this + 3) >> 1;
  vDSP_Length v5 = (float *)(*((void *)this + 34) + 4 * v4);
  v6.realp = (float *)(*((void *)this + 33) + 4 * v4);
  v6.imagp = v5;
  vDSP_ztoc(&v6, 1, a2, 2, v4);
}

void IR::FFTFilter::Implementation::saveInputForNextCycle(IR::FFTFilter::Implementation *this, unsigned int a2, unsigned int a3, DSPComplex *__C)
{
}

_DWORD *IR::FFTFilter::Implementation::firFilterTimeDomain(_DWORD *this, float *const *a2, float *const *a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v7 = this[6];
  unsigned int v6 = this[7];
  if (v6 >= a5) {
    uint64_t v8 = a5;
  }
  else {
    uint64_t v8 = v6;
  }
  if (v7 >= a6) {
    uint64_t v9 = a6;
  }
  else {
    uint64_t v9 = v7;
  }
  if (v8) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10 && (v8 >= v9 || v6 != v7))
  {
    LODWORD(v12) = a4;
    uint64_t v15 = (uint64_t)this;
    uint64_t v16 = 0;
    vDSP_Length v17 = a4;
    size_t v18 = 4 * a4;
    do
    {
      unsigned int v19 = *a2++;
      memcpy((void *)(*(void *)(*(void *)(v15 + 336) + v16) + 4 * *(unsigned int *)(v15 + 20) - 4), v19, v18);
      v16 += 24;
    }
    while (24 * v8 != v16);
    uint64_t v20 = 0;
    uint64_t v21 = 24;
    do
    {
      int v22 = (unsigned int *)(**(void **)(v15 + 152) + v21);
      unsigned int v23 = *(_DWORD *)(v15 + 20);
      if (*v22 >= v23) {
        vDSP_Length v24 = v23;
      }
      else {
        vDSP_Length v24 = *v22;
      }
      if (v8 == 1) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = v20;
      }
      vDSP_conv((const float *)(*(void *)(*(void *)(v15 + 336) + 24 * v25) + 4 * (v23 - v24)), 1, (const float *)(*((void *)v22 - 3) + 4 * v24 - 4), -1, a3[v20++], 1, v17, v24);
      v21 += 40;
    }
    while (v9 != v20);
    unsigned int v26 = *(_DWORD *)(v15 + 40);
    if (v26)
    {
      uint64_t v27 = 0;
      float v28 = (float)*(unsigned int *)(v15 + 32);
      float v29 = (float)v26 / v28;
      float __Step = -(float)(-1.0 / v28);
      float v39 = -1.0 / v28;
      if (v26 >= v12) {
        vDSP_Length v12 = v12;
      }
      else {
        vDSP_Length v12 = v26;
      }
      uint64_t v30 = 24;
      do
      {
        uint64_t v31 = (unsigned int *)(**(void **)(v15 + 144) + v30);
        unsigned int v32 = *(_DWORD *)(v15 + 20);
        if (*v31 >= v32) {
          vDSP_Length v33 = v32;
        }
        else {
          vDSP_Length v33 = *v31;
        }
        if (v8 == 1) {
          uint64_t v34 = 0;
        }
        else {
          uint64_t v34 = v27;
        }
        vDSP_conv((const float *)(*(void *)(*(void *)(v15 + 336) + 24 * v34) + 4 * (v32 - v33)), 1, (const float *)(*((void *)v31 - 3) + 4 * v33 - 4), -1, *(float **)(v15 + 384), 1, v12, v33);
        float __Start = 1.0 - v29;
        vDSP_vrampmul(a3[v27], 1, &__Start, &__Step, a3[v27], 1, v12);
        float __Start = v29;
        vDSP_vrampmuladd(*(const float **)(v15 + 384), 1, &__Start, &v39, a3[v27++], 1, v12);
        v30 += 40;
      }
      while (v9 != v27);
      int v35 = *(_DWORD *)(v15 + 40) - v12;
      *(_DWORD *)(v15 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v35;
      if (!v35) {
        caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(*(void *)(v15 + 144) + 24));
      }
    }
    uint64_t v36 = 0;
    do
    {
      this = memmove(*(void **)(*(void *)(v15 + 336) + v36), (const void *)(*(void *)(*(void *)(v15 + 336) + v36) + 4 * v17), 4 * (*(_DWORD *)(v15 + 20) - 1));
      v36 += 24;
      --v8;
    }
    while (v8);
  }
  return this;
}

uint64_t IR::FFTFilter::Implementation::process(IR::FFTFilter::Implementation *this, const float *a2, float *const *a3, uint64_t a4, uint64_t a5, IR::ComplexDataCircBuffer *a6)
{
  v7[1] = *MEMORY[0x263EF8340];
  v7[0] = a2;
  return (*(uint64_t (**)(IR::FFTFilter::Implementation *, void *, float *const *, uint64_t, uint64_t, uint64_t, IR::ComplexDataCircBuffer *))(*(void *)this + 56))(this, v7, a3, a4, 1, a5, a6);
}

uint64_t IR::FFTFilter::Implementation::processMultipleInputs(IR::FFTFilter::Implementation *this, float *const *a2, float *const *a3, uint64_t a4, unsigned int a5, unsigned int a6, IR::ComplexDataCircBuffer *a7)
{
  if (!*((unsigned char *)this + 45)) {
    return 4294956429;
  }
  uint64_t v7 = a4;
  if (a4)
  {
    unsigned int v10 = *((_DWORD *)this + 6);
    unsigned int v9 = *((_DWORD *)this + 7);
    if (v9 >= a5) {
      uint64_t v11 = a5;
    }
    else {
      uint64_t v11 = v9;
    }
    if (v10 >= a6) {
      uint64_t v12 = a6;
    }
    else {
      uint64_t v12 = v10;
    }
    if (v11) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13) {
      return 4294967246;
    }
    if (v11 < v12 && v9 == v10) {
      return 4294967246;
    }
    if (*((_DWORD *)this + 2))
    {
      if (*((unsigned char *)this + 44))
      {
        if (caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(*((void *)this + 20) + 24))) {
          *((void *)this + 19) = *((void *)this + 20);
        }
        uint64_t v74 = 0;
        char v75 = 0;
        *((unsigned char *)this + 44) = 0;
        std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v74);
      }
      if (*((_DWORD *)this + 4))
      {
        uint64_t v17 = 0;
        do
        {
          *(float **)(*((void *)this + 54) + 8 * v17) = a2[v17];
          ++v17;
        }
        while (v11 != v17);
        uint64_t v18 = 0;
        do
        {
          *(float **)(*((void *)this + 51) + 8 * v18) = a3[v18];
          ++v18;
        }
        while (v12 != v18);
        unsigned int v19 = (const DSPSplitComplex *)((char *)this + 264);
        uint64_t v69 = (const DSPSplitComplex *)((char *)this + 280);
        unsigned int v20 = *((_DWORD *)this + 9);
        do
        {
          unsigned int v21 = *((_DWORD *)this + 3);
          BOOL v22 = v21 >= v20;
          unsigned int v23 = v21 - v20;
          if (v23 != 0 && v22)
          {
            uint64_t v24 = 0;
            uint64_t v25 = 0;
            if (v23 >= v7) {
              vDSP_Length v26 = v7;
            }
            else {
              vDSP_Length v26 = v23;
            }
            do
            {
              memcpy((void *)(*(void *)(*((void *)this + 39) + v24) + 4 * *((unsigned int *)this + 9)), *(const void **)(*((void *)this + 54) + 8 * v25++), 4 * v26);
              v24 += 24;
            }
            while (v11 != v25);
            if (*((_DWORD *)this + 5))
            {
              (*(void (**)(IR::FFTFilter::Implementation *, void, void, vDSP_Length, uint64_t, uint64_t))(*(void *)this + 104))(this, *((void *)this + 54), *((void *)this + 51), v26, v11, v12);
              uint64_t v27 = 0;
              uint64_t v28 = 0;
              do
              {
                vDSP_vadd(*(const float **)(*((void *)this + 51) + 8 * v28), 1, (const float *)(*(void *)(*((void *)this + 45) + v27) + 4 * *((unsigned int *)this + 9)), 1, *(float **)(*((void *)this + 51) + 8 * v28), 1, v26);
                ++v28;
                v27 += 24;
              }
              while (v12 != v28);
            }
            else
            {
              uint64_t v34 = 0;
              uint64_t v35 = 0;
              do
              {
                memcpy(*(void **)(*((void *)this + 51) + 8 * v35++), (const void *)(*(void *)(*((void *)this + 45) + v34) + 4 * *((unsigned int *)this + 9)), 4 * v26);
                v34 += 24;
              }
              while (v12 != v35);
            }
            uint64_t v36 = 0;
            LODWORD(v7) = v7 - v26;
            do
              *(void *)(*((void *)this + 54) + 8 * v36++) += 4 * v26;
            while (v11 != v36);
            uint64_t v37 = 0;
            do
              *(void *)(*((void *)this + 51) + 8 * v37++) += 4 * v26;
            while (v12 != v37);
            unsigned int v20 = *((_DWORD *)this + 9) + v26;
          }
          else
          {
            if (*((unsigned char *)this + 47))
            {
              uint64_t v29 = *((void *)this + 20);
              if (v29 != *((void *)this + 19) && !*((_DWORD *)this + 10))
              {
                uint64_t v74 = v29 + 24;
                int v30 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v29 + 24));
                char v75 = v30;
                if (v30)
                {
                  uint64_t v31 = *((void *)this + 19);
                  uint64_t v32 = *((void *)this + 20);
                  if (v32 != v31)
                  {
                    *((void *)this + 18) = v31;
                    *((void *)this + 19) = v32;
                    uint64_t v74 = 0;
                    char v75 = 0;
                    int v33 = *((_DWORD *)this + 8);
                    if (v33) {
                      *((_DWORD *)this + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v33 - 1;
                    }
                    else {
                      caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v31 + 24));
                    }
                  }
                }
                std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v74);
              }
            }
            uint64_t v38 = 0;
            uint64_t v39 = 0;
            do
            {
              (*(void (**)(IR::FFTFilter::Implementation *, uint64_t, void))(*(void *)this + 72))(this, v39++, *(void *)(*((void *)this + 39) + v38));
              v38 += 24;
            }
            while (v11 != v39);
            unsigned int v40 = *((_DWORD *)this + 10);
            if (v40)
            {
              int v71 = v7;
              unsigned int v41 = *((_DWORD *)this + 3);
              if (v41 >= v40) {
                vDSP_Length v42 = v40;
              }
              else {
                vDSP_Length v42 = v41;
              }
              int v70 = v42;
              if (*((unsigned char *)this + 46))
              {
                uint64_t v43 = 0;
                uint64_t v44 = 0;
                uint64_t v45 = 0;
                unint64_t v46 = v19;
                do
                {
                  if (v11 == 1) {
                    uint64_t v47 = 0;
                  }
                  else {
                    uint64_t v47 = v45;
                  }
                  (*(void (**)(IR::FFTFilter::Implementation *, uint64_t, uint64_t))(*(void *)this + 80))(this, v47, **((void **)this + 18) + v44);
                  (*(void (**)(IR::FFTFilter::Implementation *, const DSPSplitComplex *, const DSPSplitComplex *, void, float))(*(void *)this + 112))(this, v19, v69, *((unsigned int *)this + 3), -0.5);
                  (*(void (**)(IR::FFTFilter::Implementation *, uint64_t, uint64_t))(*(void *)this + 80))(this, v47, **((void **)this + 19) + v44);
                  (*(void (**)(IR::FFTFilter::Implementation *, const DSPSplitComplex *, char *, void, float))(*(void *)this + 112))(this, v19, (char *)this + 296, *((unsigned int *)this + 3), 0.5);
                  vDSP_zvadd(v69, 1, (const DSPSplitComplex *)((char *)this + 296), 1, v19, 1, *((unsigned int *)this + 3));
                  (*(void (**)(IR::FFTFilter::Implementation *, void))(*(void *)this + 88))(this, *(void *)(*((void *)this + 45) + v43));
                  ++v45;
                  v44 += 40;
                  v43 += 24;
                }
                while (v12 != v45);
              }
              else
              {
                uint64_t v52 = 0;
                uint64_t v53 = 0;
                uint64_t v54 = 0;
                float v55 = (float)*((unsigned int *)this + 8);
                float v56 = (float)v40 / v55;
                float __Step = -(float)(-1.0 / v55);
                *(float *)&uint64_t v74 = -1.0 / v55;
                do
                {
                  if (v11 == 1) {
                    uint64_t v57 = 0;
                  }
                  else {
                    uint64_t v57 = v54;
                  }
                  (*(void (**)(IR::FFTFilter::Implementation *, uint64_t, uint64_t))(*(void *)this + 80))(this, v57, **((void **)this + 18) + v53);
                  (*(void (**)(IR::FFTFilter::Implementation *, void))(*(void *)this + 88))(this, *((void *)this + 48));
                  (*(void (**)(IR::FFTFilter::Implementation *, uint64_t, uint64_t))(*(void *)this + 80))(this, v57, **((void **)this + 19) + v53);
                  (*(void (**)(IR::FFTFilter::Implementation *, void))(*(void *)this + 88))(this, *(void *)(*((void *)this + 45) + v52));
                  float __Start = 1.0 - v56;
                  vDSP_vrampmul(*(const float **)(*((void *)this + 45) + v52), 1, &__Start, &__Step, *(float **)(*((void *)this + 45) + v52), 1, v42);
                  float __Start = v56;
                  vDSP_vrampmuladd(*((const float **)this + 48), 1, &__Start, (const float *)&v74, *(float **)(*((void *)this + 45) + v52), 1, v42);
                  ++v54;
                  v53 += 40;
                  v52 += 24;
                }
                while (v12 != v54);
                unint64_t v46 = v19;
              }
              LODWORD(v7) = v71;
              unsigned int v19 = v46;
              if (!*((_DWORD *)this + 5))
              {
                int v58 = *((_DWORD *)this + 10) - v70;
                *((_DWORD *)this + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v58;
                if (!v58) {
                  caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(*((void *)this + 18) + 24));
                }
              }
            }
            else
            {
              uint64_t v48 = 0;
              uint64_t v49 = 0;
              uint64_t v50 = 0;
              do
              {
                if (v11 == 1) {
                  uint64_t v51 = 0;
                }
                else {
                  uint64_t v51 = v50;
                }
                (*(void (**)(IR::FFTFilter::Implementation *, uint64_t, uint64_t))(*(void *)this + 80))(this, v51, **((void **)this + 19) + v49);
                (*(void (**)(IR::FFTFilter::Implementation *, void))(*(void *)this + 88))(this, *(void *)(*((void *)this + 45) + v48));
                ++v50;
                v49 += 40;
                v48 += 24;
              }
              while (v12 != v50);
            }
            int v59 = *((_DWORD *)this + 58);
            if (!v59) {
              int v59 = *((_DWORD *)this + 4);
            }
            uint64_t v60 = 0;
            uint64_t v61 = 0;
            uint64_t v62 = (v59 - 1);
            do
            {
              (*(void (**)(IR::FFTFilter::Implementation *, uint64_t, uint64_t, void))(*(void *)this + 96))(this, v61++, v62, *(void *)(*((void *)this + 39) + v60));
              v60 += 24;
            }
            while (v11 != v61);
            unsigned int v20 = 0;
            *((_DWORD *)this + 58) = v62;
          }
          *((_DWORD *)this + 9) = v20;
        }
        while (v7);
      }
      else
      {
        if (*((unsigned char *)this + 47))
        {
          uint64_t v64 = *((void *)this + 20);
          if (v64 != *((void *)this + 19) && !*((_DWORD *)this + 10))
          {
            uint64_t v74 = v64 + 24;
            int v65 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v64 + 24));
            char v75 = v65;
            if (v65)
            {
              uint64_t v66 = *((void *)this + 19);
              uint64_t v67 = *((void *)this + 20);
              if (v67 != v66)
              {
                *((void *)this + 18) = v66;
                *((void *)this + 19) = v67;
                uint64_t v74 = 0;
                char v75 = 0;
                int v68 = *((_DWORD *)this + 8);
                if (v68) {
                  *((_DWORD *)this + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v68 - 1;
                }
                else {
                  caulk::pooled_semaphore_mutex::_unlock((caulk::pooled_semaphore_mutex *)(v66 + 24));
                }
              }
            }
            std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v74);
          }
        }
        (*(void (**)(IR::FFTFilter::Implementation *, float *const *, float *const *, uint64_t, uint64_t, uint64_t, IR::ComplexDataCircBuffer *))(*(void *)this + 104))(this, a2, a3, v7, v11, v12, a7);
      }
      return 0;
    }
    return 4294956429;
  }
  return 0;
}

void sub_21B527628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *IR::FFTFilter::FFTFilter(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *float result = &unk_26CB57070;
  result[1] = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  *float result = &unk_26CB57070;
  result[1] = v2;
  return result;
}

void IR::FFTFilter::FFTFilter(IR::FFTFilter *this)
{
}

{
  operator new();
}

void sub_21B5277D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v12 + 48);
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (; v11; v11 -= 32)
  {
    a10 = (void **)(v10 + 16 + v11);
    std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a10);
  }
  MEMORY[0x21D48F780](v10, 0x10A1C404F441B48);
  _Unwind_Resume(a1);
}

void sub_21B527974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v12 + 48);
  std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (; v11; v11 -= 32)
  {
    a10 = (void **)(v10 + 16 + v11);
    std::vector<IR::FFTFilterKernel>::__destroy_vector::operator()[abi:ne180100](&a10);
  }
  MEMORY[0x21D48F780](v10, 0x10A1C404F441B48);
  _Unwind_Resume(a1);
}

void IR::FFTFilter::~FFTFilter(IR::FFTFilter *this)
{
  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_26CB57070;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;

  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_26CB57070;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_26CB57070;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x21D48F780);
}

uint64_t IR::FFTFilter::initialize(IR::FFTFilter *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *((void *)this + 1);
  if (!v7) {
    return 4294956429;
  }
  __int16 v9 = 1;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, __int16))(*(void *)v7 + 16))(v7, a2, a3, a4, a5, a6, a7, 0, v9);
}

uint64_t IR::FFTFilter::initialize(IR::FFTFilter *this, unsigned int a2, unsigned int a3, unsigned int a4, BOOL a5, unsigned int a6, unsigned int a7, BOOL a8, BOOL a9, BOOL a10)
{
  uint64_t v10 = *((void *)this + 1);
  if (v10) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  }
  else {
    return 4294956429;
  }
}

uint64_t IR::FFTFilter::initializeAndSetFilterKernels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, void))(*(void *)v4 + 24))(v4, a2, a3, a4, 0, 1, 0);
  }
  else {
    return 4294956429;
  }
}

uint64_t IR::FFTFilter::initializeAndSetFilterKernels(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 24))();
  }
  else {
    return 4294956429;
  }
}

uint64_t IR::FFTFilter::uninitialize(IR::FFTFilter *this)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t IR::FFTFilter::reset(IR::FFTFilter *this)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

char *IR::FFTFilter::getScratchKernels(IR::FFTFilter *this)
{
  uint64_t v1 = (IR::FFTFilter::Implementation *)*((void *)this + 1);
  if (v1 && *((unsigned char *)v1 + 45)) {
    return IR::FFTFilter::Implementation::getAndLockNextKernels(v1);
  }
  else {
    return 0;
  }
}

uint64_t IR::FFTFilter::setFilterKernels(uint64_t a1, IR::FFTFilterKernel **a2)
{
  uint64_t v2 = *(IR::FFTFilter::Implementation **)(a1 + 8);
  if (v2) {
    return IR::FFTFilter::Implementation::setFilterKernels(v2, a2);
  }
  else {
    return 4294956429;
  }
}

unsigned int *IR::FFTFilter::setFilterCoeffs(IR::FFTFilter *this, const float *const *a2, int a3, unsigned int a4)
{
  uint64_t v4 = (IR::FFTFilter::Implementation *)*((void *)this + 1);
  if (v4) {
    return IR::FFTFilter::Implementation::setFilterCoeffs(v4, a2, a3, a4);
  }
  else {
    return (unsigned int *)4294956429;
  }
}

uint64_t IR::FFTFilter::getNumActiveSubFilters(IR::FFTFilter *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return IR::FFTFilterKernel::getNumActiveFFTSubFilters(**(IR::FFTFilterKernel ***)(v1 + 152));
  }
  else {
    return 0;
  }
}

uint64_t IR::FFTFilter::getFIRFilterLength(IR::FFTFilter *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return *(unsigned int *)(v1 + 20);
  }
  else {
    return 0;
  }
}

uint64_t IR::FFTFilter::getPartitionLength(IR::FFTFilter *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return *(unsigned int *)(v1 + 12);
  }
  else {
    return 0;
  }
}

uint64_t IR::FFTFilter::getConfigParams@<X0>(IR::FFTFilter *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 16) = 0;
  return result;
}

uint64_t IR::FFTFilter::process(IR::FFTFilter *this, const float *a2, float *const *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    return (*(uint64_t (**)(uint64_t, const float *, float *const *, uint64_t, uint64_t, void))(*(void *)v5 + 48))(v5, a2, a3, a4, a5, 0);
  }
  else {
    return 4294956429;
  }
}

uint64_t IR::FFTFilter::process(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 48))();
  }
  else {
    return 4294956429;
  }
}

uint64_t IR::FFTFilter::processMultipleInputs(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 56))();
  }
  else {
    return 4294956429;
  }
}

uint64_t IR::FFTFilter::doXFadeUpdate(IR::FFTFilter *this)
{
  return *(unsigned __int8 *)(*((void *)this + 1) + 47);
}

uint64_t IR::FFTFilterKernel::FFTFilterKernel(uint64_t this)
{
  *(void *)(this + 32) = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

{
  *(void *)(this + 32) = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

IR::FFTFilterKernel *IR::FFTFilterKernel::FFTFilterKernel(IR::FFTFilterKernel *this, unsigned int a2, unsigned int a3, int a4)
{
  *((void *)this + 4) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((_DWORD *)this + 6) = 0;
  IR::FFTFilterKernel::initialize(this, a2, a3, a4);
  return this;
}

void sub_21B527EC0(_Unwind_Exception *a1)
{
  uint64_t v4 = (void *)*v2;
  void *v2 = 0;
  if (v4) {
    std::default_delete<IR::FFTSubFilterData>::operator()[abi:ne180100]((uint64_t)v2, v4);
  }
  IR::FFTFilterKernel::FFTFilterKernel(v1);
  _Unwind_Resume(a1);
}

void IR::FFTFilterKernel::initialize(IR::FFTFilterKernel *this, unsigned int a2, unsigned int a3, int a4)
{
  if (a3 >= a2) {
    unsigned int v7 = a2;
  }
  else {
    unsigned int v7 = a3;
  }
  if (a4) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 0;
  }
  if (a3) {
    unint64_t v9 = v8;
  }
  else {
    unint64_t v9 = a2;
  }
  std::vector<float>::resize((uint64_t)this, v9);
  uint64_t v12 = (int *)*((void *)this + 4);
  uint64_t v11 = (void *)((char *)this + 32);
  uint64_t v10 = v12;
  if (v12) {
    int v13 = *v10;
  }
  else {
    int v13 = 0;
  }
  if (v13 != a3 || a3 && (!v10 ? (int v14 = 0) : (int v14 = v10[1]), v14 != vcvtps_u32_f32((float)(a2 - v8) / (float)a3)))
  {
    if (a2 > v9) {
      operator new();
    }
    *uint64_t v11 = 0;
    if (v10)
    {
      std::default_delete<IR::FFTSubFilterData>::operator()[abi:ne180100]((uint64_t)v11, v10);
    }
  }
}

void sub_21B527FF8(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v1, 0x10B0C40B59F3A2CLL);
  _Unwind_Resume(a1);
}

IR::FFTFilterKernel *IR::FFTFilterKernel::FFTFilterKernel(IR::FFTFilterKernel *this, const IR::FFTFilterKernel *a2)
{
  *((void *)this + 4) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((_DWORD *)this + 6) = 0;
  IR::FFTFilterKernel::operator=((uint64_t)this, (uint64_t)a2);
  return this;
}

void sub_21B528064(_Unwind_Exception *a1)
{
  uint64_t v4 = (void *)*v2;
  void *v2 = 0;
  if (v4) {
    std::default_delete<IR::FFTSubFilterData>::operator()[abi:ne180100]((uint64_t)v2, v4);
  }
  IR::FFTFilterKernel::FFTFilterKernel(v1);
  _Unwind_Resume(a1);
}

uint64_t IR::FFTFilterKernel::operator=(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    uint64_t v4 = *(char **)(a1 + 32);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
    uint64_t v5 = *(void *)(a2 + 32);
    if (v5)
    {
      if (!v4) {
        operator new();
      }
      IR::FFTSubFilterData::operator=(v4, v5);
    }
    else
    {
      *(void *)(a1 + 32) = 0;
      if (v4) {
        std::default_delete<IR::FFTSubFilterData>::operator()[abi:ne180100](a1 + 32, v4);
      }
    }
  }
  return a1;
}

void sub_21B52814C(_Unwind_Exception *a1)
{
  MEMORY[0x21D48F780](v1, 0x10B0C40B59F3A2CLL);
  _Unwind_Resume(a1);
}

__n128 IR::FFTFilterKernel::FFTFilterKernel(uint64_t a1, __n128 *a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  *(_DWORD *)(a1 + 24) = a2[1].n128_u32[2];
  unint64_t v3 = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = 0;
  *(void *)(a1 + 32) = v3;
  return result;
}

{
  __n128 result;
  unint64_t v3;

  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  *(_DWORD *)(a1 + 24) = a2[1].n128_u32[2];
  unint64_t v3 = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = 0;
  *(void *)(a1 + 32) = v3;
  return result;
}

void IR::FFTFilterKernel::~FFTFilterKernel(IR::FFTFilterKernel *this)
{
  uint64_t v4 = (void *)*((void *)this + 4);
  uint64_t v2 = (void *)((char *)this + 32);
  unint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    std::default_delete<IR::FFTSubFilterData>::operator()[abi:ne180100]((uint64_t)v2, v3);
  }
  uint64_t v5 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v5;
    operator delete(v5);
  }
}

uint64_t IR::FFTFilterKernel::operator=(uint64_t a1, __n128 *a2)
{
  std::vector<float>::__move_assign(a1, a2);
  unsigned __int32 v4 = a2[1].n128_u32[2];
  unint64_t v5 = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = 0;
  unsigned int v6 = *(void **)(a1 + 32);
  *(_DWORD *)(a1 + 24) = v4;
  *(void *)(a1 + 32) = v5;
  if (v6) {
    std::default_delete<IR::FFTSubFilterData>::operator()[abi:ne180100](a1 + 32, v6);
  }
  return a1;
}

uint64_t IR::FFTFilterKernel::calculateFIRFilterLength(uint64_t this, unsigned int a2, int a3)
{
  if (a2 >= this) {
    unsigned int v3 = this;
  }
  else {
    unsigned int v3 = a2;
  }
  if (!a3) {
    unsigned int v3 = 0;
  }
  if (a2) {
    return v3;
  }
  else {
    return this;
  }
}

uint64_t IR::FFTFilterKernel::getPartitionLength(IR::FFTFilterKernel *this)
{
  uint64_t v1 = (unsigned int *)*((void *)this + 4);
  if (v1) {
    return *v1;
  }
  else {
    return 0;
  }
}

uint64_t IR::FFTFilterKernel::getNumFFTSubFilters(IR::FFTFilterKernel *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    return *(unsigned int *)(v1 + 4);
  }
  else {
    return 0;
  }
}

unsigned int *IR::FFTFilterKernel::storeCoeffs(IR::FFTFilterKernel *this, const float *a2, unsigned int a3, MultiRadixRealFFT *a4)
{
  return IR::FFTFilterKernel::storeCoeffs(this, a2, a3, a4, 0, 0, 1.0);
}

unsigned int *IR::FFTFilterKernel::storeCoeffs(IR::FFTFilterKernel *this, const float *__A, unsigned int a3, MultiRadixRealFFT *a4, uint64_t a5, unsigned int a6, float a7)
{
  float __B = a7;
  if (a3)
  {
    uint64_t v13 = (*((void *)this + 1) - *(void *)this) >> 2;
    if (v13 >= a3) {
      vDSP_Length v14 = a3;
    }
    else {
      vDSP_Length v14 = v13;
    }
    vDSP_vsmul(__A, 1, &__B, *(float **)this, 1, v14);
    uint64_t v15 = *(void *)this;
    uint64_t v16 = (*((void *)this + 1) - *(void *)this) >> 2;
    int v17 = v14 + 1;
    uint64_t v18 = 4 * v14;
    while (v18)
    {
      float v19 = *(float *)(*(void *)this - 4 + v18);
      --v17;
      v18 -= 4;
      if (v19 != 0.0) {
        goto LABEL_8;
      }
    }
    int v17 = 0;
LABEL_8:
    *((_DWORD *)this + 6) = v17;
    if (v14 == v16)
    {
      __n128 result = (unsigned int *)*((void *)this + 4);
      if (!result) {
        return result;
      }
      if (v13 < a3) {
        return (unsigned int *)IR::FFTSubFilterData::setFilter(result, (uint64_t)&__A[v14], a3 - v14, a4, a5, a6, __B);
      }
    }
    else
    {
      bzero((void *)(v15 + 4 * v14), 4 * (v16 - v14));
      __n128 result = (unsigned int *)*((void *)this + 4);
      if (!result) {
        return result;
      }
    }
    IR::FFTSubFilterData::reset((void **)result);
  }
  else
  {
    IR::FFTFilterKernel::reset(this);
  }
  return 0;
}

unsigned int *IR::FFTFilterKernel::storeCoeffs(IR::FFTFilterKernel *a1, const float *a2, unsigned int a3, MultiRadixRealFFT *a4, uint64_t a5, unsigned int a6)
{
  return IR::FFTFilterKernel::storeCoeffs(a1, a2, a3, a4, a5, a6, 1.0);
}

void IR::FFTFilterKernel::reset(IR::FFTFilterKernel *this)
{
  uint64_t v2 = *(void **)this;
  uint64_t v3 = *((void *)this + 1) - (void)v2;
  if (v3 >= 1) {
    bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
  }
  *((_DWORD *)this + 6) = 0;
  unsigned __int32 v4 = (void **)*((void *)this + 4);
  if (v4)
  {
    IR::FFTSubFilterData::reset(v4);
  }
}

uint64_t IR::FFTFilterKernel::calculateFIRActiveTaps(uint64_t this, const float *a2)
{
  uint64_t v2 = this;
  LODWORD(this) = a2 + 1;
  uint64_t v3 = v2 - 4;
  for (uint64_t i = 4 * a2; i; i -= 4)
  {
    float v5 = *(float *)(v3 + i);
    this = (this - 1);
    if (v5 != 0.0) {
      return this;
    }
  }
  return 0;
}

unsigned int *IR::FFTFilterKernel::initializeAndStoreCoeffs(IR::FFTFilterKernel *this, const float *a2, unsigned int a3, unsigned int a4, int a5, MultiRadixRealFFT *a6)
{
  IR::FFTFilterKernel::initialize(this, a3, a4, a5);

  return IR::FFTFilterKernel::storeCoeffs(this, a2, a3, a6, 0, 0, 1.0);
}

unsigned int *IR::FFTFilterKernel::initializeAndStoreCoeffs(IR::FFTFilterKernel *a1, const float *a2, unsigned int a3, unsigned int a4, int a5, MultiRadixRealFFT *a6, uint64_t a7, unsigned int a8, float a9)
{
  IR::FFTFilterKernel::initialize(a1, a3, a4, a5);

  return IR::FFTFilterKernel::storeCoeffs(a1, a2, a3, a6, a7, a8, a9);
}

unsigned int *IR::FFTFilterKernel::initializeAndStoreCoeffs(IR::FFTFilterKernel *a1, const float *a2, unsigned int a3, unsigned int a4, int a5, MultiRadixRealFFT *a6, uint64_t a7, unsigned int a8)
{
  IR::FFTFilterKernel::initialize(a1, a3, a4, a5);

  return IR::FFTFilterKernel::storeCoeffs(a1, a2, a3, a6, a7, a8, 1.0);
}

uint64_t IR::FFTFilterKernel::accumulate(IR::FFTFilterKernel *this, const IR::FFTFilterKernel *a2, float a3)
{
  float __B = a3;
  uint64_t v5 = (*((void *)this + 1) - *(void *)this) >> 2;
  unsigned int v6 = *((_DWORD *)a2 + 6);
  if (v6 >= v5) {
    vDSP_Length v7 = v5;
  }
  else {
    vDSP_Length v7 = v6;
  }
  if (v7) {
    vDSP_vsma(*(const float **)a2, 1, &__B, *(const float **)this, 1, *(float **)this, 1, v7);
  }
  uint64_t result = *((void *)this + 4);
  if (result)
  {
    uint64_t v9 = *((void *)a2 + 4);
    if (v9) {
      uint64_t result = IR::FFTSubFilterData::accumulate(result, v9, __B);
    }
  }
  unsigned int v10 = *((_DWORD *)this + 6);
  if (v10 <= v7) {
    unsigned int v10 = v7;
  }
  *((_DWORD *)this + 6) = v10;
  return result;
}

IR::FFTSubFilterData *IR::FFTFilterKernel::overwrite(IR::FFTFilterKernel *this, const IR::FFTFilterKernel *a2, float a3)
{
  float __B = a3;
  if ((uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 2 >= (unint64_t)((uint64_t)(*((void *)this + 1)
                                                                                         - *(void *)this) >> 2))
    LODWORD(v5) = (uint64_t)(*((void *)this + 1) - *(void *)this) >> 2;
  else {
    uint64_t v5 = (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 2;
  }
  if (v5) {
    vDSP_vsmul(*(const float **)a2, 1, &__B, *(float **)this, 1, v5);
  }
  uint64_t result = (IR::FFTSubFilterData *)*((void *)this + 4);
  if (result)
  {
    vDSP_Length v7 = (const IR::FFTSubFilterData *)*((void *)a2 + 4);
    if (v7) {
      return (IR::FFTSubFilterData *)IR::FFTSubFilterData::overwrite(result, v7, __B);
    }
  }
  return result;
}

IR::FFTSubFilterData *IR::FFTFilterKernel::scale(IR::FFTFilterKernel *this, float a2)
{
  float __B = a2;
  uint64_t v3 = *(float **)this;
  uint64_t v5 = *((void *)this + 1) - (void)v3;
  if (v5) {
    vDSP_vsmul(v3, 1, &__B, v3, 1, v5 >> 2);
  }
  uint64_t result = (IR::FFTSubFilterData *)*((void *)this + 4);
  if (result) {
    return (IR::FFTSubFilterData *)IR::FFTSubFilterData::scale(result, __B);
  }
  return result;
}

uint64_t IR::FFTFilterKernel::getMaxFilterLength(IR::FFTFilterKernel *this)
{
  uint64_t v1 = (_DWORD *)*((void *)this + 4);
  if (v1) {
    LODWORD(v1) = v1[1] * *v1;
  }
  return v1 + ((*((void *)this + 1) - *(void *)this) >> 2);
}

uint64_t IR::FFTFilterKernel::getActiveFilterLength(IR::FFTFilterKernel *this)
{
  uint64_t v1 = (_DWORD *)*((void *)this + 4);
  if (v1) {
    LODWORD(v1) = v1[2] * *v1;
  }
  return v1 + ((*((void *)this + 1) - *(void *)this) >> 2);
}

uint64_t IR::FFTFilterKernel::getFFTSubFilters(IR::FFTFilterKernel *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (!v1) {
    return 0;
  }
  if (*(void *)(v1 + 40) == *(void *)(v1 + 48)) {
    return 0;
  }
  return *(void *)(v1 + 40);
}

uint64_t IR::FFTFilterKernel::getComplexMultiplicationLengths(IR::FFTFilterKernel *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (!v1) {
    return 0;
  }
  if (*(void *)(v1 + 64) == *(void *)(v1 + 72)) {
    return 0;
  }
  return *(void *)(v1 + 64);
}

uint64_t IR::FFTFilterKernel::getNumActiveFFTSubFilters(IR::FFTFilterKernel *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    return *(unsigned int *)(v1 + 8);
  }
  else {
    return 0;
  }
}

void std::default_delete<IR::FFTSubFilterData>::operator()[abi:ne180100](uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[8];
    if (v3)
    {
      a2[9] = v3;
      operator delete(v3);
    }
    unsigned __int32 v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    uint64_t v5 = (void *)a2[2];
    if (v5)
    {
      a2[3] = v5;
      operator delete(v5);
    }
    JUMPOUT(0x21D48F780);
  }
}

void OUTLINED_FUNCTION_0_2(void *__p@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 8) = __p;
  operator delete(__p);
}

void IR::ComplexDataCircBuffer::Implementation::cleanup(IR::ComplexDataCircBuffer::Implementation *this)
{
  *((void *)this + 4) = *((void *)this + 3);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this);
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 9);
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 13) = *((void *)this + 12);
  *((void *)this + 16) = *((void *)this + 15);
  *((void *)this + 8) = 0;
  if (v2) {
    std::default_delete<MultiRadixRealFFT>::operator()[abi:ne180100]((uint64_t)this + 64, v2);
  }
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((unsigned char *)this + 144) = 0;
}

uint64_t IR::ComplexDataCircBuffer::Implementation::initialize(IR::ComplexDataCircBuffer::Implementation *this, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  *((unsigned char *)this + 144) = 0;
  uint64_t result = 4294956418;
  if (a2)
  {
    unsigned int v7 = a3;
    if (a3)
    {
      if (a4)
      {
        int v9 = a5;
        if (a5)
        {
          if (*((void *)this + 3) != *((void *)this + 4)
            && *((_DWORD *)this + 13) == a4
            && 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 3) == a2)
          {
            unint64_t v11 = a2;
            int v29 = 0;
            std::vector<float>::vector(&__p, 2 * a3 * a2 * a4, &v29);
            uint64_t v12 = 0;
            unsigned int v13 = 0;
            uint64_t v14 = *(void *)this;
            unsigned int v27 = v7;
            if (((*(void *)(*(void *)this + 8) - **(void **)this) >> 4) < v7) {
              unsigned int v7 = (*(void *)(*(void *)this + 8) - **(void **)this) >> 4;
            }
            do
            {
              if (v7)
              {
                unsigned int v15 = *((_DWORD *)this + 12);
                unsigned int v16 = v7;
                do
                {
                  memcpy((char *)__p + 4 * v13, *(const void **)(*(void *)(v14 + 24 * v12) + 16 * v15), 4 * a4);
                  unsigned int v17 = v13 + a4;
                  memcpy((char *)__p + 4 * v17, *(const void **)(*(void *)(*(void *)this + 24 * v12) + 16 * v15 + 8), 4 * a4);
                  unsigned int v13 = v17 + a4;
                  uint64_t v14 = *(void *)this;
                  if (v15 + 1 < (unint64_t)((uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 4)) {
                    ++v15;
                  }
                  else {
                    unsigned int v15 = 0;
                  }
                  --v16;
                }
                while (v16);
              }
              ++v12;
            }
            while (v12 != v11);
            std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>((char *)this + 24, (char *)__p, (uint64_t)v31, (v31 - (unsigned char *)__p) >> 2);
            unsigned int v7 = v27;
            int v9 = a5;
            if (__p)
            {
              uint64_t v31 = __p;
              operator delete(__p);
            }
          }
          else
          {
            LODWORD(__p) = 0;
            std::vector<float>::assign((char **)this + 3, 2 * a3 * a2 * a4, &__p);
            unint64_t v11 = a2;
          }
          std::vector<std::vector<DSPSplitComplex>>::resize((uint64_t *)this, v11);
          std::vector<char> __p = 0;
          std::vector<float *>::assign((char **)this + 15, v11, &__p);
          uint64_t v18 = 0;
          unsigned int v19 = 0;
          do
          {
            std::vector<DSPSplitComplex>::resize(*(void *)this + 24 * v18, v7);
            uint64_t v20 = *((void *)this + 3);
            unsigned int v21 = (void *)(*(void *)(*(void *)this + 24 * v18) + 8);
            uint64_t v22 = v7;
            do
            {
              *(v21 - 1) = v20 + 4 * v19;
              *unsigned int v21 = v20 + 4 * (v19 + a4);
              v21 += 2;
              v19 += a4 + a4;
              --v22;
            }
            while (v22);
            ++v18;
          }
          while (v18 != v11);
          *((_DWORD *)this + 13) = a4;
          *((_DWORD *)this + 14) = 0;
          *((_DWORD *)this + 12) = 0;
          std::vector<std::vector<float>>::resize((uint64_t *)this + 9, v11);
          uint64_t v23 = 0;
          unint64_t v24 = 2 * a4;
          do
          {
            uint64_t v25 = *((void *)this + 9) + v23;
            LODWORD(__p) = 0;
            std::vector<float>::resize(v25, v24, &__p);
            v23 += 24;
            --v11;
          }
          while (v11);
          std::vector<float>::resize((uint64_t)this + 96, (v24 + v9));
          vDSP_Length v26 = (MultiRadixRealFFT *)*((void *)this + 8);
          if (!v26) {
            operator new();
          }
          if (MultiRadixRealFFT::Size(v26) != v24)
          {
            if (MultiRadixRealFFT::Initialize(*((MultiRadixRealFFT **)this + 8), v24)) {
              IR::ComplexDataCircBuffer::Implementation::initialize();
            }
          }
          uint64_t result = 0;
          *((unsigned char *)this + 144) = 1;
        }
      }
    }
  }
  return result;
}

void sub_21B528C44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void IR::ComplexDataCircBuffer::Implementation::inverseFFTOverlapAdd(IR::ComplexDataCircBuffer::Implementation *this, unsigned int a2)
{
  uint64_t v2 = *(void **)this;
  uint64_t v3 = (void *)*((void *)this + 1);
  if (*(void **)this != v3)
  {
    unsigned int v4 = a2;
    uint64_t v6 = 0;
    unsigned int v7 = 1;
    while (*(void *)(*((void *)this + 15) + 8 * v6))
    {
      uint64_t v6 = v7;
      BOOL v8 = 0xAAAAAAAAAAAAAAABLL * (v3 - v2) > v7++;
      if (!v8)
      {
        if (v2[1] != *v2 && a2 != 0)
        {
          unsigned int v10 = 0;
          unsigned int v11 = *((_DWORD *)this + 14);
          uint64_t v12 = (void *)*((void *)this + 1);
          do
          {
            unsigned int v13 = *((_DWORD *)this + 13);
            if (v13 - v11 >= v4) {
              vDSP_Length v14 = v4;
            }
            else {
              vDSP_Length v14 = v13 - v11;
            }
            if (v12 == v2)
            {
              uint64_t v12 = v2;
            }
            else
            {
              uint64_t v15 = 0;
              unsigned int v16 = 1;
              do
              {
                unsigned int v17 = (float *)(*(void *)(*((void *)this + 15) + 8 * v15) + 4 * v10);
                vDSP_vadd((const float *)(*(void *)(*((void *)this + 9) + 24 * v15) + 4 * *((unsigned int *)this + 14)), 1, v17, 1, v17, 1, v14);
                uint64_t v15 = v16;
                uint64_t v2 = *(void **)this;
                uint64_t v3 = (void *)*((void *)this + 1);
                BOOL v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *(void *)this) >> 3) > v16++;
              }
              while (v8);
              unsigned int v13 = *((_DWORD *)this + 13);
              unsigned int v11 = *((_DWORD *)this + 14);
              uint64_t v12 = (void *)*((void *)this + 1);
            }
            v11 += v14;
            *((_DWORD *)this + 14) = v11;
            if (v11 >= v13)
            {
              if (v3 == v2)
              {
                uint64_t v3 = v2;
              }
              else
              {
                uint64_t v18 = 0;
                unsigned int v19 = 1;
                do
                {
                  uint64_t v20 = 3 * v18;
                  *(_OWORD *)uint64_t v23 = *(_OWORD *)(v2[3 * v18] + 16 * *((unsigned int *)this + 12));
                  MultiRadixRealFFT::RealInPlaceTransform(*((MultiRadixRealFFT **)this + 8), (DSPSplitComplex *)v23, -1, 1.0);
                  vDSP_ztoc((const DSPSplitComplex *)v23, 1, *((DSPComplex **)this + 12), 2, *((unsigned int *)this + 13));
                  unsigned int v21 = *(float **)(*((void *)this + 9) + 8 * v20);
                  vDSP_vadd(*((const float **)this + 12), 1, &v21[*((unsigned int *)this + 13)], 1, v21, 1, *((unsigned int *)this + 13));
                  memmove((void *)(*(void *)(*((void *)this + 9) + 8 * v20) + 4 * *((unsigned int *)this + 13)), (const void *)(*((void *)this + 12) + 4 * *((unsigned int *)this + 13)), 4 * *((unsigned int *)this + 13));
                  bzero(v23[0], 4 * *((unsigned int *)this + 13));
                  bzero(v23[1], 4 * *((unsigned int *)this + 13));
                  uint64_t v18 = v19;
                  uint64_t v2 = *(void **)this;
                  uint64_t v3 = (void *)*((void *)this + 1);
                  BOOL v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *(void *)this) >> 3) > v19++;
                }
                while (v8);
              }
              uint64_t v22 = (*((_DWORD *)this + 12) + 1);
              *((_DWORD *)this + 12) = v22;
              if (v22 == (uint64_t)(v2[1] - *v2) >> 4) {
                *((_DWORD *)this + 12) = 0;
              }
              unsigned int v11 = 0;
              *((_DWORD *)this + 14) = 0;
              uint64_t v12 = v3;
            }
            v10 += v14;
            v4 -= v14;
          }
          while (v4);
        }
        return;
      }
    }
  }
}

void *IR::ComplexDataCircBuffer::Implementation::getFFTBufferVec(IR::ComplexDataCircBuffer::Implementation *this, unsigned int a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 3) > a2) {
    return (void *)(*(void *)this + 24 * a2);
  }
  {
    return &IR::ComplexDataCircBuffer::Implementation::getFFTBufferVec::locEmpty;
  }
  __cxa_atexit((void (*)(void *))std::vector<DSPSplitComplex>::~vector[abi:ne180100], &IR::ComplexDataCircBuffer::Implementation::getFFTBufferVec::locEmpty, &dword_21B4DD000);
  return &IR::ComplexDataCircBuffer::Implementation::getFFTBufferVec::locEmpty;
}

uint64_t std::vector<DSPSplitComplex>::~vector[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void *IR::ComplexDataCircBuffer::ComplexDataCircBuffer(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  return result;
}

void IR::ComplexDataCircBuffer::ComplexDataCircBuffer(IR::ComplexDataCircBuffer *this)
{
}

{
  operator new();
}

void IR::ComplexDataCircBuffer::~ComplexDataCircBuffer(IR::ComplexDataCircBuffer *this)
{
  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    std::default_delete<IR::ComplexDataCircBuffer::Implementation>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    std::default_delete<IR::ComplexDataCircBuffer::Implementation>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t IR::ComplexDataCircBuffer::initialize(IR::ComplexDataCircBuffer::Implementation **this, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v5 = *this;
  if (v5) {
    return IR::ComplexDataCircBuffer::Implementation::initialize(v5, a2, a3, a4, a5);
  }
  else {
    return 4294956429;
  }
}

void IR::ComplexDataCircBuffer::cleanup(IR::ComplexDataCircBuffer::Implementation **this)
{
  uint64_t v1 = *this;
  if (v1) {
    IR::ComplexDataCircBuffer::Implementation::cleanup(v1);
  }
}

void IR::ComplexDataCircBuffer::inverseFFTOverlapAdd(IR::ComplexDataCircBuffer::Implementation **this, unsigned int a2)
{
  uint64_t v2 = *this;
  if (v2) {
    IR::ComplexDataCircBuffer::Implementation::inverseFFTOverlapAdd(v2, a2);
  }
}

uint64_t IR::ComplexDataCircBuffer::getNumOutputChannels(IR::ComplexDataCircBuffer *this)
{
  if (*(void *)this) {
    return -1431655765 * ((*(void *)(*(void *)this + 8) - **(void **)this) >> 3);
  }
  else {
    return 0;
  }
}

uint64_t IR::ComplexDataCircBuffer::getNumFFTBuffers(IR::ComplexDataCircBuffer *this)
{
  uint64_t v1 = *(void **)this;
  if (!*(void *)this || *v1 == v1[1]) {
    return 0;
  }
  else {
    return (*(void *)(*v1 + 8) - *(void *)*v1) >> 4;
  }
}

uint64_t IR::ComplexDataCircBuffer::getFFTPartitionLength(IR::ComplexDataCircBuffer *this)
{
  if (*(void *)this) {
    return *(unsigned int *)(*(void *)this + 52);
  }
  else {
    return 0;
  }
}

uint64_t IR::ComplexDataCircBuffer::getCircularIndex(IR::ComplexDataCircBuffer *this)
{
  if (*(void *)this) {
    return *(unsigned int *)(*(void *)this + 48);
  }
  else {
    return 0;
  }
}

uint64_t IR::ComplexDataCircBuffer::getFFTProcPos(IR::ComplexDataCircBuffer *this)
{
  if (*(void *)this) {
    return *(unsigned int *)(*(void *)this + 56);
  }
  else {
    return 0;
  }
}

void *IR::ComplexDataCircBuffer::getFFTBufferVec(IR::ComplexDataCircBuffer::Implementation **this, unsigned int a2)
{
  uint64_t v2 = *this;
  if (v2)
  {
    return IR::ComplexDataCircBuffer::Implementation::getFFTBufferVec(v2, a2);
  }
  else
  {
    {
      __cxa_atexit((void (*)(void *))std::vector<DSPSplitComplex>::~vector[abi:ne180100], &IR::ComplexDataCircBuffer::getFFTBufferVec::locEmpty, &dword_21B4DD000);
    }
    return &IR::ComplexDataCircBuffer::getFFTBufferVec::locEmpty;
  }
}

void *IR::ComplexDataCircBuffer::getSampleDataPtrs(IR::ComplexDataCircBuffer *this)
{
  if (*(void *)this) {
    return (void *)(*(void *)this + 120);
  }
  {
    return &IR::ComplexDataCircBuffer::getSampleDataPtrs(void)::locEmpty;
  }
  __cxa_atexit((void (*)(void *))std::vector<float *>::~vector[abi:ne180100], &IR::ComplexDataCircBuffer::getSampleDataPtrs(void)::locEmpty, &dword_21B4DD000);
  return &IR::ComplexDataCircBuffer::getSampleDataPtrs(void)::locEmpty;
}

uint64_t std::vector<float *>::~vector[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t IR::ComplexDataCircBuffer::isInitialized(IR::ComplexDataCircBuffer *this)
{
  return *(unsigned __int8 *)(*(void *)this + 144);
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unsigned int v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<IR::IRCoordinateType>::__vallocate[abi:ne180100](v7, v11);
    unsigned int v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    int v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      unsigned int v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  vDSP_Length v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unsigned int v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, 4 * v15);
    int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    unsigned int v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void std::default_delete<IR::ComplexDataCircBuffer::Implementation>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void **)(a2 + 120);
    if (v3)
    {
      *(void *)(a2 + 128) = v3;
      operator delete(v3);
    }
    unsigned int v4 = *(void **)(a2 + 96);
    if (v4)
    {
      *(void *)(a2 + 104) = v4;
      operator delete(v4);
    }
    unsigned int v7 = (void **)(a2 + 72);
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v7);
    uint64_t v5 = *(void *)(a2 + 64);
    *(void *)(a2 + 64) = 0;
    if (v5) {
      std::default_delete<MultiRadixRealFFT>::operator()[abi:ne180100](a2 + 64, v5);
    }
    uint64_t v6 = *(void **)(a2 + 24);
    if (v6)
    {
      *(void *)(a2 + 32) = v6;
      operator delete(v6);
    }
    unsigned int v7 = (void **)a2;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v7);
    MEMORY[0x21D48F780](a2, 0x10A0C40DBD9303ALL);
  }
}

double IR::MPResampler<float>::MPResampler(uint64_t a1, int a2, float a3, float a4)
{
  IR::DataResampler<float>::DataResampler(a1, a2, a3, a4);
  *(void *)uint64_t v4 = &unk_26CB57D90;
  *(void *)(v4 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
  *(void *)(v4 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 12std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  *(_OWORD *)(v4 + 136) = 0u;
  *(_OWORD *)(v4 + 152) = 0u;
  *(_OWORD *)(v4 + 168) = 0u;
  *(_OWORD *)(v4 + 184) = 0u;
  *(_OWORD *)(v4 + 20std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  return result;
}

void *IR::MPResampler<float>::~MPResampler(void *a1)
{
  *a1 = &unk_26CB57D90;
  IR::MPResampler<float>::CleanUp((uint64_t)a1);
  uint64_t v2 = (void *)a1[24];
  if (v2)
  {
    a1[25] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[21];
  if (v3)
  {
    a1[22] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[18];
  if (v4)
  {
    a1[19] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[15];
  if (v5)
  {
    a1[16] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[12];
  if (v6)
  {
    a1[13] = v6;
    operator delete(v6);
  }
  unsigned int v7 = (void *)a1[9];
  if (v7)
  {
    a1[10] = v7;
    operator delete(v7);
  }

  return IR::DataResampler<float>::~DataResampler(a1);
}

void IR::MPResampler<float>::~MPResampler(void *a1)
{
  IR::MPResampler<float>::~MPResampler(a1);

  JUMPOUT(0x21D48F780);
}

void IR::MPResampler<float>::Initialize(uint64_t a1, int a2, int a3, int a4)
{
  *(unsigned char *)(a1 + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
  if ((a2 - 4) <= 0xFFFFFFFC)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid Quality index");
    goto LABEL_17;
  }
  if ((a3 - 3) <= 0xFFFFFFFD)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid ExtrapolationMethod");
    goto LABEL_17;
  }
  if (a4 != 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid InterpolationMethod");
LABEL_17:
  }
  *(_DWORD *)(a1 + 224) = a3;
  *(_DWORD *)(a1 + 228) = 1;
  if (a2 == 2) {
    unsigned int v5 = 128;
  }
  else {
    unsigned int v5 = 512;
  }
  if (a2 == 1) {
    unsigned int v5 = 32;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = vcvtps_u32_f32(fmaxf((float)(*(float *)(a1 + 16) / *(float *)(a1 + 12)) * (float)v6, 1.0));
  if (v6 <= v7) {
    unsigned int v6 = v7;
  }
  unsigned int v8 = 1 << -(char)__clz(v6 - 1);
  if (v5 <= v8) {
    unsigned int v5 = v8;
  }
  unint64_t v9 = (v5 >> 1) + 1;
  *(_DWORD *)(a1 + 216) = v5;
  *(_DWORD *)(a1 + 22std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v9;
  std::vector<float>::resize(a1 + 168, v9);
  std::vector<float>::resize(a1 + 192, *(unsigned int *)(a1 + 220));
  float v22 = 0.0;
  std::vector<float>::assign((char **)(a1 + 72), *(unsigned int *)(a1 + 220), &v22);
  std::vector<float>::assign((char **)(a1 + 96), *(unsigned int *)(a1 + 220), &v22);
  std::vector<float>::assign((char **)(a1 + 120), *(unsigned int *)(a1 + 216), &v22);
  std::vector<float>::assign((char **)(a1 + 144), *(unsigned int *)(a1 + 216), &v22);
  uint64_t v10 = *(void *)(a1 + 144);
  *(_DWORD *)uint64_t v10 = 1065353216;
  vDSP_Length v11 = ((*(_DWORD *)(a1 + 216) >> 1) - 1);
  float __A = 2.0;
  vDSP_vfill(&__A, (float *)(v10 + 4), 1, v11);
  uint64_t v12 = *(unsigned int *)(a1 + 216);
  *(_DWORD *)(*(void *)(a1 + 144) + ((2 * v12) & 0x1FFFFFFFCLL)) = 1065353216;
  uint64_t v13 = *(void *)(a1 + 96);
  *(void *)(a1 + 56) = *(void *)(a1 + 72);
  *(void *)(a1 + 64) = v13;
  float v14 = *(float *)(a1 + 12) / (float)v12;
  float v15 = *(float *)(a1 + 16) / (float)v12;
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 40));
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 48));
  Setup = vDSP_DFT_zrop_CreateSetup(0, *(unsigned int *)(a1 + 216), vDSP_DFT_FORWARD);
  *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = Setup;
  *(void *)(a1 + 48) = vDSP_DFT_zrop_CreateSetup(Setup, *(unsigned int *)(a1 + 216), vDSP_DFT_INVERSE);
  size_t v17 = *(float **)(a1 + 168);
  vDSP_Length v18 = (uint64_t)(*(void *)(a1 + 176) - (void)v17) >> 2;
  float __B = v14;
  float __A = v22;
  vDSP_vramp(&__A, &__B, v17, 1, v18);
  unsigned int v19 = *(float **)(a1 + 192);
  vDSP_Length v20 = (uint64_t)(*(void *)(a1 + 200) - (void)v19) >> 2;
  float __B = v15;
  float __A = v22;
  vDSP_vramp(&__A, &__B, v19, 1, v20);
  *(unsigned char *)(a1 + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 1;
}

void sub_21B52989C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned int IR::MPResampler<float>::Initialize(uint64_t a1, const __CFDictionary **a2)
{
  CFDictionaryRef v3 = *a2;
  if (*a2)
  {
    unsigned int v15 = 2;
    int v5 = applesauce::CF::at_or<IR::MPResampler<float>::Quality,__CFString const*&>(v3, (const void **)&IR::kIRDataResamplerConfigQualityKey, &v15);
    CFDictionaryRef v6 = *a2;
    if (!*a2)
    {
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
    unsigned int v14 = 1;
    int v7 = applesauce::CF::at_or<IR::MPResampler<float>::ExtrapolationMethod,__CFString const*&>(v6, (const void **)&IR::kMPResamplerConfigExtrapMethodKey, &v14);
    CFDictionaryRef v8 = *a2;
    if (!*a2)
    {
      uint64_t v12 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v12);
    }
    unsigned int v13 = 1;
    int v9 = applesauce::CF::at_or<IR::MPResampler<float>::InterpolationMethod,__CFString const*&>(v8, (const void **)&IR::kMPResamplerConfigInterpMethodKey, &v13);
  }
  else
  {
    int v5 = 2;
    int v7 = 1;
    int v9 = 1;
  }
  IR::MPResampler<float>::Initialize(a1, v5, v7, v9);
  return vcvtps_u32_f32(fmaxf((float)(*(float *)(a1 + 16) / *(float *)(a1 + 12)) * (float)*(unsigned int *)(a1 + 8), 1.0));
}

void sub_21B5299E8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void IR::MPResampler<float>::CleanUp(uint64_t a1)
{
  *(unsigned char *)(a1 + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 40));
  vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)(a1 + 48));
  *(void *)(a1 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = *(void *)(a1 + 72);
  *(void *)(a1 + 104) = *(void *)(a1 + 96);
  *(void *)(a1 + 128) = *(void *)(a1 + 120);
  *(void *)(a1 + 152) = *(void *)(a1 + 144);
  *(void *)(a1 + 176) = *(void *)(a1 + 168);
  *(void *)(a1 + 20std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = *(void *)(a1 + 192);
}

uint64_t IR::MPResampler<float>::Process(uint64_t a1, const DSPComplex *a2, unsigned int a3, float *a4, unsigned int a5)
{
  if (!*(unsigned char *)(a1 + 20)) {
    return 103;
  }
  if (*(_DWORD *)(a1 + 8) < a3
    || vcvtps_u32_f32(fmaxf((float)(*(float *)(a1 + 16) / *(float *)(a1 + 12)) * (float)a3, 1.0)) != a5)
  {
    return 104;
  }
  uint64_t v10 = *(DSPComplex **)(a1 + 120);
  vDSP_vclr(*(float **)(a1 + 72), 1, (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 2);
  vDSP_vclr(*(float **)(a1 + 96), 1, (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 2);
  vDSP_ctoz(a2, 2, (const DSPSplitComplex *)(a1 + 56), 1, a3 >> 1);
  vDSP_Length v11 = *(float **)(a1 + 72);
  if (a3) {
    v11[a3 >> 1] = *((float *)a2 + a3 - 1);
  }
  float v12 = 1.0 / (float)*(unsigned int *)(a1 + 216);
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 40), v11, *(const float **)(a1 + 96), v11, *(float **)(a1 + 96));
  unsigned int v13 = *(_DWORD **)(a1 + 96);
  vDSP_Length v14 = *(unsigned int *)(a1 + 220);
  unsigned int v15 = v14 - 1;
  *(_DWORD *)(*(void *)(a1 + 72) + 4 * v15) = *v13;
  *unsigned int v13 = 0;
  v13[v15] = 0;
  vDSP_zvmags((const DSPSplitComplex *)(a1 + 56), 1, *(float **)(a1 + 120), 1, v14);
  unsigned int v16 = *(float **)(a1 + 120);
  float __B = *(float *)(a1 + 220);
  vvsqrtf(v16, v16, (const int *)&__B);
  size_t v17 = *(float **)(a1 + 120);
  vDSP_Length v18 = *(unsigned int *)(a1 + 220);
  float __B = 0.5;
  vDSP_vsmul(v17, 1, &__B, v17, 1, v18);
  IR::MPResampler<float>::Interpolate(a1, a1 + 120, (float **)(a1 + 72));
  unsigned int v19 = *(float **)(a1 + 72);
  float __B = *(float *)(a1 + 220);
  vvlogf(v19, v19, (const int *)&__B);
  vDSP_vclr(*(float **)(a1 + 96), 1, (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 2);
  vDSP_Length v20 = *(float **)(a1 + 72);
  unsigned int v21 = *(float **)(a1 + 96);
  *unsigned int v21 = v20[*(_DWORD *)(a1 + 220) - 1];
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 48), v20, v21, v20, v21);
  vDSP_ztoc((const DSPSplitComplex *)(a1 + 56), 1, v10, 2, (unint64_t)*(unsigned int *)(a1 + 216) >> 1);
  float v22 = *(float **)(a1 + 120);
  vDSP_Length v23 = (uint64_t)(*(void *)(a1 + 128) - (void)v22) >> 2;
  float __B = v12 * 0.5;
  vDSP_vsmul(v22, 1, &__B, v22, 1, v23);
  unint64_t v24 = *(const float **)(a1 + 120);
  uint64_t v25 = *(void *)(a1 + 128) - (void)v24;
  vDSP_Length v26 = *(const float **)(a1 + 144);
  if ((uint64_t)(*(void *)(a1 + 152) - (void)v26) >> 2 >= (unint64_t)(v25 >> 2)) {
    vDSP_Length v27 = v25 >> 2;
  }
  else {
    vDSP_Length v27 = (uint64_t)(*(void *)(a1 + 152) - (void)v26) >> 2;
  }
  vDSP_vmul(v24, 1, v26, 1, *(float **)(a1 + 120), 1, v27);
  vDSP_ctoz(v10, 2, (const DSPSplitComplex *)(a1 + 56), 1, (unint64_t)*(unsigned int *)(a1 + 216) >> 1);
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 40), *(const float **)(a1 + 72), *(const float **)(a1 + 96), *(float **)(a1 + 72), *(float **)(a1 + 96));
  uint64_t v28 = *(const float **)(a1 + 96);
  float v29 = *(float *)(a1 + 220);
  int v30 = LODWORD(v29) - 1;
  uint64_t v31 = *(const float **)(a1 + 72);
  v31[v30] = *v28;
  *uint64_t v28 = 0.0;
  v28[v30] = 0.0;
  uint64_t v32 = *(float **)(a1 + 120);
  float __B = v29;
  vvexpf(v32, v31, (const int *)&__B);
  int v33 = *(float **)(a1 + 96);
  uint64_t v34 = *(float **)(a1 + 72);
  float __B = *(float *)(a1 + 220);
  vvsincosf(v33, v34, v33, (const int *)&__B);
  vDSP_vmul(*(const float **)(a1 + 120), 1, *(const float **)(a1 + 72), 1, *(float **)(a1 + 72), 1, *(unsigned int *)(a1 + 220));
  vDSP_vmul(*(const float **)(a1 + 120), 1, *(const float **)(a1 + 96), 1, *(float **)(a1 + 96), 1, *(unsigned int *)(a1 + 220));
  uint64_t v35 = *(float **)(a1 + 72);
  uint64_t v36 = *(float **)(a1 + 96);
  *uint64_t v36 = v35[*(_DWORD *)(a1 + 220) - 1];
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(a1 + 48), v35, v36, v35, v36);
  vDSP_ztoc((const DSPSplitComplex *)(a1 + 56), 1, v10, 2, (unint64_t)*(unsigned int *)(a1 + 216) >> 1);
  uint64_t v37 = *(const float **)(a1 + 120);
  float __B = v12;
  vDSP_vsmul(v37, 1, &__B, a4, 1, a5);
  return 0;
}

void IR::MPResampler<float>::Interpolate(uint64_t a1, uint64_t a2, float **a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 220);
  if (v3 > (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2) {
    IR::MPResampler<float>::Interpolate();
  }
  if (v3 > a3[1] - *a3) {
    IR::MPResampler<float>::Interpolate();
  }
  **a3 = fmaxf(**(float **)a2, 1.0e-10);
  if (v3 >= 2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(a1 + 192);
    uint64_t v6 = (v3 - 1);
    uint64_t v7 = *(void *)(a1 + 168);
    CFDictionaryRef v8 = *(float **)a2;
    int v9 = *a3;
    uint64_t v10 = (uint64_t)(*a3 + 1);
    uint64_t v11 = -4;
    float v12 = *(float *)(a1 + 16) / *(float *)(a1 + 12);
    while (1)
    {
      float v13 = *(float *)(v5 + 4 + 4 * v4);
      if (v13 > *(float *)(v7 + 4 * v6)) {
        break;
      }
      unsigned int v14 = vcvtps_u32_f32(v12 * (float)(v4 + 1));
      unsigned int v15 = v14 - 1;
      *(float *)(v10 + 4 * v4) = fmaxf(v8[v15]+ (float)((float)((float)(v13 - *(float *)(v7 + 4 * v15)) * (float)(v8[v14] - v8[v15]))/ (float)(*(float *)(v7 + 4 * v14) - *(float *)(v7 + 4 * v15))), 1.0e-10);
      v11 -= 4;
      if (v3 - 1 == ++v4) {
        return;
      }
    }
    if (*(_DWORD *)(a1 + 224) == 1)
    {
      float v16 = fmaxf(*(float *)(*(void *)a2 + 4 * v6), 1.0e-10);
      size_t v17 = &(*a3)[v11 / 0xFFFFFFFFFFFFFFFCLL];
      float __A = v16;
      vDSP_vfill(&__A, v17, 1, (v6 - v4));
    }
    else
    {
      float v18 = v8[v6];
      v9[v4 + 1] = fmaxf(v18, 1.0e-10);
      unint64_t v19 = (*(void *)(a1 + 200) - v5) >> 2;
      uint64_t v20 = v4 + 2;
      if (v19 > v4 + 2)
      {
        unsigned int v21 = 0;
        unsigned int v22 = v4 + 3;
        float v23 = (float)(3.1416 / (float)((float)(v3 - v4 - 2) + -1.0)) * 0.5;
        do
        {
          v9[v20] = fmaxf(v18 * cosf(v23 * (float)v21), 1.0e-10);
          uint64_t v20 = v22;
          ++v21;
        }
        while (v19 > v22++);
      }
    }
  }
}

uint64_t IR::MPResampler<float>::GetRequiredNumberOfInputFrames(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = vcvtms_u32_f32(fmaxf((float)(*(float *)(a1 + 12) / *(float *)(a1 + 16)) * (float)a2, 1.0));
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= v2) {
    return v2;
  }
  else {
    return v3;
  }
}

void std::vector<double>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    CFDictionaryRef v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unsigned int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<IR::FFTFilterKernel>>>(v4, v13);
      CFDictionaryRef v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      unsigned int v14 = 0;
    }
    unsigned int v15 = &v14[8 * v11];
    float v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    size_t v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

unint64_t applesauce::CF::at_or<IR::MPResampler<float>::Quality,__CFString const*&>(const __CFDictionary *a1, const void **a2, unsigned int *a3)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (!v4) {
    return *a3;
  }
  unint64_t result = applesauce::CF::convert_as<IR::MPResampler<float>::Quality,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

unint64_t applesauce::CF::convert_as<IR::MPResampler<float>::Quality,0>(const __CFNumber *a1)
{
  if (a1 && (CFTypeID TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(a1)))
  {
    int valuePtr = 0;
    int Value = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
    unsigned int v4 = valuePtr & 0xFFFFFF00;
    int v5 = valuePtr;
    if (!Value)
    {
      unsigned int v4 = 0;
      int v5 = 0;
    }
    unint64_t v6 = (unint64_t)(Value != 0) << 32;
  }
  else
  {
    int v5 = 0;
    unint64_t v6 = 0;
    unsigned int v4 = 0;
  }
  return v6 | v4 | v5;
}

unint64_t applesauce::CF::at_or<IR::MPResampler<float>::ExtrapolationMethod,__CFString const*&>(const __CFDictionary *a1, const void **a2, unsigned int *a3)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (!v4) {
    return *a3;
  }
  unint64_t result = applesauce::CF::convert_as<IR::MPResampler<float>::ExtrapolationMethod,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

unint64_t applesauce::CF::convert_as<IR::MPResampler<float>::ExtrapolationMethod,0>(const __CFNumber *a1)
{
  if (a1 && (CFTypeID TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(a1)))
  {
    int valuePtr = 0;
    int Value = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
    unsigned int v4 = valuePtr & 0xFFFFFF00;
    int v5 = valuePtr;
    if (!Value)
    {
      unsigned int v4 = 0;
      int v5 = 0;
    }
    unint64_t v6 = (unint64_t)(Value != 0) << 32;
  }
  else
  {
    int v5 = 0;
    unint64_t v6 = 0;
    unsigned int v4 = 0;
  }
  return v6 | v4 | v5;
}

unint64_t applesauce::CF::at_or<IR::MPResampler<float>::InterpolationMethod,__CFString const*&>(const __CFDictionary *a1, const void **a2, unsigned int *a3)
{
  CFDictionaryRef v4 = applesauce::CF::details::at_key<__CFString const*&>(a1, a2);
  if (!v4) {
    return *a3;
  }
  unint64_t result = applesauce::CF::convert_as<IR::MPResampler<float>::InterpolationMethod,0>(v4);
  if ((result & 0xFF00000000) != 0) {
    return result;
  }
  else {
    return *a3;
  }
}

unint64_t applesauce::CF::convert_as<IR::MPResampler<float>::InterpolationMethod,0>(const __CFNumber *a1)
{
  if (a1 && (CFTypeID TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(a1)))
  {
    int valuePtr = 0;
    int Value = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
    unsigned int v4 = valuePtr & 0xFFFFFF00;
    int v5 = valuePtr;
    if (!Value)
    {
      unsigned int v4 = 0;
      int v5 = 0;
    }
    unint64_t v6 = (unint64_t)(Value != 0) << 32;
  }
  else
  {
    int v5 = 0;
    unint64_t v6 = 0;
    unsigned int v4 = 0;
  }
  return v6 | v4 | v5;
}

CFMutableStringRef PlatformUtilities::CopyHardwareModelShortName(PlatformUtilities *this)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  if (!Mutable) {
    return 0;
  }
  unsigned int v3 = Mutable;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)cStr = 0u;
  long long v13 = 0u;
  size_t v10 = 64;
  sysctlbyname("hw.model", cStr, &v10, 0, 0);
  CFStringAppendCString(v3, cStr, 0);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v1, 0, v3);
  CFRelease(v3);
  if (MutableCopy)
  {
    CFStringRef v5 = @"AP";
    if (CFStringHasSuffix(MutableCopy, @"AP")
      || (CFStringRef v5 = @"DEV", CFStringHasSuffix(MutableCopy, @"DEV"))
      || (CFStringRef v5 = @"ap", CFStringHasSuffix(MutableCopy, @"ap"))
      || (CFStringRef v5 = @"dev", CFStringHasSuffix(MutableCopy, @"dev")))
    {
      CFStringTrim(MutableCopy, v5);
    }
    *(void *)cStr = 0;
    *(void *)&cStr[8] = 1;
    uint64_t v6 = MGGetProductType();
    if (v6 == 952317141)
    {
      size_t v10 = (size_t)CFStringCreateWithCString(0, "u", 0x600u);
      char v11 = 1;
      CACFString::operator=((uint64_t)cStr, (uint64_t)&v10);
    }
    else
    {
      if (v6 != 2081274472 && v6 != 2468178735) {
        goto LABEL_16;
      }
      size_t v10 = (size_t)CFStringCreateWithCString(0, "m", 0x600u);
      char v11 = 1;
      CACFString::operator=((uint64_t)cStr, (uint64_t)&v10);
    }
    CACFString::~CACFString((CACFString *)&v10);
LABEL_16:
    CFStringRef v7 = *(const __CFString **)cStr;
    if (*(void *)cStr && CFStringHasSuffix(MutableCopy, *(CFStringRef *)cStr))
    {
      CFIndex Length = CFStringGetLength(MutableCopy);
      v17.length = CFStringGetLength(v7);
      v17.location = Length - v17.length;
      CFStringFindAndReplace(MutableCopy, v7, &stru_26CB57E20, v17, 1uLL);
    }
    CACFString::~CACFString((CACFString *)cStr);
  }
  return MutableCopy;
}

void sub_21B52A634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t PlatformUtilities_iOS::GetProductType(PlatformUtilities_iOS *this)
{
  if (PlatformUtilities_iOS::GetProductType(void)::sCompletedCheck == 1) {
    return PlatformUtilities_iOS::GetProductType(void)::sType;
  }
  PlatformUtilities_iOS::GetProductType(void)::sCompletedChecunint64_t k = 1;
  uint64_t v2 = MGGetProductType();
  if (v2 > 2159747552)
  {
    if (v2 <= 3196805750)
    {
      if (v2 > 2688879998)
      {
        if (v2 <= 2940697644)
        {
          if (v2 > 2781508712)
          {
            if (v2 <= 2797549162)
            {
              switch(v2)
              {
                case 2781508713:
                  uint64_t result = 6;
                  goto LABEL_481;
                case 2793418701:
                  uint64_t result = 19;
                  goto LABEL_481;
                case 2795618603:
                  uint64_t result = 42;
                  goto LABEL_481;
              }
              goto LABEL_480;
            }
            if (v2 > 2880863277)
            {
              if (v2 != 2880863278)
              {
                if (v2 == 2903084588)
                {
                  uint64_t result = 85;
                  goto LABEL_481;
                }
                goto LABEL_480;
              }
              goto LABEL_367;
            }
            if (v2 == 2797549163)
            {
              uint64_t result = 113;
              goto LABEL_481;
            }
            uint64_t v3 = 2823174122;
LABEL_289:
            if (v2 == v3)
            {
              uint64_t result = 109;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          if (v2 > 2722529671)
          {
            switch(v2)
            {
              case 2722529672:
                uint64_t result = 28;
                goto LABEL_481;
              case 2730762296:
                uint64_t result = 112;
                goto LABEL_481;
              case 2751865418:
                uint64_t result = 143;
                goto LABEL_481;
            }
            goto LABEL_480;
          }
          if (v2 == 2688879999)
          {
            uint64_t result = 39;
            goto LABEL_481;
          }
          if (v2 != 2692844695)
          {
            if (v2 == 2702125347)
            {
              uint64_t result = 3;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
LABEL_389:
          uint64_t result = 197;
          goto LABEL_481;
        }
        if (v2 <= 3101941569)
        {
          if (v2 <= 2959111091)
          {
            switch(v2)
            {
              case 2940697645:
                uint64_t result = 38;
                goto LABEL_481;
              case 2941181571:
                uint64_t result = 41;
                goto LABEL_481;
              case 2943112657:
                uint64_t result = 149;
                goto LABEL_481;
            }
            goto LABEL_480;
          }
          if (v2 > 3001488777)
          {
            if (v2 == 3001488778)
            {
              uint64_t result = 34;
              goto LABEL_481;
            }
            if (v2 != 3054476161) {
              goto LABEL_480;
            }
            goto LABEL_323;
          }
          if (v2 == 2959111092)
          {
            uint64_t result = 95;
            goto LABEL_481;
          }
          if (v2 == 2979575960)
          {
            uint64_t result = 155;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
        if (v2 <= 3133873108)
        {
          if (v2 != 3101941570)
          {
            if (v2 == 3104290450) {
              goto LABEL_344;
            }
            uint64_t v9 = 3128362815;
            goto LABEL_260;
          }
          goto LABEL_351;
        }
        if (v2 <= 3184375230)
        {
          if (v2 == 3133873109)
          {
            uint64_t result = 62;
            goto LABEL_481;
          }
          if (v2 == 3143587592)
          {
            uint64_t result = 166;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
        if (v2 == 3184375231)
        {
LABEL_397:
          uint64_t result = 77;
          goto LABEL_481;
        }
        uint64_t v8 = 3196158497;
        goto LABEL_373;
      }
      if (v2 <= 2458172801)
      {
        if (v2 > 2309863437)
        {
          if (v2 <= 2385671068)
          {
            if (v2 == 2309863438)
            {
              uint64_t result = 37;
              goto LABEL_481;
            }
            if (v2 == 2311900306)
            {
              uint64_t result = 14;
              goto LABEL_481;
            }
            if (v2 != 2336512887) {
              goto LABEL_480;
            }
            goto LABEL_212;
          }
          if (v2 > 2445473384)
          {
            if (v2 == 2445473385)
            {
              uint64_t result = 124;
              goto LABEL_481;
            }
            if (v2 == 2454275343)
            {
              uint64_t result = 63;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          if (v2 != 2385671069)
          {
            if (v2 == 2418348558)
            {
              uint64_t result = 135;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
LABEL_310:
          uint64_t result = 50;
          goto LABEL_481;
        }
        if (v2 > 2262113698)
        {
          if (v2 != 2262113699)
          {
            if (v2 == 2270970153)
            {
              uint64_t result = 21;
              goto LABEL_481;
            }
            if (v2 != 2288107369) {
              goto LABEL_480;
            }
            goto LABEL_396;
          }
          goto LABEL_390;
        }
        if (v2 == 2159747553)
        {
          uint64_t result = 26;
          goto LABEL_481;
        }
        if (v2 == 2162679683)
        {
LABEL_383:
          uint64_t result = 122;
          goto LABEL_481;
        }
        uint64_t v8 = 2236272848;
LABEL_373:
        if (v2 != v8) {
          goto LABEL_480;
        }
LABEL_374:
        uint64_t result = 87;
        goto LABEL_481;
      }
      if (v2 > 2619317133)
      {
        if (v2 <= 2628394913)
        {
          if (v2 != 2619317134)
          {
            if (v2 != 2622433984)
            {
              if (v2 == 2625074843)
              {
                uint64_t result = 161;
                goto LABEL_481;
              }
              goto LABEL_480;
            }
            goto LABEL_385;
          }
          goto LABEL_395;
        }
        if (v2 <= 2644487443)
        {
          if (v2 == 2628394914) {
            goto LABEL_323;
          }
          uint64_t v6 = 2634105757;
          goto LABEL_109;
        }
        if (v2 == 2644487444)
        {
          uint64_t result = 92;
          goto LABEL_481;
        }
        if (v2 != 2673319456) {
          goto LABEL_480;
        }
LABEL_360:
        uint64_t result = 73;
        goto LABEL_481;
      }
      if (v2 > 2516717267)
      {
        if (v2 != 2516717268)
        {
          if (v2 == 2566016329)
          {
            uint64_t result = 94;
            goto LABEL_481;
          }
          if (v2 != 2614323575) {
            goto LABEL_480;
          }
          goto LABEL_310;
        }
        goto LABEL_360;
      }
      if (v2 == 2458172802) {
        goto LABEL_374;
      }
      if (v2 == 2468178735) {
        goto LABEL_384;
      }
      if (v2 != 2487868872) {
        goto LABEL_480;
      }
LABEL_392:
      uint64_t result = 107;
      goto LABEL_481;
    }
    if (v2 <= 3711192743)
    {
      if (v2 <= 3540156651)
      {
        if (v2 <= 3300281075)
        {
          if (v2 <= 3228373940)
          {
            if (v2 == 3196805751)
            {
              uint64_t result = 7;
              goto LABEL_481;
            }
            if (v2 == 3215673114)
            {
              uint64_t result = 75;
              goto LABEL_481;
            }
            uint64_t v7 = 3217792190;
            goto LABEL_147;
          }
          if (v2 == 3228373941) {
            goto LABEL_391;
          }
          if (v2 != 3241053352)
          {
            if (v2 == 3242623367)
            {
              uint64_t result = 15;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          goto LABEL_392;
        }
        if (v2 <= 3397214290)
        {
          if (v2 == 3300281076)
          {
            uint64_t result = 54;
            goto LABEL_481;
          }
          if (v2 == 3348380076)
          {
            uint64_t result = 4;
            goto LABEL_481;
          }
          if (v2 != 3361025853) {
            goto LABEL_480;
          }
          goto LABEL_388;
        }
        if (v2 > 3417429876)
        {
          if (v2 != 3417429877)
          {
            if (v2 == 3455223061)
            {
              uint64_t result = 83;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          goto LABEL_379;
        }
        if (v2 == 3397214291)
        {
          uint64_t result = 74;
          goto LABEL_481;
        }
        if (v2 == 3402870384)
        {
          uint64_t result = 70;
          goto LABEL_481;
        }
LABEL_480:
        uint64_t result = 0;
        goto LABEL_481;
      }
      if (v2 > 3637438249)
      {
        if (v2 <= 3670339450)
        {
          if (v2 == 3637438250)
          {
            uint64_t result = 52;
            goto LABEL_481;
          }
          if (v2 != 3645319985)
          {
            if (v2 == 3663011141)
            {
              uint64_t result = 156;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          goto LABEL_386;
        }
        if (v2 > 3683904381)
        {
          if (v2 == 3683904382)
          {
            uint64_t result = 137;
            goto LABEL_481;
          }
          uint64_t v5 = 3707345671;
          goto LABEL_366;
        }
        if (v2 == 3670339451) {
          goto LABEL_240;
        }
        uint64_t v6 = 3677894691;
LABEL_109:
        if (v2 == v6)
        {
          uint64_t result = 102;
          goto LABEL_481;
        }
        goto LABEL_480;
      }
      if (v2 <= 3585085678)
      {
        if (v2 == 3540156652)
        {
          uint64_t result = 93;
          goto LABEL_481;
        }
        if (v2 != 3543203160)
        {
          if (v2 == 3571532206)
          {
            uint64_t result = 151;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
        goto LABEL_240;
      }
      if (v2 == 3585085679)
      {
        uint64_t result = 10;
        goto LABEL_481;
      }
      if (v2 != 3599094683)
      {
        uint64_t v8 = 3636345305;
        goto LABEL_373;
      }
    }
    else
    {
      if (v2 > 3885279869)
      {
        if (v2 > 4068102501)
        {
          if (v2 <= 4231109336)
          {
            switch(v2)
            {
              case 4068102502:
                uint64_t result = 168;
                goto LABEL_481;
              case 4172444931:
                uint64_t result = 132;
                goto LABEL_481;
              case 4201643249:
                uint64_t result = 35;
                goto LABEL_481;
            }
            goto LABEL_480;
          }
          if (v2 > 4240173201)
          {
            if (v2 == 4240173202)
            {
              uint64_t result = 2;
              goto LABEL_481;
            }
            if (v2 == 4242862982)
            {
              uint64_t result = 80;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          if (v2 != 4231109337)
          {
            if (v2 == 4232256925)
            {
              uint64_t result = 114;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          goto LABEL_231;
        }
        if (v2 <= 3953847431)
        {
          if (v2 == 3885279870)
          {
            uint64_t result = 32;
            goto LABEL_481;
          }
          if (v2 != 3933865620)
          {
            if (v2 == 3933982784)
            {
              uint64_t result = 53;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          goto LABEL_240;
        }
        if (v2 > 4055323050)
        {
          if (v2 == 4055323051)
          {
            uint64_t result = 58;
            goto LABEL_481;
          }
          if (v2 == 4067129264)
          {
            uint64_t result = 139;
            goto LABEL_481;
          }
        }
        else
        {
          if (v2 == 3953847432)
          {
            uint64_t result = 170;
            goto LABEL_481;
          }
          if (v2 == 4025247511)
          {
            uint64_t result = 133;
            goto LABEL_481;
          }
        }
        goto LABEL_480;
      }
      if (v2 <= 3825599859)
      {
        if (v2 <= 3767261005)
        {
          switch(v2)
          {
            case 3711192744:
              uint64_t result = 84;
              goto LABEL_481;
            case 3742999858:
              uint64_t result = 159;
              goto LABEL_481;
            case 3743999268:
              uint64_t result = 24;
              goto LABEL_481;
          }
          goto LABEL_480;
        }
        if (v2 == 3767261006)
        {
          uint64_t result = 153;
          goto LABEL_481;
        }
        if (v2 != 3801472101)
        {
          if (v2 == 3819635030)
          {
            uint64_t result = 160;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
        goto LABEL_302;
      }
      if (v2 <= 3863625341)
      {
        switch(v2)
        {
          case 3825599860:
            uint64_t result = 20;
            goto LABEL_481;
          case 3839750255:
            uint64_t result = 169;
            goto LABEL_481;
          case 3856877970:
            uint64_t result = 110;
            goto LABEL_481;
        }
        goto LABEL_480;
      }
      if (v2 > 3865922941)
      {
        if (v2 == 3865922942)
        {
          uint64_t result = 56;
          goto LABEL_481;
        }
        if (v2 == 3867318491)
        {
          uint64_t result = 162;
          goto LABEL_481;
        }
        goto LABEL_480;
      }
      if (v2 != 3863625342)
      {
        if (v2 == 3865897231)
        {
          uint64_t result = 79;
          goto LABEL_481;
        }
        goto LABEL_480;
      }
    }
    uint64_t result = 97;
    goto LABEL_481;
  }
  if (v2 > 1325975681)
  {
    if (v2 > 1737882205)
    {
      if (v2 > 2032616840)
      {
        if (v2 <= 2089455187)
        {
          if (v2 <= 2080700390)
          {
            if (v2 != 2032616841)
            {
              if (v2 == 2048538371)
              {
                uint64_t result = 60;
                goto LABEL_481;
              }
              if (v2 == 2078329141)
              {
                uint64_t result = 31;
                goto LABEL_481;
              }
              goto LABEL_480;
            }
            goto LABEL_394;
          }
          if (v2 > 2084894488)
          {
            if (v2 == 2084894489)
            {
              uint64_t result = 164;
              goto LABEL_481;
            }
            if (v2 == 2085054105)
            {
              uint64_t result = 158;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          if (v2 == 2080700391)
          {
            uint64_t result = 46;
            goto LABEL_481;
          }
          if (v2 != 2081274472) {
            goto LABEL_480;
          }
          goto LABEL_383;
        }
        if (v2 > 2132302343)
        {
          if (v2 <= 2144123135)
          {
            if (v2 == 2132302344)
            {
              uint64_t result = 148;
              goto LABEL_481;
            }
            uint64_t v7 = 2141052862;
LABEL_147:
            if (v2 != v7) {
              goto LABEL_480;
            }
            goto LABEL_240;
          }
          if (v2 != 2144123136)
          {
            uint64_t v10 = 2158787296;
LABEL_377:
            if (v2 == v10)
            {
              uint64_t result = 69;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
LABEL_379:
          uint64_t result = 194;
          goto LABEL_481;
        }
        if (v2 != 2089455188)
        {
          if (v2 != 2095883268)
          {
            if (v2 != 2103978418) {
              goto LABEL_480;
            }
            goto LABEL_265;
          }
          goto LABEL_389;
        }
LABEL_388:
        uint64_t result = 105;
        goto LABEL_481;
      }
      if (v2 <= 1878257789)
      {
        if (v2 <= 1770142588)
        {
          if (v2 == 1737882206)
          {
            uint64_t result = 116;
            goto LABEL_481;
          }
          if (v2 != 1744899922)
          {
            if (v2 == 1756509290)
            {
              uint64_t result = 144;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          goto LABEL_240;
        }
        if (v2 == 1770142589)
        {
          uint64_t result = 163;
          goto LABEL_481;
        }
        if (v2 == 1834147427) {
          goto LABEL_323;
        }
        uint64_t v11 = 1868379043;
LABEL_350:
        if (v2 != v11) {
          goto LABEL_480;
        }
        goto LABEL_351;
      }
      if (v2 > 1990293941)
      {
        if (v2 <= 2021146988)
        {
          if (v2 == 1990293942)
          {
            uint64_t result = 140;
            goto LABEL_481;
          }
          uint64_t v4 = 2001966017;
LABEL_172:
          if (v2 != v4) {
            goto LABEL_480;
          }
          goto LABEL_302;
        }
        if (v2 == 2021146989)
        {
          uint64_t result = 18;
          goto LABEL_481;
        }
        uint64_t v11 = 2023824667;
        goto LABEL_350;
      }
      if (v2 == 1878257790)
      {
        uint64_t result = 81;
        goto LABEL_481;
      }
      if (v2 == 1895344378)
      {
        uint64_t result = 86;
        goto LABEL_481;
      }
      if (v2 != 1908832379) {
        goto LABEL_480;
      }
LABEL_231:
      uint64_t result = 196;
      goto LABEL_481;
    }
    if (v2 <= 1517755654)
    {
      if (v2 > 1402208363)
      {
        if (v2 <= 1415625991)
        {
          switch(v2)
          {
            case 1402208364:
              uint64_t result = 130;
              goto LABEL_481;
            case 1408738134:
              uint64_t result = 150;
              goto LABEL_481;
            case 1412429328:
              uint64_t result = 65;
              goto LABEL_481;
          }
        }
        else if (v2 > 1429914405)
        {
          if (v2 == 1429914406)
          {
            uint64_t result = 23;
            goto LABEL_481;
          }
          if (v2 == 1434404433)
          {
            uint64_t result = 17;
            goto LABEL_481;
          }
        }
        else
        {
          if (v2 == 1415625992)
          {
            uint64_t result = 136;
            goto LABEL_481;
          }
          if (v2 == 1419435331)
          {
            uint64_t result = 142;
            goto LABEL_481;
          }
        }
        goto LABEL_480;
      }
      if (v2 <= 1371389548)
      {
        if (v2 == 1325975682)
        {
          uint64_t result = 67;
          goto LABEL_481;
        }
        if (v2 != 1353145733)
        {
          uint64_t v9 = 1364038516;
          goto LABEL_260;
        }
LABEL_302:
        uint64_t result = 88;
        goto LABEL_481;
      }
      if (v2 == 1371389549)
      {
        uint64_t result = 27;
        goto LABEL_481;
      }
      if (v2 != 1373516433)
      {
        if (v2 == 1380747801)
        {
          uint64_t result = 127;
          goto LABEL_481;
        }
        goto LABEL_480;
      }
LABEL_351:
      uint64_t result = 100;
      goto LABEL_481;
    }
    if (v2 <= 1602181455)
    {
      if (v2 > 1554479184)
      {
        switch(v2)
        {
          case 1554479185:
            uint64_t result = 167;
            goto LABEL_481;
          case 1559256613:
            uint64_t result = 55;
            goto LABEL_481;
          case 1573906122:
            uint64_t result = 138;
            goto LABEL_481;
        }
      }
      else
      {
        switch(v2)
        {
          case 1517755655:
            uint64_t result = 171;
            goto LABEL_481;
          case 1540760353:
            uint64_t result = 5;
            goto LABEL_481;
          case 1549248876:
            uint64_t result = 172;
            goto LABEL_481;
        }
      }
      goto LABEL_480;
    }
    if (v2 > 1644180311)
    {
      if (v2 > 1721691076)
      {
        if (v2 == 1721691077)
        {
          uint64_t result = 16;
          goto LABEL_481;
        }
        if (v2 == 1733600853)
        {
          uint64_t result = 128;
          goto LABEL_481;
        }
      }
      else
      {
        if (v2 == 1644180312)
        {
          uint64_t result = 145;
          goto LABEL_481;
        }
        if (v2 == 1701146937)
        {
          uint64_t result = 49;
          goto LABEL_481;
        }
      }
      goto LABEL_480;
    }
    if (v2 == 1602181456)
    {
      uint64_t result = 154;
      goto LABEL_481;
    }
    if (v2 == 1608945770)
    {
      uint64_t result = 192;
      goto LABEL_481;
    }
    if (v2 != 1625227434) {
      goto LABEL_480;
    }
LABEL_391:
    uint64_t result = 104;
    goto LABEL_481;
  }
  if (v2 <= 676119127)
  {
    if (v2 <= 337183580)
    {
      if (v2 > 133314239)
      {
        if (v2 <= 228444037)
        {
          if (v2 == 133314240)
          {
            uint64_t result = 40;
            goto LABEL_481;
          }
          if (v2 != 157833461)
          {
            if (v2 == 173258742)
            {
              uint64_t result = 59;
              goto LABEL_481;
            }
            goto LABEL_480;
          }
          goto LABEL_387;
        }
        if (v2 > 262180326)
        {
          if (v2 == 262180327)
          {
            uint64_t result = 123;
            goto LABEL_481;
          }
          if (v2 == 330877086)
          {
            uint64_t result = 43;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
        if (v2 != 228444038)
        {
          if (v2 != 253148925) {
            goto LABEL_480;
          }
LABEL_384:
          uint64_t result = 120;
          goto LABEL_481;
        }
LABEL_386:
        uint64_t result = 72;
        goto LABEL_481;
      }
      if (v2 <= 42878381)
      {
        switch(v2)
        {
          case 23433786:
            uint64_t result = 61;
            goto LABEL_481;
          case 33245053:
            uint64_t result = 68;
            goto LABEL_481;
          case 40511012:
            uint64_t result = 134;
            goto LABEL_481;
        }
        goto LABEL_480;
      }
      if (v2 == 42878382)
      {
        uint64_t result = 12;
        goto LABEL_481;
      }
      if (v2 != 79936591)
      {
        if (v2 != 88647037) {
          goto LABEL_480;
        }
        goto LABEL_397;
      }
LABEL_390:
      uint64_t result = 76;
      goto LABEL_481;
    }
    if (v2 > 363237282)
    {
      if (v2 > 502329936)
      {
        if (v2 <= 555503453)
        {
          if (v2 == 502329937)
          {
            uint64_t result = 22;
            goto LABEL_481;
          }
          uint64_t v5 = 551446205;
LABEL_366:
          if (v2 != v5) {
            goto LABEL_480;
          }
          goto LABEL_367;
        }
        if (v2 != 555503454)
        {
          if (v2 == 574536383)
          {
            uint64_t result = 30;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
LABEL_395:
        uint64_t result = 106;
        goto LABEL_481;
      }
      if (v2 != 363237283)
      {
        if (v2 == 425046865)
        {
          uint64_t result = 157;
          goto LABEL_481;
        }
        if (v2 == 445396642)
        {
          uint64_t result = 117;
          goto LABEL_481;
        }
        goto LABEL_480;
      }
LABEL_240:
      uint64_t result = 193;
      goto LABEL_481;
    }
    if (v2 > 344862119)
    {
      switch(v2)
      {
        case 344862120:
          uint64_t result = 115;
          goto LABEL_481;
        case 355234908:
          uint64_t result = 129;
          goto LABEL_481;
        case 358923952:
          uint64_t result = 126;
          goto LABEL_481;
      }
      goto LABEL_480;
    }
    if (v2 == 337183581)
    {
      uint64_t result = 11;
      goto LABEL_481;
    }
    if (v2 == 340218669)
    {
      uint64_t result = 111;
      goto LABEL_481;
    }
    uint64_t v4 = 341800273;
    goto LABEL_172;
  }
  if (v2 <= 952317140)
  {
    if (v2 > 776033018)
    {
      if (v2 > 851437780)
      {
        if (v2 <= 910181309)
        {
          if (v2 == 851437781)
          {
            uint64_t result = 29;
            goto LABEL_481;
          }
          if (v2 == 896202454)
          {
            uint64_t result = 71;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
        if (v2 != 910181310)
        {
          if (v2 != 910313402) {
            goto LABEL_480;
          }
LABEL_344:
          uint64_t result = 195;
          goto LABEL_481;
        }
LABEL_394:
        uint64_t result = 25;
        goto LABEL_481;
      }
      if (v2 == 776033019)
      {
        uint64_t result = 57;
        goto LABEL_481;
      }
      if (v2 != 810906663)
      {
        uint64_t v10 = 820711327;
        goto LABEL_377;
      }
LABEL_385:
      uint64_t result = 98;
      goto LABEL_481;
    }
    if (v2 <= 746003605)
    {
      if (v2 == 676119128)
      {
        uint64_t result = 146;
        goto LABEL_481;
      }
      if (v2 == 689804742)
      {
        uint64_t result = 36;
        goto LABEL_481;
      }
      uint64_t v9 = 698697055;
LABEL_260:
      if (v2 != v9) {
        goto LABEL_480;
      }
      goto LABEL_379;
    }
    if (v2 != 746003606)
    {
      if (v2 == 749116821)
      {
        uint64_t result = 165;
        goto LABEL_481;
      }
      uint64_t v3 = 761631964;
      goto LABEL_289;
    }
LABEL_323:
    uint64_t result = 101;
    goto LABEL_481;
  }
  if (v2 > 1234705394)
  {
    if (v2 > 1293446024)
    {
      if (v2 <= 1302273957)
      {
        if (v2 != 1293446025)
        {
          if (v2 == 1294429942)
          {
            uint64_t result = 147;
            goto LABEL_481;
          }
          goto LABEL_480;
        }
LABEL_265:
        uint64_t result = 96;
        goto LABEL_481;
      }
      if (v2 != 1302273958)
      {
        if (v2 == 1309571158)
        {
          uint64_t result = 141;
          goto LABEL_481;
        }
        goto LABEL_480;
      }
LABEL_396:
      uint64_t result = 108;
      goto LABEL_481;
    }
    if (v2 == 1234705395)
    {
      uint64_t result = 125;
      goto LABEL_481;
    }
    if (v2 != 1280441783)
    {
      if (v2 == 1280909812)
      {
        uint64_t result = 152;
        goto LABEL_481;
      }
      goto LABEL_480;
    }
LABEL_387:
    uint64_t result = 78;
    goto LABEL_481;
  }
  if (v2 <= 1110205731)
  {
    if (v2 != 952317141)
    {
      if (v2 == 1060988941)
      {
        uint64_t result = 9;
        goto LABEL_481;
      }
      if (v2 == 1085318934)
      {
        uint64_t result = 131;
        goto LABEL_481;
      }
      goto LABEL_480;
    }
LABEL_212:
    uint64_t result = 121;
    goto LABEL_481;
  }
  if (v2 > 1119807501)
  {
    if (v2 != 1119807502)
    {
      if (v2 == 1169082144)
      {
        uint64_t result = 33;
        goto LABEL_481;
      }
      goto LABEL_480;
    }
LABEL_367:
    uint64_t result = 51;
    goto LABEL_481;
  }
  if (v2 == 1110205732)
  {
    uint64_t result = 48;
    goto LABEL_481;
  }
  if (v2 != 1114644381) {
    goto LABEL_480;
  }
  uint64_t result = 82;
LABEL_481:
  PlatformUtilities_iOS::GetProductType(void)::sType = result;
  return result;
}

uint64_t PlatformUtilities_iOS::ProductIsMuseDevice(PlatformUtilities_iOS *this)
{
  {
    uint64_t v2 = MGGetBoolAnswer();
    BOOL v4 = (v2 & 1) != 0
      || (int ProductType = (PlatformUtilities_iOS *)PlatformUtilities_iOS::GetProductType((PlatformUtilities_iOS *)v2),
          ProductType == 173)
      || PlatformUtilities_iOS::GetProductType(ProductType) == 188;
    PlatformUtilities_iOS::ProductIsMuseDevice(void)::isMuseDevice = v4;
  }
  return PlatformUtilities_iOS::ProductIsMuseDevice(void)::isMuseDevice;
}

void sub_21B52BEC8(_Unwind_Exception *a1)
{
}

void CACFString::~CACFString(CACFString *this)
{
  if (*((unsigned char *)this + 8))
  {
    uint64_t v2 = *(const void **)this;
    if (*(void *)this) {
      CFRelease(v2);
    }
  }
}

uint64_t CACFString::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const void **)a2;
  if (*(void *)a2 != *(void *)a1)
  {
    if (*(void *)a1) {
      BOOL v5 = *(unsigned char *)(a1 + 8) == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      CFRelease(*(CFTypeRef *)a1);
      uint64_t v3 = *(const void **)a2;
    }
    *(void *)a1 = v3;
    int v6 = *(unsigned __int8 *)(a2 + 8);
    *(unsigned char *)(a1 + 8) = v6;
    if (v6) {
      BOOL v7 = v3 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7) {
      CFRetain(v3);
    }
  }
  return a1;
}

CFStringRef PlatformUtilities_iOS::CopyAcousticIDFilePrefix(PlatformUtilities_iOS *this)
{
  if (MGIsQuestionValid()) {
    MGGetSInt32Answer();
  }
  uint64_t v22 = 0;
  long long v20 = 0u;
  memset(v21, 0, sizeof(v21));
  *(_OWORD *)std::vector<char> __p = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  *(_OWORD *)__src = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v13);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v14, (uint64_t)"AID", 3);
  std::ostream::operator<<();
  if ((BYTE8(v20) & 0x10) != 0)
  {
    uint64_t v3 = (unsigned char *)v20;
    if ((void *)v20 < __src[1])
    {
      *(void **)&long long v20 = __src[1];
      uint64_t v3 = __src[1];
    }
    BOOL v4 = __src[0];
  }
  else
  {
    if ((BYTE8(v20) & 8) == 0)
    {
      size_t v1 = 0;
      HIBYTE(v12) = 0;
      uint64_t v2 = __dst;
      goto LABEL_18;
    }
    BOOL v4 = (unsigned char *)*((void *)&v15 + 1);
    uint64_t v3 = (unsigned char *)*((void *)&v16 + 1);
  }
  size_t v1 = v3 - v4;
  if ((unint64_t)(v3 - v4) >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v1 >= 0x17)
  {
    uint64_t v5 = (v1 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v1 | 7) != 0x17) {
      uint64_t v5 = v1 | 7;
    }
    uint64_t v6 = v5 + 1;
    uint64_t v2 = (void **)operator new(v5 + 1);
    __dst[1] = (void *)v1;
    int64_t v12 = v6 | 0x8000000000000000;
    __dst[0] = v2;
    goto LABEL_17;
  }
  HIBYTE(v12) = (_BYTE)v3 - (_BYTE)v4;
  uint64_t v2 = __dst;
  if (v1) {
LABEL_17:
  }
    memmove(v2, v4, v1);
LABEL_18:
  *((unsigned char *)v2 + v1) = 0;
  if (v12 >= 0) {
    BOOL v7 = (const char *)__dst;
  }
  else {
    BOOL v7 = (const char *)__dst[0];
  }
  CFStringRef v8 = CFStringCreateWithCString(0, v7, 0x600u);
  if (SHIBYTE(v12) < 0) {
    operator delete(__dst[0]);
  }
  *(void *)&long long v13 = *MEMORY[0x263F8C2B8];
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)&v13 + *(void *)(v13 - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  *(void *)&long long v14 = v9;
  *((void *)&v14 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x21D48F700](v21);
  return v8;
}

void sub_21B52C248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C328] + 104;
  *(void *)(a1 + 128) = MEMORY[0x263F8C328] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x263F8C328] + 64;
  *(void *)(a1 + 16) = MEMORY[0x263F8C328] + 64;
  uint64_t v5 = (void *)MEMORY[0x263F8C2B8];
  uint64_t v6 = *(void *)(MEMORY[0x263F8C2B8] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x263F8C2B8] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  CFStringRef v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x263F8C328] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 12std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 24;
  return a1;
}

void sub_21B52C528(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x21D48F700](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x21D48F700](a1 + 128);
  return a1;
}

CFStringRef PlatformUtilities_iOS::CopyProductTypeFilePrefix(int a1)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  *(void *)__str = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  switch(a1)
  {
    case 1:
      uint64_t v27 = 0;
      int v1 = 184;
      goto LABEL_8;
    case 2:
      uint64_t v27 = 0;
      goto LABEL_5;
    case 3:
      uint64_t v27 = 97;
LABEL_5:
      int v1 = 238;
      goto LABEL_8;
    case 4:
      uint64_t v27 = 0;
      int v1 = 520;
      goto LABEL_8;
    case 5:
      uint64_t v27 = 0;
      int v1 = 620;
LABEL_8:
      uint64_t v2 = 98;
      goto LABEL_233;
    case 6:
      uint64_t v27 = 0;
      int v1 = 10;
      goto LABEL_50;
    case 7:
      uint64_t v27 = 0;
      int v1 = 11;
      goto LABEL_50;
    case 8:
      uint64_t v27 = 0;
      int v1 = 12;
      goto LABEL_50;
    case 9:
      uint64_t v27 = 0;
      int v1 = 16;
      goto LABEL_50;
    case 10:
      uint64_t v27 = 0;
      int v1 = 17;
      goto LABEL_50;
    case 11:
      uint64_t v27 = 0;
      int v1 = 101;
      goto LABEL_50;
    case 12:
      uint64_t v27 = 0;
      int v1 = 111;
      goto LABEL_50;
    case 13:
      uint64_t v27 = 0;
      int v1 = 121;
      goto LABEL_50;
    case 14:
      uint64_t v27 = 0;
      int v1 = 20;
      goto LABEL_50;
    case 15:
      uint64_t v27 = 0;
      int v1 = 21;
      goto LABEL_50;
    case 16:
      uint64_t v27 = 0;
      int v1 = 22;
      goto LABEL_50;
    case 17:
      uint64_t v27 = 0;
      goto LABEL_49;
    case 18:
      uint64_t v27 = 0;
      int v1 = 28;
      goto LABEL_50;
    case 19:
      uint64_t v27 = 0;
      int v1 = 37;
      goto LABEL_50;
    case 20:
      uint64_t v27 = 0;
      int v1 = 38;
      goto LABEL_50;
    case 21:
      uint64_t v27 = 0;
      int v1 = 201;
      goto LABEL_50;
    case 22:
      uint64_t v27 = 0;
      int v1 = 211;
      goto LABEL_50;
    case 23:
      uint64_t v27 = 0;
      int v1 = 221;
      goto LABEL_50;
    case 24:
      uint64_t v27 = 0;
      int v1 = 32;
      goto LABEL_50;
    case 25:
      uint64_t v27 = 0;
      int v1 = 33;
      goto LABEL_50;
    case 26:
      uint64_t v27 = 0;
      int v1 = 79;
      goto LABEL_50;
    case 27:
      uint64_t v27 = 0;
      int v1 = 42;
      goto LABEL_50;
    case 28:
      uint64_t v27 = 0;
      int v1 = 43;
      goto LABEL_50;
    case 29:
      uint64_t v27 = 0;
      int v1 = 47;
      goto LABEL_50;
    case 30:
      uint64_t v27 = 0;
      int v1 = 48;
      goto LABEL_50;
    case 31:
      uint64_t v27 = 0;
      int v1 = 49;
      goto LABEL_50;
    case 32:
      uint64_t v27 = 103;
      int v1 = 52;
      goto LABEL_50;
    case 33:
      uint64_t v3 = 103;
      goto LABEL_38;
    case 34:
      uint64_t v3 = 112;
LABEL_38:
      uint64_t v27 = v3;
      int v1 = 53;
      goto LABEL_50;
    case 35:
      uint64_t v27 = 112;
      int v1 = 54;
      goto LABEL_50;
    case 36:
      uint64_t v27 = 0;
      int v1 = 63;
      goto LABEL_50;
    case 37:
      uint64_t v27 = 0;
      int v1 = 64;
      goto LABEL_50;
    case 38:
      uint64_t v27 = 0;
      int v1 = 73;
      goto LABEL_50;
    case 39:
      uint64_t v27 = 0;
      int v1 = 74;
      goto LABEL_50;
    case 40:
      uint64_t v27 = 0;
      int v1 = 83;
      goto LABEL_50;
    case 41:
      uint64_t v27 = 0;
      int v1 = 84;
      goto LABEL_50;
    case 42:
      uint64_t v27 = 0;
      int v1 = 93;
      goto LABEL_50;
    case 43:
      uint64_t v27 = 0;
      int v1 = 94;
      goto LABEL_50;
    case 44:
      uint64_t v27 = 117;
LABEL_49:
      int v1 = 27;
LABEL_50:
      uint64_t v2 = 100;
      goto LABEL_233;
    case 45:
      uint64_t v27 = 0;
      int v1 = 59;
      goto LABEL_243;
    case 46:
      uint64_t v27 = 0;
      int v1 = 104;
      goto LABEL_232;
    case 47:
      uint64_t v27 = 0;
      goto LABEL_55;
    case 48:
      uint64_t v27 = 100;
LABEL_55:
      int v1 = 42;
      goto LABEL_123;
    case 49:
      uint64_t v27 = 0;
      goto LABEL_60;
    case 50:
      uint64_t v4 = 98;
      goto LABEL_59;
    case 51:
      uint64_t v4 = 115;
LABEL_59:
      uint64_t v27 = v4;
LABEL_60:
      int v1 = 71;
      goto LABEL_123;
    case 52:
      uint64_t v27 = 0;
      int v1 = 72;
      goto LABEL_123;
    case 53:
      uint64_t v27 = 0;
      int v1 = 73;
      goto LABEL_123;
    case 54:
      uint64_t v27 = 0;
      int v1 = 81;
      goto LABEL_123;
    case 55:
      uint64_t v27 = 0;
      int v1 = 82;
      goto LABEL_123;
    case 56:
      uint64_t v27 = 0;
      goto LABEL_67;
    case 57:
      uint64_t v27 = 109;
LABEL_67:
      int v1 = 85;
      goto LABEL_123;
    case 58:
      uint64_t v27 = 0;
      goto LABEL_70;
    case 59:
      uint64_t v27 = 109;
LABEL_70:
      int v1 = 86;
      goto LABEL_123;
    case 60:
      uint64_t v27 = 0;
      goto LABEL_73;
    case 61:
      uint64_t v27 = 109;
LABEL_73:
      int v1 = 87;
      goto LABEL_123;
    case 62:
      uint64_t v27 = 0;
      int v1 = 96;
      goto LABEL_123;
    case 63:
      uint64_t v27 = 0;
      int v1 = 97;
      goto LABEL_123;
    case 64:
      uint64_t v27 = 0;
      goto LABEL_78;
    case 65:
      uint64_t v27 = 97;
LABEL_78:
      int v1 = 98;
      goto LABEL_123;
    case 66:
      uint64_t v27 = 0;
      goto LABEL_81;
    case 67:
      uint64_t v27 = 97;
LABEL_81:
      int v1 = 99;
      goto LABEL_123;
    case 68:
      uint64_t v27 = 97;
      int v1 = 105;
      goto LABEL_123;
    case 69:
      uint64_t v27 = 0;
      int v1 = 120;
      goto LABEL_123;
    case 70:
      uint64_t v27 = 0;
      int v1 = 127;
      goto LABEL_123;
    case 71:
      uint64_t v27 = 0;
      int v1 = 128;
      goto LABEL_123;
    case 72:
      uint64_t v27 = 0;
      goto LABEL_88;
    case 73:
      uint64_t v27 = 97;
LABEL_88:
      int v1 = 171;
      goto LABEL_123;
    case 74:
      uint64_t v27 = 0;
      int v1 = 181;
      goto LABEL_123;
    case 75:
      uint64_t v27 = 0;
      int v1 = 182;
      goto LABEL_123;
    case 76:
      uint64_t v27 = 0;
      int v1 = 207;
      goto LABEL_123;
    case 77:
      uint64_t v27 = 0;
      int v1 = 210;
      goto LABEL_123;
    case 78:
      uint64_t v27 = 0;
      int v1 = 217;
      goto LABEL_123;
    case 79:
      uint64_t v27 = 0;
      int v1 = 255;
      goto LABEL_123;
    case 80:
      uint64_t v27 = 0;
      int v1 = 271;
      goto LABEL_123;
    case 81:
      uint64_t v27 = 0;
      int v1 = 272;
      goto LABEL_123;
    case 82:
      uint64_t v27 = 0;
      int v1 = 305;
      goto LABEL_123;
    case 83:
      uint64_t v27 = 0;
      int v1 = 307;
      goto LABEL_123;
    case 84:
      uint64_t v27 = 0;
      int v1 = 308;
      goto LABEL_123;
    case 85:
      uint64_t v27 = 0;
      int v1 = 310;
      goto LABEL_123;
    case 86:
      uint64_t v27 = 0;
      int v1 = 311;
      goto LABEL_123;
    case 87:
      uint64_t v27 = 0;
      int v1 = 317;
      goto LABEL_123;
    case 88:
      uint64_t v27 = 0;
      int v1 = 320;
      goto LABEL_123;
    case 89:
      uint64_t v27 = 0;
      int v1 = 348;
      goto LABEL_123;
    case 90:
      uint64_t v27 = 0;
      int v1 = 381;
      goto LABEL_123;
    case 91:
      uint64_t v27 = 0;
      int v1 = 382;
      goto LABEL_123;
    case 92:
      uint64_t v27 = 0;
      int v1 = 407;
      goto LABEL_123;
    case 93:
      uint64_t v27 = 0;
      int v1 = 408;
      goto LABEL_123;
    case 94:
      uint64_t v27 = 0;
      int v1 = 410;
      goto LABEL_123;
    case 95:
      uint64_t v27 = 0;
      int v1 = 411;
      goto LABEL_123;
    case 96:
      uint64_t v27 = 0;
      int v1 = 417;
      goto LABEL_123;
    case 97:
      uint64_t v27 = 0;
      int v1 = 420;
      goto LABEL_123;
    case 98:
      uint64_t v27 = 0;
      int v1 = 507;
      goto LABEL_123;
    case 99:
      uint64_t v27 = 0;
      int v1 = 508;
      goto LABEL_123;
    case 100:
      uint64_t v27 = 0;
      int v1 = 517;
      goto LABEL_123;
    case 101:
      uint64_t v27 = 0;
      int v1 = 522;
      goto LABEL_123;
    case 102:
      uint64_t v27 = 0;
      int v1 = 537;
      goto LABEL_123;
    case 103:
      uint64_t v27 = 0;
      int v1 = 538;
      goto LABEL_123;
    case 104:
      uint64_t v27 = 0;
      int v1 = 617;
      goto LABEL_123;
    case 105:
      uint64_t v27 = 0;
      int v1 = 620;
      goto LABEL_123;
    case 106:
      uint64_t v27 = 0;
      int v1 = 717;
      goto LABEL_123;
    case 107:
      uint64_t v27 = 0;
      int v1 = 720;
LABEL_123:
      uint64_t v2 = 106;
      goto LABEL_233;
    case 108:
      uint64_t v27 = 97;
      int v1 = 27;
      goto LABEL_232;
    case 109:
      uint64_t v27 = 97;
      int v1 = 28;
      goto LABEL_232;
    case 110:
      uint64_t v27 = 0;
      int v1 = 41;
      goto LABEL_232;
    case 111:
      uint64_t v27 = 0;
      int v1 = 42;
      goto LABEL_232;
    case 112:
      uint64_t v27 = 0;
      int v1 = 48;
      goto LABEL_232;
    case 113:
      uint64_t v27 = 0;
      int v1 = 49;
      goto LABEL_232;
    case 114:
      uint64_t v27 = 0;
      int v1 = 51;
      goto LABEL_232;
    case 115:
      uint64_t v27 = 0;
      int v1 = 53;
      goto LABEL_232;
    case 116:
      uint64_t v27 = 0;
      int v1 = 56;
      goto LABEL_232;
    case 117:
      uint64_t v27 = 0;
      int v1 = 61;
      goto LABEL_232;
    case 118:
      uint64_t v27 = 0;
      int v1 = 64;
      goto LABEL_232;
    case 119:
      uint64_t v27 = 0;
      int v1 = 65;
      goto LABEL_232;
    case 120:
      uint64_t v27 = 0;
      int v1 = 66;
      goto LABEL_232;
    case 121:
      uint64_t v27 = 0;
      int v1 = 69;
      goto LABEL_232;
    case 122:
      uint64_t v27 = 0;
      int v1 = 71;
      goto LABEL_232;
    case 123:
      uint64_t v27 = 0;
      int v1 = 74;
      goto LABEL_232;
    case 124:
      uint64_t v27 = 0;
      int v1 = 75;
      goto LABEL_232;
    case 125:
      uint64_t v27 = 0;
      int v1 = 841;
      goto LABEL_232;
    case 126:
      uint64_t v27 = 0;
      int v1 = 102;
      goto LABEL_232;
    case 127:
      uint64_t v27 = 0;
      int v1 = 112;
      goto LABEL_232;
    case 128:
      uint64_t v5 = 115;
      goto LABEL_146;
    case 129:
      uint64_t v5 = 98;
LABEL_146:
      uint64_t v27 = v5;
      int v1 = 111;
      goto LABEL_232;
    case 130:
      uint64_t v6 = 115;
      goto LABEL_149;
    case 131:
      uint64_t v6 = 98;
LABEL_149:
      uint64_t v27 = v6;
      int v1 = 121;
      goto LABEL_232;
    case 132:
      uint64_t v7 = 115;
      goto LABEL_152;
    case 133:
      uint64_t v7 = 98;
LABEL_152:
      uint64_t v27 = v7;
      int v1 = 131;
      goto LABEL_232;
    case 134:
      uint64_t v8 = 115;
      goto LABEL_155;
    case 135:
      uint64_t v8 = 98;
LABEL_155:
      uint64_t v27 = v8;
      int v1 = 140;
      goto LABEL_232;
    case 136:
      uint64_t v9 = 115;
      goto LABEL_158;
    case 137:
      uint64_t v9 = 98;
LABEL_158:
      uint64_t v27 = v9;
      int v1 = 141;
      goto LABEL_232;
    case 138:
      uint64_t v10 = 115;
      goto LABEL_161;
    case 139:
      uint64_t v10 = 98;
LABEL_161:
      uint64_t v27 = v10;
      int v1 = 142;
      goto LABEL_232;
    case 140:
      uint64_t v11 = 98;
      goto LABEL_164;
    case 141:
      uint64_t v11 = 115;
LABEL_164:
      uint64_t v27 = v11;
      int v1 = 143;
      goto LABEL_232;
    case 142:
      uint64_t v12 = 115;
      goto LABEL_167;
    case 143:
      uint64_t v12 = 98;
LABEL_167:
      uint64_t v27 = v12;
      int v1 = 144;
      goto LABEL_232;
    case 144:
      uint64_t v13 = 115;
      goto LABEL_170;
    case 145:
      uint64_t v13 = 98;
LABEL_170:
      uint64_t v27 = v13;
      int v1 = 146;
      goto LABEL_232;
    case 146:
      uint64_t v14 = 98;
      goto LABEL_173;
    case 147:
      uint64_t v14 = 115;
LABEL_173:
      uint64_t v27 = v14;
      int v1 = 149;
      goto LABEL_232;
    case 148:
      uint64_t v15 = 115;
      goto LABEL_176;
    case 149:
      uint64_t v15 = 98;
LABEL_176:
      uint64_t v27 = v15;
      int v1 = 157;
      goto LABEL_232;
    case 150:
      uint64_t v16 = 115;
      goto LABEL_179;
    case 151:
      uint64_t v16 = 98;
LABEL_179:
      uint64_t v27 = v16;
      int v1 = 158;
      goto LABEL_232;
    case 152:
      uint64_t v17 = 115;
      goto LABEL_182;
    case 153:
      uint64_t v17 = 98;
LABEL_182:
      uint64_t v27 = v17;
      int v1 = 187;
      goto LABEL_232;
    case 154:
      uint64_t v18 = 115;
      goto LABEL_185;
    case 155:
      uint64_t v18 = 98;
LABEL_185:
      uint64_t v27 = v18;
      int v1 = 188;
      goto LABEL_232;
    case 156:
      uint64_t v19 = 115;
      goto LABEL_188;
    case 157:
      uint64_t v19 = 98;
LABEL_188:
      uint64_t v27 = v19;
      int v1 = 197;
      goto LABEL_232;
    case 158:
      uint64_t v20 = 115;
      goto LABEL_191;
    case 159:
      uint64_t v20 = 98;
LABEL_191:
      uint64_t v27 = v20;
      int v1 = 198;
      goto LABEL_232;
    case 160:
      uint64_t v27 = 0;
      int v1 = 199;
      goto LABEL_232;
    case 161:
      uint64_t v21 = 115;
      goto LABEL_195;
    case 162:
      uint64_t v21 = 98;
LABEL_195:
      uint64_t v27 = v21;
      int v1 = 207;
      goto LABEL_232;
    case 163:
      uint64_t v22 = 115;
      goto LABEL_198;
    case 164:
      uint64_t v22 = 98;
LABEL_198:
      uint64_t v27 = v22;
      int v1 = 208;
      goto LABEL_232;
    case 165:
      uint64_t v23 = 115;
      goto LABEL_201;
    case 166:
      uint64_t v23 = 98;
LABEL_201:
      uint64_t v27 = v23;
      int v1 = 217;
      goto LABEL_232;
    case 167:
      uint64_t v24 = 115;
      goto LABEL_204;
    case 168:
      uint64_t v24 = 98;
LABEL_204:
      uint64_t v27 = v24;
      int v1 = 218;
      goto LABEL_232;
    case 169:
      uint64_t v27 = 0;
      int v1 = 210;
      goto LABEL_232;
    case 170:
      uint64_t v27 = 0;
      int v1 = 101;
      goto LABEL_209;
    case 171:
      uint64_t v27 = 0;
      int v1 = 102;
      goto LABEL_209;
    case 172:
      uint64_t v27 = 0;
      int v1 = 103;
LABEL_209:
      uint64_t v2 = 112;
      goto LABEL_233;
    case 173:
      uint64_t v25 = 110;
      goto LABEL_212;
    case 174:
      uint64_t v25 = 112;
LABEL_212:
      uint64_t v27 = v25;
      int v1 = 398;
      goto LABEL_229;
    case 175:
      uint64_t v27 = 0;
      int v1 = 456;
      goto LABEL_229;
    case 176:
      uint64_t v27 = 112;
      int v1 = 698;
      goto LABEL_229;
    case 177:
      uint64_t v27 = 0;
      int v1 = 720;
      goto LABEL_229;
    case 178:
      uint64_t v27 = 0;
      int v1 = 721;
      goto LABEL_229;
    case 179:
      uint64_t v27 = 0;
      int v1 = 734;
      goto LABEL_229;
    case 180:
      uint64_t v27 = 0;
      int v1 = 742;
      goto LABEL_229;
    case 181:
      uint64_t v27 = 0;
      int v1 = 1125;
      goto LABEL_229;
    case 182:
      uint64_t v27 = 0;
      int v1 = 1153;
      goto LABEL_229;
    case 183:
      uint64_t v27 = 0;
      int v1 = 1232;
      goto LABEL_229;
    case 184:
      uint64_t v27 = 0;
      int v1 = 1250;
      goto LABEL_229;
    case 185:
      uint64_t v27 = 0;
      int v1 = 1251;
      goto LABEL_229;
    case 186:
      uint64_t v27 = 0;
      int v1 = 1252;
      goto LABEL_229;
    case 187:
      uint64_t v27 = 0;
      int v1 = 1253;
      goto LABEL_229;
    case 188:
      snprintf(__str, 0x18uLL, "%c%d%c", 116, 698, 116);
      goto LABEL_234;
    case 189:
      uint64_t v27 = 0;
      int v1 = 6502;
      goto LABEL_229;
    case 190:
      uint64_t v27 = 0;
      int v1 = 6809;
LABEL_229:
      uint64_t v2 = 116;
      goto LABEL_233;
    case 191:
      uint64_t v27 = 0;
      int v1 = 100;
      uint64_t v2 = 113;
      goto LABEL_233;
    case 192:
      uint64_t v27 = 0;
      int v1 = 301;
LABEL_232:
      uint64_t v2 = 110;
      goto LABEL_233;
    case 193:
      uint64_t v27 = 0;
      int v1 = 101;
      goto LABEL_243;
    case 194:
      uint64_t v27 = 0;
      int v1 = 201;
      goto LABEL_243;
    case 195:
      uint64_t v27 = 0;
      int v1 = 301;
      goto LABEL_243;
    case 196:
      uint64_t v27 = 0;
      int v1 = 401;
      goto LABEL_243;
    case 197:
      uint64_t v27 = 0;
      int v1 = 501;
LABEL_243:
      uint64_t v2 = 118;
LABEL_233:
      snprintf(__str, 0x18uLL, "%c%d%c", v2, v1, v27);
LABEL_234:
      if (!__str[0]) {
        goto LABEL_236;
      }
      CFStringRef result = CFStringCreateWithCString(0, __str, 0x600u);
      break;
    default:
LABEL_236:
      CFStringRef result = 0;
      break;
  }
  return result;
}

uint64_t *CASmartPreferences::instance(CASmartPreferences *this)
{
  {
    if (v2)
    {
      CASmartPreferences::CASmartPreferences(v2);
    }
  }
  return &CASmartPreferences::instance(void)::global;
}

void sub_21B52D41C(_Unwind_Exception *a1)
{
}

void CASmartPreferences::CASmartPreferences(CASmartPreferences *this)
{
  CASmartPreferences::instance(void)::global = 850045863;
  unk_26AD09058 = 0u;
  unk_26AD09068 = 0u;
  unk_26AD09078 = 0u;
  qword_26AD09088 = 0;
  qword_26AD09090 = (uint64_t)CFSetCreateMutable(0, 0, MEMORY[0x263EFFFA0]);
  global_queue = dispatch_get_global_queue(0, 0);
  unk_26AD09098 = 0u;
  unk_26AD090A8 = 0u;
  qword_26AD090B0 = (uint64_t)dispatch_source_create(MEMORY[0x263EF83F0], 1uLL, 0, global_queue);
  handler[0] = MEMORY[0x263EF8330];
  handler[1] = 0x40000000;
  handler[2] = ___ZN18CASmartPreferencesC2Ev_block_invoke;
  handler[3] = &__block_descriptor_tmp_11;
  handler[4] = &CASmartPreferences::instance(void)::global;
  dispatch_source_set_event_handler((dispatch_source_t)qword_26AD090B0, handler);
  dispatch_resume((dispatch_object_t)qword_26AD090B0);
}

void sub_21B52D524(_Unwind_Exception *a1)
{
}

void ___ZN18CASmartPreferencesC2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  std::mutex::lock((std::mutex *)v1);
  CFSetApplyFunction(*(CFSetRef *)(v1 + 64), (CFSetApplierFunction)SynchronizePrefDomain, 0);
  uint64_t v2 = *(CFStringRef **)(v1 + 72);
  uint64_t v3 = *(CFStringRef **)(v1 + 80);
  while (v2 != v3)
  {
    CASmartPreferences::Pref::Load(v2);
    v2 += 6;
  }

  std::mutex::unlock((std::mutex *)v1);
}

void sub_21B52D5B8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

CFPropertyListRef CASmartPreferences::Pref::Load(CFStringRef *this)
{
  CFPropertyListRef result = CFPreferencesCopyAppValue(*this, this[1]);
  if (result)
  {
    CFPropertyListRef v4 = result;
    CFStringRef v3 = this[5];
    if (!v3) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    return (CFPropertyListRef)(*((uint64_t (**)(CFStringRef, CFPropertyListRef *))v3->isa + 6))(v3, &v4);
  }
  return result;
}

uint64_t SynchronizePrefDomain(const __CFString *a1, void *a2)
{
  return CFPreferencesSynchronize(a1, (CFStringRef)*MEMORY[0x263EFFE70], (CFStringRef)*MEMORY[0x263EFFE68]);
}

BOOL CASmartPreferences::InterpretBoolean(CASmartPreferences *this, unsigned char *a2, BOOL *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int valuePtr = 0;
  *a2 = 0;
  if (this)
  {
    CFBooleanRef v4 = this;
    CFTypeID v5 = CFGetTypeID(this);
    if (v5 == CFBooleanGetTypeID())
    {
      LODWORD(this) = CFBooleanGetValue(v4);
LABEL_6:
      *a2 = 1;
      return this != 0;
    }
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v4, kCFNumberIntType, &valuePtr);
      LODWORD(this) = valuePtr != 0;
      goto LABEL_6;
    }
    if (v5 != CFStringGetTypeID())
    {
      LODWORD(this) = 0;
      return this != 0;
    }
    long long v14 = 0u;
    long long v15 = 0u;
    *(_OWORD *)buffer = 0u;
    long long v13 = 0u;
    CFStringGetCString((CFStringRef)v4, buffer, 64, 0x600u);
    if (sscanf(buffer, "%d", &valuePtr) == 1)
    {
      *a2 = 1;
      LODWORD(this) = valuePtr != 0;
      return this != 0;
    }
    char v7 = buffer[0];
    if (buffer[0])
    {
      uint64_t v8 = &buffer[1];
      do
      {
        *(v8 - 1) = __tolower(v7);
        int v9 = *v8++;
        char v7 = v9;
      }
      while (v9);
    }
    if (!(*(unsigned __int16 *)buffer ^ 0x6F6E | buffer[2])
      || (*(_DWORD *)buffer == 1936482662 ? (BOOL v10 = *(unsigned __int16 *)&buffer[4] == 101) : (BOOL v10 = 0), v10))
    {
      LODWORD(this) = 0;
      goto LABEL_6;
    }
    if (*(_DWORD *)buffer == 7562617 || !(*(_DWORD *)buffer ^ 0x65757274 | buffer[4]))
    {
      LODWORD(this) = 1;
      *a2 = 1;
    }
    else
    {
      LODWORD(this) = valuePtr;
    }
  }
  return this != 0;
}

void CASmartPreferences::_RegisterFirstHandler(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
  std::mutex::lock((std::mutex *)a1);
  uint64_t v8 = *(CFTypeRef **)(a1 + 72);
  int v9 = *(CFTypeRef **)(a1 + 80);
  while (v8 != v9)
  {
    if (CFEqual(a2, *v8) && CFEqual(a3, v8[1])) {
      goto LABEL_31;
    }
    v8 += 6;
  }
  CFRetain(a2);
  CFRetain(a3);
  unint64_t v10 = *(void *)(a1 + 88);
  unint64_t v11 = *(void *)(a1 + 80);
  if (v11 >= v10)
  {
    uint64_t v13 = *(void *)(a1 + 72);
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v13) >> 4);
    if (v14 + 1 > 0x555555555555555) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v13) >> 4);
    uint64_t v16 = 2 * v15;
    if (2 * v15 <= v14 + 1) {
      uint64_t v16 = v14 + 1;
    }
    if (v15 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v17 = 0x555555555555555;
    }
    else {
      unint64_t v17 = v16;
    }
    uint64_t v32 = a1 + 88;
    if (v17)
    {
      if (v17 > 0x555555555555555) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v18 = (char *)operator new(48 * v17);
    }
    else
    {
      uint64_t v18 = 0;
    }
    uint64_t v29 = v18;
    v30.i64[0] = (uint64_t)&v18[48 * v14];
    uint64_t v31 = &v18[48 * v17];
    std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(v30.i64[0], (uint64_t)a2, (uint64_t)a3, a4);
    uint64_t v19 = v30.i64[0];
    uint64_t v12 = v30.i64[0] + 48;
    v30.i64[1] = v30.i64[0] + 48;
    uint64_t v21 = *(void *)(a1 + 72);
    unint64_t v20 = *(void *)(a1 + 80);
    if (v20 == v21)
    {
      int64x2_t v27 = vdupq_n_s64(v20);
LABEL_29:
      *(void *)(a1 + 72) = v19;
      *(void *)(a1 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v12;
      int64x2_t v30 = v27;
      uint64_t v28 = *(char **)(a1 + 88);
      *(void *)(a1 + 88) = v31;
      uint64_t v31 = v28;
      uint64_t v29 = (char *)v27.i64[0];
      std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer((uint64_t)&v29);
      goto LABEL_30;
    }
    uint64_t v22 = 0;
    uint64_t v23 = v30.i64[0];
    while (1)
    {
      uint64_t v24 = v19 + v22;
      *(_OWORD *)(v19 + v22 - 48) = *(_OWORD *)(v20 + v22 - 48);
      uint64_t v25 = v20 + v22 - 8;
      uint64_t v26 = *(void *)v25;
      if (*(void *)v25)
      {
        if (v20 + v22 - 32 == v26)
        {
          *(void *)(v24 - 8) = v24 - 32;
          (*(void (**)(void))(**(void **)v25 + 24))();
          goto LABEL_26;
        }
        *(void *)(v24 - 8) = v26;
      }
      else
      {
        uint64_t v25 = v23 - 8;
      }
      *(void *)uint64_t v25 = 0;
LABEL_26:
      v23 -= 48;
      v22 -= 48;
      if (v20 + v22 == v21)
      {
        v19 += v22;
        int64x2_t v27 = *(int64x2_t *)(a1 + 72);
        uint64_t v12 = v30.i64[1];
        goto LABEL_29;
      }
    }
  }
  std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(*(void **)(a1 + 80), (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v12 = v11 + 48;
  *(void *)(a1 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v11 + 48;
LABEL_30:
  *(void *)(a1 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v12;
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 64), a3);
  CASmartPreferences::Pref::Load((CFStringRef *)(*(void *)(a1 + 80) - 48));
LABEL_31:
  std::mutex::unlock((std::mutex *)a1);
}

void sub_21B52DAA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer((uint64_t)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

void *std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v8[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void const*)>::__value_func[abi:ne180100]((uint64_t)v8, a4);
  *a1 = a2;
  a1[1] = a3;
  std::__function::__value_func<BOOL ()(void const*)>::__value_func[abi:ne180100]((uint64_t)(a1 + 2), (uint64_t)v8);
  std::__function::__value_func<BOOL ()(void const*)>::~__value_func[abi:ne180100](v8);
  return a1;
}

void sub_21B52DB68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(void const*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    std::__function::__value_func<BOOL ()(void const*)>::~__value_func[abi:ne180100]((void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__function::__value_func<BOOL ()(void const*)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *std::list<int>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        CFTypeID v5 = (uint64_t *)v2[1];
        operator delete(v2);
        uint64_t v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void *CDelaunayTriangles3D::check_avail_vertices(void *result, unint64_t a2, int a3)
{
  uint64_t v4 = result;
  int v5 = 0;
  int v6 = 0;
  int v7 = 0;
  unint64_t v8 = HIDWORD(a2);
  int v9 = result;
  while (1)
  {
    int v9 = (void *)v9[1];
    if (v9 == result) {
      break;
    }
    int v10 = *((_DWORD *)v9 + 4);
    if (v10 == a2 || *((_DWORD *)v9 + 5) == a2) {
      int v7 = 1;
    }
    if (v10 == HIDWORD(a2) || *((_DWORD *)v9 + 5) == HIDWORD(a2)) {
      int v5 = 1;
    }
    if (v10 == a3 || *((_DWORD *)v9 + 5) == a3) {
      int v6 = 1;
    }
    if (v7 && v5 && v6) {
      return result;
    }
  }
  if (v7)
  {
    if (v5) {
      goto LABEL_18;
    }
LABEL_21:
    CFPropertyListRef result = std::list<int>::remove(v4 + 3, v8);
    if (v6) {
      return result;
    }
    goto LABEL_22;
  }
  CFPropertyListRef result = std::list<int>::remove(result + 3, a2);
  if (!v5) {
    goto LABEL_21;
  }
LABEL_18:
  if (v6) {
    return result;
  }
LABEL_22:

  return std::list<int>::remove(v4 + 3, a3);
}

void *std::list<int>::remove(void *result, int a2)
{
  uint64_t v19 = &v19;
  std::vector<char> __p = &v19;
  uint64_t v2 = (void *)result[1];
  if (v2 == result) {
    return result;
  }
  uint64_t v21 = 0;
  if (&v19 == result)
  {
    while (1)
    {
      uint64_t v12 = (void *)v2[1];
      if (*((_DWORD *)v2 + 4) == a2) {
        break;
      }
LABEL_19:
      uint64_t v2 = v12;
      if (v12 == result) {
        return result;
      }
    }
    if (v12 == result)
    {
      BOOL v13 = 1;
    }
    else
    {
      if (*((_DWORD *)v12 + 4) != a2)
      {
LABEL_25:
        BOOL v13 = 0;
        if (v2 == v12)
        {
LABEL_30:
          if (!v13) {
            uint64_t v12 = (void *)v12[1];
          }
          goto LABEL_19;
        }
LABEL_29:
        uint64_t v14 = *v12;
        uint64_t v15 = *v2;
        *(void *)(v15 + 8) = *(void *)(*v12 + 8);
        **(void **)(v14 + 8) = v15;
        uint64_t v16 = *result;
        *(void *)(v16 + 8) = v2;
        void *v2 = v16;
        *CFPropertyListRef result = v14;
        *(void *)(v14 + 8) = result;
        goto LABEL_30;
      }
      while (1)
      {
        uint64_t v12 = (void *)v12[1];
        BOOL v13 = v12 == result;
        if (v12 == result) {
          break;
        }
        if (*((_DWORD *)v12 + 4) != a2) {
          goto LABEL_25;
        }
      }
    }
    uint64_t v12 = result;
    if (v2 == result) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  uint64_t v3 = 0;
  uint64_t v4 = &v19;
  do
  {
    int v5 = (void *)v2[1];
    if (*((_DWORD *)v2 + 4) == a2)
    {
      if (v5 == result)
      {
LABEL_9:
        BOOL v6 = 1;
        int v5 = result;
      }
      else
      {
        while (1)
        {
          BOOL v6 = *((_DWORD *)v5 + 4) == a2;
          if (*((_DWORD *)v5 + 4) != a2) {
            break;
          }
          int v5 = (void *)v5[1];
          if (v5 == result) {
            goto LABEL_9;
          }
        }
      }
      if (v2 != v5)
      {
        uint64_t v4 = (void *)*v5;
        if ((void *)*v5 == v2)
        {
          uint64_t v9 = 1;
        }
        else
        {
          uint64_t v7 = -1;
          unint64_t v8 = v2;
          do
          {
            unint64_t v8 = (void *)v8[1];
            ++v7;
          }
          while (v8 != v4);
          uint64_t v9 = v7 + 2;
        }
        result[2] -= v9;
        v3 += v9;
        uint64_t v10 = *v2;
        *(void *)(v10 + 8) = v4[1];
        *(void *)v4[1] = v10;
        unint64_t v11 = v19;
        v19[1] = v2;
        void *v2 = v11;
        uint64_t v19 = v4;
        v4[1] = &v19;
      }
      if (!v6) {
        int v5 = (void *)v5[1];
      }
    }
    uint64_t v2 = v5;
  }
  while (v5 != result);
  if (v3)
  {
    CFPropertyListRef result = __p;
    uint64_t v17 = *(void *)__p;
    *(void *)(v17 + 8) = v4[1];
    *(void *)v4[1] = v17;
    uint64_t v21 = 0;
    if (result != &v19)
    {
      do
      {
        uint64_t v18 = (void *)result[1];
        operator delete(result);
        CFPropertyListRef result = v18;
      }
      while (v18 != &v19);
    }
  }
  return result;
}

void *std::list<std::array<int,2ul>>::remove(void *result, void *a2)
{
  uint64_t v19 = &v19;
  std::vector<char> __p = &v19;
  uint64_t v21 = 0;
  uint64_t v2 = (void *)result[1];
  if (v2 != result)
  {
    if (&v19 == result)
    {
      do
      {
        uint64_t v12 = (void *)v2[1];
        if (v2[2] == *a2)
        {
          while (v12 != result)
          {
            BOOL v13 = v12[2] == *a2;
            if (v12[2] != *a2)
            {
              if (v2 == v12) {
                goto LABEL_29;
              }
              goto LABEL_28;
            }
            uint64_t v12 = (void *)v12[1];
          }
          BOOL v13 = 1;
          uint64_t v12 = result;
          if (v2 != result)
          {
LABEL_28:
            uint64_t v14 = *v12;
            uint64_t v15 = *v2;
            *(void *)(v15 + 8) = *(void *)(*v12 + 8);
            **(void **)(v14 + 8) = v15;
            uint64_t v16 = *result;
            *(void *)(v16 + 8) = v2;
            void *v2 = v16;
            *CFPropertyListRef result = v14;
            *(void *)(v14 + 8) = result;
          }
LABEL_29:
          if (!v13) {
            uint64_t v12 = (void *)v12[1];
          }
        }
        uint64_t v2 = v12;
      }
      while (v12 != result);
    }
    else
    {
      uint64_t v3 = 0;
      uint64_t v4 = &v19;
      do
      {
        int v5 = (void *)v2[1];
        if (v2[2] == *a2)
        {
          while (1)
          {
            if (v5 == result)
            {
              BOOL v6 = 1;
              int v5 = result;
              if (v2 == result) {
                goto LABEL_11;
              }
              goto LABEL_14;
            }
            BOOL v6 = v5[2] == *a2;
            if (v5[2] != *a2) {
              break;
            }
            int v5 = (void *)v5[1];
          }
          if (v2 == v5)
          {
LABEL_11:
            if (v6) {
              goto LABEL_4;
            }
            goto LABEL_20;
          }
LABEL_14:
          uint64_t v4 = (void *)*v5;
          if ((void *)*v5 == v2)
          {
            uint64_t v9 = 1;
          }
          else
          {
            uint64_t v7 = -1;
            unint64_t v8 = v2;
            do
            {
              unint64_t v8 = (void *)v8[1];
              ++v7;
            }
            while (v8 != v4);
            uint64_t v9 = v7 + 2;
          }
          result[2] -= v9;
          v3 += v9;
          uint64_t v21 = v3;
          uint64_t v10 = *v2;
          *(void *)(v10 + 8) = v4[1];
          *(void *)v4[1] = v10;
          unint64_t v11 = v19;
          v19[1] = v2;
          void *v2 = v11;
          uint64_t v19 = v4;
          v4[1] = &v19;
          if (!v6) {
LABEL_20:
          }
            int v5 = (void *)v5[1];
        }
LABEL_4:
        uint64_t v2 = v5;
      }
      while (v5 != result);
      if (v3)
      {
        CFPropertyListRef result = __p;
        uint64_t v17 = *(void *)__p;
        *(void *)(v17 + 8) = v4[1];
        *(void *)v4[1] = v17;
        uint64_t v21 = 0;
        if (result != &v19)
        {
          do
          {
            uint64_t v18 = (void *)result[1];
            operator delete(result);
            CFPropertyListRef result = v18;
          }
          while (v18 != &v19);
        }
      }
    }
  }
  return result;
}

uint64_t CDelaunayTriangles3D::find_one_delaunay3(CDelaunayTriangles3D *this, const double *a2, const double *a3, const double *a4, int *a5, int a6)
{
  uint64_t v6 = *((void *)this + 5);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  if (v6 != 1)
  {
    BOOL v13 = (char *)this + 24;
    uint64_t v14 = (CDelaunayTriangles3D *)*((void *)this + 4);
    if (v14 != (CDelaunayTriangles3D *)((char *)this + 24))
    {
      int v15 = 0;
      uint64_t v16 = *((void *)this + 4);
      do
      {
        uint64_t result = *(unsigned int *)(v16 + 16);
        if (result != a5 && result != a6)
        {
          v18.f64[0] = a2[(int)a5];
          double v19 = a2[a6];
          uint64_t v20 = (int)result;
          double v21 = a2[v20];
          v22.f64[0] = a3[(int)a5];
          double v23 = a3[a6];
          double v24 = a3[v20];
          v25.f64[0] = a4[(int)a5];
          double v26 = a4[a6];
          double v27 = a4[v20];
          if (-(v23 * v21 - v24 * v19) * v25.f64[0]
             + -(v26 * v24 - v27 * v23) * v18.f64[0]
             + -(v27 * v19 - v26 * v21) * v22.f64[0] > 0.0)
          {
            v28.f64[0] = v18.f64[0] * v18.f64[0] + v22.f64[0] * v22.f64[0] + v25.f64[0] * v25.f64[0];
            v28.f64[1] = v19 * v19 + v23 * v23 + v26 * v26;
            v18.f64[1] = a2[a6];
            v22.f64[1] = a3[a6];
            v25.f64[1] = a4[a6];
            int v29 = v15;
            int64x2_t v30 = v14;
            while (1)
            {
              if (v29)
              {
                int v31 = *((_DWORD *)v30 + 4);
                if (v31 != a5 && v31 != a6)
                {
                  uint64_t v33 = v31;
                  v34.f64[0] = v21 * v21 + v24 * v24 + v27 * v27;
                  v34.f64[1] = a2[v33] * a2[v33] + a3[v33] * a3[v33] + a4[v33] * a4[v33];
                  v35.f64[0] = v21;
                  v35.f64[1] = a2[v33];
                  *(double *)v36.i64 = v24;
                  *(double *)&v36.i64[1] = a3[v33];
                  *(double *)v37.i64 = v27;
                  *(double *)&v37.i64[1] = a4[v33];
                  float64x2_t v38 = (float64x2_t)vextq_s8(v36, (int8x16_t)v22, 8uLL);
                  float64x2_t v39 = (float64x2_t)vextq_s8((int8x16_t)v22, v36, 8uLL);
                  float64x2_t v40 = (float64x2_t)vextq_s8(v37, (int8x16_t)v25, 8uLL);
                  float64x2_t v41 = (float64x2_t)vextq_s8((int8x16_t)v25, v37, 8uLL);
                  float64x2_t v42 = vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v39, v40)), v41, v38), v35);
                  float64x2_t v43 = (float64x2_t)vextq_s8((int8x16_t)v35, (int8x16_t)v18, 8uLL);
                  float64x2_t v44 = (float64x2_t)vextq_s8((int8x16_t)v18, (int8x16_t)v35, 8uLL);
                  float64x2_t v45 = vmlaq_f64(vmlaq_f64(v42, v44, vmlaq_f64(vnegq_f64(vmulq_f64(v38, (float64x2_t)v37)), v40, (float64x2_t)v36)), v43, vmlaq_f64(vnegq_f64(vmulq_f64((float64x2_t)v36, v41)), (float64x2_t)v37, v39));
                  int64x2_t v46 = (int64x2_t)vmulq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v38, v41)), v40, v39), v18), v43, vmlaq_f64(vnegq_f64(vmulq_f64(v39, v25)), v41, v22)), v44, vmlaq_f64(vnegq_f64(vmulq_f64(v22, v40)), v25, v38)), v34);
                  int64x2_t v47 = (int64x2_t)vmulq_f64(v45, v28);
                  if (vaddvq_f64(vsubq_f64((float64x2_t)vzip1q_s64(v47, v46), (float64x2_t)vzip2q_s64(v47, v46))) > 1.0e-13) {
                    break;
                  }
                }
              }
              int64x2_t v30 = (CDelaunayTriangles3D *)*((void *)v30 + 1);
              --v29;
              if (v30 == (CDelaunayTriangles3D *)v13) {
                return result;
              }
            }
          }
        }
        uint64_t v16 = *(void *)(v16 + 8);
        ++v15;
      }
      while ((char *)v16 != v13);
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = *(_DWORD *)(*((void *)this + 4) + 16);
  if (v7 == a5 || v7 == a6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = (int)a5;
  uint64_t v10 = a6;
  uint64_t v11 = (int)v7;
  if (-(a3[v10] * a2[v11] - a3[v11] * a2[v10]) * a4[v9]
     + -(a4[v10] * a3[v11] - a4[v11] * a3[v10]) * a2[v9]
     + -(a4[v11] * a2[v10] - a4[v10] * a2[v11]) * a3[v9] <= 0.0)
    return 0xFFFFFFFFLL;
  else {
    return v7;
  }
}

uint64_t CDelaunayTriangles3D::find_subtriangle_containment(unint64_t this, double a2, double a3, double a4)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if ((this & 0x8000000000000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (a3 <= -0.00000011920929) {
    int v4 = 4 * (a2 > -0.00000011920929);
  }
  else {
    int v4 = (4 * (a2 > -0.00000011920929)) | 2;
  }
  uint64_t v5 = v4 | (a4 > -0.00000011920929);
  if (this)
  {
    uint64_t v5 = (v5 << (2 * this));
    double v6 = fabs(a4);
    double v7 = fabs(a3);
    double v8 = fabs(a2);
    uint64_t v9 = (char *)(this + 1);
    char v10 = 2 * this - 2;
    uint64_t v11 = MEMORY[0x263EF8438];
    do
    {
      double v12 = v8 - (v6 + v7);
      double v13 = v7 + v7;
      double v14 = v6 + v6;
      double v15 = fmin(v6 + v6, fmin(v7 + v7, v12));
      double v16 = fmin(v6 - (v7 + v8), fmin(v7 + v7, v8 + v8));
      BOOL v17 = v15 < v16;
      BOOL v18 = v15 < v16;
      double v29 = v15;
      double v30 = v16;
      double v19 = fmin(v6 + v6, fmin(v7 - (v8 + v6), v8 + v8));
      double v20 = fmin(v7 + v8 - v6, fmin(v8 - v7 + v6, v6 + v7 - v8));
      double v31 = v19;
      double v32 = v20;
      double v21 = fmax(v15, v16);
      uint64_t v22 = 8 * v18;
      if (v17) {
        double v23 = &v30;
      }
      else {
        double v23 = &v29;
      }
      double v24 = fmax(v21, v19);
      if (v21 < v19)
      {
        uint64_t v22 = 16;
        double v23 = &v31;
      }
      if (v24 >= v20) {
        uint64_t v25 = v22;
      }
      else {
        uint64_t v25 = 24;
      }
      if (v24 >= v20) {
        double v26 = v23;
      }
      else {
        double v26 = &v32;
      }
      double v27 = *(double *)((char *)&v29 + v25);
      if (v27 <= -0.00000011920929)
      {
LABEL_22:
        if (v27 <= -0.0000011920929)
        {
LABEL_25:
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            float64x2_t v34 = "DelaunayTriangles3D.cpp";
            __int16 v35 = 1024;
            int v36 = 476;
            __int16 v37 = 2080;
            float64x2_t v38 = "find_subtriangle_containment";
            __int16 v39 = 1024;
            int v40 = 476;
            _os_log_impl(&dword_21B4DD000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: subtriangle still not found in computing rank with relaxed test!", buf, 0x22u);
          }
          double v12 = v8;
          double v13 = v7;
          double v14 = v6;
        }
        else
        {
          switch(v26 - &v29)
          {
            case 0:
              break;
            case 1:
              goto LABEL_24;
            case 2:
              goto LABEL_27;
            case 3:
              goto LABEL_28;
            default:
              goto LABEL_25;
          }
        }
      }
      else
      {
        switch(v26 - &v29)
        {
          case 0:
            break;
          case 1:
LABEL_24:
            uint64_t v5 = ((1 << v10) + v5);
            double v12 = v8 + v8;
            double v14 = v6 - (v7 + v8);
            break;
          case 2:
LABEL_27:
            uint64_t v5 = ((2 << v10) + v5);
            double v12 = v8 + v8;
            double v13 = v7 - (v8 + v6);
            break;
          case 3:
LABEL_28:
            uint64_t v5 = ((3 << v10) + v5);
            double v12 = v6 + v7 - v8;
            double v13 = v8 - v7 + v6;
            double v14 = v7 + v8 - v6;
            break;
          default:
            goto LABEL_22;
        }
      }
      --v9;
      v10 -= 2;
      double v6 = v14;
      double v7 = v13;
      double v8 = v12;
    }
    while ((unint64_t)v9 > 1);
  }
  return v5;
}

uint64_t std::list<int>::__sort<std::__less<void,void>>(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 < 2) {
    return result;
  }
  if (a3 == 2)
  {
    int v4 = *(uint64_t **)a2;
    if (*(_DWORD *)(*(void *)a2 + 16) < *(_DWORD *)(result + 16))
    {
      uint64_t v5 = *v4;
      *(void *)(v5 + 8) = v4[1];
      *(void *)v4[1] = v5;
      uint64_t v6 = *(void *)result;
      *(void *)(v6 + 8) = v4;
      *int v4 = v6;
      *(void *)uint64_t result = v4;
      v4[1] = result;
      return (uint64_t)v4;
    }
    return result;
  }
  unint64_t v8 = a3 >> 1;
  unint64_t v9 = (a3 >> 1) + 1;
  uint64_t v10 = result;
  do
  {
    uint64_t v10 = *(void *)(v10 + 8);
    --v9;
  }
  while (v9 > 1);
  uint64_t v11 = std::list<int>::__sort<std::__less<void,void>>(result, v10, a3 >> 1);
  uint64_t result = std::list<int>::__sort<std::__less<void,void>>(v10, a2, a3 - v8);
  int v12 = *(_DWORD *)(v11 + 16);
  if (*(_DWORD *)(result + 16) >= v12)
  {
    double v16 = *(uint64_t **)(v11 + 8);
    uint64_t v13 = result;
    uint64_t result = v11;
    if (v16 == (uint64_t *)v13) {
      return result;
    }
    goto LABEL_15;
  }
  uint64_t v13 = *(void *)(result + 8);
  if (v13 == a2)
  {
LABEL_11:
    uint64_t v13 = a2;
  }
  else
  {
    while (*(_DWORD *)(v13 + 16) < v12)
    {
      uint64_t v13 = *(void *)(v13 + 8);
      if (v13 == a2) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v14 = *(void *)v13;
  uint64_t v15 = *(void *)result;
  *(void *)(v15 + 8) = *(void *)(*(void *)v13 + 8);
  **(void **)(v14 + 8) = v15;
  uint64_t v17 = *(void *)v11;
  double v16 = *(uint64_t **)(v11 + 8);
  *(void *)(v17 + 8) = result;
  *(void *)uint64_t result = v17;
  *(void *)uint64_t v11 = v14;
  *(void *)(v14 + 8) = v11;
  if (v16 != (uint64_t *)v13)
  {
LABEL_15:
    if (v13 != a2)
    {
      uint64_t v18 = v13;
      do
      {
        int v19 = *((_DWORD *)v16 + 4);
        if (*(_DWORD *)(v13 + 16) >= v19)
        {
          double v16 = (uint64_t *)v16[1];
          if (v16 == (uint64_t *)v18) {
            return result;
          }
        }
        else
        {
          uint64_t v20 = *(void *)(v13 + 8);
          if (v20 == a2)
          {
LABEL_21:
            uint64_t v20 = a2;
          }
          else
          {
            while (*(_DWORD *)(v20 + 16) < v19)
            {
              uint64_t v20 = *(void *)(v20 + 8);
              if (v20 == a2) {
                goto LABEL_21;
              }
            }
          }
          uint64_t v21 = *(void *)v20;
          uint64_t v22 = *(void *)v13;
          *(void *)(v22 + 8) = *(void *)(*(void *)v20 + 8);
          **(void **)(v21 + 8) = v22;
          if (v18 == v13) {
            uint64_t v18 = v20;
          }
          uint64_t v24 = *v16;
          double v23 = (uint64_t *)v16[1];
          *(void *)(v24 + 8) = v13;
          *(void *)uint64_t v13 = v24;
          *double v16 = v21;
          *(void *)(v21 + 8) = v16;
          double v16 = v23;
          uint64_t v13 = v20;
          if (v23 == (uint64_t *)v18) {
            return result;
          }
        }
      }
      while (v13 != a2);
    }
  }
  return result;
}

uint64_t VBAP::initialize(uint64_t a1, uint64_t *a2, uint64_t *a3, char **a4, uint64_t *a5)
{
  uint64_t v797 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(char **)(a1 + 8);
  *(void *)(a1 + 16) = v5;
  unint64_t v6 = *(unsigned int *)(a1 + 300);
  if (v6)
  {
    size_t v8 = 4 * v6;
    v762 = operator new(4 * v6);
    bzero(v762, v8);
    v774 = operator new(v8);
    bzero(v774, v8);
    v772 = operator new(v8);
    bzero(v772, v8);
    unint64_t v9 = 0;
    uint64_t v10 = *a2;
    uint64_t v11 = *a3;
    while (1)
    {
      int v21 = *(_DWORD *)(v10 + 4 * v9);
      int v22 = *(_DWORD *)(v11 + 4 * v9);
      unint64_t v23 = *(void *)(a1 + 24);
      if ((unint64_t)v5 >= v23) {
        break;
      }
      *(_DWORD *)uint64_t v5 = v21;
      *((_DWORD *)v5 + 1) = v22;
      v5 += 8;
LABEL_4:
      *(void *)(a1 + 16) = v5;
      uint64_t v10 = *a2;
      uint64_t v11 = *a3;
      uint64_t v12 = *(void *)(a1 + 56);
      uint64_t v13 = (float *)(v12 + 4 * (3 * v9));
      double v14 = *(float *)(*a2 + 4 * v9) * 0.0174532925;
      __double2 v15 = __sincos_stret(*(float *)(*a3 + 4 * v9) * 0.0174532925);
      __double2 v16 = __sincos_stret(v14);
      float v17 = v15.__cosval * v16.__cosval;
      float v18 = v15.__cosval * v16.__sinval;
      *uint64_t v13 = v17;
      v13[1] = v18;
      float sinval = v15.__sinval;
      float64x2_t v13[2] = sinval;
      uint64_t v20 = (VBAP *)v762;
      *((float *)v762 + v9) = v17;
      *((_DWORD *)v774 + v9) = *(_DWORD *)(v12 + 4 * (3 * v9 + 1));
      *((_DWORD *)v772 + v9) = *(_DWORD *)(v12 + 4 * (3 * v9 + 2));
      ++v9;
      unint64_t v6 = *(unsigned int *)(a1 + 300);
      if (v9 >= v6)
      {
        uint64_t v41 = (const float *)v772;
        int v40 = (const float *)v774;
        goto LABEL_33;
      }
    }
    uint64_t v24 = *(char **)(a1 + 8);
    uint64_t v25 = (v5 - v24) >> 3;
    unint64_t v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 61) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v27 = v23 - (void)v24;
    if (v27 >> 2 > v26) {
      unint64_t v26 = v27 >> 2;
    }
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v28 = v26;
    }
    if (v28)
    {
      if (v28 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      double v29 = operator new(8 * v28);
    }
    else
    {
      double v29 = 0;
    }
    double v30 = &v29[8 * v25];
    *double v30 = v21;
    v30[1] = v22;
    if (v5 == v24)
    {
      uint64_t v24 = v5;
      uint64_t v33 = &v29[8 * v25];
      goto LABEL_22;
    }
    unint64_t v31 = v5 - 8 - v24;
    if (v31 < 0x168
      || &v29[v5 - v24 - 8 - (v31 & 0xFFFFFFFFFFFFFFF8)] > &v29[v5 - v24 - 8]
      || &v5[-(v31 & 0xFFFFFFFFFFFFFFF8) - 8] > v5 - 8
      || (unint64_t)(v24 - v29) < 0x20)
    {
      double v32 = v5;
      uint64_t v33 = &v29[8 * v25];
    }
    else
    {
      uint64_t v35 = (v31 >> 3) + 1;
      double v32 = &v5[-8 * (v35 & 0x3FFFFFFFFFFFFFFCLL)];
      int v36 = &v29[8 * v25 - 16];
      __int16 v37 = v5 - 16;
      uint64_t v38 = v35 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v39 = *(_OWORD *)v37;
        *(v36 - 1) = *((_OWORD *)v37 - 1);
        *int v36 = v39;
        v36 -= 2;
        v37 -= 32;
        v38 -= 4;
      }
      while (v38);
      uint64_t v33 = (char *)&v30[-2 * (v35 & 0x3FFFFFFFFFFFFFFCLL)];
      if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_22;
      }
    }
    do
    {
      uint64_t v34 = *((void *)v32 - 1);
      v32 -= 8;
      *((void *)v33 - 1) = v34;
      v33 -= 8;
    }
    while (v32 != v24);
    uint64_t v24 = *(char **)(a1 + 8);
LABEL_22:
    uint64_t v5 = (char *)(v30 + 2);
    *(void *)(a1 + 8) = v33;
    *(void *)(a1 + 16) = v30 + 2;
    *(void *)(a1 + 24) = &v29[8 * v28];
    if (v24) {
      operator delete(v24);
    }
    goto LABEL_4;
  }
  uint64_t v41 = 0;
  uint64_t v20 = 0;
  int v40 = 0;
LABEL_33:
  v773 = (float *)v41;
  v775 = (float *)v40;
  if (VBAP::find_duplicate_vertex(v20, v40, v41, (const float *)v6))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "VBAP.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 112;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = "initialize";
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 112;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Duplicate vertices were found",
        buf,
        0x22u);
    }
    uint64_t v42 = 4294967246;
    goto LABEL_828;
  }
  uint64_t v43 = a1;
  if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 16)
  {
    __C.i32[0] = 0;
    vDSP_distancesq(*(const float **)(a1 + 56), 1, (const float *)(*(void *)(a1 + 56) + 12), 1, (float *)&__C, 3uLL);
    if (fabsf(__C.f32[0] + -4.0) < 0.00001)
    {
      if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "VBAP.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 121;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = "initialize";
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 121;
        _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_DEFAULT, "%25s:%-5d CADSPUtility:%s:%d: Diametrically opposed speakers; No need to generate convex hull",
          buf,
          0x22u);
      }
      uint64_t v42 = 0;
      *(unsigned char *)(a1 + 314) = 1;
      goto LABEL_828;
    }
    uint64_t v43 = a1;
    *(unsigned char *)(a1 + 314) = 0;
  }
  vDSP_Length v44 = *(unsigned int *)(v43 + 300);
  if (v44 == 1)
  {
    *(_WORD *)(v43 + 312) = 1;
    uint64_t v45 = *(void *)(v43 + 80);
    if (*(void *)(v43 + 88) != v45) {
      *(void *)(v43 + 88) = v45;
    }
    goto LABEL_827;
  }
  int v785 = 0;
  uint64_t __B = 0;
  vDSP_meanv(*(const float **)(v43 + 56), 3, (float *)&__B, v44);
  vDSP_meanv((const float *)(*(void *)(v43 + 56) + 4), 3, (float *)&__B + 1, *(unsigned int *)(v43 + 300));
  vDSP_meanv((const float *)(*(void *)(v43 + 56) + 8), 3, (float *)&v785, *(unsigned int *)(v43 + 300));
  uint64_t v53 = *(unsigned int *)(v43 + 300);
  if (v53)
  {
    size_t v54 = 4 * (3 * v53);
    float v55 = operator new(v54);
    bzero(v55, v54);
    size_t v56 = 8 * v53;
    uint64_t v57 = operator new(8 * v53);
    bzero(v57, v56);
    v770 = (float64_t *)v57;
    v759 = (char *)operator new(v56);
    bzero(v759, v56);
    uint64_t v58 = (uint64_t)v55 + v54;
    v757 = (char *)operator new(v56);
    bzero(v757, v56);
    unint64_t v59 = 0;
    uint64_t v60 = *(void *)(a1 + 56);
    unsigned int v61 = 2;
    do
    {
      vDSP_vsub((const float *)&__B, 1, (const float *)(v60 + 4 * (v61 - 2)), 1, (float *)v55 + v61 - 2, 1, 3uLL);
      uint64_t v60 = *(void *)(a1 + 56);
      uint64_t v62 = 8 * v59;
      v770[(unint64_t)v62 / 8] = *(float *)(v60 + 4 * (v61 - 2));
      *(double *)&v759[v62] = *(float *)(v60 + 4 * (v61 - 1));
      v46.f64[0] = *(float *)(v60 + 4 * v61);
      *(float64_t *)&v757[v62] = v46.f64[0];
      ++v59;
      unint64_t v63 = *(unsigned int *)(a1 + 300);
      v61 += 3;
    }
    while (v59 < v63);
    if (v63 >= 4)
    {
      uint64_t v68 = 0;
      v48.n128_u64[0] = 0x3FA999999999999ALL;
      int v65 = v770;
      uint64_t v67 = v757;
      uint64_t v66 = v759;
      while (2)
      {
        for (uint64_t i = 0; i != v63; ++i)
        {
          if (i != v68)
          {
            uint64_t v70 = 0;
            while (1)
            {
              if (v68 != v70 && i != v70)
              {
                v46.f64[0] = v770[v68];
                v46.f64[1] = *(float64_t *)&v759[8 * v68];
                v47.i64[0] = *(void *)&v757[8 * v68];
                v71.f64[0] = v770[i];
                v71.f64[1] = *(float64_t *)&v759[8 * i];
                v50.f64[0] = *(float64_t *)&v757[8 * i];
                v72.f64[0] = v770[v70];
                v72.f64[1] = *(float64_t *)&v759[8 * v70];
                v52.f64[0] = *(float64_t *)&v757[8 * v70];
                float64x2_t v73 = vsubq_f64(v72, v46);
                float64x2_t v74 = vsubq_f64(v52, (float64x2_t)v47);
                float64x2_t v75 = vsubq_f64(v71, v46);
                float64x2_t v76 = vsubq_f64(v50, (float64x2_t)v47);
                float64x2_t v51 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v74, v75, 1)), v76, v73, 1);
                v76.f64[1] = v75.f64[0];
                v74.f64[1] = v73.f64[0];
                float64x2_t v52 = vmlaq_f64(vnegq_f64(vmulq_f64(v73, v76)), v75, v74);
                v49.f64[0] = v51.f64[0];
                v49.f64[1] = v52.f64[0];
                float64x2_t v50 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v52, 1);
                if (vaddvq_f64(vabsq_f64(v49)) + vabsq_f64(v50).f64[0] > 0.05) {
                  break;
                }
              }
              if (v63 == ++v70) {
                goto LABEL_55;
              }
            }
            uint64_t v77 = 0;
            BOOL v64 = 0;
            v48.n128_u64[0] = 0x3F847AE147AE147BLL;
            *(void *)&v49.f64[1] = vextq_s8((int8x16_t)v49, (int8x16_t)v49, 8uLL).u64[0];
            float64x2_t v78 = (float64x2_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 8uLL);
            v52.f64[1] = v78.f64[0];
            float64x2_t v52 = vmulq_f64(v52, v52);
            float v79 = sqrt(vmulq_f64(v51, v51).f64[0] + v52.f64[0] + v52.f64[1]);
            v52.f64[0] = 1.0;
            v51.f64[0] = 1.0 / v79;
            do
            {
              if (v70 != v77 && v68 != v77 && i != v77)
              {
                v80.f64[0] = v770[v77];
                v80.f64[1] = *(float64_t *)&v759[8 * v77];
                v78.f64[0] = *(float64_t *)&v757[8 * v77];
                float64x2_t v52 = vmulq_f64(vsubq_f64(v80, v46), v49);
                float64x2_t v78 = vmulq_f64(vsubq_f64(v78, (float64x2_t)v47), v50);
                v52.f64[0] = fabs((vaddvq_f64(v52) + v78.f64[0]) * v51.f64[0]);
                if (v52.f64[0] > 0.01) {
                  break;
                }
              }
              BOOL v64 = ++v77 >= v63;
            }
            while (v63 != v77);
            goto LABEL_70;
          }
LABEL_55:
          ;
        }
        ++v68;
        BOOL v64 = 1;
        if (v68 != v63) {
          continue;
        }
        break;
      }
    }
    else
    {
      BOOL v64 = 1;
      int v65 = v770;
      uint64_t v67 = v757;
      uint64_t v66 = v759;
    }
  }
  else
  {
    LODWORD(v63) = 0;
    float v55 = 0;
    uint64_t v58 = 0;
    uint64_t v66 = 0;
    int v65 = 0;
    uint64_t v67 = 0;
    BOOL v64 = 1;
  }
LABEL_70:
  v758 = v67;
  v760 = v66;
  v771 = v65;
  *(unsigned char *)(a1 + 312) = v64;
  int v81 = !v64;
  *(unsigned char *)(a1 + 313) = !v64;
  int v82 = *(_DWORD *)a1;
  v753 = v55;
  if (v64 && v82 == 1)
  {
    *(_DWORD *)a1 = 0;
    v781 = 0;
    v782 = 0;
    uint64_t v783 = 0;
    std::vector<char> __p = 0;
    v779 = 0;
    v780 = 0;
    goto LABEL_578;
  }
  v781 = 0;
  v782 = 0;
  uint64_t v783 = 0;
  std::vector<char> __p = 0;
  v779 = 0;
  v780 = 0;
  if (v82 != 1) {
    goto LABEL_576;
  }
  uint64_t v42 = VBAP::delaunayTriangulation(a1, (const float *)v55, v58, a4, a5, v46.f64[0], v47, v48, v49.f64[0], v50, v51.f64[0], v52);
  if (v42)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "VBAP.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 163;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = "initialize";
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 163;
      long long v87 = MEMORY[0x263EF8438];
      float v88 = "%25s:%-5d CADSPUtility:%s:%d: VBAP error, Delaunay triangulation issue";
      goto LABEL_799;
    }
LABEL_800:
    char v729 = 0;
    v730 = (char *)__p;
    if (__p) {
      goto LABEL_803;
    }
    goto LABEL_810;
  }
  v776 = 0;
  v777[0] = 0;
  v777[1] = 0;
  uint64_t v90 = *(void *)(a1 + 224);
  uint64_t v89 = *(void *)(a1 + 232);
  *(_DWORD *)buf = 0;
  uint64_t v91 = v89 - v90;
  if (v91)
  {
    std::vector<float>::__append(&v776, v91 >> 2, buf);
    uint64_t v91 = (uint64_t)v776;
    uint64_t v92 = v777[0];
  }
  else
  {
    uint64_t v92 = 0;
  }
  if ((unint64_t)(v92 - v91) >= 0xC)
  {
    uint64_t v93 = *(void *)(a1 + 224);
    unsigned int v94 = 1;
    unsigned int v95 = 2;
    do
    {
      uint64_t v96 = 4 * (v95 - 2);
      unsigned int v97 = 3 * *(_DWORD *)(v93 + 4 * (v95 - 1));
      unsigned int v98 = 3 * *(_DWORD *)(v93 + 4 * v95);
      unsigned int v99 = 3 * *(_DWORD *)(v93 + v96);
      LODWORD(v83.f64[0]) = *((_DWORD *)v55 + v99);
      LODWORD(v85.f64[0]) = *((_DWORD *)v55 + v99 + 1);
      float v100 = *((float *)v55 + v97) - *(float *)v83.f64;
      float v101 = *((float *)v55 + v98) - *(float *)v83.f64;
      LODWORD(v83.f64[0]) = *((_DWORD *)v55 + v99 + 2);
      v102.f64[0] = v100;
      v84.f64[0] = (float)(*((float *)v55 + v97 + 1) - *(float *)v85.f64);
      v86.f64[0] = (float)(*((float *)v55 + v97 + 2) - *(float *)v83.f64);
      v103.f64[0] = v101;
      v85.f64[0] = (float)(*((float *)v55 + v98 + 1) - *(float *)v85.f64);
      v83.f64[0] = (float)(*((float *)v55 + v98 + 2) - *(float *)v83.f64);
      float64x2_t v104 = vmulq_f64(v85, v86);
      v86.f64[1] = v102.f64[0];
      v102.f64[1] = v84.f64[0];
      float64x2_t v105 = vmlaq_f64(vnegq_f64(v104), v84, v83);
      v83.f64[1] = v103.f64[0];
      uint64_t v106 = (float32x2_t *)(v91 + v96);
      v103.f64[1] = v85.f64[0];
      float64x2_t v107 = vmlaq_f64(vnegq_f64(vmulq_f64(v83, v102)), v86, v103);
      float64x2_t v108 = vmulq_f64(v107, v107);
      float64x2_t v83 = vmulq_f64(v105, v105);
      v105.f64[1] = v107.f64[0];
      v108.f64[0] = 1.0 / sqrt(v83.f64[0] + v108.f64[0] + v108.f64[1]);
      *uint64_t v106 = vcvt_f32_f64(vmulq_n_f64(v105, v108.f64[0]));
      *(float *)v107.f64 = vmulq_laneq_f64(v108, v107, 1).f64[0];
      BOOL v629 = ((v92 - v91) >> 2) / 3uLL > v94++;
      v95 += 3;
      v106[1].i32[0] = LODWORD(v107.f64[0]);
    }
    while (v629);
  }
  memset(buf, 0, 24);
  uint64_t v109 = *(__int32 ***)(a1 + 152);
  v747 = (void **)(a1 + 152);
  uint64_t v110 = *(__int32 ***)(a1 + 160);
  if (v110 != v109)
  {
    uint64_t v111 = *(__int32 ***)(a1 + 160);
    do
    {
      uint64_t v113 = *(v111 - 3);
      v111 -= 3;
      long long v112 = v113;
      if (v113)
      {
        *(v110 - 2) = v112;
        operator delete(v112);
      }
      uint64_t v110 = v111;
    }
    while (v111 != v109);
    uint64_t v91 = (uint64_t)v776;
    uint64_t v92 = v777[0];
  }
  *(void *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v109;
  if ((unint64_t)(v92 - v91) >= 0xC)
  {
    LODWORD(v114) = 0;
    float32x4_t v115 = (float32x4_t)vdupq_n_s32(0x47C35000u);
    *(float32x4_t *)v752 = v115;
    while (1)
    {
      uint64_t v117 = (3 * v114);
      v115.i32[0] = *(_DWORD *)(v91 + 4 * v117);
      v115.i32[1] = *(_DWORD *)(v91 + 4 * (v117 + 1));
      v115.i32[2] = *(_DWORD *)(v91 + 4 * (v117 + 2));
      float32x4_t v115 = vrndaq_f32(vmulq_f32(v115, *(float32x4_t *)v752));
      *(float32x4_t *)v763 = v115;
      uint64_t v118 = *(void *)&buf[8];
      unint64_t v119 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
      int v754 = v114;
      if (!v114)
      {
        if (*(void *)&buf[8] == *(void *)buf)
        {
          std::vector<std::vector<float>>::__append((uint64_t *)buf, 1 - v119);
        }
        else if (v119 >= 2)
        {
          uint64_t v123 = *(void *)buf + 24;
          if (*(void *)&buf[8] != *(void *)buf + 24)
          {
            uint64_t v124 = *(void *)&buf[8];
            do
            {
              std::string::size_type v126 = *(void **)(v124 - 24);
              v124 -= 24;
              int v125 = v126;
              if (v126)
              {
                *(void *)(v118 - 16) = v125;
                operator delete(v125);
              }
              uint64_t v118 = v124;
            }
            while (v124 != v123);
          }
          *(void *)&buf[8] = v123;
        }
        CFArrayRef v136 = *(char ***)buf;
        char v138 = *(char **)(*(void *)buf + 8);
        uint64_t v137 = *(char **)(*(void *)buf + 16);
        if (v138 < v137)
        {
          *(_DWORD *)char v138 = v763[0];
          uint64_t v139 = v138 + 4;
          goto LABEL_137;
        }
        CFDictionaryRef v140 = **(unsigned char ***)buf;
        uint64_t v141 = (uint64_t)&v138[-**(void **)buf];
        uint64_t v142 = v141 >> 2;
        unint64_t v143 = (v141 >> 2) + 1;
        if (v143 >> 62) {
          goto LABEL_839;
        }
        uint64_t v144 = v137 - v140;
        if (v144 >> 1 > v143) {
          unint64_t v143 = v144 >> 1;
        }
        if ((unint64_t)v144 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v145 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v145 = v143;
        }
        if (v145)
        {
          if (!(v145 >> 62))
          {
            std::string::size_type v146 = operator new(4 * v145);
            goto LABEL_128;
          }
LABEL_838:
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        std::string::size_type v146 = 0;
LABEL_128:
        vDSP_Length v147 = &v146[4 * v142];
        *(_DWORD *)vDSP_Length v147 = v763[0];
        uint64_t v139 = v147 + 4;
        if (v138 != v140)
        {
          unint64_t v148 = v138 - 4 - v140;
          if (v148 < 0x2C) {
            goto LABEL_854;
          }
          if ((unint64_t)(v138 - &v146[v141]) < 0x20) {
            goto LABEL_854;
          }
          uint64_t v149 = (v148 >> 2) + 1;
          long long v150 = &v146[4 * v142 - 16];
          vDSP_Length v151 = (long long *)(v138 - 16);
          uint64_t v152 = v149 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v153 = *v151;
            *(v150 - 1) = *(v151 - 1);
            *long long v150 = v153;
            v150 -= 2;
            v151 -= 2;
            v152 -= 8;
          }
          while (v152);
          v147 -= 4 * (v149 & 0x7FFFFFFFFFFFFFF8);
          v138 -= 4 * (v149 & 0x7FFFFFFFFFFFFFF8);
          if (v149 != (v149 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_854:
            do
            {
              int v154 = *((_DWORD *)v138 - 1);
              v138 -= 4;
              *((_DWORD *)v147 - 1) = v154;
              v147 -= 4;
            }
            while (v138 != v140);
          }
        }
        uint64_t v137 = &v146[4 * v145];
        IR::IRData *v136 = v147;
        v136[1] = v139;
        v136[2] = v137;
        if (v140)
        {
          operator delete(v140);
          uint64_t v137 = v136[2];
        }
LABEL_137:
        v136[1] = v139;
        if (v139 < v137)
        {
          *(_DWORD *)uint64_t v139 = HIDWORD(v763[0]);
          uint64_t v155 = v139 + 4;
          goto LABEL_187;
        }
        uint64_t v156 = *v136;
        uint64_t v157 = v139 - *v136;
        uint64_t v158 = v157 >> 2;
        unint64_t v159 = (v157 >> 2) + 1;
        if (v159 >> 62) {
          goto LABEL_839;
        }
        uint64_t v160 = v137 - v156;
        if (v160 >> 1 > v159) {
          unint64_t v159 = v160 >> 1;
        }
        if ((unint64_t)v160 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v161 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v161 = v159;
        }
        if (v161)
        {
          if (v161 >> 62) {
            goto LABEL_838;
          }
          CFRange v162 = operator new(4 * v161);
        }
        else
        {
          CFRange v162 = 0;
        }
        std::string v163 = &v162[4 * v158];
        *(_DWORD *)std::string v163 = HIDWORD(v763[0]);
        uint64_t v155 = v163 + 4;
        if (v139 != v156)
        {
          unint64_t v164 = v139 - 4 - v156;
          if (v164 < 0x2C)
          {
            std::string v165 = v139;
            goto LABEL_184;
          }
          if ((unint64_t)(v139 - v162 - v157) < 0x20)
          {
            std::string v165 = v139;
            goto LABEL_184;
          }
          uint64_t v192 = (v164 >> 2) + 1;
          std::string v165 = &v139[-4 * (v192 & 0x7FFFFFFFFFFFFFF8)];
          std::string v193 = &v162[4 * v158 - 16];
          std::string v194 = v139 - 16;
          uint64_t v195 = v192 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v196 = *(_OWORD *)v194;
            *(v193 - 1) = *((_OWORD *)v194 - 1);
            _OWORD *v193 = v196;
            v193 -= 2;
            v194 -= 32;
            v195 -= 8;
          }
          while (v195);
          v163 -= 4 * (v192 & 0x7FFFFFFFFFFFFFF8);
          if (v192 != (v192 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_184:
              int v197 = *((_DWORD *)v165 - 1);
              v165 -= 4;
              *((_DWORD *)v163 - 1) = v197;
              v163 -= 4;
            }
            while (v165 != v156);
          }
        }
        uint64_t v137 = &v162[4 * v161];
        IR::IRData *v136 = v163;
        v136[1] = v155;
        v136[2] = v137;
        if (v156)
        {
          operator delete(v156);
          uint64_t v137 = v136[2];
        }
LABEL_187:
        v136[1] = v155;
        if (v155 < v137)
        {
          v115.i32[3] = HIDWORD(v763[1]);
          *(_DWORD *)uint64_t v155 = v763[1];
          std::string v198 = v155 + 4;
          goto LABEL_210;
        }
        std::string v199 = *v136;
        uint64_t v200 = v155 - *v136;
        uint64_t v201 = v200 >> 2;
        unint64_t v202 = (v200 >> 2) + 1;
        if (v202 >> 62) {
LABEL_839:
        }
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        uint64_t v203 = v137 - v199;
        if (v203 >> 1 > v202) {
          unint64_t v202 = v203 >> 1;
        }
        if ((unint64_t)v203 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v204 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v204 = v202;
        }
        if (v204)
        {
          if (v204 >> 62) {
            goto LABEL_838;
          }
          std::string v205 = operator new(4 * v204);
        }
        else
        {
          std::string v205 = 0;
        }
        std::string v206 = &v205[4 * v201];
        v115.i32[3] = HIDWORD(v763[1]);
        *(_DWORD *)std::string v206 = v763[1];
        std::string v198 = v206 + 4;
        if (v155 != v199)
        {
          unint64_t v207 = v155 - 4 - v199;
          if (v207 < 0x2C)
          {
            std::string v208 = v155;
            goto LABEL_207;
          }
          if ((unint64_t)(v155 - v205 - v200) < 0x20)
          {
            std::string v208 = v155;
            goto LABEL_207;
          }
          uint64_t v209 = (v207 >> 2) + 1;
          std::string v208 = &v155[-4 * (v209 & 0x7FFFFFFFFFFFFFF8)];
          std::string v210 = (float32x4_t *)&v205[4 * v201 - 16];
          std::string v211 = (float32x4_t *)(v155 - 16);
          uint64_t v212 = v209 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            float32x4_t v115 = *v211;
            v210[-1] = v211[-1];
            float32x4_t *v210 = v115;
            v210 -= 2;
            v211 -= 2;
            v212 -= 8;
          }
          while (v212);
          v206 -= 4 * (v209 & 0x7FFFFFFFFFFFFFF8);
          if (v209 != (v209 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_207:
              int v213 = *((_DWORD *)v208 - 1);
              v208 -= 4;
              *((_DWORD *)v206 - 1) = v213;
              v206 -= 4;
            }
            while (v208 != v199);
          }
        }
        IR::IRData *v136 = v206;
        v136[1] = v198;
        v136[2] = &v205[4 * v204];
        if (v199) {
          operator delete(v199);
        }
LABEL_210:
        v136[1] = v198;
        uint64_t v215 = *(void *)(a1 + 152);
        uint64_t v214 = *(void *)(a1 + 160);
        unint64_t v216 = 0xAAAAAAAAAAAAAAABLL * ((v214 - v215) >> 3);
        if (v214 == v215)
        {
          std::vector<std::vector<unsigned int>>::__append((uint64_t)v747, 1 - v216);
        }
        else if (v216 >= 2)
        {
          uint64_t v217 = v215 + 24;
          if (v214 != v215 + 24)
          {
            uint64_t v218 = *(void *)(a1 + 160);
            do
            {
              std::string v220 = *(void **)(v218 - 24);
              v218 -= 24;
              std::string v219 = v220;
              if (v220)
              {
                *(void *)(v214 - 16) = v219;
                operator delete(v219);
              }
              uint64_t v214 = v218;
            }
            while (v218 != v217);
          }
          *(void *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v217;
        }
        uint64_t v221 = *(void *)(a1 + 224);
        std::string v222 = (int *)(v221 + 4 * v117);
        int v223 = (int *)(v221 + 4 * (v117 + 3));
        uint64_t v224 = *(void *)(a1 + 152);
        int v225 = *(char **)(v224 + 8);
        v765 = v223;
        while (2)
        {
          int v227 = *v222;
          unint64_t v228 = *(void *)(v224 + 16);
          if ((unint64_t)v225 < v228)
          {
            *(_DWORD *)int v225 = v227;
            unsigned int v226 = v225 + 4;
          }
          else
          {
            unint64_t v229 = *(char **)v224;
            uint64_t v230 = (uint64_t)&v225[-*(void *)v224];
            uint64_t v231 = v230 >> 2;
            unint64_t v232 = (v230 >> 2) + 1;
            if (v232 >> 62) {
              std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v233 = v228 - (void)v229;
            if (v233 >> 1 > v232) {
              unint64_t v232 = v233 >> 1;
            }
            if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v234 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v234 = v232;
            }
            if (v234)
            {
              if (v234 >> 62) {
                goto LABEL_838;
              }
              unsigned int v235 = operator new(4 * v234);
            }
            else
            {
              unsigned int v235 = 0;
            }
            unint64_t v236 = &v235[4 * v231];
            *unint64_t v236 = v227;
            unsigned int v226 = (char *)(v236 + 1);
            if (v225 != v229)
            {
              unint64_t v237 = v225 - 4 - v229;
              if (v237 < 0xBC)
              {
                unsigned int v238 = v225;
                goto LABEL_236;
              }
              if (&v235[v230 - 4 - (v237 & 0xFFFFFFFFFFFFFFFCLL)] > &v235[v230 - 4])
              {
                unsigned int v238 = v225;
                goto LABEL_236;
              }
              if (&v225[-(v237 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v225 - 4)
              {
                unsigned int v238 = v225;
                goto LABEL_236;
              }
              if ((unint64_t)(v225 - v235 - v230) < 0x20)
              {
                unsigned int v238 = v225;
                goto LABEL_236;
              }
              uint64_t v240 = (v237 >> 2) + 1;
              unsigned int v238 = &v225[-4 * (v240 & 0x7FFFFFFFFFFFFFF8)];
              uint64_t v241 = (float32x4_t *)&v235[4 * v231 - 16];
              float v242 = (float32x4_t *)(v225 - 16);
              uint64_t v243 = v240 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                float32x4_t v115 = *v242;
                v241[-1] = v242[-1];
                *uint64_t v241 = v115;
                v241 -= 2;
                v242 -= 2;
                v243 -= 8;
              }
              while (v243);
              v236 -= v240 & 0x7FFFFFFFFFFFFFF8;
              if (v240 != (v240 & 0x7FFFFFFFFFFFFFF8))
              {
                do
                {
LABEL_236:
                  int v239 = *((_DWORD *)v238 - 1);
                  v238 -= 4;
                  *--unint64_t v236 = v239;
                }
                while (v238 != v229);
              }
            }
            *(void *)uint64_t v224 = v236;
            *(void *)(v224 + 8) = v226;
            *(void *)(v224 + 16) = &v235[4 * v234];
            if (v229) {
              operator delete(v229);
            }
            int v223 = v765;
          }
          *(void *)(v224 + 8) = v226;
          ++v222;
          int v225 = v226;
          if (v222 == v223) {
            goto LABEL_93;
          }
          continue;
        }
      }
      if (*(void *)&buf[8] != *(void *)buf) {
        break;
      }
LABEL_93:
      unint64_t v114 = (v754 + 1);
      uint64_t v91 = (uint64_t)v776;
      if (v114 >= ((uint64_t)(v777[0] - (void)v776) >> 2) / 3uLL)
      {
        uint64_t v109 = *(__int32 ***)(a1 + 160);
        goto LABEL_444;
      }
    }
    uint64_t v120 = 0;
    unsigned int v121 = 0;
    while (1)
    {
      uint64_t v122 = *(void *)(*(void *)buf + 24 * v120);
      v115.i64[0] = *(void *)v122;
      v115.i32[2] = *(_DWORD *)(v122 + 8);
      float32x4_t v115 = (float32x4_t)vceqq_f32(v115, *(float32x4_t *)v763);
      *(int16x4_t *)v115.f32 = vmovn_s32((int32x4_t)v115);
      if (v115.i8[0] & 1) != 0 && (v115.i8[2] & 1) != 0 && (v115.i8[4]) {
        break;
      }
      if (v119 - 1 == v120)
      {
        unint64_t v135 = v121 + 2;
        if (v135 <= v119)
        {
          if (v135 < v119)
          {
            uint64_t v173 = *(void *)buf + 24 * v135;
            if (*(void *)&buf[8] != v173)
            {
              uint64_t v174 = *(void *)&buf[8];
              do
              {
                std::string v176 = *(void **)(v174 - 24);
                v174 -= 24;
                std::string v175 = v176;
                if (v176)
                {
                  *(void *)(v118 - 16) = v175;
                  operator delete(v175);
                }
                uint64_t v118 = v174;
              }
              while (v174 != v173);
            }
            *(void *)&buf[8] = v173;
          }
        }
        else
        {
          std::vector<std::vector<float>>::__append((uint64_t *)buf, v135 - v119);
        }
        unint64_t v750 = v121 + 2;
        unsigned int v745 = v121 + 1;
        uint64_t v177 = *(void *)buf + 24 * (v121 + 1);
        float v179 = (char **)(v177 + 8);
        std::string v178 = *(char **)(v177 + 8);
        std::string v181 = (char **)(v177 + 16);
        unsigned __int8 v180 = *(char **)(v177 + 16);
        if (v178 < v180)
        {
          v115.i32[3] = HIDWORD(v763[1]);
          *(_DWORD *)std::string v178 = v763[0];
          std::string v182 = v178 + 4;
          goto LABEL_309;
        }
        std::string v183 = (char **)(v177 + 8);
        __src = (char **)(v177 + 16);
        uint64_t v184 = *(void *)buf + 24 * v745;
        std::string v185 = *(char **)v177;
        uint64_t v186 = (uint64_t)&v178[-*(void *)v177];
        uint64_t v187 = v186 >> 2;
        unint64_t v188 = (v186 >> 2) + 1;
        if (v188 >> 62) {
          goto LABEL_845;
        }
        uint64_t v189 = v180 - v185;
        if (v189 >> 1 > v188) {
          unint64_t v188 = v189 >> 1;
        }
        if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v190 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v190 = v188;
        }
        if (v190)
        {
          if (!(v190 >> 62))
          {
            std::string v191 = operator new(4 * v190);
            goto LABEL_296;
          }
LABEL_842:
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        std::string v191 = 0;
LABEL_296:
        v278 = &v191[4 * v187];
        v115.i32[3] = HIDWORD(v763[1]);
        _DWORD *v278 = v763[0];
        std::string v182 = (char *)(v278 + 1);
        if (v178 == v185)
        {
          uint64_t v177 = v184;
          float v179 = v183;
        }
        else
        {
          unint64_t v279 = v178 - 4 - v185;
          if (v279 < 0x2C)
          {
            uint64_t v177 = v184;
            float v179 = v183;
            goto LABEL_306;
          }
          unint64_t v280 = v178 - &v191[v186];
          uint64_t v177 = v184;
          float v179 = v183;
          if (v280 < 0x20) {
            goto LABEL_855;
          }
          uint64_t v281 = (v279 >> 2) + 1;
          v282 = (float32x4_t *)&v191[4 * v187 - 16];
          uint64_t v283 = (float32x4_t *)(v178 - 16);
          uint64_t v284 = v281 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            float32x4_t v115 = *v283;
            v282[-1] = v283[-1];
            float32x4_t *v282 = v115;
            v282 -= 2;
            v283 -= 2;
            v284 -= 8;
          }
          while (v284);
          v278 -= v281 & 0x7FFFFFFFFFFFFFF8;
          v178 -= 4 * (v281 & 0x7FFFFFFFFFFFFFF8);
          if (v281 != (v281 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_855:
            do
            {
LABEL_306:
              int v285 = *((_DWORD *)v178 - 1);
              v178 -= 4;
              *--v278 = v285;
            }
            while (v178 != v185);
          }
        }
        *(void *)uint64_t v177 = v278;
        unsigned __int8 v180 = &v191[4 * v190];
        *float v179 = v182;
        std::string v181 = __src;
        *__src = v180;
        if (v185)
        {
          operator delete(v185);
          unsigned __int8 v180 = *__src;
        }
LABEL_309:
        *float v179 = v182;
        if (v182 < v180)
        {
          *(_DWORD *)std::string v182 = HIDWORD(v763[0]);
          uint64_t v286 = v182 + 4;
          goto LABEL_330;
        }
        uint64_t v287 = v179;
        uint64_t v288 = v181;
        uint64_t v289 = v177;
        v290 = *(char **)v177;
        uint64_t v291 = (uint64_t)&v182[-*(void *)v177];
        uint64_t v292 = v291 >> 2;
        unint64_t v293 = (v291 >> 2) + 1;
        if (v293 >> 62) {
          goto LABEL_845;
        }
        uint64_t v294 = v180 - v290;
        if (v294 >> 1 > v293) {
          unint64_t v293 = v294 >> 1;
        }
        if ((unint64_t)v294 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v295 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v295 = v293;
        }
        if (v295)
        {
          if (v295 >> 62) {
            goto LABEL_842;
          }
          unint64_t v296 = v295;
          uint64_t v297 = operator new(4 * v295);
          unint64_t v295 = v296;
        }
        else
        {
          uint64_t v297 = 0;
        }
        uint64_t v298 = &v297[4 * v292];
        *uint64_t v298 = HIDWORD(v763[0]);
        uint64_t v286 = (char *)(v298 + 1);
        if (v182 == v290)
        {
          std::string v181 = v288;
          uint64_t v177 = v289;
          float v179 = v287;
        }
        else
        {
          unint64_t v299 = v182 - 4 - v290;
          if (v299 < 0x2C || (unint64_t)(v182 - v297 - v291) < 0x20)
          {
            v300 = v182;
            std::string v181 = v288;
            uint64_t v177 = v289;
            float v179 = v287;
            goto LABEL_325;
          }
          uint64_t v324 = (v299 >> 2) + 1;
          v300 = &v182[-4 * (v324 & 0x7FFFFFFFFFFFFFF8)];
          uint64_t v325 = (float32x4_t *)&v297[4 * v292 - 16];
          v326 = (float32x4_t *)(v182 - 16);
          uint64_t v327 = v324 & 0x7FFFFFFFFFFFFFF8;
          uint64_t v177 = v289;
          do
          {
            float32x4_t v115 = *v326;
            v325[-1] = v326[-1];
            *uint64_t v325 = v115;
            v325 -= 2;
            v326 -= 2;
            v327 -= 8;
          }
          while (v327);
          v298 -= v324 & 0x7FFFFFFFFFFFFFF8;
          std::string v181 = v288;
          float v179 = v287;
          if (v324 != (v324 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_325:
              int v301 = *((_DWORD *)v300 - 1);
              v300 -= 4;
              *--uint64_t v298 = v301;
            }
            while (v300 != v290);
          }
        }
        *(void *)uint64_t v177 = v298;
        unsigned __int8 v180 = &v297[4 * v295];
        *float v179 = v286;
        void *v181 = v180;
        if (v290)
        {
          operator delete(v290);
          unsigned __int8 v180 = *v181;
        }
LABEL_330:
        *float v179 = v286;
        if (v286 < v180)
        {
          *(_DWORD *)uint64_t v286 = v763[1];
          uint64_t v302 = v286 + 4;
          goto LABEL_366;
        }
        v766 = v179;
        uint64_t v303 = v181;
        uint64_t v304 = (void *)v177;
        uint64_t v305 = *(char **)v177;
        uint64_t v306 = (uint64_t)&v286[-*(void *)v177];
        uint64_t v307 = v306 >> 2;
        unint64_t v308 = (v306 >> 2) + 1;
        if (v308 >> 62) {
LABEL_845:
        }
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        uint64_t v309 = v180 - v305;
        if (v309 >> 1 > v308) {
          unint64_t v308 = v309 >> 1;
        }
        if ((unint64_t)v309 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v310 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v310 = v308;
        }
        if (v310)
        {
          if (v310 >> 62) {
            goto LABEL_842;
          }
          uint64_t v311 = operator new(4 * v310);
        }
        else
        {
          uint64_t v311 = 0;
        }
        uint64_t v312 = &v311[4 * v307];
        *uint64_t v312 = v763[1];
        uint64_t v302 = (char *)(v312 + 1);
        if (v286 != v305)
        {
          unint64_t v313 = v286 - 4 - v305;
          if (v313 < 0x2C)
          {
            uint64_t v314 = v286;
            goto LABEL_363;
          }
          if ((unint64_t)(v286 - v311 - v306) < 0x20)
          {
            uint64_t v314 = v286;
            goto LABEL_363;
          }
          uint64_t v328 = (v313 >> 2) + 1;
          uint64_t v314 = &v286[-4 * (v328 & 0x7FFFFFFFFFFFFFF8)];
          uint64_t v329 = (float32x4_t *)&v311[4 * v307 - 16];
          uint64_t v330 = (float32x4_t *)(v286 - 16);
          uint64_t v331 = v328 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            float32x4_t v115 = *v330;
            v329[-1] = v330[-1];
            *uint64_t v329 = v115;
            v329 -= 2;
            v330 -= 2;
            v331 -= 8;
          }
          while (v331);
          v312 -= v328 & 0x7FFFFFFFFFFFFFF8;
          if (v328 != (v328 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_363:
              int v332 = *((_DWORD *)v314 - 1);
              v314 -= 4;
              *--uint64_t v312 = v332;
            }
            while (v314 != v305);
          }
        }
        *uint64_t v304 = v312;
        float v179 = v766;
        *v766 = v302;
        *uint64_t v303 = &v311[4 * v310];
        if (v305) {
          operator delete(v305);
        }
LABEL_366:
        *float v179 = v302;
        uint64_t v334 = *(void *)(a1 + 152);
        uint64_t v333 = *(void *)(a1 + 160);
        unint64_t v335 = 0xAAAAAAAAAAAAAAABLL * ((v333 - v334) >> 3);
        if (v750 <= v335)
        {
          if (v750 < v335)
          {
            uint64_t v336 = v334 + 24 * v750;
            if (v333 != v336)
            {
              uint64_t v337 = *(void *)(a1 + 160);
              do
              {
                uint64_t v339 = *(void **)(v337 - 24);
                v337 -= 24;
                uint64_t v338 = v339;
                if (v339)
                {
                  *(void *)(v333 - 16) = v338;
                  operator delete(v338);
                }
                uint64_t v333 = v337;
              }
              while (v337 != v336);
            }
            *(void *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v336;
          }
        }
        else
        {
          std::vector<std::vector<unsigned int>>::__append((uint64_t)v747, v750 - v335);
        }
        uint64_t v127 = *(void *)(a1 + 152) + 24 * v745;
        float v129 = (char **)(v127 + 8);
        uint64_t v340 = *(char **)(v127 + 8);
        uint64_t v341 = (_DWORD *)(*(void *)(a1 + 224) + 4 * v117);
        uint64_t v267 = (char **)(v127 + 16);
        uint64_t v342 = *(char **)(v127 + 16);
        int v343 = *v341;
        uint64_t v751 = v127;
        v767 = v341;
        if (v340 < v342)
        {
          *(_DWORD *)uint64_t v340 = v343;
          v344 = v340 + 4;
          goto LABEL_397;
        }
        v345 = *(char **)v127;
        uint64_t v346 = (uint64_t)&v340[-*(void *)v127];
        uint64_t v347 = v346 >> 2;
        unint64_t v348 = (v346 >> 2) + 1;
        if (v348 >> 62) {
          goto LABEL_841;
        }
        uint64_t v349 = v342 - v345;
        if (v349 >> 1 > v348) {
          unint64_t v348 = v349 >> 1;
        }
        if ((unint64_t)v349 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v350 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v350 = v348;
        }
        if (v350)
        {
          if (v350 >> 62) {
            goto LABEL_842;
          }
          uint64_t v351 = operator new(4 * v350);
          uint64_t v127 = v751;
        }
        else
        {
          uint64_t v351 = 0;
        }
        uint64_t v352 = &v351[4 * v347];
        *uint64_t v352 = v343;
        v344 = (char *)(v352 + 1);
        if (v340 != v345)
        {
          unint64_t v353 = v340 - 4 - v345;
          if (v353 < 0x2C) {
            goto LABEL_856;
          }
          if ((unint64_t)(v340 - &v351[v346]) < 0x20) {
            goto LABEL_856;
          }
          uint64_t v354 = (v353 >> 2) + 1;
          uint64_t v355 = (float32x4_t *)&v351[4 * v347 - 16];
          uint64_t v356 = (float32x4_t *)(v340 - 16);
          uint64_t v357 = v354 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            float32x4_t v115 = *v356;
            v355[-1] = v356[-1];
            *uint64_t v355 = v115;
            v355 -= 2;
            v356 -= 2;
            v357 -= 8;
          }
          while (v357);
          v352 -= v354 & 0x7FFFFFFFFFFFFFF8;
          v340 -= 4 * (v354 & 0x7FFFFFFFFFFFFFF8);
          if (v354 != (v354 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_856:
            do
            {
              int v358 = *((_DWORD *)v340 - 1);
              v340 -= 4;
              *--uint64_t v352 = v358;
            }
            while (v340 != v345);
          }
        }
        *(void *)uint64_t v127 = v352;
        uint64_t v342 = &v351[4 * v350];
        *float v129 = v344;
        *uint64_t v267 = v342;
        if (v345)
        {
          operator delete(v345);
          uint64_t v127 = v751;
          uint64_t v342 = *v267;
        }
        uint64_t v341 = v767;
LABEL_397:
        *float v129 = v344;
        int v359 = v341[1];
        if (v344 < v342)
        {
          *(_DWORD *)v344 = v359;
          v252 = v344 + 4;
          goto LABEL_421;
        }
        uint64_t v360 = *(char **)v127;
        uint64_t v361 = (uint64_t)&v344[-*(void *)v127];
        uint64_t v362 = v361 >> 2;
        unint64_t v363 = (v361 >> 2) + 1;
        if (v363 >> 62) {
          goto LABEL_841;
        }
        uint64_t v364 = v342 - v360;
        if (v364 >> 1 > v363) {
          unint64_t v363 = v364 >> 1;
        }
        if ((unint64_t)v364 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v365 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v365 = v363;
        }
        if (v365)
        {
          if (v365 >> 62) {
            goto LABEL_842;
          }
          v366 = operator new(4 * v365);
          uint64_t v127 = v751;
        }
        else
        {
          v366 = 0;
        }
        v367 = &v366[4 * v362];
        _DWORD *v367 = v359;
        v252 = (char *)(v367 + 1);
        if (v344 != v360)
        {
          unint64_t v368 = v344 - 4 - v360;
          if (v368 < 0x2C)
          {
            v369 = v344;
            goto LABEL_417;
          }
          if ((unint64_t)(v344 - v366 - v361) < 0x20)
          {
            v369 = v344;
            goto LABEL_417;
          }
          uint64_t v370 = (v368 >> 2) + 1;
          v369 = &v344[-4 * (v370 & 0x7FFFFFFFFFFFFFF8)];
          v371 = (float32x4_t *)&v366[4 * v362 - 16];
          v372 = (float32x4_t *)(v344 - 16);
          uint64_t v373 = v370 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            float32x4_t v115 = *v372;
            v371[-1] = v372[-1];
            float32x4_t *v371 = v115;
            v371 -= 2;
            v372 -= 2;
            v373 -= 8;
          }
          while (v373);
          v367 -= v370 & 0x7FFFFFFFFFFFFFF8;
          if (v370 != (v370 & 0x7FFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_417:
              int v374 = *((_DWORD *)v369 - 1);
              v369 -= 4;
              *--v367 = v374;
            }
            while (v369 != v360);
          }
        }
        *(void *)uint64_t v127 = v367;
        uint64_t v342 = &v366[4 * v365];
        *float v129 = v252;
        *uint64_t v267 = v342;
        if (v360)
        {
          operator delete(v360);
          uint64_t v127 = v751;
          uint64_t v342 = *v267;
        }
        uint64_t v341 = v767;
LABEL_421:
        *float v129 = v252;
        int v266 = v341[2];
        if (v252 >= v342)
        {
          uint64_t v268 = *(char **)v127;
          uint64_t v375 = (uint64_t)&v252[-*(void *)v127];
          uint64_t v376 = v375 >> 2;
          unint64_t v377 = (v375 >> 2) + 1;
          if (!(v377 >> 62))
          {
            uint64_t v378 = v342 - v268;
            if (v378 >> 1 > v377) {
              unint64_t v377 = v378 >> 1;
            }
            if ((unint64_t)v378 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v273 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v273 = v377;
            }
            if (v273)
            {
              if (v273 >> 62) {
                goto LABEL_842;
              }
              v274 = operator new(4 * v273);
              uint64_t v127 = v751;
            }
            else
            {
              v274 = 0;
            }
            v275 = &v274[4 * v376];
            _DWORD *v275 = v266;
            uint64_t v116 = (char *)(v275 + 1);
            if (v252 != v268)
            {
              unint64_t v379 = v252 - 4 - v268;
              if (v379 < 0x2C)
              {
                uint64_t v380 = v252;
                goto LABEL_440;
              }
              if ((unint64_t)(v252 - v274 - v375) < 0x20)
              {
                uint64_t v380 = v252;
                goto LABEL_440;
              }
              uint64_t v381 = (v379 >> 2) + 1;
              uint64_t v380 = &v252[-4 * (v381 & 0x7FFFFFFFFFFFFFF8)];
              uint64_t v382 = (float32x4_t *)&v274[4 * v376 - 16];
              uint64_t v383 = (float32x4_t *)(v252 - 16);
              uint64_t v384 = v381 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                float32x4_t v115 = *v383;
                v382[-1] = v383[-1];
                *uint64_t v382 = v115;
                v382 -= 2;
                v383 -= 2;
                v384 -= 8;
              }
              while (v384);
              v275 -= v381 & 0x7FFFFFFFFFFFFFF8;
              if (v381 != (v381 & 0x7FFFFFFFFFFFFFF8))
              {
                do
                {
LABEL_440:
                  int v385 = *((_DWORD *)v380 - 1);
                  v380 -= 4;
                  *--v275 = v385;
                }
                while (v380 != v268);
              }
            }
            goto LABEL_441;
          }
LABEL_841:
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        goto LABEL_91;
      }
      uint64_t v120 = ++v121;
      if (v119 <= v121) {
        goto LABEL_93;
      }
    }
    uint64_t v127 = *(void *)(a1 + 152) + 24 * v120;
    float v129 = (char **)(v127 + 8);
    int v128 = *(char **)(v127 + 8);
    CFDictionaryRef v130 = (int *)(*(void *)(a1 + 224) + 4 * v117);
    uint64_t v132 = (char **)(v127 + 16);
    float v131 = *(char **)(v127 + 16);
    int v133 = *v130;
    uint64_t v749 = v127;
    if (v128 >= v131)
    {
      v764 = (char **)(v127 + 16);
      std::string v166 = *(char **)v127;
      uint64_t v167 = (uint64_t)&v128[-*(void *)v127];
      uint64_t v168 = v167 >> 2;
      unint64_t v169 = (v167 >> 2) + 1;
      if (v169 >> 62) {
        goto LABEL_841;
      }
      uint64_t v170 = v131 - v166;
      if (v170 >> 1 > v169) {
        unint64_t v169 = v170 >> 1;
      }
      if ((unint64_t)v170 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v171 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v171 = v169;
      }
      if (v171)
      {
        if (v171 >> 62) {
          goto LABEL_842;
        }
        unsigned __int8 v172 = operator new(4 * v171);
        uint64_t v127 = v749;
      }
      else
      {
        unsigned __int8 v172 = 0;
      }
      vDSP_Length v244 = &v172[4 * v168];
      *vDSP_Length v244 = v133;
      long long v134 = (char *)(v244 + 1);
      if (v128 != v166)
      {
        unint64_t v245 = v128 - 4 - v166;
        if (v245 < 0x2C) {
          goto LABEL_857;
        }
        if ((unint64_t)(v128 - &v172[v167]) < 0x20) {
          goto LABEL_857;
        }
        uint64_t v246 = (v245 >> 2) + 1;
        CFArrayRef v247 = (float32x4_t *)&v172[4 * v168 - 16];
        int v248 = (float32x4_t *)(v128 - 16);
        uint64_t v249 = v246 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          float32x4_t v115 = *v248;
          v247[-1] = v248[-1];
          *CFArrayRef v247 = v115;
          v247 -= 2;
          v248 -= 2;
          v249 -= 8;
        }
        while (v249);
        v244 -= v246 & 0x7FFFFFFFFFFFFFF8;
        v128 -= 4 * (v246 & 0x7FFFFFFFFFFFFFF8);
        if (v246 != (v246 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_857:
          do
          {
            int v250 = *((_DWORD *)v128 - 1);
            v128 -= 4;
            *--vDSP_Length v244 = v250;
          }
          while (v128 != v166);
        }
      }
      *(void *)uint64_t v127 = v244;
      float v131 = &v172[4 * v171];
      *float v129 = v134;
      uint64_t v132 = v764;
      *v764 = v131;
      if (v166)
      {
        operator delete(v166);
        uint64_t v127 = v749;
        float v131 = *v764;
      }
    }
    else
    {
      *(_DWORD *)int v128 = v133;
      long long v134 = v128 + 4;
    }
    *float v129 = v134;
    int v251 = v130[1];
    if (v134 < v131)
    {
      *(_DWORD *)long long v134 = v251;
      v252 = v134 + 4;
LABEL_281:
      *float v129 = v252;
      int v266 = v130[2];
      if (v252 < v131)
      {
LABEL_91:
        *(_DWORD *)v252 = v266;
        uint64_t v116 = v252 + 4;
        goto LABEL_92;
      }
      uint64_t v267 = v132;
      uint64_t v268 = *(char **)v127;
      uint64_t v269 = (uint64_t)&v252[-*(void *)v127];
      uint64_t v270 = v269 >> 2;
      unint64_t v271 = (v269 >> 2) + 1;
      if (v271 >> 62) {
        goto LABEL_841;
      }
      uint64_t v272 = v131 - v268;
      if (v272 >> 1 > v271) {
        unint64_t v271 = v272 >> 1;
      }
      if ((unint64_t)v272 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v273 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v273 = v271;
      }
      if (v273)
      {
        if (v273 >> 62) {
          goto LABEL_842;
        }
        v274 = operator new(4 * v273);
        uint64_t v127 = v749;
      }
      else
      {
        v274 = 0;
      }
      v275 = &v274[4 * v270];
      _DWORD *v275 = v266;
      uint64_t v116 = (char *)(v275 + 1);
      if (v252 != v268)
      {
        unint64_t v276 = v252 - 4 - v268;
        if (v276 >= 0x2C)
        {
          if ((unint64_t)(v252 - v274 - v269) >= 0x20)
          {
            uint64_t v319 = (v276 >> 2) + 1;
            v277 = &v252[-4 * (v319 & 0x7FFFFFFFFFFFFFF8)];
            uint64_t v320 = (float32x4_t *)&v274[4 * v270 - 16];
            uint64_t v321 = (float32x4_t *)(v252 - 16);
            uint64_t v322 = v319 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              float32x4_t v115 = *v321;
              v320[-1] = v321[-1];
              *uint64_t v320 = v115;
              v320 -= 2;
              v321 -= 2;
              v322 -= 8;
            }
            while (v322);
            v275 -= v319 & 0x7FFFFFFFFFFFFFF8;
            if (v319 == (v319 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_441;
            }
          }
          else
          {
            v277 = v252;
          }
        }
        else
        {
          v277 = v252;
        }
        do
        {
          int v323 = *((_DWORD *)v277 - 1);
          v277 -= 4;
          *--v275 = v323;
        }
        while (v277 != v268);
      }
LABEL_441:
      *(void *)uint64_t v127 = v275;
      *float v129 = v116;
      *uint64_t v267 = &v274[4 * v273];
      if (v268) {
        operator delete(v268);
      }
LABEL_92:
      *float v129 = v116;
      goto LABEL_93;
    }
    uint64_t v253 = v132;
    uint64_t v254 = *(char **)v127;
    uint64_t v255 = (uint64_t)&v134[-*(void *)v127];
    uint64_t v256 = v255 >> 2;
    unint64_t v257 = (v255 >> 2) + 1;
    if (v257 >> 62) {
      goto LABEL_841;
    }
    uint64_t v258 = v131 - v254;
    if (v258 >> 1 > v257) {
      unint64_t v257 = v258 >> 1;
    }
    if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v259 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v259 = v257;
    }
    if (v259)
    {
      if (v259 >> 62) {
        goto LABEL_842;
      }
      unint64_t v260 = v259;
      uint64_t v261 = operator new(4 * v259);
      uint64_t v127 = v749;
      unint64_t v259 = v260;
    }
    else
    {
      uint64_t v261 = 0;
    }
    uint64_t v262 = &v261[4 * v256];
    *uint64_t v262 = v251;
    v252 = (char *)(v262 + 1);
    if (v134 == v254)
    {
      uint64_t v132 = v253;
      goto LABEL_279;
    }
    unint64_t v263 = v134 - 4 - v254;
    if (v263 >= 0x2C && (unint64_t)(v134 - v261 - v255) >= 0x20)
    {
      uint64_t v315 = (v263 >> 2) + 1;
      uint64_t v264 = &v134[-4 * (v315 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v316 = (float32x4_t *)&v261[4 * v256 - 16];
      v317 = (float32x4_t *)(v134 - 16);
      uint64_t v318 = v315 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v115 = *v317;
        v316[-1] = v317[-1];
        *uint64_t v316 = v115;
        v316 -= 2;
        v317 -= 2;
        v318 -= 8;
      }
      while (v318);
      v262 -= v315 & 0x7FFFFFFFFFFFFFF8;
      uint64_t v132 = v253;
      if (v315 == (v315 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_279:
        *(void *)uint64_t v127 = v262;
        float v131 = &v261[4 * v259];
        *float v129 = v252;
        void *v132 = v131;
        if (v254)
        {
          operator delete(v254);
          uint64_t v127 = v749;
          float v131 = *v132;
        }
        goto LABEL_281;
      }
    }
    else
    {
      uint64_t v264 = v134;
      uint64_t v132 = v253;
    }
    do
    {
      int v265 = *((_DWORD *)v264 - 1);
      v264 -= 4;
      *--uint64_t v262 = v265;
    }
    while (v264 != v254);
    goto LABEL_279;
  }
LABEL_444:
  if (*v747 != v109)
  {
    uint64_t v109 = (__int32 **)*v747;
    do
    {
      v386 = *v109;
      v387 = v109[1];
      if (*v109 != v387)
      {
        v388 = *v109;
        do
        {
          __int32 v389 = *v388++;
          v390 = wmemchr(v388, v389, v387 - v388);
          if (v390) {
            unsigned int v391 = v390;
          }
          else {
            unsigned int v391 = v387;
          }
          uint64_t v392 = v391 - v388 + 1;
          v393 = &v386[v392];
          unsigned int v394 = v393 + 1;
          if (v393 != v387 && v394 != v387)
          {
            do
            {
              if (*v394 != *v386) {
                v386[v392++] = *v394;
              }
              ++v394;
            }
            while (v394 != v387);
          }
          v387 = &v386[v392];
          v386 = v388;
        }
        while (v392 != 1);
        if (v387 != v109[1]) {
          v109[1] = v387;
        }
      }
      v109 += 3;
    }
    while (v109 != *(__int32 ***)(a1 + 160));
  }
  if (v747 != &__p)
  {
    uint64_t v396 = (uint64_t)*v747;
    unint64_t v397 = 0xAAAAAAAAAAAAAAABLL * (((char *)v109 - (unsigned char *)*v747) >> 3);
    uint64_t v398 = (uint64_t)v780;
    signed int v399 = (char *)__p;
    if (0xAAAAAAAAAAAAAAABLL * ((v780 - (unsigned char *)__p) >> 3) >= v397)
    {
      v405 = v779;
      unint64_t v406 = 0xAAAAAAAAAAAAAAABLL * ((v779 - (unsigned char *)__p) >> 3);
      if (v406 >= v397)
      {
        if ((__int32 **)v396 != v109)
        {
          do
          {
            if ((char *)v396 != v399) {
              std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v399, *(char **)v396, *(void *)(v396 + 8), (uint64_t)(*(void *)(v396 + 8) - *(void *)v396) >> 2);
            }
            v396 += 24;
            v399 += 24;
          }
          while ((__int32 **)v396 != v109);
          v405 = v779;
        }
        if (v405 != v399)
        {
          v413 = v405;
          do
          {
            v415 = (void *)*((void *)v413 - 3);
            v413 -= 24;
            uint64_t v414 = v415;
            if (v415)
            {
              *((void *)v405 - 2) = v414;
              operator delete(v414);
            }
            v405 = v413;
          }
          while (v413 != v399);
        }
        v779 = v399;
        goto LABEL_503;
      }
      if (v779 != __p)
      {
        uint64_t v407 = 8 * ((v779 - (unsigned char *)__p) >> 3);
        unsigned int v408 = (char *)*v747;
        do
        {
          if (v408 != v399) {
            std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v399, *(char **)v408, *((void *)v408 + 1), (uint64_t)(*((void *)v408 + 1) - *(void *)v408) >> 2);
          }
          v408 += 24;
          v399 += 24;
          v407 -= 24;
        }
        while (v407);
        signed int v399 = v779;
      }
      v412 = (char *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>((uint64_t)&v780, v396 + 24 * v406, (uint64_t)v109, v399);
    }
    else
    {
      if (__p)
      {
        int v400 = v779;
        v401 = __p;
        if (v779 != __p)
        {
          v402 = v779;
          do
          {
            unsigned int v404 = (void *)*((void *)v402 - 3);
            v402 -= 24;
            v403 = v404;
            if (v404)
            {
              *((void *)v400 - 2) = v403;
              operator delete(v403);
            }
            int v400 = v402;
          }
          while (v402 != v399);
          v401 = __p;
        }
        v779 = v399;
        operator delete(v401);
        uint64_t v398 = 0;
        std::vector<char> __p = 0;
        v779 = 0;
        v780 = 0;
      }
      if (v397 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_846;
      }
      unint64_t v409 = 0xAAAAAAAAAAAAAAABLL * (v398 >> 3);
      uint64_t v410 = 2 * v409;
      if (2 * v409 <= v397) {
        uint64_t v410 = v397;
      }
      unint64_t v411 = v409 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v410;
      if (v411 > 0xAAAAAAAAAAAAAAALL) {
LABEL_846:
      }
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      std::vector<char> __p = operator new(24 * v411);
      v779 = (char *)__p;
      v780 = (char *)__p + 24 * v411;
      v412 = (char *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>((uint64_t)&v780, v396, (uint64_t)v109, __p);
    }
    v779 = v412;
  }
LABEL_503:
  std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((uint64_t)&v781, *(uint64_t *)buf, *(uint64_t *)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
  LODWORD(v791) = 925353388;
  CFTypeRef v416 = (const float **)v781;
  if (v782 != v781)
  {
    unint64_t v417 = 0;
    unsigned int v418 = 1;
    do
    {
      vDSP_vsmul(v416[3 * v417], 1, (const float *)&v791, (float *)v416[3 * v417], 1, 3uLL);
      unint64_t v417 = v418;
      CFTypeRef v416 = (const float **)v781;
      ++v418;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v782 - (unsigned char *)v781) >> 3) > v417);
  }
  v420 = *(void **)(a1 + 152);
  v419 = *(void **)(a1 + 160);
  if (v420 != v419)
  {
    uint64_t v421 = *(void *)buf;
    while (1)
    {
      while (v420[1] - *v420 > 0xFuLL)
      {
        v420 += 3;
        v421 += 24;
        if (v420 == v419) {
          goto LABEL_535;
        }
      }
      if (v420 + 3 == v419) {
        break;
      }
      v422 = v420;
      do
      {
        v425 = (void *)*v422;
        if (*v422)
        {
          v422[1] = v425;
          operator delete(v425);
          v422[1] = 0;
          v422[2] = 0;
        }
        uint64_t v423 = v422 + 3;
        *(_OWORD *)v422 = *(_OWORD *)(v422 + 3);
        v422[2] = v422[5];
        v422[4] = 0;
        v422[5] = 0;
        v422[3] = 0;
        v424 = v422 + 6;
        v422 += 3;
      }
      while (v424 != v419);
      v419 = *(void **)(a1 + 160);
      if (v419 != v423) {
        goto LABEL_518;
      }
LABEL_522:
      *(void *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v423;
      uint64_t v429 = v421 + 24;
      uint64_t v430 = *(void *)&buf[8];
      if (v421 + 24 != *(void *)&buf[8])
      {
        uint64_t v431 = v421;
        do
        {
          v434 = *(void **)v431;
          if (*(void *)v431)
          {
            *(void *)(v431 + 8) = v434;
            operator delete(v434);
            *(void *)(v431 + 8) = 0;
            *(void *)(v431 + 16) = 0;
          }
          uint64_t v432 = v431 + 24;
          *(_OWORD *)uint64_t v431 = *(_OWORD *)(v431 + 24);
          *(void *)(v431 + 16) = *(void *)(v431 + 40);
          *(void *)(v431 + 32) = 0;
          *(void *)(v431 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
          *(void *)(v431 + 24) = 0;
          uint64_t v433 = v431 + 48;
          v431 += 24;
        }
        while (v433 != v430);
        uint64_t v429 = *(void *)&buf[8];
        if (*(void *)&buf[8] == v432) {
          goto LABEL_534;
        }
LABEL_530:
        uint64_t v435 = v429;
        do
        {
          char v437 = *(void **)(v435 - 24);
          v435 -= 24;
          uint64_t v436 = v437;
          if (v437)
          {
            *(void *)(v429 - 16) = v436;
            operator delete(v436);
          }
          uint64_t v429 = v435;
        }
        while (v435 != v432);
        goto LABEL_534;
      }
      uint64_t v432 = v421;
      if (v429 != v421) {
        goto LABEL_530;
      }
LABEL_534:
      *(void *)&buf[8] = v432;
      v419 = *(void **)(a1 + 160);
      if (v420 == v419)
      {
LABEL_535:
        v420 = *v747;
        goto LABEL_537;
      }
    }
    uint64_t v423 = v420;
    if (v419 == v420) {
      goto LABEL_522;
    }
LABEL_518:
    uint64_t v426 = v419;
    do
    {
      v428 = (void *)*(v426 - 3);
      v426 -= 3;
      v427 = v428;
      if (v428)
      {
        *(v419 - 2) = v427;
        operator delete(v427);
      }
      v419 = v426;
    }
    while (v426 != v423);
    goto LABEL_522;
  }
  v419 = *(void **)(a1 + 152);
LABEL_537:
  unint64_t v438 = v419 - v420;
  __C.i32[0] = 0;
  uint64_t v439 = *(void *)(a1 + 80);
  v440 = (char **)(a1 + 80);
  unint64_t v441 = (*(void *)(a1 + 88) - v439) >> 2;
  BOOL v442 = v438 >= v441;
  if (v438 <= v441)
  {
    unint64_t v444 = 0xAAAAAAAAAAAAAAABLL * v438;
    uint64_t v443 = a1;
    if (!v442) {
      *(void *)(a1 + 88) = v439 + 4 * v438;
    }
  }
  else
  {
    std::vector<float>::__append((void **)(a1 + 80), v438 - v441, &__C);
    uint64_t v443 = a1;
    v420 = *(void **)(a1 + 152);
    v419 = *(void **)(a1 + 160);
    unint64_t v444 = 0xAAAAAAAAAAAAAAABLL * (v419 - v420);
  }
  uint64_t v445 = *(void *)(v443 + 104);
  uint64_t v446 = *(void *)(v443 + 112);
  uint64_t v447 = (void **)(v443 + 104);
  __C.i32[0] = 0;
  unint64_t v448 = (v446 - v445) >> 2;
  if (v444 <= v448)
  {
    if (v444 < v448) {
      *(void *)(a1 + 112) = v445 + 4 * v444;
    }
  }
  else
  {
    std::vector<float>::__append(v447, v444 - v448, &__C);
    v420 = *(void **)(a1 + 152);
    v419 = *(void **)(a1 + 160);
  }
  v449 = v419;
  if (v419 != v420)
  {
    unint64_t v450 = 0;
    do
    {
      std::string v451 = (int **)&v420[3 * v450];
      CFTypeRef v452 = *v451;
      v453 = v451[1];
      uint64_t v454 = *v440;
      uint64_t v455 = (char *)v453 - (char *)v452;
      if (v455)
      {
        unint64_t v456 = v455 >> 2;
        uint64_t v457 = *(void *)(a1 + 56);
        float v458 = (float)v456;
        uint64_t v459 = (3 * v450);
        uint64_t v460 = (v459 + 1);
        float v461 = *(float *)&v454[4 * v459];
        float v462 = *(float *)&v454[4 * v460];
        uint64_t v463 = (v459 + 2);
        float v464 = *(float *)&v454[4 * v463];
        if (v456 <= 1) {
          unint64_t v456 = 1;
        }
        float v465 = 1.0 / v458;
        do
        {
          int v466 = *v452++;
          float v461 = v461 + (float)(*(float *)(v457 + 4 * (3 * v466)) * v465);
          *(float *)&v454[4 * v459] = v461;
          float v462 = v462 + (float)(*(float *)(v457 + 4 * (3 * v466 + 1)) * v465);
          *(float *)&v454[4 * v460] = v462;
          float v464 = v464 + (float)(*(float *)(v457 + 4 * (3 * v466 + 2)) * v465);
          *(float *)&v454[4 * v463] = v464;
          --v456;
        }
        while (v456);
      }
      else
      {
        uint64_t v459 = (3 * v450);
      }
      LODWORD(v786) = 0;
      vDSP_dotpr(*(const float **)(*(void *)buf + 24 * v450), 1, (const float *)&v454[4 * v459], 1, (float *)&v786, 3uLL);
      if (*(float *)&v786 == 0.0)
      {
        float v790 = 0.0;
        uint64_t __A = 0;
        float v788 = 0.0;
        uint64_t v787 = 0;
        float32x2_t __C = 0;
        uint64_t v794 = 0;
        int32x2_t v795 = 0;
        *((_DWORD *)*v447 + v45std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 1065353216;
        v470 = *v440;
        v471 = *(float **)(*(void *)buf + 24 * v450);
        float v472 = v471[1];
        *(float *)&uint64_t __A = *(float *)&(*v440)[4 * v459] - (float)(*v471 * 0.00001);
        *(float *)&uint64_t v787 = *(float *)&v470[4 * v459] + (float)(*v471 * 0.00001);
        uint64_t v473 = 4 * (v459 + 1);
        *((float *)&__A + 1) = *(float *)&v470[v473] - (float)(v472 * 0.00001);
        float v474 = v471[2];
        *((float *)&v787 + 1) = *(float *)&v470[v473] + (float)(v471[1] * 0.00001);
        uint64_t v475 = 4 * (v459 + 2);
        float v790 = *(float *)&v470[v475] - (float)(v474 * 0.00001);
        float v788 = *(float *)&v470[v475] + (float)(v471[2] * 0.00001);
        VBAP::lineUnitSphereIntersection((VBAP *)&__A, (const float *)&v787, (float *)&__C, v467);
        uint64_t v476 = (uint64_t)&(*v440)[4 * v459];
        v477 = (const float *)&(*v440)[4 * v459 + 4];
        v478 = (const float *)&(*v440)[4 * v459 + 8];
        float32x2_t v479 = vld1_dup_f32((const float *)v476);
        float32x2_t v480 = vsub_f32(v479, (float32x2_t)__PAIR64__(__C.u32[0], HIDWORD(v794)));
        float32x2_t v481 = vld1_dup_f32(v477);
        v482.i32[0] = vdup_lane_s32(v795, 1).u32[0];
        float64x2_t v483 = vcvtq_f64_f32(vsub_f32(v481, (float32x2_t)__PAIR64__(__C.u32[1], v795.u32[0])));
        float64x2_t v484 = vmlaq_f64(vcvtq_f64_f32(vmul_f32(v480, v480)), v483, v483);
        *(float32x2_t *)&v483.f64[0] = vld1_dup_f32(v478);
        v482.i32[1] = v794;
        float64x2_t v485 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)&v483.f64[0], v482));
        *(float32x2_t *)&v484.f64[0] = vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(vcvt_f32_f64(v484)), v485, v485));
        p_C = (float32x2_t *)((char *)&v794 + 4);
        if ((vcgt_f32(*(float32x2_t *)&v484.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v484.f64[0], 1)).u8[0] & 1) == 0) {
          p_C = &__C;
        }
        __int32 v487 = p_C[1].i32[0];
        *(float32x2_t *)uint64_t v476 = *p_C;
        *(_DWORD *)(v476 + 8) = v487;
      }
      else
      {
        __C.i32[0] = 0;
        vDSP_dotpr((const float *)&(*v440)[4 * v459], 1, (const float *)&(*v440)[4 * v459], 1, (float *)&__C, 3uLL);
        float v468 = sqrtf(__C.f32[0]);
        *((float *)*v447 + v45std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v468;
        float v469 = 1.0 / v468;
        __C.f32[0] = v469;
        if (*(float *)&v786 < 0.0) {
          __C.f32[0] = -v469;
        }
        vDSP_vsmul((const float *)&(*v440)[4 * v459], 1, (const float *)&__C, (float *)&(*v440)[4 * v459], 1, 3uLL);
      }
      ++v450;
      v420 = *(void **)(a1 + 152);
      v449 = *(void **)(a1 + 160);
    }
    while (0xAAAAAAAAAAAAAAABLL * (v449 - v420) > v450);
    v419 = *(void **)(a1 + 152);
  }
  uint64_t v488 = *(void *)buf;
  if (*(void *)buf)
  {
    uint64_t v489 = *(void *)&buf[8];
    v490 = *(void **)buf;
    if (*(void *)&buf[8] != *(void *)buf)
    {
      uint64_t v491 = *(void *)&buf[8];
      do
      {
        v493 = *(void **)(v491 - 24);
        v491 -= 24;
        v492 = v493;
        if (v493)
        {
          *(void *)(v489 - 16) = v492;
          operator delete(v492);
        }
        uint64_t v489 = v491;
      }
      while (v491 != v488);
      v490 = *(void **)buf;
    }
    *(void *)&buf[8] = v488;
    operator delete(v490);
    v419 = *(void **)(a1 + 152);
    v449 = *(void **)(a1 + 160);
  }
  if (v449 == v419)
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)buf = 0;
    std::vector<float>::assign(v440, 6uLL, buf);
  }
  if (v776)
  {
    v777[0] = v776;
    operator delete(v776);
  }
  int v82 = *(_DWORD *)a1;
LABEL_576:
  if (v82) {
    goto LABEL_711;
  }
  int v81 = *(unsigned __int8 *)(a1 + 313);
  LODWORD(v63) = *(_DWORD *)(a1 + 300);
LABEL_578:
  LODWORD(v794) = 0;
  float32x2_t __C = 0;
  LODWORD(v777[0]) = 0;
  v776 = 0;
  float v790 = 0.0;
  uint64_t __A = 0;
  float v788 = 0.0;
  uint64_t v787 = 0;
  if (v81) {
    goto LABEL_619;
  }
  *(void *)buf = 0;
  double v791 = 0.0;
  double v786 = 0.0;
  uint64_t v494 = (v63 + 1);
  if (v63 == -1)
  {
    v495 = 0;
    v496 = 0;
    v497 = 0;
    v498 = 0;
    v499 = 0;
    v500 = 0;
    uint64_t v501 = *(void *)(a1 + 56);
    uint64_t v502 = 0xFFFFFFFFLL;
    goto LABEL_585;
  }
  v499 = (char *)operator new(8 * v494);
  bzero(v499, 8 * v494);
  v498 = (char *)operator new(8 * v494);
  bzero(v498, 8 * v494);
  v500 = (char *)operator new(8 * v494);
  bzero(v500, 8 * v494);
  if (v63)
  {
    uint64_t v501 = *(void *)(a1 + 56);
    uint64_t v502 = v63;
    if (v63 < 0x10)
    {
      uint64_t v503 = 0;
LABEL_593:
      unsigned int v512 = 3 * v503;
      do
      {
        uint64_t v513 = 8 * v503;
        *(double *)&v499[v513] = *(float *)(v501 + 4 * v512);
        *(double *)&v498[v513] = *(float *)(v501 + 4 * (v512 + 1));
        *(double *)&v500[v513] = *(float *)(v501 + 4 * (v512 + 2));
        ++v503;
        v512 += 3;
      }
      while (v502 != v503);
      goto LABEL_595;
    }
    v495 = v500;
    v496 = v499;
    v497 = v498;
LABEL_585:
    uint64_t v503 = 0;
    uint64_t v504 = 3 * (v63 - 1);
    if (v504 <= 0xFFFFFFFD && (v504 & 0xFFFFFFFF00000000) == 0)
    {
      uint64_t v503 = 0;
      if ((unint64_t)(v497 - v496) >= 0x20
        && (unint64_t)(v495 - v496) >= 0x20
        && (unint64_t)(v495 - v497) >= 0x20)
      {
        uint64_t v505 = 0;
        uint64_t v506 = 0;
        uint64_t v503 = v502 & 0xFFFFFFFC;
        uint64_t v507 = v503;
        do
        {
          v508 = (const float *)(v501 + 4 * (v505 & 0xFFFFFFFC));
          float32x4x3_t v798 = vld3q_f32(v508);
          v509 = (float64x2_t *)&v499[v506];
          float64x2_t *v509 = vcvtq_f64_f32(*(float32x2_t *)v798.val[0].f32);
          v509[1] = vcvt_hight_f64_f32(v798.val[0]);
          v510 = (float64x2_t *)&v498[v506];
          float64x2_t *v510 = vcvtq_f64_f32(*(float32x2_t *)v798.val[1].f32);
          v510[1] = vcvt_hight_f64_f32(v798.val[1]);
          v511 = (float64x2_t *)&v500[v506];
          float64x2_t *v511 = vcvtq_f64_f32(*(float32x2_t *)v798.val[2].f32);
          v511[1] = vcvt_hight_f64_f32(v798.val[2]);
          v506 += 32;
          v505 += 12;
          v507 -= 4;
        }
        while (v507);
        if (v503 == v502) {
          goto LABEL_595;
        }
      }
    }
    goto LABEL_593;
  }
LABEL_595:
  vDSP_meanvD((const double *)v499, 1, (double *)buf, (v63 + 1));
  vDSP_meanvD((const double *)v498, 1, &v791, (*(_DWORD *)(a1 + 300) + 1));
  vDSP_meanvD((const double *)v500, 1, &v786, (*(_DWORD *)(a1 + 300) + 1));
  *(double *)buf = -*(double *)buf;
  double v791 = -v791;
  double v786 = -v786;
  vDSP_vsaddD((const double *)v499, 1, (const double *)buf, (double *)v499, 1, (*(_DWORD *)(a1 + 300) + 1));
  vDSP_vsaddD((const double *)v498, 1, &v791, (double *)v498, 1, (*(_DWORD *)(a1 + 300) + 1));
  vDSP_vsaddD((const double *)v500, 1, &v786, (double *)v500, 1, (*(_DWORD *)(a1 + 300) + 1));
  unint64_t v517 = (*(_DWORD *)(a1 + 300) + 1);
  if (v517 >= 4)
  {
    uint64_t v519 = 0;
    BOOL v518 = 1;
    while (2)
    {
      for (uint64_t j = 0; j != v517; ++j)
      {
        if (j != v519)
        {
          uint64_t v521 = 0;
          while (1)
          {
            if (v519 != v521 && j != v521)
            {
              v522.f64[0] = *(float64_t *)&v499[8 * v519];
              v522.f64[1] = *(float64_t *)&v498[8 * v519];
              v514.f64[0] = *(float64_t *)&v500[8 * v519];
              v523.f64[0] = *(float64_t *)&v499[8 * j];
              v523.f64[1] = *(float64_t *)&v498[8 * j];
              v515.f64[0] = *(float64_t *)&v500[8 * j];
              v524.f64[0] = *(float64_t *)&v499[8 * v521];
              v524.f64[1] = *(float64_t *)&v498[8 * v521];
              v516.f64[0] = *(float64_t *)&v500[8 * v521];
              float64x2_t v525 = vsubq_f64(v524, v522);
              float64x2_t v526 = vsubq_f64(v516, v514);
              float64x2_t v527 = vsubq_f64(v523, v522);
              float64x2_t v528 = vsubq_f64(v515, v514);
              float64x2_t v529 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v526, v527, 1)), v528, v525, 1);
              v528.f64[1] = v527.f64[0];
              v526.f64[1] = v525.f64[0];
              float64x2_t v516 = vmlaq_f64(vnegq_f64(vmulq_f64(v525, v528)), v527, v526);
              v530.f64[0] = v529.f64[0];
              v530.f64[1] = v516.f64[0];
              float64x2_t v515 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v516, 1);
              if (vaddvq_f64(vabsq_f64(v530)) + vabsq_f64(v515).f64[0] > 0.05) {
                break;
              }
            }
            if (v517 == ++v521) {
              goto LABEL_599;
            }
          }
          uint64_t v531 = 0;
          BOOL v518 = 0;
          *(void *)&v530.f64[1] = vextq_s8((int8x16_t)v530, (int8x16_t)v530, 8uLL).u64[0];
          float64x2_t v532 = (float64x2_t)vextq_s8((int8x16_t)v516, (int8x16_t)v516, 8uLL);
          v516.f64[1] = v532.f64[0];
          float64x2_t v533 = vmulq_f64(v516, v516);
          float v534 = sqrt(vmulq_f64(v529, v529).f64[0] + v533.f64[0] + v533.f64[1]);
          double v535 = 1.0 / v534;
          do
          {
            if (v521 != v531 && v519 != v531 && j != v531)
            {
              v536.f64[0] = *(float64_t *)&v499[8 * v531];
              v536.f64[1] = *(float64_t *)&v498[8 * v531];
              v532.f64[0] = *(float64_t *)&v500[8 * v531];
              float64x2_t v532 = vmulq_f64(vsubq_f64(v532, v514), v515);
              if (fabs((vaddvq_f64(vmulq_f64(vsubq_f64(v536, v522), v530)) + v532.f64[0]) * v535) > 0.01) {
                break;
              }
            }
            BOOL v518 = ++v531 >= v517;
          }
          while (v517 != v531);
          goto LABEL_614;
        }
LABEL_599:
        ;
      }
      if (++v519 != v517) {
        continue;
      }
      break;
    }
  }
  else
  {
    BOOL v518 = 1;
  }
LABEL_614:
  operator delete(v500);
  operator delete(v498);
  operator delete(v499);
  vDSP_Length v537 = *(unsigned int *)(a1 + 300);
  LODWORD(v63) = *(_DWORD *)(a1 + 300);
  if (v518)
  {
    if (v537 < 3)
    {
      vDSP_meanv(*(const float **)(a1 + 56), 3, (float *)&__C, *(unsigned int *)(a1 + 300));
      vDSP_meanv((const float *)(*(void *)(a1 + 56) + 4), 3, (float *)&__C + 1, *(unsigned int *)(a1 + 300));
      vDSP_meanv((const float *)(*(void *)(a1 + 56) + 8), 3, (float *)&v794, *(unsigned int *)(a1 + 300));
    }
    else
    {
      v538 = (int64x2_t *)operator new(8 * v537);
      bzero(v538, 8 * v537);
      uint64_t v539 = *(void *)(a1 + 64) - *(void *)(a1 + 56);
      memset(buf, 0, 24);
      unint64_t v540 = (v539 >> 2) + 3;
      if (v539 >> 2 == -3)
      {
        v541 = 0;
      }
      else
      {
        if (v540 >> 62) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        v541 = operator new(4 * v540);
        *(void *)buf = v541;
        *(void *)&buf[8] = v541;
        unint64_t v540 = (unint64_t)&v541[v540];
        *(void *)&uint8_t buf[16] = v540;
        bzero(v541, (v539 & 0xFFFFFFFFFFFFFFFCLL) + 12);
      }
      v581 = (unsigned long long *)operator new(4 * v537);
      bzero(v581, 4 * v537);
      unint64_t v582 = *(void *)(a1 + 8);
      if (v537 > 8
        && ((unint64_t)v581 >= 8 * v537 + v582 - 4 || v582 >= (unint64_t)v581 + 4 * v537))
      {
        uint64_t v584 = v537 & 7;
        if ((v537 & 7) == 0) {
          uint64_t v584 = 8;
        }
        vDSP_Length v583 = v537 - v584;
        v585 = v581 + 1;
        v586 = (const float *)(v582 + 32);
        int64x2_t v587 = (int64x2_t)xmmword_21B5513D0;
        int64x2_t v588 = (int64x2_t)xmmword_21B5513E0;
        v589 = v538 + 2;
        int64x2_t v590 = vdupq_n_s64(4uLL);
        vDSP_Length v591 = v583;
        do
        {
          v589[-2] = v588;
          v589[-1] = v587;
          int64x2_t *v589 = vaddq_s64(v588, v590);
          v589[1] = vaddq_s64(v587, v590);
          v589 += 4;
          v592 = v586 - 8;
          unsigned long long v593 = (unsigned __int128)vld2q_f32(v592);
          unsigned long long v594 = (unsigned __int128)vld2q_f32(v586);
          *(v585 - 1) = v593;
          unsigned long long *v585 = v594;
          int64x2_t v595 = vdupq_n_s64(8uLL);
          int64x2_t v587 = vaddq_s64(v587, v595);
          int64x2_t v588 = vaddq_s64(v588, v595);
          v585 += 2;
          v586 += 16;
          v591 -= 8;
        }
        while (v591);
      }
      else
      {
        vDSP_Length v583 = 0;
      }
      v596 = (int *)(v582 + 8 * v583);
      do
      {
        v538->i64[v583] = v583;
        int v597 = *v596;
        v596 += 2;
        *((_DWORD *)v581 + v583++) = v597;
      }
      while (v537 != v583);
      vDSP_vsorti((const float *)v581, (vDSP_Length *)v538, 0, v537, -1);
      uint64_t v598 = *(unsigned int *)(a1 + 300);
      if (v598)
      {
        uint64_t v599 = 0;
        uint64_t v600 = *(void *)(a1 + 56);
        v601 = (uint64_t *)v538;
        do
        {
          uint64_t v602 = *v601++;
          v603 = (_DWORD *)(v600 + 12 * v602);
          v541[v599] = *v603;
          v541[(v599 + 1)] = v603[1];
          v541[(v599 + 2)] = v603[2];
          v599 += 3;
        }
        while (3 * v598 != v599);
      }
      *(_DWORD *)(v540 - 12) = *v541;
      *(_DWORD *)(v540 - 8) = v541[1];
      *(_DWORD *)(v540 - 4) = v541[2];
      if (v598)
      {
        uint64_t v604 = 0;
        float v605 = 0.0;
        do
        {
          float v605 = v605
               + (float)((float)-(float)((float)(*(float *)&v541[(v604 + 1)]
                                               * *(float *)&v541[(v604 + 3)])
                                       - (float)(*(float *)&v541[(v604 + 4)]
                                               * *(float *)&v541[v604]))
                       * 0.5);
          v604 += 3;
        }
        while (3 * v598 != v604);
        uint64_t v606 = 0;
        float32x2_t v607 = __C;
        int v608 = v541[2];
        uint64_t v609 = 3 * v598;
        float v610 = 1.0 / v605;
        do
        {
          v611.i32[0] = v541[v606];
          v612.i32[0] = v541[(v606 + 3)];
          v612.i32[1] = v541[(v606 + 4)];
          v611.i32[1] = v541[(v606 + 1)];
          float32x2_t v607 = vmla_n_f32(v607, vadd_f32(v612, v611), (float)-(float)((float)(v611.f32[1] * v612.f32[0]) - (float)(v612.f32[1] * v611.f32[0]))* (float)(0.16667 * v610));
          v606 += 3;
        }
        while (v609 != v606);
        float32x2_t __C = v607;
        LODWORD(v794) = v608;
      }
      operator delete(v581);
      operator delete(v541);
      operator delete(v538);
    }
    uint64_t v613 = *(unsigned int *)(a1 + 300);
    if (v613 <= 1)
    {
      float v617 = __C.f32[1];
      LODWORD(v616.f64[0]) = 0;
      float v627 = 0.0;
      float v626 = 0.0;
    }
    else
    {
      v614 = *(float32x2_t **)(a1 + 56);
      float64x2_t v621 = vcvtq_f64_f32(vadd_f32(*v614, __C));
      float64x2_t v615 = (float64x2_t)vextq_s8((int8x16_t)v621, (int8x16_t)v621, 8uLL);
      v620.f64[0] = (float)(v614[1].f32[0] + *(float *)&v794);
      v620.f64[1] = v621.f64[0];
      float64x2_t v616 = (float64x2_t)vextq_s8((int8x16_t)v620, (int8x16_t)v620, 8uLL);
      float v617 = __C.f32[1];
      uint64_t v618 = 3 * v613;
      uint64_t v619 = 6;
      v620.f64[1] = v616.f64[0];
      v621.f64[1] = v615.f64[0];
      do
      {
        v622.i32[0] = v614->i32[(v619 - 3)];
        v622.i32[1] = v614->i32[(v619 - 2)];
        float64x2_t v623 = vcvtq_f64_f32(vadd_f32(v622, __C));
        v616.f64[0] = (float)(v614->f32[(v619 - 1)] + *(float *)&v794);
        v624.f64[0] = v616.f64[0];
        v624.f64[1] = v623.f64[0];
        v580.f64[0] = (float)(v614[1].f32[0] + *(float *)&v794);
        double v625 = vmlaq_f64(vnegq_f64(vmulq_laneq_f64(v580, v623, 1)), v615, v616).f64[0];
        float64x2_t v616 = vmlaq_f64(vnegq_f64(vmulq_f64(v624, v621)), v620, v623);
        float v626 = v625;
        float v627 = v616.f64[0];
        *(float *)v616.f64 = v616.f64[1];
        float v628 = fabsf(v627);
        BOOL v629 = fabsf(v626) < 0.00001 && v628 < 0.00001;
        float v630 = fabsf(*(float *)v616.f64);
        BOOL v632 = !v629 || v630 >= 0.00001 || v618 == v619;
        v619 += 3;
      }
      while (!v632);
    }
    *(float *)&uint64_t __A = v626 - __C.f32[0];
    *((float *)&__A + 1) = v627 - v617;
    *(float *)&uint64_t v787 = -(float)(__C.f32[0] + v626);
    *((float *)&v787 + 1) = -(float)(v617 + v627);
    float v790 = *(float *)v616.f64 - *(float *)&v794;
    float v788 = -(float)(*(float *)&v794 + *(float *)v616.f64);
    VBAP::lineUnitSphereIntersection((VBAP *)&__A, (const float *)&v787, *(float **)(a1 + 80), v579);
    goto LABEL_711;
  }
LABEL_619:
  vDSP_meanv(*(const float **)(a1 + 56), 3, (float *)&__C, v63);
  vDSP_meanv((const float *)(*(void *)(a1 + 56) + 4), 3, (float *)&__C + 1, *(unsigned int *)(a1 + 300));
  vDSP_meanv((const float *)(*(void *)(a1 + 56) + 8), 3, (float *)&v794, *(unsigned int *)(a1 + 300));
  if ((float)((float)(fabsf(__C.f32[1]) + fabsf(__C.f32[0])) + fabsf(*(float *)&v794)) < 0.00003)
  {
    uint64_t v543 = *(void *)(a1 + 80);
    if (*(void *)(a1 + 88) == v543) {
      goto LABEL_626;
    }
    goto LABEL_621;
  }
  *(float *)&v776 = -__C.f32[0];
  *((float *)&v776 + 1) = -__C.f32[1];
  *(float *)v777 = -*(float *)&v794;
  VBAP::lineUnitSphereIntersection((VBAP *)&__C, (const float *)&v776, *(float **)(a1 + 80), v542);
  if (*(unsigned char *)(a1 + 313))
  {
    uint64_t v544 = *(void *)(a1 + 80);
    unint64_t v545 = *(void *)(a1 + 88) - v544;
    if (v545 > 0xB)
    {
      if (v545 != 12)
      {
        uint64_t v543 = v544 + 12;
LABEL_621:
        *(void *)(a1 + 88) = v543;
      }
    }
    else
    {
      std::vector<float>::__append((char **)(a1 + 80), 3 - (v545 >> 2));
    }
  }
LABEL_626:
  uint64_t v546 = *(void *)(a1 + 88) - *(void *)(a1 + 80);
  memset(buf, 0, 24);
  if ((unint64_t)v546 < 0xC) {
    goto LABEL_711;
  }
  uint64_t v547 = *(unsigned int *)(a1 + 300);
  if (!v547) {
    goto LABEL_711;
  }
  v548 = 0;
  v549 = 0;
  v550 = 0;
  LODWORD(v551) = 0;
  unint64_t v552 = (v546 >> 2) / 3uLL;
  unint64_t v768 = v552;
LABEL_630:
  uint64_t v553 = 0;
  uint64_t v556 = 3 * v547;
  do
  {
    uint64_t v555 = *(void *)(a1 + 56);
    uint64_t v554 = *(void *)(a1 + 80);
    if ((float)((float)(vabds_f32(*(float *)(v554 + 4 * (3 * v551 + 1)), *(float *)(v555 + 4 * (v553 + 1)))+ vabds_f32(*(float *)(v554 + 4 * (3 * v551)), *(float *)(v555 + 4 * v553)))+ vabds_f32(*(float *)(v554 + 4 * (3 * v551 + 2)), *(float *)(v555 + 4 * (v553 + 2)))) < 0.00000035763)
    {
      if (v550 < v549)
      {
        *(_DWORD *)v550 = v551;
        v557 = v550 + 4;
LABEL_653:
        *(void *)&buf[8] = v557;
        v550 = v557;
        break;
      }
      uint64_t v558 = (v550 - v548) >> 2;
      unint64_t v559 = v558 + 1;
      if ((unint64_t)(v558 + 1) >> 62) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      if ((v549 - v548) >> 1 > v559) {
        unint64_t v559 = (v549 - v548) >> 1;
      }
      if ((unint64_t)(v549 - v548) >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v560 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v560 = v559;
      }
      if (v560)
      {
        if (v560 >> 62) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        v561 = operator new(4 * v560);
      }
      else
      {
        v561 = 0;
      }
      v562 = &v561[4 * v558];
      *(_DWORD *)v562 = v551;
      v557 = v562 + 4;
      if (v550 != v548)
      {
        unint64_t v563 = v550 - 4 - v548;
        if (v563 >= 0xBC)
        {
          if (&v561[v550 - v548 - 4 - (v563 & 0xFFFFFFFFFFFFFFFCLL)] > &v561[v550 - v548 - 4])
          {
            v564 = v550;
          }
          else if (&v550[-(v563 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v550 - 4)
          {
            v564 = v550;
          }
          else if ((unint64_t)(v548 - v561) >= 0x20)
          {
            uint64_t v566 = (v563 >> 2) + 1;
            v564 = &v550[-4 * (v566 & 0x7FFFFFFFFFFFFFF8)];
            v567 = &v561[4 * v558 - 16];
            v568 = v550 - 16;
            uint64_t v569 = v566 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v570 = *(_OWORD *)v568;
              *(v567 - 1) = *((_OWORD *)v568 - 1);
              _OWORD *v567 = v570;
              v567 -= 2;
              v568 -= 32;
              v569 -= 8;
            }
            while (v569);
            v562 -= 4 * (v566 & 0x7FFFFFFFFFFFFFF8);
            if (v566 == (v566 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_650;
            }
          }
          else
          {
            v564 = v550;
          }
        }
        else
        {
          v564 = v550;
        }
        do
        {
          int v565 = *((_DWORD *)v564 - 1);
          v564 -= 4;
          *((_DWORD *)v562 - 1) = v565;
          v562 -= 4;
        }
        while (v564 != v548);
      }
LABEL_650:
      v549 = &v561[4 * v560];
      *(void *)buf = v562;
      *(void *)&buf[8] = v557;
      *(void *)&uint8_t buf[16] = v549;
      if (v548) {
        operator delete(v548);
      }
      v548 = v562;
      unint64_t v552 = v768;
      goto LABEL_653;
    }
    v553 += 3;
  }
  while (v556 != v553);
  while (1)
  {
    unint64_t v551 = (v551 + 1);
    if (v552 <= v551) {
      break;
    }
    uint64_t v547 = *(unsigned int *)(a1 + 300);
    if (*(_DWORD *)(a1 + 300)) {
      goto LABEL_630;
    }
  }
  v571 = *(int **)buf;
  if (v550 == *(char **)buf)
  {
    if (v550) {
      goto LABEL_671;
    }
  }
  else
  {
    unint64_t v572 = 0;
    uint64_t v573 = a1;
    uint64_t v574 = *(void *)(a1 + 88);
    unint64_t v575 = (uint64_t)&v550[-*(void *)buf] >> 2;
    unsigned int v576 = 1;
    do
    {
      uint64_t v577 = *(void *)(v573 + 80) + 12 * v571[v572];
      uint64_t v578 = v574 - (v577 + 12);
      if (v574 != v577 + 12) {
        memmove((void *)(*(void *)(v573 + 80) + 12 * v571[v572]), (const void *)(v577 + 12), v574 - (v577 + 12));
      }
      uint64_t v574 = v577 + v578;
      uint64_t v573 = a1;
      *(void *)(a1 + 88) = v577 + v578;
      unint64_t v572 = v576++;
    }
    while (v575 > v572);
LABEL_671:
    operator delete(v571);
  }
LABEL_711:
  unint64_t v633 = (uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2;
  *(void *)(a1 + 304) = v633 / 3;
  uint64_t v634 = *(void *)(a1 + 128);
  unint64_t v635 = (*(void *)(a1 + 136) - v634) >> 2;
  if (v633 / 3 <= v635)
  {
    uint64_t v636 = a1;
    if (v633 / 3 < v635) {
      *(void *)(a1 + 136) = v634 + 4 * (v633 / 3);
    }
  }
  else
  {
    std::vector<float>::__append((char **)(a1 + 128), v633 / 3 - v635);
    uint64_t v636 = a1;
    unint64_t v633 = (uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2;
  }
  v639 = *(void **)(v636 + 32);
  uint64_t v638 = v636 + 32;
  v637 = v639;
  *(void *)(v638 + 8) = v639;
  v641 = *(char **)(v638 + 24);
  uint64_t v640 = *(void *)(v638 + 32);
  unint64_t v642 = (v640 - (uint64_t)v641) >> 2;
  unint64_t v643 = v633 + v642;
  if (v633 + v642 > (uint64_t)(*(void *)(v638 + 16) - (void)v639) >> 2)
  {
    if (!(v643 >> 62))
    {
      v644 = (char *)operator new(4 * v643);
      *(void *)(a1 + 32) = v644;
      *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v644;
      *(void *)(a1 + 48) = &v644[4 * v643];
      if (v637)
      {
        operator delete(v637);
        v641 = *(char **)(a1 + 56);
        uint64_t v640 = *(void *)(a1 + 64);
        unint64_t v642 = (v640 - (uint64_t)v641) >> 2;
      }
      goto LABEL_719;
    }
LABEL_844:
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
LABEL_719:
  std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)v638, v641, v640, v642);
  v652 = *(float **)(a1 + 80);
  v653 = *(float **)(a1 + 88);
  for (*(void *)buf = v638; v652 != v653; ++v652)
    std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100]((uint64_t *)buf, *v652);
  if (*(_DWORD *)a1 != 1) {
    goto LABEL_796;
  }
  v654 = (const float **)v781;
  v655 = v782;
  if (v782 == v781) {
    goto LABEL_796;
  }
  unint64_t v656 = 0;
  unsigned int v657 = 1;
  while (2)
  {
    v658 = (char *)__p + 24 * v656;
    if (v658[1] - *v658 > 0xCuLL)
    {
LABEL_725:
      unint64_t v656 = v657++;
      if (0xAAAAAAAAAAAAAAABLL * ((v655 - (char *)v654) >> 3) <= v656) {
        goto LABEL_796;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)&buf[8] = 0;
  *(void *)buf = 0;
  v659 = (_DWORD *)*v658;
  uint64_t v660 = *(void *)v638;
  unsigned int v661 = 3 * *v659;
  *(_DWORD *)buf = *(_DWORD *)(*(void *)v638 + 4 * v661);
  *(_DWORD *)&uint8_t buf[4] = *(_DWORD *)(v660 + 4 * (v661 + 1));
  *(_DWORD *)&buf[8] = *(_DWORD *)(v660 + 4 * (v661 + 2));
  unsigned int v662 = 3 * v659[1];
  *(float *)buf = *(float *)buf + *(float *)(v660 + 4 * v662);
  *(float *)&uint8_t buf[4] = *(float *)&buf[4] + *(float *)(v660 + 4 * (v662 + 1));
  *(float *)&buf[8] = *(float *)&buf[8] + *(float *)(v660 + 4 * (v662 + 2));
  LODWORD(v659) = 3 * v659[2];
  *(float *)buf = *(float *)buf + *(float *)(v660 + 4 * v659);
  *(float *)&uint8_t buf[4] = *(float *)&buf[4] + *(float *)(v660 + 4 * (v659 + 1));
  *(float *)&buf[8] = *(float *)&buf[8] + *(float *)(v660 + 4 * (v659 + 2));
  __C.i32[0] = 0;
  vDSP_dotpr((const float *)buf, 1, v654[3 * v656], 1, (float *)&__C, 3uLL);
  LODWORD(v645) = __C.i32[0];
  if (__C.f32[0] > 0.0)
  {
    v654 = (const float **)v781;
    v655 = v782;
    goto LABEL_725;
  }
  LODWORD(v777[0]) = 0;
  v776 = 0;
  vDSP_meanv(*(const float **)(a1 + 32), 3, (float *)&v776, ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2) / 3uLL);
  vDSP_meanv((const float *)(*(void *)(a1 + 32) + 4), 3, (float *)&v776 + 1, ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2) / 3uLL);
  vDSP_meanv((const float *)(*(void *)(a1 + 32) + 8), 3, (float *)v777, ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2) / 3uLL);
  LODWORD(v786) = 0;
  vDSP_sve((const float *)&v776, 1, (float *)&v786, 3uLL);
  *(float *)&double v786 = 1.0 / sqrtf(*(float *)&v786);
  float32x2_t __C = 0;
  uint64_t v794 = 0;
  int32x2_t v795 = 0;
  vDSP_vsmul((const float *)&v776, 1, (const float *)&v786, (float *)&__C, 1, 3uLL);
  float v792 = -*(float *)&v786;
  vDSP_vsmul((const float *)&v776, 1, &v792, (float *)&v794 + 1, 1, 3uLL);
  double v791 = 0.0;
  vDSP_distancesq((const float *)&v776, 1, (const float *)&__C, 1, (float *)&v791, 3uLL);
  vDSP_distancesq((const float *)&v776, 1, (const float *)&v794 + 1, 1, (float *)&v791 + 1, 3uLL);
  v646.i32[0] = HIDWORD(v791);
  LODWORD(v645) = LODWORD(v791);
  float v790 = 0.0;
  uint64_t __A = 0;
  v663 = v779;
  if (v779 == __p)
  {
    unsigned int v666 = 0;
  }
  else
  {
    uint64_t v664 = 0;
    unsigned int v665 = 0;
    unsigned int v666 = 0;
    uint64_t v667 = 12;
    if (*(float *)&v791 > *((float *)&v791 + 1)) {
      uint64_t v667 = 0;
    }
    v668 = (const float *)((char *)&__C + v667);
    float v669 = 3.4028e38;
    v663 = (char *)__p;
    do
    {
      *(_DWORD *)&buf[8] = 0;
      *(void *)buf = 0;
      v670 = &v663[24 * v664];
      uint64_t v671 = *(void *)v638;
      v672 = *(_DWORD **)v670;
      float v673 = (float)(unint64_t)((uint64_t)(*((void *)v670 + 1) - *(void *)v670) >> 2);
      LODWORD(v67std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 3 * **(_DWORD **)v670;
      float v674 = 1.0 / v673;
      *(float *)buf = *(float *)(*(void *)v638 + 4 * v670) * v674;
      *(float *)&uint8_t buf[4] = *(float *)(v671 + 4 * (v670 + 1)) * v674;
      *(float *)&buf[8] = *(float *)(v671 + 4 * (v670 + 2)) * v674;
      LODWORD(v67std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 3 * v672[1];
      *(float *)buf = *(float *)buf + (float)(*(float *)(v671 + 4 * v670) * v674);
      *(float *)&uint8_t buf[4] = *(float *)&buf[4] + (float)(*(float *)(v671 + 4 * (v670 + 1)) * v674);
      *(float *)&buf[8] = *(float *)&buf[8] + (float)(*(float *)(v671 + 4 * (v670 + 2)) * v674);
      LODWORD(v67std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 3 * v672[2];
      *(float *)buf = *(float *)buf + (float)(*(float *)(v671 + 4 * v670) * v674);
      *(float *)&uint8_t buf[4] = *(float *)&buf[4] + (float)(*(float *)(v671 + 4 * (v670 + 1)) * v674);
      *(float *)&buf[8] = *(float *)&buf[8] + (float)(*(float *)(v671 + 4 * (v670 + 2)) * v674);
      vDSP_distancesq(v668, 1, (const float *)buf, 1, (float *)&v791, 3uLL);
      LODWORD(v645) = LODWORD(v791);
      if (*(float *)&v791 < v669)
      {
        uint64_t __A = *(void *)buf;
        float v790 = *(float *)&buf[8];
        unsigned int v666 = v665;
        float v669 = *(float *)&v791;
      }
      v663 = (char *)__p;
      uint64_t v664 = ++v665;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v779 - (unsigned char *)__p) >> 3) > v665);
  }
  v675 = &v663[24 * v666];
  v676 = v675 + 8;
  if (*((void *)v675 + 1) - *(void *)v675 > 0xCuLL) {
    goto LABEL_796;
  }
  unint64_t v677 = *(void *)(a1 + 168);
  v678 = *(void **)(a1 + 160);
  if ((unint64_t)v678 < v677)
  {
    void *v678 = 0;
    v678[1] = 0;
    v678[2] = 0;
    v679 = *(const void **)v675;
    int64_t v680 = *v676 - *(void *)v675;
    if (*v676 != *(void *)v675)
    {
      if (v680 < 0) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      v681 = (char *)operator new(*v676 - *(void *)v675);
      void *v678 = v681;
      v678[1] = v681;
      v682 = &v681[4 * (v680 >> 2)];
      v678[2] = v682;
      memcpy(v681, v679, v680);
      v678[1] = v682;
    }
    v683 = v678 + 3;
    uint64_t v684 = a1;
    *(void *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v678 + 3;
    goto LABEL_766;
  }
  v685 = *(void **)(a1 + 152);
  unint64_t v686 = 0xAAAAAAAAAAAAAAABLL * (v678 - v685) + 1;
  if (v686 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
  }
  unint64_t v687 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v677 - (void)v685) >> 3);
  if (2 * v687 > v686) {
    unint64_t v686 = 2 * v687;
  }
  if (v687 >= 0x555555555555555) {
    unint64_t v688 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v688 = v686;
  }
  *(void *)&buf[32] = a1 + 168;
  if (!v688)
  {
    v689 = 0;
    goto LABEL_752;
  }
  if (v688 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_848;
  }
  v689 = (char *)operator new(24 * v688);
LABEL_752:
  v690 = &v689[8 * (v678 - v685)];
  *(void *)buf = v689;
  *(void *)&buf[8] = v690;
  *(void *)&uint8_t buf[16] = v690;
  *(void *)&unsigned char buf[24] = &v689[24 * v688];
  uint64_t v746 = *(void *)&buf[24];
  *((void *)v690 + 1) = 0;
  v748 = (char **)(v690 + 8);
  *((void *)v690 + 2) = 0;
  *(void *)v690 = 0;
  int64_t v691 = *v676 - *(void *)v675;
  if (*v676 != *(void *)v675)
  {
    if (v691 < 0) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    __srca = *(void **)v675;
    v692 = (char *)operator new(v691);
    *(void *)v690 = v692;
    *v748 = v692;
    v693 = &v692[4 * (v691 >> 2)];
    *((void *)v690 + 2) = v693;
    memcpy(v692, __srca, v691);
    *v748 = v693;
  }
  v683 = v690 + 24;
  *(void *)&uint8_t buf[16] = v690 + 24;
  if (v678 == v685)
  {
    *(void *)(a1 + 152) = v690;
    *(void *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v683;
    *(void *)(a1 + 168) = v746;
  }
  else
  {
    do
    {
      v694 = v690;
      *((void *)v690 - 2) = 0;
      *((void *)v690 - 1) = 0;
      long long v695 = *(_OWORD *)(v678 - 3);
      v678 -= 3;
      *(_OWORD *)(v690 - 24) = v695;
      v690 -= 24;
      *((void *)v694 - 1) = v678[2];
      void *v678 = 0;
      v678[1] = 0;
      v678[2] = 0;
    }
    while (v678 != v685);
    v678 = *(void **)(a1 + 152);
    v696 = *(void **)(a1 + 160);
    *(void *)(a1 + 152) = v690;
    v697 = *(void **)&buf[16];
    *(_OWORD *)(a1 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = *(_OWORD *)&buf[16];
    v683 = v697;
    if (v696 != v678)
    {
      v698 = v696;
      do
      {
        v700 = (void *)*(v698 - 3);
        v698 -= 3;
        v699 = v700;
        if (v700)
        {
          *(v696 - 2) = v699;
          operator delete(v699);
        }
        v696 = v698;
      }
      while (v698 != v678);
    }
  }
  if (v678) {
    operator delete(v678);
  }
  uint64_t v684 = a1;
LABEL_766:
  *(void *)(v684 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v683;
  memset(buf, 0, 24);
  vDSP_vadd(*((const float **)v781 + 3 * v666), 1, (const float *)&__A, 1, (float *)buf, 1, 3uLL);
  vDSP_vsub(*((const float **)v781 + 3 * v666), 1, (const float *)&__A, 1, (float *)&buf[12], 1, 3uLL);
  VBAP::lineUnitSphereIntersection((VBAP *)buf, (const float *)&buf[12], (float *)&__C, v701);
  vDSP_distancesq((const float *)&v776, 1, (const float *)&__C, 1, (float *)&v791, 3uLL);
  vDSP_distancesq((const float *)&v776, 1, (const float *)&v794 + 1, 1, (float *)&v791 + 1, 3uLL);
  v702 = (void *)a1;
  if (*(void *)(a1 + 88) - *(void *)(a1 + 80) > 0xFFFFFFFFFFFFFFF3)
  {
    uint64_t v703 = *(void *)(a1 + 88) + 12;
    *(void *)(a1 + 88) = v703;
  }
  else
  {
    std::vector<float>::__append((char **)(a1 + 80), 3uLL);
    v702 = (void *)a1;
    uint64_t v703 = *(void *)(a1 + 88);
  }
  uint64_t v704 = 12;
  if (*((float *)&v791 + 1) <= *(float *)&v791) {
    uint64_t v704 = 0;
  }
  v705 = (char *)&__C + v704;
  uint64_t v706 = v703;
  uint64_t v707 = *(void *)v705;
  *(_DWORD *)(v706 - 4) = *((_DWORD *)v705 + 2);
  *(void *)(v706 - 12) = v707;
  v709 = (char *)v702[14];
  unint64_t v708 = v702[15];
  if ((unint64_t)v709 < v708)
  {
    *(_DWORD *)v709 = 1065353216;
    v710 = v709 + 4;
    goto LABEL_792;
  }
  v711 = (char *)v702[13];
  uint64_t v712 = (v709 - v711) >> 2;
  unint64_t v713 = v712 + 1;
  if ((unint64_t)(v712 + 1) >> 62) {
    goto LABEL_844;
  }
  uint64_t v714 = v708 - (void)v711;
  if (v714 >> 1 > v713) {
    unint64_t v713 = v714 >> 1;
  }
  if ((unint64_t)v714 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v715 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v715 = v713;
  }
  if (v715)
  {
    if (!(v715 >> 62))
    {
      v716 = operator new(4 * v715);
      goto LABEL_783;
    }
LABEL_848:
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  v716 = 0;
LABEL_783:
  v717 = &v716[4 * v712];
  v718 = &v716[4 * v715];
  _DWORD *v717 = 1065353216;
  v710 = v717 + 1;
  if (v709 != v711)
  {
    unint64_t v719 = v709 - v711 - 4;
    if (v719 < 0x2C) {
      goto LABEL_858;
    }
    if ((unint64_t)(v711 - v716) < 0x20) {
      goto LABEL_858;
    }
    uint64_t v720 = (v719 >> 2) + 1;
    v721 = &v716[4 * v712 - 16];
    v722 = v709 - 16;
    uint64_t v723 = v720 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      long long v724 = *(_OWORD *)v722;
      *(v721 - 1) = *((_OWORD *)v722 - 1);
      _OWORD *v721 = v724;
      v721 -= 2;
      v722 -= 32;
      v723 -= 8;
    }
    while (v723);
    v717 -= v720 & 0x7FFFFFFFFFFFFFF8;
    v709 -= 4 * (v720 & 0x7FFFFFFFFFFFFFF8);
    if (v720 != (v720 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_858:
      do
      {
        int v725 = *((_DWORD *)v709 - 1);
        v709 -= 4;
        *--v717 = v725;
      }
      while (v709 != v711);
    }
  }
  *(void *)(a1 + 104) = v717;
  *(void *)(a1 + 112) = v710;
  *(void *)(a1 + 12std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v718;
  if (v711) {
    operator delete(v711);
  }
LABEL_792:
  *(void *)(a1 + 112) = v710;
  ++*(void *)(a1 + 304);
  uint64_t v726 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) - v726 == -4) {
    *(void *)(a1 + 136) = v726;
  }
  else {
    std::vector<float>::__append((char **)(a1 + 128), 1uLL);
  }
  uint64_t v727 = *(void *)(a1 + 88);
  uint64_t v787 = v638;
  float v728 = *(float *)(v727 - 12);
  v727 -= 12;
  std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100](&v787, v728);
  std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100](&v787, *(float *)(v727 + 4));
  std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100](&v787, *(float *)(v727 + 8));
LABEL_796:
  uint64_t v42 = VBAP::delaunayTriangulation(a1, *(const float **)(a1 + 32), *(void *)(a1 + 40), a4, a5, v645, v646, v647, v648, v649, v650, v651);
  float v55 = v753;
  if (v42)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "VBAP.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 198;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = "initialize";
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 198;
      long long v87 = MEMORY[0x263EF8438];
      float v88 = "%25s:%-5d CADSPUtility:%s:%d: VBAP error; Delaunay triangulation issue";
LABEL_799:
      _os_log_impl(&dword_21B4DD000, v87, OS_LOG_TYPE_ERROR, v88, buf, 0x22u);
    }
    goto LABEL_800;
  }
  char v729 = 1;
  v730 = (char *)__p;
  if (__p)
  {
LABEL_803:
    v731 = v779;
    v732 = v730;
    if (v779 != v730)
    {
      v733 = v779;
      do
      {
        v735 = (void *)*((void *)v733 - 3);
        v733 -= 24;
        v734 = v735;
        if (v735)
        {
          *((void *)v731 - 2) = v734;
          operator delete(v734);
        }
        v731 = v733;
      }
      while (v733 != v730);
      v732 = __p;
    }
    v779 = v730;
    operator delete(v732);
  }
LABEL_810:
  v736 = (char *)v781;
  if (v781)
  {
    v737 = v782;
    v738 = v781;
    if (v782 != v781)
    {
      v739 = v782;
      do
      {
        v741 = (void *)*((void *)v739 - 3);
        v739 -= 24;
        v740 = v741;
        if (v741)
        {
          *((void *)v737 - 2) = v740;
          operator delete(v740);
        }
        v737 = v739;
      }
      while (v739 != v736);
      v738 = v781;
    }
    v782 = v736;
    operator delete(v738);
  }
  if (v758) {
    operator delete(v758);
  }
  if (v760) {
    operator delete(v760);
  }
  if (v771) {
    operator delete(v771);
  }
  if (v55) {
    operator delete(v55);
  }
  if (v729) {
LABEL_827:
  }
    uint64_t v42 = 0;
LABEL_828:
  if (v773) {
    operator delete(v773);
  }
  if (v775) {
    operator delete(v775);
  }
  if (v20) {
    operator delete(v20);
  }
  return v42;
}

void sub_21B532A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,uint64_t a22,void *a23,uint64_t a24,void *a25,void *a26,void *a27,void *__p,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34)
{
  std::vector<std::vector<unsigned int>>::~vector[abi:ne180100]((void **)(v35 - 176));
  if (__p) {
    operator delete(__p);
  }
  std::vector<std::vector<unsigned int>>::~vector[abi:ne180100](&a31);
  std::vector<std::vector<unsigned int>>::~vector[abi:ne180100](&a34);
  if (a20)
  {
    operator delete(a20);
    if (!a21)
    {
LABEL_5:
      if (!a25) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if (!a21)
  {
    goto LABEL_5;
  }
  operator delete(a21);
  if (!a25)
  {
LABEL_7:
    if (a16) {
      operator delete(a16);
    }
    if (a26)
    {
      operator delete(a26);
      if (!a27)
      {
LABEL_11:
        if (!v34) {
          goto LABEL_12;
        }
        goto LABEL_18;
      }
    }
    else if (!a27)
    {
      goto LABEL_11;
    }
    operator delete(a27);
    if (!v34) {
LABEL_12:
    }
      _Unwind_Resume(a1);
LABEL_18:
    operator delete(v34);
    _Unwind_Resume(a1);
  }
LABEL_6:
  operator delete(a25);
  goto LABEL_7;
}

void **std::vector<std::list<int>>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t *)a1[1];
    int v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = v3 - 3;
        if (*(v3 - 1))
        {
          uint64_t v7 = *(v3 - 3);
          unint64_t v6 = (uint64_t *)*(v3 - 2);
          uint64_t v8 = *v6;
          *(void *)(v8 + 8) = *(void *)(v7 + 8);
          **(void **)(v7 + 8) = v8;
          *(v3 - 1) = 0;
          if (v6 != v5)
          {
            do
            {
              unint64_t v9 = (uint64_t *)v6[1];
              operator delete(v6);
              unint64_t v6 = v9;
            }
            while (v9 != v5);
          }
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      int v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void **std::vector<std::vector<unsigned int>>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    int v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = (char *)a1[1];
      do
      {
        uint64_t v7 = (void *)*((void *)v5 - 3);
        v5 -= 24;
        unint64_t v6 = v7;
        if (v7)
        {
          *((void *)v3 - 2) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      int v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

BOOL VBAP::find_duplicate_vertex(VBAP *this, const float *a2, const float *a3, const float *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  MEMORY[0x270FA5388](this);
  unint64_t v9 = (float *)&v15[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)];
  if (v10 < 2) {
    return 0;
  }
  bzero(&v15[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)], v8);
  unsigned int v11 = 2;
  vDSP_Length v12 = 1;
  do
  {
    vDSP_vsmul((const float *)this, 1, (const float *)this + v12, v9, 1, v12);
    vDSP_vsma(a2, 1, &a2[v12], v9, 1, v9, 1, v12);
    vDSP_vsma(a3, 1, &a3[v12], v9, 1, v9, 1, v12);
    float __C = 0.0;
    vDSP_maxv(v9, 1, &__C, v12);
    BOOL result = __C > 1.0;
    vDSP_Length v12 = v11++;
  }
  while (__C <= 1.0 && v12 < (unint64_t)a4);
  return result;
}

uint64_t VBAP::delaunayTriangulation(uint64_t a1, const float *a2, uint64_t a3, char **a4, uint64_t *a5, double a6, float32x4_t a7, __n128 a8, double a9, float64x2_t a10, double a11, float64x2_t a12)
{
  uint64_t v628 = *MEMORY[0x263EF8340];
  uint64_t v15 = ((unint64_t)((a3 - (uint64_t)a2) >> 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64;
  unint64_t v16 = ((a3 - (uint64_t)a2) >> 2) / 3uLL;
  uint64_t v619 = 0;
  uint64_t v618 = 0;
  float64x2_t v620 = 0;
  if (v16 << 32)
  {
    if (((v16 << 32) & 0x8000000000000000) != 0) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    size_t v17 = (8 * v16) & 0x7FFFFFFFFLL;
    float v18 = (double *)operator new(v17);
    uint64_t v618 = v18;
    float64x2_t v620 = &v18[(int)(v15 >> 1)];
    bzero(v18, v17);
    uint64_t v619 = (char *)v18 + v17;
    int v19 = (double *)operator new(v17);
    bzero(v19, v17);
    std::vector<char> __p = (double *)operator new(v17);
    bzero(__p, v17);
    uint64_t v20 = (v16 - 1);
    if ((int)v16 < 1) {
      goto LABEL_16;
    }
  }
  else
  {
    int v19 = 0;
    std::vector<char> __p = 0;
    float v18 = 0;
    uint64_t v20 = (v16 - 1);
    if ((int)v16 < 1) {
      goto LABEL_16;
    }
  }
  if (v16 >= 4uLL)
  {
    unint64_t v21 = 0;
    if ((unint64_t)((char *)v19 - (char *)v18) >= 0x20
      && (unint64_t)((char *)__p - (char *)v18) >= 0x20
      && (unint64_t)((char *)__p - (char *)v19) >= 0x20)
    {
      unint64_t v21 = v16 - (v16 & 3);
      int v22 = a2;
      unint64_t v23 = (float64x2_t *)v18;
      uint64_t v24 = (float64x2_t *)v19;
      uint64_t v25 = (float64x2_t *)__p;
      unint64_t v26 = v21;
      do
      {
        *(float32x4x3_t *)(&a7 - 1) = vld3q_f32(v22);
        v22 += 12;
        *unint64_t v23 = vcvtq_f64_f32(*(float32x2_t *)v27.f32);
        v23[1] = vcvt_hight_f64_f32(v27);
        v23 += 2;
        a10 = vcvt_hight_f64_f32(a7);
        *uint64_t v24 = vcvtq_f64_f32(*(float32x2_t *)a7.f32);
        v24[1] = a10;
        v24 += 2;
        *uint64_t v25 = vcvtq_f64_f32((float32x2_t)a8.n128_u64[0]);
        v25[1] = vcvt_hight_f64_f32((float32x4_t)a8);
        v25 += 2;
        v26 -= 4;
      }
      while (v26);
      if ((v16 & 3) == 0) {
        goto LABEL_16;
      }
    }
  }
  else
  {
    unint64_t v21 = 0;
  }
  unint64_t v28 = v16 - v21;
  double v29 = &__p[v21];
  double v30 = &v19[v21];
  unint64_t v31 = &v18[v21];
  double v32 = (float *)&a2[3 * v21 + 1];
  do
  {
    *v31++ = *(v32 - 1);
    float v33 = *v32;
    float v34 = v32[1];
    v32 += 3;
    *v30++ = v33;
    *v29++ = v34;
    --v28;
  }
  while (v28);
LABEL_16:
  int v608 = v19;
  if (v16 < 4) {
    goto LABEL_35;
  }
  uint64_t v35 = 0;
  unint64_t v36 = v16;
LABEL_18:
  uint64_t v37 = 0;
  while (v37 == v35)
  {
LABEL_19:
    if (++v37 == v16)
    {
      if (++v35 == v16) {
        goto LABEL_35;
      }
      goto LABEL_18;
    }
  }
  uint64_t v38 = 0;
  while (1)
  {
    if (v35 != v38 && v37 != v38)
    {
      v39.f64[0] = v18[v35];
      v39.f64[1] = v19[v35];
      *(double *)a7.i64 = __p[v35];
      v40.f64[0] = v18[v37];
      v40.f64[1] = v19[v37];
      a10.f64[0] = __p[v37];
      v41.f64[0] = v18[v38];
      v41.f64[1] = v19[v38];
      a12.f64[0] = __p[v38];
      float64x2_t v42 = vsubq_f64(v41, v39);
      float64x2_t v43 = vsubq_f64(a12, (float64x2_t)a7);
      float64x2_t v44 = vsubq_f64(v40, v39);
      float64x2_t v45 = vsubq_f64(a10, (float64x2_t)a7);
      float64x2_t v46 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v43, v44, 1)), v45, v42, 1);
      v45.f64[1] = v44.f64[0];
      v43.f64[1] = v42.f64[0];
      a12 = vmlaq_f64(vnegq_f64(vmulq_f64(v42, v45)), v44, v43);
      v47.f64[0] = v46.f64[0];
      v47.f64[1] = a12.f64[0];
      a10 = (float64x2_t)vdupq_laneq_s64((int64x2_t)a12, 1);
      float64x2_t v48 = vabsq_f64(a10);
      if (vaddvq_f64(vabsq_f64(v47)) + v48.f64[0] > 0.05) {
        break;
      }
    }
    if (v16 == ++v38) {
      goto LABEL_19;
    }
  }
  uint64_t v49 = 0;
  BOOL v50 = 0;
  *(void *)&v47.f64[1] = vextq_s8((int8x16_t)v47, (int8x16_t)v47, 8uLL).u64[0];
  float64x2_t v51 = (float64x2_t)vextq_s8((int8x16_t)a12, (int8x16_t)a12, 8uLL);
  a12.f64[1] = v51.f64[0];
  float64x2_t v52 = vmulq_f64(a12, a12);
  float v53 = sqrt(vmulq_f64(v46, v46).f64[0] + v52.f64[0] + v52.f64[1]);
  double v54 = 1.0 / v53;
  do
  {
    if (v38 != v49 && v35 != v49 && v37 != v49)
    {
      v55.f64[0] = v18[v49];
      v55.f64[1] = v19[v49];
      v51.f64[0] = __p[v49];
      float64x2_t v52 = vmulq_f64(vsubq_f64(v55, v39), v47);
      float64x2_t v51 = vmulq_f64(vsubq_f64(v51, (float64x2_t)a7), a10);
      if (fabs((vaddvq_f64(v52) + v51.f64[0]) * v54) > 0.01) {
        break;
      }
    }
    BOOL v50 = ++v49 >= (unint64_t)v16;
  }
  while (v16 != v49);
  if (v50)
  {
LABEL_35:
    if (!os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
LABEL_38:
      uint64_t v57 = 4294967246;
      goto LABEL_39;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "VBAP.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 779;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = "delaunayTriangulation";
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 779;
    size_t v56 = MEMORY[0x263EF8438];
LABEL_37:
    _os_log_impl(&dword_21B4DD000, v56, OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: Delaunay Triangulation Error: Convex hull could not be created. Check for overlapping speakers. ", buf, 0x22u);
    goto LABEL_38;
  }
  float v605 = a5;
  uint64_t v578 = v18;
  uint64_t v62 = *a4;
  unsigned int v61 = a4[1];
  int64_t v63 = v61 - *a4;
  unint64_t v64 = v63 >> 2;
  uint64_t v65 = 2 * (int)v16 - 4;
  unint64_t v603 = (v63 >> 2) / 3uLL;
  uint64_t v610 = v65;
  if (v603 == v65)
  {
    _ZF = a1 + 224 == (void)a4;
    uint64_t v71 = a1;
    if (_ZF) {
      goto LABEL_139;
    }
    uint64_t v72 = *(void *)(a1 + 240);
    float64x2_t v73 = *(char **)(a1 + 224);
    if (v64 > (v72 - (uint64_t)v73) >> 2)
    {
      if (v73)
      {
        *(void *)(a1 + 232) = v73;
        operator delete(v73);
        uint64_t v72 = 0;
        *(void *)(a1 + 224) = 0;
        *(void *)(a1 + 232) = 0;
        *(void *)(a1 + 24std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
      }
      if (v63 < 0) {
        goto LABEL_485;
      }
      uint64_t v74 = v72 >> 1;
      if (v72 >> 1 <= v64) {
        uint64_t v74 = v63 >> 2;
      }
      unint64_t v75 = (unint64_t)v72 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v74;
      if (v75 >> 62) {
LABEL_485:
      }
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      float64x2_t v76 = (char *)operator new(4 * v75);
      float64x2_t v73 = v76;
      *(void *)(a1 + 232) = v76;
      uint64_t v77 = (char **)(a1 + 232);
      *(void *)(a1 + 224) = v76;
      *(void *)(a1 + 24std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = &v76[4 * v75];
      if (v61 != v62) {
        memcpy(v76, v62, v63);
      }
      goto LABEL_92;
    }
    uint64_t v77 = (char **)(a1 + 232);
    unsigned int v95 = *(unsigned char **)(a1 + 232);
    unint64_t v96 = (v95 - v73) >> 2;
    if (v96 >= v64)
    {
      if (v61 == v62)
      {
LABEL_92:
        *uint64_t v77 = &v73[v63];
        uint64_t v71 = a1;
        goto LABEL_139;
      }
      unsigned int v98 = *(void **)(a1 + 224);
      unsigned int v99 = v62;
    }
    else
    {
      unsigned int v97 = &v62[4 * v96];
      if (v95 != v73)
      {
        memmove(*(void **)(a1 + 224), v62, v95 - v73);
        float64x2_t v73 = *v77;
      }
      int64_t v63 = v61 - v97;
      if (v61 == v97) {
        goto LABEL_92;
      }
      unsigned int v98 = v73;
      unsigned int v99 = v97;
    }
    memmove(v98, v99, v63);
    goto LABEL_92;
  }
  uint64_t v66 = (void *)a1;
  unint64_t v67 = (3 * v65);
  uint64_t v68 = *(char **)(a1 + 224);
  uint64_t v69 = *(char **)(a1 + 232);
  unint64_t v70 = (v69 - v68) >> 2;
  float v18 = v578;
  if (v67 <= v70)
  {
    if (v67 < v70)
    {
      uint64_t v69 = &v68[4 * v67];
      *(void *)(a1 + 232) = v69;
    }
  }
  else
  {
    std::vector<int>::__append((std::vector<unsigned int> *)(a1 + 224), v67 - v70);
    uint64_t v66 = (void *)a1;
    uint64_t v68 = *(char **)(a1 + 224);
    uint64_t v69 = *(char **)(a1 + 232);
  }
  uint64_t v78 = a1 + 224;
  uint64_t v79 = v69 - v68;
  if (v79 >= 1)
  {
    bzero(v68, 4 * (((unint64_t)v79 >> 2) - ((unint64_t)v79 > 3)) + 4);
    uint64_t v78 = a1 + 224;
  }
  float64x2_t v80 = (CDelaunayTriangles3D *)(v78 - 48);
  if (v66[24])
  {
    uint64_t v82 = v66[22];
    int v81 = (CDelaunayTriangles3D *)v66[23];
    uint64_t v83 = *(void *)v81;
    *(void *)(v83 + 8) = *(void *)(v82 + 8);
    **(void **)(v82 + 8) = v83;
    v66[24] = 0;
    if (v81 != v80)
    {
      do
      {
        float64x2_t v84 = (CDelaunayTriangles3D *)*((void *)v81 + 1);
        operator delete(v81);
        int v81 = v84;
      }
      while (v84 != v80);
    }
  }
  float64x2_t v85 = v66 + 25;
  unint64_t v86 = v66[27];
  uint64_t v87 = v86 - v36;
  if (v86 <= v36)
  {
    if (v86 < v36)
    {
      uint64_t v89 = operator new(0x18uLL);
      uint64_t v90 = v89;
      *uint64_t v89 = 0;
      v89[1] = 0;
      *((_DWORD *)v89 + 4) = 0;
      if (v36 + ~v86)
      {
        uint64_t v91 = v36 - v86;
        uint64_t v92 = v87 + 1;
        uint64_t v93 = v89;
        uint64_t v66 = (void *)a1;
        do
        {
          uint64_t v89 = operator new(0x18uLL);
          *uint64_t v89 = v93;
          v89[1] = 0;
          v93[1] = v89;
          uint64_t v93 = v89;
          *((_DWORD *)v89 + 4) = 0;
        }
        while (!__CFADD__(v92++, 1));
        float v18 = v578;
      }
      else
      {
        uint64_t v91 = 1;
        uint64_t v66 = (void *)a1;
      }
      v89[1] = v85;
      uint64_t v105 = v66[25];
      void *v90 = v105;
      *(void *)(v105 + 8) = v90;
      v66[25] = v89;
      v66[27] = v91 + v86;
    }
  }
  else
  {
    if (v36 <= v86 >> 1)
    {
      float v88 = (void *)v66[26];
      unint64_t v100 = v36 + 1;
      do
      {
        float v88 = (void *)v88[1];
        --v100;
      }
      while (v100 > 1);
    }
    else if (v87 < 1)
    {
      unint64_t v101 = v36 - v86 + 1;
      float v88 = v66 + 25;
      do
      {
        float v88 = (void *)v88[1];
        --v101;
      }
      while (v101 > 1);
    }
    else
    {
      float v88 = v66 + 25;
      do
      {
        float v88 = (void *)*v88;
        --v87;
      }
      while (v87);
    }
    if (v88 != v85)
    {
      uint64_t v102 = *v85;
      float64x2_t v103 = (void *)*v88;
      v103[1] = *(void *)(*v85 + 8);
      **(void **)(v102 + 8) = v103;
      do
      {
        float64x2_t v104 = (void *)v88[1];
        --v66[27];
        operator delete(v88);
        float v88 = v104;
      }
      while (v104 != v85);
    }
  }
  uint64_t v106 = v66[26];
  if ((void *)v106 != v85)
  {
    int v107 = 0;
    do
    {
      *(_DWORD *)(v106 + 16) = v107;
      uint64_t v106 = *(void *)(v106 + 8);
      ++v107;
    }
    while ((void *)v106 != v85);
  }
  if ((int)v20 < 2)
  {
    int v114 = 1;
  }
  else
  {
    uint64_t v108 = 0;
    int v109 = 0;
    double v110 = (*v19 - v19[1]) * (*v19 - v19[1]) + (*v18 - v18[1]) * (*v18 - v18[1]) + (*__p - __p[1]) * (*__p - __p[1]);
    do
    {
      double v111 = *__p - __p[v108 + 2];
      double v112 = (*v18 - v18[v108 + 2]) * (*v18 - v18[v108 + 2])
           + (*v19 - v19[v108 + 2]) * (*v19 - v19[v108 + 2])
           + v111 * v111;
      _NF = v112 < v110;
      double v110 = fmin(v112, v110);
      ++v108;
      if (_NF) {
        int v109 = v108;
      }
    }
    while (v20 - 1 != v108);
    int v114 = v109 + 1;
  }
  LODWORD(v612[0]) = 0;
  HIDWORD(v612[0]) = v114;
  float32x4_t v115 = operator new(0x18uLL);
  unint64_t v116 = (unint64_t)v612[0];
  v115[1] = v80;
  v115[2] = v116;
  uint64_t v117 = *(void *)(a1 + 176);
  *float32x4_t v115 = v117;
  *(void *)(v117 + 8) = v115;
  *(void *)(a1 + 176) = v115;
  uint64_t v118 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = v118 + 1;
  int one_delaunay3 = CDelaunayTriangles3D::find_one_delaunay3(v80, v18, v19, __p, (int *)HIDWORD(v116), v116);
  if (one_delaunay3 < 0)
  {
    int v120 = CDelaunayTriangles3D::find_one_delaunay3(v80, v18, v19, __p, (int *)v116, SHIDWORD(v116));
    unint64_t v121 = HIDWORD(v116);
  }
  else
  {
    int v120 = one_delaunay3;
    unint64_t v121 = v116;
    v116 >>= 32;
  }
  uint64_t v71 = a1;
  if (v120 < 1)
  {
    LODWORD(v131) = 0;
  }
  else
  {
    uint64_t v122 = *(_DWORD **)(a1 + 224);
    *uint64_t v122 = v116;
    v122[1] = v121;
    void v122[2] = v120;
    *(_DWORD *)buf = v121;
    *(_DWORD *)&uint8_t buf[4] = v120;
    std::list<std::array<int,2ul>>::remove(v80, buf);
    uint64_t v123 = *(void *)(a1 + 192);
    if (v123 == v118 + 1)
    {
      *(void *)buf = __PAIR64__(v121, v120);
      uint64_t v124 = operator new(0x18uLL);
      uint64_t v125 = *(void *)buf;
      v124[1] = v80;
      void v124[2] = v125;
      uint64_t v71 = a1;
      uint64_t v126 = *(void *)(a1 + 176);
      *uint64_t v124 = v126;
      *(void *)(v126 + 8) = v124;
      *(void *)(a1 + 176) = v124;
      uint64_t v123 = v118 + 2;
      *(void *)(a1 + 192) = v118 + 2;
    }
    *(_DWORD *)buf = v120;
    *(_DWORD *)&uint8_t buf[4] = v116;
    std::list<std::array<int,2ul>>::remove(v80, buf);
    if (*(void *)(v71 + 192) == v123)
    {
      *(void *)buf = __PAIR64__(v120, v116);
      uint64_t v127 = operator new(0x18uLL);
      uint64_t v128 = *(void *)buf;
      v127[1] = v80;
      v127[2] = v128;
      uint64_t v71 = a1;
      uint64_t v129 = *(void *)(a1 + 176);
      *uint64_t v127 = v129;
      *(void *)(v129 + 8) = v127;
      *(void *)(a1 + 176) = v127;
      *(void *)(a1 + 192) = v123 + 1;
    }
    CDelaunayTriangles3D::check_avail_vertices(v80, v116 | (v121 << 32), v120);
    if (!*(void *)(v71 + 216))
    {
      LODWORD(v131) = 1;
      goto LABEL_237;
    }
    if (v610 <= 1) {
      uint64_t v130 = 1;
    }
    else {
      uint64_t v130 = v610;
    }
    uint64_t v597 = v130;
    uint64_t v131 = 1;
    do
    {
      if (!*(void *)(v71 + 192)) {
        break;
      }
      uint64_t v132 = *(CDelaunayTriangles3D **)(v71 + 184);
      if (v132 == v80) {
        break;
      }
      int v133 = v80;
      while (1)
      {
        int v133 = *(CDelaunayTriangles3D **)v133;
        long long v134 = (int *)*((void *)v133 + 2);
        unsigned int v135 = CDelaunayTriangles3D::find_one_delaunay3(v80, v18, v19, __p, v134, SHIDWORD(v134));
        if ((v135 & 0x80000000) == 0) {
          break;
        }
        float v18 = v578;
        if (v133 == v132)
        {
          v612[0] = v134;
          goto LABEL_138;
        }
      }
      v612[0] = v134;
      if (v131 == v597)
      {
        LODWORD(v131) = v597;
        float v18 = v578;
        break;
      }
      unsigned int v136 = v135;
      uint64_t v137 = *(void *)(v71 + 224);
      *(_DWORD *)(v137 + 4 * (3 * v131)) = v134;
      *(_DWORD *)(v137 + 4 * (3 * v131 + 1)) = HIDWORD(v134);
      *(_DWORD *)(v137 + 4 * (3 * v131 + 2)) = v135;
      std::list<std::array<int,2ul>>::remove(v80, v612);
      uint64_t v138 = *(void *)(v71 + 192);
      *(_DWORD *)buf = HIDWORD(v134);
      *(_DWORD *)&uint8_t buf[4] = v136;
      std::list<std::array<int,2ul>>::remove(v80, buf);
      uint64_t v139 = *(void *)(v71 + 192);
      if (v139 == v138)
      {
        *(void *)buf = __PAIR64__(HIDWORD(v134), v136);
        CFDictionaryRef v140 = operator new(0x18uLL);
        uint64_t v141 = *(void *)buf;
        v140[1] = v80;
        v140[2] = v141;
        uint64_t v142 = *(void *)(v71 + 176);
        *CFDictionaryRef v140 = v142;
        *(void *)(v142 + 8) = v140;
        *(void *)(v71 + 176) = v140;
        uint64_t v139 = v138 + 1;
        *(void *)(v71 + 192) = v138 + 1;
      }
      *(_DWORD *)buf = v136;
      *(_DWORD *)&uint8_t buf[4] = v134;
      std::list<std::array<int,2ul>>::remove(v80, buf);
      if (*(void *)(v71 + 192) == v139)
      {
        *(void *)buf = __PAIR64__(v136, v134);
        unint64_t v143 = operator new(0x18uLL);
        uint64_t v144 = *(void *)buf;
        v143[1] = v80;
        v143[2] = v144;
        uint64_t v145 = *(void *)(v71 + 176);
        *unint64_t v143 = v145;
        *(void *)(v145 + 8) = v143;
        *(void *)(v71 + 176) = v143;
        *(void *)(v71 + 192) = v139 + 1;
      }
      ++v131;
      unint64_t v116 = v116 & 0xFFFFFFFF00000000 | v136;
      CDelaunayTriangles3D::check_avail_vertices(v80, (unint64_t)v134, v116);
      float v18 = v578;
    }
    while (*(void *)(v71 + 216));
  }
LABEL_138:
  if (v131 != v610)
  {
LABEL_237:
    uint64_t v209 = *(void *)(v71 + 224);
    unint64_t v210 = (*(void *)(v71 + 232) - v209) >> 2;
    if (v131 <= v210)
    {
      if (v131 < v210) {
        *(void *)(a1 + 232) = v209 + 4 * v131;
      }
    }
    else
    {
      std::vector<int>::__append((std::vector<unsigned int> *)(a1 + 224), v131 - v210);
    }
    if (!os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "VBAP.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 792;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = "delaunayTriangulation";
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 792;
    size_t v56 = MEMORY[0x263EF8438];
    goto LABEL_37;
  }
LABEL_139:
  float v18 = v578;
  uint64_t v146 = v71;
  if (*(_DWORD *)v71 != 1 || *(void *)(v71 + 304) < 2uLL) {
    goto LABEL_275;
  }
  vDSP_Length v147 = 0;
  memset(buf, 0, 24);
  v612[1] = 0;
  v612[0] = 0;
  unint64_t v613 = 0;
  uint64_t v149 = *(void *)(v146 + 224);
  uint64_t v148 = *(void *)(v146 + 232);
  if ((unint64_t)(v148 - v149) < 0xC) {
    goto LABEL_271;
  }
  vDSP_Length v147 = 0;
  long long v150 = 0;
  vDSP_Length v151 = 0;
  uint64_t v152 = 0;
  LODWORD(v153) = 0;
  do
  {
    LODWORD(v622) = 0;
    float64x2_t v621 = 0;
    int v154 = 3 * v153;
    unint64_t v155 = ((uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 2) / 3uLL;
    unsigned int v156 = *(_DWORD *)(v149 + 4 * (3 * v153));
    if (v156 >= v155)
    {
      LODWORD(v621) = *(_DWORD *)(v149 + 4 * (3 * v153));
      uint64_t v157 = 1;
      unsigned int v156 = 0;
    }
    else
    {
      uint64_t v157 = 0;
    }
    unsigned int v158 = *(_DWORD *)(v149 + 4 * (v154 + 1));
    if (v158 >= v155) {
      *(_DWORD *)((unint64_t)&v621 | (4 * v157++)) = v158;
    }
    else {
      unsigned int v156 = *(_DWORD *)(v149 + 4 * (v154 + 1));
    }
    unsigned int v159 = *(_DWORD *)(v149 + 4 * (v154 + 2));
    if (v159 >= v155)
    {
      *((_DWORD *)&v621 + v157) = v159;
      if (v157 == 1)
      {
LABEL_156:
        uint64_t v160 = *(char **)&buf[8];
        if (*(void *)&buf[8] >= *(void *)&buf[16])
        {
          CFRange v162 = *(char **)buf;
          uint64_t v163 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 2;
          unint64_t v164 = v163 + 1;
          if ((unint64_t)(v163 + 1) >> 62) {
            goto LABEL_482;
          }
          uint64_t v165 = *(void *)&buf[16] - *(void *)buf;
          if ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 1 > v164) {
            unint64_t v164 = v165 >> 1;
          }
          if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v166 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v166 = v164;
          }
          if (v166)
          {
            if (v166 >> 62) {
              goto LABEL_481;
            }
            unint64_t v167 = v166;
            uint64_t v168 = operator new(4 * v166);
            unint64_t v166 = v167;
          }
          else
          {
            uint64_t v168 = 0;
          }
          unint64_t v169 = (unsigned int *)&v168[4 * v163];
          *unint64_t v169 = v156;
          unint64_t v161 = v169 + 1;
          if (v160 != v162)
          {
            unint64_t v170 = v160 - 4 - v162;
            if (v170 < 0x2C) {
              goto LABEL_489;
            }
            if ((unint64_t)(v162 - v168) < 0x20) {
              goto LABEL_489;
            }
            uint64_t v171 = (v170 >> 2) + 1;
            unsigned __int8 v172 = (float64x2_t *)&v168[4 * v163 - 16];
            uint64_t v173 = (float64x2_t *)(v160 - 16);
            uint64_t v174 = v171 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              float64x2_t v39 = *v173;
              v172[-1] = v173[-1];
              float64x2_t *v172 = v39;
              v172 -= 2;
              v173 -= 2;
              v174 -= 8;
            }
            while (v174);
            v169 -= v171 & 0x7FFFFFFFFFFFFFF8;
            v160 -= 4 * (v171 & 0x7FFFFFFFFFFFFFF8);
            if (v171 != (v171 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_489:
              do
              {
                unsigned int v175 = *((_DWORD *)v160 - 1);
                v160 -= 4;
                *--unint64_t v169 = v175;
              }
              while (v160 != v162);
            }
          }
          *(void *)buf = v169;
          *(void *)&uint8_t buf[16] = &v168[4 * v166];
          if (v162) {
            operator delete(v162);
          }
        }
        else
        {
          **(_DWORD **)&buf[8] = v156;
          unint64_t v161 = v160 + 4;
        }
        *(void *)&buf[8] = v161;
        if (HIDWORD(v621) >= v621) {
          uint64_t v176 = v621;
        }
        else {
          uint64_t v176 = HIDWORD(v621);
        }
        if (v621 <= HIDWORD(v621)) {
          uint64_t v177 = HIDWORD(v621);
        }
        else {
          uint64_t v177 = v621;
        }
        if (v152 < v150)
        {
          *(void *)uint64_t v152 = v176 | (v177 << 32);
          v152 += 8;
          goto LABEL_204;
        }
        uint64_t v178 = (v152 - v147) >> 3;
        unint64_t v179 = v178 + 1;
        if ((unint64_t)(v178 + 1) >> 61) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        if ((v150 - v147) >> 2 > v179) {
          unint64_t v179 = (v150 - v147) >> 2;
        }
        if ((unint64_t)(v150 - v147) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v180 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v180 = v179;
        }
        if (v180)
        {
          if (v180 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          std::string v181 = operator new(8 * v180);
        }
        else
        {
          std::string v181 = 0;
        }
        std::string v182 = &v181[8 * v178];
        *(void *)std::string v182 = v176 | (v177 << 32);
        std::string v183 = v182 + 8;
        if (v152 != v147)
        {
          unint64_t v184 = v152 - 8 - v147;
          if (v184 < 0x168)
          {
            std::string v185 = v152;
            goto LABEL_200;
          }
          if (&v181[v152 - v147 - 8 - (v184 & 0xFFFFFFFFFFFFFFF8)] > &v181[v152 - v147 - 8])
          {
            std::string v185 = v152;
            goto LABEL_200;
          }
          if (&v152[-(v184 & 0xFFFFFFFFFFFFFFF8) - 8] > v152 - 8)
          {
            std::string v185 = v152;
            goto LABEL_200;
          }
          if ((unint64_t)(v147 - v181) < 0x20)
          {
            std::string v185 = v152;
            goto LABEL_200;
          }
          uint64_t v205 = (v184 >> 3) + 1;
          std::string v185 = &v152[-8 * (v205 & 0x3FFFFFFFFFFFFFFCLL)];
          std::string v206 = (float64x2_t *)&v181[8 * v178 - 16];
          unint64_t v207 = (float64x2_t *)(v152 - 16);
          uint64_t v208 = v205 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            float64x2_t v39 = *v207;
            v206[-1] = v207[-1];
            float64x2_t *v206 = v39;
            v206 -= 2;
            v207 -= 2;
            v208 -= 4;
          }
          while (v208);
          v182 -= 8 * (v205 & 0x3FFFFFFFFFFFFFFCLL);
          if (v205 != (v205 & 0x3FFFFFFFFFFFFFFCLL))
          {
            do
            {
LABEL_200:
              uint64_t v186 = *((void *)v185 - 1);
              v185 -= 8;
              *((void *)v182 - 1) = v186;
              v182 -= 8;
            }
            while (v185 != v147);
          }
        }
        long long v150 = &v181[8 * v180];
        if (v147) {
          operator delete(v147);
        }
        vDSP_Length v147 = v182;
        uint64_t v152 = v183;
LABEL_204:
        uint64_t v187 = (char *)v612[1];
        if (v612[1] < (void *)v613)
        {
          *(_DWORD *)v612[1] = v153;
          vDSP_Length v151 = v187 + 4;
        }
        else
        {
          unint64_t v188 = v152;
          uint64_t v189 = v150;
          unint64_t v190 = (char *)v612[0];
          int64_t v191 = (char *)v612[1] - (char *)v612[0];
          int64_t v192 = ((char *)v612[1] - (char *)v612[0]) >> 2;
          unint64_t v193 = v192 + 1;
          if ((unint64_t)(v192 + 1) >> 62) {
LABEL_482:
          }
            std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
          uint64_t v194 = v613 - (unint64_t)v612[0];
          if ((uint64_t)(v613 - (unint64_t)v612[0]) >> 1 > v193) {
            unint64_t v193 = v194 >> 1;
          }
          if ((unint64_t)v194 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v195 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v195 = v193;
          }
          if (v195)
          {
            if (v195 >> 62) {
LABEL_481:
            }
              std::__throw_bad_array_new_length[abi:ne180100]();
            long long v196 = operator new(4 * v195);
          }
          else
          {
            long long v196 = 0;
          }
          int v197 = &v196[4 * v192];
          *(_DWORD *)int v197 = v153;
          vDSP_Length v151 = v197 + 4;
          if (v187 == v190)
          {
            long long v150 = v189;
            uint64_t v152 = v188;
          }
          else
          {
            unint64_t v198 = v187 - 4 - v190;
            if (v198 < 0x2C)
            {
              long long v150 = v189;
              uint64_t v152 = v188;
              goto LABEL_227;
            }
            unint64_t v199 = v187 - &v196[v191];
            long long v150 = v189;
            uint64_t v152 = v188;
            if (v199 < 0x20) {
              goto LABEL_490;
            }
            uint64_t v200 = (v198 >> 2) + 1;
            uint64_t v201 = (float64x2_t *)&v196[4 * v192 - 16];
            unint64_t v202 = (float64x2_t *)(v187 - 16);
            uint64_t v203 = v200 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              float64x2_t v39 = *v202;
              v201[-1] = v202[-1];
              *uint64_t v201 = v39;
              v201 -= 2;
              v202 -= 2;
              v203 -= 8;
            }
            while (v203);
            v197 -= 4 * (v200 & 0x7FFFFFFFFFFFFFF8);
            v187 -= 4 * (v200 & 0x7FFFFFFFFFFFFFF8);
            if (v200 != (v200 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_490:
              do
              {
LABEL_227:
                int v204 = *((_DWORD *)v187 - 1);
                v187 -= 4;
                *((_DWORD *)v197 - 1) = v204;
                v197 -= 4;
              }
              while (v187 != v190);
            }
          }
          v612[0] = v197;
          unint64_t v613 = (unint64_t)&v196[4 * v195];
          if (v190) {
            operator delete(v190);
          }
        }
        v612[1] = v151;
        uint64_t v149 = *(void *)(a1 + 224);
        uint64_t v148 = *(void *)(a1 + 232);
      }
    }
    else
    {
      unsigned int v156 = v159;
      if (v157 == 2) {
        goto LABEL_156;
      }
    }
    unint64_t v153 = (v153 + 1);
  }
  while (v153 < ((v148 - v149) >> 2) / 3uLL);
  std::string v211 = (char *)v612[0];
  if (v152 != v147)
  {
    unint64_t v212 = 0;
    unsigned int v213 = 0;
    unint64_t v214 = (v152 - v147) >> 3;
    uint64_t v216 = *(void *)buf;
    uint64_t v215 = *(unsigned int **)&buf[8];
    uint64_t v600 = v618;
    int v217 = 1;
    while (1)
    {
      unint64_t v218 = v212;
      unint64_t v212 = v213 + 1;
      if (v214 > v212) {
        break;
      }
LABEL_246:
      unint64_t v214 = (v152 - v147) >> 3;
      ++v217;
      unsigned int v213 = v212;
      if (v214 <= v212)
      {
        std::string v211 = (char *)v612[0];
        goto LABEL_269;
      }
    }
    int v219 = 0;
    v39.f64[0] = *(float64_t *)&v147[8 * v218];
    unsigned int v220 = v217;
    unint64_t v221 = v213 + 1;
    while (1)
    {
      int v222 = v213 + v219;
      int32x2_t v223 = vceq_s32(*(int32x2_t *)&v39.f64[0], *(int32x2_t *)&v147[8 * v221]);
      if (v223.i32[0] & v223.i32[1]) {
        break;
      }
      unint64_t v221 = (v222 + 2);
      ++v219;
      ++v220;
      if (v214 <= v221) {
        goto LABEL_246;
      }
    }
    uint64_t v224 = 4 * v218;
    uint64_t v225 = *(unsigned int *)(v216 + 4 * v218);
    v226.f64[0] = v600[v225];
    v226.f64[1] = v608[v225];
    a8.n128_f64[0] = __p[v225];
    int v227 = (char *)(v216 + 4 * v221);
    uint64_t v228 = *(unsigned int *)v227;
    v47.f64[0] = v600[v228];
    v229.f64[0] = __p[v228];
    uint64_t v230 = LODWORD(v39.f64[0]);
    v39.f64[0] = v600[v230];
    v231.f64[0] = __p[v230];
    v52.f64[0] = v608[v228];
    float64x2_t v232 = vmulq_f64(v39, v52);
    v52.f64[1] = v229.f64[0];
    v229.f64[1] = v47.f64[0];
    v48.f64[0] = v608[v230];
    unsigned int v233 = v222 + 1;
    float64x2_t v234 = vmlaq_f64(vnegq_f64(v232), v47, v48);
    v48.f64[1] = v231.f64[0];
    v231.f64[1] = v39.f64[0];
    float64x2_t v39 = vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v48, v229)), v52, v231), v226);
    v39.f64[0] = vaddvq_f64(v39) + vmulq_f64(v234, (float64x2_t)a8).f64[0];
    if (v39.f64[0] >= 0.0) {
      unsigned int v235 = v213;
    }
    else {
      unsigned int v235 = v233;
    }
    if (v39.f64[0] >= 0.0) {
      unsigned int v213 = v233;
    }
    uint64_t v236 = 4 * v235;
    uint64_t v237 = *(void *)(a1 + 224);
    *(_DWORD *)(v237 + 4 * (3 * *(_DWORD *)&v211[v224])) = *(_DWORD *)(v216 + v236);
    uint64_t v238 = 4 * v213;
    *(_DWORD *)(v237 + 4 * (3 * *(_DWORD *)&v211[v224] + 1)) = *(_DWORD *)(v216 + v238);
    int v239 = &v147[8 * v221];
    *(_DWORD *)(v237 + 4 * (3 * *(_DWORD *)&v211[v224] + 2)) = *(_DWORD *)v239;
    uint64_t v240 = &v211[4 * v221];
    *(_DWORD *)(v237 + 4 * (3 * *(_DWORD *)v240)) = *(_DWORD *)(v216 + v238);
    *(_DWORD *)(v237 + 4 * (3 * *(_DWORD *)v240 + 1)) = *(_DWORD *)(v216 + v236);
    *(_DWORD *)(v237 + 4 * (3 * *(_DWORD *)v240 + 2)) = *((_DWORD *)v239 + 1);
    uint64_t v241 = v239 + 8;
    if (v239 + 8 != v152)
    {
      unint64_t v242 = v152 - &v147[8 * (v219 + v212)] - 16;
      if (v242 < 0x38)
      {
        do
        {
LABEL_263:
          *(_DWORD *)int v239 = *(_DWORD *)v241;
          *((_DWORD *)v239 + 1) = *((_DWORD *)v241 + 1);
          v239 += 8;
          v241 += 8;
        }
        while (v241 != v152);
      }
      else
      {
        uint64_t v243 = (v242 >> 3) + 1;
        uint64_t v244 = 8 * (v243 & 0x3FFFFFFFFFFFFFF8);
        v239 += v244;
        uint64_t v245 = 8 * v220;
        unint64_t v246 = (((unint64_t)&v152[-16 - (void)v147 - v245] >> 3) + 1) & 0x3FFFFFFFFFFFFFF8;
        CFArrayRef v247 = &v147[v245 + 40];
        do
        {
          float64x2_t v39 = *((float64x2_t *)v247 - 1);
          float64x2_t v47 = *(float64x2_t *)v247;
          a8 = *((__n128 *)v247 + 1);
          *(_OWORD *)(v247 - 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = *((_OWORD *)v247 - 2);
          *(float64x2_t *)(v247 - 24) = v39;
          *(float64x2_t *)(v247 - 8) = v47;
          *(__n128 *)(v247 + 8) = a8;
          v247 += 64;
          v246 -= 8;
        }
        while (v246);
        if (v243 != (v243 & 0x3FFFFFFFFFFFFFF8))
        {
          v241 += v244;
          goto LABEL_263;
        }
      }
    }
    uint64_t v152 = v239;
    int64_t v248 = (char *)v215 - (v227 + 4);
    if (v215 != (unsigned int *)(v227 + 4)) {
      memmove(v227, v227 + 4, (char *)v215 - (v227 + 4));
    }
    size_t v249 = v151 - (v240 + 4);
    if (v249) {
      memmove(v240, v240 + 4, v249);
    }
    uint64_t v215 = (unsigned int *)&v227[v248];
    vDSP_Length v151 = &v240[v249];
    goto LABEL_246;
  }
LABEL_269:
  float v18 = v578;
  if (v211) {
    operator delete(v211);
  }
LABEL_271:
  if (*(void *)buf) {
    operator delete(*(void **)buf);
  }
  uint64_t v146 = a1;
  if (v147) {
    operator delete(v147);
  }
LABEL_275:
  int v250 = *(double **)(v146 + 248);
  uint64_t v251 = *(void *)(v146 + 232) - *(void *)(v146 + 224);
  unint64_t v252 = (v251 >> 1) + (v251 >> 2);
  uint64_t v253 = *(double **)(v146 + 256);
  unint64_t v254 = v253 - v250;
  if (v252 <= v254)
  {
    if (v252 < v254)
    {
      uint64_t v253 = &v250[v252];
      *(void *)(v146 + 256) = v253;
    }
  }
  else
  {
    std::vector<double>::__append((char **)(v146 + 248), v252 - v254);
    int v250 = *(double **)(a1 + 248);
    uint64_t v253 = *(double **)(a1 + 256);
  }
  vDSP_vclrD(v250, 1, v253 - v250);
  uint64_t v262 = a1;
  uint64_t v264 = *(void *)(a1 + 224);
  uint64_t v263 = *(void *)(a1 + 232);
  double v265 = 0.0;
  if ((unint64_t)(v263 - v264) >= 0xC)
  {
    unsigned int v266 = 1;
    unsigned int v267 = 8;
    unsigned int v268 = 2;
    do
    {
      uint64_t v270 = *(int *)(v264 + 4 * (v268 - 2));
      v271.f64[0] = v18[v270];
      v271.f64[1] = v608[v270];
      v255.f64[0] = __p[v270];
      uint64_t v272 = *(int *)(v264 + 4 * (v268 - 1));
      v256.f64[0] = v18[v272];
      v259.f64[0] = v608[v272];
      *(double *)&long long v257 = __p[v272];
      uint64_t v273 = *(int *)(v264 + 4 * v268);
      v258.f64[0] = v18[v273];
      v261.f64[0] = v608[v273];
      *(double *)&long long v260 = __p[v273];
      v274.f64[0] = v259.f64[0];
      *(void *)&v274.f64[1] = v257;
      *(void *)&v275.f64[0] = v260;
      v275.f64[1] = v258.f64[0];
      *(void *)&v276.f64[0] = v257;
      v276.f64[1] = v256.f64[0];
      v277.f64[0] = v261.f64[0];
      *(void *)&v277.f64[1] = v260;
      if (fabs(vaddvq_f64(vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v277, v276)), v274, v275), v271))+ vmulq_f64(vmlaq_f64(vnegq_f64(vmulq_f64(v258, v259)), v256, v261), v255).f64[0]) > 0.00000011920929)
      {
        v256.f64[1] = v259.f64[0];
        v258.f64[1] = v608[*(int *)(v264 + 4 * v268)];
        *(float64x2_t *)buf = v271;
        *(float64x2_t *)&uint8_t buf[16] = v255;
        *(float64x2_t *)&buf[32] = v256;
        long long v625 = v257;
        float64x2_t v626 = v258;
        long long v627 = v260;
        __invert_d3();
        v278 = v612[1];
        float64x2_t v255 = v614;
        float64x2_t v256 = v616;
        *(void *)&long long v257 = v613;
        v258.f64[0] = v615;
        v259.f64[0] = v617;
        uint64_t v279 = *(void *)(a1 + 248);
        *(void **)(v279 + 8 * (v267 - 8)) = v612[0];
        *(float64_t *)(v279 + 8 * (v267 - 7)) = v255.f64[0];
        *(float64_t *)(v279 + 8 * (v267 - 6)) = v256.f64[0];
        *(void *)(v279 + 8 * (v267 - 5)) = v278;
        *(float64_t *)(v279 + 8 * (v267 - 4)) = v255.f64[1];
        *(float64_t *)(v279 + 8 * (v267 - 3)) = v256.f64[1];
        *(void *)(v279 + 8 * (v267 - 2)) = v257;
        *(float64_t *)(v279 + 8 * (v267 - 1)) = v258.f64[0];
        *(float64_t *)(v279 + 8 * v267) = v259.f64[0];
        uint64_t v264 = *(void *)(a1 + 224);
        uint64_t v263 = *(void *)(a1 + 232);
      }
      unint64_t v269 = ((v263 - v264) >> 2) / 3uLL;
      BOOL v519 = v269 > v266++;
      v267 += 9;
      v268 += 3;
    }
    while (v519);
    double v265 = (float)v269 * 0.125;
    uint64_t v262 = a1;
  }
  int v280 = vcvtmd_s64_f64(log(v265) * 0.72134752);
  if (v280 >= 6) {
    int v280 = 6;
  }
  uint64_t v281 = (uint64_t *)(v262 + 272);
  uint64_t v574 = (uint64_t *)(v262 + 272);
  if (v603 != v610
    || (int v282 = v280 & ~(v280 >> 31),
        unint64_t v283 = (8 << (2 * (v280 & ~(v280 >> 31)))),
        uint64_t v285 = *v605,
        uint64_t v284 = v605[1],
        0xAAAAAAAAAAAAAAABLL * ((v284 - *v605) >> 3) != v283))
  {
    unint64_t v296 = *(uint64_t **)(v262 + 272);
    unint64_t v295 = *(uint64_t **)(v262 + 280);
    if (v295 != v296)
    {
      do
      {
        uint64_t v297 = v295 - 3;
        if (*(v295 - 1))
        {
          uint64_t v299 = *(v295 - 3);
          uint64_t v298 = (uint64_t *)*(v295 - 2);
          uint64_t v300 = *v298;
          *(void *)(v300 + 8) = *(void *)(v299 + 8);
          **(void **)(v299 + 8) = v300;
          *(v295 - 1) = 0;
          if (v298 != v297)
          {
            do
            {
              int v301 = (uint64_t *)v298[1];
              operator delete(v298);
              uint64_t v298 = v301;
            }
            while (v301 != v297);
          }
        }
        unint64_t v295 = v297;
      }
      while (v297 != v296);
      uint64_t v264 = *(void *)(v262 + 224);
      uint64_t v263 = *(void *)(v262 + 232);
    }
    *(void *)(v262 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v296;
    unint64_t v302 = ((v263 - v264) >> 2) / 3uLL;
    int v303 = vcvtmd_s64_f64(log((float)v302 * 0.125) * 0.72134752);
    int v571 = v303;
    if (v303 >= 6) {
      int v304 = 6;
    }
    else {
      int v304 = v303;
    }
    unint64_t v577 = v304 & ~(v304 >> 31);
    char v305 = 2 * (v304 & ~(v304 >> 31));
    uint64_t v306 = (char *)operator new(96 << (v305 + 3));
    int64_t v307 = 96 * (((96 << (v305 + 3)) - 96) / 0x60uLL) + 96;
    bzero(v306, v307);
    uint64_t v309 = 0;
    if (8 << v305 <= 1) {
      uint64_t v310 = 1;
    }
    else {
      uint64_t v310 = (8 << v305);
    }
    float64x2_t v312 = *(float64x2_t *)MEMORY[0x263EF8988];
    float64x2_t v311 = *(float64x2_t *)(MEMORY[0x263EF8988] + 16);
    float64x2_t v314 = *(float64x2_t *)(MEMORY[0x263EF8988] + 32);
    float64x2_t v313 = *(float64x2_t *)(MEMORY[0x263EF8988] + 48);
    float64x2_t v316 = *(float64x2_t *)(MEMORY[0x263EF8988] + 64);
    float64x2_t v315 = *(float64x2_t *)(MEMORY[0x263EF8988] + 80);
    float64x2_t v317 = (float64x2_t)vdupq_n_s64(0x416312D000000000uLL);
    float64x2_t v318 = (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
    v308.f64[0] = 0.0000001;
    uint64_t v319 = a1;
    while (1)
    {
      float64x2_t v324 = v312;
      __asm { FMOV            V19.2D, #1.0 }
      float64x2_t v611 = _Q19;
      float64x2_t v327 = v311;
      float64x2_t v328 = v314;
      float64x2_t v329 = v313;
      float64x2_t v330 = v316;
      float64x2_t v331 = v315;
      unsigned int v332 = v309;
      uint64_t v333 = v304 & ~(v304 >> 31);
      if (v304 >= 1) {
        break;
      }
LABEL_319:
      float64x2_t v334 = vmulq_f64(v327, v327);
      v334.f64[0] = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v324, v324)) + v334.f64[0]);
      float64x2_t v335 = vmulq_f64(v329, v329);
      v335.f64[0] = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v328, v328)) + v335.f64[0]);
      float64x2_t v336 = vmulq_f64(v331, v331);
      float64x2_t v337 = vmulq_f64(v330, v330);
      v336.f64[0] = 1.0 / sqrt(vaddvq_f64(v337) + v336.f64[0]);
      v337.f64[0] = 10000000.0;
      unint64_t v338 = *(_OWORD *)&vmulq_f64(v335, vmulq_f64(v329, v337));
      float64x2_t v339 = vmulq_f64(vmulq_n_f64(v328, v335.f64[0]), v317);
      unint64_t v340 = *(_OWORD *)&vmulq_f64(v336, vmulq_f64(v331, v337));
      float64x2_t v341 = vmulq_f64(vmulq_n_f64(v330, v336.f64[0]), v317);
      uint64_t v342 = (float64x2_t *)&v306[96 * v309];
      float64x2_t v320 = vrndxq_f64(vmulq_f64(vmulq_n_f64(v324, v334.f64[0]), v317));
      float64x2_t v343 = vrndxq_f64((float64x2_t)(unint64_t)*(_OWORD *)&vmulq_f64(v334, vmulq_f64(v327, v337)));
      float64x2_t v344 = vrndxq_f64(v339);
      float64x2_t v345 = vmulq_f64(v344, v318);
      v342[2] = v345;
      uint64_t v346 = v342 + 2;
      float64x2_t v347 = vrndxq_f64((float64x2_t)v338);
      float64x2_t v348 = vrndxq_f64(v341);
      float64x2_t v349 = vmulq_f64(v348, v318);
      v342[4] = v349;
      float64x2_t v350 = vrndxq_f64((float64x2_t)v340);
      float64x2_t v351 = vmulq_f64(v343, v308);
      float64x2_t v352 = vmulq_f64(v320, v318);
      float64x2_t v353 = vmulq_f64(v347, v308);
      *uint64_t v342 = v352;
      v342[1] = v351;
      float64x2_t v354 = vmulq_f64(v350, v308);
      v342[3] = v353;
      v342[5] = v354;
      unint64_t v355 = vextq_s8((int8x16_t)v320, (int8x16_t)v320, 8uLL).u64[0];
      unint64_t v356 = vextq_s8((int8x16_t)v344, (int8x16_t)v344, 8uLL).u64[0];
      unint64_t v357 = vextq_s8((int8x16_t)v348, (int8x16_t)v348, 8uLL).u64[0];
      switch(v332 & 7)
      {
        case 0u:
          *uint64_t v342 = vnegq_f64(v352);
          v342[1] = vnegq_f64(v351);
          v342[2] = vnegq_f64(v345);
          v342[3] = vnegq_f64(v353);
          v342[4] = vnegq_f64(v349);
          v342[5] = vnegq_f64(v354);
          break;
        case 1u:
          *(void *)&v320.f64[1] = v355;
          float64x2_t v321 = (float64x2_t)vdupq_n_s64(0xBE7AD7F29ABCAF48);
          goto LABEL_315;
        case 2u:
          *(void *)&v320.f64[1] = v355;
          float64x2_t v378 = (float64x2_t)xmmword_21B551440;
          goto LABEL_340;
        case 3u:
          *(void *)&v320.f64[1] = v355;
          float64x2_t v321 = (float64x2_t)xmmword_21B551440;
          goto LABEL_315;
        case 4u:
          *(void *)&v320.f64[1] = v355;
          float64x2_t v378 = (float64x2_t)xmmword_21B551430;
LABEL_340:
          v349.f64[0] = -0.0000001;
          *uint64_t v342 = vmulq_f64(v320, v378);
          v342[1] = vmulq_f64(v343, v349);
          *(void *)&v344.f64[1] = v356;
          *uint64_t v346 = vmulq_f64(v344, v378);
          v342[3] = vmulq_f64(v347, v349);
          *(void *)&v348.f64[1] = v357;
          float64x2_t v322 = vmulq_f64(v348, v378);
          float64x2_t v323 = vmulq_f64(v350, v349);
          goto LABEL_316;
        case 5u:
          *(void *)&v320.f64[1] = v355;
          float64x2_t v321 = (float64x2_t)xmmword_21B551430;
LABEL_315:
          *uint64_t v342 = vmulq_f64(v320, v321);
          v342[1] = vmulq_f64(v343, v308);
          *(void *)&v344.f64[1] = v356;
          *uint64_t v346 = vmulq_f64(v344, v321);
          v342[3] = vmulq_f64(v347, v308);
          *(void *)&v348.f64[1] = v357;
          float64x2_t v322 = vmulq_f64(v348, v321);
          float64x2_t v323 = vmulq_f64(v350, v308);
          goto LABEL_316;
        case 6u:
          *(void *)&v320.f64[1] = v355;
          v345.f64[0] = -0.0000001;
          *uint64_t v342 = vmulq_f64(v320, v318);
          v342[1] = vmulq_f64(v343, v345);
          *(void *)&v344.f64[1] = v356;
          *uint64_t v346 = vmulq_f64(v344, v318);
          v342[3] = vmulq_f64(v347, v345);
          *(void *)&v348.f64[1] = v357;
          float64x2_t v322 = vmulq_f64(v348, v318);
          float64x2_t v323 = vmulq_f64(v350, v345);
LABEL_316:
          v342[4] = v322;
          v342[5] = v323;
          break;
        default:
          break;
      }
      if (++v309 == v310)
      {
        int64x2_t v595 = v306;
        unint64_t v379 = 0xAAAAAAAAAAAAAAABLL * (v307 >> 5);
        uint64_t v381 = *(void *)(a1 + 272);
        uint64_t v380 = *(uint64_t **)(a1 + 280);
        unint64_t v382 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v380 - v381) >> 3);
        if (v379 <= v382)
        {
          if (v379 < v382)
          {
            uint64_t v383 = (uint64_t *)(v381 + 8 * (v307 >> 5));
            if (v380 != v383)
            {
              do
              {
                unint64_t v545 = v380 - 3;
                if (*(v380 - 1))
                {
                  uint64_t v547 = *(v380 - 3);
                  uint64_t v546 = (uint64_t *)*(v380 - 2);
                  uint64_t v548 = *v546;
                  *(void *)(v548 + 8) = *(void *)(v547 + 8);
                  **(void **)(v547 + 8) = v548;
                  *(v380 - 1) = 0;
                  if (v546 != v545)
                  {
                    do
                    {
                      v549 = (uint64_t *)v546[1];
                      operator delete(v546);
                      uint64_t v546 = v549;
                    }
                    while (v549 != v545);
                  }
                }
                uint64_t v380 = v545;
              }
              while (v545 != v383);
            }
            uint64_t v319 = a1;
            *(void *)(a1 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v383;
          }
        }
        else
        {
          std::vector<std::list<int>>::__append(v281, v379 - v382);
        }
        if (!v302)
        {
LABEL_457:
          operator delete(v595);
          uint64_t v57 = 0;
          *(_DWORD *)(v319 + 296) = v577;
LABEL_39:
          uint64_t v58 = v608;
          unint64_t v59 = __p;
          if (!__p) {
            goto LABEL_41;
          }
          goto LABEL_40;
        }
        uint64_t v384 = 0;
        unsigned int v572 = ~(-1 << v305);
        unsigned int v573 = ((7 << v305) >> 2) | (7 << v305);
        int v565 = (7 << v305) | (v573 >> 2);
        unsigned int v385 = ((7 << v305) >> 2) | v565;
        unsigned int v386 = v385 >> 2;
        unsigned int v387 = (v385 >> 2) | v385;
        unsigned int v562 = (7 << v305) | (((v387 >> 2) | v387) >> 2);
        int v564 = v386 | (7 << v305);
        int v563 = (v387 >> 2) | (7 << v305);
        while (1)
        {
          uint64_t v388 = *(int *)(*(void *)(v319 + 224) + 12 * v384);
          v313.f64[0] = __p[v388];
          double v593 = v18[v388];
          double v604 = v608[v388];
          float64x2_t v606 = v313;
          int subtriangle_containment = CDelaunayTriangles3D::find_subtriangle_containment(v577, v593, v604, v313.f64[0]);
          uint64_t v390 = *(int *)(12 * v384 + *(void *)(v319 + 224) + 4);
          v391.f64[0] = __p[v390];
          float64x2_t v586 = v391;
          double v587 = v18[v390];
          double v601 = v608[v390];
          int v392 = CDelaunayTriangles3D::find_subtriangle_containment(v577, v587, v601, v391.f64[0]);
          v393 = v18;
          int v394 = v392;
          uint64_t v395 = *(int *)(12 * v384 + *(void *)(v319 + 224) + 8);
          v396.f64[0] = v393[v395];
          v397.f64[0] = __p[v395];
          float64x2_t v575 = v397;
          float64x2_t v576 = v396;
          double v598 = v608[v395];
          int v398 = CDelaunayTriangles3D::find_subtriangle_containment(v577, v396.f64[0], v598, v397.f64[0]);
          v612[0] = v612;
          v612[1] = v612;
          unint64_t v613 = 0;
          signed int v399 = operator new(0x18uLL);
          *((_DWORD *)v399 + 4) = subtriangle_containment;
          *signed int v399 = v612;
          v399[1] = v612;
          v612[1] = v399;
          v612[0] = v399;
          unint64_t v400 = 1;
          v401 = v399;
          unint64_t v613 = 1;
          if (v394 != subtriangle_containment)
          {
            v401 = operator new(0x18uLL);
            *((_DWORD *)v401 + 4) = v394;
            void *v401 = v399;
            v401[1] = v612;
            v399[1] = v401;
            unint64_t v400 = 2;
            v612[0] = v401;
            unint64_t v613 = 2;
          }
          _ZF = v398 == subtriangle_containment || v398 == v394;
          if (!_ZF)
          {
            v403 = operator new(0x18uLL);
            v403[4] = v398;
            *(void *)v403 = v401;
            *((void *)v403 + 1) = v612;
            v401[1] = v403;
            ++v400;
            v612[0] = v403;
            unint64_t v613 = v400;
          }
          std::list<int>::__sort<std::__less<void,void>>((uint64_t)v399, (uint64_t)v612, v400);
          unsigned int v404 = (void **)v612[1];
          int v405 = *((_DWORD *)v612[1] + 4);
          float v18 = v578;
          if (v613 >= 2) {
            break;
          }
          uint64_t v416 = *v574;
          unint64_t v417 = operator new(0x18uLL);
          unsigned int v418 = (uint64_t *)(v416 + 24 * v405);
          v417[4] = v384;
          *((void *)v417 + 1) = v418;
          uint64_t v419 = *v418;
          *(void *)unint64_t v417 = *v418;
          *(void *)(v419 + 8) = v417;
          *unsigned int v418 = (uint64_t)v417;
          ++v418[2];
LABEL_448:
          uint64_t v319 = a1;
          if (v613)
          {
            v541 = (void **)v612[1];
            v542 = (void **)v612[0];
            uint64_t v543 = *(void *)v612[1];
            *(void *)(v543 + 8) = *((void *)v612[0] + 1);
            *v542[1] = v543;
            unint64_t v613 = 0;
            if (v541 != v612)
            {
              do
              {
                uint64_t v544 = (void **)v541[1];
                operator delete(v541);
                v541 = v544;
              }
              while (v544 != v612);
            }
          }
          if (++v384 == v302) {
            goto LABEL_457;
          }
        }
        int v406 = 0;
        int v407 = *((_DWORD *)v612[0] + 4) ^ v405;
        unsigned int v408 = v574;
        if (((7 << v305) & v407) != 0)
        {
          int v409 = v379 - 1;
        }
        else
        {
          int v409 = v379 - 1;
          if (v571 >= 1)
          {
            int v410 = ~(-1 << v305);
            int v411 = 7 << v305;
            if ((v573 & v407) == 0)
            {
              int v410 = ~(-1 << v305);
              int v411 = 7 << v305;
              if (v577 >= 2)
              {
                int v410 = v572 >> 2;
                int v411 = ((7 << v305) >> 2) | (7 << v305);
                if ((v565 & v407) == 0)
                {
                  int v410 = v572 >> 2;
                  int v411 = ((7 << v305) >> 2) | (7 << v305);
                  if (v577 >= 3)
                  {
                    int v410 = v572 >> 4;
                    int v411 = (7 << v305) | (v573 >> 2);
                    if ((v564 & v407) == 0)
                    {
                      int v410 = v572 >> 4;
                      int v411 = (7 << v305) | (v573 >> 2);
                      if (v577 >= 4)
                      {
                        int v410 = v572 >> 6;
                        int v411 = v564;
                        if ((v563 & v407) == 0)
                        {
                          int v410 = v572 >> 6;
                          int v411 = v564;
                          if (v577 >= 5)
                          {
                            BOOL v412 = v577 > 5;
                            int v411 = v562;
                            BOOL v413 = (v562 & v407) == 0;
                            BOOL v414 = !v413 || !v412;
                            char v415 = v413 && v412 ? 10 : 8;
                            int v410 = v572 >> v415;
                            if (v414) {
                              int v411 = v563;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            int v406 = v411 & v405;
            int v409 = v410 | v405;
          }
        }
        v420 = &v621;
        float64x2_t v621 = &v621;
        float32x2_t v622 = &v621;
        uint64_t v623 = 0;
        if (v409 - v406 != -1)
        {
          uint64_t v421 = 0;
          uint64_t v422 = v409 - v406 + 1;
          uint64_t v423 = &v621;
          do
          {
            v424 = operator new(0x18uLL);
            v424[4] = 0;
            *(void *)v424 = v423;
            *((void *)v424 + 1) = &v621;
            v423[1] = v424;
            ++v421;
            uint64_t v423 = v424;
            float64x2_t v621 = v424;
            uint64_t v623 = v421;
          }
          while (v422 != v421);
          v420 = v622;
          if (v622 == &v621)
          {
            v420 = &v621;
            unsigned int v408 = v574;
            if (v404 == v612)
            {
LABEL_386:
              if (v420 == &v621)
              {
LABEL_445:
                if (v623)
                {
                  v538 = v621;
                  vDSP_Length v537 = v622;
                  uint64_t v539 = *v622;
                  *(void *)(v539 + 8) = *((void *)v621 + 1);
                  **((void **)v538 + 1) = v539;
                  uint64_t v623 = 0;
                  if (v537 != &v621)
                  {
                    do
                    {
                      unint64_t v540 = (void *)v537[1];
                      operator delete(v537);
                      vDSP_Length v537 = v540;
                    }
                    while (v540 != &v621);
                  }
                }
                goto LABEL_448;
              }
LABEL_413:
              *(double *)v446.i64 = v593;
              *(double *)&v446.i64[1] = v604;
              *(double *)v447.i64 = v587;
              *(double *)&v447.i64[1] = v601;
              v448.i64[0] = *(void *)&v576.f64[0];
              *(double *)&v448.i64[1] = v598;
              uint64_t v449 = *v408;
              v450.f64[0] = v606.f64[0];
              v450.f64[1] = v593;
              v451.f64[0] = v586.f64[0];
              v451.f64[1] = v587;
              int64x2_t v452 = (int64x2_t)vmlaq_f64(vnegq_f64(vmulq_f64(v451, (float64x2_t)v446)), v450, (float64x2_t)v447);
              *(void *)&double v602 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v606, (float64x2_t)v447, 1)), v586, (float64x2_t)v446, 1);
              float64x2_t v596 = (float64x2_t)vdupq_laneq_s64(v452, 1);
              float64x2_t v599 = (float64x2_t)vdupq_lane_s64(v452.i64[0], 0);
              v453.f64[0] = v575.f64[0];
              v453.f64[1] = v576.f64[0];
              int64x2_t v454 = (int64x2_t)vmlaq_f64(vnegq_f64(vmulq_f64(v453, (float64x2_t)v447)), v451, (float64x2_t)v448);
              *(void *)&double v592 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v586, (float64x2_t)v448, 1)), v575, (float64x2_t)v447, 1);
              float64x2_t v590 = (float64x2_t)vdupq_lane_s64(v454.i64[0], 0);
              int64x2_t v588 = v447;
              float64x2_t v589 = (float64x2_t)vdupq_laneq_s64(v454, 1);
              int64x2_t v455 = (int64x2_t)vmlaq_f64(vnegq_f64(vmulq_f64(v453, (float64x2_t)v446)), v450, (float64x2_t)v448);
              int8x16_t v456 = (int8x16_t)vzip1q_s64((int64x2_t)v606, (int64x2_t)v586);
              *(void *)&double v584 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v606, (float64x2_t)v448, 1)), v575, (float64x2_t)v446, 1);
              float64x2_t v582 = (float64x2_t)vdupq_laneq_s64(v455, 1);
              float64x2_t v583 = (float64x2_t)vdupq_lane_s64(v455.i64[0], 0);
              int64x2_t v594 = v446;
              int64x2_t v591 = (int64x2_t)*(unint64_t *)&v606.f64[0];
              float64x2_t v579 = (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v606.f64[0], (int64x2_t)*(unint64_t *)&v586.f64[0]);
              float64x2_t v580 = (float64x2_t)vzip2q_s64(v446, v447);
              float64x2_t v581 = (float64x2_t)vzip1q_s64(v446, v447);
              unint64_t v568 = vextq_s8((int8x16_t)v580, (int8x16_t)v580, 8uLL).u64[0];
              unint64_t v569 = vextq_s8((int8x16_t)v581, (int8x16_t)v581, 8uLL).u64[0];
              int64x2_t v607 = v448;
              uint64_t v570 = v456.i64[0];
              unint64_t v566 = vextq_s8(v456, v456, 8uLL).u64[0];
              float64x2_t v567 = (float64x2_t)vextq_s8((int8x16_t)v448, (int8x16_t)v448, 8uLL);
              do
              {
                int v457 = *((_DWORD *)v420 + 4);
                float v458 = (float64x2_t *)&v595[96 * v457];
                float64x2_t v459 = *v458;
                float64x2_t v313 = v458[1];
                float64x2_t v461 = v458[2];
                float64x2_t v460 = v458[3];
                float64x2_t v463 = v458[4];
                float64x2_t v462 = v458[5];
                int64x2_t v464 = (int64x2_t)*(unint64_t *)&v458[1].f64[0];
                int64x2_t v465 = (int64x2_t)*(unint64_t *)&v458[3].f64[0];
                int64x2_t v466 = (int64x2_t)*(unint64_t *)&v458[5].f64[0];
                float64x2_t v467 = (float64x2_t)vzip1q_s64(*(int64x2_t *)v458, (int64x2_t)v461);
                float64x2_t v468 = (float64x2_t)vzip2q_s64(*(int64x2_t *)v458, (int64x2_t)v461);
                float64x2_t v469 = (float64x2_t)vzip1q_s64((int64x2_t)v464.u64[0], (int64x2_t)v465.u64[0]);
                float64x2_t v470 = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v467, v602), v599, v468), v596, v469);
                float64x2_t v471 = vmlaq_f64(vmlaq_f64(vmulq_n_f64((float64x2_t)vzip1q_s64((int64x2_t)v463, v607), v602), v599, (float64x2_t)vzip2q_s64((int64x2_t)v463, v607)), v596, (float64x2_t)vzip1q_s64((int64x2_t)v466.u64[0], (int64x2_t)*(unint64_t *)&v575.f64[0]));
                int8x16_t v472 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
                float64x2_t v473 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v471, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v471));
                double v474 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v470, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v470)))+ v473.f64[0];
                v473.f64[0] = v474;
                *(int8x8_t *)&v473.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v473)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v473)));
                if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v473.f64[0], vdup_lane_s32(*(int32x2_t *)&v473.f64[0], 1))).u8[0] & 1) == 0|| fabs(v474) != 3.0)
                {
                  float64x2_t v475 = vmlaq_f64(vmlaq_f64(vmulq_n_f64((float64x2_t)vzip1q_s64((int64x2_t)v463, v594), v592), v590, (float64x2_t)vzip2q_s64((int64x2_t)v463, v594)), v589, (float64x2_t)vzip1q_s64(v466, v591));
                  float64x2_t v476 = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v467, v592), v590, v468), v589, v469);
                  float64x2_t v477 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v475, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v475));
                  double v478 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v476, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v476)))+ v477.f64[0];
                  v477.f64[0] = v478;
                  *(int8x8_t *)&v477.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v477)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v477)));
                  if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v477.f64[0], vdup_lane_s32(*(int32x2_t *)&v477.f64[0], 1))).u8[0] & 1) == 0|| fabs(v478) != 3.0)
                  {
                    float64x2_t v479 = vmlaq_f64(vmlaq_f64(vmulq_n_f64((float64x2_t)vzip1q_s64((int64x2_t)v463, v588), v584), v583, (float64x2_t)vzip2q_s64((int64x2_t)v463, v588)), v582, (float64x2_t)vzip1q_s64(v466, (int64x2_t)*(unint64_t *)&v586.f64[0]));
                    float64x2_t v480 = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v467, v584), v583, v468), v582, v469);
                    float64x2_t v481 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v479, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v479));
                    double v482 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v480, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v480)))+ v481.f64[0];
                    v481.f64[0] = v482;
                    *(int8x8_t *)&v481.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v481)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v481)));
                    if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v481.f64[0], vdup_lane_s32(*(int32x2_t *)&v481.f64[0], 1))).u8[0] & 1) == 0|| fabs(v482) != 3.0)
                    {
                      v483.f64[0] = v458[1].f64[0];
                      v483.f64[1] = v458->f64[0];
                      v484.f64[0] = v458[3].f64[0];
                      v484.f64[1] = v458[2].f64[0];
                      float64x2_t v485 = vmlaq_f64(vnegq_f64(vmulq_f64(v484, v459)), v483, v461);
                      *(void *)&double v486 = *(_OWORD *)&vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v313, v461, 1)), v460, v459, 1);
                      float64x2_t v487 = vmulq_n_f64((float64x2_t)vzip1q_s64(v607, (int64x2_t)v463), v486);
                      float64x2_t v488 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v581, v486), v580, v485.f64[0]), v579, v485, 1);
                      float64x2_t v489 = vmlaq_laneq_f64(vmlaq_n_f64(v487, (float64x2_t)vzip2q_s64(v607, (int64x2_t)v463), v485.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v575.f64[0], v466), v485, 1);
                      float64x2_t v490 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v489, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v489));
                      double v491 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v488, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v488)))+ v490.f64[0];
                      v490.f64[0] = v491;
                      *(int8x8_t *)&v488.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v490)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v490)));
                      if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v488.f64[0], vdup_lane_s32(*(int32x2_t *)&v488.f64[0], 1))).u8[0] & 1) == 0|| fabs(v491) != 3.0)
                      {
                        *(void *)&v484.f64[1] = vextq_s8((int8x16_t)v484, (int8x16_t)v484, 8uLL).u64[0];
                        v492.f64[0] = v458[5].f64[0];
                        v492.f64[1] = v458[4].f64[0];
                        v493.f64[0] = v458[2].f64[0];
                        *(void *)&v493.f64[1] = vextq_s8((int8x16_t)v461, (int8x16_t)v461, 8uLL).u64[0];
                        float64x2_t v494 = vmlaq_f64(vnegq_f64(vmulq_f64(v492, v493)), v484, v463);
                        *(void *)&double v495 = *(_OWORD *)&vmlaq_f64(vnegq_f64(vmulq_laneq_f64(v460, v463, 1)), (float64x2_t)vdupq_laneq_s64((int64x2_t)v461, 1), v462);
                        float64x2_t v496 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v581, v495), v580, v494.f64[0]), v579, v494, 1);
                        float64x2_t v497 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64((float64x2_t)vzip1q_s64(v607, (int64x2_t)v459), v495), (float64x2_t)vzip2q_s64(v607, (int64x2_t)v459), v494.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v575.f64[0], v464), v494, 1);
                        float64x2_t v498 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v497, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v497));
                        double v499 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v496, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v496)))+ v498.f64[0];
                        v498.f64[0] = v499;
                        *(int8x8_t *)&v498.f64[0] = vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v498)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v498)));
                        if ((vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v498.f64[0], vdup_lane_s32(*(int32x2_t *)&v498.f64[0], 1))).u8[0] & 1) == 0|| fabs(v499) != 3.0)
                        {
                          v500.f64[0] = v458[4].f64[0];
                          *(void *)&v500.f64[1] = vextq_s8((int8x16_t)v463, (int8x16_t)v463, 8uLL).u64[0];
                          *(void *)&v483.f64[1] = vextq_s8((int8x16_t)v483, (int8x16_t)v483, 8uLL).u64[0];
                          v501.f64[0] = v458->f64[0];
                          *(void *)&v501.f64[1] = vextq_s8((int8x16_t)v459, (int8x16_t)v459, 8uLL).u64[0];
                          *(void *)&v492.f64[1] = vextq_s8((int8x16_t)v492, (int8x16_t)v492, 8uLL).u64[0];
                          float64x2_t v502 = vmlaq_f64(vnegq_f64(vmulq_f64(v492, v501)), v483, v500);
                          *(void *)&double v503 = *(_OWORD *)&vmlaq_f64(vnegq_f64(vmulq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v463, 1), v313)), (float64x2_t)vdupq_laneq_s64((int64x2_t)v459, 1), v462);
                          float64x2_t v504 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v581, v503), v580, v502.f64[0]), v579, v502, 1);
                          float64x2_t v505 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64((float64x2_t)vzip1q_s64(v607, (int64x2_t)v461), v503), (float64x2_t)vzip2q_s64(v607, (int64x2_t)v461), v502.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)*(unint64_t *)&v575.f64[0], v465), v502, 1);
                          float64x2_t v506 = (float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v505, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v505));
                          double v507 = vaddvq_f64((float64x2_t)vbicq_s8(vorrq_s8(vandq_s8((int8x16_t)v504, v472), (int8x16_t)v611), (int8x16_t)vceqzq_f64(v504)))+ v506.f64[0];
                          v506.f64[0] = v507;
                          int32x2_t v508 = (int32x2_t)vbsl_s8((int8x8_t)vmovn_s64(vcgtzq_f64(v506)), (int8x8_t)0x100000001, (int8x8_t)vmovn_s64(vcltzq_f64(v506)));
                          if ((vmvn_s8((int8x8_t)vceq_s32(v508, vdup_lane_s32(v508, 1))).u8[0] & 1) == 0
                            || fabs(v507) != 3.0)
                          {
                            float64x2_t v509 = vsubq_f64(v461, v459);
                            float64x2_t v510 = vsubq_f64(v460, v313);
                            float64x2_t v511 = vsubq_f64(v463, v459);
                            float64x2_t v512 = vsubq_f64(v462, v313);
                            float64x2_t v513 = vmlaq_laneq_f64(vnegq_f64(vmulq_laneq_f64(v510, v511, 1)), v512, v509, 1);
                            v512.f64[1] = v511.f64[0];
                            v510.f64[1] = v509.f64[0];
                            float64x2_t v514 = vmlaq_f64(vnegq_f64(vmulq_f64(v512, v509)), v510, v511);
                            float64x2_t v515 = vmulq_f64(v514, v514);
                            if (vmulq_f64(v513, v513).f64[0] + v515.f64[0] + v515.f64[1] <= 0.000001) {
                              goto LABEL_444;
                            }
                            float64x2_t v516 = (float64x2_t)vextq_s8((int8x16_t)v514, (int8x16_t)v514, 8uLL);
                            v517.f64[0] = v513.f64[0];
                            v517.f64[1] = v514.f64[0];
                            float64x2_t v518 = vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v467, v513.f64[0]), v468, v514.f64[0]), (float64x2_t)vzip1q_s64((int64x2_t)v313, (int64x2_t)v460), v516.f64[0]);
                            BOOL v519 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v463, v513), v514, v463, 1), v516, v462).f64[0] < -0.00000011920929
                                && v518.f64[1] < -0.00000011920929;
                            BOOL v520 = v519 && v518.f64[0] < -0.00000011920929;
                            int8x16_t v521 = (int8x16_t)vnegq_f64(v517);
                            int8x16_t v522 = (int8x16_t)vnegq_f64(v516);
                            unint64_t v523 = v520 ? -1 : 0;
                            int8x16_t v524 = (int8x16_t)vdupq_n_s64(v523);
                            float64x2_t v313 = (float64x2_t)vbslq_s8(v524, v522, (int8x16_t)v516);
                            float64x2_t v525 = (float64x2_t)vbslq_s8(v524, v521, (int8x16_t)v517);
                            v526.f64[0] = v581.f64[0];
                            *(void *)&v526.f64[1] = v569;
                            v527.f64[0] = v580.f64[0];
                            *(void *)&v527.f64[1] = v568;
                            float64x2_t v528 = vmlaq_laneq_f64(vmulq_n_f64(v526, v525.f64[0]), v527, v525, 1);
                            float64x2_t v529 = vmlaq_laneq_f64(vmulq_f64(v525, v576), v567, v525, 1);
                            *(void *)&v525.f64[0] = v570;
                            *(void *)&v525.f64[1] = v566;
                            *(void *)&double v530 = *(_OWORD *)&vmlaq_f64(v529, v313, v575);
                            float64x2_t v531 = vmlaq_n_f64(v528, v525, v313.f64[0]);
                            BOOL v532 = v531.f64[0] < -0.00000011920929 && v531.f64[1] < -0.00000011920929;
                            if (!v532 || v530 >= -0.00000011920929)
                            {
LABEL_444:
                              float v534 = operator new(0x18uLL);
                              double v535 = (uint64_t *)(v449 + 24 * v457);
                              v534[4] = v384;
                              *((void *)v534 + 1) = v535;
                              uint64_t v536 = *v535;
                              *(void *)float v534 = *v535;
                              *(void *)(v536 + 8) = v534;
                              *double v535 = (uint64_t)v534;
                              ++v535[2];
                            }
                          }
                        }
                      }
                    }
                  }
                }
                v420 = (void *)v420[1];
              }
              while (v420 != &v621);
              goto LABEL_445;
            }
            do
            {
LABEL_391:
              int v426 = *((_DWORD *)v404 + 4);
              uint64_t v427 = *v408;
              v428 = operator new(0x18uLL);
              uint64_t v429 = (uint64_t *)(v427 + 24 * v426);
              v428[4] = v384;
              *((void *)v428 + 1) = v429;
              uint64_t v430 = *v429;
              *(void *)v428 = *v429;
              *(void *)(v430 + 8) = v428;
              *uint64_t v429 = (uint64_t)v428;
              ++v429[2];
              *(void *)buf = buf;
              *(void *)&buf[8] = buf;
              uint64_t v431 = v622;
              if (v622 != &v621)
              {
                uint64_t v432 = 0;
                *(void *)&uint8_t buf[16] = 0;
                int v433 = *((_DWORD *)v404 + 4);
                v434 = buf;
                uint64_t v435 = v623;
                do
                {
                  uint64_t v436 = (void *)v431[1];
                  if (*((_DWORD *)v431 + 4) == v433)
                  {
                    while (v436 != &v621)
                    {
                      BOOL v437 = *((_DWORD *)v436 + 4) == v433;
                      if (*((_DWORD *)v436 + 4) != v433) {
                        goto LABEL_399;
                      }
                      uint64_t v436 = (void *)v436[1];
                    }
                    BOOL v437 = 1;
                    uint64_t v436 = &v621;
LABEL_399:
                    if (v431 != v436)
                    {
                      v434 = (unsigned char *)*v436;
                      if ((void *)*v436 == v431)
                      {
                        uint64_t v440 = 1;
                      }
                      else
                      {
                        uint64_t v438 = -1;
                        uint64_t v439 = v431;
                        do
                        {
                          uint64_t v439 = (void *)v439[1];
                          ++v438;
                        }
                        while (v439 != (void *)v434);
                        uint64_t v440 = v438 + 2;
                      }
                      v435 -= v440;
                      uint64_t v623 = v435;
                      v432 += v440;
                      uint64_t v441 = *v431;
                      *(void *)(v441 + 8) = *((void *)v434 + 1);
                      **((void **)v434 + 1) = v441;
                      uint64_t v442 = *(void *)buf;
                      *(void *)(*(void *)buf + 8) = v431;
                      *uint64_t v431 = v442;
                      *(void *)buf = v434;
                      *((void *)v434 + 1) = buf;
                    }
                    if (!v437) {
                      uint64_t v436 = (void *)v436[1];
                    }
                  }
                  uint64_t v431 = v436;
                }
                while (v436 != &v621);
                if (v432)
                {
                  uint64_t v443 = *(void **)&buf[8];
                  uint64_t v444 = **(void **)&buf[8];
                  *(void *)(v444 + 8) = *((void *)v434 + 1);
                  **((void **)v434 + 1) = v444;
                  if (v443 != (void *)buf)
                  {
                    do
                    {
                      uint64_t v445 = (unsigned char *)v443[1];
                      operator delete(v443);
                      uint64_t v443 = v445;
                    }
                    while (v445 != buf);
                  }
                }
              }
              unsigned int v404 = (void **)v404[1];
            }
            while (v404 != v612);
            v420 = v622;
            if (v622 == &v621) {
              goto LABEL_445;
            }
            goto LABEL_413;
          }
          v425 = v622;
          unsigned int v408 = v574;
          do
          {
            *((_DWORD *)v425 + 4) = v406;
            v425 = (void *)v425[1];
            ++v406;
          }
          while (v425 != &v621);
        }
        if (v404 == v612) {
          goto LABEL_386;
        }
        goto LABEL_391;
      }
    }
    while (1)
    {
      __asm { FMOV            V27.2D, #0.5 }
      switch(v332 & 3)
      {
        case 2u:
          float64x2_t v371 = vmlaq_laneq_f64(vmulq_n_f64(_Q27, v324.f64[0]), (float64x2_t)xmmword_21B5513F0, v324, 1);
          float64x2_t v360 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v324, 1), _Q27, v327);
          float64x2_t v361 = (float64x2_t)xmmword_21B551400;
          float64x2_t v362 = vmlaq_n_f64(v371, (float64x2_t)xmmword_21B551400, v327.f64[0]);
          float64x2_t v363 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v328, 1), _Q27, v329);
          float64x2_t v364 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(_Q27, v328.f64[0]), (float64x2_t)xmmword_21B5513F0, v328, 1), (float64x2_t)xmmword_21B551400, v329.f64[0]);
          float64x2_t v365 = vmlaq_laneq_f64(vmulq_n_f64(_Q27, v330.f64[0]), (float64x2_t)xmmword_21B5513F0, v330, 1);
          break;
        case 1u:
          float64x2_t v366 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v324, _Q27), _Q27, v324, 1), v611, v327);
          float64x2_t v367 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551410, v324.f64[0]), (float64x2_t)xmmword_21B551400, v324, 1), (float64x2_t)0, v327.f64[0]);
          float64x2_t v363 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v328, _Q27), _Q27, v328, 1), v611, v329);
          float64x2_t v368 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551410, v328.f64[0]), (float64x2_t)xmmword_21B551400, v328, 1), (float64x2_t)0, v329.f64[0]);
          float64x2_t v369 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v330, _Q27), _Q27, v330, 1), v611, v331);
          float64x2_t v370 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551410, v330.f64[0]), (float64x2_t)xmmword_21B551400, v330, 1), (float64x2_t)0, v331.f64[0]);
LABEL_331:
          unint64_t v372 = vextq_s8((int8x16_t)v370, (int8x16_t)v370, 8uLL).u64[0];
          float64x2_t v324 = v367;
          float64x2_t v327 = v366;
          float64x2_t v328 = v368;
          goto LABEL_332;
        case 0u:
          float64x2_t v359 = vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551420, v324.f64[0]), _Q27, v324, 1);
          float64x2_t v360 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v324, 1), _Q27, v327);
          float64x2_t v361 = (float64x2_t)xmmword_21B551410;
          float64x2_t v362 = vmlaq_n_f64(v359, (float64x2_t)xmmword_21B551410, v327.f64[0]);
          float64x2_t v363 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v328, 1), _Q27, v329);
          float64x2_t v364 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551420, v328.f64[0]), _Q27, v328, 1), (float64x2_t)xmmword_21B551410, v329.f64[0]);
          float64x2_t v365 = vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551420, v330.f64[0]), _Q27, v330, 1);
          break;
        default:
          float64x2_t v366 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v324, _Q27), _Q27, v324, 1), (float64x2_t)0, v327);
          float64x2_t v367 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551400, v324.f64[0]), (float64x2_t)xmmword_21B551410, v324, 1), _Q27, v327.f64[0]);
          float64x2_t v363 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v328, _Q27), _Q27, v328, 1), (float64x2_t)0, v329);
          float64x2_t v368 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551400, v328.f64[0]), (float64x2_t)xmmword_21B551410, v328, 1), _Q27, v329.f64[0]);
          float64x2_t v369 = vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v330, _Q27), _Q27, v330, 1), (float64x2_t)0, v331);
          float64x2_t v370 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64((float64x2_t)xmmword_21B551400, v330.f64[0]), (float64x2_t)xmmword_21B551410, v330, 1), _Q27, v331.f64[0]);
          goto LABEL_331;
      }
      float64x2_t v369 = vmlaq_f64(vmlaq_laneq_f64((float64x2_t)0, (float64x2_t)0, v330, 1), _Q27, v331);
      float64x2_t v370 = vmlaq_n_f64(v365, v361, v331.f64[0]);
      unint64_t v372 = vextq_s8((int8x16_t)v370, (int8x16_t)v370, 8uLL).u64[0];
      float64x2_t v324 = v362;
      float64x2_t v327 = v360;
      float64x2_t v328 = v364;
LABEL_332:
      float64x2_t v329 = v363;
      float64x2_t v373 = vabsq_f64(v327);
      v373.f64[0] = vaddvq_f64(vabsq_f64(v324)) + v373.f64[0];
      if (v373.f64[0] > 0.0)
      {
        v373.f64[0] = 1.0 / v373.f64[0];
        float64x2_t v327 = vmulq_f64(v373, v327);
        *(void *)&v324.f64[1] = vextq_s8((int8x16_t)v324, (int8x16_t)v324, 8uLL).u64[0];
        float64x2_t v324 = vmulq_n_f64(v324, v373.f64[0]);
      }
      float64x2_t v374 = vabsq_f64(v363);
      v374.f64[0] = vaddvq_f64(vabsq_f64(v328)) + v374.f64[0];
      if (v374.f64[0] > 0.0)
      {
        v374.f64[0] = 1.0 / v374.f64[0];
        float64x2_t v329 = vmulq_f64(v374, v363);
        *(void *)&v328.f64[1] = vextq_s8((int8x16_t)v328, (int8x16_t)v328, 8uLL).u64[0];
        float64x2_t v328 = vmulq_n_f64(v328, v374.f64[0]);
      }
      v375.f64[0] = v370.f64[0];
      *(void *)&v375.f64[1] = v372;
      float64x2_t v376 = vabsq_f64(v369);
      double v377 = vaddvq_f64(vabsq_f64(v375)) + v376.f64[0];
      if (v377 > 0.0)
      {
        v376.f64[0] = 1.0 / v377;
        float64x2_t v331 = vmulq_f64(v376, v369);
        *(void *)&v370.f64[1] = v372;
        float64x2_t v330 = vmulq_n_f64(v370, v376.f64[0]);
      }
      else
      {
        *(void *)&v370.f64[1] = v372;
        float64x2_t v330 = v370;
        float64x2_t v331 = v369;
      }
      v332 >>= 2;
      if (!--v333) {
        goto LABEL_319;
      }
    }
  }
  unint64_t v59 = __p;
  if (v281 != v605)
  {
    uint64_t v286 = *(void *)(v262 + 288);
    uint64_t v287 = *(uint64_t **)(v262 + 272);
    if (0xAAAAAAAAAAAAAAABLL * ((v286 - (uint64_t)v287) >> 3) < v283)
    {
      if (v287)
      {
        uint64_t v288 = *(uint64_t **)(v262 + 280);
        uint64_t v289 = *(void **)(v262 + 272);
        if (v288 != v287)
        {
          do
          {
            v290 = v288 - 3;
            if (*(v288 - 1))
            {
              uint64_t v292 = *(v288 - 3);
              uint64_t v291 = (uint64_t *)*(v288 - 2);
              uint64_t v293 = *v291;
              *(void *)(v293 + 8) = *(void *)(v292 + 8);
              **(void **)(v292 + 8) = v293;
              *(v288 - 1) = 0;
              if (v291 != v290)
              {
                do
                {
                  uint64_t v294 = (uint64_t *)v291[1];
                  operator delete(v291);
                  uint64_t v291 = v294;
                }
                while (v294 != v290);
              }
            }
            uint64_t v288 = v290;
          }
          while (v290 != v287);
          uint64_t v289 = (void *)*v574;
        }
        *(void *)(v262 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v287;
        operator delete(v289);
        uint64_t v286 = 0;
        *uint64_t v574 = 0;
        *(void *)(v262 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
        *(void *)(v262 + 288) = 0;
      }
      unint64_t v558 = 0xAAAAAAAAAAAAAAABLL * (v286 >> 3);
      uint64_t v559 = 2 * v558;
      if (2 * v558 <= v283) {
        uint64_t v559 = v283;
      }
      if (v558 >= 0x555555555555555) {
        unint64_t v560 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v560 = v559;
      }
      if (v560 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      v561 = (char *)operator new(24 * v560);
      *(void *)(v262 + 272) = v561;
      *(void *)(v262 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v561;
      *(void *)(v262 + 288) = &v561[24 * v560];
      *(void *)(v262 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::list<int>>,std::list<int>*,std::list<int>*,std::list<int>*>(v262 + 288, v285, v284, (uint64_t)v561);
      goto LABEL_476;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v262 + 280) - (void)v287) >> 3) >= v283)
    {
      unint64_t v551 = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::list<int> *,std::list<int> *,std::list<int> *,0>((void *)*v605, (void *)v605[1], *(void **)(v262 + 272));
      unint64_t v552 = *(uint64_t **)(v262 + 280);
      if (v552 != v551)
      {
        do
        {
          uint64_t v553 = v552 - 3;
          if (*(v552 - 1))
          {
            uint64_t v555 = *(v552 - 3);
            uint64_t v554 = (uint64_t *)*(v552 - 2);
            uint64_t v556 = *v554;
            *(void *)(v556 + 8) = *(void *)(v555 + 8);
            **(void **)(v555 + 8) = v556;
            *(v552 - 1) = 0;
            if (v554 != v553)
            {
              do
              {
                v557 = (uint64_t *)v554[1];
                operator delete(v554);
                uint64_t v554 = v557;
              }
              while (v557 != v553);
            }
          }
          unint64_t v552 = v553;
        }
        while (v553 != v551);
      }
      *(void *)(v262 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v551;
LABEL_476:
      unint64_t v59 = __p;
    }
    else
    {
      v550 = (void *)(v285 + 8 * ((uint64_t)(*(void *)(v262 + 280) - (void)v287) >> 3));
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::list<int> *,std::list<int> *,std::list<int> *,0>((void *)*v605, v550, *(void **)(v262 + 272));
      unint64_t v59 = __p;
      *(void *)(v262 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::list<int>>,std::list<int>*,std::list<int>*,std::list<int>*>(v262 + 288, (uint64_t)v550, v284, *(void *)(v262 + 280));
    }
  }
  uint64_t v57 = 0;
  *(_DWORD *)(v262 + 296) = v282;
  uint64_t v58 = v608;
  if (v59) {
LABEL_40:
  }
    operator delete(v59);
LABEL_41:
  if (v58) {
    operator delete(v58);
  }
  if (v18) {
    operator delete(v18);
  }
  return v57;
}

void sub_21B535CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  *(void *)(v34 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v35;
  if (STACK[0x218])
  {
    operator delete((void *)STACK[0x218]);
    if (!STACK[0x210])
    {
LABEL_3:
      if (!a34) {
LABEL_8:
      }
        _Unwind_Resume(a1);
LABEL_7:
      STACK[0x298] = (unint64_t)a34;
      operator delete(a34);
      goto LABEL_8;
    }
  }
  else if (!STACK[0x210])
  {
    goto LABEL_3;
  }
  operator delete((void *)STACK[0x210]);
  a34 = (void *)STACK[0x290];
  if (!STACK[0x290]) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void sub_21B535CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  *(void *)(v35 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v34;
  if (STACK[0x218])
  {
    operator delete((void *)STACK[0x218]);
    if (!STACK[0x210])
    {
LABEL_3:
      if (!a34) {
LABEL_8:
      }
        _Unwind_Resume(a1);
LABEL_7:
      STACK[0x298] = (unint64_t)a34;
      operator delete(a34);
      goto LABEL_8;
    }
  }
  else if (!STACK[0x210])
  {
    goto LABEL_3;
  }
  operator delete((void *)STACK[0x210]);
  a34 = (void *)STACK[0x290];
  if (!STACK[0x290]) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void sub_21B535CC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  operator delete(__p);
  JUMPOUT(0x21B535E0CLL);
}

void sub_21B535CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  uint64_t v37 = (void *)STACK[0x230];
  if (STACK[0x230])
  {
    STACK[0x238] = (unint64_t)v37;
    operator delete(v37);
    uint64_t v38 = *(void **)(v35 - 224);
    if (!v38)
    {
LABEL_3:
      if (!v34)
      {
LABEL_8:
        if (STACK[0x218])
        {
          operator delete((void *)STACK[0x218]);
          if (!STACK[0x210])
          {
LABEL_10:
            if (!a34) {
LABEL_15:
            }
              _Unwind_Resume(a1);
LABEL_14:
            STACK[0x298] = (unint64_t)a34;
            operator delete(a34);
            goto LABEL_15;
          }
        }
        else if (!STACK[0x210])
        {
          goto LABEL_10;
        }
        operator delete((void *)STACK[0x210]);
        a34 = (void *)STACK[0x290];
        if (!STACK[0x290]) {
          goto LABEL_15;
        }
        goto LABEL_14;
      }
LABEL_16:
      JUMPOUT(0x21B535E08);
    }
  }
  else
  {
    uint64_t v38 = *(void **)(v35 - 224);
    if (!v38) {
      goto LABEL_3;
    }
  }
  *(void *)(v35 - 216) = v38;
  operator delete(v38);
  if (!v34) {
    goto LABEL_8;
  }
  goto LABEL_16;
}

void sub_21B535D24(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
    __cxa_rethrow();
  }
  JUMPOUT(0x21B535E5CLL);
}

void sub_21B535D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  if (STACK[0x218])
  {
    operator delete((void *)STACK[0x218]);
    if (!STACK[0x210])
    {
LABEL_3:
      if (!a34) {
LABEL_8:
      }
        _Unwind_Resume(a1);
LABEL_7:
      STACK[0x298] = (unint64_t)a34;
      operator delete(a34);
      goto LABEL_8;
    }
  }
  else if (!STACK[0x210])
  {
    goto LABEL_3;
  }
  operator delete((void *)STACK[0x210]);
  a34 = (void *)STACK[0x290];
  if (!STACK[0x290]) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void sub_21B535D5C(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x21B535E5CLL);
}

void sub_21B535D6C()
{
  STACK[0x210] = v0;
  JUMPOUT(0x21B535E38);
}

void sub_21B535D78()
{
}

void sub_21B535D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  if (STACK[0x218])
  {
    operator delete((void *)STACK[0x218]);
    if (!STACK[0x210])
    {
LABEL_3:
      if (!a34) {
LABEL_8:
      }
        _Unwind_Resume(a1);
LABEL_7:
      STACK[0x298] = (unint64_t)a34;
      operator delete(a34);
      goto LABEL_8;
    }
  }
  else if (!STACK[0x210])
  {
    goto LABEL_3;
  }
  operator delete((void *)STACK[0x210]);
  a34 = (void *)STACK[0x290];
  if (!STACK[0x290]) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void sub_21B535D8C()
{
}

void sub_21B535DA8()
{
  if (v0)
  {
    uint64_t v3 = *(uint64_t **)(v2 - 240);
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(v1 + 8);
    **(void **)(v1 + 8) = v4;
    *(void *)(v2 - 232) = 0;
    if (v3 != (uint64_t *)(v2 - 248))
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != (uint64_t *)(v2 - 248));
    }
  }
  JUMPOUT(0x21B535DFCLL);
}

uint64_t *std::back_insert_iterator<std::vector<float>>::operator=[abi:ne180100](uint64_t *a1, float a2)
{
  uint64_t v4 = *a1;
  unint64_t v6 = *(float **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  uint64_t v7 = v6;
  if ((unint64_t)v6 >= v5)
  {
    unint64_t v9 = *(float **)v4;
    uint64_t v10 = (uint64_t)v6 - *(void *)v4;
    uint64_t v11 = v10 >> 2;
    unint64_t v12 = (v10 >> 2) + 1;
    if (v12 >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = v5 - (void)v9;
    if (v13 >> 1 > v12) {
      unint64_t v12 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v15 = operator new(4 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    unint64_t v16 = (float *)&v15[4 * v11];
    size_t v17 = &v15[4 * v14];
    *unint64_t v16 = a2;
    size_t v8 = v16 + 1;
    if (v6 != v9)
    {
      unint64_t v18 = (char *)v6 - (char *)v9 - 4;
      if (v18 < 0x2C) {
        goto LABEL_27;
      }
      if ((unint64_t)((char *)v6 - v15 - v10) < 0x20) {
        goto LABEL_27;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      uint64_t v7 = &v6[-(v19 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v20 = &v15[4 * v11 - 16];
      unint64_t v21 = v6 - 4;
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        *uint64_t v20 = v23;
        v20 -= 2;
        v21 -= 8;
        v22 -= 8;
      }
      while (v22);
      v16 -= v19 & 0x7FFFFFFFFFFFFFF8;
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_27:
        do
        {
          int v24 = *((_DWORD *)v7-- - 1);
          *((_DWORD *)v16-- - 1) = v24;
        }
        while (v7 != v9);
      }
    }
    *(void *)uint64_t v4 = v16;
    *(void *)(v4 + 8) = v8;
    *(void *)(v4 + 16) = v17;
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *unint64_t v6 = a2;
    size_t v8 = v6 + 1;
  }
  *(void *)(v4 + 8) = v8;
  return a1;
}

void VBAP::lineUnitSphereIntersection(VBAP *this, const float *__A, float *a3, float *a4)
{
  int v16 = 0;
  uint64_t v14 = 0;
  uint64_t __C = 0;
  float v13 = 0.0;
  vDSP_vsub((const float *)this, 1, __A, 1, (float *)&__C, 1, 3uLL);
  vDSP_dotpr((const float *)&__C, 1, (const float *)&__C, 1, (float *)&v14 + 1, 3uLL);
  vDSP_dotpr((const float *)this, 1, (const float *)&__C, 1, (float *)&v14, 3uLL);
  *(float *)&uint64_t v14 = *(float *)&v14 + *(float *)&v14;
  vDSP_dotpr((const float *)this, 1, (const float *)this, 1, &v13, 3uLL);
  float v13 = v13 + -1.0;
  float v7 = (float)(v13 * (float)(-4.0 * *((float *)&v14 + 1))) + (float)(*(float *)&v14 * *(float *)&v14);
  if (v7 >= 0.0)
  {
    float v8 = sqrtf(v7);
    float v9 = (float)(v8 - *(float *)&v14) / (float)(*((float *)&v14 + 1) + *((float *)&v14 + 1));
    float __D = (float)-(float)(v8 + *(float *)&v14) / (float)(*((float *)&v14 + 1) + *((float *)&v14 + 1));
    float v11 = 1.0 - v9;
    float __B = 1.0 - __D;
    vDSP_vsmsma((const float *)this, 1, &__B, __A, 1, &__D, a3 + 3, 1, 3uLL);
    vDSP_vsmsma((const float *)this, 1, &v11, __A, 1, &v9, a3, 1, 3uLL);
  }
}

uint64_t std::__split_buffer<std::vector<unsigned int>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = v2 - 24;
        uint64_t v4 = *(void **)(v2 - 24);
        *(void *)(a1 + 16) = v2 - 24;
        if (!v4) {
          break;
        }
        *(void *)(v2 - 16) = v4;
        operator delete(v4);
        uint64_t v2 = *(void *)(a1 + 16);
        if (v2 == v3) {
          goto LABEL_6;
        }
      }
      v2 -= 24;
    }
    while (v5 != v3);
  }
LABEL_6:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::vector<unsigned int>>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = *(void **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v12 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(a1 + 8), v12);
      uint64_t v5 = (void *)((char *)v5 + v12);
    }
    *(void *)(a1 + 8) = v5;
  }
  else
  {
    unint64_t v6 = *(void **)a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *(void *)a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float v11 = (char *)operator new(24 * v10);
    }
    else
    {
      float v11 = 0;
    }
    float v13 = &v11[24 * v7];
    uint64_t v14 = &v11[24 * v10];
    size_t v15 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v13, v15);
    int v16 = &v13[v15];
    if (v5 == v6)
    {
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
    }
    else
    {
      do
      {
        size_t v17 = v13;
        *((void *)v13 - 2) = 0;
        *((void *)v13 - 1) = 0;
        long long v18 = *(_OWORD *)(v5 - 3);
        v5 -= 3;
        *(_OWORD *)(v13 - 24) = v18;
        v13 -= 24;
        *((void *)v17 - 1) = v5[2];
        *uint64_t v5 = 0;
        v5[1] = 0;
        v5[2] = 0;
      }
      while (v5 != v6);
      uint64_t v5 = *(void **)a1;
      uint64_t v19 = *(void **)(a1 + 8);
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (v19 != v5)
      {
        uint64_t v20 = v19;
        do
        {
          uint64_t v22 = (void *)*(v20 - 3);
          v20 -= 3;
          unint64_t v21 = v22;
          if (v22)
          {
            *(v19 - 2) = v21;
            operator delete(v21);
          }
          uint64_t v19 = v20;
        }
        while (v20 != v5);
      }
    }
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*,std::vector<unsigned int>*,std::vector<unsigned int>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *a4 = 0;
      a4[1] = 0;
      a4[2] = 0;
      unint64_t v9 = *(const void **)v6;
      uint64_t v8 = *(void *)(v6 + 8);
      int64_t v10 = v8 - *(void *)v6;
      if (v8 != *(void *)v6)
      {
        if (v10 < 0) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        float v11 = (char *)operator new(v8 - *(void *)v6);
        *a4 = v11;
        a4[1] = v11;
        unint64_t v7 = &v11[4 * (v10 >> 2)];
        a4[2] = v7;
        memcpy(v11, v9, v10);
        a4[1] = v7;
      }
      a4 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  return a4;
}

void sub_21B536484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 16);
    uint64_t v4 = **(void **)(a1 + 8);
    if (v3 != v4)
    {
      uint64_t v5 = **(void **)(a1 + 16);
      do
      {
        unint64_t v7 = *(void **)(v5 - 24);
        v5 -= 24;
        uint64_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v4);
    }
  }
  return a1;
}

void *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::list<int> *,std::list<int> *,std::list<int> *,0>(void *a1, void *a2, void *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      if (a3 != v5)
      {
        uint64_t v8 = v5[1];
        for (uint64_t i = (void *)a3[1]; (void *)v8 != v5 && i != a3; uint64_t i = (void *)i[1])
        {
          *((_DWORD *)i + 4) = *(_DWORD *)(v8 + 16);
          uint64_t v8 = *(void *)(v8 + 8);
        }
        if (i == a3)
        {
          if ((void *)v8 != v5)
          {
            uint64_t v14 = operator new(0x18uLL);
            size_t v15 = v14;
            *uint64_t v14 = 0;
            v14[1] = 0;
            *((_DWORD *)v14 + 4) = *(_DWORD *)(v8 + 16);
            uint64_t v16 = *(void *)(v8 + 8);
            if ((void *)v16 == v5)
            {
              uint64_t v6 = 1;
            }
            else
            {
              uint64_t v6 = 1;
              size_t v17 = v14;
              do
              {
                uint64_t v14 = operator new(0x18uLL);
                *uint64_t v14 = v17;
                v14[1] = 0;
                *((_DWORD *)v14 + 4) = *(_DWORD *)(v16 + 16);
                v17[1] = v14;
                ++v6;
                uint64_t v16 = *(void *)(v16 + 8);
                size_t v17 = v14;
              }
              while ((void *)v16 != v5);
            }
            uint64_t v7 = *a3;
            *(void *)(v7 + 8) = v15;
            *size_t v15 = v7;
            *a3 = v14;
            v14[1] = a3;
            a3[2] += v6;
          }
        }
        else
        {
          uint64_t v11 = *a3;
          uint64_t v12 = *i;
          *(void *)(v12 + 8) = *(void *)(*a3 + 8);
          **(void **)(v11 + 8) = v12;
          do
          {
            float v13 = (void *)i[1];
            --a3[2];
            operator delete(i);
            uint64_t i = v13;
          }
          while (v13 != a3);
        }
      }
      v5 += 3;
      a3 += 3;
    }
    while (v5 != a2);
  }
  return a3;
}

void sub_21B536680(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    uint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_21B5366A0(_Unwind_Exception *a1)
{
}

uint64_t VBAP::VBAP(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, char **__sz, uint64_t *a6)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v13 = *a3;
  uint64_t v12 = a3[1];
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v14 = v12 - v13;
  if (v14)
  {
    uint64_t v15 = v14 >> 2;
    uint64_t v16 = 3 * v15;
    if ((unint64_t)(3 * v15) >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    size_t v17 = 12 * v15;
    long long v18 = (char *)operator new(12 * v15);
    *(void *)(a1 + 32) = v18;
    uint64_t v19 = &v18[4 * v16];
    *(void *)(a1 + 48) = v19;
    bzero(v18, v17);
    *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v19;
  }
  float v33 = __sz;
  uint64_t v21 = *a3;
  uint64_t v20 = a3[1];
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  uint64_t v22 = v20 - v21;
  if (v22)
  {
    uint64_t v23 = v22 >> 2;
    uint64_t v24 = 3 * v23;
    if ((unint64_t)(3 * v23) >> 62) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    size_t v25 = 12 * v23;
    unint64_t v26 = (char *)operator new(12 * v23);
    *(void *)(a1 + 56) = v26;
    float32x4_t v27 = &v26[4 * v24];
    *(void *)(a1 + 72) = v27;
    bzero(v26, v25);
    *(void *)(a1 + 64) = v27;
  }
  *(void *)(a1 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  unint64_t v28 = operator new(0x18uLL);
  *(void *)(a1 + 88) = v28 + 3;
  *(void *)(a1 + 96) = v28 + 3;
  v28[1] = 0;
  v28[2] = 0;
  *unint64_t v28 = 0;
  *(void *)(a1 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v28;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a1 + 176;
  *(void *)(a1 + 184) = a1 + 176;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 20std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = a1 + 200;
  *(void *)(a1 + 208) = a1 + 200;
  *(_WORD *)(a1 + 314) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  *(_DWORD *)a1 = a4;
  uint64_t v29 = (a3[1] - *a3) >> 2;
  *(_DWORD *)(a1 + 30std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v29;
  if (v29 && (a2[1] - *a2) >> 2 == v29)
  {
    if (!VBAP::initialize(a1, a2, a3, v33, a6))
    {
      *(unsigned char *)(a1 + 315) = 1;
      return a1;
    }
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v35 = "VBAP.cpp";
      __int16 v36 = 1024;
      int v37 = 35;
      __int16 v38 = 2080;
      float64x2_t v39 = "VBAP";
      __int16 v40 = 1024;
      int v41 = 35;
      double v30 = MEMORY[0x263EF8438];
      unint64_t v31 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Initialization Error; Check for duplicate vertices";
LABEL_14:
      _os_log_impl(&dword_21B4DD000, v30, OS_LOG_TYPE_ERROR, v31, buf, 0x22u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    uint64_t v35 = "VBAP.cpp";
    __int16 v36 = 1024;
    int v37 = 40;
    __int16 v38 = 2080;
    float64x2_t v39 = "VBAP";
    __int16 v40 = 1024;
    int v41 = 40;
    double v30 = MEMORY[0x263EF8438];
    unint64_t v31 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Initialization Error; Empty or inconsistent vertex set";
    goto LABEL_14;
  }
  return a1;
}

void sub_21B5369D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void **a10, void **a11, _Unwind_Exception *exception_object)
{
  long long v18 = (uint64_t *)v12[34];
  if (v18)
  {
    uint64_t v21 = (uint64_t *)v12[35];
    uint64_t v22 = (void *)v12[34];
    if (v21 != v18)
    {
      do
      {
        uint64_t v23 = v21 - 3;
        if (*(v21 - 1))
        {
          uint64_t v25 = *(v21 - 3);
          uint64_t v24 = (uint64_t *)*(v21 - 2);
          uint64_t v26 = *v24;
          *(void *)(v26 + 8) = *(void *)(v25 + 8);
          **(void **)(v25 + 8) = v26;
          *(v21 - 1) = 0;
          if (v24 != v23)
          {
            do
            {
              float32x4_t v27 = (uint64_t *)v24[1];
              operator delete(v24);
              uint64_t v24 = v27;
            }
            while (v27 != v23);
          }
        }
        uint64_t v21 = v23;
      }
      while (v23 != v18);
      uint64_t v22 = (void *)v12[34];
    }
    v12[35] = v18;
    operator delete(v22);
    uint64_t v19 = (void *)v12[31];
    if (!v19)
    {
LABEL_3:
      uint64_t v20 = (void *)v12[28];
      if (!v20) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v19 = (void *)v12[31];
    if (!v19) {
      goto LABEL_3;
    }
  }
  v12[32] = v19;
  operator delete(v19);
  uint64_t v20 = (void *)v12[28];
  if (!v20)
  {
LABEL_4:
    if (!*v17) {
      goto LABEL_19;
    }
LABEL_17:
    uint64_t v29 = v12[25];
    unint64_t v28 = (uint64_t *)v12[26];
    uint64_t v30 = *v28;
    *(void *)(v30 + 8) = *(void *)(v29 + 8);
    **(void **)(v29 + 8) = v30;
    v12[27] = 0;
    if (v28 != v15)
    {
      do
      {
        unint64_t v31 = (uint64_t *)v28[1];
        operator delete(v28);
        unint64_t v28 = v31;
      }
      while (v31 != v15);
    }
LABEL_19:
    if (v12[24])
    {
      uint64_t v33 = v12[22];
      double v32 = (uint64_t *)v12[23];
      uint64_t v34 = *v32;
      *(void *)(v34 + 8) = *(void *)(v33 + 8);
      **(void **)(v33 + 8) = v34;
      v12[24] = 0;
      if (v32 != v14)
      {
        do
        {
          uint64_t v35 = (uint64_t *)v32[1];
          operator delete(v32);
          double v32 = v35;
        }
        while (v35 != v14);
      }
    }
    uint64_t v36 = v12[19];
    if (v36)
    {
      uint64_t v37 = v12[20];
      __int16 v38 = (void *)v12[19];
      if (v37 != v36)
      {
        uint64_t v39 = v12[20];
        do
        {
          int v41 = *(void **)(v39 - 24);
          v39 -= 24;
          __int16 v40 = v41;
          if (v41)
          {
            *(void *)(v37 - 16) = v40;
            operator delete(v40);
          }
          uint64_t v37 = v39;
        }
        while (v39 != v36);
        __int16 v38 = (void *)v12[19];
      }
      v12[20] = v36;
      operator delete(v38);
    }
    uint64_t v42 = (void *)v12[16];
    if (v42)
    {
      v12[17] = v42;
      operator delete(v42);
    }
    float64x2_t v43 = *a9;
    if (*a9)
    {
      v12[14] = v43;
      operator delete(v43);
      float64x2_t v44 = *v16;
      if (!*v16)
      {
LABEL_34:
        float64x2_t v45 = *v13;
        if (!*v13) {
          goto LABEL_36;
        }
        goto LABEL_35;
      }
    }
    else
    {
      float64x2_t v44 = *v16;
      if (!*v16) {
        goto LABEL_34;
      }
    }
    v12[11] = v44;
    operator delete(v44);
    float64x2_t v45 = *v13;
    if (!*v13)
    {
LABEL_36:
      float64x2_t v46 = *a10;
      if (*a10)
      {
        v12[5] = v46;
        operator delete(v46);
      }
      float64x2_t v47 = *a11;
      if (*a11)
      {
        v12[2] = v47;
        operator delete(v47);
      }
      _Unwind_Resume(a1);
    }
LABEL_35:
    v12[8] = v45;
    operator delete(v45);
    goto LABEL_36;
  }
LABEL_16:
  v12[29] = v20;
  operator delete(v20);
  if (!*v17) {
    goto LABEL_19;
  }
  goto LABEL_17;
}

void sub_21B536BE0()
{
  if (!*v0) {
    JUMPOUT(0x21B536B8CLL);
  }
  JUMPOUT(0x21B536B84);
}

void sub_21B536BF4()
{
  if (!*v0) {
    JUMPOUT(0x21B536BA0);
  }
  JUMPOUT(0x21B536B98);
}

uint64_t VBAP::changeSpeakerLocations(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  *(unsigned char *)(a1 + 315) = 0;
  unint64_t v3 = (unint64_t)(a3[1] - *a3) >> 2;
  if (*(_DWORD *)(a1 + 300) == v3 && (a2[1] - *a2) >> 2 == v3)
  {
    vDSP_vclr(*(float **)(a1 + 80), 1, (uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2);
    memset(buf, 0, 24);
    std::vector<char> __p = 0;
    long long v18 = 0;
    uint64_t v19 = 0;
    uint64_t v7 = VBAP::initialize(a1, a2, a3, (char **)buf, (uint64_t *)&__p);
    uint64_t v8 = (uint64_t *)__p;
    if (__p)
    {
      unint64_t v9 = v18;
      int64_t v10 = __p;
      if (v18 != __p)
      {
        do
        {
          uint64_t v11 = v9 - 3;
          if (*(v9 - 1))
          {
            uint64_t v13 = *(v9 - 3);
            uint64_t v12 = (uint64_t *)*(v9 - 2);
            uint64_t v14 = *v12;
            *(void *)(v14 + 8) = *(void *)(v13 + 8);
            **(void **)(v13 + 8) = v14;
            *(v9 - 1) = 0;
            if (v12 != v11)
            {
              do
              {
                uint64_t v15 = (uint64_t *)v12[1];
                operator delete(v12);
                uint64_t v12 = v15;
              }
              while (v15 != v11);
            }
          }
          unint64_t v9 = v11;
        }
        while (v11 != v8);
        int64_t v10 = __p;
      }
      long long v18 = v8;
      operator delete(v10);
    }
    if (*(void *)buf)
    {
      *(void *)&buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (v7)
    {
      if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "VBAP.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 59;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = "changeSpeakerLocations";
        __int16 v21 = 1024;
        int v22 = 59;
        _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Unable to change speaker locations",
          buf,
          0x22u);
      }
    }
    else
    {
      *(unsigned char *)(a1 + 315) = 1;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "VBAP.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 51;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = "changeSpeakerLocations";
      __int16 v21 = 1024;
      int v22 = 51;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Unable to change speaker locations, azimuth and elevation have different sizes",
        buf,
        0x22u);
    }
    return 4294967246;
  }
  return v7;
}

void sub_21B536E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

float VBAP::convertSphericalDegreesToCartesian(VBAP *this, float a2, float a3, float *a4)
{
  double v5 = a2 * 0.0174532925;
  __double2 v6 = __sincos_stret(a3 * 0.0174532925);
  __double2 v7 = __sincos_stret(v5);
  float v8 = v6.__cosval * v7.__cosval;
  *(float *)this = v8;
  float v9 = v6.__cosval * v7.__sinval;
  *((float *)this + 1) = v9;
  float result = v6.__sinval;
  *((float *)this + 2) = result;
  return result;
}

uint64_t VBAP::triangleLookup(VBAP *this, float32x2_t *a2, int *a3, float *a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 315))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t __C = 136315906;
      *(void *)&__C[4] = "VBAP.cpp";
      __int16 v26 = 1024;
      int v27 = 316;
      __int16 v28 = 2080;
      uint64_t v29 = "triangleLookup";
      __int16 v30 = 1024;
      int v31 = 316;
      uint64_t v19 = MEMORY[0x263EF8438];
      uint64_t v20 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; VBAP object not initialized";
      goto LABEL_15;
    }
    return 4294967246;
  }
  unsigned int subtriangle_containment = CDelaunayTriangles3D::find_subtriangle_containment(*((int *)this + 74), a2->f32[0], a2->f32[1], a2[1].f32[0]);
  if ((subtriangle_containment & 0x80000000) != 0
    || (uint64_t v9 = *((void *)this + 34),
        0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 35) - v9) >> 3) <= subtriangle_containment))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t __C = 136315906;
      *(void *)&__C[4] = "VBAP.cpp";
      __int16 v26 = 1024;
      int v27 = 322;
      __int16 v28 = 2080;
      uint64_t v29 = "triangleLookup";
      __int16 v30 = 1024;
      int v31 = 322;
      uint64_t v19 = MEMORY[0x263EF8438];
      uint64_t v20 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Triangle lookup error";
LABEL_15:
      _os_log_impl(&dword_21B4DD000, v19, OS_LOG_TYPE_ERROR, v20, __C, 0x22u);
      return 4294967246;
    }
    return 4294967246;
  }
  *a3 = -1;
  float64x2_t __B = vcvtq_f64_f32(*a2);
  double v24 = a2[1].f32[0];
  uint64_t v10 = v9 + 24 * subtriangle_containment;
  uint64_t v11 = *(void *)(v10 + 8);
  if (v11 == v10)
  {
LABEL_18:
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t __C = 136315906;
      *(void *)&__C[4] = "VBAP.cpp";
      __int16 v26 = 1024;
      int v27 = 349;
      __int16 v28 = 2080;
      uint64_t v29 = "triangleLookup";
      __int16 v30 = 1024;
      int v31 = 349;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Triangle lookup error",
        __C,
        0x22u);
    }
    return 4294964151;
  }
  else
  {
    while (1)
    {
      int v12 = *(_DWORD *)(v11 + 16);
      *(void *)uint64_t __C = 0;
      int v13 = 9 * v12;
      vDSP_dotprD((const double *)(*((void *)this + 31) + 72 * v12), 1, __B.f64, 1, (double *)__C, 3uLL);
      if (*(double *)__C > -0.00000011920929)
      {
        double v22 = 0.0;
        vDSP_dotprD((const double *)(*((void *)this + 31) + 8 * (v13 + 3)), 1, __B.f64, 1, &v22, 3uLL);
        if (v22 > -0.00000011920929)
        {
          double v21 = 0.0;
          vDSP_dotprD((const double *)(*((void *)this + 31) + 8 * (v13 + 6)), 1, __B.f64, 1, &v21, 3uLL);
          double v14 = v21;
          if (v21 > -0.00000011920929) {
            break;
          }
        }
      }
      uint64_t v11 = *(void *)(v11 + 8);
      if (v11 == v10) {
        goto LABEL_18;
      }
    }
    uint64_t result = 0;
    float v16 = *(double *)__C;
    float v17 = v22;
    *a4 = v16;
    a4[1] = v17;
    float v18 = v14;
    a4[2] = v18;
    *a3 = v12;
  }
  return result;
}

void VBAP::~VBAP(VBAP *this)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 34);
  if (v2)
  {
    unint64_t v3 = (uint64_t *)*((void *)this + 35);
    uint64_t v4 = (void *)*((void *)this + 34);
    if (v3 != v2)
    {
      do
      {
        double v5 = v3 - 3;
        if (*(v3 - 1))
        {
          uint64_t v7 = *(v3 - 3);
          __double2 v6 = (uint64_t *)*(v3 - 2);
          uint64_t v8 = *v6;
          *(void *)(v8 + 8) = *(void *)(v7 + 8);
          **(void **)(v7 + 8) = v8;
          *(v3 - 1) = 0;
          if (v6 != v5)
          {
            do
            {
              uint64_t v9 = (uint64_t *)v6[1];
              operator delete(v6);
              __double2 v6 = v9;
            }
            while (v9 != v5);
          }
        }
        unint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)*((void *)this + 34);
    }
    *((void *)this + 35) = v2;
    operator delete(v4);
  }
  uint64_t v10 = (void *)*((void *)this + 31);
  if (v10)
  {
    *((void *)this + 32) = v10;
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 28);
  if (v11)
  {
    *((void *)this + 29) = v11;
    operator delete(v11);
  }
  if (*((void *)this + 27))
  {
    uint64_t v13 = *((void *)this + 25);
    int v12 = (VBAP *)*((void *)this + 26);
    uint64_t v14 = *(void *)v12;
    *(void *)(v14 + 8) = *(void *)(v13 + 8);
    **(void **)(v13 + 8) = v14;
    *((void *)this + 27) = 0;
    if (v12 != (VBAP *)((char *)this + 200))
    {
      do
      {
        uint64_t v15 = (VBAP *)*((void *)v12 + 1);
        operator delete(v12);
        int v12 = v15;
      }
      while (v15 != (VBAP *)((char *)this + 200));
    }
  }
  if (*((void *)this + 24))
  {
    uint64_t v17 = *((void *)this + 22);
    float v16 = (VBAP *)*((void *)this + 23);
    uint64_t v18 = *(void *)v16;
    *(void *)(v18 + 8) = *(void *)(v17 + 8);
    **(void **)(v17 + 8) = v18;
    *((void *)this + 24) = 0;
    if (v16 != (VBAP *)((char *)this + 176))
    {
      do
      {
        uint64_t v19 = (VBAP *)*((void *)v16 + 1);
        operator delete(v16);
        float v16 = v19;
      }
      while (v19 != (VBAP *)((char *)this + 176));
    }
  }
  uint64_t v20 = *((void *)this + 19);
  if (v20)
  {
    uint64_t v21 = *((void *)this + 20);
    double v22 = (void *)*((void *)this + 19);
    if (v21 != v20)
    {
      uint64_t v23 = *((void *)this + 20);
      do
      {
        uint64_t v25 = *(void **)(v23 - 24);
        v23 -= 24;
        double v24 = v25;
        if (v25)
        {
          *(void *)(v21 - 16) = v24;
          operator delete(v24);
        }
        uint64_t v21 = v23;
      }
      while (v23 != v20);
      double v22 = (void *)*((void *)this + 19);
    }
    *((void *)this + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v20;
    operator delete(v22);
  }
  __int16 v26 = (void *)*((void *)this + 16);
  if (v26)
  {
    *((void *)this + 17) = v26;
    operator delete(v26);
  }
  int v27 = (void *)*((void *)this + 13);
  if (v27)
  {
    *((void *)this + 14) = v27;
    operator delete(v27);
  }
  __int16 v28 = (void *)*((void *)this + 10);
  if (v28)
  {
    *((void *)this + 11) = v28;
    operator delete(v28);
  }
  uint64_t v29 = (void *)*((void *)this + 7);
  if (v29)
  {
    *((void *)this + 8) = v29;
    operator delete(v29);
  }
  __int16 v30 = (void *)*((void *)this + 4);
  if (v30)
  {
    *((void *)this + 5) = v30;
    operator delete(v30);
  }
  int v31 = (void *)*((void *)this + 1);
  if (v31)
  {
    *((void *)this + 2) = v31;
    operator delete(v31);
  }
}

uint64_t VBAP::calculateVBAPGains(VBAP *this, float32x2_t *a2, float *__C)
{
  uint64_t v137 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 315))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      buf[0] = 136315906;
      *(void *)&buf[1] = "VBAP.cpp";
      __int16 v131 = 1024;
      int v132 = 579;
      __int16 v133 = 2080;
      long long v134 = "calculateVBAPGains";
      __int16 v135 = 1024;
      int v136 = 579;
      __double2 v6 = MEMORY[0x263EF8438];
      uint64_t v7 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Can not calculate gain if the VBAP object is not initialized";
      goto LABEL_11;
    }
    return 4294967246;
  }
  if (a2->f32[0] == 0.0 && a2->f32[1] == 0.0 && a2[1].f32[0] == 0.0)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      buf[0] = 136315906;
      *(void *)&buf[1] = "VBAP.cpp";
      __int16 v131 = 1024;
      int v132 = 585;
      __int16 v133 = 2080;
      long long v134 = "calculateVBAPGains";
      __int16 v135 = 1024;
      int v136 = 585;
      __double2 v6 = MEMORY[0x263EF8438];
      uint64_t v7 = "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Can not calculate gain for a source location [0, 0, 0]";
LABEL_11:
      _os_log_impl(&dword_21B4DD000, v6, OS_LOG_TYPE_ERROR, v7, (uint8_t *)buf, 0x22u);
      return 4294967246;
    }
    return 4294967246;
  }
  vDSP_vclr(__C, 1, *((unsigned int *)this + 75));
  vDSP_vclr(*((float **)this + 16), 1, (uint64_t)(*((void *)this + 17) - *((void *)this + 16)) >> 2);
  float64x2_t v8 = vcvtq_f64_f32(*a2);
  v9.f64[0] = a2[1].f32[0];
  float64x2_t v10 = vmulq_f64(v9, v9);
  float64x2_t v11 = vmulq_f64(v8, v8);
  v10.f64[0] = 1.0 / sqrt(vaddvq_f64(v11) + v10.f64[0]);
  float64x2_t v12 = vmulq_f64(v10, v9);
  float64x2_t v13 = vmulq_n_f64(v8, v10.f64[0]);
  unint64_t v14 = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL).u64[0];
  if (*((unsigned char *)this + 314))
  {
    uint64_t v15 = 0;
    uint64_t v16 = *((void *)this + 7);
    v9.f64[0] = *(float *)(v16 + 8);
    *(void *)&v13.f64[1] = v14;
    v11.f64[0] = *(float *)(v16 + 20);
    float v17 = sqrt((vaddvq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v16), v13)) + vmulq_f64(v9, v12).f64[0]) * 0.5 + 0.5);
    float v18 = sqrt((vaddvq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(v16 + 12)), v13)) + vmulq_f64(v11, v12).f64[0]) * 0.5+ 0.5);
    *uint64_t __C = v17;
    __C[1] = v18;
    return v15;
  }
  if (*((_DWORD *)this + 75) < 2u)
  {
    uint64_t v15 = 0;
    *uint64_t __C = 1.0;
    return v15;
  }
  unint64_t v119 = v14;
  float64_t v120 = v13.f64[0];
  float64x2_t v121 = v12;
  int v125 = 0;
  int v129 = 0;
  uint64_t v128 = 0;
  uint64_t v15 = VBAP::triangleLookup(this, a2, &v125, (float *)&v128);
  if (v15)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      buf[0] = 136315906;
      *(void *)&buf[1] = "VBAP.cpp";
      __int16 v131 = 1024;
      int v132 = 619;
      __int16 v133 = 2080;
      long long v134 = "calculateVBAPGains";
      __int16 v135 = 1024;
      int v136 = 619;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: VBAP Error; Triangle lookup failed",
        (uint8_t *)buf,
        0x22u);
    }
    return v15;
  }
  uint64_t v23 = (unsigned int *)(*((void *)this + 28) + 12 * v125);
  uint64_t v24 = (int)v23[1];
  uint64_t v25 = *((void *)this + 4);
  v20.f64[0] = *(float *)(v25 + 4 * (int)(3 * *v23 + 2));
  v21.f64[0] = *(float *)(v25 + 4 * (3 * (int)v24 + 2));
  uint64_t v26 = (int)v23[2];
  v22.f64[0] = *(float *)(v25 + 4 * (3 * (int)v26 + 2));
  float64x2_t v27 = vcvtq_f64_f32(*(float32x2_t *)(v25 + 12 * (int)*v23));
  float64x2_t v28 = vcvtq_f64_f32(*(float32x2_t *)(v25 + 12 * v24));
  float64x2_t v29 = vcvtq_f64_f32(*(float32x2_t *)(v25 + 12 * v26));
  double v30 = vaddvq_f64(vmulq_f64(v28, v27)) + vmulq_f64(v21, v20).f64[0];
  double v31 = vaddvq_f64(vmulq_f64(v29, v28)) + vmulq_f64(v22, v21).f64[0];
  float64x2_t v37 = vmulq_f64(v29, v27);
  v37.f64[0] = vaddvq_f64(v37) + vmulq_f64(v22, v20).f64[0];
  double v32 = 1.0 - v30 * v30;
  double v33 = -(v37.f64[0] - v31 * v30) / v32;
  double v34 = -(v31 - v37.f64[0] * v30) / v32;
  float64x2_t v35 = vmlaq_n_f64(vmlaq_n_f64(v29, v28, v34), v27, v33);
  float64x2_t v36 = vmlsq_lane_f64(v28, v27, v30, 0);
  v37.f64[0] = v21.f64[0] - v30 * v20.f64[0];
  v22.f64[0] = v22.f64[0] + v34 * v21.f64[0] + v33 * v20.f64[0];
  v38.f64[0] = v120;
  *(void *)&v38.f64[1] = v119;
  *(void *)&double v39 = *(_OWORD *)&vmulq_f64(v20, v121);
  double v40 = vaddvq_f64(vmulq_f64(v27, v38));
  float64x2_t v42 = vmulq_f64(v37, v37);
  double v41 = vaddvq_f64(vmulq_f64(v36, v36)) + v42.f64[0];
  v42.f64[0] = 0.0;
  double v43 = 0.0;
  if (v41 >= 0.00000999999975) {
    double v43 = (vaddvq_f64(vmulq_f64(v36, v38)) + vmulq_f64(v37, v121).f64[0]) / v41;
  }
  double v44 = vaddvq_f64(vmulq_f64(v35, v35)) + vmulq_f64(v22, v22).f64[0];
  if (v44 >= 0.00000999999975)
  {
    float64x2_t v42 = vmulq_f64(v22, v121);
    v42.f64[0] = (vaddvq_f64(vmulq_f64(v35, v38)) + v42.f64[0]) / v44;
  }
  double v45 = v40 + v39 - v43 * v30 + v42.f64[0] * v33;
  double v46 = v43 + v42.f64[0] * v34;
  v47.f64[0] = v45;
  v47.f64[1] = v46;
  double v48 = vaddvq_f64(vmulq_f64(v47, v47)) + vmulq_f64(v42, v42).f64[0];
  double v49 = 0.0;
  double v50 = 0.0;
  double v51 = 0.0;
  if (v48 > 0.00000999999975)
  {
    double v52 = 1.0 / sqrt(v48);
    double v49 = v52 * v45;
    double v53 = v52 * v46;
    double v51 = v52 * v42.f64[0];
    double v50 = v53;
  }
  uint64_t v54 = *((unsigned int *)this + 75);
  uint64_t v55 = (int)*v23;
  if (v55 >= v54)
  {
    uint64_t v57 = *((void *)this + 16);
    uint64_t v58 = 4 * ((int)v55 - (int)v54);
    float v59 = v49 + *(float *)(v57 + v58);
    *(float *)(v57 + v58) = v59;
  }
  else
  {
    float v56 = v49;
    __C[v55] = v56;
  }
  if (v24 >= v54)
  {
    uint64_t v61 = *((void *)this + 16);
    uint64_t v62 = 4 * ((int)v24 - (int)v54);
    float v63 = v50 + *(float *)(v61 + v62);
    *(float *)(v61 + v62) = v63;
  }
  else
  {
    float v60 = v50;
    __C[v24] = v60;
  }
  if (v26 >= v54)
  {
    uint64_t v65 = *((void *)this + 16);
    uint64_t v66 = 4 * ((int)v26 - (int)v54);
    double v51 = v51 + *(float *)(v65 + v66);
    *(float *)&double v51 = v51;
    *(_DWORD *)(v65 + v66) = LODWORD(v51);
    memset(buf, 0, sizeof(buf));
    if (!v54)
    {
      int v67 = 0;
      goto LABEL_40;
    }
  }
  else
  {
    float v64 = v51;
    __C[v26] = v64;
    memset(buf, 0, sizeof(buf));
  }
  int v67 = 0;
  uint64_t v68 = __C;
  uint64_t v69 = v54;
  do
  {
    if (*v68 >= 0.00001) {
      buf[v67++] = *(_DWORD *)v68;
    }
    else {
      *uint64_t v68 = 0.0;
    }
    ++v68;
    --v69;
  }
  while (v69);
LABEL_40:
  int v127 = 0;
  uint64_t v126 = 0;
  unint64_t v70 = *((void *)this + 38);
  if (v70)
  {
    uint64_t v71 = 0;
    unsigned int v72 = 0;
    uint64_t v73 = *((void *)this + 16);
    do
    {
      float v74 = *(float *)(v73 + 4 * v71);
      if (v74 >= 0.00001) {
        *((float *)&v126 + v72++) = v74;
      }
      else {
        *(_DWORD *)(v73 + 4 * v71) = 0;
      }
      ++v71;
    }
    while (v70 > v71);
    float32x2_t __A = 0;
    if (v67 || v72 != 1)
    {
      if (v67 || v72 != 2)
      {
        if (v67 == 1 && v72 == 1)
        {
          float v75 = sqrtf((float)((float)(*(float *)buf * *(float *)buf) + (float)v54)- (float)((float)(*(float *)buf * *(float *)buf) * (float)v54));
          float v76 = *(float *)&v126 * (float)v54;
          float v77 = (float)-(float)(v75 + *(float *)buf) / v76;
          __A.f32[0] = (float)(v75 - *(float *)buf) / v76;
        }
        else
        {
          if (v67 == 1 && v72 == 2)
          {
            float v78 = (float)(*(float *)&v126 * *(float *)&v126) + (float)(*((float *)&v126 + 1) * *((float *)&v126 + 1));
            float v79 = v78 * (float)v54;
            float v80 = v79 + (float)((float)(*(float *)&v126 + *(float *)&v126) * *((float *)&v126 + 1));
            float v81 = sqrtf(v80 + (float)((float)(*(float *)buf * *(float *)buf) * (float)(v78 - v79)));
            float v82 = (float)(*((float *)&v126 + 1) + *(float *)&v126) * *(float *)buf;
            float v83 = (float)-(float)(v82 + v81) / v80;
            float v77 = (float)(v81 - v82) / v80;
          }
          else
          {
            if (v67 != 2 || v72 != 1) {
              goto LABEL_64;
            }
            float v84 = sqrtf((float)((float)((float)((float)(*(float *)buf * *(float *)buf)+ (float)(*(float *)&buf[1] * *(float *)&buf[1]))+ (float)v54)+ (float)((float)(*(float *)buf + *(float *)buf) * *(float *)&buf[1]))- (float)((float)((float)(*(float *)buf * *(float *)buf)+ (float)(*(float *)&buf[1] * *(float *)&buf[1]))* (float)v54));
            float v85 = *(float *)&v126 * (float)v54;
            float v83 = (float)(v84 - (float)(*(float *)&buf[1] + *(float *)buf)) / v85;
            float v77 = (float)-(float)(v84 + (float)(*(float *)&buf[1] + *(float *)buf)) / v85;
          }
          __A.f32[0] = v83;
        }
        __A.f32[1] = v77;
      }
      else
      {
        *(float *)&double v51 = sqrtf((float)((float)((float)(*(float *)&v126 * *(float *)&v126)+ (float)((float)(*(float *)&v126 + *(float *)&v126) * *((float *)&v126 + 1)))+ (float)(*((float *)&v126 + 1) * *((float *)&v126 + 1)))+ (float)((float)((float)(*((float *)&v126 + 1) * *((float *)&v126 + 1))+ (float)(*(float *)&v126 * *(float *)&v126))* (float)v54));
        float32x2_t __A = vdiv_f32((float32x2_t)0xBF8000003F800000, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v51, 0));
      }
    }
    else
    {
      float32x2_t __A = vcvt_f32_f64(vdivq_f64((float64x2_t)xmmword_21B551450, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt((double)v54) * *(float *)&v126), 0)));
    }
  }
  else
  {
    float32x2_t __A = 0;
  }
LABEL_64:
  float __Ca = 0.0;
  vDSP_maxv((const float *)&__A, 1, &__Ca, 2uLL);
  if (*(_DWORD *)this)
  {
    unsigned int v86 = *((_DWORD *)this + 75);
    uint64_t v87 = *v23 - v86;
    if (*v23 >= v86)
    {
      uint64_t v88 = *(void *)(*((void *)this + 19) + 24 * v87);
      uint64_t v89 = *(void *)(*((void *)this + 19) + 24 * v87 + 8);
      uint64_t v90 = v89 - v88;
      if (v89 != v88)
      {
        uint64_t v91 = 0;
        unint64_t v92 = v90 >> 2;
        uint64_t v93 = *((void *)this + 16);
        uint64_t v94 = *((void *)this + 13);
        uint64_t v95 = 4 * v87;
        do
        {
          uint64_t v96 = *(unsigned int *)(v88 + 4 * v91);
          __C[v96] = (float)(*(float *)(v93 + v95) / (float)(*(float *)(v94 + v95) * (float)v92)) + __C[v96];
          ++v91;
        }
        while (v92 > v91);
      }
    }
    unsigned int v97 = v23[1];
    uint64_t v98 = v97 - v86;
    if (v97 >= v86)
    {
      uint64_t v99 = *(void *)(*((void *)this + 19) + 24 * v98);
      uint64_t v100 = *(void *)(*((void *)this + 19) + 24 * v98 + 8);
      uint64_t v101 = v100 - v99;
      if (v100 != v99)
      {
        uint64_t v102 = 0;
        unint64_t v103 = v101 >> 2;
        uint64_t v104 = *((void *)this + 16);
        uint64_t v105 = *((void *)this + 13);
        uint64_t v106 = 4 * v98;
        do
        {
          uint64_t v107 = *(unsigned int *)(v99 + 4 * v102);
          __C[v107] = (float)(*(float *)(v104 + v106) / (float)(*(float *)(v105 + v106) * (float)v103)) + __C[v107];
          ++v102;
        }
        while (v103 > v102);
      }
    }
    unsigned int v108 = v23[2];
    uint64_t v109 = v108 - v86;
    if (v108 >= v86)
    {
      uint64_t v110 = *(void *)(*((void *)this + 19) + 24 * v109);
      uint64_t v111 = *(void *)(*((void *)this + 19) + 24 * v109 + 8);
      uint64_t v112 = v111 - v110;
      if (v111 != v110)
      {
        uint64_t v113 = 0;
        unint64_t v114 = v112 >> 2;
        uint64_t v115 = *((void *)this + 16);
        uint64_t v116 = *((void *)this + 13);
        uint64_t v117 = 4 * v109;
        do
        {
          uint64_t v118 = *(unsigned int *)(v110 + 4 * v113);
          __C[v118] = (float)(*(float *)(v115 + v117) / (float)(*(float *)(v116 + v117) * (float)v114)) + __C[v118];
          ++v113;
        }
        while (v114 > v113);
      }
    }
  }
  else
  {
    float __B = 0.0;
    vDSP_sve(*((const float **)this + 16), 1, &__B, *((void *)this + 38));
    float __B = __B * __Ca;
    vDSP_vsadd(__C, 1, &__B, __C, 1, *((unsigned int *)this + 75));
    unsigned int v86 = *((_DWORD *)this + 75);
  }
  float __B = 0.0;
  vDSP_svesq(__C, 1, &__B, v86);
  float __B = 1.0 / sqrtf(__B);
  vDSP_vsmul(__C, 1, &__B, __C, 1, *((unsigned int *)this + 75));
  return v15;
}

uint64_t HOA::getTDesign(HOA *this, _OWORD *__dst, float *a3, float *__C, float *a5)
{
  switch((int)this)
  {
    case 0:
      uint64_t v7 = 1;
      if (__dst && a3)
      {
        *(_DWORD *)std::vector<char> __dst = 0;
        *a3 = 0.0;
      }
      break;
    case 1:
      uint64_t v7 = 4;
      if (__dst && a3)
      {
        *std::vector<char> __dst = xmmword_21B551610;
        *(_OWORD *)a3 = xmmword_21B551620;
      }
      break;
    case 2:
      uint64_t v7 = 12;
      if (__dst && a3)
      {
        *std::vector<char> __dst = xmmword_21B5516AC;
        __dst[1] = unk_21B5516BC;
        __dst[2] = xmmword_21B5516CC;
        float64x2_t v11 = &xmmword_21B5516DC;
        *((_OWORD *)a3 + 2) = xmmword_21B5516FC;
        goto LABEL_20;
      }
      break;
    case 3:
      uint64_t v7 = 24;
      if (__dst && a3)
      {
        __dst[2] = xmmword_21B55172C;
        __dst[3] = unk_21B55173C;
        __dst[4] = xmmword_21B55174C;
        __dst[5] = unk_21B55175C;
        *std::vector<char> __dst = xmmword_21B55170C;
        __dst[1] = unk_21B55171C;
        *((_OWORD *)a3 + 2) = xmmword_21B55178C;
        *((_OWORD *)a3 + 3) = unk_21B55179C;
        *((_OWORD *)a3 + 4) = xmmword_21B5517AC;
        *((_OWORD *)a3 + 5) = unk_21B5517BC;
        *(_OWORD *)a3 = xmmword_21B55176C;
        *((_OWORD *)a3 + 1) = unk_21B55177C;
      }
      break;
    case 4:
      uint64_t v7 = 36;
      if (__dst && a3)
      {
        __dst[2] = xmmword_21B5517EC;
        __dst[3] = unk_21B5517FC;
        __dst[8] = xmmword_21B55184C;
        __dst[6] = xmmword_21B55182C;
        __dst[7] = unk_21B55183C;
        __dst[4] = xmmword_21B55180C;
        __dst[5] = unk_21B55181C;
        *std::vector<char> __dst = xmmword_21B5517CC;
        __dst[1] = unk_21B5517DC;
        float64x2_t v11 = &xmmword_21B55185C;
        *((_OWORD *)a3 + 6) = xmmword_21B5518BC;
        *((_OWORD *)a3 + 7) = unk_21B5518CC;
        *((_OWORD *)a3 + 8) = xmmword_21B5518DC;
        *((_OWORD *)a3 + 2) = xmmword_21B55187C;
        *((_OWORD *)a3 + 3) = unk_21B55188C;
        *((_OWORD *)a3 + 4) = xmmword_21B55189C;
        *((_OWORD *)a3 + 5) = unk_21B5518AC;
LABEL_20:
        long long v12 = v11[1];
        *(_OWORD *)a3 = *v11;
        *((_OWORD *)a3 + 1) = v12;
      }
      break;
    case 5:
      uint64_t v7 = 60;
      if (__dst && a3)
      {
        __dst[12] = xmmword_21B5519AC;
        __dst[13] = unk_21B5519BC;
        __dst[14] = xmmword_21B5519CC;
        __dst[8] = xmmword_21B55196C;
        __dst[9] = unk_21B55197C;
        __dst[10] = xmmword_21B55198C;
        __dst[11] = unk_21B55199C;
        __dst[4] = xmmword_21B55192C;
        __dst[5] = unk_21B55193C;
        __dst[6] = xmmword_21B55194C;
        __dst[7] = unk_21B55195C;
        *std::vector<char> __dst = xmmword_21B5518EC;
        __dst[1] = unk_21B5518FC;
        __dst[2] = xmmword_21B55190C;
        __dst[3] = unk_21B55191C;
        *((_OWORD *)a3 + 12) = xmmword_21B551A9C;
        *((_OWORD *)a3 + 13) = unk_21B551AAC;
        *((_OWORD *)a3 + 14) = xmmword_21B551ABC;
        *((_OWORD *)a3 + 8) = xmmword_21B551A5C;
        *((_OWORD *)a3 + 9) = unk_21B551A6C;
        *((_OWORD *)a3 + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B551A7C;
        *((_OWORD *)a3 + 11) = unk_21B551A8C;
        *((_OWORD *)a3 + 4) = xmmword_21B551A1C;
        *((_OWORD *)a3 + 5) = unk_21B551A2C;
        *((_OWORD *)a3 + 6) = xmmword_21B551A3C;
        *((_OWORD *)a3 + 7) = unk_21B551A4C;
        *(_OWORD *)a3 = xmmword_21B5519DC;
        *((_OWORD *)a3 + 1) = unk_21B5519EC;
        *((_OWORD *)a3 + 2) = xmmword_21B5519FC;
        *((_OWORD *)a3 + 3) = unk_21B551A0C;
      }
      break;
    case 6:
      uint64_t v7 = 84;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B551ACC, 0x150uLL);
        float64x2_t v8 = &unk_21B551C1C;
        float64x2_t v9 = a3;
        size_t v10 = 336;
        goto LABEL_72;
      }
      break;
    case 7:
      uint64_t v7 = 108;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B551D6C, 0x1B0uLL);
        float64x2_t v8 = &unk_21B551F1C;
        float64x2_t v9 = a3;
        size_t v10 = 432;
        goto LABEL_72;
      }
      break;
    case 8:
      uint64_t v7 = 144;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B5520CC, 0x240uLL);
        float64x2_t v8 = &unk_21B55230C;
        float64x2_t v9 = a3;
        size_t v10 = 576;
        goto LABEL_72;
      }
      break;
    case 9:
      uint64_t v7 = 180;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B55254C, 0x2D0uLL);
        float64x2_t v8 = &unk_21B55281C;
        float64x2_t v9 = a3;
        size_t v10 = 720;
        goto LABEL_72;
      }
      break;
    case 10:
      uint64_t v7 = 216;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B552AEC, 0x360uLL);
        float64x2_t v8 = &unk_21B552E4C;
        float64x2_t v9 = a3;
        size_t v10 = 864;
        goto LABEL_72;
      }
      break;
    case 11:
      uint64_t v7 = 266;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B5531AC, 0x428uLL);
        float64x2_t v8 = &unk_21B5535D4;
        float64x2_t v9 = a3;
        size_t v10 = 1064;
        goto LABEL_72;
      }
      break;
    case 12:
      uint64_t v7 = 314;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B5539FC, 0x4E8uLL);
        float64x2_t v8 = &unk_21B553EE4;
        float64x2_t v9 = a3;
        size_t v10 = 1256;
        goto LABEL_72;
      }
      break;
    case 13:
      uint64_t v7 = 366;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B5543CC, 0x5B8uLL);
        float64x2_t v8 = &unk_21B554984;
        float64x2_t v9 = a3;
        size_t v10 = 1464;
        goto LABEL_72;
      }
      break;
    case 14:
      uint64_t v7 = 422;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B554F3C, 0x698uLL);
        float64x2_t v8 = &unk_21B5555D4;
        float64x2_t v9 = a3;
        size_t v10 = 1688;
        goto LABEL_72;
      }
      break;
    case 15:
      uint64_t v7 = 482;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B555C6C, 0x788uLL);
        float64x2_t v8 = &unk_21B5563F4;
        float64x2_t v9 = a3;
        size_t v10 = 1928;
        goto LABEL_72;
      }
      break;
    case 16:
      uint64_t v7 = 546;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B556B7C, 0x888uLL);
        float64x2_t v8 = &unk_21B557404;
        float64x2_t v9 = a3;
        size_t v10 = 2184;
        goto LABEL_72;
      }
      break;
    case 17:
      uint64_t v7 = 614;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B557C8C, 0x998uLL);
        float64x2_t v8 = &unk_21B558624;
        float64x2_t v9 = a3;
        size_t v10 = 2456;
        goto LABEL_72;
      }
      break;
    case 18:
      uint64_t v7 = 686;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B558FBC, 0xAB8uLL);
        float64x2_t v8 = &unk_21B559A74;
        float64x2_t v9 = a3;
        size_t v10 = 2744;
        goto LABEL_72;
      }
      break;
    case 19:
      uint64_t v7 = 762;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B55A52C, 0xBE8uLL);
        float64x2_t v8 = &unk_21B55B114;
        float64x2_t v9 = a3;
        size_t v10 = 3048;
        goto LABEL_72;
      }
      break;
    case 20:
      uint64_t v7 = 842;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B55BCFC, 0xD28uLL);
        float64x2_t v8 = &unk_21B55CA24;
        float64x2_t v9 = a3;
        size_t v10 = 3368;
        goto LABEL_72;
      }
      break;
    case 21:
      uint64_t v7 = 926;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B55D74C, 0xE78uLL);
        float64x2_t v8 = &unk_21B55E5C4;
        float64x2_t v9 = a3;
        size_t v10 = 3704;
        goto LABEL_72;
      }
      break;
    default:
      uint64_t v7 = 1014;
      if (__dst && a3)
      {
        memcpy(__dst, &unk_21B55F43C, 0xFD8uLL);
        float64x2_t v8 = &unk_21B560414;
        float64x2_t v9 = a3;
        size_t v10 = 4056;
LABEL_72:
        memcpy(v9, v8, v10);
      }
      break;
  }
  if (__C)
  {
    float __A = 1.0;
    vDSP_vfill(&__A, __C, 1, v7);
  }
  return v7;
}

uint64_t *std::unique_ptr<DFTSetups>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    unint64_t v3 = *(vDSP_DFT_SetupStruct **)(v2 + 16);
    if (v3) {
      vDSP_DFT_DestroySetup(v3);
    }
    uint64_t v4 = *(vDSP_DFT_SetupStruct **)(v2 + 8);
    if (v4) {
      vDSP_DFT_DestroySetup(v4);
    }
    MEMORY[0x21D48F780](v2, 0x1060C40CA828048);
  }
  return a1;
}

uint64_t std::shared_ptr<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)a1[6];
  if (os_unfair_lock_trylock(v2))
  {
    caulk::shared_instance_manager<DFTSetups>::remove_expired((uint64_t)v2);
    os_unfair_lock_unlock(v2);
  }
  uint64_t v3 = a1[5];
  a1[5] = 0;
  if (v3)
  {
    uint64_t v4 = *(vDSP_DFT_SetupStruct **)(v3 + 16);
    if (v4) {
      vDSP_DFT_DestroySetup(v4);
    }
    double v5 = *(vDSP_DFT_SetupStruct **)(v3 + 8);
    if (v5) {
      vDSP_DFT_DestroySetup(v5);
    }
    MEMORY[0x21D48F780](v3, 0x1060C40CA828048);
  }
  __double2 v6 = (std::__shared_weak_count *)a1[4];
  if (v6)
  {
    std::__shared_weak_count::__release_weak(v6);
  }
}

void caulk::shared_instance_manager<DFTSetups>::remove_expired(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *(uint64_t **)(a1 + 16);
  if (v1 != v2)
  {
    while (1)
    {
      uint64_t v4 = v1[1];
      if (!v4 || *(void *)(v4 + 8) == -1) {
        break;
      }
      v1 += 2;
      if (v1 == v2) {
        return;
      }
    }
    if (v1 != v2)
    {
      double v5 = v1 + 2;
      if (v1 + 2 != v2)
      {
        do
        {
          uint64_t v6 = v5[1];
          if (v6 && *(void *)(v6 + 8) != -1)
          {
            uint64_t v7 = *v5;
            *double v5 = 0;
            v5[1] = 0;
            float64x2_t v8 = (std::__shared_weak_count *)v1[1];
            uint64_t *v1 = v7;
            v1[1] = v6;
            if (v8) {
              std::__shared_weak_count::__release_weak(v8);
            }
            v1 += 2;
          }
          v5 += 2;
        }
        while (v5 != v2);
        uint64_t v2 = *(uint64_t **)(a1 + 16);
      }
    }
    if (v1 != v2)
    {
      while (v2 != v1)
      {
        float64x2_t v9 = (std::__shared_weak_count *)*(v2 - 1);
        if (v9) {
          std::__shared_weak_count::__release_weak(v9);
        }
        v2 -= 2;
      }
      *(void *)(a1 + 16) = v1;
    }
  }
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB574A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21D48F780);
}

void std::__shared_ptr_emplace<caulk::lifetime_observed<std::unique_ptr<DFTSetups>,caulk::shared_instance_manager<DFTSetups>::observer>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CB574A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t MultiRadixRealFFT::Initialize(MultiRadixRealFFT *this, unsigned int a2)
{
  {
    operator new();
  }
  uint64_t v4 = DFTSetupList<false>::instance(void)::global;
  os_unfair_lock_lock((os_unfair_lock_t)DFTSetupList<false>::instance(void)::global);
  caulk::shared_instance_manager<DFTSetups>::remove_expired(v4);
  double v5 = *(void **)(v4 + 8);
  uint64_t v6 = *(void **)(v4 + 16);
  if (v5 == v6)
  {
LABEL_11:
    Setup = vDSP_DFT_zrop_CreateSetup(0, a2, vDSP_DFT_FORWARD);
    if (Setup) {
      vDSP_DFT_zrop_CreateSetup(Setup, a2, vDSP_DFT_INVERSE);
    }
    operator new();
  }
  while (1)
  {
    uint64_t v7 = (std::__shared_weak_count *)v5[1];
    if (v7)
    {
      float64x2_t v8 = std::__shared_weak_count::lock(v7);
      if (v8) {
        break;
      }
    }
LABEL_4:
    v5 += 2;
    if (v5 == v6) {
      goto LABEL_11;
    }
  }
  float64x2_t v9 = v8;
  if (!*v5 || (uint64_t v10 = *(void *)(*v5 + 16), *(_DWORD *)v10 != a2))
  {
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v9);
    }
    goto LABEL_4;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v9);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v4);
  if (*(void *)(v10 + 8) && *(void *)(v10 + 16))
  {
    uint64_t v12 = 0;
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    float64x2_t v13 = v9;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v12 = 1936292453;
    float64x2_t v13 = 0;
  }
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v14 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = v10;
  *((void *)this + 1) = v13;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    if (v13) {
      goto LABEL_27;
    }
  }
  else if (v13)
  {
LABEL_27:
    if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  return v12;
}

void sub_21B538D28(_Unwind_Exception *a1)
{
}

void sub_21B538D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<DFTSetups>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  os_unfair_lock_unlock(v4);
  _Unwind_Resume(a1);
}

uint64_t MultiRadixRealFFT::Size(MultiRadixRealFFT *this)
{
  if (*(void *)this) {
    return **(unsigned int **)this;
  }
  else {
    return 0;
  }
}

uint64_t MultiRadixRealFFT::RealInPlaceTransform(MultiRadixRealFFT *this, DSPSplitComplex *a2, int a3, float a4)
{
  if (!*(void *)this) {
    abort();
  }
  uint64_t v8 = 16;
  if (a3 == 1) {
    uint64_t v8 = 8;
  }
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(*(void *)this + v8), a2->realp, a2->imagp, a2->realp, a2->imagp);
  if (a3 == 1)
  {
    float __B = a4 * 0.5;
    vDSP_vsmul(a2->realp, 1, &__B, a2->realp, 1, (unint64_t)**(unsigned int **)this >> 1);
    vDSP_vsmul(a2->imagp, 1, &__B, a2->imagp, 1, (unint64_t)**(unsigned int **)this >> 1);
  }
  return 0;
}

uint64_t HOA::RotationMatrix::RotationMatrix(uint64_t a1, unsigned int a2, int a3, char a4)
{
  unsigned int v4 = a2;
  uint64_t v38 = *MEMORY[0x263EF8340];
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = a3;
  *(unsigned char *)(a1 + 52) = a4;
  if (a2 >= 4 && a3 == 2)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      int v28 = 136316162;
      float64x2_t v29 = "HOA.cpp";
      __int16 v30 = 1024;
      __int16 v32 = 2080;
      int v31 = 29;
      double v33 = "RotationMatrix";
      __int16 v34 = 1024;
      int v35 = 29;
      __int16 v36 = 1024;
      unsigned int v37 = v4;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Trying to create a HOA rotation matrix of order = %d > 3 with FuMa norm"
        "alization, capping to order 3",
        (uint8_t *)&v28,
        0x28u);
    }
    unsigned int v4 = 3;
  }
  unint64_t v6 = v4 + 1;
  int v28 = 0;
  std::vector<float>::assign((char **)a1, (8 * v6 * (unint64_t)v6 - 2) * v6 / 6, &v28);
  uint64_t v7 = *(unsigned char **)(a1 + 24);
  if (v6 > (uint64_t)(*(void *)(a1 + 40) - (void)v7) >> 4)
  {
    uint64_t v8 = *(unsigned char **)(a1 + 32);
    float64x2_t v9 = (char *)operator new(16 * v6);
    uint64_t v10 = &v9[(v8 - v7) & 0xFFFFFFFFFFFFFFF0];
    float64x2_t v11 = v10;
    if (v8 != v7)
    {
      uint64_t v12 = &v9[(v8 - v7) & 0xFFFFFFFFFFFFFFF0];
      do
      {
        float64x2_t v11 = v12 - 16;
        *((_OWORD *)v12 - 1) = *((_OWORD *)v8 - 1);
        v8 -= 16;
        v12 -= 16;
      }
      while (v8 != v7);
    }
    *(void *)(a1 + 24) = v11;
    *(void *)(a1 + 32) = v10;
    *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = &v9[16 * v6];
    if (v7) {
      operator delete(v7);
    }
  }
  unsigned int v13 = 0;
  unint64_t v14 = *(unint64_t **)(a1 + 32);
  do
  {
    unint64_t v16 = ((2 * v13) | 1) * ((2 * v13) | 1);
    unint64_t v17 = *(void *)a1 + 4 * ((8 * v13 * v13 - 2) * v13 / 6uLL);
    unint64_t v18 = *(void *)(a1 + 40);
    if ((unint64_t)v14 < v18)
    {
      *unint64_t v14 = v17;
      v14[1] = v16;
      uint64_t v15 = v14 + 2;
    }
    else
    {
      uint64_t v19 = *(unint64_t **)(a1 + 24);
      uint64_t v20 = ((char *)v14 - (char *)v19) >> 4;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 60) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v22 = v18 - (void)v19;
      if (v22 >> 3 > v21) {
        unint64_t v21 = v22 >> 3;
      }
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23)
      {
        if (v23 >> 60) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v24 = (char *)operator new(16 * v23);
      }
      else
      {
        uint64_t v24 = 0;
      }
      uint64_t v25 = (unint64_t *)&v24[16 * v20];
      *uint64_t v25 = v17;
      v25[1] = v16;
      uint64_t v26 = v25;
      if (v14 != v19)
      {
        do
        {
          *((_OWORD *)v26 - 1) = *((_OWORD *)v14 - 1);
          v26 -= 2;
          v14 -= 2;
        }
        while (v14 != v19);
        unint64_t v14 = *(unint64_t **)(a1 + 24);
      }
      uint64_t v15 = v25 + 2;
      *(void *)(a1 + 24) = v26;
      *(void *)(a1 + 32) = v25 + 2;
      *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = &v24[16 * v23];
      if (v14) {
        operator delete(v14);
      }
    }
    *(void *)(a1 + 32) = v15;
    ++v13;
    unint64_t v14 = v15;
  }
  while (v13 <= v4);
  return a1;
}

void sub_21B539160(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(void *)(v1 + 32) = v3;
    operator delete(v3);
    unsigned int v4 = *(void **)v1;
    if (!*(void *)v1) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    unsigned int v4 = *(void **)v1;
    if (!*(void *)v1) {
      goto LABEL_3;
    }
  }
  *(void *)(v1 + 8) = v4;
  operator delete(v4);
  _Unwind_Resume(exception_object);
}

void HOA::RotationMatrix::setRotationMatrixYPR(float **this, float a2, float a3, float a4)
{
  unsigned int v4 = this;
  uint64_t v133 = *MEMORY[0x263EF8340];
  if (a2 == 0.0 && a3 == 0.0 && a4 == 0.0)
  {
    vDSP_vclr(*this, 1, this[1] - *this);
    double v5 = (float **)v4[3];
    unint64_t v6 = (float **)v4[4];
    if (v5 != v6)
    {
      vDSP_Stride v7 = 2;
      do
      {
        float __A = 1.0;
        uint64_t v8 = *v5;
        v5 += 2;
        vDSP_vfill(&__A, v8, v7, (v7 - 1));
        v7 += 2;
      }
      while (v5 != v6);
    }
    return;
  }
  float64x2_t v9 = this[3];
  unint64_t v10 = (char *)this[4] - (char *)v9;
  unint64_t v11 = v10 >> 4;
  uint64_t v12 = (v10 >> 4) - 1;
  **(_DWORD **)float64x2_t v9 = 1065353216;
  if (v10 >= 0x11 && (v10 >> 4) != 1)
  {
    float v14 = a4 * 0.017453;
    float v15 = a3 * 0.017453;
    __float2 v16 = __sincosf_stret(a2 * -0.017453);
    __float2 v17 = __sincosf_stret(v15);
    __float2 v19 = __sincosf_stret(v14);
    uint64_t v20 = (float *)*((void *)v9 + 2);
    *uint64_t v20 = -(float)((float)((float)(v17.__sinval * v16.__sinval) * v19.__sinval) - (float)(v19.__cosval * v16.__cosval));
    v20[1] = -(float)((float)((float)(v17.__sinval * v16.__sinval) * v19.__cosval) + (float)(v19.__sinval * v16.__cosval));
    v20[2] = v17.__cosval * v16.__sinval;
    void v20[3] = v19.__sinval * v17.__cosval;
    v20[4] = v19.__cosval * v17.__cosval;
    v20[5] = v17.__sinval;
    float v21 = -(float)(v16.__cosval * v17.__sinval);
    v20[6] = -(float)((float)(v19.__cosval * v16.__sinval) - (float)(v21 * v19.__sinval));
    v20[7] = (float)(v19.__sinval * v16.__sinval) + (float)(v21 * v19.__cosval);
    v20[8] = v17.__cosval * v16.__cosval;
    if (v12 == 1) {
      goto LABEL_92;
    }
    unsigned int v108 = v9;
    uint64_t v101 = v4;
    uint64_t v22 = (2 * v12);
    int v23 = (2 * v12) | 1;
    uint64_t v24 = ((uint64_t (*)(void))MEMORY[0x270FA5388])(v18);
    uint64_t v25 = (char *)&v101 - ((4 * (v23 * v23) + 15) & 0x3FFFFFFF0);
    MEMORY[0x270FA5388](v24);
    float64x2_t v27 = (char *)&v101 - v26;
    bzero((char *)&v101 - v26, 4 * (v23 * v23));
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t v120 = v23;
    int v30 = *((_DWORD *)v20 + 2);
    *(void *)float64x2_t v27 = *(void *)v20;
    *((_DWORD *)v27 + 2) = v30;
    int v31 = &v27[4 * v23];
    uint64_t v32 = *(void *)(v20 + 3);
    double v33 = &v27[8 * v23];
    unint64_t v106 = (8 * ((unint64_t)(int)v22 >> 1)) | 4;
    uint64_t v105 = (v11 - 2);
    *((float *)v31 + 2) = v20[5];
    unint64_t v104 = (v12 << 33) ^ 0xFFFFFFFE00000000;
    unint64_t v115 = ((unint64_t)v12 << 33) | 0x100000000;
    *(void *)int v31 = v32;
    uint64_t v34 = *((void *)v20 + 3);
    uint64_t v119 = v22 | 1;
    uint64_t v35 = (8 * v11 - 8) | 3;
    *((float *)v33 + 2) = v20[8];
    LODWORD(v32) = 4 * v11;
    uint64_t v36 = (4 * v11 - 4);
    *(void *)double v33 = v34;
    uint64_t v103 = v36 | 2;
    uint64_t v37 = (-2 * v11);
    size_t v38 = 4 * (v23 * v23);
    uint64_t v114 = v37 | 1;
    uint64_t v102 = -(int)v32 | 1;
    uint64_t v39 = -2;
    int v122 = 3;
    uint64_t v124 = -1;
    uint64_t v113 = 5;
    uint64_t v40 = 2;
    uint64_t v41 = 20;
    uint64_t v125 = v36 | 1;
    uint64_t v42 = v36 | 1;
    size_t v107 = v38;
    while (1)
    {
      uint64_t v121 = v41;
      uint64_t v112 = v29;
      uint64_t v109 = 8 * v29;
      bzero(v25, v38);
      int v43 = 0;
      uint64_t v118 = v40 - 1;
      uint64_t v44 = 2 * ((int)v40 - 1);
      uint64_t v129 = v40 * v120;
      uint64_t v128 = v40 * v120 + v44;
      uint64_t v117 = v40 - 2;
      uint64_t v116 = v44;
      uint64_t v126 = (v40 - 2) * v120 + v44;
      uint64_t v127 = (v40 - 2) * v120;
      uint64_t v45 = v28 + 4;
      size_t v131 = -1;
      uint64_t v110 = v42;
      uint64_t v130 = v42;
      int v46 = v102;
      uint64_t v111 = v35;
      int v47 = v35;
      uint64_t v48 = v104;
      uint64_t v49 = v39;
      do
      {
        uint64_t v50 = 0;
        if ((int)v49 >= 0) {
          int v51 = v49;
        }
        else {
          int v51 = -(int)v49;
        }
        int v52 = v51 + v40;
        int v53 = v51 + v40 - 1;
        int v54 = v40 - v51;
        int v55 = v49 + v40;
        float v56 = (float)((v53 << (v49 == 0)) * v52);
        if (v49) {
          float v57 = 0.5;
        }
        else {
          float v57 = -0.5;
        }
        float v58 = (float)((v54 - 1) * v54);
        if (v49) {
          float v59 = 1.0;
        }
        else {
          float v59 = 0.0;
        }
        float v60 = v59 * -0.5;
        uint64_t v61 = (v49 + v118) * v120;
        uint64_t v62 = v61 + v116;
        uint64_t v63 = v55 * (int)v120 + (int)v116;
        uint64_t v64 = v55 * (int)v120;
        if (v49 == -1) {
          float v65 = 0.0;
        }
        else {
          float v65 = 1.0;
        }
        int v66 = (v118 + ~v49) * v120;
        uint64_t v67 = v66 + (int)v116;
        uint64_t v68 = v66;
        if (v49 == -1) {
          float v69 = 1.0;
        }
        else {
          float v69 = 0.0;
        }
        float v70 = sqrtf(v69 + 1.0);
        int v71 = (v117 + v49) * v120;
        uint64_t v72 = v71 + (int)v116;
        int v73 = v40 - v49;
        if (v49 == 1) {
          float v74 = 1.0;
        }
        else {
          float v74 = 0.0;
        }
        float v75 = v74 + 1.0;
        int v76 = v73 * v120;
        uint64_t v77 = v73 * (int)v120 + (int)v116;
        uint64_t v78 = v76;
        if (v49 == 1) {
          float v79 = 0.0;
        }
        else {
          float v79 = 1.0;
        }
        int v80 = 4;
        uint64_t v123 = v48;
        float v81 = sqrtf(v75);
        do
        {
          LODWORD(v86) = v39 + v50;
          if ((int)v39 + (int)v50 >= 0) {
            uint64_t v86 = v86;
          }
          else {
            uint64_t v86 = -(int)v86;
          }
          if (v40 == v86) {
            int v87 = (2 * v40 - 1) * 2 * v40;
          }
          else {
            int v87 = v50 * (v28 + v80);
          }
          float v88 = 1.0 / (float)v87;
          float v89 = sqrtf((float)((v49 + v40) * (v40 - v49)) * v88);
          if (v89 != 0.0)
          {
            if (v50)
            {
              if (v45 == v50) {
                float v90 = -(float)((float)(*(float *)&v27[4 * v61] * v20[3]) - (float)(*(float *)&v27[4 * v62] * v20[5]));
              }
              else {
                float v90 = *(float *)&v27[v48 >> 30] * v20[4];
              }
            }
            else
            {
              float v90 = (float)(*(float *)&v27[4 * v61] * v20[5]) + (float)(*(float *)&v27[4 * v62] * v20[3]);
            }
            float v89 = v90 * v89;
          }
          float v91 = v57 * sqrtf(v56 * v88);
          float v85 = v60 * sqrtf(v58 * v88);
          if (v91 == 0.0)
          {
            if (v85 != 0.0)
            {
              if (v49 >= 1)
              {
LABEL_74:
                if (v50)
                {
                  if (v45 == v50) {
                    float v84 = (float)-(float)((float)(*(float *)&v27[4 * v64] * v20[6])
                  }
                                        - (float)(*(float *)&v27[4 * v63] * v20[8]))
                        - (float)((float)(*(float *)&v27[4 * v68] * *v20) - (float)(*(float *)&v27[4 * v67] * v20[2]));
                  else {
                    float v84 = (float)(*(float *)&v27[4 * (int)v130 + 4 * (int)v50] * v20[1])
                  }
                        + (float)(*(float *)&v27[4 * (int)v131 + 4 * (int)v50] * v20[7]);
                }
                else
                {
                  float v84 = (float)((float)(*(float *)&v27[4 * v68] * v20[2]) + (float)(*(float *)&v27[4 * v67] * *v20))
                      + (float)((float)(*(float *)&v27[4 * v64] * v20[8]) + (float)(*(float *)&v27[4 * v63] * v20[6]));
                }
              }
              else
              {
LABEL_84:
                if (v50)
                {
                  if (v45 == v50)
                  {
                    float v82 = -(float)((float)(*(float *)&v27[4 * v71] * v20[6]) - (float)(*(float *)&v27[4 * v72] * v20[8]));
                    float v83 = -(float)((float)(*(float *)&v27[4 * v78] * *v20) - (float)(*(float *)&v27[4 * v77] * v20[2]));
                  }
                  else
                  {
                    float v82 = *(float *)&v27[4 * v46 + 4 * (int)v50] * v20[7];
                    float v83 = *(float *)&v27[4 * v47 + 4 * (int)v50] * v20[1];
                  }
                }
                else
                {
                  float v82 = (float)(*(float *)&v27[4 * v71] * v20[8]) + (float)(*(float *)&v27[4 * v72] * v20[6]);
                  float v83 = (float)(*(float *)&v27[4 * v78] * v20[2]) + (float)(*(float *)&v27[4 * v77] * *v20);
                }
                float v84 = v82 - v83;
              }
              float v85 = v84 * v85;
            }
          }
          else
          {
            if (!v49)
            {
              if (v50)
              {
                if (v45 == v50) {
                  float v94 = (float)-(float)((float)(*(float *)&v27[4 * v129] * v20[6])
                }
                                      - (float)(*(float *)&v27[4 * v128] * v20[8]))
                      - (float)((float)(*(float *)&v27[4 * v127] * *v20) - (float)(*(float *)&v27[4 * v126] * v20[2]));
                else {
                  float v94 = (float)(*(float *)&v27[4 * (int)v124 + 4 * (int)v50] * v20[1])
                }
                      + (float)(*(float *)&v27[4 * (int)v125 + 4 * (int)v50] * v20[7]);
              }
              else
              {
                float v94 = (float)((float)(*(float *)&v27[4 * v127] * v20[2]) + (float)(*(float *)&v27[4 * v126] * *v20))
                    + (float)((float)(*(float *)&v27[4 * v129] * v20[8]) + (float)(*(float *)&v27[4 * v128] * v20[6]));
              }
              goto LABEL_83;
            }
            if (v49 < 1)
            {
              if (v50)
              {
                if (v45 == v50)
                {
                  float v95 = -(float)((float)(*(float *)&v27[4 * v64] * v20[6]) - (float)(*(float *)&v27[4 * v63] * v20[8]));
                  float v96 = -(float)((float)(*(float *)&v27[4 * v68] * *v20) - (float)(*(float *)&v27[4 * v67] * v20[2]));
                }
                else
                {
                  float v95 = *(float *)&v27[4 * (int)v131 + 4 * (int)v50] * v20[7];
                  float v96 = *(float *)&v27[4 * (int)v130 + 4 * (int)v50] * v20[1];
                }
              }
              else
              {
                float v95 = (float)(*(float *)&v27[4 * v64] * v20[8]) + (float)(*(float *)&v27[4 * v63] * v20[6]);
                float v96 = (float)(*(float *)&v27[4 * v68] * v20[2]) + (float)(*(float *)&v27[4 * v67] * *v20);
              }
              float v94 = (float)(v95 * v65) + (float)(v96 * v70);
LABEL_83:
              float v91 = v94 * v91;
              if (v85 != 0.0) {
                goto LABEL_84;
              }
              goto LABEL_41;
            }
            if (v50)
            {
              if (v45 == v50)
              {
                float v92 = -(float)((float)(*(float *)&v27[4 * v71] * v20[6]) - (float)(*(float *)&v27[4 * v72] * v20[8]));
                float v93 = -(float)((float)(*(float *)&v27[4 * v78] * *v20) - (float)(*(float *)&v27[4 * v77] * v20[2]));
              }
              else
              {
                float v92 = *(float *)&v27[4 * v46 + 4 * (int)v50] * v20[7];
                float v93 = *(float *)&v27[4 * v47 + 4 * (int)v50] * v20[1];
              }
            }
            else
            {
              float v92 = (float)(*(float *)&v27[4 * v71] * v20[8]) + (float)(*(float *)&v27[4 * v72] * v20[6]);
              float v93 = (float)(*(float *)&v27[4 * v78] * v20[2]) + (float)(*(float *)&v27[4 * v77] * *v20);
            }
            float v91 = (float)-(float)((float)(v93 * v79) - (float)(v92 * v81)) * v91;
            if (v85 != 0.0) {
              goto LABEL_74;
            }
          }
LABEL_41:
          *(float *)&v25[4 * v43 + 4 * (int)v50++] = v91 + (float)(v89 + v85);
          v48 += 0x100000000;
          --v80;
        }
        while (v28 + 5 != v50);
        ++v49;
        uint64_t v48 = v123 + v115;
        v43 += v119;
        v47 += v114;
        v46 += v119;
        v130 += v114;
        v131 += v119;
      }
      while (v122 != v49);
      uint64_t v97 = 0;
      size_t v131 = v109 + 20;
      uint64_t v130 = *(void *)&v108[4 * v40];
      uint64_t v98 = v25;
      uint64_t v99 = v113;
      unint64_t v100 = v106;
      do
      {
        memcpy((void *)(v130 + (v97 & 0x3FFFFFFFCLL)), v98, v131);
        v98 += v100;
        v97 += v121;
        --v99;
      }
      while (v99);
      size_t v38 = v107;
      memcpy(v27, v25, v107);
      ++v40;
      --v39;
      ++v122;
      uint64_t v29 = v112 + 1;
      v113 += 2;
      v28 += 2;
      uint64_t v35 = v111 + v103;
      uint64_t v42 = v110 + v103;
      v124 += v119;
      v125 += v119;
      uint64_t v41 = v121 + 8;
      if (v112 + 1 == v105)
      {
        unsigned int v4 = v101;
LABEL_92:
        if (*((_DWORD *)v4 + 12) == 2) {
          HOA::RotationMatrix::toFuMa((HOA::RotationMatrix *)v4);
        }
        if (*((unsigned char *)v4 + 52))
        {
          HOA::RotationMatrix::transposePrivate((HOA::RotationMatrix *)v4);
        }
        return;
      }
    }
  }
}

void HOA::RotationMatrix::toFuMa(HOA::RotationMatrix *this)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((void *)this + 3);
  unint64_t v2 = *((void *)this + 4) - v1;
  unsigned int v3 = (v2 >> 4) - 1;
  if (v2 >= 0x11 && (v2 >> 4) != 1)
  {
    long long __B = 0u;
    long long v39 = 0u;
    LODWORD(v4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
    DWORD1(__B) = 1065353216;
    __asm { FMOV            V8.2S, #1.0 }
    *(void *)((char *)&v39 + 4) = _D8;
    *(void *)&long long __A = 0;
    long long v27 = 0u;
    *((void *)&__A + 1) = _D8;
    HIDWORD(v27) = 1065353216;
    LODWORD(v28) = 0;
    LODWORD(v15) = 0;
    long long __C = 0u;
    long long v14 = 0u;
    vDSP_mmul(*(const float **)(v1 + 16), 1, (const float *)&__B, 1, (float *)&__C, 1, 3uLL, 3uLL, 3uLL);
    vDSP_mmul((const float *)&__A, 1, (const float *)&__C, 1, *(float **)(*((void *)this + 3) + 16), 1, 3uLL, 3uLL, 3uLL);
    if (v3 != 1)
    {
      long long v42 = 0u;
      long long v43 = 0u;
      LODWORD(v44) = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      long long __B = 0u;
      long long v39 = 0u;
      LODWORD(v39) = 1065353216;
      HIDWORD(v39) = 1065353216;
      DWORD2(v4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 1065353216;
      LODWORD(v42) = 1065353216;
      HIDWORD(v43) = 1065353216;
      memset(v30, 0, sizeof(v30));
      LODWORD(v31) = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      long long __A = 0u;
      long long v27 = 0u;
      DWORD2(__A) = 1065353216;
      LODWORD(v28) = 1065353216;
      HIDWORD(v28) = 1065353216;
      *(void *)((char *)v30 + 12) = _D8;
      LODWORD(v19) = 0;
      long long v17 = 0u;
      long long v18 = 0u;
      long long v15 = 0u;
      long long v16 = 0u;
      long long __C = 0u;
      long long v14 = 0u;
      vDSP_mmul(*(const float **)(*((void *)this + 3) + 32), 1, (const float *)&__B, 1, (float *)&__C, 1, 5uLL, 5uLL, 5uLL);
      vDSP_mmul((const float *)&__A, 1, (const float *)&__C, 1, *(float **)(*((void *)this + 3) + 32), 1, 5uLL, 5uLL, 5uLL);
      if (v3 != 2)
      {
        int v50 = 0;
        long long v46 = xmmword_21B564364;
        long long v47 = unk_21B564374;
        long long v48 = xmmword_21B564384;
        long long v49 = unk_21B564394;
        long long v42 = xmmword_21B564324;
        long long v43 = unk_21B564334;
        long long v44 = xmmword_21B564344;
        long long v45 = unk_21B564354;
        long long __B = xmmword_21B5642E4;
        long long v39 = *(_OWORD *)algn_21B5642F4;
        long long v40 = xmmword_21B564304;
        long long v41 = unk_21B564314;
        long long v33 = xmmword_21B564428;
        long long v34 = unk_21B564438;
        long long v35 = xmmword_21B564448;
        long long v36 = unk_21B564458;
        v30[0] = xmmword_21B5643E8;
        v30[1] = unk_21B5643F8;
        long long v31 = xmmword_21B564408;
        long long v32 = unk_21B564418;
        long long __A = xmmword_21B5643A8;
        long long v27 = unk_21B5643B8;
        long long v28 = xmmword_21B5643C8;
        long long v29 = unk_21B5643D8;
        int v37 = 0;
        int v25 = 0;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        long long __C = 0u;
        long long v14 = 0u;
        vDSP_mmul(*(const float **)(*((void *)this + 3) + 48), 1, (const float *)&__B, 1, (float *)&__C, 1, 7uLL, 7uLL, 7uLL);
        vDSP_mmul((const float *)&__A, 1, (const float *)&__C, 1, *(float **)(*((void *)this + 3) + 48), 1, 7uLL, 7uLL, 7uLL);
        if (v3 >= 4)
        {
          unsigned int v10 = 4;
          int v11 = 9;
          do
          {
            uint64_t v12 = *(float **)(*((void *)this + 3) + 16 * v10);
            if (v12) {
              vDSP_vclr(v12, 1, (v11 * v11));
            }
            ++v10;
            v11 += 2;
          }
          while (v10 <= v3);
        }
      }
    }
  }
}

void HOA::RotationMatrix::transposePrivate(HOA::RotationMatrix *this)
{
  v15[1] = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  MEMORY[0x270FA5388](this);
  vDSP_Stride v7 = (float *)((char *)v15 - v6);
  if (v5 >= 0x11 && (v5 & 0xFFFFFFFF0) != 16)
  {
    bzero((char *)v15 - v6, 4 * v4);
    unsigned int v9 = 1;
    unsigned int v10 = 3;
    do
    {
      uint64_t v11 = v3 + 16 * v9;
      uint64_t v12 = *(float **)v11;
      if (*(void *)v11)
      {
        uint64_t v13 = *(void *)(v11 + 8);
        vDSP_mtrans(*(const float **)v11, 1, v7, 1, v10, v10);
        memcpy(v12, v7, 4 * v13);
        uint64_t v3 = *((void *)this + 3);
        uint64_t v2 = *((void *)this + 4);
      }
      ++v9;
      v10 += 2;
      if ((unint64_t)(v2 - v3) <= 0x10) {
        unsigned int v14 = 0;
      }
      else {
        unsigned int v14 = ((unint64_t)(v2 - v3) >> 4) - 1;
      }
    }
    while (v9 <= v14);
  }
}

uint64_t HOA::RotationMatrix::toRegularMatrix(uint64_t a1, char *a2, uint64_t a3, int a4)
{
  unint64_t v4 = *(void *)(a1 + 32) - *(void *)(a1 + 24);
  if (v4 <= 0x10) {
    unsigned int v5 = 1;
  }
  else {
    unsigned int v5 = v4 >> 4;
  }
  int v6 = v5 * v5;
  if (a3 != v6 * v6) {
    return 4294967246;
  }
  bzero(a2, 4 * a3);
  uint64_t v10 = *(void *)(a1 + 24);
  unint64_t v11 = *(void *)(a1 + 32) - v10;
  if (v11 <= 0x10) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = (v11 >> 4) - 1;
  }
  if (v5 <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v5;
  }
  if (*(unsigned __int8 *)(a1 + 52) == a4)
  {
    int v14 = 0;
    unsigned int v15 = 0;
    unint64_t v16 = 0;
    uint64_t v17 = (v6 + 1);
    unsigned int v18 = 1;
    do
    {
      if (v18 <= 1) {
        uint64_t v19 = 1;
      }
      else {
        uint64_t v19 = v18;
      }
      if (v12 >= v16) {
        uint64_t v20 = *(void *)(v10 + 16 * v16);
      }
      else {
        uint64_t v20 = 0;
      }
      if ((v16 & 0x7FFFFFFE) > 5)
      {
        unsigned int v27 = 0;
        uint64_t v28 = 0;
        int v29 = 2 * v16;
        int v30 = v14;
        do
        {
          unint64_t v31 = 0;
          unsigned int v32 = v14 + v6 * v28;
          unsigned int v33 = v18 * v28;
          BOOL v34 = __CFADD__(v32, v29);
          BOOL v35 = __CFADD__(v33, v29);
          if (!v34 && !v35 && (unint64_t)&a2[4 * v32 - v20 + -4 * v33] >= 0x20)
          {
            unsigned int v36 = v27;
            int v37 = v30;
            uint64_t v38 = v15 & 0xFFFFFFF8;
            do
            {
              long long v39 = (long long *)(v20 + 4 * v36);
              long long v40 = *v39;
              long long v41 = v39[1];
              long long v42 = &a2[4 * v37];
              *(_OWORD *)long long v42 = v40;
              *((_OWORD *)v42 + 1) = v41;
              v37 += 8;
              v36 += 8;
              v38 -= 8;
            }
            while (v38);
            unint64_t v31 = (2 * v16) & 0xFFFFFFF8;
          }
          do
          {
            *(_DWORD *)&a2[4 * (v30 + v31)] = *(_DWORD *)(v20 + 4 * (v27 + v31));
            ++v31;
          }
          while (v31 < ((2 * v16) | 1u));
          ++v28;
          v30 += v6;
          v27 += v15 + 1;
        }
        while (v28 != v19);
      }
      else
      {
        unsigned int v21 = 0;
        int v22 = 0;
        int v23 = v14;
        do
        {
          unsigned int v24 = v21;
          int v25 = v23;
          uint64_t v26 = v15 + 1;
          do
          {
            *(_DWORD *)&a2[4 * v25++] = *(_DWORD *)(v20 + 4 * v24++);
            --v26;
          }
          while (v26);
          ++v22;
          v23 += v6;
          v21 += v18;
        }
        while (v22 != v19);
      }
      ++v16;
      v18 += 2;
      v14 += v17;
      v15 += 2;
      v17 += (2 * v6 + 2);
    }
    while (v16 != v13);
  }
  else
  {
    int v44 = 0;
    unsigned int v45 = 0;
    unint64_t v46 = 0;
    int v47 = v6 + 1;
    unsigned int v48 = 1;
    do
    {
      if (v48 <= 1) {
        int v49 = 1;
      }
      else {
        int v49 = v48;
      }
      if (v12 >= v46) {
        uint64_t v50 = *(void *)(v10 + 16 * v46);
      }
      else {
        uint64_t v50 = 0;
      }
      unsigned int v51 = 0;
      int v52 = v44;
      do
      {
        unsigned int v53 = v51;
        int v54 = v52;
        uint64_t v55 = v45 + 1;
        do
        {
          *(_DWORD *)&a2[4 * v54++] = *(_DWORD *)(v50 + 4 * v53);
          v53 += v48;
          --v55;
        }
        while (v55);
        ++v51;
        v52 += v6;
      }
      while (v51 != v49);
      ++v46;
      v48 += 2;
      v45 += 2;
      v44 += v47;
      v47 += 2 * v6 + 2;
    }
    while (v46 != v13);
  }
  return 0;
}

float HOA::legendre(HOA *this, int a2, float result)
{
  if (a2 >= (int)this) {
    int v3 = (int)this;
  }
  else {
    int v3 = a2;
  }
  float v4 = 1.0;
  switch((int)this)
  {
    case 0:
      goto LABEL_30;
    case 1:
      if (v3) {
        return -sqrtf(-(float)((float)(result * result) + -1.0));
      }
      return result;
    case 2:
      if (v3 == 2) {
        return 3.0 - (float)((float)(result * result) * 3.0);
      }
      if (v3 == 1)
      {
        float v11 = result * -3.0;
        float v12 = -(float)((float)(result * result) + -1.0);
        goto LABEL_40;
      }
      float v4 = 0.0;
      if (v3) {
LABEL_30:
      }
        uint64_t result = v4;
      else {
        uint64_t result = (float)((float)(result * result) * 1.5) + -0.5;
      }
      break;
    case 3:
      if (v3 == 2)
      {
        uint64_t result = (float)(result * 15.0) - (float)((float)(result * result) * (float)(result * 15.0));
      }
      else if (v3 == 1)
      {
        float v13 = result * result;
        float v11 = (float)(v13 * -7.5) + 1.5;
LABEL_39:
        float v12 = 1.0 - v13;
LABEL_40:
        uint64_t result = v11 * sqrtf(v12);
      }
      else if (v3)
      {
        float v14 = 1.0 - (float)(result * result);
        float v15 = sqrtf(v14);
        float v16 = -15.0;
LABEL_86:
        uint64_t result = (float)(v14 * v16) * v15;
      }
      else
      {
        uint64_t result = (float)((float)(result * -3.0) + (float)((float)(result * (float)(result * result)) * 5.0)) * 0.5;
      }
      break;
    case 4:
      switch(v3)
      {
        case 0:
          uint64_t result = (float)((float)((float)((float)(result * result) * -30.0)
                                 + (float)((float)((float)(result * result) * (float)(result * result)) * 35.0))
                         * 0.125)
                 + 0.375;
          break;
        case 1:
          float v19 = result * 2.5;
          float v13 = result * result;
          float v11 = v19 * (float)((float)(v13 * -7.0) + 3.0);
          goto LABEL_39;
        case 2:
          uint64_t result = (float)((float)((float)(result * result) * 52.5) + -7.5)
                 - (float)((float)(result * result) * (float)((float)((float)(result * result) * 52.5) + -7.5));
          break;
        case 3:
          float v20 = 1.0 - (float)(result * result);
          float v21 = sqrtf(v20);
          float v22 = -105.0;
          goto LABEL_104;
        default:
          float v17 = (float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result));
          float v18 = 105.0;
          goto LABEL_64;
      }
      return result;
    case 5:
      switch(v3)
      {
        case 0:
          float v5 = result * 0.125;
          float v6 = result * result;
          float v7 = (float)((float)(v6 * v6) * 63.0) + 15.0;
          float v8 = -70.0;
          goto LABEL_66;
        case 1:
          float v25 = result * result;
          float v26 = sqrtf(1.0 - v25);
          float v27 = -1.875;
          float v28 = (float)((float)(v25 * -14.0) + 1.0) + (float)((float)(v25 * v25) * 21.0);
          goto LABEL_100;
        case 2:
          float v29 = result * 52.5;
          float v30 = result * result;
          float v31 = v29 - (float)(v30 * v29);
          float v32 = -3.0;
          goto LABEL_102;
        case 3:
          float v33 = result * result;
          float v34 = 1.0 - v33;
          float v35 = sqrtf(1.0 - v33);
          float v36 = v33 * -9.0;
          float v37 = -52.5;
          goto LABEL_60;
        case 4:
          uint64_t result = (float)((float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result)))
                 * (float)(result * 945.0);
          break;
        default:
          float v23 = 1.0 - (float)(result * result);
          float v15 = sqrtf(v23);
          float v14 = v23 * v23;
          *(float *)&int v24 = -945.0;
          goto LABEL_85;
      }
      return result;
    case 6:
      switch(v3)
      {
        case 0:
          uint64_t result = (float)((float)((float)((float)((float)((float)(result * result) * (float)(result * result)) * -315.0)
                                         + (float)((float)((float)(result * result)
                                                         * (float)((float)(result * result) * (float)(result * result)))
                                                 * 231.0))
                                 + (float)((float)(result * result) * 105.0))
                         * 0.0625)
                 + -0.3125;
          break;
        case 1:
          float v38 = result * -2.625;
          float v39 = result * result;
          float v40 = (float)((float)(v39 * -30.0) + 5.0) + (float)((float)(v39 * v39) * 33.0);
          float v41 = sqrtf(1.0 - v39);
          goto LABEL_92;
        case 2:
          float v42 = result * result;
          float v43 = 13.125 - (float)(v42 * 13.125);
          float v44 = v42 * v42;
          float v45 = (float)(v42 * -18.0) + 1.0;
          float v46 = 33.0;
          goto LABEL_68;
        case 3:
          uint64_t result = (float)((float)((float)(1.0 - (float)(result * result)) * result)
                         * (float)((float)((float)(result * result) * -1732.5) + 472.5))
                 * sqrtf(1.0 - (float)(result * result));
          break;
        case 4:
          float v47 = result * result;
          float v48 = 1.0 - v47;
          float v36 = v47 * -11.0;
          float v49 = v48 * v48;
          float v35 = 472.5;
          goto LABEL_61;
        case 5:
          float v50 = 1.0 - (float)(result * result);
          float v51 = sqrtf(v50);
          float v52 = result * -10395.0;
          float v53 = v50 * v50;
          goto LABEL_96;
        default:
          float v14 = 1.0 - (float)(result * result);
          float v15 = v14 * v14;
          *(float *)&int v24 = 10395.0;
          goto LABEL_85;
      }
      return result;
    case 7:
      switch(v3)
      {
        case 0:
          uint64_t result = ((float)((float)(result * result) * (float)(result * result)) * -693.0
                  + -35.0
                  + (float)((float)((float)(result * result) * 429.0)
                          * (float)((float)(result * result) * (float)(result * result)))
                  + (float)((float)(result * result) * 315.0))
                 * (float)(result * 0.0625);
          break;
        case 1:
          float v6 = result * result;
          float v5 = sqrtf(1.0 - v6) * -0.4375;
          float v7 = (float)((float)((float)(v6 * v6) * -495.0) + -5.0) + (float)((float)(v6 * (float)(v6 * v6)) * 429.0);
          float v8 = 135.0;
          goto LABEL_66;
        case 2:
          float v58 = result * 7.875;
          float v59 = result * result;
          float v60 = v58 - (float)(v59 * v58);
          float v61 = v59 * v59;
          float v62 = (float)(v59 * -110.0) + 15.0;
          float v63 = 143.0;
          goto LABEL_98;
        case 3:
          float v64 = result * result;
          float v65 = 1.0 - v64;
          float v51 = sqrtf(1.0 - v64);
          float v52 = (float)((float)(v64 * -66.0) + 3.0) + (float)((float)(v64 * v64) * 143.0);
          float v66 = -39.375;
          goto LABEL_95;
        case 4:
          uint64_t result = (float)((float)((float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result)))
                         * (float)(result * 1732.5))
                 * (float)((float)((float)(result * result) * 13.0) + -3.0);
          break;
        case 5:
          float v67 = result * result;
          float v68 = 1.0 - v67;
          float v35 = sqrtf(1.0 - v67);
          float v36 = v67 * -13.0;
          float v34 = v68 * v68;
          float v37 = -5197.5;
LABEL_60:
          float v49 = v34 * v37;
LABEL_61:
          uint64_t result = -(float)((float)(v49 * v35) + (float)(v36 * (float)(v49 * v35)));
          break;
        case 6:
          uint64_t result = (float)(result * 135140.0)
                 * (float)((float)(1.0 - (float)(result * result))
                         * (float)((float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result))));
          break;
        default:
          float v54 = 1.0 - (float)(result * result);
          float v55 = sqrtf(v54);
          float v56 = v54 * (float)(v54 * v54);
          float v57 = -135140.0;
          goto LABEL_75;
      }
      return result;
    case 8:
      switch(v3)
      {
        case 0:
          float v9 = result * result;
          uint64_t result = (float)((float)((float)((float)((float)((float)(v9 * v9) * 6930.0)
                                                 + (float)((float)((float)(v9 * v9) * (float)(v9 * v9)) * 6435.0))
                                         + (float)((float)(v9 * (float)(v9 * v9)) * -12012.0))
                                 + (float)(v9 * -1260.0))
                         * 0.0078125)
                 + 0.27344;
          break;
        case 1:
          float v70 = result * -0.5625;
          float v6 = result * result;
          float v5 = v70 * sqrtf(1.0 - v6);
          float v7 = (float)((float)((float)(v6 * v6) * -1001.0) + -35.0) + (float)((float)(v6 * (float)(v6 * v6)) * 715.0);
          float v8 = 385.0;
LABEL_66:
          uint64_t result = v5 * (float)(v7 + (float)(v6 * v8));
          break;
        case 2:
          float v71 = result * result;
          float v43 = 19.688 - (float)(v71 * 19.688);
          float v44 = -(float)((float)(v71 * v71) - (float)(v71 * (float)(v71 * v71)));
          float v45 = (float)(v71 * 33.0) + -1.0;
          float v46 = 143.0;
LABEL_68:
          uint64_t result = (float)(v45 + (float)(v44 * v46)) * v43;
          break;
        case 3:
          uint64_t result = (float)((float)((float)(result * -433.12) * (float)(1.0 - (float)(result * result)))
                         * (float)((float)((float)((float)(result * result) * -26.0) + 3.0)
                                 + (float)((float)((float)(result * result) * (float)(result * result)) * 39.0)))
                 * sqrtf(1.0 - (float)(result * result));
          break;
        case 4:
          float v72 = result * result;
          float v73 = 1.0 - v72;
          float v41 = (float)((float)(v72 * -26.0) + 1.0) + (float)((float)(v72 * v72) * 65.0);
          float v38 = v73 * v73;
          *(float *)&int v74 = 1299.4;
          goto LABEL_91;
        case 5:
          float v75 = 1.0 - (float)(result * result);
          float v76 = sqrtf(v75);
          uint64_t result = -(float)((float)((float)((float)(v75 * v75) * (float)(result * -67568.0)) * v76)
                          + (float)((float)((float)(result * result) * -5.0)
                                  * (float)((float)((float)(v75 * v75) * (float)(result * -67568.0)) * v76)));
          break;
        case 6:
          float v30 = result * result;
          float v31 = (float)((float)(1.0 - v30) * 67568.0) * (float)((float)(1.0 - v30) * (float)(1.0 - v30));
          float v32 = -15.0;
          goto LABEL_102;
        case 7:
          float v77 = 1.0 - (float)(result * result);
          float v21 = sqrtf(v77);
          float v20 = v77 * (float)(v77 * v77);
          float v22 = -2027000.0;
          goto LABEL_104;
        default:
          float v69 = (float)(1.0 - (float)(result * result)) * (float)(1.0 - (float)(result * result));
          float v17 = v69 * v69;
          float v18 = 2027000.0;
LABEL_64:
          uint64_t result = v17 * v18;
          break;
      }
      return result;
    case 9:
      switch(v3)
      {
        case 0:
          uint64_t result = (float)((float)((float)((float)((float)(result * 315.0)
                                                 + (float)((float)(result
                                                                 * (float)((float)(result * result)
                                                                         * (float)(result * result)))
                                                         * 18018.0))
                                         + (float)((float)(result
                                                         * (float)((float)((float)(result * result)
                                                                         * (float)(result * result))
                                                                 * (float)((float)(result * result)
                                                                         * (float)(result * result))))
                                                 * 12155.0))
                                 + (float)((float)(result * (float)(result * result)) * -4620.0))
                         + (float)((float)((float)(result * (float)(result * result))
                                         * (float)((float)(result * result) * (float)(result * result)))
                                 * -25740.0))
                 * 0.0078125;
          break;
        case 1:
          float v79 = result * result;
          uint64_t result = (float)(sqrtf(1.0 - v79) * -0.35156)
                 * (float)((float)((float)((float)((float)((float)(v79 * v79) * 2002.0) + 7.0)
                                         + (float)((float)((float)(v79 * v79) * (float)(v79 * v79)) * 2431.0))
                                 + (float)(v79 * -308.0))
                         + (float)((float)(v79 * (float)(v79 * v79)) * -4004.0));
          break;
        case 2:
          uint64_t result = (float)((float)((float)((float)(result * -7.0)
                                         + (float)((float)(result * (float)(result * result)) * 91.0))
                                 + (float)((float)((float)(result * (float)(result * result))
                                                 * (float)((float)(result * result) * (float)(result * result)))
                                         * 221.0))
                         + (float)((float)(result * (float)((float)(result * result) * (float)(result * result)))
                                 * -273.0))
                 * (float)(30.938 - (float)((float)(result * result) * 30.938));
          break;
        case 3:
          float v80 = result * result;
          float v20 = sqrtf(1.0 - v80);
          float v21 = (float)((float)((float)((float)(v80 * v80) * -195.0) + -1.0)
                      + (float)((float)(v80 * (float)(v80 * v80)) * 221.0))
              + (float)(v80 * 39.0);
          float v81 = (float)(v80 * 216.56) + -216.56;
          goto LABEL_105;
        case 4:
          float v82 = (float)(result * result) + -1.0;
          float v41 = (float)(result + (float)((float)(result * (float)(result * result)) * -10.0))
              + (float)((float)(result * (float)((float)(result * result) * (float)(result * result))) * 17.0);
          float v38 = v82 * v82;
          *(float *)&int v74 = 16892.0;
          goto LABEL_91;
        case 5:
          float v83 = result * result;
          float v51 = sqrtf(1.0 - v83);
          float v84 = v83 + -1.0;
          float v85 = v83 * v83;
          float v86 = (float)(v83 * -30.0) + 1.0;
          float v87 = 85.0;
          goto LABEL_94;
        case 6:
          uint64_t result = (float)((float)((float)((float)(result * result) + -1.0) * -337840.0)
                         * (float)((float)((float)(result * result) + -1.0) * (float)((float)(result * result) + -1.0)))
                 * (float)((float)(result * -3.0) + (float)((float)(result * (float)(result * result)) * 17.0));
          break;
        case 7:
          float v30 = result * result;
          float v31 = sqrtf(1.0 - v30)
              * (float)(1013500.0 * (float)((float)(v30 + -1.0) * (float)((float)(v30 + -1.0) * (float)(v30 + -1.0))));
          float v32 = -17.0;
          goto LABEL_102;
        case 8:
          float v88 = result * 34459000.0;
          float v89 = (float)((float)(result * result) + -1.0) * (float)((float)(result * result) + -1.0);
          uint64_t result = v88 * (float)(v89 * v89);
          break;
        default:
          float v78 = 1.0 - (float)(result * result);
          float v55 = sqrtf(v78);
          float v56 = (float)(v78 * v78) * (float)(v78 * v78);
          float v57 = -34459000.0;
LABEL_75:
          uint64_t result = v55 * (float)(v57 * v56);
          break;
      }
      return result;
    case 10:
      switch(v3)
      {
        case 0:
          float v10 = result * result;
          return (float)((float)((float)((float)((float)((float)((float)(v10 * 90090.0) * (float)(v10 * v10))
                                                       + (float)((float)(v10
                                                                       * (float)((float)(v10 * v10) * (float)(v10 * v10)))
                                                               * 46189.0))
                                               + (float)((float)(v10 * v10) * -30030.0))
                                       + (float)((float)((float)(v10 * v10) * (float)(v10 * v10)) * -109400.0))
                               + (float)(v10 * 3465.0))
                       * 0.0039062)
               + -0.24609;
        case 1:
          return (float)(sqrtf(1.0 - (float)(result * result)) * -0.42969)
               * (float)((float)((float)((float)((float)(result * 63.0)
                                               + (float)((float)(result
                                                               * (float)((float)(result * result)
                                                                       * (float)(result * result)))
                                                       * 4914.0))
                                       + (float)((float)(result
                                                       * (float)((float)((float)(result * result)
                                                                       * (float)(result * result))
                                                               * (float)((float)(result * result)
                                                                       * (float)(result * result))))
                                               * 4199.0))
                               + (float)((float)(result * (float)(result * result)) * -1092.0))
                       + (float)((float)((float)(result * (float)(result * result))
                                       * (float)((float)(result * result) * (float)(result * result)))
                               * -7956.0));
        case 2:
          float v90 = result * result;
          return (float)((float)((float)((float)((float)((float)(v90 * v90) * 2730.0) + 7.0)
                                       + (float)((float)((float)(v90 * v90) * (float)(v90 * v90)) * 4199.0))
                               + (float)(v90 * -364.0))
                       + (float)((float)(v90 * (float)(v90 * v90)) * -6188.0))
               * (float)(3.8672 - (float)(v90 * 3.8672));
        case 3:
          float v91 = result * result;
          float v40 = sqrtf(1.0 - (float)(result * result));
          float v41 = (float)((float)((float)(result * -7.0) + (float)((float)(result * (float)(result * result)) * 105.0))
                      + (float)((float)((float)(result * (float)(result * result)) * (float)(v91 * v91)) * 323.0))
              + (float)((float)(result * (float)(v91 * v91)) * -357.0);
          float v38 = (float)(v91 * 402.19) + -402.19;
          goto LABEL_92;
        case 4:
          float v92 = result * result;
          float v93 = v92 + -1.0;
          float v41 = (float)((float)((float)((float)(v92 * v92) * -255.0) + -1.0)
                      + (float)((float)(v92 * (float)(v92 * v92)) * 323.0))
              + (float)(v92 * 45.0);
          float v38 = v93 * v93;
          *(float *)&int v74 = 2815.3;
LABEL_91:
          float v40 = *(float *)&v74;
LABEL_92:
          uint64_t result = (float)(v38 * v40) * v41;
          break;
        case 5:
          float v51 = sqrtf(1.0 - (float)(result * result));
          float v84 = (float)(result * result) + -1.0;
          float v85 = result * (float)((float)(result * result) * (float)(result * result));
          float v86 = (float)(result * 15.0) + (float)((float)(result * (float)(result * result)) * -170.0);
          float v87 = 323.0;
LABEL_94:
          float v52 = v86 + (float)(v85 * v87);
          float v65 = v84 * v84;
          float v66 = -16892.0;
LABEL_95:
          float v53 = v65 * v66;
LABEL_96:
          uint64_t result = (float)(v53 * v52) * v51;
          break;
        case 6:
          float v94 = result * result;
          float v60 = (float)((float)(v94 + -1.0) * -84459.0) * (float)((float)(v94 + -1.0) * (float)(v94 + -1.0));
          float v61 = v94 * v94;
          float v62 = (float)(v94 * -102.0) + 3.0;
          float v63 = 323.0;
LABEL_98:
          uint64_t result = v60 * (float)(v62 + (float)(v61 * v63));
          break;
        case 7:
          float v26 = sqrtf(1.0 - (float)(result * result));
          float v27 = 5743200.0
              * (float)((float)((float)(result * result) + -1.0)
                      * (float)((float)((float)(result * result) + -1.0) * (float)((float)(result * result) + -1.0)));
          float v28 = (float)(result * -3.0) + (float)((float)(result * (float)(result * result)) * 19.0);
LABEL_100:
          uint64_t result = v26 * (float)(v27 * v28);
          break;
        case 8:
          float v30 = result * result;
          float v31 = (float)((float)((float)(v30 + -1.0) * (float)(v30 + -1.0))
                      * (float)((float)(v30 + -1.0) * (float)(v30 + -1.0)))
              * 17230000.0;
          float v32 = -19.0;
LABEL_102:
          uint64_t result = -(float)(v31 + (float)((float)(v30 * v32) * v31));
          break;
        case 9:
          float v95 = 1.0 - (float)(result * result);
          float v21 = sqrtf(v95);
          float v20 = (float)(v95 * v95) * (float)(v95 * v95);
          float v22 = -654730000.0;
LABEL_104:
          float v81 = result * v22;
LABEL_105:
          uint64_t result = (float)(v81 * v20) * v21;
          break;
        default:
          float v14 = (float)(result * result) + -1.0;
          float v15 = (float)(v14 * v14) * (float)(v14 * v14);
          *(float *)&int v24 = -654730000.0;
LABEL_85:
          float v16 = *(float *)&v24;
          goto LABEL_86;
      }
      return result;
    default:
      float v4 = 0.0;
      goto LABEL_30;
  }
  return result;
}

void boost::math::detail::gamma_imp<double,boost::math::policies::policy<boost::math::policies::promote_float<false>,boost::math::policies::promote_double<false>,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy>,boost::math::lanczos::lanczos13m53>(double a1)
{
  _D6 = a1;
  double v2 = 1.0;
  if (_D6 <= 0.0)
  {
    if (floor(_D6) == _D6) {
      boost::math::policies::detail::raise_error<std::domain_error,double>();
    }
    if (_D6 <= -20.0)
    {
      double v7 = -_D6;
      double v31 = _D6;
      double v8 = boost::math::detail::gamma_imp<double,boost::math::policies::policy<boost::math::policies::promote_float<false>,boost::math::policies::promote_double<false>,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy>,boost::math::lanczos::lanczos13m53>(-_D6);
      double v9 = v31;
      if (v31 < 0.0) {
        double v9 = v7;
      }
      double v10 = floor(v9);
      double v11 = 1.0 - v9 + v10;
      double v12 = v9 - v10;
      if (vcvtmd_s64_f64(v9))
      {
        double v12 = v11;
        double v13 = -v9;
      }
      else
      {
        double v13 = v9;
      }
      if (v12 <= 0.5) {
        double v14 = v12;
      }
      else {
        double v14 = 1.0 - v12;
      }
      double v15 = fabs(v13 * v8 * sin(v14 * 3.14159265));
      if (v15 >= 1.0 || v15 * 1.79769313e308 >= 3.14159265) {
        return;
      }
LABEL_42:
      boost::math::policies::detail::raise_error<std::overflow_error,double>("Result of tgamma is too large to represent.");
    }
    for (; _D6 < 0.0; _D6 = _D6 + 1.0)
      double v2 = v2 / _D6;
  }
  double v3 = floor(_D6);
  if (v3 == _D6 && _D6 < 170.0)
  {
    if ((~*(void *)&_D6 & 0x7FF0000000000000) == 0) {
      boost::math::policies::detail::raise_error<boost::math::rounding_error,double>("boost::math::trunc<%1%>(%1%)");
    }
    double v5 = ceil(_D6);
    if (_D6 < 0.0) {
      double v3 = v5;
    }
    if (v3 > 2147483650.0 || v3 < -2147483650.0) {
      boost::math::policies::detail::raise_error<boost::math::rounding_error,double>("boost::math::itrunc<%1%>(%1%)");
    }
    return;
  }
  if (_D6 < 0.0000000149011612)
  {
    if (_D6 < COERCE_DOUBLE(0x4000000000000)) {
      boost::math::policies::detail::raise_error<std::overflow_error,double>("Overflow Error");
    }
    return;
  }
  v16.f64[0] = _D6 * _D6;
  if (_D6 <= 1.0)
  {
    float64x2_t v24 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v16.f64[0], 0);
    float64x2_t v25 = (float64x2_t)vdupq_lane_s64(0x4050800000000000, 0);
    v25.f64[0] = v16.f64[0] + 1925.0;
    _Q2 = vmlaq_n_f64((float64x2_t)xmmword_21B5514A0, vmlaq_n_f64((float64x2_t)xmmword_21B551490, vmlaq_n_f64((float64x2_t)xmmword_21B551480, vmlaq_n_f64((float64x2_t)xmmword_21B551470, vmlaq_n_f64((float64x2_t)xmmword_21B551460, v25, v16.f64[0]), v16.f64[0]), v16.f64[0]), v16.f64[0]), v16.f64[0]);
    v24.f64[0] = _D6;
    __asm { FMLA            D2, D6, V2.D[1] }
    double v23 = (vaddvq_f64(vmulq_f64(vmlaq_n_f64((float64x2_t)xmmword_21B551500, vmlaq_n_f64((float64x2_t)xmmword_21B5514F0, vmlaq_n_f64((float64x2_t)xmmword_21B5514E0, vmlaq_n_f64((float64x2_t)xmmword_21B5514D0, vmlaq_n_f64((float64x2_t)xmmword_21B5514C0, (float64x2_t)xmmword_21B5514B0, v16.f64[0]), v16.f64[0]), v16.f64[0]), v16.f64[0]), v16.f64[0]), v24))+ 2.35313769e10)/ _Q2.f64[0];
  }
  else
  {
    v16.f64[1] = _D6;
    __asm { FMOV            V2.2D, #1.0 }
    float64x2_t v21 = vdivq_f64(_Q2, v16);
    float64x2_t v22 = vmlaq_n_f64((float64x2_t)xmmword_21B5515C0, vmlaq_n_f64((float64x2_t)xmmword_21B5515B0, vmlaq_n_f64((float64x2_t)xmmword_21B5515A0, vmlaq_n_f64((float64x2_t)xmmword_21B551590, vmlaq_n_f64((float64x2_t)xmmword_21B551580, (float64x2_t)xmmword_21B551570, v21.f64[0]), v21.f64[0]), v21.f64[0]), v21.f64[0]), v21.f64[0]);
    double v23 = (vaddvq_f64(vmulq_f64(vmlaq_n_f64((float64x2_t)xmmword_21B551560, vmlaq_n_f64((float64x2_t)xmmword_21B551550, vmlaq_n_f64((float64x2_t)xmmword_21B551540, vmlaq_n_f64((float64x2_t)xmmword_21B551530, vmlaq_n_f64((float64x2_t)xmmword_21B551520, (float64x2_t)xmmword_21B551510, v21.f64[0]), v21.f64[0]), v21.f64[0]), v21.f64[0]), v21.f64[0]), v21))+ 2.50662827)/ vmlaq_laneq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v22, 1), v22, v21, 1).f64[0];
  }
  double v27 = v23 * v2;
  double v28 = _D6 + 5.52468004;
  double v32 = _D6;
  double v29 = log(_D6 + 5.52468004);
  if (v29 * v32 <= 709.0)
  {
    pow(v28, v32 + -0.5);
    exp(-v28);
    return;
  }
  if (v29 * v32 * 0.5 > 709.0) {
    goto LABEL_42;
  }
  double v30 = pow(v28, v32 * 0.5 + -0.25);
  if (1.79769313e308 / v30 < exp(-v28) * v30 * v27) {
    goto LABEL_42;
  }
}

void boost::math::policies::detail::raise_error<std::overflow_error,float>()
{
  uint64_t v0 = (std::string *)operator new(0x20uLL);
  std::string::size_type v1 = 0;
  *(_OWORD *)&v14.__r_.__value_.__r.__words[1] = xmmword_21B5515D0;
  strcpy((char *)v0, "boost::math::tgamma<%1%>(%1%)");
  v13.__r_.__value_.__r.__words[2] = 0x120000000000206ELL;
  v14.__r_.__value_.__r.__words[0] = (std::string::size_type)v0;
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = *(_OWORD *)"Error in function ";
  uint64_t v2 = 128;
  std::string::size_type size = 29;
  while (1)
  {
    float v4 = (v2 & 0x80u) == 0 ? &v14 : v0;
    std::string::size_type v5 = (v2 & 0x80u) == 0 ? v2 : size;
    if (v5 < v1) {
      break;
    }
    float v6 = (char *)v4 + v1;
    double v7 = (char *)v4 + v5;
    while (1)
    {
      uint64_t v8 = v7 - v6;
      if (v7 - v6 < 3) {
        goto LABEL_21;
      }
      if (v8 == 2) {
        goto LABEL_21;
      }
      double v9 = (char *)memchr(v6, 37, v8 - 2);
      if (!v9) {
        goto LABEL_21;
      }
      if (*(_WORD *)v9 == 12581 && v9[2] == 37) {
        break;
      }
      float v6 = v9 + 1;
    }
    if (v9 == v7) {
      break;
    }
    std::string::size_type v11 = v9 - (char *)v4;
    if (v9 - (char *)v4 == -1) {
      break;
    }
    std::string::replace(&v14, v11, 3uLL, "Unknown", 7uLL);
    std::string::size_type v1 = v11 + 7;
    uint64_t v2 = HIBYTE(v14.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v14.__r_.__value_.__l.__size_;
    uint64_t v0 = (std::string *)v14.__r_.__value_.__r.__words[0];
  }
LABEL_21:
  std::string::append(&v13, (const std::string::value_type *)v4, v5);
  std::string::append(&v13, ": ", 2uLL);
  std::string::append(&v13, "numeric overflow", 0x10uLL);
  v12.__vftable = 0;
  v12.__imp_.__imp_ = 0;
  std::runtime_error::runtime_error(&v12, &v13);
  v12.__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C398] + 16);
  boost::throw_exception<std::overflow_error>(&v12);
}

void sub_21B53BA58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0)
  {
    operator delete(a11);
    if ((a22 & 0x80000000) == 0) {
LABEL_6:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a22 & 0x80000000) == 0)
  {
    goto LABEL_6;
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

unsigned char *boost::math::policies::detail::replace_all_in_string(std::string *a1, char *__s)
{
  uint64_t result = (unsigned char *)strlen(__s);
  std::string::size_type v5 = result;
  float v6 = 0;
LABEL_2:
  unint64_t size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) == 0) {
    std::string::size_type v8 = (std::string::size_type)a1;
  }
  else {
    std::string::size_type v8 = a1->__r_.__value_.__r.__words[0];
  }
  if ((size & 0x80u) != 0) {
    unint64_t size = a1->__r_.__value_.__l.__size_;
  }
  if (size >= (unint64_t)v6)
  {
    uint64_t result = &v6[v8];
    double v9 = (unsigned char *)(v8 + size);
    while (1)
    {
      uint64_t v10 = v9 - result;
      if (v9 - result < 3) {
        break;
      }
      if (v10 == 2) {
        break;
      }
      uint64_t result = memchr(result, 37, v10 - 2);
      if (!result) {
        break;
      }
      if (*(_WORD *)result == 12581 && result[2] == 37)
      {
        if (result != v9)
        {
          std::string::size_type v12 = (std::string::size_type)&result[-v8];
          if (v12 != -1)
          {
            size_t v13 = strlen(__s);
            uint64_t result = std::string::replace(a1, v12, 3uLL, __s, v13);
            float v6 = &v5[v12];
            goto LABEL_2;
          }
        }
        return result;
      }
      ++result;
    }
  }
  return result;
}

void boost::throw_exception<std::overflow_error>(const std::runtime_error *a1)
{
  exception = (char *)__cxa_allocate_exception(0x40uLL);
  *(void *)exception = &unk_26CB57200;
  std::runtime_error::runtime_error((std::runtime_error *)(exception + 8), a1);
  *((void *)exception + 4) = 0;
  *((void *)exception + 5) = 0;
  *((void *)exception + 6) = 0;
  *((_DWORD *)exception + 14) = -1;
  *(void *)exception = &unk_26CB57188;
  *((void *)exception + 1) = &unk_26CB571B8;
  *((void *)exception + 3) = &unk_26CB571E0;
}

uint64_t boost::wrapexcept<std::overflow_error>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

void non-virtual thunk to'boost::wrapexcept<std::overflow_error>::~wrapexcept(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = a1->__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    a1->__imp_.__imp_ = 0;
  }
  std::runtime_error::~runtime_error(a1 - 1);

  JUMPOUT(0x21D48F780);
}

{
  const char *imp;
  uint64_t vars8;

  a1->__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = a1->__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    a1->__imp_.__imp_ = 0;
  }

  std::runtime_error::~runtime_error(a1 - 1);
}

void non-virtual thunk to'boost::wrapexcept<std::overflow_error>::~wrapexcept(std::runtime_error *this)
{
  this[1].__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = this[1].__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    this[1].__imp_.__imp_ = 0;
  }
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x21D48F780);
}

{
  const char *imp;
  uint64_t vars8;

  this[1].__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = this[1].__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    this[1].__imp_.__imp_ = 0;
  }

  std::runtime_error::~runtime_error(this);
}

void boost::wrapexcept<std::overflow_error>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));

  JUMPOUT(0x21D48F780);
}

void boost::wrapexcept<std::overflow_error>::rethrow(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<std::overflow_error>::wrapexcept((uint64_t)exception, a1);
}

void sub_21B53C040(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::wrapexcept<std::overflow_error>::wrapexcept(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26CB57200;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  *(void *)(a1 + 8) = MEMORY[0x263F8C398] + 16;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &unk_26CB57258;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v5;
  *(void *)a1 = &unk_26CB57188;
  *(void *)(a1 + 8) = &unk_26CB571B8;
  *(void *)(a1 + 24) = &unk_26CB571E0;
  return a1;
}

void sub_21B53C17C(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<std::overflow_error>::clone()
{
}

void sub_21B53C2DC(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v2);
  MEMORY[0x21D48F780](v1, 0x10F1C40250A9ABCLL);
  _Unwind_Resume(a1);
}

void sub_21B53C308(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::exception_detail::copy_boost_exception(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 40))(&v7);
    uint64_t v5 = v7;
    uint64_t v8 = v7;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 32))(result);
  }
  *(void *)(a1 + 8) = v5;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  return result;
}

void sub_21B53C4A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *a1 = 0;
  }
  return a1;
}

void boost::math::policies::detail::raise_error<std::domain_error,double>()
{
  uint64_t v0 = (char *)operator new(0x20uLL);
  v29.__r_.__value_.__r.__words[0] = (std::string::size_type)v0;
  *(_OWORD *)&v29.__r_.__value_.__r.__words[1] = xmmword_21B5515D0;
  strcpy(v0, "boost::math::tgamma<%1%>(%1%)");
  uint64_t v1 = (char *)operator new(0x30uLL);
  std::string::size_type v2 = 0;
  v28.__r_.__value_.__r.__words[0] = (std::string::size_type)v1;
  *(_OWORD *)&v28.__r_.__value_.__r.__words[1] = xmmword_21B5515E0;
  strcpy(v1, "Evaluation of tgamma at a negative integer %1%.");
  v27.__r_.__value_.__r.__words[2] = 0x120000000000206ELL;
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = *(_OWORD *)"Error in function ";
  uint64_t v3 = 128;
  std::string::size_type size = 29;
  while (1)
  {
    if ((v3 & 0x80u) != 0)
    {
      std::string::size_type v5 = size;
    }
    else
    {
      uint64_t v0 = (char *)&v29;
      std::string::size_type v5 = v3;
    }
    if (v5 < v2) {
      break;
    }
    float v6 = &v0[v2];
    uint64_t v7 = &v0[v5];
    while (1)
    {
      int64_t v8 = v7 - v6;
      if (v7 - v6 < 3) {
        goto LABEL_18;
      }
      if (v8 == 2) {
        goto LABEL_18;
      }
      double v9 = (char *)memchr(v6, 37, v8 - 2);
      if (!v9) {
        goto LABEL_18;
      }
      if (*(_WORD *)v9 == 12581 && v9[2] == 37) {
        break;
      }
      float v6 = v9 + 1;
    }
    if (v9 == v7) {
      break;
    }
    std::string::size_type v11 = v9 - v0;
    if (v9 - v0 == -1) {
      break;
    }
    std::string::replace(&v29, v11, 3uLL, "Unknown", 7uLL);
    std::string::size_type v2 = v11 + 7;
    uint64_t v3 = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v29.__r_.__value_.__l.__size_;
    uint64_t v0 = (char *)v29.__r_.__value_.__r.__words[0];
  }
LABEL_18:
  std::string::append(&v27, v0, v5);
  std::string::append(&v27, ": ", 2uLL);
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  boost::math::policies::detail::prec_format<double>(v25);
  if (v26 >= 0) {
    std::string::size_type v12 = (const char *)v25;
  }
  else {
    std::string::size_type v12 = (const char *)v25[0];
  }
  size_t v13 = strlen(v12);
  for (std::string::size_type i = 0; ; std::string::size_type i = v22 + v13)
  {
    double v15 = (v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v28
        : (std::string *)v28.__r_.__value_.__r.__words[0];
    std::string::size_type v16 = (v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? HIBYTE(v28.__r_.__value_.__r.__words[2])
        : v28.__r_.__value_.__l.__size_;
    if (v16 < i) {
      break;
    }
    float v17 = (char *)v15 + i;
    float v18 = (char *)v15 + v16;
    while (1)
    {
      uint64_t v19 = v18 - v17;
      if (v18 - v17 < 3) {
        goto LABEL_41;
      }
      if (v19 == 2) {
        goto LABEL_41;
      }
      float v20 = (char *)memchr(v17, 37, v19 - 2);
      if (!v20) {
        goto LABEL_41;
      }
      if (*(_WORD *)v20 == 12581 && v20[2] == 37) {
        break;
      }
      float v17 = v20 + 1;
    }
    if (v20 == v18) {
      break;
    }
    std::string::size_type v22 = v20 - (char *)v15;
    if (v20 - (char *)v15 == -1) {
      break;
    }
    size_t v23 = strlen(v12);
    std::string::replace(&v28, v22, 3uLL, v12, v23);
  }
LABEL_41:
  std::string::append(&v27, (const std::string::value_type *)v15, v16);
  v24.__vftable = 0;
  v24.__imp_.__imp_ = 0;
  std::logic_error::logic_error(&v24, &v27);
  v24.__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C380] + 16);
  boost::throw_exception<std::domain_error>(&v24);
}

void sub_21B53C7F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a17 < 0)
  {
    operator delete(__p);
    if (a23 < 0)
    {
LABEL_5:
      operator delete(a18);
      if ((a30 & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
  }
  else if (a23 < 0)
  {
    goto LABEL_5;
  }
  if ((a30 & 0x80000000) == 0)
  {
LABEL_6:
    if (*(char *)(v30 - 65) < 0) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(a25);
  if (*(char *)(v30 - 65) < 0)
  {
LABEL_7:
    operator delete(*(void **)(v30 - 88));
    _Unwind_Resume(a1);
  }
LABEL_10:
  _Unwind_Resume(a1);
}

void boost::math::policies::detail::raise_error<std::overflow_error,double>(const char *a1)
{
  if (a1) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = "Cause unknown";
  }
  std::string::size_type v2 = (std::string *)operator new(0x20uLL);
  std::string::size_type v3 = 0;
  *(_OWORD *)&v17.__r_.__value_.__r.__words[1] = xmmword_21B5515D0;
  strcpy((char *)v2, "boost::math::tgamma<%1%>(%1%)");
  v16.__r_.__value_.__r.__words[2] = 0x120000000000206ELL;
  v17.__r_.__value_.__r.__words[0] = (std::string::size_type)v2;
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = *(_OWORD *)"Error in function ";
  uint64_t v4 = 128;
  std::string::size_type size = 29;
  while (1)
  {
    float v6 = (v4 & 0x80u) == 0 ? &v17 : v2;
    std::string::size_type v7 = (v4 & 0x80u) == 0 ? v4 : size;
    if (v7 < v3) {
      break;
    }
    int64_t v8 = (char *)v6 + v3;
    double v9 = (char *)v6 + v7;
    while (1)
    {
      uint64_t v10 = v9 - v8;
      if (v9 - v8 < 3) {
        goto LABEL_24;
      }
      if (v10 == 2) {
        goto LABEL_24;
      }
      std::string::size_type v11 = (char *)memchr(v8, 37, v10 - 2);
      if (!v11) {
        goto LABEL_24;
      }
      if (*(_WORD *)v11 == 12581 && v11[2] == 37) {
        break;
      }
      int64_t v8 = v11 + 1;
    }
    if (v11 == v9) {
      break;
    }
    std::string::size_type v13 = v11 - (char *)v6;
    if (v11 - (char *)v6 == -1) {
      break;
    }
    std::string::replace(&v17, v13, 3uLL, "Unknown", 7uLL);
    std::string::size_type v3 = v13 + 7;
    uint64_t v4 = HIBYTE(v17.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v17.__r_.__value_.__l.__size_;
    std::string::size_type v2 = (std::string *)v17.__r_.__value_.__r.__words[0];
  }
LABEL_24:
  std::string::append(&v16, (const std::string::value_type *)v6, v7);
  std::string::append(&v16, ": ", 2uLL);
  size_t v14 = strlen(v1);
  std::string::append(&v16, v1, v14);
  v15.__vftable = 0;
  v15.__imp_.__imp_ = 0;
  std::runtime_error::runtime_error(&v15, &v16);
  v15.__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C398] + 16);
  boost::throw_exception<std::overflow_error>(&v15);
}

void sub_21B53CA4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0)
  {
    operator delete(a11);
    if ((a22 & 0x80000000) == 0) {
LABEL_6:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a22 & 0x80000000) == 0)
  {
    goto LABEL_6;
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void boost::math::policies::detail::raise_error<boost::math::rounding_error,double>(const char *a1)
{
  if (a1) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = "Unknown function operating on type %1%";
  }
  memset(&__dst, 0, sizeof(__dst));
  size_t v2 = strlen(v1);
  if (v2 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v3 = v2;
  if (v2 >= 0x17)
  {
    uint64_t v5 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v2 | 7) != 0x17) {
      uint64_t v5 = v2 | 7;
    }
    uint64_t v6 = v5 + 1;
    p_dst = (std::string *)operator new(v5 + 1);
    __dst.__r_.__value_.__l.__size_ = v3;
    __dst.__r_.__value_.__r.__words[2] = v6 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v2;
    p_dst = &__dst;
    if (!v2) {
      goto LABEL_13;
    }
  }
  memcpy(p_dst, v1, v3);
LABEL_13:
  p_dst->__r_.__value_.__s.__data_[v3] = 0;
  std::string::size_type v7 = (char *)operator new(0x40uLL);
  std::string::size_type v8 = 0;
  v24.__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
  *(_OWORD *)&v24.__r_.__value_.__r.__words[1] = xmmword_21B5515F0;
  strcpy(v7, "Value %1% can not be represented in the target integer type.");
  v23.__r_.__value_.__r.__words[2] = 0x120000000000206ELL;
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = *(_OWORD *)"Error in function ";
  while (1)
  {
    double v9 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
       ? &__dst
       : (std::string *)__dst.__r_.__value_.__r.__words[0];
    std::string::size_type v10 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? HIBYTE(__dst.__r_.__value_.__r.__words[2])
        : __dst.__r_.__value_.__l.__size_;
    if (v10 < v8) {
      break;
    }
    std::string::size_type v11 = (char *)v9 + v8;
    std::string::size_type v12 = (char *)v9 + v10;
    while (1)
    {
      uint64_t v13 = v12 - v11;
      if (v12 - v11 < 3) {
        goto LABEL_33;
      }
      if (v13 == 2) {
        goto LABEL_33;
      }
      size_t v14 = (char *)memchr(v11, 37, v13 - 2);
      if (!v14) {
        goto LABEL_33;
      }
      if (*(_WORD *)v14 == 12581 && v14[2] == 37) {
        break;
      }
      std::string::size_type v11 = v14 + 1;
    }
    if (v14 == v12) {
      break;
    }
    std::string::size_type v16 = v14 - (char *)v9;
    if (v14 - (char *)v9 == -1) {
      break;
    }
    std::string::replace(&__dst, v16, 3uLL, "Unknown", 7uLL);
    std::string::size_type v8 = v16 + 7;
  }
LABEL_33:
  std::string::append(&v23, (const std::string::value_type *)v9, v10);
  std::string::append(&v23, ": ", 2uLL);
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  boost::math::policies::detail::prec_format<double>(v21);
  if (v22 >= 0) {
    std::string v17 = (char *)v21;
  }
  else {
    std::string v17 = (char *)v21[0];
  }
  boost::math::policies::detail::replace_all_in_string(&v24, v17);
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float v18 = &v24;
  }
  else {
    float v18 = (std::string *)v24.__r_.__value_.__r.__words[0];
  }
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v24.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v24.__r_.__value_.__l.__size_;
  }
  std::string::append(&v23, (const std::string::value_type *)v18, size);
  v20.__vftable = 0;
  v20.__imp_.__imp_ = 0;
  std::runtime_error::runtime_error(&v20, &v23);
  v20.__vftable = (std::runtime_error_vtbl *)&unk_26CB57230;
  boost::throw_exception<boost::math::rounding_error>(&v20);
}

void sub_21B53CD1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::runtime_error a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a22 < 0)
  {
    operator delete(__p);
    if (a29 < 0) {
      goto LABEL_7;
    }
  }
  else if (a29 < 0)
  {
LABEL_7:
    operator delete(a24);
    if ((*(char *)(v29 - 65) & 0x80000000) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
LABEL_4:
    operator delete(*(void **)(v29 - 88));
    _Unwind_Resume(a1);
  }
  if ((*(char *)(v29 - 65) & 0x80000000) == 0) {
    goto LABEL_8;
  }
  goto LABEL_4;
}

uint64_t boost::math::policies::detail::prec_format<double>(unsigned char *a1)
{
  uint64_t v20 = 0;
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  *(_OWORD *)std::vector<char> __p = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v11);
  *(void *)((char *)&v12 + *(void *)(v12 - 24) + 16) = 17;
  std::ostream::operator<<();
  if ((BYTE8(v18) & 0x10) != 0)
  {
    uint64_t v3 = v18;
    if ((unint64_t)v18 < *((void *)&v15 + 1))
    {
      *(void *)&long long v18 = *((void *)&v15 + 1);
      uint64_t v3 = *((void *)&v15 + 1);
    }
    uint64_t v4 = (const void **)&v15;
  }
  else
  {
    if ((BYTE8(v18) & 8) == 0)
    {
      size_t v2 = 0;
      a1[23] = 0;
      goto LABEL_16;
    }
    uint64_t v4 = (const void **)&v13 + 1;
    uint64_t v3 = *((void *)&v14 + 1);
  }
  uint64_t v5 = *v4;
  size_t v2 = v3 - (void)*v4;
  if (v2 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v2 >= 0x17)
  {
    uint64_t v6 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v2 | 7) != 0x17) {
      uint64_t v6 = v2 | 7;
    }
    uint64_t v7 = v6 + 1;
    std::string::size_type v8 = operator new(v6 + 1);
    *((void *)a1 + 1) = v2;
    *((void *)a1 + 2) = v7 | 0x8000000000000000;
    *(void *)a1 = v8;
    a1 = v8;
    goto LABEL_15;
  }
  a1[23] = v2;
  if (v2) {
LABEL_15:
  }
    memmove(a1, v5, v2);
LABEL_16:
  a1[v2] = 0;
  *(void *)&long long v11 = *MEMORY[0x263F8C2B8];
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)&v11 + *(void *)(v11 - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  *(void *)&long long v12 = v9;
  *((void *)&v12 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x21D48F700](v19);
}

void sub_21B53D034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void boost::throw_exception<boost::math::rounding_error>(const std::runtime_error *a1)
{
  exception = (char *)__cxa_allocate_exception(0x40uLL);
  *(void *)exception = &unk_26CB57200;
  std::runtime_error::runtime_error((std::runtime_error *)(exception + 8), a1);
  *((void *)exception + 4) = 0;
  *((void *)exception + 5) = 0;
  *((void *)exception + 6) = 0;
  *((_DWORD *)exception + 14) = -1;
  *(void *)exception = &unk_26CB57098;
  *((void *)exception + 1) = &unk_26CB570C8;
  *((void *)exception + 3) = &unk_26CB570F0;
}

uint64_t boost::wrapexcept<boost::math::rounding_error>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

void non-virtual thunk to'boost::wrapexcept<boost::math::rounding_error>::~wrapexcept(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = a1->__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    a1->__imp_.__imp_ = 0;
  }
  std::runtime_error::~runtime_error(a1 - 1);

  JUMPOUT(0x21D48F780);
}

{
  const char *imp;
  uint64_t vars8;

  a1->__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = a1->__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    a1->__imp_.__imp_ = 0;
  }

  std::runtime_error::~runtime_error(a1 - 1);
}

void non-virtual thunk to'boost::wrapexcept<boost::math::rounding_error>::~wrapexcept(std::runtime_error *this)
{
  this[1].__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = this[1].__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    this[1].__imp_.__imp_ = 0;
  }
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x21D48F780);
}

{
  const char *imp;
  uint64_t vars8;

  this[1].__vftable = (std::runtime_error_vtbl *)&unk_26CB57258;
  imp = this[1].__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    this[1].__imp_.__imp_ = 0;
  }

  std::runtime_error::~runtime_error(this);
}

void boost::wrapexcept<boost::math::rounding_error>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));

  JUMPOUT(0x21D48F780);
}

void boost::wrapexcept<boost::math::rounding_error>::rethrow(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<boost::math::rounding_error>::wrapexcept((uint64_t)exception, a1);
}

void sub_21B53D4E4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::wrapexcept<boost::math::rounding_error>::wrapexcept(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26CB57200;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  *(void *)(a1 + 8) = &unk_26CB57230;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &unk_26CB57258;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v5;
  *(void *)a1 = &unk_26CB57098;
  *(void *)(a1 + 8) = &unk_26CB570C8;
  *(void *)(a1 + 24) = &unk_26CB570F0;
  return a1;
}

void sub_21B53D620(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::math::rounding_error>::clone()
{
}

void sub_21B53D780(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v2);
  MEMORY[0x21D48F780](v1, 0x10F1C40250A9ABCLL);
  _Unwind_Resume(a1);
}

void sub_21B53D7AC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void boost::math::rounding_error::~rounding_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x21D48F780);
}

void boost::throw_exception<std::domain_error>(const std::logic_error *a1)
{
  exception = (char *)__cxa_allocate_exception(0x40uLL);
  *(void *)exception = &unk_26CB57200;
  std::logic_error::logic_error((std::logic_error *)(exception + 8), a1);
  *((void *)exception + 4) = 0;
  *((void *)exception + 5) = 0;
  *((void *)exception + 6) = 0;
  *((_DWORD *)exception + 14) = -1;
  *(void *)exception = &unk_26CB57110;
  *((void *)exception + 1) = &unk_26CB57140;
  *((void *)exception + 3) = &unk_26CB57168;
}

uint64_t boost::wrapexcept<std::domain_error>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  MEMORY[0x21D48F400](a1 + 8);
  return a1;
}

void non-virtual thunk to'boost::wrapexcept<std::domain_error>::~wrapexcept(void *a1)
{
  *a1 = &unk_26CB57258;
  uint64_t v2 = a1[1];
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    a1[1] = 0;
  }
  MEMORY[0x21D48F400](a1 - 2);

  JUMPOUT(0x21D48F780);
}

{
  uint64_t v2;
  uint64_t vars8;

  *a1 = &unk_26CB57258;
  uint64_t v2 = a1[1];
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    a1[1] = 0;
  }

  JUMPOUT(0x21D48F400);
}

void non-virtual thunk to'boost::wrapexcept<std::domain_error>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 24) = 0;
  }
  MEMORY[0x21D48F400](a1);

  JUMPOUT(0x21D48F780);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)(a1 + 16) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 24) = 0;
  }

  JUMPOUT(0x21D48F400);
}

void boost::wrapexcept<std::domain_error>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CB57258;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  MEMORY[0x21D48F400](a1 + 8);

  JUMPOUT(0x21D48F780);
}

void boost::wrapexcept<std::domain_error>::rethrow(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<std::domain_error>::wrapexcept((uint64_t)exception, a1);
}

void sub_21B53DCB8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::wrapexcept<std::domain_error>::wrapexcept(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26CB57200;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), (const std::logic_error *)(a2 + 8));
  *(void *)(a1 + 8) = MEMORY[0x263F8C380] + 16;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &unk_26CB57258;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v5;
  *(void *)a1 = &unk_26CB57110;
  *(void *)(a1 + 8) = &unk_26CB57140;
  *(void *)(a1 + 24) = &unk_26CB57168;
  return a1;
}

void boost::wrapexcept<std::domain_error>::clone()
{
}

void HOA::applyDecoderWeighting(unsigned int *a1, void *a2, unsigned int a3, int a4)
{
  if (!a4) {
    return;
  }
  vDSP_Length v8 = a1[2];
  if (v8)
  {
    uint64_t v9 = operator new(4 * v8);
    bzero(v9, 4 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  unsigned int __IC = a3;
  if (a4 == 2)
  {
    uint64_t v14 = *a1;
    if (v14 > 0x22)
    {
      unsigned int v16 = v14 + 1;
      boost::math::detail::gamma_imp<double,boost::math::policies::policy<boost::math::policies::promote_float<false>,boost::math::policies::promote_double<false>,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy>,boost::math::lanczos::lanczos13m53>((float)(v14 + 1));
      if (fabs(v17) > 3.40282347e38) {
        goto LABEL_39;
      }
      float v15 = v17;
      if (v15 <= 3.4028e38) {
        float v15 = floorf(v15 + 0.5);
      }
    }
    else
    {
      float v15 = flt_21B564958[v14];
      unsigned int v16 = v14 + 1;
    }
    if (v16 <= 0x22)
    {
      float v18 = flt_21B564958[v16];
      goto LABEL_21;
    }
    boost::math::detail::gamma_imp<double,boost::math::policies::policy<boost::math::policies::promote_float<false>,boost::math::policies::promote_double<false>,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy>,boost::math::lanczos::lanczos13m53>((float)(v14 + 2));
    if (fabs(v19) <= 3.40282347e38)
    {
      float v18 = v19;
      float v20 = floorf(v18 + 0.5);
      if (v18 <= 3.4028e38) {
        float v18 = v20;
      }
LABEL_21:
      unsigned int v21 = 0;
      float v22 = v18 * v15;
      unsigned int v23 = 1;
      unsigned int v24 = v14;
      do
      {
        float v34 = 0.0;
        unsigned int v25 = v14 + v21 + 1;
        if (v25 > 0x22)
        {
          boost::math::detail::gamma_imp<double,boost::math::policies::policy<boost::math::policies::promote_float<false>,boost::math::policies::promote_double<false>,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy>,boost::math::lanczos::lanczos13m53>((float)(v14 + v21 + 2));
          if (fabs(v27) > 3.40282347e38) {
            goto LABEL_39;
          }
          float v26 = v27;
          if (v26 <= 3.4028e38) {
            float v26 = floorf(v26 + 0.5);
          }
        }
        else
        {
          float v26 = flt_21B564958[v25];
        }
        if (v24 > 0x22)
        {
          boost::math::detail::gamma_imp<double,boost::math::policies::policy<boost::math::policies::promote_float<false>,boost::math::policies::promote_double<false>,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy,boost::math::policies::default_policy>,boost::math::lanczos::lanczos13m53>((float)(v24 + 1));
          if (fabs(v29) > 3.40282347e38) {
            goto LABEL_39;
          }
          float v28 = v29;
          if (v28 <= 3.4028e38) {
            float v28 = floorf(v28 + 0.5);
          }
        }
        else
        {
          float v28 = flt_21B564958[v24];
        }
        float v34 = v22 / (float)(v28 * v26);
        vDSP_vfill(&v34, (float *)v9 + v21 * v21, 1, v23);
        ++v21;
        v23 += 2;
        --v24;
      }
      while (v21 <= v14);
      goto LABEL_33;
    }
LABEL_39:
    boost::math::policies::detail::raise_error<std::overflow_error,float>();
  }
  if (a4 == 1)
  {
    unsigned int v10 = *a1;
    float v11 = cosf(2.4068 / (float)((float)*a1 + 1.51));
    long long v12 = 0;
    unsigned int v13 = 1;
    do
    {
      float __A = HOA::legendre(v12, 0, v11);
      vDSP_vfill(&__A, (float *)v9 + (v12 * v12), 1, v13);
      long long v12 = (HOA *)(v12 + 1);
      v13 += 2;
    }
    while (v12 <= v10);
  }
  else
  {
    float __C = 1.0;
    vDSP_vfill((const float *)v9, &__C, 1, v8);
  }
LABEL_33:
  if (__IC)
  {
    uint64_t v30 = 0;
    do
    {
      vDSP_vmul((const float *)v9, 1, (const float *)(*a2 + v30), __IC, (float *)(*a2 + v30), __IC, a1[2]);
      v30 += 4;
    }
    while (4 * __IC != v30);
  }
  if (v9) {
    operator delete(v9);
  }
}

void sub_21B53E2FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

int *HOA::HOA(int *a1, unsigned int a2, int a3, int a4)
{
  uint64_t v149 = *MEMORY[0x263EF8340];
  *((_OWORD *)a1 + 2) = 0u;
  a1[1] = a2;
  *((unsigned char *)a1 + 28) = 0;
  *((_OWORD *)a1 + 5) = 0u;
  long long v5 = (char **)(a1 + 20);
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  a1[44] = a4;
  *(_OWORD *)(a1 + 46) = 0u;
  *(_OWORD *)(a1 + 58) = 0u;
  int v136 = (char **)(a1 + 58);
  uint64_t v137 = (char **)(a1 + 52);
  uint64_t v138 = (char **)(a1 + 26);
  __int16 v135 = (char **)(a1 + 64);
  *(_OWORD *)(a1 + 7std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  uint64_t v6 = (char **)(a1 + 70);
  *(_OWORD *)(a1 + 5std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0u;
  *(_OWORD *)(a1 + 54) = 0u;
  *(_OWORD *)(a1 + 62) = 0u;
  *(_OWORD *)(a1 + 66) = 0u;
  *((void *)a1 + 37) = 0;
  a1[76] = a3;
  HOA::RotationMatrix::RotationMatrix((uint64_t)(a1 + 78), a2, a3, 1);
  *((void *)a1 + 46) = 0;
  *((void *)a1 + 47) = 0;
  *((void *)a1 + 48) = 0;
  unsigned int v8 = a1[1];
  unsigned int v9 = v8 + 1;
  unsigned int v10 = v9 * v9;
  a1[3] = (v8 + 1) * (v8 + 1);
  *a1 = v8;
  if (a1[76] == 2 && v8 >= 4)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      CFDictionaryRef v140 = "HOA.cpp";
      __int16 v141 = 1024;
      __int16 v143 = 2080;
      int v142 = 684;
      uint64_t v144 = "initialize";
      __int16 v145 = 1024;
      int v146 = 684;
      __int16 v147 = 1024;
      unsigned int v148 = v8;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; initializing a HOA instance with order = %d > 3 with FuMa normalization",
        buf,
        0x28u);
    }
    int v11 = 3;
  }
  else
  {
    if (v8 < 0xB) {
      goto LABEL_11;
    }
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      CFDictionaryRef v140 = "HOA.cpp";
      __int16 v141 = 1024;
      __int16 v143 = 2080;
      int v142 = 687;
      uint64_t v144 = "initialize";
      __int16 v145 = 1024;
      int v146 = 687;
      __int16 v147 = 1024;
      unsigned int v148 = v8;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Warning; initializing a HOA instance with order = %d > 10",
        buf,
        0x28u);
    }
    int v11 = 10;
  }
  *a1 = v11;
  unsigned int v9 = v11 + 1;
  unsigned int v10 = v9 * v9;
LABEL_11:
  long long v134 = (char **)(a1 + 92);
  a1[2] = v10;
  uint64_t v12 = *((void *)a1 + 10);
  unint64_t v13 = (*((void *)a1 + 11) - v12) >> 2;
  if (v10 <= v13)
  {
    if (v10 < v13) {
      *((void *)a1 + 11) = v12 + 4 * v10;
    }
  }
  else
  {
    std::vector<float>::__append(v5, v10 - v13);
    unsigned int v9 = *a1 + 1;
  }
  uint64_t v14 = v9;
  int v15 = a1[76];
  if (v15 == 2)
  {
    int v20 = 0;
    uint64_t v21 = 0;
    LODWORD(v22) = 0;
    unsigned int v23 = *v5;
    uint64_t v24 = (uint64_t)(*v5 + 16);
    int v25 = -1;
    __asm { FMOV            V2.4S, #1.0 }
    do
    {
      float v31 = sqrtf((float)((float)(int)v21 * 2.0) + 1.0);
      uint64_t v32 = (int)v22;
      if ((v21 & 0x7FFFFFFC) != 0)
      {
        uint64_t v33 = v20 & 0xFFFFFFF8;
        uint64_t v34 = (2 * v21) & 0xFFFFFFF8;
        uint64_t v22 = v34 + (int)v22;
        uint64_t v35 = v32;
        float v36 = (float32x4_t *)(v24 + 4 * v32);
        float v37 = (float32x4_t *)&flt_21B56446C[v35 + 4];
        do
        {
          float32x4_t v38 = vdivq_f32(_Q2, vmulq_n_f32(*v37, v31));
          v36[-1] = vdivq_f32(_Q2, vmulq_n_f32(v37[-1], v31));
          *float v36 = v38;
          v36 += 2;
          v37 += 2;
          v33 -= 8;
        }
        while (v33);
      }
      else
      {
        LODWORD(v34) = 0;
        uint64_t v22 = (int)v22;
      }
      int v39 = v34 + v25;
      do
      {
        *(float *)&v23[4 * v22] = 1.0 / (float)(flt_21B56446C[v22] * v31);
        ++v22;
        _CF = __CFADD__(v39++, 1);
      }
      while (!_CF);
      ++v21;
      v20 += 2;
      v25 -= 2;
    }
    while (v21 != v14);
  }
  else if (v15)
  {
    int v40 = 0;
    uint64_t v41 = 0;
    LODWORD(v42) = 0;
    float v43 = *v5;
    uint64_t v44 = (uint64_t)(*v5 + 16);
    int v45 = -1;
    do
    {
      *(float *)v7.i32 = 1.0 / sqrtf((float)((float)(int)v41 * 2.0) + 1.0);
      uint64_t v46 = (int)v42;
      if ((v41 & 0x7FFFFFFC) != 0)
      {
        uint64_t v47 = v40 & 0xFFFFFFF8;
        uint64_t v48 = (2 * v41) & 0xFFFFFFF8;
        uint64_t v42 = v48 + (int)v42;
        int32x4_t v49 = vdupq_lane_s32(v7, 0);
        float v50 = (int32x4_t *)(v44 + 4 * v46);
        do
        {
          v50[-1] = v49;
          *float v50 = v49;
          v50 += 2;
          v47 -= 8;
        }
        while (v47);
      }
      else
      {
        LODWORD(v48) = 0;
        uint64_t v42 = (int)v42;
      }
      int v51 = v48 + v45;
      do
      {
        *(_DWORD *)&v43[4 * v42++] = v7.i32[0];
        _CF = __CFADD__(v51++, 1);
      }
      while (!_CF);
      ++v41;
      v40 += 2;
      v45 -= 2;
    }
    while (v41 != v14);
  }
  else
  {
    int v16 = 0;
    double v17 = *v5;
    uint64_t v18 = 1;
    size_t v19 = 4;
    do
    {
      memset_pattern16(&v17[4 * v16], &unk_21B551680, v19);
      v16 += v18;
      v18 += 2;
      v19 += 8;
      --v14;
    }
    while (v14);
  }
  unint64_t v52 = (a1[2] * a1[2]);
  *(_DWORD *)buf = 0;
  std::vector<float>::assign(v138, v52, buf);
  int v55 = a1[44];
  uint64_t v56 = *a1;
  if (v55)
  {
    if (v55 == 2)
    {
      if (v56 < 0xA)
      {
        float v57 = &unk_21B56509C;
        goto LABEL_50;
      }
    }
    else
    {
      if (v55 != 1) {
        goto LABEL_53;
      }
      if (v56 < 0xA)
      {
        float v57 = &unk_21B565074;
LABEL_50:
        unsigned int v54 = v57[v56];
        goto LABEL_53;
      }
    }
    unsigned int v54 = 121;
  }
  else
  {
    if (v56 < 0x16)
    {
      float v57 = &unk_21B5650C4;
      goto LABEL_50;
    }
    unsigned int v54 = 1014;
  }
LABEL_53:
  a1[6] = v54;
  unint64_t v58 = v54;
  uint64_t v59 = *((void *)a1 + 26);
  unint64_t v60 = (*((void *)a1 + 27) - v59) >> 2;
  if (v58 <= v60)
  {
    if (v58 < v60) {
      *((void *)a1 + 27) = v59 + 4 * v58;
    }
  }
  else
  {
    std::vector<float>::__append(v137, v58 - v60);
    unint64_t v58 = a1[6];
  }
  uint64_t v61 = *((void *)a1 + 29);
  unint64_t v62 = (*((void *)a1 + 30) - v61) >> 2;
  if (v58 <= v62)
  {
    if (v58 < v62) {
      *((void *)a1 + 3std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v61 + 4 * v58;
    }
  }
  else
  {
    std::vector<float>::__append(v136, v58 - v62);
    unint64_t v58 = a1[6];
  }
  float v63 = (char *)*((void *)a1 + 32);
  unint64_t v64 = (uint64_t)(*((void *)a1 + 33) - (void)v63) >> 2;
  if (v58 <= v64)
  {
    if (v58 < v64) {
      *((void *)a1 + 33) = &v63[4 * v58];
    }
  }
  else
  {
    std::vector<float>::__append(v135, v58 - v64);
    float v63 = *v135;
  }
  int v65 = a1[44];
  int v66 = *a1;
  uint64_t v67 = *((void *)a1 + 26);
  uint64_t v68 = *((void *)a1 + 29);
  if (v65)
  {
    if (v65 == 2)
    {
      switch(v66)
      {
        case 0:
          if (v67 && v68 && v63)
          {
LABEL_77:
            *(_DWORD *)uint64_t v67 = 0;
            *(_DWORD *)uint64_t v68 = 0;
            *(_DWORD *)float v63 = 1065353216;
          }
          break;
        case 1:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)uint64_t v67 = xmmword_21B551650;
            *(_OWORD *)uint64_t v68 = xmmword_21B551660;
            float v70 = &xmmword_21B551670;
LABEL_127:
            *(_OWORD *)float v63 = *v70;
          }
          break;
        case 2:
          if (v67 && v68 && v63)
          {
            *(_DWORD *)(v67 + 32) = 1116271638;
            *(_OWORD *)uint64_t v67 = xmmword_21B562B68;
            *(_OWORD *)(v67 + 16) = unk_21B562B78;
            *(_DWORD *)(v68 + 32) = -1035839118;
            *(_OWORD *)uint64_t v68 = xmmword_21B562B8C;
            *(_OWORD *)(v68 + 16) = unk_21B562B9C;
            *((_DWORD *)v63 + 8) = 1068792731;
            float v71 = &xmmword_21B562BB0;
            goto LABEL_141;
          }
          break;
        case 3:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)uint64_t v67 = xmmword_21B562BD4;
            *(_OWORD *)(v67 + 16) = unk_21B562BE4;
            *(_OWORD *)(v67 + 32) = xmmword_21B562BF4;
            *(_OWORD *)(v67 + 48) = unk_21B562C04;
            *(_OWORD *)uint64_t v68 = xmmword_21B562C14;
            *(_OWORD *)(v68 + 16) = unk_21B562C24;
            *(_OWORD *)(v68 + 32) = xmmword_21B562C34;
            *(_OWORD *)(v68 + 48) = unk_21B562C44;
            float v72 = &xmmword_21B562C54;
            goto LABEL_157;
          }
          break;
        case 4:
          if (v67 && v68 && v63)
          {
            *(_DWORD *)(v67 + 96) = 1058111518;
            *(_OWORD *)uint64_t v67 = xmmword_21B562C94;
            *(_OWORD *)(v67 + 16) = unk_21B562CA4;
            *(_OWORD *)(v67 + 64) = xmmword_21B562CD4;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B562CE4;
            *(_OWORD *)(v67 + 32) = xmmword_21B562CB4;
            *(_OWORD *)(v67 + 48) = unk_21B562CC4;
            *(_OWORD *)uint64_t v68 = xmmword_21B562CF8;
            *(_OWORD *)(v68 + 16) = unk_21B562D08;
            *(_OWORD *)(v68 + 64) = xmmword_21B562D38;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B562D48;
            *(_OWORD *)(v68 + 32) = xmmword_21B562D18;
            *(_OWORD *)(v68 + 48) = unk_21B562D28;
            *(_DWORD *)(v68 + 96) = 1110360230;
            *((_DWORD *)v63 + 24) = 1057102910;
            float v71 = &xmmword_21B562D5C;
LABEL_140:
            long long v76 = v71[5];
            *((_OWORD *)v63 + 4) = v71[4];
            *((_OWORD *)v63 + 5) = v76;
            long long v77 = v71[3];
            *((_OWORD *)v63 + 2) = v71[2];
            *((_OWORD *)v63 + 3) = v77;
LABEL_141:
            long long v78 = v71[1];
            *(_OWORD *)float v63 = *v71;
            *((_OWORD *)v63 + 1) = v78;
          }
          break;
        case 5:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)(v67 + 32) = xmmword_21B562DE0;
            *(_OWORD *)(v67 + 48) = unk_21B562DF0;
            *(_OWORD *)(v67 + 128) = xmmword_21B562E40;
            *(_OWORD *)(v67 + 96) = xmmword_21B562E20;
            *(_OWORD *)(v67 + 112) = unk_21B562E30;
            *(_OWORD *)(v67 + 64) = xmmword_21B562E00;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B562E10;
            *(_OWORD *)uint64_t v67 = xmmword_21B562DC0;
            *(_OWORD *)(v67 + 16) = unk_21B562DD0;
            *(_OWORD *)(v68 + 32) = xmmword_21B562E70;
            *(_OWORD *)(v68 + 48) = unk_21B562E80;
            *(_OWORD *)uint64_t v68 = xmmword_21B562E50;
            *(_OWORD *)(v68 + 16) = unk_21B562E60;
            *(_OWORD *)(v68 + 128) = xmmword_21B562ED0;
            *(_OWORD *)(v68 + 96) = xmmword_21B562EB0;
            *(_OWORD *)(v68 + 112) = unk_21B562EC0;
            *(_OWORD *)(v68 + 64) = xmmword_21B562E90;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B562EA0;
            float v73 = &xmmword_21B562EE0;
LABEL_146:
            long long v79 = v73[7];
            *((_OWORD *)v63 + 6) = v73[6];
            *((_OWORD *)v63 + 7) = v79;
            *((_OWORD *)v63 + 8) = v73[8];
            long long v80 = v73[3];
            *((_OWORD *)v63 + 2) = v73[2];
            *((_OWORD *)v63 + 3) = v80;
            long long v81 = v73[5];
            *((_OWORD *)v63 + 4) = v73[4];
            *((_OWORD *)v63 + 5) = v81;
            long long v82 = v73[1];
            *(_OWORD *)float v63 = *v73;
            *((_OWORD *)v63 + 1) = v82;
          }
          break;
        case 6:
          if (v67 && v68 && v63)
          {
            *(_DWORD *)(v67 + 192) = 1127431944;
            *(_OWORD *)(v67 + 128) = xmmword_21B562FF0;
            *(_OWORD *)(v67 + 144) = unk_21B563000;
            *(_OWORD *)(v67 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B563010;
            *(_OWORD *)(v67 + 176) = unk_21B563020;
            *(_OWORD *)(v67 + 64) = xmmword_21B562FB0;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B562FC0;
            *(_OWORD *)(v67 + 96) = xmmword_21B562FD0;
            *(_OWORD *)(v67 + 112) = unk_21B562FE0;
            *(_OWORD *)uint64_t v67 = xmmword_21B562F70;
            *(_OWORD *)(v67 + 16) = unk_21B562F80;
            *(_OWORD *)(v67 + 32) = xmmword_21B562F90;
            *(_OWORD *)(v67 + 48) = unk_21B562FA0;
            *(_DWORD *)(v68 + 192) = -1030844557;
            *(_OWORD *)(v68 + 128) = xmmword_21B5630B4;
            *(_OWORD *)(v68 + 144) = unk_21B5630C4;
            *(_OWORD *)(v68 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B5630D4;
            *(_OWORD *)(v68 + 176) = unk_21B5630E4;
            *(_OWORD *)(v68 + 64) = xmmword_21B563074;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B563084;
            *(_OWORD *)(v68 + 96) = xmmword_21B563094;
            *(_OWORD *)(v68 + 112) = unk_21B5630A4;
            *(_OWORD *)uint64_t v68 = xmmword_21B563034;
            *(_OWORD *)(v68 + 16) = unk_21B563044;
            *(_OWORD *)(v68 + 32) = xmmword_21B563054;
            *(_OWORD *)(v68 + 48) = unk_21B563064;
            *((_DWORD *)v63 + 48) = 1048755214;
            float v72 = &xmmword_21B5630F8;
            goto LABEL_156;
          }
          break;
        case 7:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)(v67 + 192) = xmmword_21B56327C;
            *(_OWORD *)(v67 + 208) = unk_21B56328C;
            *(_OWORD *)(v67 + 224) = xmmword_21B56329C;
            *(_OWORD *)(v67 + 24std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B5632AC;
            *(_OWORD *)(v67 + 128) = xmmword_21B56323C;
            *(_OWORD *)(v67 + 144) = unk_21B56324C;
            *(_OWORD *)(v67 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B56325C;
            *(_OWORD *)(v67 + 176) = unk_21B56326C;
            *(_OWORD *)(v67 + 64) = xmmword_21B5631FC;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B56320C;
            *(_OWORD *)(v67 + 96) = xmmword_21B56321C;
            *(_OWORD *)(v67 + 112) = unk_21B56322C;
            *(_OWORD *)uint64_t v67 = xmmword_21B5631BC;
            *(_OWORD *)(v67 + 16) = unk_21B5631CC;
            *(_OWORD *)(v67 + 32) = xmmword_21B5631DC;
            *(_OWORD *)(v67 + 48) = unk_21B5631EC;
            *(_OWORD *)(v68 + 192) = xmmword_21B56337C;
            *(_OWORD *)(v68 + 208) = unk_21B56338C;
            *(_OWORD *)(v68 + 224) = xmmword_21B56339C;
            *(_OWORD *)(v68 + 24std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B5633AC;
            *(_OWORD *)(v68 + 128) = xmmword_21B56333C;
            *(_OWORD *)(v68 + 144) = unk_21B56334C;
            *(_OWORD *)(v68 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B56335C;
            *(_OWORD *)(v68 + 176) = unk_21B56336C;
            *(_OWORD *)(v68 + 64) = xmmword_21B5632FC;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B56330C;
            *(_OWORD *)(v68 + 96) = xmmword_21B56331C;
            *(_OWORD *)(v68 + 112) = unk_21B56332C;
            *(_OWORD *)uint64_t v68 = xmmword_21B5632BC;
            *(_OWORD *)(v68 + 16) = unk_21B5632CC;
            *(_OWORD *)(v68 + 32) = xmmword_21B5632DC;
            *(_OWORD *)(v68 + 48) = unk_21B5632EC;
            float v72 = &xmmword_21B5633BC;
LABEL_155:
            long long v83 = v72[13];
            *((_OWORD *)v63 + 12) = v72[12];
            *((_OWORD *)v63 + 13) = v83;
            long long v84 = v72[15];
            *((_OWORD *)v63 + 14) = v72[14];
            *((_OWORD *)v63 + 15) = v84;
LABEL_156:
            long long v85 = v72[9];
            *((_OWORD *)v63 + 8) = v72[8];
            *((_OWORD *)v63 + 9) = v85;
            long long v86 = v72[11];
            *((_OWORD *)v63 + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v72[10];
            *((_OWORD *)v63 + 11) = v86;
            long long v87 = v72[5];
            *((_OWORD *)v63 + 4) = v72[4];
            *((_OWORD *)v63 + 5) = v87;
            long long v88 = v72[7];
            *((_OWORD *)v63 + 6) = v72[6];
            *((_OWORD *)v63 + 7) = v88;
LABEL_157:
            long long v89 = v72[1];
            *(_OWORD *)float v63 = *v72;
            *((_OWORD *)v63 + 1) = v89;
            long long v90 = v72[3];
            *((_OWORD *)v63 + 2) = v72[2];
            *((_OWORD *)v63 + 3) = v90;
          }
          break;
        case 8:
          if (v67 && v68 && v63)
          {
            memcpy(*((void **)a1 + 26), &unk_21B5634BC, 0x144uLL);
            memcpy((void *)v68, &unk_21B563600, 0x144uLL);
            float v69 = &unk_21B563744;
LABEL_162:
            int v74 = v63;
            size_t v75 = 324;
            goto LABEL_168;
          }
          break;
        case 9:
          if (v67 && v68 && v63)
          {
            memcpy(*((void **)a1 + 26), &unk_21B563888, 0x190uLL);
            memcpy((void *)v68, &unk_21B563A18, 0x190uLL);
            float v69 = &unk_21B563BA8;
LABEL_167:
            int v74 = v63;
            size_t v75 = 400;
            goto LABEL_168;
          }
          break;
        default:
          if (v67 && v68 && v63)
          {
            memcpy(*((void **)a1 + 26), &unk_21B563D38, 0x1E4uLL);
            memcpy((void *)v68, &unk_21B563F1C, 0x1E4uLL);
            float v69 = &unk_21B564100;
LABEL_122:
            int v74 = v63;
            size_t v75 = 484;
LABEL_168:
            memcpy(v74, v69, v75);
          }
          break;
      }
    }
    else if (v65 == 1)
    {
      switch(v66)
      {
        case 0:
          if (v67 && v68) {
            goto LABEL_77;
          }
          break;
        case 1:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)uint64_t v67 = xmmword_21B551650;
            *(_OWORD *)uint64_t v68 = xmmword_21B551630;
            float v70 = &xmmword_21B551640;
            goto LABEL_127;
          }
          break;
        case 2:
          if (v67 && v68 && v63)
          {
            *(_DWORD *)(v67 + 32) = 1123963561;
            *(_OWORD *)uint64_t v67 = xmmword_21B5613EC;
            *(_OWORD *)(v67 + 16) = unk_21B5613FC;
            *(_DWORD *)(v68 + 32) = -1039627997;
            *(_OWORD *)uint64_t v68 = xmmword_21B561410;
            *(_OWORD *)(v68 + 16) = unk_21B561420;
            *((_DWORD *)v63 + 8) = 1069089495;
            float v71 = &xmmword_21B561434;
            goto LABEL_141;
          }
          break;
        case 3:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)uint64_t v67 = xmmword_21B561458;
            *(_OWORD *)(v67 + 16) = unk_21B561468;
            *(_OWORD *)(v67 + 32) = xmmword_21B561478;
            *(_OWORD *)(v67 + 48) = unk_21B561488;
            *(_OWORD *)uint64_t v68 = xmmword_21B561498;
            *(_OWORD *)(v68 + 16) = unk_21B5614A8;
            *(_OWORD *)(v68 + 32) = xmmword_21B5614B8;
            *(_OWORD *)(v68 + 48) = unk_21B5614C8;
            float v72 = &xmmword_21B5614D8;
            goto LABEL_157;
          }
          break;
        case 4:
          if (v67 && v68 && v63)
          {
            *(_DWORD *)(v67 + 96) = -1038292098;
            *(_OWORD *)uint64_t v67 = xmmword_21B561518;
            *(_OWORD *)(v67 + 16) = unk_21B561528;
            *(_OWORD *)(v67 + 64) = xmmword_21B561558;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561568;
            *(_OWORD *)(v67 + 32) = xmmword_21B561538;
            *(_OWORD *)(v67 + 48) = unk_21B561548;
            *(_OWORD *)uint64_t v68 = xmmword_21B56157C;
            *(_OWORD *)(v68 + 16) = unk_21B56158C;
            *(_OWORD *)(v68 + 64) = xmmword_21B5615BC;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B5615CC;
            *(_OWORD *)(v68 + 32) = xmmword_21B56159C;
            *(_OWORD *)(v68 + 48) = unk_21B5615AC;
            *(_DWORD *)(v68 + 96) = -1040443289;
            *((_DWORD *)v63 + 24) = 1057367852;
            float v71 = &xmmword_21B5615E0;
            goto LABEL_140;
          }
          break;
        case 5:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)(v67 + 32) = xmmword_21B561664;
            *(_OWORD *)(v67 + 48) = unk_21B561674;
            *(_OWORD *)(v67 + 128) = xmmword_21B5616C4;
            *(_OWORD *)(v67 + 96) = xmmword_21B5616A4;
            *(_OWORD *)(v67 + 112) = unk_21B5616B4;
            *(_OWORD *)(v67 + 64) = xmmword_21B561684;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561694;
            *(_OWORD *)uint64_t v67 = xmmword_21B561644;
            *(_OWORD *)(v67 + 16) = unk_21B561654;
            *(_OWORD *)(v68 + 32) = xmmword_21B5616F4;
            *(_OWORD *)(v68 + 48) = unk_21B561704;
            *(_OWORD *)uint64_t v68 = xmmword_21B5616D4;
            *(_OWORD *)(v68 + 16) = unk_21B5616E4;
            *(_OWORD *)(v68 + 128) = xmmword_21B561754;
            *(_OWORD *)(v68 + 96) = xmmword_21B561734;
            *(_OWORD *)(v68 + 112) = unk_21B561744;
            *(_OWORD *)(v68 + 64) = xmmword_21B561714;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561724;
            float v73 = &xmmword_21B561764;
            goto LABEL_146;
          }
          break;
        case 6:
          if (v67 && v68 && v63)
          {
            *(_DWORD *)(v67 + 192) = -1022566698;
            *(_OWORD *)(v67 + 128) = xmmword_21B561874;
            *(_OWORD *)(v67 + 144) = unk_21B561884;
            *(_OWORD *)(v67 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B561894;
            *(_OWORD *)(v67 + 176) = unk_21B5618A4;
            *(_OWORD *)(v67 + 64) = xmmword_21B561834;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561844;
            *(_OWORD *)(v67 + 96) = xmmword_21B561854;
            *(_OWORD *)(v67 + 112) = unk_21B561864;
            *(_OWORD *)uint64_t v67 = xmmword_21B5617F4;
            *(_OWORD *)(v67 + 16) = unk_21B561804;
            *(_OWORD *)(v67 + 32) = xmmword_21B561814;
            *(_OWORD *)(v67 + 48) = unk_21B561824;
            *(_DWORD *)(v68 + 192) = 1102138249;
            *(_OWORD *)(v68 + 128) = xmmword_21B561938;
            *(_OWORD *)(v68 + 144) = unk_21B561948;
            *(_OWORD *)(v68 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B561958;
            *(_OWORD *)(v68 + 176) = unk_21B561968;
            *(_OWORD *)(v68 + 64) = xmmword_21B5618F8;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561908;
            *(_OWORD *)(v68 + 96) = xmmword_21B561918;
            *(_OWORD *)(v68 + 112) = unk_21B561928;
            *(_OWORD *)uint64_t v68 = xmmword_21B5618B8;
            *(_OWORD *)(v68 + 16) = unk_21B5618C8;
            *(_OWORD *)(v68 + 32) = xmmword_21B5618D8;
            *(_OWORD *)(v68 + 48) = unk_21B5618E8;
            *((_DWORD *)v63 + 48) = 1048646893;
            float v72 = &xmmword_21B56197C;
            goto LABEL_156;
          }
          break;
        case 7:
          if (v67 && v68 && v63)
          {
            *(_OWORD *)(v67 + 192) = xmmword_21B561B00;
            *(_OWORD *)(v67 + 208) = unk_21B561B10;
            *(_OWORD *)(v67 + 224) = xmmword_21B561B20;
            *(_OWORD *)(v67 + 24std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561B30;
            *(_OWORD *)(v67 + 128) = xmmword_21B561AC0;
            *(_OWORD *)(v67 + 144) = unk_21B561AD0;
            *(_OWORD *)(v67 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B561AE0;
            *(_OWORD *)(v67 + 176) = unk_21B561AF0;
            *(_OWORD *)(v67 + 64) = xmmword_21B561A80;
            *(_OWORD *)(v67 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561A90;
            *(_OWORD *)(v67 + 96) = xmmword_21B561AA0;
            *(_OWORD *)(v67 + 112) = unk_21B561AB0;
            *(_OWORD *)uint64_t v67 = xmmword_21B561A40;
            *(_OWORD *)(v67 + 16) = unk_21B561A50;
            *(_OWORD *)(v67 + 32) = xmmword_21B561A60;
            *(_OWORD *)(v67 + 48) = unk_21B561A70;
            *(_OWORD *)(v68 + 192) = xmmword_21B561C00;
            *(_OWORD *)(v68 + 208) = unk_21B561C10;
            *(_OWORD *)(v68 + 224) = xmmword_21B561C20;
            *(_OWORD *)(v68 + 24std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561C30;
            *(_OWORD *)(v68 + 128) = xmmword_21B561BC0;
            *(_OWORD *)(v68 + 144) = unk_21B561BD0;
            *(_OWORD *)(v68 + 16std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = xmmword_21B561BE0;
            *(_OWORD *)(v68 + 176) = unk_21B561BF0;
            *(_OWORD *)(v68 + 64) = xmmword_21B561B80;
            *(_OWORD *)(v68 + 8std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = unk_21B561B90;
            *(_OWORD *)(v68 + 96) = xmmword_21B561BA0;
            *(_OWORD *)(v68 + 112) = unk_21B561BB0;
            *(_OWORD *)uint64_t v68 = xmmword_21B561B40;
            *(_OWORD *)(v68 + 16) = unk_21B561B50;
            *(_OWORD *)(v68 + 32) = xmmword_21B561B60;
            *(_OWORD *)(v68 + 48) = unk_21B561B70;
            float v72 = &xmmword_21B561C40;
            goto LABEL_155;
          }
          break;
        case 8:
          if (v67 && v68 && v63)
          {
            memcpy(*((void **)a1 + 26), &unk_21B561D40, 0x144uLL);
            memcpy((void *)v68, &unk_21B561E84, 0x144uLL);
            float v69 = &unk_21B561FC8;
            goto LABEL_162;
          }
          break;
        case 9:
          if (v67 && v68 && v63)
          {
            memcpy(*((void **)a1 + 26), &unk_21B56210C, 0x190uLL);
            memcpy((void *)v68, &unk_21B56229C, 0x190uLL);
            float v69 = &unk_21B56242C;
            goto LABEL_167;
          }
          break;
        default:
          if (v67 && v68 && v63)
          {
            memcpy(*((void **)a1 + 26), &unk_21B5625BC, 0x1E4uLL);
            memcpy((void *)v68, &unk_21B5627A0, 0x1E4uLL);
            float v69 = &unk_21B562984;
            goto LABEL_122;
          }
          break;
      }
    }
  }
  else
  {
    HOA::getTDesign((HOA *)*a1, (_OWORD *)v67, *((float **)a1 + 29), (float *)v63, v53);
  }
  vDSP_vsmul(*((const float **)a1 + 26), 1, &kDeg2Radf, *((float **)a1 + 26), 1, a1[6]);
  vDSP_vsmul(*((const float **)a1 + 29), 1, &kDeg2Radf, *((float **)a1 + 29), 1, a1[6]);
  unsigned int v91 = a1[6];
  unint64_t v92 = 3 * v91;
  uint64_t v93 = *((void *)a1 + 35);
  unint64_t v94 = (*((void *)a1 + 36) - v93) >> 2;
  if (v92 <= v94)
  {
    if (v92 < v94) {
      *((void *)a1 + 36) = v93 + 4 * v92;
    }
  }
  else
  {
    std::vector<float>::__append(v6, v92 - v94);
    unsigned int v91 = a1[6];
  }
  if (v91)
  {
    float v95 = *v137;
    float v96 = *v136;
    uint64_t v97 = v91;
    uint64_t v98 = (float *)(*v6 + 8);
    do
    {
      float v99 = *(float *)v95;
      v95 += 4;
      float v100 = v99;
      float v101 = *(float *)v96;
      v96 += 4;
      __float2 v102 = __sincosf_stret(v101);
      __float2 v103 = __sincosf_stret(v100);
      *(v98 - 2) = v102.__cosval * v103.__cosval;
      *(v98 - 1) = v102.__cosval * v103.__sinval;
      *uint64_t v98 = v102.__sinval;
      v98 += 3;
      --v97;
    }
    while (v97);
  }
  if (a1[76] != 2) {
    goto LABEL_220;
  }
  unsigned int v104 = a1[2];
  unint64_t v105 = v104 * v104;
  uint64_t v106 = *((void *)a1 + 46);
  unint64_t v107 = (*((void *)a1 + 47) - v106) >> 2;
  if (v105 <= v107)
  {
    if (v105 < v107) {
      *((void *)a1 + 47) = v106 + 4 * v105;
    }
  }
  else
  {
    std::vector<float>::__append(v134, v105 - v107);
    unsigned int v104 = a1[2];
  }
  if (!v104) {
    goto LABEL_220;
  }
  unsigned int v108 = *v134;
  if (v104 >= 8)
  {
    uint64_t v110 = 0;
    int v111 = 0;
    uint64_t v112 = 0;
    uint64_t v113 = (long long *)&unk_21B5644BC;
    while (1)
    {
      int v114 = v111;
      unint64_t v115 = v113;
      uint64_t v116 = v104 & 0xFFFFFFF8;
      if (__CFADD__(v104 * v112, v104 - 1))
      {
        uint64_t v117 = 0;
      }
      else
      {
        do
        {
          long long v118 = *v115;
          uint64_t v119 = &v108[4 * v114];
          *(_OWORD *)uint64_t v119 = *(v115 - 1);
          *((_OWORD *)v119 + 1) = v118;
          v115 += 2;
          v114 += 8;
          v116 -= 8;
        }
        while (v116);
        uint64_t v117 = v104 & 0xFFFFFFF8;
        if (v117 == v104) {
          goto LABEL_187;
        }
      }
      uint64_t v120 = v104 - v117;
      int v121 = v111 + v117;
      int v122 = (int *)&xmmword_21B5644AC + v117 + v110;
      do
      {
        int v123 = *v122++;
        *(_DWORD *)&v108[4 * v121++] = v123;
        --v120;
      }
      while (v120);
LABEL_187:
      ++v112;
      v113 += 4;
      v111 += v104;
      v110 += 16;
      if (v112 == v104) {
        goto LABEL_220;
      }
    }
  }
  *(_DWORD *)unsigned int v108 = 1065353216;
  if (v104 == 1) {
    goto LABEL_220;
  }
  *((_DWORD *)v108 + 1) = 0;
  *((_DWORD *)v108 + 2) = 0;
  if (v104 == 2)
  {
    uint64_t v109 = 3;
LABEL_219:
    *(_DWORD *)&v108[4 * v109] = 0;
    goto LABEL_220;
  }
  *((_DWORD *)v108 + 3) = 0;
  if (v104 == 3)
  {
    *((void *)v108 + 2) = 0;
    *((void *)v108 + 3) = 0x3F80000000000000;
    uint64_t v109 = 8;
    goto LABEL_219;
  }
  if (v104 != 4)
  {
    *((_DWORD *)v108 + 4) = 0;
    if (v104 != 5)
    {
      *((_DWORD *)v108 + 5) = 0;
      if (v104 != 6) {
        *((_DWORD *)v108 + 6) = 0;
      }
    }
  }
  *(_DWORD *)&v108[4 * v104] = 0;
  *(_DWORD *)&v108[4 * v104 + 4] = 0;
  *(_DWORD *)&v108[4 * v104 + 8] = 0;
  *(_DWORD *)&v108[4 * v104 + 12] = 1065353216;
  if (v104 != 4)
  {
    *(_DWORD *)&v108[4 * v104 + 16] = 0;
    if (v104 != 5)
    {
      *(_DWORD *)&v108[4 * v104 + 20] = 0;
      if (v104 != 6)
      {
        *((_DWORD *)v108 + 13) = 0;
        int v127 = 2 * v104;
        *(void *)&v108[8 * v104] = 0x3F80000000000000;
        *(_DWORD *)&v108[4 * (v127 + 2)] = 0;
        *(_DWORD *)&v108[4 * (v127 + 3)] = 0;
        BOOL v125 = v104 == 4;
        *(_DWORD *)&v108[4 * (v127 + 4)] = 0;
        *(_DWORD *)&v108[4 * (v127 + 5)] = 0;
        unsigned int v126 = 2 * v104 + 6;
        goto LABEL_209;
      }
    }
  }
  int v124 = 2 * v104;
  *(void *)&v108[8 * v104] = 0x3F80000000000000;
  *(_DWORD *)&v108[4 * (v124 + 2)] = 0;
  *(_DWORD *)&v108[4 * (v124 + 3)] = 0;
  BOOL v125 = v104 == 4;
  if (v104 != 4)
  {
    *(_DWORD *)&v108[4 * (v124 + 4)] = 0;
    if (v104 != 5)
    {
      unsigned int v126 = v124 + 5;
LABEL_209:
      *(_DWORD *)&v108[4 * v126] = 0;
    }
  }
  unsigned int v128 = 3 * v104;
  *(_DWORD *)&v108[4 * v128] = 0;
  *(_DWORD *)&v108[4 * v128 + 4] = 0;
  *(_DWORD *)&v108[4 * v128 + 8] = 1065353216;
  *(_DWORD *)&v108[4 * v128 + 12] = 0;
  if (!v125)
  {
    *(_DWORD *)&v108[4 * v128 + 16] = 0;
    if (v104 == 5)
    {
      *((void *)v108 + 1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
      *((void *)v108 + 11) = 0;
      uint64_t v109 = 24;
      goto LABEL_219;
    }
    *(_DWORD *)&v108[4 * v128 + 20] = 0;
    if (v104 != 6) {
      *(_DWORD *)&v108[4 * v128 + 24] = 0;
    }
    int v129 = 4 * v104;
    uint64_t v130 = &v108[16 * v104];
    *(void *)uint64_t v130 = 0;
    *((void *)v130 + 1) = 0;
    *(_DWORD *)&v108[4 * (v129 + 4)] = 0;
    *(_DWORD *)&v108[4 * (v129 + 5)] = 0;
    if (v104 != 6) {
      *(_DWORD *)&v108[4 * (v129 + 6)] = 1065353216;
    }
    unsigned int v131 = 5 * v104;
    *(_DWORD *)&v108[4 * v131] = 0;
    *(_DWORD *)&v108[4 * v131 + 4] = 0;
    *(_DWORD *)&v108[4 * v131 + 8] = 0;
    *(_DWORD *)&v108[4 * v131 + 12] = 0;
    *(_DWORD *)&v108[4 * v131 + 16] = 0;
    *(_DWORD *)&v108[4 * v131 + 20] = 0;
    if (v104 != 6)
    {
      *(_DWORD *)&v108[4 * v131 + 24] = 0;
      unsigned int v132 = 6 * v104;
      *(void *)&v108[4 * v132] = 0;
      *(void *)&v108[4 * v132 + 8] = 0;
      *(void *)&v108[4 * v132 + 16] = 0x3F80000000000000;
      uint64_t v109 = v132 + 6;
      goto LABEL_219;
    }
  }
LABEL_220:
  *((void *)a1 + 2) = 0;
  *((unsigned char *)a1 + 28) = 1;
  return a1;
}

void sub_21B53F62C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11, uint64_t a12, void **a13, void **a14, void **a15, void **a16)
{
  uint64_t v21 = *v19;
  if (*v19)
  {
    v16[36] = v21;
    operator delete(v21);
  }
  uint64_t v22 = *a13;
  if (*a13)
  {
    v16[33] = v22;
    operator delete(v22);
  }
  unsigned int v23 = *a14;
  if (*a14)
  {
    v16[30] = v23;
    operator delete(v23);
  }
  uint64_t v24 = *a15;
  if (*a15)
  {
    v16[27] = v24;
    operator delete(v24);
  }
  int v25 = *a11;
  if (*a11)
  {
    unsigned char v16[24] = v25;
    operator delete(v25);
    float v26 = (void *)v16[19];
    if (!v26)
    {
LABEL_11:
      double v27 = (void *)v16[16];
      if (!v27) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    float v26 = (void *)v16[19];
    if (!v26) {
      goto LABEL_11;
    }
  }
  v16[20] = v26;
  operator delete(v26);
  double v27 = (void *)v16[16];
  if (!v27)
  {
LABEL_13:
    float v28 = *a16;
    if (*a16)
    {
      v16[14] = v28;
      operator delete(v28);
      double v29 = *v18;
      if (!*v18)
      {
LABEL_15:
        uint64_t v30 = (void *)v16[7];
        if (!v30) {
          goto LABEL_16;
        }
        goto LABEL_23;
      }
    }
    else
    {
      double v29 = *v18;
      if (!*v18) {
        goto LABEL_15;
      }
    }
    v16[11] = v29;
    operator delete(v29);
    uint64_t v30 = (void *)v16[7];
    if (!v30)
    {
LABEL_16:
      float v31 = *v17;
      if (!*v17) {
        goto LABEL_17;
      }
      goto LABEL_24;
    }
LABEL_23:
    v16[8] = v30;
    operator delete(v30);
    float v31 = *v17;
    if (!*v17) {
LABEL_17:
    }
      _Unwind_Resume(exception_object);
LABEL_24:
    void v16[5] = v31;
    operator delete(v31);
    _Unwind_Resume(exception_object);
  }
LABEL_12:
  v16[17] = v27;
  operator delete(v27);
  goto LABEL_13;
}

void HOA::~HOA(HOA *this)
{
  uint64_t v2 = (void *)*((void *)this + 46);
  if (v2)
  {
    *((void *)this + 47) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 42);
  if (v3)
  {
    *((void *)this + 43) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 39);
  if (v4)
  {
    *((void *)this + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v4;
    operator delete(v4);
  }
  long long v5 = (void *)*((void *)this + 35);
  if (v5)
  {
    *((void *)this + 36) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 32);
  if (v6)
  {
    *((void *)this + 33) = v6;
    operator delete(v6);
  }
  int32x2_t v7 = (void *)*((void *)this + 29);
  if (v7)
  {
    *((void *)this + 3std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v7;
    operator delete(v7);
  }
  unsigned int v8 = (void *)*((void *)this + 26);
  if (v8)
  {
    *((void *)this + 27) = v8;
    operator delete(v8);
  }
  unsigned int v9 = (void *)*((void *)this + 23);
  if (v9)
  {
    *((void *)this + 24) = v9;
    operator delete(v9);
  }
  unsigned int v10 = (void *)*((void *)this + 19);
  if (v10)
  {
    *((void *)this + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v10;
    operator delete(v10);
  }
  int v11 = (void *)*((void *)this + 16);
  if (v11)
  {
    *((void *)this + 17) = v11;
    operator delete(v11);
  }
  uint64_t v12 = (void *)*((void *)this + 13);
  if (v12)
  {
    *((void *)this + 14) = v12;
    operator delete(v12);
  }
  unint64_t v13 = (void *)*((void *)this + 10);
  if (v13)
  {
    *((void *)this + 11) = v13;
    operator delete(v13);
  }
  uint64_t v14 = (void *)*((void *)this + 7);
  if (v14)
  {
    *((void *)this + 8) = v14;
    operator delete(v14);
  }
  int v15 = (void *)*((void *)this + 4);
  if (v15)
  {
    *((void *)this + 5) = v15;
    operator delete(v15);
  }
}

uint64_t HOA::createEncoder(HOA *this, const float *a2, const float *a3, vDSP_Length a4, float *a5, uint64_t a6)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 28))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      float v26 = "HOA.cpp";
      __int16 v27 = 1024;
      int v28 = 777;
      __int16 v29 = 2080;
      uint64_t v30 = "createEncoder";
      __int16 v31 = 1024;
      int v32 = 777;
      unsigned int v23 = MEMORY[0x263EF8438];
      uint64_t v24 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized";
LABEL_19:
      _os_log_impl(&dword_21B4DD000, v23, OS_LOG_TYPE_ERROR, v24, buf, 0x22u);
    }
    return 4294967246;
  }
  if (*((unsigned int *)this + 3) * a4 != a6)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      float v26 = "HOA.cpp";
      __int16 v27 = 1024;
      int v28 = 782;
      __int16 v29 = 2080;
      uint64_t v30 = "createEncoder";
      __int16 v31 = 1024;
      int v32 = 782;
      unsigned int v23 = MEMORY[0x263EF8438];
      uint64_t v24 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Inconsistent vector size";
      goto LABEL_19;
    }
    return 4294967246;
  }
  if (a4)
  {
    int v11 = *((_DWORD *)this + 2);
    uint64_t v12 = 4 * a4;
    MEMORY[0x270FA5388](this);
    unint64_t v13 = &buf[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v13, 4 * a4);
    MEMORY[0x270FA5388](v14);
    bzero(v13, 4 * a4);
    vDSP_vsmul(a2, 1, &kDeg2Radf, (float *)v13, 1, a4);
    vDSP_vsmul(a3, 1, &kDeg2Radf, (float *)v13, 1, a4);
    uint64_t v15 = (v11 * a4);
    HOA::sphericalHarmonics((HOA *)v13, (const float *)v13, (const float *)a4, (uint64_t)a5, (float *)*(unsigned int *)this);
    MEMORY[0x270FA5388](v16);
    uint64_t v18 = (float *)&buf[-v17];
    bzero(&buf[-v17], 4 * v15);
    if (*((_DWORD *)this + 76) == 2)
    {
      vDSP_mmul(*((const float **)this + 46), 1, a5, 1, v18, 1, *((unsigned int *)this + 2), a4, *((unsigned int *)this + 2));
      if (v15) {
        memcpy(a5, v18, 4 * v15);
      }
    }
    uint64_t v19 = 0;
    int v20 = a5;
    do
      vDSP_vmul(*((const float **)this + 10), 1, v20++, a4, &v18[(*((_DWORD *)this + 2) * v19++)], 1, *((unsigned int *)this + 2));
    while (a4 != v19);
    if (v15) {
      memcpy(a5, v18, 4 * v15);
    }
    if (*((_DWORD *)this + 1) != *(_DWORD *)this)
    {
      uint64_t v21 = 4 * *((unsigned int *)this + 3) * a4 - 4 * v15;
      if (v21 >= 1) {
        bzero(&a5[v15], 4 * (((unint64_t)v21 >> 2) - ((unint64_t)v21 > 3)) + 4);
      }
    }
  }
  return 0;
}

void HOA::sphericalHarmonics(HOA *this, const float *a2, const float *a3, uint64_t a4, float *a5)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unsigned int v6 = a3;
    long long v83 = this;
    uint64_t v70 = (uint64_t)&v70;
    long long v76 = (HOA *)(a5 + 1);
    MEMORY[0x270FA5388](this);
    unsigned int v9 = (char *)&v70 - v8;
    bzero((char *)&v70 - v8, v10);
    unint64_t v11 = v6;
    MEMORY[0x270FA5388](v12);
    long long v87 = (char *)&v70 - ((v13 + 15) & 0x7FFFFFFF0);
    bzero(v87, v13);
    if ((int)v6 >= 1)
    {
      long long v77 = v9;
      if (v6 > 1uLL)
      {
        unint64_t v15 = v6 - (unint64_t)(v6 & 1);
        uint64_t v16 = a2;
        uint64_t v17 = v87;
        unint64_t v18 = v15;
        do
        {
          uint64_t v19 = *(void *)v16;
          v16 += 2;
          *(void *)&long long v14 = v19;
          long long v88 = v14;
          *(float *)&uint64_t v20 = sinf(*((float *)&v19 + 1));
          *(void *)&long long v90 = v20;
          *(float *)&long long v14 = sinf(*(float *)&v88);
          DWORD1(v14) = v90;
          *v17++ = v14;
          v18 -= 2;
        }
        while (v18);
        if ((v6 & 1) == 0) {
          goto LABEL_11;
        }
      }
      else
      {
        unint64_t v15 = 0;
      }
      unint64_t v21 = v6 - v15;
      unint64_t v22 = v15;
      unsigned int v23 = (float *)&v87[4 * v15];
      uint64_t v24 = &a2[v22];
      do
      {
        float v25 = *v24++;
        *v23++ = sinf(v25);
        --v21;
      }
      while (v21);
LABEL_11:
      float v26 = (float *)v77;
      int v86 = 0;
      int v27 = 0;
      int v28 = 0;
      uint64_t v82 = 0;
      uint64_t v75 = v6 & 7;
      uint64_t v74 = v6 - v75;
      uint64_t v29 = 4 * (int)v6;
      uint64_t v73 = a4 + 16;
      int v72 = 2 * v6;
      float v71 = v77 + 16;
      uint64_t v30 = 1;
      unsigned int v31 = v6;
      uint64_t v32 = 1;
      unint64_t v89 = v6;
      *(void *)&long long v90 = v29;
      uint64_t v85 = a4;
      do
      {
        unsigned int v78 = v31;
        uint64_t v80 = v30;
        uint64_t v33 = 0;
        int v81 = v27;
        *(void *)&long long v88 = a4 + v29 * (v32 + v27);
        uint64_t v34 = v26;
        do
        {
          __powisf2();
          float v36 = v35;
          float v37 = (float *)v87;
          float32x4_t v38 = v34;
          do
          {
            float v39 = *v37++;
            *v38++ = HOA::legendre(v28, v33, v39) * v36;
            --v11;
          }
          while (v11);
          ++v33;
          unint64_t v11 = v89;
          uint64_t v29 = v90;
          uint64_t v34 = (float *)((char *)v34 + v90);
        }
        while (v33 != v32);
        int v40 = (int)v28;
        int v41 = v86;
        int v42 = v82;
        uint64_t v43 = v75;
        uint64_t v44 = v74;
        uint64_t v45 = v73;
        uint64_t v46 = v71;
        do
        {
          uint64_t v47 = v41;
          if (v42 <= v40) {
            int v48 = v40;
          }
          else {
            int v48 = v42;
          }
          int v49 = v6 * v48;
          if (v42 >= 0) {
            uint64_t v50 = v42;
          }
          else {
            uint64_t v50 = -v42;
          }
          float v51 = sqrtf(flt_21B5648AC[(void)v28 - v50]* (float)((float)((float)((float)(int)v28 * 2.0) + 1.0)* flt_21B564900[(v50 + v28)]));
          if (v11 < 8)
          {
            uint64_t v52 = 0;
LABEL_30:
            uint64_t v57 = v49;
            uint64_t v58 = v11 - v52;
            uint64_t v59 = (float *)(a4 + 4 * (v52 + v47));
            unint64_t v60 = &v26[v52 + v57];
            do
            {
              float v61 = *v60++;
              *v59++ = v61 * v51;
              --v58;
            }
            while (v58);
            goto LABEL_18;
          }
          float v53 = (float32x4_t *)(v45 + 4 * v41);
          uint64_t v54 = v44;
          int v55 = (float32x4_t *)&v46[4 * v49];
          do
          {
            float32x4_t v56 = vmulq_n_f32(*v55, v51);
            v53[-1] = vmulq_n_f32(v55[-1], v51);
            *float v53 = v56;
            v53 += 2;
            v55 += 2;
            v54 -= 8;
          }
          while (v54);
          uint64_t v52 = v44;
          if (v43) {
            goto LABEL_30;
          }
LABEL_18:
          ++v42;
          int v41 = v47 + v6;
          --v40;
        }
        while (v32 != v42);
        uint64_t v79 = v32;
        unint64_t v62 = (float *)v88;
        if (v28)
        {
          uint64_t v63 = 0;
          long long v84 = v28;
          do
          {
            int v64 = 1;
            int v65 = v86;
            *(void *)&long long v88 = v62;
            int v66 = v28;
            uint64_t v67 = v83;
            uint64_t v68 = v85;
            do
            {
              *unint64_t v62 = (float)(*v62 * 1.4142) * cosf(*((float *)v67 + v63) * (float)v64);
              float v69 = sinf(-(float)((float)(int)v66 * *((float *)v67 + v63)));
              uint64_t v29 = v90;
              *(float *)(v68 + 4 * (v63 + v65)) = (float)(*(float *)(v68 + 4 * (v63 + v65)) * 1.4142) * v69;
              unint64_t v62 = (float *)((char *)v62 + v29);
              ++v64;
              v65 += v6;
              int v66 = (HOA *)((char *)v66 - 1);
            }
            while (v66);
            ++v63;
            unint64_t v62 = (float *)(v88 + 4);
            unint64_t v11 = v89;
            int v28 = v84;
          }
          while (v63 != v89);
        }
        int v28 = (HOA *)((char *)v28 + 1);
        uint64_t v32 = v79 + 1;
        --v82;
        v86 += v78;
        unsigned int v31 = v78 + v72;
        int v27 = v81 + v80;
        uint64_t v30 = (v80 + 2);
        float v26 = (float *)v77;
        a4 = v85;
      }
      while (v28 != v76);
    }
  }
}

uint64_t HOA::createEncoder(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 28))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      int v23 = 136315906;
      uint64_t v24 = "HOA.cpp";
      __int16 v25 = 1024;
      int v26 = 834;
      __int16 v27 = 2080;
      int v28 = "createEncoder";
      __int16 v29 = 1024;
      int v30 = 834;
      uint64_t v20 = MEMORY[0x263EF8438];
      unint64_t v21 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized";
LABEL_10:
      _os_log_impl(&dword_21B4DD000, v20, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v23, 0x22u);
    }
    return 4294967246;
  }
  long long v5 = *(const float **)a2;
  unint64_t v7 = *(void *)(a2 + 8) - (void)v5;
  uint64_t v8 = *(const float **)a3;
  if ((uint64_t)v7 >> 2 != (uint64_t)(*(void *)(a3 + 8) - (void)v8) >> 2)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      int v23 = 136315906;
      uint64_t v24 = "HOA.cpp";
      __int16 v25 = 1024;
      int v26 = 839;
      __int16 v27 = 2080;
      int v28 = "createEncoder";
      __int16 v29 = 1024;
      int v30 = 839;
      uint64_t v20 = MEMORY[0x263EF8438];
      unint64_t v21 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Inconsistent azimuth/elevation size";
      goto LABEL_10;
    }
    return 4294967246;
  }
  unint64_t v11 = v7 >> 2;
  long long v14 = *(float **)(a1 + 32);
  uint64_t v12 = a1 + 32;
  size_t v13 = v14;
  *(_DWORD *)(v12 - 16) = v7 >> 2;
  unint64_t v15 = *(_DWORD *)(v12 - 20) * (v7 >> 2);
  uint64_t v16 = *(float **)(v12 + 8);
  unint64_t v17 = v16 - v14;
  BOOL v18 = v15 >= v17;
  unint64_t v19 = v15 - v17;
  if (v19 != 0 && v18)
  {
    std::vector<float>::__append((char **)v12, v19);
    long long v5 = *(const float **)a2;
    uint64_t v8 = *(const float **)a3;
    LODWORD(v11) = *(_DWORD *)(a1 + 16);
    size_t v13 = *(float **)(a1 + 32);
    uint64_t v16 = *(float **)(a1 + 40);
  }
  else if (!v18)
  {
    uint64_t v16 = &v13[v15];
    *(void *)(a1 + 4std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v16;
  }

  return HOA::createEncoder((HOA *)a1, v5, v8, v11, v13, v16 - v13);
}

uint64_t HOA::createDecoder(unsigned int *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v147 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)a1 + 28))
  {
    if (!os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      return 4294967246;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "HOA.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 948;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = "createDecoder";
    *(_WORD *)&unsigned char buf[28] = 1024;
    *(_DWORD *)&buf[30] = 948;
    uint64_t v16 = MEMORY[0x263EF8438];
    unint64_t v17 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized";
LABEL_12:
    _os_log_impl(&dword_21B4DD000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x22u);
    return 4294967246;
  }
  uint64_t v6 = *(void *)(a2 + 8) - *(void *)a2;
  if (!v6)
  {
    if (!os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      return 4294967246;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "HOA.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 953;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = "createDecoder";
    *(_WORD *)&unsigned char buf[28] = 1024;
    *(_DWORD *)&buf[30] = 953;
    uint64_t v16 = MEMORY[0x263EF8438];
    unint64_t v17 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Empty azimuth/elevation";
    goto LABEL_12;
  }
  uint64_t v8 = v6 >> 2;
  if (v8 != (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "HOA.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 958;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = "createDecoder";
      *(_WORD *)&unsigned char buf[28] = 1024;
      *(_DWORD *)&buf[30] = 958;
      uint64_t v16 = MEMORY[0x263EF8438];
      unint64_t v17 = "%25s:%-5d CADSPUtility:%s:%d: HOA Error; Inconsistent azimuth/elevation size";
      goto LABEL_12;
    }
    return 4294967246;
  }
  uint64_t v14 = *((void *)a1 + 16);
  uint64_t v12 = a1 + 32;
  uint64_t v13 = v14;
  *(v12 - 27) = v8;
  unint64_t v15 = (*((void *)v12 + 1) - v14) >> 2;
  if (v8 <= v15)
  {
    if (v8 < v15) {
      *((void *)a1 + 17) = v13 + 4 * v8;
    }
  }
  else
  {
    std::vector<float>::__append((char **)v12, v8 - v15);
    LODWORD(v8) = a1[5];
  }
  vDSP_Length v20 = v8;
  uint64_t v21 = *((void *)a1 + 19);
  unint64_t v22 = (*((void *)a1 + 20) - v21) >> 2;
  if (v20 <= v22)
  {
    if (v20 < v22) {
      *((void *)a1 + 2std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v21 + 4 * v20;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1 + 19, v20 - v22);
    vDSP_Length v20 = a1[5];
  }
  vDSP_vsmul(*(const float **)a2, 1, &kDeg2Radf, *((float **)a1 + 16), 1, v20);
  vDSP_vsmul(*(const float **)a3, 1, &kDeg2Radf, *((float **)a1 + 19), 1, a1[5]);
  int v23 = (void **)(a1 + 14);
  unint64_t v24 = a1[2] * a1[5];
  *(_DWORD *)buf = 0;
  std::vector<float>::assign((char **)a1 + 7, v24, buf);
  if (!*a1)
  {
    uint64_t v30 = a1[5];
    if (v30)
    {
      *(float *)v25.i32 = 1.0 / sqrtf((float)v30);
      uint64_t v31 = (int32x4_t *)*v23;
      if (v30 >= 8)
      {
        uint64_t v32 = v30 & 0xFFFFFFF8;
        int32x4_t v33 = vdupq_lane_s32(v25, 0);
        uint64_t v34 = v31 + 1;
        uint64_t v35 = v32;
        do
        {
          v34[-1] = v33;
          *uint64_t v34 = v33;
          v34 += 2;
          v35 -= 8;
        }
        while (v35);
        if (v32 == v30)
        {
          LODWORD(v3std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = 0;
          goto LABEL_141;
        }
        LODWORD(v3std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v30 - v32;
        uint64_t v31 = (int32x4_t *)((char *)v31 + 4 * v32);
      }
      do
      {
        v31->i32[0] = v25.i32[0];
        uint64_t v31 = (int32x4_t *)((char *)v31 + 4);
        LODWORD(v3std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = v30 - 1;
      }
      while (v30);
    }
LABEL_141:
    uint64_t v18 = 0;
LABEL_142:
    if (a1[1] != v30)
    {
      unint64_t v103 = a1[5] * a1[3];
      *(_DWORD *)buf = 0;
      uint64_t v104 = *((void *)a1 + 7);
      unint64_t v105 = (*((void *)a1 + 8) - v104) >> 2;
      if (v103 <= v105)
      {
        if (v103 < v105) {
          *((void *)a1 + 8) = v104 + 4 * v103;
        }
      }
      else
      {
        std::vector<float>::__append(v23, v103 - v105, buf);
      }
    }
    return v18;
  }
  long long v142 = 0u;
  long long v143 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v127 = 0u;
  memset(buf, 0, sizeof(buf));
  int v122 = 0;
  int v123 = 0;
  int v124 = 0;
  __int16 v27 = *(const float **)a2;
  uint64_t v26 = *(void *)(a2 + 8);
  int64_t v28 = v26 - *(void *)a2;
  if (v26 == *(void *)a2)
  {
    __int16 v29 = 0;
  }
  else
  {
    if (v28 < 0) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    __int16 v29 = (char *)operator new(v26 - *(void *)a2);
    int v122 = v29;
    int v124 = &v29[4 * (v28 >> 2)];
    memcpy(v29, v27, v28);
    int v123 = v124;
  }
  uint64_t v119 = 0;
  uint64_t v120 = 0;
  int v121 = 0;
  float v37 = *(const float **)a3;
  uint64_t v36 = *(void *)(a3 + 8);
  int64_t v38 = v36 - *(void *)a3;
  if (v36 == *(void *)a3)
  {
    float v39 = 0;
  }
  else
  {
    if (v38 < 0) {
      std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
    }
    float v39 = (char *)operator new(v36 - *(void *)a3);
    uint64_t v119 = v39;
    int v121 = &v39[4 * (v38 >> 2)];
    memcpy(v39, v37, v38);
    uint64_t v120 = v121;
  }
  memset(v144, 0, 24);
  std::vector<char> __p = 0;
  uint64_t v117 = 0;
  long long v118 = 0;
  VBAP::VBAP((uint64_t)buf, (uint64_t *)&v122, (uint64_t *)&v119, 1, (char **)v144, (uint64_t *)&__p);
  int v40 = (char *)__p;
  if (__p)
  {
    int v41 = v117;
    int v42 = __p;
    if (v117 != __p)
    {
      do
      {
        uint64_t v43 = (uint64_t *)(v41 - 24);
        if (*((void *)v41 - 1))
        {
          uint64_t v45 = *((void *)v41 - 3);
          uint64_t v44 = (uint64_t *)*((void *)v41 - 2);
          uint64_t v46 = *v44;
          *(void *)(v46 + 8) = *(void *)(v45 + 8);
          **(void **)(v45 + 8) = v46;
          *((void *)v41 - 1) = 0;
          if (v44 != v43)
          {
            do
            {
              uint64_t v47 = (uint64_t *)v44[1];
              operator delete(v44);
              uint64_t v44 = v47;
            }
            while (v47 != v43);
          }
        }
        int v41 = (char *)v43;
      }
      while (v43 != (uint64_t *)v40);
      int v42 = __p;
    }
    uint64_t v117 = v40;
    operator delete(v42);
  }
  if (*(void *)v144)
  {
    *(void *)&v144[8] = *(void *)v144;
    operator delete(*(void **)v144);
  }
  if (v39)
  {
    uint64_t v120 = v39;
    operator delete(v39);
  }
  if (v29)
  {
    int v123 = v29;
    operator delete(v29);
  }
  if (BYTE11(v143))
  {
    unsigned int v48 = a1[2];
    uint64_t v117 = 0;
    long long v118 = 0;
    uint64_t v49 = 216 * v48;
    std::vector<char> __p = 0;
    if (v49)
    {
      size_t v50 = 4 * v49;
      float v51 = (char *)operator new(4 * v49);
      uint64_t v52 = &v51[4 * v49];
      std::vector<char> __p = v51;
      long long v118 = v52;
      long long __B = (float *)v51;
      bzero(v51, v50);
      uint64_t v117 = v52;
    }
    else
    {
      long long __B = 0;
    }
    float v53 = (char *)operator new(0x360uLL);
    bzero(v53, 0x360uLL);
    uint64_t v54 = (char *)operator new(0x360uLL);
    bzero(v54, 0x360uLL);
    uint64_t v109 = v54;
    int v111 = (float *)operator new(0xA20uLL);
    bzero(v111, 0xA20uLL);
    memcpy(v53, &unk_21B552AEC, 0x360uLL);
    memcpy(v54, &unk_21B552E4C, 0x360uLL);
    vDSP_vsmul((const float *)v53, 1, &kDeg2Radf, (float *)v53, 1, 0xD8uLL);
    vDSP_vsmul((const float *)v54, 1, &kDeg2Radf, (float *)v54, 1, 0xD8uLL);
    HOA::sphericalHarmonics((HOA *)v53, (const float *)v54, (const float *)0xD8, (uint64_t)__B, (float *)*a1);
    int v55 = v54;
    uint64_t v56 = 0;
    uint64_t v57 = v111 + 2;
    do
    {
      float v58 = *(float *)&v53[v56];
      __float2 v59 = __sincosf_stret(*(float *)&v55[v56]);
      __float2 v60 = __sincosf_stret(v58);
      *(v57 - 2) = v59.__cosval * v60.__cosval;
      *(v57 - 1) = v59.__cosval * v60.__sinval;
      float *v57 = v59.__sinval;
      v57 += 3;
      v56 += 4;
    }
    while (v56 != 864);
    if (a1[76] == 2)
    {
      vDSP_Length __P = a1[2];
      if (216 * __P)
      {
        unint64_t v62 = (char *)operator new(4 * (216 * __P));
        bzero(v62, 4 * (216 * __P));
        uint64_t v63 = &v62[4 * (216 * __P)];
      }
      else
      {
        unint64_t v62 = 0;
        uint64_t v63 = 0;
      }
      vDSP_mmul(*((const float **)a1 + 46), 1, __B, 1, (float *)v62, 1, __P, 0xD8uLL, __P);
      if (v63 != v62) {
        memcpy(__B, v62, v63 - v62);
      }
      if (v62) {
        operator delete(v62);
      }
    }
    float __A = 0.0046296;
    int v65 = (const float *)*((void *)a1 + 10);
    int v64 = (const float *)*((void *)a1 + 11);
    int v114 = 0;
    size_t v66 = (char *)v64 - (char *)v65;
    if (v64 == v65)
    {
      uint64_t v67 = 0;
    }
    else
    {
      if ((v66 & 0x8000000000000000) != 0) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v67 = (float *)operator new((char *)v64 - (char *)v65);
      int v114 = v67;
      bzero(v67, v66);
    }
    vDSP_svdiv(&__A, v65, 1, v67, 1, a1[2]);
    for (uint64_t i = 0; i != 216; ++i)
      vDSP_vmul(v114, 1, &__B[i], 216, &__B[i], 216, a1[2]);
    if (a4 == 1)
    {
      uint64_t v69 = a1[2];
      uint64_t v70 = (216 * v69);
      unint64_t v107 = v53;
      if (v70)
      {
        float v71 = (char *)operator new(4 * v70);
        bzero(v71, 4 * v70);
        float __C = (float *)operator new(4 * v70);
        bzero(__C, 4 * v70);
      }
      else
      {
        float v71 = 0;
        float __C = 0;
      }
      uint64_t v112 = (char *)operator new(0x2D900uLL);
      bzero(v112, 0x2D900uLL);
      if (216 * a1[5])
      {
        size_t v74 = 864 * a1[5];
        uint64_t v75 = (char *)operator new(v74);
        bzero(v75, v74);
        long long v76 = &v75[v74];
      }
      else
      {
        uint64_t v75 = 0;
        long long v76 = 0;
      }
      if (v70) {
        memcpy(v71, __B, 4 * v70);
      }
      float __D = (float *)v75;
      if (v69)
      {
        uint64_t v82 = operator new(4 * v69);
        bzero(v82, 4 * v69);
      }
      else
      {
        uint64_t v82 = 0;
      }
      unsigned int v83 = *a1;
      float v84 = cosf(2.4068 / (float)((float)*a1 + 1.51));
      uint64_t v85 = 0;
      unsigned int v86 = 1;
      do
      {
        *(_DWORD *)uint64_t v144 = HOA::legendre(v85, 0, v84);
        vDSP_vfill((const float *)v144, (float *)v82 + (v85 * v85), 1, v86);
        uint64_t v85 = (HOA *)(v85 + 1);
        v86 += 2;
      }
      while (v85 <= v83);
      long long v87 = v112;
      vDSP_vmul((const float *)v82, 1, *((const float **)a1 + 10), 1, (float *)v82, 1, a1[2]);
      vDSP_vmul((const float *)v82, 1, *((const float **)a1 + 10), 1, (float *)v82, 1, a1[2]);
      for (uint64_t j = 0; j != 864; j += 4)
        vDSP_vmul((const float *)v82, 1, (const float *)&v71[j], 216, (float *)&v71[j], 216, a1[2]);
      vDSP_mtrans((const float *)v71, 1, __C, 1, 0xD8uLL, a1[2]);
      vDSP_mmul(__C, 1, __B, 1, (float *)v112, 1, 0xD8uLL, 0xD8uLL, a1[2]);
      vDSP_vsq((const float *)v112, 1, (float *)v112, 1, 0xB640uLL);
      uint64_t v89 = 0;
      float v125 = 0.0;
      do
      {
        *(_DWORD *)uint64_t v144 = 0;
        vDSP_sve((const float *)&v112[v89], 216, (float *)v144, 0xD8uLL);
        float v90 = v125;
        if (*(float *)v144 > v125)
        {
          float v125 = *(float *)v144;
          float v90 = *(float *)v144;
        }
        v89 += 4;
      }
      while (v89 != 864);
      if (v90 == 0.0) {
        float v91 = 1.0;
      }
      else {
        float v91 = 1.0 / v90;
      }
      float v125 = v91;
      vDSP_vsmul((const float *)v112, 1, &v125, (float *)v112, 1, 0xB640uLL);
      uint64_t v92 = v76 - v75;
      vDSP_vclr((float *)v75, 1, v92 >> 2);
      unint64_t v106 = v92;
      uint64_t v93 = a1[5];
      if (v93)
      {
        size_t v94 = 4 * v93;
        float v95 = (char *)operator new(4 * v93);
        bzero(v95, v94);
        float v96 = &v95[v94];
      }
      else
      {
        float v95 = 0;
        float v96 = 0;
      }
      uint64_t v97 = 0;
      vDSP_Length v98 = (v96 - v95) >> 2;
      while (1)
      {
        uint64_t v18 = VBAP::calculateVBAPGains((VBAP *)buf, (float32x2_t *)&v111[3 * v97], (float *)v95);
        if (v18) {
          break;
        }
        vDSP_vsq((const float *)v95, 1, (float *)v95, 1, v98);
        unint64_t v99 = a1[5];
        if (v99)
        {
          unint64_t v100 = 0;
          float v101 = (const float *)v95;
          __float2 v102 = __D;
          do
          {
            vDSP_vsma((const float *)&v112[4 * v97], 216, v101, v102, v99, v102, v99, 0xD8uLL);
            ++v100;
            unint64_t v99 = a1[5];
            ++v102;
            ++v101;
          }
          while (v100 < v99);
        }
        ++v97;
        long long v87 = v112;
        if (v97 == 216)
        {
          *(_DWORD *)uint64_t v144 = v106 >> 2;
          vvsqrtf(__D, __D, (const int *)v144);
          vDSP_mmul(__B, 1, __D, 1, *((float **)a1 + 7), 1, a1[2], a1[5], 0xD8uLL);
          uint64_t v18 = 0;
          goto LABEL_124;
        }
      }
      if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v144 = 136315906;
        *(void *)&v144[4] = "HOA.cpp";
        *(_WORD *)&v144[12] = 1024;
        *(_DWORD *)&v144[14] = 924;
        *(_WORD *)&v144[18] = 2080;
        *(void *)&v144[20] = "createALLRAD2";
        __int16 v145 = 1024;
        int v146 = 924;
        _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; VBAP calculation error",
          v144,
          0x22u);
      }
LABEL_124:
      if (v95) {
        operator delete(v95);
      }
      if (v82) {
        operator delete(v82);
      }
      int v23 = (void **)(a1 + 14);
      float v53 = v107;
      if (__D) {
        operator delete(__D);
      }
      operator delete(v87);
      unsigned int v78 = v111;
      if (__C) {
        operator delete(__C);
      }
    }
    else
    {
      HOA::applyDecoderWeighting(a1, &__p, 0xD8u, a5);
      vDSP_vclr(*((float **)a1 + 7), 1, a1[2] * a1[5]);
      uint64_t v72 = a1[5];
      if (v72)
      {
        size_t v73 = 4 * v72;
        float v71 = (char *)operator new(4 * v72);
        bzero(v71, v73);
      }
      else
      {
        float v71 = 0;
      }
      uint64_t v77 = 0;
      unsigned int v78 = v111;
      while (1)
      {
        uint64_t v18 = VBAP::calculateVBAPGains((VBAP *)buf, (float32x2_t *)&v111[3 * v77], (float *)v71);
        if (v18) {
          break;
        }
        unint64_t v79 = a1[5];
        if (v79)
        {
          uint64_t v80 = 0;
          for (unint64_t k = 0; k < v79; ++k)
          {
            vDSP_vsma(&__B[v77], 216, (const float *)&v71[v80], (const float *)(*((void *)a1 + 7) + v80), v79, (float *)(*((void *)a1 + 7) + v80), v79, a1[2]);
            unint64_t v79 = a1[5];
            v80 += 4;
          }
        }
        if (++v77 == 216)
        {
          uint64_t v18 = 0;
          goto LABEL_132;
        }
      }
      if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v144 = 136315906;
        *(void *)&v144[4] = "HOA.cpp";
        *(_WORD *)&v144[12] = 1024;
        *(_DWORD *)&v144[14] = 863;
        *(_WORD *)&v144[18] = 2080;
        *(void *)&v144[20] = "createALLRAD";
        __int16 v145 = 1024;
        int v146 = 863;
        _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; VBAP calculation error",
          v144,
          0x22u);
      }
    }
LABEL_132:
    if (v71) {
      operator delete(v71);
    }
    if (v114) {
      operator delete(v114);
    }
    operator delete(v78);
    operator delete(v109);
    operator delete(v53);
    if (__B) {
      operator delete(__B);
    }
    VBAP::~VBAP((VBAP *)buf);
    LODWORD(v3std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = *a1;
    goto LABEL_142;
  }
  if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t v144 = 136315906;
    *(void *)&v144[4] = "HOA.cpp";
    *(_WORD *)&v144[12] = 1024;
    *(_DWORD *)&v144[14] = 982;
    *(_WORD *)&v144[18] = 2080;
    *(void *)&v144[20] = "createDecoder";
    __int16 v145 = 1024;
    int v146 = 982;
    _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; VBAP object was not initialized",
      v144,
      0x22u);
  }
  VBAP::~VBAP((VBAP *)buf);
  return 4294967246;
}

void sub_21B541260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *__p, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  if (v34)
  {
    operator delete(v34);
    if (!__p)
    {
LABEL_4:
      operator delete(a17);
      if (a13) {
        operator delete(a13);
      }
      if (v33) {
        operator delete(v33);
      }
      if (a19) {
        operator delete(a19);
      }
      operator delete(a16);
      operator delete(a14);
      operator delete(a12);
      if (a23) {
        operator delete(a23);
      }
      VBAP::~VBAP((VBAP *)&a33);
      _Unwind_Resume(a1);
    }
  }
  else if (!__p)
  {
    goto LABEL_4;
  }
  operator delete(__p);
  goto LABEL_4;
}

uint64_t HOA::createSphericalGridDecoder(unsigned int *a1, int a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)a1 + 28))
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1 + 128, *((char **)a1 + 26), *((void *)a1 + 27), (uint64_t)(*((void *)a1 + 27) - *((void *)a1 + 26)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1 + 152, *((char **)a1 + 29), *((void *)a1 + 30), (uint64_t)(*((void *)a1 + 30) - *((void *)a1 + 29)) >> 2);
    long long v5 = (void **)(a1 + 46);
    uint64_t v4 = (char *)*((void *)a1 + 23);
    unsigned int v6 = a1[6];
    a1[5] = v6;
    unint64_t v7 = a1[2] * v6;
    unint64_t v8 = (uint64_t)(*((void *)a1 + 24) - (void)v4) >> 2;
    if (v7 <= v8)
    {
      if (v7 < v8) {
        *((void *)a1 + 24) = &v4[4 * v7];
      }
    }
    else
    {
      std::vector<float>::__append((char **)a1 + 23, v7 - v8);
      uint64_t v4 = (char *)*v5;
    }
    HOA::sphericalHarmonics(*((HOA **)a1 + 26), *((const float **)a1 + 29), (const float *)((uint64_t)(*((void *)a1 + 27) - *((void *)a1 + 26)) >> 2), (uint64_t)v4, (float *)*a1);
    if (a1[44] - 1 <= 1)
    {
      LODWORD(v1std::unique_ptr<IR::PersonalizedIRData::Implementation>::reset[abi:ne180100]((id **)this, 0) = a1[5];
      if (v10)
      {
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        do
        {
          vDSP_vmul(*((const float **)a1 + 32), 1, (const float *)(*((void *)a1 + 23) + v11), v10, (float *)(*((void *)a1 + 23) + v11), v10, v10);
          ++v12;
          unint64_t v10 = a1[5];
          v11 += 4;
        }
        while (v12 < v10);
      }
      *(float *)buf = (float)v10 * 0.079577;
      vDSP_vsmul(*((const float **)a1 + 23), 1, (const float *)buf, *((float **)a1 + 23), 1, (uint64_t)(*((void *)a1 + 24) - *((void *)a1 + 23)) >> 2);
    }
    uint64_t v13 = *((void *)a1 + 7);
    unint64_t v14 = (uint64_t)(*((void *)a1 + 24) - *((void *)a1 + 23)) >> 2;
    unint64_t v15 = (*((void *)a1 + 8) - v13) >> 2;
    if (v14 <= v15)
    {
      if (v14 < v15) {
        *((void *)a1 + 8) = v13 + 4 * v14;
      }
    }
    else
    {
      std::vector<float>::__append((char **)a1 + 7, v14 - v15);
    }
    if (a1[76] == 2)
    {
      unint64_t v17 = (const float *)*((void *)a1 + 23);
      uint64_t v16 = (const float *)*((void *)a1 + 24);
      memset(buf, 0, 24);
      size_t v18 = (char *)v16 - (char *)v17;
      if (v16 == v17)
      {
        unint64_t v19 = 0;
      }
      else
      {
        if ((v18 & 0x8000000000000000) != 0) {
          std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v19 = operator new((char *)v16 - (char *)v17);
        bzero(v19, v18);
        v18 += (size_t)v19;
      }
      vDSP_mmul(*((const float **)a1 + 46), 1, v17, 1, (float *)v19, 1, a1[2], a1[6], a1[2]);
      if ((void *)v18 != v19) {
        memmove(*v5, v19, v18 - (void)v19);
      }
      if (v19) {
        operator delete(v19);
      }
    }
    float __A = 1.0 / (float)a1[6];
    uint64_t v21 = (const float *)*((void *)a1 + 10);
    vDSP_Length v20 = (const float *)*((void *)a1 + 11);
    memset(buf, 0, 24);
    size_t v22 = (char *)v20 - (char *)v21;
    if (v20 == v21)
    {
      int v23 = 0;
    }
    else
    {
      if ((v22 & 0x8000000000000000) != 0) {
        std::vector<std::vector<float>>::__throw_length_error[abi:ne180100]();
      }
      int v23 = operator new((char *)v20 - (char *)v21);
      bzero(v23, v22);
    }
    vDSP_svdiv(&__A, v21, 1, (float *)v23, 1, a1[2]);
    LODWORD(v24) = a1[6];
    if (v24)
    {
      uint64_t v25 = 0;
      unint64_t v26 = 0;
      do
      {
        vDSP_vmul((const float *)v23, 1, (const float *)(*((void *)a1 + 23) + v25), v24, (float *)(*((void *)a1 + 7) + v25), v24, a1[2]);
        ++v26;
        unint64_t v24 = a1[6];
        v25 += 4;
      }
      while (v26 < v24);
    }
    HOA::applyDecoderWeighting(a1, (void *)a1 + 7, v24, a2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1 + 184, *((char **)a1 + 7), *((void *)a1 + 8), (uint64_t)(*((void *)a1 + 8) - *((void *)a1 + 7)) >> 2);
    if (a1[1] != *a1)
    {
      unint64_t v27 = a1[6] * a1[3];
      int v30 = 0;
      uint64_t v28 = *((void *)a1 + 7);
      unint64_t v29 = (*((void *)a1 + 8) - v28) >> 2;
      if (v27 <= v29)
      {
        if (v27 < v29) {
          *((void *)a1 + 8) = v28 + 4 * v27;
        }
      }
      else
      {
        std::vector<float>::__append((void **)a1 + 7, v27 - v29, &v30);
      }
    }
    if (v23) {
      operator delete(v23);
    }
    return 0;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "HOA.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1051;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = "createSphericalGridDecoder";
      __int16 v33 = 1024;
      int v34 = 1051;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized",
        buf,
        0x22u);
    }
    return 4294967246;
  }
}

void sub_21B5418B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (!v12) {
    _Unwind_Resume(exception_object);
  }
  operator delete(v12);
  _Unwind_Resume(exception_object);
}

uint64_t HOA::decodeData(HOA *this, const float *__A, float *__C, vDSP_Length __M)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 28))
  {
    long long v5 = (const float *)*((void *)this + 7);
    if (v5 != *((const float **)this + 8)) {
      vDSP_mmul(__A, 1, v5, 1, __C, 1, __M, *((unsigned int *)this + 5), *((unsigned int *)this + 3));
    }
    return 0;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      unint64_t v8 = "HOA.cpp";
      __int16 v9 = 1024;
      int v10 = 1452;
      __int16 v11 = 2080;
      unint64_t v12 = "decodeData";
      __int16 v13 = 1024;
      int v14 = 1452;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized",
        buf,
        0x22u);
    }
    return 4294967246;
  }
}

uint64_t HOA::encodeData(HOA *this, const float *__A, float *__C, vDSP_Length __M)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 28))
  {
    long long v5 = (const float *)*((void *)this + 4);
    if (v5 != *((const float **)this + 5)) {
      vDSP_mmul(__A, 1, v5, 1, __C, 1, __M, *((unsigned int *)this + 3), *((unsigned int *)this + 4));
    }
    return 0;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      unint64_t v8 = "HOA.cpp";
      __int16 v9 = 1024;
      int v10 = 1477;
      __int16 v11 = 2080;
      unint64_t v12 = "encodeData";
      __int16 v13 = 1024;
      int v14 = 1477;
      _os_log_impl(&dword_21B4DD000, MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: HOA Error; HOA object was not initialized",
        buf,
        0x22u);
    }
    return 4294967246;
  }
}

uint64_t HOA::getNormalization(HOA *this)
{
  if ((this & 0xFFFF0000) == 0xBE0000) {
    return 1;
  }
  else {
    return 2 * ((this & 0xFFFF0000) != 12517376);
  }
}

uint64_t SincKernelFactory::ReferenceSincKernel(SincKernelFactory *this, int a2, int a3, double a4, double a5)
{
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (!v5) {
LABEL_9:
  }
    operator new();
  unint64_t v6 = 0;
  unint64_t v7 = v5 >> 3;
  unsigned int v8 = 1;
  while (1)
  {
    uint64_t v9 = *(void *)(*(void *)this + 8 * v6);
    if (*(double *)(v9 + 32) == a5
      && *(double *)(v9 + 24) == a4
      && *(_DWORD *)(v9 + 12) == a2
      && *(_DWORD *)(v9 + 16) == a3)
    {
      break;
    }
    unint64_t v6 = v8++;
    if (v7 <= v6) {
      goto LABEL_9;
    }
  }
  ++*(_DWORD *)(v9 + 8);
  return v9;
}

void sub_21B54251C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  std::__split_buffer<KaiserWindow>::~__split_buffer((uint64_t)&a30);
  os_unfair_lock_unlock((os_unfair_lock_t)&GetKaiser(unsigned int,double)::sKaiserWindows);
  MEMORY[0x21D48F780](v30, 0x1080C4003DAF236);
  _Unwind_Resume(a1);
}

void *SincKernelFactory::ReleaseSincKernel(void *result, uint64_t a2)
{
  if (a2)
  {
    int v3 = *(_DWORD *)(a2 + 8) - 1;
    *(_DWORD *)(a2 + 8) = v3;
    if (!v3)
    {
      uint64_t v4 = result;
      uint64_t v6 = *result;
      uint64_t v5 = result[1];
      if (v5 != *result)
      {
        unint64_t v7 = 0;
        unsigned int v8 = 1;
        do
        {
          if (*(void *)(v6 + 8 * v7) == a2)
          {
            uint64_t v9 = v6 + 8 * v7;
            uint64_t v10 = v5 - (v9 + 8);
            if (v5 != v9 + 8) {
              memmove((void *)(v6 + 8 * v7), (const void *)(v9 + 8), v5 - (v9 + 8));
            }
            v4[1] = v9 + v10;
            free(*(void **)a2);
            JUMPOUT(0x21D48F780);
          }
          unint64_t v7 = v8++;
        }
        while ((v5 - *result) >> 3 > v7);
      }
    }
  }
  return result;
}

void KaiserWindow::KaiserWindow(KaiserWindow *this, int a2, double a3)
{
  uint64_t v6 = 0;
  *(_DWORD *)this = a2;
  *((double *)this + 1) = a3;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  if (a2 != -1)
  {
    size_t v7 = (a2 + 1);
    uint64_t v6 = operator new(v7 * 4);
    *((void *)this + 2) = v6;
    *((void *)this + 4) = &v6[v7];
    bzero(v6, v7 * 4);
    *((void *)this + 3) = &v6[v7];
  }
  if (a3 >= 50.0)
  {
    double v8 = a3 * 0.1102 + -0.95874;
  }
  else
  {
    double v8 = 0.0;
    if (a3 > 21.0) {
      double v8 = (a3 + -21.0) * 0.07886 + pow(a3 + -21.0, 0.4) * 0.5842;
    }
  }
  double v9 = fabs(v8);
  uint64_t v10 = &qword_21B551000;
  __int16 v11 = &qword_21B551000;
  double v28 = v8;
  if (v9 >= 3.75)
  {
    double v14 = 3.75 / v9;
    long double v15 = exp(v9);
    __int16 v11 = &qword_21B551000;
    uint64_t v10 = &qword_21B551000;
    double v8 = v28;
    double v13 = ((((((((v14 * 0.00392377 + -0.01647633) * v14 + 0.02635537) * v14 + -0.02057706) * v14 + 0.00916281) * v14
            + -0.00157565)
           * v14
           + 0.00225319)
          * v14
          + 0.01328592)
         * v14
         + 0.39894228)
        * v15
        / sqrt(v9);
    if (!a2) {
      goto LABEL_16;
    }
  }
  else
  {
    double v12 = v8 * 0.266666667 * (v8 * 0.266666667);
    double v13 = (((((v12 * 0.0045813 + 0.0360768) * v12 + 0.2659732) * v12 + 1.2067492) * v12 + 3.0899424) * v12 + 3.5156229)
        * v12
        + 1.0;
    if (!a2) {
      goto LABEL_16;
    }
  }
  uint64_t v16 = 0;
  double v17 = -1.0;
  double v18 = *((double *)v10 + 114);
  double v19 = *((double *)v11 + 115);
  double v20 = 1.0 / v13;
  do
  {
    double v25 = sqrt(-(v17
               + ((double)v16 - (double)((a2 - 1) >> 1))
               * (1.0
                / (double)((a2 - 1) >> 1))
               * (((double)v16 - (double)((a2 - 1) >> 1))
                * (1.0
                 / (double)((a2 - 1) >> 1)))))
        * v8;
    double v26 = fabs(v25);
    if (v26 >= 3.75)
    {
      long double v22 = exp(v26);
      double v17 = -1.0;
      double v8 = v28;
      double v21 = 3.75 / v26;
      double v23 = (v19
           + (v18
            + ((((((v21 * 0.00392377 + -0.01647633) * v21 + 0.02635537) * v21 + -0.02057706) * v21 + 0.00916281) * v21
              + -0.00157565)
             * v21
             + 0.00225319)
            * v21)
           * v21)
          * v22
          / sqrt(v26);
    }
    else
    {
      double v27 = v25 * 0.266666667 * (v25 * 0.266666667);
      double v23 = (((((v27 * 0.0045813 + 0.0360768) * v27 + 0.2659732) * v27 + 1.2067492) * v27 + 3.0899424) * v27 + 3.5156229)
          * v27
          + 1.0;
    }
    float v24 = v23 * v20;
    *(float *)&v6[++v16] = v24;
  }
  while (a2 != v16);
LABEL_16:
  *uint64_t v6 = 0;
}

uint64_t std::__split_buffer<KaiserWindow>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        uint64_t v4 = v2 - 40;
        *(void *)(a1 + 16) = v2 - 40;
        uint64_t v5 = *(void **)(v2 - 24);
        if (!v5) {
          break;
        }
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
        uint64_t v2 = *(void *)(a1 + 16);
        if (v2 == v3) {
          goto LABEL_6;
        }
      }
      v2 -= 40;
    }
    while (v4 != v3);
  }
LABEL_6:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<KaiserWindow>,std::reverse_iterator<KaiserWindow*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 16) + 8);
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 8);
    while (v3 != v4)
    {
      uint64_t v5 = *(void **)(v3 + 16);
      if (v5)
      {
        *(void *)(v3 + 24) = v5;
        operator delete(v5);
      }
      v3 += 40;
    }
  }
  return a1;
}

uint64_t IR::FFTFilterTranspose::FFTFilterTranspose(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t IR::FFTFilterTranspose::FFTFilterTranspose(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(a1);
}

void IR::IRData::Implementation::readIRPlist()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_9(&dword_21B4DD000, v0, v1, "IRData::%s: rawPlistLength %u is larger than remaining file size %zu", v2, v3, v4);
}

void IR::IRData::Implementation::readIRPlist(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: failed to read rawPlistLength", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::readIRPlist(int a1, int a2, NSObject *a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v3 = 136315650;
  uint64_t v4 = "readIRPlist";
  __int16 v5 = 1024;
  int v6 = a1;
  __int16 v7 = 1024;
  int v8 = a2;
  OUTLINED_FUNCTION_8(&dword_21B4DD000, a3, (uint64_t)a3, "IRData::%s: %u bytes read, expected %u", (uint8_t *)&v3);
}

void IR::IRData::Implementation::Implementation(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: unable to create user-defined size dimension", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Filter Data Size - Delay Size Mismatch", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Dimension Size Mismatch", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Fractional Filter Length", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: unable to load IR file", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: unable to load IR file header", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: IR file's native sample rate is zero.", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: Invalid filter length.", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: length of fadeout is greater than filter", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: start of fadeout is before window fadein", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: NumChannels was either not specified or read as 0", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: failed to read float value from file", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: failed to read float dimensionVal from file", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: Triangulation dictionary found but is empty/defective", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: Triangulation dictionary found but failed to load", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: coefficient format not specified", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: start of fadeout is beyond end of filter", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: window start sample beyond end of filter", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::canCreateSizeDimension(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
    a5,
    a6,
    a7,
    a8,
    2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: unable to create user-defined size dimension; size dimension already exists in data",
    a5,
    a6,
    a7,
    a8,
    2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: unable to create user-defined size dimension; size vector has values not in the range [0 1]",
    a5,
    a6,
    a7,
    a8,
    2u);
}

void IR::IRData::Implementation::createSizeDimension()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_11();
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "IRData::%s: Size dimension generation (including triangulation) took %.2f ms", (uint8_t *)v1, 0x16u);
}

{
  os_log_t v0;
  int v1[6];
  uint64_t v2;

  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_11();
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "IRData::%s: VBAP triangulation took %.2f ms", (uint8_t *)v1, 0x16u);
}

void IR::IRData::Implementation::createSizeDimension(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void IR::IRData::Implementation::Implementation()
{
  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  int v2 = 136315394;
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_21B4DD000, v0, v1, "IRData::%s: unsupported coefficient format: %s", v2, v3);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  int v2 = 136315650;
  OUTLINED_FUNCTION_6();
  OUTLINED_FUNCTION_10(&dword_21B4DD000, v0, v1, "IRData::%s: %zu bytes remaining in file but need %zu", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_7(&dword_21B4DD000, v0, v1, "IRData::%s: failed to read %d int16 values from file", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_7(&dword_21B4DD000, v0, v1, "IRData::%s: failed to read %d float values from file", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_7(&dword_21B4DD000, v0, v1, "IRData::%s: duplicate coordinate %u found in Dimensions array", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  uint64_t v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_9(&dword_21B4DD000, v0, v1, "IRData::%s: %u bytes to skip, but only %zu bytes remaining in the file.", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  const char *v3;

  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  int v2 = 136315394;
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_21B4DD000, v0, v1, "IRData::%s: unsupported delay format: %s", v2, v3);
}

void IR::IRData::Implementation::Implementation(int *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v4 = 136315650;
  __int16 v5 = "Implementation";
  __int16 v6 = 1024;
  int v7 = v3;
  __int16 v8 = 1024;
  int v9 = 9;
  OUTLINED_FUNCTION_8(&dword_21B4DD000, a2, a3, "IRData::%s: size of Dimensions array is %u but this should never be greater than %u", (uint8_t *)&v4);
}

void IR::IRData::Implementation::Implementation(int *a1, int *a2, NSObject *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v4 = *a2;
  int v5 = 136315650;
  __int16 v6 = "Implementation";
  __int16 v7 = 1024;
  int v8 = v3;
  __int16 v9 = 1024;
  int v10 = v4;
  OUTLINED_FUNCTION_8(&dword_21B4DD000, a3, (uint64_t)a3, "IRData::%s: failed to initialize and store coeffs with filterCFIndex Length = %d, partitionCFIndex Length = %d", (uint8_t *)&v5);
}

void IR::IRData::Implementation::createSoundProfilePack(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void IR::IRData::Implementation::createSerializedIRData(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Filter data not created, XML creation issue", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Invalid IR Data", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::createSoundProfileMetaDataDictionary(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: SoundProfile is not well-constructed.", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::getSoundProfileVersion(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: SoundProfile is not well-constructed.", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::createDictionaryIRData(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void IR::IRData::Implementation::createSerializedIRDataWithNoise(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: unable to load input data header", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: invalid filter length.", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TotalNumCoordinates was either not specified or read as 0", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: NumChannels was either not specified or read as 0", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::createSerializedIRDataWithNoise()
{
  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  int v2 = 136315394;
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_21B4DD000, v0, v1, "IRData::%s: coefficient format '%s' is not supported.", v2, v3);
}

{
  __int16 v0;
  NSObject *v1;
  uint64_t v2;
  int v3[4];
  __int16 v4;
  int v5;
  uint64_t v6;

  __int16 v6 = *MEMORY[0x263EF8340];
  v3[0] = 136315650;
  OUTLINED_FUNCTION_4();
  int v4 = v0;
  int v5 = 9;
  OUTLINED_FUNCTION_8(&dword_21B4DD000, v1, v2, "IRData::%s: size of Dimensions array is %u but this should never be greater than %u", (uint8_t *)v3);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  int v2 = 136315650;
  OUTLINED_FUNCTION_6();
  OUTLINED_FUNCTION_10(&dword_21B4DD000, v0, v1, "IRData::%s: %zu bytes remaining in file but need %zu", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  const char *v3;

  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  int v2 = 136315394;
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_21B4DD000, v0, v1, "IRData::%s: unsupported delay format: %s", v2, v3);
}

void IR::IRData::Implementation::createNoisySoundProfilePack(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: SoundProfile is not well-constructed.", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::insertIRDataInTree()
{
}

void IR::VBAPTriangulationKernel::VBAPTriangulationKernel(void **a1, void **a2, void *a3)
{
  int v5 = *a1;
  if (v5)
  {
    a3[6] = v5;
    operator delete(v5);
  }
  __int16 v6 = *a2;
  if (*a2)
  {
    a3[3] = v6;
    operator delete(v6);
  }
  __int16 v7 = (std::__shared_weak_count *)a3[1];
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

void IR::IRData::Implementation::getInterpolatedTimeDomainCoeffs<std::vector<float>>()
{
}

{
  __assert_rtn("getInterpolatedTimeDomainCoeffs", "IRDataInterpolation.cpp", 167, "ioCoefficients.size() >= inChans.size()");
}

{
  __assert_rtn("getInterpolatedTimeDomainCoeffs", "IRDataInterpolation.cpp", 166, "ioCoefficients.size() == ioDelays.size()");
}

{
  __assert_rtn("getInterpolatedTimeDomainCoeffs", "IRDataInterpolation.cpp", 162, "!mVBAPKernels.empty()");
}

void IR::IRData::Implementation::getInterpolatedCoeffs()
{
}

{
  __assert_rtn("getInterpolatedCoeffs", "IRDataInterpolation.cpp", 42, "ioFilterKernels.size() >= inChans.size()");
}

{
  __assert_rtn("getInterpolatedCoeffs", "IRDataInterpolation.cpp", 41, "ioFilterKernels.size() == ioDelays.size()");
}

{
  __assert_rtn("getInterpolatedCoeffs", "IRDataInterpolation.cpp", 37, "!mVBAPKernels.empty()");
}

void IR::HOA2BinauralIRRenderer::setEnvironment(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "HOA2BinauralIRRenderer::%s: Invalid number of HOA channels", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "HOA2BinauralIRRenderer::%s: Invalid HRIR IRData object", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::loadTriangulationData(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriVertices has wrong data type", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriAssignment data of wrong type", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: triangle lookup bins have insufficient data", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: triangle lookup bins have wrong amount of data", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: triangle lookup bins must have at least one element", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriBinLengths and/or TriBinSerial array not of proper size", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriBinLengths and/or TriBinSerial not array type", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriBinLengths and/or TriBinSerial key missing from triangulation dictionary", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: wrong number of TriAssignment data points", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriAssignment key missing from triangulation dictionary", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriVertices array wrong length", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: TriVertices key missing from triangulation dictionary", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "IRData::%s: NumTriangulations key missing from triangulation dictionary", a5, a6, a7, a8, 2u);
}

void IR::IRData::Implementation::initVBAPTriangulation(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void AudioDSP::Core::HeadTracker::Implementation::ConnectRM()
{
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Invalid head-tracking mode.", v2, v3, v4, v5, v6);
}

void AudioDSP::Core::HeadTracker::Implementation::SetBluetoothLowLatencyMode()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_3_0();
  uint64_t v2 = "SetBluetoothLowLatencyMode";
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "[%s|%s] Host disallowed accessing HAL APIs. Bluetooth latency mode cannot be updated.", v1, 0x16u);
}

void AudioDSP::Core::HeadTracker::UnregisterUserChoiceListener()
{
  OUTLINED_FUNCTION_2_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_0();
  uint64_t v2 = "UnregisterUserChoiceListener";
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "[%s|%s] SpatialConfig listener is already unregistered.", v1, 0x16u);
}

void AudioDSP::Core::HeadTracker::ConnectRM()
{
  OUTLINED_FUNCTION_2_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Device doesn't support head tracking.", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Head tracking is disabled on the device.", v2, v3, v4, v5, v6);
}

void AudioDSP::Core::HeadTracker::RegisterUserChoiceListener()
{
  OUTLINED_FUNCTION_2_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Failed to register SpatialConfig listener. Unknown/unsupported device ID.", v2, v3, v4, v5, v6);
}

void ___ZL22getRMMediaSessionClassv_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  ___ZL29getRMMediaSessionOptionsClassv_block_invoke_cold_1(v0);
}

void ___ZL29getRMMediaSessionOptionsClassv_block_invoke_cold_1()
{
}

void caulk::recursive_mutex_adapter<caulk::pooled_semaphore_mutex>::unlock()
{
}

void IR::DataResampler<float>::Initialize(int a1, NSObject *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v2 = 136315906;
  uint64_t v3 = "Initialize";
  __int16 v4 = 1024;
  int v5 = a1;
  __int16 v6 = 1024;
  int v7 = 0;
  __int16 v8 = 1024;
  int v9 = 127;
  _os_log_error_impl(&dword_21B4DD000, a2, OS_LOG_TYPE_ERROR, "IRDataResampler::%s: Invalid configuration data: Quality = %u is out of bound, needs to be within [%u, %u]", (uint8_t *)&v2, 0x1Eu);
}

void IR::DataResampler<float>::Initialize(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  int v2 = "Initialize";
  _os_log_error_impl(&dword_21B4DD000, log, OS_LOG_TYPE_ERROR, "IRDataResampler::%s: SRC actual input consumed = 0", (uint8_t *)&v1, 0xCu);
}

void IR::DelayLine::processPolyphaseQ22_10()
{
  __assert_rtn("processPolyphaseQ22_10", "DelayLine.cpp", 216, "inNumFramesToProcess + padOffset <= mDelayLine.size()");
}

{
  __assert_rtn("processPolyphaseQ22_10", "DelayLine.cpp", 206, "phaseIndex < mFractionalPhases");
}

void IR::DelayLine::setDelay()
{
}

void IR::DelayLine::process()
{
}

{
  __assert_rtn("process", "DelayLine.cpp", 594, "phaseIndex < mFractionalPhases");
}

{
  __assert_rtn("process", "DelayLine.cpp", 655, "numSubBlocksRemaining > 0");
}

{
  __assert_rtn("process", "DelayLine.cpp", 612, "inNumFramesToProcess <= delayLineLen - padOffset");
}

{
  __assert_rtn("process", "DelayLine.cpp", 703, "inNumFramesToProcess < delayLineLen - padOffset");
}

void IR::getFilePtr(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: unable to create file path from URL", a5, a6, a7, a8, 2u);
}

void IR::getFilePtr()
{
  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "%s: attempting to open a directory: %s", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_4_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "%s: invalid file handle for %s", v2, v3, v4, v5, 2u);
}

void IR::getFilePtr(int a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = 136315394;
  uint64_t v3 = "getFilePtr";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl(&dword_21B4DD000, a2, OS_LOG_TYPE_ERROR, "%s: error %d getting file status", (uint8_t *)&v2, 0x12u);
}

void IR::IRDataLoader::Implementation::create()
{
  OUTLINED_FUNCTION_0_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "%s%s: ERROR: Issue creating the IR data object", v2, v3, v4, v5, v6);
}

void IR::IRDataLoader::Implementation::loadPrivate(uint64_t *a1, uint64_t a2, NSObject *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = (uint64_t *)*a1;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  int v6 = 136315650;
  int v7 = v4;
  __int16 v8 = 2080;
  int v9 = "loadPrivate";
  __int16 v10 = 2080;
  uint64_t v11 = v5;
  _os_log_error_impl(&dword_21B4DD000, a3, OS_LOG_TYPE_ERROR, "%s%s: IRData construction error: %s", (uint8_t *)&v6, 0x20u);
}

void IR::IRDataLoader::Implementation::loadPrivate()
{
  OUTLINED_FUNCTION_0_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "%s%s: Invalid personalized HRIR data source.", v2, v3, v4, v5, v6);
}

{
  os_log_t v0;
  uint8_t v1[40];

  OUTLINED_FUNCTION_0_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_5_0();
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "%s%s: Fetched personalized HRIR type %u from cache", v1, 0x1Cu);
}

void IR::IRDataLoader::Implementation::addIRDataToCache()
{
  OUTLINED_FUNCTION_0_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "%s%s: ERROR: Trying to save IRData with an unrelated IRDataAttributes.", v2, v3, v4, v5, v6);
}

void IR::IRDataLoader::Implementation::loadAndDecode()
{
  OUTLINED_FUNCTION_0_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "%s%s: invalid decoder layout tag = 0", v2, v3, v4, v5, v6);
}

{
  os_log_t v0;
  uint8_t v1[40];

  OUTLINED_FUNCTION_0_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_5_0();
  _os_log_error_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_ERROR, "%s%s: could not generate panning IR data for layout tag %u", v1, 0x1Cu);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_0_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "%s%s: could not load decoder IR data: ", v2, v3, v4, v5, v6);
}

void IR::IRDataLoader::Implementation::loadAndDecode(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void IR::IRDataLoader::writeIRFile(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Empty Data Vectors; Filter File Not Written",
    a5,
    a6,
    a7,
    a8,
    2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Filter File Not Written, XML creation issue", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Filter Data Size - Delay Size Mismatch: Filter File Not Written", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Dimension Size Mismatch; Filter File Not Written",
    a5,
    a6,
    a7,
    a8,
    2u);
}

{
  OUTLINED_FUNCTION_0(&dword_21B4DD000, a1, a3, "%s: ERROR: Fractional Filter Length; Filter File Not Written",
    a5,
    a6,
    a7,
    a8,
    2u);
}

void IR::IRDataLoader::writeIRFile()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_4_0();
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "%s: Filter Written: %s", (uint8_t *)v1, 0x16u);
}

void IR::MatrixResampler<float>::Initialize()
{
  __assert_rtn("Initialize", "MatrixResampler.cpp", 70, "nDFT >= 16u");
}

void IR::FFTSubFilterData::FFTSubFilterData(void **a1, void **a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  if (v5)
  {
    *(void *)(a3 + 48) = v5;
    operator delete(v5);
  }
  uint8_t v6 = *a2;
  if (*a2)
  {
    *(void *)(a3 + 24) = v6;
    operator delete(v6);
  }
}

void IR::PersonalizedIRData::Implementation::RegisterObservers()
{
  OUTLINED_FUNCTION_1_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  uint64_t v2 = "RegisterObservers";
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "[%s|%s] BTCloudServicesSoundProfile observer is registered.", v1, 0x16u);
}

{
  int v0;
  os_log_t v1;
  uint8_t v2[14];
  const char *v3;
  __int16 v4;
  int v5;

  OUTLINED_FUNCTION_1_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  uint64_t v3 = "RegisterObservers";
  uint64_t v4 = 1024;
  uint64_t v5 = v0;
  _os_log_error_impl(&dword_21B4DD000, v1, OS_LOG_TYPE_ERROR, "[%s|%s] BTCloudServicesSoundProfile observer registration failed. Error: %u", v2, 0x1Cu);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  const char *v3;
  int v4;

  OUTLINED_FUNCTION_1_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_4_1(&dword_21B4DD000, v0, v1, "[%s|%s] personalizedHRTFAllowed listener is registered for device ID: %u.", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Failed to register personalizedHRTFAllowed listener. Unknown device ID.", v2, v3, v4, v5, v6);
}

void IR::PersonalizedIRData::Implementation::UnregisterPersonalizedHRTFAllowedListener()
{
  OUTLINED_FUNCTION_1_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_4_1(&dword_21B4DD000, v0, v1, "[%s|%s] personalizedHRTFAllowed listener is unregistered for device ID: %u", v2, v3, v4);
}

void IR::PersonalizedIRData::HALListenerCallbackFunction(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "HALListenerCallbackFunction";
  _os_log_error_impl(&dword_21B4DD000, log, OS_LOG_TYPE_ERROR, "%s: Personalized HRIR configuration has changed, but the callback function returns invalid context. AUSM will ignore the change.", (uint8_t *)&v1, 0xCu);
}

void IR::PersonalizedIRData::Implementation::UnregisterBTCServicesAndMAObservers()
{
  OUTLINED_FUNCTION_1_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  uint64_t v2 = "UnregisterBTCServicesAndMAObservers";
  _os_log_debug_impl(&dword_21B4DD000, v0, OS_LOG_TYPE_DEBUG, "[%s|%s] BTCloudServicesSoundProfile observer is unregistered.", v1, 0x16u);
}

void IR::PersonalizedIRData::Implementation::GetCFData()
{
  OUTLINED_FUNCTION_1_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Timeout while trying to fetch SoundProfile.", v2, v3, v4, v5, v6);
}

void IR::DataCache::DownloadAndCacheCFData(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "GetEnrolledSoundProfileFromBTHAL";
  _os_log_error_impl(&dword_21B4DD000, log, OS_LOG_TYPE_ERROR, "%s: Invalid SoundProfile.", (uint8_t *)&v1, 0xCu);
}

void IR::DataCache::DownloadAndCacheCFData(int a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = 136315394;
  uint64_t v3 = "GetEnrolledSoundProfileFromBTHAL";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl(&dword_21B4DD000, a2, OS_LOG_TYPE_ERROR, "%s: Could not get object ID for the plugin. Error: %d", (uint8_t *)&v2, 0x12u);
}

void IR::DataCache::parseSoundProfileAndAddToCache()
{
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Pulled SoundProfile is not a valid dictionary.", v2, v3, v4, v5, v6);
}

void IR::DataCache::addToCFDataCachePrivate()
{
  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_1_0(&dword_21B4DD000, v0, v1, "[%s|%s] Invalid personalized HRTF type.", v2, v3, v4, v5, v6);
}

void IR::FFTFilterKernel::FFTFilterKernel(void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    OUTLINED_FUNCTION_0_2(v2, (uint64_t)a1);
  }
}

void IR::ComplexDataCircBuffer::Implementation::initialize()
{
  __assert_rtn("initialize", "ComplexDataCircBuffer.cpp", 86, "err == noErr");
}

void IR::MPResampler<float>::Interpolate()
{
  __assert_rtn("Interpolate", "MPResampler.cpp", 195, "inSig.size() >= mNumPositiveFreq");
}

{
  __assert_rtn("Interpolate", "MPResampler.cpp", 196, "outSig.size() >= mNumPositiveFreq");
}

OSStatus AudioFormatGetProperty(AudioFormatPropertyID inPropertyID, UInt32 inSpecifierSize, const void *inSpecifier, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return MEMORY[0x270F0FCF8](*(void *)&inPropertyID, *(void *)&inSpecifierSize, inSpecifier, ioPropertyDataSize, outPropertyData);
}

OSStatus AudioObjectAddPropertyListener(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, AudioObjectPropertyListenerProc inListener, void *inClientData)
{
  return MEMORY[0x270EE4118](*(void *)&inObjectID, inAddress, inListener, inClientData);
}

OSStatus AudioObjectGetPropertyData(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, UInt32 inQualifierDataSize, const void *inQualifierData, UInt32 *ioDataSize, void *outData)
{
  return MEMORY[0x270EE4128](*(void *)&inObjectID, inAddress, *(void *)&inQualifierDataSize, inQualifierData, ioDataSize, outData);
}

Boolean AudioObjectHasProperty(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress)
{
  return MEMORY[0x270EE4138](*(void *)&inObjectID, inAddress);
}

OSStatus AudioObjectRemovePropertyListener(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, AudioObjectPropertyListenerProc inListener, void *inClientData)
{
  return MEMORY[0x270EE4148](*(void *)&inObjectID, inAddress, inListener, inClientData);
}

OSStatus AudioObjectSetPropertyData(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, UInt32 inQualifierDataSize, const void *inQualifierData, UInt32 inDataSize, const void *inData)
{
  return MEMORY[0x270EE4158](*(void *)&inObjectID, inAddress, *(void *)&inQualifierDataSize, inQualifierData, *(void *)&inDataSize, inData);
}

uint64_t AudioSampleRateConverterCreate()
{
  return MEMORY[0x270F0FD00]();
}

uint64_t AudioSampleRateConverterDispose()
{
  return MEMORY[0x270F0FD08]();
}

uint64_t AudioSampleRateConverterGetExpectedNumberOfOutputFrames()
{
  return MEMORY[0x270F0FD10]();
}

uint64_t AudioSampleRateConverterGetRequiredNumberOfInputFrames()
{
  return MEMORY[0x270F0FD20]();
}

uint64_t AudioSampleRateConverterProcess()
{
  return MEMORY[0x270F0FD28]();
}

uint64_t AudioSampleRateConverterReset()
{
  return MEMORY[0x270F0FD38]();
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x270EE42F0](allocator, values, numValues, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x270EE4348]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x270EE4788](cf);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x270EE47C8](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x270EE47E8](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x270EE47F0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x270EE4838]();
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x270EE48F0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x270EE4908](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x270EE4930](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x270EE4948]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x270EE4998](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x270EE4C50](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x270EE4C58]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x270EE4CA0](key, applicationID);
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x270EE4D08](applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x270EE4D10](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x270EE4D40](allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x270EE4F60](allocator, capacity, callBacks);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x270EE50B0](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x270EE50B8](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x270EE50D0](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x270EE50E0](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x270EE5118](alloc, formatOptions, format, arguments);
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x270EE5150](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x270EE5170](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x270EE5178](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x270EE5180](theString, *(void *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x270EE51D8](theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x270EE5218]();
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x270EE5230](theString, suffix);
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x270EE5320](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x270EE5328](anURL, pathStyle);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x270EE53C0](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateFromFileSystemRepresentationRelativeToBase(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x270EE53C8](allocator, buffer, bufLen, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x270EE53E8](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x270EE5400](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x270EE5430](url, resolveAgainstBase, buffer, maxBufLen);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x270EE5448]();
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  return MEMORY[0x270EE5458](url, error);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x270F95F98]();
}

uint64_t MGCopyAnswerWithError()
{
  return MEMORY[0x270F95FA8]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x270F95FB8]();
}

uint64_t MGGetProductType()
{
  return MEMORY[0x270F95FD8]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x270F95FE8]();
}

uint64_t MGIsQuestionValid()
{
  return MEMORY[0x270F96018]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void caulk::concurrent::message::~message(caulk::concurrent::message *this)
{
}

uint64_t caulk::concurrent::messenger::shared_high_priority(caulk::concurrent::messenger *this)
{
  return MEMORY[0x270F87AA0](this);
}

uint64_t caulk::concurrent::messenger::drain(caulk::concurrent::messenger *this)
{
  return MEMORY[0x270F87AB0](this);
}

uint64_t caulk::concurrent::messenger::messenger()
{
  return MEMORY[0x270F87AC0]();
}

void caulk::concurrent::messenger::~messenger(caulk::concurrent::messenger *this)
{
}

uint64_t caulk::pooled_semaphore_mutex::_lock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x270F87AE8](this);
}

uint64_t caulk::pooled_semaphore_mutex::_unlock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x270F87AF0](this);
}

uint64_t caulk::pooled_semaphore_mutex::try_lock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x270F87AF8](this);
}

uint64_t caulk::pooled_semaphore_mutex::pooled_semaphore_mutex(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x270F87B00](this);
}

void IR::IRData::getInterpolatedTimeDomainCoeffs<std::vector<float>>()
{
  while (1)
    ;
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

const char *__cdecl std::exception::what(const std::exception *this)
{
  return (const char *)MEMORY[0x270F98310](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x270F98338](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::logic_error *a2)
{
  return (std::logic_error *)MEMORY[0x270F98340](this, a2);
}

void std::domain_error::~domain_error(std::domain_error *this)
{
}

{
  MEMORY[0x270F98368](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983B0](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983D0](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983D8](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
}

void std::overflow_error::~overflow_error(std::overflow_error *this)
{
}

{
  MEMORY[0x270F98400](this);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

void std::__call_once(std::once_flag::_State_type *a1, void *a2, void (__cdecl *a3)(void *))
{
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984A0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984E8](this, __pos, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x270F98508](this, __pos, __n1, __s, __n2);
}

uint64_t std::ostream::put()
{
  return MEMORY[0x270F98740]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x270F98748]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F98790]();
}

{
  return MEMORY[0x270F987A0]();
}

{
  return MEMORY[0x270F987A8]();
}

std::random_device *__cdecl std::random_device::random_device(std::random_device *this, const std::string *__token)
{
  return (std::random_device *)MEMORY[0x270F98838](this, __token);
}

void std::random_device::~random_device(std::random_device *this)
{
}

std::random_device::result_type std::random_device::operator()(std::random_device *this)
{
  return MEMORY[0x270F98848](this);
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x270F98870]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x270F988A8]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x270F988B0]();
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x270F98900](this);
}

void std::recursive_mutex::~recursive_mutex(std::recursive_mutex *this)
{
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
}

void std::condition_variable::__do_timed_wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk, std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> a3)
{
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x270F989E8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

BOOL std::mutex::try_lock(std::mutex *this)
{
  return MEMORY[0x270F98BB0](this);
}

void std::mutex::~mutex(std::mutex *this)
{
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x270F98C18]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x270F98C28]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x270F98DE8]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, float __val)
{
  return (std::string *)MEMORY[0x270F98E00](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x270F98E08](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x270F98E10](retstr, *(void *)&__val);
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x270ED7DA0](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

uint64_t __invert_d3()
{
  return MEMORY[0x270ED7E00]();
}

uint64_t __powisf2()
{
  return MEMORY[0x270ED7E68]();
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x270ED7E88](a1);
  result.__cosval = v2;
  result.__float sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x270ED7E90](a1);
  result.__cosval = v2;
  result.__float sinval = v1;
  return result;
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x270ED7F00](*(void *)&a1);
}

uint64_t _os_assert_log()
{
  return MEMORY[0x270ED8050]();
}

uint64_t _os_crash()
{
  return MEMORY[0x270ED8060]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x270ED8070]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x270F76310]();
}

void abort(void)
{
}

uint64_t abort_report_np()
{
  return MEMORY[0x270ED8458]();
}

float asinf(float a1)
{
  MEMORY[0x270ED8618](a1);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x270ED86B8](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

long double cos(long double __x)
{
  MEMORY[0x270ED9128](__x);
  return result;
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9458](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x270ED9510](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x270ED9628](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x270ED9648](__handle, __symbol);
}

long double exp(long double __x)
{
  MEMORY[0x270ED9858](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x270ED9860](__x);
  return result;
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

FILE *__cdecl fmemopen(void *__buf, size_t __size, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99C8](__buf, __size, __mode);
}

float fmodf(float a1, float a2)
{
  MEMORY[0x270ED99D8](a1, a2);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9A28](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x270ED9AC0](a1, a2, *(void *)&a3);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x270ED9B18](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

float hypotf(float a1, float a2)
{
  MEMORY[0x270ED9E60](a1, a2);
  return result;
}

long double log(long double __x)
{
  MEMORY[0x270EDA0A8](__x);
  return result;
}

float log2f(float a1)
{
  MEMORY[0x270EDA0E0](a1);
  return result;
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x270EDA138]();
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x270EDA738](*(void *)&token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x270EDA770](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x270F9A658](name);
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x270EDAAD8](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x270EDACF8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x270EDB010]();
}

long double sin(long double __x)
{
  MEMORY[0x270EDB4E8](__x);
  return result;
}

float sinf(float a1)
{
  MEMORY[0x270EDB4F0](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x270EDB560](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDB568](a1, a2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x270EDB7D8](a1, a2, a3, a4, a5);
}

void vDSP_DFT_DestroySetup(vDSP_DFT_Setup __Setup)
{
}

void vDSP_DFT_Execute(const vDSP_DFT_SetupStruct *__Setup, const float *__Ir, const float *__Ii, float *__Or, float *__Oi)
{
}

vDSP_DFT_Setup vDSP_DFT_zrop_CreateSetup(vDSP_DFT_Setup __Previous, vDSP_Length __Length, vDSP_DFT_Direction __Direction)
{
  return (vDSP_DFT_Setup)MEMORY[0x270EDE950](__Previous, __Length, *(void *)&__Direction);
}

void vDSP_conv(const float *__A, vDSP_Stride __IA, const float *__F, vDSP_Stride __IF, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
}

void vDSP_distancesq(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
}

void vDSP_dotpr(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
}

void vDSP_dotprD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Length __N)
{
}

void vDSP_maxmgv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_maxv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_meanvD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Length __N)
{
}

void vDSP_mmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_mtrans(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N)
{
}

void vDSP_svdiv(const float *__A, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_sve(const float *__A, vDSP_Stride __I, float *__C, vDSP_Length __N)
{
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_vadd(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vclip(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vclr(float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vclrD(double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vfill(const float *__A, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vfix16(const float *__A, vDSP_Stride __IA, __int16 *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vflt16(const __int16 *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vmma(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, const float *__D, vDSP_Stride __ID, float *__E, vDSP_Stride __IE, vDSP_Length __N)
{
}

void vDSP_vmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vramp(const float *__A, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vrampmul(const float *__I, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vrampmuladd(const float *__I, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsaddD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vsmsa(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vsmsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, const float *__D, float *__E, vDSP_Stride __IE, vDSP_Length __N)
{
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsorti(const float *__C, vDSP_Length *__I, vDSP_Length *__Temporary, vDSP_Length __N, int __Order)
{
}

void vDSP_vsq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsub(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zmmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_ztoc(const DSPSplitComplex *__Z, vDSP_Stride __IZ, DSPComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvadd(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvma(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_zvmags(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvmmaa(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__D, vDSP_Stride __ID, const DSPSplitComplex *__E, vDSP_Stride __IE, const DSPSplitComplex *__F, vDSP_Stride __IF, vDSP_Length __N)
{
}

void vDSP_zvmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N, int __Conjugate)
{
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x270EDBB18](__str, __size, __format, a4);
}

void vvexpf(float *a1, const float *a2, const int *a3)
{
}

void vvlogf(float *a1, const float *a2, const int *a3)
{
}

void vvsincosf(float *a1, float *a2, const float *a3, const int *a4)
{
}

void vvsqrtf(float *a1, const float *a2, const int *a3)
{
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x270EDBBE8](__s, *(void *)&__c, __n);
}